6,BLOCK,-1,,<empty>,1,,1,1,,ANY
15,BLOCK,-1,,<empty>,1,,1,1,,ANY
26,BLOCK,-1,,<empty>,1,,1,1,,ANY
37,BLOCK,-1,,<empty>,1,,1,1,,ANY
48,BLOCK,-1,,<empty>,1,,1,1,,ANY
57,BLOCK,-1,,<empty>,1,,1,1,,ANY
64,BLOCK,-1,,"{
  CHECK_NOT_NULL(env_);
  async_context_ = EmitAsyncInit(isolate, resource, name,
                                 trigger_async_id);
}",36,,19,5,,void
77,BLOCK,-1,,"{
  EmitAsyncDestroy(env_, async_context_);
}",33,,25,1,,void
87,BLOCK,-1,,"{
  return node::MakeCallback(env_->isolate(), get_resource(),
                            callback, argc, argv,
                            async_context_);
}",67,,31,4,,void
108,BLOCK,-1,,"{
  return node::MakeCallback(env_->isolate(), get_resource(),
                            method, argc, argv,
                            async_context_);
}",67,,39,4,,void
129,BLOCK,-1,,"{
  return node::MakeCallback(env_->isolate(), get_resource(),
                            symbol, argc, argv,
                            async_context_);
}",67,,47,4,,void
147,BLOCK,-1,,"{
  return resource_.Get(env_->isolate());
}",45,,53,1,,void
160,BLOCK,-1,,"{
  return async_context_.async_id;
}",46,,57,1,,void
168,BLOCK,-1,,"{
  return async_context_.trigger_async_id;
}",54,,61,1,,void
177,BLOCK,-1,,<empty>,48,,68,2,,void
182,BLOCK,-1,,"{
    if (env_->is_stopping()) {
      MarkAsFailed();
      env_->async_hooks()->clear_async_id_stack();
    }
  }",39,,103,1,,void
188,BLOCK,-1,,"{
      MarkAsFailed();
      env_->async_hooks()->clear_async_id_stack();
    }",30,,104,2,,void
202,BLOCK,-1,,{ isolate->SetIdle(true); },34,,114,1,,void
213,BLOCK,-1,,{ env_->RunWeakRefCleanup(); },45,,133,1,,void
231,BLOCK,-1,,<empty>,1,,1,1,,ANY
237,BLOCK,-1,,<empty>,76,,22,4,,void
244,BLOCK,-1,,"{
  try_catch_.SetVerbose(true);
}",32,,30,4,,void
253,BLOCK,-1,,"{
  if (try_catch_.HasCaught())
    private_->MarkAsFailed();
  delete private_;
}",33,,34,1,,void
259,BLOCK,-1,,<empty>,5,,36,2,,void
271,BLOCK,-1,,<empty>,36,,45,3,,void
279,BLOCK,-1,,"{
  CHECK_NOT_NULL(env);
  env->PushAsyncCallbackScope();

  if (!env->can_call_into_js()) {
    failed_ = true;
    return;
  }

  Isolate* isolate = env->isolate();

  HandleScope handle_scope(isolate);
  Local<Context> current_context = isolate->GetCurrentContext();
  // If you hit this assertion, the caller forgot to enter the right Node.js
  // Environment's v8::Context first.
  // We first check `env->context() != current_context` because the contexts
  // likely *are* the same, in which case we can skip the slightly more
  // expensive Environment::GetCurrent() call.
  if (UNLIKELY(env->context() != current_context)) {
    CHECK_EQ(Environment::GetCurrent(isolate), env);
  }

  isolate->SetIdle(false);

  env->async_hooks()->push_async_context(
    async_context_.async_id, async_context_.trigger_async_id, object);

  pushed_ids_ = true;

  if (asyncContext.async_id != 0 && !skip_hooks_) {
    // No need to check a return value because the application will exit if
    // an ex...",48,,55,5,,void
292,BLOCK,-1,,"{
    failed_ = true;
    return;
  }",33,,59,2,,void
325,BLOCK,-1,,"{
    CHECK_EQ(Environment::GetCurrent(isolate), env);
  }",52,,73,2,,void
364,BLOCK,-1,,"{
    // No need to check a return value because the application will exit if
    // an exception occurs.
    AsyncWrap::EmitBefore(env, asyncContext.async_id);
  }",51,,84,2,,void
376,BLOCK,-1,,"{
  Close();
  env_->PopAsyncCallbackScope();
}",49,,91,1,,void
385,BLOCK,-1,,"{
  if (closed_) return;
  closed_ = true;

  // This function must ends up with either cleanup the
  // async id stack or pop the topmost one from it

  auto perform_stopping_check = [&]() {
    if (env_->is_stopping()) {
      MarkAsFailed();
      env_->async_hooks()->clear_async_id_stack();
    }
  };
  perform_stopping_check();

  if (env_->is_stopping()) return;

  Isolate* isolate = env_->isolate();
  auto idle = OnScopeLeave([&]() { isolate->SetIdle(true); });

  if (!failed_ && async_context_.async_id != 0 && !skip_hooks_) {
    AsyncWrap::EmitAfter(env_, async_context_.async_id);
  }

  if (pushed_ids_)
    env_->async_hooks()->pop_async_context(async_context_.async_id);

  if (failed_) return;

  if (env_->async_callback_scope_depth() > 1 || skip_task_queues_) {
    return;
  }

  TickInfo* tick_info = env_->tick_info();

  if (!env_->can_call_into_js()) return;

  auto weakref_cleanup = OnScopeLeave([&]() { env_->RunWeakRefCleanup(); });

  Local<Context> context = env_-...",37,,96,1,,void
388,BLOCK,-1,,<empty>,16,,97,2,,void
403,BLOCK,-1,,<empty>,28,,111,2,,void
428,BLOCK,-1,,"{
    AsyncWrap::EmitAfter(env_, async_context_.async_id);
  }",65,,116,2,,void
439,BLOCK,-1,,<empty>,5,,121,2,,void
452,BLOCK,-1,,<empty>,16,,123,2,,void
463,BLOCK,-1,,"{
    return;
  }",68,,125,2,,void
478,BLOCK,-1,,<empty>,34,,131,2,,void
501,BLOCK,-1,,"{
    context->GetMicrotaskQueue()->PerformCheckpoint(isolate);

    perform_stopping_check();
  }",41,,136,2,,void
523,BLOCK,-1,,"{
    CHECK_EQ(env_->execution_async_id(), 0);
    CHECK_EQ(env_->trigger_async_id(), 0);
  }",59,,144,2,,void
548,BLOCK,-1,,"{
    return;
  }",80,,149,2,,void
569,BLOCK,-1,,<empty>,34,,156,2,,void
599,BLOCK,-1,,"{
    failed_ = true;
  }",68,,164,2,,void
614,BLOCK,-1,,"{
  CHECK(!recv.IsEmpty());
#ifdef DEBUG
  for (int i = 0; i < argc; i++)
    CHECK(!argv[i].IsEmpty());
#endif

  Local<Function> hook_cb = env->async_hooks_callback_trampoline();
  int flags = InternalCallbackScope::kNoFlags;
  bool use_async_hooks_trampoline = false;
  AsyncHooks* async_hooks = env->async_hooks();
  if (!hook_cb.IsEmpty()) {
    // Use the callback trampoline if there are any before or after hooks, or
    // we can expect some kind of usage of async_hooks.executionAsyncResource().
    flags = InternalCallbackScope::kSkipAsyncHooks;
    use_async_hooks_trampoline =
        async_hooks->fields()[AsyncHooks::kBefore] +
        async_hooks->fields()[AsyncHooks::kAfter] +
        async_hooks->fields()[AsyncHooks::kUsesExecutionAsyncResource] > 0;
  }

  InternalCallbackScope scope(env, resource, asyncContext, flags);
  if (scope.Failed()) {
    return MaybeLocal<Value>();
  }

  MaybeLocal<Value> ret;

  Local<Context> context = env->context();
  if (use_async_hooks_t...",68,,176,8,,void
654,BLOCK,-1,,"{
    // Use the callback trampoline if there are any before or after hooks, or
    // we can expect some kind of usage of async_hooks.executionAsyncResource().
    flags = InternalCallbackScope::kSkipAsyncHooks;
    use_async_hooks_trampoline =
        async_hooks->fields()[AsyncHooks::kBefore] +
        async_hooks->fields()[AsyncHooks::kAfter] +
        async_hooks->fields()[AsyncHooks::kUsesExecutionAsyncResource] > 0;
  }",27,,187,2,,void
701,BLOCK,-1,,"{
    return MaybeLocal<Value>();
  }",23,,198,2,,void
721,BLOCK,-1,,"{
    MaybeStackBuffer<Local<Value>, 16> args(3 + argc);
    args[0] = v8::Number::New(env->isolate(), asyncContext.async_id);
    args[1] = resource;
    args[2] = callback;
    for (int i = 0; i < argc; i++) {
      args[i + 3] = argv[i];
    }
    ret = hook_cb->Call(context, recv, args.length(), &args[0]);
  }",35,,205,2,,void
755,BLOCK,-1,,<empty>,5,,210,1,,void
765,BLOCK,4,,"{
      args[i + 3] = argv[i];
    }",36,,210,4,,void
792,BLOCK,-1,,"{
    ret = callback->Call(context, recv, argc, argv);
  }",10,,214,1,,void
808,BLOCK,-1,,"{
    scope.MarkAsFailed();
    return MaybeLocal<Value>();
  }",22,,218,2,,void
824,BLOCK,-1,,"{
    return MaybeLocal<Value>();
  }",23,,224,2,,void
838,BLOCK,-1,,"{
  Local<String> method_string =
      String::NewFromUtf8(isolate, method).ToLocalChecked();
  return MakeCallback(isolate, recv, method_string, argc, argv, asyncContext);
}",60,,238,7,,void
871,BLOCK,-1,,"{
  // Check can_call_into_js() first because calling Get() might do so.
  Environment* env =
      Environment::GetCurrent(recv->GetCreationContext().ToLocalChecked());
  CHECK_NOT_NULL(env);
  if (!env->can_call_into_js()) return Local<Value>();

  Local<Value> callback_v;
  if (!recv->Get(isolate->GetCurrentContext(), symbol).ToLocal(&callback_v))
    return Local<Value>();
  if (!callback_v->IsFunction()) {
    // This used to return an empty value, but Undefined() makes more sense
    // since no exception is pending here.
    return Undefined(isolate);
  }
  Local<Function> callback = callback_v.As<Function>();
  return MakeCallback(isolate, recv, callback, argc, argv, asyncContext);
}",60,,249,7,,void
894,BLOCK,-1,,<empty>,33,,254,2,,void
918,BLOCK,-1,,<empty>,5,,258,2,,void
927,BLOCK,-1,,"{
    // This used to return an empty value, but Undefined() makes more sense
    // since no exception is pending here.
    return Undefined(isolate);
  }",34,,259,2,,void
958,BLOCK,-1,,"{
  // Observe the following two subtleties:
  //
  // 1. The environment is retrieved from the callback function's context.
  // 2. The context to enter is retrieved from the environment.
  //
  // Because of the AssignToContext() call in src/node_contextify.cc,
  // the two contexts need not be the same.
  Environment* env =
      Environment::GetCurrent(callback->GetCreationContext().ToLocalChecked());
  CHECK_NOT_NULL(env);
  Context::Scope context_scope(env->context());
  MaybeLocal<Value> ret =
      InternalMakeCallback(env, recv, recv, callback, argc, argv, asyncContext);
  if (ret.IsEmpty() && env->async_callback_scope_depth() == 0) {
    // This is only for legacy compatibility and we may want to look into
    // removing/adjusting it.
    return Undefined(isolate);
  }
  return ret;
}",60,,273,7,,void
1007,BLOCK,-1,,"{
    // This is only for legacy compatibility and we may want to look into
    // removing/adjusting it.
    return Undefined(isolate);
  }",64,,287,2,,void
1021,BLOCK,-1,,"{
  Environment* env =
      Environment::GetCurrent(callback->GetCreationContext().ToLocalChecked());
  CHECK_NOT_NULL(env);
  if (!env->can_call_into_js()) return Local<Value>();

  Local<Context> context = env->context();
  Context::Scope context_scope(context);
  if (env->async_callback_scope_depth()) {
    // There's another MakeCallback() on the stack, piggy back on it.
    // In particular, retain the current async_context.
    return callback->Call(context, recv, argc, argv);
  }

  // This is a toplevel invocation and the caller (intentionally)
  // didn't provide any async_context to run in. Install a default context.
  MaybeLocal<Value> ret =
    InternalMakeCallback(env, env->process_object(), recv, callback, argc, argv,
                         async_context{0, 0});
  return ret;
}",57,,303,6,,void
1044,BLOCK,-1,,<empty>,33,,307,2,,void
1065,BLOCK,-1,,"{
    // There's another MakeCallback() on the stack, piggy back on it.
    // In particular, retain the current async_context.
    return callback->Call(context, recv, argc, argv);
  }",42,,311,2,,void
1105,BLOCK,-1,,"{
  EscapableHandleScope handle_scope(isolate);
  return handle_scope.Escape(
      MakeCallback(isolate, recv, method, argc, argv, {0, 0})
          .FromMaybe(Local<Value>()));
}",47,,331,6,,void
1135,BLOCK,-1,,"{
  EscapableHandleScope handle_scope(isolate);
  return handle_scope.Escape(
      MakeCallback(isolate, recv, symbol, argc, argv, {0, 0})
          .FromMaybe(Local<Value>()));
}",47,,342,6,,void
1165,BLOCK,-1,,"{
  EscapableHandleScope handle_scope(isolate);
  return handle_scope.Escape(
      MakeCallback(isolate, recv, callback, argc, argv, {0, 0})
          .FromMaybe(Local<Value>()));
}",47,,353,6,,void
1192,BLOCK,-1,,{ realm->VerifyNoStrongBaseObjects(); },38,,75,2,,void
1202,BLOCK,-1,,"{
      if (bootstrapCatch.HasCaught()) {
        errors->push_back(FormatCaughtException(
            isolate, isolate->GetCurrentContext(), bootstrapCatch));
      }
    }",47,,136,1,,void
1208,BLOCK,-1,,"{
        errors->push_back(FormatCaughtException(
            isolate, isolate->GetCurrentContext(), bootstrapCatch));
      }",39,,137,2,,void
1227,BLOCK,-1,,"{
        return CreateEnvironment(
            setup->isolate_data(),
            setup->context(),
            args,
            exec_args,
            static_cast<EnvironmentFlags::Flags>(env_flags));
      }",64,,192,2,,void
1251,BLOCK,-1,,"{
      *static_cast<bool*>(data) = true;
    }",73,,217,2,,void
1271,BLOCK,-1,,<empty>,1,,1,1,,ANY
1275,BLOCK,-1,,"{
  CHECK_NOT_NULL(env);
  MultiIsolatePlatform* platform = GetMultiIsolatePlatform(env);
  CHECK_NOT_NULL(platform);

  Isolate* isolate = env->isolate();
  HandleScope handle_scope(isolate);
  Context::Scope context_scope(env->context());
  SealHandleScope seal(isolate);

  if (env->is_stopping()) return Nothing<ExitCode>();

  env->set_trace_sync_io(env->options()->trace_sync_io);
  {
    bool more;
    env->performance_state()->Mark(
        node::performance::NODE_PERFORMANCE_MILESTONE_LOOP_START);
    do {
      if (env->is_stopping()) break;
      uv_run(env->event_loop(), UV_RUN_DEFAULT);
      if (env->is_stopping()) break;

      platform->DrainTasks(isolate);

      more = uv_loop_alive(env->event_loop());
      if (more && !env->is_stopping()) continue;

      if (EmitProcessBeforeExit(env).IsNothing())
        break;

      {
        HandleScope handle_scope(isolate);
        if (env->RunSnapshotSerializeCallback().IsEmpty()) {
          break;
        }
      }

      ...",57,,22,2,,void
1309,BLOCK,-1,,<empty>,27,,32,2,,void
1322,BLOCK,15,,"{
    bool more;
    env->performance_state()->Mark(
        node::performance::NODE_PERFORMANCE_MILESTONE_LOOP_START);
    do {
      if (env->is_stopping()) break;
      uv_run(env->event_loop(), UV_RUN_DEFAULT);
      if (env->is_stopping()) break;

      platform->DrainTasks(isolate);

      more = uv_loop_alive(env->event_loop());
      if (more && !env->is_stopping()) continue;

      if (EmitProcessBeforeExit(env).IsNothing())
        break;

      {
        HandleScope handle_scope(isolate);
        if (env->RunSnapshotSerializeCallback().IsEmpty()) {
          break;
        }
      }

      // Emit `beforeExit` if the loop became alive either after emitting
      // event, or after running some callbacks.
      more = uv_loop_alive(env->event_loop());
    } while (more == true && !env->is_stopping());
    env->performance_state()->Mark(
        node::performance::NODE_PERFORMANCE_MILESTONE_LOOP_EXIT);
  }",3,,35,15,,void
1337,BLOCK,-1,,"{
      if (env->is_stopping()) break;
      uv_run(env->event_loop(), UV_RUN_DEFAULT);
      if (env->is_stopping()) break;

      platform->DrainTasks(isolate);

      more = uv_loop_alive(env->event_loop());
      if (more && !env->is_stopping()) continue;

      if (EmitProcessBeforeExit(env).IsNothing())
        break;

      {
        HandleScope handle_scope(isolate);
        if (env->RunSnapshotSerializeCallback().IsEmpty()) {
          break;
        }
      }

      // Emit `beforeExit` if the loop became alive either after emitting
      // event, or after running some callbacks.
      more = uv_loop_alive(env->event_loop());
    }",8,,39,1,,void
1343,BLOCK,-1,,<empty>,31,,40,2,,void
1356,BLOCK,-1,,<empty>,31,,42,2,,void
1378,BLOCK,-1,,<empty>,40,,47,2,,void
1386,BLOCK,-1,,<empty>,9,,50,2,,void
1388,BLOCK,8,,"{
        HandleScope handle_scope(isolate);
        if (env->RunSnapshotSerializeCallback().IsEmpty()) {
          break;
        }
      }",7,,52,8,,void
1400,BLOCK,-1,,"{
          break;
        }",60,,54,2,,void
1435,BLOCK,-1,,<empty>,27,,66,2,,void
1472,BLOCK,-1,,<empty>,,,,1,,<empty>
1486,BLOCK,-1,,"{
  CHECK_NOT_NULL(platform);
  CHECK_NOT_NULL(errors);

  impl_->platform = platform;
  uv_loop_t* loop = &impl_->loop;
  // Use `data` to tell the destructor whether the loop was initialized or not.
  loop->data = nullptr;
  int ret = uv_loop_init(loop);
  if (ret != 0) {
    errors->push_back(
        SPrintF(""Failed to initialize loop: %s"", uv_err_name(ret)));
    return;
  }
  loop->data = this;

  Isolate* isolate;
  if (flags & Flags::kIsForSnapshotting) {
    const std::vector<intptr_t>& external_references =
        SnapshotBuilder::CollectExternalReferences();
    isolate = impl_->isolate = Isolate::Allocate();
    // Must be done before the SnapshotCreator creation so  that the
    // memory reducer can be initialized.
    platform->RegisterIsolate(isolate, loop);
    impl_->snapshot_creator.emplace(isolate, external_references.data());
    isolate->SetCaptureStackTraceForUncaughtExceptions(
        true, 10, v8::StackTrace::StackTraceOptions::kDetailed);
    SetIsolateMi...",25,,96,6,,void
1517,BLOCK,-1,,"{
    errors->push_back(
        SPrintF(""Failed to initialize loop: %s"", uv_err_name(ret)));
    return;
  }",17,,105,2,,void
1541,BLOCK,-1,,"{
    const std::vector<intptr_t>& external_references =
        SnapshotBuilder::CollectExternalReferences();
    isolate = impl_->isolate = Isolate::Allocate();
    // Must be done before the SnapshotCreator creation so  that the
    // memory reducer can be initialized.
    platform->RegisterIsolate(isolate, loop);
    impl_->snapshot_creator.emplace(isolate, external_references.data());
    isolate->SetCaptureStackTraceForUncaughtExceptions(
        true, 10, v8::StackTrace::StackTraceOptions::kDetailed);
    SetIsolateMiscHandlers(isolate, {});
  }",42,,113,2,,void
1593,BLOCK,-1,,"{
    impl_->allocator = ArrayBufferAllocator::Create();
    isolate = impl_->isolate =
        NewIsolate(impl_->allocator, &impl_->loop, platform, snapshot_data);
  }",10,,124,1,,void
1618,BLOCK,13,,"{
    Locker locker(isolate);
    Isolate::Scope isolate_scope(isolate);
    HandleScope handle_scope(isolate);

    TryCatch bootstrapCatch(isolate);
    auto print_Exception = OnScopeLeave([&]() {
      if (bootstrapCatch.HasCaught()) {
        errors->push_back(FormatCaughtException(
            isolate, isolate->GetCurrentContext(), bootstrapCatch));
      }
    });

    impl_->isolate_data.reset(CreateIsolateData(
        isolate, loop, platform, impl_->allocator.get(), snapshot_data));
    impl_->isolate_data->options()->build_snapshot =
        impl_->snapshot_creator.has_value();

    if (snapshot_data) {
      impl_->env.reset(make_env(this));
      if (impl_->env) {
        impl_->main_context.Reset(isolate, impl_->env->context());
      }
      return;
    }

    Local<Context> context = NewContext(isolate);
    impl_->main_context.Reset(isolate, context);
    if (context.IsEmpty()) {
      errors->push_back(""Failed to initialize V8 Context"");
      return;
    }

    Con...",3,,130,13,,void
1669,BLOCK,-1,,"{
      impl_->env.reset(make_env(this));
      if (impl_->env) {
        impl_->main_context.Reset(isolate, impl_->env->context());
      }
      return;
    }",24,,148,2,,void
1682,BLOCK,-1,,"{
        impl_->main_context.Reset(isolate, impl_->env->context());
      }",23,,150,2,,void
1718,BLOCK,-1,,"{
      errors->push_back(""Failed to initialize V8 Context"");
      return;
    }",28,,158,2,,void
1742,BLOCK,-1,,<empty>,74,,172,4,,void
1748,BLOCK,-1,,"{
  // It's not guaranteed that a context that goes through
  // v8_inspector::V8Inspector::contextCreated() is runtime-independent,
  // so do not start the inspector on the main context when building
  // the default snapshot.
  uint64_t env_flags =
      EnvironmentFlags::kDefaultFlags | EnvironmentFlags::kNoCreateInspector;

  auto ret = std::unique_ptr<CommonEnvironmentSetup>(new CommonEnvironmentSetup(
      platform,
      errors,
      nullptr,
      true,
      [&](const CommonEnvironmentSetup* setup) -> Environment* {
        return CreateEnvironment(
            setup->isolate_data(),
            setup->context(),
            args,
            exec_args,
            static_cast<EnvironmentFlags::Flags>(env_flags));
      }));
  if (!errors->empty()) ret.reset();
  return ret;
}",48,,179,5,,void
1780,BLOCK,-1,,<empty>,25,,200,2,,void
1790,BLOCK,-1,,"{
  if (impl_->isolate != nullptr) {
    Isolate* isolate = impl_->isolate;
    {
      Locker locker(isolate);
      Isolate::Scope isolate_scope(isolate);

      impl_->main_context.Reset();
      impl_->env.reset();
      impl_->isolate_data.reset();
    }

    bool platform_finished = false;
    impl_->platform->AddIsolateFinishedCallback(isolate, [](void* data) {
      *static_cast<bool*>(data) = true;
    }, &platform_finished);
    impl_->platform->UnregisterIsolate(isolate);
    if (impl_->snapshot_creator.has_value())
      impl_->snapshot_creator.reset();
    else
      isolate->Dispose();

    // Wait until the platform has cleaned up all relevant resources.
    while (!platform_finished)
      uv_run(&impl_->loop, UV_RUN_ONCE);
  }

  if (impl_->isolate || impl_->loop.data != nullptr)
    CheckedUvLoopClose(&impl_->loop);

  delete impl_;
}",51,,204,1,,void
1797,BLOCK,-1,,"{
    Isolate* isolate = impl_->isolate;
    {
      Locker locker(isolate);
      Isolate::Scope isolate_scope(isolate);

      impl_->main_context.Reset();
      impl_->env.reset();
      impl_->isolate_data.reset();
    }

    bool platform_finished = false;
    impl_->platform->AddIsolateFinishedCallback(isolate, [](void* data) {
      *static_cast<bool*>(data) = true;
    }, &platform_finished);
    impl_->platform->UnregisterIsolate(isolate);
    if (impl_->snapshot_creator.has_value())
      impl_->snapshot_creator.reset();
    else
      isolate->Dispose();

    // Wait until the platform has cleaned up all relevant resources.
    while (!platform_finished)
      uv_run(&impl_->loop, UV_RUN_ONCE);
  }",34,,205,2,,void
1804,BLOCK,3,,"{
      Locker locker(isolate);
      Isolate::Scope isolate_scope(isolate);

      impl_->main_context.Reset();
      impl_->env.reset();
      impl_->isolate_data.reset();
    }",5,,207,3,,void
1857,BLOCK,-1,,<empty>,7,,222,2,,void
1865,BLOCK,-1,,<empty>,7,,224,1,,void
1891,BLOCK,-1,,<empty>,5,,232,2,,void
1902,BLOCK,-1,,"{
  CHECK_NOT_NULL(snapshot_creator());
  SnapshotData* snapshot_data = new SnapshotData();
  EmbedderSnapshotData::Pointer result{
      new EmbedderSnapshotData(snapshot_data, true)};

  auto exit_code = SnapshotBuilder::CreateSnapshot(
      snapshot_data,
      this,
      static_cast<uint8_t>(SnapshotMetadata::Type::kFullyCustomized));
  if (exit_code != ExitCode::kNoFailure) return {};

  return result;
}",72,,237,1,,void
1940,BLOCK,-1,,<empty>,42,,247,2,,void
1948,BLOCK,-1,,"{
  Maybe<ExitCode> result = SpinEventLoopInternal(env);
  if (result.IsNothing()) {
    return Nothing<int>();
  }
  return Just(static_cast<int>(result.FromJust()));
}",44,,252,2,,void
1962,BLOCK,-1,,"{
    return Nothing<int>();
  }",27,,254,2,,void
1976,BLOCK,-1,,"{
  return &impl_->loop;
}",55,,260,1,,void
1985,BLOCK,-1,,"{
  return impl_->allocator;
}",56,,265,1,,void
1993,BLOCK,-1,,"{
  return impl_->isolate;
}",50,,269,1,,void
2001,BLOCK,-1,,"{
  return impl_->isolate_data.get();
}",59,,273,1,,void
2012,BLOCK,-1,,"{
  return impl_->env.get();
}",50,,277,1,,void
2023,BLOCK,-1,,"{
  return impl_->main_context.Get(impl_->isolate);
}",64,,281,1,,void
2037,BLOCK,-1,,"{
  return impl_->snapshot_creator ? &impl_->snapshot_creator.value() : nullptr;
}",65,,285,1,,void
2055,BLOCK,-1,,"{
  CHECK_IMPLIES(data->owns_impl_, data->impl_);
  if (data->owns_impl_ &&
      data->impl_->data_ownership == SnapshotData::DataOwnership::kOwned) {
    delete data->impl_;
  }
  delete data;
}",45,,290,2,,void
2079,BLOCK,-1,,"{
    delete data->impl_;
  }",75,,293,2,,void
2089,BLOCK,-1,,"{
  return EmbedderSnapshotData::Pointer{new EmbedderSnapshotData(
      SnapshotBuilder::GetEmbeddedSnapshotData(), false)};
}",75,,299,1,,void
2104,BLOCK,-1,,"{
  SnapshotData* snapshot_data = new SnapshotData();
  CHECK_EQ(snapshot_data->data_ownership, SnapshotData::DataOwnership::kOwned);
  EmbedderSnapshotData::Pointer result{
      new EmbedderSnapshotData(snapshot_data, true)};
  if (!SnapshotData::FromBlob(snapshot_data, in)) {
    return {};
  }
  return result;
}",34,,305,2,,void
2135,BLOCK,-1,,"{
    return {};
  }",51,,310,2,,void
2143,BLOCK,-1,,"{
  return FromBlob(ReadFileSync(in));
}",72,,316,2,,void
2151,BLOCK,-1,,"{
  return impl_->ToBlob();
}",56,,320,1,,void
2161,BLOCK,-1,,"{
  impl_->ToFile(out);
}",52,,324,2,,void
2172,BLOCK,-1,,<empty>,42,,330,3,,void
2176,BLOCK,-1,,"{
#ifdef NODE_V8_SHARED_RO_HEAP
  return false;
#else
  return true;
#endif
}",61,,332,1,,void
2193,BLOCK,-1,,<empty>,1,,1,1,,ANY
2198,BLOCK,-1,,"{
  switch (encoding[0]) {
    case 'u':
    case 'U':
      // Note: the two first conditions are needed for performance reasons
      // as ""utf8""/""utf-8"" is a common case.
      // (same for other cases below)

      // utf8, utf16le
      if (encoding[1] == 't' && encoding[2] == 'f') {
        // Skip `-`
        const size_t skip = encoding[3] == '-' ? 4 : 3;
        if (encoding[skip] == '8' && encoding[skip + 1] == '\0')
          return UTF8;
        if (strncmp(encoding + skip, ""16le"", 5) == 0)
          return UCS2;
      // ucs2
      } else if (encoding[1] == 'c' && encoding[2] == 's') {
        const size_t skip = encoding[3] == '-' ? 4 : 3;
        if (encoding[skip] == '2' && encoding[skip + 1] == '\0')
          return UCS2;
      }
      if (StringEqualNoCase(encoding, ""utf8""))
        return UTF8;
      if (StringEqualNoCase(encoding, ""utf-8""))
        return UTF8;
      if (StringEqualNoCase(encoding, ""ucs2""))
        return UCS2;
      if (StringEqualNoCase(encod...",61,,14,3,,void
2203,BLOCK,-1,,"{
    case 'u':
    case 'U':
      // Note: the two first conditions are needed for performance reasons
      // as ""utf8""/""utf-8"" is a common case.
      // (same for other cases below)

      // utf8, utf16le
      if (encoding[1] == 't' && encoding[2] == 'f') {
        // Skip `-`
        const size_t skip = encoding[3] == '-' ? 4 : 3;
        if (encoding[skip] == '8' && encoding[skip + 1] == '\0')
          return UTF8;
        if (strncmp(encoding + skip, ""16le"", 5) == 0)
          return UCS2;
      // ucs2
      } else if (encoding[1] == 'c' && encoding[2] == 's') {
        const size_t skip = encoding[3] == '-' ? 4 : 3;
        if (encoding[skip] == '2' && encoding[skip + 1] == '\0')
          return UCS2;
      }
      if (StringEqualNoCase(encoding, ""utf8""))
        return UTF8;
      if (StringEqualNoCase(encoding, ""utf-8""))
        return UTF8;
      if (StringEqualNoCase(encoding, ""ucs2""))
        return UCS2;
      if (StringEqualNoCase(encoding, ""ucs-2""))
        re...",24,,15,2,,void
2220,BLOCK,-1,,"{
        // Skip `-`
        const size_t skip = encoding[3] == '-' ? 4 : 3;
        if (encoding[skip] == '8' && encoding[skip + 1] == '\0')
          return UTF8;
        if (strncmp(encoding + skip, ""16le"", 5) == 0)
          return UCS2;
      // ucs2
      }",53,,23,2,,void
2246,BLOCK,-1,,<empty>,11,,27,2,,void
2258,BLOCK,-1,,<empty>,11,,29,2,,void
2262,BLOCK,-1,,<empty>,14,,31,1,,void
2275,BLOCK,-1,,"{
        const size_t skip = encoding[3] == '-' ? 4 : 3;
        if (encoding[skip] == '2' && encoding[skip + 1] == '\0')
          return UCS2;
      }",60,,31,2,,void
2301,BLOCK,-1,,<empty>,11,,34,2,,void
2308,BLOCK,-1,,<empty>,9,,37,2,,void
2315,BLOCK,-1,,<empty>,9,,39,2,,void
2322,BLOCK,-1,,<empty>,9,,41,2,,void
2329,BLOCK,-1,,<empty>,9,,43,2,,void
2336,BLOCK,-1,,<empty>,9,,45,2,,void
2343,BLOCK,-1,,<empty>,9,,47,2,,void
2357,BLOCK,-1,,"{
        if (strncmp(encoding + 2, ""tin1"", 5) == 0)
          return LATIN1;
      }",31,,53,2,,void
2367,BLOCK,-1,,<empty>,11,,55,2,,void
2374,BLOCK,-1,,<empty>,9,,58,2,,void
2388,BLOCK,-1,,"{
        if (strncmp(encoding + 2, ""nary"", 5) == 0)
          return LATIN1;
      // buffer
      }",31,,64,2,,void
2398,BLOCK,-1,,<empty>,11,,66,2,,void
2402,BLOCK,-1,,<empty>,14,,68,1,,void
2409,BLOCK,-1,,"{
        if (strncmp(encoding + 2, ""ffer"", 5) == 0)
          return BUFFER;
      // base64
      }",38,,68,2,,void
2419,BLOCK,-1,,<empty>,11,,70,2,,void
2423,BLOCK,-1,,<empty>,14,,72,1,,void
2430,BLOCK,-1,,"{
        if (strncmp(encoding + 2, ""se64"", 5) == 0)
          return BASE64;
        if (strncmp(encoding + 2, ""se64url"", 8) == 0)
          return BASE64URL;
      }",38,,72,2,,void
2440,BLOCK,-1,,<empty>,11,,74,2,,void
2452,BLOCK,-1,,<empty>,11,,76,2,,void
2459,BLOCK,-1,,<empty>,9,,79,2,,void
2466,BLOCK,-1,,<empty>,9,,81,2,,void
2473,BLOCK,-1,,<empty>,9,,83,2,,void
2480,BLOCK,-1,,<empty>,9,,85,2,,void
2494,BLOCK,-1,,"{
        if (strncmp(encoding + 2, ""cii"", 4) == 0)
          return ASCII;
      }",31,,91,2,,void
2504,BLOCK,-1,,<empty>,11,,93,2,,void
2511,BLOCK,-1,,<empty>,9,,96,2,,void
2525,BLOCK,-1,,<empty>,9,,103,2,,void
2538,BLOCK,-1,,<empty>,11,,104,2,,void
2545,BLOCK,-1,,<empty>,9,,106,2,,void
2557,BLOCK,-1,,"{
  CHECK(!encoding_v.IsEmpty());

  if (!encoding_v->IsString())
    return default_encoding;

  Utf8Value encoding(isolate, encoding_v);

  return ParseEncoding(*encoding, default_encoding);
}",61,,115,4,,void
2570,BLOCK,-1,,<empty>,5,,119,2,,void
2589,BLOCK,-1,,"{
  CHECK_NE(encoding, UCS2);
  Local<Value> error;
  return StringBytes::Encode(isolate, buf, len, encoding, &error)
      .ToLocalChecked();
}",45,,129,5,,void
2618,BLOCK,-1,,"{
  Local<Value> error;
  return StringBytes::Encode(isolate, buf, len, &error)
      .ToLocalChecked();
}",72,,136,4,,void
2643,BLOCK,-1,,"{
  HandleScope scope(isolate);

  return StringBytes::Size(isolate, val, encoding).FromMaybe(-1);
}",45,,145,4,,void
2668,BLOCK,-1,,"{
  return StringBytes::Write(isolate, buf, buflen, val, encoding);
}",45,,156,6,,void
2684,BLOCK,-1,,"{
        Local<Value> main_script =
            ToV8Value(env->context(), main_script_source_utf8).ToLocalChecked();
        return info.run_cjs->Call(
            env->context(), Null(env->isolate()), 1, &main_script);
      }",77,,556,2,,void
2728,BLOCK,-1,,"{
    movedHandler(env, static_cast<int>(exit_code));
  }",75,,932,3,,void
2774,BLOCK,-1,,<empty>,1,,1,1,,ANY
2779,BLOCK,-1,,"{
  Local<Value> wasm_code_gen =
      context->GetEmbedderData(ContextEmbedderIndex::kAllowWasmCodeGeneration);
  return wasm_code_gen->IsUndefined() || wasm_code_gen->IsTrue();
}",53,,48,3,,void
2807,BLOCK,-1,,"{
  DebugSealHandleScope scope(isolate);
  Environment* env = Environment::GetCurrent(isolate);
  return env != nullptr &&
         (env->is_main_thread() || !env->is_stopping()) &&
         env->abort_on_uncaught_exception() &&
         env->should_abort_on_uncaught_toggle()[0] &&
         !env->inside_should_not_abort_on_uncaught_scope();
}",55,,54,2,,void
2858,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  if (env == nullptr) {
    return exception->ToString(context).FromMaybe(Local<Value>());
  }
  Realm* realm = Realm::GetCurrent(context);
  Local<Function> prepare;
  if (realm != nullptr) {
    // If we are in a Realm, call the realm specific prepareStackTrace callback
    // to avoid passing the JS objects (the exception and trace) across the
    // realm boundary with the `Error.prepareStackTrace` override.
    prepare = realm->prepare_stack_trace_callback();
  } else {
    // The context is created with ContextifyContext, call the principal
    // realm's prepareStackTrace callback.
    prepare = env->principal_realm()->prepare_stack_trace_callback();
  }
  if (prepare.IsEmpty()) {
    return exception->ToString(context).FromMaybe(Local<Value>());
  }
  Local<Value> args[] = {
      context->Global(),
      exception,
      trace,
  };
  // This TryCatch + Rethrow is required by V8 due to details around exception
  // ha...",65,,66,4,,void
2871,BLOCK,-1,,"{
    return exception->ToString(context).FromMaybe(Local<Value>());
  }",23,,68,2,,void
2899,BLOCK,-1,,"{
    // If we are in a Realm, call the realm specific prepareStackTrace callback
    // to avoid passing the JS objects (the exception and trace) across the
    // realm boundary with the `Error.prepareStackTrace` override.
    prepare = realm->prepare_stack_trace_callback();
  }",25,,73,2,,void
2907,BLOCK,-1,,"{
    // The context is created with ContextifyContext, call the principal
    // realm's prepareStackTrace callback.
    prepare = env->principal_realm()->prepare_stack_trace_callback();
  }",10,,78,1,,void
2922,BLOCK,-1,,"{
    return exception->ToString(context).FromMaybe(Local<Value>());
  }",26,,83,2,,void
2976,BLOCK,-1,,"{
    try_catch.ReThrow();
  }",60,,98,2,,void
2987,BLOCK,-1,,"{
  void* ret;
  if (zero_fill_field_ || per_process::cli_options->zero_fill_all_buffers)
    ret = allocator_->Allocate(size);
  else
    ret = allocator_->AllocateUninitialized(size);
  if (LIKELY(ret != nullptr))
    total_mem_usage_.fetch_add(size, std::memory_order_relaxed);
  return ret;
}",55,,104,2,,void
2997,BLOCK,-1,,<empty>,5,,107,2,,void
3006,BLOCK,-1,,<empty>,5,,109,1,,void
3019,BLOCK,-1,,<empty>,5,,111,2,,void
3034,BLOCK,-1,,"{
  void* ret = allocator_->AllocateUninitialized(size);
  if (LIKELY(ret != nullptr))
    total_mem_usage_.fetch_add(size, std::memory_order_relaxed);
  return ret;
}",68,,115,2,,void
3048,BLOCK,-1,,<empty>,5,,118,2,,void
3065,BLOCK,-1,,"{
  void* ret = allocator_->Reallocate(data, old_size, size);
  if (LIKELY(ret != nullptr) || UNLIKELY(size == 0))
    total_mem_usage_.fetch_add(size - old_size, std::memory_order_relaxed);
  return ret;
}",47,,123,4,,void
3086,BLOCK,-1,,<empty>,5,,126,2,,void
3104,BLOCK,-1,,"{
  total_mem_usage_.fetch_sub(size, std::memory_order_relaxed);
  allocator_->Free(data, size);
}",62,,130,3,,void
3122,BLOCK,-1,,"{
  CHECK(allocations_.empty());
}",65,,135,1,,void
3132,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  void* data = NodeArrayBufferAllocator::Allocate(size);
  RegisterPointerInternal(data, size);
  return data;
}",60,,139,2,,void
3153,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  void* data = NodeArrayBufferAllocator::AllocateUninitialized(size);
  RegisterPointerInternal(data, size);
  return data;
}",73,,146,2,,void
3175,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  UnregisterPointerInternal(data, size);
  NodeArrayBufferAllocator::Free(data, size);
}",67,,153,3,,void
3194,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  void* ret = NodeArrayBufferAllocator::Reallocate(data, old_size, size);
  if (ret == nullptr) {
    if (size == 0) {  // i.e. equivalent to free().
      // suppress coverity warning as data is used as key versus as pointer
      // in UnregisterPointerInternal
      // coverity[pass_freed_arg]
      UnregisterPointerInternal(data, old_size);
    }
    return nullptr;
  }

  if (data != nullptr) {
    auto it = allocations_.find(data);
    CHECK_NE(it, allocations_.end());
    allocations_.erase(it);
  }

  RegisterPointerInternal(ret, size);
  return ret;
}",62,,161,4,,void
3212,BLOCK,-1,,"{
    if (size == 0) {  // i.e. equivalent to free().
      // suppress coverity warning as data is used as key versus as pointer
      // in UnregisterPointerInternal
      // coverity[pass_freed_arg]
      UnregisterPointerInternal(data, old_size);
    }
    return nullptr;
  }",23,,164,2,,void
3217,BLOCK,-1,,"{  // i.e. equivalent to free().
      // suppress coverity warning as data is used as key versus as pointer
      // in UnregisterPointerInternal
      // coverity[pass_freed_arg]
      UnregisterPointerInternal(data, old_size);
    }",20,,165,2,,void
3227,BLOCK,-1,,"{
    auto it = allocations_.find(data);
    CHECK_NE(it, allocations_.end());
    allocations_.erase(it);
  }",24,,174,2,,void
3257,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  NodeArrayBufferAllocator::RegisterPointer(data, size);
  RegisterPointerInternal(data, size);
}",78,,184,3,,void
3275,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  NodeArrayBufferAllocator::UnregisterPointer(data, size);
  UnregisterPointerInternal(data, size);
}",80,,190,3,,void
3293,BLOCK,-1,,"{
  if (data == nullptr) return;
  auto it = allocations_.find(data);
  CHECK_NE(it, allocations_.end());
  if (size > 0) {
    // We allow allocations with size 1 for 0-length buffers to avoid having
    // to deal with nullptr values.
    CHECK_EQ(it->second, size);
  }
  allocations_.erase(it);
}",76,,197,3,,void
3298,BLOCK,-1,,<empty>,24,,198,2,,void
3318,BLOCK,-1,,"{
    // We allow allocations with size 1 for 0-length buffers to avoid having
    // to deal with nullptr values.
    CHECK_EQ(it->second, size);
  }",17,,201,2,,void
3334,BLOCK,-1,,"{
  if (data == nullptr) return;
  CHECK_EQ(allocations_.count(data), 0);
  allocations_[data] = size;
}",74,,210,3,,void
3339,BLOCK,-1,,<empty>,24,,211,2,,void
3357,BLOCK,-1,,"{
  if (debug || per_process::cli_options->debug_arraybuffer_allocations)
    return std::make_unique<DebuggingArrayBufferAllocator>();
  else
    return std::make_unique<NodeArrayBufferAllocator>();
}",80,,216,2,,void
3366,BLOCK,-1,,<empty>,5,,218,2,,void
3373,BLOCK,-1,,<empty>,5,,220,1,,void
3382,BLOCK,-1,,"{
  return ArrayBufferAllocator::Create().release();
}",52,,223,1,,void
3395,BLOCK,-1,,"{
  delete allocator;
}",64,,227,2,,void
3402,BLOCK,-1,,"{
  const uint64_t constrained_memory = uv_get_constrained_memory();
  const uint64_t total_memory = constrained_memory > 0 ?
      std::min(uv_get_total_memory(), constrained_memory) :
      uv_get_total_memory();
  if (total_memory > 0 &&
      params->constraints.max_old_generation_size_in_bytes() == 0) {
    // V8 defaults to 700MB or 1.4GB on 32 and 64 bit platforms respectively.
    // This default is based on browser use-cases. Tell V8 to configure the
    // heap based on the actual physical memory.
    params->constraints.ConfigureDefaults(total_memory, 0);
  }
  params->embedder_wrapper_object_index = BaseObject::InternalFields::kSlot;
  params->embedder_wrapper_type_index = std::numeric_limits<int>::max();

#ifdef NODE_ENABLE_VTUNE_PROFILING
  params->code_event_handler = vTune::GetVtuneCodeEventHandler();
#endif
}",67,,231,2,,void
3434,BLOCK,-1,,"{
    // V8 defaults to 700MB or 1.4GB on 32 and 64 bit platforms respectively.
    // This default is based on browser use-cases. Tell V8 to configure the
    // heap based on the actual physical memory.
    params->constraints.ConfigureDefaults(total_memory, 0);
  }",68,,237,2,,void
3467,BLOCK,-1,,"{
  if (s.flags & MESSAGE_LISTENER_WITH_ERROR_LEVEL)
    isolate->AddMessageListenerWithErrorLevel(
            errors::PerIsolateMessageListener,
            Isolate::MessageErrorLevel::kMessageError |
                Isolate::MessageErrorLevel::kMessageWarning);

  auto* abort_callback = s.should_abort_on_uncaught_exception_callback ?
      s.should_abort_on_uncaught_exception_callback :
      ShouldAbortOnUncaughtException;
  isolate->SetAbortOnUncaughtExceptionCallback(abort_callback);

  auto* fatal_error_cb = s.fatal_error_callback ?
      s.fatal_error_callback : OnFatalError;
  isolate->SetFatalErrorHandler(fatal_error_cb);
  isolate->SetOOMErrorHandler(OOMErrorHandler);

  if ((s.flags & SHOULD_NOT_SET_PREPARE_STACK_TRACE_CALLBACK) == 0) {
    auto* prepare_stack_trace_cb = s.prepare_stack_trace_callback ?
        s.prepare_stack_trace_callback : PrepareStackTraceCallback;
    isolate->SetPrepareStackTraceCallback(prepare_stack_trace_cb);
  }
}",78,,251,3,,void
3474,BLOCK,-1,,<empty>,5,,253,2,,void
3538,BLOCK,-1,,"{
    auto* prepare_stack_trace_cb = s.prepare_stack_trace_callback ?
        s.prepare_stack_trace_callback : PrepareStackTraceCallback;
    isolate->SetPrepareStackTraceCallback(prepare_stack_trace_cb);
  }",69,,268,2,,void
3560,BLOCK,-1,,"{
  isolate->SetMicrotasksPolicy(s.policy);

  auto* allow_wasm_codegen_cb = s.allow_wasm_code_generation_callback ?
    s.allow_wasm_code_generation_callback : AllowWasmCodeGenerationCallback;
  isolate->SetAllowWasmCodeGenerationCallback(allow_wasm_codegen_cb);

  auto* modify_code_generation_from_strings_callback =
      ModifyCodeGenerationFromStrings;
  if (s.modify_code_generation_from_strings_callback != nullptr) {
    modify_code_generation_from_strings_callback =
        s.modify_code_generation_from_strings_callback;
  }
  isolate->SetModifyCodeGenerationFromStringsCallback(
      modify_code_generation_from_strings_callback);

  Mutex::ScopedLock lock(node::per_process::cli_options_mutex);
  if (per_process::cli_options->get_per_isolate_options()
          ->get_per_env_options()
          ->experimental_fetch) {
    isolate->SetWasmStreamingCallback(wasm_web_api::StartStreamingCompilation);
  }

  if (per_process::cli_options->get_per_isolate_options()
          ->experi...",77,,275,3,,void
3594,BLOCK,-1,,"{
    modify_code_generation_from_strings_callback =
        s.modify_code_generation_from_strings_callback;
  }",66,,284,2,,void
3624,BLOCK,-1,,"{
    isolate->SetWasmStreamingCallback(wasm_web_api::StartStreamingCompilation);
  }",33,,294,2,,void
3641,BLOCK,-1,,"{
    isolate->SetHostCreateShadowRealmContextCallback(
        shadow_realm::HostCreateShadowRealmContextCallback);
  }",40,,299,2,,void
3657,BLOCK,-1,,"{
    auto* promise_reject_cb = s.promise_reject_callback ?
      s.promise_reject_callback : PromiseRejectCallback;
    isolate->SetPromiseRejectCallback(promise_reject_cb);
  }",67,,304,2,,void
3680,BLOCK,-1,,<empty>,5,,311,2,,void
3693,BLOCK,-1,,"{
  SetIsolateErrorHandlers(isolate, settings);
  SetIsolateMiscHandlers(isolate, settings);
}",59,,315,3,,void
3704,BLOCK,-1,,"{
  IsolateSettings settings;
  SetIsolateUpForNode(isolate, settings);
}",48,,320,2,,void
3717,BLOCK,-1,,"{
  Isolate* isolate = Isolate::Allocate();
  if (isolate == nullptr) return nullptr;

  if (snapshot_data != nullptr) {
    SnapshotBuilder::InitializeIsolateParams(snapshot_data, params);
  }

#ifdef NODE_V8_SHARED_RO_HEAP
  {
    // In shared-readonly-heap mode, V8 requires all snapshots used for
    // creating Isolates to be identical. This isn't really memory-safe
    // but also otherwise just doesn't work, and the only real alternative
    // is disabling shared-readonly-heap mode altogether.
    static Isolate::CreateParams first_params = *params;
    params->snapshot_blob = first_params.snapshot_blob;
    params->external_references = first_params.external_references;
  }
#endif

  // Register the isolate on the platform before the isolate gets initialized,
  // so that the isolate can access the platform during initialization.
  platform->RegisterIsolate(isolate, event_loop);

  SetIsolateCreateParamsForNode(params);
  Isolate::Initialize(isolate, *params);
  if (snapshot...",54,,331,6,,void
3729,BLOCK,-1,,<empty>,27,,333,2,,void
3736,BLOCK,-1,,"{
    SnapshotBuilder::InitializeIsolateParams(snapshot_data, params);
  }",33,,335,2,,void
3762,BLOCK,-1,,"{
    // If in deserialize mode, delay until after the deserialization is
    // complete.
    SetIsolateUpForNode(isolate, settings);
  }",33,,357,2,,void
3767,BLOCK,-1,,"{
    SetIsolateMiscHandlers(isolate, settings);
  }",10,,361,1,,void
3781,BLOCK,-1,,"{
  Isolate::CreateParams params;
  if (allocator != nullptr) params.array_buffer_allocator = allocator;
  return NewIsolate(&params,
                    event_loop,
                    platform,
                    SnapshotData::FromEmbedderWrapper(snapshot_data),
                    settings);
}",54,,372,6,,void
3787,BLOCK,-1,,<empty>,29,,374,2,,void
3813,BLOCK,-1,,"{
  Isolate::CreateParams params;
  if (allocator) params.array_buffer_allocator_shared = allocator;
  return NewIsolate(&params,
                    event_loop,
                    platform,
                    SnapshotData::FromEmbedderWrapper(snapshot_data),
                    settings);
}",54,,386,6,,void
3817,BLOCK,-1,,<empty>,18,,388,2,,void
3843,BLOCK,-1,,"{
  const SnapshotData* snapshot_data =
      SnapshotData::FromEmbedderWrapper(embedder_snapshot_data);
  return new IsolateData(isolate, loop, platform, allocator, snapshot_data);
}",57,,401,6,,void
3864,BLOCK,-1,,"{
  delete isolate_data;
}",49,,407,2,,void
3870,BLOCK,-1,,<empty>,49,,411,1,,void
3881,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();
  HandleScope handle_scope(isolate);

  const bool use_snapshot = context.IsEmpty();
  const EnvSerializeInfo* env_snapshot_info = nullptr;
  if (use_snapshot) {
    CHECK_NOT_NULL(isolate_data->snapshot_data());
    env_snapshot_info = &isolate_data->snapshot_data()->env_info;
  }

  // TODO(addaleax): This is a much better place for parsing per-Environment
  // options than the global parse call.
  Environment* env = new Environment(isolate_data,
                                     isolate,
                                     args,
                                     exec_args,
                                     env_snapshot_info,
                                     flags,
                                     thread_id);
  CHECK_NOT_NULL(env);

  if (use_snapshot) {
    context = Context::FromSnapshot(isolate,
                                    SnapshotData::kNodeMainContextIndex,
                                    {Deseriali...",69,,431,8,,void
3905,BLOCK,-1,,"{
    CHECK_NOT_NULL(isolate_data->snapshot_data());
    env_snapshot_info = &isolate_data->snapshot_data()->env_info;
  }",21,,437,2,,void
3936,BLOCK,-1,,"{
    context = Context::FromSnapshot(isolate,
                                    SnapshotData::kNodeMainContextIndex,
                                    {DeserializeNodeInternalFields, env})
                  .ToLocalChecked();

    CHECK(!context.IsEmpty());
    Context::Scope context_scope(context);

    if (InitializeContextRuntime(context).IsNothing()) {
      FreeEnvironment(env);
      return nullptr;
    }
    SetIsolateErrorHandlers(isolate, {});
  }",21,,453,2,,void
3968,BLOCK,-1,,"{
      FreeEnvironment(env);
      return nullptr;
    }",56,,462,2,,void
3999,BLOCK,-1,,"{
    FreeEnvironment(env);
    return nullptr;
  }",78,,484,2,,void
4010,BLOCK,-1,,"{
  Isolate* isolate = env->isolate();
  Isolate::DisallowJavascriptExecutionScope disallow_js(isolate,
      Isolate::DisallowJavascriptExecutionScope::THROW_ON_FAILURE);
  {
    HandleScope handle_scope(isolate);  // For env->context().
    Context::Scope context_scope(env->context());
    SealHandleScope seal_handle_scope(isolate);

    // Set the flag in accordance with the DisallowJavascriptExecutionScope
    // above.
    env->set_can_call_into_js(false);
    env->set_stopping(true);
    env->stop_sub_worker_contexts();
    env->RunCleanup();
    RunAtExit(env);
  }

  // This call needs to be made while the `Environment` is still alive
  // because we assume that it is available for async tracking in the
  // NodePlatform implementation.
  MultiIsolatePlatform* platform = env->isolate_data()->platform();
  if (platform != nullptr)
    platform->DrainTasks(isolate);

  delete env;
}",40,,492,2,,void
4026,BLOCK,5,,"{
    HandleScope handle_scope(isolate);  // For env->context().
    Context::Scope context_scope(env->context());
    SealHandleScope seal_handle_scope(isolate);

    // Set the flag in accordance with the DisallowJavascriptExecutionScope
    // above.
    env->set_can_call_into_js(false);
    env->set_stopping(true);
    env->stop_sub_worker_contexts();
    env->RunCleanup();
    RunAtExit(env);
  }",3,,496,5,,void
4073,BLOCK,-1,,<empty>,5,,515,2,,void
4087,BLOCK,-1,,"{
  return GetInspectorParentHandle(env, thread_id, url, """");
}",22,,523,4,,void
4101,BLOCK,-1,,"{
  CHECK_NOT_NULL(env);
  if (name == nullptr) name = """";
  CHECK_NE(thread_id.id, static_cast<uint64_t>(-1));
  if (!env->should_create_inspector()) {
    return nullptr;
  }
#if HAVE_INSPECTOR
  return std::make_unique<InspectorParentHandleImpl>(
      env->inspector_agent()->GetParentHandle(thread_id.id, url, name));
#else
  return {};
#endif
}",78,,528,5,,void
4108,BLOCK,-1,,<empty>,24,,530,2,,void
4126,BLOCK,-1,,"{
    return nullptr;
  }",40,,532,2,,void
4135,BLOCK,-1,,"{
  env->InitializeLibuv();
  env->InitializeDiagnostics();

  return StartExecution(env, cb);
}",32,,545,3,,void
4151,BLOCK,-1,,"{
  CHECK_NOT_NULL(main_script_source_utf8.data());
  return LoadEnvironment(
      env, [&](const StartExecutionCallbackInfo& info) -> MaybeLocal<Value> {
        Local<Value> main_script =
            ToV8Value(env->context(), main_script_source_utf8).ToLocalChecked();
        return info.run_cjs->Call(
            env->context(), Null(env->isolate()), 1, &main_script);
      });
}",77,,553,3,,void
4165,BLOCK,-1,,"{
  return Environment::GetCurrent(context);
}",60,,564,2,,void
4176,BLOCK,-1,,"{
  return env->isolate_data();
}",58,,568,2,,void
4186,BLOCK,-1,,"{
  return isolate_data->node_allocator();
}",74,,572,2,,void
4196,BLOCK,-1,,"{
  return env->context();
}",49,,576,2,,void
4206,BLOCK,-1,,"{
  return GetMultiIsolatePlatform(env->isolate_data());
}",65,,580,2,,void
4217,BLOCK,-1,,"{
  return env->platform();
}",65,,584,2,,void
4228,BLOCK,-1,,"{
  return CreatePlatform(
      thread_pool_size,
      static_cast<v8::TracingController*>(tracing_controller));
}",59,,590,3,,void
4240,BLOCK,-1,,"{
  return MultiIsolatePlatform::Create(thread_pool_size,
                                      tracing_controller)
      .release();
}",48,,598,3,,void
4255,BLOCK,-1,,"{
  delete platform;
}",51,,604,2,,void
4264,BLOCK,-1,,"{
  return std::make_unique<NodePlatform>(thread_pool_size,
                                        tracing_controller,
                                        page_allocator);
}",40,,611,4,,void
4281,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  EscapableHandleScope handle_scope(isolate);

  Local<Object> global = context->Global();
  Local<Private> key = Private::ForApi(isolate,
      FIXED_ONE_BYTE_STRING(isolate, ""node:per_context_binding_exports""));

  Local<Value> existing_value;
  if (!global->GetPrivate(context, key).ToLocal(&existing_value))
    return MaybeLocal<Object>();
  if (existing_value->IsObject())
    return handle_scope.Escape(existing_value.As<Object>());

  Local<Object> exports = Object::New(isolate);
  if (context->Global()->SetPrivate(context, key, exports).IsNothing() ||
      InitializePrimordials(context).IsNothing())
    return MaybeLocal<Object>();
  return handle_scope.Escape(exports);
}",65,,617,2,,void
4334,BLOCK,-1,,<empty>,5,,627,2,,void
4342,BLOCK,-1,,<empty>,5,,629,2,,void
4383,BLOCK,-1,,<empty>,5,,634,2,,void
4397,BLOCK,-1,,"{
  auto context = Context::New(isolate, nullptr, object_template);
  if (context.IsEmpty()) return context;

  if (InitializeContext(context).IsNothing()) {
    return Local<Context>();
  }

  return context;
}",66,,642,3,,void
4413,BLOCK,-1,,<empty>,26,,644,2,,void
4422,BLOCK,-1,,"{
    return Local<Context>();
  }",47,,646,2,,void
4431,BLOCK,-1,,"{
  THROW_ERR_PROTO_ACCESS(info.GetIsolate());
}",60,,653,2,,void
4441,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  HandleScope handle_scope(isolate);

  // When `IsCodeGenerationFromStringsAllowed` is true, V8 takes the fast path
  // and ignores the ModifyCodeGenerationFromStrings callback. Set it to false
  // to delegate the code generation validation to
  // node::ModifyCodeGenerationFromStrings.
  // The `IsCodeGenerationFromStringsAllowed` can be refreshed by V8 according
  // to the runtime flags, propagate the value to the embedder data.
  bool is_code_generation_from_strings_allowed =
      context->IsCodeGenerationFromStringsAllowed();
  context->AllowCodeGenerationFromStrings(false);
  context->SetEmbedderData(
      ContextEmbedderIndex::kAllowCodeGenerationFromStrings,
      Boolean::New(isolate, is_code_generation_from_strings_allowed));

  if (per_process::cli_options->disable_proto == """") {
    return Just(true);
  }

  // Remove __proto__
  // https://github.com/nodejs/node/issues/31951
  Local<Object> prototype;
  {
    Local<Stri...",62,,659,2,,void
4485,BLOCK,-1,,"{
    return Just(true);
  }",54,,676,2,,void
4494,BLOCK,11,,"{
    Local<String> object_string =
      FIXED_ONE_BYTE_STRING(isolate, ""Object"");
    Local<String> prototype_string =
      FIXED_ONE_BYTE_STRING(isolate, ""prototype"");

    Local<Value> object_v;
    if (!context->Global()
        ->Get(context, object_string)
        .ToLocal(&object_v)) {
      return Nothing<bool>();
    }

    Local<Value> prototype_v;
    if (!object_v.As<Object>()
        ->Get(context, prototype_string)
        .ToLocal(&prototype_v)) {
      return Nothing<bool>();
    }

    prototype = prototype_v.As<Object>();
  }",3,,683,11,,void
4534,BLOCK,-1,,"{
      return Nothing<bool>();
    }",30,,692,2,,void
4558,BLOCK,-1,,"{
      return Nothing<bool>();
    }",33,,699,2,,void
4584,BLOCK,-1,,"{
    if (prototype
        ->Delete(context, proto_string)
        .IsNothing()) {
      return Nothing<bool>();
    }
  }",60,,709,2,,void
4595,BLOCK,-1,,"{
      return Nothing<bool>();
    }",23,,712,2,,void
4599,BLOCK,-1,,<empty>,10,,715,1,,void
4608,BLOCK,-1,,"{
    Local<Value> thrower;
    if (!Function::New(context, ProtoThrower)
        .ToLocal(&thrower)) {
      return Nothing<bool>();
    }

    PropertyDescriptor descriptor(thrower, thrower);
    descriptor.set_enumerable(false);
    descriptor.set_configurable(true);
    if (prototype
        ->DefineProperty(context, proto_string, descriptor)
        .IsNothing()) {
      return Nothing<bool>();
    }
  }",66,,715,2,,void
4627,BLOCK,-1,,"{
      return Nothing<bool>();
    }",29,,718,2,,void
4655,BLOCK,-1,,"{
      return Nothing<bool>();
    }",23,,727,2,,void
4659,BLOCK,-1,,<empty>,10,,730,1,,void
4668,BLOCK,-1,,"{
    // Validated in ProcessGlobalArgs
    OnFatalError(""InitializeContextRuntime()"", ""invalid --disable-proto mode"");
  }",61,,730,2,,void
4679,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  HandleScope handle_scope(isolate);

  // Delete `Intl.v8BreakIterator`
  // https://github.com/nodejs/node/issues/14909
  {
    Context::Scope context_scope(context);
    Local<String> intl_string = FIXED_ONE_BYTE_STRING(isolate, ""Intl"");
    Local<String> break_iter_string =
        FIXED_ONE_BYTE_STRING(isolate, ""v8BreakIterator"");

    Local<Value> intl_v;
    if (!context->Global()->Get(context, intl_string).ToLocal(&intl_v)) {
      return Nothing<bool>();
    }

    if (intl_v->IsObject() &&
        intl_v.As<Object>()->Delete(context, break_iter_string).IsNothing()) {
      return Nothing<bool>();
    }
  }
  return Just(true);
}",70,,738,2,,void
4690,BLOCK,5,,"{
    Context::Scope context_scope(context);
    Local<String> intl_string = FIXED_ONE_BYTE_STRING(isolate, ""Intl"");
    Local<String> break_iter_string =
        FIXED_ONE_BYTE_STRING(isolate, ""v8BreakIterator"");

    Local<Value> intl_v;
    if (!context->Global()->Get(context, intl_string).ToLocal(&intl_v)) {
      return Nothing<bool>();
    }

    if (intl_v->IsObject() &&
        intl_v.As<Object>()->Delete(context, break_iter_string).IsNothing()) {
      return Nothing<bool>();
    }
  }",3,,744,5,,void
4733,BLOCK,-1,,"{
      return Nothing<bool>();
    }",73,,751,2,,void
4754,BLOCK,-1,,"{
      return Nothing<bool>();
    }",78,,756,2,,void
4764,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  HandleScope handle_scope(isolate);

  // Initialize the default values.
  context->SetEmbedderData(ContextEmbedderIndex::kAllowWasmCodeGeneration,
                           True(isolate));
  context->SetEmbedderData(
      ContextEmbedderIndex::kAllowCodeGenerationFromStrings, True(isolate));

  if (InitializeBaseContextForSnapshot(context).IsNothing()) {
    return Nothing<bool>();
  }
  return InitializePrimordials(context);
}",70,,763,2,,void
4799,BLOCK,-1,,"{
    return Nothing<bool>();
  }",62,,773,2,,void
4809,BLOCK,-1,,"{
  // Run per-context JS files.
  Isolate* isolate = context->GetIsolate();
  Context::Scope context_scope(context);
  Local<Object> exports;

  Local<String> primordials_string =
      FIXED_ONE_BYTE_STRING(isolate, ""primordials"");

  // Create primordials first and make it available to per-context scripts.
  Local<Object> primordials = Object::New(isolate);
  if (primordials->SetPrototype(context, Null(isolate)).IsNothing() ||
      !GetPerContextExports(context).ToLocal(&exports) ||
      exports->Set(context, primordials_string, primordials).IsNothing()) {
    return Nothing<bool>();
  }

  static const char* context_files[] = {""internal/per_context/primordials"",
                                        ""internal/per_context/domexception"",
                                        ""internal/per_context/messageport"",
                                        nullptr};

  // We do not have access to a per-Environment BuiltinLoader instance
  // at this point, because this code runs be...",59,,779,2,,void
4876,BLOCK,-1,,"{
    return Nothing<bool>();
  }",75,,792,2,,void
4889,BLOCK,-1,,<empty>,3,,807,1,,void
4900,BLOCK,4,,"{
    Local<Value> arguments[] = {exports, primordials};
    if (builtin_loader
            .CompileAndCall(
                context, *module, arraysize(arguments), arguments, nullptr)
            .IsEmpty()) {
      // Execution failed during context creation.
      return Nothing<bool>();
    }
  }",75,,807,4,,void
4922,BLOCK,-1,,"{
      // Execution failed during context creation.
      return Nothing<bool>();
    }",25,,812,2,,void
4932,BLOCK,-1,,"{
  if (InitializeMainContextForSnapshot(context).IsNothing()) {
    return Nothing<bool>();
  }

  return InitializeContextRuntime(context);
}",55,,822,2,,void
4939,BLOCK,-1,,"{
    return Nothing<bool>();
  }",62,,823,2,,void
4949,BLOCK,-1,,"{
  HandleScope handle_scope(isolate);
  Local<Context> context = isolate->GetCurrentContext();
  if (context.IsEmpty()) return nullptr;
  Environment* env = Environment::GetCurrent(context);
  if (env == nullptr) return nullptr;
  return env->event_loop();
}",50,,830,2,,void
4968,BLOCK,-1,,<empty>,26,,833,2,,void
4983,BLOCK,-1,,<empty>,23,,835,2,,void
4996,BLOCK,-1,,"{
  CHECK_NOT_NULL(env);
  Mutex::ScopedLock lock(env->extra_linked_bindings_mutex());

  node_module* prev_tail = env->extra_linked_bindings_tail();
  env->extra_linked_bindings()->push_back(mod);
  if (prev_tail != nullptr)
    prev_tail->nm_link = &env->extra_linked_bindings()->back();
}",65,,839,3,,void
5024,BLOCK,-1,,<empty>,5,,846,2,,void
5042,BLOCK,-1,,"{
  node_module node_mod = napi_module_to_node_module(&mod);
  node_mod.nm_flags = NM_F_LINKED;
  AddLinkedBinding(env, node_mod);
}",65,,849,3,,void
5064,BLOCK,-1,,"{
  node_module mod = {
    NODE_MODULE_VERSION,
    NM_F_LINKED,
    nullptr,  // nm_dso_handle
    nullptr,  // nm_filename
    nullptr,  // nm_register_func
    fn,
    name,
    priv,
    nullptr   // nm_link
  };
  AddLinkedBinding(env, mod);
}",35,,858,5,,void
5070,BLOCK,1,,<empty>,,,,1,,void
5090,BLOCK,-1,,"{
  node_module mod = {
      -1,           // nm_version for Node-API
      NM_F_LINKED,  // nm_flags
      nullptr,      // nm_dso_handle
      nullptr,      // nm_filename
      nullptr,      // nm_register_func
      get_node_api_context_register_func(env, name, module_api_version),
      name,                         // nm_modname
      reinterpret_cast<void*>(fn),  // nm_priv
      nullptr                       // nm_link
  };
  AddLinkedBinding(env, mod);
}",51,,876,5,,void
5121,BLOCK,-1,,"{
  return ThreadId { next_thread_id++ };
}",40,,893,1,,void
5131,BLOCK,-1,,"{
  exit(static_cast<int>(exit_code));
}",44,,897,2,,void
5141,BLOCK,-1,,"{
  env->set_stopping(true);
  env->set_can_call_into_js(false);
  env->stop_sub_worker_contexts();
  env->isolate()->DumpAndResetStats();
  // The tracing agent could be in the process of writing data using the
  // threadpool. Stop it before shutting down libuv. The rest of the tracing
  // agent disposal will be performed in DisposePlatform().
  per_process::v8_platform.StopTracingAgent();
  // When the process exits, the tasks in the thread pool may also need to
  // access the data of V8Platform, such as trace agent, or a field
  // added in the future. So make sure the thread pool exits first.
  // And make sure V8Platform don not call into Libuv threadpool, see Dispose
  // in node_v8_platform-inl.h
  uv_library_shutdown();
  DisposePlatform();
  Exit(exit_code);
}",78,,901,3,,void
5178,BLOCK,-1,,"{
  DefaultProcessExitHandlerInternal(env, static_cast<ExitCode>(exit_code));
}",65,,920,3,,void
5189,BLOCK,-1,,"{
  env->set_process_exit_handler(std::move(handler));
}",78,,925,3,,void
5203,BLOCK,-1,,"{
  auto movedHandler = std::move(handler);
  env->set_process_exit_handler([=](Environment* env, ExitCode exit_code) {
    movedHandler(env, static_cast<int>(exit_code));
  });
}",78,,930,3,,void
5237,BLOCK,-1,,<empty>,1,,1,1,,ANY
5245,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(isolate);
  CHECK_NOT_NULL(env);

  Local<Value> e;
  Local<String> estring = OneByteString(isolate, errors::errno_string(errorno));
  if (msg == nullptr || msg[0] == '\0') {
    msg = strerror(errorno);
  }
  Local<String> message = OneByteString(isolate, msg);

  Local<String> cons =
      String::Concat(isolate, estring, FIXED_ONE_BYTE_STRING(isolate, "", ""));
  cons = String::Concat(isolate, cons, message);

  Local<String> path_string;
  if (path != nullptr) {
    // FIXME(bnoordhuis) It's questionable to interpret the file path as UTF-8.
    path_string = String::NewFromUtf8(isolate, path).ToLocalChecked();
  }

  if (path_string.IsEmpty() == false) {
    cons = String::Concat(isolate, cons, FIXED_ONE_BYTE_STRING(isolate, "" '""));
    cons = String::Concat(isolate, cons, path_string);
    cons = String::Concat(isolate, cons, FIXED_ONE_BYTE_STRING(isolate, ""'""));
  }
  e = Exception::Error(cons);

  Local<Context> context = env->cont...",47,,27,6,,void
5284,BLOCK,-1,,"{
    msg = strerror(errorno);
  }",41,,33,2,,void
5331,BLOCK,-1,,"{
    // FIXME(bnoordhuis) It's questionable to interpret the file path as UTF-8.
    path_string = String::NewFromUtf8(isolate, path).ToLocalChecked();
  }",24,,43,2,,void
5350,BLOCK,-1,,"{
    cons = String::Concat(isolate, cons, FIXED_ONE_BYTE_STRING(isolate, "" '""));
    cons = String::Concat(isolate, cons, path_string);
    cons = String::Concat(isolate, cons, FIXED_ONE_BYTE_STRING(isolate, ""'""));
  }",39,,48,2,,void
5447,BLOCK,-1,,"{
    obj->Set(context, env->path_string(), path_string).Check();
  }",39,,62,2,,void
5465,BLOCK,-1,,"{
    obj->Set(context,
             env->syscall_string(),
             OneByteString(isolate, syscall)).Check();
  }",27,,66,2,,void
5488,BLOCK,-1,,"{
#ifdef _WIN32
  if (strncmp(path, ""\\\\?\\UNC\\"", 8) == 0) {
    return String::Concat(
        isolate,
        FIXED_ONE_BYTE_STRING(isolate, ""\\\\""),
        String::NewFromUtf8(isolate, path + 8).ToLocalChecked());
  } else if (strncmp(path, ""\\\\?\\"", 4) == 0) {
    return String::NewFromUtf8(isolate, path + 4).ToLocalChecked();
  }
#endif

  return String::NewFromUtf8(isolate, path).ToLocalChecked();
}",73,,75,3,,void
5508,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(isolate);
  CHECK_NOT_NULL(env);

  if (!msg || !msg[0])
    msg = uv_strerror(errorno);

  Local<String> js_code = OneByteString(isolate, uv_err_name(errorno));
  Local<String> js_syscall = OneByteString(isolate, syscall);
  Local<String> js_path;
  Local<String> js_dest;

  Local<String> js_msg = js_code;
  js_msg =
      String::Concat(isolate, js_msg, FIXED_ONE_BYTE_STRING(isolate, "": ""));
  js_msg = String::Concat(isolate, js_msg, OneByteString(isolate, msg));
  js_msg =
      String::Concat(isolate, js_msg, FIXED_ONE_BYTE_STRING(isolate, "", ""));
  js_msg = String::Concat(isolate, js_msg, js_syscall);

  if (path != nullptr) {
    js_path = StringFromPath(isolate, path);

    js_msg =
        String::Concat(isolate, js_msg, FIXED_ONE_BYTE_STRING(isolate, "" '""));
    js_msg = String::Concat(isolate, js_msg, js_path);
    js_msg =
        String::Concat(isolate, js_msg, FIXED_ONE_BYTE_STRING(isolate, ""'""));
  }

  if (dest != nullptr...",44,,96,7,,void
5527,BLOCK,-1,,<empty>,5,,101,2,,void
5614,BLOCK,-1,,"{
    js_path = StringFromPath(isolate, path);

    js_msg =
        String::Concat(isolate, js_msg, FIXED_ONE_BYTE_STRING(isolate, "" '""));
    js_msg = String::Concat(isolate, js_msg, js_path);
    js_msg =
        String::Concat(isolate, js_msg, FIXED_ONE_BYTE_STRING(isolate, ""'""));
  }",24,,116,2,,void
5655,BLOCK,-1,,"{
    js_dest = StringFromPath(isolate, dest);

    js_msg = String::Concat(
        isolate, js_msg, FIXED_ONE_BYTE_STRING(isolate, "" -> '""));
    js_msg = String::Concat(isolate, js_msg, js_dest);
    js_msg =
        String::Concat(isolate, js_msg, FIXED_ONE_BYTE_STRING(isolate, ""'""));
  }",24,,126,2,,void
5773,BLOCK,-1,,<empty>,5,,147,2,,void
5793,BLOCK,-1,,<empty>,5,,149,2,,void
5814,BLOCK,-1,,"{
  errors::TriggerUncaughtException(isolate, try_catch);
}",70,,246,3,,void
5826,BLOCK,-1,,"{
    // Disallow JavaScript execution during interrupt.
    Isolate::DisallowJavascriptExecutionScope scope(
        env->isolate(),
        Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
    fun(arg);
  }",54,,172,2,,void
5856,BLOCK,-1,,<empty>,1,,1,1,,ANY
5860,BLOCK,-1,,"{
  env->RunAtExitCallbacks();
}",34,,20,2,,void
5871,BLOCK,-1,,"{
  CHECK_NOT_NULL(env);
  env->AtExit(cb, arg);
}",65,,24,4,,void
5884,BLOCK,-1,,"{
  USE(EmitProcessBeforeExit(env));
}",39,,29,2,,void
5892,BLOCK,-1,,"{
  TRACE_EVENT0(TRACING_CATEGORY_NODE1(environment), ""BeforeExit"");
  if (!env->destroy_async_id_list()->empty())
    AsyncWrap::DestroyAsyncIdsCallback(env);

  Isolate* isolate = env->isolate();
  HandleScope handle_scope(isolate);
  Context::Scope context_scope(env->context());

  if (!env->can_call_into_js()) {
    return Nothing<bool>();
  }

  Local<Integer> exit_code = Integer::New(
      isolate, static_cast<int32_t>(env->exit_code(ExitCode::kNoFailure)));

  return ProcessEmit(env, ""beforeExit"", exit_code).IsEmpty() ?
      Nothing<bool>() : Just(true);
}",53,,33,2,,void
5906,BLOCK,-1,,<empty>,5,,36,2,,void
5934,BLOCK,-1,,"{
    return Nothing<bool>();
  }",33,,42,2,,void
5973,BLOCK,-1,,"{
  return EmitProcessExitInternal(env).FromMaybe(ExitCode::kGenericUserError);
}",52,,53,2,,void
5987,BLOCK,-1,,"{
  return static_cast<int>(EmitExitInternal(env));
}",32,,57,2,,void
5997,BLOCK,-1,,"{
  // process.emit('exit')
  Isolate* isolate = env->isolate();
  HandleScope handle_scope(isolate);
  Context::Scope context_scope(env->context());

  env->set_exiting(true);

  if (!env->can_call_into_js()) {
    return Nothing<ExitCode>();
  }

  Local<Integer> exit_code = Integer::New(
      isolate, static_cast<int32_t>(env->exit_code(ExitCode::kNoFailure)));

  if (ProcessEmit(env, ""exit"", exit_code).IsEmpty()) {
    return Nothing<ExitCode>();
  }
  // Reload exit code, it may be changed by `emit('exit')`
  return Just(env->exit_code(ExitCode::kNoFailure));
}",59,,61,2,,void
6025,BLOCK,-1,,"{
    return Nothing<ExitCode>();
  }",33,,69,2,,void
6056,BLOCK,-1,,"{
    return Nothing<ExitCode>();
  }",54,,76,2,,void
6072,BLOCK,-1,,"{
  Maybe<ExitCode> result = EmitProcessExitInternal(env);
  if (result.IsNothing()) {
    return Nothing<int>();
  }
  return Just(static_cast<int>(result.FromJust()));
}",46,,83,2,,void
6086,BLOCK,-1,,"{
    return Nothing<int>();
  }",27,,85,2,,void
6101,BLOCK,-1,,<empty>,,,,2,,<empty>
6108,BLOCK,-1,,<empty>,,,,4,,<empty>
6118,BLOCK,-1,,<empty>,,,,1,,<empty>
6128,BLOCK,-1,,{ delete handle; },60,,116,2,,void
6137,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(isolate);
  CHECK_NOT_NULL(env);
  env->AddCleanupHook(fun, arg);
}",43,,120,4,,void
6160,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(isolate);
  CHECK_NOT_NULL(env);
  env->RemoveCleanupHook(fun, arg);
}",46,,128,4,,void
6181,BLOCK,-1,,"{
  AsyncCleanupHookInfo* info = static_cast<AsyncCleanupHookInfo*>(arg);
  std::shared_ptr<AsyncCleanupHookInfo> keep_alive = info->self;

  info->env->DecreaseWaitingRequestCounter();
  info->self.reset();
}",47,,134,2,,void
6210,BLOCK,-1,,"{
  AsyncCleanupHookInfo* info = static_cast<AsyncCleanupHookInfo*>(arg);
  info->env->IncreaseWaitingRequestCounter();
  info->started = true;
  info->fun(info->arg, FinishAsyncCleanupHook, info);
}",44,,142,2,,void
6243,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(isolate);
  CHECK_NOT_NULL(env);
  auto info = std::make_shared<AsyncCleanupHookInfo>();
  info->env = env;
  info->fun = fun;
  info->arg = arg;
  info->self = info;
  env->AddCleanupHook(RunAsyncCleanupHook, info.get());
  return new ACHHandle { info };
}",16,,152,4,,void
6297,BLOCK,-1,,"{
  if (handle->info->started) return;
  handle->info->self.reset();
  handle->info->env->RemoveCleanupHook(RunAsyncCleanupHook, handle->info.get());
}",24,,165,2,,void
6304,BLOCK,-1,,<empty>,30,,166,2,,void
6333,BLOCK,-1,,"{
  env->RequestInterrupt([fun, arg](Environment* env) {
    // Disallow JavaScript execution during interrupt.
    Isolate::DisallowJavascriptExecutionScope scope(
        env->isolate(),
        Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
    fun(arg);
  });
}",76,,171,4,,void
6343,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(isolate);
  if (env == nullptr) return -1;
  return env->execution_async_id();
}",58,,181,2,,void
6356,BLOCK,-1,,<empty>,23,,183,2,,void
6369,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(isolate);
  if (env == nullptr) return -1;
  return env->trigger_async_id();
}",56,,187,2,,void
6382,BLOCK,-1,,<empty>,23,,189,2,,void
6398,BLOCK,-1,,"{
  HandleScope handle_scope(isolate);
  Local<String> type =
      String::NewFromUtf8(isolate, name, NewStringType::kInternalized)
          .ToLocalChecked();
  return EmitAsyncInit(isolate, resource, type, trigger_async_id);
}",56,,197,5,,void
6433,BLOCK,-1,,"{
  DebugSealHandleScope handle_scope(isolate);
  Environment* env = Environment::GetCurrent(isolate);
  CHECK_NOT_NULL(env);

  // Initialize async context struct
  if (trigger_async_id == -1)
    trigger_async_id = env->get_default_trigger_async_id();

  async_context context = {
    env->new_async_id(),  // async_id_
    trigger_async_id  // trigger_async_id_
  };

  // Run init hooks
  AsyncWrap::EmitAsyncInit(env, resource, name, context.async_id,
                           context.trigger_async_id);

  return context;
}",56,,208,5,,void
6452,BLOCK,-1,,<empty>,5,,215,2,,void
6488,BLOCK,-1,,"{
  EmitAsyncDestroy(Environment::GetCurrent(isolate), asyncContext);
}",69,,229,3,,void
6501,BLOCK,-1,,"{
  AsyncWrap::EmitDestroy(env, asyncContext.async_id);
}",69,,233,3,,void
6520,BLOCK,-1,,<empty>,1,,1,1,,ANY
6524,BLOCK,-1,,"{
#define SIGNO_CASE(e)                                                          \
  case e:                                                                      \
    return #e;
  switch (signo) {
#ifdef SIGHUP
    SIGNO_CASE(SIGHUP);
#endif

#ifdef SIGINT
    SIGNO_CASE(SIGINT);
#endif

#ifdef SIGQUIT
    SIGNO_CASE(SIGQUIT);
#endif

#ifdef SIGILL
    SIGNO_CASE(SIGILL);
#endif

#ifdef SIGTRAP
    SIGNO_CASE(SIGTRAP);
#endif

#ifdef SIGABRT
    SIGNO_CASE(SIGABRT);
#endif

#ifdef SIGIOT
#if SIGABRT != SIGIOT
    SIGNO_CASE(SIGIOT);
#endif
#endif

#ifdef SIGBUS
    SIGNO_CASE(SIGBUS);
#endif

#ifdef SIGFPE
    SIGNO_CASE(SIGFPE);
#endif

#ifdef SIGKILL
    SIGNO_CASE(SIGKILL);
#endif

#ifdef SIGUSR1
    SIGNO_CASE(SIGUSR1);
#endif

#ifdef SIGSEGV
    SIGNO_CASE(SIGSEGV);
#endif

#ifdef SIGUSR2
    SIGNO_CASE(SIGUSR2);
#endif

#ifdef SIGPIPE
    SIGNO_CASE(SIGPIPE);
#endif

#ifdef SIGALRM
    SIGNO_CASE(SIGALRM);
#endif

    SIGNO_CASE(SIGTERM);

#ifdef SIGCHLD
    SIGNO_CASE(SIGCHL...",37,,7,2,,void
6527,BLOCK,-1,,"{
#ifdef SIGHUP
    SIGNO_CASE(SIGHUP);
#endif

#ifdef SIGINT
    SIGNO_CASE(SIGINT);
#endif

#ifdef SIGQUIT
    SIGNO_CASE(SIGQUIT);
#endif

#ifdef SIGILL
    SIGNO_CASE(SIGILL);
#endif

#ifdef SIGTRAP
    SIGNO_CASE(SIGTRAP);
#endif

#ifdef SIGABRT
    SIGNO_CASE(SIGABRT);
#endif

#ifdef SIGIOT
#if SIGABRT != SIGIOT
    SIGNO_CASE(SIGIOT);
#endif
#endif

#ifdef SIGBUS
    SIGNO_CASE(SIGBUS);
#endif

#ifdef SIGFPE
    SIGNO_CASE(SIGFPE);
#endif

#ifdef SIGKILL
    SIGNO_CASE(SIGKILL);
#endif

#ifdef SIGUSR1
    SIGNO_CASE(SIGUSR1);
#endif

#ifdef SIGSEGV
    SIGNO_CASE(SIGSEGV);
#endif

#ifdef SIGUSR2
    SIGNO_CASE(SIGUSR2);
#endif

#ifdef SIGPIPE
    SIGNO_CASE(SIGPIPE);
#endif

#ifdef SIGALRM
    SIGNO_CASE(SIGALRM);
#endif

    SIGNO_CASE(SIGTERM);

#ifdef SIGCHLD
    SIGNO_CASE(SIGCHLD);
#endif

#ifdef SIGSTKFLT
    SIGNO_CASE(SIGSTKFLT);
#endif

#ifdef SIGCONT
    SIGNO_CASE(SIGCONT);
#endif

#ifdef SIGSTOP
    SIGNO_CASE(SIGSTOP);
#endif

#ifdef SIGTSTP
    SIGNO_CASE(SIGTST...",18,,11,2,,void
6529,BLOCK,1,,<empty>,,,,1,,void
6549,BLOCK,-1,,<empty>,1,,1,1,,ANY
6553,BLOCK,-1,,"{
          DestroyAsyncIdsCallback(static_cast<Environment*>(arg));
        }",23,,570,2,,void
6564,BLOCK,-1,,"{
      env->context()->GetMicrotaskQueue()->EnqueueMicrotask(
        env->isolate(),
        [](void* arg) {
          DestroyAsyncIdsCallback(static_cast<Environment*>(arg));
        }, env);
      }",48,,567,2,,void
6603,BLOCK,-1,,<empty>,1,,1,1,,ANY
6614,BLOCK,-1,,"{
  Local<Function> fn = env->async_hooks_destroy_function();

  TryCatchScope try_catch(env, TryCatchScope::CatchMode::kFatal);

  do {
    std::vector<double> destroy_async_id_list;
    destroy_async_id_list.swap(*env->destroy_async_id_list());
    if (!env->can_call_into_js()) return;
    for (auto async_id : destroy_async_id_list) {
      // Want each callback to be cleaned up after itself, instead of cleaning
      // them all up after the while() loop completes.
      HandleScope scope(env->isolate());
      Local<Value> async_id_value = Number::New(env->isolate(), async_id);
      MaybeLocal<Value> ret = fn->Call(
          env->context(), Undefined(env->isolate()), 1, &async_id_value);

      if (ret.IsEmpty())
        return;
    }
  } while (!env->destroy_async_id_list()->empty());
}",59,,67,2,,void
6634,BLOCK,-1,,"{
    std::vector<double> destroy_async_id_list;
    destroy_async_id_list.swap(*env->destroy_async_id_list());
    if (!env->can_call_into_js()) return;
    for (auto async_id : destroy_async_id_list) {
      // Want each callback to be cleaned up after itself, instead of cleaning
      // them all up after the while() loop completes.
      HandleScope scope(env->isolate());
      Local<Value> async_id_value = Number::New(env->isolate(), async_id);
      MaybeLocal<Value> ret = fn->Call(
          env->context(), Undefined(env->isolate()), 1, &async_id_value);

      if (ret.IsEmpty())
        return;
    }
  }",6,,72,1,,void
6651,BLOCK,-1,,<empty>,35,,75,2,,void
6656,BLOCK,-1,,"{
      // Want each callback to be cleaned up after itself, instead of cleaning
      // them all up after the while() loop completes.
      HandleScope scope(env->isolate());
      Local<Value> async_id_value = Number::New(env->isolate(), async_id);
      MaybeLocal<Value> ret = fn->Call(
          env->context(), Undefined(env->isolate()), 1, &async_id_value);

      if (ret.IsEmpty())
        return;
    }",49,,76,3,,void
6705,BLOCK,-1,,<empty>,9,,85,2,,void
6722,BLOCK,-1,,"{
  AsyncHooks* async_hooks = env->async_hooks();

  if (async_hooks->fields()[type] == 0 || !env->can_call_into_js())
    return;

  HandleScope handle_scope(env->isolate());
  Local<Value> async_id_value = Number::New(env->isolate(), async_id);
  TryCatchScope try_catch(env, TryCatchScope::CatchMode::kFatal);
  USE(fn->Call(env->context(), Undefined(env->isolate()), 1, &async_id_value));
}",31,,91,5,,void
6745,BLOCK,-1,,<empty>,5,,95,2,,void
6798,BLOCK,-1,,"{
  Emit(env, async_id, AsyncHooks::kPromiseResolve,
       env->async_hooks_promise_resolve_function());
}",71,,104,3,,void
6812,BLOCK,-1,,"{
  switch (provider_type()) {
#define V(PROVIDER)                                                           \
    case PROVIDER_ ## PROVIDER:                                               \
      TRACE_EVENT_NESTABLE_ASYNC_BEGIN0(                                      \
        TRACING_CATEGORY_NODE1(async_hooks),                                  \
        #PROVIDER ""_CALLBACK"", static_cast<int64_t>(get_async_id()));         \
      break;
    NODE_ASYNC_PROVIDER_TYPES(V)
#undef V
    default:
      UNREACHABLE();
  }
}",40,,110,1,,void
6815,BLOCK,-1,,"{
#define V(PROVIDER)                                                           \
    case PROVIDER_ ## PROVIDER:                                               \
      TRACE_EVENT_NESTABLE_ASYNC_BEGIN0(                                      \
        TRACING_CATEGORY_NODE1(async_hooks),                                  \
        #PROVIDER ""_CALLBACK"", static_cast<int64_t>(get_async_id()));         \
      break;
    NODE_ASYNC_PROVIDER_TYPES(V)
#undef V
    default:
      UNREACHABLE();
  }",28,,111,2,,void
6825,BLOCK,-1,,"{
  Emit(env, async_id, AsyncHooks::kBefore,
       env->async_hooks_before_function());
}",63,,126,3,,void
6841,BLOCK,-1,,"{
  switch (type) {
#define V(PROVIDER)                                                           \
    case PROVIDER_ ## PROVIDER:                                               \
      TRACE_EVENT_NESTABLE_ASYNC_END0(                                        \
        TRACING_CATEGORY_NODE1(async_hooks),                                  \
        #PROVIDER ""_CALLBACK"", static_cast<int64_t>(async_id));               \
      break;
    NODE_ASYNC_PROVIDER_TYPES(V)
#undef V
    default:
      UNREACHABLE();
  }
}",73,,132,3,,void
6844,BLOCK,-1,,"{
#define V(PROVIDER)                                                           \
    case PROVIDER_ ## PROVIDER:                                               \
      TRACE_EVENT_NESTABLE_ASYNC_END0(                                        \
        TRACING_CATEGORY_NODE1(async_hooks),                                  \
        #PROVIDER ""_CALLBACK"", static_cast<int64_t>(async_id));               \
      break;
    NODE_ASYNC_PROVIDER_TYPES(V)
#undef V
    default:
      UNREACHABLE();
  }",17,,133,2,,void
6854,BLOCK,-1,,"{
  // If the user's callback failed then the after() hooks will be called at the
  // end of _fatalException().
  Emit(env, async_id, AsyncHooks::kAfter,
       env->async_hooks_after_function());
}",62,,148,3,,void
6869,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsObject());

  // All of init, before, after, destroy, and promise_resolve are supplied by
  // async_hooks internally, so this should only ever be called once. At which
  // time all the functions should be set. Detect this by checking if
  // init !IsEmpty().
  CHECK(env->async_hooks_init_function().IsEmpty());

  Local<Object> fn_obj = args[0].As<Object>();

#define SET_HOOK_FN(name)                                                      \
  do {                                                                         \
    Local<Value> v =                                                           \
        fn_obj->Get(env->context(),                                            \
                    FIXED_ONE_BYTE_STRING(env->isolate(), #name))              \
            .ToLocalChecked();                                                 \
    CHECK(v->IsFunction());                                               ...",65,,155,2,,void
6906,BLOCK,1,,<empty>,,,,4,,void
6908,BLOCK,-1,,SET_HOOK_FN(init),3,,178,1,,void
6947,BLOCK,1,,<empty>,,,,4,,void
6949,BLOCK,-1,,SET_HOOK_FN(before),3,,179,1,,void
6988,BLOCK,1,,<empty>,,,,4,,void
6990,BLOCK,-1,,SET_HOOK_FN(after),3,,180,1,,void
7029,BLOCK,1,,<empty>,,,,4,,void
7031,BLOCK,-1,,SET_HOOK_FN(destroy),3,,181,1,,void
7070,BLOCK,1,,<empty>,,,,4,,void
7072,BLOCK,-1,,SET_HOOK_FN(promise_resolve),3,,182,1,,void
7114,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  env->ResetPromiseHooks(
      args[0]->IsFunction() ? args[0].As<Function>() : Local<Function>(),
      args[1]->IsFunction() ? args[1].As<Function>() : Local<Function>(),
      args[2]->IsFunction() ? args[2].As<Function>() : Local<Function>(),
      args[3]->IsFunction() ? args[3].As<Function>() : Local<Function>());
}",70,,186,2,,void
7192,BLOCK,-1,,"{
  delete static_cast<DestroyParam*>(ptr);
}",48,,204,2,,void
7201,BLOCK,-1,,"{
  HandleScope scope(info.GetIsolate());

  std::unique_ptr<DestroyParam> p{info.GetParameter()};
  Local<Object> prop_bag = PersistentToLocal::Default(info.GetIsolate(),
                                                      p->propBag);
  Local<Value> val;

  p->env->RemoveCleanupHook(DestroyParamCleanupHook, p.get());

  if (!prop_bag.IsEmpty() &&
      !prop_bag->Get(p->env->context(), p->env->destroyed_string())
        .ToLocal(&val)) {
    return;
  }

  if (val.IsEmpty() || val->IsFalse()) {
    AsyncWrap::EmitDestroy(p->env, p->asyncId);
  }
  // unique_ptr goes out of scope here and pointer is deleted.
}",74,,208,2,,void
7282,BLOCK,-1,,"{
    return;
  }",25,,220,2,,void
7294,BLOCK,-1,,"{
    AsyncWrap::EmitDestroy(p->env, p->asyncId);
  }",40,,224,2,,void
7309,BLOCK,-1,,"{
  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsNumber());
  CHECK(args.Length() == 2 || args[2]->IsObject());

  Isolate* isolate = args.GetIsolate();
  DestroyParam* p = new DestroyParam();
  p->asyncId = args[1].As<Number>()->Value();
  p->env = Environment::GetCurrent(args);
  p->target.Reset(isolate, args[0].As<Object>());
  if (args.Length() > 2) {
    p->propBag.Reset(isolate, args[2].As<Object>());
  }
  p->target.SetWeak(p, AsyncWrap::WeakCallback, WeakCallbackType::kParameter);
  p->env->AddCleanupHook(DestroyParamCleanupHook, p);
}",74,,231,2,,void
7392,BLOCK,-1,,"{
    p->propBag.Reset(isolate, args[2].As<Object>());
  }",26,,241,2,,void
7431,BLOCK,-1,,"{
  AsyncWrap* wrap;
  args.GetReturnValue().Set(kInvalidAsyncId);
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  args.GetReturnValue().Set(wrap->get_async_id());
}",69,,248,2,,void
7463,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  // No need for CHECK(IsNumber()) on args because if FromJust() doesn't fail
  // then the checks in push_async_ids() and pop_async_id() will.
  double async_id = args[0]->NumberValue(env->context()).FromJust();
  double trigger_async_id = args[1]->NumberValue(env->context()).FromJust();
  env->async_hooks()->push_async_context(async_id, trigger_async_id, {});
}",75,,256,2,,void
7518,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  double async_id = args[0]->NumberValue(env->context()).FromJust();
  args.GetReturnValue().Set(env->async_hooks()->pop_async_context(async_id));
}",74,,266,2,,void
7562,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  uint32_t index;
  if (!args[0]->Uint32Value(env->context()).To(&index)) return;
  args.GetReturnValue().Set(
      env->async_hooks()->native_execution_async_resource(index));
}",46,,274,2,,void
7589,BLOCK,-1,,<empty>,57,,277,2,,void
7610,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  env->async_hooks()->clear_async_id_stack();
}",76,,283,2,,void
7630,BLOCK,-1,,"{
  CHECK(args[0]->IsObject());

  AsyncWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  Local<Object> resource = args[0].As<Object>();
  double execution_async_id =
      args[1]->IsNumber() ? args[1].As<Number>()->Value() : kInvalidAsyncId;
  wrap->AsyncReset(resource, execution_async_id);
}",69,,289,2,,void
7688,BLOCK,-1,,"{
  AsyncWrap* wrap;
  args.GetReturnValue().Set(AsyncWrap::PROVIDER_NONE);
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  args.GetReturnValue().Set(wrap->provider_type());
}",74,,302,2,,void
7722,BLOCK,-1,,"{
  AsyncWrap::EmitDestroy(env(), async_id_);
  // Ensure no double destroy is emitted via AsyncReset().
  async_id_ = kInvalidAsyncId;

  if (!persistent().IsEmpty() && !from_gc) {
    HandleScope handle_scope(env()->isolate());
    USE(object()->Set(env()->context(), env()->resource_symbol(), object()));
  }
}",43,,310,2,,void
7741,BLOCK,-1,,"{
    HandleScope handle_scope(env()->isolate());
    USE(object()->Set(env()->context(), env()->resource_symbol(), object()));
  }",44,,315,2,,void
7753,BLOCK,-1,,"{
  CHECK(args[0]->IsNumber());
  AsyncWrap::EmitDestroy(
      Environment::GetCurrent(args),
      args[0].As<Number>()->Value());
}",78,,321,2,,void
7783,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  if (args[0]->IsFunction()) {
    env->set_async_hooks_callback_trampoline(args[0].As<Function>());
  } else {
    env->set_async_hooks_callback_trampoline(Local<Function>());
  }
}",80,,328,2,,void
7799,BLOCK,-1,,"{
    env->set_async_hooks_callback_trampoline(args[0].As<Function>());
  }",30,,331,2,,void
7811,BLOCK,-1,,"{
    env->set_async_hooks_callback_trampoline(Local<Function>());
  }",10,,333,1,,void
7821,BLOCK,-1,,"{
  Local<FunctionTemplate> tmpl = isolate_data->async_wrap_ctor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = isolate_data->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->SetClassName(
        FIXED_ONE_BYTE_STRING(isolate_data->isolate(), ""AsyncWrap""));
    SetProtoMethod(isolate, tmpl, ""getAsyncId"", AsyncWrap::GetAsyncId);
    SetProtoMethod(isolate, tmpl, ""asyncReset"", AsyncWrap::AsyncReset);
    SetProtoMethod(
        isolate, tmpl, ""getProviderType"", AsyncWrap::GetProviderType);
    isolate_data->set_async_wrap_ctor_template(tmpl);
  }
  return tmpl;
}",32,,339,2,,void
7837,BLOCK,-1,,"{
    Isolate* isolate = isolate_data->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->SetClassName(
        FIXED_ONE_BYTE_STRING(isolate_data->isolate(), ""AsyncWrap""));
    SetProtoMethod(isolate, tmpl, ""getAsyncId"", AsyncWrap::GetAsyncId);
    SetProtoMethod(isolate, tmpl, ""asyncReset"", AsyncWrap::AsyncReset);
    SetProtoMethod(
        isolate, tmpl, ""getProviderType"", AsyncWrap::GetProviderType);
    isolate_data->set_async_wrap_ctor_template(tmpl);
  }",23,,341,2,,void
7893,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();
  Local<ObjectTemplate> target = ctor->InstanceTemplate();

  SetMethod(isolate, target, ""setupHooks"", SetupHooks);
  SetMethod(isolate, target, ""setCallbackTrampoline"", SetCallbackTrampoline);
  SetMethod(isolate, target, ""pushAsyncContext"", PushAsyncContext);
  SetMethod(isolate, target, ""popAsyncContext"", PopAsyncContext);
  SetMethod(isolate, target, ""executionAsyncResource"", ExecutionAsyncResource);
  SetMethod(isolate, target, ""clearAsyncIdStack"", ClearAsyncIdStack);
  SetMethod(isolate, target, ""queueDestroyAsyncId"", QueueDestroyAsyncId);
  SetMethod(isolate, target, ""setPromiseHooks"", SetPromiseHooks);
  SetMethod(isolate, target, ""registerDestroyHook"", RegisterDestroyHook);
  AsyncWrap::GetConstructorTemplate(isolate_data);
}",74,,356,3,,void
7968,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();
  HandleScope scope(isolate);

  PropertyAttribute ReadOnlyDontDelete =
      static_cast<PropertyAttribute>(ReadOnly | DontDelete);

#define FORCE_SET_TARGET_FIELD(obj, str, field)                               \
  (obj)->DefineOwnProperty(context,                                           \
                           FIXED_ONE_BYTE_STRING(isolate, str),               \
                           field,                                             \
                           ReadOnlyDontDelete).FromJust()

  // Attach the uint32_t[] where each slot contains the count of the number of
  // callbacks waiting to be called on a particular event. It can then be
  // incremented/decremented from JS quickly to communicate to C++ if there are
  // any callbacks waiting to be called.
  FORCE_SET_TARGET_FIELD(target,
                         ""async_hook_fields"",
                         env->async_h...",56,,375,5,,void
8008,BLOCK,1,,<empty>,,,,7,,void
8044,BLOCK,1,,<empty>,,,,7,,void
8077,BLOCK,1,,<empty>,,,,7,,void
8131,BLOCK,1,,<empty>,,,,4,,void
8153,BLOCK,1,,<empty>,,,,4,,void
8175,BLOCK,1,,<empty>,,,,4,,void
8197,BLOCK,1,,<empty>,,,,4,,void
8219,BLOCK,1,,<empty>,,,,4,,void
8241,BLOCK,1,,<empty>,,,,4,,void
8263,BLOCK,1,,<empty>,,,,4,,void
8285,BLOCK,1,,<empty>,,,,4,,void
8307,BLOCK,1,,<empty>,,,,4,,void
8329,BLOCK,1,,<empty>,,,,4,,void
8351,BLOCK,1,,<empty>,,,,4,,void
8373,BLOCK,1,,<empty>,,,,4,,void
8395,BLOCK,1,,<empty>,,,,4,,void
8420,BLOCK,1,,<empty>,,,,6,,void
8454,BLOCK,1,,<empty>,,,,2,,void
8503,BLOCK,-1,,"{
  registry->Register(SetupHooks);
  registry->Register(SetCallbackTrampoline);
  registry->Register(PushAsyncContext);
  registry->Register(PopAsyncContext);
  registry->Register(ExecutionAsyncResource);
  registry->Register(ClearAsyncIdStack);
  registry->Register(QueueDestroyAsyncId);
  registry->Register(SetPromiseHooks);
  registry->Register(RegisterDestroyHook);
  registry->Register(AsyncWrap::GetAsyncId);
  registry->Register(AsyncWrap::AsyncReset);
  registry->Register(AsyncWrap::GetProviderType);
}",42,,460,2,,void
8577,BLOCK,-1,,<empty>,67,,479,5,,void
8586,BLOCK,-1,,"{
  CHECK_NE(provider, PROVIDER_NONE);
  provider_type_ = provider;

  // Use AsyncReset() call to execute the init() callbacks.
  AsyncReset(object, execution_async_id, silent);
  init_hook_ran_ = true;
}",30,,486,6,,void
8608,BLOCK,-1,,"{
  trigger_async_id_ = trigger_async_id;
}",66,,500,6,,void
8617,BLOCK,-1,,"{
}",29,,505,3,,void
8621,BLOCK,-1,,"{
  return init_hook_ran_;
}",44,,529,1,,void
8627,BLOCK,-1,,"{
  EmitTraceEventDestroy();
  EmitDestroy(true /* from gc */);
}",25,,533,1,,void
8634,BLOCK,-1,,"{
  switch (provider_type()) {
  #define V(PROVIDER)                                                         \
    case PROVIDER_ ## PROVIDER:                                               \
      TRACE_EVENT_NESTABLE_ASYNC_END0(                                        \
        TRACING_CATEGORY_NODE1(async_hooks),                                  \
        #PROVIDER, static_cast<int64_t>(get_async_id()));                     \
      break;
    NODE_ASYNC_PROVIDER_TYPES(V)
  #undef V
    default:
      UNREACHABLE();
  }
}",41,,538,1,,void
8637,BLOCK,-1,,"{
  #define V(PROVIDER)                                                         \
    case PROVIDER_ ## PROVIDER:                                               \
      TRACE_EVENT_NESTABLE_ASYNC_END0(                                        \
        TRACING_CATEGORY_NODE1(async_hooks),                                  \
        #PROVIDER, static_cast<int64_t>(get_async_id()));                     \
      break;
    NODE_ASYNC_PROVIDER_TYPES(V)
  #undef V
    default:
      UNREACHABLE();
  }",28,,539,2,,void
8646,BLOCK,-1,,"{
  if (env->async_hooks()->fields()[AsyncHooks::kDestroy] == 0 ||
      !env->can_call_into_js()) {
    return;
  }

  if (env->destroy_async_id_list()->empty()) {
    env->SetImmediate(&DestroyAsyncIdsCallback, CallbackFlags::kUnrefed);
  }

  // If the list gets very large empty it faster using a Microtask.
  // Microtasks can't be added in GC context therefore we use an
  // interrupt to get this Microtask scheduled as fast as possible.
  if (env->destroy_async_id_list()->size() == 16384) {
    env->RequestInterrupt([](Environment* env) {
      env->context()->GetMicrotaskQueue()->EnqueueMicrotask(
        env->isolate(),
        [](void* arg) {
          DestroyAsyncIdsCallback(static_cast<Environment*>(arg));
        }, env);
      });
  }

  env->destroy_async_id_list()->push_back(async_id);
}",64,,553,3,,void
8667,BLOCK,-1,,"{
    return;
  }",33,,555,2,,void
8677,BLOCK,-1,,"{
    env->SetImmediate(&DestroyAsyncIdsCallback, CallbackFlags::kUnrefed);
  }",46,,559,2,,void
8697,BLOCK,-1,,"{
    env->RequestInterrupt([](Environment* env) {
      env->context()->GetMicrotaskQueue()->EnqueueMicrotask(
        env->isolate(),
        [](void* arg) {
          DestroyAsyncIdsCallback(static_cast<Environment*>(arg));
        }, env);
      });
  }",54,,566,2,,void
8717,BLOCK,-1,,"{
  CHECK_NE(provider_type(), PROVIDER_NONE);

  if (async_id_ != kInvalidAsyncId) {
    // This instance was in use before, we have already emitted an init with
    // its previous async_id and need to emit a matching destroy for that
    // before generating a new async_id.
    EmitDestroy();
  }

  // Now we can assign a new async_id_ to this instance.
  async_id_ = execution_async_id == kInvalidAsyncId ? env()->new_async_id()
                                                     : execution_async_id;
  trigger_async_id_ = env()->get_default_trigger_async_id();

  {
    HandleScope handle_scope(env()->isolate());
    Local<Object> obj = object();
    CHECK(!obj.IsEmpty());
    if (resource != obj) {
      USE(obj->Set(env()->context(), env()->resource_symbol(), resource));
    }
  }

  switch (provider_type()) {
#define V(PROVIDER)                                                           \
    case PROVIDER_ ## PROVIDER:                                               \
      if (*...",41,,583,4,,void
8725,BLOCK,-1,,"{
    // This instance was in use before, we have already emitted an init with
    // its previous async_id and need to emit a matching destroy for that
    // before generating a new async_id.
    EmitDestroy();
  }",37,,586,2,,void
8744,BLOCK,5,,"{
    HandleScope handle_scope(env()->isolate());
    Local<Object> obj = object();
    CHECK(!obj.IsEmpty());
    if (resource != obj) {
      USE(obj->Set(env()->context(), env()->resource_symbol(), resource));
    }
  }",3,,598,5,,void
8768,BLOCK,-1,,"{
      USE(obj->Set(env()->context(), env()->resource_symbol(), resource));
    }",26,,602,2,,void
8785,BLOCK,-1,,"{
#define V(PROVIDER)                                                           \
    case PROVIDER_ ## PROVIDER:                                               \
      if (*TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED(                        \
          TRACING_CATEGORY_NODE1(async_hooks))) {                             \
        auto data = tracing::TracedValue::Create();                           \
        data->SetInteger(""executionAsyncId"",                                  \
                         static_cast<int64_t>(env()->execution_async_id()));  \
        data->SetInteger(""triggerAsyncId"",                                    \
                         static_cast<int64_t>(get_trigger_async_id()));       \
        TRACE_EVENT_NESTABLE_ASYNC_BEGIN1(                                    \
          TRACING_CATEGORY_NODE1(async_hooks),                                \
          #PROVIDER, static_cast<int64_t>(get_async_id()),                    \
          ""data"", std::move(data));...",28,,607,2,,void
8792,BLOCK,-1,,<empty>,15,,629,2,,void
8815,BLOCK,-1,,"{
  CHECK(!object.IsEmpty());
  CHECK(!type.IsEmpty());
  AsyncHooks* async_hooks = env->async_hooks();

  // Nothing to execute, so can continue normally.
  if (async_hooks->fields()[AsyncHooks::kInit] == 0) {
    return;
  }

  HandleScope scope(env->isolate());
  Local<Function> init_fn = env->async_hooks_init_function();

  Local<Value> argv[] = {
    Number::New(env->isolate(), async_id),
    type,
    Number::New(env->isolate(), trigger_async_id),
    object,
  };

  TryCatchScope try_catch(env, TryCatchScope::CatchMode::kFatal);
  USE(init_fn->Call(env->context(), object, arraysize(argv), argv));
}",56,,640,6,,void
8846,BLOCK,-1,,"{
    return;
  }",54,,646,2,,void
8915,BLOCK,-1,,"{
  EmitTraceEventBefore();

  ProviderType provider = provider_type();
  async_context context { get_async_id(), get_trigger_async_id() };
  MaybeLocal<Value> ret = InternalMakeCallback(
      env(), object(), object(), cb, argc, argv, context);

  // This is a static call with cached values because the `this` object may
  // no longer be alive at this point.
  EmitTraceEventAfter(provider, context.async_id);

  return ret;
}",63,,667,4,,void
8951,BLOCK,-1,,"{
  return provider_names[provider_type()];
}",47,,682,1,,void
8959,BLOCK,-1,,"{
  char buf[64];
  snprintf(buf,
           sizeof(buf),
           ""%s(%"" PRIu64 "":%.0f)"",
           MemoryInfoName(),
           env()->thread_id(),
           async_id_);
  return buf;
}",48,,686,1,,void
8967,BLOCK,-1,,"{
  return GetOwner(env(), object());
}",37,,697,1,,void
8977,BLOCK,-1,,"{
  EscapableHandleScope handle_scope(env->isolate());
  CHECK(!obj.IsEmpty());

  TryCatchScope ignore_exceptions(env);
  while (true) {
    Local<Value> owner;
    if (!obj->Get(env->context(),
                  env->owner_symbol()).ToLocal(&owner) ||
        !owner->IsObject()) {
      return handle_scope.Escape(obj);
    }

    obj = owner.As<Object>();
  }
}",72,,701,3,,void
8995,BLOCK,-1,,"{
    Local<Value> owner;
    if (!obj->Get(env->context(),
                  env->owner_symbol()).ToLocal(&owner) ||
        !owner->IsObject()) {
      return handle_scope.Escape(obj);
    }

    obj = owner.As<Object>();
  }",16,,706,2,,void
9026,BLOCK,-1,,"{
      return handle_scope.Escape(obj);
    }",29,,710,2,,void
9052,BLOCK,-1,,<empty>,1,,1,1,,ANY
9063,BLOCK,-1,,<empty>,1,,1,1,,ANY
9076,BLOCK,-1,,<empty>,1,,1,1,,ANY
9081,BLOCK,-1,,<empty>,1,,1,1,,ANY
9094,BLOCK,-1,,<empty>,1,,1,1,,ANY
9098,BLOCK,-1,,"{
        BaseObject* obj = data.GetParameter();
        // Clear the persistent handle so that ~BaseObject() doesn't attempt
        // to mess with internal fields, since the JS object may have
        // transitioned into an invalid state.
        // Refs: https://github.com/nodejs/node/issues/18897
        obj->persistent_handle_.Reset();
        CHECK_IMPLIES(obj->has_pointer_data(),
                      obj->pointer_data()->strong_ptr_count == 0);
        obj->OnGCCollect();
      }",52,,55,2,,void
9141,BLOCK,-1,,<empty>,1,,1,1,,ANY
9146,BLOCK,-1,,"{
  CHECK_EQ(false, object.IsEmpty());
  CHECK_GE(object->InternalFieldCount(), BaseObject::kInternalFieldCount);
  SetInternalFields(object, static_cast<void*>(this));
  realm->AddCleanupHook(DeleteMe, static_cast<void*>(this));
  realm->modify_base_object_count(1);
}",67,,17,3,,void
9182,BLOCK,-1,,"{
  realm()->modify_base_object_count(-1);
  realm()->RemoveCleanupHook(DeleteMe, static_cast<void*>(this));

  if (UNLIKELY(has_pointer_data())) {
    PointerData* metadata = pointer_data();
    CHECK_EQ(metadata->strong_ptr_count, 0);
    metadata->self = nullptr;
    if (metadata->weak_ptr_count == 0) delete metadata;
  }

  if (persistent_handle_.IsEmpty()) {
    // This most likely happened because the weak callback below cleared it.
    return;
  }

  {
    HandleScope handle_scope(realm()->isolate());
    object()->SetAlignedPointerInInternalField(BaseObject::kSlot, nullptr);
  }
}",27,,25,1,,void
9198,BLOCK,-1,,<empty>,7,,29,1,,void
9200,BLOCK,-1,,"{
    PointerData* metadata = pointer_data();
    CHECK_EQ(metadata->strong_ptr_count, 0);
    metadata->self = nullptr;
    if (metadata->weak_ptr_count == 0) delete metadata;
  }",37,,29,2,,void
9221,BLOCK,-1,,<empty>,40,,33,2,,void
9229,BLOCK,-1,,"{
    // This most likely happened because the weak callback below cleared it.
    return;
  }",37,,36,2,,void
9231,BLOCK,5,,"{
    HandleScope handle_scope(realm()->isolate());
    object()->SetAlignedPointerInInternalField(BaseObject::kSlot, nullptr);
  }",3,,41,5,,void
9249,BLOCK,-1,,"{
  if (has_pointer_data()) {
    pointer_data()->wants_weak_jsobj = true;
    if (pointer_data()->strong_ptr_count > 0) return;
  }

  persistent_handle_.SetWeak(
      this,
      [](const WeakCallbackInfo<BaseObject>& data) {
        BaseObject* obj = data.GetParameter();
        // Clear the persistent handle so that ~BaseObject() doesn't attempt
        // to mess with internal fields, since the JS object may have
        // transitioned into an invalid state.
        // Refs: https://github.com/nodejs/node/issues/18897
        obj->persistent_handle_.Reset();
        CHECK_IMPLIES(obj->has_pointer_data(),
                      obj->pointer_data()->strong_ptr_count == 0);
        obj->OnGCCollect();
      },
      WeakCallbackType::kParameter);
}",29,,47,1,,void
9252,BLOCK,-1,,"{
    pointer_data()->wants_weak_jsobj = true;
    if (pointer_data()->strong_ptr_count > 0) return;
  }",27,,48,2,,void
9264,BLOCK,-1,,<empty>,47,,50,2,,void
9283,BLOCK,-1,,"{
  DCHECK(args.IsConstructCall());
  CHECK_GE(args.This()->InternalFieldCount(), BaseObject::kInternalFieldCount);
  SetInternalFields(args.This(), nullptr);
}",46,,77,2,,void
9310,BLOCK,-1,,"{
  return MakeLazilyInitializedJSTemplate(env->isolate_data());
}",23,,84,2,,void
9321,BLOCK,-1,,"{
  Local<FunctionTemplate> t = NewFunctionTemplate(
      isolate_data->isolate(), LazilyInitializedJSTemplateConstructor);
  t->InstanceTemplate()->SetInternalFieldCount(BaseObject::kInternalFieldCount);
  return t;
}",32,,89,2,,void
9349,BLOCK,-1,,"{
  if (!has_pointer_data()) {
    PointerData* metadata = new PointerData();
    metadata->wants_weak_jsobj = persistent_handle_.IsWeak();
    metadata->self = this;
    pointer_data_ = metadata;
  }
  CHECK(has_pointer_data());
  return pointer_data_;
}",53,,96,1,,void
9353,BLOCK,-1,,"{
    PointerData* metadata = new PointerData();
    metadata->wants_weak_jsobj = persistent_handle_.IsWeak();
    metadata->self = this;
    pointer_data_ = metadata;
  }",28,,97,2,,void
9381,BLOCK,-1,,"{
  CHECK(has_pointer_data());
  PointerData* metadata = pointer_data();
  CHECK_GT(metadata->strong_ptr_count, 0);
  unsigned int new_refcount = --metadata->strong_ptr_count;
  if (new_refcount == 0) {
    if (metadata->is_detached) {
      OnGCCollect();
    } else if (metadata->wants_weak_jsobj && !persistent_handle_.IsEmpty()) {
      MakeWeak();
    }
  }
}",38,,107,1,,void
9403,BLOCK,-1,,"{
    if (metadata->is_detached) {
      OnGCCollect();
    } else if (metadata->wants_weak_jsobj && !persistent_handle_.IsEmpty()) {
      MakeWeak();
    }
  }",26,,112,2,,void
9408,BLOCK,-1,,"{
      OnGCCollect();
    }",32,,113,2,,void
9411,BLOCK,-1,,<empty>,12,,115,1,,void
9422,BLOCK,-1,,"{
      MakeWeak();
    }",77,,115,2,,void
9427,BLOCK,-1,,"{
  unsigned int prev_refcount = pointer_data()->strong_ptr_count++;
  if (prev_refcount == 0 && !persistent_handle_.IsEmpty())
    persistent_handle_.ClearWeak();
}",38,,121,1,,void
9445,BLOCK,-1,,<empty>,5,,124,2,,void
9454,BLOCK,-1,,"{
  BaseObject* self = static_cast<BaseObject*>(data);
  if (self->has_pointer_data() && self->pointer_data()->strong_ptr_count > 0) {
    return self->Detach();
  }
  delete self;
}",39,,127,2,,void
9475,BLOCK,-1,,"{
    return self->Detach();
  }",79,,129,2,,void
9486,BLOCK,-1,,"{
  return true;
}",45,,135,1,,void
9492,BLOCK,-1,,"{
  return object();
}",49,,139,1,,void
9498,BLOCK,-1,,"{
  return !persistent_handle_.IsWeak();
}",37,,143,1,,void
9508,BLOCK,-1,,"{
  return IsWeakOrDetached();
}",60,,147,1,,void
9525,BLOCK,-1,,<empty>,1,,1,1,,ANY
9532,BLOCK,-1,,<empty>,1,,1,1,,ANY
9551,BLOCK,-1,,<empty>,1,,1,1,,ANY
9560,BLOCK,-1,,<empty>,1,,1,1,,ANY
9567,BLOCK,-1,,<empty>,1,,1,1,,ANY
9574,BLOCK,-1,,<empty>,1,,1,1,,ANY
9578,BLOCK,-1,,{ delete handle; },60,,763,2,,void
9586,BLOCK,-1,,{ uv_freeaddrinfo(res); },37,,1432,1,,void
9596,BLOCK,-1,,"{
      for (auto p = res; p != nullptr; p = p->ai_next) {
        CHECK_EQ(p->ai_socktype, SOCK_STREAM);

        const char* addr;
        if (want_ipv4 && p->ai_family == AF_INET) {
          addr = reinterpret_cast<char*>(
              &(reinterpret_cast<struct sockaddr_in*>(p->ai_addr)->sin_addr));
        } else if (want_ipv6 && p->ai_family == AF_INET6) {
          addr = reinterpret_cast<char*>(
              &(reinterpret_cast<struct sockaddr_in6*>(p->ai_addr)->sin6_addr));
        } else {
          continue;
        }

        char ip[INET6_ADDRSTRLEN];
        if (uv_inet_ntop(p->ai_family, addr, ip, sizeof(ip)))
          continue;

        Local<String> s = OneByteString(env->isolate(), ip);
        if (results->Set(env->context(), n, s).IsNothing())
          return Nothing<bool>();
        n++;
      }
      return Just(true);
    }",68,,1451,3,,void
9598,BLOCK,-1,,<empty>,7,,1452,1,,void
9611,BLOCK,4,,"{
        CHECK_EQ(p->ai_socktype, SOCK_STREAM);

        const char* addr;
        if (want_ipv4 && p->ai_family == AF_INET) {
          addr = reinterpret_cast<char*>(
              &(reinterpret_cast<struct sockaddr_in*>(p->ai_addr)->sin_addr));
        } else if (want_ipv6 && p->ai_family == AF_INET6) {
          addr = reinterpret_cast<char*>(
              &(reinterpret_cast<struct sockaddr_in6*>(p->ai_addr)->sin6_addr));
        } else {
          continue;
        }

        char ip[INET6_ADDRSTRLEN];
        if (uv_inet_ntop(p->ai_family, addr, ip, sizeof(ip)))
          continue;

        Local<String> s = OneByteString(env->isolate(), ip);
        if (results->Set(env->context(), n, s).IsNothing())
          return Nothing<bool>();
        n++;
      }",56,,1452,4,,void
9626,BLOCK,-1,,"{
          addr = reinterpret_cast<char*>(
              &(reinterpret_cast<struct sockaddr_in*>(p->ai_addr)->sin_addr));
        }",51,,1456,2,,void
9640,BLOCK,-1,,<empty>,16,,1459,1,,void
9649,BLOCK,-1,,"{
          addr = reinterpret_cast<char*>(
              &(reinterpret_cast<struct sockaddr_in6*>(p->ai_addr)->sin6_addr));
        }",59,,1459,2,,void
9663,BLOCK,-1,,"{
          continue;
        }",16,,1462,1,,void
9675,BLOCK,-1,,<empty>,11,,1468,2,,void
9703,BLOCK,-1,,<empty>,11,,1472,2,,void
9717,BLOCK,-1,,{ ares_free_data(servers); },37,,1658,1,,void
9764,BLOCK,-1,,<empty>,1,,1,1,,ANY
9771,BLOCK,-1,,"{
  return static_cast<uint32_t>(p[0] << 8U) | (static_cast<uint32_t>(p[1]));
}",57,,81,2,,void
9792,BLOCK,-1,,"{
  NodeAresTask* task = ContainerOf(&NodeAresTask::poll_watcher, watcher);
  ChannelWrap* channel = task->channel;

  /* Reset the idle timer */
  uv_timer_again(channel->timer_handle());

  if (status < 0) {
    /* An error happened. Just pretend that the socket is both readable and */
    /* writable. */
    ares_process_fd(channel->cares_channel(), task->sock, task->sock);
    return;
  }

  /* Process DNS responses */
  ares_process_fd(channel->cares_channel(),
                  events & UV_READABLE ? task->sock : ARES_SOCKET_BAD,
                  events & UV_WRITABLE ? task->sock : ARES_SOCKET_BAD);
}",63,,85,4,,void
9817,BLOCK,-1,,"{
    /* An error happened. Just pretend that the socket is both readable and */
    /* writable. */
    ares_process_fd(channel->cares_channel(), task->sock, task->sock);
    return;
  }",19,,92,2,,void
9855,BLOCK,-1,,"{
  std::unique_ptr<NodeAresTask> free_me(
        ContainerOf(&NodeAresTask::poll_watcher, watcher));
}",45,,106,2,,void
9876,BLOCK,-1,,"{
  ChannelWrap* channel = static_cast<ChannelWrap*>(data);
  NodeAresTask* task;

  NodeAresTask lookup_task;
  lookup_task.sock = sock;
  auto it = channel->task_list()->find(&lookup_task);

  task = (it == channel->task_list()->end()) ? nullptr : *it;

  if (read || write) {
    if (!task) {
      /* New socket */
      channel->StartTimer();

      task = NodeAresTask::Create(channel, sock);
      if (task == nullptr) {
        /* This should never happen unless we're out of memory or something */
        /* is seriously wrong. The socket won't be polled, but the query will */
        /* eventually time out. */
        return;
      }

      channel->task_list()->insert(task);
    }

    /* This should never fail. If it fails anyway, the query will eventually */
    /* time out. */
    uv_poll_start(&task->poll_watcher,
                  (read ? UV_READABLE : 0) | (write ? UV_WRITABLE : 0),
                  ares_poll_cb);

  } else {
    /* read == 0 and write == 0 this is c-ar...",77,,113,5,,void
9921,BLOCK,-1,,"{
    if (!task) {
      /* New socket */
      channel->StartTimer();

      task = NodeAresTask::Create(channel, sock);
      if (task == nullptr) {
        /* This should never happen unless we're out of memory or something */
        /* is seriously wrong. The socket won't be polled, but the query will */
        /* eventually time out. */
        return;
      }

      channel->task_list()->insert(task);
    }

    /* This should never fail. If it fails anyway, the query will eventually */
    /* time out. */
    uv_poll_start(&task->poll_watcher,
                  (read ? UV_READABLE : 0) | (write ? UV_WRITABLE : 0),
                  ares_poll_cb);

  }",22,,123,2,,void
9925,BLOCK,-1,,"{
      /* New socket */
      channel->StartTimer();

      task = NodeAresTask::Create(channel, sock);
      if (task == nullptr) {
        /* This should never happen unless we're out of memory or something */
        /* is seriously wrong. The socket won't be polled, but the query will */
        /* eventually time out. */
        return;
      }

      channel->task_list()->insert(task);
    }",16,,124,2,,void
9942,BLOCK,-1,,"{
        /* This should never happen unless we're out of memory or something */
        /* is seriously wrong. The socket won't be polled, but the query will */
        /* eventually time out. */
        return;
      }",28,,129,2,,void
9968,BLOCK,-1,,"{
    /* read == 0 and write == 0 this is c-ares's way of notifying us that */
    /* the socket is now closed. We must free the data associated with */
    /* socket. */
    CHECK(task &&
          ""When an ares socket is closed we should have a handle for it"");

    channel->task_list()->erase(it);
    channel->env()->CloseHandle(&task->poll_watcher, ares_poll_close_cb);

    if (channel->task_list()->empty()) {
      channel->CloseTimer();
    }
  }",10,,145,1,,void
10001,BLOCK,-1,,"{
      channel->CloseTimer();
    }",40,,155,2,,void
10011,BLOCK,-1,,"{
  EscapableHandleScope scope(env->isolate());

  std::vector<Local<Value>> names;

  for (uint32_t i = 0; host->h_aliases[i] != nullptr; ++i)
    names.emplace_back(OneByteString(env->isolate(), host->h_aliases[i]));

  Local<Array> ret = Array::New(env->isolate(), names.data(), names.size());

  return scope.Escape(ret);
}",69,,161,3,,void
10028,BLOCK,-1,,<empty>,3,,166,1,,void
10090,BLOCK,-1,,"{
  size_t offset = names->Length();

  for (uint32_t i = 0; host->h_aliases[i] != nullptr; ++i) {
    names->Set(
        env->context(),
        i + offset,
        OneByteString(env->isolate(), host->h_aliases[i])).Check();
  }

  return names;
}",49,,176,4,,void
10099,BLOCK,-1,,<empty>,3,,179,1,,void
10113,BLOCK,4,,"{
    names->Set(
        env->context(),
        i + offset,
        OneByteString(env->isolate(), host->h_aliases[i])).Check();
  }",60,,179,4,,void
10146,BLOCK,-1,,"{
  MaybeStackBuffer<Local<Value>, 8> ttls(naddrttls);
  for (size_t i = 0; i < naddrttls; i++)
    ttls[i] = Integer::NewFromUnsigned(env->isolate(), addrttls[i].ttl);

  return Array::New(env->isolate(), ttls.out(), naddrttls);
}",23,,193,4,,void
10151,BLOCK,-1,,<empty>,3,,195,1,,void
10202,BLOCK,-1,,"{
  HandleScope handle_scope(env->isolate());
  hostent* host;

  int status;
  switch (*type) {
    case ns_t_a:
    case ns_t_cname:
    case ns_t_cname_or_a:
      status = ares_parse_a_reply(buf,
                                  len,
                                  &host,
                                  static_cast<ares_addrttl*>(addrttls),
                                  naddrttls);
      break;
    case ns_t_aaaa:
      status = ares_parse_aaaa_reply(buf,
                                     len,
                                     &host,
                                     static_cast<ares_addr6ttl*>(addrttls),
                                     naddrttls);
      break;
    case ns_t_ns:
      status = ares_parse_ns_reply(buf, len, &host);
      break;
    case ns_t_ptr:
      status = ares_parse_ptr_reply(buf, len, nullptr, 0, AF_INET, &host);
      break;
    default:
      UNREACHABLE(""Bad NS type"");
  }

  if (status != ARES_SUCCESS)
    return status;

  CHECK...",31,,208,8,,void
10214,BLOCK,-1,,"{
    case ns_t_a:
    case ns_t_cname:
    case ns_t_cname_or_a:
      status = ares_parse_a_reply(buf,
                                  len,
                                  &host,
                                  static_cast<ares_addrttl*>(addrttls),
                                  naddrttls);
      break;
    case ns_t_aaaa:
      status = ares_parse_aaaa_reply(buf,
                                     len,
                                     &host,
                                     static_cast<ares_addr6ttl*>(addrttls),
                                     naddrttls);
      break;
    case ns_t_ns:
      status = ares_parse_ns_reply(buf, len, &host);
      break;
    case ns_t_ptr:
      status = ares_parse_ptr_reply(buf, len, nullptr, 0, AF_INET, &host);
      break;
    default:
      UNREACHABLE(""Bad NS type"");
  }",18,,213,2,,void
10277,BLOCK,-1,,<empty>,5,,241,2,,void
10305,BLOCK,-1,,"{
    // A cname lookup always returns a single record but we follow the
    // common API here.
    *type = ns_t_cname;
    ret->Set(env->context(),
             ret->Length(),
             OneByteString(env->isolate(), ptr->h_name)).Check();
    return ARES_SUCCESS;
  }",28,,250,2,,void
10340,BLOCK,-1,,<empty>,5,,261,2,,void
10350,BLOCK,-1,,"{
    HostentToNames(env, ptr.get(), ret);
  }",25,,263,2,,void
10359,BLOCK,-1,,<empty>,10,,265,1,,void
10365,BLOCK,-1,,"{
    uint32_t offset = ret->Length();
    for (uint32_t i = 0; ptr->h_aliases[i] != nullptr; i++) {
      auto alias = OneByteString(env->isolate(), ptr->h_aliases[i]);
      ret->Set(env->context(), i + offset, alias).Check();
    }
  }",33,,265,2,,void
10374,BLOCK,-1,,<empty>,5,,267,1,,void
10388,BLOCK,4,,"{
      auto alias = OneByteString(env->isolate(), ptr->h_aliases[i]);
      ret->Set(env->context(), i + offset, alias).Check();
    }",61,,267,4,,void
10418,BLOCK,-1,,"{
    uint32_t offset = ret->Length();
    char ip[INET6_ADDRSTRLEN];
    for (uint32_t i = 0; ptr->h_addr_list[i] != nullptr; ++i) {
      uv_inet_ntop(ptr->h_addrtype, ptr->h_addr_list[i], ip, sizeof(ip));
      auto address = OneByteString(env->isolate(), ip);
      ret->Set(env->context(), i + offset, address).Check();
    }
  }",10,,271,1,,void
10428,BLOCK,-1,,<empty>,5,,274,1,,void
10442,BLOCK,4,,"{
      uv_inet_ntop(ptr->h_addrtype, ptr->h_addr_list[i], ip, sizeof(ip));
      auto address = OneByteString(env->isolate(), ip);
      ret->Set(env->context(), i + offset, address).Check();
    }",63,,274,4,,void
10489,BLOCK,-1,,"{
  HandleScope handle_scope(env->isolate());

  struct ares_mx_reply* mx_start;
  int status = ares_parse_mx_reply(buf, len, &mx_start);
  if (status != ARES_SUCCESS)
    return status;

  uint32_t offset = ret->Length();
  ares_mx_reply* current = mx_start;
  for (uint32_t i = 0; current != nullptr; ++i, current = current->next) {
    Local<Object> mx_record = Object::New(env->isolate());
    mx_record->Set(env->context(),
                   env->exchange_string(),
                   OneByteString(env->isolate(), current->host)).Check();
    mx_record->Set(env->context(),
                   env->priority_string(),
                   Integer::New(env->isolate(), current->priority)).Check();
    if (need_type)
      mx_record->Set(env->context(),
                     env->type_string(),
                     env->dns_mx_string()).Check();

    ret->Set(env->context(), i + offset, mx_record).Check();
  }

  ares_free_data(mx_start);
  return ARES_SUCCESS;
}",29,,289,6,,void
10509,BLOCK,-1,,<empty>,5,,295,2,,void
10524,BLOCK,-1,,<empty>,3,,299,1,,void
10540,BLOCK,4,,"{
    Local<Object> mx_record = Object::New(env->isolate());
    mx_record->Set(env->context(),
                   env->exchange_string(),
                   OneByteString(env->isolate(), current->host)).Check();
    mx_record->Set(env->context(),
                   env->priority_string(),
                   Integer::New(env->isolate(), current->priority)).Check();
    if (need_type)
      mx_record->Set(env->context(),
                     env->type_string(),
                     env->dns_mx_string()).Check();

    ret->Set(env->context(), i + offset, mx_record).Check();
  }",74,,299,4,,void
10606,BLOCK,-1,,<empty>,7,,308,2,,void
10653,BLOCK,-1,,"{
  HandleScope handle_scope(env->isolate());

  struct ares_caa_reply* caa_start;
  int status = ares_parse_caa_reply(buf, len, &caa_start);
  if (status != ARES_SUCCESS)
    return status;

  uint32_t offset = ret->Length();
  ares_caa_reply* current = caa_start;
  for (uint32_t i = 0; current != nullptr; ++i, current = current->next) {
    Local<Object> caa_record = Object::New(env->isolate());

    caa_record->Set(env->context(),
                    env->dns_critical_string(),
                    Integer::New(env->isolate(), current->critical)).Check();
    caa_record->Set(env->context(),
                    OneByteString(env->isolate(), current->property),
                    OneByteString(env->isolate(), current->value)).Check();
    if (need_type)
      caa_record->Set(env->context(),
                      env->type_string(),
                      env->dns_caa_string()).Check();

    ret->Set(env->context(), i + offset, caa_record).Check();
  }

  ares_free_data(caa_start);
 ...",29,,324,6,,void
10673,BLOCK,-1,,<empty>,5,,330,2,,void
10688,BLOCK,-1,,<empty>,3,,334,1,,void
10704,BLOCK,4,,"{
    Local<Object> caa_record = Object::New(env->isolate());

    caa_record->Set(env->context(),
                    env->dns_critical_string(),
                    Integer::New(env->isolate(), current->critical)).Check();
    caa_record->Set(env->context(),
                    OneByteString(env->isolate(), current->property),
                    OneByteString(env->isolate(), current->value)).Check();
    if (need_type)
      caa_record->Set(env->context(),
                      env->type_string(),
                      env->dns_caa_string()).Check();

    ret->Set(env->context(), i + offset, caa_record).Check();
  }",74,,334,4,,void
10774,BLOCK,-1,,<empty>,7,,344,2,,void
10821,BLOCK,-1,,"{
  HandleScope handle_scope(env->isolate());

  struct ares_txt_ext* txt_out;

  int status = ares_parse_txt_reply_ext(buf, len, &txt_out);
  if (status != ARES_SUCCESS)
    return status;

  Local<Array> txt_chunk;

  struct ares_txt_ext* current = txt_out;
  uint32_t i = 0, j;
  uint32_t offset = ret->Length();
  for (j = 0; current != nullptr; current = current->next) {
    Local<String> txt =
        OneByteString(env->isolate(), current->txt, current->length);

    // New record found - write out the current chunk
    if (current->record_start) {
      if (!txt_chunk.IsEmpty()) {
        if (need_type) {
          Local<Object> elem = Object::New(env->isolate());
          elem->Set(env->context(), env->entries_string(), txt_chunk).Check();
          elem->Set(env->context(),
                    env->type_string(),
                    env->dns_txt_string()).Check();
          ret->Set(env->context(), offset + i++, elem).Check();
        } else {
          ret->Set(env->context...",29,,360,6,,void
10841,BLOCK,-1,,<empty>,5,,367,2,,void
10866,BLOCK,-1,,<empty>,3,,374,1,,void
10878,BLOCK,4,,"{
    Local<String> txt =
        OneByteString(env->isolate(), current->txt, current->length);

    // New record found - write out the current chunk
    if (current->record_start) {
      if (!txt_chunk.IsEmpty()) {
        if (need_type) {
          Local<Object> elem = Object::New(env->isolate());
          elem->Set(env->context(), env->entries_string(), txt_chunk).Check();
          elem->Set(env->context(),
                    env->type_string(),
                    env->dns_txt_string()).Check();
          ret->Set(env->context(), offset + i++, elem).Check();
        } else {
          ret->Set(env->context(), offset + i++, txt_chunk).Check();
        }
      }

      txt_chunk = Array::New(env->isolate());
      j = 0;
    }

    txt_chunk->Set(env->context(), j++, txt).Check();
  }",60,,374,4,,void
10900,BLOCK,-1,,"{
      if (!txt_chunk.IsEmpty()) {
        if (need_type) {
          Local<Object> elem = Object::New(env->isolate());
          elem->Set(env->context(), env->entries_string(), txt_chunk).Check();
          elem->Set(env->context(),
                    env->type_string(),
                    env->dns_txt_string()).Check();
          ret->Set(env->context(), offset + i++, elem).Check();
        } else {
          ret->Set(env->context(), offset + i++, txt_chunk).Check();
        }
      }

      txt_chunk = Array::New(env->isolate());
      j = 0;
    }",32,,379,2,,void
10907,BLOCK,-1,,"{
        if (need_type) {
          Local<Object> elem = Object::New(env->isolate());
          elem->Set(env->context(), env->entries_string(), txt_chunk).Check();
          elem->Set(env->context(),
                    env->type_string(),
                    env->dns_txt_string()).Check();
          ret->Set(env->context(), offset + i++, elem).Check();
        } else {
          ret->Set(env->context(), offset + i++, txt_chunk).Check();
        }
      }",33,,380,2,,void
10910,BLOCK,-1,,"{
          Local<Object> elem = Object::New(env->isolate());
          elem->Set(env->context(), env->entries_string(), txt_chunk).Check();
          elem->Set(env->context(),
                    env->type_string(),
                    env->dns_txt_string()).Check();
          ret->Set(env->context(), offset + i++, elem).Check();
        }",24,,381,2,,void
10977,BLOCK,-1,,"{
          ret->Set(env->context(), offset + i++, txt_chunk).Check();
        }",16,,388,1,,void
11027,BLOCK,-1,,"{
    if (need_type) {
      Local<Object> elem = Object::New(env->isolate());
      elem->Set(env->context(), env->entries_string(), txt_chunk).Check();
      elem->Set(env->context(),
                env->type_string(),
                env->dns_txt_string()).Check();
      ret->Set(env->context(), offset + i, elem).Check();
    } else {
      ret->Set(env->context(), offset + i, txt_chunk).Check();
    }
  }",29,,401,2,,void
11030,BLOCK,-1,,"{
      Local<Object> elem = Object::New(env->isolate());
      elem->Set(env->context(), env->entries_string(), txt_chunk).Check();
      elem->Set(env->context(),
                env->type_string(),
                env->dns_txt_string()).Check();
      ret->Set(env->context(), offset + i, elem).Check();
    }",20,,402,2,,void
11096,BLOCK,-1,,"{
      ret->Set(env->context(), offset + i, txt_chunk).Check();
    }",12,,409,1,,void
11124,BLOCK,-1,,"{
  HandleScope handle_scope(env->isolate());

  struct ares_srv_reply* srv_start;
  int status = ares_parse_srv_reply(buf, len, &srv_start);
  if (status != ARES_SUCCESS)
    return status;

  ares_srv_reply* current = srv_start;
  int offset = ret->Length();
  for (uint32_t i = 0; current != nullptr; ++i, current = current->next) {
    Local<Object> srv_record = Object::New(env->isolate());
    srv_record->Set(env->context(),
                    env->name_string(),
                    OneByteString(env->isolate(), current->host)).Check();
    srv_record->Set(env->context(),
                    env->port_string(),
                    Integer::New(env->isolate(), current->port)).Check();
    srv_record->Set(env->context(),
                    env->priority_string(),
                    Integer::New(env->isolate(), current->priority)).Check();
    srv_record->Set(env->context(),
                    env->weight_string(),
                    Integer::New(env->isolate(), current->weight...",29,,424,6,,void
11144,BLOCK,-1,,<empty>,5,,430,2,,void
11159,BLOCK,-1,,<empty>,3,,434,1,,void
11175,BLOCK,4,,"{
    Local<Object> srv_record = Object::New(env->isolate());
    srv_record->Set(env->context(),
                    env->name_string(),
                    OneByteString(env->isolate(), current->host)).Check();
    srv_record->Set(env->context(),
                    env->port_string(),
                    Integer::New(env->isolate(), current->port)).Check();
    srv_record->Set(env->context(),
                    env->priority_string(),
                    Integer::New(env->isolate(), current->priority)).Check();
    srv_record->Set(env->context(),
                    env->weight_string(),
                    Integer::New(env->isolate(), current->weight)).Check();
    if (need_type)
      srv_record->Set(env->context(),
                      env->type_string(),
                      env->dns_srv_string()).Check();

    ret->Set(env->context(), i + offset, srv_record).Check();
  }",74,,434,4,,void
11293,BLOCK,-1,,<empty>,7,,449,2,,void
11340,BLOCK,-1,,"{
  HandleScope handle_scope(env->isolate());

  ares_naptr_reply* naptr_start;
  int status = ares_parse_naptr_reply(buf, len, &naptr_start);

  if (status != ARES_SUCCESS)
    return status;

  ares_naptr_reply* current = naptr_start;
  int offset = ret->Length();
  for (uint32_t i = 0; current != nullptr; ++i, current = current->next) {
    Local<Object> naptr_record = Object::New(env->isolate());
    naptr_record->Set(env->context(),
                      env->flags_string(),
                      OneByteString(env->isolate(), current->flags)).Check();
    naptr_record->Set(env->context(),
                      env->service_string(),
                      OneByteString(env->isolate(),
                                    current->service)).Check();
    naptr_record->Set(env->context(),
                      env->regexp_string(),
                      OneByteString(env->isolate(),
                                    current->regexp)).Check();
    naptr_record->Set(env->context(),
...",29,,466,6,,void
11360,BLOCK,-1,,<empty>,5,,473,2,,void
11375,BLOCK,-1,,<empty>,3,,477,1,,void
11391,BLOCK,4,,"{
    Local<Object> naptr_record = Object::New(env->isolate());
    naptr_record->Set(env->context(),
                      env->flags_string(),
                      OneByteString(env->isolate(), current->flags)).Check();
    naptr_record->Set(env->context(),
                      env->service_string(),
                      OneByteString(env->isolate(),
                                    current->service)).Check();
    naptr_record->Set(env->context(),
                      env->regexp_string(),
                      OneByteString(env->isolate(),
                                    current->regexp)).Check();
    naptr_record->Set(env->context(),
                      env->replacement_string(),
                      OneByteString(env->isolate(),
                                    current->replacement)).Check();
    naptr_record->Set(env->context(),
                      env->order_string(),
                      Integer::New(env->isolate(), current->order)).Check();
    naptr_rec...",74,,477,4,,void
11552,BLOCK,-1,,<empty>,7,,502,2,,void
11598,BLOCK,-1,,"{
  EscapableHandleScope handle_scope(env->isolate());

  // Manage memory using standardard smart pointer std::unique_tr
  struct AresDeleter {
    void operator()(char* ptr) const noexcept { ares_free_string(ptr); }
  };
  using ares_unique_ptr = std::unique_ptr<char[], AresDeleter>;

  // Can't use ares_parse_soa_reply() here which can only parse single record
  const unsigned int ancount = cares_get_16bit(buf + 6);
  unsigned char* ptr = buf + NS_HFIXEDSZ;
  char* name_temp = nullptr;
  long temp_len;  // NOLINT(runtime/int)
  int status = ares_expand_name(ptr, buf, len, &name_temp, &temp_len);
  if (status != ARES_SUCCESS) {
    // returns EBADRESP in case of invalid input
    return status == ARES_EBADNAME ? ARES_EBADRESP : status;
  }

  const ares_unique_ptr name(name_temp);

  if (ptr + temp_len + NS_QFIXEDSZ > buf + len) {
    return ARES_EBADRESP;
  }
  ptr += temp_len + NS_QFIXEDSZ;

  for (unsigned int i = 0; i < ancount; i++) {
    char* rr_name_temp = nullptr;
    lon...",25,,518,5,,void
11639,BLOCK,-1,,"{
    // returns EBADRESP in case of invalid input
    return status == ARES_EBADNAME ? ARES_EBADRESP : status;
  }",31,,533,2,,void
11660,BLOCK,-1,,"{
    return ARES_EBADRESP;
  }",49,,540,2,,void
11669,BLOCK,-1,,<empty>,3,,545,1,,void
11679,BLOCK,4,,"{
    char* rr_name_temp = nullptr;
    long rr_temp_len;  // NOLINT(runtime/int)
    int status2 = ares_expand_name(ptr, buf, len, &rr_name_temp, &rr_temp_len);

    if (status2 != ARES_SUCCESS)
      return status2 == ARES_EBADNAME ? ARES_EBADRESP : status2;

    const ares_unique_ptr rr_name(rr_name_temp);

    ptr += rr_temp_len;
    if (ptr + NS_RRFIXEDSZ > buf + len) {
      return ARES_EBADRESP;
    }

    const int rr_type = cares_get_16bit(ptr);
    const int rr_len = cares_get_16bit(ptr + 8);
    ptr += NS_RRFIXEDSZ;

    // only need SOA
    if (rr_type == ns_t_soa) {
      char* nsname_temp = nullptr;
      long nsname_temp_len;  // NOLINT(runtime/int)

      int status3 = ares_expand_name(ptr, buf, len,
                                     &nsname_temp,
                                     &nsname_temp_len);
      if (status3 != ARES_SUCCESS) {
        return status3 == ARES_EBADNAME ? ARES_EBADRESP : status3;
      }
      const ares_unique_ptr nsname(nsname_temp);
   ...",46,,545,4,,void
11700,BLOCK,-1,,<empty>,7,,551,2,,void
11722,BLOCK,-1,,"{
      return ARES_EBADRESP;
    }",41,,556,2,,void
11744,BLOCK,-1,,"{
      char* nsname_temp = nullptr;
      long nsname_temp_len;  // NOLINT(runtime/int)

      int status3 = ares_expand_name(ptr, buf, len,
                                     &nsname_temp,
                                     &nsname_temp_len);
      if (status3 != ARES_SUCCESS) {
        return status3 == ARES_EBADNAME ? ARES_EBADRESP : status3;
      }
      const ares_unique_ptr nsname(nsname_temp);
      ptr += nsname_temp_len;

      char* hostmaster_temp = nullptr;
      long hostmaster_temp_len;  // NOLINT(runtime/int)
      int status4 = ares_expand_name(ptr, buf, len,
                                     &hostmaster_temp,
                                     &hostmaster_temp_len);
      if (status4 != ARES_SUCCESS) {
        return status4 == ARES_EBADNAME ? ARES_EBADRESP : status4;
      }
      const ares_unique_ptr hostmaster(hostmaster_temp);
      ptr += hostmaster_temp_len;

      if (ptr + 5 * 4 > buf + len) {
        return ARES_EBADRESP;
      }

      const un...",30,,565,2,,void
11765,BLOCK,-1,,"{
        return status3 == ARES_EBADNAME ? ARES_EBADRESP : status3;
      }",36,,572,2,,void
11799,BLOCK,-1,,"{
        return status4 == ARES_EBADNAME ? ARES_EBADRESP : status4;
      }",36,,583,2,,void
11823,BLOCK,-1,,"{
        return ARES_EBADRESP;
      }",36,,589,2,,void
12093,BLOCK,-1,,"{
  MakeWeak();

  Setup();
}",21,,645,5,,void
12100,BLOCK,-1,,"{
  if (timer_handle_ != nullptr)
    tracker->TrackField(""timer_handle"", *timer_handle_);
  tracker->TrackField(""task_list"", task_list_, ""NodeAresTask::List"");
}",60,,651,2,,void
12105,BLOCK,-1,,<empty>,5,,653,2,,void
12124,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  CHECK_EQ(args.Length(), 2);
  CHECK(args[0]->IsInt32());
  CHECK(args[1]->IsInt32());
  const int timeout = args[0].As<Int32>()->Value();
  const int tries = args[1].As<Int32>()->Value();
  Environment* env = Environment::GetCurrent(args);
  new ChannelWrap(env, args.This(), timeout, tries);
}",64,,657,2,,void
12197,BLOCK,-1,,<empty>,27,,673,4,,void
12203,BLOCK,-1,,<empty>,74,,678,3,,void
12208,BLOCK,-1,,"{
  ChannelWrap* channel = static_cast<ChannelWrap*>(handle->data);
  CHECK_EQ(channel->timer_handle(), handle);
  CHECK_EQ(false, channel->task_list()->empty());
  ares_process_fd(channel->cares_channel(), ARES_SOCKET_BAD, ARES_SOCKET_BAD);
}",51,,682,2,,void
12243,BLOCK,-1,,"{
  tracker->TrackField(""channel"", channel);
}",61,,690,2,,void
12255,BLOCK,-1,,"{
  auto task = new NodeAresTask();

  task->channel = channel;
  task->sock = sock;

  if (uv_poll_init_socket(channel->env()->event_loop(),
                          &task->poll_watcher, sock) < 0) {
    /* This should never happen. */
    delete task;
    return nullptr;
  }

  return task;
}",78,,695,3,,void
12287,BLOCK,-1,,"{
    /* This should never happen. */
    delete task;
    return nullptr;
  }",59,,702,2,,void
12297,BLOCK,-1,,"{
  struct ares_options options;
  memset(&options, 0, sizeof(options));
  options.flags = ARES_FLAG_NOCHECKRESP;
  options.sock_state_cb = ares_sockstate_cb;
  options.sock_state_cb_data = this;
  options.timeout = timeout_;
  options.tries = tries_;

  int r;
  if (!library_inited_) {
    Mutex::ScopedLock lock(ares_library_mutex);
    // Multiple calls to ares_library_init() increase a reference counter,
    // so this is a no-op except for the first call to it.
    r = ares_library_init(ARES_LIB_INIT_ALL);
    if (r != ARES_SUCCESS)
      return env()->ThrowError(ToErrorCodeString(r));
  }

  /* We do the call to ares_init_option for caller. */
  const int optmask =
      ARES_OPT_FLAGS | ARES_OPT_TIMEOUTMS |
      ARES_OPT_SOCK_STATE_CB | ARES_OPT_TRIES;
  r = ares_init_options(&channel_, &options, optmask);

  if (r != ARES_SUCCESS) {
    Mutex::ScopedLock lock(ares_library_mutex);
    ares_library_cleanup();
    return env()->ThrowError(ToErrorCodeString(r));
  }

  library_i...",27,,711,1,,void
12334,BLOCK,-1,,"{
    Mutex::ScopedLock lock(ares_library_mutex);
    // Multiple calls to ares_library_init() increase a reference counter,
    // so this is a no-op except for the first call to it.
    r = ares_library_init(ARES_LIB_INIT_ALL);
    if (r != ARES_SUCCESS)
      return env()->ThrowError(ToErrorCodeString(r));
  }",25,,721,2,,void
12346,BLOCK,-1,,<empty>,7,,727,2,,void
12376,BLOCK,-1,,"{
    Mutex::ScopedLock lock(ares_library_mutex);
    ares_library_cleanup();
    return env()->ThrowError(ToErrorCodeString(r));
  }",26,,736,2,,void
12394,BLOCK,-1,,"{
  if (timer_handle_ == nullptr) {
    timer_handle_ = new uv_timer_t();
    timer_handle_->data = static_cast<void*>(this);
    uv_timer_init(env()->event_loop(), timer_handle_);
  } else if (uv_is_active(reinterpret_cast<uv_handle_t*>(timer_handle_))) {
    return;
  }
  int timeout = timeout_;
  if (timeout == 0) timeout = 1;
  if (timeout < 0 || timeout > 1000) timeout = 1000;
  uv_timer_start(timer_handle_, AresTimeout, timeout, timeout);
}",32,,745,1,,void
12399,BLOCK,-1,,"{
    timer_handle_ = new uv_timer_t();
    timer_handle_->data = static_cast<void*>(this);
    uv_timer_init(env()->event_loop(), timer_handle_);
  }",33,,746,2,,void
12418,BLOCK,-1,,<empty>,10,,750,1,,void
12424,BLOCK,-1,,"{
    return;
  }",75,,750,2,,void
12434,BLOCK,-1,,<empty>,21,,754,2,,void
12446,BLOCK,-1,,<empty>,38,,755,2,,void
12458,BLOCK,-1,,"{
  if (timer_handle_ == nullptr)
    return;

  env()->CloseHandle(timer_handle_, [](uv_timer_t* handle) { delete handle; });
  timer_handle_ = nullptr;
}",32,,759,1,,void
12463,BLOCK,-1,,<empty>,5,,761,2,,void
12477,BLOCK,-1,,"{
  ares_destroy(channel_);

  if (library_inited_) {
    Mutex::ScopedLock lock(ares_library_mutex);
    // This decreases the reference counter increased by ares_library_init().
    ares_library_cleanup();
  }

  CloseTimer();
}",29,,767,1,,void
12481,BLOCK,-1,,"{
    Mutex::ScopedLock lock(ares_library_mutex);
    // This decreases the reference counter increased by ares_library_init().
    ares_library_cleanup();
  }",24,,770,2,,void
12491,BLOCK,-1,,"{
  active_query_count_ += count;
  CHECK_GE(active_query_count_, 0);
}",55,,780,2,,void
12501,BLOCK,-1,,"{
  /* if last query is OK or servers are set by user self, do not check */
  if (query_last_ok_ || !is_servers_default_) {
    return;
  }

  ares_addr_port_node* servers = nullptr;

  ares_get_servers_ports(channel_, &servers);

  /* if no server or multi-servers, ignore */
  if (servers == nullptr) return;
  if (servers->next != nullptr) {
    ares_free_data(servers);
    is_servers_default_ = false;
    return;
  }

  /* if the only server is not 127.0.0.1, ignore */
  if (servers[0].family != AF_INET ||
      servers[0].addr.addr4.s_addr != htonl(INADDR_LOOPBACK) ||
      servers[0].tcp_port != 0 ||
      servers[0].udp_port != 0) {
    ares_free_data(servers);
    is_servers_default_ = false;
    return;
  }

  ares_free_data(servers);
  servers = nullptr;

  /* destroy channel and reset channel */
  ares_destroy(channel_);

  CloseTimer();
  Setup();
}",35,,793,1,,void
12507,BLOCK,-1,,"{
    return;
  }",47,,795,2,,void
12521,BLOCK,-1,,<empty>,27,,804,2,,void
12529,BLOCK,-1,,"{
    ares_free_data(servers);
    is_servers_default_ = false;
    return;
  }",33,,805,2,,void
12573,BLOCK,-1,,"{
    ares_free_data(servers);
    is_servers_default_ = false;
    return;
  }",33,,815,2,,void
12593,BLOCK,-1,,"{
  wrap->AresQuery(name, ns_c_in, ns_t_any);
  return 0;
}",67,,831,3,,void
12608,BLOCK,-1,,"{
  wrap->AresQuery(name, ns_c_in, ns_t_a);
  return 0;
}",63,,836,3,,void
12623,BLOCK,-1,,"{
  wrap->AresQuery(name, ns_c_in, ns_t_aaaa);
  return 0;
}",69,,841,3,,void
12638,BLOCK,-1,,"{
  wrap->AresQuery(name, ns_c_in, T_CAA);
  return 0;
}",67,,846,3,,void
12646,BLOCK,1,,<empty>,,,,1,,void
12655,BLOCK,-1,,"{
  wrap->AresQuery(name, ns_c_in, ns_t_cname);
  return 0;
}",71,,851,3,,void
12670,BLOCK,-1,,"{
  wrap->AresQuery(name, ns_c_in, ns_t_mx);
  return 0;
}",65,,856,3,,void
12685,BLOCK,-1,,"{
  wrap->AresQuery(name, ns_c_in, ns_t_ns);
  return 0;
}",65,,861,3,,void
12700,BLOCK,-1,,"{
  wrap->AresQuery(name, ns_c_in, ns_t_txt);
  return 0;
}",67,,866,3,,void
12715,BLOCK,-1,,"{
  wrap->AresQuery(name, ns_c_in, ns_t_srv);
  return 0;
}",67,,871,3,,void
12730,BLOCK,-1,,"{
  wrap->AresQuery(name, ns_c_in, ns_t_ptr);
  return 0;
}",67,,876,3,,void
12745,BLOCK,-1,,"{
  wrap->AresQuery(name, ns_c_in, ns_t_naptr);
  return 0;
}",71,,881,3,,void
12760,BLOCK,-1,,"{
  wrap->AresQuery(name, ns_c_in, ns_t_soa);
  return 0;
}",67,,886,3,,void
12775,BLOCK,-1,,"{
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Array> ret = Array::New(env->isolate());
  int type, status, old_count;

  /* Parse A records or CNAME records */
  ares_addrttl addrttls[256];
  int naddrttls = arraysize(addrttls);

  type = ns_t_cname_or_a;
  status = ParseGeneralReply(env,
                             buf,
                             len,
                             &type,
                             ret,
                             addrttls,
                             &naddrttls);
  uint32_t a_count = ret->Length();
  if (status != ARES_SUCCESS && status != ARES_ENODATA)
    return status;

  if (type == ns_t_a) {
    CHECK_EQ(static_cast<uint32_t>(naddrttls), a_count);
    for (uint32_t i = 0; i < a_count; i++) {
      Local<Object> o...",52,,893,3,,void
12781,BLOCK,-1,,<empty>,5,,895,2,,void
12872,BLOCK,-1,,<empty>,5,,921,2,,void
12879,BLOCK,-1,,"{
    CHECK_EQ(static_cast<uint32_t>(naddrttls), a_count);
    for (uint32_t i = 0; i < a_count; i++) {
      Local<Object> obj = Object::New(env->isolate());
      obj->Set(env->context(),
                env->address_string(),
                ret->Get(env->context(), i).ToLocalChecked()).Check();
      obj->Set(env->context(),
                env->ttl_string(),
                Integer::NewFromUnsigned(
                  env->isolate(), addrttls[i].ttl)).Check();
      obj->Set(env->context(),
                env->type_string(),
                env->dns_a_string()).Check();
      ret->Set(env->context(), i, obj).Check();
    }
  }",23,,923,2,,void
12886,BLOCK,-1,,<empty>,5,,925,1,,void
12896,BLOCK,4,,"{
      Local<Object> obj = Object::New(env->isolate());
      obj->Set(env->context(),
                env->address_string(),
                ret->Get(env->context(), i).ToLocalChecked()).Check();
      obj->Set(env->context(),
                env->ttl_string(),
                Integer::NewFromUnsigned(
                  env->isolate(), addrttls[i].ttl)).Check();
      obj->Set(env->context(),
                env->type_string(),
                env->dns_a_string()).Check();
      ret->Set(env->context(), i, obj).Check();
    }",44,,925,4,,void
12999,BLOCK,-1,,"{
    for (uint32_t i = 0; i < a_count; i++) {
      Local<Object> obj = Object::New(env->isolate());
      obj->Set(env->context(),
                env->value_string(),
                ret->Get(env->context(), i).ToLocalChecked()).Check();
      obj->Set(env->context(),
                env->type_string(),
                env->dns_cname_string()).Check();
      ret->Set(env->context(), i, obj).Check();
    }
  }",10,,939,1,,void
13001,BLOCK,-1,,<empty>,5,,940,1,,void
13011,BLOCK,4,,"{
      Local<Object> obj = Object::New(env->isolate());
      obj->Set(env->context(),
                env->value_string(),
                ret->Get(env->context(), i).ToLocalChecked()).Check();
      obj->Set(env->context(),
                env->type_string(),
                env->dns_cname_string()).Check();
      ret->Set(env->context(), i, obj).Check();
    }",44,,940,4,,void
13123,BLOCK,-1,,<empty>,5,,966,2,,void
13140,BLOCK,-1,,<empty>,3,,970,1,,void
13153,BLOCK,4,,"{
    Local<Object> obj = Object::New(env->isolate());
    obj->Set(env->context(),
              env->address_string(),
              ret->Get(env->context(), i).ToLocalChecked()).Check();
    obj->Set(env->context(),
              env->ttl_string(),
              Integer::NewFromUnsigned(
                env->isolate(), addr6ttls[i - a_count].ttl)).Check();
    obj->Set(env->context(),
              env->type_string(),
              env->dns_aaaa_string()).Check();
    ret->Set(env->context(), i, obj).Check();
  }",54,,970,4,,void
13273,BLOCK,-1,,<empty>,5,,988,2,,void
13302,BLOCK,-1,,<empty>,5,,995,2,,void
13306,BLOCK,-1,,<empty>,3,,997,1,,void
13319,BLOCK,4,,"{
    Local<Object> obj = Object::New(env->isolate());
    obj->Set(env->context(),
             env->value_string(),
             ret->Get(env->context(), i).ToLocalChecked()).Check();
    obj->Set(env->context(),
              env->type_string(),
              env->dns_ns_string()).Check();
    ret->Set(env->context(), i, obj).Check();
  }",56,,997,4,,void
13409,BLOCK,-1,,<empty>,5,,1011,2,,void
13428,BLOCK,-1,,<empty>,5,,1016,2,,void
13457,BLOCK,-1,,<empty>,5,,1023,2,,void
13461,BLOCK,-1,,<empty>,3,,1024,1,,void
13474,BLOCK,4,,"{
    Local<Object> obj = Object::New(env->isolate());
    obj->Set(env->context(),
              env->value_string(),
              ret->Get(env->context(), i).ToLocalChecked()).Check();
    obj->Set(env->context(),
              env->type_string(),
              env->dns_ptr_string()).Check();
    ret->Set(env->context(), i, obj).Check();
  }",56,,1024,4,,void
13564,BLOCK,-1,,<empty>,5,,1038,2,,void
13590,BLOCK,-1,,<empty>,5,,1044,2,,void
13599,BLOCK,-1,,<empty>,5,,1047,2,,void
13632,BLOCK,-1,,<empty>,5,,1052,2,,void
13647,BLOCK,-1,,"{
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  ares_addrttl addrttls[256];
  int naddrttls = arraysize(addrttls), status;
  Local<Array> ret = Array::New(env->isolate());

  int type = ns_t_a;
  status = ParseGeneralReply(env,
                             buf,
                             len,
                             &type,
                             ret,
                             addrttls,
                             &naddrttls);
  if (status != ARES_SUCCESS)
    return status;

  Local<Array> ttls = AddrTTLToArray<ares_addrttl>(env, addrttls, naddrttls);

  wrap->CallOnComplete(ret, ttls);
  return 0;
}",52,,1060,3,,void
13653,BLOCK,-1,,<empty>,5,,1062,2,,void
13732,BLOCK,-1,,<empty>,5,,1084,2,,void
13763,BLOCK,-1,,"{
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  ares_addr6ttl addrttls[256];
  int naddrttls = arraysize(addrttls), status;
  Local<Array> ret = Array::New(env->isolate());

  int type = ns_t_aaaa;
  status = ParseGeneralReply(env,
                             buf,
                             len,
                             &type,
                             ret,
                             addrttls,
                             &naddrttls);
  if (status != ARES_SUCCESS)
    return status;

  Local<Array> ttls = AddrTTLToArray<ares_addr6ttl>(env, addrttls, naddrttls);

  wrap->CallOnComplete(ret, ttls);
  return 0;
}",52,,1094,3,,void
13769,BLOCK,-1,,<empty>,5,,1096,2,,void
13848,BLOCK,-1,,<empty>,5,,1118,2,,void
13879,BLOCK,-1,,"{
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Array> ret = Array::New(env->isolate());
  int status = ParseCaaReply(env, buf, len, ret);
  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(ret);
  return 0;
}",52,,1128,3,,void
13885,BLOCK,-1,,<empty>,5,,1130,2,,void
13949,BLOCK,-1,,<empty>,5,,1142,2,,void
13964,BLOCK,-1,,"{
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Array> ret = Array::New(env->isolate());
  int type = ns_t_cname;
  int status = ParseGeneralReply(env, buf, len, &type, ret);
  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(ret);
  return 0;
}",52,,1150,3,,void
13970,BLOCK,-1,,<empty>,5,,1152,2,,void
14040,BLOCK,-1,,<empty>,5,,1165,2,,void
14055,BLOCK,-1,,"{
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Array> mx_records = Array::New(env->isolate());
  int status = ParseMxReply(env, buf, len, mx_records);

  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(mx_records);
  return 0;
}",52,,1173,3,,void
14061,BLOCK,-1,,<empty>,5,,1175,2,,void
14125,BLOCK,-1,,<empty>,5,,1188,2,,void
14140,BLOCK,-1,,"{
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  int type = ns_t_ns;
  Local<Array> names = Array::New(env->isolate());
  int status = ParseGeneralReply(env, buf, len, &type, names);
  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(names);
  return 0;
}",52,,1196,3,,void
14146,BLOCK,-1,,<empty>,5,,1198,2,,void
14216,BLOCK,-1,,<empty>,5,,1211,2,,void
14231,BLOCK,-1,,"{
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Array> txt_records = Array::New(env->isolate());
  int status = ParseTxtReply(env, buf, len, txt_records);
  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(txt_records);
  return 0;
}",52,,1219,3,,void
14237,BLOCK,-1,,<empty>,5,,1221,2,,void
14301,BLOCK,-1,,<empty>,5,,1233,2,,void
14316,BLOCK,-1,,"{
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Array> srv_records = Array::New(env->isolate());
  int status = ParseSrvReply(env, buf, len, srv_records);
  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(srv_records);
  return 0;
}",52,,1241,3,,void
14322,BLOCK,-1,,<empty>,5,,1243,2,,void
14386,BLOCK,-1,,<empty>,5,,1255,2,,void
14401,BLOCK,-1,,"{
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  int type = ns_t_ptr;
  Local<Array> aliases = Array::New(env->isolate());

  int status = ParseGeneralReply(env, buf, len, &type, aliases);
  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(aliases);
  return 0;
}",52,,1263,3,,void
14407,BLOCK,-1,,<empty>,5,,1265,2,,void
14477,BLOCK,-1,,<empty>,5,,1279,2,,void
14492,BLOCK,-1,,"{
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Array> naptr_records = Array::New(env->isolate());
  int status = ParseNaptrReply(env, buf, len, naptr_records);
  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(naptr_records);
  return 0;
}",52,,1287,3,,void
14498,BLOCK,-1,,<empty>,5,,1289,2,,void
14562,BLOCK,-1,,<empty>,5,,1301,2,,void
14577,BLOCK,-1,,"{
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  ares_soa_reply* soa_out;
  int status = ares_parse_soa_reply(buf, len, &soa_out);

  if (status != ARES_SUCCESS)
    return status;

  Local<Object> soa_record = Object::New(env->isolate());

  soa_record->Set(env->context(),
                  env->nsname_string(),
                  OneByteString(env->isolate(), soa_out->nsname)).Check();
  soa_record->Set(env->context(),
                  env->hostmaster_string(),
                  OneByteString(env->isolate(), soa_out->hostmaster)).Check();
  soa_record->Set(env->context(),
                  env->serial_string(),
                  Integer::NewFromUnsigned(
                      env->isolate(), soa_out->serial)).Check();
  soa_record->Set(env->context(),
             ...",52,,1309,3,,void
14583,BLOCK,-1,,<empty>,5,,1311,2,,void
14634,BLOCK,-1,,<empty>,5,,1324,2,,void
14841,BLOCK,-1,,"{
  int length, family;
  char address_buffer[sizeof(struct in6_addr)];

  if (uv_inet_pton(AF_INET, name, &address_buffer) == 0) {
    length = sizeof(struct in_addr);
    family = AF_INET;
  } else if (uv_inet_pton(AF_INET6, name, &address_buffer) == 0) {
    length = sizeof(struct in6_addr);
    family = AF_INET6;
  } else {
    return UV_EINVAL;  // So errnoException() reports a proper error.
  }

  TRACE_EVENT_NESTABLE_ASYNC_BEGIN2(
      TRACING_CATEGORY_NODE2(dns, native), ""reverse"", wrap,
      ""name"", TRACE_STR_COPY(name),
      ""family"", family == AF_INET ? ""ipv4"" : ""ipv6"");

  ares_gethostbyaddr(
      wrap->channel()->cares_channel(),
      address_buffer,
      length,
      family,
      GetHostByAddrWrap::Callback,
      wrap->MakeCallbackPointer());
  return 0;
}",68,,1358,3,,void
14853,BLOCK,-1,,"{
    length = sizeof(struct in_addr);
    family = AF_INET;
  }",58,,1362,2,,void
14862,BLOCK,-1,,<empty>,10,,1365,1,,void
14871,BLOCK,-1,,"{
    length = sizeof(struct in6_addr);
    family = AF_INET6;
  }",66,,1365,2,,void
14880,BLOCK,-1,,"{
    return UV_EINVAL;  // So errnoException() reports a proper error.
  }",10,,1368,1,,void
14924,BLOCK,-1,,"{
  if (UNLIKELY(!response->is_host))
    return ARES_EBADRESP;

  struct hostent* host = response->host.get();

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());
  wrap->CallOnComplete(HostentToNames(env, host));
  return 0;
}",52,,1389,3,,void
14931,BLOCK,-1,,<empty>,5,,1391,2,,void
14976,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  ChannelWrap* channel;
  ASSIGN_OR_RETURN_UNWRAP(&channel, args.Holder());

  CHECK_EQ(false, args.IsConstructCall());
  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsString());

  Local<Object> req_wrap_obj = args[0].As<Object>();
  Local<String> string = args[1].As<String>();
  auto wrap = std::make_unique<Wrap>(channel, req_wrap_obj);

  node::Utf8Value name(env->isolate(), string);
  channel->ModifyActivityQueryCount(1);
  int err = wrap->Send(*name);
  if (err) {
    channel->ModifyActivityQueryCount(-1);
  } else {
    // Release ownership of the pointer allowing the ownership to be transferred
    USE(wrap.release());
  }

  args.GetReturnValue().Set(err);
}",60,,1404,2,,void
15073,BLOCK,-1,,"{
    channel->ModifyActivityQueryCount(-1);
  }",12,,1420,2,,void
15081,BLOCK,-1,,"{
    // Release ownership of the pointer allowing the ownership to be transferred
    USE(wrap.release());
  }",10,,1422,1,,void
15100,BLOCK,-1,,"{
  auto cleanup = OnScopeLeave([&]() { uv_freeaddrinfo(res); });
  BaseObjectPtr<GetAddrInfoReqWrap> req_wrap{
      static_cast<GetAddrInfoReqWrap*>(req->data)};
  Environment* env = req_wrap->env();

  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Value> argv[] = {
    Integer::New(env->isolate(), status),
    Null(env->isolate())
  };

  uint32_t n = 0;
  const bool verbatim = req_wrap->verbatim();

  if (status == 0) {
    Local<Array> results = Array::New(env->isolate());

    auto add = [&] (bool want_ipv4, bool want_ipv6) -> Maybe<bool> {
      for (auto p = res; p != nullptr; p = p->ai_next) {
        CHECK_EQ(p->ai_socktype, SOCK_STREAM);

        const char* addr;
        if (want_ipv4 && p->ai_family == AF_INET) {
          addr = reinterpret_cast<char*>(
              &(reinterpret_cast<struct sockaddr_in*>(p->ai_addr)->sin_addr));
        } else if (want_ipv6 && p->ai_family == AF_INET6) {
          addr = reinterpre...",80,,1431,4,,void
15167,BLOCK,-1,,"{
    Local<Array> results = Array::New(env->isolate());

    auto add = [&] (bool want_ipv4, bool want_ipv6) -> Maybe<bool> {
      for (auto p = res; p != nullptr; p = p->ai_next) {
        CHECK_EQ(p->ai_socktype, SOCK_STREAM);

        const char* addr;
        if (want_ipv4 && p->ai_family == AF_INET) {
          addr = reinterpret_cast<char*>(
              &(reinterpret_cast<struct sockaddr_in*>(p->ai_addr)->sin_addr));
        } else if (want_ipv6 && p->ai_family == AF_INET6) {
          addr = reinterpret_cast<char*>(
              &(reinterpret_cast<struct sockaddr_in6*>(p->ai_addr)->sin6_addr));
        } else {
          continue;
        }

        char ip[INET6_ADDRSTRLEN];
        if (uv_inet_ntop(p->ai_family, addr, ip, sizeof(ip)))
          continue;

        Local<String> s = OneByteString(env->isolate(), ip);
        if (results->Set(env->context(), n, s).IsNothing())
          return Nothing<bool>();
        n++;
      }
      return Just(true);
    };

    if (...",20,,1448,2,,void
15193,BLOCK,-1,,<empty>,7,,1479,2,,void
15199,BLOCK,-1,,"{
      if (add(false, true).IsNothing())
        return;
    }",28,,1480,2,,void
15207,BLOCK,-1,,<empty>,9,,1482,2,,void
15213,BLOCK,-1,,"{
      argv[0] = Integer::New(env->isolate(), UV_EAI_NODATA);
    }",17,,1486,2,,void
15263,BLOCK,-1,,"{
  BaseObjectPtr<GetNameInfoReqWrap> req_wrap{
      static_cast<GetNameInfoReqWrap*>(req->data)};
  Environment* env = req_wrap->env();

  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Value> argv[] = {
    Integer::New(env->isolate(), status),
    Null(env->isolate()),
    Null(env->isolate())
  };

  if (status == 0) {
    // Success
    Local<String> js_hostname = OneByteString(env->isolate(), hostname);
    Local<String> js_service = OneByteString(env->isolate(), service);
    argv[1] = js_hostname;
    argv[2] = js_service;
  }

  TRACE_EVENT_NESTABLE_ASYNC_END2(
      TRACING_CATEGORY_NODE2(dns, native), ""lookupService"", req_wrap.get(),
      ""hostname"", TRACE_STR_COPY(hostname),
      ""service"", TRACE_STR_COPY(service));

  // Make the callback into JavaScript
  req_wrap->MakeCallback(env->oncomplete_string(), arraysize(argv), argv);
}",44,,1505,5,,void
15321,BLOCK,-1,,"{
    // Success
    Local<String> js_hostname = OneByteString(env->isolate(), hostname);
    Local<String> js_service = OneByteString(env->isolate(), service);
    argv[1] = js_hostname;
    argv[2] = js_service;
  }",20,,1519,2,,void
15386,BLOCK,-1,,"{
  Isolate* isolate = args.GetIsolate();
  node::Utf8Value ip(isolate, args[0]);

  int af;
  unsigned char result[sizeof(ares_addr_port_node::addr)];
  if (uv_inet_pton(af = AF_INET, *ip, result) != 0 &&
      uv_inet_pton(af = AF_INET6, *ip, result) != 0)
    return;

  char canonical_ip[INET6_ADDRSTRLEN];
  CHECK_EQ(0, uv_inet_ntop(af, result, canonical_ip, sizeof(canonical_ip)));
  Local<String> val = String::NewFromUtf8(isolate, canonical_ip)
      .ToLocalChecked();
  args.GetReturnValue().Set(val);
}",62,,1536,2,,void
15422,BLOCK,-1,,<empty>,5,,1544,2,,void
15460,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsString());
  CHECK(args[2]->IsInt32());
  CHECK(args[4]->IsBoolean());
  Local<Object> req_wrap_obj = args[0].As<Object>();
  node::Utf8Value hostname(env->isolate(), args[1]);
  std::string ascii_hostname = ada::idna::to_ascii(hostname.ToStringView());

  int32_t flags = 0;
  if (args[3]->IsInt32()) {
    flags = args[3].As<Int32>()->Value();
  }

  int family;

  switch (args[2].As<Int32>()->Value()) {
    case 0:
      family = AF_UNSPEC;
      break;
    case 4:
      family = AF_INET;
      break;
    case 6:
      family = AF_INET6;
      break;
    default:
      UNREACHABLE(""bad address family"");
  }

  auto req_wrap = std::make_unique<GetAddrInfoReqWrap>(env,
                                                       req_wrap_obj,
                                                       args[4]->IsTrue());

  struct addrinfo hints;
  memset(&hints, 0, sizeof(hints));
  hints.ai...",59,,1553,2,,void
15542,BLOCK,-1,,"{
    flags = args[3].As<Int32>()->Value();
  }",27,,1565,2,,void
15565,BLOCK,-1,,"{
    case 0:
      family = AF_UNSPEC;
      break;
    case 4:
      family = AF_INET;
      break;
    case 6:
      family = AF_INET6;
      break;
    default:
      UNREACHABLE(""bad address family"");
  }",41,,1571,2,,void
15675,BLOCK,-1,,<empty>,5,,1609,2,,void
15693,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsString());
  CHECK(args[2]->IsUint32());
  Local<Object> req_wrap_obj = args[0].As<Object>();
  node::Utf8Value ip(env->isolate(), args[1]);
  const unsigned port = args[2]->Uint32Value(env->context()).FromJust();
  struct sockaddr_storage addr;

  CHECK(uv_ip4_addr(*ip, port, reinterpret_cast<sockaddr_in*>(&addr)) == 0 ||
        uv_ip6_addr(*ip, port, reinterpret_cast<sockaddr_in6*>(&addr)) == 0);

  auto req_wrap = std::make_unique<GetNameInfoReqWrap>(env, req_wrap_obj);

  TRACE_EVENT_NESTABLE_ASYNC_BEGIN2(
      TRACING_CATEGORY_NODE2(dns, native), ""lookupService"", req_wrap.get(),
      ""ip"", TRACE_STR_COPY(*ip), ""port"", port);

  int err = req_wrap->Dispatch(uv_getnameinfo,
                               AfterGetNameInfo,
                               reinterpret_cast<struct sockaddr*>(&addr),
                               NI_NAMEREQD);
  if (err == 0)
    // Release owner...",59,,1615,2,,void
15829,BLOCK,-1,,<empty>,5,,1641,2,,void
15847,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  ChannelWrap* channel;
  ASSIGN_OR_RETURN_UNWRAP(&channel, args.Holder());

  Local<Array> server_array = Array::New(env->isolate());

  ares_addr_port_node* servers;

  int r = ares_get_servers_ports(channel->cares_channel(), &servers);
  CHECK_EQ(r, ARES_SUCCESS);
  auto cleanup = OnScopeLeave([&]() { ares_free_data(servers); });

  ares_addr_port_node* cur = servers;

  for (uint32_t i = 0; cur != nullptr; ++i, cur = cur->next) {
    char ip[INET6_ADDRSTRLEN];

    const void* caddr = static_cast<const void*>(&cur->addr);
    int err = uv_inet_ntop(cur->family, caddr, ip, sizeof(ip));
    CHECK_EQ(err, 0);

    Local<Value> ret[] = {
      OneByteString(env->isolate(), ip),
      Integer::New(env->isolate(), cur->udp_port)
    };

    if (server_array->Set(env->context(), i,
                          Array::New(env->isolate(), ret, arraysize(ret)))
          .IsNothing()) {
      return;
    }
  }

  args.GetReturnValue().Set...",58,,1647,2,,void
15901,BLOCK,-1,,<empty>,3,,1662,1,,void
15917,BLOCK,4,,"{
    char ip[INET6_ADDRSTRLEN];

    const void* caddr = static_cast<const void*>(&cur->addr);
    int err = uv_inet_ntop(cur->family, caddr, ip, sizeof(ip));
    CHECK_EQ(err, 0);

    Local<Value> ret[] = {
      OneByteString(env->isolate(), ip),
      Integer::New(env->isolate(), cur->udp_port)
    };

    if (server_array->Set(env->context(), i,
                          Array::New(env->isolate(), ret, arraysize(ret)))
          .IsNothing()) {
      return;
    }
  }",62,,1662,4,,void
15987,BLOCK,-1,,"{
      return;
    }",25,,1676,2,,void
16001,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  ChannelWrap* channel;
  ASSIGN_OR_RETURN_UNWRAP(&channel, args.Holder());

  if (channel->active_query_count()) {
    return args.GetReturnValue().Set(DNS_ESETSRVPENDING);
  }

  CHECK(args[0]->IsArray());

  Local<Array> arr = args[0].As<Array>();

  uint32_t len = arr->Length();

  if (len == 0) {
    int rv = ares_set_servers(channel->cares_channel(), nullptr);
    return args.GetReturnValue().Set(rv);
  }

  std::vector<ares_addr_port_node> servers(len);
  ares_addr_port_node* last = nullptr;

  int err;

  for (uint32_t i = 0; i < len; i++) {
    CHECK(arr->Get(env->context(), i).ToLocalChecked()->IsArray());

    Local<Array> elm = arr->Get(env->context(), i).ToLocalChecked().As<Array>();

    CHECK(elm->Get(env->context(),
                   0).ToLocalChecked()->Int32Value(env->context()).FromJust());
    CHECK(elm->Get(env->context(), 1).ToLocalChecked()->IsString());
    CHECK(elm->Get(env->context(),
                 ...",58,,1685,2,,void
16023,BLOCK,-1,,"{
    return args.GetReturnValue().Set(DNS_ESETSRVPENDING);
  }",38,,1690,2,,void
16063,BLOCK,-1,,"{
    int rv = ares_set_servers(channel->cares_channel(), nullptr);
    return args.GetReturnValue().Set(rv);
  }",17,,1700,2,,void
16096,BLOCK,-1,,<empty>,3,,1710,1,,void
16106,BLOCK,4,,"{
    CHECK(arr->Get(env->context(), i).ToLocalChecked()->IsArray());

    Local<Array> elm = arr->Get(env->context(), i).ToLocalChecked().As<Array>();

    CHECK(elm->Get(env->context(),
                   0).ToLocalChecked()->Int32Value(env->context()).FromJust());
    CHECK(elm->Get(env->context(), 1).ToLocalChecked()->IsString());
    CHECK(elm->Get(env->context(),
                   2).ToLocalChecked()->Int32Value(env->context()).FromJust());

    int fam = elm->Get(env->context(), 0)
        .ToLocalChecked()->Int32Value(env->context()).FromJust();
    node::Utf8Value ip(env->isolate(),
                       elm->Get(env->context(), 1).ToLocalChecked());
    int port = elm->Get(env->context(), 2)
        .ToLocalChecked()->Int32Value(env->context()).FromJust();

    ares_addr_port_node* cur = &servers[i];

    cur->tcp_port = cur->udp_port = port;
    switch (fam) {
      case 4:
        cur->family = AF_INET;
        err = uv_inet_pton(AF_INET, *ip, &cur->addr);
        brea...",38,,1710,4,,void
16292,BLOCK,-1,,"{
      case 4:
        cur->family = AF_INET;
        err = uv_inet_pton(AF_INET, *ip, &cur->addr);
        break;
      case 6:
        cur->family = AF_INET6;
        err = uv_inet_pton(AF_INET6, *ip, &cur->addr);
        break;
      default:
        UNREACHABLE(""Bad address family"");
    }",18,,1731,2,,void
16334,BLOCK,-1,,<empty>,7,,1745,2,,void
16345,BLOCK,-1,,<empty>,7,,1750,2,,void
16358,BLOCK,-1,,<empty>,5,,1756,2,,void
16371,BLOCK,-1,,<empty>,5,,1758,1,,void
16379,BLOCK,-1,,<empty>,5,,1761,2,,void
16397,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  ChannelWrap* channel;
  ASSIGN_OR_RETURN_UNWRAP(&channel, args.Holder());

  CHECK_EQ(args.Length(), 2);
  CHECK(args[0]->IsString());

  Isolate* isolate = args.GetIsolate();
  node::Utf8Value ip0(isolate, args[0]);

  unsigned char addr0[sizeof(struct in6_addr)];
  unsigned char addr1[sizeof(struct in6_addr)];
  int type0 = 0;

  // This function accepts 2 arguments.  The first may be either an IPv4
  // address or an IPv6 address.  If present, the second argument must be the
  // other type of address.  Otherwise, the unspecified type of IP is set
  // to 0 (any).

  if (uv_inet_pton(AF_INET, *ip0, &addr0) == 0) {
    ares_set_local_ip4(channel->cares_channel(), ReadUint32BE(addr0));
    type0 = 4;
  } else if (uv_inet_pton(AF_INET6, *ip0, &addr0) == 0) {
    ares_set_local_ip6(channel->cares_channel(), addr0);
    type0 = 6;
  } else {
    THROW_ERR_INVALID_ARG_VALUE(env, ""Invalid IP address."");
    return;
  }

  if (!args...",63,,1766,2,,void
16455,BLOCK,-1,,"{
    ares_set_local_ip4(channel->cares_channel(), ReadUint32BE(addr0));
    type0 = 4;
  }",49,,1786,2,,void
16467,BLOCK,-1,,<empty>,10,,1789,1,,void
16477,BLOCK,-1,,"{
    ares_set_local_ip6(channel->cares_channel(), addr0);
    type0 = 6;
  }",57,,1789,2,,void
16488,BLOCK,-1,,"{
    THROW_ERR_INVALID_ARG_VALUE(env, ""Invalid IP address."");
    return;
  }",10,,1792,1,,void
16501,BLOCK,-1,,"{
    CHECK(args[1]->IsString());
    node::Utf8Value ip1(isolate, args[1]);

    if (uv_inet_pton(AF_INET, *ip1, &addr1) == 0) {
      if (type0 == 4) {
        THROW_ERR_INVALID_ARG_VALUE(env, ""Cannot specify two IPv4 addresses."");
        return;
      } else {
        ares_set_local_ip4(channel->cares_channel(), ReadUint32BE(addr1));
      }
    } else if (uv_inet_pton(AF_INET6, *ip1, &addr1) == 0) {
      if (type0 == 6) {
        THROW_ERR_INVALID_ARG_VALUE(env, ""Cannot specify two IPv6 addresses."");
        return;
      } else {
        ares_set_local_ip6(channel->cares_channel(), addr1);
      }
    } else {
      THROW_ERR_INVALID_ARG_VALUE(env, ""Invalid IP address."");
      return;
    }
  }",32,,1797,2,,void
16524,BLOCK,-1,,"{
      if (type0 == 4) {
        THROW_ERR_INVALID_ARG_VALUE(env, ""Cannot specify two IPv4 addresses."");
        return;
      } else {
        ares_set_local_ip4(channel->cares_channel(), ReadUint32BE(addr1));
      }
    }",51,,1801,2,,void
16529,BLOCK,-1,,"{
        THROW_ERR_INVALID_ARG_VALUE(env, ""Cannot specify two IPv4 addresses."");
        return;
      }",23,,1802,2,,void
16535,BLOCK,-1,,"{
        ares_set_local_ip4(channel->cares_channel(), ReadUint32BE(addr1));
      }",14,,1805,1,,void
16544,BLOCK,-1,,<empty>,12,,1808,1,,void
16554,BLOCK,-1,,"{
      if (type0 == 6) {
        THROW_ERR_INVALID_ARG_VALUE(env, ""Cannot specify two IPv6 addresses."");
        return;
      } else {
        ares_set_local_ip6(channel->cares_channel(), addr1);
      }
    }",59,,1808,2,,void
16559,BLOCK,-1,,"{
        THROW_ERR_INVALID_ARG_VALUE(env, ""Cannot specify two IPv6 addresses."");
        return;
      }",23,,1809,2,,void
16565,BLOCK,-1,,"{
        ares_set_local_ip6(channel->cares_channel(), addr1);
      }",14,,1812,1,,void
16573,BLOCK,-1,,"{
      THROW_ERR_INVALID_ARG_VALUE(env, ""Invalid IP address."");
      return;
    }",12,,1815,1,,void
16579,BLOCK,-1,,"{
    // No second arg specified
    if (type0 == 4) {
      memset(&addr1, 0, sizeof(addr1));
      ares_set_local_ip6(channel->cares_channel(), addr1);
    } else {
      ares_set_local_ip4(channel->cares_channel(), 0);
    }
  }",10,,1819,1,,void
16584,BLOCK,-1,,"{
      memset(&addr1, 0, sizeof(addr1));
      ares_set_local_ip6(channel->cares_channel(), addr1);
    }",21,,1821,2,,void
16598,BLOCK,-1,,"{
      ares_set_local_ip4(channel->cares_channel(), 0);
    }",12,,1824,1,,void
16609,BLOCK,-1,,"{
  ChannelWrap* channel;
  ASSIGN_OR_RETURN_UNWRAP(&channel, args.Holder());

  TRACE_EVENT_INSTANT0(TRACING_CATEGORY_NODE2(dns, native),
      ""cancel"", TRACE_EVENT_SCOPE_THREAD);

  ares_cancel(channel->cares_channel());
}",54,,1830,2,,void
16637,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  int code = args[0]->Int32Value(env->context()).FromJust();
  const char* errmsg = (code == DNS_ESETSRVPENDING) ?
    EMSG_ESETSRVPENDING :
    ares_strerror(code);
  args.GetReturnValue().Set(OneByteString(env->isolate(), errmsg));
}",56,,1841,2,,void
16689,BLOCK,-1,,"{
  int idx;

  if (host->h_addr_list != nullptr) {
    idx = 0;
    while (host->h_addr_list[idx]) {
      free(host->h_addr_list[idx++]);
    }
    free(host->h_addr_list);
    host->h_addr_list = nullptr;
  }

  if (host->h_aliases != nullptr) {
    idx = 0;
    while (host->h_aliases[idx]) {
      free(host->h_aliases[idx++]);
    }
    free(host->h_aliases);
    host->h_aliases = nullptr;
  }

  free(host->h_name);
  free(host);
}",53,,1852,2,,void
16697,BLOCK,-1,,"{
    idx = 0;
    while (host->h_addr_list[idx]) {
      free(host->h_addr_list[idx++]);
    }
    free(host->h_addr_list);
    host->h_addr_list = nullptr;
  }",37,,1855,2,,void
16707,BLOCK,-1,,"{
      free(host->h_addr_list[idx++]);
    }",36,,1857,2,,void
16730,BLOCK,-1,,"{
    idx = 0;
    while (host->h_aliases[idx]) {
      free(host->h_aliases[idx++]);
    }
    free(host->h_aliases);
    host->h_aliases = nullptr;
  }",35,,1864,2,,void
16740,BLOCK,-1,,"{
      free(host->h_aliases[idx++]);
    }",34,,1866,2,,void
16770,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  SetMethod(context, target, ""getaddrinfo"", GetAddrInfo);
  SetMethod(context, target, ""getnameinfo"", GetNameInfo);
  SetMethodNoSideEffect(context, target, ""canonicalizeIP"", CanonicalizeIP);

  SetMethod(context, target, ""strerror"", StrError);

  target->Set(env->context(), FIXED_ONE_BYTE_STRING(env->isolate(), ""AF_INET""),
              Integer::New(env->isolate(), AF_INET)).Check();
  target->Set(env->context(), FIXED_ONE_BYTE_STRING(env->isolate(), ""AF_INET6""),
              Integer::New(env->isolate(), AF_INET6)).Check();
  target->Set(env->context(), FIXED_ONE_BYTE_STRING(env->isolate(),
                                                    ""AF_UNSPEC""),
              Integer::New(env->isolate(), AF_UNSPEC)).Check();
  target->Set(env->context(), FIXED_ONE_BYTE_STRING(env->isolate(),
                                                    ""AI_ADDRCONFIG""),
              Integer::New(env->is...",29,,1880,5,,void
16935,BLOCK,1,,<empty>,,,,1,,void
16963,BLOCK,1,,<empty>,,,,1,,void
17165,BLOCK,-1,,"{
  registry->Register(GetAddrInfo);
  registry->Register(GetNameInfo);
  registry->Register(CanonicalizeIP);
  registry->Register(StrError);
  registry->Register(ChannelWrap::New);

  registry->Register(Query<QueryAnyWrap>);
  registry->Register(Query<QueryAWrap>);
  registry->Register(Query<QueryAaaaWrap>);
  registry->Register(Query<QueryCaaWrap>);
  registry->Register(Query<QueryCnameWrap>);
  registry->Register(Query<QueryMxWrap>);
  registry->Register(Query<QueryNsWrap>);
  registry->Register(Query<QueryTxtWrap>);
  registry->Register(Query<QuerySrvWrap>);
  registry->Register(Query<QueryPtrWrap>);
  registry->Register(Query<QueryNaptrWrap>);
  registry->Register(Query<QuerySoaWrap>);
  registry->Register(Query<GetHostByAddrWrap>);

  registry->Register(GetServers);
  registry->Register(SetServers);
  registry->Register(SetLocalAddress);
  registry->Register(Cancel);
}",70,,1951,2,,void
17311,BLOCK,-1,,<empty>,1,,1,1,,ANY
17316,BLOCK,-1,,<empty>,1,,1,1,,ANY
17329,BLOCK,-1,,<empty>,1,,1,1,,ANY
17334,BLOCK,-1,,"{
              // Sort in descending order so that the most recently inserted
              // callbacks are run first.
              return a.insertion_order_counter_ > b.insertion_order_counter_;
            }",76,,17,3,,void
17357,BLOCK,-1,,<empty>,1,,1,1,,ANY
17360,BLOCK,-1,,"{
  // Copy into a vector, since we can't sort an unordered_set in-place.
  std::vector<CleanupHookCallback> callbacks(cleanup_hooks_.begin(),
                                             cleanup_hooks_.end());
  // We can't erase the copied elements from `cleanup_hooks_` yet, because we
  // need to be able to check whether they were un-scheduled by another hook.

  std::sort(callbacks.begin(),
            callbacks.end(),
            [](const CleanupHookCallback& a, const CleanupHookCallback& b) {
              // Sort in descending order so that the most recently inserted
              // callbacks are run first.
              return a.insertion_order_counter_ > b.insertion_order_counter_;
            });

  for (const CleanupHookCallback& cb : callbacks) {
    if (cleanup_hooks_.count(cb) == 0) {
      // This hook was removed from the `cleanup_hooks_` set during another
      // hook that was run earlier. Nothing to do here.
      continue;
    }

    cb.fn_(cb.arg_);
    clean...",28,,8,1,,void
17392,BLOCK,-1,,"{
    if (cleanup_hooks_.count(cb) == 0) {
      // This hook was removed from the `cleanup_hooks_` set during another
      // hook that was run earlier. Nothing to do here.
      continue;
    }

    cb.fn_(cb.arg_);
    cleanup_hooks_.erase(cb);
  }",51,,23,3,,void
17401,BLOCK,-1,,"{
      // This hook was removed from the `cleanup_hooks_` set during another
      // hook that was run earlier. Nothing to do here.
      continue;
    }",40,,24,2,,void
17419,BLOCK,-1,,"{
  return std::hash<void*>()(cb.arg_);
}",42,,36,2,,void
17434,BLOCK,-1,,"{
  return a.fn_ == b.fn_ && a.arg_ == b.arg_;
}",71,,41,3,,void
17465,BLOCK,-1,,<empty>,1,,1,1,,ANY
17474,BLOCK,-1,,<empty>,1,,1,1,,ANY
17481,BLOCK,-1,,"{
}",78,,13,4,,void
17492,BLOCK,-1,,<empty>,1,,1,1,,ANY
17513,BLOCK,-1,,<empty>,1,,1,1,,ANY
17519,BLOCK,-1,,<empty>,33,,29,4,,void
17525,BLOCK,-1,,"{
  WrapType* wrap_data = static_cast<WrapType*>(handle->data);
  CHECK_NOT_NULL(wrap_data);
  CHECK_EQ(&wrap_data->handle_, reinterpret_cast<UVType*>(handle));

  Environment* env = wrap_data->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  // We should not be getting this callback if someone has already called
  // uv_close() on the handle.
  CHECK_EQ(wrap_data->persistent().IsEmpty(), false);

  Local<Value> client_handle;

  if (status == 0) {
    // Instantiate the client javascript object and handle.
    Local<Object> client_obj;
    if (!WrapType::Instantiate(env, wrap_data, WrapType::SOCKET)
             .ToLocal(&client_obj))
      return;

    // Unwrap the client javascript object.
    WrapType* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, client_obj);
    uv_stream_t* client = reinterpret_cast<uv_stream_t*>(&wrap->handle_);
    // uv_accept can fail if the new connection has already been closed, in
    // which case an EA...",65,,34,3,,void
17581,BLOCK,-1,,"{
    // Instantiate the client javascript object and handle.
    Local<Object> client_obj;
    if (!WrapType::Instantiate(env, wrap_data, WrapType::SOCKET)
             .ToLocal(&client_obj))
      return;

    // Unwrap the client javascript object.
    WrapType* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, client_obj);
    uv_stream_t* client = reinterpret_cast<uv_stream_t*>(&wrap->handle_);
    // uv_accept can fail if the new connection has already been closed, in
    // which case an EAGAIN (resource temporarily unavailable) will be
    // returned.
    if (uv_accept(handle, client))
      return;

    // Successful accept. Call the onconnection callback in JavaScript land.
    client_handle = client_obj;
  }",20,,49,2,,void
17603,BLOCK,-1,,<empty>,7,,54,2,,void
17623,BLOCK,-1,,<empty>,7,,64,2,,void
17629,BLOCK,-1,,"{
    client_handle = Undefined(env->isolate());
  }",10,,68,1,,void
17667,BLOCK,-1,,"{
  BaseObjectPtr<ConnectWrap> req_wrap{static_cast<ConnectWrap*>(req->data)};
  CHECK(req_wrap);
  WrapType* wrap = static_cast<WrapType*>(req->handle->data);
  CHECK_EQ(req_wrap->env(), wrap->env());
  Environment* env = wrap->env();

  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  // The wrap and request objects should still be there.
  CHECK_EQ(req_wrap->persistent().IsEmpty(), false);
  CHECK_EQ(wrap->persistent().IsEmpty(), false);

  bool readable, writable;

  if (status) {
    readable = writable = false;
  } else {
    readable = uv_is_readable(req->handle) != 0;
    writable = uv_is_writable(req->handle) != 0;
  }

  Local<Value> argv[5] = {
    Integer::New(env->isolate(), status),
    wrap->object(),
    req_wrap->object(),
    Boolean::New(env->isolate(), readable),
    Boolean::New(env->isolate(), writable)
  };

  TRACE_EVENT_NESTABLE_ASYNC_END1(TRACING_CATEGORY_NODE2(net, native),
                                  ""conn...",65,,79,3,,void
17740,BLOCK,-1,,"{
    readable = writable = false;
  }",15,,95,2,,void
17747,BLOCK,-1,,"{
    readable = uv_is_readable(req->handle) != 0;
    writable = uv_is_writable(req->handle) != 0;
  }",10,,97,1,,void
17802,BLOCK,-1,,<empty>,1,,1,1,,ANY
17833,BLOCK,-1,,<empty>,1,,1,1,,ANY
17844,BLOCK,-1,,"{
  CHECK_NOT_NULL(key_data);
  CHECK_EQ(key_data->GetKeyType(), kKeyTypeSecret);

  const int mode = EVP_CIPHER_mode(params.cipher);

  CipherCtxPointer ctx(EVP_CIPHER_CTX_new());
  EVP_CIPHER_CTX_init(ctx.get());
  if (mode == EVP_CIPH_WRAP_MODE)
    EVP_CIPHER_CTX_set_flags(ctx.get(), EVP_CIPHER_CTX_FLAG_WRAP_ALLOW);

  const bool encrypt = cipher_mode == kWebCryptoCipherEncrypt;

  if (!EVP_CipherInit_ex(
          ctx.get(),
          params.cipher,
          nullptr,
          nullptr,
          nullptr,
          encrypt)) {
    // Cipher init failed
    return WebCryptoCipherStatus::FAILED;
  }

  if (mode == EVP_CIPH_GCM_MODE && !EVP_CIPHER_CTX_ctrl(
        ctx.get(),
        EVP_CTRL_AEAD_SET_IVLEN,
        params.iv.size(),
        nullptr)) {
    return WebCryptoCipherStatus::FAILED;
  }

  if (!EVP_CIPHER_CTX_set_key_length(
          ctx.get(),
          key_data->GetSymmetricKeySize()) ||
      !EVP_CipherInit_ex(
          ctx.get(),
          nullptr,
          nul...",22,,40,7,,void
17872,BLOCK,-1,,<empty>,5,,49,2,,void
17899,BLOCK,-1,,"{
    // Cipher init failed
    return WebCryptoCipherStatus::FAILED;
  }",21,,59,2,,void
17923,BLOCK,-1,,"{
    return WebCryptoCipherStatus::FAILED;
  }",19,,68,2,,void
17961,BLOCK,-1,,"{
    return WebCryptoCipherStatus::FAILED;
  }",21,,81,2,,void
17974,BLOCK,-1,,"{
    switch (cipher_mode) {
      case kWebCryptoCipherDecrypt:
        // If in decrypt mode, the auth tag must be set in the params.tag.
        CHECK(params.tag);
        if (!EVP_CIPHER_CTX_ctrl(ctx.get(),
                                 EVP_CTRL_AEAD_SET_TAG,
                                 params.tag.size(),
                                 const_cast<char*>(params.tag.data<char>()))) {
          return WebCryptoCipherStatus::FAILED;
        }
        break;
      case kWebCryptoCipherEncrypt:
        // In decrypt mode, we grab the tag length here. We'll use it to
        // ensure that that allocated buffer has enough room for both the
        // final block and the auth tag. Unlike our other AES-GCM implementation
        // in CipherBase, in WebCrypto, the auth tag is concatenated to the end
        // of the generated ciphertext and returned in the same ArrayBuffer.
        tag_len = params.length;
        break;
      default:
        UNREACHABLE();
    }
  }",34,,87,2,,void
17977,BLOCK,-1,,"{
      case kWebCryptoCipherDecrypt:
        // If in decrypt mode, the auth tag must be set in the params.tag.
        CHECK(params.tag);
        if (!EVP_CIPHER_CTX_ctrl(ctx.get(),
                                 EVP_CTRL_AEAD_SET_TAG,
                                 params.tag.size(),
                                 const_cast<char*>(params.tag.data<char>()))) {
          return WebCryptoCipherStatus::FAILED;
        }
        break;
      case kWebCryptoCipherEncrypt:
        // In decrypt mode, we grab the tag length here. We'll use it to
        // ensure that that allocated buffer has enough room for both the
        // final block and the auth tag. Unlike our other AES-GCM implementation
        // in CipherBase, in WebCrypto, the auth tag is concatenated to the end
        // of the generated ciphertext and returned in the same ArrayBuffer.
        tag_len = params.length;
        break;
      default:
        UNREACHABLE();
    }",26,,88,2,,void
18006,BLOCK,-1,,"{
          return WebCryptoCipherStatus::FAILED;
        }",79,,95,2,,void
18075,BLOCK,-1,,"{
    return WebCryptoCipherStatus::FAILED;
  }",45,,123,2,,void
18090,BLOCK,-1,,"{
    out_len = 0;
  }",23,,137,2,,void
18095,BLOCK,-1,,<empty>,10,,139,1,,void
18117,BLOCK,-1,,"{
    return WebCryptoCipherStatus::FAILED;
  }",44,,143,2,,void
18150,BLOCK,-1,,"{
    return WebCryptoCipherStatus::FAILED;
  }",68,,151,2,,void
18166,BLOCK,-1,,"{
    if (!EVP_CIPHER_CTX_ctrl(ctx.get(),
                             EVP_CTRL_AEAD_GET_TAG,
                             tag_len,
                             buf.data<unsigned char>() + total))
      return WebCryptoCipherStatus::FAILED;
    total += tag_len;
  }",76,,158,2,,void
18182,BLOCK,-1,,<empty>,7,,163,2,,void
18211,BLOCK,-1,,"{
  return a == 0 ? 0 : 1 + (a - 1) / b;
}",21,,178,3,,void
18229,BLOCK,-1,,"{
  unsigned int remainder = (params.length % CHAR_BIT);
  const unsigned char* data = params.iv.data<unsigned char>();

  if (remainder == 0) {
    unsigned int byte_length = params.length / CHAR_BIT;
    return BignumPointer(BN_bin2bn(
        data + params.iv.size() - byte_length,
        byte_length,
        nullptr));
  }

  unsigned int byte_length =
      CeilDiv(params.length, static_cast<size_t>(CHAR_BIT));

  std::vector<unsigned char> counter(
      data + params.iv.size() - byte_length,
      data + params.iv.size());
  counter[0] &= ~(0xFF << remainder);

  return BignumPointer(BN_bin2bn(counter.data(), counter.size(), nullptr));
}",57,,182,2,,void
18251,BLOCK,-1,,"{
    unsigned int byte_length = params.length / CHAR_BIT;
    return BignumPointer(BN_bin2bn(
        data + params.iv.size() - byte_length,
        byte_length,
        nullptr));
  }",23,,186,2,,void
18329,BLOCK,-1,,"{
  unsigned int length_bytes = params.length / CHAR_BIT;
  unsigned int remainder = params.length % CHAR_BIT;

  const unsigned char* data = params.iv.data<unsigned char>();

  std::vector<unsigned char> new_counter_block(data, data + params.iv.size());

  size_t index = new_counter_block.size() - length_bytes;
  memset(&new_counter_block.front() + index, 0, length_bytes);

  if (remainder)
    new_counter_block[index - 1] &= 0xFF << remainder;

  return new_counter_block;
}",36,,206,2,,void
18387,BLOCK,-1,,<empty>,5,,218,2,,void
18408,BLOCK,-1,,"{
  CipherCtxPointer ctx(EVP_CIPHER_CTX_new());
  const bool encrypt = cipher_mode == kWebCryptoCipherEncrypt;

  if (!EVP_CipherInit_ex(
          ctx.get(),
          params.cipher,
          nullptr,
          reinterpret_cast<const unsigned char*>(key_data->GetSymmetricKey()),
          counter,
          encrypt)) {
    // Cipher init failed
    return WebCryptoCipherStatus::FAILED;
  }

  int out_len = 0;
  int final_len = 0;
  if (!EVP_CipherUpdate(
          ctx.get(),
          out,
          &out_len,
          in.data<unsigned char>(),
          in.size())) {
    return WebCryptoCipherStatus::FAILED;
  }

  if (!EVP_CipherFinal_ex(ctx.get(), out + out_len, &final_len))
    return WebCryptoCipherStatus::FAILED;

  out_len += final_len;
  if (static_cast<unsigned>(out_len) != in.size())
    return WebCryptoCipherStatus::FAILED;

  return WebCryptoCipherStatus::OK;
}",25,,229,7,,void
18437,BLOCK,-1,,"{
    // Cipher init failed
    return WebCryptoCipherStatus::FAILED;
  }",21,,239,2,,void
18468,BLOCK,-1,,"{
    return WebCryptoCipherStatus::FAILED;
  }",23,,251,2,,void
18485,BLOCK,-1,,<empty>,5,,256,2,,void
18502,BLOCK,-1,,<empty>,5,,260,2,,void
18520,BLOCK,-1,,"{
  BignumPointer num_counters(BN_new());
  if (!BN_lshift(num_counters.get(), BN_value_one(), params.length))
    return WebCryptoCipherStatus::FAILED;

  BignumPointer current_counter = GetCounter(params);

  BignumPointer num_output(BN_new());

  if (!BN_set_word(num_output.get(), CeilDiv(in.size(), kAesBlockSize)))
    return WebCryptoCipherStatus::FAILED;

  // Just like in chromium's implementation, if the counter will
  // be incremented more than there are counter values, we fail.
  if (BN_cmp(num_output.get(), num_counters.get()) > 0)
    return WebCryptoCipherStatus::FAILED;

  BignumPointer remaining_until_reset(BN_new());
  if (!BN_sub(remaining_until_reset.get(),
              num_counters.get(),
              current_counter.get())) {
    return WebCryptoCipherStatus::FAILED;
  }

  // Output size is identical to the input size.
  ByteSource::Builder buf(in.size());

  // Also just like in chromium's implementation, if we can process
  // the input without wrapping the...",22,,271,7,,void
18535,BLOCK,-1,,<empty>,5,,274,2,,void
18561,BLOCK,-1,,<empty>,5,,281,2,,void
18578,BLOCK,-1,,<empty>,5,,286,2,,void
18601,BLOCK,-1,,"{
    return WebCryptoCipherStatus::FAILED;
  }",39,,291,2,,void
18624,BLOCK,-1,,"{
    auto status = AES_CTR_Cipher2(key_data,
                                  cipher_mode,
                                  params,
                                  in,
                                  params.iv.data<unsigned char>(),
                                  buf.data<unsigned char>());
    if (status == WebCryptoCipherStatus::OK) *out = std::move(buf).release();
    return status;
  }",67,,301,2,,void
18649,BLOCK,-1,,<empty>,46,,308,2,,void
18709,BLOCK,-1,,<empty>,5,,325,2,,void
18755,BLOCK,-1,,<empty>,44,,340,2,,void
18776,BLOCK,-1,,"{
  ArrayBufferOrViewContents<char> iv(value);
  if (UNLIKELY(!iv.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""iv is too big"");
    return false;
  }
  params->iv = (mode == kCryptoJobAsync)
      ? iv.ToCopy()
      : iv.ToByteSource();
  return true;
}",30,,349,5,,void
18787,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""iv is too big"");
    return false;
  }",39,,351,2,,void
18817,BLOCK,-1,,"{
  CHECK(value->IsUint32());  // Length
  params->length = value.As<Uint32>()->Value();
  if (params->iv.size() != 16 ||
      params->length == 0 ||
      params->length > 128) {
    THROW_ERR_CRYPTO_INVALID_COUNTER(env);
    return false;
  }
  return true;
}",28,,364,4,,void
18855,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_COUNTER(env);
    return false;
  }",29,,369,2,,void
18870,BLOCK,-1,,"{
  switch (cipher_mode) {
    case kWebCryptoCipherDecrypt: {
      if (!IsAnyByteSource(value)) {
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }
      ArrayBufferOrViewContents<char> tag_contents(value);
      if (UNLIKELY(!tag_contents.CheckSizeInt32())) {
        THROW_ERR_OUT_OF_RANGE(env, ""tagLength is too big"");
        return false;
      }
      params->tag = mode == kCryptoJobAsync
          ? tag_contents.ToCopy()
          : tag_contents.ToByteSource();
      break;
    }
    case kWebCryptoCipherEncrypt: {
      if (!value->IsUint32()) {
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }
      params->length = value.As<Uint32>()->Value();
      if (params->length > 128) {
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }
      break;
    }
    default:
      UNREACHABLE();
  }
  return true;
}",30,,381,6,,void
18873,BLOCK,-1,,"{
    case kWebCryptoCipherDecrypt: {
      if (!IsAnyByteSource(value)) {
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }
      ArrayBufferOrViewContents<char> tag_contents(value);
      if (UNLIKELY(!tag_contents.CheckSizeInt32())) {
        THROW_ERR_OUT_OF_RANGE(env, ""tagLength is too big"");
        return false;
      }
      params->tag = mode == kCryptoJobAsync
          ? tag_contents.ToCopy()
          : tag_contents.ToByteSource();
      break;
    }
    case kWebCryptoCipherEncrypt: {
      if (!value->IsUint32()) {
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }
      params->length = value.As<Uint32>()->Value();
      if (params->length > 128) {
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }
      break;
    }
    default:
      UNREACHABLE();
  }",24,,382,2,,void
18876,BLOCK,3,,"{
      if (!IsAnyByteSource(value)) {
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }
      ArrayBufferOrViewContents<char> tag_contents(value);
      if (UNLIKELY(!tag_contents.CheckSizeInt32())) {
        THROW_ERR_OUT_OF_RANGE(env, ""tagLength is too big"");
        return false;
      }
      params->tag = mode == kCryptoJobAsync
          ? tag_contents.ToCopy()
          : tag_contents.ToByteSource();
      break;
    }",35,,383,3,,void
18881,BLOCK,-1,,"{
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }",36,,384,2,,void
18896,BLOCK,-1,,"{
        THROW_ERR_OUT_OF_RANGE(env, ""tagLength is too big"");
        return false;
      }",53,,389,2,,void
18921,BLOCK,6,,"{
      if (!value->IsUint32()) {
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }
      params->length = value.As<Uint32>()->Value();
      if (params->length > 128) {
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }
      break;
    }",35,,398,6,,void
18928,BLOCK,-1,,"{
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }",31,,399,2,,void
18950,BLOCK,-1,,"{
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }",33,,404,2,,void
18967,BLOCK,-1,,"{
  // Additional Data
  if (IsAnyByteSource(value)) {
    ArrayBufferOrViewContents<char> additional(value);
    if (UNLIKELY(!additional.CheckSizeInt32())) {
      THROW_ERR_OUT_OF_RANGE(env, ""additionalData is too big"");
      return false;
    }
    params->additional_data = mode == kCryptoJobAsync
        ? additional.ToCopy()
        : additional.ToByteSource();
  }
  return true;
}",30,,420,5,,void
18971,BLOCK,-1,,"{
    ArrayBufferOrViewContents<char> additional(value);
    if (UNLIKELY(!additional.CheckSizeInt32())) {
      THROW_ERR_OUT_OF_RANGE(env, ""additionalData is too big"");
      return false;
    }
    params->additional_data = mode == kCryptoJobAsync
        ? additional.ToCopy()
        : additional.ToByteSource();
  }",31,,422,2,,void
18982,BLOCK,-1,,"{
      THROW_ERR_OUT_OF_RANGE(env, ""additionalData is too big"");
      return false;
    }",49,,424,2,,void
19010,BLOCK,-1,,"{
  params->iv = ByteSource::Foreign(kDefaultWrapIV, strlen(kDefaultWrapIV));
}",44,,435,2,,void
19026,BLOCK,-1,,<empty>,33,,447,2,,void
19031,BLOCK,-1,,"{
  if (&other == this) return *this;
  this->~AESCipherConfig();
  return *new (this) AESCipherConfig(std::move(other));
}",79,,449,2,,void
19037,BLOCK,-1,,<empty>,23,,450,2,,void
19059,BLOCK,-1,,"{
  // If mode is sync, then the data in each of these properties
  // is not owned by the AESCipherConfig, so we ignore it.
  if (mode == kCryptoJobAsync) {
    tracker->TrackFieldWithSize(""iv"", iv.size());
    tracker->TrackFieldWithSize(""additional_data"", additional_data.size());
    tracker->TrackFieldWithSize(""tag"", tag.size());
  }
}",64,,455,2,,void
19064,BLOCK,-1,,"{
    tracker->TrackFieldWithSize(""iv"", iv.size());
    tracker->TrackFieldWithSize(""additional_data"", additional_data.size());
    tracker->TrackFieldWithSize(""tag"", tag.size());
  }",32,,458,2,,void
19100,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  params->mode = mode;

  CHECK(args[offset]->IsUint32());  // Key Variant
  params->variant =
      static_cast<AESKeyVariant>(args[offset].As<Uint32>()->Value());

  int cipher_nid;

  switch (params->variant) {
    case kKeyVariantAES_CTR_128:
      if (!ValidateIV(env, mode, args[offset + 1], params) ||
          !ValidateCounter(env, args[offset + 2], params)) {
        return Nothing<bool>();
      }
      cipher_nid = NID_aes_128_ctr;
      break;
    case kKeyVariantAES_CTR_192:
      if (!ValidateIV(env, mode, args[offset + 1], params) ||
          !ValidateCounter(env, args[offset + 2], params)) {
        return Nothing<bool>();
      }
      cipher_nid = NID_aes_192_ctr;
      break;
    case kKeyVariantAES_CTR_256:
      if (!ValidateIV(env, mode, args[offset + 1], params) ||
          !ValidateCounter(env, args[offset + 2], params)) {
        return Nothing<bool>();
      }
      cipher_nid = NID_aes_256_ctr;
      ...",30,,470,6,,void
19141,BLOCK,-1,,"{
    case kKeyVariantAES_CTR_128:
      if (!ValidateIV(env, mode, args[offset + 1], params) ||
          !ValidateCounter(env, args[offset + 2], params)) {
        return Nothing<bool>();
      }
      cipher_nid = NID_aes_128_ctr;
      break;
    case kKeyVariantAES_CTR_192:
      if (!ValidateIV(env, mode, args[offset + 1], params) ||
          !ValidateCounter(env, args[offset + 2], params)) {
        return Nothing<bool>();
      }
      cipher_nid = NID_aes_192_ctr;
      break;
    case kKeyVariantAES_CTR_256:
      if (!ValidateIV(env, mode, args[offset + 1], params) ||
          !ValidateCounter(env, args[offset + 2], params)) {
        return Nothing<bool>();
      }
      cipher_nid = NID_aes_256_ctr;
      break;
    case kKeyVariantAES_CBC_128:
      if (!ValidateIV(env, mode, args[offset + 1], params))
        return Nothing<bool>();
      cipher_nid = NID_aes_128_cbc;
      break;
    case kKeyVariantAES_CBC_192:
      if (!ValidateIV(env, mode, args[offset + 1], pa...",28,,481,2,,void
19165,BLOCK,-1,,"{
        return Nothing<bool>();
      }",60,,484,2,,void
19195,BLOCK,-1,,"{
        return Nothing<bool>();
      }",60,,491,2,,void
19225,BLOCK,-1,,"{
        return Nothing<bool>();
      }",60,,498,2,,void
19245,BLOCK,-1,,<empty>,9,,505,2,,void
19265,BLOCK,-1,,<empty>,9,,510,2,,void
19285,BLOCK,-1,,<empty>,9,,515,2,,void
19352,BLOCK,-1,,"{
        return Nothing<bool>();
      }",73,,533,2,,void
19395,BLOCK,-1,,"{
        return Nothing<bool>();
      }",73,,541,2,,void
19438,BLOCK,-1,,"{
        return Nothing<bool>();
      }",73,,549,2,,void
19459,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_UNKNOWN_CIPHER(env);
    return Nothing<bool>();
  }",34,,559,2,,void
19478,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_IV(env);
    return Nothing<bool>();
  }",66,,565,2,,void
19495,BLOCK,-1,,"{
#define V(name, fn)                                                           \
  case kKeyVariantAES_ ## name:                                               \
    return fn(env, key_data.get(), cipher_mode, params, in, out);
  switch (params.variant) {
    VARIANTS(V)
    default:
      UNREACHABLE();
  }
#undef V
}",22,,579,7,,void
19500,BLOCK,-1,,"{
    VARIANTS(V)
    default:
      UNREACHABLE();
  }",27,,583,2,,void
19510,BLOCK,-1,,"{
  AESCryptoJob::Initialize(env, target);

#define V(name, _) NODE_DEFINE_CONSTANT(target, kKeyVariantAES_ ## name);
  VARIANTS(V)
#undef V
}",62,,591,3,,void
19523,BLOCK,-1,,"{
  AESCryptoJob::RegisterExternalReferences(registry);
}",75,,599,2,,void
19545,BLOCK,-1,,<empty>,1,,1,1,,ANY
19548,BLOCK,-1,,"{
    BIO_METHOD* method = BIO_meth_new(BIO_TYPE_MEM, ""node.js SSL buffer"");
    BIO_meth_set_write(method, Write);
    BIO_meth_set_read(method, Read);
    BIO_meth_set_puts(method, Puts);
    BIO_meth_set_gets(method, Gets);
    BIO_meth_set_ctrl(method, Ctrl);
    BIO_meth_set_create(method, New);
    BIO_meth_set_destroy(method, Free);
    return method;
  }",43,,224,1,,void
19598,BLOCK,-1,,<empty>,1,,1,1,,ANY
19603,BLOCK,-1,,"{
  BIOPointer bio(BIO_new(GetMethod()));
  if (bio && env != nullptr)
    NodeBIO::FromBIO(bio.get())->env_ = env;
  return bio;
}",43,,35,2,,void
19606,BLOCK,-1,,<empty>,,,,2,,<empty>
19615,BLOCK,-1,,<empty>,5,,38,2,,void
19636,BLOCK,-1,,"{
  BIOPointer bio = New(env);

  if (!bio ||
      len > INT_MAX ||
      BIO_write(bio.get(), data, len) != static_cast<int>(len) ||
      BIO_set_mem_eof_return(bio.get(), 0) != 1) {
    return BIOPointer();
  }

  return bio;
}",78,,43,4,,void
19670,BLOCK,-1,,"{
    return BIOPointer();
  }",50,,49,2,,void
19679,BLOCK,-1,,"{
  BIO_set_data(bio, new NodeBIO());
  BIO_set_init(bio, 1);

  return 1;
}",28,,57,2,,void
19693,BLOCK,-1,,"{
  if (bio == nullptr)
    return 0;

  if (BIO_get_shutdown(bio)) {
    if (BIO_get_init(bio) && BIO_get_data(bio) != nullptr) {
      delete FromBIO(bio);
      BIO_set_data(bio, nullptr);
    }
  }

  return 1;
}",29,,65,2,,void
19698,BLOCK,-1,,<empty>,5,,67,2,,void
19704,BLOCK,-1,,"{
    if (BIO_get_init(bio) && BIO_get_data(bio) != nullptr) {
      delete FromBIO(bio);
      BIO_set_data(bio, nullptr);
    }
  }",30,,69,2,,void
19713,BLOCK,-1,,"{
      delete FromBIO(bio);
      BIO_set_data(bio, nullptr);
    }",60,,70,2,,void
19728,BLOCK,-1,,"{
  BIO_clear_retry_flags(bio);

  NodeBIO* nbio = FromBIO(bio);
  int bytes = nbio->Read(out, len);

  if (bytes == 0) {
    bytes = nbio->eof_return();
    if (bytes != 0) {
      BIO_set_retry_read(bio);
    }
  }

  return bytes;
}",49,,80,4,,void
19749,BLOCK,-1,,"{
    bytes = nbio->eof_return();
    if (bytes != 0) {
      BIO_set_retry_read(bio);
    }
  }",19,,86,2,,void
19760,BLOCK,-1,,"{
      BIO_set_retry_read(bio);
    }",21,,88,2,,void
19769,BLOCK,-1,,"{
  *size = read_head_->write_pos_ - read_head_->read_pos_;
  return read_head_->data_ + read_head_->read_pos_;
}",35,,97,2,,void
19794,BLOCK,-1,,"{
  Buffer* pos = read_head_;
  size_t max = *count;
  size_t total = 0;

  size_t i;
  for (i = 0; i < max; i++) {
    size[i] = pos->write_pos_ - pos->read_pos_;
    total += size[i];
    out[i] = pos->data_ + pos->read_pos_;

    /* Don't get past write head */
    if (pos == write_head_)
      break;
    else
      pos = pos->next_;
  }

  if (i == max)
    *count = i;
  else
    *count = i + 1;

  return total;
}",71,,103,4,,void
19810,BLOCK,-1,,<empty>,3,,109,1,,void
19819,BLOCK,4,,"{
    size[i] = pos->write_pos_ - pos->read_pos_;
    total += size[i];
    out[i] = pos->data_ + pos->read_pos_;

    /* Don't get past write head */
    if (pos == write_head_)
      break;
    else
      pos = pos->next_;
  }",29,,109,4,,void
19851,BLOCK,-1,,<empty>,7,,116,2,,void
19854,BLOCK,-1,,<empty>,7,,118,1,,void
19864,BLOCK,-1,,<empty>,5,,122,2,,void
19870,BLOCK,-1,,<empty>,5,,124,1,,void
19885,BLOCK,-1,,"{
  BIO_clear_retry_flags(bio);

  FromBIO(bio)->Write(data, len);

  return len;
}",57,,130,4,,void
19902,BLOCK,-1,,"{
  return Write(bio, str, strlen(str));
}",46,,139,3,,void
19915,BLOCK,-1,,"{
  NodeBIO* nbio = FromBIO(bio);

  if (nbio->Length() == 0)
    return 0;

  int i = nbio->IndexOf('\n', size);

  // Include '\n', if it's there.  If not, don't read off the end.
  if (i < size && i >= 0 && static_cast<size_t>(i) < nbio->Length())
    i++;

  // Shift `i` a bit to nullptr-terminate string later
  if (size == i)
    i--;

  // Flush read data
  nbio->Read(out, i);

  out[i] = 0;

  return i;
}",50,,144,4,,void
19928,BLOCK,-1,,<empty>,5,,148,2,,void
19957,BLOCK,-1,,<empty>,5,,154,2,,void
19964,BLOCK,-1,,<empty>,5,,158,2,,void
19987,BLOCK,-1,,"{
  NodeBIO* nbio;
  long ret;  // NOLINT(runtime/int)

  nbio = FromBIO(bio);
  ret = 1;

  switch (cmd) {
    case BIO_CTRL_RESET:
      nbio->Reset();
      break;
    case BIO_CTRL_EOF:
      ret = nbio->Length() == 0;
      break;
    case BIO_C_SET_BUF_MEM_EOF_RETURN:
      nbio->set_eof_return(num);
      break;
    case BIO_CTRL_INFO:
      ret = nbio->Length();
      if (ptr != nullptr)
        *reinterpret_cast<void**>(ptr) = nullptr;
      break;
    case BIO_C_SET_BUF_MEM:
      UNREACHABLE(""Can't use SET_BUF_MEM_PTR with NodeBIO"");
    case BIO_C_GET_BUF_MEM_PTR:
      UNREACHABLE(""Can't use GET_BUF_MEM_PTR with NodeBIO"");
    case BIO_CTRL_GET_CLOSE:
      ret = BIO_get_shutdown(bio);
      break;
    case BIO_CTRL_SET_CLOSE:
      BIO_set_shutdown(bio, num);
      break;
    case BIO_CTRL_WPENDING:
      ret = 0;
      break;
    case BIO_CTRL_PENDING:
      ret = nbio->Length();
      break;
    case BIO_CTRL_DUP:
    case BIO_CTRL_FLUSH:
      ret = 1;
      break;
...",31,,170,5,,void
19999,BLOCK,-1,,"{
    case BIO_CTRL_RESET:
      nbio->Reset();
      break;
    case BIO_CTRL_EOF:
      ret = nbio->Length() == 0;
      break;
    case BIO_C_SET_BUF_MEM_EOF_RETURN:
      nbio->set_eof_return(num);
      break;
    case BIO_CTRL_INFO:
      ret = nbio->Length();
      if (ptr != nullptr)
        *reinterpret_cast<void**>(ptr) = nullptr;
      break;
    case BIO_C_SET_BUF_MEM:
      UNREACHABLE(""Can't use SET_BUF_MEM_PTR with NodeBIO"");
    case BIO_C_GET_BUF_MEM_PTR:
      UNREACHABLE(""Can't use GET_BUF_MEM_PTR with NodeBIO"");
    case BIO_CTRL_GET_CLOSE:
      ret = BIO_get_shutdown(bio);
      break;
    case BIO_CTRL_SET_CLOSE:
      BIO_set_shutdown(bio, num);
      break;
    case BIO_CTRL_WPENDING:
      ret = 0;
      break;
    case BIO_CTRL_PENDING:
      ret = nbio->Length();
      break;
    case BIO_CTRL_DUP:
    case BIO_CTRL_FLUSH:
      ret = 1;
      break;
    case BIO_CTRL_PUSH:
    case BIO_CTRL_POP:
    default:
      ret = 0;
      break;
  }",16,,177,2,,void
20038,BLOCK,-1,,<empty>,9,,190,2,,void
20104,BLOCK,-1,,"{
  // Static initialization ensures that this is safe to use concurrently.
  static const BIO_METHOD* method = [&]() {
    BIO_METHOD* method = BIO_meth_new(BIO_TYPE_MEM, ""node.js SSL buffer"");
    BIO_meth_set_write(method, Write);
    BIO_meth_set_read(method, Read);
    BIO_meth_set_puts(method, Puts);
    BIO_meth_set_gets(method, Gets);
    BIO_meth_set_ctrl(method, Ctrl);
    BIO_meth_set_create(method, New);
    BIO_meth_set_destroy(method, Free);
    return method;
  }();

  return method;
}",40,,222,1,,void
20115,BLOCK,-1,,"{
  // `read_pos_` and `write_pos_` means the position of the reader and writer
  // inside the buffer, respectively. When they're equal - its safe to reset
  // them, because both reader and writer will continue doing their stuff
  // from new (zero) positions.
  while (read_head_->read_pos_ != 0 &&
         read_head_->read_pos_ == read_head_->write_pos_) {
    // Reset positions
    read_head_->read_pos_ = 0;
    read_head_->write_pos_ = 0;

    // Move read_head_ forward, just in case if there're still some data to
    // read in the next buffer.
    if (read_head_ != write_head_)
      read_head_ = read_head_->next_;
  }
}",33,,240,1,,void
20130,BLOCK,-1,,"{
    // Reset positions
    read_head_->read_pos_ = 0;
    read_head_->write_pos_ = 0;

    // Move read_head_ forward, just in case if there're still some data to
    // read in the next buffer.
    if (read_head_ != write_head_)
      read_head_ = read_head_->next_;
  }",59,,246,2,,void
20145,BLOCK,-1,,<empty>,7,,254,2,,void
20156,BLOCK,-1,,"{
  size_t bytes_read = 0;
  size_t expected = Length() > size ? size : Length();
  size_t offset = 0;
  size_t left = size;

  while (bytes_read < expected) {
    CHECK_LE(read_head_->read_pos_, read_head_->write_pos_);
    size_t avail = read_head_->write_pos_ - read_head_->read_pos_;
    if (avail > left)
      avail = left;

    // Copy data
    if (out != nullptr)
      memcpy(out + offset, read_head_->data_ + read_head_->read_pos_, avail);
    read_head_->read_pos_ += avail;

    // Move pointers
    bytes_read += avail;
    offset += avail;
    left -= avail;

    TryMoveReadHead();
  }
  CHECK_EQ(expected, bytes_read);
  length_ -= bytes_read;

  // Free all empty buffers, but write_head's child
  FreeEmpty();

  return bytes_read;
}",46,,259,3,,void
20182,BLOCK,-1,,"{
    CHECK_LE(read_head_->read_pos_, read_head_->write_pos_);
    size_t avail = read_head_->write_pos_ - read_head_->read_pos_;
    if (avail > left)
      avail = left;

    // Copy data
    if (out != nullptr)
      memcpy(out + offset, read_head_->data_ + read_head_->read_pos_, avail);
    read_head_->read_pos_ += avail;

    // Move pointers
    bytes_read += avail;
    offset += avail;
    left -= avail;

    TryMoveReadHead();
  }",33,,265,2,,void
20204,BLOCK,-1,,<empty>,7,,269,2,,void
20212,BLOCK,-1,,<empty>,7,,273,2,,void
20252,BLOCK,-1,,"{
  if (write_head_ == nullptr)
    return;
  Buffer* child = write_head_->next_;
  if (child == write_head_ || child == read_head_)
    return;
  Buffer* cur = child->next_;
  if (cur == write_head_ || cur == read_head_)
    return;

  Buffer* prev = child;
  while (cur != read_head_) {
    CHECK_NE(cur, write_head_);
    CHECK_EQ(cur->write_pos_, cur->read_pos_);

    Buffer* next = cur->next_;
    delete cur;
    cur = next;
  }
  prev->next_ = cur;
}",27,,293,1,,void
20257,BLOCK,-1,,<empty>,5,,295,2,,void
20273,BLOCK,-1,,<empty>,5,,298,2,,void
20289,BLOCK,-1,,<empty>,5,,301,2,,void
20299,BLOCK,-1,,"{
    CHECK_NE(cur, write_head_);
    CHECK_EQ(cur->write_pos_, cur->read_pos_);

    Buffer* next = cur->next_;
    delete cur;
    cur = next;
  }",29,,304,2,,void
20331,BLOCK,-1,,"{
  size_t bytes_read = 0;
  size_t max = Length() > limit ? limit : Length();
  size_t left = limit;
  Buffer* current = read_head_;

  while (bytes_read < max) {
    CHECK_LE(current->read_pos_, current->write_pos_);
    size_t avail = current->write_pos_ - current->read_pos_;
    if (avail > left)
      avail = left;

    // Walk through data
    char* tmp = current->data_ + current->read_pos_;
    size_t off = 0;
    while (off < avail && *tmp != delim) {
      off++;
      tmp++;
    }

    // Move pointers
    bytes_read += off;
    left -= off;

    // Found `delim`
    if (off != avail) {
      return bytes_read;
    }

    // Move to next buffer
    if (current->read_pos_ + avail == current->len_) {
      current = current->next_;
    }
  }
  CHECK_EQ(max, bytes_read);

  return max;
}",51,,316,3,,void
20357,BLOCK,-1,,"{
    CHECK_LE(current->read_pos_, current->write_pos_);
    size_t avail = current->write_pos_ - current->read_pos_;
    if (avail > left)
      avail = left;

    // Walk through data
    char* tmp = current->data_ + current->read_pos_;
    size_t off = 0;
    while (off < avail && *tmp != delim) {
      off++;
      tmp++;
    }

    // Move pointers
    bytes_read += off;
    left -= off;

    // Found `delim`
    if (off != avail) {
      return bytes_read;
    }

    // Move to next buffer
    if (current->read_pos_ + avail == current->len_) {
      current = current->next_;
    }
  }",28,,322,2,,void
20379,BLOCK,-1,,<empty>,7,,326,2,,void
20406,BLOCK,-1,,"{
      off++;
      tmp++;
    }",42,,331,2,,void
20421,BLOCK,-1,,"{
      return bytes_read;
    }",23,,341,2,,void
20434,BLOCK,-1,,"{
      current = current->next_;
    }",54,,346,2,,void
20450,BLOCK,-1,,"{
  size_t offset = 0;
  size_t left = size;

  // Allocate initial buffer if the ring is empty
  TryAllocateForWrite(left);

  while (left > 0) {
    size_t to_write = left;
    CHECK_LE(write_head_->write_pos_, write_head_->len_);
    size_t avail = write_head_->len_ - write_head_->write_pos_;

    if (to_write > avail)
      to_write = avail;

    // Copy data
    memcpy(write_head_->data_ + write_head_->write_pos_,
           data + offset,
           to_write);

    // Move pointers
    left -= to_write;
    offset += to_write;
    length_ += to_write;
    write_head_->write_pos_ += to_write;
    CHECK_LE(write_head_->write_pos_, write_head_->len_);

    // Go to next buffer if there still are some bytes to write
    if (left != 0) {
      CHECK_EQ(write_head_->write_pos_, write_head_->len_);
      TryAllocateForWrite(left);
      write_head_ = write_head_->next_;

      // Additionally, since we're moved to the next buffer, read head
      // may be moved as well.
      TryMov...",52,,356,3,,void
20465,BLOCK,-1,,"{
    size_t to_write = left;
    CHECK_LE(write_head_->write_pos_, write_head_->len_);
    size_t avail = write_head_->len_ - write_head_->write_pos_;

    if (to_write > avail)
      to_write = avail;

    // Copy data
    memcpy(write_head_->data_ + write_head_->write_pos_,
           data + offset,
           to_write);

    // Move pointers
    left -= to_write;
    offset += to_write;
    length_ += to_write;
    write_head_->write_pos_ += to_write;
    CHECK_LE(write_head_->write_pos_, write_head_->len_);

    // Go to next buffer if there still are some bytes to write
    if (left != 0) {
      CHECK_EQ(write_head_->write_pos_, write_head_->len_);
      TryAllocateForWrite(left);
      write_head_ = write_head_->next_;

      // Additionally, since we're moved to the next buffer, read head
      // may be moved as well.
      TryMoveReadHead();
    }
  }",20,,363,2,,void
20491,BLOCK,-1,,<empty>,7,,369,2,,void
20532,BLOCK,-1,,"{
      CHECK_EQ(write_head_->write_pos_, write_head_->len_);
      TryAllocateForWrite(left);
      write_head_ = write_head_->next_;

      // Additionally, since we're moved to the next buffer, read head
      // may be moved as well.
      TryMoveReadHead();
    }",20,,384,2,,void
20555,BLOCK,-1,,"{
  TryAllocateForWrite(*size);

  size_t available = write_head_->len_ - write_head_->write_pos_;
  if (*size == 0 || available <= *size)
    *size = available;

  return write_head_->data_ + write_head_->write_pos_;
}",43,,398,2,,void
20579,BLOCK,-1,,<empty>,5,,403,2,,void
20596,BLOCK,-1,,"{
  write_head_->write_pos_ += size;
  length_ += size;
  CHECK_LE(write_head_->write_pos_, write_head_->len_);

  // Allocate new buffer if write head is full,
  // and there're no other place to go
  TryAllocateForWrite(0);
  if (write_head_->write_pos_ == write_head_->len_) {
    write_head_ = write_head_->next_;

    // Additionally, since we're moved to the next buffer, read head
    // may be moved as well.
    TryMoveReadHead();
  }
}",35,,409,2,,void
20622,BLOCK,-1,,"{
    write_head_ = write_head_->next_;

    // Additionally, since we're moved to the next buffer, read head
    // may be moved as well.
    TryMoveReadHead();
  }",53,,417,2,,void
20633,BLOCK,-1,,"{
  Buffer* w = write_head_;
  Buffer* r = read_head_;
  // If write head is full, next buffer is either read head or not empty.
  if (w == nullptr ||
      (w->write_pos_ == w->len_ &&
       (w->next_ == r || w->next_->write_pos_ != 0))) {
    size_t len = w == nullptr ? initial_ :
                             kThroughputBufferLength;
    if (len < hint)
      len = hint;

    // If there is a one time allocation size hint, use it.
    if (allocate_hint_ > len) {
      len = allocate_hint_;
      allocate_hint_ = 0;
    }

    Buffer* next = new Buffer(env_, len);

    if (w == nullptr) {
      next->next_ = next;
      write_head_ = next;
      read_head_ = next;
    } else {
      next->next_ = w->next_;
      w->next_ = next;
    }
  }
}",48,,427,2,,void
20668,BLOCK,-1,,"{
    size_t len = w == nullptr ? initial_ :
                             kThroughputBufferLength;
    if (len < hint)
      len = hint;

    // If there is a one time allocation size hint, use it.
    if (allocate_hint_ > len) {
      len = allocate_hint_;
      allocate_hint_ = 0;
    }

    Buffer* next = new Buffer(env_, len);

    if (w == nullptr) {
      next->next_ = next;
      write_head_ = next;
      read_head_ = next;
    } else {
      next->next_ = w->next_;
      w->next_ = next;
    }
  }",55,,433,2,,void
20682,BLOCK,-1,,<empty>,7,,437,2,,void
20690,BLOCK,-1,,"{
      len = allocate_hint_;
      allocate_hint_ = 0;
    }",31,,440,2,,void
20708,BLOCK,-1,,"{
      next->next_ = next;
      write_head_ = next;
      read_head_ = next;
    }",23,,447,2,,void
20721,BLOCK,-1,,"{
      next->next_ = w->next_;
      w->next_ = next;
    }",12,,451,1,,void
20737,BLOCK,-1,,"{
  if (read_head_ == nullptr)
    return;

  while (read_head_->read_pos_ != read_head_->write_pos_) {
    CHECK(read_head_->write_pos_ > read_head_->read_pos_);

    length_ -= read_head_->write_pos_ - read_head_->read_pos_;
    read_head_->write_pos_ = 0;
    read_head_->read_pos_ = 0;

    read_head_ = read_head_->next_;
  }
  write_head_ = read_head_;
  CHECK_EQ(length_, 0);
}",23,,459,1,,void
20742,BLOCK,-1,,<empty>,5,,461,2,,void
20752,BLOCK,-1,,"{
    CHECK(read_head_->write_pos_ > read_head_->read_pos_);

    length_ -= read_head_->write_pos_ - read_head_->read_pos_;
    read_head_->write_pos_ = 0;
    read_head_->read_pos_ = 0;

    read_head_ = read_head_->next_;
  }",59,,463,2,,void
20794,BLOCK,-1,,"{
  if (read_head_ == nullptr)
    return;

  Buffer* current = read_head_;
  do {
    Buffer* next = current->next_;
    delete current;
    current = next;
  } while (current != read_head_);

  read_head_ = nullptr;
  write_head_ = nullptr;
}",21,,477,1,,void
20799,BLOCK,-1,,<empty>,5,,479,2,,void
20806,BLOCK,-1,,"{
    Buffer* next = current->next_;
    delete current;
    current = next;
  }",6,,482,1,,void
20831,BLOCK,-1,,"{
  CHECK_NOT_NULL(BIO_get_data(bio));
  return static_cast<NodeBIO*>(BIO_get_data(bio));
}",37,,493,2,,void
20854,BLOCK,-1,,<empty>,1,,1,1,,ANY
20861,BLOCK,-1,,"{
    std::unique_ptr<BackingStore> out;
    Environment* env = Environment::GetCurrent(args);

    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");

    UpdateResult r = cipher->Update(data, size, &out);

    if (r != kSuccess) {
      if (r == kErrorState) {
        ThrowCryptoError(env, ERR_get_error(),
                         ""Trying to add data in unsupported state"");
      }
      return;
    }

    Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(out));
    args.GetReturnValue().Set(
        Buffer::New(env, ab, 0, ab->ByteLength()).FromMaybe(Local<Value>()));
  }",62,,849,5,,void
20882,BLOCK,-1,,<empty>,7,,854,2,,void
20902,BLOCK,-1,,"{
      if (r == kErrorState) {
        ThrowCryptoError(env, ERR_get_error(),
                         ""Trying to add data in unsupported state"");
      }
      return;
    }",24,,858,2,,void
20907,BLOCK,-1,,"{
        ThrowCryptoError(env, ERR_get_error(),
                         ""Trying to add data in unsupported state"");
      }",29,,859,2,,void
20979,BLOCK,-1,,<empty>,1,,1,1,,ANY
20985,BLOCK,-1,,"{
  switch (EVP_CIPHER_mode(cipher)) {
  case EVP_CIPH_CCM_MODE:
  case EVP_CIPH_GCM_MODE:
#ifndef OPENSSL_NO_OCB
  case EVP_CIPH_OCB_MODE:
#endif
    return true;
  case EVP_CIPH_STREAM_CIPHER:
    return EVP_CIPHER_nid(cipher) == NID_chacha20_poly1305;
  default:
    return false;
  }
}",61,,29,2,,void
20989,BLOCK,-1,,"{
  case EVP_CIPH_CCM_MODE:
  case EVP_CIPH_GCM_MODE:
#ifndef OPENSSL_NO_OCB
  case EVP_CIPH_OCB_MODE:
#endif
    return true;
  case EVP_CIPH_STREAM_CIPHER:
    return EVP_CIPHER_nid(cipher) == NID_chacha20_poly1305;
  default:
    return false;
  }",36,,30,2,,void
21012,BLOCK,-1,,"{
  const EVP_CIPHER* cipher = EVP_CIPHER_CTX_cipher(ctx);
  return IsSupportedAuthenticatedMode(cipher);
}",62,,44,2,,void
21025,BLOCK,-1,,"{
  return tag_len == 4 || tag_len == 8 || (tag_len >= 12 && tag_len <= 16);
}",48,,49,2,,void
21046,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsObject());
  Local<Object> info = args[0].As<Object>();

  CHECK(args[1]->IsString() || args[1]->IsInt32());

  const EVP_CIPHER* cipher;
  if (args[1]->IsString()) {
    Utf8Value name(env->isolate(), args[1]);
    cipher = EVP_get_cipherbyname(*name);
  } else {
    int nid = args[1].As<Int32>()->Value();
    cipher = EVP_get_cipherbynid(nid);
  }

  if (cipher == nullptr)
    return;

  int mode = EVP_CIPHER_mode(cipher);
  int iv_length = EVP_CIPHER_iv_length(cipher);
  int key_length = EVP_CIPHER_key_length(cipher);
  int block_length = EVP_CIPHER_block_size(cipher);
  const char* mode_label = nullptr;
  switch (mode) {
    case EVP_CIPH_CBC_MODE: mode_label = ""cbc""; break;
    case EVP_CIPH_CCM_MODE: mode_label = ""ccm""; break;
    case EVP_CIPH_CFB_MODE: mode_label = ""cfb""; break;
    case EVP_CIPH_CTR_MODE: mode_label = ""ctr""; break;
    case EVP_CIPH_ECB_MODE: mode_label = ""ecb""; break;
    case EVP_CIP...",61,,54,2,,void
21096,BLOCK,-1,,"{
    Utf8Value name(env->isolate(), args[1]);
    cipher = EVP_get_cipherbyname(*name);
  }",28,,62,2,,void
21112,BLOCK,-1,,"{
    int nid = args[1].As<Int32>()->Value();
    cipher = EVP_get_cipherbynid(nid);
  }",10,,65,1,,void
21133,BLOCK,-1,,<empty>,5,,71,2,,void
21161,BLOCK,-1,,"{
    case EVP_CIPH_CBC_MODE: mode_label = ""cbc""; break;
    case EVP_CIPH_CCM_MODE: mode_label = ""ccm""; break;
    case EVP_CIPH_CFB_MODE: mode_label = ""cfb""; break;
    case EVP_CIPH_CTR_MODE: mode_label = ""ctr""; break;
    case EVP_CIPH_ECB_MODE: mode_label = ""ecb""; break;
    case EVP_CIPH_GCM_MODE: mode_label = ""gcm""; break;
    case EVP_CIPH_OCB_MODE: mode_label = ""ocb""; break;
    case EVP_CIPH_OFB_MODE: mode_label = ""ofb""; break;
    case EVP_CIPH_WRAP_MODE: mode_label = ""wrap""; break;
    case EVP_CIPH_XTS_MODE: mode_label = ""xts""; break;
    case EVP_CIPH_STREAM_CIPHER: mode_label = ""stream""; break;
  }",17,,78,2,,void
21242,BLOCK,-1,,"{
    // Test and input IV or key length to determine if it's acceptable.
    // If it is, then the getCipherInfo will succeed with the given
    // values.
    CipherCtxPointer ctx(EVP_CIPHER_CTX_new());
    if (!EVP_CipherInit_ex(ctx.get(), cipher, nullptr, nullptr, nullptr, 1))
      return;

    if (args[2]->IsInt32()) {
      int check_len = args[2].As<Int32>()->Value();
      if (!EVP_CIPHER_CTX_set_key_length(ctx.get(), check_len))
        return;
      key_length = check_len;
    }

    if (args[3]->IsInt32()) {
      int check_len = args[3].As<Int32>()->Value();
      // For CCM modes, the IV may be between 7 and 13 bytes.
      // For GCM and OCB modes, we'll check by attempting to
      // set the value. For everything else, just check that
      // check_len == iv_length.
      switch (mode) {
        case EVP_CIPH_CCM_MODE:
          if (check_len < 7 || check_len > 13)
            return;
          break;
        case EVP_CIPH_GCM_MODE:
          // Fall through
      ...",49,,97,2,,void
21258,BLOCK,-1,,<empty>,7,,103,2,,void
21267,BLOCK,-1,,"{
      int check_len = args[2].As<Int32>()->Value();
      if (!EVP_CIPHER_CTX_set_key_length(ctx.get(), check_len))
        return;
      key_length = check_len;
    }",29,,105,2,,void
21288,BLOCK,-1,,<empty>,9,,108,2,,void
21300,BLOCK,-1,,"{
      int check_len = args[3].As<Int32>()->Value();
      // For CCM modes, the IV may be between 7 and 13 bytes.
      // For GCM and OCB modes, we'll check by attempting to
      // set the value. For everything else, just check that
      // check_len == iv_length.
      switch (mode) {
        case EVP_CIPH_CCM_MODE:
          if (check_len < 7 || check_len > 13)
            return;
          break;
        case EVP_CIPH_GCM_MODE:
          // Fall through
        case EVP_CIPH_OCB_MODE:
          if (!EVP_CIPHER_CTX_ctrl(
                  ctx.get(),
                  EVP_CTRL_AEAD_SET_IVLEN,
                  check_len,
                  nullptr)) {
            return;
          }
          break;
        default:
          if (check_len != iv_length)
            return;
      }
      iv_length = check_len;
    }",29,,112,2,,void
21315,BLOCK,-1,,"{
        case EVP_CIPH_CCM_MODE:
          if (check_len < 7 || check_len > 13)
            return;
          break;
        case EVP_CIPH_GCM_MODE:
          // Fall through
        case EVP_CIPH_OCB_MODE:
          if (!EVP_CIPHER_CTX_ctrl(
                  ctx.get(),
                  EVP_CTRL_AEAD_SET_IVLEN,
                  check_len,
                  nullptr)) {
            return;
          }
          break;
        default:
          if (check_len != iv_length)
            return;
      }",21,,118,2,,void
21326,BLOCK,-1,,<empty>,13,,121,2,,void
21343,BLOCK,-1,,"{
            return;
          }",29,,130,2,,void
21351,BLOCK,-1,,<empty>,13,,136,2,,void
21384,BLOCK,-1,,"{
    return;
  }",67,,146,2,,void
21410,BLOCK,-1,,"{
    return;
  }",63,,157,2,,void
21440,BLOCK,-1,,"{
    return;
  }",76,,164,2,,void
21473,BLOCK,-1,,"{
    return;
  }",66,,173,2,,void
21506,BLOCK,-1,,"{
    return;
  }",63,,182,2,,void
21535,BLOCK,-1,,"{
    return;
  }",64,,189,2,,void
21549,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  SSLCtxPointer ctx(SSL_CTX_new(TLS_method()));
  if (!ctx) {
    return ThrowCryptoError(env, ERR_get_error(), ""SSL_CTX_new"");
  }

  SSLPointer ssl(SSL_new(ctx.get()));
  if (!ssl) {
    return ThrowCryptoError(env, ERR_get_error(), ""SSL_new"");
  }

  STACK_OF(SSL_CIPHER)* ciphers = SSL_get_ciphers(ssl.get());

  // TLSv1.3 ciphers aren't listed by EVP. There are only 5, we could just
  // document them, but since there are only 5, easier to just add them manually
  // and not have to explain their absence in the API docs. They are lower-cased
  // because the docs say they will be.
  static const char* TLS13_CIPHERS[] = {
    ""tls_aes_256_gcm_sha384"",
    ""tls_chacha20_poly1305_sha256"",
    ""tls_aes_128_gcm_sha256"",
    ""tls_aes_128_ccm_8_sha256"",
    ""tls_aes_128_ccm_sha256""
  };

  const int n = sk_SSL_CIPHER_num(ciphers);
  std::vector<Local<Value>> arr(n + arraysize(TLS13_CIPHERS));

  for (int i = 0; i < n; ++i) {
    co...",73,,197,2,,void
21560,BLOCK,-1,,<empty>,,,,2,,<empty>
21566,BLOCK,-1,,"{
    return ThrowCryptoError(env, ERR_get_error(), ""SSL_CTX_new"");
  }",13,,201,2,,void
21582,BLOCK,-1,,"{
    return ThrowCryptoError(env, ERR_get_error(), ""SSL_new"");
  }",13,,206,2,,void
21626,BLOCK,-1,,<empty>,3,,227,1,,void
21636,BLOCK,4,,"{
    const SSL_CIPHER* cipher = sk_SSL_CIPHER_value(ciphers, i);
    arr[i] = OneByteString(env->isolate(), SSL_CIPHER_get_name(cipher));
  }",31,,227,4,,void
21655,BLOCK,-1,,<empty>,3,,232,1,,void
21666,BLOCK,4,,"{
    const char* name = TLS13_CIPHERS[i];
    arr[n + i] = OneByteString(env->isolate(), name);
  }",59,,232,4,,void
21712,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  MarkPopErrorOnReturn mark_pop_error_on_return;
  CipherPushContext ctx(env);
  EVP_CIPHER_do_all_sorted(
#if OPENSSL_VERSION_MAJOR >= 3
    array_push_back<EVP_CIPHER,
                    EVP_CIPHER_fetch,
                    EVP_CIPHER_free,
                    EVP_get_cipherbyname,
                    EVP_CIPHER_get0_name>,
#else
    array_push_back<EVP_CIPHER>,
#endif
    &ctx);
  args.GetReturnValue().Set(ctx.ToJSArray());
}",70,,240,2,,void
21746,BLOCK,-1,,"{
  MakeWeak();
}",35,,266,4,,void
21752,BLOCK,-1,,"{
  tracker->TrackFieldWithSize(""context"", ctx_ ? kSizeOf_EVP_CIPHER_CTX : 0);
}",59,,270,2,,void
21767,BLOCK,-1,,"{
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);

  t->InstanceTemplate()->SetInternalFieldCount(CipherBase::kInternalFieldCount);

  SetProtoMethod(isolate, t, ""init"", Init);
  SetProtoMethod(isolate, t, ""initiv"", InitIv);
  SetProtoMethod(isolate, t, ""update"", Update);
  SetProtoMethod(isolate, t, ""final"", Final);
  SetProtoMethod(isolate, t, ""setAutoPadding"", SetAutoPadding);
  SetProtoMethodNoSideEffect(isolate, t, ""getAuthTag"", GetAuthTag);
  SetProtoMethod(isolate, t, ""setAuthTag"", SetAuthTag);
  SetProtoMethod(isolate, t, ""setAAD"", SetAAD);
  SetConstructorFunction(context, target, ""CipherBase"", t);

  SetMethodNoSideEffect(context, target, ""getSSLCiphers"", GetSSLCiphers);
  SetMethodNoSideEffect(context, target, ""getCiphers"", GetCiphers);

  SetMethod(context,
            target,
            ""publicEncrypt"",
            PublicKeyCipher::Cipher<PublicKeyCipher::kPublic,
        ...",69,,274,3,,void
21897,BLOCK,1,,<empty>,,,,7,,void
21899,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kWebCryptoCipherEncrypt)",3,,322,1,,void
21996,BLOCK,1,,<empty>,,,,7,,void
21998,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kWebCryptoCipherDecrypt)",3,,323,1,,void
22094,BLOCK,-1,,"{
  registry->Register(New);

  registry->Register(Init);
  registry->Register(InitIv);
  registry->Register(Update);
  registry->Register(Final);
  registry->Register(SetAutoPadding);
  registry->Register(GetAuthTag);
  registry->Register(SetAuthTag);
  registry->Register(SetAAD);

  registry->Register(GetSSLCiphers);
  registry->Register(GetCiphers);

  registry->Register(PublicKeyCipher::Cipher<PublicKeyCipher::kPublic,
                                             EVP_PKEY_encrypt_init,
                                             EVP_PKEY_encrypt>);
  registry->Register(PublicKeyCipher::Cipher<PublicKeyCipher::kPrivate,
                                             EVP_PKEY_decrypt_init,
                                             EVP_PKEY_decrypt>);
  registry->Register(PublicKeyCipher::Cipher<PublicKeyCipher::kPrivate,
                                             EVP_PKEY_sign_init,
                                             EVP_PKEY_sign>);
  registry->Register(PublicKeyCip...",42,,327,2,,void
22187,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new CipherBase(env, args.This(), args[0]->IsTrue() ? kCipher : kDecipher);
}",63,,358,2,,void
22227,BLOCK,-1,,"{
  CHECK(!ctx_);
  ctx_.reset(EVP_CIPHER_CTX_new());

  const int mode = EVP_CIPHER_mode(cipher);
  if (mode == EVP_CIPH_WRAP_MODE)
    EVP_CIPHER_CTX_set_flags(ctx_.get(), EVP_CIPHER_CTX_FLAG_WRAP_ALLOW);

  const bool encrypt = (kind_ == kCipher);
  if (1 != EVP_CipherInit_ex(ctx_.get(), cipher, nullptr,
                             nullptr, nullptr, encrypt)) {
    return ThrowCryptoError(env(), ERR_get_error(),
                            ""Failed to initialize cipher"");
  }

  if (IsSupportedAuthenticatedMode(cipher)) {
    CHECK_GE(iv_len, 0);
    if (!InitAuthenticated(cipher_type, iv_len, auth_tag_len))
      return;
  }

  if (!EVP_CIPHER_CTX_set_key_length(ctx_.get(), key_len)) {
    ctx_.reset();
    return THROW_ERR_CRYPTO_INVALID_KEYLEN(env());
  }

  if (1 != EVP_CipherInit_ex(ctx_.get(), nullptr, nullptr, key, iv, encrypt)) {
    return ThrowCryptoError(env(), ERR_get_error(),
                            ""Failed to initialize cipher"");
  }
}",56,,370,8,,void
22245,BLOCK,-1,,<empty>,5,,376,2,,void
22271,BLOCK,-1,,"{
    return ThrowCryptoError(env(), ERR_get_error(),
                            ""Failed to initialize cipher"");
  }",58,,380,2,,void
22280,BLOCK,-1,,"{
    CHECK_GE(iv_len, 0);
    if (!InitAuthenticated(cipher_type, iv_len, auth_tag_len))
      return;
  }",45,,385,2,,void
22290,BLOCK,-1,,<empty>,7,,388,2,,void
22300,BLOCK,-1,,"{
    ctx_.reset();
    return THROW_ERR_CRYPTO_INVALID_KEYLEN(env());
  }",60,,391,2,,void
22321,BLOCK,-1,,"{
    return ThrowCryptoError(env(), ERR_get_error(),
                            ""Failed to initialize cipher"");
  }",79,,396,2,,void
22333,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());
  MarkPopErrorOnReturn mark_pop_error_on_return;
#if OPENSSL_VERSION_MAJOR >= 3
  if (EVP_default_properties_is_fips_enabled(nullptr)) {
#else
  if (FIPS_mode()) {
#endif
    return THROW_ERR_CRYPTO_UNSUPPORTED_OPERATION(env(),
        ""crypto.createCipher() is not supported in FIPS mode."");
  }

  const EVP_CIPHER* const cipher = EVP_get_cipherbyname(cipher_type);
  if (cipher == nullptr)
    return THROW_ERR_CRYPTO_UNKNOWN_CIPHER(env());

  unsigned char key[EVP_MAX_KEY_LENGTH];
  unsigned char iv[EVP_MAX_IV_LENGTH];

  int key_len = EVP_BytesToKey(cipher,
                               EVP_md5(),
                               nullptr,
                               key_buf.data(),
                               key_buf.size(),
                               1,
                               key,
                               iv);
  CHECK_NE(key_len, 0);

  const int mode = EVP_CIPHER_mode(cipher);
  if (kind_ == kCipher && (mode == EVP_C...",50,,404,4,,void
22343,BLOCK,-1,,"{
#endif
    return THROW_ERR_CRYPTO_UNSUPPORTED_OPERATION(env(),
        ""crypto.createCipher() is not supported in FIPS mode."");
  }",20,,410,2,,void
22357,BLOCK,-1,,<empty>,5,,418,2,,void
22405,BLOCK,-1,,"{
    // Ignore the return value (i.e. possible exception) because we are
    // not calling back into JS anyway.
    ProcessEmitWarning(env(),
                       ""Use Cipheriv for counter mode of %s"",
                       cipher_type);
  }",56,,436,2,,void
22423,BLOCK,-1,,"{
  CipherBase* cipher;
  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());
  Environment* env = Environment::GetCurrent(args);

  CHECK_GE(args.Length(), 3);

  const Utf8Value cipher_type(args.GetIsolate(), args[0]);
  ArrayBufferOrViewContents<unsigned char> key_buf(args[1]);
  if (!key_buf.CheckSizeInt32())
    return THROW_ERR_OUT_OF_RANGE(env, ""password is too large"");

  // Don't assign to cipher->auth_tag_len_ directly; the value might not
  // represent a valid length at this point.
  unsigned int auth_tag_len;
  if (args[2]->IsUint32()) {
    auth_tag_len = args[2].As<Uint32>()->Value();
  } else {
    CHECK(args[2]->IsInt32() && args[2].As<Int32>()->Value() == -1);
    auth_tag_len = kNoAuthTagLength;
  }

  cipher->Init(*cipher_type, key_buf, auth_tag_len);
}",64,,448,2,,void
22466,BLOCK,-1,,<empty>,5,,458,2,,void
22479,BLOCK,-1,,"{
    auth_tag_len = args[2].As<Uint32>()->Value();
  }",28,,463,2,,void
22492,BLOCK,-1,,"{
    CHECK(args[2]->IsInt32() && args[2].As<Int32>()->Value() == -1);
    auth_tag_len = kNoAuthTagLength;
  }",10,,465,1,,void
22531,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());
  MarkPopErrorOnReturn mark_pop_error_on_return;

  const EVP_CIPHER* const cipher = EVP_get_cipherbyname(cipher_type);
  if (cipher == nullptr)
    return THROW_ERR_CRYPTO_UNKNOWN_CIPHER(env());

  const int expected_iv_len = EVP_CIPHER_iv_length(cipher);
  const bool is_authenticated_mode = IsSupportedAuthenticatedMode(cipher);
  const bool has_iv = iv_buf.size() > 0;

  // Throw if no IV was passed and the cipher requires an IV
  if (!has_iv && expected_iv_len != 0)
    return THROW_ERR_CRYPTO_INVALID_IV(env());

  // Throw if an IV was passed which does not match the cipher's fixed IV length
  // static_cast<int> for the iv_buf.size() is safe because we've verified
  // prior that the value is not larger than INT_MAX.
  if (!is_authenticated_mode &&
      has_iv &&
      static_cast<int>(iv_buf.size()) != expected_iv_len) {
    return THROW_ERR_CRYPTO_INVALID_IV(env());
  }

  if (EVP_CIPHER_nid(cipher) == NID_chacha20_poly1305) {
    CHE...",52,,476,5,,void
22548,BLOCK,-1,,<empty>,5,,482,2,,void
22578,BLOCK,-1,,<empty>,5,,490,2,,void
22596,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_INVALID_IV(env());
  }",59,,497,2,,void
22605,BLOCK,-1,,"{
    CHECK(has_iv);
    // Check for invalid IV lengths, since OpenSSL does not under some
    // conditions:
    //   https://www.openssl.org/news/secadv/20190306.txt.
    if (iv_buf.size() > 12)
      return THROW_ERR_CRYPTO_INVALID_IV(env());
  }",56,,501,2,,void
22615,BLOCK,-1,,<empty>,7,,507,2,,void
22643,BLOCK,-1,,"{
  CipherBase* cipher;
  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());
  Environment* env = cipher->env();

  CHECK_GE(args.Length(), 4);

  const Utf8Value cipher_type(env->isolate(), args[0]);

  // The argument can either be a KeyObjectHandle or a byte source
  // (e.g. ArrayBuffer, TypedArray, etc). Whichever it is, grab the
  // raw bytes and proceed...
  const ByteSource key_buf = ByteSource::FromSecretKeyBytes(env, args[1]);

  if (UNLIKELY(key_buf.size() > INT_MAX))
    return THROW_ERR_OUT_OF_RANGE(env, ""key is too big"");

  ArrayBufferOrViewContents<unsigned char> iv_buf(
      !args[2]->IsNull() ? args[2] : Local<Value>());

  if (UNLIKELY(!iv_buf.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""iv is too big"");

  // Don't assign to cipher->auth_tag_len_ directly; the value might not
  // represent a valid length at this point.
  unsigned int auth_tag_len;
  if (args[3]->IsUint32()) {
    auth_tag_len = args[3].As<Uint32>()->Value();
  } else {
    CHECK(ar...",66,,520,2,,void
22693,BLOCK,-1,,<empty>,5,,535,2,,void
22719,BLOCK,-1,,<empty>,5,,541,2,,void
22732,BLOCK,-1,,"{
    auth_tag_len = args[3].As<Uint32>()->Value();
  }",28,,546,2,,void
22745,BLOCK,-1,,"{
    CHECK(args[3]->IsInt32() && args[3].As<Int32>()->Value() == -1);
    auth_tag_len = kNoAuthTagLength;
  }",10,,548,1,,void
22784,BLOCK,-1,,"{
  CHECK(IsAuthenticatedMode());
  MarkPopErrorOnReturn mark_pop_error_on_return;

  if (!EVP_CIPHER_CTX_ctrl(ctx_.get(),
                           EVP_CTRL_AEAD_SET_IVLEN,
                           iv_len,
                           nullptr)) {
    THROW_ERR_CRYPTO_INVALID_IV(env());
    return false;
  }

  const int mode = EVP_CIPHER_CTX_mode(ctx_.get());
  if (mode == EVP_CIPH_GCM_MODE) {
    if (auth_tag_len != kNoAuthTagLength) {
      if (!IsValidGCMTagLength(auth_tag_len)) {
        THROW_ERR_CRYPTO_INVALID_AUTH_TAG(
          env(),
          ""Invalid authentication tag length: %u"",
          auth_tag_len);
        return false;
      }

      // Remember the given authentication tag length for later.
      auth_tag_len_ = auth_tag_len;
    }
  } else {
    if (auth_tag_len == kNoAuthTagLength) {
      // We treat ChaCha20-Poly1305 specially. Like GCM, the authentication tag
      // length defaults to 16 bytes when encrypting. Unlike GCM, the
      // authentication tag...",32,,559,4,,void
22797,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_IV(env());
    return false;
  }",38,,566,2,,void
22813,BLOCK,-1,,"{
    if (auth_tag_len != kNoAuthTagLength) {
      if (!IsValidGCMTagLength(auth_tag_len)) {
        THROW_ERR_CRYPTO_INVALID_AUTH_TAG(
          env(),
          ""Invalid authentication tag length: %u"",
          auth_tag_len);
        return false;
      }

      // Remember the given authentication tag length for later.
      auth_tag_len_ = auth_tag_len;
    }
  }",34,,572,2,,void
22818,BLOCK,-1,,"{
      if (!IsValidGCMTagLength(auth_tag_len)) {
        THROW_ERR_CRYPTO_INVALID_AUTH_TAG(
          env(),
          ""Invalid authentication tag length: %u"",
          auth_tag_len);
        return false;
      }

      // Remember the given authentication tag length for later.
      auth_tag_len_ = auth_tag_len;
    }",43,,573,2,,void
22823,BLOCK,-1,,"{
        THROW_ERR_CRYPTO_INVALID_AUTH_TAG(
          env(),
          ""Invalid authentication tag length: %u"",
          auth_tag_len);
        return false;
      }",47,,574,2,,void
22834,BLOCK,-1,,"{
    if (auth_tag_len == kNoAuthTagLength) {
      // We treat ChaCha20-Poly1305 specially. Like GCM, the authentication tag
      // length defaults to 16 bytes when encrypting. Unlike GCM, the
      // authentication tag length also defaults to 16 bytes when decrypting,
      // whereas GCM would accept any valid authentication tag length.
      if (EVP_CIPHER_CTX_nid(ctx_.get()) == NID_chacha20_poly1305) {
        auth_tag_len = 16;
      } else {
        THROW_ERR_CRYPTO_INVALID_AUTH_TAG(
          env(), ""authTagLength required for %s"", cipher_type);
        return false;
      }
    }

    // TODO(tniessen) Support CCM decryption in FIPS mode

#if OPENSSL_VERSION_MAJOR >= 3
    if (mode == EVP_CIPH_CCM_MODE && kind_ == kDecipher &&
        EVP_default_properties_is_fips_enabled(nullptr)) {
#else
    if (mode == EVP_CIPH_CCM_MODE && kind_ == kDecipher && FIPS_mode()) {
#endif
      THROW_ERR_CRYPTO_UNSUPPORTED_OPERATION(env(),
          ""CCM encryption not supported in FIPS mo...",10,,585,1,,void
22839,BLOCK,-1,,"{
      // We treat ChaCha20-Poly1305 specially. Like GCM, the authentication tag
      // length defaults to 16 bytes when encrypting. Unlike GCM, the
      // authentication tag length also defaults to 16 bytes when decrypting,
      // whereas GCM would accept any valid authentication tag length.
      if (EVP_CIPHER_CTX_nid(ctx_.get()) == NID_chacha20_poly1305) {
        auth_tag_len = 16;
      } else {
        THROW_ERR_CRYPTO_INVALID_AUTH_TAG(
          env(), ""authTagLength required for %s"", cipher_type);
        return false;
      }
    }",43,,586,2,,void
22848,BLOCK,-1,,"{
        auth_tag_len = 16;
      }",68,,591,2,,void
22853,BLOCK,-1,,"{
        THROW_ERR_CRYPTO_INVALID_AUTH_TAG(
          env(), ""authTagLength required for %s"", cipher_type);
        return false;
      }",14,,593,1,,void
22870,BLOCK,-1,,"{
#endif
      THROW_ERR_CRYPTO_UNSUPPORTED_OPERATION(env(),
          ""CCM encryption not supported in FIPS mode"");
      return false;
    }",73,,606,2,,void
22886,BLOCK,-1,,"{
      THROW_ERR_CRYPTO_INVALID_AUTH_TAG(
          env(), ""Invalid authentication tag length: %u"", auth_tag_len);
      return false;
    }",40,,615,2,,void
22900,BLOCK,-1,,"{
      // Restrict the message length to min(INT_MAX, 2^(8*(15-iv_len))-1) bytes.
      CHECK(iv_len >= 7 && iv_len <= 13);
      max_message_size_ = INT_MAX;
      if (iv_len == 12) max_message_size_ = 16777215;
      if (iv_len == 13) max_message_size_ = 65535;
    }",36,,624,2,,void
22916,BLOCK,-1,,<empty>,25,,628,2,,void
22924,BLOCK,-1,,<empty>,25,,629,2,,void
22934,BLOCK,-1,,"{
  CHECK(ctx_);
  CHECK(EVP_CIPHER_CTX_mode(ctx_.get()) == EVP_CIPH_CCM_MODE);

  if (message_len > max_message_size_) {
    THROW_ERR_CRYPTO_INVALID_MESSAGELEN(env());
    return false;
  }

  return true;
}",57,,636,2,,void
22948,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_MESSAGELEN(env());
    return false;
  }",40,,640,2,,void
22957,BLOCK,-1,,"{
  // Check if this cipher operates in an AEAD mode that we support.
  CHECK(ctx_);
  return IsSupportedAuthenticatedMode(ctx_.get());
}",46,,648,1,,void
22969,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CipherBase* cipher;
  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());

  // Only callable after Final and if encrypting.
  if (cipher->ctx_ ||
      cipher->kind_ != kCipher ||
      cipher->auth_tag_len_ == kNoAuthTagLength) {
    return;
  }

  args.GetReturnValue().Set(
      Buffer::Copy(env, cipher->auth_tag_, cipher->auth_tag_len_)
          .FromMaybe(Local<Value>()));
}",70,,654,2,,void
23002,BLOCK,-1,,"{
    return;
  }",50,,662,2,,void
23030,BLOCK,-1,,"{
  CipherBase* cipher;
  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());
  Environment* env = Environment::GetCurrent(args);

  if (!cipher->ctx_ ||
      !cipher->IsAuthenticatedMode() ||
      cipher->kind_ != kDecipher ||
      cipher->auth_tag_state_ != kAuthTagUnknown) {
    return args.GetReturnValue().Set(false);
  }

  ArrayBufferOrViewContents<char> auth_tag(args[0]);
  if (UNLIKELY(!auth_tag.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""buffer is too big"");

  unsigned int tag_len = auth_tag.size();

  const int mode = EVP_CIPHER_CTX_mode(cipher->ctx_.get());
  bool is_valid;
  if (mode == EVP_CIPH_GCM_MODE) {
    // Restrict GCM tag lengths according to NIST 800-38d, page 9.
    is_valid = (cipher->auth_tag_len_ == kNoAuthTagLength ||
                cipher->auth_tag_len_ == tag_len) &&
               IsValidGCMTagLength(tag_len);
  } else {
    // At this point, the tag length is already known and must match the
    // length of the given authentication ta...",70,,671,2,,void
23070,BLOCK,-1,,"{
    return args.GetReturnValue().Set(false);
  }",51,,679,2,,void
23092,BLOCK,-1,,<empty>,5,,685,2,,void
23119,BLOCK,-1,,"{
    // Restrict GCM tag lengths according to NIST 800-38d, page 9.
    is_valid = (cipher->auth_tag_len_ == kNoAuthTagLength ||
                cipher->auth_tag_len_ == tag_len) &&
               IsValidGCMTagLength(tag_len);
  }",34,,691,2,,void
23137,BLOCK,-1,,"{
    // At this point, the tag length is already known and must match the
    // length of the given authentication tag.
    CHECK(IsSupportedAuthenticatedMode(cipher->ctx_.get()));
    CHECK_NE(cipher->auth_tag_len_, kNoAuthTagLength);
    is_valid = cipher->auth_tag_len_ == tag_len;
  }",10,,696,1,,void
23161,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_INVALID_AUTH_TAG(
      env, ""Invalid authentication tag length: %u"", tag_len);
  }",18,,704,2,,void
23215,BLOCK,-1,,"{
  if (auth_tag_state_ == kAuthTagKnown) {
    if (!EVP_CIPHER_CTX_ctrl(ctx_.get(),
                             EVP_CTRL_AEAD_SET_TAG,
                             auth_tag_len_,
                             reinterpret_cast<unsigned char*>(auth_tag_))) {
      return false;
    }
    auth_tag_state_ = kAuthTagPassedToOpenSSL;
  }
  return true;
}",46,,719,1,,void
23220,BLOCK,-1,,"{
    if (!EVP_CIPHER_CTX_ctrl(ctx_.get(),
                             EVP_CTRL_AEAD_SET_TAG,
                             auth_tag_len_,
                             reinterpret_cast<unsigned char*>(auth_tag_))) {
      return false;
    }
    auth_tag_state_ = kAuthTagPassedToOpenSSL;
  }",41,,720,2,,void
23233,BLOCK,-1,,"{
      return false;
    }",76,,724,2,,void
23246,BLOCK,-1,,"{
  if (!ctx_ || !IsAuthenticatedMode())
    return false;
  MarkPopErrorOnReturn mark_pop_error_on_return;

  int outlen;
  const int mode = EVP_CIPHER_CTX_mode(ctx_.get());

  // When in CCM mode, we need to set the authentication tag and the plaintext
  // length in advance.
  if (mode == EVP_CIPH_CCM_MODE) {
    if (plaintext_len < 0) {
      THROW_ERR_MISSING_ARGS(env(),
          ""options.plaintextLength required for CCM mode with AAD"");
      return false;
    }

    if (!CheckCCMMessageLength(plaintext_len))
      return false;

    if (kind_ == kDecipher) {
      if (!MaybePassAuthTagToOpenSSL())
        return false;
    }

    // Specify the plaintext length.
    if (!EVP_CipherUpdate(ctx_.get(), nullptr, &outlen, nullptr, plaintext_len))
      return false;
  }

  return 1 == EVP_CipherUpdate(ctx_.get(),
                               nullptr,
                               &outlen,
                               data.data(),
                               data.size());
}",24,,734,3,,void
23253,BLOCK,-1,,<empty>,5,,736,2,,void
23270,BLOCK,-1,,"{
    if (plaintext_len < 0) {
      THROW_ERR_MISSING_ARGS(env(),
          ""options.plaintextLength required for CCM mode with AAD"");
      return false;
    }

    if (!CheckCCMMessageLength(plaintext_len))
      return false;

    if (kind_ == kDecipher) {
      if (!MaybePassAuthTagToOpenSSL())
        return false;
    }

    // Specify the plaintext length.
    if (!EVP_CipherUpdate(ctx_.get(), nullptr, &outlen, nullptr, plaintext_len))
      return false;
  }",34,,744,2,,void
23275,BLOCK,-1,,"{
      THROW_ERR_MISSING_ARGS(env(),
          ""options.plaintextLength required for CCM mode with AAD"");
      return false;
    }",28,,745,2,,void
23285,BLOCK,-1,,<empty>,7,,752,2,,void
23292,BLOCK,-1,,"{
      if (!MaybePassAuthTagToOpenSSL())
        return false;
    }",29,,754,2,,void
23296,BLOCK,-1,,<empty>,9,,756,2,,void
23311,BLOCK,-1,,<empty>,7,,761,2,,void
23337,BLOCK,-1,,"{
  CipherBase* cipher;
  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());
  Environment* env = Environment::GetCurrent(args);

  CHECK_EQ(args.Length(), 2);
  CHECK(args[1]->IsInt32());
  int plaintext_len = args[1].As<Int32>()->Value();
  ArrayBufferOrViewContents<unsigned char> buf(args[0]);

  if (UNLIKELY(!buf.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""buffer is too big"");
  args.GetReturnValue().Set(cipher->SetAAD(buf, plaintext_len));
}",66,,771,2,,void
23391,BLOCK,-1,,<empty>,5,,782,2,,void
23415,BLOCK,-1,,"{
  if (!ctx_ || len > INT_MAX)
    return kErrorState;
  MarkPopErrorOnReturn mark_pop_error_on_return;

  const int mode = EVP_CIPHER_CTX_mode(ctx_.get());

  if (mode == EVP_CIPH_CCM_MODE && !CheckCCMMessageLength(len))
    return kErrorMessageSize;

  // Pass the authentication tag to OpenSSL if possible. This will only happen
  // once, usually on the first update.
  if (kind_ == kDecipher && IsAuthenticatedMode())
    CHECK(MaybePassAuthTagToOpenSSL());

  const int block_size = EVP_CIPHER_CTX_block_size(ctx_.get());
  CHECK_GT(block_size, 0);
  if (len + block_size > INT_MAX) return kErrorState;
  int buf_len = len + block_size;

  // For key wrapping algorithms, get output size by calling
  // EVP_CipherUpdate() with null output.
  if (kind_ == kCipher && mode == EVP_CIPH_WRAP_MODE &&
      EVP_CipherUpdate(ctx_.get(),
                       nullptr,
                       &buf_len,
                       reinterpret_cast<const unsigned char*>(data),
                       l...",41,,789,4,,void
23423,BLOCK,-1,,<empty>,5,,791,2,,void
23443,BLOCK,-1,,<empty>,5,,797,2,,void
23452,BLOCK,-1,,<empty>,5,,802,2,,void
23471,BLOCK,-1,,<empty>,35,,806,2,,void
23503,BLOCK,-1,,"{
    return kErrorState;
  }",35,,816,2,,void
23506,BLOCK,14,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env()->isolate_data());
    *out = ArrayBuffer::NewBackingStore(env()->isolate(), buf_len);
  }",3,,820,14,,void
23559,BLOCK,-1,,<empty>,5,,833,2,,void
23573,BLOCK,-1,,<empty>,5,,835,1,,void
23603,BLOCK,-1,,"{
    pending_auth_failed_ = true;
    return kSuccess;
  }",62,,839,2,,void
23619,BLOCK,-1,,"{
  Decode<CipherBase>(args, [](CipherBase* cipher,
                              const FunctionCallbackInfo<Value>& args,
                              const char* data, size_t size) {
    std::unique_ptr<BackingStore> out;
    Environment* env = Environment::GetCurrent(args);

    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");

    UpdateResult r = cipher->Update(data, size, &out);

    if (r != kSuccess) {
      if (r == kErrorState) {
        ThrowCryptoError(env, ERR_get_error(),
                         ""Trying to add data in unsupported state"");
      }
      return;
    }

    Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(out));
    args.GetReturnValue().Set(
        Buffer::New(env, ab, 0, ab->ByteLength()).FromMaybe(Local<Value>()));
  });
}",66,,846,2,,void
23632,BLOCK,-1,,"{
  if (!ctx_)
    return false;
  MarkPopErrorOnReturn mark_pop_error_on_return;
  return EVP_CIPHER_CTX_set_padding(ctx_.get(), auto_padding);
}",52,,872,2,,void
23636,BLOCK,-1,,<empty>,5,,874,2,,void
23651,BLOCK,-1,,"{
  CipherBase* cipher;
  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());

  bool b = cipher->SetAutoPadding(args.Length() < 1 || args[0]->IsTrue());
  args.GetReturnValue().Set(b);  // Possibly report invalid state failure
}",74,,879,2,,void
23692,BLOCK,-1,,"{
  if (!ctx_)
    return false;

  const int mode = EVP_CIPHER_CTX_mode(ctx_.get());

  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env()->isolate_data());
    *out = ArrayBuffer::NewBackingStore(env()->isolate(),
        static_cast<size_t>(EVP_CIPHER_CTX_block_size(ctx_.get())));
  }

  if (kind_ == kDecipher && IsSupportedAuthenticatedMode(ctx_.get()))
    MaybePassAuthTagToOpenSSL();

  // OpenSSL v1.x doesn't verify the presence of the auth tag so do
  // it ourselves, see https://github.com/nodejs/node/issues/45874.
  if (OPENSSL_VERSION_NUMBER < 0x30000000L && kind_ == kDecipher &&
      NID_chacha20_poly1305 == EVP_CIPHER_CTX_nid(ctx_.get()) &&
      auth_tag_state_ != kAuthTagPassedToOpenSSL) {
    return false;
  }

  // In CCM mode, final() only checks whether authentication failed in update().
  // EVP_CipherFinal_ex must not be called and will fail.
  bool ok;
  if (kind_ == kDecipher && mode == EVP_CIPH_CCM_MODE) {
    ok = !pending_auth_failed_;
    *out = Ar...",60,,887,2,,void
23696,BLOCK,-1,,<empty>,5,,889,2,,void
23707,BLOCK,4,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env()->isolate_data());
    *out = ArrayBuffer::NewBackingStore(env()->isolate(),
        static_cast<size_t>(EVP_CIPHER_CTX_block_size(ctx_.get())));
  }",3,,893,4,,void
23742,BLOCK,-1,,<empty>,5,,900,2,,void
23764,BLOCK,-1,,"{
    return false;
  }",51,,906,2,,void
23776,BLOCK,-1,,"{
    ok = !pending_auth_failed_;
    *out = ArrayBuffer::NewBackingStore(env()->isolate(), 0);
  }",56,,913,2,,void
23794,BLOCK,-1,,"{
    int out_len = (*out)->ByteLength();
    ok = EVP_CipherFinal_ex(ctx_.get(),
                            static_cast<unsigned char*>((*out)->Data()),
                            &out_len) == 1;

    CHECK_LE(static_cast<size_t>(out_len), (*out)->ByteLength());
    if (out_len > 0) {
      *out =
        BackingStore::Reallocate(env()->isolate(), std::move(*out), out_len);
    } else {
      *out = ArrayBuffer::NewBackingStore(env()->isolate(), 0);
    }

    if (ok && kind_ == kCipher && IsAuthenticatedMode()) {
      // In GCM mode, the authentication tag length can be specified in advance,
      // but defaults to 16 bytes when encrypting. In CCM and OCB mode, it must
      // always be given by the user.
      if (auth_tag_len_ == kNoAuthTagLength) {
        CHECK(mode == EVP_CIPH_GCM_MODE);
        auth_tag_len_ = sizeof(auth_tag_);
      }
      ok = (1 == EVP_CIPHER_CTX_ctrl(ctx_.get(), EVP_CTRL_AEAD_GET_TAG,
                     auth_tag_len_,
                     reinte...",10,,916,1,,void
23834,BLOCK,-1,,"{
      *out =
        BackingStore::Reallocate(env()->isolate(), std::move(*out), out_len);
    }",22,,923,2,,void
23854,BLOCK,-1,,"{
      *out = ArrayBuffer::NewBackingStore(env()->isolate(), 0);
    }",12,,926,1,,void
23875,BLOCK,-1,,"{
      // In GCM mode, the authentication tag length can be specified in advance,
      // but defaults to 16 bytes when encrypting. In CCM and OCB mode, it must
      // always be given by the user.
      if (auth_tag_len_ == kNoAuthTagLength) {
        CHECK(mode == EVP_CIPH_GCM_MODE);
        auth_tag_len_ = sizeof(auth_tag_);
      }
      ok = (1 == EVP_CIPHER_CTX_ctrl(ctx_.get(), EVP_CTRL_AEAD_GET_TAG,
                     auth_tag_len_,
                     reinterpret_cast<unsigned char*>(auth_tag_)));
    }",58,,930,2,,void
23880,BLOCK,-1,,"{
        CHECK(mode == EVP_CIPH_GCM_MODE);
        auth_tag_len_ = sizeof(auth_tag_);
      }",46,,934,2,,void
23913,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CipherBase* cipher;
  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());
  if (cipher->ctx_ == nullptr)
    return THROW_ERR_CRYPTO_INVALID_STATE(env);

  std::unique_ptr<BackingStore> out;

  // Check IsAuthenticatedMode() first, Final() destroys the EVP_CIPHER_CTX.
  const bool is_auth_mode = cipher->IsAuthenticatedMode();
  bool r = cipher->Final(&out);

  if (!r) {
    const char* msg = is_auth_mode
                          ? ""Unsupported state or unable to authenticate data""
                          : ""Unsupported state"";

    return ThrowCryptoError(env, ERR_get_error(), msg);
  }

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(out));
  args.GetReturnValue().Set(
      Buffer::New(env, ab, 0, ab->ByteLength()).FromMaybe(Local<Value>()));
}",65,,949,2,,void
23936,BLOCK,-1,,<empty>,5,,955,2,,void
23966,BLOCK,-1,,"{
    const char* msg = is_auth_mode
                          ? ""Unsupported state or unable to authenticate data""
                          : ""Unsupported state"";

    return ThrowCryptoError(env, ERR_get_error(), msg);
  }",11,,963,2,,void
24030,BLOCK,-1,,"{
  EVPKeyCtxPointer ctx(EVP_PKEY_CTX_new(pkey.get(), nullptr));
  if (!ctx)
    return false;
  if (EVP_PKEY_cipher_init(ctx.get()) <= 0)
    return false;
  if (EVP_PKEY_CTX_set_rsa_padding(ctx.get(), padding) <= 0)
    return false;

  if (digest != nullptr) {
    if (EVP_PKEY_CTX_set_rsa_oaep_md(ctx.get(), digest) <= 0)
      return false;
  }

  if (!SetRsaOaepLabel(ctx, oaep_label.ToByteSource())) return false;

  size_t out_len = 0;
  if (EVP_PKEY_cipher(
          ctx.get(),
          nullptr,
          &out_len,
          data.data(),
          data.size()) <= 0) {
    return false;
  }

  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    *out = ArrayBuffer::NewBackingStore(env->isolate(), out_len);
  }

  if (EVP_PKEY_cipher(
          ctx.get(),
          static_cast<unsigned char*>((*out)->Data()),
          &out_len,
          data.data(),
          data.size()) <= 0) {
    return false;
  }

  CHECK_LE(out_len, (*out)->ByteLength());
  if (o...",41,,986,8,,void
24042,BLOCK,-1,,<empty>,5,,989,2,,void
24053,BLOCK,-1,,<empty>,5,,991,2,,void
24065,BLOCK,-1,,<empty>,5,,993,2,,void
24072,BLOCK,-1,,"{
    if (EVP_PKEY_CTX_set_rsa_oaep_md(ctx.get(), digest) <= 0)
      return false;
  }",26,,995,2,,void
24082,BLOCK,-1,,<empty>,7,,997,2,,void
24093,BLOCK,-1,,<empty>,57,,1000,2,,void
24119,BLOCK,-1,,"{
    return false;
  }",30,,1008,2,,void
24122,BLOCK,11,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    *out = ArrayBuffer::NewBackingStore(env->isolate(), out_len);
  }",3,,1012,11,,void
24166,BLOCK,-1,,"{
    return false;
  }",30,,1022,2,,void
24180,BLOCK,-1,,<empty>,5,,1028,2,,void
24200,BLOCK,-1,,<empty>,5,,1030,1,,void
24219,BLOCK,-1,,"{
  MarkPopErrorOnReturn mark_pop_error_on_return;
  Environment* env = Environment::GetCurrent(args);

  unsigned int offset = 0;
  ManagedEVPPKey pkey =
      ManagedEVPPKey::GetPublicOrPrivateKeyFromJs(args, &offset);
  if (!pkey)
    return;

  ArrayBufferOrViewContents<unsigned char> buf(args[offset]);
  if (UNLIKELY(!buf.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""buffer is too long"");

  uint32_t padding;
  if (!args[offset + 1]->Uint32Value(env->context()).To(&padding)) return;

  const EVP_MD* digest = nullptr;
  if (args[offset + 2]->IsString()) {
    const Utf8Value oaep_str(env->isolate(), args[offset + 2]);
    digest = EVP_get_digestbyname(*oaep_str);
    if (digest == nullptr)
      return THROW_ERR_OSSL_EVP_INVALID_DIGEST(env);
  }

  ArrayBufferOrViewContents<unsigned char> oaep_label(
      !args[offset + 3]->IsUndefined() ? args[offset + 3] : Local<Value>());
  if (UNLIKELY(!oaep_label.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""oaepL...",71,,1038,2,,void
24246,BLOCK,-1,,<empty>,5,,1046,2,,void
24260,BLOCK,-1,,<empty>,5,,1050,2,,void
24285,BLOCK,-1,,<empty>,68,,1053,2,,void
24300,BLOCK,-1,,"{
    const Utf8Value oaep_str(env->isolate(), args[offset + 2]);
    digest = EVP_get_digestbyname(*oaep_str);
    if (digest == nullptr)
      return THROW_ERR_OSSL_EVP_INVALID_DIGEST(env);
  }",37,,1056,2,,void
24321,BLOCK,-1,,<empty>,7,,1060,2,,void
24350,BLOCK,-1,,<empty>,5,,1066,2,,void
24373,BLOCK,-1,,"{
    return ThrowCryptoError(env, ERR_get_error());
  }",63,,1070,2,,void
24439,BLOCK,-1,,<empty>,1,,1,1,,ANY
24448,BLOCK,-1,,<empty>,1,,1,1,,ANY
24457,BLOCK,-1,,<empty>,1,,1,1,,ANY
24463,BLOCK,-1,,"{
  switch (state_) {
    case kWaiting:
      if (!ParseRecordHeader(data, avail))
        break;
      [[fallthrough]];
    case kTLSHeader:
      ParseHeader(data, avail);
      break;
    case kPaused:
      // Just nop
    case kEnded:
      // Already ended, just ignore it
      break;
    default:
      break;
  }
}",66,,27,3,,void
24466,BLOCK,-1,,"{
    case kWaiting:
      if (!ParseRecordHeader(data, avail))
        break;
      [[fallthrough]];
    case kTLSHeader:
      ParseHeader(data, avail);
      break;
    case kPaused:
      // Just nop
    case kEnded:
      // Already ended, just ignore it
      break;
    default:
      break;
  }",19,,28,2,,void
24474,BLOCK,-1,,<empty>,9,,31,2,,void
24494,BLOCK,-1,,"{
  // >= 5 bytes for header parsing
  if (avail < 5)
    return false;

  if (data[0] == kChangeCipherSpec ||
      data[0] == kAlert ||
      data[0] == kHandshake ||
      data[0] == kApplicationData) {
    frame_len_ = (data[3] << 8) + data[4];
    state_ = kTLSHeader;
    body_offset_ = 5;
  } else {
    End();
    return false;
  }

  // Sanity check (too big frame, or too small)
  // Let OpenSSL handle it
  if (frame_len_ >= kMaxTLSFrameLen) {
    End();
    return false;
  }

  return true;
}",78,,47,3,,void
24499,BLOCK,-1,,<empty>,5,,50,2,,void
24526,BLOCK,-1,,"{
    frame_len_ = (data[3] << 8) + data[4];
    state_ = kTLSHeader;
    body_offset_ = 5;
  }",36,,55,2,,void
24545,BLOCK,-1,,"{
    End();
    return false;
  }",10,,59,1,,void
24553,BLOCK,-1,,"{
    End();
    return false;
  }",38,,66,2,,void
24564,BLOCK,-1,,"{
  ClientHello hello;

  // We need at least six bytes (one byte for kClientHello, three bytes for the
  // length of the handshake message, and two bytes for the protocol version).
  // If the client sent a frame that suggests a smaller ClientHello, give up.
  if (frame_len_ < 6) return End();

  // >= 5 + frame size bytes for frame parsing
  if (body_offset_ + frame_len_ > avail)
    return;

  // Check hello protocol version.  Protocol tuples that we know about:
  //
  // (3,1) TLS v1.0
  // (3,2) TLS v1.1
  // (3,3) TLS v1.2
  //
  // Note that TLS v1.3 uses a TLS v1.2 handshake so requires no specific
  // support here.
  if (data[body_offset_ + 4] != 0x03 ||
      data[body_offset_ + 5] < 0x01 ||
      data[body_offset_ + 5] > 0x03) {
    return End();
  }

  if (data[body_offset_] == kClientHello) {
    if (state_ == kTLSHeader) {
      if (!ParseTLSClientHello(data, avail))
        return End();
    } else {
      // We couldn't get here, but whatever
      return End();
  ...",72,,75,3,,void
24570,BLOCK,-1,,<empty>,23,,81,2,,void
24579,BLOCK,-1,,<empty>,5,,85,2,,void
24605,BLOCK,-1,,"{
    return End();
  }",38,,97,2,,void
24614,BLOCK,-1,,"{
    if (state_ == kTLSHeader) {
      if (!ParseTLSClientHello(data, avail))
        return End();
    } else {
      // We couldn't get here, but whatever
      return End();
    }

    // Check if we overflowed (do not reply with any private data)
    if (session_id_ == nullptr ||
        session_size_ > 32 ||
        session_id_ + session_size_ > data + avail) {
      return End();
    }
  }",43,,101,2,,void
24619,BLOCK,-1,,"{
      if (!ParseTLSClientHello(data, avail))
        return End();
    }",31,,102,2,,void
24625,BLOCK,-1,,<empty>,9,,104,2,,void
24629,BLOCK,-1,,"{
      // We couldn't get here, but whatever
      return End();
    }",12,,105,1,,void
24648,BLOCK,-1,,"{
      return End();
    }",53,,113,2,,void
24696,BLOCK,-1,,"{
  // NOTE: In case of anything we're just returning back, ignoring the problem.
  // That's because we're heavily relying on OpenSSL to solve any problem with
  // incoming data.
  switch (type) {
    case kServerName:
      {
        if (len < 2)
          return;
        uint32_t server_names_len = (data[0] << 8) + data[1];
        if (server_names_len + 2 > len)
          return;
        for (size_t offset = 2; offset < 2 + server_names_len; ) {
          if (offset + 3 > len)
            return;
          uint8_t name_type = data[offset];
          if (name_type != kServernameHostname)
            return;
          uint16_t name_len = (data[offset + 1] << 8) + data[offset + 2];
          offset += 3;
          if (offset + name_len > len)
            return;
          servername_ = data + offset;
          servername_size_ = name_len;
          offset += name_len;
        }
      }
      break;
    case kTLSSessionTicket:
      tls_ticket_size_ = len;
      tls_ticket_ = data ...",52,,130,4,,void
24699,BLOCK,-1,,"{
    case kServerName:
      {
        if (len < 2)
          return;
        uint32_t server_names_len = (data[0] << 8) + data[1];
        if (server_names_len + 2 > len)
          return;
        for (size_t offset = 2; offset < 2 + server_names_len; ) {
          if (offset + 3 > len)
            return;
          uint8_t name_type = data[offset];
          if (name_type != kServernameHostname)
            return;
          uint16_t name_len = (data[offset + 1] << 8) + data[offset + 2];
          offset += 3;
          if (offset + name_len > len)
            return;
          servername_ = data + offset;
          servername_size_ = name_len;
          offset += name_len;
        }
      }
      break;
    case kTLSSessionTicket:
      tls_ticket_size_ = len;
      tls_ticket_ = data + len;
      break;
    default:
      // Ignore
      break;
  }",17,,134,2,,void
24702,BLOCK,3,,"{
        if (len < 2)
          return;
        uint32_t server_names_len = (data[0] << 8) + data[1];
        if (server_names_len + 2 > len)
          return;
        for (size_t offset = 2; offset < 2 + server_names_len; ) {
          if (offset + 3 > len)
            return;
          uint8_t name_type = data[offset];
          if (name_type != kServernameHostname)
            return;
          uint16_t name_len = (data[offset + 1] << 8) + data[offset + 2];
          offset += 3;
          if (offset + name_len > len)
            return;
          servername_ = data + offset;
          servername_size_ = name_len;
          offset += name_len;
        }
      }",7,,136,3,,void
24707,BLOCK,-1,,<empty>,11,,138,2,,void
24727,BLOCK,-1,,<empty>,11,,141,2,,void
24730,BLOCK,-1,,<empty>,9,,142,1,,void
24740,BLOCK,4,,"{
          if (offset + 3 > len)
            return;
          uint8_t name_type = data[offset];
          if (name_type != kServernameHostname)
            return;
          uint16_t name_len = (data[offset + 1] << 8) + data[offset + 2];
          offset += 3;
          if (offset + name_len > len)
            return;
          servername_ = data + offset;
          servername_size_ = name_len;
          offset += name_len;
        }",66,,142,4,,void
24747,BLOCK,-1,,<empty>,13,,144,2,,void
24759,BLOCK,-1,,<empty>,13,,147,2,,void
24786,BLOCK,-1,,<empty>,13,,151,2,,void
24818,BLOCK,-1,,"{
  const uint8_t* body;

  // Skip frame header, hello header, protocol version and random data
  size_t session_offset = body_offset_ + 4 + 2 + 32;

  if (session_offset + 1 >= avail)
    return false;

  body = data + session_offset;
  session_size_ = *body;
  session_id_ = body + 1;

  size_t cipher_offset = session_offset + 1 + session_size_;

  // Session OOB failure
  if (cipher_offset + 1 >= avail)
    return false;

  uint16_t cipher_len =
      (data[cipher_offset] << 8) + data[cipher_offset + 1];
  size_t comp_offset = cipher_offset + 2 + cipher_len;

  // Cipher OOB failure
  if (comp_offset >= avail)
    return false;

  uint8_t comp_len = data[comp_offset];
  size_t extension_offset = comp_offset + 1 + comp_len;

  // Compression OOB failure
  if (extension_offset > avail)
    return false;

  // No extensions present
  if (extension_offset == avail)
    return true;

  size_t ext_off = extension_offset + 2;

  // Parse known extensions
  while (ext_off < avail) {
    ...",80,,169,3,,void
24836,BLOCK,-1,,<empty>,5,,176,2,,void
24867,BLOCK,-1,,<empty>,5,,186,2,,void
24896,BLOCK,-1,,<empty>,5,,194,2,,void
24917,BLOCK,-1,,<empty>,5,,201,2,,void
24924,BLOCK,-1,,<empty>,5,,205,2,,void
24937,BLOCK,-1,,"{
    // Extension OOB
    if (ext_off + 4 > avail)
      return false;

    uint16_t ext_type = (data[ext_off] << 8) + data[ext_off + 1];
    uint16_t ext_len = (data[ext_off + 2] << 8) + data[ext_off + 3];
    ext_off += 4;

    // Extension OOB
    if (ext_off + ext_len > avail)
      return false;

    ParseExtension(ext_type,
                   data + ext_off,
                   ext_len);

    ext_off += ext_len;
  }",27,,210,2,,void
24944,BLOCK,-1,,<empty>,7,,213,2,,void
24986,BLOCK,-1,,<empty>,7,,221,2,,void
25002,BLOCK,-1,,<empty>,5,,232,2,,void
25017,BLOCK,-1,,<empty>,1,,1,1,,ANY
25020,BLOCK,-1,,{ OPENSSL_free(value_str); },46,,999,1,,void
25070,BLOCK,-1,,<empty>,1,,1,1,,ANY
25098,BLOCK,-1,,"{
  X509_STORE* store = SSL_CTX_get_cert_store(ctx);
  DeleteFnPtr<X509_STORE_CTX, X509_STORE_CTX_free> store_ctx(
      X509_STORE_CTX_new());
  X509Pointer result;
  X509* issuer;
  if (store_ctx.get() != nullptr &&
      X509_STORE_CTX_init(store_ctx.get(), store, nullptr, nullptr) == 1 &&
      X509_STORE_CTX_get1_issuer(&issuer, store_ctx.get(), cert) == 1) {
    result.reset(issuer);
  }
  return result;
}",58,,54,3,,void
25143,BLOCK,-1,,"{
    result.reset(issuer);
  }",72,,62,2,,void
25158,BLOCK,-1,,"{
  auto keylog_cb = SSL_CTX_get_keylog_callback(SSL_get_SSL_CTX(ssl.get()));
  // All supported versions of TLS/SSL fix the client random to the same size.
  constexpr size_t kTlsClientRandomSize = SSL3_RANDOM_SIZE;
  unsigned char crandom[kTlsClientRandomSize];

  if (keylog_cb == nullptr ||
      SSL_get_client_random(ssl.get(), crandom, kTlsClientRandomSize) !=
          kTlsClientRandomSize) {
    return;
  }

  std::string line = name;
  line += "" "" + StringBytes::hex_encode(reinterpret_cast<const char*>(crandom),
                                        kTlsClientRandomSize);
  line += "" "" + StringBytes::hex_encode(
      reinterpret_cast<const char*>(secret), secretlen);
  keylog_cb(ssl.get(), line.c_str());
}",23,,72,5,,void
25187,BLOCK,-1,,"{
    return;
  }",33,,80,2,,void
25232,BLOCK,-1,,"{
  const unsigned char* resp;
  int len = SSL_get_tlsext_status_ocsp_resp(ssl, &resp);
  if (resp == nullptr)
    return default_value;

  Local<Value> ret;
  MaybeLocal<Object> maybe_buffer =
      Buffer::Copy(env, reinterpret_cast<const char*>(resp), len);

  if (!maybe_buffer.ToLocal(&ret))
    return MaybeLocal<Value>();

  return ret;
}",33,,95,4,,void
25245,BLOCK,-1,,<empty>,5,,99,2,,void
25276,BLOCK,-1,,<empty>,5,,106,2,,void
25286,BLOCK,-1,,"{
  return session != nullptr && SSL_set_session(ssl.get(), session.get()) == 1;
}",39,,113,3,,void
25308,BLOCK,-1,,"{
  return SSLSessionPointer(d2i_SSL_SESSION(nullptr, &buf, length));
}",74,,117,3,,void
25321,BLOCK,-1,,"{  // NOLINT(runtime/int)
  long err = def;  // NOLINT(runtime/int)
  if (X509* peer_cert = SSL_get_peer_certificate(ssl.get())) {
    X509_free(peer_cert);
    err = SSL_get_verify_result(ssl.get());
  } else {
    const SSL_CIPHER* curr_cipher = SSL_get_current_cipher(ssl.get());
    const SSL_SESSION* sess = SSL_get_session(ssl.get());
    // Allow no-cert for PSK authentication in TLS1.2 and lower.
    // In TLS1.3 check that session was reused because TLS1.3 PSK
    // looks like session resumption.
    if (SSL_CIPHER_get_auth_nid(curr_cipher) == NID_auth_psk ||
        (SSL_SESSION_get_protocol_version(sess) == TLS1_3_VERSION &&
         SSL_session_reused(ssl.get()))) {
      return X509_V_OK;
    }
  }
  return err;
}",15,,123,3,,void
25327,BLOCK,-1,,<empty>,7,,125,1,,void
25336,BLOCK,-1,,"{
    X509_free(peer_cert);
    err = SSL_get_verify_result(ssl.get());
  }",62,,125,2,,void
25347,BLOCK,-1,,"{
    const SSL_CIPHER* curr_cipher = SSL_get_current_cipher(ssl.get());
    const SSL_SESSION* sess = SSL_get_session(ssl.get());
    // Allow no-cert for PSK authentication in TLS1.2 and lower.
    // In TLS1.3 check that session was reused because TLS1.3 PSK
    // looks like session resumption.
    if (SSL_CIPHER_get_auth_nid(curr_cipher) == NID_auth_psk ||
        (SSL_SESSION_get_protocol_version(sess) == TLS1_3_VERSION &&
         SSL_session_reused(ssl.get()))) {
      return X509_V_OK;
    }
  }",10,,128,1,,void
25380,BLOCK,-1,,"{
      return X509_V_OK;
    }",42,,136,2,,void
25390,BLOCK,-1,,"{
  SSL_CTX* ctx = context->ctx().get();
  X509* x509 = SSL_CTX_get0_certificate(ctx);
  EVP_PKEY* pkey = SSL_CTX_get0_privatekey(ctx);
  STACK_OF(X509)* chain;

  int err = SSL_CTX_get0_chain_certs(ctx, &chain);
  if (err == 1) err = SSL_use_certificate(ssl.get(), x509);
  if (err == 1) err = SSL_use_PrivateKey(ssl.get(), pkey);
  if (err == 1 && chain != nullptr) err = SSL_set1_chain(ssl.get(), chain);
  return err == 1;
}",66,,144,3,,void
25426,BLOCK,-1,,<empty>,17,,151,2,,void
25439,BLOCK,-1,,<empty>,17,,152,2,,void
25456,BLOCK,-1,,<empty>,37,,153,2,,void
25473,BLOCK,-1,,"{
  const unsigned char* buf;
  size_t len;
  size_t rem;

  if (!SSL_client_hello_get0_ext(
          ssl.get(),
          TLSEXT_TYPE_application_layer_protocol_negotiation,
          &buf,
          &rem) ||
      rem < 2) {
    return nullptr;
  }

  len = (buf[0] << 8) | buf[1];
  if (len + 2 != rem) return nullptr;
  return reinterpret_cast<const char*>(buf + 3);
}",55,,157,2,,void
25493,BLOCK,-1,,"{
    return nullptr;
  }",16,,167,2,,void
25513,BLOCK,-1,,<empty>,23,,172,2,,void
25526,BLOCK,-1,,"{
  const unsigned char* buf;
  size_t len;
  size_t rem;

  if (!SSL_client_hello_get0_ext(
          ssl.get(),
          TLSEXT_TYPE_server_name,
          &buf,
          &rem) || rem <= 2) {
    return nullptr;
  }

  len = (*buf << 8) | *(buf + 1);
  if (len + 2 != rem)
    return nullptr;
  rem = len;

  if (rem == 0 || *(buf + 2) != TLSEXT_NAMETYPE_host_name) return nullptr;
  rem--;
  if (rem <= 2)
    return nullptr;
  len = (*(buf + 3) << 8) | *(buf + 4);
  if (len + 2 > rem)
    return nullptr;
  return reinterpret_cast<const char*>(buf + 5);
}",61,,176,2,,void
25546,BLOCK,-1,,"{
    return nullptr;
  }",30,,185,2,,void
25566,BLOCK,-1,,<empty>,5,,191,2,,void
25583,BLOCK,-1,,<empty>,60,,194,2,,void
25592,BLOCK,-1,,<empty>,5,,197,2,,void
25614,BLOCK,-1,,<empty>,5,,200,2,,void
25627,BLOCK,-1,,"{
  return SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name);
}",37,,204,2,,void
25637,BLOCK,-1,,"{
  return SSL_CTX_set1_groups_list(sc->ctx().get(), groups) == 1;
}",55,,208,3,,void
25654,BLOCK,-1,,"{  // NOLINT(runtime/int)
  const char* code = ""UNSPECIFIED"";
#define CASE_X509_ERR(CODE) case X509_V_ERR_##CODE: code = #CODE; break;
  switch (err) {
    // if you modify anything in here, *please* update the respective section in
    // doc/api/tls.md as well
    CASE_X509_ERR(UNABLE_TO_GET_ISSUER_CERT)
    CASE_X509_ERR(UNABLE_TO_GET_CRL)
    CASE_X509_ERR(UNABLE_TO_DECRYPT_CERT_SIGNATURE)
    CASE_X509_ERR(UNABLE_TO_DECRYPT_CRL_SIGNATURE)
    CASE_X509_ERR(UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY)
    CASE_X509_ERR(CERT_SIGNATURE_FAILURE)
    CASE_X509_ERR(CRL_SIGNATURE_FAILURE)
    CASE_X509_ERR(CERT_NOT_YET_VALID)
    CASE_X509_ERR(CERT_HAS_EXPIRED)
    CASE_X509_ERR(CRL_NOT_YET_VALID)
    CASE_X509_ERR(CRL_HAS_EXPIRED)
    CASE_X509_ERR(ERROR_IN_CERT_NOT_BEFORE_FIELD)
    CASE_X509_ERR(ERROR_IN_CERT_NOT_AFTER_FIELD)
    CASE_X509_ERR(ERROR_IN_CRL_LAST_UPDATE_FIELD)
    CASE_X509_ERR(ERROR_IN_CRL_NEXT_UPDATE_FIELD)
    CASE_X509_ERR(OUT_OF_MEM)
    CASE_X509_ERR(DEPTH_ZERO_SELF_SIG...",37,,212,2,,void
25661,BLOCK,-1,,"{
    // if you modify anything in here, *please* update the respective section in
    // doc/api/tls.md as well
    CASE_X509_ERR(UNABLE_TO_GET_ISSUER_CERT)
    CASE_X509_ERR(UNABLE_TO_GET_CRL)
    CASE_X509_ERR(UNABLE_TO_DECRYPT_CERT_SIGNATURE)
    CASE_X509_ERR(UNABLE_TO_DECRYPT_CRL_SIGNATURE)
    CASE_X509_ERR(UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY)
    CASE_X509_ERR(CERT_SIGNATURE_FAILURE)
    CASE_X509_ERR(CRL_SIGNATURE_FAILURE)
    CASE_X509_ERR(CERT_NOT_YET_VALID)
    CASE_X509_ERR(CERT_HAS_EXPIRED)
    CASE_X509_ERR(CRL_NOT_YET_VALID)
    CASE_X509_ERR(CRL_HAS_EXPIRED)
    CASE_X509_ERR(ERROR_IN_CERT_NOT_BEFORE_FIELD)
    CASE_X509_ERR(ERROR_IN_CERT_NOT_AFTER_FIELD)
    CASE_X509_ERR(ERROR_IN_CRL_LAST_UPDATE_FIELD)
    CASE_X509_ERR(ERROR_IN_CRL_NEXT_UPDATE_FIELD)
    CASE_X509_ERR(OUT_OF_MEM)
    CASE_X509_ERR(DEPTH_ZERO_SELF_SIGNED_CERT)
    CASE_X509_ERR(SELF_SIGNED_CERT_IN_CHAIN)
    CASE_X509_ERR(UNABLE_TO_GET_ISSUER_CERT_LOCALLY)
    CASE_X509_ERR(UNABLE_TO_VERIFY_LEAF_SI...",16,,215,2,,void
25663,BLOCK,1,,<empty>,,,,1,,void
25671,BLOCK,1,,<empty>,,,,1,,void
25679,BLOCK,1,,<empty>,,,,1,,void
25687,BLOCK,1,,<empty>,,,,1,,void
25695,BLOCK,1,,<empty>,,,,1,,void
25703,BLOCK,1,,<empty>,,,,1,,void
25711,BLOCK,1,,<empty>,,,,1,,void
25719,BLOCK,1,,<empty>,,,,1,,void
25727,BLOCK,1,,<empty>,,,,1,,void
25735,BLOCK,1,,<empty>,,,,1,,void
25743,BLOCK,1,,<empty>,,,,1,,void
25751,BLOCK,1,,<empty>,,,,1,,void
25759,BLOCK,1,,<empty>,,,,1,,void
25767,BLOCK,1,,<empty>,,,,1,,void
25775,BLOCK,1,,<empty>,,,,1,,void
25783,BLOCK,1,,<empty>,,,,1,,void
25791,BLOCK,1,,<empty>,,,,1,,void
25799,BLOCK,1,,<empty>,,,,1,,void
25807,BLOCK,1,,<empty>,,,,1,,void
25815,BLOCK,1,,<empty>,,,,1,,void
25823,BLOCK,1,,<empty>,,,,1,,void
25831,BLOCK,1,,<empty>,,,,1,,void
25839,BLOCK,1,,<empty>,,,,1,,void
25847,BLOCK,1,,<empty>,,,,1,,void
25855,BLOCK,1,,<empty>,,,,1,,void
25863,BLOCK,1,,<empty>,,,,1,,void
25871,BLOCK,1,,<empty>,,,,1,,void
25879,BLOCK,1,,<empty>,,,,1,,void
25893,BLOCK,-1,,"{
  if (err == 0)
    return Undefined(env->isolate());
  const char* reason = X509_verify_cert_error_string(err);
  return OneByteString(env->isolate(), reason);
}",71,,251,3,,void
25898,BLOCK,-1,,<empty>,5,,253,2,,void
25922,BLOCK,-1,,"{
  if (err == 0)
    return Undefined(env->isolate());
  return OneByteString(env->isolate(), X509ErrorCode(err));
}",69,,258,3,,void
25927,BLOCK,-1,,<empty>,5,,260,2,,void
25947,BLOCK,-1,,"{
  ClearErrorOnReturn clear_error_on_return;
  X509* cert = SSL_get_certificate(ssl.get());
  if (cert == nullptr)
    return Undefined(env->isolate());

  MaybeLocal<Object> maybe_cert = X509ToObject(env, cert);
  return maybe_cert.FromMaybe<Value>(Local<Value>());
}",68,,264,3,,void
25961,BLOCK,-1,,<empty>,5,,268,2,,void
25990,BLOCK,-1,,"{
  BUF_MEM* mem;
  BIO_get_mem_ptr(bio.get(), &mem);
  MaybeLocal<String> ret =
      String::NewFromUtf8(
          env->isolate(),
          mem->data,
          NewStringType::kNormal,
          mem->length);
  CHECK_EQ(BIO_reset(bio.get()), 1);
  return ret.FromMaybe(Local<Value>());
}",65,,274,3,,void
26043,BLOCK,-1,,"{
  Local<Value> value;
  if (!maybe_value.ToLocal(&value))
    return false;

  // Undefined is ignored, but still considered successful
  if (value->IsUndefined())
    return true;

  return !target->Set(context, name, value).IsNothing();
}",32,,293,5,,void
26057,BLOCK,-1,,<empty>,5,,296,2,,void
26065,BLOCK,-1,,<empty>,5,,300,2,,void
26085,BLOCK,-1,,"{
  if (cipher == nullptr)
    return Undefined(env->isolate());

  return OneByteString(env->isolate(), getstr(cipher));
}",78,,306,3,,void
26090,BLOCK,-1,,<empty>,5,,308,2,,void
26125,BLOCK,-1,,"{
  Local<Context> context = env->isolate()->GetCurrentContext();
  cert->reset(sk_X509_delete(peer_certs.get(), 0));
  for (;;) {
    int i;
    for (i = 0; i < sk_X509_num(peer_certs.get()); i++) {
      X509* ca = sk_X509_value(peer_certs.get(), i);
      if (X509_check_issued(ca, cert->get()) != X509_V_OK)
        continue;

      Local<Object> ca_info;
      MaybeLocal<Object> maybe_ca_info = X509ToObject(env, ca);
      if (!maybe_ca_info.ToLocal(&ca_info))
        return MaybeLocal<Object>();

      if (!Set<Object>(context, object, env->issuercert_string(), ca_info))
        return MaybeLocal<Object>();
      object = ca_info;

      // NOTE: Intentionally freeing cert that is not used anymore.
      // Delete cert and continue aggregating issuers.
      cert->reset(sk_X509_delete(peer_certs.get(), i));
      break;
    }

    // Issuer not found, break out of the loop.
    if (i == sk_X509_num(peer_certs.get()))
      break;
  }
  return MaybeLocal<Object>(object);
}",29,,337,5,,void
26150,BLOCK,-1,,<empty>,3,,340,1,,void
26151,BLOCK,4,,"{
    int i;
    for (i = 0; i < sk_X509_num(peer_certs.get()); i++) {
      X509* ca = sk_X509_value(peer_certs.get(), i);
      if (X509_check_issued(ca, cert->get()) != X509_V_OK)
        continue;

      Local<Object> ca_info;
      MaybeLocal<Object> maybe_ca_info = X509ToObject(env, ca);
      if (!maybe_ca_info.ToLocal(&ca_info))
        return MaybeLocal<Object>();

      if (!Set<Object>(context, object, env->issuercert_string(), ca_info))
        return MaybeLocal<Object>();
      object = ca_info;

      // NOTE: Intentionally freeing cert that is not used anymore.
      // Delete cert and continue aggregating issuers.
      cert->reset(sk_X509_delete(peer_certs.get(), i));
      break;
    }

    // Issuer not found, break out of the loop.
    if (i == sk_X509_num(peer_certs.get()))
      break;
  }",12,,340,4,,void
26154,BLOCK,-1,,<empty>,5,,342,1,,void
26167,BLOCK,4,,"{
      X509* ca = sk_X509_value(peer_certs.get(), i);
      if (X509_check_issued(ca, cert->get()) != X509_V_OK)
        continue;

      Local<Object> ca_info;
      MaybeLocal<Object> maybe_ca_info = X509ToObject(env, ca);
      if (!maybe_ca_info.ToLocal(&ca_info))
        return MaybeLocal<Object>();

      if (!Set<Object>(context, object, env->issuercert_string(), ca_info))
        return MaybeLocal<Object>();
      object = ca_info;

      // NOTE: Intentionally freeing cert that is not used anymore.
      // Delete cert and continue aggregating issuers.
      cert->reset(sk_X509_delete(peer_certs.get(), i));
      break;
    }",57,,342,4,,void
26186,BLOCK,-1,,<empty>,9,,345,2,,void
26210,BLOCK,-1,,<empty>,9,,350,2,,void
26223,BLOCK,-1,,<empty>,9,,353,2,,void
26248,BLOCK,-1,,<empty>,7,,364,2,,void
26263,BLOCK,-1,,"{
  Local<Context> context = env->isolate()->GetCurrentContext();
  while (X509_check_issued(cert->get(), cert->get()) != X509_V_OK) {
    X509Pointer ca;
    if (!(ca = SSL_CTX_get_issuer(SSL_get_SSL_CTX(ssl.get()), cert->get())))
      break;

    Local<Object> ca_info;
    MaybeLocal<Object> maybe_ca_info = X509ToObject(env, ca.get());
    if (!maybe_ca_info.ToLocal(&ca_info))
      return MaybeLocal<Object>();

    if (!Set<Object>(context, issuer_chain, env->issuercert_string(), ca_info))
      return MaybeLocal<Object>();
    issuer_chain = ca_info;

    // For self-signed certificates whose keyUsage field does not include
    // keyCertSign, X509_check_issued() will return false. Avoid going into an
    // infinite loop by checking if SSL_CTX_get_issuer() returned the same
    // certificate.
    if (cert->get() == ca.get()) break;

    // Delete previous cert and continue aggregating issuers.
    *cert = std::move(ca);
  }
  return MaybeLocal<Object>(issuer_chain);
}",29,,373,5,,void
26289,BLOCK,-1,,"{
    X509Pointer ca;
    if (!(ca = SSL_CTX_get_issuer(SSL_get_SSL_CTX(ssl.get()), cert->get())))
      break;

    Local<Object> ca_info;
    MaybeLocal<Object> maybe_ca_info = X509ToObject(env, ca.get());
    if (!maybe_ca_info.ToLocal(&ca_info))
      return MaybeLocal<Object>();

    if (!Set<Object>(context, issuer_chain, env->issuercert_string(), ca_info))
      return MaybeLocal<Object>();
    issuer_chain = ca_info;

    // For self-signed certificates whose keyUsage field does not include
    // keyCertSign, X509_check_issued() will return false. Avoid going into an
    // infinite loop by checking if SSL_CTX_get_issuer() returned the same
    // certificate.
    if (cert->get() == ca.get()) break;

    // Delete previous cert and continue aggregating issuers.
    *cert = std::move(ca);
  }",68,,375,2,,void
26305,BLOCK,-1,,<empty>,7,,378,2,,void
26332,BLOCK,-1,,<empty>,7,,383,2,,void
26345,BLOCK,-1,,<empty>,7,,386,2,,void
26361,BLOCK,-1,,<empty>,34,,393,2,,void
26383,BLOCK,-1,,"{
  unsigned int i;
  const char hex[] = ""0123456789ABCDEF"";

  for (i = 0; i < md_size; i++) {
    fingerprint[3*i] = hex[(md[i] & 0xf0) >> 4];
    fingerprint[(3*i)+1] = hex[(md[i] & 0x0f)];
    fingerprint[(3*i)+2] = ':';
  }

  DCHECK_GT(md_size, 0);
  fingerprint[(3 * (md_size - 1)) + 2] = '\0';
}",44,,404,4,,void
26390,BLOCK,-1,,<empty>,3,,408,1,,void
26399,BLOCK,4,,"{
    fingerprint[3*i] = hex[(md[i] & 0xf0) >> 4];
    fingerprint[(3*i)+1] = hex[(md[i] & 0x0f)];
    fingerprint[(3*i)+2] = ':';
  }",33,,408,4,,void
26458,BLOCK,-1,,"{
  const char* name = nid2string(nid);
  return name != nullptr ?
      MaybeLocal<Value>(OneByteString(env->isolate(), name)) :
      MaybeLocal<Value>(Undefined(env->isolate()));
}",65,,419,3,,void
26494,BLOCK,-1,,"{
  const EC_POINT* pubkey = EC_KEY_get0_public_key(ec.get());
  if (pubkey == nullptr)
    return Undefined(env->isolate());

  return ECPointToBuffer(
      env,
      group,
      pubkey,
      EC_KEY_get_conv_form(ec.get()),
      nullptr).FromMaybe(Local<Object>());
}",26,,429,4,,void
26507,BLOCK,-1,,<empty>,5,,432,2,,void
26535,BLOCK,-1,,"{
  if (group == nullptr)
    return Undefined(env->isolate());

  int bits = EC_GROUP_order_bits(group);
  if (bits <= 0)
    return Undefined(env->isolate());

  return Integer::New(env->isolate(), bits);
}",26,,445,4,,void
26540,BLOCK,-1,,<empty>,5,,447,2,,void
26556,BLOCK,-1,,<empty>,5,,451,2,,void
26578,BLOCK,-1,,"{
  int size = i2d_RSA_PUBKEY(rsa.get(), nullptr);
  CHECK_GE(size, 0);

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), size);
  }

  unsigned char* serialized = reinterpret_cast<unsigned char*>(bs->Data());
  CHECK_GE(i2d_RSA_PUBKEY(rsa.get(), &serialized), 0);

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  return Buffer::New(env, ab, 0, ab->ByteLength()).FromMaybe(Local<Object>());
}",71,,456,3,,void
26598,BLOCK,5,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), size);
  }",3,,461,5,,void
26675,BLOCK,-1,,"{
  uint64_t exponent_word = static_cast<uint64_t>(BN_get_word(e));
  BIO_printf(bio.get(), ""0x%"" PRIx64, exponent_word);
  return ToV8Value(env, bio);
}",22,,476,4,,void
26693,BLOCK,-1,,"{
  return Integer::New(env->isolate(), BN_num_bits(n));
}",57,,482,3,,void
26711,BLOCK,-1,,"{
  BN_print(bio.get(), n);
  return ToV8Value(env, bio);
}",22,,489,4,,void
26727,BLOCK,-1,,"{
  int size = i2d_X509(cert, nullptr);

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), size);
  }

  unsigned char* serialized = reinterpret_cast<unsigned char*>(bs->Data());
  CHECK_GE(i2d_X509(cert, &serialized), 0);

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  return Buffer::New(env, ab, 0, ab->ByteLength()).FromMaybe(Local<Object>());
}",71,,495,3,,void
26741,BLOCK,4,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), size);
  }",3,,499,4,,void
26814,BLOCK,-1,,"{
  if (ASN1_INTEGER* serial_number = X509_get_serialNumber(cert)) {
    BignumPointer bn(ASN1_INTEGER_to_BN(serial_number, nullptr));
    if (bn) {
      char* data = BN_bn2hex(bn.get());
      ByteSource buf = ByteSource::Allocated(data, strlen(data));
      if (buf) return OneByteString(env->isolate(), buf.data<unsigned char>());
    }
  }

  return Undefined(env->isolate());
}",65,,511,3,,void
26816,BLOCK,-1,,<empty>,7,,512,1,,void
26822,BLOCK,-1,,"{
    BignumPointer bn(ASN1_INTEGER_to_BN(serial_number, nullptr));
    if (bn) {
      char* data = BN_bn2hex(bn.get());
      ByteSource buf = ByteSource::Allocated(data, strlen(data));
      if (buf) return OneByteString(env->isolate(), buf.data<unsigned char>());
    }
  }",66,,512,2,,void
26830,BLOCK,-1,,"{
      char* data = BN_bn2hex(bn.get());
      ByteSource buf = ByteSource::Allocated(data, strlen(data));
      if (buf) return OneByteString(env->isolate(), buf.data<unsigned char>());
    }",13,,514,2,,void
26851,BLOCK,-1,,<empty>,16,,517,2,,void
26873,BLOCK,-1,,"{
  StackOfASN1 eku(static_cast<STACK_OF(ASN1_OBJECT)*>(
      X509_get_ext_d2i(cert, NID_ext_key_usage, nullptr, nullptr)));
  if (eku) {
    const int count = sk_ASN1_OBJECT_num(eku.get());
    MaybeStackBuffer<Local<Value>, 16> ext_key_usage(count);
    char buf[256];

    int j = 0;
    for (int i = 0; i < count; i++) {
      if (OBJ_obj2txt(buf,
                      sizeof(buf),
                      sk_ASN1_OBJECT_value(eku.get(), i), 1) >= 0) {
        ext_key_usage[j++] = OneByteString(env->isolate(), buf);
      }
    }

    return Array::New(env->isolate(), ext_key_usage.out(), count);
  }

  return Undefined(env->isolate());
}",61,,524,3,,void
26879,BLOCK,-1,,"{
    const int count = sk_ASN1_OBJECT_num(eku.get());
    MaybeStackBuffer<Local<Value>, 16> ext_key_usage(count);
    char buf[256];

    int j = 0;
    for (int i = 0; i < count; i++) {
      if (OBJ_obj2txt(buf,
                      sizeof(buf),
                      sk_ASN1_OBJECT_value(eku.get(), i), 1) >= 0) {
        ext_key_usage[j++] = OneByteString(env->isolate(), buf);
      }
    }

    return Array::New(env->isolate(), ext_key_usage.out(), count);
  }",12,,527,2,,void
26897,BLOCK,-1,,<empty>,5,,533,1,,void
26907,BLOCK,4,,"{
      if (OBJ_obj2txt(buf,
                      sizeof(buf),
                      sk_ASN1_OBJECT_value(eku.get(), i), 1) >= 0) {
        ext_key_usage[j++] = OneByteString(env->isolate(), buf);
      }
    }",37,,533,4,,void
26922,BLOCK,-1,,"{
        ext_key_usage[j++] = OneByteString(env->isolate(), buf);
      }",68,,536,2,,void
26959,BLOCK,-1,,"{
  return GetCipherName(env, SSL_get_current_cipher(ssl.get()));
}",63,,548,3,,void
26973,BLOCK,-1,,"{
  return GetCipherVersion(env, SSL_get_current_cipher(ssl.get()));
}",66,,553,3,,void
26988,BLOCK,-1,,"{
  unsigned char md[EVP_MAX_MD_SIZE];
  unsigned int md_size;
  char fingerprint[EVP_MAX_MD_SIZE * 3];

  if (X509_digest(cert, method, md, &md_size)) {
    AddFingerprintDigest(md, md_size, fingerprint);
    return OneByteString(env->isolate(), fingerprint);
  }
  return Undefined(env->isolate());
}",17,,560,4,,void
26999,BLOCK,-1,,"{
    AddFingerprintDigest(md, md_size, fingerprint);
    return OneByteString(env->isolate(), fingerprint);
  }",48,,565,2,,void
27023,BLOCK,-1,,"{
  ASN1_TIME_print(bio.get(), X509_get0_notAfter(cert));
  return ToV8Value(env, bio);
}",28,,575,4,,void
27041,BLOCK,-1,,"{
  ASN1_TIME_print(bio.get(), X509_get0_notBefore(cert));
  return ToV8Value(env, bio);
}",28,,583,4,,void
27059,BLOCK,-1,,"{
  for (size_t i = 0; i < length; i++) {
    char c = name[i];
    switch (c) {
    case '""':
    case '\\':
      // These mess with encoding rules.
      // Fall through.
    case ',':
      // Commas make it impossible to split the list of subject alternative
      // names unambiguously, which is why we have to escape.
      // Fall through.
    case '\'':
      // Single quotes are unlikely to appear in any legitimate values, but they
      // could be used to make a value look like it was escaped (i.e., enclosed
      // in single/double quotes).
      return false;
    default:
      if (utf8) {
        // In UTF8 strings, we require escaping for any ASCII control character,
        // but NOT for non-ASCII characters. Note that all bytes of any code
        // point that consists of more than a single byte have their MSB set.
        if (static_cast<unsigned char>(c) < ' ' || c == '\x7f') {
          return false;
        }
      } else {
        // Check if the char is a c...",78,,588,4,,void
27061,BLOCK,-1,,<empty>,3,,589,1,,void
27071,BLOCK,4,,"{
    char c = name[i];
    switch (c) {
    case '""':
    case '\\':
      // These mess with encoding rules.
      // Fall through.
    case ',':
      // Commas make it impossible to split the list of subject alternative
      // names unambiguously, which is why we have to escape.
      // Fall through.
    case '\'':
      // Single quotes are unlikely to appear in any legitimate values, but they
      // could be used to make a value look like it was escaped (i.e., enclosed
      // in single/double quotes).
      return false;
    default:
      if (utf8) {
        // In UTF8 strings, we require escaping for any ASCII control character,
        // but NOT for non-ASCII characters. Note that all bytes of any code
        // point that consists of more than a single byte have their MSB set.
        if (static_cast<unsigned char>(c) < ' ' || c == '\x7f') {
          return false;
        }
      } else {
        // Check if the char is a control character or non-ASCII character....",39,,589,4,,void
27080,BLOCK,-1,,"{
    case '""':
    case '\\':
      // These mess with encoding rules.
      // Fall through.
    case ',':
      // Commas make it impossible to split the list of subject alternative
      // names unambiguously, which is why we have to escape.
      // Fall through.
    case '\'':
      // Single quotes are unlikely to appear in any legitimate values, but they
      // could be used to make a value look like it was escaped (i.e., enclosed
      // in single/double quotes).
      return false;
    default:
      if (utf8) {
        // In UTF8 strings, we require escaping for any ASCII control character,
        // but NOT for non-ASCII characters. Note that all bytes of any code
        // point that consists of more than a single byte have their MSB set.
        if (static_cast<unsigned char>(c) < ' ' || c == '\x7f') {
          return false;
        }
      } else {
        // Check if the char is a control character or non-ASCII character. Note
        // that char may or may n...",16,,591,2,,void
27094,BLOCK,-1,,"{
        // In UTF8 strings, we require escaping for any ASCII control character,
        // but NOT for non-ASCII characters. Note that all bytes of any code
        // point that consists of more than a single byte have their MSB set.
        if (static_cast<unsigned char>(c) < ' ' || c == '\x7f') {
          return false;
        }
      }",17,,606,2,,void
27105,BLOCK,-1,,"{
          return false;
        }",65,,610,2,,void
27109,BLOCK,-1,,"{
        // Check if the char is a control character or non-ASCII character. Note
        // that char may or may not be a signed type. Regardless, non-ASCII
        // values will always be outside of this range.
        if (c < ' ' || c > '~') {
          return false;
        }
      }",14,,613,1,,void
27118,BLOCK,-1,,"{
          return false;
        }",33,,617,2,,void
27131,BLOCK,-1,,"{
  if (IsSafeAltName(name, length, utf8)) {
    // For backward-compatibility, append ""safe"" names without any
    // modifications.
    if (safe_prefix != nullptr) {
      BIO_printf(out.get(), ""%s:"", safe_prefix);
    }
    BIO_write(out.get(), name, length);
  } else {
    // If a name is not ""safe"", we cannot embed it without special
    // encoding. This does not usually happen, but we don't want to hide
    // it from the user either. We use JSON compatible escaping here.
    BIO_write(out.get(), ""\"""", 1);
    if (safe_prefix != nullptr) {
      BIO_printf(out.get(), ""%s:"", safe_prefix);
    }
    for (size_t j = 0; j < length; j++) {
      char c = static_cast<char>(name[j]);
      if (c == '\\') {
        BIO_write(out.get(), ""\\\\"", 2);
      } else if (c == '""') {
        BIO_write(out.get(), ""\\\"""", 2);
      } else if ((c >= ' ' && c != ',' && c <= '~') || (utf8 && (c & 0x80))) {
        // Note that the above condition explicitly excludes commas, which means
        //...",58,,628,6,,void
27137,BLOCK,-1,,"{
    // For backward-compatibility, append ""safe"" names without any
    // modifications.
    if (safe_prefix != nullptr) {
      BIO_printf(out.get(), ""%s:"", safe_prefix);
    }
    BIO_write(out.get(), name, length);
  }",42,,629,2,,void
27142,BLOCK,-1,,"{
      BIO_printf(out.get(), ""%s:"", safe_prefix);
    }",33,,632,2,,void
27158,BLOCK,-1,,"{
    // If a name is not ""safe"", we cannot embed it without special
    // encoding. This does not usually happen, but we don't want to hide
    // it from the user either. We use JSON compatible escaping here.
    BIO_write(out.get(), ""\"""", 1);
    if (safe_prefix != nullptr) {
      BIO_printf(out.get(), ""%s:"", safe_prefix);
    }
    for (size_t j = 0; j < length; j++) {
      char c = static_cast<char>(name[j]);
      if (c == '\\') {
        BIO_write(out.get(), ""\\\\"", 2);
      } else if (c == '""') {
        BIO_write(out.get(), ""\\\"""", 2);
      } else if ((c >= ' ' && c != ',' && c <= '~') || (utf8 && (c & 0x80))) {
        // Note that the above condition explicitly excludes commas, which means
        // that those are encoded as Unicode escape sequences in the ""else""
        // block. That is not strictly necessary, and Node.js itself would parse
        // it correctly either way. We only do this to account for third-party
        // code that might be splitting the st...",10,,636,1,,void
27170,BLOCK,-1,,"{
      BIO_printf(out.get(), ""%s:"", safe_prefix);
    }",33,,641,2,,void
27179,BLOCK,-1,,<empty>,5,,644,1,,void
27189,BLOCK,4,,"{
      char c = static_cast<char>(name[j]);
      if (c == '\\') {
        BIO_write(out.get(), ""\\\\"", 2);
      } else if (c == '""') {
        BIO_write(out.get(), ""\\\"""", 2);
      } else if ((c >= ' ' && c != ',' && c <= '~') || (utf8 && (c & 0x80))) {
        // Note that the above condition explicitly excludes commas, which means
        // that those are encoded as Unicode escape sequences in the ""else""
        // block. That is not strictly necessary, and Node.js itself would parse
        // it correctly either way. We only do this to account for third-party
        // code that might be splitting the string at commas (as Node.js itself
        // used to do).
        BIO_write(out.get(), &c, 1);
      } else {
        // Control character or non-ASCII character. We treat everything as
        // Latin-1, which corresponds to the first 255 Unicode code points.
        const char hex[] = ""0123456789abcdef"";
        char u[] = { '\\', 'u', '0', '0', hex[(c & 0xf0) >> 4], hex...",41,,644,4,,void
27202,BLOCK,-1,,"{
        BIO_write(out.get(), ""\\\\"", 2);
      }",22,,646,2,,void
27211,BLOCK,-1,,<empty>,14,,648,1,,void
27216,BLOCK,-1,,"{
        BIO_write(out.get(), ""\\\"""", 2);
      }",28,,648,2,,void
27225,BLOCK,-1,,<empty>,14,,650,1,,void
27244,BLOCK,-1,,"{
        // Note that the above condition explicitly excludes commas, which means
        // that those are encoded as Unicode escape sequences in the ""else""
        // block. That is not strictly necessary, and Node.js itself would parse
        // it correctly either way. We only do this to account for third-party
        // code that might be splitting the string at commas (as Node.js itself
        // used to do).
        BIO_write(out.get(), &c, 1);
      }",78,,650,2,,void
27254,BLOCK,-1,,"{
        // Control character or non-ASCII character. We treat everything as
        // Latin-1, which corresponds to the first 255 Unicode code points.
        const char hex[] = ""0123456789abcdef"";
        char u[] = { '\\', 'u', '0', '0', hex[(c & 0xf0) >> 4], hex[c & 0x0f] };
        BIO_write(out.get(), u, sizeof(u));
      }",14,,658,1,,void
27300,BLOCK,-1,,"{
  PrintAltName(out, reinterpret_cast<const char*>(name->data), name->length,
               false, safe_prefix);
}",74,,672,4,,void
27319,BLOCK,-1,,"{
  PrintAltName(out, reinterpret_cast<const char*>(name->data), name->length,
               true, safe_prefix);
}",72,,679,4,,void
27337,BLOCK,-1,,"{
  if (gen->type == GEN_DNS) {
    ASN1_IA5STRING* name = gen->d.dNSName;
    BIO_write(out.get(), ""DNS:"", 4);
    // Note that the preferred name syntax (see RFCs 5280 and 1034) with
    // wildcards is a subset of what we consider ""safe"", so spec-compliant DNS
    // names will never need to be escaped.
    PrintLatin1AltName(out, name);
  } else if (gen->type == GEN_EMAIL) {
    ASN1_IA5STRING* name = gen->d.rfc822Name;
    BIO_write(out.get(), ""email:"", 6);
    PrintLatin1AltName(out, name);
  } else if (gen->type == GEN_URI) {
    ASN1_IA5STRING* name = gen->d.uniformResourceIdentifier;
    BIO_write(out.get(), ""URI:"", 4);
    // The set of ""safe"" names was designed to include just about any URI,
    // with a few exceptions, most notably URIs that contains commas (see
    // RFC 2396). In other words, most legitimate URIs will not require
    // escaping.
    PrintLatin1AltName(out, name);
  } else if (gen->type == GEN_DIRNAME) {
    // Earlier versions of Node.js used X509_N...",78,,686,3,,void
27344,BLOCK,-1,,"{
    ASN1_IA5STRING* name = gen->d.dNSName;
    BIO_write(out.get(), ""DNS:"", 4);
    // Note that the preferred name syntax (see RFCs 5280 and 1034) with
    // wildcards is a subset of what we consider ""safe"", so spec-compliant DNS
    // names will never need to be escaped.
    PrintLatin1AltName(out, name);
  }",29,,687,2,,void
27364,BLOCK,-1,,<empty>,10,,694,1,,void
27371,BLOCK,-1,,"{
    ASN1_IA5STRING* name = gen->d.rfc822Name;
    BIO_write(out.get(), ""email:"", 6);
    PrintLatin1AltName(out, name);
  }",38,,694,2,,void
27391,BLOCK,-1,,<empty>,10,,698,1,,void
27398,BLOCK,-1,,"{
    ASN1_IA5STRING* name = gen->d.uniformResourceIdentifier;
    BIO_write(out.get(), ""URI:"", 4);
    // The set of ""safe"" names was designed to include just about any URI,
    // with a few exceptions, most notably URIs that contains commas (see
    // RFC 2396). In other words, most legitimate URIs will not require
    // escaping.
    PrintLatin1AltName(out, name);
  }",36,,698,2,,void
27418,BLOCK,-1,,<empty>,10,,706,1,,void
27425,BLOCK,-1,,"{
    // Earlier versions of Node.js used X509_NAME_oneline to print the X509_NAME
    // object. The format was non standard and should be avoided. The use of
    // X509_NAME_oneline is discouraged by OpenSSL but was required for backward
    // compatibility. Conveniently, X509_NAME_oneline produced ASCII and the
    // output was unlikely to contains commas or other characters that would
    // require escaping. However, it SHOULD NOT produce ASCII output since an
    // RFC5280 AttributeValue may be a UTF8String.
    // Newer versions of Node.js have since switched to X509_NAME_print_ex to
    // produce a better format at the cost of backward compatibility. The new
    // format may contain Unicode characters and it is likely to contain commas,
    // which require escaping. Fortunately, the recently safeguarded function
    // PrintAltName handles all of that safely.
    BIO_printf(out.get(), ""DirName:"");
    BIOPointer tmp(BIO_new(BIO_s_mem()));
    CHECK(tmp);
    if (X509_...",40,,706,2,,void
27434,BLOCK,-1,,<empty>,,,,2,,<empty>
27454,BLOCK,-1,,"{
      return false;
    }",70,,725,2,,void
27490,BLOCK,-1,,<empty>,10,,733,1,,void
27497,BLOCK,-1,,"{
    BIO_printf(out.get(), ""IP Address:"");
    const ASN1_OCTET_STRING* ip = gen->d.ip;
    const unsigned char* b = ip->data;
    if (ip->length == 4) {
      BIO_printf(out.get(), ""%d.%d.%d.%d"", b[0], b[1], b[2], b[3]);
    } else if (ip->length == 16) {
      for (unsigned int j = 0; j < 8; j++) {
        uint16_t pair = (b[2 * j] << 8) | b[2 * j + 1];
        BIO_printf(out.get(), (j == 0) ? ""%X"" : "":%X"", pair);
      }
    } else {
#if OPENSSL_VERSION_MAJOR >= 3
      BIO_printf(out.get(), ""<invalid length=%d>"", ip->length);
#else
      BIO_printf(out.get(), ""<invalid>"");
#endif
    }
  }",38,,733,2,,void
27524,BLOCK,-1,,"{
      BIO_printf(out.get(), ""%d.%d.%d.%d"", b[0], b[1], b[2], b[3]);
    }",26,,737,2,,void
27544,BLOCK,-1,,<empty>,12,,739,1,,void
27551,BLOCK,-1,,"{
      for (unsigned int j = 0; j < 8; j++) {
        uint16_t pair = (b[2 * j] << 8) | b[2 * j + 1];
        BIO_printf(out.get(), (j == 0) ? ""%X"" : "":%X"", pair);
      }
    }",34,,739,2,,void
27553,BLOCK,-1,,<empty>,7,,740,1,,void
27563,BLOCK,4,,"{
        uint16_t pair = (b[2 * j] << 8) | b[2 * j + 1];
        BIO_printf(out.get(), (j == 0) ? ""%X"" : "":%X"", pair);
      }",44,,740,4,,void
27595,BLOCK,-1,,"{
#if OPENSSL_VERSION_MAJOR >= 3
      BIO_printf(out.get(), ""<invalid length=%d>"", ip->length);
#else
      BIO_printf(out.get(), ""<invalid>"");
#endif
    }",12,,744,1,,void
27603,BLOCK,-1,,<empty>,10,,751,1,,void
27610,BLOCK,-1,,"{
    // Unlike OpenSSL's default implementation, never print the OID as text and
    // instead always print its numeric representation.
    char oline[256];
    OBJ_obj2txt(oline, sizeof(oline), gen->d.rid, true);
    BIO_printf(out.get(), ""Registered ID:%s"", oline);
  }",36,,751,2,,void
27630,BLOCK,-1,,<empty>,10,,757,1,,void
27637,BLOCK,-1,,"{
    // The format that is used here is based on OpenSSL's implementation of
    // GENERAL_NAME_print (as of OpenSSL 3.0.1). Earlier versions of Node.js
    // instead produced the same format as i2v_GENERAL_NAME, which was somewhat
    // awkward, especially when passed to translatePeerCertificate.
    bool unicode = true;
    const char* prefix = nullptr;
    // OpenSSL 1.1.1 does not support othername in GENERAL_NAME_print and may
    // not define these NIDs.
#if OPENSSL_VERSION_MAJOR >= 3
    int nid = OBJ_obj2nid(gen->d.otherName->type_id);
    switch (nid) {
      case NID_id_on_SmtpUTF8Mailbox:
        prefix = ""SmtpUTF8Mailbox"";
        break;
      case NID_XmppAddr:
        prefix = ""XmppAddr"";
        break;
      case NID_SRVName:
        prefix = ""SRVName"";
        unicode = false;
        break;
      case NID_ms_upn:
        prefix = ""UPN"";
        break;
      case NID_NAIRealm:
        prefix = ""NAIRealm"";
        break;
    }
#endif  // OPENSSL_VERSION_MAJOR >= ...",42,,757,2,,void
27675,BLOCK,-1,,"{
      BIO_printf(out.get(), ""othername:<unsupported>"");
    }",53,,790,2,,void
27683,BLOCK,-1,,"{
      BIO_printf(out.get(), ""othername:"");
      if (unicode) {
        PrintUtf8AltName(out, gen->d.otherName->value->value.utf8string,
                         prefix);
      } else {
        PrintLatin1AltName(out, gen->d.otherName->value->value.ia5string,
                           prefix);
      }
    }",12,,792,1,,void
27692,BLOCK,-1,,"{
        PrintUtf8AltName(out, gen->d.otherName->value->value.utf8string,
                         prefix);
      }",20,,794,2,,void
27708,BLOCK,-1,,"{
        PrintLatin1AltName(out, gen->d.otherName->value->value.ia5string,
                           prefix);
      }",14,,797,1,,void
27724,BLOCK,-1,,<empty>,10,,802,1,,void
27731,BLOCK,-1,,"{
    // TODO(tniessen): this is what OpenSSL does, implement properly instead
    BIO_printf(out.get(), ""X400Name:<unsupported>"");
  }",37,,802,2,,void
27739,BLOCK,-1,,<empty>,10,,805,1,,void
27746,BLOCK,-1,,"{
    // TODO(tniessen): this is what OpenSSL does, implement properly instead
    BIO_printf(out.get(), ""EdiPartyName:<unsupported>"");
  }",41,,805,2,,void
27754,BLOCK,-1,,"{
    // This is safe because X509V3_EXT_d2i would have returned nullptr in this
    // case already.
    UNREACHABLE();
  }",10,,808,1,,void
27763,BLOCK,-1,,"{
  const X509V3_EXT_METHOD* method = X509V3_EXT_get(ext);
  CHECK(method == X509V3_EXT_get_nid(NID_subject_alt_name));

  GENERAL_NAMES* names = static_cast<GENERAL_NAMES*>(X509V3_EXT_d2i(ext));
  if (names == nullptr)
    return false;

  bool ok = true;

  for (int i = 0; i < sk_GENERAL_NAME_num(names); i++) {
    GENERAL_NAME* gen = sk_GENERAL_NAME_value(names, i);

    if (i != 0)
      BIO_write(out.get(), "", "", 2);

    if (!(ok = PrintGeneralName(out, gen))) {
      break;
    }
  }
  sk_GENERAL_NAME_pop_free(names, GENERAL_NAME_free);

  return ok;
}",78,,817,3,,void
27785,BLOCK,-1,,<empty>,5,,823,2,,void
27793,BLOCK,-1,,<empty>,3,,827,1,,void
27804,BLOCK,4,,"{
    GENERAL_NAME* gen = sk_GENERAL_NAME_value(names, i);

    if (i != 0)
      BIO_write(out.get(), "", "", 2);

    if (!(ok = PrintGeneralName(out, gen))) {
      break;
    }
  }",56,,827,4,,void
27815,BLOCK,-1,,<empty>,7,,831,2,,void
27830,BLOCK,-1,,"{
      break;
    }",45,,833,2,,void
27842,BLOCK,-1,,"{
  const X509V3_EXT_METHOD* method = X509V3_EXT_get(ext);
  CHECK(method == X509V3_EXT_get_nid(NID_info_access));

  AUTHORITY_INFO_ACCESS* descs =
      static_cast<AUTHORITY_INFO_ACCESS*>(X509V3_EXT_d2i(ext));
  if (descs == nullptr)
    return false;

  bool ok = true;

  for (int i = 0; i < sk_ACCESS_DESCRIPTION_num(descs); i++) {
    ACCESS_DESCRIPTION* desc = sk_ACCESS_DESCRIPTION_value(descs, i);

    if (i != 0)
      BIO_write(out.get(), ""\n"", 1);

    char objtmp[80];
    i2t_ASN1_OBJECT(objtmp, sizeof(objtmp), desc->method);
    BIO_printf(out.get(), ""%s - "", objtmp);
    if (!(ok = PrintGeneralName(out, desc->location))) {
      break;
    }
  }
  sk_ACCESS_DESCRIPTION_pop_free(descs, ACCESS_DESCRIPTION_free);

#if OPENSSL_VERSION_MAJOR < 3
  BIO_write(out.get(), ""\n"", 1);
#endif

  return ok;
}",74,,842,3,,void
27864,BLOCK,-1,,<empty>,5,,849,2,,void
27872,BLOCK,-1,,<empty>,3,,853,1,,void
27883,BLOCK,4,,"{
    ACCESS_DESCRIPTION* desc = sk_ACCESS_DESCRIPTION_value(descs, i);

    if (i != 0)
      BIO_write(out.get(), ""\n"", 1);

    char objtmp[80];
    i2t_ASN1_OBJECT(objtmp, sizeof(objtmp), desc->method);
    BIO_printf(out.get(), ""%s - "", objtmp);
    if (!(ok = PrintGeneralName(out, desc->location))) {
      break;
    }
  }",62,,853,4,,void
27894,BLOCK,-1,,<empty>,7,,857,2,,void
27926,BLOCK,-1,,"{
      break;
    }",56,,862,2,,void
27946,BLOCK,-1,,"{
  int index = X509_get_ext_by_NID(cert, NID_subject_alt_name, -1);
  if (index < 0)
    return Undefined(env->isolate());

  X509_EXTENSION* ext = X509_get_ext(cert, index);
  CHECK_NOT_NULL(ext);

  if (!SafeX509SubjectAltNamePrint(bio, ext)) {
    CHECK_EQ(BIO_reset(bio.get()), 1);
    return v8::Null(env->isolate());
  }

  return ToV8Value(env, bio);
}",17,,878,4,,void
27959,BLOCK,-1,,<empty>,5,,881,2,,void
27979,BLOCK,-1,,"{
    CHECK_EQ(BIO_reset(bio.get()), 1);
    return v8::Null(env->isolate());
  }",47,,886,2,,void
28006,BLOCK,-1,,"{
  int index = X509_get_ext_by_NID(cert, NID_info_access, -1);
  if (index < 0)
    return Undefined(env->isolate());

  X509_EXTENSION* ext = X509_get_ext(cert, index);
  CHECK_NOT_NULL(ext);

  if (!SafeX509InfoAccessPrint(bio, ext)) {
    CHECK_EQ(BIO_reset(bio.get()), 1);
    return v8::Null(env->isolate());
  }

  return ToV8Value(env, bio);
}",17,,897,4,,void
28019,BLOCK,-1,,<empty>,5,,900,2,,void
28039,BLOCK,-1,,"{
    CHECK_EQ(BIO_reset(bio.get()), 1);
    return v8::Null(env->isolate());
  }",43,,905,2,,void
28066,BLOCK,-1,,"{
  X509_NAME* issuer_name = X509_get_issuer_name(cert);
  if (X509_NAME_print_ex(
          bio.get(),
          issuer_name,
          0,
          kX509NameFlagsMultiline) <= 0) {
    CHECK_EQ(BIO_reset(bio.get()), 1);
    return Undefined(env->isolate());
  }

  return ToV8Value(env, bio);
}",17,,916,4,,void
28083,BLOCK,-1,,"{
    CHECK_EQ(BIO_reset(bio.get()), 1);
    return Undefined(env->isolate());
  }",42,,922,2,,void
28107,BLOCK,-1,,"{
  if (X509_NAME_print_ex(
          bio.get(),
          X509_get_subject_name(cert),
          0,
          kX509NameFlagsMultiline) <= 0) {
    CHECK_EQ(BIO_reset(bio.get()), 1);
    return Undefined(env->isolate());
  }

  return ToV8Value(env, bio);
}",17,,933,4,,void
28120,BLOCK,-1,,"{
    CHECK_EQ(BIO_reset(bio.get()), 1);
    return Undefined(env->isolate());
  }",42,,938,2,,void
28143,BLOCK,-1,,"{
  X509_NAME* name = get_name(cert);
  CHECK_NOT_NULL(name);

  int cnt = X509_NAME_entry_count(name);
  CHECK_GE(cnt, 0);

  Local<Object> result =
      Object::New(env->isolate(), Null(env->isolate()), nullptr, nullptr, 0);
  if (result.IsEmpty()) {
    return MaybeLocal<Value>();
  }

  for (int i = 0; i < cnt; i++) {
    X509_NAME_ENTRY* entry = X509_NAME_get_entry(name, i);
    CHECK_NOT_NULL(entry);

    // We intentionally ignore the value of X509_NAME_ENTRY_set because the
    // representation as an object does not allow grouping entries into sets
    // anyway, and multi-value RDNs are rare, i.e., the vast majority of
    // Relative Distinguished Names contains a single type-value pair only.
    const ASN1_OBJECT* type = X509_NAME_ENTRY_get_object(entry);
    const ASN1_STRING* value = X509_NAME_ENTRY_get_data(entry);

    // If OpenSSL knows the type, use the short name of the type as the key, and
    // the numeric representation of the type's OID otherwise.
    int t...",74,,947,3,,void
28186,BLOCK,-1,,"{
    return MaybeLocal<Value>();
  }",25,,956,2,,void
28190,BLOCK,-1,,<empty>,3,,960,1,,void
28200,BLOCK,4,,"{
    X509_NAME_ENTRY* entry = X509_NAME_get_entry(name, i);
    CHECK_NOT_NULL(entry);

    // We intentionally ignore the value of X509_NAME_ENTRY_set because the
    // representation as an object does not allow grouping entries into sets
    // anyway, and multi-value RDNs are rare, i.e., the vast majority of
    // Relative Distinguished Names contains a single type-value pair only.
    const ASN1_OBJECT* type = X509_NAME_ENTRY_get_object(entry);
    const ASN1_STRING* value = X509_NAME_ENTRY_get_data(entry);

    // If OpenSSL knows the type, use the short name of the type as the key, and
    // the numeric representation of the type's OID otherwise.
    int type_nid = OBJ_obj2nid(type);
    char type_buf[80];
    const char* type_str;
    if (type_nid != NID_undef) {
      type_str = OBJ_nid2sn(type_nid);
      CHECK_NOT_NULL(type_str);
    } else {
      OBJ_obj2txt(type_buf, sizeof(type_buf), type, true);
      type_str = type_buf;
    }

    Local<String> v8_name;
    if (...",33,,960,4,,void
28230,BLOCK,-1,,"{
      type_str = OBJ_nid2sn(type_nid);
      CHECK_NOT_NULL(type_str);
    }",32,,976,2,,void
28238,BLOCK,-1,,"{
      OBJ_obj2txt(type_buf, sizeof(type_buf), type, true);
      type_str = type_buf;
    }",12,,979,1,,void
28269,BLOCK,-1,,"{
      return MaybeLocal<Value>();
    }",75,,985,2,,void
28283,BLOCK,-1,,"{
      return Undefined(env->isolate());
    }",29,,996,2,,void
28322,BLOCK,-1,,"{
      return MaybeLocal<Value>();
    }",35,,1006,2,,void
28342,BLOCK,-1,,"{
      return MaybeLocal<Value>();
    }",73,,1016,2,,void
28346,BLOCK,-1,,<empty>,12,,1018,1,,void
28349,BLOCK,-1,,"{
      Local<Value> accum;
      if (!result->Get(env->context(), v8_name).ToLocal(&accum)) {
        return MaybeLocal<Value>();
      }
      if (!accum->IsArray()) {
        accum = Array::New(env->isolate(), &accum, 1);
        if (result->Set(env->context(), v8_name, accum).IsNothing()) {
          return MaybeLocal<Value>();
        }
      }
      Local<Array> array = accum.As<Array>();
      if (array->Set(env->context(), array->Length(), v8_value).IsNothing()) {
        return MaybeLocal<Value>();
      }
    }",26,,1018,2,,void
28371,BLOCK,-1,,"{
        return MaybeLocal<Value>();
      }",66,,1020,2,,void
28380,BLOCK,-1,,"{
        accum = Array::New(env->isolate(), &accum, 1);
        if (result->Set(env->context(), v8_name, accum).IsNothing()) {
          return MaybeLocal<Value>();
        }
      }",30,,1023,2,,void
28408,BLOCK,-1,,"{
          return MaybeLocal<Value>();
        }",70,,1025,2,,void
28438,BLOCK,-1,,"{
        return MaybeLocal<Value>();
      }",78,,1030,2,,void
28442,BLOCK,-1,,<empty>,12,,1033,1,,void
28457,BLOCK,-1,,"{
      return MaybeLocal<Value>();
    }",76,,1033,2,,void
28467,BLOCK,-1,,"{
  return Get(env, SSL_get_current_cipher(ssl.get()));
}",64,,1043,3,,void
28481,BLOCK,-1,,"{
  EscapableHandleScope scope(env->isolate());
  const unsigned char* buf;
  size_t len = SSL_client_hello_get0_ciphers(ssl.get(), &buf);
  size_t count = len / 2;
  MaybeStackBuffer<Local<Value>, 16> ciphers(count);
  int j = 0;
  for (size_t n = 0; n < len; n += 2) {
    const SSL_CIPHER* cipher = SSL_CIPHER_find(ssl.get(), buf);
    buf += 2;
    Local<Object> obj = Object::New(env->isolate());
    if (!Set(env->context(),
             obj,
             env->name_string(),
             GetCipherName(env, cipher)) ||
        !Set(env->context(),
             obj,
             env->standard_name_string(),
             GetCipherStandardName(env, cipher)) ||
        !Set(env->context(),
             obj,
             env->version_string(),
             GetCipherVersion(env, cipher))) {
      return MaybeLocal<Array>();
    }
    ciphers[j++] = obj;
  }
  Local<Array> ret = Array::New(env->isolate(), ciphers.out(), count);
  return scope.Escape(ret);
}",28,,1049,3,,void
28513,BLOCK,-1,,<empty>,3,,1056,1,,void
28524,BLOCK,4,,"{
    const SSL_CIPHER* cipher = SSL_CIPHER_find(ssl.get(), buf);
    buf += 2;
    Local<Object> obj = Object::New(env->isolate());
    if (!Set(env->context(),
             obj,
             env->name_string(),
             GetCipherName(env, cipher)) ||
        !Set(env->context(),
             obj,
             env->standard_name_string(),
             GetCipherStandardName(env, cipher)) ||
        !Set(env->context(),
             obj,
             env->version_string(),
             GetCipherVersion(env, cipher))) {
      return MaybeLocal<Array>();
    }
    ciphers[j++] = obj;
  }",39,,1056,4,,void
28596,BLOCK,-1,,"{
      return MaybeLocal<Array>();
    }",46,,1071,2,,void
28635,BLOCK,-1,,"{
  if (SSL_get_current_cipher(ssl.get()) == nullptr)
    return MaybeLocal<Object>();
  EscapableHandleScope scope(env->isolate());
  Local<Object> info = Object::New(env->isolate());

  if (!Set<Value>(env->context(),
                  info,
                  env->name_string(),
                  GetCurrentCipherValue<GetCipherName>(env, ssl)) ||
      !Set<Value>(env->context(),
                  info,
                  env->standard_name_string(),
                  GetCurrentCipherValue<GetCipherStandardName>(env, ssl)) ||
      !Set<Value>(env->context(),
                  info,
                  env->version_string(),
                  GetCurrentCipherValue<GetCipherVersion>(env, ssl))) {
    return MaybeLocal<Object>();
  }

  return scope.Escape(info);
}",75,,1081,3,,void
28644,BLOCK,-1,,<empty>,5,,1083,2,,void
28712,BLOCK,-1,,"{
    return MaybeLocal<Object>();
  }",71,,1098,2,,void
28726,BLOCK,-1,,"{
  CHECK_EQ(SSL_is_server(ssl.get()), 0);
  EVP_PKEY* raw_key;

  EscapableHandleScope scope(env->isolate());
  Local<Object> info = Object::New(env->isolate());
  if (!SSL_get_server_tmp_key(ssl.get(), &raw_key))
    return scope.Escape(info);

  Local<Context> context = env->context();
  crypto::EVPKeyPointer key(raw_key);

  int kid = EVP_PKEY_id(key.get());
  int bits = EVP_PKEY_bits(key.get());
  switch (kid) {
    case EVP_PKEY_DH:
      if (!Set<String>(context, info, env->type_string(), env->dh_string()) ||
          !Set<Integer>(context,
               info,
               env->size_string(),
               Integer::New(env->isolate(), bits))) {
        return MaybeLocal<Object>();
      }
      break;
    case EVP_PKEY_EC:
    case EVP_PKEY_X25519:
    case EVP_PKEY_X448:
      {
        const char* curve_name;
        if (kid == EVP_PKEY_EC) {
          ECKeyPointer ec(EVP_PKEY_get1_EC_KEY(key.get()));
          int nid = EC_GROUP_get_curve_name(EC_KEY_get0_group(ec.get...",77,,1105,3,,void
28764,BLOCK,-1,,<empty>,5,,1112,2,,void
28802,BLOCK,-1,,"{
    case EVP_PKEY_DH:
      if (!Set<String>(context, info, env->type_string(), env->dh_string()) ||
          !Set<Integer>(context,
               info,
               env->size_string(),
               Integer::New(env->isolate(), bits))) {
        return MaybeLocal<Object>();
      }
      break;
    case EVP_PKEY_EC:
    case EVP_PKEY_X25519:
    case EVP_PKEY_X448:
      {
        const char* curve_name;
        if (kid == EVP_PKEY_EC) {
          ECKeyPointer ec(EVP_PKEY_get1_EC_KEY(key.get()));
          int nid = EC_GROUP_get_curve_name(EC_KEY_get0_group(ec.get()));
          curve_name = OBJ_nid2sn(nid);
        } else {
          curve_name = OBJ_nid2sn(kid);
        }
        if (!Set<String>(context,
                         info,
                         env->type_string(),
                         env->ecdh_string()) ||
            !Set<String>(context,
                info,
                env->name_string(),
                OneByteString(env->isolate(), curve_name...",16,,1119,2,,void
28836,BLOCK,-1,,"{
        return MaybeLocal<Object>();
      }",53,,1125,2,,void
28846,BLOCK,11,,"{
        const char* curve_name;
        if (kid == EVP_PKEY_EC) {
          ECKeyPointer ec(EVP_PKEY_get1_EC_KEY(key.get()));
          int nid = EC_GROUP_get_curve_name(EC_KEY_get0_group(ec.get()));
          curve_name = OBJ_nid2sn(nid);
        } else {
          curve_name = OBJ_nid2sn(kid);
        }
        if (!Set<String>(context,
                         info,
                         env->type_string(),
                         env->ecdh_string()) ||
            !Set<String>(context,
                info,
                env->name_string(),
                OneByteString(env->isolate(), curve_name)) ||
            !Set<Integer>(context,
                 info,
                 env->size_string(),
                 Integer::New(env->isolate(), bits))) {
          return MaybeLocal<Object>();
        }
      }",7,,1132,11,,void
28852,BLOCK,-1,,"{
          ECKeyPointer ec(EVP_PKEY_get1_EC_KEY(key.get()));
          int nid = EC_GROUP_get_curve_name(EC_KEY_get0_group(ec.get()));
          curve_name = OBJ_nid2sn(nid);
        }",33,,1134,2,,void
28874,BLOCK,-1,,"{
          curve_name = OBJ_nid2sn(kid);
        }",16,,1138,1,,void
28925,BLOCK,-1,,"{
          return MaybeLocal<Object>();
        }",55,,1152,2,,void
28943,BLOCK,-1,,"{
  size_t len = EC_POINT_point2oct(group, point, form, nullptr, 0, nullptr);
  if (len == 0) {
    if (error != nullptr) *error = ""Failed to get public key length"";
    return MaybeLocal<Object>();
  }

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), len);
  }

  len = EC_POINT_point2oct(group,
                           point,
                           form,
                           reinterpret_cast<unsigned char*>(bs->Data()),
                           bs->ByteLength(),
                           nullptr);
  if (len == 0) {
    if (error != nullptr) *error = ""Failed to get public key"";
    return MaybeLocal<Object>();
  }

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  return Buffer::New(env, ab, 0, ab->ByteLength()).FromMaybe(Local<Object>());
}",56,,1166,6,,void
28958,BLOCK,-1,,"{
    if (error != nullptr) *error = ""Failed to get public key length"";
    return MaybeLocal<Object>();
  }",17,,1168,2,,void
28963,BLOCK,-1,,<empty>,27,,1169,2,,void
28977,BLOCK,5,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), len);
  }",3,,1174,5,,void
29016,BLOCK,-1,,"{
    if (error != nullptr) *error = ""Failed to get public key"";
    return MaybeLocal<Object>();
  }",17,,1185,2,,void
29021,BLOCK,-1,,<empty>,27,,1186,2,,void
29070,BLOCK,-1,,"{
  ClearErrorOnReturn clear_error_on_return;
  Local<Object> result;
  MaybeLocal<Object> maybe_cert;

  // NOTE: This is because of the odd OpenSSL behavior. On client `cert_chain`
  // contains the `peer_certificate`, but on server it doesn't.
  X509Pointer cert(is_server ? SSL_get_peer_certificate(ssl.get()) : nullptr);
  STACK_OF(X509)* ssl_certs = SSL_get_peer_cert_chain(ssl.get());
  if (!cert && (ssl_certs == nullptr || sk_X509_num(ssl_certs) == 0))
    return Undefined(env->isolate());

  // Short result requested.
  if (abbreviated) {
    maybe_cert =
        X509ToObject(env, cert ? cert.get() : sk_X509_value(ssl_certs, 0));
    return maybe_cert.ToLocal(&result) ? result : MaybeLocal<Value>();
  }

  StackOfX509 peer_certs = CloneSSLCerts(std::move(cert), ssl_certs);
  if (peer_certs == nullptr)
    return Undefined(env->isolate());

  // First and main certificate.
  X509Pointer first_cert(sk_X509_value(peer_certs.get(), 0));
  CHECK(first_cert);
  maybe_cert = X509ToOb...",21,,1198,5,,void
29114,BLOCK,-1,,<empty>,5,,1208,2,,void
29123,BLOCK,-1,,"{
    maybe_cert =
        X509ToObject(env, cert ? cert.get() : sk_X509_value(ssl_certs, 0));
    return maybe_cert.ToLocal(&result) ? result : MaybeLocal<Value>();
  }",20,,1211,2,,void
29161,BLOCK,-1,,<empty>,5,,1219,2,,void
29194,BLOCK,-1,,<empty>,5,,1226,2,,void
29227,BLOCK,-1,,<empty>,5,,1238,2,,void
29250,BLOCK,-1,,<empty>,5,,1249,2,,void
29278,BLOCK,-1,,"{
    return MaybeLocal<Value>();
  }",27,,1256,2,,void
29288,BLOCK,-1,,"{
  EscapableHandleScope scope(env->isolate());
  Local<Context> context = env->context();
  Local<Object> info = Object::New(env->isolate());

  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);

  // X509_check_ca() returns a range of values. Only 1 means ""is a CA""
  auto is_ca = Boolean::New(env->isolate(), 1 == X509_check_ca(cert));
  if (!Set<Value>(context,
                  info,
                  env->subject_string(),
                  GetX509NameObject<X509_get_subject_name>(env, cert)) ||
      !Set<Value>(context,
                  info,
                  env->issuer_string(),
                  GetX509NameObject<X509_get_issuer_name>(env, cert)) ||
      !Set<Value>(context,
                  info,
                  env->subjectaltname_string(),
                  GetSubjectAltNameString(env, bio, cert)) ||
      !Set<Value>(context,
                  info,
                  env->infoaccess_string(),
                  GetInfoAccessString(env, bio, cert)) ||
      !Set<B...",17,,1265,3,,void
29321,BLOCK,-1,,<empty>,,,,2,,<empty>
29401,BLOCK,-1,,"{
    return MaybeLocal<Object>();
  }",62,,1291,2,,void
29412,BLOCK,-1,,"{
    switch (EVP_PKEY_id(pkey.get())) {
      case EVP_PKEY_RSA:
        rsa.reset(EVP_PKEY_get1_RSA(pkey.get()));
        break;
      case EVP_PKEY_EC:
        ec.reset(EVP_PKEY_get1_EC_KEY(pkey.get()));
        break;
    }
  }",13,,1298,2,,void
29419,BLOCK,-1,,"{
      case EVP_PKEY_RSA:
        rsa.reset(EVP_PKEY_get1_RSA(pkey.get()));
        break;
      case EVP_PKEY_EC:
        ec.reset(EVP_PKEY_get1_EC_KEY(pkey.get()));
        break;
    }",38,,1299,2,,void
29446,BLOCK,-1,,"{
    const BIGNUM* n;
    const BIGNUM* e;
    RSA_get0_key(rsa.get(), &n, &e, nullptr);
    if (!Set<Value>(context,
                    info,
                    env->modulus_string(),
                    GetModulusString(env, bio, n)) ||
        !Set<Value>(context, info, env->bits_string(), GetBits(env, n)) ||
        !Set<Value>(context,
                    info,
                    env->exponent_string(),
                    GetExponentString(env, bio, e)) ||
        !Set<Object>(context,
                     info,
                     env->pubkey_string(),
                     GetPubKey(env, rsa))) {
      return MaybeLocal<Object>();
    }
  }",12,,1309,2,,void
29509,BLOCK,-1,,"{
      return MaybeLocal<Object>();
    }",44,,1325,2,,void
29513,BLOCK,-1,,<empty>,10,,1328,1,,void
29516,BLOCK,-1,,"{
    const EC_GROUP* group = EC_KEY_get0_group(ec.get());

    if (!Set<Value>(context,
                    info,
                    env->bits_string(),
                    GetECGroup(env, group, ec)) ||
        !Set<Value>(context,
                    info,
                    env->pubkey_string(),
                    GetECPubKey(env, group, ec))) {
      return MaybeLocal<Object>();
    }

    const int nid = EC_GROUP_get_curve_name(group);
    if (nid != 0) {
      // Curve is well-known, get its OID and NIST nick-name (if it has one).

      if (!Set<Value>(context,
                      info,
                      env->asn1curve_string(),
                      GetCurveName<OBJ_nid2sn>(env, nid)) ||
          !Set<Value>(context,
                      info,
                      env->nistcurve_string(),
                      GetCurveName<EC_curve_nid2nist>(env, nid))) {
        return MaybeLocal<Object>();
      }
    } else {
      // Unnamed curves can be described by their ...",18,,1328,2,,void
29551,BLOCK,-1,,"{
      return MaybeLocal<Object>();
    }",51,,1338,2,,void
29563,BLOCK,-1,,"{
      // Curve is well-known, get its OID and NIST nick-name (if it has one).

      if (!Set<Value>(context,
                      info,
                      env->asn1curve_string(),
                      GetCurveName<OBJ_nid2sn>(env, nid)) ||
          !Set<Value>(context,
                      info,
                      env->nistcurve_string(),
                      GetCurveName<EC_curve_nid2nist>(env, nid))) {
        return MaybeLocal<Object>();
      }
    }",19,,1343,2,,void
29588,BLOCK,-1,,"{
        return MaybeLocal<Object>();
      }",67,,1353,2,,void
29592,BLOCK,-1,,"{
      // Unnamed curves can be described by their mathematical properties,
      // but aren't used much (at all?) with X.509/TLS. Support later if needed.
    }",12,,1356,1,,void
29631,BLOCK,-1,,"{
    return MaybeLocal<Object>();
  }",48,,1374,2,,void
29713,BLOCK,-1,,"{
    return MaybeLocal<Object>();
  }",54,,1404,2,,void
29738,BLOCK,-1,,<empty>,1,,1,1,,ANY
29777,BLOCK,-1,,<empty>,1,,1,1,,ANY
29793,BLOCK,-1,,"{
  // Guaranteed thread-safe by standard, just don't use -fno-threadsafe-statics.
  static X509_STORE* store = NewRootCertStore();
  return store;
}",47,,56,1,,void
29805,BLOCK,-1,,"{
  HandleScope scope(env->isolate());

  if (v->IsString()) {
    Utf8Value s(env->isolate(), v);
    return NodeBIO::NewFixed(*s, s.length());
  }

  if (v->IsArrayBufferView()) {
    ArrayBufferViewContents<char> buf(v.As<ArrayBufferView>());
    return NodeBIO::NewFixed(buf.data(), buf.length());
  }

  return nullptr;
}",54,,64,3,,void
29817,BLOCK,-1,,"{
    Utf8Value s(env->isolate(), v);
    return NodeBIO::NewFixed(*s, s.length());
  }",22,,67,2,,void
29841,BLOCK,-1,,"{
    ArrayBufferViewContents<char> buf(v.As<ArrayBufferView>());
    return NodeBIO::NewFixed(buf.data(), buf.length());
  }",31,,72,2,,void
29872,BLOCK,-1,,"{
  // Just to ensure that `ERR_peek_last_error` below will return only errors
  // that we are interested in
  ERR_clear_error();

  X509Pointer x(
      PEM_read_bio_X509_AUX(in.get(), nullptr, NoPasswordCallback, nullptr));

  if (!x)
    return 0;

  unsigned long err = 0;  // NOLINT(runtime/int)

  StackOfX509 extra_certs(sk_X509_new_null());
  if (!extra_certs)
    return 0;

  while (X509Pointer extra {PEM_read_bio_X509(in.get(),
                                    nullptr,
                                    NoPasswordCallback,
                                    nullptr)}) {
    if (sk_X509_push(extra_certs.get(), extra.get())) {
      extra.release();
      continue;
    }

    return 0;
  }

  // When the while loop ends, it's usually just EOF.
  err = ERR_peek_last_error();
  if (ERR_GET_LIB(err) == ERR_LIB_PEM &&
      ERR_GET_REASON(err) == PEM_R_NO_START_LINE) {
    ERR_clear_error();
  } else {
    // some real error
    return 0;
  }

  return SSL_CTX_use_certificat...",56,,153,5,,void
29887,BLOCK,-1,,<empty>,5,,162,2,,void
29900,BLOCK,-1,,<empty>,5,,168,2,,void
29904,BLOCK,-1,,"{
    if (sk_X509_push(extra_certs.get(), extra.get())) {
      extra.release();
      continue;
    }

    return 0;
  }",48,,173,1,,void
29915,BLOCK,-1,,"{
      extra.release();
      continue;
    }",55,,174,2,,void
29936,BLOCK,-1,,"{
    ERR_clear_error();
  }",51,,185,2,,void
29939,BLOCK,-1,,"{
    // some real error
    return 0;
  }",10,,187,1,,void
29959,BLOCK,-1,,"{
  static std::vector<X509*> root_certs_vector;
  static Mutex root_certs_vector_mutex;
  Mutex::ScopedLock lock(root_certs_vector_mutex);

  if (root_certs_vector.empty() &&
      per_process::cli_options->ssl_openssl_cert_store == false) {
    for (size_t i = 0; i < arraysize(root_certs); i++) {
      X509* x509 =
          PEM_read_bio_X509(NodeBIO::NewFixed(root_certs[i],
                                              strlen(root_certs[i])).get(),
                            nullptr,   // no re-use of X509 structure
                            NoPasswordCallback,
                            nullptr);  // no callback data

      // Parse errors from the built-in roots are fatal.
      CHECK_NOT_NULL(x509);

      root_certs_vector.push_back(x509);
    }
  }

  X509_STORE* store = X509_STORE_new();
  if (*system_cert_path != '\0') {
    ERR_set_mark();
    X509_STORE_load_locations(store, system_cert_path, nullptr);
    ERR_pop_to_mark();
  }

  Mutex::ScopedLock cli_lock(node::pe...",32,,201,1,,void
29978,BLOCK,-1,,"{
    for (size_t i = 0; i < arraysize(root_certs); i++) {
      X509* x509 =
          PEM_read_bio_X509(NodeBIO::NewFixed(root_certs[i],
                                              strlen(root_certs[i])).get(),
                            nullptr,   // no re-use of X509 structure
                            NoPasswordCallback,
                            nullptr);  // no callback data

      // Parse errors from the built-in roots are fatal.
      CHECK_NOT_NULL(x509);

      root_certs_vector.push_back(x509);
    }
  }",66,,207,2,,void
29980,BLOCK,-1,,<empty>,5,,208,1,,void
29991,BLOCK,4,,"{
      X509* x509 =
          PEM_read_bio_X509(NodeBIO::NewFixed(root_certs[i],
                                              strlen(root_certs[i])).get(),
                            nullptr,   // no re-use of X509 structure
                            NoPasswordCallback,
                            nullptr);  // no callback data

      // Parse errors from the built-in roots are fatal.
      CHECK_NOT_NULL(x509);

      root_certs_vector.push_back(x509);
    }",56,,208,4,,void
30029,BLOCK,-1,,"{
    ERR_set_mark();
    X509_STORE_load_locations(store, system_cert_path, nullptr);
    ERR_pop_to_mark();
  }",34,,224,2,,void
30049,BLOCK,-1,,"{
    X509_STORE_set_default_paths(store);
  }",57,,231,2,,void
30053,BLOCK,-1,,"{
    for (X509* cert : root_certs_vector) {
      X509_up_ref(cert);
      X509_STORE_add_cert(store, cert);
    }
  }",10,,233,1,,void
30057,BLOCK,-1,,"{
      X509_up_ref(cert);
      X509_STORE_add_cert(store, cert);
    }",42,,234,3,,void
30069,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Local<Value> result[arraysize(root_certs)];

  for (size_t i = 0; i < arraysize(root_certs); i++) {
    if (!String::NewFromOneByte(
            env->isolate(),
            reinterpret_cast<const uint8_t*>(root_certs[i]))
            .ToLocal(&result[i])) {
      return;
    }
  }

  args.GetReturnValue().Set(
      Array::New(env->isolate(), result, arraysize(root_certs)));
}",67,,243,2,,void
30087,BLOCK,-1,,<empty>,3,,247,1,,void
30098,BLOCK,4,,"{
    if (!String::NewFromOneByte(
            env->isolate(),
            reinterpret_cast<const uint8_t*>(root_certs[i]))
            .ToLocal(&result[i])) {
      return;
    }
  }",54,,247,4,,void
30121,BLOCK,-1,,"{
      return;
    }",35,,251,2,,void
30146,BLOCK,-1,,"{
  return GetConstructorTemplate(env)->HasInstance(value);
}",78,,260,3,,void
30158,BLOCK,-1,,"{
  Local<FunctionTemplate> tmpl = env->secure_context_constructor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, New);
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        SecureContext::kInternalFieldCount);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), ""SecureContext""));

    SetProtoMethod(isolate, tmpl, ""init"", Init);
    SetProtoMethod(isolate, tmpl, ""setKey"", SetKey);
    SetProtoMethod(isolate, tmpl, ""setCert"", SetCert);
    SetProtoMethod(isolate, tmpl, ""addCACert"", AddCACert);
    SetProtoMethod(isolate, tmpl, ""addCRL"", AddCRL);
    SetProtoMethod(isolate, tmpl, ""addRootCerts"", AddRootCerts);
    SetProtoMethod(isolate, tmpl, ""setCipherSuites"", SetCipherSuites);
    SetProtoMethod(isolate, tmpl, ""setCiphers"", SetCiphers);
    SetProtoMethod(isolate, tmpl, ""setSigalgs"", SetSigalgs);
    SetProtoMethod(isolate, tmpl, ""setECDHCurve"", SetECDHCurve);
    SetProtoMethod(isolate, tmpl, ""set...",23,,265,2,,void
30174,BLOCK,-1,,"{
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, New);
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        SecureContext::kInternalFieldCount);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), ""SecureContext""));

    SetProtoMethod(isolate, tmpl, ""init"", Init);
    SetProtoMethod(isolate, tmpl, ""setKey"", SetKey);
    SetProtoMethod(isolate, tmpl, ""setCert"", SetCert);
    SetProtoMethod(isolate, tmpl, ""addCACert"", AddCACert);
    SetProtoMethod(isolate, tmpl, ""addCRL"", AddCRL);
    SetProtoMethod(isolate, tmpl, ""addRootCerts"", AddRootCerts);
    SetProtoMethod(isolate, tmpl, ""setCipherSuites"", SetCipherSuites);
    SetProtoMethod(isolate, tmpl, ""setCiphers"", SetCiphers);
    SetProtoMethod(isolate, tmpl, ""setSigalgs"", SetSigalgs);
    SetProtoMethod(isolate, tmpl, ""setECDHCurve"", SetECDHCurve);
    SetProtoMethod(isolate, tmpl, ""setDHParam"", SetDHParam);
    SetProtoMethod(isolate, tmpl, ""setMaxProto"", SetMaxProto);
    SetProtoMet...",23,,267,2,,void
30345,BLOCK,1,,<empty>,,,,5,,void
30362,BLOCK,1,,<empty>,,,,5,,void
30379,BLOCK,1,,<empty>,,,,5,,void
30396,BLOCK,1,,<empty>,,,,5,,void
30413,BLOCK,1,,<empty>,,,,5,,void
30475,BLOCK,-1,,"{
  Local<Context> context = env->context();
  SetConstructorFunction(context,
                         target,
                         ""SecureContext"",
                         GetConstructorTemplate(env),
                         SetConstructorFunctionFlag::NONE);

  SetMethodNoSideEffect(
      context, target, ""getRootCertificates"", GetRootCertificates);
  // Exposed for testing purposes only.
  SetMethodNoSideEffect(context,
                        target,
                        ""isExtraRootCertsFileLoaded"",
                        IsExtraRootCertsFileLoaded);
}",72,,333,3,,void
30509,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(Init);
  registry->Register(SetKey);
  registry->Register(SetCert);
  registry->Register(AddCACert);
  registry->Register(AddCRL);
  registry->Register(AddRootCerts);
  registry->Register(SetCipherSuites);
  registry->Register(SetCiphers);
  registry->Register(SetSigalgs);
  registry->Register(SetECDHCurve);
  registry->Register(SetDHParam);
  registry->Register(SetMaxProto);
  registry->Register(SetMinProto);
  registry->Register(GetMaxProto);
  registry->Register(GetMinProto);
  registry->Register(SetOptions);
  registry->Register(SetSessionIdContext);
  registry->Register(SetSessionTimeout);
  registry->Register(Close);
  registry->Register(LoadPKCS12);
  registry->Register(SetTicketKeys);
  registry->Register(EnableTicketKeyCallback);
  registry->Register(GetTicketKeys);
  registry->Register(GetCertificate<true>);
  registry->Register(GetCertificate<false>);

#ifndef OPENSSL_NO_ENGINE
  registry->Register(SetEngineKey);
  registr...",42,,351,2,,void
30669,BLOCK,-1,,"{
  Local<Object> obj;
  if (!GetConstructorTemplate(env)
          ->InstanceTemplate()
          ->NewInstance(env->context()).ToLocal(&obj)) {
    return nullptr;
  }

  return new SecureContext(env, obj);
}",56,,390,2,,void
30694,BLOCK,-1,,"{
    return nullptr;
  }",56,,394,2,,void
30707,BLOCK,-1,,"{
  MakeWeak();
  env->isolate()->AdjustAmountOfExternalAllocatedMemory(kExternalSize);
}",29,,402,3,,void
30720,BLOCK,-1,,"{
  if (ctx_ != nullptr) {
    env()->isolate()->AdjustAmountOfExternalAllocatedMemory(-kExternalSize);
  }
  ctx_.reset();
  cert_.reset();
  issuer_.reset();
}",36,,407,1,,void
30725,BLOCK,-1,,"{
    env()->isolate()->AdjustAmountOfExternalAllocatedMemory(-kExternalSize);
  }",24,,408,2,,void
30750,BLOCK,-1,,"{
  Reset();
}",33,,416,1,,void
30756,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  new SecureContext(env, args.This());
}",66,,420,2,,void
30776,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  Environment* env = sc->env();

  CHECK_EQ(args.Length(), 3);
  CHECK(args[1]->IsInt32());
  CHECK(args[2]->IsInt32());

  int min_version = args[1].As<Int32>()->Value();
  int max_version = args[2].As<Int32>()->Value();
  const SSL_METHOD* method = TLS_method();

  if (max_version == 0)
    max_version = kMaxSupportedVersion;

  if (args[0]->IsString()) {
    Utf8Value sslmethod(env->isolate(), args[0]);

    // Note that SSLv2 and SSLv3 are disallowed but SSLv23_method and friends
    // are still accepted.  They are OpenSSL's way of saying that all known
    // protocols below TLS 1.3 are supported unless explicitly disabled (which
    // we do below for SSLv2 and SSLv3.)
    if (sslmethod == ""SSLv2_method"" ||
        sslmethod == ""SSLv2_server_method"" ||
        sslmethod == ""SSLv2_client_method"") {
      THROW_ERR_TLS_INVALID_PROTOCOL_METHOD(env, ""SSLv2 methods disabled"");
      return;
    } else if (sslmet...",67,,425,2,,void
30844,BLOCK,-1,,<empty>,5,,439,2,,void
30855,BLOCK,-1,,"{
    Utf8Value sslmethod(env->isolate(), args[0]);

    // Note that SSLv2 and SSLv3 are disallowed but SSLv23_method and friends
    // are still accepted.  They are OpenSSL's way of saying that all known
    // protocols below TLS 1.3 are supported unless explicitly disabled (which
    // we do below for SSLv2 and SSLv3.)
    if (sslmethod == ""SSLv2_method"" ||
        sslmethod == ""SSLv2_server_method"" ||
        sslmethod == ""SSLv2_client_method"") {
      THROW_ERR_TLS_INVALID_PROTOCOL_METHOD(env, ""SSLv2 methods disabled"");
      return;
    } else if (sslmethod == ""SSLv3_method"" ||
               sslmethod == ""SSLv3_server_method"" ||
               sslmethod == ""SSLv3_client_method"") {
      THROW_ERR_TLS_INVALID_PROTOCOL_METHOD(env, ""SSLv3 methods disabled"");
      return;
    } else if (sslmethod == ""SSLv23_method"") {
      max_version = TLS1_2_VERSION;
    } else if (sslmethod == ""SSLv23_server_method"") {
      max_version = TLS1_2_VERSION;
      method = TLS_server_method()...",28,,441,2,,void
30877,BLOCK,-1,,"{
      THROW_ERR_TLS_INVALID_PROTOCOL_METHOD(env, ""SSLv2 methods disabled"");
      return;
    }",45,,450,2,,void
30883,BLOCK,-1,,<empty>,12,,453,1,,void
30896,BLOCK,-1,,"{
      THROW_ERR_TLS_INVALID_PROTOCOL_METHOD(env, ""SSLv3 methods disabled"");
      return;
    }",52,,455,2,,void
30902,BLOCK,-1,,<empty>,12,,458,1,,void
30907,BLOCK,-1,,"{
      max_version = TLS1_2_VERSION;
    }",46,,458,2,,void
30912,BLOCK,-1,,<empty>,12,,460,1,,void
30917,BLOCK,-1,,"{
      max_version = TLS1_2_VERSION;
      method = TLS_server_method();
    }",53,,460,2,,void
30925,BLOCK,-1,,<empty>,12,,463,1,,void
30930,BLOCK,-1,,"{
      max_version = TLS1_2_VERSION;
      method = TLS_client_method();
    }",53,,463,2,,void
30938,BLOCK,-1,,<empty>,12,,466,1,,void
30943,BLOCK,-1,,"{
      min_version = 0;
      max_version = kMaxSupportedVersion;
    }",43,,466,2,,void
30951,BLOCK,-1,,<empty>,12,,469,1,,void
30956,BLOCK,-1,,"{
      min_version = 0;
      max_version = kMaxSupportedVersion;
      method = TLS_server_method();
    }",50,,469,2,,void
30967,BLOCK,-1,,<empty>,12,,473,1,,void
30972,BLOCK,-1,,"{
      min_version = 0;
      max_version = kMaxSupportedVersion;
      method = TLS_client_method();
    }",50,,473,2,,void
30983,BLOCK,-1,,<empty>,12,,477,1,,void
30988,BLOCK,-1,,"{
      min_version = TLS1_VERSION;
      max_version = TLS1_VERSION;
    }",45,,477,2,,void
30996,BLOCK,-1,,<empty>,12,,480,1,,void
31001,BLOCK,-1,,"{
      min_version = TLS1_VERSION;
      max_version = TLS1_VERSION;
      method = TLS_server_method();
    }",52,,480,2,,void
31012,BLOCK,-1,,<empty>,12,,484,1,,void
31017,BLOCK,-1,,"{
      min_version = TLS1_VERSION;
      max_version = TLS1_VERSION;
      method = TLS_client_method();
    }",52,,484,2,,void
31028,BLOCK,-1,,<empty>,12,,488,1,,void
31033,BLOCK,-1,,"{
      min_version = TLS1_1_VERSION;
      max_version = TLS1_1_VERSION;
    }",47,,488,2,,void
31041,BLOCK,-1,,<empty>,12,,491,1,,void
31046,BLOCK,-1,,"{
      min_version = TLS1_1_VERSION;
      max_version = TLS1_1_VERSION;
      method = TLS_server_method();
    }",54,,491,2,,void
31057,BLOCK,-1,,<empty>,12,,495,1,,void
31062,BLOCK,-1,,"{
      min_version = TLS1_1_VERSION;
      max_version = TLS1_1_VERSION;
      method = TLS_client_method();
    }",54,,495,2,,void
31073,BLOCK,-1,,<empty>,12,,499,1,,void
31078,BLOCK,-1,,"{
      min_version = TLS1_2_VERSION;
      max_version = TLS1_2_VERSION;
    }",47,,499,2,,void
31086,BLOCK,-1,,<empty>,12,,502,1,,void
31091,BLOCK,-1,,"{
      min_version = TLS1_2_VERSION;
      max_version = TLS1_2_VERSION;
      method = TLS_server_method();
    }",54,,502,2,,void
31102,BLOCK,-1,,<empty>,12,,506,1,,void
31107,BLOCK,-1,,"{
      min_version = TLS1_2_VERSION;
      max_version = TLS1_2_VERSION;
      method = TLS_client_method();
    }",54,,506,2,,void
31118,BLOCK,-1,,"{
      THROW_ERR_TLS_INVALID_PROTOCOL_METHOD(
          env, ""Unknown method: %s"", *sslmethod);
      return;
    }",12,,510,1,,void
31138,BLOCK,-1,,"{
    return ThrowCryptoError(env, ERR_get_error(), ""SSL_CTX_new"");
  }",18,,518,2,,void
31242,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_OPERATION_FAILED(
        env, ""Error generating ticket keys"");
  }",74,,553,2,,void
31258,BLOCK,-1,,"{
  return SSLPointer(SSL_new(ctx_.get()));
}",39,,560,1,,void
31270,BLOCK,-1,,"{
  SSL_CTX_sess_set_new_cb(ctx_.get(), cb);
}",60,,564,2,,void
31281,BLOCK,-1,,"{
  SSL_CTX_sess_set_get_cb(ctx_.get(), cb);
}",60,,568,2,,void
31292,BLOCK,-1,,"{
  SSL_CTX_set_tlsext_servername_callback(ctx_.get(), cb);
}",72,,572,2,,void
31303,BLOCK,-1,,"{
  SSL_CTX_set_keylog_callback(ctx_.get(), cb);
}",52,,576,2,,void
31315,BLOCK,-1,,"{
  if (key->GetKeyType() != KeyType::kKeyTypePrivate) {
    THROW_ERR_CRYPTO_INVALID_KEYTYPE(env);
    return Nothing<bool>();
  }

  ClearErrorOnReturn clear_error_on_return;
  if (!SSL_CTX_use_PrivateKey(ctx_.get(), key->GetAsymmetricKey().get())) {
    ThrowCryptoError(env, ERR_get_error(), ""SSL_CTX_use_PrivateKey"");
    return Nothing<bool>();
  }

  return Just(true);
}",71,,581,3,,void
31325,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_KEYTYPE(env);
    return Nothing<bool>();
  }",54,,582,2,,void
31345,BLOCK,-1,,"{
    ThrowCryptoError(env, ERR_get_error(), ""SSL_CTX_use_PrivateKey"");
    return Nothing<bool>();
  }",75,,588,2,,void
31359,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_GE(args.Length(), 1);  // Private key argument is mandatory

  BIOPointer bio(LoadBIO(env, args[0]));
  if (!bio)
    return;

  ByteSource passphrase;
  if (args[1]->IsString())
    passphrase = ByteSource::FromString(env, args[1].As<String>());
  // This redirection is necessary because the PasswordCallback expects a
  // pointer to a pointer to the passphrase ByteSource to allow passing in
  // const ByteSources.
  const ByteSource* pass_ptr = &passphrase;

  EVPKeyPointer key(
      PEM_read_bio_PrivateKey(bio.get(),
                              nullptr,
                              PasswordCallback,
                              &pass_ptr));

  if (!key)
    return ThrowCryptoError(env, ERR_get_error(), ""PEM_read_bio_PrivateKey"");

  if (!SSL_CTX_use_PrivateKey(sc->ctx_.get(), key.get()))
    return ThrowCryptoError(env, ERR_get_error(), ""SSL_CTX...",69,,596,2,,void
31392,BLOCK,-1,,<empty>,5,,606,2,,void
31402,BLOCK,-1,,<empty>,5,,610,2,,void
31435,BLOCK,-1,,<empty>,5,,623,2,,void
31454,BLOCK,-1,,<empty>,5,,626,2,,void
31464,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  Environment* env = sc->env();
  ClearErrorOnReturn clear_error_on_return;

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());

  const Utf8Value sigalgs(env->isolate(), args[0]);

  if (!SSL_CTX_set1_sigalgs_list(sc->ctx_.get(), *sigalgs))
    return ThrowCryptoError(env, ERR_get_error());
}",73,,629,2,,void
31514,BLOCK,-1,,<empty>,5,,641,2,,void
31523,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_EQ(args.Length(), 2);

  CryptoErrorStore errors;
  Utf8Value engine_id(env->isolate(), args[1]);
  EnginePointer engine = LoadEngineById(*engine_id, &errors);
  if (!engine) {
    Local<Value> exception;
    if (errors.ToException(env).ToLocal(&exception))
      env->isolate()->ThrowException(exception);
    return;
  }

  if (!ENGINE_init(engine.get())) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(
        env, ""Failure to initialize engine"");
  }

  engine.finish_on_exit = true;

  Utf8Value key_name(env->isolate(), args[0]);
  EVPKeyPointer key(ENGINE_load_private_key(engine.get(), *key_name,
                                            nullptr, nullptr));

  if (!key)
    return ThrowCryptoError(env, ERR_get_error(), ""ENGINE_load_private_key"");

  if (!SSL_CTX_use_PrivateKey(sc->ctx_.get(), key.get()))
    return ThrowCryptoError(env, ERR_get_erro...",75,,645,2,,void
31567,BLOCK,-1,,"{
    Local<Value> exception;
    if (errors.ToException(env).ToLocal(&exception))
      env->isolate()->ThrowException(exception);
    return;
  }",16,,656,2,,void
31584,BLOCK,-1,,<empty>,7,,659,2,,void
31601,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_OPERATION_FAILED(
        env, ""Failure to initialize engine"");
  }",35,,663,2,,void
31634,BLOCK,-1,,<empty>,5,,675,2,,void
31653,BLOCK,-1,,<empty>,5,,678,2,,void
31673,BLOCK,-1,,"{
  ClearErrorOnReturn clear_error_on_return;
  if (!bio) return Just(false);
  cert_.reset();
  issuer_.reset();

  // The SSL_CTX_use_certificate_chain call here is not from openssl, this is
  // the method implemented elsewhere in this file. The naming is a bit
  // confusing, unfortunately.
  if (SSL_CTX_use_certificate_chain(
          ctx_.get(), std::move(bio), &cert_, &issuer_) == 0) {
    ThrowCryptoError(env, ERR_get_error(), ""SSL_CTX_use_certificate_chain"");
    return Nothing<bool>();
  }
  return Just(true);
}",72,,684,3,,void
31678,BLOCK,-1,,<empty>,13,,686,2,,void
31707,BLOCK,-1,,"{
    ThrowCryptoError(env, ERR_get_error(), ""SSL_CTX_use_certificate_chain"");
    return Nothing<bool>();
  }",63,,694,2,,void
31721,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_GE(args.Length(), 1);  // Certificate argument is mandatory

  BIOPointer bio(LoadBIO(env, args[0]));
  USE(sc->AddCert(env, std::move(bio)));
}",70,,701,2,,void
31766,BLOCK,-1,,"{
  ClearErrorOnReturn clear_error_on_return;
  if (!bio) return;
  X509_STORE* cert_store = SSL_CTX_get_cert_store(ctx_.get());
  while (X509Pointer x509 = X509Pointer(PEM_read_bio_X509_AUX(
             bio.get(), nullptr, NoPasswordCallback, nullptr))) {
    if (cert_store == GetOrCreateRootCertStore()) {
      cert_store = NewRootCertStore();
      SSL_CTX_set_cert_store(ctx_.get(), cert_store);
    }
    CHECK_EQ(1, X509_STORE_add_cert(cert_store, x509.get()));
    CHECK_EQ(1, SSL_CTX_add_client_CA(ctx_.get(), x509.get()));
  }
}",54,,713,2,,void
31771,BLOCK,-1,,<empty>,13,,715,2,,void
31782,BLOCK,-1,,"{
    if (cert_store == GetOrCreateRootCertStore()) {
      cert_store = NewRootCertStore();
      SSL_CTX_set_cert_store(ctx_.get(), cert_store);
    }
    CHECK_EQ(1, X509_STORE_add_cert(cert_store, x509.get()));
    CHECK_EQ(1, SSL_CTX_add_client_CA(ctx_.get(), x509.get()));
  }",65,,718,1,,void
31787,BLOCK,-1,,"{
      cert_store = NewRootCertStore();
      SSL_CTX_set_cert_store(ctx_.get(), cert_store);
    }",51,,719,2,,void
31820,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_GE(args.Length(), 1);  // CA certificate argument is mandatory

  BIOPointer bio(LoadBIO(env, args[0]));
  sc->SetCACert(bio);
}",72,,728,2,,void
31860,BLOCK,-1,,"{
  ClearErrorOnReturn clear_error_on_return;
  if (!bio) return Just(false);

  DeleteFnPtr<X509_CRL, X509_CRL_free> crl(
      PEM_read_bio_X509_CRL(bio.get(), nullptr, NoPasswordCallback, nullptr));

  if (!crl) {
    THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""Failed to parse CRL"");
    return Nothing<bool>();
  }

  X509_STORE* cert_store = SSL_CTX_get_cert_store(ctx_.get());
  if (cert_store == GetOrCreateRootCertStore()) {
    cert_store = NewRootCertStore();
    SSL_CTX_set_cert_store(ctx_.get(), cert_store);
  }

  CHECK_EQ(1, X509_STORE_add_crl(cert_store, crl.get()));
  CHECK_EQ(1,
           X509_STORE_set_flags(
               cert_store, X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL));
  return Just(true);
}",76,,740,3,,void
31865,BLOCK,-1,,<empty>,13,,742,2,,void
31887,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""Failed to parse CRL"");
    return Nothing<bool>();
  }",13,,747,2,,void
31905,BLOCK,-1,,"{
    cert_store = NewRootCertStore();
    SSL_CTX_set_cert_store(ctx_.get(), cert_store);
  }",49,,753,2,,void
31937,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_GE(args.Length(), 1);  // CRL argument is mandatory

  BIOPointer bio(LoadBIO(env, args[0]));
  USE(sc->SetCRL(env, bio));
}",69,,765,2,,void
31977,BLOCK,-1,,"{
  ClearErrorOnReturn clear_error_on_return;
  auto store = GetOrCreateRootCertStore();

  // Increment reference count so global store is not deleted along with CTX.
  X509_STORE_up_ref(store);
  SSL_CTX_set_cert_store(ctx_.get(), store);
}",36,,777,1,,void
31995,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  sc->SetRootCerts();
}",75,,786,2,,void
32012,BLOCK,-1,,"{
  // BoringSSL doesn't allow API config of TLS1.3 cipher suites.
#ifndef OPENSSL_IS_BORINGSSL
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  Environment* env = sc->env();
  ClearErrorOnReturn clear_error_on_return;

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());

  const Utf8Value ciphers(env->isolate(), args[0]);
  if (!SSL_CTX_set_ciphersuites(sc->ctx_.get(), *ciphers))
    return ThrowCryptoError(env, ERR_get_error(), ""Failed to set ciphers"");
#endif
}",78,,792,2,,void
32062,BLOCK,-1,,<empty>,5,,805,2,,void
32072,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  Environment* env = sc->env();
  ClearErrorOnReturn clear_error_on_return;

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());

  Utf8Value ciphers(env->isolate(), args[0]);
  if (!SSL_CTX_set_cipher_list(sc->ctx_.get(), *ciphers)) {
    unsigned long err = ERR_get_error();  // NOLINT(runtime/int)

    if (strlen(*ciphers) == 0 && ERR_GET_REASON(err) == SSL_R_NO_CIPHER_MATCH) {
      // TLS1.2 ciphers were deliberately cleared, so don't consider
      // SSL_R_NO_CIPHER_MATCH to be an error (this is how _set_cipher_suites()
      // works). If the user actually sets a value (like ""no-such-cipher""), then
      // that's actually an error.
      return;
    }
    return ThrowCryptoError(env, err, ""Failed to set ciphers"");
  }
}",73,,809,2,,void
32122,BLOCK,-1,,"{
    unsigned long err = ERR_get_error();  // NOLINT(runtime/int)

    if (strlen(*ciphers) == 0 && ERR_GET_REASON(err) == SSL_R_NO_CIPHER_MATCH) {
      // TLS1.2 ciphers were deliberately cleared, so don't consider
      // SSL_R_NO_CIPHER_MATCH to be an error (this is how _set_cipher_suites()
      // works). If the user actually sets a value (like ""no-such-cipher""), then
      // that's actually an error.
      return;
    }
    return ThrowCryptoError(env, err, ""Failed to set ciphers"");
  }",59,,819,2,,void
32138,BLOCK,-1,,"{
      // TLS1.2 ciphers were deliberately cleared, so don't consider
      // SSL_R_NO_CIPHER_MATCH to be an error (this is how _set_cipher_suites()
      // works). If the user actually sets a value (like ""no-such-cipher""), then
      // that's actually an error.
      return;
    }",80,,822,2,,void
32149,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  Environment* env = sc->env();

  CHECK_GE(args.Length(), 1);  // ECDH curve name argument is mandatory
  CHECK(args[0]->IsString());

  Utf8Value curve(env->isolate(), args[0]);

  if (curve != ""auto"" && !SSL_CTX_set1_curves_list(sc->ctx_.get(), *curve)) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""Failed to set ECDH curve"");
  }
}",75,,833,2,,void
32202,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""Failed to set ECDH curve"");
  }",77,,843,2,,void
32211,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.This());
  Environment* env = sc->env();
  ClearErrorOnReturn clear_error_on_return;

  CHECK_GE(args.Length(), 1);  // DH argument is mandatory

  // If the user specified ""auto"" for dhparams, the JavaScript layer will pass
  // true to this function instead of the original string. Any other string
  // value will be interpreted as custom DH parameters below.
  if (args[0]->IsTrue()) {
    CHECK(SSL_CTX_set_dh_auto(sc->ctx_.get(), true));
    return;
  }

  DHPointer dh;
  {
    BIOPointer bio(LoadBIO(env, args[0]));
    if (!bio)
      return;

    dh.reset(PEM_read_bio_DHparams(bio.get(), nullptr, nullptr, nullptr));
  }

  // Invalid dhparam is silently discarded and DHE is no longer used.
  // TODO(tniessen): don't silently discard invalid dhparam.
  if (!dh)
    return;

  const BIGNUM* p;
  DH_get0_pqg(dh.get(), &p, nullptr, nullptr);
  const int size = BN_num_bits(p);
  if (size < 1024) {
    return THROW_ERR_INVALID...",73,,848,2,,void
32241,BLOCK,-1,,"{
    CHECK(SSL_CTX_set_dh_auto(sc->ctx_.get(), true));
    return;
  }",26,,859,2,,void
32253,BLOCK,9,,"{
    BIOPointer bio(LoadBIO(env, args[0]));
    if (!bio)
      return;

    dh.reset(PEM_read_bio_DHparams(bio.get(), nullptr, nullptr, nullptr));
  }",3,,865,9,,void
32264,BLOCK,-1,,<empty>,7,,868,2,,void
32281,BLOCK,-1,,<empty>,5,,876,2,,void
32302,BLOCK,-1,,"{
    return THROW_ERR_INVALID_ARG_VALUE(
        env, ""DH parameter is less than 1024 bits"");
  }",20,,881,2,,void
32308,BLOCK,-1,,<empty>,10,,884,1,,void
32313,BLOCK,-1,,"{
    args.GetReturnValue().Set(FIXED_ONE_BYTE_STRING(
        env->isolate(), ""DH parameter is less than 2048 bits""));
  }",27,,884,2,,void
32340,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_OPERATION_FAILED(
        env, ""Error setting temp DH parameter"");
  }",54,,889,2,,void
32349,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsInt32());

  int version = args[0].As<Int32>()->Value();

  CHECK(SSL_CTX_set_min_proto_version(sc->ctx_.get(), version));
}",74,,895,2,,void
32396,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsInt32());

  int version = args[0].As<Int32>()->Value();

  CHECK(SSL_CTX_set_max_proto_version(sc->ctx_.get(), version));
}",74,,907,2,,void
32443,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_EQ(args.Length(), 0);

  long version =  // NOLINT(runtime/int)
    SSL_CTX_get_min_proto_version(sc->ctx_.get());
  args.GetReturnValue().Set(static_cast<uint32_t>(version));
}",74,,919,2,,void
32482,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_EQ(args.Length(), 0);

  long version =  // NOLINT(runtime/int)
    SSL_CTX_get_max_proto_version(sc->ctx_.get());
  args.GetReturnValue().Set(static_cast<uint32_t>(version));
}",74,,930,2,,void
32521,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsNumber());

  int64_t val = args[0]->IntegerValue(env->context()).FromMaybe(0);

  SSL_CTX_set_options(sc->ctx_.get(),
                      static_cast<long>(val));  // NOLINT(runtime/int)
}",73,,941,2,,void
32582,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  Environment* env = sc->env();

  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());

  const Utf8Value sessionIdContext(env->isolate(), args[0]);
  const unsigned char* sid_ctx =
      reinterpret_cast<const unsigned char*>(*sessionIdContext);
  unsigned int sid_ctx_len = sessionIdContext.length();

  if (SSL_CTX_set_session_id_context(sc->ctx_.get(), sid_ctx, sid_ctx_len) == 1)
    return;

  BUF_MEM* mem;
  Local<String> message;

  BIOPointer bio(BIO_new(BIO_s_mem()));
  if (!bio) {
    message = FIXED_ONE_BYTE_STRING(env->isolate(),
                                    ""SSL_CTX_set_session_id_context error"");
  } else {
    ERR_print_errors(bio.get());
    BIO_get_mem_ptr(bio.get(), &mem);
    message = OneByteString(env->isolate(), mem->data, mem->length);
  }

  env->isolate()->ThrowException(Exception::TypeError(message));
}",46,,956,2,,void
32646,BLOCK,-1,,<empty>,5,,970,2,,void
32656,BLOCK,-1,,<empty>,,,,2,,<empty>
32662,BLOCK,-1,,"{
    message = FIXED_ONE_BYTE_STRING(env->isolate(),
                                    ""SSL_CTX_set_session_id_context error"");
  }",13,,976,2,,void
32672,BLOCK,-1,,"{
    ERR_print_errors(bio.get());
    BIO_get_mem_ptr(bio.get(), &mem);
    message = OneByteString(env->isolate(), mem->data, mem->length);
  }",10,,979,1,,void
32714,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsInt32());

  int32_t sessionTimeout = args[0].As<Int32>()->Value();
  SSL_CTX_set_timeout(sc->ctx_.get(), sessionTimeout);
}",80,,988,2,,void
32760,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  sc->Reset();
}",68,,999,2,,void
32777,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  std::vector<char> pass;
  bool ret = false;

  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  ClearErrorOnReturn clear_error_on_return;

  if (args.Length() < 1) {
    return THROW_ERR_MISSING_ARGS(env, ""PFX certificate argument is mandatory"");
  }

  BIOPointer in(LoadBIO(env, args[0]));
  if (!in) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(
        env, ""Unable to load PFX certificate"");
  }

  if (args.Length() >= 2) {
    THROW_AND_RETURN_IF_NOT_BUFFER(env, args[1], ""Pass phrase"");
    Local<ArrayBufferView> abv = args[1].As<ArrayBufferView>();
    size_t passlen = abv->ByteLength();
    pass.resize(passlen + 1);
    abv->CopyContents(pass.data(), passlen);
    pass[passlen] = '\0';
  }

  // Free previous certs
  sc->issuer_.reset();
  sc->cert_.reset();

  X509_STORE* cert_store = SSL_CTX_get_cert_store(sc->ctx_.get());

  DeleteFnPtr<PKCS12, PKCS12_free> p12;
  EVPKeyPointer pkey;
  X509Pointer ...",73,,1006,2,,void
32807,BLOCK,-1,,"{
    return THROW_ERR_MISSING_ARGS(env, ""PFX certificate argument is mandatory"");
  }",26,,1016,2,,void
32822,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_OPERATION_FAILED(
        env, ""Unable to load PFX certificate"");
  }",12,,1021,2,,void
32834,BLOCK,-1,,"{
    THROW_AND_RETURN_IF_NOT_BUFFER(env, args[1], ""Pass phrase"");
    Local<ArrayBufferView> abv = args[1].As<ArrayBufferView>();
    size_t passlen = abv->ByteLength();
    pass.resize(passlen + 1);
    abv->CopyContents(pass.data(), passlen);
    pass[passlen] = '\0';
  }",27,,1026,2,,void
33020,BLOCK,-1,,"{
    // Add CA certs too
    for (int i = 0; i < sk_X509_num(extra_certs.get()); i++) {
      X509* ca = sk_X509_value(extra_certs.get(), i);

      if (cert_store == GetOrCreateRootCertStore()) {
        cert_store = NewRootCertStore();
        SSL_CTX_set_cert_store(sc->ctx_.get(), cert_store);
      }
      X509_STORE_add_cert(cert_store, ca);
      SSL_CTX_add_client_CA(sc->ctx_.get(), ca);
    }
    ret = true;
  }",59,,1063,2,,void
33022,BLOCK,-1,,<empty>,5,,1065,1,,void
33036,BLOCK,4,,"{
      X509* ca = sk_X509_value(extra_certs.get(), i);

      if (cert_store == GetOrCreateRootCertStore()) {
        cert_store = NewRootCertStore();
        SSL_CTX_set_cert_store(sc->ctx_.get(), cert_store);
      }
      X509_STORE_add_cert(cert_store, ca);
      SSL_CTX_add_client_CA(sc->ctx_.get(), ca);
    }",62,,1065,4,,void
33050,BLOCK,-1,,"{
        cert_store = NewRootCertStore();
        SSL_CTX_set_cert_store(sc->ctx_.get(), cert_store);
      }",53,,1068,2,,void
33079,BLOCK,-1,,"{
    // TODO(@jasnell): Should this use ThrowCryptoError?
    unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
    const char* str = ERR_reason_error_string(err);
    str = str != nullptr ? str : ""Unknown error"";

    return env->ThrowError(str);
  }",13,,1078,2,,void
33107,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());

  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  MarkPopErrorOnReturn mark_pop_error_on_return;

  // SSL_CTX_set_client_cert_engine does not itself support multiple
  // calls by cleaning up before overwriting the client_cert_engine
  // internal context variable.
  // Instead of trying to fix up this problem we in turn also do not
  // support multiple calls to SetClientCertEngine.
  CHECK(!sc->client_cert_engine_provided_);

  CryptoErrorStore errors;
  const Utf8Value engine_id(env->isolate(), args[0]);
  EnginePointer engine = LoadEngineById(*engine_id, &errors);
  if (!engine) {
    Local<Value> exception;
    if (errors.ToException(env).ToLocal(&exception))
      env->isolate()->ThrowException(exception);
    return;
  }

  // Note that this takes another reference to `engine`.
  if (!SSL_CTX_set_client_cert_engine(sc->ctx_.get(), engine.get...",46,,1090,2,,void
33164,BLOCK,-1,,"{
    Local<Value> exception;
    if (errors.ToException(env).ToLocal(&exception))
      env->isolate()->ThrowException(exception);
    return;
  }",16,,1110,2,,void
33181,BLOCK,-1,,<empty>,7,,1113,2,,void
33204,BLOCK,-1,,<empty>,5,,1119,2,,void
33218,BLOCK,-1,,"{
  SecureContext* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  Local<Object> buff;
  if (!Buffer::New(wrap->env(), 48).ToLocal(&buff))
    return;

  memcpy(Buffer::Data(buff), wrap->ticket_key_name_, 16);
  memcpy(Buffer::Data(buff) + 16, wrap->ticket_key_hmac_, 16);
  memcpy(Buffer::Data(buff) + 32, wrap->ticket_key_aes_, 16);

  args.GetReturnValue().Set(buff);
}",76,,1124,2,,void
33248,BLOCK,-1,,<empty>,5,,1130,2,,void
33296,BLOCK,-1,,"{
  SecureContext* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK_GE(args.Length(), 1);  // Ticket keys argument is mandatory
  CHECK(args[0]->IsArrayBufferView());
  ArrayBufferViewContents<char> buf(args[0].As<ArrayBufferView>());

  CHECK_EQ(buf.length(), 48);

  memcpy(wrap->ticket_key_name_, buf.data(), 16);
  memcpy(wrap->ticket_key_hmac_, buf.data() + 16, 16);
  memcpy(wrap->ticket_key_aes_, buf.data() + 32, 16);

  args.GetReturnValue().Set(true);
}",76,,1139,2,,void
33375,BLOCK,-1,,"{
  SecureContext* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  SSL_CTX_set_tlsext_ticket_key_cb(wrap->ctx_.get(), TicketKeyCallback);
}",46,,1159,2,,void
33401,BLOCK,-1,,"{
  static const int kTicketPartSize = 16;

  SecureContext* sc = static_cast<SecureContext*>(
      SSL_CTX_get_app_data(SSL_get_SSL_CTX(ssl)));

  Environment* env = sc->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Value> argv[3];

  if (!Buffer::Copy(
          env,
          reinterpret_cast<char*>(name),
          kTicketPartSize).ToLocal(&argv[0]) ||
      !Buffer::Copy(
          env,
          reinterpret_cast<char*>(iv),
          kTicketPartSize).ToLocal(&argv[1])) {
    return -1;
  }

  argv[2] = Boolean::New(env->isolate(), enc != 0);

  Local<Value> ret;
  if (!node::MakeCallback(
          env->isolate(),
          sc->object(),
          env->ticketkeycallback_string(),
          arraysize(argv),
          argv,
          {0, 0}).ToLocal(&ret) ||
      !ret->IsArray()) {
    return -1;
  }
  Local<Array> arr = ret.As<Array>();

  Local<Value> val;
  if (!arr->Get(env->context(), kTicketKeyReturnIndex).ToL...",47,,1171,7,,void
33476,BLOCK,-1,,"{
    return -1;
  }",47,,1190,2,,void
33535,BLOCK,-1,,"{
    return -1;
  }",24,,1204,2,,void
33576,BLOCK,-1,,"{
    return -1;
  }",24,,1211,2,,void
33594,BLOCK,-1,,<empty>,5,,1217,2,,void
33647,BLOCK,-1,,"{
    return -1;
  }",47,,1224,2,,void
33653,BLOCK,-1,,"{
    Local<Value> name_val;
    Local<Value> iv_val;
    if (!arr->Get(env->context(), kTicketKeyNameIndex).ToLocal(&name_val) ||
        !arr->Get(env->context(), kTicketKeyIVIndex).ToLocal(&iv_val) ||
        Buffer::Length(name_val) != kTicketPartSize ||
        Buffer::Length(iv_val) != kTicketPartSize) {
      return -1;
    }

    name_val.As<ArrayBufferView>()->CopyContents(name, kTicketPartSize);
    iv_val.As<ArrayBufferView>()->CopyContents(iv, kTicketPartSize);
  }",12,,1228,2,,void
33712,BLOCK,-1,,"{
      return -1;
    }",52,,1234,2,,void
33757,BLOCK,-1,,"{
    EVP_EncryptInit_ex(ectx,
                       EVP_aes_128_cbc(),
                       nullptr,
                       aes_key.data(),
                       iv);
  }",12,,1250,2,,void
33768,BLOCK,-1,,"{
    EVP_DecryptInit_ex(ectx,
                       EVP_aes_128_cbc(),
                       nullptr,
                       aes_key.data(),
                       iv);
  }",10,,1256,1,,void
33789,BLOCK,-1,,"{
  SecureContext* sc = static_cast<SecureContext*>(
      SSL_CTX_get_app_data(SSL_get_SSL_CTX(ssl)));

  if (enc) {
    memcpy(name, sc->ticket_key_name_, sizeof(sc->ticket_key_name_));
    if (CSPRNG(iv, 16).is_err() ||
        EVP_EncryptInit_ex(
            ectx, EVP_aes_128_cbc(), nullptr, sc->ticket_key_aes_, iv) <= 0 ||
        HMAC_Init_ex(hctx,
                     sc->ticket_key_hmac_,
                     sizeof(sc->ticket_key_hmac_),
                     EVP_sha256(),
                     nullptr) <= 0) {
      return -1;
    }
    return 1;
  }

  if (memcmp(name, sc->ticket_key_name_, sizeof(sc->ticket_key_name_)) != 0) {
    // The ticket key name does not match. Discard the ticket.
    return 0;
  }

  if (EVP_DecryptInit_ex(ectx, EVP_aes_128_cbc(), nullptr, sc->ticket_key_aes_,
                         iv) <= 0 ||
      HMAC_Init_ex(hctx, sc->ticket_key_hmac_, sizeof(sc->ticket_key_hmac_),
                   EVP_sha256(), nullptr) <= 0) {
    return -1;
  }
  retur...",57,,1272,7,,void
33800,BLOCK,-1,,"{
    memcpy(name, sc->ticket_key_name_, sizeof(sc->ticket_key_name_));
    if (CSPRNG(iv, 16).is_err() ||
        EVP_EncryptInit_ex(
            ectx, EVP_aes_128_cbc(), nullptr, sc->ticket_key_aes_, iv) <= 0 ||
        HMAC_Init_ex(hctx,
                     sc->ticket_key_hmac_,
                     sizeof(sc->ticket_key_hmac_),
                     EVP_sha256(),
                     nullptr) <= 0) {
      return -1;
    }
    return 1;
  }",12,,1276,2,,void
33842,BLOCK,-1,,"{
      return -1;
    }",37,,1285,2,,void
33860,BLOCK,-1,,"{
    // The ticket key name does not match. Discard the ticket.
    return 0;
  }",78,,1291,2,,void
33888,BLOCK,-1,,"{
    return -1;
  }",49,,1299,2,,void
33898,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, info.This());
  Local<External> ext = External::New(info.GetIsolate(), sc->ctx_.get());
  info.GetReturnValue().Set(ext);
}",72,,1305,2,,void
33939,BLOCK,-1,,"{
  SecureContext* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  Environment* env = wrap->env();
  X509* cert;

  if (primary)
    cert = wrap->cert_.get();
  else
    cert = wrap->issuer_.get();
  if (cert == nullptr)
    return args.GetReturnValue().SetNull();

  int size = i2d_X509(cert, nullptr);
  Local<Object> buff;
  if (!Buffer::New(env, size).ToLocal(&buff))
    return;
  unsigned char* serialized = reinterpret_cast<unsigned char*>(
      Buffer::Data(buff));
  i2d_X509(cert, &serialized);

  args.GetReturnValue().Set(buff);
}",77,,1313,2,,void
33958,BLOCK,-1,,<empty>,5,,1320,2,,void
33968,BLOCK,-1,,<empty>,5,,1322,1,,void
33981,BLOCK,-1,,<empty>,5,,1324,2,,void
34014,BLOCK,-1,,<empty>,5,,1329,2,,void
34044,BLOCK,-1,,"{
  ERR_clear_error();
  MarkPopErrorOnReturn mark_pop_error_on_return;

  BIOPointer bio(BIO_new_file(file, ""r""));
  if (!bio)
    return ERR_get_error();

  while (X509Pointer x509 = X509Pointer(PEM_read_bio_X509(
             bio.get(), nullptr, NoPasswordCallback, nullptr))) {
    X509_STORE_add_cert(store, x509.get());
  }

  unsigned long err = ERR_peek_error();  // NOLINT(runtime/int)
  // Ignore error if its EOF/no start line found.
  if (ERR_GET_LIB(err) == ERR_LIB_PEM &&
      ERR_GET_REASON(err) == PEM_R_NO_START_LINE) {
    return 0;
  }

  return err;
}",23,,1340,3,,void
34055,BLOCK,-1,,<empty>,5,,1346,2,,void
34059,BLOCK,-1,,"{
    X509_STORE_add_cert(store, x509.get());
  }",65,,1349,1,,void
34080,BLOCK,-1,,"{
    return 0;
  }",51,,1356,2,,void
34089,BLOCK,-1,,"{
  if (file.empty()) return;
  ClearErrorOnReturn clear_error_on_return;
  X509_STORE* store = GetOrCreateRootCertStore();
  if (auto err = AddCertsFromFile(store, file.c_str())) {
    char buf[256];
    ERR_error_string_n(err, buf, sizeof(buf));
    fprintf(stderr,
            ""Warning: Ignoring extra certs from `%s`, load failed: %s\n"",
            file.c_str(),
            buf);
  } else {
    extra_root_certs_loaded = true;
  }
}",47,,1365,2,,void
34095,BLOCK,-1,,<empty>,21,,1366,2,,void
34103,BLOCK,-1,,<empty>,7,,1369,1,,void
34113,BLOCK,-1,,"{
    char buf[256];
    ERR_error_string_n(err, buf, sizeof(buf));
    fprintf(stderr,
            ""Warning: Ignoring extra certs from `%s`, load failed: %s\n"",
            file.c_str(),
            buf);
  }",57,,1369,2,,void
34129,BLOCK,-1,,"{
    extra_root_certs_loaded = true;
  }",10,,1376,1,,void
34137,BLOCK,-1,,"{
  return args.GetReturnValue().Set(extra_root_certs_loaded);
}",46,,1383,2,,void
34165,BLOCK,-1,,<empty>,1,,1,1,,ANY
34170,BLOCK,-1,,"{
    Local<FunctionTemplate> t = NewFunctionTemplate(isolate, callback);

    const PropertyAttribute attributes =
        static_cast<PropertyAttribute>(ReadOnly | DontDelete);

    t->InstanceTemplate()->SetInternalFieldCount(
        DiffieHellman::kInternalFieldCount);

    SetProtoMethod(isolate, t, ""generateKeys"", GenerateKeys);
    SetProtoMethod(isolate, t, ""computeSecret"", ComputeSecret);
    SetProtoMethodNoSideEffect(isolate, t, ""getPrime"", GetPrime);
    SetProtoMethodNoSideEffect(isolate, t, ""getGenerator"", GetGenerator);
    SetProtoMethodNoSideEffect(isolate, t, ""getPublicKey"", GetPublicKey);
    SetProtoMethodNoSideEffect(isolate, t, ""getPrivateKey"", GetPrivateKey);
    SetProtoMethod(isolate, t, ""setPublicKey"", SetPublicKey);
    SetProtoMethod(isolate, t, ""setPrivateKey"", SetPrivateKey);

    Local<FunctionTemplate> verify_error_getter_templ =
        FunctionTemplate::New(isolate,
                              DiffieHellman::VerifyErrorGetter,
                   ...",66,,64,3,,void
34297,BLOCK,-1,,"{
    const BIGNUM* p;
    DH_get0_pqg(dh, &p, nullptr, nullptr);
    return p;
  }",52,,355,2,,void
34312,BLOCK,-1,,"{
    const BIGNUM* g;
    DH_get0_pqg(dh, nullptr, nullptr, &g);
    return g;
  }",52,,363,2,,void
34327,BLOCK,-1,,"{
    const BIGNUM* pub_key;
    DH_get0_key(dh, &pub_key, nullptr);
    return pub_key;
  }",52,,371,2,,void
34341,BLOCK,-1,,"{
    const BIGNUM* priv_key;
    DH_get0_key(dh, nullptr, &priv_key);
    return priv_key;
  }",52,,379,2,,void
34356,BLOCK,-1,,"{ return DH_set0_key(dh, num, nullptr); }",34,,461,3,,void
34368,BLOCK,-1,,"{ return DH_set0_key(dh, nullptr, num); }",34,,467,3,,void
34397,BLOCK,-1,,<empty>,1,,1,1,,ANY
34405,BLOCK,-1,,"{
  // DH_size returns number of bytes in a prime number.
  // DH_compute_key returns number of bytes in a remainder of exponent, which
  // may have less bytes than a prime number. Therefore add 0-padding to the
  // allocated buffer.
  const size_t prime_size = length;
  if (remainder_size != prime_size) {
    CHECK_LT(remainder_size, prime_size);
    const size_t padding = prime_size - remainder_size;
    memmove(data + padding, data, remainder_size);
    memset(data, 0, padding);
  }
}",48,,41,4,,void
34414,BLOCK,-1,,"{
    CHECK_LT(remainder_size, prime_size);
    const size_t padding = prime_size - remainder_size;
    memmove(data + padding, data, remainder_size);
    memset(data, 0, padding);
  }",37,,47,2,,void
34439,BLOCK,-1,,"{
  MakeWeak();
}",46,,57,3,,void
34444,BLOCK,-1,,"{
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();
  auto make = [&](Local<String> name, FunctionCallback callback) {
    Local<FunctionTemplate> t = NewFunctionTemplate(isolate, callback);

    const PropertyAttribute attributes =
        static_cast<PropertyAttribute>(ReadOnly | DontDelete);

    t->InstanceTemplate()->SetInternalFieldCount(
        DiffieHellman::kInternalFieldCount);

    SetProtoMethod(isolate, t, ""generateKeys"", GenerateKeys);
    SetProtoMethod(isolate, t, ""computeSecret"", ComputeSecret);
    SetProtoMethodNoSideEffect(isolate, t, ""getPrime"", GetPrime);
    SetProtoMethodNoSideEffect(isolate, t, ""getGenerator"", GetGenerator);
    SetProtoMethodNoSideEffect(isolate, t, ""getPublicKey"", GetPublicKey);
    SetProtoMethodNoSideEffect(isolate, t, ""getPrivateKey"", GetPrivateKey);
    SetProtoMethod(isolate, t, ""setPublicKey"", SetPublicKey);
    SetProtoMethod(isolate, t, ""setPrivateKey"", SetPrivateKey);

    Local<FunctionTemplate> ver...",72,,61,3,,void
34510,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(DiffieHellmanGroup);

  registry->Register(GenerateKeys);
  registry->Register(ComputeSecret);
  registry->Register(GetPrime);
  registry->Register(GetGenerator);
  registry->Register(GetPublicKey);
  registry->Register(GetPrivateKey);
  registry->Register(SetPublicKey);
  registry->Register(SetPrivateKey);

  registry->Register(DiffieHellman::VerifyErrorGetter);
  registry->Register(DiffieHellman::Stateless);

  DHKeyPairGenJob::RegisterExternalReferences(registry);
  DHKeyExportJob::RegisterExternalReferences(registry);
  DHBitsJob::RegisterExternalReferences(registry);
}",42,,112,2,,void
34595,BLOCK,-1,,"{
  dh_.reset(DH_new());
  if (!DH_generate_parameters_ex(dh_.get(), primeLength, g, nullptr))
    return false;
  return VerifyContext();
}",50,,133,3,,void
34611,BLOCK,-1,,<empty>,5,,136,2,,void
34620,BLOCK,-1,,"{
  tracker->TrackFieldWithSize(""dh"", dh_ ? kSizeOf_DH : 0);
}",62,,140,2,,void
34635,BLOCK,-1,,"{
  dh_.reset(DH_new());
  CHECK_GE(g, 2);
  BignumPointer bn_g(BN_new());
  return bn_g && BN_set_word(bn_g.get(), g) &&
         DH_set0_pqg(dh_.get(), bn_p.release(), nullptr, bn_g.release()) &&
         VerifyContext();
}",55,,144,3,,void
34679,BLOCK,-1,,"{
  dh_.reset(DH_new());
  if (p_len <= 0) {
    ERR_put_error(ERR_LIB_BN, BN_F_BN_GENERATE_PRIME_EX,
      BN_R_BITS_TOO_SMALL, __FILE__, __LINE__);
    return false;
  }
  if (g <= 1) {
    ERR_put_error(ERR_LIB_DH, DH_F_DH_BUILTIN_GENPARAMS,
      DH_R_BAD_GENERATOR, __FILE__, __LINE__);
    return false;
  }
  BIGNUM* bn_p =
      BN_bin2bn(reinterpret_cast<const unsigned char*>(p), p_len, nullptr);
  BIGNUM* bn_g = BN_new();
  if (!BN_set_word(bn_g, g) ||
      !DH_set0_pqg(dh_.get(), bn_p, nullptr, bn_g)) {
    BN_free(bn_p);
    BN_free(bn_g);
    return false;
  }
  return VerifyContext();
}",59,,153,4,,void
34689,BLOCK,-1,,"{
    ERR_put_error(ERR_LIB_BN, BN_F_BN_GENERATE_PRIME_EX,
      BN_R_BITS_TOO_SMALL, __FILE__, __LINE__);
    return false;
  }",19,,155,2,,void
34695,BLOCK,1,,<empty>,,,,1,,void
34698,BLOCK,1,,<empty>,,,,1,,void
34706,BLOCK,-1,,"{
    ERR_put_error(ERR_LIB_DH, DH_F_DH_BUILTIN_GENPARAMS,
      DH_R_BAD_GENERATOR, __FILE__, __LINE__);
    return false;
  }",15,,160,2,,void
34712,BLOCK,1,,<empty>,,,,1,,void
34715,BLOCK,1,,<empty>,,,,1,,void
34747,BLOCK,-1,,"{
    BN_free(bn_p);
    BN_free(bn_g);
    return false;
  }",53,,169,2,,void
34763,BLOCK,-1,,"{
  dh_.reset(DH_new());
  if (p_len <= 0) {
    ERR_put_error(ERR_LIB_BN, BN_F_BN_GENERATE_PRIME_EX,
      BN_R_BITS_TOO_SMALL, __FILE__, __LINE__);
    return false;
  }
  if (g_len <= 0) {
    ERR_put_error(ERR_LIB_DH, DH_F_DH_BUILTIN_GENPARAMS,
      DH_R_BAD_GENERATOR, __FILE__, __LINE__);
    return false;
  }
  BIGNUM* bn_g =
      BN_bin2bn(reinterpret_cast<const unsigned char*>(g), g_len, nullptr);
  if (BN_is_zero(bn_g) || BN_is_one(bn_g)) {
    BN_free(bn_g);
    ERR_put_error(ERR_LIB_DH, DH_F_DH_BUILTIN_GENPARAMS,
      DH_R_BAD_GENERATOR, __FILE__, __LINE__);
    return false;
  }
  BIGNUM* bn_p =
      BN_bin2bn(reinterpret_cast<const unsigned char*>(p), p_len, nullptr);
  if (!DH_set0_pqg(dh_.get(), bn_p, nullptr, bn_g)) {
    BN_free(bn_p);
    BN_free(bn_g);
    return false;
  }
  return VerifyContext();
}",78,,177,5,,void
34773,BLOCK,-1,,"{
    ERR_put_error(ERR_LIB_BN, BN_F_BN_GENERATE_PRIME_EX,
      BN_R_BITS_TOO_SMALL, __FILE__, __LINE__);
    return false;
  }",19,,179,2,,void
34779,BLOCK,1,,<empty>,,,,1,,void
34782,BLOCK,1,,<empty>,,,,1,,void
34790,BLOCK,-1,,"{
    ERR_put_error(ERR_LIB_DH, DH_F_DH_BUILTIN_GENPARAMS,
      DH_R_BAD_GENERATOR, __FILE__, __LINE__);
    return false;
  }",19,,184,2,,void
34796,BLOCK,1,,<empty>,,,,1,,void
34799,BLOCK,1,,<empty>,,,,1,,void
34818,BLOCK,-1,,"{
    BN_free(bn_g);
    ERR_put_error(ERR_LIB_DH, DH_F_DH_BUILTIN_GENPARAMS,
      DH_R_BAD_GENERATOR, __FILE__, __LINE__);
    return false;
  }",44,,191,2,,void
34826,BLOCK,1,,<empty>,,,,1,,void
34829,BLOCK,1,,<empty>,,,,1,,void
34852,BLOCK,-1,,"{
    BN_free(bn_p);
    BN_free(bn_g);
    return false;
  }",53,,199,2,,void
34868,BLOCK,-1,,"{
  return BignumPointer(p(nullptr));
}",46,,210,1,,void
34876,BLOCK,-1,,<empty>,,,,1,,<empty>
34881,BLOCK,-1,,"{
#define V(n, p)                                                                \
  if (StringEqualNoCase(name, n)) return InstantiateStandardizedGroup<p>
  V(""modp1"", BN_get_rfc2409_prime_768);
  V(""modp2"", BN_get_rfc2409_prime_1024);
  V(""modp5"", BN_get_rfc3526_prime_1536);
  V(""modp14"", BN_get_rfc3526_prime_2048);
  V(""modp15"", BN_get_rfc3526_prime_3072);
  V(""modp16"", BN_get_rfc3526_prime_4096);
  V(""modp17"", BN_get_rfc3526_prime_6144);
  V(""modp18"", BN_get_rfc3526_prime_8192);
#undef V
  return nullptr;
}",79,,218,2,,void
34884,BLOCK,1,,<empty>,,,,2,,void
34889,BLOCK,-1,,<empty>,3,,221,2,,void
34894,BLOCK,1,,<empty>,,,,2,,void
34899,BLOCK,-1,,<empty>,3,,222,2,,void
34904,BLOCK,1,,<empty>,,,,2,,void
34909,BLOCK,-1,,<empty>,3,,223,2,,void
34914,BLOCK,1,,<empty>,,,,2,,void
34919,BLOCK,-1,,<empty>,3,,224,2,,void
34924,BLOCK,1,,<empty>,,,,2,,void
34929,BLOCK,-1,,<empty>,3,,225,2,,void
34934,BLOCK,1,,<empty>,,,,2,,void
34939,BLOCK,-1,,<empty>,3,,226,2,,void
34944,BLOCK,1,,<empty>,,,,2,,void
34949,BLOCK,-1,,<empty>,3,,227,2,,void
34954,BLOCK,1,,<empty>,,,,2,,void
34959,BLOCK,-1,,<empty>,3,,228,2,,void
34968,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  DiffieHellman* diffieHellman = new DiffieHellman(env, args.This());

  CHECK_EQ(args.Length(), 1);
  THROW_AND_RETURN_IF_NOT_STRING(env, args[0], ""Group name"");

  bool initialized = false;

  const node::Utf8Value group_name(env->isolate(), args[0]);
  auto group = FindDiffieHellmanGroup(*group_name);
  if (group == nullptr)
    return THROW_ERR_CRYPTO_UNKNOWN_DH_GROUP(env);

  initialized = diffieHellman->Init(group(), kStandardizedGenerator);
  if (!initialized)
    THROW_ERR_CRYPTO_INITIALIZATION_FAILED(env);
}",46,,234,2,,void
35022,BLOCK,-1,,<empty>,5,,246,2,,void
35037,BLOCK,-1,,<empty>,5,,250,2,,void
35044,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  DiffieHellman* diffieHellman =
      new DiffieHellman(env, args.This());
  bool initialized = false;

  if (args.Length() == 2) {
    if (args[0]->IsInt32()) {
      if (args[1]->IsInt32()) {
        initialized = diffieHellman->Init(args[0].As<Int32>()->Value(),
                                          args[1].As<Int32>()->Value());
      }
    } else {
      ArrayBufferOrViewContents<char> arg0(args[0]);
      if (UNLIKELY(!arg0.CheckSizeInt32()))
        return THROW_ERR_OUT_OF_RANGE(env, ""prime is too big"");
      if (args[1]->IsInt32()) {
        initialized = diffieHellman->Init(arg0.data(),
                                          arg0.size(),
                                          args[1].As<Int32>()->Value());
      } else {
        ArrayBufferOrViewContents<char> arg1(args[1]);
        if (UNLIKELY(!arg1.CheckSizeInt32()))
          return THROW_ERR_OUT_OF_RANGE(env, ""generator is too big"");
        initialized ...",66,,254,2,,void
35074,BLOCK,-1,,"{
    if (args[0]->IsInt32()) {
      if (args[1]->IsInt32()) {
        initialized = diffieHellman->Init(args[0].As<Int32>()->Value(),
                                          args[1].As<Int32>()->Value());
      }
    } else {
      ArrayBufferOrViewContents<char> arg0(args[0]);
      if (UNLIKELY(!arg0.CheckSizeInt32()))
        return THROW_ERR_OUT_OF_RANGE(env, ""prime is too big"");
      if (args[1]->IsInt32()) {
        initialized = diffieHellman->Init(arg0.data(),
                                          arg0.size(),
                                          args[1].As<Int32>()->Value());
      } else {
        ArrayBufferOrViewContents<char> arg1(args[1]);
        if (UNLIKELY(!arg1.CheckSizeInt32()))
          return THROW_ERR_OUT_OF_RANGE(env, ""generator is too big"");
        initialized = diffieHellman->Init(arg0.data(), arg0.size(),
                                          arg1.data(), arg1.size());
      }
    }
  }",27,,260,2,,void
35082,BLOCK,-1,,"{
      if (args[1]->IsInt32()) {
        initialized = diffieHellman->Init(args[0].As<Int32>()->Value(),
                                          args[1].As<Int32>()->Value());
      }
    }",29,,261,2,,void
35090,BLOCK,-1,,"{
        initialized = diffieHellman->Init(args[0].As<Int32>()->Value(),
                                          args[1].As<Int32>()->Value());
      }",31,,262,2,,void
35116,BLOCK,-1,,"{
      ArrayBufferOrViewContents<char> arg0(args[0]);
      if (UNLIKELY(!arg0.CheckSizeInt32()))
        return THROW_ERR_OUT_OF_RANGE(env, ""prime is too big"");
      if (args[1]->IsInt32()) {
        initialized = diffieHellman->Init(arg0.data(),
                                          arg0.size(),
                                          args[1].As<Int32>()->Value());
      } else {
        ArrayBufferOrViewContents<char> arg1(args[1]);
        if (UNLIKELY(!arg1.CheckSizeInt32()))
          return THROW_ERR_OUT_OF_RANGE(env, ""generator is too big"");
        initialized = diffieHellman->Init(arg0.data(), arg0.size(),
                                          arg1.data(), arg1.size());
      }
    }",12,,266,1,,void
35129,BLOCK,-1,,<empty>,9,,269,2,,void
35141,BLOCK,-1,,"{
        initialized = diffieHellman->Init(arg0.data(),
                                          arg0.size(),
                                          args[1].As<Int32>()->Value());
      }",31,,270,2,,void
35166,BLOCK,-1,,"{
        ArrayBufferOrViewContents<char> arg1(args[1]);
        if (UNLIKELY(!arg1.CheckSizeInt32()))
          return THROW_ERR_OUT_OF_RANGE(env, ""generator is too big"");
        initialized = diffieHellman->Init(arg0.data(), arg0.size(),
                                          arg1.data(), arg1.size());
      }",14,,274,1,,void
35179,BLOCK,-1,,<empty>,11,,277,2,,void
35209,BLOCK,-1,,"{
    return ThrowCryptoError(env, ERR_get_error(), ""Initialization failed"");
  }",21,,284,2,,void
35219,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  DiffieHellman* diffieHellman;
  ASSIGN_OR_RETURN_UNWRAP(&diffieHellman, args.Holder());

  if (!DH_generate_key(diffieHellman->dh_.get())) {
    return ThrowCryptoError(env, ERR_get_error(), ""Key generation failed"");
  }

  const BIGNUM* pub_key;
  DH_get0_key(diffieHellman->dh_.get(), &pub_key, nullptr);

  std::unique_ptr<BackingStore> bs;
  {
    const int size = BN_num_bytes(pub_key);
    CHECK_GE(size, 0);
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), size);
  }

  CHECK_EQ(static_cast<int>(bs->ByteLength()),
           BN_bn2binpad(pub_key,
                        static_cast<unsigned char*>(bs->Data()),
                        bs->ByteLength()));

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  Local<Value> buffer;
  if (!Buffer::New(env, ab, 0, ab->ByteLength()).ToLocal(&buffer)) return;
  args.GetReturnValue()....",75,,290,2,,void
35245,BLOCK,-1,,"{
    return ThrowCryptoError(env, ERR_get_error(), ""Key generation failed"");
  }",51,,296,2,,void
35269,BLOCK,9,,"{
    const int size = BN_num_bytes(pub_key);
    CHECK_GE(size, 0);
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), size);
  }",3,,304,9,,void
35356,BLOCK,-1,,<empty>,68,,318,2,,void
35372,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  DiffieHellman* dh;
  ASSIGN_OR_RETURN_UNWRAP(&dh, args.Holder());

  const BIGNUM* num = get_field(dh->dh_.get());
  if (num == nullptr)
    return THROW_ERR_CRYPTO_INVALID_STATE(env, err_if_null);

  std::unique_ptr<BackingStore> bs;
  {
    const int size = BN_num_bytes(num);
    CHECK_GE(size, 0);
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), size);
  }

  CHECK_EQ(static_cast<int>(bs->ByteLength()),
           BN_bn2binpad(num,
                        static_cast<unsigned char*>(bs->Data()),
                        bs->ByteLength()));

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  Local<Value> buffer;
  if (!Buffer::New(env, ab, 0, ab->ByteLength()).ToLocal(&buffer)) return;
  args.GetReturnValue().Set(buffer);
}",55,,325,4,,void
35403,BLOCK,-1,,<empty>,5,,333,2,,void
35415,BLOCK,9,,"{
    const int size = BN_num_bytes(num);
    CHECK_GE(size, 0);
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), size);
  }",3,,336,9,,void
35502,BLOCK,-1,,<empty>,68,,350,2,,void
35516,BLOCK,-1,,"{
  GetField(args, [](const DH* dh) -> const BIGNUM* {
    const BIGNUM* p;
    DH_get0_pqg(dh, &p, nullptr, nullptr);
    return p;
  }, ""p is null"");
}",71,,354,2,,void
35525,BLOCK,-1,,"{
  GetField(args, [](const DH* dh) -> const BIGNUM* {
    const BIGNUM* g;
    DH_get0_pqg(dh, nullptr, nullptr, &g);
    return g;
  }, ""g is null"");
}",75,,362,2,,void
35534,BLOCK,-1,,"{
  GetField(args, [](const DH* dh) -> const BIGNUM* {
    const BIGNUM* pub_key;
    DH_get0_key(dh, &pub_key, nullptr);
    return pub_key;
  }, ""No public key - did you forget to generate one?"");
}",75,,370,2,,void
35543,BLOCK,-1,,"{
  GetField(args, [](const DH* dh) -> const BIGNUM* {
    const BIGNUM* priv_key;
    DH_get0_key(dh, nullptr, &priv_key);
    return priv_key;
  }, ""No private key - did you forget to generate one?"");
}",76,,378,2,,void
35552,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  DiffieHellman* diffieHellman;
  ASSIGN_OR_RETURN_UNWRAP(&diffieHellman, args.Holder());

  ClearErrorOnReturn clear_error_on_return;

  CHECK_EQ(args.Length(), 1);
  ArrayBufferOrViewContents<unsigned char> key_buf(args[0]);
  if (UNLIKELY(!key_buf.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""secret is too big"");
  BignumPointer key(BN_bin2bn(key_buf.data(), key_buf.size(), nullptr));

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(),
                                      DH_size(diffieHellman->dh_.get()));
  }

  int size = DH_compute_key(static_cast<unsigned char*>(bs->Data()),
                            key.get(),
                            diffieHellman->dh_.get());

  if (size == -1) {
    int checkResult;
    int checked;

    checked = DH_check_pub_key(diffieHellman->dh_.get(),
            ...",76,,386,2,,void
35588,BLOCK,-1,,<empty>,5,,397,2,,void
35612,BLOCK,13,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(),
                                      DH_size(diffieHellman->dh_.get()));
  }",3,,401,13,,void
35661,BLOCK,-1,,"{
    int checkResult;
    int checked;

    checked = DH_check_pub_key(diffieHellman->dh_.get(),
                               key.get(),
                               &checkResult);

    if (!checked) {
      return ThrowCryptoError(env, ERR_get_error(), ""Invalid Key"");
    } else if (checkResult) {
      if (checkResult & DH_CHECK_PUBKEY_TOO_SMALL) {
        return THROW_ERR_CRYPTO_INVALID_KEYLEN(env,
            ""Supplied key is too small"");
      } else if (checkResult & DH_CHECK_PUBKEY_TOO_LARGE) {
        return THROW_ERR_CRYPTO_INVALID_KEYLEN(env,
            ""Supplied key is too large"");
      }
    }

    return THROW_ERR_CRYPTO_INVALID_KEYTYPE(env);
  }",19,,411,2,,void
35682,BLOCK,-1,,"{
      return ThrowCryptoError(env, ERR_get_error(), ""Invalid Key"");
    }",19,,419,2,,void
35689,BLOCK,-1,,<empty>,12,,421,1,,void
35692,BLOCK,-1,,"{
      if (checkResult & DH_CHECK_PUBKEY_TOO_SMALL) {
        return THROW_ERR_CRYPTO_INVALID_KEYLEN(env,
            ""Supplied key is too small"");
      } else if (checkResult & DH_CHECK_PUBKEY_TOO_LARGE) {
        return THROW_ERR_CRYPTO_INVALID_KEYLEN(env,
            ""Supplied key is too large"");
      }
    }",29,,421,2,,void
35697,BLOCK,-1,,"{
        return THROW_ERR_CRYPTO_INVALID_KEYLEN(env,
            ""Supplied key is too small"");
      }",52,,422,2,,void
35703,BLOCK,-1,,<empty>,14,,425,1,,void
35708,BLOCK,-1,,"{
        return THROW_ERR_CRYPTO_INVALID_KEYLEN(env,
            ""Supplied key is too large"");
      }",59,,425,2,,void
35773,BLOCK,-1,,<empty>,68,,441,2,,void
35789,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  DiffieHellman* dh;
  ASSIGN_OR_RETURN_UNWRAP(&dh, args.Holder());
  CHECK_EQ(args.Length(), 1);
  ArrayBufferOrViewContents<unsigned char> buf(args[0]);
  if (UNLIKELY(!buf.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""buf is too big"");
  BIGNUM* num = BN_bin2bn(buf.data(), buf.size(), nullptr);
  CHECK_NOT_NULL(num);
  CHECK_EQ(1, set_field(dh->dh_.get(), num));
}",78,,446,4,,void
35824,BLOCK,-1,,<empty>,5,,453,2,,void
35858,BLOCK,-1,,"{
  SetKey(args,
         [](DH* dh, BIGNUM* num) { return DH_set0_key(dh, num, nullptr); },
         ""Public key"");
}",75,,459,2,,void
35867,BLOCK,-1,,"{
  SetKey(args,
         [](DH* dh, BIGNUM* num) { return DH_set0_key(dh, nullptr, num); },
         ""Private key"");
}",76,,465,2,,void
35876,BLOCK,-1,,"{
  HandleScope scope(args.GetIsolate());

  DiffieHellman* diffieHellman;
  ASSIGN_OR_RETURN_UNWRAP(&diffieHellman, args.Holder());

  args.GetReturnValue().Set(diffieHellman->verifyError_);
}",80,,471,2,,void
35904,BLOCK,-1,,"{
  int codes;
  if (!DH_check(dh_.get(), &codes))
    return false;
  verifyError_ = codes;
  return true;
}",37,,480,1,,void
35915,BLOCK,-1,,<empty>,5,,483,2,,void
35930,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  if (args[*offset]->IsString()) {
    Utf8Value group_name(env->isolate(), args[*offset]);
    auto group = FindDiffieHellmanGroup(*group_name);
    if (group == nullptr) {
      THROW_ERR_CRYPTO_UNKNOWN_DH_GROUP(env);
      return Nothing<bool>();
    }

    params->params.prime = group();
    params->params.generator = kStandardizedGenerator;
    *offset += 1;
  } else {
    if (args[*offset]->IsInt32()) {
      int size = args[*offset].As<Int32>()->Value();
      if (size < 0) {
        THROW_ERR_OUT_OF_RANGE(env, ""Invalid prime size"");
        return Nothing<bool>();
      }
      params->params.prime = size;
    } else {
      ArrayBufferOrViewContents<unsigned char> input(args[*offset]);
      if (UNLIKELY(!input.CheckSizeInt32())) {
        THROW_ERR_OUT_OF_RANGE(env, ""prime is too big"");
        return Nothing<bool>();
      }
      params->params.prime = BignumPointer(
          BN_bin2bn(input.data(), input.size(), nu...",33,,506,5,,void
35947,BLOCK,-1,,"{
    Utf8Value group_name(env->isolate(), args[*offset]);
    auto group = FindDiffieHellmanGroup(*group_name);
    if (group == nullptr) {
      THROW_ERR_CRYPTO_UNKNOWN_DH_GROUP(env);
      return Nothing<bool>();
    }

    params->params.prime = group();
    params->params.generator = kStandardizedGenerator;
    *offset += 1;
  }",34,,509,2,,void
35968,BLOCK,-1,,"{
      THROW_ERR_CRYPTO_UNKNOWN_DH_GROUP(env);
      return Nothing<bool>();
    }",27,,512,2,,void
35992,BLOCK,-1,,"{
    if (args[*offset]->IsInt32()) {
      int size = args[*offset].As<Int32>()->Value();
      if (size < 0) {
        THROW_ERR_OUT_OF_RANGE(env, ""Invalid prime size"");
        return Nothing<bool>();
      }
      params->params.prime = size;
    } else {
      ArrayBufferOrViewContents<unsigned char> input(args[*offset]);
      if (UNLIKELY(!input.CheckSizeInt32())) {
        THROW_ERR_OUT_OF_RANGE(env, ""prime is too big"");
        return Nothing<bool>();
      }
      params->params.prime = BignumPointer(
          BN_bin2bn(input.data(), input.size(), nullptr));
    }

    CHECK(args[*offset + 1]->IsInt32());
    params->params.generator = args[*offset + 1].As<Int32>()->Value();
    *offset += 2;
  }",10,,520,1,,void
36001,BLOCK,-1,,"{
      int size = args[*offset].As<Int32>()->Value();
      if (size < 0) {
        THROW_ERR_OUT_OF_RANGE(env, ""Invalid prime size"");
        return Nothing<bool>();
      }
      params->params.prime = size;
    }",35,,521,2,,void
36019,BLOCK,-1,,"{
        THROW_ERR_OUT_OF_RANGE(env, ""Invalid prime size"");
        return Nothing<bool>();
      }",21,,523,2,,void
36033,BLOCK,-1,,"{
      ArrayBufferOrViewContents<unsigned char> input(args[*offset]);
      if (UNLIKELY(!input.CheckSizeInt32())) {
        THROW_ERR_OUT_OF_RANGE(env, ""prime is too big"");
        return Nothing<bool>();
      }
      params->params.prime = BignumPointer(
          BN_bin2bn(input.data(), input.size(), nullptr));
    }",12,,528,1,,void
36047,BLOCK,-1,,"{
        THROW_ERR_OUT_OF_RANGE(env, ""prime is too big"");
        return Nothing<bool>();
      }",46,,530,2,,void
36109,BLOCK,-1,,"{
  EVPKeyPointer key_params;
  if (BignumPointer* prime_fixed_value =
          std::get_if<BignumPointer>(&params->params.prime)) {
    DHPointer dh(DH_new());
    if (!dh)
      return EVPKeyCtxPointer();

    BIGNUM* prime = prime_fixed_value->get();
    BignumPointer bn_g(BN_new());
    if (!BN_set_word(bn_g.get(), params->params.generator) ||
        !DH_set0_pqg(dh.get(), prime, nullptr, bn_g.get())) {
      return EVPKeyCtxPointer();
    }

    prime_fixed_value->release();
    bn_g.release();

    key_params = EVPKeyPointer(EVP_PKEY_new());
    CHECK(key_params);
    CHECK_EQ(EVP_PKEY_assign_DH(key_params.get(), dh.release()), 1);
  } else if (int* prime_size = std::get_if<int>(&params->params.prime)) {
    EVPKeyCtxPointer param_ctx(EVP_PKEY_CTX_new_id(EVP_PKEY_DH, nullptr));
    EVP_PKEY* raw_params = nullptr;
    if (!param_ctx ||
        EVP_PKEY_paramgen_init(param_ctx.get()) <= 0 ||
        EVP_PKEY_CTX_set_dh_paramgen_prime_len(
            param_ctx.get(),
         ...",68,,546,2,,void
36112,BLOCK,-1,,<empty>,7,,548,1,,void
36128,BLOCK,-1,,"{
    DHPointer dh(DH_new());
    if (!dh)
      return EVPKeyCtxPointer();

    BIGNUM* prime = prime_fixed_value->get();
    BignumPointer bn_g(BN_new());
    if (!BN_set_word(bn_g.get(), params->params.generator) ||
        !DH_set0_pqg(dh.get(), prime, nullptr, bn_g.get())) {
      return EVPKeyCtxPointer();
    }

    prime_fixed_value->release();
    bn_g.release();

    key_params = EVPKeyPointer(EVP_PKEY_new());
    CHECK(key_params);
    CHECK_EQ(EVP_PKEY_assign_DH(key_params.get(), dh.release()), 1);
  }",62,,549,2,,void
36135,BLOCK,-1,,<empty>,7,,552,2,,void
36173,BLOCK,-1,,"{
      return EVPKeyCtxPointer();
    }",61,,557,2,,void
36202,BLOCK,-1,,<empty>,10,,567,1,,void
36204,BLOCK,-1,,<empty>,14,,567,1,,void
36218,BLOCK,-1,,"{
    EVPKeyCtxPointer param_ctx(EVP_PKEY_CTX_new_id(EVP_PKEY_DH, nullptr));
    EVP_PKEY* raw_params = nullptr;
    if (!param_ctx ||
        EVP_PKEY_paramgen_init(param_ctx.get()) <= 0 ||
        EVP_PKEY_CTX_set_dh_paramgen_prime_len(
            param_ctx.get(),
            *prime_size) <= 0 ||
        EVP_PKEY_CTX_set_dh_paramgen_generator(
            param_ctx.get(),
            params->params.generator) <= 0 ||
        EVP_PKEY_paramgen(param_ctx.get(), &raw_params) <= 0) {
      return EVPKeyCtxPointer();
    }

    key_params = EVPKeyPointer(raw_params);
  }",73,,567,2,,void
36272,BLOCK,-1,,"{
      return EVPKeyCtxPointer();
    }",63,,578,2,,void
36280,BLOCK,-1,,"{
    UNREACHABLE();
  }",10,,583,1,,void
36301,BLOCK,-1,,<empty>,5,,589,2,,void
36312,BLOCK,-1,,"{
  return Just(true);
}",32,,597,4,,void
36323,BLOCK,-1,,"{
  CHECK_NE(key_data->GetKeyType(), kKeyTypeSecret);

  switch (format) {
    case kWebCryptoKeyFormatPKCS8:
      if (key_data->GetKeyType() != kKeyTypePrivate)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_PKCS8_Export(key_data.get(), out);
    case kWebCryptoKeyFormatSPKI:
      if (key_data->GetKeyType() != kKeyTypePublic)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_SPKI_Export(key_data.get(), out);
    default:
      UNREACHABLE();
  }
}",22,,605,5,,void
36332,BLOCK,-1,,"{
    case kWebCryptoKeyFormatPKCS8:
      if (key_data->GetKeyType() != kKeyTypePrivate)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_PKCS8_Export(key_data.get(), out);
    case kWebCryptoKeyFormatSPKI:
      if (key_data->GetKeyType() != kKeyTypePublic)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_SPKI_Export(key_data.get(), out);
    default:
      UNREACHABLE();
  }",19,,608,2,,void
36342,BLOCK,-1,,<empty>,9,,611,2,,void
36363,BLOCK,-1,,<empty>,9,,615,2,,void
36383,BLOCK,-1,,"{
  size_t out_size;

  EVPKeyCtxPointer ctx(EVP_PKEY_CTX_new(our_key.get(), nullptr));
  if (!ctx ||
      EVP_PKEY_derive_init(ctx.get()) <= 0 ||
      EVP_PKEY_derive_set_peer(ctx.get(), their_key.get()) <= 0 ||
      EVP_PKEY_derive(ctx.get(), nullptr, &out_size) <= 0)
    return ByteSource();

  ByteSource::Builder out(out_size);
  if (EVP_PKEY_derive(ctx.get(), out.data<unsigned char>(), &out_size) <= 0) {
    return ByteSource();
  }

  ZeroPadDiffieHellmanSecret(out_size, out.data<char>(), out.size());
  return std::move(out).release();
}",38,,625,3,,void
36427,BLOCK,-1,,<empty>,5,,633,2,,void
36447,BLOCK,-1,,"{
    return ByteSource();
  }",78,,636,2,,void
36473,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsObject() && args[1]->IsObject());
  KeyObjectHandle* our_key_object;
  ASSIGN_OR_RETURN_UNWRAP(&our_key_object, args[0].As<Object>());
  CHECK_EQ(our_key_object->Data()->GetKeyType(), kKeyTypePrivate);
  KeyObjectHandle* their_key_object;
  ASSIGN_OR_RETURN_UNWRAP(&their_key_object, args[1].As<Object>());
  CHECK_NE(their_key_object->Data()->GetKeyType(), kKeyTypeSecret);

  ManagedEVPPKey our_key = our_key_object->Data()->GetAsymmetricKey();
  ManagedEVPPKey their_key = their_key_object->Data()->GetAsymmetricKey();

  Local<Value> out;
  if (!StatelessDiffieHellmanThreadsafe(our_key, their_key)
          .ToBuffer(env)
              .ToLocal(&out)) return;

  if (Buffer::Length(out) == 0)
    return ThrowCryptoError(env, ERR_get_error(), ""diffieHellman failed"");

  args.GetReturnValue().Set(out);
}",72,,645,2,,void
36573,BLOCK,-1,,<empty>,31,,662,2,,void
36583,BLOCK,-1,,<empty>,5,,665,2,,void
36604,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[offset]->IsObject());  // public key
  CHECK(args[offset + 1]->IsObject());  // private key

  KeyObjectHandle* private_key;
  KeyObjectHandle* public_key;

  ASSIGN_OR_RETURN_UNWRAP(&public_key, args[offset], Nothing<bool>());
  ASSIGN_OR_RETURN_UNWRAP(&private_key, args[offset + 1], Nothing<bool>());

  if (private_key->Data()->GetKeyType() != kKeyTypePrivate ||
      public_key->Data()->GetKeyType() != kKeyTypePublic) {
    THROW_ERR_CRYPTO_INVALID_KEYTYPE(env);
    return Nothing<bool>();
  }

  params->public_key = public_key->Data();
  params->private_key = private_key->Data();

  return Just(true);
}",27,,674,5,,void
36667,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_KEYTYPE(env);
    return Nothing<bool>();
  }",59,,687,2,,void
36698,BLOCK,-1,,"{
  *result = out->ToArrayBuffer(env);
  return Just(!result->IsEmpty());
}",35,,702,5,,void
36720,BLOCK,-1,,"{
  *out = StatelessDiffieHellmanThreadsafe(
      params.private_key->GetAsymmetricKey(),
      params.public_key->GetAsymmetricKey());
  return true;
}",22,,710,4,,void
36745,BLOCK,-1,,"{
  ManagedEVPPKey pkey = key->GetAsymmetricKey();
  CHECK_EQ(EVP_PKEY_id(pkey.get()), EVP_PKEY_DH);
  return Just(true);
}",27,,720,4,,void
36783,BLOCK,-1,,<empty>,1,,1,1,,ANY
36810,BLOCK,-1,,<empty>,1,,1,1,,ANY
36815,BLOCK,-1,,"{
  EVPKeyCtxPointer param_ctx(EVP_PKEY_CTX_new_id(EVP_PKEY_DSA, nullptr));
  EVP_PKEY* raw_params = nullptr;

  if (!param_ctx ||
      EVP_PKEY_paramgen_init(param_ctx.get()) <= 0 ||
      EVP_PKEY_CTX_set_dsa_paramgen_bits(
          param_ctx.get(),
          params->params.modulus_bits) <= 0) {
    return EVPKeyCtxPointer();
  }

  if (params->params.divisor_bits != -1) {
    if (EVP_PKEY_CTX_set_dsa_paramgen_q_bits(
            param_ctx.get(), params->params.divisor_bits) <= 0) {
      return EVPKeyCtxPointer();
    }
  }

  if (EVP_PKEY_paramgen(param_ctx.get(), &raw_params) <= 0)
    return EVPKeyCtxPointer();

  EVPKeyPointer key_params(raw_params);
  EVPKeyCtxPointer key_ctx(EVP_PKEY_CTX_new(key_params.get(), nullptr));

  if (!key_ctx || EVP_PKEY_keygen_init(key_ctx.get()) <= 0)
    return EVPKeyCtxPointer();

  return key_ctx;
}",70,,40,2,,void
36849,BLOCK,-1,,"{
    return EVPKeyCtxPointer();
  }",46,,48,2,,void
36861,BLOCK,-1,,"{
    if (EVP_PKEY_CTX_set_dsa_paramgen_q_bits(
            param_ctx.get(), params->params.divisor_bits) <= 0) {
      return EVPKeyCtxPointer();
    }
  }",42,,52,2,,void
36874,BLOCK,1,,<empty>,,,,4,,void
36890,BLOCK,-1,,"{
      return EVPKeyCtxPointer();
    }",65,,54,2,,void
36903,BLOCK,-1,,<empty>,5,,60,2,,void
36928,BLOCK,-1,,<empty>,5,,66,2,,void
36940,BLOCK,-1,,"{
  CHECK(args[*offset]->IsUint32());  // modulus bits
  CHECK(args[*offset + 1]->IsInt32());  // divisor bits

  params->params.modulus_bits = args[*offset].As<Uint32>()->Value();
  params->params.divisor_bits = args[*offset + 1].As<Int32>()->Value();
  CHECK_GE(params->params.divisor_bits, -1);

  *offset += 2;

  return Just(true);
}",34,,85,5,,void
37014,BLOCK,-1,,"{
  return Just(true);
}",33,,101,4,,void
37025,BLOCK,-1,,"{
  CHECK_NE(key_data->GetKeyType(), kKeyTypeSecret);

  switch (format) {
    case kWebCryptoKeyFormatRaw:
      // Not supported for RSA keys of either type
      return WebCryptoKeyExportStatus::FAILED;
    case kWebCryptoKeyFormatPKCS8:
      if (key_data->GetKeyType() != kKeyTypePrivate)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_PKCS8_Export(key_data.get(), out);
    case kWebCryptoKeyFormatSPKI:
      if (key_data->GetKeyType() != kKeyTypePublic)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_SPKI_Export(key_data.get(), out);
    default:
      UNREACHABLE();
  }
}",22,,109,5,,void
37034,BLOCK,-1,,"{
    case kWebCryptoKeyFormatRaw:
      // Not supported for RSA keys of either type
      return WebCryptoKeyExportStatus::FAILED;
    case kWebCryptoKeyFormatPKCS8:
      if (key_data->GetKeyType() != kKeyTypePrivate)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_PKCS8_Export(key_data.get(), out);
    case kWebCryptoKeyFormatSPKI:
      if (key_data->GetKeyType() != kKeyTypePublic)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_SPKI_Export(key_data.get(), out);
    default:
      UNREACHABLE();
  }",19,,112,2,,void
37050,BLOCK,-1,,<empty>,9,,118,2,,void
37071,BLOCK,-1,,<empty>,9,,122,2,,void
37091,BLOCK,-1,,"{
  const BIGNUM* p;  // Modulus length
  const BIGNUM* q;  // Divisor length

  ManagedEVPPKey m_pkey = key->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());
  int type = EVP_PKEY_id(m_pkey.get());
  CHECK(type == EVP_PKEY_DSA);

  const DSA* dsa = EVP_PKEY_get0_DSA(m_pkey.get());
  CHECK_NOT_NULL(dsa);

  DSA_get0_pqg(dsa, &p, &q, nullptr);

  size_t modulus_length = BN_num_bits(p);
  size_t divisor_length = BN_num_bits(q);

  if (target
          ->Set(
              env->context(),
              env->modulus_length_string(),
              Number::New(env->isolate(), static_cast<double>(modulus_length)))
          .IsNothing() ||
      target
          ->Set(
              env->context(),
              env->divisor_length_string(),
              Number::New(env->isolate(), static_cast<double>(divisor_length)))
          .IsNothing()) {
    return Nothing<bool>();
  }

  return Just(true);
}",27,,132,4,,void
37201,BLOCK,-1,,"{
    return Nothing<bool>();
  }",25,,160,2,,void
37213,BLOCK,-1,,"{
  DsaKeyPairGenJob::Initialize(env, target);
  DSAKeyExportJob::Initialize(env, target);
}",57,,168,3,,void
37230,BLOCK,-1,,"{
  DsaKeyPairGenJob::RegisterExternalReferences(registry);
  DSAKeyExportJob::RegisterExternalReferences(registry);
}",70,,173,2,,void
37259,BLOCK,-1,,<empty>,1,,1,1,,ANY
37263,BLOCK,-1,,"{
    return OneByteString(env->isolate(), OBJ_nid2sn(curve.nid));
  }",80,,115,2,,void
37311,BLOCK,-1,,<empty>,1,,1,1,,ANY
37316,BLOCK,-1,,"{
  int nid = EC_curve_nist2nid(name);
  if (nid == NID_undef)
    nid = OBJ_sn2nid(name);
  return nid;
}",40,,41,2,,void
37326,BLOCK,-1,,<empty>,5,,44,2,,void
37337,BLOCK,-1,,"{
  int nid;
  if (strcmp(name, ""Ed25519"") == 0) {
    nid = EVP_PKEY_ED25519;
  } else if (strcmp(name, ""Ed448"") == 0) {
    nid = EVP_PKEY_ED448;
  } else if (strcmp(name, ""X25519"") == 0) {
    nid = EVP_PKEY_X25519;
  } else if (strcmp(name, ""X448"") == 0) {
    nid = EVP_PKEY_X448;
  } else {
    nid = NID_undef;
  }
  return nid;
}",43,,48,2,,void
37345,BLOCK,-1,,"{
    nid = EVP_PKEY_ED25519;
  }",37,,50,2,,void
37350,BLOCK,-1,,<empty>,10,,52,1,,void
37357,BLOCK,-1,,"{
    nid = EVP_PKEY_ED448;
  }",42,,52,2,,void
37362,BLOCK,-1,,<empty>,10,,54,1,,void
37369,BLOCK,-1,,"{
    nid = EVP_PKEY_X25519;
  }",43,,54,2,,void
37374,BLOCK,-1,,<empty>,10,,56,1,,void
37381,BLOCK,-1,,"{
    nid = EVP_PKEY_X448;
  }",41,,56,2,,void
37386,BLOCK,-1,,"{
    nid = NID_undef;
  }",10,,58,1,,void
37397,BLOCK,-1,,"{
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);

  t->InstanceTemplate()->SetInternalFieldCount(ECDH::kInternalFieldCount);

  SetProtoMethod(isolate, t, ""generateKeys"", GenerateKeys);
  SetProtoMethod(isolate, t, ""computeSecret"", ComputeSecret);
  SetProtoMethodNoSideEffect(isolate, t, ""getPublicKey"", GetPublicKey);
  SetProtoMethodNoSideEffect(isolate, t, ""getPrivateKey"", GetPrivateKey);
  SetProtoMethod(isolate, t, ""setPublicKey"", SetPublicKey);
  SetProtoMethod(isolate, t, ""setPrivateKey"", SetPrivateKey);

  SetConstructorFunction(context, target, ""ECDH"", t);

  SetMethodNoSideEffect(context, target, ""ECDHConvertKey"", ECDH::ConvertKey);
  SetMethodNoSideEffect(context, target, ""getCurves"", ECDH::GetCurves);

  ECDHBitsJob::Initialize(env, target);
  ECKeyPairGenJob::Initialize(env, target);
  ECKeyExportJob::Initialize(env, target);

  NODE_DEFINE_CONSTANT(target, OPENSSL_EC_NAMED...",63,,64,3,,void
37506,BLOCK,1,,<empty>,,,,7,,void
37508,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, OPENSSL_EC_NAMED_CURVE)",3,,88,1,,void
37605,BLOCK,1,,<empty>,,,,7,,void
37607,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, OPENSSL_EC_EXPLICIT_CURVE)",3,,89,1,,void
37703,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(GenerateKeys);
  registry->Register(ComputeSecret);
  registry->Register(GetPublicKey);
  registry->Register(GetPrivateKey);
  registry->Register(SetPublicKey);
  registry->Register(SetPrivateKey);
  registry->Register(ECDH::ConvertKey);
  registry->Register(ECDH::GetCurves);

  ECDHBitsJob::RegisterExternalReferences(registry);
  ECKeyPairGenJob::RegisterExternalReferences(registry);
  ECKeyExportJob::RegisterExternalReferences(registry);
}",76,,92,2,,void
37772,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  const size_t num_curves = EC_get_builtin_curves(nullptr, 0);
  std::vector<EC_builtin_curve> curves(num_curves);
  CHECK_EQ(EC_get_builtin_curves(curves.data(), num_curves), num_curves);

  std::vector<Local<Value>> arr(num_curves);
  std::transform(curves.begin(), curves.end(), arr.begin(), [env](auto& curve) {
    return OneByteString(env->isolate(), OBJ_nid2sn(curve.nid));
  });
  args.GetReturnValue().Set(Array::New(env->isolate(), arr.data(), arr.size()));
}",63,,108,2,,void
37858,BLOCK,-1,,"{
  MakeWeak();
  CHECK_NOT_NULL(group_);
}",43,,124,4,,void
37865,BLOCK,-1,,"{
  tracker->TrackFieldWithSize(""key"", key_ ? kSizeOf_EC_KEY : 0);
}",53,,129,2,,void
37878,BLOCK,-1,,<empty>,15,,133,1,,void
37883,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  MarkPopErrorOnReturn mark_pop_error_on_return;

  // TODO(indutny): Support raw curves?
  CHECK(args[0]->IsString());
  node::Utf8Value curve(env->isolate(), args[0]);

  int nid = OBJ_sn2nid(*curve);
  if (nid == NID_undef)
    return THROW_ERR_CRYPTO_INVALID_CURVE(env);

  ECKeyPointer key(EC_KEY_new_by_curve_name(nid));
  if (!key)
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
      ""Failed to create key using named curve"");

  new ECDH(env, args.This(), std::move(key));
}",57,,135,2,,void
37919,BLOCK,-1,,<empty>,5,,146,2,,void
37930,BLOCK,-1,,<empty>,5,,150,2,,void
37951,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  ECDH* ecdh;
  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());

  if (!EC_KEY_generate_key(ecdh->key_.get()))
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""Failed to generate key"");
}",66,,156,2,,void
37977,BLOCK,-1,,<empty>,5,,163,2,,void
37988,BLOCK,-1,,"{
  int r;

  ECPointPointer pub(EC_POINT_new(group));
  if (!pub) {
    THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to allocate EC_POINT for a public key"");
    return pub;
  }

  ArrayBufferOrViewContents<unsigned char> input(buf);
  if (UNLIKELY(!input.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""buffer is too big"");
    return ECPointPointer();
  }
  r = EC_POINT_oct2point(
      group,
      pub.get(),
      input.data(),
      input.size(),
      nullptr);
  if (!r)
    return ECPointPointer();

  return pub;
}",54,,168,4,,void
37997,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to allocate EC_POINT for a public key"");
    return pub;
  }",13,,172,2,,void
38013,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""buffer is too big"");
    return ECPointPointer();
  }",42,,179,2,,void
38039,BLOCK,-1,,<empty>,5,,190,2,,void
38048,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(IsAnyByteSource(args[0]));

  ECDH* ecdh;
  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());

  MarkPopErrorOnReturn mark_pop_error_on_return;

  if (!ecdh->IsKeyPairValid())
    return THROW_ERR_CRYPTO_INVALID_KEYPAIR(env);

  ECPointPointer pub(
      ECDH::BufferToPoint(env,
                          ecdh->group_,
                          args[0]));
  if (!pub) {
    args.GetReturnValue().Set(
        FIXED_ONE_BYTE_STRING(env->isolate(),
        ""ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY""));
    return;
  }

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    // NOTE: field_size is in bits
    int field_size = EC_GROUP_get_degree(ecdh->group_);
    size_t out_len = (field_size + 7) / 8;
    bs = ArrayBuffer::NewBackingStore(env->isolate(), out_len);
  }

  if (!ECDH_compute_key(
          bs->Data(), bs->ByteLength(), pub.get(), ecdh->key_.get(), nullptr))
    r...",67,,195,2,,void
38077,BLOCK,-1,,<empty>,5,,206,2,,void
38097,BLOCK,-1,,"{
    args.GetReturnValue().Set(
        FIXED_ONE_BYTE_STRING(env->isolate(),
        ""ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY""));
    return;
  }",13,,212,2,,void
38119,BLOCK,12,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    // NOTE: field_size is in bits
    int field_size = EC_GROUP_get_degree(ecdh->group_);
    size_t out_len = (field_size + 7) / 8;
    bs = ArrayBuffer::NewBackingStore(env->isolate(), out_len);
  }",3,,220,12,,void
38174,BLOCK,-1,,<empty>,5,,230,2,,void
38221,BLOCK,-1,,<empty>,68,,234,2,,void
38235,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  // Conversion form
  CHECK_EQ(args.Length(), 1);

  ECDH* ecdh;
  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());

  const EC_GROUP* group = EC_KEY_get0_group(ecdh->key_.get());
  const EC_POINT* pub = EC_KEY_get0_public_key(ecdh->key_.get());
  if (pub == nullptr)
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to get ECDH public key"");

  CHECK(args[0]->IsUint32());
  uint32_t val = args[0].As<Uint32>()->Value();
  point_conversion_form_t form = static_cast<point_conversion_form_t>(val);

  const char* error;
  Local<Object> buf;
  if (!ECPointToBuffer(env, group, pub, form, &error).ToLocal(&buf))
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env, error);
  args.GetReturnValue().Set(buf);
}",66,,238,2,,void
38282,BLOCK,-1,,<empty>,5,,250,2,,void
38332,BLOCK,-1,,<empty>,5,,260,2,,void
38349,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  ECDH* ecdh;
  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());

  const BIGNUM* b = EC_KEY_get0_private_key(ecdh->key_.get());
  if (b == nullptr)
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to get ECDH private key"");

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), BN_num_bytes(b));
  }
  CHECK_EQ(static_cast<int>(bs->ByteLength()),
           BN_bn2binpad(
               b, static_cast<unsigned char*>(bs->Data()), bs->ByteLength()));

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  Local<Value> buffer;
  if (!Buffer::New(env, ab, 0, ab->ByteLength()).ToLocal(&buffer)) return;
  args.GetReturnValue().Set(buffer);
}",67,,264,2,,void
38380,BLOCK,-1,,<empty>,5,,272,2,,void
38392,BLOCK,9,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), BN_num_bytes(b));
  }",3,,276,9,,void
38472,BLOCK,-1,,<empty>,68,,286,2,,void
38486,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  ECDH* ecdh;
  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());

  ArrayBufferOrViewContents<unsigned char> priv_buffer(args[0]);
  if (UNLIKELY(!priv_buffer.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""key is too big"");

  BignumPointer priv(BN_bin2bn(
      priv_buffer.data(), priv_buffer.size(), nullptr));
  if (!priv) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to convert Buffer to BN"");
  }

  if (!ecdh->IsKeyValidForCurve(priv)) {
    return THROW_ERR_CRYPTO_INVALID_KEYTYPE(env,
        ""Private key is not valid for specified curve."");
  }

  ECKeyPointer new_key(EC_KEY_dup(ecdh->key_.get()));
  CHECK(new_key);

  int result = EC_KEY_set_private_key(new_key.get(), priv.get());
  priv.reset();

  if (!result) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to convert BN to a private key"");
  }

  MarkPopErrorOnReturn mark_pop_error_on_return;
  USE(&mark_pop_error_on_...",67,,290,2,,void
38515,BLOCK,-1,,<empty>,5,,298,2,,void
38535,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to convert Buffer to BN"");
  }",14,,302,2,,void
38547,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_INVALID_KEYTYPE(env,
        ""Private key is not valid for specified curve."");
  }",40,,307,2,,void
38582,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to convert BN to a private key"");
  }",16,,318,2,,void
38623,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to generate ECDH public key"");
  }",49,,333,2,,void
38639,BLOCK,-1,,<empty>,5,,339,2,,void
38668,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  ECDH* ecdh;
  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());

  CHECK(IsAnyByteSource(args[0]));

  MarkPopErrorOnReturn mark_pop_error_on_return;

  ECPointPointer pub(
      ECDH::BufferToPoint(env,
                          ecdh->group_,
                          args[0]));
  if (!pub) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to convert Buffer to EC_POINT"");
  }

  int r = EC_KEY_set_public_key(ecdh->key_.get(), pub.get());
  if (!r) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to set EC_POINT as the public key"");
  }
}",66,,346,2,,void
38707,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to convert Buffer to EC_POINT"");
  }",13,,360,2,,void
38729,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to set EC_POINT as the public key"");
  }",11,,366,2,,void
38738,BLOCK,-1,,"{
  CHECK(group_);
  CHECK(private_key);
  // Private keys must be in the range [1, n-1].
  // Ref: Section 3.2.1 - http://www.secg.org/sec1-v2.pdf
  if (BN_cmp(private_key.get(), BN_value_one()) < 0) {
    return false;
  }
  BignumPointer order(BN_new());
  CHECK(order);
  return EC_GROUP_get_order(group_, order.get(), nullptr) &&
         BN_cmp(private_key.get(), order.get()) < 0;
}",65,,372,2,,void
38751,BLOCK,-1,,"{
    return false;
  }",54,,377,2,,void
38782,BLOCK,-1,,"{
  MarkPopErrorOnReturn mark_pop_error_on_return;
  USE(&mark_pop_error_on_return);
  return 1 == EC_KEY_check_key(key_.get());
}",29,,386,1,,void
38799,BLOCK,-1,,"{
  MarkPopErrorOnReturn mark_pop_error_on_return;
  Environment* env = Environment::GetCurrent(args);

  CHECK_EQ(args.Length(), 3);
  CHECK(IsAnyByteSource(args[0]));

  ArrayBufferOrViewContents<char> args0(args[0]);
  if (UNLIKELY(!args0.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""key is too big"");
  if (args0.size() == 0)
    return args.GetReturnValue().SetEmptyString();

  node::Utf8Value curve(env->isolate(), args[1]);

  int nid = OBJ_sn2nid(*curve);
  if (nid == NID_undef)
    return THROW_ERR_CRYPTO_INVALID_CURVE(env);

  ECGroupPointer group(
      EC_GROUP_new_by_curve_name(nid));
  if (group == nullptr)
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""Failed to get EC_GROUP"");

  ECPointPointer pub(
      ECDH::BufferToPoint(env,
                          group.get(),
                          args[0]));

  if (pub == nullptr) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to convert Buffer to EC_POINT"");
  }

  CHECK(args[2]->IsUi...",64,,393,2,,void
38832,BLOCK,-1,,<empty>,5,,402,2,,void
38844,BLOCK,-1,,<empty>,5,,404,2,,void
38872,BLOCK,-1,,<empty>,5,,410,2,,void
38884,BLOCK,-1,,<empty>,5,,415,2,,void
38907,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to convert Buffer to EC_POINT"");
  }",23,,422,2,,void
38963,BLOCK,-1,,<empty>,5,,434,2,,void
38980,BLOCK,-1,,"{
  tracker->TrackField(""public"", public_);
  tracker->TrackField(""private"", private_);
}",63,,438,2,,void
39000,BLOCK,-1,,"{
  *result = out->ToArrayBuffer(env);
  return Just(!result->IsEmpty());
}",35,,447,5,,void
39023,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[offset]->IsString());  // curve name
  CHECK(args[offset + 1]->IsObject());  // public key
  CHECK(args[offset + 2]->IsObject());  // private key

  KeyObjectHandle* private_key;
  KeyObjectHandle* public_key;

  Utf8Value name(env->isolate(), args[offset]);

  ASSIGN_OR_RETURN_UNWRAP(&public_key, args[offset + 1], Nothing<bool>());
  ASSIGN_OR_RETURN_UNWRAP(&private_key, args[offset + 2], Nothing<bool>());

  if (private_key->Data()->GetKeyType() != kKeyTypePrivate ||
      public_key->Data()->GetKeyType() != kKeyTypePublic) {
    THROW_ERR_CRYPTO_INVALID_KEYTYPE(env);
    return Nothing<bool>();
  }

  params->id_ = GetOKPCurveFromName(*name);
  params->private_ = private_key->Data();
  params->public_ = public_key->Data();

  return Just(true);
}",29,,456,5,,void
39106,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_KEYTYPE(env);
    return Nothing<bool>();
  }",59,,472,2,,void
39143,BLOCK,-1,,"{
  size_t len = 0;
  ManagedEVPPKey m_privkey = params.private_->GetAsymmetricKey();
  ManagedEVPPKey m_pubkey = params.public_->GetAsymmetricKey();

  switch (params.id_) {
    case EVP_PKEY_X25519:
      // Fall through
    case EVP_PKEY_X448: {
      EVPKeyCtxPointer ctx = nullptr;
      {
        ctx.reset(EVP_PKEY_CTX_new(m_privkey.get(), nullptr));
      }
      Mutex::ScopedLock pub_lock(*m_pubkey.mutex());
      if (EVP_PKEY_derive_init(ctx.get()) <= 0 ||
          EVP_PKEY_derive_set_peer(
              ctx.get(),
              m_pubkey.get()) <= 0 ||
          EVP_PKEY_derive(ctx.get(), nullptr, &len) <= 0) {
        return false;
      }

      ByteSource::Builder buf(len);

      if (EVP_PKEY_derive(ctx.get(), buf.data<unsigned char>(), &len) <= 0) {
        return false;
      }

      *out = std::move(buf).release(len);

      break;
    }
    default: {
      const EC_KEY* private_key;
      {
        Mutex::ScopedLock priv_lock(*m_privkey.mutex());
        private_k...",50,,486,4,,void
39170,BLOCK,-1,,"{
    case EVP_PKEY_X25519:
      // Fall through
    case EVP_PKEY_X448: {
      EVPKeyCtxPointer ctx = nullptr;
      {
        ctx.reset(EVP_PKEY_CTX_new(m_privkey.get(), nullptr));
      }
      Mutex::ScopedLock pub_lock(*m_pubkey.mutex());
      if (EVP_PKEY_derive_init(ctx.get()) <= 0 ||
          EVP_PKEY_derive_set_peer(
              ctx.get(),
              m_pubkey.get()) <= 0 ||
          EVP_PKEY_derive(ctx.get(), nullptr, &len) <= 0) {
        return false;
      }

      ByteSource::Builder buf(len);

      if (EVP_PKEY_derive(ctx.get(), buf.data<unsigned char>(), &len) <= 0) {
        return false;
      }

      *out = std::move(buf).release(len);

      break;
    }
    default: {
      const EC_KEY* private_key;
      {
        Mutex::ScopedLock priv_lock(*m_privkey.mutex());
        private_key = EVP_PKEY_get0_EC_KEY(m_privkey.get());
      }

      Mutex::ScopedLock pub_lock(*m_pubkey.mutex());
      const EC_KEY* public_key = EVP_PKEY_get0_EC_KEY(m_pubkey.get(...",23,,491,2,,void
39175,BLOCK,5,,"{
      EVPKeyCtxPointer ctx = nullptr;
      {
        ctx.reset(EVP_PKEY_CTX_new(m_privkey.get(), nullptr));
      }
      Mutex::ScopedLock pub_lock(*m_pubkey.mutex());
      if (EVP_PKEY_derive_init(ctx.get()) <= 0 ||
          EVP_PKEY_derive_set_peer(
              ctx.get(),
              m_pubkey.get()) <= 0 ||
          EVP_PKEY_derive(ctx.get(), nullptr, &len) <= 0) {
        return false;
      }

      ByteSource::Builder buf(len);

      if (EVP_PKEY_derive(ctx.get(), buf.data<unsigned char>(), &len) <= 0) {
        return false;
      }

      *out = std::move(buf).release(len);

      break;
    }",25,,494,5,,void
39180,BLOCK,3,,"{
        ctx.reset(EVP_PKEY_CTX_new(m_privkey.get(), nullptr));
      }",7,,496,3,,void
39229,BLOCK,-1,,"{
        return false;
      }",59,,504,2,,void
39249,BLOCK,-1,,"{
        return false;
      }",77,,510,2,,void
39266,BLOCK,7,,"{
      const EC_KEY* private_key;
      {
        Mutex::ScopedLock priv_lock(*m_privkey.mutex());
        private_key = EVP_PKEY_get0_EC_KEY(m_privkey.get());
      }

      Mutex::ScopedLock pub_lock(*m_pubkey.mutex());
      const EC_KEY* public_key = EVP_PKEY_get0_EC_KEY(m_pubkey.get());

      const EC_GROUP* group = EC_KEY_get0_group(private_key);
      if (group == nullptr)
        return false;

      CHECK_EQ(EC_KEY_check_key(private_key), 1);
      CHECK_EQ(EC_KEY_check_key(public_key), 1);
      const EC_POINT* pub = EC_KEY_get0_public_key(public_key);
      int field_size = EC_GROUP_get_degree(group);
      len = (field_size + 7) / 8;
      ByteSource::Builder buf(len);
      CHECK_NOT_NULL(pub);
      CHECK_NOT_NULL(private_key);
      if (ECDH_compute_key(buf.data<char>(), len, pub, private_key, nullptr) <=
          0) {
        return false;
      }

      *out = std::move(buf).release();
    }",14,,518,7,,void
39268,BLOCK,2,,"{
        Mutex::ScopedLock priv_lock(*m_privkey.mutex());
        private_key = EVP_PKEY_get0_EC_KEY(m_privkey.get());
      }",7,,520,2,,void
39307,BLOCK,-1,,<empty>,9,,530,2,,void
39354,BLOCK,-1,,"{
        return false;
      }",14,,541,2,,void
39374,BLOCK,-1,,"{
  EVPKeyCtxPointer key_ctx;
  switch (params->params.curve_nid) {
    case EVP_PKEY_ED25519:
      // Fall through
    case EVP_PKEY_ED448:
      // Fall through
    case EVP_PKEY_X25519:
      // Fall through
    case EVP_PKEY_X448:
      key_ctx.reset(EVP_PKEY_CTX_new_id(params->params.curve_nid, nullptr));
      break;
    default: {
      EVPKeyCtxPointer param_ctx(EVP_PKEY_CTX_new_id(EVP_PKEY_EC, nullptr));
      EVP_PKEY* raw_params = nullptr;
      if (!param_ctx ||
          EVP_PKEY_paramgen_init(param_ctx.get()) <= 0 ||
          EVP_PKEY_CTX_set_ec_paramgen_curve_nid(
              param_ctx.get(), params->params.curve_nid) <= 0 ||
          EVP_PKEY_CTX_set_ec_param_enc(
              param_ctx.get(), params->params.param_encoding) <= 0 ||
          EVP_PKEY_paramgen(param_ctx.get(), &raw_params) <= 0) {
        return EVPKeyCtxPointer();
      }
      EVPKeyPointer key_params(raw_params);
      key_ctx.reset(EVP_PKEY_CTX_new(key_params.get(), nullptr));
    }
  }

  i...",68,,552,2,,void
39382,BLOCK,-1,,"{
    case EVP_PKEY_ED25519:
      // Fall through
    case EVP_PKEY_ED448:
      // Fall through
    case EVP_PKEY_X25519:
      // Fall through
    case EVP_PKEY_X448:
      key_ctx.reset(EVP_PKEY_CTX_new_id(params->params.curve_nid, nullptr));
      break;
    default: {
      EVPKeyCtxPointer param_ctx(EVP_PKEY_CTX_new_id(EVP_PKEY_EC, nullptr));
      EVP_PKEY* raw_params = nullptr;
      if (!param_ctx ||
          EVP_PKEY_paramgen_init(param_ctx.get()) <= 0 ||
          EVP_PKEY_CTX_set_ec_paramgen_curve_nid(
              param_ctx.get(), params->params.curve_nid) <= 0 ||
          EVP_PKEY_CTX_set_ec_param_enc(
              param_ctx.get(), params->params.param_encoding) <= 0 ||
          EVP_PKEY_paramgen(param_ctx.get(), &raw_params) <= 0) {
        return EVPKeyCtxPointer();
      }
      EVPKeyPointer key_params(raw_params);
      key_ctx.reset(EVP_PKEY_CTX_new(key_params.get(), nullptr));
    }
  }",37,,554,2,,void
39404,BLOCK,12,,"{
      EVPKeyCtxPointer param_ctx(EVP_PKEY_CTX_new_id(EVP_PKEY_EC, nullptr));
      EVP_PKEY* raw_params = nullptr;
      if (!param_ctx ||
          EVP_PKEY_paramgen_init(param_ctx.get()) <= 0 ||
          EVP_PKEY_CTX_set_ec_paramgen_curve_nid(
              param_ctx.get(), params->params.curve_nid) <= 0 ||
          EVP_PKEY_CTX_set_ec_param_enc(
              param_ctx.get(), params->params.param_encoding) <= 0 ||
          EVP_PKEY_paramgen(param_ctx.get(), &raw_params) <= 0) {
        return EVPKeyCtxPointer();
      }
      EVPKeyPointer key_params(raw_params);
      key_ctx.reset(EVP_PKEY_CTX_new(key_params.get(), nullptr));
    }",14,,564,12,,void
39461,BLOCK,-1,,"{
        return EVPKeyCtxPointer();
      }",65,,573,2,,void
39487,BLOCK,-1,,<empty>,5,,582,2,,void
39501,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[*offset]->IsString());  // curve name
  CHECK(args[*offset + 1]->IsInt32());  // param encoding

  Utf8Value curve_name(env->isolate(), args[*offset]);
  params->params.curve_nid = GetCurveFromName(*curve_name);
  if (params->params.curve_nid == NID_undef) {
    THROW_ERR_CRYPTO_INVALID_CURVE(env);
    return Nothing<bool>();
  }

  params->params.param_encoding = args[*offset + 1].As<Int32>()->Value();
  if (params->params.param_encoding != OPENSSL_EC_NAMED_CURVE &&
      params->params.param_encoding != OPENSSL_EC_EXPLICIT_CURVE) {
    THROW_ERR_OUT_OF_RANGE(env, ""Invalid param_encoding specified"");
    return Nothing<bool>();
  }

  *offset += 2;

  return Just(true);
}",33,,601,5,,void
39555,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_CURVE(env);
    return Nothing<bool>();
  }",46,,608,2,,void
39594,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""Invalid param_encoding specified"");
    return Nothing<bool>();
  }",67,,615,2,,void
39614,BLOCK,-1,,"{
  ManagedEVPPKey m_pkey = key_data->GetAsymmetricKey();
  CHECK(m_pkey);
  Mutex::ScopedLock lock(*m_pkey.mutex());

  const EC_KEY* ec_key = EVP_PKEY_get0_EC_KEY(m_pkey.get());

  size_t len = 0;

  if (ec_key == nullptr) {
    typedef int (*export_fn)(const EVP_PKEY*, unsigned char*, size_t* len);
    export_fn fn = nullptr;
    switch (key_data->GetKeyType()) {
      case kKeyTypePrivate:
        fn = EVP_PKEY_get_raw_private_key;
        break;
      case kKeyTypePublic:
        fn = EVP_PKEY_get_raw_public_key;
        break;
      case kKeyTypeSecret:
        UNREACHABLE();
    }
    CHECK_NOT_NULL(fn);
    // Get the size of the raw key data
    if (fn(m_pkey.get(), nullptr, &len) == 0)
      return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
    ByteSource::Builder data(len);
    if (fn(m_pkey.get(), data.data<unsigned char>(), &len) == 0)
      return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
    *out = std::move(data).release(len);
  } else {
    if (key_data->GetKeyTy...",22,,629,4,,void
39647,BLOCK,-1,,"{
    typedef int (*export_fn)(const EVP_PKEY*, unsigned char*, size_t* len);
    export_fn fn = nullptr;
    switch (key_data->GetKeyType()) {
      case kKeyTypePrivate:
        fn = EVP_PKEY_get_raw_private_key;
        break;
      case kKeyTypePublic:
        fn = EVP_PKEY_get_raw_public_key;
        break;
      case kKeyTypeSecret:
        UNREACHABLE();
    }
    CHECK_NOT_NULL(fn);
    // Get the size of the raw key data
    if (fn(m_pkey.get(), nullptr, &len) == 0)
      return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
    ByteSource::Builder data(len);
    if (fn(m_pkey.get(), data.data<unsigned char>(), &len) == 0)
      return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
    *out = std::move(data).release(len);
  }",26,,638,2,,void
39652,BLOCK,-1,,<empty>,,,,4,,<empty>
39664,BLOCK,-1,,"{
      case kKeyTypePrivate:
        fn = EVP_PKEY_get_raw_private_key;
        break;
      case kKeyTypePublic:
        fn = EVP_PKEY_get_raw_public_key;
        break;
      case kKeyTypeSecret:
        UNREACHABLE();
    }",37,,641,2,,void
39693,BLOCK,-1,,<empty>,7,,654,2,,void
39715,BLOCK,-1,,<empty>,7,,657,2,,void
39733,BLOCK,-1,,"{
    if (key_data->GetKeyType() != kKeyTypePublic)
      return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
    const EC_GROUP* group = EC_KEY_get0_group(ec_key);
    const EC_POINT* point = EC_KEY_get0_public_key(ec_key);
    point_conversion_form_t form = POINT_CONVERSION_UNCOMPRESSED;

    // Get the allocated data size...
    len = EC_POINT_point2oct(group, point, form, nullptr, 0, nullptr);
    if (len == 0)
      return WebCryptoKeyExportStatus::FAILED;
    ByteSource::Builder data(len);
    size_t check_len = EC_POINT_point2oct(
        group, point, form, data.data<unsigned char>(), len, nullptr);
    if (check_len == 0)
      return WebCryptoKeyExportStatus::FAILED;

    CHECK_EQ(len, check_len);
    *out = std::move(data).release();
  }",10,,659,1,,void
39741,BLOCK,-1,,<empty>,7,,661,2,,void
39773,BLOCK,-1,,<empty>,7,,669,2,,void
39798,BLOCK,-1,,<empty>,7,,674,2,,void
39827,BLOCK,-1,,"{
  return Just(true);
}",32,,687,4,,void
39838,BLOCK,-1,,"{
  CHECK_NE(key_data->GetKeyType(), kKeyTypeSecret);

  switch (format) {
    case kWebCryptoKeyFormatRaw:
      return EC_Raw_Export(key_data.get(), params, out);
    case kWebCryptoKeyFormatPKCS8:
      if (key_data->GetKeyType() != kKeyTypePrivate)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_PKCS8_Export(key_data.get(), out);
    case kWebCryptoKeyFormatSPKI: {
      if (key_data->GetKeyType() != kKeyTypePublic)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;

      ManagedEVPPKey m_pkey = key_data->GetAsymmetricKey();
      if (EVP_PKEY_id(m_pkey.get()) != EVP_PKEY_EC) {
        return PKEY_SPKI_Export(key_data.get(), out);
      } else {
        // Ensure exported key is in uncompressed point format.
        // The temporary EC key is so we can have i2d_PUBKEY_bio() write out
        // the header but it is a somewhat silly hoop to jump through because
        // the header is for all practical purposes a static 26 byte sequence
    ...",22,,695,5,,void
39847,BLOCK,-1,,"{
    case kWebCryptoKeyFormatRaw:
      return EC_Raw_Export(key_data.get(), params, out);
    case kWebCryptoKeyFormatPKCS8:
      if (key_data->GetKeyType() != kKeyTypePrivate)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_PKCS8_Export(key_data.get(), out);
    case kWebCryptoKeyFormatSPKI: {
      if (key_data->GetKeyType() != kKeyTypePublic)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;

      ManagedEVPPKey m_pkey = key_data->GetAsymmetricKey();
      if (EVP_PKEY_id(m_pkey.get()) != EVP_PKEY_EC) {
        return PKEY_SPKI_Export(key_data.get(), out);
      } else {
        // Ensure exported key is in uncompressed point format.
        // The temporary EC key is so we can have i2d_PUBKEY_bio() write out
        // the header but it is a somewhat silly hoop to jump through because
        // the header is for all practical purposes a static 26 byte sequence
        // where only the second byte changes.
        Mutex::ScopedLock lock...",19,,698,2,,void
39867,BLOCK,-1,,<empty>,9,,703,2,,void
39881,BLOCK,10,,"{
      if (key_data->GetKeyType() != kKeyTypePublic)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;

      ManagedEVPPKey m_pkey = key_data->GetAsymmetricKey();
      if (EVP_PKEY_id(m_pkey.get()) != EVP_PKEY_EC) {
        return PKEY_SPKI_Export(key_data.get(), out);
      } else {
        // Ensure exported key is in uncompressed point format.
        // The temporary EC key is so we can have i2d_PUBKEY_bio() write out
        // the header but it is a somewhat silly hoop to jump through because
        // the header is for all practical purposes a static 26 byte sequence
        // where only the second byte changes.
        Mutex::ScopedLock lock(*m_pkey.mutex());
        const EC_KEY* ec_key = EVP_PKEY_get0_EC_KEY(m_pkey.get());
        const EC_GROUP* group = EC_KEY_get0_group(ec_key);
        const EC_POINT* point = EC_KEY_get0_public_key(ec_key);
        const point_conversion_form_t form = POINT_CONVERSION_UNCOMPRESSED;
        const size_t need =
            E...",35,,705,10,,void
39889,BLOCK,-1,,<empty>,9,,707,2,,void
39909,BLOCK,-1,,"{
        return PKEY_SPKI_Export(key_data.get(), out);
      }",53,,710,2,,void
39918,BLOCK,-1,,"{
        // Ensure exported key is in uncompressed point format.
        // The temporary EC key is so we can have i2d_PUBKEY_bio() write out
        // the header but it is a somewhat silly hoop to jump through because
        // the header is for all practical purposes a static 26 byte sequence
        // where only the second byte changes.
        Mutex::ScopedLock lock(*m_pkey.mutex());
        const EC_KEY* ec_key = EVP_PKEY_get0_EC_KEY(m_pkey.get());
        const EC_GROUP* group = EC_KEY_get0_group(ec_key);
        const EC_POINT* point = EC_KEY_get0_public_key(ec_key);
        const point_conversion_form_t form = POINT_CONVERSION_UNCOMPRESSED;
        const size_t need =
            EC_POINT_point2oct(group, point, form, nullptr, 0, nullptr);
        if (need == 0) return WebCryptoKeyExportStatus::FAILED;
        ByteSource::Builder data(need);
        const size_t have = EC_POINT_point2oct(
            group, point, form, data.data<unsigned char>(), need, nullptr);
       ...",14,,712,1,,void
39962,BLOCK,-1,,<empty>,24,,725,2,,void
39987,BLOCK,-1,,<empty>,24,,729,2,,void
40051,BLOCK,-1,,<empty>,,,,2,,<empty>
40067,BLOCK,-1,,<empty>,11,,745,2,,void
40092,BLOCK,-1,,"{
  ManagedEVPPKey m_pkey = key->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());
  CHECK_EQ(EVP_PKEY_id(m_pkey.get()), EVP_PKEY_EC);

  const EC_KEY* ec = EVP_PKEY_get0_EC_KEY(m_pkey.get());
  CHECK_NOT_NULL(ec);

  const EC_POINT* pub = EC_KEY_get0_public_key(ec);
  const EC_GROUP* group = EC_KEY_get0_group(ec);

  int degree_bits = EC_GROUP_get_degree(group);
  int degree_bytes =
    (degree_bits / CHAR_BIT) + (7 + (degree_bits % CHAR_BIT)) / 8;

  BignumPointer x(BN_new());
  BignumPointer y(BN_new());

  if (!EC_POINT_get_affine_coordinates(group, pub, x.get(), y.get(), nullptr)) {
    ThrowCryptoError(env, ERR_get_error(),
                     ""Failed to get elliptic-curve point coordinates"");
    return Nothing<void>();
  }

  if (target->Set(
          env->context(),
          env->jwk_kty_string(),
          env->jwk_ec_string()).IsNothing()) {
    return Nothing<void>();
  }

  if (SetEncodedValue(
          env,
          target,
          env->jwk_x_string...",27,,758,4,,void
40173,BLOCK,-1,,"{
    ThrowCryptoError(env, ERR_get_error(),
                     ""Failed to get elliptic-curve point coordinates"");
    return Nothing<void>();
  }",80,,776,2,,void
40200,BLOCK,-1,,"{
    return Nothing<void>();
  }",46,,785,2,,void
40235,BLOCK,-1,,"{
    return Nothing<void>();
  }",38,,800,2,,void
40250,BLOCK,-1,,"{
    case NID_X9_62_prime256v1:
      crv_name = OneByteString(env->isolate(), ""P-256"");
      break;
    case NID_secp256k1:
      crv_name = OneByteString(env->isolate(), ""secp256k1"");
      break;
    case NID_secp384r1:
      crv_name = OneByteString(env->isolate(), ""P-384"");
      break;
    case NID_secp521r1:
      crv_name = OneByteString(env->isolate(), ""P-521"");
      break;
    default: {
      THROW_ERR_CRYPTO_JWK_UNSUPPORTED_CURVE(
          env, ""Unsupported JWK EC curve: %s."", OBJ_nid2sn(nid));
      return Nothing<void>();
    }
  }",16,,806,2,,void
40296,BLOCK,18,,"{
      THROW_ERR_CRYPTO_JWK_UNSUPPORTED_CURVE(
          env, ""Unsupported JWK EC curve: %s."", OBJ_nid2sn(nid));
      return Nothing<void>();
    }",14,,819,18,,void
40321,BLOCK,-1,,"{
    return Nothing<void>();
  }",30,,828,2,,void
40331,BLOCK,-1,,"{
    const BIGNUM* pvt = EC_KEY_get0_private_key(ec);
    return SetEncodedValue(
      env,
      target,
      env->jwk_d_string(),
      pvt,
      degree_bytes).IsJust() ? JustVoid() : Nothing<void>();
  }",45,,832,2,,void
40361,BLOCK,-1,,"{
  ManagedEVPPKey pkey = key->GetAsymmetricKey();
  Mutex::ScopedLock lock(*pkey.mutex());

  const char* curve = nullptr;
  switch (EVP_PKEY_id(pkey.get())) {
    case EVP_PKEY_ED25519:
      curve = ""Ed25519"";
      break;
    case EVP_PKEY_ED448:
      curve = ""Ed448"";
      break;
    case EVP_PKEY_X25519:
      curve = ""X25519"";
      break;
    case EVP_PKEY_X448:
      curve = ""X448"";
      break;
    default:
      UNREACHABLE();
  }
  if (target->Set(
          env->context(),
          env->jwk_crv_string(),
          OneByteString(env->isolate(), curve)).IsNothing()) {
    return Nothing<bool>();
  }

  size_t len = 0;
  Local<Value> encoded;
  Local<Value> error;

  if (!EVP_PKEY_get_raw_public_key(pkey.get(), nullptr, &len))
    return Nothing<bool>();

  ByteSource::Builder out(len);

  if (key->GetKeyType() == kKeyTypePrivate) {
    if (!EVP_PKEY_get_raw_private_key(
            pkey.get(), out.data<unsigned char>(), &len) ||
        !StringBytes::Encode(
           ...",27,,848,4,,void
40386,BLOCK,-1,,"{
    case EVP_PKEY_ED25519:
      curve = ""Ed25519"";
      break;
    case EVP_PKEY_ED448:
      curve = ""Ed448"";
      break;
    case EVP_PKEY_X25519:
      curve = ""X25519"";
      break;
    case EVP_PKEY_X448:
      curve = ""X448"";
      break;
    default:
      UNREACHABLE();
  }",36,,853,2,,void
40435,BLOCK,-1,,"{
    return Nothing<bool>();
  }",62,,872,2,,void
40462,BLOCK,-1,,<empty>,5,,881,2,,void
40475,BLOCK,-1,,"{
    if (!EVP_PKEY_get_raw_private_key(
            pkey.get(), out.data<unsigned char>(), &len) ||
        !StringBytes::Encode(
             env->isolate(), out.data<const char>(), len, BASE64URL, &error)
             .ToLocal(&encoded) ||
        !target->Set(env->context(), env->jwk_d_string(), encoded).IsJust()) {
      if (!error.IsEmpty())
        env->isolate()->ThrowException(error);
      return Nothing<bool>();
    }
  }",45,,885,2,,void
40530,BLOCK,-1,,"{
      if (!error.IsEmpty())
        env->isolate()->ThrowException(error);
      return Nothing<bool>();
    }",78,,891,2,,void
40537,BLOCK,-1,,<empty>,9,,893,2,,void
40602,BLOCK,-1,,"{
    if (!error.IsEmpty())
      env->isolate()->ThrowException(error);
    return Nothing<bool>();
  }",76,,903,2,,void
40609,BLOCK,-1,,<empty>,7,,905,2,,void
40640,BLOCK,-1,,"{
    return Nothing<bool>();
  }",47,,912,2,,void
40653,BLOCK,-1,,"{
  CHECK(args[offset]->IsString());  // curve name
  Utf8Value curve(env->isolate(), args[offset].As<String>());

  int nid = GetCurveFromName(*curve);
  if (nid == NID_undef) {  // Unknown curve
    THROW_ERR_CRYPTO_INVALID_CURVE(env);
    return std::shared_ptr<KeyObjectData>();
  }

  Local<Value> x_value;
  Local<Value> y_value;
  Local<Value> d_value;

  if (!jwk->Get(env->context(), env->jwk_x_string()).ToLocal(&x_value) ||
      !jwk->Get(env->context(), env->jwk_y_string()).ToLocal(&y_value) ||
      !jwk->Get(env->context(), env->jwk_d_string()).ToLocal(&d_value)) {
    return std::shared_ptr<KeyObjectData>();
  }

  if (!x_value->IsString() ||
      !y_value->IsString() ||
      (!d_value->IsUndefined() && !d_value->IsString())) {
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK EC key"");
    return std::shared_ptr<KeyObjectData>();
  }

  KeyType type = d_value->IsString() ? kKeyTypePrivate : kKeyTypePublic;

  ECKeyPointer ec(EC_KEY_new_by_curve_name(nid));
  if (!ec)...",26,,923,5,,void
40683,BLOCK,-1,,"{  // Unknown curve
    THROW_ERR_CRYPTO_INVALID_CURVE(env);
    return std::shared_ptr<KeyObjectData>();
  }",25,,928,2,,void
40763,BLOCK,-1,,"{
    return std::shared_ptr<KeyObjectData>();
  }",73,,939,2,,void
40793,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK EC key"");
    return std::shared_ptr<KeyObjectData>();
  }",58,,945,2,,void
40819,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK EC key"");
    return std::shared_ptr<KeyObjectData>();
  }",12,,953,2,,void
40873,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK EC key"");
    return std::shared_ptr<KeyObjectData>();
  }",28,,964,2,,void
40886,BLOCK,-1,,"{
    ByteSource d = ByteSource::FromEncodedString(env, d_value.As<String>());
    if (!EC_KEY_set_private_key(ec.get(), d.ToBN().get())) {
      THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK EC key"");
      return std::shared_ptr<KeyObjectData>();
    }
  }",32,,969,2,,void
40913,BLOCK,-1,,"{
      THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK EC key"");
      return std::shared_ptr<KeyObjectData>();
    }",60,,971,2,,void
40954,BLOCK,-1,,"{
  ManagedEVPPKey m_pkey = key->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());
  CHECK_EQ(EVP_PKEY_id(m_pkey.get()), EVP_PKEY_EC);

  const EC_KEY* ec = EVP_PKEY_get0_EC_KEY(m_pkey.get());
  CHECK_NOT_NULL(ec);

  const EC_GROUP* group = EC_KEY_get0_group(ec);
  int nid = EC_GROUP_get_curve_name(group);

  return target->Set(
      env->context(),
      env->named_curve_string(),
      OneByteString(env->isolate(), OBJ_nid2sn(nid)));
}",27,,986,4,,void
41020,BLOCK,-1,,"{
  const EC_KEY* ec = EVP_PKEY_get0_EC_KEY(key.get());
  CHECK_NOT_NULL(ec);
  const EC_GROUP* group = EC_KEY_get0_group(ec);
  BignumPointer order(BN_new());
  CHECK(EC_GROUP_get_order(group, order.get(), nullptr));
  return BN_num_bytes(order.get());
}",50,,1008,2,,void
41077,BLOCK,-1,,<empty>,1,,1,1,,ANY
41084,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    bool r = hash->HashUpdate(data, size);
    args.GetReturnValue().Set(r);
  }",56,,142,5,,void
41098,BLOCK,-1,,<empty>,7,,145,2,,void
41145,BLOCK,-1,,<empty>,1,,1,1,,ANY
41151,BLOCK,-1,,"{
  MakeWeak();
}",74,,28,3,,void
41157,BLOCK,-1,,"{
  tracker->TrackFieldWithSize(""mdctx"", mdctx_ ? kSizeOf_EVP_MD_CTX : 0);
  tracker->TrackFieldWithSize(""md"", digest_ ? md_len_ : 0);
}",53,,32,2,,void
41180,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  MarkPopErrorOnReturn mark_pop_error_on_return;
  CipherPushContext ctx(env);
  EVP_MD_do_all_sorted(
#if OPENSSL_VERSION_MAJOR >= 3
    array_push_back<EVP_MD,
                    EVP_MD_fetch,
                    EVP_MD_free,
                    EVP_get_digestbyname,
                    EVP_MD_get0_name>,
#else
    array_push_back<EVP_MD>,
#endif
    &ctx);
  args.GetReturnValue().Set(ctx.ToJSArray());
}",63,,37,2,,void
41213,BLOCK,-1,,"{
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();
  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);

  t->InstanceTemplate()->SetInternalFieldCount(Hash::kInternalFieldCount);

  SetProtoMethod(isolate, t, ""update"", HashUpdate);
  SetProtoMethod(isolate, t, ""digest"", HashDigest);

  SetConstructorFunction(context, target, ""Hash"", t);

  SetMethodNoSideEffect(context, target, ""getHashes"", GetHashes);

  HashJob::Initialize(env, target);
}",63,,55,3,,void
41280,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(HashUpdate);
  registry->Register(HashDigest);
  registry->Register(GetHashes);

  HashJob::RegisterExternalReferences(registry);
}",76,,72,2,,void
41310,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const Hash* orig = nullptr;
  const EVP_MD* md = nullptr;

  if (args[0]->IsObject()) {
    ASSIGN_OR_RETURN_UNWRAP(&orig, args[0].As<Object>());
    md = EVP_MD_CTX_md(orig->mdctx_.get());
  } else {
    const Utf8Value hash_type(env->isolate(), args[0]);
    md = EVP_get_digestbyname(*hash_type);
  }

  Maybe<unsigned int> xof_md_len = Nothing<unsigned int>();
  if (!args[1]->IsUndefined()) {
    CHECK(args[1]->IsUint32());
    xof_md_len = Just<unsigned int>(args[1].As<Uint32>()->Value());
  }

  Hash* hash = new Hash(env, args.This());
  if (md == nullptr || !hash->HashInit(md, xof_md_len)) {
    return ThrowCryptoError(env, ERR_get_error(),
                            ""Digest method not supported"");
  }

  if (orig != nullptr &&
      0 >= EVP_MD_CTX_copy(hash->mdctx_.get(), orig->mdctx_.get())) {
    return ThrowCryptoError(env, ERR_get_error(), ""Digest copy error"");
  }
}",57,,81,2,,void
41334,BLOCK,-1,,"{
    ASSIGN_OR_RETURN_UNWRAP(&orig, args[0].As<Object>());
    md = EVP_MD_CTX_md(orig->mdctx_.get());
  }",28,,87,2,,void
41354,BLOCK,-1,,"{
    const Utf8Value hash_type(env->isolate(), args[0]);
    md = EVP_get_digestbyname(*hash_type);
  }",10,,90,1,,void
41381,BLOCK,-1,,"{
    CHECK(args[1]->IsUint32());
    xof_md_len = Just<unsigned int>(args[1].As<Uint32>()->Value());
  }",32,,96,2,,void
41423,BLOCK,-1,,"{
    return ThrowCryptoError(env, ERR_get_error(),
                            ""Digest method not supported"");
  }",57,,102,2,,void
41449,BLOCK,-1,,"{
    return ThrowCryptoError(env, ERR_get_error(), ""Digest copy error"");
  }",69,,108,2,,void
41460,BLOCK,-1,,"{
  mdctx_.reset(EVP_MD_CTX_new());
  if (!mdctx_ || EVP_DigestInit_ex(mdctx_.get(), md, nullptr) <= 0) {
    mdctx_.reset();
    return false;
  }

  md_len_ = EVP_MD_size(md);
  if (xof_md_len.IsJust() && xof_md_len.FromJust() != md_len_) {
    // This is a little hack to cause createHash to fail when an incorrect
    // hashSize option was passed for a non-XOF hash function.
    if ((EVP_MD_flags(md) & EVP_MD_FLAG_XOF) == 0) {
      EVPerr(EVP_F_EVP_DIGESTFINALXOF, EVP_R_NOT_XOF_OR_INVALID_LENGTH);
      return false;
    }
    md_len_ = xof_md_len.FromJust();
  }

  return true;
}",71,,113,3,,void
41479,BLOCK,-1,,"{
    mdctx_.reset();
    return false;
  }",69,,115,2,,void
41502,BLOCK,-1,,"{
    // This is a little hack to cause createHash to fail when an incorrect
    // hashSize option was passed for a non-XOF hash function.
    if ((EVP_MD_flags(md) & EVP_MD_FLAG_XOF) == 0) {
      EVPerr(EVP_F_EVP_DIGESTFINALXOF, EVP_R_NOT_XOF_OR_INVALID_LENGTH);
      return false;
    }
    md_len_ = xof_md_len.FromJust();
  }",64,,121,2,,void
41510,BLOCK,-1,,"{
      EVPerr(EVP_F_EVP_DIGESTFINALXOF, EVP_R_NOT_XOF_OR_INVALID_LENGTH);
      return false;
    }",52,,124,2,,void
41529,BLOCK,-1,,"{
  if (!mdctx_)
    return false;
  return EVP_DigestUpdate(mdctx_.get(), data, len) == 1;
}",53,,134,3,,void
41533,BLOCK,-1,,<empty>,5,,136,2,,void
41549,BLOCK,-1,,"{
  Decode<Hash>(args, [](Hash* hash, const FunctionCallbackInfo<Value>& args,
                        const char* data, size_t size) {
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    bool r = hash->HashUpdate(data, size);
    args.GetReturnValue().Set(r);
  });
}",64,,140,2,,void
41562,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  Hash* hash;
  ASSIGN_OR_RETURN_UNWRAP(&hash, args.Holder());

  enum encoding encoding = BUFFER;
  if (args.Length() >= 1) {
    encoding = ParseEncoding(env->isolate(), args[0], BUFFER);
  }

  unsigned int len = hash->md_len_;

  // TODO(tniessen): SHA3_squeeze does not work for zero-length outputs on all
  // platforms and will cause a segmentation fault if called. This workaround
  // causes hash.digest() to correctly return an empty buffer / string.
  // See https://github.com/openssl/openssl/issues/9431.

  if (!hash->digest_ && len > 0) {
    // Some hash algorithms such as SHA3 do not support calling
    // EVP_DigestFinal_ex more than once, however, Hash._flush
    // and Hash.digest can both be used to retrieve the digest,
    // so we need to cache it.
    // See https://github.com/nodejs/node/issues/28245.

    ByteSource::Builder digest(len);

    size_t default_len = EVP_MD_CTX_size(hash->mdctx_.get());
    int r...",64,,151,2,,void
41590,BLOCK,-1,,"{
    encoding = ParseEncoding(env->isolate(), args[0], BUFFER);
  }",27,,158,2,,void
41617,BLOCK,-1,,"{
    // Some hash algorithms such as SHA3 do not support calling
    // EVP_DigestFinal_ex more than once, however, Hash._flush
    // and Hash.digest can both be used to retrieve the digest,
    // so we need to cache it.
    // See https://github.com/nodejs/node/issues/28245.

    ByteSource::Builder digest(len);

    size_t default_len = EVP_MD_CTX_size(hash->mdctx_.get());
    int ret;
    if (len == default_len) {
      ret = EVP_DigestFinal_ex(
          hash->mdctx_.get(), digest.data<unsigned char>(), &len);
      // The output length should always equal hash->md_len_
      CHECK_EQ(len, hash->md_len_);
    } else {
      ret = EVP_DigestFinalXOF(
          hash->mdctx_.get(), digest.data<unsigned char>(), len);
    }

    if (ret != 1)
      return ThrowCryptoError(env, ERR_get_error());

    hash->digest_ = std::move(digest).release();
  }",34,,169,2,,void
41636,BLOCK,-1,,"{
      ret = EVP_DigestFinal_ex(
          hash->mdctx_.get(), digest.data<unsigned char>(), &len);
      // The output length should always equal hash->md_len_
      CHECK_EQ(len, hash->md_len_);
    }",29,,180,2,,void
41658,BLOCK,-1,,"{
      ret = EVP_DigestFinalXOF(
          hash->mdctx_.get(), digest.data<unsigned char>(), len);
    }",12,,185,1,,void
41677,BLOCK,-1,,<empty>,7,,191,2,,void
41728,BLOCK,-1,,"{
    CHECK(!error.IsEmpty());
    env->isolate()->ThrowException(error);
    return;
  }",21,,199,2,,void
41760,BLOCK,-1,,<empty>,28,,211,2,,void
41765,BLOCK,-1,,"{
  if (&other == this) return *this;
  this->~HashConfig();
  return *new (this) HashConfig(std::move(other));
}",64,,213,2,,void
41771,BLOCK,-1,,<empty>,23,,214,2,,void
41793,BLOCK,-1,,"{
  // If the Job is sync, then the HashConfig does not own the data.
  if (mode == kCryptoJobAsync)
    tracker->TrackFieldWithSize(""in"", in.size());
}",59,,219,2,,void
41798,BLOCK,-1,,<empty>,5,,222,2,,void
41815,BLOCK,-1,,"{
  *result = out->ToArrayBuffer(env);
  return Just(!result->IsEmpty());
}",35,,229,5,,void
41838,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  params->mode = mode;

  CHECK(args[offset]->IsString());  // Hash algorithm
  Utf8Value digest(env->isolate(), args[offset]);
  params->digest = EVP_get_digestbyname(*digest);
  if (UNLIKELY(params->digest == nullptr)) {
    THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
    return Nothing<bool>();
  }

  ArrayBufferOrViewContents<char> data(args[offset + 1]);
  if (UNLIKELY(!data.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""data is too big"");
    return Nothing<bool>();
  }
  params->in = mode == kCryptoJobAsync
      ? data.ToCopy()
      : data.ToByteSource();

  unsigned int expected = EVP_MD_size(params->digest);
  params->length = expected;
  if (UNLIKELY(args[offset + 2]->IsUint32())) {
    // length is expressed in terms of bits
    params->length =
        static_cast<uint32_t>(args[offset + 2]
            .As<Uint32>()->Value()) / CHAR_BIT;
    if (params->length != expected) {
      if...",25,,238,5,,void
41882,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
    return Nothing<bool>();
  }",44,,246,2,,void
41904,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""data is too big"");
    return Nothing<bool>();
  }",41,,252,2,,void
41948,BLOCK,-1,,"{
    // length is expressed in terms of bits
    params->length =
        static_cast<uint32_t>(args[offset + 2]
            .As<Uint32>()->Value()) / CHAR_BIT;
    if (params->length != expected) {
      if ((EVP_MD_flags(params->digest) & EVP_MD_FLAG_XOF) == 0) {
        THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Digest method not supported"");
        return Nothing<bool>();
      }
    }
  }",47,,262,2,,void
41974,BLOCK,-1,,"{
      if ((EVP_MD_flags(params->digest) & EVP_MD_FLAG_XOF) == 0) {
        THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Digest method not supported"");
        return Nothing<bool>();
      }
    }",37,,267,2,,void
41984,BLOCK,-1,,"{
        THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Digest method not supported"");
        return Nothing<bool>();
      }",66,,268,2,,void
41999,BLOCK,-1,,"{
  EVPMDPointer ctx(EVP_MD_CTX_new());

  if (UNLIKELY(!ctx ||
               EVP_DigestInit_ex(ctx.get(), params.digest, nullptr) <= 0 ||
               EVP_DigestUpdate(
                   ctx.get(), params.in.data<char>(), params.in.size()) <= 0)) {
    return false;
  }

  if (LIKELY(params.length > 0)) {
    unsigned int length = params.length;
    ByteSource::Builder buf(length);

    size_t expected = EVP_MD_CTX_size(ctx.get());

    int ret =
        (length == expected)
            ? EVP_DigestFinal_ex(ctx.get(), buf.data<unsigned char>(), &length)
            : EVP_DigestFinalXOF(ctx.get(), buf.data<unsigned char>(), length);

    if (UNLIKELY(ret != 1))
      return false;

    *out = std::move(buf).release();
  }

  return true;
}",22,,281,4,,void
42039,BLOCK,-1,,"{
    return false;
  }",80,,287,2,,void
42049,BLOCK,-1,,"{
    unsigned int length = params.length;
    ByteSource::Builder buf(length);

    size_t expected = EVP_MD_CTX_size(ctx.get());

    int ret =
        (length == expected)
            ? EVP_DigestFinal_ex(ctx.get(), buf.data<unsigned char>(), &length)
            : EVP_DigestFinalXOF(ctx.get(), buf.data<unsigned char>(), length);

    if (UNLIKELY(ret != 1))
      return false;

    *out = std::move(buf).release();
  }",34,,291,2,,void
42100,BLOCK,-1,,<empty>,7,,303,2,,void
42134,BLOCK,-1,,<empty>,1,,1,1,,ANY
42155,BLOCK,-1,,<empty>,1,,1,1,,ANY
42160,BLOCK,-1,,<empty>,35,,26,2,,void
42165,BLOCK,-1,,"{
  if (&other == this) return *this;
  this->~HKDFConfig();
  return *new (this) HKDFConfig(std::move(other));
}",64,,28,2,,void
42171,BLOCK,-1,,<empty>,23,,29,2,,void
42196,BLOCK,-1,,"{
  *result = out->ToArrayBuffer(env);
  return Just(!result->IsEmpty());
}",35,,38,5,,void
42219,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  params->mode = mode;

  CHECK(args[offset]->IsString());  // Hash
  CHECK(args[offset + 1]->IsObject());  // Key
  CHECK(IsAnyByteSource(args[offset + 2]));  // Salt
  CHECK(IsAnyByteSource(args[offset + 3]));  // Info
  CHECK(args[offset + 4]->IsUint32());  // Length

  Utf8Value hash(env->isolate(), args[offset]);
  params->digest = EVP_get_digestbyname(*hash);
  if (params->digest == nullptr) {
    THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *hash);
    return Nothing<bool>();
  }

  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args[offset + 1], Nothing<bool>());
  params->key = key->Data();

  ArrayBufferOrViewContents<char> salt(args[offset + 2]);
  ArrayBufferOrViewContents<char> info(args[offset + 3]);

  if (UNLIKELY(!salt.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""salt is too big"");
    return Nothing<bool>();
  }
  if (UNLIKELY(!info.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(e...",25,,47,5,,void
42294,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *hash);
    return Nothing<bool>();
  }",34,,60,2,,void
42341,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""salt is too big"");
    return Nothing<bool>();
  }",41,,72,2,,void
42354,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""info is too big"");
    return Nothing<bool>();
  }",41,,76,2,,void
42426,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_KEYLEN(env);
    return Nothing<bool>();
  }",36,,95,2,,void
42440,BLOCK,-1,,"{
  EVPKeyCtxPointer ctx =
      EVPKeyCtxPointer(EVP_PKEY_CTX_new_id(EVP_PKEY_HKDF, nullptr));
  if (!ctx || !EVP_PKEY_derive_init(ctx.get()) ||
      !EVP_PKEY_CTX_set_hkdf_md(ctx.get(), params.digest) ||
      !EVP_PKEY_CTX_add1_hkdf_info(
          ctx.get(), params.info.data<unsigned char>(), params.info.size())) {
    return false;
  }

  // TODO(panva): Once support for OpenSSL 1.1.1 is dropped the whole
  // of HKDFTraits::DeriveBits can be refactored to use
  // EVP_KDF which does handle zero length key.

  std::string_view salt;
  if (params.salt.size() != 0) {
    salt = {params.salt.data<char>(), params.salt.size()};
  } else {
    static const char default_salt[EVP_MAX_MD_SIZE] = {0};
    salt = {default_salt, static_cast<unsigned>(EVP_MD_size(params.digest))};
  }

  // We do not use EVP_PKEY_HKDEF_MODE_EXTRACT_AND_EXPAND and instead implement
  // the extraction step ourselves because EVP_PKEY_derive does not handle
  // zero-length keys, which are required for Web Cr...",22,,106,4,,void
42487,BLOCK,-1,,"{
    return false;
  }",78,,112,2,,void
42500,BLOCK,-1,,"{
    salt = {params.salt.data<char>(), params.salt.size()};
  }",32,,121,2,,void
42504,BLOCK,-1,,"{
    static const char default_salt[EVP_MAX_MD_SIZE] = {0};
    salt = {default_salt, static_cast<unsigned>(EVP_MD_size(params.digest))};
  }",10,,123,1,,void
42550,BLOCK,-1,,"{
    return false;
  }",33,,140,2,,void
42570,BLOCK,-1,,"{
    return false;
  }",74,,144,2,,void
42596,BLOCK,-1,,<empty>,5,,151,2,,void
42616,BLOCK,-1,,"{
  tracker->TrackField(""key"", key);
  // If the job is sync, then the HKDFConfig does not own the data
  if (mode == kCryptoJobAsync) {
    tracker->TrackFieldWithSize(""salt"", salt.size());
    tracker->TrackFieldWithSize(""info"", info.size());
  }
}",59,,157,2,,void
42627,BLOCK,-1,,"{
    tracker->TrackFieldWithSize(""salt"", salt.size());
    tracker->TrackFieldWithSize(""info"", info.size());
  }",32,,160,2,,void
42662,BLOCK,-1,,<empty>,1,,1,1,,ANY
42669,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    bool r = hmac->HmacUpdate(data, size);
    args.GetReturnValue().Set(r);
  }",56,,104,5,,void
42683,BLOCK,-1,,<empty>,7,,107,2,,void
42736,BLOCK,-1,,<empty>,1,,1,1,,ANY
42742,BLOCK,-1,,"{
  MakeWeak();
}",21,,33,3,,void
42748,BLOCK,-1,,"{
  tracker->TrackFieldWithSize(""context"", ctx_ ? kSizeOf_HMAC_CTX : 0);
}",53,,37,2,,void
42763,BLOCK,-1,,"{
  Isolate* isolate = env->isolate();
  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);

  t->InstanceTemplate()->SetInternalFieldCount(Hmac::kInternalFieldCount);

  SetProtoMethod(isolate, t, ""init"", HmacInit);
  SetProtoMethod(isolate, t, ""update"", HmacUpdate);
  SetProtoMethod(isolate, t, ""digest"", HmacDigest);

  SetConstructorFunction(env->context(), target, ""Hmac"", t);

  HmacJob::Initialize(env, target);
}",63,,41,3,,void
42823,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(HmacInit);
  registry->Register(HmacUpdate);
  registry->Register(HmacDigest);
  HmacJob::RegisterExternalReferences(registry);
}",76,,56,2,,void
42853,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  new Hmac(env, args.This());
}",57,,64,2,,void
42875,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());

  const EVP_MD* md = EVP_get_digestbyname(hash_type);
  if (md == nullptr)
    return THROW_ERR_CRYPTO_INVALID_DIGEST(
        env(), ""Invalid digest: %s"", hash_type);
  if (key_len == 0) {
    key = """";
  }
  ctx_.reset(HMAC_CTX_new());
  if (!ctx_ || !HMAC_Init_ex(ctx_.get(), key, key_len, md, nullptr)) {
    ctx_.reset();
    return ThrowCryptoError(env(), ERR_get_error());
  }
}",74,,69,4,,void
42891,BLOCK,-1,,<empty>,5,,74,2,,void
42901,BLOCK,-1,,"{
    key = """";
  }",21,,76,2,,void
42924,BLOCK,-1,,"{
    ctx_.reset();
    return ThrowCryptoError(env(), ERR_get_error());
  }",70,,80,2,,void
42937,BLOCK,-1,,"{
  Hmac* hmac;
  ASSIGN_OR_RETURN_UNWRAP(&hmac, args.Holder());
  Environment* env = hmac->env();

  const node::Utf8Value hash_type(env->isolate(), args[0]);
  ByteSource key = ByteSource::FromSecretKeyBytes(env, args[1]);
  hmac->HmacInit(*hash_type, key.data<char>(), key.size());
}",62,,86,2,,void
42992,BLOCK,-1,,"{
  return ctx_ && HMAC_Update(ctx_.get(),
                             reinterpret_cast<const unsigned char*>(data),
                             len) == 1;
}",53,,96,3,,void
43010,BLOCK,-1,,"{
  Decode<Hmac>(args, [](Hmac* hmac, const FunctionCallbackInfo<Value>& args,
                        const char* data, size_t size) {
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    bool r = hmac->HmacUpdate(data, size);
    args.GetReturnValue().Set(r);
  });
}",64,,102,2,,void
43023,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  Hmac* hmac;
  ASSIGN_OR_RETURN_UNWRAP(&hmac, args.Holder());

  enum encoding encoding = BUFFER;
  if (args.Length() >= 1) {
    encoding = ParseEncoding(env->isolate(), args[0], BUFFER);
  }

  unsigned char md_value[EVP_MAX_MD_SIZE];
  unsigned int md_len = 0;

  if (hmac->ctx_) {
    bool ok = HMAC_Final(hmac->ctx_.get(), md_value, &md_len);
    hmac->ctx_.reset();
    if (!ok) {
      return ThrowCryptoError(env, ERR_get_error(), ""Failed to finalize HMAC"");
    }
  }

  Local<Value> error;
  MaybeLocal<Value> rc =
      StringBytes::Encode(env->isolate(),
                          reinterpret_cast<const char*>(md_value),
                          md_len,
                          encoding,
                          &error);
  if (rc.IsEmpty()) {
    CHECK(!error.IsEmpty());
    env->isolate()->ThrowException(error);
    return;
  }
  args.GetReturnValue().Set(rc.FromMaybe(Local<Value>()));
}",64,,113,2,,void
43051,BLOCK,-1,,"{
    encoding = ParseEncoding(env->isolate(), args[0], BUFFER);
  }",27,,120,2,,void
43072,BLOCK,-1,,"{
    bool ok = HMAC_Final(hmac->ctx_.get(), md_value, &md_len);
    hmac->ctx_.reset();
    if (!ok) {
      return ThrowCryptoError(env, ERR_get_error(), ""Failed to finalize HMAC"");
    }
  }",19,,127,2,,void
43095,BLOCK,-1,,"{
      return ThrowCryptoError(env, ERR_get_error(), ""Failed to finalize HMAC"");
    }",14,,130,2,,void
43132,BLOCK,-1,,"{
    CHECK(!error.IsEmpty());
    env->isolate()->ThrowException(error);
    return;
  }",21,,142,2,,void
43164,BLOCK,-1,,<empty>,28,,156,2,,void
43169,BLOCK,-1,,"{
  if (&other == this) return *this;
  this->~HmacConfig();
  return *new (this) HmacConfig(std::move(other));
}",64,,158,2,,void
43175,BLOCK,-1,,<empty>,23,,159,2,,void
43197,BLOCK,-1,,"{
  tracker->TrackField(""key"", key.get());
  // If the job is sync, then the HmacConfig does not own the data
  if (job_mode == kCryptoJobAsync) {
    tracker->TrackFieldWithSize(""data"", data.size());
    tracker->TrackFieldWithSize(""signature"", signature.size());
  }
}",59,,164,2,,void
43211,BLOCK,-1,,"{
    tracker->TrackFieldWithSize(""data"", data.size());
    tracker->TrackFieldWithSize(""signature"", signature.size());
  }",36,,167,2,,void
43237,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  params->job_mode = mode;

  CHECK(args[offset]->IsUint32());  // SignConfiguration::Mode
  params->mode =
    static_cast<SignConfiguration::Mode>(args[offset].As<Uint32>()->Value());

  CHECK(args[offset + 1]->IsString());  // Hash
  CHECK(args[offset + 2]->IsObject());  // Key

  Utf8Value digest(env->isolate(), args[offset + 1]);
  params->digest = EVP_get_digestbyname(*digest);
  if (params->digest == nullptr) {
    THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
    return Nothing<bool>();
  }

  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args[offset + 2], Nothing<bool>());
  params->key = key->Data();

  ArrayBufferOrViewContents<char> data(args[offset + 3]);
  if (UNLIKELY(!data.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""data is too big"");
    return Nothing<bool>();
  }
  params->data = mode == kCryptoJobAsync
      ? data.ToCopy()
      : data.ToByteSource();

  if (!args[off...",25,,177,5,,void
43315,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
    return Nothing<bool>();
  }",34,,191,2,,void
43355,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""data is too big"");
    return Nothing<bool>();
  }",41,,201,2,,void
43387,BLOCK,-1,,"{
    ArrayBufferOrViewContents<char> signature(args[offset + 4]);
    if (UNLIKELY(!signature.CheckSizeInt32())) {
      THROW_ERR_OUT_OF_RANGE(env, ""signature is too big"");
      return Nothing<bool>();
    }
    params->signature = mode == kCryptoJobAsync
        ? signature.ToCopy()
        : signature.ToByteSource();
  }",41,,209,2,,void
43402,BLOCK,-1,,"{
      THROW_ERR_OUT_OF_RANGE(env, ""signature is too big"");
      return Nothing<bool>();
    }",48,,211,2,,void
43433,BLOCK,-1,,"{
  HMACCtxPointer ctx(HMAC_CTX_new());

  if (!ctx ||
      !HMAC_Init_ex(
          ctx.get(),
          params.key->GetSymmetricKey(),
          params.key->GetSymmetricKeySize(),
          params.digest,
          nullptr)) {
    return false;
  }

  if (!HMAC_Update(
          ctx.get(),
          params.data.data<unsigned char>(),
          params.data.size())) {
    return false;
  }

  ByteSource::Builder buf(EVP_MAX_MD_SIZE);
  unsigned int len;

  if (!HMAC_Final(ctx.get(), buf.data<unsigned char>(), &len)) {
    return false;
  }

  *out = std::move(buf).release(len);

  return true;
}",22,,226,4,,void
43463,BLOCK,-1,,"{
    return false;
  }",21,,235,2,,void
43485,BLOCK,-1,,"{
    return false;
  }",32,,242,2,,void
43505,BLOCK,-1,,"{
    return false;
  }",64,,249,2,,void
43529,BLOCK,-1,,"{
  switch (params.mode) {
    case SignConfiguration::kSign:
      *result = out->ToArrayBuffer(env);
      break;
    case SignConfiguration::kVerify:
      *result = Boolean::New(
          env->isolate(),
          out->size() > 0 && out->size() == params.signature.size() &&
              memcmp(out->data(), params.signature.data(), out->size()) == 0);
      break;
    default:
      UNREACHABLE();
  }
  return Just(!result->IsEmpty());
}",27,,262,5,,void
43534,BLOCK,-1,,"{
    case SignConfiguration::kSign:
      *result = out->ToArrayBuffer(env);
      break;
    case SignConfiguration::kVerify:
      *result = Boolean::New(
          env->isolate(),
          out->size() > 0 && out->size() == params.signature.size() &&
              memcmp(out->data(), params.signature.data(), out->size()) == 0);
      break;
    default:
      UNREACHABLE();
  }",24,,263,2,,void
43629,BLOCK,-1,,<empty>,1,,1,1,,ANY
43652,BLOCK,-1,,<empty>,1,,1,1,,ANY
43660,BLOCK,-1,,"{
  CHECK(args[*offset]->IsInt32());
  params->params.id = args[*offset].As<Int32>()->Value();

  *offset += 1;

  return Just(true);
}",34,,37,5,,void
43696,BLOCK,-1,,"{
  EVPKeyCtxPointer ctx =
      EVPKeyCtxPointer(EVP_PKEY_CTX_new_id(params->params.id, nullptr));
  if (!ctx || EVP_PKEY_keygen_init(ctx.get()) <= 0)
    return EVPKeyCtxPointer();

  return ctx;
}",74,,46,2,,void
43719,BLOCK,-1,,<empty>,5,,50,2,,void
43728,BLOCK,-1,,"{
  if (out) tracker->TrackFieldWithSize(""out"", length);
}",67,,55,2,,void
43731,BLOCK,-1,,<empty>,12,,56,2,,void
43745,BLOCK,-1,,"{
  CHECK(args[*offset]->IsUint32());
  uint32_t bits = args[*offset].As<Uint32>()->Value();
  static_assert(std::numeric_limits<decltype(bits)>::max() / CHAR_BIT <=
                INT_MAX);
  params->length = bits / CHAR_BIT;
  *offset += 1;
  return Just(true);
}",33,,63,5,,void
43797,BLOCK,-1,,"{
  CHECK_LE(params->length, INT_MAX);
  ByteSource::Builder bytes(params->length);
  if (CSPRNG(bytes.data<unsigned char>(), params->length).is_err())
    return KeyGenJobStatus::FAILED;
  params->out = std::move(bytes).release();
  return KeyGenJobStatus::OK;
}",33,,75,3,,void
43820,BLOCK,-1,,<empty>,5,,79,2,,void
43847,BLOCK,-1,,"{
  std::shared_ptr<KeyObjectData> data =
      KeyObjectData::CreateSecret(std::move(params->out));
  return Just(KeyObjectHandle::Create(env, data).ToLocal(result));
}",65,,86,4,,void
43885,BLOCK,-1,,"{
  NidKeyPairGenJob::Initialize(env, target);
  SecretKeyGenJob::Initialize(env, target);
}",57,,93,3,,void
43902,BLOCK,-1,,"{
  NidKeyPairGenJob::RegisterExternalReferences(registry);
  SecretKeyGenJob::RegisterExternalReferences(registry);
}",70,,98,2,,void
43933,BLOCK,-1,,<empty>,1,,1,1,,ANY
43938,BLOCK,-1,,"{  // NOLINT(runtime/int)
        return d2i_PUBKEY(nullptr, p, l);
      }",43,,115,3,,void
43951,BLOCK,-1,,"{  // NOLINT(runtime/int)
        return d2i_PublicKey(EVP_PKEY_RSA, nullptr, p, l);
      }",43,,124,3,,void
43964,BLOCK,-1,,"{  // NOLINT(runtime/int)
        X509Pointer x509(d2i_X509(nullptr, p, l));
        return x509 ? X509_get_pubkey(x509.get()) : nullptr;
      }",43,,133,3,,void
44019,BLOCK,-1,,<empty>,1,,1,1,,ANY
44028,BLOCK,-1,,"{
  // During key pair generation, it is possible not to specify a key encoding,
  // which will lead to a key object being returned.
  if (args[*offset]->IsUndefined()) {
    CHECK_EQ(context, kKeyContextGenerate);
    CHECK(args[*offset + 1]->IsUndefined());
    config->output_key_object_ = true;
  } else {
    config->output_key_object_ = false;

    CHECK(args[*offset]->IsInt32());
    config->format_ = static_cast<PKFormatType>(
        args[*offset].As<Int32>()->Value());

    if (args[*offset + 1]->IsInt32()) {
      config->type_ = Just<PKEncodingType>(static_cast<PKEncodingType>(
          args[*offset + 1].As<Int32>()->Value()));
    } else {
      CHECK(
          (context == kKeyContextInput &&
           config->format_ == kKeyFormatPEM) ||
          (context == kKeyContextGenerate &&
           config->format_ == kKeyFormatJWK));
      CHECK(args[*offset + 1]->IsNullOrUndefined());
      config->type_ = Nothing<PKEncodingType>();
    }
  }

  *offset += 2;
}",33,,47,5,,void
44037,BLOCK,-1,,"{
    CHECK_EQ(context, kKeyContextGenerate);
    CHECK(args[*offset + 1]->IsUndefined());
    config->output_key_object_ = true;
  }",37,,50,2,,void
44057,BLOCK,-1,,"{
    config->output_key_object_ = false;

    CHECK(args[*offset]->IsInt32());
    config->format_ = static_cast<PKFormatType>(
        args[*offset].As<Int32>()->Value());

    if (args[*offset + 1]->IsInt32()) {
      config->type_ = Just<PKEncodingType>(static_cast<PKEncodingType>(
          args[*offset + 1].As<Int32>()->Value()));
    } else {
      CHECK(
          (context == kKeyContextInput &&
           config->format_ == kKeyFormatPEM) ||
          (context == kKeyContextGenerate &&
           config->format_ == kKeyFormatJWK));
      CHECK(args[*offset + 1]->IsNullOrUndefined());
      config->type_ = Nothing<PKEncodingType>();
    }
  }",10,,54,1,,void
44097,BLOCK,-1,,"{
      config->type_ = Just<PKEncodingType>(static_cast<PKEncodingType>(
          args[*offset + 1].As<Int32>()->Value()));
    }",39,,61,2,,void
44121,BLOCK,-1,,"{
      CHECK(
          (context == kKeyContextInput &&
           config->format_ == kKeyFormatPEM) ||
          (context == kKeyContextGenerate &&
           config->format_ == kKeyFormatJWK));
      CHECK(args[*offset + 1]->IsNullOrUndefined());
      config->type_ = Nothing<PKEncodingType>();
    }",12,,64,1,,void
44168,BLOCK,-1,,"{
  unsigned char* der_data;
  long der_len;  // NOLINT(runtime/int)

  // This skips surrounding data and decodes PEM to DER.
  {
    MarkPopErrorOnReturn mark_pop_error_on_return;
    if (PEM_bytes_read_bio(&der_data, &der_len, nullptr, name,
                           bp.get(), nullptr, nullptr) != 1)
      return ParseKeyResult::kParseKeyNotRecognized;
  }

  // OpenSSL might modify the pointer, so we need to make a copy before parsing.
  const unsigned char* p = der_data;
  pkey->reset(parse(&p, der_len));
  OPENSSL_clear_free(der_data, der_len);

  return *pkey ? ParseKeyResult::kParseKeyOk :
                 ParseKeyResult::kParseKeyFailed;
}",77,,83,5,,void
44171,BLOCK,3,,"{
    MarkPopErrorOnReturn mark_pop_error_on_return;
    if (PEM_bytes_read_bio(&der_data, &der_len, nullptr, name,
                           bp.get(), nullptr, nullptr) != 1)
      return ParseKeyResult::kParseKeyNotRecognized;
  }",3,,88,3,,void
44189,BLOCK,-1,,<empty>,7,,92,2,,void
44225,BLOCK,-1,,"{
  BIOPointer bp(BIO_new_mem_buf(const_cast<char*>(key_pem), key_pem_len));
  if (!bp)
    return ParseKeyResult::kParseKeyFailed;

  ParseKeyResult ret;

  // Try parsing as a SubjectPublicKeyInfo first.
  ret = TryParsePublicKey(pkey, bp, ""PUBLIC KEY"",
      [](const unsigned char** p, long l) {  // NOLINT(runtime/int)
        return d2i_PUBKEY(nullptr, p, l);
      });
  if (ret != ParseKeyResult::kParseKeyNotRecognized)
    return ret;

  // Maybe it is PKCS#1.
  CHECK(BIO_reset(bp.get()));
  ret = TryParsePublicKey(pkey, bp, ""RSA PUBLIC KEY"",
      [](const unsigned char** p, long l) {  // NOLINT(runtime/int)
        return d2i_PublicKey(EVP_PKEY_RSA, nullptr, p, l);
      });
  if (ret != ParseKeyResult::kParseKeyNotRecognized)
    return ret;

  // X.509 fallback.
  CHECK(BIO_reset(bp.get()));
  return TryParsePublicKey(pkey, bp, ""CERTIFICATE"",
      [](const unsigned char** p, long l) {  // NOLINT(runtime/int)
        X509Pointer x509(d2i_X509(nullptr, p, l));
        retur...",51,,106,4,,void
44236,BLOCK,-1,,<empty>,5,,109,2,,void
44255,BLOCK,-1,,<empty>,5,,119,2,,void
44277,BLOCK,-1,,<empty>,5,,128,2,,void
44299,BLOCK,-1,,"{
  if (config.format_ == kKeyFormatPEM) {
    return ParsePublicKeyPEM(pkey, key, key_len);
  } else {
    CHECK_EQ(config.format_, kKeyFormatDER);

    const unsigned char* p = reinterpret_cast<const unsigned char*>(key);
    if (config.type_.ToChecked() == kKeyEncodingPKCS1) {
      pkey->reset(d2i_PublicKey(EVP_PKEY_RSA, nullptr, &p, key_len));
    } else {
      CHECK_EQ(config.type_.ToChecked(), kKeyEncodingSPKI);
      pkey->reset(d2i_PUBKEY(nullptr, &p, key_len));
    }

    return *pkey ? ParseKeyResult::kParseKeyOk :
                   ParseKeyResult::kParseKeyFailed;
  }
}",47,,142,5,,void
44306,BLOCK,-1,,"{
    return ParsePublicKeyPEM(pkey, key, key_len);
  }",40,,143,2,,void
44313,BLOCK,-1,,"{
    CHECK_EQ(config.format_, kKeyFormatDER);

    const unsigned char* p = reinterpret_cast<const unsigned char*>(key);
    if (config.type_.ToChecked() == kKeyEncodingPKCS1) {
      pkey->reset(d2i_PublicKey(EVP_PKEY_RSA, nullptr, &p, key_len));
    } else {
      CHECK_EQ(config.type_.ToChecked(), kKeyEncodingSPKI);
      pkey->reset(d2i_PUBKEY(nullptr, &p, key_len));
    }

    return *pkey ? ParseKeyResult::kParseKeyOk :
                   ParseKeyResult::kParseKeyFailed;
  }",10,,145,1,,void
44334,BLOCK,-1,,"{
      pkey->reset(d2i_PublicKey(EVP_PKEY_RSA, nullptr, &p, key_len));
    }",56,,149,2,,void
44346,BLOCK,-1,,"{
      CHECK_EQ(config.type_.ToChecked(), kKeyEncodingSPKI);
      pkey->reset(d2i_PUBKEY(nullptr, &p, key_len));
    }",12,,151,1,,void
44381,BLOCK,-1,,"{
  if (size < 2 || data[0] != 0x30)
    return false;

  if (data[1] & 0x80) {
    // Long form.
    size_t n_bytes = data[1] & ~0x80;
    if (n_bytes + 2 > size || n_bytes > sizeof(size_t))
      return false;
    size_t length = 0;
    for (size_t i = 0; i < n_bytes; i++)
      length = (length << 8) | data[i + 2];
    *data_offset = 2 + n_bytes;
    *data_size = std::min(size - 2 - n_bytes, length);
  } else {
    // Short form.
    *data_offset = 2;
    *data_size = std::min<size_t>(size - 2, data[1]);
  }

  return true;
}",61,,162,5,,void
44392,BLOCK,-1,,<empty>,5,,164,2,,void
44401,BLOCK,-1,,"{
    // Long form.
    size_t n_bytes = data[1] & ~0x80;
    if (n_bytes + 2 > size || n_bytes > sizeof(size_t))
      return false;
    size_t length = 0;
    for (size_t i = 0; i < n_bytes; i++)
      length = (length << 8) | data[i + 2];
    *data_offset = 2 + n_bytes;
    *data_size = std::min(size - 2 - n_bytes, length);
  }",23,,166,2,,void
44422,BLOCK,-1,,<empty>,7,,170,2,,void
44430,BLOCK,-1,,<empty>,5,,172,1,,void
44471,BLOCK,-1,,"{
    // Short form.
    *data_offset = 2;
    *data_size = std::min<size_t>(size - 2, data[1]);
  }",10,,176,1,,void
44500,BLOCK,-1,,"{
  // Both RSAPrivateKey and RSAPublicKey structures start with a SEQUENCE.
  size_t offset, len;
  if (!IsASN1Sequence(data, size, &offset, &len))
    return false;

  // An RSAPrivateKey sequence always starts with a single-byte integer whose
  // value is either 0 or 1, whereas an RSAPublicKey starts with the modulus
  // (which is the product of two primes and therefore at least 4), so we can
  // decide the type of the structure based on the first three bytes of the
  // sequence.
  return len >= 3 &&
         data[offset] == 2 &&
         data[offset + 1] == 1 &&
         !(data[offset + 2] & 0xfe);
}",62,,185,3,,void
44512,BLOCK,-1,,<empty>,5,,189,2,,void
44547,BLOCK,-1,,"{
  // Both PrivateKeyInfo and EncryptedPrivateKeyInfo start with a SEQUENCE.
  size_t offset, len;
  if (!IsASN1Sequence(data, size, &offset, &len))
    return false;

  // A PrivateKeyInfo sequence always starts with an integer whereas an
  // EncryptedPrivateKeyInfo starts with an AlgorithmIdentifier.
  return len >= 1 &&
         data[offset] != 2;
}",72,,202,3,,void
44559,BLOCK,-1,,<empty>,5,,206,2,,void
44579,BLOCK,-1,,"{
  const ByteSource* passphrase = config.passphrase_.get();

  if (config.format_ == kKeyFormatPEM) {
    BIOPointer bio(BIO_new_mem_buf(key, key_len));
    if (!bio)
      return ParseKeyResult::kParseKeyFailed;

    pkey->reset(PEM_read_bio_PrivateKey(bio.get(),
                                        nullptr,
                                        PasswordCallback,
                                        &passphrase));
  } else {
    CHECK_EQ(config.format_, kKeyFormatDER);

    if (config.type_.ToChecked() == kKeyEncodingPKCS1) {
      const unsigned char* p = reinterpret_cast<const unsigned char*>(key);
      pkey->reset(d2i_PrivateKey(EVP_PKEY_RSA, nullptr, &p, key_len));
    } else if (config.type_.ToChecked() == kKeyEncodingPKCS8) {
      BIOPointer bio(BIO_new_mem_buf(key, key_len));
      if (!bio)
        return ParseKeyResult::kParseKeyFailed;

      if (IsEncryptedPrivateKeyInfo(
              reinterpret_cast<const unsigned char*>(key), key_len)) {
        pkey->rese...",48,,217,5,,void
44595,BLOCK,-1,,"{
    BIOPointer bio(BIO_new_mem_buf(key, key_len));
    if (!bio)
      return ParseKeyResult::kParseKeyFailed;

    pkey->reset(PEM_read_bio_PrivateKey(bio.get(),
                                        nullptr,
                                        PasswordCallback,
                                        &passphrase));
  }",40,,220,2,,void
44604,BLOCK,-1,,<empty>,7,,223,2,,void
44623,BLOCK,-1,,"{
    CHECK_EQ(config.format_, kKeyFormatDER);

    if (config.type_.ToChecked() == kKeyEncodingPKCS1) {
      const unsigned char* p = reinterpret_cast<const unsigned char*>(key);
      pkey->reset(d2i_PrivateKey(EVP_PKEY_RSA, nullptr, &p, key_len));
    } else if (config.type_.ToChecked() == kKeyEncodingPKCS8) {
      BIOPointer bio(BIO_new_mem_buf(key, key_len));
      if (!bio)
        return ParseKeyResult::kParseKeyFailed;

      if (IsEncryptedPrivateKeyInfo(
              reinterpret_cast<const unsigned char*>(key), key_len)) {
        pkey->reset(d2i_PKCS8PrivateKey_bio(bio.get(),
                                            nullptr,
                                            PasswordCallback,
                                            &passphrase));
      } else {
        PKCS8Pointer p8inf(d2i_PKCS8_PRIV_KEY_INFO_bio(bio.get(), nullptr));
        if (p8inf)
          pkey->reset(EVP_PKCS82PKEY(p8inf.get()));
      }
    } else {
      CHECK_EQ(config.type_.ToChecked(), k...",10,,229,1,,void
44638,BLOCK,-1,,"{
      const unsigned char* p = reinterpret_cast<const unsigned char*>(key);
      pkey->reset(d2i_PrivateKey(EVP_PKEY_RSA, nullptr, &p, key_len));
    }",56,,232,2,,void
44656,BLOCK,-1,,<empty>,12,,235,1,,void
44666,BLOCK,-1,,"{
      BIOPointer bio(BIO_new_mem_buf(key, key_len));
      if (!bio)
        return ParseKeyResult::kParseKeyFailed;

      if (IsEncryptedPrivateKeyInfo(
              reinterpret_cast<const unsigned char*>(key), key_len)) {
        pkey->reset(d2i_PKCS8PrivateKey_bio(bio.get(),
                                            nullptr,
                                            PasswordCallback,
                                            &passphrase));
      } else {
        PKCS8Pointer p8inf(d2i_PKCS8_PRIV_KEY_INFO_bio(bio.get(), nullptr));
        if (p8inf)
          pkey->reset(EVP_PKCS82PKEY(p8inf.get()));
      }
    }",63,,235,2,,void
44675,BLOCK,-1,,<empty>,9,,238,2,,void
44686,BLOCK,-1,,"{
        pkey->reset(d2i_PKCS8PrivateKey_bio(bio.get(),
                                            nullptr,
                                            PasswordCallback,
                                            &passphrase));
      }",70,,241,2,,void
44701,BLOCK,-1,,"{
        PKCS8Pointer p8inf(d2i_PKCS8_PRIV_KEY_INFO_bio(bio.get(), nullptr));
        if (p8inf)
          pkey->reset(EVP_PKCS82PKEY(p8inf.get()));
      }",14,,246,1,,void
44712,BLOCK,-1,,<empty>,11,,249,2,,void
44723,BLOCK,-1,,"{
      CHECK_EQ(config.type_.ToChecked(), kKeyEncodingSEC1);
      const unsigned char* p = reinterpret_cast<const unsigned char*>(key);
      pkey->reset(d2i_PrivateKey(EVP_PKEY_EC, nullptr, &p, key_len));
    }",12,,251,1,,void
44756,BLOCK,-1,,<empty>,5,,261,2,,void
44764,BLOCK,-1,,<empty>,5,,264,2,,void
44779,BLOCK,-1,,"{
    if (config.passphrase_.IsEmpty())
      return ParseKeyResult::kParseKeyNeedPassphrase;
  }",55,,266,2,,void
44787,BLOCK,-1,,<empty>,7,,268,2,,void
44802,BLOCK,-1,,"{
  BUF_MEM* bptr;
  BIO_get_mem_ptr(bio, &bptr);
  if (format == kKeyFormatPEM) {
    // PEM is an ASCII format, so we will return it as a string.
    return String::NewFromUtf8(env->isolate(), bptr->data,
                               NewStringType::kNormal,
                               bptr->length).FromMaybe(Local<Value>());
  } else {
    CHECK_EQ(format, kKeyFormatDER);
    // DER is binary, return it as a buffer.
    return Buffer::Copy(env, bptr->data, bptr->length)
        .FromMaybe(Local<Value>());
  }
}",26,,276,4,,void
44812,BLOCK,-1,,"{
    // PEM is an ASCII format, so we will return it as a string.
    return String::NewFromUtf8(env->isolate(), bptr->data,
                               NewStringType::kNormal,
                               bptr->length).FromMaybe(Local<Value>());
  }",32,,279,2,,void
44836,BLOCK,-1,,"{
    CHECK_EQ(format, kKeyFormatDER);
    // DER is binary, return it as a buffer.
    return Buffer::Copy(env, bptr->data, bptr->length)
        .FromMaybe(Local<Value>());
  }",10,,284,1,,void
44862,BLOCK,-1,,"{
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);

  // If an empty string was passed as the passphrase, the ByteSource might
  // contain a null pointer, which OpenSSL will ignore, causing it to invoke its
  // default passphrase callback, which would block the thread until the user
  // manually enters a passphrase. We could supply our own passphrase callback
  // to handle this special case, but it is easier to avoid passing a null
  // pointer to OpenSSL.
  char* pass = nullptr;
  size_t pass_len = 0;
  if (!config.passphrase_.IsEmpty()) {
    pass = const_cast<char*>(config.passphrase_->data<char>());
    pass_len = config.passphrase_->size();
    if (pass == nullptr) {
      // OpenSSL will not actually dereference this pointer, so it can be any
      // non-null pointer. We cannot assert that directly, which is why we
      // intentionally use a pointer that will likely cause a segmentation fault
      // when dereferenced.
      CHECK_EQ(pass_len, 0);
      pass = rei...",45,,296,4,,void
44865,BLOCK,-1,,<empty>,,,,2,,<empty>
44886,BLOCK,-1,,"{
    pass = const_cast<char*>(config.passphrase_->data<char>());
    pass_len = config.passphrase_->size();
    if (pass == nullptr) {
      // OpenSSL will not actually dereference this pointer, so it can be any
      // non-null pointer. We cannot assert that directly, which is why we
      // intentionally use a pointer that will likely cause a segmentation fault
      // when dereferenced.
      CHECK_EQ(pass_len, 0);
      pass = reinterpret_cast<char*>(-1);
      CHECK_NE(pass, nullptr);
    }
  }",38,,308,2,,void
44909,BLOCK,-1,,"{
      // OpenSSL will not actually dereference this pointer, so it can be any
      // non-null pointer. We cannot assert that directly, which is why we
      // intentionally use a pointer that will likely cause a segmentation fault
      // when dereferenced.
      CHECK_EQ(pass_len, 0);
      pass = reinterpret_cast<char*>(-1);
      CHECK_NE(pass, nullptr);
    }",26,,311,2,,void
44937,BLOCK,-1,,"{
    // PKCS#1 is only permitted for RSA keys.
    CHECK_EQ(EVP_PKEY_id(pkey), EVP_PKEY_RSA);

    RSAPointer rsa(EVP_PKEY_get1_RSA(pkey));
    if (config.format_ == kKeyFormatPEM) {
      // Encode PKCS#1 as PEM.
      err = PEM_write_bio_RSAPrivateKey(
                bio.get(), rsa.get(),
                config.cipher_,
                reinterpret_cast<unsigned char*>(pass),
                pass_len,
                nullptr, nullptr) != 1;
    } else {
      // Encode PKCS#1 as DER. This does not permit encryption.
      CHECK_EQ(config.format_, kKeyFormatDER);
      CHECK_NULL(config.cipher_);
      err = i2d_RSAPrivateKey_bio(bio.get(), rsa.get()) != 1;
    }
  }",43,,326,2,,void
44952,BLOCK,-1,,"{
      // Encode PKCS#1 as PEM.
      err = PEM_write_bio_RSAPrivateKey(
                bio.get(), rsa.get(),
                config.cipher_,
                reinterpret_cast<unsigned char*>(pass),
                pass_len,
                nullptr, nullptr) != 1;
    }",42,,331,2,,void
44976,BLOCK,-1,,"{
      // Encode PKCS#1 as DER. This does not permit encryption.
      CHECK_EQ(config.format_, kKeyFormatDER);
      CHECK_NULL(config.cipher_);
      err = i2d_RSAPrivateKey_bio(bio.get(), rsa.get()) != 1;
    }",12,,339,1,,void
45000,BLOCK,-1,,<empty>,10,,345,1,,void
45005,BLOCK,-1,,"{
    if (config.format_ == kKeyFormatPEM) {
      // Encode PKCS#8 as PEM.
      err = PEM_write_bio_PKCS8PrivateKey(
                bio.get(), pkey,
                config.cipher_,
                pass,
                pass_len,
                nullptr, nullptr) != 1;
    } else {
      // Encode PKCS#8 as DER.
      CHECK_EQ(config.format_, kKeyFormatDER);
      err = i2d_PKCS8PrivateKey_bio(
                bio.get(), pkey,
                config.cipher_,
                pass,
                pass_len,
                nullptr, nullptr) != 1;
    }
  }",50,,345,2,,void
45012,BLOCK,-1,,"{
      // Encode PKCS#8 as PEM.
      err = PEM_write_bio_PKCS8PrivateKey(
                bio.get(), pkey,
                config.cipher_,
                pass,
                pass_len,
                nullptr, nullptr) != 1;
    }",42,,346,2,,void
45031,BLOCK,-1,,"{
      // Encode PKCS#8 as DER.
      CHECK_EQ(config.format_, kKeyFormatDER);
      err = i2d_PKCS8PrivateKey_bio(
                bio.get(), pkey,
                config.cipher_,
                pass,
                pass_len,
                nullptr, nullptr) != 1;
    }",12,,354,1,,void
45055,BLOCK,-1,,"{
    CHECK_EQ(encoding_type, kKeyEncodingSEC1);

    // SEC1 is only permitted for EC keys.
    CHECK_EQ(EVP_PKEY_id(pkey), EVP_PKEY_EC);

    ECKeyPointer ec_key(EVP_PKEY_get1_EC_KEY(pkey));
    if (config.format_ == kKeyFormatPEM) {
      // Encode SEC1 as PEM.
      err = PEM_write_bio_ECPrivateKey(
                bio.get(), ec_key.get(),
                config.cipher_,
                reinterpret_cast<unsigned char*>(pass),
                pass_len,
                nullptr, nullptr) != 1;
    } else {
      // Encode SEC1 as DER. This does not permit encryption.
      CHECK_EQ(config.format_, kKeyFormatDER);
      CHECK_NULL(config.cipher_);
      err = i2d_ECPrivateKey_bio(bio.get(), ec_key.get()) != 1;
    }
  }",10,,364,1,,void
45073,BLOCK,-1,,"{
      // Encode SEC1 as PEM.
      err = PEM_write_bio_ECPrivateKey(
                bio.get(), ec_key.get(),
                config.cipher_,
                reinterpret_cast<unsigned char*>(pass),
                pass_len,
                nullptr, nullptr) != 1;
    }",42,,371,2,,void
45097,BLOCK,-1,,"{
      // Encode SEC1 as DER. This does not permit encryption.
      CHECK_EQ(config.format_, kKeyFormatDER);
      CHECK_NULL(config.cipher_);
      err = i2d_ECPrivateKey_bio(bio.get(), ec_key.get()) != 1;
    }",12,,379,1,,void
45122,BLOCK,-1,,"{
    ThrowCryptoError(env, ERR_get_error(), ""Failed to encode private key"");
    return MaybeLocal<Value>();
  }",12,,387,2,,void
45145,BLOCK,-1,,"{
  if (config.type_.ToChecked() == kKeyEncodingPKCS1) {
    // PKCS#1 is only valid for RSA keys.
    CHECK_EQ(EVP_PKEY_id(pkey), EVP_PKEY_RSA);
    RSAPointer rsa(EVP_PKEY_get1_RSA(pkey));
    if (config.format_ == kKeyFormatPEM) {
      // Encode PKCS#1 as PEM.
      return PEM_write_bio_RSAPublicKey(bio.get(), rsa.get()) == 1;
    } else {
      // Encode PKCS#1 as DER.
      CHECK_EQ(config.format_, kKeyFormatDER);
      return i2d_RSAPublicKey_bio(bio.get(), rsa.get()) == 1;
    }
  } else {
    CHECK_EQ(config.type_.ToChecked(), kKeyEncodingSPKI);
    if (config.format_ == kKeyFormatPEM) {
      // Encode SPKI as PEM.
      return PEM_write_bio_PUBKEY(bio.get(), pkey) == 1;
    } else {
      // Encode SPKI as DER.
      CHECK_EQ(config.format_, kKeyFormatDER);
      return i2d_PUBKEY_bio(bio.get(), pkey) == 1;
    }
  }
}",65,,396,4,,void
45155,BLOCK,-1,,"{
    // PKCS#1 is only valid for RSA keys.
    CHECK_EQ(EVP_PKEY_id(pkey), EVP_PKEY_RSA);
    RSAPointer rsa(EVP_PKEY_get1_RSA(pkey));
    if (config.format_ == kKeyFormatPEM) {
      // Encode PKCS#1 as PEM.
      return PEM_write_bio_RSAPublicKey(bio.get(), rsa.get()) == 1;
    } else {
      // Encode PKCS#1 as DER.
      CHECK_EQ(config.format_, kKeyFormatDER);
      return i2d_RSAPublicKey_bio(bio.get(), rsa.get()) == 1;
    }
  }",54,,397,2,,void
45170,BLOCK,-1,,"{
      // Encode PKCS#1 as PEM.
      return PEM_write_bio_RSAPublicKey(bio.get(), rsa.get()) == 1;
    }",42,,401,2,,void
45184,BLOCK,-1,,"{
      // Encode PKCS#1 as DER.
      CHECK_EQ(config.format_, kKeyFormatDER);
      return i2d_RSAPublicKey_bio(bio.get(), rsa.get()) == 1;
    }",12,,404,1,,void
45203,BLOCK,-1,,"{
    CHECK_EQ(config.type_.ToChecked(), kKeyEncodingSPKI);
    if (config.format_ == kKeyFormatPEM) {
      // Encode SPKI as PEM.
      return PEM_write_bio_PUBKEY(bio.get(), pkey) == 1;
    } else {
      // Encode SPKI as DER.
      CHECK_EQ(config.format_, kKeyFormatDER);
      return i2d_PUBKEY_bio(bio.get(), pkey) == 1;
    }
  }",10,,409,1,,void
45218,BLOCK,-1,,"{
      // Encode SPKI as PEM.
      return PEM_write_bio_PUBKEY(bio.get(), pkey) == 1;
    }",42,,411,2,,void
45229,BLOCK,-1,,"{
      // Encode SPKI as DER.
      CHECK_EQ(config.format_, kKeyFormatDER);
      return i2d_PUBKEY_bio(bio.get(), pkey) == 1;
    }",12,,414,1,,void
45250,BLOCK,-1,,"{
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);

  if (!WritePublicKeyInner(pkey, bio, config)) {
    ThrowCryptoError(env, ERR_get_error(), ""Failed to encode public key"");
    return MaybeLocal<Value>();
  }
  return BIOToStringOrBuffer(env, bio.get(), config.format_);
}",73,,424,4,,void
45253,BLOCK,-1,,<empty>,,,,2,,<empty>
45264,BLOCK,-1,,"{
    ThrowCryptoError(env, ERR_get_error(), ""Failed to encode public key"");
    return MaybeLocal<Value>();
  }",48,,428,2,,void
45287,BLOCK,-1,,"{
  CHECK_EQ(key->GetKeyType(), kKeyTypeSecret);

  Local<Value> error;
  Local<Value> raw;
  MaybeLocal<Value> key_data =
      StringBytes::Encode(
          env->isolate(),
          key->GetSymmetricKey(),
          key->GetSymmetricKeySize(),
          BASE64URL,
          &error);
  if (key_data.IsEmpty()) {
    CHECK(!error.IsEmpty());
    env->isolate()->ThrowException(error);
    return Nothing<bool>();
  }
  if (!key_data.ToLocal(&raw))
    return Nothing<bool>();

  if (target->Set(
          env->context(),
          env->jwk_kty_string(),
          env->jwk_oct_string()).IsNothing() ||
      target->Set(
          env->context(),
          env->jwk_k_string(),
          raw).IsNothing()) {
    return Nothing<bool>();
  }

  return Just(true);
}",27,,438,4,,void
45334,BLOCK,-1,,"{
    CHECK(!error.IsEmpty());
    env->isolate()->ThrowException(error);
    return Nothing<bool>();
  }",27,,450,2,,void
45359,BLOCK,-1,,<empty>,5,,456,2,,void
45399,BLOCK,-1,,"{
    return Nothing<bool>();
  }",29,,465,2,,void
45410,BLOCK,-1,,"{
  Local<Value> key;
  if (!jwk->Get(env->context(), env->jwk_k_string()).ToLocal(&key) ||
      !key->IsString()) {
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK secret key format"");
    return std::shared_ptr<KeyObjectData>();
  }

  static_assert(String::kMaxLength <= INT_MAX);
  ByteSource key_data = ByteSource::FromEncodedString(env, key.As<String>());
  return KeyObjectData::CreateSecret(std::move(key_data));
}",24,,474,3,,void
45441,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK secret key format"");
    return std::shared_ptr<KeyObjectData>();
  }",25,,477,2,,void
45485,BLOCK,-1,,"{
  switch (EVP_PKEY_id(key->GetAsymmetricKey().get())) {
    case EVP_PKEY_RSA_PSS: {
      if (handleRsaPss) return ExportJWKRsaKey(env, key, target);
      break;
    }
    case EVP_PKEY_RSA: return ExportJWKRsaKey(env, key, target);
    case EVP_PKEY_EC: return ExportJWKEcKey(env, key, target).IsJust() ?
                               Just(true) : Nothing<bool>();
    case EVP_PKEY_ED25519:
      // Fall through
    case EVP_PKEY_ED448:
      // Fall through
    case EVP_PKEY_X25519:
      // Fall through
    case EVP_PKEY_X448: return ExportJWKEdKey(env, key, target);
  }
  THROW_ERR_CRYPTO_JWK_UNSUPPORTED_KEY_TYPE(env);
  return Just(false);
}",24,,491,5,,void
45495,BLOCK,-1,,"{
    case EVP_PKEY_RSA_PSS: {
      if (handleRsaPss) return ExportJWKRsaKey(env, key, target);
      break;
    }
    case EVP_PKEY_RSA: return ExportJWKRsaKey(env, key, target);
    case EVP_PKEY_EC: return ExportJWKEcKey(env, key, target).IsJust() ?
                               Just(true) : Nothing<bool>();
    case EVP_PKEY_ED25519:
      // Fall through
    case EVP_PKEY_ED448:
      // Fall through
    case EVP_PKEY_X25519:
      // Fall through
    case EVP_PKEY_X448: return ExportJWKEdKey(env, key, target);
  }",55,,492,2,,void
45498,BLOCK,3,,"{
      if (handleRsaPss) return ExportJWKRsaKey(env, key, target);
      break;
    }",28,,493,3,,void
45501,BLOCK,-1,,<empty>,25,,494,2,,void
45555,BLOCK,-1,,"{
  if (strcmp(kty, ""RSA"") == 0) {
    return ImportJWKRsaKey(env, jwk, args, offset);
  } else if (strcmp(kty, ""EC"") == 0) {
    return ImportJWKEcKey(env, jwk, args, offset);
  }

  THROW_ERR_CRYPTO_INVALID_JWK(env, ""%s is not a supported JWK key type"", kty);
  return std::shared_ptr<KeyObjectData>();
}",26,,517,6,,void
45562,BLOCK,-1,,"{
    return ImportJWKRsaKey(env, jwk, args, offset);
  }",32,,518,2,,void
45570,BLOCK,-1,,<empty>,10,,520,1,,void
45577,BLOCK,-1,,"{
    return ImportJWKEcKey(env, jwk, args, offset);
  }",38,,520,2,,void
45599,BLOCK,-1,,"{
  // For the secret key detail, all we care about is the length,
  // converted to bits.

  size_t length = key->GetSymmetricKeySize() * CHAR_BIT;
  return target->Set(env->context(),
                     env->length_string(),
                     Number::New(env->isolate(), static_cast<double>(length)));
}",27,,531,4,,void
45639,BLOCK,-1,,"{
  switch (EVP_PKEY_id(key->GetAsymmetricKey().get())) {
    case EVP_PKEY_RSA:
      // Fall through
    case EVP_PKEY_RSA_PSS: return GetRsaKeyDetail(env, key, target);
    case EVP_PKEY_DSA: return GetDsaKeyDetail(env, key, target);
    case EVP_PKEY_EC: return GetEcKeyDetail(env, key, target);
    case EVP_PKEY_DH: return GetDhKeyDetail(env, key, target);
  }
  THROW_ERR_CRYPTO_INVALID_KEYTYPE(env);
  return Nothing<bool>();
}",25,,544,4,,void
45649,BLOCK,-1,,"{
    case EVP_PKEY_RSA:
      // Fall through
    case EVP_PKEY_RSA_PSS: return GetRsaKeyDetail(env, key, target);
    case EVP_PKEY_DSA: return GetDsaKeyDetail(env, key, target);
    case EVP_PKEY_EC: return GetEcKeyDetail(env, key, target);
    case EVP_PKEY_DH: return GetDhKeyDetail(env, key, target);
  }",55,,545,2,,void
45688,BLOCK,-1,,<empty>,39,,559,2,,void
45693,BLOCK,-1,,"{
  *this = that;
}",60,,561,2,,void
45702,BLOCK,-1,,"{
  Mutex::ScopedLock lock(*that.mutex_);

  pkey_.reset(that.get());

  if (pkey_)
    EVP_PKEY_up_ref(pkey_.get());

  mutex_ = that.mutex_;

  return *this;
}",71,,565,2,,void
45719,BLOCK,-1,,<empty>,5,,571,2,,void
45736,BLOCK,-1,,"{
  return !!pkey_;
}",39,,578,1,,void
45744,BLOCK,-1,,"{
  return pkey_.get();
}",39,,582,1,,void
45753,BLOCK,-1,,"{
  return mutex_.get();
}",38,,586,1,,void
45763,BLOCK,-1,,"{
  tracker->TrackFieldWithSize(""pkey"",
                              !pkey_ ? 0 : kSizeOf_EVP_PKEY +
                              size_of_private_key() +
                              size_of_public_key());
}",63,,590,2,,void
45781,BLOCK,-1,,"{
  size_t len = 0;
  return (pkey_ && EVP_PKEY_get_raw_private_key(
      pkey_.get(), nullptr, &len) == 1) ? len : 0;
}",52,,597,1,,void
45805,BLOCK,-1,,"{
  size_t len = 0;
  return (pkey_ && EVP_PKEY_get_raw_public_key(
      pkey_.get(), nullptr, &len) == 1) ? len : 0;
}",51,,603,1,,void
45830,BLOCK,-1,,"{
  return b ? Just(true) : Nothing<bool>();
}",44,,610,2,,void
45844,BLOCK,-1,,"{
  switch (key->GetKeyType()) {
    case kKeyTypeSecret:
      return ExportJWKSecretKey(env, key, result.As<Object>());
    case kKeyTypePublic:
      // Fall through
    case kKeyTypePrivate:
      return ExportJWKAsymmetricKey(
        env, key, result.As<Object>(), handleRsaPss);
    default:
      UNREACHABLE();
  }
}",47,,617,5,,void
45850,BLOCK,-1,,"{
    case kKeyTypeSecret:
      return ExportJWKSecretKey(env, key, result.As<Object>());
    case kKeyTypePublic:
      // Fall through
    case kKeyTypePrivate:
      return ExportJWKAsymmetricKey(
        env, key, result.As<Object>(), handleRsaPss);
    default:
      UNREACHABLE();
  }",30,,618,2,,void
45882,BLOCK,-1,,"{
  if (!*this) return Nothing<bool>();
  if (config.output_key_object_) {
    // Note that this has the downside of containing sensitive data of the
    // private key.
    std::shared_ptr<KeyObjectData> data =
        KeyObjectData::CreateAsymmetric(kKeyTypePublic, *this);
    return Tristate(KeyObjectHandle::Create(env, data).ToLocal(out));
  } else if (config.format_ == kKeyFormatJWK) {
    std::shared_ptr<KeyObjectData> data =
        KeyObjectData::CreateAsymmetric(kKeyTypePublic, *this);
    *out = Object::New(env->isolate());
    return ExportJWKInner(env, data, *out, false);
  }

  return Tristate(WritePublicKey(env, get(), config).ToLocal(out));
}",24,,634,4,,void
45887,BLOCK,-1,,<empty>,15,,635,2,,void
45894,BLOCK,-1,,"{
    // Note that this has the downside of containing sensitive data of the
    // private key.
    std::shared_ptr<KeyObjectData> data =
        KeyObjectData::CreateAsymmetric(kKeyTypePublic, *this);
    return Tristate(KeyObjectHandle::Create(env, data).ToLocal(out));
  }",34,,636,2,,void
45923,BLOCK,-1,,<empty>,10,,642,1,,void
45930,BLOCK,-1,,"{
    std::shared_ptr<KeyObjectData> data =
        KeyObjectData::CreateAsymmetric(kKeyTypePublic, *this);
    *out = Object::New(env->isolate());
    return ExportJWKInner(env, data, *out, false);
  }",47,,642,2,,void
45980,BLOCK,-1,,"{
  if (!*this) return Nothing<bool>();
  if (config.output_key_object_) {
    std::shared_ptr<KeyObjectData> data =
        KeyObjectData::CreateAsymmetric(kKeyTypePrivate, *this);
    return Tristate(KeyObjectHandle::Create(env, data).ToLocal(out));
  } else if (config.format_ == kKeyFormatJWK) {
    std::shared_ptr<KeyObjectData> data =
        KeyObjectData::CreateAsymmetric(kKeyTypePrivate, *this);
    *out = Object::New(env->isolate());
    return ExportJWKInner(env, data, *out, false);
  }

  return Tristate(WritePrivateKey(env, get(), config).ToLocal(out));
}",24,,655,4,,void
45985,BLOCK,-1,,<empty>,15,,656,2,,void
45992,BLOCK,-1,,"{
    std::shared_ptr<KeyObjectData> data =
        KeyObjectData::CreateAsymmetric(kKeyTypePrivate, *this);
    return Tristate(KeyObjectHandle::Create(env, data).ToLocal(out));
  }",34,,657,2,,void
46021,BLOCK,-1,,<empty>,10,,661,1,,void
46028,BLOCK,-1,,"{
    std::shared_ptr<KeyObjectData> data =
        KeyObjectData::CreateAsymmetric(kKeyTypePrivate, *this);
    *out = Object::New(env->isolate());
    return ExportJWKInner(env, data, *out, false);
  }",47,,661,2,,void
46078,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  PrivateKeyEncodingConfig result;
  GetKeyFormatAndTypeFromJs(&result, args, offset, context);

  if (result.output_key_object_) {
    if (context != kKeyContextInput)
      (*offset)++;
  } else {
    bool needs_passphrase = false;
    if (context != kKeyContextInput) {
      if (args[*offset]->IsString()) {
        Utf8Value cipher_name(env->isolate(), args[*offset]);
        result.cipher_ = EVP_get_cipherbyname(*cipher_name);
        if (result.cipher_ == nullptr) {
          THROW_ERR_CRYPTO_UNKNOWN_CIPHER(env);
          return NonCopyableMaybe<PrivateKeyEncodingConfig>();
        }
        needs_passphrase = true;
      } else {
        CHECK(args[*offset]->IsNullOrUndefined());
        result.cipher_ = nullptr;
      }
      (*offset)++;
    }

    if (IsAnyByteSource(args[*offset])) {
      CHECK_IMPLIES(context != kKeyContextInput, result.cipher_ != nullptr);
      ArrayBufferOrViewContents<char> passphrase(args[*offs...",33,,675,4,,void
46098,BLOCK,-1,,"{
    if (context != kKeyContextInput)
      (*offset)++;
  }",34,,681,2,,void
46103,BLOCK,-1,,<empty>,7,,683,2,,void
46108,BLOCK,-1,,"{
    bool needs_passphrase = false;
    if (context != kKeyContextInput) {
      if (args[*offset]->IsString()) {
        Utf8Value cipher_name(env->isolate(), args[*offset]);
        result.cipher_ = EVP_get_cipherbyname(*cipher_name);
        if (result.cipher_ == nullptr) {
          THROW_ERR_CRYPTO_UNKNOWN_CIPHER(env);
          return NonCopyableMaybe<PrivateKeyEncodingConfig>();
        }
        needs_passphrase = true;
      } else {
        CHECK(args[*offset]->IsNullOrUndefined());
        result.cipher_ = nullptr;
      }
      (*offset)++;
    }

    if (IsAnyByteSource(args[*offset])) {
      CHECK_IMPLIES(context != kKeyContextInput, result.cipher_ != nullptr);
      ArrayBufferOrViewContents<char> passphrase(args[*offset]);
      if (UNLIKELY(!passphrase.CheckSizeInt32())) {
        THROW_ERR_OUT_OF_RANGE(env, ""passphrase is too big"");
        return NonCopyableMaybe<PrivateKeyEncodingConfig>();
      }
      result.passphrase_ = NonCopyableMaybe<ByteSource>(
      ...",10,,684,1,,void
46117,BLOCK,-1,,"{
      if (args[*offset]->IsString()) {
        Utf8Value cipher_name(env->isolate(), args[*offset]);
        result.cipher_ = EVP_get_cipherbyname(*cipher_name);
        if (result.cipher_ == nullptr) {
          THROW_ERR_CRYPTO_UNKNOWN_CIPHER(env);
          return NonCopyableMaybe<PrivateKeyEncodingConfig>();
        }
        needs_passphrase = true;
      } else {
        CHECK(args[*offset]->IsNullOrUndefined());
        result.cipher_ = nullptr;
      }
      (*offset)++;
    }",38,,686,2,,void
46126,BLOCK,-1,,"{
        Utf8Value cipher_name(env->isolate(), args[*offset]);
        result.cipher_ = EVP_get_cipherbyname(*cipher_name);
        if (result.cipher_ == nullptr) {
          THROW_ERR_CRYPTO_UNKNOWN_CIPHER(env);
          return NonCopyableMaybe<PrivateKeyEncodingConfig>();
        }
        needs_passphrase = true;
      }",38,,687,2,,void
46150,BLOCK,-1,,"{
          THROW_ERR_CRYPTO_UNKNOWN_CIPHER(env);
          return NonCopyableMaybe<PrivateKeyEncodingConfig>();
        }",40,,690,2,,void
46159,BLOCK,-1,,"{
        CHECK(args[*offset]->IsNullOrUndefined());
        result.cipher_ = nullptr;
      }",14,,695,1,,void
46182,BLOCK,-1,,"{
      CHECK_IMPLIES(context != kKeyContextInput, result.cipher_ != nullptr);
      ArrayBufferOrViewContents<char> passphrase(args[*offset]);
      if (UNLIKELY(!passphrase.CheckSizeInt32())) {
        THROW_ERR_OUT_OF_RANGE(env, ""passphrase is too big"");
        return NonCopyableMaybe<PrivateKeyEncodingConfig>();
      }
      result.passphrase_ = NonCopyableMaybe<ByteSource>(
          passphrase.ToNullTerminatedCopy());
    }",41,,702,2,,void
46205,BLOCK,-1,,"{
        THROW_ERR_OUT_OF_RANGE(env, ""passphrase is too big"");
        return NonCopyableMaybe<PrivateKeyEncodingConfig>();
      }",51,,705,2,,void
46224,BLOCK,-1,,"{
      CHECK(args[*offset]->IsNullOrUndefined() && !needs_passphrase);
    }",12,,711,1,,void
46255,BLOCK,-1,,"{
  PublicKeyEncodingConfig result;
  GetKeyFormatAndTypeFromJs(&result, args, offset, context);
  return result;
}",33,,723,4,,void
46271,BLOCK,-1,,"{
  if (args[*offset]->IsString() || IsAnyByteSource(args[*offset])) {
    Environment* env = Environment::GetCurrent(args);
    ByteSource key = ByteSource::FromStringOrBuffer(env, args[(*offset)++]);
    NonCopyableMaybe<PrivateKeyEncodingConfig> config =
        GetPrivateKeyEncodingFromJs(args, offset, kKeyContextInput);
    if (config.IsEmpty())
      return ManagedEVPPKey();

    EVPKeyPointer pkey;
    ParseKeyResult ret =
        ParsePrivateKey(&pkey, config.Release(), key.data<char>(), key.size());
    return GetParsedKey(env, std::move(pkey), ret,
                        ""Failed to read private key"");
  } else {
    CHECK(args[*offset]->IsObject() && allow_key_object);
    KeyObjectHandle* key;
    ASSIGN_OR_RETURN_UNWRAP(&key, args[*offset].As<Object>(), ManagedEVPPKey());
    CHECK_EQ(key->Data()->GetKeyType(), kKeyTypePrivate);
    (*offset) += 4;
    return key->Data()->GetAsymmetricKey();
  }
}",28,,732,4,,void
46286,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(args);
    ByteSource key = ByteSource::FromStringOrBuffer(env, args[(*offset)++]);
    NonCopyableMaybe<PrivateKeyEncodingConfig> config =
        GetPrivateKeyEncodingFromJs(args, offset, kKeyContextInput);
    if (config.IsEmpty())
      return ManagedEVPPKey();

    EVPKeyPointer pkey;
    ParseKeyResult ret =
        ParsePrivateKey(&pkey, config.Release(), key.data<char>(), key.size());
    return GetParsedKey(env, std::move(pkey), ret,
                        ""Failed to read private key"");
  }",68,,733,2,,void
46323,BLOCK,-1,,<empty>,7,,739,2,,void
46356,BLOCK,-1,,"{
    CHECK(args[*offset]->IsObject() && allow_key_object);
    KeyObjectHandle* key;
    ASSIGN_OR_RETURN_UNWRAP(&key, args[*offset].As<Object>(), ManagedEVPPKey());
    CHECK_EQ(key->Data()->GetKeyType(), kKeyTypePrivate);
    (*offset) += 4;
    return key->Data()->GetAsymmetricKey();
  }",10,,746,1,,void
46405,BLOCK,-1,,"{
  if (IsAnyByteSource(args[*offset])) {
    Environment* env = Environment::GetCurrent(args);
    ArrayBufferOrViewContents<char> data(args[(*offset)++]);
    if (UNLIKELY(!data.CheckSizeInt32())) {
      THROW_ERR_OUT_OF_RANGE(env, ""keyData is too big"");
      return ManagedEVPPKey();
    }
    NonCopyableMaybe<PrivateKeyEncodingConfig> config_ =
        GetPrivateKeyEncodingFromJs(args, offset, kKeyContextInput);
    if (config_.IsEmpty())
      return ManagedEVPPKey();

    ParseKeyResult ret;
    PrivateKeyEncodingConfig config = config_.Release();
    EVPKeyPointer pkey;
    if (config.format_ == kKeyFormatPEM) {
      // For PEM, we can easily determine whether it is a public or private key
      // by looking for the respective PEM tags.
      ret = ParsePublicKeyPEM(&pkey, data.data(), data.size());
      if (ret == ParseKeyResult::kParseKeyNotRecognized) {
        ret = ParsePrivateKey(&pkey, config, data.data(), data.size());
      }
    } else {
      // For DER, the ty...",27,,758,3,,void
46412,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(args);
    ArrayBufferOrViewContents<char> data(args[(*offset)++]);
    if (UNLIKELY(!data.CheckSizeInt32())) {
      THROW_ERR_OUT_OF_RANGE(env, ""keyData is too big"");
      return ManagedEVPPKey();
    }
    NonCopyableMaybe<PrivateKeyEncodingConfig> config_ =
        GetPrivateKeyEncodingFromJs(args, offset, kKeyContextInput);
    if (config_.IsEmpty())
      return ManagedEVPPKey();

    ParseKeyResult ret;
    PrivateKeyEncodingConfig config = config_.Release();
    EVPKeyPointer pkey;
    if (config.format_ == kKeyFormatPEM) {
      // For PEM, we can easily determine whether it is a public or private key
      // by looking for the respective PEM tags.
      ret = ParsePublicKeyPEM(&pkey, data.data(), data.size());
      if (ret == ParseKeyResult::kParseKeyNotRecognized) {
        ret = ParsePrivateKey(&pkey, config, data.data(), data.size());
      }
    } else {
      // For DER, the type determines how to parse it. SPKI, PKC...",39,,759,2,,void
46435,BLOCK,-1,,"{
      THROW_ERR_OUT_OF_RANGE(env, ""keyData is too big"");
      return ManagedEVPPKey();
    }",43,,762,2,,void
46456,BLOCK,-1,,<empty>,7,,769,2,,void
46474,BLOCK,-1,,"{
      // For PEM, we can easily determine whether it is a public or private key
      // by looking for the respective PEM tags.
      ret = ParsePublicKeyPEM(&pkey, data.data(), data.size());
      if (ret == ParseKeyResult::kParseKeyNotRecognized) {
        ret = ParsePrivateKey(&pkey, config, data.data(), data.size());
      }
    }",42,,774,2,,void
46494,BLOCK,-1,,"{
        ret = ParsePrivateKey(&pkey, config, data.data(), data.size());
      }",58,,778,2,,void
46510,BLOCK,-1,,"{
      // For DER, the type determines how to parse it. SPKI, PKCS#8 and SEC1 are
      // easy, but PKCS#1 can be a public key or a private key.
      bool is_public;
      switch (config.type_.ToChecked()) {
        case kKeyEncodingPKCS1:
          is_public = !IsRSAPrivateKey(
              reinterpret_cast<const unsigned char*>(data.data()), data.size());
          break;
        case kKeyEncodingSPKI:
          is_public = true;
          break;
        case kKeyEncodingPKCS8:
        case kKeyEncodingSEC1:
          is_public = false;
          break;
        default:
          UNREACHABLE(""Invalid key encoding type"");
      }

      if (is_public) {
        ret = ParsePublicKey(&pkey, config, data.data(), data.size());
      } else {
        ret = ParsePrivateKey(&pkey, config, data.data(), data.size());
      }
    }",12,,781,1,,void
46519,BLOCK,-1,,"{
        case kKeyEncodingPKCS1:
          is_public = !IsRSAPrivateKey(
              reinterpret_cast<const unsigned char*>(data.data()), data.size());
          break;
        case kKeyEncodingSPKI:
          is_public = true;
          break;
        case kKeyEncodingPKCS8:
        case kKeyEncodingSEC1:
          is_public = false;
          break;
        default:
          UNREACHABLE(""Invalid key encoding type"");
      }",41,,785,2,,void
46556,BLOCK,-1,,"{
        ret = ParsePublicKey(&pkey, config, data.data(), data.size());
      }",22,,801,2,,void
46572,BLOCK,-1,,"{
        ret = ParsePrivateKey(&pkey, config, data.data(), data.size());
      }",14,,803,1,,void
46601,BLOCK,-1,,"{
    CHECK(args[*offset]->IsObject());
    KeyObjectHandle* key = Unwrap<KeyObjectHandle>(args[*offset].As<Object>());
    CHECK_NOT_NULL(key);
    CHECK_NE(key->Data()->GetKeyType(), kKeyTypeSecret);
    (*offset) += 4;
    return key->Data()->GetAsymmetricKey();
  }",10,,810,1,,void
46654,BLOCK,-1,,"{
  switch (ret) {
    case ParseKeyResult::kParseKeyOk:
      CHECK(pkey);
      break;
    case ParseKeyResult::kParseKeyNeedPassphrase:
      THROW_ERR_MISSING_PASSPHRASE(env,
                                   ""Passphrase required for encrypted key"");
      break;
    default:
      ThrowCryptoError(env, ERR_get_error(), default_msg);
  }

  return ManagedEVPPKey(std::move(pkey));
}",70,,823,5,,void
46657,BLOCK,-1,,"{
    case ParseKeyResult::kParseKeyOk:
      CHECK(pkey);
      break;
    case ParseKeyResult::kParseKeyNeedPassphrase:
      THROW_ERR_MISSING_PASSPHRASE(env,
                                   ""Passphrase required for encrypted key"");
      break;
    default:
      ThrowCryptoError(env, ERR_get_error(), default_msg);
  }",16,,824,2,,void
46689,BLOCK,-1,,<empty>,25,,842,2,,void
46695,BLOCK,-1,,<empty>,64,,845,3,,void
46700,BLOCK,-1,,"{
  switch (GetKeyType()) {
    case kKeyTypeSecret:
      tracker->TrackFieldWithSize(""symmetric_key"", symmetric_key_.size());
      break;
    case kKeyTypePrivate:
      // Fall through
    case kKeyTypePublic:
      tracker->TrackFieldWithSize(""key"", asymmetric_key_);
      break;
    default:
      UNREACHABLE();
  }
}",62,,847,2,,void
46703,BLOCK,-1,,"{
    case kKeyTypeSecret:
      tracker->TrackFieldWithSize(""symmetric_key"", symmetric_key_.size());
      break;
    case kKeyTypePrivate:
      // Fall through
    case kKeyTypePublic:
      tracker->TrackFieldWithSize(""key"", asymmetric_key_);
      break;
    default:
      UNREACHABLE();
  }",25,,848,2,,void
46733,BLOCK,-1,,"{
  return std::shared_ptr<KeyObjectData>(new KeyObjectData(std::move(key)));
}",76,,862,2,,void
46753,BLOCK,-1,,"{
  CHECK(pkey);
  return std::shared_ptr<KeyObjectData>(new KeyObjectData(key_type, pkey));
}",33,,868,3,,void
46770,BLOCK,-1,,"{
  return key_type_;
}",43,,873,1,,void
46776,BLOCK,-1,,"{
  CHECK_NE(key_type_, kKeyTypeSecret);
  return asymmetric_key_;
}",56,,877,1,,void
46785,BLOCK,-1,,"{
  CHECK_EQ(key_type_, kKeyTypeSecret);
  return symmetric_key_.data<char>();
}",52,,882,1,,void
46797,BLOCK,-1,,"{
  CHECK_EQ(key_type_, kKeyTypeSecret);
  return symmetric_key_.size();
}",51,,887,1,,void
46811,BLOCK,-1,,"{
  Local<FunctionTemplate> t = env->crypto_key_object_handle_constructor();
  return !t.IsEmpty() && t->HasInstance(value);
}",73,,892,3,,void
46838,BLOCK,-1,,"{
  Local<FunctionTemplate> templ = env->crypto_key_object_handle_constructor();
  if (templ.IsEmpty()) {
    Isolate* isolate = env->isolate();
    templ = NewFunctionTemplate(isolate, New);
    templ->InstanceTemplate()->SetInternalFieldCount(
        KeyObjectHandle::kInternalFieldCount);

    SetProtoMethod(isolate, templ, ""init"", Init);
    SetProtoMethodNoSideEffect(
        isolate, templ, ""getSymmetricKeySize"", GetSymmetricKeySize);
    SetProtoMethodNoSideEffect(
        isolate, templ, ""getAsymmetricKeyType"", GetAsymmetricKeyType);
    SetProtoMethod(isolate, templ, ""export"", Export);
    SetProtoMethod(isolate, templ, ""exportJwk"", ExportJWK);
    SetProtoMethod(isolate, templ, ""initECRaw"", InitECRaw);
    SetProtoMethod(isolate, templ, ""initEDRaw"", InitEDRaw);
    SetProtoMethod(isolate, templ, ""initJwk"", InitJWK);
    SetProtoMethod(isolate, templ, ""keyDetail"", GetKeyDetail);
    SetProtoMethod(isolate, templ, ""equals"", Equals);

    env->set_crypto_key_object_handle_con...",71,,897,2,,void
46854,BLOCK,-1,,"{
    Isolate* isolate = env->isolate();
    templ = NewFunctionTemplate(isolate, New);
    templ->InstanceTemplate()->SetInternalFieldCount(
        KeyObjectHandle::kInternalFieldCount);

    SetProtoMethod(isolate, templ, ""init"", Init);
    SetProtoMethodNoSideEffect(
        isolate, templ, ""getSymmetricKeySize"", GetSymmetricKeySize);
    SetProtoMethodNoSideEffect(
        isolate, templ, ""getAsymmetricKeyType"", GetAsymmetricKeyType);
    SetProtoMethod(isolate, templ, ""export"", Export);
    SetProtoMethod(isolate, templ, ""exportJwk"", ExportJWK);
    SetProtoMethod(isolate, templ, ""initECRaw"", InitECRaw);
    SetProtoMethod(isolate, templ, ""initEDRaw"", InitEDRaw);
    SetProtoMethod(isolate, templ, ""initJwk"", InitJWK);
    SetProtoMethod(isolate, templ, ""keyDetail"", GetKeyDetail);
    SetProtoMethod(isolate, templ, ""equals"", Equals);

    env->set_crypto_key_object_handle_constructor(templ);
  }",24,,899,2,,void
46948,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(Init);
  registry->Register(GetSymmetricKeySize);
  registry->Register(GetAsymmetricKeyType);
  registry->Register(Export);
  registry->Register(ExportJWK);
  registry->Register(InitECRaw);
  registry->Register(InitEDRaw);
  registry->Register(InitJWK);
  registry->Register(GetKeyDetail);
  registry->Register(Equals);
}",42,,924,2,,void
47009,BLOCK,-1,,"{
  Local<Object> obj;
  Local<Function> ctor = KeyObjectHandle::Initialize(env);
  CHECK(!env->crypto_key_object_handle_constructor().IsEmpty());
  if (!ctor->NewInstance(env->context(), 0, nullptr).ToLocal(&obj))
    return MaybeLocal<Object>();

  KeyObjectHandle* key = Unwrap<KeyObjectHandle>(obj);
  CHECK_NOT_NULL(key);
  key->data_ = data;
  return obj;
}",42,,940,3,,void
47052,BLOCK,-1,,<empty>,5,,945,2,,void
47075,BLOCK,-1,,"{
  return data_;
}",63,,953,1,,void
47082,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new KeyObjectHandle(env, args.This());
}",68,,957,2,,void
47108,BLOCK,-1,,"{
  MakeWeak();
}",29,,965,3,,void
47114,BLOCK,-1,,"{
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());
  MarkPopErrorOnReturn mark_pop_error_on_return;

  CHECK(args[0]->IsInt32());
  KeyType type = static_cast<KeyType>(args[0].As<Uint32>()->Value());

  unsigned int offset;
  ManagedEVPPKey pkey;

  switch (type) {
  case kKeyTypeSecret: {
    CHECK_EQ(args.Length(), 2);
    ArrayBufferOrViewContents<char> buf(args[1]);
    key->data_ = KeyObjectData::CreateSecret(buf.ToCopy());
    break;
  }
  case kKeyTypePublic: {
    CHECK_EQ(args.Length(), 5);

    offset = 1;
    pkey = ManagedEVPPKey::GetPublicOrPrivateKeyFromJs(args, &offset);
    if (!pkey)
      return;
    key->data_ = KeyObjectData::CreateAsymmetric(type, pkey);
    break;
  }
  case kKeyTypePrivate: {
    CHECK_EQ(args.Length(), 5);

    offset = 1;
    pkey = ManagedEVPPKey::GetPrivateKeyFromJs(args, &offset, false);
    if (!pkey)
      return;
    key->data_ = KeyObjectData::CreateAsymmetric(type, pkey);
    break;
  }
  default:
    UNREACHAB...",69,,969,2,,void
47149,BLOCK,-1,,"{
  case kKeyTypeSecret: {
    CHECK_EQ(args.Length(), 2);
    ArrayBufferOrViewContents<char> buf(args[1]);
    key->data_ = KeyObjectData::CreateSecret(buf.ToCopy());
    break;
  }
  case kKeyTypePublic: {
    CHECK_EQ(args.Length(), 5);

    offset = 1;
    pkey = ManagedEVPPKey::GetPublicOrPrivateKeyFromJs(args, &offset);
    if (!pkey)
      return;
    key->data_ = KeyObjectData::CreateAsymmetric(type, pkey);
    break;
  }
  case kKeyTypePrivate: {
    CHECK_EQ(args.Length(), 5);

    offset = 1;
    pkey = ManagedEVPPKey::GetPrivateKeyFromJs(args, &offset, false);
    if (!pkey)
      return;
    key->data_ = KeyObjectData::CreateAsymmetric(type, pkey);
    break;
  }
  default:
    UNREACHABLE();
  }",17,,980,2,,void
47152,BLOCK,3,,"{
    CHECK_EQ(args.Length(), 2);
    ArrayBufferOrViewContents<char> buf(args[1]);
    key->data_ = KeyObjectData::CreateSecret(buf.ToCopy());
    break;
  }",24,,981,3,,void
47179,BLOCK,6,,"{
    CHECK_EQ(args.Length(), 5);

    offset = 1;
    pkey = ManagedEVPPKey::GetPublicOrPrivateKeyFromJs(args, &offset);
    if (!pkey)
      return;
    key->data_ = KeyObjectData::CreateAsymmetric(type, pkey);
    break;
  }",24,,987,6,,void
47201,BLOCK,-1,,<empty>,7,,993,2,,void
47216,BLOCK,9,,"{
    CHECK_EQ(args.Length(), 5);

    offset = 1;
    pkey = ManagedEVPPKey::GetPrivateKeyFromJs(args, &offset, false);
    if (!pkey)
      return;
    key->data_ = KeyObjectData::CreateAsymmetric(type, pkey);
    break;
  }",25,,997,9,,void
47239,BLOCK,-1,,<empty>,7,,1003,2,,void
47258,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());
  MarkPopErrorOnReturn mark_pop_error_on_return;

  // The argument must be a JavaScript object that we will inspect
  // to get the JWK properties from.
  CHECK(args[0]->IsObject());

  // Step one, Secret key or not?
  Local<Object> input = args[0].As<Object>();

  Local<Value> kty;
  if (!input->Get(env->context(), env->jwk_kty_string()).ToLocal(&kty) ||
      !kty->IsString()) {
    return THROW_ERR_CRYPTO_INVALID_JWK(env);
  }

  Utf8Value kty_string(env->isolate(), kty);

  if (strcmp(*kty_string, ""oct"") == 0) {
    // Secret key
    key->data_ = ImportJWKSecretKey(env, input);
    if (!key->data_) {
      // ImportJWKSecretKey is responsible for throwing an appropriate error
      return;
    }
  } else {
    key->data_ = ImportJWKAsymmetricKey(env, input, *kty_string, args, 1);
    if (!key->data_) {
      // ImportJWKAsymmetricKey is responsible for ...",72,,1012,2,,void
47325,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_INVALID_JWK(env);
  }",25,,1027,2,,void
47343,BLOCK,-1,,"{
    // Secret key
    key->data_ = ImportJWKSecretKey(env, input);
    if (!key->data_) {
      // ImportJWKSecretKey is responsible for throwing an appropriate error
      return;
    }
  }",40,,1033,2,,void
47356,BLOCK,-1,,"{
      // ImportJWKSecretKey is responsible for throwing an appropriate error
      return;
    }",22,,1036,2,,void
47359,BLOCK,-1,,"{
    key->data_ = ImportJWKAsymmetricKey(env, input, *kty_string, args, 1);
    if (!key->data_) {
      // ImportJWKAsymmetricKey is responsible for throwing an appropriate error
      return;
    }
  }",10,,1040,1,,void
47376,BLOCK,-1,,"{
      // ImportJWKAsymmetricKey is responsible for throwing an appropriate error
      return;
    }",22,,1042,2,,void
47395,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());

  CHECK(args[0]->IsString());
  Utf8Value name(env->isolate(), args[0]);

  MarkPopErrorOnReturn mark_pop_error_on_return;

  int id = OBJ_txt2nid(*name);
  ECKeyPointer eckey(EC_KEY_new_by_curve_name(id));
  if (!eckey)
    return args.GetReturnValue().Set(false);

  const EC_GROUP* group = EC_KEY_get0_group(eckey.get());
  ECPointPointer pub(ECDH::BufferToPoint(env, group, args[1]));

  if (!pub ||
      !eckey ||
      !EC_KEY_set_public_key(eckey.get(), pub.get())) {
    return args.GetReturnValue().Set(false);
  }

  EVPKeyPointer pkey(EVP_PKEY_new());
  if (!EVP_PKEY_assign_EC_KEY(pkey.get(), eckey.get()))
    args.GetReturnValue().Set(false);

  eckey.release();  // Release ownership of the key

  key->data_ =
      KeyObjectData::CreateAsymmetric(
          kKeyTypePublic,
          ManagedEVPPKey(std::move(pkey)));

  args.GetReturnValue().Set(true);
}",74,,1051,2,,void
47442,BLOCK,-1,,<empty>,5,,1064,2,,void
47488,BLOCK,-1,,"{
    return args.GetReturnValue().Set(false);
  }",55,,1071,2,,void
47512,BLOCK,-1,,<empty>,5,,1077,2,,void
47552,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());

  CHECK(args[0]->IsString());
  Utf8Value name(env->isolate(), args[0]);

  ArrayBufferOrViewContents<unsigned char> key_data(args[1]);
  KeyType type = static_cast<KeyType>(args[2].As<Int32>()->Value());

  MarkPopErrorOnReturn mark_pop_error_on_return;

  typedef EVP_PKEY* (*new_key_fn)(int, ENGINE*, const unsigned char*, size_t);
  new_key_fn fn = type == kKeyTypePrivate
      ? EVP_PKEY_new_raw_private_key
      : EVP_PKEY_new_raw_public_key;

  int id = GetOKPCurveFromName(*name);

  switch (id) {
    case EVP_PKEY_X25519:
    case EVP_PKEY_X448:
    case EVP_PKEY_ED25519:
    case EVP_PKEY_ED448: {
      EVPKeyPointer pkey(fn(id, nullptr, key_data.data(), key_data.size()));
      if (!pkey)
        return args.GetReturnValue().Set(false);
      key->data_ =
          KeyObjectData::CreateAsymmetric(
              type,
              ManagedEVPPKey(std:...",74,,1089,2,,void
47610,BLOCK,-1,,<empty>,,,,5,,<empty>
47630,BLOCK,-1,,"{
    case EVP_PKEY_X25519:
    case EVP_PKEY_X448:
    case EVP_PKEY_ED25519:
    case EVP_PKEY_ED448: {
      EVPKeyPointer pkey(fn(id, nullptr, key_data.data(), key_data.size()));
      if (!pkey)
        return args.GetReturnValue().Set(false);
      key->data_ =
          KeyObjectData::CreateAsymmetric(
              type,
              ManagedEVPPKey(std::move(pkey)));
      CHECK(key->data_);
      break;
    }
    default:
      UNREACHABLE();
  }",15,,1109,2,,void
47639,BLOCK,9,,"{
      EVPKeyPointer pkey(fn(id, nullptr, key_data.data(), key_data.size()));
      if (!pkey)
        return args.GetReturnValue().Set(false);
      key->data_ =
          KeyObjectData::CreateAsymmetric(
              type,
              ManagedEVPPKey(std::move(pkey)));
      CHECK(key->data_);
      break;
    }",26,,1113,9,,void
47656,BLOCK,-1,,<empty>,9,,1116,2,,void
47700,BLOCK,-1,,"{
  KeyObjectHandle* self_handle;
  KeyObjectHandle* arg_handle;
  ASSIGN_OR_RETURN_UNWRAP(&self_handle, args.Holder());
  ASSIGN_OR_RETURN_UNWRAP(&arg_handle, args[0].As<Object>());
  std::shared_ptr<KeyObjectData> key = self_handle->Data();
  std::shared_ptr<KeyObjectData> key2 = arg_handle->Data();

  KeyType key_type = key->GetKeyType();
  CHECK_EQ(key_type, key2->GetKeyType());

  bool ret;
  switch (key_type) {
    case kKeyTypeSecret: {
      size_t size = key->GetSymmetricKeySize();
      if (size == key2->GetSymmetricKeySize()) {
        ret = CRYPTO_memcmp(
          key->GetSymmetricKey(),
          key2->GetSymmetricKey(),
          size) == 0;
      } else {
        ret = false;
      }
      break;
    }
    case kKeyTypePublic:
    case kKeyTypePrivate: {
      EVP_PKEY* pkey = key->GetAsymmetricKey().get();
      EVP_PKEY* pkey2 = key2->GetAsymmetricKey().get();
#if OPENSSL_VERSION_MAJOR >= 3
      int ok = EVP_PKEY_eq(pkey, pkey2);
#else
      int ok = EVP_PKEY_cmp(...",71,,1131,2,,void
47759,BLOCK,-1,,"{
    case kKeyTypeSecret: {
      size_t size = key->GetSymmetricKeySize();
      if (size == key2->GetSymmetricKeySize()) {
        ret = CRYPTO_memcmp(
          key->GetSymmetricKey(),
          key2->GetSymmetricKey(),
          size) == 0;
      } else {
        ret = false;
      }
      break;
    }
    case kKeyTypePublic:
    case kKeyTypePrivate: {
      EVP_PKEY* pkey = key->GetAsymmetricKey().get();
      EVP_PKEY* pkey2 = key2->GetAsymmetricKey().get();
#if OPENSSL_VERSION_MAJOR >= 3
      int ok = EVP_PKEY_eq(pkey, pkey2);
#else
      int ok = EVP_PKEY_cmp(pkey, pkey2);
#endif
      if (ok == -2) {
        Environment* env = Environment::GetCurrent(args);
        return THROW_ERR_CRYPTO_UNSUPPORTED_OPERATION(env);
      }
      ret = ok == 1;
      break;
    }
    default:
      UNREACHABLE(""unsupported key type"");
  }",21,,1143,2,,void
47762,BLOCK,3,,"{
      size_t size = key->GetSymmetricKeySize();
      if (size == key2->GetSymmetricKeySize()) {
        ret = CRYPTO_memcmp(
          key->GetSymmetricKey(),
          key2->GetSymmetricKey(),
          size) == 0;
      } else {
        ret = false;
      }
      break;
    }",26,,1144,3,,void
47777,BLOCK,-1,,"{
        ret = CRYPTO_memcmp(
          key->GetSymmetricKey(),
          key2->GetSymmetricKey(),
          size) == 0;
      }",48,,1146,2,,void
47793,BLOCK,-1,,"{
        ret = false;
      }",14,,1151,1,,void
47802,BLOCK,8,,"{
      EVP_PKEY* pkey = key->GetAsymmetricKey().get();
      EVP_PKEY* pkey2 = key2->GetAsymmetricKey().get();
#if OPENSSL_VERSION_MAJOR >= 3
      int ok = EVP_PKEY_eq(pkey, pkey2);
#else
      int ok = EVP_PKEY_cmp(pkey, pkey2);
#endif
      if (ok == -2) {
        Environment* env = Environment::GetCurrent(args);
        return THROW_ERR_CRYPTO_UNSUPPORTED_OPERATION(env);
      }
      ret = ok == 1;
      break;
    }",27,,1157,8,,void
47834,BLOCK,-1,,"{
        Environment* env = Environment::GetCurrent(args);
        return THROW_ERR_CRYPTO_UNSUPPORTED_OPERATION(env);
      }",21,,1165,2,,void
47867,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());

  CHECK(args[0]->IsObject());

  std::shared_ptr<KeyObjectData> data = key->Data();

  switch (data->GetKeyType()) {
    case kKeyTypeSecret:
      if (GetSecretKeyDetail(env, data, args[0].As<Object>()).IsNothing())
        return;
      break;
    case kKeyTypePublic:
      // Fall through
    case kKeyTypePrivate:
      if (GetAsymmetricKeyDetail(env, data, args[0].As<Object>()).IsNothing())
        return;
      break;
    default:
      UNREACHABLE();
  }

  args.GetReturnValue().Set(args[0]);
}",77,,1179,2,,void
47908,BLOCK,-1,,"{
    case kKeyTypeSecret:
      if (GetSecretKeyDetail(env, data, args[0].As<Object>()).IsNothing())
        return;
      break;
    case kKeyTypePublic:
      // Fall through
    case kKeyTypePrivate:
      if (GetAsymmetricKeyDetail(env, data, args[0].As<Object>()).IsNothing())
        return;
      break;
    default:
      UNREACHABLE();
  }",31,,1188,2,,void
47924,BLOCK,-1,,<empty>,9,,1191,2,,void
47944,BLOCK,-1,,<empty>,9,,1197,2,,void
47962,BLOCK,-1,,"{
  const ManagedEVPPKey& key = data_->GetAsymmetricKey();
  switch (EVP_PKEY_id(key.get())) {
  case EVP_PKEY_RSA:
    return env()->crypto_rsa_string();
  case EVP_PKEY_RSA_PSS:
    return env()->crypto_rsa_pss_string();
  case EVP_PKEY_DSA:
    return env()->crypto_dsa_string();
  case EVP_PKEY_DH:
    return env()->crypto_dh_string();
  case EVP_PKEY_EC:
    return env()->crypto_ec_string();
  case EVP_PKEY_ED25519:
    return env()->crypto_ed25519_string();
  case EVP_PKEY_ED448:
    return env()->crypto_ed448_string();
  case EVP_PKEY_X25519:
    return env()->crypto_x25519_string();
  case EVP_PKEY_X448:
    return env()->crypto_x448_string();
  default:
    return Undefined(env()->isolate());
  }
}",60,,1206,1,,void
47976,BLOCK,-1,,"{
  case EVP_PKEY_RSA:
    return env()->crypto_rsa_string();
  case EVP_PKEY_RSA_PSS:
    return env()->crypto_rsa_pss_string();
  case EVP_PKEY_DSA:
    return env()->crypto_dsa_string();
  case EVP_PKEY_DH:
    return env()->crypto_dh_string();
  case EVP_PKEY_EC:
    return env()->crypto_ec_string();
  case EVP_PKEY_ED25519:
    return env()->crypto_ed25519_string();
  case EVP_PKEY_ED448:
    return env()->crypto_ed448_string();
  case EVP_PKEY_X25519:
    return env()->crypto_x25519_string();
  case EVP_PKEY_X448:
    return env()->crypto_x448_string();
  default:
    return Undefined(env()->isolate());
  }",35,,1208,2,,void
48051,BLOCK,-1,,"{
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());

  args.GetReturnValue().Set(key->GetAsymmetricKeyType());
}",46,,1233,2,,void
48075,BLOCK,-1,,"{
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());
  args.GetReturnValue().Set(
      static_cast<uint32_t>(key->Data()->GetSymmetricKeySize()));
}",46,,1241,2,,void
48104,BLOCK,-1,,"{
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());

  KeyType type = key->Data()->GetKeyType();

  MaybeLocal<Value> result;
  if (type == kKeyTypeSecret) {
    result = key->ExportSecretKey();
  } else if (type == kKeyTypePublic) {
    unsigned int offset = 0;
    PublicKeyEncodingConfig config =
        ManagedEVPPKey::GetPublicKeyEncodingFromJs(
            args, &offset, kKeyContextExport);
    CHECK_EQ(offset, static_cast<unsigned int>(args.Length()));
    result = key->ExportPublicKey(config);
  } else {
    CHECK_EQ(type, kKeyTypePrivate);
    unsigned int offset = 0;
    NonCopyableMaybe<PrivateKeyEncodingConfig> config =
        ManagedEVPPKey::GetPrivateKeyEncodingFromJs(
            args, &offset, kKeyContextExport);
    if (config.IsEmpty())
      return;
    CHECK_EQ(offset, static_cast<unsigned int>(args.Length()));
    result = key->ExportPrivateKey(config.Release());
  }

  if (!result.IsEmpty())
    args.GetReturnValue().Set(result.FromMaybe(L...",71,,1248,2,,void
48132,BLOCK,-1,,"{
    result = key->ExportSecretKey();
  }",31,,1255,2,,void
48140,BLOCK,-1,,<empty>,10,,1257,1,,void
48145,BLOCK,-1,,"{
    unsigned int offset = 0;
    PublicKeyEncodingConfig config =
        ManagedEVPPKey::GetPublicKeyEncodingFromJs(
            args, &offset, kKeyContextExport);
    CHECK_EQ(offset, static_cast<unsigned int>(args.Length()));
    result = key->ExportPublicKey(config);
  }",38,,1257,2,,void
48177,BLOCK,-1,,"{
    CHECK_EQ(type, kKeyTypePrivate);
    unsigned int offset = 0;
    NonCopyableMaybe<PrivateKeyEncodingConfig> config =
        ManagedEVPPKey::GetPrivateKeyEncodingFromJs(
            args, &offset, kKeyContextExport);
    if (config.IsEmpty())
      return;
    CHECK_EQ(offset, static_cast<unsigned int>(args.Length()));
    result = key->ExportPrivateKey(config.Release());
  }",10,,1264,1,,void
48204,BLOCK,-1,,<empty>,7,,1271,2,,void
48230,BLOCK,-1,,<empty>,5,,1277,2,,void
48246,BLOCK,-1,,"{
  const char* buf = data_->GetSymmetricKey();
  unsigned int len = data_->GetSymmetricKeySize();
  return Buffer::Copy(env(), buf, len).FromMaybe(Local<Value>());
}",60,,1280,1,,void
48277,BLOCK,-1,,"{
  return WritePublicKey(env(), data_->GetAsymmetricKey().get(), config);
}",50,,1287,2,,void
48293,BLOCK,-1,,"{
  return WritePrivateKey(env(), data_->GetAsymmetricKey().get(), config);
}",51,,1292,2,,void
48309,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());

  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsBoolean());

  ExportJWKInner(env, key->Data(), args[0], args[1]->IsTrue());

  args.GetReturnValue().Set(args[0]);
}",54,,1297,2,,void
48370,BLOCK,-1,,"{
  SetMethod(env->context(),
            target,
            ""createNativeKeyObjectClass"",
            NativeKeyObject::CreateNativeKeyObjectClass);
}",74,,1310,3,,void
48385,BLOCK,-1,,"{
  registry->Register(NativeKeyObject::CreateNativeKeyObjectClass);
  registry->Register(NativeKeyObject::New);
}",42,,1318,2,,void
48404,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsObject());
  KeyObjectHandle* handle = Unwrap<KeyObjectHandle>(args[0].As<Object>());
  new NativeKeyObject(env, args.This(), handle->Data());
}",68,,1323,2,,void
48454,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  CHECK_EQ(args.Length(), 1);
  Local<Value> callback = args[0];
  CHECK(callback->IsFunction());

  Local<FunctionTemplate> t =
      NewFunctionTemplate(isolate, NativeKeyObject::New);
  t->InstanceTemplate()->SetInternalFieldCount(
      KeyObjectHandle::kInternalFieldCount);

  Local<Value> ctor;
  if (!t->GetFunction(env->context()).ToLocal(&ctor))
    return;

  Local<Value> recv = Undefined(env->isolate());
  Local<Value> ret_v;
  if (!callback.As<Function>()->Call(
          env->context(), recv, 1, &ctor).ToLocal(&ret_v)) {
    return;
  }
  Local<Array> ret = ret_v.As<Array>();
  if (!ret->Get(env->context(), 1).ToLocal(&ctor)) return;
  env->set_crypto_key_object_secret_constructor(ctor.As<Function>());
  if (!ret->Get(env->context(), 2).ToLocal(&ctor)) return;
  env->set_crypto_key_object_public_constructor(ctor.As<Function>());
  if (!ret->Get(env->context(), 3).ToLocal(&ctor)) r...",46,,1332,2,,void
48531,BLOCK,-1,,<empty>,5,,1347,2,,void
48571,BLOCK,-1,,"{
    return;
  }",60,,1352,2,,void
48599,BLOCK,-1,,<empty>,52,,1356,2,,void
48625,BLOCK,-1,,<empty>,52,,1358,2,,void
48651,BLOCK,-1,,<empty>,52,,1360,2,,void
48675,BLOCK,-1,,"{
  if (context != env->context()) {
    THROW_ERR_MESSAGE_TARGET_CONTEXT_UNAVAILABLE(env);
    return {};
  }

  Local<Value> handle;
  if (!KeyObjectHandle::Create(env, data_).ToLocal(&handle))
    return {};

  Local<Function> key_ctor;
  Local<Value> arg = FIXED_ONE_BYTE_STRING(env->isolate(),
                                           ""internal/crypto/keys"");
  if (env->builtin_module_require()
          ->Call(context, Null(env->isolate()), 1, &arg)
          .IsEmpty()) {
    return {};
  }
  switch (data_->GetKeyType()) {
    case kKeyTypeSecret:
      key_ctor = env->crypto_key_object_secret_constructor();
      break;
    case kKeyTypePublic:
      key_ctor = env->crypto_key_object_public_constructor();
      break;
    case kKeyTypePrivate:
      key_ctor = env->crypto_key_object_private_constructor();
      break;
    default:
      UNREACHABLE();
  }

  Local<Value> key;
  if (!key_ctor->NewInstance(context, 1, &handle).ToLocal(&key))
    return {};

  return BaseObject...",53,,1368,4,,void
48683,BLOCK,-1,,"{
    THROW_ERR_MESSAGE_TARGET_CONTEXT_UNAVAILABLE(env);
    return {};
  }",34,,1369,2,,void
48705,BLOCK,-1,,<empty>,5,,1376,2,,void
48744,BLOCK,-1,,"{
    return {};
  }",23,,1383,2,,void
48751,BLOCK,-1,,"{
    case kKeyTypeSecret:
      key_ctor = env->crypto_key_object_secret_constructor();
      break;
    case kKeyTypePublic:
      key_ctor = env->crypto_key_object_public_constructor();
      break;
    case kKeyTypePrivate:
      key_ctor = env->crypto_key_object_private_constructor();
      break;
    default:
      UNREACHABLE();
  }",32,,1386,2,,void
48801,BLOCK,-1,,<empty>,5,,1402,2,,void
48819,BLOCK,-1,,"{
  return BaseObject::TransferMode::kCloneable;
}",67,,1407,1,,void
48829,BLOCK,-1,,"{
  return std::make_unique<KeyObjectTransferData>(handle_data_);
}",11,,1412,1,,void
48843,BLOCK,-1,,"{
  CHECK_EQ(key_data->GetKeyType(), kKeyTypePublic);
  ManagedEVPPKey m_pkey = key_data->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);
  if (!i2d_PUBKEY_bio(bio.get(), m_pkey.get()))
    return WebCryptoKeyExportStatus::FAILED;

  *out = ByteSource::FromBIO(bio);
  return WebCryptoKeyExportStatus::OK;
}",22,,1418,3,,void
48866,BLOCK,-1,,<empty>,,,,2,,<empty>
48882,BLOCK,-1,,<empty>,5,,1425,2,,void
48904,BLOCK,-1,,"{
  CHECK_EQ(key_data->GetKeyType(), kKeyTypePrivate);
  ManagedEVPPKey m_pkey = key_data->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());

  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);
  PKCS8Pointer p8inf(EVP_PKEY2PKCS8(m_pkey.get()));
  if (!i2d_PKCS8_PRIV_KEY_INFO_bio(bio.get(), p8inf.get()))
    return WebCryptoKeyExportStatus::FAILED;

  *out = ByteSource::FromBIO(bio);
  return WebCryptoKeyExportStatus::OK;
}",22,,1433,3,,void
48927,BLOCK,-1,,<empty>,,,,2,,<empty>
48950,BLOCK,-1,,<empty>,5,,1442,2,,void
48973,BLOCK,-1,,"{
  target->Set(env->context(),
              FIXED_ONE_BYTE_STRING(env->isolate(), ""KeyObjectHandle""),
              KeyObjectHandle::Initialize(env)).Check();

  NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatRaw);
  NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatPKCS8);
  NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatSPKI);
  NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatJWK);

  NODE_DEFINE_CONSTANT(target, EVP_PKEY_ED25519);
  NODE_DEFINE_CONSTANT(target, EVP_PKEY_ED448);
  NODE_DEFINE_CONSTANT(target, EVP_PKEY_X25519);
  NODE_DEFINE_CONSTANT(target, EVP_PKEY_X448);
  NODE_DEFINE_CONSTANT(target, kKeyEncodingPKCS1);
  NODE_DEFINE_CONSTANT(target, kKeyEncodingPKCS8);
  NODE_DEFINE_CONSTANT(target, kKeyEncodingSPKI);
  NODE_DEFINE_CONSTANT(target, kKeyEncodingSEC1);
  NODE_DEFINE_CONSTANT(target, kKeyFormatDER);
  NODE_DEFINE_CONSTANT(target, kKeyFormatPEM);
  NODE_DEFINE_CONSTANT(target, kKeyFormatJWK);
  NODE_DEFINE_CONSTANT(target, kKeyTypeSecret);
  NODE_DEFINE_CONSTANT...",57,,1449,3,,void
49001,BLOCK,1,,<empty>,,,,7,,void
49003,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatRaw)",3,,1454,1,,void
49100,BLOCK,1,,<empty>,,,,7,,void
49102,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatPKCS8)",3,,1455,1,,void
49199,BLOCK,1,,<empty>,,,,7,,void
49201,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatSPKI)",3,,1456,1,,void
49298,BLOCK,1,,<empty>,,,,7,,void
49300,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatJWK)",3,,1457,1,,void
49397,BLOCK,1,,<empty>,,,,7,,void
49399,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, EVP_PKEY_ED25519)",3,,1459,1,,void
49496,BLOCK,1,,<empty>,,,,7,,void
49498,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, EVP_PKEY_ED448)",3,,1460,1,,void
49595,BLOCK,1,,<empty>,,,,7,,void
49597,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, EVP_PKEY_X25519)",3,,1461,1,,void
49694,BLOCK,1,,<empty>,,,,7,,void
49696,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, EVP_PKEY_X448)",3,,1462,1,,void
49793,BLOCK,1,,<empty>,,,,7,,void
49795,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kKeyEncodingPKCS1)",3,,1463,1,,void
49892,BLOCK,1,,<empty>,,,,7,,void
49894,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kKeyEncodingPKCS8)",3,,1464,1,,void
49991,BLOCK,1,,<empty>,,,,7,,void
49993,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kKeyEncodingSPKI)",3,,1465,1,,void
50090,BLOCK,1,,<empty>,,,,7,,void
50092,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kKeyEncodingSEC1)",3,,1466,1,,void
50189,BLOCK,1,,<empty>,,,,7,,void
50191,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kKeyFormatDER)",3,,1467,1,,void
50288,BLOCK,1,,<empty>,,,,7,,void
50290,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kKeyFormatPEM)",3,,1468,1,,void
50387,BLOCK,1,,<empty>,,,,7,,void
50389,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kKeyFormatJWK)",3,,1469,1,,void
50486,BLOCK,1,,<empty>,,,,7,,void
50488,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kKeyTypeSecret)",3,,1470,1,,void
50585,BLOCK,1,,<empty>,,,,7,,void
50587,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kKeyTypePublic)",3,,1471,1,,void
50684,BLOCK,1,,<empty>,,,,7,,void
50686,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kKeyTypePrivate)",3,,1472,1,,void
50783,BLOCK,1,,<empty>,,,,7,,void
50785,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kSigEncDER)",3,,1473,1,,void
50882,BLOCK,1,,<empty>,,,,7,,void
50884,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kSigEncP1363)",3,,1474,1,,void
50980,BLOCK,-1,,"{
  KeyObjectHandle::RegisterExternalReferences(registry);
}",70,,1477,2,,void
51012,BLOCK,-1,,<empty>,1,,1,1,,ANY
51033,BLOCK,-1,,<empty>,1,,1,1,,ANY
51038,BLOCK,-1,,<empty>,28,,26,2,,void
51043,BLOCK,-1,,"{
  if (&other == this) return *this;
  this->~PBKDF2Config();
  return *new (this) PBKDF2Config(std::move(other));
}",70,,28,2,,void
51049,BLOCK,-1,,<empty>,23,,29,2,,void
51071,BLOCK,-1,,"{
  // The job is sync, the PBKDF2Config does not own the data.
  if (mode == kCryptoJobAsync) {
    tracker->TrackFieldWithSize(""pass"", pass.size());
    tracker->TrackFieldWithSize(""salt"", salt.size());
  }
}",61,,34,2,,void
51076,BLOCK,-1,,"{
    tracker->TrackFieldWithSize(""pass"", pass.size());
    tracker->TrackFieldWithSize(""salt"", salt.size());
  }",32,,36,2,,void
51102,BLOCK,-1,,"{
  *result = out->ToArrayBuffer(env);
  return Just(!result->IsEmpty());
}",35,,46,5,,void
51125,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  params->mode = mode;

  ArrayBufferOrViewContents<char> pass(args[offset]);
  ArrayBufferOrViewContents<char> salt(args[offset + 1]);

  if (UNLIKELY(!pass.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""pass is too large"");
    return Nothing<bool>();
  }

  if (UNLIKELY(!salt.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""salt is too large"");
    return Nothing<bool>();
  }

  params->pass = mode == kCryptoJobAsync
      ? pass.ToCopy()
      : pass.ToByteSource();

  params->salt = mode == kCryptoJobAsync
      ? salt.ToCopy()
      : salt.ToByteSource();

  CHECK(args[offset + 2]->IsInt32());  // iteration_count
  CHECK(args[offset + 3]->IsInt32());  // length
  CHECK(args[offset + 4]->IsString());  // digest_name

  params->iterations = args[offset + 2].As<Int32>()->Value();
  if (params->iterations < 0) {
    THROW_ERR_OUT_OF_RANGE(env, ""iterations must be <= %d"", INT_MAX);
    return Nothing<bool>();
  }

 ...",27,,62,5,,void
51158,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""pass is too large"");
    return Nothing<bool>();
  }",41,,70,2,,void
51171,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""salt is too large"");
    return Nothing<bool>();
  }",41,,75,2,,void
51257,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""iterations must be <= %d"", INT_MAX);
    return Nothing<bool>();
  }",31,,93,2,,void
51285,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""length must be <= %d"", INT_MAX);
    return Nothing<bool>();
  }",27,,99,2,,void
51316,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *name);
    return Nothing<bool>();
  }",34,,106,2,,void
51333,BLOCK,-1,,"{
  ByteSource::Builder buf(params.length);

  // Both pass and salt may be zero length here.
  // The generated bytes are stored in buf, which is
  // assigned to out on success.

  if (PKCS5_PBKDF2_HMAC(params.pass.data<char>(),
                        params.pass.size(),
                        params.salt.data<unsigned char>(),
                        params.salt.size(),
                        params.iterations,
                        params.digest,
                        params.length,
                        buf.data<unsigned char>()) <= 0) {
    return false;
  }
  *out = std::move(buf).release();
  return true;
}",22,,117,4,,void
51380,BLOCK,-1,,"{
    return false;
  }",58,,131,2,,void
51412,BLOCK,-1,,<empty>,1,,1,1,,ANY
51435,BLOCK,-1,,<empty>,1,,1,1,,ANY
51443,BLOCK,-1,,"{
  *result = v8::Undefined(env->isolate());
  return Just(!result->IsEmpty());
}",35,,32,5,,void
51469,BLOCK,-1,,"{
  CHECK(IsAnyByteSource(args[offset]));  // Buffer to fill
  CHECK(args[offset + 1]->IsUint32());  // Offset
  CHECK(args[offset + 2]->IsUint32());  // Size

  ArrayBufferOrViewContents<unsigned char> in(args[offset]);

  const uint32_t byte_offset = args[offset + 1].As<Uint32>()->Value();
  const uint32_t size = args[offset + 2].As<Uint32>()->Value();
  CHECK_GE(byte_offset + size, byte_offset);  // Overflow check.
  CHECK_LE(byte_offset + size, in.size());  // Bounds check.

  params->buffer = in.data() + byte_offset;
  params->size = size;

  return Just(true);
}",32,,41,5,,void
51563,BLOCK,-1,,"{
  return CSPRNG(params.buffer, params.size).is_ok();
}",25,,62,4,,void
51579,BLOCK,-1,,"{
  tracker->TrackFieldWithSize(""prime"", prime ? bits * 8 : 0);
}",66,,66,2,,void
51598,BLOCK,-1,,"{
  size_t size = BN_num_bytes(params.prime.get());
  std::shared_ptr<BackingStore> store =
      ArrayBuffer::NewBackingStore(env->isolate(), size);
  BN_bn2binpad(
      params.prime.get(),
      reinterpret_cast<unsigned char*>(store->Data()),
      size);
  *result = ArrayBuffer::New(env->isolate(), store);
  return Just(true);
}",35,,74,5,,void
51662,BLOCK,-1,,"{
  ClearErrorOnReturn clear_error;
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[offset]->IsUint32());  // Size
  CHECK(args[offset + 1]->IsBoolean());  // Safe

  const uint32_t size = args[offset].As<Uint32>()->Value();
  bool safe = args[offset + 1]->IsTrue();

  if (!args[offset + 2]->IsUndefined()) {
    ArrayBufferOrViewContents<unsigned char> add(args[offset + 2]);
    params->add.reset(BN_bin2bn(add.data(), add.size(), nullptr));
    if (!params->add) {
      THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""could not generate prime"");
      return Nothing<bool>();
    }
  }

  if (!args[offset + 3]->IsUndefined()) {
    ArrayBufferOrViewContents<unsigned char> rem(args[offset + 3]);
    params->rem.reset(BN_bin2bn(rem.data(), rem.size(), nullptr));
    if (!params->rem) {
      THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""could not generate prime"");
      return Nothing<bool>();
    }
  }

  // The JS interface already ensures that the (positive) size fits into an int....",32,,90,5,,void
51721,BLOCK,-1,,"{
    ArrayBufferOrViewContents<unsigned char> add(args[offset + 2]);
    params->add.reset(BN_bin2bn(add.data(), add.size(), nullptr));
    if (!params->add) {
      THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""could not generate prime"");
      return Nothing<bool>();
    }
  }",41,,99,2,,void
51750,BLOCK,-1,,"{
      THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""could not generate prime"");
      return Nothing<bool>();
    }",23,,102,2,,void
51766,BLOCK,-1,,"{
    ArrayBufferOrViewContents<unsigned char> rem(args[offset + 3]);
    params->rem.reset(BN_bin2bn(rem.data(), rem.size(), nullptr));
    if (!params->rem) {
      THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""could not generate prime"");
      return Nothing<bool>();
    }
  }",41,,108,2,,void
51795,BLOCK,-1,,"{
      THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""could not generate prime"");
      return Nothing<bool>();
    }",23,,111,2,,void
51814,BLOCK,-1,,"{
    if (BN_num_bits(params->add.get()) > bits) {
      // If we allowed this, the best case would be returning a static prime
      // that wasn't generated randomly. The worst case would be an infinite
      // loop within OpenSSL, blocking the main thread or one of the threads
      // in the thread pool.
      THROW_ERR_OUT_OF_RANGE(env, ""invalid options.add"");
      return Nothing<bool>();
    }

    if (params->rem) {
      if (BN_cmp(params->add.get(), params->rem.get()) != 1) {
        // This would definitely lead to an infinite loop if allowed since
        // OpenSSL does not check this condition.
        THROW_ERR_OUT_OF_RANGE(env, ""invalid options.rem"");
        return Nothing<bool>();
      }
    }
  }",20,,121,2,,void
51825,BLOCK,-1,,"{
      // If we allowed this, the best case would be returning a static prime
      // that wasn't generated randomly. The worst case would be an infinite
      // loop within OpenSSL, blocking the main thread or one of the threads
      // in the thread pool.
      THROW_ERR_OUT_OF_RANGE(env, ""invalid options.add"");
      return Nothing<bool>();
    }",48,,122,2,,void
51835,BLOCK,-1,,"{
      if (BN_cmp(params->add.get(), params->rem.get()) != 1) {
        // This would definitely lead to an infinite loop if allowed since
        // OpenSSL does not check this condition.
        THROW_ERR_OUT_OF_RANGE(env, ""invalid options.rem"");
        return Nothing<bool>();
      }
    }",22,,131,2,,void
51852,BLOCK,-1,,"{
        // This would definitely lead to an infinite loop if allowed since
        // OpenSSL does not check this condition.
        THROW_ERR_OUT_OF_RANGE(env, ""invalid options.rem"");
        return Nothing<bool>();
      }",62,,132,2,,void
51880,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""could not generate prime"");
    return Nothing<bool>();
  }",23,,144,2,,void
51895,BLOCK,-1,,"{
  // BN_generate_prime_ex() calls RAND_bytes_ex() internally.
  // Make sure the CSPRNG is properly seeded.
  CHECK(CSPRNG(nullptr, 0).is_ok());

  if (BN_generate_prime_ex(
          params.prime.get(),
          params.bits,
          params.safe ? 1 : 0,
          params.add.get(),
          params.rem.get(),
          nullptr) == 0) {
    return false;
  }

  return true;
}",56,,154,4,,void
51935,BLOCK,-1,,"{
    return false;
  }",26,,165,2,,void
51944,BLOCK,-1,,"{
  tracker->TrackFieldWithSize(
      ""prime"", candidate ? BN_num_bytes(candidate.get()) : 0);
}",65,,172,2,,void
51965,BLOCK,-1,,"{
  ArrayBufferOrViewContents<unsigned char> candidate(args[offset]);

  params->candidate =
      BignumPointer(BN_bin2bn(
          candidate.data(),
          candidate.size(),
          nullptr));

  CHECK(args[offset + 1]->IsInt32());  // Checks
  params->checks = args[offset + 1].As<Int32>()->Value();
  CHECK_GE(params->checks, 0);

  return Just(true);
}",31,,181,5,,void
52024,BLOCK,-1,,"{

  BignumCtxPointer ctx(BN_CTX_new());

  int ret = BN_is_prime_ex(
            params.candidate.get(),
            params.checks,
            ctx.get(),
            nullptr);
  if (ret < 0) return false;
  ByteSource::Builder buf(1);
  buf.data<char>()[0] = ret;
  *out = std::move(buf).release();
  return true;
}",22,,200,4,,void
52050,BLOCK,-1,,<empty>,16,,209,2,,void
52084,BLOCK,-1,,"{
  *result = Boolean::New(env->isolate(), out->data<char>()[0] != 0);
  return Just(true);
}",35,,220,5,,void
52113,BLOCK,-1,,"{
  RandomBytesJob::Initialize(env, target);
  RandomPrimeJob::Initialize(env, target);
  CheckPrimeJob::Initialize(env, target);
}",57,,226,3,,void
52136,BLOCK,-1,,"{
  RandomBytesJob::RegisterExternalReferences(registry);
  RandomPrimeJob::RegisterExternalReferences(registry);
  CheckPrimeJob::RegisterExternalReferences(registry);
}",70,,232,2,,void
52170,BLOCK,-1,,<empty>,1,,1,1,,ANY
52199,BLOCK,-1,,<empty>,1,,1,1,,ANY
52204,BLOCK,-1,,"{
  EVPKeyCtxPointer ctx(
      EVP_PKEY_CTX_new_id(
          params->params.variant == kKeyVariantRSA_PSS
              ? EVP_PKEY_RSA_PSS
              : EVP_PKEY_RSA,
          nullptr));

  if (EVP_PKEY_keygen_init(ctx.get()) <= 0)
    return EVPKeyCtxPointer();

  if (EVP_PKEY_CTX_set_rsa_keygen_bits(
          ctx.get(),
          params->params.modulus_bits) <= 0) {
    return EVPKeyCtxPointer();
  }

  // 0x10001 is the default RSA exponent.
  if (params->params.exponent != 0x10001) {
    BignumPointer bn(BN_new());
    CHECK_NOT_NULL(bn.get());
    CHECK(BN_set_word(bn.get(), params->params.exponent));
    // EVP_CTX accepts ownership of bn on success.
    if (EVP_PKEY_CTX_set_rsa_keygen_pubexp(ctx.get(), bn.get()) <= 0)
      return EVPKeyCtxPointer();

    bn.release();
  }

  if (params->params.variant == kKeyVariantRSA_PSS) {
    if (params->params.md != nullptr &&
        EVP_PKEY_CTX_set_rsa_pss_keygen_md(ctx.get(), params->params.md) <= 0) {
      return EVPKeyCtxPo...",70,,32,2,,void
52227,BLOCK,-1,,<empty>,5,,41,2,,void
52243,BLOCK,-1,,"{
    return EVPKeyCtxPointer();
  }",46,,45,2,,void
52254,BLOCK,-1,,"{
    BignumPointer bn(BN_new());
    CHECK_NOT_NULL(bn.get());
    CHECK(BN_set_word(bn.get(), params->params.exponent));
    // EVP_CTX accepts ownership of bn on success.
    if (EVP_PKEY_CTX_set_rsa_keygen_pubexp(ctx.get(), bn.get()) <= 0)
      return EVPKeyCtxPointer();

    bn.release();
  }",43,,50,2,,void
52286,BLOCK,-1,,<empty>,7,,56,2,,void
52301,BLOCK,-1,,"{
    if (params->params.md != nullptr &&
        EVP_PKEY_CTX_set_rsa_pss_keygen_md(ctx.get(), params->params.md) <= 0) {
      return EVPKeyCtxPointer();
    }

    // TODO(tniessen): This appears to only be necessary in OpenSSL 3, while
    // OpenSSL 1.1.1 behaves as recommended by RFC 8017 and defaults the MGF1
    // hash algorithm to the RSA-PSS hashAlgorithm. Remove this code if the
    // behavior of OpenSSL 3 changes.
    const EVP_MD* mgf1_md = params->params.mgf1_md;
    if (mgf1_md == nullptr && params->params.md != nullptr) {
      mgf1_md = params->params.md;
    }

    if (mgf1_md != nullptr &&
        EVP_PKEY_CTX_set_rsa_pss_keygen_mgf1_md(
            ctx.get(),
            mgf1_md) <= 0) {
      return EVPKeyCtxPointer();
    }

    int saltlen = params->params.saltlen;
    if (saltlen < 0 && params->params.md != nullptr) {
      saltlen = EVP_MD_size(params->params.md);
    }

    if (saltlen >= 0 &&
        EVP_PKEY_CTX_set_rsa_pss_keygen_saltlen(
            c...",53,,61,2,,void
52323,BLOCK,-1,,"{
      return EVPKeyCtxPointer();
    }",80,,63,2,,void
52346,BLOCK,-1,,"{
      mgf1_md = params->params.md;
    }",61,,72,2,,void
52367,BLOCK,-1,,"{
      return EVPKeyCtxPointer();
    }",28,,79,2,,void
52390,BLOCK,-1,,"{
      saltlen = EVP_MD_size(params->params.md);
    }",54,,84,2,,void
52412,BLOCK,-1,,"{
      return EVPKeyCtxPointer();
    }",28,,91,2,,void
52424,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[*offset]->IsUint32());  // Variant
  CHECK(args[*offset + 1]->IsUint32());  // Modulus bits
  CHECK(args[*offset + 2]->IsUint32());  // Exponent

  params->params.variant =
      static_cast<RSAKeyVariant>(args[*offset].As<Uint32>()->Value());

  CHECK_IMPLIES(params->params.variant != kKeyVariantRSA_PSS,
                args.Length() == 10);
  CHECK_IMPLIES(params->params.variant == kKeyVariantRSA_PSS,
                args.Length() == 13);

  params->params.modulus_bits = args[*offset + 1].As<Uint32>()->Value();
  params->params.exponent = args[*offset + 2].As<Uint32>()->Value();

  *offset += 3;

  if (params->params.variant == kKeyVariantRSA_PSS) {
    if (!args[*offset]->IsUndefined()) {
      CHECK(args[*offset]->IsString());
      Utf8Value digest(env->isolate(), args[*offset]);
      params->params.md = EVP_get_digestbyname(*digest);
      if (params->params.md == nullptr) {
        THROW_ERR_CRYPTO_INVALID_D...",34,,130,5,,void
52555,BLOCK,-1,,"{
    if (!args[*offset]->IsUndefined()) {
      CHECK(args[*offset]->IsString());
      Utf8Value digest(env->isolate(), args[*offset]);
      params->params.md = EVP_get_digestbyname(*digest);
      if (params->params.md == nullptr) {
        THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
        return Nothing<bool>();
      }
    }

    if (!args[*offset + 1]->IsUndefined()) {
      CHECK(args[*offset + 1]->IsString());
      Utf8Value digest(env->isolate(), args[*offset + 1]);
      params->params.mgf1_md = EVP_get_digestbyname(*digest);
      if (params->params.mgf1_md == nullptr) {
        THROW_ERR_CRYPTO_INVALID_DIGEST(
            env, ""Invalid MGF1 digest: %s"", *digest);
        return Nothing<bool>();
      }
    }

    if (!args[*offset + 2]->IsUndefined()) {
      CHECK(args[*offset + 2]->IsInt32());
      params->params.saltlen = args[*offset + 2].As<Int32>()->Value();
      if (params->params.saltlen < 0) {
        THROW_ERR_OUT_OF_RANGE(
      ...",53,,150,2,,void
52565,BLOCK,-1,,"{
      CHECK(args[*offset]->IsString());
      Utf8Value digest(env->isolate(), args[*offset]);
      params->params.md = EVP_get_digestbyname(*digest);
      if (params->params.md == nullptr) {
        THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
        return Nothing<bool>();
      }
    }",40,,151,2,,void
52601,BLOCK,-1,,"{
        THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
        return Nothing<bool>();
      }",41,,155,2,,void
52620,BLOCK,-1,,"{
      CHECK(args[*offset + 1]->IsString());
      Utf8Value digest(env->isolate(), args[*offset + 1]);
      params->params.mgf1_md = EVP_get_digestbyname(*digest);
      if (params->params.mgf1_md == nullptr) {
        THROW_ERR_CRYPTO_INVALID_DIGEST(
            env, ""Invalid MGF1 digest: %s"", *digest);
        return Nothing<bool>();
      }
    }",44,,161,2,,void
52660,BLOCK,-1,,"{
        THROW_ERR_CRYPTO_INVALID_DIGEST(
            env, ""Invalid MGF1 digest: %s"", *digest);
        return Nothing<bool>();
      }",46,,165,2,,void
52679,BLOCK,-1,,"{
      CHECK(args[*offset + 2]->IsInt32());
      params->params.saltlen = args[*offset + 2].As<Int32>()->Value();
      if (params->params.saltlen < 0) {
        THROW_ERR_OUT_OF_RANGE(
          env,
          ""salt length is out of range"");
        return Nothing<bool>();
      }
    }",44,,172,2,,void
52716,BLOCK,-1,,"{
        THROW_ERR_OUT_OF_RANGE(
          env,
          ""salt length is out of range"");
        return Nothing<bool>();
      }",39,,175,2,,void
52736,BLOCK,-1,,"{
  return WebCryptoKeyExportStatus::FAILED;
}",22,,193,4,,void
52749,BLOCK,-1,,"{
  CHECK_NE(key_data->GetKeyType(), kKeyTypeSecret);
  ManagedEVPPKey m_pkey = key_data->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());

  EVPKeyCtxPointer ctx(EVP_PKEY_CTX_new(m_pkey.get(), nullptr));

  if (!ctx || init(ctx.get()) <= 0)
    return WebCryptoCipherStatus::FAILED;

  if (EVP_PKEY_CTX_set_rsa_padding(ctx.get(), params.padding) <= 0) {
    return WebCryptoCipherStatus::FAILED;
  }

  if (params.digest != nullptr &&
      (EVP_PKEY_CTX_set_rsa_oaep_md(ctx.get(), params.digest) <= 0 ||
       EVP_PKEY_CTX_set_rsa_mgf1_md(ctx.get(), params.digest) <= 0)) {
    return WebCryptoCipherStatus::FAILED;
  }

  if (!SetRsaOaepLabel(ctx, params.label)) return WebCryptoCipherStatus::FAILED;

  size_t out_len = 0;
  if (cipher(
          ctx.get(),
          nullptr,
          &out_len,
          in.data<unsigned char>(),
          in.size()) <= 0) {
    return WebCryptoCipherStatus::FAILED;
  }

  ByteSource::Builder buf(out_len);

  if (cipher(ctx.get(),
        ...",22,,204,6,,void
52789,BLOCK,-1,,<empty>,5,,212,2,,void
52805,BLOCK,-1,,"{
    return WebCryptoCipherStatus::FAILED;
  }",69,,214,2,,void
52838,BLOCK,-1,,"{
    return WebCryptoCipherStatus::FAILED;
  }",70,,220,2,,void
52850,BLOCK,-1,,<empty>,44,,224,2,,void
52878,BLOCK,-1,,"{
    return WebCryptoCipherStatus::FAILED;
  }",28,,232,2,,void
52908,BLOCK,-1,,"{
    return WebCryptoCipherStatus::FAILED;
  }",31,,242,2,,void
52935,BLOCK,-1,,"{
  CHECK(args[offset]->IsUint32());  // RSAKeyVariant
  params->variant =
      static_cast<RSAKeyVariant>(args[offset].As<Uint32>()->Value());
  return Just(true);
}",33,,254,4,,void
52968,BLOCK,-1,,"{
  CHECK_NE(key_data->GetKeyType(), kKeyTypeSecret);

  switch (format) {
    case kWebCryptoKeyFormatRaw:
      // Not supported for RSA keys of either type
      return WebCryptoKeyExportStatus::FAILED;
    case kWebCryptoKeyFormatJWK:
      return RSA_JWK_Export(key_data.get(), params, out);
    case kWebCryptoKeyFormatPKCS8:
      if (key_data->GetKeyType() != kKeyTypePrivate)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_PKCS8_Export(key_data.get(), out);
    case kWebCryptoKeyFormatSPKI:
      if (key_data->GetKeyType() != kKeyTypePublic)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_SPKI_Export(key_data.get(), out);
    default:
      UNREACHABLE();
  }
}",22,,265,5,,void
52977,BLOCK,-1,,"{
    case kWebCryptoKeyFormatRaw:
      // Not supported for RSA keys of either type
      return WebCryptoKeyExportStatus::FAILED;
    case kWebCryptoKeyFormatJWK:
      return RSA_JWK_Export(key_data.get(), params, out);
    case kWebCryptoKeyFormatPKCS8:
      if (key_data->GetKeyType() != kKeyTypePrivate)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_PKCS8_Export(key_data.get(), out);
    case kWebCryptoKeyFormatSPKI:
      if (key_data->GetKeyType() != kKeyTypePublic)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_SPKI_Export(key_data.get(), out);
    default:
      UNREACHABLE();
  }",19,,268,2,,void
53003,BLOCK,-1,,<empty>,9,,276,2,,void
53024,BLOCK,-1,,<empty>,9,,280,2,,void
53042,BLOCK,-1,,<empty>,28,,291,2,,void
53047,BLOCK,-1,,"{
  if (mode == kCryptoJobAsync)
    tracker->TrackFieldWithSize(""label"", label.size());
}",64,,293,2,,void
53052,BLOCK,-1,,<empty>,5,,295,2,,void
53070,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  params->mode = mode;
  params->padding = RSA_PKCS1_OAEP_PADDING;

  CHECK(args[offset]->IsUint32());
  RSAKeyVariant variant =
      static_cast<RSAKeyVariant>(args[offset].As<Uint32>()->Value());

  switch (variant) {
    case kKeyVariantRSA_OAEP: {
      CHECK(args[offset + 1]->IsString());  // digest
      Utf8Value digest(env->isolate(), args[offset + 1]);

      params->digest = EVP_get_digestbyname(*digest);
      if (params->digest == nullptr) {
        THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
        return Nothing<bool>();
      }

      if (IsAnyByteSource(args[offset + 2])) {
        ArrayBufferOrViewContents<char> label(args[offset + 2]);
        if (UNLIKELY(!label.CheckSizeInt32())) {
          THROW_ERR_OUT_OF_RANGE(env, ""label is too big"");
          return Nothing<bool>();
        }
        params->label = label.ToCopy();
      }
      break;
    }
    default:
      THROW_ERR_CRYPT...",30,,303,6,,void
53112,BLOCK,-1,,"{
    case kKeyVariantRSA_OAEP: {
      CHECK(args[offset + 1]->IsString());  // digest
      Utf8Value digest(env->isolate(), args[offset + 1]);

      params->digest = EVP_get_digestbyname(*digest);
      if (params->digest == nullptr) {
        THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
        return Nothing<bool>();
      }

      if (IsAnyByteSource(args[offset + 2])) {
        ArrayBufferOrViewContents<char> label(args[offset + 2]);
        if (UNLIKELY(!label.CheckSizeInt32())) {
          THROW_ERR_OUT_OF_RANGE(env, ""label is too big"");
          return Nothing<bool>();
        }
        params->label = label.ToCopy();
      }
      break;
    }
    default:
      THROW_ERR_CRYPTO_INVALID_KEYTYPE(env);
      return Nothing<bool>();
  }",20,,313,2,,void
53115,BLOCK,3,,"{
      CHECK(args[offset + 1]->IsString());  // digest
      Utf8Value digest(env->isolate(), args[offset + 1]);

      params->digest = EVP_get_digestbyname(*digest);
      if (params->digest == nullptr) {
        THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
        return Nothing<bool>();
      }

      if (IsAnyByteSource(args[offset + 2])) {
        ArrayBufferOrViewContents<char> label(args[offset + 2]);
        if (UNLIKELY(!label.CheckSizeInt32())) {
          THROW_ERR_OUT_OF_RANGE(env, ""label is too big"");
          return Nothing<bool>();
        }
        params->label = label.ToCopy();
      }
      break;
    }",31,,314,3,,void
53149,BLOCK,-1,,"{
        THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
        return Nothing<bool>();
      }",38,,319,2,,void
53164,BLOCK,-1,,"{
        ArrayBufferOrViewContents<char> label(args[offset + 2]);
        if (UNLIKELY(!label.CheckSizeInt32())) {
          THROW_ERR_OUT_OF_RANGE(env, ""label is too big"");
          return Nothing<bool>();
        }
        params->label = label.ToCopy();
      }",46,,324,2,,void
53179,BLOCK,-1,,"{
          THROW_ERR_OUT_OF_RANGE(env, ""label is too big"");
          return Nothing<bool>();
        }",48,,326,2,,void
53211,BLOCK,-1,,"{
  switch (cipher_mode) {
    case kWebCryptoCipherEncrypt:
      CHECK_EQ(key_data->GetKeyType(), kKeyTypePublic);
      return RSA_Cipher<EVP_PKEY_encrypt_init, EVP_PKEY_encrypt>(
          env, key_data.get(), params, in, out);
    case kWebCryptoCipherDecrypt:
      CHECK_EQ(key_data->GetKeyType(), kKeyTypePrivate);
      return RSA_Cipher<EVP_PKEY_decrypt_init, EVP_PKEY_decrypt>(
          env, key_data.get(), params, in, out);
  }
  return WebCryptoCipherStatus::FAILED;
}",22,,348,7,,void
53214,BLOCK,-1,,"{
    case kWebCryptoCipherEncrypt:
      CHECK_EQ(key_data->GetKeyType(), kKeyTypePublic);
      return RSA_Cipher<EVP_PKEY_encrypt_init, EVP_PKEY_encrypt>(
          env, key_data.get(), params, in, out);
    case kWebCryptoCipherDecrypt:
      CHECK_EQ(key_data->GetKeyType(), kKeyTypePrivate);
      return RSA_Cipher<EVP_PKEY_decrypt_init, EVP_PKEY_decrypt>(
          env, key_data.get(), params, in, out);
  }",24,,349,2,,void
53261,BLOCK,-1,,"{
  ManagedEVPPKey m_pkey = key->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());
  int type = EVP_PKEY_id(m_pkey.get());
  CHECK(type == EVP_PKEY_RSA || type == EVP_PKEY_RSA_PSS);

  // TODO(tniessen): Remove the ""else"" branch once we drop support for OpenSSL
  // versions older than 1.1.1e via FIPS / dynamic linking.
  const RSA* rsa;
  if (OpenSSL_version_num() >= 0x1010105fL) {
    rsa = EVP_PKEY_get0_RSA(m_pkey.get());
  } else {
    rsa = static_cast<const RSA*>(EVP_PKEY_get0(m_pkey.get()));
  }
  CHECK_NOT_NULL(rsa);

  const BIGNUM* n;
  const BIGNUM* e;
  const BIGNUM* d;
  const BIGNUM* p;
  const BIGNUM* q;
  const BIGNUM* dp;
  const BIGNUM* dq;
  const BIGNUM* qi;
  RSA_get0_key(rsa, &n, &e, &d);

  if (target->Set(
          env->context(),
          env->jwk_kty_string(),
          env->jwk_rsa_string()).IsNothing()) {
    return Nothing<bool>();
  }

  if (SetEncodedValue(env, target, env->jwk_n_string(), n).IsNothing() ||
      SetEncodedValue(env, tar...",27,,365,4,,void
53297,BLOCK,-1,,"{
    rsa = EVP_PKEY_get0_RSA(m_pkey.get());
  }",45,,374,2,,void
53306,BLOCK,-1,,"{
    rsa = static_cast<const RSA*>(EVP_PKEY_get0(m_pkey.get()));
  }",10,,376,1,,void
53354,BLOCK,-1,,"{
    return Nothing<bool>();
  }",47,,394,2,,void
53381,BLOCK,-1,,"{
    return Nothing<bool>();
  }",73,,399,2,,void
53391,BLOCK,-1,,"{
    RSA_get0_factors(rsa, &p, &q);
    RSA_get0_crt_params(rsa, &dp, &dq, &qi);
    if (SetEncodedValue(env, target, env->jwk_d_string(), d).IsNothing() ||
        SetEncodedValue(env, target, env->jwk_p_string(), p).IsNothing() ||
        SetEncodedValue(env, target, env->jwk_q_string(), q).IsNothing() ||
        SetEncodedValue(env, target, env->jwk_dp_string(), dp).IsNothing() ||
        SetEncodedValue(env, target, env->jwk_dq_string(), dq).IsNothing() ||
        SetEncodedValue(env, target, env->jwk_qi_string(), qi).IsNothing()) {
      return Nothing<bool>();
    }
  }",45,,403,2,,void
53478,BLOCK,-1,,"{
      return Nothing<bool>();
    }",77,,411,2,,void
53491,BLOCK,-1,,"{
  Local<Value> n_value;
  Local<Value> e_value;
  Local<Value> d_value;

  if (!jwk->Get(env->context(), env->jwk_n_string()).ToLocal(&n_value) ||
      !jwk->Get(env->context(), env->jwk_e_string()).ToLocal(&e_value) ||
      !jwk->Get(env->context(), env->jwk_d_string()).ToLocal(&d_value) ||
      !n_value->IsString() ||
      !e_value->IsString()) {
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK RSA key"");
    return std::shared_ptr<KeyObjectData>();
  }

  if (!d_value->IsUndefined() && !d_value->IsString()) {
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK RSA key"");
    return std::shared_ptr<KeyObjectData>();
  }

  KeyType type = d_value->IsString() ? kKeyTypePrivate : kKeyTypePublic;

  RsaPointer rsa(RSA_new());

  ByteSource n = ByteSource::FromEncodedString(env, n_value.As<String>());
  ByteSource e = ByteSource::FromEncodedString(env, e_value.As<String>());

  if (!RSA_set0_key(
          rsa.get(),
          n.ToBN().release(),
          e.ToBN().release(),
  ...",26,,423,5,,void
53576,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK RSA key"");
    return std::shared_ptr<KeyObjectData>();
  }",29,,432,2,,void
53597,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK RSA key"");
    return std::shared_ptr<KeyObjectData>();
  }",56,,437,2,,void
53665,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK RSA key"");
    return std::shared_ptr<KeyObjectData>();
  }",21,,453,2,,void
53678,BLOCK,-1,,"{
    Local<Value> p_value;
    Local<Value> q_value;
    Local<Value> dp_value;
    Local<Value> dq_value;
    Local<Value> qi_value;

    if (!jwk->Get(env->context(), env->jwk_p_string()).ToLocal(&p_value) ||
        !jwk->Get(env->context(), env->jwk_q_string()).ToLocal(&q_value) ||
        !jwk->Get(env->context(), env->jwk_dp_string()).ToLocal(&dp_value) ||
        !jwk->Get(env->context(), env->jwk_dq_string()).ToLocal(&dq_value) ||
        !jwk->Get(env->context(), env->jwk_qi_string()).ToLocal(&qi_value)) {
      THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK RSA key"");
      return std::shared_ptr<KeyObjectData>();
    }

    if (!p_value->IsString() ||
        !q_value->IsString() ||
        !dp_value->IsString() ||
        !dq_value->IsString() ||
        !qi_value->IsString()) {
      THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK RSA key"");
      return std::shared_ptr<KeyObjectData>();
    }

    ByteSource d = ByteSource::FromEncodedString(env, d_value.As<String>());...",32,,458,2,,void
53799,BLOCK,-1,,"{
      THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK RSA key"");
      return std::shared_ptr<KeyObjectData>();
    }",77,,469,2,,void
53838,BLOCK,-1,,"{
      THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK RSA key"");
      return std::shared_ptr<KeyObjectData>();
    }",32,,478,2,,void
53984,BLOCK,-1,,"{
      THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK RSA key"");
      return std::shared_ptr<KeyObjectData>();
    }",35,,496,2,,void
54025,BLOCK,-1,,"{
  const BIGNUM* e;  // Public Exponent
  const BIGNUM* n;  // Modulus

  ManagedEVPPKey m_pkey = key->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());
  int type = EVP_PKEY_id(m_pkey.get());
  CHECK(type == EVP_PKEY_RSA || type == EVP_PKEY_RSA_PSS);

  // TODO(tniessen): Remove the ""else"" branch once we drop support for OpenSSL
  // versions older than 1.1.1e via FIPS / dynamic linking.
  const RSA* rsa;
  if (OpenSSL_version_num() >= 0x1010105fL) {
    rsa = EVP_PKEY_get0_RSA(m_pkey.get());
  } else {
    rsa = static_cast<const RSA*>(EVP_PKEY_get0(m_pkey.get()));
  }
  CHECK_NOT_NULL(rsa);

  RSA_get0_key(rsa, &n, &e, nullptr);

  size_t modulus_length = BN_num_bits(n);

  if (target
          ->Set(
              env->context(),
              env->modulus_length_string(),
              Number::New(env->isolate(), static_cast<double>(modulus_length)))
          .IsNothing()) {
    return Nothing<bool>();
  }

  std::unique_ptr<BackingStore> public_exponent;
  {
   ...",27,,511,4,,void
54063,BLOCK,-1,,"{
    rsa = EVP_PKEY_get0_RSA(m_pkey.get());
  }",45,,523,2,,void
54072,BLOCK,-1,,"{
    rsa = static_cast<const RSA*>(EVP_PKEY_get0(m_pkey.get()));
  }",10,,525,1,,void
54123,BLOCK,-1,,"{
    return Nothing<bool>();
  }",25,,539,2,,void
54133,BLOCK,18,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    public_exponent =
        ArrayBuffer::NewBackingStore(env->isolate(), BN_num_bytes(e));
  }",3,,544,18,,void
54200,BLOCK,-1,,"{
    return Nothing<bool>();
  }",25,,558,2,,void
54207,BLOCK,-1,,"{
    // Due to the way ASN.1 encoding works, default values are omitted when
    // encoding the data structure. However, there are also RSA-PSS keys for
    // which no parameters are set. In that case, the ASN.1 RSASSA-PSS-params
    // sequence will be missing entirely and RSA_get0_pss_params will return
    // nullptr. If parameters are present but all parameters are set to their
    // default values, an empty sequence will be stored in the ASN.1 structure.
    // In that case, RSA_get0_pss_params does not return nullptr but all fields
    // of the returned RSA_PSS_PARAMS will be set to nullptr.

    const RSA_PSS_PARAMS* params = RSA_get0_pss_params(rsa);
    if (params != nullptr) {
      int hash_nid = NID_sha1;
      int mgf_nid = NID_mgf1;
      int mgf1_hash_nid = NID_sha1;
      int64_t salt_length = 20;

      if (params->hashAlgorithm != nullptr) {
        hash_nid = OBJ_obj2nid(params->hashAlgorithm->algorithm);
      }

      if (target
              ->Set(
       ...",33,,562,2,,void
54217,BLOCK,-1,,"{
      int hash_nid = NID_sha1;
      int mgf_nid = NID_mgf1;
      int mgf1_hash_nid = NID_sha1;
      int64_t salt_length = 20;

      if (params->hashAlgorithm != nullptr) {
        hash_nid = OBJ_obj2nid(params->hashAlgorithm->algorithm);
      }

      if (target
              ->Set(
                  env->context(),
                  env->hash_algorithm_string(),
                  OneByteString(env->isolate(), OBJ_nid2ln(hash_nid)))
              .IsNothing()) {
        return Nothing<bool>();
      }

      if (params->maskGenAlgorithm != nullptr) {
        mgf_nid = OBJ_obj2nid(params->maskGenAlgorithm->algorithm);
        if (mgf_nid == NID_mgf1) {
          mgf1_hash_nid = OBJ_obj2nid(params->maskHash->algorithm);
        }
      }

      // If, for some reason, the MGF is not MGF1, then the MGF1 hash function
      // is intentionally not added to the object.
      if (mgf_nid == NID_mgf1) {
        if (target
                ->Set(
                    env->context(),
  ...",28,,573,2,,void
54240,BLOCK,-1,,"{
        hash_nid = OBJ_obj2nid(params->hashAlgorithm->algorithm);
      }",45,,579,2,,void
54272,BLOCK,-1,,"{
        return Nothing<bool>();
      }",29,,588,2,,void
54281,BLOCK,-1,,"{
        mgf_nid = OBJ_obj2nid(params->maskGenAlgorithm->algorithm);
        if (mgf_nid == NID_mgf1) {
          mgf1_hash_nid = OBJ_obj2nid(params->maskHash->algorithm);
        }
      }",48,,592,2,,void
54294,BLOCK,-1,,"{
          mgf1_hash_nid = OBJ_obj2nid(params->maskHash->algorithm);
        }",34,,594,2,,void
54307,BLOCK,-1,,"{
        if (target
                ->Set(
                    env->context(),
                    env->mgf1_hash_algorithm_string(),
                    OneByteString(env->isolate(), OBJ_nid2ln(mgf1_hash_nid)))
                .IsNothing()) {
          return Nothing<bool>();
        }
      }",32,,601,2,,void
54331,BLOCK,-1,,"{
          return Nothing<bool>();
        }",31,,607,2,,void
54340,BLOCK,-1,,"{
        if (ASN1_INTEGER_get_int64(&salt_length, params->saltLength) != 1) {
          ThrowCryptoError(env, ERR_get_error(), ""ASN1_INTEGER_get_in64 error"");
          return Nothing<bool>();
        }
      }",42,,612,2,,void
54350,BLOCK,-1,,"{
          ThrowCryptoError(env, ERR_get_error(), ""ASN1_INTEGER_get_in64 error"");
          return Nothing<bool>();
        }",76,,613,2,,void
54384,BLOCK,-1,,"{
        return Nothing<bool>();
      }",29,,624,2,,void
54396,BLOCK,-1,,"{
  RSAKeyPairGenJob::Initialize(env, target);
  RSAKeyExportJob::Initialize(env, target);
  RSACipherJob::Initialize(env, target);

  NODE_DEFINE_CONSTANT(target, kKeyVariantRSA_SSA_PKCS1_v1_5);
  NODE_DEFINE_CONSTANT(target, kKeyVariantRSA_PSS);
  NODE_DEFINE_CONSTANT(target, kKeyVariantRSA_OAEP);
}",57,,634,3,,void
54428,BLOCK,-1,,"{
  RSAKeyPairGenJob::RegisterExternalReferences(registry);
  RSAKeyExportJob::RegisterExternalReferences(registry);
  RSACipherJob::RegisterExternalReferences(registry);
}",70,,644,2,,void
54464,BLOCK,-1,,<empty>,1,,1,1,,ANY
54485,BLOCK,-1,,<empty>,1,,1,1,,ANY
54490,BLOCK,-1,,<empty>,26,,31,2,,void
54495,BLOCK,-1,,"{
  if (&other == this) return *this;
  this->~ScryptConfig();
  return *new (this) ScryptConfig(std::move(other));
}",70,,33,2,,void
54501,BLOCK,-1,,<empty>,23,,34,2,,void
54523,BLOCK,-1,,"{
  if (mode == kCryptoJobAsync) {
    tracker->TrackFieldWithSize(""pass"", pass.size());
    tracker->TrackFieldWithSize(""salt"", salt.size());
  }
}",61,,39,2,,void
54528,BLOCK,-1,,"{
    tracker->TrackFieldWithSize(""pass"", pass.size());
    tracker->TrackFieldWithSize(""salt"", salt.size());
  }",32,,40,2,,void
54554,BLOCK,-1,,"{
  *result = out->ToArrayBuffer(env);
  return Just(!result->IsEmpty());
}",35,,50,5,,void
54577,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  params->mode = mode;

  ArrayBufferOrViewContents<char> pass(args[offset]);
  ArrayBufferOrViewContents<char> salt(args[offset + 1]);

  if (UNLIKELY(!pass.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""pass is too large"");
    return Nothing<bool>();
  }

  if (UNLIKELY(!salt.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""salt is too large"");
    return Nothing<bool>();
  }

  params->pass = mode == kCryptoJobAsync
      ? pass.ToCopy()
      : pass.ToByteSource();

  params->salt = mode == kCryptoJobAsync
      ? salt.ToCopy()
      : salt.ToByteSource();

  CHECK(args[offset + 2]->IsUint32());  // N
  CHECK(args[offset + 3]->IsUint32());  // r
  CHECK(args[offset + 4]->IsUint32());  // p
  CHECK(args[offset + 5]->IsNumber());  // maxmem
  CHECK(args[offset + 6]->IsInt32());  // length

  params->N = args[offset + 2].As<Uint32>()->Value();
  params->r = args[offset + 3].As<Uint32>()->Value();
  params->p = args...",27,,59,5,,void
54610,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""pass is too large"");
    return Nothing<bool>();
  }",41,,67,2,,void
54623,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""salt is too large"");
    return Nothing<bool>();
  }",41,,72,2,,void
54792,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_SCRYPT_PARAMS(env);
    return Nothing<bool>();
  }",20,,106,2,,void
54826,BLOCK,-1,,"{
  ByteSource::Builder buf(params.length);

  // Both the pass and salt may be zero-length at this point

  if (!EVP_PBE_scrypt(params.pass.data<char>(),
                      params.pass.size(),
                      params.salt.data<unsigned char>(),
                      params.salt.size(),
                      params.N,
                      params.r,
                      params.p,
                      params.maxmem,
                      buf.data<unsigned char>(),
                      params.length)) {
    return false;
  }
  *out = std::move(buf).release();
  return true;
}",22,,120,4,,void
54878,BLOCK,-1,,"{
    return false;
  }",39,,134,2,,void
54908,BLOCK,-1,,<empty>,1,,1,1,,ANY
54915,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    Error err = sign->Update(data, size);
    crypto::CheckThrow(sign->env(), err);
  }",56,,377,5,,void
54929,BLOCK,-1,,<empty>,7,,380,2,,void
54962,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    Error err = verify->Update(data, size);
    crypto::CheckThrow(verify->env(), err);
  }",58,,494,5,,void
54976,BLOCK,-1,,<empty>,7,,497,2,,void
55025,BLOCK,-1,,<empty>,1,,1,1,,ANY
55031,BLOCK,-1,,"{
  /* Validate DSA2 parameters from FIPS 186-4 */
#if OPENSSL_VERSION_MAJOR >= 3
  if (EVP_default_properties_is_fips_enabled(nullptr) &&
      EVP_PKEY_DSA == EVP_PKEY_base_id(key)) {
#else
  if (FIPS_mode() && EVP_PKEY_DSA == EVP_PKEY_base_id(key)) {
#endif
    const DSA* dsa = EVP_PKEY_get0_DSA(key);
    const BIGNUM* p;
    DSA_get0_pqg(dsa, &p, nullptr, nullptr);
    size_t L = BN_num_bits(p);
    const BIGNUM* q;
    DSA_get0_pqg(dsa, nullptr, &q, nullptr);
    size_t N = BN_num_bits(q);

    return (L == 1024 && N == 160) ||
           (L == 2048 && N == 224) ||
           (L == 2048 && N == 256) ||
           (L == 3072 && N == 256);
  }

  return true;
}",43,,32,2,,void
55039,BLOCK,-1,,"{
#endif
    const DSA* dsa = EVP_PKEY_get0_DSA(key);
    const BIGNUM* p;
    DSA_get0_pqg(dsa, &p, nullptr, nullptr);
    size_t L = BN_num_bits(p);
    const BIGNUM* q;
    DSA_get0_pqg(dsa, nullptr, &q, nullptr);
    size_t N = BN_num_bits(q);

    return (L == 1024 && N == 160) ||
           (L == 2048 && N == 224) ||
           (L == 2048 && N == 256) ||
           (L == 3072 && N == 256);
  }",61,,38,2,,void
55110,BLOCK,-1,,"{
  if (EVP_PKEY_id(pkey.get()) == EVP_PKEY_RSA ||
      EVP_PKEY_id(pkey.get()) == EVP_PKEY_RSA2 ||
      EVP_PKEY_id(pkey.get()) == EVP_PKEY_RSA_PSS) {
    if (EVP_PKEY_CTX_set_rsa_padding(pkctx, padding) <= 0)
      return false;
    if (padding == RSA_PKCS1_PSS_PADDING && salt_len.IsJust()) {
      if (EVP_PKEY_CTX_set_rsa_pss_saltlen(pkctx, salt_len.FromJust()) <= 0)
        return false;
    }
  }

  return true;
}",50,,60,5,,void
55135,BLOCK,-1,,"{
    if (EVP_PKEY_CTX_set_rsa_padding(pkctx, padding) <= 0)
      return false;
    if (padding == RSA_PKCS1_PSS_PADDING && salt_len.IsJust()) {
      if (EVP_PKEY_CTX_set_rsa_pss_saltlen(pkctx, salt_len.FromJust()) <= 0)
        return false;
    }
  }",52,,63,2,,void
55142,BLOCK,-1,,<empty>,7,,65,2,,void
55154,BLOCK,-1,,"{
      if (EVP_PKEY_CTX_set_rsa_pss_saltlen(pkctx, salt_len.FromJust()) <= 0)
        return false;
    }",64,,66,2,,void
55164,BLOCK,-1,,<empty>,9,,68,2,,void
55177,BLOCK,-1,,"{
  unsigned char m[EVP_MAX_MD_SIZE];
  unsigned int m_len;

  if (!EVP_DigestFinal_ex(mdctx.get(), m, &m_len))
    return nullptr;

  int signed_sig_len = EVP_PKEY_size(pkey.get());
  CHECK_GE(signed_sig_len, 0);
  size_t sig_len = static_cast<size_t>(signed_sig_len);
  std::unique_ptr<BackingStore> sig;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    sig = ArrayBuffer::NewBackingStore(env->isolate(), sig_len);
  }
  EVPKeyCtxPointer pkctx(EVP_PKEY_CTX_new(pkey.get(), nullptr));
  if (pkctx &&
      EVP_PKEY_sign_init(pkctx.get()) &&
      ApplyRSAOptions(pkey, pkctx.get(), padding, pss_salt_len) &&
      EVP_PKEY_CTX_set_signature_md(pkctx.get(), EVP_MD_CTX_md(mdctx.get())) &&
      EVP_PKEY_sign(pkctx.get(), static_cast<unsigned char*>(sig->Data()),
                    &sig_len, m, m_len)) {
    CHECK_LE(sig_len, sig->ByteLength());
    if (sig_len == 0)
      sig = ArrayBuffer::NewBackingStore(env->isolate(), 0);
    else
      sig = BackingStore:...",71,,79,6,,void
55190,BLOCK,-1,,<empty>,5,,84,2,,void
55217,BLOCK,10,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    sig = ArrayBuffer::NewBackingStore(env->isolate(), sig_len);
  }",3,,90,10,,void
55287,BLOCK,-1,,"{
    CHECK_LE(sig_len, sig->ByteLength());
    if (sig_len == 0)
      sig = ArrayBuffer::NewBackingStore(env->isolate(), 0);
    else
      sig = BackingStore::Reallocate(env->isolate(), std::move(sig), sig_len);
    return sig;
  }",42,,100,2,,void
55298,BLOCK,-1,,<empty>,7,,103,2,,void
55311,BLOCK,-1,,<empty>,7,,105,1,,void
55336,BLOCK,-1,,"{
  return EVP_PKEY_id(m_pkey.get()) == EVP_PKEY_RSA_PSS ? RSA_PKCS1_PSS_PADDING :
                                                         RSA_PKCS1_PADDING;
}",57,,112,2,,void
55352,BLOCK,-1,,"{
  int bits, base_id = EVP_PKEY_base_id(pkey.get());

  if (base_id == EVP_PKEY_DSA) {
    const DSA* dsa_key = EVP_PKEY_get0_DSA(pkey.get());
    // Both r and s are computed mod q, so their width is limited by that of q.
    bits = BN_num_bits(DSA_get0_q(dsa_key));
  } else if (base_id == EVP_PKEY_EC) {
    const EC_KEY* ec_key = EVP_PKEY_get0_EC_KEY(pkey.get());
    const EC_GROUP* ec_group = EC_KEY_get0_group(ec_key);
    bits = EC_GROUP_order_bits(ec_group);
  } else {
    return kNoDsaSignature;
  }

  return (bits + 7) / 8;
}",55,,117,2,,void
55366,BLOCK,-1,,"{
    const DSA* dsa_key = EVP_PKEY_get0_DSA(pkey.get());
    // Both r and s are computed mod q, so their width is limited by that of q.
    bits = BN_num_bits(DSA_get0_q(dsa_key));
  }",32,,120,2,,void
55381,BLOCK,-1,,<empty>,10,,124,1,,void
55386,BLOCK,-1,,"{
    const EC_KEY* ec_key = EVP_PKEY_get0_EC_KEY(pkey.get());
    const EC_GROUP* ec_group = EC_KEY_get0_group(ec_key);
    bits = EC_GROUP_order_bits(ec_group);
  }",38,,124,2,,void
55405,BLOCK,-1,,"{
    return kNoDsaSignature;
  }",10,,128,1,,void
55421,BLOCK,-1,,"{
  ECDSASigPointer asn1_sig(d2i_ECDSA_SIG(nullptr, &sig_data, len));
  if (!asn1_sig)
    return false;

  const BIGNUM* pr = ECDSA_SIG_get0_r(asn1_sig.get());
  const BIGNUM* ps = ECDSA_SIG_get0_s(asn1_sig.get());

  return BN_bn2binpad(pr, out, n) > 0 && BN_bn2binpad(ps, out + n, n) > 0;
}",15,,139,5,,void
55432,BLOCK,-1,,<empty>,5,,142,2,,void
55473,BLOCK,-1,,"{
  unsigned int n = GetBytesOfRS(pkey);
  if (n == kNoDsaSignature)
    return std::move(signature);

  std::unique_ptr<BackingStore> buf;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    buf = ArrayBuffer::NewBackingStore(env->isolate(), 2 * n);
  }
  if (!ExtractP1363(static_cast<unsigned char*>(signature->Data()),
                    static_cast<unsigned char*>(buf->Data()),
                    signature->ByteLength(), n))
    return std::move(signature);

  return buf;
}",76,,152,4,,void
55483,BLOCK,-1,,<empty>,5,,155,2,,void
55497,BLOCK,5,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    buf = ArrayBuffer::NewBackingStore(env->isolate(), 2 * n);
  }",3,,158,5,,void
55537,BLOCK,-1,,<empty>,5,,165,2,,void
55552,BLOCK,-1,,"{
  unsigned int n = GetBytesOfRS(pkey);
  if (n == kNoDsaSignature)
    return ByteSource();

  const unsigned char* sig_data = signature.data<unsigned char>();

  ByteSource::Builder out(n * 2);
  memset(out.data<void>(), 0, n * 2);

  if (!ExtractP1363(sig_data, out.data<unsigned char>(), signature.size(), n))
    return ByteSource();

  return std::move(out).release();
}",34,,174,4,,void
55562,BLOCK,-1,,<empty>,5,,177,2,,void
55599,BLOCK,-1,,<empty>,5,,185,2,,void
55616,BLOCK,-1,,"{
  unsigned int n = GetBytesOfRS(pkey);
  if (n == kNoDsaSignature)
    return std::move(out);

  const unsigned char* sig_data = out.data<unsigned char>();

  if (out.size() != 2 * n)
    return ByteSource();

  ECDSASigPointer asn1_sig(ECDSA_SIG_new());
  CHECK(asn1_sig);
  BIGNUM* r = BN_new();
  CHECK_NOT_NULL(r);
  BIGNUM* s = BN_new();
  CHECK_NOT_NULL(s);
  CHECK_EQ(r, BN_bin2bn(sig_data, n, r));
  CHECK_EQ(s, BN_bin2bn(sig_data + n, n, s));
  CHECK_EQ(1, ECDSA_SIG_set0(asn1_sig.get(), r, s));

  unsigned char* data = nullptr;
  int len = i2d_ECDSA_SIG(asn1_sig.get(), &data);

  if (len <= 0)
    return ByteSource();

  CHECK_NOT_NULL(data);

  return ByteSource::Allocated(data, len);
}",25,,192,3,,void
55626,BLOCK,-1,,<empty>,5,,195,2,,void
55649,BLOCK,-1,,<empty>,5,,200,2,,void
55710,BLOCK,-1,,<empty>,5,,216,2,,void
55727,BLOCK,-1,,"{
  HandleScope scope(env->isolate());

  switch (error) {
    case SignBase::Error::kSignUnknownDigest:
      return THROW_ERR_CRYPTO_INVALID_DIGEST(env);

    case SignBase::Error::kSignNotInitialised:
      return THROW_ERR_CRYPTO_INVALID_STATE(env, ""Not initialised"");

    case SignBase::Error::kSignMalformedSignature:
      return THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""Malformed signature"");

    case SignBase::Error::kSignInit:
    case SignBase::Error::kSignUpdate:
    case SignBase::Error::kSignPrivateKey:
    case SignBase::Error::kSignPublicKey:
      {
        unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
        if (err)
          return ThrowCryptoError(env, err);
        switch (error) {
          case SignBase::Error::kSignInit:
            return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                ""EVP_SignInit_ex failed"");
          case SignBase::Error::kSignUpdate:
            return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                ""EVP_Si...",58,,223,3,,void
55736,BLOCK,-1,,"{
    case SignBase::Error::kSignUnknownDigest:
      return THROW_ERR_CRYPTO_INVALID_DIGEST(env);

    case SignBase::Error::kSignNotInitialised:
      return THROW_ERR_CRYPTO_INVALID_STATE(env, ""Not initialised"");

    case SignBase::Error::kSignMalformedSignature:
      return THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""Malformed signature"");

    case SignBase::Error::kSignInit:
    case SignBase::Error::kSignUpdate:
    case SignBase::Error::kSignPrivateKey:
    case SignBase::Error::kSignPublicKey:
      {
        unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
        if (err)
          return ThrowCryptoError(env, err);
        switch (error) {
          case SignBase::Error::kSignInit:
            return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                ""EVP_SignInit_ex failed"");
          case SignBase::Error::kSignUpdate:
            return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                ""EVP_SignUpdate failed"");
          case SignBase::Error::kSignP...",18,,226,2,,void
55790,BLOCK,18,,"{
        unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
        if (err)
          return ThrowCryptoError(env, err);
        switch (error) {
          case SignBase::Error::kSignInit:
            return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                ""EVP_SignInit_ex failed"");
          case SignBase::Error::kSignUpdate:
            return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                ""EVP_SignUpdate failed"");
          case SignBase::Error::kSignPrivateKey:
            return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                ""PEM_read_bio_PrivateKey failed"");
          case SignBase::Error::kSignPublicKey:
            return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                ""PEM_read_bio_PUBKEY failed"");
          default:
            ABORT();
        }
      }",7,,240,18,,void
55797,BLOCK,-1,,<empty>,11,,243,2,,void
55804,BLOCK,-1,,"{
          case SignBase::Error::kSignInit:
            return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                ""EVP_SignInit_ex failed"");
          case SignBase::Error::kSignUpdate:
            return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                ""EVP_SignUpdate failed"");
          case SignBase::Error::kSignPrivateKey:
            return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                ""PEM_read_bio_PrivateKey failed"");
          case SignBase::Error::kSignPublicKey:
            return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                ""PEM_read_bio_PUBKEY failed"");
          default:
            ABORT();
        }",24,,244,2,,void
55858,BLOCK,-1,,"{
  switch (EVP_PKEY_id(key.get())) {
    case EVP_PKEY_ED25519:
    case EVP_PKEY_ED448:
      return true;
    default:
      return false;
  }
}",43,,267,2,,void
55865,BLOCK,-1,,"{
    case EVP_PKEY_ED25519:
    case EVP_PKEY_ED448:
      return true;
    default:
      return false;
  }",35,,268,2,,void
55880,BLOCK,-1,,"{
  switch (EVP_PKEY_id(key.get())) {
    case EVP_PKEY_EC:
    case EVP_PKEY_DSA:
      return dsa_encoding == kSigEncP1363;
    default:
      return false;
  }
}",54,,278,3,,void
55887,BLOCK,-1,,"{
    case EVP_PKEY_EC:
    case EVP_PKEY_DSA:
      return dsa_encoding == kSigEncP1363;
    default:
      return false;
  }",35,,279,2,,void
55903,BLOCK,-1,,"{
  CHECK_NULL(mdctx_);
  // Historically, ""dss1"" and ""DSS1"" were DSA aliases for SHA-1
  // exposed through the public API.
  if (strcmp(sign_type, ""dss1"") == 0 ||
      strcmp(sign_type, ""DSS1"") == 0) {
    sign_type = ""SHA1"";
  }
  const EVP_MD* md = EVP_get_digestbyname(sign_type);
  if (md == nullptr)
    return kSignUnknownDigest;

  mdctx_.reset(EVP_MD_CTX_new());
  if (!mdctx_ || !EVP_DigestInit_ex(mdctx_.get(), md, nullptr)) {
    mdctx_.reset();
    return kSignInit;
  }

  return kSignOk;
}",55,,289,2,,void
55917,BLOCK,-1,,"{
    sign_type = ""SHA1"";
  }",39,,294,2,,void
55930,BLOCK,-1,,<empty>,5,,299,2,,void
55950,BLOCK,-1,,"{
    mdctx_.reset();
    return kSignInit;
  }",65,,302,2,,void
55964,BLOCK,-1,,"{
  if (mdctx_ == nullptr)
    return kSignNotInitialised;
  if (!EVP_DigestUpdate(mdctx_.get(), data, len))
    return kSignUpdate;
  return kSignOk;
}",64,,310,3,,void
55969,BLOCK,-1,,<empty>,5,,312,2,,void
55981,BLOCK,-1,,<empty>,5,,314,2,,void
55991,BLOCK,-1,,<empty>,29,,319,3,,void
55996,BLOCK,-1,,"{
  tracker->TrackFieldWithSize(""mdctx"", mdctx_ ? kSizeOf_EVP_MD_CTX : 0);
}",57,,321,2,,void
56011,BLOCK,-1,,"{
  MakeWeak();
}",72,,325,3,,void
56018,BLOCK,-1,,"{
  Isolate* isolate = env->isolate();
  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);

  t->InstanceTemplate()->SetInternalFieldCount(SignBase::kInternalFieldCount);

  SetProtoMethod(isolate, t, ""init"", SignInit);
  SetProtoMethod(isolate, t, ""update"", SignUpdate);
  SetProtoMethod(isolate, t, ""sign"", SignFinal);

  SetConstructorFunction(env->context(), target, ""Sign"", t);

  SignJob::Initialize(env, target);

  constexpr int kSignJobModeSign = SignConfiguration::kSign;
  constexpr int kSignJobModeVerify = SignConfiguration::kVerify;

  NODE_DEFINE_CONSTANT(target, kSignJobModeSign);
  NODE_DEFINE_CONSTANT(target, kSignJobModeVerify);
  NODE_DEFINE_CONSTANT(target, kSigEncDER);
  NODE_DEFINE_CONSTANT(target, kSigEncP1363);
  NODE_DEFINE_CONSTANT(target, RSA_PKCS1_PSS_PADDING);
}",63,,329,3,,void
56105,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(SignInit);
  registry->Register(SignUpdate);
  registry->Register(SignFinal);
  SignJob::RegisterExternalReferences(registry);
}",76,,353,2,,void
56135,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  new Sign(env, args.This());
}",57,,361,2,,void
56155,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Sign* sign;
  ASSIGN_OR_RETURN_UNWRAP(&sign, args.Holder());

  const node::Utf8Value sign_type(args.GetIsolate(), args[0]);
  crypto::CheckThrow(env, sign->Init(*sign_type));
}",62,,366,2,,void
56195,BLOCK,-1,,"{
  Decode<Sign>(args, [](Sign* sign, const FunctionCallbackInfo<Value>& args,
                        const char* data, size_t size) {
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    Error err = sign->Update(data, size);
    crypto::CheckThrow(sign->env(), err);
  });
}",64,,375,2,,void
56211,BLOCK,-1,,"{
  if (!mdctx_)
    return SignResult(kSignNotInitialised);

  EVPMDPointer mdctx = std::move(mdctx_);

  if (!ValidateDSAParameters(pkey.get()))
    return SignResult(kSignPrivateKey);

  std::unique_ptr<BackingStore> buffer =
      Node_SignFinal(env(), std::move(mdctx), pkey, padding, salt_len);
  Error error = buffer ? kSignOk : kSignPrivateKey;
  if (error == kSignOk && dsa_sig_enc == kSigEncP1363) {
    buffer = ConvertSignatureToP1363(env(), pkey, std::move(buffer));
    CHECK_NOT_NULL(buffer->Data());
  }
  return SignResult(error, std::move(buffer));
}",28,,390,5,,void
56215,BLOCK,-1,,<empty>,5,,392,2,,void
56234,BLOCK,-1,,<empty>,5,,397,2,,void
56271,BLOCK,-1,,"{
    buffer = ConvertSignatureToP1363(env(), pkey, std::move(buffer));
    CHECK_NOT_NULL(buffer->Data());
  }",56,,402,2,,void
56299,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Sign* sign;
  ASSIGN_OR_RETURN_UNWRAP(&sign, args.Holder());

  ClearErrorOnReturn clear_error_on_return;

  unsigned int offset = 0;
  ManagedEVPPKey key = ManagedEVPPKey::GetPrivateKeyFromJs(args, &offset, true);
  if (!key)
    return;

  int padding = GetDefaultSignPadding(key);
  if (!args[offset]->IsUndefined()) {
    CHECK(args[offset]->IsInt32());
    padding = args[offset].As<Int32>()->Value();
  }

  Maybe<int> salt_len = Nothing<int>();
  if (!args[offset + 1]->IsUndefined()) {
    CHECK(args[offset + 1]->IsInt32());
    salt_len = Just<int>(args[offset + 1].As<Int32>()->Value());
  }

  CHECK(args[offset + 2]->IsInt32());
  DSASigEnc dsa_sig_enc =
      static_cast<DSASigEnc>(args[offset + 2].As<Int32>()->Value());

  SignResult ret = sign->SignFinal(
      key,
      padding,
      salt_len,
      dsa_sig_enc);

  if (ret.error != kSignOk)
    return crypto::CheckThrow(env, ret.error);

  Local<ArrayBuffer> ab =
  ...",63,,409,2,,void
56335,BLOCK,-1,,<empty>,5,,419,2,,void
56350,BLOCK,-1,,"{
    CHECK(args[offset]->IsInt32());
    padding = args[offset].As<Int32>()->Value();
  }",37,,422,2,,void
56383,BLOCK,-1,,"{
    CHECK(args[offset + 1]->IsInt32());
    salt_len = Just<int>(args[offset + 1].As<Int32>()->Value());
  }",41,,428,2,,void
56449,BLOCK,-1,,<empty>,5,,444,2,,void
56507,BLOCK,-1,,"{
  MakeWeak();
}",25,,453,3,,void
56514,BLOCK,-1,,"{
  Isolate* isolate = env->isolate();
  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);

  t->InstanceTemplate()->SetInternalFieldCount(SignBase::kInternalFieldCount);

  SetProtoMethod(isolate, t, ""init"", VerifyInit);
  SetProtoMethod(isolate, t, ""update"", VerifyUpdate);
  SetProtoMethod(isolate, t, ""verify"", VerifyFinal);

  SetConstructorFunction(env->context(), target, ""Verify"", t);
}",65,,457,3,,void
56568,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(VerifyInit);
  registry->Register(VerifyUpdate);
  registry->Register(VerifyFinal);
}",78,,470,2,,void
56593,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  new Verify(env, args.This());
}",59,,477,2,,void
56613,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Verify* verify;
  ASSIGN_OR_RETURN_UNWRAP(&verify, args.Holder());

  const node::Utf8Value verify_type(args.GetIsolate(), args[0]);
  crypto::CheckThrow(env, verify->Init(*verify_type));
}",66,,482,2,,void
56653,BLOCK,-1,,"{
  Decode<Verify>(args, [](Verify* verify,
                          const FunctionCallbackInfo<Value>& args,
                          const char* data, size_t size) {
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    Error err = verify->Update(data, size);
    crypto::CheckThrow(verify->env(), err);
  });
}",68,,491,2,,void
56670,BLOCK,-1,,"{
  if (!mdctx_)
    return kSignNotInitialised;

  unsigned char m[EVP_MAX_MD_SIZE];
  unsigned int m_len;
  *verify_result = false;
  EVPMDPointer mdctx = std::move(mdctx_);

  if (!EVP_DigestFinal_ex(mdctx.get(), m, &m_len))
    return kSignPublicKey;

  EVPKeyCtxPointer pkctx(EVP_PKEY_CTX_new(pkey.get(), nullptr));
  if (pkctx &&
      EVP_PKEY_verify_init(pkctx.get()) > 0 &&
      ApplyRSAOptions(pkey, pkctx.get(), padding, saltlen) &&
      EVP_PKEY_CTX_set_signature_md(pkctx.get(),
                                    EVP_MD_CTX_md(mdctx.get())) > 0) {
    const unsigned char* s = sig.data<unsigned char>();
    const int r = EVP_PKEY_verify(pkctx.get(), s, sig.size(), m, m_len);
    *verify_result = r == 1;
  }

  return kSignOk;
}",58,,507,6,,void
56674,BLOCK,-1,,<empty>,5,,509,2,,void
56701,BLOCK,-1,,<empty>,5,,517,2,,void
56744,BLOCK,-1,,"{
    const unsigned char* s = sig.data<unsigned char>();
    const int r = EVP_PKEY_verify(pkctx.get(), s, sig.size(), m, m_len);
    *verify_result = r == 1;
  }",70,,524,2,,void
56779,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  ClearErrorOnReturn clear_error_on_return;

  Verify* verify;
  ASSIGN_OR_RETURN_UNWRAP(&verify, args.Holder());

  unsigned int offset = 0;
  ManagedEVPPKey pkey =
      ManagedEVPPKey::GetPublicOrPrivateKeyFromJs(args, &offset);
  if (!pkey)
    return;

  ArrayBufferOrViewContents<char> hbuf(args[offset]);
  if (UNLIKELY(!hbuf.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""buffer is too big"");

  int padding = GetDefaultSignPadding(pkey);
  if (!args[offset + 1]->IsUndefined()) {
    CHECK(args[offset + 1]->IsInt32());
    padding = args[offset + 1].As<Int32>()->Value();
  }

  Maybe<int> salt_len = Nothing<int>();
  if (!args[offset + 2]->IsUndefined()) {
    CHECK(args[offset + 2]->IsInt32());
    salt_len = Just<int>(args[offset + 2].As<Int32>()->Value());
  }

  CHECK(args[offset + 3]->IsInt32());
  DSASigEnc dsa_sig_enc =
      static_cast<DSASigEnc>(args[offset + 3].As<Int32>()->Value());

  ByteSource signa...",67,,533,2,,void
56814,BLOCK,-1,,<empty>,5,,544,2,,void
56828,BLOCK,-1,,<empty>,5,,548,2,,void
56848,BLOCK,-1,,"{
    CHECK(args[offset + 1]->IsInt32());
    padding = args[offset + 1].As<Int32>()->Value();
  }",41,,551,2,,void
56885,BLOCK,-1,,"{
    CHECK(args[offset + 2]->IsInt32());
    salt_len = Just<int>(args[offset + 2].As<Int32>()->Value());
  }",41,,557,2,,void
56945,BLOCK,-1,,"{
    signature = ConvertSignatureToDER(pkey, hbuf.ToByteSource());
    if (signature.data() == nullptr)
      return crypto::CheckThrow(env, Error::kSignMalformedSignature);
  }",36,,567,2,,void
56961,BLOCK,-1,,<empty>,7,,570,2,,void
56989,BLOCK,-1,,<empty>,5,,577,2,,void
57009,BLOCK,-1,,<empty>,40,,591,2,,void
57014,BLOCK,-1,,"{
  if (&other == this) return *this;
  this->~SignConfiguration();
  return *new (this) SignConfiguration(std::move(other));
}",41,,594,2,,void
57020,BLOCK,-1,,<empty>,23,,595,2,,void
57042,BLOCK,-1,,"{
  tracker->TrackField(""key"", key);
  if (job_mode == kCryptoJobAsync) {
    tracker->TrackFieldWithSize(""data"", data.size());
    tracker->TrackFieldWithSize(""signature"", signature.size());
  }
}",66,,600,2,,void
57053,BLOCK,-1,,"{
    tracker->TrackFieldWithSize(""data"", data.size());
    tracker->TrackFieldWithSize(""signature"", signature.size());
  }",36,,602,2,,void
57079,BLOCK,-1,,"{
  ClearErrorOnReturn clear_error_on_return;
  Environment* env = Environment::GetCurrent(args);

  params->job_mode = mode;

  CHECK(args[offset]->IsUint32());  // Sign Mode

  params->mode =
      static_cast<SignConfiguration::Mode>(args[offset].As<Uint32>()->Value());

  ManagedEVPPKey key;
  unsigned int keyParamOffset = offset + 1;
  if (params->mode == SignConfiguration::kVerify) {
    key = ManagedEVPPKey::GetPublicOrPrivateKeyFromJs(args, &keyParamOffset);
  } else {
    key = ManagedEVPPKey::GetPrivateKeyFromJs(args, &keyParamOffset, true);
  }
  if (!key)
    return Nothing<bool>();
  params->key = key;

  ArrayBufferOrViewContents<char> data(args[offset + 5]);
  if (UNLIKELY(!data.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""data is too big"");
    return Nothing<bool>();
  }
  params->data = mode == kCryptoJobAsync
      ? data.ToCopy()
      : data.ToByteSource();

  if (args[offset + 6]->IsString()) {
    Utf8Value digest(env->isolate(), args[offset + 6]);
  ...",32,,612,5,,void
57131,BLOCK,-1,,"{
    key = ManagedEVPPKey::GetPublicOrPrivateKeyFromJs(args, &keyParamOffset);
  }",51,,625,2,,void
57142,BLOCK,-1,,"{
    key = ManagedEVPPKey::GetPrivateKeyFromJs(args, &keyParamOffset, true);
  }",10,,627,1,,void
57156,BLOCK,-1,,<empty>,5,,631,2,,void
57178,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""data is too big"");
    return Nothing<bool>();
  }",41,,635,2,,void
57209,BLOCK,-1,,"{
    Utf8Value digest(env->isolate(), args[offset + 6]);
    params->digest = EVP_get_digestbyname(*digest);
    if (params->digest == nullptr) {
      THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
      return Nothing<bool>();
    }
  }",37,,643,2,,void
57234,BLOCK,-1,,"{
      THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
      return Nothing<bool>();
    }",36,,646,2,,void
57251,BLOCK,-1,,"{  // Salt length
    params->flags |= SignConfiguration::kHasSaltLength;
    params->salt_length = args[offset + 7].As<Int32>()->Value();
  }",36,,652,2,,void
57283,BLOCK,-1,,"{  // Padding
    params->flags |= SignConfiguration::kHasPadding;
    params->padding = args[offset + 8].As<Uint32>()->Value();
  }",37,,656,2,,void
57315,BLOCK,-1,,"{  // DSA Encoding
    params->dsa_encoding =
        static_cast<DSASigEnc>(args[offset + 9].As<Uint32>()->Value());
    if (params->dsa_encoding != kSigEncDER &&
        params->dsa_encoding != kSigEncP1363) {
      THROW_ERR_OUT_OF_RANGE(env, ""invalid signature encoding"");
      return Nothing<bool>();
    }
  }",37,,661,2,,void
57345,BLOCK,-1,,"{
      THROW_ERR_OUT_OF_RANGE(env, ""invalid signature encoding"");
      return Nothing<bool>();
    }",47,,665,2,,void
57359,BLOCK,-1,,"{
    ArrayBufferOrViewContents<char> signature(args[offset + 10]);
    if (UNLIKELY(!signature.CheckSizeInt32())) {
      THROW_ERR_OUT_OF_RANGE(env, ""signature is too big"");
      return Nothing<bool>();
    }
    // If this is an EC key (assuming ECDSA) we need to convert the
    // the signature from WebCrypto format into DER format...
    ManagedEVPPKey m_pkey = params->key;
    Mutex::ScopedLock lock(*m_pkey.mutex());
    if (UseP1363Encoding(m_pkey, params->dsa_encoding)) {
      params->signature =
          ConvertSignatureToDER(m_pkey, signature.ToByteSource());
    } else {
      params->signature = mode == kCryptoJobAsync
          ? signature.ToCopy()
          : signature.ToByteSource();
    }
  }",51,,671,2,,void
57374,BLOCK,-1,,"{
      THROW_ERR_OUT_OF_RANGE(env, ""signature is too big"");
      return Nothing<bool>();
    }",48,,673,2,,void
57399,BLOCK,-1,,"{
      params->signature =
          ConvertSignatureToDER(m_pkey, signature.ToByteSource());
    }",57,,681,2,,void
57411,BLOCK,-1,,"{
      params->signature = mode == kCryptoJobAsync
          ? signature.ToCopy()
          : signature.ToByteSource();
    }",12,,684,1,,void
57437,BLOCK,-1,,"{
  ClearErrorOnReturn clear_error_on_return;
  EVPMDPointer context(EVP_MD_CTX_new());
  EVP_PKEY_CTX* ctx = nullptr;

  switch (params.mode) {
    case SignConfiguration::kSign:
      if (!EVP_DigestSignInit(
              context.get(),
              &ctx,
              params.digest,
              nullptr,
              params.key.get())) {
        crypto::CheckThrow(env, SignBase::Error::kSignInit);
        return false;
      }
      break;
    case SignConfiguration::kVerify:
      if (!EVP_DigestVerifyInit(
              context.get(),
              &ctx,
              params.digest,
              nullptr,
              params.key.get())) {
        crypto::CheckThrow(env, SignBase::Error::kSignInit);
        return false;
      }
      break;
  }

  int padding = params.flags & SignConfiguration::kHasPadding
      ? params.padding
      : GetDefaultSignPadding(params.key);

  Maybe<int> salt_length = params.flags & SignConfiguration::kHasSaltLength
      ? Just<int>(params.s...",22,,697,4,,void
57450,BLOCK,-1,,"{
    case SignConfiguration::kSign:
      if (!EVP_DigestSignInit(
              context.get(),
              &ctx,
              params.digest,
              nullptr,
              params.key.get())) {
        crypto::CheckThrow(env, SignBase::Error::kSignInit);
        return false;
      }
      break;
    case SignConfiguration::kVerify:
      if (!EVP_DigestVerifyInit(
              context.get(),
              &ctx,
              params.digest,
              nullptr,
              params.key.get())) {
        crypto::CheckThrow(env, SignBase::Error::kSignInit);
        return false;
      }
      break;
  }",24,,702,2,,void
57474,BLOCK,-1,,"{
        crypto::CheckThrow(env, SignBase::Error::kSignInit);
        return false;
      }",34,,709,2,,void
57511,BLOCK,-1,,"{
        crypto::CheckThrow(env, SignBase::Error::kSignInit);
        return false;
      }",34,,720,2,,void
57568,BLOCK,-1,,"{
    crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
    return false;
  }",25,,738,2,,void
57585,BLOCK,-1,,"{
    case SignConfiguration::kSign: {
      if (IsOneShot(params.key)) {
        size_t len;
        if (!EVP_DigestSign(
            context.get(),
            nullptr,
            &len,
            params.data.data<unsigned char>(),
            params.data.size())) {
          crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
          return false;
        }
        ByteSource::Builder buf(len);
        if (!EVP_DigestSign(context.get(),
                            buf.data<unsigned char>(),
                            &len,
                            params.data.data<unsigned char>(),
                            params.data.size())) {
          crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
          return false;
        }
        *out = std::move(buf).release(len);
      } else {
        size_t len;
        if (!EVP_DigestSignUpdate(
                context.get(),
                params.data.data<unsigned char>(),
                params.data.size()) ||
 ...",24,,743,2,,void
57590,BLOCK,3,,"{
      if (IsOneShot(params.key)) {
        size_t len;
        if (!EVP_DigestSign(
            context.get(),
            nullptr,
            &len,
            params.data.data<unsigned char>(),
            params.data.size())) {
          crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
          return false;
        }
        ByteSource::Builder buf(len);
        if (!EVP_DigestSign(context.get(),
                            buf.data<unsigned char>(),
                            &len,
                            params.data.data<unsigned char>(),
                            params.data.size())) {
          crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
          return false;
        }
        *out = std::move(buf).release(len);
      } else {
        size_t len;
        if (!EVP_DigestSignUpdate(
                context.get(),
                params.data.data<unsigned char>(),
                params.data.size()) ||
            !EVP_DigestSignFinal(conte...",36,,744,3,,void
57596,BLOCK,-1,,"{
        size_t len;
        if (!EVP_DigestSign(
            context.get(),
            nullptr,
            &len,
            params.data.data<unsigned char>(),
            params.data.size())) {
          crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
          return false;
        }
        ByteSource::Builder buf(len);
        if (!EVP_DigestSign(context.get(),
                            buf.data<unsigned char>(),
                            &len,
                            params.data.data<unsigned char>(),
                            params.data.size())) {
          crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
          return false;
        }
        *out = std::move(buf).release(len);
      }",34,,745,2,,void
57620,BLOCK,-1,,"{
          crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
          return false;
        }",34,,752,2,,void
57661,BLOCK,-1,,"{
          crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
          return false;
        }",50,,761,2,,void
57687,BLOCK,-1,,"{
        size_t len;
        if (!EVP_DigestSignUpdate(
                context.get(),
                params.data.data<unsigned char>(),
                params.data.size()) ||
            !EVP_DigestSignFinal(context.get(), nullptr, &len)) {
          crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
          return false;
        }
        ByteSource::Builder buf(len);
        if (!EVP_DigestSignFinal(
                context.get(), buf.data<unsigned char>(), &len)) {
          crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
          return false;
        }

        if (UseP1363Encoding(params.key, params.dsa_encoding)) {
          *out = ConvertSignatureToP1363(
              env, params.key, std::move(buf).release());
        } else {
          *out = std::move(buf).release(len);
        }
      }",14,,766,1,,void
57718,BLOCK,-1,,"{
          crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
          return false;
        }",65,,772,2,,void
57747,BLOCK,-1,,"{
          crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
          return false;
        }",66,,778,2,,void
57768,BLOCK,-1,,"{
          *out = ConvertSignatureToP1363(
              env, params.key, std::move(buf).release());
        }",64,,783,2,,void
57786,BLOCK,-1,,"{
          *out = std::move(buf).release(len);
        }",16,,786,1,,void
57804,BLOCK,6,,"{
      ByteSource::Builder buf(1);
      buf.data<char>()[0] = 0;
      if (EVP_DigestVerify(
              context.get(),
              params.signature.data<unsigned char>(),
              params.signature.size(),
              params.data.data<unsigned char>(),
              params.data.size()) == 1) {
        buf.data<char>()[0] = 1;
      }
      *out = std::move(buf).release();
    }",38,,792,6,,void
57848,BLOCK,-1,,"{
        buf.data<char>()[0] = 1;
      }",41,,800,2,,void
57877,BLOCK,-1,,"{
  switch (params.mode) {
    case SignConfiguration::kSign:
      *result = out->ToArrayBuffer(env);
      break;
    case SignConfiguration::kVerify:
      *result = Boolean::New(env->isolate(), out->data<char>()[0] == 1);
      break;
    default:
      UNREACHABLE();
  }
  return Just(!result->IsEmpty());
}",27,,814,5,,void
57882,BLOCK,-1,,"{
    case SignConfiguration::kSign:
      *result = out->ToArrayBuffer(env);
      break;
    case SignConfiguration::kVerify:
      *result = Boolean::New(env->isolate(), out->data<char>()[0] == 1);
      break;
    default:
      UNREACHABLE();
  }",24,,815,2,,void
57945,BLOCK,-1,,<empty>,1,,1,1,,ANY
57964,BLOCK,-1,,<empty>,1,,1,1,,ANY
57970,BLOCK,-1,,"{
  size_t length = input.size();
#ifdef OPENSSL_IS_BORINGSSL
  // OpenSSL uses EVP_DecodeBlock, which explicitly removes trailing characters,
  // while BoringSSL uses EVP_DecodedLength and EVP_DecodeBase64, which do not.
  // As such, we trim those characters here for compatibility.
  length = std::string(input.data()).find_last_not_of("" \n\r\t"") + 1;
#endif
  NetscapeSPKIPointer spki(
      NETSCAPE_SPKI_b64_decode(input.data(), length));
  if (!spki)
    return false;

  EVPKeyPointer pkey(X509_PUBKEY_get(spki->spkac->pubkey));
  if (!pkey)
    return false;

  return NETSCAPE_SPKI_verify(spki.get(), pkey.get()) > 0;
}",64,,19,2,,void
57989,BLOCK,-1,,<empty>,5,,30,2,,void
58003,BLOCK,-1,,<empty>,5,,34,2,,void
58022,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  ArrayBufferOrViewContents<char> input(args[0]);
  if (input.size() == 0)
    return args.GetReturnValue().SetEmptyString();

  if (UNLIKELY(!input.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""spkac is too large"");

  args.GetReturnValue().Set(VerifySpkac(input));
}",59,,39,2,,void
58043,BLOCK,-1,,<empty>,5,,43,2,,void
58059,BLOCK,-1,,<empty>,5,,46,2,,void
58078,BLOCK,-1,,"{
  BIOPointer bio(BIO_new(BIO_s_mem()));
  if (!bio) return ByteSource();

  size_t length = input.size();
#ifdef OPENSSL_IS_BORINGSSL
  // OpenSSL uses EVP_DecodeBlock, which explicitly removes trailing characters,
  // while BoringSSL uses EVP_DecodedLength and EVP_DecodeBase64, which do not.
  // As such, we trim those characters here for compatibility.
  length = std::string(input.data()).find_last_not_of("" \n\r\t"") + 1;
#endif
  NetscapeSPKIPointer spki(
      NETSCAPE_SPKI_b64_decode(input.data(), length));
  if (!spki) return ByteSource();

  EVPKeyPointer pkey(NETSCAPE_SPKI_get_pubkey(spki.get()));
  if (!pkey) return ByteSource();

  if (PEM_write_bio_PUBKEY(bio.get(), pkey.get()) <= 0) return ByteSource();

  return ByteSource::FromBIO(bio);
}",74,,52,3,,void
58081,BLOCK,-1,,<empty>,,,,2,,<empty>
58087,BLOCK,-1,,<empty>,13,,54,2,,void
58108,BLOCK,-1,,<empty>,14,,65,2,,void
58121,BLOCK,-1,,<empty>,14,,68,2,,void
58136,BLOCK,-1,,<empty>,57,,70,2,,void
58149,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  ArrayBufferOrViewContents<char> input(args[0]);
  if (input.size() == 0) return args.GetReturnValue().SetEmptyString();

  if (UNLIKELY(!input.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""spkac is too large"");

  ByteSource pkey = ExportPublicKey(env, input);
  if (!pkey) return args.GetReturnValue().SetEmptyString();

  args.GetReturnValue().Set(pkey.ToBuffer(env).FromMaybe(Local<Value>()));
}",63,,75,2,,void
58170,BLOCK,-1,,<empty>,26,,79,2,,void
58186,BLOCK,-1,,<empty>,5,,82,2,,void
58200,BLOCK,-1,,<empty>,14,,85,2,,void
58229,BLOCK,-1,,"{
  size_t length = input.size();
#ifdef OPENSSL_IS_BORINGSSL
  // OpenSSL uses EVP_DecodeBlock, which explicitly removes trailing characters,
  // while BoringSSL uses EVP_DecodedLength and EVP_DecodeBase64, which do not.
  // As such, we trim those characters here for compatibility.
  length = std::string(input.data()).find_last_not_of("" \n\r\t"") + 1;
#endif
  NetscapeSPKIPointer sp(
      NETSCAPE_SPKI_b64_decode(input.data(), length));
  if (!sp)
    return ByteSource();

  unsigned char* buf = nullptr;
  int buf_size = ASN1_STRING_to_UTF8(&buf, sp->spkac->challenge);
  return (buf_size >= 0) ? ByteSource::Allocated(buf, buf_size) : ByteSource();
}",74,,90,2,,void
58248,BLOCK,-1,,<empty>,5,,101,2,,void
58282,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  ArrayBufferOrViewContents<char> input(args[0]);
  if (input.size() == 0)
    return args.GetReturnValue().SetEmptyString();

  if (UNLIKELY(!input.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""spkac is too large"");

  ByteSource cert = ExportChallenge(input);
  if (!cert)
    return args.GetReturnValue().SetEmptyString();

  Local<Value> outString =
      Encode(env->isolate(), cert.data<char>(), cert.size(), BUFFER);

  args.GetReturnValue().Set(outString);
}",63,,108,2,,void
58303,BLOCK,-1,,<empty>,5,,113,2,,void
58319,BLOCK,-1,,<empty>,5,,116,2,,void
58332,BLOCK,-1,,<empty>,5,,120,2,,void
58374,BLOCK,-1,,"{
  Local<Context> context = env->context();
  SetMethodNoSideEffect(context, target, ""certVerifySpkac"", VerifySpkac);
  SetMethodNoSideEffect(
      context, target, ""certExportPublicKey"", ExportPublicKey);
  SetMethodNoSideEffect(
      context, target, ""certExportChallenge"", ExportChallenge);
}",57,,128,3,,void
58404,BLOCK,-1,,"{
  registry->Register(VerifySpkac);
  registry->Register(ExportPublicKey);
  registry->Register(ExportChallenge);
}",70,,137,2,,void
58432,BLOCK,-1,,<empty>,1,,1,1,,ANY
58451,BLOCK,-1,,<empty>,1,,1,1,,ANY
58457,BLOCK,-1,,"{
  // Moving the type checking into JS leads to test failures, most likely due
  // to V8 inlining certain parts of the wrapper. Therefore, keep them in C++.
  // Refs: https://github.com/nodejs/node/issues/34073.
  Environment* env = Environment::GetCurrent(args);
  if (!IsAnyByteSource(args[0])) {
    THROW_ERR_INVALID_ARG_TYPE(
      env, ""The \""buf1\"" argument must be an instance of ""
      ""ArrayBuffer, Buffer, TypedArray, or DataView."");
    return;
  }
  if (!IsAnyByteSource(args[1])) {
    THROW_ERR_INVALID_ARG_TYPE(
      env, ""The \""buf2\"" argument must be an instance of ""
      ""ArrayBuffer, Buffer, TypedArray, or DataView."");
    return;
  }

  ArrayBufferOrViewContents<char> buf1(args[0]);
  ArrayBufferOrViewContents<char> buf2(args[1]);

  if (buf1.size() != buf2.size()) {
    THROW_ERR_CRYPTO_TIMING_SAFE_EQUAL_LENGTH(env);
    return;
  }

  return args.GetReturnValue().Set(
      CRYPTO_memcmp(buf1.data(), buf2.data(), buf1.size()) == 0);
}",63,,19,2,,void
58472,BLOCK,-1,,"{
    THROW_ERR_INVALID_ARG_TYPE(
      env, ""The \""buf1\"" argument must be an instance of ""
      ""ArrayBuffer, Buffer, TypedArray, or DataView."");
    return;
  }",34,,24,2,,void
58483,BLOCK,-1,,"{
    THROW_ERR_INVALID_ARG_TYPE(
      env, ""The \""buf2\"" argument must be an instance of ""
      ""ArrayBuffer, Buffer, TypedArray, or DataView."");
    return;
  }",34,,30,2,,void
58508,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_TIMING_SAFE_EQUAL_LENGTH(env);
    return;
  }",35,,40,2,,void
58540,BLOCK,-1,,"{
  SetMethodNoSideEffect(
      env->context(), target, ""timingSafeEqual"", TimingSafeEqual);
}",57,,49,3,,void
58553,BLOCK,-1,,"{
  registry->Register(TimingSafeEqual);
}",70,,53,2,,void
58569,BLOCK,-1,,<empty>,1,,1,1,,ANY
58575,BLOCK,-1,,"{
        static_cast<std::string*>(opaque)->assign(str, len);
        return 0;
      }",53,,309,4,,void
58592,BLOCK,-1,,"{
          InvokeQueued(0);
        }",66,,591,2,,void
58600,BLOCK,-1,,"{
      OnStreamAfterWrite(nullptr, 0);
    }",62,,623,2,,void
58609,BLOCK,-1,,{ return c == ' ' ? '_' : ToUpper(c); },37,,769,2,,void
58623,BLOCK,-1,,"{
          OnStreamAfterWrite(WriteWrap::FromObject(current_empty_write_), 0);
        }",66,,936,2,,void
58642,BLOCK,-1,,"{
        // BIO_write(), etc., called by SSL_trace, may error. The error should
        // be ignored, trace is a ""best effort"", and its usually because stderr
        // is a non-blocking pipe, and its buffer has overflowed. Leaving errors
        // on the stack that can get picked up by later SSL_ calls causes
        // unwanted failures in SSL_ calls, so keep the error stack unchanged.
        MarkPopErrorOnReturn mark_pop_error_on_return;
        SSL_trace(write_p,  version, content_type, buf, len, ssl, arg);
    }",17,,1167,8,,void
58683,BLOCK,-1,,<empty>,1,,1,1,,ANY
58692,BLOCK,-1,,"{
  TLSWrap* w = static_cast<TLSWrap*>(SSL_get_app_data(s));
  *copy = 0;
  return w->ReleaseSession();
}",16,,71,5,,void
58714,BLOCK,-1,,"{
  TLSWrap* w = static_cast<TLSWrap*>(arg);
  Environment* env = w->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Object> hello_obj = Object::New(env->isolate());
  Local<String> servername = (hello.servername() == nullptr)
      ? String::Empty(env->isolate())
      : OneByteString(env->isolate(),
                      hello.servername(),
                      hello.servername_size());
  Local<Object> buf =
      Buffer::Copy(
          env,
          reinterpret_cast<const char*>(hello.session_id()),
          hello.session_size()).FromMaybe(Local<Object>());

  if ((buf.IsEmpty() ||
       hello_obj->Set(env->context(), env->session_id_string(), buf)
           .IsNothing()) ||
      hello_obj->Set(env->context(), env->servername_string(), servername)
          .IsNothing() ||
      hello_obj
          ->Set(env->context(),
                env->tls_ticket_string(),
                Boolean::New(env->isolate(), hello.ha...",50,,79,3,,void
58880,BLOCK,-1,,"{
    return;
  }",25,,106,2,,void
58903,BLOCK,-1,,"{
  TLSWrap* w = static_cast<TLSWrap*>(SSL_get_app_data(s));
  Environment* env = w->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  const size_t size = strlen(line);
  Local<Value> line_bf = Buffer::Copy(env, line, 1 + size)
      .FromMaybe(Local<Value>());
  if (UNLIKELY(line_bf.IsEmpty()))
    return;

  char* data = Buffer::Data(line_bf);
  data[size] = '\n';
  w->MakeCallback(env->onkeylog_string(), 1, &line_bf);
}",53,,114,3,,void
58960,BLOCK,-1,,<empty>,5,,124,2,,void
58991,BLOCK,-1,,"{
  TLSWrap* w = static_cast<TLSWrap*>(SSL_get_app_data(s));
  Environment* env = w->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  if (!w->has_session_callbacks())
    return 0;

  // Check if session is small enough to be stored
  int size = i2d_SSL_SESSION(sess, nullptr);
  if (UNLIKELY(size > SecureContext::kMaxSessionSize))
    return 0;

  // Serialize session
  Local<Object> session = Buffer::New(env, size).FromMaybe(Local<Object>());
  if (UNLIKELY(session.IsEmpty()))
    return 0;

  unsigned char* session_data =
      reinterpret_cast<unsigned char*>(Buffer::Data(session));

  CHECK_EQ(i2d_SSL_SESSION(sess, &session_data), size);

  unsigned int session_id_length;
  const unsigned char* session_id_data =
      SSL_SESSION_get_id(sess, &session_id_length);

  Local<Object> session_id = Buffer::Copy(
      env,
      reinterpret_cast<const char*>(session_id_data),
      session_id_length).FromMaybe(Local<Object>());
  if...",51,,131,3,,void
59024,BLOCK,-1,,<empty>,5,,138,2,,void
59040,BLOCK,-1,,<empty>,5,,143,2,,void
59065,BLOCK,-1,,<empty>,5,,148,2,,void
59117,BLOCK,-1,,<empty>,5,,164,2,,void
59131,BLOCK,-1,,<empty>,5,,174,2,,void
59155,BLOCK,-1,,"{
  TLSWrap* w = static_cast<TLSWrap*>(SSL_get_app_data(s));

  if (!w->is_server() || !w->is_waiting_cert_cb())
    return 1;

  if (w->is_cert_cb_running())
    // Not an error. Suspend handshake with SSL_ERROR_WANT_X509_LOOKUP, and
    // handshake will continue after certcb is done.
    return -1;

  Environment* env = w->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());
  w->set_cert_cb_running();

  Local<Object> info = Object::New(env->isolate());

  const char* servername = GetServerName(s);
  Local<String> servername_str = (servername == nullptr)
      ? String::Empty(env->isolate())
      : OneByteString(env->isolate(), servername, strlen(servername));

  Local<Value> ocsp = Boolean::New(
      env->isolate(), SSL_get_tlsext_status_type(s) == TLSEXT_STATUSTYPE_ocsp);

  if (info->Set(env->context(), env->servername_string(), servername_str)
          .IsNothing() ||
      info->Set(env->context(), env->ocsp_request_string(),...",40,,181,3,,void
59175,BLOCK,-1,,<empty>,5,,185,2,,void
59183,BLOCK,-1,,<empty>,5,,190,2,,void
59307,BLOCK,-1,,"{
    return 1;
  }",80,,209,2,,void
59344,BLOCK,-1,,"{
  TLSWrap* w = static_cast<TLSWrap*>(arg);
  const std::vector<unsigned char>& alpn_protos = w->alpn_protos_;

  if (alpn_protos.empty()) return SSL_TLSEXT_ERR_NOACK;

  int status = SSL_select_next_proto(const_cast<unsigned char**>(out),
                                     outlen,
                                     alpn_protos.data(),
                                     alpn_protos.size(),
                                     in,
                                     inlen);

  // Previous versions of Node.js returned SSL_TLSEXT_ERR_NOACK if no protocol
  // match was found. This would neither cause a fatal alert nor would it result
  // in a useful ALPN response as part of the Server Hello message.
  // We now return SSL_TLSEXT_ERR_ALERT_FATAL in that case as per Section 3.2
  // of RFC 7301, which causes a fatal no_application_protocol alert.
  return status == OPENSSL_NPN_NEGOTIATED ? SSL_TLSEXT_ERR_OK
                                          : SSL_TLSEXT_ERR_ALERT_FATAL;
}",16,,225,7,,void
59362,BLOCK,-1,,<empty>,28,,229,2,,void
59395,BLOCK,-1,,"{
  TLSWrap* w = static_cast<TLSWrap*>(SSL_get_app_data(s));
  Environment* env = w->env();
  HandleScope handle_scope(env->isolate());

  if (w->is_client()) {
    // Incoming response
    Local<Value> arg;
    if (GetSSLOCSPResponse(env, s, Null(env->isolate())).ToLocal(&arg))
      w->MakeCallback(env->onocspresponse_string(), 1, &arg);

    // No async acceptance is possible, so always return 1 to accept the
    // response.  The listener for 'OCSPResponse' event has no control over
    // return value, but it can .destroy() the connection if the response is not
    // acceptable.
    return 1;
  }

  // Outgoing response
  Local<ArrayBufferView> obj =
      w->ocsp_response().FromMaybe(Local<ArrayBufferView>());
  if (UNLIKELY(obj.IsEmpty()))
    return SSL_TLSEXT_ERR_NOACK;

  size_t len = obj->ByteLength();

  // OpenSSL takes control of the pointer after accepting it
  unsigned char* data = MallocOpenSSL<unsigned char>(len);
  obj->CopyContents(data, len);

  if (!SSL_set_tl...",45,,247,3,,void
59421,BLOCK,-1,,"{
    // Incoming response
    Local<Value> arg;
    if (GetSSLOCSPResponse(env, s, Null(env->isolate())).ToLocal(&arg))
      w->MakeCallback(env->onocspresponse_string(), 1, &arg);

    // No async acceptance is possible, so always return 1 to accept the
    // response.  The listener for 'OCSPResponse' event has no control over
    // return value, but it can .destroy() the connection if the response is not
    // acceptable.
    return 1;
  }",23,,252,2,,void
59441,BLOCK,-1,,<empty>,7,,256,2,,void
59475,BLOCK,-1,,<empty>,5,,269,2,,void
59502,BLOCK,-1,,<empty>,5,,278,2,,void
59515,BLOCK,-1,,"{
  // OCSP stapling
  SSL_CTX_set_tlsext_status_cb(sc->ctx().get(), TLSExtStatusCallback);
  SSL_CTX_set_tlsext_status_arg(sc->ctx().get(), nullptr);
}",48,,285,2,,void
59542,BLOCK,-1,,"{
  if (value == nullptr)
    return ignore_null;
  return !target->Set(
      env->context(),
      name,
      OneByteString(env->isolate(), value))
          .IsNothing();
}",30,,296,6,,void
59547,BLOCK,-1,,<empty>,5,,298,2,,void
59573,BLOCK,-1,,"{
  std::string ret;
  ERR_print_errors_cb(
      [](const char* str, size_t len, void* opaque) {
        static_cast<std::string*>(opaque)->assign(str, len);
        return 0;
      },
      static_cast<void*>(&ret));
  return ret;
}",27,,306,1,,void
59591,BLOCK,-1,,"{
  MakeWeak();
  CHECK(sc_);
  ssl_ = sc_->CreateSSL();
  CHECK(ssl_);

  sc_->SetGetSessionCallback(GetSessionCallback);
  sc_->SetNewSessionCallback(NewSessionCallback);

  StreamBase::AttachToObject(GetObject());
  stream->PushStreamListener(this);

  env_->isolate()->AdjustAmountOfExternalAllocatedMemory(kExternalSize);

  InitSSL();
  Debug(this, ""Created new TLSWrap"");
}",15,,327,6,,void
59632,BLOCK,-1,,"{
  Destroy();
}",21,,345,1,,void
59637,BLOCK,-1,,"{
  if (ocsp_response_.IsEmpty())
    return MaybeLocal<ArrayBufferView>();
  return PersistentToLocal::Default(env()->isolate(), ocsp_response_);
}",60,,349,1,,void
59643,BLOCK,-1,,<empty>,5,,351,2,,void
59659,BLOCK,-1,,"{
  ocsp_response_.Reset();
}",35,,355,1,,void
59667,BLOCK,-1,,"{
  return next_sess_.release();
}",40,,359,1,,void
59678,BLOCK,-1,,"{
  Debug(this, ""Invoking queued write callbacks (%d, %s)"", status, error_str);
  if (!write_callback_scheduled_)
    return;

  if (current_write_) {
    BaseObjectPtr<AsyncWrap> current_write = std::move(current_write_);
    current_write_.reset();
    WriteWrap* w = WriteWrap::FromObject(current_write);
    w->Done(status, error_str);
  }
}",63,,363,3,,void
59687,BLOCK,-1,,<empty>,5,,366,2,,void
59691,BLOCK,-1,,"{
    BaseObjectPtr<AsyncWrap> current_write = std::move(current_write_);
    current_write_.reset();
    WriteWrap* w = WriteWrap::FromObject(current_write);
    w->Done(status, error_str);
  }",23,,368,2,,void
59724,BLOCK,-1,,"{
  Debug(this, ""New session callback done"");
  Cycle();
}",34,,376,1,,void
59732,BLOCK,-1,,"{
  // Initialize SSL – OpenSSL takes ownership of these.
  enc_in_ = NodeBIO::New(env()).release();
  enc_out_ = NodeBIO::New(env()).release();

  SSL_set_bio(ssl_.get(), enc_in_, enc_out_);

  // NOTE: This could be overridden in SetVerifyMode
  SSL_set_verify(ssl_.get(), SSL_VERIFY_NONE, VerifyCallback);

#ifdef SSL_MODE_RELEASE_BUFFERS
  SSL_set_mode(ssl_.get(), SSL_MODE_RELEASE_BUFFERS);
#endif  // SSL_MODE_RELEASE_BUFFERS

  // This is default in 1.1.1, but set it anyway, Cycle() doesn't currently
  // re-call ClearIn() if SSL_read() returns SSL_ERROR_WANT_READ, so data can be
  // left sitting in the incoming enc_in_ and never get processed.
  // - https://wiki.openssl.org/index.php/TLS1.3#Non-application_data_records
  SSL_set_mode(ssl_.get(), SSL_MODE_AUTO_RETRY);

#ifdef OPENSSL_IS_BORINGSSL
  // OpenSSL allows renegotiation by default, but BoringSSL disables it.
  // Configure BoringSSL to match OpenSSL's behavior.
  SSL_set_renegotiate_mode(ssl_.get(), ssl_renegotiate_fr...",25,,381,1,,void
59787,BLOCK,-1,,<empty>,5,,416,2,,void
59807,BLOCK,-1,,"{
    SSL_set_accept_state(ssl_.get());
  }",20,,422,2,,void
59814,BLOCK,-1,,<empty>,10,,424,1,,void
59817,BLOCK,-1,,"{
    // Enough space for server response (hello, cert)
    NodeBIO::FromBIO(enc_in_)->set_initial(kInitialClientBufferLength);
    SSL_set_connect_state(ssl_.get());
  }",27,,424,2,,void
59833,BLOCK,-1,,"{
    // Unexpected
    ABORT();
  }",10,,428,1,,void
59839,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK_EQ(args.Length(), 3);
  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsObject());
  CHECK(args[2]->IsBoolean());

  Local<Object> sc = args[1].As<Object>();
  Kind kind = args[2]->IsTrue() ? Kind::kServer : Kind::kClient;

  StreamBase* stream = StreamBase::FromObject(args[0].As<Object>());
  CHECK_NOT_NULL(stream);

  Local<Object> obj;
  if (!env->tls_wrap_constructor_function()
           ->NewInstance(env->context())
           .ToLocal(&obj)) {
    return;
  }

  TLSWrap* res = new TLSWrap(env, obj, kind, stream, Unwrap<SecureContext>(sc));

  args.GetReturnValue().Set(res->object());
}",61,,434,2,,void
59941,BLOCK,-1,,"{
    return;
  }",28,,451,2,,void
59972,BLOCK,-1,,"{
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  ArrayBufferViewContents<char> buffer(args[0]);
  const char* data = buffer.data();
  size_t len = buffer.length();
  Debug(wrap, ""Receiving %zu bytes injected from JS"", len);

  // Copy given buffer entirely or partiall if handle becomes closed
  while (len > 0 && wrap->IsAlive() && !wrap->IsClosing()) {
    uv_buf_t buf = wrap->OnStreamAlloc(len);
    size_t copy = buf.len > len ? len : buf.len;
    memcpy(buf.base, data, copy);
    buf.len = copy;
    wrap->OnStreamRead(copy, buf);

    data += copy;
    len -= copy;
  }
}",64,,460,2,,void
60019,BLOCK,-1,,"{
    uv_buf_t buf = wrap->OnStreamAlloc(len);
    size_t copy = buf.len > len ? len : buf.len;
    memcpy(buf.base, data, copy);
    buf.len = copy;
    wrap->OnStreamRead(copy, buf);

    data += copy;
    len -= copy;
  }",60,,470,2,,void
60068,BLOCK,-1,,"{
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK(!wrap->started_);
  wrap->started_ = true;

  // Send ClientHello handshake
  CHECK(wrap->is_client());
  // Seems odd to read when when we want to send, but SSL_read() triggers a
  // handshake if a session isn't established, and handshake will cause
  // encrypted data to become available for output.
  wrap->ClearOut();
  wrap->EncOut();
}",62,,482,2,,void
60106,BLOCK,-1,,"{
  if (!(where & (SSL_CB_HANDSHAKE_START | SSL_CB_HANDSHAKE_DONE)))
    return;

  // SSL_renegotiate_pending() should take `const SSL*`, but it does not.
  SSL* ssl = const_cast<SSL*>(ssl_);
  TLSWrap* c = static_cast<TLSWrap*>(SSL_get_app_data(ssl_));
  Environment* env = c->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());
  Local<Object> object = c->object();

  if (where & SSL_CB_HANDSHAKE_START) {
    Debug(c, ""SSLInfoCallback(SSL_CB_HANDSHAKE_START);"");
    // Start is tracked to limit number and frequency of renegotiation attempts,
    // since excessive renegotiation may be an attack.
    Local<Value> callback;

    if (object->Get(env->context(), env->onhandshakestart_string())
            .ToLocal(&callback) && callback->IsFunction()) {
      Local<Value> argv[] = { env->GetNow() };
      c->MakeCallback(callback.As<Function>(), arraysize(argv), argv);
    }
  }

  // SSL_CB_HANDSHAKE_START and SSL_CB_HANDSHAKE_DONE are ca...",68,,498,4,,void
60114,BLOCK,-1,,<empty>,5,,500,2,,void
60162,BLOCK,-1,,"{
    Debug(c, ""SSLInfoCallback(SSL_CB_HANDSHAKE_START);"");
    // Start is tracked to limit number and frequency of renegotiation attempts,
    // since excessive renegotiation may be an attack.
    Local<Value> callback;

    if (object->Get(env->context(), env->onhandshakestart_string())
            .ToLocal(&callback) && callback->IsFunction()) {
      Local<Value> argv[] = { env->GetNow() };
      c->MakeCallback(callback.As<Function>(), arraysize(argv), argv);
    }
  }",39,,510,2,,void
60194,BLOCK,-1,,"{
      Local<Value> argv[] = { env->GetNow() };
      c->MakeCallback(callback.As<Function>(), arraysize(argv), argv);
    }",60,,517,2,,void
60222,BLOCK,-1,,"{
    Debug(c, ""SSLInfoCallback(SSL_CB_HANDSHAKE_DONE);"");
    CHECK(!SSL_renegotiate_pending(ssl));
    Local<Value> callback;

    c->established_ = true;

    if (object->Get(env->context(), env->onhandshakedone_string())
          .ToLocal(&callback) && callback->IsFunction()) {
      c->MakeCallback(callback.As<Function>(), 0, nullptr);
    }
  }",71,,526,2,,void
60263,BLOCK,-1,,"{
      c->MakeCallback(callback.As<Function>(), 0, nullptr);
    }",58,,534,2,,void
60277,BLOCK,-1,,"{
  Debug(this, ""Trying to write encrypted output"");

  // Ignore cycling data if ClientHello wasn't yet parsed
  if (!hello_parser_.IsEnded()) {
    Debug(this, ""Returning from EncOut(), hello_parser_ active"");
    return;
  }

  // Write in progress
  if (write_size_ != 0) {
    Debug(this, ""Returning from EncOut(), write currently in progress"");
    return;
  }

  // Wait for `newSession` callback to be invoked
  if (is_awaiting_new_session()) {
    Debug(this, ""Returning from EncOut(), awaiting new session"");
    return;
  }

  // Split-off queue
  if (established_ && current_write_) {
    Debug(this, ""EncOut() write is scheduled"");
    write_callback_scheduled_ = true;
  }

  if (ssl_ == nullptr) {
    Debug(this, ""Returning from EncOut(), ssl_ == nullptr"");
    return;
  }

  // No encrypted output ready to write to the underlying stream.
  if (BIO_pending(enc_out_) == 0) {
    Debug(this, ""No pending encrypted output"");
    if (!pending_cleartext_input_ ||
        pending_cle...",24,,540,1,,void
60287,BLOCK,-1,,"{
    Debug(this, ""Returning from EncOut(), hello_parser_ active"");
    return;
  }",33,,544,2,,void
60296,BLOCK,-1,,"{
    Debug(this, ""Returning from EncOut(), write currently in progress"");
    return;
  }",25,,550,2,,void
60303,BLOCK,-1,,"{
    Debug(this, ""Returning from EncOut(), awaiting new session"");
    return;
  }",34,,556,2,,void
60309,BLOCK,-1,,<empty>,7,,562,1,,void
60311,BLOCK,-1,,"{
    Debug(this, ""EncOut() write is scheduled"");
    write_callback_scheduled_ = true;
  }",39,,562,2,,void
60322,BLOCK,-1,,"{
    Debug(this, ""Returning from EncOut(), ssl_ == nullptr"");
    return;
  }",24,,567,2,,void
60332,BLOCK,-1,,"{
    Debug(this, ""No pending encrypted output"");
    if (!pending_cleartext_input_ ||
        pending_cleartext_input_->ByteLength() == 0) {
      if (!in_dowrite_) {
        Debug(this, ""No pending cleartext input, not inside DoWrite()"");
        InvokeQueued(0);
      } else {
        Debug(this, ""No pending cleartext input, inside DoWrite()"");
        // TODO(@sam-github, @addaleax) If in_dowrite_ is true, appdata was
        // passed to SSL_write().  If we are here, the data was not encrypted to
        // enc_out_ yet.  Calling Done() ""works"", but since the write is not
        // flushed, its too soon.  Just returning and letting the next EncOut()
        // call Done() passes the test suite, but without more careful analysis,
        // its not clear if it is always correct. Not calling Done() could block
        // data flow, so for now continue to call Done(), just do it in the next
        // tick.
        BaseObjectPtr<TLSWrap> strong_ref{this};
        env()->SetImmedi...",35,,573,2,,void
60346,BLOCK,-1,,"{
      if (!in_dowrite_) {
        Debug(this, ""No pending cleartext input, not inside DoWrite()"");
        InvokeQueued(0);
      } else {
        Debug(this, ""No pending cleartext input, inside DoWrite()"");
        // TODO(@sam-github, @addaleax) If in_dowrite_ is true, appdata was
        // passed to SSL_write().  If we are here, the data was not encrypted to
        // enc_out_ yet.  Calling Done() ""works"", but since the write is not
        // flushed, its too soon.  Just returning and letting the next EncOut()
        // call Done() passes the test suite, but without more careful analysis,
        // its not clear if it is always correct. Not calling Done() could block
        // data flow, so for now continue to call Done(), just do it in the next
        // tick.
        BaseObjectPtr<TLSWrap> strong_ref{this};
        env()->SetImmediate([this, strong_ref](Environment* env) {
          InvokeQueued(0);
        });
      }
    }",54,,576,2,,void
60350,BLOCK,-1,,"{
        Debug(this, ""No pending cleartext input, not inside DoWrite()"");
        InvokeQueued(0);
      }",25,,577,2,,void
60357,BLOCK,-1,,"{
        Debug(this, ""No pending cleartext input, inside DoWrite()"");
        // TODO(@sam-github, @addaleax) If in_dowrite_ is true, appdata was
        // passed to SSL_write().  If we are here, the data was not encrypted to
        // enc_out_ yet.  Calling Done() ""works"", but since the write is not
        // flushed, its too soon.  Just returning and letting the next EncOut()
        // call Done() passes the test suite, but without more careful analysis,
        // its not clear if it is always correct. Not calling Done() could block
        // data flow, so for now continue to call Done(), just do it in the next
        // tick.
        BaseObjectPtr<TLSWrap> strong_ref{this};
        env()->SetImmediate([this, strong_ref](Environment* env) {
          InvokeQueued(0);
        });
      }",14,,580,1,,void
60409,BLOCK,-1,,<empty>,3,,607,1,,void
60449,BLOCK,-1,,"{
    InvokeQueued(res.err);
    return;
  }",21,,612,2,,void
60460,BLOCK,-1,,"{
    Debug(this, ""Write finished synchronously"");
    HandleScope handle_scope(env()->isolate());

    // Simulate asynchronous finishing, TLS cannot handle this at the moment.
    BaseObjectPtr<TLSWrap> strong_ref{this};
    env()->SetImmediate([this, strong_ref](Environment* env) {
      OnStreamAfterWrite(nullptr, 0);
    });
  }",19,,617,2,,void
60487,BLOCK,-1,,"{
  Debug(this, ""OnStreamAfterWrite(status = %d)"", status);
  if (current_empty_write_) {
    Debug(this, ""Had empty write"");
    BaseObjectPtr<AsyncWrap> current_empty_write =
        std::move(current_empty_write_);
    current_empty_write_.reset();
    WriteWrap* finishing = WriteWrap::FromObject(current_empty_write);
    finishing->Done(status);
    return;
  }

  if (ssl_ == nullptr) {
    Debug(this, ""ssl_ == nullptr, marking as cancelled"");
    status = UV_ECANCELED;
  }

  // Handle error
  if (status) {
    if (shutdown_) {
      Debug(this, ""Ignoring error after shutdown"");
      return;
    }

    // Notify about error
    InvokeQueued(status);
    return;
  }

  // Commit
  NodeBIO::FromBIO(enc_out_)->Read(nullptr, write_size_);

  // Ensure that the progress will be made and `InvokeQueued` will be called.
  ClearIn();

  // Try writing more data
  write_size_ = 0;
  EncOut();
}",67,,629,3,,void
60494,BLOCK,-1,,"{
    Debug(this, ""Had empty write"");
    BaseObjectPtr<AsyncWrap> current_empty_write =
        std::move(current_empty_write_);
    current_empty_write_.reset();
    WriteWrap* finishing = WriteWrap::FromObject(current_empty_write);
    finishing->Done(status);
    return;
  }",29,,631,2,,void
60531,BLOCK,-1,,"{
    Debug(this, ""ssl_ == nullptr, marking as cancelled"");
    status = UV_ECANCELED;
  }",24,,641,2,,void
60540,BLOCK,-1,,"{
    if (shutdown_) {
      Debug(this, ""Ignoring error after shutdown"");
      return;
    }

    // Notify about error
    InvokeQueued(status);
    return;
  }",15,,647,2,,void
60543,BLOCK,-1,,"{
      Debug(this, ""Ignoring error after shutdown"");
      return;
    }",20,,648,2,,void
60569,BLOCK,-1,,"{
  Debug(this, ""Trying to read cleartext output"");
  // Ignore cycling data if ClientHello wasn't yet parsed
  if (!hello_parser_.IsEnded()) {
    Debug(this, ""Returning from ClearOut(), hello_parser_ active"");
    return;
  }

  // No reads after EOF
  if (eof_) {
    Debug(this, ""Returning from ClearOut(), EOF reached"");
    return;
  }

  if (ssl_ == nullptr) {
    Debug(this, ""Returning from ClearOut(), ssl_ == nullptr"");
    return;
  }

  MarkPopErrorOnReturn mark_pop_error_on_return;

  char out[kClearOutChunkSize];
  int read;
  for (;;) {
    read = SSL_read(ssl_.get(), out, sizeof(out));
    Debug(this, ""Read %d bytes of cleartext output"", read);

    if (read <= 0)
      break;

    char* current = out;
    while (read > 0) {
      int avail = read;

      uv_buf_t buf = EmitAlloc(avail);
      if (static_cast<int>(buf.len) < avail)
        avail = buf.len;
      memcpy(buf.base, current, avail);
      EmitRead(avail, buf);

      // Caveat emptor: OnRead() calls into JS...",26,,669,1,,void
60579,BLOCK,-1,,"{
    Debug(this, ""Returning from ClearOut(), hello_parser_ active"");
    return;
  }",33,,672,2,,void
60586,BLOCK,-1,,"{
    Debug(this, ""Returning from ClearOut(), EOF reached"");
    return;
  }",13,,678,2,,void
60595,BLOCK,-1,,"{
    Debug(this, ""Returning from ClearOut(), ssl_ == nullptr"");
    return;
  }",24,,683,2,,void
60604,BLOCK,-1,,<empty>,3,,692,1,,void
60605,BLOCK,4,,"{
    read = SSL_read(ssl_.get(), out, sizeof(out));
    Debug(this, ""Read %d bytes of cleartext output"", read);

    if (read <= 0)
      break;

    char* current = out;
    while (read > 0) {
      int avail = read;

      uv_buf_t buf = EmitAlloc(avail);
      if (static_cast<int>(buf.len) < avail)
        avail = buf.len;
      memcpy(buf.base, current, avail);
      EmitRead(avail, buf);

      // Caveat emptor: OnRead() calls into JS land which can result in
      // the SSL context object being destroyed.  We have to carefully
      // check that ssl_ != nullptr afterwards.
      if (ssl_ == nullptr) {
        Debug(this, ""Returning from read loop, ssl_ == nullptr"");
        return;
      }

      read -= avail;
      current += avail;
    }
  }",12,,692,4,,void
60624,BLOCK,-1,,<empty>,7,,697,2,,void
60634,BLOCK,-1,,"{
      int avail = read;

      uv_buf_t buf = EmitAlloc(avail);
      if (static_cast<int>(buf.len) < avail)
        avail = buf.len;
      memcpy(buf.base, current, avail);
      EmitRead(avail, buf);

      // Caveat emptor: OnRead() calls into JS land which can result in
      // the SSL context object being destroyed.  We have to carefully
      // check that ssl_ != nullptr afterwards.
      if (ssl_ == nullptr) {
        Debug(this, ""Returning from read loop, ssl_ == nullptr"");
        return;
      }

      read -= avail;
      current += avail;
    }",22,,700,2,,void
60652,BLOCK,-1,,<empty>,9,,705,2,,void
60671,BLOCK,-1,,"{
        Debug(this, ""Returning from read loop, ssl_ == nullptr"");
        return;
      }",28,,712,2,,void
60686,BLOCK,-1,,"{
    HandleScope handle_scope(env()->isolate());
    Local<Value> error;
    int err = SSL_get_error(ssl_.get(), read);
    switch (err) {
      case SSL_ERROR_ZERO_RETURN:
        if (!eof_) {
          eof_ = true;
          EmitRead(UV_EOF);
        }
        return;

      case SSL_ERROR_SSL:
      case SSL_ERROR_SYSCALL:
        {
          unsigned long ssl_err = ERR_peek_error();  // NOLINT(runtime/int)

          Local<Context> context = env()->isolate()->GetCurrentContext();
          if (UNLIKELY(context.IsEmpty())) return;
          const std::string error_str = GetBIOError();
          Local<String> message = OneByteString(
              env()->isolate(), error_str.c_str(), error_str.size());
          if (UNLIKELY(message.IsEmpty())) return;
          error = Exception::Error(message);
          if (UNLIKELY(error.IsEmpty())) return;
          Local<Object> obj;
          if (UNLIKELY(!error->ToObject(context).ToLocal(&obj))) return;

          const char* ls = ERR_lib...",18,,728,2,,void
60709,BLOCK,-1,,"{
      case SSL_ERROR_ZERO_RETURN:
        if (!eof_) {
          eof_ = true;
          EmitRead(UV_EOF);
        }
        return;

      case SSL_ERROR_SSL:
      case SSL_ERROR_SYSCALL:
        {
          unsigned long ssl_err = ERR_peek_error();  // NOLINT(runtime/int)

          Local<Context> context = env()->isolate()->GetCurrentContext();
          if (UNLIKELY(context.IsEmpty())) return;
          const std::string error_str = GetBIOError();
          Local<String> message = OneByteString(
              env()->isolate(), error_str.c_str(), error_str.size());
          if (UNLIKELY(message.IsEmpty())) return;
          error = Exception::Error(message);
          if (UNLIKELY(error.IsEmpty())) return;
          Local<Object> obj;
          if (UNLIKELY(!error->ToObject(context).ToLocal(&obj))) return;

          const char* ls = ERR_lib_error_string(ssl_err);
          const char* fs = ERR_func_error_string(ssl_err);
          const char* rs = ERR_reason_error_string(ssl_...",18,,732,2,,void
60715,BLOCK,-1,,"{
          eof_ = true;
          EmitRead(UV_EOF);
        }",20,,734,2,,void
60725,BLOCK,9,,"{
          unsigned long ssl_err = ERR_peek_error();  // NOLINT(runtime/int)

          Local<Context> context = env()->isolate()->GetCurrentContext();
          if (UNLIKELY(context.IsEmpty())) return;
          const std::string error_str = GetBIOError();
          Local<String> message = OneByteString(
              env()->isolate(), error_str.c_str(), error_str.size());
          if (UNLIKELY(message.IsEmpty())) return;
          error = Exception::Error(message);
          if (UNLIKELY(error.IsEmpty())) return;
          Local<Object> obj;
          if (UNLIKELY(!error->ToObject(context).ToLocal(&obj))) return;

          const char* ls = ERR_lib_error_string(ssl_err);
          const char* fs = ERR_func_error_string(ssl_err);
          const char* rs = ERR_reason_error_string(ssl_err);
          if (!Set(env(), obj, env()->library_string(), ls) ||
              !Set(env(), obj, env()->function_string(), fs) ||
              !Set(env(), obj, env()->reason_string(), rs, false))...",9,,742,9,,void
60749,BLOCK,-1,,<empty>,44,,746,2,,void
60780,BLOCK,-1,,<empty>,44,,750,2,,void
60795,BLOCK,-1,,<empty>,42,,752,2,,void
60815,BLOCK,-1,,<empty>,66,,754,2,,void
60863,BLOCK,-1,,<empty>,68,,761,2,,void
60900,BLOCK,-1,,<empty>,72,,771,2,,void
60914,BLOCK,-1,,<empty>,7,,783,2,,void
60927,BLOCK,-1,,"{
  Debug(this, ""Trying to write cleartext input"");
  // Ignore cycling data if ClientHello wasn't yet parsed
  if (!hello_parser_.IsEnded()) {
    Debug(this, ""Returning from ClearIn(), hello_parser_ active"");
    return;
  }

  if (ssl_ == nullptr) {
    Debug(this, ""Returning from ClearIn(), ssl_ == nullptr"");
    return;
  }

  if (!pending_cleartext_input_ ||
      pending_cleartext_input_->ByteLength() == 0) {
    Debug(this, ""Returning from ClearIn(), no pending data"");
    return;
  }

  std::unique_ptr<BackingStore> bs = std::move(pending_cleartext_input_);
  MarkPopErrorOnReturn mark_pop_error_on_return;

  NodeBIO::FromBIO(enc_out_)->set_allocate_tls_hint(bs->ByteLength());
  int written = SSL_write(ssl_.get(), bs->Data(), bs->ByteLength());
  Debug(this, ""Writing %zu bytes, written = %d"", bs->ByteLength(), written);
  CHECK(written == -1 || written == static_cast<int>(bs->ByteLength()));

  // All written
  if (written != -1) {
    Debug(this, ""Successfully wrote all dat...",25,,789,1,,void
60937,BLOCK,-1,,"{
    Debug(this, ""Returning from ClearIn(), hello_parser_ active"");
    return;
  }",33,,792,2,,void
60946,BLOCK,-1,,"{
    Debug(this, ""Returning from ClearIn(), ssl_ == nullptr"");
    return;
  }",24,,797,2,,void
60961,BLOCK,-1,,"{
    Debug(this, ""Returning from ClearIn(), no pending data"");
    return;
  }",52,,803,2,,void
61035,BLOCK,-1,,"{
    Debug(this, ""Successfully wrote all data to SSL"");
    return;
  }",22,,817,2,,void
61057,BLOCK,-1,,"{
    Debug(this, ""Got SSL error (%d)"", err);
    write_callback_scheduled_ = true;
    // TODO(@sam-github) Should forward an error object with
    // .code/.function/.etc, if possible.
    InvokeQueued(UV_EPROTO, GetBIOError().c_str());
    return;
  }",57,,824,2,,void
61085,BLOCK,-1,,"{
  std::string name = ""TLSWrap "";
  name += is_server() ? ""server ("" : ""client ("";
  name += std::to_string(static_cast<int64_t>(get_async_id())) + "")"";
  return name;
}",46,,839,1,,void
61112,BLOCK,-1,,"{
  return static_cast<AsyncWrap*>(this);
}",36,,846,1,,void
61120,BLOCK,-1,,"{
  return underlying_stream()->IsIPCPipe();
}",27,,850,1,,void
61129,BLOCK,-1,,"{
  return underlying_stream()->GetFD();
}",22,,854,1,,void
61138,BLOCK,-1,,"{
  return ssl_ &&
      underlying_stream() != nullptr &&
      underlying_stream()->IsAlive();
}",25,,858,1,,void
61153,BLOCK,-1,,"{
  return underlying_stream()->IsClosing();
}",27,,864,1,,void
61162,BLOCK,-1,,"{
  Debug(this, ""ReadStart()"");
  if (underlying_stream() != nullptr && !eof_)
    return underlying_stream()->ReadStart();
  return 0;
}",26,,868,1,,void
61173,BLOCK,-1,,<empty>,5,,871,2,,void
61184,BLOCK,-1,,"{
  Debug(this, ""ReadStop()"");
  return underlying_stream() != nullptr ? underlying_stream()->ReadStop() : 0;
}",25,,875,1,,void
61201,BLOCK,-1,,"{
  return error_.empty() ? nullptr : error_.c_str();
}",36,,880,1,,void
61216,BLOCK,-1,,"{
  error_.clear();
}",28,,884,1,,void
61228,BLOCK,-1,,"{
  CHECK_NULL(send_handle);
  Debug(this, ""DoWrite()"");

  if (ssl_ == nullptr) {
    ClearError();
    error_ = ""Write after DestroySSL"";
    return UV_EPROTO;
  }

  size_t length = 0;
  size_t i;
  size_t nonempty_i = 0;
  size_t nonempty_count = 0;
  for (i = 0; i < count; i++) {
    length += bufs[i].len;
    if (bufs[i].len > 0) {
      nonempty_i = i;
      nonempty_count += 1;
    }
  }

  // We want to trigger a Write() on the underlying stream to drive the stream
  // system, but don't want to encrypt empty buffers into a TLS frame, so see
  // if we can find something to Write().
  // First, call ClearOut(). It does an SSL_read(), which might cause handshake
  // or other internal messages to be encrypted. If it does, write them later
  // with EncOut().
  // If there is still no encrypted output, call Write(bufs) on the underlying
  // stream. Since the bufs are empty, it won't actually write non-TLS data
  // onto the socket, we just want the side-effects. After, make ...",48,,893,5,,void
61238,BLOCK,-1,,"{
    ClearError();
    error_ = ""Write after DestroySSL"";
    return UV_EPROTO;
  }",24,,897,2,,void
61259,BLOCK,-1,,<empty>,3,,907,1,,void
61268,BLOCK,4,,"{
    length += bufs[i].len;
    if (bufs[i].len > 0) {
      nonempty_i = i;
      nonempty_count += 1;
    }
  }",31,,907,4,,void
61284,BLOCK,-1,,"{
      nonempty_i = i;
      nonempty_count += 1;
    }",26,,909,2,,void
61295,BLOCK,-1,,"{
    Debug(this, ""Empty write"");
    ClearOut();
    if (BIO_pending(enc_out_) == 0) {
      Debug(this, ""No pending encrypted output, writing to underlying stream"");
      CHECK(!current_empty_write_);
      current_empty_write_.reset(w->GetAsyncWrap());
      StreamWriteResult res =
          underlying_stream()->Write(bufs, count, send_handle);
      if (!res.async) {
        BaseObjectPtr<TLSWrap> strong_ref{this};
        env()->SetImmediate([this, strong_ref](Environment* env) {
          OnStreamAfterWrite(WriteWrap::FromObject(current_empty_write_), 0);
        });
      }
      return 0;
    }
  }",20,,925,2,,void
61305,BLOCK,-1,,"{
      Debug(this, ""No pending encrypted output, writing to underlying stream"");
      CHECK(!current_empty_write_);
      current_empty_write_.reset(w->GetAsyncWrap());
      StreamWriteResult res =
          underlying_stream()->Write(bufs, count, send_handle);
      if (!res.async) {
        BaseObjectPtr<TLSWrap> strong_ref{this};
        env()->SetImmediate([this, strong_ref](Environment* env) {
          OnStreamAfterWrite(WriteWrap::FromObject(current_empty_write_), 0);
        });
      }
      return 0;
    }",37,,928,2,,void
61335,BLOCK,-1,,"{
        BaseObjectPtr<TLSWrap> strong_ref{this};
        env()->SetImmediate([this, strong_ref](Environment* env) {
          OnStreamAfterWrite(WriteWrap::FromObject(current_empty_write_), 0);
        });
      }",23,,934,2,,void
61365,BLOCK,-1,,"{
    EncOut();
    return 0;
  }",20,,949,2,,void
61385,BLOCK,-1,,"{
    {
      NoArrayBufferZeroFillScope no_zero_fill_scope(env()->isolate_data());
      bs = ArrayBuffer::NewBackingStore(env()->isolate(), length);
    }
    size_t offset = 0;
    for (i = 0; i < count; i++) {
      memcpy(static_cast<char*>(bs->Data()) + offset,
             bufs[i].base, bufs[i].len);
      offset += bufs[i].len;
    }

    NodeBIO::FromBIO(enc_out_)->set_allocate_tls_hint(length);
    written = SSL_write(ssl_.get(), bs->Data(), length);
  }",28,,967,2,,void
61386,BLOCK,1,,"{
      NoArrayBufferZeroFillScope no_zero_fill_scope(env()->isolate_data());
      bs = ArrayBuffer::NewBackingStore(env()->isolate(), length);
    }",5,,968,1,,void
61409,BLOCK,-1,,<empty>,5,,973,1,,void
61418,BLOCK,4,,"{
      memcpy(static_cast<char*>(bs->Data()) + offset,
             bufs[i].base, bufs[i].len);
      offset += bufs[i].len;
    }",33,,973,4,,void
61467,BLOCK,-1,,"{
    // Only one buffer: try to write directly, only store if it fails
    uv_buf_t* buf = &bufs[nonempty_i];
    NodeBIO::FromBIO(enc_out_)->set_allocate_tls_hint(buf->len);
    written = SSL_write(ssl_.get(), buf->base, buf->len);

    if (written == -1) {
      NoArrayBufferZeroFillScope no_zero_fill_scope(env()->isolate_data());
      bs = ArrayBuffer::NewBackingStore(env()->isolate(), length);
      memcpy(bs->Data(), buf->base, buf->len);
    }
  }",10,,981,1,,void
61504,BLOCK,-1,,"{
      NoArrayBufferZeroFillScope no_zero_fill_scope(env()->isolate_data());
      bs = ArrayBuffer::NewBackingStore(env()->isolate(), length);
      memcpy(bs->Data(), buf->base, buf->len);
    }",24,,987,2,,void
61554,BLOCK,-1,,"{
    // If we stopped writing because of an error, it's fatal, discard the data.
    int err = SSL_get_error(ssl_.get(), written);
    if (err == SSL_ERROR_SSL || err == SSL_ERROR_SYSCALL) {
      // TODO(@jasnell): What are we doing with the error?
      Debug(this, ""Got SSL error (%d), returning UV_EPROTO"", err);
      current_write_.reset();
      return UV_EPROTO;
    }

    Debug(this, ""Saving data for later write"");
    // Otherwise, save unwritten data so it can be written later by ClearIn().
    CHECK(!pending_cleartext_input_ ||
          pending_cleartext_input_->ByteLength() == 0);
    pending_cleartext_input_ = std::move(bs);
  }",22,,997,2,,void
61572,BLOCK,-1,,"{
      // TODO(@jasnell): What are we doing with the error?
      Debug(this, ""Got SSL error (%d), returning UV_EPROTO"", err);
      current_write_.reset();
      return UV_EPROTO;
    }",59,,1000,2,,void
61616,BLOCK,-1,,"{
  CHECK_NOT_NULL(ssl_);

  size_t size = suggested_size;
  char* base = NodeBIO::FromBIO(enc_in_)->PeekWritable(&size);
  return uv_buf_init(base, size);
}",56,,1023,2,,void
61644,BLOCK,-1,,"{
  Debug(this, ""Read %zd bytes from underlying stream"", nread);

  // Ignore everything after close_notify (rfc5246#section-7.2.1)
  if (eof_)
    return;

  if (nread < 0)  {
    // Error should be emitted only after all data was read
    ClearOut();

    if (nread == UV_EOF) {
      // underlying stream already should have also called ReadStop on itself
      eof_ = true;
    }

    EmitRead(nread);
    return;
  }

  // DestroySSL() is the only thing that un-sets ssl_, but that also removes
  // this TLSWrap as a stream listener, so we should not receive OnStreamRead()
  // calls anymore.
  CHECK(ssl_);

  // Commit the amount of data actually read into the peeked/allocated buffer
  // from the underlying stream.
  NodeBIO* enc_in = NodeBIO::FromBIO(enc_in_);
  enc_in->Commit(nread);

  // Parse ClientHello first, if we need to. It's only parsed if session event
  // listeners are used on the server side.  ""ended"" is the initial state, so
  // can mean parsing was never started,...",64,,1031,3,,void
61651,BLOCK,-1,,<empty>,5,,1036,2,,void
61657,BLOCK,-1,,"{
    // Error should be emitted only after all data was read
    ClearOut();

    if (nread == UV_EOF) {
      // underlying stream already should have also called ReadStop on itself
      eof_ = true;
    }

    EmitRead(nread);
    return;
  }",19,,1038,2,,void
61663,BLOCK,-1,,"{
      // underlying stream already should have also called ReadStop on itself
      eof_ = true;
    }",26,,1042,2,,void
61690,BLOCK,-1,,"{
    size_t avail = 0;
    uint8_t* data = reinterpret_cast<uint8_t*>(enc_in->Peek(&avail));
    CHECK_IMPLIES(data == nullptr, avail == 0);
    Debug(this, ""Passing %zu bytes to the hello parser"", avail);
    return hello_parser_.Parse(data, avail);
  }",33,,1065,2,,void
61729,BLOCK,-1,,"{
  return underlying_stream()->CreateShutdownWrap(req_wrap_object);
}",74,,1077,2,,void
61740,BLOCK,-1,,"{
  Debug(this, ""DoShutdown()"");
  MarkPopErrorOnReturn mark_pop_error_on_return;

  if (ssl_ && SSL_shutdown(ssl_.get()) == 0)
    SSL_shutdown(ssl_.get());

  shutdown_ = true;
  EncOut();
  return underlying_stream()->DoShutdown(req_wrap);
}",49,,1081,2,,void
61755,BLOCK,-1,,<empty>,5,,1086,2,,void
61775,BLOCK,-1,,"{
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK_EQ(args.Length(), 2);
  CHECK(args[0]->IsBoolean());
  CHECK(args[1]->IsBoolean());
  CHECK_NOT_NULL(wrap->ssl_);

  int verify_mode;
  if (wrap->is_server()) {
    bool request_cert = args[0]->IsTrue();
    if (!request_cert) {
      // If no cert is requested, there will be none to reject as unauthorized.
      verify_mode = SSL_VERIFY_NONE;
    } else {
      bool reject_unauthorized = args[1]->IsTrue();
      verify_mode = SSL_VERIFY_PEER;
      if (reject_unauthorized)
        verify_mode |= SSL_VERIFY_FAIL_IF_NO_PEER_CERT;
    }
  } else {
    // Servers always send a cert if the cipher is not anonymous (anon is
    // disabled by default), so use VERIFY_NONE and check the cert after the
    // handshake has completed.
    verify_mode = SSL_VERIFY_NONE;
  }

  // Always allow a connection. We'll reject in javascript.
  SSL_set_verify(wrap->ssl_.get(), verify_mode, VerifyCallback);
}",70,,1093,2,,void
61814,BLOCK,-1,,"{
    bool request_cert = args[0]->IsTrue();
    if (!request_cert) {
      // If no cert is requested, there will be none to reject as unauthorized.
      verify_mode = SSL_VERIFY_NONE;
    } else {
      bool reject_unauthorized = args[1]->IsTrue();
      verify_mode = SSL_VERIFY_PEER;
      if (reject_unauthorized)
        verify_mode |= SSL_VERIFY_FAIL_IF_NO_PEER_CERT;
    }
  }",26,,1103,2,,void
61827,BLOCK,-1,,"{
      // If no cert is requested, there will be none to reject as unauthorized.
      verify_mode = SSL_VERIFY_NONE;
    }",24,,1105,2,,void
61832,BLOCK,-1,,"{
      bool reject_unauthorized = args[1]->IsTrue();
      verify_mode = SSL_VERIFY_PEER;
      if (reject_unauthorized)
        verify_mode |= SSL_VERIFY_FAIL_IF_NO_PEER_CERT;
    }",12,,1108,1,,void
61847,BLOCK,-1,,<empty>,9,,1112,2,,void
61852,BLOCK,-1,,"{
    // Servers always send a cert if the cipher is not anonymous (anon is
    // disabled by default), so use VERIFY_NONE and check the cert after the
    // handshake has completed.
    verify_mode = SSL_VERIFY_NONE;
  }",10,,1114,1,,void
61869,BLOCK,-1,,"{
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  CHECK_NOT_NULL(wrap->ssl_);
  wrap->enable_session_callbacks();

  // Clients don't use the HelloParser.
  if (wrap->is_client())
    return;

  NodeBIO::FromBIO(wrap->enc_in_)->set_initial(kMaxHelloLength);
  wrap->hello_parser_.Start(OnClientHello,
                            OnClientHelloParseEnd,
                            wrap);
}",79,,1125,2,,void
61891,BLOCK,-1,,<empty>,5,,1133,2,,void
61917,BLOCK,-1,,"{
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  CHECK(wrap->sc_);
  wrap->sc_->SetKeylogCallback(KeylogCallback);
}",77,,1141,2,,void
61941,BLOCK,-1,,"{
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

#if HAVE_SSL_TRACE
  if (wrap->ssl_) {
    wrap->bio_trace_.reset(BIO_new_fp(stderr,  BIO_NOCLOSE | BIO_FP_TEXT));
    SSL_set_msg_callback(wrap->ssl_.get(), [](int write_p, int version, int
          content_type, const void* buf, size_t len, SSL* ssl, void* arg)
        -> void {
        // BIO_write(), etc., called by SSL_trace, may error. The error should
        // be ignored, trace is a ""best effort"", and its usually because stderr
        // is a non-blocking pipe, and its buffer has overflowed. Leaving errors
        // on the stack that can get picked up by later SSL_ calls causes
        // unwanted failures in SSL_ calls, so keep the error stack unchanged.
        MarkPopErrorOnReturn mark_pop_error_on_return;
        SSL_trace(write_p,  version, content_type, buf, len, ssl, arg);
    });
    SSL_set_msg_callback_arg(wrap->ssl_.get(), wrap->bio_trace_.get());
  }
#endif
}",68,,1158,2,,void
61954,BLOCK,-1,,"{
    wrap->bio_trace_.reset(BIO_new_fp(stderr,  BIO_NOCLOSE | BIO_FP_TEXT));
    SSL_set_msg_callback(wrap->ssl_.get(), [](int write_p, int version, int
          content_type, const void* buf, size_t len, SSL* ssl, void* arg)
        -> void {
        // BIO_write(), etc., called by SSL_trace, may error. The error should
        // be ignored, trace is a ""best effort"", and its usually because stderr
        // is a non-blocking pipe, and its buffer has overflowed. Leaving errors
        // on the stack that can get picked up by later SSL_ calls causes
        // unwanted failures in SSL_ calls, so keep the error stack unchanged.
        MarkPopErrorOnReturn mark_pop_error_on_return;
        SSL_trace(write_p,  version, content_type, buf, len, ssl, arg);
    });
    SSL_set_msg_callback_arg(wrap->ssl_.get(), wrap->bio_trace_.get());
  }",19,,1163,2,,void
61991,BLOCK,-1,,"{
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  wrap->Destroy();
  Debug(wrap, ""DestroySSL() finished"");
}",67,,1181,2,,void
62010,BLOCK,-1,,"{
  if (!ssl_)
    return;

  // If there is a write happening, mark it as finished.
  write_callback_scheduled_ = true;

  // And destroy
  InvokeQueued(UV_ECANCELED, ""Canceled because of SSL destruction"");

  env()->isolate()->AdjustAmountOfExternalAllocatedMemory(-kExternalSize);
  ssl_.reset();

  enc_in_ = nullptr;
  enc_out_ = nullptr;

  if (underlying_stream() != nullptr)
    underlying_stream()->RemoveStreamListener(this);

  sc_.reset();
}",25,,1188,1,,void
62014,BLOCK,-1,,<empty>,5,,1190,2,,void
62045,BLOCK,-1,,<empty>,5,,1205,2,,void
62059,BLOCK,-1,,"{
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  wrap->WaitForCertCb(OnClientHelloParseEnd, wrap);
}",69,,1210,2,,void
62079,BLOCK,-1,,"{
  cert_cb_ = cb;
  cert_cb_arg_ = arg;
}",51,,1216,3,,void
62090,BLOCK,-1,,"{
  TLSWrap* c = static_cast<TLSWrap*>(arg);
  Debug(c, ""OnClientHelloParseEnd()"");
  c->Cycle();
}",48,,1221,2,,void
62108,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK_NOT_NULL(wrap->ssl_);

  const char* servername = GetServerName(wrap->ssl_.get());
  if (servername != nullptr) {
    args.GetReturnValue().Set(OneByteString(env->isolate(), servername));
  } else {
    args.GetReturnValue().Set(false);
  }
}",70,,1227,2,,void
62143,BLOCK,-1,,"{
    args.GetReturnValue().Set(OneByteString(env->isolate(), servername));
  }",30,,1236,2,,void
62158,BLOCK,-1,,"{
    args.GetReturnValue().Set(false);
  }",10,,1238,1,,void
62171,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());
  CHECK(!wrap->started_);
  CHECK(wrap->is_client());

  CHECK(wrap->ssl_);

  Utf8Value servername(env->isolate(), args[0].As<String>());
  SSL_set_tlsext_host_name(wrap->ssl_.get(), *servername);
}",70,,1243,2,,void
62242,BLOCK,-1,,"{
  TLSWrap* p = static_cast<TLSWrap*>(SSL_get_app_data(s));
  Environment* env = p->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  const char* servername = GetServerName(s);
  if (!Set(env, p->GetOwner(), env->servername_string(), servername))
    return SSL_TLSEXT_ERR_NOACK;

  Local<Value> ctx = p->object()->Get(env->context(), env->sni_context_string())
      .FromMaybe(Local<Value>());

  if (UNLIKELY(ctx.IsEmpty()) || !ctx->IsObject())
    return SSL_TLSEXT_ERR_NOACK;

  if (!env->secure_context_constructor_template()->HasInstance(ctx)) {
    // Failure: incorrect SNI context object
    Local<Value> err = Exception::TypeError(env->sni_context_err_string());
    p->MakeCallback(env->onerror_string(), 1, &err);
    return SSL_TLSEXT_ERR_NOACK;
  }

  SecureContext* sc = Unwrap<SecureContext>(ctx.As<Object>());
  CHECK_NOT_NULL(sc);
  p->sni_context_ = BaseObjectPtr<SecureContext>(sc);

  ConfigureSecureContext(sc);
  CHECK_E...",67,,1260,4,,void
62287,BLOCK,-1,,<empty>,5,,1268,2,,void
62327,BLOCK,-1,,<empty>,5,,1274,2,,void
62340,BLOCK,-1,,"{
    // Failure: incorrect SNI context object
    Local<Value> err = Exception::TypeError(env->sni_context_err_string());
    p->MakeCallback(env->onerror_string(), 1, &err);
    return SSL_TLSEXT_ERR_NOACK;
  }",70,,1276,2,,void
62425,BLOCK,-1,,"{
  int err = SSL_set1_verify_cert_store(ssl_.get(),
                                       SSL_CTX_get_cert_store(sc->ctx().get()));
  if (err != 1)
    return err;

  STACK_OF(X509_NAME)* list =
      SSL_dup_CA_list(SSL_CTX_get_client_CA_list(sc->ctx().get()));

  // NOTE: `SSL_set_client_CA_list` takes the ownership of `list`
  SSL_set_client_CA_list(ssl_.get(), list);
  return 1;
}",44,,1294,2,,void
62446,BLOCK,-1,,<empty>,5,,1298,2,,void
62475,BLOCK,-1,,"{
  TLSWrap* p;
  ASSIGN_OR_RETURN_UNWRAP(&p, args.Holder());
  CHECK_NOT_NULL(p->ssl_);

  Environment* env = p->env();
  Isolate* isolate = env->isolate();

  CHECK(args[0]->IsString());
  Utf8Value hint(isolate, args[0].As<String>());

  if (!SSL_use_psk_identity_hint(p->ssl_.get(), *hint)) {
    Local<Value> err = node::ERR_TLS_PSK_SET_IDENTIY_HINT_FAILED(isolate);
    p->MakeCallback(env->onerror_string(), 1, &err);
  }
}",75,,1310,2,,void
62529,BLOCK,-1,,"{
    Local<Value> err = node::ERR_TLS_PSK_SET_IDENTIY_HINT_FAILED(isolate);
    p->MakeCallback(env->onerror_string(), 1, &err);
  }",57,,1321,2,,void
62556,BLOCK,-1,,"{
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  CHECK_NOT_NULL(wrap->ssl_);

  SSL_set_psk_server_callback(wrap->ssl_.get(), PskServerCallback);
  SSL_set_psk_client_callback(wrap->ssl_.get(), PskClientCallback);
}",74,,1327,2,,void
62592,BLOCK,-1,,"{
  TLSWrap* p = static_cast<TLSWrap*>(SSL_get_app_data(s));

  Environment* env = p->env();
  HandleScope scope(env->isolate());

  Local<String> identity_str =
      String::NewFromUtf8(env->isolate(), identity).FromMaybe(Local<String>());
  if (UNLIKELY(identity_str.IsEmpty()))
    return 0;

  // Make sure there are no utf8 replacement symbols.
  Utf8Value identity_utf8(env->isolate(), identity_str);
  if (identity_utf8 != identity) return 0;

  Local<Value> argv[] = {
    identity_str,
    Integer::NewFromUnsigned(env->isolate(), max_psk_len)
  };

  Local<Value> psk_val =
      p->MakeCallback(env->onpskexchange_symbol(), arraysize(argv), argv)
          .FromMaybe(Local<Value>());
  if (UNLIKELY(psk_val.IsEmpty()) || !psk_val->IsArrayBufferView())
    return 0;

  ArrayBufferViewContents<char> psk_buf(psk_val);

  if (psk_buf.length() > max_psk_len)
    return 0;

  memcpy(psk, psk_buf.data(), psk_buf.length());
  return psk_buf.length();
}",31,,1340,5,,void
62638,BLOCK,-1,,<empty>,5,,1349,2,,void
62652,BLOCK,-1,,<empty>,34,,1353,2,,void
62702,BLOCK,-1,,<empty>,5,,1364,2,,void
62715,BLOCK,-1,,<empty>,5,,1369,2,,void
62742,BLOCK,-1,,"{
  TLSWrap* p = static_cast<TLSWrap*>(SSL_get_app_data(s));

  Environment* env = p->env();
  HandleScope scope(env->isolate());

  Local<Value> argv[] = {
    Null(env->isolate()),
    Integer::NewFromUnsigned(env->isolate(), max_psk_len),
    Integer::NewFromUnsigned(env->isolate(), max_identity_len)
  };

  if (hint != nullptr) {
    Local<String> local_hint =
        String::NewFromUtf8(env->isolate(), hint).FromMaybe(Local<String>());
    if (UNLIKELY(local_hint.IsEmpty()))
      return 0;

    argv[0] = local_hint;
  }

  Local<Value> ret =
      p->MakeCallback(env->onpskexchange_symbol(), arraysize(argv), argv)
          .FromMaybe(Local<Value>());
  if (UNLIKELY(ret.IsEmpty()) || !ret->IsObject())
    return 0;

  Local<Object> obj = ret.As<Object>();

  Local<Value> psk_val = obj->Get(env->context(), env->psk_string())
      .FromMaybe(Local<Value>());
  if (UNLIKELY(psk_val.IsEmpty()) || !psk_val->IsArrayBufferView())
    return 0;

  ArrayBufferViewContents<char> psk_bu...",31,,1381,7,,void
62794,BLOCK,-1,,"{
    Local<String> local_hint =
        String::NewFromUtf8(env->isolate(), hint).FromMaybe(Local<String>());
    if (UNLIKELY(local_hint.IsEmpty()))
      return 0;

    argv[0] = local_hint;
  }",24,,1393,2,,void
62820,BLOCK,-1,,<empty>,7,,1397,2,,void
62861,BLOCK,-1,,<empty>,5,,1406,2,,void
62908,BLOCK,-1,,<empty>,5,,1413,2,,void
62921,BLOCK,-1,,<empty>,5,,1417,2,,void
62958,BLOCK,-1,,<empty>,5,,1422,2,,void
62975,BLOCK,-1,,<empty>,5,,1427,2,,void
63005,BLOCK,-1,,"{
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, info.This());

  if (!wrap->ssl_)
    return info.GetReturnValue().Set(0);

  uint32_t write_queue_size = BIO_pending(wrap->enc_out_);
  info.GetReturnValue().Set(write_queue_size);
}",74,,1437,2,,void
63019,BLOCK,-1,,<empty>,5,,1442,2,,void
63048,BLOCK,-1,,"{
  tracker->TrackField(""ocsp_response"", ocsp_response_);
  tracker->TrackField(""sni_context"", sni_context_);
  tracker->TrackField(""error"", error_);
  if (pending_cleartext_input_)
    tracker->TrackField(""pending_cleartext_input"", pending_cleartext_input_);
  if (enc_in_ != nullptr)
    tracker->TrackField(""enc_in"", NodeBIO::FromBIO(enc_in_));
  if (enc_out_ != nullptr)
    tracker->TrackField(""enc_out"", NodeBIO::FromBIO(enc_out_));
}",56,,1448,2,,void
63069,BLOCK,-1,,<empty>,5,,1453,2,,void
63080,BLOCK,-1,,<empty>,5,,1455,2,,void
63095,BLOCK,-1,,<empty>,5,,1457,2,,void
63110,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  CHECK(w->is_waiting_cert_cb() && w->cert_cb_running_);

  Local<Object> object = w->object();
  Local<Value> ctx = object->Get(env->context(), env->sni_context_string())
      .FromMaybe(Local<Value>());
  if (UNLIKELY(ctx.IsEmpty()))
    return;

  Local<FunctionTemplate> cons = env->secure_context_constructor_template();
  if (cons->HasInstance(ctx)) {
    SecureContext* sc = Unwrap<SecureContext>(ctx.As<Object>());
    CHECK_NOT_NULL(sc);
    // Store the SNI context for later use.
    w->sni_context_ = BaseObjectPtr<SecureContext>(sc);

    if (UseSNIContext(w->ssl_, w->sni_context_) && !w->SetCACerts(sc)) {
      // Not clear why sometimes we throw error, and sometimes we call
      // onerror(). Both cause .destroy(), but onerror does a bit more.
      unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
      return ThrowCryptoError(env, err, ""CertCbDon...",67,,1460,2,,void
63174,BLOCK,-1,,<empty>,5,,1471,2,,void
63192,BLOCK,-1,,"{
    SecureContext* sc = Unwrap<SecureContext>(ctx.As<Object>());
    CHECK_NOT_NULL(sc);
    // Store the SNI context for later use.
    w->sni_context_ = BaseObjectPtr<SecureContext>(sc);

    if (UseSNIContext(w->ssl_, w->sni_context_) && !w->SetCACerts(sc)) {
      // Not clear why sometimes we throw error, and sometimes we call
      // onerror(). Both cause .destroy(), but onerror does a bit more.
      unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
      return ThrowCryptoError(env, err, ""CertCbDone"");
    }
  }",31,,1474,2,,void
63230,BLOCK,-1,,"{
      // Not clear why sometimes we throw error, and sometimes we call
      // onerror(). Both cause .destroy(), but onerror does a bit more.
      unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
      return ThrowCryptoError(env, err, ""CertCbDone"");
    }",72,,1480,2,,void
63241,BLOCK,-1,,<empty>,10,,1486,1,,void
63247,BLOCK,-1,,"{
    // Failure: incorrect SNI context object
    Local<Value> err = Exception::TypeError(env->sni_context_err_string());
    w->MakeCallback(env->onerror_string(), 1, &err);
    return;
  }",31,,1486,2,,void
63307,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = w->env();
  if (args.Length() < 1 || !Buffer::HasInstance(args[0]))
    return env->ThrowTypeError(""Must give a Buffer as first argument"");

  ArrayBufferViewContents<uint8_t> protos(args[0].As<ArrayBufferView>());
  SSL* ssl = w->ssl_.get();
  if (w->is_client()) {
    CHECK_EQ(0, SSL_set_alpn_protos(ssl, protos.data(), protos.length()));
  } else {
    w->alpn_protos_ = std::vector<unsigned char>(
        protos.data(), protos.data() + protos.length());
    SSL_CTX_set_alpn_select_cb(SSL_get_SSL_CTX(ssl), SelectALPNCallback, w);
  }
}",73,,1506,2,,void
63339,BLOCK,-1,,<empty>,5,,1511,2,,void
63371,BLOCK,-1,,"{
    CHECK_EQ(0, SSL_set_alpn_protos(ssl, protos.data(), protos.length()));
  }",23,,1515,2,,void
63385,BLOCK,-1,,"{
    w->alpn_protos_ = std::vector<unsigned char>(
        protos.data(), protos.data() + protos.length());
    SSL_CTX_set_alpn_select_cb(SSL_get_SSL_CTX(ssl), SelectALPNCallback, w);
  }",10,,1517,1,,void
63416,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = w->env();

  bool abbreviated = args.Length() < 1 || !args[0]->IsTrue();

  Local<Value> ret;
  if (GetPeerCert(
          env,
          w->ssl_,
          abbreviated,
          w->is_server()).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",75,,1524,2,,void
63470,BLOCK,-1,,<empty>,5,,1537,2,,void
63483,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = w->env();

  X509Certificate::GetPeerCertificateFlag flag = w->is_server()
      ? X509Certificate::GetPeerCertificateFlag::SERVER
      : X509Certificate::GetPeerCertificateFlag::NONE;

  Local<Value> ret;
  if (X509Certificate::GetPeerCert(env, w->ssl_, flag).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",79,,1540,2,,void
63537,BLOCK,-1,,<empty>,5,,1551,2,,void
63550,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = w->env();

  Local<Value> ret;
  if (GetCert(env, w->ssl_).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",71,,1554,2,,void
63582,BLOCK,-1,,<empty>,5,,1561,2,,void
63595,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = w->env();
  Local<Value> ret;
  if (X509Certificate::GetCert(env, w->ssl_).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",75,,1564,2,,void
63630,BLOCK,-1,,<empty>,5,,1570,2,,void
63643,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  // We cannot just pass nullptr to SSL_get_finished()
  // because it would further be propagated to memcpy(),
  // where the standard requirements as described in ISO/IEC 9899:2011
  // sections 7.21.2.1, 7.21.1.2, and 7.1.4, would be violated.
  // Thus, we use a dummy byte.
  char dummy[1];
  size_t len = SSL_get_finished(w->ssl_.get(), dummy, sizeof dummy);
  if (len == 0)
    return;

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), len);
  }

  CHECK_EQ(bs->ByteLength(),
           SSL_get_finished(w->ssl_.get(), bs->Data(), bs->ByteLength()));

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  Local<Value> buffer;
  if (!Buffer::New(env, ab, 0, ab->ByteLength()).ToLocal(&buffer)) return;
  args.GetReturnValue().Set(buff...",68,,1573,2,,void
63678,BLOCK,-1,,<empty>,5,,1587,2,,void
63687,BLOCK,10,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), len);
  }",3,,1590,10,,void
63767,BLOCK,-1,,<empty>,68,,1600,2,,void
63781,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  // We cannot just pass nullptr to SSL_get_peer_finished()
  // because it would further be propagated to memcpy(),
  // where the standard requirements as described in ISO/IEC 9899:2011
  // sections 7.21.2.1, 7.21.1.2, and 7.1.4, would be violated.
  // Thus, we use a dummy byte.
  char dummy[1];
  size_t len = SSL_get_peer_finished(w->ssl_.get(), dummy, sizeof dummy);
  if (len == 0)
    return;

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), len);
  }

  CHECK_EQ(bs->ByteLength(),
           SSL_get_peer_finished(w->ssl_.get(), bs->Data(), bs->ByteLength()));

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  Local<Value> buffer;
  if (!Buffer::New(env, ab, 0, ab->ByteLength()).ToLocal(&buffer)) return;
  args.GetReturnV...",72,,1604,2,,void
63816,BLOCK,-1,,<empty>,5,,1618,2,,void
63825,BLOCK,10,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), len);
  }",3,,1621,10,,void
63905,BLOCK,-1,,<empty>,68,,1631,2,,void
63919,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  SSL_SESSION* sess = SSL_get_session(w->ssl_.get());
  if (sess == nullptr)
    return;

  int slen = i2d_SSL_SESSION(sess, nullptr);
  if (slen <= 0)
    return;  // Invalid or malformed session.

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), slen);
  }

  unsigned char* p = static_cast<unsigned char*>(bs->Data());
  CHECK_LT(0, i2d_SSL_SESSION(sess, &p));

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  Local<Value> buffer;
  if (!Buffer::New(env, ab, 0, ab->ByteLength()).ToLocal(&buffer)) return;
  args.GetReturnValue().Set(buffer);
}",67,,1635,2,,void
63950,BLOCK,-1,,<empty>,5,,1643,2,,void
63962,BLOCK,-1,,<empty>,5,,1647,2,,void
63971,BLOCK,12,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), slen);
  }",3,,1650,12,,void
64046,BLOCK,-1,,<empty>,68,,1660,2,,void
64060,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  if (args.Length() < 1)
    return THROW_ERR_MISSING_ARGS(env, ""Session argument is mandatory"");

  THROW_AND_RETURN_IF_NOT_BUFFER(env, args[0], ""Session"");
  ArrayBufferViewContents<unsigned char> sbuf(args[0]);
  SSLSessionPointer sess = GetTLSSession(sbuf.data(), sbuf.length());
  if (sess == nullptr)
    return;  // TODO(tniessen): figure out error handling

  if (!SetTLSSession(w->ssl_, sess))
    return env->ThrowError(""SSL_set_session error"");
}",67,,1664,2,,void
64084,BLOCK,-1,,<empty>,5,,1671,2,,void
64116,BLOCK,-1,,<empty>,5,,1677,2,,void
64125,BLOCK,-1,,<empty>,5,,1680,2,,void
64136,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  bool yes = SSL_session_reused(w->ssl_.get());
  args.GetReturnValue().Set(yes);
}",72,,1683,2,,void
64167,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  // XXX(bnoordhuis) The UNABLE_TO_GET_ISSUER_CERT error when there is no
  // peer certificate is questionable but it's compatible with what was
  // here before.
  long x509_verify_error =  // NOLINT(runtime/int)
      VerifyPeerCertificate(
          w->ssl_,
          X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT);

  if (x509_verify_error == X509_V_OK)
    return args.GetReturnValue().SetNull();

  const char* reason = X509_verify_cert_error_string(x509_verify_error);
  const char* code = X509ErrorCode(x509_verify_error);

  Local<Object> error =
      Exception::Error(OneByteString(env->isolate(), reason))
          ->ToObject(env->isolate()->GetCurrentContext())
              .FromMaybe(Local<Object>());

  if (Set(env, error, env->code_string(), code))
    args.GetReturnValue().Set(error);
}",68,,1690,2,,void
64196,BLOCK,-1,,<empty>,5,,1704,2,,void
64254,BLOCK,-1,,<empty>,5,,1715,2,,void
64267,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  args.GetReturnValue().Set(
      GetCipherInfo(env, w->ssl_).FromMaybe(Local<Object>()));
}",66,,1718,2,,void
64304,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  // TODO(@sam-github) check arg length and types in js, and CHECK in c++
  if (args.Length() >= 1 && Buffer::HasInstance(args[0])) {
    ArrayBufferViewContents<unsigned char> sbuf(args[0]);

    const unsigned char* p = sbuf.data();
    SSL_SESSION* sess = d2i_SSL_SESSION(nullptr, &p, sbuf.length());

    // Setup next session and move hello to the BIO buffer
    w->next_sess_.reset(sess);
  }
}",68,,1726,2,,void
64328,BLOCK,-1,,"{
    ArrayBufferViewContents<unsigned char> sbuf(args[0]);

    const unsigned char* p = sbuf.data();
    SSL_SESSION* sess = d2i_SSL_SESSION(nullptr, &p, sbuf.length());

    // Setup next session and move hello to the BIO buffer
    w->next_sess_.reset(sess);
  }",59,,1731,2,,void
64363,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  SSL* ssl = w->ssl_.get();
  int nsig = SSL_get_shared_sigalgs(ssl, 0, nullptr, nullptr, nullptr, nullptr,
                                    nullptr);
  MaybeStackBuffer<Local<Value>, 16> ret_arr(nsig);

  for (int i = 0; i < nsig; i++) {
    int hash_nid;
    int sign_nid;
    std::string sig_with_md;

    SSL_get_shared_sigalgs(ssl, i, &sign_nid, &hash_nid, nullptr, nullptr,
                           nullptr);

    switch (sign_nid) {
      case EVP_PKEY_RSA:
        sig_with_md = ""RSA+"";
        break;

      case EVP_PKEY_RSA_PSS:
        sig_with_md = ""RSA-PSS+"";
        break;

      case EVP_PKEY_DSA:
        sig_with_md = ""DSA+"";
        break;

      case EVP_PKEY_EC:
        sig_with_md = ""ECDSA+"";
        break;

      case NID_ED25519:
        sig_with_md = ""Ed25519+"";
        break;

      case NID_ED448:
        sig_with_md = ""Ed448+"";
        break;
#...",73,,1742,2,,void
64404,BLOCK,-1,,<empty>,3,,1752,1,,void
64414,BLOCK,4,,"{
    int hash_nid;
    int sign_nid;
    std::string sig_with_md;

    SSL_get_shared_sigalgs(ssl, i, &sign_nid, &hash_nid, nullptr, nullptr,
                           nullptr);

    switch (sign_nid) {
      case EVP_PKEY_RSA:
        sig_with_md = ""RSA+"";
        break;

      case EVP_PKEY_RSA_PSS:
        sig_with_md = ""RSA-PSS+"";
        break;

      case EVP_PKEY_DSA:
        sig_with_md = ""DSA+"";
        break;

      case EVP_PKEY_EC:
        sig_with_md = ""ECDSA+"";
        break;

      case NID_ED25519:
        sig_with_md = ""Ed25519+"";
        break;

      case NID_ED448:
        sig_with_md = ""Ed448+"";
        break;
#ifndef OPENSSL_NO_GOST
      case NID_id_GostR3410_2001:
        sig_with_md = ""gost2001+"";
        break;

      case NID_id_GostR3410_2012_256:
        sig_with_md = ""gost2012_256+"";
        break;

      case NID_id_GostR3410_2012_512:
        sig_with_md = ""gost2012_512+"";
        break;
#endif  // !OPENSSL_NO_GOST
      default:
        const char*...",34,,1752,4,,void
64430,BLOCK,-1,,"{
      case EVP_PKEY_RSA:
        sig_with_md = ""RSA+"";
        break;

      case EVP_PKEY_RSA_PSS:
        sig_with_md = ""RSA-PSS+"";
        break;

      case EVP_PKEY_DSA:
        sig_with_md = ""DSA+"";
        break;

      case EVP_PKEY_EC:
        sig_with_md = ""ECDSA+"";
        break;

      case NID_ED25519:
        sig_with_md = ""Ed25519+"";
        break;

      case NID_ED448:
        sig_with_md = ""Ed448+"";
        break;
#ifndef OPENSSL_NO_GOST
      case NID_id_GostR3410_2001:
        sig_with_md = ""gost2001+"";
        break;

      case NID_id_GostR3410_2012_256:
        sig_with_md = ""gost2012_256+"";
        break;

      case NID_id_GostR3410_2012_512:
        sig_with_md = ""gost2012_512+"";
        break;
#endif  // !OPENSSL_NO_GOST
      default:
        const char* sn = OBJ_nid2sn(sign_nid);

        if (sn != nullptr) {
          sig_with_md = std::string(sn) + ""+"";
        } else {
          sig_with_md = ""UNDEF+"";
        }
        break;
    }",23,,1760,2,,void
64495,BLOCK,-1,,"{
          sig_with_md = std::string(sn) + ""+"";
        }",28,,1800,2,,void
64506,BLOCK,-1,,"{
          sig_with_md = ""UNDEF+"";
        }",16,,1802,1,,void
64520,BLOCK,-1,,"{
      sig_with_md += std::string(sn_hash);
    }",29,,1809,2,,void
64529,BLOCK,-1,,"{
      sig_with_md += ""UNDEF"";
    }",12,,1811,1,,void
64573,BLOCK,-1,,"{
  CHECK(args[0]->IsInt32());
  CHECK(args[1]->IsString());

  Environment* env = Environment::GetCurrent(args);
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  uint32_t olen = args[0].As<Uint32>()->Value();
  Utf8Value label(env->isolate(), args[1]);

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), olen);
  }

  ByteSource context;
  bool use_context = !args[2]->IsUndefined();
  if (use_context)
    context = ByteSource::FromBuffer(args[2]);

  if (SSL_export_keying_material(
          w->ssl_.get(),
          static_cast<unsigned char*>(bs->Data()),
          olen,
          *label,
          label.length(),
          context.data<unsigned char>(),
          context.size(),
          use_context) != 1) {
    return ThrowCryptoError(
         env,
         ERR_get_error(),
         ""SSL_export_keying_material"");
  }

  Local<ArrayBuffer> ab = ArrayBu...",77,,1821,2,,void
64632,BLOCK,12,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), olen);
  }",3,,1833,12,,void
64663,BLOCK,-1,,<empty>,5,,1841,2,,void
64705,BLOCK,-1,,"{
    return ThrowCryptoError(
         env,
         ERR_get_error(),
         ""SSL_export_keying_material"");
  }",30,,1851,2,,void
64753,BLOCK,-1,,<empty>,68,,1860,2,,void
64767,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  w->hello_parser_.End();
}",66,,1864,2,,void
64786,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  ClearErrorOnReturn clear_error_on_return;
  if (SSL_renegotiate(w->ssl_.get()) != 1)
    return ThrowCryptoError(w->env(), ERR_get_error());
}",68,,1870,2,,void
64806,BLOCK,-1,,<empty>,5,,1875,2,,void
64818,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = w->env();

  SSL_SESSION* sess = SSL_get_session(w->ssl_.get());
  if (sess == nullptr)
    return;

  const unsigned char* ticket;
  size_t length;
  SSL_SESSION_get0_ticket(sess, &ticket, &length);

  if (ticket != nullptr) {
    args.GetReturnValue().Set(
        Buffer::Copy(env, reinterpret_cast<const char*>(ticket), length)
            .FromMaybe(Local<Object>()));
  }
}",69,,1878,2,,void
64848,BLOCK,-1,,<empty>,5,,1885,2,,void
64862,BLOCK,-1,,"{
    args.GetReturnValue().Set(
        Buffer::Copy(env, reinterpret_cast<const char*>(ticket), length)
            .FromMaybe(Local<Object>()));
  }",26,,1891,2,,void
64887,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  w->awaiting_new_session_ = false;
  w->NewSessionDoneCb();
}",71,,1898,2,,void
64909,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = w->env();

  if (args.Length() < 1)
    return THROW_ERR_MISSING_ARGS(env, ""OCSP response argument is mandatory"");

  THROW_AND_RETURN_IF_NOT_BUFFER(env, args[0], ""OCSP response"");

  w->ocsp_response_.Reset(args.GetIsolate(), args[0].As<ArrayBufferView>());
}",72,,1905,2,,void
64932,BLOCK,-1,,<empty>,5,,1911,2,,void
64963,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  SSL_set_tlsext_status_type(w->ssl_.get(), TLSEXT_STATUSTYPE_ocsp);
}",68,,1918,2,,void
64984,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = Environment::GetCurrent(args);

  CHECK(w->ssl_);

  // tmp key is available on only client
  if (w->is_server())
    return args.GetReturnValue().SetNull();

  args.GetReturnValue().Set(GetEphemeralKey(env, w->ssl_)
      .FromMaybe(Local<Value>()));

  // TODO(@sam-github) semver-major: else return ThrowCryptoError(env,
  // ERR_get_error())
}",76,,1925,2,,void
65010,BLOCK,-1,,<empty>,5,,1934,2,,void
65039,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  args.GetReturnValue().Set(
      OneByteString(env->isolate(), SSL_get_version(w->ssl_.get())));
}",68,,1943,2,,void
65079,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  const unsigned char* alpn_proto;
  unsigned int alpn_proto_len;

  SSL_get0_alpn_selected(w->ssl_.get(), &alpn_proto, &alpn_proto_len);

  Local<Value> result;
  if (alpn_proto_len == 0) {
    result = False(env->isolate());
  } else if (alpn_proto_len == sizeof(""h2"") - 1 &&
             0 == memcmp(alpn_proto, ""h2"", sizeof(""h2"") - 1)) {
    result = env->h2_string();
  } else if (alpn_proto_len == sizeof(""http/1.1"") - 1 &&
             0 == memcmp(alpn_proto, ""http/1.1"", sizeof(""http/1.1"") - 1)) {
    result = env->http_1_1_string();
  } else {
    result = OneByteString(env->isolate(), alpn_proto, alpn_proto_len);
  }

  args.GetReturnValue().Set(result);
}",79,,1951,2,,void
65118,BLOCK,-1,,"{
    result = False(env->isolate());
  }",28,,1962,2,,void
65127,BLOCK,-1,,<empty>,10,,1964,1,,void
65145,BLOCK,-1,,"{
    result = env->h2_string();
  }",63,,1965,2,,void
65153,BLOCK,-1,,<empty>,10,,1967,1,,void
65171,BLOCK,-1,,"{
    result = env->http_1_1_string();
  }",75,,1968,2,,void
65179,BLOCK,-1,,"{
    result = OneByteString(env->isolate(), alpn_proto, alpn_proto_len);
  }",10,,1970,1,,void
65200,BLOCK,-1,,"{
  // Prevent recursion
  if (++cycle_depth_ > 1)
    return;

  for (; cycle_depth_ > 0; cycle_depth_--) {
    ClearIn();
    ClearOut();
    // EncIn() doesn't exist, it happens via stream listener callbacks.
    EncOut();
  }
}",23,,1977,1,,void
65206,BLOCK,-1,,<empty>,5,,1980,2,,void
65209,BLOCK,-1,,<empty>,3,,1982,1,,void
65215,BLOCK,4,,"{
    ClearIn();
    ClearOut();
    // EncIn() doesn't exist, it happens via stream listener callbacks.
    EncOut();
  }",44,,1982,4,,void
65226,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  SetMethod(context, target, ""wrap"", TLSWrap::Wrap);

  NODE_DEFINE_CONSTANT(target, HAVE_SSL_TRACE);

  Local<FunctionTemplate> t = BaseObject::MakeLazilyInitializedJSTemplate(env);
  Local<String> tlsWrapString =
      FIXED_ONE_BYTE_STRING(env->isolate(), ""TLSWrap"");
  t->SetClassName(tlsWrapString);
  t->InstanceTemplate()->SetInternalFieldCount(StreamBase::kInternalFieldCount);

  Local<FunctionTemplate> get_write_queue_size =
      FunctionTemplate::New(env->isolate(),
                            GetWriteQueueSize,
                            Local<Value>(),
                            Signature::New(env->isolate(), t));
  t->PrototypeTemplate()->SetAccessorProperty(
      env->write_queue_size_string(),
      get_write_queue_size,
      Local<FunctionTemplate>(),
      static_cast<PropertyAttribute>(ReadOnly | DontDelete));

  t->Inherit(AsyncWrap::GetConstructorTemplate(env));

  S...",17,,2007,5,,void
65253,BLOCK,1,,<empty>,,,,6,,void
65255,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, HAVE_SSL_TRACE)",3,,2013,1,,void
65667,BLOCK,-1,,"{
  registry->Register(TLSWrap::Wrap);
  registry->Register(GetWriteQueueSize);

  registry->Register(CertCbDone);
  registry->Register(DestroySSL);
  registry->Register(EnableCertCb);
  registry->Register(EndParser);
  registry->Register(EnableKeylogCallback);
  registry->Register(EnableSessionCallbacks);
  registry->Register(EnableTrace);
  registry->Register(GetServername);
  registry->Register(LoadSession);
  registry->Register(NewSessionDone);
  registry->Register(Receive);
  registry->Register(Renegotiate);
  registry->Register(RequestOCSP);
  registry->Register(SetALPNProtocols);
  registry->Register(SetOCSPResponse);
  registry->Register(SetServername);
  registry->Register(SetSession);
  registry->Register(SetVerifyMode);
  registry->Register(Start);
  registry->Register(ExportKeyingMaterial);
  registry->Register(IsSessionReused);
  registry->Register(GetALPNNegotiatedProto);
  registry->Register(GetCertificate);
  registry->Register(GetX509Certificate);
  registry->Regist...",79,,2095,2,,void
65888,BLOCK,-1,,<empty>,1,,1,1,,ANY
65894,BLOCK,-1,,"{
        OPENSSL_clear_free(deleter_data, length);
      }",57,,358,4,,void
65906,BLOCK,-1,,"{
            OPENSSL_secure_clear_free(data, len);
          }",58,,721,4,,void
65947,BLOCK,-1,,<empty>,1,,1,1,,ANY
65953,BLOCK,-1,,"{
  // From https://www.openssl.org/docs/man1.1.1/man3/SSL_verify_cb:
  //
  //   If VerifyCallback returns 1, the verification process is continued. If
  //   VerifyCallback always returns 1, the TLS/SSL handshake will not be
  //   terminated with respect to verification failures and the connection will
  //   be established. The calling process can however retrieve the error code
  //   of the last verification error using SSL_get_verify_result(3) or by
  //   maintaining its own error storage managed by VerifyCallback.
  //
  // Since we cannot perform I/O quickly enough with X509_STORE_CTX_ APIs in
  // this callback, we ignore all preverify_ok errors and let the handshake
  // continue. It is imperative that the user use Connection::VerifyError after
  // the 'secure' callback has been made.
  return 1;
}",59,,46,3,,void
65962,BLOCK,-1,,"{
  unsigned char* buf = static_cast<unsigned char*>(buffer);
  do {
    if (1 == RAND_status()) {
#if OPENSSL_VERSION_MAJOR >= 3
      if (1 == RAND_bytes_ex(nullptr, buf, length, 0)) return {true};
#else
      while (length > INT_MAX && 1 == RAND_bytes(buf, INT_MAX)) {
        buf += INT_MAX;
        length -= INT_MAX;
      }
      if (length <= INT_MAX && 1 == RAND_bytes(buf, static_cast<int>(length)))
        return {true};
#endif
    }
#if OPENSSL_VERSION_MAJOR >= 3
    const auto code = ERR_peek_last_error();
    // A misconfigured OpenSSL 3 installation may report 1 from RAND_poll()
    // and RAND_status() but fail in RAND_bytes() if it cannot look up
    // a matching algorithm for the CSPRNG.
    if (ERR_GET_LIB(code) == ERR_LIB_RAND) {
      const auto reason = ERR_GET_REASON(code);
      if (reason == RAND_R_ERROR_INSTANTIATING_DRBG ||
          reason == RAND_R_UNABLE_TO_FETCH_DRBG ||
          reason == RAND_R_UNABLE_TO_CREATE_DRBG) {
        return {false};
      }
 ...",66,,63,3,,void
65970,BLOCK,-1,,"{
    if (1 == RAND_status()) {
#if OPENSSL_VERSION_MAJOR >= 3
      if (1 == RAND_bytes_ex(nullptr, buf, length, 0)) return {true};
#else
      while (length > INT_MAX && 1 == RAND_bytes(buf, INT_MAX)) {
        buf += INT_MAX;
        length -= INT_MAX;
      }
      if (length <= INT_MAX && 1 == RAND_bytes(buf, static_cast<int>(length)))
        return {true};
#endif
    }
#if OPENSSL_VERSION_MAJOR >= 3
    const auto code = ERR_peek_last_error();
    // A misconfigured OpenSSL 3 installation may report 1 from RAND_poll()
    // and RAND_status() but fail in RAND_bytes() if it cannot look up
    // a matching algorithm for the CSPRNG.
    if (ERR_GET_LIB(code) == ERR_LIB_RAND) {
      const auto reason = ERR_GET_REASON(code);
      if (reason == RAND_R_ERROR_INSTANTIATING_DRBG ||
          reason == RAND_R_UNABLE_TO_FETCH_DRBG ||
          reason == RAND_R_UNABLE_TO_CREATE_DRBG) {
        return {false};
      }
    }
#endif
  }",6,,65,1,,void
65975,BLOCK,-1,,"{
#if OPENSSL_VERSION_MAJOR >= 3
      if (1 == RAND_bytes_ex(nullptr, buf, length, 0)) return {true};
#else
      while (length > INT_MAX && 1 == RAND_bytes(buf, INT_MAX)) {
        buf += INT_MAX;
        length -= INT_MAX;
      }
      if (length <= INT_MAX && 1 == RAND_bytes(buf, static_cast<int>(length)))
        return {true};
#endif
    }",29,,66,2,,void
65986,BLOCK,-1,,"{
        buf += INT_MAX;
        length -= INT_MAX;
      }",65,,70,2,,void
66005,BLOCK,-1,,<empty>,9,,75,2,,void
66018,BLOCK,-1,,"{
  const ByteSource* passphrase = *static_cast<const ByteSource**>(u);
  if (passphrase != nullptr) {
    size_t buflen = static_cast<size_t>(size);
    size_t len = passphrase->size();
    if (buflen < len)
      return -1;
    memcpy(buf, passphrase->data(), len);
    return len;
  }

  return -1;
}",64,,97,5,,void
66030,BLOCK,-1,,"{
    size_t buflen = static_cast<size_t>(size);
    size_t len = passphrase->size();
    if (buflen < len)
      return -1;
    memcpy(buf, passphrase->data(), len);
    return len;
  }",30,,99,2,,void
66048,BLOCK,-1,,<empty>,7,,103,2,,void
66071,BLOCK,-1,,"{
  return 0;
}",66,,116,5,,void
66077,BLOCK,-1,,"{
  /* Override FIPS settings in configuration file, if needed. */
  if (per_process::cli_options->enable_fips_crypto ||
      per_process::cli_options->force_fips_crypto) {
#if OPENSSL_VERSION_MAJOR >= 3
    OSSL_PROVIDER* fips_provider = OSSL_PROVIDER_load(nullptr, ""fips"");
    if (fips_provider == nullptr)
      return false;
    OSSL_PROVIDER_unload(fips_provider);

    return EVP_default_properties_enable_fips(nullptr, 1) &&
           EVP_default_properties_is_fips_enabled(nullptr);
#else
    if (FIPS_mode() == 0) return FIPS_mode_set(1);

#endif
  }
  return true;
}",27,,120,1,,void
66090,BLOCK,-1,,"{
#if OPENSSL_VERSION_MAJOR >= 3
    OSSL_PROVIDER* fips_provider = OSSL_PROVIDER_load(nullptr, ""fips"");
    if (fips_provider == nullptr)
      return false;
    OSSL_PROVIDER_unload(fips_provider);

    return EVP_default_properties_enable_fips(nullptr, 1) &&
           EVP_default_properties_is_fips_enabled(nullptr);
#else
    if (FIPS_mode() == 0) return FIPS_mode_set(1);

#endif
  }",52,,123,2,,void
66095,BLOCK,-1,,<empty>,27,,133,2,,void
66105,BLOCK,-1,,"{
  static uv_once_t init_once = UV_ONCE_INIT;
  TryCatch try_catch{isolate};
  uv_once(&init_once, InitCryptoOnce);
  if (try_catch.HasCaught() && !try_catch.HasTerminated()) {
    try_catch.ReThrow();
    return false;
  }
  return true;
}",39,,140,2,,void
66130,BLOCK,-1,,"{
    try_catch.ReThrow();
    return false;
  }",60,,144,2,,void
66143,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Mutex::ScopedLock fips_lock(fips_mutex);
#ifndef OPENSSL_IS_BORINGSSL
  OPENSSL_INIT_SETTINGS* settings = OPENSSL_INIT_new();

#if OPENSSL_VERSION_MAJOR < 3
  // --openssl-config=...
  if (!per_process::cli_options->openssl_config.empty()) {
    const char* conf = per_process::cli_options->openssl_config.c_str();
    OPENSSL_INIT_set_config_filename(settings, conf);
  }
#endif

#if OPENSSL_VERSION_MAJOR >= 3
  // --openssl-legacy-provider
  if (per_process::cli_options->openssl_legacy_provider) {
    OSSL_PROVIDER* legacy_provider = OSSL_PROVIDER_load(nullptr, ""legacy"");
    if (legacy_provider == nullptr) {
      fprintf(stderr, ""Unable to load legacy provider.\n"");
    }
  }
#endif

  OPENSSL_init_ssl(0, settings);
  OPENSSL_INIT_free(settings);
  settings = nullptr;

#ifndef _WIN32
  if (per_process::cli_options->secure_heap != 0) {
    switch (CRYPTO_secure_malloc_init(
                per_process::cli_options->secure...",23,,155,1,,void
66166,BLOCK,-1,,"{
    const char* conf = per_process::cli_options->openssl_config.c_str();
    OPENSSL_INIT_set_config_filename(settings, conf);
  }",58,,163,2,,void
66197,BLOCK,-1,,"{
    switch (CRYPTO_secure_malloc_init(
                per_process::cli_options->secure_heap,
                static_cast<int>(per_process::cli_options->secure_heap_min))) {
      case 0:
        fprintf(stderr, ""Unable to initialize openssl secure heap.\n"");
        break;
      case 2:
        // Not a fatal error but worthy of a warning.
        fprintf(stderr, ""Unable to memory map openssl secure heap.\n"");
        break;
      case 1:
        // OK!
        break;
    }
  }",51,,184,2,,void
66212,BLOCK,-1,,"{
      case 0:
        fprintf(stderr, ""Unable to initialize openssl secure heap.\n"");
        break;
      case 2:
        // Not a fatal error but worthy of a warning.
        fprintf(stderr, ""Unable to memory map openssl secure heap.\n"");
        break;
      case 1:
        // OK!
        break;
    }",79,,187,2,,void
66235,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Mutex::ScopedLock fips_lock(fips_mutex);

#if OPENSSL_VERSION_MAJOR >= 3
  args.GetReturnValue().Set(EVP_default_properties_is_fips_enabled(nullptr) ?
      1 : 0);
#else
  args.GetReturnValue().Set(FIPS_mode() ? 1 : 0);
#endif
}",61,,214,2,,void
66259,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Mutex::ScopedLock fips_lock(fips_mutex);

  CHECK(!per_process::cli_options->force_fips_crypto);
  Environment* env = Environment::GetCurrent(args);
  CHECK(env->owns_process_state());
  bool enable = args[0]->BooleanValue(env->isolate());

#if OPENSSL_VERSION_MAJOR >= 3
  if (enable == EVP_default_properties_is_fips_enabled(nullptr))
#else
  if (static_cast<int>(enable) == FIPS_mode())
#endif
    return;  // No action needed.

#if OPENSSL_VERSION_MAJOR >= 3
  if (!EVP_default_properties_enable_fips(nullptr, enable)) {
#else
  if (!FIPS_mode_set(enable)) {
#endif
    unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
    return ThrowCryptoError(env, err);
  }
}",61,,226,2,,void
66307,BLOCK,-1,,<empty>,5,,240,2,,void
66313,BLOCK,-1,,"{
#endif
    unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
    return ThrowCryptoError(env, err);
  }",31,,245,2,,void
66326,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Mutex::ScopedLock fips_lock(fips_mutex);

#ifdef OPENSSL_FIPS
#if OPENSSL_VERSION_MAJOR >= 3
  OSSL_PROVIDER* fips_provider = nullptr;
  if (OSSL_PROVIDER_available(nullptr, ""fips"")) {
    fips_provider = OSSL_PROVIDER_load(nullptr, ""fips"");
  }
  const auto enabled = fips_provider == nullptr ? 0 :
      OSSL_PROVIDER_self_test(fips_provider) ? 1 : 0;
#else
  const auto enabled = FIPS_selftest() ? 1 : 0;
#endif
#else  // OPENSSL_FIPS
  const auto enabled = 0;
#endif  // OPENSSL_FIPS

  args.GetReturnValue().Set(enabled);
}",70,,252,2,,void
66350,BLOCK,-1,,"{
  errors_.clear();
  while (const uint32_t err = ERR_get_error()) {
    char buf[256];
    ERR_error_string_n(err, buf, sizeof(buf));
    errors_.emplace_back(buf);
  }
  std::reverse(std::begin(errors_), std::end(errors_));
}",34,,274,1,,void
66356,BLOCK,-1,,"{
    char buf[256];
    ERR_error_string_n(err, buf, sizeof(buf));
    errors_.emplace_back(buf);
  }",48,,276,1,,void
66385,BLOCK,-1,,"{
  return errors_.empty();
}",38,,284,1,,void
66396,BLOCK,-1,,"{
  if (exception_string.IsEmpty()) {
    CryptoErrorStore copy(*this);
    if (copy.Empty()) {
      // But possibly a bug...
      copy.Insert(NodeCryptoError::OK);
    }
    // Use last element as the error message, everything else goes
    // into the .opensslErrorStack property on the exception object.
    const std::string& last_error_string = copy.errors_.back();
    Local<String> exception_string;
    if (!String::NewFromUtf8(
            env->isolate(),
            last_error_string.data(),
            NewStringType::kNormal,
            last_error_string.size()).ToLocal(&exception_string)) {
      return MaybeLocal<Value>();
    }
    copy.errors_.pop_back();
    return copy.ToException(env, exception_string);
  }

  Local<Value> exception_v = Exception::Error(exception_string);
  CHECK(!exception_v.IsEmpty());

  if (!Empty()) {
    CHECK(exception_v->IsObject());
    Local<Object> exception = exception_v.As<Object>();
    Local<Value> stack;
    if (!ToV8Value(env->conte...",43,,290,3,,void
66402,BLOCK,-1,,"{
    CryptoErrorStore copy(*this);
    if (copy.Empty()) {
      // But possibly a bug...
      copy.Insert(NodeCryptoError::OK);
    }
    // Use last element as the error message, everything else goes
    // into the .opensslErrorStack property on the exception object.
    const std::string& last_error_string = copy.errors_.back();
    Local<String> exception_string;
    if (!String::NewFromUtf8(
            env->isolate(),
            last_error_string.data(),
            NewStringType::kNormal,
            last_error_string.size()).ToLocal(&exception_string)) {
      return MaybeLocal<Value>();
    }
    copy.errors_.pop_back();
    return copy.ToException(env, exception_string);
  }",35,,291,2,,void
66412,BLOCK,-1,,"{
      // But possibly a bug...
      copy.Insert(NodeCryptoError::OK);
    }",23,,293,2,,void
66460,BLOCK,-1,,"{
      return MaybeLocal<Value>();
    }",67,,305,2,,void
66496,BLOCK,-1,,"{
    CHECK(exception_v->IsObject());
    Local<Object> exception = exception_v.As<Object>();
    Local<Value> stack;
    if (!ToV8Value(env->context(), errors_).ToLocal(&stack) ||
        exception->Set(env->context(), env->openssl_error_stack(), stack)
            .IsNothing()) {
      return MaybeLocal<Value>();
    }
  }",17,,315,2,,void
66547,BLOCK,-1,,"{
      return MaybeLocal<Value>();
    }",27,,321,2,,void
66556,BLOCK,-1,,"{
  other.allocated_data_ = nullptr;
}",26,,332,2,,void
66565,BLOCK,-1,,"{
  OPENSSL_clear_free(allocated_data_, size_);
}",27,,336,1,,void
66573,BLOCK,-1,,"{
  if (&other != this) {
    OPENSSL_clear_free(allocated_data_, size_);
    data_ = other.data_;
    allocated_data_ = other.allocated_data_;
    other.allocated_data_ = nullptr;
    size_ = other.size_;
  }
  return *this;
}",64,,340,2,,void
66579,BLOCK,-1,,"{
    OPENSSL_clear_free(allocated_data_, size_);
    data_ = other.data_;
    allocated_data_ = other.allocated_data_;
    other.allocated_data_ = nullptr;
    size_ = other.size_;
  }",23,,341,2,,void
66609,BLOCK,-1,,"{
  // It's ok for allocated_data_ to be nullptr but
  // only if size_ is zero.
  CHECK_IMPLIES(size_ > 0, allocated_data_ != nullptr);
  std::unique_ptr<BackingStore> ptr = ArrayBuffer::NewBackingStore(
      allocated_data_,
      size(),
      [](void* data, size_t length, void* deleter_data) {
        OPENSSL_clear_free(deleter_data, length);
      }, allocated_data_);
  CHECK(ptr);
  allocated_data_ = nullptr;
  data_ = nullptr;
  size_ = 0;
  return ptr;
}",67,,351,1,,void
66649,BLOCK,-1,,"{
  std::unique_ptr<BackingStore> store = ReleaseToBackingStore();
  return ArrayBuffer::New(env->isolate(), std::move(store));
}",64,,368,2,,void
66677,BLOCK,-1,,"{
  Local<ArrayBuffer> ab = ToArrayBuffer(env);
  return Buffer::New(env, ab, 0, ab->ByteLength());
}",63,,373,2,,void
66702,BLOCK,-1,,"{
  CHECK(bio);
  BUF_MEM* bptr;
  BIO_get_mem_ptr(bio.get(), &bptr);
  ByteSource::Builder out(bptr->length);
  memcpy(out.data<void>(), bptr->data, bptr->length);
  return std::move(out).release();
}",55,,378,2,,void
66744,BLOCK,-1,,"{
  size_t length = 0;
  ByteSource out;

  if (StringBytes::Size(env->isolate(), key, enc).To(&length) && length > 0) {
    ByteSource::Builder buf(length);
    size_t actual =
        StringBytes::Write(env->isolate(), buf.data<char>(), length, key, enc);
    out = std::move(buf).release(actual);
  }

  return out;
}",61,,389,4,,void
66770,BLOCK,-1,,"{
    ByteSource::Builder buf(length);
    size_t actual =
        StringBytes::Write(env->isolate(), buf.data<char>(), length, key, enc);
    out = std::move(buf).release(actual);
  }",78,,393,2,,void
66810,BLOCK,-1,,"{
  return IsAnyByteSource(value) ? FromBuffer(value)
                                : FromString(env, value.As<String>());
}",63,,404,3,,void
66829,BLOCK,-1,,"{
  CHECK(str->IsString());
  size_t size = str->Utf8Length(env->isolate());
  size_t alloc_size = ntc ? size + 1 : size;
  ByteSource::Builder out(alloc_size);
  int opts = String::NO_OPTIONS;
  if (!ntc) opts |= String::NO_NULL_TERMINATION;
  str->WriteUtf8(env->isolate(), out.data<char>(), alloc_size, nullptr, opts);
  return std::move(out).release();
}",45,,410,4,,void
66867,BLOCK,-1,,<empty>,13,,416,2,,void
66902,BLOCK,-1,,"{
  ArrayBufferOrViewContents<char> buf(buffer);
  return ntc ? buf.ToNullTerminatedCopy() : buf.ToByteSource();
}",66,,421,3,,void
66922,BLOCK,-1,,"{
  // A key can be passed as a string, buffer or KeyObject with type 'secret'.
  // If it is a string, we need to convert it to a buffer. We are not doing that
  // in JS to avoid creating an unprotected copy on the heap.
  return value->IsString() || IsAnyByteSource(value) ?
           ByteSource::FromStringOrBuffer(env, value) :
           ByteSource::FromSymmetricKeyObjectHandle(value);
}",25,,428,3,,void
66948,BLOCK,-1,,"{
  return Buffer::HasInstance(value) ? FromBuffer(value, true)
                                    : FromString(env, value.As<String>(), true);
}",63,,438,3,,void
66970,BLOCK,-1,,"{
  CHECK(handle->IsObject());
  KeyObjectHandle* key = Unwrap<KeyObjectHandle>(handle.As<Object>());
  CHECK_NOT_NULL(key);
  return Foreign(key->Data()->GetSymmetricKey(),
                 key->Data()->GetSymmetricKeySize());
}",74,,443,2,,void
67010,BLOCK,-1,,"{
  return ByteSource(data, data, size);
}",59,,451,3,,void
67021,BLOCK,-1,,"{
  return ByteSource(data, nullptr, size);
}",63,,455,3,,void
67034,BLOCK,-1,,"{  // NOLINT(runtime/int)
  if (err == 0) return Just(true);  // No decoration necessary.

  const char* ls = ERR_lib_error_string(err);
  const char* fs = ERR_func_error_string(err);
  const char* rs = ERR_reason_error_string(err);

  Isolate* isolate = env->isolate();
  Local<Context> context = isolate->GetCurrentContext();

  if (ls != nullptr) {
    if (obj->Set(context, env->library_string(),
                 OneByteString(isolate, ls)).IsNothing()) {
      return Nothing<bool>();
    }
  }
  if (fs != nullptr) {
    if (obj->Set(context, env->function_string(),
                 OneByteString(isolate, fs)).IsNothing()) {
      return Nothing<bool>();
    }
  }
  if (rs != nullptr) {
    if (obj->Set(context, env->reason_string(),
                 OneByteString(isolate, rs)).IsNothing()) {
      return Nothing<bool>();
    }

    // SSL has no API to recover the error name from the number, so we
    // transform reason strings like ""this error"" to ""ERR_SSL_THIS_ERROR"",
    // wh...",34,,461,4,,void
67039,BLOCK,-1,,<empty>,17,,462,2,,void
67079,BLOCK,-1,,"{
    if (obj->Set(context, env->library_string(),
                 OneByteString(isolate, ls)).IsNothing()) {
      return Nothing<bool>();
    }
  }",22,,471,2,,void
67096,BLOCK,-1,,"{
      return Nothing<bool>();
    }",59,,473,2,,void
67103,BLOCK,-1,,"{
    if (obj->Set(context, env->function_string(),
                 OneByteString(isolate, fs)).IsNothing()) {
      return Nothing<bool>();
    }
  }",22,,477,2,,void
67120,BLOCK,-1,,"{
      return Nothing<bool>();
    }",59,,479,2,,void
67127,BLOCK,-1,,"{
    if (obj->Set(context, env->reason_string(),
                 OneByteString(isolate, rs)).IsNothing()) {
      return Nothing<bool>();
    }

    // SSL has no API to recover the error name from the number, so we
    // transform reason strings like ""this error"" to ""ERR_SSL_THIS_ERROR"",
    // which ends up being close to the original error macro name.
    std::string reason(rs);

    for (auto& c : reason) {
      if (c == ' ')
        c = '_';
      else
        c = ToUpper(c);
    }

#define OSSL_ERROR_CODES_MAP(V)                                               \
    V(SYS)                                                                    \
    V(BN)                                                                     \
    V(RSA)                                                                    \
    V(DH)                                                                     \
    V(EVP)                                                                    \
    V(BUF)          ...",22,,483,2,,void
67144,BLOCK,-1,,"{
      return Nothing<bool>();
    }",59,,485,2,,void
67153,BLOCK,-1,,"{
      if (c == ' ')
        c = '_';
      else
        c = ToUpper(c);
    }",28,,494,3,,void
67158,BLOCK,-1,,<empty>,9,,496,2,,void
67163,BLOCK,-1,,<empty>,9,,498,1,,void
67179,BLOCK,-1,,{ OSSL_ERROR_CODES_MAP(V) },31,,543,2,,void
67181,BLOCK,1,,<empty>,,,,1,,void
67412,BLOCK,-1,,<empty>,7,,548,2,,void
67453,BLOCK,-1,,<empty>,7,,559,2,,void
67465,BLOCK,-1,,"{
  char message_buffer[128] = {0};
  if (err != 0 || message == nullptr) {
    ERR_error_string_n(err, message_buffer, sizeof(message_buffer));
    message = message_buffer;
  }
  HandleScope scope(env->isolate());
  Local<String> exception_string;
  Local<Value> exception;
  Local<Object> obj;
  if (!String::NewFromUtf8(env->isolate(), message).ToLocal(&exception_string))
    return;
  CryptoErrorStore errors;
  errors.Capture();
  if (!errors.ToException(env, exception_string).ToLocal(&exception) ||
      !exception->ToObject(env->context()).ToLocal(&obj) ||
      error::Decorate(env, obj, err).IsNothing()) {
    return;
  }
  env->isolate()->ThrowException(exception);
}",44,,570,4,,void
67479,BLOCK,-1,,"{
    ERR_error_string_n(err, message_buffer, sizeof(message_buffer));
    message = message_buffer;
  }",39,,572,2,,void
67525,BLOCK,-1,,<empty>,5,,581,2,,void
67571,BLOCK,-1,,"{
    return;
  }",51,,586,2,,void
67586,BLOCK,-1,,"{
  MarkPopErrorOnReturn mark_pop_error_on_return;

  EnginePointer engine(ENGINE_by_id(id));
  if (!engine) {
    // Engine not found, try loading dynamically.
    engine = EnginePointer(ENGINE_by_id(""dynamic""));
    if (engine) {
      if (!ENGINE_ctrl_cmd_string(engine.get(), ""SO_PATH"", id, 0) ||
          !ENGINE_ctrl_cmd_string(engine.get(), ""LOAD"", nullptr, 0)) {
        engine.reset();
      }
    }
  }

  if (!engine && errors != nullptr) {
    errors->Capture();
    if (errors->Empty()) {
      errors->Insert(NodeCryptoError::ENGINE_NOT_FOUND, id);
    }
  }

  return engine;
}",72,,593,3,,void
67595,BLOCK,-1,,"{
    // Engine not found, try loading dynamically.
    engine = EnginePointer(ENGINE_by_id(""dynamic""));
    if (engine) {
      if (!ENGINE_ctrl_cmd_string(engine.get(), ""SO_PATH"", id, 0) ||
          !ENGINE_ctrl_cmd_string(engine.get(), ""LOAD"", nullptr, 0)) {
        engine.reset();
      }
    }
  }",16,,597,2,,void
67603,BLOCK,-1,,"{
      if (!ENGINE_ctrl_cmd_string(engine.get(), ""SO_PATH"", id, 0) ||
          !ENGINE_ctrl_cmd_string(engine.get(), ""LOAD"", nullptr, 0)) {
        engine.reset();
      }
    }",17,,600,2,,void
67624,BLOCK,-1,,"{
        engine.reset();
      }",70,,602,2,,void
67636,BLOCK,-1,,"{
    errors->Capture();
    if (errors->Empty()) {
      errors->Insert(NodeCryptoError::ENGINE_NOT_FOUND, id);
    }
  }",37,,608,2,,void
67646,BLOCK,-1,,"{
      errors->Insert(NodeCryptoError::ENGINE_NOT_FOUND, id);
    }",26,,610,2,,void
67663,BLOCK,-1,,"{
  ClearErrorOnReturn clear_error_on_return;
  EnginePointer engine = LoadEngineById(id, errors);
  if (!engine)
    return false;

  if (!ENGINE_set_default(engine.get(), flags)) {
    if (errors != nullptr)
      errors->Capture();
    return false;
  }

  return true;
}",74,,618,4,,void
67674,BLOCK,-1,,<empty>,5,,622,2,,void
67685,BLOCK,-1,,"{
    if (errors != nullptr)
      errors->Capture();
    return false;
  }",49,,624,2,,void
67690,BLOCK,-1,,<empty>,7,,626,2,,void
67703,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args.Length() >= 2 && args[0]->IsString());
  uint32_t flags;
  if (!args[1]->Uint32Value(env->context()).To(&flags)) return;

  const node::Utf8Value engine_id(env->isolate(), args[0]);

  args.GetReturnValue().Set(SetEngine(*engine_id, flags));
}",57,,633,2,,void
67744,BLOCK,-1,,<empty>,57,,637,2,,void
67773,BLOCK,-1,,"{
  std::vector<uint8_t> buf(size);
  CHECK_EQ(BN_bn2binpad(bn, buf.data(), size), size);
  return StringBytes::Encode(
      env->isolate(),
      reinterpret_cast<const char*>(buf.data()),
      buf.size(),
      BASE64URL,
      error);
}",26,,649,5,,void
67820,BLOCK,-1,,"{
  Local<Value> value;
  Local<Value> error;
  CHECK_NOT_NULL(bn);
  if (size == 0)
    size = BN_num_bytes(bn);
  if (!EncodeBignum(env, bn, size, &error).ToLocal(&value)) {
    if (!error.IsEmpty())
      env->isolate()->ThrowException(error);
    return Nothing<bool>();
  }
  return target->Set(env->context(), name, value);
}",15,,665,6,,void
67837,BLOCK,-1,,<empty>,5,,670,2,,void
67855,BLOCK,-1,,"{
    if (!error.IsEmpty())
      env->isolate()->ThrowException(error);
    return Nothing<bool>();
  }",61,,671,2,,void
67862,BLOCK,-1,,<empty>,7,,673,2,,void
67889,BLOCK,-1,,"{
  if (label.size() != 0) {
    // OpenSSL takes ownership of the label, so we need to create a copy.
    void* label_copy = OPENSSL_memdup(label.data(), label.size());
    CHECK_NOT_NULL(label_copy);
    int ret = EVP_PKEY_CTX_set0_rsa_oaep_label(
        ctx.get(), static_cast<unsigned char*>(label_copy), label.size());
    if (ret <= 0) {
      OPENSSL_free(label_copy);
      return false;
    }
  }
  return true;
}",76,,679,3,,void
67897,BLOCK,-1,,"{
    // OpenSSL takes ownership of the label, so we need to create a copy.
    void* label_copy = OPENSSL_memdup(label.data(), label.size());
    CHECK_NOT_NULL(label_copy);
    int ret = EVP_PKEY_CTX_set0_rsa_oaep_label(
        ctx.get(), static_cast<unsigned char*>(label_copy), label.size());
    if (ret <= 0) {
      OPENSSL_free(label_copy);
      return false;
    }
  }",26,,680,2,,void
67931,BLOCK,-1,,"{
      OPENSSL_free(label_copy);
      return false;
    }",19,,686,2,,void
67942,BLOCK,-1,,"{
  CHECK(args->IsUint32());
  uint32_t mode = args.As<v8::Uint32>()->Value();
  CHECK_LE(mode, kCryptoJobSync);
  return static_cast<CryptoJobMode>(mode);
}",59,,694,2,,void
67970,BLOCK,-1,,"{
  CHECK(args[0]->IsUint32());
  Environment* env = Environment::GetCurrent(args);
  uint32_t len = args[0].As<Uint32>()->Value();
  void* data = OPENSSL_secure_zalloc(len);
  if (data == nullptr) {
    // There's no memory available for the allocation.
    // Return nothing.
    return;
  }
  std::shared_ptr<BackingStore> store =
      ArrayBuffer::NewBackingStore(
          data,
          len,
          [](void* data, size_t len, void* deleter_data) {
            OPENSSL_secure_clear_free(data, len);
          },
          data);
  Local<ArrayBuffer> buffer = ArrayBuffer::New(env->isolate(), store);
  args.GetReturnValue().Set(Uint8Array::New(buffer, 0, len));
}",60,,707,2,,void
68005,BLOCK,-1,,"{
    // There's no memory available for the allocation.
    // Return nothing.
    return;
  }",24,,712,2,,void
68056,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  if (CRYPTO_secure_malloc_initialized())
    args.GetReturnValue().Set(
        BigInt::New(env->isolate(), CRYPTO_secure_used()));
}",62,,729,2,,void
68067,BLOCK,-1,,<empty>,5,,732,2,,void
68090,BLOCK,-1,,"{
  Local<Context> context = env->context();
#ifndef OPENSSL_NO_ENGINE
  SetMethod(context, target, ""setEngine"", SetEngine);
#endif  // !OPENSSL_NO_ENGINE

  SetMethodNoSideEffect(context, target, ""getFipsCrypto"", GetFipsCrypto);
  SetMethod(context, target, ""setFipsCrypto"", SetFipsCrypto);
  SetMethodNoSideEffect(context, target, ""testFipsCrypto"", TestFipsCrypto);

  NODE_DEFINE_CONSTANT(target, kCryptoJobAsync);
  NODE_DEFINE_CONSTANT(target, kCryptoJobSync);

  SetMethod(context, target, ""secureBuffer"", SecureBuffer);
  SetMethod(context, target, ""secureHeapUsed"", SecureHeapUsed);
}",57,,738,3,,void
68126,BLOCK,1,,<empty>,,,,7,,void
68128,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kCryptoJobAsync)",3,,748,1,,void
68225,BLOCK,1,,<empty>,,,,7,,void
68227,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kCryptoJobSync)",3,,749,1,,void
68333,BLOCK,-1,,"{
#ifndef OPENSSL_NO_ENGINE
  registry->Register(SetEngine);
#endif  // !OPENSSL_NO_ENGINE

  registry->Register(GetFipsCrypto);
  registry->Register(SetFipsCrypto);
  registry->Register(TestFipsCrypto);
  registry->Register(SecureBuffer);
  registry->Register(SecureHeapUsed);
}",70,,754,2,,void
68420,BLOCK,-1,,<empty>,1,,1,1,,ANY
68451,BLOCK,-1,,<empty>,1,,1,1,,ANY
68456,BLOCK,-1,,<empty>,71,,33,2,,void
68461,BLOCK,-1,,"{
  *this = that;
}",51,,35,2,,void
68470,BLOCK,-1,,"{
  cert_.reset(that.get());

  if (cert_)
    X509_up_ref(cert_.get());

  return *this;
}",62,,39,2,,void
68481,BLOCK,-1,,<empty>,5,,43,2,,void
68494,BLOCK,-1,,"{
  // This is an approximation based on the der encoding size.
  int size = i2d_X509(cert_.get(), nullptr);
  tracker->TrackFieldWithSize(""cert"", size);
}",60,,48,2,,void
68515,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  Local<Value> ret;
  if (GetFingerprintDigest(env, algo(), cert->get()).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",59,,56,2,,void
68550,BLOCK,-1,,<empty>,5,,62,2,,void
68563,BLOCK,-1,,"{
  Local<FunctionTemplate> tmpl = env->x509_constructor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        BaseObject::kInternalFieldCount);
    tmpl->SetClassName(
        FIXED_ONE_BYTE_STRING(env->isolate(), ""X509Certificate""));
    SetProtoMethod(isolate, tmpl, ""subject"", Subject);
    SetProtoMethod(isolate, tmpl, ""subjectAltName"", SubjectAltName);
    SetProtoMethod(isolate, tmpl, ""infoAccess"", InfoAccess);
    SetProtoMethod(isolate, tmpl, ""issuer"", Issuer);
    SetProtoMethod(isolate, tmpl, ""validTo"", ValidTo);
    SetProtoMethod(isolate, tmpl, ""validFrom"", ValidFrom);
    SetProtoMethod(isolate, tmpl, ""fingerprint"", Fingerprint<EVP_sha1>);
    SetProtoMethod(isolate, tmpl, ""fingerprint256"", Fingerprint<EVP_sha256>);
    SetProtoMethod(isolate, tmpl, ""fingerprint512"", Fingerprint<EVP_sha512>);
    SetProtoMethod(isolate, tmpl, ""keyUsage"", Ke...",23,,67,2,,void
68579,BLOCK,-1,,"{
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        BaseObject::kInternalFieldCount);
    tmpl->SetClassName(
        FIXED_ONE_BYTE_STRING(env->isolate(), ""X509Certificate""));
    SetProtoMethod(isolate, tmpl, ""subject"", Subject);
    SetProtoMethod(isolate, tmpl, ""subjectAltName"", SubjectAltName);
    SetProtoMethod(isolate, tmpl, ""infoAccess"", InfoAccess);
    SetProtoMethod(isolate, tmpl, ""issuer"", Issuer);
    SetProtoMethod(isolate, tmpl, ""validTo"", ValidTo);
    SetProtoMethod(isolate, tmpl, ""validFrom"", ValidFrom);
    SetProtoMethod(isolate, tmpl, ""fingerprint"", Fingerprint<EVP_sha1>);
    SetProtoMethod(isolate, tmpl, ""fingerprint256"", Fingerprint<EVP_sha256>);
    SetProtoMethod(isolate, tmpl, ""fingerprint512"", Fingerprint<EVP_sha512>);
    SetProtoMethod(isolate, tmpl, ""keyUsage"", KeyUsage);
    SetProtoMethod(isolate, tmpl, ""serialNumber"", SerialNumber);
    SetProtoMetho...",23,,69,2,,void
68739,BLOCK,-1,,"{
  return GetConstructorTemplate(env)->HasInstance(object);
}",75,,104,3,,void
68754,BLOCK,-1,,"{
  ClearErrorOnReturn clear_error_on_return;
  X509* cert = SSL_get_certificate(ssl.get());
  if (cert == nullptr)
    return MaybeLocal<Object>();

  X509Pointer ptr(X509_dup(cert));
  return New(env, std::move(ptr));
}",28,,135,3,,void
68768,BLOCK,-1,,<empty>,5,,139,2,,void
68789,BLOCK,-1,,"{
  ClearErrorOnReturn clear_error_on_return;
  MaybeLocal<Object> maybe_cert;

  bool is_server =
      static_cast<int>(flag) & static_cast<int>(GetPeerCertificateFlag::SERVER);

  X509Pointer cert(is_server ? SSL_get_peer_certificate(ssl.get()) : nullptr);
  STACK_OF(X509)* ssl_certs = SSL_get_peer_cert_chain(ssl.get());
  if (!cert && (ssl_certs == nullptr || sk_X509_num(ssl_certs) == 0))
    return MaybeLocal<Object>();

  std::vector<Local<Value>> certs;

  if (!cert) {
    cert.reset(sk_X509_value(ssl_certs, 0));
    sk_X509_delete(ssl_certs, 0);
  }

  return sk_X509_num(ssl_certs)
      ? New(env, std::move(cert), ssl_certs)
      : New(env, std::move(cert));
}",34,,148,4,,void
68840,BLOCK,-1,,<empty>,5,,158,2,,void
68855,BLOCK,-1,,"{
    cert.reset(sk_X509_value(ssl_certs, 0));
    sk_X509_delete(ssl_certs, 0);
  }",14,,162,2,,void
68889,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsArrayBufferView());
  ArrayBufferViewContents<unsigned char> buf(args[0].As<ArrayBufferView>());
  const unsigned char* data = buf.data();
  unsigned data_len = buf.length();

  ClearErrorOnReturn clear_error_on_return;
  BIOPointer bio(LoadBIO(env, args[0]));
  if (!bio)
    return ThrowCryptoError(env, ERR_get_error());

  Local<Object> cert;

  X509Pointer pem(PEM_read_bio_X509_AUX(
      bio.get(), nullptr, NoPasswordCallback, nullptr));
  if (!pem) {
    // Try as DER, but return the original PEM failure if it isn't DER.
    MarkPopErrorOnReturn mark_here;

    X509Pointer der(d2i_X509(nullptr, &data, data_len));
    if (!der)
      return ThrowCryptoError(env, ERR_get_error());

    if (!X509Certificate::New(env, std::move(der)).ToLocal(&cert))
      return;
  } else if (!X509Certificate::New(env, std::move(pem)).ToLocal(&cert)) {
    return;
  }

  args.GetReturnValue().Set(cert);
}",70,,172,2,,void
68938,BLOCK,-1,,<empty>,5,,183,2,,void
68961,BLOCK,-1,,"{
    // Try as DER, but return the original PEM failure if it isn't DER.
    MarkPopErrorOnReturn mark_here;

    X509Pointer der(d2i_X509(nullptr, &data, data_len));
    if (!der)
      return ThrowCryptoError(env, ERR_get_error());

    if (!X509Certificate::New(env, std::move(der)).ToLocal(&cert))
      return;
  }",13,,189,2,,void
68973,BLOCK,-1,,<empty>,7,,195,2,,void
68995,BLOCK,-1,,<empty>,7,,198,2,,void
68998,BLOCK,-1,,<empty>,10,,199,1,,void
69016,BLOCK,-1,,"{
    return;
  }",73,,199,2,,void
69030,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);
  Local<Value> ret;
  if (GetSubject(env, bio, cert->get()).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",72,,206,2,,void
69049,BLOCK,-1,,<empty>,,,,2,,<empty>
69072,BLOCK,-1,,<empty>,5,,214,2,,void
69085,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);
  Local<Value> ret;
  if (GetIssuerString(env, bio, cert->get()).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",71,,217,2,,void
69104,BLOCK,-1,,<empty>,,,,2,,<empty>
69127,BLOCK,-1,,<empty>,5,,225,2,,void
69140,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);
  Local<Value> ret;
  if (GetSubjectAltNameString(env, bio, cert->get()).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",79,,228,2,,void
69159,BLOCK,-1,,<empty>,,,,2,,<empty>
69182,BLOCK,-1,,<empty>,5,,236,2,,void
69195,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);
  Local<Value> ret;
  if (GetInfoAccessString(env, bio, cert->get()).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",75,,239,2,,void
69214,BLOCK,-1,,<empty>,,,,2,,<empty>
69237,BLOCK,-1,,<empty>,5,,247,2,,void
69250,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);
  Local<Value> ret;
  if (GetValidFrom(env, cert->get(), bio).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",74,,250,2,,void
69269,BLOCK,-1,,<empty>,,,,2,,<empty>
69292,BLOCK,-1,,<empty>,5,,258,2,,void
69305,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);
  Local<Value> ret;
  if (GetValidTo(env, cert->get(), bio).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",72,,261,2,,void
69324,BLOCK,-1,,<empty>,,,,2,,<empty>
69347,BLOCK,-1,,<empty>,5,,269,2,,void
69360,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  Local<Value> ret;
  if (GetKeyUsage(env, cert->get()).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",73,,272,2,,void
69394,BLOCK,-1,,<empty>,5,,278,2,,void
69407,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  Local<Value> ret;
  if (GetSerialNumber(env, cert->get()).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",77,,281,2,,void
69441,BLOCK,-1,,<empty>,5,,287,2,,void
69454,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  Local<Value> ret;
  if (GetRawDERCertificate(env, cert->get()).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",68,,290,2,,void
69488,BLOCK,-1,,<empty>,5,,296,2,,void
69501,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());

  EVPKeyPointer pkey(X509_get_pubkey(cert->get()));
  ManagedEVPPKey epkey(std::move(pkey));
  std::shared_ptr<KeyObjectData> key_data =
      KeyObjectData::CreateAsymmetric(kKeyTypePublic, epkey);

  Local<Value> ret;
  if (KeyObjectHandle::Create(env, key_data).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",74,,299,2,,void
69563,BLOCK,-1,,<empty>,5,,311,2,,void
69576,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);
  if (PEM_write_bio_X509(bio.get(), cert->get()))
    args.GetReturnValue().Set(ToV8Value(env, bio));
}",68,,314,2,,void
69595,BLOCK,-1,,<empty>,,,,2,,<empty>
69610,BLOCK,-1,,<empty>,5,,321,2,,void
69625,BLOCK,-1,,"{
  X509Certificate* cert;
  ClearErrorOnReturn clear_error_on_return;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  args.GetReturnValue().Set(X509_check_ca(cert->get()) == 1);
}",72,,324,2,,void
69653,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());

  CHECK(args[0]->IsString());  // name
  CHECK(args[1]->IsUint32());  // flags

  Utf8Value name(env->isolate(), args[0]);
  uint32_t flags = args[1].As<Uint32>()->Value();
  char* peername;

  switch (X509_check_host(
              cert->get(),
              *name,
              name.length(),
              flags,
              &peername)) {
    case 1:  {  // Match!
      Local<Value> ret = args[0];
      if (peername != nullptr) {
        ret = OneByteString(env->isolate(), peername);
        OPENSSL_free(peername);
      }
      return args.GetReturnValue().Set(ret);
    }
    case 0:  // No Match!
      return;  // No return value is set
    case -2:  // Error!
      return THROW_ERR_INVALID_ARG_VALUE(env, ""Invalid name"");
    default:  // Error!
      return THROW_ERR_CRYPTO_OPERATION_FAILED(env);
  }
}",74,,331,2,,void
69721,BLOCK,-1,,"{
    case 1:  {  // Match!
      Local<Value> ret = args[0];
      if (peername != nullptr) {
        ret = OneByteString(env->isolate(), peername);
        OPENSSL_free(peername);
      }
      return args.GetReturnValue().Set(ret);
    }
    case 0:  // No Match!
      return;  // No return value is set
    case -2:  // Error!
      return THROW_ERR_INVALID_ARG_VALUE(env, ""Invalid name"");
    default:  // Error!
      return THROW_ERR_CRYPTO_OPERATION_FAILED(env);
  }",27,,348,2,,void
69724,BLOCK,3,,"{  // Match!
      Local<Value> ret = args[0];
      if (peername != nullptr) {
        ret = OneByteString(env->isolate(), peername);
        OPENSSL_free(peername);
      }
      return args.GetReturnValue().Set(ret);
    }",14,,349,3,,void
69738,BLOCK,-1,,"{
        ret = OneByteString(env->isolate(), peername);
        OPENSSL_free(peername);
      }",32,,351,2,,void
69776,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());

  CHECK(args[0]->IsString());  // name
  CHECK(args[1]->IsUint32());  // flags

  Utf8Value name(env->isolate(), args[0]);
  uint32_t flags = args[1].As<Uint32>()->Value();

  switch (X509_check_email(
              cert->get(),
              *name,
              name.length(),
              flags)) {
    case 1:  // Match!
      return args.GetReturnValue().Set(args[0]);
    case 0:  // No Match!
      return;  // No return value is set
    case -2:  // Error!
      return THROW_ERR_INVALID_ARG_VALUE(env, ""Invalid name"");
    default:  // Error!
      return THROW_ERR_CRYPTO_OPERATION_FAILED(env);
  }
}",75,,366,2,,void
69841,BLOCK,-1,,"{
    case 1:  // Match!
      return args.GetReturnValue().Set(args[0]);
    case 0:  // No Match!
      return;  // No return value is set
    case -2:  // Error!
      return THROW_ERR_INVALID_ARG_VALUE(env, ""Invalid name"");
    default:  // Error!
      return THROW_ERR_CRYPTO_OPERATION_FAILED(env);
  }",23,,381,2,,void
69873,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());

  CHECK(args[0]->IsString());  // IP
  CHECK(args[1]->IsUint32());  // flags

  Utf8Value name(env->isolate(), args[0]);
  uint32_t flags = args[1].As<Uint32>()->Value();

  switch (X509_check_ip_asc(cert->get(), *name, flags)) {
    case 1:  // Match!
      return args.GetReturnValue().Set(args[0]);
    case 0:  // No Match!
      return;  // No return value is set
    case -2:  // Error!
      return THROW_ERR_INVALID_ARG_VALUE(env, ""Invalid IP"");
    default:  // Error!
      return THROW_ERR_CRYPTO_OPERATION_FAILED(env);
  }
}",72,,393,2,,void
69934,BLOCK,-1,,"{
    case 1:  // Match!
      return args.GetReturnValue().Set(args[0]);
    case 0:  // No Match!
      return;  // No return value is set
    case -2:  // Error!
      return THROW_ERR_INVALID_ARG_VALUE(env, ""Invalid IP"");
    default:  // Error!
      return THROW_ERR_CRYPTO_OPERATION_FAILED(env);
  }",57,,404,2,,void
69966,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());

  CHECK(args[0]->IsObject());
  CHECK(X509Certificate::HasInstance(env, args[0].As<Object>()));

  X509Certificate* issuer;
  ASSIGN_OR_RETURN_UNWRAP(&issuer, args[0]);

  ClearErrorOnReturn clear_error_on_return;

  args.GetReturnValue().Set(
    X509_check_issued(issuer->get(), cert->get()) == X509_V_OK);
}",76,,416,2,,void
70032,BLOCK,-1,,"{
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());

  CHECK(args[0]->IsObject());
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args[0]);
  CHECK_EQ(key->Data()->GetKeyType(), kKeyTypePrivate);

  ClearErrorOnReturn clear_error_on_return;

  args.GetReturnValue().Set(
      X509_check_private_key(
          cert->get(),
          key->Data()->GetAsymmetricKey().get()) == 1);
}",80,,433,2,,void
70093,BLOCK,-1,,"{
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());

  CHECK(args[0]->IsObject());
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args[0]);
  CHECK_EQ(key->Data()->GetKeyType(), kKeyTypePublic);

  ClearErrorOnReturn clear_error_on_return;

  args.GetReturnValue().Set(
      X509_verify(
          cert->get(),
          key->Data()->GetAsymmetricKey().get()) > 0);
}",71,,450,2,,void
70154,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  ClearErrorOnReturn clear_error_on_return;
  Local<Value> ret;
  if (X509ToObject(env, cert->get()).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",73,,467,2,,void
70189,BLOCK,-1,,<empty>,5,,474,2,,void
70202,BLOCK,-1,,"{
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  if (cert->issuer_cert_)
    args.GetReturnValue().Set(cert->issuer_cert_->object());
}",78,,477,2,,void
70215,BLOCK,-1,,<empty>,5,,481,2,,void
70234,BLOCK,-1,,"{
  tracker->TrackField(""cert"", cert_);
}",64,,505,2,,void
70247,BLOCK,-1,,"{
  if (context != env->context()) {
    THROW_ERR_MESSAGE_TARGET_CONTEXT_UNAVAILABLE(env);
    return {};
  }

  Local<Value> handle;
  if (!X509Certificate::New(env, data_).ToLocal(&handle))
    return {};

  return BaseObjectPtr<BaseObject>(
      Unwrap<X509Certificate>(handle.As<Object>()));
}",49,,513,4,,void
70255,BLOCK,-1,,"{
    THROW_ERR_MESSAGE_TARGET_CONTEXT_UNAVAILABLE(env);
    return {};
  }",34,,514,2,,void
70277,BLOCK,-1,,<empty>,5,,521,2,,void
70295,BLOCK,-1,,"{
  return BaseObject::TransferMode::kCloneable;
}",67,,528,1,,void
70305,BLOCK,-1,,"{
  return std::make_unique<X509CertificateTransferData>(cert_);
}",11,,533,1,,void
70319,BLOCK,-1,,"{
  SetMethod(env->context(), target, ""parseX509"", X509Certificate::Parse);

  NODE_DEFINE_CONSTANT(target, X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT);
  NODE_DEFINE_CONSTANT(target, X509_CHECK_FLAG_NEVER_CHECK_SUBJECT);
  NODE_DEFINE_CONSTANT(target, X509_CHECK_FLAG_NO_WILDCARDS);
  NODE_DEFINE_CONSTANT(target, X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS);
  NODE_DEFINE_CONSTANT(target, X509_CHECK_FLAG_MULTI_LABEL_WILDCARDS);
  NODE_DEFINE_CONSTANT(target, X509_CHECK_FLAG_SINGLE_LABEL_SUBDOMAINS);
}",74,,538,3,,void
70352,BLOCK,-1,,"{
  registry->Register(X509Certificate::Parse);
  registry->Register(Subject);
  registry->Register(SubjectAltName);
  registry->Register(InfoAccess);
  registry->Register(Issuer);
  registry->Register(ValidTo);
  registry->Register(ValidFrom);
  registry->Register(Fingerprint<EVP_sha1>);
  registry->Register(Fingerprint<EVP_sha256>);
  registry->Register(Fingerprint<EVP_sha512>);
  registry->Register(KeyUsage);
  registry->Register(SerialNumber);
  registry->Register(Pem);
  registry->Register(Raw);
  registry->Register(PublicKey);
  registry->Register(CheckCA);
  registry->Register(CheckHost);
  registry->Register(CheckEmail);
  registry->Register(CheckIP);
  registry->Register(CheckIssued);
  registry->Register(CheckPrivateKey);
  registry->Register(Verify);
  registry->Register(ToLegacy);
  registry->Register(GetIssuerCert);
}",42,,550,2,,void
70493,BLOCK,-1,,<empty>,1,,1,1,,ANY
70497,BLOCK,-1,,<empty>,73,,211,2,,void
70504,BLOCK,-1,,<empty>,75,,224,2,,void
70510,BLOCK,-1,,<empty>,59,,240,2,,void
70516,BLOCK,-1,,<empty>,62,,272,2,,void
70525,BLOCK,-1,,"{
          pull_pending_ = false;
          // In each of these cases, we do not expect that the source will
          // actually have provided any actual data.
          CHECK_IMPLIES(status == bob::Status::STATUS_BLOCK ||
                            status == bob::Status::STATUS_WAIT ||
                            status == bob::Status::STATUS_EOS,
                        vecs == nullptr && count == 0);
          if (status == bob::Status::STATUS_EOS) {
            uint32_t current = current_index_.value() + 1;
            current_reader_ = nullptr;
            // We have reached the end of this entry. If this is the last entry,
            // then we are done. Otherwise, we advance the current_index_, clear
            // the current_reader_ and wait for the next read.

            if (current == data_queue_->entries_.size()) {
              // Yes, this was the final entry. We're all done.
              ended_ = true;
            } else {
              // This was not the fina...",80,,248,5,,void
70568,BLOCK,-1,,"{
            uint32_t current = current_index_.value() + 1;
            current_reader_ = nullptr;
            // We have reached the end of this entry. If this is the last entry,
            // then we are done. Otherwise, we advance the current_index_, clear
            // the current_reader_ and wait for the next read.

            if (current == data_queue_->entries_.size()) {
              // Yes, this was the final entry. We're all done.
              ended_ = true;
            } else {
              // This was not the final entry, so we update the index and
              // continue on by performing another read.
              current_index_ = current;
              status = bob::STATUS_CONTINUE;
            }
            std::move(next)(status, nullptr, 0, [](uint64_t) {});
            return;
          }",50,,256,2,,void
70590,BLOCK,-1,,"{
              // Yes, this was the final entry. We're all done.
              ended_ = true;
            }",58,,263,2,,void
70595,BLOCK,-1,,"{
              // This was not the final entry, so we update the index and
              // continue on by performing another read.
              current_index_ = current;
              status = bob::STATUS_CONTINUE;
            }",20,,266,1,,void
70637,BLOCK,-1,,<empty>,73,,364,2,,void
70644,BLOCK,-1,,<empty>,77,,377,2,,void
70650,BLOCK,-1,,<empty>,67,,390,2,,void
70656,BLOCK,-1,,<empty>,73,,403,2,,void
70662,BLOCK,-1,,<empty>,59,,409,2,,void
70668,BLOCK,-1,,<empty>,62,,432,2,,void
70677,BLOCK,-1,,"{
          pull_pending_ = false;

          // In each of these cases, we do not expect that the source will
          // actually have provided any actual data.
          CHECK_IMPLIES(status == bob::Status::STATUS_BLOCK ||
                            status == bob::Status::STATUS_WAIT ||
                            status == bob::Status::STATUS_EOS,
                        vecs == nullptr && count == 0);
          if (status == bob::Status::STATUS_EOS) {
            data_queue_->entries_.erase(data_queue_->entries_.begin());
            ended_ = data_queue_->entries_.empty();
            current_reader_ = nullptr;
            if (!ended_) status = bob::Status::STATUS_CONTINUE;
            std::move(next)(status, nullptr, 0, [](uint64_t) {});
            return;
          }

          // Now that we have updated this readers state, we can forward
          // everything on to the outer next.
          std::move(next)(status, vecs, count, std::move(done));
        }",80,,418,5,,void
70720,BLOCK,-1,,"{
            data_queue_->entries_.erase(data_queue_->entries_.begin());
            ended_ = data_queue_->entries_.empty();
            current_reader_ = nullptr;
            if (!ended_) status = bob::Status::STATUS_CONTINUE;
            std::move(next)(status, nullptr, 0, [](uint64_t) {});
            return;
          }",50,,427,2,,void
70747,BLOCK,-1,,<empty>,26,,431,2,,void
70788,BLOCK,-1,,<empty>,75,,516,2,,void
70795,BLOCK,-1,,<empty>,66,,522,2,,void
70801,BLOCK,-1,,<empty>,75,,586,2,,void
70809,BLOCK,-1,,"{
      if (len == 0) {
        return std::make_unique<EmptyEntry>();
      }

      return std::make_unique<InMemoryEntry>(backing_store_, start, len);
    }",72,,638,3,,void
70814,BLOCK,-1,,"{
        return std::make_unique<EmptyEntry>();
      }",21,,639,2,,void
70838,BLOCK,-1,,{ uv_fs_req_cleanup(&req); },37,,791,1,,void
70848,BLOCK,-1,,{ uv_fs_req_cleanup(&req); },37,,853,1,,void
70857,BLOCK,-1,,{ uv_fs_req_cleanup(&req); },39,,870,1,,void
70868,BLOCK,-1,,<empty>,69,,921,2,,void
70874,BLOCK,-1,,<empty>,77,,927,2,,void
70880,BLOCK,-1,,<empty>,67,,929,2,,void
70886,BLOCK,-1,,<empty>,60,,939,2,,void
70892,BLOCK,-1,,<empty>,67,,953,2,,void
70898,BLOCK,-1,,<empty>,61,,959,2,,void
70904,BLOCK,-1,,<empty>,75,,1000,2,,void
70909,BLOCK,-1,,{ pending_pulls_.pop_front(); },38,,1018,1,,void
70919,BLOCK,-1,,"{
    if (item == nullptr || !item->is_idempotent()) {
      return true;  // true means the entry is not valid here.
    }

    // To keep from having to iterate over the entries
    // again, we'll try calculating the size. If any
    // of the entries are unable to provide a size, then
    // we assume we cannot safely treat this entry as
    // idempotent even if it claims to be.
    if (item->size().has_value()) {
      size += item->size().value();
    } else {
      return true;  // true means the entry is not valid here.
    }

    return false;
  }",46,,1037,2,,void
70930,BLOCK,-1,,"{
      return true;  // true means the entry is not valid here.
    }",52,,1038,2,,void
70941,BLOCK,-1,,"{
      size += item->size().value();
    }",35,,1047,2,,void
70952,BLOCK,-1,,"{
      return true;  // true means the entry is not valid here.
    }",12,,1049,1,,void
71002,BLOCK,-1,,<empty>,1,,1,1,,ANY
71009,BLOCK,-1,,<empty>,,,,1,,<empty>
71016,BLOCK,-1,,<empty>,25,,47,3,,void
71021,BLOCK,-1,,<empty>,57,,55,2,,void
71026,BLOCK,-1,,<empty>,,,,2,,<empty>
71031,BLOCK,-1,,<empty>,,,,2,,<empty>
71036,BLOCK,-1,,<empty>,,,,2,,<empty>
71041,BLOCK,-1,,<empty>,,,,2,,<empty>
71047,BLOCK,-1,,"{
    // If the data queue is not idempotent, or the size cannot be determined,
    // we cannot reasonably create a slice. Therefore, return nothing.
    if (!idempotent_ || !size_.has_value()) return nullptr;

    uint64_t size = size_.value();

    // start cannot be greater than the size.
    start = std::min(start, size);

    uint64_t end = std::max(start, std::min(maybeEnd.value_or(size), size));

    DCHECK_LE(start, end);

    uint64_t len = end - start;
    uint64_t remaining = end - start;
    std::vector<std::unique_ptr<Entry>> slices;

    if (remaining > 0) {
      for (const auto& entry : entries_) {
        // The size of every entry should be known since this is an
        // idempotent queue.
        uint64_t entrySize = entry->size().value();
        if (start > entrySize) {
          start -= entrySize;
          continue;
        }

        uint64_t chunkStart = start;
        uint64_t len = std::min(remaining, entrySize - chunkStart);
        slices.emplace_bac...",65,,65,3,,void
71057,BLOCK,-1,,<empty>,45,,68,2,,void
71123,BLOCK,-1,,"{
      for (const auto& entry : entries_) {
        // The size of every entry should be known since this is an
        // idempotent queue.
        uint64_t entrySize = entry->size().value();
        if (start > entrySize) {
          start -= entrySize;
          continue;
        }

        uint64_t chunkStart = start;
        uint64_t len = std::min(remaining, entrySize - chunkStart);
        slices.emplace_back(entry->slice(chunkStart, chunkStart + len));
        remaining -= len;
        start = 0;

        if (remaining == 0) break;
      }
    }",24,,83,2,,void
71127,BLOCK,-1,,"{
        // The size of every entry should be known since this is an
        // idempotent queue.
        uint64_t entrySize = entry->size().value();
        if (start > entrySize) {
          start -= entrySize;
          continue;
        }

        uint64_t chunkStart = start;
        uint64_t len = std::min(remaining, entrySize - chunkStart);
        slices.emplace_back(entry->slice(chunkStart, chunkStart + len));
        remaining -= len;
        start = 0;

        if (remaining == 0) break;
      }",42,,84,3,,void
71142,BLOCK,-1,,"{
          start -= entrySize;
          continue;
        }",32,,88,2,,void
71184,BLOCK,-1,,<empty>,29,,99,2,,void
71204,BLOCK,-1,,{ return size_; },49,,106,1,,void
71210,BLOCK,-1,,{ return idempotent_; },39,,108,1,,void
71216,BLOCK,-1,,{ return capped_size_.has_value(); },35,,110,1,,void
71226,BLOCK,-1,,"{
    if (idempotent_) return std::nullopt;
    if (!entry) return false;

    // If this entry successfully provides a size, we can add it to our size_
    // if that has a value, otherwise, we keep uint64_t empty.
    if (entry->size().has_value() && size_.has_value()) {
      uint64_t entrySize = entry->size().value();
      uint64_t size = size_.value();
      // If capped_size_ is set, size + entrySize cannot exceed capped_size_
      // or the entry cannot be added.
      if (capped_size_.has_value() &&
          (capped_size_.value() < entrySize + size)) {
        return false;
      }
      size_ = size + entrySize;
    } else {
      // This entry cannot provide a size. We can still add it but we have to
      // clear the known size.
      size_ = std::nullopt;
    }

    entries_.push_back(std::move(entry));
    return true;
  }",69,,112,2,,void
71229,BLOCK,-1,,<empty>,22,,113,2,,void
71237,BLOCK,-1,,<empty>,17,,114,2,,void
71253,BLOCK,-1,,"{
      uint64_t entrySize = entry->size().value();
      uint64_t size = size_.value();
      // If capped_size_ is set, size + entrySize cannot exceed capped_size_
      // or the entry cannot be added.
      if (capped_size_.has_value() &&
          (capped_size_.value() < entrySize + size)) {
        return false;
      }
      size_ = size + entrySize;
    }",57,,118,2,,void
71285,BLOCK,-1,,"{
        return false;
      }",54,,124,2,,void
71294,BLOCK,-1,,"{
      // This entry cannot provide a size. We can still add it but we have to
      // clear the known size.
      size_ = std::nullopt;
    }",12,,128,1,,void
71315,BLOCK,-1,,"{
    if (is_idempotent()) return;
    // If the data queue is already capped, it is possible to call
    // cap again with a smaller size.
    if (capped_size_.has_value()) {
      capped_size_ = std::min(limit, capped_size_.value());
      return;
    }

    // Otherwise just set the limit.
    capped_size_ = limit;
  }",41,,138,2,,void
71318,BLOCK,-1,,<empty>,26,,139,2,,void
71325,BLOCK,-1,,"{
      capped_size_ = std::min(limit, capped_size_.value());
      return;
    }",35,,142,2,,void
71344,BLOCK,-1,,"{
    if (capped_size_.has_value() && size_.has_value()) {
      uint64_t capped_size = capped_size_.value();
      uint64_t size = size_.value();
      return capped_size > size ? capped_size - size : 0UL;
    }
    return std::nullopt;
  }",62,,151,1,,void
71355,BLOCK,-1,,"{
      uint64_t capped_size = capped_size_.value();
      uint64_t size = size_.value();
      return capped_size > size ? capped_size - size : 0UL;
    }",56,,152,2,,void
71387,BLOCK,-1,,"{
    tracker->TrackField(
        ""entries"", entries_, ""std::vector<std::unique_ptr<Entry>>"");
  }",64,,160,2,,void
71398,BLOCK,-1,,<empty>,,,,1,,<empty>
71414,BLOCK,-1,,<empty>,,,,1,,<empty>
71432,BLOCK,-1,,"{
    CHECK(data_queue_->is_idempotent());
  }",44,,190,2,,void
71442,BLOCK,-1,,<empty>,,,,2,,<empty>
71447,BLOCK,-1,,<empty>,,,,2,,<empty>
71452,BLOCK,-1,,<empty>,,,,2,,<empty>
71457,BLOCK,-1,,<empty>,,,,2,,<empty>
71464,BLOCK,-1,,"{
    std::shared_ptr<DataQueue::Reader> self = shared_from_this();

    // If ended is true, this reader has already reached the end and cannot
    // provide any more data.
    if (ended_) {
      std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
      return bob::Status::STATUS_EOS;
    }

    // If this is the first pull from this reader, we are first going to
    // check to see if there is anything at all to actually do.
    if (!current_index_.has_value()) {
      // First, let's check the number of entries. If there are no entries,
      // we've reached the end and have nothing to do.
      // Because this is an idempotent dataqueue, we should always know the
      // size...
      if (data_queue_->entries_.empty()) {
        ended_ = true;
        std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        return bob::Status::STATUS_EOS;
      }

      current_index_ = 0;
    }

    // We have current_index_, awesome, we are going to...",65,,205,6,,void
71478,BLOCK,-1,,"{
      std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
      return bob::Status::STATUS_EOS;
    }",17,,210,2,,void
71505,BLOCK,-1,,"{
      // First, let's check the number of entries. If there are no entries,
      // we've reached the end and have nothing to do.
      // Because this is an idempotent dataqueue, we should always know the
      // size...
      if (data_queue_->entries_.empty()) {
        ended_ = true;
        std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        return bob::Status::STATUS_EOS;
      }

      current_index_ = 0;
    }",38,,217,2,,void
71513,BLOCK,-1,,"{
        ended_ = true;
        std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        return bob::Status::STATUS_EOS;
      }",42,,222,2,,void
71548,BLOCK,-1,,"{
      // Getting the current reader for an entry could fail for several
      // reasons. For an FdEntry, for instance, getting the reader may
      // fail if the file has been modified since the FdEntry was created.
      // We handle the case simply by erroring.
      std::move(next)(UV_EINVAL, nullptr, 0, [](uint64_t) {});
      return UV_EINVAL;
    }",36,,235,2,,void
71581,BLOCK,-1,,"{
      if (!ended_) return bob::Status::STATUS_CONTINUE;
      // For all other status, we just fall through and return it straightaway.
    }",25,,285,2,,void
71585,BLOCK,-1,,<empty>,20,,286,2,,void
71597,BLOCK,-1,,"{
    CHECK(!ended_);
    CHECK(current_index_.has_value());
    if (current_reader_ == nullptr) {
      auto& entry = data_queue_->entries_[current_index_.value()];
      // Because this is an idempotent reader, let's just be sure to
      // doublecheck that the entry itself is actually idempotent
      DCHECK(entry->is_idempotent());
      current_reader_ = static_cast<EntryImpl&>(*entry).get_reader();
    }
    return current_reader_.get();
  }",41,,308,1,,void
71610,BLOCK,-1,,"{
      auto& entry = data_queue_->entries_[current_index_.value()];
      // Because this is an idempotent reader, let's just be sure to
      // doublecheck that the entry itself is actually idempotent
      DCHECK(entry->is_idempotent());
      current_reader_ = static_cast<EntryImpl&>(*entry).get_reader();
    }",37,,311,2,,void
71649,BLOCK,-1,,<empty>,,,,1,,<empty>
71668,BLOCK,-1,,"{
    CHECK(!data_queue_->is_idempotent());
  }",44,,342,2,,void
71679,BLOCK,-1,,<empty>,,,,2,,<empty>
71684,BLOCK,-1,,<empty>,,,,2,,<empty>
71689,BLOCK,-1,,<empty>,,,,2,,<empty>
71694,BLOCK,-1,,<empty>,,,,2,,<empty>
71701,BLOCK,-1,,"{
    std::shared_ptr<DataQueue::Reader> self = shared_from_this();

    // If ended is true, this reader has already reached the end and cannot
    // provide any more data.
    if (ended_) {
      std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
      return bob::Status::STATUS_EOS;
    }

    // If the collection of entries is empty, there's nothing currently left to
    // read. How we respond depends on whether the data queue has been capped
    // or not.
    if (data_queue_->entries_.empty()) {
      // If the data_queue_ is empty, and not capped, then we can reasonably
      // expect more data to be provided later, but we don't know exactly when
      // that'll happe, so the proper response here is to return a blocked
      // status.
      if (!data_queue_->is_capped()) {
        std::move(next)(bob::Status::STATUS_BLOCK, nullptr, 0, [](uint64_t) {});
        return bob::STATUS_BLOCK;
      }

      // However, if we are capped, the status will depen...",65,,358,6,,void
71715,BLOCK,-1,,"{
      std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
      return bob::Status::STATUS_EOS;
    }",17,,363,2,,void
71743,BLOCK,-1,,"{
      // If the data_queue_ is empty, and not capped, then we can reasonably
      // expect more data to be provided later, but we don't know exactly when
      // that'll happe, so the proper response here is to return a blocked
      // status.
      if (!data_queue_->is_capped()) {
        std::move(next)(bob::Status::STATUS_BLOCK, nullptr, 0, [](uint64_t) {});
        return bob::STATUS_BLOCK;
      }

      // However, if we are capped, the status will depend on whether the size
      // of the data_queue_ is known or not.

      if (data_queue_->size().has_value()) {
        // If the size is known, and it is still less than the cap, then we
        // still might get more data. We just don't know exactly when that'll
        // come, so let's return a blocked status.
        if (data_queue_->size().value() < data_queue_->capped_size_.value()) {
          std::move(next)(
              bob::Status::STATUS_BLOCK, nullptr, 0, [](uint64_t) {});
          return bob::STATUS_BLO...",40,,371,2,,void
71750,BLOCK,-1,,"{
        std::move(next)(bob::Status::STATUS_BLOCK, nullptr, 0, [](uint64_t) {});
        return bob::STATUS_BLOCK;
      }",38,,376,2,,void
71777,BLOCK,-1,,"{
        // If the size is known, and it is still less than the cap, then we
        // still might get more data. We just don't know exactly when that'll
        // come, so let's return a blocked status.
        if (data_queue_->size().value() < data_queue_->capped_size_.value()) {
          std::move(next)(
              bob::Status::STATUS_BLOCK, nullptr, 0, [](uint64_t) {});
          return bob::STATUS_BLOCK;
        }

        // Otherwise, if size is equal to or greater than capped, we are done.
        // Fall through to allow the end handling to run.
      }",44,,384,2,,void
71793,BLOCK,-1,,"{
          std::move(next)(
              bob::Status::STATUS_BLOCK, nullptr, 0, [](uint64_t) {});
          return bob::STATUS_BLOCK;
        }",78,,388,2,,void
71844,BLOCK,-1,,"{
      std::move(next)(UV_EINVAL, nullptr, 0, [](uint64_t) {});
      return UV_EINVAL;
    }",36,,408,2,,void
71877,BLOCK,-1,,"{
      // The callback was resolved synchronously. Let's check our status.
      if (!ended_) return bob::Status::STATUS_CONTINUE;
      // For all other status, we just fall through and return it straightaway.
    }",25,,445,2,,void
71881,BLOCK,-1,,<empty>,20,,447,2,,void
71893,BLOCK,-1,,"{
    CHECK(!ended_);
    CHECK(!data_queue_->entries_.empty());
    if (current_reader_ == nullptr) {
      auto& entry = data_queue_->entries_.front();
      current_reader_ = static_cast<EntryImpl&>(*entry).get_reader();
    }
    return current_reader_.get();
  }",41,,469,1,,void
71909,BLOCK,-1,,"{
      auto& entry = data_queue_->entries_.front();
      current_reader_ = static_cast<EntryImpl&>(*entry).get_reader();
    }",37,,472,2,,void
71940,BLOCK,-1,,<empty>,,,,1,,<empty>
71953,BLOCK,-1,,"{
  if (is_idempotent()) {
    return std::make_shared<IdempotentDataQueueReader>(shared_from_this());
  }

  if (locked_to_reader_) return nullptr;
  locked_to_reader_ = true;

  return std::make_shared<NonIdempotentDataQueueReader>(shared_from_this());
}",64,,490,1,,void
71956,BLOCK,-1,,"{
    return std::make_shared<IdempotentDataQueueReader>(shared_from_this());
  }",24,,491,2,,void
71967,BLOCK,-1,,<empty>,26,,495,2,,void
71990,BLOCK,-1,,"{
      auto self = shared_from_this();
      if (ended_) {
        std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        return bob::Status::STATUS_EOS;
      }

      ended_ = true;
      std::move(next)(
          bob::Status::STATUS_CONTINUE, nullptr, 0, [](uint64_t) {});
      return bob::Status::STATUS_CONTINUE;
    }",67,,513,6,,void
71997,BLOCK,-1,,"{
        std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        return bob::Status::STATUS_EOS;
      }",19,,515,2,,void
72045,BLOCK,-1,,<empty>,,,,1,,<empty>
72050,BLOCK,-1,,<empty>,,,,2,,<empty>
72055,BLOCK,-1,,<empty>,,,,2,,<empty>
72060,BLOCK,-1,,<empty>,,,,2,,<empty>
72065,BLOCK,-1,,<empty>,,,,2,,<empty>
72069,BLOCK,-1,,"{
    return std::make_shared<EmptyReader>();
  }",60,,542,1,,void
72080,BLOCK,-1,,"{
    if (start != 0) return nullptr;
    return std::make_unique<EmptyEntry>();
  }",65,,548,3,,void
72085,BLOCK,-1,,<empty>,21,,549,2,,void
72096,BLOCK,-1,,{ return 0; },49,,553,1,,void
72102,BLOCK,-1,,{ return true; },39,,555,1,,void
72112,BLOCK,-1,,{ backing_store = nullptr; },31,,570,2,,void
72120,BLOCK,-1,,<empty>,58,,577,2,,void
72129,BLOCK,-1,,"{
      auto self = shared_from_this();
      if (ended_) {
        std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        return bob::Status::STATUS_EOS;
      }

      ended_ = true;
      DataQueue::Vec vec{
          reinterpret_cast<uint8_t*>(entry_.backing_store_->Data()) +
              entry_.offset_,
          entry_.byte_length_,
      };

      std::move(next)(bob::Status::STATUS_CONTINUE,
                      &vec,
                      1,
                      InMemoryFunctor({entry_.backing_store_}));
      return bob::Status::STATUS_CONTINUE;
    }",67,,583,6,,void
72136,BLOCK,-1,,"{
        std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        return bob::Status::STATUS_EOS;
      }",19,,585,2,,void
72209,BLOCK,-1,,<empty>,,,,1,,<empty>
72219,BLOCK,-1,,"{
    // The offset_ + byte_length_ cannot extend beyond the size of the
    // backing store, because that would just be silly.
    CHECK_LE(offset_ + byte_length_, backing_store_->ByteLength());
  }",35,,618,4,,void
72232,BLOCK,-1,,<empty>,,,,2,,<empty>
72237,BLOCK,-1,,<empty>,,,,2,,<empty>
72242,BLOCK,-1,,<empty>,,,,2,,<empty>
72247,BLOCK,-1,,<empty>,,,,2,,<empty>
72251,BLOCK,-1,,"{
    return std::make_shared<InMemoryReader>(*this);
  }",60,,630,1,,void
72265,BLOCK,-1,,"{
    const auto makeEntry = [&](uint64_t start,
                               uint64_t len) -> std::unique_ptr<Entry> {
      if (len == 0) {
        return std::make_unique<EmptyEntry>();
      }

      return std::make_unique<InMemoryEntry>(backing_store_, start, len);
    };

    start += offset_;

    // The start cannot extend beyond the maximum end point of this entry.
    start = std::min(start, offset_ + byte_length_);

    if (maybeEnd.has_value()) {
      uint64_t end = maybeEnd.value();
      // The end cannot extend beyond the maximum end point of this entry,
      // and the end must be equal to or greater than the start.
      end = std::max(start, std::min(offset_ + end, offset_ + byte_length_));

      return makeEntry(start, end - start);
    }

    // If no end is given, then the new length is the current length
    // minus the adjusted start.
    return makeEntry(start, byte_length_ - start);
  }",65,,636,3,,void
72288,BLOCK,-1,,"{
      uint64_t end = maybeEnd.value();
      // The end cannot extend beyond the maximum end point of this entry,
      // and the end must be equal to or greater than the start.
      end = std::max(start, std::min(offset_ + end, offset_ + byte_length_));

      return makeEntry(start, end - start);
    }",31,,651,2,,void
72328,BLOCK,-1,,{ return byte_length_; },49,,665,1,,void
72334,BLOCK,-1,,{ return true; },39,,667,1,,void
72341,BLOCK,-1,,"{
    tracker->TrackField(
        ""store"", backing_store_, ""std::shared_ptr<v8::BackingStore>"");
  }",64,,669,2,,void
72362,BLOCK,-1,,"{
    CHECK(data_queue_);
  }",44,,691,2,,void
72369,BLOCK,-1,,<empty>,,,,2,,<empty>
72374,BLOCK,-1,,<empty>,,,,2,,<empty>
72379,BLOCK,-1,,<empty>,,,,2,,<empty>
72384,BLOCK,-1,,<empty>,,,,2,,<empty>
72388,BLOCK,-1,,"{
    return std::make_shared<ReaderImpl>(data_queue_->get_reader());
  }",60,,701,1,,void
72405,BLOCK,-1,,"{
    std::shared_ptr<DataQueue> sliced = data_queue_->slice(start, end);
    if (!sliced) return nullptr;

    return std::make_unique<DataQueueEntry>(std::move(sliced));
  }",76,,706,3,,void
72423,BLOCK,-1,,<empty>,18,,708,2,,void
72441,BLOCK,-1,,{ return data_queue_->size(); },49,,719,1,,void
72450,BLOCK,-1,,{ return data_queue_->is_idempotent(); },39,,727,1,,void
72460,BLOCK,-1,,"{
    tracker->TrackField(
        ""data_queue"", data_queue_, ""std::shared_ptr<DataQueue>"");
  }",64,,729,2,,void
72471,BLOCK,-1,,{ return *data_queue_; },29,,734,1,,void
72485,BLOCK,-1,,<empty>,36,,746,2,,void
72494,BLOCK,-1,,"{
      auto self = shared_from_this();
      return inner_->Pull(
          std::move(next), options, data, count, max_count_hint);
    }",46,,752,6,,void
72519,BLOCK,-1,,"{
    // We're only going to create the FdEntry if the file exists.
    uv_fs_t req = uv_fs_t();
    auto cleanup = OnScopeLeave([&] { uv_fs_req_cleanup(&req); });

    auto buf = std::make_shared<BufferValue>(env->isolate(), path);
    if (uv_fs_stat(nullptr, &req, buf->out(), nullptr) < 0) return nullptr;

    return std::make_unique<FdEntry>(
        env, std::move(buf), req.statbuf, 0, req.statbuf.st_size);
  }",79,,788,3,,void
72556,BLOCK,-1,,<empty>,61,,794,2,,void
72591,BLOCK,-1,,<empty>,19,,809,6,,void
72595,BLOCK,-1,,"{
    return ReaderImpl::Create(this);
  }",60,,811,1,,void
72607,BLOCK,-1,,"{
    uint64_t new_start = start_ + start;
    uint64_t new_end = end_;
    if (end.has_value()) {
      new_end = std::min(end.value(), end_);
    }

    CHECK(new_start >= start_);
    CHECK(new_end <= end_);

    return std::make_unique<FdEntry>(env_, path_, stat_, new_start, new_end);
  }",76,,816,3,,void
72623,BLOCK,-1,,"{
      new_end = std::min(end.value(), end_);
    }",26,,819,2,,void
72660,BLOCK,-1,,{ return end_ - start_; },49,,829,1,,void
72668,BLOCK,-1,,{ return true; },39,,831,1,,void
72674,BLOCK,-1,,{ return env_; },28,,833,1,,void
72686,BLOCK,-1,,"{
    return other.st_size != stat_.st_size ||
           other.st_mtim.tv_nsec != stat_.st_mtim.tv_nsec;
  }",44,,846,2,,void
72712,BLOCK,-1,,"{
    uv_fs_t req = uv_fs_t();
    auto cleanup = OnScopeLeave([&] { uv_fs_req_cleanup(&req); });
    // TODO(jasnell): Note the use of a sync fs call here is a bit unfortunate.
    // Doing this asynchronously creates a bit of a race condition tho, a file
    // could be unmodified when we call the operation but then by the time the
    // async callback is triggered to give us that answer the file is modified.
    // While such silliness is still possible here, the sync call at least makes
    // it less likely to hit the race.
    if (uv_fs_fstat(nullptr, &req, fd, nullptr) < 0) return true;
    return entry->is_modified(req.statbuf);
  }",53,,851,3,,void
72730,BLOCK,-1,,<empty>,54,,860,2,,void
72745,BLOCK,-1,,"{
      uv_fs_t req;
      auto cleanup = OnScopeLeave([&] { uv_fs_req_cleanup(&req); });
      int file =
          uv_fs_open(nullptr, &req, entry->path_->out(), O_RDONLY, 0, nullptr);
      if (file < 0 || FdEntry::CheckModified(entry, file)) {
        uv_fs_close(nullptr, &req, file, nullptr);
        return nullptr;
      }
      Realm* realm = entry->env()->principal_realm();
      return std::make_shared<ReaderImpl>(
          BaseObjectPtr<fs::FileHandle>(fs::FileHandle::New(
              realm->GetBindingData<fs::BindingData>(realm->context()),
              file,
              Local<Object>(),
              entry->start_,
              entry->end_ - entry->start_)),
          entry);
    }",63,,868,2,,void
72778,BLOCK,-1,,"{
        uv_fs_close(nullptr, &req, file, nullptr);
        return nullptr;
      }",60,,873,2,,void
72848,BLOCK,-1,,"{
      handle_->PushStreamListener(this);
      handle_->env()->AddCleanupHook(cleanup, this);
    }",74,,889,3,,void
72866,BLOCK,-1,,"{
      handle_->env()->RemoveCleanupHook(cleanup, this);
      DrainAndClose();
      handle_->RemoveStreamListener(this);
    }",28,,894,1,,void
72886,BLOCK,-1,,"{
      return env_->allocate_managed_buffer(suggested_size);
    }",60,,900,2,,void
72898,BLOCK,-1,,"{
      std::shared_ptr<v8::BackingStore> store =
          env_->release_managed_buffer(buf);

      if (ended_) {
        // If we got here and ended_ is true, it means we ended and drained
        // while the read was pending. We're just going to do nothing.
        CHECK(pending_pulls_.empty());
        return;
      }

      CHECK(reading_);
      auto pending = DequeuePendingPull();

      if (CheckModified(entry_, handle_->GetFD())) {
        DrainAndClose();
        // The file was modified while the read was pending. We need to error.
        std::move(pending.next)(UV_EINVAL, nullptr, 0, [](uint64_t) {});
        return;
      }

      if (nread < 0) {
        if (nread == UV_EOF) {
          std::move(pending.next)(bob::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        } else {
          std::move(pending.next)(nread, nullptr, 0, [](uint64_t) {});
        }

        return DrainAndClose();
      }

      DataQueue::Vec vec;
      vec.base = static_cast<uint8_t*>(store->D...",68,,904,3,,void
72916,BLOCK,-1,,"{
        // If we got here and ended_ is true, it means we ended and drained
        // while the read was pending. We're just going to do nothing.
        CHECK(pending_pulls_.empty());
        return;
      }",19,,908,2,,void
72936,BLOCK,-1,,"{
        DrainAndClose();
        // The file was modified while the read was pending. We need to error.
        std::move(pending.next)(UV_EINVAL, nullptr, 0, [](uint64_t) {});
        return;
      }",52,,918,2,,void
72955,BLOCK,-1,,"{
        if (nread == UV_EOF) {
          std::move(pending.next)(bob::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        } else {
          std::move(pending.next)(nread, nullptr, 0, [](uint64_t) {});
        }

        return DrainAndClose();
      }",22,,925,2,,void
72960,BLOCK,-1,,"{
          std::move(pending.next)(bob::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        }",30,,926,2,,void
72976,BLOCK,-1,,"{
          std::move(pending.next)(nread, nullptr, 0, [](uint64_t) {});
        }",16,,928,1,,void
73029,BLOCK,-1,,"{
        reading_ = false;
        if (handle_->IsAlive()) handle_->ReadStop();
      }",35,,941,2,,void
73038,BLOCK,-1,,<empty>,33,,943,2,,void
73051,BLOCK,-1,,"{
      if (ended_ || !handle_->IsAlive()) {
        std::move(next)(bob::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        return bob::STATUS_EOS;
      }

      if (FdEntry::CheckModified(entry_, handle_->GetFD())) {
        DrainAndClose();
        std::move(next)(UV_EINVAL, nullptr, 0, [](uint64_t) {});
        return UV_EINVAL;
      }

      pending_pulls_.emplace_back(std::move(next), shared_from_this());
      if (!reading_) {
        reading_ = true;
        handle_->ReadStart();
      }
      return bob::STATUS_WAIT;
    }",67,,951,6,,void
73060,BLOCK,-1,,"{
        std::move(next)(bob::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        return bob::STATUS_EOS;
      }",42,,952,2,,void
73087,BLOCK,-1,,"{
        DrainAndClose();
        std::move(next)(UV_EINVAL, nullptr, 0, [](uint64_t) {});
        return UV_EINVAL;
      }",61,,957,2,,void
73114,BLOCK,-1,,"{
        reading_ = true;
        handle_->ReadStart();
      }",22,,964,2,,void
73137,BLOCK,-1,,"{
      auto ptr = static_cast<ReaderImpl*>(self);
      ptr->DrainAndClose();
    }",37,,990,2,,void
73151,BLOCK,-1,,"{
      if (ended_) return;
      ended_ = true;
      while (!pending_pulls_.empty()) {
        auto pending = DequeuePendingPull();
        std::move(pending.next)(bob::STATUS_EOS, nullptr, 0, [](uint64_t) {});
      }
      handle_->ReadStop();

      // We fallback to a sync close on the raw fd here because it is the
      // easiest, simplest thing to do. All of FileHandle's close mechanisms
      // assume async close and cleanup, while DrainAndClose might be running
      // in the destructor during GC, for instance. As a todo, FileHandle could
      // provide a sync mechanism for closing the FD but, for now, this
      // approach works.
      int fd = handle_->Release();
      uv_fs_t req;
      uv_fs_close(nullptr, &req, fd, nullptr);
      uv_fs_req_cleanup(&req);
    }",26,,995,1,,void
73154,BLOCK,-1,,<empty>,19,,996,2,,void
73165,BLOCK,-1,,"{
        auto pending = DequeuePendingPull();
        std::move(pending.next)(bob::STATUS_EOS, nullptr, 0, [](uint64_t) {});
      }",39,,998,2,,void
73208,BLOCK,-1,,"{
      CHECK(!pending_pulls_.empty());
      auto pop = OnScopeLeave([this] { pending_pulls_.pop_front(); });
      return std::move(pending_pulls_.front());
    }",38,,1016,1,,void
73233,BLOCK,-1,,<empty>,,,,1,,<empty>
73244,BLOCK,-1,,<empty>,,,,1,,<empty>
73255,BLOCK,-1,,"{
  // Any entry is invalid for an idempotent DataQueue if any of the entries
  // are nullptr or is not idempotent.
  uint64_t size = 0;
  const auto isInvalid = [&size](auto& item) {
    if (item == nullptr || !item->is_idempotent()) {
      return true;  // true means the entry is not valid here.
    }

    // To keep from having to iterate over the entries
    // again, we'll try calculating the size. If any
    // of the entries are unable to provide a size, then
    // we assume we cannot safely treat this entry as
    // idempotent even if it claims to be.
    if (item->size().has_value()) {
      size += item->size().value();
    } else {
      return true;  // true means the entry is not valid here.
    }

    return false;
  };

  if (std::any_of(list.begin(), list.end(), isInvalid)) {
    return nullptr;
  }

  return std::make_shared<DataQueueImpl>(std::move(list), size);
}",47,,1033,2,,void
73277,BLOCK,-1,,"{
    return nullptr;
  }",57,,1056,2,,void
73299,BLOCK,-1,,"{
  return std::make_shared<DataQueueImpl>(capped);
}",78,,1063,2,,void
73312,BLOCK,-1,,"{
  // If the view is not detachable, we do not want to create an InMemoryEntry
  // from it. Why? Because if we're not able to detach the backing store from
  // the underlying buffer, something else could modify the buffer while we're
  // holding the reference, which means we cannot guarantee that reads will be
  // idempotent.
  if (!view->Buffer()->IsDetachable()) {
    return nullptr;
  }
  auto store = view->Buffer()->GetBackingStore();
  auto offset = view->ByteOffset();
  auto length = view->ByteLength();
  USE(view->Buffer()->Detach(Local<Value>()));
  return CreateInMemoryEntryFromBackingStore(std::move(store), offset, length);
}",34,,1068,2,,void
73322,BLOCK,-1,,"{
    return nullptr;
  }",40,,1074,2,,void
73373,BLOCK,-1,,"{
  CHECK(store);
  if (offset + length > store->ByteLength()) {
    return nullptr;
  }
  return std::make_unique<InMemoryEntry>(std::move(store), offset, length);
}",76,,1086,4,,void
73385,BLOCK,-1,,"{
    return nullptr;
  }",46,,1088,2,,void
73408,BLOCK,-1,,"{
  return std::make_unique<DataQueueEntry>(std::move(data_queue));
}",44,,1095,2,,void
73426,BLOCK,-1,,"{
  return FdEntry::Create(env, path);
}",79,,1100,3,,void
73439,BLOCK,-1,,"{
  // Nothing to do here currently.
}",76,,1104,3,,void
73444,BLOCK,-1,,"{
  // Nothing to do here currently.
}",42,,1109,2,,void
73473,BLOCK,-1,,<empty>,1,,1,1,,ANY
73484,BLOCK,-1,,<empty>,1,,1,1,,ANY
73489,BLOCK,-1,,"{
    Info* info = static_cast<Info*>(arg);
    NativeSymbolDebuggingContext* sym_ctx = info->ctx.get();
    FILE* stream = info->stream;
    info->num_handles++;

    fprintf(stream, ""[%p] %s%s\n"", handle, uv_handle_type_name(handle->type),
            uv_is_active(handle) ? "" (active)"" : """");

    void* close_cb = reinterpret_cast<void*>(handle->close_cb);
    fprintf(stream, ""\tClose callback: %p %s\n"",
        close_cb, sym_ctx->LookupSymbol(close_cb).Display().c_str());

    fprintf(stream, ""\tData: %p %s\n"",
        handle->data, sym_ctx->LookupSymbol(handle->data).Display().c_str());

    // We are also interested in the first field of what `handle->data`
    // points to, because for C++ code that is usually the virtual table pointer
    // and gives us information about the exact kind of object we're looking at.
    void* first_field = nullptr;
    // `handle->data` might be any value, including `nullptr`, or something
    // cast from a completely different type; therefore...",52,,338,3,,void
73582,BLOCK,-1,,<empty>,7,,362,2,,void
73595,BLOCK,-1,,"{
      fprintf(stream, ""\t(First field): %p %s\n"",
          first_field, sym_ctx->LookupSymbol(first_field).Display().c_str());
    }",33,,364,2,,void
73616,BLOCK,-1,,"{
    // The return value is ignored because there's no good way to handle it.
    fwrite(str.data(), str.size(), 1, file);
  }",30,,477,1,,void
73677,BLOCK,-1,,<empty>,1,,1,1,,ANY
73684,BLOCK,-1,,"{
  std::string cats;
  credentials::SafeGetenv(""NODE_DEBUG_NATIVE"", &cats, env_vars, isolate);
  Parse(cats);
}",52,,63,3,,void
73701,BLOCK,-1,,"{
  std::string debug_categories = cats;
  while (!debug_categories.empty()) {
    std::string::size_type comma_pos = debug_categories.find(',');
    std::string wanted = ToLower(debug_categories.substr(0, comma_pos));

#define V(name)                                                                \
  {                                                                            \
    static const std::string available_category = ToLower(#name);              \
    if (available_category.find(wanted) != std::string::npos)                  \
      set_enabled(DebugCategory::name);                                        \
  }

    DEBUG_CATEGORY_NAMES(V)
#undef V

    if (comma_pos == std::string::npos) break;
    // Use everything after the `,` as the list for the next iteration.
    debug_categories = debug_categories.substr(comma_pos + 1);
  }
}",55,,69,2,,void
73712,BLOCK,-1,,"{
    std::string::size_type comma_pos = debug_categories.find(',');
    std::string wanted = ToLower(debug_categories.substr(0, comma_pos));

#define V(name)                                                                \
  {                                                                            \
    static const std::string available_category = ToLower(#name);              \
    if (available_category.find(wanted) != std::string::npos)                  \
      set_enabled(DebugCategory::name);                                        \
  }

    DEBUG_CATEGORY_NAMES(V)
#undef V

    if (comma_pos == std::string::npos) break;
    // Use everything after the `,` as the list for the next iteration.
    debug_categories = debug_categories.substr(comma_pos + 1);
  }",37,,71,2,,void
73741,BLOCK,-1,,<empty>,41,,85,2,,void
73756,BLOCK,-1,,"{
    current_process_ = GetCurrentProcess();
    USE(SymInitialize(current_process_, nullptr, true));
  }",33,,153,1,,void
73768,BLOCK,-1,,"{
    USE(SymCleanup(current_process_));
  }",43,,158,1,,void
73777,BLOCK,-1,,"{
    // Refs: https://docs.microsoft.com/en-us/windows/desktop/Debug/retrieving-symbol-information-by-address
    // Patches:
    // Use `fprintf(stderr, ` instead of `printf`
    // `sym.filename = pSymbol->Name` on success
    // `current_process_` instead of `hProcess.
    DWORD64 dwDisplacement = 0;
    // Patch: made into arg - DWORD64  dwAddress = SOME_ADDRESS;

    char buffer[sizeof(SYMBOL_INFO) + MAX_SYM_NAME * sizeof(TCHAR)];
    const auto pSymbol = reinterpret_cast<PSYMBOL_INFO>(buffer);

    pSymbol->SizeOfStruct = sizeof(SYMBOL_INFO);
    pSymbol->MaxNameLen = MAX_SYM_NAME;

    if (SymFromAddr(current_process_, dwAddress, &dwDisplacement, pSymbol)) {
      // SymFromAddr returned success
      return NameAndDisplacement(pSymbol->Name, dwDisplacement);
    } else {
      // SymFromAddr failed
      const DWORD error = GetLastError();  // ""eat"" the error anyway
#ifdef DEBUG
      fprintf(stderr, ""SymFromAddr returned error : %lu\n"", error);
#endif
    }
    // End MSDN...",67,,163,2,,void
73807,BLOCK,-1,,"{
      // SymFromAddr returned success
      return NameAndDisplacement(pSymbol->Name, dwDisplacement);
    }",77,,178,2,,void
73815,BLOCK,-1,,"{
      // SymFromAddr failed
      const DWORD error = GetLastError();  // ""eat"" the error anyway
#ifdef DEBUG
      fprintf(stderr, ""SymFromAddr returned error : %lu\n"", error);
#endif
    }",12,,181,1,,void
73826,BLOCK,-1,,"{
    SymbolInfo sym{};

    // Refs: https://docs.microsoft.com/en-us/windows/desktop/Debug/retrieving-symbol-information-by-address
    // Patches:
    // Use `fprintf(stderr, ` instead of `printf`.
    // Assign values to `sym` on success.
    // `current_process_` instead of `hProcess.

    // Patch: made into arg - DWORD64  dwAddress;
    DWORD dwDisplacement;
    IMAGEHLP_LINE64 line;

    SymSetOptions(SYMOPT_LOAD_LINES);

    line.SizeOfStruct = sizeof(IMAGEHLP_LINE64);
    // Patch: made into arg - dwAddress = 0x1000000;

    if (SymGetLineFromAddr64(current_process_, dwAddress,
                             &dwDisplacement, &line)) {
      // SymGetLineFromAddr64 returned success
      sym.filename = line.FileName;
      sym.line = line.LineNumber;
    } else {
      // SymGetLineFromAddr64 failed
      const DWORD error = GetLastError();  // ""eat"" the error anyway
#ifdef DEBUG
      fprintf(stderr, ""SymGetLineFromAddr64 returned error : %lu\n"", error);
#endif
    }
    // ...",54,,193,2,,void
73848,BLOCK,-1,,"{
      // SymGetLineFromAddr64 returned success
      sym.filename = line.FileName;
      sym.line = line.LineNumber;
    }",55,,212,2,,void
73864,BLOCK,-1,,"{
      // SymGetLineFromAddr64 failed
      const DWORD error = GetLastError();  // ""eat"" the error anyway
#ifdef DEBUG
      fprintf(stderr, ""SymGetLineFromAddr64 returned error : %lu\n"", error);
#endif
    }",12,,216,1,,void
73875,BLOCK,-1,,"{
    // Refs: https://docs.microsoft.com/en-us/windows/desktop/Debug/retrieving-undecorated-symbol-names
    // Patches:
    // Use `fprintf(stderr, ` instead of `printf`.
    // return `szUndName` instead of `printf` on success
    char szUndName[MAX_SYM_NAME];
    if (UnDecorateSymbolName(name, szUndName, sizeof(szUndName),
                             UNDNAME_COMPLETE)) {
      // UnDecorateSymbolName returned success
      return szUndName;
    } else {
      // UnDecorateSymbolName failed
      const DWORD error = GetLastError();  // ""eat"" the error anyway
#ifdef DEBUG
      fprintf(stderr, ""UnDecorateSymbolName returned error %lu\n"", error);
#endif
    }
    return nullptr;
  }",67,,229,2,,void
73884,BLOCK,-1,,"{
      // UnDecorateSymbolName returned success
      return szUndName;
    }",49,,236,2,,void
73888,BLOCK,-1,,"{
      // UnDecorateSymbolName failed
      const DWORD error = GetLastError();  // ""eat"" the error anyway
#ifdef DEBUG
      fprintf(stderr, ""UnDecorateSymbolName returned error %lu\n"", error);
#endif
    }",12,,239,1,,void
73899,BLOCK,-1,,"{
    const DWORD64 dw_address = reinterpret_cast<DWORD64>(address);
    SymbolInfo ret = WrappedGetLine(dw_address);
    std::tie(ret.name, ret.dis) = WrappedSymFromAddr(dw_address);
    if (!ret.name.empty()) {
      ret.name = WrappedUnDecorateSymbolName(ret.name.c_str());
    }
    return ret;
  }",51,,249,2,,void
73932,BLOCK,-1,,"{
      ret.name = WrappedUnDecorateSymbolName(ret.name.c_str());
    }",28,,253,2,,void
73950,BLOCK,-1,,"{
    MEMORY_BASIC_INFORMATION info;

    if (VirtualQuery(address, &info, sizeof(info)) != sizeof(info))
      return false;

    return info.State == MEM_COMMIT && info.Protect != 0;
  }",41,,259,2,,void
73962,BLOCK,-1,,<empty>,7,,263,2,,void
73982,BLOCK,-1,,"{
    return CaptureStackBackTrace(0, count, frames, nullptr);
  }",56,,268,3,,void
73993,BLOCK,-1,,<empty>,,,,2,,<empty>
73998,BLOCK,-1,,<empty>,,,,2,,<empty>
74003,BLOCK,-1,,<empty>,,,,2,,<empty>
74008,BLOCK,-1,,<empty>,,,,2,,<empty>
74013,BLOCK,-1,,"{
  return std::unique_ptr<NativeSymbolDebuggingContext>(
      new Win32SymbolDebuggingContext());
}",37,,284,1,,void
74026,BLOCK,-1,,"{
  std::ostringstream oss;
  oss << name;
  if (dis != 0) {
    oss << ""+"" << dis;
  }
  if (!filename.empty()) {
    oss << "" ["" << filename << ']';
  }
  if (line != 0) {
    oss << "":L"" << line;
  }
  return oss.str();
}",71,,291,1,,void
74035,BLOCK,-1,,"{
    oss << ""+"" << dis;
  }",17,,294,2,,void
74047,BLOCK,-1,,"{
    oss << "" ["" << filename << ']';
  }",26,,297,2,,void
74059,BLOCK,-1,,"{
    oss << "":L"" << line;
  }",18,,300,2,,void
74074,BLOCK,-1,,"{
  auto sym_ctx = NativeSymbolDebuggingContext::New();
  void* frames[256];
  const int size = sym_ctx->GetStackTrace(frames, arraysize(frames));
  for (int i = 1; i < size; i += 1) {
    void* frame = frames[i];
    NativeSymbolDebuggingContext::SymbolInfo s = sym_ctx->LookupSymbol(frame);
    fprintf(fp, ""%2d: %p %s\n"", i, frame, s.Display().c_str());
  }
}",30,,306,2,,void
74094,BLOCK,-1,,<empty>,3,,310,1,,void
74105,BLOCK,4,,"{
    void* frame = frames[i];
    NativeSymbolDebuggingContext::SymbolInfo s = sym_ctx->LookupSymbol(frame);
    fprintf(fp, ""%2d: %p %s\n"", i, frame, s.Display().c_str());
  }",37,,310,4,,void
74136,BLOCK,-1,,"{
  if (uv_loop_close(loop) == 0) return;

  PrintLibuvHandleInformation(loop, stderr);

  fflush(stderr);
  // Finally, abort.
  UNREACHABLE(""uv_loop_close() while having open handles"");
}",42,,317,2,,void
74142,BLOCK,-1,,<empty>,33,,318,2,,void
74155,BLOCK,-1,,"{
  struct Info {
    std::unique_ptr<NativeSymbolDebuggingContext> ctx;
    FILE* stream;
    size_t num_handles;
  };

  Info info { NativeSymbolDebuggingContext::New(), stream, 0 };

  fprintf(stream, ""uv loop at [%p] has open handles:\n"", loop);

  uv_walk(loop, [](uv_handle_t* handle, void* arg) {
    Info* info = static_cast<Info*>(arg);
    NativeSymbolDebuggingContext* sym_ctx = info->ctx.get();
    FILE* stream = info->stream;
    info->num_handles++;

    fprintf(stream, ""[%p] %s%s\n"", handle, uv_handle_type_name(handle->type),
            uv_is_active(handle) ? "" (active)"" : """");

    void* close_cb = reinterpret_cast<void*>(handle->close_cb);
    fprintf(stream, ""\tClose callback: %p %s\n"",
        close_cb, sym_ctx->LookupSymbol(close_cb).Display().c_str());

    fprintf(stream, ""\tData: %p %s\n"",
        handle->data, sym_ctx->LookupSymbol(handle->data).Display().c_str());

    // We are also interested in the first field of what `handle->data`
    // points to, becaus...",65,,327,3,,void
74185,BLOCK,-1,,"{
  std::vector<std::string> list;
#if defined(__linux__) || defined(__FreeBSD__) || \
    defined(__OpenBSD__) || defined(__DragonFly__)
  dl_iterate_phdr(
      [](struct dl_phdr_info* info, size_t size, void* data) {
        auto list = static_cast<std::vector<std::string>*>(data);
        if (*info->dlpi_name != '\0') {
          list->emplace_back(info->dlpi_name);
        }
        return 0;
      },
      &list);
#elif __APPLE__
  uint32_t i = 0;
  for (const char* name = _dyld_get_image_name(i); name != nullptr;
       name = _dyld_get_image_name(++i)) {
    list.emplace_back(name);
  }

#elif _AIX
  // We can't tell in advance how large the buffer needs to be.
  // Retry until we reach too large a size (1Mb).
  const unsigned int kBufferGrowStep = 4096;
  MallocedBuffer<char> buffer(kBufferGrowStep);
  int rc = -1;
  do {
    rc = loadquery(L_GETINFO, buffer.data, buffer.size);
    if (rc == 0) break;
    buffer = MallocedBuffer<char>(buffer.size + kBufferGrowStep);
  } whi...",77,,374,1,,void
74200,BLOCK,-1,,"{
  auto simple_fwrite = [&]() {
    // The return value is ignored because there's no good way to handle it.
    fwrite(str.data(), str.size(), 1, file);
  };

  if (file != stderr && file != stdout) {
    simple_fwrite();
    return;
  }
#ifdef _WIN32
  HANDLE handle =
      GetStdHandle(file == stdout ? STD_OUTPUT_HANDLE : STD_ERROR_HANDLE);

  // Check if stderr is something other than a tty/console
  if (handle == INVALID_HANDLE_VALUE || handle == nullptr ||
      uv_guess_handle(_fileno(file)) != UV_TTY) {
    simple_fwrite();
    return;
  }

  // Get required wide buffer size
  int n = MultiByteToWideChar(CP_UTF8, 0, str.data(), str.size(), nullptr, 0);

  std::vector<wchar_t> wbuf(n);
  MultiByteToWideChar(CP_UTF8, 0, str.data(), str.size(), wbuf.data(), n);

  WriteConsoleW(handle, wbuf.data(), n, nullptr, nullptr);
  return;
#elif defined(__ANDROID__)
  if (file == stderr) {
    __android_log_print(ANDROID_LOG_ERROR, ""nodejs"", ""%s"", str.data());
    return;
  }
#endif
  s...",49,,476,3,,void
74213,BLOCK,-1,,"{
    simple_fwrite();
    return;
  }",41,,482,2,,void
74221,BLOCK,-1,,"{
  node::DumpBacktrace(fp);
}",43,,516,2,,void
74243,BLOCK,-1,,<empty>,1,,1,1,,ANY
74250,BLOCK,-1,,<empty>,1,,1,1,,ANY
74273,BLOCK,-1,,<empty>,1,,1,1,,ANY
74278,BLOCK,-1,,"{
  tracker->TrackField(""encode_into_results_buffer"",
                      encode_into_results_buffer_);
}",60,,29,2,,void
74291,BLOCK,-1,,"{
  if (info == nullptr) {
    object
        ->Set(realm->context(),
              FIXED_ONE_BYTE_STRING(realm->isolate(), ""encodeIntoResults""),
              encode_into_results_buffer_.GetJSArray())
        .Check();
  } else {
    encode_into_results_buffer_.Deserialize(realm->context());
  }
  encode_into_results_buffer_.MakeWeak();
}",62,,41,4,,void
74296,BLOCK,-1,,"{
    object
        ->Set(realm->context(),
              FIXED_ONE_BYTE_STRING(realm->isolate(), ""encodeIntoResults""),
              encode_into_results_buffer_.GetJSArray())
        .Check();
  }",24,,42,2,,void
74319,BLOCK,-1,,"{
    encode_into_results_buffer_.Deserialize(realm->context());
  }",10,,48,1,,void
74337,BLOCK,-1,,"{
  DCHECK_NULL(internal_field_info_);
  internal_field_info_ = InternalFieldInfoBase::New<InternalFieldInfo>(type());
  internal_field_info_->encode_into_results_buffer =
      encode_into_results_buffer_.Serialize(context, creator);
  // Return true because we need to maintain the reference to the binding from
  // JS land.
  return true;
}",73,,55,3,,void
74364,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info = internal_field_info_;
  internal_field_info_ = nullptr;
  return info;
}",58,,65,2,,void
74386,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  v8::HandleScope scope(context->GetIsolate());
  Realm* realm = Realm::GetCurrent(context);
  // Recreate the buffer in the constructor.
  InternalFieldInfo* casted_info = static_cast<InternalFieldInfo*>(info);
  BindingData* binding =
      realm->AddBindingData<BindingData>(context, holder, casted_info);
  CHECK_NOT_NULL(binding);
}",60,,75,5,,void
74432,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  CHECK_GE(args.Length(), 2);
  CHECK(args[0]->IsString());
  CHECK(args[1]->IsUint8Array());
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);

  Local<String> source = args[0].As<String>();

  Local<Uint8Array> dest = args[1].As<Uint8Array>();
  Local<ArrayBuffer> buf = dest->Buffer();
  char* write_result = static_cast<char*>(buf->Data()) + dest->ByteOffset();
  size_t dest_length = dest->ByteLength();

  int nchars;
  int written = source->WriteUtf8(
      isolate,
      write_result,
      dest_length,
      &nchars,
      String::NO_NULL_TERMINATION | String::REPLACE_INVALID_UTF8);

  binding_data->encode_into_results_buffer_[0] = nchars;
  binding_data->encode_into_results_buffer_[1] = written;
}",71,,86,2,,void
74571,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());

  Local<String> str = args[0].As<String>();
  size_t length = str->Utf8Length(isolate);

  Local<ArrayBuffer> ab;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    std::unique_ptr<BackingStore> bs =
        ArrayBuffer::NewBackingStore(isolate, length);

    CHECK(bs);

    str->WriteUtf8(isolate,
                   static_cast<char*>(bs->Data()),
                   -1,  // We are certain that `data` is sufficiently large
                   nullptr,
                   String::NO_NULL_TERMINATION | String::REPLACE_INVALID_UTF8);

    ab = ArrayBuffer::New(isolate, std::move(bs));
  }

  auto array = Uint8Array::New(ab, 0, length);
  args.GetReturnValue().Set(array);
}",77,,115,2,,void
74625,BLOCK,11,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    std::unique_ptr<BackingStore> bs =
        ArrayBuffer::NewBackingStore(isolate, length);

    CHECK(bs);

    str->WriteUtf8(isolate,
                   static_cast<char*>(bs->Data()),
                   -1,  // We are certain that `data` is sufficiently large
                   nullptr,
                   String::NO_NULL_TERMINATION | String::REPLACE_INVALID_UTF8);

    ab = ArrayBuffer::New(isolate, std::move(bs));
  }",3,,125,11,,void
74702,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);  // list, flags

  CHECK_GE(args.Length(), 1);

  if (!(args[0]->IsArrayBuffer() || args[0]->IsSharedArrayBuffer() ||
        args[0]->IsArrayBufferView())) {
    return node::THROW_ERR_INVALID_ARG_TYPE(
        env->isolate(),
        ""The \""list\"" argument must be an instance of SharedArrayBuffer, ""
        ""ArrayBuffer or ArrayBufferView."");
  }

  ArrayBufferViewContents<char> buffer(args[0]);

  bool ignore_bom = args[1]->IsTrue();
  bool has_fatal = args[2]->IsTrue();

  const char* data = buffer.data();
  size_t length = buffer.length();

  if (has_fatal) {
    auto result = simdutf::validate_utf8_with_errors(data, length);

    if (result.error) {
      return node::THROW_ERR_ENCODING_INVALID_ENCODED_DATA(
          env->isolate(), ""The encoded data was not valid for encoding utf-8"");
    }
  }

  if (!ignore_bom && length >= 3) {
    if (memcmp(data, ""\xEF\xBB\xBF"", 3) == 0) {
      data += 3;
      length -= 3;
    }
  ...",71,,146,2,,void
74739,BLOCK,-1,,"{
    return node::THROW_ERR_INVALID_ARG_TYPE(
        env->isolate(),
        ""The \""list\"" argument must be an instance of SharedArrayBuffer, ""
        ""ArrayBuffer or ArrayBufferView."");
  }",40,,152,2,,void
74789,BLOCK,-1,,"{
    auto result = simdutf::validate_utf8_with_errors(data, length);

    if (result.error) {
      return node::THROW_ERR_ENCODING_INVALID_ENCODED_DATA(
          env->isolate(), ""The encoded data was not valid for encoding utf-8"");
    }
  }",18,,167,2,,void
74803,BLOCK,-1,,"{
      return node::THROW_ERR_ENCODING_INVALID_ENCODED_DATA(
          env->isolate(), ""The encoded data was not valid for encoding utf-8"");
    }",23,,170,2,,void
74821,BLOCK,-1,,"{
    if (memcmp(data, ""\xEF\xBB\xBF"", 3) == 0) {
      data += 3;
      length -= 3;
    }
  }",35,,176,2,,void
74829,BLOCK,-1,,"{
      data += 3;
      length -= 3;
    }",47,,177,2,,void
74840,BLOCK,-1,,<empty>,20,,183,2,,void
74886,BLOCK,-1,,"{
    CHECK(!error.IsEmpty());
    env->isolate()->ThrowException(error);
    return;
  }",33,,190,2,,void
74914,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());

  Utf8Value input(env->isolate(), args[0]);
  auto out = ada::idna::to_ascii(input.ToStringView());
  args.GetReturnValue().Set(
      String::NewFromUtf8(env->isolate(), out.c_str()).ToLocalChecked());
}",76,,199,2,,void
74984,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());

  Utf8Value input(env->isolate(), args[0]);
  auto out = ada::idna::to_unicode(input.ToStringView());
  args.GetReturnValue().Set(
      String::NewFromUtf8(env->isolate(), out.c_str()).ToLocalChecked());
}",78,,210,2,,void
75055,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();
  Local<ObjectTemplate> target = ctor->InstanceTemplate();
  SetMethod(isolate, target, ""encodeInto"", EncodeInto);
  SetMethodNoSideEffect(isolate, target, ""encodeUtf8String"", EncodeUtf8String);
  SetMethodNoSideEffect(isolate, target, ""decodeUTF8"", DecodeUTF8);
  SetMethodNoSideEffect(isolate, target, ""toASCII"", ToASCII);
  SetMethodNoSideEffect(isolate, target, ""toUnicode"", ToUnicode);
}",76,,222,3,,void
75105,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(context);
  realm->AddBindingData<BindingData>(context, target);
}",58,,235,5,,void
75128,BLOCK,-1,,"{
  registry->Register(EncodeInto);
  registry->Register(EncodeUtf8String);
  registry->Register(DecodeUTF8);
  registry->Register(ToASCII);
  registry->Register(ToUnicode);
}",42,,241,2,,void
75169,BLOCK,-1,,<empty>,1,,1,1,,ANY
75204,BLOCK,-1,,<empty>,1,,1,1,,ANY
75208,BLOCK,-1,,{ return el.IsEmpty(); },49,,218,2,,void
75220,BLOCK,-1,,"{
        Environment* env = ContainerOf(
            &Environment::task_queues_async_, async);
        HandleScope handle_scope(env->isolate());
        Context::Scope context_scope(env->context());
        env->RunAndClearNativeImmediates();
      }",29,,948,2,,void
75251,BLOCK,-1,,"{
    env->set_can_call_into_js(false);
    uv_stop(env->event_loop());
  }",47,,982,2,,void
75267,BLOCK,-1,,"{
#ifdef DEBUG
      memset(handle, 0xab, uv_handle_size(handle->type));
#endif
    }",54,,993,2,,void
75275,BLOCK,-1,,"{
    handle->data = env;

    env->CloseHandle(handle, [](uv_handle_t* handle) {
#ifdef DEBUG
      memset(handle, 0xab, uv_handle_size(handle->type));
#endif
    });
  }",52,,990,4,,void
75292,BLOCK,-1,,"{
    RegisterHandleCleanup(handle, close_and_finish, nullptr);
  }",51,,1000,2,,void
75303,BLOCK,-1,,"{
    Environment* env = ContainerOf(&Environment::idle_prepare_handle_, handle);
    env->isolate()->SetIdle(true);
  }",68,,1040,2,,void
75326,BLOCK,-1,,"{
    Environment* env = ContainerOf(&Environment::idle_check_handle_, handle);
    env->isolate()->SetIdle(false);
  }",62,,1044,2,,void
75349,BLOCK,-1,,"{
    TryCatchScope try_catch(this);
    DebugSealHandleScope seal_handle_scope(isolate());
    while (auto head = queue->Shift()) {
      bool is_refed = head->flags() & CallbackFlags::kRefed;
      if (is_refed)
        ref_count++;

      if (is_refed || !only_refed)
        head->Call(this);

      head.reset();  // Destroy now so that this is also observed by try_catch.

      if (UNLIKELY(try_catch.HasCaught())) {
        if (!try_catch.HasTerminated() && can_call_into_js())
          errors::TriggerUncaughtException(isolate(), try_catch);

        return true;
      }
    }
    return false;
  }",54,,1150,2,,void
75357,BLOCK,-1,,"{
      bool is_refed = head->flags() & CallbackFlags::kRefed;
      if (is_refed)
        ref_count++;

      if (is_refed || !only_refed)
        head->Call(this);

      head.reset();  // Destroy now so that this is also observed by try_catch.

      if (UNLIKELY(try_catch.HasCaught())) {
        if (!try_catch.HasTerminated() && can_call_into_js())
          errors::TriggerUncaughtException(isolate(), try_catch);

        return true;
      }
    }",40,,1153,1,,void
75371,BLOCK,-1,,<empty>,9,,1156,2,,void
75379,BLOCK,-1,,<empty>,9,,1159,2,,void
75395,BLOCK,-1,,"{
        if (!try_catch.HasTerminated() && can_call_into_js())
          errors::TriggerUncaughtException(isolate(), try_catch);

        return true;
      }",44,,1163,2,,void
75404,BLOCK,-1,,<empty>,11,,1165,2,,void
75423,BLOCK,-1,,"{
    std::unique_ptr<Environment*> env_ptr { static_cast<Environment**>(data) };
    Environment* env = *env_ptr;
    if (env == nullptr) {
      // The Environment has already been destroyed. That should be okay; any
      // callback added before the Environment shuts down would have been
      // handled during cleanup.
      return;
    }
    env->interrupt_data_.store(nullptr);
    env->RunAndClearInterrupts();
  }",64,,1213,3,,void
75440,BLOCK,-1,,"{
      // The Environment has already been destroyed. That should be okay; any
      // callback added before the Environment shuts down would have been
      // handled during cleanup.
      return;
    }",25,,1216,2,,void
75458,BLOCK,-1,,{ },58,,1333,2,,void
75522,BLOCK,-1,,<empty>,1,,1,1,,ANY
75544,BLOCK,-1,,"{
  js_promise_hooks_[0].Reset(env()->isolate(), init);
  js_promise_hooks_[1].Reset(env()->isolate(), before);
  js_promise_hooks_[2].Reset(env()->isolate(), after);
  js_promise_hooks_[3].Reset(env()->isolate(), resolve);
}",61,,71,5,,void
75596,BLOCK,-1,,"{
  async_hooks()->ResetPromiseHooks(init, before, after, resolve);

  for (auto it = contexts_.begin(); it != contexts_.end(); it++) {
    if (it->IsEmpty()) {
      contexts_.erase(it--);
      continue;
    }
    PersistentToLocal::Weak(isolate_, *it)
        ->SetPromiseHooks(init, before, after, resolve);
  }
}",62,,81,5,,void
75606,BLOCK,-1,,<empty>,3,,84,1,,void
75622,BLOCK,4,,"{
    if (it->IsEmpty()) {
      contexts_.erase(it--);
      continue;
    }
    PersistentToLocal::Weak(isolate_, *it)
        ->SetPromiseHooks(init, before, after, resolve);
  }",66,,84,4,,void
75628,BLOCK,-1,,"{
      contexts_.erase(it--);
      continue;
    }",24,,85,2,,void
75656,BLOCK,-1,,"{
  // Since async_hooks is experimental, do only perform the check
  // when async_hooks is enabled.
  if (fields_[kCheck] > 0) {
    CHECK_GE(async_id, -1);
    CHECK_GE(trigger_async_id, -1);
  }

  uint32_t offset = fields_[kStackLength];
  if (offset * 2 >= async_ids_stack_.Length()) grow_async_ids_stack();
  async_ids_stack_[2 * offset] = async_id_fields_[kExecutionAsyncId];
  async_ids_stack_[2 * offset + 1] = async_id_fields_[kTriggerAsyncId];
  fields_[kStackLength] += 1;
  async_id_fields_[kExecutionAsyncId] = async_id;
  async_id_fields_[kTriggerAsyncId] = trigger_async_id;

#ifdef DEBUG
  for (uint32_t i = offset; i < native_execution_async_resources_.size(); i++)
    CHECK(native_execution_async_resources_[i].IsEmpty());
#endif

  // When this call comes from JS (as a way of increasing the stack size),
  // `resource` will be empty, because JS caches these values anyway.
  if (!resource.IsEmpty()) {
    native_execution_async_resources_.resize(offset + 1);
    // Caveat...",61,,97,4,,void
75663,BLOCK,-1,,"{
    CHECK_GE(async_id, -1);
    CHECK_GE(trigger_async_id, -1);
  }",28,,100,2,,void
75687,BLOCK,-1,,<empty>,48,,106,2,,void
75730,BLOCK,-1,,"{
    native_execution_async_resources_.resize(offset + 1);
    // Caveat: This is a v8::Local<> assignment, we do not keep a v8::Global<>!
    native_execution_async_resources_[offset] = resource;
  }",28,,120,2,,void
75747,BLOCK,-1,,"{
  // In case of an exception then this may have already been reset, if the
  // stack was multiple MakeCallback()'s deep.
  if (UNLIKELY(fields_[kStackLength] == 0)) return false;

  // Ask for the async_id to be restored as a check that the stack
  // hasn't been corrupted.
  if (UNLIKELY(fields_[kCheck] > 0 &&
               async_id_fields_[kExecutionAsyncId] != async_id)) {
    FailWithCorruptedAsyncStack(async_id);
  }

  uint32_t offset = fields_[kStackLength] - 1;
  async_id_fields_[kExecutionAsyncId] = async_ids_stack_[2 * offset];
  async_id_fields_[kTriggerAsyncId] = async_ids_stack_[2 * offset + 1];
  fields_[kStackLength] = offset;

  if (LIKELY(offset < native_execution_async_resources_.size() &&
             !native_execution_async_resources_[offset].IsEmpty())) {
#ifdef DEBUG
    for (uint32_t i = offset + 1; i < native_execution_async_resources_.size();
         i++) {
      CHECK(native_execution_async_resources_[i].IsEmpty());
    }
#endif
    native_execution_as...",53,,128,2,,void
75755,BLOCK,-1,,<empty>,45,,131,2,,void
75771,BLOCK,-1,,"{
    FailWithCorruptedAsyncStack(async_id);
  }",66,,136,2,,void
75823,BLOCK,-1,,"{
#ifdef DEBUG
    for (uint32_t i = offset + 1; i < native_execution_async_resources_.size();
         i++) {
      CHECK(native_execution_async_resources_[i].IsEmpty());
    }
#endif
    native_execution_async_resources_.resize(offset);
    if (native_execution_async_resources_.size() <
            native_execution_async_resources_.capacity() / 2 &&
        native_execution_async_resources_.size() > 16) {
      native_execution_async_resources_.shrink_to_fit();
    }
  }",69,,146,2,,void
75848,BLOCK,-1,,"{
      native_execution_async_resources_.shrink_to_fit();
    }",56,,156,2,,void
75861,BLOCK,-1,,"{
    HandleScope handle_scope(env()->isolate());
    USE(js_execution_async_resources()->Set(
        env()->context(),
        env()->length_string(),
        Integer::NewFromUnsigned(env()->isolate(), offset)));
  }",68,,161,2,,void
75899,BLOCK,-1,,"{
  if (env()->can_call_into_js()) {
    Isolate* isolate = env()->isolate();
    HandleScope handle_scope(isolate);
    if (!js_execution_async_resources_.IsEmpty()) {
      USE(PersistentToLocal::Strong(js_execution_async_resources_)
              ->Set(env()->context(),
                    env()->length_string(),
                    Integer::NewFromUnsigned(isolate, 0)));
    }
  }

  native_execution_async_resources_.clear();
  native_execution_async_resources_.shrink_to_fit();

  async_id_fields_[kExecutionAsyncId] = 0;
  async_id_fields_[kTriggerAsyncId] = 0;
  fields_[kStackLength] = 0;
}",41,,172,1,,void
75905,BLOCK,-1,,"{
    Isolate* isolate = env()->isolate();
    HandleScope handle_scope(isolate);
    if (!js_execution_async_resources_.IsEmpty()) {
      USE(PersistentToLocal::Strong(js_execution_async_resources_)
              ->Set(env()->context(),
                    env()->length_string(),
                    Integer::NewFromUnsigned(isolate, 0)));
    }
  }",34,,173,2,,void
75922,BLOCK,-1,,"{
      USE(PersistentToLocal::Strong(js_execution_async_resources_)
              ->Set(env()->context(),
                    env()->length_string(),
                    Integer::NewFromUnsigned(isolate, 0)));
    }",51,,176,2,,void
75973,BLOCK,-1,,"{
  ctx->SetPromiseHooks(js_promise_hooks_[0].IsEmpty()
                           ? Local<Function>()
                           : PersistentToLocal::Strong(js_promise_hooks_[0]),
                       js_promise_hooks_[1].IsEmpty()
                           ? Local<Function>()
                           : PersistentToLocal::Strong(js_promise_hooks_[1]),
                       js_promise_hooks_[2].IsEmpty()
                           ? Local<Function>()
                           : PersistentToLocal::Strong(js_promise_hooks_[2]),
                       js_promise_hooks_[3].IsEmpty()
                           ? Local<Function>()
                           : PersistentToLocal::Strong(js_promise_hooks_[3]));
}",58,,192,2,,void
76042,BLOCK,-1,,"{
  size_t id = contexts_.size();
  contexts_.resize(id + 1);
  contexts_[id].Reset(isolate_, context);
  contexts_[id].SetWeak();
}",56,,207,2,,void
76075,BLOCK,-1,,"{
  HandleScope handle_scope(isolate_);
  contexts_.erase(std::remove_if(contexts_.begin(),
                                 contexts_.end(),
                                 [&](auto&& el) { return el.IsEmpty(); }),
                  contexts_.end());
  for (auto it = contexts_.begin(); it != contexts_.end(); it++) {
    Local<Context> saved_context = PersistentToLocal::Weak(isolate_, *it);
    if (saved_context == context) {
      it->Reset();
      contexts_.erase(it);
      break;
    }
  }
}",58,,214,2,,void
76101,BLOCK,-1,,<empty>,3,,220,1,,void
76117,BLOCK,4,,"{
    Local<Context> saved_context = PersistentToLocal::Weak(isolate_, *it);
    if (saved_context == context) {
      it->Reset();
      contexts_.erase(it);
      break;
    }
  }",66,,220,4,,void
76135,BLOCK,-1,,"{
      it->Reset();
      contexts_.erase(it);
      break;
    }",35,,222,2,,void
76150,BLOCK,-1,,"{
  shadow_realms_.insert(realm);
}",70,,230,2,,void
76160,BLOCK,-1,,"{
  shadow_realms_.erase(realm);
}",72,,234,2,,void
76171,BLOCK,-1,,"{
  if (env->async_hooks()->fields()[AsyncHooks::kCheck] > 0) {
    CHECK_GE(default_trigger_async_id, 0);
  }

  old_default_trigger_async_id_ =
      async_hooks_->async_id_fields()[AsyncHooks::kDefaultTriggerAsyncId];
  async_hooks_->async_id_fields()[AsyncHooks::kDefaultTriggerAsyncId] =
      default_trigger_async_id;
}",40,,240,3,,void
76186,BLOCK,-1,,"{
    CHECK_GE(default_trigger_async_id, 0);
  }",61,,241,2,,void
76213,BLOCK,-1,,"{
  async_hooks_->async_id_fields()[AsyncHooks::kDefaultTriggerAsyncId] =
      old_default_trigger_async_id_;
}",71,,251,1,,void
76228,BLOCK,-1,,<empty>,62,,259,2,,void
76234,BLOCK,-1,,"{
  output << ""{ "";
  for (const SnapshotIndex i : v) {
    output << i << "", "";
  }
  output << "" }"";
  return output;
}",63,,262,3,,void
76241,BLOCK,-1,,"{
    output << i << "", "";
  }",35,,264,3,,void
76257,BLOCK,-1,,"{
  output << ""{\n""
         << ""// -- primitive begins --\n""
         << i.primitive_values << "",\n""
         << ""// -- primitive ends --\n""
         << ""// -- template_values begins --\n""
         << i.template_values << "",\n""
         << ""// -- template_values ends --\n""
         << ""}"";
  return output;
}",61,,272,3,,void
76290,BLOCK,-1,,"{
  output << ""{\n""
         << ""  ""
         << (i.type == SnapshotMetadata::Type::kDefault
                 ? ""SnapshotMetadata::Type::kDefault""
                 : ""SnapshotMetadata::Type::kFullyCustomized"")
         << "", // type\n""
         << ""  \"""" << i.node_version << ""\"", // node_version\n""
         << ""  \"""" << i.node_arch << ""\"", // node_arch\n""
         << ""  \"""" << i.node_platform << ""\"", // node_platform\n""
         << ""  "" << i.v8_cache_version_tag << "", // v8_cache_version_tag\n""
         << ""}"";
  return output;
}",75,,284,3,,void
76351,BLOCK,-1,,"{
  Isolate* isolate = creator->GetIsolate();
  IsolateDataSerializeInfo info;
  HandleScope handle_scope(isolate);
  // XXX(joyeecheung): technically speaking, the indexes here should be
  // consecutive and we could just return a range instead of an array,
  // but that's not part of the V8 API contract so we use an array
  // just to be safe.

#define VP(PropertyName, StringValue) V(Private, PropertyName)
#define VY(PropertyName, StringValue) V(Symbol, PropertyName)
#define VS(PropertyName, StringValue) V(String, PropertyName)
#define VR(PropertyName, TypeName) V(Private, per_realm_##PropertyName)
#define V(TypeName, PropertyName)                                              \
  info.primitive_values.push_back(                                             \
      creator->AddData(PropertyName##_.Get(isolate)));
  PER_ISOLATE_PRIVATE_SYMBOL_PROPERTIES(VP)
  PER_ISOLATE_SYMBOL_PROPERTIES(VY)
  PER_ISOLATE_STRING_PROPERTIES(VS)
  PER_REALM_STRONG_PERSISTENT_VALUES(VR)
#undef V
#undef...",75,,299,2,,void
76372,BLOCK,-1,,<empty>,3,,325,1,,void
76410,BLOCK,-1,,"{
  size_t i = 0;
  HandleScope handle_scope(isolate_);

  if (per_process::enabled_debug_list.enabled(DebugCategory::MKSNAPSHOT)) {
    fprintf(stderr, ""deserializing IsolateDataSerializeInfo...\n"");
    std::cerr << *info << ""\n"";
  }

#define VP(PropertyName, StringValue) V(Private, PropertyName)
#define VY(PropertyName, StringValue) V(Symbol, PropertyName)
#define VS(PropertyName, StringValue) V(String, PropertyName)
#define VR(PropertyName, TypeName) V(Private, per_realm_##PropertyName)
#define V(TypeName, PropertyName)                                              \
  do {                                                                         \
    MaybeLocal<TypeName> maybe_field =                                         \
        isolate_->GetDataFromSnapshotOnce<TypeName>(                           \
            info->primitive_values[i++]);                                      \
    Local<TypeName> field;                                                     \
    if (!maybe...",79,,346,2,,void
76428,BLOCK,-1,,"{
    fprintf(stderr, ""deserializing IsolateDataSerializeInfo...\n"");
    std::cerr << *info << ""\n"";
  }",75,,350,2,,void
76449,BLOCK,-1,,<empty>,3,,380,1,,void
76461,BLOCK,4,,"{
    MaybeLocal<String> maybe_field =
        isolate_->GetDataFromSnapshotOnce<String>(info->primitive_values[i++]);
    Local<String> field;
    if (!maybe_field.ToLocal(&field)) {
      fprintf(stderr, ""Failed to deserialize AsyncWrap provider %zu\n"", j);
    }
    async_wrap_providers_[j].Set(isolate_, field);
  }",60,,380,4,,void
76493,BLOCK,-1,,"{
      fprintf(stderr, ""Failed to deserialize AsyncWrap provider %zu\n"", j);
    }",39,,384,2,,void
76524,BLOCK,-1,,"{
  // Create string and private symbol properties as internalized one byte
  // strings after the platform is properly initialized.
  //
  // Internalized because it makes property lookups a little faster and
  // because the string is created in the old space straight away.  It's going
  // to end up in the old space sooner or later anyway but now it doesn't go
  // through v8::Eternal's new space handling first.
  //
  // One byte because our strings are ASCII and we can safely skip V8's UTF-8
  // decoding step.

  HandleScope handle_scope(isolate_);

#define V(PropertyName, StringValue)                                           \
  PropertyName##_.Set(                                                         \
      isolate_,                                                                \
      Private::New(isolate_,                                                   \
                   String::NewFromOneByte(                                     \
                       isolate...",38,,418,1,,void
76580,BLOCK,-1,,"{
  options_.reset(
      new PerIsolateOptions(*(per_process::cli_options->per_isolate)));

  if (snapshot_data == nullptr) {
    CreateProperties();
  } else {
    DeserializeProperties(&snapshot_data->isolate_data_info);
  }
}",37,,513,6,,void
76597,BLOCK,-1,,"{
    CreateProperties();
  }",33,,517,2,,void
76600,BLOCK,-1,,"{
    DeserializeProperties(&snapshot_data->isolate_data_info);
  }",10,,519,1,,void
76610,BLOCK,-1,,"{
#define V(PropertyName, StringValue)                                           \
  tracker->TrackField(#PropertyName, PropertyName());
  PER_ISOLATE_SYMBOL_PROPERTIES(V)

  PER_ISOLATE_STRING_PROPERTIES(V)
#undef V

  tracker->TrackField(""async_wrap_providers"", async_wrap_providers_);

  if (node_allocator_ != nullptr) {
    tracker->TrackFieldWithSize(
        ""node_allocator"", sizeof(*node_allocator_), ""NodeArrayBufferAllocator"");
  }
  tracker->TrackFieldWithSize(
      ""platform"", sizeof(*platform_), ""MultiIsolatePlatform"");
  // TODO(joyeecheung): implement MemoryRetainer in the option classes.
}",60,,524,2,,void
76625,BLOCK,-1,,"{
    tracker->TrackFieldWithSize(
        ""node_allocator"", sizeof(*node_allocator_), ""NodeArrayBufferAllocator"");
  }",35,,534,2,,void
76647,BLOCK,-1,,"{
  if (!env_->owns_process_state() || !env_->can_call_into_js()) {
    // Ideally, we’d have a consistent story that treats all threads/Environment
    // instances equally here. However, tracing is essentially global, and this
    // callback is called from whichever thread calls `StartTracing()` or
    // `StopTracing()`. The only way to do this in a threadsafe fashion
    // seems to be only tracking this from the main thread, and only allowing
    // these state modifications from the main thread.
    return;
  }

  if (env_->principal_realm() == nullptr) {
    return;
  }

  bool async_hooks_enabled = (*(TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED(
                                 TRACING_CATEGORY_NODE1(async_hooks)))) != 0;

  Isolate* isolate = env_->isolate();
  HandleScope handle_scope(isolate);
  Local<Function> cb = env_->trace_category_state_function();
  if (cb.IsEmpty())
    return;
  TryCatchScope try_catch(env_);
  try_catch.SetVerbose(true);
  Local<Value> args[] = ...",61,,543,1,,void
76660,BLOCK,-1,,"{
    // Ideally, we’d have a consistent story that treats all threads/Environment
    // instances equally here. However, tracing is essentially global, and this
    // callback is called from whichever thread calls `StartTracing()` or
    // `StopTracing()`. The only way to do this in a threadsafe fashion
    // seems to be only tracking this from the main thread, and only allowing
    // these state modifications from the main thread.
    return;
  }",65,,544,2,,void
76669,BLOCK,-1,,"{
    return;
  }",43,,554,2,,void
76705,BLOCK,-1,,<empty>,5,,565,2,,void
76745,BLOCK,-1,,"{
  context->SetAlignedPointerInEmbedderData(ContextEmbedderIndex::kEnvironment,
                                           this);
  context->SetAlignedPointerInEmbedderData(ContextEmbedderIndex::kRealm, realm);
  // Used to retrieve bindings
  context->SetAlignedPointerInEmbedderData(
      ContextEmbedderIndex::kBindingDataStoreIndex,
      realm->binding_data_store());

  // ContextifyContexts will update this to a pointer to the native object.
  context->SetAlignedPointerInEmbedderData(
      ContextEmbedderIndex::kContextifyContext, nullptr);

  // This must not be done before other context fields are initialized.
  ContextEmbedderTag::TagNodeContext(context);

#if HAVE_INSPECTOR
  inspector_agent()->ContextCreated(context, info);
#endif  // HAVE_INSPECTOR

  this->async_hooks()->InstallPromiseHooks(context);
  TrackContext(context);
}",60,,574,4,,void
76802,BLOCK,-1,,"{
  loaded_addons_.emplace_back(filename, flags);
  if (!was_loaded(&loaded_addons_.back())) {
    loaded_addons_.pop_back();
  }
}",60,,601,4,,void
76817,BLOCK,-1,,"{
    loaded_addons_.pop_back();
  }",44,,603,2,,void
76825,BLOCK,-1,,"{
  char cwd[PATH_MAX_BYTES];
  size_t size = PATH_MAX_BYTES;
  const int err = uv_cwd(cwd, &size);

  if (err == 0) {
    CHECK_GT(size, 0);
    return cwd;
  }

  // This can fail if the cwd is deleted. In that case, fall back to
  // exec_path.
  const std::string& exec_path = exec_path_;
  return exec_path.substr(0, exec_path.find_last_of(kPathSeparator));
}",35,,608,1,,void
76842,BLOCK,-1,,"{
    CHECK_GT(size, 0);
    return cwd;
  }",17,,613,2,,void
76867,BLOCK,-1,,"{
  task_queues_async_refs_ += diff;
  CHECK_GE(task_queues_async_refs_, 0);
  if (task_queues_async_refs_ == 0)
    uv_unref(reinterpret_cast<uv_handle_t*>(&task_queues_async_));
  else
    uv_ref(reinterpret_cast<uv_handle_t*>(&task_queues_async_));
}",42,,624,2,,void
76878,BLOCK,-1,,<empty>,5,,628,2,,void
76885,BLOCK,-1,,<empty>,5,,630,1,,void
76895,BLOCK,-1,,"{
  NoArrayBufferZeroFillScope no_zero_fill_scope(isolate_data());
  std::unique_ptr<v8::BackingStore> bs =
      v8::ArrayBuffer::NewBackingStore(isolate(), suggested_size);
  uv_buf_t buf = uv_buf_init(static_cast<char*>(bs->Data()), bs->ByteLength());
  released_allocated_buffers_.emplace(buf.base, std::move(bs));
  return buf;
}",76,,633,2,,void
76949,BLOCK,-1,,"{
  std::unique_ptr<v8::BackingStore> bs;
  if (buf.base != nullptr) {
    auto it = released_allocated_buffers_.find(buf.base);
    CHECK_NE(it, released_allocated_buffers_.end());
    bs = std::move(it->second);
    released_allocated_buffers_.erase(it);
  }
  return bs;
}",26,,643,2,,void
76965,BLOCK,-1,,"{
    auto it = released_allocated_buffers_.find(buf.base);
    CHECK_NE(it, released_allocated_buffers_.end());
    bs = std::move(it->second);
    released_allocated_buffers_.erase(it);
  }",28,,645,2,,void
77002,BLOCK,-1,,"{
  char exec_path_buf[2 * PATH_MAX];
  size_t exec_path_len = sizeof(exec_path_buf);
  std::string exec_path;
  if (uv_exepath(exec_path_buf, &exec_path_len) == 0) {
    exec_path = std::string(exec_path_buf, exec_path_len);
  } else if (argv.size() > 0) {
    exec_path = argv[0];
  }

  // On OpenBSD process.execPath will be relative unless we
  // get the full path before process.execPath is used.
#if defined(__OpenBSD__)
  uv_fs_t req;
  req.ptr = nullptr;
  if (0 ==
      uv_fs_realpath(nullptr, &req, exec_path.c_str(), nullptr)) {
    CHECK_NOT_NULL(req.ptr);
    exec_path = std::string(static_cast<char*>(req.ptr));
  }
  uv_fs_req_cleanup(&req);
#endif

  return exec_path;
}",63,,654,2,,void
77017,BLOCK,-1,,"{
    exec_path = std::string(exec_path_buf, exec_path_len);
  }",55,,658,2,,void
77027,BLOCK,-1,,<empty>,10,,660,1,,void
77035,BLOCK,-1,,"{
    exec_path = argv[0];
  }",31,,660,2,,void
77053,BLOCK,-1,,"{
  constexpr bool is_shared_ro_heap =
#ifdef NODE_V8_SHARED_RO_HEAP
      true;
#else
      false;
#endif
  if (is_shared_ro_heap && !is_main_thread()) {
    // If this is a Worker thread and we are in shared-readonly-heap mode,
    // we can always safely use the parent's Isolate's code cache.
    CHECK_NOT_NULL(isolate_data->worker_context());
    builtin_loader()->CopySourceAndCodeCacheReferenceFrom(
        isolate_data->worker_context()->env()->builtin_loader());
  } else if (isolate_data->snapshot_data() != nullptr) {
    // ... otherwise, if a snapshot was provided, use its code cache.
    builtin_loader()->RefreshCodeCache(
        isolate_data->snapshot_data()->code_cache);
  }

  // We'll be creating new objects so make sure we've entered the context.
  HandleScope handle_scope(isolate);

  // Set some flags if only kDefaultFlags was passed. This can make API version
  // transitions easier for embedders.
  if (flags_ & EnvironmentFlags::kDefaultFlags) {
    flags_ = flag...",38,,712,8,,void
77063,BLOCK,-1,,"{
    // If this is a Worker thread and we are in shared-readonly-heap mode,
    // we can always safely use the parent's Isolate's code cache.
    CHECK_NOT_NULL(isolate_data->worker_context());
    builtin_loader()->CopySourceAndCodeCacheReferenceFrom(
        isolate_data->worker_context()->env()->builtin_loader());
  }",47,,719,2,,void
77084,BLOCK,-1,,<empty>,10,,725,1,,void
77092,BLOCK,-1,,"{
    // ... otherwise, if a snapshot was provided, use its code cache.
    builtin_loader()->RefreshCodeCache(
        isolate_data->snapshot_data()->code_cache);
  }",56,,725,2,,void
77112,BLOCK,-1,,"{
    flags_ = flags_ |
        EnvironmentFlags::kOwnsProcessState |
        EnvironmentFlags::kOwnsInspector;
  }",49,,736,2,,void
77179,BLOCK,-1,,"{
    set_abort_on_uncaught_exception(false);
  }",56,,757,2,,void
77183,BLOCK,-1,,<empty>,7,,766,1,,void
77188,BLOCK,-1,,"{
    trace_state_observer_ = std::make_unique<TrackingTraceStateObserver>(this);
    if (TracingController* tracing_controller = writer->GetTracingController())
      tracing_controller->AddTraceStateObserver(trace_state_observer_.get());
  }",69,,766,2,,void
77199,BLOCK,-1,,<empty>,9,,768,1,,void
77207,BLOCK,-1,,<empty>,7,,769,2,,void
77244,BLOCK,-1,,"{
    auto traced_value = tracing::TracedValue::Create();
    traced_value->BeginArray(""args"");
    for (const std::string& arg : args) traced_value->AppendString(arg);
    traced_value->EndArray();
    traced_value->BeginArray(""exec_args"");
    for (const std::string& arg : exec_args) traced_value->AppendString(arg);
    traced_value->EndArray();
    TRACE_EVENT_NESTABLE_ASYNC_BEGIN1(TRACING_CATEGORY_NODE1(environment),
                                      ""Environment"",
                                      this,
                                      ""args"",
                                      std::move(traced_value));
  }",54,,778,2,,void
77303,BLOCK,-1,,"{
    permission()->EnablePermissions();
    // If any permission is set the process shouldn't be able to neither
    // spawn/worker nor use addons unless explicitly allowed by the user
    if (!options_->allow_fs_read.empty() || !options_->allow_fs_write.empty()) {
      options_->allow_native_addons = false;
      if (!options_->allow_child_process) {
        permission()->Apply(""*"", permission::PermissionScope::kChildProcess);
      }
      if (!options_->allow_worker_threads) {
        permission()->Apply(""*"", permission::PermissionScope::kWorkerThreads);
      }
    }

    if (!options_->allow_fs_read.empty()) {
      permission()->Apply(options_->allow_fs_read,
                          permission::PermissionScope::kFileSystemRead);
    }

    if (!options_->allow_fs_write.empty()) {
      permission()->Apply(options_->allow_fs_write,
                          permission::PermissionScope::kFileSystemWrite);
    }
  }",42,,793,2,,void
77324,BLOCK,-1,,"{
      options_->allow_native_addons = false;
      if (!options_->allow_child_process) {
        permission()->Apply(""*"", permission::PermissionScope::kChildProcess);
      }
      if (!options_->allow_worker_threads) {
        permission()->Apply(""*"", permission::PermissionScope::kWorkerThreads);
      }
    }",80,,797,2,,void
77335,BLOCK,-1,,"{
        permission()->Apply(""*"", permission::PermissionScope::kChildProcess);
      }",43,,799,2,,void
77351,BLOCK,-1,,"{
        permission()->Apply(""*"", permission::PermissionScope::kWorkerThreads);
      }",44,,802,2,,void
77370,BLOCK,-1,,"{
      permission()->Apply(options_->allow_fs_read,
                          permission::PermissionScope::kFileSystemRead);
    }",43,,807,2,,void
77391,BLOCK,-1,,"{
      permission()->Apply(options_->allow_fs_write,
                          permission::PermissionScope::kFileSystemWrite);
    }",44,,812,2,,void
77409,BLOCK,-1,,"{
  principal_realm_ = std::make_unique<PrincipalRealm>(
      this, context, MAYBE_FIELD_PTR(env_info, principal_realm));
  AssignToContext(context, principal_realm_.get(), ContextInfo(""""));
  if (env_info != nullptr) {
    DeserializeProperties(env_info);
  }

  if (!options_->force_async_hooks_checks) {
    async_hooks_.no_force_checks();
  }

  // By default, always abort when --abort-on-uncaught-exception was passed.
  should_abort_on_uncaught_toggle_[0] = 1;

  // The process is not exiting by default.
  set_exiting(false);

  performance_state_->Mark(performance::NODE_PERFORMANCE_MILESTONE_ENVIRONMENT,
                           environment_start_);
  performance_state_->Mark(performance::NODE_PERFORMANCE_MILESTONE_NODE_START,
                           per_process::node_start_time);

  if (per_process::v8_initialized) {
    performance_state_->Mark(performance::NODE_PERFORMANCE_MILESTONE_V8_START,
                            performance::performance_v8_start);
  }
}",75,,820,3,,void
77437,BLOCK,-1,,"{
    DeserializeProperties(env_info);
  }",28,,824,2,,void
77445,BLOCK,-1,,"{
    async_hooks_.no_force_checks();
  }",44,,828,2,,void
77479,BLOCK,-1,,"{
    performance_state_->Mark(performance::NODE_PERFORMANCE_MILESTONE_V8_START,
                            performance::performance_v8_start);
  }",36,,843,2,,void
77493,BLOCK,-1,,"{
  HandleScope handle_scope(isolate());
  Local<Context> ctx = context();

  if (Environment** interrupt_data = interrupt_data_.load()) {
    // There are pending RequestInterrupt() callbacks. Tell them not to run,
    // then force V8 to run interrupts by compiling and running an empty script
    // so as not to leak memory.
    *interrupt_data = nullptr;

    Isolate::AllowJavascriptExecutionScope allow_js_here(isolate());
    TryCatch try_catch(isolate());
    Context::Scope context_scope(ctx);

#ifdef DEBUG
    bool consistency_check = false;
    isolate()->RequestInterrupt([](Isolate*, void* data) {
      *static_cast<bool*>(data) = true;
    }, &consistency_check);
#endif

    Local<Script> script;
    if (Script::Compile(ctx, String::Empty(isolate())).ToLocal(&script))
      USE(script->Run(ctx));

    DCHECK(consistency_check);
  }

  // FreeEnvironment() should have set this.
  CHECK(is_stopping());

  if (heapsnapshot_near_heap_limit_callback_added_) {
    RemoveHeapSnaps...",29,,849,1,,void
77505,BLOCK,-1,,<empty>,7,,853,1,,void
77513,BLOCK,-1,,"{
    // There are pending RequestInterrupt() callbacks. Tell them not to run,
    // then force V8 to run interrupts by compiling and running an empty script
    // so as not to leak memory.
    *interrupt_data = nullptr;

    Isolate::AllowJavascriptExecutionScope allow_js_here(isolate());
    TryCatch try_catch(isolate());
    Context::Scope context_scope(ctx);

#ifdef DEBUG
    bool consistency_check = false;
    isolate()->RequestInterrupt([](Isolate*, void* data) {
      *static_cast<bool*>(data) = true;
    }, &consistency_check);
#endif

    Local<Script> script;
    if (Script::Compile(ctx, String::Empty(isolate())).ToLocal(&script))
      USE(script->Run(ctx));

    DCHECK(consistency_check);
  }",62,,853,2,,void
77548,BLOCK,-1,,<empty>,7,,872,2,,void
77559,BLOCK,-1,,"{
    RemoveHeapSnapshotNearHeapLimitCallback(0);
  }",53,,880,2,,void
77589,BLOCK,-1,,"{
    tracing::AgentWriterHandle* writer = GetTracingAgentWriter();
    CHECK_NOT_NULL(writer);
    if (TracingController* tracing_controller = writer->GetTracingController())
      tracing_controller->RemoveTraceStateObserver(trace_state_observer_.get());
  }",30,,897,2,,void
77597,BLOCK,-1,,<empty>,9,,900,1,,void
77605,BLOCK,-1,,<empty>,7,,901,2,,void
77622,BLOCK,-1,,"{
    // Dereference all addons that were loaded into this environment.
    for (binding::DLib& addon : loaded_addons_) {
      addon.Close();
    }
  }",26,,912,2,,void
77626,BLOCK,-1,,"{
      addon.Close();
    }",49,,914,3,,void
77634,BLOCK,-1,,"{
    realm->OnEnvironmentDestruct();
  }",37,,919,3,,void
77642,BLOCK,-1,,"{
  HandleScope handle_scope(isolate());
  Context::Scope context_scope(context());

  CHECK_EQ(0, uv_timer_init(event_loop(), timer_handle()));
  uv_unref(reinterpret_cast<uv_handle_t*>(timer_handle()));

  CHECK_EQ(0, uv_check_init(event_loop(), immediate_check_handle()));
  uv_unref(reinterpret_cast<uv_handle_t*>(immediate_check_handle()));

  CHECK_EQ(0, uv_idle_init(event_loop(), immediate_idle_handle()));

  CHECK_EQ(0, uv_check_start(immediate_check_handle(), CheckImmediate));

  // Inform V8's CPU profiler when we're idle.  The profiler is sampling-based
  // but not all samples are created equal; mark the wall clock time spent in
  // epoll_wait() and friends so profiling tools can filter it out.  The samples
  // still end up in v8.log but with state=IDLE rather than state=EXTERNAL.
  CHECK_EQ(0, uv_prepare_init(event_loop(), &idle_prepare_handle_));
  CHECK_EQ(0, uv_check_init(event_loop(), &idle_check_handle_));

  CHECK_EQ(0, uv_async_init(
      event_loop(),
      &ta...",37,,924,1,,void
77711,BLOCK,17,,"{
    Mutex::ScopedLock lock(native_immediates_threadsafe_mutex_);
    task_queues_async_initialized_ = true;
    if (native_immediates_threadsafe_.size() > 0 ||
        native_immediates_interrupts_.size() > 0) {
      uv_async_send(&task_queues_async_);
    }
  }",3,,959,17,,void
77732,BLOCK,-1,,"{
      uv_async_send(&task_queues_async_);
    }",51,,963,2,,void
77740,BLOCK,-1,,"{
  // Should not access non-thread-safe methods here.
  set_stopping(true);
  if ((flags & StopFlags::kDoNotTerminateIsolate) == 0)
    isolate_->TerminateExecution();
  SetImmediateThreadsafe([](Environment* env) {
    env->set_can_call_into_js(false);
    uv_stop(env->event_loop());
  });
}",51,,977,2,,void
77751,BLOCK,-1,,<empty>,5,,981,2,,void
77761,BLOCK,-1,,"{
  HandleCleanupCb close_and_finish = [](Environment* env, uv_handle_t* handle,
                                        void* arg) {
    handle->data = env;

    env->CloseHandle(handle, [](uv_handle_t* handle) {
#ifdef DEBUG
      memset(handle, 0xab, uv_handle_size(handle->type));
#endif
    });
  };

  auto register_handle = [&](uv_handle_t* handle) {
    RegisterHandleCleanup(handle, close_and_finish, nullptr);
  };
  register_handle(reinterpret_cast<uv_handle_t*>(timer_handle()));
  register_handle(reinterpret_cast<uv_handle_t*>(immediate_check_handle()));
  register_handle(reinterpret_cast<uv_handle_t*>(immediate_idle_handle()));
  register_handle(reinterpret_cast<uv_handle_t*>(&idle_prepare_handle_));
  register_handle(reinterpret_cast<uv_handle_t*>(&idle_check_handle_));
  register_handle(reinterpret_cast<uv_handle_t*>(&task_queues_async_));
}",44,,988,1,,void
77799,BLOCK,-1,,"{
  {
    Mutex::ScopedLock lock(native_immediates_threadsafe_mutex_);
    task_queues_async_initialized_ = false;
  }

  Isolate::DisallowJavascriptExecutionScope disallow_js(isolate(),
      Isolate::DisallowJavascriptExecutionScope::THROW_ON_FAILURE);

  RunAndClearNativeImmediates(true /* skip unrefed SetImmediate()s */);

  for (ReqWrapBase* request : req_wrap_queue_)
    request->Cancel();

  for (HandleWrap* handle : handle_wrap_queue_)
    handle->Close();

  for (HandleCleanup& hc : handle_cleanup_queue_)
    hc.cb_(this, hc.handle_, hc.arg_);
  handle_cleanup_queue_.clear();

  while (handle_cleanup_waiting_ != 0 ||
         request_waiting_ != 0 ||
         !handle_wrap_queue_.IsEmpty()) {
    uv_run(event_loop(), UV_RUN_ONCE);
  }
}",36,,1011,1,,void
77800,BLOCK,1,,"{
    Mutex::ScopedLock lock(native_immediates_threadsafe_mutex_);
    task_queues_async_initialized_ = false;
  }",3,,1012,1,,void
77863,BLOCK,-1,,"{
    uv_run(event_loop(), UV_RUN_ONCE);
  }",41,,1034,2,,void
77870,BLOCK,-1,,"{
  uv_prepare_start(&idle_prepare_handle_, [](uv_prepare_t* handle) {
    Environment* env = ContainerOf(&Environment::idle_prepare_handle_, handle);
    env->isolate()->SetIdle(true);
  });
  uv_check_start(&idle_check_handle_, [](uv_check_t* handle) {
    Environment* env = ContainerOf(&Environment::idle_check_handle_, handle);
    env->isolate()->SetIdle(false);
  });
}",47,,1039,1,,void
77882,BLOCK,-1,,"{
  if (!trace_sync_io_) return;

  HandleScope handle_scope(isolate());

  fprintf(
      stderr, ""(node:%d) WARNING: Detected use of sync API\n"", uv_os_getpid());
  PrintStackTrace(isolate(),
                  StackTrace::CurrentStackTrace(
                      isolate(), stack_trace_limit(), StackTrace::kDetailed));
}",42,,1050,1,,void
77886,BLOCK,-1,,<empty>,24,,1051,2,,void
77909,BLOCK,-1,,"{
  EscapableHandleScope handle_scope(isolate());
  if (!snapshot_serialize_callback().IsEmpty()) {
    Context::Scope context_scope(context());
    return handle_scope.EscapeMaybe(snapshot_serialize_callback()->Call(
        context(), v8::Undefined(isolate()), 0, nullptr));
  }
  return handle_scope.Escape(Undefined(isolate()));
}",69,,1062,1,,void
77919,BLOCK,-1,,"{
    Context::Scope context_scope(context());
    return handle_scope.EscapeMaybe(snapshot_serialize_callback()->Call(
        context(), v8::Undefined(isolate()), 0, nullptr));
  }",49,,1064,2,,void
77950,BLOCK,-1,,"{
  EscapableHandleScope handle_scope(isolate());
  if (!snapshot_deserialize_main().IsEmpty()) {
    Context::Scope context_scope(context());
    return handle_scope.EscapeMaybe(snapshot_deserialize_main()->Call(
        context(), v8::Undefined(isolate()), 0, nullptr));
  }
  return handle_scope.Escape(Undefined(isolate()));
}",67,,1072,1,,void
77960,BLOCK,-1,,"{
    Context::Scope context_scope(context());
    return handle_scope.EscapeMaybe(snapshot_deserialize_main()->Call(
        context(), v8::Undefined(isolate()), 0, nullptr));
  }",47,,1074,2,,void
77991,BLOCK,-1,,"{
  started_cleanup_ = true;
  TRACE_EVENT0(TRACING_CATEGORY_NODE1(environment), ""RunCleanup"");
  // Only BaseObject's cleanups are registered as per-realm cleanup hooks now.
  // Defer the BaseObject cleanup after handles are cleaned up.
  CleanupHandles();

  while (!cleanup_queue_.empty() || principal_realm_->HasCleanupHooks() ||
         native_immediates_.size() > 0 ||
         native_immediates_threadsafe_.size() > 0 ||
         native_immediates_interrupts_.size() > 0) {
    // TODO(legendecas): cleanup handles in per-realm cleanup hooks as well.
    principal_realm_->RunCleanup();
    cleanup_queue_.Drain();
    CleanupHandles();
  }

  for (const int fd : unmanaged_fds_) {
    uv_fs_t close_req;
    uv_fs_close(nullptr, &close_req, fd, nullptr);
    uv_fs_req_cleanup(&close_req);
  }
}",32,,1082,1,,void
78032,BLOCK,-1,,"{
    // TODO(legendecas): cleanup handles in per-realm cleanup hooks as well.
    principal_realm_->RunCleanup();
    cleanup_queue_.Drain();
    CleanupHandles();
  }",52,,1092,2,,void
78045,BLOCK,-1,,"{
    uv_fs_t close_req;
    uv_fs_close(nullptr, &close_req, fd, nullptr);
    uv_fs_req_cleanup(&close_req);
  }",39,,1099,3,,void
78059,BLOCK,-1,,"{
  TRACE_EVENT0(TRACING_CATEGORY_NODE1(environment), ""AtExit"");
  for (ExitCallback at_exit : at_exit_functions_) {
    at_exit.cb_(at_exit.arg_);
  }
  at_exit_functions_.clear();
}",40,,1106,1,,void
78067,BLOCK,-1,,"{
    at_exit.cb_(at_exit.arg_);
  }",51,,1108,3,,void
78084,BLOCK,-1,,"{
  at_exit_functions_.push_front(ExitCallback{cb, arg});
}",60,,1114,3,,void
78096,BLOCK,-1,,"{
  while (native_immediates_interrupts_.size() > 0) {
    NativeImmediateQueue queue;
    {
      Mutex::ScopedLock lock(native_immediates_threadsafe_mutex_);
      queue.ConcatMove(std::move(native_immediates_interrupts_));
    }
    DebugSealHandleScope seal_handle_scope(isolate());

    while (auto head = queue.Shift())
      head->Call(this);
  }
}",43,,1118,1,,void
78104,BLOCK,-1,,"{
    NativeImmediateQueue queue;
    {
      Mutex::ScopedLock lock(native_immediates_threadsafe_mutex_);
      queue.ConcatMove(std::move(native_immediates_interrupts_));
    }
    DebugSealHandleScope seal_handle_scope(isolate());

    while (auto head = queue.Shift())
      head->Call(this);
  }",52,,1119,2,,void
78106,BLOCK,2,,"{
      Mutex::ScopedLock lock(native_immediates_threadsafe_mutex_);
      queue.ConcatMove(std::move(native_immediates_interrupts_));
    }",5,,1121,2,,void
78131,BLOCK,-1,,"{
  TRACE_EVENT0(TRACING_CATEGORY_NODE1(environment),
               ""RunAndClearNativeImmediates"");
  HandleScope handle_scope(isolate_);
  // In case the Isolate is no longer accessible just use an empty Local. This
  // is not an issue for InternalCallbackScope as this case is already handled
  // in its constructor but we avoid calls into v8 which can crash the process
  // in debug builds.
  Local<Object> obj =
      can_call_into_js() ? Object::New(isolate_) : Local<Object>();
  InternalCallbackScope cb_scope(this, obj, {0, 0});

  size_t ref_count = 0;

  // Handle interrupts first. These functions are not allowed to throw
  // exceptions, so we do not need to handle that.
  RunAndClearInterrupts();

  auto drain_list = [&](NativeImmediateQueue* queue) {
    TryCatchScope try_catch(this);
    DebugSealHandleScope seal_handle_scope(isolate());
    while (auto head = queue->Shift()) {
      bool is_refed = head->flags() & CallbackFlags::kRefed;
      if (is_refed)
        ref_c...",64,,1132,2,,void
78172,BLOCK,-1,,<empty>,43,,1172,2,,void
78185,BLOCK,-1,,<empty>,5,,1177,2,,void
78196,BLOCK,-1,,"{
    Mutex::ScopedLock lock(native_immediates_threadsafe_mutex_);
    threadsafe_immediates.ConcatMove(std::move(native_immediates_threadsafe_));
  }",49,,1187,2,,void
78213,BLOCK,-1,,<empty>,46,,1191,2,,void
78217,BLOCK,-1,,"{
  // The Isolate may outlive the Environment, so some logic to handle the
  // situation in which the Environment is destroyed before the handler runs
  // is required.

  // We allocate a new pointer to a pointer to this Environment instance, and
  // try to set it as interrupt_data_. If interrupt_data_ was already set, then
  // callbacks are already scheduled to run and we can delete our own pointer
  // and just return. If it was nullptr previously, the Environment** is stored;
  // ~Environment sets the Environment* contained in it to nullptr, so that
  // the callback can check whether ~Environment has already run and it is thus
  // not safe to access the Environment instance itself.
  Environment** interrupt_data = new Environment*(this);
  Environment** dummy = nullptr;
  if (!interrupt_data_.compare_exchange_strong(dummy, interrupt_data)) {
    delete interrupt_data;
    return;  // Already scheduled.
  }

  isolate()->RequestInterrupt([](Isolate* isolate, void* data) {
...",44,,1194,1,,void
78236,BLOCK,-1,,"{
    delete interrupt_data;
    return;  // Already scheduled.
  }",72,,1208,2,,void
78250,BLOCK,-1,,"{
  if (started_cleanup_) return;
  uv_timer_start(timer_handle(), RunTimers, duration_ms, 0);
}",54,,1227,2,,void
78253,BLOCK,-1,,<empty>,25,,1228,2,,void
78264,BLOCK,-1,,"{
  if (started_cleanup_) return;

  if (ref) {
    uv_ref(reinterpret_cast<uv_handle_t*>(timer_handle()));
  } else {
    uv_unref(reinterpret_cast<uv_handle_t*>(timer_handle()));
  }
}",44,,1232,2,,void
78267,BLOCK,-1,,<empty>,25,,1233,2,,void
78271,BLOCK,-1,,"{
    uv_ref(reinterpret_cast<uv_handle_t*>(timer_handle()));
  }",12,,1235,2,,void
78277,BLOCK,-1,,"{
    uv_unref(reinterpret_cast<uv_handle_t*>(timer_handle()));
  }",10,,1237,1,,void
78286,BLOCK,-1,,"{
  Environment* env = Environment::from_timer_handle(handle);
  TRACE_EVENT0(TRACING_CATEGORY_NODE1(environment), ""RunTimers"");

  if (!env->can_call_into_js())
    return;

  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Object> process = env->process_object();
  InternalCallbackScope scope(env, process, {0, 0});

  Local<Function> cb = env->timers_callback_function();
  MaybeLocal<Value> ret;
  Local<Value> arg = env->GetNow();
  // This code will loop until all currently due timers will process. It is
  // impossible for us to end up in an infinite loop due to how the JS-side
  // is structured.
  do {
    TryCatchScope try_catch(env);
    try_catch.SetVerbose(true);
    ret = cb->Call(env->context(), process, 1, &arg);
  } while (ret.IsEmpty() && env->can_call_into_js());

  // NOTE(apapirovski): If it ever becomes possible that `call_into_js` above
  // is reset back to `true` after being previously set to `false` then this
...",49,,1242,2,,void
78305,BLOCK,-1,,<empty>,5,,1247,2,,void
78362,BLOCK,-1,,"{
    TryCatchScope try_catch(env);
    try_catch.SetVerbose(true);
    ret = cb->Call(env->context(), process, 1, &arg);
  }",6,,1261,1,,void
78399,BLOCK,-1,,<empty>,5,,1273,2,,void
78428,BLOCK,-1,,"{
    int64_t duration_ms =
        llabs(expiry_ms) - (uv_now(env->event_loop()) - env->timer_base());

    env->ScheduleTimer(duration_ms > 0 ? duration_ms : 1);

    if (expiry_ms > 0)
      uv_ref(h);
    else
      uv_unref(h);
  }",23,,1287,2,,void
78459,BLOCK,-1,,<empty>,7,,1294,2,,void
78463,BLOCK,-1,,<empty>,7,,1296,1,,void
78467,BLOCK,-1,,"{
    uv_unref(h);
  }",10,,1297,1,,void
78474,BLOCK,-1,,"{
  Environment* env = Environment::from_immediate_check_handle(handle);
  TRACE_EVENT0(TRACING_CATEGORY_NODE1(environment), ""CheckImmediate"");

  HandleScope scope(env->isolate());
  Context::Scope context_scope(env->context());

  env->RunAndClearNativeImmediates();

  if (env->immediate_info()->count() == 0 || !env->can_call_into_js())
    return;

  do {
    MakeCallback(env->isolate(),
                 env->process_object(),
                 env->immediate_callback_function(),
                 0,
                 nullptr,
                 {0, 0}).ToLocalChecked();
  } while (env->immediate_info()->has_outstanding() && env->can_call_into_js());

  if (env->immediate_info()->ref_count() == 0)
    env->ToggleImmediateRef(false);
}",54,,1303,2,,void
78519,BLOCK,-1,,<empty>,5,,1313,2,,void
78522,BLOCK,-1,,"{
    MakeCallback(env->isolate(),
                 env->process_object(),
                 env->immediate_callback_function(),
                 0,
                 nullptr,
                 {0, 0}).ToLocalChecked();
  }",6,,1315,1,,void
78566,BLOCK,-1,,<empty>,5,,1325,2,,void
78576,BLOCK,-1,,"{
  if (started_cleanup_) return;

  if (ref) {
    // Idle handle is needed only to stop the event loop from blocking in poll.
    uv_idle_start(immediate_idle_handle(), [](uv_idle_t*){ });
  } else {
    uv_idle_stop(immediate_idle_handle());
  }
}",48,,1328,2,,void
78579,BLOCK,-1,,<empty>,25,,1329,2,,void
78583,BLOCK,-1,,"{
    // Idle handle is needed only to stop the event loop from blocking in poll.
    uv_idle_start(immediate_idle_handle(), [](uv_idle_t*){ });
  }",12,,1331,2,,void
78588,BLOCK,-1,,"{
    uv_idle_stop(immediate_idle_handle());
  }",10,,1334,1,,void
78593,BLOCK,-1,,"{
  uv_update_time(event_loop());
  uint64_t now = uv_now(event_loop());
  CHECK_GE(now, timer_base());
  now -= timer_base();
  return now;
}",38,,1339,1,,void
78611,BLOCK,-1,,"{
  uint64_t now = GetNowUint64();
  if (now <= 0xffffffff)
    return Integer::NewFromUnsigned(isolate(), static_cast<uint32_t>(now));
  else
    return Number::New(isolate(), static_cast<double>(now));
}",36,,1347,1,,void
78620,BLOCK,-1,,<empty>,5,,1350,2,,void
78631,BLOCK,-1,,<empty>,5,,1352,1,,void
78652,BLOCK,-1,,"{
  obj->Set(env->context(),
           env->errno_string(),
           Integer::New(env->isolate(), errorno)).Check();

  obj->Set(env->context(), env->code_string(),
           OneByteString(env->isolate(), err_string)).Check();

  if (message != nullptr) {
    obj->Set(env->context(), env->message_string(),
             OneByteString(env->isolate(), message)).Check();
  }

  Local<Value> path_buffer;
  if (path != nullptr) {
    path_buffer =
      Buffer::Copy(env->isolate(), path, strlen(path)).ToLocalChecked();
    obj->Set(env->context(), env->path_string(), path_buffer).Check();
  }

  Local<Value> dest_buffer;
  if (dest != nullptr) {
    dest_buffer =
      Buffer::Copy(env->isolate(), dest, strlen(dest)).ToLocalChecked();
    obj->Set(env->context(), env->dest_string(), dest_buffer).Check();
  }

  if (syscall != nullptr) {
    obj->Set(env->context(), env->syscall_string(),
             OneByteString(env->isolate(), syscall)).Check();
  }
}",45,,1362,9,,void
78702,BLOCK,-1,,"{
    obj->Set(env->context(), env->message_string(),
             OneByteString(env->isolate(), message)).Check();
  }",27,,1370,2,,void
78733,BLOCK,-1,,"{
    path_buffer =
      Buffer::Copy(env->isolate(), path, strlen(path)).ToLocalChecked();
    obj->Set(env->context(), env->path_string(), path_buffer).Check();
  }",24,,1376,2,,void
78775,BLOCK,-1,,"{
    dest_buffer =
      Buffer::Copy(env->isolate(), dest, strlen(dest)).ToLocalChecked();
    obj->Set(env->context(), env->dest_string(), dest_buffer).Check();
  }",24,,1383,2,,void
78812,BLOCK,-1,,"{
    obj->Set(env->context(), env->syscall_string(),
             OneByteString(env->isolate(), syscall)).Check();
  }",27,,1389,2,,void
78843,BLOCK,-1,,"{
  if (!object->IsObject() || errorno == 0)
    return;

  Local<Object> obj = object.As<Object>();
  const char* err_string = uv_err_name(errorno);

  if (message == nullptr || message[0] == '\0') {
    message = uv_strerror(errorno);
  }

  node::CollectExceptionInfo(this, obj, errorno, err_string,
                             syscall, message, path, dest);
}",60,,1400,7,,void
78854,BLOCK,-1,,<empty>,5,,1402,2,,void
78881,BLOCK,-1,,"{
    message = uv_strerror(errorno);
  }",49,,1407,2,,void
78903,BLOCK,-1,,<empty>,69,,1416,3,,void
78909,BLOCK,-1,,"{
  return {fields_.Serialize(context, creator)};
}",55,,1419,3,,void
78915,BLOCK,-1,,"{
  fields_.Deserialize(context);
}",57,,1423,2,,void
78926,BLOCK,-1,,"{
  output << ""{ "" << i.fields << "" }"";
  return output;
}",65,,1428,3,,void
78942,BLOCK,-1,,"{
  tracker->TrackField(""fields"", fields_);
}",62,,1433,2,,void
78954,BLOCK,-1,,"{
  return {fields_.Serialize(context, creator)};
}",71,,1438,3,,void
78960,BLOCK,-1,,"{
  fields_.Deserialize(context);
}",52,,1442,2,,void
78971,BLOCK,-1,,"{
  output << ""{ "" << i.fields << "" }"";
  return output;
}",60,,1447,3,,void
78987,BLOCK,-1,,"{
  tracker->TrackField(""fields"", fields_);
}",57,,1452,2,,void
78999,BLOCK,-1,,<empty>,79,,1458,3,,void
79005,BLOCK,-1,,"{
  HandleScope handle_scope(isolate);
  if (info == nullptr) {
    clear_async_id_stack();

    // Always perform async_hooks checks, not just when async_hooks is enabled.
    // TODO(AndreasMadsen): Consider removing this for LTS releases.
    // See discussion in https://github.com/nodejs/node/pull/15454
    // When removing this, do it by reverting the commit. Otherwise the test
    // and flag changes won't be included.
    fields_[kCheck] = 1;

    // kDefaultTriggerAsyncId should be -1, this indicates that there is no
    // specified default value and it should fallback to the executionAsyncId.
    // 0 is not used as the magic value, because that indicates a missing
    // context which is different from a default context.
    async_id_fields_[AsyncHooks::kDefaultTriggerAsyncId] = -1;

    // kAsyncIdCounter should start at 1 because that'll be the id the execution
    // context during bootstrap (code that runs before entering uv_run()).
    async_id_fields_[AsyncHooks::kA...",19,,1465,3,,void
79013,BLOCK,-1,,"{
    clear_async_id_stack();

    // Always perform async_hooks checks, not just when async_hooks is enabled.
    // TODO(AndreasMadsen): Consider removing this for LTS releases.
    // See discussion in https://github.com/nodejs/node/pull/15454
    // When removing this, do it by reverting the commit. Otherwise the test
    // and flag changes won't be included.
    fields_[kCheck] = 1;

    // kDefaultTriggerAsyncId should be -1, this indicates that there is no
    // specified default value and it should fallback to the executionAsyncId.
    // 0 is not used as the magic value, because that indicates a missing
    // context which is different from a default context.
    async_id_fields_[AsyncHooks::kDefaultTriggerAsyncId] = -1;

    // kAsyncIdCounter should start at 1 because that'll be the id the execution
    // context during bootstrap (code that runs before entering uv_run()).
    async_id_fields_[AsyncHooks::kAsyncIdCounter] = 1;
  }",24,,1467,2,,void
79039,BLOCK,-1,,"{
  async_ids_stack_.Deserialize(context);
  fields_.Deserialize(context);
  async_id_fields_.Deserialize(context);

  Local<Array> js_execution_async_resources;
  if (info_->js_execution_async_resources != 0) {
    js_execution_async_resources =
        context->GetDataFromSnapshotOnce<Array>(
            info_->js_execution_async_resources).ToLocalChecked();
  } else {
    js_execution_async_resources = Array::New(context->GetIsolate());
  }
  js_execution_async_resources_.Reset(
      context->GetIsolate(), js_execution_async_resources);

  // The native_execution_async_resources_ field requires v8::Local<> instances
  // for async calls whose resources were on the stack as JS objects when they
  // were entered. We cannot recreate this here; however, storing these values
  // on the JS equivalent gives the same result, so we do that instead.
  for (size_t i = 0; i < info_->native_execution_async_resources.size(); ++i) {
    if (info_->native_execution_async_resources[i] == SIZE_...",54,,1489,2,,void
79066,BLOCK,-1,,"{
    js_execution_async_resources =
        context->GetDataFromSnapshotOnce<Array>(
            info_->js_execution_async_resources).ToLocalChecked();
  }",49,,1495,2,,void
79082,BLOCK,-1,,"{
    js_execution_async_resources = Array::New(context->GetIsolate());
  }",10,,1499,1,,void
79103,BLOCK,-1,,<empty>,3,,1509,1,,void
79118,BLOCK,4,,"{
    if (info_->native_execution_async_resources[i] == SIZE_MAX)
      continue;
    Local<Object> obj = context->GetDataFromSnapshotOnce<Object>(
                                   info_->native_execution_async_resources[i])
                               .ToLocalChecked();
    js_execution_async_resources->Set(context, i, obj).Check();
  }",79,,1509,4,,void
79127,BLOCK,-1,,<empty>,7,,1511,2,,void
79167,BLOCK,-1,,"{
  output << ""{\n""
         << ""  "" << i.async_ids_stack << "",  // async_ids_stack\n""
         << ""  "" << i.fields << "",  // fields\n""
         << ""  "" << i.async_id_fields << "",  // async_id_fields\n""
         << ""  "" << i.js_execution_async_resources
         << "",  // js_execution_async_resources\n""
         << ""  "" << i.native_execution_async_resources
         << "",  // native_execution_async_resources\n""
         << ""}"";
  return output;
}",62,,1521,3,,void
79220,BLOCK,-1,,"{
  SerializeInfo info;
  // TODO(joyeecheung): some of these probably don't need to be serialized.
  info.async_ids_stack = async_ids_stack_.Serialize(context, creator);
  info.fields = fields_.Serialize(context, creator);
  info.async_id_fields = async_id_fields_.Serialize(context, creator);
  if (!js_execution_async_resources_.IsEmpty()) {
    info.js_execution_async_resources = creator->AddData(
        context, js_execution_async_resources_.Get(context->GetIsolate()));
    CHECK_NE(info.js_execution_async_resources, 0);
  } else {
    info.js_execution_async_resources = 0;
  }

  info.native_execution_async_resources.resize(
      native_execution_async_resources_.size());
  for (size_t i = 0; i < native_execution_async_resources_.size(); i++) {
    info.native_execution_async_resources[i] =
        native_execution_async_resources_[i].IsEmpty() ? SIZE_MAX :
            creator->AddData(
                context,
                native_execution_async_resources_[i]);
  }

  // A...",75,,1535,3,,void
79258,BLOCK,-1,,"{
    info.js_execution_async_resources = creator->AddData(
        context, js_execution_async_resources_.Get(context->GetIsolate()));
    CHECK_NE(info.js_execution_async_resources, 0);
  }",49,,1541,2,,void
79282,BLOCK,-1,,"{
    info.js_execution_async_resources = 0;
  }",10,,1545,1,,void
79299,BLOCK,-1,,<empty>,3,,1551,1,,void
79312,BLOCK,4,,"{
    info.native_execution_async_resources[i] =
        native_execution_async_resources_[i].IsEmpty() ? SIZE_MAX :
            creator->AddData(
                context,
                native_execution_async_resources_[i]);
  }",73,,1551,4,,void
79369,BLOCK,-1,,"{
  tracker->TrackField(""async_ids_stack"", async_ids_stack_);
  tracker->TrackField(""fields"", fields_);
  tracker->TrackField(""async_id_fields"", async_id_fields_);
  tracker->TrackField(""js_promise_hooks"", js_promise_hooks_);
}",59,,1569,2,,void
79397,BLOCK,-1,,"{
  async_ids_stack_.reserve(async_ids_stack_.Length() * 3);

  env()->async_hooks_binding()->Set(
      env()->context(),
      env()->async_ids_stack_string(),
      async_ids_stack_.GetJSArray()).Check();
}",41,,1576,1,,void
79434,BLOCK,-1,,"{
  fprintf(stderr,
          ""Error: async hook stack has become corrupted (""
          ""actual: %.f, expected: %.f)\n"",
          async_id_fields_.GetValue(kExecutionAsyncId),
          expected_async_id);
  DumpBacktrace(stderr);
  fflush(stderr);
  // TODO(joyeecheung): should this exit code be more specific?
  if (!env()->abort_on_uncaught_exception()) Exit(ExitCode::kGenericUserError);
  fprintf(stderr, ""\n"");
  fflush(stderr);
  ABORT_NO_BACKTRACE();
}",72,,1585,2,,void
79453,BLOCK,-1,,<empty>,46,,1594,2,,void
79468,BLOCK,-1,,"{
  if (options()->trace_exit) {
    HandleScope handle_scope(isolate());
    Isolate::DisallowJavascriptExecutionScope disallow_js(
        isolate(), Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);

    if (is_main_thread()) {
      fprintf(stderr, ""(node:%d) "", uv_os_getpid());
    } else {
      fprintf(stderr, ""(node:%d, thread:%"" PRIu64 "") "",
              uv_os_getpid(), thread_id());
    }

    fprintf(stderr,
            ""WARNING: Exited the environment with code %d\n"",
            static_cast<int>(exit_code));
    PrintStackTrace(isolate(),
                    StackTrace::CurrentStackTrace(
                        isolate(), stack_trace_limit(), StackTrace::kDetailed));
  }
  process_exit_handler_(this, exit_code);
}",44,,1600,2,,void
79473,BLOCK,-1,,"{
    HandleScope handle_scope(isolate());
    Isolate::DisallowJavascriptExecutionScope disallow_js(
        isolate(), Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);

    if (is_main_thread()) {
      fprintf(stderr, ""(node:%d) "", uv_os_getpid());
    } else {
      fprintf(stderr, ""(node:%d, thread:%"" PRIu64 "") "",
              uv_os_getpid(), thread_id());
    }

    fprintf(stderr,
            ""WARNING: Exited the environment with code %d\n"",
            static_cast<int>(exit_code));
    PrintStackTrace(isolate(),
                    StackTrace::CurrentStackTrace(
                        isolate(), stack_trace_limit(), StackTrace::kDetailed));
  }",30,,1601,2,,void
79487,BLOCK,-1,,"{
      fprintf(stderr, ""(node:%d) "", uv_os_getpid());
    }",27,,1606,2,,void
79493,BLOCK,-1,,"{
      fprintf(stderr, ""(node:%d, thread:%"" PRIu64 "") "",
              uv_os_getpid(), thread_id());
    }",12,,1608,1,,void
79518,BLOCK,-1,,"{
  DCHECK_EQ(Isolate::GetCurrent(), isolate());

  while (!sub_worker_contexts_.empty()) {
    Worker* w = *sub_worker_contexts_.begin();
    remove_sub_worker_context(w);
    w->Exit(ExitCode::kGenericUserError);
    w->JoinThread();
  }
}",46,,1623,1,,void
79531,BLOCK,-1,,"{
    Worker* w = *sub_worker_contexts_.begin();
    remove_sub_worker_context(w);
    w->Exit(ExitCode::kGenericUserError);
    w->JoinThread();
  }",41,,1626,2,,void
79556,BLOCK,-1,,"{
  if (worker_context() == nullptr) return nullptr;
  return worker_context()->env();
}",53,,1634,1,,void
79561,BLOCK,-1,,<empty>,36,,1635,2,,void
79573,BLOCK,-1,,"{
  if (!tracks_unmanaged_fds()) return;
  auto result = unmanaged_fds_.insert(fd);
  if (!result.second) {
    ProcessEmitWarning(
        this, ""File descriptor %d opened in unmanaged mode twice"", fd);
  }
}",42,,1639,2,,void
79577,BLOCK,-1,,<empty>,32,,1640,2,,void
79592,BLOCK,-1,,"{
    ProcessEmitWarning(
        this, ""File descriptor %d opened in unmanaged mode twice"", fd);
  }",23,,1642,2,,void
79601,BLOCK,-1,,"{
  if (!tracks_unmanaged_fds()) return;
  size_t removed_count = unmanaged_fds_.erase(fd);
  if (removed_count == 0) {
    ProcessEmitWarning(
        this, ""File descriptor %d closed but not opened in unmanaged mode"", fd);
  }
}",45,,1648,2,,void
79605,BLOCK,-1,,<empty>,32,,1649,2,,void
79619,BLOCK,-1,,"{
    ProcessEmitWarning(
        this, ""File descriptor %d closed but not opened in unmanaged mode"", fd);
  }",27,,1651,2,,void
79627,BLOCK,-1,,"{
  if (enabled_debug_list()->enabled(DebugCategory::MKSNAPSHOT)) {
    fprintf(stderr, ""At the exit of the Environment:\n"");
    principal_realm()->PrintInfoForSnapshot();
  }
}",49,,1657,1,,void
79636,BLOCK,-1,,"{
    fprintf(stderr, ""At the exit of the Environment:\n"");
    principal_realm()->PrintInfoForSnapshot();
  }",65,,1658,2,,void
79648,BLOCK,-1,,"{
  EnvSerializeInfo info;
  Local<Context> ctx = context();

  info.async_hooks = async_hooks_.Serialize(ctx, creator);
  info.immediate_info = immediate_info_.Serialize(ctx, creator);
  info.timeout_info = timeout_info_.Serialize(ctx, creator);
  info.tick_info = tick_info_.Serialize(ctx, creator);
  info.performance_state = performance_state_->Serialize(ctx, creator);
  info.exit_info = exit_info_.Serialize(ctx, creator);
  info.stream_base_state = stream_base_state_.Serialize(ctx, creator);
  info.should_abort_on_uncaught_toggle =
      should_abort_on_uncaught_toggle_.Serialize(ctx, creator);

  info.principal_realm = principal_realm_->Serialize(creator);
  // For now we only support serialization of the main context.
  // TODO(joyeecheung): support de/serialization of vm contexts.
  CHECK_EQ(contexts_.size(), 1);
  CHECK_EQ(contexts_[0], context());
  return info;
}",67,,1664,2,,void
79766,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  DeserializeRequest request{cb, {isolate(), holder}, index, info};
  deserialize_requests_.push_back(std::move(request));
}",74,,1689,5,,void
79794,BLOCK,-1,,"{
  HandleScope scope(isolate());
  Local<Context> ctx = context();
  Isolate* is = isolate();
  while (!deserialize_requests_.empty()) {
    DeserializeRequest request(std::move(deserialize_requests_.front()));
    deserialize_requests_.pop_front();
    Local<Object> holder = request.holder.Get(is);
    request.cb(ctx, holder, request.index, request.info);
    request.holder.Reset();
    request.info->Delete();
  }
}",44,,1695,1,,void
79815,BLOCK,-1,,"{
    DeserializeRequest request(std::move(deserialize_requests_.front()));
    deserialize_requests_.pop_front();
    Local<Object> holder = request.holder.Get(is);
    request.cb(ctx, holder, request.index, request.info);
    request.holder.Reset();
    request.info->Delete();
  }",42,,1699,2,,void
79871,BLOCK,-1,,"{
  Local<Context> ctx = context();

  if (enabled_debug_list_.enabled(DebugCategory::MKSNAPSHOT)) {
    fprintf(stderr, ""deserializing EnvSerializeInfo...\n"");
    std::cerr << *info << ""\n"";
  }

  RunDeserializeRequests();

  async_hooks_.Deserialize(ctx);
  immediate_info_.Deserialize(ctx);
  timeout_info_.Deserialize(ctx);
  tick_info_.Deserialize(ctx);
  performance_state_->Deserialize(ctx);
  exit_info_.Deserialize(ctx);
  stream_base_state_.Deserialize(ctx);
  should_abort_on_uncaught_toggle_.Deserialize(ctx);

  principal_realm_->DeserializeProperties(&info->principal_realm);
}",71,,1709,2,,void
79887,BLOCK,-1,,"{
    fprintf(stderr, ""deserializing EnvSerializeInfo...\n"");
    std::cerr << *info << ""\n"";
  }",63,,1712,2,,void
79951,BLOCK,-1,,"{
  uint64_t free_in_system = uv_get_free_memory();
  size_t allowed = uv_get_constrained_memory();
  if (allowed == 0) {
    return free_in_system;
  }
  size_t rss;
  int err = uv_resident_set_memory(&rss);
  if (err) {
    return free_in_system;
  }
  if (allowed < rss) {
    // Something is probably wrong. Fallback to the free memory.
    return free_in_system;
  }
  // There may still be room for swap, but we will just leave it here.
  return allowed - rss;
}",45,,1731,1,,void
79964,BLOCK,-1,,"{
    return free_in_system;
  }",21,,1734,2,,void
79976,BLOCK,-1,,"{
    return free_in_system;
  }",12,,1739,2,,void
79983,BLOCK,-1,,"{
    // Something is probably wrong. Fallback to the free memory.
    return free_in_system;
  }",22,,1742,2,,void
79996,BLOCK,-1,,"{
  MemoryTracker tracker(isolate, graph);
  Environment* env = static_cast<Environment*>(data);
  // Start traversing embedder objects from the root Environment object.
  tracker.Track(env);
}",50,,1752,4,,void
80018,BLOCK,-1,,"{
  Environment* env = static_cast<Environment*>(data);

  Debug(env,
        DebugCategory::DIAGNOSTICS,
        ""Invoked NearHeapLimitCallback, processing=%d, ""
        ""current_limit=%"" PRIu64 "", ""
        ""initial_limit=%"" PRIu64 ""\n"",
        env->is_in_heapsnapshot_heap_limit_callback_,
        static_cast<uint64_t>(current_heap_limit),
        static_cast<uint64_t>(initial_heap_limit));

  size_t max_young_gen_size = env->isolate_data()->max_young_gen_size;
  size_t young_gen_size = 0;
  size_t old_gen_size = 0;

  HeapSpaceStatistics stats;
  size_t num_heap_spaces = env->isolate()->NumberOfHeapSpaces();
  for (size_t i = 0; i < num_heap_spaces; ++i) {
    env->isolate()->GetHeapSpaceStatistics(&stats, i);
    if (strcmp(stats.space_name(), ""new_space"") == 0 ||
        strcmp(stats.space_name(), ""new_large_object_space"") == 0) {
      young_gen_size += stats.space_used_size();
    } else {
      old_gen_size += stats.space_used_size();
    }
  }

  Debug(env,
        DebugCa...",70,,1761,4,,void
80055,BLOCK,-1,,<empty>,3,,1779,1,,void
80065,BLOCK,4,,"{
    env->isolate()->GetHeapSpaceStatistics(&stats, i);
    if (strcmp(stats.space_name(), ""new_space"") == 0 ||
        strcmp(stats.space_name(), ""new_large_object_space"") == 0) {
      young_gen_size += stats.space_used_size();
    } else {
      old_gen_size += stats.space_used_size();
    }
  }",48,,1779,4,,void
80094,BLOCK,-1,,"{
      young_gen_size += stats.space_used_size();
    }",68,,1782,2,,void
80102,BLOCK,-1,,"{
      old_gen_size += stats.space_used_size();
    }",12,,1784,1,,void
80129,BLOCK,-1,,"{
    Debug(env,
          DebugCategory::DIAGNOSTICS,
          ""Not generating snapshots in nested callback. ""
          ""new_limit=%"" PRIu64 ""\n"",
          static_cast<uint64_t>(new_limit));
    return new_limit;
  }",53,,1822,2,,void
80137,BLOCK,-1,,"{
    Debug(env,
          DebugCategory::DIAGNOSTICS,
          ""Not generating snapshots because it's too risky.\n"");
    env->RemoveHeapSnapshotNearHeapLimitCallback(0);
    // The new limit must be higher than current_heap_limit or V8 might
    // crash.
    return new_limit;
  }",39,,1834,2,,void
80170,BLOCK,-1,,"{
    dir = env->GetCwd();
  }",20,,1848,2,,void
80242,BLOCK,-1,,"{
    Debug(env,
          DebugCategory::DIAGNOSTICS,
          ""Removing the near heap limit callback"");
    env->RemoveHeapSnapshotNearHeapLimitCallback(0);
  }",79,,1869,2,,void
80279,BLOCK,-1,,"{
  size_t size = sizeof(*this);
  // Remove non pointer fields that will be tracked in MemoryInfo()
  // TODO(joyeecheung): refactor the MemoryTracker interface so
  // this can be done for common types within the Track* calls automatically
  // if a certain scope is entered.
  size -= sizeof(async_hooks_);
  size -= sizeof(cleanup_queue_);
  size -= sizeof(tick_info_);
  size -= sizeof(immediate_info_);
  return size;
}",45,,1888,1,,void
80308,BLOCK,-1,,"{
  // Iteratable STLs have their own sizes subtracted from the parent
  // by default.
  tracker->TrackField(""isolate_data"", isolate_data_);
  tracker->TrackField(""destroy_async_id_list"", destroy_async_id_list_);
  tracker->TrackField(""exec_argv"", exec_argv_);
  tracker->TrackField(""exit_info"", exit_info_);
  tracker->TrackField(""should_abort_on_uncaught_toggle"",
                      should_abort_on_uncaught_toggle_);
  tracker->TrackField(""stream_base_state"", stream_base_state_);
  tracker->TrackField(""cleanup_queue"", cleanup_queue_);
  tracker->TrackField(""async_hooks"", async_hooks_);
  tracker->TrackField(""immediate_info"", immediate_info_);
  tracker->TrackField(""timeout_info"", timeout_info_);
  tracker->TrackField(""tick_info"", tick_info_);
  tracker->TrackField(""principal_realm"", principal_realm_);
  tracker->TrackField(""shadow_realms"", shadow_realms_);

  // FIXME(joyeecheung): track other fields in Environment.
  // Currently MemoryTracker is unable to track these
  // corre...",60,,1901,2,,void
80390,BLOCK,-1,,"{
  isolate()->ClearKeptObjects();
}",39,,1930,1,,void
80469,BLOCK,-1,,<empty>,1,,1,1,,ANY
80474,BLOCK,-1,,<empty>,1,,1,1,,ANY
80493,BLOCK,-1,,<empty>,1,,1,1,,ANY
80502,BLOCK,-1,,<empty>,,,,5,,<empty>
80507,BLOCK,-1,,<empty>,,,,2,,<empty>
80512,BLOCK,-1,,<empty>,,,,2,,<empty>
80517,BLOCK,-1,,<empty>,,,,2,,<empty>
80522,BLOCK,-1,,<empty>,,,,2,,<empty>
80529,BLOCK,-1,,<empty>,,,,3,,<empty>
80533,BLOCK,-1,,<empty>,,,,1,,<empty>
80541,BLOCK,-1,,<empty>,,,,5,,<empty>
80548,BLOCK,-1,,<empty>,,,,1,,<empty>
80557,BLOCK,-1,,"{
  MarkAsUninitialized();
}",51,,84,3,,void
80563,BLOCK,-1,,"{
  FSEventWrap* wrap = Unwrap<FSEventWrap>(args.This());
  CHECK_NOT_NULL(wrap);
  args.GetReturnValue().Set(!wrap->IsHandleClosing());
}",75,,89,2,,void
80596,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->InstanceTemplate()->SetInternalFieldCount(
      FSEventWrap::kInternalFieldCount);

  t->Inherit(HandleWrap::GetConstructorTemplate(env));
  SetProtoMethod(isolate, t, ""start"", Start);

  Local<FunctionTemplate> get_initialized_templ =
      FunctionTemplate::New(env->isolate(),
                            GetInitialized,
                            Local<Value>(),
                            Signature::New(env->isolate(), t));

  t->PrototypeTemplate()->SetAccessorProperty(
      FIXED_ONE_BYTE_STRING(env->isolate(), ""initialized""),
      get_initialized_templ,
      Local<FunctionTemplate>(),
      static_cast<PropertyAttribute>(ReadOnly | DontDelete | DontEnum));

  SetConstructorFunction(context, target, ""FSEvent"", t);
}",42,,98,5,,void
80701,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(Start);
  registry->Register(GetInitialized);
}",42,,125,2,,void
80721,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new FSEventWrap(env, args.This());
}",64,,131,2,,void
80746,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  FSEventWrap* wrap = Unwrap<FSEventWrap>(args.This());
  CHECK_NOT_NULL(wrap);
  CHECK(wrap->IsHandleClosing());  // Check that Start() has not been called.

  const int argc = args.Length();
  CHECK_GE(argc, 4);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, *path);

  unsigned int flags = 0;
  if (args[2]->IsTrue())
    flags |= UV_FS_EVENT_RECURSIVE;

  wrap->encoding_ = ParseEncoding(env->isolate(), args[3], kDefaultEncoding);

  int err = uv_fs_event_init(wrap->env()->event_loop(), &wrap->handle_);
  if (err != 0) {
    return args.GetReturnValue().Set(err);
  }

  err = uv_fs_event_start(&wrap->handle_, OnEvent, *path, flags);
  wrap->MarkAsInitialized();

  if (err != 0) {
    FSEventWrap::Close(args);
    return args.GetReturnValue().Set(err);
  }

  // Check for persistent argument
  if (!args[1]->IsTru...",66,,138,2,,void
80815,BLOCK,-1,,<empty>,5,,155,2,,void
80851,BLOCK,-1,,"{
    return args.GetReturnValue().Set(err);
  }",17,,160,2,,void
80880,BLOCK,-1,,"{
    FSEventWrap::Close(args);
    return args.GetReturnValue().Set(err);
  }",17,,167,2,,void
80903,BLOCK,-1,,"{
    uv_unref(reinterpret_cast<uv_handle_t*>(&wrap->handle_));
  }",27,,173,2,,void
80926,BLOCK,-1,,"{
  FSEventWrap* wrap = static_cast<FSEventWrap*>(handle->data);
  Environment* env = wrap->env();

  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  CHECK_EQ(wrap->persistent().IsEmpty(), false);

  // We're in a bind here. libuv can set both UV_RENAME and UV_CHANGE but
  // the Node API only lets us pass a single event to JS land.
  //
  // The obvious solution is to run the callback twice, once for each event.
  // However, since the second event is not allowed to fire if the handle is
  // closed after the first event, and since there is no good way to detect
  // closed handles, that option is out.
  //
  // For now, ignore the UV_CHANGE event if UV_RENAME is also set. Make the
  // assumption that a rename implicitly means an attribute change. Not too
  // unreasonable, right? Still, we should revisit this before v1.0.
  Local<String> event_string;
  if (status) {
    event_string = String::Empty(env->isolate());
  } else if (events...",29,,182,5,,void
80970,BLOCK,-1,,"{
    event_string = String::Empty(env->isolate());
  }",15,,203,2,,void
80982,BLOCK,-1,,<empty>,10,,205,1,,void
80987,BLOCK,-1,,"{
    event_string = env->rename_string();
  }",34,,205,2,,void
80995,BLOCK,-1,,<empty>,10,,207,1,,void
81000,BLOCK,-1,,"{
    event_string = env->change_string();
  }",34,,207,2,,void
81008,BLOCK,-1,,"{
    UNREACHABLE(""bad fs events flag"");
  }",10,,209,1,,void
81034,BLOCK,-1,,"{
    Local<Value> error;
    MaybeLocal<Value> fn = StringBytes::Encode(env->isolate(),
                                               filename,
                                               wrap->encoding_,
                                               &error);
    if (fn.IsEmpty()) {
      argv[0] = Integer::New(env->isolate(), UV_EINVAL);
      argv[2] = StringBytes::Encode(env->isolate(),
                                    filename,
                                    strlen(filename),
                                    BUFFER,
                                    &error).ToLocalChecked();
    } else {
      argv[2] = fn.ToLocalChecked();
    }
  }",28,,219,2,,void
81065,BLOCK,-1,,"{
      argv[0] = Integer::New(env->isolate(), UV_EINVAL);
      argv[2] = StringBytes::Encode(env->isolate(),
                                    filename,
                                    strlen(filename),
                                    BUFFER,
                                    &error).ToLocalChecked();
    }",23,,225,2,,void
81101,BLOCK,-1,,"{
      argv[2] = fn.ToLocalChecked();
    }",12,,232,1,,void
81138,BLOCK,-1,,<empty>,1,,1,1,,ANY
81142,BLOCK,-1,,"{
  HandleWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  if (IsAlive(wrap))
    uv_ref(wrap->GetHandle());
}",63,,40,2,,void
81154,BLOCK,-1,,<empty>,5,,45,2,,void
81164,BLOCK,-1,,"{
  HandleWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  if (IsAlive(wrap))
    uv_unref(wrap->GetHandle());
}",65,,49,2,,void
81176,BLOCK,-1,,<empty>,5,,54,2,,void
81186,BLOCK,-1,,"{
  HandleWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  args.GetReturnValue().Set(HasRef(wrap));
}",66,,58,2,,void
81208,BLOCK,-1,,"{
  HandleWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  wrap->Close(args[0]);
}",65,,65,2,,void
81228,BLOCK,-1,,"{
  if (state_ != kInitialized)
    return;

  uv_close(handle_, OnClose);
  state_ = kClosing;

  if (!close_callback.IsEmpty() && close_callback->IsFunction() &&
      !persistent().IsEmpty()) {
    object()->Set(env()->context(),
                  env()->handle_onclose_symbol(),
                  close_callback).Check();
  }
}",53,,72,2,,void
81233,BLOCK,-1,,<empty>,5,,74,2,,void
81258,BLOCK,-1,,"{
    object()->Set(env()->context(),
                  env()->handle_onclose_symbol(),
                  close_callback).Check();
  }",32,,80,2,,void
81278,BLOCK,-1,,"{
  // When all references to a HandleWrap are lost and the object is supposed to
  // be destroyed, we first call Close() to clean up the underlying libuv
  // handle. The OnClose callback then acquires and destroys another reference
  // to that object, and when that reference is lost, we perform the default
  // action (i.e. destroying `this`).
  if (state_ != kClosed) {
    Close();
  } else {
    BaseObject::OnGCCollect();
  }
}",32,,88,1,,void
81283,BLOCK,-1,,"{
    Close();
  }",26,,94,2,,void
81286,BLOCK,-1,,"{
    BaseObject::OnGCCollect();
  }",10,,96,1,,void
81294,BLOCK,-1,,"{
  return IsWeakOrDetached() ||
         !HandleWrap::HasRef(this) ||
         !uv_is_active(GetHandle());
}",60,,102,1,,void
81311,BLOCK,-1,,"{
  env()->handle_wrap_queue()->PushBack(this);
  state_ = kInitialized;
}",38,,109,1,,void
81326,BLOCK,-1,,"{
  handle_wrap_queue_.Remove();
  state_ = kClosed;
}",40,,115,1,,void
81341,BLOCK,-1,,"{
  handle_->data = this;
  HandleScope scope(env->isolate());
  CHECK(env->has_run_bootstrapping_code());
  env->handle_wrap_queue()->PushBack(this);
}",23,,127,5,,void
81370,BLOCK,-1,,"{
  CHECK_NOT_NULL(handle->data);
  BaseObjectPtr<HandleWrap> wrap { static_cast<HandleWrap*>(handle->data) };
  wrap->Detach();

  Environment* env = wrap->env();
  HandleScope scope(env->isolate());
  Context::Scope context_scope(env->context());

  CHECK_EQ(wrap->state_, kClosing);

  wrap->state_ = kClosed;

  wrap->OnClose();
  wrap->handle_wrap_queue_.Remove();

  if (!wrap->persistent().IsEmpty() &&
      wrap->object()->Has(env->context(), env->handle_onclose_symbol())
      .FromMaybe(false)) {
    wrap->MakeCallback(env->handle_onclose_symbol(), 0, nullptr);
  }
}",47,,135,2,,void
81458,BLOCK,-1,,"{
    wrap->MakeCallback(env->handle_onclose_symbol(), 0, nullptr);
  }",26,,153,2,,void
81473,BLOCK,-1,,"{
  return GetConstructorTemplate(env->isolate_data());
}",78,,157,2,,void
81484,BLOCK,-1,,"{
  Local<FunctionTemplate> tmpl = isolate_data->handle_wrap_ctor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = isolate_data->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->SetClassName(
        FIXED_ONE_BYTE_STRING(isolate_data->isolate(), ""HandleWrap""));
    tmpl->Inherit(AsyncWrap::GetConstructorTemplate(isolate_data));
    SetProtoMethod(isolate, tmpl, ""close"", HandleWrap::Close);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""hasRef"", HandleWrap::HasRef);
    SetProtoMethod(isolate, tmpl, ""ref"", HandleWrap::Ref);
    SetProtoMethod(isolate, tmpl, ""unref"", HandleWrap::Unref);
    isolate_data->set_handle_wrap_ctor_template(tmpl);
  }
  return tmpl;
}",32,,162,2,,void
81500,BLOCK,-1,,"{
    Isolate* isolate = isolate_data->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->SetClassName(
        FIXED_ONE_BYTE_STRING(isolate_data->isolate(), ""HandleWrap""));
    tmpl->Inherit(AsyncWrap::GetConstructorTemplate(isolate_data));
    SetProtoMethod(isolate, tmpl, ""close"", HandleWrap::Close);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""hasRef"", HandleWrap::HasRef);
    SetProtoMethod(isolate, tmpl, ""ref"", HandleWrap::Ref);
    SetProtoMethod(isolate, tmpl, ""unref"", HandleWrap::Unref);
    isolate_data->set_handle_wrap_ctor_template(tmpl);
  }",23,,164,2,,void
81571,BLOCK,-1,,"{
  registry->Register(HandleWrap::Close);
  registry->Register(HandleWrap::HasRef);
  registry->Register(HandleWrap::Ref);
  registry->Register(HandleWrap::Unref);
}",42,,180,2,,void
81615,BLOCK,-1,,<empty>,1,,1,1,,ANY
81634,BLOCK,-1,,<empty>,1,,1,1,,ANY
81639,BLOCK,-1,,"{ return ""<JS Node>""; }",31,,48,1,,void
81645,BLOCK,-1,,{ return 0; },33,,49,1,,void
81651,BLOCK,-1,,{ return false; },34,,50,1,,void
81657,BLOCK,-1,,{ return PersistentToLocal::Strong(persistent_); },26,,51,1,,void
81667,BLOCK,-1,,"{
    Local<Value> v = JSValue();
    if (v->IsObject()) return v.As<Object>()->GetIdentityHash();
    if (v->IsName()) return v.As<v8::Name>()->GetIdentityHash();
    if (v->IsInt32()) return v.As<v8::Int32>()->Value();
    return 0;
  }",22,,53,1,,void
81680,BLOCK,-1,,<empty>,24,,55,2,,void
81694,BLOCK,-1,,<empty>,22,,56,2,,void
81708,BLOCK,-1,,<empty>,23,,57,2,,void
81724,BLOCK,-1,,"{
    CHECK(!val.IsEmpty());
  }",35,,62,3,,void
81736,BLOCK,-1,,"{
      return static_cast<size_t>(n->IdentityHash());
    }",54,,67,2,,void
81750,BLOCK,-1,,"{
      return a->JSValue()->SameValue(b->JSValue());
    }",70,,73,3,,void
81769,BLOCK,-1,,<empty>,58,,84,2,,void
81774,BLOCK,-1,,"{
    std::unique_ptr<JSGraphJSNode> n { new JSGraphJSNode(isolate_, value) };
    auto it = engine_nodes_.find(n.get());
    if (it != engine_nodes_.end())
      return *it;
    engine_nodes_.insert(n.get());
    return AddNode(std::unique_ptr<Node>(n.release()));
  }",52,,86,2,,void
81801,BLOCK,-1,,<empty>,7,,90,2,,void
81829,BLOCK,-1,,"{
    Node* n = node.get();
    nodes_.emplace(std::move(node));
    return n;
  }",54,,95,2,,void
81854,BLOCK,-1,,"{
    edges_[from].insert(std::make_pair(name, to));
  }",75,,101,4,,void
81870,BLOCK,-1,,"{
    EscapableHandleScope handle_scope(isolate_);
    Local<Context> context = isolate_->GetCurrentContext();
    Environment* env = Environment::GetCurrent(context);

    std::unordered_map<Node*, Local<Object>> info_objects;
    Local<Array> nodes = Array::New(isolate_, nodes_.size());
    Local<String> edges_string = FIXED_ONE_BYTE_STRING(isolate_, ""edges"");
    Local<String> is_root_string = FIXED_ONE_BYTE_STRING(isolate_, ""isRoot"");
    Local<String> name_string = env->name_string();
    Local<String> size_string = env->size_string();
    Local<String> value_string = env->value_string();
    Local<String> wraps_string = FIXED_ONE_BYTE_STRING(isolate_, ""wraps"");
    Local<String> to_string = FIXED_ONE_BYTE_STRING(isolate_, ""to"");

    for (const std::unique_ptr<Node>& n : nodes_)
      info_objects[n.get()] = Object::New(isolate_);

    {
      HandleScope handle_scope(isolate_);
      size_t i = 0;
      for (const std::unique_ptr<Node>& n : nodes_) {
        Local<Object> obj...",42,,105,1,,void
81989,BLOCK,16,,"{
      HandleScope handle_scope(isolate_);
      size_t i = 0;
      for (const std::unique_ptr<Node>& n : nodes_) {
        Local<Object> obj = info_objects[n.get()];
        Local<Value> value;
        std::string name_str;
        const char* prefix = n->NamePrefix();
        if (prefix == nullptr) {
          name_str = n->Name();
        } else {
          name_str = n->NamePrefix();
          name_str += "" "";
          name_str += n->Name();
        }
        if (!String::NewFromUtf8(isolate_, name_str.c_str()).ToLocal(&value) ||
            obj->Set(context, name_string, value).IsNothing() ||
            obj->Set(context,
                     is_root_string,
                     Boolean::New(isolate_, n->IsRootNode()))
                .IsNothing() ||
            obj->Set(
                   context,
                   size_string,
                   Number::New(isolate_, static_cast<double>(n->SizeInBytes())))
                .IsNothing() ||
            obj->Set(context, edg...",5,,123,16,,void
82000,BLOCK,-1,,"{
        Local<Object> obj = info_objects[n.get()];
        Local<Value> value;
        std::string name_str;
        const char* prefix = n->NamePrefix();
        if (prefix == nullptr) {
          name_str = n->Name();
        } else {
          name_str = n->NamePrefix();
          name_str += "" "";
          name_str += n->Name();
        }
        if (!String::NewFromUtf8(isolate_, name_str.c_str()).ToLocal(&value) ||
            obj->Set(context, name_string, value).IsNothing() ||
            obj->Set(context,
                     is_root_string,
                     Boolean::New(isolate_, n->IsRootNode()))
                .IsNothing() ||
            obj->Set(
                   context,
                   size_string,
                   Number::New(isolate_, static_cast<double>(n->SizeInBytes())))
                .IsNothing() ||
            obj->Set(context, edges_string, Array::New(isolate_)).IsNothing()) {
          return MaybeLocal<Array>();
        }
        if (nodes->S...",53,,126,3,,void
82030,BLOCK,-1,,"{
          name_str = n->Name();
        }",32,,131,2,,void
82038,BLOCK,-1,,"{
          name_str = n->NamePrefix();
          name_str += "" "";
          name_str += n->Name();
        }",16,,133,1,,void
82136,BLOCK,-1,,"{
          return MaybeLocal<Array>();
        }",80,,149,2,,void
82151,BLOCK,-1,,<empty>,11,,153,2,,void
82160,BLOCK,-1,,"{
          value = static_cast<JSGraphJSNode*>(n.get())->JSValue();
          if (obj->Set(context, value_string, value).IsNothing())
            return MaybeLocal<Array>();
        }",35,,154,2,,void
82183,BLOCK,-1,,<empty>,13,,157,2,,void
82189,BLOCK,-1,,"{
      Node* wraps = n->WrapperNode();
      if (wraps == nullptr) continue;
      Local<Object> from = info_objects[n.get()];
      Local<Object> to = info_objects[wraps];
      if (from->Set(context, wraps_string, to).IsNothing())
        return MaybeLocal<Array>();
    }",51,,162,3,,void
82201,BLOCK,-1,,<empty>,29,,164,2,,void
82235,BLOCK,-1,,<empty>,9,,168,2,,void
82241,BLOCK,-1,,"{
      Node* source = edge_info.first;
      Local<Value> edges;
      if (!info_objects[source]->Get(context, edges_string).ToLocal(&edges) ||
          !edges->IsArray()) {
        return MaybeLocal<Array>();
      }

      size_t i = 0;
      size_t j = 0;
      for (const auto& edge : edge_info.second) {
        Local<Object> to_object = info_objects[edge.second];
        Local<Object> edge_obj = Object::New(isolate_);
        Local<Value> edge_name_value;
        const char* edge_name = edge.first;
        if (edge_name != nullptr) {
          if (!String::NewFromUtf8(isolate_, edge_name)
              .ToLocal(&edge_name_value)) {
            return MaybeLocal<Array>();
          }
        } else {
          edge_name_value = Number::New(isolate_, static_cast<double>(j++));
        }
        if (edge_obj->Set(context, name_string, edge_name_value).IsNothing() ||
            edge_obj->Set(context, to_string, to_object).IsNothing() ||
            edges.As<Array>()->Set(context,...",42,,171,3,,void
82274,BLOCK,-1,,"{
        return MaybeLocal<Array>();
      }",30,,175,2,,void
82290,BLOCK,-1,,"{
        Local<Object> to_object = info_objects[edge.second];
        Local<Object> edge_obj = Object::New(isolate_);
        Local<Value> edge_name_value;
        const char* edge_name = edge.first;
        if (edge_name != nullptr) {
          if (!String::NewFromUtf8(isolate_, edge_name)
              .ToLocal(&edge_name_value)) {
            return MaybeLocal<Array>();
          }
        } else {
          edge_name_value = Number::New(isolate_, static_cast<double>(j++));
        }
        if (edge_obj->Set(context, name_string, edge_name_value).IsNothing() ||
            edge_obj->Set(context, to_string, to_object).IsNothing() ||
            edges.As<Array>()->Set(context, i++, edge_obj).IsNothing()) {
          return MaybeLocal<Array>();
        }
      }",49,,181,3,,void
82328,BLOCK,-1,,"{
          if (!String::NewFromUtf8(isolate_, edge_name)
              .ToLocal(&edge_name_value)) {
            return MaybeLocal<Array>();
          }
        }",35,,186,2,,void
82342,BLOCK,-1,,"{
            return MaybeLocal<Array>();
          }",43,,188,2,,void
82346,BLOCK,-1,,"{
          edge_name_value = Number::New(isolate_, static_cast<double>(j++));
        }",16,,191,1,,void
82395,BLOCK,-1,,"{
          return MaybeLocal<Array>();
        }",73,,196,2,,void
82412,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  JSGraph graph(env->isolate());
  Environment::BuildEmbedderGraph(env->isolate(), &graph, env);
  Local<Array> ret;
  if (graph.CreateObject().ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",66,,213,2,,void
82453,BLOCK,-1,,<empty>,5,,219,2,,void
82469,BLOCK,-1,,<empty>,69,,225,3,,void
82473,BLOCK,-1,,"{
    return 65536;  // big chunks == faster
  }",31,,227,1,,void
82479,BLOCK,-1,,<empty>,31,,231,1,,void
82485,BLOCK,-1,,"{
    DCHECK_EQ(status_, 0);
    int offset = 0;
    while (offset < size) {
      const uv_buf_t buf = uv_buf_init(data + offset, size - offset);
      const int num_bytes_written = uv_fs_write(nullptr,
                                                req_,
                                                fd_,
                                                &buf,
                                                1,
                                                -1,
                                                nullptr);
      uv_fs_req_cleanup(req_);
      if (num_bytes_written < 0) {
        status_ = num_bytes_written;
        return kAbort;
      }
      DCHECK_LE(static_cast<size_t>(num_bytes_written), buf.len);
      offset += num_bytes_written;
    }
    DCHECK_EQ(offset, size);
    return kContinue;
  }",68,,233,3,,void
82497,BLOCK,-1,,"{
      const uv_buf_t buf = uv_buf_init(data + offset, size - offset);
      const int num_bytes_written = uv_fs_write(nullptr,
                                                req_,
                                                fd_,
                                                &buf,
                                                1,
                                                -1,
                                                nullptr);
      uv_fs_req_cleanup(req_);
      if (num_bytes_written < 0) {
        status_ = num_bytes_written;
        return kAbort;
      }
      DCHECK_LE(static_cast<size_t>(num_bytes_written), buf.len);
      offset += num_bytes_written;
    }",27,,236,2,,void
82527,BLOCK,-1,,"{
        status_ = num_bytes_written;
        return kAbort;
      }",34,,246,2,,void
82551,BLOCK,-1,,{ return status_; },22,,257,1,,void
82560,BLOCK,-1,,<empty>,,,,1,,<empty>
82571,BLOCK,-1,,"{
    MakeWeak();
    StreamBase::AttachToObject(GetObject());
  }",38,,275,4,,void
82577,BLOCK,-1,,<empty>,34,,280,1,,void
82581,BLOCK,-1,,"{
    return 65536;  // big chunks == faster
  }",31,,282,1,,void
82587,BLOCK,-1,,"{
    EmitRead(UV_EOF);
    snapshot_.reset();
  }",31,,286,1,,void
82598,BLOCK,-1,,"{
    int len = size;
    while (len != 0) {
      uv_buf_t buf = EmitAlloc(size);
      ssize_t avail = len;
      if (static_cast<ssize_t>(buf.len) < avail)
        avail = buf.len;
      memcpy(buf.base, data, avail);
      data += avail;
      len -= static_cast<int>(avail);
      EmitRead(size, buf);
    }
    return kContinue;
  }",62,,291,3,,void
82607,BLOCK,-1,,"{
      uv_buf_t buf = EmitAlloc(size);
      ssize_t avail = len;
      if (static_cast<ssize_t>(buf.len) < avail)
        avail = buf.len;
      memcpy(buf.base, data, avail);
      data += avail;
      len -= static_cast<int>(avail);
      EmitRead(size, buf);
    }",22,,293,2,,void
82625,BLOCK,-1,,<empty>,9,,297,2,,void
82653,BLOCK,-1,,"{
    CHECK_NE(snapshot_, nullptr);
    snapshot_->Serialize(this, HeapSnapshot::kJSON);
    return 0;
  }",28,,306,1,,void
82670,BLOCK,-1,,"{
    return 0;
  }",27,,312,1,,void
82677,BLOCK,-1,,"{
    UNREACHABLE();
  }",51,,316,2,,void
82686,BLOCK,-1,,"{
    UNREACHABLE();
  }",50,,323,5,,void
82691,BLOCK,-1,,{ return snapshot_ != nullptr; },27,,327,1,,void
82699,BLOCK,-1,,{ return snapshot_ == nullptr; },29,,328,1,,void
82707,BLOCK,-1,,{ return this; },38,,329,1,,void
82714,BLOCK,-1,,"{
    if (snapshot_ != nullptr) {
      tracker->TrackFieldWithSize(
          ""snapshot"", sizeof(*snapshot_), ""HeapSnapshot"");
    }
  }",58,,331,2,,void
82719,BLOCK,-1,,"{
      tracker->TrackFieldWithSize(
          ""snapshot"", sizeof(*snapshot_), ""HeapSnapshot"");
    }",31,,332,2,,void
82740,BLOCK,-1,,"{
  HeapSnapshotPointer snapshot{
      env->isolate()->GetHeapProfiler()->TakeHeapSnapshot(options)};
  snapshot->Serialize(out, HeapSnapshot::kJSON);
}",69,,347,4,,void
82770,BLOCK,-1,,"{
  uv_fs_t req;
  int err;

  const int fd = uv_fs_open(nullptr,
                            &req,
                            filename,
                            O_WRONLY | O_CREAT | O_TRUNC,
                            S_IWUSR | S_IRUSR,
                            nullptr);
  uv_fs_req_cleanup(&req);
  if ((err = fd) < 0) {
    env->ThrowUVException(err, ""open"", nullptr, filename);
    return Nothing<void>();
  }

  FileOutputStream stream(fd, &req);
  TakeSnapshot(env, &stream, options);
  if ((err = stream.status()) < 0) {
    env->ThrowUVException(err, ""write"", nullptr, filename);
    return Nothing<void>();
  }

  err = uv_fs_close(nullptr, &req, fd, nullptr);
  uv_fs_req_cleanup(&req);
  if (err < 0) {
    env->ThrowUVException(err, ""close"", nullptr, filename);
    return Nothing<void>();
  }

  return JustVoid();
}",70,,357,4,,void
82799,BLOCK,-1,,"{
    env->ThrowUVException(err, ""open"", nullptr, filename);
    return Nothing<void>();
  }",23,,368,2,,void
82829,BLOCK,-1,,"{
    env->ThrowUVException(err, ""write"", nullptr, filename);
    return Nothing<void>();
  }",36,,375,2,,void
82855,BLOCK,-1,,"{
    env->ThrowUVException(err, ""close"", nullptr, filename);
    return Nothing<void>();
  }",16,,382,2,,void
82872,BLOCK,-1,,"{
  const_cast<HeapSnapshot*>(snapshot)->Delete();
}",55,,390,2,,void
82884,BLOCK,-1,,"{
  HandleScope scope(env->isolate());

  if (env->streambaseoutputstream_constructor_template().IsEmpty()) {
    // Create FunctionTemplate for HeapSnapshotStream
    Local<FunctionTemplate> os = FunctionTemplate::New(env->isolate());
    os->Inherit(AsyncWrap::GetConstructorTemplate(env));
    Local<ObjectTemplate> ost = os->InstanceTemplate();
    ost->SetInternalFieldCount(StreamBase::kInternalFieldCount);
    os->SetClassName(
        FIXED_ONE_BYTE_STRING(env->isolate(), ""HeapSnapshotStream""));
    StreamBase::AddMethods(env, os);
    env->set_streambaseoutputstream_constructor_template(ost);
  }

  Local<Object> obj;
  if (!env->streambaseoutputstream_constructor_template()
           ->NewInstance(env->context())
           .ToLocal(&obj)) {
    return {};
  }
  return MakeBaseObject<HeapSnapshotStream>(env, std::move(snapshot), obj);
}",55,,395,3,,void
82899,BLOCK,-1,,"{
    // Create FunctionTemplate for HeapSnapshotStream
    Local<FunctionTemplate> os = FunctionTemplate::New(env->isolate());
    os->Inherit(AsyncWrap::GetConstructorTemplate(env));
    Local<ObjectTemplate> ost = os->InstanceTemplate();
    ost->SetInternalFieldCount(StreamBase::kInternalFieldCount);
    os->SetClassName(
        FIXED_ONE_BYTE_STRING(env->isolate(), ""HeapSnapshotStream""));
    StreamBase::AddMethods(env, os);
    env->set_streambaseoutputstream_constructor_template(ost);
  }",69,,398,2,,void
82984,BLOCK,-1,,"{
    return {};
  }",28,,413,2,,void
83004,BLOCK,-1,,"{
  CHECK(options_value->IsUint8Array());
  Local<Uint8Array> arr = options_value.As<Uint8Array>();
  uint8_t* options =
      static_cast<uint8_t*>(arr->Buffer()->Data()) + arr->ByteOffset();
  HeapProfiler::HeapSnapshotOptions result;
  result.snapshot_mode = options[0]
                             ? HeapProfiler::HeapSnapshotMode::kExposeInternals
                             : HeapProfiler::HeapSnapshotMode::kRegular;
  result.numerics_mode = options[1]
                             ? HeapProfiler::NumericsMode::kExposeNumericValues
                             : HeapProfiler::NumericsMode::kHideNumericValues;
  return result;
}",33,,420,2,,void
83080,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK_EQ(args.Length(), 1);
  auto options = GetHeapSnapshotOptions(args[0]);
  HeapSnapshotPointer snapshot{
      env->isolate()->GetHeapProfiler()->TakeHeapSnapshot(options)};
  CHECK(snapshot);
  BaseObjectPtr<AsyncWrap> stream =
      CreateHeapSnapshotStream(env, std::move(snapshot));
  if (stream)
    args.GetReturnValue().Set(stream->object());
}",72,,435,2,,void
83134,BLOCK,-1,,<empty>,5,,445,2,,void
83150,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = args.GetIsolate();
  CHECK_EQ(args.Length(), 2);
  Local<Value> filename_v = args[0];
  auto options = GetHeapSnapshotOptions(args[1]);

  if (filename_v->IsUndefined()) {
    DiagnosticFilename name(env, ""Heap"", ""heapsnapshot"");
    if (WriteSnapshot(env, *name, options).IsNothing()) return;
    if (String::NewFromUtf8(isolate, *name).ToLocal(&filename_v)) {
      args.GetReturnValue().Set(filename_v);
    }
    return;
  }

  BufferValue path(isolate, filename_v);
  CHECK_NOT_NULL(*path);
  if (WriteSnapshot(env, *path, options).IsNothing()) return;
  return args.GetReturnValue().Set(filename_v);
}",67,,448,2,,void
83193,BLOCK,-1,,"{
    DiagnosticFilename name(env, ""Heap"", ""heapsnapshot"");
    if (WriteSnapshot(env, *name, options).IsNothing()) return;
    if (String::NewFromUtf8(isolate, *name).ToLocal(&filename_v)) {
      args.GetReturnValue().Set(filename_v);
    }
    return;
  }",34,,455,2,,void
83208,BLOCK,-1,,<empty>,57,,457,2,,void
83223,BLOCK,-1,,"{
      args.GetReturnValue().Set(filename_v);
    }",67,,458,2,,void
83249,BLOCK,-1,,<empty>,55,,466,2,,void
83267,BLOCK,-1,,"{
  SetMethod(context, target, ""buildEmbedderGraph"", BuildEmbedderGraph);
  SetMethod(context, target, ""triggerHeapSnapshot"", TriggerHeapSnapshot);
  SetMethod(
      context, target, ""createHeapSnapshotStream"", CreateHeapSnapshotStream);
}",29,,473,5,,void
83287,BLOCK,-1,,"{
  registry->Register(BuildEmbedderGraph);
  registry->Register(TriggerHeapSnapshot);
  registry->Register(CreateHeapSnapshotStream);
}",70,,480,2,,void
83316,BLOCK,-1,,<empty>,1,,1,1,,ANY
83321,BLOCK,-1,,"{
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          Number::New(env->isolate(), static_cast<double>(value))));
  }",67,,163,3,,void
83359,BLOCK,-1,,"{
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          BigInt::New(env->isolate(), value)));
  }",67,,178,3,,void
83394,BLOCK,-1,,"{
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          Number::New(env->isolate(), static_cast<double>(value))));
  }",67,,603,3,,void
83431,BLOCK,-1,,"{
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          BigInt::New(env->isolate(), value)));
  }",67,,618,3,,void
83477,BLOCK,-1,,<empty>,1,,1,1,,ANY
83481,BLOCK,-1,,"{
  hdr_histogram* histogram;
  CHECK_EQ(0, hdr_init(options.lowest,
                       options.highest,
                       options.figures,
                       &histogram));
  histogram_.reset(histogram);
}",46,,24,2,,void
83506,BLOCK,-1,,"{
  tracker->TrackFieldWithSize(""histogram"", GetMemorySize());
}",58,,33,2,,void
83517,BLOCK,-1,,<empty>,42,,38,2,,void
83522,BLOCK,-1,,<empty>,40,,41,2,,void
83529,BLOCK,-1,,"{
  MakeWeak();
}",30,,48,4,,void
83537,BLOCK,-1,,"{
  MakeWeak();
}",43,,57,4,,void
83543,BLOCK,-1,,"{
  tracker->TrackField(""histogram"", histogram());
}",62,,61,2,,void
83554,BLOCK,-1,,"{
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Count());
  args.GetReturnValue().Set(value);
}",79,,65,2,,void
83585,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(
      BigInt::NewFromUnsigned(env->isolate(), (*histogram)->Count()));
}",54,,73,2,,void
83626,BLOCK,-1,,"{
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Min());
  args.GetReturnValue().Set(value);
}",69,,81,2,,void
83657,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(BigInt::New(env->isolate(), (*histogram)->Min()));
}",75,,88,2,,void
83698,BLOCK,-1,,"{
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Max());
  args.GetReturnValue().Set(value);
}",69,,95,2,,void
83729,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(
      BigInt::New(env->isolate(), (*histogram)->Max()));
}",75,,102,2,,void
83770,BLOCK,-1,,"{
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set((*histogram)->Mean());
}",70,,110,2,,void
83795,BLOCK,-1,,"{
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Exceeds());
  args.GetReturnValue().Set(value);
}",73,,116,2,,void
83826,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(
      BigInt::NewFromUnsigned(env->isolate(), (*histogram)->Exceeds()));
}",79,,123,2,,void
83867,BLOCK,-1,,"{
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set((*histogram)->Stddev());
}",72,,131,2,,void
83892,BLOCK,-1,,"{
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsNumber());
  double percentile = args[0].As<Number>()->Value();
  double value = static_cast<double>((*histogram)->Percentile(percentile));
  args.GetReturnValue().Set(value);
}",76,,137,2,,void
83943,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsNumber());
  double percentile = args[0].As<Number>()->Value();
  int64_t value = (*histogram)->Percentile(percentile);
  args.GetReturnValue().Set(BigInt::New(env->isolate(), value));
}",46,,147,2,,void
84008,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsMap());
  Local<Map> map = args[0].As<Map>();
  (*histogram)->Percentiles([map, env](double key, int64_t value) {
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          Number::New(env->isolate(), static_cast<double>(value))));
  });
}",77,,157,2,,void
84053,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsMap());
  Local<Map> map = args[0].As<Map>();
  (*histogram)->Percentiles([map, env](double key, int64_t value) {
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          BigInt::New(env->isolate(), value)));
  });
}",46,,172,2,,void
84098,BLOCK,-1,,"{
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  (*histogram)->Reset();
}",70,,186,2,,void
84116,BLOCK,-1,,"{
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  (*histogram)->RecordDelta();
}",74,,192,2,,void
84134,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK_IMPLIES(!args[0]->IsNumber(), args[0]->IsBigInt());
  bool lossless = true;
  int64_t value = args[0]->IsBigInt()
      ? args[0].As<BigInt>()->Int64Value(&lossless)
      : static_cast<int64_t>(args[0].As<Number>()->Value());
  if (!lossless || value < 1)
    return THROW_ERR_OUT_OF_RANGE(env, ""value is out of range"");
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  (*histogram)->Record(value);
}",69,,198,2,,void
84200,BLOCK,-1,,<empty>,5,,206,2,,void
84223,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());

  CHECK(GetConstructorTemplate(env->isolate_data())->HasInstance(args[0]));
  HistogramBase* other;
  ASSIGN_OR_RETURN_UNWRAP(&other, args[0]);

  double count = (*histogram)->Add(*(other->histogram()));
  args.GetReturnValue().Set(count);
}",66,,212,2,,void
84285,BLOCK,-1,,"{
  Local<Object> obj;
  if (!GetConstructorTemplate(env->isolate_data())
           ->InstanceTemplate()
           ->NewInstance(env->context())
           .ToLocal(&obj)) {
    return BaseObjectPtr<HistogramBase>();
  }

  return MakeBaseObject<HistogramBase>(env, obj, options);
}",40,,227,3,,void
84313,BLOCK,-1,,"{
    return BaseObjectPtr<HistogramBase>();
  }",28,,232,2,,void
84331,BLOCK,-1,,"{
  Local<Object> obj;
  if (!GetConstructorTemplate(env->isolate_data())
           ->InstanceTemplate()
           ->NewInstance(env->context())
           .ToLocal(&obj)) {
    return BaseObjectPtr<HistogramBase>();
  }
  return MakeBaseObject<HistogramBase>(env, obj, std::move(histogram));
}",43,,241,3,,void
84359,BLOCK,-1,,"{
    return BaseObjectPtr<HistogramBase>();
  }",28,,246,2,,void
84380,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);

  CHECK_IMPLIES(!args[0]->IsNumber(), args[0]->IsBigInt());
  CHECK_IMPLIES(!args[1]->IsNumber(), args[1]->IsBigInt());
  CHECK(args[2]->IsUint32());

  int64_t lowest = 1;
  int64_t highest = std::numeric_limits<int64_t>::max();

  bool lossless_ignored;

  if (args[0]->IsNumber()) {
    lowest = args[0].As<Integer>()->Value();
  } else if (args[0]->IsBigInt()) {
    lowest = args[0].As<BigInt>()->Int64Value(&lossless_ignored);
  }

  if (args[1]->IsNumber()) {
    highest = args[1].As<Integer>()->Value();
  } else if (args[1]->IsBigInt()) {
    highest = args[1].As<BigInt>()->Int64Value(&lossless_ignored);
  }

  int32_t figures = args[2].As<Uint32>()->Value();
  new HistogramBase(env, args.This(), Histogram::Options {
    lowest, highest, figures
  });
}",66,,252,2,,void
84454,BLOCK,-1,,"{
    lowest = args[0].As<Integer>()->Value();
  }",28,,265,2,,void
84467,BLOCK,-1,,<empty>,10,,267,1,,void
84475,BLOCK,-1,,"{
    lowest = args[0].As<BigInt>()->Int64Value(&lossless_ignored);
  }",35,,267,2,,void
84496,BLOCK,-1,,"{
    highest = args[1].As<Integer>()->Value();
  }",28,,271,2,,void
84509,BLOCK,-1,,<empty>,10,,273,1,,void
84517,BLOCK,-1,,"{
    highest = args[1].As<BigInt>()->Int64Value(&lossless_ignored);
  }",35,,273,2,,void
84559,BLOCK,-1,,"{
  Local<FunctionTemplate> tmpl = isolate_data->histogram_ctor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = isolate_data->isolate();
    tmpl = NewFunctionTemplate(isolate, New);
    Local<String> classname = FIXED_ONE_BYTE_STRING(isolate, ""Histogram"");
    tmpl->SetClassName(classname);

    tmpl->InstanceTemplate()->SetInternalFieldCount(
        HistogramBase::kInternalFieldCount);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""count"", GetCount);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""countBigInt"", GetCountBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""exceeds"", GetExceeds);
    SetProtoMethodNoSideEffect(
        isolate, tmpl, ""exceedsBigInt"", GetExceedsBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""min"", GetMin);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""minBigInt"", GetMinBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""max"", GetMax);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""maxBigInt"", GetMaxBigInt);
    SetProtoMetho...",32,,284,2,,void
84575,BLOCK,-1,,"{
    Isolate* isolate = isolate_data->isolate();
    tmpl = NewFunctionTemplate(isolate, New);
    Local<String> classname = FIXED_ONE_BYTE_STRING(isolate, ""Histogram"");
    tmpl->SetClassName(classname);

    tmpl->InstanceTemplate()->SetInternalFieldCount(
        HistogramBase::kInternalFieldCount);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""count"", GetCount);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""countBigInt"", GetCountBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""exceeds"", GetExceeds);
    SetProtoMethodNoSideEffect(
        isolate, tmpl, ""exceedsBigInt"", GetExceedsBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""min"", GetMin);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""minBigInt"", GetMinBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""max"", GetMax);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""maxBigInt"", GetMaxBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""mean"", GetMean);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""stdd...",23,,286,2,,void
84713,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(GetCount);
  registry->Register(GetCountBigInt);
  registry->Register(GetExceeds);
  registry->Register(GetExceedsBigInt);
  registry->Register(GetMin);
  registry->Register(GetMinBigInt);
  registry->Register(GetMax);
  registry->Register(GetMaxBigInt);
  registry->Register(GetMean);
  registry->Register(GetStddev);
  registry->Register(GetPercentile);
  registry->Register(GetPercentileBigInt);
  registry->Register(GetPercentiles);
  registry->Register(GetPercentilesBigInt);
  registry->Register(DoReset);
  registry->Register(Record);
  registry->Register(RecordDelta);
  registry->Register(Add);
}",42,,321,2,,void
84814,BLOCK,-1,,"{
  SetConstructorFunction(isolate_data->isolate(),
                         target,
                         ""Histogram"",
                         GetConstructorTemplate(isolate_data),
                         SetConstructorFunctionFlag::NONE);
}",62,,344,3,,void
84833,BLOCK,-1,,"{
  return Create(env, std::move(histogram_));
}",49,,355,4,,void
84845,BLOCK,-1,,"{
  return std::make_unique<HistogramTransferData>(this);
}",80,,359,1,,void
84858,BLOCK,-1,,"{
  tracker->TrackField(""histogram"", histogram_);
}",35,,364,2,,void
84869,BLOCK,-1,,"{
  Local<FunctionTemplate> tmpl = env->intervalhistogram_constructor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->Inherit(HandleWrap::GetConstructorTemplate(env));
    tmpl->SetClassName(OneByteString(isolate, ""Histogram""));
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        HistogramBase::kInternalFieldCount);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""count"", GetCount);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""countBigInt"", GetCountBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""exceeds"", GetExceeds);
    SetProtoMethodNoSideEffect(
        isolate, tmpl, ""exceedsBigInt"", GetExceedsBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""min"", GetMin);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""minBigInt"", GetMinBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""max"", GetMax);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""maxBigInt"", GetMaxBigInt);
    Se...",23,,369,2,,void
84885,BLOCK,-1,,"{
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->Inherit(HandleWrap::GetConstructorTemplate(env));
    tmpl->SetClassName(OneByteString(isolate, ""Histogram""));
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        HistogramBase::kInternalFieldCount);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""count"", GetCount);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""countBigInt"", GetCountBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""exceeds"", GetExceeds);
    SetProtoMethodNoSideEffect(
        isolate, tmpl, ""exceedsBigInt"", GetExceedsBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""min"", GetMin);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""minBigInt"", GetMinBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""max"", GetMax);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""maxBigInt"", GetMaxBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""mean"", GetMean);
    SetProtoMethodNoSideEffect(isolate, tmpl, ...",23,,371,2,,void
85020,BLOCK,-1,,"{
  registry->Register(GetCount);
  registry->Register(GetCountBigInt);
  registry->Register(GetExceeds);
  registry->Register(GetExceedsBigInt);
  registry->Register(GetMin);
  registry->Register(GetMinBigInt);
  registry->Register(GetMax);
  registry->Register(GetMaxBigInt);
  registry->Register(GetMean);
  registry->Register(GetStddev);
  registry->Register(GetPercentile);
  registry->Register(GetPercentileBigInt);
  registry->Register(GetPercentiles);
  registry->Register(GetPercentilesBigInt);
  registry->Register(DoReset);
  registry->Register(Start);
  registry->Register(Stop);
}",42,,404,2,,void
85115,BLOCK,-1,,"{
  MakeWeak();
  uv_timer_init(env->event_loop(), &timer_);
}",44,,438,7,,void
85131,BLOCK,-1,,"{
  Local<Object> obj;
  if (!GetConstructorTemplate(env)
          ->InstanceTemplate()
          ->NewInstance(env->context()).ToLocal(&obj)) {
    return BaseObjectPtr<IntervalHistogram>();
  }

  return MakeBaseObject<IntervalHistogram>(
      env,
      obj,
      AsyncWrap::PROVIDER_ELDHISTOGRAM,
      interval,
      std::move(on_interval),
      options);
}",40,,447,5,,void
85156,BLOCK,-1,,"{
    return BaseObjectPtr<IntervalHistogram>();
  }",56,,451,2,,void
85182,BLOCK,-1,,"{
  IntervalHistogram* histogram =
      ContainerOf(&IntervalHistogram::timer_, handle);

  Histogram* h = histogram->histogram().get();

  histogram->on_interval_(*h);
}",53,,464,2,,void
85212,BLOCK,-1,,"{
  tracker->TrackField(""histogram"", histogram());
}",66,,473,2,,void
85223,BLOCK,-1,,"{
  if (enabled_ || IsHandleClosing()) return;
  enabled_ = true;
  if (flags == StartFlags::RESET)
    histogram()->Reset();
  uv_timer_start(&timer_, TimerCB, interval_, interval_);
  uv_unref(reinterpret_cast<uv_handle_t*>(&timer_));
}",51,,477,2,,void
85228,BLOCK,-1,,<empty>,38,,478,2,,void
85239,BLOCK,-1,,<empty>,5,,481,2,,void
85258,BLOCK,-1,,"{
  if (!enabled_ || IsHandleClosing()) return;
  enabled_ = false;
  uv_timer_stop(&timer_);
}",34,,486,1,,void
85264,BLOCK,-1,,<empty>,39,,487,2,,void
85274,BLOCK,-1,,"{
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  histogram->OnStart(args[0]->IsTrue() ? StartFlags::RESET : StartFlags::NONE);
}",72,,492,2,,void
85304,BLOCK,-1,,"{
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  histogram->OnStop();
}",71,,498,2,,void
85321,BLOCK,-1,,"{
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Count());
  args.GetReturnValue().Set(value);
}",75,,504,2,,void
85352,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(
      BigInt::NewFromUnsigned(env->isolate(), (*histogram)->Count()));
}",54,,512,2,,void
85393,BLOCK,-1,,"{
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Min());
  args.GetReturnValue().Set(value);
}",73,,520,2,,void
85424,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(BigInt::New(env->isolate(), (*histogram)->Min()));
}",79,,527,2,,void
85465,BLOCK,-1,,"{
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Max());
  args.GetReturnValue().Set(value);
}",73,,534,2,,void
85496,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(BigInt::New(env->isolate(), (*histogram)->Min()));
}",79,,541,2,,void
85537,BLOCK,-1,,"{
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set((*histogram)->Mean());
}",74,,548,2,,void
85562,BLOCK,-1,,"{
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Exceeds());
  args.GetReturnValue().Set(value);
}",77,,554,2,,void
85593,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(
      BigInt::New(env->isolate(), (*histogram)->Exceeds()));
}",46,,562,2,,void
85634,BLOCK,-1,,"{
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set((*histogram)->Stddev());
}",76,,570,2,,void
85659,BLOCK,-1,,"{
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsNumber());
  double percentile = args[0].As<Number>()->Value();
  double value = static_cast<double>((*histogram)->Percentile(percentile));
  args.GetReturnValue().Set(value);
}",80,,576,2,,void
85710,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsNumber());
  double percentile = args[0].As<Number>()->Value();
  int64_t value = (*histogram)->Percentile(percentile);
  args.GetReturnValue().Set(BigInt::New(env->isolate(), value));
}",46,,586,2,,void
85775,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsMap());
  Local<Map> map = args[0].As<Map>();
  (*histogram)->Percentiles([map, env](double key, int64_t value) {
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          Number::New(env->isolate(), static_cast<double>(value))));
  });
}",46,,597,2,,void
85820,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsMap());
  Local<Map> map = args[0].As<Map>();
  (*histogram)->Percentiles([map, env](double key, int64_t value) {
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          BigInt::New(env->isolate(), value)));
  });
}",46,,612,2,,void
85865,BLOCK,-1,,"{
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  (*histogram)->Reset();
}",74,,626,2,,void
85882,BLOCK,-1,,"{
  return std::make_unique<HistogramBase::HistogramTransferData>(histogram());
}",46,,633,1,,void
85921,BLOCK,-1,,<empty>,1,,1,1,,ANY
85925,BLOCK,-1,,"{
      delegate->SendMessageToFrontend(m->string());
    }",46,,188,2,,void
85940,BLOCK,-1,,"{
      if (auto iface = weak_self.lock()) iface->DispatchMessages();
    }",63,,214,2,,void
85942,BLOCK,-1,,<empty>,11,,215,1,,void
85950,BLOCK,-1,,<empty>,42,,215,2,,void
85974,BLOCK,-1,,<empty>,1,,1,1,,ANY
85981,BLOCK,-1,,<empty>,54,,21,2,,void
85985,BLOCK,-1,,<empty>,,,,1,,<empty>
85991,BLOCK,-1,,"{
    return
        static_cast<DeletableWrapper<T>*>(thread->GetObject(id))->object_.get();
  }",54,,24,3,,void
86010,BLOCK,-1,,"{
  return std::unique_ptr<DeletableWrapper<T>>(
      new DeletableWrapper<T>(std::move(object)));
}",71,,34,2,,void
86033,BLOCK,-1,,<empty>,77,,43,3,,void
86038,BLOCK,-1,,"{
    thread->AddObject(object_id_, WrapInDeletable(factory_(thread)));
  }",51,,45,2,,void
86054,BLOCK,-1,,"{
  return std::unique_ptr<Request>(
      new CreateObjectRequest<Factory>(object_id, std::move(factory)));
}",75,,55,3,,void
86075,BLOCK,-1,,<empty>,65,,62,2,,void
86080,BLOCK,-1,,"{
    thread->RemoveObject(object_id_);
  }",51,,64,2,,void
86093,BLOCK,-1,,<empty>,60,,75,3,,void
86098,BLOCK,-1,,"{
    fn_(DeletableWrapper<Target>::get(thread, id_));
  }",51,,77,2,,void
86114,BLOCK,-1,,<empty>,48,,91,3,,void
86120,BLOCK,-1,,"{
    thread_->Post(NewCreateRequest(object_id_, std::move(factory)));
  }",69,,96,3,,void
86136,BLOCK,-1,,<empty>,,,,2,,<empty>
86140,BLOCK,-1,,"{
    // Disappearing thread may cause a memory leak
    thread_->Post(std::make_unique<DeleteRequest>(object_id_));
  }",35,,101,1,,void
86156,BLOCK,-1,,"{
    using Request = CallRequest<T, Fn>;
    thread_->Post(std::unique_ptr<Request>(
        new Request(object_id_, std::move(fn))));
  }",26,,107,2,,void
86181,BLOCK,-1,,"{
    Call(std::bind(Apply<Arg>, std::placeholders::_1, fn, std::move(argument)));
  }",53,,114,3,,void
86205,BLOCK,-1,,"{
    (target->*fn)(std::move(argument));
  }",59,,123,4,,void
86223,BLOCK,-1,,<empty>,64,,135,3,,void
86229,BLOCK,-1,,"{
    return std::make_unique<MainThreadSessionState>(thread, prevent_shutdown);
  }",59,,138,3,,void
86245,BLOCK,-1,,"{
    Agent* agent = thread_->inspector_agent();
    if (agent != nullptr)
      session_ = agent->Connect(std::move(delegate), prevent_shutdown_);
  }",68,,142,2,,void
86257,BLOCK,-1,,<empty>,7,,145,2,,void
86274,BLOCK,-1,,"{
    session_->Dispatch(message->string());
  }",56,,148,2,,void
86294,BLOCK,-1,,"{
    state_.Call(&MainThreadSessionState::Connect, std::move(delegate));
  }",53,,167,5,,void
86312,BLOCK,-1,,"{
    state_.Call(&MainThreadSessionState::Dispatch,
                StringBuffer::create(message));
  }",53,,171,2,,void
86332,BLOCK,-1,,<empty>,70,,183,3,,void
86337,BLOCK,-1,,"{
    delegate_.Call(
        [m = StringBuffer::create(message)]
        (InspectorSessionDelegate* delegate) {
      delegate->SendMessageToFrontend(m->string());
    });
  }",80,,185,2,,void
86349,BLOCK,-1,,<empty>,72,,200,2,,void
86353,BLOCK,-1,,"{
  if (handle_)
    handle_->Reset();
}",45,,202,1,,void
86356,BLOCK,-1,,<empty>,5,,204,2,,void
86365,BLOCK,-1,,"{
  CHECK_NOT_NULL(agent_);
  Mutex::ScopedLock scoped_lock(requests_lock_);
  bool needs_notify = requests_.empty();
  requests_.push_back(std::move(request));
  if (needs_notify) {
    std::weak_ptr<MainThreadInterface> weak_self {shared_from_this()};
    agent_->env()->RequestInterrupt([weak_self](Environment*) {
      if (auto iface = weak_self.lock()) iface->DispatchMessages();
    });
  }
  incoming_message_cond_.Broadcast(scoped_lock);
}",66,,207,2,,void
86389,BLOCK,-1,,"{
    std::weak_ptr<MainThreadInterface> weak_self {shared_from_this()};
    agent_->env()->RequestInterrupt([weak_self](Environment*) {
      if (auto iface = weak_self.lock()) iface->DispatchMessages();
    });
  }",21,,212,2,,void
86410,BLOCK,-1,,"{
  // We allow DispatchMessages reentry as we enter the pause. This is important
  // to support debugging the code invoked by an inspector call, such
  // as Runtime.evaluate
  dispatching_messages_ = false;
  if (dispatching_message_queue_.empty()) {
    Mutex::ScopedLock scoped_lock(requests_lock_);
    while (requests_.empty()) incoming_message_cond_.Wait(scoped_lock);
  }
  return true;
}",50,,221,1,,void
86419,BLOCK,-1,,"{
    Mutex::ScopedLock scoped_lock(requests_lock_);
    while (requests_.empty()) incoming_message_cond_.Wait(scoped_lock);
  }",43,,226,2,,void
86438,BLOCK,-1,,"{
  if (dispatching_messages_)
    return;
  dispatching_messages_ = true;
  bool had_messages = false;
  do {
    if (dispatching_message_queue_.empty()) {
      Mutex::ScopedLock scoped_lock(requests_lock_);
      requests_.swap(dispatching_message_queue_);
    }
    had_messages = !dispatching_message_queue_.empty();
    while (!dispatching_message_queue_.empty()) {
      MessageQueue::value_type task;
      std::swap(dispatching_message_queue_.front(), task);
      dispatching_message_queue_.pop_front();

      v8::SealHandleScope seal_handle_scope(agent_->env()->isolate());
      task->Call(this);
    }
  } while (had_messages);
  dispatching_messages_ = false;
}",46,,233,1,,void
86441,BLOCK,-1,,<empty>,5,,235,2,,void
86451,BLOCK,-1,,"{
    if (dispatching_message_queue_.empty()) {
      Mutex::ScopedLock scoped_lock(requests_lock_);
      requests_.swap(dispatching_message_queue_);
    }
    had_messages = !dispatching_message_queue_.empty();
    while (!dispatching_message_queue_.empty()) {
      MessageQueue::value_type task;
      std::swap(dispatching_message_queue_.front(), task);
      dispatching_message_queue_.pop_front();

      v8::SealHandleScope seal_handle_scope(agent_->env()->isolate());
      task->Call(this);
    }
  }",6,,238,1,,void
86457,BLOCK,-1,,"{
      Mutex::ScopedLock scoped_lock(requests_lock_);
      requests_.swap(dispatching_message_queue_);
    }",45,,239,2,,void
86479,BLOCK,-1,,"{
      MessageQueue::value_type task;
      std::swap(dispatching_message_queue_.front(), task);
      dispatching_message_queue_.pop_front();

      v8::SealHandleScope seal_handle_scope(agent_->env()->isolate());
      task->Call(this);
    }",49,,244,2,,void
86515,BLOCK,-1,,"{
  if (handle_ == nullptr)
    handle_ = std::make_shared<MainThreadHandle>(this);
  return handle_;
}",68,,256,1,,void
86520,BLOCK,-1,,<empty>,5,,258,2,,void
86537,BLOCK,-1,,"{
  CHECK_NOT_NULL(object);
  managed_objects_[id] = std::move(object);
}",72,,263,3,,void
86553,BLOCK,-1,,"{
  CHECK_EQ(1, managed_objects_.erase(id));
}",48,,268,2,,void
86565,BLOCK,-1,,"{
  Deletable* pointer = GetObjectIfExists(id);
  // This would mean the object is requested after it was disposed, which is
  // a coding error.
  CHECK_NOT_NULL(pointer);
  return pointer;
}",51,,272,2,,void
86579,BLOCK,-1,,"{
  auto iterator = managed_objects_.find(id);
  if (iterator == managed_objects_.end()) {
    return nullptr;
  }
  return iterator->second.get();
}",59,,280,2,,void
86595,BLOCK,-1,,"{
    return nullptr;
  }",43,,282,2,,void
86609,BLOCK,-1,,"{
  size_t expected_u16_length =
      simdutf::utf16_length_from_utf8(message.data(), message.length());
  MaybeStackBuffer<char16_t> buffer(expected_u16_length);
  size_t utf16_length = simdutf::convert_utf8_to_utf16(
      message.data(), message.length(), buffer.out());
  StringView view(reinterpret_cast<uint16_t*>(buffer.out()), utf16_length);
  return StringBuffer::create(view);
}",80,,288,2,,void
86667,BLOCK,-1,,"{
  return std::unique_ptr<InspectorSession>(
      new CrossThreadInspectorSession(++next_session_id_,
                                      shared_from_this(),
                                      std::move(delegate),
                                      prevent_shutdown));
}",28,,300,3,,void
86690,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(block_lock_);
  if (!main_thread_)
    return false;
  main_thread_->Post(std::move(request));
  return true;
}",63,,308,2,,void
86697,BLOCK,-1,,<empty>,5,,311,2,,void
86714,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(block_lock_);
  main_thread_ = nullptr;
}",32,,316,1,,void
86725,BLOCK,-1,,"{
  int id = newObjectId();
  main_thread_->AddObject(id, WrapInDeletable(std::move(delegate)));
  return std::unique_ptr<InspectorSessionDelegate>(
      new ThreadSafeDelegate(shared_from_this(), id));
}",57,,323,2,,void
86755,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(block_lock_);
  return main_thread_ == nullptr;
}",34,,330,1,,void
86781,BLOCK,-1,,<empty>,1,,1,1,,ANY
86791,BLOCK,-1,,<empty>,,,,2,,<empty>
86795,BLOCK,-1,,<empty>,,,,1,,<empty>
86800,BLOCK,-1,,<empty>,,,,1,,<empty>
86805,BLOCK,-1,,<empty>,,,,2,,<empty>
86812,BLOCK,-1,,"{
  }",57,,44,2,,void
86816,BLOCK,-1,,"{
    Mutex::ScopedLock scoped_lock(block_lock_);
    CHECK_NULL(main_thread_);  // main_thread_ should have called Reset
  }",23,,46,1,,void
86827,BLOCK,-1,,<empty>,,,,3,,<empty>
86831,BLOCK,-1,,"{
    return ++next_object_id_;
  }",21,,53,1,,void
86839,BLOCK,-1,,<empty>,,,,2,,<empty>
86844,BLOCK,-1,,<empty>,,,,2,,<empty>
86848,BLOCK,-1,,<empty>,,,,1,,<empty>
86852,BLOCK,-1,,<empty>,,,,1,,<empty>
86861,BLOCK,-1,,<empty>,,,,1,,<empty>
86874,BLOCK,-1,,<empty>,,,,2,,<empty>
86878,BLOCK,-1,,<empty>,,,,1,,<empty>
86882,BLOCK,-1,,<empty>,,,,1,,<empty>
86887,BLOCK,-1,,<empty>,,,,2,,<empty>
86891,BLOCK,-1,,<empty>,,,,1,,<empty>
86895,BLOCK,-1,,<empty>,,,,1,,<empty>
86899,BLOCK,-1,,"{
    return agent_;
  }",28,,82,1,,void
86907,BLOCK,-1,,<empty>,,,,3,,<empty>
86912,BLOCK,-1,,<empty>,,,,2,,<empty>
86917,BLOCK,-1,,<empty>,,,,2,,<empty>
86922,BLOCK,-1,,<empty>,,,,2,,<empty>
86934,BLOCK,-1,,<empty>,,,,1,,<empty>
86954,BLOCK,-1,,<empty>,1,,1,1,,ANY
86970,BLOCK,-1,,"{
  builder.put('""');
  if (!string.empty()) {
    size_t expected_utf16_length =
        simdutf::utf16_length_from_utf8(string.data(), string.length());
    MaybeStackBuffer<char16_t> buffer(expected_utf16_length);
    // simdutf::convert_utf8_to_utf16 returns zero in case of error.
    size_t utf16_length = simdutf::convert_utf8_to_utf16(
        string.data(), string.length(), buffer.out());
    // We have that utf16_length == expected_utf16_length if and only
    // if the input was a valid UTF-8 string.
    if (utf16_length != 0) {
      CHECK_EQ(expected_utf16_length, utf16_length);
      escapeWideStringForJSON(reinterpret_cast<const uint16_t*>(buffer.out()),
                              utf16_length,
                              &builder);
    }  // Otherwise, we had an invalid UTF-8 input.
  }
  builder.put('""');
}",63,,16,3,,void
86982,BLOCK,-1,,"{
    size_t expected_utf16_length =
        simdutf::utf16_length_from_utf8(string.data(), string.length());
    MaybeStackBuffer<char16_t> buffer(expected_utf16_length);
    // simdutf::convert_utf8_to_utf16 returns zero in case of error.
    size_t utf16_length = simdutf::convert_utf8_to_utf16(
        string.data(), string.length(), buffer.out());
    // We have that utf16_length == expected_utf16_length if and only
    // if the input was a valid UTF-8 string.
    if (utf16_length != 0) {
      CHECK_EQ(expected_utf16_length, utf16_length);
      escapeWideStringForJSON(reinterpret_cast<const uint16_t*>(buffer.out()),
                              utf16_length,
                              &builder);
    }  // Otherwise, we had an invalid UTF-8 input.
  }",24,,18,2,,void
87024,BLOCK,-1,,"{
      CHECK_EQ(expected_utf16_length, utf16_length);
      escapeWideStringForJSON(reinterpret_cast<const uint16_t*>(buffer.out()),
                              utf16_length,
                              &builder);
    }",28,,27,2,,void
87047,BLOCK,-1,,"{
  if (string.empty())
    return nullptr;
  size_t expected_utf16_length =
      simdutf::utf16_length_from_utf8(string.data(), string.length());
  MaybeStackBuffer<char16_t> buffer(expected_utf16_length);
  // simdutf::convert_utf8_to_utf16 returns zero in case of error.
  size_t utf16_length = simdutf::convert_utf8_to_utf16(
      string.data(), string.length(), buffer.out());
  // We have that utf16_length == expected_utf16_length if and only
  // if the input was a valid UTF-8 string.
  if (utf16_length == 0) return nullptr;  // We had an invalid UTF-8 input.
  CHECK_EQ(expected_utf16_length, utf16_length);
  return parseJSONCharacters(reinterpret_cast<const uint16_t*>(buffer.out()),
                             utf16_length);
}",65,,37,2,,void
87053,BLOCK,-1,,<empty>,5,,39,2,,void
87097,BLOCK,-1,,<empty>,26,,48,2,,void
87116,BLOCK,-1,,"{
  if (string.length() == 0)
    return nullptr;
  if (string.is8Bit())
    return parseJSONCharacters(string.characters8(), string.length());
  return parseJSONCharacters(string.characters16(), string.length());
}",67,,54,2,,void
87124,BLOCK,-1,,<empty>,5,,56,2,,void
87132,BLOCK,-1,,<empty>,5,,58,2,,void
87157,BLOCK,-1,,"{
  if (view.length() == 0)
    return """";
  if (view.is8Bit()) {
    return std::string(reinterpret_cast<const char*>(view.characters8()),
                       view.length());
  }
  const char16_t* source =
      reinterpret_cast<const char16_t*>(view.characters16());
  size_t expected_utf8_length =
      simdutf::utf8_length_from_utf16(source, view.length());
  MaybeStackBuffer<char> buffer(expected_utf8_length);
  // convert_utf16_to_utf8 returns zero in case of error.
  size_t utf8_length =
      simdutf::convert_utf16_to_utf8(source, view.length(), buffer.out());
  // We have that utf8_length == expected_utf8_length if and only
  // if the input was a valid UTF-16 string. Otherwise, utf8_length
  // must be zero.
  CHECK(utf8_length == 0 || utf8_length == expected_utf8_length);
  // An invalid UTF-16 input will generate the empty string:
  return String(buffer.out(), utf8_length);
}",56,,62,2,,void
87165,BLOCK,-1,,<empty>,5,,64,2,,void
87173,BLOCK,-1,,"{
    return std::string(reinterpret_cast<const char*>(view.characters8()),
                       view.length());
  }",22,,65,2,,void
87248,BLOCK,-1,,"{
  std::ostringstream stream;
  stream.imbue(std::locale::classic());  // Ignore current locale
  stream << d;
  return stream.str();
}",29,,85,2,,void
87274,BLOCK,-1,,"{
  std::istringstream stream(std::string(buffer, length));
  stream.imbue(std::locale::classic());  // Ignore current locale
  double d;
  stream >> d;
  *ok = !stream.fail();
  return d;
}",62,,92,4,,void
87312,BLOCK,-1,,"{
  if (binary) {
    return Value::parseBinary(
        reinterpret_cast<const uint8_t*>(message.data()),
        message.length());
  }
  return parseJSON(message);
}",50,,102,3,,void
87315,BLOCK,-1,,"{
    return Value::parseBinary(
        reinterpret_cast<const uint8_t*>(message.data()),
        message.length());
  }",15,,103,2,,void
87338,BLOCK,-1,,"{
  return message;
}",47,,111,2,,void
87345,BLOCK,-1,,"{
  return std::string(reinterpret_cast<const char*>(message.data()),
                     message.size());
}",63,,115,2,,void
87366,BLOCK,-1,,"{
  return std::string(reinterpret_cast<const char*>(data), length);
}",53,,120,3,,void
87381,BLOCK,-1,,"{
  auto casted_data = reinterpret_cast<const char16_t*>(data);
  size_t expected_utf8_length =
      simdutf::utf8_length_from_utf16(casted_data, length);
  MaybeStackBuffer<char> buffer(expected_utf8_length);
  // simdutf::convert_utf16_to_utf8 returns zero in case of error.
  size_t utf8_length =
      simdutf::convert_utf16_to_utf8(casted_data, length, buffer.out());
  // We have that utf8_length == expected_utf8_length if and only
  // if the input was a valid UTF-16 string. Otherwise, utf8_length
  // must be zero.
  CHECK(utf8_length == 0 || utf8_length == expected_utf8_length);
  // An invalid UTF-16 input will generate the empty string:
  return String(buffer.out(), utf8_length);
}",55,,124,3,,void
87432,BLOCK,-1,,"{
  return reinterpret_cast<const uint8_t*>(s.data());
}",57,,140,2,,void
87444,BLOCK,-1,,"{
  // The utf32_length_from_utf8 function calls count_utf8.
  // The count_utf8 function counts the number of code points
  // (characters) in the string, assuming that the string is valid Unicode.
  // TODO(@anonrig): Test to make sure CharacterCount returns correctly.
  return simdutf::utf32_length_from_utf8(s.data(), s.length());
}",49,,144,2,,void
87474,BLOCK,-1,,<empty>,1,,1,1,,ANY
87486,BLOCK,-1,,"{
  builder.put(c);
}",59,,25,3,,void
87498,BLOCK,-1,,"{
  builder.write(value, length);
}",42,,31,4,,void
87510,BLOCK,-1,,"{
  builderAppend(builder, value, std::strlen(value));
}",70,,36,3,,void
87524,BLOCK,-1,,"{
  builder << string;
}",73,,41,3,,void
87533,BLOCK,-1,,"{
  // ostringstream does not have a counterpart
}",60,,46,3,,void
87540,BLOCK,-1,,"{
  return string.substr(start, count);
}",75,,49,4,,void
87552,BLOCK,-1,,"{
  return std::to_string(n);
}",34,,52,2,,void
87563,BLOCK,-1,,"{
  return builder.str();
}",61,,55,2,,void
87574,BLOCK,-1,,"{
  return string.find(substring);
}",65,,58,3,,void
87585,BLOCK,-1,,<empty>,,,,2,,<empty>
87592,BLOCK,-1,,<empty>,,,,4,,<empty>
87597,BLOCK,-1,,<empty>,,,,2,,<empty>
87603,BLOCK,-1,,<empty>,,,,3,,<empty>
87608,BLOCK,-1,,<empty>,,,,2,,<empty>
87614,BLOCK,-1,,<empty>,,,,3,,<empty>
87619,BLOCK,-1,,<empty>,,,,2,,<empty>
87624,BLOCK,-1,,<empty>,,,,2,,<empty>
87630,BLOCK,-1,,<empty>,,,,3,,<empty>
87636,BLOCK,-1,,<empty>,,,,3,,<empty>
87641,BLOCK,-1,,<empty>,,,,2,,<empty>
87646,BLOCK,-1,,<empty>,,,,2,,<empty>
87651,BLOCK,-1,,"{
  return nullptr;
}",60,,81,2,,void
87658,BLOCK,-1,,"{
  return nullptr;
}",66,,84,2,,void
87666,BLOCK,-1,,{ UNREACHABLE(); },31,,97,1,,void
87671,BLOCK,-1,,{ UNREACHABLE(); },23,,98,1,,void
87676,BLOCK,-1,,{ UNREACHABLE(); },27,,99,1,,void
87683,BLOCK,-1,,"{
    UNREACHABLE();
  }",74,,100,3,,void
87690,BLOCK,-1,,{ UNREACHABLE(); },60,,103,3,,void
87704,BLOCK,-1,,<empty>,1,,1,1,,ANY
87709,BLOCK,-1,,<empty>,48,,11,1,,void
87714,BLOCK,-1,,"{
  frontend_ = std::make_unique<NodeRuntime::Frontend>(dispatcher->channel());
  NodeRuntime::Dispatcher::wire(dispatcher, this);
}",53,,13,2,,void
87741,BLOCK,-1,,"{
  notify_when_waiting_for_disconnect_ = enabled;
  return DispatchResponse::OK();
}",77,,18,2,,void
87753,BLOCK,-1,,"{
  if (notify_when_waiting_for_disconnect_) {
    frontend_->waitingForDisconnect();
    return true;
  }
  return false;
}",49,,23,1,,void
87756,BLOCK,-1,,"{
    frontend_->waitingForDisconnect();
    return true;
  }",44,,24,2,,void
87775,BLOCK,-1,,<empty>,1,,1,1,,ANY
87782,BLOCK,-1,,<empty>,,,,1,,<empty>
87787,BLOCK,-1,,<empty>,,,,2,,<empty>
87792,BLOCK,-1,,<empty>,,,,2,,<empty>
87796,BLOCK,-1,,<empty>,,,,1,,<empty>
87819,BLOCK,-1,,<empty>,1,,1,1,,ANY
87827,BLOCK,-1,,<empty>,29,,21,2,,void
87831,BLOCK,-1,,{ return frontend_.lock().get(); },32,,25,1,,void
87847,BLOCK,-1,,"{
    frontend_wrapper_ = std::make_unique<DeletableFrontendWrapper>(frontend);
  }",31,,35,3,,void
87861,BLOCK,-1,,"{
    thread->AddObject(object_id_, std::move(frontend_wrapper_));
  }",51,,39,2,,void
87879,BLOCK,-1,,<empty>,31,,51,2,,void
87884,BLOCK,-1,,"{
    thread->RemoveObject(object_id_);
  }",51,,53,2,,void
87897,BLOCK,-1,,<empty>,50,,64,3,,void
87902,BLOCK,-1,,"{
    DeletableFrontendWrapper* frontend_wrapper =
        static_cast<DeletableFrontendWrapper*>(
            thread->GetObjectIfExists(object_id_));
    if (frontend_wrapper == nullptr) return;
    auto frontend = frontend_wrapper->get();
    if (frontend != nullptr) {
      frontend->sendRawJSONNotification(message_);
    }
  }",51,,66,2,,void
87917,BLOCK,-1,,<empty>,38,,70,2,,void
87930,BLOCK,-1,,"{
      frontend->sendRawJSONNotification(message_);
    }",30,,72,2,,void
87944,BLOCK,-1,,<empty>,76,,86,3,,void
87949,BLOCK,-1,,"{
    if (!json_writer_)
      json_writer_.reset(TraceWriter::CreateJSONTraceWriter(stream_, ""value""));
    json_writer_->AppendTraceEvent(trace_event);
  }",65,,89,2,,void
87953,BLOCK,-1,,<empty>,7,,91,2,,void
87973,BLOCK,-1,,"{
    if (!json_writer_)
      return;
    json_writer_.reset();
    std::ostringstream result(
        ""{\""method\"":\""NodeTracing.dataCollected\"",\""params\"":"",
        std::ostringstream::ate);
    result << stream_.str();
    result << ""}"";
    main_thread_->Post(std::make_unique<SendMessageRequest>(frontend_object_id_,
                                                            result.str()));
    stream_.str("""");
  }",29,,95,2,,void
87977,BLOCK,-1,,<empty>,7,,97,2,,void
88031,BLOCK,-1,,<empty>,44,,119,3,,void
88035,BLOCK,-1,,"{
  trace_writer_.reset();
  main_thread_->Post(
      std::make_unique<DestroyFrontendWrapperRequest>(frontend_object_id_));
}",31,,121,1,,void
88055,BLOCK,-1,,"{
  // Note that frontend is still owned by TracingAgent
  frontend_ = std::make_shared<NodeTracing::Frontend>(dispatcher->channel());
  frontend_object_id_ = main_thread_->newObjectId();
  main_thread_->Post(std::make_unique<CreateFrontendWrapperRequest>(
      frontend_object_id_, frontend_));
  NodeTracing::Dispatcher::wire(dispatcher, this);
}",53,,127,2,,void
88102,BLOCK,-1,,"{
  if (!trace_writer_.empty()) {
    return DispatchResponse::Error(
        ""Call NodeTracing::end to stop tracing before updating the config"");
  }
  if (!env_->owns_process_state()) {
    return DispatchResponse::Error(
        ""Tracing properties can only be changed through main thread sessions"");
  }

  std::set<std::string> categories_set;
  protocol::Array<std::string>* categories =
      traceConfig->getIncludedCategories();
  for (size_t i = 0; i < categories->length(); i++)
    categories_set.insert(categories->get(i));

  if (categories_set.empty())
    return DispatchResponse::Error(""At least one category should be enabled"");

  tracing::AgentWriterHandle* writer = GetTracingAgentWriter();
  if (writer != nullptr) {
    trace_writer_ =
        writer->agent()->AddClient(categories_set,
                                   std::make_unique<InspectorTraceWriter>(
                                       frontend_object_id_, main_thread_),
                                   tr...",70,,137,2,,void
88109,BLOCK,-1,,"{
    return DispatchResponse::Error(
        ""Call NodeTracing::end to stop tracing before updating the config"");
  }",31,,138,2,,void
88122,BLOCK,-1,,"{
    return DispatchResponse::Error(
        ""Tracing properties can only be changed through main thread sessions"");
  }",36,,142,2,,void
88154,BLOCK,-1,,<empty>,3,,150,1,,void
88181,BLOCK,-1,,<empty>,5,,154,2,,void
88196,BLOCK,-1,,"{
    trace_writer_ =
        writer->agent()->AddClient(categories_set,
                                   std::make_unique<InspectorTraceWriter>(
                                       frontend_object_id_, main_thread_),
                                   tracing::Agent::kIgnoreDefaultCategories);
  }",26,,157,2,,void
88230,BLOCK,-1,,"{
  trace_writer_.reset();
  frontend_->tracingComplete();
  return DispatchResponse::OK();
}",39,,167,1,,void
88248,BLOCK,-1,,"{
  *categories = Array<String>::create();
  protocol::Array<String>* categories_list = categories->get();
  // In alphabetical order
  categories_list->addItem(""node"");
  categories_list->addItem(""node.async_hooks"");
  categories_list->addItem(""node.bootstrap"");
  categories_list->addItem(""node.console"");
  categories_list->addItem(""node.dns.native"");
  categories_list->addItem(""node.environment"");
  categories_list->addItem(""node.fs.async"");
  categories_list->addItem(""node.fs.sync"");
  categories_list->addItem(""node.fs_dir.async"");
  categories_list->addItem(""node.fs_dir.sync"");
  categories_list->addItem(""node.http"");
  categories_list->addItem(""node.net.native"");
  categories_list->addItem(""node.perf"");
  categories_list->addItem(""node.perf.timerify"");
  categories_list->addItem(""node.perf.usertiming"");
  categories_list->addItem(""node.promises.rejections"");
  categories_list->addItem(""node.threadpoolwork.async"");
  categories_list->addItem(""node.threadpoolwork.sync"");
  catego...",59,,174,2,,void
88390,BLOCK,-1,,<empty>,1,,1,1,,ANY
88400,BLOCK,-1,,<empty>,,,,3,,<empty>
88404,BLOCK,-1,,<empty>,,,,1,,<empty>
88409,BLOCK,-1,,<empty>,,,,2,,<empty>
88414,BLOCK,-1,,<empty>,,,,2,,<empty>
88418,BLOCK,-1,,<empty>,,,,1,,<empty>
88423,BLOCK,-1,,<empty>,,,,2,,<empty>
88432,BLOCK,-1,,<empty>,,,,1,,<empty>
88450,BLOCK,-1,,<empty>,1,,1,1,,ANY
88458,BLOCK,-1,,<empty>,62,,16,3,,void
88466,BLOCK,-1,,<empty>,,,,5,,<empty>
88472,BLOCK,-1,,<empty>,,,,3,,<empty>
88478,BLOCK,-1,,<empty>,,,,3,,<empty>
88483,BLOCK,-1,,<empty>,,,,2,,<empty>
88491,BLOCK,-1,,<empty>,,,,1,,<empty>
88501,BLOCK,-1,,<empty>,61,,36,2,,void
88509,BLOCK,-1,,"{
    workers_->WorkerCreated(title, url, waiting, target);
  }",73,,41,5,,void
88525,BLOCK,-1,,<empty>,63,,53,3,,void
88529,BLOCK,-1,,"{
    workers_->Detached(id_);
  }",46,,55,1,,void
88539,BLOCK,-1,,"{
    std::string message = protocol::StringUtil::StringViewToUtf8(msg);
    workers_->Send(id_, message);
  }",76,,59,2,,void
88564,BLOCK,-1,,"{
  return NodeWorker::WorkerInfo::create()
      .setWorkerId(id)
      .setTitle(title)
      .setUrl(url)
      .setType(""worker"").build();
}",76,,71,4,,void
88595,BLOCK,-1,,<empty>,46,,81,2,,void
88600,BLOCK,-1,,"{
  frontend_.reset(new NodeWorker::Frontend(dispatcher->channel()));
  NodeWorker::Dispatcher::wire(dispatcher, this);
  auto manager = manager_.lock();
  CHECK_NOT_NULL(manager);
  workers_ =
      std::make_shared<NodeWorkers>(frontend_, manager->MainThread());
}",52,,84,2,,void
88648,BLOCK,-1,,"{
  workers_->Receive(sessionId, message);
  return DispatchResponse::OK();
}",76,,94,3,,void
88664,BLOCK,-1,,"{
  auto manager = manager_.lock();
  if (!manager) {
    return DispatchResponse::OK();
  }
  if (!event_handle_) {
    std::unique_ptr<AgentWorkerInspectorDelegate> delegate(
            new AgentWorkerInspectorDelegate(workers_));
    event_handle_ = manager->SetAutoAttach(std::move(delegate));
  }
  event_handle_->SetWaitOnStart(waitForDebuggerOnStart);
  return DispatchResponse::OK();
}",67,,99,2,,void
88675,BLOCK,-1,,"{
    return DispatchResponse::OK();
  }",17,,101,2,,void
88684,BLOCK,-1,,"{
    std::unique_ptr<AgentWorkerInspectorDelegate> delegate(
            new AgentWorkerInspectorDelegate(workers_));
    event_handle_ = manager->SetAutoAttach(std::move(delegate));
  }",23,,104,2,,void
88714,BLOCK,-1,,"{
  event_handle_.reset();
  return DispatchResponse::OK();
}",41,,113,1,,void
88728,BLOCK,-1,,"{
  workers_->Detached(sessionId);
  return DispatchResponse::OK();
}",63,,118,2,,void
88746,BLOCK,-1,,"{
  auto frontend = frontend_.lock();
  if (!frontend)
    return;
  std::string id = std::to_string(++next_target_id_);
  auto delegate = thread_->MakeDelegateThreadSafe(
      std::unique_ptr<InspectorSessionDelegate>(
          new ParentInspectorSessionDelegate(id, shared_from_this())));
  sessions_[id] = target->Connect(std::move(delegate), true);
  frontend->attachedToWorker(id, WorkerInfo(id, title, url), waiting);
}",75,,126,5,,void
88757,BLOCK,-1,,<empty>,5,,129,2,,void
88814,BLOCK,-1,,"{
  auto frontend = frontend_.lock();
  if (frontend)
    frontend->receivedMessageFromWorker(id, message);
}",75,,138,3,,void
88824,BLOCK,-1,,<empty>,5,,141,2,,void
88836,BLOCK,-1,,"{
  auto it = sessions_.find(id);
  if (it != sessions_.end())
    it->second->Dispatch(Utf8ToStringView(message)->string());
}",78,,144,3,,void
88852,BLOCK,-1,,<empty>,5,,147,2,,void
88868,BLOCK,-1,,"{
  if (sessions_.erase(id) == 0)
    return;
  auto frontend = frontend_.lock();
  if (frontend) {
    frontend->detachedFromWorker(id);
  }
}",51,,150,2,,void
88877,BLOCK,-1,,<empty>,5,,152,2,,void
88888,BLOCK,-1,,"{
    frontend->detachedFromWorker(id);
  }",17,,154,2,,void
88904,BLOCK,-1,,<empty>,1,,1,1,,ANY
88914,BLOCK,-1,,<empty>,,,,2,,<empty>
88918,BLOCK,-1,,<empty>,,,,1,,<empty>
88923,BLOCK,-1,,<empty>,,,,2,,<empty>
88929,BLOCK,-1,,<empty>,,,,3,,<empty>
88934,BLOCK,-1,,<empty>,,,,2,,<empty>
88938,BLOCK,-1,,<empty>,,,,1,,<empty>
88943,BLOCK,-1,,<empty>,,,,2,,<empty>
88962,BLOCK,-1,,<empty>,1,,1,1,,ANY
88973,BLOCK,-1,,<empty>,27,,21,6,,void
88978,BLOCK,-1,,"{
    auto manager = thread->inspector_agent()->GetWorkerManager();
    manager->WorkerStarted(id_, info_, waiting_);
  }",51,,22,2,,void
89001,BLOCK,-1,,"{
    return ""[worker "" + std::to_string(id) + ""]"" +
           (name == """" ? """" : "" "" + name);
  }",72,,28,3,,void
89030,BLOCK,-1,,"{
  if (info.worker_thread)
    delegate->WorkerCreated(info.title, info.url, waiting, info.worker_thread);
}",51,,40,4,,void
89035,BLOCK,-1,,<empty>,5,,42,2,,void
89055,BLOCK,-1,,<empty>,78,,47,2,,void
89060,BLOCK,-1,,"{
    thread->inspector_agent()->GetWorkerManager()->WorkerFinished(worker_id_);
  }",51,,49,2,,void
89081,BLOCK,-1,,<empty>,19,,68,6,,void
89085,BLOCK,-1,,"{
  parent_thread_->Post(
      std::unique_ptr<Request>(new WorkerFinishedRequest(id_)));
}",49,,70,1,,void
89104,BLOCK,-1,,"{
  std::unique_ptr<Request> request(
      new WorkerStartedRequest(id_, url_, worker_thread, waiting, name_));
  parent_thread_->Post(std::move(request));
}",68,,76,3,,void
89128,BLOCK,-1,,"{
  return parent_thread_->Connect(std::move(delegate), prevent_shutdown);
}",28,,84,3,,void
89144,BLOCK,-1,,"{
  children_.erase(session_id);
}",57,,88,2,,void
89156,BLOCK,-1,,"{
  if (info.worker_thread->Expired())
    return;
  children_.emplace(session_id, info);
  for (const auto& delegate : delegates_) {
    Report(delegate.second, info, waiting);
  }
}",49,,94,4,,void
89164,BLOCK,-1,,<empty>,5,,96,2,,void
89175,BLOCK,-1,,"{
    Report(delegate.second, info, waiting);
  }",43,,98,3,,void
89188,BLOCK,-1,,"{
  bool wait = !delegates_waiting_on_start_.empty();
  return std::make_unique<ParentInspectorHandle>(
      thread_id, url, thread_, wait, name);
}",74,,104,4,,void
89215,BLOCK,-1,,"{
  delegates_.erase(id);
  delegates_waiting_on_start_.erase(id);
}",50,,110,2,,void
89230,BLOCK,-1,,"{
  int id = ++next_delegate_id_;
  delegates_[id] = std::move(attach_delegate);
  const auto& delegate = delegates_[id];
  for (const auto& worker : children_) {
    // Waiting is only reported when a worker is started, same as browser
    Report(delegate, worker.second, false);
  }
  return std::make_unique<WorkerManagerEventHandle>(shared_from_this(), id);
}",54,,116,2,,void
89254,BLOCK,-1,,"{
    // Waiting is only reported when a worker is started, same as browser
    Report(delegate, worker.second, false);
  }",40,,120,3,,void
89277,BLOCK,-1,,"{
  if (wait)
    delegates_waiting_on_start_.insert(id);
  else
    delegates_waiting_on_start_.erase(id);
}",66,,127,3,,void
89280,BLOCK,-1,,<empty>,5,,129,2,,void
89287,BLOCK,-1,,<empty>,5,,131,1,,void
89297,BLOCK,-1,,"{
    manager_->SetWaitOnStartForDelegate(id_, wait_on_start);
}",67,,134,2,,void
89307,BLOCK,-1,,"{
  manager_->RemoveAttachDelegate(id_);
}",55,,138,1,,void
89327,BLOCK,-1,,<empty>,1,,1,1,,ANY
89340,BLOCK,-1,,<empty>,,,,5,,<empty>
89344,BLOCK,-1,,<empty>,,,,1,,<empty>
89351,BLOCK,-1,,<empty>,66,,33,3,,void
89356,BLOCK,-1,,<empty>,,,,2,,<empty>
89360,BLOCK,-1,,<empty>,,,,1,,<empty>
89370,BLOCK,-1,,<empty>,45,,48,4,,void
89383,BLOCK,-1,,<empty>,,,,6,,<empty>
89387,BLOCK,-1,,<empty>,,,,1,,<empty>
89394,BLOCK,-1,,"{
    return std::make_unique<ParentInspectorHandle>(
        thread_id, url, parent_thread_, wait_, name);
  }",76,,63,4,,void
89414,BLOCK,-1,,<empty>,,,,3,,<empty>
89418,BLOCK,-1,,"{
    return wait_;
  }",25,,69,1,,void
89424,BLOCK,-1,,{ return url_; },34,,72,1,,void
89432,BLOCK,-1,,<empty>,,,,3,,<empty>
89443,BLOCK,-1,,<empty>,44,,88,2,,void
89450,BLOCK,-1,,<empty>,,,,4,,<empty>
89457,BLOCK,-1,,<empty>,,,,4,,<empty>
89462,BLOCK,-1,,<empty>,,,,2,,<empty>
89467,BLOCK,-1,,<empty>,,,,2,,<empty>
89473,BLOCK,-1,,<empty>,,,,3,,<empty>
89478,BLOCK,-1,,<empty>,,,,2,,<empty>
89482,BLOCK,-1,,"{
    return thread_;
  }",50,,98,1,,void
89493,BLOCK,-1,,<empty>,,,,1,,<empty>
89501,BLOCK,-1,,{ callback(data); },53,,551,1,,void
89511,BLOCK,-1,,"{
        CHECK(start_io_thread_async_initialized.exchange(false));
      }",64,,721,2,,void
89524,BLOCK,-1,,"{
      Environment* env = static_cast<Environment*>(data);

      {
        Mutex::ScopedLock lock(start_io_thread_async_mutex);
        start_io_thread_async.data = nullptr;
      }

      // This is global, will never get freed
      env->CloseHandle(&start_io_thread_async, [](uv_async_t*) {
        CHECK(start_io_thread_async_initialized.exchange(false));
      });
    }",48,,712,2,,void
89531,BLOCK,3,,"{
        Mutex::ScopedLock lock(start_io_thread_async_mutex);
        start_io_thread_async.data = nullptr;
      }",7,,715,3,,void
89552,BLOCK,-1,,"{
    Agent* agent = static_cast<Environment*>(env)->inspector_agent();
    if (agent->IsActive()) {
      agent->WaitForDisconnect();
    }
  }",37,,727,2,,void
89567,BLOCK,-1,,"{
      agent->WaitForDisconnect();
    }",28,,729,2,,void
89577,BLOCK,-1,,"{
    StartIoThread();
  }",54,,939,2,,void
89638,BLOCK,-1,,<empty>,1,,1,1,,ANY
89652,BLOCK,-1,,"{
  TwoByteValue buffer(isolate, value);
  return StringBuffer::create(StringView(*buffer, buffer.length()));
}",68,,66,3,,void
89673,BLOCK,-1,,"{
  static_cast<Agent*>(handle->data)->StartIoThread();
}",53,,72,2,,void
89690,BLOCK,-1,,"{
  std::ostringstream result;
  result << ""Worker["" << env->thread_id() << ""]"";
  return result.str();
}",52,,205,2,,void
89717,BLOCK,-1,,"{
    session_ = inspector->connect(CONTEXT_GROUP_ID,
                                  this,
                                  StringView(),
                                  V8Inspector::ClientTrustLevel::kFullyTrusted);
    node_dispatcher_ = std::make_unique<protocol::UberDispatcher>(this);
    tracing_agent_ =
        std::make_unique<protocol::TracingAgent>(env, main_thread_);
    tracing_agent_->Wire(node_dispatcher_.get());
    if (worker_manager) {
      worker_agent_ = std::make_unique<protocol::WorkerAgent>(worker_manager);
      worker_agent_->Wire(node_dispatcher_.get());
    }
    runtime_agent_ = std::make_unique<protocol::RuntimeAgent>();
    runtime_agent_->Wire(node_dispatcher_.get());
  }",35,,221,7,,void
89767,BLOCK,-1,,"{
      worker_agent_ = std::make_unique<protocol::WorkerAgent>(worker_manager);
      worker_agent_->Wire(node_dispatcher_.get());
    }",25,,230,2,,void
89804,BLOCK,-1,,"{
    tracing_agent_->disable();
    tracing_agent_.reset();  // Dispose before the dispatchers
    if (worker_agent_) {
      worker_agent_->disable();
      worker_agent_.reset();  // Dispose before the dispatchers
    }
    runtime_agent_->disable();
    runtime_agent_.reset();  // Dispose before the dispatchers
  }",27,,238,1,,void
89815,BLOCK,-1,,"{
      worker_agent_->disable();
      worker_agent_.reset();  // Dispose before the dispatchers
    }",24,,241,2,,void
89836,BLOCK,-1,,"{
    std::string raw_message = protocol::StringUtil::StringViewToUtf8(message);
    per_process::Debug(DebugCategory::INSPECTOR_SERVER,
                       ""[inspector received] %s\n"",
                       raw_message);
    std::unique_ptr<protocol::DictionaryValue> value =
        protocol::DictionaryValue::cast(protocol::StringUtil::parseMessage(
            raw_message, false));
    int call_id;
    std::string method;
    node_dispatcher_->parseCommand(value.get(), &call_id, &method);
    if (v8_inspector::V8InspectorSession::canDispatchMethod(
            Utf8ToStringView(method)->string())) {
      session_->dispatchProtocolMessage(message);
    } else {
      node_dispatcher_->dispatch(call_id, method, std::move(value),
                                 raw_message);
    }
  }",59,,249,2,,void
89906,BLOCK,-1,,"{
      session_->dispatchProtocolMessage(message);
    }",50,,261,2,,void
89913,BLOCK,-1,,"{
      node_dispatcher_->dispatch(call_id, method, std::move(value),
                                 raw_message);
    }",12,,263,1,,void
89930,BLOCK,-1,,"{
    std::unique_ptr<StringBuffer> buffer = Utf8ToStringView(reason);
    session_->schedulePauseOnNextStatement(buffer->string(), buffer->string());
  }",64,,269,2,,void
89951,BLOCK,-1,,"{
    return prevent_shutdown_;
  }",26,,274,1,,void
89957,BLOCK,-1,,"{
    retaining_context_ = runtime_agent_->notifyWaitingForDisconnect();
    return retaining_context_;
  }",37,,278,1,,void
89969,BLOCK,-1,,"{
    return retaining_context_;
  }",27,,283,1,,void
89977,BLOCK,-1,,"{
    sendMessageToFrontend(message->string());
  }",69,,290,3,,void
89987,BLOCK,-1,,"{
    sendMessageToFrontend(message->string());
  }",69,,295,2,,void
89996,BLOCK,-1,,{ },46,,299,1,,void
90001,BLOCK,-1,,"{
    if (per_process::enabled_debug_list.enabled(
            DebugCategory::INSPECTOR_SERVER)) {
      std::string raw_message = protocol::StringUtil::StringViewToUtf8(message);
      per_process::Debug(DebugCategory::INSPECTOR_SERVER,
                         ""[inspector send] %s\n"",
                         raw_message);
    }
    delegate_->SendMessageToFrontend(message);
  }",57,,301,2,,void
90012,BLOCK,-1,,"{
      std::string raw_message = protocol::StringUtil::StringViewToUtf8(message);
      per_process::Debug(DebugCategory::INSPECTOR_SERVER,
                         ""[inspector send] %s\n"",
                         raw_message);
    }",47,,303,2,,void
90041,BLOCK,-1,,"{
    sendMessageToFrontend(Utf8ToStringView(message)->string());
  }",58,,312,2,,void
90054,BLOCK,-1,,"{
    sendMessageToFrontend(message->serializeToJSON());
  }",77,,319,3,,void
90064,BLOCK,-1,,"{
    sendMessageToFrontend(message->serializeToJSON());
  }",55,,323,2,,void
90076,BLOCK,-1,,"{
    DCHECK(false);
  }",57,,329,4,,void
90093,BLOCK,-1,,<empty>,50,,347,3,,void
90097,BLOCK,-1,,<empty>,,,,1,,<empty>
90102,BLOCK,-1,,<empty>,,,,2,,<empty>
90109,BLOCK,-1,,"{
  Isolate* isolate = env->isolate();
  HandleScope handle_scope(isolate);
  Local<Context> context = env->context();

  // Send message to enable debug in cluster workers
  Local<Object> message = Object::New(isolate);
  message->Set(context, FIXED_ONE_BYTE_STRING(isolate, ""cmd""),
               FIXED_ONE_BYTE_STRING(isolate, ""NODE_DEBUG_ENABLED"")).Check();
  ProcessEmit(env, ""internalMessage"", message);
}",57,,356,2,,void
90163,BLOCK,-1,,"{
  return !path.empty() && path[0] == '/';
}",42,,381,2,,void
90180,BLOCK,-1,,"{
  HandleScope scope(env->isolate());

  const char* msg = ""This Environment was initialized without a V8::Inspector"";
  Local<Value> exception =
    v8::String::NewFromUtf8(env->isolate(), msg).ToLocalChecked();

  env->isolate()->ThrowException(exception);
}",57,,386,2,,void
90224,BLOCK,-1,,"{
    client_ = V8Inspector::create(env->isolate(), this);
    // TODO(bnoordhuis) Make name configurable from src/node.cc.
    std::string name =
        is_main_ ? GetHumanReadableProcessName() : GetWorkerLabel(env);
    ContextInfo info(name);
    info.is_default = true;
    contextCreated(env->context(), info);
  }",38,,401,3,,void
90262,BLOCK,-1,,"{
    waiting_for_resume_ = true;
    runMessageLoop();
  }",61,,411,2,,void
90270,BLOCK,-1,,"{
    waiting_for_sessions_disconnect_ = true;
    runMessageLoop();
  }",36,,416,1,,void
90278,BLOCK,-1,,"{
    waiting_for_frontend_ = true;
    runMessageLoop();
  }",26,,421,1,,void
90287,BLOCK,-1,,"{
    if (waiting_for_sessions_disconnect_) {
      // V8 isolate is mostly done and is only letting Inspector protocol
      // clients gather data.
      return;
    }
    if (auto agent = env_->inspector_agent()) {
      if (depth == 0) {
        agent->DisableAsyncHook();
      } else {
        agent->EnableAsyncHook();
      }
    }
  }",58,,426,2,,void
90290,BLOCK,-1,,"{
      // V8 isolate is mostly done and is only letting Inspector protocol
      // clients gather data.
      return;
    }",43,,427,2,,void
90293,BLOCK,-1,,<empty>,9,,432,1,,void
90301,BLOCK,-1,,"{
      if (depth == 0) {
        agent->DisableAsyncHook();
      } else {
        agent->EnableAsyncHook();
      }
    }",47,,432,2,,void
90306,BLOCK,-1,,"{
        agent->DisableAsyncHook();
      }",23,,433,2,,void
90312,BLOCK,-1,,"{
        agent->EnableAsyncHook();
      }",14,,435,1,,void
90322,BLOCK,-1,,"{
    auto name_buffer = Utf8ToStringView(info.name);
    auto origin_buffer = Utf8ToStringView(info.origin);
    std::unique_ptr<StringBuffer> aux_data_buffer;

    v8_inspector::V8ContextInfo v8info(
        context, CONTEXT_GROUP_ID, name_buffer->string());
    v8info.origin = origin_buffer->string();

    if (info.is_default) {
      aux_data_buffer = Utf8ToStringView(""{\""isDefault\"":true}"");
    } else {
      aux_data_buffer = Utf8ToStringView(""{\""isDefault\"":false}"");
    }
    v8info.auxData = aux_data_buffer->string();

    client_->contextCreated(v8info);
  }",72,,441,3,,void
90358,BLOCK,-1,,"{
      aux_data_buffer = Utf8ToStringView(""{\""isDefault\"":true}"");
    }",26,,450,2,,void
90364,BLOCK,-1,,"{
      aux_data_buffer = Utf8ToStringView(""{\""isDefault\"":false}"");
    }",12,,452,1,,void
90386,BLOCK,-1,,"{
    client_->contextDestroyed(context);
  }",49,,460,2,,void
90395,BLOCK,-1,,"{
    waiting_for_resume_ = false;
  }",42,,464,1,,void
90403,BLOCK,-1,,"{
    waiting_for_frontend_ = false;
  }",63,,468,2,,void
90412,BLOCK,-1,,"{
    int session_id = next_session_id_++;
    channels_[session_id] = std::make_unique<ChannelImpl>(env_,
                                                          client_,
                                                          getWorkerManager(),
                                                          std::move(delegate),
                                                          getThreadHandle(),
                                                          prevent_shutdown);
    return session_id;
  }",46,,473,3,,void
90446,BLOCK,-1,,"{
    auto it = channels_.find(session_id);
    if (it == channels_.end())
      return;
    bool retaining_context = it->second->retainingContext();
    channels_.erase(it);
    if (retaining_context) {
      for (const auto& id_channel : channels_) {
        if (id_channel.second->retainingContext())
          return;
      }
      contextDestroyed(env_->context());
    }
    if (waiting_for_sessions_disconnect_ && !is_main_)
      waiting_for_sessions_disconnect_ = false;
  }",43,,484,2,,void
90462,BLOCK,-1,,<empty>,7,,487,2,,void
90480,BLOCK,-1,,"{
      for (const auto& id_channel : channels_) {
        if (id_channel.second->retainingContext())
          return;
      }
      contextDestroyed(env_->context());
    }",28,,490,2,,void
90484,BLOCK,-1,,"{
        if (id_channel.second->retainingContext())
          return;
      }",48,,491,3,,void
90492,BLOCK,-1,,<empty>,11,,493,2,,void
90504,BLOCK,-1,,<empty>,7,,498,2,,void
90513,BLOCK,-1,,"{
    channels_[session_id]->dispatchProtocolMessage(message);
  }",79,,501,3,,void
90525,BLOCK,-1,,"{
    return env_->context();
  }",75,,505,2,,void
90536,BLOCK,-1,,"{
    Local<Function> installer = env_->inspector_console_extension_installer();
    if (!installer.IsEmpty()) {
      Local<Value> argv[] = {target};
      // If there is an exception, proceed in JS land
      USE(installer->Call(context, target, arraysize(argv), argv));
    }
  }",71,,510,3,,void
90553,BLOCK,-1,,"{
      Local<Value> argv[] = {target};
      // If there is an exception, proceed in JS land
      USE(installer->Call(context, target, arraysize(argv), argv));
    }",31,,512,2,,void
90574,BLOCK,-1,,"{
    Isolate* isolate = env_->isolate();
    Local<Context> context = env_->context();

    int script_id = message->GetScriptOrigin().ScriptId();

    Local<v8::StackTrace> stack_trace = message->GetStackTrace();

    if (!stack_trace.IsEmpty() && stack_trace->GetFrameCount() > 0 &&
        script_id == stack_trace->GetFrame(isolate, 0)->GetScriptId()) {
      script_id = 0;
    }

    const uint8_t DETAILS[] = ""Uncaught"";

    client_->exceptionThrown(
        context,
        StringView(DETAILS, sizeof(DETAILS) - 1),
        error,
        ToProtocolString(isolate, message->Get())->string(),
        ToProtocolString(isolate, message->GetScriptResourceName())->string(),
        message->GetLineNumber(context).FromMaybe(0),
        message->GetStartColumn(context).FromMaybe(0),
        client_->createStackTrace(stack_trace),
        script_id);
  }",76,,519,3,,void
90639,BLOCK,-1,,"{
      script_id = 0;
    }",72,,528,2,,void
90706,BLOCK,-1,,"{
    auto result =
        timers_.emplace(std::piecewise_construct, std::make_tuple(data),
                        std::make_tuple(env_, [=]() { callback(data); }));
    CHECK(result.second);
    uint64_t interval = static_cast<uint64_t>(1000 * interval_s);
    result.first->second.Update(interval, interval);
  }",49,,548,4,,void
90754,BLOCK,-1,,"{
    timers_.erase(data);
  }",41,,557,2,,void
90766,BLOCK,-1,,"{
    client_->asyncTaskScheduled(task_name, task, recurring);
  }",43,,563,4,,void
90778,BLOCK,-1,,"{
    client_->asyncTaskCanceled(task);
  }",38,,567,2,,void
90788,BLOCK,-1,,"{
    client_->asyncTaskStarted(task);
  }",37,,571,2,,void
90798,BLOCK,-1,,"{
    client_->asyncTaskFinished(task);
  }",38,,575,2,,void
90807,BLOCK,-1,,"{
    client_->allAsyncTasksCanceled();
  }",32,,579,1,,void
90816,BLOCK,-1,,"{
    for (const auto& id_channel : channels_) {
      id_channel.second->schedulePauseOnNextStatement(reason);
    }
  }",64,,583,2,,void
90820,BLOCK,-1,,"{
      id_channel.second->schedulePauseOnNextStatement(reason);
    }",46,,584,3,,void
90831,BLOCK,-1,,"{
    for (const auto& id_channel : channels_) {
      // Other sessions are ""invisible"" more most purposes
      if (id_channel.second->preventShutdown())
        return true;
    }
    return false;
  }",31,,589,1,,void
90835,BLOCK,-1,,"{
      // Other sessions are ""invisible"" more most purposes
      if (id_channel.second->preventShutdown())
        return true;
    }",46,,590,3,,void
90843,BLOCK,-1,,<empty>,9,,593,2,,void
90851,BLOCK,-1,,"{
    bool retaining_context = false;
    for (const auto& id_channel : channels_) {
      if (id_channel.second->notifyWaitingForDisconnect())
        retaining_context = true;
    }
    return retaining_context;
  }",37,,598,1,,void
90859,BLOCK,-1,,"{
      if (id_channel.second->notifyWaitingForDisconnect())
        retaining_context = true;
    }",46,,600,3,,void
90867,BLOCK,-1,,<empty>,9,,602,2,,void
90876,BLOCK,-1,,"{
    if (!interface_) {
      interface_ = std::make_shared<MainThreadInterface>(
          env_->inspector_agent());
    }
    return interface_->GetHandle();
  }",55,,607,1,,void
90880,BLOCK,-1,,"{
      interface_ = std::make_shared<MainThreadInterface>(
          env_->inspector_agent());
    }",22,,608,2,,void
90901,BLOCK,-1,,"{
    if (!is_main_) {
      return nullptr;
    }
    if (worker_manager_ == nullptr) {
      worker_manager_ =
          std::make_shared<WorkerManager>(getThreadHandle());
    }
    return worker_manager_;
  }",53,,615,1,,void
90905,BLOCK,-1,,"{
      return nullptr;
    }",20,,616,2,,void
90912,BLOCK,-1,,"{
      worker_manager_ =
          std::make_shared<WorkerManager>(getThreadHandle());
    }",37,,619,2,,void
90927,BLOCK,-1,,"{
    return !channels_.empty();
  }",19,,626,1,,void
90937,BLOCK,-1,,"{
    if (waiting_for_frontend_)
      return true;
    if (waiting_for_sessions_disconnect_ || waiting_for_resume_) {
      return hasConnectedSessions();
    }
    return false;
  }",31,,631,1,,void
90940,BLOCK,-1,,<empty>,7,,633,2,,void
90947,BLOCK,-1,,"{
      return hasConnectedSessions();
    }",66,,634,2,,void
90955,BLOCK,-1,,"{
    if (running_nested_loop_)
      return;

    running_nested_loop_ = true;

    while (shouldRunMessageLoop()) {
      if (interface_) interface_->WaitForFrontendEvent();
      env_->RunAndClearInterrupts();
    }
    running_nested_loop_ = false;
  }",25,,640,1,,void
90958,BLOCK,-1,,<empty>,7,,642,2,,void
90965,BLOCK,-1,,"{
      if (interface_) interface_->WaitForFrontendEvent();
      env_->RunAndClearInterrupts();
    }",36,,646,2,,void
90968,BLOCK,-1,,<empty>,23,,647,2,,void
90983,BLOCK,-1,,"{
    return env_->isolate_data()->platform()->CurrentClockTimeMillis();
  }",35,,653,1,,void
90999,BLOCK,-1,,"{
    std::string resource_name =
        protocol::StringUtil::StringViewToUtf8(resource_name_view);
    if (!IsFilePath(resource_name))
      return nullptr;

    std::string url = node::url::FromFilePath(resource_name);
    return Utf8ToStringView(url);
  }",54,,658,2,,void
91014,BLOCK,-1,,<empty>,7,,662,2,,void
91045,BLOCK,-1,,<empty>,,,,1,,<empty>
91065,BLOCK,-1,,<empty>,46,,687,2,,void
91069,BLOCK,-1,,<empty>,17,,689,1,,void
91077,BLOCK,-1,,"{
  path_ = path;
  debug_options_ = options;
  CHECK_NOT_NULL(host_port);
  host_port_ = host_port;

  client_ = std::make_shared<NodeInspectorClient>(parent_env_, is_main);
  if (parent_env_->owns_inspector()) {
    Mutex::ScopedLock lock(start_io_thread_async_mutex);
    CHECK_EQ(start_io_thread_async_initialized.exchange(true), false);
    CHECK_EQ(0, uv_async_init(parent_env_->event_loop(),
                              &start_io_thread_async,
                              StartIoThreadAsyncCallback));
    uv_unref(reinterpret_cast<uv_handle_t*>(&start_io_thread_async));
    start_io_thread_async.data = this;
    // Ignore failure, SIGUSR1 won't work, but that should not block node start.
    StartDebugSignalHandler();

    parent_env_->AddCleanupHook([](void* data) {
      Environment* env = static_cast<Environment*>(data);

      {
        Mutex::ScopedLock lock(start_io_thread_async_mutex);
        start_io_thread_async.data = nullptr;
      }

      // This is global, will ...",33,,694,5,,void
91106,BLOCK,-1,,"{
    Mutex::ScopedLock lock(start_io_thread_async_mutex);
    CHECK_EQ(start_io_thread_async_initialized.exchange(true), false);
    CHECK_EQ(0, uv_async_init(parent_env_->event_loop(),
                              &start_io_thread_async,
                              StartIoThreadAsyncCallback));
    uv_unref(reinterpret_cast<uv_handle_t*>(&start_io_thread_async));
    start_io_thread_async.data = this;
    // Ignore failure, SIGUSR1 won't work, but that should not block node start.
    StartDebugSignalHandler();

    parent_env_->AddCleanupHook([](void* data) {
      Environment* env = static_cast<Environment*>(data);

      {
        Mutex::ScopedLock lock(start_io_thread_async_mutex);
        start_io_thread_async.data = nullptr;
      }

      // This is global, will never get freed
      env->CloseHandle(&start_io_thread_async, [](uv_async_t*) {
        CHECK(start_io_thread_async_initialized.exchange(false));
      });
    }, parent_env_);
  }",38,,701,2,,void
91157,BLOCK,-1,,"{
    wait_for_connect = parent_handle_->WaitForConnect();
    parent_handle_->WorkerStarted(client_->getThreadHandle(), wait_for_connect);
  }",23,,735,2,,void
91174,BLOCK,-1,,<empty>,10,,738,1,,void
91188,BLOCK,-1,,"{
    return false;
  }",32,,739,2,,void
91193,BLOCK,-1,,"{
    CHECK(!parent_env_->has_serialized_options());
    debug_options_.EnableBreakFirstLine();
    parent_env_->options()->get_debug_options()->EnableBreakFirstLine();
    client_->waitForFrontend();
  }",25,,745,2,,void
91223,BLOCK,-1,,"{
  if (io_ != nullptr)
    return true;

  if (!parent_env_->should_create_inspector() && !client_) {
    ThrowUninitializedInspectorError(parent_env_);
    return false;
  }

  CHECK_NOT_NULL(client_);

  io_ = InspectorIo::Start(client_->getThreadHandle(),
                           path_,
                           host_port_,
                           debug_options_.inspect_publish_uid);
  if (io_ == nullptr) {
    return false;
  }
  NotifyClusterWorkersDebugEnabled(parent_env_);
  return true;
}",29,,754,1,,void
91228,BLOCK,-1,,<empty>,5,,756,2,,void
91240,BLOCK,-1,,"{
    ThrowUninitializedInspectorError(parent_env_);
    return false;
  }",60,,758,2,,void
91264,BLOCK,-1,,"{
    return false;
  }",23,,769,2,,void
91273,BLOCK,-1,,"{
  io_.reset();
}",20,,776,1,,void
91283,BLOCK,-1,,"{
  if (!parent_env_->should_create_inspector() && !client_) {
    ThrowUninitializedInspectorError(parent_env_);
    return std::unique_ptr<InspectorSession>{};
  }

  CHECK_NOT_NULL(client_);

  int session_id = client_->connectFrontend(std::move(delegate),
                                            prevent_shutdown);
  return std::unique_ptr<InspectorSession>(
      new SameThreadInspectorSession(session_id, client_));
}",28,,782,3,,void
91293,BLOCK,-1,,"{
    ThrowUninitializedInspectorError(parent_env_);
    return std::unique_ptr<InspectorSession>{};
  }",60,,783,2,,void
91328,BLOCK,-1,,"{
  if (!parent_env_->should_create_inspector() && !client_) {
    ThrowUninitializedInspectorError(parent_env_);
    return std::unique_ptr<InspectorSession>{};
  }

  CHECK_NOT_NULL(parent_handle_);
  CHECK_NOT_NULL(client_);
  auto thread_safe_delegate =
      client_->getThreadHandle()->MakeDelegateThreadSafe(std::move(delegate));
  return parent_handle_->Connect(std::move(thread_safe_delegate),
                                 prevent_shutdown);
}",28,,798,3,,void
91338,BLOCK,-1,,"{
    ThrowUninitializedInspectorError(parent_env_);
    return std::unique_ptr<InspectorSession>{};
  }",60,,799,2,,void
91374,BLOCK,-1,,"{
  if (!parent_env_->should_create_inspector() && !client_) {
    ThrowUninitializedInspectorError(parent_env_);
    return;
  }

  CHECK_NOT_NULL(client_);
  bool is_worker = parent_handle_ != nullptr;
  parent_handle_.reset();
  if (client_->hasConnectedSessions() && !is_worker) {
    fprintf(stderr, ""Waiting for the debugger to disconnect...\n"");
    fflush(stderr);
  }
  if (!client_->notifyWaitingForDisconnect()) {
    client_->contextDestroyed(parent_env_->context());
  } else if (is_worker) {
    client_->waitForSessionsDisconnect();
  }
  if (io_ != nullptr) {
    io_->StopAcceptingNewConnections();
    client_->waitForSessionsDisconnect();
  }
}",33,,812,1,,void
91384,BLOCK,-1,,"{
    ThrowUninitializedInspectorError(parent_env_);
    return;
  }",60,,813,2,,void
91406,BLOCK,-1,,"{
    fprintf(stderr, ""Waiting for the debugger to disconnect...\n"");
    fflush(stderr);
  }",54,,821,2,,void
91417,BLOCK,-1,,"{
    client_->contextDestroyed(parent_env_->context());
  }",47,,825,2,,void
91427,BLOCK,-1,,<empty>,10,,827,1,,void
91430,BLOCK,-1,,"{
    client_->waitForSessionsDisconnect();
  }",25,,827,2,,void
91439,BLOCK,-1,,"{
    io_->StopAcceptingNewConnections();
    client_->waitForSessionsDisconnect();
  }",23,,830,2,,void
91453,BLOCK,-1,,"{
  if (!IsListening())
    return;
  client_->ReportUncaughtException(error, message);
  WaitForDisconnect();
}",61,,837,3,,void
91457,BLOCK,-1,,<empty>,5,,839,2,,void
91470,BLOCK,-1,,"{
  client_->schedulePauseOnNextStatement(reason);
}",71,,844,2,,void
91482,BLOCK,-1,,"{
  parent_env_->set_inspector_enable_async_hooks(enable_function);
  parent_env_->set_inspector_disable_async_hooks(disable_function);
  if (pending_enable_async_hook_) {
    CHECK(!pending_disable_async_hook_);
    pending_enable_async_hook_ = false;
    EnableAsyncHook();
  } else if (pending_disable_async_hook_) {
    CHECK(!pending_enable_async_hook_);
    pending_disable_async_hook_ = false;
    DisableAsyncHook();
  }
}",65,,850,4,,void
91495,BLOCK,-1,,"{
    CHECK(!pending_disable_async_hook_);
    pending_enable_async_hook_ = false;
    EnableAsyncHook();
  }",35,,853,2,,void
91504,BLOCK,-1,,<empty>,10,,857,1,,void
91507,BLOCK,-1,,"{
    CHECK(!pending_enable_async_hook_);
    pending_disable_async_hook_ = false;
    DisableAsyncHook();
  }",43,,857,2,,void
91518,BLOCK,-1,,"{
  HandleScope scope(parent_env_->isolate());
  Local<Function> enable = parent_env_->inspector_enable_async_hooks();
  if (!enable.IsEmpty()) {
    ToggleAsyncHook(parent_env_->isolate(), enable);
  } else if (pending_disable_async_hook_) {
    CHECK(!pending_enable_async_hook_);
    pending_disable_async_hook_ = false;
  } else {
    pending_enable_async_hook_ = true;
  }
}",31,,864,1,,void
91541,BLOCK,-1,,"{
    ToggleAsyncHook(parent_env_->isolate(), enable);
  }",26,,867,2,,void
91549,BLOCK,-1,,<empty>,10,,869,1,,void
91552,BLOCK,-1,,"{
    CHECK(!pending_enable_async_hook_);
    pending_disable_async_hook_ = false;
  }",43,,869,2,,void
91560,BLOCK,-1,,"{
    pending_enable_async_hook_ = true;
  }",10,,872,1,,void
91567,BLOCK,-1,,"{
  HandleScope scope(parent_env_->isolate());
  Local<Function> disable = parent_env_->inspector_enable_async_hooks();
  if (!disable.IsEmpty()) {
    ToggleAsyncHook(parent_env_->isolate(), disable);
  } else if (pending_enable_async_hook_) {
    CHECK(!pending_disable_async_hook_);
    pending_enable_async_hook_ = false;
  } else {
    pending_disable_async_hook_ = true;
  }
}",32,,877,1,,void
91590,BLOCK,-1,,"{
    ToggleAsyncHook(parent_env_->isolate(), disable);
  }",27,,880,2,,void
91598,BLOCK,-1,,<empty>,10,,882,1,,void
91601,BLOCK,-1,,"{
    CHECK(!pending_disable_async_hook_);
    pending_enable_async_hook_ = false;
  }",42,,882,2,,void
91609,BLOCK,-1,,"{
    pending_disable_async_hook_ = true;
  }",10,,885,1,,void
91618,BLOCK,-1,,"{
  // Guard against running this during cleanup -- no async events will be
  // emitted anyway at that point anymore, and calling into JS is not possible.
  // This should probably not be something we're attempting in the first place,
  // Refs: https://github.com/nodejs/node/pull/34362#discussion_r456006039
  if (!parent_env_->can_call_into_js()) return;
  CHECK(parent_env_->has_run_bootstrapping_code());
  HandleScope handle_scope(isolate);
  CHECK(!fn.IsEmpty());
  auto context = parent_env_->context();
  v8::TryCatch try_catch(isolate);
  USE(fn->Call(context, Undefined(isolate), 0, nullptr));
  if (try_catch.HasCaught() && !try_catch.HasTerminated()) {
    PrintCaughtException(isolate, context, try_catch);
    OnFatalError(""\nnode::inspector::Agent::ToggleAsyncHook"",
                 ""Cannot toggle Inspector's AsyncHook, please report this."");
  }
}",67,,890,3,,void
91625,BLOCK,-1,,<empty>,41,,895,2,,void
91672,BLOCK,-1,,"{
    PrintCaughtException(isolate, context, try_catch);
    OnFatalError(""\nnode::inspector::Agent::ToggleAsyncHook"",
                 ""Cannot toggle Inspector's AsyncHook, please report this."");
  }",60,,902,2,,void
91686,BLOCK,-1,,"{
  client_->AsyncTaskScheduled(task_name, task, recurring);
}",48,,910,4,,void
91698,BLOCK,-1,,"{
  client_->AsyncTaskCanceled(task);
}",43,,914,2,,void
91708,BLOCK,-1,,"{
  client_->AsyncTaskStarted(task);
}",42,,918,2,,void
91718,BLOCK,-1,,"{
  client_->AsyncTaskFinished(task);
}",43,,922,2,,void
91727,BLOCK,-1,,"{
  client_->AllAsyncTasksCanceled();
}",37,,926,1,,void
91735,BLOCK,-1,,"{
  // We need to attempt to interrupt V8 flow (in case Node is running
  // continuous JS code) and to wake up libuv thread (in case Node is waiting
  // for IO events)
  if (!options().allow_attaching_debugger) {
    return;
  }
  CHECK(start_io_thread_async_initialized);
  uv_async_send(&start_io_thread_async);
  parent_env_->RequestInterrupt([this](Environment*) {
    StartIoThread();
  });

  CHECK(start_io_thread_async_initialized);
  uv_async_send(&start_io_thread_async);
}",36,,930,1,,void
91741,BLOCK,-1,,"{
    return;
  }",44,,934,2,,void
91760,BLOCK,-1,,"{
  if (client_ == nullptr)  // This happens for a main context
    return;
  client_->contextCreated(context, info);
}",77,,947,3,,void
91765,BLOCK,-1,,<empty>,5,,949,2,,void
91776,BLOCK,-1,,"{
  if (client_ == nullptr)
    return false;
  return io_ != nullptr || client_->IsActive();
}",24,,953,1,,void
91781,BLOCK,-1,,<empty>,5,,955,2,,void
91797,BLOCK,-1,,"{
  parent_handle_ = std::move(parent_handle);
}",59,,960,2,,void
91811,BLOCK,-1,,"{
  if (!parent_env_->should_create_inspector() && !client_) {
    ThrowUninitializedInspectorError(parent_env_);
    return std::unique_ptr<ParentInspectorHandle>{};
  }

  CHECK_NOT_NULL(client_);
  if (!parent_handle_) {
    return client_->getWorkerManager()->NewParentHandle(thread_id, url, name);
  } else {
    return parent_handle_->NewParentInspectorHandle(thread_id, url, name);
  }
}",74,,965,4,,void
91821,BLOCK,-1,,"{
    ThrowUninitializedInspectorError(parent_env_);
    return std::unique_ptr<ParentInspectorHandle>{};
  }",60,,966,2,,void
91830,BLOCK,-1,,"{
    return client_->getWorkerManager()->NewParentHandle(thread_id, url, name);
  }",24,,972,2,,void
91843,BLOCK,-1,,"{
    return parent_handle_->NewParentInspectorHandle(thread_id, url, name);
  }",10,,974,1,,void
91855,BLOCK,-1,,"{
  if (!parent_env_->should_create_inspector() && !client_) {
    ThrowUninitializedInspectorError(parent_env_);
    return;
  }

  CHECK_NOT_NULL(client_);
  client_->waitForFrontend();
}",30,,979,1,,void
91865,BLOCK,-1,,"{
    ThrowUninitializedInspectorError(parent_env_);
    return;
  }",60,,980,2,,void
91876,BLOCK,-1,,"{
  if (!parent_env_->should_create_inspector() && !client_) {
    ThrowUninitializedInspectorError(parent_env_);
    return std::unique_ptr<WorkerManager>{};
  }

  CHECK_NOT_NULL(client_);
  return client_->getWorkerManager();
}",58,,989,1,,void
91886,BLOCK,-1,,"{
    ThrowUninitializedInspectorError(parent_env_);
    return std::unique_ptr<WorkerManager>{};
  }",60,,990,2,,void
91900,BLOCK,-1,,"{
  if (io_ == nullptr)
    return """";
  return io_->GetWsUrl();
}",37,,999,1,,void
91905,BLOCK,-1,,<empty>,5,,1001,2,,void
91916,BLOCK,-1,,"{
  auto client = client_.lock();
  if (client)
    client->disconnectFrontend(session_id_);
}",59,,1005,1,,void
91926,BLOCK,-1,,<empty>,5,,1008,2,,void
91936,BLOCK,-1,,"{
  auto client = client_.lock();
  if (client)
    client->dispatchMessageFromFrontend(session_id_, message);
}",46,,1012,2,,void
91946,BLOCK,-1,,<empty>,5,,1015,2,,void
91967,BLOCK,-1,,<empty>,1,,1,1,,ANY
91971,BLOCK,-1,,"{
      RequestQueueData* wrapper =
          node::ContainerOf(&RequestQueueData::async_, async);
      wrapper->DoDispatch();
    }",66,,101,2,,void
91994,BLOCK,-1,,"{
    uv_async_t* async = reinterpret_cast<uv_async_t*>(handle);
    RequestQueueData* wrapper =
        node::ContainerOf(&RequestQueueData::async_, async);
    delete wrapper;
  }",36,,376,2,,void
92053,BLOCK,-1,,<empty>,1,,1,1,,ANY
92064,BLOCK,-1,,"{
  std::string script_path;

  if (!script_name.empty()) {
    uv_fs_t req;
    req.ptr = nullptr;
    if (0 == uv_fs_realpath(loop, &req, script_name.c_str(), nullptr)) {
      CHECK_NOT_NULL(req.ptr);
      script_path = std::string(static_cast<char*>(req.ptr));
    }
    uv_fs_req_cleanup(&req);
  }

  return script_path;
}",73,,29,3,,void
92072,BLOCK,-1,,"{
    uv_fs_t req;
    req.ptr = nullptr;
    if (0 == uv_fs_realpath(loop, &req, script_name.c_str(), nullptr)) {
      CHECK_NOT_NULL(req.ptr);
      script_path = std::string(static_cast<char*>(req.ptr));
    }
    uv_fs_req_cleanup(&req);
  }",29,,32,2,,void
92091,BLOCK,-1,,"{
      CHECK_NOT_NULL(req.ptr);
      script_path = std::string(static_cast<char*>(req.ptr));
    }",72,,35,2,,void
92115,BLOCK,-1,,"{
  uint16_t buffer[8];
  CHECK(crypto::CSPRNG(buffer, sizeof(buffer)).is_ok());

  char uuid[256];
  snprintf(uuid, sizeof(uuid), ""%04x%04x-%04x-%04x-%04x-%04x%04x%04x"",
           buffer[0],  // time_low
           buffer[1],  // time_mid
           buffer[2],  // time_low
           (buffer[3] & 0x0fff) | 0x4000,  // time_hi_and_version
           (buffer[4] & 0x3fff) | 0x8000,  // clk_seq_hi clk_seq_low
           buffer[5],  // node
           buffer[6],
           buffer[7]);
  return uuid;
}",26,,47,1,,void
92175,BLOCK,-1,,<empty>,50,,71,4,,void
92180,BLOCK,-1,,"{
    switch (action_) {
      case TransportAction::kKill:
        server->TerminateConnections();
        [[fallthrough]];
      case TransportAction::kStop:
        server->Stop();
        break;
      case TransportAction::kSendMessage:
        server->Send(
            session_id_,
            protocol::StringUtil::StringViewToUtf8(message_->string()));
        break;
    }
  }",54,,73,2,,void
92183,BLOCK,-1,,"{
      case TransportAction::kKill:
        server->TerminateConnections();
        [[fallthrough]];
      case TransportAction::kStop:
        server->Stop();
        break;
      case TransportAction::kSendMessage:
        server->Send(
            session_id_,
            protocol::StringUtil::StringViewToUtf8(message_->string()));
        break;
    }",22,,74,2,,void
92229,BLOCK,-1,,"{
    int err = uv_async_init(loop, &async_, [](uv_async_t* async) {
      RequestQueueData* wrapper =
          node::ContainerOf(&RequestQueueData::async_, async);
      wrapper->DoDispatch();
    });
    CHECK_EQ(0, err);
  }",77,,100,2,,void
92245,BLOCK,-1,,<empty>,,,,2,,<empty>
92252,BLOCK,-1,,"{
    Mutex::ScopedLock scoped_lock(state_lock_);
    bool notify = messages_.empty();
    messages_.emplace_back(action, session_id, std::move(message));
    if (notify) {
      CHECK_EQ(0, uv_async_send(&async_));
      incoming_message_cond_.Broadcast(scoped_lock);
    }
  }",52,,113,4,,void
92276,BLOCK,-1,,"{
      CHECK_EQ(0, uv_async_send(&async_));
      incoming_message_cond_.Broadcast(scoped_lock);
    }",17,,117,2,,void
92290,BLOCK,-1,,"{
    Mutex::ScopedLock scoped_lock(state_lock_);
    if (messages_.empty()) {
      incoming_message_cond_.Wait(scoped_lock);
    }
  }",15,,123,1,,void
92299,BLOCK,-1,,"{
      incoming_message_cond_.Wait(scoped_lock);
    }",28,,125,2,,void
92309,BLOCK,-1,,"{
    server_ = server;
  }",49,,130,2,,void
92316,BLOCK,-1,,"{
    return handle_;
  }",42,,134,1,,void
92322,BLOCK,-1,,<empty>,,,,1,,<empty>
92326,BLOCK,-1,,"{
    Mutex::ScopedLock scoped_lock(state_lock_);
    MessageQueue messages;
    messages_.swap(messages);
    return messages;
  }",30,,141,1,,void
92341,BLOCK,-1,,"{
    if (server_ == nullptr)
      return;
    for (const auto& request : GetMessages()) {
      request.Dispatch(server_);
    }
  }",21,,148,1,,void
92346,BLOCK,-1,,<empty>,7,,150,2,,void
92351,BLOCK,-1,,"{
      request.Dispatch(server_);
    }",47,,151,3,,void
92366,BLOCK,-1,,<empty>,,,,1,,<empty>
92375,BLOCK,-1,,<empty>,63,,167,2,,void
92379,BLOCK,-1,,"{
    Mutex::ScopedLock scoped_lock(lock_);
    data_ = nullptr;
  }",16,,169,1,,void
92392,BLOCK,-1,,"{
    Mutex::ScopedLock scoped_lock(lock_);
    if (data_ != nullptr)
      data_->Post(session_id, action, std::move(message));
  }",52,,176,4,,void
92400,BLOCK,-1,,<empty>,7,,179,2,,void
92415,BLOCK,-1,,"{
    Mutex::ScopedLock scoped_lock(lock_);
    return data_ == nullptr;
  }",18,,182,1,,void
92431,BLOCK,-1,,{ },63,,195,3,,void
92436,BLOCK,-1,,"{
    request_queue_->Post(id_, TransportAction::kSendMessage,
                         StringBuffer::create(message));
  }",80,,196,2,,void
92461,BLOCK,-1,,<empty>,,,,6,,<empty>
92465,BLOCK,-1,,<empty>,,,,1,,<empty>
92471,BLOCK,-1,,<empty>,,,,3,,<empty>
92477,BLOCK,-1,,<empty>,,,,3,,<empty>
92482,BLOCK,-1,,<empty>,,,,2,,<empty>
92486,BLOCK,-1,,<empty>,,,,1,,<empty>
92491,BLOCK,-1,,<empty>,,,,2,,<empty>
92496,BLOCK,-1,,<empty>,,,,2,,<empty>
92501,BLOCK,-1,,"{
    request_queue_->SetServer(server);
  }",61,,224,2,,void
92520,BLOCK,-1,,"{
  auto io = std::unique_ptr<InspectorIo>(
      new InspectorIo(main_thread,
                      path,
                      host_port,
                      inspect_publish_uid));
  if (io->request_queue_->Expired()) {  // Thread is not running
    return nullptr;
  }
  return io;
}",51,,242,5,,void
92543,BLOCK,-1,,"{  // Thread is not running
    return nullptr;
  }",38,,248,2,,void
92555,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(thread_start_lock_);
  CHECK_EQ(uv_thread_create(&thread_, InspectorIo::ThreadMain, this), 0);
  thread_start_condition_.Wait(scoped_lock);
}",25,,263,5,,void
92576,BLOCK,-1,,"{
  request_queue_->Post(0, TransportAction::kKill, nullptr);
  int err = uv_thread_join(&thread_);
  CHECK_EQ(err, 0);
}",29,,269,1,,void
92598,BLOCK,-1,,"{
  request_queue_->Post(0, TransportAction::kStop, nullptr);
}",49,,275,1,,void
92612,BLOCK,-1,,"{
  static_cast<InspectorIo*>(io)->ThreadMain();
}",40,,280,2,,void
92622,BLOCK,-1,,"{
  uv_loop_t loop;
  loop.data = nullptr;
  int err = uv_loop_init(&loop);
  CHECK_EQ(err, 0);
  std::shared_ptr<RequestQueueData> queue(new RequestQueueData(&loop),
                                          RequestQueueData::CloseAndFree);
  std::string script_path = ScriptPath(&loop, script_name_);
  std::unique_ptr<InspectorIoDelegate> delegate(
      new InspectorIoDelegate(queue, main_thread_, id_,
                              script_path, script_name_));
  std::string host;
  int port;
  {
    ExclusiveAccess<HostPort>::Scoped host_port(host_port_);
    host = host_port->host();
    port = host_port->port();
  }
  InspectorSocketServer server(std::move(delegate),
                               &loop,
                               std::move(host),
                               port,
                               inspect_publish_uid_);
  request_queue_ = queue->handle();
  // Its lifetime is now that of the server delegate
  queue.reset();
  {
    Mutex::ScopedLock scoped_l...",32,,284,1,,void
92675,BLOCK,12,,"{
    ExclusiveAccess<HostPort>::Scoped host_port(host_port_);
    host = host_port->host();
    port = host_port->port();
  }",3,,297,12,,void
92717,BLOCK,17,,"{
    Mutex::ScopedLock scoped_lock(thread_start_lock_);
    if (server.Start()) {
      ExclusiveAccess<HostPort>::Scoped host_port(host_port_);
      host_port->set_port(server.Port());
    }
    thread_start_condition_.Broadcast(scoped_lock);
  }",3,,310,17,,void
92726,BLOCK,-1,,"{
      ExclusiveAccess<HostPort>::Scoped host_port(host_port_);
      host_port->set_port(server.Port());
    }",25,,312,2,,void
92753,BLOCK,-1,,"{
  ExclusiveAccess<HostPort>::Scoped host_port(host_port_);
  return FormatWsAddress(host_port->host(), host_port->port(), id_, true);
}",43,,322,1,,void
92777,BLOCK,-1,,<empty>,29,,335,6,,void
92783,BLOCK,-1,,"{
  auto session = main_thread_->Connect(
      std::unique_ptr<InspectorSessionDelegate>(
          new IoSessionDelegate(request_queue_->handle(), session_id)), true);
  if (session) {
    sessions_[session_id] = std::move(session);
    fprintf(stderr, ""Debugger attached.\n"");
  }
}",70,,338,3,,void
92807,BLOCK,-1,,"{
    sessions_[session_id] = std::move(session);
    fprintf(stderr, ""Debugger attached.\n"");
  }",16,,342,2,,void
92825,BLOCK,-1,,"{
  auto session = sessions_.find(session_id);
  if (session != sessions_.end())
    session->second->Dispatch(Utf8ToStringView(message)->string());
}",71,,349,3,,void
92841,BLOCK,-1,,<empty>,5,,352,2,,void
92857,BLOCK,-1,,"{
  sessions_.erase(session_id);
}",54,,355,2,,void
92866,BLOCK,-1,,"{
  return { target_id_ };
}",62,,359,1,,void
92872,BLOCK,-1,,"{
  return script_name_.empty() ? GetHumanReadableProcessName() : script_name_;
}",72,,363,2,,void
92885,BLOCK,-1,,"{
  return ""file://"" + script_path_;
}",70,,367,2,,void
92894,BLOCK,-1,,"{
  queue->handle_->Reset();
  queue->handle_.reset();
  uv_close(reinterpret_cast<uv_handle_t*>(&queue->async_),
           [](uv_handle_t* handle) {
    uv_async_t* async = reinterpret_cast<uv_async_t*>(handle);
    RequestQueueData* wrapper =
        node::ContainerOf(&RequestQueueData::async_, async);
    delete wrapper;
  });
}",62,,372,2,,void
92931,BLOCK,-1,,<empty>,1,,1,1,,ANY
92956,BLOCK,-1,,<empty>,1,,1,1,,ANY
92963,BLOCK,-1,,"{
  TwoByteValue buffer(isolate, value);
  return StringBuffer::create(StringView(*buffer, buffer.length()));
}",68,,36,3,,void
92986,BLOCK,-1,,"{
    return inspector->Connect(std::move(delegate), false);
  }",77,,43,3,,void
93002,BLOCK,-1,,"{
    return FIXED_ONE_BYTE_STRING(env->isolate(), ""Connection"");
  }",55,,47,2,,void
93016,BLOCK,-1,,"{
    return inspector->ConnectToMainThread(std::move(delegate), true);
  }",77,,54,3,,void
93032,BLOCK,-1,,"{
    return FIXED_ONE_BYTE_STRING(env->isolate(), ""MainThreadConnection"");
  }",55,,58,2,,void
93047,BLOCK,-1,,"{
    }",57,,71,3,,void
93052,BLOCK,-1,,"{
      Isolate* isolate = env_->isolate();
      HandleScope handle_scope(isolate);
      Context::Scope context_scope(env_->context());
      Local<Value> argument;
      if (!String::NewFromTwoByte(isolate, message.characters16(),
                                  NewStringType::kNormal,
                                  message.length()).ToLocal(&argument)) return;
      connection_->OnMessage(argument);
    }",18,,75,2,,void
93097,BLOCK,-1,,<empty>,73,,82,2,,void
93112,BLOCK,-1,,"{
    Agent* inspector = env->inspector_agent();
    session_ = ConnectionType::Connect(
        inspector, std::make_unique<JSBindingsSessionDelegate>(env, this));
  }",62,,95,4,,void
93141,BLOCK,-1,,"{
    MakeCallback(callback_.Get(env()->isolate()), 1, &value);
  }",38,,101,2,,void
93159,BLOCK,-1,,"{
    Isolate* isolate = env->isolate();
    Local<FunctionTemplate> tmpl =
        NewFunctionTemplate(isolate, JSBindingsConnection::New);
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        JSBindingsConnection::kInternalFieldCount);
    tmpl->Inherit(AsyncWrap::GetConstructorTemplate(env));
    SetProtoMethod(isolate, tmpl, ""dispatch"", JSBindingsConnection::Dispatch);
    SetProtoMethod(
        isolate, tmpl, ""disconnect"", JSBindingsConnection::Disconnect);
    SetConstructorFunction(
        env->context(), target, ConnectionType::GetClassName(env), tmpl);
  }",60,,105,3,,void
93227,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(info);
    CHECK(info[0]->IsFunction());
    Local<Function> callback = info[0].As<Function>();
    new JSBindingsConnection(env, info.This(), callback);
  }",60,,119,2,,void
93266,BLOCK,-1,,"{
    BaseObjectPtr<JSBindingsConnection> strong_ref{this};
    session_.reset();
    Detach();
  }",21,,127,1,,void
93283,BLOCK,-1,,"{
    JSBindingsConnection* session;
    ASSIGN_OR_RETURN_UNWRAP(&session, info.Holder());
    session->Disconnect();
  }",67,,133,2,,void
93300,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(info);
    JSBindingsConnection* session;
    ASSIGN_OR_RETURN_UNWRAP(&session, info.Holder());
    CHECK(info[0]->IsString());

    if (session->session_) {
      session->session_->Dispatch(
          ToProtocolString(env->isolate(), info[0])->string());
    }
  }",65,,139,2,,void
93328,BLOCK,-1,,"{
      session->session_->Dispatch(
          ToProtocolString(env->isolate(), info[0])->string());
    }",28,,145,2,,void
93350,BLOCK,-1,,"{
    tracker->TrackField(""callback"", callback_);
    tracker->TrackFieldWithSize(
        ""session"", sizeof(*session_), ""InspectorSession"");
  }",58,,151,2,,void
93373,BLOCK,-1,,"{
    return true;  // Binding connections emit events on their own.
  }",59,,160,1,,void
93382,BLOCK,-1,,"{
  Agent* agent = env->inspector_agent();
  return agent->IsActive();
}",48,,169,2,,void
93399,BLOCK,-1,,"{
  auto env = Environment::GetCurrent(info);

  CHECK_EQ(info.Length(), 1);
  CHECK(info[0]->IsFunction());

  env->set_inspector_console_extension_installer(info[0].As<Function>());
}",76,,174,2,,void
93435,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK_GT(args.Length(), 1);
  CHECK(args[0]->IsFunction());
  SlicedArguments call_args(args, /* start */ 2);
  env->inspector_agent()->PauseOnNextJavascriptStatement(""Break on start"");
  v8::MaybeLocal<v8::Value> retval =
      args[0].As<v8::Function>()->Call(env->context(), args[1],
                                       call_args.length(), call_args.out());
  if (!retval.IsEmpty()) {
    args.GetReturnValue().Set(retval.ToLocalChecked());
  }
}",71,,183,2,,void
93509,BLOCK,-1,,"{
    args.GetReturnValue().Set(retval.ToLocalChecked());
  }",26,,192,2,,void
93525,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  Isolate* isolate = env->isolate();
  Local<Context> context = isolate->GetCurrentContext();
  CHECK_GE(info.Length(), 2);
  SlicedArguments call_args(info, /* start */ 2);
  if (InspectorEnabled(env)) {
    Local<Value> inspector_method = info[0];
    CHECK(inspector_method->IsFunction());
    if (!env->is_in_inspector_console_call()) {
      env->set_is_in_inspector_console_call(true);
      MaybeLocal<Value> ret =
          inspector_method.As<Function>()->Call(context,
                                                info.Holder(),
                                                call_args.length(),
                                                call_args.out());
      env->set_is_in_inspector_console_call(false);
      if (ret.IsEmpty())
        return;
    }
  }

  Local<Value> node_method = info[1];
  CHECK(node_method->IsFunction());
  USE(node_method.As<Function>()->Call(context,
                                   info.H...",68,,197,2,,void
93564,BLOCK,-1,,"{
    Local<Value> inspector_method = info[0];
    CHECK(inspector_method->IsFunction());
    if (!env->is_in_inspector_console_call()) {
      env->set_is_in_inspector_console_call(true);
      MaybeLocal<Value> ret =
          inspector_method.As<Function>()->Call(context,
                                                info.Holder(),
                                                call_args.length(),
                                                call_args.out());
      env->set_is_in_inspector_console_call(false);
      if (ret.IsEmpty())
        return;
    }
  }",30,,203,2,,void
93585,BLOCK,-1,,"{
      env->set_is_in_inspector_console_call(true);
      MaybeLocal<Value> ret =
          inspector_method.As<Function>()->Call(context,
                                                info.Holder(),
                                                call_args.length(),
                                                call_args.out());
      env->set_is_in_inspector_console_call(false);
      if (ret.IsEmpty())
        return;
    }",47,,206,2,,void
93627,BLOCK,-1,,<empty>,9,,215,2,,void
93668,BLOCK,-1,,"{
  // The inspector assumes that when other clients use its asyncTask* API,
  // they use real pointers, or at least something aligned like real pointer.
  // In general it means that our task_id should always be even.
  //
  // On 32bit platforms, the 64bit asyncId would get truncated when converted
  // to a 32bit pointer. However, the javascript part will never enable
  // the async_hook on 32bit platforms, therefore the truncation will never
  // happen in practice.
  return reinterpret_cast<void*>(asyncId << 1);
}",44,,227,2,,void
93679,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsNumber());
  int64_t task_id = args[0]->IntegerValue(env->context()).FromJust();
  (env->inspector_agent()->*asyncTaskFn)(GetAsyncTask(task_id));
}",78,,240,2,,void
93724,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsString());
  Local<String> task_name = args[0].As<String>();
  String::Value task_name_value(args.GetIsolate(), task_name);
  StringView task_name_view(*task_name_value, task_name_value.length());

  CHECK(args[1]->IsNumber());
  int64_t task_id = args[1]->IntegerValue(env->context()).FromJust();
  void* task = GetAsyncTask(task_id);

  CHECK(args[2]->IsBoolean());
  bool recurring = args[2]->BooleanValue(args.GetIsolate());

  env->inspector_agent()->AsyncTaskScheduled(task_name_view, task, recurring);
}",80,,247,2,,void
93829,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsFunction());
  Local<Function> enable_function = args[0].As<Function>();
  CHECK(args[1]->IsFunction());
  Local<Function> disable_function = args[1].As<Function>();
  env->inspector_agent()->RegisterAsyncHook(env->isolate(),
    enable_function, disable_function);
}",79,,265,2,,void
93893,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  args.GetReturnValue().Set(env->inspector_agent()->IsListening());
}",57,,276,2,,void
93920,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Agent* agent = env->inspector_agent();

  if (args.Length() > 0 && args[0]->IsUint32()) {
    uint32_t port = args[0].As<Uint32>()->Value();
    CHECK_LE(port, std::numeric_limits<uint16_t>::max());
    ExclusiveAccess<HostPort>::Scoped host_port(agent->host_port());
    host_port->set_port(static_cast<int>(port));
  }

  if (args.Length() > 1 && args[1]->IsString()) {
    Utf8Value host(env->isolate(), args[1].As<String>());
    ExclusiveAccess<HostPort>::Scoped host_port(agent->host_port());
    host_port->set_host(*host);
  }

  agent->StartIoThread();
}",52,,281,2,,void
93950,BLOCK,-1,,"{
    uint32_t port = args[0].As<Uint32>()->Value();
    CHECK_LE(port, std::numeric_limits<uint16_t>::max());
    ExclusiveAccess<HostPort>::Scoped host_port(agent->host_port());
    host_port->set_port(static_cast<int>(port));
  }",49,,285,2,,void
94002,BLOCK,-1,,"{
    Utf8Value host(env->isolate(), args[1].As<String>());
    ExclusiveAccess<HostPort>::Scoped host_port(agent->host_port());
    host_port->set_host(*host);
  }",49,,292,2,,void
94035,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Agent* agent = env->inspector_agent();
  if (agent->IsActive())
    agent->WaitForConnect();
  args.GetReturnValue().Set(agent->IsActive());
}",63,,301,2,,void
94056,BLOCK,-1,,<empty>,5,,305,2,,void
94076,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  std::string url = env->inspector_agent()->GetWsUrl();
  if (url.empty()) {
    return;
  }
  args.GetReturnValue().Set(OneByteString(env->isolate(), url.c_str()));
}",51,,309,2,,void
94100,BLOCK,-1,,"{
    return;
  }",20,,312,2,,void
94125,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  v8::Local<v8::Function> consoleCallFunc =
      NewFunctionTemplate(isolate,
                          InspectorConsoleCall,
                          v8::Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasSideEffect)
          ->GetFunction(context)
          .ToLocalChecked();
  auto name_string = FIXED_ONE_BYTE_STRING(isolate, ""consoleCall"");
  target->Set(context, name_string, consoleCallFunc).Check();
  consoleCallFunc->SetName(name_string);

  SetMethod(context,
            target,
            ""setConsoleExtensionInstaller"",
            SetConsoleExtensionInstaller);
  SetMethod(context, target, ""callAndPauseOnStart"", CallAndPauseOnStart);
  SetMethod(context, target, ""open"", Open);
  SetMethodNoSideEffect(context, target, ""url"", Url);
  SetMethod(context, target, ""waitForDebugger"", WaitForDebugger);
...",53,,319,5,,void
94304,BLOCK,-1,,"{
  registry->Register(InspectorConsoleCall);
  registry->Register(SetConsoleExtensionInstaller);
  registry->Register(CallAndPauseOnStart);
  registry->Register(Open);
  registry->Register(Url);
  registry->Register(WaitForDebugger);

  registry->Register(AsyncTaskScheduledWrapper);
  registry->Register(InvokeAsyncTaskFnWithId<&Agent::AsyncTaskCanceled>);
  registry->Register(InvokeAsyncTaskFnWithId<&Agent::AsyncTaskStarted>);
  registry->Register(InvokeAsyncTaskFnWithId<&Agent::AsyncTaskFinished>);

  registry->Register(RegisterAsyncHookWrapper);
  registry->Register(IsEnabled);

  registry->Register(JSBindingsConnection<LocalConnection>::New);
  registry->Register(JSBindingsConnection<LocalConnection>::Dispatch);
  registry->Register(JSBindingsConnection<LocalConnection>::Disconnect);
  registry->Register(JSBindingsConnection<MainThreadConnection>::New);
  registry->Register(JSBindingsConnection<MainThreadConnection>::Dispatch);
  registry->Register(JSBindingsConnection<MainThrea...",70,,378,2,,void
94413,BLOCK,-1,,"{
    EndStartedProfilers(static_cast<Environment*>(env));
  }",29,,417,2,,void
94451,BLOCK,-1,,<empty>,1,,1,1,,ANY
94456,BLOCK,-1,,<empty>,17,,39,2,,void
94463,BLOCK,-1,,"{
  std::stringstream ss;
  uint32_t id = next_id();
  ss << R""({ ""id"": )"" << id;
  DCHECK(method != nullptr);
  ss << R""(, ""method"": "")"" << method << '""';
  if (params != nullptr) {
    ss << R""(, ""params"": )"" << params;
  }
  ss << "" }"";
  std::string message = ss.str();
  const uint8_t* message_data =
      reinterpret_cast<const uint8_t*>(message.c_str());
  // Save the id of the profile request to identify its response.
  if (is_profile_request) {
    profile_ids_.insert(id);
  }
  Debug(env(),
        DebugCategory::INSPECTOR_PROFILER,
        ""Dispatching message %s\n"",
        message.c_str());
  session_->Dispatch(StringView(message_data, message.length()));
  return id;
}",73,,43,4,,void
94489,BLOCK,-1,,"{
    ss << R""(, ""params"": )"" << params;
  }",26,,49,2,,void
94516,BLOCK,-1,,"{
    profile_ids_.insert(id);
  }",27,,57,2,,void
94550,BLOCK,-1,,"{
  int ret = WriteFileSync(env->isolate(), path, result);
  if (ret != 0) {
    char err_buf[128];
    uv_err_name_r(ret, err_buf, sizeof(err_buf));
    fprintf(stderr, ""%s: Failed to write file %s\n"", err_buf, path);
    return;
  }
  Debug(env, DebugCategory::INSPECTOR_PROFILER, ""Written result to %s\n"", path);
}",47,,70,4,,void
94565,BLOCK,-1,,"{
    char err_buf[128];
    uv_err_name_r(ret, err_buf, sizeof(err_buf));
    fprintf(stderr, ""%s: Failed to write file %s\n"", err_buf, path);
    return;
  }",17,,72,2,,void
94589,BLOCK,-1,,"{
  Environment* env = connection_->env();
  Isolate* isolate = env->isolate();
  HandleScope handle_scope(isolate);
  Local<Context> context = env->context();
  Context::Scope context_scope(context);

  const char* type = connection_->type();
  // Convert StringView to a Local<String>.
  Local<String> message_str;
  if (!String::NewFromTwoByte(isolate,
                              message.characters16(),
                              NewStringType::kNormal,
                              message.length())
           .ToLocal(&message_str)) {
    fprintf(
        stderr, ""Failed to convert %s profile message to V8 string\n"", type);
    return;
  }

  Debug(env,
        DebugCategory::INSPECTOR_PROFILER,
        ""Receive %s profile message\n"",
        type);

  Local<Value> parsed;
  if (!v8::JSON::Parse(context, message_str).ToLocal(&parsed) ||
      !parsed->IsObject()) {
    fprintf(stderr, ""Failed to parse %s profile result as JSON object\n"", type);
    return;
  }

  Local<Objec...",46,,82,2,,void
94655,BLOCK,-1,,"{
    fprintf(
        stderr, ""Failed to convert %s profile message to V8 string\n"", type);
    return;
  }",36,,96,2,,void
94694,BLOCK,-1,,"{
    fprintf(stderr, ""Failed to parse %s profile result as JSON object\n"", type);
    return;
  }",28,,109,2,,void
94736,BLOCK,-1,,"{
    Utf8Value str(isolate, message_str);
    fprintf(
        stderr, ""Cannot retrieve id from the response message:\n%s\n"", *str);
    return;
  }",26,,118,2,,void
94764,BLOCK,-1,,"{
    Utf8Value str(isolate, message_str);
    Debug(env, DebugCategory::INSPECTOR_PROFILER, ""%s\n"", *str);
    return;
  }",39,,126,2,,void
94779,BLOCK,-1,,"{
    Debug(env,
          DebugCategory::INSPECTOR_PROFILER,
          ""Writing profile response (id = %"" PRIu64 "")\n"",
          static_cast<uint64_t>(id));
  }",10,,130,1,,void
94801,BLOCK,-1,,"{
    fprintf(stderr, ""Failed to get 'result' from %s profile response\n"", type);
    return;
  }",33,,140,2,,void
94813,BLOCK,-1,,"{
    fprintf(
        stderr, ""'result' from %s profile response is not an object\n"", type);
    return;
  }",30,,145,2,,void
94837,BLOCK,-1,,"{
  fs::FSReqWrapSync req_wrap_sync;
  int ret = fs::MKDirpSync(nullptr, &req_wrap_sync.req, directory, 0777,
                           nullptr);
  if (ret < 0 && ret != UV_EEXIST) {
    char err_buf[128];
    uv_err_name_r(ret, err_buf, sizeof(err_buf));
    fprintf(stderr,
            ""%s: Failed to create %s profile directory %s\n"",
            err_buf,
            type,
            directory.c_str());
    return false;
  }
  return true;
}",77,,155,3,,void
94862,BLOCK,-1,,"{
    char err_buf[128];
    uv_err_name_r(ret, err_buf, sizeof(err_buf));
    fprintf(stderr,
            ""%s: Failed to create %s profile directory %s\n"",
            err_buf,
            type,
            directory.c_str());
    return false;
  }",36,,159,2,,void
94885,BLOCK,-1,,"{
  uint64_t timestamp =
      static_cast<uint64_t>(GetCurrentTimeInMicroseconds() / 1000);
  return SPrintF(""coverage-%s-%s-%s.json"",
      uv_os_getpid(),
      timestamp,
      env()->thread_id());
}",55,,172,1,,void
94907,BLOCK,-1,,"{
  Local<Context> context = env_->context();

  // Generate the profile output from the subclass.
  Local<Object> profile;
  if (!GetProfile(result).ToLocal(&profile)) {
    return;
  }

  Local<String> result_s;
  if (!v8::JSON::Stringify(context, profile).ToLocal(&result_s)) {
    fprintf(stderr, ""Failed to stringify %s profile result\n"", type());
    return;
  }

  // Create the directory if necessary.
  std::string directory = GetDirectory();
  DCHECK(!directory.empty());
  if (!EnsureDirectory(directory, type())) {
    return;
  }

  std::string filename = GetFilename();
  DCHECK(!filename.empty());
  std::string path = directory + kPathSeparator + filename;

  WriteResult(env_, path.c_str(), result_s);
}",63,,181,2,,void
94932,BLOCK,-1,,"{
    return;
  }",46,,186,2,,void
94954,BLOCK,-1,,"{
    fprintf(stderr, ""Failed to stringify %s profile result\n"", type());
    return;
  }",66,,191,2,,void
94975,BLOCK,-1,,"{
    return;
  }",44,,199,2,,void
95006,BLOCK,-1,,"{
  Isolate* isolate = env_->isolate();
  Local<Context> context = env_->context();
  HandleScope handle_scope(isolate);
  Context::Scope context_scope(context);

  // This is only set up during pre-execution (when the environment variables
  // becomes available in the JS land). If it's empty, we don't have coverage
  // directory path (which is resolved in JS land at the moment) either, so
  // the best we could to is to just discard the profile and do nothing.
  // This should only happen in half-baked Environments created using the
  // embedder API.
  if (env_->source_map_cache_getter().IsEmpty()) {
    return;
  }

  // Generate the profile output from the subclass.
  Local<Object> profile;
  if (!GetProfile(result).ToLocal(&profile)) {
    return;
  }

  // append source-map cache information to coverage object:
  Local<Value> source_map_cache_v;
  {
    TryCatchScope try_catch(env());
    {
      Isolate::AllowJavascriptExecutionScope allow_js_here(isolate);
      Local<Func...",63,,210,2,,void
95038,BLOCK,-1,,"{
    return;
  }",50,,222,2,,void
95054,BLOCK,-1,,"{
    return;
  }",46,,228,2,,void
95061,BLOCK,12,,"{
    TryCatchScope try_catch(env());
    {
      Isolate::AllowJavascriptExecutionScope allow_js_here(isolate);
      Local<Function> source_map_cache_getter = env_->source_map_cache_getter();
      if (!source_map_cache_getter->Call(
              context, Undefined(isolate), 0, nullptr)
              .ToLocal(&source_map_cache_v)) {
        return;
      }
    }
    if (try_catch.HasCaught() && !try_catch.HasTerminated()) {
      PrintCaughtException(isolate, context, try_catch);
    }
  }",3,,234,12,,void
95065,BLOCK,3,,"{
      Isolate::AllowJavascriptExecutionScope allow_js_here(isolate);
      Local<Function> source_map_cache_getter = env_->source_map_cache_getter();
      if (!source_map_cache_getter->Call(
              context, Undefined(isolate), 0, nullptr)
              .ToLocal(&source_map_cache_v)) {
        return;
      }
    }",5,,236,3,,void
95095,BLOCK,-1,,"{
        return;
      }",46,,241,2,,void
95108,BLOCK,-1,,"{
      PrintCaughtException(isolate, context, try_catch);
    }",62,,245,2,,void
95119,BLOCK,-1,,"{
    profile->Set(context, FIXED_ONE_BYTE_STRING(isolate, ""source-map-cache""),
                source_map_cache_v).ToChecked();
  }",43,,250,2,,void
95152,BLOCK,-1,,"{
    fprintf(stderr, ""Failed to stringify %s profile result\n"", type());
    return;
  }",66,,256,2,,void
95173,BLOCK,-1,,"{
    return;
  }",44,,264,2,,void
95204,BLOCK,-1,,"{
  return result;
}",75,,275,2,,void
95210,BLOCK,-1,,"{
  return env()->coverage_directory();
}",56,,279,1,,void
95219,BLOCK,-1,,"{
  DispatchMessage(""Profiler.enable"");
  DispatchMessage(""Profiler.startPreciseCoverage"",
                  R""({ ""callCount"": true, ""detailed"": true })"");
}",36,,283,1,,void
95228,BLOCK,-1,,"{
  DispatchMessage(""Profiler.takePreciseCoverage"", nullptr, true);
}",43,,289,1,,void
95236,BLOCK,-1,,"{
  DispatchMessage(""Profiler.stopPreciseCoverage"");
}",43,,293,1,,void
95242,BLOCK,-1,,"{
  Debug(env_,
      DebugCategory::INSPECTOR_PROFILER,
      ""V8CoverageConnection::End(), ending = %d\n"", ending_);
  if (ending_) {
    return;
  }
  ending_ = true;
  TakeCoverage();
}",34,,297,1,,void
95252,BLOCK,-1,,"{
    return;
  }",16,,301,2,,void
95261,BLOCK,-1,,"{
  return env()->cpu_prof_dir();
}",59,,308,1,,void
95270,BLOCK,-1,,"{
  return env()->cpu_prof_name();
}",58,,312,1,,void
95280,BLOCK,-1,,"{
  Local<Value> profile_v;
  if (!result
           ->Get(env()->context(),
                 FIXED_ONE_BYTE_STRING(env()->isolate(), ""profile""))
           .ToLocal(&profile_v)) {
    fprintf(stderr, ""'profile' from CPU profile result is undefined\n"");
    return MaybeLocal<Object>();
  }
  if (!profile_v->IsObject()) {
    fprintf(stderr, ""'profile' from CPU profile result is not an Object\n"");
    return MaybeLocal<Object>();
  }
  return profile_v.As<Object>();
}",78,,316,2,,void
95307,BLOCK,-1,,"{
    fprintf(stderr, ""'profile' from CPU profile result is undefined\n"");
    return MaybeLocal<Object>();
  }",34,,321,2,,void
95319,BLOCK,-1,,"{
    fprintf(stderr, ""'profile' from CPU profile result is not an Object\n"");
    return MaybeLocal<Object>();
  }",31,,325,2,,void
95333,BLOCK,-1,,"{
  DispatchMessage(""Profiler.enable"");
  std::string params = R""({ ""interval"": )"";
  params += std::to_string(env()->cpu_prof_interval());
  params += "" }"";
  DispatchMessage(""Profiler.setSamplingInterval"", params.c_str());
  DispatchMessage(""Profiler.start"");
}",39,,332,1,,void
95364,BLOCK,-1,,"{
  Debug(env_,
      DebugCategory::INSPECTOR_PROFILER,
      ""V8CpuProfilerConnection::End(), ending = %d\n"", ending_);
  if (ending_) {
    return;
  }
  ending_ = true;
  DispatchMessage(""Profiler.stop"", nullptr, true);
}",37,,341,1,,void
95374,BLOCK,-1,,"{
    return;
  }",16,,345,2,,void
95386,BLOCK,-1,,"{
  return env()->heap_prof_dir();
}",60,,352,1,,void
95395,BLOCK,-1,,"{
  return env()->heap_prof_name();
}",59,,356,1,,void
95405,BLOCK,-1,,"{
  Local<Value> profile_v;
  if (!result
           ->Get(env()->context(),
                 FIXED_ONE_BYTE_STRING(env()->isolate(), ""profile""))
           .ToLocal(&profile_v)) {
    fprintf(stderr, ""'profile' from heap profile result is undefined\n"");
    return MaybeLocal<Object>();
  }
  if (!profile_v->IsObject()) {
    fprintf(stderr, ""'profile' from heap profile result is not an Object\n"");
    return MaybeLocal<Object>();
  }
  return profile_v.As<Object>();
}",79,,360,2,,void
95432,BLOCK,-1,,"{
    fprintf(stderr, ""'profile' from heap profile result is undefined\n"");
    return MaybeLocal<Object>();
  }",34,,365,2,,void
95444,BLOCK,-1,,"{
    fprintf(stderr, ""'profile' from heap profile result is not an Object\n"");
    return MaybeLocal<Object>();
  }",31,,369,2,,void
95458,BLOCK,-1,,"{
  DispatchMessage(""HeapProfiler.enable"");
  std::string params = R""({ ""samplingInterval"": )"";
  params += std::to_string(env()->heap_prof_interval());
  params += "" }"";
  DispatchMessage(""HeapProfiler.startSampling"", params.c_str());
}",40,,376,1,,void
95487,BLOCK,-1,,"{
  Debug(env_,
      DebugCategory::INSPECTOR_PROFILER,
      ""V8HeapProfilerConnection::End(), ending = %d\n"", ending_);
  if (ending_) {
    return;
  }
  ending_ = true;
  DispatchMessage(""HeapProfiler.stopSampling"", nullptr, true);
}",38,,384,1,,void
95497,BLOCK,-1,,"{
    return;
  }",16,,388,2,,void
95510,BLOCK,-1,,"{
  // TODO(joyeechueng): merge these connections and use one session per env.
  Debug(env, DebugCategory::INSPECTOR_PROFILER, ""EndStartedProfilers\n"");
  V8ProfilerConnection* connection = env->cpu_profiler_connection();
  if (connection != nullptr) {
    connection->End();
  }

  connection = env->heap_profiler_connection();
  if (connection != nullptr) {
    connection->End();
  }

  connection = env->coverage_connection();
  if (connection != nullptr) {
    connection->End();
  }
}",51,,397,2,,void
95528,BLOCK,-1,,"{
    connection->End();
  }",30,,401,2,,void
95543,BLOCK,-1,,"{
    connection->End();
  }",30,,406,2,,void
95558,BLOCK,-1,,"{
    connection->End();
  }",30,,411,2,,void
95566,BLOCK,-1,,"{
  AtExit(env, [](void* env) {
    EndStartedProfilers(static_cast<Environment*>(env));
  }, env);

  Isolate* isolate = env->isolate();
  Local<String> coverage_str = env->env_vars()->Get(
      isolate, FIXED_ONE_BYTE_STRING(isolate, ""NODE_V8_COVERAGE""))
      .FromMaybe(Local<String>());
  if ((!coverage_str.IsEmpty() && coverage_str->Length() > 0) ||
      env->options()->test_runner_coverage) {
    CHECK_NULL(env->coverage_connection());
    env->set_coverage_connection(std::make_unique<V8CoverageConnection>(env));
    env->coverage_connection()->Start();
  }
  if (env->options()->cpu_prof) {
    const std::string& dir = env->options()->cpu_prof_dir;
    env->set_cpu_prof_interval(env->options()->cpu_prof_interval);
    env->set_cpu_prof_dir(dir.empty() ? env->GetCwd() : dir);
    if (env->options()->cpu_prof_name.empty()) {
      DiagnosticFilename filename(env, ""CPU"", ""cpuprofile"");
      env->set_cpu_prof_name(*filename);
    } else {
      env->set_cpu_prof_name(env->optio...",39,,416,2,,void
95619,BLOCK,-1,,"{
    CHECK_NULL(env->coverage_connection());
    env->set_coverage_connection(std::make_unique<V8CoverageConnection>(env));
    env->coverage_connection()->Start();
  }",45,,426,2,,void
95650,BLOCK,-1,,"{
    const std::string& dir = env->options()->cpu_prof_dir;
    env->set_cpu_prof_interval(env->options()->cpu_prof_interval);
    env->set_cpu_prof_dir(dir.empty() ? env->GetCwd() : dir);
    if (env->options()->cpu_prof_name.empty()) {
      DiagnosticFilename filename(env, ""CPU"", ""cpuprofile"");
      env->set_cpu_prof_name(*filename);
    } else {
      env->set_cpu_prof_name(env->options()->cpu_prof_name);
    }
    CHECK_NULL(env->cpu_profiler_connection());
    env->set_cpu_profiler_connection(
        std::make_unique<V8CpuProfilerConnection>(env));
    env->cpu_profiler_connection()->Start();
  }",33,,431,2,,void
95694,BLOCK,-1,,"{
      DiagnosticFilename filename(env, ""CPU"", ""cpuprofile"");
      env->set_cpu_prof_name(*filename);
    }",48,,435,2,,void
95707,BLOCK,-1,,"{
      env->set_cpu_prof_name(env->options()->cpu_prof_name);
    }",12,,438,1,,void
95748,BLOCK,-1,,"{
    const std::string& dir = env->options()->heap_prof_dir;
    env->set_heap_prof_interval(env->options()->heap_prof_interval);
    env->set_heap_prof_dir(dir.empty() ? env->GetCwd() : dir);
    if (env->options()->heap_prof_name.empty()) {
      DiagnosticFilename filename(env, ""Heap"", ""heapprofile"");
      env->set_heap_prof_name(*filename);
    } else {
      env->set_heap_prof_name(env->options()->heap_prof_name);
    }
    env->set_heap_profiler_connection(
        std::make_unique<profiler::V8HeapProfilerConnection>(env));
    env->heap_profiler_connection()->Start();
  }",34,,446,2,,void
95792,BLOCK,-1,,"{
      DiagnosticFilename filename(env, ""Heap"", ""heapprofile"");
      env->set_heap_prof_name(*filename);
    }",49,,450,2,,void
95805,BLOCK,-1,,"{
      env->set_heap_prof_name(env->options()->heap_prof_name);
    }",12,,453,1,,void
95840,BLOCK,-1,,"{
  CHECK(args[0]->IsString());
  Environment* env = Environment::GetCurrent(args);
  node::Utf8Value directory(env->isolate(), args[0].As<String>());
  env->set_coverage_directory(*directory);
}",75,,462,2,,void
95878,BLOCK,-1,,"{
  CHECK(args[0]->IsFunction());
  Environment* env = Environment::GetCurrent(args);
  env->set_source_map_cache_getter(args[0].As<Function>());
}",78,,470,2,,void
95908,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  V8CoverageConnection* connection = env->coverage_connection();

  Debug(
    env,
    DebugCategory::INSPECTOR_PROFILER,
    ""TakeCoverage, connection %s nullptr\n"",
    connection == nullptr ? ""=="" : ""!="");

  if (connection != nullptr) {
    Debug(env, DebugCategory::INSPECTOR_PROFILER, ""taking coverage\n"");
    connection->TakeCoverage();
  }
}",67,,476,2,,void
95940,BLOCK,-1,,"{
    Debug(env, DebugCategory::INSPECTOR_PROFILER, ""taking coverage\n"");
    connection->TakeCoverage();
  }",30,,486,2,,void
95955,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  V8CoverageConnection* connection = env->coverage_connection();

  Debug(env,
        DebugCategory::INSPECTOR_PROFILER,
        ""StopCoverage, connection %s nullptr\n"",
        connection == nullptr ? ""=="" : ""!="");

  if (connection != nullptr) {
    Debug(env, DebugCategory::INSPECTOR_PROFILER, ""Stopping coverage\n"");
    connection->StopCoverage();
  }
}",67,,492,2,,void
95987,BLOCK,-1,,"{
    Debug(env, DebugCategory::INSPECTOR_PROFILER, ""Stopping coverage\n"");
    connection->StopCoverage();
  }",30,,501,2,,void
96005,BLOCK,-1,,"{
  SetMethod(context, target, ""setCoverageDirectory"", SetCoverageDirectory);
  SetMethod(
      context, target, ""setSourceMapCacheGetter"", SetSourceMapCacheGetter);
  SetMethod(context, target, ""takeCoverage"", TakeCoverage);
  SetMethod(context, target, ""stopCoverage"", StopCoverage);
}",36,,510,5,,void
96030,BLOCK,-1,,"{
  registry->Register(SetCoverageDirectory);
  registry->Register(SetSourceMapCacheGetter);
  registry->Register(TakeCoverage);
  registry->Register(StopCoverage);
}",70,,518,2,,void
96062,BLOCK,-1,,<empty>,1,,1,1,,ANY
96066,BLOCK,-1,,{ return b == 0; },59,,204,2,,void
96093,BLOCK,-1,,<empty>,1,,1,1,,ANY
96099,BLOCK,-1,,<empty>,,,,2,,<empty>
96106,BLOCK,-1,,<empty>,,,,3,,<empty>
96111,BLOCK,-1,,<empty>,,,,2,,<empty>
96117,BLOCK,-1,,<empty>,,,,3,,<empty>
96121,BLOCK,-1,,"{
    return &tcp_;
  }",19,,30,1,,void
96128,BLOCK,-1,,<empty>,,,,1,,<empty>
96133,BLOCK,-1,,"{
    return node::ContainerOf(&TcpHolder::tcp_,
                             reinterpret_cast<uv_tcp_t*>(handle));
  }",40,,36,2,,void
96150,BLOCK,-1,,<empty>,,,,2,,<empty>
96157,BLOCK,-1,,<empty>,,,,4,,<empty>
96162,BLOCK,-1,,<empty>,,,,2,,<empty>
96166,BLOCK,-1,,<empty>,,,,1,,<empty>
96172,BLOCK,-1,,<empty>,,,,3,,<empty>
96183,BLOCK,-1,,<empty>,,,,3,,<empty>
96188,BLOCK,-1,,<empty>,,,,2,,<empty>
96193,BLOCK,-1,,<empty>,,,,2,,<empty>
96197,BLOCK,-1,,<empty>,,,,1,,<empty>
96202,BLOCK,-1,,<empty>,,,,2,,<empty>
96206,BLOCK,-1,,<empty>,,,,1,,<empty>
96210,BLOCK,-1,,<empty>,,,,1,,<empty>
96214,BLOCK,-1,,"{
    return inspector_;
  }",32,,66,1,,void
96220,BLOCK,-1,,<empty>,,,,1,,<empty>
96224,BLOCK,-1,,<empty>,,,,1,,<empty>
96230,BLOCK,-1,,<empty>,,,,3,,<empty>
96234,BLOCK,-1,,<empty>,,,,1,,<empty>
96244,BLOCK,-1,,<empty>,58,,114,3,,void
96249,BLOCK,-1,,"{
    return node::ContainerOf(&WriteRequest::req, req);
  }",56,,116,2,,void
96265,BLOCK,-1,,"{
    delete WriteRequest::from_write_req(req);
  }",52,,120,3,,void
96282,BLOCK,-1,,"{
  *buf = uv_buf_init(new char[len], len);
}",70,,130,4,,void
96295,BLOCK,-1,,"{
  buffer->erase(buffer->begin(), buffer->begin() + count);
}",76,,134,3,,void
96326,BLOCK,-1,,"{
  // Magic string from websockets spec.
  static const char ws_magic[] = ""258EAFA5-E914-47DA-95CA-C5AB0DC85B11"";
  std::string input(client_key + ws_magic);
  char hash[SHA_DIGEST_LENGTH];
  USE(SHA1(reinterpret_cast<const unsigned char*>(input.data()),
           input.size(),
           reinterpret_cast<unsigned char*>(hash)));
  node::base64_encode(hash, sizeof(hash), *buffer, sizeof(*buffer));
}",71,,145,3,,void
96368,BLOCK,-1,,"{
  size_t last_colon_pos = host.rfind(':');
  if (last_colon_pos == std::string::npos)
    return host;
  size_t bracket = host.rfind(']');
  if (bracket == std::string::npos || last_colon_pos > bracket)
    return host.substr(0, last_colon_pos);
  return host;
}",54,,156,2,,void
96385,BLOCK,-1,,<empty>,5,,159,2,,void
96408,BLOCK,-1,,<empty>,5,,162,2,,void
96422,BLOCK,-1,,"{
  // To avoid DNS rebinding attacks, we are aware of the following requirements:
  // * the host name must be an IP address (CVE-2018-7160, CVE-2022-32212),
  // * the IP address must be routable (hackerone.com/reports/1632921), and
  // * the IP address must be formatted unambiguously (CVE-2022-43548).

  // The logic below assumes that the string is null-terminated, so ensure that
  // we did not somehow end up with null characters within the string.
  if (host.find('\0') != std::string::npos) return false;

  // All IPv6 addresses must be enclosed in square brackets, and anything
  // enclosed in square brackets must be an IPv6 address.
  if (host.length() >= 4 && host.front() == '[' && host.back() == ']') {
    // INET6_ADDRSTRLEN is the maximum length of the dual format (including the
    // terminating null character), which is the longest possible representation
    // of an IPv6 address: xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:ddd.ddd.ddd.ddd
    if (host.length() - 2 >= INET6_ADDRS...",50,,166,2,,void
96435,BLOCK,-1,,<empty>,45,,174,2,,void
96459,BLOCK,-1,,"{
    // INET6_ADDRSTRLEN is the maximum length of the dual format (including the
    // terminating null character), which is the longest possible representation
    // of an IPv6 address: xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:ddd.ddd.ddd.ddd
    if (host.length() - 2 >= INET6_ADDRSTRLEN) return false;

    // Annoyingly, libuv's implementation of inet_pton() deviates from other
    // implementations of the function in that it allows '%' in IPv6 addresses.
    if (host.find('%') != std::string::npos) return false;

    // Parse the IPv6 address to ensure it is syntactically valid.
    char ipv6_str[INET6_ADDRSTRLEN];
    std::copy(host.begin() + 1, host.end() - 1, ipv6_str);
    ipv6_str[host.length()] = '\0';
    unsigned char ipv6[sizeof(struct in6_addr)];
    if (uv_inet_pton(AF_INET6, ipv6_str, ipv6) != 0) return false;

    // The only non-routable IPv6 address is ::/128. It should not be necessary
    // to explicitly reject it because it will still be enclosed in square
    // brac...",72,,178,2,,void
96469,BLOCK,-1,,<empty>,48,,182,2,,void
96484,BLOCK,-1,,<empty>,46,,186,2,,void
96521,BLOCK,-1,,<empty>,54,,193,2,,void
96535,BLOCK,-1,,"{
      return false;
    }",80,,204,2,,void
96551,BLOCK,-1,,<empty>,55,,219,2,,void
96560,BLOCK,-1,,<empty>,21,,226,2,,void
96638,BLOCK,-1,,"{
  std::vector<char> frame;
  OpCode op_code = kOpCodeText;
  frame.push_back(kFinalBit | op_code);
  const size_t data_length = message.size();
  if (data_length <= kMaxSingleBytePayloadLength) {
    frame.push_back(static_cast<char>(data_length));
  } else if (data_length <= 0xFFFF) {
    frame.push_back(kTwoBytePayloadLengthField);
    frame.push_back((data_length & 0xFF00) >> 8);
    frame.push_back(data_length & 0xFF);
  } else {
    frame.push_back(kEightBytePayloadLengthField);
    char extended_payload_length[8];
    size_t remaining = data_length;
    // Fill the length into extended_payload_length in the network byte order.
    for (int i = 0; i < 8; ++i) {
      extended_payload_length[7 - i] = remaining & 0xFF;
      remaining >>= 8;
    }
    frame.insert(frame.end(), extended_payload_length,
                 extended_payload_length + 8);
    CHECK_EQ(0, remaining);
  }
  frame.insert(frame.end(), message.begin(), message.end());
  return frame;
}",80,,256,2,,void
96662,BLOCK,-1,,"{
    frame.push_back(static_cast<char>(data_length));
  }",51,,261,2,,void
96671,BLOCK,-1,,<empty>,10,,263,1,,void
96676,BLOCK,-1,,"{
    frame.push_back(kTwoBytePayloadLengthField);
    frame.push_back((data_length & 0xFF00) >> 8);
    frame.push_back(data_length & 0xFF);
  }",37,,263,2,,void
96699,BLOCK,-1,,"{
    frame.push_back(kEightBytePayloadLengthField);
    char extended_payload_length[8];
    size_t remaining = data_length;
    // Fill the length into extended_payload_length in the network byte order.
    for (int i = 0; i < 8; ++i) {
      extended_payload_length[7 - i] = remaining & 0xFF;
      remaining >>= 8;
    }
    frame.insert(frame.end(), extended_payload_length,
                 extended_payload_length + 8);
    CHECK_EQ(0, remaining);
  }",10,,267,1,,void
96711,BLOCK,-1,,<empty>,5,,272,1,,void
96721,BLOCK,4,,"{
      extended_payload_length[7 - i] = remaining & 0xFF;
      remaining >>= 8;
    }",33,,272,4,,void
96775,BLOCK,-1,,"{
  *bytes_consumed = 0;
  if (buffer.size() < 2)
    return FRAME_INCOMPLETE;

  auto it = buffer.begin();

  unsigned char first_byte = *it++;
  unsigned char second_byte = *it++;

  bool final = (first_byte & kFinalBit) != 0;
  bool reserved1 = (first_byte & kReserved1Bit) != 0;
  bool reserved2 = (first_byte & kReserved2Bit) != 0;
  bool reserved3 = (first_byte & kReserved3Bit) != 0;
  int op_code = first_byte & kOpCodeMask;
  bool masked = (second_byte & kMaskBit) != 0;
  *compressed = reserved1;
  if (!final || reserved2 || reserved3)
    return FRAME_ERROR;  // Only compression extension is supported.

  bool closed = false;
  switch (op_code) {
    case kOpCodeClose:
      closed = true;
      break;
    case kOpCodeText:
      break;
    case kOpCodeBinary:        // We don't support binary frames yet.
    case kOpCodeContinuation:  // We don't support binary frames yet.
    case kOpCodePing:          // We don't support binary frames yet.
    case kOpCodePong:          // ...",63,,288,6,,void
96787,BLOCK,-1,,<empty>,5,,291,2,,void
96866,BLOCK,-1,,<empty>,5,,306,2,,void
96875,BLOCK,-1,,"{
    case kOpCodeClose:
      closed = true;
      break;
    case kOpCodeText:
      break;
    case kOpCodeBinary:        // We don't support binary frames yet.
    case kOpCodeContinuation:  // We don't support binary frames yet.
    case kOpCodePing:          // We don't support binary frames yet.
    case kOpCodePong:          // We don't support binary frames yet.
    default:
      return FRAME_ERROR;
  }",20,,309,2,,void
96901,BLOCK,-1,,"{
    return FRAME_ERROR;
  }",32,,324,2,,void
96914,BLOCK,-1,,"{
    int extended_payload_length_size;
    if (payload_length64 == kTwoBytePayloadLengthField) {
      extended_payload_length_size = 2;
    } else if (payload_length64 == kEightBytePayloadLengthField) {
      extended_payload_length_size = 8;
    } else {
      return FRAME_ERROR;
    }
    if ((buffer.end() - it) < extended_payload_length_size)
      return FRAME_INCOMPLETE;
    payload_length64 = 0;
    for (int i = 0; i < extended_payload_length_size; ++i) {
      payload_length64 <<= 8;
      payload_length64 |= static_cast<unsigned char>(*it++);
    }
  }",55,,329,2,,void
96920,BLOCK,-1,,"{
      extended_payload_length_size = 2;
    }",57,,331,2,,void
96925,BLOCK,-1,,<empty>,12,,333,1,,void
96930,BLOCK,-1,,"{
      extended_payload_length_size = 8;
    }",66,,333,2,,void
96935,BLOCK,-1,,"{
      return FRAME_ERROR;
    }",12,,335,1,,void
96947,BLOCK,-1,,<empty>,7,,339,2,,void
96954,BLOCK,-1,,<empty>,5,,341,1,,void
96964,BLOCK,4,,"{
      payload_length64 <<= 8;
      payload_length64 |= static_cast<unsigned char>(*it++);
    }",60,,341,4,,void
96993,BLOCK,-1,,"{
    // WebSocket frame length too large.
    return FRAME_ERROR;
  }",64,,350,2,,void
97011,BLOCK,-1,,<empty>,5,,357,2,,void
97025,BLOCK,-1,,<empty>,3,,361,1,,void
97080,BLOCK,-1,,{ },31,,377,3,,void
97085,BLOCK,-1,,{ },62,,379,2,,void
97089,BLOCK,-1,,<empty>,35,,380,1,,void
97093,BLOCK,-1,,"{
    tcp_.reset();
    if (dispose_)
      delete this;
  }",25,,382,1,,void
97100,BLOCK,-1,,<empty>,7,,385,2,,void
97107,BLOCK,-1,,"{
    // 1. Parse.
    int processed = 0;
    do {
      processed = ParseWsFrames(*data);
      // 2. Fix the data size & length
      if (processed > 0) {
        remove_from_beginning(data, processed);
      }
    } while (processed > 0 && !data->empty());
  }",49,,388,2,,void
97113,BLOCK,-1,,"{
      processed = ParseWsFrames(*data);
      // 2. Fix the data size & length
      if (processed > 0) {
        remove_from_beginning(data, processed);
      }
    }",8,,391,1,,void
97123,BLOCK,-1,,"{
        remove_from_beginning(data, processed);
      }",26,,394,2,,void
97140,BLOCK,-1,,"{
    std::vector<char> output = encode_frame_hybi17(data);
    WriteRaw(output, WriteRequest::Cleanup);
  }",53,,400,2,,void
97154,BLOCK,-1,,"{
    if (tcp_) {
      dispose_ = true;
      SendClose();
    } else {
      delete this;
    }
  }",28,,406,1,,void
97157,BLOCK,-1,,"{
      dispose_ = true;
      SendClose();
    }",15,,407,2,,void
97163,BLOCK,-1,,"{
      delete this;
    }",12,,410,1,,void
97172,BLOCK,-1,,"{
    WriteRequest* wr = WriteRequest::from_write_req(req);
    WsHandler* handler = static_cast<WsHandler*>(wr->handler);
    delete wr;
    Callback cb = handler->OnCloseSent;
    (handler->*cb)();
  }",64,,418,3,,void
97204,BLOCK,-1,,"{
    OnCloseReceived = &WsHandler::OnEof;
  }",28,,426,1,,void
97214,BLOCK,-1,,"{
    WriteRaw(std::vector<char>(CLOSE_FRAME, CLOSE_FRAME + sizeof(CLOSE_FRAME)),
             OnCloseFrameWritten);
  }",20,,430,1,,void
97229,BLOCK,-1,,"{
    OnCloseSent = &WsHandler::OnEof;
    SendClose();
  }",29,,435,1,,void
97241,BLOCK,-1,,"{
    int bytes_consumed = 0;
    std::vector<char> output;
    bool compressed = false;

    ws_decode_result r =  decode_frame_hybi17(buffer,
                                              true /* client_frame */,
                                              &bytes_consumed, &output,
                                              &compressed);
    // Compressed frame means client is ignoring the headers and misbehaves
    if (compressed || r == FRAME_ERROR) {
      OnEof();
      bytes_consumed = 0;
    } else if (r == FRAME_CLOSE) {
      (this->*OnCloseReceived)();
      bytes_consumed = 0;
    } else if (r == FRAME_OK) {
      delegate()->OnWsFrame(output);
    }
    return bytes_consumed;
  }",54,,440,2,,void
97269,BLOCK,-1,,"{
      OnEof();
      bytes_consumed = 0;
    }",41,,450,2,,void
97275,BLOCK,-1,,<empty>,12,,453,1,,void
97280,BLOCK,-1,,"{
      (this->*OnCloseReceived)();
      bytes_consumed = 0;
    }",34,,453,2,,void
97289,BLOCK,-1,,<empty>,12,,456,1,,void
97294,BLOCK,-1,,"{
      delegate()->OnWsFrame(output);
    }",31,,456,2,,void
97314,BLOCK,-1,,{ },26,,474,6,,void
97326,BLOCK,-1,,"{
    llhttp_init(&parser_, HTTP_REQUEST, &parser_settings);
    llhttp_settings_init(&parser_settings);
    parser_settings.on_header_field = OnHeaderField;
    parser_settings.on_header_value = OnHeaderValue;
    parser_settings.on_message_complete = OnMessageComplete;
    parser_settings.on_url = OnPath;
  }",48,,487,3,,void
97360,BLOCK,-1,,"{
    char accept_string[ACCEPT_KEY_LENGTH];
    generate_accept_string(accept_key, &accept_string);
    const char accept_ws_prefix[] = ""HTTP/1.1 101 Switching Protocols\r\n""
                                    ""Upgrade: websocket\r\n""
                                    ""Connection: Upgrade\r\n""
                                    ""Sec-WebSocket-Accept: "";
    const char accept_ws_suffix[] = ""\r\n\r\n"";
    std::vector<char> reply(accept_ws_prefix,
                            accept_ws_prefix + sizeof(accept_ws_prefix) - 1);
    reply.insert(reply.end(), accept_string,
                 accept_string + sizeof(accept_string));
    reply.insert(reply.end(), accept_ws_suffix,
                 accept_ws_suffix + sizeof(accept_ws_suffix) - 1);
    if (WriteRaw(reply, WriteRequest::Cleanup) >= 0) {
      inspector_->SwitchProtocol(new WsHandler(inspector_, std::move(tcp_)));
    } else {
      tcp_.reset();
    }
  }",62,,496,2,,void
97419,BLOCK,-1,,"{
      inspector_->SwitchProtocol(new WsHandler(inspector_, std::move(tcp_)));
    }",54,,510,2,,void
97433,BLOCK,-1,,"{
      tcp_.reset();
    }",12,,512,1,,void
97441,BLOCK,-1,,"{
    const char HANDSHAKE_FAILED_RESPONSE[] =
        ""HTTP/1.0 400 Bad Request\r\n""
        ""Content-Type: text/html; charset=UTF-8\r\n\r\n""
        ""WebSockets request was expected\r\n"";
    WriteRaw(std::vector<char>(HANDSHAKE_FAILED_RESPONSE,
             HANDSHAKE_FAILED_RESPONSE + sizeof(HANDSHAKE_FAILED_RESPONSE) - 1),
             ThenCloseAndReportFailure);
  }",35,,517,1,,void
97462,BLOCK,-1,,"{
    tcp_.reset();
  }",25,,528,1,,void
97471,BLOCK,-1,,"{
    llhttp_errno_t err;
    err = llhttp_execute(&parser_, data->data(), data->size());

    if (err == HPE_PAUSED_UPGRADE) {
      err = HPE_OK;
      llhttp_resume_after_upgrade(&parser_);
    }
    data->clear();
    if (err != HPE_OK) {
      CancelHandshake();
    }
    // Event handling may delete *this
    std::vector<HttpEvent> events;
    std::swap(events, events_);
    for (const HttpEvent& event : events) {
      if (!IsAllowedHost(event.host) || !event.isGET) {
        CancelHandshake();
        return;
      } else if (!event.upgrade) {
        delegate()->OnHttpGet(event.host, event.path);
      } else if (event.ws_key.empty()) {
        CancelHandshake();
        return;
      } else {
        delegate()->OnSocketUpgrade(event.host, event.path, event.ws_key);
      }
    }
  }",49,,532,2,,void
97490,BLOCK,-1,,"{
      err = HPE_OK;
      llhttp_resume_after_upgrade(&parser_);
    }",36,,536,2,,void
97505,BLOCK,-1,,"{
      CancelHandshake();
    }",24,,541,2,,void
97517,BLOCK,-1,,"{
      if (!IsAllowedHost(event.host) || !event.isGET) {
        CancelHandshake();
        return;
      } else if (!event.upgrade) {
        delegate()->OnHttpGet(event.host, event.path);
      } else if (event.ws_key.empty()) {
        CancelHandshake();
        return;
      } else {
        delegate()->OnSocketUpgrade(event.host, event.path, event.ws_key);
      }
    }",43,,547,3,,void
97529,BLOCK,-1,,"{
        CancelHandshake();
        return;
      }",55,,548,2,,void
97533,BLOCK,-1,,<empty>,14,,551,1,,void
97539,BLOCK,-1,,"{
        delegate()->OnHttpGet(event.host, event.path);
      }",34,,551,2,,void
97551,BLOCK,-1,,<empty>,14,,553,1,,void
97559,BLOCK,-1,,"{
        CancelHandshake();
        return;
      }",40,,553,2,,void
97563,BLOCK,-1,,"{
        delegate()->OnSocketUpgrade(event.host, event.path, event.ws_key);
      }",14,,556,1,,void
97581,BLOCK,-1,,"{
    WriteRaw(data, WriteRequest::Cleanup);
  }",53,,562,2,,void
97590,BLOCK,-1,,"{
    delete this;
  }",28,,567,1,,void
97598,BLOCK,-1,,"{
    ProtocolHandler* handler = WriteRequest::from_write_req(req)->handler;
    WriteRequest::Cleanup(req, status);
    handler->inspector()->SwitchProtocol(nullptr);
  }",70,,572,3,,void
97629,BLOCK,-1,,"{
    HttpHandler* handler = From(parser);
    handler->parsing_value_ = true;
    handler->headers_[handler->current_header_].append(at, length);
    return 0;
  }",77,,578,4,,void
97660,BLOCK,-1,,"{
    HttpHandler* handler = From(parser);
    if (handler->parsing_value_) {
      handler->parsing_value_ = false;
      handler->current_header_.clear();
    }
    handler->current_header_.append(at, length);
    return 0;
  }",77,,585,4,,void
97670,BLOCK,-1,,"{
      handler->parsing_value_ = false;
      handler->current_header_.clear();
    }",34,,587,2,,void
97698,BLOCK,-1,,"{
    HttpHandler* handler = From(parser);
    handler->path_.append(at, length);
    return 0;
  }",70,,595,4,,void
97718,BLOCK,-1,,"{
    return node::ContainerOf(&HttpHandler::parser_, parser);
  }",46,,601,2,,void
97733,BLOCK,-1,,"{
    // Event needs to be fired after the parser is done.
    HttpHandler* handler = From(parser);
    handler->events_.emplace_back(handler->path_,
                                  parser->upgrade,
                                  parser->method == HTTP_GET,
                                  handler->HeaderValue(""Sec-WebSocket-Key""),
                                  handler->HeaderValue(""Host""));
    handler->path_ = """";
    handler->parsing_value_ = false;
    handler->headers_.clear();
    handler->current_header_ = """";
    return 0;
  }",50,,605,2,,void
97793,BLOCK,-1,,"{
    bool header_found = false;
    std::string value;
    for (const auto& header_value : headers_) {
      if (node::StringEqualNoCaseN(header_value.first.data(), header.data(),
                                   header.length())) {
        if (header_found)
          return """";
        value = header_value.second;
        header_found = true;
      }
    }
    return value;
  }",60,,620,2,,void
97802,BLOCK,-1,,"{
      if (node::StringEqualNoCaseN(header_value.first.data(), header.data(),
                                   header.length())) {
        if (header_found)
          return """";
        value = header_value.second;
        header_found = true;
      }
    }",47,,623,3,,void
97822,BLOCK,-1,,"{
        if (header_found)
          return """";
        value = header_value.second;
        header_found = true;
      }",54,,625,2,,void
97825,BLOCK,-1,,<empty>,11,,627,2,,void
97842,BLOCK,-1,,"{
    std::string host = TrimPort(host_with_port);
    return host.empty() || IsIPAddress(host)
           || node::StringEqualNoCase(host.data(), ""localhost"");
  }",63,,635,2,,void
97878,BLOCK,-1,,"{
  CHECK_NOT_NULL(tcp_);
  tcp_->SetHandler(this);
}",80,,655,3,,void
97891,BLOCK,-1,,"{
  return tcp_->WriteRaw(buffer, write_cb);
}",53,,661,3,,void
97902,BLOCK,-1,,"{
  return tcp_->delegate();
}",56,,665,1,,void
97911,BLOCK,-1,,"{
  char ip[INET6_ADDRSTRLEN];
  sockaddr_storage addr;
  int len = sizeof(addr);
  int err = uv_tcp_getsockname(tcp_->tcp(),
                               reinterpret_cast<struct sockaddr*>(&addr),
                               &len);
  if (err != 0)
    return """";
  if (addr.ss_family == AF_INET6) {
    const sockaddr_in6* v6 = reinterpret_cast<const sockaddr_in6*>(&addr);
    err = uv_ip6_name(v6, ip, sizeof(ip));
  } else {
    const sockaddr_in* v4 = reinterpret_cast<const sockaddr_in*>(&addr);
    err = uv_ip4_name(v4, ip, sizeof(ip));
  }
  if (err != 0)
    return """";
  return ip;
}",46,,669,1,,void
97937,BLOCK,-1,,<empty>,5,,677,2,,void
97946,BLOCK,-1,,"{
    const sockaddr_in6* v6 = reinterpret_cast<const sockaddr_in6*>(&addr);
    err = uv_ip6_name(v6, ip, sizeof(ip));
  }",35,,678,2,,void
97962,BLOCK,-1,,"{
    const sockaddr_in* v4 = reinterpret_cast<const sockaddr_in*>(&addr);
    err = uv_ip4_name(v4, ip, sizeof(ip));
  }",10,,681,1,,void
97981,BLOCK,-1,,<empty>,5,,686,2,,void
97990,BLOCK,-1,,{ },42,,694,2,,void
97996,BLOCK,-1,,"{
  TcpHolder* result = new TcpHolder(std::move(delegate));
  uv_stream_t* tcp = reinterpret_cast<uv_stream_t*>(&result->tcp_);
  int err = uv_tcp_init(server->loop, &result->tcp_);
  if (err == 0) {
    err = uv_accept(server, tcp);
  }
  if (err == 0) {
    err = uv_read_start(tcp, allocate_buffer, OnDataReceivedCb);
  }
  if (err == 0) {
    return TcpHolder::Pointer(result);
  } else {
    delete result;
    return nullptr;
  }
}",48,,699,3,,void
98031,BLOCK,-1,,"{
    err = uv_accept(server, tcp);
  }",17,,703,2,,void
98041,BLOCK,-1,,"{
    err = uv_read_start(tcp, allocate_buffer, OnDataReceivedCb);
  }",17,,706,2,,void
98052,BLOCK,-1,,"{
    return TcpHolder::Pointer(result);
  }",17,,709,2,,void
98060,BLOCK,-1,,"{
    delete result;
    return nullptr;
  }",10,,711,1,,void
98069,BLOCK,-1,,"{
  handler_ = handler;
}",54,,717,2,,void
98078,BLOCK,-1,,"{
#if DUMP_WRITES
  printf(""%s (%ld bytes):\n"", __FUNCTION__, buffer.size());
  dump_hex(buffer.data(), buffer.size());
  printf(""\n"");
#endif

  // Freed in write_request_cleanup
  WriteRequest* wr = new WriteRequest(handler_, buffer);
  uv_stream_t* stream = reinterpret_cast<uv_stream_t*>(&tcp_);
  int err = uv_write(&wr->req, stream, &wr->buf, 1, write_cb);
  if (err < 0)
    delete wr;
  return err < 0;
}",80,,721,3,,void
98112,BLOCK,-1,,<empty>,5,,733,2,,void
98122,BLOCK,-1,,"{
  return delegate_.get();
}",50,,737,1,,void
98132,BLOCK,-1,,"{
  delete From(handle);
}",47,,742,2,,void
98142,BLOCK,-1,,"{
#if DUMP_READS
  if (nread >= 0) {
    printf(""%s (%ld bytes)\n"", __FUNCTION__, nread);
    dump_hex(buf->base, nread);
  } else {
    printf(""[%s:%d] %s\n"", __FUNCTION__, __LINE__, uv_err_name(nread));
  }
#endif
  TcpHolder* holder = From(tcp);
  holder->ReclaimUvBuf(buf, nread);
  if (nread < 0 || nread == UV_EOF) {
    holder->handler_->OnEof();
  } else {
    holder->handler_->OnData(&holder->buffer);
  }
}",55,,747,4,,void
98162,BLOCK,-1,,"{
    holder->handler_->OnEof();
  }",37,,758,2,,void
98170,BLOCK,-1,,"{
    holder->handler_->OnData(&holder->buffer);
  }",10,,760,1,,void
98185,BLOCK,-1,,"{
  uv_handle_t* handle = reinterpret_cast<uv_handle_t*>(&holder->tcp_);
  uv_close(handle, OnClosed);
}",57,,766,2,,void
98203,BLOCK,-1,,"{
  if (read > 0) {
    buffer.insert(buffer.end(), buf->base, buf->base + read);
  }
  delete[] buf->base;
}",65,,771,3,,void
98208,BLOCK,-1,,"{
    buffer.insert(buffer.end(), buf->base, buf->base + read);
  }",17,,772,2,,void
98232,BLOCK,-1,,<empty>,,,,1,,<empty>
98237,BLOCK,-1,,"{
  handler->Shutdown();
}",58,,781,2,,void
98247,BLOCK,-1,,"{
  auto tcp = TcpHolder::Accept(server, std::move(delegate));
  if (tcp) {
    InspectorSocket* inspector = new InspectorSocket();
    inspector->SwitchProtocol(new HttpHandler(inspector, std::move(tcp)));
    return InspectorSocket::Pointer(inspector);
  } else {
    return InspectorSocket::Pointer(nullptr);
  }
}",76,,787,3,,void
98263,BLOCK,-1,,"{
    InspectorSocket* inspector = new InspectorSocket();
    inspector->SwitchProtocol(new HttpHandler(inspector, std::move(tcp)));
    return InspectorSocket::Pointer(inspector);
  }",12,,789,2,,void
98288,BLOCK,-1,,"{
    return InspectorSocket::Pointer(nullptr);
  }",10,,793,1,,void
98299,BLOCK,-1,,"{
  protocol_handler_->AcceptUpgrade(ws_key);
}",64,,798,2,,void
98308,BLOCK,-1,,"{
  protocol_handler_->CancelHandshake();
}",41,,802,1,,void
98316,BLOCK,-1,,"{
  return protocol_handler_->GetHost();
}",40,,806,1,,void
98326,BLOCK,-1,,"{
  protocol_handler_.reset(std::move(handler));
}",64,,810,2,,void
98341,BLOCK,-1,,"{
  protocol_handler_->Write(std::vector<char>(data, data + len));
}",59,,814,3,,void
98368,BLOCK,-1,,<empty>,1,,1,1,,ANY
98393,BLOCK,-1,,<empty>,1,,1,1,,ANY
98401,BLOCK,-1,,<empty>,,,,5,,<empty>
98411,BLOCK,-1,,"{
  for (char& c : *string) {
    c = (c == '\""' || c == '\\') ? '_' : c;
  }
}",34,,27,2,,void
98416,BLOCK,-1,,"{
    c = (c == '\""' || c == '\\') ? '_' : c;
  }",27,,28,3,,void
98434,BLOCK,-1,,"{
  // Host is valid (socket was bound) so colon means it's a v6 IP address
  bool v6 = host.find(':') != std::string::npos;
  std::ostringstream url;
  if (v6) {
    url << '[';
  }
  url << host;
  if (v6) {
    url << ']';
  }
  url << ':' << port;
  return url.str();
}",63,,33,3,,void
98452,BLOCK,-1,,"{
    url << '[';
  }",11,,37,2,,void
98461,BLOCK,-1,,"{
    url << ']';
  }",11,,41,2,,void
98481,BLOCK,-1,,"{
  std::ostringstream url;
  if (include_protocol)
    url << ""ws://"";
  url << host << '/' << target_id;
  return url.str();
}",50,,50,4,,void
98485,BLOCK,-1,,<empty>,5,,53,2,,void
98505,BLOCK,-1,,"{
  bool first = true;
  std::ostringstream json;
  json << ""{\n"";
  for (const auto& name_value : object) {
    if (!first)
      json << "",\n"";
    first = false;
    json << ""  \"""" << name_value.first << ""\"": \"""";
    json << name_value.second << ""\"""";
  }
  json << ""\n} "";
  return json.str();
}",75,,58,2,,void
98517,BLOCK,-1,,"{
    if (!first)
      json << "",\n"";
    first = false;
    json << ""  \"""" << name_value.first << ""\"": \"""";
    json << name_value.second << ""\"""";
  }",41,,62,3,,void
98521,BLOCK,-1,,<empty>,7,,64,2,,void
98556,BLOCK,-1,,"{
  bool first = true;
  std::ostringstream json;
  json << ""[ "";
  for (const auto& object : array) {
    if (!first)
      json << "", "";
    first = false;
    json << MapToString(object);
  }
  json << ""]\n\n"";
  return json.str();
}",67,,74,2,,void
98568,BLOCK,-1,,"{
    if (!first)
      json << "", "";
    first = false;
    json << MapToString(object);
  }",36,,78,3,,void
98572,BLOCK,-1,,<empty>,7,,80,2,,void
98596,BLOCK,-1,,"{
  size_t len = strlen(expected);
  if (StringEqualNoCaseN(path, expected, len)) {
    if (path[len] == '/') return path + len + 1;
    if (path[len] == '\0') return path + len;
  }
  return nullptr;
}",70,,88,3,,void
98607,BLOCK,-1,,"{
    if (path[len] == '/') return path + len + 1;
    if (path[len] == '\0') return path + len;
  }",48,,90,2,,void
98614,BLOCK,-1,,<empty>,27,,91,2,,void
98627,BLOCK,-1,,<empty>,28,,92,2,,void
98640,BLOCK,-1,,"{
  const char HEADERS[] = ""HTTP/1.0 %d OK\r\n""
                         ""Content-Type: application/json; charset=UTF-8\r\n""
                         ""Cache-Control: no-cache\r\n""
                         ""Content-Length: %zu\r\n""
                         ""\r\n"";
  char header[sizeof(HEADERS) + 20];
  int header_len = snprintf(header,
                            sizeof(header),
                            HEADERS,
                            code,
                            response.size());
  socket->Write(header, header_len);
  socket->Write(response.data(), response.size());
}",33,,99,4,,void
98681,BLOCK,-1,,"{
  std::map<std::string, std::string> response;
  response[""Browser""] = ""node.js/"" NODE_VERSION;
  response[""Protocol-Version""] = ""1.1"";
  SendHttpResponse(socket, MapToString(response), 200);
}",51,,115,2,,void
98714,BLOCK,-1,,"{
  SendHttpResponse(socket, """", 404);
}",48,,122,2,,void
98723,BLOCK,-1,,"{
  z_stream strm;
  strm.zalloc = Z_NULL;
  strm.zfree = Z_NULL;
  strm.opaque = Z_NULL;
  CHECK_EQ(Z_OK, inflateInit(&strm));
  static const size_t kDecompressedSize =
      PROTOCOL_JSON[0] * 0x10000u +
      PROTOCOL_JSON[1] * 0x100u +
      PROTOCOL_JSON[2];
  strm.next_in = const_cast<uint8_t*>(PROTOCOL_JSON + 3);
  strm.avail_in = sizeof(PROTOCOL_JSON) - 3;
  std::string data(kDecompressedSize, '\0');
  strm.next_out = reinterpret_cast<Byte*>(data.data());
  strm.avail_out = data.size();
  CHECK_EQ(Z_STREAM_END, inflate(&strm, Z_FINISH));
  CHECK_EQ(0, strm.avail_out);
  CHECK_EQ(Z_OK, inflateEnd(&strm));
  SendHttpResponse(socket, data, 200);
}",48,,126,2,,void
98829,BLOCK,-1,,"{
  return FormatAddress(FormatHostPort(host, port), target_id, include_protocol);
}",52,,150,5,,void
98844,BLOCK,-1,,<empty>,,,,4,,<empty>
98848,BLOCK,-1,,"{
    ws_socket_.reset();
  }",16,,157,1,,void
98857,BLOCK,-1,,<empty>,,,,2,,<empty>
98862,BLOCK,-1,,"{
    ws_socket_ = std::move(ws_socket);
  }",48,,161,2,,void
98873,BLOCK,-1,,{ return id_; },18,,164,1,,void
98879,BLOCK,-1,,"{
    return server_port_;
  }",21,,165,1,,void
98885,BLOCK,-1,,"{
    return ws_socket_.get();
  }",32,,168,1,,void
98895,BLOCK,-1,,"{
    ws_socket_->AcceptUpgrade(ws_key);
  }",42,,171,2,,void
98904,BLOCK,-1,,"{
    ws_socket_->CancelHandshake();
  }",18,,174,1,,void
98915,BLOCK,-1,,{ },57,,181,3,,void
98919,BLOCK,-1,,"{
      server_->SessionTerminated(session_id_);
    }",26,,182,1,,void
98930,BLOCK,-1,,<empty>,,,,3,,<empty>
98937,BLOCK,-1,,<empty>,,,,4,,<empty>
98942,BLOCK,-1,,<empty>,,,,2,,<empty>
98946,BLOCK,-1,,"{
      return server_->Session(session_id_);
    }",30,,191,1,,void
98963,BLOCK,-1,,<empty>,68,,208,2,,void
98969,BLOCK,-1,,<empty>,,,,3,,<empty>
98973,BLOCK,-1,,"{
    uv_close(reinterpret_cast<uv_handle_t*>(&tcp_socket_), FreeOnCloseCallback);
  }",16,,210,1,,void
98983,BLOCK,-1,,{ return port_; },20,,213,1,,void
98990,BLOCK,-1,,"{
    return node::ContainerOf(&ServerSocket::tcp_socket_,
                             reinterpret_cast<uv_tcp_t*>(socket));
  }",56,,217,2,,void
99008,BLOCK,-1,,<empty>,,,,3,,<empty>
99013,BLOCK,-1,,"{
    delete FromTcpSocket(tcp_socket_);
  }",61,,222,2,,void
99020,BLOCK,-1,,<empty>,,,,1,,<empty>
99024,BLOCK,-1,,<empty>,,,,1,,<empty>
99031,BLOCK,-1,,<empty>,,,,1,,<empty>
99045,BLOCK,-1,,"{
  if (!publish_uid_stderr || out == nullptr) {
    return;
  }
  for (const auto& server_socket : server_sockets) {
    for (const std::string& id : ids) {
      fprintf(out, ""Debugger %s on %s\n"",
              verb,
              FormatWsAddress(host, server_socket->port(), id, true).c_str());
    }
  }
  fprintf(out, ""For help, see: %s\n"",
          ""https://nodejs.org/en/docs/inspector"");
  fflush(out);
}",16,,239,7,,void
99053,BLOCK,-1,,"{
    return;
  }",46,,240,2,,void
99058,BLOCK,-1,,"{
    for (const std::string& id : ids) {
      fprintf(out, ""Debugger %s on %s\n"",
              verb,
              FormatWsAddress(host, server_socket->port(), id, true).c_str());
    }
  }",52,,243,3,,void
99062,BLOCK,-1,,"{
      fprintf(out, ""Debugger %s on %s\n"",
              verb,
              FormatWsAddress(host, server_socket->port(), id, true).c_str());
    }",39,,244,3,,void
99093,BLOCK,-1,,"{
  delegate_->AssignServer(this);
  state_ = ServerState::kNew;
}",17,,265,7,,void
99107,BLOCK,-1,,<empty>,,,,1,,<empty>
99112,BLOCK,-1,,"{
  auto it = connected_sessions_.find(session_id);
  return it == connected_sessions_.end() ? nullptr : it->second.second.get();
}",63,,272,2,,void
99144,BLOCK,-1,,"{
  SocketSession* session = Session(session_id);
  if (!TargetExists(id)) {
    session->Decline();
    return;
  }
  connected_sessions_[session_id].first = id;
  session->Accept(ws_key);
  delegate_->StartSession(session_id, id);
}",71,,279,4,,void
99154,BLOCK,-1,,"{
    session->Decline();
    return;
  }",26,,281,2,,void
99182,BLOCK,-1,,"{
  if (Session(session_id) == nullptr) {
    return;
  }
  bool was_attached = connected_sessions_[session_id].first != """";
  if (was_attached) {
    delegate_->EndSession(session_id);
  }
  connected_sessions_.erase(session_id);
  if (connected_sessions_.empty()) {
    if (was_attached && state_ == ServerState::kRunning
        && !server_sockets_.empty()) {
      PrintDebuggerReadyMessage(host_,
                                server_sockets_,
                                delegate_->GetTargetIds(),
                                ""ending"",
                                inspect_publish_uid_.console,
                                out_);
    }
    if (state_ == ServerState::kStopped) {
      delegate_.reset();
    }
  }
}",63,,290,2,,void
99188,BLOCK,-1,,"{
    return;
  }",39,,291,2,,void
99202,BLOCK,-1,,"{
    delegate_->EndSession(session_id);
  }",21,,295,2,,void
99218,BLOCK,-1,,"{
    if (was_attached && state_ == ServerState::kRunning
        && !server_sockets_.empty()) {
      PrintDebuggerReadyMessage(host_,
                                server_sockets_,
                                delegate_->GetTargetIds(),
                                ""ending"",
                                inspect_publish_uid_.console,
                                out_);
    }
    if (state_ == ServerState::kStopped) {
      delegate_.reset();
    }
  }",36,,299,2,,void
99233,BLOCK,-1,,"{
      PrintDebuggerReadyMessage(host_,
                                server_sockets_,
                                delegate_->GetTargetIds(),
                                ""ending"",
                                inspect_publish_uid_.console,
                                out_);
    }",38,,301,2,,void
99252,BLOCK,-1,,"{
      delegate_.reset();
    }",42,,309,2,,void
99263,BLOCK,-1,,"{
  SocketSession* session = Session(session_id);
  InspectorSocket* socket = session->ws_socket();
  if (!inspect_publish_uid_.http) {
    SendHttpNotFound(socket);
    return true;
  }
  const char* command = MatchPathSegment(path.c_str(), ""/json"");
  if (command == nullptr)
    return false;

  if (MatchPathSegment(command, ""list"") || command[0] == '\0') {
    SendListResponse(socket, host, session);
    return true;
  } else if (MatchPathSegment(command, ""protocol"")) {
    SendProtocolJson(socket);
    return true;
  } else if (MatchPathSegment(command, ""version"")) {
    SendVersionResponse(socket);
    return true;
  }
  return false;
}",71,,317,4,,void
99281,BLOCK,-1,,"{
    SendHttpNotFound(socket);
    return true;
  }",35,,320,2,,void
99299,BLOCK,-1,,<empty>,5,,326,2,,void
99312,BLOCK,-1,,"{
    SendListResponse(socket, host, session);
    return true;
  }",64,,328,2,,void
99320,BLOCK,-1,,<empty>,10,,331,1,,void
99325,BLOCK,-1,,"{
    SendProtocolJson(socket);
    return true;
  }",53,,331,2,,void
99331,BLOCK,-1,,<empty>,10,,334,1,,void
99336,BLOCK,-1,,"{
    SendVersionResponse(socket);
    return true;
  }",52,,334,2,,void
99349,BLOCK,-1,,"{
  std::vector<std::map<std::string, std::string>> response;
  for (const std::string& id : delegate_->GetTargetIds()) {
    response.push_back(std::map<std::string, std::string>());
    std::map<std::string, std::string>& target_map = response.back();
    target_map[""description""] = ""node.js instance"";
    target_map[""faviconUrl""] =
                        ""https://nodejs.org/static/images/favicons/favicon.ico"";
    target_map[""id""] = id;
    target_map[""title""] = delegate_->GetTargetTitle(id);
    Escape(&target_map[""title""]);
    target_map[""type""] = ""node"";
    // This attribute value is a ""best effort"" URL that is passed as a JSON
    // string. It is not guaranteed to resolve to a valid resource.
    target_map[""url""] = delegate_->GetTargetUrl(id);
    Escape(&target_map[""url""]);

    std::string detected_host = host;
    if (detected_host.empty()) {
      detected_host = FormatHostPort(socket->GetHost(),
                                     session->server_port());
    }
   ...",70,,343,4,,void
99357,BLOCK,-1,,"{
    response.push_back(std::map<std::string, std::string>());
    std::map<std::string, std::string>& target_map = response.back();
    target_map[""description""] = ""node.js instance"";
    target_map[""faviconUrl""] =
                        ""https://nodejs.org/static/images/favicons/favicon.ico"";
    target_map[""id""] = id;
    target_map[""title""] = delegate_->GetTargetTitle(id);
    Escape(&target_map[""title""]);
    target_map[""type""] = ""node"";
    // This attribute value is a ""best effort"" URL that is passed as a JSON
    // string. It is not guaranteed to resolve to a valid resource.
    target_map[""url""] = delegate_->GetTargetUrl(id);
    Escape(&target_map[""url""]);

    std::string detected_host = host;
    if (detected_host.empty()) {
      detected_host = FormatHostPort(socket->GetHost(),
                                     session->server_port());
    }
    std::string formatted_address = FormatAddress(detected_host, id, false);
    target_map[""devtoolsFrontendUrl""] = GetFro...",59,,345,3,,void
99438,BLOCK,-1,,"{
      detected_host = FormatHostPort(socket->GetHost(),
                                     session->server_port());
    }",32,,361,2,,void
99489,BLOCK,-1,,"{
  std::ostringstream frontend_url;
  frontend_url << ""devtools://devtools/bundled/"";
  frontend_url << (is_compat ? ""inspector"" : ""js_app"");
  frontend_url << "".html?experiments=true&v8only=true&ws="";
  frontend_url << formatted_address;
  return frontend_url.str();
}",43,,377,3,,void
99514,BLOCK,-1,,"{
  CHECK_NOT_NULL(delegate_);
  CHECK_EQ(state_, ServerState::kNew);
  std::unique_ptr<SocketServerDelegate> delegate_holder;
  // We will return it if startup is successful
  delegate_.swap(delegate_holder);
  struct addrinfo hints;
  memset(&hints, 0, sizeof(hints));
  hints.ai_flags = AI_NUMERICSERV;
  hints.ai_socktype = SOCK_STREAM;
  uv_getaddrinfo_t req;
  const std::string port_string = std::to_string(port_);
  int err = uv_getaddrinfo(loop_, &req, nullptr, host_.c_str(),
                           port_string.c_str(), &hints);
  if (err < 0) {
    if (out_ != nullptr) {
      fprintf(out_, ""Unable to resolve \""%s\"": %s\n"", host_.c_str(),
              uv_strerror(err));
    }
    return false;
  }
  for (addrinfo* address = req.addrinfo; address != nullptr;
       address = address->ai_next) {
    auto server_socket = ServerSocketPtr(new ServerSocket(this));
    err = server_socket->Listen(address->ai_addr, loop_);
    if (err == 0)
      server_sockets_.push_back(std::mov...",37,,386,1,,void
99581,BLOCK,-1,,"{
    if (out_ != nullptr) {
      fprintf(out_, ""Unable to resolve \""%s\"": %s\n"", host_.c_str(),
              uv_strerror(err));
    }
    return false;
  }",16,,400,2,,void
99586,BLOCK,-1,,"{
      fprintf(out_, ""Unable to resolve \""%s\"": %s\n"", host_.c_str(),
              uv_strerror(err));
    }",26,,401,2,,void
99599,BLOCK,-1,,<empty>,3,,407,1,,void
99614,BLOCK,4,,"{
    auto server_socket = ServerSocketPtr(new ServerSocket(this));
    err = server_socket->Listen(address->ai_addr, loop_);
    if (err == 0)
      server_sockets_.push_back(std::move(server_socket));
  }",36,,408,4,,void
99636,BLOCK,-1,,<empty>,7,,412,2,,void
99655,BLOCK,-1,,"{
    if (out_ != nullptr) {
      fprintf(out_, ""Starting inspector on %s:%d failed: %s\n"",
              host_.c_str(), port_, uv_strerror(err));
      fflush(out_);
    }
    return false;
  }",32,,418,2,,void
99660,BLOCK,-1,,"{
      fprintf(out_, ""Starting inspector on %s:%d failed: %s\n"",
              host_.c_str(), port_, uv_strerror(err));
      fflush(out_);
    }",26,,419,2,,void
99701,BLOCK,-1,,"{
  if (state_ == ServerState::kStopped)
    return;
  CHECK_EQ(state_, ServerState::kRunning);
  state_ = ServerState::kStopped;
  server_sockets_.clear();
  if (done())
    delegate_.reset();
}",36,,437,1,,void
99708,BLOCK,-1,,<empty>,5,,439,2,,void
99726,BLOCK,-1,,<empty>,5,,444,2,,void
99734,BLOCK,-1,,"{
  for (const auto& key_value : connected_sessions_)
    key_value.second.second->Close();
}",52,,447,1,,void
99750,BLOCK,-1,,"{
  const std::vector<std::string>& target_ids = delegate_->GetTargetIds();
  const auto& found = std::find(target_ids.begin(), target_ids.end(), id);
  return found != target_ids.end();
}",65,,452,2,,void
99784,BLOCK,-1,,"{
  if (!server_sockets_.empty()) {
    return server_sockets_[0]->port();
  }
  return port_;
}",41,,458,1,,void
99791,BLOCK,-1,,"{
    return server_sockets_[0]->port();
  }",33,,459,2,,void
99806,BLOCK,-1,,"{
  std::unique_ptr<SocketSession> session(
      new SocketSession(this, next_session_id_++, server_port));

  InspectorSocket::DelegatePointer delegate =
      InspectorSocket::DelegatePointer(
          new SocketSession::Delegate(this, session->id()));

  InspectorSocket::Pointer inspector =
      InspectorSocket::Accept(server_socket, std::move(delegate));
  if (inspector) {
    session->Own(std::move(inspector));
    connected_sessions_[session->id()].second = std::move(session);
  }
}",64,,466,3,,void
99849,BLOCK,-1,,"{
    session->Own(std::move(inspector));
    connected_sessions_[session->id()].second = std::move(session);
  }",18,,476,2,,void
99878,BLOCK,-1,,"{
  SocketSession* session = Session(session_id);
  if (session != nullptr) {
    session->Send(message);
  }
}",78,,482,3,,void
99888,BLOCK,-1,,"{
    session->Send(message);
  }",27,,484,2,,void
99898,BLOCK,-1,,"{
  server->Close();
}",69,,489,2,,void
99909,BLOCK,-1,,<empty>,42,,496,4,,void
99914,BLOCK,-1,,"{
  ws_socket_->Write(message.data(), message.length());
}",54,,498,2,,void
99932,BLOCK,-1,,"{
  if (!server_->HandleGetRequest(session_id_, host, path))
    Session()->ws_socket()->CancelHandshake();
}",66,,503,3,,void
99942,BLOCK,-1,,<empty>,5,,505,2,,void
99956,BLOCK,-1,,"{
  std::string id = path.empty() ? path : path.substr(1);
  server_->SessionStarted(session_id_, id, ws_key);
}",74,,510,4,,void
99982,BLOCK,-1,,"{
  server_->MessageReceived(session_id_,
                           std::string(data.data(), data.size()));
}",72,,515,2,,void
100003,BLOCK,-1,,"{
  sockaddr_storage addr;
  int len = sizeof(addr);
  int err = uv_tcp_getsockname(&tcp_socket_,
                               reinterpret_cast<struct sockaddr*>(&addr), &len);
  if (err != 0)
    return err;
  int port;
  if (addr.ss_family == AF_INET6)
    port = reinterpret_cast<const sockaddr_in6*>(&addr)->sin6_port;
  else
    port = reinterpret_cast<const sockaddr_in*>(&addr)->sin_port;
  port_ = ntohs(port);
  return err;
}",32,,521,1,,void
100026,BLOCK,-1,,<empty>,5,,527,2,,void
100036,BLOCK,-1,,<empty>,5,,530,2,,void
100046,BLOCK,-1,,<empty>,5,,532,1,,void
100066,BLOCK,-1,,"{
  uv_tcp_t* server = &tcp_socket_;
  CHECK_EQ(0, uv_tcp_init(loop, server));
  int err = uv_tcp_bind(server, addr, 0);
  if (err == 0) {
    // 511 is the value used by a 'net' module by default
    err = uv_listen(reinterpret_cast<uv_stream_t*>(server), 511,
                    ServerSocket::SocketConnectedCallback);
  }
  if (err == 0) {
    err = DetectPort();
  }
  return err;
}",59,,537,3,,void
100088,BLOCK,-1,,"{
    // 511 is the value used by a 'net' module by default
    err = uv_listen(reinterpret_cast<uv_stream_t*>(server), 511,
                    ServerSocket::SocketConnectedCallback);
  }",17,,541,2,,void
100103,BLOCK,-1,,"{
    err = DetectPort();
  }",17,,546,2,,void
100114,BLOCK,-1,,"{
  if (status == 0) {
    ServerSocket* server_socket = ServerSocket::FromTcpSocket(tcp_socket);
    // Memory is freed when the socket closes.
    server_socket->server_->Accept(server_socket->port_, tcp_socket);
  }
}",56,,554,3,,void
100119,BLOCK,-1,,"{
    ServerSocket* server_socket = ServerSocket::FromTcpSocket(tcp_socket);
    // Memory is freed when the socket closes.
    server_socket->server_->Accept(server_socket->port_, tcp_socket);
  }",20,,555,2,,void
100156,BLOCK,-1,,<empty>,1,,1,1,,ANY
100167,BLOCK,-1,,<empty>,1,,1,1,,ANY
100171,BLOCK,-1,,<empty>,,,,3,,<empty>
100177,BLOCK,-1,,<empty>,,,,3,,<empty>
100183,BLOCK,-1,,<empty>,,,,3,,<empty>
100189,BLOCK,-1,,<empty>,,,,3,,<empty>
100196,BLOCK,-1,,<empty>,,,,4,,<empty>
100202,BLOCK,-1,,<empty>,,,,3,,<empty>
100208,BLOCK,-1,,<empty>,,,,3,,<empty>
100215,BLOCK,-1,,<empty>,,,,4,,<empty>
100222,BLOCK,-1,,<empty>,,,,4,,<empty>
100229,BLOCK,-1,,<empty>,,,,4,,<empty>
100236,BLOCK,-1,,<empty>,,,,4,,<empty>
100243,BLOCK,-1,,<empty>,,,,4,,<empty>
100251,BLOCK,-1,,<empty>,,,,5,,<empty>
100259,BLOCK,-1,,<empty>,,,,5,,<empty>
100267,BLOCK,-1,,<empty>,,,,5,,<empty>
100274,BLOCK,-1,,<empty>,,,,4,,<empty>
100284,BLOCK,-1,,<empty>,,,,7,,<empty>
100292,BLOCK,-1,,<empty>,,,,5,,<empty>
100300,BLOCK,-1,,<empty>,,,,5,,<empty>
100308,BLOCK,-1,,<empty>,,,,5,,<empty>
100315,BLOCK,-1,,<empty>,,,,4,,<empty>
100322,BLOCK,-1,,<empty>,,,,4,,<empty>
100329,BLOCK,-1,,<empty>,,,,4,,<empty>
100336,BLOCK,-1,,<empty>,,,,4,,<empty>
100343,BLOCK,-1,,<empty>,,,,4,,<empty>
100350,BLOCK,-1,,<empty>,,,,4,,<empty>
100359,BLOCK,-1,,<empty>,,,,6,,<empty>
100368,BLOCK,-1,,<empty>,,,,6,,<empty>
100377,BLOCK,-1,,<empty>,,,,6,,<empty>
100384,BLOCK,-1,,<empty>,,,,4,,<empty>
100391,BLOCK,-1,,<empty>,,,,4,,<empty>
100398,BLOCK,-1,,<empty>,,,,4,,<empty>
100405,BLOCK,-1,,<empty>,,,,4,,<empty>
100412,BLOCK,-1,,<empty>,,,,4,,<empty>
100419,BLOCK,-1,,<empty>,,,,4,,<empty>
100427,BLOCK,-1,,<empty>,,,,5,,<empty>
100435,BLOCK,-1,,<empty>,,,,5,,<empty>
100443,BLOCK,-1,,<empty>,,,,5,,<empty>
100451,BLOCK,-1,,<empty>,,,,5,,<empty>
100459,BLOCK,-1,,<empty>,,,,5,,<empty>
100467,BLOCK,-1,,<empty>,,,,5,,<empty>
100475,BLOCK,-1,,<empty>,,,,5,,<empty>
100483,BLOCK,-1,,<empty>,,,,5,,<empty>
100491,BLOCK,-1,,<empty>,,,,5,,<empty>
100499,BLOCK,-1,,<empty>,,,,5,,<empty>
100507,BLOCK,-1,,<empty>,,,,5,,<empty>
100515,BLOCK,-1,,<empty>,,,,5,,<empty>
100523,BLOCK,-1,,<empty>,,,,5,,<empty>
100530,BLOCK,-1,,<empty>,,,,4,,<empty>
100537,BLOCK,-1,,<empty>,,,,4,,<empty>
100545,BLOCK,-1,,<empty>,,,,5,,<empty>
100555,BLOCK,-1,,<empty>,,,,7,,<empty>
100564,BLOCK,-1,,<empty>,,,,6,,<empty>
100572,BLOCK,-1,,<empty>,,,,5,,<empty>
100582,BLOCK,-1,,<empty>,,,,7,,<empty>
100589,BLOCK,-1,,<empty>,,,,4,,<empty>
100601,BLOCK,-1,,<empty>,,,,9,,<empty>
100611,BLOCK,-1,,<empty>,,,,7,,<empty>
100618,BLOCK,-1,,<empty>,,,,4,,<empty>
100625,BLOCK,-1,,<empty>,,,,4,,<empty>
100634,BLOCK,-1,,<empty>,,,,6,,<empty>
100641,BLOCK,-1,,<empty>,,,,4,,<empty>
100649,BLOCK,-1,,<empty>,,,,5,,<empty>
100655,BLOCK,-1,,<empty>,,,,3,,<empty>
100662,BLOCK,-1,,<empty>,,,,4,,<empty>
100669,BLOCK,-1,,<empty>,,,,4,,<empty>
100676,BLOCK,-1,,<empty>,,,,4,,<empty>
100682,BLOCK,-1,,<empty>,,,,3,,<empty>
100688,BLOCK,-1,,<empty>,,,,3,,<empty>
100694,BLOCK,-1,,<empty>,,,,3,,<empty>
100700,BLOCK,-1,,<empty>,,,,3,,<empty>
100708,BLOCK,-1,,<empty>,,,,5,,<empty>
100714,BLOCK,-1,,<empty>,,,,3,,<empty>
100721,BLOCK,-1,,<empty>,,,,4,,<empty>
100728,BLOCK,-1,,<empty>,,,,4,,<empty>
100735,BLOCK,-1,,<empty>,,,,4,,<empty>
100742,BLOCK,-1,,<empty>,,,,4,,<empty>
100748,BLOCK,-1,,<empty>,,,,3,,<empty>
100754,BLOCK,-1,,<empty>,,,,3,,<empty>
100761,BLOCK,-1,,<empty>,,,,4,,<empty>
100769,BLOCK,-1,,<empty>,,,,5,,<empty>
100779,BLOCK,-1,,<empty>,,,,7,,<empty>
100787,BLOCK,-1,,<empty>,,,,5,,<empty>
100794,BLOCK,-1,,<empty>,,,,4,,<empty>
100804,BLOCK,-1,,<empty>,,,,7,,<empty>
100815,BLOCK,-1,,<empty>,,,,8,,<empty>
100824,BLOCK,-1,,<empty>,,,,6,,<empty>
100831,BLOCK,-1,,<empty>,,,,4,,<empty>
100841,BLOCK,-1,,<empty>,,,,7,,<empty>
100847,BLOCK,-1,,<empty>,,,,3,,<empty>
100854,BLOCK,-1,,<empty>,,,,4,,<empty>
100861,BLOCK,-1,,<empty>,,,,4,,<empty>
100868,BLOCK,-1,,<empty>,,,,4,,<empty>
100875,BLOCK,-1,,<empty>,,,,4,,<empty>
100882,BLOCK,-1,,<empty>,,,,4,,<empty>
100889,BLOCK,-1,,<empty>,,,,4,,<empty>
100896,BLOCK,-1,,<empty>,,,,4,,<empty>
100903,BLOCK,-1,,<empty>,,,,4,,<empty>
100910,BLOCK,-1,,<empty>,,,,4,,<empty>
100920,BLOCK,-1,,<empty>,,,,7,,<empty>
100927,BLOCK,-1,,<empty>,,,,4,,<empty>
100934,BLOCK,-1,,<empty>,,,,4,,<empty>
100943,BLOCK,-1,,<empty>,,,,6,,<empty>
100951,BLOCK,-1,,<empty>,,,,5,,<empty>
100959,BLOCK,-1,,<empty>,,,,5,,<empty>
100968,BLOCK,-1,,<empty>,,,,6,,<empty>
100978,BLOCK,-1,,<empty>,,,,7,,<empty>
100986,BLOCK,-1,,<empty>,,,,5,,<empty>
100992,BLOCK,-1,,<empty>,,,,3,,<empty>
100998,BLOCK,-1,,<empty>,,,,3,,<empty>
101005,BLOCK,-1,,<empty>,,,,4,,<empty>
101012,BLOCK,-1,,<empty>,,,,4,,<empty>
101020,BLOCK,-1,,<empty>,,,,5,,<empty>
101026,BLOCK,-1,,<empty>,,,,3,,<empty>
101032,BLOCK,-1,,<empty>,,,,3,,<empty>
101043,BLOCK,-1,,<empty>,1,,1,1,,ANY
101065,BLOCK,-1,,<empty>,,,,1,,<empty>
101145,BLOCK,-1,,<empty>,,,,3,,<empty>
101152,BLOCK,-1,,<empty>,,,,4,,<empty>
101174,BLOCK,-1,,"{ result = cb(env, cbinfo_wrapper); }",43,,314,2,,void
101190,BLOCK,-1,,"{
                          exceptionOccurred = true;
                          if (env->terminatedOrTerminating()) {
                            return;
                          }
                          env->isolate->ThrowException(value);
                        }",71,,315,3,,void
101199,BLOCK,-1,,"{
                            return;
                          }",63,,317,2,,void
101229,BLOCK,-1,,<empty>,1,,1,1,,ANY
101236,BLOCK,-1,,"{
  if (p->utf8name != nullptr) {
    CHECK_NEW_FROM_UTF8(env, *result, p->utf8name);
  } else {
    v8::Local<v8::Value> property_value =
        v8impl::V8LocalValueFromJsValue(p->name);

    RETURN_STATUS_IF_FALSE(env, property_value->IsName(), napi_name_expected);
    *result = property_value.As<v8::Name>();
  }

  return napi_ok;
}",34,,67,4,,void
101243,BLOCK,-1,,"{
    CHECK_NEW_FROM_UTF8(env, *result, p->utf8name);
  }",31,,68,2,,void
101252,BLOCK,1,,<empty>,,,,6,,void
101254,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, *result, p->utf8name)",5,,69,1,,void
101264,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, *result, p->utf8name)",5,,69,1,,void
101274,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, *result, p->utf8name)",5,,69,2,,void
101281,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, *result, p->utf8name)",5,,69,1,,void
101289,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, *result, p->utf8name)",5,,69,2,,void
101319,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, *result, p->utf8name)",5,,69,1,,void
101327,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, *result, p->utf8name)",5,,69,2,,void
101342,BLOCK,-1,,"{
    v8::Local<v8::Value> property_value =
        v8impl::V8LocalValueFromJsValue(p->name);

    RETURN_STATUS_IF_FALSE(env, property_value->IsName(), napi_name_expected);
    *result = property_value.As<v8::Name>();
  }",10,,70,1,,void
101367,BLOCK,1,,<empty>,,,,4,,void
101369,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, property_value->IsName(), napi_name_expected)",5,,74,1,,void
101376,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, property_value->IsName(), napi_name_expected)",5,,74,2,,void
101395,BLOCK,-1,,"{
  unsigned int attribute_flags = v8::PropertyAttribute::None;

  // The napi_writable attribute is ignored for accessor descriptors, but
  // V8 would throw `TypeError`s on assignment with nonexistence of a setter.
  if ((descriptor->getter == nullptr && descriptor->setter == nullptr) &&
      (descriptor->attributes & napi_writable) == 0) {
    attribute_flags |= v8::PropertyAttribute::ReadOnly;
  }

  if ((descriptor->attributes & napi_enumerable) == 0) {
    attribute_flags |= v8::PropertyAttribute::DontEnum;
  }
  if ((descriptor->attributes & napi_configurable) == 0) {
    attribute_flags |= v8::PropertyAttribute::DontDelete;
  }

  return static_cast<v8::PropertyAttribute>(attribute_flags);
}",49,,83,2,,void
101424,BLOCK,-1,,"{
    attribute_flags |= v8::PropertyAttribute::ReadOnly;
  }",54,,89,2,,void
101440,BLOCK,-1,,"{
    attribute_flags |= v8::PropertyAttribute::DontEnum;
  }",56,,93,2,,void
101456,BLOCK,-1,,"{
    attribute_flags |= v8::PropertyAttribute::DontDelete;
  }",58,,96,2,,void
101472,BLOCK,-1,,"{
  return reinterpret_cast<napi_deferred>(local);
}",43,,104,2,,void
101481,BLOCK,-1,,"{
  return reinterpret_cast<v8impl::Persistent<v8::Value>*>(local);
}",26,,109,2,,void
101491,BLOCK,-1,,<empty>,70,,115,2,,void
101498,BLOCK,-1,,<empty>,47,,129,2,,void
101502,BLOCK,-1,,{ return escape_called_; },30,,130,1,,void
101509,BLOCK,-1,,"{
    escape_called_ = true;
    return scope.Escape(handle);
  }",44,,132,2,,void
101525,BLOCK,-1,,"{
  return reinterpret_cast<napi_handle_scope>(s);
}",80,,142,2,,void
101534,BLOCK,-1,,"{
  return reinterpret_cast<HandleScopeWrapper*>(s);
}",80,,146,2,,void
101543,BLOCK,-1,,"{
  return reinterpret_cast<napi_escapable_handle_scope>(s);
}",37,,152,2,,void
101552,BLOCK,-1,,"{
  return reinterpret_cast<EscapableHandleScopeWrapper*>(s);
}",36,,158,2,,void
101564,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();
  v8impl::Persistent<v8::Value>* deferred_ref =
      NodePersistentFromJsDeferred(deferred);
  v8::Local<v8::Value> v8_deferred =
      v8::Local<v8::Value>::New(env->isolate, *deferred_ref);

  auto v8_resolver = v8_deferred.As<v8::Promise::Resolver>();

  v8::Maybe<bool> success =
      is_resolved ? v8_resolver->Resolve(
                        context, v8impl::V8LocalValueFromJsValue(result))
                  : v8_resolver->Reject(
                        context, v8impl::V8LocalValueFromJsValue(result));

  delete deferred_ref;

  RETURN_STATUS_IF_FALSE(env, success.FromMaybe(false), napi_generic_failure);

  return GET_RETURN_STATUS(env);
}",55,,165,5,,void
101567,BLOCK,1,,<empty>,,,,2,,void
101569,BLOCK,-1,,NAPI_PREAMBLE(env),3,,166,1,,void
101574,BLOCK,-1,,NAPI_PREAMBLE(env),3,,166,2,,void
101579,BLOCK,-1,,NAPI_PREAMBLE(env),3,,166,1,,void
101593,BLOCK,-1,,NAPI_PREAMBLE(env),3,,166,2,,void
101607,BLOCK,1,,<empty>,,,,3,,void
101609,BLOCK,-1,,"CHECK_ARG(env, result)",3,,167,1,,void
101615,BLOCK,-1,,"CHECK_ARG(env, result)",3,,167,2,,void
101709,BLOCK,1,,<empty>,,,,5,,void
101711,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, success.FromMaybe(false), napi_generic_failure)",3,,185,1,,void
101719,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, success.FromMaybe(false), napi_generic_failure)",3,,185,2,,void
101728,BLOCK,1,,<empty>,,,,3,,void
101749,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, js_object);
  if (action == KeepWrap) {
    CHECK_ARG(env, result);
  }

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(js_object);
  RETURN_STATUS_IF_FALSE(env, value->IsObject(), napi_invalid_arg);
  v8::Local<v8::Object> obj = value.As<v8::Object>();

  auto val = obj->GetPrivate(context, NAPI_PRIVATE_KEY(context, wrapper))
                 .ToLocalChecked();
  RETURN_STATUS_IF_FALSE(env, val->IsExternal(), napi_invalid_arg);
  Reference* reference =
      static_cast<v8impl::Reference*>(val.As<v8::External>()->Value());

  if (result) {
    *result = reference->Data();
  }

  if (action == RemoveWrap) {
    CHECK(obj->DeletePrivate(context, NAPI_PRIVATE_KEY(context, wrapper))
              .FromJust());
    if (reference->ownership() == Ownership::kUserland) {
      // When the wrap is been removed, the finalizer should be reset.
      reference->ResetFinalizer();
    } e...",48,,195,5,,void
101752,BLOCK,1,,<empty>,,,,2,,void
101754,BLOCK,-1,,NAPI_PREAMBLE(env),3,,196,1,,void
101759,BLOCK,-1,,NAPI_PREAMBLE(env),3,,196,2,,void
101764,BLOCK,-1,,NAPI_PREAMBLE(env),3,,196,1,,void
101778,BLOCK,-1,,NAPI_PREAMBLE(env),3,,196,2,,void
101792,BLOCK,1,,<empty>,,,,3,,void
101794,BLOCK,-1,,"CHECK_ARG(env, js_object)",3,,197,1,,void
101800,BLOCK,-1,,"CHECK_ARG(env, js_object)",3,,197,2,,void
101810,BLOCK,-1,,"{
    CHECK_ARG(env, result);
  }",27,,198,2,,void
101814,BLOCK,1,,<empty>,,,,3,,void
101816,BLOCK,-1,,"CHECK_ARG(env, result)",5,,199,1,,void
101822,BLOCK,-1,,"CHECK_ARG(env, result)",5,,199,2,,void
101864,BLOCK,1,,<empty>,,,,4,,void
101866,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsObject(), napi_invalid_arg)",3,,205,1,,void
101873,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsObject(), napi_invalid_arg)",3,,205,2,,void
101905,BLOCK,1,,<empty>,,,,2,,void
101924,BLOCK,1,,<empty>,,,,5,,void
101926,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsExternal(), napi_invalid_arg)",3,,210,1,,void
101933,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsExternal(), napi_invalid_arg)",3,,210,2,,void
101953,BLOCK,-1,,"{
    *result = reference->Data();
  }",15,,214,2,,void
101965,BLOCK,-1,,"{
    CHECK(obj->DeletePrivate(context, NAPI_PRIVATE_KEY(context, wrapper))
              .FromJust());
    if (reference->ownership() == Ownership::kUserland) {
      // When the wrap is been removed, the finalizer should be reset.
      reference->ResetFinalizer();
    } else {
      delete reference;
    }
  }",29,,218,2,,void
101976,BLOCK,1,,<empty>,,,,2,,void
101997,BLOCK,-1,,"{
      // When the wrap is been removed, the finalizer should be reset.
      reference->ResetFinalizer();
    }",57,,221,2,,void
102003,BLOCK,-1,,"{
      delete reference;
    }",12,,224,1,,void
102009,BLOCK,1,,<empty>,,,,3,,void
102027,BLOCK,-1,,"{
    CallbackBundle* bundle = new CallbackBundle();
    bundle->cb = cb;
    bundle->cb_data = data;
    bundle->env = env;

    v8::Local<v8::Value> cbdata = v8::External::New(env->isolate, bundle);
    Reference::New(
        env, cbdata, 0, Ownership::kRuntime, Delete, bundle, nullptr);
    return cbdata;
  }",54,,246,4,,void
102092,BLOCK,-1,,"{
    CallbackBundle* bundle = static_cast<CallbackBundle*>(data);
    delete bundle;
  }",60,,262,4,,void
102108,BLOCK,-1,,<empty>,65,,273,4,,void
102112,BLOCK,-1,,<empty>,,,,1,,<empty>
102118,BLOCK,-1,,<empty>,,,,3,,<empty>
102123,BLOCK,-1,,<empty>,,,,2,,<empty>
102127,BLOCK,-1,,{ return _this; },21,,279,1,,void
102133,BLOCK,-1,,{ return _args_length; },23,,281,1,,void
102139,BLOCK,-1,,{ return _data; },16,,283,1,,void
102150,BLOCK,-1,,"{
    _bundle = reinterpret_cast<CallbackBundle*>(
        cbinfo.Data().As<v8::External>()->Value());
    _data = _bundle->cb_data;
  }",25,,297,3,,void
102173,BLOCK,-1,,"{
    napi_callback_info cbinfo_wrapper = reinterpret_cast<napi_callback_info>(
        static_cast<CallbackWrapper*>(this));

    // All other pointers we need are stored in `_bundle`
    napi_env env = _bundle->env;
    napi_callback cb = _bundle->cb;

    napi_value result = nullptr;
    bool exceptionOccurred = false;
    env->CallIntoModule([&](napi_env env) { result = cb(env, cbinfo_wrapper); },
                        [&](napi_env env, v8::Local<v8::Value> value) {
                          exceptionOccurred = true;
                          if (env->terminatedOrTerminating()) {
                            return;
                          }
                          env->isolate->ThrowException(value);
                        });

    if (!exceptionOccurred && (result != nullptr)) {
      this->SetReturnValue(result);
    }
  }",32,,304,1,,void
102211,BLOCK,-1,,"{
      this->SetReturnValue(result);
    }",52,,323,2,,void
102224,BLOCK,-1,,"{
    FunctionCallbackWrapper cbwrapper(info);
    cbwrapper.InvokeCallback();
  }",71,,334,2,,void
102239,BLOCK,-1,,"{
    v8::Local<v8::Value> cbdata = v8impl::CallbackBundle::New(env, cb, cb_data);
    RETURN_STATUS_IF_FALSE(env, !cbdata.IsEmpty(), napi_generic_failure);

    v8::MaybeLocal<v8::Function> maybe_function =
        v8::Function::New(env->context(), Invoke, cbdata);
    CHECK_MAYBE_EMPTY(env, maybe_function, napi_generic_failure);

    *result = maybe_function.ToLocalChecked();
    return napi_clear_last_error(env);
  }",74,,342,5,,void
102267,BLOCK,1,,<empty>,,,,4,,void
102269,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, !cbdata.IsEmpty(), napi_generic_failure)",5,,344,1,,void
102277,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, !cbdata.IsEmpty(), napi_generic_failure)",5,,344,2,,void
102309,BLOCK,1,,<empty>,,,,4,,void
102311,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe_function, napi_generic_failure)",5,,348,1,,void
102319,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe_function, napi_generic_failure)",5,,348,2,,void
102343,BLOCK,-1,,"{
    v8::Local<v8::Value> cbdata = v8impl::CallbackBundle::New(env, cb, cb_data);
    RETURN_STATUS_IF_FALSE(env, !cbdata.IsEmpty(), napi_generic_failure);

    *result = v8::FunctionTemplate::New(env->isolate, Invoke, cbdata, sig);
    return napi_clear_last_error(env);
  }",66,,359,6,,void
102371,BLOCK,1,,<empty>,,,,4,,void
102373,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, !cbdata.IsEmpty(), napi_generic_failure)",5,,361,1,,void
102381,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, !cbdata.IsEmpty(), napi_generic_failure)",5,,361,2,,void
102409,BLOCK,-1,,<empty>,54,,369,2,,void
102413,BLOCK,-1,,"{
    if (_cbinfo.IsConstructCall()) {
      return v8impl::JsValueFromV8LocalValue(_cbinfo.NewTarget());
    } else {
      return nullptr;
    }
  }",38,,371,1,,void
102419,BLOCK,-1,,"{
      return v8impl::JsValueFromV8LocalValue(_cbinfo.NewTarget());
    }",36,,372,2,,void
102430,BLOCK,-1,,"{
      return nullptr;
    }",12,,374,1,,void
102438,BLOCK,-1,,"{
    size_t i = 0;
    size_t min = std::min(buffer_length, _args_length);

    for (; i < min; i += 1) {
      buffer[i] = v8impl::JsValueFromV8LocalValue(_cbinfo[i]);
    }

    if (i < buffer_length) {
      napi_value undefined =
          v8impl::JsValueFromV8LocalValue(v8::Undefined(_cbinfo.GetIsolate()));
      for (; i < buffer_length; i += 1) {
        buffer[i] = undefined;
      }
    }
  }",64,,380,3,,void
102453,BLOCK,-1,,<empty>,5,,384,1,,void
102460,BLOCK,4,,"{
      buffer[i] = v8impl::JsValueFromV8LocalValue(_cbinfo[i]);
    }",29,,384,4,,void
102476,BLOCK,-1,,"{
      napi_value undefined =
          v8impl::JsValueFromV8LocalValue(v8::Undefined(_cbinfo.GetIsolate()));
      for (; i < buffer_length; i += 1) {
        buffer[i] = undefined;
      }
    }",28,,388,2,,void
102493,BLOCK,-1,,<empty>,7,,391,1,,void
102500,BLOCK,4,,"{
        buffer[i] = undefined;
      }",41,,391,4,,void
102510,BLOCK,-1,,"{
    v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
    _cbinfo.GetReturnValue().Set(val);
  }",50,,398,2,,void
102543,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, js_object);

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(js_object);
  RETURN_STATUS_IF_FALSE(env, value->IsObject(), napi_invalid_arg);
  v8::Local<v8::Object> obj = value.As<v8::Object>();

  // If we've already wrapped this object, we error out.
  RETURN_STATUS_IF_FALSE(
      env,
      !obj->HasPrivate(context, NAPI_PRIVATE_KEY(context, wrapper)).FromJust(),
      napi_invalid_arg);

  v8impl::Reference* reference = nullptr;
  if (result != nullptr) {
    // The returned reference should be deleted via napi_delete_reference()
    // ONLY in response to the finalize callback invocation. (If it is deleted
    // before then, then the finalize callback will never be invoked.)
    // Therefore a finalize callback is required when returning a reference.
    CHECK_ARG(env, finalize_cb);
    reference = v8impl::Reference::New(env,
                                       obj,
...",43,,409,7,,void
102546,BLOCK,1,,<empty>,,,,2,,void
102548,BLOCK,-1,,NAPI_PREAMBLE(env),3,,410,1,,void
102553,BLOCK,-1,,NAPI_PREAMBLE(env),3,,410,2,,void
102558,BLOCK,-1,,NAPI_PREAMBLE(env),3,,410,1,,void
102572,BLOCK,-1,,NAPI_PREAMBLE(env),3,,410,2,,void
102586,BLOCK,1,,<empty>,,,,3,,void
102588,BLOCK,-1,,"CHECK_ARG(env, js_object)",3,,411,1,,void
102594,BLOCK,-1,,"CHECK_ARG(env, js_object)",3,,411,2,,void
102636,BLOCK,1,,<empty>,,,,4,,void
102638,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsObject(), napi_invalid_arg)",3,,416,1,,void
102645,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsObject(), napi_invalid_arg)",3,,416,2,,void
102668,BLOCK,1,,<empty>,,,,3,,void
102670,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(
      env,
      !obj->HasPrivate(context, NAPI_PRIVATE_KEY(context, wrapper)).FromJust(),
      napi_invalid_arg)",3,,420,1,,void
102692,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(
      env,
      !obj->HasPrivate(context, NAPI_PRIVATE_KEY(context, wrapper)).FromJust(),
      napi_invalid_arg)",3,,420,2,,void
102706,BLOCK,-1,,"{
    // The returned reference should be deleted via napi_delete_reference()
    // ONLY in response to the finalize callback invocation. (If it is deleted
    // before then, then the finalize callback will never be invoked.)
    // Therefore a finalize callback is required when returning a reference.
    CHECK_ARG(env, finalize_cb);
    reference = v8impl::Reference::New(env,
                                       obj,
                                       0,
                                       v8impl::Ownership::kUserland,
                                       finalize_cb,
                                       native_object,
                                       finalize_hint);
    *result = reinterpret_cast<napi_ref>(reference);
  }",26,,426,2,,void
102710,BLOCK,1,,<empty>,,,,3,,void
102712,BLOCK,-1,,"CHECK_ARG(env, finalize_cb)",5,,431,1,,void
102718,BLOCK,-1,,"CHECK_ARG(env, finalize_cb)",5,,431,2,,void
102750,BLOCK,-1,,"{
    // Create a self-deleting reference.
    reference = v8impl::Reference::New(
        env,
        obj,
        0,
        v8impl::Ownership::kRuntime,
        finalize_cb,
        native_object,
        finalize_cb == nullptr ? nullptr : finalize_hint);
  }",10,,440,1,,void
102785,BLOCK,1,,<empty>,,,,2,,void
102810,BLOCK,1,,<empty>,,,,3,,void
102825,BLOCK,-1,,"{
  return value->IsObject() || value->IsSymbol();
}",57,,468,2,,void
102839,BLOCK,-1,,"{
  finalize_callback_ = nullptr;
  finalize_data_ = nullptr;
  finalize_hint_ = nullptr;
}",34,,474,1,,void
102858,BLOCK,-1,,"{
  Link(finalize_callback == nullptr ? &env->reflist : &env->finalizing_reflist);
}",29,,489,7,,void
102875,BLOCK,-1,,"{
  // Remove from the env's tracked list.
  Unlink();
  // Try to remove the finalizer from the scheduled second pass callback.
  env_->DequeueFinalizer(this);
}",21,,495,1,,void
102891,BLOCK,-1,,"{
  return new RefBase(env,
                     initial_refcount,
                     ownership,
                     finalize_callback,
                     finalize_data,
                     finalize_hint);
}",44,,507,7,,void
102904,BLOCK,-1,,"{
  return finalize_data_;
}",23,,516,1,,void
102910,BLOCK,-1,,"{
  return ++refcount_;
}",25,,520,1,,void
102917,BLOCK,-1,,"{
  if (refcount_ == 0) {
    return 0;
  }
  return --refcount_;
}",27,,524,1,,void
102922,BLOCK,-1,,"{
    return 0;
  }",23,,525,2,,void
102931,BLOCK,-1,,"{
  return refcount_;
}",30,,531,1,,void
102937,BLOCK,-1,,"{
  Ownership ownership = ownership_;
  // Swap out the field finalize_callback so that it can not be accidentally
  // called more than once.
  napi_finalize finalize_callback = finalize_callback_;
  void* finalize_data = finalize_data_;
  void* finalize_hint = finalize_hint_;
  ResetFinalizer();

  // Either the RefBase is going to be deleted in the finalize_callback or not,
  // it should be removed from the tracked list.
  Unlink();
  // 1. If the finalize_callback is present, it should either delete the
  //    RefBase, or set ownership with Ownership::kRuntime.
  // 2. If the finalizer is not present, the RefBase can be deleted after the
  //    call.
  if (finalize_callback != nullptr) {
    env_->CallFinalizer(finalize_callback, finalize_data, finalize_hint);
    // No access to `this` after finalize_callback is called.
  }

  // If the RefBase is not Ownership::kRuntime, userland code should delete it.
  // Now delete it if it is Ownership::kRuntime.
  if (ownership == Owne...",26,,535,1,,void
102960,BLOCK,-1,,"{
    env_->CallFinalizer(finalize_callback, finalize_data, finalize_hint);
    // No access to `this` after finalize_callback is called.
  }",37,,551,2,,void
102974,BLOCK,-1,,"{
    delete this;
  }",41,,558,2,,void
102983,BLOCK,-1,,"{
  if (RefCount() == 0) {
    SetWeak();
  }
}",44,,567,4,,void
102988,BLOCK,-1,,"{
    SetWeak();
  }",24,,568,2,,void
102993,BLOCK,-1,,"{
  // Reset the handle. And no weak callback will be invoked.
  persistent_.Reset();
}",25,,573,1,,void
103008,BLOCK,-1,,"{
  return new Reference(env,
                       value,
                       initial_refcount,
                       ownership,
                       finalize_callback,
                       finalize_data,
                       finalize_hint);
}",48,,584,8,,void
103022,BLOCK,-1,,"{
  // When the persistent_ is cleared in the WeakCallback, and a second pass
  // callback is pending, return 0 unconditionally.
  if (persistent_.IsEmpty()) {
    return 0;
  }
  uint32_t refcount = RefBase::Ref();
  if (refcount == 1 && can_be_weak_) {
    persistent_.ClearWeak();
  }
  return refcount;
}",27,,594,1,,void
103028,BLOCK,-1,,"{
    return 0;
  }",30,,597,2,,void
103044,BLOCK,-1,,"{
    persistent_.ClearWeak();
  }",38,,601,2,,void
103054,BLOCK,-1,,"{
  // When the persistent_ is cleared in the WeakCallback, and a second pass
  // callback is pending, return 0 unconditionally.
  if (persistent_.IsEmpty()) {
    return 0;
  }
  uint32_t old_refcount = RefCount();
  uint32_t refcount = RefBase::Unref();
  if (old_refcount == 1 && refcount == 0) {
    SetWeak();
  }
  return refcount;
}",29,,607,1,,void
103060,BLOCK,-1,,"{
    return 0;
  }",30,,610,2,,void
103082,BLOCK,-1,,"{
    SetWeak();
  }",43,,615,2,,void
103089,BLOCK,-1,,"{
  if (persistent_.IsEmpty()) {
    return v8::Local<v8::Value>();
  } else {
    return v8::Local<v8::Value>::New(env_->isolate, persistent_);
  }
}",39,,621,1,,void
103095,BLOCK,-1,,"{
    return v8::Local<v8::Value>();
  }",30,,622,2,,void
103102,BLOCK,-1,,"{
    return v8::Local<v8::Value>::New(env_->isolate, persistent_);
  }",10,,624,1,,void
103123,BLOCK,-1,,"{
  // Unconditionally reset the persistent handle so that no weak callback will
  // be invoked again.
  persistent_.Reset();

  // Chain up to perform the rest of the finalization.
  RefBase::Finalize();
}",28,,629,1,,void
103135,BLOCK,-1,,"{
  if (can_be_weak_) {
    persistent_.SetWeak(this, WeakCallback, v8::WeakCallbackType::kParameter);
  } else {
    persistent_.Reset();
  }
}",27,,640,1,,void
103138,BLOCK,-1,,"{
    persistent_.SetWeak(this, WeakCallback, v8::WeakCallbackType::kParameter);
  }",21,,641,2,,void
103151,BLOCK,-1,,"{
    persistent_.Reset();
  }",10,,643,1,,void
103160,BLOCK,-1,,"{
  Reference* reference = data.GetParameter();
  // The reference must be reset during the weak callback as the API protocol.
  reference->persistent_.Reset();
  reference->env_->EnqueueFinalizer(reference);
}",75,,651,2,,void
103213,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  // The value of the constant below must be updated to reference the last
  // message in the `napi_status` enum each time a new error message is added.
  // We don't have a napi_status_last as this would result in an ABI
  // change each time a message was added.
  const int last_status = napi_no_external_buffers_allowed;

  static_assert(NAPI_ARRAYSIZE(error_messages) == last_status + 1,
                ""Count of error messages must match count of error values"");
  CHECK_LE(env->last_error.error_code, last_status);
  // Wait until someone requests the last error information to fetch the error
  // message string
  env->last_error.error_message = error_messages[env->last_error.error_code];

  if (env->last_error.error_code == napi_ok) {
    napi_clear_last_error(env);
  }
  *result = &(env->last_error);
  return napi_ok;
}",60,,688,3,,void
103216,BLOCK,1,,<empty>,,,,2,,void
103218,BLOCK,-1,,CHECK_ENV(env),3,,689,1,,void
103223,BLOCK,-1,,CHECK_ENV(env),3,,689,2,,void
103230,BLOCK,1,,<empty>,,,,3,,void
103232,BLOCK,-1,,"CHECK_ARG(env, result)",3,,690,1,,void
103238,BLOCK,-1,,"CHECK_ARG(env, result)",3,,690,2,,void
103252,BLOCK,1,,<empty>,,,,3,,void
103290,BLOCK,-1,,"{
    napi_clear_last_error(env);
  }",46,,705,2,,void
103311,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);
  CHECK_ARG(env, cb);

  v8::Local<v8::Function> return_value;
  v8::EscapableHandleScope scope(env->isolate);
  v8::Local<v8::Function> fn;
  STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
      env, cb, callback_data, &fn));
  return_value = scope.Escape(fn);

  if (utf8name != nullptr) {
    v8::Local<v8::String> name_string;
    CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length);
    return_value->SetName(name_string);
  }

  *result = v8impl::JsValueFromV8LocalValue(return_value);

  return GET_RETURN_STATUS(env);
}",65,,717,7,,void
103314,BLOCK,1,,<empty>,,,,2,,void
103316,BLOCK,-1,,NAPI_PREAMBLE(env),3,,718,1,,void
103321,BLOCK,-1,,NAPI_PREAMBLE(env),3,,718,2,,void
103326,BLOCK,-1,,NAPI_PREAMBLE(env),3,,718,1,,void
103340,BLOCK,-1,,NAPI_PREAMBLE(env),3,,718,2,,void
103354,BLOCK,1,,<empty>,,,,3,,void
103356,BLOCK,-1,,"CHECK_ARG(env, result)",3,,719,1,,void
103362,BLOCK,-1,,"CHECK_ARG(env, result)",3,,719,2,,void
103371,BLOCK,1,,<empty>,,,,3,,void
103373,BLOCK,-1,,"CHECK_ARG(env, cb)",3,,720,1,,void
103379,BLOCK,-1,,"CHECK_ARG(env, cb)",3,,720,2,,void
103410,BLOCK,1,,<empty>,,,,3,,void
103412,BLOCK,-1,,"STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
      env, cb, callback_data, &fn))",3,,725,1,,void
103431,BLOCK,-1,,<empty>,3,,725,2,,void
103446,BLOCK,-1,,"{
    v8::Local<v8::String> name_string;
    CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length);
    return_value->SetName(name_string);
  }",28,,729,2,,void
103462,BLOCK,1,,<empty>,,,,7,,void
103464,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",5,,731,1,,void
103474,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",5,,731,1,,void
103484,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",5,,731,2,,void
103491,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",5,,731,1,,void
103497,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",5,,731,2,,void
103525,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",5,,731,1,,void
103533,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",5,,731,2,,void
103562,BLOCK,1,,<empty>,,,,3,,void
103584,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);
  CHECK_ARG(env, constructor);

  if (property_count > 0) {
    CHECK_ARG(env, properties);
  }

  v8::Isolate* isolate = env->isolate;

  v8::EscapableHandleScope scope(isolate);
  v8::Local<v8::FunctionTemplate> tpl;
  STATUS_CALL(v8impl::FunctionCallbackWrapper::NewTemplate(
      env, constructor, callback_data, &tpl));

  v8::Local<v8::String> name_string;
  CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length);
  tpl->SetClassName(name_string);

  size_t static_property_count = 0;
  for (size_t i = 0; i < property_count; i++) {
    const napi_property_descriptor* p = properties + i;

    if ((p->attributes & napi_static) != 0) {
      // Static properties are handled separately below.
      static_property_count++;
      continue;
    }

    v8::Local<v8::Name> property_name;
    STATUS_CALL(v8impl::V8NameFromPropertyDescriptor(env, p, &property_name));

    v8::PropertyAttribute attributes =
        v8impl::V8PropertyAtt...",39,,748,9,,void
103587,BLOCK,1,,<empty>,,,,2,,void
103589,BLOCK,-1,,NAPI_PREAMBLE(env),3,,749,1,,void
103594,BLOCK,-1,,NAPI_PREAMBLE(env),3,,749,2,,void
103599,BLOCK,-1,,NAPI_PREAMBLE(env),3,,749,1,,void
103613,BLOCK,-1,,NAPI_PREAMBLE(env),3,,749,2,,void
103627,BLOCK,1,,<empty>,,,,3,,void
103629,BLOCK,-1,,"CHECK_ARG(env, result)",3,,750,1,,void
103635,BLOCK,-1,,"CHECK_ARG(env, result)",3,,750,2,,void
103644,BLOCK,1,,<empty>,,,,3,,void
103646,BLOCK,-1,,"CHECK_ARG(env, constructor)",3,,751,1,,void
103652,BLOCK,-1,,"CHECK_ARG(env, constructor)",3,,751,2,,void
103662,BLOCK,-1,,"{
    CHECK_ARG(env, properties);
  }",27,,753,2,,void
103666,BLOCK,1,,<empty>,,,,3,,void
103668,BLOCK,-1,,"CHECK_ARG(env, properties)",5,,754,1,,void
103674,BLOCK,-1,,"CHECK_ARG(env, properties)",5,,754,2,,void
103700,BLOCK,1,,<empty>,,,,3,,void
103702,BLOCK,-1,,"STATUS_CALL(v8impl::FunctionCallbackWrapper::NewTemplate(
      env, constructor, callback_data, &tpl))",3,,761,1,,void
103721,BLOCK,-1,,<empty>,3,,761,2,,void
103740,BLOCK,1,,<empty>,,,,7,,void
103742,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",3,,765,1,,void
103752,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",3,,765,1,,void
103762,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",3,,765,2,,void
103769,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",3,,765,1,,void
103775,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",3,,765,2,,void
103803,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",3,,765,1,,void
103811,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",3,,765,2,,void
103834,BLOCK,-1,,<empty>,3,,769,1,,void
103844,BLOCK,4,,"{
    const napi_property_descriptor* p = properties + i;

    if ((p->attributes & napi_static) != 0) {
      // Static properties are handled separately below.
      static_property_count++;
      continue;
    }

    v8::Local<v8::Name> property_name;
    STATUS_CALL(v8impl::V8NameFromPropertyDescriptor(env, p, &property_name));

    v8::PropertyAttribute attributes =
        v8impl::V8PropertyAttributesFromDescriptor(p);

    // This code is similar to that in napi_define_properties(); the
    // difference is it applies to a template instead of an object,
    // and preferred PropertyAttribute for lack of PropertyDescriptor
    // support on ObjectTemplate.
    if (p->getter != nullptr || p->setter != nullptr) {
      v8::Local<v8::FunctionTemplate> getter_tpl;
      v8::Local<v8::FunctionTemplate> setter_tpl;
      if (p->getter != nullptr) {
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewTemplate(
            env, p->getter, p->data, &getter_tpl));
      }
      if (...",47,,769,4,,void
103859,BLOCK,-1,,"{
      // Static properties are handled separately below.
      static_property_count++;
      continue;
    }",45,,772,2,,void
103874,BLOCK,1,,<empty>,,,,4,,void
103876,BLOCK,-1,,"STATUS_CALL(v8impl::V8NameFromPropertyDescriptor(env, p, &property_name))",5,,779,1,,void
103892,BLOCK,-1,,<empty>,5,,779,2,,void
103916,BLOCK,-1,,"{
      v8::Local<v8::FunctionTemplate> getter_tpl;
      v8::Local<v8::FunctionTemplate> setter_tpl;
      if (p->getter != nullptr) {
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewTemplate(
            env, p->getter, p->data, &getter_tpl));
      }
      if (p->setter != nullptr) {
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewTemplate(
            env, p->setter, p->data, &setter_tpl));
      }

      tpl->PrototypeTemplate()->SetAccessorProperty(property_name,
                                                    getter_tpl,
                                                    setter_tpl,
                                                    attributes,
                                                    v8::AccessControl::DEFAULT);
    }",55,,788,2,,void
103941,BLOCK,-1,,"{
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewTemplate(
            env, p->getter, p->data, &getter_tpl));
      }",33,,791,2,,void
103944,BLOCK,1,,<empty>,,,,5,,void
103946,BLOCK,-1,,"STATUS_CALL(v8impl::FunctionCallbackWrapper::NewTemplate(
            env, p->getter, p->data, &getter_tpl))",9,,792,1,,void
103969,BLOCK,-1,,<empty>,9,,792,2,,void
103979,BLOCK,-1,,"{
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewTemplate(
            env, p->setter, p->data, &setter_tpl));
      }",33,,795,2,,void
103982,BLOCK,1,,<empty>,,,,5,,void
103984,BLOCK,-1,,"STATUS_CALL(v8impl::FunctionCallbackWrapper::NewTemplate(
            env, p->setter, p->data, &setter_tpl))",9,,796,1,,void
104007,BLOCK,-1,,<empty>,9,,796,2,,void
104028,BLOCK,-1,,<empty>,12,,805,1,,void
104035,BLOCK,-1,,"{
      v8::Local<v8::FunctionTemplate> t;
      STATUS_CALL(v8impl::FunctionCallbackWrapper::NewTemplate(
          env, p->method, p->data, &t, v8::Signature::New(isolate, tpl)));

      tpl->PrototypeTemplate()->Set(property_name, t, attributes);
    }",38,,805,2,,void
104047,BLOCK,1,,<empty>,,,,6,,void
104049,BLOCK,-1,,"STATUS_CALL(v8impl::FunctionCallbackWrapper::NewTemplate(
          env, p->method, p->data, &t, v8::Signature::New(isolate, tpl)))",7,,807,1,,void
104080,BLOCK,-1,,<empty>,7,,807,2,,void
104095,BLOCK,-1,,"{
      v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(p->value);
      tpl->PrototypeTemplate()->Set(property_name, value, attributes);
    }",12,,811,1,,void
104160,BLOCK,-1,,"{
    std::vector<napi_property_descriptor> static_descriptors;
    static_descriptors.reserve(static_property_count);

    for (size_t i = 0; i < property_count; i++) {
      const napi_property_descriptor* p = properties + i;
      if ((p->attributes & napi_static) != 0) {
        static_descriptors.push_back(*p);
      }
    }

    STATUS_CALL(napi_define_properties(
        env, *result, static_descriptors.size(), static_descriptors.data()));
  }",34,,821,2,,void
104168,BLOCK,-1,,<empty>,5,,825,1,,void
104178,BLOCK,4,,"{
      const napi_property_descriptor* p = properties + i;
      if ((p->attributes & napi_static) != 0) {
        static_descriptors.push_back(*p);
      }
    }",49,,825,4,,void
104193,BLOCK,-1,,"{
        static_descriptors.push_back(*p);
      }",47,,827,2,,void
104202,BLOCK,1,,<empty>,,,,5,,void
104204,BLOCK,-1,,"STATUS_CALL(napi_define_properties(
        env, *result, static_descriptors.size(), static_descriptors.data()))",5,,832,1,,void
104224,BLOCK,-1,,<empty>,5,,832,2,,void
104231,BLOCK,1,,<empty>,,,,3,,void
104248,BLOCK,-1,,"{
  return napi_get_all_property_names(
      env,
      object,
      napi_key_include_prototypes,
      static_cast<napi_key_filter>(napi_key_enumerable | napi_key_skip_symbols),
      napi_key_numbers_to_strings,
      result);
}",68,,841,4,,void
104270,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;
  CHECK_TO_OBJECT(env, context, obj, object);

  v8::PropertyFilter filter = v8::PropertyFilter::ALL_PROPERTIES;
  if (key_filter & napi_key_writable) {
    filter = static_cast<v8::PropertyFilter>(filter |
                                             v8::PropertyFilter::ONLY_WRITABLE);
  }
  if (key_filter & napi_key_enumerable) {
    filter = static_cast<v8::PropertyFilter>(
        filter | v8::PropertyFilter::ONLY_ENUMERABLE);
  }
  if (key_filter & napi_key_configurable) {
    filter = static_cast<v8::PropertyFilter>(
        filter | v8::PropertyFilter::ONLY_CONFIGURABLE);
  }
  if (key_filter & napi_key_skip_strings) {
    filter = static_cast<v8::PropertyFilter>(filter |
                                             v8::PropertyFilter::SKIP_STRINGS);
  }
  if (key_filter & napi_key_skip_symbols) {
    filter = static_cast<v8::PropertyFilter>(filte...",49,,857,7,,void
104273,BLOCK,1,,<empty>,,,,2,,void
104275,BLOCK,-1,,NAPI_PREAMBLE(env),3,,858,1,,void
104280,BLOCK,-1,,NAPI_PREAMBLE(env),3,,858,2,,void
104285,BLOCK,-1,,NAPI_PREAMBLE(env),3,,858,1,,void
104299,BLOCK,-1,,NAPI_PREAMBLE(env),3,,858,2,,void
104313,BLOCK,1,,<empty>,,,,3,,void
104315,BLOCK,-1,,"CHECK_ARG(env, result)",3,,859,1,,void
104321,BLOCK,-1,,"CHECK_ARG(env, result)",3,,859,2,,void
104356,BLOCK,1,,<empty>,,,,7,,void
104358,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,863,1,,void
104360,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,863,1,,void
104366,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,863,2,,void
104385,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,863,1,,void
104393,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,863,2,,void
104418,BLOCK,-1,,"{
    filter = static_cast<v8::PropertyFilter>(filter |
                                             v8::PropertyFilter::ONLY_WRITABLE);
  }",39,,866,2,,void
104434,BLOCK,-1,,"{
    filter = static_cast<v8::PropertyFilter>(
        filter | v8::PropertyFilter::ONLY_ENUMERABLE);
  }",41,,870,2,,void
104450,BLOCK,-1,,"{
    filter = static_cast<v8::PropertyFilter>(
        filter | v8::PropertyFilter::ONLY_CONFIGURABLE);
  }",43,,874,2,,void
104466,BLOCK,-1,,"{
    filter = static_cast<v8::PropertyFilter>(filter |
                                             v8::PropertyFilter::SKIP_STRINGS);
  }",43,,878,2,,void
104482,BLOCK,-1,,"{
    filter = static_cast<v8::PropertyFilter>(filter |
                                             v8::PropertyFilter::SKIP_SYMBOLS);
  }",43,,882,2,,void
104498,BLOCK,-1,,"{
    case napi_key_include_prototypes:
      collection_mode = v8::KeyCollectionMode::kIncludePrototypes;
      break;
    case napi_key_own_only:
      collection_mode = v8::KeyCollectionMode::kOwnOnly;
      break;
    default:
      return napi_set_last_error(env, napi_invalid_arg);
  }",21,,889,2,,void
104526,BLOCK,-1,,"{
    case napi_key_keep_numbers:
      conversion_mode = v8::KeyConversionMode::kKeepNumbers;
      break;
    case napi_key_numbers_to_strings:
      conversion_mode = v8::KeyConversionMode::kConvertToString;
      break;
    default:
      return napi_set_last_error(env, napi_invalid_arg);
  }",27,,900,2,,void
104579,BLOCK,1,,<empty>,,,,5,,void
104581,BLOCK,-1,,"CHECK_MAYBE_EMPTY_WITH_PREAMBLE(
      env, maybe_all_propertynames, napi_generic_failure)",3,,918,1,,void
104589,BLOCK,-1,,"CHECK_MAYBE_EMPTY_WITH_PREAMBLE(
      env, maybe_all_propertynames, napi_generic_failure)",3,,918,2,,void
104615,BLOCK,1,,<empty>,,,,3,,void
104633,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, key);
  CHECK_ARG(env, value);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Local<v8::Value> k = v8impl::V8LocalValueFromJsValue(key);
  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  v8::Maybe<bool> set_maybe = obj->Set(context, k, val);

  RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure);
  return GET_RETURN_STATUS(env);
}",60,,929,5,,void
104636,BLOCK,1,,<empty>,,,,2,,void
104638,BLOCK,-1,,NAPI_PREAMBLE(env),3,,930,1,,void
104643,BLOCK,-1,,NAPI_PREAMBLE(env),3,,930,2,,void
104648,BLOCK,-1,,NAPI_PREAMBLE(env),3,,930,1,,void
104662,BLOCK,-1,,NAPI_PREAMBLE(env),3,,930,2,,void
104676,BLOCK,1,,<empty>,,,,3,,void
104678,BLOCK,-1,,"CHECK_ARG(env, key)",3,,931,1,,void
104684,BLOCK,-1,,"CHECK_ARG(env, key)",3,,931,2,,void
104693,BLOCK,1,,<empty>,,,,3,,void
104695,BLOCK,-1,,"CHECK_ARG(env, value)",3,,932,1,,void
104701,BLOCK,-1,,"CHECK_ARG(env, value)",3,,932,2,,void
104736,BLOCK,1,,<empty>,,,,7,,void
104738,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,937,1,,void
104740,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,937,1,,void
104746,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,937,2,,void
104765,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,937,1,,void
104773,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,937,2,,void
104834,BLOCK,1,,<empty>,,,,5,,void
104836,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure)",3,,944,1,,void
104844,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure)",3,,944,2,,void
104853,BLOCK,1,,<empty>,,,,3,,void
104871,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);
  CHECK_ARG(env, key);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Local<v8::Value> k = v8impl::V8LocalValueFromJsValue(key);
  v8::Maybe<bool> has_maybe = obj->Has(context, k);

  CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure);

  *result = has_maybe.FromMaybe(false);
  return GET_RETURN_STATUS(env);
}",56,,951,5,,void
104874,BLOCK,1,,<empty>,,,,2,,void
104876,BLOCK,-1,,NAPI_PREAMBLE(env),3,,952,1,,void
104881,BLOCK,-1,,NAPI_PREAMBLE(env),3,,952,2,,void
104886,BLOCK,-1,,NAPI_PREAMBLE(env),3,,952,1,,void
104900,BLOCK,-1,,NAPI_PREAMBLE(env),3,,952,2,,void
104914,BLOCK,1,,<empty>,,,,3,,void
104916,BLOCK,-1,,"CHECK_ARG(env, result)",3,,953,1,,void
104922,BLOCK,-1,,"CHECK_ARG(env, result)",3,,953,2,,void
104931,BLOCK,1,,<empty>,,,,3,,void
104933,BLOCK,-1,,"CHECK_ARG(env, key)",3,,954,1,,void
104939,BLOCK,-1,,"CHECK_ARG(env, key)",3,,954,2,,void
104974,BLOCK,1,,<empty>,,,,7,,void
104976,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,959,1,,void
104978,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,959,1,,void
104984,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,959,2,,void
105003,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,959,1,,void
105011,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,959,2,,void
105052,BLOCK,1,,<empty>,,,,5,,void
105054,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure)",3,,964,1,,void
105062,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure)",3,,964,2,,void
105079,BLOCK,1,,<empty>,,,,3,,void
105097,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, key);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Value> k = v8impl::V8LocalValueFromJsValue(key);
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  auto get_maybe = obj->Get(context, k);

  CHECK_MAYBE_EMPTY(env, get_maybe, napi_generic_failure);

  v8::Local<v8::Value> val = get_maybe.ToLocalChecked();
  *result = v8impl::JsValueFromV8LocalValue(val);
  return GET_RETURN_STATUS(env);
}",62,,973,5,,void
105100,BLOCK,1,,<empty>,,,,2,,void
105102,BLOCK,-1,,NAPI_PREAMBLE(env),3,,974,1,,void
105107,BLOCK,-1,,NAPI_PREAMBLE(env),3,,974,2,,void
105112,BLOCK,-1,,NAPI_PREAMBLE(env),3,,974,1,,void
105126,BLOCK,-1,,NAPI_PREAMBLE(env),3,,974,2,,void
105140,BLOCK,1,,<empty>,,,,3,,void
105142,BLOCK,-1,,"CHECK_ARG(env, key)",3,,975,1,,void
105148,BLOCK,-1,,"CHECK_ARG(env, key)",3,,975,2,,void
105157,BLOCK,1,,<empty>,,,,3,,void
105159,BLOCK,-1,,"CHECK_ARG(env, result)",3,,976,1,,void
105165,BLOCK,-1,,"CHECK_ARG(env, result)",3,,976,2,,void
105215,BLOCK,1,,<empty>,,,,7,,void
105217,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,982,1,,void
105219,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,982,1,,void
105225,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,982,2,,void
105244,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,982,1,,void
105252,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,982,2,,void
105278,BLOCK,1,,<empty>,,,,5,,void
105280,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, get_maybe, napi_generic_failure)",3,,986,1,,void
105288,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, get_maybe, napi_generic_failure)",3,,986,2,,void
105319,BLOCK,1,,<empty>,,,,3,,void
105337,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, key);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Value> k = v8impl::V8LocalValueFromJsValue(key);
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);
  v8::Maybe<bool> delete_maybe = obj->Delete(context, k);
  CHECK_MAYBE_NOTHING(env, delete_maybe, napi_generic_failure);

  if (result != nullptr) *result = delete_maybe.FromMaybe(false);

  return GET_RETURN_STATUS(env);
}",59,,996,5,,void
105340,BLOCK,1,,<empty>,,,,2,,void
105342,BLOCK,-1,,NAPI_PREAMBLE(env),3,,997,1,,void
105347,BLOCK,-1,,NAPI_PREAMBLE(env),3,,997,2,,void
105352,BLOCK,-1,,NAPI_PREAMBLE(env),3,,997,1,,void
105366,BLOCK,-1,,NAPI_PREAMBLE(env),3,,997,2,,void
105380,BLOCK,1,,<empty>,,,,3,,void
105382,BLOCK,-1,,"CHECK_ARG(env, key)",3,,998,1,,void
105388,BLOCK,-1,,"CHECK_ARG(env, key)",3,,998,2,,void
105438,BLOCK,1,,<empty>,,,,7,,void
105440,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1004,1,,void
105442,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1004,1,,void
105448,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1004,2,,void
105467,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1004,1,,void
105475,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1004,2,,void
105501,BLOCK,1,,<empty>,,,,5,,void
105503,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, delete_maybe, napi_generic_failure)",3,,1006,1,,void
105511,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, delete_maybe, napi_generic_failure)",3,,1006,2,,void
105521,BLOCK,-1,,<empty>,26,,1008,2,,void
105533,BLOCK,1,,<empty>,,,,3,,void
105551,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, key);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);
  v8::Local<v8::Value> k = v8impl::V8LocalValueFromJsValue(key);
  RETURN_STATUS_IF_FALSE(env, k->IsName(), napi_name_expected);
  v8::Maybe<bool> has_maybe = obj->HasOwnProperty(context, k.As<v8::Name>());
  CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure);
  *result = has_maybe.FromMaybe(false);

  return GET_RETURN_STATUS(env);
}",60,,1016,5,,void
105554,BLOCK,1,,<empty>,,,,2,,void
105556,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1017,1,,void
105561,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1017,2,,void
105566,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1017,1,,void
105580,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1017,2,,void
105594,BLOCK,1,,<empty>,,,,3,,void
105596,BLOCK,-1,,"CHECK_ARG(env, key)",3,,1018,1,,void
105602,BLOCK,-1,,"CHECK_ARG(env, key)",3,,1018,2,,void
105611,BLOCK,1,,<empty>,,,,3,,void
105613,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1019,1,,void
105619,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1019,2,,void
105654,BLOCK,1,,<empty>,,,,7,,void
105656,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1024,1,,void
105658,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1024,1,,void
105664,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1024,2,,void
105683,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1024,1,,void
105691,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1024,2,,void
105726,BLOCK,1,,<empty>,,,,4,,void
105728,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, k->IsName(), napi_name_expected)",3,,1026,1,,void
105735,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, k->IsName(), napi_name_expected)",3,,1026,2,,void
105757,BLOCK,1,,<empty>,,,,5,,void
105759,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure)",3,,1028,1,,void
105767,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure)",3,,1028,2,,void
105784,BLOCK,1,,<empty>,,,,3,,void
105802,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, value);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Local<v8::Name> key;
  CHECK_NEW_FROM_UTF8(env, key, utf8name);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  v8::Maybe<bool> set_maybe = obj->Set(context, key, val);

  RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure);
  return GET_RETURN_STATUS(env);
}",66,,1037,5,,void
105805,BLOCK,1,,<empty>,,,,2,,void
105807,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1038,1,,void
105812,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1038,2,,void
105817,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1038,1,,void
105831,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1038,2,,void
105845,BLOCK,1,,<empty>,,,,3,,void
105847,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1039,1,,void
105853,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1039,2,,void
105888,BLOCK,1,,<empty>,,,,7,,void
105890,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1044,1,,void
105892,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1044,1,,void
105898,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1044,2,,void
105917,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1044,1,,void
105925,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1044,2,,void
105952,BLOCK,1,,<empty>,,,,6,,void
105954,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1047,1,,void
105964,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1047,1,,void
105974,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1047,2,,void
105981,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1047,1,,void
105987,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1047,2,,void
106015,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1047,1,,void
106023,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1047,2,,void
106069,BLOCK,1,,<empty>,,,,5,,void
106071,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure)",3,,1053,1,,void
106079,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure)",3,,1053,2,,void
106088,BLOCK,1,,<empty>,,,,3,,void
106106,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Local<v8::Name> key;
  CHECK_NEW_FROM_UTF8(env, key, utf8name);

  v8::Maybe<bool> has_maybe = obj->Has(context, key);

  CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure);

  *result = has_maybe.FromMaybe(false);
  return GET_RETURN_STATUS(env);
}",62,,1060,5,,void
106109,BLOCK,1,,<empty>,,,,2,,void
106111,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1061,1,,void
106116,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1061,2,,void
106121,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1061,1,,void
106135,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1061,2,,void
106149,BLOCK,1,,<empty>,,,,3,,void
106151,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1062,1,,void
106157,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1062,2,,void
106192,BLOCK,1,,<empty>,,,,7,,void
106194,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1067,1,,void
106196,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1067,1,,void
106202,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1067,2,,void
106221,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1067,1,,void
106229,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1067,2,,void
106256,BLOCK,1,,<empty>,,,,6,,void
106258,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1070,1,,void
106268,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1070,1,,void
106278,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1070,2,,void
106285,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1070,1,,void
106291,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1070,2,,void
106319,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1070,1,,void
106327,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1070,2,,void
106353,BLOCK,1,,<empty>,,,,5,,void
106355,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure)",3,,1074,1,,void
106363,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure)",3,,1074,2,,void
106380,BLOCK,1,,<empty>,,,,3,,void
106398,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Name> key;
  CHECK_NEW_FROM_UTF8(env, key, utf8name);

  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  auto get_maybe = obj->Get(context, key);

  CHECK_MAYBE_EMPTY(env, get_maybe, napi_generic_failure);

  v8::Local<v8::Value> val = get_maybe.ToLocalChecked();
  *result = v8impl::JsValueFromV8LocalValue(val);
  return GET_RETURN_STATUS(env);
}",68,,1083,5,,void
106401,BLOCK,1,,<empty>,,,,2,,void
106403,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1084,1,,void
106408,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1084,2,,void
106413,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1084,1,,void
106427,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1084,2,,void
106441,BLOCK,1,,<empty>,,,,3,,void
106443,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1085,1,,void
106449,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1085,2,,void
106483,BLOCK,1,,<empty>,,,,6,,void
106485,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1090,1,,void
106495,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1090,1,,void
106505,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1090,2,,void
106512,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1090,1,,void
106518,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1090,2,,void
106546,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1090,1,,void
106554,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1090,2,,void
106582,BLOCK,1,,<empty>,,,,7,,void
106584,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1094,1,,void
106586,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1094,1,,void
106592,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1094,2,,void
106611,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1094,1,,void
106619,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1094,2,,void
106645,BLOCK,1,,<empty>,,,,5,,void
106647,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, get_maybe, napi_generic_failure)",3,,1098,1,,void
106655,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, get_maybe, napi_generic_failure)",3,,1098,2,,void
106686,BLOCK,1,,<empty>,,,,3,,void
106704,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, value);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  auto set_maybe = obj->Set(context, index, val);

  RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure);

  return GET_RETURN_STATUS(env);
}",59,,1108,5,,void
106707,BLOCK,1,,<empty>,,,,2,,void
106709,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1109,1,,void
106714,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1109,2,,void
106719,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1109,1,,void
106733,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1109,2,,void
106747,BLOCK,1,,<empty>,,,,3,,void
106749,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1110,1,,void
106755,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1110,2,,void
106790,BLOCK,1,,<empty>,,,,7,,void
106792,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1115,1,,void
106794,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1115,1,,void
106800,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1115,2,,void
106819,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1115,1,,void
106827,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1115,2,,void
106873,BLOCK,1,,<empty>,,,,5,,void
106875,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure)",3,,1120,1,,void
106883,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure)",3,,1120,2,,void
106892,BLOCK,1,,<empty>,,,,3,,void
106910,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Maybe<bool> has_maybe = obj->Has(context, index);

  CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure);

  *result = has_maybe.FromMaybe(false);
  return GET_RETURN_STATUS(env);
}",55,,1128,5,,void
106913,BLOCK,1,,<empty>,,,,2,,void
106915,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1129,1,,void
106920,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1129,2,,void
106925,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1129,1,,void
106939,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1129,2,,void
106953,BLOCK,1,,<empty>,,,,3,,void
106955,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1130,1,,void
106961,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1130,2,,void
106996,BLOCK,1,,<empty>,,,,7,,void
106998,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1135,1,,void
107000,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1135,1,,void
107006,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1135,2,,void
107025,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1135,1,,void
107033,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1135,2,,void
107059,BLOCK,1,,<empty>,,,,5,,void
107061,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure)",3,,1139,1,,void
107069,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure)",3,,1139,2,,void
107086,BLOCK,1,,<empty>,,,,3,,void
107104,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  auto get_maybe = obj->Get(context, index);

  CHECK_MAYBE_EMPTY(env, get_maybe, napi_generic_failure);

  *result = v8impl::JsValueFromV8LocalValue(get_maybe.ToLocalChecked());
  return GET_RETURN_STATUS(env);
}",61,,1148,5,,void
107107,BLOCK,1,,<empty>,,,,2,,void
107109,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1149,1,,void
107114,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1149,2,,void
107119,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1149,1,,void
107133,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1149,2,,void
107147,BLOCK,1,,<empty>,,,,3,,void
107149,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1150,1,,void
107155,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1150,2,,void
107190,BLOCK,1,,<empty>,,,,7,,void
107192,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1155,1,,void
107194,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1155,1,,void
107200,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1155,2,,void
107219,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1155,1,,void
107227,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1155,2,,void
107253,BLOCK,1,,<empty>,,,,5,,void
107255,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, get_maybe, napi_generic_failure)",3,,1159,1,,void
107263,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, get_maybe, napi_generic_failure)",3,,1159,2,,void
107283,BLOCK,1,,<empty>,,,,3,,void
107301,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);
  v8::Maybe<bool> delete_maybe = obj->Delete(context, index);
  CHECK_MAYBE_NOTHING(env, delete_maybe, napi_generic_failure);

  if (result != nullptr) *result = delete_maybe.FromMaybe(false);

  return GET_RETURN_STATUS(env);
}",58,,1168,5,,void
107304,BLOCK,1,,<empty>,,,,2,,void
107306,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1169,1,,void
107311,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1169,2,,void
107316,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1169,1,,void
107330,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1169,2,,void
107370,BLOCK,1,,<empty>,,,,7,,void
107372,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1174,1,,void
107374,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1174,1,,void
107380,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1174,2,,void
107399,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1174,1,,void
107407,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1174,2,,void
107433,BLOCK,1,,<empty>,,,,5,,void
107435,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, delete_maybe, napi_generic_failure)",3,,1176,1,,void
107443,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, delete_maybe, napi_generic_failure)",3,,1176,2,,void
107453,BLOCK,-1,,<empty>,26,,1178,2,,void
107465,BLOCK,1,,<empty>,,,,3,,void
107483,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  if (property_count > 0) {
    CHECK_ARG(env, properties);
  }

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Object> obj;
  CHECK_TO_OBJECT(env, context, obj, object);

  for (size_t i = 0; i < property_count; i++) {
    const napi_property_descriptor* p = &properties[i];

    v8::Local<v8::Name> property_name;
    STATUS_CALL(v8impl::V8NameFromPropertyDescriptor(env, p, &property_name));

    if (p->getter != nullptr || p->setter != nullptr) {
      v8::Local<v8::Function> local_getter;
      v8::Local<v8::Function> local_setter;

      if (p->getter != nullptr) {
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
            env, p->getter, p->data, &local_getter));
      }
      if (p->setter != nullptr) {
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
            env, p->setter, p->data, &local_setter));
      }

      v8::PropertyDescriptor descriptor(local_getter, local_setter);
      descriptor....",68,,1187,5,,void
107486,BLOCK,1,,<empty>,,,,2,,void
107488,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1188,1,,void
107493,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1188,2,,void
107498,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1188,1,,void
107512,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1188,2,,void
107527,BLOCK,-1,,"{
    CHECK_ARG(env, properties);
  }",27,,1189,2,,void
107531,BLOCK,1,,<empty>,,,,3,,void
107533,BLOCK,-1,,"CHECK_ARG(env, properties)",5,,1190,1,,void
107539,BLOCK,-1,,"CHECK_ARG(env, properties)",5,,1190,2,,void
107574,BLOCK,1,,<empty>,,,,7,,void
107576,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1196,1,,void
107578,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1196,1,,void
107584,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1196,2,,void
107603,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1196,1,,void
107611,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1196,2,,void
107625,BLOCK,-1,,<empty>,3,,1198,1,,void
107635,BLOCK,4,,"{
    const napi_property_descriptor* p = &properties[i];

    v8::Local<v8::Name> property_name;
    STATUS_CALL(v8impl::V8NameFromPropertyDescriptor(env, p, &property_name));

    if (p->getter != nullptr || p->setter != nullptr) {
      v8::Local<v8::Function> local_getter;
      v8::Local<v8::Function> local_setter;

      if (p->getter != nullptr) {
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
            env, p->getter, p->data, &local_getter));
      }
      if (p->setter != nullptr) {
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
            env, p->setter, p->data, &local_setter));
      }

      v8::PropertyDescriptor descriptor(local_getter, local_setter);
      descriptor.set_enumerable((p->attributes & napi_enumerable) != 0);
      descriptor.set_configurable((p->attributes & napi_configurable) != 0);

      auto define_maybe =
          obj->DefineProperty(context, property_name, descriptor);

      if (!define_maybe.FromMaybe(f...",47,,1198,4,,void
107654,BLOCK,1,,<empty>,,,,4,,void
107656,BLOCK,-1,,"STATUS_CALL(v8impl::V8NameFromPropertyDescriptor(env, p, &property_name))",5,,1202,1,,void
107672,BLOCK,-1,,<empty>,5,,1202,2,,void
107688,BLOCK,-1,,"{
      v8::Local<v8::Function> local_getter;
      v8::Local<v8::Function> local_setter;

      if (p->getter != nullptr) {
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
            env, p->getter, p->data, &local_getter));
      }
      if (p->setter != nullptr) {
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
            env, p->setter, p->data, &local_setter));
      }

      v8::PropertyDescriptor descriptor(local_getter, local_setter);
      descriptor.set_enumerable((p->attributes & napi_enumerable) != 0);
      descriptor.set_configurable((p->attributes & napi_configurable) != 0);

      auto define_maybe =
          obj->DefineProperty(context, property_name, descriptor);

      if (!define_maybe.FromMaybe(false)) {
        return napi_set_last_error(env, napi_invalid_arg);
      }
    }",55,,1204,2,,void
107713,BLOCK,-1,,"{
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
            env, p->getter, p->data, &local_getter));
      }",33,,1208,2,,void
107716,BLOCK,1,,<empty>,,,,5,,void
107718,BLOCK,-1,,"STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
            env, p->getter, p->data, &local_getter))",9,,1209,1,,void
107741,BLOCK,-1,,<empty>,9,,1209,2,,void
107751,BLOCK,-1,,"{
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
            env, p->setter, p->data, &local_setter));
      }",33,,1212,2,,void
107754,BLOCK,1,,<empty>,,,,5,,void
107756,BLOCK,-1,,"STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
            env, p->setter, p->data, &local_setter))",9,,1213,1,,void
107779,BLOCK,-1,,<empty>,9,,1213,2,,void
107826,BLOCK,-1,,"{
        return napi_set_last_error(env, napi_invalid_arg);
      }",43,,1224,2,,void
107832,BLOCK,-1,,<empty>,12,,1227,1,,void
107839,BLOCK,-1,,"{
      v8::Local<v8::Function> method;
      STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
          env, p->method, p->data, &method));
      v8::PropertyDescriptor descriptor(method,
                                        (p->attributes & napi_writable) != 0);
      descriptor.set_enumerable((p->attributes & napi_enumerable) != 0);
      descriptor.set_configurable((p->attributes & napi_configurable) != 0);

      auto define_maybe =
          obj->DefineProperty(context, property_name, descriptor);

      if (!define_maybe.FromMaybe(false)) {
        return napi_set_last_error(env, napi_generic_failure);
      }
    }",38,,1227,2,,void
107851,BLOCK,1,,<empty>,,,,5,,void
107853,BLOCK,-1,,"STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
          env, p->method, p->data, &method))",7,,1229,1,,void
107876,BLOCK,-1,,<empty>,7,,1229,2,,void
107929,BLOCK,-1,,"{
        return napi_set_last_error(env, napi_generic_failure);
      }",43,,1239,2,,void
107935,BLOCK,-1,,"{
      v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(p->value);

      v8::PropertyDescriptor descriptor(value,
                                        (p->attributes & napi_writable) != 0);
      descriptor.set_enumerable((p->attributes & napi_enumerable) != 0);
      descriptor.set_configurable((p->attributes & napi_configurable) != 0);

      auto define_maybe =
          obj->DefineProperty(context, property_name, descriptor);

      if (!define_maybe.FromMaybe(false)) {
        return napi_set_last_error(env, napi_invalid_arg);
      }
    }",12,,1242,1,,void
108002,BLOCK,-1,,"{
        return napi_set_last_error(env, napi_invalid_arg);
      }",43,,1253,2,,void
108010,BLOCK,1,,<empty>,,,,3,,void
108026,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Maybe<bool> set_frozen =
      obj->SetIntegrityLevel(context, v8::IntegrityLevel::kFrozen);

  RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, set_frozen.FromMaybe(false), napi_generic_failure);

  return GET_RETURN_STATUS(env);
}",76,,1262,3,,void
108029,BLOCK,1,,<empty>,,,,2,,void
108031,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1263,1,,void
108036,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1263,2,,void
108041,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1263,1,,void
108055,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1263,2,,void
108095,BLOCK,1,,<empty>,,,,7,,void
108097,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1268,1,,void
108099,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1268,1,,void
108105,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1268,2,,void
108124,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1268,1,,void
108132,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1268,2,,void
108166,BLOCK,1,,<empty>,,,,6,,void
108168,BLOCK,-1,,"RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, set_frozen.FromMaybe(false), napi_generic_failure)",3,,1273,1,,void
108176,BLOCK,-1,,"RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, set_frozen.FromMaybe(false), napi_generic_failure)",3,,1273,2,,void
108191,BLOCK,1,,<empty>,,,,3,,void
108207,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Maybe<bool> set_sealed =
      obj->SetIntegrityLevel(context, v8::IntegrityLevel::kSealed);

  RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, set_sealed.FromMaybe(false), napi_generic_failure);

  return GET_RETURN_STATUS(env);
}",74,,1279,3,,void
108210,BLOCK,1,,<empty>,,,,2,,void
108212,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1280,1,,void
108217,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1280,2,,void
108222,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1280,1,,void
108236,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1280,2,,void
108276,BLOCK,1,,<empty>,,,,7,,void
108278,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1285,1,,void
108280,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1285,1,,void
108286,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1285,2,,void
108305,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1285,1,,void
108313,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1285,2,,void
108347,BLOCK,1,,<empty>,,,,6,,void
108349,BLOCK,-1,,"RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, set_sealed.FromMaybe(false), napi_generic_failure)",3,,1290,1,,void
108357,BLOCK,-1,,"RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, set_sealed.FromMaybe(false), napi_generic_failure)",3,,1290,2,,void
108372,BLOCK,1,,<empty>,,,,3,,void
108389,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  *result = val->IsArray();
  return napi_clear_last_error(env);
}",52,,1298,4,,void
108392,BLOCK,1,,<empty>,,,,2,,void
108394,BLOCK,-1,,CHECK_ENV(env),3,,1299,1,,void
108399,BLOCK,-1,,CHECK_ENV(env),3,,1299,2,,void
108406,BLOCK,1,,<empty>,,,,3,,void
108408,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1300,1,,void
108414,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1300,2,,void
108423,BLOCK,1,,<empty>,,,,3,,void
108425,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1301,1,,void
108431,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1301,2,,void
108468,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsArray(), napi_array_expected);

  v8::Local<v8::Array> arr = val.As<v8::Array>();
  *result = arr->Length();

  return GET_RETURN_STATUS(env);
}",64,,1311,4,,void
108471,BLOCK,1,,<empty>,,,,2,,void
108473,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1312,1,,void
108478,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1312,2,,void
108483,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1312,1,,void
108497,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1312,2,,void
108511,BLOCK,1,,<empty>,,,,3,,void
108513,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1313,1,,void
108519,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1313,2,,void
108528,BLOCK,1,,<empty>,,,,3,,void
108530,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1314,1,,void
108536,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1314,2,,void
108564,BLOCK,1,,<empty>,,,,4,,void
108566,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsArray(), napi_array_expected)",3,,1317,1,,void
108573,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsArray(), napi_array_expected)",3,,1317,2,,void
108603,BLOCK,1,,<empty>,,,,3,,void
108621,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, lhs);
  CHECK_ARG(env, rhs);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> a = v8impl::V8LocalValueFromJsValue(lhs);
  v8::Local<v8::Value> b = v8impl::V8LocalValueFromJsValue(rhs);

  *result = a->StrictEquals(b);
  return GET_RETURN_STATUS(env);
}",57,,1328,5,,void
108624,BLOCK,1,,<empty>,,,,2,,void
108626,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1329,1,,void
108631,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1329,2,,void
108636,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1329,1,,void
108650,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1329,2,,void
108664,BLOCK,1,,<empty>,,,,3,,void
108666,BLOCK,-1,,"CHECK_ARG(env, lhs)",3,,1330,1,,void
108672,BLOCK,-1,,"CHECK_ARG(env, lhs)",3,,1330,2,,void
108681,BLOCK,1,,<empty>,,,,3,,void
108683,BLOCK,-1,,"CHECK_ARG(env, rhs)",3,,1331,1,,void
108689,BLOCK,-1,,"CHECK_ARG(env, rhs)",3,,1331,2,,void
108698,BLOCK,1,,<empty>,,,,3,,void
108700,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1332,1,,void
108706,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1332,2,,void
108753,BLOCK,1,,<empty>,,,,3,,void
108770,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Object> obj;
  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Local<v8::Value> val = obj->GetPrototype();
  *result = v8impl::JsValueFromV8LocalValue(val);
  return GET_RETURN_STATUS(env);
}",63,,1343,4,,void
108773,BLOCK,1,,<empty>,,,,2,,void
108775,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1344,1,,void
108780,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1344,2,,void
108785,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1344,1,,void
108799,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1344,2,,void
108813,BLOCK,1,,<empty>,,,,3,,void
108815,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1345,1,,void
108821,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1345,2,,void
108856,BLOCK,1,,<empty>,,,,7,,void
108858,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1350,1,,void
108860,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1350,1,,void
108866,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1350,2,,void
108885,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1350,1,,void
108893,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1350,2,,void
108931,BLOCK,1,,<empty>,,,,3,,void
108947,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(v8::Object::New(env->isolate));

  return napi_clear_last_error(env);
}",77,,1357,3,,void
108950,BLOCK,1,,<empty>,,,,2,,void
108952,BLOCK,-1,,CHECK_ENV(env),3,,1358,1,,void
108957,BLOCK,-1,,CHECK_ENV(env),3,,1358,2,,void
108964,BLOCK,1,,<empty>,,,,3,,void
108966,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1359,1,,void
108972,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1359,2,,void
109002,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(v8::Array::New(env->isolate));

  return napi_clear_last_error(env);
}",76,,1366,3,,void
109005,BLOCK,1,,<empty>,,,,2,,void
109007,BLOCK,-1,,CHECK_ENV(env),3,,1367,1,,void
109012,BLOCK,-1,,CHECK_ENV(env),3,,1367,2,,void
109019,BLOCK,1,,<empty>,,,,3,,void
109021,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1368,1,,void
109027,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1368,2,,void
109058,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result =
      v8impl::JsValueFromV8LocalValue(v8::Array::New(env->isolate, length));

  return napi_clear_last_error(env);
}",74,,1377,4,,void
109061,BLOCK,1,,<empty>,,,,2,,void
109063,BLOCK,-1,,CHECK_ENV(env),3,,1378,1,,void
109068,BLOCK,-1,,CHECK_ENV(env),3,,1378,2,,void
109075,BLOCK,1,,<empty>,,,,3,,void
109077,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1379,1,,void
109083,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1379,2,,void
109116,BLOCK,-1,,"{
  CHECK_ENV(env);
  if (length > 0) CHECK_ARG(env, str);
  CHECK_ARG(env, result);
  RETURN_STATUS_IF_FALSE(
      env, (length == NAPI_AUTO_LENGTH) || length <= INT_MAX, napi_invalid_arg);

  auto isolate = env->isolate;
  auto str_maybe =
      v8::String::NewFromOneByte(isolate,
                                 reinterpret_cast<const uint8_t*>(str),
                                 v8::NewStringType::kNormal,
                                 length);
  CHECK_MAYBE_EMPTY(env, str_maybe, napi_generic_failure);

  *result = v8impl::JsValueFromV8LocalValue(str_maybe.ToLocalChecked());
  return napi_clear_last_error(env);
}",70,,1390,5,,void
109119,BLOCK,1,,<empty>,,,,2,,void
109121,BLOCK,-1,,CHECK_ENV(env),3,,1391,1,,void
109126,BLOCK,-1,,CHECK_ENV(env),3,,1391,2,,void
109134,BLOCK,-1,,<empty>,19,,1392,2,,void
109138,BLOCK,1,,<empty>,,,,3,,void
109140,BLOCK,-1,,"CHECK_ARG(env, str)",19,,1392,1,,void
109146,BLOCK,-1,,"CHECK_ARG(env, str)",19,,1392,2,,void
109155,BLOCK,1,,<empty>,,,,3,,void
109157,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1393,1,,void
109163,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1393,2,,void
109172,BLOCK,1,,<empty>,,,,3,,void
109174,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(
      env, (length == NAPI_AUTO_LENGTH) || length <= INT_MAX, napi_invalid_arg)",3,,1394,1,,void
109184,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(
      env, (length == NAPI_AUTO_LENGTH) || length <= INT_MAX, napi_invalid_arg)",3,,1394,2,,void
109219,BLOCK,1,,<empty>,,,,5,,void
109221,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, str_maybe, napi_generic_failure)",3,,1403,1,,void
109229,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, str_maybe, napi_generic_failure)",3,,1403,2,,void
109256,BLOCK,-1,,"{
  CHECK_ENV(env);
  if (length > 0) CHECK_ARG(env, str);
  CHECK_ARG(env, result);
  RETURN_STATUS_IF_FALSE(
      env, (length == NAPI_AUTO_LENGTH) || length <= INT_MAX, napi_invalid_arg);

  auto isolate = env->isolate;
  auto str_maybe = v8::String::NewFromUtf8(
      isolate, str, v8::NewStringType::kNormal, static_cast<int>(length));
  CHECK_MAYBE_EMPTY(env, str_maybe, napi_generic_failure);
  *result = v8impl::JsValueFromV8LocalValue(str_maybe.ToLocalChecked());
  return napi_clear_last_error(env);
}",68,,1412,5,,void
109259,BLOCK,1,,<empty>,,,,2,,void
109261,BLOCK,-1,,CHECK_ENV(env),3,,1413,1,,void
109266,BLOCK,-1,,CHECK_ENV(env),3,,1413,2,,void
109274,BLOCK,-1,,<empty>,19,,1414,2,,void
109278,BLOCK,1,,<empty>,,,,3,,void
109280,BLOCK,-1,,"CHECK_ARG(env, str)",19,,1414,1,,void
109286,BLOCK,-1,,"CHECK_ARG(env, str)",19,,1414,2,,void
109295,BLOCK,1,,<empty>,,,,3,,void
109297,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1415,1,,void
109303,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1415,2,,void
109312,BLOCK,1,,<empty>,,,,3,,void
109314,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(
      env, (length == NAPI_AUTO_LENGTH) || length <= INT_MAX, napi_invalid_arg)",3,,1416,1,,void
109324,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(
      env, (length == NAPI_AUTO_LENGTH) || length <= INT_MAX, napi_invalid_arg)",3,,1416,2,,void
109359,BLOCK,1,,<empty>,,,,5,,void
109361,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, str_maybe, napi_generic_failure)",3,,1422,1,,void
109369,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, str_maybe, napi_generic_failure)",3,,1422,2,,void
109396,BLOCK,-1,,"{
  CHECK_ENV(env);
  if (length > 0) CHECK_ARG(env, str);
  CHECK_ARG(env, result);
  RETURN_STATUS_IF_FALSE(
      env, (length == NAPI_AUTO_LENGTH) || length <= INT_MAX, napi_invalid_arg);

  auto isolate = env->isolate;
  auto str_maybe =
      v8::String::NewFromTwoByte(isolate,
                                 reinterpret_cast<const uint16_t*>(str),
                                 v8::NewStringType::kNormal,
                                 length);
  CHECK_MAYBE_EMPTY(env, str_maybe, napi_generic_failure);

  *result = v8impl::JsValueFromV8LocalValue(str_maybe.ToLocalChecked());
  return napi_clear_last_error(env);
}",69,,1430,5,,void
109399,BLOCK,1,,<empty>,,,,2,,void
109401,BLOCK,-1,,CHECK_ENV(env),3,,1431,1,,void
109406,BLOCK,-1,,CHECK_ENV(env),3,,1431,2,,void
109414,BLOCK,-1,,<empty>,19,,1432,2,,void
109418,BLOCK,1,,<empty>,,,,3,,void
109420,BLOCK,-1,,"CHECK_ARG(env, str)",19,,1432,1,,void
109426,BLOCK,-1,,"CHECK_ARG(env, str)",19,,1432,2,,void
109435,BLOCK,1,,<empty>,,,,3,,void
109437,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1433,1,,void
109443,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1433,2,,void
109452,BLOCK,1,,<empty>,,,,3,,void
109454,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(
      env, (length == NAPI_AUTO_LENGTH) || length <= INT_MAX, napi_invalid_arg)",3,,1434,1,,void
109464,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(
      env, (length == NAPI_AUTO_LENGTH) || length <= INT_MAX, napi_invalid_arg)",3,,1434,2,,void
109499,BLOCK,1,,<empty>,,,,5,,void
109501,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, str_maybe, napi_generic_failure)",3,,1443,1,,void
109509,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, str_maybe, napi_generic_failure)",3,,1443,2,,void
109535,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result =
      v8impl::JsValueFromV8LocalValue(v8::Number::New(env->isolate, value));

  return napi_clear_last_error(env);
}",63,,1451,4,,void
109538,BLOCK,1,,<empty>,,,,2,,void
109540,BLOCK,-1,,CHECK_ENV(env),3,,1452,1,,void
109545,BLOCK,-1,,CHECK_ENV(env),3,,1452,2,,void
109552,BLOCK,1,,<empty>,,,,3,,void
109554,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1453,1,,void
109560,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1453,2,,void
109592,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result =
      v8impl::JsValueFromV8LocalValue(v8::Integer::New(env->isolate, value));

  return napi_clear_last_error(env);
}",62,,1463,4,,void
109595,BLOCK,1,,<empty>,,,,2,,void
109597,BLOCK,-1,,CHECK_ENV(env),3,,1464,1,,void
109602,BLOCK,-1,,CHECK_ENV(env),3,,1464,2,,void
109609,BLOCK,1,,<empty>,,,,3,,void
109611,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1465,1,,void
109617,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1465,2,,void
109649,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(
      v8::Integer::NewFromUnsigned(env->isolate, value));

  return napi_clear_last_error(env);
}",63,,1475,4,,void
109652,BLOCK,1,,<empty>,,,,2,,void
109654,BLOCK,-1,,CHECK_ENV(env),3,,1476,1,,void
109659,BLOCK,-1,,CHECK_ENV(env),3,,1476,2,,void
109666,BLOCK,1,,<empty>,,,,3,,void
109668,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1477,1,,void
109674,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1477,2,,void
109706,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(
      v8::Number::New(env->isolate, static_cast<double>(value)));

  return napi_clear_last_error(env);
}",62,,1487,4,,void
109709,BLOCK,1,,<empty>,,,,2,,void
109711,BLOCK,-1,,CHECK_ENV(env),3,,1488,1,,void
109716,BLOCK,-1,,CHECK_ENV(env),3,,1488,2,,void
109723,BLOCK,1,,<empty>,,,,3,,void
109725,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1489,1,,void
109731,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1489,2,,void
109765,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result =
      v8impl::JsValueFromV8LocalValue(v8::BigInt::New(env->isolate, value));

  return napi_clear_last_error(env);
}",69,,1499,4,,void
109768,BLOCK,1,,<empty>,,,,2,,void
109770,BLOCK,-1,,CHECK_ENV(env),3,,1500,1,,void
109775,BLOCK,-1,,CHECK_ENV(env),3,,1500,2,,void
109782,BLOCK,1,,<empty>,,,,3,,void
109784,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1501,1,,void
109790,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1501,2,,void
109822,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(
      v8::BigInt::NewFromUnsigned(env->isolate, value));

  return napi_clear_last_error(env);
}",70,,1511,4,,void
109825,BLOCK,1,,<empty>,,,,2,,void
109827,BLOCK,-1,,CHECK_ENV(env),3,,1512,1,,void
109832,BLOCK,-1,,CHECK_ENV(env),3,,1512,2,,void
109839,BLOCK,1,,<empty>,,,,3,,void
109841,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1513,1,,void
109847,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1513,2,,void
109881,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, words);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();

  RETURN_STATUS_IF_FALSE(env, word_count <= INT_MAX, napi_invalid_arg);

  v8::MaybeLocal<v8::BigInt> b =
      v8::BigInt::NewFromWords(context, sign_bit, word_count, words);

  CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, b, napi_generic_failure);

  *result = v8impl::JsValueFromV8LocalValue(b.ToLocalChecked());
  return GET_RETURN_STATUS(env);
}",69,,1525,6,,void
109884,BLOCK,1,,<empty>,,,,2,,void
109886,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1526,1,,void
109891,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1526,2,,void
109896,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1526,1,,void
109910,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1526,2,,void
109924,BLOCK,1,,<empty>,,,,3,,void
109926,BLOCK,-1,,"CHECK_ARG(env, words)",3,,1527,1,,void
109932,BLOCK,-1,,"CHECK_ARG(env, words)",3,,1527,2,,void
109941,BLOCK,1,,<empty>,,,,3,,void
109943,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1528,1,,void
109949,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1528,2,,void
109972,BLOCK,1,,<empty>,,,,3,,void
109974,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, word_count <= INT_MAX, napi_invalid_arg)",3,,1532,1,,void
109980,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, word_count <= INT_MAX, napi_invalid_arg)",3,,1532,2,,void
110010,BLOCK,1,,<empty>,,,,5,,void
110012,BLOCK,-1,,"CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, b, napi_generic_failure)",3,,1537,1,,void
110020,BLOCK,-1,,"CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, b, napi_generic_failure)",3,,1537,2,,void
110046,BLOCK,1,,<empty>,,,,3,,void
110063,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  v8::Isolate* isolate = env->isolate;

  if (value) {
    *result = v8impl::JsValueFromV8LocalValue(v8::True(isolate));
  } else {
    *result = v8impl::JsValueFromV8LocalValue(v8::False(isolate));
  }

  return napi_clear_last_error(env);
}",61,,1545,4,,void
110066,BLOCK,1,,<empty>,,,,2,,void
110068,BLOCK,-1,,CHECK_ENV(env),3,,1546,1,,void
110073,BLOCK,-1,,CHECK_ENV(env),3,,1546,2,,void
110080,BLOCK,1,,<empty>,,,,3,,void
110082,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1547,1,,void
110088,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1547,2,,void
110102,BLOCK,-1,,"{
    *result = v8impl::JsValueFromV8LocalValue(v8::True(isolate));
  }",14,,1551,2,,void
110116,BLOCK,-1,,"{
    *result = v8impl::JsValueFromV8LocalValue(v8::False(isolate));
  }",10,,1553,1,,void
110138,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  v8::Isolate* isolate = env->isolate;

  if (description == nullptr) {
    *result = v8impl::JsValueFromV8LocalValue(v8::Symbol::New(isolate));
  } else {
    v8::Local<v8::Value> desc = v8impl::V8LocalValueFromJsValue(description);
    RETURN_STATUS_IF_FALSE(env, desc->IsString(), napi_string_expected);

    *result = v8impl::JsValueFromV8LocalValue(
        v8::Symbol::New(isolate, desc.As<v8::String>()));
  }

  return napi_clear_last_error(env);
}",63,,1562,4,,void
110141,BLOCK,1,,<empty>,,,,2,,void
110143,BLOCK,-1,,CHECK_ENV(env),3,,1563,1,,void
110148,BLOCK,-1,,CHECK_ENV(env),3,,1563,2,,void
110155,BLOCK,1,,<empty>,,,,3,,void
110157,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1564,1,,void
110163,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1564,2,,void
110179,BLOCK,-1,,"{
    *result = v8impl::JsValueFromV8LocalValue(v8::Symbol::New(isolate));
  }",31,,1568,2,,void
110195,BLOCK,-1,,"{
    v8::Local<v8::Value> desc = v8impl::V8LocalValueFromJsValue(description);
    RETURN_STATUS_IF_FALSE(env, desc->IsString(), napi_string_expected);

    *result = v8impl::JsValueFromV8LocalValue(
        v8::Symbol::New(isolate, desc.As<v8::String>()));
  }",10,,1570,1,,void
110218,BLOCK,1,,<empty>,,,,4,,void
110220,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, desc->IsString(), napi_string_expected)",5,,1572,1,,void
110227,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, desc->IsString(), napi_string_expected)",5,,1572,2,,void
110261,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  napi_value js_description_string;
  STATUS_CALL(napi_create_string_utf8(
      env, utf8description, length, &js_description_string));
  v8::Local<v8::String> description_string =
      v8impl::V8LocalValueFromJsValue(js_description_string).As<v8::String>();

  *result = v8impl::JsValueFromV8LocalValue(
      v8::Symbol::For(env->isolate, description_string));

  return napi_clear_last_error(env);
}",64,,1584,5,,void
110264,BLOCK,1,,<empty>,,,,2,,void
110266,BLOCK,-1,,CHECK_ENV(env),3,,1585,1,,void
110271,BLOCK,-1,,CHECK_ENV(env),3,,1585,2,,void
110278,BLOCK,1,,<empty>,,,,3,,void
110280,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1586,1,,void
110286,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1586,2,,void
110295,BLOCK,1,,<empty>,,,,4,,void
110297,BLOCK,-1,,"STATUS_CALL(napi_create_string_utf8(
      env, utf8description, length, &js_description_string))",3,,1589,1,,void
110311,BLOCK,-1,,<empty>,3,,1589,2,,void
110360,BLOCK,-1,,"{
  if ((code != nullptr) || (code_cstring != nullptr)) {
    v8::Local<v8::Context> context = env->context();
    v8::Local<v8::Object> err_object = error.As<v8::Object>();

    v8::Local<v8::Value> code_value = v8impl::V8LocalValueFromJsValue(code);
    if (code != nullptr) {
      code_value = v8impl::V8LocalValueFromJsValue(code);
      RETURN_STATUS_IF_FALSE(env, code_value->IsString(), napi_string_expected);
    } else {
      CHECK_NEW_FROM_UTF8(env, code_value, code_cstring);
    }

    v8::Local<v8::Name> code_key;
    CHECK_NEW_FROM_UTF8(env, code_key, ""code"");

    v8::Maybe<bool> set_maybe = err_object->Set(context, code_key, code_value);
    RETURN_STATUS_IF_FALSE(
        env, set_maybe.FromMaybe(false), napi_generic_failure);
  }
  return napi_ok;
}",68,,1603,5,,void
110369,BLOCK,-1,,"{
    v8::Local<v8::Context> context = env->context();
    v8::Local<v8::Object> err_object = error.As<v8::Object>();

    v8::Local<v8::Value> code_value = v8impl::V8LocalValueFromJsValue(code);
    if (code != nullptr) {
      code_value = v8impl::V8LocalValueFromJsValue(code);
      RETURN_STATUS_IF_FALSE(env, code_value->IsString(), napi_string_expected);
    } else {
      CHECK_NEW_FROM_UTF8(env, code_value, code_cstring);
    }

    v8::Local<v8::Name> code_key;
    CHECK_NEW_FROM_UTF8(env, code_key, ""code"");

    v8::Maybe<bool> set_maybe = err_object->Set(context, code_key, code_value);
    RETURN_STATUS_IF_FALSE(
        env, set_maybe.FromMaybe(false), napi_generic_failure);
  }",55,,1604,2,,void
110417,BLOCK,-1,,"{
      code_value = v8impl::V8LocalValueFromJsValue(code);
      RETURN_STATUS_IF_FALSE(env, code_value->IsString(), napi_string_expected);
    }",26,,1609,2,,void
110432,BLOCK,1,,<empty>,,,,4,,void
110434,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, code_value->IsString(), napi_string_expected)",7,,1611,1,,void
110441,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, code_value->IsString(), napi_string_expected)",7,,1611,2,,void
110448,BLOCK,-1,,"{
      CHECK_NEW_FROM_UTF8(env, code_value, code_cstring);
    }",12,,1612,1,,void
110454,BLOCK,1,,<empty>,,,,6,,void
110456,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_value, code_cstring)",7,,1613,1,,void
110466,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_value, code_cstring)",7,,1613,1,,void
110476,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_value, code_cstring)",7,,1613,2,,void
110483,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_value, code_cstring)",7,,1613,1,,void
110489,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_value, code_cstring)",7,,1613,2,,void
110517,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_value, code_cstring)",7,,1613,1,,void
110525,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_value, code_cstring)",7,,1613,2,,void
110552,BLOCK,1,,<empty>,,,,6,,void
110554,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_key, ""code"")",5,,1617,1,,void
110564,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_key, ""code"")",5,,1617,1,,void
110574,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_key, ""code"")",5,,1617,2,,void
110581,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_key, ""code"")",5,,1617,1,,void
110587,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_key, ""code"")",5,,1617,2,,void
110615,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_key, ""code"")",5,,1617,1,,void
110623,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_key, ""code"")",5,,1617,2,,void
110654,BLOCK,1,,<empty>,,,,5,,void
110656,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(
        env, set_maybe.FromMaybe(false), napi_generic_failure)",5,,1620,1,,void
110664,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(
        env, set_maybe.FromMaybe(false), napi_generic_failure)",5,,1620,2,,void
110679,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, msg);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> message_value = v8impl::V8LocalValueFromJsValue(msg);
  RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected);

  v8::Local<v8::Value> error_obj =
      v8::Exception::Error(message_value.As<v8::String>());
  STATUS_CALL(set_error_code(env, error_obj, code, nullptr));

  *result = v8impl::JsValueFromV8LocalValue(error_obj);

  return napi_clear_last_error(env);
}",62,,1629,5,,void
110682,BLOCK,1,,<empty>,,,,2,,void
110684,BLOCK,-1,,CHECK_ENV(env),3,,1630,1,,void
110689,BLOCK,-1,,CHECK_ENV(env),3,,1630,2,,void
110696,BLOCK,1,,<empty>,,,,3,,void
110698,BLOCK,-1,,"CHECK_ARG(env, msg)",3,,1631,1,,void
110704,BLOCK,-1,,"CHECK_ARG(env, msg)",3,,1631,2,,void
110713,BLOCK,1,,<empty>,,,,3,,void
110715,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1632,1,,void
110721,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1632,2,,void
110749,BLOCK,1,,<empty>,,,,4,,void
110751,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected)",3,,1635,1,,void
110758,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected)",3,,1635,2,,void
110786,BLOCK,1,,<empty>,,,,3,,void
110788,BLOCK,-1,,"STATUS_CALL(set_error_code(env, error_obj, code, nullptr))",3,,1639,1,,void
110801,BLOCK,-1,,<empty>,3,,1639,2,,void
110823,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, msg);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> message_value = v8impl::V8LocalValueFromJsValue(msg);
  RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected);

  v8::Local<v8::Value> error_obj =
      v8::Exception::TypeError(message_value.As<v8::String>());
  STATUS_CALL(set_error_code(env, error_obj, code, nullptr));

  *result = v8impl::JsValueFromV8LocalValue(error_obj);

  return napi_clear_last_error(env);
}",67,,1649,5,,void
110826,BLOCK,1,,<empty>,,,,2,,void
110828,BLOCK,-1,,CHECK_ENV(env),3,,1650,1,,void
110833,BLOCK,-1,,CHECK_ENV(env),3,,1650,2,,void
110840,BLOCK,1,,<empty>,,,,3,,void
110842,BLOCK,-1,,"CHECK_ARG(env, msg)",3,,1651,1,,void
110848,BLOCK,-1,,"CHECK_ARG(env, msg)",3,,1651,2,,void
110857,BLOCK,1,,<empty>,,,,3,,void
110859,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1652,1,,void
110865,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1652,2,,void
110893,BLOCK,1,,<empty>,,,,4,,void
110895,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected)",3,,1655,1,,void
110902,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected)",3,,1655,2,,void
110930,BLOCK,1,,<empty>,,,,3,,void
110932,BLOCK,-1,,"STATUS_CALL(set_error_code(env, error_obj, code, nullptr))",3,,1659,1,,void
110945,BLOCK,-1,,<empty>,3,,1659,2,,void
110967,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, msg);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> message_value = v8impl::V8LocalValueFromJsValue(msg);
  RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected);

  v8::Local<v8::Value> error_obj =
      v8::Exception::RangeError(message_value.As<v8::String>());
  STATUS_CALL(set_error_code(env, error_obj, code, nullptr));

  *result = v8impl::JsValueFromV8LocalValue(error_obj);

  return napi_clear_last_error(env);
}",68,,1669,5,,void
110970,BLOCK,1,,<empty>,,,,2,,void
110972,BLOCK,-1,,CHECK_ENV(env),3,,1670,1,,void
110977,BLOCK,-1,,CHECK_ENV(env),3,,1670,2,,void
110984,BLOCK,1,,<empty>,,,,3,,void
110986,BLOCK,-1,,"CHECK_ARG(env, msg)",3,,1671,1,,void
110992,BLOCK,-1,,"CHECK_ARG(env, msg)",3,,1671,2,,void
111001,BLOCK,1,,<empty>,,,,3,,void
111003,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1672,1,,void
111009,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1672,2,,void
111037,BLOCK,1,,<empty>,,,,4,,void
111039,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected)",3,,1675,1,,void
111046,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected)",3,,1675,2,,void
111074,BLOCK,1,,<empty>,,,,3,,void
111076,BLOCK,-1,,"STATUS_CALL(set_error_code(env, error_obj, code, nullptr))",3,,1679,1,,void
111089,BLOCK,-1,,<empty>,3,,1679,2,,void
111111,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, msg);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> message_value = v8impl::V8LocalValueFromJsValue(msg);
  RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected);

  v8::Local<v8::Value> error_obj =
      v8::Exception::SyntaxError(message_value.As<v8::String>());
  STATUS_CALL(set_error_code(env, error_obj, code, nullptr));

  *result = v8impl::JsValueFromV8LocalValue(error_obj);

  return napi_clear_last_error(env);
}",73,,1689,5,,void
111114,BLOCK,1,,<empty>,,,,2,,void
111116,BLOCK,-1,,CHECK_ENV(env),3,,1690,1,,void
111121,BLOCK,-1,,CHECK_ENV(env),3,,1690,2,,void
111128,BLOCK,1,,<empty>,,,,3,,void
111130,BLOCK,-1,,"CHECK_ARG(env, msg)",3,,1691,1,,void
111136,BLOCK,-1,,"CHECK_ARG(env, msg)",3,,1691,2,,void
111145,BLOCK,1,,<empty>,,,,3,,void
111147,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1692,1,,void
111153,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1692,2,,void
111181,BLOCK,1,,<empty>,,,,4,,void
111183,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected)",3,,1695,1,,void
111190,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected)",3,,1695,2,,void
111218,BLOCK,1,,<empty>,,,,3,,void
111220,BLOCK,-1,,"STATUS_CALL(set_error_code(env, error_obj, code, nullptr))",3,,1699,1,,void
111233,BLOCK,-1,,<empty>,3,,1699,2,,void
111254,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> v = v8impl::V8LocalValueFromJsValue(value);

  if (v->IsNumber()) {
    *result = napi_number;
  } else if (v->IsBigInt()) {
    *result = napi_bigint;
  } else if (v->IsString()) {
    *result = napi_string;
  } else if (v->IsFunction()) {
    // This test has to come before IsObject because IsFunction
    // implies IsObject
    *result = napi_function;
  } else if (v->IsExternal()) {
    // This test has to come before IsObject because IsExternal
    // implies IsObject
    *result = napi_external;
  } else if (v->IsObject()) {
    *result = napi_object;
  } else if (v->IsBoolean()) {
    *result = napi_boolean;
  } else if (v->IsUndefined()) {
    *result = napi_undefined;
  } else if (v->IsSymbol()) {
    *result = napi_symbol;
  } else if (v->IsNull()) {
    *result = napi_null;
  } e...",60,,1708,4,,void
111257,BLOCK,1,,<empty>,,,,2,,void
111259,BLOCK,-1,,CHECK_ENV(env),3,,1711,1,,void
111264,BLOCK,-1,,CHECK_ENV(env),3,,1711,2,,void
111271,BLOCK,1,,<empty>,,,,3,,void
111273,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1712,1,,void
111279,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1712,2,,void
111288,BLOCK,1,,<empty>,,,,3,,void
111290,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1713,1,,void
111296,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1713,2,,void
111322,BLOCK,-1,,"{
    *result = napi_number;
  }",22,,1717,2,,void
111328,BLOCK,-1,,<empty>,10,,1719,1,,void
111334,BLOCK,-1,,"{
    *result = napi_bigint;
  }",29,,1719,2,,void
111340,BLOCK,-1,,<empty>,10,,1721,1,,void
111346,BLOCK,-1,,"{
    *result = napi_string;
  }",29,,1721,2,,void
111352,BLOCK,-1,,<empty>,10,,1723,1,,void
111358,BLOCK,-1,,"{
    // This test has to come before IsObject because IsFunction
    // implies IsObject
    *result = napi_function;
  }",31,,1723,2,,void
111364,BLOCK,-1,,<empty>,10,,1727,1,,void
111370,BLOCK,-1,,"{
    // This test has to come before IsObject because IsExternal
    // implies IsObject
    *result = napi_external;
  }",31,,1727,2,,void
111376,BLOCK,-1,,<empty>,10,,1731,1,,void
111382,BLOCK,-1,,"{
    *result = napi_object;
  }",29,,1731,2,,void
111388,BLOCK,-1,,<empty>,10,,1733,1,,void
111394,BLOCK,-1,,"{
    *result = napi_boolean;
  }",30,,1733,2,,void
111400,BLOCK,-1,,<empty>,10,,1735,1,,void
111406,BLOCK,-1,,"{
    *result = napi_undefined;
  }",32,,1735,2,,void
111412,BLOCK,-1,,<empty>,10,,1737,1,,void
111418,BLOCK,-1,,"{
    *result = napi_symbol;
  }",29,,1737,2,,void
111424,BLOCK,-1,,<empty>,10,,1739,1,,void
111430,BLOCK,-1,,"{
    *result = napi_null;
  }",27,,1739,2,,void
111436,BLOCK,-1,,"{
    // Should not get here unless V8 has added some new kind of value.
    return napi_set_last_error(env, napi_invalid_arg);
  }",10,,1741,1,,void
111449,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(v8::Undefined(env->isolate));

  return napi_clear_last_error(env);
}",77,,1749,3,,void
111452,BLOCK,1,,<empty>,,,,2,,void
111454,BLOCK,-1,,CHECK_ENV(env),3,,1750,1,,void
111459,BLOCK,-1,,CHECK_ENV(env),3,,1750,2,,void
111466,BLOCK,1,,<empty>,,,,3,,void
111468,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1751,1,,void
111474,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1751,2,,void
111502,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(v8::Null(env->isolate));

  return napi_clear_last_error(env);
}",72,,1758,3,,void
111505,BLOCK,1,,<empty>,,,,2,,void
111507,BLOCK,-1,,CHECK_ENV(env),3,,1759,1,,void
111512,BLOCK,-1,,CHECK_ENV(env),3,,1759,2,,void
111519,BLOCK,1,,<empty>,,,,3,,void
111521,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1760,1,,void
111527,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1760,2,,void
111559,BLOCK,-1,,"{         // [out] Receives the data pointer for the callback.
  CHECK_ENV(env);
  CHECK_ARG(env, cbinfo);

  v8impl::CallbackWrapper* info =
      reinterpret_cast<v8impl::CallbackWrapper*>(cbinfo);

  if (argv != nullptr) {
    CHECK_ARG(env, argc);
    info->Args(argv, *argc);
  }
  if (argc != nullptr) {
    *argc = info->ArgsLength();
  }
  if (this_arg != nullptr) {
    *this_arg = info->This();
  }
  if (data != nullptr) {
    *data = info->Data();
  }

  return napi_clear_last_error(env);
}",18,,1775,7,,void
111562,BLOCK,1,,<empty>,,,,2,,void
111564,BLOCK,-1,,CHECK_ENV(env),3,,1776,1,,void
111569,BLOCK,-1,,CHECK_ENV(env),3,,1776,2,,void
111576,BLOCK,1,,<empty>,,,,3,,void
111578,BLOCK,-1,,"CHECK_ARG(env, cbinfo)",3,,1777,1,,void
111584,BLOCK,-1,,"CHECK_ARG(env, cbinfo)",3,,1777,2,,void
111600,BLOCK,-1,,"{
    CHECK_ARG(env, argc);
    info->Args(argv, *argc);
  }",24,,1782,2,,void
111604,BLOCK,1,,<empty>,,,,3,,void
111606,BLOCK,-1,,"CHECK_ARG(env, argc)",5,,1783,1,,void
111612,BLOCK,-1,,"CHECK_ARG(env, argc)",5,,1783,2,,void
111629,BLOCK,-1,,"{
    *argc = info->ArgsLength();
  }",24,,1786,2,,void
111641,BLOCK,-1,,"{
    *this_arg = info->This();
  }",28,,1789,2,,void
111653,BLOCK,-1,,"{
    *data = info->Data();
  }",24,,1792,2,,void
111670,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, cbinfo);
  CHECK_ARG(env, result);

  v8impl::CallbackWrapper* info =
      reinterpret_cast<v8impl::CallbackWrapper*>(cbinfo);

  *result = info->GetNewTarget();
  return napi_clear_last_error(env);
}",64,,1801,4,,void
111673,BLOCK,1,,<empty>,,,,2,,void
111675,BLOCK,-1,,CHECK_ENV(env),3,,1802,1,,void
111680,BLOCK,-1,,CHECK_ENV(env),3,,1802,2,,void
111687,BLOCK,1,,<empty>,,,,3,,void
111689,BLOCK,-1,,"CHECK_ARG(env, cbinfo)",3,,1803,1,,void
111695,BLOCK,-1,,"CHECK_ARG(env, cbinfo)",3,,1803,2,,void
111704,BLOCK,1,,<empty>,,,,3,,void
111706,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1804,1,,void
111712,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1804,2,,void
111743,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, recv);
  if (argc > 0) {
    CHECK_ARG(env, argv);
  }

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Value> v8recv = v8impl::V8LocalValueFromJsValue(recv);

  v8::Local<v8::Function> v8func;
  CHECK_TO_FUNCTION(env, v8func, func);

  auto maybe = v8func->Call(
      context,
      v8recv,
      argc,
      reinterpret_cast<v8::Local<v8::Value>*>(const_cast<napi_value*>(argv)));

  if (try_catch.HasCaught()) {
    return napi_set_last_error(env, napi_pending_exception);
  } else {
    if (result != nullptr) {
      CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure);
      *result = v8impl::JsValueFromV8LocalValue(maybe.ToLocalChecked());
    }
    return napi_clear_last_error(env);
  }
}",63,,1818,7,,void
111746,BLOCK,1,,<empty>,,,,2,,void
111748,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1819,1,,void
111753,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1819,2,,void
111758,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1819,1,,void
111772,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1819,2,,void
111786,BLOCK,1,,<empty>,,,,3,,void
111788,BLOCK,-1,,"CHECK_ARG(env, recv)",3,,1820,1,,void
111794,BLOCK,-1,,"CHECK_ARG(env, recv)",3,,1820,2,,void
111804,BLOCK,-1,,"{
    CHECK_ARG(env, argv);
  }",17,,1821,2,,void
111808,BLOCK,1,,<empty>,,,,3,,void
111810,BLOCK,-1,,"CHECK_ARG(env, argv)",5,,1822,1,,void
111816,BLOCK,-1,,"CHECK_ARG(env, argv)",5,,1822,2,,void
111864,BLOCK,1,,<empty>,,,,4,,void
111866,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8func, func)",3,,1830,1,,void
111868,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8func, func)",3,,1830,1,,void
111874,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8func, func)",3,,1830,2,,void
111896,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8func, func)",3,,1830,1,,void
111903,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8func, func)",3,,1830,2,,void
111936,BLOCK,-1,,"{
    return napi_set_last_error(env, napi_pending_exception);
  }",30,,1838,2,,void
111942,BLOCK,-1,,"{
    if (result != nullptr) {
      CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure);
      *result = v8impl::JsValueFromV8LocalValue(maybe.ToLocalChecked());
    }
    return napi_clear_last_error(env);
  }",10,,1840,1,,void
111947,BLOCK,-1,,"{
      CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure);
      *result = v8impl::JsValueFromV8LocalValue(maybe.ToLocalChecked());
    }",28,,1841,2,,void
111952,BLOCK,1,,<empty>,,,,5,,void
111954,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure)",7,,1842,1,,void
111962,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure)",7,,1842,2,,void
111987,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(env->context()->Global());

  return napi_clear_last_error(env);
}",74,,1849,3,,void
111990,BLOCK,1,,<empty>,,,,2,,void
111992,BLOCK,-1,,CHECK_ENV(env),3,,1850,1,,void
111997,BLOCK,-1,,CHECK_ENV(env),3,,1850,2,,void
112004,BLOCK,1,,<empty>,,,,3,,void
112006,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1851,1,,void
112012,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1851,2,,void
112040,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, error);

  v8::Isolate* isolate = env->isolate;

  isolate->ThrowException(v8impl::V8LocalValueFromJsValue(error));
  // any VM calls after this point and before returning
  // to the javascript invoker will fail
  return napi_clear_last_error(env);
}",67,,1858,3,,void
112043,BLOCK,1,,<empty>,,,,2,,void
112045,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1859,1,,void
112050,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1859,2,,void
112055,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1859,1,,void
112069,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1859,2,,void
112083,BLOCK,1,,<empty>,,,,3,,void
112085,BLOCK,-1,,"CHECK_ARG(env, error)",3,,1860,1,,void
112091,BLOCK,-1,,"CHECK_ARG(env, error)",3,,1860,2,,void
112121,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);

  v8::Isolate* isolate = env->isolate;
  v8::Local<v8::String> str;
  CHECK_NEW_FROM_UTF8(env, str, msg);

  v8::Local<v8::Value> error_obj = v8::Exception::Error(str);
  STATUS_CALL(set_error_code(env, error_obj, nullptr, code));

  isolate->ThrowException(error_obj);
  // any VM calls after this point and before returning
  // to the javascript invoker will fail
  return napi_clear_last_error(env);
}",58,,1872,4,,void
112124,BLOCK,1,,<empty>,,,,2,,void
112126,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1873,1,,void
112131,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1873,2,,void
112136,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1873,1,,void
112150,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1873,2,,void
112181,BLOCK,1,,<empty>,,,,6,,void
112183,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,1877,1,,void
112193,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,1877,1,,void
112203,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,1877,2,,void
112210,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,1877,1,,void
112216,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,1877,2,,void
112244,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,1877,1,,void
112252,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,1877,2,,void
112284,BLOCK,1,,<empty>,,,,3,,void
112286,BLOCK,-1,,"STATUS_CALL(set_error_code(env, error_obj, nullptr, code))",3,,1880,1,,void
112299,BLOCK,-1,,<empty>,3,,1880,2,,void
112317,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);

  v8::Isolate* isolate = env->isolate;
  v8::Local<v8::String> str;
  CHECK_NEW_FROM_UTF8(env, str, msg);

  v8::Local<v8::Value> error_obj = v8::Exception::TypeError(str);
  STATUS_CALL(set_error_code(env, error_obj, nullptr, code));

  isolate->ThrowException(error_obj);
  // any VM calls after this point and before returning
  // to the javascript invoker will fail
  return napi_clear_last_error(env);
}",63,,1890,4,,void
112320,BLOCK,1,,<empty>,,,,2,,void
112322,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1891,1,,void
112327,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1891,2,,void
112332,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1891,1,,void
112346,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1891,2,,void
112377,BLOCK,1,,<empty>,,,,6,,void
112379,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,1895,1,,void
112389,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,1895,1,,void
112399,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,1895,2,,void
112406,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,1895,1,,void
112412,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,1895,2,,void
112440,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,1895,1,,void
112448,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,1895,2,,void
112480,BLOCK,1,,<empty>,,,,3,,void
112482,BLOCK,-1,,"STATUS_CALL(set_error_code(env, error_obj, nullptr, code))",3,,1898,1,,void
112495,BLOCK,-1,,<empty>,3,,1898,2,,void
112513,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);

  v8::Isolate* isolate = env->isolate;
  v8::Local<v8::String> str;
  CHECK_NEW_FROM_UTF8(env, str, msg);

  v8::Local<v8::Value> error_obj = v8::Exception::RangeError(str);
  STATUS_CALL(set_error_code(env, error_obj, nullptr, code));

  isolate->ThrowException(error_obj);
  // any VM calls after this point and before returning
  // to the javascript invoker will fail
  return napi_clear_last_error(env);
}",64,,1908,4,,void
112516,BLOCK,1,,<empty>,,,,2,,void
112518,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1909,1,,void
112523,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1909,2,,void
112528,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1909,1,,void
112542,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1909,2,,void
112573,BLOCK,1,,<empty>,,,,6,,void
112575,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,1913,1,,void
112585,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,1913,1,,void
112595,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,1913,2,,void
112602,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,1913,1,,void
112608,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,1913,2,,void
112636,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,1913,1,,void
112644,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,1913,2,,void
112676,BLOCK,1,,<empty>,,,,3,,void
112678,BLOCK,-1,,"STATUS_CALL(set_error_code(env, error_obj, nullptr, code))",3,,1916,1,,void
112691,BLOCK,-1,,<empty>,3,,1916,2,,void
112709,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);

  v8::Isolate* isolate = env->isolate;
  v8::Local<v8::String> str;
  CHECK_NEW_FROM_UTF8(env, str, msg);

  v8::Local<v8::Value> error_obj = v8::Exception::SyntaxError(str);
  STATUS_CALL(set_error_code(env, error_obj, nullptr, code));

  isolate->ThrowException(error_obj);
  // any VM calls after this point and before returning
  // to the javascript invoker will fail
  return napi_clear_last_error(env);
}",69,,1926,4,,void
112712,BLOCK,1,,<empty>,,,,2,,void
112714,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1927,1,,void
112719,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1927,2,,void
112724,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1927,1,,void
112738,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1927,2,,void
112769,BLOCK,1,,<empty>,,,,6,,void
112771,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,1931,1,,void
112781,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,1931,1,,void
112791,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,1931,2,,void
112798,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,1931,1,,void
112804,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,1931,2,,void
112832,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,1931,1,,void
112840,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,1931,2,,void
112872,BLOCK,1,,<empty>,,,,3,,void
112874,BLOCK,-1,,"STATUS_CALL(set_error_code(env, error_obj, nullptr, code))",3,,1934,1,,void
112887,BLOCK,-1,,<empty>,3,,1934,2,,void
112905,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot
  // throw JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  *result = val->IsNativeError();

  return napi_clear_last_error(env);
}",52,,1944,4,,void
112908,BLOCK,1,,<empty>,,,,2,,void
112910,BLOCK,-1,,CHECK_ENV(env),3,,1947,1,,void
112915,BLOCK,-1,,CHECK_ENV(env),3,,1947,2,,void
112922,BLOCK,1,,<empty>,,,,3,,void
112924,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1948,1,,void
112930,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1948,2,,void
112939,BLOCK,1,,<empty>,,,,3,,void
112941,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1949,1,,void
112947,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1949,2,,void
112984,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected);

  *result = val.As<v8::Number>()->Value();

  return napi_clear_last_error(env);
}",62,,1959,4,,void
112987,BLOCK,1,,<empty>,,,,2,,void
112989,BLOCK,-1,,CHECK_ENV(env),3,,1962,1,,void
112994,BLOCK,-1,,CHECK_ENV(env),3,,1962,2,,void
113001,BLOCK,1,,<empty>,,,,3,,void
113003,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1963,1,,void
113009,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1963,2,,void
113018,BLOCK,1,,<empty>,,,,3,,void
113020,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1964,1,,void
113026,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1964,2,,void
113054,BLOCK,1,,<empty>,,,,4,,void
113056,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected)",3,,1967,1,,void
113063,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected)",3,,1967,2,,void
113088,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  if (val->IsInt32()) {
    *result = val.As<v8::Int32>()->Value();
  } else {
    RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected);

    // Empty context: https://github.com/nodejs/node/issues/14379
    v8::Local<v8::Context> context;
    *result = val->Int32Value(context).FromJust();
  }

  return napi_clear_last_error(env);
}",62,,1976,4,,void
113091,BLOCK,1,,<empty>,,,,2,,void
113093,BLOCK,-1,,CHECK_ENV(env),3,,1979,1,,void
113098,BLOCK,-1,,CHECK_ENV(env),3,,1979,2,,void
113105,BLOCK,1,,<empty>,,,,3,,void
113107,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1980,1,,void
113113,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1980,2,,void
113122,BLOCK,1,,<empty>,,,,3,,void
113124,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1981,1,,void
113130,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1981,2,,void
113156,BLOCK,-1,,"{
    *result = val.As<v8::Int32>()->Value();
  }",23,,1985,2,,void
113168,BLOCK,-1,,"{
    RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected);

    // Empty context: https://github.com/nodejs/node/issues/14379
    v8::Local<v8::Context> context;
    *result = val->Int32Value(context).FromJust();
  }",10,,1987,1,,void
113176,BLOCK,1,,<empty>,,,,4,,void
113178,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected)",5,,1988,1,,void
113185,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected)",5,,1988,2,,void
113220,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  if (val->IsUint32()) {
    *result = val.As<v8::Uint32>()->Value();
  } else {
    RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected);

    // Empty context: https://github.com/nodejs/node/issues/14379
    v8::Local<v8::Context> context;
    *result = val->Uint32Value(context).FromJust();
  }

  return napi_clear_last_error(env);
}",64,,2000,4,,void
113223,BLOCK,1,,<empty>,,,,2,,void
113225,BLOCK,-1,,CHECK_ENV(env),3,,2003,1,,void
113230,BLOCK,-1,,CHECK_ENV(env),3,,2003,2,,void
113237,BLOCK,1,,<empty>,,,,3,,void
113239,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2004,1,,void
113245,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2004,2,,void
113254,BLOCK,1,,<empty>,,,,3,,void
113256,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2005,1,,void
113262,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2005,2,,void
113288,BLOCK,-1,,"{
    *result = val.As<v8::Uint32>()->Value();
  }",24,,2009,2,,void
113300,BLOCK,-1,,"{
    RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected);

    // Empty context: https://github.com/nodejs/node/issues/14379
    v8::Local<v8::Context> context;
    *result = val->Uint32Value(context).FromJust();
  }",10,,2011,1,,void
113308,BLOCK,1,,<empty>,,,,4,,void
113310,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected)",5,,2012,1,,void
113317,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected)",5,,2012,2,,void
113352,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  // This is still a fast path very likely to be taken.
  if (val->IsInt32()) {
    *result = val.As<v8::Int32>()->Value();
    return napi_clear_last_error(env);
  }

  RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected);

  // v8::Value::IntegerValue() converts NaN, +Inf, and -Inf to INT64_MIN,
  // inconsistent with v8::Value::Int32Value() which converts those values to 0.
  // Special-case all non-finite values to match that behavior.
  double doubleValue = val.As<v8::Number>()->Value();
  if (std::isfinite(doubleValue)) {
    // Empty context: https://github.com/nodejs/node/issues/14379
    v8::Local<v8::Context> context;
    *result = val->IntegerValue(context).FromJust();
  } else {
    *result = 0;
  }

  return napi_clea...",62,,2024,4,,void
113355,BLOCK,1,,<empty>,,,,2,,void
113357,BLOCK,-1,,CHECK_ENV(env),3,,2027,1,,void
113362,BLOCK,-1,,CHECK_ENV(env),3,,2027,2,,void
113369,BLOCK,1,,<empty>,,,,3,,void
113371,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2028,1,,void
113377,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2028,2,,void
113386,BLOCK,1,,<empty>,,,,3,,void
113388,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2029,1,,void
113394,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2029,2,,void
113420,BLOCK,-1,,"{
    *result = val.As<v8::Int32>()->Value();
    return napi_clear_last_error(env);
  }",23,,2034,2,,void
113441,BLOCK,1,,<empty>,,,,4,,void
113443,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected)",3,,2039,1,,void
113450,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected)",3,,2039,2,,void
113472,BLOCK,-1,,"{
    // Empty context: https://github.com/nodejs/node/issues/14379
    v8::Local<v8::Context> context;
    *result = val->IntegerValue(context).FromJust();
  }",35,,2045,2,,void
113494,BLOCK,-1,,"{
    *result = 0;
  }",10,,2049,1,,void
113509,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);
  CHECK_ARG(env, lossless);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  RETURN_STATUS_IF_FALSE(env, val->IsBigInt(), napi_bigint_expected);

  *result = val.As<v8::BigInt>()->Int64Value(lossless);

  return napi_clear_last_error(env);
}",68,,2059,5,,void
113512,BLOCK,1,,<empty>,,,,2,,void
113514,BLOCK,-1,,CHECK_ENV(env),3,,2060,1,,void
113519,BLOCK,-1,,CHECK_ENV(env),3,,2060,2,,void
113526,BLOCK,1,,<empty>,,,,3,,void
113528,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2061,1,,void
113534,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2061,2,,void
113543,BLOCK,1,,<empty>,,,,3,,void
113545,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2062,1,,void
113551,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2062,2,,void
113560,BLOCK,1,,<empty>,,,,3,,void
113562,BLOCK,-1,,"CHECK_ARG(env, lossless)",3,,2063,1,,void
113568,BLOCK,-1,,"CHECK_ARG(env, lossless)",3,,2063,2,,void
113596,BLOCK,1,,<empty>,,,,4,,void
113598,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsBigInt(), napi_bigint_expected)",3,,2067,1,,void
113605,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsBigInt(), napi_bigint_expected)",3,,2067,2,,void
113632,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);
  CHECK_ARG(env, lossless);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  RETURN_STATUS_IF_FALSE(env, val->IsBigInt(), napi_bigint_expected);

  *result = val.As<v8::BigInt>()->Uint64Value(lossless);

  return napi_clear_last_error(env);
}",69,,2077,5,,void
113635,BLOCK,1,,<empty>,,,,2,,void
113637,BLOCK,-1,,CHECK_ENV(env),3,,2078,1,,void
113642,BLOCK,-1,,CHECK_ENV(env),3,,2078,2,,void
113649,BLOCK,1,,<empty>,,,,3,,void
113651,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2079,1,,void
113657,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2079,2,,void
113666,BLOCK,1,,<empty>,,,,3,,void
113668,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2080,1,,void
113674,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2080,2,,void
113683,BLOCK,1,,<empty>,,,,3,,void
113685,BLOCK,-1,,"CHECK_ARG(env, lossless)",3,,2081,1,,void
113691,BLOCK,-1,,"CHECK_ARG(env, lossless)",3,,2081,2,,void
113719,BLOCK,1,,<empty>,,,,4,,void
113721,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsBigInt(), napi_bigint_expected)",3,,2085,1,,void
113728,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsBigInt(), napi_bigint_expected)",3,,2085,2,,void
113756,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, word_count);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  RETURN_STATUS_IF_FALSE(env, val->IsBigInt(), napi_bigint_expected);

  v8::Local<v8::BigInt> big = val.As<v8::BigInt>();

  int word_count_int = *word_count;

  if (sign_bit == nullptr && words == nullptr) {
    word_count_int = big->WordCount();
  } else {
    CHECK_ARG(env, sign_bit);
    CHECK_ARG(env, words);
    big->ToWordsArray(sign_bit, &word_count_int, words);
  }

  *word_count = word_count_int;

  return napi_clear_last_error(env);
}",69,,2096,6,,void
113759,BLOCK,1,,<empty>,,,,2,,void
113761,BLOCK,-1,,CHECK_ENV(env),3,,2097,1,,void
113766,BLOCK,-1,,CHECK_ENV(env),3,,2097,2,,void
113773,BLOCK,1,,<empty>,,,,3,,void
113775,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2098,1,,void
113781,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2098,2,,void
113790,BLOCK,1,,<empty>,,,,3,,void
113792,BLOCK,-1,,"CHECK_ARG(env, word_count)",3,,2099,1,,void
113798,BLOCK,-1,,"CHECK_ARG(env, word_count)",3,,2099,2,,void
113826,BLOCK,1,,<empty>,,,,4,,void
113828,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsBigInt(), napi_bigint_expected)",3,,2103,1,,void
113835,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsBigInt(), napi_bigint_expected)",3,,2103,2,,void
113868,BLOCK,-1,,"{
    word_count_int = big->WordCount();
  }",48,,2109,2,,void
113876,BLOCK,-1,,"{
    CHECK_ARG(env, sign_bit);
    CHECK_ARG(env, words);
    big->ToWordsArray(sign_bit, &word_count_int, words);
  }",10,,2111,1,,void
113880,BLOCK,1,,<empty>,,,,3,,void
113882,BLOCK,-1,,"CHECK_ARG(env, sign_bit)",5,,2112,1,,void
113888,BLOCK,-1,,"CHECK_ARG(env, sign_bit)",5,,2112,2,,void
113897,BLOCK,1,,<empty>,,,,3,,void
113899,BLOCK,-1,,"CHECK_ARG(env, words)",5,,2113,1,,void
113905,BLOCK,-1,,"CHECK_ARG(env, words)",5,,2113,2,,void
113932,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsBoolean(), napi_boolean_expected);

  *result = val.As<v8::Boolean>()->Value();

  return napi_clear_last_error(env);
}",58,,2124,4,,void
113935,BLOCK,1,,<empty>,,,,2,,void
113937,BLOCK,-1,,CHECK_ENV(env),3,,2127,1,,void
113942,BLOCK,-1,,CHECK_ENV(env),3,,2127,2,,void
113949,BLOCK,1,,<empty>,,,,3,,void
113951,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2128,1,,void
113957,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2128,2,,void
113966,BLOCK,1,,<empty>,,,,3,,void
113968,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2129,1,,void
113974,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2129,2,,void
114002,BLOCK,1,,<empty>,,,,4,,void
114004,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsBoolean(), napi_boolean_expected)",3,,2132,1,,void
114011,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsBoolean(), napi_boolean_expected)",3,,2132,2,,void
114038,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected);

  if (!buf) {
    CHECK_ARG(env, result);
    *result = val.As<v8::String>()->Length();
  } else if (bufsize != 0) {
    int copied =
        val.As<v8::String>()->WriteOneByte(env->isolate,
                                           reinterpret_cast<uint8_t*>(buf),
                                           0,
                                           bufsize - 1,
                                           v8::String::NO_NULL_TERMINATION);

    buf[copied] = '\0';
    if (result != nullptr) {
      *result = copied;
    }
  } else if (result != nullptr) {
    *result = 0;
  }

  return napi_clear_last_error(env);
}",80,,2148,6,,void
114041,BLOCK,1,,<empty>,,,,2,,void
114043,BLOCK,-1,,CHECK_ENV(env),3,,2149,1,,void
114048,BLOCK,-1,,CHECK_ENV(env),3,,2149,2,,void
114055,BLOCK,1,,<empty>,,,,3,,void
114057,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2150,1,,void
114063,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2150,2,,void
114091,BLOCK,1,,<empty>,,,,4,,void
114093,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected)",3,,2153,1,,void
114100,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected)",3,,2153,2,,void
114109,BLOCK,-1,,"{
    CHECK_ARG(env, result);
    *result = val.As<v8::String>()->Length();
  }",13,,2155,2,,void
114113,BLOCK,1,,<empty>,,,,3,,void
114115,BLOCK,-1,,"CHECK_ARG(env, result)",5,,2156,1,,void
114121,BLOCK,-1,,"CHECK_ARG(env, result)",5,,2156,2,,void
114138,BLOCK,-1,,<empty>,10,,2158,1,,void
114143,BLOCK,-1,,"{
    int copied =
        val.As<v8::String>()->WriteOneByte(env->isolate,
                                           reinterpret_cast<uint8_t*>(buf),
                                           0,
                                           bufsize - 1,
                                           v8::String::NO_NULL_TERMINATION);

    buf[copied] = '\0';
    if (result != nullptr) {
      *result = copied;
    }
  }",28,,2158,2,,void
114178,BLOCK,-1,,"{
      *result = copied;
    }",28,,2167,2,,void
114184,BLOCK,-1,,<empty>,10,,2170,1,,void
114189,BLOCK,-1,,"{
    *result = 0;
  }",33,,2170,2,,void
114205,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected);

  if (!buf) {
    CHECK_ARG(env, result);
    *result = val.As<v8::String>()->Utf8Length(env->isolate);
  } else if (bufsize != 0) {
    int copied = val.As<v8::String>()->WriteUtf8(
        env->isolate,
        buf,
        bufsize - 1,
        nullptr,
        v8::String::REPLACE_INVALID_UTF8 | v8::String::NO_NULL_TERMINATION);

    buf[copied] = '\0';
    if (result != nullptr) {
      *result = copied;
    }
  } else if (result != nullptr) {
    *result = 0;
  }

  return napi_clear_last_error(env);
}",80,,2186,6,,void
114208,BLOCK,1,,<empty>,,,,2,,void
114210,BLOCK,-1,,CHECK_ENV(env),3,,2187,1,,void
114215,BLOCK,-1,,CHECK_ENV(env),3,,2187,2,,void
114222,BLOCK,1,,<empty>,,,,3,,void
114224,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2188,1,,void
114230,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2188,2,,void
114258,BLOCK,1,,<empty>,,,,4,,void
114260,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected)",3,,2191,1,,void
114267,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected)",3,,2191,2,,void
114276,BLOCK,-1,,"{
    CHECK_ARG(env, result);
    *result = val.As<v8::String>()->Utf8Length(env->isolate);
  }",13,,2193,2,,void
114280,BLOCK,1,,<empty>,,,,3,,void
114282,BLOCK,-1,,"CHECK_ARG(env, result)",5,,2194,1,,void
114288,BLOCK,-1,,"CHECK_ARG(env, result)",5,,2194,2,,void
114308,BLOCK,-1,,<empty>,10,,2196,1,,void
114313,BLOCK,-1,,"{
    int copied = val.As<v8::String>()->WriteUtf8(
        env->isolate,
        buf,
        bufsize - 1,
        nullptr,
        v8::String::REPLACE_INVALID_UTF8 | v8::String::NO_NULL_TERMINATION);

    buf[copied] = '\0';
    if (result != nullptr) {
      *result = copied;
    }
  }",28,,2196,2,,void
114352,BLOCK,-1,,"{
      *result = copied;
    }",28,,2205,2,,void
114358,BLOCK,-1,,<empty>,10,,2208,1,,void
114363,BLOCK,-1,,"{
    *result = 0;
  }",33,,2208,2,,void
114379,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected);

  if (!buf) {
    CHECK_ARG(env, result);
    // V8 assumes UTF-16 length is the same as the number of characters.
    *result = val.As<v8::String>()->Length();
  } else if (bufsize != 0) {
    int copied = val.As<v8::String>()->Write(env->isolate,
                                             reinterpret_cast<uint16_t*>(buf),
                                             0,
                                             bufsize - 1,
                                             v8::String::NO_NULL_TERMINATION);

    buf[copied] = '\0';
    if (result != nullptr) {
      *result = copied;
    }
  } else if (result != nullptr) {
    *result = 0;
  }

  return napi_clear_last_error(env);
}",68,,2227,6,,void
114382,BLOCK,1,,<empty>,,,,2,,void
114384,BLOCK,-1,,CHECK_ENV(env),3,,2228,1,,void
114389,BLOCK,-1,,CHECK_ENV(env),3,,2228,2,,void
114396,BLOCK,1,,<empty>,,,,3,,void
114398,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2229,1,,void
114404,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2229,2,,void
114432,BLOCK,1,,<empty>,,,,4,,void
114434,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected)",3,,2232,1,,void
114441,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected)",3,,2232,2,,void
114450,BLOCK,-1,,"{
    CHECK_ARG(env, result);
    // V8 assumes UTF-16 length is the same as the number of characters.
    *result = val.As<v8::String>()->Length();
  }",13,,2234,2,,void
114454,BLOCK,1,,<empty>,,,,3,,void
114456,BLOCK,-1,,"CHECK_ARG(env, result)",5,,2235,1,,void
114462,BLOCK,-1,,"CHECK_ARG(env, result)",5,,2235,2,,void
114479,BLOCK,-1,,<empty>,10,,2238,1,,void
114484,BLOCK,-1,,"{
    int copied = val.As<v8::String>()->Write(env->isolate,
                                             reinterpret_cast<uint16_t*>(buf),
                                             0,
                                             bufsize - 1,
                                             v8::String::NO_NULL_TERMINATION);

    buf[copied] = '\0';
    if (result != nullptr) {
      *result = copied;
    }
  }",28,,2238,2,,void
114519,BLOCK,-1,,"{
      *result = copied;
    }",28,,2246,2,,void
114525,BLOCK,-1,,<empty>,10,,2249,1,,void
114530,BLOCK,-1,,"{
    *result = 0;
  }",33,,2249,2,,void
114544,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Isolate* isolate = env->isolate;
  v8::Local<v8::Boolean> b =
      v8impl::V8LocalValueFromJsValue(value)->ToBoolean(isolate);
  *result = v8impl::JsValueFromV8LocalValue(b);
  return GET_RETURN_STATUS(env);
}",64,,2258,4,,void
114547,BLOCK,1,,<empty>,,,,2,,void
114549,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2259,1,,void
114554,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2259,2,,void
114559,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2259,1,,void
114573,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2259,2,,void
114587,BLOCK,1,,<empty>,,,,3,,void
114589,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2260,1,,void
114595,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2260,2,,void
114604,BLOCK,1,,<empty>,,,,3,,void
114606,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2261,1,,void
114612,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2261,2,,void
114654,BLOCK,1,,<empty>,,,,3,,void
114671,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2286,4,,void
114673,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2286,1,,void
114678,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2286,2,,void
114683,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2286,1,,void
114697,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2286,2,,void
114709,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2286,1,,void
114715,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2286,2,,void
114722,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2286,1,,void
114728,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2286,2,,void
114758,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2286,1,,void
114760,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2286,1,,void
114766,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2286,2,,void
114785,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2286,1,,void
114793,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2286,2,,void
114831,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2287,4,,void
114833,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2287,1,,void
114838,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2287,2,,void
114843,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2287,1,,void
114857,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2287,2,,void
114869,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2287,1,,void
114875,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2287,2,,void
114882,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2287,1,,void
114888,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2287,2,,void
114918,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2287,1,,void
114920,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2287,1,,void
114926,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2287,2,,void
114945,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2287,1,,void
114953,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2287,2,,void
114991,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2288,4,,void
114993,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2288,1,,void
114998,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2288,2,,void
115003,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2288,1,,void
115017,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2288,2,,void
115029,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2288,1,,void
115035,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2288,2,,void
115042,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2288,1,,void
115048,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2288,2,,void
115078,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2288,1,,void
115080,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2288,1,,void
115086,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2288,2,,void
115105,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2288,1,,void
115113,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2288,2,,void
115154,BLOCK,-1,,"{
  return v8impl::Wrap(
      env, js_object, native_object, finalize_cb, finalize_hint, result);
}",52,,2297,7,,void
115172,BLOCK,-1,,"{
  return v8impl::Unwrap(env, obj, result, v8impl::KeepWrap);
}",51,,2304,4,,void
115190,BLOCK,-1,,"{
  return v8impl::Unwrap(env, obj, result, v8impl::RemoveWrap);
}",56,,2310,4,,void
115210,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Isolate* isolate = env->isolate;

  v8::Local<v8::Value> external_value = v8::External::New(isolate, data);

  if (finalize_cb) {
    // The Reference object will delete itself after invoking the finalizer
    // callback.
    v8impl::Reference::New(env,
                           external_value,
                           0,
                           v8impl::Ownership::kRuntime,
                           finalize_cb,
                           data,
                           finalize_hint);
  }

  *result = v8impl::JsValueFromV8LocalValue(external_value);

  return napi_clear_last_error(env);
}",65,,2318,6,,void
115213,BLOCK,1,,<empty>,,,,2,,void
115215,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2319,1,,void
115220,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2319,2,,void
115225,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2319,1,,void
115239,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2319,2,,void
115253,BLOCK,1,,<empty>,,,,3,,void
115255,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2320,1,,void
115261,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2320,2,,void
115293,BLOCK,-1,,"{
    // The Reference object will delete itself after invoking the finalizer
    // callback.
    v8impl::Reference::New(env,
                           external_value,
                           0,
                           v8impl::Ownership::kRuntime,
                           finalize_cb,
                           data,
                           finalize_hint);
  }",20,,2326,2,,void
115328,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;
  CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object);
  CHECK_ARG_WITH_PREAMBLE(env, type_tag);

  auto key = NAPI_PRIVATE_KEY(context, type_tag);
  auto maybe_has = obj->HasPrivate(context, key);
  CHECK_MAYBE_NOTHING_WITH_PREAMBLE(env, maybe_has, napi_generic_failure);
  RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, !maybe_has.FromJust(), napi_invalid_arg);

  auto tag = v8::BigInt::NewFromWords(
      context, 0, 2, reinterpret_cast<const uint64_t*>(type_tag));
  CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, tag, napi_generic_failure);

  auto maybe_set = obj->SetPrivate(context, key, tag.ToLocalChecked());
  CHECK_MAYBE_NOTHING_WITH_PREAMBLE(env, maybe_set, napi_generic_failure);
  RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, maybe_set.FromJust(), napi_generic_failure);

  return GET_RETURN_STATUS(env);
}",76,,2345,4,,void
115331,BLOCK,1,,<empty>,,,,2,,void
115333,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2346,1,,void
115338,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2346,2,,void
115343,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2346,1,,void
115357,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2346,2,,void
115397,BLOCK,1,,<empty>,,,,9,,void
115399,BLOCK,-1,,"CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object)",3,,2349,1,,void
115401,BLOCK,-1,,"CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object)",3,,2349,1,,void
115407,BLOCK,-1,,"CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object)",3,,2349,2,,void
115432,BLOCK,-1,,"CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object)",3,,2349,1,,void
115440,BLOCK,-1,,"CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object)",3,,2349,2,,void
115462,BLOCK,1,,<empty>,,,,4,,void
115464,BLOCK,-1,,"CHECK_ARG_WITH_PREAMBLE(env, type_tag)",3,,2350,1,,void
115470,BLOCK,-1,,"CHECK_ARG_WITH_PREAMBLE(env, type_tag)",3,,2350,2,,void
115487,BLOCK,1,,<empty>,,,,2,,void
115511,BLOCK,1,,<empty>,,,,6,,void
115513,BLOCK,-1,,"CHECK_MAYBE_NOTHING_WITH_PREAMBLE(env, maybe_has, napi_generic_failure)",3,,2354,1,,void
115521,BLOCK,-1,,"CHECK_MAYBE_NOTHING_WITH_PREAMBLE(env, maybe_has, napi_generic_failure)",3,,2354,2,,void
115541,BLOCK,1,,<empty>,,,,6,,void
115543,BLOCK,-1,,"RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, !maybe_has.FromJust(), napi_invalid_arg)",3,,2355,1,,void
115551,BLOCK,-1,,"RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, !maybe_has.FromJust(), napi_invalid_arg)",3,,2355,2,,void
115582,BLOCK,1,,<empty>,,,,6,,void
115584,BLOCK,-1,,"CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, tag, napi_generic_failure)",3,,2360,1,,void
115592,BLOCK,-1,,"CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, tag, napi_generic_failure)",3,,2360,2,,void
115621,BLOCK,1,,<empty>,,,,6,,void
115623,BLOCK,-1,,"CHECK_MAYBE_NOTHING_WITH_PREAMBLE(env, maybe_set, napi_generic_failure)",3,,2363,1,,void
115631,BLOCK,-1,,"CHECK_MAYBE_NOTHING_WITH_PREAMBLE(env, maybe_set, napi_generic_failure)",3,,2363,2,,void
115650,BLOCK,1,,<empty>,,,,6,,void
115652,BLOCK,-1,,"RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, maybe_set.FromJust(), napi_generic_failure)",3,,2364,1,,void
115659,BLOCK,-1,,"RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, maybe_set.FromJust(), napi_generic_failure)",3,,2364,2,,void
115674,BLOCK,1,,<empty>,,,,3,,void
115692,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;
  CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object);
  CHECK_ARG_WITH_PREAMBLE(env, type_tag);
  CHECK_ARG_WITH_PREAMBLE(env, result);

  auto maybe_value =
      obj->GetPrivate(context, NAPI_PRIVATE_KEY(context, type_tag));
  CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, maybe_value, napi_generic_failure);
  v8::Local<v8::Value> val = maybe_value.ToLocalChecked();

  // We consider the type check to have failed unless we reach the line below
  // where we set whether the type check succeeded or not based on the
  // comparison of the two type tags.
  *result = false;
  if (val->IsBigInt()) {
    int sign;
    int size = 2;
    napi_type_tag tag;
    val.As<v8::BigInt>()->ToWordsArray(
        &sign, &size, reinterpret_cast<uint64_t*>(&tag));
    if (sign == 0) {
      if (size == 2) {
        *result =
            (tag.lower == type_tag->lower && tag.upper == type_tag->upper);
   ...",65,,2373,5,,void
115695,BLOCK,1,,<empty>,,,,2,,void
115697,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2374,1,,void
115702,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2374,2,,void
115707,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2374,1,,void
115721,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2374,2,,void
115761,BLOCK,1,,<empty>,,,,9,,void
115763,BLOCK,-1,,"CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object)",3,,2377,1,,void
115765,BLOCK,-1,,"CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object)",3,,2377,1,,void
115771,BLOCK,-1,,"CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object)",3,,2377,2,,void
115796,BLOCK,-1,,"CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object)",3,,2377,1,,void
115804,BLOCK,-1,,"CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object)",3,,2377,2,,void
115826,BLOCK,1,,<empty>,,,,4,,void
115828,BLOCK,-1,,"CHECK_ARG_WITH_PREAMBLE(env, type_tag)",3,,2378,1,,void
115834,BLOCK,-1,,"CHECK_ARG_WITH_PREAMBLE(env, type_tag)",3,,2378,2,,void
115849,BLOCK,1,,<empty>,,,,4,,void
115851,BLOCK,-1,,"CHECK_ARG_WITH_PREAMBLE(env, result)",3,,2379,1,,void
115857,BLOCK,-1,,"CHECK_ARG_WITH_PREAMBLE(env, result)",3,,2379,2,,void
115879,BLOCK,1,,<empty>,,,,2,,void
115894,BLOCK,1,,<empty>,,,,6,,void
115896,BLOCK,-1,,"CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, maybe_value, napi_generic_failure)",3,,2383,1,,void
115904,BLOCK,-1,,"CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, maybe_value, napi_generic_failure)",3,,2383,2,,void
115939,BLOCK,-1,,"{
    int sign;
    int size = 2;
    napi_type_tag tag;
    val.As<v8::BigInt>()->ToWordsArray(
        &sign, &size, reinterpret_cast<uint64_t*>(&tag));
    if (sign == 0) {
      if (size == 2) {
        *result =
            (tag.lower == type_tag->lower && tag.upper == type_tag->upper);
      } else if (size == 1) {
        *result = (tag.lower == type_tag->lower && 0 == type_tag->upper);
      } else if (size == 0) {
        *result = (0 == type_tag->lower && 0 == type_tag->upper);
      }
    }
  }",24,,2390,2,,void
115965,BLOCK,-1,,"{
      if (size == 2) {
        *result =
            (tag.lower == type_tag->lower && tag.upper == type_tag->upper);
      } else if (size == 1) {
        *result = (tag.lower == type_tag->lower && 0 == type_tag->upper);
      } else if (size == 0) {
        *result = (0 == type_tag->lower && 0 == type_tag->upper);
      }
    }",20,,2396,2,,void
115970,BLOCK,-1,,"{
        *result =
            (tag.lower == type_tag->lower && tag.upper == type_tag->upper);
      }",22,,2397,2,,void
115990,BLOCK,-1,,<empty>,14,,2400,1,,void
115995,BLOCK,-1,,"{
        *result = (tag.lower == type_tag->lower && 0 == type_tag->upper);
      }",29,,2400,2,,void
116013,BLOCK,-1,,<empty>,14,,2402,1,,void
116018,BLOCK,-1,,"{
        *result = (0 == type_tag->lower && 0 == type_tag->upper);
      }",29,,2402,2,,void
116036,BLOCK,1,,<empty>,,,,3,,void
116053,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsExternal(), napi_invalid_arg);

  v8::Local<v8::External> external_value = val.As<v8::External>();
  *result = external_value->Value();

  return napi_clear_last_error(env);
}",63,,2413,4,,void
116056,BLOCK,1,,<empty>,,,,2,,void
116058,BLOCK,-1,,CHECK_ENV(env),3,,2414,1,,void
116063,BLOCK,-1,,CHECK_ENV(env),3,,2414,2,,void
116070,BLOCK,1,,<empty>,,,,3,,void
116072,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2415,1,,void
116078,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2415,2,,void
116087,BLOCK,1,,<empty>,,,,3,,void
116089,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2416,1,,void
116095,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2416,2,,void
116123,BLOCK,1,,<empty>,,,,4,,void
116125,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsExternal(), napi_invalid_arg)",3,,2419,1,,void
116132,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsExternal(), napi_invalid_arg)",3,,2419,2,,void
116169,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> v8_value = v8impl::V8LocalValueFromJsValue(value);
  if (env->module_api_version <= 8) {
    if (!(v8_value->IsObject() || v8_value->IsFunction() ||
          v8_value->IsSymbol())) {
      return napi_set_last_error(env, napi_invalid_arg);
    }
  }

  v8impl::Reference* reference = v8impl::Reference::New(
      env, v8_value, initial_refcount, v8impl::Ownership::kUserland);

  *result = reinterpret_cast<napi_ref>(reference);
  return napi_clear_last_error(env);
}",64,,2431,5,,void
116172,BLOCK,1,,<empty>,,,,2,,void
116174,BLOCK,-1,,CHECK_ENV(env),3,,2434,1,,void
116179,BLOCK,-1,,CHECK_ENV(env),3,,2434,2,,void
116186,BLOCK,1,,<empty>,,,,3,,void
116188,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2435,1,,void
116194,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2435,2,,void
116203,BLOCK,1,,<empty>,,,,3,,void
116205,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2436,1,,void
116211,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2436,2,,void
116238,BLOCK,-1,,"{
    if (!(v8_value->IsObject() || v8_value->IsFunction() ||
          v8_value->IsSymbol())) {
      return napi_set_last_error(env, napi_invalid_arg);
    }
  }",37,,2439,2,,void
116255,BLOCK,-1,,"{
      return napi_set_last_error(env, napi_invalid_arg);
    }",34,,2441,2,,void
116291,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, ref);

  delete reinterpret_cast<v8impl::Reference*>(ref);

  return napi_clear_last_error(env);
}",74,,2455,3,,void
116294,BLOCK,1,,<empty>,,,,2,,void
116296,BLOCK,-1,,CHECK_ENV(env),3,,2458,1,,void
116301,BLOCK,-1,,CHECK_ENV(env),3,,2458,2,,void
116308,BLOCK,1,,<empty>,,,,3,,void
116310,BLOCK,-1,,"CHECK_ARG(env, ref)",3,,2459,1,,void
116316,BLOCK,-1,,"CHECK_ARG(env, ref)",3,,2459,2,,void
116335,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, ref);

  v8impl::Reference* reference = reinterpret_cast<v8impl::Reference*>(ref);
  uint32_t count = reference->Ref();

  if (result != nullptr) {
    *result = count;
  }

  return napi_clear_last_error(env);
}",61,,2473,4,,void
116338,BLOCK,1,,<empty>,,,,2,,void
116340,BLOCK,-1,,CHECK_ENV(env),3,,2476,1,,void
116345,BLOCK,-1,,CHECK_ENV(env),3,,2476,2,,void
116352,BLOCK,1,,<empty>,,,,3,,void
116354,BLOCK,-1,,"CHECK_ARG(env, ref)",3,,2477,1,,void
116360,BLOCK,-1,,"CHECK_ARG(env, ref)",3,,2477,2,,void
116383,BLOCK,-1,,"{
    *result = count;
  }",26,,2482,2,,void
116397,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, ref);

  v8impl::Reference* reference = reinterpret_cast<v8impl::Reference*>(ref);

  if (reference->RefCount() == 0) {
    return napi_set_last_error(env, napi_generic_failure);
  }

  uint32_t count = reference->Unref();

  if (result != nullptr) {
    *result = count;
  }

  return napi_clear_last_error(env);
}",63,,2495,4,,void
116400,BLOCK,1,,<empty>,,,,2,,void
116402,BLOCK,-1,,CHECK_ENV(env),3,,2498,1,,void
116407,BLOCK,-1,,CHECK_ENV(env),3,,2498,2,,void
116414,BLOCK,1,,<empty>,,,,3,,void
116416,BLOCK,-1,,"CHECK_ARG(env, ref)",3,,2499,1,,void
116422,BLOCK,-1,,"CHECK_ARG(env, ref)",3,,2499,2,,void
116441,BLOCK,-1,,"{
    return napi_set_last_error(env, napi_generic_failure);
  }",35,,2503,2,,void
116457,BLOCK,-1,,"{
    *result = count;
  }",26,,2509,2,,void
116471,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, ref);
  CHECK_ARG(env, result);

  v8impl::Reference* reference = reinterpret_cast<v8impl::Reference*>(ref);
  *result = v8impl::JsValueFromV8LocalValue(reference->Get());

  return napi_clear_last_error(env);
}",69,,2521,4,,void
116474,BLOCK,1,,<empty>,,,,2,,void
116476,BLOCK,-1,,CHECK_ENV(env),3,,2524,1,,void
116481,BLOCK,-1,,CHECK_ENV(env),3,,2524,2,,void
116488,BLOCK,1,,<empty>,,,,3,,void
116490,BLOCK,-1,,"CHECK_ARG(env, ref)",3,,2525,1,,void
116496,BLOCK,-1,,"CHECK_ARG(env, ref)",3,,2525,2,,void
116505,BLOCK,1,,<empty>,,,,3,,void
116507,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2526,1,,void
116513,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2526,2,,void
116544,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsHandleScopeFromV8HandleScope(
      new v8impl::HandleScopeWrapper(env->isolate));
  env->open_handle_scopes++;
  return napi_clear_last_error(env);
}",74,,2535,3,,void
116547,BLOCK,1,,<empty>,,,,2,,void
116549,BLOCK,-1,,CHECK_ENV(env),3,,2538,1,,void
116554,BLOCK,-1,,CHECK_ENV(env),3,,2538,2,,void
116561,BLOCK,1,,<empty>,,,,3,,void
116563,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2539,1,,void
116569,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2539,2,,void
116599,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, scope);
  if (env->open_handle_scopes == 0) {
    return napi_handle_scope_mismatch;
  }

  env->open_handle_scopes--;
  delete v8impl::V8HandleScopeFromJsHandleScope(scope);
  return napi_clear_last_error(env);
}",73,,2548,3,,void
116602,BLOCK,1,,<empty>,,,,2,,void
116604,BLOCK,-1,,CHECK_ENV(env),3,,2551,1,,void
116609,BLOCK,-1,,CHECK_ENV(env),3,,2551,2,,void
116616,BLOCK,1,,<empty>,,,,3,,void
116618,BLOCK,-1,,"CHECK_ARG(env, scope)",3,,2552,1,,void
116624,BLOCK,-1,,"CHECK_ARG(env, scope)",3,,2552,2,,void
116636,BLOCK,-1,,"{
    return napi_handle_scope_mismatch;
  }",37,,2553,2,,void
116657,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsEscapableHandleScopeFromV8EscapableHandleScope(
      new v8impl::EscapableHandleScopeWrapper(env->isolate));
  env->open_handle_scopes++;
  return napi_clear_last_error(env);
}",56,,2563,3,,void
116660,BLOCK,1,,<empty>,,,,2,,void
116662,BLOCK,-1,,CHECK_ENV(env),3,,2566,1,,void
116667,BLOCK,-1,,CHECK_ENV(env),3,,2566,2,,void
116674,BLOCK,1,,<empty>,,,,3,,void
116676,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2567,1,,void
116682,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2567,2,,void
116712,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, scope);
  if (env->open_handle_scopes == 0) {
    return napi_handle_scope_mismatch;
  }

  delete v8impl::V8EscapableHandleScopeFromJsEscapableHandleScope(scope);
  env->open_handle_scopes--;
  return napi_clear_last_error(env);
}",54,,2576,3,,void
116715,BLOCK,1,,<empty>,,,,2,,void
116717,BLOCK,-1,,CHECK_ENV(env),3,,2579,1,,void
116722,BLOCK,-1,,CHECK_ENV(env),3,,2579,2,,void
116729,BLOCK,1,,<empty>,,,,3,,void
116731,BLOCK,-1,,"CHECK_ARG(env, scope)",3,,2580,1,,void
116737,BLOCK,-1,,"CHECK_ARG(env, scope)",3,,2580,2,,void
116749,BLOCK,-1,,"{
    return napi_handle_scope_mismatch;
  }",37,,2581,2,,void
116772,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, scope);
  CHECK_ARG(env, escapee);
  CHECK_ARG(env, result);

  v8impl::EscapableHandleScopeWrapper* s =
      v8impl::V8EscapableHandleScopeFromJsEscapableHandleScope(scope);
  if (!s->escape_called()) {
    *result = v8impl::JsValueFromV8LocalValue(
        s->Escape(v8impl::V8LocalValueFromJsValue(escapee)));
    return napi_clear_last_error(env);
  }
  return napi_set_last_error(env, napi_escape_called_twice);
}",63,,2593,5,,void
116775,BLOCK,1,,<empty>,,,,2,,void
116777,BLOCK,-1,,CHECK_ENV(env),3,,2596,1,,void
116782,BLOCK,-1,,CHECK_ENV(env),3,,2596,2,,void
116789,BLOCK,1,,<empty>,,,,3,,void
116791,BLOCK,-1,,"CHECK_ARG(env, scope)",3,,2597,1,,void
116797,BLOCK,-1,,"CHECK_ARG(env, scope)",3,,2597,2,,void
116806,BLOCK,1,,<empty>,,,,3,,void
116808,BLOCK,-1,,"CHECK_ARG(env, escapee)",3,,2598,1,,void
116814,BLOCK,-1,,"CHECK_ARG(env, escapee)",3,,2598,2,,void
116823,BLOCK,1,,<empty>,,,,3,,void
116825,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2599,1,,void
116831,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2599,2,,void
116851,BLOCK,-1,,"{
    *result = v8impl::JsValueFromV8LocalValue(
        s->Escape(v8impl::V8LocalValueFromJsValue(escapee)));
    return napi_clear_last_error(env);
  }",28,,2603,2,,void
116883,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, constructor);
  if (argc > 0) {
    CHECK_ARG(env, argv);
  }
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Function> ctor;
  CHECK_TO_FUNCTION(env, ctor, constructor);

  auto maybe = ctor->NewInstance(
      context,
      argc,
      reinterpret_cast<v8::Local<v8::Value>*>(const_cast<napi_value*>(argv)));

  CHECK_MAYBE_EMPTY(env, maybe, napi_pending_exception);

  *result = v8impl::JsValueFromV8LocalValue(maybe.ToLocalChecked());
  return GET_RETURN_STATUS(env);
}",62,,2615,6,,void
116886,BLOCK,1,,<empty>,,,,2,,void
116888,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2616,1,,void
116893,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2616,2,,void
116898,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2616,1,,void
116912,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2616,2,,void
116926,BLOCK,1,,<empty>,,,,3,,void
116928,BLOCK,-1,,"CHECK_ARG(env, constructor)",3,,2617,1,,void
116934,BLOCK,-1,,"CHECK_ARG(env, constructor)",3,,2617,2,,void
116944,BLOCK,-1,,"{
    CHECK_ARG(env, argv);
  }",17,,2618,2,,void
116948,BLOCK,1,,<empty>,,,,3,,void
116950,BLOCK,-1,,"CHECK_ARG(env, argv)",5,,2619,1,,void
116956,BLOCK,-1,,"CHECK_ARG(env, argv)",5,,2619,2,,void
116965,BLOCK,1,,<empty>,,,,3,,void
116967,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2621,1,,void
116973,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2621,2,,void
117006,BLOCK,1,,<empty>,,,,4,,void
117008,BLOCK,-1,,"CHECK_TO_FUNCTION(env, ctor, constructor)",3,,2626,1,,void
117010,BLOCK,-1,,"CHECK_TO_FUNCTION(env, ctor, constructor)",3,,2626,1,,void
117016,BLOCK,-1,,"CHECK_TO_FUNCTION(env, ctor, constructor)",3,,2626,2,,void
117038,BLOCK,-1,,"CHECK_TO_FUNCTION(env, ctor, constructor)",3,,2626,1,,void
117045,BLOCK,-1,,"CHECK_TO_FUNCTION(env, ctor, constructor)",3,,2626,2,,void
117076,BLOCK,1,,<empty>,,,,5,,void
117078,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe, napi_pending_exception)",3,,2633,1,,void
117086,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe, napi_pending_exception)",3,,2633,2,,void
117106,BLOCK,1,,<empty>,,,,3,,void
117124,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, object);
  CHECK_ARG(env, result);

  *result = false;

  v8::Local<v8::Object> ctor;
  v8::Local<v8::Context> context = env->context();

  CHECK_TO_OBJECT(env, context, ctor, constructor);

  if (!ctor->IsFunction()) {
    napi_throw_type_error(
        env, ""ERR_NAPI_CONS_FUNCTION"", ""Constructor must be a function"");

    return napi_set_last_error(env, napi_function_expected);
  }

  napi_status status = napi_generic_failure;

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(object);
  auto maybe_result = val->InstanceOf(context, ctor);
  CHECK_MAYBE_NOTHING(env, maybe_result, status);
  *result = maybe_result.FromJust();
  return GET_RETURN_STATUS(env);
}",54,,2642,5,,void
117127,BLOCK,1,,<empty>,,,,2,,void
117129,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2643,1,,void
117134,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2643,2,,void
117139,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2643,1,,void
117153,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2643,2,,void
117167,BLOCK,1,,<empty>,,,,3,,void
117169,BLOCK,-1,,"CHECK_ARG(env, object)",3,,2644,1,,void
117175,BLOCK,-1,,"CHECK_ARG(env, object)",3,,2644,2,,void
117184,BLOCK,1,,<empty>,,,,3,,void
117186,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2645,1,,void
117192,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2645,2,,void
117231,BLOCK,1,,<empty>,,,,7,,void
117233,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, ctor, constructor)",3,,2652,1,,void
117235,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, ctor, constructor)",3,,2652,1,,void
117241,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, ctor, constructor)",3,,2652,2,,void
117260,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, ctor, constructor)",3,,2652,1,,void
117268,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, ctor, constructor)",3,,2652,2,,void
117287,BLOCK,-1,,"{
    napi_throw_type_error(
        env, ""ERR_NAPI_CONS_FUNCTION"", ""Constructor must be a function"");

    return napi_set_last_error(env, napi_function_expected);
  }",28,,2654,2,,void
117328,BLOCK,1,,<empty>,,,,6,,void
117330,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, maybe_result, status)",3,,2665,1,,void
117338,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, maybe_result, status)",3,,2665,2,,void
117354,BLOCK,1,,<empty>,,,,3,,void
117370,BLOCK,-1,,"{
  // NAPI_PREAMBLE is not used here: this function must execute when there is a
  // pending exception.
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = !env->last_exception.IsEmpty();
  return napi_clear_last_error(env);
}",78,,2671,3,,void
117373,BLOCK,1,,<empty>,,,,2,,void
117375,BLOCK,-1,,CHECK_ENV(env),3,,2674,1,,void
117380,BLOCK,-1,,CHECK_ENV(env),3,,2674,2,,void
117387,BLOCK,1,,<empty>,,,,3,,void
117389,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2675,1,,void
117395,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2675,2,,void
117419,BLOCK,-1,,"{
  // NAPI_PREAMBLE is not used here: this function must execute when there is a
  // pending exception.
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  if (env->last_exception.IsEmpty()) {
    return napi_get_undefined(env, result);
  } else {
    *result = v8impl::JsValueFromV8LocalValue(
        v8::Local<v8::Value>::New(env->isolate, env->last_exception));
    env->last_exception.Reset();
  }

  return napi_clear_last_error(env);
}",78,,2682,3,,void
117422,BLOCK,1,,<empty>,,,,2,,void
117424,BLOCK,-1,,CHECK_ENV(env),3,,2685,1,,void
117429,BLOCK,-1,,CHECK_ENV(env),3,,2685,2,,void
117436,BLOCK,1,,<empty>,,,,3,,void
117438,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2686,1,,void
117444,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2686,2,,void
117457,BLOCK,-1,,"{
    return napi_get_undefined(env, result);
  }",38,,2688,2,,void
117463,BLOCK,-1,,"{
    *result = v8impl::JsValueFromV8LocalValue(
        v8::Local<v8::Value>::New(env->isolate, env->last_exception));
    env->last_exception.Reset();
  }",10,,2690,1,,void
117504,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  *result = val->IsArrayBuffer();

  return napi_clear_last_error(env);
}",58,,2701,4,,void
117507,BLOCK,1,,<empty>,,,,2,,void
117509,BLOCK,-1,,CHECK_ENV(env),3,,2702,1,,void
117514,BLOCK,-1,,CHECK_ENV(env),3,,2702,2,,void
117521,BLOCK,1,,<empty>,,,,3,,void
117523,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2703,1,,void
117529,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2703,2,,void
117538,BLOCK,1,,<empty>,,,,3,,void
117540,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2704,1,,void
117546,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2704,2,,void
117584,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Isolate* isolate = env->isolate;
  v8::Local<v8::ArrayBuffer> buffer =
      v8::ArrayBuffer::New(isolate, byte_length);

  // Optionally return a pointer to the buffer's data, to avoid another call to
  // retrieve it.
  if (data != nullptr) {
    *data = buffer->Data();
  }

  *result = v8impl::JsValueFromV8LocalValue(buffer);
  return GET_RETURN_STATUS(env);
}",68,,2715,5,,void
117587,BLOCK,1,,<empty>,,,,2,,void
117589,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2716,1,,void
117594,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2716,2,,void
117599,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2716,1,,void
117613,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2716,2,,void
117627,BLOCK,1,,<empty>,,,,3,,void
117629,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2717,1,,void
117635,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2717,2,,void
117669,BLOCK,-1,,"{
    *data = buffer->Data();
  }",24,,2725,2,,void
117688,BLOCK,1,,<empty>,,,,3,,void
117708,BLOCK,-1,,"{
  // The API contract here is that the cleanup function runs on the JS thread,
  // and is able to use napi_env. Implementing that properly is hard, so use the
  // `Buffer` variant for easier implementation.
  napi_value buffer;
  STATUS_CALL(napi_create_external_buffer(
      env, byte_length, external_data, finalize_cb, finalize_hint, &buffer));
  return napi_get_typedarray_info(
      env, buffer, nullptr, nullptr, nullptr, result, nullptr);
}",54,,2739,7,,void
117712,BLOCK,1,,<empty>,,,,4,,void
117714,BLOCK,-1,,"STATUS_CALL(napi_create_external_buffer(
      env, byte_length, external_data, finalize_cb, finalize_hint, &buffer))",3,,2744,1,,void
117730,BLOCK,-1,,<empty>,3,,2744,2,,void
117750,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, arraybuffer);

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(arraybuffer);
  RETURN_STATUS_IF_FALSE(env, value->IsArrayBuffer(), napi_invalid_arg);

  v8::Local<v8::ArrayBuffer> ab = value.As<v8::ArrayBuffer>();

  if (data != nullptr) {
    *data = ab->Data();
  }

  if (byte_length != nullptr) {
    *byte_length = ab->ByteLength();
  }

  return napi_clear_last_error(env);
}",71,,2753,5,,void
117753,BLOCK,1,,<empty>,,,,2,,void
117755,BLOCK,-1,,CHECK_ENV(env),3,,2754,1,,void
117760,BLOCK,-1,,CHECK_ENV(env),3,,2754,2,,void
117767,BLOCK,1,,<empty>,,,,3,,void
117769,BLOCK,-1,,"CHECK_ARG(env, arraybuffer)",3,,2755,1,,void
117775,BLOCK,-1,,"CHECK_ARG(env, arraybuffer)",3,,2755,2,,void
117803,BLOCK,1,,<empty>,,,,4,,void
117805,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsArrayBuffer(), napi_invalid_arg)",3,,2758,1,,void
117812,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsArrayBuffer(), napi_invalid_arg)",3,,2758,2,,void
117836,BLOCK,-1,,"{
    *data = ab->Data();
  }",24,,2762,2,,void
117848,BLOCK,-1,,"{
    *byte_length = ab->ByteLength();
  }",31,,2766,2,,void
117865,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  *result = val->IsTypedArray();

  return napi_clear_last_error(env);
}",57,,2775,4,,void
117868,BLOCK,1,,<empty>,,,,2,,void
117870,BLOCK,-1,,CHECK_ENV(env),3,,2776,1,,void
117875,BLOCK,-1,,CHECK_ENV(env),3,,2776,2,,void
117882,BLOCK,1,,<empty>,,,,3,,void
117884,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2777,1,,void
117890,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2777,2,,void
117899,BLOCK,1,,<empty>,,,,3,,void
117901,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2778,1,,void
117907,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2778,2,,void
117947,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, arraybuffer);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(arraybuffer);
  RETURN_STATUS_IF_FALSE(env, value->IsArrayBuffer(), napi_invalid_arg);

  v8::Local<v8::ArrayBuffer> buffer = value.As<v8::ArrayBuffer>();
  v8::Local<v8::TypedArray> typedArray;

  switch (type) {
    case napi_int8_array:
      CREATE_TYPED_ARRAY(
          env, Int8Array, 1, buffer, byte_offset, length, typedArray);
      break;
    case napi_uint8_array:
      CREATE_TYPED_ARRAY(
          env, Uint8Array, 1, buffer, byte_offset, length, typedArray);
      break;
    case napi_uint8_clamped_array:
      CREATE_TYPED_ARRAY(
          env, Uint8ClampedArray, 1, buffer, byte_offset, length, typedArray);
      break;
    case napi_int16_array:
      CREATE_TYPED_ARRAY(
          env, Int16Array, 2, buffer, byte_offset, length, typedArray);
      break;
    case napi_uint16_array:
      CREATE_TYPED_ARRAY(
          env, Uint...",67,,2791,7,,void
117950,BLOCK,1,,<empty>,,,,2,,void
117952,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2792,1,,void
117957,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2792,2,,void
117962,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2792,1,,void
117976,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2792,2,,void
117990,BLOCK,1,,<empty>,,,,3,,void
117992,BLOCK,-1,,"CHECK_ARG(env, arraybuffer)",3,,2793,1,,void
117998,BLOCK,-1,,"CHECK_ARG(env, arraybuffer)",3,,2793,2,,void
118007,BLOCK,1,,<empty>,,,,3,,void
118009,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2794,1,,void
118015,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2794,2,,void
118043,BLOCK,1,,<empty>,,,,4,,void
118045,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsArrayBuffer(), napi_invalid_arg)",3,,2797,1,,void
118052,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsArrayBuffer(), napi_invalid_arg)",3,,2797,2,,void
118083,BLOCK,-1,,"{
    case napi_int8_array:
      CREATE_TYPED_ARRAY(
          env, Int8Array, 1, buffer, byte_offset, length, typedArray);
      break;
    case napi_uint8_array:
      CREATE_TYPED_ARRAY(
          env, Uint8Array, 1, buffer, byte_offset, length, typedArray);
      break;
    case napi_uint8_clamped_array:
      CREATE_TYPED_ARRAY(
          env, Uint8ClampedArray, 1, buffer, byte_offset, length, typedArray);
      break;
    case napi_int16_array:
      CREATE_TYPED_ARRAY(
          env, Int16Array, 2, buffer, byte_offset, length, typedArray);
      break;
    case napi_uint16_array:
      CREATE_TYPED_ARRAY(
          env, Uint16Array, 2, buffer, byte_offset, length, typedArray);
      break;
    case napi_int32_array:
      CREATE_TYPED_ARRAY(
          env, Int32Array, 4, buffer, byte_offset, length, typedArray);
      break;
    case napi_uint32_array:
      CREATE_TYPED_ARRAY(
          env, Uint32Array, 4, buffer, byte_offset, length, typedArray);
      break;
    case nap...",17,,2802,2,,void
118093,BLOCK,1,,<empty>,,,,7,,void
118095,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int8Array, 1, buffer, byte_offset, length, typedArray)",7,,2804,1,,void
118100,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int8Array, 1, buffer, byte_offset, length, typedArray)",7,,2804,2,,void
118102,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int8Array, 1, buffer, byte_offset, length, typedArray)",7,,2804,1,,void
118110,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int8Array, 1, buffer, byte_offset, length, typedArray)",7,,2804,2,,void
118121,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int8Array, 1, buffer, byte_offset, length, typedArray)",7,,2804,1,,void
118134,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int8Array, 1, buffer, byte_offset, length, typedArray)",7,,2804,2,,void
118166,BLOCK,1,,<empty>,,,,7,,void
118168,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint8Array, 1, buffer, byte_offset, length, typedArray)",7,,2808,1,,void
118173,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint8Array, 1, buffer, byte_offset, length, typedArray)",7,,2808,2,,void
118175,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint8Array, 1, buffer, byte_offset, length, typedArray)",7,,2808,1,,void
118183,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint8Array, 1, buffer, byte_offset, length, typedArray)",7,,2808,2,,void
118194,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint8Array, 1, buffer, byte_offset, length, typedArray)",7,,2808,1,,void
118207,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint8Array, 1, buffer, byte_offset, length, typedArray)",7,,2808,2,,void
118239,BLOCK,1,,<empty>,,,,7,,void
118241,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint8ClampedArray, 1, buffer, byte_offset, length, typedArray)",7,,2812,1,,void
118246,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint8ClampedArray, 1, buffer, byte_offset, length, typedArray)",7,,2812,2,,void
118248,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint8ClampedArray, 1, buffer, byte_offset, length, typedArray)",7,,2812,1,,void
118256,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint8ClampedArray, 1, buffer, byte_offset, length, typedArray)",7,,2812,2,,void
118267,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint8ClampedArray, 1, buffer, byte_offset, length, typedArray)",7,,2812,1,,void
118280,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint8ClampedArray, 1, buffer, byte_offset, length, typedArray)",7,,2812,2,,void
118312,BLOCK,1,,<empty>,,,,7,,void
118314,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int16Array, 2, buffer, byte_offset, length, typedArray)",7,,2816,1,,void
118319,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int16Array, 2, buffer, byte_offset, length, typedArray)",7,,2816,2,,void
118321,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int16Array, 2, buffer, byte_offset, length, typedArray)",7,,2816,1,,void
118329,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int16Array, 2, buffer, byte_offset, length, typedArray)",7,,2816,2,,void
118340,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int16Array, 2, buffer, byte_offset, length, typedArray)",7,,2816,1,,void
118353,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int16Array, 2, buffer, byte_offset, length, typedArray)",7,,2816,2,,void
118385,BLOCK,1,,<empty>,,,,7,,void
118387,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint16Array, 2, buffer, byte_offset, length, typedArray)",7,,2820,1,,void
118392,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint16Array, 2, buffer, byte_offset, length, typedArray)",7,,2820,2,,void
118394,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint16Array, 2, buffer, byte_offset, length, typedArray)",7,,2820,1,,void
118402,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint16Array, 2, buffer, byte_offset, length, typedArray)",7,,2820,2,,void
118413,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint16Array, 2, buffer, byte_offset, length, typedArray)",7,,2820,1,,void
118426,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint16Array, 2, buffer, byte_offset, length, typedArray)",7,,2820,2,,void
118458,BLOCK,1,,<empty>,,,,7,,void
118460,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int32Array, 4, buffer, byte_offset, length, typedArray)",7,,2824,1,,void
118465,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int32Array, 4, buffer, byte_offset, length, typedArray)",7,,2824,2,,void
118467,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int32Array, 4, buffer, byte_offset, length, typedArray)",7,,2824,1,,void
118475,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int32Array, 4, buffer, byte_offset, length, typedArray)",7,,2824,2,,void
118486,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int32Array, 4, buffer, byte_offset, length, typedArray)",7,,2824,1,,void
118499,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int32Array, 4, buffer, byte_offset, length, typedArray)",7,,2824,2,,void
118531,BLOCK,1,,<empty>,,,,7,,void
118533,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint32Array, 4, buffer, byte_offset, length, typedArray)",7,,2828,1,,void
118538,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint32Array, 4, buffer, byte_offset, length, typedArray)",7,,2828,2,,void
118540,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint32Array, 4, buffer, byte_offset, length, typedArray)",7,,2828,1,,void
118548,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint32Array, 4, buffer, byte_offset, length, typedArray)",7,,2828,2,,void
118559,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint32Array, 4, buffer, byte_offset, length, typedArray)",7,,2828,1,,void
118572,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint32Array, 4, buffer, byte_offset, length, typedArray)",7,,2828,2,,void
118604,BLOCK,1,,<empty>,,,,7,,void
118606,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Float32Array, 4, buffer, byte_offset, length, typedArray)",7,,2832,1,,void
118611,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Float32Array, 4, buffer, byte_offset, length, typedArray)",7,,2832,2,,void
118613,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Float32Array, 4, buffer, byte_offset, length, typedArray)",7,,2832,1,,void
118621,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Float32Array, 4, buffer, byte_offset, length, typedArray)",7,,2832,2,,void
118632,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Float32Array, 4, buffer, byte_offset, length, typedArray)",7,,2832,1,,void
118645,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Float32Array, 4, buffer, byte_offset, length, typedArray)",7,,2832,2,,void
118677,BLOCK,1,,<empty>,,,,7,,void
118679,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Float64Array, 8, buffer, byte_offset, length, typedArray)",7,,2836,1,,void
118684,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Float64Array, 8, buffer, byte_offset, length, typedArray)",7,,2836,2,,void
118686,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Float64Array, 8, buffer, byte_offset, length, typedArray)",7,,2836,1,,void
118694,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Float64Array, 8, buffer, byte_offset, length, typedArray)",7,,2836,2,,void
118705,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Float64Array, 8, buffer, byte_offset, length, typedArray)",7,,2836,1,,void
118718,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Float64Array, 8, buffer, byte_offset, length, typedArray)",7,,2836,2,,void
118750,BLOCK,1,,<empty>,,,,7,,void
118752,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, BigInt64Array, 8, buffer, byte_offset, length, typedArray)",7,,2840,1,,void
118757,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, BigInt64Array, 8, buffer, byte_offset, length, typedArray)",7,,2840,2,,void
118759,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, BigInt64Array, 8, buffer, byte_offset, length, typedArray)",7,,2840,1,,void
118767,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, BigInt64Array, 8, buffer, byte_offset, length, typedArray)",7,,2840,2,,void
118778,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, BigInt64Array, 8, buffer, byte_offset, length, typedArray)",7,,2840,1,,void
118791,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, BigInt64Array, 8, buffer, byte_offset, length, typedArray)",7,,2840,2,,void
118823,BLOCK,1,,<empty>,,,,7,,void
118825,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, BigUint64Array, 8, buffer, byte_offset, length, typedArray)",7,,2844,1,,void
118830,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, BigUint64Array, 8, buffer, byte_offset, length, typedArray)",7,,2844,2,,void
118832,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, BigUint64Array, 8, buffer, byte_offset, length, typedArray)",7,,2844,1,,void
118840,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, BigUint64Array, 8, buffer, byte_offset, length, typedArray)",7,,2844,2,,void
118851,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, BigUint64Array, 8, buffer, byte_offset, length, typedArray)",7,,2844,1,,void
118864,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, BigUint64Array, 8, buffer, byte_offset, length, typedArray)",7,,2844,2,,void
118903,BLOCK,1,,<empty>,,,,3,,void
118924,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, typedarray);

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(typedarray);
  RETURN_STATUS_IF_FALSE(env, value->IsTypedArray(), napi_invalid_arg);

  v8::Local<v8::TypedArray> array = value.As<v8::TypedArray>();

  if (type != nullptr) {
    if (value->IsInt8Array()) {
      *type = napi_int8_array;
    } else if (value->IsUint8Array()) {
      *type = napi_uint8_array;
    } else if (value->IsUint8ClampedArray()) {
      *type = napi_uint8_clamped_array;
    } else if (value->IsInt16Array()) {
      *type = napi_int16_array;
    } else if (value->IsUint16Array()) {
      *type = napi_uint16_array;
    } else if (value->IsInt32Array()) {
      *type = napi_int32_array;
    } else if (value->IsUint32Array()) {
      *type = napi_uint32_array;
    } else if (value->IsFloat32Array()) {
      *type = napi_float32_array;
    } else if (value->IsFloat64Array()) {
      *type = napi_float64_array;
    } else if (value->IsBigInt64Array()) ...",70,,2861,8,,void
118927,BLOCK,1,,<empty>,,,,2,,void
118929,BLOCK,-1,,CHECK_ENV(env),3,,2862,1,,void
118934,BLOCK,-1,,CHECK_ENV(env),3,,2862,2,,void
118941,BLOCK,1,,<empty>,,,,3,,void
118943,BLOCK,-1,,"CHECK_ARG(env, typedarray)",3,,2863,1,,void
118949,BLOCK,-1,,"CHECK_ARG(env, typedarray)",3,,2863,2,,void
118977,BLOCK,1,,<empty>,,,,4,,void
118979,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsTypedArray(), napi_invalid_arg)",3,,2866,1,,void
118986,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsTypedArray(), napi_invalid_arg)",3,,2866,2,,void
119010,BLOCK,-1,,"{
    if (value->IsInt8Array()) {
      *type = napi_int8_array;
    } else if (value->IsUint8Array()) {
      *type = napi_uint8_array;
    } else if (value->IsUint8ClampedArray()) {
      *type = napi_uint8_clamped_array;
    } else if (value->IsInt16Array()) {
      *type = napi_int16_array;
    } else if (value->IsUint16Array()) {
      *type = napi_uint16_array;
    } else if (value->IsInt32Array()) {
      *type = napi_int32_array;
    } else if (value->IsUint32Array()) {
      *type = napi_uint32_array;
    } else if (value->IsFloat32Array()) {
      *type = napi_float32_array;
    } else if (value->IsFloat64Array()) {
      *type = napi_float64_array;
    } else if (value->IsBigInt64Array()) {
      *type = napi_bigint64_array;
    } else if (value->IsBigUint64Array()) {
      *type = napi_biguint64_array;
    }
  }",24,,2870,2,,void
119016,BLOCK,-1,,"{
      *type = napi_int8_array;
    }",31,,2871,2,,void
119022,BLOCK,-1,,<empty>,12,,2873,1,,void
119028,BLOCK,-1,,"{
      *type = napi_uint8_array;
    }",39,,2873,2,,void
119034,BLOCK,-1,,<empty>,12,,2875,1,,void
119040,BLOCK,-1,,"{
      *type = napi_uint8_clamped_array;
    }",46,,2875,2,,void
119046,BLOCK,-1,,<empty>,12,,2877,1,,void
119052,BLOCK,-1,,"{
      *type = napi_int16_array;
    }",39,,2877,2,,void
119058,BLOCK,-1,,<empty>,12,,2879,1,,void
119064,BLOCK,-1,,"{
      *type = napi_uint16_array;
    }",40,,2879,2,,void
119070,BLOCK,-1,,<empty>,12,,2881,1,,void
119076,BLOCK,-1,,"{
      *type = napi_int32_array;
    }",39,,2881,2,,void
119082,BLOCK,-1,,<empty>,12,,2883,1,,void
119088,BLOCK,-1,,"{
      *type = napi_uint32_array;
    }",40,,2883,2,,void
119094,BLOCK,-1,,<empty>,12,,2885,1,,void
119100,BLOCK,-1,,"{
      *type = napi_float32_array;
    }",41,,2885,2,,void
119106,BLOCK,-1,,<empty>,12,,2887,1,,void
119112,BLOCK,-1,,"{
      *type = napi_float64_array;
    }",41,,2887,2,,void
119118,BLOCK,-1,,<empty>,12,,2889,1,,void
119124,BLOCK,-1,,"{
      *type = napi_bigint64_array;
    }",42,,2889,2,,void
119130,BLOCK,-1,,<empty>,12,,2891,1,,void
119136,BLOCK,-1,,"{
      *type = napi_biguint64_array;
    }",43,,2891,2,,void
119145,BLOCK,-1,,"{
    *length = array->Length();
  }",26,,2896,2,,void
119170,BLOCK,-1,,"{
    // Calling Buffer() may have the side effect of allocating the buffer,
    // so only do this when it’s needed.
    buffer = array->Buffer();
  }",50,,2901,2,,void
119181,BLOCK,-1,,"{
    *data = static_cast<uint8_t*>(buffer->Data()) + array->ByteOffset();
  }",24,,2907,2,,void
119200,BLOCK,-1,,"{
    *arraybuffer = v8impl::JsValueFromV8LocalValue(buffer);
  }",31,,2911,2,,void
119213,BLOCK,-1,,"{
    *byte_offset = array->ByteOffset();
  }",31,,2915,2,,void
119232,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, arraybuffer);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(arraybuffer);
  RETURN_STATUS_IF_FALSE(env, value->IsArrayBuffer(), napi_invalid_arg);

  v8::Local<v8::ArrayBuffer> buffer = value.As<v8::ArrayBuffer>();
  if (byte_length + byte_offset > buffer->ByteLength()) {
    napi_throw_range_error(env,
                           ""ERR_NAPI_INVALID_DATAVIEW_ARGS"",
                           ""byte_offset + byte_length should be less than or ""
                           ""equal to the size in bytes of the array passed in"");
    return napi_set_last_error(env, napi_pending_exception);
  }
  v8::Local<v8::DataView> DataView =
      v8::DataView::New(buffer, byte_offset, byte_length);

  *result = v8impl::JsValueFromV8LocalValue(DataView);
  return GET_RETURN_STATUS(env);
}",65,,2926,6,,void
119235,BLOCK,1,,<empty>,,,,2,,void
119237,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2927,1,,void
119242,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2927,2,,void
119247,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2927,1,,void
119261,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2927,2,,void
119275,BLOCK,1,,<empty>,,,,3,,void
119277,BLOCK,-1,,"CHECK_ARG(env, arraybuffer)",3,,2928,1,,void
119283,BLOCK,-1,,"CHECK_ARG(env, arraybuffer)",3,,2928,2,,void
119292,BLOCK,1,,<empty>,,,,3,,void
119294,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2929,1,,void
119300,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2929,2,,void
119328,BLOCK,1,,<empty>,,,,4,,void
119330,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsArrayBuffer(), napi_invalid_arg)",3,,2932,1,,void
119337,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsArrayBuffer(), napi_invalid_arg)",3,,2932,2,,void
119366,BLOCK,-1,,"{
    napi_throw_range_error(env,
                           ""ERR_NAPI_INVALID_DATAVIEW_ARGS"",
                           ""byte_offset + byte_length should be less than or ""
                           ""equal to the size in bytes of the array passed in"");
    return napi_set_last_error(env, napi_pending_exception);
  }",57,,2935,2,,void
119405,BLOCK,1,,<empty>,,,,3,,void
119422,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  *result = val->IsDataView();

  return napi_clear_last_error(env);
}",55,,2951,4,,void
119425,BLOCK,1,,<empty>,,,,2,,void
119427,BLOCK,-1,,CHECK_ENV(env),3,,2952,1,,void
119432,BLOCK,-1,,CHECK_ENV(env),3,,2952,2,,void
119439,BLOCK,1,,<empty>,,,,3,,void
119441,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2953,1,,void
119447,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2953,2,,void
119456,BLOCK,1,,<empty>,,,,3,,void
119458,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2954,1,,void
119464,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2954,2,,void
119504,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, dataview);

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(dataview);
  RETURN_STATUS_IF_FALSE(env, value->IsDataView(), napi_invalid_arg);

  v8::Local<v8::DataView> array = value.As<v8::DataView>();

  if (byte_length != nullptr) {
    *byte_length = array->ByteLength();
  }

  v8::Local<v8::ArrayBuffer> buffer;
  if (data != nullptr || arraybuffer != nullptr) {
    // Calling Buffer() may have the side effect of allocating the buffer,
    // so only do this when it’s needed.
    buffer = array->Buffer();
  }

  if (data != nullptr) {
    *data = static_cast<uint8_t*>(buffer->Data()) + array->ByteOffset();
  }

  if (arraybuffer != nullptr) {
    *arraybuffer = v8impl::JsValueFromV8LocalValue(buffer);
  }

  if (byte_offset != nullptr) {
    *byte_offset = array->ByteOffset();
  }

  return napi_clear_last_error(env);
}",68,,2967,7,,void
119507,BLOCK,1,,<empty>,,,,2,,void
119509,BLOCK,-1,,CHECK_ENV(env),3,,2968,1,,void
119514,BLOCK,-1,,CHECK_ENV(env),3,,2968,2,,void
119521,BLOCK,1,,<empty>,,,,3,,void
119523,BLOCK,-1,,"CHECK_ARG(env, dataview)",3,,2969,1,,void
119529,BLOCK,-1,,"CHECK_ARG(env, dataview)",3,,2969,2,,void
119557,BLOCK,1,,<empty>,,,,4,,void
119559,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsDataView(), napi_invalid_arg)",3,,2972,1,,void
119566,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsDataView(), napi_invalid_arg)",3,,2972,2,,void
119590,BLOCK,-1,,"{
    *byte_length = array->ByteLength();
  }",31,,2976,2,,void
119615,BLOCK,-1,,"{
    // Calling Buffer() may have the side effect of allocating the buffer,
    // so only do this when it’s needed.
    buffer = array->Buffer();
  }",50,,2981,2,,void
119626,BLOCK,-1,,"{
    *data = static_cast<uint8_t*>(buffer->Data()) + array->ByteOffset();
  }",24,,2987,2,,void
119645,BLOCK,-1,,"{
    *arraybuffer = v8impl::JsValueFromV8LocalValue(buffer);
  }",31,,2991,2,,void
119658,BLOCK,-1,,"{
    *byte_offset = array->ByteOffset();
  }",31,,2995,2,,void
119674,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);
  *result = NAPI_VERSION;
  return napi_clear_last_error(env);
}",73,,3002,3,,void
119677,BLOCK,1,,<empty>,,,,2,,void
119679,BLOCK,-1,,CHECK_ENV(env),3,,3003,1,,void
119684,BLOCK,-1,,CHECK_ENV(env),3,,3003,2,,void
119691,BLOCK,1,,<empty>,,,,3,,void
119693,BLOCK,-1,,"CHECK_ARG(env, result)",3,,3004,1,,void
119699,BLOCK,-1,,"CHECK_ARG(env, result)",3,,3004,2,,void
119709,BLOCK,1,,<empty>,,,,1,,void
119720,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, deferred);
  CHECK_ARG(env, promise);

  auto maybe = v8::Promise::Resolver::New(env->context());
  CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure);

  auto v8_resolver = maybe.ToLocalChecked();
  auto v8_deferred = new v8impl::Persistent<v8::Value>();
  v8_deferred->Reset(env->isolate, v8_resolver);

  *deferred = v8impl::JsDeferredFromNodePersistent(v8_deferred);
  *promise = v8impl::JsValueFromV8LocalValue(v8_resolver->GetPromise());
  return GET_RETURN_STATUS(env);
}",65,,3011,4,,void
119723,BLOCK,1,,<empty>,,,,2,,void
119725,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3012,1,,void
119730,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3012,2,,void
119735,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3012,1,,void
119749,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3012,2,,void
119763,BLOCK,1,,<empty>,,,,3,,void
119765,BLOCK,-1,,"CHECK_ARG(env, deferred)",3,,3013,1,,void
119771,BLOCK,-1,,"CHECK_ARG(env, deferred)",3,,3013,2,,void
119780,BLOCK,1,,<empty>,,,,3,,void
119782,BLOCK,-1,,"CHECK_ARG(env, promise)",3,,3014,1,,void
119788,BLOCK,-1,,"CHECK_ARG(env, promise)",3,,3014,2,,void
119813,BLOCK,1,,<empty>,,,,5,,void
119815,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure)",3,,3017,1,,void
119823,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure)",3,,3017,2,,void
119871,BLOCK,1,,<empty>,,,,3,,void
119888,BLOCK,-1,,"{
  return v8impl::ConcludeDeferred(env, deferred, resolution, true);
}",69,,3030,4,,void
119904,BLOCK,-1,,"{
  return v8impl::ConcludeDeferred(env, deferred, resolution, false);
}",68,,3036,4,,void
119920,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, is_promise);

  *is_promise = v8impl::V8LocalValueFromJsValue(value)->IsPromise();

  return napi_clear_last_error(env);
}",58,,3042,4,,void
119923,BLOCK,1,,<empty>,,,,2,,void
119925,BLOCK,-1,,CHECK_ENV(env),3,,3043,1,,void
119930,BLOCK,-1,,CHECK_ENV(env),3,,3043,2,,void
119937,BLOCK,1,,<empty>,,,,3,,void
119939,BLOCK,-1,,"CHECK_ARG(env, value)",3,,3044,1,,void
119945,BLOCK,-1,,"CHECK_ARG(env, value)",3,,3044,2,,void
119954,BLOCK,1,,<empty>,,,,3,,void
119956,BLOCK,-1,,"CHECK_ARG(env, is_promise)",3,,3045,1,,void
119962,BLOCK,-1,,"CHECK_ARG(env, is_promise)",3,,3045,2,,void
119988,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::MaybeLocal<v8::Value> maybe_date = v8::Date::New(env->context(), time);
  CHECK_MAYBE_EMPTY(env, maybe_date, napi_generic_failure);

  *result = v8impl::JsValueFromV8LocalValue(maybe_date.ToLocalChecked());

  return GET_RETURN_STATUS(env);
}",61,,3054,4,,void
119991,BLOCK,1,,<empty>,,,,2,,void
119993,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3055,1,,void
119998,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3055,2,,void
120003,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3055,1,,void
120017,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3055,2,,void
120031,BLOCK,1,,<empty>,,,,3,,void
120033,BLOCK,-1,,"CHECK_ARG(env, result)",3,,3056,1,,void
120039,BLOCK,-1,,"CHECK_ARG(env, result)",3,,3056,2,,void
120070,BLOCK,1,,<empty>,,,,4,,void
120072,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe_date, napi_generic_failure)",3,,3059,1,,void
120080,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe_date, napi_generic_failure)",3,,3059,2,,void
120100,BLOCK,1,,<empty>,,,,3,,void
120117,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, is_date);

  *is_date = v8impl::V8LocalValueFromJsValue(value)->IsDate();

  return napi_clear_last_error(env);
}",52,,3068,4,,void
120120,BLOCK,1,,<empty>,,,,2,,void
120122,BLOCK,-1,,CHECK_ENV(env),3,,3069,1,,void
120127,BLOCK,-1,,CHECK_ENV(env),3,,3069,2,,void
120134,BLOCK,1,,<empty>,,,,3,,void
120136,BLOCK,-1,,"CHECK_ARG(env, value)",3,,3070,1,,void
120142,BLOCK,-1,,"CHECK_ARG(env, value)",3,,3070,2,,void
120151,BLOCK,1,,<empty>,,,,3,,void
120153,BLOCK,-1,,"CHECK_ARG(env, is_date)",3,,3071,1,,void
120159,BLOCK,-1,,"CHECK_ARG(env, is_date)",3,,3071,2,,void
120185,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsDate(), napi_date_expected);

  v8::Local<v8::Date> date = val.As<v8::Date>();
  *result = date->ValueOf();

  return GET_RETURN_STATUS(env);
}",60,,3080,4,,void
120188,BLOCK,1,,<empty>,,,,2,,void
120190,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3081,1,,void
120195,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3081,2,,void
120200,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3081,1,,void
120214,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3081,2,,void
120228,BLOCK,1,,<empty>,,,,3,,void
120230,BLOCK,-1,,"CHECK_ARG(env, value)",3,,3082,1,,void
120236,BLOCK,-1,,"CHECK_ARG(env, value)",3,,3082,2,,void
120245,BLOCK,1,,<empty>,,,,3,,void
120247,BLOCK,-1,,"CHECK_ARG(env, result)",3,,3083,1,,void
120253,BLOCK,-1,,"CHECK_ARG(env, result)",3,,3083,2,,void
120281,BLOCK,1,,<empty>,,,,4,,void
120283,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsDate(), napi_date_expected)",3,,3086,1,,void
120290,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsDate(), napi_date_expected)",3,,3086,2,,void
120320,BLOCK,1,,<empty>,,,,3,,void
120337,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, script);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> v8_script = v8impl::V8LocalValueFromJsValue(script);

  if (!v8_script->IsString()) {
    return napi_set_last_error(env, napi_string_expected);
  }

  v8::Local<v8::Context> context = env->context();

  auto maybe_script = v8::Script::Compile(context, v8_script.As<v8::String>());
  CHECK_MAYBE_EMPTY(env, maybe_script, napi_generic_failure);

  auto script_result = maybe_script.ToLocalChecked()->Run(context);
  CHECK_MAYBE_EMPTY(env, script_result, napi_generic_failure);

  *result = v8impl::JsValueFromV8LocalValue(script_result.ToLocalChecked());
  return GET_RETURN_STATUS(env);
}",60,,3096,4,,void
120340,BLOCK,1,,<empty>,,,,2,,void
120342,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3097,1,,void
120347,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3097,2,,void
120352,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3097,1,,void
120366,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3097,2,,void
120380,BLOCK,1,,<empty>,,,,3,,void
120382,BLOCK,-1,,"CHECK_ARG(env, script)",3,,3098,1,,void
120388,BLOCK,-1,,"CHECK_ARG(env, script)",3,,3098,2,,void
120397,BLOCK,1,,<empty>,,,,3,,void
120399,BLOCK,-1,,"CHECK_ARG(env, result)",3,,3099,1,,void
120405,BLOCK,-1,,"CHECK_ARG(env, result)",3,,3099,2,,void
120432,BLOCK,-1,,"{
    return napi_set_last_error(env, napi_string_expected);
  }",31,,3103,2,,void
120469,BLOCK,1,,<empty>,,,,5,,void
120471,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe_script, napi_generic_failure)",3,,3110,1,,void
120479,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe_script, napi_generic_failure)",3,,3110,2,,void
120500,BLOCK,1,,<empty>,,,,5,,void
120502,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, script_result, napi_generic_failure)",3,,3113,1,,void
120510,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, script_result, napi_generic_failure)",3,,3113,2,,void
120530,BLOCK,1,,<empty>,,,,3,,void
120550,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, js_object);
  CHECK_ARG(env, finalize_cb);

  v8::Local<v8::Value> v8_value = v8impl::V8LocalValueFromJsValue(js_object);
  RETURN_STATUS_IF_FALSE(env, v8_value->IsObject(), napi_invalid_arg);

  // Create a self-deleting reference if the optional out-param result is not
  // set.
  v8impl::Ownership ownership = result == nullptr
                                    ? v8impl::Ownership::kRuntime
                                    : v8impl::Ownership::kUserland;
  v8impl::Reference* reference = v8impl::Reference::New(
      env, v8_value, 0, ownership, finalize_cb, finalize_data, finalize_hint);

  if (result != nullptr) {
    *result = reinterpret_cast<napi_ref>(reference);
  }
  return napi_clear_last_error(env);
}",61,,3124,7,,void
120553,BLOCK,1,,<empty>,,,,2,,void
120555,BLOCK,-1,,CHECK_ENV(env),3,,3127,1,,void
120560,BLOCK,-1,,CHECK_ENV(env),3,,3127,2,,void
120567,BLOCK,1,,<empty>,,,,3,,void
120569,BLOCK,-1,,"CHECK_ARG(env, js_object)",3,,3128,1,,void
120575,BLOCK,-1,,"CHECK_ARG(env, js_object)",3,,3128,2,,void
120584,BLOCK,1,,<empty>,,,,3,,void
120586,BLOCK,-1,,"CHECK_ARG(env, finalize_cb)",3,,3129,1,,void
120592,BLOCK,-1,,"CHECK_ARG(env, finalize_cb)",3,,3129,2,,void
120620,BLOCK,1,,<empty>,,,,4,,void
120622,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, v8_value->IsObject(), napi_invalid_arg)",3,,3132,1,,void
120629,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, v8_value->IsObject(), napi_invalid_arg)",3,,3132,2,,void
120672,BLOCK,-1,,"{
    *result = reinterpret_cast<napi_ref>(reference);
  }",26,,3142,2,,void
120688,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, adjusted_value);

  *adjusted_value =
      env->isolate->AdjustAmountOfExternalAllocatedMemory(change_in_bytes);

  return napi_clear_last_error(env);
}",77,,3150,4,,void
120691,BLOCK,1,,<empty>,,,,2,,void
120693,BLOCK,-1,,CHECK_ENV(env),3,,3151,1,,void
120698,BLOCK,-1,,CHECK_ENV(env),3,,3151,2,,void
120705,BLOCK,1,,<empty>,,,,3,,void
120707,BLOCK,-1,,"CHECK_ARG(env, adjusted_value)",3,,3152,1,,void
120713,BLOCK,-1,,"CHECK_ARG(env, adjusted_value)",3,,3152,2,,void
120739,BLOCK,-1,,"{
  CHECK_ENV(env);

  v8impl::RefBase* old_data = static_cast<v8impl::RefBase*>(env->instance_data);
  if (old_data != nullptr) {
    // Our contract so far has been to not finalize any old data there may be.
    // So we simply delete it.
    delete old_data;
  }

  env->instance_data = v8impl::RefBase::New(
      env, 0, v8impl::Ownership::kRuntime, finalize_cb, data, finalize_hint);

  return napi_clear_last_error(env);
}",68,,3163,5,,void
120742,BLOCK,1,,<empty>,,,,2,,void
120744,BLOCK,-1,,CHECK_ENV(env),3,,3164,1,,void
120749,BLOCK,-1,,CHECK_ENV(env),3,,3164,2,,void
120765,BLOCK,-1,,"{
    // Our contract so far has been to not finalize any old data there may be.
    // So we simply delete it.
    delete old_data;
  }",28,,3167,2,,void
120796,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, data);

  v8impl::RefBase* idata = static_cast<v8impl::RefBase*>(env->instance_data);

  *data = (idata == nullptr ? nullptr : idata->Data());

  return napi_clear_last_error(env);
}",74,,3179,3,,void
120799,BLOCK,1,,<empty>,,,,2,,void
120801,BLOCK,-1,,CHECK_ENV(env),3,,3180,1,,void
120806,BLOCK,-1,,CHECK_ENV(env),3,,3180,2,,void
120813,BLOCK,1,,<empty>,,,,3,,void
120815,BLOCK,-1,,"CHECK_ARG(env, data)",3,,3181,1,,void
120821,BLOCK,-1,,"CHECK_ARG(env, data)",3,,3181,2,,void
120855,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, arraybuffer);

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(arraybuffer);
  RETURN_STATUS_IF_FALSE(
      env, value->IsArrayBuffer(), napi_arraybuffer_expected);

  v8::Local<v8::ArrayBuffer> it = value.As<v8::ArrayBuffer>();
  RETURN_STATUS_IF_FALSE(
      env, it->IsDetachable(), napi_detachable_arraybuffer_expected);

  it->Detach(v8::Local<v8::Value>()).Check();

  return napi_clear_last_error(env);
}",72,,3191,3,,void
120858,BLOCK,1,,<empty>,,,,2,,void
120860,BLOCK,-1,,CHECK_ENV(env),3,,3192,1,,void
120865,BLOCK,-1,,CHECK_ENV(env),3,,3192,2,,void
120872,BLOCK,1,,<empty>,,,,3,,void
120874,BLOCK,-1,,"CHECK_ARG(env, arraybuffer)",3,,3193,1,,void
120880,BLOCK,-1,,"CHECK_ARG(env, arraybuffer)",3,,3193,2,,void
120908,BLOCK,1,,<empty>,,,,4,,void
120910,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(
      env, value->IsArrayBuffer(), napi_arraybuffer_expected)",3,,3196,1,,void
120917,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(
      env, value->IsArrayBuffer(), napi_arraybuffer_expected)",3,,3196,2,,void
120944,BLOCK,1,,<empty>,,,,4,,void
120946,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(
      env, it->IsDetachable(), napi_detachable_arraybuffer_expected)",3,,3200,1,,void
120953,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(
      env, it->IsDetachable(), napi_detachable_arraybuffer_expected)",3,,3200,2,,void
120979,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, arraybuffer);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(arraybuffer);

  *result =
      value->IsArrayBuffer() && value.As<v8::ArrayBuffer>()->WasDetached();

  return napi_clear_last_error(env);
}",67,,3210,4,,void
120982,BLOCK,1,,<empty>,,,,2,,void
120984,BLOCK,-1,,CHECK_ENV(env),3,,3211,1,,void
120989,BLOCK,-1,,CHECK_ENV(env),3,,3211,2,,void
120996,BLOCK,1,,<empty>,,,,3,,void
120998,BLOCK,-1,,"CHECK_ARG(env, arraybuffer)",3,,3212,1,,void
121004,BLOCK,-1,,"CHECK_ARG(env, arraybuffer)",3,,3212,2,,void
121013,BLOCK,1,,<empty>,,,,3,,void
121015,BLOCK,-1,,"CHECK_ARG(env, result)",3,,3213,1,,void
121021,BLOCK,-1,,"CHECK_ARG(env, result)",3,,3213,2,,void
121065,BLOCK,-1,,"{ cb(env, data, hint); }",38,,105,2,,void
121083,BLOCK,-1,,<empty>,1,,1,1,,ANY
121086,BLOCK,-1,,<empty>,,,,2,,<empty>
121092,BLOCK,-1,,<empty>,16,,13,1,,void
121096,BLOCK,-1,,<empty>,25,,14,1,,void
121100,BLOCK,-1,,<empty>,27,,15,1,,void
121106,BLOCK,-1,,"{
    prev_ = list;
    next_ = list->next_;
    if (next_ != nullptr) {
      next_->prev_ = this;
    }
    list->next_ = this;
  }",35,,19,2,,void
121119,BLOCK,-1,,"{
      next_->prev_ = this;
    }",27,,22,2,,void
121133,BLOCK,-1,,"{
    if (prev_ != nullptr) {
      prev_->next_ = next_;
    }
    if (next_ != nullptr) {
      next_->prev_ = prev_;
    }
    prev_ = nullptr;
    next_ = nullptr;
  }",24,,28,1,,void
121138,BLOCK,-1,,"{
      prev_->next_ = next_;
    }",27,,29,2,,void
121148,BLOCK,-1,,"{
      next_->prev_ = prev_;
    }",27,,32,2,,void
121164,BLOCK,-1,,"{
    while (list->next_ != nullptr) {
      list->next_->Finalize();
    }
  }",42,,39,2,,void
121171,BLOCK,-1,,"{
      list->next_->Finalize();
    }",36,,40,2,,void
121183,BLOCK,-1,,<empty>,,,,1,,<empty>
121196,BLOCK,-1,,"{
    napi_clear_last_error(this);
  }",48,,58,3,,void
121202,BLOCK,-1,,"{
    return v8impl::PersistentToLocal::Strong(context_persistent);
  }",49,,62,1,,void
121214,BLOCK,-1,,{ refs++; },21,,66,1,,void
121220,BLOCK,-1,,"{
    if (--refs == 0) DeleteMe();
  }",23,,67,1,,void
121226,BLOCK,-1,,<empty>,22,,68,2,,void
121231,BLOCK,-1,,{ return true; },41,,71,1,,void
121239,BLOCK,-1,,"{
    if (env->terminatedOrTerminating()) {
      return;
    }
    env->isolate->ThrowException(value);
  }",76,,73,3,,void
121245,BLOCK,-1,,"{
      return;
    }",41,,74,2,,void
121257,BLOCK,-1,,"{
    return this->isolate->IsExecutionTerminating() || !can_call_into_js();
  }",41,,81,1,,void
121273,BLOCK,-1,,"{
    int open_handle_scopes_before = open_handle_scopes;
    int open_callback_scopes_before = open_callback_scopes;
    napi_clear_last_error(this);
    call(this);
    CHECK_EQ(open_handle_scopes, open_handle_scopes_before);
    CHECK_EQ(open_callback_scopes, open_callback_scopes_before);
    if (!last_exception.IsEmpty()) {
      handle_exception(this, last_exception.Get(this->isolate));
      last_exception.Reset();
    }
  }",76,,89,3,,void
121298,BLOCK,-1,,"{
      handle_exception(this, last_exception.Get(this->isolate));
      last_exception.Reset();
    }",36,,96,2,,void
121316,BLOCK,-1,,"{
    v8::HandleScope handle_scope(isolate);
    CallIntoModule([&](napi_env env) { cb(env, data, hint); });
  }",72,,103,4,,void
121326,BLOCK,-1,,"{
    pending_finalizers.emplace(finalizer);
  }",64,,112,2,,void
121336,BLOCK,-1,,"{
    pending_finalizers.erase(finalizer);
  }",64,,118,2,,void
121345,BLOCK,-1,,"{
    // First we must finalize those references that have `napi_finalizer`
    // callbacks. The reason is that addons might store other references which
    // they delete during their `napi_finalizer` callbacks. If we deleted such
    // references here first, they would be doubly deleted when the
    // `napi_finalizer` deleted them subsequently.
    v8impl::RefTracker::FinalizeAll(&finalizing_reflist);
    v8impl::RefTracker::FinalizeAll(&reflist);
    delete this;
  }",27,,122,1,,void
121379,BLOCK,-1,,<empty>,,,,1,,<empty>
121383,BLOCK,-1,,<empty>,,,,1,,<empty>
121399,BLOCK,1,,<empty>,,,,1,,void
121405,BLOCK,-1,,"{
  env->last_error.error_code = napi_ok;
  env->last_error.engine_error_code = 0;
  env->last_error.engine_reserved = nullptr;
  env->last_error.error_message = nullptr;
  return napi_ok;
}",56,,158,2,,void
121443,BLOCK,-1,,"{
  env->last_error.error_code = error_code;
  env->last_error.engine_error_code = engine_error_code;
  env->last_error.engine_reserved = engine_reserved;
  return error_code;
}",73,,169,5,,void
121479,BLOCK,-1,,"{
  return reinterpret_cast<napi_value>(*local);
}",71,,294,2,,void
121489,BLOCK,-1,,"{
  v8::Local<v8::Value> local;
  memcpy(static_cast<void*>(&local), &v, sizeof(v));
  return local;
}",67,,298,2,,void
121518,BLOCK,-1,,<empty>,39,,314,5,,void
121522,BLOCK,-1,,<empty>,,,,1,,<empty>
121530,BLOCK,-1,,"{
    return new Finalizer(env, finalize_callback, finalize_data, finalize_hint);
  }",56,,322,5,,void
121541,BLOCK,-1,,{ return finalize_callback_; },28,,326,1,,void
121547,BLOCK,-1,,{ return finalize_data_; },16,,327,1,,void
121553,BLOCK,-1,,{ return finalize_hint_; },16,,328,1,,void
121559,BLOCK,-1,,<empty>,,,,1,,<empty>
121569,BLOCK,-1,,<empty>,75,,341,2,,void
121573,BLOCK,-1,,"{
    if (HasCaught()) {
      _env->last_exception.Reset(_env->isolate, Exception());
    }
  }",15,,343,1,,void
121576,BLOCK,-1,,"{
      _env->last_exception.Reset(_env->isolate, Exception());
    }",22,,344,2,,void
121601,BLOCK,-1,,<empty>,,,,7,,<empty>
121611,BLOCK,-1,,<empty>,,,,7,,<empty>
121615,BLOCK,-1,,<empty>,,,,1,,<empty>
121619,BLOCK,-1,,<empty>,,,,1,,<empty>
121623,BLOCK,-1,,<empty>,,,,1,,<empty>
121627,BLOCK,-1,,<empty>,,,,1,,<empty>
121631,BLOCK,-1,,<empty>,,,,1,,<empty>
121635,BLOCK,-1,,{ return ownership_; },25,,387,1,,void
121641,BLOCK,-1,,<empty>,,,,1,,<empty>
121651,BLOCK,-1,,<empty>,,,,4,,<empty>
121662,BLOCK,-1,,<empty>,,,,8,,<empty>
121666,BLOCK,-1,,<empty>,,,,1,,<empty>
121670,BLOCK,-1,,<empty>,,,,1,,<empty>
121674,BLOCK,-1,,<empty>,,,,1,,<empty>
121678,BLOCK,-1,,<empty>,,,,1,,<empty>
121682,BLOCK,-1,,<empty>,,,,1,,<empty>
121687,BLOCK,-1,,<empty>,,,,2,,<empty>
121691,BLOCK,-1,,<empty>,,,,1,,<empty>
121708,BLOCK,-1,,<empty>,1,,1,1,,ANY
121730,BLOCK,-1,,<empty>,1,,1,1,,ANY
121735,BLOCK,-1,,"{
  MakeWeak();
  StreamBase::AttachToObject(obj);
}",23,,28,3,,void
121745,BLOCK,-1,,"{
  return static_cast<AsyncWrap*>(this);
}",37,,34,1,,void
121753,BLOCK,-1,,"{
  return true;
}",26,,39,1,,void
121759,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  TryCatchScope try_catch(env());
  Local<Value> value;
  if (!MakeCallback(env()->isclosing_string(), 0, nullptr).ToLocal(&value)) {
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
    return true;
  }
  return value->IsTrue();
}",28,,44,1,,void
121794,BLOCK,-1,,"{
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
    return true;
  }",77,,49,2,,void
121806,BLOCK,-1,,<empty>,7,,51,2,,void
121826,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  TryCatchScope try_catch(env());
  Local<Value> value;
  int value_int = UV_EPROTO;
  if (!MakeCallback(env()->onreadstart_string(), 0, nullptr).ToLocal(&value) ||
      !value->Int32Value(env()->context()).To(&value_int)) {
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }
  return value_int;
}",27,,58,1,,void
121880,BLOCK,-1,,"{
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }",60,,65,2,,void
121892,BLOCK,-1,,<empty>,7,,67,2,,void
121907,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  TryCatchScope try_catch(env());
  Local<Value> value;
  int value_int = UV_EPROTO;
  if (!MakeCallback(env()->onreadstop_string(), 0, nullptr).ToLocal(&value) ||
      !value->Int32Value(env()->context()).To(&value_int)) {
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }
  return value_int;
}",26,,73,1,,void
121961,BLOCK,-1,,"{
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }",60,,80,2,,void
121973,BLOCK,-1,,<empty>,7,,82,2,,void
121989,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());

  Local<Value> argv[] = {
    req_wrap->object()
  };

  TryCatchScope try_catch(env());
  Local<Value> value;
  int value_int = UV_EPROTO;
  if (!MakeCallback(env()->onshutdown_string(),
                    arraysize(argv),
                    argv).ToLocal(&value) ||
      !value->Int32Value(env()->context()).To(&value_int)) {
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }
  return value_int;
}",50,,88,2,,void
122052,BLOCK,-1,,"{
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }",60,,102,2,,void
122064,BLOCK,-1,,<empty>,7,,104,2,,void
122083,BLOCK,-1,,"{
  CHECK_NULL(send_handle);

  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());

  MaybeStackBuffer<Local<Value>, 16> bufs_arr(count);
  for (size_t i = 0; i < count; i++) {
    bufs_arr[i] =
        Buffer::Copy(env(), bufs[i].base, bufs[i].len).ToLocalChecked();
  }

  Local<Value> argv[] = {
    w->object(),
    Array::New(env()->isolate(), bufs_arr.out(), count)
  };

  TryCatchScope try_catch(env());
  Local<Value> value;
  int value_int = UV_EPROTO;
  if (!MakeCallback(env()->onwrite_string(),
                    arraysize(argv),
                    argv).ToLocal(&value) ||
      !value->Int32Value(env()->context()).To(&value_int)) {
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }
  return value_int;
}",49,,113,5,,void
122102,BLOCK,-1,,<empty>,3,,120,1,,void
122112,BLOCK,4,,"{
    bufs_arr[i] =
        Buffer::Copy(env(), bufs[i].base, bufs[i].len).ToLocalChecked();
  }",38,,120,4,,void
122198,BLOCK,-1,,"{
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }",60,,136,2,,void
122210,BLOCK,-1,,<empty>,7,,138,2,,void
122226,BLOCK,-1,,"{
  // This constructor should not be exposed to public javascript.
  // Therefore we assert that we are not trying to call this as a
  // normal function.
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new JSStream(env, args.This());
}",61,,144,2,,void
122251,BLOCK,-1,,"{
  CHECK(args[0]->IsObject());
  Wrap* w = static_cast<Wrap*>(StreamReq::FromObject(args[0].As<Object>()));

  CHECK(args[1]->IsInt32());
  w->Done(args[1].As<Int32>()->Value());
}",64,,155,2,,void
122298,BLOCK,-1,,"{
  JSStream* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  ArrayBufferViewContents<char> buffer(args[0]);
  const char* data = buffer.data();
  int len = buffer.length();

  // Repeatedly ask the stream's owner for memory, copy the data that we
  // just read from JS into those buffers and emit them as reads.
  while (len != 0) {
    uv_buf_t buf = wrap->EmitAlloc(len);
    ssize_t avail = len;
    if (static_cast<ssize_t>(buf.len) < avail)
      avail = buf.len;

    memcpy(buf.base, data, avail);
    data += avail;
    len -= static_cast<int>(avail);
    wrap->EmitRead(avail, buf);
  }
}",68,,164,2,,void
122330,BLOCK,-1,,"{
    uv_buf_t buf = wrap->EmitAlloc(len);
    ssize_t avail = len;
    if (static_cast<ssize_t>(buf.len) < avail)
      avail = buf.len;

    memcpy(buf.base, data, avail);
    data += avail;
    len -= static_cast<int>(avail);
    wrap->EmitRead(avail, buf);
  }",20,,174,2,,void
122351,BLOCK,-1,,<empty>,7,,178,2,,void
122381,BLOCK,-1,,"{
  JSStream* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  wrap->EmitRead(UV_EOF);
}",65,,188,2,,void
122402,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->InstanceTemplate()
    ->SetInternalFieldCount(StreamBase::kInternalFieldCount);
  t->Inherit(AsyncWrap::GetConstructorTemplate(env));

  SetProtoMethod(isolate, t, ""finishWrite"", Finish<WriteWrap>);
  SetProtoMethod(isolate, t, ""finishShutdown"", Finish<ShutdownWrap>);
  SetProtoMethod(isolate, t, ""readBuffer"", ReadBuffer);
  SetProtoMethod(isolate, t, ""emitEOF"", EmitEOF);

  StreamBase::AddMethods(env, t);
  SetConstructorFunction(context, target, ""JSStream"", t);
}",39,,199,5,,void
122488,BLOCK,-1,,<empty>,1,,1,1,,ANY
122503,BLOCK,-1,,<empty>,1,,1,1,,ANY
122509,BLOCK,-1,,<empty>,,,,3,,<empty>
122513,BLOCK,-1,,<empty>,,,,1,,<empty>
122517,BLOCK,-1,,<empty>,,,,1,,<empty>
122524,BLOCK,-1,,<empty>,,,,4,,<empty>
122528,BLOCK,-1,,<empty>,,,,1,,<empty>
122532,BLOCK,-1,,<empty>,,,,1,,<empty>
122536,BLOCK,-1,,{ return this; },38,,38,1,,void
122543,BLOCK,-1,,<empty>,,,,2,,<empty>
122548,BLOCK,-1,,<empty>,,,,2,,<empty>
122553,BLOCK,-1,,<empty>,,,,2,,<empty>
122558,BLOCK,-1,,<empty>,,,,2,,<empty>
122566,BLOCK,-1,,<empty>,,,,5,,<empty>
122573,BLOCK,-1,,"{
  MakeWeak();

  obj->SetAlignedPointerInInternalField(
      kUDPWrapBaseField, static_cast<UDPWrapBase*>(this));
}",45,,55,3,,void
122586,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  TryCatchScope try_catch(env());
  Local<Value> value;
  int32_t value_int = JS_EXCEPTION_PENDING;
  if (!MakeCallback(env()->onreadstart_string(), 0, nullptr).ToLocal(&value) ||
      !value->Int32Value(env()->context()).To(&value_int)) {
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }
  return value_int;
}",28,,62,1,,void
122611,BLOCK,1,,<empty>,,,,1,,void
122642,BLOCK,-1,,"{
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }",60,,69,2,,void
122654,BLOCK,-1,,<empty>,7,,71,2,,void
122669,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  TryCatchScope try_catch(env());
  Local<Value> value;
  int32_t value_int = JS_EXCEPTION_PENDING;
  if (!MakeCallback(env()->onreadstop_string(), 0, nullptr).ToLocal(&value) ||
      !value->Int32Value(env()->context()).To(&value_int)) {
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }
  return value_int;
}",27,,76,1,,void
122694,BLOCK,1,,<empty>,,,,1,,void
122725,BLOCK,-1,,"{
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }",60,,83,2,,void
122737,BLOCK,-1,,<empty>,7,,85,2,,void
122755,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  TryCatchScope try_catch(env());
  Local<Value> value;
  int64_t value_int = JS_EXCEPTION_PENDING;
  size_t total_len = 0;

  MaybeStackBuffer<Local<Value>, 16> buffers(nbufs);
  for (size_t i = 0; i < nbufs; i++) {
    buffers[i] = Buffer::Copy(env(), bufs[i].base, bufs[i].len)
        .ToLocalChecked();
    total_len += bufs[i].len;
  }

  Local<Object> address;
  if (!AddressToJS(env(), addr).ToLocal(&address)) return value_int;

  Local<Value> args[] = {
    listener()->CreateSendWrap(total_len)->object(),
    Array::New(env()->isolate(), buffers.out(), nbufs),
    address,
  };

  if (!MakeCallback(env()->onwrite_string(), arraysize(args), args)
          .ToLocal(&value) ||
      !value->IntegerValue(env()->context()).To(&value_int)) {
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }
  return value_int;
}",47,,92,4,,void
122780,BLOCK,1,,<empty>,,,,1,,void
122790,BLOCK,-1,,<empty>,3,,101,1,,void
122800,BLOCK,4,,"{
    buffers[i] = Buffer::Copy(env(), bufs[i].base, bufs[i].len)
        .ToLocalChecked();
    total_len += bufs[i].len;
  }",38,,101,4,,void
122845,BLOCK,-1,,<empty>,52,,108,2,,void
122904,BLOCK,-1,,"{
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }",62,,118,2,,void
122916,BLOCK,-1,,<empty>,7,,120,2,,void
122931,BLOCK,-1,,"{
  SocketAddress ret;
  CHECK(SocketAddress::New(AF_INET, ""127.0.0.1"", 1337, &ret));
  return ret;
}",40,,125,1,,void
122948,BLOCK,-1,,"{
  SocketAddress ret;
  CHECK(SocketAddress::New(AF_INET, ""127.0.0.1"", 1337, &ret));
  return ret;
}",40,,131,1,,void
122966,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args.IsConstructCall());
  new JSUDPWrap(env, args.Holder());
}",62,,137,2,,void
122991,BLOCK,-1,,"{
  JSUDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  Environment* env = wrap->env();

  ArrayBufferViewContents<char> buffer(args[0]);
  const char* data = buffer.data();
  int len = buffer.length();

  CHECK(args[1]->IsInt32());   // family
  CHECK(args[2]->IsString());  // address
  CHECK(args[3]->IsInt32());   // port
  CHECK(args[4]->IsInt32());   // flags
  int family = args[1].As<Int32>()->Value() == 4 ? AF_INET : AF_INET6;
  Utf8Value address(env->isolate(), args[2]);
  int port = args[3].As<Int32>()->Value();
  int flags = args[3].As<Int32>()->Value();

  sockaddr_storage addr;
  CHECK_EQ(sockaddr_for_family(family, *address, port, &addr), 0);

  // Repeatedly ask the stream's owner for memory, copy the data that we
  // just read from JS into those buffers and emit them as reads.
  while (len != 0) {
    uv_buf_t buf = wrap->listener()->OnAlloc(len);
    ssize_t avail = std::min<size_t>(buf.len, len);
    memcpy(buf.base, data, avail);
    data += avail;
...",71,,143,2,,void
123118,BLOCK,-1,,"{
    uv_buf_t buf = wrap->listener()->OnAlloc(len);
    ssize_t avail = std::min<size_t>(buf.len, len);
    memcpy(buf.base, data, avail);
    data += avail;
    len -= static_cast<int>(avail);
    wrap->listener()->OnRecv(
        avail, buf, reinterpret_cast<sockaddr*>(&addr), flags);
  }",20,,166,2,,void
123177,BLOCK,-1,,"{
  JSUDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsInt32());
  ReqWrap<uv_udp_send_t>* req_wrap;
  ASSIGN_OR_RETURN_UNWRAP(&req_wrap, args[0].As<Object>());
  int status = args[1].As<Int32>()->Value();

  wrap->listener()->OnSendDone(req_wrap, status);
}",69,,177,2,,void
123240,BLOCK,-1,,"{
  JSUDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  wrap->listener()->OnAfterBind();
}",70,,190,2,,void
123263,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->InstanceTemplate()
    ->SetInternalFieldCount(UDPWrapBase::kUDPWrapBaseField + 1);
  t->Inherit(AsyncWrap::GetConstructorTemplate(env));

  UDPWrapBase::AddMethods(env, t);
  SetProtoMethod(isolate, t, ""emitReceived"", EmitReceived);
  SetProtoMethod(isolate, t, ""onSendDone"", OnSendDone);
  SetProtoMethod(isolate, t, ""onAfterBind"", OnAfterBind);

  SetConstructorFunction(context, target, ""JSUDPWrap"", t);
}",40,,200,5,,void
123350,BLOCK,-1,,<empty>,1,,1,1,,ANY
123354,BLOCK,-1,,"{
  Isolate* isolate = Isolate::Allocate();
  CHECK_NOT_NULL(isolate);
  per_process::v8_platform.Platform()->RegisterIsolate(isolate,
                                                       uv_default_loop());
  Isolate::CreateParams params;
  params.array_buffer_allocator = allocator;
  Isolate::Initialize(isolate, params);
  return isolate;
}",67,,15,2,,void
123393,BLOCK,-1,,"{
  per_process::v8_platform.Platform()->UnregisterIsolate(isolate);
  isolate->Dispose();
}",48,,26,2,,void
123411,BLOCK,-1,,<empty>,52,,36,1,,void
123416,BLOCK,-1,,"{
  DCHECK(!parsed_);

  Isolate* isolate = isolate_.get();
  Local<Context> context = context_.Get(isolate);

  // It's not a real script, so don't print the source line.
  errors::PrinterTryCatch bootstrapCatch(
      isolate, errors::PrinterTryCatch::kDontPrintSourceLine);
  Local<Value> json_string_value;
  Local<Value> result_value;
  if (!ToV8Value(context, content).ToLocal(&json_string_value) ||
      !json_string_value->IsString() ||
      !v8::JSON::Parse(context, json_string_value.As<String>())
           .ToLocal(&result_value) ||
      !result_value->IsObject()) {
    return false;
  }
  content_.Reset(isolate, result_value.As<Object>());
  parsed_ = true;
  return true;
}",52,,38,2,,void
123496,BLOCK,-1,,"{
    return false;
  }",34,,53,2,,void
123517,BLOCK,-1,,"{
  Isolate* isolate = isolate_.get();
  Local<Context> context = context_.Get(isolate);
  Local<Object> content_object = content_.Get(isolate);
  Local<Value> value;
  // It's not a real script, so don't print the source line.
  errors::PrinterTryCatch bootstrapCatch(
      isolate, errors::PrinterTryCatch::kDontPrintSourceLine);
  Local<Value> field_local;
  if (!ToV8Value(context, field, isolate).ToLocal(&field_local)) {
    return {};
  }
  if (!content_object->Get(context, field_local).ToLocal(&value) ||
      !value->IsString()) {
    return {};
  }
  Utf8Value utf8_value(isolate, value);
  return utf8_value.ToString();
}",29,,62,2,,void
123576,BLOCK,-1,,"{
    return {};
  }",66,,71,2,,void
123597,BLOCK,-1,,"{
    return {};
  }",27,,75,2,,void
123612,BLOCK,-1,,"{
  Isolate* isolate = isolate_.get();
  Local<Context> context = context_.Get(isolate);
  Local<Object> content_object = content_.Get(isolate);
  Local<Value> value;
  bool has_field;
  // It's not a real script, so don't print the source line.
  errors::PrinterTryCatch bootstrapCatch(
      isolate, errors::PrinterTryCatch::kDontPrintSourceLine);
  Local<Value> field_local;
  if (!ToV8Value(context, field, isolate).ToLocal(&field_local)) {
    return {};
  }
  if (!content_object->Has(context, field_local).To(&has_field)) {
    return {};
  }
  if (!has_field) {
    return false;
  }
  if (!content_object->Get(context, field_local).ToLocal(&value) ||
      !value->IsBoolean()) {
    return {};
  }
  return value->BooleanValue(isolate);
}",78,,82,2,,void
123672,BLOCK,-1,,"{
    return {};
  }",66,,92,2,,void
123687,BLOCK,-1,,"{
    return {};
  }",66,,95,2,,void
123692,BLOCK,-1,,"{
    return false;
  }",19,,98,2,,void
123714,BLOCK,-1,,"{
    return {};
  }",28,,102,2,,void
123738,BLOCK,-1,,<empty>,1,,1,1,,ANY
123745,BLOCK,-1,,<empty>,1,,1,1,,ANY
123749,BLOCK,-1,,"{
  // 'static constexpr' is slightly better than static const
  // since the initialization occurs at compile time.
  // See https://lemire.me/blog/I3Cah
  static constexpr std::string_view control_symbols[0x20] = {
      ""\\u0000"", ""\\u0001"", ""\\u0002"", ""\\u0003"", ""\\u0004"", ""\\u0005"",
      ""\\u0006"", ""\\u0007"", ""\\b"",     ""\\t"",     ""\\n"",     ""\\u000b"",
      ""\\f"",     ""\\r"",     ""\\u000e"", ""\\u000f"", ""\\u0010"", ""\\u0011"",
      ""\\u0012"", ""\\u0013"", ""\\u0014"", ""\\u0015"", ""\\u0016"", ""\\u0017"",
      ""\\u0018"", ""\\u0019"", ""\\u001a"", ""\\u001b"", ""\\u001c"", ""\\u001d"",
      ""\\u001e"", ""\\u001f""};

  std::string ret;
  size_t last_pos = 0;
  size_t pos = 0;
  for (; pos < str.size(); ++pos) {
    std::string replace;
    char ch = str[pos];
    if (ch == '\\') {
      replace = ""\\\\"";
    } else if (ch == '\""') {
      replace = ""\\\"""";
    } else {
      size_t num = static_cast<size_t>(ch);
      if (num < 0x20) replace = control_symbols[num];
    }
    if (!replace.empty()) {
 ...",51,,5,2,,void
123796,BLOCK,-1,,<empty>,3,,20,1,,void
123805,BLOCK,4,,"{
    std::string replace;
    char ch = str[pos];
    if (ch == '\\') {
      replace = ""\\\\"";
    } else if (ch == '\""') {
      replace = ""\\\"""";
    } else {
      size_t num = static_cast<size_t>(ch);
      if (num < 0x20) replace = control_symbols[num];
    }
    if (!replace.empty()) {
      if (pos > last_pos) {
        ret += str.substr(last_pos, pos - last_pos);
      }
      last_pos = pos + 1;
      ret += replace;
    }
  }",35,,20,4,,void
123817,BLOCK,-1,,"{
      replace = ""\\\\"";
    }",21,,23,2,,void
123822,BLOCK,-1,,<empty>,12,,25,1,,void
123827,BLOCK,-1,,"{
      replace = ""\\\"""";
    }",28,,25,2,,void
123832,BLOCK,-1,,"{
      size_t num = static_cast<size_t>(ch);
      if (num < 0x20) replace = control_symbols[num];
    }",12,,27,1,,void
123843,BLOCK,-1,,<empty>,23,,29,2,,void
123855,BLOCK,-1,,"{
      if (pos > last_pos) {
        ret += str.substr(last_pos, pos - last_pos);
      }
      last_pos = pos + 1;
      ret += replace;
    }",27,,31,2,,void
123860,BLOCK,-1,,"{
        ret += str.substr(last_pos, pos - last_pos);
      }",27,,32,2,,void
123886,BLOCK,-1,,"{
    ret += str.substr(last_pos, pos - last_pos);
  }",30,,40,2,,void
123904,BLOCK,-1,,"{
  if (indent_depth <= 0) return str;
  const std::string indent(indent_depth, ' ');
  std::string out;
  std::string::size_type pos = 0;
  for (;;) {
    std::string::size_type prev_pos = pos;
    pos = str.find('\n', pos);

    out.append(indent);

    if (pos == std::string::npos) {
      out.append(str, prev_pos, std::string::npos);
      break;
    } else {
      pos++;
      out.append(str, prev_pos, pos - prev_pos);
    }
  }

  return out;
}",64,,46,3,,void
123909,BLOCK,-1,,<empty>,26,,47,2,,void
123922,BLOCK,-1,,<empty>,3,,51,1,,void
123923,BLOCK,4,,"{
    std::string::size_type prev_pos = pos;
    pos = str.find('\n', pos);

    out.append(indent);

    if (pos == std::string::npos) {
      out.append(str, prev_pos, std::string::npos);
      break;
    } else {
      pos++;
      out.append(str, prev_pos, pos - prev_pos);
    }
  }",12,,51,4,,void
123949,BLOCK,-1,,"{
      out.append(str, prev_pos, std::string::npos);
      break;
    }",35,,57,2,,void
123963,BLOCK,-1,,"{
      pos++;
      out.append(str, prev_pos, pos - prev_pos);
    }",12,,60,1,,void
123993,BLOCK,-1,,<empty>,1,,1,1,,ANY
124030,BLOCK,-1,,<empty>,1,,1,1,,ANY
124033,BLOCK,-1,,"{
#if defined(NODE_ENABLE_LARGE_CODE_PAGES) && NODE_ENABLE_LARGE_CODE_PAGES
  bool have_thp = false;
#if defined(__linux__)
  have_thp = IsTransparentHugePagesEnabled();
#elif defined(__FreeBSD__)
  have_thp = IsSuperPagesEnabled();
#elif defined(__APPLE__)
  // pse-36 flag is present in recent mac x64 products.
  have_thp = true;
#endif
  if (!have_thp)
    return EACCES;

  struct text_region r = FindNodeTextRegion();
  if (r.found_text_region == false)
    return ENOENT;

  return MoveTextRegionToLargePages(r);
#else
  return ENOTSUP;
#endif
}",33,,417,1,,void
124040,BLOCK,-1,,"{
  switch (status) {
    case ENOTSUP:
      return ""Mapping to large pages is not supported."";

    case EACCES:
      return ""Large pages are not enabled."";

    case ENOENT:
      return ""failed to find text region"";

    case -1:
      return ""Mapping code to large pages failed. Reverting to default page ""
          ""size."";

    case 0:
      return ""OK"";

    default:
      return ""Unknown error"";
  }
}",41,,441,2,,void
124043,BLOCK,-1,,"{
    case ENOTSUP:
      return ""Mapping to large pages is not supported."";

    case EACCES:
      return ""Large pages are not enabled."";

    case ENOENT:
      return ""failed to find text region"";

    case -1:
      return ""Mapping code to large pages failed. Reverting to default page ""
          ""size."";

    case 0:
      return ""OK"";

    default:
      return ""Unknown error"";
  }",19,,442,2,,void
124074,BLOCK,-1,,<empty>,1,,1,1,,ANY
124083,BLOCK,-1,,<empty>,1,,1,1,,ANY
124102,BLOCK,-1,,<empty>,1,,1,1,,ANY
124105,BLOCK,-1,,"{
    MaybeLocal<Value> result = module->Evaluate(context);
    if (!result.IsEmpty() && microtask_queue)
      microtask_queue->PerformCheckpoint(isolate);
    return result;
  }",20,,384,1,,void
124125,BLOCK,-1,,<empty>,7,,387,2,,void
124164,BLOCK,-1,,<empty>,1,,1,1,,ANY
124172,BLOCK,-1,,"{
  env->id_to_module_map.emplace(id_, this);

  Local<Value> undefined = Undefined(env->isolate());
  object->SetInternalField(kURLSlot, url);
  object->SetInternalField(kSyntheticEvaluationStepsSlot, undefined);
  object->SetInternalField(kContextObjectSlot, undefined);
}",36,,58,5,,void
124213,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());
  Local<Module> module = module_.Get(env()->isolate());
  env()->id_to_module_map.erase(id_);
  auto range = env()->hash_to_module_map.equal_range(module->GetIdentityHash());
  for (auto it = range.first; it != range.second; ++it) {
    if (it->second == this) {
      env()->hash_to_module_map.erase(it);
      break;
    }
  }
}",27,,67,1,,void
124255,BLOCK,-1,,<empty>,3,,72,1,,void
124269,BLOCK,4,,"{
    if (it->second == this) {
      env()->hash_to_module_map.erase(it);
      break;
    }
  }",57,,72,4,,void
124276,BLOCK,-1,,"{
      env()->hash_to_module_map.erase(it);
      break;
    }",29,,73,2,,void
124288,BLOCK,-1,,"{
  Local<Value> obj = object()->GetInternalField(kContextObjectSlot);
  if (obj.IsEmpty()) return {};
  return obj.As<Object>()->GetCreationContext().ToLocalChecked();
}",44,,80,1,,void
124305,BLOCK,-1,,<empty>,22,,82,2,,void
124323,BLOCK,-1,,"{
  auto range = env->hash_to_module_map.equal_range(module->GetIdentityHash());
  for (auto it = range.first; it != range.second; ++it) {
    if (it->second->module_ == module) {
      return it->second;
    }
  }
  return nullptr;
}",61,,87,3,,void
124338,BLOCK,-1,,<empty>,3,,89,1,,void
124352,BLOCK,4,,"{
    if (it->second->module_ == module) {
      return it->second;
    }
  }",57,,89,4,,void
124361,BLOCK,-1,,"{
      return it->second;
    }",40,,90,2,,void
124373,BLOCK,-1,,"{
  auto module_wrap_it = env->id_to_module_map.find(id);
  if (module_wrap_it == env->id_to_module_map.end()) {
    return nullptr;
  }
  return module_wrap_it->second;
}",66,,97,3,,void
124393,BLOCK,-1,,"{
    return nullptr;
  }",54,,99,2,,void
124404,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  CHECK_GE(args.Length(), 3);

  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  Local<Object> that = args.This();

  CHECK(args[0]->IsString());
  Local<String> url = args[0].As<String>();

  Local<Context> context;
  ContextifyContext* contextify_context = nullptr;
  if (args[1]->IsUndefined()) {
    context = that->GetCreationContext().ToLocalChecked();
  } else {
    CHECK(args[1]->IsObject());
    contextify_context = ContextifyContext::ContextFromContextifiedSandbox(
        env, args[1].As<Object>());
    CHECK_NOT_NULL(contextify_context);
    context = contextify_context->context();
  }

  int line_offset = 0;
  int column_offset = 0;

  bool synthetic = args[2]->IsArray();
  if (synthetic) {
    // new ModuleWrap(url, context, exportNames, syntheticExecutionFunction)
    CHECK(args[3]->IsFunction());
  } else {
    // new ModuleWrap(url, context, source, lineOffset, columOffset, cachedData)
    CH...",63,,107,2,,void
124476,BLOCK,-1,,"{
    context = that->GetCreationContext().ToLocalChecked();
  }",31,,121,2,,void
124487,BLOCK,-1,,"{
    CHECK(args[1]->IsObject());
    contextify_context = ContextifyContext::ContextFromContextifiedSandbox(
        env, args[1].As<Object>());
    CHECK_NOT_NULL(contextify_context);
    context = contextify_context->context();
  }",10,,123,1,,void
124535,BLOCK,-1,,"{
    // new ModuleWrap(url, context, exportNames, syntheticExecutionFunction)
    CHECK(args[3]->IsFunction());
  }",18,,135,2,,void
124544,BLOCK,-1,,"{
    // new ModuleWrap(url, context, source, lineOffset, columOffset, cachedData)
    CHECK(args[2]->IsString());
    CHECK(args[3]->IsNumber());
    line_offset = args[3].As<Int32>()->Value();
    CHECK(args[4]->IsNumber());
    column_offset = args[4].As<Int32>()->Value();
  }",10,,138,1,,void
124629,BLOCK,28,,"{
    Context::Scope context_scope(context);
    if (synthetic) {
      CHECK(args[2]->IsArray());
      Local<Array> export_names_arr = args[2].As<Array>();

      uint32_t len = export_names_arr->Length();
      std::vector<Local<String>> export_names(len);
      for (uint32_t i = 0; i < len; i++) {
        Local<Value> export_name_val =
            export_names_arr->Get(context, i).ToLocalChecked();
        CHECK(export_name_val->IsString());
        export_names[i] = export_name_val.As<String>();
      }

      module = Module::CreateSyntheticModule(isolate, url, export_names,
        SyntheticModuleEvaluationStepsCallback);
    } else {
      ScriptCompiler::CachedData* cached_data = nullptr;
      if (!args[5]->IsUndefined()) {
        CHECK(args[5]->IsArrayBufferView());
        Local<ArrayBufferView> cached_data_buf = args[5].As<ArrayBufferView>();
        uint8_t* data =
            static_cast<uint8_t*>(cached_data_buf->Buffer()->Data());
        cached_data =
            ...",3,,157,28,,void
124635,BLOCK,-1,,"{
      CHECK(args[2]->IsArray());
      Local<Array> export_names_arr = args[2].As<Array>();

      uint32_t len = export_names_arr->Length();
      std::vector<Local<String>> export_names(len);
      for (uint32_t i = 0; i < len; i++) {
        Local<Value> export_name_val =
            export_names_arr->Get(context, i).ToLocalChecked();
        CHECK(export_name_val->IsString());
        export_names[i] = export_name_val.As<String>();
      }

      module = Module::CreateSyntheticModule(isolate, url, export_names,
        SyntheticModuleEvaluationStepsCallback);
    }",20,,159,2,,void
124673,BLOCK,-1,,<empty>,7,,165,1,,void
124683,BLOCK,4,,"{
        Local<Value> export_name_val =
            export_names_arr->Get(context, i).ToLocalChecked();
        CHECK(export_name_val->IsString());
        export_names[i] = export_name_val.As<String>();
      }",42,,165,4,,void
124723,BLOCK,-1,,"{
      ScriptCompiler::CachedData* cached_data = nullptr;
      if (!args[5]->IsUndefined()) {
        CHECK(args[5]->IsArrayBufferView());
        Local<ArrayBufferView> cached_data_buf = args[5].As<ArrayBufferView>();
        uint8_t* data =
            static_cast<uint8_t*>(cached_data_buf->Buffer()->Data());
        cached_data =
            new ScriptCompiler::CachedData(data + cached_data_buf->ByteOffset(),
                                           cached_data_buf->ByteLength());
      }

      Local<String> source_text = args[2].As<String>();
      ScriptOrigin origin(isolate,
                          url,
                          line_offset,
                          column_offset,
                          true,                             // is cross origin
                          -1,                               // script id
                          Local<Value>(),                   // source map URL
                          false,                            // ...",12,,174,1,,void
124736,BLOCK,-1,,"{
        CHECK(args[5]->IsArrayBufferView());
        Local<ArrayBufferView> cached_data_buf = args[5].As<ArrayBufferView>();
        uint8_t* data =
            static_cast<uint8_t*>(cached_data_buf->Buffer()->Data());
        cached_data =
            new ScriptCompiler::CachedData(data + cached_data_buf->ByteOffset(),
                                           cached_data_buf->ByteLength());
      }",36,,176,2,,void
124821,BLOCK,-1,,"{
        options = ScriptCompiler::kNoCompileOptions;
      }",46,,200,2,,void
124828,BLOCK,-1,,"{
        options = ScriptCompiler::kConsumeCodeCache;
      }",14,,202,1,,void
124849,BLOCK,-1,,"{
        if (try_catch.HasCaught() && !try_catch.HasTerminated()) {
          CHECK(!try_catch.Message().IsEmpty());
          CHECK(!try_catch.Exception().IsEmpty());
          AppendExceptionLine(env, try_catch.Exception(), try_catch.Message(),
                              ErrorHandlingMode::MODULE_ERROR);
          try_catch.ReThrow();
        }
        return;
      }",35,,206,2,,void
124861,BLOCK,-1,,"{
          CHECK(!try_catch.Message().IsEmpty());
          CHECK(!try_catch.Exception().IsEmpty());
          AppendExceptionLine(env, try_catch.Exception(), try_catch.Message(),
                              ErrorHandlingMode::MODULE_ERROR);
          try_catch.ReThrow();
        }",66,,207,2,,void
124911,BLOCK,-1,,"{
        THROW_ERR_VM_MODULE_CACHED_DATA_REJECTED(
            env, ""cachedData buffer was rejected"");
        try_catch.ReThrow();
        return;
      }",45,,217,2,,void
124936,BLOCK,-1,,"{
    return;
  }",69,,226,2,,void
124949,BLOCK,-1,,"{
    obj->synthetic_ = true;
    obj->object()->SetInternalField(kSyntheticEvaluationStepsSlot, args[3]);
  }",18,,232,2,,void
125033,BLOCK,-1,,"{
  Local<Object> assertions =
        Object::New(isolate, v8::Null(env->isolate()), nullptr, nullptr, 0);
  for (int i = 0; i < raw_assertions->Length(); i += 3) {
      assertions
          ->Set(env->context(),
                raw_assertions->Get(env->context(), i).As<String>(),
                raw_assertions->Get(env->context(), i + 1).As<Value>())
          .ToChecked();
  }

  return assertions;
}",55,,254,4,,void
125057,BLOCK,-1,,<empty>,3,,257,1,,void
125071,BLOCK,4,,"{
      assertions
          ->Set(env->context(),
                raw_assertions->Get(env->context(), i).As<String>(),
                raw_assertions->Get(env->context(), i + 1).As<Value>())
          .ToChecked();
  }",57,,257,4,,void
125115,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = args.GetIsolate();

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsFunction());

  Local<Object> that = args.This();

  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, that);

  if (obj->linked_)
    return;
  obj->linked_ = true;

  Local<Function> resolver_arg = args[0].As<Function>();

  Local<Context> mod_context = obj->context();
  Local<Module> module = obj->module_.Get(isolate);

  Local<FixedArray> module_requests = module->GetModuleRequests();
  const int module_requests_length = module_requests->Length();
  MaybeStackBuffer<Local<Value>, 16> promises(module_requests_length);

  // call the dependency resolve callbacks
  for (int i = 0; i < module_requests_length; i++) {
    Local<ModuleRequest> module_request =
      module_requests->Get(env->context(), i).As<ModuleRequest>();
    Local<String> specifier = module_request->GetSpecifier();
    Utf8Value specifier_utf8(env->isolate(), specifier);
  ...",64,,268,2,,void
125163,BLOCK,-1,,<empty>,5,,281,2,,void
125226,BLOCK,-1,,<empty>,3,,294,1,,void
125236,BLOCK,4,,"{
    Local<ModuleRequest> module_request =
      module_requests->Get(env->context(), i).As<ModuleRequest>();
    Local<String> specifier = module_request->GetSpecifier();
    Utf8Value specifier_utf8(env->isolate(), specifier);
    std::string specifier_std(*specifier_utf8, specifier_utf8.length());

    Local<FixedArray> raw_assertions = module_request->GetImportAssertions();
    Local<Object> assertions =
      createImportAssertionContainer(env, isolate, raw_assertions);

    Local<Value> argv[] = {
        specifier,
        assertions,
    };

    MaybeLocal<Value> maybe_resolve_return_value =
        resolver_arg->Call(mod_context, that, arraysize(argv), argv);
    if (maybe_resolve_return_value.IsEmpty()) {
      return;
    }
    Local<Value> resolve_return_value =
        maybe_resolve_return_value.ToLocalChecked();
    if (!resolve_return_value->IsPromise()) {
      THROW_ERR_VM_MODULE_LINK_FAILURE(
          env, ""request for '%s' did not return promise"", specifier_std)...",52,,294,4,,void
125326,BLOCK,-1,,"{
      return;
    }",47,,312,2,,void
125344,BLOCK,-1,,"{
      THROW_ERR_VM_MODULE_LINK_FAILURE(
          env, ""request for '%s' did not return promise"", specifier_std);
      return;
    }",45,,317,2,,void
125402,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = args.GetIsolate();
  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());
  Local<Context> context = obj->context();
  Local<Module> module = obj->module_.Get(isolate);
  TryCatchScope try_catch(env);
  USE(module->InstantiateModule(context, ResolveModuleCallback));

  // clear resolve cache on instantiate
  obj->resolve_cache_.clear();

  if (try_catch.HasCaught() && !try_catch.HasTerminated()) {
    CHECK(!try_catch.Message().IsEmpty());
    CHECK(!try_catch.Exception().IsEmpty());
    AppendExceptionLine(env, try_catch.Exception(), try_catch.Message(),
                        ErrorHandlingMode::MODULE_ERROR);
    try_catch.ReThrow();
    return;
  }
}",71,,332,2,,void
125476,BLOCK,-1,,"{
    CHECK(!try_catch.Message().IsEmpty());
    CHECK(!try_catch.Exception().IsEmpty());
    AppendExceptionLine(env, try_catch.Exception(), try_catch.Message(),
                        ErrorHandlingMode::MODULE_ERROR);
    try_catch.ReThrow();
    return;
  }",60,,345,2,,void
125517,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());
  Local<Context> context = obj->context();
  Local<Module> module = obj->module_.Get(isolate);

  ContextifyContext* contextify_context = obj->contextify_context_;
  std::shared_ptr<MicrotaskQueue> microtask_queue;
  if (contextify_context != nullptr)
      microtask_queue = contextify_context->microtask_queue();

  // module.evaluate(timeout, breakOnSigint)
  CHECK_EQ(args.Length(), 2);

  CHECK(args[0]->IsNumber());
  int64_t timeout = args[0]->IntegerValue(env->context()).FromJust();

  CHECK(args[1]->IsBoolean());
  bool break_on_sigint = args[1]->IsTrue();

  ShouldNotAbortOnUncaughtScope no_abort_scope(env);
  TryCatchScope try_catch(env);
  Isolate::SafeForTerminationScope safe_for_termination(env->isolate());

  bool timed_out = false;
  bool received_signal = false;
  MaybeLocal<Value> result;
  auto run = [&]() {
    Ma...",68,,355,2,,void
125580,BLOCK,-1,,<empty>,7,,366,2,,void
125668,BLOCK,-1,,"{
    Watchdog wd(isolate, timeout, &timed_out);
    SigintWatchdog swd(isolate, &received_signal);
    result = run();
  }",41,,390,2,,void
125684,BLOCK,-1,,<empty>,10,,394,1,,void
125687,BLOCK,-1,,"{
    SigintWatchdog swd(isolate, &received_signal);
    result = run();
  }",31,,394,2,,void
125697,BLOCK,-1,,<empty>,10,,397,1,,void
125703,BLOCK,-1,,"{
    Watchdog wd(isolate, timeout, &timed_out);
    result = run();
  }",29,,397,2,,void
125714,BLOCK,-1,,"{
    result = run();
  }",10,,400,1,,void
125723,BLOCK,-1,,"{
    CHECK(try_catch.HasCaught());
  }",25,,404,2,,void
125733,BLOCK,-1,,"{
    if (!env->is_main_thread() && env->is_stopping())
      return;
    env->isolate()->CancelTerminateExecution();
    // It is possible that execution was terminated by another timeout in
    // which this timeout is nested, so check whether one of the watchdogs
    // from this invocation is responsible for termination.
    if (timed_out) {
      THROW_ERR_SCRIPT_EXECUTION_TIMEOUT(env, timeout);
    } else if (received_signal) {
      THROW_ERR_SCRIPT_EXECUTION_INTERRUPTED(env);
    }
  }",37,,409,2,,void
125745,BLOCK,-1,,<empty>,7,,411,2,,void
125756,BLOCK,-1,,"{
      THROW_ERR_SCRIPT_EXECUTION_TIMEOUT(env, timeout);
    }",20,,416,2,,void
125761,BLOCK,-1,,<empty>,12,,418,1,,void
125764,BLOCK,-1,,"{
      THROW_ERR_SCRIPT_EXECUTION_INTERRUPTED(env);
    }",33,,418,2,,void
125772,BLOCK,-1,,"{
    if (!try_catch.HasTerminated())
      try_catch.ReThrow();
    return;
  }",30,,423,2,,void
125779,BLOCK,-1,,<empty>,7,,425,2,,void
125800,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = args.GetIsolate();
  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());

  Local<Module> module = obj->module_.Get(isolate);

  switch (module->GetStatus()) {
    case v8::Module::Status::kUninstantiated:
    case v8::Module::Status::kInstantiating:
      return env->ThrowError(
          ""cannot get namespace, module has not been instantiated"");
    case v8::Module::Status::kInstantiated:
    case v8::Module::Status::kEvaluating:
    case v8::Module::Status::kEvaluated:
    case v8::Module::Status::kErrored:
      break;
    default:
      UNREACHABLE();
  }

  Local<Value> result = module->GetModuleNamespace();
  args.GetReturnValue().Set(result);
}",72,,432,2,,void
125842,BLOCK,-1,,"{
    case v8::Module::Status::kUninstantiated:
    case v8::Module::Status::kInstantiating:
      return env->ThrowError(
          ""cannot get namespace, module has not been instantiated"");
    case v8::Module::Status::kInstantiated:
    case v8::Module::Status::kEvaluating:
    case v8::Module::Status::kEvaluated:
    case v8::Module::Status::kErrored:
      break;
    default:
      UNREACHABLE();
  }",32,,440,2,,void
125922,BLOCK,-1,,"{
  Isolate* isolate = args.GetIsolate();
  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());

  Local<Module> module = obj->module_.Get(isolate);

  args.GetReturnValue().Set(module->GetStatus());
}",69,,458,2,,void
125966,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());

  Local<Module> module = obj->module_.Get(env->isolate());

  Local<FixedArray> module_requests = module->GetModuleRequests();
  int count = module_requests->Length();

  MaybeStackBuffer<Local<Value>, 16> specifiers(count);

  for (int i = 0; i < count; i++) {
    Local<ModuleRequest> module_request =
      module_requests->Get(env->context(), i).As<ModuleRequest>();
    specifiers[i] = module_request->GetSpecifier();
  }

  args.GetReturnValue().Set(
      Array::New(env->isolate(), specifiers.out(), count));
}",46,,469,2,,void
126020,BLOCK,-1,,<empty>,3,,481,1,,void
126030,BLOCK,4,,"{
    Local<ModuleRequest> module_request =
      module_requests->Get(env->context(), i).As<ModuleRequest>();
    specifiers[i] = module_request->GetSpecifier();
  }",35,,481,4,,void
126081,BLOCK,-1,,"{
  Isolate* isolate = args.GetIsolate();
  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());

  Local<Module> module = obj->module_.Get(isolate);
  args.GetReturnValue().Set(module->GetException());
}",68,,491,2,,void
126128,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  if (env == nullptr) {
    Isolate* isolate = context->GetIsolate();
    THROW_ERR_EXECUTION_ENVIRONMENT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Module>();
  }

  Isolate* isolate = env->isolate();

  Utf8Value specifier_utf8(isolate, specifier);
  std::string specifier_std(*specifier_utf8, specifier_utf8.length());

  ModuleWrap* dependent = GetFromModule(env, referrer);
  if (dependent == nullptr) {
    THROW_ERR_VM_MODULE_LINK_FAILURE(
        env, ""request for '%s' is from invalid module"", specifier_std);
    return MaybeLocal<Module>();
  }

  if (dependent->resolve_cache_.count(specifier_std) != 1) {
    THROW_ERR_VM_MODULE_LINK_FAILURE(
        env, ""request for '%s' is not in cache"", specifier_std);
    return MaybeLocal<Module>();
  }

  Local<Promise> resolve_promise =
      dependent->resolve_cache_[specifier_std].Get(isolate);

  if (resolve_promise->State() != Promise::kFulfilled) {
    THROW_ERR_VM_MODULE_...",29,,504,5,,void
126141,BLOCK,-1,,"{
    Isolate* isolate = context->GetIsolate();
    THROW_ERR_EXECUTION_ENVIRONMENT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Module>();
  }",23,,506,2,,void
126182,BLOCK,-1,,"{
    THROW_ERR_VM_MODULE_LINK_FAILURE(
        env, ""request for '%s' is from invalid module"", specifier_std);
    return MaybeLocal<Module>();
  }",29,,518,2,,void
126199,BLOCK,-1,,"{
    THROW_ERR_VM_MODULE_LINK_FAILURE(
        env, ""request for '%s' is not in cache"", specifier_std);
    return MaybeLocal<Module>();
  }",60,,524,2,,void
126230,BLOCK,-1,,"{
    THROW_ERR_VM_MODULE_LINK_FAILURE(
        env, ""request for '%s' is not yet fulfilled"", specifier_std);
    return MaybeLocal<Module>();
  }",56,,533,2,,void
126261,BLOCK,-1,,"{
    THROW_ERR_VM_MODULE_LINK_FAILURE(
        env, ""request for '%s' did not return an object"", specifier_std);
    return MaybeLocal<Module>();
  }",62,,540,2,,void
126290,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  Environment* env = Environment::GetCurrent(context);
  if (env == nullptr) {
    THROW_ERR_EXECUTION_ENVIRONMENT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Promise>();
  }

  EscapableHandleScope handle_scope(isolate);

  Local<Function> import_callback =
    env->host_import_module_dynamically_callback();

  Local<FixedArray> options = host_defined_options.As<FixedArray>();
  if (options->Length() != HostDefinedOptions::kLength) {
    Local<Promise::Resolver> resolver;
    if (!Promise::Resolver::New(context).ToLocal(&resolver)) return {};
    resolver
        ->Reject(context,
                 v8::Exception::TypeError(FIXED_ONE_BYTE_STRING(
                     context->GetIsolate(), ""Invalid host defined options"")))
        .ToChecked();
    return handle_scope.Escape(resolver->GetPromise());
  }

  Local<Value> object;

  int type = options->Get(context, HostDefinedOptions::kType)
                 .As<Number>()
                 ...",42,,556,6,,void
126310,BLOCK,-1,,"{
    THROW_ERR_EXECUTION_ENVIRONMENT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Promise>();
  }",23,,559,2,,void
126347,BLOCK,-1,,"{
    Local<Promise::Resolver> resolver;
    if (!Promise::Resolver::New(context).ToLocal(&resolver)) return {};
    resolver
        ->Reject(context,
                 v8::Exception::TypeError(FIXED_ONE_BYTE_STRING(
                     context->GetIsolate(), ""Invalid host defined options"")))
        .ToChecked();
    return handle_scope.Escape(resolver->GetPromise());
  }",57,,570,2,,void
126369,BLOCK,-1,,<empty>,62,,572,2,,void
126453,BLOCK,-1,,"{
    contextify::ContextifyScript* wrap = env->id_to_script_map.find(id)->second;
    object = wrap->object();
  }",36,,591,2,,void
126473,BLOCK,-1,,<empty>,10,,594,1,,void
126480,BLOCK,-1,,"{
    ModuleWrap* wrap = ModuleWrap::GetFromID(env, id);
    object = wrap->object();
  }",43,,594,2,,void
126497,BLOCK,-1,,<empty>,10,,597,1,,void
126504,BLOCK,-1,,"{
    auto it = env->id_to_function_map.find(id);
    CHECK_NE(it, env->id_to_function_map.end());
    object = it->second->object();
  }",45,,597,2,,void
126532,BLOCK,-1,,"{
    UNREACHABLE();
  }",10,,601,1,,void
126576,BLOCK,-1,,"{
    CHECK(result->IsPromise());
    return handle_scope.Escape(result.As<Promise>());
  }",40,,619,2,,void
126597,BLOCK,-1,,"{
  Isolate* isolate = args.GetIsolate();
  Environment* env = Environment::GetCurrent(args);
  HandleScope handle_scope(isolate);

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsFunction());
  Local<Function> import_callback = args[0].As<Function>();
  env->set_host_import_module_dynamically_callback(import_callback);

  isolate->SetHostImportModuleDynamicallyCallback(ImportModuleDynamically);
}",46,,628,2,,void
126657,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  if (env == nullptr)
    return;
  ModuleWrap* module_wrap = GetFromModule(env, module);

  if (module_wrap == nullptr) {
    return;
  }

  Local<Object> wrap = module_wrap->object();
  Local<Function> callback =
      env->host_initialize_import_meta_object_callback();
  Local<Value> args[] = { wrap, meta };
  TryCatchScope try_catch(env);
  USE(callback->Call(
        context, Undefined(env->isolate()), arraysize(args), args));
  if (try_catch.HasCaught() && !try_catch.HasTerminated()) {
    try_catch.ReThrow();
  }
}",71,,642,4,,void
126670,BLOCK,-1,,<empty>,5,,645,2,,void
126682,BLOCK,-1,,"{
    return;
  }",31,,648,2,,void
126738,BLOCK,-1,,"{
    try_catch.ReThrow();
  }",60,,659,2,,void
126747,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsFunction());
  Local<Function> import_meta_callback = args[0].As<Function>();
  env->set_host_initialize_import_meta_object_callback(import_meta_callback);

  isolate->SetHostInitializeImportMetaObjectCallback(
      HostInitializeImportMetaObjectCallback);
}",46,,665,2,,void
126803,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  ModuleWrap* obj = GetFromModule(env, module);

  TryCatchScope try_catch(env);
  Local<Function> synthetic_evaluation_steps =
      obj->object()->GetInternalField(kSyntheticEvaluationStepsSlot)
          .As<Function>();
  obj->object()->SetInternalField(
      kSyntheticEvaluationStepsSlot, Undefined(isolate));
  MaybeLocal<Value> ret = synthetic_evaluation_steps->Call(context,
      obj->object(), 0, nullptr);
  if (ret.IsEmpty()) {
    CHECK(try_catch.HasCaught());
  }
  if (try_catch.HasCaught() && !try_catch.HasTerminated()) {
    CHECK(!try_catch.Message().IsEmpty());
    CHECK(!try_catch.Exception().IsEmpty());
    try_catch.ReThrow();
    return MaybeLocal<Value>();
  }

  Local<Promise::Resolver> resolver;
  if (!Promise::Resolver::New(context).ToLocal(&resolver)) {
    return MaybeLocal<Value>();
  }

  resolver->Resolve(context, Undefined(isolate)).ToChecked();
  return resol...",51,,679,3,,void
126877,BLOCK,-1,,"{
    CHECK(try_catch.HasCaught());
  }",22,,693,2,,void
126894,BLOCK,-1,,"{
    CHECK(!try_catch.Message().IsEmpty());
    CHECK(!try_catch.Exception().IsEmpty());
    try_catch.ReThrow();
    return MaybeLocal<Value>();
  }",60,,696,2,,void
126940,BLOCK,-1,,"{
    return MaybeLocal<Value>();
  }",60,,704,2,,void
126962,BLOCK,-1,,"{
  Isolate* isolate = args.GetIsolate();
  Local<Object> that = args.This();

  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, that);

  CHECK(obj->synthetic_);

  CHECK_EQ(args.Length(), 2);

  CHECK(args[0]->IsString());
  Local<String> export_name = args[0].As<String>();

  Local<Value> export_value = args[1];

  Local<Module> module = obj->module_.Get(isolate);
  USE(module->SetSyntheticModuleExport(isolate, export_name, export_value));
}",78,,712,2,,void
127048,BLOCK,-1,,"{
  Isolate* isolate = args.GetIsolate();
  Local<Object> that = args.This();

  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, that);

  CHECK(!obj->synthetic_);

  Local<Module> module = obj->module_.Get(isolate);

  CHECK_LT(module->GetStatus(), v8::Module::Status::kEvaluating);

  Local<UnboundModuleScript> unbound_module_script =
      module->GetUnboundModuleScript();
  std::unique_ptr<ScriptCompiler::CachedData> cached_data(
      ScriptCompiler::CreateCodeCache(unbound_module_script));
  Environment* env = Environment::GetCurrent(args);
  if (!cached_data) {
    args.GetReturnValue().Set(Buffer::New(env, 0).ToLocalChecked());
  } else {
    MaybeLocal<Object> buf =
        Buffer::Copy(env,
                     reinterpret_cast<const char*>(cached_data->data),
                     cached_data->length);
    args.GetReturnValue().Set(buf.ToLocalChecked());
  }
}",76,,732,2,,void
127113,BLOCK,-1,,<empty>,,,,2,,<empty>
127127,BLOCK,-1,,"{
    args.GetReturnValue().Set(Buffer::New(env, 0).ToLocalChecked());
  }",21,,750,2,,void
127145,BLOCK,-1,,"{
    MaybeLocal<Object> buf =
        Buffer::Copy(env,
                     reinterpret_cast<const char*>(cached_data->data),
                     cached_data->length);
    args.GetReturnValue().Set(buf.ToLocalChecked());
  }",10,,752,1,,void
127183,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> tpl = NewFunctionTemplate(isolate, New);
  tpl->InstanceTemplate()->SetInternalFieldCount(
      ModuleWrap::kInternalFieldCount);

  SetProtoMethod(isolate, tpl, ""link"", Link);
  SetProtoMethod(isolate, tpl, ""instantiate"", Instantiate);
  SetProtoMethod(isolate, tpl, ""evaluate"", Evaluate);
  SetProtoMethod(isolate, tpl, ""setExport"", SetSyntheticExport);
  SetProtoMethodNoSideEffect(
      isolate, tpl, ""createCachedData"", CreateCachedData);
  SetProtoMethodNoSideEffect(isolate, tpl, ""getNamespace"", GetNamespace);
  SetProtoMethodNoSideEffect(isolate, tpl, ""getStatus"", GetStatus);
  SetProtoMethodNoSideEffect(isolate, tpl, ""getError"", GetError);
  SetProtoMethodNoSideEffect(isolate,
                             tpl,
                             ""getStaticDependencySpecifiers"",
                             GetStaticDependencySpecifiers);

  SetConstructorFunction(c...",41,,764,5,,void
127279,BLOCK,1,,<empty>,,,,3,,void
127308,BLOCK,1,,<empty>,,,,3,,void
127337,BLOCK,1,,<empty>,,,,3,,void
127366,BLOCK,1,,<empty>,,,,3,,void
127395,BLOCK,1,,<empty>,,,,3,,void
127424,BLOCK,1,,<empty>,,,,3,,void
127456,BLOCK,-1,,"{
  registry->Register(New);

  registry->Register(Link);
  registry->Register(Instantiate);
  registry->Register(Evaluate);
  registry->Register(SetSyntheticExport);
  registry->Register(CreateCachedData);
  registry->Register(GetNamespace);
  registry->Register(GetStatus);
  registry->Register(GetError);
  registry->Register(GetStaticDependencySpecifiers);

  registry->Register(SetImportModuleDynamicallyCallback);
  registry->Register(SetInitializeImportMetaObjectCallback);
}",42,,812,2,,void
127532,BLOCK,-1,,<empty>,1,,1,1,,ANY
127536,BLOCK,-1,,"{
      Environment* env = static_cast<Environment*>(data);
      env->isolate()->SetAtomicsWaitCallback(nullptr, nullptr);
    }",35,,255,2,,void
127557,BLOCK,-1,,{ env->set_embedder_entry_point({}); },28,,284,1,,void
127568,BLOCK,-1,,"{
    TearDownOncePerProcess();

    if (snapshot_data != nullptr &&
        snapshot_data->data_ownership == SnapshotData::DataOwnership::kOwned) {
      delete snapshot_data;
    }
  }",45,,1231,1,,void
127584,BLOCK,-1,,"{
      delete snapshot_data;
    }",79,,1235,2,,void
127699,BLOCK,-1,,<empty>,1,,1,1,,ANY
127726,BLOCK,-1,,"{
  Environment* env = static_cast<Environment*>(data);

  const char* message = ""(unknown event)"";
  switch (event) {
#define V(key, msg)                         \
    case Isolate::AtomicsWaitEvent::key:    \
      message = msg;                        \
      break;
    ATOMIC_WAIT_EVENTS(V)
#undef V
  }

  fprintf(stderr,
          ""(node:%d) [Thread %"" PRIu64 ""] Atomics.wait(%p + %zx, %"" PRId64
          "", %.f) %s\n"",
          static_cast<int>(uv_os_getpid()),
          env->thread_id(),
          array_buffer->Data(),
          offset_in_bytes,
          value,
          timeout_in_ms,
          message);
}",45,,220,8,,void
127739,BLOCK,-1,,"{
#define V(key, msg)                         \
    case Isolate::AtomicsWaitEvent::key:    \
      message = msg;                        \
      break;
    ATOMIC_WAIT_EVENTS(V)
#undef V
  }",18,,224,2,,void
127741,BLOCK,1,,<empty>,,,,1,,void
127806,BLOCK,-1,,"{
  isolate_->GetHeapProfiler()->AddBuildEmbedderGraphCallback(
      Environment::BuildEmbedderGraph, this);
  if (heap_snapshot_near_heap_limit_ > 0) {
    AddHeapSnapshotNearHeapLimitCallback();
  }
  if (options_->trace_uncaught)
    isolate_->SetCaptureStackTraceForUncaughtExceptions(true);
  if (options_->trace_atomics_wait) {
    isolate_->SetAtomicsWaitCallback(AtomicsWaitCallback, this);
    AddCleanupHook([](void* data) {
      Environment* env = static_cast<Environment*>(data);
      env->isolate()->SetAtomicsWaitCallback(nullptr, nullptr);
    }, this);
  }
}",43,,245,1,,void
127822,BLOCK,-1,,"{
    AddHeapSnapshotNearHeapLimitCallback();
  }",43,,248,2,,void
127828,BLOCK,-1,,<empty>,5,,252,2,,void
127838,BLOCK,-1,,"{
    isolate_->SetAtomicsWaitCallback(AtomicsWaitCallback, this);
    AddCleanupHook([](void* data) {
      Environment* env = static_cast<Environment*>(data);
      env->isolate()->SetAtomicsWaitCallback(nullptr, nullptr);
    }, this);
  }",37,,253,2,,void
127853,BLOCK,-1,,"{
  EscapableHandleScope scope(env->isolate());
  CHECK_NOT_NULL(main_script_id);
  Realm* realm = env->principal_realm();

  return scope.EscapeMaybe(realm->ExecuteBootstrapper(main_script_id));
}",80,,263,3,,void
127883,BLOCK,-1,,"{
  InternalCallbackScope callback_scope(
      env,
      Object::New(env->isolate()),
      { 1, 0 },
      InternalCallbackScope::kSkipAsyncHooks);

  if (cb != nullptr) {
    EscapableHandleScope scope(env->isolate());
    // TODO(addaleax): pass the callback to the main script more directly,
    // e.g. by making StartExecution(env, builtin) parametrizable
    env->set_embedder_entry_point(std::move(cb));
    auto reset_entry_point =
        OnScopeLeave([&]() { env->set_embedder_entry_point({}); });

    const char* entry = env->isolate_data()->options()->build_snapshot
                            ? ""internal/main/mksnapshot""
                            : ""internal/main/embedding"";

    return scope.EscapeMaybe(StartExecution(env, entry));
  }

  // TODO(joyeecheung): move these conditions into JS land and let the
  // deserialize main function take precedence. For workers, we need to
  // move the pre-execution part into a different file that can be
  // reused when dealing w...",79,,271,3,,void
127905,BLOCK,-1,,"{
    EscapableHandleScope scope(env->isolate());
    // TODO(addaleax): pass the callback to the main script more directly,
    // e.g. by making StartExecution(env, builtin) parametrizable
    env->set_embedder_entry_point(std::move(cb));
    auto reset_entry_point =
        OnScopeLeave([&]() { env->set_embedder_entry_point({}); });

    const char* entry = env->isolate_data()->options()->build_snapshot
                            ? ""internal/main/mksnapshot""
                            : ""internal/main/embedding"";

    return scope.EscapeMaybe(StartExecution(env, entry));
  }",22,,278,2,,void
127958,BLOCK,-1,,"{
    return env->RunSnapshotDeserializeMain();
  }",52,,297,2,,void
127971,BLOCK,-1,,"{
    return StartExecution(env, ""internal/main/worker_thread"");
  }",41,,301,2,,void
127987,BLOCK,-1,,"{
    first_argv = env->argv()[1];
  }",31,,306,2,,void
128000,BLOCK,-1,,"{
    return StartExecution(env, ""internal/main/inspect"");
  }",32,,310,2,,void
128015,BLOCK,-1,,"{
    return StartExecution(env, ""internal/main/mksnapshot"");
  }",55,,314,2,,void
128026,BLOCK,-1,,"{
    return StartExecution(env, ""internal/main/print_help"");
  }",45,,318,2,,void
128038,BLOCK,-1,,"{
    return StartExecution(env, ""internal/main/prof_process"");
  }",37,,323,2,,void
128058,BLOCK,-1,,"{
    return StartExecution(env, ""internal/main/eval_string"");
  }",71,,328,2,,void
128070,BLOCK,-1,,"{
    return StartExecution(env, ""internal/main/check_syntax"");
  }",42,,332,2,,void
128082,BLOCK,-1,,"{
    return StartExecution(env, ""internal/main/test_runner"");
  }",36,,336,2,,void
128094,BLOCK,-1,,"{
    return StartExecution(env, ""internal/main/watch_mode"");
  }",35,,340,2,,void
128109,BLOCK,-1,,"{
    return StartExecution(env, ""internal/main/run_main_module"");
  }",49,,344,2,,void
128126,BLOCK,-1,,"{
    return StartExecution(env, ""internal/main/repl"");
  }",78,,348,2,,void
128138,BLOCK,-1,,"{
#ifdef __POSIX__
  // Restore signal dispositions, the parent process may have changed them.
  struct sigaction act;
  memset(&act, 0, sizeof(act));

  // The hard-coded upper limit is because NSIG is not very reliable; on Linux,
  // it evaluates to 32, 34 or 64, depending on whether RT signals are enabled.
  // Counting up to SIGRTMIN doesn't work for the same reason.
  for (unsigned nr = 1; nr < kMaxSignal; nr += 1) {
    if (nr == SIGKILL || nr == SIGSTOP)
      continue;
    act.sa_handler = (nr == SIGPIPE || nr == SIGXFSZ) ? SIG_IGN : SIG_DFL;
    if (act.sa_handler == SIG_DFL) {
      // The only bad handler value we can inhert from before exec is SIG_IGN
      // (any actual function pointer is reset to SIG_DFL during exec).
      // If that's the case, we want to reset it back to SIG_DFL.
      // However, it's also possible that an embeder (or an LD_PRELOAD-ed
      // library) has set up own signal handler for own purposes
      // (e.g. profiling). If that's the case, ...",28,,420,1,,void
128151,BLOCK,-1,,"{
  // init_process_flags is accessed in ResetStdio(),
  // which can be called from signal handlers.
  CHECK(init_process_flags.is_lock_free());
  init_process_flags.store(flags);

  if (!(flags & ProcessInitializationFlags::kNoStdioInitialization)) {
    atexit(ResetStdio);
  }

#ifdef __POSIX__
  if (!(flags & ProcessInitializationFlags::kNoStdioInitialization)) {
    // Disable stdio buffering, it interacts poorly with printf()
    // calls elsewhere in the program (e.g., any logging from V8.)
    setvbuf(stdout, nullptr, _IONBF, 0);
    setvbuf(stderr, nullptr, _IONBF, 0);

    // Make sure file descriptors 0-2 are valid before we start logging
    // anything.
    for (auto& s : stdio) {
      const int fd = &s - stdio;
      if (fstat(fd, &s.stat) == 0) continue;

      // Anything but EBADF means something is seriously wrong.  We don't
      // have to special-case EINTR, fstat() is not interruptible.
      if (errno != EBADF) ABORT();

      // If EBADF (file descriptor doe...",67,,457,2,,void
128169,BLOCK,-1,,"{
    atexit(ResetStdio);
  }",70,,463,2,,void
128174,BLOCK,-1,,"{
  if (init_process_flags.load() &
      ProcessInitializationFlags::kNoStdioInitialization) {
    return;
  }

  uv_tty_reset_mode();
#ifdef __POSIX__
  for (auto& s : stdio) {
    const int fd = &s - stdio;

    struct stat tmp;
    if (-1 == fstat(fd, &tmp)) {
      CHECK_EQ(errno, EBADF);  // Program closed file descriptor.
      continue;
    }

    bool is_same_file =
        (s.stat.st_dev == tmp.st_dev && s.stat.st_ino == tmp.st_ino);
    if (!is_same_file) continue;  // Program reopened file descriptor.

    int flags;
    do
      flags = fcntl(fd, F_GETFL);
    while (flags == -1 && errno == EINTR);  // NOLINT
    CHECK_NE(flags, -1);

    // Restore the O_NONBLOCK flag if it changed.
    if (O_NONBLOCK & (flags ^ s.flags)) {
      flags &= ~O_NONBLOCK;
      flags |= s.flags & O_NONBLOCK;

      int err;
      do
        err = fcntl(fd, F_SETFL, flags);
      while (err == -1 && errno == EINTR);  // NOLINT
      CHECK_NE(err, -1);
    }

    if (s.isatty) {
      sigset...",19,,611,1,,void
128184,BLOCK,-1,,"{
    return;
  }",59,,613,2,,void
128194,BLOCK,-1,,"{
  // Parse a few arguments which are specific to Node.
  std::vector<std::string> v8_args;

  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  options_parser::Parse(
      args,
      exec_args,
      &v8_args,
      per_process::cli_options.get(),
      settings,
      errors);

  if (!errors->empty()) return ExitCode::kInvalidCommandLineArgument;

  std::string revert_error;
  for (const std::string& cve : per_process::cli_options->security_reverts) {
    Revert(cve.c_str(), &revert_error);
    if (!revert_error.empty()) {
      errors->emplace_back(std::move(revert_error));
      // TODO(joyeecheung): merge into kInvalidCommandLineArgument.
      return ExitCode::kInvalidCommandLineArgument2;
    }
  }

  if (per_process::cli_options->disable_proto != ""delete"" &&
      per_process::cli_options->disable_proto != ""throw"" &&
      per_process::cli_options->disable_proto != """") {
    errors->emplace_back(""invalid mode passed to --disable-proto"");
    // TODO(joyeecheung): ...",74,,676,5,,void
128231,BLOCK,-1,,<empty>,25,,689,2,,void
128244,BLOCK,-1,,"{
    Revert(cve.c_str(), &revert_error);
    if (!revert_error.empty()) {
      errors->emplace_back(std::move(revert_error));
      // TODO(joyeecheung): merge into kInvalidCommandLineArgument.
      return ExitCode::kInvalidCommandLineArgument2;
    }
  }",77,,692,3,,void
128258,BLOCK,-1,,"{
      errors->emplace_back(std::move(revert_error));
      // TODO(joyeecheung): merge into kInvalidCommandLineArgument.
      return ExitCode::kInvalidCommandLineArgument2;
    }",32,,694,2,,void
128296,BLOCK,-1,,"{
    errors->emplace_back(""invalid mode passed to --disable-proto"");
    // TODO(joyeecheung): merge into kInvalidCommandLineArgument.
    return ExitCode::kInvalidCommandLineArgument2;
  }",54,,703,2,,void
128325,BLOCK,-1,,"{
    v8_args.emplace_back(""--harmony-import-assertions"");
  }",69,,712,2,,void
128379,BLOCK,-1,,"{
    env_opts->abort_on_uncaught_exception = true;
  }",68,,720,2,,void
128398,BLOCK,-1,,"{
    for (size_t i = 0; i < v8_args.size(); ++i)
      v8_args_as_char_ptr[i] = v8_args[i].data();
    int argc = v8_args.size();
    V8::SetFlagsFromCommandLine(&argc, v8_args_as_char_ptr.data(), true);
    v8_args_as_char_ptr.resize(argc);
  }",27,,734,2,,void
128400,BLOCK,-1,,<empty>,5,,735,1,,void
128447,BLOCK,-1,,<empty>,3,,743,1,,void
128480,BLOCK,-1,,<empty>,5,,747,2,,void
128496,BLOCK,-1,,"{
  return static_cast<int>(
      ProcessGlobalArgsInternal(args, exec_args, errors, settings));
}",54,,755,5,,void
128517,BLOCK,-1,,"{
  // Make sure InitializeNodeWithArgs() is called only once.
  CHECK(!init_called.exchange(true));

  // Initialize node_start_time to get relative uptime.
  per_process::node_start_time = uv_hrtime();

  // Register built-in bindings
  binding::RegisterBuiltinBindings();

  // Make inherited handles noninheritable.
  if (!(flags & ProcessInitializationFlags::kEnableStdioInheritance) &&
      !(flags & ProcessInitializationFlags::kNoStdioInitialization)) {
    uv_disable_stdio_inheritance();
  }

  // Cache the original command line to be
  // used in diagnostic reports.
  per_process::cli_options->cmdline = *argv;

  // Node provides a ""v8.setFlagsFromString"" method to dynamically change flags.
  // Hence do not freeze flags when initializing V8. In a browser setting, this
  // is security relevant, for Node it's less important.
  V8::SetFlagsFromString(""--no-freeze-flags-after-init"");

#if defined(NODE_V8_OPTIONS)
  // Should come before the call to V8::SetFlagsFromCommandLine()...",46,,768,5,,void
128548,BLOCK,-1,,"{
    uv_disable_stdio_inheritance();
  }",70,,780,2,,void
128578,BLOCK,-1,,"{
    std::string node_options;

    if (credentials::SafeGetenv(""NODE_OPTIONS"", &node_options)) {
      std::vector<std::string> env_argv =
          ParseNodeOptionsEnvVar(node_options, errors);

      if (!errors->empty()) return ExitCode::kInvalidCommandLineArgument;

      // [0] is expected to be the program name, fill it in from the real argv.
      env_argv.insert(env_argv.begin(), argv->at(0));

      const ExitCode exit_code = ProcessGlobalArgsInternal(
          &env_argv, nullptr, errors, kAllowedInEnvvar);
      if (exit_code != ExitCode::kNoFailure) return exit_code;
    }
  }",70,,803,2,,void
128588,BLOCK,-1,,"{
      std::vector<std::string> env_argv =
          ParseNodeOptionsEnvVar(node_options, errors);

      if (!errors->empty()) return ExitCode::kInvalidCommandLineArgument;

      // [0] is expected to be the program name, fill it in from the real argv.
      env_argv.insert(env_argv.begin(), argv->at(0));

      const ExitCode exit_code = ProcessGlobalArgsInternal(
          &env_argv, nullptr, errors, kAllowedInEnvvar);
      if (exit_code != ExitCode::kNoFailure) return exit_code;
    }",65,,806,2,,void
128608,BLOCK,-1,,<empty>,29,,810,2,,void
128641,BLOCK,-1,,<empty>,46,,817,2,,void
128651,BLOCK,-1,,"{
    const ExitCode exit_code =
        ProcessGlobalArgsInternal(argv, exec_argv, errors, kDisallowedInEnvvar);
    if (exit_code != ExitCode::kNoFailure) return exit_code;
  }",66,,822,2,,void
128666,BLOCK,-1,,<empty>,44,,825,2,,void
128679,BLOCK,-1,,<empty>,5,,830,2,,void
128703,BLOCK,-1,,"{
  return static_cast<int>(
      InitializeNodeWithArgsInternal(argv, exec_argv, errors, flags));
}",69,,886,5,,void
128717,BLOCK,-1,,"{
  auto result = std::make_unique<InitializationResultImpl>();
  result->args_ = args;

  if (!(flags & ProcessInitializationFlags::kNoParseGlobalDebugVariables)) {
    // Initialized the enabled list for Debug() calls with system
    // environment variables.
    per_process::enabled_debug_list.Parse();
  }

  PlatformInit(flags);

  // This needs to run *before* V8::Initialize().
  {
    result->exit_code_ = InitializeNodeWithArgsInternal(
        &result->args_, &result->exec_args_, &result->errors_, flags);
    if (result->exit_code_enum() != ExitCode::kNoFailure) {
      result->early_return_ = true;
      return result;
    }
  }

  if (!(flags & ProcessInitializationFlags::kNoUseLargePages) &&
      (per_process::cli_options->use_largepages == ""on"" ||
       per_process::cli_options->use_largepages == ""silent"")) {
    int lp_result = node::MapStaticCodeToLargePages();
    if (per_process::cli_options->use_largepages == ""on"" && lp_result != 0) {
      result->errors_.emplace_...",76,,894,3,,void
128737,BLOCK,-1,,"{
    // Initialized the enabled list for Debug() calls with system
    // environment variables.
    per_process::enabled_debug_list.Parse();
  }",76,,898,2,,void
128746,BLOCK,6,,"{
    result->exit_code_ = InitializeNodeWithArgsInternal(
        &result->args_, &result->exec_args_, &result->errors_, flags);
    if (result->exit_code_enum() != ExitCode::kNoFailure) {
      result->early_return_ = true;
      return result;
    }
  }",3,,907,6,,void
128774,BLOCK,-1,,"{
      result->early_return_ = true;
      return result;
    }",59,,910,2,,void
128805,BLOCK,-1,,"{
    int lp_result = node::MapStaticCodeToLargePages();
    if (per_process::cli_options->use_largepages == ""on"" && lp_result != 0) {
      result->errors_.emplace_back(node::LargePagesError(lp_result));
    }
  }",63,,918,2,,void
128825,BLOCK,-1,,"{
      result->errors_.emplace_back(node::LargePagesError(lp_result));
    }",77,,920,2,,void
128844,BLOCK,-1,,"{
    if (per_process::cli_options->print_version) {
      printf(""%s\n"", NODE_VERSION);
      result->exit_code_ = ExitCode::kNoFailure;
      result->early_return_ = true;
      return result;
    }

    if (per_process::cli_options->print_bash_completion) {
      std::string completion = options_parser::GetBashCompletion();
      printf(""%s\n"", completion.c_str());
      result->exit_code_ = ExitCode::kNoFailure;
      result->early_return_ = true;
      return result;
    }

    if (per_process::cli_options->print_v8_help) {
      V8::SetFlagsFromString(""--help"", static_cast<size_t>(6));
      result->exit_code_ = ExitCode::kNoFailure;
      result->early_return_ = true;
      return result;
    }
  }",75,,925,2,,void
128851,BLOCK,-1,,"{
      printf(""%s\n"", NODE_VERSION);
      result->exit_code_ = ExitCode::kNoFailure;
      result->early_return_ = true;
      return result;
    }",50,,926,2,,void
128855,BLOCK,1,,<empty>,,,,1,,void
128877,BLOCK,-1,,"{
      std::string completion = options_parser::GetBashCompletion();
      printf(""%s\n"", completion.c_str());
      result->exit_code_ = ExitCode::kNoFailure;
      result->early_return_ = true;
      return result;
    }",58,,933,2,,void
128911,BLOCK,-1,,"{
      V8::SetFlagsFromString(""--help"", static_cast<size_t>(6));
      result->exit_code_ = ExitCode::kNoFailure;
      result->early_return_ = true;
      return result;
    }",50,,941,2,,void
128941,BLOCK,-1,,"{
#if HAVE_OPENSSL && !defined(OPENSSL_IS_BORINGSSL)
    auto GetOpenSSLErrorString = []() -> std::string {
      std::string ret;
      ERR_print_errors_cb(
          [](const char* str, size_t len, void* opaque) {
            std::string* ret = static_cast<std::string*>(opaque);
            ret->append(str, len);
            ret->append(""\n"");
            return 0;
          },
          static_cast<void*>(&ret));
      return ret;
    };

    {
      std::string extra_ca_certs;
      if (credentials::SafeGetenv(""NODE_EXTRA_CA_CERTS"", &extra_ca_certs))
        crypto::UseExtraCaCerts(extra_ca_certs);
    }
    // In the case of FIPS builds we should make sure
    // the random source is properly initialized first.
#if OPENSSL_VERSION_MAJOR >= 3
    // Call OPENSSL_init_crypto to initialize OPENSSL_INIT_LOAD_CONFIG to
    // avoid the default behavior where errors raised during the parsing of the
    // OpenSSL configuration file are not propagated and cannot be detected.
    //
  ...",62,,949,2,,void
128949,BLOCK,-1,,"{
    per_process::v8_platform.Initialize(
        static_cast<int>(per_process::cli_options->v8_thread_pool_size));
    result->platform_ = per_process::v8_platform.Platform();
  }",75,,1058,2,,void
128980,BLOCK,-1,,"{
    V8::Initialize();
  }",63,,1064,2,,void
129002,BLOCK,-1,,"{
  return InitializeOncePerProcessInternal(args, flags);
}",46,,1076,3,,void
129010,BLOCK,-1,,"{
  const uint32_t flags = init_process_flags.load();
  ResetStdio();
  if (!(flags & ProcessInitializationFlags::kNoDefaultSignalHandling)) {
    ResetSignalHandlers();
  }

  per_process::v8_initialized = false;
  if (!(flags & ProcessInitializationFlags::kNoInitializeV8)) {
    V8::Dispose();
  }

#if NODE_USE_V8_WASM_TRAP_HANDLER && defined(_WIN32)
  if (!(flags & ProcessInitializationFlags::kNoDefaultSignalHandling)) {
    RemoveVectoredExceptionHandler(per_process::old_vectored_exception_handler);
  }
#endif

  if (!(flags & ProcessInitializationFlags::kNoInitializeNodeV8Platform)) {
    V8::DisposePlatform();
    // uv_run cannot be called from the time before the beforeExit callback
    // runs until the program exits unless the event loop has any referenced
    // handles after beforeExit terminates. This prevents unrefed timers
    // that happen to terminate during shutdown from being run unsafely.
    // Since uv_run cannot be called, uv_async handles held by the platfor...",31,,1080,1,,void
129026,BLOCK,-1,,"{
    ResetSignalHandlers();
  }",72,,1083,2,,void
129040,BLOCK,-1,,"{
    V8::Dispose();
  }",63,,1088,2,,void
129052,BLOCK,-1,,"{
    V8::DisposePlatform();
    // uv_run cannot be called from the time before the beforeExit callback
    // runs until the program exits unless the event loop has any referenced
    // handles after beforeExit terminates. This prevents unrefed timers
    // that happen to terminate during shutdown from being run unsafely.
    // Since uv_run cannot be called, uv_async handles held by the platform
    // will never be fully cleaned up.
    per_process::v8_platform.Dispose();
  }",75,,1098,2,,void
129066,BLOCK,-1,,<empty>,47,,1110,1,,void
129070,BLOCK,-1,,<empty>,55,,1111,1,,void
129076,BLOCK,-1,,"{
  ExitCode exit_code = result->exit_code_enum();
  // nullptr indicates there's no snapshot data.
  DCHECK_NULL(*snapshot_data_ptr);

  // node:embedded_snapshot_main indicates that we are using the
  // embedded snapshot and we are not supposed to clean it up.
  if (result->args()[1] == ""node:embedded_snapshot_main"") {
    *snapshot_data_ptr = SnapshotBuilder::GetEmbeddedSnapshotData();
    if (*snapshot_data_ptr == nullptr) {
      // The Node.js binary is built without embedded snapshot
      fprintf(stderr,
              ""node:embedded_snapshot_main was specified as snapshot ""
              ""entry point but Node.js was built without embedded ""
              ""snapshot.\n"");
      exit_code = ExitCode::kInvalidCommandLineArgument;
      return exit_code;
    }
  } else {
    // Otherwise, load and run the specified main script.
    std::unique_ptr<SnapshotData> generated_data =
        std::make_unique<SnapshotData>();
    exit_code = node::SnapshotBuilder::Generate(
        gen...",79,,1114,3,,void
129096,BLOCK,-1,,"{
    *snapshot_data_ptr = SnapshotBuilder::GetEmbeddedSnapshotData();
    if (*snapshot_data_ptr == nullptr) {
      // The Node.js binary is built without embedded snapshot
      fprintf(stderr,
              ""node:embedded_snapshot_main was specified as snapshot ""
              ""entry point but Node.js was built without embedded ""
              ""snapshot.\n"");
      exit_code = ExitCode::kInvalidCommandLineArgument;
      return exit_code;
    }
  }",59,,1121,2,,void
129109,BLOCK,-1,,"{
      // The Node.js binary is built without embedded snapshot
      fprintf(stderr,
              ""node:embedded_snapshot_main was specified as snapshot ""
              ""entry point but Node.js was built without embedded ""
              ""snapshot.\n"");
      exit_code = ExitCode::kInvalidCommandLineArgument;
      return exit_code;
    }",40,,1123,2,,void
129121,BLOCK,-1,,"{
    // Otherwise, load and run the specified main script.
    std::unique_ptr<SnapshotData> generated_data =
        std::make_unique<SnapshotData>();
    exit_code = node::SnapshotBuilder::Generate(
        generated_data.get(), result->args(), result->exec_args());
    if (exit_code == ExitCode::kNoFailure) {
      *snapshot_data_ptr = generated_data.release();
    } else {
      return exit_code;
    }
  }",10,,1132,1,,void
129155,BLOCK,-1,,"{
      *snapshot_data_ptr = generated_data.release();
    }",44,,1138,2,,void
129164,BLOCK,-1,,"{
      return exit_code;
    }",12,,1140,1,,void
129178,BLOCK,-1,,"{
    snapshot_blob_path = per_process::cli_options->snapshot_blob;
  }",57,,1147,2,,void
129187,BLOCK,-1,,"{
    // Defaults to snapshot.blob in the current working directory.
    snapshot_blob_path = std::string(""snapshot.blob"");
  }",10,,1149,1,,void
129208,BLOCK,-1,,"{
    (*snapshot_data_ptr)->ToFile(fp);
    fclose(fp);
  }",22,,1155,2,,void
129218,BLOCK,-1,,"{
    fprintf(stderr,
            ""Cannot open %s for writing a snapshot.\n"",
            snapshot_blob_path.c_str());
    exit_code = ExitCode::kStartupSnapshotFailure;
  }",10,,1158,1,,void
129238,BLOCK,-1,,"{
  ExitCode exit_code = result->exit_code_enum();
  // nullptr indicates there's no snapshot data.
  DCHECK_NULL(*snapshot_data_ptr);
  // --snapshot-blob indicates that we are reading a customized snapshot.
  if (!per_process::cli_options->snapshot_blob.empty()) {
    std::string filename = per_process::cli_options->snapshot_blob;
    FILE* fp = fopen(filename.c_str(), ""rb"");
    if (fp == nullptr) {
      fprintf(stderr, ""Cannot open %s"", filename.c_str());
      exit_code = ExitCode::kStartupSnapshotFailure;
      return exit_code;
    }
    std::unique_ptr<SnapshotData> read_data = std::make_unique<SnapshotData>();
    bool ok = SnapshotData::FromFile(read_data.get(), fp);
    fclose(fp);
    if (!ok) {
      // If we fail to read the customized snapshot,
      // simply exit with kStartupSnapshotFailure.
      exit_code = ExitCode::kStartupSnapshotFailure;
      return exit_code;
    }
    *snapshot_data_ptr = read_data.release();
  } else if (per_process::cli_options->node_sn...",73,,1168,3,,void
129259,BLOCK,-1,,"{
    std::string filename = per_process::cli_options->snapshot_blob;
    FILE* fp = fopen(filename.c_str(), ""rb"");
    if (fp == nullptr) {
      fprintf(stderr, ""Cannot open %s"", filename.c_str());
      exit_code = ExitCode::kStartupSnapshotFailure;
      return exit_code;
    }
    std::unique_ptr<SnapshotData> read_data = std::make_unique<SnapshotData>();
    bool ok = SnapshotData::FromFile(read_data.get(), fp);
    fclose(fp);
    if (!ok) {
      // If we fail to read the customized snapshot,
      // simply exit with kStartupSnapshotFailure.
      exit_code = ExitCode::kStartupSnapshotFailure;
      return exit_code;
    }
    *snapshot_data_ptr = read_data.release();
  }",57,,1173,2,,void
129281,BLOCK,-1,,"{
      fprintf(stderr, ""Cannot open %s"", filename.c_str());
      exit_code = ExitCode::kStartupSnapshotFailure;
      return exit_code;
    }",24,,1176,2,,void
129320,BLOCK,-1,,"{
      // If we fail to read the customized snapshot,
      // simply exit with kStartupSnapshotFailure.
      exit_code = ExitCode::kStartupSnapshotFailure;
      return exit_code;
    }",14,,1184,2,,void
129336,BLOCK,-1,,<empty>,10,,1191,1,,void
129343,BLOCK,-1,,"{
    // If --snapshot-blob is not specified, we are reading the embedded
    // snapshot, but we will skip it if --no-node-snapshot is specified.
    const node::SnapshotData* read_data =
        SnapshotBuilder::GetEmbeddedSnapshotData();
    if (read_data != nullptr && read_data->Check()) {
      // If we fail to read the embedded snapshot, treat it as if Node.js
      // was built without one.
      *snapshot_data_ptr = read_data;
    }
  }",55,,1191,2,,void
129360,BLOCK,-1,,"{
      // If we fail to read the embedded snapshot, treat it as if Node.js
      // was built without one.
      *snapshot_data_ptr = read_data;
    }",53,,1196,2,,void
129397,BLOCK,-1,,"{
  CHECK_GT(argc, 0);

  // Hack around with the argv pointer. Used for process.title = ""blah"".
  argv = uv_setup_args(argc, argv);

  std::unique_ptr<InitializationResultImpl> result =
      InitializeOncePerProcessInternal(
          std::vector<std::string>(argv, argv + argc));
  for (const std::string& error : result->errors()) {
    FPrintF(stderr, ""%s: %s\n"", result->args().at(0), error);
  }
  if (result->early_return()) {
    return result->exit_code_enum();
  }

  DCHECK_EQ(result->exit_code_enum(), ExitCode::kNoFailure);
  const SnapshotData* snapshot_data = nullptr;

  auto cleanup_process = OnScopeLeave([&]() {
    TearDownOncePerProcess();

    if (snapshot_data != nullptr &&
        snapshot_data->data_ownership == SnapshotData::DataOwnership::kOwned) {
      delete snapshot_data;
    }
  });

  uv_loop_configure(uv_default_loop(), UV_METRICS_IDLE_TIME);

  std::string sea_config = per_process::cli_options->experimental_sea_config;
  if (!sea_config.empty()) {
    ret...",54,,1212,3,,void
129430,BLOCK,-1,,"{
    FPrintF(stderr, ""%s: %s\n"", result->args().at(0), error);
  }",53,,1221,3,,void
129448,BLOCK,-1,,"{
    return result->exit_code_enum();
  }",31,,1224,2,,void
129487,BLOCK,-1,,"{
    return sea::BuildSingleExecutableBlob(sea_config);
  }",28,,1243,2,,void
129502,BLOCK,-1,,"{
    if (result->args().size() < 2) {
      fprintf(stderr,
              ""--build-snapshot must be used with an entry point script.\n""
              ""Usage: node --build-snapshot /path/to/entry.js\n"");
      return ExitCode::kInvalidCommandLineArgument;
    }
    return GenerateAndWriteSnapshotData(&snapshot_data, result.get());
  }",62,,1248,2,,void
129513,BLOCK,-1,,"{
      fprintf(stderr,
              ""--build-snapshot must be used with an entry point script.\n""
              ""Usage: node --build-snapshot /path/to/entry.js\n"");
      return ExitCode::kInvalidCommandLineArgument;
    }",36,,1249,2,,void
129542,BLOCK,-1,,"{
#ifndef DISABLE_SINGLE_EXECUTABLE_APPLICATION
  std::tie(argc, argv) = sea::FixupArgsForSEA(argc, argv);
#endif
  return static_cast<int>(StartInternal(argc, argv));
}",34,,1262,3,,void
129567,BLOCK,-1,,"{
  env->ExitEnv(flags);
  return 0;
}",52,,1269,3,,void
129578,BLOCK,-1,,<empty>,19,,1277,1,,void
129585,BLOCK,-1,,"{
        return CreateEnvironment(
            setup->isolate_data(), setup->context(),
            std::forward<EnvironmentArgs>(env_args)...);
      }",64,,904,2,,void
129610,BLOCK,-1,,"{
        return CreateEnvironment(setup->isolate_data(),
                                 setup->context(),
                                 std::forward<EnvironmentArgs>(env_args)...);
      }",64,,926,2,,void
129656,BLOCK,-1,,<empty>,1,,1,1,,ANY
129668,BLOCK,-1,,<empty>,,,,6,,<empty>
129678,BLOCK,-1,,<empty>,,,,7,,<empty>
129686,BLOCK,-1,,"NODE_DEPRECATED(""Use ErrnoException(isolate, ...)"",
                inline v8::Local<v8::Value> ErrnoException(
      int errorno,
      const char* syscall = nullptr,
      const char* message = nullptr,
      const char* path = nullptr) {
  return ErrnoException(v8::Isolate::GetCurrent(),
                        errorno,
                        syscall,
                        message,
                        path);
})",1,,151,5,,void
129706,BLOCK,-1,,"NODE_DEPRECATED(""Use UVException(isolate, ...)"",
                inline v8::Local<v8::Value> UVException(int errorno,
                                        const char* syscall = nullptr,
                                        const char* message = nullptr,
                                        const char* path = nullptr) {
  return UVException(v8::Isolate::GetCurrent(),
                     errorno,
                     syscall,
                     message,
                     path);
})",1,,164,5,,void
129727,BLOCK,-1,,<empty>,,,,6,,<empty>
129736,BLOCK,-1,,<empty>,,,,6,,<empty>
129762,BLOCK,-1,,<empty>,,,,1,,<empty>
129858,BLOCK,-1,,<empty>,,,,1,,<empty>
129871,BLOCK,-1,,<empty>,,,,1,,<empty>
129875,BLOCK,-1,,<empty>,,,,1,,<empty>
129879,BLOCK,-1,,<empty>,,,,1,,<empty>
129883,BLOCK,-1,,<empty>,,,,1,,<empty>
129887,BLOCK,-1,,<empty>,,,,1,,<empty>
129891,BLOCK,-1,,<empty>,,,,1,,<empty>
129895,BLOCK,-1,,<empty>,,,,1,,<empty>
129899,BLOCK,-1,,<empty>,,,,1,,<empty>
129906,BLOCK,-1,,<empty>,,,,3,,<empty>
129912,BLOCK,-1,,<empty>,,,,3,,<empty>
129920,BLOCK,-1,,<empty>,,,,5,,<empty>
129926,BLOCK,-1,,<empty>,,,,3,,<empty>
129930,BLOCK,-1,,<empty>,,,,1,,<empty>
129936,BLOCK,-1,,"{
  uint64_t flags_accum = ProcessInitializationFlags::kNoFlags;
  for (const auto flag : list) flags_accum |= static_cast<uint64_t>(flag);
  return InitializeOncePerProcess(
      args, static_cast<ProcessInitializationFlags::Flags>(flags_accum));
}",68,,356,3,,void
129965,BLOCK,-1,,<empty>,,,,1,,<empty>
129985,BLOCK,-1,,<empty>,,,,5,,<empty>
129992,BLOCK,-1,,<empty>,,,,2,,<empty>
129996,BLOCK,-1,,<empty>,,,,1,,<empty>
130001,BLOCK,-1,,<empty>,,,,1,,<empty>
130006,BLOCK,-1,,<empty>,,,,2,,<empty>
130011,BLOCK,-1,,<empty>,,,,1,,<empty>
130015,BLOCK,-1,,<empty>,,,,1,,<empty>
130020,BLOCK,-1,,<empty>,,,,1,,<empty>
130025,BLOCK,-1,,<empty>,,,,2,,<empty>
130030,BLOCK,-1,,<empty>,,,,2,,<empty>
130036,BLOCK,-1,,<empty>,,,,3,,<empty>
130042,BLOCK,-1,,<empty>,,,,3,,<empty>
130047,BLOCK,-1,,<empty>,,,,2,,<empty>
130054,BLOCK,-1,,<empty>,,,,4,,<empty>
130061,BLOCK,-1,,<empty>,,,,4,,<empty>
130071,BLOCK,-1,,<empty>,,,,1,,<empty>
130107,BLOCK,-1,,<empty>,,,,1,,<empty>
130144,BLOCK,-1,,<empty>,,,,2,,<empty>
130149,BLOCK,-1,,<empty>,,,,1,,<empty>
130154,BLOCK,-1,,<empty>,,,,2,,<empty>
130159,BLOCK,-1,,<empty>,,,,2,,<empty>
130164,BLOCK,-1,,<empty>,,,,2,,<empty>
130168,BLOCK,-1,,<empty>,,,,1,,<empty>
130172,BLOCK,-1,,<empty>,,,,1,,<empty>
130177,BLOCK,-1,,<empty>,,,,2,,<empty>
130182,BLOCK,-1,,<empty>,,,,2,,<empty>
130187,BLOCK,-1,,<empty>,,,,2,,<empty>
130192,BLOCK,-1,,<empty>,,,,2,,<empty>
130198,BLOCK,-1,,<empty>,,,,3,,<empty>
130208,BLOCK,-1,,<empty>,,,,3,,<empty>
130213,BLOCK,-1,,<empty>,,,,2,,<empty>
130222,BLOCK,-1,,<empty>,,,,6,,<empty>
130231,BLOCK,-1,,<empty>,,,,6,,<empty>
130237,BLOCK,-1,,<empty>,,,,3,,<empty>
130242,BLOCK,-1,,<empty>,,,,2,,<empty>
130251,BLOCK,-1,,<empty>,,,,6,,<empty>
130256,BLOCK,-1,,<empty>,,,,2,,<empty>
130262,BLOCK,-1,,<empty>,,,,1,,<empty>
130272,BLOCK,-1,,<empty>,,,,1,,<empty>
130289,BLOCK,-1,,<empty>,,,,1,,<empty>
130347,BLOCK,-1,,<empty>,,,,1,,<empty>
130358,BLOCK,-1,,<empty>,,,,8,,<empty>
130365,BLOCK,-1,,<empty>,,,,4,,<empty>
130373,BLOCK,-1,,<empty>,,,,5,,<empty>
130384,BLOCK,-1,,<empty>,,,,3,,<empty>
130390,BLOCK,-1,,<empty>,,,,3,,<empty>
130395,BLOCK,-1,,<empty>,,,,2,,<empty>
130401,BLOCK,-1,,<empty>,,,,3,,<empty>
130407,BLOCK,-1,,<empty>,,,,3,,<empty>
130412,BLOCK,-1,,<empty>,,,,2,,<empty>
130417,BLOCK,-1,,<empty>,,,,2,,<empty>
130422,BLOCK,-1,,<empty>,,,,2,,<empty>
130427,BLOCK,-1,,<empty>,,,,2,,<empty>
130433,BLOCK,-1,,<empty>,,,,3,,<empty>
130438,BLOCK,-1,,<empty>,,,,2,,<empty>
130444,BLOCK,-1,,<empty>,,,,3,,<empty>
130449,BLOCK,-1,,<empty>,,,,2,,<empty>
130456,BLOCK,-1,,<empty>,,,,4,,<empty>
130465,BLOCK,-1,,<empty>,,,,6,,<empty>
130474,BLOCK,-1,,<empty>,,,,6,,<empty>
130483,BLOCK,-1,,<empty>,,,,6,,<empty>
130492,BLOCK,-1,,<empty>,,,,6,,<empty>
130497,BLOCK,-1,,<empty>,,,,2,,<empty>
130502,BLOCK,-1,,<empty>,,,,2,,<empty>
130508,BLOCK,-1,,<empty>,,,,3,,<empty>
130513,BLOCK,-1,,<empty>,,,,2,,<empty>
130517,BLOCK,-1,,<empty>,,,,1,,<empty>
130522,BLOCK,-1,,<empty>,,,,2,,<empty>
130527,BLOCK,-1,,<empty>,,,,2,,<empty>
130532,BLOCK,-1,,<empty>,,,,2,,<empty>
130537,BLOCK,-1,,<empty>,,,,2,,<empty>
130542,BLOCK,-1,,<empty>,,,,2,,<empty>
130547,BLOCK,-1,,<empty>,,,,2,,<empty>
130554,BLOCK,-1,,<empty>,,,,2,,<empty>
130559,BLOCK,-1,,<empty>,,,,1,,<empty>
130566,BLOCK,-1,,<empty>,,,,4,,<empty>
130574,BLOCK,-1,,<empty>,,,,5,,<empty>
130582,BLOCK,-1,,<empty>,,,,5,,<empty>
130586,BLOCK,-1,,<empty>,,,,1,,<empty>
130592,BLOCK,-1,,<empty>,,,,1,,<empty>
130596,BLOCK,-1,,<empty>,,,,1,,<empty>
130600,BLOCK,-1,,<empty>,,,,1,,<empty>
130604,BLOCK,-1,,<empty>,,,,1,,<empty>
130608,BLOCK,-1,,<empty>,,,,1,,<empty>
130612,BLOCK,-1,,<empty>,,,,1,,<empty>
130617,BLOCK,-1,,<empty>,,,,2,,<empty>
130622,BLOCK,-1,,<empty>,,,,2,,<empty>
130627,BLOCK,-1,,<empty>,,,,2,,<empty>
130632,BLOCK,-1,,<empty>,,,,2,,<empty>
130639,BLOCK,-1,,<empty>,,,,1,,<empty>
130654,BLOCK,-1,,<empty>,,,,4,,<empty>
130663,BLOCK,-1,,<empty>,,,,6,,<empty>
130669,BLOCK,-1,,"{
  auto ret = std::unique_ptr<CommonEnvironmentSetup>(new CommonEnvironmentSetup(
      platform, errors,
      [&](const CommonEnvironmentSetup* setup) -> Environment* {
        return CreateEnvironment(
            setup->isolate_data(), setup->context(),
            std::forward<EnvironmentArgs>(env_args)...);
      }));
  if (!errors->empty()) ret.reset();
  return ret;
}",36,,901,4,,void
130690,BLOCK,-1,,<empty>,25,,909,2,,void
130703,BLOCK,-1,,"{
  auto ret = std::unique_ptr<CommonEnvironmentSetup>(new CommonEnvironmentSetup(
      platform,
      errors,
      snapshot_data,
      Flags::kNoFlags,
      [&](const CommonEnvironmentSetup* setup) -> Environment* {
        return CreateEnvironment(setup->isolate_data(),
                                 setup->context(),
                                 std::forward<EnvironmentArgs>(env_args)...);
      }));
  if (!errors->empty()) ret.reset();
  return ret;
}",36,,920,5,,void
130728,BLOCK,-1,,<empty>,25,,931,2,,void
130739,BLOCK,-1,,"NODE_DEPRECATED(""Use v8::Date::New() directly"",
                inline v8::Local<v8::Value> NODE_UNIXTIME_V8(double time) {
                  return v8::Date::New(
                             v8::Isolate::GetCurrent()->GetCurrentContext(),
                             1000 * time)
                      .ToLocalChecked();
                })",1,,936,2,,void
130766,BLOCK,-1,,"NODE_DEPRECATED(""Use v8::Date::ValueOf() directly"",
                inline double NODE_V8_UNIXTIME(v8::Local<v8::Date> date) {
  return date->ValueOf() / 1000;
})",1,,944,2,,void
130780,BLOCK,-1,,"{
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate,
                                                                callback);
  v8::Local<v8::String> fn_name = v8::String::NewFromUtf8(isolate, name,
      v8::NewStringType::kInternalized).ToLocalChecked();
  t->SetClassName(fn_name);
  recv->Set(fn_name, t);
}",60,,992,4,,void
130854,BLOCK,-1,,"{
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> context = isolate->GetCurrentContext();
  v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate,
                                                                callback);
  v8::Local<v8::Function> fn = t->GetFunction(context).ToLocalChecked();
  v8::Local<v8::String> fn_name = v8::String::NewFromUtf8(isolate, name,
      v8::NewStringType::kInternalized).ToLocalChecked();
  fn->SetName(fn_name);
  recv->Set(context, fn_name, fn).Check();
}",60,,1006,4,,void
130964,BLOCK,-1,,"{
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Signature> s = v8::Signature::New(isolate, recv);
  v8::Local<v8::FunctionTemplate> t =
      v8::FunctionTemplate::New(isolate, callback, v8::Local<v8::Value>(), s);
  v8::Local<v8::String> fn_name = v8::String::NewFromUtf8(isolate, name,
      v8::NewStringType::kInternalized).ToLocalChecked();
  t->SetClassName(fn_name);
  recv->PrototypeTemplate()->Set(fn_name, t);
}",70,,1024,4,,void
131071,BLOCK,-1,,<empty>,,,,1,,<empty>
131082,BLOCK,-1,,<empty>,,,,3,,<empty>
131090,BLOCK,-1,,<empty>,,,,5,,<empty>
131097,BLOCK,-1,,<empty>,,,,4,,<empty>
131104,BLOCK,-1,,<empty>,,,,4,,<empty>
131113,BLOCK,-1,,<empty>,,,,6,,<empty>
131118,BLOCK,-1,,<empty>,,,,2,,<empty>
131125,BLOCK,-1,,<empty>,,,,4,,<empty>
131133,BLOCK,-1,,<empty>,,,,5,,<empty>
131139,BLOCK,-1,,<empty>,,,,1,,<empty>
131158,BLOCK,-1,,<empty>,,,,2,,<empty>
131164,BLOCK,-1,,<empty>,,,,3,,<empty>
131170,BLOCK,-1,,<empty>,,,,3,,<empty>
131178,BLOCK,-1,,<empty>,,,,5,,<empty>
131186,BLOCK,-1,,<empty>,,,,5,,<empty>
131193,BLOCK,-1,,<empty>,,,,4,,<empty>
131204,BLOCK,-1,,<empty>,,,,4,,<empty>
131211,BLOCK,-1,,<empty>,,,,4,,<empty>
131218,BLOCK,-1,,<empty>,,,,2,,<empty>
131226,BLOCK,-1,,<empty>,,,,4,,<empty>
131233,BLOCK,-1,,"{
  return AsyncCleanupHookHandle(AddEnvironmentCleanupHookInternal(isolate, fun,
      arg));
}",16,,1292,4,,void
131244,BLOCK,-1,,<empty>,,,,2,,<empty>
131249,BLOCK,-1,,"{
  RemoveEnvironmentCleanupHookInternal(holder.get());
}",73,,1300,2,,void
131261,BLOCK,-1,,<empty>,,,,4,,<empty>
131266,BLOCK,-1,,<empty>,,,,2,,<empty>
131271,BLOCK,-1,,<empty>,,,,2,,<empty>
131279,BLOCK,-1,,<empty>,,,,5,,<empty>
131287,BLOCK,-1,,<empty>,,,,5,,<empty>
131293,BLOCK,-1,,<empty>,,,,3,,<empty>
131299,BLOCK,-1,,<empty>,,,,3,,<empty>
131308,BLOCK,-1,,<empty>,,,,4,,<empty>
131315,BLOCK,-1,,<empty>,,,,4,,<empty>
131319,BLOCK,-1,,<empty>,,,,1,,<empty>
131324,BLOCK,-1,,<empty>,,,,2,,<empty>
131329,BLOCK,-1,,<empty>,,,,2,,<empty>
131334,BLOCK,-1,,<empty>,,,,2,,<empty>
131339,BLOCK,-1,,<empty>,,,,2,,<empty>
131351,BLOCK,-1,,<empty>,,,,7,,<empty>
131361,BLOCK,-1,,<empty>,,,,7,,<empty>
131370,BLOCK,-1,,<empty>,,,,5,,<empty>
131374,BLOCK,-1,,<empty>,,,,1,,<empty>
131379,BLOCK,-1,,<empty>,,,,2,,<empty>
131384,BLOCK,-1,,<empty>,,,,2,,<empty>
131391,BLOCK,-1,,<empty>,,,,4,,<empty>
131398,BLOCK,-1,,<empty>,,,,4,,<empty>
131402,BLOCK,-1,,<empty>,,,,1,,<empty>
131406,BLOCK,-1,,<empty>,,,,1,,<empty>
131410,BLOCK,-1,,<empty>,,,,1,,<empty>
131416,BLOCK,-1,,<empty>,,,,2,,<empty>
131426,BLOCK,-1,,<empty>,,,,4,,<empty>
131432,BLOCK,-1,,"{ cb(env, data, hint); }",25,,48,2,,void
131445,BLOCK,-1,,"{
      finalization_scheduled = false;
      Unref();
      DrainFinalizerQueue();
    }",66,,60,2,,void
131457,BLOCK,-1,,"{
    node_napi_env__* env = static_cast<node_napi_env__*>(env_);
    if (env->terminatedOrTerminating()) {
      return;
    }
    node::Environment* node_env = env->node_env();
    if (!node_env->options()->force_node_api_uncaught_exceptions_policy &&
        !enforceUncaughtExceptionPolicy) {
      ProcessEmitDeprecationWarning(
          node_env,
          ""Uncaught N-API callback exception detected, please run node ""
          ""with option --force-node-api-uncaught-exceptions-policy=true""
          ""to handle those exceptions properly."",
          ""DEP0168"");
      return;
    }
    // If there was an unhandled exception in the complete callback,
    // report it as a fatal exception. (There is no JavaScript on the
    // callstack that can possibly handle it.)
    env->trigger_fatal_exception(local_err);
  }",74,,90,3,,void
131469,BLOCK,-1,,"{
      return;
    }",41,,92,2,,void
131489,BLOCK,-1,,"{
      ProcessEmitDeprecationWarning(
          node_env,
          ""Uncaught N-API callback exception detected, please run node ""
          ""with option --force-node-api-uncaught-exceptions-policy=true""
          ""to handle those exceptions properly."",
          ""DEP0168"");
      return;
    }",42,,97,2,,void
131505,BLOCK,-1,,{ static_cast<napi_env>(arg)->Unref(); },21,,193,2,,void
131517,BLOCK,-1,,"{
            ThreadSafeFunction* ts_fn =
                node::ContainerOf(&ThreadSafeFunction::async,
                                  reinterpret_cast<uv_async_t*>(handle));
            delete ts_fn;
          }",43,,318,2,,void
131540,BLOCK,-1,,"{ call_js_cb(env, js_callback, context, data); }",29,,416,2,,void
131553,BLOCK,-1,,"{
          ThreadSafeFunction* ts_fn =
              node::ContainerOf(&ThreadSafeFunction::async,
                                reinterpret_cast<uv_async_t*>(handle));
          ts_fn->Finalize();
        }",41,,446,2,,void
131577,BLOCK,-1,,"{
    _exports = init(env, v8impl::JsValueFromV8LocalValue(exports));
  }",41,,724,2,,void
131595,BLOCK,-1,,{ env->Unref(); },42,,799,2,,void
131606,BLOCK,-1,,"{
      _complete(env, ConvertUVErrorCode(status), _data);
    }",54,,1193,2,,void
131655,BLOCK,-1,,<empty>,1,,1,1,,ANY
131660,BLOCK,-1,,"{
  CHECK_NOT_NULL(node_env());
}",74,,25,4,,void
131666,BLOCK,-1,,"{
  destructing = true;
  DrainFinalizerQueue();
  napi_env__::DeleteMe();
}",34,,29,1,,void
131678,BLOCK,-1,,"{
  return node_env()->can_call_into_js();
}",48,,35,1,,void
131690,BLOCK,-1,,"{
  CallFinalizer<true>(cb, data, hint);
}",79,,39,4,,void
131699,BLOCK,-1,,"{
  v8::HandleScope handle_scope(isolate);
  v8::Context::Scope context_scope(context());
  CallbackIntoModule<enforceUncaughtExceptionPolicy>(
      [&](napi_env env) { cb(env, data, hint); });
}",79,,44,4,,void
131712,BLOCK,-1,,"{
  napi_env__::EnqueueFinalizer(finalizer);
  // Schedule a second pass only when it has not been scheduled, and not
  // destructing the env.
  // When the env is being destructed, queued finalizers are drained in the
  // loop of `node_napi_env__::DrainFinalizerQueue`.
  if (!finalization_scheduled && !destructing) {
    finalization_scheduled = true;
    Ref();
    node_env()->SetImmediate([this](node::Environment* node_env) {
      finalization_scheduled = false;
      Unref();
      DrainFinalizerQueue();
    });
  }
}",71,,51,2,,void
131724,BLOCK,-1,,"{
    finalization_scheduled = true;
    Ref();
    node_env()->SetImmediate([this](node::Environment* node_env) {
      finalization_scheduled = false;
      Unref();
      DrainFinalizerQueue();
    });
  }",48,,57,2,,void
131737,BLOCK,-1,,"{
  // As userland code can delete additional references in one finalizer,
  // the list of pending finalizers may be mutated as we execute them, so
  // we keep iterating it until it is empty.
  while (!pending_finalizers.empty()) {
    v8impl::RefTracker* ref_tracker = *pending_finalizers.begin();
    pending_finalizers.erase(ref_tracker);
    ref_tracker->Finalize();
  }
}",45,,68,1,,void
131744,BLOCK,-1,,"{
    v8impl::RefTracker* ref_tracker = *pending_finalizers.begin();
    pending_finalizers.erase(ref_tracker);
    ref_tracker->Finalize();
  }",39,,72,2,,void
131766,BLOCK,-1,,"{
  v8::Local<v8::Message> local_msg =
      v8::Exception::CreateMessage(isolate, local_err);
  node::errors::TriggerUncaughtException(isolate, local_err, local_msg);
}",79,,79,2,,void
131798,BLOCK,-1,,"{
  CallIntoModule(call, [](napi_env env_, v8::Local<v8::Value> local_err) {
    node_napi_env__* env = static_cast<node_napi_env__*>(env_);
    if (env->terminatedOrTerminating()) {
      return;
    }
    node::Environment* node_env = env->node_env();
    if (!node_env->options()->force_node_api_uncaught_exceptions_policy &&
        !enforceUncaughtExceptionPolicy) {
      ProcessEmitDeprecationWarning(
          node_env,
          ""Uncaught N-API callback exception detected, please run node ""
          ""with option --force-node-api-uncaught-exceptions-policy=true""
          ""to handle those exceptions properly."",
          ""DEP0168"");
      return;
    }
    // If there was an unhandled exception in the complete callback,
    // report it as a fatal exception. (There is no JavaScript on the
    // callstack that can possibly handle it.)
    env->trigger_fatal_exception(local_err);
  });
}",52,,89,2,,void
131812,BLOCK,-1,,"{
    return new BufferFinalizer(
        env, finalize_callback, finalize_data, finalize_hint);
  }",62,,122,5,,void
131825,BLOCK,-1,,"{
    std::unique_ptr<BufferFinalizer, Deleter> finalizer{
        static_cast<BufferFinalizer*>(hint)};
    finalizer->finalize_data_ = data;

    // It is safe to call into JavaScript at this point.
    if (finalizer->finalize_callback_ == nullptr) return;
    finalizer->env_->CallFinalizer(finalizer->finalize_callback_,
                                   finalizer->finalize_data_,
                                   finalizer->finalize_hint_);
  }",62,,127,3,,void
131844,BLOCK,-1,,<empty>,51,,133,2,,void
131866,BLOCK,-1,,{ delete finalizer; },49,,140,2,,void
131876,BLOCK,-1,,"{
    env_->Ref();
  }",73,,148,5,,void
131884,BLOCK,-1,,{ env_->Unref(); },22,,152,1,,void
131895,BLOCK,-1,,"{
  std::string error_message;
  error_message += module_name;
  error_message += "" requires Node-API version "";
  error_message += std::to_string(module_api_version);
  error_message += "", but this version of Node.js only supports version "";
  error_message += NODE_STRINGIFY(NAPI_VERSION) "" add-ons."";
  node_env->ThrowError(error_message.c_str());
}",59,,157,4,,void
131916,BLOCK,1,,<empty>,,,,1,,void
131932,BLOCK,-1,,"{
  node_napi_env result;

  // Validate module_api_version.
  if (module_api_version < NODE_API_DEFAULT_MODULE_API_VERSION) {
    module_api_version = NODE_API_DEFAULT_MODULE_API_VERSION;
  } else if (module_api_version > NAPI_VERSION &&
             module_api_version != NAPI_VERSION_EXPERIMENTAL) {
    node::Environment* node_env = node::Environment::GetCurrent(context);
    CHECK_NOT_NULL(node_env);
    ThrowNodeApiVersionError(
        node_env, module_filename.c_str(), module_api_version);
    return nullptr;
  }

  result = new node_napi_env__(context, module_filename, module_api_version);
  // TODO(addaleax): There was previously code that tried to delete the
  // napi_env when its v8::Context was garbage collected;
  // However, as long as N-API addons using this napi_env are in place,
  // the Context needs to be accessible and alive.
  // Ideally, we'd want an on-addon-unload hook that takes care of this
  // once all N-API addons using this napi_env are unloaded.
  // Fo...",52,,169,4,,void
131938,BLOCK,1,,<empty>,,,,1,,void
131940,BLOCK,-1,,"{
    module_api_version = NODE_API_DEFAULT_MODULE_API_VERSION;
  }",65,,173,2,,void
131944,BLOCK,1,,<empty>,,,,1,,void
131947,BLOCK,-1,,<empty>,10,,175,1,,void
131953,BLOCK,1,,<empty>,,,,1,,void
131958,BLOCK,1,,<empty>,,,,1,,void
131960,BLOCK,-1,,"{
    node::Environment* node_env = node::Environment::GetCurrent(context);
    CHECK_NOT_NULL(node_env);
    ThrowNodeApiVersionError(
        node_env, module_filename.c_str(), module_api_version);
    return nullptr;
  }",63,,176,2,,void
132015,BLOCK,-1,,"{
    ref.Reset(env->isolate, func);
    node::AddEnvironmentCleanupHook(env->isolate, Cleanup, this);
    env->Ref();
  }",32,,223,11,,void
132040,BLOCK,-1,,"{
    node::RemoveEnvironmentCleanupHook(env->isolate, Cleanup, this);
    env->Unref();
  }",34,,229,1,,void
132059,BLOCK,-1,,"{
    node::Mutex::ScopedLock lock(this->mutex);

    while (queue.size() >= max_queue_size && max_queue_size > 0 &&
           !is_closing) {
      if (mode == napi_tsfn_nonblocking) {
        return napi_queue_full;
      }
      cond->Wait(lock);
    }

    if (is_closing) {
      if (thread_count == 0) {
        return napi_invalid_arg;
      } else {
        thread_count--;
        return napi_closing;
      }
    } else {
      queue.push(data);
      Send();
      return napi_ok;
    }
  }",73,,236,3,,void
132079,BLOCK,-1,,"{
      if (mode == napi_tsfn_nonblocking) {
        return napi_queue_full;
      }
      cond->Wait(lock);
    }",25,,240,2,,void
132084,BLOCK,-1,,"{
        return napi_queue_full;
      }",42,,241,2,,void
132094,BLOCK,-1,,"{
      if (thread_count == 0) {
        return napi_invalid_arg;
      } else {
        thread_count--;
        return napi_closing;
      }
    }",21,,247,2,,void
132099,BLOCK,-1,,"{
        return napi_invalid_arg;
      }",30,,248,2,,void
132103,BLOCK,-1,,"{
        thread_count--;
        return napi_closing;
      }",14,,250,1,,void
132109,BLOCK,-1,,"{
      queue.push(data);
      Send();
      return napi_ok;
    }",12,,254,1,,void
132121,BLOCK,-1,,"{
    node::Mutex::ScopedLock lock(this->mutex);

    if (is_closing) {
      return napi_closing;
    }

    thread_count++;

    return napi_ok;
  }",25,,261,1,,void
132129,BLOCK,-1,,"{
      return napi_closing;
    }",21,,264,2,,void
132140,BLOCK,-1,,"{
    node::Mutex::ScopedLock lock(this->mutex);

    if (thread_count == 0) {
      return napi_invalid_arg;
    }

    thread_count--;

    if (thread_count == 0 || mode == napi_tsfn_abort) {
      if (!is_closing) {
        is_closing = (mode == napi_tsfn_abort);
        if (is_closing && max_queue_size > 0) {
          cond->Signal(lock);
        }
        Send();
      }
    }

    return napi_ok;
  }",67,,273,2,,void
132150,BLOCK,-1,,"{
      return napi_invalid_arg;
    }",28,,276,2,,void
132163,BLOCK,-1,,"{
      if (!is_closing) {
        is_closing = (mode == napi_tsfn_abort);
        if (is_closing && max_queue_size > 0) {
          cond->Signal(lock);
        }
        Send();
      }
    }",55,,282,2,,void
132167,BLOCK,-1,,"{
        is_closing = (mode == napi_tsfn_abort);
        if (is_closing && max_queue_size > 0) {
          cond->Signal(lock);
        }
        Send();
      }",24,,283,2,,void
132179,BLOCK,-1,,"{
          cond->Signal(lock);
        }",47,,285,2,,void
132191,BLOCK,-1,,"{
    for (; !queue.empty(); queue.pop()) {
      call_js_cb(nullptr, nullptr, context, queue.front());
    }
    delete this;
  }",30,,295,1,,void
132193,BLOCK,-1,,<empty>,5,,296,1,,void
132203,BLOCK,4,,"{
      call_js_cb(nullptr, nullptr, context, queue.front());
    }",41,,296,4,,void
132217,BLOCK,-1,,"{
    ThreadSafeFunction* ts_fn = this;
    uv_loop_t* loop = env->node_env()->event_loop();

    if (uv_async_init(loop, &async, AsyncCb) == 0) {
      if (max_queue_size > 0) {
        cond = std::make_unique<node::ConditionVariable>();
      }
      if (max_queue_size == 0 || cond) {
        return napi_ok;
      }

      env->node_env()->CloseHandle(
          reinterpret_cast<uv_handle_t*>(&async),
          [](uv_handle_t* handle) -> void {
            ThreadSafeFunction* ts_fn =
                node::ContainerOf(&ThreadSafeFunction::async,
                                  reinterpret_cast<uv_async_t*>(handle));
            delete ts_fn;
          });

      // Prevent the thread-safe function from being deleted here, because
      // the callback above will delete it.
      ts_fn = nullptr;
    }

    delete ts_fn;

    return napi_generic_failure;
  }",22,,304,1,,void
132240,BLOCK,-1,,"{
      if (max_queue_size > 0) {
        cond = std::make_unique<node::ConditionVariable>();
      }
      if (max_queue_size == 0 || cond) {
        return napi_ok;
      }

      env->node_env()->CloseHandle(
          reinterpret_cast<uv_handle_t*>(&async),
          [](uv_handle_t* handle) -> void {
            ThreadSafeFunction* ts_fn =
                node::ContainerOf(&ThreadSafeFunction::async,
                                  reinterpret_cast<uv_async_t*>(handle));
            delete ts_fn;
          });

      // Prevent the thread-safe function from being deleted here, because
      // the callback above will delete it.
      ts_fn = nullptr;
    }",52,,308,2,,void
132245,BLOCK,-1,,"{
        cond = std::make_unique<node::ConditionVariable>();
      }",31,,309,2,,void
132258,BLOCK,-1,,"{
        return napi_ok;
      }",40,,312,2,,void
132283,BLOCK,-1,,"{
    uv_unref(reinterpret_cast<uv_handle_t*>(&async));

    return napi_ok;
  }",23,,335,1,,void
132294,BLOCK,-1,,"{
    uv_ref(reinterpret_cast<uv_handle_t*>(&async));

    return napi_ok;
  }",21,,341,1,,void
132305,BLOCK,-1,,{ return context; },26,,347,1,,void
132311,BLOCK,-1,,"{
    bool has_more = true;

    // Limit maximum synchronous iteration count to prevent event loop
    // starvation. See `src/node_messaging.cc` for an inspiration.
    unsigned int iterations_left = kMaxIterationCount;
    while (has_more && --iterations_left != 0) {
      dispatch_state = kDispatchRunning;
      has_more = DispatchOne();

      // Send() was called while we were executing the JS function
      if (dispatch_state.exchange(kDispatchIdle) != kDispatchRunning) {
        has_more = true;
      }
    }

    if (has_more) {
      Send();
    }
  }",19,,350,1,,void
132327,BLOCK,-1,,"{
      dispatch_state = kDispatchRunning;
      has_more = DispatchOne();

      // Send() was called while we were executing the JS function
      if (dispatch_state.exchange(kDispatchIdle) != kDispatchRunning) {
        has_more = true;
      }
    }",48,,356,2,,void
132342,BLOCK,-1,,"{
        has_more = true;
      }",71,,361,2,,void
132348,BLOCK,-1,,"{
      Send();
    }",19,,366,2,,void
132353,BLOCK,-1,,"{
    void* data = nullptr;
    bool popped_value = false;
    bool has_more = false;

    {
      node::Mutex::ScopedLock lock(this->mutex);
      if (is_closing) {
        CloseHandlesAndMaybeDelete();
      } else {
        size_t size = queue.size();
        if (size > 0) {
          data = queue.front();
          queue.pop();
          popped_value = true;
          if (size == max_queue_size && max_queue_size > 0) {
            cond->Signal(lock);
          }
          size--;
        }

        if (size == 0) {
          if (thread_count == 0) {
            is_closing = true;
            if (max_queue_size > 0) {
              cond->Signal(lock);
            }
            CloseHandlesAndMaybeDelete();
          }
        } else {
          has_more = true;
        }
      }
    }

    if (popped_value) {
      v8::HandleScope scope(env->isolate);
      CallbackScope cb_scope(this);
      napi_value js_callback = nullptr;
      if (!ref.IsEmpty()) {
        v8::Local<v8::Func...",22,,371,1,,void
132365,BLOCK,7,,"{
      node::Mutex::ScopedLock lock(this->mutex);
      if (is_closing) {
        CloseHandlesAndMaybeDelete();
      } else {
        size_t size = queue.size();
        if (size > 0) {
          data = queue.front();
          queue.pop();
          popped_value = true;
          if (size == max_queue_size && max_queue_size > 0) {
            cond->Signal(lock);
          }
          size--;
        }

        if (size == 0) {
          if (thread_count == 0) {
            is_closing = true;
            if (max_queue_size > 0) {
              cond->Signal(lock);
            }
            CloseHandlesAndMaybeDelete();
          }
        } else {
          has_more = true;
        }
      }
    }",5,,376,7,,void
132373,BLOCK,-1,,"{
        CloseHandlesAndMaybeDelete();
      }",23,,378,2,,void
132376,BLOCK,-1,,"{
        size_t size = queue.size();
        if (size > 0) {
          data = queue.front();
          queue.pop();
          popped_value = true;
          if (size == max_queue_size && max_queue_size > 0) {
            cond->Signal(lock);
          }
          size--;
        }

        if (size == 0) {
          if (thread_count == 0) {
            is_closing = true;
            if (max_queue_size > 0) {
              cond->Signal(lock);
            }
            CloseHandlesAndMaybeDelete();
          }
        } else {
          has_more = true;
        }
      }",14,,380,1,,void
132388,BLOCK,-1,,"{
          data = queue.front();
          queue.pop();
          popped_value = true;
          if (size == max_queue_size && max_queue_size > 0) {
            cond->Signal(lock);
          }
          size--;
        }",23,,382,2,,void
132410,BLOCK,-1,,"{
            cond->Signal(lock);
          }",61,,386,2,,void
132422,BLOCK,-1,,"{
          if (thread_count == 0) {
            is_closing = true;
            if (max_queue_size > 0) {
              cond->Signal(lock);
            }
            CloseHandlesAndMaybeDelete();
          }
        }",24,,392,2,,void
132427,BLOCK,-1,,"{
            is_closing = true;
            if (max_queue_size > 0) {
              cond->Signal(lock);
            }
            CloseHandlesAndMaybeDelete();
          }",34,,393,2,,void
132435,BLOCK,-1,,"{
              cond->Signal(lock);
            }",37,,395,2,,void
132443,BLOCK,-1,,"{
          has_more = true;
        }",16,,400,1,,void
132449,BLOCK,-1,,"{
      v8::HandleScope scope(env->isolate);
      CallbackScope cb_scope(this);
      napi_value js_callback = nullptr;
      if (!ref.IsEmpty()) {
        v8::Local<v8::Function> js_cb =
            v8::Local<v8::Function>::New(env->isolate, ref);
        js_callback = v8impl::JsValueFromV8LocalValue(js_cb);
      }
      env->CallbackIntoModule<false>(
          [&](napi_env env) { call_js_cb(env, js_callback, context, data); });
    }",23,,406,2,,void
132467,BLOCK,-1,,"{
        v8::Local<v8::Function> js_cb =
            v8::Local<v8::Function>::New(env->isolate, ref);
        js_callback = v8impl::JsValueFromV8LocalValue(js_cb);
      }",27,,410,2,,void
132511,BLOCK,-1,,"{
    v8::HandleScope scope(env->isolate);
    if (finalize_cb) {
      CallbackScope cb_scope(this);
      env->CallFinalizer<false>(finalize_cb, finalize_data, context);
    }
    EmptyQueueAndDelete();
  }",19,,422,1,,void
132519,BLOCK,-1,,"{
      CallbackScope cb_scope(this);
      env->CallFinalizer<false>(finalize_cb, finalize_data, context);
    }",22,,424,2,,void
132535,BLOCK,-1,,"{
    v8::HandleScope scope(env->isolate);
    if (set_closing) {
      node::Mutex::ScopedLock lock(this->mutex);
      is_closing = true;
      if (max_queue_size > 0) {
        cond->Signal(lock);
      }
    }
    if (handles_closing) {
      return;
    }
    handles_closing = true;
    env->node_env()->CloseHandle(
        reinterpret_cast<uv_handle_t*>(&async),
        [](uv_handle_t* handle) -> void {
          ThreadSafeFunction* ts_fn =
              node::ContainerOf(&ThreadSafeFunction::async,
                                reinterpret_cast<uv_async_t*>(handle));
          ts_fn->Finalize();
        });
  }",61,,431,2,,void
132543,BLOCK,-1,,"{
      node::Mutex::ScopedLock lock(this->mutex);
      is_closing = true;
      if (max_queue_size > 0) {
        cond->Signal(lock);
      }
    }",22,,433,2,,void
132556,BLOCK,-1,,"{
        cond->Signal(lock);
      }",31,,436,2,,void
132564,BLOCK,-1,,"{
      return;
    }",26,,440,2,,void
132584,BLOCK,-1,,"{
    // Ask currently running Dispatch() to make one more iteration
    unsigned char current_state = dispatch_state.fetch_or(kDispatchPending);
    if ((current_state & kDispatchRunning) == kDispatchRunning) {
      return;
    }

    CHECK_EQ(0, uv_async_send(&async));
  }",15,,454,1,,void
132599,BLOCK,-1,,"{
      return;
    }",65,,457,2,,void
132613,BLOCK,-1,,"{
    if (!(env == nullptr || cb == nullptr)) {
      napi_value recv;
      napi_status status;

      status = napi_get_undefined(env, &recv);
      if (status != napi_ok) {
        napi_throw_error(env,
                         ""ERR_NAPI_TSFN_GET_UNDEFINED"",
                         ""Failed to retrieve undefined value"");
        return;
      }

      status = napi_call_function(env, recv, cb, 0, nullptr, nullptr);
      if (status != napi_ok && status != napi_pending_exception) {
        napi_throw_error(
            env, ""ERR_NAPI_TSFN_CALL_JS"", ""Failed to call JS callback"");
        return;
      }
    }
  }",78,,466,5,,void
132623,BLOCK,-1,,"{
      napi_value recv;
      napi_status status;

      status = napi_get_undefined(env, &recv);
      if (status != napi_ok) {
        napi_throw_error(env,
                         ""ERR_NAPI_TSFN_GET_UNDEFINED"",
                         ""Failed to retrieve undefined value"");
        return;
      }

      status = napi_call_function(env, recv, cb, 0, nullptr, nullptr);
      if (status != napi_ok && status != napi_pending_exception) {
        napi_throw_error(
            env, ""ERR_NAPI_TSFN_CALL_JS"", ""Failed to call JS callback"");
        return;
      }
    }",45,,467,2,,void
132636,BLOCK,-1,,"{
        napi_throw_error(env,
                         ""ERR_NAPI_TSFN_GET_UNDEFINED"",
                         ""Failed to retrieve undefined value"");
        return;
      }",30,,472,2,,void
132659,BLOCK,-1,,"{
        napi_throw_error(
            env, ""ERR_NAPI_TSFN_CALL_JS"", ""Failed to call JS callback"");
        return;
      }",66,,480,2,,void
132669,BLOCK,-1,,"{
    ThreadSafeFunction* ts_fn =
        node::ContainerOf(&ThreadSafeFunction::async, async);
    ts_fn->Dispatch();
  }",42,,488,2,,void
132690,BLOCK,-1,,"{
    reinterpret_cast<ThreadSafeFunction*>(data)->CloseHandlesAndMaybeDelete(
        true);
  }",35,,494,2,,void
132720,BLOCK,-1,,<empty>,,,,1,,<empty>
132745,BLOCK,-1,,"{
    async_id_ = node_env()->new_async_id();
    trigger_async_id_ = node_env()->get_default_trigger_async_id();
    resource_.Reset(node_env()->isolate(), resource_object);
    lost_reference_ = false;
    if (externally_managed_resource) {
      resource_.SetWeak(
          this, AsyncContext::WeakCallback, v8::WeakCallbackType::kParameter);
    }

    node::AsyncWrap::EmitAsyncInit(node_env(),
                                   resource_object,
                                   resource_name,
                                   async_id_,
                                   trigger_async_id_);
  }",19,,541,5,,void
132772,BLOCK,-1,,"{
      resource_.SetWeak(
          this, AsyncContext::WeakCallback, v8::WeakCallbackType::kParameter);
    }",38,,546,2,,void
132800,BLOCK,-1,,"{
    resource_.Reset();
    lost_reference_ = true;
    node::AsyncWrap::EmitDestroy(node_env(), async_id_);
  }",19,,558,1,,void
132823,BLOCK,-1,,"{
    EnsureReference();
    return node::InternalMakeCallback(node_env(),
                                      resource(),
                                      recv,
                                      callback,
                                      argc,
                                      argv,
                                      {async_id_, trigger_async_id_});
  }",36,,568,5,,void
132842,BLOCK,-1,,"{
    EnsureReference();
    napi_callback_scope it =
        reinterpret_cast<napi_callback_scope>(new CallbackScope(this));
    env_->open_callback_scopes++;
    return it;
  }",50,,579,1,,void
132861,BLOCK,-1,,"{
    if (lost_reference_) {
      const v8::HandleScope handle_scope(node_env()->isolate());
      resource_.Reset(node_env()->isolate(),
                      v8::Object::New(node_env()->isolate()));
      lost_reference_ = false;
    }
  }",33,,587,1,,void
132864,BLOCK,-1,,"{
      const v8::HandleScope handle_scope(node_env()->isolate());
      resource_.Reset(node_env()->isolate(),
                      v8::Object::New(node_env()->isolate()));
      lost_reference_ = false;
    }",26,,588,2,,void
132895,BLOCK,-1,,{ return env_->node_env(); },40,,596,1,,void
132904,BLOCK,-1,,"{
    return resource_.Get(node_env()->isolate());
  }",43,,597,1,,void
132917,BLOCK,-1,,"{
    return {async_id_, trigger_async_id_};
  }",46,,600,1,,void
132924,BLOCK,-1,,"{
    CallbackScope* callback_scope = reinterpret_cast<CallbackScope*>(s);
    delete callback_scope;
    env->open_callback_scopes--;
  }",64,,605,3,,void
132941,BLOCK,-1,,"{
    AsyncContext* async_context = data.GetParameter();
    async_context->resource_.Reset();
    async_context->lost_reference_ = true;
  }",76,,611,2,,void
132965,BLOCK,-1,,<empty>,63,,624,2,,void
132978,BLOCK,-1,,"{
  napi_module_register_by_symbol(
      exports,
      module,
      context,
      static_cast<const napi_module*>(priv)->nm_register_func);
}",49,,644,5,,void
132995,BLOCK,-1,,"{
  napi_module_register_by_symbol(
      exports,
      module,
      context,
      reinterpret_cast<napi_addon_register_func>(priv),
      module_api_version);
}",56,,656,5,,void
133010,BLOCK,-1,,"{
  static_assert(
      NAPI_VERSION == 8,
      ""New version of Node-API requires adding another else-if statement below ""
      ""for the new version and updating this assert condition."");
  if (module_api_version <= NODE_API_DEFAULT_MODULE_API_VERSION) {
    return node_api_context_register_func<NODE_API_DEFAULT_MODULE_API_VERSION>;
  } else if (module_api_version == NAPI_VERSION_EXPERIMENTAL) {
    return node_api_context_register_func<NAPI_VERSION_EXPERIMENTAL>;
  } else {
    v8impl::ThrowNodeApiVersionError(node_env, module_name, module_api_version);
    return nullptr;
  }
}",33,,674,4,,void
133014,BLOCK,1,,<empty>,,,,1,,void
133022,BLOCK,1,,<empty>,,,,1,,void
133024,BLOCK,-1,,"{
    return node_api_context_register_func<NODE_API_DEFAULT_MODULE_API_VERSION>;
  }",66,,679,2,,void
133028,BLOCK,-1,,<empty>,10,,681,1,,void
133033,BLOCK,1,,<empty>,,,,1,,void
133035,BLOCK,-1,,"{
    return node_api_context_register_func<NAPI_VERSION_EXPERIMENTAL>;
  }",63,,681,2,,void
133039,BLOCK,-1,,"{
    v8impl::ThrowNodeApiVersionError(node_env, module_name, module_api_version);
    return nullptr;
  }",10,,683,1,,void
133056,BLOCK,-1,,"{
  node::Environment* node_env = node::Environment::GetCurrent(context);
  std::string module_filename = """";
  if (init == nullptr) {
    CHECK_NOT_NULL(node_env);
    node_env->ThrowError(""Module has no declared entry point."");
    return;
  }

  // We set `env->filename` from `module.filename` here, but we could just as
  // easily add a private property to `exports` in `process.dlopen`, which
  // receives the file name from JS, and retrieve *that* here. Thus, we are not
  // endorsing commonjs here by making use of `module.filename`.
  v8::Local<v8::Value> filename_js;
  v8::Local<v8::Object> modobj;
  if (module->ToObject(context).ToLocal(&modobj) &&
      modobj->Get(context, node_env->filename_string()).ToLocal(&filename_js) &&
      filename_js->IsString()) {
    node::Utf8Value filename(node_env->isolate(), filename_js);

    // Turn the absolute path into a URL. Currently the absolute path is always
    // a file system path.
    // TODO(gabrielschulhof): Pass the `filena...",65,,693,6,,void
133075,BLOCK,-1,,"{
    CHECK_NOT_NULL(node_env);
    node_env->ThrowError(""Module has no declared entry point."");
    return;
  }",24,,696,2,,void
133133,BLOCK,-1,,"{
    node::Utf8Value filename(node_env->isolate(), filename_js);

    // Turn the absolute path into a URL. Currently the absolute path is always
    // a file system path.
    // TODO(gabrielschulhof): Pass the `filename` through unchanged if/when we
    // receive it as a URL already.
    module_filename = node::url::FromFilePath(filename.ToStringView());
  }",32,,710,2,,void
133182,BLOCK,-1,,"{
    napi_value _module = v8impl::JsValueFromV8LocalValue(module);
    napi_set_named_property(env, _module, ""exports"", _exports);
  }",61,,732,2,,void
133201,BLOCK,-1,,"{
  return {
      -1,
      mod->nm_flags | NM_F_DELETEME,
      nullptr,
      mod->nm_filename,
      nullptr,
      napi_module_register_cb,
      mod->nm_modname,
      const_cast<napi_module*>(mod),  // priv
      nullptr,
  };
}",64,,739,2,,void
133207,BLOCK,-1,,"{
  node::node_module* nm =
      new node::node_module(node::napi_module_to_node_module(mod));
  node::node_module_register(nm);
}",56,,755,2,,void
133229,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, fun);

  node::AddEnvironmentCleanupHook(env->isolate, fun, arg);

  return napi_ok;
}",61,,763,4,,void
133232,BLOCK,1,,<empty>,,,,2,,void
133234,BLOCK,-1,,CHECK_ENV(env),3,,764,1,,void
133239,BLOCK,-1,,CHECK_ENV(env),3,,764,2,,void
133246,BLOCK,1,,<empty>,,,,3,,void
133248,BLOCK,-1,,"CHECK_ARG(env, fun)",3,,765,1,,void
133254,BLOCK,-1,,"CHECK_ARG(env, fun)",3,,765,2,,void
133277,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, fun);

  node::RemoveEnvironmentCleanupHook(env->isolate, fun, arg);

  return napi_ok;
}",64,,774,4,,void
133280,BLOCK,1,,<empty>,,,,2,,void
133282,BLOCK,-1,,CHECK_ENV(env),3,,775,1,,void
133287,BLOCK,-1,,CHECK_ENV(env),3,,775,2,,void
133294,BLOCK,1,,<empty>,,,,3,,void
133296,BLOCK,-1,,"CHECK_ARG(env, fun)",3,,776,1,,void
133302,BLOCK,-1,,"CHECK_ARG(env, fun)",3,,776,2,,void
133325,BLOCK,-1,,"{
    handle_ = node::AddEnvironmentCleanupHook(env->isolate, Hook, this);
    env->Ref();
  }",65,,787,4,,void
133344,BLOCK,-1,,"{
    node::RemoveEnvironmentCleanupHook(std::move(handle_));
    if (done_cb_ != nullptr) done_cb_(done_data_);

    // Release the `env` handle asynchronously since it would be surprising if
    // a call to a N-API function would destroy `env` synchronously.
    static_cast<node_napi_env>(env_)->node_env()->SetImmediate(
        [env = env_](node::Environment*) { env->Unref(); });
  }",39,,792,1,,void
133358,BLOCK,-1,,<empty>,30,,794,2,,void
133377,BLOCK,-1,,"{
    napi_async_cleanup_hook_handle__* handle =
        static_cast<napi_async_cleanup_hook_handle__*>(data);
    handle->done_cb_ = done_cb;
    handle->done_data_ = done_data;
    handle->user_hook_(handle, handle->user_data_);
  }",73,,802,4,,void
133410,BLOCK,-1,,<empty>,,,,2,,<empty>
133415,BLOCK,-1,,<empty>,,,,1,,<empty>
133438,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, hook);

  napi_async_cleanup_hook_handle__* handle =
      new napi_async_cleanup_hook_handle__(env, hook, arg);

  if (remove_handle != nullptr) *remove_handle = handle;

  return napi_clear_last_error(env);
}",76,,822,5,,void
133441,BLOCK,1,,<empty>,,,,2,,void
133443,BLOCK,-1,,CHECK_ENV(env),3,,823,1,,void
133448,BLOCK,-1,,CHECK_ENV(env),3,,823,2,,void
133455,BLOCK,1,,<empty>,,,,3,,void
133457,BLOCK,-1,,"CHECK_ARG(env, hook)",3,,824,1,,void
133463,BLOCK,-1,,"CHECK_ARG(env, hook)",3,,824,2,,void
133481,BLOCK,-1,,<empty>,33,,829,2,,void
133493,BLOCK,-1,,"{
  if (remove_handle == nullptr) return napi_invalid_arg;

  delete remove_handle;

  return napi_ok;
}",78,,835,2,,void
133498,BLOCK,-1,,<empty>,33,,836,2,,void
133510,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, err);

  v8::Local<v8::Value> local_err = v8impl::V8LocalValueFromJsValue(err);
  static_cast<node_napi_env>(env)->trigger_fatal_exception(local_err);

  return napi_clear_last_error(env);
}",75,,843,3,,void
133513,BLOCK,1,,<empty>,,,,2,,void
133515,BLOCK,-1,,NAPI_PREAMBLE(env),3,,844,1,,void
133520,BLOCK,-1,,NAPI_PREAMBLE(env),3,,844,2,,void
133525,BLOCK,-1,,NAPI_PREAMBLE(env),3,,844,1,,void
133539,BLOCK,-1,,NAPI_PREAMBLE(env),3,,844,2,,void
133553,BLOCK,1,,<empty>,,,,3,,void
133555,BLOCK,-1,,"CHECK_ARG(env, err)",3,,845,1,,void
133561,BLOCK,-1,,"CHECK_ARG(env, err)",3,,845,2,,void
133599,BLOCK,-1,,"{
  std::string location_string;
  std::string message_string;

  if (location_len != NAPI_AUTO_LENGTH) {
    location_string.assign(const_cast<char*>(location), location_len);
  } else {
    location_string.assign(const_cast<char*>(location), strlen(location));
  }

  if (message_len != NAPI_AUTO_LENGTH) {
    message_string.assign(const_cast<char*>(message), message_len);
  } else {
    message_string.assign(const_cast<char*>(message), strlen(message));
  }

  node::OnFatalError(location_string.c_str(), message_string.c_str());
}",69,,856,5,,void
133606,BLOCK,1,,<empty>,,,,1,,void
133608,BLOCK,-1,,"{
    location_string.assign(const_cast<char*>(location), location_len);
  }",41,,860,2,,void
133618,BLOCK,-1,,"{
    location_string.assign(const_cast<char*>(location), strlen(location));
  }",10,,862,1,,void
133632,BLOCK,1,,<empty>,,,,1,,void
133634,BLOCK,-1,,"{
    message_string.assign(const_cast<char*>(message), message_len);
  }",40,,866,2,,void
133644,BLOCK,-1,,"{
    message_string.assign(const_cast<char*>(message), strlen(message));
  }",10,,868,1,,void
133673,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  v8impl::AsyncContext* node_async_context =
      reinterpret_cast<v8impl::AsyncContext*>(async_context_handle);

  *result = node_async_context->OpenCallbackScope();

  return napi_clear_last_error(env);
}",55,,879,5,,void
133676,BLOCK,1,,<empty>,,,,2,,void
133678,BLOCK,-1,,CHECK_ENV(env),3,,882,1,,void
133683,BLOCK,-1,,CHECK_ENV(env),3,,882,2,,void
133690,BLOCK,1,,<empty>,,,,3,,void
133692,BLOCK,-1,,"CHECK_ARG(env, result)",3,,883,1,,void
133698,BLOCK,-1,,"CHECK_ARG(env, result)",3,,883,2,,void
133725,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, scope);
  if (env->open_callback_scopes == 0) {
    return napi_callback_scope_mismatch;
  }

  v8impl::AsyncContext::CloseCallbackScope(reinterpret_cast<node_napi_env>(env),
                                           scope);

  return napi_clear_last_error(env);
}",77,,894,3,,void
133728,BLOCK,1,,<empty>,,,,2,,void
133730,BLOCK,-1,,CHECK_ENV(env),3,,897,1,,void
133735,BLOCK,-1,,CHECK_ENV(env),3,,897,2,,void
133742,BLOCK,1,,<empty>,,,,3,,void
133744,BLOCK,-1,,"CHECK_ARG(env, scope)",3,,898,1,,void
133750,BLOCK,-1,,"CHECK_ARG(env, scope)",3,,898,2,,void
133762,BLOCK,-1,,"{
    return napi_callback_scope_mismatch;
  }",39,,899,2,,void
133785,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, async_resource_name);
  CHECK_ARG(env, result);

  v8::Isolate* isolate = env->isolate;
  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Object> v8_resource;
  bool externally_managed_resource;
  if (async_resource != nullptr) {
    CHECK_TO_OBJECT(env, context, v8_resource, async_resource);
    externally_managed_resource = true;
  } else {
    v8_resource = v8::Object::New(isolate);
    externally_managed_resource = false;
  }

  v8::Local<v8::String> v8_resource_name;
  CHECK_TO_STRING(env, context, v8_resource_name, async_resource_name);

  v8impl::AsyncContext* async_context =
      new v8impl::AsyncContext(reinterpret_cast<node_napi_env>(env),
                               v8_resource,
                               v8_resource_name,
                               externally_managed_resource);

  *result = reinterpret_cast<napi_async_context>(async_context);

  return napi_clear_last_error(env);
}",68,,912,5,,void
133788,BLOCK,1,,<empty>,,,,2,,void
133790,BLOCK,-1,,CHECK_ENV(env),3,,913,1,,void
133795,BLOCK,-1,,CHECK_ENV(env),3,,913,2,,void
133802,BLOCK,1,,<empty>,,,,3,,void
133804,BLOCK,-1,,"CHECK_ARG(env, async_resource_name)",3,,914,1,,void
133810,BLOCK,-1,,"CHECK_ARG(env, async_resource_name)",3,,914,2,,void
133819,BLOCK,1,,<empty>,,,,3,,void
133821,BLOCK,-1,,"CHECK_ARG(env, result)",3,,915,1,,void
133827,BLOCK,-1,,"CHECK_ARG(env, result)",3,,915,2,,void
133867,BLOCK,-1,,"{
    CHECK_TO_OBJECT(env, context, v8_resource, async_resource);
    externally_managed_resource = true;
  }",34,,922,2,,void
133874,BLOCK,1,,<empty>,,,,7,,void
133876,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, v8_resource, async_resource)",5,,923,1,,void
133878,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, v8_resource, async_resource)",5,,923,1,,void
133884,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, v8_resource, async_resource)",5,,923,2,,void
133903,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, v8_resource, async_resource)",5,,923,1,,void
133911,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, v8_resource, async_resource)",5,,923,2,,void
133928,BLOCK,-1,,"{
    v8_resource = v8::Object::New(isolate);
    externally_managed_resource = false;
  }",10,,925,1,,void
133956,BLOCK,1,,<empty>,,,,7,,void
133958,BLOCK,-1,,"CHECK_TO_STRING(env, context, v8_resource_name, async_resource_name)",3,,931,1,,void
133960,BLOCK,-1,,"CHECK_TO_STRING(env, context, v8_resource_name, async_resource_name)",3,,931,1,,void
133966,BLOCK,-1,,"CHECK_TO_STRING(env, context, v8_resource_name, async_resource_name)",3,,931,2,,void
133985,BLOCK,-1,,"CHECK_TO_STRING(env, context, v8_resource_name, async_resource_name)",3,,931,1,,void
133993,BLOCK,-1,,"CHECK_TO_STRING(env, context, v8_resource_name, async_resource_name)",3,,931,2,,void
134031,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, async_context);

  v8impl::AsyncContext* node_async_context =
      reinterpret_cast<v8impl::AsyncContext*>(async_context);

  delete node_async_context;

  return napi_clear_last_error(env);
}",77,,945,3,,void
134034,BLOCK,1,,<empty>,,,,2,,void
134036,BLOCK,-1,,CHECK_ENV(env),3,,946,1,,void
134041,BLOCK,-1,,CHECK_ENV(env),3,,946,2,,void
134048,BLOCK,1,,<empty>,,,,3,,void
134050,BLOCK,-1,,"CHECK_ARG(env, async_context)",3,,947,1,,void
134056,BLOCK,-1,,"CHECK_ARG(env, async_context)",3,,947,2,,void
134083,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, recv);
  if (argc > 0) {
    CHECK_ARG(env, argv);
  }

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Object> v8recv;
  CHECK_TO_OBJECT(env, context, v8recv, recv);

  v8::Local<v8::Function> v8func;
  CHECK_TO_FUNCTION(env, v8func, func);

  v8::MaybeLocal<v8::Value> callback_result;

  if (async_context == nullptr) {
    callback_result = node::MakeCallback(
        env->isolate,
        v8recv,
        v8func,
        argc,
        reinterpret_cast<v8::Local<v8::Value>*>(const_cast<napi_value*>(argv)),
        {0, 0});
  } else {
    v8impl::AsyncContext* node_async_context =
        reinterpret_cast<v8impl::AsyncContext*>(async_context);
    callback_result = node_async_context->MakeCallback(
        v8recv,
        v8func,
        argc,
        reinterpret_cast<v8::Local<v8::Value>*>(const_cast<napi_value*>(argv)));
  }

  if (try_catch.HasCaught()) {
    return napi_set_last_error(env, napi_pending_exception);
  } ...",63,,963,8,,void
134086,BLOCK,1,,<empty>,,,,2,,void
134088,BLOCK,-1,,NAPI_PREAMBLE(env),3,,964,1,,void
134093,BLOCK,-1,,NAPI_PREAMBLE(env),3,,964,2,,void
134098,BLOCK,-1,,NAPI_PREAMBLE(env),3,,964,1,,void
134112,BLOCK,-1,,NAPI_PREAMBLE(env),3,,964,2,,void
134126,BLOCK,1,,<empty>,,,,3,,void
134128,BLOCK,-1,,"CHECK_ARG(env, recv)",3,,965,1,,void
134134,BLOCK,-1,,"CHECK_ARG(env, recv)",3,,965,2,,void
134144,BLOCK,-1,,"{
    CHECK_ARG(env, argv);
  }",17,,966,2,,void
134148,BLOCK,1,,<empty>,,,,3,,void
134150,BLOCK,-1,,"CHECK_ARG(env, argv)",5,,967,1,,void
134156,BLOCK,-1,,"CHECK_ARG(env, argv)",5,,967,2,,void
134191,BLOCK,1,,<empty>,,,,7,,void
134193,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, v8recv, recv)",3,,973,1,,void
134195,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, v8recv, recv)",3,,973,1,,void
134201,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, v8recv, recv)",3,,973,2,,void
134220,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, v8recv, recv)",3,,973,1,,void
134228,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, v8recv, recv)",3,,973,2,,void
134254,BLOCK,1,,<empty>,,,,4,,void
134256,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8func, func)",3,,976,1,,void
134258,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8func, func)",3,,976,1,,void
134264,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8func, func)",3,,976,2,,void
134286,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8func, func)",3,,976,1,,void
134293,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8func, func)",3,,976,2,,void
134319,BLOCK,-1,,"{
    callback_result = node::MakeCallback(
        env->isolate,
        v8recv,
        v8func,
        argc,
        reinterpret_cast<v8::Local<v8::Value>*>(const_cast<napi_value*>(argv)),
        {0, 0});
  }",33,,980,2,,void
134341,BLOCK,-1,,"{
    v8impl::AsyncContext* node_async_context =
        reinterpret_cast<v8impl::AsyncContext*>(async_context);
    callback_result = node_async_context->MakeCallback(
        v8recv,
        v8func,
        argc,
        reinterpret_cast<v8::Local<v8::Value>*>(const_cast<napi_value*>(argv)));
  }",10,,988,1,,void
134367,BLOCK,-1,,"{
    return napi_set_last_error(env, napi_pending_exception);
  }",30,,998,2,,void
134373,BLOCK,-1,,"{
    CHECK_MAYBE_EMPTY(env, callback_result, napi_generic_failure);
    if (result != nullptr) {
      *result =
          v8impl::JsValueFromV8LocalValue(callback_result.ToLocalChecked());
    }
  }",10,,1000,1,,void
134378,BLOCK,1,,<empty>,,,,4,,void
134380,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, callback_result, napi_generic_failure)",5,,1001,1,,void
134388,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, callback_result, napi_generic_failure)",5,,1001,2,,void
134398,BLOCK,-1,,"{
      *result =
          v8impl::JsValueFromV8LocalValue(callback_result.ToLocalChecked());
    }",28,,1002,2,,void
134413,BLOCK,1,,<empty>,,,,3,,void
134431,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::MaybeLocal<v8::Object> maybe = node::Buffer::New(env->isolate, length);

  CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure);

  v8::Local<v8::Object> buffer = maybe.ToLocalChecked();

  *result = v8impl::JsValueFromV8LocalValue(buffer);

  if (data != nullptr) {
    *data = node::Buffer::Data(buffer);
  }

  return GET_RETURN_STATUS(env);
}",63,,1014,5,,void
134434,BLOCK,1,,<empty>,,,,2,,void
134436,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1015,1,,void
134441,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1015,2,,void
134446,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1015,1,,void
134460,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1015,2,,void
134474,BLOCK,1,,<empty>,,,,3,,void
134476,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1016,1,,void
134482,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1016,2,,void
134512,BLOCK,1,,<empty>,,,,4,,void
134514,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure)",3,,1020,1,,void
134522,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure)",3,,1020,2,,void
134554,BLOCK,-1,,"{
    *data = node::Buffer::Data(buffer);
  }",24,,1026,2,,void
134568,BLOCK,1,,<empty>,,,,3,,void
134588,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

#if defined(V8_ENABLE_SANDBOX)
  return napi_set_last_error(env, napi_no_external_buffers_allowed);
#endif

  v8::Isolate* isolate = env->isolate;

  // The finalizer object will delete itself after invoking the callback.
  v8impl::BufferFinalizer* finalizer =
      v8impl::BufferFinalizer::New(env, finalize_cb, nullptr, finalize_hint);

  v8::MaybeLocal<v8::Object> maybe =
      node::Buffer::New(isolate,
                        static_cast<char*>(data),
                        length,
                        v8impl::BufferFinalizer::FinalizeBufferCallback,
                        finalizer);

  CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure);

  *result = v8impl::JsValueFromV8LocalValue(maybe.ToLocalChecked());
  return GET_RETURN_STATUS(env);
  // Tell coverity that 'finalizer' should not be freed when we return
  // as it will be deleted when the buffer to which it is associated
  // is finalized.
  // coverity[leaked_storag...",72,,1038,7,,void
134591,BLOCK,1,,<empty>,,,,2,,void
134593,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1039,1,,void
134598,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1039,2,,void
134603,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1039,1,,void
134617,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1039,2,,void
134631,BLOCK,1,,<empty>,,,,3,,void
134633,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1040,1,,void
134639,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1040,2,,void
134695,BLOCK,1,,<empty>,,,,4,,void
134697,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure)",3,,1059,1,,void
134705,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure)",3,,1059,2,,void
134725,BLOCK,1,,<empty>,,,,3,,void
134744,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::MaybeLocal<v8::Object> maybe =
      node::Buffer::Copy(env->isolate, static_cast<const char*>(data), length);

  CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure);

  v8::Local<v8::Object> buffer = maybe.ToLocalChecked();
  *result = v8impl::JsValueFromV8LocalValue(buffer);

  if (result_data != nullptr) {
    *result_data = node::Buffer::Data(buffer);
  }

  return GET_RETURN_STATUS(env);
}",68,,1073,6,,void
134747,BLOCK,1,,<empty>,,,,2,,void
134749,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1074,1,,void
134754,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1074,2,,void
134759,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1074,1,,void
134773,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1074,2,,void
134787,BLOCK,1,,<empty>,,,,3,,void
134789,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1075,1,,void
134795,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1075,2,,void
134828,BLOCK,1,,<empty>,,,,4,,void
134830,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure)",3,,1080,1,,void
134838,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure)",3,,1080,2,,void
134870,BLOCK,-1,,"{
    *result_data = node::Buffer::Data(buffer);
  }",31,,1085,2,,void
134884,BLOCK,1,,<empty>,,,,3,,void
134901,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  *result = node::Buffer::HasInstance(v8impl::V8LocalValueFromJsValue(value));
  return napi_clear_last_error(env);
}",53,,1094,4,,void
134904,BLOCK,1,,<empty>,,,,2,,void
134906,BLOCK,-1,,CHECK_ENV(env),3,,1095,1,,void
134911,BLOCK,-1,,CHECK_ENV(env),3,,1095,2,,void
134918,BLOCK,1,,<empty>,,,,3,,void
134920,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1096,1,,void
134926,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1096,2,,void
134935,BLOCK,1,,<empty>,,,,3,,void
134937,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1097,1,,void
134943,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1097,2,,void
134973,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);

  v8::Local<v8::Value> buffer = v8impl::V8LocalValueFromJsValue(value);

  if (data != nullptr) {
    *data = node::Buffer::Data(buffer);
  }
  if (length != nullptr) {
    *length = node::Buffer::Length(buffer);
  }

  return napi_clear_last_error(env);
}",61,,1106,5,,void
134976,BLOCK,1,,<empty>,,,,2,,void
134978,BLOCK,-1,,CHECK_ENV(env),3,,1107,1,,void
134983,BLOCK,-1,,CHECK_ENV(env),3,,1107,2,,void
134990,BLOCK,1,,<empty>,,,,3,,void
134992,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1108,1,,void
134998,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1108,2,,void
135023,BLOCK,-1,,"{
    *data = node::Buffer::Data(buffer);
  }",24,,1112,2,,void
135038,BLOCK,-1,,"{
    *length = node::Buffer::Length(buffer);
  }",26,,1115,2,,void
135057,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);
  static const napi_node_version version = {
      NODE_MAJOR_VERSION, NODE_MINOR_VERSION, NODE_PATCH_VERSION, NODE_RELEASE};
  *result = &version;
  return napi_clear_last_error(env);
}",80,,1123,3,,void
135060,BLOCK,1,,<empty>,,,,2,,void
135062,BLOCK,-1,,CHECK_ENV(env),3,,1124,1,,void
135067,BLOCK,-1,,CHECK_ENV(env),3,,1124,2,,void
135074,BLOCK,1,,<empty>,,,,3,,void
135076,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1125,1,,void
135082,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1125,2,,void
135093,BLOCK,1,,<empty>,,,,1,,void
135096,BLOCK,1,,<empty>,,,,1,,void
135099,BLOCK,1,,<empty>,,,,1,,void
135102,BLOCK,1,,<empty>,,,,1,,void
135118,BLOCK,-1,,"{
  switch (code) {
    case 0:
      return napi_ok;
    case UV_EINVAL:
      return napi_invalid_arg;
    case UV_ECANCELED:
      return napi_cancelled;
    default:
      return napi_generic_failure;
  }
}",49,,1135,2,,void
135121,BLOCK,-1,,"{
    case 0:
      return napi_ok;
    case UV_EINVAL:
      return napi_invalid_arg;
    case UV_ECANCELED:
      return napi_cancelled;
    default:
      return napi_generic_failure;
  }",17,,1136,2,,void
135146,BLOCK,-1,,<empty>,29,,1165,7,,void
135150,BLOCK,-1,,<empty>,,,,1,,<empty>
135160,BLOCK,-1,,"{
    return new Work(
        env, async_resource, async_resource_name, execute, complete, data);
  }",32,,1175,7,,void
135174,BLOCK,-1,,{ delete work; },34,,1180,2,,void
135180,BLOCK,-1,,"{ _execute(_env, _data); }",36,,1182,1,,void
135187,BLOCK,-1,,"{
    if (_complete == nullptr) return;

    // Establish a handle scope here so that every callback doesn't have to.
    // Also it is needed for the exception-handling below.
    v8::HandleScope scope(_env->isolate);

    CallbackScope callback_scope(this);

    _env->CallbackIntoModule<true>([&](napi_env env) {
      _complete(env, ConvertUVErrorCode(status), _data);
    });

    // Note: Don't access `work` after this point because it was
    // likely deleted by the complete callback.
  }",49,,1184,2,,void
135192,BLOCK,-1,,<empty>,31,,1185,2,,void
135221,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, execute);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Object> resource;
  if (async_resource != nullptr) {
    CHECK_TO_OBJECT(env, context, resource, async_resource);
  } else {
    resource = v8::Object::New(env->isolate);
  }

  v8::Local<v8::String> resource_name;
  CHECK_TO_STRING(env, context, resource_name, async_resource_name);

  uvimpl::Work* work = uvimpl::Work::New(reinterpret_cast<node_napi_env>(env),
                                         resource,
                                         resource_name,
                                         execute,
                                         complete,
                                         data);

  *result = reinterpret_cast<napi_async_work>(work);

  return napi_clear_last_error(env);
}",49,,1227,8,,void
135224,BLOCK,1,,<empty>,,,,2,,void
135226,BLOCK,-1,,CHECK_ENV(env),3,,1228,1,,void
135231,BLOCK,-1,,CHECK_ENV(env),3,,1228,2,,void
135238,BLOCK,1,,<empty>,,,,3,,void
135240,BLOCK,-1,,"CHECK_ARG(env, execute)",3,,1229,1,,void
135246,BLOCK,-1,,"CHECK_ARG(env, execute)",3,,1229,2,,void
135255,BLOCK,1,,<empty>,,,,3,,void
135257,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1230,1,,void
135263,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1230,2,,void
135296,BLOCK,-1,,"{
    CHECK_TO_OBJECT(env, context, resource, async_resource);
  }",34,,1235,2,,void
135303,BLOCK,1,,<empty>,,,,7,,void
135305,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, resource, async_resource)",5,,1236,1,,void
135307,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, resource, async_resource)",5,,1236,1,,void
135313,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, resource, async_resource)",5,,1236,2,,void
135332,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, resource, async_resource)",5,,1236,1,,void
135340,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, resource, async_resource)",5,,1236,2,,void
135354,BLOCK,-1,,"{
    resource = v8::Object::New(env->isolate);
  }",10,,1237,1,,void
135381,BLOCK,1,,<empty>,,,,7,,void
135383,BLOCK,-1,,"CHECK_TO_STRING(env, context, resource_name, async_resource_name)",3,,1242,1,,void
135385,BLOCK,-1,,"CHECK_TO_STRING(env, context, resource_name, async_resource_name)",3,,1242,1,,void
135391,BLOCK,-1,,"CHECK_TO_STRING(env, context, resource_name, async_resource_name)",3,,1242,2,,void
135410,BLOCK,-1,,"CHECK_TO_STRING(env, context, resource_name, async_resource_name)",3,,1242,1,,void
135418,BLOCK,-1,,"CHECK_TO_STRING(env, context, resource_name, async_resource_name)",3,,1242,2,,void
135462,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, work);

  uvimpl::Work::Delete(reinterpret_cast<uvimpl::Work*>(work));

  return napi_clear_last_error(env);
}",69,,1257,3,,void
135465,BLOCK,1,,<empty>,,,,2,,void
135467,BLOCK,-1,,CHECK_ENV(env),3,,1258,1,,void
135472,BLOCK,-1,,CHECK_ENV(env),3,,1258,2,,void
135479,BLOCK,1,,<empty>,,,,3,,void
135481,BLOCK,-1,,"CHECK_ARG(env, work)",3,,1259,1,,void
135487,BLOCK,-1,,"CHECK_ARG(env, work)",3,,1259,2,,void
135510,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, loop);
  *loop = reinterpret_cast<node_napi_env>(env)->node_env()->event_loop();
  return napi_clear_last_error(env);
}",79,,1266,3,,void
135513,BLOCK,1,,<empty>,,,,2,,void
135515,BLOCK,-1,,CHECK_ENV(env),3,,1267,1,,void
135520,BLOCK,-1,,CHECK_ENV(env),3,,1267,2,,void
135527,BLOCK,1,,<empty>,,,,3,,void
135529,BLOCK,-1,,"CHECK_ARG(env, loop)",3,,1268,1,,void
135535,BLOCK,-1,,"CHECK_ARG(env, loop)",3,,1268,2,,void
135561,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, work);

  uv_loop_t* event_loop = nullptr;
  STATUS_CALL(napi_get_uv_event_loop(env, &event_loop));

  uvimpl::Work* w = reinterpret_cast<uvimpl::Work*>(work);

  w->ScheduleWork();

  return napi_clear_last_error(env);
}",68,,1274,3,,void
135564,BLOCK,1,,<empty>,,,,2,,void
135566,BLOCK,-1,,CHECK_ENV(env),3,,1275,1,,void
135571,BLOCK,-1,,CHECK_ENV(env),3,,1275,2,,void
135578,BLOCK,1,,<empty>,,,,3,,void
135580,BLOCK,-1,,"CHECK_ARG(env, work)",3,,1276,1,,void
135586,BLOCK,-1,,"CHECK_ARG(env, work)",3,,1276,2,,void
135598,BLOCK,1,,<empty>,,,,4,,void
135600,BLOCK,-1,,"STATUS_CALL(napi_get_uv_event_loop(env, &event_loop))",3,,1279,1,,void
135612,BLOCK,-1,,<empty>,3,,1279,2,,void
135634,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, work);

  uvimpl::Work* w = reinterpret_cast<uvimpl::Work*>(work);

  CALL_UV(env, w->CancelWork());

  return napi_clear_last_error(env);
}",69,,1289,3,,void
135637,BLOCK,1,,<empty>,,,,2,,void
135639,BLOCK,-1,,CHECK_ENV(env),3,,1290,1,,void
135644,BLOCK,-1,,CHECK_ENV(env),3,,1290,2,,void
135651,BLOCK,1,,<empty>,,,,3,,void
135653,BLOCK,-1,,"CHECK_ARG(env, work)",3,,1291,1,,void
135659,BLOCK,-1,,"CHECK_ARG(env, work)",3,,1291,2,,void
135679,BLOCK,1,,<empty>,,,,8,,void
135681,BLOCK,-1,,"CALL_UV(env, w->CancelWork())",3,,1295,1,,void
135701,BLOCK,-1,,"CALL_UV(env, w->CancelWork())",3,,1295,2,,void
135725,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, async_resource_name);
  RETURN_STATUS_IF_FALSE(env, initial_thread_count > 0, napi_invalid_arg);
  CHECK_ARG(env, result);

  napi_status status = napi_ok;

  v8::Local<v8::Function> v8_func;
  if (func == nullptr) {
    CHECK_ARG(env, call_js_cb);
  } else {
    CHECK_TO_FUNCTION(env, v8_func, func);
  }

  v8::Local<v8::Context> v8_context = env->context();

  v8::Local<v8::Object> v8_resource;
  if (async_resource == nullptr) {
    v8_resource = v8::Object::New(env->isolate);
  } else {
    CHECK_TO_OBJECT(env, v8_context, v8_resource, async_resource);
  }

  v8::Local<v8::String> v8_name;
  CHECK_TO_STRING(env, v8_context, v8_name, async_resource_name);

  v8impl::ThreadSafeFunction* ts_fn =
      new v8impl::ThreadSafeFunction(v8_func,
                                     v8_resource,
                                     v8_name,
                                     initial_thread_count,
                                     context,
        ...",67,,1311,12,,void
135728,BLOCK,1,,<empty>,,,,2,,void
135730,BLOCK,-1,,CHECK_ENV(env),3,,1312,1,,void
135735,BLOCK,-1,,CHECK_ENV(env),3,,1312,2,,void
135742,BLOCK,1,,<empty>,,,,3,,void
135744,BLOCK,-1,,"CHECK_ARG(env, async_resource_name)",3,,1313,1,,void
135750,BLOCK,-1,,"CHECK_ARG(env, async_resource_name)",3,,1313,2,,void
135759,BLOCK,1,,<empty>,,,,3,,void
135761,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, initial_thread_count > 0, napi_invalid_arg)",3,,1314,1,,void
135767,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, initial_thread_count > 0, napi_invalid_arg)",3,,1314,2,,void
135776,BLOCK,1,,<empty>,,,,3,,void
135778,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1315,1,,void
135784,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1315,2,,void
135807,BLOCK,-1,,"{
    CHECK_ARG(env, call_js_cb);
  }",24,,1320,2,,void
135811,BLOCK,1,,<empty>,,,,3,,void
135813,BLOCK,-1,,"CHECK_ARG(env, call_js_cb)",5,,1321,1,,void
135819,BLOCK,-1,,"CHECK_ARG(env, call_js_cb)",5,,1321,2,,void
135826,BLOCK,-1,,"{
    CHECK_TO_FUNCTION(env, v8_func, func);
  }",10,,1322,1,,void
135831,BLOCK,1,,<empty>,,,,4,,void
135833,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8_func, func)",5,,1323,1,,void
135835,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8_func, func)",5,,1323,1,,void
135841,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8_func, func)",5,,1323,2,,void
135863,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8_func, func)",5,,1323,1,,void
135870,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8_func, func)",5,,1323,2,,void
135910,BLOCK,-1,,"{
    v8_resource = v8::Object::New(env->isolate);
  }",34,,1329,2,,void
135923,BLOCK,-1,,"{
    CHECK_TO_OBJECT(env, v8_context, v8_resource, async_resource);
  }",10,,1331,1,,void
135930,BLOCK,1,,<empty>,,,,7,,void
135932,BLOCK,-1,,"CHECK_TO_OBJECT(env, v8_context, v8_resource, async_resource)",5,,1332,1,,void
135934,BLOCK,-1,,"CHECK_TO_OBJECT(env, v8_context, v8_resource, async_resource)",5,,1332,1,,void
135940,BLOCK,-1,,"CHECK_TO_OBJECT(env, v8_context, v8_resource, async_resource)",5,,1332,2,,void
135959,BLOCK,-1,,"CHECK_TO_OBJECT(env, v8_context, v8_resource, async_resource)",5,,1332,1,,void
135967,BLOCK,-1,,"CHECK_TO_OBJECT(env, v8_context, v8_resource, async_resource)",5,,1332,2,,void
135995,BLOCK,1,,<empty>,,,,7,,void
135997,BLOCK,-1,,"CHECK_TO_STRING(env, v8_context, v8_name, async_resource_name)",3,,1336,1,,void
135999,BLOCK,-1,,"CHECK_TO_STRING(env, v8_context, v8_name, async_resource_name)",3,,1336,1,,void
136005,BLOCK,-1,,"CHECK_TO_STRING(env, v8_context, v8_name, async_resource_name)",3,,1336,2,,void
136024,BLOCK,-1,,"CHECK_TO_STRING(env, v8_context, v8_name, async_resource_name)",3,,1336,1,,void
136032,BLOCK,-1,,"CHECK_TO_STRING(env, v8_context, v8_name, async_resource_name)",3,,1336,2,,void
136066,BLOCK,-1,,"{
    status = napi_generic_failure;
  }",25,,1350,2,,void
136071,BLOCK,-1,,"{
    // Init deletes ts_fn upon failure.
    status = ts_fn->Init();
    if (status == napi_ok) {
      *result = reinterpret_cast<napi_threadsafe_function>(ts_fn);
    }
  }",10,,1352,1,,void
136082,BLOCK,-1,,"{
      *result = reinterpret_cast<napi_threadsafe_function>(ts_fn);
    }",28,,1355,2,,void
136098,BLOCK,-1,,"{
  CHECK_NOT_NULL(func);
  CHECK_NOT_NULL(result);

  *result = reinterpret_cast<v8impl::ThreadSafeFunction*>(func)->Context();
  return napi_ok;
}",51,,1364,3,,void
136120,BLOCK,-1,,"{
  CHECK_NOT_NULL(func);
  return reinterpret_cast<v8impl::ThreadSafeFunction*>(func)->Push(data,
                                                                   is_blocking);
}",79,,1375,4,,void
136136,BLOCK,-1,,"{
  CHECK_NOT_NULL(func);
  return reinterpret_cast<v8impl::ThreadSafeFunction*>(func)->Acquire();
}",65,,1382,2,,void
136151,BLOCK,-1,,"{
  CHECK_NOT_NULL(func);
  return reinterpret_cast<v8impl::ThreadSafeFunction*>(func)->Release(mode);
}",80,,1388,3,,void
136167,BLOCK,-1,,"{
  CHECK_NOT_NULL(func);
  return reinterpret_cast<v8impl::ThreadSafeFunction*>(func)->Unref();
}",77,,1394,3,,void
136182,BLOCK,-1,,"{
  CHECK_NOT_NULL(func);
  return reinterpret_cast<v8impl::ThreadSafeFunction*>(func)->Ref();
}",75,,1400,3,,void
136197,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = static_cast<node_napi_env>(env)->GetFilename();
  return napi_clear_last_error(env);
}",75,,1406,3,,void
136200,BLOCK,1,,<empty>,,,,2,,void
136202,BLOCK,-1,,CHECK_ENV(env),3,,1407,1,,void
136207,BLOCK,-1,,CHECK_ENV(env),3,,1407,2,,void
136214,BLOCK,1,,<empty>,,,,3,,void
136216,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1408,1,,void
136222,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1408,2,,void
136250,BLOCK,-1,,<empty>,1,,1,1,,ANY
136255,BLOCK,-1,,<empty>,,,,3,,<empty>
136259,BLOCK,-1,,<empty>,,,,1,,<empty>
136271,BLOCK,-1,,<empty>,,,,1,,<empty>
136279,BLOCK,-1,,<empty>,,,,2,,<empty>
136287,BLOCK,-1,,<empty>,,,,5,,<empty>
136295,BLOCK,-1,,<empty>,,,,5,,<empty>
136301,BLOCK,-1,,<empty>,,,,3,,<empty>
136312,BLOCK,-1,,<empty>,,,,8,,<empty>
136320,BLOCK,-1,,<empty>,,,,5,,<empty>
136330,BLOCK,-1,,<empty>,,,,7,,<empty>
136339,BLOCK,-1,,<empty>,,,,6,,<empty>
136346,BLOCK,-1,,<empty>,,,,4,,<empty>
136354,BLOCK,-1,,<empty>,,,,5,,<empty>
136365,BLOCK,-1,,<empty>,,,,8,,<empty>
136371,BLOCK,-1,,<empty>,,,,3,,<empty>
136377,BLOCK,-1,,<empty>,,,,3,,<empty>
136383,BLOCK,-1,,<empty>,,,,3,,<empty>
136389,BLOCK,-1,,<empty>,,,,3,,<empty>
136395,BLOCK,-1,,<empty>,,,,3,,<empty>
136401,BLOCK,-1,,<empty>,,,,3,,<empty>
136408,BLOCK,-1,,<empty>,,,,4,,<empty>
136415,BLOCK,-1,,<empty>,,,,4,,<empty>
136423,BLOCK,-1,,<empty>,,,,5,,<empty>
136429,BLOCK,-1,,<empty>,,,,3,,<empty>
136444,BLOCK,-1,,<empty>,,,,12,,<empty>
136450,BLOCK,-1,,<empty>,,,,3,,<empty>
136457,BLOCK,-1,,<empty>,,,,4,,<empty>
136462,BLOCK,-1,,<empty>,,,,2,,<empty>
136468,BLOCK,-1,,<empty>,,,,3,,<empty>
136474,BLOCK,-1,,<empty>,,,,3,,<empty>
136480,BLOCK,-1,,<empty>,,,,3,,<empty>
136488,BLOCK,-1,,<empty>,,,,5,,<empty>
136493,BLOCK,-1,,<empty>,,,,2,,<empty>
136510,BLOCK,-1,,<empty>,1,,1,1,,ANY
136516,BLOCK,-1,,<empty>,,,,4,,<empty>
136520,BLOCK,-1,,<empty>,,,,1,,<empty>
136527,BLOCK,-1,,<empty>,,,,4,,<empty>
136534,BLOCK,-1,,<empty>,,,,4,,<empty>
136539,BLOCK,-1,,<empty>,,,,2,,<empty>
136543,BLOCK,-1,,<empty>,,,,1,,<empty>
136548,BLOCK,-1,,<empty>,,,,2,,<empty>
136553,BLOCK,-1,,<empty>,,,,2,,<empty>
136557,BLOCK,-1,,<empty>,,,,1,,<empty>
136561,BLOCK,-1,,"{
    return node::Environment::GetCurrent(context());
  }",46,,30,1,,void
136573,BLOCK,-1,,{ return filename.c_str(); },42,,33,1,,void
136585,BLOCK,-1,,<empty>,,,,1,,<empty>
136601,BLOCK,-1,,<empty>,1,,1,1,,ANY
136611,BLOCK,-1,,<empty>,,,,3,,<empty>
136618,BLOCK,-1,,<empty>,,,,4,,<empty>
136630,BLOCK,-1,,"{
    static Mutex dlib_load_mutex;
    Mutex::ScopedLock lock(dlib_load_mutex);

    const bool is_opened = dlib->Open();

    // Objects containing v14 or later modules will have registered themselves
    // on the pending list.  Activate all of them now.  At present, only one
    // module per object is supported.
    node_module* mp = thread_local_modpending;
    thread_local_modpending = nullptr;

    if (!is_opened) {
      std::string errmsg = dlib->errmsg_.c_str();
      dlib->Close();
#ifdef _WIN32
      // Windows needs to add the filename into the error message
      errmsg += *filename;
#endif  // _WIN32
      THROW_ERR_DLOPEN_FAILED(env, ""%s"", errmsg.c_str());
      return false;
    }

    if (mp != nullptr) {
      if (mp->nm_context_register_func == nullptr) {
        if (env->force_context_aware()) {
          dlib->Close();
          THROW_ERR_NON_CONTEXT_AWARE_DISABLED(env);
          return false;
        }
      }
      mp->nm_dso_handle = dlib->handle_;
      d...",55,,455,2,,void
136652,BLOCK,-1,,"{
      std::string errmsg = dlib->errmsg_.c_str();
      dlib->Close();
#ifdef _WIN32
      // Windows needs to add the filename into the error message
      errmsg += *filename;
#endif  // _WIN32
      THROW_ERR_DLOPEN_FAILED(env, ""%s"", errmsg.c_str());
      return false;
    }",21,,467,2,,void
136679,BLOCK,-1,,"{
      if (mp->nm_context_register_func == nullptr) {
        if (env->force_context_aware()) {
          dlib->Close();
          THROW_ERR_NON_CONTEXT_AWARE_DISABLED(env);
          return false;
        }
      }
      mp->nm_dso_handle = dlib->handle_;
      dlib->SaveInGlobalHandleMap(mp);
    }",24,,478,2,,void
136686,BLOCK,-1,,"{
        if (env->force_context_aware()) {
          dlib->Close();
          THROW_ERR_NON_CONTEXT_AWARE_DISABLED(env);
          return false;
        }
      }",52,,479,2,,void
136692,BLOCK,-1,,"{
          dlib->Close();
          THROW_ERR_NON_CONTEXT_AWARE_DISABLED(env);
          return false;
        }",41,,480,2,,void
136714,BLOCK,-1,,"{
      if (auto callback = GetInitializerCallback(dlib)) {
        callback(exports, module, context);
        return true;
      } else if (auto napi_callback = GetNapiInitializerCallback(dlib)) {
        int32_t module_api_version = NODE_API_DEFAULT_MODULE_API_VERSION;
        if (auto get_version = GetNapiAddonGetApiVersionCallback(dlib)) {
          module_api_version = get_version();
        }
        napi_module_register_by_symbol(
            exports, module, context, napi_callback, module_api_version);
        return true;
      } else {
        mp = dlib->GetSavedModuleFromGlobalHandleMap();
        if (mp == nullptr || mp->nm_context_register_func == nullptr) {
          dlib->Close();
          THROW_ERR_DLOPEN_FAILED(
              env, ""Module did not self-register: '%s'."", *filename);
          return false;
        }
      }
    }",12,,488,1,,void
136716,BLOCK,-1,,<empty>,11,,489,1,,void
136722,BLOCK,-1,,"{
        callback(exports, module, context);
        return true;
      }",57,,489,2,,void
136730,BLOCK,-1,,<empty>,14,,492,1,,void
136732,BLOCK,-1,,<empty>,18,,492,1,,void
136738,BLOCK,-1,,"{
        int32_t module_api_version = NODE_API_DEFAULT_MODULE_API_VERSION;
        if (auto get_version = GetNapiAddonGetApiVersionCallback(dlib)) {
          module_api_version = get_version();
        }
        napi_module_register_by_symbol(
            exports, module, context, napi_callback, module_api_version);
        return true;
      }",73,,492,2,,void
136744,BLOCK,-1,,<empty>,13,,494,1,,void
136750,BLOCK,-1,,"{
          module_api_version = get_version();
        }",73,,494,2,,void
136763,BLOCK,-1,,"{
        mp = dlib->GetSavedModuleFromGlobalHandleMap();
        if (mp == nullptr || mp->nm_context_register_func == nullptr) {
          dlib->Close();
          THROW_ERR_DLOPEN_FAILED(
              env, ""Module did not self-register: '%s'."", *filename);
          return false;
        }
      }",14,,500,1,,void
136780,BLOCK,-1,,"{
          dlib->Close();
          THROW_ERR_DLOPEN_FAILED(
              env, ""Module did not self-register: '%s'."", *filename);
          return false;
        }",71,,502,2,,void
136805,BLOCK,-1,,"{
      // Even if the module did self-register, it may have done so with the
      // wrong version. We must only give up after having checked to see if it
      // has an appropriate initializer callback.
      if (auto callback = GetInitializerCallback(dlib)) {
        callback(exports, module, context);
        return true;
      }

      const int actual_nm_version = mp->nm_version;
      // NOTE: `mp` is allocated inside of the shared library's memory, calling
      // `dlclose` will deallocate it
      dlib->Close();
      THROW_ERR_DLOPEN_FAILED(
          env,
          ""The module '%s'""
          ""\nwas compiled against a different Node.js version using""
          ""\nNODE_MODULE_VERSION %d. This version of Node.js requires""
          ""\nNODE_MODULE_VERSION %d. Please try re-compiling or ""
          ""re-installing\nthe module (for instance, using `npm rebuild` ""
          ""or `npm install`)."",
          *filename,
          actual_nm_version,
          NODE_MODULE_VERSION);...",76,,512,2,,void
136807,BLOCK,-1,,<empty>,11,,516,1,,void
136813,BLOCK,-1,,"{
        callback(exports, module, context);
        return true;
      }",57,,516,2,,void
136855,BLOCK,-1,,"{
      mp->nm_context_register_func(exports, module, context, mp->nm_priv);
    }",50,,542,2,,void
136867,BLOCK,-1,,<empty>,12,,544,1,,void
136874,BLOCK,-1,,"{
      mp->nm_register_func(exports, module, mp->nm_priv);
    }",49,,544,2,,void
136885,BLOCK,-1,,"{
      dlib->Close();
      THROW_ERR_DLOPEN_FAILED(env, ""Module has no declared entry point."");
      return false;
    }",12,,546,1,,void
136923,BLOCK,-1,,<empty>,1,,1,1,,ANY
136925,BLOCK,-1,,<empty>,,,,1,,<empty>
136929,BLOCK,-1,,<empty>,,,,1,,<empty>
136933,BLOCK,-1,,<empty>,,,,1,,<empty>
136937,BLOCK,-1,,<empty>,,,,1,,<empty>
136941,BLOCK,-1,,<empty>,,,,1,,<empty>
136945,BLOCK,-1,,<empty>,,,,1,,<empty>
136949,BLOCK,-1,,<empty>,,,,1,,<empty>
136953,BLOCK,-1,,<empty>,,,,1,,<empty>
136957,BLOCK,-1,,<empty>,,,,1,,<empty>
136961,BLOCK,-1,,<empty>,,,,1,,<empty>
136965,BLOCK,-1,,<empty>,,,,1,,<empty>
136969,BLOCK,-1,,<empty>,,,,1,,<empty>
136973,BLOCK,-1,,<empty>,,,,1,,<empty>
136977,BLOCK,-1,,<empty>,,,,1,,<empty>
136981,BLOCK,-1,,<empty>,,,,1,,<empty>
136985,BLOCK,-1,,<empty>,,,,1,,<empty>
136989,BLOCK,-1,,<empty>,,,,1,,<empty>
136993,BLOCK,-1,,<empty>,,,,1,,<empty>
136997,BLOCK,-1,,<empty>,,,,1,,<empty>
137001,BLOCK,-1,,<empty>,,,,1,,<empty>
137005,BLOCK,-1,,<empty>,,,,1,,<empty>
137009,BLOCK,-1,,<empty>,,,,1,,<empty>
137013,BLOCK,-1,,<empty>,,,,1,,<empty>
137017,BLOCK,-1,,<empty>,,,,1,,<empty>
137021,BLOCK,-1,,<empty>,,,,1,,<empty>
137025,BLOCK,-1,,<empty>,,,,1,,<empty>
137029,BLOCK,-1,,<empty>,,,,1,,<empty>
137033,BLOCK,-1,,<empty>,,,,1,,<empty>
137037,BLOCK,-1,,<empty>,,,,1,,<empty>
137041,BLOCK,-1,,<empty>,,,,1,,<empty>
137045,BLOCK,-1,,<empty>,,,,1,,<empty>
137049,BLOCK,-1,,<empty>,,,,1,,<empty>
137053,BLOCK,-1,,<empty>,,,,1,,<empty>
137057,BLOCK,-1,,<empty>,,,,1,,<empty>
137061,BLOCK,-1,,<empty>,,,,1,,<empty>
137065,BLOCK,-1,,<empty>,,,,1,,<empty>
137069,BLOCK,-1,,<empty>,,,,1,,<empty>
137073,BLOCK,-1,,<empty>,,,,1,,<empty>
137077,BLOCK,-1,,<empty>,,,,1,,<empty>
137081,BLOCK,-1,,<empty>,,,,1,,<empty>
137085,BLOCK,-1,,<empty>,,,,1,,<empty>
137089,BLOCK,-1,,<empty>,,,,1,,<empty>
137093,BLOCK,-1,,<empty>,,,,1,,<empty>
137097,BLOCK,-1,,<empty>,,,,1,,<empty>
137101,BLOCK,-1,,<empty>,,,,1,,<empty>
137105,BLOCK,-1,,<empty>,,,,1,,<empty>
137109,BLOCK,-1,,<empty>,,,,1,,<empty>
137113,BLOCK,-1,,<empty>,,,,1,,<empty>
137117,BLOCK,-1,,<empty>,,,,1,,<empty>
137121,BLOCK,-1,,<empty>,,,,1,,<empty>
137125,BLOCK,-1,,<empty>,,,,1,,<empty>
137129,BLOCK,-1,,<empty>,,,,1,,<empty>
137133,BLOCK,-1,,<empty>,,,,1,,<empty>
137137,BLOCK,-1,,<empty>,,,,1,,<empty>
137141,BLOCK,-1,,<empty>,,,,1,,<empty>
137157,BLOCK,-1,,"{
  struct node_module* mp = reinterpret_cast<struct node_module*>(m);

  if (mp->nm_flags & NM_F_INTERNAL) {
    mp->nm_link = modlist_internal;
    modlist_internal = mp;
  } else if (!node_is_initialized) {
    // ""Linked"" modules are included as part of the node project.
    // Like builtins they are registered *before* node::Init runs.
    mp->nm_flags = NM_F_LINKED;
    mp->nm_link = modlist_linked;
    modlist_linked = mp;
  } else {
    thread_local_modpending = mp;
  }
}",47,,254,2,,void
137170,BLOCK,-1,,"{
    mp->nm_link = modlist_internal;
    modlist_internal = mp;
  }",37,,257,2,,void
137180,BLOCK,-1,,<empty>,10,,260,1,,void
137184,BLOCK,-1,,"{
    // ""Linked"" modules are included as part of the node project.
    // Like builtins they are registered *before* node::Init runs.
    mp->nm_flags = NM_F_LINKED;
    mp->nm_link = modlist_linked;
    modlist_linked = mp;
  }",36,,260,2,,void
137199,BLOCK,-1,,"{
    thread_local_modpending = mp;
  }",10,,266,1,,void
137210,BLOCK,-1,,"{
    CHECK_NE(handle, nullptr);
    Mutex::ScopedLock lock(mutex_);

    map_[handle].module = mod;
    // We need to store this flag internally to avoid a chicken-and-egg problem
    // during cleanup. By the time we actually use the flag's value,
    // the shared object has been unloaded, and its memory would be gone,
    // making it impossible to access fields of `mod` --
    // unless `mod` *is* dynamically allocated, but we cannot know that
    // without checking the flag.
    map_[handle].wants_delete_module = mod->nm_flags & NM_F_DELETEME;
    map_[handle].refcount++;
  }",44,,275,3,,void
137245,BLOCK,-1,,"{
    CHECK_NE(handle, nullptr);
    Mutex::ScopedLock lock(mutex_);

    auto it = map_.find(handle);
    if (it == map_.end()) return nullptr;
    it->second.refcount++;
    return it->second.module;
  }",56,,290,2,,void
137267,BLOCK,-1,,<empty>,27,,295,2,,void
137286,BLOCK,-1,,"{
    CHECK_NE(handle, nullptr);
    Mutex::ScopedLock lock(mutex_);

    auto it = map_.find(handle);
    if (it == map_.end()) return;
    CHECK_GE(it->second.refcount, 1);
    if (--it->second.refcount == 0) {
      if (it->second.wants_delete_module)
        delete it->second.module;
      map_.erase(handle);
    }
  }",28,,300,2,,void
137308,BLOCK,-1,,<empty>,27,,305,2,,void
137326,BLOCK,-1,,"{
      if (it->second.wants_delete_module)
        delete it->second.module;
      map_.erase(handle);
    }",37,,307,2,,void
137333,BLOCK,-1,,<empty>,9,,309,2,,void
137357,BLOCK,-1,,<empty>,60,,325,3,,void
137361,BLOCK,-1,,"{
  int ret = uv_dlopen(filename_.c_str(), &lib_);
  if (ret == 0) {
    handle_ = static_cast<void*>(lib_.handle);
    return true;
  }
  errmsg_ = uv_dlerror(&lib_);
  uv_dlclose(&lib_);
  return false;
}",19,,359,1,,void
137376,BLOCK,-1,,"{
    handle_ = static_cast<void*>(lib_.handle);
    return true;
  }",17,,361,2,,void
137397,BLOCK,-1,,"{
  if (handle_ == nullptr) return;
  if (has_entry_in_global_handle_map_)
    global_handle_map.erase(handle_);
  uv_dlclose(&lib_);
  handle_ = nullptr;
}",20,,370,1,,void
137402,BLOCK,-1,,<empty>,27,,371,2,,void
137406,BLOCK,-1,,<empty>,5,,373,2,,void
137420,BLOCK,-1,,"{
  void* address;
  if (0 == uv_dlsym(&lib_, name, &address)) return address;
  return nullptr;
}",48,,378,2,,void
137431,BLOCK,-1,,<empty>,45,,380,2,,void
137440,BLOCK,-1,,"{
  has_entry_in_global_handle_map_ = true;
  global_handle_map.set(handle_, mp);
}",51,,385,2,,void
137453,BLOCK,-1,,"{
  has_entry_in_global_handle_map_ = true;
  return global_handle_map.get_and_increase_refcount(handle_);
}",56,,390,1,,void
137468,BLOCK,-1,,"{
  const char* name = ""node_register_module_v"" STRINGIFY(NODE_MODULE_VERSION);
  return reinterpret_cast<InitializerCallback>(dlib->GetSymbolAddress(name));
}",63,,399,2,,void
137487,BLOCK,-1,,"{
  const char* name =
      STRINGIFY(NAPI_MODULE_INITIALIZER_BASE) STRINGIFY(NAPI_MODULE_VERSION);
  return reinterpret_cast<napi_addon_register_func>(
      dlib->GetSymbolAddress(name));
}",72,,404,2,,void
137507,BLOCK,-1,,"{
  return reinterpret_cast<node_api_addon_get_api_version_func>(
      dlib->GetSymbolAddress(STRINGIFY(NODE_API_MODULE_GET_API_VERSION)));
}",17,,412,2,,void
137521,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  if (env->no_native_addons()) {
    return THROW_ERR_DLOPEN_DISABLED(
      env, ""Cannot load native addon because loading addons is disabled."");
  }

  auto context = env->context();

  CHECK_NULL(thread_local_modpending);

  if (args.Length() < 2) {
    return THROW_ERR_MISSING_ARGS(
        env, ""process.dlopen needs at least 2 arguments"");
  }

  int32_t flags = DLib::kDefaultFlags;
  if (args.Length() > 2 && !args[2]->Int32Value(context).To(&flags)) {
    return THROW_ERR_INVALID_ARG_TYPE(env, ""flag argument must be an integer."");
  }

  Local<Object> module;
  Local<Object> exports;
  Local<Value> exports_v;
  if (!args[0]->ToObject(context).ToLocal(&module) ||
      !module->Get(context, env->exports_string()).ToLocal(&exports_v) ||
      !exports_v->ToObject(context).ToLocal(&exports)) {
    return;  // Exception pending.
  }

  node::Utf8Value filename(env->isolate(), args[1]);  // Cast
  env->TryLoadAddon(*filename, f...",54,,423,2,,void
137534,BLOCK,-1,,"{
    return THROW_ERR_DLOPEN_DISABLED(
      env, ""Cannot load native addon because loading addons is disabled."");
  }",32,,426,2,,void
137554,BLOCK,-1,,"{
    return THROW_ERR_MISSING_ARGS(
        env, ""process.dlopen needs at least 2 arguments"");
  }",26,,435,2,,void
137586,BLOCK,-1,,"{
    return THROW_ERR_INVALID_ARG_TYPE(env, ""flag argument must be an integer."");
  }",70,,441,2,,void
137648,BLOCK,-1,,"{
    return;  // Exception pending.
  }",56,,450,2,,void
137672,BLOCK,-1,,"{
  struct node_module* mp;

  for (mp = list; mp != nullptr; mp = mp->nm_link) {
    if (strcmp(mp->nm_modname, name) == 0) break;
  }

  CHECK(mp == nullptr || (mp->nm_flags & flag) != 0);
  return mp;
}",49,,561,4,,void
137675,BLOCK,-1,,<empty>,3,,564,1,,void
137687,BLOCK,4,,"{
    if (strcmp(mp->nm_modname, name) == 0) break;
  }",52,,564,4,,void
137696,BLOCK,-1,,<empty>,44,,565,2,,void
137716,BLOCK,-1,,"{
#define V(modname)                                                             \
  do {                                                                         \
    Local<FunctionTemplate> templ =                                            \
        FunctionTemplate::New(isolate_data->isolate());                        \
    templ->InstanceTemplate()->SetInternalFieldCount(                          \
        BaseObject::kInternalFieldCount);                                      \
    _register_isolate_##modname(isolate_data, templ);                          \
    isolate_data->set_##modname##_binding(templ);                              \
  } while (0);
  NODE_BINDINGS_WITH_PER_ISOLATE_INIT(V)
#undef V
}",64,,572,2,,void
137725,BLOCK,-1,,"{
  Local<FunctionTemplate> ctor;
#define V(name)                                                                \
  if (strcmp(mod_name, #name) == 0) {                                          \
    ctor = isolate_data->name##_binding();                                     \
  } else  // NOLINT(readability/braces)
  NODE_BINDINGS_WITH_PER_ISOLATE_INIT(V)
#undef V
  {
    ctor = isolate_data->binding_data_ctor_template();
  }

  Local<Object> obj = ctor->GetFunction(context)
                          .ToLocalChecked()
                          ->NewInstance(context)
                          .ToLocalChecked();
  return obj;
}",77,,588,4,,void
137734,BLOCK,4,,"{
    ctor = isolate_data->binding_data_ctor_template();
  }",3,,596,4,,void
137769,BLOCK,-1,,"{
  EscapableHandleScope scope(realm->isolate());
  Local<Context> context = realm->context();
  Local<Object> exports = GetInternalBindingExportObject(
      realm->isolate_data(), mod->nm_modname, context);
  CHECK_NULL(mod->nm_register_func);
  CHECK_NOT_NULL(mod->nm_context_register_func);
  Local<Value> unused = Undefined(realm->isolate());
  // Internal bindings don't have a ""module"" object, only exports.
  mod->nm_context_register_func(exports, unused, context, mod->nm_priv);
  return scope.Escape(exports);
}",74,,607,3,,void
137840,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(args);
  Isolate* isolate = realm->isolate();
  HandleScope scope(isolate);
  Local<Context> context = realm->context();

  CHECK(args[0]->IsString());

  Local<String> module = args[0].As<String>();
  node::Utf8Value module_v(isolate, module);
  Local<Object> exports;

  node_module* mod = FindModule(modlist_internal, *module_v, NM_F_INTERNAL);
  if (mod != nullptr) {
    exports = InitInternalBinding(realm, mod);
    realm->internal_bindings.insert(mod);
  } else if (!strcmp(*module_v, ""constants"")) {
    exports = Object::New(isolate);
    CHECK(exports->SetPrototype(context, Null(isolate)).FromJust());
    DefineConstants(isolate, exports);
  } else if (!strcmp(*module_v, ""natives"")) {
    exports = realm->env()->builtin_loader()->GetSourceObject(context);
    // Legacy feature: process.binding('natives').config contains stringified
    // config.gypi
    CHECK(exports
              ->Set(context,
                    realm->isolate_data()->co...",66,,620,2,,void
137909,BLOCK,-1,,"{
    exports = InitInternalBinding(realm, mod);
    realm->internal_bindings.insert(mod);
  }",23,,633,2,,void
137923,BLOCK,-1,,<empty>,10,,636,1,,void
137930,BLOCK,-1,,"{
    exports = Object::New(isolate);
    CHECK(exports->SetPrototype(context, Null(isolate)).FromJust());
    DefineConstants(isolate, exports);
  }",47,,636,2,,void
137953,BLOCK,-1,,<empty>,10,,640,1,,void
137960,BLOCK,-1,,"{
    exports = realm->env()->builtin_loader()->GetSourceObject(context);
    // Legacy feature: process.binding('natives').config contains stringified
    // config.gypi
    CHECK(exports
              ->Set(context,
                    realm->isolate_data()->config_string(),
                    realm->env()->builtin_loader()->GetConfigString(isolate))
              .FromJust());
  }",45,,640,2,,void
138002,BLOCK,-1,,"{
    return THROW_ERR_INVALID_MODULE(isolate, ""No such binding: %s"", *module_v);
  }",10,,649,1,,void
138021,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsString());

  Local<String> module_name = args[0].As<String>();

  node::Utf8Value module_name_v(env->isolate(), module_name);
  const char* name = *module_name_v;
  node_module* mod = nullptr;

  // Iterate from here to the nearest non-Worker Environment to see if there's
  // a linked binding defined locally rather than through the global list.
  Environment* cur_env = env;
  while (mod == nullptr && cur_env != nullptr) {
    Mutex::ScopedLock lock(cur_env->extra_linked_bindings_mutex());
    mod = FindModule(cur_env->extra_linked_bindings_head(), name, NM_F_LINKED);
    cur_env = cur_env->worker_parent_env();
  }

  if (mod == nullptr)
    mod = FindModule(modlist_linked, name, NM_F_LINKED);

  if (mod == nullptr) {
    return THROW_ERR_INVALID_MODULE(
        env, ""No such binding was linked: %s"", *module_name_v);
  }

  Local<Object> module = Object::New(env->isolate());
  Local<Object> exports = Object::...",64,,656,2,,void
138077,BLOCK,-1,,"{
    Mutex::ScopedLock lock(cur_env->extra_linked_bindings_mutex());
    mod = FindModule(cur_env->extra_linked_bindings_head(), name, NM_F_LINKED);
    cur_env = cur_env->worker_parent_env();
  }",48,,670,2,,void
138103,BLOCK,-1,,<empty>,5,,677,2,,void
138114,BLOCK,-1,,"{
    return THROW_ERR_INVALID_MODULE(
        env, ""No such binding was linked: %s"", *module_name_v);
  }",23,,679,2,,void
138183,BLOCK,-1,,"{
    mod->nm_context_register_func(
        exports, module, env->context(), mod->nm_priv);
  }",49,,690,2,,void
138198,BLOCK,-1,,<empty>,10,,693,1,,void
138205,BLOCK,-1,,"{
    mod->nm_register_func(exports, module, mod->nm_priv);
  }",48,,693,2,,void
138216,BLOCK,-1,,"{
    return THROW_ERR_INVALID_MODULE(
        env, ""Linked binding has no declared entry point."");
  }",10,,695,1,,void
138247,BLOCK,-1,,"{
#define V(modname) _register_##modname();
  NODE_BUILTIN_BINDINGS(V)
#undef V
}",32,,708,1,,void
138249,BLOCK,1,,<empty>,,,,1,,void
138252,BLOCK,1,,<empty>,,,,1,,void
138313,BLOCK,-1,,"{
  registry->Register(GetLinkedBinding);
  registry->Register(GetInternalBinding);
}",70,,714,2,,void
138339,BLOCK,-1,,<empty>,1,,1,1,,ANY
138345,BLOCK,-1,,"{
      if (buf->IsDetachable()) {
        std::shared_ptr<BackingStore> store = buf->GetBackingStore();
        USE(buf->Detach(Local<Value>()));
        return DataQueue::CreateInMemoryEntryFromBackingStore(
            store, byte_offset, byte_length);
      }

      // If the ArrayBuffer is not detachable, we will copy from it instead.
      std::shared_ptr<BackingStore> store =
          ArrayBuffer::NewBackingStore(env->isolate(), byte_length);
      uint8_t* ptr = static_cast<uint8_t*>(buf->Data()) + byte_offset;
      std::copy(ptr, ptr + byte_length, static_cast<uint8_t*>(store->Data()));
      return DataQueue::CreateInMemoryEntryFromBackingStore(
          store, 0, byte_length);
    }",69,,182,4,,void
138351,BLOCK,-1,,"{
        std::shared_ptr<BackingStore> store = buf->GetBackingStore();
        USE(buf->Detach(Local<Value>()));
        return DataQueue::CreateInMemoryEntryFromBackingStore(
            store, byte_offset, byte_length);
      }",32,,183,2,,void
138438,BLOCK,-1,,"{
    auto dropMe = std::unique_ptr<Impl>(impl);
    Environment* env = impl->env;
    HandleScope handleScope(env->isolate());
    Local<Function> fn = impl->callback.Get(env->isolate());

    if (status == bob::STATUS_EOS) impl->reader->eos_ = true;

    if (count > 0) {
      // Copy the returns vectors into a single ArrayBuffer.
      size_t total = 0;
      for (size_t n = 0; n < count; n++) total += vecs[n].len;

      std::shared_ptr<BackingStore> store =
          v8::ArrayBuffer::NewBackingStore(env->isolate(), total);
      auto ptr = static_cast<uint8_t*>(store->Data());
      for (size_t n = 0; n < count; n++) {
        std::copy(vecs[n].base, vecs[n].base + vecs[n].len, ptr);
        ptr += vecs[n].len;
      }
      // Since we copied the data buffers, signal that we're done with them.
      std::move(doneCb)(0);
      Local<Value> argv[2] = {Uint32::New(env->isolate(), status),
                              ArrayBuffer::New(env->isolate(), store)};
      impl->reader-...",48,,339,5,,void
138483,BLOCK,-1,,<empty>,36,,345,2,,void
138495,BLOCK,-1,,"{
      // Copy the returns vectors into a single ArrayBuffer.
      size_t total = 0;
      for (size_t n = 0; n < count; n++) total += vecs[n].len;

      std::shared_ptr<BackingStore> store =
          v8::ArrayBuffer::NewBackingStore(env->isolate(), total);
      auto ptr = static_cast<uint8_t*>(store->Data());
      for (size_t n = 0; n < count; n++) {
        std::copy(vecs[n].base, vecs[n].base + vecs[n].len, ptr);
        ptr += vecs[n].len;
      }
      // Since we copied the data buffers, signal that we're done with them.
      std::move(doneCb)(0);
      Local<Value> argv[2] = {Uint32::New(env->isolate(), status),
                              ArrayBuffer::New(env->isolate(), store)};
      impl->reader->MakeCallback(fn, arraysize(argv), argv);
      return;
    }",20,,347,2,,void
138501,BLOCK,-1,,<empty>,7,,350,1,,void
138547,BLOCK,-1,,<empty>,7,,355,1,,void
138557,BLOCK,4,,"{
        std::copy(vecs[n].base, vecs[n].base + vecs[n].len, ptr);
        ptr += vecs[n].len;
      }",42,,355,4,,void
138662,BLOCK,-1,,<empty>,1,,1,1,,ANY
138667,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsArray());
  Local<Array> array = args[0].As<Array>();

  struct View {
    std::shared_ptr<BackingStore> store;
    size_t length;
    size_t offset = 0;
  };

  std::vector<View> views;
  size_t total = 0;

  for (uint32_t n = 0; n < array->Length(); n++) {
    Local<Value> val;
    if (!array->Get(env->context(), n).ToLocal(&val)) return;
    if (val->IsArrayBuffer()) {
      auto ab = val.As<ArrayBuffer>();
      views.push_back(View{ab->GetBackingStore(), ab->ByteLength(), 0});
      total += ab->ByteLength();
    } else {
      CHECK(val->IsArrayBufferView());
      auto view = val.As<ArrayBufferView>();
      views.push_back(View{view->Buffer()->GetBackingStore(),
                           view->ByteLength(),
                           view->ByteOffset()});
      total += view->ByteLength();
    }
  }

  std::shared_ptr<BackingStore> store =
      ArrayBuffer::NewBackingStore(env->isolate(), total);
  ui...",54,,42,2,,void
138701,BLOCK,-1,,<empty>,3,,56,1,,void
138714,BLOCK,4,,"{
    Local<Value> val;
    if (!array->Get(env->context(), n).ToLocal(&val)) return;
    if (val->IsArrayBuffer()) {
      auto ab = val.As<ArrayBuffer>();
      views.push_back(View{ab->GetBackingStore(), ab->ByteLength(), 0});
      total += ab->ByteLength();
    } else {
      CHECK(val->IsArrayBufferView());
      auto view = val.As<ArrayBufferView>();
      views.push_back(View{view->Buffer()->GetBackingStore(),
                           view->ByteLength(),
                           view->ByteOffset()});
      total += view->ByteLength();
    }
  }",50,,56,4,,void
138736,BLOCK,-1,,<empty>,55,,58,2,,void
138743,BLOCK,-1,,"{
      auto ab = val.As<ArrayBuffer>();
      views.push_back(View{ab->GetBackingStore(), ab->ByteLength(), 0});
      total += ab->ByteLength();
    }",31,,59,2,,void
138773,BLOCK,-1,,"{
      CHECK(val->IsArrayBufferView());
      auto view = val.As<ArrayBufferView>();
      views.push_back(View{view->Buffer()->GetBackingStore(),
                           view->ByteLength(),
                           view->ByteOffset()});
      total += view->ByteLength();
    }",12,,63,1,,void
138840,BLOCK,-1,,<empty>,3,,76,1,,void
138853,BLOCK,4,,"{
    uint8_t* from =
        static_cast<uint8_t*>(views[n].store->Data()) + views[n].offset;
    std::copy(from, from + views[n].length, ptr);
    ptr += views[n].length;
  }",45,,76,4,,void
138917,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  auto entry = DataQueue::CreateFdEntry(env, args[0]);
  if (entry == nullptr) {
    return THROW_ERR_INVALID_ARG_VALUE(env, ""Unabled to open file as blob"");
  }

  std::vector<std::unique_ptr<DataQueue::Entry>> entries;
  entries.push_back(std::move(entry));

  auto blob =
      Blob::Create(env, DataQueue::CreateIdempotent(std::move(entries)));

  if (blob) {
    auto array = Array::New(env->isolate(), 2);
    USE(array->Set(env->context(), 0, blob->object()));
    USE(array->Set(env->context(),
                   1,
                   Uint32::NewFromUnsigned(env->isolate(), blob->length())));

    args.GetReturnValue().Set(array);
  }
}",64,,86,2,,void
138941,BLOCK,-1,,"{
    return THROW_ERR_INVALID_ARG_VALUE(env, ""Unabled to open file as blob"");
  }",25,,89,2,,void
138987,BLOCK,-1,,"{
    auto array = Array::New(env->isolate(), 2);
    USE(array->Set(env->context(), 0, blob->object()));
    USE(array->Set(env->context(),
                   1,
                   Uint32::NewFromUnsigned(env->isolate(), blob->length())));

    args.GetReturnValue().Set(array);
  }",13,,99,2,,void
139049,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();
  Local<ObjectTemplate> target = ctor->InstanceTemplate();

  SetMethod(isolate, target, ""createBlob"", New);
  SetMethod(isolate, target, ""storeDataObject"", StoreDataObject);
  SetMethod(isolate, target, ""getDataObject"", GetDataObject);
  SetMethod(isolate, target, ""revokeObjectURL"", RevokeObjectURL);
  SetMethod(isolate, target, ""concat"", Concat);
  SetMethod(isolate, target, ""createBlobFromFilePath"", BlobFromFilePath);
}",69,,112,3,,void
139104,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(context);
  realm->AddBindingData<BlobBindingData>(context, target);
}",51,,127,5,,void
139127,BLOCK,-1,,"{
  Local<FunctionTemplate> tmpl = env->blob_constructor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        BaseObject::kInternalFieldCount);
    tmpl->SetClassName(
        FIXED_ONE_BYTE_STRING(env->isolate(), ""Blob""));
    SetProtoMethod(isolate, tmpl, ""getReader"", GetReader);
    SetProtoMethod(isolate, tmpl, ""slice"", ToSlice);
    env->set_blob_constructor_template(tmpl);
  }
  return tmpl;
}",72,,132,2,,void
139143,BLOCK,-1,,"{
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        BaseObject::kInternalFieldCount);
    tmpl->SetClassName(
        FIXED_ONE_BYTE_STRING(env->isolate(), ""Blob""));
    SetProtoMethod(isolate, tmpl, ""getReader"", GetReader);
    SetProtoMethod(isolate, tmpl, ""slice"", ToSlice);
    env->set_blob_constructor_template(tmpl);
  }",23,,134,2,,void
139198,BLOCK,-1,,"{
  return GetConstructorTemplate(env)->HasInstance(object);
}",71,,148,3,,void
139211,BLOCK,-1,,"{
  HandleScope scope(env->isolate());

  Local<Function> ctor;
  if (!GetConstructorTemplate(env)->GetFunction(env->context()).ToLocal(&ctor))
    return BaseObjectPtr<Blob>();

  Local<Object> obj;
  if (!ctor->NewInstance(env->context()).ToLocal(&obj))
    return BaseObjectPtr<Blob>();

  return MakeBaseObject<Blob>(env, obj, data_queue);
}",73,,153,3,,void
139239,BLOCK,-1,,<empty>,5,,158,2,,void
139262,BLOCK,-1,,<empty>,5,,162,2,,void
139279,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsArray());  // sources

  Local<Array> array = args[0].As<Array>();
  std::vector<std::unique_ptr<DataQueue::Entry>> entries(array->Length());

  for (size_t i = 0; i < array->Length(); i++) {
    Local<Value> entry;
    if (!array->Get(env->context(), i).ToLocal(&entry)) {
      return;
    }

    const auto entryFromArrayBuffer = [env](v8::Local<v8::ArrayBuffer> buf,
                                            size_t byte_length,
                                            size_t byte_offset = 0) {
      if (buf->IsDetachable()) {
        std::shared_ptr<BackingStore> store = buf->GetBackingStore();
        USE(buf->Detach(Local<Value>()));
        return DataQueue::CreateInMemoryEntryFromBackingStore(
            store, byte_offset, byte_length);
      }

      // If the ArrayBuffer is not detachable, we will copy from it instead.
      std::shared_ptr<BackingStore> store =
          ArrayBuffer::NewBackingSt...",57,,167,2,,void
139324,BLOCK,-1,,<empty>,3,,174,1,,void
139337,BLOCK,4,,"{
    Local<Value> entry;
    if (!array->Get(env->context(), i).ToLocal(&entry)) {
      return;
    }

    const auto entryFromArrayBuffer = [env](v8::Local<v8::ArrayBuffer> buf,
                                            size_t byte_length,
                                            size_t byte_offset = 0) {
      if (buf->IsDetachable()) {
        std::shared_ptr<BackingStore> store = buf->GetBackingStore();
        USE(buf->Detach(Local<Value>()));
        return DataQueue::CreateInMemoryEntryFromBackingStore(
            store, byte_offset, byte_length);
      }

      // If the ArrayBuffer is not detachable, we will copy from it instead.
      std::shared_ptr<BackingStore> store =
          ArrayBuffer::NewBackingStore(env->isolate(), byte_length);
      uint8_t* ptr = static_cast<uint8_t*>(buf->Data()) + byte_offset;
      std::copy(ptr, ptr + byte_length, static_cast<uint8_t*>(store->Data()));
      return DataQueue::CreateInMemoryEntryFromBackingStore(
          store, 0...",48,,174,4,,void
139359,BLOCK,-1,,"{
      return;
    }",57,,176,2,,void
139370,BLOCK,-1,,"{
      Local<ArrayBuffer> buf = entry.As<ArrayBuffer>();
      entries[i] = entryFromArrayBuffer(buf, buf->ByteLength());
    }",33,,208,2,,void
139392,BLOCK,-1,,<empty>,12,,211,1,,void
139398,BLOCK,-1,,"{
      Local<ArrayBufferView> view = entry.As<ArrayBufferView>();
      entries[i] = entryFromArrayBuffer(
          view->Buffer(), view->ByteLength(), view->ByteOffset());
    }",44,,211,2,,void
139427,BLOCK,-1,,<empty>,12,,215,1,,void
139435,BLOCK,-1,,"{
      Blob* blob;
      ASSIGN_OR_RETURN_UNWRAP(&blob, entry);
      entries[i] = DataQueue::CreateDataQueueEntry(blob->data_queue_);
    }",47,,215,2,,void
139453,BLOCK,-1,,"{
      UNREACHABLE(""Incorrect Blob initialization type"");
    }",12,,219,1,,void
139472,BLOCK,-1,,<empty>,5,,226,2,,void
139488,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Blob* blob;
  ASSIGN_OR_RETURN_UNWRAP(&blob, args.Holder());

  BaseObjectPtr<Blob::Reader> reader =
      Blob::Reader::Create(env, BaseObjectPtr<Blob>(blob));
  if (reader) args.GetReturnValue().Set(reader->object());
}",63,,229,2,,void
139527,BLOCK,-1,,<empty>,15,,236,2,,void
139543,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Blob* blob;
  ASSIGN_OR_RETURN_UNWRAP(&blob, args.Holder());
  CHECK(args[0]->IsUint32());
  CHECK(args[1]->IsUint32());
  size_t start = args[0].As<Uint32>()->Value();
  size_t end = args[1].As<Uint32>()->Value();
  BaseObjectPtr<Blob> slice = blob->Slice(env, start, end);
  if (slice)
    args.GetReturnValue().Set(slice->object());
}",61,,239,2,,void
139613,BLOCK,-1,,<empty>,5,,249,2,,void
139629,BLOCK,-1,,"{
  tracker->TrackField(""data_queue_"", data_queue_, ""std::shared_ptr<DataQueue>"");
}",53,,252,2,,void
139643,BLOCK,-1,,"{
  return Create(env,
                this->data_queue_->slice(start, static_cast<uint64_t>(end)));
}",77,,256,4,,void
139663,BLOCK,-1,,"{
  MakeWeak();
}",53,,264,4,,void
139671,BLOCK,-1,,"{
  MakeWeak();
}",42,,273,4,,void
139678,BLOCK,-1,,"{
  return GetConstructorTemplate(env)->HasInstance(value);
}",78,,277,3,,void
139690,BLOCK,-1,,"{
  Local<FunctionTemplate> tmpl = env->blob_reader_constructor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        BaseObject::kInternalFieldCount);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), ""BlobReader""));
    SetProtoMethod(env->isolate(), tmpl, ""pull"", Pull);
    env->set_blob_reader_constructor_template(tmpl);
  }
  return tmpl;
}",80,,281,2,,void
139706,BLOCK,-1,,"{
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        BaseObject::kInternalFieldCount);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), ""BlobReader""));
    SetProtoMethod(env->isolate(), tmpl, ""pull"", Pull);
    env->set_blob_reader_constructor_template(tmpl);
  }",23,,283,2,,void
139759,BLOCK,-1,,"{
  Local<Object> obj;
  if (!GetConstructorTemplate(env)
           ->InstanceTemplate()
           ->NewInstance(env->context())
           .ToLocal(&obj)) {
    return BaseObjectPtr<Blob::Reader>();
  }

  return MakeBaseObject<Blob::Reader>(env, obj, std::move(blob));
}",76,,296,3,,void
139784,BLOCK,-1,,"{
    return BaseObjectPtr<Blob::Reader>();
  }",28,,301,2,,void
139808,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Blob::Reader* reader;
  ASSIGN_OR_RETURN_UNWRAP(&reader, args.Holder());

  CHECK(args[0]->IsFunction());
  Local<Function> fn = args[0].As<Function>();
  CHECK(!fn->IsConstructor());

  if (reader->eos_) {
    Local<Value> arg = Int32::New(env->isolate(), bob::STATUS_EOS);
    reader->MakeCallback(fn, 1, &arg);
    return args.GetReturnValue().Set(bob::STATUS_EOS);
  }

  struct Impl {
    BaseObjectPtr<Blob::Reader> reader;
    Global<Function> callback;
    Environment* env;
  };
  // TODO(@jasnell): A unique_ptr is likely better here but making this a unique
  // pointer that is passed into the lambda causes the std::move(next) below to
  // complain about std::function needing to be copy-constructible.
  Impl* impl = new Impl();
  impl->reader = BaseObjectPtr<Blob::Reader>(reader);
  impl->callback.Reset(env->isolate(), fn);
  impl->env = env;

  auto next = [impl](int status,
                     const DataQueue::Vec* vec...",66,,308,2,,void
139854,BLOCK,-1,,"{
    Local<Value> arg = Int32::New(env->isolate(), bob::STATUS_EOS);
    reader->MakeCallback(fn, 1, &arg);
    return args.GetReturnValue().Set(bob::STATUS_EOS);
  }",21,,317,2,,void
139957,BLOCK,-1,,"{
  if (context != env->context()) {
    THROW_ERR_MESSAGE_TARGET_CONTEXT_UNAVAILABLE(env);
    return {};
  }
  return Blob::Create(env, data_queue);
}",49,,382,4,,void
139965,BLOCK,-1,,"{
    THROW_ERR_MESSAGE_TARGET_CONTEXT_UNAVAILABLE(env);
    return {};
  }",34,,383,2,,void
139979,BLOCK,-1,,"{
  return BaseObject::TransferMode::kCloneable;
}",56,,390,1,,void
139989,BLOCK,-1,,"{
  return std::make_unique<BlobTransferData>(data_queue_);
}",71,,394,1,,void
140002,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  BlobBindingData* binding_data = Realm::GetBindingData<BlobBindingData>(args);

  CHECK(args[0]->IsString());  // ID key
  CHECK(Blob::HasInstance(env, args[1]));  // Blob
  CHECK(args[2]->IsUint32());  // Length
  CHECK(args[3]->IsString());  // Type

  Utf8Value key(env->isolate(), args[0]);
  Blob* blob;
  ASSIGN_OR_RETURN_UNWRAP(&blob, args[1]);

  size_t length = args[2].As<Uint32>()->Value();
  Utf8Value type(env->isolate(), args[3]);

  binding_data->store_data_object(
      std::string(*key, key.length()),
      BlobBindingData::StoredDataObject(
        BaseObjectPtr<Blob>(blob),
        length,
        std::string(*type, type.length())));
}",77,,398,2,,void
140126,BLOCK,-1,,"{
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());
  BlobBindingData* binding_data = Realm::GetBindingData<BlobBindingData>(args);
  Environment* env = Environment::GetCurrent(args);
  Utf8Value input(env->isolate(), args[0].As<String>());
  auto out = ada::parse<ada::url_aggregator>(input.ToStringView());

  if (!out) {
    return;
  }

  auto pathname = out->get_pathname();
  auto start_index = pathname.find(':');

  if (start_index != std::string_view::npos && start_index != pathname.size()) {
    auto end_index = pathname.find(':', start_index + 1);
    if (end_index == std::string_view::npos) {
      auto id = std::string(pathname.substr(start_index + 1));
      binding_data->revoke_data_object(id);
    }
  }
}",69,,423,2,,void
140188,BLOCK,-1,,"{
    return;
  }",13,,431,2,,void
140220,BLOCK,-1,,"{
    auto end_index = pathname.find(':', start_index + 1);
    if (end_index == std::string_view::npos) {
      auto id = std::string(pathname.substr(start_index + 1));
      binding_data->revoke_data_object(id);
    }
  }",80,,438,2,,void
140240,BLOCK,-1,,"{
      auto id = std::string(pathname.substr(start_index + 1));
      binding_data->revoke_data_object(id);
    }",46,,440,2,,void
140264,BLOCK,-1,,"{
  BlobBindingData* binding_data = Realm::GetBindingData<BlobBindingData>(args);

  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsString());

  Utf8Value key(env->isolate(), args[0]);

  BlobBindingData::StoredDataObject stored =
      binding_data->get_data_object(std::string(*key, key.length()));
  if (stored.blob) {
    Local<Value> type;
    if (!String::NewFromUtf8(
            env->isolate(),
            stored.type.c_str(),
            v8::NewStringType::kNormal,
            static_cast<int>(stored.type.length())).ToLocal(&type)) {
      return;
    }

    Local<Value> values[] = {
      stored.blob->object(),
      Uint32::NewFromUnsigned(env->isolate(), stored.length),
      type
    };

    args.GetReturnValue().Set(
        Array::New(
            env->isolate(),
            values,
            arraysize(values)));
  }
}",75,,447,2,,void
140320,BLOCK,-1,,"{
    Local<Value> type;
    if (!String::NewFromUtf8(
            env->isolate(),
            stored.type.c_str(),
            v8::NewStringType::kNormal,
            static_cast<int>(stored.type.length())).ToLocal(&type)) {
      return;
    }

    Local<Value> values[] = {
      stored.blob->object(),
      Uint32::NewFromUnsigned(env->isolate(), stored.length),
      type
    };

    args.GetReturnValue().Set(
        Array::New(
            env->isolate(),
            values,
            arraysize(values)));
  }",20,,457,2,,void
140360,BLOCK,-1,,"{
      return;
    }",69,,463,2,,void
140406,BLOCK,-1,,"{
  tracker->TrackField(""blob"", blob, ""BaseObjectPtr<Blob>"");
}",35,,482,2,,void
140420,BLOCK,-1,,<empty>,19,,492,4,,void
140426,BLOCK,-1,,"{
  MakeWeak();
}",49,,495,3,,void
140432,BLOCK,-1,,"{
  tracker->TrackField(""data_objects_"",
                      data_objects_,
                      ""std::unordered_map<std::string, StoredDataObject>"");
}",64,,499,2,,void
140445,BLOCK,-1,,"{
  data_objects_[uuid] = object;
}",54,,507,3,,void
140455,BLOCK,-1,,"{
  if (data_objects_.find(uuid) == data_objects_.end()) {
    return;
  }
  data_objects_.erase(uuid);
  CHECK_EQ(data_objects_.find(uuid), data_objects_.end());
}",67,,511,2,,void
140467,BLOCK,-1,,"{
    return;
  }",56,,512,2,,void
140488,BLOCK,-1,,"{
  auto entry = data_objects_.find(uuid);
  if (entry == data_objects_.end())
    return BlobBindingData::StoredDataObject {};
  return entry->second;
}",30,,520,2,,void
140504,BLOCK,-1,,<empty>,5,,523,2,,void
140519,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  HandleScope scope(context->GetIsolate());
  Realm* realm = Realm::GetCurrent(context);
  BlobBindingData* binding =
      realm->AddBindingData<BlobBindingData>(context, holder);
  CHECK_NOT_NULL(binding);
}",64,,530,5,,void
140559,BLOCK,-1,,"{
  // Stored blob objects are not actually persisted.
  // Return true because we need to maintain the reference to the binding from
  // JS land.
  return true;
}",77,,540,3,,void
140566,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info =
      InternalFieldInfoBase::New<InternalFieldInfo>(type());
  return info;
}",62,,547,2,,void
140588,BLOCK,-1,,"{
  registry->Register(Blob::New);
  registry->Register(Blob::GetReader);
  registry->Register(Blob::ToSlice);
  registry->Register(Blob::StoreDataObject);
  registry->Register(Blob::GetDataObject);
  registry->Register(Blob::RevokeObjectURL);
  registry->Register(Blob::Reader::Pull);
  registry->Register(Concat);
  registry->Register(BlobFromFilePath);
}",76,,554,2,,void
140685,BLOCK,-1,,<empty>,1,,1,1,,ANY
140689,BLOCK,-1,,<empty>,56,,22,2,,void
140700,BLOCK,-1,,<empty>,1,,1,1,,ANY
140709,BLOCK,-1,,"{

  int status;
  if (eos_) {
    status = bob::Status::STATUS_EOS;
    std::move(next)(status, nullptr, 0, [](size_t len) {});
    return status;
  }

  status = DoPull(std::move(next), options, data, count, max_count_hint);

  if (status == bob::Status::STATUS_EOS) eos_ = true;

  return status;
}",28,,17,6,,void
140713,BLOCK,-1,,"{
    status = bob::Status::STATUS_EOS;
    std::move(next)(status, nullptr, 0, [](size_t len) {});
    return status;
  }",13,,20,2,,void
140753,BLOCK,-1,,<empty>,42,,28,2,,void
140767,BLOCK,-1,,<empty>,1,,1,1,,ANY
140780,BLOCK,-1,,<empty>,,,,1,,<empty>
140800,BLOCK,-1,,<empty>,,,,1,,<empty>
140816,BLOCK,-1,,<empty>,,,,1,,<empty>
140825,BLOCK,-1,,<empty>,,,,6,,<empty>
140835,BLOCK,-1,,<empty>,,,,6,,<empty>
140839,BLOCK,-1,,{ return eos_; },23,,90,1,,void
140850,BLOCK,-1,,<empty>,,,,6,,<empty>
140855,BLOCK,-1,,<empty>,,,,1,,<empty>
140866,BLOCK,-1,,"{
        static_cast<CallbackInfo*>(arg)->OnBackingStoreFree();
      }",79,,122,4,,void
140879,BLOCK,-1,,"{
    CHECK_EQ(self->env_, env);  // Consistency check.

    self->CallAndResetCallback();
  }",75,,198,2,,void
140897,BLOCK,-1,,"{
    free(data);
  }",74,,509,4,,void
140908,BLOCK,-1,,<empty>,63,,1179,4,,void
140946,BLOCK,-1,,<empty>,1,,1,1,,ANY
140957,BLOCK,-1,,<empty>,,,,6,,<empty>
140962,BLOCK,-1,,<empty>,,,,2,,<empty>
140967,BLOCK,-1,,<empty>,,,,2,,<empty>
140972,BLOCK,-1,,<empty>,,,,2,,<empty>
140976,BLOCK,-1,,<empty>,,,,1,,<empty>
140980,BLOCK,-1,,<empty>,,,,1,,<empty>
140988,BLOCK,-1,,<empty>,,,,5,,<empty>
141003,BLOCK,-1,,"{
  CHECK_NOT_NULL(callback);
  CHECK_IMPLIES(data == nullptr, length == 0);

  CallbackInfo* self = new CallbackInfo(env, callback, data, hint);
  std::unique_ptr<BackingStore> bs =
      ArrayBuffer::NewBackingStore(data, length, [](void*, size_t, void* arg) {
        static_cast<CallbackInfo*>(arg)->OnBackingStoreFree();
      }, self);
  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));

  // V8 simply ignores the BackingStore deleter callback if data == nullptr,
  // but our API contract requires it being called.
  if (data == nullptr) {
    ab->Detach(Local<Value>()).Check();
    self->OnBackingStoreFree();  // This calls `callback` asynchronously.
  } else {
    // Store the ArrayBuffer so that we can detach it later.
    self->persistent_.Reset(env->isolate(), ab);
    self->persistent_.SetWeak();
  }

  return ab;
}",17,,116,6,,void
141061,BLOCK,-1,,"{
    ab->Detach(Local<Value>()).Check();
    self->OnBackingStoreFree();  // This calls `callback` asynchronously.
  }",24,,129,2,,void
141075,BLOCK,-1,,"{
    // Store the ArrayBuffer so that we can detach it later.
    self->persistent_.Reset(env->isolate(), ab);
    self->persistent_.SetWeak();
  }",10,,132,1,,void
141102,BLOCK,-1,,"{
  env->AddCleanupHook(CleanupHook, this);
  env->isolate()->AdjustAmountOfExternalAllocatedMemory(sizeof(*this));
}",17,,149,5,,void
141123,BLOCK,-1,,"{
  CallbackInfo* self = static_cast<CallbackInfo*>(data);

  {
    HandleScope handle_scope(self->env_->isolate());
    Local<ArrayBuffer> ab = self->persistent_.Get(self->env_->isolate());
    if (!ab.IsEmpty() && ab->IsDetachable()) {
      ab->Detach(Local<Value>()).Check();
      self->persistent_.Reset();
    }
  }

  // Call the callback in this case, but don't delete `this` yet because the
  // BackingStore deleter callback will do so later.
  self->CallAndResetCallback();
}",44,,154,2,,void
141130,BLOCK,3,,"{
    HandleScope handle_scope(self->env_->isolate());
    Local<ArrayBuffer> ab = self->persistent_.Get(self->env_->isolate());
    if (!ab.IsEmpty() && ab->IsDetachable()) {
      ab->Detach(Local<Value>()).Check();
      self->persistent_.Reset();
    }
  }",3,,157,3,,void
141168,BLOCK,-1,,"{
      ab->Detach(Local<Value>()).Check();
      self->persistent_.Reset();
    }",46,,160,2,,void
141190,BLOCK,-1,,"{
  FreeCallback callback;
  {
    Mutex::ScopedLock lock(mutex_);
    callback = callback_;
    callback_ = nullptr;
  }
  if (callback != nullptr) {
    // Clean up all Environment-related state and run the callback.
    env_->RemoveCleanupHook(CleanupHook, this);
    int64_t change_in_bytes = -static_cast<int64_t>(sizeof(*this));
    env_->isolate()->AdjustAmountOfExternalAllocatedMemory(change_in_bytes);

    callback(data_, hint_);
  }
}",43,,171,1,,void
141192,BLOCK,2,,"{
    Mutex::ScopedLock lock(mutex_);
    callback = callback_;
    callback_ = nullptr;
  }",3,,173,2,,void
141206,BLOCK,-1,,"{
    // Clean up all Environment-related state and run the callback.
    env_->RemoveCleanupHook(CleanupHook, this);
    int64_t change_in_bytes = -static_cast<int64_t>(sizeof(*this));
    env_->isolate()->AdjustAmountOfExternalAllocatedMemory(change_in_bytes);

    callback(data_, hint_);
  }",28,,178,2,,void
141236,BLOCK,-1,,"{
  // This method should always release the memory for `this`.
  std::unique_ptr<CallbackInfo> self { this };
  Mutex::ScopedLock lock(mutex_);
  // If callback_ == nullptr, that means that the callback has already run from
  // the cleanup hook, and there is nothing left to do here besides to clean
  // up the memory involved. In particular, the underlying `Environment` may
  // be gone at this point, so don’t attempt to call SetImmediateThreadsafe().
  if (callback_ == nullptr) return;

  env_->SetImmediateThreadsafe([self = std::move(self)](Environment* env) {
    CHECK_EQ(self->env_, env);  // Consistency check.

    self->CallAndResetCallback();
  });
}",41,,188,1,,void
141248,BLOCK,-1,,<empty>,29,,196,2,,void
141260,BLOCK,-1,,"{
  return val->IsArrayBufferView();
}",36,,237,2,,void
141270,BLOCK,-1,,"{
  return obj->IsArrayBufferView();
}",37,,242,2,,void
141280,BLOCK,-1,,"{
  CHECK(val->IsArrayBufferView());
  Local<ArrayBufferView> ui = val.As<ArrayBufferView>();
  return static_cast<char*>(ui->Buffer()->Data()) + ui->ByteOffset();
}",30,,247,2,,void
141315,BLOCK,-1,,"{
  return Data(obj.As<Value>());
}",31,,254,2,,void
141326,BLOCK,-1,,"{
  CHECK(val->IsArrayBufferView());
  Local<ArrayBufferView> ui = val.As<ArrayBufferView>();
  return ui->ByteLength();
}",33,,259,2,,void
141351,BLOCK,-1,,"{
  CHECK(obj->IsArrayBufferView());
  Local<ArrayBufferView> ui = obj.As<ArrayBufferView>();
  return ui->ByteLength();
}",34,,266,2,,void
141379,BLOCK,-1,,"{
  CHECK(!env->buffer_prototype_object().IsEmpty());
  Local<Uint8Array> ui = Uint8Array::New(ab, byte_offset, length);
  Maybe<bool> mb =
      ui->SetPrototype(env->context(), env->buffer_prototype_object());
  if (mb.IsNothing())
    return MaybeLocal<Uint8Array>();
  return ui;
}",43,,276,5,,void
141422,BLOCK,-1,,<empty>,5,,282,2,,void
141434,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(isolate);
  if (env == nullptr) {
    THROW_ERR_BUFFER_CONTEXT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Uint8Array>();
  }
  return New(env, ab, byte_offset, length);
}",43,,289,5,,void
141447,BLOCK,-1,,"{
    THROW_ERR_BUFFER_CONTEXT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Uint8Array>();
  }",23,,291,2,,void
141464,BLOCK,-1,,"{
  EscapableHandleScope scope(isolate);

  size_t length;
  if (!StringBytes::Size(isolate, string, enc).To(&length))
    return Local<Object>();
  size_t actual = 0;
  std::unique_ptr<BackingStore> store;

  if (length > 0) {
    store = ArrayBuffer::NewBackingStore(isolate, length);

    if (UNLIKELY(!store)) {
      THROW_ERR_MEMORY_ALLOCATION_FAILED(isolate);
      return Local<Object>();
    }

    actual = StringBytes::Write(
        isolate,
        static_cast<char*>(store->Data()),
        length,
        string,
        enc);
    CHECK(actual <= length);

    if (LIKELY(actual > 0)) {
      if (actual < length)
        store = BackingStore::Reallocate(isolate, std::move(store), actual);
      Local<ArrayBuffer> buf = ArrayBuffer::New(isolate, std::move(store));
      Local<Object> obj;
      if (UNLIKELY(!New(isolate, buf, 0, actual).ToLocal(&obj)))
        return MaybeLocal<Object>();
      return scope.Escape(obj);
    }
  }

  return scope.EscapeMaybe(New(isolate, 0));
}",43,,301,4,,void
141483,BLOCK,-1,,<empty>,5,,306,2,,void
141501,BLOCK,-1,,"{
    store = ArrayBuffer::NewBackingStore(isolate, length);

    if (UNLIKELY(!store)) {
      THROW_ERR_MEMORY_ALLOCATION_FAILED(isolate);
      return Local<Object>();
    }

    actual = StringBytes::Write(
        isolate,
        static_cast<char*>(store->Data()),
        length,
        string,
        enc);
    CHECK(actual <= length);

    if (LIKELY(actual > 0)) {
      if (actual < length)
        store = BackingStore::Reallocate(isolate, std::move(store), actual);
      Local<ArrayBuffer> buf = ArrayBuffer::New(isolate, std::move(store));
      Local<Object> obj;
      if (UNLIKELY(!New(isolate, buf, 0, actual).ToLocal(&obj)))
        return MaybeLocal<Object>();
      return scope.Escape(obj);
    }
  }",19,,310,2,,void
141514,BLOCK,-1,,"{
      THROW_ERR_MEMORY_ALLOCATION_FAILED(isolate);
      return Local<Object>();
    }",27,,313,2,,void
141544,BLOCK,-1,,"{
      if (actual < length)
        store = BackingStore::Reallocate(isolate, std::move(store), actual);
      Local<ArrayBuffer> buf = ArrayBuffer::New(isolate, std::move(store));
      Local<Object> obj;
      if (UNLIKELY(!New(isolate, buf, 0, actual).ToLocal(&obj)))
        return MaybeLocal<Object>();
      return scope.Escape(obj);
    }",29,,326,2,,void
141549,BLOCK,-1,,<empty>,9,,328,2,,void
141597,BLOCK,-1,,<empty>,9,,332,2,,void
141619,BLOCK,-1,,"{
  EscapableHandleScope handle_scope(isolate);
  Local<Object> obj;
  Environment* env = Environment::GetCurrent(isolate);
  if (env == nullptr) {
    THROW_ERR_BUFFER_CONTEXT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Object>();
  }
  if (Buffer::New(env, length).ToLocal(&obj))
    return handle_scope.Escape(obj);
  return Local<Object>();
}",57,,341,3,,void
141640,BLOCK,-1,,"{
    THROW_ERR_BUFFER_CONTEXT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Object>();
  }",23,,345,2,,void
141657,BLOCK,-1,,<empty>,5,,350,2,,void
141671,BLOCK,-1,,"{
  Isolate* isolate(env->isolate());
  EscapableHandleScope scope(isolate);

  // V8 currently only allows a maximum Typed Array index of max Smi.
  if (length > kMaxLength) {
    isolate->ThrowException(ERR_BUFFER_TOO_LARGE(isolate));
    return Local<Object>();
  }

  Local<ArrayBuffer> ab;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    std::unique_ptr<BackingStore> bs =
        ArrayBuffer::NewBackingStore(isolate, length);

    CHECK(bs);

    ab = ArrayBuffer::New(isolate, std::move(bs));
  }

  MaybeLocal<Object> obj =
      New(env, ab, 0, ab->ByteLength())
          .FromMaybe(Local<Uint8Array>());

  return scope.EscapeMaybe(obj);
}",57,,355,3,,void
141685,BLOCK,-1,,"{
    isolate->ThrowException(ERR_BUFFER_TOO_LARGE(isolate));
    return Local<Object>();
  }",28,,360,2,,void
141699,BLOCK,7,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    std::unique_ptr<BackingStore> bs =
        ArrayBuffer::NewBackingStore(isolate, length);

    CHECK(bs);

    ab = ArrayBuffer::New(isolate, std::move(bs));
  }",3,,366,7,,void
141763,BLOCK,-1,,"{
  EscapableHandleScope handle_scope(isolate);
  Environment* env = Environment::GetCurrent(isolate);
  if (env == nullptr) {
    THROW_ERR_BUFFER_CONTEXT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Object>();
  }
  Local<Object> obj;
  if (Buffer::Copy(env, data, length).ToLocal(&obj))
    return handle_scope.Escape(obj);
  return Local<Object>();
}",76,,384,4,,void
141779,BLOCK,-1,,"{
    THROW_ERR_BUFFER_CONTEXT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Object>();
  }",23,,387,2,,void
141802,BLOCK,-1,,<empty>,5,,393,2,,void
141817,BLOCK,-1,,"{
  Isolate* isolate(env->isolate());
  EscapableHandleScope scope(isolate);

  // V8 currently only allows a maximum Typed Array index of max Smi.
  if (length > kMaxLength) {
    isolate->ThrowException(ERR_BUFFER_TOO_LARGE(isolate));
    return Local<Object>();
  }

  Local<ArrayBuffer> ab;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    std::unique_ptr<BackingStore> bs =
        ArrayBuffer::NewBackingStore(isolate, length);

    CHECK(bs);

    memcpy(bs->Data(), data, length);

    ab = ArrayBuffer::New(isolate, std::move(bs));
  }

  MaybeLocal<Object> obj =
      New(env, ab, 0, ab->ByteLength())
          .FromMaybe(Local<Uint8Array>());

  return scope.EscapeMaybe(obj);
}",76,,398,4,,void
141831,BLOCK,-1,,"{
    isolate->ThrowException(ERR_BUFFER_TOO_LARGE(isolate));
    return Local<Object>();
  }",28,,403,2,,void
141845,BLOCK,7,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    std::unique_ptr<BackingStore> bs =
        ArrayBuffer::NewBackingStore(isolate, length);

    CHECK(bs);

    memcpy(bs->Data(), data, length);

    ab = ArrayBuffer::New(isolate, std::move(bs));
  }",3,,409,7,,void
141918,BLOCK,-1,,"{
  EscapableHandleScope handle_scope(isolate);
  Environment* env = Environment::GetCurrent(isolate);
  if (env == nullptr) {
    callback(data, hint);
    THROW_ERR_BUFFER_CONTEXT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Object>();
  }
  return handle_scope.EscapeMaybe(
      Buffer::New(env, data, length, callback, hint));
}",36,,433,6,,void
141934,BLOCK,-1,,"{
    callback(data, hint);
    THROW_ERR_BUFFER_CONTEXT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Object>();
  }",23,,436,2,,void
141964,BLOCK,-1,,"{
  EscapableHandleScope scope(env->isolate());

  if (length > kMaxLength) {
    env->isolate()->ThrowException(ERR_BUFFER_TOO_LARGE(env->isolate()));
    callback(data, hint);
    return Local<Object>();
  }

  Local<ArrayBuffer> ab =
      CallbackInfo::CreateTrackedArrayBuffer(env, data, length, callback, hint);
  if (ab->SetPrivate(env->context(),
                     env->untransferable_object_private_symbol(),
                     True(env->isolate())).IsNothing()) {
    return Local<Object>();
  }
  MaybeLocal<Uint8Array> maybe_ui = Buffer::New(env, ab, 0, length);

  Local<Uint8Array> ui;
  if (!maybe_ui.ToLocal(&ui))
    return MaybeLocal<Object>();

  return scope.Escape(ui);
}",36,,450,6,,void
141975,BLOCK,-1,,"{
    env->isolate()->ThrowException(ERR_BUFFER_TOO_LARGE(env->isolate()));
    callback(data, hint);
    return Local<Object>();
  }",28,,453,2,,void
142029,BLOCK,-1,,"{
    return Local<Object>();
  }",57,,463,2,,void
142059,BLOCK,-1,,<empty>,5,,470,2,,void
142074,BLOCK,-1,,"{
  EscapableHandleScope handle_scope(isolate);
  Environment* env = Environment::GetCurrent(isolate);
  if (env == nullptr) {
    free(data);
    THROW_ERR_BUFFER_CONTEXT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Object>();
  }
  Local<Object> obj;
  if (Buffer::New(env, data, length).ToLocal(&obj))
    return handle_scope.Escape(obj);
  return Local<Object>();
}",69,,477,4,,void
142090,BLOCK,-1,,"{
    free(data);
    THROW_ERR_BUFFER_CONTEXT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Object>();
  }",23,,480,2,,void
142115,BLOCK,-1,,<empty>,5,,487,2,,void
142129,BLOCK,-1,,"{
  if (length > 0) {
    CHECK_NOT_NULL(data);
    // V8 currently only allows a maximum Typed Array index of max Smi.
    if (length > kMaxLength) {
      Isolate* isolate(env->isolate());
      isolate->ThrowException(ERR_BUFFER_TOO_LARGE(isolate));
      free(data);
      return Local<Object>();
    }
  }

  EscapableHandleScope handle_scope(env->isolate());

  auto free_callback = [](void* data, size_t length, void* deleter_data) {
    free(data);
  };
  std::unique_ptr<BackingStore> bs =
      v8::ArrayBuffer::NewBackingStore(data, length, free_callback, nullptr);

  Local<ArrayBuffer> ab = v8::ArrayBuffer::New(env->isolate(), std::move(bs));

  Local<Object> obj;
  if (Buffer::New(env, ab, 0, length).ToLocal(&obj))
    return handle_scope.Escape(obj);
  return Local<Object>();
}",39,,495,4,,void
142134,BLOCK,-1,,"{
    CHECK_NOT_NULL(data);
    // V8 currently only allows a maximum Typed Array index of max Smi.
    if (length > kMaxLength) {
      Isolate* isolate(env->isolate());
      isolate->ThrowException(ERR_BUFFER_TOO_LARGE(isolate));
      free(data);
      return Local<Object>();
    }
  }",19,,496,2,,void
142141,BLOCK,-1,,"{
      Isolate* isolate(env->isolate());
      isolate->ThrowException(ERR_BUFFER_TOO_LARGE(isolate));
      free(data);
      return Local<Object>();
    }",30,,499,2,,void
142226,BLOCK,-1,,<empty>,5,,519,2,,void
142240,BLOCK,-1,,"{
  CHECK(args[0]->IsString());
  CHECK(args[1]->IsInt32());

  enum encoding enc = static_cast<enum encoding>(args[1].As<Int32>()->Value());
  Local<Object> buf;
  if (New(args.GetIsolate(), args[0].As<String>(), enc).ToLocal(&buf))
    args.GetReturnValue().Set(buf);
}",64,,525,2,,void
142292,BLOCK,-1,,<empty>,5,,532,2,,void
142305,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  THROW_AND_RETURN_UNLESS_BUFFER(env, args.This());
  ArrayBufferViewContents<char> buffer(args.This());

  if (buffer.length() == 0)
    return args.GetReturnValue().SetEmptyString();

  size_t start = 0;
  size_t end = 0;
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[0], 0, &start));
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[1], buffer.length(), &end));
  if (end < start) end = start;
  THROW_AND_RETURN_IF_OOB(Just(end <= buffer.length()));
  size_t length = end - start;

  Local<Value> error;
  MaybeLocal<Value> maybe_ret =
      StringBytes::Encode(isolate,
                          buffer.data() + start,
                          length,
                          encoding,
                          &error);
  Local<Value> ret;
  if (!maybe_ret.ToLocal(&ret)) {
    CHECK(!error.IsEmpty());
    isolate->ThrowException(error);
    return;
  }
  args.GetReturnValue().Set(ret);
}",59,,537,2,,void
142327,BLOCK,1,,<empty>,,,,4,,void
142348,BLOCK,-1,,<empty>,5,,545,2,,void
142367,BLOCK,1,,<empty>,,,,6,,void
142369,BLOCK,-1,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[0], 0, &start))",3,,549,1,,void
142386,BLOCK,-1,,<empty>,3,,549,2,,void
142394,BLOCK,-1,,<empty>,3,,549,2,,void
142405,BLOCK,1,,<empty>,,,,7,,void
142407,BLOCK,-1,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[1], buffer.length(), &end))",3,,550,1,,void
142427,BLOCK,-1,,<empty>,3,,550,2,,void
142435,BLOCK,-1,,<empty>,3,,550,2,,void
142448,BLOCK,-1,,<empty>,20,,551,2,,void
142454,BLOCK,1,,<empty>,,,,6,,void
142456,BLOCK,-1,,THROW_AND_RETURN_IF_OOB(Just(end <= buffer.length())),3,,552,1,,void
142472,BLOCK,-1,,<empty>,3,,552,2,,void
142480,BLOCK,-1,,<empty>,3,,552,2,,void
142534,BLOCK,-1,,"{
    CHECK(!error.IsEmpty());
    isolate->ThrowException(error);
    return;
  }",33,,563,2,,void
142559,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  THROW_AND_RETURN_UNLESS_BUFFER(env, args[1]);
  ArrayBufferViewContents<char> source(args[0]);
  Local<Object> target_obj = args[1].As<Object>();
  SPREAD_BUFFER_ARG(target_obj, target);

  size_t target_start = 0;
  size_t source_start = 0;
  size_t source_end = 0;

  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], 0, &target_start));
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[3], 0, &source_start));
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[4], source.length(),
                                          &source_end));

  // Copy 0 bytes; we're done
  if (target_start >= target_length || source_start >= source_end)
    return args.GetReturnValue().Set(0);

  if (source_start > source.length())
    return THROW_ERR_OUT_OF_RANGE(
        env, ""The value of \""sourceStart\"" is out of range."");

  if (source_end - source_start > target_length - target_start)
 ...",52,,572,2,,void
142573,BLOCK,1,,<empty>,,,,4,,void
142585,BLOCK,1,,<empty>,,,,4,,void
142626,BLOCK,1,,<empty>,,,,6,,void
142628,BLOCK,-1,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], 0, &target_start))",3,,585,1,,void
142645,BLOCK,-1,,<empty>,3,,585,2,,void
142653,BLOCK,-1,,<empty>,3,,585,2,,void
142664,BLOCK,1,,<empty>,,,,6,,void
142666,BLOCK,-1,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[3], 0, &source_start))",3,,586,1,,void
142683,BLOCK,-1,,<empty>,3,,586,2,,void
142691,BLOCK,-1,,<empty>,3,,586,2,,void
142702,BLOCK,1,,<empty>,,,,7,,void
142704,BLOCK,-1,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[4], source.length(),
                                          &source_end))",3,,587,1,,void
142724,BLOCK,-1,,<empty>,3,,587,2,,void
142732,BLOCK,-1,,<empty>,3,,587,2,,void
142749,BLOCK,-1,,<empty>,5,,592,2,,void
142766,BLOCK,-1,,<empty>,5,,595,2,,void
142779,BLOCK,-1,,<empty>,5,,599,2,,void
142833,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Local<Context> ctx = env->context();

  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  SPREAD_BUFFER_ARG(args[0], ts_obj);

  size_t start = 0;
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], 0, &start));
  size_t end;
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[3], 0, &end));

  size_t fill_length = end - start;
  Local<String> str_obj;
  size_t str_length;
  enum encoding enc;

  // OOB Check. Throw the error in JS.
  if (start > end || fill_length + start > ts_obj_length)
    return args.GetReturnValue().Set(-2);

  // First check if Buffer has been passed.
  if (Buffer::HasInstance(args[1])) {
    SPREAD_BUFFER_ARG(args[1], fill_obj);
    str_length = fill_obj_length;
    memcpy(
        ts_obj_data + start, fill_obj_data, std::min(str_length, fill_length));
    goto start_fill;
  }

  // Then coerce everything that's not a string.
  if (!args[1]->IsString()) {
    uint32_t val;
    if (!args[1]->Uint32Valu...",52,,610,2,,void
142857,BLOCK,1,,<empty>,,,,4,,void
142875,BLOCK,1,,<empty>,,,,6,,void
142877,BLOCK,-1,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], 0, &start))",3,,618,1,,void
142894,BLOCK,-1,,<empty>,3,,618,2,,void
142902,BLOCK,-1,,<empty>,3,,618,2,,void
142914,BLOCK,1,,<empty>,,,,6,,void
142916,BLOCK,-1,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[3], 0, &end))",3,,620,1,,void
142933,BLOCK,-1,,<empty>,3,,620,2,,void
142941,BLOCK,-1,,<empty>,3,,620,2,,void
142973,BLOCK,-1,,<empty>,5,,629,2,,void
142992,BLOCK,-1,,"{
    SPREAD_BUFFER_ARG(args[1], fill_obj);
    str_length = fill_obj_length;
    memcpy(
        ts_obj_data + start, fill_obj_data, std::min(str_length, fill_length));
    goto start_fill;
  }",37,,632,2,,void
143021,BLOCK,-1,,"{
    uint32_t val;
    if (!args[1]->Uint32Value(ctx).To(&val)) return;
    int value = val & 255;
    memset(ts_obj_data + start, value, fill_length);
    return;
  }",29,,641,2,,void
143037,BLOCK,-1,,<empty>,46,,643,2,,void
143082,BLOCK,-1,,"{
    str_length = str_obj->Utf8Length(env->isolate());
    node::Utf8Value str(env->isolate(), args[1]);
    memcpy(ts_obj_data + start, *str, std::min(str_length, fill_length));

  }",20,,654,2,,void
143115,BLOCK,-1,,<empty>,10,,659,1,,void
143120,BLOCK,-1,,"{
    str_length = str_obj->Length() * sizeof(uint16_t);
    node::TwoByteValue str(env->isolate(), args[1]);
    if (IsBigEndian())
      SwapBytes16(reinterpret_cast<char*>(&str[0]), str_length);

    memcpy(ts_obj_data + start, *str, std::min(str_length, fill_length));

  }",27,,659,2,,void
143141,BLOCK,-1,,<empty>,7,,663,2,,void
143163,BLOCK,-1,,"{
    // Write initial String to Buffer, then use that memory to copy remainder
    // of string. Correct the string length for cases like HEX where less than
    // the total string length is written.
    str_length = StringBytes::Write(
        env->isolate(), ts_obj_data + start, fill_length, str_obj, enc);
  }",10,,667,1,,void
143185,BLOCK,-1,,<empty>,5,,678,2,,void
143191,BLOCK,-1,,<empty>,5,,686,2,,void
143220,BLOCK,-1,,"{
    memcpy(ptr, ts_obj_data + start, in_there);
    ptr += in_there;
    in_there *= 2;
  }",45,,691,2,,void
143237,BLOCK,-1,,"{
    memcpy(ptr, ts_obj_data + start, fill_length - in_there);
  }",31,,697,2,,void
143250,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  THROW_AND_RETURN_UNLESS_BUFFER(env, args.This());
  SPREAD_BUFFER_ARG(args.This(), ts_obj);

  THROW_AND_RETURN_IF_NOT_STRING(env, args[0], ""argument"");

  Local<String> str = args[0]->ToString(env->context()).ToLocalChecked();

  size_t offset = 0;
  size_t max_length = 0;

  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[1], 0, &offset));
  if (offset > ts_obj_length) {
    return node::THROW_ERR_BUFFER_OUT_OF_BOUNDS(
        env, ""\""offset\"" is outside of buffer bounds"");
  }

  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], ts_obj_length - offset,
                                          &max_length));

  max_length = std::min(ts_obj_length - offset, max_length);

  if (max_length == 0)
    return args.GetReturnValue().Set(0);

  uint32_t written = StringBytes::Write(
      env->isolate(), ts_obj_data + offset, max_length, str, encoding);
  args.GetReturnValue().Set(written);
}",59,,704,2,,void
143265,BLOCK,1,,<empty>,,,,4,,void
143314,BLOCK,1,,<empty>,,,,6,,void
143316,BLOCK,-1,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[1], 0, &offset))",3,,717,1,,void
143333,BLOCK,-1,,<empty>,3,,717,2,,void
143341,BLOCK,-1,,<empty>,3,,717,2,,void
143354,BLOCK,-1,,"{
    return node::THROW_ERR_BUFFER_OUT_OF_BOUNDS(
        env, ""\""offset\"" is outside of buffer bounds"");
  }",31,,718,2,,void
143364,BLOCK,1,,<empty>,,,,7,,void
143366,BLOCK,-1,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], ts_obj_length - offset,
                                          &max_length))",3,,723,1,,void
143385,BLOCK,-1,,<empty>,3,,723,2,,void
143393,BLOCK,-1,,<empty>,3,,723,2,,void
143416,BLOCK,-1,,<empty>,5,,729,2,,void
143455,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsString());

  // Fast case: avoid StringBytes on UTF8 string. Jump to v8.
  args.GetReturnValue().Set(args[0].As<String>()->Utf8Length(env->isolate()));
}",66,,736,2,,void
143496,BLOCK,-1,,"{
  uint32_t result = 0;
  uint32_t length = source.length;
  const uint8_t* data = reinterpret_cast<const uint8_t*>(source.data);
  for (uint32_t i = 0; i < length; ++i) {
    result += (data[i] >> 7);
  }
  result += length;
  return result;
}",66,,745,3,,void
143516,BLOCK,-1,,<empty>,3,,749,1,,void
143526,BLOCK,4,,"{
    result += (data[i] >> 7);
  }",41,,749,4,,void
143543,BLOCK,-1,,<empty>,,,,2,,<empty>
143550,BLOCK,-1,,"{
  if (val == 0) {
    if (a_length > b_length)
      return 1;
    else if (a_length < b_length)
      return -1;
  } else {
    if (val > 0)
      return 1;
    else
      return -1;
  }
  return val;
}",75,,761,4,,void
143555,BLOCK,-1,,"{
    if (a_length > b_length)
      return 1;
    else if (a_length < b_length)
      return -1;
  }",17,,762,2,,void
143560,BLOCK,-1,,<empty>,7,,764,2,,void
143564,BLOCK,-1,,<empty>,10,,765,1,,void
143569,BLOCK,-1,,<empty>,7,,766,2,,void
143574,BLOCK,-1,,"{
    if (val > 0)
      return 1;
    else
      return -1;
  }",10,,767,1,,void
143579,BLOCK,-1,,<empty>,7,,769,2,,void
143583,BLOCK,-1,,<empty>,7,,771,1,,void
143593,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  THROW_AND_RETURN_UNLESS_BUFFER(env, args[1]);
  ArrayBufferViewContents<char> source(args[0]);
  ArrayBufferViewContents<char> target(args[1]);

  size_t target_start = 0;
  size_t source_start = 0;
  size_t source_end = 0;
  size_t target_end = 0;

  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], 0, &target_start));
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[3], 0, &source_start));
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[4], target.length(),
                                          &target_end));
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[5], source.length(),
                                          &source_end));

  if (source_start > source.length())
    return THROW_ERR_OUT_OF_RANGE(
        env, ""The value of \""sourceStart\"" is out of range."");
  if (target_start > target.length())
    return THROW_ERR_OUT_OF_RANGE(
        env, ""The va...",61,,776,2,,void
143607,BLOCK,1,,<empty>,,,,4,,void
143619,BLOCK,1,,<empty>,,,,4,,void
143654,BLOCK,1,,<empty>,,,,6,,void
143656,BLOCK,-1,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], 0, &target_start))",3,,789,1,,void
143673,BLOCK,-1,,<empty>,3,,789,2,,void
143681,BLOCK,-1,,<empty>,3,,789,2,,void
143692,BLOCK,1,,<empty>,,,,6,,void
143694,BLOCK,-1,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[3], 0, &source_start))",3,,790,1,,void
143711,BLOCK,-1,,<empty>,3,,790,2,,void
143719,BLOCK,-1,,<empty>,3,,790,2,,void
143730,BLOCK,1,,<empty>,,,,7,,void
143732,BLOCK,-1,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[4], target.length(),
                                          &target_end))",3,,791,1,,void
143752,BLOCK,-1,,<empty>,3,,791,2,,void
143760,BLOCK,-1,,<empty>,3,,791,2,,void
143771,BLOCK,1,,<empty>,,,,7,,void
143773,BLOCK,-1,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[5], source.length(),
                                          &source_end))",3,,793,1,,void
143793,BLOCK,-1,,<empty>,3,,793,2,,void
143801,BLOCK,-1,,<empty>,3,,793,2,,void
143817,BLOCK,-1,,<empty>,5,,797,2,,void
143829,BLOCK,-1,,<empty>,5,,800,2,,void
143904,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  THROW_AND_RETURN_UNLESS_BUFFER(env, args[1]);
  ArrayBufferViewContents<char> a(args[0]);
  ArrayBufferViewContents<char> b(args[1]);

  size_t cmp_length = std::min(a.length(), b.length());

  int val = normalizeCompareVal(cmp_length > 0 ?
                                memcmp(a.data(), b.data(), cmp_length) : 0,
                                a.length(), b.length());
  args.GetReturnValue().Set(val);
}",55,,820,2,,void
143918,BLOCK,1,,<empty>,,,,4,,void
143930,BLOCK,1,,<empty>,,,,4,,void
144004,BLOCK,-1,,"{
  int64_t length_i64 = static_cast<int64_t>(length);
  if (offset_i64 < 0) {
    if (offset_i64 + length_i64 >= 0) {
      // Negative offsets count backwards from the end of the buffer.
      return length_i64 + offset_i64;
    } else if (is_forward || needle_length == 0) {
      // indexOf from before the start of the buffer: search the whole buffer.
      return 0;
    } else {
      // lastIndexOf from before the start of the buffer: no match.
      return -1;
    }
  } else {
    if (offset_i64 + needle_length <= length_i64) {
      // Valid positive offset.
      return offset_i64;
    } else if (needle_length == 0) {
      // Out of buffer bounds, but empty needle: point to end of buffer.
      return length_i64;
    } else if (is_forward) {
      // indexOf from past the end of the buffer: no match.
      return -1;
    } else {
      // lastIndexOf from past the end of the buffer: search the whole buffer.
      return length_i64 - 1;
    }
  }
}",40,,843,5,,void
144015,BLOCK,-1,,"{
    if (offset_i64 + length_i64 >= 0) {
      // Negative offsets count backwards from the end of the buffer.
      return length_i64 + offset_i64;
    } else if (is_forward || needle_length == 0) {
      // indexOf from before the start of the buffer: search the whole buffer.
      return 0;
    } else {
      // lastIndexOf from before the start of the buffer: no match.
      return -1;
    }
  }",23,,845,2,,void
144022,BLOCK,-1,,"{
      // Negative offsets count backwards from the end of the buffer.
      return length_i64 + offset_i64;
    }",39,,846,2,,void
144028,BLOCK,-1,,<empty>,12,,849,1,,void
144035,BLOCK,-1,,"{
      // indexOf from before the start of the buffer: search the whole buffer.
      return 0;
    }",50,,849,2,,void
144039,BLOCK,-1,,"{
      // lastIndexOf from before the start of the buffer: no match.
      return -1;
    }",12,,852,1,,void
144044,BLOCK,-1,,"{
    if (offset_i64 + needle_length <= length_i64) {
      // Valid positive offset.
      return offset_i64;
    } else if (needle_length == 0) {
      // Out of buffer bounds, but empty needle: point to end of buffer.
      return length_i64;
    } else if (is_forward) {
      // indexOf from past the end of the buffer: no match.
      return -1;
    } else {
      // lastIndexOf from past the end of the buffer: search the whole buffer.
      return length_i64 - 1;
    }
  }",10,,856,1,,void
144051,BLOCK,-1,,"{
      // Valid positive offset.
      return offset_i64;
    }",51,,857,2,,void
144055,BLOCK,-1,,<empty>,12,,860,1,,void
144060,BLOCK,-1,,"{
      // Out of buffer bounds, but empty needle: point to end of buffer.
      return length_i64;
    }",36,,860,2,,void
144064,BLOCK,-1,,<empty>,12,,863,1,,void
144067,BLOCK,-1,,"{
      // indexOf from past the end of the buffer: no match.
      return -1;
    }",28,,863,2,,void
144072,BLOCK,-1,,"{
      // lastIndexOf from past the end of the buffer: search the whole buffer.
      return length_i64 - 1;
    }",12,,866,1,,void
144081,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  CHECK(args[1]->IsString());
  CHECK(args[2]->IsNumber());
  CHECK(args[3]->IsInt32());
  CHECK(args[4]->IsBoolean());

  enum encoding enc = static_cast<enum encoding>(args[3].As<Int32>()->Value());

  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  ArrayBufferViewContents<char> buffer(args[0]);

  Local<String> needle = args[1].As<String>();
  int64_t offset_i64 = args[2].As<Integer>()->Value();
  bool is_forward = args[4]->IsTrue();

  const char* haystack = buffer.data();
  // Round down to the nearest multiple of 2 in case of UCS2.
  const size_t haystack_length = (enc == UCS2) ?
      buffer.length() &~ 1 : buffer.length();  // NOLINT(whitespace/operators)

  size_t needle_length;
  if (!StringBytes::Size(isolate, needle, enc).To(&needle_length)) return;

  int64_t opt_offset = IndexOfOffset(haystack_length,
                                     offset_i64,
                             ...",61,,873,2,,void
144144,BLOCK,1,,<empty>,,,,4,,void
144229,BLOCK,-1,,<empty>,68,,897,2,,void
144243,BLOCK,-1,,"{
    // Match String#indexOf() and String#lastIndexOf() behavior.
    args.GetReturnValue().Set(static_cast<double>(opt_offset));
    return;
  }",27,,904,2,,void
144259,BLOCK,-1,,"{
    return args.GetReturnValue().Set(-1);
  }",29,,910,2,,void
144275,BLOCK,-1,,"{
    return args.GetReturnValue().Set(-1);
  }",25,,914,2,,void
144307,BLOCK,-1,,"{
    return args.GetReturnValue().Set(-1);
  }",40,,920,2,,void
144326,BLOCK,-1,,"{
    String::Value needle_value(isolate, needle);
    if (*needle_value == nullptr)
      return args.GetReturnValue().Set(-1);

    if (haystack_length < 2 || needle_value.length() < 1) {
      return args.GetReturnValue().Set(-1);
    }

    if (IsBigEndian()) {
      StringBytes::InlineDecoder decoder;
      if (decoder.Decode(env, needle, enc).IsNothing()) return;
      const uint16_t* decoded_string =
          reinterpret_cast<const uint16_t*>(decoder.out());

      if (decoded_string == nullptr)
        return args.GetReturnValue().Set(-1);

      result = SearchString(reinterpret_cast<const uint16_t*>(haystack),
                            haystack_length / 2,
                            decoded_string,
                            decoder.size() / 2,
                            offset / 2,
                            is_forward);
    } else {
      result = SearchString(reinterpret_cast<const uint16_t*>(haystack),
                            haystack_length / 2,
           ...",20,,926,2,,void
144336,BLOCK,-1,,<empty>,7,,929,2,,void
144358,BLOCK,-1,,"{
      return args.GetReturnValue().Set(-1);
    }",59,,931,2,,void
144371,BLOCK,-1,,"{
      StringBytes::InlineDecoder decoder;
      if (decoder.Decode(env, needle, enc).IsNothing()) return;
      const uint16_t* decoded_string =
          reinterpret_cast<const uint16_t*>(decoder.out());

      if (decoded_string == nullptr)
        return args.GetReturnValue().Set(-1);

      result = SearchString(reinterpret_cast<const uint16_t*>(haystack),
                            haystack_length / 2,
                            decoded_string,
                            decoder.size() / 2,
                            offset / 2,
                            is_forward);
    }",24,,935,2,,void
144384,BLOCK,-1,,<empty>,57,,937,2,,void
144399,BLOCK,-1,,<empty>,9,,942,2,,void
144431,BLOCK,-1,,"{
      result = SearchString(reinterpret_cast<const uint16_t*>(haystack),
                            haystack_length / 2,
                            reinterpret_cast<const uint16_t*>(*needle_value),
                            needle_value.length(),
                            offset / 2,
                            is_forward);
    }",12,,950,1,,void
144457,BLOCK,-1,,<empty>,10,,959,1,,void
144462,BLOCK,-1,,"{
    String::Utf8Value needle_value(isolate, needle);
    if (*needle_value == nullptr)
      return args.GetReturnValue().Set(-1);

    result = SearchString(reinterpret_cast<const uint8_t*>(haystack),
                          haystack_length,
                          reinterpret_cast<const uint8_t*>(*needle_value),
                          needle_length,
                          offset,
                          is_forward);
  }",27,,959,2,,void
144472,BLOCK,-1,,<empty>,7,,962,2,,void
144498,BLOCK,-1,,<empty>,10,,970,1,,void
144503,BLOCK,-1,,"{
    uint8_t* needle_data = node::UncheckedMalloc<uint8_t>(needle_length);
    if (needle_data == nullptr) {
      return args.GetReturnValue().Set(-1);
    }
    needle->WriteOneByte(
        isolate, needle_data, 0, needle_length, String::NO_NULL_TERMINATION);

    result = SearchString(reinterpret_cast<const uint8_t*>(haystack),
                          haystack_length,
                          needle_data,
                          needle_length,
                          offset,
                          is_forward);
    free(needle_data);
  }",29,,970,2,,void
144518,BLOCK,-1,,"{
      return args.GetReturnValue().Set(-1);
    }",33,,972,2,,void
144573,BLOCK,-1,,"{
  CHECK(args[1]->IsObject());
  CHECK(args[2]->IsNumber());
  CHECK(args[3]->IsInt32());
  CHECK(args[4]->IsBoolean());

  enum encoding enc = static_cast<enum encoding>(args[3].As<Int32>()->Value());

  THROW_AND_RETURN_UNLESS_BUFFER(Environment::GetCurrent(args), args[0]);
  THROW_AND_RETURN_UNLESS_BUFFER(Environment::GetCurrent(args), args[1]);
  ArrayBufferViewContents<char> haystack_contents(args[0]);
  ArrayBufferViewContents<char> needle_contents(args[1]);
  int64_t offset_i64 = args[2].As<Integer>()->Value();
  bool is_forward = args[4]->IsTrue();

  const char* haystack = haystack_contents.data();
  const size_t haystack_length = haystack_contents.length();
  const char* needle = needle_contents.data();
  const size_t needle_length = needle_contents.length();

  int64_t opt_offset = IndexOfOffset(haystack_length,
                                     offset_i64,
                                     needle_length,
                                     is_forward);

  if (nee...",61,,991,2,,void
144625,BLOCK,1,,<empty>,,,,3,,void
144645,BLOCK,1,,<empty>,,,,3,,void
144727,BLOCK,-1,,"{
    // Match String#indexOf() and String#lastIndexOf() behavior.
    args.GetReturnValue().Set(static_cast<double>(opt_offset));
    return;
  }",27,,1016,2,,void
144743,BLOCK,-1,,"{
    return args.GetReturnValue().Set(-1);
  }",29,,1022,2,,void
144759,BLOCK,-1,,"{
    return args.GetReturnValue().Set(-1);
  }",25,,1026,2,,void
144791,BLOCK,-1,,"{
    return args.GetReturnValue().Set(-1);
  }",40,,1032,2,,void
144810,BLOCK,-1,,"{
    if (haystack_length < 2 || needle_length < 2) {
      return args.GetReturnValue().Set(-1);
    }
    result = SearchString(
        reinterpret_cast<const uint16_t*>(haystack),
        haystack_length / 2,
        reinterpret_cast<const uint16_t*>(needle),
        needle_length / 2,
        offset / 2,
        is_forward);
    result *= 2;
  }",20,,1038,2,,void
144819,BLOCK,-1,,"{
      return args.GetReturnValue().Set(-1);
    }",51,,1039,2,,void
144853,BLOCK,-1,,"{
    result = SearchString(
        reinterpret_cast<const uint8_t*>(haystack),
        haystack_length,
        reinterpret_cast<const uint8_t*>(needle),
        needle_length,
        offset,
        is_forward);
  }",10,,1050,1,,void
144887,BLOCK,-1,,"{
  CHECK(args[1]->IsUint32());
  CHECK(args[2]->IsNumber());
  CHECK(args[3]->IsBoolean());

  THROW_AND_RETURN_UNLESS_BUFFER(Environment::GetCurrent(args), args[0]);
  ArrayBufferViewContents<char> buffer(args[0]);

  uint32_t needle = args[1].As<Uint32>()->Value();
  int64_t offset_i64 = args[2].As<Integer>()->Value();
  bool is_forward = args[3]->IsTrue();

  int64_t opt_offset =
      IndexOfOffset(buffer.length(), offset_i64, 1, is_forward);
  if (opt_offset <= -1 || buffer.length() == 0) {
    return args.GetReturnValue().Set(-1);
  }
  size_t offset = static_cast<size_t>(opt_offset);
  CHECK_LT(offset, buffer.length());

  const void* ptr;
  if (is_forward) {
    ptr = memchr(buffer.data() + offset, needle, buffer.length() - offset);
  } else {
    ptr = node::stringsearch::MemrchrFill(buffer.data(), needle, offset + 1);
  }
  const char* ptr_char = static_cast<const char*>(ptr);
  args.GetReturnValue().Set(ptr ? static_cast<int>(ptr_char - buffer.data())
                   ...",61,,1064,2,,void
144918,BLOCK,1,,<empty>,,,,3,,void
144990,BLOCK,-1,,"{
    return args.GetReturnValue().Set(-1);
  }",49,,1078,2,,void
145016,BLOCK,-1,,"{
    ptr = memchr(buffer.data() + offset, needle, buffer.length() - offset);
  }",19,,1085,2,,void
145034,BLOCK,-1,,"{
    ptr = node::stringsearch::MemrchrFill(buffer.data(), needle, offset + 1);
  }",10,,1087,1,,void
145080,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  SPREAD_BUFFER_ARG(args[0], ts_obj);
  SwapBytes16(ts_obj_data, ts_obj_length);
  args.GetReturnValue().Set(args[0]);
}",54,,1096,2,,void
145094,BLOCK,1,,<empty>,,,,4,,void
145123,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  SPREAD_BUFFER_ARG(args[0], ts_obj);
  SwapBytes32(ts_obj_data, ts_obj_length);
  args.GetReturnValue().Set(args[0]);
}",54,,1105,2,,void
145137,BLOCK,1,,<empty>,,,,4,,void
145166,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  SPREAD_BUFFER_ARG(args[0], ts_obj);
  SwapBytes64(ts_obj_data, ts_obj_length);
  args.GetReturnValue().Set(args[0]);
}",54,,1114,2,,void
145180,BLOCK,1,,<empty>,,,,4,,void
145209,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsTypedArray() || args[0]->IsArrayBuffer() ||
        args[0]->IsSharedArrayBuffer());
  ArrayBufferViewContents<char> abv(args[0]);

  if (abv.WasDetached()) {
    return node::THROW_ERR_INVALID_STATE(
        env, ""Cannot validate on a detached buffer"");
  }

  args.GetReturnValue().Set(simdutf::validate_utf8(abv.data(), abv.length()));
}",61,,1122,2,,void
145255,BLOCK,-1,,"{
    return node::THROW_ERR_INVALID_STATE(
        env, ""Cannot validate on a detached buffer"");
  }",26,,1129,2,,void
145286,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsTypedArray() || args[0]->IsArrayBuffer() ||
        args[0]->IsSharedArrayBuffer());
  ArrayBufferViewContents<char> abv(args[0]);

  if (abv.WasDetached()) {
    return node::THROW_ERR_INVALID_STATE(
        env, ""Cannot validate on a detached buffer"");
  }

  args.GetReturnValue().Set(simdutf::validate_ascii(abv.data(), abv.length()));
}",62,,1137,2,,void
145332,BLOCK,-1,,"{
    return node::THROW_ERR_INVALID_STATE(
        env, ""Cannot validate on a detached buffer"");
  }",26,,1144,2,,void
145363,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(args);

  // TODO(legendecas): Remove this check once the binding supports sub-realms.
  CHECK_EQ(realm->kind(), Realm::Kind::kPrincipal);

  CHECK(args[0]->IsObject());
  Local<Object> proto = args[0].As<Object>();
  realm->set_buffer_prototype_object(proto);
}",66,,1152,2,,void
145410,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  NodeArrayBufferAllocator* allocator = env->isolate_data()->node_allocator();
  Local<ArrayBuffer> ab;
  // It can be a nullptr when running inside an isolate where we
  // do not own the ArrayBuffer allocator.
  if (allocator == nullptr) {
    // Create a dummy Uint32Array - the JS land can only toggle the C++ land
    // setting when the allocator uses our toggle. With this the toggle in JS
    // land results in no-ops.
    ab = ArrayBuffer::New(env->isolate(), sizeof(uint32_t));
  } else {
    uint32_t* zero_fill_field = allocator->zero_fill_field();
    std::unique_ptr<BackingStore> backing =
        ArrayBuffer::NewBackingStore(zero_fill_field,
                                     sizeof(*zero_fill_field),
                                     [](void*, size_t, void*) {},
                                     nullptr);
    ab = ArrayBuffer::New(env->isolate(), std::move(backing));
  }

  ab->SetPrivate(
      env->context(),...",65,,1163,2,,void
145438,BLOCK,-1,,"{
    // Create a dummy Uint32Array - the JS land can only toggle the C++ land
    // setting when the allocator uses our toggle. With this the toggle in JS
    // land results in no-ops.
    ab = ArrayBuffer::New(env->isolate(), sizeof(uint32_t));
  }",29,,1169,2,,void
145452,BLOCK,-1,,"{
    uint32_t* zero_fill_field = allocator->zero_fill_field();
    std::unique_ptr<BackingStore> backing =
        ArrayBuffer::NewBackingStore(zero_fill_field,
                                     sizeof(*zero_fill_field),
                                     [](void*, size_t, void*) {},
                                     nullptr);
    ab = ArrayBuffer::New(env->isolate(), std::move(backing));
  }",10,,1174,1,,void
145531,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  if (args[0]->IsArrayBuffer()) {
    Local<ArrayBuffer> buf = args[0].As<ArrayBuffer>();
    if (buf->IsDetachable()) {
      std::shared_ptr<BackingStore> store = buf->GetBackingStore();
      buf->Detach(Local<Value>()).Check();
      args.GetReturnValue().Set(ArrayBuffer::New(env->isolate(), store));
    }
  }
}",65,,1192,2,,void
145547,BLOCK,-1,,"{
    Local<ArrayBuffer> buf = args[0].As<ArrayBuffer>();
    if (buf->IsDetachable()) {
      std::shared_ptr<BackingStore> store = buf->GetBackingStore();
      buf->Detach(Local<Value>()).Check();
      args.GetReturnValue().Set(ArrayBuffer::New(env->isolate(), store));
    }
  }",33,,1194,2,,void
145565,BLOCK,-1,,"{
      std::shared_ptr<BackingStore> store = buf->GetBackingStore();
      buf->Detach(Local<Value>()).Check();
      args.GetReturnValue().Set(ArrayBuffer::New(env->isolate(), store));
    }",30,,1196,2,,void
145607,BLOCK,-1,,"{
  void* pointer;
  size_t byte_length;
  if (buffer->IsArrayBuffer()) {
    Local<ArrayBuffer> ab = buffer.As<ArrayBuffer>();
    pointer = ab->Data();
    byte_length = ab->ByteLength();
  } else if (buffer->IsSharedArrayBuffer()) {
    Local<SharedArrayBuffer> ab = buffer.As<SharedArrayBuffer>();
    pointer = ab->Data();
    byte_length = ab->ByteLength();
  } else {
    UNREACHABLE();  // Caller must validate.
  }
  return {pointer, byte_length};
}",70,,1206,2,,void
145615,BLOCK,-1,,"{
    Local<ArrayBuffer> ab = buffer.As<ArrayBuffer>();
    pointer = ab->Data();
    byte_length = ab->ByteLength();
  }",32,,1209,2,,void
145639,BLOCK,-1,,<empty>,10,,1213,1,,void
145645,BLOCK,-1,,"{
    Local<SharedArrayBuffer> ab = buffer.As<SharedArrayBuffer>();
    pointer = ab->Data();
    byte_length = ab->ByteLength();
  }",45,,1213,2,,void
145669,BLOCK,-1,,"{
    UNREACHABLE();  // Caller must validate.
  }",10,,1217,1,,void
145676,BLOCK,-1,,"{
  // args[0] == Destination ArrayBuffer
  // args[1] == Destination ArrayBuffer Offset
  // args[2] == Source ArrayBuffer
  // args[3] == Source ArrayBuffer Offset
  // args[4] == bytesToCopy

  CHECK(args[0]->IsArrayBuffer() || args[0]->IsSharedArrayBuffer());
  CHECK(args[1]->IsUint32());
  CHECK(args[2]->IsArrayBuffer() || args[2]->IsSharedArrayBuffer());
  CHECK(args[3]->IsUint32());
  CHECK(args[4]->IsUint32());

  void* destination;
  size_t destination_byte_length;
  std::tie(destination, destination_byte_length) =
      DecomposeBufferToParts(args[0]);

  void* source;
  size_t source_byte_length;
  std::tie(source, source_byte_length) = DecomposeBufferToParts(args[2]);

  uint32_t destination_offset = args[1].As<Uint32>()->Value();
  uint32_t source_offset = args[3].As<Uint32>()->Value();
  size_t bytes_to_copy = args[4].As<Uint32>()->Value();

  CHECK_GE(destination_byte_length - destination_offset, bytes_to_copy);
  CHECK_GE(source_byte_length - source_offset, bytes_to_...",63,,1225,2,,void
145825,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  SetMethod(context, target, ""setBufferPrototype"", SetBufferPrototype);
  SetMethodNoSideEffect(context, target, ""createFromString"", CreateFromString);

  SetFastMethodNoSideEffect(context,
                            target,
                            ""byteLengthUtf8"",
                            SlowByteLengthUtf8,
                            &fast_byte_length_utf8);
  SetMethod(context, target, ""copy"", Copy);
  SetMethodNoSideEffect(context, target, ""compare"", Compare);
  SetMethodNoSideEffect(context, target, ""compareOffset"", CompareOffset);
  SetMethod(context, target, ""fill"", Fill);
  SetMethodNoSideEffect(context, target, ""indexOfBuffer"", IndexOfBuffer);
  SetMethodNoSideEffect(context, target, ""indexOfNumber"", IndexOfNumber);
  SetMethodNoSideEffect(context, target, ""indexOfString"", IndexOfString);

  SetMethod(context, target, ""detachArrayBuffer"", DetachArrayBuffer);
  SetMethod(...",29,,1262,5,,void
146043,BLOCK,-1,,"{
  registry->Register(SetBufferPrototype);
  registry->Register(CreateFromString);

  registry->Register(SlowByteLengthUtf8);
  registry->Register(fast_byte_length_utf8.GetTypeInfo());
  registry->Register(FastByteLengthUtf8);
  registry->Register(Copy);
  registry->Register(Compare);
  registry->Register(CompareOffset);
  registry->Register(Fill);
  registry->Register(IndexOfBuffer);
  registry->Register(IndexOfNumber);
  registry->Register(IndexOfString);

  registry->Register(Swap16);
  registry->Register(Swap32);
  registry->Register(Swap64);

  registry->Register(IsUtf8);
  registry->Register(IsAscii);

  registry->Register(StringSlice<ASCII>);
  registry->Register(StringSlice<BASE64>);
  registry->Register(StringSlice<BASE64URL>);
  registry->Register(StringSlice<LATIN1>);
  registry->Register(StringSlice<HEX>);
  registry->Register(StringSlice<UCS2>);
  registry->Register(StringSlice<UTF8>);

  registry->Register(StringWrite<ASCII>);
  registry->Register(StringWrite<BASE64>)...",70,,1326,2,,void
146228,BLOCK,-1,,<empty>,1,,1,1,,ANY
146242,BLOCK,-1,,<empty>,,,,3,,<empty>
146247,BLOCK,-1,,<empty>,,,,2,,<empty>
146252,BLOCK,-1,,<empty>,,,,2,,<empty>
146257,BLOCK,-1,,<empty>,,,,2,,<empty>
146264,BLOCK,-1,,<empty>,,,,4,,<empty>
146270,BLOCK,-1,,<empty>,,,,3,,<empty>
146277,BLOCK,-1,,<empty>,,,,4,,<empty>
146286,BLOCK,-1,,<empty>,,,,6,,<empty>
146293,BLOCK,-1,,<empty>,,,,4,,<empty>
146301,BLOCK,-1,,<empty>,,,,5,,<empty>
146308,BLOCK,-1,,"{
  // Asking to seek too far into the buffer
  // check to avoid wrapping in subsequent subtraction
  if (off > max)
    return false;

  // Asking for more than is left over in the buffer
  if (max - off < len)
    return false;

  // Otherwise we're in bounds
  return true;
}",71,,75,4,,void
146313,BLOCK,-1,,<empty>,5,,79,2,,void
146322,BLOCK,-1,,<empty>,5,,83,2,,void
146349,BLOCK,-1,,<empty>,1,,1,1,,ANY
146353,BLOCK,-1,,"{
  LoadJavaScriptSource();
#ifdef NODE_SHARED_BUILTIN_CJS_MODULE_LEXER_LEXER_PATH
  AddExternalizedBuiltin(
      ""internal/deps/cjs-module-lexer/lexer"",
      STRINGIFY(NODE_SHARED_BUILTIN_CJS_MODULE_LEXER_LEXER_PATH));
#endif  // NODE_SHARED_BUILTIN_CJS_MODULE_LEXER_LEXER_PATH

#ifdef NODE_SHARED_BUILTIN_CJS_MODULE_LEXER_DIST_LEXER_PATH
  AddExternalizedBuiltin(
      ""internal/deps/cjs-module-lexer/dist/lexer"",
      STRINGIFY(NODE_SHARED_BUILTIN_CJS_MODULE_LEXER_DIST_LEXER_PATH));
#endif  // NODE_SHARED_BUILTIN_CJS_MODULE_LEXER_DIST_LEXER_PATH

#ifdef NODE_SHARED_BUILTIN_UNDICI_UNDICI_PATH
  AddExternalizedBuiltin(""internal/deps/undici/undici"",
                         STRINGIFY(NODE_SHARED_BUILTIN_UNDICI_UNDICI_PATH));
#endif  // NODE_SHARED_BUILTIN_UNDICI_UNDICI_PATH
}",79,,37,1,,void
146359,BLOCK,-1,,"{
  auto source = source_.read();
  return source->find(id) != source->end();
}",44,,57,2,,void
146383,BLOCK,-1,,"{
  auto result = source_.write()->emplace(id, source);
  return result.second;
}",67,,62,3,,void
146404,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  Local<Object> out = Object::New(isolate);
  auto source = source_.read();
  for (auto const& x : *source) {
    Local<String> key = OneByteString(isolate, x.first.c_str(), x.first.size());
    out->Set(context, key, x.second.ToStringChecked(isolate)).FromJust();
  }
  return out;
}",70,,67,2,,void
146434,BLOCK,-1,,"{
    Local<String> key = OneByteString(isolate, x.first.c_str(), x.first.size());
    out->Set(context, key, x.second.ToStringChecked(isolate)).FromJust();
  }",33,,71,3,,void
146477,BLOCK,-1,,"{
  return config_.ToStringChecked(isolate);
}",64,,78,2,,void
146487,BLOCK,-1,,"{
  std::vector<std::string> ids;
  auto source = source_.read();
  ids.reserve(source->size());
  for (auto const& x : *source) {
    ids.emplace_back(x.first);
  }
  return ids;
}",63,,82,1,,void
146516,BLOCK,-1,,"{
    ids.emplace_back(x.first);
  }",33,,86,3,,void
146529,BLOCK,-1,,"{
  BuiltinCategories builtin_categories;

  std::vector<std::string> prefixes = {
#if !HAVE_OPENSSL
    ""internal/crypto/"",
    ""internal/debugger/"",
#endif  // !HAVE_OPENSSL

    ""internal/bootstrap/"",
    ""internal/per_context/"",
    ""internal/deps/"",
    ""internal/main/""
  };

  builtin_categories.can_be_required.emplace(
      ""internal/deps/cjs-module-lexer/lexer"");

  builtin_categories.cannot_be_required = std::set<std::string> {
#if !HAVE_INSPECTOR
    ""inspector"", ""inspector/promises"", ""internal/util/inspector"",
#endif  // !HAVE_INSPECTOR

#if !NODE_USE_V8_PLATFORM || !defined(NODE_HAVE_I18N_SUPPORT)
        ""trace_events"",
#endif  // !NODE_USE_V8_PLATFORM || !defined(NODE_HAVE_I18N_SUPPORT)

#if !HAVE_OPENSSL
        ""crypto"", ""crypto/promises"", ""https"", ""http2"", ""tls"", ""_tls_common"",
        ""_tls_wrap"", ""internal/tls/secure-pair"",
        ""internal/tls/parse-cert-string"", ""internal/tls/secure-context"",
        ""internal/http2/core"", ""internal/http2/compat"",
        ""int...",78,,92,1,,void
146589,BLOCK,-1,,"{
    const std::string& id = x.first;
    for (auto const& prefix : prefixes) {
      if (prefix.length() > id.length()) {
        continue;
      }
      if (id.find(prefix) == 0 &&
          builtin_categories.can_be_required.count(id) == 0) {
        builtin_categories.cannot_be_required.emplace(id);
      }
    }
  }",33,,134,3,,void
146599,BLOCK,-1,,"{
      if (prefix.length() > id.length()) {
        continue;
      }
      if (id.find(prefix) == 0 &&
          builtin_categories.can_be_required.count(id) == 0) {
        builtin_categories.cannot_be_required.emplace(id);
      }
    }",41,,136,3,,void
146610,BLOCK,-1,,"{
        continue;
      }",42,,137,2,,void
146630,BLOCK,-1,,"{
        builtin_categories.cannot_be_required.emplace(id);
      }",62,,141,2,,void
146642,BLOCK,-1,,"{
    const std::string& id = x.first;
    if (0 == builtin_categories.cannot_be_required.count(id)) {
      builtin_categories.can_be_required.emplace(id);
    }
  }",33,,147,3,,void
146659,BLOCK,-1,,"{
      builtin_categories.can_be_required.emplace(id);
    }",63,,149,2,,void
146674,BLOCK,-1,,"{
  auto source = source_.read();
#ifndef NODE_BUILTIN_MODULES_PATH
  const auto source_it = source->find(id);
  if (UNLIKELY(source_it == source->end())) {
    fprintf(stderr, ""Cannot find native builtin: \""%s\"".\n"", id);
    ABORT();
  }
  return source_it->second.ToStringChecked(isolate);
#else   // !NODE_BUILTIN_MODULES_PATH
  std::string filename = OnDiskFileName(id);

  std::string contents;
  int r = ReadFileSync(&contents, filename.c_str());
  if (r != 0) {
    const std::string buf = SPrintF(""Cannot read local builtin. %s: %s \""%s\"""",
                                    uv_err_name(r),
                                    uv_strerror(r),
                                    filename);
    Local<String> message = OneByteString(isolate, buf.c_str());
    isolate->ThrowException(v8::Exception::Error(message));
    return MaybeLocal<String>();
  }
  return String::NewFromUtf8(
      isolate, contents.c_str(), v8::NewStringType::kNormal, contents.length());
#endif  // NODE_BUILTIN...",75,,175,3,,void
146698,BLOCK,-1,,"{
    fprintf(stderr, ""Cannot find native builtin: \""%s\"".\n"", id);
    ABORT();
  }",45,,179,2,,void
146720,BLOCK,-1,,"{
  StaticExternalTwoByteResource* resource;
  {
    Mutex::ScopedLock lock(externalized_builtins_mutex);
    auto it = externalized_builtin_sources.find(id);
    if (it == externalized_builtin_sources.end()) {
      std::string source;
      int r = ReadFileSync(&source, filename);
      if (r != 0) {
        fprintf(stderr,
                ""Cannot load externalized builtin: \""%s:%s\"".\n"",
                id,
                filename);
        ABORT();
      }
      size_t expected_u16_length =
          simdutf::utf16_length_from_utf8(source.data(), source.length());
      auto out = std::make_shared<std::vector<uint16_t>>(expected_u16_length);
      size_t u16_length = simdutf::convert_utf8_to_utf16(
          source.data(),
          source.length(),
          reinterpret_cast<char16_t*>(out->data()));
      out->resize(u16_length);

      auto result = externalized_builtin_sources.emplace(
          id,
          std::make_unique<StaticExternalTwoByteResource>(
              ou...",66,,210,3,,void
146722,BLOCK,2,,"{
    Mutex::ScopedLock lock(externalized_builtins_mutex);
    auto it = externalized_builtin_sources.find(id);
    if (it == externalized_builtin_sources.end()) {
      std::string source;
      int r = ReadFileSync(&source, filename);
      if (r != 0) {
        fprintf(stderr,
                ""Cannot load externalized builtin: \""%s:%s\"".\n"",
                id,
                filename);
        ABORT();
      }
      size_t expected_u16_length =
          simdutf::utf16_length_from_utf8(source.data(), source.length());
      auto out = std::make_shared<std::vector<uint16_t>>(expected_u16_length);
      size_t u16_length = simdutf::convert_utf8_to_utf16(
          source.data(),
          source.length(),
          reinterpret_cast<char16_t*>(out->data()));
      out->resize(u16_length);

      auto result = externalized_builtin_sources.emplace(
          id,
          std::make_unique<StaticExternalTwoByteResource>(
              out->data(), out->size(), out));
      CHECK(resu...",3,,212,2,,void
146741,BLOCK,-1,,"{
      std::string source;
      int r = ReadFileSync(&source, filename);
      if (r != 0) {
        fprintf(stderr,
                ""Cannot load externalized builtin: \""%s:%s\"".\n"",
                id,
                filename);
        ABORT();
      }
      size_t expected_u16_length =
          simdutf::utf16_length_from_utf8(source.data(), source.length());
      auto out = std::make_shared<std::vector<uint16_t>>(expected_u16_length);
      size_t u16_length = simdutf::convert_utf8_to_utf16(
          source.data(),
          source.length(),
          reinterpret_cast<char16_t*>(out->data()));
      out->resize(u16_length);

      auto result = externalized_builtin_sources.emplace(
          id,
          std::make_unique<StaticExternalTwoByteResource>(
              out->data(), out->size(), out));
      CHECK(result.second);
      it = result.first;
    }",51,,215,2,,void
146754,BLOCK,-1,,"{
        fprintf(stderr,
                ""Cannot load externalized builtin: \""%s:%s\"".\n"",
                id,
                filename);
        ABORT();
      }",19,,218,2,,void
146869,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  EscapableHandleScope scope(isolate);

  Local<String> source;
  if (!LoadBuiltinSource(isolate, id).ToLocal(&source)) {
    return {};
  }

  std::string filename_s = std::string(""node:"") + id;
  Local<String> filename =
      OneByteString(isolate, filename_s.c_str(), filename_s.size());
  ScriptOrigin origin(isolate, filename, 0, 0, true);

  BuiltinCodeCacheData cached_data{};
  {
    // Note: The lock here should not extend into the
    // `CompileFunction()` call below, because this function may recurse if
    // there is a syntax error during bootstrap (because the fatal exception
    // handler is invoked, which may load built-in modules).
    RwLock::ScopedLock lock(code_cache_->mutex);
    auto cache_it = code_cache_->map.find(id);
    if (cache_it != code_cache_->map.end()) {
      // Transfer ownership to ScriptCompiler::Source later.
      cached_data = cache_it->second;
    }
  }

  const bool has_cache = cached_data.data ...",36,,254,5,,void
146895,BLOCK,-1,,"{
    return {};
  }",57,,259,2,,void
146934,BLOCK,14,,"{
    // Note: The lock here should not extend into the
    // `CompileFunction()` call below, because this function may recurse if
    // there is a syntax error during bootstrap (because the fatal exception
    // handler is invoked, which may load built-in modules).
    RwLock::ScopedLock lock(code_cache_->mutex);
    auto cache_it = code_cache_->map.find(id);
    if (cache_it != code_cache_->map.end()) {
      // Transfer ownership to ScriptCompiler::Source later.
      cached_data = cache_it->second;
    }
  }",3,,269,14,,void
146959,BLOCK,-1,,"{
      // Transfer ownership to ScriptCompiler::Source later.
      cached_data = cache_it->second;
    }",45,,276,2,,void
147048,BLOCK,-1,,"{
    // In the case of early errors, v8 is already capable of
    // decorating the stack for us - note that we use CompileFunction
    // so there is no need to worry about wrappers.
    return MaybeLocal<Function>();
  }",33,,308,2,,void
147072,BLOCK,-1,,"{
    per_process::Debug(DebugCategory::CODE_CACHE,
                       ""Code cache of %s (%s) %s\n"",
                       id,
                       script_source.GetCachedData()->buffer_policy ==
                               ScriptCompiler::CachedData::BufferNotOwned
                           ? ""BufferNotOwned""
                           : ""BufferOwned"",
                       script_source.GetCachedData()->rejected ? ""is rejected""
                                                               : ""is accepted"");
  }",18,,324,2,,void
147113,BLOCK,-1,,"{
    // We failed to accept this cache, maybe because it was rejected, maybe
    // because it wasn't present. Either way, we'll attempt to replace this
    // code cache info with a new one.
    std::shared_ptr<ScriptCompiler::CachedData> new_cached_data(
        ScriptCompiler::CreateCodeCacheForFunction(fun));
    CHECK_NOT_NULL(new_cached_data);

    {
      RwLock::ScopedLock lock(code_cache_->mutex);
      code_cache_->map.insert_or_assign(
          id, BuiltinCodeCacheData(std::move(new_cached_data)));
    }
  }",41,,336,2,,void
147116,BLOCK,-1,,<empty>,,,,2,,<empty>
147121,BLOCK,3,,"{
      RwLock::ScopedLock lock(code_cache_->mutex);
      code_cache_->map.insert_or_assign(
          id, BuiltinCodeCacheData(std::move(new_cached_data)));
    }",5,,344,3,,void
147152,BLOCK,-1,,"{
  Result result;
  std::vector<Local<String>> parameters;
  Isolate* isolate = context->GetIsolate();
  // Detects parameters of the scripts based on module ids.
  // internal/bootstrap/realm: process, getLinkedBinding,
  //                           getInternalBinding, primordials
  if (strcmp(id, ""internal/bootstrap/realm"") == 0) {
    parameters = {
        FIXED_ONE_BYTE_STRING(isolate, ""process""),
        FIXED_ONE_BYTE_STRING(isolate, ""getLinkedBinding""),
        FIXED_ONE_BYTE_STRING(isolate, ""getInternalBinding""),
        FIXED_ONE_BYTE_STRING(isolate, ""primordials""),
    };
  } else if (strncmp(id,
                     ""internal/per_context/"",
                     strlen(""internal/per_context/"")) == 0) {
    // internal/per_context/*: global, exports, primordials
    parameters = {
        FIXED_ONE_BYTE_STRING(isolate, ""exports""),
        FIXED_ONE_BYTE_STRING(isolate, ""primordials""),
    };
  } else if (strncmp(id, ""internal/main/"", strlen(""internal/main/"")) == 0 ||
   ...",77,,356,4,,void
147176,BLOCK,-1,,"{
    parameters = {
        FIXED_ONE_BYTE_STRING(isolate, ""process""),
        FIXED_ONE_BYTE_STRING(isolate, ""getLinkedBinding""),
        FIXED_ONE_BYTE_STRING(isolate, ""getInternalBinding""),
        FIXED_ONE_BYTE_STRING(isolate, ""primordials""),
    };
  }",52,,363,2,,void
147180,BLOCK,-1,,<empty>,10,,370,1,,void
147189,BLOCK,-1,,"{
    // internal/per_context/*: global, exports, primordials
    parameters = {
        FIXED_ONE_BYTE_STRING(isolate, ""exports""),
        FIXED_ONE_BYTE_STRING(isolate, ""primordials""),
    };
  }",61,,372,2,,void
147193,BLOCK,-1,,<empty>,10,,378,1,,void
147210,BLOCK,-1,,"{
    // internal/main/*, internal/bootstrap/*: process, require,
    //                                        internalBinding, primordials
    parameters = {
        FIXED_ONE_BYTE_STRING(isolate, ""process""),
        FIXED_ONE_BYTE_STRING(isolate, ""require""),
        FIXED_ONE_BYTE_STRING(isolate, ""internalBinding""),
        FIXED_ONE_BYTE_STRING(isolate, ""primordials""),
    };
  }",59,,381,2,,void
147214,BLOCK,-1,,"{
    // others: exports, require, module, process, internalBinding, primordials
    parameters = {
        FIXED_ONE_BYTE_STRING(isolate, ""exports""),
        FIXED_ONE_BYTE_STRING(isolate, ""require""),
        FIXED_ONE_BYTE_STRING(isolate, ""module""),
        FIXED_ONE_BYTE_STRING(isolate, ""process""),
        FIXED_ONE_BYTE_STRING(isolate, ""internalBinding""),
        FIXED_ONE_BYTE_STRING(isolate, ""primordials""),
    };
  }",10,,390,1,,void
147234,BLOCK,-1,,"{
    DCHECK_EQ(this, optional_realm->env()->builtin_loader());
    RecordResult(id, result, optional_realm);
  }",34,,404,2,,void
147256,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  // Arguments must match the parameters specified in
  // BuiltinLoader::LookupAndCompile().
  std::vector<Local<Value>> arguments;
  // Detects parameters of the scripts based on module ids.
  // internal/bootstrap/realm: process, getLinkedBinding,
  //                           getInternalBinding, primordials
  if (strcmp(id, ""internal/bootstrap/realm"") == 0) {
    Local<Value> get_linked_binding;
    Local<Value> get_internal_binding;
    if (!NewFunctionTemplate(isolate, binding::GetLinkedBinding)
             ->GetFunction(context)
             .ToLocal(&get_linked_binding) ||
        !NewFunctionTemplate(isolate, binding::GetInternalBinding)
             ->GetFunction(context)
             .ToLocal(&get_internal_binding)) {
      return MaybeLocal<Value>();
    }
    arguments = {realm->process_object(),
                 get_linked_binding,
                 get_internal_binding,
                 realm->primordials()};
  } else if ...",63,,413,4,,void
147279,BLOCK,-1,,"{
    Local<Value> get_linked_binding;
    Local<Value> get_internal_binding;
    if (!NewFunctionTemplate(isolate, binding::GetLinkedBinding)
             ->GetFunction(context)
             .ToLocal(&get_linked_binding) ||
        !NewFunctionTemplate(isolate, binding::GetInternalBinding)
             ->GetFunction(context)
             .ToLocal(&get_internal_binding)) {
      return MaybeLocal<Value>();
    }
    arguments = {realm->process_object(),
                 get_linked_binding,
                 get_internal_binding,
                 realm->primordials()};
  }",52,,421,2,,void
147322,BLOCK,-1,,"{
      return MaybeLocal<Value>();
    }",47,,429,2,,void
147328,BLOCK,-1,,<empty>,10,,436,1,,void
147345,BLOCK,-1,,"{
    // internal/main/*, internal/bootstrap/*: process, require,
    //                                        internalBinding, primordials
    arguments = {realm->process_object(),
                 realm->builtin_module_require(),
                 realm->internal_binding_loader(),
                 realm->primordials()};
  }",59,,439,2,,void
147349,BLOCK,-1,,"{
    // This should be invoked with the other CompileAndCall() methods, as
    // we are unable to generate the arguments.
    // Currently there are two cases:
    // internal/per_context/*: the arguments are generated in
    //                         InitializePrimordials()
    // all the other cases: the arguments are generated in the JS-land loader.
    UNREACHABLE();
  }",10,,446,1,,void
147372,BLOCK,-1,,"{
  // Arguments must match the parameters specified in
  // BuiltinLoader::LookupAndCompile().
  MaybeLocal<Function> maybe_fn = LookupAndCompile(context, id, optional_realm);
  Local<Function> fn;
  if (!maybe_fn.ToLocal(&fn)) {
    return MaybeLocal<Value>();
  }
  Local<Value> undefined = Undefined(context->GetIsolate());
  return fn->Call(context, undefined, argc, argv);
}",72,,462,6,,void
147396,BLOCK,-1,,"{
    return MaybeLocal<Value>();
  }",31,,467,2,,void
147423,BLOCK,-1,,"{
  std::vector<std::string> ids = GetBuiltinIds();
  bool all_succeeded = true;
  std::string v8_tools_prefix = ""internal/deps/v8/tools/"";
  for (const auto& id : ids) {
    if (id.compare(0, v8_tools_prefix.size(), v8_tools_prefix) == 0) {
      continue;
    }
    v8::TryCatch bootstrapCatch(context->GetIsolate());
    USE(LookupAndCompile(context, id.c_str(), nullptr));
    if (bootstrapCatch.HasCaught()) {
      per_process::Debug(DebugCategory::CODE_CACHE,
                         ""Failed to compile code cache for %s\n"",
                         id.c_str());
      all_succeeded = false;
      PrintCaughtException(context->GetIsolate(), context, bootstrapCatch);
    }
  }
  return all_succeeded;
}",64,,474,2,,void
147446,BLOCK,-1,,"{
    if (id.compare(0, v8_tools_prefix.size(), v8_tools_prefix) == 0) {
      continue;
    }
    v8::TryCatch bootstrapCatch(context->GetIsolate());
    USE(LookupAndCompile(context, id.c_str(), nullptr));
    if (bootstrapCatch.HasCaught()) {
      per_process::Debug(DebugCategory::CODE_CACHE,
                         ""Failed to compile code cache for %s\n"",
                         id.c_str());
      all_succeeded = false;
      PrintCaughtException(context->GetIsolate(), context, bootstrapCatch);
    }
  }",30,,478,3,,void
147460,BLOCK,-1,,"{
      continue;
    }",70,,479,2,,void
147481,BLOCK,-1,,"{
      per_process::Debug(DebugCategory::CODE_CACHE,
                         ""Failed to compile code cache for %s\n"",
                         id.c_str());
      all_succeeded = false;
      PrintCaughtException(context->GetIsolate(), context, bootstrapCatch);
    }",37,,484,2,,void
147510,BLOCK,-1,,"{
  RwLock::ScopedReadLock lock(code_cache_->mutex);
  for (auto const& item : code_cache_->map) {
    out->push_back({item.first, item.second});
  }
}",74,,495,2,,void
147521,BLOCK,-1,,"{
    out->push_back({item.first, item.second});
  }",45,,497,3,,void
147537,BLOCK,-1,,"{
  RwLock::ScopedLock lock(code_cache_->mutex);
  code_cache_->map.reserve(in.size());
  DCHECK(code_cache_->map.empty());
  for (auto const& item : in) {
    auto result = code_cache_->map.emplace(item.id, item.data);
    USE(result.second);
    DCHECK(result.second);
  }
  code_cache_->has_code_cache = true;
}",76,,502,2,,void
147563,BLOCK,-1,,"{
    auto result = code_cache_->map.emplace(item.id, item.data);
    USE(result.second);
    DCHECK(result.second);
  }",31,,506,3,,void
147597,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();
  Local<Object> result = Object::New(isolate);

  BuiltinCategories builtin_categories =
      env->builtin_loader()->GetBuiltinCategories();

  if (!env->owns_process_state()) {
    builtin_categories.can_be_required.erase(""trace_events"");
    builtin_categories.cannot_be_required.insert(""trace_events"");
  }

  Local<Value> cannot_be_required_js;
  Local<Value> can_be_required_js;

  if (!ToV8Value(context, builtin_categories.cannot_be_required)
           .ToLocal(&cannot_be_required_js))
    return;
  if (result
          ->Set(context,
                OneByteString(isolate, ""cannotBeRequired""),
                cannot_be_required_js)
          .IsNothing())
    return;
  if (!ToV8Value(context, builtin_categories.can_be_required)
           .ToLocal(&can_be_required_js))
    return;
  if (result
          ->Set(context,
                OneByteStrin...",68,,515,3,,void
147650,BLOCK,-1,,"{
    builtin_categories.can_be_required.erase(""trace_events"");
    builtin_categories.cannot_be_required.insert(""trace_events"");
  }",35,,524,2,,void
147687,BLOCK,-1,,<empty>,5,,534,2,,void
147702,BLOCK,-1,,<empty>,5,,540,2,,void
147716,BLOCK,-1,,<empty>,5,,543,2,,void
147731,BLOCK,-1,,"{
    return;
  }",25,,548,2,,void
147745,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(args);
  Isolate* isolate = realm->isolate();
  Local<Context> context = realm->context();
  Local<Object> result = Object::New(isolate);

  Local<Value> builtins_with_cache_js;
  Local<Value> builtins_without_cache_js;
  Local<Value> builtins_in_snapshot_js;
  if (!ToV8Value(context, realm->builtins_with_cache)
           .ToLocal(&builtins_with_cache_js)) {
    return;
  }
  if (result
          ->Set(context,
                OneByteString(isolate, ""compiledWithCache""),
                builtins_with_cache_js)
          .IsNothing()) {
    return;
  }

  if (!ToV8Value(context, realm->builtins_without_cache)
           .ToLocal(&builtins_without_cache_js)) {
    return;
  }
  if (result
          ->Set(context,
                OneByteString(isolate, ""compiledWithoutCache""),
                builtins_without_cache_js)
          .IsNothing()) {
    return;
  }

  if (!ToV8Value(context, realm->builtins_in_snapshot)
           .ToLocal(&builtins_in_...",76,,554,2,,void
147809,BLOCK,-1,,"{
    return;
  }",47,,564,2,,void
147824,BLOCK,-1,,"{
    return;
  }",25,,571,2,,void
147838,BLOCK,-1,,"{
    return;
  }",50,,576,2,,void
147853,BLOCK,-1,,"{
    return;
  }",25,,583,2,,void
147867,BLOCK,-1,,"{
    return;
  }",48,,588,2,,void
147882,BLOCK,-1,,"{
    return;
  }",25,,595,2,,void
147897,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  Isolate* isolate = env->isolate();

  std::vector<std::string> ids = env->builtin_loader()->GetBuiltinIds();
  info.GetReturnValue().Set(
      ToV8Value(isolate->GetCurrentContext(), ids).ToLocalChecked());
}",79,,603,3,,void
147951,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  info.GetReturnValue().Set(
      env->builtin_loader()->GetConfigString(info.GetIsolate()));
}",68,,613,3,,void
147984,BLOCK,-1,,"{
  if (result == BuiltinLoader::Result::kWithCache) {
    realm->builtins_with_cache.insert(id);
  } else {
    realm->builtins_without_cache.insert(id);
  }
}",48,,621,4,,void
147993,BLOCK,-1,,"{
    realm->builtins_with_cache.insert(id);
  }",52,,622,2,,void
148002,BLOCK,-1,,"{
    realm->builtins_without_cache.insert(id);
  }",10,,624,1,,void
148014,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(args);
  CHECK(args[0]->IsString());
  node::Utf8Value id_v(realm->isolate(), args[0].As<String>());
  const char* id = *id_v;
  MaybeLocal<Function> maybe = realm->env()->builtin_loader()->LookupAndCompile(
      realm->context(), id, realm);
  Local<Function> fn;
  if (maybe.ToLocal(&fn)) {
    args.GetReturnValue().Set(fn);
  }
}",78,,629,2,,void
148081,BLOCK,-1,,"{
    args.GetReturnValue().Set(fn);
  }",27,,637,2,,void
148094,BLOCK,-1,,"{
  auto instance = Environment::GetCurrent(args)->builtin_loader();
  RwLock::ScopedReadLock lock(instance->code_cache_->mutex);
  args.GetReturnValue().Set(v8::Boolean::New(
      args.GetIsolate(), instance->code_cache_->has_code_cache));
}",80,,642,2,,void
148139,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  CHECK(args[1]->IsFunction());
  DCHECK(realm->internal_binding_loader().IsEmpty());
  DCHECK(realm->builtin_module_require().IsEmpty());
  realm->set_internal_binding_loader(args[0].As<Function>());
  realm->set_builtin_module_require(args[1].As<Function>());
}",66,,649,2,,void
148202,BLOCK,-1,,"{
  code_cache_ = other->code_cache_;
  source_ = other->source_;
}",33,,660,2,,void
148218,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();
  Local<ObjectTemplate> proto = target->PrototypeTemplate();

  proto->SetAccessor(isolate_data->config_string(),
                     ConfigStringGetter,
                     nullptr,
                     Local<Value>(),
                     DEFAULT,
                     None,
                     SideEffectType::kHasNoSideEffect);

  proto->SetAccessor(FIXED_ONE_BYTE_STRING(isolate, ""builtinIds""),
                     BuiltinIdsGetter,
                     nullptr,
                     Local<Value>(),
                     DEFAULT,
                     None,
                     SideEffectType::kHasNoSideEffect);

  proto->SetAccessor(FIXED_ONE_BYTE_STRING(isolate, ""builtinCategories""),
                     GetBuiltinCategories,
                     nullptr,
                     Local<Value>(),
                     DEFAULT,
                     None,
                     SideEffectType::kHasNoSideEffect);

  SetMethod(isolate, proto, ...",80,,666,3,,void
148313,BLOCK,-1,,"{
  // internalBinding('builtins') should be frozen
  target->SetIntegrityLevel(context, IntegrityLevel::kFrozen).FromJust();
}",60,,703,5,,void
148329,BLOCK,-1,,"{
  registry->Register(ConfigStringGetter);
  registry->Register(BuiltinIdsGetter);
  registry->Register(GetBuiltinCategories);
  registry->Register(GetCacheUsage);
  registry->Register(CompileFunction);
  registry->Register(HasCachedBuiltins);
  registry->Register(SetInternalLoaders);

  RegisterExternalReferencesForInternalizedBuiltinCode(registry);
}",42,,709,2,,void
148398,BLOCK,-1,,<empty>,1,,1,1,,ANY
148417,BLOCK,-1,,<empty>,1,,1,1,,ANY
148424,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

#if defined(DEBUG) && DEBUG
  READONLY_TRUE_PROPERTY(target, ""isDebugBuild"");
#else
  READONLY_FALSE_PROPERTY(target, ""isDebugBuild"");
#endif  // defined(DEBUG) && DEBUG

#if HAVE_OPENSSL
  READONLY_TRUE_PROPERTY(target, ""hasOpenSSL"");
#else
  READONLY_FALSE_PROPERTY(target, ""hasOpenSSL"");
#endif  // HAVE_OPENSSL

  READONLY_TRUE_PROPERTY(target, ""fipsMode"");

#ifdef NODE_HAVE_I18N_SUPPORT

  READONLY_TRUE_PROPERTY(target, ""hasIntl"");

#ifdef NODE_HAVE_SMALL_ICU
  READONLY_TRUE_PROPERTY(target, ""hasSmallICU"");
#endif  // NODE_HAVE_SMALL_ICU

#if NODE_USE_V8_PLATFORM
  READONLY_TRUE_PROPERTY(target, ""hasTracing"");
#endif

#if !defined(NODE_WITHOUT_NODE_OPTIONS)
  READONLY_TRUE_PROPERTY(target, ""hasNodeOptions"");
#endif

#endif  // NODE_HAVE_I18N_SUPPORT

#if HAVE_INSPECTOR
  READONLY_TRUE_PROPERTY(target, ""hasInspector"");
#else
  READONLY_FALSE_PROPERTY(target, ""hasInspector"");
#endif

// c...",36,,29,5,,void
148508,BLOCK,-1,,<empty>,1,,1,1,,ANY
148513,BLOCK,-1,,"{
#ifdef E2BIG
  NODE_DEFINE_CONSTANT(target, E2BIG);
#endif

#ifdef EACCES
  NODE_DEFINE_CONSTANT(target, EACCES);
#endif

#ifdef EADDRINUSE
  NODE_DEFINE_CONSTANT(target, EADDRINUSE);
#endif

#ifdef EADDRNOTAVAIL
  NODE_DEFINE_CONSTANT(target, EADDRNOTAVAIL);
#endif

#ifdef EAFNOSUPPORT
  NODE_DEFINE_CONSTANT(target, EAFNOSUPPORT);
#endif

#ifdef EAGAIN
  NODE_DEFINE_CONSTANT(target, EAGAIN);
#endif

#ifdef EALREADY
  NODE_DEFINE_CONSTANT(target, EALREADY);
#endif

#ifdef EBADF
  NODE_DEFINE_CONSTANT(target, EBADF);
#endif

#ifdef EBADMSG
  NODE_DEFINE_CONSTANT(target, EBADMSG);
#endif

#ifdef EBUSY
  NODE_DEFINE_CONSTANT(target, EBUSY);
#endif

#ifdef ECANCELED
  NODE_DEFINE_CONSTANT(target, ECANCELED);
#endif

#ifdef ECHILD
  NODE_DEFINE_CONSTANT(target, ECHILD);
#endif

#ifdef ECONNABORTED
  NODE_DEFINE_CONSTANT(target, ECONNABORTED);
#endif

#ifdef ECONNREFUSED
  NODE_DEFINE_CONSTANT(target, ECONNREFUSED);
#endif

#ifdef ECONNRESET
  NODE_DEFINE_CONSTANT(target, ECONNRESET);
#...",49,,71,2,,void
148518,BLOCK,-1,,"{
#ifdef WSAEINTR
  NODE_DEFINE_CONSTANT(target, WSAEINTR);
#endif

#ifdef WSAEBADF
  NODE_DEFINE_CONSTANT(target, WSAEBADF);
#endif

#ifdef WSAEACCES
  NODE_DEFINE_CONSTANT(target, WSAEACCES);
#endif

#ifdef WSAEFAULT
  NODE_DEFINE_CONSTANT(target, WSAEFAULT);
#endif

#ifdef WSAEINVAL
  NODE_DEFINE_CONSTANT(target, WSAEINVAL);
#endif

#ifdef WSAEMFILE
  NODE_DEFINE_CONSTANT(target, WSAEMFILE);
#endif

#ifdef WSAEWOULDBLOCK
  NODE_DEFINE_CONSTANT(target, WSAEWOULDBLOCK);
#endif

#ifdef WSAEINPROGRESS
  NODE_DEFINE_CONSTANT(target, WSAEINPROGRESS);
#endif

#ifdef WSAEALREADY
  NODE_DEFINE_CONSTANT(target, WSAEALREADY);
#endif

#ifdef WSAENOTSOCK
  NODE_DEFINE_CONSTANT(target, WSAENOTSOCK);
#endif

#ifdef WSAEDESTADDRREQ
  NODE_DEFINE_CONSTANT(target, WSAEDESTADDRREQ);
#endif

#ifdef WSAEMSGSIZE
  NODE_DEFINE_CONSTANT(target, WSAEMSGSIZE);
#endif

#ifdef WSAEPROTOTYPE
  NODE_DEFINE_CONSTANT(target, WSAEPROTOTYPE);
#endif

#ifdef WSAENOPROTOOPT
  NODE_DEFINE_CONSTANT(target, WSAENOPROT...",56,,389,2,,void
148523,BLOCK,-1,,"{
#ifdef SIGHUP
  NODE_DEFINE_CONSTANT(target, SIGHUP);
#endif

#ifdef SIGINT
  NODE_DEFINE_CONSTANT(target, SIGINT);
#endif

#ifdef SIGQUIT
  NODE_DEFINE_CONSTANT(target, SIGQUIT);
#endif

#ifdef SIGILL
  NODE_DEFINE_CONSTANT(target, SIGILL);
#endif

#ifdef SIGTRAP
  NODE_DEFINE_CONSTANT(target, SIGTRAP);
#endif

#ifdef SIGABRT
  NODE_DEFINE_CONSTANT(target, SIGABRT);
#endif

#ifdef SIGIOT
  NODE_DEFINE_CONSTANT(target, SIGIOT);
#endif

#ifdef SIGBUS
  NODE_DEFINE_CONSTANT(target, SIGBUS);
#endif

#ifdef SIGFPE
  NODE_DEFINE_CONSTANT(target, SIGFPE);
#endif

#ifdef SIGKILL
  NODE_DEFINE_CONSTANT(target, SIGKILL);
#endif

#ifdef SIGUSR1
  NODE_DEFINE_CONSTANT(target, SIGUSR1);
#endif

#ifdef SIGSEGV
  NODE_DEFINE_CONSTANT(target, SIGSEGV);
#endif

#ifdef SIGUSR2
  NODE_DEFINE_CONSTANT(target, SIGUSR2);
#endif

#ifdef SIGPIPE
  NODE_DEFINE_CONSTANT(target, SIGPIPE);
#endif

#ifdef SIGALRM
  NODE_DEFINE_CONSTANT(target, SIGALRM);
#endif

  NODE_DEFINE_CONSTANT(target, SIGTERM);

#ifde...",50,,623,2,,void
148531,BLOCK,-1,,"{
#ifdef UV_PRIORITY_LOW
# define PRIORITY_LOW UV_PRIORITY_LOW
  NODE_DEFINE_CONSTANT(target, PRIORITY_LOW);
# undef PRIORITY_LOW
#endif

#ifdef UV_PRIORITY_BELOW_NORMAL
# define PRIORITY_BELOW_NORMAL UV_PRIORITY_BELOW_NORMAL
  NODE_DEFINE_CONSTANT(target, PRIORITY_BELOW_NORMAL);
# undef PRIORITY_BELOW_NORMAL
#endif

#ifdef UV_PRIORITY_NORMAL
# define PRIORITY_NORMAL UV_PRIORITY_NORMAL
  NODE_DEFINE_CONSTANT(target, PRIORITY_NORMAL);
# undef PRIORITY_NORMAL
#endif

#ifdef UV_PRIORITY_ABOVE_NORMAL
# define PRIORITY_ABOVE_NORMAL UV_PRIORITY_ABOVE_NORMAL
  NODE_DEFINE_CONSTANT(target, PRIORITY_ABOVE_NORMAL);
# undef PRIORITY_ABOVE_NORMAL
#endif

#ifdef UV_PRIORITY_HIGH
# define PRIORITY_HIGH UV_PRIORITY_HIGH
  NODE_DEFINE_CONSTANT(target, PRIORITY_HIGH);
# undef PRIORITY_HIGH
#endif

#ifdef UV_PRIORITY_HIGHEST
# define PRIORITY_HIGHEST UV_PRIORITY_HIGHEST
  NODE_DEFINE_CONSTANT(target, PRIORITY_HIGHEST);
# undef PRIORITY_HIGHEST
#endif
}",52,,772,2,,void
148536,BLOCK,-1,,"{
#ifdef OPENSSL_VERSION_NUMBER
    NODE_DEFINE_CONSTANT(target, OPENSSL_VERSION_NUMBER);
#endif

#ifdef SSL_OP_ALL
    NODE_DEFINE_CONSTANT(target, SSL_OP_ALL);
#endif

#ifdef SSL_OP_ALLOW_NO_DHE_KEX
    NODE_DEFINE_CONSTANT(target, SSL_OP_ALLOW_NO_DHE_KEX);
#endif

#ifdef SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION
    NODE_DEFINE_CONSTANT(target, SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION);
#endif

#ifdef SSL_OP_CIPHER_SERVER_PREFERENCE
    NODE_DEFINE_CONSTANT(target, SSL_OP_CIPHER_SERVER_PREFERENCE);
#endif

#ifdef SSL_OP_CISCO_ANYCONNECT
    NODE_DEFINE_CONSTANT(target, SSL_OP_CISCO_ANYCONNECT);
#endif

#ifdef SSL_OP_COOKIE_EXCHANGE
    NODE_DEFINE_CONSTANT(target, SSL_OP_COOKIE_EXCHANGE);
#endif

#ifdef SSL_OP_CRYPTOPRO_TLSEXT_BUG
    NODE_DEFINE_CONSTANT(target, SSL_OP_CRYPTOPRO_TLSEXT_BUG);
#endif

#ifdef SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS
    NODE_DEFINE_CONSTANT(target, SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS);
#endif

#ifdef SSL_OP_LEGACY_SERVER_CONNECT
    NODE_DEFINE_CONSTANT(ta...",50,,810,2,,void
148541,BLOCK,-1,,"{
  NODE_DEFINE_CONSTANT(target, UV_FS_SYMLINK_DIR);
  NODE_DEFINE_CONSTANT(target, UV_FS_SYMLINK_JUNCTION);
  // file access modes
  NODE_DEFINE_CONSTANT(target, O_RDONLY);
  NODE_DEFINE_CONSTANT(target, O_WRONLY);
  NODE_DEFINE_CONSTANT(target, O_RDWR);

  // file types from readdir
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_UNKNOWN);
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_FILE);
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_DIR);
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_LINK);
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_FIFO);
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_SOCKET);
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_CHAR);
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_BLOCK);

  NODE_DEFINE_CONSTANT(target, S_IFMT);
  NODE_DEFINE_CONSTANT(target, S_IFREG);
  NODE_DEFINE_CONSTANT(target, S_IFDIR);
  NODE_DEFINE_CONSTANT(target, S_IFCHR);
#ifdef S_IFBLK
  NODE_DEFINE_CONSTANT(target, S_IFBLK);
#endif

#ifdef S_IFIFO
  NODE_DEFINE_CONSTANT(target, S_IFIFO);
#endif

#ifdef S_IFLNK
  NODE_DEFINE_C...",50,,1039,2,,void
148600,BLOCK,-1,,"{
#ifdef RTLD_LAZY
  NODE_DEFINE_CONSTANT(target, RTLD_LAZY);
#endif

#ifdef RTLD_NOW
  NODE_DEFINE_CONSTANT(target, RTLD_NOW);
#endif

#ifdef RTLD_GLOBAL
  NODE_DEFINE_CONSTANT(target, RTLD_GLOBAL);
#endif

#ifdef RTLD_LOCAL
  NODE_DEFINE_CONSTANT(target, RTLD_LOCAL);
#endif

#ifdef RTLD_DEEPBIND
  NODE_DEFINE_CONSTANT(target, RTLD_DEEPBIND);
#endif
}",50,,1222,2,,void
148605,BLOCK,-1,,"{
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_BEGIN);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_END);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_COMPLETE);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_INSTANT);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_ASYNC_BEGIN);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_ASYNC_STEP_INTO);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_ASYNC_STEP_PAST);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_ASYNC_END);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_NESTABLE_ASYNC_END);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_NESTABLE_ASYNC_INSTANT);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_FLOW_BEGIN);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_FLOW_STEP);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_FLOW_END);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_METADATA);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHAS...",49,,1244,2,,void
148689,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(isolate);

  Local<Object> os_constants = Object::New(isolate);
  CHECK(os_constants->SetPrototype(env->context(),
                                   Null(env->isolate())).FromJust());

  Local<Object> err_constants = Object::New(isolate);
  CHECK(err_constants->SetPrototype(env->context(),
                                    Null(env->isolate())).FromJust());

  Local<Object> sig_constants = Object::New(isolate);
  CHECK(sig_constants->SetPrototype(env->context(),
                                    Null(env->isolate())).FromJust());

  Local<Object> priority_constants = Object::New(isolate);
  CHECK(priority_constants->SetPrototype(env->context(),
                                         Null(env->isolate())).FromJust());

  Local<Object> fs_constants = Object::New(isolate);
  CHECK(fs_constants->SetPrototype(env->context(),
                                   Null(env->isolate())).FromJust());

  Local<Object> crypto_constants = Objec...",66,,1275,3,,void
149108,BLOCK,-1,,<empty>,1,,1,1,,ANY
149117,BLOCK,-1,,<empty>,1,,1,1,,ANY
149121,BLOCK,-1,,"{
        if (desc.has_enumerable()) {
          desc_for_sandbox->set_enumerable(desc.enumerable());
        }
        if (desc.has_configurable()) {
          desc_for_sandbox->set_configurable(desc.configurable());
        }
        // Set the property on the sandbox.
        USE(sandbox->DefineProperty(context, property, *desc_for_sandbox));
      }",50,,597,2,,void
149127,BLOCK,-1,,"{
          desc_for_sandbox->set_enumerable(desc.enumerable());
        }",36,,598,2,,void
149141,BLOCK,-1,,"{
          desc_for_sandbox->set_configurable(desc.configurable());
        }",38,,601,2,,void
149166,BLOCK,-1,,"{
    MaybeLocal<Value> result = script->Run(context);
    if (!result.IsEmpty() && mtask_queue)
      mtask_queue->PerformCheckpoint(env->isolate());
    return result;
  }",20,,1052,1,,void
149186,BLOCK,-1,,<empty>,7,,1055,2,,void
149227,BLOCK,-1,,<empty>,1,,1,1,,ANY
149234,BLOCK,-1,,"{
  return Uint32::New(context->GetIsolate(), index)->ToString(context)
      .ToLocalChecked();
}",66,,105,3,,void
149258,BLOCK,-1,,"{
  HandleScope scope(env->isolate());
  Local<ObjectTemplate> object_template = env->contextify_global_template();
  DCHECK(!object_template.IsEmpty());
  const SnapshotData* snapshot_data = env->isolate_data()->snapshot_data();

  MicrotaskQueue* queue =
      options.microtask_queue_wrap
          ? options.microtask_queue_wrap->microtask_queue().get()
          : env->isolate()->GetCurrentContext()->GetMicrotaskQueue();

  Local<Context> v8_context;
  if (!(CreateV8Context(env->isolate(), object_template, snapshot_data, queue)
            .ToLocal(&v8_context))) {
    // Allocation failure, maximum call stack size reached, termination, etc.
    return BaseObjectPtr<ContextifyContext>();
  }
  return New(v8_context, env, sandbox_obj, options);
}",36,,115,4,,void
149337,BLOCK,-1,,"{
    // Allocation failure, maximum call stack size reached, termination, etc.
    return BaseObjectPtr<ContextifyContext>();
  }",37,,128,2,,void
149350,BLOCK,-1,,"{
  if (microtask_queue_wrap_) {
    tracker->TrackField(""microtask_queue_wrap"",
                        microtask_queue_wrap_->object());
  }
}",66,,135,2,,void
149353,BLOCK,-1,,"{
    tracker->TrackField(""microtask_queue_wrap"",
                        microtask_queue_wrap_->object());
  }",30,,136,2,,void
149370,BLOCK,-1,,"{
  context_.Reset(env->isolate(), v8_context);
  // This should only be done after the initial initializations of the context
  // global object is finished.
  DCHECK_NULL(v8_context->GetAlignedPointerFromEmbedderData(
      ContextEmbedderIndex::kContextifyContext));
  v8_context->SetAlignedPointerInEmbedderData(
      ContextEmbedderIndex::kContextifyContext, this);
  // It's okay to make this reference weak - V8 would create an internal
  // reference to this context via the constructor of the wrapper.
  // As long as the wrapper is alive, it's constructor is alive, and so
  // is the context.
  context_.SetWeak();
}",59,,147,5,,void
149403,BLOCK,-1,,"{
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);

  env()->UntrackContext(PersistentToLocal::Weak(isolate, context_));
  context_.Reset();
}",41,,162,1,,void
149432,BLOCK,-1,,"{
  DCHECK(isolate_data->contextify_wrapper_template().IsEmpty());
  Local<FunctionTemplate> global_func_template =
      FunctionTemplate::New(isolate_data->isolate());
  Local<ObjectTemplate> global_object_template =
      global_func_template->InstanceTemplate();

  NamedPropertyHandlerConfiguration config(
      PropertyGetterCallback,
      PropertySetterCallback,
      PropertyDescriptorCallback,
      PropertyDeleterCallback,
      PropertyEnumeratorCallback,
      PropertyDefinerCallback,
      {},
      PropertyHandlerFlags::kHasNoSideEffect);

  IndexedPropertyHandlerConfiguration indexed_config(
      IndexedPropertyGetterCallback,
      IndexedPropertySetterCallback,
      IndexedPropertyDescriptorCallback,
      IndexedPropertyDeleterCallback,
      PropertyEnumeratorCallback,
      IndexedPropertyDefinerCallback,
      {},
      PropertyHandlerFlags::kHasNoSideEffect);

  global_object_template->SetHandler(config);
  global_object_template->SetHandler(indexed_config);
...",78,,170,2,,void
149537,BLOCK,-1,,"{
  EscapableHandleScope scope(isolate);

  Local<Context> ctx;
  if (snapshot_data == nullptr) {
    ctx = Context::New(isolate,
                       nullptr,  // extensions
                       object_template,
                       {},  // global object
                       {},  // deserialization callback
                       queue);
    if (ctx.IsEmpty() || InitializeBaseContextForSnapshot(ctx).IsNothing()) {
      return MaybeLocal<Context>();
    }
  } else if (!Context::FromSnapshot(isolate,
                                    SnapshotData::kNodeVMContextIndex,
                                    {},       // deserialization callback
                                    nullptr,  // extensions
                                    {},       // global object
                                    queue)
                  .ToLocal(&ctx)) {
    return MaybeLocal<Context>();
  }

  return scope.Escape(ctx);
}",28,,212,5,,void
149550,BLOCK,-1,,"{
    ctx = Context::New(isolate,
                       nullptr,  // extensions
                       object_template,
                       {},  // global object
                       {},  // deserialization callback
                       queue);
    if (ctx.IsEmpty() || InitializeBaseContextForSnapshot(ctx).IsNothing()) {
      return MaybeLocal<Context>();
    }
  }",33,,216,2,,void
149574,BLOCK,-1,,"{
      return MaybeLocal<Context>();
    }",77,,223,2,,void
149578,BLOCK,-1,,<empty>,10,,226,1,,void
149598,BLOCK,-1,,"{
    return MaybeLocal<Context>();
  }",35,,232,2,,void
149614,BLOCK,-1,,"{
  HandleScope scope(env->isolate());
  // This only initializes part of the context. The primordials are
  // only initialized when needed because even deserializing them slows
  // things down significantly and they are only needed in rare occasions
  // in the vm contexts.
  if (InitializeContextRuntime(v8_context).IsNothing()) {
    return BaseObjectPtr<ContextifyContext>();
  }

  Local<Context> main_context = env->context();
  Local<Object> new_context_global = v8_context->Global();
  v8_context->SetSecurityToken(main_context->GetSecurityToken());

  // We need to tie the lifetime of the sandbox object with the lifetime of
  // newly created context. We do this by making them hold references to each
  // other. The context can directly hold a reference to the sandbox as an
  // embedder data field. The sandbox uses a private symbol to hold a reference
  // to the ContextifyContext wrapper which in turn internally references
  // the context from its constructor.
  v8_context-...",36,,243,5,,void
149627,BLOCK,-1,,"{
    return BaseObjectPtr<ContextifyContext>();
  }",57,,249,2,,void
149712,BLOCK,-1,,"{
    Utf8Value origin_val(env->isolate(), options.origin);
    info.origin = *origin_val;
  }",34,,277,2,,void
149738,BLOCK,18,,"{
    Context::Scope context_scope(v8_context);
    Local<String> ctor_name = sandbox_obj->GetConstructorName();
    if (!ctor_name->Equals(v8_context, env->object_string()).FromMaybe(false) &&
        new_context_global
            ->DefineOwnProperty(
                v8_context,
                v8::Symbol::GetToStringTag(env->isolate()),
                ctor_name,
                static_cast<v8::PropertyAttribute>(v8::DontEnum))
            .IsNothing()) {
      return BaseObjectPtr<ContextifyContext>();
    }
    env->AssignToContext(v8_context, nullptr, info);

    if (!env->contextify_wrapper_template()
             ->NewInstance(v8_context)
             .ToLocal(&wrapper)) {
      return BaseObjectPtr<ContextifyContext>();
    }

    result =
        MakeBaseObject<ContextifyContext>(env, wrapper, v8_context, options);
    // The only strong reference to the wrapper will come from the sandbox.
    result->MakeWeak();
  }",3,,284,18,,void
149792,BLOCK,-1,,"{
      return BaseObjectPtr<ContextifyContext>();
    }",27,,294,2,,void
149817,BLOCK,-1,,"{
      return BaseObjectPtr<ContextifyContext>();
    }",34,,301,2,,void
149850,BLOCK,-1,,"{
    return BaseObjectPtr<ContextifyContext>();
  }",25,,314,2,,void
149860,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();
  SetMethod(isolate, target, ""makeContext"", MakeContext);
  SetMethod(isolate, target, ""isContext"", IsContext);
  SetMethod(isolate, target, ""compileFunction"", CompileFunction);
}",62,,322,3,,void
149887,BLOCK,-1,,"{
  registry->Register(MakeContext);
  registry->Register(IsContext);
  registry->Register(CompileFunction);
  registry->Register(PropertyGetterCallback);
  registry->Register(PropertySetterCallback);
  registry->Register(PropertyDescriptorCallback);
  registry->Register(PropertyDeleterCallback);
  registry->Register(PropertyEnumeratorCallback);
  registry->Register(PropertyDefinerCallback);
  registry->Register(IndexedPropertyGetterCallback);
  registry->Register(IndexedPropertySetterCallback);
  registry->Register(IndexedPropertyDescriptorCallback);
  registry->Register(IndexedPropertyDeleterCallback);
  registry->Register(IndexedPropertyDefinerCallback);
}",42,,330,2,,void
149962,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK_EQ(args.Length(), 6);
  CHECK(args[0]->IsObject());
  Local<Object> sandbox = args[0].As<Object>();

  // Don't allow contextifying a sandbox multiple times.
  CHECK(
      !sandbox->HasPrivate(
          env->context(),
          env->contextify_context_private_symbol()).FromJust());

  ContextOptions options;

  CHECK(args[1]->IsString());
  options.name = args[1].As<String>();

  CHECK(args[2]->IsString() || args[2]->IsUndefined());
  if (args[2]->IsString()) {
    options.origin = args[2].As<String>();
  }

  CHECK(args[3]->IsBoolean());
  options.allow_code_gen_strings = args[3].As<Boolean>();

  CHECK(args[4]->IsBoolean());
  options.allow_code_gen_wasm = args[4].As<Boolean>();

  if (args[5]->IsObject() &&
      !env->microtask_queue_ctor_template().IsEmpty() &&
      env->microtask_queue_ctor_template()->HasInstance(args[5])) {
    options.microtask_queue_wrap.reset(
        Unwrap<MicrotaskQueueWrap>(args[5].As<...",78,,348,2,,void
150052,BLOCK,-1,,"{
    options.origin = args[2].As<String>();
  }",28,,367,2,,void
150124,BLOCK,-1,,"{
    options.microtask_queue_wrap.reset(
        Unwrap<MicrotaskQueueWrap>(args[5].As<Object>()));
  }",67,,379,2,,void
150162,BLOCK,-1,,"{
    if (!try_catch.HasTerminated())
      try_catch.ReThrow();
    return;
  }",30,,388,2,,void
150169,BLOCK,-1,,<empty>,7,,390,2,,void
150179,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsObject());
  Local<Object> sandbox = args[0].As<Object>();

  Maybe<bool> result =
      sandbox->HasPrivate(env->context(),
                          env->contextify_context_private_symbol());
  args.GetReturnValue().Set(result.FromJust());
}",76,,396,2,,void
150237,BLOCK,-1,,"{
  ContextifyContext* context = data.GetParameter();
  delete context;
}",54,,410,2,,void
150252,BLOCK,-1,,"{
  Local<Value> context_global;
  if (sandbox
          ->GetPrivate(env->context(), env->contextify_context_private_symbol())
          .ToLocal(&context_global) &&
      context_global->IsObject()) {
    return Unwrap<ContextifyContext>(context_global.As<Object>());
  }
  return nullptr;
}",35,,418,3,,void
150281,BLOCK,-1,,"{
    return Unwrap<ContextifyContext>(context_global.As<Object>());
  }",35,,423,2,,void
150297,BLOCK,-1,,"{
  return Get(args.This());
}",80,,430,2,,void
150308,BLOCK,-1,,"{
  Local<Context> context;
  if (!object->GetCreationContext().ToLocal(&context)) {
    return nullptr;
  }
  if (!ContextEmbedderTag::IsNodeContext(context)) {
    return nullptr;
  }
  return static_cast<ContextifyContext*>(
      context->GetAlignedPointerFromEmbedderData(
          ContextEmbedderIndex::kContextifyContext));
}",65,,434,2,,void
150325,BLOCK,-1,,"{
    return nullptr;
  }",56,,436,2,,void
150335,BLOCK,-1,,"{
    return nullptr;
  }",52,,439,2,,void
150352,BLOCK,-1,,"{
  return ctx == nullptr || ctx->context_.IsEmpty();
}",75,,447,2,,void
150369,BLOCK,-1,,"{
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  Local<Context> context = ctx->context();
  Local<Object> sandbox = ctx->sandbox();
  MaybeLocal<Value> maybe_rv =
      sandbox->GetRealNamedProperty(context, property);
  if (maybe_rv.IsEmpty()) {
    maybe_rv =
        ctx->global_proxy()->GetRealNamedProperty(context, property);
  }

  Local<Value> rv;
  if (maybe_rv.ToLocal(&rv)) {
    if (rv == sandbox)
      rv = ctx->global_proxy();

    args.GetReturnValue().Set(rv);
  }
}",46,,454,3,,void
150381,BLOCK,-1,,<empty>,33,,458,2,,void
150420,BLOCK,-1,,"{
    maybe_rv =
        ctx->global_proxy()->GetRealNamedProperty(context, property);
  }",27,,464,2,,void
150444,BLOCK,-1,,"{
    if (rv == sandbox)
      rv = ctx->global_proxy();

    args.GetReturnValue().Set(rv);
  }",30,,470,2,,void
150449,BLOCK,-1,,<empty>,7,,472,2,,void
150470,BLOCK,-1,,"{
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  Local<Context> context = ctx->context();
  PropertyAttribute attributes = PropertyAttribute::None;
  bool is_declared_on_global_proxy = ctx->global_proxy()
      ->GetRealNamedPropertyAttributes(context, property)
      .To(&attributes);
  bool read_only =
      static_cast<int>(attributes) &
      static_cast<int>(PropertyAttribute::ReadOnly);

  bool is_declared_on_sandbox = ctx->sandbox()
      ->GetRealNamedPropertyAttributes(context, property)
      .To(&attributes);
  read_only = read_only ||
      (static_cast<int>(attributes) &
      static_cast<int>(PropertyAttribute::ReadOnly));

  if (read_only)
    return;

  // true for x = 5
  // false for this.x = 5
  // false for Object.defineProperty(this, 'foo', ...)
  // false for vmResult.x = 5 where vmResult = vm.runInContext();
  bool is_contextual_store = ctx->global_proxy() != args.This();

  // Indic...",46,,482,4,,void
150482,BLOCK,-1,,<empty>,33,,486,2,,void
150561,BLOCK,-1,,<empty>,5,,505,2,,void
150601,BLOCK,-1,,<empty>,5,,525,2,,void
150617,BLOCK,-1,,<empty>,66,,527,2,,void
150647,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(context);
    Local<Object> desc_obj = desc.As<Object>();

    // We have to specify the return value for any contextual or get/set
    // property
    if (desc_obj->HasOwnProperty(context, env->get_string()).FromMaybe(false) ||
        desc_obj->HasOwnProperty(context, env->set_string()).FromMaybe(false))
      args.GetReturnValue().Set(value);
  }",29,,534,2,,void
150694,BLOCK,-1,,<empty>,7,,542,2,,void
150708,BLOCK,-1,,"{
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  Local<Context> context = ctx->context();

  Local<Object> sandbox = ctx->sandbox();

  if (sandbox->HasOwnProperty(context, property).FromMaybe(false)) {
    Local<Value> desc;
    if (sandbox->GetOwnPropertyDescriptor(context, property).ToLocal(&desc)) {
      args.GetReturnValue().Set(desc);
    }
  }
}",46,,549,3,,void
150720,BLOCK,-1,,<empty>,33,,553,2,,void
150753,BLOCK,-1,,"{
    Local<Value> desc;
    if (sandbox->GetOwnPropertyDescriptor(context, property).ToLocal(&desc)) {
      args.GetReturnValue().Set(desc);
    }
  }",68,,559,2,,void
150771,BLOCK,-1,,"{
      args.GetReturnValue().Set(desc);
    }",78,,561,2,,void
150784,BLOCK,-1,,"{
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  Local<Context> context = ctx->context();
  Isolate* isolate = context->GetIsolate();

  PropertyAttribute attributes = PropertyAttribute::None;
  bool is_declared =
      ctx->global_proxy()->GetRealNamedPropertyAttributes(context,
                                                          property)
          .To(&attributes);
  bool read_only =
      static_cast<int>(attributes) &
          static_cast<int>(PropertyAttribute::ReadOnly);

  // If the property is set on the global as read_only, don't change it on
  // the global or sandbox.
  if (is_declared && read_only)
    return;

  Local<Object> sandbox = ctx->sandbox();

  auto define_prop_on_sandbox =
      [&] (PropertyDescriptor* desc_for_sandbox) {
        if (desc.has_enumerable()) {
          desc_for_sandbox->set_enumerable(desc.enumerable());
        }
        if (desc.has_configurable()) {
     ...",46,,571,4,,void
150796,BLOCK,-1,,<empty>,33,,575,2,,void
150854,BLOCK,-1,,<empty>,5,,592,2,,void
150880,BLOCK,-1,,"{
    PropertyDescriptor desc_for_sandbox(
        desc.has_get() ? desc.get() : Undefined(isolate).As<Value>(),
        desc.has_set() ? desc.set() : Undefined(isolate).As<Value>());

    define_prop_on_sandbox(&desc_for_sandbox);
  }",41,,608,2,,void
150915,BLOCK,-1,,"{
    Local<Value> value =
        desc.has_value() ? desc.value() : Undefined(isolate).As<Value>();

    if (desc.has_writable()) {
      PropertyDescriptor desc_for_sandbox(value, desc.writable());
      define_prop_on_sandbox(&desc_for_sandbox);
    } else {
      PropertyDescriptor desc_for_sandbox(value);
      define_prop_on_sandbox(&desc_for_sandbox);
    }
  }",10,,614,1,,void
150941,BLOCK,-1,,"{
      PropertyDescriptor desc_for_sandbox(value, desc.writable());
      define_prop_on_sandbox(&desc_for_sandbox);
    }",30,,618,2,,void
150953,BLOCK,-1,,"{
      PropertyDescriptor desc_for_sandbox(value);
      define_prop_on_sandbox(&desc_for_sandbox);
    }",12,,621,1,,void
150965,BLOCK,-1,,"{
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  Maybe<bool> success = ctx->sandbox()->Delete(ctx->context(), property);

  if (success.FromMaybe(false))
    return;

  // Delete failed on the sandbox, intercept and do not delete on
  // the global object.
  args.GetReturnValue().Set(false);
}",48,,631,3,,void
150977,BLOCK,-1,,<empty>,33,,635,2,,void
151000,BLOCK,-1,,<empty>,5,,640,2,,void
151014,BLOCK,-1,,"{
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  Local<Array> properties;

  if (!ctx->sandbox()->GetPropertyNames(ctx->context()).ToLocal(&properties))
    return;

  args.GetReturnValue().Set(properties);
}",46,,649,2,,void
151026,BLOCK,-1,,<empty>,33,,653,2,,void
151051,BLOCK,-1,,<empty>,5,,658,2,,void
151066,BLOCK,-1,,"{
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  ContextifyContext::PropertyGetterCallback(
      Uint32ToName(ctx->context(), index), args);
}",46,,666,3,,void
151078,BLOCK,-1,,<empty>,33,,670,2,,void
151097,BLOCK,-1,,"{
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  ContextifyContext::PropertySetterCallback(
      Uint32ToName(ctx->context(), index), value, args);
}",46,,680,4,,void
151109,BLOCK,-1,,<empty>,33,,684,2,,void
151128,BLOCK,-1,,"{
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  ContextifyContext::PropertyDescriptorCallback(
      Uint32ToName(ctx->context(), index), args);
}",46,,693,3,,void
151140,BLOCK,-1,,<empty>,33,,697,2,,void
151159,BLOCK,-1,,"{
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  ContextifyContext::PropertyDefinerCallback(
      Uint32ToName(ctx->context(), index), desc, args);
}",46,,707,4,,void
151171,BLOCK,-1,,<empty>,33,,711,2,,void
151190,BLOCK,-1,,"{
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  Maybe<bool> success = ctx->sandbox()->Delete(ctx->context(), index);

  if (success.FromMaybe(false))
    return;

  // Delete failed on the sandbox, intercept and do not delete on
  // the global object.
  args.GetReturnValue().Set(false);
}",48,,720,3,,void
151202,BLOCK,-1,,<empty>,33,,724,2,,void
151225,BLOCK,-1,,<empty>,5,,729,2,,void
151240,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();
  Local<String> class_name = FIXED_ONE_BYTE_STRING(isolate, ""ContextifyScript"");

  Local<FunctionTemplate> script_tmpl = NewFunctionTemplate(isolate, New);
  script_tmpl->InstanceTemplate()->SetInternalFieldCount(
      ContextifyScript::kInternalFieldCount);
  script_tmpl->SetClassName(class_name);
  SetProtoMethod(isolate, script_tmpl, ""createCachedData"", CreateCachedData);
  SetProtoMethod(isolate, script_tmpl, ""runInContext"", RunInContext);

  target->Set(isolate, ""ContextifyScript"", script_tmpl);
  isolate_data->set_script_context_constructor_template(script_tmpl);
}",62,,737,3,,void
151307,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(CreateCachedData);
  registry->Register(RunInContext);
}",42,,753,2,,void
151327,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();

  CHECK(args.IsConstructCall());

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  CHECK(args[0]->IsString());
  Local<String> code = args[0].As<String>();

  CHECK(args[1]->IsString());
  Local<String> filename = args[1].As<String>();

  int line_offset = 0;
  int column_offset = 0;
  Local<ArrayBufferView> cached_data_buf;
  bool produce_cached_data = false;
  Local<Context> parsing_context = context;

  if (argc > 2) {
    // new ContextifyScript(code, filename, lineOffset, columnOffset,
    //                      cachedData, produceCachedData, parsingContext)
    CHECK_EQ(argc, 7);
    CHECK(args[2]->IsNumber());
    line_offset = args[2].As<Int32>()->Value();
    CHECK(args[3]->IsNumber());
    column_offset = args[3].As<Int32>()->Value();
    if (!args[4]->IsUndefined()) {
      CHECK(args[4]->IsArrayBufferView());
      cached_data_b...",69,,759,2,,void
151434,BLOCK,-1,,"{
    // new ContextifyScript(code, filename, lineOffset, columnOffset,
    //                      cachedData, produceCachedData, parsingContext)
    CHECK_EQ(argc, 7);
    CHECK(args[2]->IsNumber());
    line_offset = args[2].As<Int32>()->Value();
    CHECK(args[3]->IsNumber());
    column_offset = args[3].As<Int32>()->Value();
    if (!args[4]->IsUndefined()) {
      CHECK(args[4]->IsArrayBufferView());
      cached_data_buf = args[4].As<ArrayBufferView>();
    }
    CHECK(args[5]->IsBoolean());
    produce_cached_data = args[5]->IsTrue();
    if (!args[6]->IsUndefined()) {
      CHECK(args[6]->IsObject());
      ContextifyContext* sandbox =
          ContextifyContext::ContextFromContextifiedSandbox(
              env, args[6].As<Object>());
      CHECK_NOT_NULL(sandbox);
      parsing_context = sandbox->context();
    }
  }",17,,781,2,,void
151482,BLOCK,-1,,"{
      CHECK(args[4]->IsArrayBufferView());
      cached_data_buf = args[4].As<ArrayBufferView>();
    }",34,,789,2,,void
151521,BLOCK,-1,,"{
      CHECK(args[6]->IsObject());
      ContextifyContext* sandbox =
          ContextifyContext::ContextFromContextifiedSandbox(
              env, args[6].As<Object>());
      CHECK_NOT_NULL(sandbox);
      parsing_context = sandbox->context();
    }",34,,795,2,,void
151569,BLOCK,-1,,"{
    Utf8Value fn(isolate, filename);
    TRACE_EVENT_BEGIN1(TRACING_CATEGORY_NODE2(vm, script),
                       ""ContextifyScript::New"",
                       ""filename"",
                       TRACE_STR_COPY(*fn));
  }",53,,809,2,,void
151593,BLOCK,-1,,"{
    uint8_t* data = static_cast<uint8_t*>(cached_data_buf->Buffer()->Data());
    cached_data = new ScriptCompiler::CachedData(
        data + cached_data_buf->ByteOffset(), cached_data_buf->ByteLength());
  }",35,,818,2,,void
151707,BLOCK,-1,,<empty>,5,,847,2,,void
151749,BLOCK,-1,,"{
    errors::DecorateErrorStack(env, try_catch);
    no_abort_scope.Close();
    if (!try_catch.HasTerminated())
      try_catch.ReThrow();
    TRACE_EVENT_END0(TRACING_CATEGORY_NODE2(vm, script),
                     ""ContextifyScript::New"");
    return;
  }",45,,857,2,,void
151766,BLOCK,-1,,<empty>,7,,861,2,,void
151796,BLOCK,-1,,"{
    new_cached_data.reset(ScriptCompiler::CreateCodeCache(v8_script));
  }",28,,869,2,,void
151824,BLOCK,-1,,"{
    return;
  }",25,,879,2,,void
151849,BLOCK,-1,,<empty>,5,,888,2,,void
151865,BLOCK,-1,,"{
  Local<Context> context;
  if (!target->GetCreationContext().ToLocal(&context)) {
    return Nothing<bool>();
  }
  if (compile_options == ScriptCompiler::kConsumeCodeCache) {
    if (target
            ->Set(
                context,
                env->cached_data_rejected_string(),
                Boolean::New(env->isolate(), source.GetCachedData()->rejected))
            .IsNothing()) {
      return Nothing<bool>();
    }
  }
  if (produce_cached_data) {
    bool cached_data_produced = new_cached_data != nullptr;
    if (cached_data_produced) {
      MaybeLocal<Object> buf =
          Buffer::Copy(env,
                       reinterpret_cast<const char*>(new_cached_data->data),
                       new_cached_data->length);
      if (target->Set(context, env->cached_data_string(), buf.ToLocalChecked())
              .IsNothing()) {
        return Nothing<bool>();
      }
    }
    if (target
            ->Set(context,
                  env->cached_data_produced_string(),
 ...",66,,899,7,,void
151882,BLOCK,-1,,"{
    return Nothing<bool>();
  }",56,,901,2,,void
151891,BLOCK,-1,,"{
    if (target
            ->Set(
                context,
                env->cached_data_rejected_string(),
                Boolean::New(env->isolate(), source.GetCachedData()->rejected))
            .IsNothing()) {
      return Nothing<bool>();
    }
  }",61,,904,2,,void
151919,BLOCK,-1,,"{
      return Nothing<bool>();
    }",27,,910,2,,void
151924,BLOCK,-1,,"{
    bool cached_data_produced = new_cached_data != nullptr;
    if (cached_data_produced) {
      MaybeLocal<Object> buf =
          Buffer::Copy(env,
                       reinterpret_cast<const char*>(new_cached_data->data),
                       new_cached_data->length);
      if (target->Set(context, env->cached_data_string(), buf.ToLocalChecked())
              .IsNothing()) {
        return Nothing<bool>();
      }
    }
    if (target
            ->Set(context,
                  env->cached_data_produced_string(),
                  Boolean::New(env->isolate(), cached_data_produced))
            .IsNothing()) {
      return Nothing<bool>();
    }
  }",28,,914,2,,void
151933,BLOCK,-1,,"{
      MaybeLocal<Object> buf =
          Buffer::Copy(env,
                       reinterpret_cast<const char*>(new_cached_data->data),
                       new_cached_data->length);
      if (target->Set(context, env->cached_data_string(), buf.ToLocalChecked())
              .IsNothing()) {
        return Nothing<bool>();
      }
    }",31,,916,2,,void
151970,BLOCK,-1,,"{
        return Nothing<bool>();
      }",29,,922,2,,void
151995,BLOCK,-1,,"{
      return Nothing<bool>();
    }",27,,930,2,,void
152006,BLOCK,-1,,"{
  return !value.IsEmpty() &&
         env->script_context_constructor_template()->HasInstance(value);
}",62,,938,3,,void
152026,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  ContextifyScript* wrapped_script;
  ASSIGN_OR_RETURN_UNWRAP(&wrapped_script, args.Holder());
  Local<UnboundScript> unbound_script =
      PersistentToLocal::Default(env->isolate(), wrapped_script->script_);
  std::unique_ptr<ScriptCompiler::CachedData> cached_data(
      ScriptCompiler::CreateCodeCache(unbound_script));
  if (!cached_data) {
    args.GetReturnValue().Set(Buffer::New(env, 0).ToLocalChecked());
  } else {
    MaybeLocal<Object> buf = Buffer::Copy(
        env,
        reinterpret_cast<const char*>(cached_data->data),
        cached_data->length);
    args.GetReturnValue().Set(buf.ToLocalChecked());
  }
}",46,,944,2,,void
152062,BLOCK,-1,,<empty>,,,,2,,<empty>
152068,BLOCK,-1,,"{
    args.GetReturnValue().Set(Buffer::New(env, 0).ToLocalChecked());
  }",21,,952,2,,void
152086,BLOCK,-1,,"{
    MaybeLocal<Object> buf = Buffer::Copy(
        env,
        reinterpret_cast<const char*>(cached_data->data),
        cached_data->length);
    args.GetReturnValue().Set(buf.ToLocalChecked());
  }",10,,954,1,,void
152121,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  ContextifyScript* wrapped_script;
  ASSIGN_OR_RETURN_UNWRAP(&wrapped_script, args.Holder());

  CHECK_EQ(args.Length(), 5);
  CHECK(args[0]->IsObject() || args[0]->IsNull());

  Local<Context> context;
  std::shared_ptr<MicrotaskQueue> microtask_queue;

  if (args[0]->IsObject()) {
    Local<Object> sandbox = args[0].As<Object>();
    // Get the context from the sandbox
    ContextifyContext* contextify_context =
        ContextifyContext::ContextFromContextifiedSandbox(env, sandbox);
    CHECK_NOT_NULL(contextify_context);
    CHECK_EQ(contextify_context->env(), env);

    context = contextify_context->context();
    if (context.IsEmpty()) return;

    microtask_queue = contextify_context->microtask_queue();
  } else {
    context = env->context();
  }

  TRACE_EVENT0(TRACING_CATEGORY_NODE2(vm, script), ""RunInContext"");

  CHECK(args[1]->IsNumber());
  int64_t timeout = args[1]->IntegerValue(env->context()).FromJust();

  CHE...",78,,963,2,,void
152177,BLOCK,-1,,"{
    Local<Object> sandbox = args[0].As<Object>();
    // Get the context from the sandbox
    ContextifyContext* contextify_context =
        ContextifyContext::ContextFromContextifiedSandbox(env, sandbox);
    CHECK_NOT_NULL(contextify_context);
    CHECK_EQ(contextify_context->env(), env);

    context = contextify_context->context();
    if (context.IsEmpty()) return;

    microtask_queue = contextify_context->microtask_queue();
  }",28,,975,2,,void
152218,BLOCK,-1,,<empty>,28,,984,2,,void
152227,BLOCK,-1,,"{
    context = env->context();
  }",10,,987,1,,void
152327,BLOCK,-1,,"{
  Context::Scope context_scope(context);

  if (!env->can_call_into_js())
    return false;
  if (!ContextifyScript::InstanceOf(env, args.Holder())) {
    THROW_ERR_INVALID_THIS(
        env,
        ""Script methods can only be called on script instances."");
    return false;
  }

  TryCatchScope try_catch(env);
  Isolate::SafeForTerminationScope safe_for_termination(env->isolate());
  ContextifyScript* wrapped_script;
  ASSIGN_OR_RETURN_UNWRAP(&wrapped_script, args.Holder(), false);
  Local<UnboundScript> unbound_script =
      PersistentToLocal::Default(env->isolate(), wrapped_script->script_);
  Local<Script> script = unbound_script->BindToCurrentContext();

#if HAVE_INSPECTOR
  if (break_on_first_line) {
    env->inspector_agent()->PauseOnNextJavascriptStatement(""Break on start"");
  }
#endif

  MaybeLocal<Value> result;
  bool timed_out = false;
  bool received_signal = false;
  auto run = [&]() {
    MaybeLocal<Value> result = script->Run(context);
    if (!result.IsEmpty() &...",77,,1023,9,,void
152337,BLOCK,-1,,<empty>,5,,1027,2,,void
152351,BLOCK,-1,,"{
    THROW_ERR_INVALID_THIS(
        env,
        ""Script methods can only be called on script instances."");
    return false;
  }",58,,1028,2,,void
152426,BLOCK,-1,,"{
    Watchdog wd(env->isolate(), timeout, &timed_out);
    SigintWatchdog swd(env->isolate(), &received_signal);
    result = run();
  }",41,,1058,2,,void
152448,BLOCK,-1,,<empty>,10,,1062,1,,void
152451,BLOCK,-1,,"{
    SigintWatchdog swd(env->isolate(), &received_signal);
    result = run();
  }",31,,1062,2,,void
152464,BLOCK,-1,,<empty>,10,,1065,1,,void
152470,BLOCK,-1,,"{
    Watchdog wd(env->isolate(), timeout, &timed_out);
    result = run();
  }",29,,1065,2,,void
152484,BLOCK,-1,,"{
    result = run();
  }",10,,1068,1,,void
152492,BLOCK,-1,,"{
    if (!env->is_main_thread() && env->is_stopping())
      return false;
    env->isolate()->CancelTerminateExecution();
    // It is possible that execution was terminated by another timeout in
    // which this timeout is nested, so check whether one of the watchdogs
    // from this invocation is responsible for termination.
    if (timed_out) {
      node::THROW_ERR_SCRIPT_EXECUTION_TIMEOUT(env, timeout);
    } else if (received_signal) {
      node::THROW_ERR_SCRIPT_EXECUTION_INTERRUPTED(env);
    }
  }",37,,1073,2,,void
152504,BLOCK,-1,,<empty>,7,,1075,2,,void
152516,BLOCK,-1,,"{
      node::THROW_ERR_SCRIPT_EXECUTION_TIMEOUT(env, timeout);
    }",20,,1080,2,,void
152524,BLOCK,-1,,<empty>,12,,1082,1,,void
152527,BLOCK,-1,,"{
      node::THROW_ERR_SCRIPT_EXECUTION_INTERRUPTED(env);
    }",33,,1082,2,,void
152538,BLOCK,-1,,"{
    if (!timed_out && !received_signal && display_errors) {
      // We should decorate non-termination exceptions
      errors::DecorateErrorStack(env, try_catch);
    }

    // If there was an exception thrown during script execution, re-throw it.
    // If one of the above checks threw, re-throw the exception instead of
    // letting try_catch catch it.
    // If execution has been terminated, but not by one of the watchdogs from
    // this invocation, this will re-throw a `null` value.
    if (!try_catch.HasTerminated())
      try_catch.ReThrow();

    return false;
  }",30,,1087,2,,void
152547,BLOCK,-1,,"{
      // We should decorate non-termination exceptions
      errors::DecorateErrorStack(env, try_catch);
    }",59,,1088,2,,void
152560,BLOCK,-1,,<empty>,7,,1099,2,,void
152585,BLOCK,-1,,"{
  MakeWeak();
  env->id_to_script_map.emplace(id_, this);
}",38,,1111,3,,void
152598,BLOCK,-1,,"{
  env()->id_to_script_map.erase(id_);
}",39,,1117,1,,void
152610,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();

  // Argument 1: source code
  CHECK(args[0]->IsString());
  Local<String> code = args[0].As<String>();

  // Argument 2: filename
  CHECK(args[1]->IsString());
  Local<String> filename = args[1].As<String>();

  // Argument 3: line offset
  CHECK(args[2]->IsNumber());
  int line_offset = args[2].As<Int32>()->Value();

  // Argument 4: column offset
  CHECK(args[3]->IsNumber());
  int column_offset = args[3].As<Int32>()->Value();

  // Argument 5: cached data (optional)
  Local<ArrayBufferView> cached_data_buf;
  if (!args[4]->IsUndefined()) {
    CHECK(args[4]->IsArrayBufferView());
    cached_data_buf = args[4].As<ArrayBufferView>();
  }

  // Argument 6: produce cache data
  CHECK(args[5]->IsBoolean());
  bool produce_cached_data = args[5]->IsTrue();

  // Argument 7: parsing context (optional)
  Local<Context> parsing_context;
  if (!args[6]->IsU...",46,,1123,2,,void
152725,BLOCK,-1,,"{
    CHECK(args[4]->IsArrayBufferView());
    cached_data_buf = args[4].As<ArrayBufferView>();
  }",32,,1146,2,,void
152770,BLOCK,-1,,"{
    CHECK(args[6]->IsObject());
    ContextifyContext* sandbox =
        ContextifyContext::ContextFromContextifiedSandbox(
            env, args[6].As<Object>());
    CHECK_NOT_NULL(sandbox);
    parsing_context = sandbox->context();
  }",32,,1157,2,,void
152801,BLOCK,-1,,"{
    parsing_context = context;
  }",10,,1164,1,,void
152818,BLOCK,-1,,"{
    CHECK(args[7]->IsArray());
    context_extensions_buf = args[7].As<Array>();
  }",32,,1170,2,,void
152847,BLOCK,-1,,"{
    CHECK(args[8]->IsArray());
    params_buf = args[8].As<Array>();
  }",32,,1177,2,,void
152873,BLOCK,-1,,"{
    uint8_t* data = static_cast<uint8_t*>(cached_data_buf->Buffer()->Data());
    cached_data = new ScriptCompiler::CachedData(
      data + cached_data_buf->ByteOffset(), cached_data_buf->ByteLength());
  }",35,,1184,2,,void
152986,BLOCK,-1,,"{
    options = ScriptCompiler::kNoCompileOptions;
  }",42,,1217,2,,void
152993,BLOCK,-1,,"{
    options = ScriptCompiler::kConsumeCodeCache;
  }",10,,1219,1,,void
153020,BLOCK,-1,,"{
    for (uint32_t n = 0; n < context_extensions_buf->Length(); n++) {
      Local<Value> val;
      if (!context_extensions_buf->Get(context, n).ToLocal(&val)) return;
      CHECK(val->IsObject());
      context_extensions.push_back(val.As<Object>());
    }
  }",42,,1228,2,,void
153022,BLOCK,-1,,<empty>,5,,1229,1,,void
153035,BLOCK,4,,"{
      Local<Value> val;
      if (!context_extensions_buf->Get(context, n).ToLocal(&val)) return;
      CHECK(val->IsObject());
      context_extensions.push_back(val.As<Object>());
    }",69,,1229,4,,void
153054,BLOCK,-1,,<empty>,67,,1231,2,,void
153084,BLOCK,-1,,"{
    for (uint32_t n = 0; n < params_buf->Length(); n++) {
      Local<Value> val;
      if (!params_buf->Get(context, n).ToLocal(&val)) return;
      CHECK(val->IsString());
      params.push_back(val.As<String>());
    }
  }",30,,1239,2,,void
153086,BLOCK,-1,,<empty>,5,,1240,1,,void
153099,BLOCK,4,,"{
      Local<Value> val;
      if (!params_buf->Get(context, n).ToLocal(&val)) return;
      CHECK(val->IsString());
      params.push_back(val.As<String>());
    }",57,,1240,4,,void
153118,BLOCK,-1,,<empty>,55,,1242,2,,void
153183,BLOCK,-1,,"{
    if (try_catch.HasCaught() && !try_catch.HasTerminated()) {
      errors::DecorateErrorStack(env, try_catch);
      try_catch.ReThrow();
    }
    return;
  }",31,,1259,2,,void
153195,BLOCK,-1,,"{
      errors::DecorateErrorStack(env, try_catch);
      try_catch.ReThrow();
    }",62,,1260,2,,void
153227,BLOCK,-1,,"{
    return;
  }",42,,1269,2,,void
153271,BLOCK,-1,,<empty>,5,,1277,2,,void
153287,BLOCK,-1,,<empty>,5,,1280,2,,void
153309,BLOCK,-1,,<empty>,5,,1286,2,,void
153322,BLOCK,-1,,"{
    new_cached_data.reset(ScriptCompiler::CreateCodeCacheForFunction(fn));
  }",28,,1289,2,,void
153347,BLOCK,-1,,"{
    return;
  }",25,,1298,2,,void
153361,BLOCK,-1,,"{
  CompiledFnEntry* entry = data.GetParameter();
  delete entry;
}",52,,1306,2,,void
153378,BLOCK,-1,,"{
  fn_.SetWeak(this, WeakCallback, v8::WeakCallbackType::kParameter);
}",65,,1315,5,,void
153393,BLOCK,-1,,"{
  env()->id_to_function_map.erase(id_);
  fn_.ClearWeak();
}",37,,1319,1,,void
153409,BLOCK,-1,,"{
  int ret = SigintWatchdogHelper::GetInstance()->Start();
  args.GetReturnValue().Set(ret == 0);
}",74,,1324,2,,void
153434,BLOCK,-1,,"{
  bool had_pending_signals = SigintWatchdogHelper::GetInstance()->Stop();
  args.GetReturnValue().Set(had_pending_signals);
}",73,,1329,2,,void
153457,BLOCK,-1,,"{
  bool ret = SigintWatchdogHelper::GetInstance()->HasPendingSignal();
  args.GetReturnValue().Set(ret);
}",79,,1334,2,,void
153480,BLOCK,-1,,"{
  CHECK(args[0]->IsInt32());
  CHECK(args[1]->IsInt32());
  int32_t mode = args[0].As<v8::Int32>()->Value();
  int32_t execution = args[1].As<v8::Int32>()->Value();
  Isolate* isolate = args.GetIsolate();

  Local<Context> current_context = isolate->GetCurrentContext();
  Local<Promise::Resolver> resolver;
  if (!Promise::Resolver::New(current_context).ToLocal(&resolver)) return;
  std::unique_ptr<v8::MeasureMemoryDelegate> delegate =
      v8::MeasureMemoryDelegate::Default(
          isolate,
          current_context,
          resolver,
          static_cast<v8::MeasureMemoryMode>(mode));
  isolate->MeasureMemory(std::move(delegate),
                         static_cast<v8::MeasureMemoryExecution>(execution));
  Local<Promise> promise = resolver->GetPromise();

  args.GetReturnValue().Set(promise);
}",68,,1339,2,,void
153557,BLOCK,-1,,<empty>,68,,1348,2,,void
153616,BLOCK,-1,,"{
  MakeWeak();
}",75,,1365,3,,void
153621,BLOCK,-1,,"{
  return microtask_queue_;
}",45,,1370,1,,void
153628,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  new MicrotaskQueueWrap(Environment::GetCurrent(args), args.This());
}",71,,1374,2,,void
153650,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();
  HandleScope scope(isolate);
  Local<FunctionTemplate> tmpl = NewFunctionTemplate(isolate, New);
  tmpl->InstanceTemplate()->SetInternalFieldCount(
      ContextifyScript::kInternalFieldCount);
  isolate_data->set_microtask_queue_ctor_template(tmpl);
  SetConstructorFunction(isolate, target, ""MicrotaskQueue"", tmpl);
}",62,,1380,3,,void
153694,BLOCK,-1,,"{
  registry->Register(New);
}",42,,1391,2,,void
153705,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();
  Local<ObjectTemplate> target = ctor->InstanceTemplate();
  ContextifyContext::CreatePerIsolateProperties(isolate_data, target);
  ContextifyScript::CreatePerIsolateProperties(isolate_data, target);
  MicrotaskQueueWrap::CreatePerIsolateProperties(isolate_data, target);

  SetMethod(isolate, target, ""startSigintWatchdog"", StartSigintWatchdog);
  SetMethod(isolate, target, ""stopSigintWatchdog"", StopSigintWatchdog);
  // Used in tests.
  SetMethodNoSideEffect(
      isolate, target, ""watchdogHasPendingSigint"", WatchdogHasPendingSigint);

  {
    Local<FunctionTemplate> tpl = FunctionTemplate::New(isolate);
    tpl->SetClassName(FIXED_ONE_BYTE_STRING(isolate, ""CompiledFnEntry""));
    tpl->InstanceTemplate()->SetInternalFieldCount(
        CompiledFnEntry::kInternalFieldCount);

    isolate_data->set_compiled_fn_entry_template(tpl->InstanceTemplate());
  }
  SetMethod(isolate, target, ""measureMemory"", MeasureMemory);
}",63,,1396,3,,void
153756,BLOCK,10,,"{
    Local<FunctionTemplate> tpl = FunctionTemplate::New(isolate);
    tpl->SetClassName(FIXED_ONE_BYTE_STRING(isolate, ""CompiledFnEntry""));
    tpl->InstanceTemplate()->SetInternalFieldCount(
        CompiledFnEntry::kInternalFieldCount);

    isolate_data->set_compiled_fn_entry_template(tpl->InstanceTemplate());
  }",3,,1409,10,,void
153805,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<Object> constants = Object::New(env->isolate());
  Local<Object> measure_memory = Object::New(env->isolate());
  Local<Object> memory_execution = Object::New(env->isolate());

  {
    Local<Object> memory_mode = Object::New(env->isolate());
    MeasureMemoryMode SUMMARY = MeasureMemoryMode::kSummary;
    MeasureMemoryMode DETAILED = MeasureMemoryMode::kDetailed;
    NODE_DEFINE_CONSTANT(memory_mode, SUMMARY);
    NODE_DEFINE_CONSTANT(memory_mode, DETAILED);
    READONLY_PROPERTY(measure_memory, ""mode"", memory_mode);
  }

  {
    MeasureMemoryExecution DEFAULT = MeasureMemoryExecution::kDefault;
    MeasureMemoryExecution EAGER = MeasureMemoryExecution::kEager;
    NODE_DEFINE_CONSTANT(memory_execution, DEFAULT);
    NODE_DEFINE_CONSTANT(memory_execution, EAGER);
    READONLY_PROPERTY(measure_memory, ""execution"", memory_execution);
  }

  READONLY_PROPERTY(constants, ""measureMemory""...",52,,1423,5,,void
153863,BLOCK,8,,"{
    Local<Object> memory_mode = Object::New(env->isolate());
    MeasureMemoryMode SUMMARY = MeasureMemoryMode::kSummary;
    MeasureMemoryMode DETAILED = MeasureMemoryMode::kDetailed;
    NODE_DEFINE_CONSTANT(memory_mode, SUMMARY);
    NODE_DEFINE_CONSTANT(memory_mode, DETAILED);
    READONLY_PROPERTY(measure_memory, ""mode"", memory_mode);
  }",3,,1431,8,,void
153900,BLOCK,9,,"{
    MeasureMemoryExecution DEFAULT = MeasureMemoryExecution::kDefault;
    MeasureMemoryExecution EAGER = MeasureMemoryExecution::kEager;
    NODE_DEFINE_CONSTANT(memory_execution, DEFAULT);
    NODE_DEFINE_CONSTANT(memory_execution, EAGER);
    READONLY_PROPERTY(measure_memory, ""execution"", memory_execution);
  }",3,,1440,9,,void
153944,BLOCK,-1,,"{
  ContextifyContext::RegisterExternalReferences(registry);
  ContextifyScript::RegisterExternalReferences(registry);
  MicrotaskQueueWrap::RegisterExternalReferences(registry);

  registry->Register(StartSigintWatchdog);
  registry->Register(StopSigintWatchdog);
  registry->Register(WatchdogHasPendingSigint);
  registry->Register(MeasureMemory);
}",70,,1453,2,,void
153993,BLOCK,-1,,<empty>,1,,1,1,,ANY
154018,BLOCK,-1,,<empty>,1,,1,1,,ANY
154021,BLOCK,-1,,"{
  // This could reasonably be a static variable, but this way
  // we can guarantee that this function is always usable
  // and returns the correct value,  e.g. even in static
  // initialization code in other files.
#ifdef __linux__
  static const bool value = getauxval(AT_SECURE);
  return value;
#else
  return false;
#endif
}",24,,35,1,,void
154032,BLOCK,-1,,"{
#if !defined(__CloudABI__) && !defined(_WIN32)
#if defined(__linux__)
  if ((!HasOnly(CAP_NET_BIND_SERVICE) && linux_at_secure()) ||
      getuid() != geteuid() || getgid() != getegid())
#else
  if (linux_at_secure() || getuid() != geteuid() || getgid() != getegid())
#endif
    goto fail;
#endif

  if (env_vars != nullptr) {
    DCHECK_NOT_NULL(isolate);
    HandleScope handle_scope(isolate);
    TryCatch ignore_errors(isolate);
    MaybeLocal<String> maybe_value = env_vars->Get(
        isolate, String::NewFromUtf8(isolate, key).ToLocalChecked());
    Local<String> value;
    if (!maybe_value.ToLocal(&value)) goto fail;
    String::Utf8Value utf8_value(isolate, value);
    if (*utf8_value == nullptr) goto fail;
    *text = std::string(*utf8_value, utf8_value.length());
    return true;
  }

  {
    Mutex::ScopedLock lock(per_process::env_var_mutex);

    size_t init_sz = 256;
    MaybeStackBuffer<char, 256> val;
    int ret = uv_os_getenv(key, *val, &init_sz);

    if (ret == UV_...",39,,80,5,,void
154043,BLOCK,-1,,<empty>,5,,88,2,,void
154049,BLOCK,-1,,"{
    DCHECK_NOT_NULL(isolate);
    HandleScope handle_scope(isolate);
    TryCatch ignore_errors(isolate);
    MaybeLocal<String> maybe_value = env_vars->Get(
        isolate, String::NewFromUtf8(isolate, key).ToLocalChecked());
    Local<String> value;
    if (!maybe_value.ToLocal(&value)) goto fail;
    String::Utf8Value utf8_value(isolate, value);
    if (*utf8_value == nullptr) goto fail;
    *text = std::string(*utf8_value, utf8_value.length());
    return true;
  }",28,,91,2,,void
154091,BLOCK,-1,,<empty>,39,,98,2,,void
154102,BLOCK,-1,,<empty>,33,,100,2,,void
154119,BLOCK,3,,"{
    Mutex::ScopedLock lock(per_process::env_var_mutex);

    size_t init_sz = 256;
    MaybeStackBuffer<char, 256> val;
    int ret = uv_os_getenv(key, *val, &init_sz);

    if (ret == UV_ENOBUFS) {
      // Buffer is not large enough, reallocate to the updated init_sz
      // and fetch env value again.
      val.AllocateSufficientStorage(init_sz);
      ret = uv_os_getenv(key, *val, &init_sz);
    }

    if (ret >= 0) {  // Env key value fetch success.
      *text = *val;
      return true;
    }
  }",3,,105,3,,void
154143,BLOCK,-1,,"{
      // Buffer is not large enough, reallocate to the updated init_sz
      // and fetch env value again.
      val.AllocateSufficientStorage(init_sz);
      ret = uv_os_getenv(key, *val, &init_sz);
    }",28,,112,2,,void
154161,BLOCK,-1,,"{  // Env key value fetch success.
      *text = *val;
      return true;
    }",19,,119,2,,void
154180,BLOCK,-1,,"{
  CHECK(args[0]->IsString());
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  Utf8Value strenvtag(isolate, args[0]);
  std::string text;
  if (!SafeGetenv(*strenvtag, &text, env->env_vars(), isolate)) return;
  Local<Value> result =
      ToV8Value(isolate->GetCurrentContext(), text).ToLocalChecked();
  args.GetReturnValue().Set(result);
}",65,,130,2,,void
154222,BLOCK,-1,,<empty>,65,,136,2,,void
154251,BLOCK,-1,,"{
  registry->Register(SafeGetenv);

#ifdef NODE_IMPLEMENTS_POSIX_CREDENTIALS
  registry->Register(GetUid);
  registry->Register(GetEUid);
  registry->Register(GetGid);
  registry->Register(GetEGid);
  registry->Register(GetGroups);

  registry->Register(InitGroups);
  registry->Register(SetEGid);
  registry->Register(SetEUid);
  registry->Register(SetGid);
  registry->Register(SetUid);
  registry->Register(SetGroups);
#endif  // NODE_IMPLEMENTS_POSIX_CREDENTIALS
}",70,,436,2,,void
154264,BLOCK,-1,,"{
  SetMethod(context, target, ""safeGetenv"", SafeGetenv);

#ifdef NODE_IMPLEMENTS_POSIX_CREDENTIALS
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  READONLY_TRUE_PROPERTY(target, ""implementsPosixCredentials"");
  SetMethodNoSideEffect(context, target, ""getuid"", GetUid);
  SetMethodNoSideEffect(context, target, ""geteuid"", GetEUid);
  SetMethodNoSideEffect(context, target, ""getgid"", GetGid);
  SetMethodNoSideEffect(context, target, ""getegid"", GetEGid);
  SetMethodNoSideEffect(context, target, ""getgroups"", GetGroups);

  if (env->owns_process_state()) {
    SetMethod(context, target, ""initgroups"", InitGroups);
    SetMethod(context, target, ""setegid"", SetEGid);
    SetMethod(context, target, ""seteuid"", SetEUid);
    SetMethod(context, target, ""setgid"", SetGid);
    SetMethod(context, target, ""setuid"", SetUid);
    SetMethod(context, target, ""setgroups"", SetGroups);
  }
#endif  // NODE_IMPLEMENTS_POSIX_CREDENTIALS
}",36,,458,5,,void
154291,BLOCK,-1,,<empty>,1,,1,1,,ANY
154299,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);

  if (!InitCryptoOnce(env->isolate())) {
    return;
  }

#define V(Namespace) Namespace::Initialize(env, target);
  CRYPTO_NAMESPACE_LIST(V)
#undef V
}",29,,75,5,,void
154315,BLOCK,-1,,"{
    return;
  }",40,,78,2,,void
154318,BLOCK,1,,<empty>,,,,2,,void
154455,BLOCK,-1,,"{
#define V(Namespace) Namespace::RegisterExternalReferences(registry);
  CRYPTO_NAMESPACE_LIST(V)
#undef V
}",70,,87,2,,void
154457,BLOCK,1,,<empty>,,,,1,,void
154619,BLOCK,-1,,<empty>,1,,1,1,,ANY
154623,BLOCK,-1,,"{
      const char* msg = ""Closing directory handle on garbage collection failed"";
      // This exception will end up being fatal for the process because
      // it is being thrown from within the SetImmediate handler and
      // there is no JS stack to bubble it to. In other words, tearing
      // down the process is the only reasonable thing we can do here.
      HandleScope handle_scope(env->isolate());
      env->ThrowUVException(detail.ret, ""close"", msg);
    }",52,,152,2,,void
154650,BLOCK,-1,,"{
    ProcessEmitWarning(env,
                       ""Closing directory handle on garbage collection"");
  }",44,,168,2,,void
154691,BLOCK,-1,,<empty>,1,,1,1,,ANY
154696,BLOCK,-1,,"{
  switch (req_type) {
#define FS_TYPE_TO_NAME(type, name)                                            \
  case UV_FS_##type:                                                           \
    return name;
    FS_TYPE_TO_NAME(OPENDIR, ""opendir"")
    FS_TYPE_TO_NAME(READDIR, ""readdir"")
    FS_TYPE_TO_NAME(CLOSEDIR, ""closedir"")
#undef FS_TYPE_TO_NAME
    default:
      return ""unknow"";
  }
}",67,,46,2,,void
154699,BLOCK,-1,,"{
#define FS_TYPE_TO_NAME(type, name)                                            \
  case UV_FS_##type:                                                           \
    return name;
    FS_TYPE_TO_NAME(OPENDIR, ""opendir"")
    FS_TYPE_TO_NAME(READDIR, ""readdir"")
    FS_TYPE_TO_NAME(CLOSEDIR, ""closedir"")
#undef FS_TYPE_TO_NAME
    default:
      return ""unknow"";
  }",21,,47,2,,void
154701,BLOCK,1,,<empty>,,,,1,,void
154707,BLOCK,1,,<empty>,,,,1,,void
154713,BLOCK,1,,<empty>,,,,1,,void
154727,BLOCK,-1,,"{
  MakeWeak();

  dir_->nentries = 0;
  dir_->dirents = nullptr;
}",17,,100,4,,void
154744,BLOCK,-1,,"{
  Local<Object> obj;
  if (!env->dir_instance_template()
          ->NewInstance(env->context())
          .ToLocal(&obj)) {
    return nullptr;
  }

  return new DirHandle(env, obj, dir);
}",60,,107,3,,void
154768,BLOCK,-1,,"{
    return nullptr;
  }",27,,111,2,,void
154781,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
}",62,,118,2,,void
154790,BLOCK,-1,,"{
  CHECK(!closing_);  // We should not be deleting while explicitly closing!
  GCClose();         // Close synchronously and emit warning
  CHECK(closed_);    // We have to be closed at the point
}",25,,122,1,,void
154800,BLOCK,-1,,"{
  tracker->TrackFieldWithSize(""dir"", sizeof(*dir_));
}",58,,128,2,,void
154812,BLOCK,-1,,"{
  if (closed_) return;
  uv_fs_t req;
  FS_DIR_SYNC_TRACE_BEGIN(closedir);
  int ret = uv_fs_closedir(nullptr, &req, dir_, nullptr);
  FS_DIR_SYNC_TRACE_END(closedir);
  uv_fs_req_cleanup(&req);
  closing_ = false;
  closed_ = true;

  struct err_detail { int ret; };

  err_detail detail { ret };

  if (ret < 0) {
    // Do not unref this
    env()->SetImmediate([detail](Environment* env) {
      const char* msg = ""Closing directory handle on garbage collection failed"";
      // This exception will end up being fatal for the process because
      // it is being thrown from within the SetImmediate handler and
      // there is no JS stack to bubble it to. In other words, tearing
      // down the process is the only reasonable thing we can do here.
      HandleScope handle_scope(env->isolate());
      env->ThrowUVException(detail.ret, ""close"", msg);
    });
    return;
  }

  // If the close was successful, we still want to emit a process warning
  // to notify that the file descri...",34,,136,1,,void
154815,BLOCK,-1,,<empty>,16,,137,2,,void
154821,BLOCK,1,,<empty>,,,,9,,void
154837,BLOCK,-1,,<empty>,3,,139,2,,void
154839,BLOCK,-1,,FS_DIR_SYNC_TRACE_BEGIN(closedir),3,,139,1,,void
154857,BLOCK,-1,,FS_DIR_SYNC_TRACE_BEGIN(closedir),3,,139,2,,void
154885,BLOCK,-1,,FS_DIR_SYNC_TRACE_BEGIN(closedir),3,,139,2,,void
154926,BLOCK,1,,<empty>,,,,9,,void
154942,BLOCK,-1,,<empty>,3,,141,2,,void
154944,BLOCK,-1,,FS_DIR_SYNC_TRACE_END(closedir),3,,141,1,,void
154962,BLOCK,-1,,FS_DIR_SYNC_TRACE_END(closedir),3,,141,2,,void
154990,BLOCK,-1,,FS_DIR_SYNC_TRACE_END(closedir),3,,141,2,,void
155036,BLOCK,-1,,"{
    // Do not unref this
    env()->SetImmediate([detail](Environment* env) {
      const char* msg = ""Closing directory handle on garbage collection failed"";
      // This exception will end up being fatal for the process because
      // it is being thrown from within the SetImmediate handler and
      // there is no JS stack to bubble it to. In other words, tearing
      // down the process is the only reasonable thing we can do here.
      HandleScope handle_scope(env->isolate());
      env->ThrowUVException(detail.ret, ""close"", msg);
    });
    return;
  }",16,,150,2,,void
155055,BLOCK,-1,,"{
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (after.Proceed())
    req_wrap->Resolve(Undefined(req_wrap->env()->isolate()));
}",31,,174,2,,void
155083,BLOCK,1,,<empty>,,,,18,,void
155085,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,177,1,,void
155103,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,177,2,,void
155131,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,177,2,,void
155187,BLOCK,-1,,<empty>,5,,180,2,,void
155204,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 1);

  DirHandle* dir;
  ASSIGN_OR_RETURN_UNWRAP(&dir, args.Holder());

  dir->closing_ = false;
  dir->closed_ = true;

  FSReqBase* req_wrap_async = GetReqWrap(args, 0);
  if (req_wrap_async != nullptr) {  // close(req)
    FS_DIR_ASYNC_TRACE_BEGIN0(UV_FS_CLOSEDIR, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""closedir"", UTF8, AfterClose,
              uv_fs_closedir, dir->dir());
  } else {  // close(undefined, ctx)
    CHECK_EQ(argc, 2);
    FSReqWrapSync req_wrap_sync;
    FS_DIR_SYNC_TRACE_BEGIN(closedir);
    SyncCall(env, args[1], &req_wrap_sync, ""closedir"", uv_fs_closedir,
             dir->dir());
    FS_DIR_SYNC_TRACE_END(closedir);
  }
}",64,,183,2,,void
155251,BLOCK,-1,,"{  // close(req)
    FS_DIR_ASYNC_TRACE_BEGIN0(UV_FS_CLOSEDIR, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""closedir"", UTF8, AfterClose,
              uv_fs_closedir, dir->dir());
  }",34,,196,2,,void
155259,BLOCK,1,,<empty>,,,,16,,void
155261,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_BEGIN0(UV_FS_CLOSEDIR, req_wrap_async)",5,,197,1,,void
155279,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_BEGIN0(UV_FS_CLOSEDIR, req_wrap_async)",5,,197,2,,void
155307,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_BEGIN0(UV_FS_CLOSEDIR, req_wrap_async)",5,,197,2,,void
155363,BLOCK,-1,,"{  // close(undefined, ctx)
    CHECK_EQ(argc, 2);
    FSReqWrapSync req_wrap_sync;
    FS_DIR_SYNC_TRACE_BEGIN(closedir);
    SyncCall(env, args[1], &req_wrap_sync, ""closedir"", uv_fs_closedir,
             dir->dir());
    FS_DIR_SYNC_TRACE_END(closedir);
  }",10,,200,1,,void
155371,BLOCK,1,,<empty>,,,,9,,void
155387,BLOCK,-1,,<empty>,5,,203,2,,void
155389,BLOCK,-1,,FS_DIR_SYNC_TRACE_BEGIN(closedir),5,,203,1,,void
155407,BLOCK,-1,,FS_DIR_SYNC_TRACE_BEGIN(closedir),5,,203,2,,void
155435,BLOCK,-1,,FS_DIR_SYNC_TRACE_BEGIN(closedir),5,,203,2,,void
155480,BLOCK,1,,<empty>,,,,9,,void
155496,BLOCK,-1,,<empty>,5,,206,2,,void
155498,BLOCK,-1,,FS_DIR_SYNC_TRACE_END(closedir),5,,206,1,,void
155516,BLOCK,-1,,FS_DIR_SYNC_TRACE_END(closedir),5,,206,2,,void
155544,BLOCK,-1,,FS_DIR_SYNC_TRACE_END(closedir),5,,206,2,,void
155581,BLOCK,-1,,"{
  MaybeStackBuffer<Local<Value>, 64> entries(num * 2);

  // Return an array of all read filenames.
  int j = 0;
  for (int i = 0; i < num; i++) {
    Local<Value> filename;
    Local<Value> error;
    const size_t namelen = strlen(ents[i].name);
    if (!StringBytes::Encode(env->isolate(),
                             ents[i].name,
                             namelen,
                             encoding,
                             &error).ToLocal(&filename)) {
      *err_out = error;
      return MaybeLocal<Array>();
    }

    entries[j++] = filename;
    entries[j++] = Integer::New(env->isolate(), ents[i].type);
  }

  return Array::New(env->isolate(), entries.out(), j);
}",28,,215,6,,void
155592,BLOCK,-1,,<empty>,3,,220,1,,void
155602,BLOCK,4,,"{
    Local<Value> filename;
    Local<Value> error;
    const size_t namelen = strlen(ents[i].name);
    if (!StringBytes::Encode(env->isolate(),
                             ents[i].name,
                             namelen,
                             encoding,
                             &error).ToLocal(&filename)) {
      *err_out = error;
      return MaybeLocal<Array>();
    }

    entries[j++] = filename;
    entries[j++] = Integer::New(env->isolate(), ents[i].type);
  }",33,,220,4,,void
155646,BLOCK,-1,,"{
      *err_out = error;
      return MaybeLocal<Array>();
    }",58,,228,2,,void
155695,BLOCK,-1,,"{
  BaseObjectPtr<FSReqBase> req_wrap { FSReqBase::from_req(req) };
  FSReqAfterScope after(req_wrap.get(), req);
  FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (!after.Proceed()) {
    return;
  }

  Environment* env = req_wrap->env();
  Isolate* isolate = env->isolate();

  if (req->result == 0) {
    // Done
    Local<Value> done = Null(isolate);
    after.Clear();
    req_wrap->Resolve(done);
    return;
  }

  uv_dir_t* dir = static_cast<uv_dir_t*>(req->ptr);

  Local<Value> error;
  Local<Array> js_array;
  if (!DirentListToArray(env,
                         dir->dirents,
                         static_cast<int>(req->result),
                         req_wrap->encoding(),
                         &error)
           .ToLocal(&js_array)) {
    // Clear libuv resources *before* delivering results to JS land because
    // that can schedule another operation on the same uv_dir_t. Ditto below.
    after.Clear();
    return r...",40,,240,2,,void
155729,BLOCK,1,,<empty>,,,,17,,void
155731,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,243,1,,void
155749,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,243,2,,void
155777,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,243,2,,void
155834,BLOCK,-1,,"{
    return;
  }",25,,245,2,,void
155856,BLOCK,-1,,"{
    // Done
    Local<Value> done = Null(isolate);
    after.Clear();
    req_wrap->Resolve(done);
    return;
  }",25,,252,2,,void
155916,BLOCK,-1,,"{
    // Clear libuv resources *before* delivering results to JS land because
    // that can schedule another operation on the same uv_dir_t. Ditto below.
    after.Clear();
    return req_wrap->Reject(error);
  }",33,,269,2,,void
155940,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  const enum encoding encoding = ParseEncoding(isolate, args[0], UTF8);

  DirHandle* dir;
  ASSIGN_OR_RETURN_UNWRAP(&dir, args.Holder());

  CHECK(args[1]->IsNumber());
  uint64_t buffer_size = static_cast<uint64_t>(args[1].As<Number>()->Value());

  if (buffer_size != dir->dirents_.size()) {
    dir->dirents_.resize(buffer_size);
    dir->dir_->nentries = buffer_size;
    dir->dir_->dirents = dir->dirents_.data();
  }

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // dir.read(encoding, bufferSize, req)
    FS_DIR_ASYNC_TRACE_BEGIN0(UV_FS_READDIR, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""readdir"", encoding,
              AfterDirRead, uv_fs_readdir, dir->dir());
  } else {  // dir.read(encoding, bufferSize, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
 ...",63,,281,2,,void
156013,BLOCK,-1,,"{
    dir->dirents_.resize(buffer_size);
    dir->dir_->nentries = buffer_size;
    dir->dir_->dirents = dir->dirents_.data();
  }",44,,296,2,,void
156050,BLOCK,-1,,"{  // dir.read(encoding, bufferSize, req)
    FS_DIR_ASYNC_TRACE_BEGIN0(UV_FS_READDIR, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""readdir"", encoding,
              AfterDirRead, uv_fs_readdir, dir->dir());
  }",34,,303,2,,void
156058,BLOCK,1,,<empty>,,,,16,,void
156060,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_BEGIN0(UV_FS_READDIR, req_wrap_async)",5,,304,1,,void
156078,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_BEGIN0(UV_FS_READDIR, req_wrap_async)",5,,304,2,,void
156106,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_BEGIN0(UV_FS_READDIR, req_wrap_async)",5,,304,2,,void
156162,BLOCK,-1,,"{  // dir.read(encoding, bufferSize, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_DIR_SYNC_TRACE_BEGIN(readdir);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""readdir"", uv_fs_readdir,
                       dir->dir());
    FS_DIR_SYNC_TRACE_END(readdir);
    if (err < 0) {
      return;  // syscall failed, no need to continue, error info is in ctx
    }

    if (req_wrap_sync.req.result == 0) {
      // Done
      Local<Value> done = Null(isolate);
      args.GetReturnValue().Set(done);
      return;
    }

    CHECK_GE(req_wrap_sync.req.result, 0);

    Local<Value> error;
    Local<Array> js_array;
    if (!DirentListToArray(env,
                           dir->dir()->dirents,
                           static_cast<int>(req_wrap_sync.req.result),
                           encoding,
                           &error)
             .ToLocal(&js_array)) {
      Local<Object> ctx = args[2].As<Object>();
      USE(ctx->Set(env->context(), env-...",10,,307,1,,void
156170,BLOCK,1,,<empty>,,,,9,,void
156186,BLOCK,-1,,<empty>,5,,310,2,,void
156188,BLOCK,-1,,FS_DIR_SYNC_TRACE_BEGIN(readdir),5,,310,1,,void
156206,BLOCK,-1,,FS_DIR_SYNC_TRACE_BEGIN(readdir),5,,310,2,,void
156234,BLOCK,-1,,FS_DIR_SYNC_TRACE_BEGIN(readdir),5,,310,2,,void
156282,BLOCK,1,,<empty>,,,,9,,void
156298,BLOCK,-1,,<empty>,5,,313,2,,void
156300,BLOCK,-1,,FS_DIR_SYNC_TRACE_END(readdir),5,,313,1,,void
156318,BLOCK,-1,,FS_DIR_SYNC_TRACE_END(readdir),5,,313,2,,void
156346,BLOCK,-1,,FS_DIR_SYNC_TRACE_END(readdir),5,,313,2,,void
156379,BLOCK,-1,,"{
      return;  // syscall failed, no need to continue, error info is in ctx
    }",18,,314,2,,void
156389,BLOCK,-1,,"{
      // Done
      Local<Value> done = Null(isolate);
      args.GetReturnValue().Set(done);
      return;
    }",40,,318,2,,void
156449,BLOCK,-1,,"{
      Local<Object> ctx = args[2].As<Object>();
      USE(ctx->Set(env->context(), env->error_string(), error));
      return;
    }",35,,334,2,,void
156489,BLOCK,-1,,"{
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (!after.Proceed()) {
    return;
  }

  Environment* env = req_wrap->env();

  uv_dir_t* dir = static_cast<uv_dir_t*>(req->ptr);
  DirHandle* handle = DirHandle::New(env, dir);

  req_wrap->Resolve(handle->object().As<Value>());
}",33,,344,2,,void
156517,BLOCK,1,,<empty>,,,,18,,void
156519,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,347,1,,void
156537,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,347,2,,void
156565,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,347,2,,void
156622,BLOCK,-1,,"{
    return;
  }",25,,349,2,,void
156663,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(isolate, args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, path.ToStringView());

  const enum encoding encoding = ParseEncoding(isolate, args[1], UTF8);

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // openDir(path, encoding, req)
    FS_DIR_ASYNC_TRACE_BEGIN1(
        UV_FS_OPENDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""opendir"", encoding, AfterOpenDir,
              uv_fs_opendir, *path);
  } else {  // openDir(path, encoding, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_DIR_SYNC_TRACE_BEGIN(opendir);
    int result = SyncCall(env, args[3], &req_wrap_sync, ""opendir"",
                          uv_fs_opendir, *path)...",62,,361,2,,void
156728,BLOCK,-1,,"{  // openDir(path, encoding, req)
    FS_DIR_ASYNC_TRACE_BEGIN1(
        UV_FS_OPENDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""opendir"", encoding, AfterOpenDir,
              uv_fs_opendir, *path);
  }",34,,376,2,,void
156737,BLOCK,1,,<empty>,,,,18,,void
156739,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_BEGIN1(
        UV_FS_OPENDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,377,1,,void
156757,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_BEGIN1(
        UV_FS_OPENDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,377,2,,void
156785,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_BEGIN1(
        UV_FS_OPENDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,377,2,,void
156848,BLOCK,-1,,"{  // openDir(path, encoding, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_DIR_SYNC_TRACE_BEGIN(opendir);
    int result = SyncCall(env, args[3], &req_wrap_sync, ""opendir"",
                          uv_fs_opendir, *path);
    FS_DIR_SYNC_TRACE_END(opendir);
    if (result < 0) {
      return;  // syscall failed, no need to continue, error info is in ctx
    }

    uv_fs_t* req = &req_wrap_sync.req;
    uv_dir_t* dir = static_cast<uv_dir_t*>(req->ptr);
    DirHandle* handle = DirHandle::New(env, dir);

    args.GetReturnValue().Set(handle->object().As<Value>());
  }",10,,381,1,,void
156856,BLOCK,1,,<empty>,,,,9,,void
156872,BLOCK,-1,,<empty>,5,,384,2,,void
156874,BLOCK,-1,,FS_DIR_SYNC_TRACE_BEGIN(opendir),5,,384,1,,void
156892,BLOCK,-1,,FS_DIR_SYNC_TRACE_BEGIN(opendir),5,,384,2,,void
156920,BLOCK,-1,,FS_DIR_SYNC_TRACE_BEGIN(opendir),5,,384,2,,void
156966,BLOCK,1,,<empty>,,,,9,,void
156982,BLOCK,-1,,<empty>,5,,387,2,,void
156984,BLOCK,-1,,FS_DIR_SYNC_TRACE_END(opendir),5,,387,1,,void
157002,BLOCK,-1,,FS_DIR_SYNC_TRACE_END(opendir),5,,387,2,,void
157030,BLOCK,-1,,FS_DIR_SYNC_TRACE_END(opendir),5,,387,2,,void
157063,BLOCK,-1,,"{
      return;  // syscall failed, no need to continue, error info is in ctx
    }",21,,388,2,,void
157110,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  SetMethod(context, target, ""opendir"", OpenDir);

  // Create FunctionTemplate for DirHandle
  Local<FunctionTemplate> dir = NewFunctionTemplate(isolate, DirHandle::New);
  dir->Inherit(AsyncWrap::GetConstructorTemplate(env));
  SetProtoMethod(isolate, dir, ""read"", DirHandle::Read);
  SetProtoMethod(isolate, dir, ""close"", DirHandle::Close);
  Local<ObjectTemplate> dirt = dir->InstanceTemplate();
  dirt->SetInternalFieldCount(DirHandle::kInternalFieldCount);
  SetConstructorFunction(context, target, ""DirHandle"", dir);
  env->set_dir_instance_template(dirt);
}",29,,403,5,,void
157196,BLOCK,-1,,"{
  registry->Register(OpenDir);
  registry->Register(DirHandle::New);
  registry->Register(DirHandle::Read);
  registry->Register(DirHandle::Close);
}",70,,420,2,,void
157232,BLOCK,-1,,<empty>,1,,1,1,,ANY
157235,BLOCK,-1,,"{ uv_os_free_environ(items, count); }",37,,193,1,,void
157261,BLOCK,-1,,<empty>,1,,1,1,,ANY
157267,BLOCK,-1,,<empty>,,,,3,,<empty>
157272,BLOCK,-1,,<empty>,,,,2,,<empty>
157279,BLOCK,-1,,<empty>,,,,4,,<empty>
157285,BLOCK,-1,,<empty>,,,,3,,<empty>
157290,BLOCK,-1,,<empty>,,,,2,,<empty>
157296,BLOCK,-1,,<empty>,,,,3,,<empty>
157301,BLOCK,-1,,<empty>,,,,2,,<empty>
157308,BLOCK,-1,,<empty>,,,,3,,<empty>
157313,BLOCK,-1,,<empty>,,,,2,,<empty>
157320,BLOCK,-1,,<empty>,,,,4,,<empty>
157326,BLOCK,-1,,<empty>,,,,3,,<empty>
157331,BLOCK,-1,,<empty>,,,,2,,<empty>
157337,BLOCK,-1,,<empty>,,,,3,,<empty>
157342,BLOCK,-1,,<empty>,,,,2,,<empty>
157347,BLOCK,-1,,<empty>,,,,2,,<empty>
157351,BLOCK,-1,,<empty>,,,,1,,<empty>
157356,BLOCK,-1,,<empty>,69,,61,2,,void
157374,BLOCK,-1,,"{
  if (key.length() == 2 && key[0] == 'T' && key[1] == 'Z') {
#ifdef __POSIX__
    tzset();
    isolate->DateTimeConfigurationChangeNotification(
        Isolate::TimeZoneDetection::kRedetect);
#else
    _tzset();

# if defined(NODE_HAVE_I18N_SUPPORT)
    isolate->DateTimeConfigurationChangeNotification(
        Isolate::TimeZoneDetection::kSkip);

    // On windows, the TZ environment is not supported out of the box.
    // By default, v8 will only be able to detect the system configured
    // timezone. This supports using the TZ environment variable to set
    // the default timezone instead.
    if (val != nullptr) i18n::SetDefaultTimeZone(val);
# else
    isolate->DateTimeConfigurationChangeNotification(
        Isolate::TimeZoneDetection::kRedetect);
# endif
#endif
  }
}",32,,77,4,,void
157394,BLOCK,-1,,"{
#ifdef __POSIX__
    tzset();
    isolate->DateTimeConfigurationChangeNotification(
        Isolate::TimeZoneDetection::kRedetect);
#else
    _tzset();

# if defined(NODE_HAVE_I18N_SUPPORT)
    isolate->DateTimeConfigurationChangeNotification(
        Isolate::TimeZoneDetection::kSkip);

    // On windows, the TZ environment is not supported out of the box.
    // By default, v8 will only be able to detect the system configured
    // timezone. This supports using the TZ environment variable to set
    // the default timezone instead.
    if (val != nullptr) i18n::SetDefaultTimeZone(val);
# else
    isolate->DateTimeConfigurationChangeNotification(
        Isolate::TimeZoneDetection::kRedetect);
# endif
#endif
  }",60,,78,2,,void
157409,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::env_var_mutex);

  size_t init_sz = 256;
  MaybeStackBuffer<char, 256> val;
  int ret = uv_os_getenv(key, *val, &init_sz);

  if (ret == UV_ENOBUFS) {
    // Buffer is not large enough, reallocate to the updated init_sz
    // and fetch env value again.
    val.AllocateSufficientStorage(init_sz);
    ret = uv_os_getenv(key, *val, &init_sz);
  }

  if (ret >= 0) {  // Env key value fetch success.
    return Just(std::string(*val, init_sz));
  }

  return Nothing<std::string>();
}",61,,103,2,,void
157433,BLOCK,-1,,"{
    // Buffer is not large enough, reallocate to the updated init_sz
    // and fetch env value again.
    val.AllocateSufficientStorage(init_sz);
    ret = uv_os_getenv(key, *val, &init_sz);
  }",26,,110,2,,void
157451,BLOCK,-1,,"{  // Env key value fetch success.
    return Just(std::string(*val, init_sz));
  }",17,,117,2,,void
157469,BLOCK,-1,,"{
  node::Utf8Value key(isolate, property);
  Maybe<std::string> value = Get(*key);

  if (value.IsJust()) {
    std::string val = value.FromJust();
    return String::NewFromUtf8(
        isolate, val.data(), NewStringType::kNormal, val.size());
  }

  return MaybeLocal<String>();
}",68,,125,3,,void
157490,BLOCK,-1,,"{
    std::string val = value.FromJust();
    return String::NewFromUtf8(
        isolate, val.data(), NewStringType::kNormal, val.size());
  }",23,,129,2,,void
157523,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::env_var_mutex);

  node::Utf8Value key(isolate, property);
  node::Utf8Value val(isolate, value);

#ifdef _WIN32
  if (key.length() > 0 && key[0] == '=') return;
#endif
  uv_os_setenv(*key, *val);
  DateTimeConfigurationChangeNotification(isolate, key, *val);
}",45,,140,4,,void
157551,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::env_var_mutex);

  char val[2];
  size_t init_sz = sizeof(val);
  int ret = uv_os_getenv(key, val, &init_sz);

  if (ret == UV_ENOENT) {
    return -1;
  }

#ifdef _WIN32
  if (key[0] == '=') {
    return static_cast<int32_t>(ReadOnly) |
           static_cast<int32_t>(DontDelete) |
           static_cast<int32_t>(DontEnum);
  }
#endif

  return 0;
}",52,,153,2,,void
157575,BLOCK,-1,,"{
    return -1;
  }",25,,160,2,,void
157586,BLOCK,-1,,"{
  node::Utf8Value key(isolate, property);
  return Query(*key);
}",77,,175,3,,void
157600,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::env_var_mutex);

  node::Utf8Value key(isolate, property);
  uv_os_unsetenv(*key);
  DateTimeConfigurationChangeNotification(isolate, key);
}",69,,180,3,,void
157620,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::env_var_mutex);
  uv_env_item_t* items;
  int count;

  auto cleanup = OnScopeLeave([&]() { uv_os_free_environ(items, count); });
  CHECK_EQ(uv_os_environ(&items, &count), 0);

  MaybeStackBuffer<Local<Value>, 256> env_v(count);
  int env_v_index = 0;
  for (int i = 0; i < count; i++) {
#ifdef _WIN32
    // If the key starts with '=' it is a hidden environment variable.
    if (items[i].name[0] == '=') continue;
#endif
    MaybeLocal<String> str = String::NewFromUtf8(isolate, items[i].name);
    if (str.IsEmpty()) {
      isolate->ThrowException(ERR_STRING_TOO_LONG(isolate));
      return Local<Array>();
    }
    env_v[env_v_index++] = str.ToLocalChecked();
  }

  return Array::New(isolate, env_v.out(), env_v_index);
}",62,,188,2,,void
157646,BLOCK,-1,,<empty>,3,,198,1,,void
157656,BLOCK,4,,"{
#ifdef _WIN32
    // If the key starts with '=' it is a hidden environment variable.
    if (items[i].name[0] == '=') continue;
#endif
    MaybeLocal<String> str = String::NewFromUtf8(isolate, items[i].name);
    if (str.IsEmpty()) {
      isolate->ThrowException(ERR_STRING_TOO_LONG(isolate));
      return Local<Array>();
    }
    env_v[env_v_index++] = str.ToLocalChecked();
  }",35,,198,4,,void
157678,BLOCK,-1,,"{
      isolate->ThrowException(ERR_STRING_TOO_LONG(isolate));
      return Local<Array>();
    }",24,,204,2,,void
157711,BLOCK,-1,,"{
  HandleScope handle_scope(isolate);
  Local<Context> context = isolate->GetCurrentContext();

  std::shared_ptr<KVStore> copy = KVStore::CreateMapKVStore();
  Local<Array> keys = Enumerate(isolate);
  uint32_t keys_length = keys->Length();
  for (uint32_t i = 0; i < keys_length; i++) {
    Local<Value> key = keys->Get(context, i).ToLocalChecked();
    CHECK(key->IsString());
    copy->Set(isolate,
              key.As<String>(),
              Get(isolate, key.As<String>()).ToLocalChecked());
  }
  return copy;
}",65,,214,2,,void
157753,BLOCK,-1,,<empty>,3,,221,1,,void
157763,BLOCK,4,,"{
    Local<Value> key = keys->Get(context, i).ToLocalChecked();
    CHECK(key->IsString());
    copy->Set(isolate,
              key.As<String>(),
              Get(isolate, key.As<String>()).ToLocalChecked());
  }",46,,221,4,,void
157808,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  auto it = map_.find(key);
  return it == map_.end() ? Nothing<std::string>() : Just(it->second);
}",59,,231,2,,void
157839,BLOCK,-1,,"{
  Utf8Value str(isolate, key);
  Maybe<std::string> value = Get(*str);
  if (value.IsNothing()) return Local<String>();
  std::string val = value.FromJust();
  return String::NewFromUtf8(
      isolate, val.data(), NewStringType::kNormal, val.size());
}",79,,237,3,,void
157860,BLOCK,-1,,<empty>,26,,240,2,,void
157893,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  Utf8Value key_str(isolate, key);
  Utf8Value value_str(isolate, value);
  if (*key_str != nullptr && key_str.length() > 0 && *value_str != nullptr) {
    map_[std::string(*key_str, key_str.length())] =
        std::string(*value_str, value_str.length());
  }
}",80,,246,4,,void
157922,BLOCK,-1,,"{
    map_[std::string(*key_str, key_str.length())] =
        std::string(*value_str, value_str.length());
  }",77,,250,2,,void
157950,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  return map_.find(key) == map_.end() ? -1 : 0;
}",50,,256,2,,void
157974,BLOCK,-1,,"{
  Utf8Value str(isolate, key);
  return Query(*str);
}",70,,261,3,,void
157988,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  Utf8Value str(isolate, key);
  map_.erase(std::string(*str, str.length()));
}",62,,266,3,,void
158014,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  std::vector<Local<Value>> values;
  values.reserve(map_.size());
  for (const auto& pair : map_) {
    values.emplace_back(
        String::NewFromUtf8(isolate, pair.first.data(),
                            NewStringType::kNormal, pair.first.size())
            .ToLocalChecked());
  }
  return Array::New(isolate, values.data(), values.size());
}",60,,272,2,,void
158038,BLOCK,-1,,"{
    values.emplace_back(
        String::NewFromUtf8(isolate, pair.first.data(),
                            NewStringType::kNormal, pair.first.size())
            .ToLocalChecked());
  }",33,,276,3,,void
158084,BLOCK,-1,,"{
  return std::make_shared<MapKVStore>(*this);
}",68,,285,2,,void
158097,BLOCK,-1,,"{
  return std::make_shared<MapKVStore>();
}",54,,289,1,,void
158108,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  HandleScope handle_scope(isolate);
  Local<Array> keys;
  if (!entries->GetOwnPropertyNames(context).ToLocal(&keys))
    return Nothing<bool>();
  uint32_t keys_length = keys->Length();
  for (uint32_t i = 0; i < keys_length; i++) {
    Local<Value> key;
    if (!keys->Get(context, i).ToLocal(&key))
      return Nothing<bool>();
    if (!key->IsString()) continue;

    Local<Value> value;
    Local<String> value_string;
    if (!entries->Get(context, key).ToLocal(&value) ||
        !value->ToString(context).ToLocal(&value_string)) {
      return Nothing<bool>();
    }

    Set(isolate, key.As<String>(), value_string);
  }
  return Just(true);
}",62,,294,3,,void
158136,BLOCK,-1,,<empty>,5,,299,2,,void
158147,BLOCK,-1,,<empty>,3,,301,1,,void
158157,BLOCK,4,,"{
    Local<Value> key;
    if (!keys->Get(context, i).ToLocal(&key))
      return Nothing<bool>();
    if (!key->IsString()) continue;

    Local<Value> value;
    Local<String> value_string;
    if (!entries->Get(context, key).ToLocal(&value) ||
        !value->ToString(context).ToLocal(&value_string)) {
      return Nothing<bool>();
    }

    Set(isolate, key.As<String>(), value_string);
  }",46,,301,4,,void
158176,BLOCK,-1,,<empty>,7,,304,2,,void
158185,BLOCK,-1,,<empty>,27,,305,2,,void
158222,BLOCK,-1,,"{
      return Nothing<bool>();
    }",59,,310,2,,void
158241,BLOCK,-1,,"{
  HandleScope scope(isolate);
  Local<Array> keys = Enumerate(isolate);
  uint32_t keys_length = keys->Length();
  for (uint32_t i = 0; i < keys_length; i++) {
    Local<Value> key;
    Local<String> value;
    bool ok = keys->Get(context, i).ToLocal(&key);
    ok = ok && key->IsString();
    ok = ok && Get(isolate, key.As<String>()).ToLocal(&value);
    ok = ok && object->Set(context, key, value).To(&ok);
    if (!ok) return Nothing<bool>();
  }
  return Just(true);
}",67,,323,4,,void
158261,BLOCK,-1,,<empty>,3,,327,1,,void
158271,BLOCK,4,,"{
    Local<Value> key;
    Local<String> value;
    bool ok = keys->Get(context, i).ToLocal(&key);
    ok = ok && key->IsString();
    ok = ok && Get(isolate, key.As<String>()).ToLocal(&value);
    ok = ok && object->Set(context, key, value).To(&ok);
    if (!ok) return Nothing<bool>();
  }",46,,327,4,,void
158338,BLOCK,-1,,<empty>,14,,334,2,,void
158349,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  CHECK(env->has_run_bootstrapping_code());
  if (property->IsSymbol()) {
    return info.GetReturnValue().SetUndefined();
  }
  CHECK(property->IsString());
  MaybeLocal<String> value_string =
      env->env_vars()->Get(env->isolate(), property.As<String>());
  if (!value_string.IsEmpty()) {
    info.GetReturnValue().Set(value_string.ToLocalChecked());
  }
}",64,,340,3,,void
158368,BLOCK,-1,,"{
    return info.GetReturnValue().SetUndefined();
  }",29,,343,2,,void
158409,BLOCK,-1,,"{
    info.GetReturnValue().Set(value_string.ToLocalChecked());
  }",32,,349,2,,void
158427,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  CHECK(env->has_run_bootstrapping_code());
  // calling env->EmitProcessEnvWarning() sets a variable indicating that
  // warnings have been emitted. It should be called last after other
  // conditions leading to a warning have been met.
  if (env->options()->pending_deprecation && !value->IsString() &&
      !value->IsNumber() && !value->IsBoolean() &&
      env->EmitProcessEnvWarning()) {
    if (ProcessEmitDeprecationWarning(
            env,
            ""Assigning any value other than a string, number, or boolean to a ""
            ""process.env property is deprecated. Please make sure to convert ""
            ""the ""
            ""value to a string before setting process.env with it."",
            ""DEP0104"")
            .IsNothing())
      return;
  }

  Local<String> key;
  Local<String> value_string;
  if (!property->ToString(env->context()).ToLocal(&key) ||
      !value->ToString(env->context()).ToLocal(&value_string)) {
 ...",64,,356,4,,void
158471,BLOCK,-1,,"{
    if (ProcessEmitDeprecationWarning(
            env,
            ""Assigning any value other than a string, number, or boolean to a ""
            ""process.env property is deprecated. Please make sure to convert ""
            ""the ""
            ""value to a string before setting process.env with it."",
            ""DEP0104"")
            .IsNothing())
      return;
  }",37,,364,2,,void
158480,BLOCK,-1,,<empty>,7,,373,2,,void
158522,BLOCK,-1,,"{
    return;
  }",64,,379,2,,void
158550,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  CHECK(env->has_run_bootstrapping_code());
  if (property->IsString()) {
    int32_t rc = env->env_vars()->Query(env->isolate(), property.As<String>());
    if (rc != -1) info.GetReturnValue().Set(rc);
  }
}",65,,390,3,,void
158569,BLOCK,-1,,"{
    int32_t rc = env->env_vars()->Query(env->isolate(), property.As<String>());
    if (rc != -1) info.GetReturnValue().Set(rc);
  }",29,,393,2,,void
158593,BLOCK,-1,,<empty>,19,,395,2,,void
158607,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  CHECK(env->has_run_bootstrapping_code());
  if (property->IsString()) {
    env->env_vars()->Delete(env->isolate(), property.As<String>());
  }

  // process.env never has non-configurable properties, so always
  // return true like the tc39 delete operator.
  info.GetReturnValue().Set(true);
}",67,,400,3,,void
158626,BLOCK,-1,,"{
    env->env_vars()->Delete(env->isolate(), property.As<String>());
  }",29,,403,2,,void
158654,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  CHECK(env->has_run_bootstrapping_code());

  info.GetReturnValue().Set(
      env->env_vars()->Enumerate(env->isolate()));
}",68,,412,2,,void
158692,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  if (desc.has_value()) {
    if (!desc.has_writable() ||
        !desc.has_enumerable() ||
        !desc.has_configurable()) {
      THROW_ERR_INVALID_OBJECT_DEFINE_PROPERTY(env,
                                               ""'process.env' only accepts a ""
                                               ""configurable, writable,""
                                               "" and enumerable ""
                                               ""data descriptor"");
    } else if (!desc.configurable() ||
               !desc.enumerable() ||
               !desc.writable()) {
      THROW_ERR_INVALID_OBJECT_DEFINE_PROPERTY(env,
                                               ""'process.env' only accepts a ""
                                               ""configurable, writable,""
                                               "" and enumerable ""
                                               ""data descriptor"");
    } else {
      return EnvS...",65,,422,4,,void
158706,BLOCK,-1,,"{
    if (!desc.has_writable() ||
        !desc.has_enumerable() ||
        !desc.has_configurable()) {
      THROW_ERR_INVALID_OBJECT_DEFINE_PROPERTY(env,
                                               ""'process.env' only accepts a ""
                                               ""configurable, writable,""
                                               "" and enumerable ""
                                               ""data descriptor"");
    } else if (!desc.configurable() ||
               !desc.enumerable() ||
               !desc.writable()) {
      THROW_ERR_INVALID_OBJECT_DEFINE_PROPERTY(env,
                                               ""'process.env' only accepts a ""
                                               ""configurable, writable,""
                                               "" and enumerable ""
                                               ""data descriptor"");
    } else {
      return EnvSetter(property, desc.value(), info);
    }
  }",25,,424,2,,void
158725,BLOCK,-1,,"{
      THROW_ERR_INVALID_OBJECT_DEFINE_PROPERTY(env,
                                               ""'process.env' only accepts a ""
                                               ""configurable, writable,""
                                               "" and enumerable ""
                                               ""data descriptor"");
    }",35,,427,2,,void
158730,BLOCK,-1,,<empty>,12,,433,1,,void
158749,BLOCK,-1,,"{
      THROW_ERR_INVALID_OBJECT_DEFINE_PROPERTY(env,
                                               ""'process.env' only accepts a ""
                                               ""configurable, writable,""
                                               "" and enumerable ""
                                               ""data descriptor"");
    }",34,,435,2,,void
158754,BLOCK,-1,,"{
      return EnvSetter(property, desc.value(), info);
    }",12,,441,1,,void
158764,BLOCK,-1,,<empty>,10,,444,1,,void
158775,BLOCK,-1,,"{
    // we don't accept a getter/setter in 'process.env'
    THROW_ERR_INVALID_OBJECT_DEFINE_PROPERTY(env,
                                             ""'process.env' does not accept an""
                                             "" accessor(getter/setter)""
                                             "" descriptor"");
  }",48,,444,2,,void
158780,BLOCK,-1,,"{
    THROW_ERR_INVALID_OBJECT_DEFINE_PROPERTY(env,
                                             ""'process.env' only accepts a ""
                                             ""configurable, writable,""
                                             "" and enumerable ""
                                             ""data descriptor"");
  }",10,,450,1,,void
158789,BLOCK,-1,,"{
  HandleScope scope(isolate);
  if (!isolate_data->env_proxy_template().IsEmpty()) return;
  Local<FunctionTemplate> env_proxy_ctor_template =
      FunctionTemplate::New(isolate);
  Local<ObjectTemplate> env_proxy_template =
      ObjectTemplate::New(isolate, env_proxy_ctor_template);
  env_proxy_template->SetHandler(NamedPropertyHandlerConfiguration(
      EnvGetter,
      EnvSetter,
      EnvQuery,
      EnvDeleter,
      EnvEnumerator,
      EnvDefiner,
      nullptr,
      Local<Value>(),
      PropertyHandlerFlags::kHasNoSideEffect));
  isolate_data->set_env_proxy_template(env_proxy_template);
  isolate_data->set_env_proxy_ctor_template(env_proxy_ctor_template);
}",74,,459,3,,void
158802,BLOCK,-1,,<empty>,54,,461,2,,void
158857,BLOCK,-1,,"{
  registry->Register(EnvGetter);
  registry->Register(EnvSetter);
  registry->Register(EnvQuery);
  registry->Register(EnvDeleter);
  registry->Register(EnvEnumerator);
  registry->Register(EnvDefiner);
}",76,,480,2,,void
158893,BLOCK,-1,,"{
#if HAVE_INSPECTOR
    env->inspector_agent()->ReportUncaughtException(error, message);
#endif
  }",36,,376,1,,void
158900,BLOCK,-1,,"{
      Local<Value> enhanced;
      Local<Value> argv[] = {err_obj};
      if (!enhancer.IsEmpty() &&
          enhancer
              ->Call(env->context(), Undefined(isolate), arraysize(argv), argv)
              .ToLocal(&enhanced)) {
        stack_trace = enhanced;
      }
    }",55,,396,2,,void
158936,BLOCK,-1,,"{
        stack_trace = enhanced;
      }",36,,402,2,,void
158967,BLOCK,-1,,<empty>,1,,1,1,,ANY
158972,BLOCK,-1,,"{
  if (!er.IsEmpty() && er->IsObject()) {
    Local<Object> err_obj = er.As<Object>();
    auto maybe_value =
        err_obj->GetPrivate(env->context(), env->decorated_private_symbol());
    Local<Value> decorated;
    return maybe_value.ToLocal(&decorated) && decorated->IsTrue();
  }
  return false;
}",62,,37,3,,void
158984,BLOCK,-1,,"{
    Local<Object> err_obj = er.As<Object>();
    auto maybe_value =
        err_obj->GetPrivate(env->context(), env->decorated_private_symbol());
    Local<Value> decorated;
    return maybe_value.ToLocal(&decorated) && decorated->IsTrue();
  }",40,,38,2,,void
159038,BLOCK,-1,,"{
  v8::TryCatch try_catch(isolate);
  HandleScope handle_scope(isolate);
  Environment* env = Environment::GetCurrent(context);

  // The ScriptResourceName of the message may be different from the one we use
  // to compile the script. V8 replaces it when it detects magic comments in
  // the source texts.
  Local<Value> script_resource_name = message->GetScriptResourceName();
  int linenum = message->GetLineNumber(context).FromJust();
  int columnum = message->GetStartColumn(context).FromJust();

  Local<Value> argv[] = {script_resource_name,
                         v8::Int32::New(isolate, linenum),
                         v8::Int32::New(isolate, columnum)};
  MaybeLocal<Value> maybe_ret = env->get_source_map_error_source()->Call(
      context, Undefined(isolate), arraysize(argv), argv);
  Local<Value> ret;
  if (!maybe_ret.ToLocal(&ret)) {
    // Ignore the caught exceptions.
    DCHECK(try_catch.HasCaught());
    return std::string();
  }
  if (!ret->IsString()) {
    return...",72,,55,5,,void
159138,BLOCK,-1,,"{
    // Ignore the caught exceptions.
    DCHECK(try_catch.HasCaught());
    return std::string();
  }",33,,73,2,,void
159155,BLOCK,-1,,"{
    return std::string();
  }",25,,78,2,,void
159182,BLOCK,-1,,"{
  MaybeLocal<String> source_line_maybe = message->GetSourceLine(context);
  node::Utf8Value encoded_source(isolate, source_line_maybe.ToLocalChecked());
  std::string sourceline(*encoded_source, encoded_source.length());
  *added_exception_line = false;

  if (sourceline.find(""node-do-not-add-exception-line"") != std::string::npos) {
    return sourceline;
  }

  // If source maps have been enabled, the exception line will instead be
  // added in the JavaScript context:
  Environment* env = Environment::GetCurrent(isolate);
  const bool has_source_map_url =
      !message->GetScriptOrigin().SourceMapUrl().IsEmpty() &&
      !message->GetScriptOrigin().SourceMapUrl()->IsUndefined();
  if (has_source_map_url && env != nullptr && env->source_maps_enabled()) {
    std::string source = GetSourceMapErrorSource(
        isolate, context, message, added_exception_line);
    if (*added_exception_line) {
      return source;
    }
  }

  // Because of how node modules work, all scripts are ...",63,,89,5,,void
159225,BLOCK,-1,,"{
    return sourceline;
  }",79,,95,2,,void
159273,BLOCK,-1,,"{
    std::string source = GetSourceMapErrorSource(
        isolate, context, message, added_exception_line);
    if (*added_exception_line) {
      return source;
    }
  }",75,,105,2,,void
159285,BLOCK,-1,,"{
      return source;
    }",32,,108,2,,void
159363,BLOCK,-1,,"{
    CHECK_GE(end, start);
    start -= script_start;
    end -= script_start;
  }",30,,145,2,,void
159411,BLOCK,-1,,"{
    return buf;
  }",53,,160,2,,void
159424,BLOCK,-1,,<empty>,3,,168,1,,void
159434,BLOCK,4,,"{
    if (sourceline[i] == '\0' || off >= kUnderlineBufsize) {
      break;
    }
    CHECK_LT(off, kUnderlineBufsize);
    underline_buf[off++] = (sourceline[i] == '\t') ? '\t' : ' ';
  }",35,,168,4,,void
159445,BLOCK,-1,,"{
      break;
    }",60,,169,2,,void
159464,BLOCK,-1,,<empty>,3,,175,1,,void
159474,BLOCK,4,,"{
    if (sourceline[i] == '\0' || off >= kUnderlineBufsize) {
      break;
    }
    CHECK_LT(off, kUnderlineBufsize);
    underline_buf[off++] = '^';
  }",37,,175,4,,void
159485,BLOCK,-1,,"{
      break;
    }",60,,176,2,,void
159519,BLOCK,-1,,"{
  std::string result;
  for (int i = 0; i < stack->GetFrameCount(); i++) {
    Local<StackFrame> stack_frame = stack->GetFrame(isolate, i);
    node::Utf8Value fn_name_s(isolate, stack_frame->GetFunctionName());
    node::Utf8Value script_name(isolate, stack_frame->GetScriptName());
    const int line_number = stack_frame->GetLineNumber();
    const int column = stack_frame->GetColumn();

    if (stack_frame->IsEval()) {
      if (stack_frame->GetScriptId() == Message::kNoScriptIdInfo) {
        result += SPrintF(""    at [eval]:%i:%i\n"", line_number, column);
      } else {
        std::vector<char> buf(script_name.length() + 64);
        snprintf(buf.data(),
                 buf.size(),
                 ""    at [eval] (%s:%i:%i)\n"",
                 *script_name,
                 line_number,
                 column);
        result += std::string(buf.data());
      }
      break;
    }

    if (fn_name_s.length() == 0) {
      std::vector<char> buf(script_name.length() + 64);
  ...",80,,188,3,,void
159522,BLOCK,-1,,<empty>,3,,190,1,,void
159535,BLOCK,4,,"{
    Local<StackFrame> stack_frame = stack->GetFrame(isolate, i);
    node::Utf8Value fn_name_s(isolate, stack_frame->GetFunctionName());
    node::Utf8Value script_name(isolate, stack_frame->GetScriptName());
    const int line_number = stack_frame->GetLineNumber();
    const int column = stack_frame->GetColumn();

    if (stack_frame->IsEval()) {
      if (stack_frame->GetScriptId() == Message::kNoScriptIdInfo) {
        result += SPrintF(""    at [eval]:%i:%i\n"", line_number, column);
      } else {
        std::vector<char> buf(script_name.length() + 64);
        snprintf(buf.data(),
                 buf.size(),
                 ""    at [eval] (%s:%i:%i)\n"",
                 *script_name,
                 line_number,
                 column);
        result += std::string(buf.data());
      }
      break;
    }

    if (fn_name_s.length() == 0) {
      std::vector<char> buf(script_name.length() + 64);
      snprintf(buf.data(),
               buf.size(),
               ""    at ...",52,,190,4,,void
159581,BLOCK,-1,,"{
      if (stack_frame->GetScriptId() == Message::kNoScriptIdInfo) {
        result += SPrintF(""    at [eval]:%i:%i\n"", line_number, column);
      } else {
        std::vector<char> buf(script_name.length() + 64);
        snprintf(buf.data(),
                 buf.size(),
                 ""    at [eval] (%s:%i:%i)\n"",
                 *script_name,
                 line_number,
                 column);
        result += std::string(buf.data());
      }
      break;
    }",32,,197,2,,void
159591,BLOCK,-1,,"{
        result += SPrintF(""    at [eval]:%i:%i\n"", line_number, column);
      }",67,,198,2,,void
159599,BLOCK,-1,,"{
        std::vector<char> buf(script_name.length() + 64);
        snprintf(buf.data(),
                 buf.size(),
                 ""    at [eval] (%s:%i:%i)\n"",
                 *script_name,
                 line_number,
                 column);
        result += std::string(buf.data());
      }",14,,200,1,,void
159640,BLOCK,-1,,"{
      std::vector<char> buf(script_name.length() + 64);
      snprintf(buf.data(),
               buf.size(),
               ""    at %s:%i:%i\n"",
               *script_name,
               line_number,
               column);
      result += std::string(buf.data());
    }",34,,213,2,,void
159674,BLOCK,-1,,"{
      std::vector<char> buf(fn_name_s.length() + script_name.length() + 64);
      snprintf(buf.data(),
               buf.size(),
               ""    at %s (%s:%i:%i)\n"",
               *fn_name_s,
               *script_name,
               line_number,
               column);
      result += std::string(buf.data());
    }",12,,222,1,,void
159720,BLOCK,-1,,"{
  FPrintF(stderr, ""%s\n"", str);
  fflush(stderr);
}",59,,237,2,,void
159731,BLOCK,-1,,"{
  PrintToStderrAndFlush(FormatStackTrace(isolate, stack));
}",65,,242,3,,void
159744,BLOCK,-1,,"{
  std::string result;
  node::Utf8Value reason(isolate,
                         err->ToDetailString(context)
                             .FromMaybe(Local<String>()));
  if (add_source_line) {
    bool added_exception_line = false;
    std::string source =
        GetErrorSource(isolate, context, message, &added_exception_line);
    result = source + '\n';
  }
  result += reason.ToString() + '\n';

  Local<v8::StackTrace> stack = message->GetStackTrace();
  if (!stack.IsEmpty()) result += FormatStackTrace(isolate, stack);
  return result;
}",64,,250,6,,void
159760,BLOCK,-1,,"{
    bool added_exception_line = false;
    std::string source =
        GetErrorSource(isolate, context, message, &added_exception_line);
    result = source + '\n';
  }",24,,255,2,,void
159805,BLOCK,-1,,<empty>,25,,264,2,,void
159819,BLOCK,-1,,"{
  CHECK(try_catch.HasCaught());
  return FormatCaughtException(
      isolate, context, try_catch.Exception(), try_catch.Message());
}",66,,270,4,,void
159843,BLOCK,-1,,"{
  PrintToStderrAndFlush(FormatCaughtException(isolate, context, try_catch));
}",58,,278,4,,void
159856,BLOCK,-1,,"{
  if (message.IsEmpty()) return;

  HandleScope scope(env->isolate());
  Local<Object> err_obj;
  if (!er.IsEmpty() && er->IsObject()) {
    err_obj = er.As<Object>();
    // If arrow_message is already set, skip.
    auto maybe_value = err_obj->GetPrivate(env->context(),
                                          env->arrow_message_private_symbol());
    Local<Value> lvalue;
    if (!maybe_value.ToLocal(&lvalue) || lvalue->IsString())
      return;
  }

  bool added_exception_line = false;
  std::string source = GetErrorSource(
      env->isolate(), env->context(), message, &added_exception_line);
  if (!added_exception_line) {
    return;
  }
  MaybeLocal<Value> arrow_str = ToV8Value(env->context(), source);

  const bool can_set_arrow = !arrow_str.IsEmpty() && !err_obj.IsEmpty();
  // If allocating arrow_str failed, print it out. There's not much else to do.
  // If it's not an error, but something needs to be printed out because
  // it's a fatal exception, also print it out fr...",55,,285,5,,void
159862,BLOCK,-1,,<empty>,26,,286,2,,void
159886,BLOCK,-1,,"{
    err_obj = er.As<Object>();
    // If arrow_message is already set, skip.
    auto maybe_value = err_obj->GetPrivate(env->context(),
                                          env->arrow_message_private_symbol());
    Local<Value> lvalue;
    if (!maybe_value.ToLocal(&lvalue) || lvalue->IsString())
      return;
  }",40,,290,2,,void
159926,BLOCK,-1,,<empty>,7,,297,2,,void
159950,BLOCK,-1,,"{
    return;
  }",30,,303,2,,void
159991,BLOCK,-1,,"{
    if (env->printed_error()) return;
    Mutex::ScopedLock lock(per_process::tty_mutex);
    env->set_printed_error(true);

    ResetStdio();
    FPrintF(stderr, ""\n%s"", source);
    return;
  }",77,,314,2,,void
159997,BLOCK,-1,,<empty>,31,,315,2,,void
160039,BLOCK,-1,,"{
  DumpBacktrace(stderr);
  fflush(stderr);
  ABORT_NO_BACKTRACE();
}",27,,331,1,,void
160048,BLOCK,-1,,"{
  std::string name = GetHumanReadableProcessName();

  fprintf(stderr,
          ""%s: %s:%s%s Assertion `%s' failed.\n"",
          name.c_str(),
          info.file_line,
          info.function,
          *info.function ? "":"" : """",
          info.message);
  fflush(stderr);

  Abort();
}",53,,337,2,,void
160087,BLOCK,-1,,"{
  if (!env->can_call_into_js())
    enhance_stack = EnhanceFatalException::kDontEnhance;

  Isolate* isolate = env->isolate();
  CHECK(!error.IsEmpty());
  CHECK(!message.IsEmpty());
  HandleScope scope(isolate);

  AppendExceptionLine(env, error, message, FATAL_ERROR);

  auto report_to_inspector = [&]() {
#if HAVE_INSPECTOR
    env->inspector_agent()->ReportUncaughtException(error, message);
#endif
  };

  Local<Value> arrow;
  Local<Value> stack_trace;
  bool decorated = IsExceptionDecorated(env, error);

  if (!error->IsObject()) {  // We can only enhance actual errors.
    report_to_inspector();
    stack_trace = Undefined(isolate);
    // If error is not an object, AppendExceptionLine() has already print the
    // source line and the arrow to stderr.
    // TODO(joyeecheung): move that side effect out of AppendExceptionLine().
    // It is done just to preserve the source line as soon as possible.
  } else {
    Local<Object> err_obj = error.As<Object>();

    auto enhance_...",71,,365,5,,void
160094,BLOCK,-1,,<empty>,5,,367,2,,void
160152,BLOCK,-1,,"{  // We can only enhance actual errors.
    report_to_inspector();
    stack_trace = Undefined(isolate);
    // If error is not an object, AppendExceptionLine() has already print the
    // source line and the arrow to stderr.
    // TODO(joyeecheung): move that side effect out of AppendExceptionLine().
    // It is done just to preserve the source line as soon as possible.
  }",27,,386,2,,void
160159,BLOCK,-1,,"{
    Local<Object> err_obj = error.As<Object>();

    auto enhance_with = [&](Local<Function> enhancer) {
      Local<Value> enhanced;
      Local<Value> argv[] = {err_obj};
      if (!enhancer.IsEmpty() &&
          enhancer
              ->Call(env->context(), Undefined(isolate), arraysize(argv), argv)
              .ToLocal(&enhanced)) {
        stack_trace = enhanced;
      }
    };

    switch (enhance_stack) {
      case EnhanceFatalException::kEnhance: {
        enhance_with(env->enhance_fatal_stack_before_inspector());
        report_to_inspector();
        enhance_with(env->enhance_fatal_stack_after_inspector());
        break;
      }
      case EnhanceFatalException::kDontEnhance: {
        USE(err_obj->Get(env->context(), env->stack_string())
                .ToLocal(&stack_trace));
        report_to_inspector();
        break;
      }
      default:
        UNREACHABLE();
    }

    arrow =
        err_obj->GetPrivate(env->context(), env->arrow_message_private_symbol()...",10,,393,1,,void
160176,BLOCK,-1,,"{
      case EnhanceFatalException::kEnhance: {
        enhance_with(env->enhance_fatal_stack_before_inspector());
        report_to_inspector();
        enhance_with(env->enhance_fatal_stack_after_inspector());
        break;
      }
      case EnhanceFatalException::kDontEnhance: {
        USE(err_obj->Get(env->context(), env->stack_string())
                .ToLocal(&stack_trace));
        report_to_inspector();
        break;
      }
      default:
        UNREACHABLE();
    }",28,,407,2,,void
160181,BLOCK,3,,"{
        enhance_with(env->enhance_fatal_stack_before_inspector());
        report_to_inspector();
        enhance_with(env->enhance_fatal_stack_after_inspector());
        break;
      }",45,,408,3,,void
160198,BLOCK,6,,"{
        USE(err_obj->Get(env->context(), env->stack_string())
                .ToLocal(&stack_trace));
        report_to_inspector();
        break;
      }",49,,414,6,,void
160262,BLOCK,-1,,"{
    if (arrow.IsEmpty() || !arrow->IsString() || decorated) {
      FPrintF(stderr, ""%s\n"", trace);
    } else {
      node::Utf8Value arrow_string(env->isolate(), arrow);
      FPrintF(stderr, ""%s\n%s\n"", arrow_string, trace);
    }
  }",58,,433,2,,void
160276,BLOCK,-1,,"{
      FPrintF(stderr, ""%s\n"", trace);
    }",61,,434,2,,void
160282,BLOCK,-1,,"{
      node::Utf8Value arrow_string(env->isolate(), arrow);
      FPrintF(stderr, ""%s\n%s\n"", arrow_string, trace);
    }",12,,436,1,,void
160296,BLOCK,-1,,"{
    // this really only happens for RangeErrors, since they're the only
    // kind that won't have all this info in the trace, or when non-Error
    // objects are thrown manually.
    MaybeLocal<Value> message;
    MaybeLocal<Value> name;

    if (error->IsObject()) {
      Local<Object> err_obj = error.As<Object>();
      message = err_obj->Get(env->context(), env->message_string());
      name = err_obj->Get(env->context(), env->name_string());
    }

    if (message.IsEmpty() || message.ToLocalChecked()->IsUndefined() ||
        name.IsEmpty() || name.ToLocalChecked()->IsUndefined()) {
      // Not an error object. Just print as-is.
      node::Utf8Value message(env->isolate(), error);

      FPrintF(
          stderr,
          ""%s\n"",
          *message ? message.ToStringView() : ""<toString() threw exception>"");
    } else {
      node::Utf8Value name_string(env->isolate(), name.ToLocalChecked());
      node::Utf8Value message_string(env->isolate(), message.ToLocalChecked()...",10,,440,1,,void
160312,BLOCK,-1,,"{
      Local<Object> err_obj = error.As<Object>();
      message = err_obj->Get(env->context(), env->message_string());
      name = err_obj->Get(env->context(), env->name_string());
    }",28,,447,2,,void
160377,BLOCK,-1,,"{
      // Not an error object. Just print as-is.
      node::Utf8Value message(env->isolate(), error);

      FPrintF(
          stderr,
          ""%s\n"",
          *message ? message.ToStringView() : ""<toString() threw exception>"");
    }",65,,454,2,,void
160397,BLOCK,-1,,"{
      node::Utf8Value name_string(env->isolate(), name.ToLocalChecked());
      node::Utf8Value message_string(env->isolate(), message.ToLocalChecked());
      // Update the report message if it is an object has message property.
      report_message = message_string.ToString();

      if (arrow.IsEmpty() || !arrow->IsString() || decorated) {
        FPrintF(stderr, ""%s: %s\n"", name_string, message_string);
      } else {
        node::Utf8Value arrow_string(env->isolate(), arrow);
        FPrintF(stderr,
            ""%s\n%s: %s\n"", arrow_string, name_string, message_string);
      }
    }",12,,462,1,,void
160437,BLOCK,-1,,"{
        FPrintF(stderr, ""%s: %s\n"", name_string, message_string);
      }",63,,468,2,,void
160444,BLOCK,-1,,"{
        node::Utf8Value arrow_string(env->isolate(), arrow);
        FPrintF(stderr,
            ""%s\n%s: %s\n"", arrow_string, name_string, message_string);
      }",14,,470,1,,void
160466,BLOCK,-1,,"{
      std::string argv0;
      if (!env->argv().empty()) argv0 = env->argv()[0];
      if (argv0.empty()) argv0 = ""node"";
      FPrintF(stderr,
              ""(Use `%s --trace-uncaught ...` to show where the exception ""
              ""was thrown)\n"",
              fs::Basename(argv0, "".exe""));
    }",42,,477,2,,void
160477,BLOCK,-1,,<empty>,33,,479,2,,void
160491,BLOCK,-1,,<empty>,26,,480,2,,void
160514,BLOCK,-1,,"{
    TriggerNodeReport(env, report_message.c_str(), ""Exception"", """", error);
  }",66,,488,2,,void
160531,BLOCK,-1,,"{
    Local<StackTrace> trace = message->GetStackTrace();
    if (!trace.IsEmpty()) {
      FPrintF(stderr, ""Thrown at:\n"");
      PrintStackTrace(env->isolate(), trace);
    }
  }",39,,492,2,,void
160548,BLOCK,-1,,"{
      FPrintF(stderr, ""Thrown at:\n"");
      PrintStackTrace(env->isolate(), trace);
    }",27,,494,2,,void
160565,BLOCK,-1,,"{
    FPrintF(stderr, ""\nNode.js %s\n"", NODE_VERSION);
  }",54,,500,2,,void
160576,BLOCK,-1,,"{
  if (location) {
    FPrintF(stderr, ""FATAL ERROR: %s %s\n"", location, message);
  } else {
    FPrintF(stderr, ""FATAL ERROR: %s\n"", message);
  }

  Isolate* isolate = Isolate::TryGetCurrent();
  bool report_on_fatalerror;
  {
    Mutex::ScopedLock lock(node::per_process::cli_options_mutex);
    report_on_fatalerror = per_process::cli_options->report_on_fatalerror;
  }

  if (report_on_fatalerror) {
    TriggerNodeReport(isolate, message, ""FatalError"", """", Local<Object>());
  }

  fflush(stderr);
  ABORT();
}",75,,507,3,,void
160579,BLOCK,-1,,"{
    FPrintF(stderr, ""FATAL ERROR: %s %s\n"", location, message);
  }",17,,508,2,,void
160586,BLOCK,-1,,"{
    FPrintF(stderr, ""FATAL ERROR: %s\n"", message);
  }",10,,510,1,,void
160599,BLOCK,5,,"{
    Mutex::ScopedLock lock(node::per_process::cli_options_mutex);
    report_on_fatalerror = per_process::cli_options->report_on_fatalerror;
  }",3,,516,5,,void
160616,BLOCK,-1,,"{
    TriggerNodeReport(isolate, message, ""FatalError"", """", Local<Object>());
  }",29,,521,2,,void
160630,BLOCK,-1,,"{
  const char* message =
      details.is_heap_oom ? ""Allocation failed - JavaScript heap out of memory""
                          : ""Allocation failed - process out of memory"";
  if (location) {
    FPrintF(stderr, ""FATAL ERROR: %s %s\n"", location, message);
  } else {
    FPrintF(stderr, ""FATAL ERROR: %s\n"", message);
  }

  Isolate* isolate = Isolate::TryGetCurrent();
  bool report_on_fatalerror;
  {
    Mutex::ScopedLock lock(node::per_process::cli_options_mutex);
    report_on_fatalerror = per_process::cli_options->report_on_fatalerror;
  }

  if (report_on_fatalerror) {
    // Trigger report with the isolate. Environment::GetCurrent may return
    // nullptr here:
    // - If the OOM is reported by a young generation space allocation,
    //   Isolate::GetCurrentContext returns an empty handle.
    // - Otherwise, Isolate::GetCurrentContext returns a non-empty handle.
    TriggerNodeReport(isolate, message, ""OOMError"", """", Local<Object>());
  }

  fflush(stderr);
  ABORT();
}",66,,530,3,,void
160642,BLOCK,-1,,"{
    FPrintF(stderr, ""FATAL ERROR: %s %s\n"", location, message);
  }",17,,534,2,,void
160649,BLOCK,-1,,"{
    FPrintF(stderr, ""FATAL ERROR: %s\n"", message);
  }",10,,536,1,,void
160662,BLOCK,7,,"{
    Mutex::ScopedLock lock(node::per_process::cli_options_mutex);
    report_on_fatalerror = per_process::cli_options->report_on_fatalerror;
  }",3,,542,7,,void
160679,BLOCK,-1,,"{
    // Trigger report with the isolate. Environment::GetCurrent may return
    // nullptr here:
    // - If the OOM is reported by a young generation space allocation,
    //   Isolate::GetCurrentContext returns an empty handle.
    // - Otherwise, Isolate::GetCurrentContext returns a non-empty handle.
    TriggerNodeReport(isolate, message, ""OOMError"", """", Local<Object>());
  }",29,,547,2,,void
160694,BLOCK,-1,,"{
  HandleScope scope(context->GetIsolate());

  Environment* env = Environment::GetCurrent(context);
  if (env->source_maps_enabled()) {
    // We do not expect the maybe_cache_generated_source_map to throw any more
    // exceptions. If it does, just ignore it.
    errors::TryCatchScope try_catch(env);
    Local<Function> maybe_cache_source_map =
        env->maybe_cache_generated_source_map();
    Local<Value> argv[1] = {source};

    MaybeLocal<Value> maybe_cached = maybe_cache_source_map->Call(
        context, context->Global(), arraysize(argv), argv);
    if (maybe_cached.IsEmpty()) {
      DCHECK(try_catch.HasCaught());
    }
  }

  Local<Value> allow_code_gen = context->GetEmbedderData(
      ContextEmbedderIndex::kAllowCodeGenerationFromStrings);
  bool codegen_allowed =
      allow_code_gen->IsUndefined() || allow_code_gen->IsTrue();
  return {
      codegen_allowed,
      {},
  };
}",24,,563,4,,void
160714,BLOCK,-1,,"{
    // We do not expect the maybe_cache_generated_source_map to throw any more
    // exceptions. If it does, just ignore it.
    errors::TryCatchScope try_catch(env);
    Local<Function> maybe_cache_source_map =
        env->maybe_cache_generated_source_map();
    Local<Value> argv[1] = {source};

    MaybeLocal<Value> maybe_cached = maybe_cache_source_map->Call(
        context, context->Global(), arraysize(argv), argv);
    if (maybe_cached.IsEmpty()) {
      DCHECK(try_catch.HasCaught());
    }
  }",35,,567,2,,void
160759,BLOCK,-1,,"{
      DCHECK(try_catch.HasCaught());
    }",33,,577,2,,void
160795,BLOCK,-1,,"{
  if (HasCaught() && !HasTerminated() && mode_ == CatchMode::kFatal) {
    HandleScope scope(env_->isolate());
    Local<v8::Value> exception = Exception();
    Local<v8::Message> message = Message();
    EnhanceFatalException enhance = CanContinue() ?
        EnhanceFatalException::kEnhance : EnhanceFatalException::kDontEnhance;
    if (message.IsEmpty())
      message = Exception::CreateMessage(env_->isolate(), exception);
    ReportFatalException(env_, exception, message, enhance);
    env_->Exit(ExitCode::kExceptionInFatalExceptionHandler);
  }
}",33,,594,1,,void
160807,BLOCK,-1,,"{
    HandleScope scope(env_->isolate());
    Local<v8::Value> exception = Exception();
    Local<v8::Message> message = Message();
    EnhanceFatalException enhance = CanContinue() ?
        EnhanceFatalException::kEnhance : EnhanceFatalException::kDontEnhance;
    if (message.IsEmpty())
      message = Exception::CreateMessage(env_->isolate(), exception);
    ReportFatalException(env_, exception, message, enhance);
    env_->Exit(ExitCode::kExceptionInFatalExceptionHandler);
  }",70,,595,2,,void
160848,BLOCK,-1,,<empty>,7,,602,2,,void
160876,BLOCK,-1,,"{
#define ERRNO_CASE(e)                                                          \
  case e:                                                                      \
    return #e;
  switch (errorno) {
#ifdef EACCES
    ERRNO_CASE(EACCES);
#endif

#ifdef EADDRINUSE
    ERRNO_CASE(EADDRINUSE);
#endif

#ifdef EADDRNOTAVAIL
    ERRNO_CASE(EADDRNOTAVAIL);
#endif

#ifdef EAFNOSUPPORT
    ERRNO_CASE(EAFNOSUPPORT);
#endif

#ifdef EAGAIN
    ERRNO_CASE(EAGAIN);
#endif

#ifdef EWOULDBLOCK
#if EAGAIN != EWOULDBLOCK
    ERRNO_CASE(EWOULDBLOCK);
#endif
#endif

#ifdef EALREADY
    ERRNO_CASE(EALREADY);
#endif

#ifdef EBADF
    ERRNO_CASE(EBADF);
#endif

#ifdef EBADMSG
    ERRNO_CASE(EBADMSG);
#endif

#ifdef EBUSY
    ERRNO_CASE(EBUSY);
#endif

#ifdef ECANCELED
    ERRNO_CASE(ECANCELED);
#endif

#ifdef ECHILD
    ERRNO_CASE(ECHILD);
#endif

#ifdef ECONNABORTED
    ERRNO_CASE(ECONNABORTED);
#endif

#ifdef ECONNREFUSED
    ERRNO_CASE(ECONNREFUSED);
#endif

#ifdef ECONNRESET
    ERRNO_CASE(ECONNRESET)...",39,,608,2,,void
160879,BLOCK,-1,,"{
#ifdef EACCES
    ERRNO_CASE(EACCES);
#endif

#ifdef EADDRINUSE
    ERRNO_CASE(EADDRINUSE);
#endif

#ifdef EADDRNOTAVAIL
    ERRNO_CASE(EADDRNOTAVAIL);
#endif

#ifdef EAFNOSUPPORT
    ERRNO_CASE(EAFNOSUPPORT);
#endif

#ifdef EAGAIN
    ERRNO_CASE(EAGAIN);
#endif

#ifdef EWOULDBLOCK
#if EAGAIN != EWOULDBLOCK
    ERRNO_CASE(EWOULDBLOCK);
#endif
#endif

#ifdef EALREADY
    ERRNO_CASE(EALREADY);
#endif

#ifdef EBADF
    ERRNO_CASE(EBADF);
#endif

#ifdef EBADMSG
    ERRNO_CASE(EBADMSG);
#endif

#ifdef EBUSY
    ERRNO_CASE(EBUSY);
#endif

#ifdef ECANCELED
    ERRNO_CASE(ECANCELED);
#endif

#ifdef ECHILD
    ERRNO_CASE(ECHILD);
#endif

#ifdef ECONNABORTED
    ERRNO_CASE(ECONNABORTED);
#endif

#ifdef ECONNREFUSED
    ERRNO_CASE(ECONNREFUSED);
#endif

#ifdef ECONNRESET
    ERRNO_CASE(ECONNRESET);
#endif

#ifdef EDEADLK
    ERRNO_CASE(EDEADLK);
#endif

#ifdef EDESTADDRREQ
    ERRNO_CASE(EDESTADDRREQ);
#endif

#ifdef EDOM
    ERRNO_CASE(EDOM);
#endif

#ifdef EDQUOT
    ERRNO_CASE(EDQUOT);
#e...",20,,612,2,,void
160888,BLOCK,-1,,"{
  Isolate* isolate = message->GetIsolate();
  switch (message->ErrorLevel()) {
    case Isolate::MessageErrorLevel::kMessageWarning: {
      Environment* env = Environment::GetCurrent(isolate);
      if (!env) {
        break;
      }
      Utf8Value filename(isolate, message->GetScriptOrigin().ResourceName());
      // (filename):(line) (message)
      std::stringstream warning;
      warning << *filename;
      warning << "":"";
      warning << message->GetLineNumber(env->context()).FromMaybe(-1);
      warning << "" "";
      v8::String::Utf8Value msg(isolate, message->Get());
      warning << *msg;
      USE(ProcessEmitWarningGeneric(env, warning.str().c_str(), ""V8""));
      break;
    }
    case Isolate::MessageErrorLevel::kMessageError:
      TriggerUncaughtException(isolate, error, message);
      break;
  }
}",76,,936,3,,void
160901,BLOCK,-1,,"{
    case Isolate::MessageErrorLevel::kMessageWarning: {
      Environment* env = Environment::GetCurrent(isolate);
      if (!env) {
        break;
      }
      Utf8Value filename(isolate, message->GetScriptOrigin().ResourceName());
      // (filename):(line) (message)
      std::stringstream warning;
      warning << *filename;
      warning << "":"";
      warning << message->GetLineNumber(env->context()).FromMaybe(-1);
      warning << "" "";
      v8::String::Utf8Value msg(isolate, message->Get());
      warning << *msg;
      USE(ProcessEmitWarningGeneric(env, warning.str().c_str(), ""V8""));
      break;
    }
    case Isolate::MessageErrorLevel::kMessageError:
      TriggerUncaughtException(isolate, error, message);
      break;
  }",34,,938,2,,void
160908,BLOCK,3,,"{
      Environment* env = Environment::GetCurrent(isolate);
      if (!env) {
        break;
      }
      Utf8Value filename(isolate, message->GetScriptOrigin().ResourceName());
      // (filename):(line) (message)
      std::stringstream warning;
      warning << *filename;
      warning << "":"";
      warning << message->GetLineNumber(env->context()).FromMaybe(-1);
      warning << "" "";
      v8::String::Utf8Value msg(isolate, message->Get());
      warning << *msg;
      USE(ProcessEmitWarningGeneric(env, warning.str().c_str(), ""V8""));
      break;
    }",55,,939,3,,void
160920,BLOCK,-1,,"{
        break;
      }",17,,941,2,,void
160996,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  realm->set_prepare_stack_trace_callback(args[0].As<Function>());
}",76,,962,2,,void
161026,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsBoolean());
  env->set_source_maps_enabled(args[0].As<Boolean>()->Value());
}",75,,968,2,,void
161059,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  env->set_get_source_map_error_source(args[0].As<Function>());
}",46,,975,2,,void
161089,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  env->set_maybe_cache_generated_source_map(args[0].As<Function>());
}",46,,982,2,,void
161119,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  CHECK(args[1]->IsFunction());
  realm->set_enhance_fatal_stack_before_inspector(args[0].As<Function>());
  realm->set_enhance_fatal_stack_after_inspector(args[1].As<Function>());
}",46,,989,2,,void
161166,BLOCK,-1,,"{
  Local<Context> context = args.GetIsolate()->GetCurrentContext();
  Local<String> detail_string;
  if (args[0]->ToDetailString(context).ToLocal(&detail_string))
    args.GetReturnValue().Set(detail_string);
}",76,,998,2,,void
161198,BLOCK,-1,,<empty>,5,,1002,2,,void
161211,BLOCK,-1,,"{
  Isolate* isolate = args.GetIsolate();
  Environment* env = Environment::GetCurrent(isolate);
  Local<Value> exception = args[0];
  Local<Message> message = Exception::CreateMessage(isolate, exception);
  if (env != nullptr && env->abort_on_uncaught_exception()) {
    ReportFatalException(
        env, exception, message, EnhanceFatalException::kEnhance);
    Abort();
  }
  bool from_promise = args[1]->IsTrue();
  errors::TriggerUncaughtException(isolate, exception, message, from_promise);
}",79,,1005,2,,void
161257,BLOCK,-1,,"{
    ReportFatalException(
        env, exception, message, EnhanceFatalException::kEnhance);
    Abort();
  }",61,,1010,2,,void
161287,BLOCK,-1,,"{
  registry->Register(SetPrepareStackTraceCallback);
  registry->Register(SetGetSourceMapErrorSource);
  registry->Register(SetSourceMapsEnabled);
  registry->Register(SetMaybeCacheGeneratedSourceMap);
  registry->Register(SetEnhanceStackForFatalException);
  registry->Register(NoSideEffectsToString);
  registry->Register(TriggerUncaughtException);
}",70,,1019,2,,void
161330,BLOCK,-1,,"{
  SetMethod(context,
            target,
            ""setPrepareStackTraceCallback"",
            SetPrepareStackTraceCallback);
  SetMethod(context,
            target,
            ""setGetSourceMapErrorSource"",
            SetGetSourceMapErrorSource);
  SetMethod(context, target, ""setSourceMapsEnabled"", SetSourceMapsEnabled);
  SetMethod(context,
            target,
            ""setMaybeCacheGeneratedSourceMap"",
            SetMaybeCacheGeneratedSourceMap);
  SetMethod(context,
            target,
            ""setEnhanceStackForFatalException"",
            SetEnhanceStackForFatalException);
  SetMethodNoSideEffect(
      context, target, ""noSideEffectsToString"", NoSideEffectsToString);
  SetMethod(
      context, target, ""triggerUncaughtException"", TriggerUncaughtException);

  Isolate* isolate = context->GetIsolate();
  Local<Object> exit_codes = Object::New(isolate);
  READONLY_PROPERTY(target, ""exitCodes"", exit_codes);

#define V(Name, Code)                                     ...",29,,1032,5,,void
161395,BLOCK,-1,,"{
  Local<Value> exception = try_catch.Exception();

  if (!exception->IsObject()) return;

  Local<Object> err_obj = exception.As<Object>();

  if (IsExceptionDecorated(env, err_obj)) return;

  AppendExceptionLine(env, exception, try_catch.Message(), CONTEXTIFY_ERROR);
  TryCatchScope try_catch_scope(env);  // Ignore exceptions below.
  MaybeLocal<Value> stack = err_obj->Get(env->context(), env->stack_string());
  MaybeLocal<Value> maybe_value =
      err_obj->GetPrivate(env->context(), env->arrow_message_private_symbol());

  Local<Value> arrow;
  if (!(maybe_value.ToLocal(&arrow) && arrow->IsString())) {
    return;
  }

  if (stack.IsEmpty() || !stack.ToLocalChecked()->IsString()) {
    return;
  }

  Local<String> decorated_stack = String::Concat(
      env->isolate(),
      String::Concat(env->isolate(),
                     arrow.As<String>(),
                     FIXED_ONE_BYTE_STRING(env->isolate(), ""\n"")),
      stack.ToLocalChecked().As<String>());
  USE(err_obj->Set(env...",65,,1068,3,,void
161412,BLOCK,-1,,<empty>,31,,1071,2,,void
161428,BLOCK,-1,,<empty>,43,,1075,2,,void
161495,BLOCK,-1,,"{
    return;
  }",60,,1084,2,,void
161511,BLOCK,-1,,"{
    return;
  }",63,,1088,2,,void
161590,BLOCK,-1,,"{
  CHECK(!error.IsEmpty());
  HandleScope scope(isolate);

  if (message.IsEmpty()) message = Exception::CreateMessage(isolate, error);

  CHECK(isolate->InContext());
  Local<Context> context = isolate->GetCurrentContext();
  Environment* env = Environment::GetCurrent(context);
  if (env == nullptr) {
    // This means that the exception happens before Environment is assigned
    // to the context e.g. when there is a SyntaxError in a per-context
    // script - which usually indicates that there is a bug because no JS
    // error is supposed to be thrown at this point.
    // Since we don't have access to Environment here, there is not
    // much we can do, so we just print whatever is useful and crash.
    PrintToStderrAndFlush(
        FormatCaughtException(isolate, context, error, message));
    Abort();
  }

  // Invoke process._fatalException() to give user a chance to handle it.
  // We have to grab it from the process object since this has been
  // monkey-patchable.
  L...",50,,1106,5,,void
161605,BLOCK,-1,,<empty>,26,,1110,2,,void
161641,BLOCK,-1,,"{
    // This means that the exception happens before Environment is assigned
    // to the context e.g. when there is a SyntaxError in a per-context
    // script - which usually indicates that there is a bug because no JS
    // error is supposed to be thrown at this point.
    // Since we don't have access to Environment here, there is not
    // much we can do, so we just print whatever is useful and crash.
    PrintToStderrAndFlush(
        FormatCaughtException(isolate, context, error, message));
    Abort();
  }",23,,1115,2,,void
161693,BLOCK,-1,,"{
    ReportFatalException(
        env, error, message, EnhanceFatalException::kDontEnhance);
    env->Exit(ExitCode::kInvalidFatalExceptionMonkeyPatching);
    return;
  }",48,,1138,2,,void
161719,BLOCK,-1,,"{
    // We do not expect the global uncaught exception itself to throw any more
    // exceptions. If it does, exit the current Node.js instance.
    errors::TryCatchScope try_catch(env,
                                    errors::TryCatchScope::CatchMode::kFatal);
    // Explicitly disable verbose exception reporting -
    // if process._fatalException() throws an error, we don't want it to
    // trigger the per-isolate message listener which will call this
    // function and recurse.
    try_catch.SetVerbose(false);
    Local<Value> argv[2] = { error,
                             Boolean::New(env->isolate(), from_promise) };

    maybe_handled = fatal_exception_function.As<Function>()->Call(
        env->context(), process_object, arraysize(argv), argv);
  }",32,,1146,2,,void
161773,BLOCK,-1,,"{
    return;
  }",41,,1168,2,,void
161781,BLOCK,-1,,"{
    return;
  }",28,,1178,2,,void
161808,BLOCK,-1,,"{
  // If the try_catch is verbose, the per-isolate message listener is going to
  // handle it (which is going to call into another overload of
  // TriggerUncaughtException()).
  if (try_catch.IsVerbose()) {
    return;
  }

  // If the user calls TryCatch::TerminateExecution() on this TryCatch
  // they must call CancelTerminateExecution() again before invoking
  // TriggerUncaughtException() because it will invoke
  // process._fatalException() in the JS land.
  CHECK(!try_catch.HasTerminated());
  CHECK(try_catch.HasCaught());
  HandleScope scope(isolate);
  TriggerUncaughtException(isolate,
                           try_catch.Exception(),
                           try_catch.Message(),
                           false /* from_promise */);
}",80,,1191,3,,void
161814,BLOCK,-1,,"{
    return;
  }",30,,1195,2,,void
161844,BLOCK,-1,,"{
  if (!HasCaught()) {
    return;
  }
  std::string str =
      FormatCaughtException(isolate_,
                            isolate_->GetCurrentContext(),
                            Exception(),
                            Message(),
                            print_source_line_ == kPrintSourceLine);
  PrintToStderrAndFlush(str);
}",37,,1212,1,,void
161848,BLOCK,-1,,"{
    return;
  }",21,,1213,2,,void
161881,BLOCK,-1,,<empty>,1,,1,1,,ANY
161886,BLOCK,-1,,<empty>,1,,1,1,,ANY
161901,BLOCK,-1,,<empty>,1,,1,1,,ANY
161904,BLOCK,-1,,"{
  if (!is_finalized_) {
    external_references_.push_back(reinterpret_cast<intptr_t>(nullptr));
    is_finalized_ = true;
  }

  return external_references_;
}",79,,9,1,,void
161908,BLOCK,-1,,"{
    external_references_.push_back(reinterpret_cast<intptr_t>(nullptr));
    is_finalized_ = true;
  }",23,,10,2,,void
161924,BLOCK,-1,,"{
  this->Register(BaseObject::LazilyInitializedJSTemplateConstructor);

#define V(modname) _register_external_reference_##modname(this);
  EXTERNAL_REFERENCE_BINDING_LIST(V)
#undef V
  // TODO(joyeecheung): collect more external references here.
}",56,,18,1,,void
161948,BLOCK,-1,,<empty>,1,,1,1,,ANY
161957,BLOCK,-1,,<empty>,1,,1,1,,ANY
161961,BLOCK,-1,,"{
      char msg[70];
      snprintf(msg, arraysize(msg),
              ""Closing file descriptor %d on garbage collection failed"",
              detail.fd);
      // This exception will end up being fatal for the process because
      // it is being thrown from within the SetImmediate handler and
      // there is no JS stack to bubble it to. In other words, tearing
      // down the process is the only reasonable thing we can do here.
      HandleScope handle_scope(env->isolate());
      env->ThrowUVException(detail.ret, ""close"", msg);
    }",52,,359,2,,void
161993,BLOCK,-1,,"{
    ProcessEmitWarning(env,
                       ""Closing file descriptor %d on garbage collection"",
                       detail.fd);
    if (env->filehandle_close_warning()) {
      env->set_filehandle_close_warning(false);
      USE(ProcessEmitDeprecationWarning(
          env,
          ""Closing a FileHandle object on garbage collection is deprecated. ""
          ""Please close FileHandle objects explicitly using ""
          ""FileHandle.prototype.close(). In the future, an error will be ""
          ""thrown if a file descriptor is closed during garbage collection."",
          ""DEP0137""));
    }
  }",50,,378,2,,void
162005,BLOCK,-1,,"{
      env->set_filehandle_close_warning(false);
      USE(ProcessEmitDeprecationWarning(
          env,
          ""Closing a FileHandle object on garbage collection is deprecated. ""
          ""Please close FileHandle objects explicitly using ""
          ""FileHandle.prototype.close(). In the future, an error will be ""
          ""thrown if a file descriptor is closed during garbage collection."",
          ""DEP0137""));
    }",42,,382,2,,void
162021,BLOCK,-1,,"{
    CloseReq* req_wrap = CloseReq::from_req(req);
    FS_ASYNC_TRACE_END1(
        req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
    BaseObjectPtr<CloseReq> close(req_wrap);
    CHECK(close);
    close->file_handle()->AfterClose();
    if (!close->env()->can_call_into_js()) return;
    Isolate* isolate = close->env()->isolate();
    if (req->result < 0) {
      HandleScope handle_scope(isolate);
      close->Reject(
          UVException(isolate, static_cast<int>(req->result), ""close""));
    } else {
      close->Resolve();
    }
  }",55,,480,2,,void
162046,BLOCK,1,,<empty>,,,,20,,void
162048,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
        req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",5,,482,1,,void
162066,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
        req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",5,,482,2,,void
162094,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
        req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",5,,482,2,,void
162168,BLOCK,-1,,<empty>,44,,487,2,,void
162186,BLOCK,-1,,"{
      HandleScope handle_scope(isolate);
      close->Reject(
          UVException(isolate, static_cast<int>(req->result), ""close""));
    }",26,,489,2,,void
162203,BLOCK,-1,,"{
      close->Resolve();
    }",12,,493,1,,void
162213,BLOCK,-1,,"{
    FileHandle* handle;
    {
      FileHandleReadWrap* req_wrap = FileHandleReadWrap::from_req(req);
      FS_ASYNC_TRACE_END1(
          req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
      handle = req_wrap->file_handle_;
      CHECK_EQ(handle->current_read_.get(), req_wrap);
    }

    // ReadStart() checks whether current_read_ is set to determine whether
    // a read is in progress. Moving it into a local variable makes sure that
    // the ReadStart() call below doesn't think we're still actively reading.
    BaseObjectPtr<FileHandleReadWrap> read_wrap =
        std::move(handle->current_read_);

    ssize_t result = req->result;
    uv_buf_t buffer = read_wrap->buffer_;

    uv_fs_req_cleanup(req);

    // Push the read wrap back to the freelist, or let it be destroyed
    // once we’re exiting the current scope.
    constexpr size_t kWantedFreelistFill = 100;
    auto& freelist = handle->binding_data_->file_handle_read_wrap_freelist;
    if (freelist.si...",61,,605,2,,void
162215,BLOCK,2,,"{
      FileHandleReadWrap* req_wrap = FileHandleReadWrap::from_req(req);
      FS_ASYNC_TRACE_END1(
          req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
      handle = req_wrap->file_handle_;
      CHECK_EQ(handle->current_read_.get(), req_wrap);
    }",5,,607,2,,void
162239,BLOCK,1,,<empty>,,,,18,,void
162241,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
          req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",7,,609,1,,void
162259,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
          req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",7,,609,2,,void
162287,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
          req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",7,,609,2,,void
162397,BLOCK,-1,,"{
      read_wrap->Reset();
      freelist.emplace_back(std::move(read_wrap));
    }",48,,630,2,,void
162415,BLOCK,-1,,"{
      // Read at most as many bytes as we originally planned to.
      if (handle->read_length_ >= 0 && handle->read_length_ < result)
        result = handle->read_length_;

      // If we read data and we have an expected length, decrease it by
      // how much we have read.
      if (handle->read_length_ >= 0)
        handle->read_length_ -= result;

      // If we have an offset, increase it by how much we have read.
      if (handle->read_offset_ >= 0)
        handle->read_offset_ += result;
    }",22,,635,2,,void
162428,BLOCK,-1,,<empty>,9,,638,2,,void
162440,BLOCK,-1,,<empty>,9,,643,2,,void
162452,BLOCK,-1,,<empty>,9,,647,2,,void
162462,BLOCK,-1,,<empty>,7,,653,2,,void
162476,BLOCK,-1,,<empty>,7,,659,2,,void
162486,BLOCK,-1,,"{
    FileHandleCloseWrap* wrap = static_cast<FileHandleCloseWrap*>(
        FileHandleCloseWrap::from_req(req));
    FS_ASYNC_TRACE_END1(
        req->fs_type, wrap, ""result"", static_cast<int>(req->result))
    FileHandle* handle = static_cast<FileHandle*>(wrap->stream());
    handle->AfterClose();

    int result = static_cast<int>(req->result);
    uv_fs_req_cleanup(req);
    wrap->Done(result);
  }",70,,685,2,,void
162512,BLOCK,1,,<empty>,,,,18,,void
162514,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
        req->fs_type, wrap, ""result"", static_cast<int>(req->result))",5,,688,1,,void
162532,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
        req->fs_type, wrap, ""result"", static_cast<int>(req->result))",5,,688,2,,void
162560,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
        req->fs_type, wrap, ""result"", static_cast<int>(req->result))",5,,688,2,,void
162643,BLOCK,-1,,"{
    uv_fs_t close_req;
    CHECK_EQ(0, uv_fs_close(loop, &close_req, fd, nullptr));
    uv_fs_req_cleanup(&close_req);
  }",48,,1047,1,,void
162663,BLOCK,-1,,"{
            FSReqBase* req_wrap = FSReqBase::from_req(req);
            int err = static_cast<int>(req->result);
            if (reinterpret_cast<intptr_t>(req->data) == UV_EEXIST &&
                  req_wrap->continuation_data()->paths().size() > 0) {
              if (err == 0 && S_ISDIR(req->statbuf.st_mode)) {
                Environment* env = req_wrap->env();
                uv_loop_t* loop = env->event_loop();
                std::string path = req->path;
                uv_fs_req_cleanup(req);
                MKDirpAsync(loop, req, path.c_str(),
                            req_wrap->continuation_data()->mode(), nullptr);
                return;
              }
              err = UV_ENOTDIR;
            }
            // verify that the path pointed to is actually a directory.
            if (err == 0 && !S_ISDIR(req->statbuf.st_mode)) err = UV_EEXIST;
            req_wrap->continuation_data()->Done(err);
          }",66,,1722,2,,void
162701,BLOCK,-1,,"{
              if (err == 0 && S_ISDIR(req->statbuf.st_mode)) {
                Environment* env = req_wrap->env();
                uv_loop_t* loop = env->event_loop();
                std::string path = req->path;
                uv_fs_req_cleanup(req);
                MKDirpAsync(loop, req, path.c_str(),
                            req_wrap->continuation_data()->mode(), nullptr);
                return;
              }
              err = UV_ENOTDIR;
            }",70,,1726,2,,void
162713,BLOCK,1,,<empty>,,,,2,,void
162723,BLOCK,-1,,"{
                Environment* env = req_wrap->env();
                uv_loop_t* loop = env->event_loop();
                std::string path = req->path;
                uv_fs_req_cleanup(req);
                MKDirpAsync(loop, req, path.c_str(),
                            req_wrap->continuation_data()->mode(), nullptr);
                return;
              }",62,,1727,2,,void
162777,BLOCK,1,,<empty>,,,,2,,void
162787,BLOCK,-1,,<empty>,61,,1739,2,,void
162805,BLOCK,-1,,"{
    FSReqBase* req_wrap = FSReqBase::from_req(req);
    Environment* env = req_wrap->env();
    uv_loop_t* loop = env->event_loop();
    std::string path = req->path;
    int err = static_cast<int>(req->result);

    while (true) {
      switch (err) {
        // Note: uv_fs_req_cleanup in terminal paths will be called by
        // FSReqAfterScope::~FSReqAfterScope()
        case 0: {
          if (req_wrap->continuation_data()->paths().size() == 0) {
            req_wrap->continuation_data()->MaybeSetFirstPath(path);
            req_wrap->continuation_data()->Done(0);
          } else {
            req_wrap->continuation_data()->MaybeSetFirstPath(path);
            uv_fs_req_cleanup(req);
            MKDirpAsync(loop, req, path.c_str(),
                        req_wrap->continuation_data()->mode(), nullptr);
          }
          break;
        }
        case UV_EACCES:
        case UV_ENOTDIR:
        case UV_EPERM: {
          req_wrap->continuation_data()->Done(err);
        ...",59,,1673,2,,void
162844,BLOCK,-1,,"{
      switch (err) {
        // Note: uv_fs_req_cleanup in terminal paths will be called by
        // FSReqAfterScope::~FSReqAfterScope()
        case 0: {
          if (req_wrap->continuation_data()->paths().size() == 0) {
            req_wrap->continuation_data()->MaybeSetFirstPath(path);
            req_wrap->continuation_data()->Done(0);
          } else {
            req_wrap->continuation_data()->MaybeSetFirstPath(path);
            uv_fs_req_cleanup(req);
            MKDirpAsync(loop, req, path.c_str(),
                        req_wrap->continuation_data()->mode(), nullptr);
          }
          break;
        }
        case UV_EACCES:
        case UV_ENOTDIR:
        case UV_EPERM: {
          req_wrap->continuation_data()->Done(err);
          break;
        }
        case UV_ENOENT: {
          std::string dirname = path.substr(0,
                                            path.find_last_of(kPathSeparator));
          if (dirname != path) {
            req_wrap->conti...",18,,1680,2,,void
162847,BLOCK,-1,,"{
        // Note: uv_fs_req_cleanup in terminal paths will be called by
        // FSReqAfterScope::~FSReqAfterScope()
        case 0: {
          if (req_wrap->continuation_data()->paths().size() == 0) {
            req_wrap->continuation_data()->MaybeSetFirstPath(path);
            req_wrap->continuation_data()->Done(0);
          } else {
            req_wrap->continuation_data()->MaybeSetFirstPath(path);
            uv_fs_req_cleanup(req);
            MKDirpAsync(loop, req, path.c_str(),
                        req_wrap->continuation_data()->mode(), nullptr);
          }
          break;
        }
        case UV_EACCES:
        case UV_ENOTDIR:
        case UV_EPERM: {
          req_wrap->continuation_data()->Done(err);
          break;
        }
        case UV_ENOENT: {
          std::string dirname = path.substr(0,
                                            path.find_last_of(kPathSeparator));
          if (dirname != path) {
            req_wrap->continuation_data()->PushP...",20,,1681,2,,void
162850,BLOCK,3,,"{
          if (req_wrap->continuation_data()->paths().size() == 0) {
            req_wrap->continuation_data()->MaybeSetFirstPath(path);
            req_wrap->continuation_data()->Done(0);
          } else {
            req_wrap->continuation_data()->MaybeSetFirstPath(path);
            uv_fs_req_cleanup(req);
            MKDirpAsync(loop, req, path.c_str(),
                        req_wrap->continuation_data()->mode(), nullptr);
          }
          break;
        }",17,,1684,3,,void
162864,BLOCK,-1,,"{
            req_wrap->continuation_data()->MaybeSetFirstPath(path);
            req_wrap->continuation_data()->Done(0);
          }",67,,1685,2,,void
162882,BLOCK,-1,,"{
            req_wrap->continuation_data()->MaybeSetFirstPath(path);
            uv_fs_req_cleanup(req);
            MKDirpAsync(loop, req, path.c_str(),
                        req_wrap->continuation_data()->mode(), nullptr);
          }",18,,1688,1,,void
162915,BLOCK,10,,"{
          req_wrap->continuation_data()->Done(err);
          break;
        }",24,,1698,10,,void
162927,BLOCK,13,,"{
          std::string dirname = path.substr(0,
                                            path.find_last_of(kPathSeparator));
          if (dirname != path) {
            req_wrap->continuation_data()->PushPath(path);
            req_wrap->continuation_data()->PushPath(std::move(dirname));
          } else if (req_wrap->continuation_data()->paths().size() == 0) {
            err = UV_EEXIST;
            continue;
          }
          uv_fs_req_cleanup(req);
          MKDirpAsync(loop, req, path.c_str(),
                      req_wrap->continuation_data()->mode(), nullptr);
          break;
        }",25,,1702,13,,void
162945,BLOCK,-1,,"{
            req_wrap->continuation_data()->PushPath(path);
            req_wrap->continuation_data()->PushPath(std::move(dirname));
          }",32,,1705,2,,void
162967,BLOCK,-1,,<empty>,18,,1708,1,,void
162981,BLOCK,-1,,"{
            err = UV_EEXIST;
            continue;
          }",74,,1708,2,,void
163033,BLOCK,-1,,<empty>,24,,1742,2,,void
163094,BLOCK,-1,,<empty>,1,,1,1,,ANY
163103,BLOCK,-1,,"{
  // Remove everything leading up to and including the final path separator.
  std::string::size_type pos = str.find_last_of(kPathSeparator);

  // Starting index for the resulting string
  std::size_t start_pos = 0;
  // String size to return
  std::size_t str_size = str.size();
  if (pos != std::string::npos) {
    start_pos = pos + 1;
    str_size -= start_pos;
  }

  // Strip away the extension, if any.
  if (str_size >= extension.size() &&
      str.compare(str.size() - extension.size(),
        extension.size(), extension) == 0) {
    str_size -= extension.size();
  }

  return str.substr(start_pos, str_size);
}",76,,90,3,,void
163131,BLOCK,-1,,"{
    start_pos = pos + 1;
    str_size -= start_pos;
  }",33,,98,2,,void
163168,BLOCK,-1,,"{
    str_size -= extension.size();
  }",44,,106,2,,void
163186,BLOCK,-1,,"{
  return IsSafeJsInt(value) ? value.As<Integer>()->Value() : -1;
}",46,,113,2,,void
163204,BLOCK,-1,,"{
  switch (req_type) {
#define FS_TYPE_TO_NAME(type, name)                                            \
  case UV_FS_##type:                                                           \
    return name;
    FS_TYPE_TO_NAME(OPEN, ""open"")
    FS_TYPE_TO_NAME(CLOSE, ""close"")
    FS_TYPE_TO_NAME(READ, ""read"")
    FS_TYPE_TO_NAME(WRITE, ""write"")
    FS_TYPE_TO_NAME(SENDFILE, ""sendfile"")
    FS_TYPE_TO_NAME(STAT, ""stat"")
    FS_TYPE_TO_NAME(LSTAT, ""lstat"")
    FS_TYPE_TO_NAME(FSTAT, ""fstat"")
    FS_TYPE_TO_NAME(FTRUNCATE, ""ftruncate"")
    FS_TYPE_TO_NAME(UTIME, ""utime"")
    FS_TYPE_TO_NAME(FUTIME, ""futime"")
    FS_TYPE_TO_NAME(ACCESS, ""access"")
    FS_TYPE_TO_NAME(CHMOD, ""chmod"")
    FS_TYPE_TO_NAME(FCHMOD, ""fchmod"")
    FS_TYPE_TO_NAME(FSYNC, ""fsync"")
    FS_TYPE_TO_NAME(FDATASYNC, ""fdatasync"")
    FS_TYPE_TO_NAME(UNLINK, ""unlink"")
    FS_TYPE_TO_NAME(RMDIR, ""rmdir"")
    FS_TYPE_TO_NAME(MKDIR, ""mkdir"")
    FS_TYPE_TO_NAME(MKDTEMP, ""mkdtemp"")
    FS_TYPE_TO_NAME(RENAME, ""rename"")
    FS_T...",66,,117,2,,void
163207,BLOCK,-1,,"{
#define FS_TYPE_TO_NAME(type, name)                                            \
  case UV_FS_##type:                                                           \
    return name;
    FS_TYPE_TO_NAME(OPEN, ""open"")
    FS_TYPE_TO_NAME(CLOSE, ""close"")
    FS_TYPE_TO_NAME(READ, ""read"")
    FS_TYPE_TO_NAME(WRITE, ""write"")
    FS_TYPE_TO_NAME(SENDFILE, ""sendfile"")
    FS_TYPE_TO_NAME(STAT, ""stat"")
    FS_TYPE_TO_NAME(LSTAT, ""lstat"")
    FS_TYPE_TO_NAME(FSTAT, ""fstat"")
    FS_TYPE_TO_NAME(FTRUNCATE, ""ftruncate"")
    FS_TYPE_TO_NAME(UTIME, ""utime"")
    FS_TYPE_TO_NAME(FUTIME, ""futime"")
    FS_TYPE_TO_NAME(ACCESS, ""access"")
    FS_TYPE_TO_NAME(CHMOD, ""chmod"")
    FS_TYPE_TO_NAME(FCHMOD, ""fchmod"")
    FS_TYPE_TO_NAME(FSYNC, ""fsync"")
    FS_TYPE_TO_NAME(FDATASYNC, ""fdatasync"")
    FS_TYPE_TO_NAME(UNLINK, ""unlink"")
    FS_TYPE_TO_NAME(RMDIR, ""rmdir"")
    FS_TYPE_TO_NAME(MKDIR, ""mkdir"")
    FS_TYPE_TO_NAME(MKDTEMP, ""mkdtemp"")
    FS_TYPE_TO_NAME(RENAME, ""rename"")
    FS_TYPE_TO_NAME(SCANDIR, ""...",21,,118,2,,void
163209,BLOCK,1,,<empty>,,,,1,,void
163215,BLOCK,1,,<empty>,,,,1,,void
163221,BLOCK,1,,<empty>,,,,1,,void
163227,BLOCK,1,,<empty>,,,,1,,void
163233,BLOCK,1,,<empty>,,,,1,,void
163239,BLOCK,1,,<empty>,,,,1,,void
163245,BLOCK,1,,<empty>,,,,1,,void
163251,BLOCK,1,,<empty>,,,,1,,void
163257,BLOCK,1,,<empty>,,,,1,,void
163263,BLOCK,1,,<empty>,,,,1,,void
163269,BLOCK,1,,<empty>,,,,1,,void
163275,BLOCK,1,,<empty>,,,,1,,void
163281,BLOCK,1,,<empty>,,,,1,,void
163287,BLOCK,1,,<empty>,,,,1,,void
163293,BLOCK,1,,<empty>,,,,1,,void
163299,BLOCK,1,,<empty>,,,,1,,void
163305,BLOCK,1,,<empty>,,,,1,,void
163311,BLOCK,1,,<empty>,,,,1,,void
163317,BLOCK,1,,<empty>,,,,1,,void
163323,BLOCK,1,,<empty>,,,,1,,void
163329,BLOCK,1,,<empty>,,,,1,,void
163335,BLOCK,1,,<empty>,,,,1,,void
163341,BLOCK,1,,<empty>,,,,1,,void
163347,BLOCK,1,,<empty>,,,,1,,void
163353,BLOCK,1,,<empty>,,,,1,,void
163359,BLOCK,1,,<empty>,,,,1,,void
163365,BLOCK,1,,<empty>,,,,1,,void
163371,BLOCK,1,,<empty>,,,,1,,void
163377,BLOCK,1,,<empty>,,,,1,,void
163383,BLOCK,1,,<empty>,,,,1,,void
163389,BLOCK,1,,<empty>,,,,1,,void
163395,BLOCK,1,,<empty>,,,,1,,void
163401,BLOCK,1,,<empty>,,,,1,,void
163413,BLOCK,-1,,<empty>,,,,2,,<empty>
163418,BLOCK,-1,,"{
  tracker->TrackField(""paths"", paths_);
}",67,,222,2,,void
163428,BLOCK,-1,,<empty>,,,,1,,<empty>
163432,BLOCK,-1,,<empty>,,,,1,,<empty>
163437,BLOCK,-1,,"{
  tracker->TrackField(""continuation_data"", continuation_data_);
}",58,,230,2,,void
163450,BLOCK,-1,,"{
  MakeWeak();
  StreamBase::AttachToObject(GetObject());
}",35,,242,4,,void
163461,BLOCK,-1,,"{
  Environment* env = binding_data->env();
  if (obj.IsEmpty() && !env->fd_constructor_template()
                            ->NewInstance(env->context())
                            .ToLocal(&obj)) {
    return nullptr;
  }
  auto handle = new FileHandle(binding_data, obj, fd);
  if (maybeOffset.has_value()) handle->read_offset_ = maybeOffset.value();
  if (maybeLength.has_value()) handle->read_length_ = maybeLength.value();
  return handle;
}",65,,251,6,,void
163492,BLOCK,-1,,"{
    return nullptr;
  }",45,,255,2,,void
163508,BLOCK,-1,,<empty>,32,,259,2,,void
163522,BLOCK,-1,,<empty>,32,,260,2,,void
163537,BLOCK,-1,,"{
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = binding_data->env();
  CHECK(args.IsConstructCall());
  CHECK(args[0]->IsInt32());

  std::optional<int64_t> maybeOffset = std::nullopt;
  std::optional<int64_t> maybeLength = std::nullopt;
  if (args[1]->IsNumber())
    maybeOffset = args[1]->IntegerValue(env->context()).FromJust();
  if (args[2]->IsNumber())
    maybeLength = args[2]->IntegerValue(env->context()).FromJust();

  FileHandle::New(binding_data,
                  args[0].As<Int32>()->Value(),
                  args.This(),
                  maybeOffset,
                  maybeLength);
}",63,,264,2,,void
163596,BLOCK,-1,,<empty>,5,,273,2,,void
163619,BLOCK,-1,,<empty>,5,,275,2,,void
163658,BLOCK,-1,,"{
  CHECK(!closing_);  // We should not be deleting while explicitly closing!
  Close();           // Close synchronously and emit warning
  CHECK(closed_);    // We have to be closed at the point
}",27,,284,1,,void
163671,BLOCK,-1,,"{
  return UV_ENOSYS;  // Not implemented (yet).
}",51,,293,5,,void
163678,BLOCK,-1,,"{
  tracker->TrackField(""current_read"", current_read_);
}",59,,297,2,,void
163688,BLOCK,-1,,"{
  return reading_ || closing_ || closed_ ?
      TransferMode::kUntransferable : TransferMode::kTransferable;
}",62,,301,1,,void
163705,BLOCK,-1,,"{
  CHECK_NE(GetTransferMode(), TransferMode::kUntransferable);
  auto ret = std::make_unique<TransferData>(fd_);
  closed_ = true;
  return ret;
}",74,,306,1,,void
163730,BLOCK,-1,,<empty>,58,,313,2,,void
163734,BLOCK,-1,,"{
  if (fd_ > 0) {
    uv_fs_t close_req;
    CHECK_NE(fd_, -1);
    FS_SYNC_TRACE_BEGIN(close);
    CHECK_EQ(0, uv_fs_close(nullptr, &close_req, fd_, nullptr));
    FS_SYNC_TRACE_END(close);
    uv_fs_req_cleanup(&close_req);
  }
}",43,,315,1,,void
163739,BLOCK,-1,,"{
    uv_fs_t close_req;
    CHECK_NE(fd_, -1);
    FS_SYNC_TRACE_BEGIN(close);
    CHECK_EQ(0, uv_fs_close(nullptr, &close_req, fd_, nullptr));
    FS_SYNC_TRACE_END(close);
    uv_fs_req_cleanup(&close_req);
  }",16,,316,2,,void
163748,BLOCK,1,,<empty>,,,,9,,void
163764,BLOCK,-1,,<empty>,5,,319,2,,void
163766,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(close),5,,319,1,,void
163784,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(close),5,,319,2,,void
163812,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(close),5,,319,2,,void
163852,BLOCK,1,,<empty>,,,,9,,void
163868,BLOCK,-1,,<empty>,5,,321,2,,void
163870,BLOCK,-1,,FS_SYNC_TRACE_END(close),5,,321,1,,void
163888,BLOCK,-1,,FS_SYNC_TRACE_END(close),5,,321,2,,void
163916,BLOCK,-1,,FS_SYNC_TRACE_END(close),5,,321,2,,void
163954,BLOCK,-1,,"{
  BindingData* bd = Realm::GetBindingData<BindingData>(context);
  if (bd == nullptr) return {};

  int fd = fd_;
  fd_ = -1;
  return BaseObjectPtr<BaseObject> { FileHandle::New(bd, fd) };
}",49,,329,4,,void
163969,BLOCK,-1,,<empty>,22,,331,2,,void
163991,BLOCK,-1,,"{
  if (closed_ || closing_) return;
  uv_fs_t req;
  CHECK_NE(fd_, -1);
  FS_SYNC_TRACE_BEGIN(close);
  int ret = uv_fs_close(env()->event_loop(), &req, fd_, nullptr);
  FS_SYNC_TRACE_END(close);
  uv_fs_req_cleanup(&req);

  struct err_detail { int ret; int fd; };

  err_detail detail { ret, fd_ };

  AfterClose();

  if (ret < 0) {
    // Do not unref this
    env()->SetImmediate([detail](Environment* env) {
      char msg[70];
      snprintf(msg, arraysize(msg),
              ""Closing file descriptor %d on garbage collection failed"",
              detail.fd);
      // This exception will end up being fatal for the process because
      // it is being thrown from within the SetImmediate handler and
      // there is no JS stack to bubble it to. In other words, tearing
      // down the process is the only reasonable thing we can do here.
      HandleScope handle_scope(env->isolate());
      env->ThrowUVException(detail.ret, ""close"", msg);
    });
    return;
  }

  // If the clos...",33,,342,1,,void
163996,BLOCK,-1,,<empty>,28,,343,2,,void
164006,BLOCK,1,,<empty>,,,,9,,void
164022,BLOCK,-1,,<empty>,3,,346,2,,void
164024,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(close),3,,346,1,,void
164042,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(close),3,,346,2,,void
164070,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(close),3,,346,2,,void
164114,BLOCK,1,,<empty>,,,,9,,void
164130,BLOCK,-1,,<empty>,3,,348,2,,void
164132,BLOCK,-1,,FS_SYNC_TRACE_END(close),3,,348,1,,void
164150,BLOCK,-1,,FS_SYNC_TRACE_END(close),3,,348,2,,void
164178,BLOCK,-1,,FS_SYNC_TRACE_END(close),3,,348,2,,void
164220,BLOCK,-1,,"{
    // Do not unref this
    env()->SetImmediate([detail](Environment* env) {
      char msg[70];
      snprintf(msg, arraysize(msg),
              ""Closing file descriptor %d on garbage collection failed"",
              detail.fd);
      // This exception will end up being fatal for the process because
      // it is being thrown from within the SetImmediate handler and
      // there is no JS stack to bubble it to. In other words, tearing
      // down the process is the only reasonable thing we can do here.
      HandleScope handle_scope(env->isolate());
      env->ThrowUVException(detail.ret, ""close"", msg);
    });
    return;
  }",16,,357,2,,void
164238,BLOCK,-1,,"{
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Context::Scope context_scope(env()->context());
  InternalCallbackScope callback_scope(this);
  Local<Promise> promise = promise_.Get(isolate);
  Local<Promise::Resolver> resolver = promise.As<Promise::Resolver>();
  resolver->Resolve(env()->context(), Undefined(isolate)).Check();
}",38,,395,1,,void
164298,BLOCK,-1,,"{
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Context::Scope context_scope(env()->context());
  InternalCallbackScope callback_scope(this);
  Local<Promise> promise = promise_.Get(isolate);
  Local<Promise::Resolver> resolver = promise.As<Promise::Resolver>();
  resolver->Reject(env()->context(), reason).Check();
}",56,,405,2,,void
164356,BLOCK,-1,,"{
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Value> val = ref_.Get(isolate);
  Local<Object> obj = val.As<Object>();
  return Unwrap<FileHandle>(obj);
}",49,,415,1,,void
164401,BLOCK,-1,,"{
  promise_.Reset(env->isolate(), promise);
  ref_.Reset(env->isolate(), ref);
}",63,,427,5,,void
164423,BLOCK,-1,,"{
  uv_fs_req_cleanup(req());
  promise_.Reset();
  ref_.Reset();
}",35,,432,1,,void
164437,BLOCK,-1,,"{
  tracker->TrackField(""promise"", promise_);
  tracker->TrackField(""ref"", ref_);
}",69,,438,2,,void
164453,BLOCK,-1,,"{
  Isolate* isolate = env()->isolate();
  EscapableHandleScope scope(isolate);
  Local<Context> context = env()->context();

  Local<Value> close_resolver =
      object()->GetInternalField(FileHandle::kClosingPromiseSlot);
  if (!close_resolver.IsEmpty() && !close_resolver->IsUndefined()) {
    CHECK(close_resolver->IsPromise());
    return close_resolver.As<Promise>();
  }

  CHECK(!closed_);
  CHECK(!closing_);
  CHECK(!reading_);

  auto maybe_resolver = Promise::Resolver::New(context);
  CHECK(!maybe_resolver.IsEmpty());
  Local<Promise::Resolver> resolver = maybe_resolver.ToLocalChecked();
  Local<Promise> promise = resolver.As<Promise>();

  Local<Object> close_req_obj;
  if (!env()->fdclose_constructor_template()
          ->NewInstance(env()->context()).ToLocal(&close_req_obj)) {
    return MaybeLocal<Promise>();
  }
  closing_ = true;
  object()->SetInternalField(FileHandle::kClosingPromiseSlot, promise);

  CloseReq* req = new CloseReq(env(), close_req_obj, promise, obje...",48,,450,1,,void
164499,BLOCK,-1,,"{
    CHECK(close_resolver->IsPromise());
    return close_resolver.As<Promise>();
  }",68,,457,2,,void
164580,BLOCK,-1,,"{
    return MaybeLocal<Promise>();
  }",68,,473,2,,void
164619,BLOCK,1,,<empty>,,,,16,,void
164621,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, req)",3,,498,1,,void
164639,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, req)",3,,498,2,,void
164667,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, req)",3,,498,2,,void
164724,BLOCK,-1,,"{
    req->Reject(UVException(isolate, ret, ""close""));
    delete req;
  }",16,,500,2,,void
164745,BLOCK,-1,,"{
  FileHandle* fd;
  ASSIGN_OR_RETURN_UNWRAP(&fd, args.Holder());
  Local<Promise> ret;
  if (!fd->ClosePromise().ToLocal(&ret)) return;
  args.GetReturnValue().Set(ret);
}",65,,508,2,,void
164770,BLOCK,-1,,<empty>,42,,512,2,,void
164784,BLOCK,-1,,"{
  FileHandle* fd;
  ASSIGN_OR_RETURN_UNWRAP(&fd, args.Holder());
  fd->Release();
}",69,,517,2,,void
164800,BLOCK,-1,,"{
  int fd = GetFD();
  // Just pretend that Close was called and we're all done.
  AfterClose();
  return fd;
}",27,,523,1,,void
164811,BLOCK,-1,,"{
  closing_ = false;
  closed_ = true;
  fd_ = -1;
  if (reading_ && !persistent().IsEmpty())
    EmitRead(UV_EOF);
}",31,,530,1,,void
164830,BLOCK,-1,,<empty>,5,,535,2,,void
164836,BLOCK,-1,,"{
  tracker->TrackField(""buffer"", buffer_);
  tracker->TrackField(""file_handle"", this->file_handle_);
}",67,,538,2,,void
164856,BLOCK,-1,,<empty>,26,,545,3,,void
164860,BLOCK,-1,,"{
  if (!IsAlive() || IsClosing())
    return UV_EOF;

  reading_ = true;

  if (current_read_)
    return 0;

  BaseObjectPtr<FileHandleReadWrap> read_wrap;

  if (read_length_ == 0) {
    EmitRead(UV_EOF);
    return 0;
  }

  {
    // Create a new FileHandleReadWrap or re-use one.
    // Either way, we need these two scopes for AsyncReset() or otherwise
    // for creating the new instance.
    HandleScope handle_scope(env()->isolate());
    AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(this);

    auto& freelist = binding_data_->file_handle_read_wrap_freelist;
    if (freelist.size() > 0) {
      read_wrap = std::move(freelist.back());
      freelist.pop_back();
      // Use a fresh async resource.
      // Lifetime is ensured via AsyncWrap::resource_.
      Local<Object> resource = Object::New(env()->isolate());
      USE(resource->Set(
          env()->context(), env()->handle_string(), read_wrap->object()));
      read_wrap->AsyncReset(resource);
      read_wrap->file_...",29,,547,1,,void
164866,BLOCK,-1,,<empty>,5,,549,2,,void
164874,BLOCK,-1,,<empty>,5,,554,2,,void
164886,BLOCK,-1,,"{
    EmitRead(UV_EOF);
    return 0;
  }",26,,558,2,,void
164890,BLOCK,6,,"{
    // Create a new FileHandleReadWrap or re-use one.
    // Either way, we need these two scopes for AsyncReset() or otherwise
    // for creating the new instance.
    HandleScope handle_scope(env()->isolate());
    AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(this);

    auto& freelist = binding_data_->file_handle_read_wrap_freelist;
    if (freelist.size() > 0) {
      read_wrap = std::move(freelist.back());
      freelist.pop_back();
      // Use a fresh async resource.
      // Lifetime is ensured via AsyncWrap::resource_.
      Local<Object> resource = Object::New(env()->isolate());
      USE(resource->Set(
          env()->context(), env()->handle_string(), read_wrap->object()));
      read_wrap->AsyncReset(resource);
      read_wrap->file_handle_ = this;
    } else {
      Local<Object> wrap_obj;
      if (!env()
               ->filehandlereadwrap_template()
               ->NewInstance(env()->context())
               .ToLocal(&wrap_obj)) {
        return UV_EBU...",3,,563,6,,void
164913,BLOCK,-1,,"{
      read_wrap = std::move(freelist.back());
      freelist.pop_back();
      // Use a fresh async resource.
      // Lifetime is ensured via AsyncWrap::resource_.
      Local<Object> resource = Object::New(env()->isolate());
      USE(resource->Set(
          env()->context(), env()->handle_string(), read_wrap->object()));
      read_wrap->AsyncReset(resource);
      read_wrap->file_handle_ = this;
    }",30,,571,2,,void
164970,BLOCK,-1,,"{
      Local<Object> wrap_obj;
      if (!env()
               ->filehandlereadwrap_template()
               ->NewInstance(env()->context())
               .ToLocal(&wrap_obj)) {
        return UV_EBUSY;
      }
      read_wrap = MakeDetachedBaseObject<FileHandleReadWrap>(this, wrap_obj);
    }",12,,581,1,,void
164994,BLOCK,-1,,"{
        return UV_EBUSY;
      }",37,,586,2,,void
165019,BLOCK,-1,,<empty>,5,,594,2,,void
165046,BLOCK,1,,<empty>,,,,15,,void
165048,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, current_read_.get())",3,,599,1,,void
165066,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, current_read_.get())",3,,599,2,,void
165094,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, current_read_.get())",3,,599,2,,void
165160,BLOCK,-1,,"{
  reading_ = false;
  return 0;
}",28,,665,1,,void
165171,BLOCK,-1,,"{
  return new FileHandleCloseWrap(this, object);
}",68,,672,2,,void
165181,BLOCK,-1,,"{
  if (closing_ || closed_) {
    req_wrap->Done(0);
    return 1;
  }
  FileHandleCloseWrap* wrap = static_cast<FileHandleCloseWrap*>(req_wrap);
  closing_ = true;
  CHECK_NE(fd_, -1);
  FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, wrap)
  wrap->Dispatch(uv_fs_close, fd_, uv_fs_callback_t{[](uv_fs_t* req) {
    FileHandleCloseWrap* wrap = static_cast<FileHandleCloseWrap*>(
        FileHandleCloseWrap::from_req(req));
    FS_ASYNC_TRACE_END1(
        req->fs_type, wrap, ""result"", static_cast<int>(req->result))
    FileHandle* handle = static_cast<FileHandle*>(wrap->stream());
    handle->AfterClose();

    int result = static_cast<int>(req->result);
    uv_fs_req_cleanup(req);
    wrap->Done(result);
  }});

  return 0;
}",52,,676,2,,void
165186,BLOCK,-1,,"{
    req_wrap->Done(0);
    return 1;
  }",28,,677,2,,void
165214,BLOCK,1,,<empty>,,,,16,,void
165216,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, wrap)",3,,684,1,,void
165234,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, wrap)",3,,684,2,,void
165262,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, wrap)",3,,684,2,,void
165320,BLOCK,-1,,"{
  MakeCallback(env()->oncomplete_string(), 1, &reject);
}",49,,702,2,,void
165333,BLOCK,-1,,"{
  Resolve(FillGlobalStatsArray(binding_data(), use_bigint(), stat));
}",56,,706,2,,void
165343,BLOCK,-1,,"{
  Resolve(FillGlobalStatFsArray(binding_data(), use_bigint(), stat));
}",60,,710,2,,void
165353,BLOCK,-1,,"{
  Local<Value> argv[2] {
    Null(env()->isolate()),
    value
  };
  MakeCallback(env()->oncomplete_string(),
               value->IsUndefined() ? 1 : arraysize(argv),
               argv);
}",49,,714,2,,void
165382,BLOCK,-1,,"{
  args.GetReturnValue().SetUndefined();
}",77,,724,2,,void
165394,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  new FSReqCallback(binding_data, args.This(), args[0]->IsTrue());
}",64,,728,2,,void
165428,BLOCK,-1,,"{
  CHECK_EQ(wrap_->req(), req);
}",46,,738,3,,void
165438,BLOCK,-1,,"{
  Clear();
}",37,,742,1,,void
165443,BLOCK,-1,,"{
  if (!wrap_) return;

  uv_fs_req_cleanup(wrap_->req());
  wrap_->Detach();
  wrap_.reset();
}",31,,746,1,,void
165447,BLOCK,-1,,<empty>,15,,747,2,,void
165466,BLOCK,-1,,"{
  BaseObjectPtr<FSReqBase> wrap { wrap_ };
  Local<Value> exception = UVException(wrap_->env()->isolate(),
                                       static_cast<int>(req->result),
                                       wrap_->syscall(),
                                       nullptr,
                                       req->path,
                                       wrap_->data());
  Clear();
  wrap->Reject(exception);
}",44,,763,2,,void
165514,BLOCK,-1,,"{
  if (!wrap_->env()->can_call_into_js()) {
    return false;
  }

  if (req_->result < 0) {
    Reject(req_);
    return false;
  }
  return true;
}",33,,775,1,,void
165524,BLOCK,-1,,"{
    return false;
  }",42,,776,2,,void
165533,BLOCK,-1,,"{
    Reject(req_);
    return false;
  }",25,,780,2,,void
165543,BLOCK,-1,,"{
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (after.Proceed())
    req_wrap->Resolve(Undefined(req_wrap->env()->isolate()));
}",32,,787,2,,void
165571,BLOCK,1,,<empty>,,,,18,,void
165573,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,790,1,,void
165591,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,790,2,,void
165619,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,790,2,,void
165675,BLOCK,-1,,<empty>,5,,793,2,,void
165692,BLOCK,-1,,"{
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (after.Proceed()) {
    req_wrap->ResolveStat(&req->statbuf);
  }
}",30,,796,2,,void
165720,BLOCK,1,,<empty>,,,,18,,void
165722,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,799,1,,void
165740,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,799,2,,void
165768,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,799,2,,void
165824,BLOCK,-1,,"{
    req_wrap->ResolveStat(&req->statbuf);
  }",24,,801,2,,void
165837,BLOCK,-1,,"{
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (after.Proceed()) {
    req_wrap->ResolveStatFs(static_cast<uv_statfs_t*>(req->ptr));
  }
}",32,,806,2,,void
165865,BLOCK,1,,<empty>,,,,18,,void
165867,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,809,1,,void
165885,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,809,2,,void
165913,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,809,2,,void
165969,BLOCK,-1,,"{
    req_wrap->ResolveStatFs(static_cast<uv_statfs_t*>(req->ptr));
  }",24,,811,2,,void
165983,BLOCK,-1,,"{
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  int result = static_cast<int>(req->result);
  if (result >= 0 && req_wrap->is_plain_open())
    req_wrap->env()->AddUnmanagedFd(result);

  if (after.Proceed())
    req_wrap->Resolve(Integer::New(req_wrap->env()->isolate(), result));
}",33,,816,2,,void
166011,BLOCK,1,,<empty>,,,,18,,void
166013,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,819,1,,void
166031,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,819,2,,void
166059,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,819,2,,void
166127,BLOCK,-1,,<empty>,5,,823,2,,void
166141,BLOCK,-1,,<empty>,5,,826,2,,void
166162,BLOCK,-1,,"{
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (after.Proceed()) {
    FileHandle* fd = FileHandle::New(req_wrap->binding_data(),
                                     static_cast<int>(req->result));
    if (fd == nullptr) return;
    req_wrap->Resolve(fd->object());
  }
}",40,,829,2,,void
166190,BLOCK,1,,<empty>,,,,18,,void
166192,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,832,1,,void
166210,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,832,2,,void
166238,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,832,2,,void
166294,BLOCK,-1,,"{
    FileHandle* fd = FileHandle::New(req_wrap->binding_data(),
                                     static_cast<int>(req->result));
    if (fd == nullptr) return;
    req_wrap->Resolve(fd->object());
  }",24,,834,2,,void
166315,BLOCK,-1,,<empty>,24,,837,2,,void
166329,BLOCK,-1,,"{
#ifdef _WIN32
  if (path->compare(0, 8, ""\\\\?\\UNC\\"", 8) == 0) {
    *path = path->substr(8);
    path->insert(0, ""\\\\"");
  } else if (path->compare(0, 4, ""\\\\?\\"", 4) == 0) {
    *path = path->substr(4);
  }
#endif
}",44,,844,2,,void
166334,BLOCK,-1,,"{
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (after.Proceed()) {
    std::string first_path(req_wrap->continuation_data()->first_path());
    if (first_path.empty())
      return req_wrap->Resolve(Undefined(req_wrap->env()->isolate()));
    FromNamespacedPath(&first_path);
    Local<Value> path;
    Local<Value> error;
    if (!StringBytes::Encode(req_wrap->env()->isolate(), first_path.c_str(),
                             req_wrap->encoding(),
                             &error).ToLocal(&path)) {
      return req_wrap->Reject(error);
    }
    return req_wrap->Resolve(path);
  }
}",32,,855,2,,void
166362,BLOCK,1,,<empty>,,,,18,,void
166364,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,858,1,,void
166382,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,858,2,,void
166410,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,858,2,,void
166466,BLOCK,-1,,"{
    std::string first_path(req_wrap->continuation_data()->first_path());
    if (first_path.empty())
      return req_wrap->Resolve(Undefined(req_wrap->env()->isolate()));
    FromNamespacedPath(&first_path);
    Local<Value> path;
    Local<Value> error;
    if (!StringBytes::Encode(req_wrap->env()->isolate(), first_path.c_str(),
                             req_wrap->encoding(),
                             &error).ToLocal(&path)) {
      return req_wrap->Reject(error);
    }
    return req_wrap->Resolve(path);
  }",24,,860,2,,void
166481,BLOCK,-1,,<empty>,7,,863,2,,void
166536,BLOCK,-1,,"{
      return req_wrap->Reject(error);
    }",54,,869,2,,void
166553,BLOCK,-1,,"{
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  MaybeLocal<Value> link;
  Local<Value> error;

  if (after.Proceed()) {
    link = StringBytes::Encode(req_wrap->env()->isolate(),
                               req->path,
                               req_wrap->encoding(),
                               &error);
    if (link.IsEmpty())
      req_wrap->Reject(error);
    else
      req_wrap->Resolve(link.ToLocalChecked());
  }
}",36,,876,2,,void
166581,BLOCK,1,,<empty>,,,,18,,void
166583,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,879,1,,void
166601,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,879,2,,void
166629,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,879,2,,void
166695,BLOCK,-1,,"{
    link = StringBytes::Encode(req_wrap->env()->isolate(),
                               req->path,
                               req_wrap->encoding(),
                               &error);
    if (link.IsEmpty())
      req_wrap->Reject(error);
    else
      req_wrap->Resolve(link.ToLocalChecked());
  }",24,,884,2,,void
166723,BLOCK,-1,,<empty>,7,,890,2,,void
166730,BLOCK,-1,,<empty>,7,,892,1,,void
166743,BLOCK,-1,,"{
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  MaybeLocal<Value> link;
  Local<Value> error;

  if (after.Proceed()) {
    link = StringBytes::Encode(req_wrap->env()->isolate(),
                               static_cast<const char*>(req->ptr),
                               req_wrap->encoding(),
                               &error);
    if (link.IsEmpty())
      req_wrap->Reject(error);
    else
      req_wrap->Resolve(link.ToLocalChecked());
  }
}",35,,896,2,,void
166771,BLOCK,1,,<empty>,,,,18,,void
166773,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,899,1,,void
166791,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,899,2,,void
166819,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,899,2,,void
166885,BLOCK,-1,,"{
    link = StringBytes::Encode(req_wrap->env()->isolate(),
                               static_cast<const char*>(req->ptr),
                               req_wrap->encoding(),
                               &error);
    if (link.IsEmpty())
      req_wrap->Reject(error);
    else
      req_wrap->Resolve(link.ToLocalChecked());
  }",24,,904,2,,void
166915,BLOCK,-1,,<empty>,7,,910,2,,void
166922,BLOCK,-1,,<empty>,7,,912,1,,void
166935,BLOCK,-1,,"{
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (!after.Proceed()) {
    return;
  }

  Environment* env = req_wrap->env();
  Isolate* isolate = env->isolate();
  Local<Value> error;
  int r;

  std::vector<Local<Value>> name_v;
  std::vector<Local<Value>> type_v;

  const bool with_file_types = req_wrap->with_file_types();

  for (;;) {
    uv_dirent_t ent;

    r = uv_fs_scandir_next(req, &ent);
    if (r == UV_EOF)
      break;
    if (r != 0) {
      return req_wrap->Reject(
          UVException(isolate, r, nullptr, req_wrap->syscall(), req->path));
    }

    Local<Value> filename;
    if (!StringBytes::Encode(isolate, ent.name, req_wrap->encoding(), &error)
             .ToLocal(&filename)) {
      return req_wrap->Reject(error);
    }
    name_v.push_back(filename);

    if (with_file_types) type_v.emplace_back(Integer::New(isolate, e...",33,,916,2,,void
166963,BLOCK,1,,<empty>,,,,18,,void
166965,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,919,1,,void
166983,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,919,2,,void
167011,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,919,2,,void
167068,BLOCK,-1,,"{
    return;
  }",25,,921,2,,void
167116,BLOCK,-1,,<empty>,3,,935,1,,void
167117,BLOCK,4,,"{
    uv_dirent_t ent;

    r = uv_fs_scandir_next(req, &ent);
    if (r == UV_EOF)
      break;
    if (r != 0) {
      return req_wrap->Reject(
          UVException(isolate, r, nullptr, req_wrap->syscall(), req->path));
    }

    Local<Value> filename;
    if (!StringBytes::Encode(isolate, ent.name, req_wrap->encoding(), &error)
             .ToLocal(&filename)) {
      return req_wrap->Reject(error);
    }
    name_v.push_back(filename);

    if (with_file_types) type_v.emplace_back(Integer::New(isolate, ent.type));
  }",12,,935,4,,void
167129,BLOCK,-1,,<empty>,7,,940,2,,void
167135,BLOCK,-1,,"{
      return req_wrap->Reject(
          UVException(isolate, r, nullptr, req_wrap->syscall(), req->path));
    }",17,,941,2,,void
167178,BLOCK,-1,,"{
      return req_wrap->Reject(error);
    }",35,,948,2,,void
167192,BLOCK,-1,,<empty>,26,,953,2,,void
167207,BLOCK,-1,,"{
    Local<Value> result[] = {Array::New(isolate, name_v.data(), name_v.size()),
                             Array::New(isolate, type_v.data(), type_v.size())};
    req_wrap->Resolve(Array::New(isolate, result, arraysize(result)));
  }",24,,956,2,,void
167251,BLOCK,-1,,"{
    req_wrap->Resolve(Array::New(isolate, name_v.data(), name_v.size()));
  }",10,,960,1,,void
167273,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  Isolate* isolate = env->isolate();
  HandleScope scope(isolate);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  CHECK(args[1]->IsInt32());
  int mode = args[1].As<Int32>()->Value();

  BufferValue path(isolate, args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, path.ToStringView());

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // access(path, mode, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_ACCESS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""access"", UTF8, AfterNoArgs,
              uv_fs_access, *path, mode);
  } else {  // access(path, mode, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(access);
    SyncCall(env, args[3], &req_wrap_sync, ""access"", uv_fs_access, *path, mode);
    FS_SYNC_TRACE_END(a...",54,,965,2,,void
167351,BLOCK,-1,,"{  // access(path, mode, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_ACCESS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""access"", UTF8, AfterNoArgs,
              uv_fs_access, *path, mode);
  }",34,,983,2,,void
167360,BLOCK,1,,<empty>,,,,18,,void
167362,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_ACCESS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,984,1,,void
167380,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_ACCESS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,984,2,,void
167408,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_ACCESS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,984,2,,void
167472,BLOCK,-1,,"{  // access(path, mode, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(access);
    SyncCall(env, args[3], &req_wrap_sync, ""access"", uv_fs_access, *path, mode);
    FS_SYNC_TRACE_END(access);
  }",10,,988,1,,void
167480,BLOCK,1,,<empty>,,,,9,,void
167496,BLOCK,-1,,<empty>,5,,991,2,,void
167498,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(access),5,,991,1,,void
167516,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(access),5,,991,2,,void
167544,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(access),5,,991,2,,void
167588,BLOCK,1,,<empty>,,,,9,,void
167604,BLOCK,-1,,<empty>,5,,993,2,,void
167606,BLOCK,-1,,FS_SYNC_TRACE_END(access),5,,993,1,,void
167624,BLOCK,-1,,FS_SYNC_TRACE_END(access),5,,993,2,,void
167652,BLOCK,-1,,FS_SYNC_TRACE_END(access),5,,993,2,,void
167685,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  CHECK(args[0]->IsInt32());
  int fd = args[0].As<Int32>()->Value();
  env->RemoveUnmanagedFd(fd);

  FSReqBase* req_wrap_async = GetReqWrap(args, 1);
  if (req_wrap_async != nullptr) {  // close(fd, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""close"", UTF8, AfterNoArgs,
              uv_fs_close, fd);
  } else {  // close(fd, undefined, ctx)
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(close);
    SyncCall(env, args[2], &req_wrap_sync, ""close"", uv_fs_close, fd);
    FS_SYNC_TRACE_END(close);
  }
}",53,,998,2,,void
167738,BLOCK,-1,,"{  // close(fd, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""close"", UTF8, AfterNoArgs,
              uv_fs_close, fd);
  }",34,,1009,2,,void
167746,BLOCK,1,,<empty>,,,,16,,void
167748,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, req_wrap_async)",5,,1010,1,,void
167766,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, req_wrap_async)",5,,1010,2,,void
167794,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, req_wrap_async)",5,,1010,2,,void
167847,BLOCK,-1,,"{  // close(fd, undefined, ctx)
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(close);
    SyncCall(env, args[2], &req_wrap_sync, ""close"", uv_fs_close, fd);
    FS_SYNC_TRACE_END(close);
  }",10,,1013,1,,void
167855,BLOCK,1,,<empty>,,,,9,,void
167871,BLOCK,-1,,<empty>,5,,1016,2,,void
167873,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(close),5,,1016,1,,void
167891,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(close),5,,1016,2,,void
167919,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(close),5,,1016,2,,void
167961,BLOCK,1,,<empty>,,,,9,,void
167977,BLOCK,-1,,<empty>,5,,1018,2,,void
167979,BLOCK,-1,,FS_SYNC_TRACE_END(close),5,,1018,1,,void
167997,BLOCK,-1,,FS_SYNC_TRACE_END(close),5,,1018,2,,void
168025,BLOCK,-1,,FS_SYNC_TRACE_END(close),5,,1018,2,,void
168058,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  uv_loop_t* loop = env->event_loop();

  CHECK(args[0]->IsString());
  node::Utf8Value path(isolate, args[0]);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, path.ToStringView());

  if (strlen(*path) != path.length()) {
    args.GetReturnValue().Set(Array::New(isolate));
    return;  // Contains a nul byte.
  }
  uv_fs_t open_req;
  const int fd = uv_fs_open(loop, &open_req, *path, O_RDONLY, 0, nullptr);
  uv_fs_req_cleanup(&open_req);

  if (fd < 0) {
    args.GetReturnValue().Set(Array::New(isolate));
    return;
  }

  auto defer_close = OnScopeLeave([fd, loop]() {
    uv_fs_t close_req;
    CHECK_EQ(0, uv_fs_close(loop, &close_req, fd, nullptr));
    uv_fs_req_cleanup(&close_req);
  });

  const size_t kBlockSize = 32 << 10;
  std::vector<char> chars;
  int64_t offset = 0;
  ssize_t numchars;
  do {
    const size_t start = chars.size();
   ...",77,,1024,2,,void
168113,BLOCK,-1,,"{
    args.GetReturnValue().Set(Array::New(isolate));
    return;  // Contains a nul byte.
  }",39,,1034,2,,void
168146,BLOCK,-1,,"{
    args.GetReturnValue().Set(Array::New(isolate));
    return;
  }",15,,1042,2,,void
168178,BLOCK,-1,,"{
    const size_t start = chars.size();
    chars.resize(start + kBlockSize);

    uv_buf_t buf;
    buf.base = &chars[start];
    buf.len = kBlockSize;

    uv_fs_t read_req;
    numchars = uv_fs_read(loop, &read_req, fd, &buf, 1, offset, nullptr);
    uv_fs_req_cleanup(&read_req);

    if (numchars < 0) {
      args.GetReturnValue().Set(Array::New(isolate));
      return;
    }
    offset += numchars;
  }",6,,1057,1,,void
168227,BLOCK,-1,,"{
      args.GetReturnValue().Set(Array::New(isolate));
      return;
    }",23,,1069,2,,void
168267,BLOCK,-1,,"{
    start = 3;  // Skip UTF-8 BOM.
  }",68,,1077,2,,void
168303,BLOCK,-1,,"{
    char c = *p++;
    if (c == '\\' && p < pe && *p == '""') p++;
    if (c != '""') continue;
    *ppos++ = p;
    if (ppos < &pos[2]) continue;
    ppos = &pos[0];

    char* s = &pos[0][0];
    char* se = &pos[1][-1];  // Exclude quote.
    size_t n = se - s;

    if (n == 4) {
      if (0 == memcmp(s, ""main"", 4)) break;
      if (0 == memcmp(s, ""name"", 4)) break;
      if (0 == memcmp(s, ""type"", 4)) break;
    } else if (n == 7) {
      if (0 == memcmp(s, ""exports"", 7)) break;
      if (0 == memcmp(s, ""imports"", 7)) break;
    }
  }",18,,1087,2,,void
168323,BLOCK,-1,,<empty>,43,,1089,2,,void
168330,BLOCK,-1,,<empty>,19,,1090,2,,void
168344,BLOCK,-1,,<empty>,25,,1092,2,,void
168381,BLOCK,-1,,"{
      if (0 == memcmp(s, ""main"", 4)) break;
      if (0 == memcmp(s, ""name"", 4)) break;
      if (0 == memcmp(s, ""type"", 4)) break;
    }",17,,1099,2,,void
168389,BLOCK,-1,,<empty>,38,,1100,2,,void
168398,BLOCK,-1,,<empty>,38,,1101,2,,void
168407,BLOCK,-1,,<empty>,38,,1102,2,,void
168410,BLOCK,-1,,<empty>,12,,1103,1,,void
168415,BLOCK,-1,,"{
      if (0 == memcmp(s, ""exports"", 7)) break;
      if (0 == memcmp(s, ""imports"", 7)) break;
    }",24,,1103,2,,void
168423,BLOCK,-1,,<empty>,41,,1104,2,,void
168432,BLOCK,-1,,<empty>,41,,1105,2,,void
168486,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsString());
  node::Utf8Value path(env->isolate(), args[0]);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, path.ToStringView());

  uv_fs_t req;
  int rc = uv_fs_stat(env->event_loop(), &req, *path, nullptr);
  if (rc == 0) {
    const uv_stat_t* const s = static_cast<const uv_stat_t*>(req.ptr);
    rc = !!(s->st_mode & S_IFDIR);
  }
  uv_fs_req_cleanup(&req);

  args.GetReturnValue().Set(rc);
}",73,,1124,2,,void
168540,BLOCK,-1,,"{
    const uv_stat_t* const s = static_cast<const uv_stat_t*>(req.ptr);
    rc = !!(s->st_mode & S_IFDIR);
  }",16,,1134,2,,void
168573,BLOCK,-1,,"{
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = binding_data->env();

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, path.ToStringView());

  bool use_bigint = args[1]->IsTrue();
  FSReqBase* req_wrap_async = GetReqWrap(args, 2, use_bigint);
  if (req_wrap_async != nullptr) {  // stat(path, use_bigint, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""stat"", UTF8, AfterStat,
              uv_fs_stat, *path);
  } else {  // stat(path, use_bigint, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(stat);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""stat"", uv_fs_stat, *path);
    FS_SYNC_TRACE_END(stat);
    if (err != 0) {
   ...",59,,1143,2,,void
168644,BLOCK,-1,,"{  // stat(path, use_bigint, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""stat"", UTF8, AfterStat,
              uv_fs_stat, *path);
  }",34,,1157,2,,void
168653,BLOCK,1,,<empty>,,,,18,,void
168655,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1158,1,,void
168673,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1158,2,,void
168701,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1158,2,,void
168764,BLOCK,-1,,"{  // stat(path, use_bigint, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(stat);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""stat"", uv_fs_stat, *path);
    FS_SYNC_TRACE_END(stat);
    if (err != 0) {
      return;  // error info is in ctx
    }

    Local<Value> arr = FillGlobalStatsArray(binding_data, use_bigint,
        static_cast<const uv_stat_t*>(req_wrap_sync.req.ptr));
    args.GetReturnValue().Set(arr);
  }",10,,1162,1,,void
168772,BLOCK,1,,<empty>,,,,9,,void
168788,BLOCK,-1,,<empty>,5,,1165,2,,void
168790,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(stat),5,,1165,1,,void
168808,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(stat),5,,1165,2,,void
168836,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(stat),5,,1165,2,,void
168882,BLOCK,1,,<empty>,,,,9,,void
168898,BLOCK,-1,,<empty>,5,,1167,2,,void
168900,BLOCK,-1,,FS_SYNC_TRACE_END(stat),5,,1167,1,,void
168918,BLOCK,-1,,FS_SYNC_TRACE_END(stat),5,,1167,2,,void
168946,BLOCK,-1,,FS_SYNC_TRACE_END(stat),5,,1167,2,,void
168979,BLOCK,-1,,"{
      return;  // error info is in ctx
    }",19,,1168,2,,void
169009,BLOCK,-1,,"{
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = binding_data->env();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);

  bool use_bigint = args[1]->IsTrue();
  FSReqBase* req_wrap_async = GetReqWrap(args, 2, use_bigint);
  if (req_wrap_async != nullptr) {  // lstat(path, use_bigint, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LSTAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""lstat"", UTF8, AfterStat,
              uv_fs_lstat, *path);
  } else {  // lstat(path, use_bigint, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(lstat);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""lstat"", uv_fs_lstat,
                       *path);
    FS_SYNC_TRACE_END(lstat);
    if (err != 0) {
      return;  // error info is in ctx
    }

    Local<Value> arr = FillGlobalStatsArr...",60,,1178,2,,void
169069,BLOCK,-1,,"{  // lstat(path, use_bigint, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LSTAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""lstat"", UTF8, AfterStat,
              uv_fs_lstat, *path);
  }",34,,1190,2,,void
169078,BLOCK,1,,<empty>,,,,18,,void
169080,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LSTAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1191,1,,void
169098,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LSTAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1191,2,,void
169126,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LSTAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1191,2,,void
169189,BLOCK,-1,,"{  // lstat(path, use_bigint, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(lstat);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""lstat"", uv_fs_lstat,
                       *path);
    FS_SYNC_TRACE_END(lstat);
    if (err != 0) {
      return;  // error info is in ctx
    }

    Local<Value> arr = FillGlobalStatsArray(binding_data, use_bigint,
        static_cast<const uv_stat_t*>(req_wrap_sync.req.ptr));
    args.GetReturnValue().Set(arr);
  }",10,,1195,1,,void
169197,BLOCK,1,,<empty>,,,,9,,void
169213,BLOCK,-1,,<empty>,5,,1198,2,,void
169215,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(lstat),5,,1198,1,,void
169233,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(lstat),5,,1198,2,,void
169261,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(lstat),5,,1198,2,,void
169307,BLOCK,1,,<empty>,,,,9,,void
169323,BLOCK,-1,,<empty>,5,,1201,2,,void
169325,BLOCK,-1,,FS_SYNC_TRACE_END(lstat),5,,1201,1,,void
169343,BLOCK,-1,,FS_SYNC_TRACE_END(lstat),5,,1201,2,,void
169371,BLOCK,-1,,FS_SYNC_TRACE_END(lstat),5,,1201,2,,void
169404,BLOCK,-1,,"{
      return;  // error info is in ctx
    }",19,,1202,2,,void
169434,BLOCK,-1,,"{
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = binding_data->env();

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  CHECK(args[0]->IsInt32());
  int fd = args[0].As<Int32>()->Value();

  bool use_bigint = args[1]->IsTrue();
  FSReqBase* req_wrap_async = GetReqWrap(args, 2, use_bigint);
  if (req_wrap_async != nullptr) {  // fstat(fd, use_bigint, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FSTAT, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fstat"", UTF8, AfterStat,
              uv_fs_fstat, fd);
  } else {  // fstat(fd, use_bigint, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fstat);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""fstat"", uv_fs_fstat, fd);
    FS_SYNC_TRACE_END(fstat);
    if (err != 0) {
      return;  // error info is in ctx
    }

    Local<Value> arr = FillGlobalStatsArray(binding_data, use_bigint,
        static_cast<const uv_stat_t*>(req_wr...",60,,1212,2,,void
169501,BLOCK,-1,,"{  // fstat(fd, use_bigint, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FSTAT, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fstat"", UTF8, AfterStat,
              uv_fs_fstat, fd);
  }",34,,1224,2,,void
169509,BLOCK,1,,<empty>,,,,16,,void
169511,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FSTAT, req_wrap_async)",5,,1225,1,,void
169529,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FSTAT, req_wrap_async)",5,,1225,2,,void
169557,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FSTAT, req_wrap_async)",5,,1225,2,,void
169610,BLOCK,-1,,"{  // fstat(fd, use_bigint, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fstat);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""fstat"", uv_fs_fstat, fd);
    FS_SYNC_TRACE_END(fstat);
    if (err != 0) {
      return;  // error info is in ctx
    }

    Local<Value> arr = FillGlobalStatsArray(binding_data, use_bigint,
        static_cast<const uv_stat_t*>(req_wrap_sync.req.ptr));
    args.GetReturnValue().Set(arr);
  }",10,,1228,1,,void
169618,BLOCK,1,,<empty>,,,,9,,void
169634,BLOCK,-1,,<empty>,5,,1231,2,,void
169636,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fstat),5,,1231,1,,void
169654,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fstat),5,,1231,2,,void
169682,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fstat),5,,1231,2,,void
169727,BLOCK,1,,<empty>,,,,9,,void
169743,BLOCK,-1,,<empty>,5,,1233,2,,void
169745,BLOCK,-1,,FS_SYNC_TRACE_END(fstat),5,,1233,1,,void
169763,BLOCK,-1,,FS_SYNC_TRACE_END(fstat),5,,1233,2,,void
169791,BLOCK,-1,,FS_SYNC_TRACE_END(fstat),5,,1233,2,,void
169824,BLOCK,-1,,"{
      return;  // error info is in ctx
    }",19,,1234,2,,void
169854,BLOCK,-1,,"{
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = binding_data->env();

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);

  bool use_bigint = args[1]->IsTrue();
  FSReqBase* req_wrap_async = GetReqWrap(args, 2, use_bigint);
  if (req_wrap_async != nullptr) {  // statfs(path, use_bigint, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STATFS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env,
              req_wrap_async,
              args,
              ""statfs"",
              UTF8,
              AfterStatFs,
              uv_fs_statfs,
              *path);
  } else {  // statfs(path, use_bigint, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(statfs);
    int err =
        SyncCall(env, args[3], &req_wrap_sync, ""statfs"", uv_fs_statfs, *path);
    FS_SYNC_TRACE_END(statfs);
    if (err != 0) {
      r...",61,,1244,2,,void
169914,BLOCK,-1,,"{  // statfs(path, use_bigint, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STATFS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env,
              req_wrap_async,
              args,
              ""statfs"",
              UTF8,
              AfterStatFs,
              uv_fs_statfs,
              *path);
  }",34,,1256,2,,void
169923,BLOCK,1,,<empty>,,,,18,,void
169925,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STATFS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1257,1,,void
169943,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STATFS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1257,2,,void
169971,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STATFS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1257,2,,void
170034,BLOCK,-1,,"{  // statfs(path, use_bigint, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(statfs);
    int err =
        SyncCall(env, args[3], &req_wrap_sync, ""statfs"", uv_fs_statfs, *path);
    FS_SYNC_TRACE_END(statfs);
    if (err != 0) {
      return;  // error info is in ctx
    }

    Local<Value> arr = FillGlobalStatFsArray(
        binding_data,
        use_bigint,
        static_cast<const uv_statfs_t*>(req_wrap_sync.req.ptr));
    args.GetReturnValue().Set(arr);
  }",10,,1267,1,,void
170042,BLOCK,1,,<empty>,,,,9,,void
170058,BLOCK,-1,,<empty>,5,,1270,2,,void
170060,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(statfs),5,,1270,1,,void
170078,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(statfs),5,,1270,2,,void
170106,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(statfs),5,,1270,2,,void
170152,BLOCK,1,,<empty>,,,,9,,void
170168,BLOCK,-1,,<empty>,5,,1273,2,,void
170170,BLOCK,-1,,FS_SYNC_TRACE_END(statfs),5,,1273,1,,void
170188,BLOCK,-1,,FS_SYNC_TRACE_END(statfs),5,,1273,2,,void
170216,BLOCK,-1,,FS_SYNC_TRACE_END(statfs),5,,1273,2,,void
170249,BLOCK,-1,,"{
      return;  // error info is in ctx
    }",19,,1274,2,,void
170279,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 4);

  BufferValue target(isolate, args[0]);
  CHECK_NOT_NULL(*target);
  auto target_view = target.ToStringView();
  // To avoid bypass the symlink target should be allowed to read and write
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, target_view);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, target_view);

  BufferValue path(isolate, args[1]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  CHECK(args[2]->IsInt32());
  int flags = args[2].As<Int32>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // symlink(target, path, flags, req)
    FS_ASYNC_TRACE_BEGIN2(UV_FS_SYMLINK,
                        ...",62,,1286,2,,void
170386,BLOCK,-1,,"{  // symlink(target, path, flags, req)
    FS_ASYNC_TRACE_BEGIN2(UV_FS_SYMLINK,
                          req_wrap_async,
                          ""target"",
                          TRACE_STR_COPY(*target),
                          ""path"",
                          TRACE_STR_COPY(*path))
    AsyncDestCall(env, req_wrap_async, args, ""symlink"", *path, path.length(),
                  UTF8, AfterNoArgs, uv_fs_symlink, *target, *path, flags);
  }",34,,1311,2,,void
170396,BLOCK,1,,<empty>,,,,20,,void
170398,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_SYMLINK,
                          req_wrap_async,
                          ""target"",
                          TRACE_STR_COPY(*target),
                          ""path"",
                          TRACE_STR_COPY(*path))",5,,1312,1,,void
170416,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_SYMLINK,
                          req_wrap_async,
                          ""target"",
                          TRACE_STR_COPY(*target),
                          ""path"",
                          TRACE_STR_COPY(*path))",5,,1312,2,,void
170444,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_SYMLINK,
                          req_wrap_async,
                          ""target"",
                          TRACE_STR_COPY(*target),
                          ""path"",
                          TRACE_STR_COPY(*path))",5,,1312,2,,void
170525,BLOCK,-1,,"{  // symlink(target, path, flags, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(symlink);
    SyncCall(env, args[4], &req_wrap_sync, ""symlink"",
             uv_fs_symlink, *target, *path, flags);
    FS_SYNC_TRACE_END(symlink);
  }",10,,1320,1,,void
170533,BLOCK,1,,<empty>,,,,9,,void
170549,BLOCK,-1,,<empty>,5,,1323,2,,void
170551,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(symlink),5,,1323,1,,void
170569,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(symlink),5,,1323,2,,void
170597,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(symlink),5,,1323,2,,void
170643,BLOCK,1,,<empty>,,,,9,,void
170659,BLOCK,-1,,<empty>,5,,1326,2,,void
170661,BLOCK,-1,,FS_SYNC_TRACE_END(symlink),5,,1326,1,,void
170679,BLOCK,-1,,FS_SYNC_TRACE_END(symlink),5,,1326,2,,void
170707,BLOCK,-1,,FS_SYNC_TRACE_END(symlink),5,,1326,2,,void
170740,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue src(isolate, args[0]);
  CHECK_NOT_NULL(*src);

  const auto src_view = src.ToStringView();
  // To avoid bypass the link target should be allowed to read and write
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, src_view);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, src_view);

  BufferValue dest(isolate, args[1]);
  CHECK_NOT_NULL(*dest);
  const auto dest_view = dest.ToStringView();
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, dest_view);

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // link(src, dest, req)
    FS_ASYNC_TRACE_BEGIN2(UV_FS_LINK,
                          req_wrap_async,
                          ""src"",
                 ...",59,,1330,2,,void
170832,BLOCK,-1,,"{  // link(src, dest, req)
    FS_ASYNC_TRACE_BEGIN2(UV_FS_LINK,
                          req_wrap_async,
                          ""src"",
                          TRACE_STR_COPY(*src),
                          ""dest"",
                          TRACE_STR_COPY(*dest))
    AsyncDestCall(env, req_wrap_async, args, ""link"", *dest, dest.length(), UTF8,
                  AfterNoArgs, uv_fs_link, *src, *dest);
  }",34,,1354,2,,void
170842,BLOCK,1,,<empty>,,,,20,,void
170844,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_LINK,
                          req_wrap_async,
                          ""src"",
                          TRACE_STR_COPY(*src),
                          ""dest"",
                          TRACE_STR_COPY(*dest))",5,,1355,1,,void
170862,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_LINK,
                          req_wrap_async,
                          ""src"",
                          TRACE_STR_COPY(*src),
                          ""dest"",
                          TRACE_STR_COPY(*dest))",5,,1355,2,,void
170890,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_LINK,
                          req_wrap_async,
                          ""src"",
                          TRACE_STR_COPY(*src),
                          ""dest"",
                          TRACE_STR_COPY(*dest))",5,,1355,2,,void
170970,BLOCK,-1,,"{  // link(src, dest)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(link);
    SyncCall(env, args[3], &req_wrap_sync, ""link"",
             uv_fs_link, *src, *dest);
    FS_SYNC_TRACE_END(link);
  }",10,,1363,1,,void
170978,BLOCK,1,,<empty>,,,,9,,void
170994,BLOCK,-1,,<empty>,5,,1366,2,,void
170996,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(link),5,,1366,1,,void
171014,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(link),5,,1366,2,,void
171042,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(link),5,,1366,2,,void
171087,BLOCK,1,,<empty>,,,,9,,void
171103,BLOCK,-1,,<empty>,5,,1369,2,,void
171105,BLOCK,-1,,FS_SYNC_TRACE_END(link),5,,1369,1,,void
171123,BLOCK,-1,,FS_SYNC_TRACE_END(link),5,,1369,2,,void
171151,BLOCK,-1,,FS_SYNC_TRACE_END(link),5,,1369,2,,void
171184,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(isolate, args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, path.ToStringView());

  const enum encoding encoding = ParseEncoding(isolate, args[1], UTF8);

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // readlink(path, encoding, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_READLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""readlink"", encoding, AfterStringPtr,
              uv_fs_readlink, *path);
  } else {
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(readlink);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""readlink"",
                       uv_fs_readlink, *path);
    FS_SYNC_TRACE_END(readlink);
    if (err < ...",63,,1373,2,,void
171249,BLOCK,-1,,"{  // readlink(path, encoding, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_READLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""readlink"", encoding, AfterStringPtr,
              uv_fs_readlink, *path);
  }",34,,1388,2,,void
171258,BLOCK,1,,<empty>,,,,18,,void
171260,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_READLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1389,1,,void
171278,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_READLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1389,2,,void
171306,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_READLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1389,2,,void
171369,BLOCK,-1,,"{
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(readlink);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""readlink"",
                       uv_fs_readlink, *path);
    FS_SYNC_TRACE_END(readlink);
    if (err < 0) {
      return;  // syscall failed, no need to continue, error info is in ctx
    }
    const char* link_path = static_cast<const char*>(req_wrap_sync.req.ptr);

    Local<Value> error;
    MaybeLocal<Value> rc = StringBytes::Encode(isolate,
                                               link_path,
                                               encoding,
                                               &error);
    if (rc.IsEmpty()) {
      Local<Object> ctx = args[3].As<Object>();
      ctx->Set(env->context(), env->error_string(), error).Check();
      return;
    }

    args.GetReturnValue().Set(rc.ToLocalChecked());
  }",10,,1393,1,,void
171377,BLOCK,1,,<empty>,,,,9,,void
171393,BLOCK,-1,,<empty>,5,,1396,2,,void
171395,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(readlink),5,,1396,1,,void
171413,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(readlink),5,,1396,2,,void
171441,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(readlink),5,,1396,2,,void
171487,BLOCK,1,,<empty>,,,,9,,void
171503,BLOCK,-1,,<empty>,5,,1399,2,,void
171505,BLOCK,-1,,FS_SYNC_TRACE_END(readlink),5,,1399,1,,void
171523,BLOCK,-1,,FS_SYNC_TRACE_END(readlink),5,,1399,2,,void
171551,BLOCK,-1,,FS_SYNC_TRACE_END(readlink),5,,1399,2,,void
171584,BLOCK,-1,,"{
      return;  // syscall failed, no need to continue, error info is in ctx
    }",18,,1400,2,,void
171621,BLOCK,-1,,"{
      Local<Object> ctx = args[3].As<Object>();
      ctx->Set(env->context(), env->error_string(), error).Check();
      return;
    }",23,,1410,2,,void
171666,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue old_path(isolate, args[0]);
  CHECK_NOT_NULL(*old_path);
  auto view_old_path = old_path.ToStringView();
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, view_old_path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, view_old_path);

  BufferValue new_path(isolate, args[1]);
  CHECK_NOT_NULL(*new_path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env,
      permission::PermissionScope::kFileSystemWrite,
      new_path.ToStringView());

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {
    FS_ASYNC_TRACE_BEGIN2(UV_FS_RENAME,
                          req_wrap_async,
                          ""old_path"",
                          TRACE_STR_COPY(*old_path),
                          ""new_path"",
      ...",61,,1420,2,,void
171754,BLOCK,-1,,"{
    FS_ASYNC_TRACE_BEGIN2(UV_FS_RENAME,
                          req_wrap_async,
                          ""old_path"",
                          TRACE_STR_COPY(*old_path),
                          ""new_path"",
                          TRACE_STR_COPY(*new_path))
    AsyncDestCall(env, req_wrap_async, args, ""rename"", *new_path,
                  new_path.length(), UTF8, AfterNoArgs, uv_fs_rename,
                  *old_path, *new_path);
  }",34,,1443,2,,void
171764,BLOCK,1,,<empty>,,,,20,,void
171766,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_RENAME,
                          req_wrap_async,
                          ""old_path"",
                          TRACE_STR_COPY(*old_path),
                          ""new_path"",
                          TRACE_STR_COPY(*new_path))",5,,1444,1,,void
171784,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_RENAME,
                          req_wrap_async,
                          ""old_path"",
                          TRACE_STR_COPY(*old_path),
                          ""new_path"",
                          TRACE_STR_COPY(*new_path))",5,,1444,2,,void
171812,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_RENAME,
                          req_wrap_async,
                          ""old_path"",
                          TRACE_STR_COPY(*old_path),
                          ""new_path"",
                          TRACE_STR_COPY(*new_path))",5,,1444,2,,void
171892,BLOCK,-1,,"{
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(rename);
    SyncCall(env, args[3], &req_wrap_sync, ""rename"", uv_fs_rename,
             *old_path, *new_path);
    FS_SYNC_TRACE_END(rename);
  }",10,,1453,1,,void
171900,BLOCK,1,,<empty>,,,,9,,void
171916,BLOCK,-1,,<empty>,5,,1456,2,,void
171918,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(rename),5,,1456,1,,void
171936,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(rename),5,,1456,2,,void
171964,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(rename),5,,1456,2,,void
172009,BLOCK,1,,<empty>,,,,9,,void
172025,BLOCK,-1,,<empty>,5,,1459,2,,void
172027,BLOCK,-1,,FS_SYNC_TRACE_END(rename),5,,1459,1,,void
172045,BLOCK,-1,,FS_SYNC_TRACE_END(rename),5,,1459,2,,void
172073,BLOCK,-1,,FS_SYNC_TRACE_END(rename),5,,1459,2,,void
172106,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(IsSafeJsInt(args[1]));
  const int64_t len = args[1].As<Integer>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FTRUNCATE, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""ftruncate"", UTF8, AfterNoArgs,
              uv_fs_ftruncate, fd, len);
  } else {
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(ftruncate);
    SyncCall(env, args[3], &req_wrap_sync, ""ftruncate"", uv_fs_ftruncate, fd,
             len);
    FS_SYNC_TRACE_END(ftruncate);
  }
}",64,,1463,2,,void
172171,BLOCK,-1,,"{
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FTRUNCATE, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""ftruncate"", UTF8, AfterNoArgs,
              uv_fs_ftruncate, fd, len);
  }",34,,1476,2,,void
172179,BLOCK,1,,<empty>,,,,16,,void
172181,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FTRUNCATE, req_wrap_async)",5,,1477,1,,void
172199,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FTRUNCATE, req_wrap_async)",5,,1477,2,,void
172227,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FTRUNCATE, req_wrap_async)",5,,1477,2,,void
172281,BLOCK,-1,,"{
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(ftruncate);
    SyncCall(env, args[3], &req_wrap_sync, ""ftruncate"", uv_fs_ftruncate, fd,
             len);
    FS_SYNC_TRACE_END(ftruncate);
  }",10,,1480,1,,void
172289,BLOCK,1,,<empty>,,,,9,,void
172305,BLOCK,-1,,<empty>,5,,1483,2,,void
172307,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(ftruncate),5,,1483,1,,void
172325,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(ftruncate),5,,1483,2,,void
172353,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(ftruncate),5,,1483,2,,void
172396,BLOCK,1,,<empty>,,,,9,,void
172412,BLOCK,-1,,<empty>,5,,1486,2,,void
172414,BLOCK,-1,,FS_SYNC_TRACE_END(ftruncate),5,,1486,1,,void
172432,BLOCK,-1,,FS_SYNC_TRACE_END(ftruncate),5,,1486,2,,void
172460,BLOCK,-1,,FS_SYNC_TRACE_END(ftruncate),5,,1486,2,,void
172493,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 1);
  if (req_wrap_async != nullptr) {
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FDATASYNC, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fdatasync"", UTF8, AfterNoArgs,
              uv_fs_fdatasync, fd);
  } else {
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fdatasync);
    SyncCall(env, args[2], &req_wrap_sync, ""fdatasync"", uv_fs_fdatasync, fd);
    FS_SYNC_TRACE_END(fdatasync);
  }
}",64,,1490,2,,void
172541,BLOCK,-1,,"{
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FDATASYNC, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fdatasync"", UTF8, AfterNoArgs,
              uv_fs_fdatasync, fd);
  }",34,,1500,2,,void
172549,BLOCK,1,,<empty>,,,,16,,void
172551,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FDATASYNC, req_wrap_async)",5,,1501,1,,void
172569,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FDATASYNC, req_wrap_async)",5,,1501,2,,void
172597,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FDATASYNC, req_wrap_async)",5,,1501,2,,void
172650,BLOCK,-1,,"{
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fdatasync);
    SyncCall(env, args[2], &req_wrap_sync, ""fdatasync"", uv_fs_fdatasync, fd);
    FS_SYNC_TRACE_END(fdatasync);
  }",10,,1504,1,,void
172658,BLOCK,1,,<empty>,,,,9,,void
172674,BLOCK,-1,,<empty>,5,,1507,2,,void
172676,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fdatasync),5,,1507,1,,void
172694,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fdatasync),5,,1507,2,,void
172722,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fdatasync),5,,1507,2,,void
172764,BLOCK,1,,<empty>,,,,9,,void
172780,BLOCK,-1,,<empty>,5,,1509,2,,void
172782,BLOCK,-1,,FS_SYNC_TRACE_END(fdatasync),5,,1509,1,,void
172800,BLOCK,-1,,FS_SYNC_TRACE_END(fdatasync),5,,1509,2,,void
172828,BLOCK,-1,,FS_SYNC_TRACE_END(fdatasync),5,,1509,2,,void
172861,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 1);
  if (req_wrap_async != nullptr) {
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FSYNC, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fsync"", UTF8, AfterNoArgs,
              uv_fs_fsync, fd);
  } else {
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fsync);
    SyncCall(env, args[2], &req_wrap_sync, ""fsync"", uv_fs_fsync, fd);
    FS_SYNC_TRACE_END(fsync);
  }
}",60,,1513,2,,void
172909,BLOCK,-1,,"{
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FSYNC, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fsync"", UTF8, AfterNoArgs,
              uv_fs_fsync, fd);
  }",34,,1523,2,,void
172917,BLOCK,1,,<empty>,,,,16,,void
172919,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FSYNC, req_wrap_async)",5,,1524,1,,void
172937,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FSYNC, req_wrap_async)",5,,1524,2,,void
172965,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FSYNC, req_wrap_async)",5,,1524,2,,void
173018,BLOCK,-1,,"{
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fsync);
    SyncCall(env, args[2], &req_wrap_sync, ""fsync"", uv_fs_fsync, fd);
    FS_SYNC_TRACE_END(fsync);
  }",10,,1527,1,,void
173026,BLOCK,1,,<empty>,,,,9,,void
173042,BLOCK,-1,,<empty>,5,,1530,2,,void
173044,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fsync),5,,1530,1,,void
173062,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fsync),5,,1530,2,,void
173090,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fsync),5,,1530,2,,void
173132,BLOCK,1,,<empty>,,,,9,,void
173148,BLOCK,-1,,<empty>,5,,1532,2,,void
173150,BLOCK,-1,,FS_SYNC_TRACE_END(fsync),5,,1532,1,,void
173168,BLOCK,-1,,FS_SYNC_TRACE_END(fsync),5,,1532,2,,void
173196,BLOCK,-1,,FS_SYNC_TRACE_END(fsync),5,,1532,2,,void
173229,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  FSReqBase* req_wrap_async = GetReqWrap(args, 1);
  if (req_wrap_async != nullptr) {
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UNLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""unlink"", UTF8, AfterNoArgs,
              uv_fs_unlink, *path);
  } else {
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(unlink);
    SyncCall(env, args[2], &req_wrap_sync, ""unlink"", uv_fs_unlink, *path);
    FS_SYNC_TRACE_END(unlink);
  }
}",61,,1536,2,,void
173281,BLOCK,-1,,"{
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UNLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""unlink"", UTF8, AfterNoArgs,
              uv_fs_unlink, *path);
  }",34,,1548,2,,void
173290,BLOCK,1,,<empty>,,,,18,,void
173292,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UNLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1549,1,,void
173310,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UNLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1549,2,,void
173338,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UNLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1549,2,,void
173401,BLOCK,-1,,"{
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(unlink);
    SyncCall(env, args[2], &req_wrap_sync, ""unlink"", uv_fs_unlink, *path);
    FS_SYNC_TRACE_END(unlink);
  }",10,,1553,1,,void
173409,BLOCK,1,,<empty>,,,,9,,void
173425,BLOCK,-1,,<empty>,5,,1556,2,,void
173427,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(unlink),5,,1556,1,,void
173445,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(unlink),5,,1556,2,,void
173473,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(unlink),5,,1556,2,,void
173516,BLOCK,1,,<empty>,,,,9,,void
173532,BLOCK,-1,,<empty>,5,,1558,2,,void
173534,BLOCK,-1,,FS_SYNC_TRACE_END(unlink),5,,1558,1,,void
173552,BLOCK,-1,,FS_SYNC_TRACE_END(unlink),5,,1558,2,,void
173580,BLOCK,-1,,FS_SYNC_TRACE_END(unlink),5,,1558,2,,void
173613,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  FSReqBase* req_wrap_async = GetReqWrap(args, 1);  // rmdir(path, req)
  if (req_wrap_async != nullptr) {
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_RMDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""rmdir"", UTF8, AfterNoArgs,
              uv_fs_rmdir, *path);
  } else {  // rmdir(path, undefined, ctx)
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(rmdir);
    SyncCall(env, args[2], &req_wrap_sync, ""rmdir"",
             uv_fs_rmdir, *path);
    FS_SYNC_TRACE_END(rmdir);
  }
}",60,,1562,2,,void
173665,BLOCK,-1,,"{
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_RMDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""rmdir"", UTF8, AfterNoArgs,
              uv_fs_rmdir, *path);
  }",34,,1574,2,,void
173674,BLOCK,1,,<empty>,,,,18,,void
173676,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_RMDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1575,1,,void
173694,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_RMDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1575,2,,void
173722,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_RMDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1575,2,,void
173785,BLOCK,-1,,"{  // rmdir(path, undefined, ctx)
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(rmdir);
    SyncCall(env, args[2], &req_wrap_sync, ""rmdir"",
             uv_fs_rmdir, *path);
    FS_SYNC_TRACE_END(rmdir);
  }",10,,1579,1,,void
173793,BLOCK,1,,<empty>,,,,9,,void
173809,BLOCK,-1,,<empty>,5,,1582,2,,void
173811,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(rmdir),5,,1582,1,,void
173829,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(rmdir),5,,1582,2,,void
173857,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(rmdir),5,,1582,2,,void
173900,BLOCK,1,,<empty>,,,,9,,void
173916,BLOCK,-1,,<empty>,5,,1585,2,,void
173918,BLOCK,-1,,FS_SYNC_TRACE_END(rmdir),5,,1585,1,,void
173936,BLOCK,-1,,FS_SYNC_TRACE_END(rmdir),5,,1585,2,,void
173964,BLOCK,-1,,FS_SYNC_TRACE_END(rmdir),5,,1585,2,,void
174001,BLOCK,-1,,"{
  FSReqWrapSync* req_wrap = ContainerOf(&FSReqWrapSync::req, req);

  // on the first iteration of algorithm, stash state information.
  if (req_wrap->continuation_data() == nullptr) {
    req_wrap->set_continuation_data(
        std::make_unique<FSContinuationData>(req, mode, cb));
    req_wrap->continuation_data()->PushPath(std::move(path));
  }

  while (req_wrap->continuation_data()->paths().size() > 0) {
    std::string next_path = req_wrap->continuation_data()->PopPath();
    int err = uv_fs_mkdir(loop, req, next_path.c_str(), mode, nullptr);
    while (true) {
      switch (err) {
        // Note: uv_fs_req_cleanup in terminal paths will be called by
        // ~FSReqWrapSync():
        case 0:
          req_wrap->continuation_data()->MaybeSetFirstPath(next_path);
          if (req_wrap->continuation_data()->paths().size() == 0) {
            return 0;
          }
          break;
        case UV_EACCES:
        case UV_ENOSPC:
        case UV_ENOTDIR:
        case UV_EPERM...",29,,1593,6,,void
174018,BLOCK,-1,,"{
    req_wrap->set_continuation_data(
        std::make_unique<FSContinuationData>(req, mode, cb));
    req_wrap->continuation_data()->PushPath(std::move(path));
  }",49,,1597,2,,void
174059,BLOCK,-1,,"{
    std::string next_path = req_wrap->continuation_data()->PopPath();
    int err = uv_fs_mkdir(loop, req, next_path.c_str(), mode, nullptr);
    while (true) {
      switch (err) {
        // Note: uv_fs_req_cleanup in terminal paths will be called by
        // ~FSReqWrapSync():
        case 0:
          req_wrap->continuation_data()->MaybeSetFirstPath(next_path);
          if (req_wrap->continuation_data()->paths().size() == 0) {
            return 0;
          }
          break;
        case UV_EACCES:
        case UV_ENOSPC:
        case UV_ENOTDIR:
        case UV_EPERM: {
          return err;
        }
        case UV_ENOENT: {
          std::string dirname = next_path.substr(0,
                                        next_path.find_last_of(kPathSeparator));
          if (dirname != next_path) {
            req_wrap->continuation_data()->PushPath(std::move(next_path));
            req_wrap->continuation_data()->PushPath(std::move(dirname));
          } else if (req_wrap->c...",61,,1603,2,,void
174084,BLOCK,-1,,"{
      switch (err) {
        // Note: uv_fs_req_cleanup in terminal paths will be called by
        // ~FSReqWrapSync():
        case 0:
          req_wrap->continuation_data()->MaybeSetFirstPath(next_path);
          if (req_wrap->continuation_data()->paths().size() == 0) {
            return 0;
          }
          break;
        case UV_EACCES:
        case UV_ENOSPC:
        case UV_ENOTDIR:
        case UV_EPERM: {
          return err;
        }
        case UV_ENOENT: {
          std::string dirname = next_path.substr(0,
                                        next_path.find_last_of(kPathSeparator));
          if (dirname != next_path) {
            req_wrap->continuation_data()->PushPath(std::move(next_path));
            req_wrap->continuation_data()->PushPath(std::move(dirname));
          } else if (req_wrap->continuation_data()->paths().size() == 0) {
            err = UV_EEXIST;
            continue;
          }
          break;
        }
        default:
          u...",18,,1606,2,,void
174087,BLOCK,-1,,"{
        // Note: uv_fs_req_cleanup in terminal paths will be called by
        // ~FSReqWrapSync():
        case 0:
          req_wrap->continuation_data()->MaybeSetFirstPath(next_path);
          if (req_wrap->continuation_data()->paths().size() == 0) {
            return 0;
          }
          break;
        case UV_EACCES:
        case UV_ENOSPC:
        case UV_ENOTDIR:
        case UV_EPERM: {
          return err;
        }
        case UV_ENOENT: {
          std::string dirname = next_path.substr(0,
                                        next_path.find_last_of(kPathSeparator));
          if (dirname != next_path) {
            req_wrap->continuation_data()->PushPath(std::move(next_path));
            req_wrap->continuation_data()->PushPath(std::move(dirname));
          } else if (req_wrap->continuation_data()->paths().size() == 0) {
            err = UV_EEXIST;
            continue;
          }
          break;
        }
        default:
          uv_fs_req_cleanup(req)...",20,,1607,2,,void
174111,BLOCK,-1,,"{
            return 0;
          }",67,,1612,2,,void
174123,BLOCK,14,,"{
          return err;
        }",24,,1619,14,,void
174128,BLOCK,17,,"{
          std::string dirname = next_path.substr(0,
                                        next_path.find_last_of(kPathSeparator));
          if (dirname != next_path) {
            req_wrap->continuation_data()->PushPath(std::move(next_path));
            req_wrap->continuation_data()->PushPath(std::move(dirname));
          } else if (req_wrap->continuation_data()->paths().size() == 0) {
            err = UV_EEXIST;
            continue;
          }
          break;
        }",25,,1622,17,,void
174146,BLOCK,-1,,"{
            req_wrap->continuation_data()->PushPath(std::move(next_path));
            req_wrap->continuation_data()->PushPath(std::move(dirname));
          }",37,,1625,2,,void
174172,BLOCK,-1,,<empty>,18,,1628,1,,void
174186,BLOCK,-1,,"{
            err = UV_EEXIST;
            continue;
          }",74,,1628,2,,void
174221,BLOCK,1,,<empty>,,,,2,,void
174231,BLOCK,-1,,"{
            uv_fs_req_cleanup(req);
            if (orig_err == UV_EEXIST &&
              req_wrap->continuation_data()->paths().size() > 0) {
              return UV_ENOTDIR;
            }
            return UV_EEXIST;
          }",59,,1638,2,,void
174251,BLOCK,-1,,"{
              return UV_ENOTDIR;
            }",66,,1641,2,,void
174260,BLOCK,-1,,<empty>,24,,1646,2,,void
174276,BLOCK,-1,,"{
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  // on the first iteration of algorithm, stash state information.
  if (req_wrap->continuation_data() == nullptr) {
    req_wrap->set_continuation_data(
        std::make_unique<FSContinuationData>(req, mode, cb));
    req_wrap->continuation_data()->PushPath(std::move(path));
  }

  // on each iteration of algorithm, mkdir directory on top of stack.
  std::string next_path = req_wrap->continuation_data()->PopPath();
  int err = uv_fs_mkdir(loop, req, next_path.c_str(), mode,
                        uv_fs_callback_t{[](uv_fs_t* req) {
    FSReqBase* req_wrap = FSReqBase::from_req(req);
    Environment* env = req_wrap->env();
    uv_loop_t* loop = env->event_loop();
    std::string path = req->path;
    int err = static_cast<int>(req->result);

    while (true) {
      switch (err) {
        // Note: uv_fs_req_cleanup in terminal paths will be called by
        // FSReqAfterScope::~FSReqAfterScope()
        case 0: {
          if (r...",30,,1661,6,,void
174292,BLOCK,-1,,"{
    req_wrap->set_continuation_data(
        std::make_unique<FSContinuationData>(req, mode, cb));
    req_wrap->continuation_data()->PushPath(std::move(path));
  }",49,,1664,2,,void
174354,BLOCK,-1,,"{
  env->PrintSyncTrace();
  int err = MKDirpSync(env->event_loop(), &req_wrap->req, path, mode,
                       nullptr);
  if (err < 0) {
    v8::Local<v8::Context> context = env->context();
    v8::Local<v8::Object> ctx_obj = args[4].As<v8::Object>();
    v8::Isolate* isolate = env->isolate();
    ctx_obj->Set(context,
                 env->errno_string(),
                 v8::Integer::New(isolate, err)).Check();
    ctx_obj->Set(context,
                 env->syscall_string(),
                 OneByteString(isolate, ""mkdir"")).Check();
  }
  return err;
}",73,,1753,6,,void
174378,BLOCK,-1,,"{
    v8::Local<v8::Context> context = env->context();
    v8::Local<v8::Object> ctx_obj = args[4].As<v8::Object>();
    v8::Isolate* isolate = env->isolate();
    ctx_obj->Set(context,
                 env->errno_string(),
                 v8::Integer::New(isolate, err)).Check();
    ctx_obj->Set(context,
                 env->syscall_string(),
                 OneByteString(isolate, ""mkdir"")).Check();
  }",16,,1757,2,,void
174457,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 4);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  CHECK(args[1]->IsInt32());
  const int mode = args[1].As<Int32>()->Value();

  CHECK(args[2]->IsBoolean());
  bool mkdirp = args[2]->IsTrue();

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // mkdir(path, mode, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UNLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""mkdir"", UTF8,
              mkdirp ? AfterMkdirp : AfterNoArgs,
              mkdirp ? MKDirpAsync : uv_fs_mkdir, *path, mode);
  } else {  // mkdir(path, mode, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(mkdir);
    if (mkdirp) {
      int err = Ca...",60,,1771,2,,void
174544,BLOCK,-1,,"{  // mkdir(path, mode, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UNLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""mkdir"", UTF8,
              mkdirp ? AfterMkdirp : AfterNoArgs,
              mkdirp ? MKDirpAsync : uv_fs_mkdir, *path, mode);
  }",34,,1789,2,,void
174553,BLOCK,1,,<empty>,,,,18,,void
174555,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UNLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1790,1,,void
174573,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UNLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1790,2,,void
174601,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UNLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1790,2,,void
174671,BLOCK,-1,,"{  // mkdir(path, mode, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(mkdir);
    if (mkdirp) {
      int err = CallMKDirpSync(env, args, &req_wrap_sync, *path, mode);
      if (err == 0 &&
          !req_wrap_sync.continuation_data()->first_path().empty()) {
        Local<Value> error;
        std::string first_path(req_wrap_sync.continuation_data()->first_path());
        FromNamespacedPath(&first_path);
        MaybeLocal<Value> path = StringBytes::Encode(env->isolate(),
                                                     first_path.c_str(),
                                                     UTF8, &error);
        if (path.IsEmpty()) {
          Local<Object> ctx = args[4].As<Object>();
          ctx->Set(env->context(), env->error_string(), error).Check();
          return;
        }
        args.GetReturnValue().Set(path.ToLocalChecked());
      }
    } else {
      SyncCall(env, args[4], &req_wrap_sync, ""mkdir"",
            ...",10,,1795,1,,void
174679,BLOCK,1,,<empty>,,,,9,,void
174695,BLOCK,-1,,<empty>,5,,1798,2,,void
174697,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(mkdir),5,,1798,1,,void
174715,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(mkdir),5,,1798,2,,void
174743,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(mkdir),5,,1798,2,,void
174774,BLOCK,-1,,"{
      int err = CallMKDirpSync(env, args, &req_wrap_sync, *path, mode);
      if (err == 0 &&
          !req_wrap_sync.continuation_data()->first_path().empty()) {
        Local<Value> error;
        std::string first_path(req_wrap_sync.continuation_data()->first_path());
        FromNamespacedPath(&first_path);
        MaybeLocal<Value> path = StringBytes::Encode(env->isolate(),
                                                     first_path.c_str(),
                                                     UTF8, &error);
        if (path.IsEmpty()) {
          Local<Object> ctx = args[4].As<Object>();
          ctx->Set(env->context(), env->error_string(), error).Check();
          return;
        }
        args.GetReturnValue().Set(path.ToLocalChecked());
      }
    }",17,,1799,2,,void
174802,BLOCK,-1,,"{
        Local<Value> error;
        std::string first_path(req_wrap_sync.continuation_data()->first_path());
        FromNamespacedPath(&first_path);
        MaybeLocal<Value> path = StringBytes::Encode(env->isolate(),
                                                     first_path.c_str(),
                                                     UTF8, &error);
        if (path.IsEmpty()) {
          Local<Object> ctx = args[4].As<Object>();
          ctx->Set(env->context(), env->error_string(), error).Check();
          return;
        }
        args.GetReturnValue().Set(path.ToLocalChecked());
      }",69,,1802,2,,void
174846,BLOCK,-1,,"{
          Local<Object> ctx = args[4].As<Object>();
          ctx->Set(env->context(), env->error_string(), error).Check();
          return;
        }",29,,1809,2,,void
174888,BLOCK,-1,,"{
      SyncCall(env, args[4], &req_wrap_sync, ""mkdir"",
               uv_fs_mkdir, *path, mode);
    }",12,,1816,1,,void
174904,BLOCK,1,,<empty>,,,,9,,void
174920,BLOCK,-1,,<empty>,5,,1820,2,,void
174922,BLOCK,-1,,FS_SYNC_TRACE_END(mkdir),5,,1820,1,,void
174940,BLOCK,-1,,FS_SYNC_TRACE_END(mkdir),5,,1820,2,,void
174968,BLOCK,-1,,FS_SYNC_TRACE_END(mkdir),5,,1820,2,,void
175001,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(isolate, args[0]);
  CHECK_NOT_NULL(*path);

  const enum encoding encoding = ParseEncoding(isolate, args[1], UTF8);

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // realpath(path, encoding, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_REALPATH, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""realpath"", encoding, AfterStringPtr,
              uv_fs_realpath, *path);
  } else {  // realpath(path, encoding, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(realpath);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""realpath"",
                       uv_fs_realpath, *path);
    FS_SYNC_TRACE_END(realpath);
    if (err < 0) {
      return;  // syscall failed, no need to continue, error info ...",63,,1824,2,,void
175055,BLOCK,-1,,"{  // realpath(path, encoding, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_REALPATH, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""realpath"", encoding, AfterStringPtr,
              uv_fs_realpath, *path);
  }",34,,1837,2,,void
175064,BLOCK,1,,<empty>,,,,18,,void
175066,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_REALPATH, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1838,1,,void
175084,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_REALPATH, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1838,2,,void
175112,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_REALPATH, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1838,2,,void
175175,BLOCK,-1,,"{  // realpath(path, encoding, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(realpath);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""realpath"",
                       uv_fs_realpath, *path);
    FS_SYNC_TRACE_END(realpath);
    if (err < 0) {
      return;  // syscall failed, no need to continue, error info is in ctx
    }

    const char* link_path = static_cast<const char*>(req_wrap_sync.req.ptr);

    Local<Value> error;
    MaybeLocal<Value> rc = StringBytes::Encode(isolate,
                                               link_path,
                                               encoding,
                                               &error);
    if (rc.IsEmpty()) {
      Local<Object> ctx = args[3].As<Object>();
      ctx->Set(env->context(), env->error_string(), error).Check();
      return;
    }

    args.GetReturnValue().Set(rc.ToLocalChecked());
  }",10,,1842,1,,void
175183,BLOCK,1,,<empty>,,,,9,,void
175199,BLOCK,-1,,<empty>,5,,1845,2,,void
175201,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(realpath),5,,1845,1,,void
175219,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(realpath),5,,1845,2,,void
175247,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(realpath),5,,1845,2,,void
175293,BLOCK,1,,<empty>,,,,9,,void
175309,BLOCK,-1,,<empty>,5,,1848,2,,void
175311,BLOCK,-1,,FS_SYNC_TRACE_END(realpath),5,,1848,1,,void
175329,BLOCK,-1,,FS_SYNC_TRACE_END(realpath),5,,1848,2,,void
175357,BLOCK,-1,,FS_SYNC_TRACE_END(realpath),5,,1848,2,,void
175390,BLOCK,-1,,"{
      return;  // syscall failed, no need to continue, error info is in ctx
    }",18,,1849,2,,void
175427,BLOCK,-1,,"{
      Local<Object> ctx = args[3].As<Object>();
      ctx->Set(env->context(), env->error_string(), error).Check();
      return;
    }",23,,1860,2,,void
175472,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(isolate, args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, path.ToStringView());

  const enum encoding encoding = ParseEncoding(isolate, args[1], UTF8);

  bool with_types = args[2]->IsTrue();

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // readdir(path, encoding, withTypes, req)
    req_wrap_async->set_with_file_types(with_types);
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_SCANDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env,
              req_wrap_async,
              args,
              ""scandir"",
              encoding,
              AfterScanDir,
              uv_fs_scandir,
              *path,
              0 /*flags*/);
  } else {  // readdir(path, encoding, withTypes, un...",62,,1870,2,,void
175546,BLOCK,-1,,"{  // readdir(path, encoding, withTypes, req)
    req_wrap_async->set_with_file_types(with_types);
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_SCANDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env,
              req_wrap_async,
              args,
              ""scandir"",
              encoding,
              AfterScanDir,
              uv_fs_scandir,
              *path,
              0 /*flags*/);
  }",34,,1887,2,,void
175560,BLOCK,1,,<empty>,,,,18,,void
175562,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_SCANDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1889,1,,void
175580,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_SCANDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1889,2,,void
175608,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_SCANDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1889,2,,void
175672,BLOCK,-1,,"{  // readdir(path, encoding, withTypes, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(readdir);
    int err = SyncCall(env, args[4], &req_wrap_sync, ""scandir"",
                       uv_fs_scandir, *path, 0 /*flags*/);
    FS_SYNC_TRACE_END(readdir);
    if (err < 0) {
      return;  // syscall failed, no need to continue, error info is in ctx
    }

    CHECK_GE(req_wrap_sync.req.result, 0);
    int r;
    std::vector<Local<Value>> name_v;
    std::vector<Local<Value>> type_v;

    for (;;) {
      uv_dirent_t ent;

      r = uv_fs_scandir_next(&(req_wrap_sync.req), &ent);
      if (r == UV_EOF)
        break;
      if (r != 0) {
        Local<Object> ctx = args[4].As<Object>();
        ctx->Set(env->context(), env->errno_string(),
                 Integer::New(isolate, r)).Check();
        ctx->Set(env->context(), env->syscall_string(),
                 OneByteString(isolate, ""readdir"")).Check();
        return;
      }

      Loc...",10,,1900,1,,void
175680,BLOCK,1,,<empty>,,,,9,,void
175696,BLOCK,-1,,<empty>,5,,1903,2,,void
175698,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(readdir),5,,1903,1,,void
175716,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(readdir),5,,1903,2,,void
175744,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(readdir),5,,1903,2,,void
175791,BLOCK,1,,<empty>,,,,9,,void
175807,BLOCK,-1,,<empty>,5,,1906,2,,void
175809,BLOCK,-1,,FS_SYNC_TRACE_END(readdir),5,,1906,1,,void
175827,BLOCK,-1,,FS_SYNC_TRACE_END(readdir),5,,1906,2,,void
175855,BLOCK,-1,,FS_SYNC_TRACE_END(readdir),5,,1906,2,,void
175888,BLOCK,-1,,"{
      return;  // syscall failed, no need to continue, error info is in ctx
    }",18,,1907,2,,void
175917,BLOCK,-1,,<empty>,5,,1916,1,,void
175918,BLOCK,4,,"{
      uv_dirent_t ent;

      r = uv_fs_scandir_next(&(req_wrap_sync.req), &ent);
      if (r == UV_EOF)
        break;
      if (r != 0) {
        Local<Object> ctx = args[4].As<Object>();
        ctx->Set(env->context(), env->errno_string(),
                 Integer::New(isolate, r)).Check();
        ctx->Set(env->context(), env->syscall_string(),
                 OneByteString(isolate, ""readdir"")).Check();
        return;
      }

      Local<Value> error;
      MaybeLocal<Value> filename = StringBytes::Encode(isolate,
                                                       ent.name,
                                                       encoding,
                                                       &error);

      if (filename.IsEmpty()) {
        Local<Object> ctx = args[4].As<Object>();
        ctx->Set(env->context(), env->error_string(), error).Check();
        return;
      }

      name_v.push_back(filename.ToLocalChecked());

      if (with_types) {
        type_v.empl...",14,,1916,4,,void
175933,BLOCK,-1,,<empty>,9,,1921,2,,void
175939,BLOCK,-1,,"{
        Local<Object> ctx = args[4].As<Object>();
        ctx->Set(env->context(), env->errno_string(),
                 Integer::New(isolate, r)).Check();
        ctx->Set(env->context(), env->syscall_string(),
                 OneByteString(isolate, ""readdir"")).Check();
        return;
      }",19,,1922,2,,void
176019,BLOCK,-1,,"{
        Local<Object> ctx = args[4].As<Object>();
        ctx->Set(env->context(), env->error_string(), error).Check();
        return;
      }",31,,1937,2,,void
176059,BLOCK,-1,,"{
        type_v.emplace_back(Integer::New(isolate, ent.type));
      }",23,,1945,2,,void
176093,BLOCK,-1,,"{
      Local<Value> result[] = {
        names,
        Array::New(isolate, type_v.data(), type_v.size())
      };
      args.GetReturnValue().Set(Array::New(isolate, result, arraysize(result)));
    }",21,,1952,2,,void
176128,BLOCK,-1,,"{
      args.GetReturnValue().Set(names);
    }",12,,1958,1,,void
176143,BLOCK,-1,,"{
  // These flags capture the intention of the open() call.
  const int rwflags = flags & (UV_FS_O_RDONLY | UV_FS_O_WRONLY | UV_FS_O_RDWR);

  // These flags have write-like side effects even with O_RDONLY, at least on
  // some operating systems. On Windows, for example, O_RDONLY | O_TEMPORARY
  // can be used to delete a file. Bizarre.
  const int write_as_side_effect = flags & (UV_FS_O_APPEND | UV_FS_O_CREAT |
                                            UV_FS_O_TRUNC | UV_FS_O_TEMPORARY);

  // TODO(rafaelgss): it can be optimized to avoid two permission checks
  auto pathView = path.ToStringView();
  if (rwflags != UV_FS_O_WRONLY) {
    THROW_IF_INSUFFICIENT_PERMISSIONS(
        env,
        permission::PermissionScope::kFileSystemRead,
        pathView,
        Nothing<void>());
  }
  if (rwflags != UV_FS_O_RDONLY || write_as_side_effect) {
    THROW_IF_INSUFFICIENT_PERMISSIONS(
        env,
        permission::PermissionScope::kFileSystemWrite,
        pathView,
        Nothi...",59,,1966,4,,void
176177,BLOCK,-1,,"{
    THROW_IF_INSUFFICIENT_PERMISSIONS(
        env,
        permission::PermissionScope::kFileSystemRead,
        pathView,
        Nothing<void>());
  }",34,,1978,2,,void
176193,BLOCK,-1,,"{
    THROW_IF_INSUFFICIENT_PERMISSIONS(
        env,
        permission::PermissionScope::kFileSystemWrite,
        pathView,
        Nothing<void>());
  }",58,,1985,2,,void
176209,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);

  CHECK(args[1]->IsInt32());
  const int flags = args[1].As<Int32>()->Value();

  CHECK(args[2]->IsInt32());
  const int mode = args[2].As<Int32>()->Value();

  if (CheckOpenPermissions(env, path, flags).IsNothing()) return;

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // open(path, flags, mode, req)
    req_wrap_async->set_is_plain_open(true);
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_OPEN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""open"", UTF8, AfterInteger,
              uv_fs_open, *path, flags, mode);
  } else {  // open(path, flags, mode, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(open);
    int result = SyncCall(env, args[4], &req_wrap_sync, ""open"",
         ...",59,,1995,2,,void
176286,BLOCK,-1,,<empty>,59,,2010,2,,void
176298,BLOCK,-1,,"{  // open(path, flags, mode, req)
    req_wrap_async->set_is_plain_open(true);
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_OPEN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""open"", UTF8, AfterInteger,
              uv_fs_open, *path, flags, mode);
  }",34,,2013,2,,void
176312,BLOCK,1,,<empty>,,,,18,,void
176314,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_OPEN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2015,1,,void
176332,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_OPEN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2015,2,,void
176360,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_OPEN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2015,2,,void
176425,BLOCK,-1,,"{  // open(path, flags, mode, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(open);
    int result = SyncCall(env, args[4], &req_wrap_sync, ""open"",
                          uv_fs_open, *path, flags, mode);
    FS_SYNC_TRACE_END(open);
    if (result >= 0) env->AddUnmanagedFd(result);
    args.GetReturnValue().Set(result);
  }",10,,2019,1,,void
176433,BLOCK,1,,<empty>,,,,9,,void
176449,BLOCK,-1,,<empty>,5,,2022,2,,void
176451,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(open),5,,2022,1,,void
176469,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(open),5,,2022,2,,void
176497,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(open),5,,2022,2,,void
176545,BLOCK,1,,<empty>,,,,9,,void
176561,BLOCK,-1,,<empty>,5,,2025,2,,void
176563,BLOCK,-1,,FS_SYNC_TRACE_END(open),5,,2025,1,,void
176581,BLOCK,-1,,FS_SYNC_TRACE_END(open),5,,2025,2,,void
176609,BLOCK,-1,,FS_SYNC_TRACE_END(open),5,,2025,2,,void
176642,BLOCK,-1,,<empty>,22,,2026,2,,void
176660,BLOCK,-1,,"{
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = binding_data->env();
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(isolate, args[0]);
  CHECK_NOT_NULL(*path);

  CHECK(args[1]->IsInt32());
  const int flags = args[1].As<Int32>()->Value();

  CHECK(args[2]->IsInt32());
  const int mode = args[2].As<Int32>()->Value();

  if (CheckOpenPermissions(env, path, flags).IsNothing()) return;

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // openFileHandle(path, flags, mode, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_OPEN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""open"", UTF8, AfterOpenFileHandle,
              uv_fs_open, *path, flags, mode);
  } else {  // openFileHandle(path, flags, mode, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(open);...",69,,2031,2,,void
176750,BLOCK,-1,,<empty>,59,,2048,2,,void
176762,BLOCK,-1,,"{  // openFileHandle(path, flags, mode, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_OPEN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""open"", UTF8, AfterOpenFileHandle,
              uv_fs_open, *path, flags, mode);
  }",34,,2051,2,,void
176771,BLOCK,1,,<empty>,,,,18,,void
176773,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_OPEN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2052,1,,void
176791,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_OPEN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2052,2,,void
176819,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_OPEN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2052,2,,void
176884,BLOCK,-1,,"{  // openFileHandle(path, flags, mode, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(open);
    int result = SyncCall(env, args[4], &req_wrap_sync, ""open"",
                          uv_fs_open, *path, flags, mode);
    FS_SYNC_TRACE_END(open);
    if (result < 0) {
      return;  // syscall failed, no need to continue, error info is in ctx
    }
    FileHandle* fd = FileHandle::New(binding_data, result);
    if (fd == nullptr) return;
    args.GetReturnValue().Set(fd->object());
  }",10,,2056,1,,void
176892,BLOCK,1,,<empty>,,,,9,,void
176908,BLOCK,-1,,<empty>,5,,2059,2,,void
176910,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(open),5,,2059,1,,void
176928,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(open),5,,2059,2,,void
176956,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(open),5,,2059,2,,void
177004,BLOCK,1,,<empty>,,,,9,,void
177020,BLOCK,-1,,<empty>,5,,2062,2,,void
177022,BLOCK,-1,,FS_SYNC_TRACE_END(open),5,,2062,1,,void
177040,BLOCK,-1,,FS_SYNC_TRACE_END(open),5,,2062,2,,void
177068,BLOCK,-1,,FS_SYNC_TRACE_END(open),5,,2062,2,,void
177101,BLOCK,-1,,"{
      return;  // syscall failed, no need to continue, error info is in ctx
    }",21,,2063,2,,void
177116,BLOCK,-1,,<empty>,24,,2067,2,,void
177133,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue src(isolate, args[0]);
  CHECK_NOT_NULL(*src);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, src.ToStringView());

  BufferValue dest(isolate, args[1]);
  CHECK_NOT_NULL(*dest);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, dest.ToStringView());

  CHECK(args[2]->IsInt32());
  const int flags = args[2].As<Int32>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // copyFile(src, dest, flags, req)
    FS_ASYNC_TRACE_BEGIN2(UV_FS_COPYFILE,
                          req_wrap_async,
                          ""src"",
                          TRACE_STR_COPY(*src),
                          ""dest"",
                          TRACE_STR_COPY(*dest))
    AsyncDestCall(env, req_wrap_async, ar...",63,,2072,2,,void
177228,BLOCK,-1,,"{  // copyFile(src, dest, flags, req)
    FS_ASYNC_TRACE_BEGIN2(UV_FS_COPYFILE,
                          req_wrap_async,
                          ""src"",
                          TRACE_STR_COPY(*src),
                          ""dest"",
                          TRACE_STR_COPY(*dest))
    AsyncDestCall(env, req_wrap_async, args, ""copyfile"",
                  *dest, dest.length(), UTF8, AfterNoArgs,
                  uv_fs_copyfile, *src, *dest, flags);
  }",34,,2093,2,,void
177238,BLOCK,1,,<empty>,,,,20,,void
177240,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_COPYFILE,
                          req_wrap_async,
                          ""src"",
                          TRACE_STR_COPY(*src),
                          ""dest"",
                          TRACE_STR_COPY(*dest))",5,,2094,1,,void
177258,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_COPYFILE,
                          req_wrap_async,
                          ""src"",
                          TRACE_STR_COPY(*src),
                          ""dest"",
                          TRACE_STR_COPY(*dest))",5,,2094,2,,void
177286,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_COPYFILE,
                          req_wrap_async,
                          ""src"",
                          TRACE_STR_COPY(*src),
                          ""dest"",
                          TRACE_STR_COPY(*dest))",5,,2094,2,,void
177367,BLOCK,-1,,"{  // copyFile(src, dest, flags, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(copyfile);
    SyncCall(env, args[4], &req_wrap_sync, ""copyfile"",
             uv_fs_copyfile, *src, *dest, flags);
    FS_SYNC_TRACE_END(copyfile);
  }",10,,2103,1,,void
177375,BLOCK,1,,<empty>,,,,9,,void
177391,BLOCK,-1,,<empty>,5,,2106,2,,void
177393,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(copyfile),5,,2106,1,,void
177411,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(copyfile),5,,2106,2,,void
177439,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(copyfile),5,,2106,2,,void
177485,BLOCK,1,,<empty>,,,,9,,void
177501,BLOCK,-1,,<empty>,5,,2109,2,,void
177503,BLOCK,-1,,FS_SYNC_TRACE_END(copyfile),5,,2109,1,,void
177521,BLOCK,-1,,FS_SYNC_TRACE_END(copyfile),5,,2109,2,,void
177549,BLOCK,-1,,FS_SYNC_TRACE_END(copyfile),5,,2109,2,,void
177582,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 4);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(Buffer::HasInstance(args[1]));
  Local<Object> buffer_obj = args[1].As<Object>();
  char* buffer_data = Buffer::Data(buffer_obj);
  size_t buffer_length = Buffer::Length(buffer_obj);

  CHECK(IsSafeJsInt(args[2]));
  const int64_t off_64 = args[2].As<Integer>()->Value();
  CHECK_GE(off_64, 0);
  CHECK_LE(static_cast<uint64_t>(off_64), buffer_length);
  const size_t off = static_cast<size_t>(off_64);

  CHECK(args[3]->IsInt32());
  const size_t len = static_cast<size_t>(args[3].As<Int32>()->Value());
  CHECK(Buffer::IsWithinBounds(off, len, buffer_length));
  CHECK_LE(len, buffer_length);
  CHECK_GE(off + len, off);

  const int64_t pos = GetOffset(args[4]);

  char* buf = buffer_data + off;
  uv_buf_t uvbuf = uv_buf_init(buf, len);

  FSReqBase* req_wrap_async = GetReqWrap(args, 5);
  if (r...",66,,2123,2,,void
177753,BLOCK,-1,,"{  // write(fd, buffer, off, len, pos, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""write"", UTF8, AfterInteger,
              uv_fs_write, fd, &uvbuf, 1, pos);
  }",34,,2155,2,,void
177761,BLOCK,1,,<empty>,,,,16,,void
177763,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)",5,,2156,1,,void
177781,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)",5,,2156,2,,void
177809,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)",5,,2156,2,,void
177866,BLOCK,-1,,"{  // write(fd, buffer, off, len, pos, undefined, ctx)
    CHECK_EQ(argc, 7);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(write);
    int bytesWritten = SyncCall(env, args[6], &req_wrap_sync, ""write"",
                                uv_fs_write, fd, &uvbuf, 1, pos);
    FS_SYNC_TRACE_END(write, ""bytesWritten"", bytesWritten);
    args.GetReturnValue().Set(bytesWritten);
  }",10,,2159,1,,void
177874,BLOCK,1,,<empty>,,,,9,,void
177890,BLOCK,-1,,<empty>,5,,2162,2,,void
177892,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(write),5,,2162,1,,void
177910,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(write),5,,2162,2,,void
177938,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(write),5,,2162,2,,void
177987,BLOCK,1,,<empty>,,,,10,,void
178003,BLOCK,-1,,<empty>,5,,2165,2,,void
178005,BLOCK,-1,,"FS_SYNC_TRACE_END(write, ""bytesWritten"", bytesWritten)",5,,2165,1,,void
178023,BLOCK,-1,,"FS_SYNC_TRACE_END(write, ""bytesWritten"", bytesWritten)",5,,2165,2,,void
178051,BLOCK,-1,,"FS_SYNC_TRACE_END(write, ""bytesWritten"", bytesWritten)",5,,2165,2,,void
178094,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(args[1]->IsArray());
  Local<Array> chunks = args[1].As<Array>();

  int64_t pos = GetOffset(args[2]);

  MaybeStackBuffer<uv_buf_t> iovs(chunks->Length());

  for (uint32_t i = 0; i < iovs.length(); i++) {
    Local<Value> chunk = chunks->Get(env->context(), i).ToLocalChecked();
    CHECK(Buffer::HasInstance(chunk));
    iovs[i] = uv_buf_init(Buffer::Data(chunk), Buffer::Length(chunk));
  }

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // writeBuffers(fd, chunks, pos, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""write"", UTF8, AfterInteger,
              uv_fs_write, fd, *iovs, iovs.length(), pos);
  } else {  // writeBuffers(fd, chunks, pos, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWra...",67,,2178,2,,void
178168,BLOCK,-1,,<empty>,3,,2194,1,,void
178181,BLOCK,4,,"{
    Local<Value> chunk = chunks->Get(env->context(), i).ToLocalChecked();
    CHECK(Buffer::HasInstance(chunk));
    iovs[i] = uv_buf_init(Buffer::Data(chunk), Buffer::Length(chunk));
  }",48,,2194,4,,void
178231,BLOCK,-1,,"{  // writeBuffers(fd, chunks, pos, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""write"", UTF8, AfterInteger,
              uv_fs_write, fd, *iovs, iovs.length(), pos);
  }",34,,2201,2,,void
178239,BLOCK,1,,<empty>,,,,16,,void
178241,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)",5,,2202,1,,void
178259,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)",5,,2202,2,,void
178287,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)",5,,2202,2,,void
178347,BLOCK,-1,,"{  // writeBuffers(fd, chunks, pos, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(write);
    int bytesWritten = SyncCall(env, args[4], &req_wrap_sync, ""write"",
                                uv_fs_write, fd, *iovs, iovs.length(), pos);
    FS_SYNC_TRACE_END(write, ""bytesWritten"", bytesWritten);
    args.GetReturnValue().Set(bytesWritten);
  }",10,,2205,1,,void
178355,BLOCK,1,,<empty>,,,,9,,void
178371,BLOCK,-1,,<empty>,5,,2208,2,,void
178373,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(write),5,,2208,1,,void
178391,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(write),5,,2208,2,,void
178419,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(write),5,,2208,2,,void
178471,BLOCK,1,,<empty>,,,,10,,void
178487,BLOCK,-1,,<empty>,5,,2211,2,,void
178489,BLOCK,-1,,"FS_SYNC_TRACE_END(write, ""bytesWritten"", bytesWritten)",5,,2211,1,,void
178507,BLOCK,-1,,"FS_SYNC_TRACE_END(write, ""bytesWritten"", bytesWritten)",5,,2211,2,,void
178535,BLOCK,-1,,"FS_SYNC_TRACE_END(write, ""bytesWritten"", bytesWritten)",5,,2211,2,,void
178578,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 4);
  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  const int64_t pos = GetOffset(args[2]);

  const auto enc = ParseEncoding(isolate, args[3], UTF8);

  Local<Value> value = args[1];
  char* buf = nullptr;
  size_t len;

  FSReqBase* req_wrap_async = GetReqWrap(args, 4);
  const bool is_async = req_wrap_async != nullptr;

  // Avoid copying the string when it is externalized but only when:
  // 1. The target encoding is compatible with the string's encoding, and
  // 2. The write is synchronous, otherwise the string might get neutered
  //    while the request is in flight, and
  // 3. For UCS2, when the host system is little-endian.  Big-endian systems
  //    need to call StringBytes::Write() to ensure proper byte swapping.
  // The const_casts are conceptually sound: memory is read but not written.
  if (!is...",66,,2225,2,,void
178673,BLOCK,-1,,"{
    auto string = value.As<String>();
    if ((enc == ASCII || enc == LATIN1) && string->IsExternalOneByte()) {
      auto ext = string->GetExternalOneByteStringResource();
      buf = const_cast<char*>(ext->data());
      len = ext->length();
    } else if (enc == UCS2 && IsLittleEndian() && string->IsExternalTwoByte()) {
      auto ext = string->GetExternalStringResource();
      buf = reinterpret_cast<char*>(const_cast<uint16_t*>(ext->data()));
      len = ext->length() * sizeof(*ext->data());
    }
  }",39,,2252,2,,void
178694,BLOCK,-1,,"{
      auto ext = string->GetExternalOneByteStringResource();
      buf = const_cast<char*>(ext->data());
      len = ext->length();
    }",73,,2254,2,,void
178717,BLOCK,-1,,<empty>,12,,2258,1,,void
178729,BLOCK,-1,,"{
      auto ext = string->GetExternalStringResource();
      buf = reinterpret_cast<char*>(const_cast<uint16_t*>(ext->data()));
      len = ext->length() * sizeof(*ext->data());
    }",80,,2258,2,,void
178762,BLOCK,-1,,"{  // write(fd, string, pos, enc, req)
    CHECK_NOT_NULL(req_wrap_async);
    if (!StringBytes::StorageSize(isolate, value, enc).To(&len)) return;
    FSReqBase::FSReqBuffer& stack_buffer =
        req_wrap_async->Init(""write"", len, enc);
    // StorageSize may return too large a char, so correct the actual length
    // by the write size
    len = StringBytes::Write(isolate, *stack_buffer, len, args[1], enc);
    stack_buffer.SetLengthAndZeroTerminate(len);
    uv_buf_t uvbuf = uv_buf_init(*stack_buffer, len);
    FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)
    int err = req_wrap_async->Dispatch(uv_fs_write,
                                       fd,
                                       &uvbuf,
                                       1,
                                       pos,
                                       AfterInteger);
    if (err < 0) {
      uv_fs_t* uv_req = req_wrap_async->req();
      uv_req->result = err;
      uv_req->path = nullptr;
      AfterInteger...",17,,2265,2,,void
178779,BLOCK,-1,,<empty>,66,,2267,2,,void
178824,BLOCK,1,,<empty>,,,,16,,void
178826,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)",5,,2275,1,,void
178844,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)",5,,2275,2,,void
178872,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)",5,,2275,2,,void
178933,BLOCK,-1,,"{
      uv_fs_t* uv_req = req_wrap_async->req();
      uv_req->result = err;
      uv_req->path = nullptr;
      AfterInteger(uv_req);  // after may delete req_wrap_async if there is
                             // an error
    }",18,,2282,2,,void
178954,BLOCK,-1,,"{
      req_wrap_async->SetReturnValue(args);
    }",12,,2288,1,,void
178961,BLOCK,-1,,"{  // write(fd, string, pos, enc, undefined, ctx)
    CHECK_EQ(argc, 6);
    FSReqWrapSync req_wrap_sync;
    FSReqBase::FSReqBuffer stack_buffer;
    if (buf == nullptr) {
      if (!StringBytes::StorageSize(isolate, value, enc).To(&len))
        return;
      stack_buffer.AllocateSufficientStorage(len + 1);
      // StorageSize may return too large a char, so correct the actual length
      // by the write size
      len = StringBytes::Write(isolate, *stack_buffer,
                               len, args[1], enc);
      stack_buffer.SetLengthAndZeroTerminate(len);
      buf = *stack_buffer;
    }
    uv_buf_t uvbuf = uv_buf_init(buf, len);
    FS_SYNC_TRACE_BEGIN(write);
    int bytesWritten = SyncCall(env, args[5], &req_wrap_sync, ""write"",
                                uv_fs_write, fd, &uvbuf, 1, pos);
    FS_SYNC_TRACE_END(write, ""bytesWritten"", bytesWritten);
    args.GetReturnValue().Set(bytesWritten);
  }",10,,2291,1,,void
178971,BLOCK,-1,,"{
      if (!StringBytes::StorageSize(isolate, value, enc).To(&len))
        return;
      stack_buffer.AllocateSufficientStorage(len + 1);
      // StorageSize may return too large a char, so correct the actual length
      // by the write size
      len = StringBytes::Write(isolate, *stack_buffer,
                               len, args[1], enc);
      stack_buffer.SetLengthAndZeroTerminate(len);
      buf = *stack_buffer;
    }",25,,2295,2,,void
178986,BLOCK,-1,,<empty>,9,,2297,2,,void
179027,BLOCK,1,,<empty>,,,,9,,void
179043,BLOCK,-1,,<empty>,5,,2307,2,,void
179045,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(write),5,,2307,1,,void
179063,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(write),5,,2307,2,,void
179091,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(write),5,,2307,2,,void
179140,BLOCK,1,,<empty>,,,,10,,void
179156,BLOCK,-1,,<empty>,5,,2310,2,,void
179158,BLOCK,-1,,"FS_SYNC_TRACE_END(write, ""bytesWritten"", bytesWritten)",5,,2310,1,,void
179176,BLOCK,-1,,"FS_SYNC_TRACE_END(write, ""bytesWritten"", bytesWritten)",5,,2310,2,,void
179204,BLOCK,-1,,"FS_SYNC_TRACE_END(write, ""bytesWritten"", bytesWritten)",5,,2310,2,,void
179247,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 5);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(Buffer::HasInstance(args[1]));
  Local<Object> buffer_obj = args[1].As<Object>();
  char* buffer_data = Buffer::Data(buffer_obj);
  size_t buffer_length = Buffer::Length(buffer_obj);

  CHECK(IsSafeJsInt(args[2]));
  const int64_t off_64 = args[2].As<Integer>()->Value();
  CHECK_GE(off_64, 0);
  CHECK_LT(static_cast<uint64_t>(off_64), buffer_length);
  const size_t off = static_cast<size_t>(off_64);

  CHECK(args[3]->IsInt32());
  const size_t len = static_cast<size_t>(args[3].As<Int32>()->Value());
  CHECK(Buffer::IsWithinBounds(off, len, buffer_length));

  CHECK(IsSafeJsInt(args[4]) || args[4]->IsBigInt());
  const int64_t pos = args[4]->IsNumber() ?
                      args[4].As<Integer>()->Value() :
                      args[4].As<BigInt>()->Int64Value();

  char* buf = buffer_data...",59,,2327,2,,void
179443,BLOCK,-1,,"{  // read(fd, buffer, offset, len, pos, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""read"", UTF8, AfterInteger,
              uv_fs_read, fd, &uvbuf, 1, pos);
  }",34,,2360,2,,void
179451,BLOCK,1,,<empty>,,,,16,,void
179453,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, req_wrap_async)",5,,2361,1,,void
179471,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, req_wrap_async)",5,,2361,2,,void
179499,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, req_wrap_async)",5,,2361,2,,void
179556,BLOCK,-1,,"{  // read(fd, buffer, offset, len, pos, undefined, ctx)
    CHECK_EQ(argc, 7);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(read);
    const int bytesRead = SyncCall(env, args[6], &req_wrap_sync, ""read"",
                                   uv_fs_read, fd, &uvbuf, 1, pos);
    FS_SYNC_TRACE_END(read, ""bytesRead"", bytesRead);
    args.GetReturnValue().Set(bytesRead);
  }",10,,2364,1,,void
179564,BLOCK,1,,<empty>,,,,9,,void
179580,BLOCK,-1,,<empty>,5,,2367,2,,void
179582,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(read),5,,2367,1,,void
179600,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(read),5,,2367,2,,void
179628,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(read),5,,2367,2,,void
179677,BLOCK,1,,<empty>,,,,10,,void
179693,BLOCK,-1,,<empty>,5,,2370,2,,void
179695,BLOCK,-1,,"FS_SYNC_TRACE_END(read, ""bytesRead"", bytesRead)",5,,2370,1,,void
179713,BLOCK,-1,,"FS_SYNC_TRACE_END(read, ""bytesRead"", bytesRead)",5,,2370,2,,void
179741,BLOCK,-1,,"FS_SYNC_TRACE_END(read, ""bytesRead"", bytesRead)",5,,2370,2,,void
179784,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(args[1]->IsArray());
  Local<Array> buffers = args[1].As<Array>();

  int64_t pos = GetOffset(args[2]);  // -1 if not a valid JS int

  MaybeStackBuffer<uv_buf_t> iovs(buffers->Length());

  // Init uv buffers from ArrayBufferViews
  for (uint32_t i = 0; i < iovs.length(); i++) {
    Local<Value> buffer = buffers->Get(env->context(), i).ToLocalChecked();
    CHECK(Buffer::HasInstance(buffer));
    iovs[i] = uv_buf_init(Buffer::Data(buffer), Buffer::Length(buffer));
  }

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // readBuffers(fd, buffers, pos, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""read"", UTF8, AfterInteger,
              uv_fs_read, fd, *iovs, iovs.length(), pos);
  } else {  // readB...",66,,2383,2,,void
179858,BLOCK,-1,,<empty>,3,,2400,1,,void
179871,BLOCK,4,,"{
    Local<Value> buffer = buffers->Get(env->context(), i).ToLocalChecked();
    CHECK(Buffer::HasInstance(buffer));
    iovs[i] = uv_buf_init(Buffer::Data(buffer), Buffer::Length(buffer));
  }",48,,2400,4,,void
179921,BLOCK,-1,,"{  // readBuffers(fd, buffers, pos, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""read"", UTF8, AfterInteger,
              uv_fs_read, fd, *iovs, iovs.length(), pos);
  }",34,,2407,2,,void
179929,BLOCK,1,,<empty>,,,,16,,void
179931,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, req_wrap_async)",5,,2408,1,,void
179949,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, req_wrap_async)",5,,2408,2,,void
179977,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, req_wrap_async)",5,,2408,2,,void
180037,BLOCK,-1,,"{  // readBuffers(fd, buffers, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(read);
    int bytesRead = SyncCall(env, /* ctx */ args[4], &req_wrap_sync, ""read"",
                             uv_fs_read, fd, *iovs, iovs.length(), pos);
    FS_SYNC_TRACE_END(read, ""bytesRead"", bytesRead);
    args.GetReturnValue().Set(bytesRead);
  }",10,,2411,1,,void
180045,BLOCK,1,,<empty>,,,,9,,void
180061,BLOCK,-1,,<empty>,5,,2414,2,,void
180063,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(read),5,,2414,1,,void
180081,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(read),5,,2414,2,,void
180109,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(read),5,,2414,2,,void
180161,BLOCK,1,,<empty>,,,,10,,void
180177,BLOCK,-1,,<empty>,5,,2417,2,,void
180179,BLOCK,-1,,"FS_SYNC_TRACE_END(read, ""bytesRead"", bytesRead)",5,,2417,1,,void
180197,BLOCK,-1,,"FS_SYNC_TRACE_END(read, ""bytesRead"", bytesRead)",5,,2417,2,,void
180225,BLOCK,-1,,"FS_SYNC_TRACE_END(read, ""bytesRead"", bytesRead)",5,,2417,2,,void
180268,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  CHECK(args[1]->IsInt32());
  int mode = args[1].As<Int32>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // chmod(path, mode, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHMOD, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""chmod"", UTF8, AfterNoArgs,
              uv_fs_chmod, *path, mode);
  } else {  // chmod(path, mode, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(chmod);
    SyncCall(env, args[3], &req_wrap_sync, ""chmod"",
             uv_fs_chmod, *path, mode);
    FS_SYNC_TRACE_END(chmod);
  }
}",60,,2426,2,,void
180339,BLOCK,-1,,"{  // chmod(path, mode, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHMOD, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""chmod"", UTF8, AfterNoArgs,
              uv_fs_chmod, *path, mode);
  }",34,,2441,2,,void
180348,BLOCK,1,,<empty>,,,,18,,void
180350,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHMOD, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2442,1,,void
180368,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHMOD, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2442,2,,void
180396,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHMOD, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2442,2,,void
180460,BLOCK,-1,,"{  // chmod(path, mode, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(chmod);
    SyncCall(env, args[3], &req_wrap_sync, ""chmod"",
             uv_fs_chmod, *path, mode);
    FS_SYNC_TRACE_END(chmod);
  }",10,,2446,1,,void
180468,BLOCK,1,,<empty>,,,,9,,void
180484,BLOCK,-1,,<empty>,5,,2449,2,,void
180486,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(chmod),5,,2449,1,,void
180504,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(chmod),5,,2449,2,,void
180532,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(chmod),5,,2449,2,,void
180576,BLOCK,1,,<empty>,,,,9,,void
180592,BLOCK,-1,,<empty>,5,,2452,2,,void
180594,BLOCK,-1,,FS_SYNC_TRACE_END(chmod),5,,2452,1,,void
180612,BLOCK,-1,,FS_SYNC_TRACE_END(chmod),5,,2452,2,,void
180640,BLOCK,-1,,FS_SYNC_TRACE_END(chmod),5,,2452,2,,void
180673,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(args[1]->IsInt32());
  const int mode = args[1].As<Int32>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // fchmod(fd, mode, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHMOD, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fchmod"", UTF8, AfterNoArgs,
              uv_fs_fchmod, fd, mode);
  } else {  // fchmod(fd, mode, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fchmod);
    SyncCall(env, args[3], &req_wrap_sync, ""fchmod"",
             uv_fs_fchmod, fd, mode);
    FS_SYNC_TRACE_END(fchmod);
  }
}",61,,2460,2,,void
180740,BLOCK,-1,,"{  // fchmod(fd, mode, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHMOD, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fchmod"", UTF8, AfterNoArgs,
              uv_fs_fchmod, fd, mode);
  }",34,,2473,2,,void
180748,BLOCK,1,,<empty>,,,,16,,void
180750,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHMOD, req_wrap_async)",5,,2474,1,,void
180768,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHMOD, req_wrap_async)",5,,2474,2,,void
180796,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHMOD, req_wrap_async)",5,,2474,2,,void
180850,BLOCK,-1,,"{  // fchmod(fd, mode, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fchmod);
    SyncCall(env, args[3], &req_wrap_sync, ""fchmod"",
             uv_fs_fchmod, fd, mode);
    FS_SYNC_TRACE_END(fchmod);
  }",10,,2477,1,,void
180858,BLOCK,1,,<empty>,,,,9,,void
180874,BLOCK,-1,,<empty>,5,,2480,2,,void
180876,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fchmod),5,,2480,1,,void
180894,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fchmod),5,,2480,2,,void
180922,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fchmod),5,,2480,2,,void
180965,BLOCK,1,,<empty>,,,,9,,void
180981,BLOCK,-1,,<empty>,5,,2483,2,,void
180983,BLOCK,-1,,FS_SYNC_TRACE_END(fchmod),5,,2483,1,,void
181001,BLOCK,-1,,FS_SYNC_TRACE_END(fchmod),5,,2483,2,,void
181029,BLOCK,-1,,FS_SYNC_TRACE_END(fchmod),5,,2483,2,,void
181062,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  CHECK(IsSafeJsInt(args[1]));
  const uv_uid_t uid = static_cast<uv_uid_t>(args[1].As<Integer>()->Value());

  CHECK(IsSafeJsInt(args[2]));
  const uv_gid_t gid = static_cast<uv_gid_t>(args[2].As<Integer>()->Value());

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // chown(path, uid, gid, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""chown"", UTF8, AfterNoArgs,
              uv_fs_chown, *path, uid, gid);
  } else {  // chown(path, uid, gid, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(chown);
    SyncCal...",60,,2491,2,,void
181152,BLOCK,-1,,"{  // chown(path, uid, gid, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""chown"", UTF8, AfterNoArgs,
              uv_fs_chown, *path, uid, gid);
  }",34,,2509,2,,void
181161,BLOCK,1,,<empty>,,,,18,,void
181163,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2510,1,,void
181181,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2510,2,,void
181209,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2510,2,,void
181274,BLOCK,-1,,"{  // chown(path, uid, gid, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(chown);
    SyncCall(env, args[4], &req_wrap_sync, ""chown"",
             uv_fs_chown, *path, uid, gid);
    FS_SYNC_TRACE_END(chown);
  }",10,,2514,1,,void
181282,BLOCK,1,,<empty>,,,,9,,void
181298,BLOCK,-1,,<empty>,5,,2517,2,,void
181300,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(chown),5,,2517,1,,void
181318,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(chown),5,,2517,2,,void
181346,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(chown),5,,2517,2,,void
181391,BLOCK,1,,<empty>,,,,9,,void
181407,BLOCK,-1,,<empty>,5,,2520,2,,void
181409,BLOCK,-1,,FS_SYNC_TRACE_END(chown),5,,2520,1,,void
181427,BLOCK,-1,,FS_SYNC_TRACE_END(chown),5,,2520,2,,void
181455,BLOCK,-1,,FS_SYNC_TRACE_END(chown),5,,2520,2,,void
181488,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(IsSafeJsInt(args[1]));
  const uv_uid_t uid = static_cast<uv_uid_t>(args[1].As<Integer>()->Value());

  CHECK(IsSafeJsInt(args[2]));
  const uv_gid_t gid = static_cast<uv_gid_t>(args[2].As<Integer>()->Value());

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // fchown(fd, uid, gid, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHOWN, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fchown"", UTF8, AfterNoArgs,
              uv_fs_fchown, fd, uid, gid);
  } else {  // fchown(fd, uid, gid, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fchown);
    SyncCall(env, args[4], &req_wrap_sync, ""fchown"",
             uv_fs_fchown, fd, uid, gid);
    FS_SYNC_TRACE_END(fchown);
  }
}",61,,2528,2,,void
181574,BLOCK,-1,,"{  // fchown(fd, uid, gid, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHOWN, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fchown"", UTF8, AfterNoArgs,
              uv_fs_fchown, fd, uid, gid);
  }",34,,2544,2,,void
181582,BLOCK,1,,<empty>,,,,16,,void
181584,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHOWN, req_wrap_async)",5,,2545,1,,void
181602,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHOWN, req_wrap_async)",5,,2545,2,,void
181630,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHOWN, req_wrap_async)",5,,2545,2,,void
181685,BLOCK,-1,,"{  // fchown(fd, uid, gid, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fchown);
    SyncCall(env, args[4], &req_wrap_sync, ""fchown"",
             uv_fs_fchown, fd, uid, gid);
    FS_SYNC_TRACE_END(fchown);
  }",10,,2548,1,,void
181693,BLOCK,1,,<empty>,,,,9,,void
181709,BLOCK,-1,,<empty>,5,,2551,2,,void
181711,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fchown),5,,2551,1,,void
181729,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fchown),5,,2551,2,,void
181757,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fchown),5,,2551,2,,void
181801,BLOCK,1,,<empty>,,,,9,,void
181817,BLOCK,-1,,<empty>,5,,2554,2,,void
181819,BLOCK,-1,,FS_SYNC_TRACE_END(fchown),5,,2554,1,,void
181837,BLOCK,-1,,FS_SYNC_TRACE_END(fchown),5,,2554,2,,void
181865,BLOCK,-1,,FS_SYNC_TRACE_END(fchown),5,,2554,2,,void
181898,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  CHECK(IsSafeJsInt(args[1]));
  const uv_uid_t uid = static_cast<uv_uid_t>(args[1].As<Integer>()->Value());

  CHECK(IsSafeJsInt(args[2]));
  const uv_gid_t gid = static_cast<uv_gid_t>(args[2].As<Integer>()->Value());

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // lchown(path, uid, gid, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LCHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""lchown"", UTF8, AfterNoArgs,
              uv_fs_lchown, *path, uid, gid);
  } else {  // lchown(path, uid, gid, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(lchown);
    S...",61,,2559,2,,void
181988,BLOCK,-1,,"{  // lchown(path, uid, gid, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LCHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""lchown"", UTF8, AfterNoArgs,
              uv_fs_lchown, *path, uid, gid);
  }",34,,2577,2,,void
181997,BLOCK,1,,<empty>,,,,18,,void
181999,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LCHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2578,1,,void
182017,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LCHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2578,2,,void
182045,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LCHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2578,2,,void
182110,BLOCK,-1,,"{  // lchown(path, uid, gid, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(lchown);
    SyncCall(env, args[4], &req_wrap_sync, ""lchown"",
             uv_fs_lchown, *path, uid, gid);
    FS_SYNC_TRACE_END(lchown);
  }",10,,2582,1,,void
182118,BLOCK,1,,<empty>,,,,9,,void
182134,BLOCK,-1,,<empty>,5,,2585,2,,void
182136,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(lchown),5,,2585,1,,void
182154,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(lchown),5,,2585,2,,void
182182,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(lchown),5,,2585,2,,void
182227,BLOCK,1,,<empty>,,,,9,,void
182243,BLOCK,-1,,<empty>,5,,2588,2,,void
182245,BLOCK,-1,,FS_SYNC_TRACE_END(lchown),5,,2588,1,,void
182263,BLOCK,-1,,FS_SYNC_TRACE_END(lchown),5,,2588,2,,void
182291,BLOCK,-1,,FS_SYNC_TRACE_END(lchown),5,,2588,2,,void
182324,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  CHECK(args[1]->IsNumber());
  const double atime = args[1].As<Number>()->Value();

  CHECK(args[2]->IsNumber());
  const double mtime = args[2].As<Number>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // utimes(path, atime, mtime, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""utime"", UTF8, AfterNoArgs,
              uv_fs_utime, *path, atime, mtime);
  } else {  // utimes(path, atime, mtime, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(utimes);
    SyncCall(env, args[4], &req_wrap_sync, ""ut...",61,,2593,2,,void
182414,BLOCK,-1,,"{  // utimes(path, atime, mtime, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""utime"", UTF8, AfterNoArgs,
              uv_fs_utime, *path, atime, mtime);
  }",34,,2611,2,,void
182423,BLOCK,1,,<empty>,,,,18,,void
182425,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2612,1,,void
182443,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2612,2,,void
182471,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2612,2,,void
182536,BLOCK,-1,,"{  // utimes(path, atime, mtime, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(utimes);
    SyncCall(env, args[4], &req_wrap_sync, ""utime"",
             uv_fs_utime, *path, atime, mtime);
    FS_SYNC_TRACE_END(utimes);
  }",10,,2616,1,,void
182544,BLOCK,1,,<empty>,,,,9,,void
182560,BLOCK,-1,,<empty>,5,,2619,2,,void
182562,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(utimes),5,,2619,1,,void
182580,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(utimes),5,,2619,2,,void
182608,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(utimes),5,,2619,2,,void
182653,BLOCK,1,,<empty>,,,,9,,void
182669,BLOCK,-1,,<empty>,5,,2622,2,,void
182671,BLOCK,-1,,FS_SYNC_TRACE_END(utimes),5,,2622,1,,void
182689,BLOCK,-1,,FS_SYNC_TRACE_END(utimes),5,,2622,2,,void
182717,BLOCK,-1,,FS_SYNC_TRACE_END(utimes),5,,2622,2,,void
182750,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(args[1]->IsNumber());
  const double atime = args[1].As<Number>()->Value();

  CHECK(args[2]->IsNumber());
  const double mtime = args[2].As<Number>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // futimes(fd, atime, mtime, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FUTIME, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""futime"", UTF8, AfterNoArgs,
              uv_fs_futime, fd, atime, mtime);
  } else {  // futimes(fd, atime, mtime, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(futimes);
    SyncCall(env, args[4], &req_wrap_sync, ""futime"",
             uv_fs_futime, fd, atime, mtime);
    FS_SYNC_TRACE_END(futimes);
  }
}",62,,2626,2,,void
182836,BLOCK,-1,,"{  // futimes(fd, atime, mtime, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FUTIME, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""futime"", UTF8, AfterNoArgs,
              uv_fs_futime, fd, atime, mtime);
  }",34,,2642,2,,void
182844,BLOCK,1,,<empty>,,,,16,,void
182846,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FUTIME, req_wrap_async)",5,,2643,1,,void
182864,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FUTIME, req_wrap_async)",5,,2643,2,,void
182892,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FUTIME, req_wrap_async)",5,,2643,2,,void
182947,BLOCK,-1,,"{  // futimes(fd, atime, mtime, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(futimes);
    SyncCall(env, args[4], &req_wrap_sync, ""futime"",
             uv_fs_futime, fd, atime, mtime);
    FS_SYNC_TRACE_END(futimes);
  }",10,,2646,1,,void
182955,BLOCK,1,,<empty>,,,,9,,void
182971,BLOCK,-1,,<empty>,5,,2649,2,,void
182973,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(futimes),5,,2649,1,,void
182991,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(futimes),5,,2649,2,,void
183019,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(futimes),5,,2649,2,,void
183063,BLOCK,1,,<empty>,,,,9,,void
183079,BLOCK,-1,,<empty>,5,,2652,2,,void
183081,BLOCK,-1,,FS_SYNC_TRACE_END(futimes),5,,2652,1,,void
183099,BLOCK,-1,,FS_SYNC_TRACE_END(futimes),5,,2652,2,,void
183127,BLOCK,-1,,FS_SYNC_TRACE_END(futimes),5,,2652,2,,void
183160,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  CHECK(args[1]->IsNumber());
  const double atime = args[1].As<Number>()->Value();

  CHECK(args[2]->IsNumber());
  const double mtime = args[2].As<Number>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // lutimes(path, atime, mtime, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LUTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""lutime"", UTF8, AfterNoArgs,
              uv_fs_lutime, *path, atime, mtime);
  } else {  // lutimes(path, atime, mtime, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(lutimes);
    SyncCall(env, args[4], &req_wrap_syn...",62,,2656,2,,void
183250,BLOCK,-1,,"{  // lutimes(path, atime, mtime, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LUTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""lutime"", UTF8, AfterNoArgs,
              uv_fs_lutime, *path, atime, mtime);
  }",34,,2674,2,,void
183259,BLOCK,1,,<empty>,,,,18,,void
183261,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LUTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2675,1,,void
183279,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LUTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2675,2,,void
183307,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LUTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2675,2,,void
183372,BLOCK,-1,,"{  // lutimes(path, atime, mtime, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(lutimes);
    SyncCall(env, args[4], &req_wrap_sync, ""lutime"",
             uv_fs_lutime, *path, atime, mtime);
    FS_SYNC_TRACE_END(lutimes);
  }",10,,2679,1,,void
183380,BLOCK,1,,<empty>,,,,9,,void
183396,BLOCK,-1,,<empty>,5,,2682,2,,void
183398,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(lutimes),5,,2682,1,,void
183416,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(lutimes),5,,2682,2,,void
183444,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(lutimes),5,,2682,2,,void
183489,BLOCK,1,,<empty>,,,,9,,void
183505,BLOCK,-1,,<empty>,5,,2685,2,,void
183507,BLOCK,-1,,FS_SYNC_TRACE_END(lutimes),5,,2685,1,,void
183525,BLOCK,-1,,FS_SYNC_TRACE_END(lutimes),5,,2685,2,,void
183553,BLOCK,-1,,FS_SYNC_TRACE_END(lutimes),5,,2685,2,,void
183586,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  BufferValue tmpl(isolate, args[0]);
  CHECK_NOT_NULL(*tmpl);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, tmpl.ToStringView());

  const enum encoding encoding = ParseEncoding(isolate, args[1], UTF8);

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // mkdtemp(tmpl, encoding, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_MKDTEMP, req_wrap_async, ""path"", TRACE_STR_COPY(*tmpl))
    AsyncCall(env, req_wrap_async, args, ""mkdtemp"", encoding, AfterStringPath,
              uv_fs_mkdtemp, *tmpl);
  } else {  // mkdtemp(tmpl, encoding, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(mkdtemp);
    SyncCall(env, args[3], &req_wrap_sync, ""mkdtemp"",
             uv_fs_mkdtemp, *tmpl);
    FS_SYNC_TRACE_END(mkdtem...",62,,2689,2,,void
183651,BLOCK,-1,,"{  // mkdtemp(tmpl, encoding, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_MKDTEMP, req_wrap_async, ""path"", TRACE_STR_COPY(*tmpl))
    AsyncCall(env, req_wrap_async, args, ""mkdtemp"", encoding, AfterStringPath,
              uv_fs_mkdtemp, *tmpl);
  }",34,,2704,2,,void
183660,BLOCK,1,,<empty>,,,,18,,void
183662,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_MKDTEMP, req_wrap_async, ""path"", TRACE_STR_COPY(*tmpl))",5,,2705,1,,void
183680,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_MKDTEMP, req_wrap_async, ""path"", TRACE_STR_COPY(*tmpl))",5,,2705,2,,void
183708,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_MKDTEMP, req_wrap_async, ""path"", TRACE_STR_COPY(*tmpl))",5,,2705,2,,void
183771,BLOCK,-1,,"{  // mkdtemp(tmpl, encoding, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(mkdtemp);
    SyncCall(env, args[3], &req_wrap_sync, ""mkdtemp"",
             uv_fs_mkdtemp, *tmpl);
    FS_SYNC_TRACE_END(mkdtemp);
    const char* path = req_wrap_sync.req.path;

    Local<Value> error;
    MaybeLocal<Value> rc =
        StringBytes::Encode(isolate, path, encoding, &error);
    if (rc.IsEmpty()) {
      Local<Object> ctx = args[3].As<Object>();
      ctx->Set(env->context(), env->error_string(), error).Check();
      return;
    }
    args.GetReturnValue().Set(rc.ToLocalChecked());
  }",10,,2709,1,,void
183779,BLOCK,1,,<empty>,,,,9,,void
183795,BLOCK,-1,,<empty>,5,,2712,2,,void
183797,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(mkdtemp),5,,2712,1,,void
183815,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(mkdtemp),5,,2712,2,,void
183843,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(mkdtemp),5,,2712,2,,void
183886,BLOCK,1,,<empty>,,,,9,,void
183902,BLOCK,-1,,<empty>,5,,2715,2,,void
183904,BLOCK,-1,,FS_SYNC_TRACE_END(mkdtemp),5,,2715,1,,void
183922,BLOCK,-1,,FS_SYNC_TRACE_END(mkdtemp),5,,2715,2,,void
183950,BLOCK,-1,,FS_SYNC_TRACE_END(mkdtemp),5,,2715,2,,void
184012,BLOCK,-1,,"{
      Local<Object> ctx = args[3].As<Object>();
      ctx->Set(env->context(), env->error_string(), error).Check();
      return;
    }",23,,2721,2,,void
184057,BLOCK,-1,,"{
  tracker->TrackField(""stats_field_array"", stats_field_array);
  tracker->TrackField(""stats_field_bigint_array"", stats_field_bigint_array);
  tracker->TrackField(""statfs_field_array"", statfs_field_array);
  tracker->TrackField(""statfs_field_bigint_array"", statfs_field_bigint_array);
  tracker->TrackField(""file_handle_read_wrap_freelist"",
                      file_handle_read_wrap_freelist);
}",60,,2730,2,,void
184094,BLOCK,-1,,"{
  Isolate* isolate = realm->isolate();
  Local<Context> context = realm->context();

  if (info == nullptr) {
    wrap->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""statValues""),
              stats_field_array.GetJSArray())
        .Check();

    wrap->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""bigintStatValues""),
              stats_field_bigint_array.GetJSArray())
        .Check();

    wrap->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""statFsValues""),
              statfs_field_array.GetJSArray())
        .Check();

    wrap->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""bigintStatFsValues""),
              statfs_field_bigint_array.GetJSArray())
        .Check();
  } else {
    stats_field_array.Deserialize(realm->context());
    stats_field_bigint_array.Deserialize(realm->context());
    statfs_field_array.Deserialize(realm->context());
    statfs_field_bigint_array.Deserialize(realm->context());
  }
  stats_field_array...",61,,2755,4,,void
184116,BLOCK,-1,,"{
    wrap->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""statValues""),
              stats_field_array.GetJSArray())
        .Check();

    wrap->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""bigintStatValues""),
              stats_field_bigint_array.GetJSArray())
        .Check();

    wrap->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""statFsValues""),
              statfs_field_array.GetJSArray())
        .Check();

    wrap->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""bigintStatFsValues""),
              statfs_field_bigint_array.GetJSArray())
        .Check();
  }",24,,2759,2,,void
184178,BLOCK,-1,,"{
    stats_field_array.Deserialize(realm->context());
    stats_field_bigint_array.Deserialize(realm->context());
    statfs_field_array.Deserialize(realm->context());
    statfs_field_bigint_array.Deserialize(realm->context());
  }",10,,2779,1,,void
184234,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  HandleScope scope(context->GetIsolate());
  Realm* realm = Realm::GetCurrent(context);
  InternalFieldInfo* casted_info = static_cast<InternalFieldInfo*>(info);
  BindingData* binding =
      realm->AddBindingData<BindingData>(context, holder, casted_info);
  CHECK_NOT_NULL(binding);
}",60,,2794,5,,void
184281,BLOCK,-1,,"{
  CHECK(file_handle_read_wrap_freelist.empty());
  DCHECK_NULL(internal_field_info_);
  internal_field_info_ = InternalFieldInfoBase::New<InternalFieldInfo>(type());
  internal_field_info_->stats_field_array =
      stats_field_array.Serialize(context, creator);
  internal_field_info_->stats_field_bigint_array =
      stats_field_bigint_array.Serialize(context, creator);
  internal_field_info_->statfs_field_array =
      statfs_field_array.Serialize(context, creator);
  internal_field_info_->statfs_field_bigint_array =
      statfs_field_bigint_array.Serialize(context, creator);
  // Return true because we need to maintain the reference to the binding from
  // JS land.
  return true;
}",73,,2805,3,,void
184343,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info = internal_field_info_;
  internal_field_info_ = nullptr;
  return info;
}",58,,2822,2,,void
184363,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();
  Local<ObjectTemplate> target = ctor->InstanceTemplate();

  SetMethod(isolate, target, ""access"", Access);
  SetMethod(isolate, target, ""close"", Close);
  SetMethod(isolate, target, ""open"", Open);
  SetMethod(isolate, target, ""openFileHandle"", OpenFileHandle);
  SetMethod(isolate, target, ""read"", Read);
  SetMethod(isolate, target, ""readBuffers"", ReadBuffers);
  SetMethod(isolate, target, ""fdatasync"", Fdatasync);
  SetMethod(isolate, target, ""fsync"", Fsync);
  SetMethod(isolate, target, ""rename"", Rename);
  SetMethod(isolate, target, ""ftruncate"", FTruncate);
  SetMethod(isolate, target, ""rmdir"", RMDir);
  SetMethod(isolate, target, ""mkdir"", MKDir);
  SetMethod(isolate, target, ""readdir"", ReadDir);
  SetMethod(isolate, target, ""internalModuleReadJSON"", InternalModuleReadJSON);
  SetMethod(isolate, target, ""internalModuleStat"", InternalModuleStat);
  SetMethod(isolate, target, ""stat"", Stat);
  SetMethod(isolate, target, ""lstat"", LStat);...",70,,2830,3,,void
184863,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(context);
  realm->AddBindingData<BindingData>(context, target);
}",52,,2937,5,,void
184885,BLOCK,-1,,"{
  return binding_data_.get();
}",40,,2942,1,,void
184895,BLOCK,-1,,"{
  registry->Register(Access);
  StatWatcher::RegisterExternalReferences(registry);

  registry->Register(Close);
  registry->Register(Open);
  registry->Register(OpenFileHandle);
  registry->Register(Read);
  registry->Register(ReadBuffers);
  registry->Register(Fdatasync);
  registry->Register(Fsync);
  registry->Register(Rename);
  registry->Register(FTruncate);
  registry->Register(RMDir);
  registry->Register(MKDir);
  registry->Register(ReadDir);
  registry->Register(InternalModuleReadJSON);
  registry->Register(InternalModuleStat);
  registry->Register(Stat);
  registry->Register(LStat);
  registry->Register(FStat);
  registry->Register(StatFs);
  registry->Register(Link);
  registry->Register(Symlink);
  registry->Register(ReadLink);
  registry->Register(Unlink);
  registry->Register(WriteBuffer);
  registry->Register(WriteBuffers);
  registry->Register(WriteString);
  registry->Register(RealPath);
  registry->Register(CopyFile);

  registry->Register(Chmod);
  registry->Re...",70,,2946,2,,void
185134,BLOCK,-1,,<empty>,1,,1,1,,ANY
185138,BLOCK,-1,,"{
    if (HasHttp2Observer(env))
      entry->Notify(env);
  }",68,,646,2,,void
185142,BLOCK,-1,,<empty>,7,,648,2,,void
185154,BLOCK,-1,,"{
    if (HasHttp2Observer(env))
      entry->Notify(env);
  }",68,,666,2,,void
185158,BLOCK,-1,,<empty>,7,,668,2,,void
185169,BLOCK,-1,,"{
          ping->Done(false);
        }",52,,718,2,,void
185181,BLOCK,-1,,"{
    headers_v[i * 2] = header.GetName(this).ToLocalChecked();
    headers_v[i * 2 + 1] = header.GetValue(this).ToLocalChecked();
    if (header.flags() & NGHTTP2_NV_FLAG_NO_INDEX)
      sensitive_v[sensitive_count++] = headers_v[i * 2];
  }",68,,1352,3,,void
185219,BLOCK,-1,,<empty>,7,,1356,2,,void
185238,BLOCK,-1,,"{
      if (!session_ || !is_write_scheduled()) {
        // This can happen e.g. when a stream was reset before this turn
        // of the event loop, in which case SendPendingData() is called early,
        // or the session was destroyed in the meantime.
        return;
      }

      // Sending data may call arbitrary JS code, so keep track of
      // async context.
      if (env->can_call_into_js()) {
        HandleScope handle_scope(env->isolate());
        InternalCallbackScope callback_scope(this);
        SendPendingData();
      }
    }",62,,1628,2,,void
185245,BLOCK,-1,,"{
        // This can happen e.g. when a stream was reset before this turn
        // of the event loop, in which case SendPendingData() is called early,
        // or the session was destroyed in the meantime.
        return;
      }",47,,1629,2,,void
185252,BLOCK,-1,,"{
        HandleScope handle_scope(env->isolate());
        InternalCallbackScope callback_scope(this);
        SendPendingData();
      }",36,,1638,2,,void
185268,BLOCK,-1,,"{
      // Free any remaining outgoing data chunks here. This should be done
      // here because it's possible for destroy to have been called while
      // we still have queued outbound writes.
      while (!queue_.empty()) {
        NgHttp2StreamWrite& head = queue_.front();
        if (head.req_wrap)
          WriteWrap::FromObject(head.req_wrap)->Done(UV_ECANCELED);
        queue_.pop();
      }

      // We can destroy the stream now if there are no writes for it
      // already on the socket. Otherwise, we'll wait for the garbage collector
      // to take care of cleaning up.
      if (session() == nullptr ||
          !session()->HasWritesOnSocketForStream(this)) {
        // Delete once strong_ref goes out of scope.
        Detach();
      }
    }",27,,2141,2,,void
185275,BLOCK,-1,,"{
        NgHttp2StreamWrite& head = queue_.front();
        if (head.req_wrap)
          WriteWrap::FromObject(head.req_wrap)->Done(UV_ECANCELED);
        queue_.pop();
      }",31,,2145,2,,void
185287,BLOCK,-1,,<empty>,11,,2148,2,,void
185314,BLOCK,-1,,"{
        // Delete once strong_ref goes out of scope.
        Detach();
      }",57,,2156,2,,void
185321,BLOCK,-1,,"{
    return code == NGHTTP2_CANCEL;
  }",51,,2275,2,,void
185370,BLOCK,-1,,<empty>,1,,1,1,,ANY
185380,BLOCK,-1,,"{
  AliasedUint32Array& observers = env->performance_state()->observers;
  return observers[performance::NODE_PERFORMANCE_ENTRY_TYPE_HTTP2] != 0;
}",41,,54,2,,void
185410,BLOCK,-1,,<empty>,77,,79,2,,void
185415,BLOCK,-1,,"{
  if (!session_) return;

  // If there is another scope further below on the stack, or
  // a write is already scheduled, there's nothing to do.
  if (session_->is_in_scope() || session_->is_write_scheduled()) {
    session_.reset();
    return;
  }
  session_->set_in_scope();
}",67,,81,2,,void
185419,BLOCK,-1,,<empty>,18,,82,2,,void
185431,BLOCK,-1,,"{
    session_.reset();
    return;
  }",66,,86,2,,void
185444,BLOCK,-1,,"{
  if (!session_) return;
  session_->set_in_scope(false);
  if (!session_->is_write_scheduled())
    session_->MaybeScheduleWrite();
}",27,,93,1,,void
185448,BLOCK,-1,,<empty>,18,,94,2,,void
185461,BLOCK,-1,,<empty>,5,,97,2,,void
185471,BLOCK,-1,,"{
  nghttp2_option* option;
  CHECK_EQ(nghttp2_option_new(&option), 0);
  CHECK_NOT_NULL(option);
  options_.reset(option);

  // Make sure closed connections aren't kept around, taking up memory.
  // Note that this breaks the priority tree, which we don't use.
  nghttp2_option_set_no_closed_streams(option, 1);

  // We manually handle flow control within a session in order to
  // implement backpressure -- that is, we only send WINDOW_UPDATE
  // frames to the remote peer as data is actually consumed by user
  // code. This ensures that the flow of data over the connection
  // does not move too quickly and limits the amount of data we
  // are required to buffer.
  nghttp2_option_set_no_auto_window_update(option, 1);

  // Enable built in support for receiving ALTSVC and ORIGIN frames (but
  // only on client side sessions
  if (type == NGHTTP2_SESSION_CLIENT) {
    nghttp2_option_set_builtin_recv_extension_type(option, NGHTTP2_ALTSVC);
    nghttp2_option_set_builtin_recv_extensi...",71,,104,3,,void
185495,BLOCK,-1,,"{
    nghttp2_option_set_builtin_recv_extension_type(option, NGHTTP2_ALTSVC);
    nghttp2_option_set_builtin_recv_extension_type(option, NGHTTP2_ORIGIN);
  }",39,,124,2,,void
185520,BLOCK,-1,,"{
    nghttp2_option_set_max_deflate_dynamic_table_size(
        option,
        buffer[IDX_OPTIONS_MAX_DEFLATE_DYNAMIC_TABLE_SIZE]);
  }",66,,132,2,,void
185532,BLOCK,-1,,"{
    nghttp2_option_set_max_reserved_remote_streams(
        option,
        buffer[IDX_OPTIONS_MAX_RESERVED_REMOTE_STREAMS]);
  }",63,,138,2,,void
185544,BLOCK,-1,,"{
    nghttp2_option_set_max_send_header_block_length(
        option,
        buffer[IDX_OPTIONS_MAX_SEND_HEADER_BLOCK_LENGTH]);
  }",64,,144,2,,void
185559,BLOCK,-1,,"{
    nghttp2_option_set_peer_max_concurrent_streams(
        option,
        buffer[IDX_OPTIONS_PEER_MAX_CONCURRENT_STREAMS]);
  }",63,,152,2,,void
185571,BLOCK,-1,,"{
    PaddingStrategy strategy =
        static_cast<PaddingStrategy>(
            buffer.GetValue(IDX_OPTIONS_PADDING_STRATEGY));
    set_padding_strategy(strategy);
  }",52,,162,2,,void
185590,BLOCK,-1,,<empty>,5,,174,2,,void
185601,BLOCK,-1,,<empty>,5,,182,2,,void
185612,BLOCK,-1,,<empty>,5,,190,2,,void
185623,BLOCK,-1,,<empty>,5,,201,2,,void
185638,BLOCK,-1,,"{
    nghttp2_option_set_max_settings(
        option,
        static_cast<size_t>(buffer[IDX_OPTIONS_MAX_SETTINGS]));
  }",48,,204,2,,void
185651,BLOCK,-1,,"{
  AliasedUint32Array& buffer = http2_state->settings_buffer;
  uint32_t flags = buffer[IDX_SETTINGS_COUNT];

  size_t count = 0;

#define V(name) GRABSETTING(entries, count, name);
  HTTP2_SETTINGS(V)
#undef V

  return count;
}",38,,221,3,,void
185679,BLOCK,-1,,"{
  callback_.Reset(env()->isolate(), callback);
  count_ = Init(session->http2_state(), entries_);
}",30,,244,5,,void
185700,BLOCK,-1,,"{
  return callback_.Get(env()->isolate());
}",49,,249,1,,void
185714,BLOCK,-1,,"{
  tracker->TrackField(""callback"", callback_);
}",62,,253,2,,void
185724,BLOCK,-1,,"{
  return Pack(session_->env(), count_, entries_);
}",36,,260,1,,void
185737,BLOCK,-1,,"{
  nghttp2_settings_entry entries[IDX_SETTINGS_COUNT];
  size_t count = Init(state, entries);
  return Pack(state->env(), count, entries);
}",53,,264,2,,void
185759,BLOCK,-1,,"{
  EscapableHandleScope scope(env->isolate());
  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), count * 6);
  }
  if (nghttp2_pack_settings_payload(static_cast<uint8_t*>(bs->Data()),
                                    bs->ByteLength(),
                                    entries,
                                    count) < 0) {
    return scope.Escape(Undefined(env->isolate()));
  }
  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  return scope.Escape(Buffer::New(env, ab, 0, ab->ByteLength())
                          .FromMaybe(Local<Value>()));
}",44,,273,4,,void
185773,BLOCK,4,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), count * 6);
  }",3,,276,4,,void
185809,BLOCK,-1,,"{
    return scope.Escape(Undefined(env->isolate()));
  }",49,,283,2,,void
185864,BLOCK,-1,,"{
  AliasedUint32Array& buffer = session->http2_state()->settings_buffer;

#define V(name)                                                                \
  buffer[IDX_SETTINGS_ ## name] =                                              \
      fn(session->session(), NGHTTP2_SETTINGS_ ## name);
  HTTP2_SETTINGS(V)
#undef V
}",67,,293,3,,void
185880,BLOCK,-1,,"{
  AliasedUint32Array& buffer = http2_state->settings_buffer;
  uint32_t flags = 0;

#define V(name)                                                            \
  do {                                                                     \
    buffer[IDX_SETTINGS_ ## name] = DEFAULT_SETTINGS_ ## name;             \
    flags |= 1 << IDX_SETTINGS_ ## name;                                   \
  } while (0);
  HTTP2_SETTINGS(V)
#undef V

  buffer[IDX_SETTINGS_COUNT] = flags;
}",62,,304,2,,void
185901,BLOCK,-1,,"{
  Http2Scope h2scope(session_.get());
  CHECK_EQ(nghttp2_submit_settings(
      session_->session(),
      NGHTTP2_FLAG_NONE,
      &entries_[0],
      count_), 0);
}",28,,320,1,,void
185925,BLOCK,-1,,"{
  uint64_t end = uv_hrtime();
  double duration = (end - startTime_) / 1e6;

  Local<Value> argv[] = {Boolean::New(env()->isolate(), ack),
                         Number::New(env()->isolate(), duration)};
  MakeCallback(callback(), arraysize(argv), argv);
}",36,,329,2,,void
185972,BLOCK,-1,,"{
  Local<Context> context = env->context();
  int32_t parent_ = parent->Int32Value(context).ToChecked();
  int32_t weight_ = weight->Int32Value(context).ToChecked();
  bool exclusive_ = exclusive->IsTrue();
  Debug(env, DebugCategory::HTTP2STREAM,
        ""Http2Priority: parent: %d, weight: %d, exclusive: %s\n"",
        parent_, weight_, exclusive_ ? ""yes"" : ""no"");
  nghttp2_priority_spec_init(this, parent_, weight_, exclusive_ ? 1 : 0);
}",54,,344,5,,void
186035,BLOCK,-1,,"{
  switch (session_type_) {
    case NGHTTP2_SESSION_SERVER: return ""server"";
    case NGHTTP2_SESSION_CLIENT: return ""client"";
    default:
      // This should never happen
      ABORT();
  }
}",44,,356,1,,void
186038,BLOCK,-1,,"{
    case NGHTTP2_SESSION_SERVER: return ""server"";
    case NGHTTP2_SESSION_CLIENT: return ""client"";
    default:
      // This should never happen
      ABORT();
  }",26,,357,2,,void
186055,BLOCK,-1,,"{
  int origin_string_len = origin_string->Length();
  if (count_ == 0) {
    CHECK_EQ(origin_string_len, 0);
    return;
  }

  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs_ = ArrayBuffer::NewBackingStore(env->isolate(),
                                       alignof(nghttp2_origin_entry) - 1 +
                                       count_ * sizeof(nghttp2_origin_entry) +
                                       origin_string_len);
  }

  // Make sure the start address is aligned appropriately for an nghttp2_nv*.
  char* start = AlignUp(static_cast<char*>(bs_->Data()),
                        alignof(nghttp2_origin_entry));
  char* origin_contents = start + (count_ * sizeof(nghttp2_origin_entry));
  nghttp2_origin_entry* const nva =
      reinterpret_cast<nghttp2_origin_entry*>(start);

  CHECK_LE(origin_contents + origin_string_len,
           static_cast<char*>(bs_->Data()) + bs_->ByteLength());
  CHECK_EQ(origin_string->WriteOneByte(
           ...",28,,370,4,,void
186067,BLOCK,-1,,"{
    CHECK_EQ(origin_string_len, 0);
    return;
  }",20,,372,2,,void
186072,BLOCK,4,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs_ = ArrayBuffer::NewBackingStore(env->isolate(),
                                       alignof(nghttp2_origin_entry) - 1 +
                                       count_ * sizeof(nghttp2_origin_entry) +
                                       origin_string_len);
  }",3,,377,4,,void
186166,BLOCK,-1,,<empty>,3,,404,1,,void
186177,BLOCK,4,,"{
    if (n >= count_) {
      static uint8_t zero = '\0';
      nva[0].origin = &zero;
      nva[0].origin_len = 1;
      count_ = 1;
      return;
    }

    nva[n].origin = reinterpret_cast<uint8_t*>(p);
    nva[n].origin_len = strlen(p);
    p += nva[n].origin_len + 1;
  }",75,,404,4,,void
186182,BLOCK,-1,,"{
      static uint8_t zero = '\0';
      nva[0].origin = &zero;
      nva[0].origin_len = 1;
      count_ = 1;
      return;
    }",22,,405,2,,void
186236,BLOCK,-1,,"{
  nghttp2_session_callbacks* callbacks_;
  CHECK_EQ(nghttp2_session_callbacks_new(&callbacks_), 0);
  callbacks.reset(callbacks_);

  nghttp2_session_callbacks_set_on_begin_headers_callback(
    callbacks_, OnBeginHeadersCallback);
  nghttp2_session_callbacks_set_on_header_callback2(
    callbacks_, OnHeaderCallback);
  nghttp2_session_callbacks_set_on_frame_recv_callback(
    callbacks_, OnFrameReceive);
  nghttp2_session_callbacks_set_on_stream_close_callback(
    callbacks_, OnStreamClose);
  nghttp2_session_callbacks_set_on_data_chunk_recv_callback(
    callbacks_, OnDataChunkReceived);
  nghttp2_session_callbacks_set_on_frame_not_send_callback(
    callbacks_, OnFrameNotSent);
  nghttp2_session_callbacks_set_on_invalid_header_callback2(
    callbacks_, OnInvalidHeader);
  nghttp2_session_callbacks_set_error_callback2(callbacks_, OnNghttpError);
  nghttp2_session_callbacks_set_send_data_callback(
    callbacks_, OnSendData);
  nghttp2_session_callbacks_set_on_invalid_frame_rec...",65,,421,2,,void
186283,BLOCK,-1,,"{
    nghttp2_session_callbacks_set_select_padding_callback(
      callbacks_, OnSelectPadding);
  }",31,,448,2,,void
186291,BLOCK,-1,,"{
  StopTrackingMemory(buf);
}",58,,454,2,,void
186298,BLOCK,-1,,"{
  CHECK_GE(current_nghttp2_memory_, previous_size);
}",67,,458,2,,void
186306,BLOCK,-1,,"{
  current_nghttp2_memory_ += size;
}",55,,462,2,,void
186314,BLOCK,-1,,"{
  current_nghttp2_memory_ -= size;
}",55,,466,2,,void
186324,BLOCK,-1,,"{
  MakeWeak();
  statistics_.session_type = type;
  statistics_.start_time = uv_hrtime();

  // Capture the configuration options for this session
  Http2Options opts(http2_state, type);

  max_session_memory_ = opts.max_session_memory();

  uint32_t maxHeaderPairs = opts.max_header_pairs();
  max_header_pairs_ =
      type == NGHTTP2_SESSION_SERVER
          ? GetServerMaxHeaderPairs(maxHeaderPairs)
          : GetClientMaxHeaderPairs(maxHeaderPairs);

  max_outstanding_pings_ = opts.max_outstanding_pings();
  max_outstanding_settings_ = opts.max_outstanding_settings();

  padding_strategy_ = opts.padding_strategy();

  bool hasGetPaddingCallback =
      padding_strategy_ != PADDING_STRATEGY_NONE;

  auto fn = type == NGHTTP2_SESSION_SERVER ?
      nghttp2_session_server_new3 :
      nghttp2_session_client_new3;

  nghttp2_mem alloc_info = MakeAllocator();

  // This should fail only if the system is out of memory, which
  // is going to cause lots of other problems anyway, or if ...",33,,476,4,,void
186470,BLOCK,-1,,"{
  CHECK(!is_in_scope());
  Debug(this, ""freeing nghttp2 session"");
  // Explicitly reset session_ so the subsequent
  // current_nghttp2_memory_ check passes.
  session_.reset();
  CHECK_EQ(current_nghttp2_memory_, 0);
}",31,,528,1,,void
186488,BLOCK,-1,,"{
  tracker->TrackField(""streams"", streams_);
  tracker->TrackField(""outstanding_pings"", outstanding_pings_);
  tracker->TrackField(""outstanding_settings"", outstanding_settings_);
  tracker->TrackField(""outgoing_buffers"", outgoing_buffers_);
  tracker->TrackFieldWithSize(""stream_buf"", stream_buf_.len);
  tracker->TrackFieldWithSize(""outgoing_storage"", outgoing_storage_.size());
  tracker->TrackFieldWithSize(""pending_rst_streams"",
                              pending_rst_streams_.size() * sizeof(int32_t));
  tracker->TrackFieldWithSize(""nghttp2_memory"", current_nghttp2_memory_);
}",61,,537,2,,void
186551,BLOCK,-1,,"{
  return std::string(""Http2Session "") + TypeName() + "" ("" +
      std::to_string(static_cast<int64_t>(get_async_id())) + "")"";
}",51,,549,1,,void
186577,BLOCK,-1,,"{
  Local<Object> obj = Object::New(env->isolate());

#define SET(name, val)                                                         \
  if (!obj->Set(                                                               \
          env->context(),                                                      \
          env->name(),                                                         \
          Number::New(                                                         \
            env->isolate(),                                                    \
            static_cast<double>(entry.details.val))).IsJust()) {               \
    return MaybeLocal<Object>();                                               \
  }

  SET(bytes_read_string, received_bytes)
  SET(bytes_written_string, sent_bytes)
  SET(id_string, id)
#undef SET

#define SET(name, val)                                                         \
  if (!obj->Set(                                                               \
          env-...",47,,556,3,,void
186593,BLOCK,1,,<empty>,,,,1,,void
186626,BLOCK,-1,,"SET(bytes_read_string, received_bytes)",3,,569,2,,void
186630,BLOCK,1,,<empty>,,,,1,,void
186663,BLOCK,-1,,"SET(bytes_written_string, sent_bytes)",3,,570,2,,void
186667,BLOCK,1,,<empty>,,,,1,,void
186700,BLOCK,-1,,"SET(id_string, id)",3,,571,2,,void
186704,BLOCK,1,,<empty>,,,,1,,void
186743,BLOCK,-1,,"SET(time_to_first_byte_string, first_byte)",3,,585,2,,void
186747,BLOCK,1,,<empty>,,,,1,,void
186786,BLOCK,-1,,"SET(time_to_first_byte_sent_string, first_byte_sent)",3,,586,2,,void
186790,BLOCK,1,,<empty>,,,,1,,void
186829,BLOCK,-1,,"SET(time_to_first_header_string, first_header)",3,,587,2,,void
186839,BLOCK,-1,,"{
  Local<Object> obj = Object::New(env->isolate());

#define SET(name, val)                                                         \
  if (!obj->Set(                                                               \
          env->context(),                                                      \
          env->name(),                                                         \
          Number::New(                                                         \
            env->isolate(),                                                    \
            static_cast<double>(entry.details.val))).IsJust()) {               \
    return MaybeLocal<Object>();                                               \
  }

  SET(bytes_written_string, data_sent)
  SET(bytes_read_string, data_received)
  SET(frames_received_string, frame_count)
  SET(frames_sent_string, frame_sent)
  SET(max_concurrent_streams_string, max_concurrent_streams)
  SET(ping_rtt_string, ping_rtt)
  SET(stream_average_duration_string...",48,,595,3,,void
186855,BLOCK,1,,<empty>,,,,1,,void
186888,BLOCK,-1,,"SET(bytes_written_string, data_sent)",3,,608,2,,void
186892,BLOCK,1,,<empty>,,,,1,,void
186925,BLOCK,-1,,"SET(bytes_read_string, data_received)",3,,609,2,,void
186929,BLOCK,1,,<empty>,,,,1,,void
186962,BLOCK,-1,,"SET(frames_received_string, frame_count)",3,,610,2,,void
186966,BLOCK,1,,<empty>,,,,1,,void
186999,BLOCK,-1,,"SET(frames_sent_string, frame_sent)",3,,611,2,,void
187003,BLOCK,1,,<empty>,,,,1,,void
187036,BLOCK,-1,,"SET(max_concurrent_streams_string, max_concurrent_streams)",3,,612,2,,void
187040,BLOCK,1,,<empty>,,,,1,,void
187073,BLOCK,-1,,"SET(ping_rtt_string, ping_rtt)",3,,613,2,,void
187077,BLOCK,1,,<empty>,,,,1,,void
187110,BLOCK,-1,,"SET(stream_average_duration_string, stream_average_duration)",3,,614,2,,void
187114,BLOCK,1,,<empty>,,,,1,,void
187147,BLOCK,-1,,"SET(stream_count_string, stream_count)",3,,615,2,,void
187182,BLOCK,-1,,"{
    return MaybeLocal<Object>();
  }",53,,623,2,,void
187190,BLOCK,-1,,"{
  CHECK_NOT_NULL(session());
  if (LIKELY(!HasHttp2Observer(env())))
    return;

  double start = statistics_.start_time / 1e6;
  double duration = (PERFORMANCE_NOW() / 1e6) - start;

  std::unique_ptr<Http2StreamPerformanceEntry> entry =
      std::make_unique<Http2StreamPerformanceEntry>(
          ""Http2Stream"",
          start - (env()->time_origin() / 1e6),
          duration,
          statistics_);

  env()->SetImmediate([entry = std::move(entry)](Environment* env) {
    if (HasHttp2Observer(env))
      entry->Notify(env);
  });
}",36,,631,1,,void
187197,BLOCK,-1,,<empty>,5,,634,2,,void
187250,BLOCK,-1,,"{
  if (LIKELY(!HasHttp2Observer(env())))
    return;

  double start = statistics_.start_time / 1e6;
  double duration = (PERFORMANCE_NOW() / 1e6) - start;

  std::unique_ptr<Http2SessionPerformanceEntry> entry =
      std::make_unique<Http2SessionPerformanceEntry>(
          ""Http2Session"",
          start - (env()->time_origin() / 1e6),
          duration,
          statistics_);

  env()->SetImmediate([entry = std::move(entry)](Environment* env) {
    if (HasHttp2Observer(env))
      entry->Notify(env);
  });
}",37,,652,1,,void
187256,BLOCK,-1,,<empty>,5,,654,2,,void
187311,BLOCK,-1,,"{
  Debug(this, ""closing session"");

  if (is_closing())
    return;
  set_closing();

  // Stop reading on the i/o stream
  if (stream_ != nullptr) {
    set_reading_stopped();
    stream_->ReadStop();
  }

  // If the socket is not closed, then attempt to send a closing GOAWAY
  // frame. There is no guarantee that this GOAWAY will be received by
  // the peer but the HTTP/2 spec recommends sending it anyway. We'll
  // make a best effort.
  if (!socket_closed) {
    Debug(this, ""terminating session with code %d"", code);
    CHECK_EQ(nghttp2_session_terminate_session(session_.get(), code), 0);
    SendPendingData();
  } else if (stream_ != nullptr) {
    stream_->RemoveStreamListener(this);
  }

  set_destroyed();

  // If we are writing we will get to make the callback in OnStreamAfterWrite.
  if (!is_write_in_progress()) {
    Debug(this, ""make done session callback"");
    HandleScope scope(env()->isolate());
    MakeCallback(env()->ondone_string(), 0, nullptr);
    if (stream_ ...",61,,673,3,,void
187317,BLOCK,-1,,<empty>,5,,677,2,,void
187324,BLOCK,-1,,"{
    set_reading_stopped();
    stream_->ReadStop();
  }",27,,681,2,,void
187333,BLOCK,-1,,"{
    Debug(this, ""terminating session with code %d"", code);
    CHECK_EQ(nghttp2_session_terminate_session(session_.get(), code), 0);
    SendPendingData();
  }",23,,690,2,,void
187348,BLOCK,-1,,<empty>,10,,694,1,,void
187353,BLOCK,-1,,"{
    stream_->RemoveStreamListener(this);
  }",34,,694,2,,void
187363,BLOCK,-1,,"{
    Debug(this, ""make done session callback"");
    HandleScope scope(env()->isolate());
    MakeCallback(env()->ondone_string(), 0, nullptr);
    if (stream_ != nullptr) {
      // Start reading again to detect the other end finishing.
      set_reading_stopped(false);
      stream_->ReadStart();
    }
  }",32,,701,2,,void
187384,BLOCK,-1,,"{
      // Start reading again to detect the other end finishing.
      set_reading_stopped(false);
      stream_->ReadStart();
    }",29,,705,2,,void
187399,BLOCK,-1,,"{
    ping->DetachFromSession();
    env()->SetImmediate(
        [ping = std::move(ping)](Environment* env) {
          ping->Done(false);
        });
  }",53,,715,2,,void
187419,BLOCK,-1,,"{
  auto s = streams_.find(id);
  return s != streams_.end() ? s->second : BaseObjectPtr<Http2Stream>();
}",65,,729,2,,void
187443,BLOCK,-1,,"{
  uint32_t maxConcurrentStreams =
      nghttp2_session_get_local_settings(
          session_.get(), NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS);
  size_t maxSize =
      std::min(streams_.max_size(), static_cast<size_t>(maxConcurrentStreams));
  // We can add a new stream so long as we are less than the current
  // maximum on concurrent streams and there's enough available memory
  return streams_.size() < maxSize &&
         has_available_session_memory(sizeof(Http2Stream));
}",35,,734,1,,void
187482,BLOCK,-1,,"{
  CHECK_GE(++statistics_.stream_count, 0);
  streams_[stream->id()] = BaseObjectPtr<Http2Stream>(stream);
  size_t size = streams_.size();
  if (size > statistics_.max_concurrent_streams)
    statistics_.max_concurrent_streams = size;
  IncrementCurrentSessionMemory(sizeof(*stream));
}",51,,746,2,,void
187514,BLOCK,-1,,<empty>,5,,751,2,,void
187528,BLOCK,-1,,"{
  BaseObjectPtr<Http2Stream> stream;
  if (streams_.empty())
    return stream;
  stream = FindStream(id);
  if (stream) {
    streams_.erase(id);
    DecrementCurrentSessionMemory(sizeof(*stream));
  }
  return stream;
}",67,,756,2,,void
187539,BLOCK,-1,,<empty>,5,,759,2,,void
187548,BLOCK,-1,,"{
    streams_.erase(id);
    DecrementCurrentSessionMemory(sizeof(*stream));
  }",15,,761,2,,void
187565,BLOCK,-1,,"{
  size_t r = (frameLen + 9) % 8;
  if (r == 0) return frameLen;  // If already a multiple of 8, return.

  size_t pad = frameLen + (8 - r);

  // If maxPayloadLen happens to be less than the calculated pad length,
  // use the max instead, even tho this means the frame will not be
  // aligned.
  pad = std::min(maxPayloadLen, pad);
  Debug(this, ""using frame size padding: %d"", pad);
  return pad;
}",67,,773,3,,void
187578,BLOCK,-1,,<empty>,15,,775,2,,void
187608,BLOCK,-1,,"{
  Debug(this, ""using max frame size padding: %d"", maxPayloadLen);
  return maxPayloadLen;
}",67,,790,3,,void
187618,BLOCK,-1,,"{
  CHECK_NOT_NULL(stream_buf_.base);
  CHECK_LE(stream_buf_offset_, stream_buf_.len);
  size_t read_len = stream_buf_.len - stream_buf_offset_;

  // multiple side effects.
  Debug(this, ""receiving %d bytes [wants data? %d]"",
        read_len,
        nghttp2_session_want_read(session_.get()));
  set_receive_paused(false);
  custom_recv_error_code_ = nullptr;
  ssize_t ret =
    nghttp2_session_mem_recv(session_.get(),
                             reinterpret_cast<uint8_t*>(stream_buf_.base) +
                                 stream_buf_offset_,
                             read_len);
  CHECK_NE(ret, NGHTTP2_ERR_NOMEM);
  CHECK_IMPLIES(custom_recv_error_code_ != nullptr, ret < 0);

  if (is_receive_paused()) {
    CHECK(is_reading_stopped());

    CHECK_GT(ret, 0);
    CHECK_LE(static_cast<size_t>(ret), read_len);

    // Mark the remainder of the data as available for later consumption.
    // Even if all bytes were received, a paused stream may delay the
    // nghttp2_on_frame_r...",39,,800,1,,void
187678,BLOCK,-1,,"{
    CHECK(is_reading_stopped());

    CHECK_GT(ret, 0);
    CHECK_LE(static_cast<size_t>(ret), read_len);

    // Mark the remainder of the data as available for later consumption.
    // Even if all bytes were received, a paused stream may delay the
    // nghttp2_on_frame_recv_callback which may have an END_STREAM flag.
    stream_buf_offset_ += ret;
    goto done;
  }",28,,819,2,,void
187719,BLOCK,-1,,"{
    SendPendingData();
  }",36,,840,2,,void
187727,BLOCK,-1,,"{
    Isolate* isolate = env()->isolate();
    Debug(this,
        ""fatal error receiving data: %d (%s)"",
        ret,
        custom_recv_error_code_ != nullptr ?
            custom_recv_error_code_ : ""(no custom error code)"");
    Local<Value> args[] = {
      Integer::New(isolate, static_cast<int32_t>(ret)),
      Null(isolate)
    };
    if (custom_recv_error_code_ != nullptr) {
      args[1] = String::NewFromUtf8(
          isolate,
          custom_recv_error_code_,
          NewStringType::kInternalized).ToLocalChecked();
    }
    MakeCallback(
        env()->http2session_on_error_function(),
        arraysize(args),
        args);
  }",26,,845,2,,void
187763,BLOCK,-1,,"{
      args[1] = String::NewFromUtf8(
          isolate,
          custom_recv_error_code_,
          NewStringType::kInternalized).ToLocalChecked();
    }",45,,856,2,,void
187792,BLOCK,-1,,"{
  // If this is a push promise, we want to grab the id of the promised stream
  return (frame->hd.type == NGHTTP2_PUSH_PROMISE) ?
      frame->push_promise.promised_stream_id :
      frame->hd.stream_id;
}",48,,870,2,,void
187818,BLOCK,-1,,"{
  Http2Session* session = static_cast<Http2Session*>(user_data);
  int32_t id = GetFrameID(frame);
  Debug(session, ""beginning headers for stream %d"", id);

  BaseObjectPtr<Http2Stream> stream = session->FindStream(id);
  // The common case is that we're creating a new stream. The less likely
  // case is that we're receiving a set of trailers
  if (LIKELY(!stream)) {
    if (UNLIKELY(!session->CanAddStream() ||
                 Http2Stream::New(session, id, frame->headers.cat) ==
                     nullptr)) {
      if (session->rejected_stream_count_++ >
          session->js_fields_->max_rejected_streams)
        return NGHTTP2_ERR_CALLBACK_FAILURE;
      // Too many concurrent streams being opened
      nghttp2_submit_rst_stream(
          session->session(),
          NGHTTP2_FLAG_NONE,
          id,
          NGHTTP2_ENHANCE_YOUR_CALM);
      return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
    }

    session->rejected_stream_count_ = 0;
  } else if (!stream->is_destroyed()) ...",59,,884,4,,void
187849,BLOCK,-1,,"{
    if (UNLIKELY(!session->CanAddStream() ||
                 Http2Stream::New(session, id, frame->headers.cat) ==
                     nullptr)) {
      if (session->rejected_stream_count_++ >
          session->js_fields_->max_rejected_streams)
        return NGHTTP2_ERR_CALLBACK_FAILURE;
      // Too many concurrent streams being opened
      nghttp2_submit_rst_stream(
          session->session(),
          NGHTTP2_FLAG_NONE,
          id,
          NGHTTP2_ENHANCE_YOUR_CALM);
      return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
    }

    session->rejected_stream_count_ = 0;
  }",24,,892,2,,void
187871,BLOCK,-1,,"{
      if (session->rejected_stream_count_++ >
          session->js_fields_->max_rejected_streams)
        return NGHTTP2_ERR_CALLBACK_FAILURE;
      // Too many concurrent streams being opened
      nghttp2_submit_rst_stream(
          session->session(),
          NGHTTP2_FLAG_NONE,
          id,
          NGHTTP2_ENHANCE_YOUR_CALM);
      return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
    }",32,,895,2,,void
187883,BLOCK,-1,,<empty>,9,,898,2,,void
187902,BLOCK,-1,,<empty>,10,,909,1,,void
187909,BLOCK,-1,,"{
    stream->StartHeaders(frame->headers.cat);
  }",39,,909,2,,void
187930,BLOCK,-1,,"{
  Http2Session* session = static_cast<Http2Session*>(user_data);
  int32_t id = GetFrameID(frame);
  BaseObjectPtr<Http2Stream> stream = session->FindStream(id);
  // If stream is null at this point, either something odd has happened
  // or the stream was closed locally while header processing was occurring.
  // either way, do not proceed and close the stream.
  if (UNLIKELY(!stream))
    return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;

  // If the stream has already been destroyed, ignore.
  if (!stream->is_destroyed() && !stream->AddHeader(name, value, flags)) {
    // This will only happen if the connected peer sends us more
    // than the allowed number of header items at any given time
    stream->SubmitRstStream(NGHTTP2_ENHANCE_YOUR_CALM);
    return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
  }
  return 0;
}",53,,923,7,,void
187957,BLOCK,-1,,<empty>,5,,931,2,,void
187975,BLOCK,-1,,"{
    // This will only happen if the connected peer sends us more
    // than the allowed number of header items at any given time
    stream->SubmitRstStream(NGHTTP2_ENHANCE_YOUR_CALM);
    return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
  }",74,,934,2,,void
187991,BLOCK,-1,,"{
  Http2Session* session = static_cast<Http2Session*>(user_data);
  session->statistics_.frame_count++;
  Debug(session, ""complete frame received: type: %d"",
        frame->hd.type);
  switch (frame->hd.type) {
    case NGHTTP2_DATA:
      return session->HandleDataFrame(frame);
    case NGHTTP2_PUSH_PROMISE:
      // Intentional fall-through, handled just like headers frames
    case NGHTTP2_HEADERS:
      session->HandleHeadersFrame(frame);
      break;
    case NGHTTP2_SETTINGS:
      session->HandleSettingsFrame(frame);
      break;
    case NGHTTP2_PRIORITY:
      session->HandlePriorityFrame(frame);
      break;
    case NGHTTP2_GOAWAY:
      session->HandleGoawayFrame(frame);
      break;
    case NGHTTP2_PING:
      session->HandlePingFrame(frame);
      break;
    case NGHTTP2_ALTSVC:
      session->HandleAltSvcFrame(frame);
      break;
    case NGHTTP2_ORIGIN:
      session->HandleOriginFrame(frame);
      break;
    default:
      break;
  }
  return 0;
}",51,,948,4,,void
188018,BLOCK,-1,,"{
    case NGHTTP2_DATA:
      return session->HandleDataFrame(frame);
    case NGHTTP2_PUSH_PROMISE:
      // Intentional fall-through, handled just like headers frames
    case NGHTTP2_HEADERS:
      session->HandleHeadersFrame(frame);
      break;
    case NGHTTP2_SETTINGS:
      session->HandleSettingsFrame(frame);
      break;
    case NGHTTP2_PRIORITY:
      session->HandlePriorityFrame(frame);
      break;
    case NGHTTP2_GOAWAY:
      session->HandleGoawayFrame(frame);
      break;
    case NGHTTP2_PING:
      session->HandlePingFrame(frame);
      break;
    case NGHTTP2_ALTSVC:
      session->HandleAltSvcFrame(frame);
      break;
    case NGHTTP2_ORIGIN:
      session->HandleOriginFrame(frame);
      break;
    default:
      break;
  }",27,,953,2,,void
188096,BLOCK,-1,,"{
  Http2Session* session = static_cast<Http2Session*>(user_data);
  const uint32_t max_invalid_frames = session->js_fields_->max_invalid_frames;

  Debug(session,
        ""invalid frame received (%u/%u), code: %d"",
        session->invalid_frame_count_,
        max_invalid_frames,
        lib_error_code);
  if (session->invalid_frame_count_++ > max_invalid_frames) {
    session->custom_recv_error_code_ = ""ERR_HTTP2_TOO_MANY_INVALID_FRAMES"";
    return 1;
  }

  // If the error is fatal or if error code is ERR_STREAM_CLOSED... emit error
  if (nghttp2_is_fatal(lib_error_code) ||
      lib_error_code == NGHTTP2_ERR_STREAM_CLOSED) {
    Environment* env = session->env();
    Isolate* isolate = env->isolate();
    HandleScope scope(isolate);
    Local<Context> context = env->context();
    Context::Scope context_scope(context);
    Local<Value> arg = Integer::New(isolate, lib_error_code);
    session->MakeCallback(env->http2session_on_error_function(), 1, &arg);
  }
  return 0;
}",51,,988,5,,void
188126,BLOCK,-1,,"{
    session->custom_recv_error_code_ = ""ERR_HTTP2_TOO_MANY_INVALID_FRAMES"";
    return 1;
  }",61,,997,2,,void
188141,BLOCK,-1,,"{
    Environment* env = session->env();
    Isolate* isolate = env->isolate();
    HandleScope scope(isolate);
    Local<Context> context = env->context();
    Context::Scope context_scope(context);
    Local<Value> arg = Integer::New(isolate, lib_error_code);
    session->MakeCallback(env->http2session_on_error_function(), 1, &arg);
  }",52,,1004,2,,void
188201,BLOCK,-1,,"{
  int32_t id = GetFrameID(frame);
  BaseObjectPtr<Http2Stream> stream = FindStream(id);

  if (stream && !stream->is_destroyed() && stream->headers_count() > 0) {
    Debug(this, ""freeing headers for stream %d"", id);
    stream->ClearHeaders();
    CHECK_EQ(stream->headers_count(), 0);
    DecrementCurrentSessionMemory(stream->current_headers_length_);
    stream->current_headers_length_ = 0;
  }
}",62,,1018,2,,void
188230,BLOCK,-1,,"{
    Debug(this, ""freeing headers for stream %d"", id);
    stream->ClearHeaders();
    CHECK_EQ(stream->headers_count(), 0);
    DecrementCurrentSessionMemory(stream->current_headers_length_);
    stream->current_headers_length_ = 0;
  }",73,,1022,2,,void
188258,BLOCK,-1,,"{
  switch (libErrorCode) {
  case NGHTTP2_ERR_STREAM_CLOSED:
    return NGHTTP2_STREAM_CLOSED;
  case NGHTTP2_ERR_HEADER_COMP:
    return NGHTTP2_COMPRESSION_ERROR;
  case NGHTTP2_ERR_FRAME_SIZE_ERROR:
    return NGHTTP2_FRAME_SIZE_ERROR;
  case NGHTTP2_ERR_FLOW_CONTROL:
    return NGHTTP2_FLOW_CONTROL_ERROR;
  case NGHTTP2_ERR_REFUSED_STREAM:
    return NGHTTP2_REFUSED_STREAM;
  case NGHTTP2_ERR_PROTO:
  case NGHTTP2_ERR_HTTP_HEADER:
  case NGHTTP2_ERR_HTTP_MESSAGING:
    return NGHTTP2_PROTOCOL_ERROR;
  default:
    return NGHTTP2_INTERNAL_ERROR;
  }
}",60,,1031,2,,void
188261,BLOCK,-1,,"{
  case NGHTTP2_ERR_STREAM_CLOSED:
    return NGHTTP2_STREAM_CLOSED;
  case NGHTTP2_ERR_HEADER_COMP:
    return NGHTTP2_COMPRESSION_ERROR;
  case NGHTTP2_ERR_FRAME_SIZE_ERROR:
    return NGHTTP2_FRAME_SIZE_ERROR;
  case NGHTTP2_ERR_FLOW_CONTROL:
    return NGHTTP2_FLOW_CONTROL_ERROR;
  case NGHTTP2_ERR_REFUSED_STREAM:
    return NGHTTP2_REFUSED_STREAM;
  case NGHTTP2_ERR_PROTO:
  case NGHTTP2_ERR_HTTP_HEADER:
  case NGHTTP2_ERR_HTTP_MESSAGING:
    return NGHTTP2_PROTOCOL_ERROR;
  default:
    return NGHTTP2_INTERNAL_ERROR;
  }",25,,1032,2,,void
188300,BLOCK,-1,,"{
  Http2Session* session = static_cast<Http2Session*>(user_data);
  Environment* env = session->env();
  Debug(session, ""frame type %d was not sent, code: %d"",
        frame->hd.type, error_code);

  // Do not report if the frame was not sent due to the session closing
  if (error_code == NGHTTP2_ERR_SESSION_CLOSING ||
      error_code == NGHTTP2_ERR_STREAM_CLOSED ||
      error_code == NGHTTP2_ERR_STREAM_CLOSING) {
    // Nghttp2 contains header limit of 65536. When this value is exceeded the
    // pipeline is stopped and we should remove the current headers reference
    // to destroy the session completely.
    // Further information see: https://github.com/nodejs/node/issues/35233
    session->DecrefHeaders(frame);
    return 0;
  }

  Isolate* isolate = env->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env->context();
  Context::Scope context_scope(context);

  Local<Value> argv[3] = {
    Integer::New(isolate, frame->hd.stream_id),
    Integer::New(iso...",51,,1061,5,,void
188335,BLOCK,-1,,"{
    // Nghttp2 contains header limit of 65536. When this value is exceeded the
    // pipeline is stopped and we should remove the current headers reference
    // to destroy the session completely.
    // Further information see: https://github.com/nodejs/node/issues/35233
    session->DecrefHeaders(frame);
    return 0;
  }",49,,1070,2,,void
188393,BLOCK,-1,,"{
  Http2Session* session = static_cast<Http2Session*>(user_data);
  session->statistics_.frame_sent += 1;
  return 0;
}",48,,1097,4,,void
188416,BLOCK,-1,,"{
  Http2Session* session = static_cast<Http2Session*>(user_data);
  Environment* env = session->env();
  Isolate* isolate = env->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env->context();
  Context::Scope context_scope(context);
  Debug(session, ""stream %d closed with code: %d"", id, code);
  BaseObjectPtr<Http2Stream> stream = session->FindStream(id);
  // Intentionally ignore the callback if the stream does not exist or has
  // already been destroyed
  if (!stream || stream->is_destroyed())
    return 0;

  stream->Close(code);

  // It is possible for the stream close to occur before the stream is
  // ever passed on to the javascript side. If that happens, the callback
  // will return false.
  if (env->can_call_into_js()) {
    Local<Value> arg = Integer::NewFromUnsigned(isolate, code);
    MaybeLocal<Value> answer = stream->MakeCallback(
        env->http2session_on_stream_close_function(), 1, &arg);
    if (answer.IsEmpty() || answer.ToLocalChecked()...",50,,1107,5,,void
188477,BLOCK,-1,,<empty>,5,,1119,2,,void
188490,BLOCK,-1,,"{
    Local<Value> arg = Integer::NewFromUnsigned(isolate, code);
    MaybeLocal<Value> answer = stream->MakeCallback(
        env->http2session_on_stream_close_function(), 1, &arg);
    if (answer.IsEmpty() || answer.ToLocalChecked()->IsFalse()) {
      // Skip to destroy
      stream->Destroy();
    }
  }",32,,1126,2,,void
188533,BLOCK,-1,,"{
      // Skip to destroy
      stream->Destroy();
    }",65,,1130,2,,void
188549,BLOCK,-1,,"{
  // Ignore invalid header fields by default.
  return 0;
}",52,,1147,7,,void
188561,BLOCK,-1,,"{
  Http2Session* session = static_cast<Http2Session*>(user_data);
  Debug(session, ""buffering data chunk for stream %d, size: ""
        ""%d, flags: %d"", id, len, flags);
  Environment* env = session->env();
  HandleScope scope(env->isolate());

  // We should never actually get a 0-length chunk so this check is
  // only a precaution at this point.
  if (len == 0)
    return 0;

  // Notify nghttp2 that we've consumed a chunk of data on the connection
  // so that it can send a WINDOW_UPDATE frame. This is a critical part of
  // the flow control process in http2
  CHECK_EQ(nghttp2_session_consume_connection(handle, len), 0);
  BaseObjectPtr<Http2Stream> stream = session->FindStream(id);

  // If the stream has been destroyed, ignore this chunk
  if (!stream || stream->is_destroyed())
    return 0;

  stream->statistics_.received_bytes += len;

  // Repeatedly ask the stream's owner for memory, and copy the read data
  // into those buffers.
  // The typical case is actually the ex...",56,,1161,7,,void
188591,BLOCK,-1,,<empty>,5,,1171,2,,void
188618,BLOCK,-1,,<empty>,5,,1181,2,,void
188629,BLOCK,-1,,"{
    uv_buf_t buf = stream->EmitAlloc(len);
    ssize_t avail = len;
    if (static_cast<ssize_t>(buf.len) < avail)
      avail = buf.len;

    // `buf.base == nullptr` is the default Http2StreamListener's way
    // of saying that it wants a pointer to the raw original.
    // Since it has access to the original socket buffer from which the data
    // was read in the first place, it can use that to minimize ArrayBuffer
    // allocations.
    if (LIKELY(buf.base == nullptr))
      buf.base = reinterpret_cast<char*>(const_cast<uint8_t*>(data));
    else
      memcpy(buf.base, data, avail);
    data += avail;
    len -= avail;
    stream->EmitRead(avail, buf);

    // If the stream owner (e.g. the JS Http2Stream) wants more data, just
    // tell nghttp2 that all data has been consumed. Otherwise, defer until
    // more data is being requested.
    if (stream->is_reading())
      nghttp2_session_consume_stream(handle, id, avail);
    else
      stream->inbound_consumed_data_while_...",6,,1190,1,,void
188650,BLOCK,-1,,<empty>,7,,1194,2,,void
188663,BLOCK,-1,,<empty>,7,,1202,2,,void
188674,BLOCK,-1,,<empty>,7,,1204,1,,void
188698,BLOCK,-1,,<empty>,7,,1213,2,,void
188704,BLOCK,-1,,<empty>,7,,1215,1,,void
188722,BLOCK,-1,,"{
      session->SendPendingData();
    }",52,,1219,2,,void
188735,BLOCK,-1,,"{
    CHECK(session->is_reading_stopped());
    session->set_receive_paused();
    Debug(session, ""receive paused"");
    return NGHTTP2_ERR_PAUSE;
  }",40,,1226,2,,void
188759,BLOCK,-1,,"{
  Http2Session* session = static_cast<Http2Session*>(user_data);
  ssize_t padding = frame->hd.length;

  switch (session->padding_strategy_) {
    case PADDING_STRATEGY_NONE:
      // Fall-through
      break;
    case PADDING_STRATEGY_MAX:
      padding = session->OnMaxFrameSizePadding(padding, maxPayloadLen);
      break;
    case PADDING_STRATEGY_ALIGNED:
      padding = session->OnDWordAlignedPadding(padding, maxPayloadLen);
      break;
  }
  return padding;
}",56,,1241,5,,void
188778,BLOCK,-1,,"{
    case PADDING_STRATEGY_NONE:
      // Fall-through
      break;
    case PADDING_STRATEGY_MAX:
      padding = session->OnMaxFrameSizePadding(padding, maxPayloadLen);
      break;
    case PADDING_STRATEGY_ALIGNED:
      padding = session->OnDWordAlignedPadding(padding, maxPayloadLen);
      break;
  }",39,,1245,2,,void
188814,BLOCK,-1,,"{
  // Unfortunately, this is currently the only way for us to know if
  // the session errored because the peer is not an http2 peer.
  Http2Session* session = static_cast<Http2Session*>(user_data);
  Debug(session, ""Error '%s'"", message);
  if (lib_error_code == NGHTTP2_ERR_SETTINGS_EXPECTED) {
    Environment* env = session->env();
    Isolate* isolate = env->isolate();
    HandleScope scope(isolate);
    Local<Context> context = env->context();
    Context::Scope context_scope(context);
    Local<Value> arg = Integer::New(isolate, NGHTTP2_ERR_PROTO);
    session->MakeCallback(env->http2session_on_error_function(), 1, &arg);
  }
  return 0;
}",50,,1265,6,,void
188829,BLOCK,-1,,"{
    Environment* env = session->env();
    Isolate* isolate = env->isolate();
    HandleScope scope(isolate);
    Local<Context> context = env->context();
    Context::Scope context_scope(context);
    Local<Value> arg = Integer::New(isolate, NGHTTP2_ERR_PROTO);
    session->MakeCallback(env->http2session_on_error_function(), 1, &arg);
  }",56,,1270,2,,void
188889,BLOCK,-1,,"{
  // See the comments in Http2Session::OnDataChunkReceived
  // (which is the only possible call site for this method).
  return uv_buf_init(nullptr, size);
}",58,,1282,2,,void
188899,BLOCK,-1,,"{
  Http2Stream* stream = static_cast<Http2Stream*>(stream_);
  Http2Session* session = stream->session();
  Environment* env = stream->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  if (nread < 0) {
    PassReadErrorToPreviousListener(nread);
    return;
  }

  Local<ArrayBuffer> ab;
  if (session->stream_buf_ab_.IsEmpty()) {
    ab = ArrayBuffer::New(env->isolate(),
                          std::move(session->stream_buf_allocation_));
    session->stream_buf_ab_.Reset(env->isolate(), ab);
  } else {
    ab = PersistentToLocal::Strong(session->stream_buf_ab_);
  }

  // There is a single large array buffer for the entire data read from the
  // network; create a slice of that array buffer and emit it as the
  // received data buffer.
  size_t offset = buf.base - session->stream_buf_.base;

  // Verify that the data offset is inside the current read buffer.
  CHECK_GE(offset, session->stream_buf_offset_);
  CHECK_LE(offset, ses...",76,,1288,3,,void
188936,BLOCK,-1,,"{
    PassReadErrorToPreviousListener(nread);
    return;
  }",18,,1295,2,,void
188952,BLOCK,-1,,"{
    ab = ArrayBuffer::New(env->isolate(),
                          std::move(session->stream_buf_allocation_));
    session->stream_buf_ab_.Reset(env->isolate(), ab);
  }",42,,1301,2,,void
188982,BLOCK,-1,,"{
    ab = PersistentToLocal::Strong(session->stream_buf_ab_);
  }",10,,1305,1,,void
189038,BLOCK,-1,,"{
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);

  int32_t id = GetFrameID(frame);
  Debug(this, ""handle headers frame for stream %d"", id);
  BaseObjectPtr<Http2Stream> stream = FindStream(id);

  // If the stream has already been destroyed, ignore.
  if (!stream || stream->is_destroyed())
    return;

  // The headers are stored as a vector of Http2Header instances.
  // The following converts that into a JS array with the structure:
  // [name1, value1, name2, value2, name3, value3, name3, value4] and so on.
  // That array is passed up to the JS layer and converted into an Object form
  // like {name1: value1, name2: value2, name3: [value3, value4]}. We do it
  // this way for performance reasons (it's faster to generate and pass an
  // array than it is to generate and pass the object).

  MaybeStackBuffer<Local<Value>, 64> headers_v(stream->headers_count() * 2);
  MaybeS...",67,,1326,2,,void
189087,BLOCK,-1,,<empty>,5,,1338,2,,void
189192,BLOCK,-1,,"{
  if (js_fields_->priority_listener_count == 0) return;
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);

  nghttp2_priority priority_frame = frame->priority;
  int32_t id = GetFrameID(frame);
  Debug(this, ""handle priority frame for stream %d"", id);
  // Priority frame stream ID should never be <= 0. nghttp2 handles this for us
  nghttp2_priority_spec spec = priority_frame.pri_spec;

  Local<Value> argv[4] = {
    Integer::New(isolate, id),
    Integer::New(isolate, spec.stream_id),
    Integer::New(isolate, spec.weight),
    Boolean::New(isolate, spec.exclusive)
  };
  MakeCallback(env()->http2session_on_priority_function(),
               arraysize(argv), argv);
}",68,,1380,2,,void
189199,BLOCK,-1,,<empty>,49,,1381,2,,void
189265,BLOCK,-1,,"{
  int32_t id = GetFrameID(frame);
  Debug(this, ""handling data frame for stream %d"", id);
  BaseObjectPtr<Http2Stream> stream = FindStream(id);

  if (stream &&
      !stream->is_destroyed() &&
      frame->hd.flags & NGHTTP2_FLAG_END_STREAM) {
    stream->EmitRead(UV_EOF);
  } else if (frame->hd.length == 0) {
    if (invalid_frame_count_++ > js_fields_->max_invalid_frames) {
      custom_recv_error_code_ = ""ERR_HTTP2_TOO_MANY_INVALID_FRAMES"";
      Debug(this, ""rejecting empty-frame-without-END_STREAM flood\n"");
      // Consider a flood of 0-length frames without END_STREAM an error.
      return 1;
    }
  }
  return 0;
}",63,,1407,2,,void
189299,BLOCK,-1,,"{
    stream->EmitRead(UV_EOF);
  }",50,,1414,2,,void
189306,BLOCK,-1,,<empty>,10,,1416,1,,void
189315,BLOCK,-1,,"{
    if (invalid_frame_count_++ > js_fields_->max_invalid_frames) {
      custom_recv_error_code_ = ""ERR_HTTP2_TOO_MANY_INVALID_FRAMES"";
      Debug(this, ""rejecting empty-frame-without-END_STREAM flood\n"");
      // Consider a flood of 0-length frames without END_STREAM an error.
      return 1;
    }
  }",37,,1416,2,,void
189323,BLOCK,-1,,"{
      custom_recv_error_code_ = ""ERR_HTTP2_TOO_MANY_INVALID_FRAMES"";
      Debug(this, ""rejecting empty-frame-without-END_STREAM flood\n"");
      // Consider a flood of 0-length frames without END_STREAM an error.
      return 1;
    }",66,,1417,2,,void
189338,BLOCK,-1,,"{
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);

  nghttp2_goaway goaway_frame = frame->goaway;
  Debug(this, ""handling goaway frame"");

  Local<Value> argv[3] = {
    Integer::NewFromUnsigned(isolate, goaway_frame.error_code),
    Integer::New(isolate, goaway_frame.last_stream_id),
    Undefined(isolate)
  };

  size_t length = goaway_frame.opaque_data_len;
  if (length > 0) {
    // If the copy fails for any reason here, we just ignore it.
    // The additional goaway data is completely optional and we
    // shouldn't fail if we're not able to process it.
    argv[2] = Buffer::Copy(isolate,
                           reinterpret_cast<char*>(goaway_frame.opaque_data),
                           length).ToLocalChecked();
  }

  MakeCallback(env()->http2session_on_goaway_data_function(),
               arraysize(argv), argv);
}",66,,1429,2,,void
189389,BLOCK,-1,,"{
    // If the copy fails for any reason here, we just ignore it.
    // The additional goaway data is completely optional and we
    // shouldn't fail if we're not able to process it.
    argv[2] = Buffer::Copy(isolate,
                           reinterpret_cast<char*>(goaway_frame.opaque_data),
                           length).ToLocalChecked();
  }",19,,1445,2,,void
189420,BLOCK,-1,,"{
  if (!(js_fields_->bitfield & (1 << kSessionHasAltsvcListeners))) return;
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);

  int32_t id = GetFrameID(frame);

  nghttp2_extension ext = frame->ext;
  nghttp2_ext_altsvc* altsvc = static_cast<nghttp2_ext_altsvc*>(ext.payload);
  Debug(this, ""handling altsvc frame"");

  Local<Value> argv[3] = {
    Integer::New(isolate, id),
    OneByteString(isolate, altsvc->origin, altsvc->origin_len),
    OneByteString(isolate, altsvc->field_value, altsvc->field_value_len)
  };

  MakeCallback(env()->http2session_on_altsvc_function(),
               arraysize(argv), argv);
}",66,,1459,2,,void
189430,BLOCK,-1,,<empty>,68,,1460,2,,void
189497,BLOCK,-1,,"{
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);

  Debug(this, ""handling origin frame"");

  nghttp2_extension ext = frame->ext;
  nghttp2_ext_origin* origin = static_cast<nghttp2_ext_origin*>(ext.payload);

  size_t nov = origin->nov;
  std::vector<Local<Value>> origin_v(nov);

  for (size_t i = 0; i < nov; ++i) {
    const nghttp2_origin_entry& entry = origin->ov[i];
    origin_v[i] = OneByteString(isolate, entry.origin, entry.origin_len);
  }
  Local<Value> holder = Array::New(isolate, origin_v.data(), origin_v.size());
  MakeCallback(env()->http2session_on_origin_function(), 1, &holder);
}",66,,1482,2,,void
189555,BLOCK,-1,,<empty>,3,,1496,1,,void
189565,BLOCK,4,,"{
    const nghttp2_origin_entry& entry = origin->ov[i];
    origin_v[i] = OneByteString(isolate, entry.origin, entry.origin_len);
  }",36,,1496,4,,void
189617,BLOCK,-1,,"{
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);
  Local<Value> arg;
  bool ack = frame->hd.flags & NGHTTP2_FLAG_ACK;
  if (ack) {
    BaseObjectPtr<Http2Ping> ping = PopPing();

    if (!ping) {
      // PING Ack is unsolicited. Treat as a connection error. The HTTP/2
      // spec does not require this, but there is no legitimate reason to
      // receive an unsolicited PING ack on a connection. Either the peer
      // is buggy or malicious, and we're not going to tolerate such
      // nonsense.
      arg = Integer::New(isolate, NGHTTP2_ERR_PROTO);
      MakeCallback(env()->http2session_on_error_function(), 1, &arg);
      return;
    }

    ping->Done(true, frame->ping.opaque_data);
    return;
  }

  if (!(js_fields_->bitfield & (1 << kSessionHasPingListeners))) return;
  // Notify the session that a ping occurred
  arg = Buffer::Copy(
      env(),
      reinterpret_cas...",64,,1505,2,,void
189658,BLOCK,-1,,"{
    BaseObjectPtr<Http2Ping> ping = PopPing();

    if (!ping) {
      // PING Ack is unsolicited. Treat as a connection error. The HTTP/2
      // spec does not require this, but there is no legitimate reason to
      // receive an unsolicited PING ack on a connection. Either the peer
      // is buggy or malicious, and we're not going to tolerate such
      // nonsense.
      arg = Integer::New(isolate, NGHTTP2_ERR_PROTO);
      MakeCallback(env()->http2session_on_error_function(), 1, &arg);
      return;
    }

    ping->Done(true, frame->ping.opaque_data);
    return;
  }",12,,1512,2,,void
189669,BLOCK,-1,,"{
      // PING Ack is unsolicited. Treat as a connection error. The HTTP/2
      // spec does not require this, but there is no legitimate reason to
      // receive an unsolicited PING ack on a connection. Either the peer
      // is buggy or malicious, and we're not going to tolerate such
      // nonsense.
      arg = Integer::New(isolate, NGHTTP2_ERR_PROTO);
      MakeCallback(env()->http2session_on_error_function(), 1, &arg);
      return;
    }",16,,1515,2,,void
189707,BLOCK,-1,,<empty>,66,,1530,2,,void
189739,BLOCK,-1,,"{
  bool ack = frame->hd.flags & NGHTTP2_FLAG_ACK;
  if (!ack) {
    js_fields_->bitfield &= ~(1 << kSessionRemoteSettingsIsUpToDate);
    if (!(js_fields_->bitfield & (1 << kSessionHasRemoteSettingsListeners)))
      return;
    // This is not a SETTINGS acknowledgement, notify and return
    MakeCallback(env()->http2session_on_settings_function(), 0, nullptr);
    return;
  }

  // If this is an acknowledgement, we should have an Http2Settings
  // object for it.
  BaseObjectPtr<Http2Settings> settings = PopSettings();
  if (settings) {
    settings->Done(true);
    return;
  }
  // SETTINGS Ack is unsolicited. Treat as a connection error. The HTTP/2
  // spec does not require this, but there is no legitimate reason to
  // receive an unsolicited SETTINGS ack on a connection. Either the peer
  // is buggy or malicious, and we're not going to tolerate such
  // nonsense.
  // Note that nghttp2 currently prevents this from happening for SETTINGS
  // frames, so this block is purely ...",68,,1540,2,,void
189753,BLOCK,-1,,"{
    js_fields_->bitfield &= ~(1 << kSessionRemoteSettingsIsUpToDate);
    if (!(js_fields_->bitfield & (1 << kSessionHasRemoteSettingsListeners)))
      return;
    // This is not a SETTINGS acknowledgement, notify and return
    MakeCallback(env()->http2session_on_settings_function(), 0, nullptr);
    return;
  }",13,,1542,2,,void
189771,BLOCK,-1,,<empty>,7,,1545,2,,void
189790,BLOCK,-1,,"{
    settings->Done(true);
    return;
  }",17,,1554,2,,void
189845,BLOCK,-1,,"{
  Debug(this, ""write finished with status %d"", status);

  CHECK(is_write_in_progress());
  set_write_in_progress(false);

  // Inform all pending writes about their completion.
  ClearOutgoing(status);

  if (is_reading_stopped() &&
      !is_write_in_progress() &&
      nghttp2_session_want_read(session_.get())) {
    set_reading_stopped(false);
    stream_->ReadStart();
  }

  if (is_destroyed()) {
    HandleScope scope(env()->isolate());
    MakeCallback(env()->ondone_string(), 0, nullptr);
    if (stream_ != nullptr) {
      // Start reading again to detect the other end finishing.
      set_reading_stopped(false);
      stream_->ReadStart();
    }
    return;
  }

  // If there is more incoming data queued up, consume it.
  if (stream_buf_offset_ > 0) {
    ConsumeHTTP2Data();
  }

  if (!is_write_scheduled() && !is_destroyed()) {
    // Schedule a new write if nghttp2 wants to send data.
    MaybeScheduleWrite();
  }
}",65,,1576,3,,void
189866,BLOCK,-1,,"{
    set_reading_stopped(false);
    stream_->ReadStart();
  }",50,,1587,2,,void
189875,BLOCK,-1,,"{
    HandleScope scope(env()->isolate());
    MakeCallback(env()->ondone_string(), 0, nullptr);
    if (stream_ != nullptr) {
      // Start reading again to detect the other end finishing.
      set_reading_stopped(false);
      stream_->ReadStart();
    }
    return;
  }",23,,1592,2,,void
189893,BLOCK,-1,,"{
      // Start reading again to detect the other end finishing.
      set_reading_stopped(false);
      stream_->ReadStart();
    }",29,,1595,2,,void
189905,BLOCK,-1,,"{
    ConsumeHTTP2Data();
  }",31,,1604,2,,void
189913,BLOCK,-1,,"{
    // Schedule a new write if nghttp2 wants to send data.
    MaybeScheduleWrite();
  }",49,,1608,2,,void
189918,BLOCK,-1,,"{
  CHECK(!is_write_scheduled());
  if (UNLIKELY(!session_))
    return;

  if (nghttp2_session_want_write(session_.get())) {
    HandleScope handle_scope(env()->isolate());
    Debug(this, ""scheduling write"");
    set_write_scheduled();
    BaseObjectPtr<Http2Session> strong_ref{this};
    env()->SetImmediate([this, strong_ref](Environment* env) {
      if (!session_ || !is_write_scheduled()) {
        // This can happen e.g. when a stream was reset before this turn
        // of the event loop, in which case SendPendingData() is called early,
        // or the session was destroyed in the meantime.
        return;
      }

      // Sending data may call arbitrary JS code, so keep track of
      // async context.
      if (env->can_call_into_js()) {
        HandleScope handle_scope(env->isolate());
        InternalCallbackScope callback_scope(this);
        SendPendingData();
      }
    });
  }
}",41,,1618,1,,void
189926,BLOCK,-1,,<empty>,5,,1621,2,,void
189934,BLOCK,-1,,"{
    HandleScope handle_scope(env()->isolate());
    Debug(this, ""scheduling write"");
    set_write_scheduled();
    BaseObjectPtr<Http2Session> strong_ref{this};
    env()->SetImmediate([this, strong_ref](Environment* env) {
      if (!session_ || !is_write_scheduled()) {
        // This can happen e.g. when a stream was reset before this turn
        // of the event loop, in which case SendPendingData() is called early,
        // or the session was destroyed in the meantime.
        return;
      }

      // Sending data may call arbitrary JS code, so keep track of
      // async context.
      if (env->can_call_into_js()) {
        HandleScope handle_scope(env->isolate());
        InternalCallbackScope callback_scope(this);
        SendPendingData();
      }
    });
  }",51,,1623,2,,void
189960,BLOCK,-1,,"{
  // If the session is already closing we don't want to stop reading as we want
  // to detect when the other peer is actually closed.
  if (is_reading_stopped() || is_closing()) return;
  int want_read = nghttp2_session_want_read(session_.get());
  Debug(this, ""wants read? %d"", want_read);
  if (want_read == 0 || is_write_in_progress()) {
    set_reading_stopped();
    stream_->ReadStop();
  }
}",39,,1647,1,,void
189965,BLOCK,-1,,<empty>,45,,1650,2,,void
189985,BLOCK,-1,,"{
    set_reading_stopped();
    stream_->ReadStop();
  }",49,,1653,2,,void
189995,BLOCK,-1,,"{
  CHECK(is_sending());

  set_sending(false);

  if (!outgoing_buffers_.empty()) {
    outgoing_storage_.clear();
    outgoing_length_ = 0;

    std::vector<NgHttp2StreamWrite> current_outgoing_buffers_;
    current_outgoing_buffers_.swap(outgoing_buffers_);
    for (const NgHttp2StreamWrite& wr : current_outgoing_buffers_) {
      BaseObjectPtr<AsyncWrap> wrap = std::move(wr.req_wrap);
      if (wrap) {
        // TODO(addaleax): Pass `status` instead of 0, so that we actually error
        // out with the error from the write to the underlying protocol,
        // if one occurred.
        WriteWrap::FromObject(wrap)->Done(0);
      }
    }
  }

  // Now that we've finished sending queued data, if there are any pending
  // RstStreams we should try sending again and then flush them one by one.
  if (!pending_rst_streams_.empty()) {
    std::vector<int32_t> current_pending_rst_streams;
    pending_rst_streams_.swap(current_pending_rst_streams);

    SendPendingData();

    for (in...",46,,1661,2,,void
190005,BLOCK,-1,,"{
    outgoing_storage_.clear();
    outgoing_length_ = 0;

    std::vector<NgHttp2StreamWrite> current_outgoing_buffers_;
    current_outgoing_buffers_.swap(outgoing_buffers_);
    for (const NgHttp2StreamWrite& wr : current_outgoing_buffers_) {
      BaseObjectPtr<AsyncWrap> wrap = std::move(wr.req_wrap);
      if (wrap) {
        // TODO(addaleax): Pass `status` instead of 0, so that we actually error
        // out with the error from the write to the underlying protocol,
        // if one occurred.
        WriteWrap::FromObject(wrap)->Done(0);
      }
    }
  }",35,,1666,2,,void
190028,BLOCK,-1,,"{
      BaseObjectPtr<AsyncWrap> wrap = std::move(wr.req_wrap);
      if (wrap) {
        // TODO(addaleax): Pass `status` instead of 0, so that we actually error
        // out with the error from the write to the underlying protocol,
        // if one occurred.
        WriteWrap::FromObject(wrap)->Done(0);
      }
    }",68,,1672,3,,void
190044,BLOCK,-1,,"{
        // TODO(addaleax): Pass `status` instead of 0, so that we actually error
        // out with the error from the write to the underlying protocol,
        // if one occurred.
        WriteWrap::FromObject(wrap)->Done(0);
      }",17,,1674,2,,void
190060,BLOCK,-1,,"{
    std::vector<int32_t> current_pending_rst_streams;
    pending_rst_streams_.swap(current_pending_rst_streams);

    SendPendingData();

    for (int32_t stream_id : current_pending_rst_streams) {
      BaseObjectPtr<Http2Stream> stream = FindStream(stream_id);
      if (LIKELY(stream))
        stream->FlushRstStream();
    }
  }",38,,1685,2,,void
190077,BLOCK,-1,,"{
      BaseObjectPtr<Http2Stream> stream = FindStream(stream_id);
      if (LIKELY(stream))
        stream->FlushRstStream();
    }",59,,1691,3,,void
190087,BLOCK,-1,,<empty>,11,,1693,1,,void
190089,BLOCK,-1,,<empty>,9,,1694,2,,void
190098,BLOCK,-1,,"{
  outgoing_length_ += write.buf.len;
  outgoing_buffers_.emplace_back(std::move(write));
}",67,,1699,2,,void
190120,BLOCK,-1,,"{
  size_t offset = outgoing_storage_.size();
  outgoing_storage_.resize(offset + src_length);
  memcpy(&outgoing_storage_[offset], src, src_length);

  // Store with a base of `nullptr` initially, since future resizes
  // of the outgoing_buffers_ vector may invalidate the pointer.
  // The correct base pointers will be set later, before writing to the
  // underlying socket.
  PushOutgoingBuffer(NgHttp2StreamWrite {
    uv_buf_init(nullptr, src_length)
  });
}",80,,1707,3,,void
190151,BLOCK,-1,,"{
  Debug(this, ""sending pending data"");
  // Do not attempt to send data on the socket if the destroying flag has
  // been set. That means everything is shutting down and the socket
  // will not be usable.
  if (is_destroyed())
    return 0;
  set_write_scheduled(false);

  // SendPendingData should not be called recursively.
  if (is_sending())
    return 1;
  // This is cleared by ClearOutgoing().
  set_sending();

  ssize_t src_length;
  const uint8_t* src;

  CHECK(outgoing_buffers_.empty());
  CHECK(outgoing_storage_.empty());

  // Part One: Gather data from nghttp2

  while ((src_length = nghttp2_session_mem_send(session_.get(), &src)) > 0) {
    Debug(this, ""nghttp2 has %d bytes to send"", src_length);
    CopyDataIntoOutgoing(src, src_length);
  }

  CHECK_NE(src_length, NGHTTP2_ERR_NOMEM);

  if (stream_ == nullptr) {
    // It would seem nice to bail out earlier, but `nghttp2_session_mem_send()`
    // does take care of things like closing the individual streams after
 ...",41,,1726,1,,void
190157,BLOCK,-1,,<empty>,5,,1732,2,,void
190164,BLOCK,-1,,<empty>,5,,1737,2,,void
190192,BLOCK,-1,,"{
    Debug(this, ""nghttp2 has %d bytes to send"", src_length);
    CopyDataIntoOutgoing(src, src_length);
  }",77,,1749,2,,void
190207,BLOCK,-1,,"{
    // It would seem nice to bail out earlier, but `nghttp2_session_mem_send()`
    // does take care of things like closing the individual streams after
    // a socket has been torn down, so we still need to call it.
    ClearOutgoing(UV_ECANCELED);
    return 0;
  }",27,,1756,2,,void
190222,BLOCK,-1,,"{
    ClearOutgoing(0);
    return 0;
  }",19,,1767,2,,void
190250,BLOCK,-1,,"{
    statistics_.data_sent += write.buf.len;
    if (write.buf.base == nullptr) {
      bufs[i++] = uv_buf_init(
          reinterpret_cast<char*>(outgoing_storage_.data() + offset),
          write.buf.len);
      offset += write.buf.len;
    } else {
      bufs[i++] = write.buf;
    }
  }",61,,1779,3,,void
190268,BLOCK,-1,,"{
      bufs[i++] = uv_buf_init(
          reinterpret_cast<char*>(outgoing_storage_.data() + offset),
          write.buf.len);
      offset += write.buf.len;
    }",36,,1781,2,,void
190296,BLOCK,-1,,"{
      bufs[i++] = write.buf;
    }",12,,1786,1,,void
190326,BLOCK,-1,,"{
    set_write_in_progress(false);
    ClearOutgoing(res.err);
  }",19,,1796,2,,void
190345,BLOCK,-1,,"{
  Http2Session* session = static_cast<Http2Session*>(user_data);
  BaseObjectPtr<Http2Stream> stream = session->FindStream(frame->hd.stream_id);
  if (!stream) return 0;

  // Send the frame header + a byte that indicates padding length.
  session->CopyDataIntoOutgoing(framehd, 9);
  if (frame->data.padlen > 0) {
    uint8_t padding_byte = frame->data.padlen - 1;
    CHECK_EQ(padding_byte, frame->data.padlen - 1);
    session->CopyDataIntoOutgoing(&padding_byte, 1);
  }

  Debug(session, ""nghttp2 has %d bytes to send directly"", length);
  while (length > 0) {
    // nghttp2 thinks that there is data available (length > 0), which means
    // we told it so, which means that we *should* have data available.
    CHECK(!stream->queue_.empty());

    NgHttp2StreamWrite& write = stream->queue_.front();
    if (write.buf.len <= length) {
      // This write does not suffice by itself, so we can consume it completely.
      length -= write.buf.len;
      session->PushOutgoingBuffer(std::m...",24,,1817,7,,void
190370,BLOCK,-1,,<empty>,16,,1820,2,,void
190387,BLOCK,-1,,"{
    uint8_t padding_byte = frame->data.padlen - 1;
    CHECK_EQ(padding_byte, frame->data.padlen - 1);
    session->CopyDataIntoOutgoing(&padding_byte, 1);
  }",31,,1824,2,,void
190422,BLOCK,-1,,"{
    // nghttp2 thinks that there is data available (length > 0), which means
    // we told it so, which means that we *should* have data available.
    CHECK(!stream->queue_.empty());

    NgHttp2StreamWrite& write = stream->queue_.front();
    if (write.buf.len <= length) {
      // This write does not suffice by itself, so we can consume it completely.
      length -= write.buf.len;
      session->PushOutgoingBuffer(std::move(write));
      stream->queue_.pop();
      continue;
    }

    // Slice off `length` bytes of the first write in the queue.
    session->PushOutgoingBuffer(NgHttp2StreamWrite {
      uv_buf_init(write.buf.base, length)
    });
    write.buf.base += length;
    write.buf.len -= length;
    break;
  }",22,,1831,2,,void
190448,BLOCK,-1,,"{
      // This write does not suffice by itself, so we can consume it completely.
      length -= write.buf.len;
      session->PushOutgoingBuffer(std::move(write));
      stream->queue_.pop();
      continue;
    }",34,,1837,2,,void
190508,BLOCK,-1,,"{
    // Send padding if that was requested.
    session->PushOutgoingBuffer(NgHttp2StreamWrite {
      uv_buf_init(const_cast<char*>(zero_bytes_256), frame->data.padlen - 1)
    });
  }",31,,1854,2,,void
190535,BLOCK,-1,,"{
  Debug(this, ""submitting request"");
  Http2Scope h2scope(this);
  Http2Stream* stream = nullptr;
  Http2Stream::Provider::Stream prov(options);
  *ret = nghttp2_submit_request(
      session_.get(),
      &priority,
      headers.data(),
      headers.length(),
      *prov,
      nullptr);
  CHECK_NE(*ret, NGHTTP2_ERR_NOMEM);
  if (LIKELY(*ret > 0))
    stream = Http2Stream::New(this, *ret, NGHTTP2_HCAT_HEADERS, options);
  return stream;
}",18,,1869,5,,void
190580,BLOCK,-1,,<empty>,5,,1883,2,,void
190598,BLOCK,-1,,"{
  return env()->allocate_managed_buffer(suggested_size);
}",61,,1887,2,,void
190610,BLOCK,-1,,"{
  HandleScope handle_scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  Http2Scope h2scope(this);
  CHECK_NOT_NULL(stream_);
  Debug(this, ""receiving %d bytes, offset %d"", nread, stream_buf_offset_);
  std::unique_ptr<BackingStore> bs = env()->release_managed_buffer(buf_);

  // Only pass data on if nread > 0
  if (nread <= 0) {
    if (nread < 0) {
      PassReadErrorToPreviousListener(nread);
    }
    return;
  }

  CHECK_LE(static_cast<size_t>(nread), bs->ByteLength());

  statistics_.data_received += nread;

  if (LIKELY(stream_buf_offset_ == 0)) {
    // Shrink to the actual amount of used data.
    bs = BackingStore::Reallocate(env()->isolate(), std::move(bs), nread);
  } else {
    // This is a very unlikely case, and should only happen if the ReadStart()
    // call in OnStreamAfterWrite() immediately provides data. If that does
    // happen, we concatenate the data we received with the already-stored
    // pending input data, slicing off the a...",70,,1892,3,,void
190649,BLOCK,-1,,"{
    if (nread < 0) {
      PassReadErrorToPreviousListener(nread);
    }
    return;
  }",19,,1901,2,,void
190654,BLOCK,-1,,"{
      PassReadErrorToPreviousListener(nread);
    }",20,,1902,2,,void
190676,BLOCK,-1,,"{
    // Shrink to the actual amount of used data.
    bs = BackingStore::Reallocate(env()->isolate(), std::move(bs), nread);
  }",40,,1912,2,,void
190694,BLOCK,-1,,"{
    // This is a very unlikely case, and should only happen if the ReadStart()
    // call in OnStreamAfterWrite() immediately provides data. If that does
    // happen, we concatenate the data we received with the already-stored
    // pending input data, slicing off the already processed part.
    size_t pending_len = stream_buf_.len - stream_buf_offset_;
    std::unique_ptr<BackingStore> new_bs;
    {
      NoArrayBufferZeroFillScope no_zero_fill_scope(env()->isolate_data());
      new_bs = ArrayBuffer::NewBackingStore(env()->isolate(),
                                            pending_len + nread);
    }
    memcpy(static_cast<char*>(new_bs->Data()),
           stream_buf_.base + stream_buf_offset_,
           pending_len);
    memcpy(static_cast<char*>(new_bs->Data()) + pending_len,
           bs->Data(),
           nread);

    bs = std::move(new_bs);
    nread = bs->ByteLength();
    stream_buf_offset_ = 0;
    stream_buf_ab_.Reset();

    // We have now fully processed t...",10,,1915,1,,void
190710,BLOCK,4,,"{
      NoArrayBufferZeroFillScope no_zero_fill_scope(env()->isolate_data());
      new_bs = ArrayBuffer::NewBackingStore(env()->isolate(),
                                            pending_len + nread);
    }",5,,1922,4,,void
190808,BLOCK,-1,,"{
  for (const NgHttp2StreamWrite& wr : outgoing_buffers_) {
    if (wr.req_wrap && WriteWrap::FromObject(wr.req_wrap)->stream() == stream)
      return true;
  }
  return false;
}",68,,1961,2,,void
190812,BLOCK,-1,,"{
    if (wr.req_wrap && WriteWrap::FromObject(wr.req_wrap)->stream() == stream)
      return true;
  }",58,,1962,3,,void
190830,BLOCK,-1,,<empty>,7,,1964,2,,void
190839,BLOCK,-1,,"{
  StreamBase* stream = StreamBase::FromObject(stream_obj);
  stream->PushStreamListener(this);
  Debug(this, ""i/o stream consumed"");
}",54,,1973,2,,void
190860,BLOCK,-1,,"{
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  CHECK(args[0]->IsObject());

  ArrayBufferViewContents<char> buffer(args[0]);
  const char* data = buffer.data();
  size_t len = buffer.length();
  Debug(session, ""Receiving %zu bytes injected from JS"", len);

  // Copy given buffer
  while (len > 0) {
    uv_buf_t buf = session->OnStreamAlloc(len);
    size_t copy = buf.len > len ? len : buf.len;
    memcpy(buf.base, data, copy);
    buf.len = copy;
    session->OnStreamRead(copy, buf);

    data += copy;
    len -= copy;
  }
}",69,,1983,2,,void
190903,BLOCK,-1,,"{
    uv_buf_t buf = session->OnStreamAlloc(len);
    size_t copy = buf.len > len ? len : buf.len;
    memcpy(buf.base, data, copy);
    buf.len = copy;
    session->OnStreamRead(copy, buf);

    data += copy;
    len -= copy;
  }",19,,1994,2,,void
190955,BLOCK,-1,,"{
  Local<Object> obj;
  if (!session->env()
           ->http2stream_constructor_template()
           ->NewInstance(session->env()->context())
           .ToLocal(&obj)) {
    return nullptr;
  }
  return new Http2Stream(session, obj, id, category, options);
}",44,,2009,5,,void
190985,BLOCK,-1,,"{
    return nullptr;
  }",28,,2014,2,,void
191004,BLOCK,-1,,"{
  MakeWeak();
  StreamBase::AttachToObject(GetObject());
  statistics_.id = id;
  statistics_.start_time = uv_hrtime();

  // Limit the number of header pairs
  max_header_pairs_ = session->max_header_pairs();
  if (max_header_pairs_ == 0) {
    max_header_pairs_ = DEFAULT_MAX_HEADER_LIST_PAIRS;
  }
  current_headers_.reserve(std::min(max_header_pairs_, 12u));

  // Limit the number of header octets
  max_header_length_ =
      std::min(
        nghttp2_session_get_local_settings(
          session->session(),
          NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE),
      MAX_MAX_HEADER_LIST_SIZE);

  if (options & STREAM_OPTION_GET_TRAILERS)
    set_has_trailers();

  PushStreamListener(&stream_listener_);

  if (options & STREAM_OPTION_EMPTY_PAYLOAD)
    Shutdown();
  session->AddStream(this);
}",43,,2029,6,,void
191027,BLOCK,-1,,"{
    max_header_pairs_ = DEFAULT_MAX_HEADER_LIST_PAIRS;
  }",31,,2037,2,,void
191058,BLOCK,-1,,<empty>,5,,2051,2,,void
191065,BLOCK,-1,,<empty>,5,,2056,2,,void
191075,BLOCK,-1,,"{
  Debug(this, ""tearing down stream"");
}",29,,2060,1,,void
191083,BLOCK,-1,,"{
  tracker->TrackField(""current_headers"", current_headers_);
  tracker->TrackField(""queue"", queue_);
}",60,,2064,2,,void
191099,BLOCK,-1,,"{
  const Http2Session* sess = session();
  const std::string sname =
      sess ? sess->diagnostic_name() : ""session already destroyed"";
  return ""HttpStream "" + std::to_string(id()) + "" ("" +
         std::to_string(static_cast<int64_t>(get_async_id())) + "") ["" + sname +
         ""]"";
}",50,,2069,1,,void
191142,BLOCK,-1,,"{
  Debug(this, ""starting headers, category: %d"", category);
  CHECK(!this->is_destroyed());
  session_->DecrementCurrentSessionMemory(current_headers_length_);
  current_headers_length_ = 0;
  current_headers_.clear();
  current_headers_category_ = category;
}",67,,2079,2,,void
191171,BLOCK,-1,,{ return stream(); },48,,2089,1,,void
191177,BLOCK,-1,,"{
  return nghttp2_session_find_stream(session_->session(), id_);
}",45,,2091,1,,void
191189,BLOCK,-1,,"{
  CHECK(!this->is_destroyed());
  set_closed();
  code_ = code;
  Debug(this, ""closed with code %d"", code);
}",39,,2095,2,,void
191208,BLOCK,-1,,"{
  // DoShutdown() always finishes synchronously, so there's no need to create
  // a structure to store asynchronous context.
  return nullptr;
}",69,,2102,2,,void
191215,BLOCK,-1,,"{
  if (is_destroyed())
    return UV_EPIPE;

  {
    Http2Scope h2scope(this);
    set_not_writable();
    CHECK_NE(nghttp2_session_resume_data(
        session_->session(), id_),
        NGHTTP2_ERR_NOMEM);
    Debug(this, ""writable side shutdown"");
  }
  return 1;
}",53,,2108,2,,void
191218,BLOCK,-1,,<empty>,5,,2110,2,,void
191221,BLOCK,2,,"{
    Http2Scope h2scope(this);
    set_not_writable();
    CHECK_NE(nghttp2_session_resume_data(
        session_->session(), id_),
        NGHTTP2_ERR_NOMEM);
    Debug(this, ""writable side shutdown"");
  }",3,,2112,2,,void
191242,BLOCK,-1,,"{
  // Do nothing if this stream instance is already destroyed
  if (is_destroyed())
    return;
  if (session_->has_pending_rststream(id_))
    FlushRstStream();
  set_destroyed();

  Debug(this, ""destroying stream"");

  // Wait until the start of the next loop to delete because there
  // may still be some pending operations queued for this stream.
  BaseObjectPtr<Http2Stream> strong_ref = session_->RemoveStream(id_);
  if (strong_ref) {
    env()->SetImmediate([this, strong_ref = std::move(strong_ref)](
        Environment* env) {
      // Free any remaining outgoing data chunks here. This should be done
      // here because it's possible for destroy to have been called while
      // we still have queued outbound writes.
      while (!queue_.empty()) {
        NgHttp2StreamWrite& head = queue_.front();
        if (head.req_wrap)
          WriteWrap::FromObject(head.req_wrap)->Done(UV_ECANCELED);
        queue_.pop();
      }

      // We can destroy the stream now if there are ...",29,,2126,1,,void
191245,BLOCK,-1,,<empty>,5,,2129,2,,void
191253,BLOCK,-1,,<empty>,5,,2131,2,,void
191272,BLOCK,-1,,"{
    env()->SetImmediate([this, strong_ref = std::move(strong_ref)](
        Environment* env) {
      // Free any remaining outgoing data chunks here. This should be done
      // here because it's possible for destroy to have been called while
      // we still have queued outbound writes.
      while (!queue_.empty()) {
        NgHttp2StreamWrite& head = queue_.front();
        if (head.req_wrap)
          WriteWrap::FromObject(head.req_wrap)->Done(UV_ECANCELED);
        queue_.pop();
      }

      // We can destroy the stream now if there are no writes for it
      // already on the socket. Otherwise, we'll wait for the garbage collector
      // to take care of cleaning up.
      if (session() == nullptr ||
          !session()->HasWritesOnSocketForStream(this)) {
        // Delete once strong_ref goes out of scope.
        Detach();
      }
    });
  }",19,,2139,2,,void
191310,BLOCK,-1,,"{
  CHECK(!this->is_destroyed());
  Http2Scope h2scope(this);
  Debug(this, ""submitting response"");
  if (options & STREAM_OPTION_GET_TRAILERS)
    set_has_trailers();

  if (!is_writable())
    options |= STREAM_OPTION_EMPTY_PAYLOAD;

  Http2Stream::Provider::Stream prov(this, options);
  int ret = nghttp2_submit_response(
      session_->session(),
      id_,
      headers.data(),
      headers.length(),
      *prov);
  CHECK_NE(ret, NGHTTP2_ERR_NOMEM);
  return ret;
}",75,,2173,3,,void
191327,BLOCK,-1,,<empty>,5,,2178,2,,void
191332,BLOCK,-1,,<empty>,5,,2181,2,,void
191368,BLOCK,-1,,"{
  CHECK(!this->is_destroyed());
  Http2Scope h2scope(this);
  Debug(this, ""sending %d informational headers"", headers.length());
  int ret = nghttp2_submit_headers(
      session_->session(),
      NGHTTP2_FLAG_NONE,
      id_,
      nullptr,
      headers.data(),
      headers.length(),
      nullptr);
  CHECK_NE(ret, NGHTTP2_ERR_NOMEM);
  return ret;
}",58,,2196,2,,void
191413,BLOCK,-1,,"{
  Debug(this, ""let javascript know we are ready for trailers"");
  CHECK(!this->is_destroyed());
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);
  set_has_trailers(false);
  MakeCallback(env()->http2session_on_stream_trailers_function(), 0, nullptr);
}",32,,2212,1,,void
191459,BLOCK,-1,,"{
  CHECK(!this->is_destroyed());
  Http2Scope h2scope(this);
  Debug(this, ""sending %d trailers"", headers.length());
  int ret;
  // Sending an empty trailers frame poses problems in Safari, Edge & IE.
  // Instead we can just send an empty data frame with NGHTTP2_FLAG_END_STREAM
  // to indicate that the stream is ready to be closed.
  if (headers.length() == 0) {
    Http2Stream::Provider::Stream prov(this, 0);
    ret = nghttp2_submit_data(
        session_->session(),
        NGHTTP2_FLAG_END_STREAM,
        id_,
        *prov);
  } else {
    ret = nghttp2_submit_trailer(
        session_->session(),
        id_,
        headers.data(),
        headers.length());
  }
  CHECK_NE(ret, NGHTTP2_ERR_NOMEM);
  return ret;
}",62,,2224,2,,void
191484,BLOCK,-1,,"{
    Http2Stream::Provider::Stream prov(this, 0);
    ret = nghttp2_submit_data(
        session_->session(),
        NGHTTP2_FLAG_END_STREAM,
        id_,
        *prov);
  }",30,,2232,2,,void
191501,BLOCK,-1,,"{
    ret = nghttp2_submit_trailer(
        session_->session(),
        id_,
        headers.data(),
        headers.length());
  }",10,,2239,1,,void
191528,BLOCK,-1,,"{
  CHECK(!this->is_destroyed());
  Http2Scope h2scope(this);
  Debug(this, ""sending priority spec"");
  int ret = silent ?
      nghttp2_session_change_stream_priority(
          session_->session(),
          id_,
          &priority) :
      nghttp2_submit_priority(
          session_->session(),
          NGHTTP2_FLAG_NONE,
          id_, &priority);
  CHECK_NE(ret, NGHTTP2_ERR_NOMEM);
  return ret;
}",46,,2252,3,,void
191571,BLOCK,-1,,"{
  CHECK(!this->is_destroyed());
  code_ = code;

  auto is_stream_cancel = [](const uint32_t code) {
    return code == NGHTTP2_CANCEL;
  };

  // If RST_STREAM frame is received with error code NGHTTP2_CANCEL,
  // add it to the pending list and don't force purge the data. It is
  // to avoids the double free error due to unwanted behavior of nghttp2.

  // Add stream to the pending list only if it is received with scope
  // below in the stack. The pending list may not get processed
  // if RST_STREAM received is not in scope and added to the list
  // causing endpoint to hang.
  if (session_->is_in_scope() && is_stream_cancel(code)) {
      session_->AddPendingRstStream(id_);
      return;
  }


  // If possible, force a purge of any currently pending data here to make sure
  // it is sent before closing the stream. If it returns non-zero then we need
  // to wait until the current write finishes and try again to avoid nghttp2
  // behaviour where it prioritizes RstStream over ...",56,,2271,2,,void
191593,BLOCK,-1,,"{
      session_->AddPendingRstStream(id_);
      return;
  }",58,,2287,2,,void
191607,BLOCK,-1,,"{
    session_->AddPendingRstStream(id_);
    return;
  }",41,,2297,2,,void
191618,BLOCK,-1,,"{
  if (is_destroyed())
    return;
  Http2Scope h2scope(this);
  CHECK_EQ(nghttp2_submit_rst_stream(
      session_->session(),
      NGHTTP2_FLAG_NONE,
      id_,
      code_), 0);
}",36,,2305,1,,void
191621,BLOCK,-1,,<empty>,5,,2307,2,,void
191642,BLOCK,-1,,"{
  CHECK(!this->is_destroyed());
  Http2Scope h2scope(this);
  Debug(this, ""sending push promise"");
  *ret = nghttp2_submit_push_promise(
      session_->session(),
      NGHTTP2_FLAG_NONE,
      id_,
      headers.data(),
      headers.length(),
      nullptr);
  CHECK_NE(*ret, NGHTTP2_ERR_NOMEM);
  Http2Stream* stream = nullptr;
  if (*ret > 0) {
    stream = Http2Stream::New(
        session_.get(), *ret, NGHTTP2_HCAT_HEADERS, options);
  }

  return stream;
}",58,,2320,4,,void
191687,BLOCK,-1,,"{
    stream = Http2Stream::New(
        session_.get(), *ret, NGHTTP2_HCAT_HEADERS, options);
  }",17,,2333,2,,void
191707,BLOCK,-1,,"{
  Http2Scope h2scope(this);
  CHECK(!this->is_destroyed());
  set_reading();

  Debug(this, ""reading starting"");

  // Tell nghttp2 about our consumption of the data that was handed
  // off to JS land.
  nghttp2_session_consume_stream(
      session_->session(),
      id_,
      inbound_consumed_data_while_paused_);
  inbound_consumed_data_while_paused_ = 0;

  return 0;
}",30,,2343,1,,void
191736,BLOCK,-1,,"{
  CHECK(!this->is_destroyed());
  if (!is_reading())
    return 0;
  set_paused();
  Debug(this, ""reading stopped"");
  return 0;
}",29,,2362,1,,void
191746,BLOCK,-1,,<empty>,5,,2365,2,,void
191762,BLOCK,-1,,"{
  CHECK_NULL(send_handle);
  Http2Scope h2scope(this);
  if (!is_writable() || is_destroyed()) {
    return UV_EOF;
  }
  Debug(this, ""queuing %d buffers to send"", nbufs);
  for (size_t i = 0; i < nbufs; ++i) {
    // Store the req_wrap on the last write info in the queue, so that it is
    // only marked as finished once all buffers associated with it are finished.
    queue_.emplace(NgHttp2StreamWrite {
      BaseObjectPtr<AsyncWrap>(
          i == nbufs - 1 ? req_wrap->GetAsyncWrap() : nullptr),
      bufs[i]
    });
    IncrementAvailableOutboundLength(bufs[i].len);
  }
  CHECK_NE(nghttp2_session_resume_data(
      session_->session(),
      id_), NGHTTP2_ERR_NOMEM);
  return 0;
}",52,,2384,5,,void
191773,BLOCK,-1,,"{
    return UV_EOF;
  }",41,,2387,2,,void
191781,BLOCK,-1,,<empty>,3,,2391,1,,void
191791,BLOCK,4,,"{
    // Store the req_wrap on the last write info in the queue, so that it is
    // only marked as finished once all buffers associated with it are finished.
    queue_.emplace(NgHttp2StreamWrite {
      BaseObjectPtr<AsyncWrap>(
          i == nbufs - 1 ? req_wrap->GetAsyncWrap() : nullptr),
      bufs[i]
    });
    IncrementAvailableOutboundLength(bufs[i].len);
  }",38,,2391,4,,void
191838,BLOCK,-1,,"{
  CHECK(!this->is_destroyed());

  if (Http2RcBufferPointer::IsZeroLength(name))
    return true;  // Ignore empty headers.

  Http2Header header(env(), name, value, flags);
  size_t length = header.length() + 32;
  // A header can only be added if we have not exceeded the maximum number
  // of headers and the session has memory available for it.
  if (!session_->has_available_session_memory(length) ||
      current_headers_.size() == max_header_pairs_ ||
      current_headers_length_ + length > max_header_length_) {
    return false;
  }

  if (statistics_.first_header == 0)
    statistics_.first_header = uv_hrtime();

  current_headers_.push_back(std::move(header));

  current_headers_length_ += length;
  session_->IncrementCurrentSessionMemory(length);
  return true;
}",44,,2414,4,,void
191851,BLOCK,-1,,<empty>,5,,2418,2,,void
191889,BLOCK,-1,,"{
    return false;
  }",62,,2426,2,,void
191898,BLOCK,-1,,<empty>,5,,2431,2,,void
191928,BLOCK,-1,,"{
  CHECK(!stream->is_destroyed());
  provider_.source.ptr = stream;
  empty_ = options & STREAM_OPTION_EMPTY_PAYLOAD;
}",67,,2441,3,,void
191951,BLOCK,-1,,"{
  provider_.source.ptr = nullptr;
  empty_ = options & STREAM_OPTION_EMPTY_PAYLOAD;
}",46,,2447,2,,void
191967,BLOCK,-1,,"{
  provider_.source.ptr = nullptr;
}",36,,2452,1,,void
191979,BLOCK,-1,,"{
  provider_.read_callback = Http2Stream::Provider::Stream::OnRead;
}",38,,2459,2,,void
191996,BLOCK,-1,,"{
  provider_.read_callback = Http2Stream::Provider::Stream::OnRead;
}",46,,2464,3,,void
192018,BLOCK,-1,,"{
  Http2Session* session = static_cast<Http2Session*>(user_data);
  Debug(session, ""reading outbound data for stream %d"", id);
  BaseObjectPtr<Http2Stream> stream = session->FindStream(id);
  if (!stream) return 0;
  if (stream->statistics_.first_byte_sent == 0)
    stream->statistics_.first_byte_sent = uv_hrtime();
  CHECK_EQ(id, stream->id());

  size_t amount = 0;          // amount of data being sent in this data frame.

  // Remove all empty chunks from the head of the queue.
  // This is done here so that .write('', cb) is still a meaningful way to
  // find out when the HTTP2 stream wants to consume data, and because the
  // StreamBase API allows empty input chunks.
  while (!stream->queue_.empty() && stream->queue_.front().buf.len == 0) {
    BaseObjectPtr<AsyncWrap> finished =
        std::move(stream->queue_.front().req_wrap);
    stream->queue_.pop();
    if (finished)
      WriteWrap::FromObject(finished)->Done(0);
  }

  if (!stream->queue_.empty()) {
    Debug(sessio...",64,,2474,8,,void
192043,BLOCK,-1,,<empty>,16,,2478,2,,void
192054,BLOCK,-1,,<empty>,5,,2480,2,,void
192093,BLOCK,-1,,"{
    BaseObjectPtr<AsyncWrap> finished =
        std::move(stream->queue_.front().req_wrap);
    stream->queue_.pop();
    if (finished)
      WriteWrap::FromObject(finished)->Done(0);
  }",74,,2489,2,,void
192120,BLOCK,-1,,<empty>,7,,2494,2,,void
192138,BLOCK,-1,,"{
    Debug(session, ""stream %d has pending outbound data"", id);
    amount = std::min(stream->available_outbound_length_, length);
    Debug(session, ""sending %d bytes for data frame on stream %d"", amount, id);
    if (amount > 0) {
      // Just return the length, let Http2Session::OnSendData take care of
      // actually taking the buffers out of the queue.
      *flags |= NGHTTP2_DATA_FLAG_NO_COPY;
      stream->DecrementAvailableOutboundLength(amount);
    }
  }",32,,2497,2,,void
192162,BLOCK,-1,,"{
      // Just return the length, let Http2Session::OnSendData take care of
      // actually taking the buffers out of the queue.
      *flags |= NGHTTP2_DATA_FLAG_NO_COPY;
      stream->DecrementAvailableOutboundLength(amount);
    }",21,,2501,2,,void
192181,BLOCK,-1,,"{
    CHECK(stream->queue_.empty());
    Debug(session, ""deferring stream %d"", id);
    stream->EmitWantsWrite(length);
    if (stream->available_outbound_length_ > 0 || !stream->is_writable()) {
      // EmitWantsWrite() did something interesting synchronously, restart:
      return OnRead(handle, id, buf, length, flags, source, user_data);
    }
    return NGHTTP2_ERR_DEFERRED;
  }",45,,2509,2,,void
192210,BLOCK,-1,,"{
      // EmitWantsWrite() did something interesting synchronously, restart:
      return OnRead(handle, id, buf, length, flags, source, user_data);
    }",75,,2513,2,,void
192234,BLOCK,-1,,"{
    Debug(session, ""no more data for stream %d"", id);
    *flags |= NGHTTP2_DATA_FLAG_EOF;
    if (stream->has_trailers()) {
      *flags |= NGHTTP2_DATA_FLAG_NO_END_STREAM;
      stream->OnTrailers();
    }
  }",74,,2520,2,,void
192248,BLOCK,-1,,"{
      *flags |= NGHTTP2_DATA_FLAG_NO_END_STREAM;
      stream->OnTrailers();
    }",33,,2523,2,,void
192270,BLOCK,-1,,"{
  available_outbound_length_ += amount;
  session_->IncrementCurrentSessionMemory(amount);
}",67,,2533,2,,void
192283,BLOCK,-1,,"{
  available_outbound_length_ -= amount;
  session_->DecrementCurrentSessionMemory(amount);
}",67,,2538,2,,void
192296,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  uint32_t val = args[0]->Uint32Value(env->context()).ToChecked();
  args.GetReturnValue().Set(
      OneByteString(
          env->isolate(),
          reinterpret_cast<const uint8_t*>(nghttp2_strerror(val))));
}",63,,2548,2,,void
192341,BLOCK,-1,,"{
  Http2State* state = Realm::GetBindingData<Http2State>(args);
  args.GetReturnValue().Set(Http2Settings::Pack(state));
}",60,,2561,2,,void
192368,BLOCK,-1,,"{
  Http2State* state = Realm::GetBindingData<Http2State>(args);
  Http2Settings::RefreshDefaults(state);
}",70,,2569,2,,void
192388,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  int32_t id = args[0]->Int32Value(env->context()).ToChecked();
  if (nghttp2_session_set_next_stream_id(session->session(), id) < 0) {
    Debug(session, ""failed to set next stream id to %d"", id);
    return args.GetReturnValue().Set(false);
  }
  args.GetReturnValue().Set(true);
  Debug(session, ""set next stream id to %d"", id);
}",77,,2575,2,,void
192430,BLOCK,-1,,"{
    Debug(session, ""failed to set next stream id to %d"", id);
    return args.GetReturnValue().Set(false);
  }",71,,2580,2,,void
192460,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());

  int32_t window_size = args[0]->Int32Value(env->context()).ToChecked();

  int result = nghttp2_session_set_local_window_size(
      session->session(), NGHTTP2_FLAG_NONE, 0, window_size);

  args.GetReturnValue().Set(result);

  Debug(session, ""set local window size to %d"", window_size);
}",46,,2592,2,,void
192520,BLOCK,-1,,"{
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  Http2Settings::Update(session, fn);
  Debug(session, ""settings refreshed for session"");
}",77,,2611,2,,void
192542,BLOCK,-1,,"{
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  Debug(session, ""refreshing state"");

  AliasedFloat64Array& buffer = session->http2_state()->session_state_buffer;

  nghttp2_session* s = session->session();

  buffer[IDX_SESSION_STATE_EFFECTIVE_LOCAL_WINDOW_SIZE] =
      nghttp2_session_get_effective_local_window_size(s);
  buffer[IDX_SESSION_STATE_EFFECTIVE_RECV_DATA_LENGTH] =
      nghttp2_session_get_effective_recv_data_length(s);
  buffer[IDX_SESSION_STATE_NEXT_STREAM_ID] =
      nghttp2_session_get_next_stream_id(s);
  buffer[IDX_SESSION_STATE_LOCAL_WINDOW_SIZE] =
      nghttp2_session_get_local_window_size(s);
  buffer[IDX_SESSION_STATE_LAST_PROC_STREAM_ID] =
      nghttp2_session_get_last_proc_stream_id(s);
  buffer[IDX_SESSION_STATE_REMOTE_WINDOW_SIZE] =
      nghttp2_session_get_remote_window_size(s);
  buffer[IDX_SESSION_STATE_OUTBOUND_QUEUE_SIZE] =
      static_cast<double>(nghttp2_session_get_outbound_queue_size(s));
  buffer[IDX_SESSION_...",74,,2621,2,,void
192634,BLOCK,-1,,"{
  Http2State* state = Realm::GetBindingData<Http2State>(args);
  Environment* env = state->env();
  CHECK(args.IsConstructCall());
  SessionType type =
      static_cast<SessionType>(
          args[0]->Int32Value(env->context()).ToChecked());
  Http2Session* session = new Http2Session(state, args.This(), type);
  Debug(session, ""session created"");
}",65,,2652,2,,void
192693,BLOCK,-1,,"{
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  CHECK(args[0]->IsObject());
  session->Consume(args[0].As<Object>());
}",69,,2665,2,,void
192723,BLOCK,-1,,"{
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  Debug(session, ""destroying session"");
  Environment* env = Environment::GetCurrent(args);
  Local<Context> context = env->context();

  uint32_t code = args[0]->Uint32Value(context).ToChecked();
  session->Close(code, args[1]->IsTrue());
}",69,,2673,2,,void
192781,BLOCK,-1,,"{
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  Environment* env = session->env();

  Local<Array> headers = args[0].As<Array>();
  int32_t options = args[1]->Int32Value(env->context()).ToChecked();

  Debug(session, ""request submitted"");

  int32_t ret = 0;
  Http2Stream* stream =
      session->Http2Session::SubmitRequest(
          Http2Priority(env, args[2], args[3], args[4]),
          Http2Headers(env, headers),
          &ret,
          static_cast<int>(options));

  if (ret <= 0 || stream == nullptr) {
    Debug(session, ""could not submit request: %s"", nghttp2_strerror(ret));
    return args.GetReturnValue().Set(ret);
  }

  Debug(session, ""request submitted, new stream id %d"", stream->id());
  args.GetReturnValue().Set(stream->object());
}",69,,2686,2,,void
192866,BLOCK,-1,,"{
    Debug(session, ""could not submit request: %s"", nghttp2_strerror(ret));
    return args.GetReturnValue().Set(ret);
  }",38,,2704,2,,void
192906,BLOCK,-1,,"{
  if (is_destroyed())
    return;

  Http2Scope h2scope(this);
  // the last proc stream id is the most recently created Http2Stream.
  if (lastStreamID <= 0)
    lastStreamID = nghttp2_session_get_last_proc_stream_id(session_.get());
  Debug(this, ""submitting goaway"");
  nghttp2_submit_goaway(session_.get(), NGHTTP2_FLAG_NONE,
                        lastStreamID, code, data, len);
}",39,,2719,5,,void
192909,BLOCK,-1,,<empty>,5,,2721,2,,void
192918,BLOCK,-1,,<empty>,5,,2726,2,,void
192943,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Local<Context> context = env->context();
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());

  uint32_t code = args[0]->Uint32Value(context).ToChecked();
  int32_t lastStreamID = args[1]->Int32Value(context).ToChecked();
  ArrayBufferViewContents<uint8_t> opaque_data;

  if (args[2]->IsArrayBufferView()) {
    opaque_data.Read(args[2].As<ArrayBufferView>());
  }

  session->Goaway(code, lastStreamID, opaque_data.data(), opaque_data.length());
}",68,,2735,2,,void
193008,BLOCK,-1,,"{
    opaque_data.Read(args[2].As<ArrayBufferView>());
  }",37,,2745,2,,void
193037,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  HandleScope scope(isolate);
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());

  uint32_t length = session->chunks_sent_since_last_write_;

  session->object()->Set(env->context(),
                         env->chunks_sent_since_last_write_string(),
                         Integer::NewFromUnsigned(isolate, length)).Check();

  args.GetReturnValue().Set(length);
}",78,,2754,2,,void
193106,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Local<Context> context = env->context();
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());
  uint32_t code = args[0]->Uint32Value(context).ToChecked();
  Debug(stream, ""sending rst_stream with code %d"", code);
  stream->SubmitRstStream(code);
}",70,,2773,2,,void
193159,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());

  Local<Array> headers = args[0].As<Array>();
  int32_t options = args[1]->Int32Value(env->context()).ToChecked();

  args.GetReturnValue().Set(
      stream->SubmitResponse(
          Http2Headers(env, headers),
          static_cast<int>(options)));
  Debug(stream, ""response submitted"");
}",68,,2785,2,,void
193228,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());

  Local<Array> headers = args[0].As<Array>();

  args.GetReturnValue().Set(stream->SubmitInfo(Http2Headers(env, headers)));
}",65,,2802,2,,void
193275,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());

  Local<Array> headers = args[0].As<Array>();

  args.GetReturnValue().Set(
      stream->SubmitTrailers(Http2Headers(env, headers)));
}",69,,2813,2,,void
193322,BLOCK,-1,,"{
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());
  args.GetReturnValue().Set(stream->id());
}",66,,2825,2,,void
193346,BLOCK,-1,,"{
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());
  Debug(stream, ""destroying stream"");
  stream->Destroy();
}",68,,2832,2,,void
193366,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Http2Stream* parent;
  ASSIGN_OR_RETURN_UNWRAP(&parent, args.Holder());

  Local<Array> headers = args[0].As<Array>();
  int32_t options = args[1]->Int32Value(env->context()).ToChecked();

  Debug(parent, ""creating push promise"");

  int32_t ret = 0;
  Http2Stream* stream =
      parent->SubmitPushPromise(
          Http2Headers(env, headers),
          &ret,
          static_cast<int>(options));

  if (ret <= 0 || stream == nullptr) {
    Debug(parent, ""failed to create push stream: %d"", ret);
    return args.GetReturnValue().Set(ret);
  }
  Debug(parent, ""push stream %d created"", stream->id());
  args.GetReturnValue().Set(stream->object());
}",72,,2840,2,,void
193441,BLOCK,-1,,"{
    Debug(parent, ""failed to create push stream: %d"", ret);
    return args.GetReturnValue().Set(ret);
  }",38,,2857,2,,void
193477,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());

  CHECK_EQ(stream->SubmitPriority(
      Http2Priority(env, args[0], args[1], args[2]),
      args[3]->IsTrue()), 0);
  Debug(stream, ""priority submitted"");
}",69,,2866,2,,void
193524,BLOCK,-1,,"{
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());

  Debug(stream, ""refreshing state"");

  CHECK_NOT_NULL(stream->session());
  AliasedFloat64Array& buffer =
      stream->session()->http2_state()->stream_state_buffer;

  nghttp2_stream* str = stream->stream();
  nghttp2_session* s = stream->session()->session();

  if (str == nullptr) {
    buffer[IDX_STREAM_STATE] = NGHTTP2_STREAM_STATE_IDLE;
    buffer[IDX_STREAM_STATE_WEIGHT] =
        buffer[IDX_STREAM_STATE_SUM_DEPENDENCY_WEIGHT] =
        buffer[IDX_STREAM_STATE_LOCAL_CLOSE] =
        buffer[IDX_STREAM_STATE_REMOTE_CLOSE] =
        buffer[IDX_STREAM_STATE_LOCAL_WINDOW_SIZE] = 0;
  } else {
    buffer[IDX_STREAM_STATE] =
        nghttp2_stream_get_state(str);
    buffer[IDX_STREAM_STATE_WEIGHT] =
        nghttp2_stream_get_weight(str);
    buffer[IDX_STREAM_STATE_SUM_DEPENDENCY_WEIGHT] =
        nghttp2_stream_get_sum_dependency_weight(str);
    buffer[IDX_STREAM_STATE_LOCAL_CLOSE] =
        nghttp2_s...",73,,2880,2,,void
193574,BLOCK,-1,,"{
    buffer[IDX_STREAM_STATE] = NGHTTP2_STREAM_STATE_IDLE;
    buffer[IDX_STREAM_STATE_WEIGHT] =
        buffer[IDX_STREAM_STATE_SUM_DEPENDENCY_WEIGHT] =
        buffer[IDX_STREAM_STATE_LOCAL_CLOSE] =
        buffer[IDX_STREAM_STATE_REMOTE_CLOSE] =
        buffer[IDX_STREAM_STATE_LOCAL_WINDOW_SIZE] = 0;
  }",23,,2893,2,,void
193602,BLOCK,-1,,"{
    buffer[IDX_STREAM_STATE] =
        nghttp2_stream_get_state(str);
    buffer[IDX_STREAM_STATE_WEIGHT] =
        nghttp2_stream_get_weight(str);
    buffer[IDX_STREAM_STATE_SUM_DEPENDENCY_WEIGHT] =
        nghttp2_stream_get_sum_dependency_weight(str);
    buffer[IDX_STREAM_STATE_LOCAL_CLOSE] =
        nghttp2_session_get_stream_local_close(s, stream->id());
    buffer[IDX_STREAM_STATE_REMOTE_CLOSE] =
        nghttp2_session_get_stream_remote_close(s, stream->id());
    buffer[IDX_STREAM_STATE_LOCAL_WINDOW_SIZE] =
        nghttp2_session_get_stream_local_window_size(s, stream->id());
  }",10,,2900,1,,void
193659,BLOCK,-1,,"{
  Http2Scope h2scope(this);
  CHECK_EQ(nghttp2_submit_altsvc(session_.get(), NGHTTP2_FLAG_NONE, id,
                                 origin, origin_len, value, value_len), 0);
}",45,,2920,6,,void
193680,BLOCK,-1,,"{
  Http2Scope h2scope(this);
  CHECK_EQ(nghttp2_submit_origin(
      session_.get(),
      NGHTTP2_FLAG_NONE,
      *origins,
      origins.length()), 0);
}",51,,2926,2,,void
193702,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());

  int32_t id = args[0]->Int32Value(env->context()).ToChecked();

  // origin and value are both required to be ASCII, handle them as such.
  Local<String> origin_str = args[1]->ToString(env->context()).ToLocalChecked();
  Local<String> value_str = args[2]->ToString(env->context()).ToLocalChecked();

  if (origin_str.IsEmpty() || value_str.IsEmpty())
    return;

  size_t origin_len = origin_str->Length();
  size_t value_len = value_str->Length();

  CHECK_LE(origin_len + value_len, 16382);  // Max permitted for ALTSVC
  // Verify that origin len != 0 if stream id == 0, or
  // that origin len == 0 if stream id != 0
  CHECK((origin_len != 0 && id == 0) || (origin_len == 0 && id != 0));

  MaybeStackBuffer<uint8_t> origin(origin_len);
  MaybeStackBuffer<uint8_t> value(value_len);
  origin_str->WriteOneByte(env->isolate(), *origin);
  value_str->WriteOneBy...",68,,2936,2,,void
193783,BLOCK,-1,,<empty>,5,,2948,2,,void
193867,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Local<Context> context = env->context();
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());

  Local<String> origin_string = args[0].As<String>();
  size_t count = args[1]->Int32Value(context).ToChecked();

  session->Origin(Origins(env, origin_string, count));
}",68,,2966,2,,void
193931,BLOCK,-1,,"{
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());

  // A PING frame may have exactly 8 bytes of payload data. If not provided,
  // then the current hrtime will be used as the payload.
  ArrayBufferViewContents<uint8_t, 8> payload;
  if (args[0]->IsArrayBufferView()) {
    payload.Read(args[0].As<ArrayBufferView>());
    CHECK_EQ(payload.length(), 8);
  }

  CHECK(args[1]->IsFunction());
  args.GetReturnValue().Set(
      session->AddPing(payload.data(), args[1].As<Function>()));
}",66,,2979,2,,void
193954,BLOCK,-1,,"{
    payload.Read(args[0].As<ArrayBufferView>());
    CHECK_EQ(payload.length(), 8);
  }",37,,2986,2,,void
194003,BLOCK,-1,,"{
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  CHECK(args[0]->IsFunction());
  args.GetReturnValue().Set(session->AddSettings(args[0].As<Function>()));
}",70,,2997,2,,void
194039,BLOCK,-1,,"{
  BaseObjectPtr<Http2Ping> ping;
  if (!outstanding_pings_.empty()) {
    ping = std::move(outstanding_pings_.front());
    outstanding_pings_.pop();
    DecrementCurrentSessionMemory(sizeof(*ping));
  }
  return ping;
}",50,,3004,1,,void
194051,BLOCK,-1,,"{
    ping = std::move(outstanding_pings_.front());
    outstanding_pings_.pop();
    DecrementCurrentSessionMemory(sizeof(*ping));
  }",36,,3006,2,,void
194077,BLOCK,-1,,"{
  Local<Object> obj;
  if (!env()->http2ping_constructor_template()
          ->NewInstance(env()->context())
              .ToLocal(&obj)) {
    return false;
  }

  BaseObjectPtr<Http2Ping> ping =
      MakeDetachedBaseObject<Http2Ping>(this, obj, callback);
  if (!ping)
    return false;

  if (outstanding_pings_.size() == max_outstanding_pings_) {
    ping->Done(false);
    return false;
  }

  IncrementCurrentSessionMemory(sizeof(*ping));
  // The Ping itself is an Async resource. When the acknowledgement is received,
  // the callback will be invoked and a notification sent out to JS land. The
  // notification will include the duration of the ping, allowing the round
  // trip to be measured.
  ping->Send(payload);

  outstanding_pings_.emplace(std::move(ping));
  return true;
}",78,,3014,3,,void
194101,BLOCK,-1,,"{
    return false;
  }",31,,3018,2,,void
194122,BLOCK,-1,,<empty>,5,,3025,2,,void
194132,BLOCK,-1,,"{
    ping->Done(false);
    return false;
  }",60,,3027,2,,void
194163,BLOCK,-1,,"{
  BaseObjectPtr<Http2Settings> settings;
  if (!outstanding_settings_.empty()) {
    settings = std::move(outstanding_settings_.front());
    outstanding_settings_.pop();
    DecrementCurrentSessionMemory(sizeof(*settings));
  }
  return settings;
}",58,,3043,1,,void
194175,BLOCK,-1,,"{
    settings = std::move(outstanding_settings_.front());
    outstanding_settings_.pop();
    DecrementCurrentSessionMemory(sizeof(*settings));
  }",39,,3045,2,,void
194200,BLOCK,-1,,"{
  Local<Object> obj;
  if (!env()->http2settings_constructor_template()
          ->NewInstance(env()->context())
              .ToLocal(&obj)) {
    return false;
  }

  BaseObjectPtr<Http2Settings> settings =
      MakeDetachedBaseObject<Http2Settings>(this, obj, callback, 0);
  if (!settings)
    return false;

  if (outstanding_settings_.size() == max_outstanding_settings_) {
    settings->Done(false);
    return false;
  }

  IncrementCurrentSessionMemory(sizeof(*settings));
  settings->Send();
  outstanding_settings_.emplace(std::move(settings));
  return true;
}",58,,3053,2,,void
194224,BLOCK,-1,,"{
    return false;
  }",31,,3057,2,,void
194246,BLOCK,-1,,<empty>,5,,3064,2,,void
194256,BLOCK,-1,,"{
    settings->Done(false);
    return false;
  }",66,,3066,2,,void
194289,BLOCK,-1,,"{
  callback_.Reset(env()->isolate(), callback);
}",31,,3083,4,,void
194303,BLOCK,-1,,"{
  tracker->TrackField(""callback"", callback_);
}",58,,3087,2,,void
194313,BLOCK,-1,,"{
  return callback_.Get(env()->isolate());
}",45,,3091,1,,void
194327,BLOCK,-1,,"{
  CHECK(session_);
  uint8_t data[8];
  if (payload == nullptr) {
    memcpy(&data, &startTime_, arraysize(data));
    payload = data;
  }
  Http2Scope h2scope(session_.get());
  CHECK_EQ(nghttp2_submit_ping(
      session_->session(),
      NGHTTP2_FLAG_NONE,
      payload), 0);
}",46,,3095,2,,void
194334,BLOCK,-1,,"{
    memcpy(&data, &startTime_, arraysize(data));
    payload = data;
  }",27,,3098,2,,void
194365,BLOCK,-1,,"{
  uint64_t duration_ns = uv_hrtime() - startTime_;
  double duration_ms = duration_ns / 1e6;
  if (session_) session_->statistics_.ping_rtt = duration_ns;

  Isolate* isolate = env()->isolate();
  HandleScope handle_scope(isolate);
  Context::Scope context_scope(env()->context());

  Local<Value> buf = Undefined(isolate);
  if (payload != nullptr) {
    buf = Buffer::Copy(isolate,
                       reinterpret_cast<const char*>(payload),
                       8).ToLocalChecked();
  }

  Local<Value> argv[] = {
      Boolean::New(isolate, ack), Number::New(isolate, duration_ms), buf};
  MakeCallback(callback(), arraysize(argv), argv);
}",56,,3109,3,,void
194380,BLOCK,-1,,<empty>,17,,3112,2,,void
194416,BLOCK,-1,,"{
    buf = Buffer::Copy(isolate,
                       reinterpret_cast<const char*>(payload),
                       8).ToLocalChecked();
  }",27,,3119,2,,void
194456,BLOCK,-1,,"{
  session_.reset();
}",37,,3130,1,,void
194465,BLOCK,-1,,"{
  if (req_wrap)
    tracker->TrackField(""req_wrap"", req_wrap);
  tracker->TrackField(""buf"", buf);
}",67,,3134,2,,void
194468,BLOCK,-1,,<empty>,5,,3136,2,,void
194485,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK_EQ(args.Length(), 11);

#define SET_FUNCTION(arg, name)                                               \
  CHECK(args[arg]->IsFunction());                                             \
  env->set_http2session_on_ ## name ## _function(args[arg].As<Function>());

  SET_FUNCTION(0, error)
  SET_FUNCTION(1, priority)
  SET_FUNCTION(2, settings)
  SET_FUNCTION(3, ping)
  SET_FUNCTION(4, headers)
  SET_FUNCTION(5, frame_error)
  SET_FUNCTION(6, goaway_data)
  SET_FUNCTION(7, altsvc)
  SET_FUNCTION(8, origin)
  SET_FUNCTION(9, stream_trailers)
  SET_FUNCTION(10, stream_close)

#undef SET_FUNCTION
}",68,,3140,2,,void
194502,BLOCK,1,,<empty>,,,,2,,void
194522,BLOCK,1,,<empty>,,,,2,,void
194542,BLOCK,1,,<empty>,,,,2,,void
194562,BLOCK,1,,<empty>,,,,2,,void
194582,BLOCK,1,,<empty>,,,,2,,void
194602,BLOCK,1,,<empty>,,,,2,,void
194622,BLOCK,1,,<empty>,,,,2,,void
194642,BLOCK,1,,<empty>,,,,2,,void
194662,BLOCK,1,,<empty>,,,,2,,void
194682,BLOCK,1,,<empty>,,,,2,,void
194702,BLOCK,1,,<empty>,,,,2,,void
194724,BLOCK,-1,,"{
  tracker->TrackField(""root_buffer"", root_buffer);
}",59,,3169,2,,void
194738,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(context);
  Environment* env = realm->env();
  Isolate* isolate = env->isolate();
  HandleScope handle_scope(isolate);

  Http2State* const state = realm->AddBindingData<Http2State>(context, target);
  if (state == nullptr) return;

#define SET_STATE_TYPEDARRAY(name, field)             \
  target->Set(context,                                \
              FIXED_ONE_BYTE_STRING(isolate, (name)), \
              (field)).FromJust()

  // Initialize the buffer used to store the session state
  SET_STATE_TYPEDARRAY(
    ""sessionState"", state->session_state_buffer.GetJSArray());
  // Initialize the buffer used to store the stream state
  SET_STATE_TYPEDARRAY(
    ""streamState"", state->stream_state_buffer.GetJSArray());
  SET_STATE_TYPEDARRAY(
    ""settingsBuffer"", state->settings_buffer.GetJSArray());
  SET_STATE_TYPEDARRAY(
    ""optionsBuffer"", state->options_buffer.GetJSArray());
  SET_STATE_TYPEDARRAY(
    ""streamStats"", state->stream_stats_buffer...",29,,3177,5,,void
194781,BLOCK,-1,,<empty>,25,,3184,2,,void
194791,BLOCK,1,,<empty>,,,,5,,void
194817,BLOCK,1,,<empty>,,,,5,,void
194843,BLOCK,1,,<empty>,,,,5,,void
194869,BLOCK,1,,<empty>,,,,5,,void
194895,BLOCK,1,,<empty>,,,,5,,void
194921,BLOCK,1,,<empty>,,,,5,,void
194944,BLOCK,1,,<empty>,,,,7,,void
194946,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kBitfield)",3,,3207,1,,void
195043,BLOCK,1,,<empty>,,,,7,,void
195045,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kSessionPriorityListenerCount)",3,,3208,1,,void
195142,BLOCK,1,,<empty>,,,,7,,void
195144,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kSessionFrameErrorListenerCount)",3,,3209,1,,void
195241,BLOCK,1,,<empty>,,,,7,,void
195243,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kSessionMaxInvalidFrames)",3,,3210,1,,void
195340,BLOCK,1,,<empty>,,,,7,,void
195342,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kSessionMaxRejectedStreams)",3,,3211,1,,void
195439,BLOCK,1,,<empty>,,,,7,,void
195441,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kSessionUint8FieldCount)",3,,3212,1,,void
195538,BLOCK,1,,<empty>,,,,7,,void
195540,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kSessionHasRemoteSettingsListeners)",3,,3214,1,,void
195637,BLOCK,1,,<empty>,,,,7,,void
195639,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kSessionRemoteSettingsIsUpToDate)",3,,3215,1,,void
195736,BLOCK,1,,<empty>,,,,7,,void
195738,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kSessionHasPingListeners)",3,,3216,1,,void
195835,BLOCK,1,,<empty>,,,,7,,void
195837,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kSessionHasAltsvcListeners)",3,,3217,1,,void
196360,BLOCK,1,,<empty>,,,,7,,void
196362,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, NGHTTP2_DEFAULT_WEIGHT)",3,,3318,1,,void
196504,BLOCK,-1,,<empty>,1,,1,1,,ANY
196511,BLOCK,-1,,<empty>,1,,1,1,,ANY
196528,BLOCK,-1,,<empty>,1,,1,1,,ANY
196533,BLOCK,-1,,"{
  v8::Local<v8::Value> header_string =
      headers->Get(env->context(), 0).ToLocalChecked();
  v8::Local<v8::Value> header_count =
      headers->Get(env->context(), 1).ToLocalChecked();
  CHECK(header_count->IsUint32());
  CHECK(header_string->IsString());
  count_ = header_count.As<v8::Uint32>()->Value();
  int header_string_len = header_string.As<v8::String>()->Length();

  if (count_ == 0) {
    CHECK_EQ(header_string_len, 0);
    return;
  }

  buf_.AllocateSufficientStorage((alignof(nv_t) - 1) +
                                 count_ * sizeof(nv_t) +
                                 header_string_len);

  char* start = AlignUp(buf_.out(), alignof(nv_t));
  char* header_contents = start + (count_ * sizeof(nv_t));
  nv_t* const nva = reinterpret_cast<nv_t*>(start);

  CHECK_LE(header_contents + header_string_len, *buf_ + buf_.length());
  CHECK_EQ(header_string.As<v8::String>()->WriteOneByte(
               env->isolate(),
               reinterpret_cast<uint8_t*>(header_co...",73,,15,3,,void
196611,BLOCK,-1,,"{
    CHECK_EQ(header_string_len, 0);
    return;
  }",20,,25,2,,void
196696,BLOCK,-1,,<empty>,3,,49,1,,void
196707,BLOCK,4,,"{
    if (n >= count_) {
      static uint8_t zero = '\0';
      nva[0].name = nva[0].value = &zero;
      nva[0].namelen = nva[0].valuelen = 1;
      count_ = 1;
      return;
    }

    nva[n].name = reinterpret_cast<uint8_t*>(p);
    nva[n].namelen = strlen(p);
    p += nva[n].namelen + 1;
    nva[n].value = reinterpret_cast<uint8_t*>(p);
    nva[n].valuelen = strlen(p);
    p += nva[n].valuelen + 1;
    nva[n].flags = *p;
    p++;
  }",75,,49,4,,void
196712,BLOCK,-1,,"{
      static uint8_t zero = '\0';
      nva[0].name = nva[0].value = &zero;
      nva[0].namelen = nva[0].valuelen = 1;
      count_ = 1;
      return;
    }",22,,50,2,,void
196814,BLOCK,-1,,"{
  static constexpr size_t min_header_pairs = 1;
  return std::max(max_header_pairs, min_header_pairs);
}",57,,69,2,,void
196830,BLOCK,-1,,"{
  static constexpr size_t min_header_pairs = 4;
  return std::max(max_header_pairs, min_header_pairs);
}",57,,74,2,,void
196845,BLOCK,-1,,"{
  std::string ret = name();
  ret += "" = "";
  ret += value();
  return ret;
}",57,,80,1,,void
196863,BLOCK,-1,,"{
  return IsZeroLength(-1, name, value);
}",34,,90,3,,void
196876,BLOCK,-1,,"{

  if (NgHeader<T>::rcbufferpointer_t::IsZeroLength(value))
    return true;

  const char* header_name = T::ToHttpHeaderName(token);
  return header_name != nullptr ||
      NgHeader<T>::rcbufferpointer_t::IsZeroLength(name);
}",34,,98,4,,void
196887,BLOCK,-1,,<empty>,5,,101,2,,void
196919,BLOCK,-1,,<empty>,48,,114,5,,void
196928,BLOCK,-1,,"{
  if (token == -1) {
    CHECK_NOT_NULL(name);
    name_.reset(name, true);  // Internalizable
  }
  CHECK_NOT_NULL(value);
  name_.reset(name, true);  // Internalizable
  value_.reset(value);
}",62,,122,6,,void
196934,BLOCK,-1,,"{
    CHECK_NOT_NULL(name);
    name_.reset(name, true);  // Internalizable
  }",20,,123,2,,void
196960,BLOCK,-1,,"{
  other.token_ = -1;
  other.flags_ = 0;
  other.env_ = nullptr;
}",28,,138,2,,void
196981,BLOCK,-1,,"{
  tracker->TrackField(""name"", name_);
  tracker->TrackField(""value"", value_);
}",60,,145,2,,void
196998,BLOCK,-1,,"{

  // Not all instances will support using token id's for header names.
  // HTTP/2 specifically does not support it.
  const char* header_name = T::ToHttpHeaderName(token_);

  // If header_name is not nullptr, then it is a known header with
  // a statically defined name. We can safely internalize it here.
  if (header_name != nullptr) {
    auto& static_str_map = env_->isolate_data()->static_str_map;
    v8::Eternal<v8::String> eternal = static_str_map[header_name];
    if (eternal.IsEmpty()) {
      v8::Local<v8::String> str = OneByteString(env_->isolate(), header_name);
      eternal.Set(env_->isolate(), str);
      return str;
    }
    return eternal.Get(env_->isolate());
  }
  return rcbufferpointer_t::External::New(allocator, name_);
}",48,,152,2,,void
197011,BLOCK,-1,,"{
    auto& static_str_map = env_->isolate_data()->static_str_map;
    v8::Eternal<v8::String> eternal = static_str_map[header_name];
    if (eternal.IsEmpty()) {
      v8::Local<v8::String> str = OneByteString(env_->isolate(), header_name);
      eternal.Set(env_->isolate(), str);
      return str;
    }
    return eternal.Get(env_->isolate());
  }",31,,160,2,,void
197039,BLOCK,-1,,"{
      v8::Local<v8::String> str = OneByteString(env_->isolate(), header_name);
      eternal.Set(env_->isolate(), str);
      return str;
    }",28,,163,2,,void
197089,BLOCK,-1,,"{
  return rcbufferpointer_t::External::New(allocator, value_);
}",48,,175,2,,void
197102,BLOCK,-1,,"{
  return name_.str();
}",39,,180,1,,void
197111,BLOCK,-1,,"{
  return value_.str();
}",40,,185,1,,void
197120,BLOCK,-1,,"{
  return name_.len() + value_.len();
}",36,,190,1,,void
197134,BLOCK,-1,,"{
  return flags_;
}",36,,195,1,,void
197149,BLOCK,-1,,<empty>,1,,1,1,,ANY
197152,BLOCK,-1,,"{
      if (buf.base == binding_data_->parser_buffer.data())
        binding_data_->parser_buffer_in_use = false;
      else
        free(buf.base);
    }",46,,761,1,,void
197164,BLOCK,-1,,<empty>,9,,763,2,,void
197171,BLOCK,-1,,<empty>,9,,765,1,,void
197206,BLOCK,-1,,<empty>,1,,1,1,,ANY
197273,BLOCK,-1,,"{
  return c == ' ' || c == '\t';
}",27,,90,2,,void
197288,BLOCK,-1,,<empty>,73,,96,3,,void
197297,BLOCK,-1,,"{
    tracker->TrackField(""parser_buffer"", parser_buffer);
  }",58,,103,2,,void
197311,BLOCK,-1,,<empty>,,,,1,,<empty>
197319,BLOCK,-1,,"{
    on_heap_ = false;
    Reset();
  }",15,,112,1,,void
197327,BLOCK,-1,,"{
    Reset();
  }",16,,118,1,,void
197332,BLOCK,-1,,"{
    if (!on_heap_ && size_ > 0) {
      char* s = new char[size_];
      memcpy(s, str_, size_);
      str_ = s;
      on_heap_ = true;
    }
  }",15,,126,1,,void
197340,BLOCK,-1,,"{
      char* s = new char[size_];
      memcpy(s, str_, size_);
      str_ = s;
      on_heap_ = true;
    }",33,,127,2,,void
197359,BLOCK,-1,,"{
    if (on_heap_) {
      delete[] str_;
      on_heap_ = false;
    }

    str_ = nullptr;
    size_ = 0;
  }",16,,136,1,,void
197362,BLOCK,-1,,"{
      delete[] str_;
      on_heap_ = false;
    }",19,,137,2,,void
197379,BLOCK,-1,,"{
    if (str_ == nullptr) {
      str_ = str;
    } else if (on_heap_ || str_ + size_ != str) {
      // Non-consecutive input, make a copy on the heap.
      // TODO(bnoordhuis) Use slab allocation, O(n) allocs is bad.
      char* s = new char[size_ + size];
      memcpy(s, str_, size_);
      memcpy(s + size_, str, size);

      if (on_heap_)
        delete[] str_;
      else
        on_heap_ = true;

      str_ = s;
    }
    size_ += size;
  }",45,,147,3,,void
197384,BLOCK,-1,,"{
      str_ = str;
    }",26,,148,2,,void
197389,BLOCK,-1,,<empty>,12,,150,1,,void
197398,BLOCK,-1,,"{
      // Non-consecutive input, make a copy on the heap.
      // TODO(bnoordhuis) Use slab allocation, O(n) allocs is bad.
      char* s = new char[size_ + size];
      memcpy(s, str_, size_);
      memcpy(s + size_, str, size);

      if (on_heap_)
        delete[] str_;
      else
        on_heap_ = true;

      str_ = s;
    }",49,,150,2,,void
197416,BLOCK,-1,,<empty>,9,,158,2,,void
197420,BLOCK,-1,,<empty>,9,,160,1,,void
197434,BLOCK,-1,,"{
    if (size_ != 0)
      return OneByteString(env->isolate(), str_, size_);
    else
      return String::Empty(env->isolate());
  }",50,,168,2,,void
197439,BLOCK,-1,,<empty>,7,,170,2,,void
197449,BLOCK,-1,,<empty>,7,,172,1,,void
197463,BLOCK,-1,,"{
    while (size_ > 0 && IsOWS(str_[size_ - 1])) {
      size_--;
    }
    return ToString(env);
  }",51,,177,2,,void
197475,BLOCK,-1,,"{
      size_--;
    }",49,,178,2,,void
197491,BLOCK,-1,,<empty>,,,,3,,<empty>
197497,BLOCK,-1,,<empty>,,,,2,,<empty>
197502,BLOCK,-1,,<empty>,,,,2,,<empty>
197507,BLOCK,-1,,<empty>,,,,2,,<empty>
197512,BLOCK,-1,,<empty>,,,,2,,<empty>
197517,BLOCK,-1,,<empty>,,,,2,,<empty>
197522,BLOCK,-1,,"{
      all_connections_.insert(parser);
    }",31,,208,2,,void
197532,BLOCK,-1,,"{
      all_connections_.erase(parser);
    }",30,,212,2,,void
197542,BLOCK,-1,,"{
      active_connections_.insert(parser);
    }",37,,216,2,,void
197552,BLOCK,-1,,"{
      active_connections_.erase(parser);
    }",36,,220,2,,void
197568,BLOCK,-1,,"{
  }",37,,247,3,,void
197575,BLOCK,-1,,"{
    int rv = TrackHeader(length);
    if (rv != 0) {
      return rv;
    }

    url_.Update(at, length);
    return 0;
  }",45,,289,3,,void
197585,BLOCK,-1,,"{
      return rv;
    }",18,,291,2,,void
197601,BLOCK,-1,,"{
    int rv = TrackHeader(length);
    if (rv != 0) {
      return rv;
    }

    status_message_.Update(at, length);
    return 0;
  }",48,,300,3,,void
197611,BLOCK,-1,,"{
      return rv;
    }",18,,302,2,,void
197627,BLOCK,-1,,"{
    int rv = TrackHeader(length);
    if (rv != 0) {
      return rv;
    }

    if (num_fields_ == num_values_) {
      // start of new field name
      num_fields_++;
      if (num_fields_ == kMaxHeaderFieldsCount) {
        // ran out of space - flush to javascript land
        Flush();
        num_fields_ = 1;
        num_values_ = 0;
      }
      fields_[num_fields_ - 1].Reset();
    }

    CHECK_LT(num_fields_, kMaxHeaderFieldsCount);
    CHECK_EQ(num_fields_, num_values_ + 1);

    fields_[num_fields_ - 1].Update(at, length);

    return 0;
  }",54,,311,3,,void
197637,BLOCK,-1,,"{
      return rv;
    }",18,,313,2,,void
197644,BLOCK,-1,,"{
      // start of new field name
      num_fields_++;
      if (num_fields_ == kMaxHeaderFieldsCount) {
        // ran out of space - flush to javascript land
        Flush();
        num_fields_ = 1;
        num_values_ = 0;
      }
      fields_[num_fields_ - 1].Reset();
    }",37,,317,2,,void
197651,BLOCK,-1,,"{
        // ran out of space - flush to javascript land
        Flush();
        num_fields_ = 1;
        num_values_ = 0;
      }",49,,320,2,,void
197692,BLOCK,-1,,"{
    int rv = TrackHeader(length);
    if (rv != 0) {
      return rv;
    }

    if (num_values_ != num_fields_) {
      // start of new header value
      num_values_++;
      values_[num_values_ - 1].Reset();
    }

    CHECK_LT(num_values_, arraysize(values_));
    CHECK_EQ(num_values_, num_fields_);

    values_[num_values_ - 1].Update(at, length);

    return 0;
  }",54,,338,3,,void
197702,BLOCK,-1,,"{
      return rv;
    }",18,,340,2,,void
197709,BLOCK,-1,,"{
      // start of new header value
      num_values_++;
      values_[num_values_ - 1].Reset();
    }",37,,344,2,,void
197742,BLOCK,-1,,"{
    headers_completed_ = true;
    header_nread_ = 0;

    // Arguments for the on-headers-complete javascript callback. This
    // list needs to be kept in sync with the actual argument list for
    // `parserOnHeadersComplete` in lib/_http_common.js.
    enum on_headers_complete_arg_index {
      A_VERSION_MAJOR = 0,
      A_VERSION_MINOR,
      A_HEADERS,
      A_METHOD,
      A_URL,
      A_STATUS_CODE,
      A_STATUS_MESSAGE,
      A_UPGRADE,
      A_SHOULD_KEEP_ALIVE,
      A_MAX
    };

    Local<Value> argv[A_MAX];
    Local<Object> obj = object();
    Local<Value> cb = obj->Get(env()->context(),
                               kOnHeadersComplete).ToLocalChecked();

    if (!cb->IsFunction())
      return 0;

    Local<Value> undefined = Undefined(env()->isolate());
    for (size_t i = 0; i < arraysize(argv); i++)
      argv[i] = undefined;

    if (have_flushed_) {
      // Slow case, flush remaining headers.
      Flush();
    } else {
      // Fast case, pass headers an...",29,,359,1,,void
197787,BLOCK,-1,,<empty>,7,,385,2,,void
197802,BLOCK,-1,,<empty>,5,,388,1,,void
197820,BLOCK,-1,,"{
      // Slow case, flush remaining headers.
      Flush();
    }",24,,391,2,,void
197823,BLOCK,-1,,"{
      // Fast case, pass headers and URL to JS land.
      argv[A_HEADERS] = CreateHeaders();
      if (parser_.type == HTTP_REQUEST)
        argv[A_URL] = url_.ToString(env());
    }",12,,394,1,,void
197835,BLOCK,-1,,<empty>,9,,398,2,,void
197857,BLOCK,-1,,"{
      argv[A_METHOD] =
          Uint32::NewFromUnsigned(env()->isolate(), parser_.method);
    }",39,,405,2,,void
197879,BLOCK,-1,,"{
      argv[A_STATUS_CODE] =
          Integer::New(env()->isolate(), parser_.status_code);
      argv[A_STATUS_MESSAGE] = status_message_.ToString(env());
    }",40,,411,2,,void
197973,BLOCK,21,,"{
      InternalCallbackScope callback_scope(
          this, InternalCallbackScope::kSkipTaskQueues);
      head_response = cb.As<Function>()->Call(
          env()->context(), object(), arraysize(argv), argv);
      if (head_response.IsEmpty()) callback_scope.MarkAsFailed();
    }",5,,430,21,,void
198002,BLOCK,-1,,<empty>,36,,435,2,,void
198031,BLOCK,-1,,"{
      got_exception_ = true;
      return -1;
    }",52,,442,2,,void
198047,BLOCK,-1,,"{
    if (length == 0)
      return 0;

    Environment* env = this->env();
    HandleScope handle_scope(env->isolate());

    Local<Value> cb = object()->Get(env->context(), kOnBody).ToLocalChecked();

    if (!cb->IsFunction())
      return 0;

    Local<Value> buffer = Buffer::Copy(env, at, length).ToLocalChecked();

    MaybeLocal<Value> r = MakeCallback(cb.As<Function>(), 1, &buffer);

    if (r.IsEmpty()) {
      got_exception_ = true;
      llhttp_set_error_reason(&parser_, ""HPE_JS_EXCEPTION:JS Exception"");
      return HPE_USER;
    }

    return 0;
  }",46,,451,3,,void
198052,BLOCK,-1,,<empty>,7,,453,2,,void
198092,BLOCK,-1,,<empty>,7,,461,2,,void
198130,BLOCK,-1,,"{
      got_exception_ = true;
      llhttp_set_error_reason(&parser_, ""HPE_JS_EXCEPTION:JS Exception"");
      return HPE_USER;
    }",22,,467,2,,void
198145,BLOCK,-1,,"{
    HandleScope scope(env()->isolate());

    // Important: Pop from the lists BEFORE resetting the last_message_start_
    // otherwise std::set.erase will fail.
    if (connectionsList_ != nullptr) {
      connectionsList_->Pop(this);
      connectionsList_->PopActive(this);
    }

    last_message_start_ = 0;

    if (connectionsList_ != nullptr) {
      connectionsList_->Push(this);
    }

    if (num_fields_)
      Flush();  // Flush trailing HTTP headers.

    Local<Object> obj = object();
    Local<Value> cb = obj->Get(env()->context(),
                               kOnMessageComplete).ToLocalChecked();

    if (!cb->IsFunction())
      return 0;

    MaybeLocal<Value> r;
    {
      InternalCallbackScope callback_scope(
          this, InternalCallbackScope::kSkipTaskQueues);
      r = cb.As<Function>()->Call(env()->context(), object(), 0, nullptr);
      if (r.IsEmpty()) callback_scope.MarkAsFailed();
    }

    if (r.IsEmpty()) {
      got_exception_ = true;
      retur...",29,,477,1,,void
198156,BLOCK,-1,,"{
      connectionsList_->Pop(this);
      connectionsList_->PopActive(this);
    }",38,,482,2,,void
198174,BLOCK,-1,,"{
      connectionsList_->Push(this);
    }",38,,489,2,,void
198182,BLOCK,-1,,<empty>,7,,494,2,,void
198215,BLOCK,-1,,<empty>,7,,501,2,,void
198223,BLOCK,11,,"{
      InternalCallbackScope callback_scope(
          this, InternalCallbackScope::kSkipTaskQueues);
      r = cb.As<Function>()->Call(env()->context(), object(), 0, nullptr);
      if (r.IsEmpty()) callback_scope.MarkAsFailed();
    }",5,,504,11,,void
198251,BLOCK,-1,,<empty>,24,,508,2,,void
198261,BLOCK,-1,,"{
      got_exception_ = true;
      return -1;
    }",22,,511,2,,void
198273,BLOCK,-1,,"{
    header_nread_ = 0;
    return 0;
  }",25,,520,1,,void
198282,BLOCK,-1,,"{
    header_nread_ = 0;
    return 0;
  }",27,,527,1,,void
198292,BLOCK,-1,,"{
    BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
    new Parser(binding_data, args.This());
  }",60,,532,2,,void
198314,BLOCK,-1,,"{
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    delete parser;
  }",62,,538,2,,void
198329,BLOCK,-1,,"{
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    // Since the Parser destructor isn't going to run the destroy() callbacks
    // it needs to be triggered manually.
    parser->EmitTraceEventDestroy();
    parser->EmitDestroy();
  }",61,,546,2,,void
198350,BLOCK,-1,,"{
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    if (parser->connectionsList_ != nullptr) {
      parser->connectionsList_->Pop(parser);
      parser->connectionsList_->PopActive(parser);
    }
  }",63,,556,2,,void
198365,BLOCK,-1,,"{
      parser->connectionsList_->Pop(parser);
      parser->connectionsList_->PopActive(parser);
    }",46,,560,2,,void
198383,BLOCK,-1,,"{
    url_.Save();
    status_message_.Save();

    for (size_t i = 0; i < num_fields_; i++) {
      fields_[i].Save();
    }

    for (size_t i = 0; i < num_values_; i++) {
      values_[i].Save();
    }
  }",15,,566,1,,void
198393,BLOCK,-1,,<empty>,5,,570,1,,void
198403,BLOCK,4,,"{
      fields_[i].Save();
    }",46,,570,4,,void
198411,BLOCK,-1,,<empty>,5,,574,1,,void
198421,BLOCK,4,,"{
      values_[i].Save();
    }",46,,574,4,,void
198432,BLOCK,-1,,"{
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    ArrayBufferViewContents<char> buffer(args[0]);

    Local<Value> ret = parser->Execute(buffer.data(), buffer.length());

    if (!ret.IsEmpty())
      args.GetReturnValue().Set(ret);
  }",64,,580,2,,void
198470,BLOCK,-1,,<empty>,7,,589,2,,void
198483,BLOCK,-1,,"{
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    Local<Value> ret = parser->Execute(nullptr, 0);

    if (!ret.IsEmpty())
      args.GetReturnValue().Set(ret);
  }",63,,593,2,,void
198510,BLOCK,-1,,<empty>,7,,600,2,,void
198523,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(args);

    uint64_t max_http_header_size = 0;
    uint32_t lenient_flags = kLenientNone;
    ConnectionsList* connectionsList = nullptr;

    CHECK(args[0]->IsInt32());
    CHECK(args[1]->IsObject());

    if (args.Length() > 2) {
      CHECK(args[2]->IsNumber());
      max_http_header_size =
          static_cast<uint64_t>(args[2].As<Number>()->Value());
    }
    if (max_http_header_size == 0) {
      max_http_header_size = env->options()->max_http_header_size;
    }

    if (args.Length() > 3) {
      CHECK(args[3]->IsInt32());
      lenient_flags = args[3].As<Int32>()->Value();
    }

    if (args.Length() > 4 && !args[4]->IsNullOrUndefined()) {
      CHECK(args[4]->IsObject());
      ASSIGN_OR_RETURN_UNWRAP(&connectionsList, args[4]);
    }

    llhttp_type_t type =
        static_cast<llhttp_type_t>(args[0].As<Int32>()->Value());

    CHECK(type == HTTP_REQUEST || type == HTTP_RESPONSE);
    Parser* parser;
    ASSIGN_OR_RETURN...",67,,604,2,,void
198565,BLOCK,-1,,"{
      CHECK(args[2]->IsNumber());
      max_http_header_size =
          static_cast<uint64_t>(args[2].As<Number>()->Value());
    }",28,,614,2,,void
198590,BLOCK,-1,,"{
      max_http_header_size = env->options()->max_http_header_size;
    }",36,,619,2,,void
198606,BLOCK,-1,,"{
      CHECK(args[3]->IsInt32());
      lenient_flags = args[3].As<Int32>()->Value();
    }",28,,623,2,,void
198640,BLOCK,-1,,"{
      CHECK(args[4]->IsObject());
      ASSIGN_OR_RETURN_UNWRAP(&connectionsList, args[4]);
    }",61,,628,2,,void
198729,BLOCK,-1,,"{
      parser->connectionsList_ = connectionsList;

      // This protects from a DoS attack where an attacker establishes
      // the connection without sending any data on applications where
      // server.timeout is left to the default value of zero.
      parser->last_message_start_ = uv_hrtime();

      // Important: Push into the lists AFTER setting the last_message_start_
      // otherwise std::set.erase will fail later.
      parser->connectionsList_->Push(parser);
      parser->connectionsList_->PushActive(parser);
    }",37,,651,2,,void
198755,BLOCK,-1,,"{
      parser->connectionsList_ = nullptr;
    }",12,,663,1,,void
198765,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(args);
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());
    // Should always be called from the same context.
    CHECK_EQ(env, parser->env());

    if constexpr (should_pause) {
      llhttp_pause(&parser->parser_);
    } else {
      llhttp_resume(&parser->parser_);
    }
  }",62,,669,2,,void
198790,BLOCK,-1,,"{
      llhttp_pause(&parser->parser_);
    }",33,,676,2,,void
198797,BLOCK,-1,,"{
      llhttp_resume(&parser->parser_);
    }",12,,678,1,,void
198807,BLOCK,-1,,"{
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());
    CHECK(args[0]->IsObject());
    StreamBase* stream = StreamBase::FromObject(args[0].As<Object>());
    CHECK_NOT_NULL(stream);
    stream->PushStreamListener(parser);
  }",64,,684,2,,void
198847,BLOCK,-1,,"{
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    // Already unconsumed
    if (parser->stream_ == nullptr)
      return;

    parser->stream_->RemoveStreamListener(parser);
  }",66,,694,2,,void
198862,BLOCK,-1,,<empty>,7,,700,2,,void
198875,BLOCK,-1,,"{
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    Local<Object> ret = Buffer::Copy(
        parser->env(),
        parser->current_buffer_data_,
        parser->current_buffer_len_).ToLocalChecked();

    args.GetReturnValue().Set(ret);
  }",73,,706,2,,void
198919,BLOCK,-1,,"{
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    if (parser->last_message_start_ == 0) {
      args.GetReturnValue().Set(0);
      return;
    }

    double duration = (uv_hrtime() - parser->last_message_start_) / 1e6;
    args.GetReturnValue().Set(duration);
  }",65,,718,2,,void
198934,BLOCK,-1,,"{
      args.GetReturnValue().Set(0);
      return;
    }",43,,722,2,,void
198966,BLOCK,-1,,"{
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    args.GetReturnValue().Set(parser->headers_completed_);
  }",73,,731,2,,void
198990,BLOCK,-1,,"{
    // For most types of streams, OnStreamRead will be immediately after
    // OnStreamAlloc, and will consume all data, so using a static buffer for
    // reading is more efficient. For other streams, just use Malloc() directly.
    if (binding_data_->parser_buffer_in_use)
      return uv_buf_init(Malloc(suggested_size), suggested_size);
    binding_data_->parser_buffer_in_use = true;

    if (binding_data_->parser_buffer.empty())
      binding_data_->parser_buffer.resize(kAllocBufferSize);

    return uv_buf_init(binding_data_->parser_buffer.data(), kAllocBufferSize);
  }",58,,741,2,,void
198995,BLOCK,-1,,<empty>,7,,746,2,,void
199013,BLOCK,-1,,<empty>,7,,750,2,,void
199034,BLOCK,-1,,"{
    HandleScope scope(env()->isolate());
    // Once we’re done here, either indicate that the HTTP parser buffer
    // is free for re-use, or free() the data if it didn’t come from there
    // in the first place.
    auto on_scope_leave = OnScopeLeave([&]() {
      if (buf.base == binding_data_->parser_buffer.data())
        binding_data_->parser_buffer_in_use = false;
      else
        free(buf.base);
    });

    if (nread < 0) {
      PassReadErrorToPreviousListener(nread);
      return;
    }

    // Ignore, empty reads have special meaning in http parser
    if (nread == 0)
      return;

    Local<Value> ret = Execute(buf.base, nread);

    // Exception
    if (ret.IsEmpty())
      return;

    Local<Value> cb =
        object()->Get(env()->context(), kOnExecute).ToLocalChecked();

    if (!cb->IsFunction())
      return;

    // Hooks for GetCurrentBuffer
    current_buffer_len_ = nread;
    current_buffer_data_ = buf.base;

    MakeCallback(cb.As<Function>(), 1, &ret);...",66,,756,3,,void
199050,BLOCK,-1,,"{
      PassReadErrorToPreviousListener(nread);
      return;
    }",20,,768,2,,void
199058,BLOCK,-1,,<empty>,7,,775,2,,void
199076,BLOCK,-1,,<empty>,7,,781,2,,void
199102,BLOCK,-1,,<empty>,7,,787,2,,void
199131,BLOCK,-1,,"{
    EscapableHandleScope scope(env()->isolate());

    current_buffer_len_ = len;
    current_buffer_data_ = data;
    got_exception_ = false;

    llhttp_errno_t err;

    if (data == nullptr) {
      err = llhttp_finish(&parser_);
    } else {
      err = llhttp_execute(&parser_, data, len);
      Save();
    }

    // Calculate bytes read and resume after Upgrade/CONNECT pause
    size_t nread = len;
    if (err != HPE_OK) {
      nread = llhttp_get_error_pos(&parser_) - data;

      // This isn't a real pause, just a way to stop parsing early.
      if (err == HPE_PAUSED_UPGRADE) {
        err = HPE_OK;
        llhttp_resume_after_upgrade(&parser_);
      }
    }

    // Apply pending pause
    if (pending_pause_) {
      pending_pause_ = false;
      llhttp_pause(&parser_);
    }

    current_buffer_len_ = 0;
    current_buffer_data_ = nullptr;

    // If there was an exception in one of the callbacks
    if (got_exception_)
      return scope.Escape(Local<Value>());

    Loc...",54,,800,3,,void
199152,BLOCK,-1,,"{
      err = llhttp_finish(&parser_);
    }",26,,809,2,,void
199159,BLOCK,-1,,"{
      err = llhttp_execute(&parser_, data, len);
      Save();
    }",12,,811,1,,void
199176,BLOCK,-1,,"{
      nread = llhttp_get_error_pos(&parser_) - data;

      // This isn't a real pause, just a way to stop parsing early.
      if (err == HPE_PAUSED_UPGRADE) {
        err = HPE_OK;
        llhttp_resume_after_upgrade(&parser_);
      }
    }",24,,818,2,,void
199188,BLOCK,-1,,"{
        err = HPE_OK;
        llhttp_resume_after_upgrade(&parser_);
      }",38,,822,2,,void
199197,BLOCK,-1,,"{
      pending_pause_ = false;
      llhttp_pause(&parser_);
    }",25,,829,2,,void
199212,BLOCK,-1,,<empty>,7,,839,2,,void
199243,BLOCK,-1,,"{
      Local<Value> e = Exception::Error(env()->parse_error_string());
      Local<Object> obj = e->ToObject(env()->isolate()->GetCurrentContext())
        .ToLocalChecked();
      obj->Set(env()->context(),
               env()->bytes_parsed_string(),
               nread_obj).Check();
      const char* errno_reason = llhttp_get_error_reason(&parser_);

      Local<String> code;
      Local<String> reason;
      if (err == HPE_USER) {
        const char* colon = strchr(errno_reason, ':');
        CHECK_NOT_NULL(colon);
        code = OneByteString(env()->isolate(),
                             errno_reason,
                             static_cast<int>(colon - errno_reason));
        reason = OneByteString(env()->isolate(), colon + 1);
      } else {
        code = OneByteString(env()->isolate(), llhttp_errno_name(err));
        reason = OneByteString(env()->isolate(), errno_reason);
      }

      obj->Set(env()->context(), env()->code_string(), code).Check();
      obj->Set(env(...",44,,845,2,,void
199314,BLOCK,-1,,"{
        const char* colon = strchr(errno_reason, ':');
        CHECK_NOT_NULL(colon);
        code = OneByteString(env()->isolate(),
                             errno_reason,
                             static_cast<int>(colon - errno_reason));
        reason = OneByteString(env()->isolate(), colon + 1);
      }",28,,856,2,,void
199347,BLOCK,-1,,"{
        code = OneByteString(env()->isolate(), llhttp_errno_name(err));
        reason = OneByteString(env()->isolate(), errno_reason);
      }",14,,863,1,,void
199407,BLOCK,-1,,"{
      return scope.Escape(Local<Value>());
    }",26,,874,2,,void
199423,BLOCK,-1,,"{
    // There could be extra entries but the max size should be fixed
    Local<Value> headers_v[kMaxHeaderFieldsCount * 2];

    for (size_t i = 0; i < num_values_; ++i) {
      headers_v[i * 2] = fields_[i].ToString(env());
      headers_v[i * 2 + 1] = values_[i].ToTrimmedString(env());
    }

    return Array::New(env()->isolate(), headers_v, num_values_ * 2);
  }",32,,880,1,,void
199434,BLOCK,-1,,<empty>,5,,884,1,,void
199444,BLOCK,4,,"{
      headers_v[i * 2] = fields_[i].ToString(env());
      headers_v[i * 2 + 1] = values_[i].ToTrimmedString(env());
    }",46,,884,4,,void
199489,BLOCK,-1,,"{
    HandleScope scope(env()->isolate());

    Local<Object> obj = object();
    Local<Value> cb = obj->Get(env()->context(), kOnHeaders).ToLocalChecked();

    if (!cb->IsFunction())
      return;

    Local<Value> argv[2] = {
      CreateHeaders(),
      url_.ToString(env())
    };

    MaybeLocal<Value> r = MakeCallback(cb.As<Function>(),
                                       arraysize(argv),
                                       argv);

    if (r.IsEmpty())
      got_exception_ = true;

    url_.Reset();
    have_flushed_ = true;
  }",16,,894,1,,void
199527,BLOCK,-1,,<empty>,7,,901,2,,void
199556,BLOCK,-1,,<empty>,7,,913,2,,void
199573,BLOCK,-1,,"{
    llhttp_init(&parser_, type, &settings);

    if (lenient_flags & kLenientHeaders) {
      llhttp_set_lenient_headers(&parser_, 1);
    }
    if (lenient_flags & kLenientChunkedLength) {
      llhttp_set_lenient_chunked_length(&parser_, 1);
    }
    if (lenient_flags & kLenientKeepAlive) {
      llhttp_set_lenient_keep_alive(&parser_, 1);
    }

    header_nread_ = 0;
    url_.Reset();
    status_message_.Reset();
    num_fields_ = 0;
    num_values_ = 0;
    have_flushed_ = false;
    got_exception_ = false;
    headers_completed_ = false;
    max_http_header_size_ = max_http_header_size;
  }",37,,921,4,,void
199584,BLOCK,-1,,"{
      llhttp_set_lenient_headers(&parser_, 1);
    }",42,,924,2,,void
199593,BLOCK,-1,,"{
      llhttp_set_lenient_chunked_length(&parser_, 1);
    }",48,,927,2,,void
199602,BLOCK,-1,,"{
      llhttp_set_lenient_keep_alive(&parser_, 1);
    }",44,,930,2,,void
199640,BLOCK,-1,,"{
    header_nread_ += len;
    if (header_nread_ >= max_http_header_size_) {
      llhttp_set_error_reason(&parser_, ""HPE_HEADER_OVERFLOW:Header overflow"");
      return HPE_USER;
    }
    return 0;
  }",31,,946,2,,void
199648,BLOCK,-1,,"{
      llhttp_set_error_reason(&parser_, ""HPE_HEADER_OVERFLOW:Header overflow"");
      return HPE_USER;
    }",49,,948,2,,void
199660,BLOCK,-1,,"{
    if (!pending_pause_) {
      return 0;
    }

    pending_pause_ = false;
    llhttp_set_error_reason(&parser_, ""Paused in callback"");
    return HPE_PAUSED;
  }",20,,956,1,,void
199664,BLOCK,-1,,"{
      return 0;
    }",26,,957,2,,void
199679,BLOCK,-1,,"{
    // HTTP parsers are able to emit events without any GC root referring
    // to them, because they receive events directly from the underlying
    // libuv resource.
    return true;
  }",59,,967,1,,void
199707,BLOCK,-1,,"{
      Parser* parser = ContainerOf(&Parser::parser_, p);
      int rv = (parser->*Member)(std::forward<Args>(args)...);
      if (rv == 0) {
        rv = parser->MaybePause();
      }
      return rv;
    }",48,,1000,3,,void
199735,BLOCK,-1,,"{
        rv = parser->MaybePause();
      }",20,,1003,2,,void
199747,BLOCK,-1,,<empty>,,,,1,,<empty>
199753,BLOCK,-1,,<empty>,,,,3,,<empty>
199758,BLOCK,-1,,<empty>,,,,1,,<empty>
199782,BLOCK,-1,,"{
  if (lhs->last_message_start_ == 0 && rhs->last_message_start_ == 0) {
    // When both parsers are idle, guarantee strict order by
    // comparing pointers as ints.
    return lhs < rhs;
  } else if (lhs->last_message_start_ == 0) {
    return true;
  } else if (rhs->last_message_start_ == 0) {
    return false;
  }

  return lhs->last_message_start_ < rhs->last_message_start_;
}",79,,1016,3,,void
199795,BLOCK,-1,,"{
    // When both parsers are idle, guarantee strict order by
    // comparing pointers as ints.
    return lhs < rhs;
  }",71,,1017,2,,void
199801,BLOCK,-1,,<empty>,10,,1021,1,,void
199808,BLOCK,-1,,"{
    return true;
  }",45,,1021,2,,void
199812,BLOCK,-1,,<empty>,10,,1023,1,,void
199819,BLOCK,-1,,"{
    return false;
  }",45,,1023,2,,void
199834,BLOCK,-1,,"{
  Local<Context> context = args.GetIsolate()->GetCurrentContext();
  Environment* env = Environment::GetCurrent(context);

  new ConnectionsList(env, args.This());
}",68,,1030,2,,void
199867,BLOCK,-1,,"{
  Isolate* isolate = args.GetIsolate();

  ConnectionsList* list;

  ASSIGN_OR_RETURN_UNWRAP(&list, args.Holder());

  std::vector<Local<Value>> result;
  result.reserve(list->all_connections_.size());
  for (auto parser : list->all_connections_) {
    result.emplace_back(parser->object());
  }

  return args.GetReturnValue().Set(
      Array::New(isolate, result.data(), result.size()));
}",68,,1037,2,,void
199907,BLOCK,-1,,"{
    result.emplace_back(parser->object());
  }",46,,1046,3,,void
199941,BLOCK,-1,,"{
  Isolate* isolate = args.GetIsolate();

  ConnectionsList* list;

  ASSIGN_OR_RETURN_UNWRAP(&list, args.Holder());

  std::vector<Local<Value>> result;
  result.reserve(list->all_connections_.size());
  for (auto parser : list->all_connections_) {
    if (parser->last_message_start_ == 0) {
      result.emplace_back(parser->object());
    }
  }

  return args.GetReturnValue().Set(
      Array::New(isolate, result.data(), result.size()));
}",69,,1054,2,,void
199981,BLOCK,-1,,"{
    if (parser->last_message_start_ == 0) {
      result.emplace_back(parser->object());
    }
  }",46,,1063,3,,void
199988,BLOCK,-1,,"{
      result.emplace_back(parser->object());
    }",43,,1064,2,,void
200022,BLOCK,-1,,"{
  Isolate* isolate = args.GetIsolate();

  ConnectionsList* list;

  ASSIGN_OR_RETURN_UNWRAP(&list, args.Holder());

  std::vector<Local<Value>> result;
  result.reserve(list->active_connections_.size());
  for (auto parser : list->active_connections_) {
    result.emplace_back(parser->object());
  }

  return args.GetReturnValue().Set(
      Array::New(isolate, result.data(), result.size()));
}",71,,1073,2,,void
200062,BLOCK,-1,,"{
    result.emplace_back(parser->object());
  }",49,,1082,3,,void
200096,BLOCK,-1,,"{
  Isolate* isolate = args.GetIsolate();

  ConnectionsList* list;

  ASSIGN_OR_RETURN_UNWRAP(&list, args.Holder());
  CHECK(args[0]->IsNumber());
  CHECK(args[1]->IsNumber());
  uint64_t headers_timeout =
    static_cast<uint64_t>(args[0].As<Uint32>()->Value()) * 1000000;
  uint64_t request_timeout =
    static_cast<uint64_t>(args[1].As<Uint32>()->Value()) * 1000000;

  if (headers_timeout == 0 && request_timeout == 0) {
    return args.GetReturnValue().Set(Array::New(isolate, 0));
  } else if (request_timeout > 0 && headers_timeout > request_timeout) {
    std::swap(headers_timeout, request_timeout);
  }

  const uint64_t now = uv_hrtime();
  const uint64_t headers_deadline =
    headers_timeout > 0 ? now - headers_timeout : 0;
  const uint64_t request_deadline =
    request_timeout > 0 ? now - request_timeout : 0;

  auto iter = list->active_connections_.begin();
  auto end = list->active_connections_.end();

  std::vector<Local<Value>> result;
  result.reserve(list->active_conn...",72,,1090,2,,void
200166,BLOCK,-1,,"{
    return args.GetReturnValue().Set(Array::New(isolate, 0));
  }",53,,1103,2,,void
200182,BLOCK,-1,,<empty>,10,,1105,1,,void
200191,BLOCK,-1,,"{
    std::swap(headers_timeout, request_timeout);
  }",72,,1105,2,,void
200265,BLOCK,-1,,"{
    Parser* parser = *iter;
    iter++;

    // Check for expiration.
    if (
      (!parser->headers_completed_ && headers_deadline > 0 &&
        parser->last_message_start_ < headers_deadline) ||
      (
        request_deadline > 0 &&
        parser->last_message_start_ < request_deadline)
    ) {
      result.emplace_back(parser->object());

      list->active_connections_.erase(parser);
    }
  }",23,,1120,2,,void
200298,BLOCK,-1,,"{
      result.emplace_back(parser->object());

      list->active_connections_.erase(parser);
    }",7,,1131,2,,void
200389,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(context);
  Environment* env = realm->env();
  Isolate* isolate = env->isolate();
  BindingData* const binding_data =
      realm->AddBindingData<BindingData>(context, target);
  if (binding_data == nullptr) return;

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, Parser::New);
  t->InstanceTemplate()->SetInternalFieldCount(Parser::kInternalFieldCount);

  t->Set(FIXED_ONE_BYTE_STRING(env->isolate(), ""REQUEST""),
         Integer::New(env->isolate(), HTTP_REQUEST));
  t->Set(FIXED_ONE_BYTE_STRING(env->isolate(), ""RESPONSE""),
         Integer::New(env->isolate(), HTTP_RESPONSE));
  t->Set(FIXED_ONE_BYTE_STRING(env->isolate(), ""kOnMessageBegin""),
         Integer::NewFromUnsigned(env->isolate(), kOnMessageBegin));
  t->Set(FIXED_ONE_BYTE_STRING(env->isolate(), ""kOnHeaders""),
         Integer::NewFromUnsigned(env->isolate(), kOnHeaders));
  t->Set(FIXED_ONE_BYTE_STRING(env->isolate(), ""kOnHeadersComplete""),
         Integer::NewFromUnsigne...",39,,1191,5,,void
200429,BLOCK,-1,,<empty>,32,,1197,2,,void
200966,BLOCK,-1,,<empty>,1,,1,1,,ANY
200983,BLOCK,-1,,<empty>,1,,1,1,,ANY
201012,BLOCK,-1,,<empty>,1,,1,1,,ANY
201027,BLOCK,-1,,<empty>,1,,1,1,,ANY
201031,BLOCK,-1,,"{
  return node::Start(argc, argv);
}",34,,96,3,,void
201077,BLOCK,-1,,<empty>,1,,1,1,,ANY
201085,BLOCK,-1,,"{
  isolate_params_->array_buffer_allocator = array_buffer_allocator_.get();

  isolate_ =
      NewIsolate(isolate_params_.get(), event_loop, platform, snapshot_data);
  CHECK_NOT_NULL(isolate_);

  // If the indexes are not nullptr, we are not deserializing
  isolate_data_.reset(
      CreateIsolateData(isolate_,
                        event_loop,
                        platform,
                        array_buffer_allocator_.get(),
                        snapshot_data->AsEmbedderWrapper().get()));

  isolate_data_->max_young_gen_size =
      isolate_params_->constraints.max_young_generation_size_in_bytes();
}",37,,45,6,,void
201137,BLOCK,-1,,"{
  if (isolate_params_ == nullptr) {
    return;
  }
  // This should only be done on a main instance that owns its isolate.
  platform_->UnregisterIsolate(isolate_);
  isolate_->Dispose();
}",39,,64,1,,void
201142,BLOCK,-1,,"{
    return;
  }",35,,65,2,,void
201156,BLOCK,-1,,"{
  Locker locker(isolate_);
  Isolate::Scope isolate_scope(isolate_);
  HandleScope handle_scope(isolate_);

  ExitCode exit_code = ExitCode::kNoFailure;
  DeleteFnPtr<Environment, FreeEnvironment> env =
      CreateMainEnvironment(&exit_code);
  CHECK_NOT_NULL(env);

  Context::Scope context_scope(env->context());
  Run(&exit_code, env.get());
  return exit_code;
}",34,,73,1,,void
201204,BLOCK,-1,,"{
  if (*exit_code == ExitCode::kNoFailure) {
    bool is_sea = false;
#ifndef DISABLE_SINGLE_EXECUTABLE_APPLICATION
    if (sea::IsSingleExecutable()) {
      is_sea = true;
      LoadEnvironment(env, sea::FindSingleExecutableCode());
    }
#endif
    if (!is_sea) {
      LoadEnvironment(env, StartExecutionCallback{});
    }

    *exit_code =
        SpinEventLoopInternal(env).FromMaybe(ExitCode::kGenericUserError);
  }

#if defined(LEAK_SANITIZER)
  __lsan_do_leak_check();
#endif
}",67,,88,3,,void
201212,BLOCK,-1,,"{
    bool is_sea = false;
#ifndef DISABLE_SINGLE_EXECUTABLE_APPLICATION
    if (sea::IsSingleExecutable()) {
      is_sea = true;
      LoadEnvironment(env, sea::FindSingleExecutableCode());
    }
#endif
    if (!is_sea) {
      LoadEnvironment(env, StartExecutionCallback{});
    }

    *exit_code =
        SpinEventLoopInternal(env).FromMaybe(ExitCode::kGenericUserError);
  }",43,,89,2,,void
201222,BLOCK,-1,,"{
      is_sea = true;
      LoadEnvironment(env, sea::FindSingleExecutableCode());
    }",36,,92,2,,void
201235,BLOCK,-1,,"{
      LoadEnvironment(env, StartExecutionCallback{});
    }",18,,97,2,,void
201255,BLOCK,-1,,"{
  *exit_code = ExitCode::kNoFailure;  // Reset the exit code to 0

  HandleScope handle_scope(isolate_);

  // TODO(addaleax): This should load a real per-Isolate option, currently
  // this is still effectively per-process.
  if (isolate_data_->options()->track_heap_objects) {
    isolate_->GetHeapProfiler()->StartTrackingHeapObjects(true);
  }

  Local<Context> context;
  DeleteFnPtr<Environment, FreeEnvironment> env;

  if (snapshot_data_ != nullptr) {
    env.reset(CreateEnvironment(isolate_data_.get(),
                                Local<Context>(),  // read from snapshot
                                args_,
                                exec_args_));
#if HAVE_OPENSSL
    crypto::InitCryptoOnce(isolate_);
#endif  // HAVE_OPENSSL
  } else {
    context = NewContext(isolate_);
    CHECK(!context.IsEmpty());
    Context::Scope context_scope(context);
    env.reset(
        CreateEnvironment(isolate_data_.get(), context, args_, exec_args_));
  }

  return env;
}",62,,111,2,,void
201272,BLOCK,-1,,"{
    isolate_->GetHeapProfiler()->StartTrackingHeapObjects(true);
  }",53,,118,2,,void
201297,BLOCK,-1,,"{
    env.reset(CreateEnvironment(isolate_data_.get(),
                                Local<Context>(),  // read from snapshot
                                args_,
                                exec_args_));
#if HAVE_OPENSSL
    crypto::InitCryptoOnce(isolate_);
#endif  // HAVE_OPENSSL
  }",34,,125,2,,void
201311,BLOCK,-1,,"{
    context = NewContext(isolate_);
    CHECK(!context.IsEmpty());
    Context::Scope context_scope(context);
    env.reset(
        CreateEnvironment(isolate_data_.get(), context, args_, exec_args_));
  }",10,,133,1,,void
201359,BLOCK,-1,,<empty>,1,,1,1,,ANY
201368,BLOCK,-1,,<empty>,1,,1,1,,ANY
201375,BLOCK,-1,,<empty>,1,,1,1,,ANY
201378,BLOCK,-1,,"{
    for (BaseObjectPtr<BaseObject> object : host_objects) {
      if (!object) continue;

      // If the function did not finish successfully, host_objects will contain
      // a list of objects that will never be passed to JS. Therefore, we
      // destroy them here.
      object->Detach();
    }
  }",37,,166,1,,void
201382,BLOCK,-1,,"{
      if (!object) continue;

      // If the function did not finish successfully, host_objects will contain
      // a list of objects that will never be passed to JS. Therefore, we
      // destroy them here.
      object->Detach();
    }",59,,167,3,,void
201386,BLOCK,-1,,<empty>,20,,168,2,,void
201398,BLOCK,-1,,"{
    // Called when data has been put into the queue.
    MessagePort* channel = ContainerOf(&MessagePort::async_, handle);
    channel->OnMessage(MessageProcessingMode::kNormalOperation);
  }",43,,641,2,,void
201419,BLOCK,-1,,{ if (!succeeded) Close(); },37,,652,1,,void
201423,BLOCK,-1,,<empty>,55,,652,2,,void
201451,BLOCK,-1,,<empty>,1,,1,1,,ANY
201462,BLOCK,-1,,"{
  return BaseObject::TransferMode::kUntransferable;
}",62,,50,1,,void
201472,BLOCK,-1,,"{
  return CloneForMessaging();
}",74,,54,1,,void
201478,BLOCK,-1,,"{
  return {};
}",77,,58,1,,void
201483,BLOCK,-1,,"{
  return Just(BaseObjectList {});
}",63,,62,1,,void
201493,BLOCK,-1,,"{
  return Just(true);
}",62,,67,3,,void
201503,BLOCK,-1,,"{
  return Just(true);
}",58,,74,3,,void
201511,BLOCK,-1,,<empty>,44,,79,2,,void
201515,BLOCK,-1,,"{
  return main_message_buf_.data == nullptr;
}",38,,81,1,,void
201533,BLOCK,-1,,<empty>,55,,101,7,,void
201538,BLOCK,-1,,"{
    // Identifying the index in the message's BaseObject array is sufficient.
    uint32_t id;
    if (!deserializer->ReadUint32(&id))
      return MaybeLocal<Object>();
    if (id != kNormalObject) {
      CHECK_LT(id, host_objects_.size());
      return host_objects_[id]->object(isolate);
    }
    EscapableHandleScope scope(isolate);
    Local<Context> context = isolate->GetCurrentContext();
    Local<Value> object;
    if (!deserializer->ReadValue(context).ToLocal(&object))
      return MaybeLocal<Object>();
    CHECK(object->IsObject());
    return scope.Escape(object.As<Object>());
  }",64,,103,2,,void
201548,BLOCK,-1,,<empty>,7,,107,2,,void
201555,BLOCK,-1,,"{
      CHECK_LT(id, host_objects_.size());
      return host_objects_[id]->object(isolate);
    }",30,,108,2,,void
201600,BLOCK,-1,,<empty>,7,,116,2,,void
201622,BLOCK,-1,,"{
    CHECK_LT(clone_id, shared_array_buffers_.size());
    return shared_array_buffers_[clone_id];
  }",53,,122,3,,void
201638,BLOCK,-1,,"{
    CHECK_LT(transfer_id, wasm_modules_.size());
    return WasmModuleObject::FromCompiledModule(
        isolate, wasm_modules_[transfer_id]);
  }",56,,128,3,,void
201658,BLOCK,-1,,"{
    CHECK(shared_value_conveyor_.has_value());
    return &shared_value_conveyor_.value();
  }",80,,134,2,,void
201678,BLOCK,-1,,<empty>,,,,1,,<empty>
201688,BLOCK,-1,,"{
  Context::Scope context_scope(context);

  CHECK(!IsCloseMessage());
  if (port_list != nullptr && !transferables_.empty()) {
    // Need to create this outside of the EscapableHandleScope, but inside
    // the Context::Scope.
    *port_list = Array::New(env->isolate());
  }

  EscapableHandleScope handle_scope(env->isolate());

  // Create all necessary objects for transferables, e.g. MessagePort handles.
  std::vector<BaseObjectPtr<BaseObject>> host_objects(transferables_.size());
  auto cleanup = OnScopeLeave([&]() {
    for (BaseObjectPtr<BaseObject> object : host_objects) {
      if (!object) continue;

      // If the function did not finish successfully, host_objects will contain
      // a list of objects that will never be passed to JS. Therefore, we
      // destroy them here.
      object->Detach();
    }
  });

  for (uint32_t i = 0; i < transferables_.size(); ++i) {
    HandleScope handle_scope(env->isolate());
    TransferData* data = transferables_[i].get();
    h...",65,,152,4,,void
201705,BLOCK,-1,,"{
    // Need to create this outside of the EscapableHandleScope, but inside
    // the Context::Scope.
    *port_list = Array::New(env->isolate());
  }",56,,156,2,,void
201742,BLOCK,-1,,<empty>,3,,177,1,,void
201755,BLOCK,4,,"{
    HandleScope handle_scope(env->isolate());
    TransferData* data = transferables_[i].get();
    host_objects[i] = data->Deserialize(
        env, context, std::move(transferables_[i]));
    if (!host_objects[i]) return {};
    if (port_list != nullptr) {
      // If we gather a list of all message ports, and this transferred object
      // is a message port, add it to that list. This is a bit of an odd case
      // of special handling for MessagePorts (as opposed to applying to all
      // transferables), but it's required for spec compliance.
      DCHECK((*port_list)->IsArray());
      Local<Array> port_list_array = port_list->As<Array>();
      Local<Object> obj = host_objects[i]->object();
      if (env->message_port_constructor_template()->HasInstance(obj)) {
        if (port_list_array->Set(context,
                                 port_list_array->Length(),
                                 obj).IsNothing()) {
          return {};
        }
      }
    }
  }",56,,177,4,,void
201793,BLOCK,-1,,<empty>,27,,182,2,,void
201799,BLOCK,-1,,"{
      // If we gather a list of all message ports, and this transferred object
      // is a message port, add it to that list. This is a bit of an odd case
      // of special handling for MessagePorts (as opposed to applying to all
      // transferables), but it's required for spec compliance.
      DCHECK((*port_list)->IsArray());
      Local<Array> port_list_array = port_list->As<Array>();
      Local<Object> obj = host_objects[i]->object();
      if (env->message_port_constructor_template()->HasInstance(obj)) {
        if (port_list_array->Set(context,
                                 port_list_array->Length(),
                                 obj).IsNothing()) {
          return {};
        }
      }
    }",31,,183,2,,void
201837,BLOCK,-1,,"{
        if (port_list_array->Set(context,
                                 port_list_array->Length(),
                                 obj).IsNothing()) {
          return {};
        }
      }",71,,191,2,,void
201852,BLOCK,-1,,"{
          return {};
        }",52,,194,2,,void
201868,BLOCK,-1,,<empty>,3,,204,1,,void
201881,BLOCK,4,,"{
    Local<SharedArrayBuffer> sab =
        SharedArrayBuffer::New(env->isolate(), shared_array_buffers_[i]);
    shared_array_buffers.push_back(sab);
  }",63,,204,4,,void
201935,BLOCK,-1,,<empty>,3,,224,1,,void
201948,BLOCK,4,,"{
    Local<ArrayBuffer> ab =
        ArrayBuffer::New(env->isolate(), std::move(array_buffers_[i]));
    deserializer.TransferArrayBuffer(i, ab);
  }",56,,224,4,,void
201985,BLOCK,-1,,<empty>,5,,231,2,,void
202004,BLOCK,-1,,<empty>,5,,234,2,,void
202009,BLOCK,-1,,"{
    if (base_object->FinalizeTransferRead(context, &deserializer).IsNothing())
      return {};
  }",62,,236,3,,void
202021,BLOCK,-1,,<empty>,7,,238,2,,void
202037,BLOCK,-1,,"{
  shared_array_buffers_.emplace_back(std::move(backing_store));
}",50,,246,2,,void
202051,BLOCK,-1,,"{
  transferables_.emplace_back(std::move(data));
}",69,,250,2,,void
202065,BLOCK,-1,,"{
  wasm_modules_.emplace_back(std::move(mod));
  return wasm_modules_.size() - 1;
}",59,,254,2,,void
202086,BLOCK,-1,,"{
  shared_value_conveyor_.emplace(std::move(conveyor));
}",72,,259,2,,void
202101,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  Local<Object> per_context_bindings;
  Local<Value> emit_message_val;
  if (!GetPerContextExports(context).ToLocal(&per_context_bindings) ||
      !per_context_bindings->Get(context,
                                FIXED_ONE_BYTE_STRING(isolate, ""emitMessage""))
          .ToLocal(&emit_message_val)) {
    return MaybeLocal<Function>();
  }
  CHECK(emit_message_val->IsFunction());
  return emit_message_val.As<Function>();
}",69,,265,2,,void
202143,BLOCK,-1,,"{
    return MaybeLocal<Function>();
  }",40,,272,2,,void
202160,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  Local<Object> per_context_bindings;
  Local<Value> domexception_ctor_val;
  if (!GetPerContextExports(context).ToLocal(&per_context_bindings) ||
      !per_context_bindings->Get(context,
                                FIXED_ONE_BYTE_STRING(isolate, ""DOMException""))
          .ToLocal(&domexception_ctor_val)) {
    return MaybeLocal<Function>();
  }
  CHECK(domexception_ctor_val->IsFunction());
  Local<Function> domexception_ctor = domexception_ctor_val.As<Function>();
  return domexception_ctor;
}",62,,279,2,,void
202202,BLOCK,-1,,"{
    return MaybeLocal<Function>();
  }",45,,286,2,,void
202227,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  Local<Value> argv[] = {message,
                         FIXED_ONE_BYTE_STRING(isolate, ""DataCloneError"")};
  Local<Value> exception;
  Local<Function> domexception_ctor;
  if (!GetDOMException(context).ToLocal(&domexception_ctor) ||
      !domexception_ctor->NewInstance(context, arraysize(argv), argv)
           .ToLocal(&exception)) {
    return;
  }
  isolate->ThrowException(exception);
}",77,,294,3,,void
202277,BLOCK,-1,,"{
    return;
  }",34,,302,2,,void
202291,BLOCK,-1,,<empty>,47,,314,4,,void
202296,BLOCK,-1,,"{
    ThrowDataCloneException(context_, message);
  }",60,,316,2,,void
202305,BLOCK,-1,,"{
    if (BaseObject::IsBaseObject(object)) {
      return WriteHostObject(
          BaseObjectPtr<BaseObject> { Unwrap<BaseObject>(object) });
    }

    // Convert process.env to a regular object.
    auto env_proxy_ctor_template = env_->env_proxy_ctor_template();
    if (!env_proxy_ctor_template.IsEmpty() &&
        env_proxy_ctor_template->HasInstance(object)) {
      HandleScope scope(isolate);
      // TODO(bnoordhuis) Prototype-less object in case process.env contains
      // a ""__proto__"" key? process.env has a prototype with concomitant
      // methods like toString(). It's probably confusing if that gets lost
      // in transmission.
      Local<Object> normal_object = Object::New(isolate);
      env_->env_vars()->AssignToObject(isolate, env_->context(), normal_object);
      serializer->WriteUint32(kNormalObject);  // Instead of a BaseObject.
      return serializer->WriteValue(env_->context(), normal_object);
    }

    ThrowDataCloneError(env_->clone_unsupported_typ...",80,,320,3,,void
202312,BLOCK,-1,,"{
      return WriteHostObject(
          BaseObjectPtr<BaseObject> { Unwrap<BaseObject>(object) });
    }",43,,321,2,,void
202341,BLOCK,-1,,"{
      HandleScope scope(isolate);
      // TODO(bnoordhuis) Prototype-less object in case process.env contains
      // a ""__proto__"" key? process.env has a prototype with concomitant
      // methods like toString(). It's probably confusing if that gets lost
      // in transmission.
      Local<Object> normal_object = Object::New(isolate);
      env_->env_vars()->AssignToObject(isolate, env_->context(), normal_object);
      serializer->WriteUint32(kNormalObject);  // Instead of a BaseObject.
      return serializer->WriteValue(env_->context(), normal_object);
    }",55,,329,2,,void
202396,BLOCK,-1,,"{
    uint32_t i;
    for (i = 0; i < seen_shared_array_buffers_.size(); ++i) {
      if (PersistentToLocal::Strong(seen_shared_array_buffers_[i]) ==
          shared_array_buffer) {
        return Just(i);
      }
    }

    seen_shared_array_buffers_.emplace_back(
      Global<SharedArrayBuffer> { isolate, shared_array_buffer });
    msg_->AddSharedArrayBuffer(shared_array_buffer->GetBackingStore());
    return Just(i);
  }",62,,347,3,,void
202399,BLOCK,-1,,<empty>,5,,349,1,,void
202411,BLOCK,4,,"{
      if (PersistentToLocal::Strong(seen_shared_array_buffers_[i]) ==
          shared_array_buffer) {
        return Just(i);
      }
    }",61,,349,4,,void
202422,BLOCK,-1,,"{
        return Just(i);
      }",32,,351,2,,void
202450,BLOCK,-1,,"{
    return Just(msg_->AddWASMModule(module->GetCompiledModule()));
  }",66,,363,3,,void
202466,BLOCK,-1,,"{
    msg_->AdoptSharedValueConveyor(std::move(conveyor));
    return true;
  }",74,,368,3,,void
202482,BLOCK,-1,,"{
    for (uint32_t i = 0; i < host_objects_.size(); i++) {
      BaseObjectPtr<BaseObject> host_object = std::move(host_objects_[i]);
      std::unique_ptr<TransferData> data;
      if (i < first_cloned_object_index_)
        data = host_object->TransferForMessaging();
      if (!data)
        data = host_object->CloneForMessaging();
      if (!data) return Nothing<bool>();
      if (data->FinalizeTransferWrite(context, serializer).IsNothing())
        return Nothing<bool>();
      msg_->AddTransferable(std::move(data));
    }
    return Just(true);
  }",46,,373,2,,void
202484,BLOCK,-1,,<empty>,5,,374,1,,void
202497,BLOCK,4,,"{
      BaseObjectPtr<BaseObject> host_object = std::move(host_objects_[i]);
      std::unique_ptr<TransferData> data;
      if (i < first_cloned_object_index_)
        data = host_object->TransferForMessaging();
      if (!data)
        data = host_object->CloneForMessaging();
      if (!data) return Nothing<bool>();
      if (data->FinalizeTransferWrite(context, serializer).IsNothing())
        return Nothing<bool>();
      msg_->AddTransferable(std::move(data));
    }",57,,374,4,,void
202522,BLOCK,-1,,<empty>,9,,378,2,,void
202532,BLOCK,-1,,<empty>,9,,380,2,,void
202542,BLOCK,-1,,<empty>,18,,381,2,,void
202555,BLOCK,-1,,<empty>,9,,383,2,,void
202574,BLOCK,-1,,"{
    // Make sure we have not started serializing the value itself yet.
    CHECK_EQ(first_cloned_object_index_, SIZE_MAX);
    host_objects_.emplace_back(std::move(host_object));
  }",68,,389,2,,void
202590,BLOCK,-1,,"{
    for (size_t i = 0; i < host_objects_.size(); i++) {
      std::vector<BaseObjectPtr<BaseObject>> nested_transferables;
      if (!host_objects_[i]->NestedTransferables().To(&nested_transferables))
        return Nothing<bool>();
      for (auto& nested_transferable : nested_transferables) {
        if (std::find(host_objects_.begin(),
                      host_objects_.end(),
                      nested_transferable) == host_objects_.end()) {
          AddHostObject(nested_transferable);
        }
      }
    }
    return Just(true);
  }",45,,398,1,,void
202592,BLOCK,-1,,<empty>,5,,399,1,,void
202605,BLOCK,4,,"{
      std::vector<BaseObjectPtr<BaseObject>> nested_transferables;
      if (!host_objects_[i]->NestedTransferables().To(&nested_transferables))
        return Nothing<bool>();
      for (auto& nested_transferable : nested_transferables) {
        if (std::find(host_objects_.begin(),
                      host_objects_.end(),
                      nested_transferable) == host_objects_.end()) {
          AddHostObject(nested_transferable);
        }
      }
    }",55,,399,4,,void
202628,BLOCK,-1,,<empty>,9,,402,2,,void
202634,BLOCK,-1,,"{
        if (std::find(host_objects_.begin(),
                      host_objects_.end(),
                      nested_transferable) == host_objects_.end()) {
          AddHostObject(nested_transferable);
        }
      }",62,,403,3,,void
202654,BLOCK,-1,,"{
          AddHostObject(nested_transferable);
        }",68,,406,2,,void
202665,BLOCK,-1,,"{
    BaseObject::TransferMode mode = host_object->GetTransferMode();
    if (mode == BaseObject::TransferMode::kUntransferable) {
      ThrowDataCloneError(env_->clone_unsupported_type_str());
      return Nothing<bool>();
    }

    for (uint32_t i = 0; i < host_objects_.size(); i++) {
      if (host_objects_[i] == host_object) {
        serializer->WriteUint32(i);
        return Just(true);
      }
    }

    if (mode == BaseObject::TransferMode::kTransferable) {
      THROW_ERR_MISSING_TRANSFERABLE_IN_TRANSFER_LIST(env_);
      return Nothing<bool>();
    }

    CHECK_EQ(mode, BaseObject::TransferMode::kCloneable);
    uint32_t index = host_objects_.size();
    if (first_cloned_object_index_ == SIZE_MAX)
      first_cloned_object_index_ = index;
    serializer->WriteUint32(index);
    host_objects_.push_back(host_object);
    return Just(true);
  }",70,,417,2,,void
202681,BLOCK,-1,,"{
      ThrowDataCloneError(env_->clone_unsupported_type_str());
      return Nothing<bool>();
    }",60,,419,2,,void
202690,BLOCK,-1,,<empty>,5,,424,1,,void
202703,BLOCK,4,,"{
      if (host_objects_[i] == host_object) {
        serializer->WriteUint32(i);
        return Just(true);
      }
    }",57,,424,4,,void
202710,BLOCK,-1,,"{
        serializer->WriteUint32(i);
        return Just(true);
      }",44,,425,2,,void
202727,BLOCK,-1,,"{
      THROW_ERR_MISSING_TRANSFERABLE_IN_TRANSFER_LIST(env_);
      return Nothing<bool>();
    }",58,,431,2,,void
202750,BLOCK,-1,,<empty>,7,,439,2,,void
202777,BLOCK,-1,,<empty>,,,,1,,<empty>
202792,BLOCK,-1,,"{
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(context);

  // Verify that we're not silently overwriting an existing message.
  CHECK(main_message_buf_.is_empty());

  SerializerDelegate delegate(env, context, this);
  ValueSerializer serializer(env->isolate(), &delegate);
  delegate.serializer = &serializer;

  std::vector<Local<ArrayBuffer>> array_buffers;
  for (uint32_t i = 0; i < transfer_list_v.length(); ++i) {
    Local<Value> entry = transfer_list_v[i];
    if (entry->IsObject()) {
      // See https://github.com/nodejs/node/pull/30339#issuecomment-552225353
      // for details.
      bool untransferable;
      if (!entry.As<Object>()->HasPrivate(
              context,
              env->untransferable_object_private_symbol())
              .To(&untransferable)) {
        return Nothing<bool>();
      }
      if (untransferable) continue;
    }

    // Currently, we support ArrayBuffers and BaseObjects for which
    // GetTransferMode() does ...",59,,461,6,,void
202836,BLOCK,-1,,<empty>,3,,473,1,,void
202849,BLOCK,4,,"{
    Local<Value> entry = transfer_list_v[i];
    if (entry->IsObject()) {
      // See https://github.com/nodejs/node/pull/30339#issuecomment-552225353
      // for details.
      bool untransferable;
      if (!entry.As<Object>()->HasPrivate(
              context,
              env->untransferable_object_private_symbol())
              .To(&untransferable)) {
        return Nothing<bool>();
      }
      if (untransferable) continue;
    }

    // Currently, we support ArrayBuffers and BaseObjects for which
    // GetTransferMode() does not return kUntransferable.
    if (entry->IsArrayBuffer()) {
      Local<ArrayBuffer> ab = entry.As<ArrayBuffer>();
      // If we cannot render the ArrayBuffer unusable in this Isolate,
      // copying the buffer will have to do.
      // Note that we can currently transfer ArrayBuffers even if they were
      // not allocated by Node’s ArrayBufferAllocator in the first place,
      // because we pass the underlying v8::BackingStore around rat...",59,,473,4,,void
202864,BLOCK,-1,,"{
      // See https://github.com/nodejs/node/pull/30339#issuecomment-552225353
      // for details.
      bool untransferable;
      if (!entry.As<Object>()->HasPrivate(
              context,
              env->untransferable_object_private_symbol())
              .To(&untransferable)) {
        return Nothing<bool>();
      }
      if (untransferable) continue;
    }",28,,475,2,,void
202885,BLOCK,-1,,"{
        return Nothing<bool>();
      }",37,,482,2,,void
202890,BLOCK,-1,,<empty>,27,,485,2,,void
202897,BLOCK,-1,,"{
      Local<ArrayBuffer> ab = entry.As<ArrayBuffer>();
      // If we cannot render the ArrayBuffer unusable in this Isolate,
      // copying the buffer will have to do.
      // Note that we can currently transfer ArrayBuffers even if they were
      // not allocated by Node’s ArrayBufferAllocator in the first place,
      // because we pass the underlying v8::BackingStore around rather than
      // raw data *and* an Isolate with a non-default ArrayBuffer allocator
      // is always going to outlive any Workers it creates, and so will its
      // allocator along with it.
      if (!ab->IsDetachable()) continue;
      if (std::find(array_buffers.begin(), array_buffers.end(), ab) !=
          array_buffers.end()) {
        ThrowDataCloneException(
            context,
            FIXED_ONE_BYTE_STRING(
                env->isolate(),
                ""Transfer list contains duplicate ArrayBuffer""));
        return Nothing<bool>();
      }
      // We simply use the array index i...",33,,490,2,,void
202914,BLOCK,-1,,<empty>,32,,500,2,,void
202935,BLOCK,-1,,"{
        ThrowDataCloneException(
            context,
            FIXED_ONE_BYTE_STRING(
                env->isolate(),
                ""Transfer list contains duplicate ArrayBuffer""));
        return Nothing<bool>();
      }",32,,502,2,,void
202966,BLOCK,-1,,<empty>,12,,516,1,,void
202981,BLOCK,-1,,"{
      // Check if the source MessagePort is being transferred.
      if (!source_port.IsEmpty() && entry == source_port) {
        ThrowDataCloneException(
            context,
            FIXED_ONE_BYTE_STRING(env->isolate(),
                                  ""Transfer list contains source port""));
        return Nothing<bool>();
      }
      BaseObjectPtr<BaseObject> host_object {
          Unwrap<BaseObject>(entry.As<Object>()) };
      if (env->message_port_constructor_template()->HasInstance(entry) &&
          (!host_object ||
           static_cast<MessagePort*>(host_object.get())->IsDetached())) {
        ThrowDataCloneException(
            context,
            FIXED_ONE_BYTE_STRING(
                env->isolate(),
                ""MessagePort in transfer list is already detached""));
        return Nothing<bool>();
      }
      if (std::find(delegate.host_objects_.begin(),
                    delegate.host_objects_.end(),
                    host_object) != delegate.hos...",62,,517,2,,void
202992,BLOCK,-1,,"{
        ThrowDataCloneException(
            context,
            FIXED_ONE_BYTE_STRING(env->isolate(),
                                  ""Transfer list contains source port""));
        return Nothing<bool>();
      }",59,,519,2,,void
203039,BLOCK,-1,,"{
        ThrowDataCloneException(
            context,
            FIXED_ONE_BYTE_STRING(
                env->isolate(),
                ""MessagePort in transfer list is already detached""));
        return Nothing<bool>();
      }",73,,530,2,,void
203075,BLOCK,-1,,"{
        ThrowDataCloneException(
            context,
            String::Concat(env->isolate(),
                FIXED_ONE_BYTE_STRING(
                  env->isolate(),
                  ""Transfer list contains duplicate ""),
                entry.As<Object>()->GetConstructorName()));
        return Nothing<bool>();
      }",67,,540,2,,void
203114,BLOCK,-1,,"{
        delegate.AddHostObject(host_object);
        continue;
      }",58,,551,2,,void
203133,BLOCK,-1,,<empty>,5,,561,2,,void
203150,BLOCK,-1,,"{
    return Nothing<bool>();
  }",58,,564,2,,void
203156,BLOCK,-1,,"{
    // If serialization succeeded, we render it inaccessible in this Isolate.
    std::shared_ptr<BackingStore> backing_store = ab->GetBackingStore();
    ab->Detach(Local<Value>()).Check();

    array_buffers_.emplace_back(std::move(backing_store));
  }",47,,568,3,,void
203195,BLOCK,-1,,<empty>,5,,577,2,,void
203227,BLOCK,-1,,"{
  tracker->TrackField(""array_buffers_"", array_buffers_);
  tracker->TrackField(""shared_array_buffers"", shared_array_buffers_);
  tracker->TrackField(""transferables"", transferables_);
}",56,,587,2,,void
203250,BLOCK,-1,,"{
}",21,,594,2,,void
203254,BLOCK,-1,,"{
  CHECK_NULL(owner_);
  Disentangle();
}",37,,597,1,,void
203261,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  tracker->TrackField(""incoming_messages"", incoming_messages_);
}",64,,602,2,,void
203275,BLOCK,-1,,"{
  // This function will be called by other threads.
  Mutex::ScopedLock lock(mutex_);
  incoming_messages_.emplace_back(std::move(message));

  if (owner_ != nullptr) {
    Debug(owner_, ""Adding message to incoming queue"");
    owner_->TriggerAsync();
  }
}",76,,607,2,,void
203292,BLOCK,-1,,"{
    Debug(owner_, ""Adding message to incoming queue"");
    owner_->TriggerAsync();
  }",26,,612,2,,void
203305,BLOCK,-1,,"{
  auto group = std::make_shared<SiblingGroup>();
  group->Entangle({a, b});
}",72,,618,3,,void
203323,BLOCK,-1,,"{
  if (group_) {
    group_->Disentangle(this);
  }
}",37,,623,1,,void
203326,BLOCK,-1,,"{
    group_->Disentangle(this);
  }",15,,624,2,,void
203335,BLOCK,-1,,"{
  if (data_) Detach();
}",29,,629,1,,void
203338,BLOCK,-1,,<empty>,14,,630,2,,void
203346,BLOCK,-1,,"{
  auto onmessage = [](uv_async_t* handle) {
    // Called when data has been put into the queue.
    MessagePort* channel = ContainerOf(&MessagePort::async_, handle);
    channel->OnMessage(MessageProcessingMode::kNormalOperation);
  };

  CHECK_EQ(uv_async_init(env->event_loop(),
                         &async_,
                         onmessage), 0);
  // Reset later to indicate success of the constructor.
  bool succeeded = false;
  auto cleanup = OnScopeLeave([&]() { if (!succeeded) Close(); });

  Local<Value> fn;
  if (!wrap->Get(context, env->oninit_symbol()).ToLocal(&fn))
    return;

  if (fn->IsFunction()) {
    Local<Function> init = fn.As<Function>();
    if (init->Call(context, wrap, 0, nullptr).IsEmpty())
      return;
  }

  Local<Function> emit_message_fn;
  if (!GetEmitMessageFunction(context).ToLocal(&emit_message_fn))
    return;
  emit_message_fn_.Reset(env->isolate(), emit_message_fn);

  succeeded = true;
  Debug(this, ""Created message port"");
}",38,,640,4,,void
203390,BLOCK,-1,,<empty>,5,,656,2,,void
203397,BLOCK,-1,,"{
    Local<Function> init = fn.As<Function>();
    if (init->Call(context, wrap, 0, nullptr).IsEmpty())
      return;
  }",25,,658,2,,void
203420,BLOCK,-1,,<empty>,7,,661,2,,void
203436,BLOCK,-1,,<empty>,5,,666,2,,void
203456,BLOCK,-1,,"{
  return data_ == nullptr || IsHandleClosing();
}",38,,673,1,,void
203466,BLOCK,-1,,"{
  if (IsHandleClosing()) return;
  CHECK_EQ(uv_async_send(&async_), 0);
}",34,,677,1,,void
203469,BLOCK,-1,,<empty>,26,,678,2,,void
203480,BLOCK,-1,,"{
  Debug(this, ""Closing message port, data set = %d"", static_cast<int>(!!data_));

  if (data_) {
    // Wrap this call with accessing the mutex, so that TriggerAsync()
    // can check IsHandleClosing() without race conditions.
    Mutex::ScopedLock sibling_lock(data_->mutex_);
    HandleWrap::Close(close_callback);
  } else {
    HandleWrap::Close(close_callback);
  }
}",62,,682,2,,void
203491,BLOCK,-1,,"{
    // Wrap this call with accessing the mutex, so that TriggerAsync()
    // can check IsHandleClosing() without race conditions.
    Mutex::ScopedLock sibling_lock(data_->mutex_);
    HandleWrap::Close(close_callback);
  }",14,,685,2,,void
203503,BLOCK,-1,,"{
    HandleWrap::Close(close_callback);
  }",10,,690,1,,void
203513,BLOCK,-1,,"{
  // This constructor just throws an error. Unfortunately, we can’t use V8’s
  // ConstructorBehavior::kThrow, as that also removes the prototype from the
  // class (i.e. makes it behave like an arrow function).
  Environment* env = Environment::GetCurrent(args);
  THROW_ERR_CONSTRUCT_CALL_INVALID(env);
}",64,,695,2,,void
203531,BLOCK,-1,,"{
  Context::Scope context_scope(context);
  Local<FunctionTemplate> ctor_templ = GetMessagePortConstructorTemplate(env);

  // Construct a new instance, then assign the listener instance and possibly
  // the MessagePortData to it.
  Local<Object> instance;
  if (!ctor_templ->InstanceTemplate()->NewInstance(context).ToLocal(&instance))
    return nullptr;
  MessagePort* port = new MessagePort(env, context, instance);
  CHECK_NOT_NULL(port);
  if (port->IsHandleClosing()) {
    // Construction failed with an exception.
    return nullptr;
  }

  if (data) {
    CHECK(!sibling_group);
    port->Detach();
    port->data_ = std::move(data);

    // This lock is here to avoid race conditions with the `owner_` read
    // in AddToIncomingQueue(). (This would likely be unproblematic without it,
    // but it's better to be safe than sorry.)
    Mutex::ScopedLock lock(port->data_->mutex_);
    port->data_->owner_ = port;
    // If the existing MessagePortData object had pending messages, t...",50,,707,5,,void
203563,BLOCK,-1,,<empty>,5,,715,2,,void
203581,BLOCK,-1,,"{
    // Construction failed with an exception.
    return nullptr;
  }",32,,718,2,,void
203586,BLOCK,-1,,"{
    CHECK(!sibling_group);
    port->Detach();
    port->data_ = std::move(data);

    // This lock is here to avoid race conditions with the `owner_` read
    // in AddToIncomingQueue(). (This would likely be unproblematic without it,
    // but it's better to be safe than sorry.)
    Mutex::ScopedLock lock(port->data_->mutex_);
    port->data_->owner_ = port;
    // If the existing MessagePortData object had pending messages, this is
    // the easiest way to run that queue.
    port->TriggerAsync();
  }",13,,723,2,,void
203622,BLOCK,-1,,<empty>,10,,736,1,,void
203625,BLOCK,-1,,"{
    sibling_group->Entangle(port->data_.get());
  }",29,,736,2,,void
203644,BLOCK,-1,,"{
  std::shared_ptr<Message> received;
  {
    // Get the head of the message queue.
    Mutex::ScopedLock lock(data_->mutex_);

    Debug(this, ""MessagePort has message"");

    bool wants_message =
        receiving_messages_ ||
        mode == MessageProcessingMode::kForceReadMessages;
    // We have nothing to do if:
    // - There are no pending messages
    // - We are not intending to receive messages, and the message we would
    //   receive is not the final ""close"" message.
    if (data_->incoming_messages_.empty() ||
        (!wants_message &&
         !data_->incoming_messages_.front()->IsCloseMessage())) {
      return env()->no_message_symbol();
    }

    received = data_->incoming_messages_.front();
    data_->incoming_messages_.pop_front();
  }

  if (received->IsCloseMessage()) {
    Close();
    return env()->no_message_symbol();
  }

  if (!env()->can_call_into_js()) return MaybeLocal<Value>();

  return received->Deserialize(env(), context, port_list);
}",72,,744,4,,void
203652,BLOCK,2,,"{
    // Get the head of the message queue.
    Mutex::ScopedLock lock(data_->mutex_);

    Debug(this, ""MessagePort has message"");

    bool wants_message =
        receiving_messages_ ||
        mode == MessageProcessingMode::kForceReadMessages;
    // We have nothing to do if:
    // - There are no pending messages
    // - We are not intending to receive messages, and the message we would
    //   receive is not the final ""close"" message.
    if (data_->incoming_messages_.empty() ||
        (!wants_message &&
         !data_->incoming_messages_.front()->IsCloseMessage())) {
      return env()->no_message_symbol();
    }

    received = data_->incoming_messages_.front();
    data_->incoming_messages_.pop_front();
  }",3,,746,2,,void
203692,BLOCK,-1,,"{
      return env()->no_message_symbol();
    }",65,,761,2,,void
203717,BLOCK,-1,,"{
    Close();
    return env()->no_message_symbol();
  }",35,,769,2,,void
203730,BLOCK,-1,,<empty>,35,,774,2,,void
203745,BLOCK,-1,,"{
  Debug(this, ""Running MessagePort::OnMessage()"");
  HandleScope handle_scope(env()->isolate());
  Local<Context> context =
      object(env()->isolate())->GetCreationContext().ToLocalChecked();

  size_t processing_limit;
  if (mode == MessageProcessingMode::kNormalOperation) {
    Mutex::ScopedLock(data_->mutex_);
    processing_limit = std::max(data_->incoming_messages_.size(),
                                static_cast<size_t>(1000));
  } else {
    processing_limit = std::numeric_limits<size_t>::max();
  }

  // data_ can only ever be modified by the owner thread, so no need to lock.
  // However, the message port may be transferred while it is processing
  // messages, so we need to check that this handle still owns its `data_` field
  // on every iteration.
  while (data_) {
    if (processing_limit-- == 0) {
      // Prevent event loop starvation by only processing those messages without
      // interruption that were already present when the OnMessage() call was
      /...",57,,779,2,,void
203779,BLOCK,-1,,"{
    Mutex::ScopedLock(data_->mutex_);
    processing_limit = std::max(data_->incoming_messages_.size(),
                                static_cast<size_t>(1000));
  }",56,,786,2,,void
203803,BLOCK,-1,,"{
    processing_limit = std::numeric_limits<size_t>::max();
  }",10,,790,1,,void
203818,BLOCK,-1,,"{
    if (processing_limit-- == 0) {
      // Prevent event loop starvation by only processing those messages without
      // interruption that were already present when the OnMessage() call was
      // first triggered, but at least 1000 messages because otherwise the
      // overhead of repeatedly triggering the uv_async_t instance becomes
      // noticeable, at least on Windows.
      // (That might require more investigation by somebody more familiar with
      // Windows.)
      TriggerAsync();
      return;
    }

    HandleScope handle_scope(env()->isolate());
    Context::Scope context_scope(context);
    Local<Function> emit_message = PersistentToLocal::Strong(emit_message_fn_);

    Local<Value> payload;
    Local<Value> port_list = Undefined(env()->isolate());
    Local<Value> message_error;
    Local<Value> argv[3];

    {
      // Catch any exceptions from parsing the message itself (not from
      // emitting it) as 'messageeror' events.
      TryCatchScope try_catc...",17,,798,2,,void
203824,BLOCK,-1,,"{
      // Prevent event loop starvation by only processing those messages without
      // interruption that were already present when the OnMessage() call was
      // first triggered, but at least 1000 messages because otherwise the
      // overhead of repeatedly triggering the uv_async_t instance becomes
      // noticeable, at least on Windows.
      // (That might require more investigation by somebody more familiar with
      // Windows.)
      TriggerAsync();
      return;
    }",34,,799,2,,void
203875,BLOCK,11,,"{
      // Catch any exceptions from parsing the message itself (not from
      // emitting it) as 'messageeror' events.
      TryCatchScope try_catch(env());
      if (!ReceiveMessage(context, mode, &port_list).ToLocal(&payload)) {
        if (try_catch.HasCaught() && !try_catch.HasTerminated())
          message_error = try_catch.Exception();
        goto reschedule;
      }
    }",5,,820,11,,void
203891,BLOCK,-1,,"{
        if (try_catch.HasCaught() && !try_catch.HasTerminated())
          message_error = try_catch.Exception();
        goto reschedule;
      }",73,,824,2,,void
203903,BLOCK,-1,,<empty>,11,,826,2,,void
203918,BLOCK,-1,,<empty>,48,,830,2,,void
203926,BLOCK,-1,,"{
      Debug(this, ""MessagePort drains queue because !can_call_into_js()"");
      // In this case there is nothing to do but to drain the current queue.
      continue;
    }",37,,832,2,,void
203958,BLOCK,-1,,"{
    reschedule:
      if (!message_error.IsEmpty()) {
        argv[0] = message_error;
        argv[1] = Undefined(env()->isolate());
        argv[2] = env()->messageerror_string();
        USE(MakeCallback(emit_message, arraysize(argv), argv));
      }

      // Re-schedule OnMessage() execution in case of failure.
      if (data_)
        TriggerAsync();
      return;
    }",70,,842,2,,void
203966,BLOCK,-1,,"{
        argv[0] = message_error;
        argv[1] = Undefined(env()->isolate());
        argv[2] = env()->messageerror_string();
        USE(MakeCallback(emit_message, arraysize(argv), argv));
      }",37,,844,2,,void
203992,BLOCK,-1,,<empty>,9,,853,2,,void
203998,BLOCK,-1,,"{
  Debug(this, ""MessagePort::OnClose()"");
  if (data_) {
    // Detach() returns move(data_).
    Detach()->Disentangle();
  }
}",29,,859,1,,void
204004,BLOCK,-1,,"{
    // Detach() returns move(data_).
    Detach()->Disentangle();
  }",14,,861,2,,void
204012,BLOCK,-1,,"{
  CHECK(data_);
  Mutex::ScopedLock lock(data_->mutex_);
  data_->owner_ = nullptr;
  return std::move(data_);
}",56,,867,1,,void
204033,BLOCK,-1,,"{
  if (IsDetached())
    return BaseObject::TransferMode::kUntransferable;
  return BaseObject::TransferMode::kTransferable;
}",63,,874,1,,void
204036,BLOCK,-1,,<empty>,5,,876,2,,void
204052,BLOCK,-1,,"{
  Close();
  return Detach();
}",67,,880,1,,void
204062,BLOCK,-1,,"{
  return BaseObjectPtr<MessagePort> { MessagePort::New(
      env, context,
      static_unique_pointer_cast<MessagePortData>(std::move(self))) };
}",41,,888,4,,void
204088,BLOCK,-1,,"{
  Isolate* isolate = env->isolate();
  Local<Object> obj = object(isolate);

  std::shared_ptr<Message> msg = std::make_shared<Message>();

  // Per spec, we need to both check if transfer list has the source port, and
  // serialize the input message, even if the MessagePort is closed or detached.

  Maybe<bool> serialization_maybe =
      msg->Serialize(env, context, message_v, transfer_v, obj);
  if (data_ == nullptr) {
    return serialization_maybe;
  }
  if (serialization_maybe.IsNothing()) {
    return Nothing<bool>();
  }

  std::string error;
  Maybe<bool> res = data_->Dispatch(msg, &error);
  if (res.IsNothing())
    return res;

  if (!error.empty())
    ProcessEmitWarning(env, error.c_str());

  return res;
}",70,,897,5,,void
204132,BLOCK,-1,,"{
    return serialization_maybe;
  }",25,,908,2,,void
204140,BLOCK,-1,,"{
    return Nothing<bool>();
  }",40,,911,2,,void
204159,BLOCK,-1,,<empty>,5,,918,2,,void
204168,BLOCK,-1,,<empty>,5,,921,2,,void
204182,BLOCK,-1,,"{
  if (!group_) {
    if (error != nullptr)
      *error = ""MessagePortData is not entangled."";
    return Nothing<bool>();
  }
  return group_->Dispatch(this, message, error);
}",25,,928,3,,void
204186,BLOCK,-1,,"{
    if (error != nullptr)
      *error = ""MessagePortData is not entangled."";
    return Nothing<bool>();
  }",16,,929,2,,void
204191,BLOCK,-1,,<empty>,7,,931,2,,void
204213,BLOCK,-1,,"{
  if (!object->IsObject()) return Just(false);

  if (object->IsArray()) {
    Local<Array> arr = object.As<Array>();
    size_t length = arr->Length();
    transfer_list.AllocateSufficientStorage(length);
    for (size_t i = 0; i < length; i++) {
      if (!arr->Get(context, i).ToLocal(&transfer_list[i]))
        return Nothing<bool>();
    }
    return Just(true);
  }

  Isolate* isolate = env->isolate();
  Local<Value> iterator_method;
  if (!object.As<Object>()->Get(context, Symbol::GetIterator(isolate))
      .ToLocal(&iterator_method)) return Nothing<bool>();
  if (!iterator_method->IsFunction()) return Just(false);

  Local<Value> iterator;
  if (!iterator_method.As<Function>()->Call(context, object, 0, nullptr)
      .ToLocal(&iterator)) return Nothing<bool>();
  if (!iterator->IsObject()) return Just(false);

  Local<Value> next;
  if (!iterator.As<Object>()->Get(context, env->next_string()).ToLocal(&next))
    return Nothing<bool>();
  if (!next->IsFunction()) return Jus...",54,,941,5,,void
204220,BLOCK,-1,,<empty>,28,,942,2,,void
204229,BLOCK,-1,,"{
    Local<Array> arr = object.As<Array>();
    size_t length = arr->Length();
    transfer_list.AllocateSufficientStorage(length);
    for (size_t i = 0; i < length; i++) {
      if (!arr->Get(context, i).ToLocal(&transfer_list[i]))
        return Nothing<bool>();
    }
    return Just(true);
  }",26,,944,2,,void
204253,BLOCK,-1,,<empty>,5,,948,1,,void
204263,BLOCK,4,,"{
      if (!arr->Get(context, i).ToLocal(&transfer_list[i]))
        return Nothing<bool>();
    }",41,,948,4,,void
204279,BLOCK,-1,,<empty>,9,,950,2,,void
204317,BLOCK,-1,,<empty>,35,,958,2,,void
204326,BLOCK,-1,,<empty>,39,,959,2,,void
204353,BLOCK,-1,,<empty>,28,,963,2,,void
204362,BLOCK,-1,,<empty>,30,,964,2,,void
204390,BLOCK,-1,,<empty>,5,,968,2,,void
204399,BLOCK,-1,,<empty>,28,,969,2,,void
204417,BLOCK,-1,,"{
    Local<Value> result;
    if (!next.As<Function>()->Call(context, iterator, 0, nullptr)
        .ToLocal(&result)) return Nothing<bool>();
    if (!result->IsObject()) return Just(false);

    Local<Value> done;
    if (!result.As<Object>()->Get(context, env->done_string()).ToLocal(&done))
      return Nothing<bool>();
    if (done->BooleanValue(isolate)) break;

    Local<Value> val;
    if (!result.As<Object>()->Get(context, env->value_string()).ToLocal(&val))
      return Nothing<bool>();
    entries.push_back(val);
  }",35,,972,2,,void
204441,BLOCK,-1,,<empty>,28,,975,2,,void
204450,BLOCK,-1,,<empty>,30,,976,2,,void
204478,BLOCK,-1,,<empty>,7,,980,2,,void
204487,BLOCK,-1,,<empty>,38,,981,2,,void
204513,BLOCK,-1,,<empty>,7,,985,2,,void
204552,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Local<Object> obj = args.This();
  Local<Context> context = obj->GetCreationContext().ToLocalChecked();

  if (args.Length() == 0) {
    return THROW_ERR_MISSING_ARGS(env, ""Not enough arguments to ""
                                       ""MessagePort.postMessage"");
  }

  if (!args[1]->IsNullOrUndefined() && !args[1]->IsObject()) {
    // Browsers ignore null or undefined, and otherwise accept an array or an
    // options object.
    return THROW_ERR_INVALID_ARG_TYPE(env,
        ""Optional transferList argument must be an iterable"");
  }

  TransferList transfer_list;
  if (args[1]->IsObject()) {
    bool was_iterable;
    if (!ReadIterable(env, context, transfer_list, args[1]).To(&was_iterable))
      return;
    if (!was_iterable) {
      Local<Value> transfer_option;
      if (!args[1].As<Object>()->Get(context, env->transfer_string())
          .ToLocal(&transfer_option)) return;
      if (!transfer_option->IsUndefined()) ...",72,,994,2,,void
204591,BLOCK,-1,,"{
    return THROW_ERR_MISSING_ARGS(env, ""Not enough arguments to ""
                                       ""MessagePort.postMessage"");
  }",27,,999,2,,void
204612,BLOCK,-1,,"{
    // Browsers ignore null or undefined, and otherwise accept an array or an
    // options object.
    return THROW_ERR_INVALID_ARG_TYPE(env,
        ""Optional transferList argument must be an iterable"");
  }",62,,1004,2,,void
204625,BLOCK,-1,,"{
    bool was_iterable;
    if (!ReadIterable(env, context, transfer_list, args[1]).To(&was_iterable))
      return;
    if (!was_iterable) {
      Local<Value> transfer_option;
      if (!args[1].As<Object>()->Get(context, env->transfer_string())
          .ToLocal(&transfer_option)) return;
      if (!transfer_option->IsUndefined()) {
        if (!ReadIterable(env, context, transfer_list, transfer_option)
            .To(&was_iterable)) return;
        if (!was_iterable) {
          return THROW_ERR_INVALID_ARG_TYPE(env,
              ""Optional options.transfer argument must be an iterable"");
        }
      }
    }
  }",28,,1012,2,,void
204641,BLOCK,-1,,<empty>,7,,1015,2,,void
204646,BLOCK,-1,,"{
      Local<Value> transfer_option;
      if (!args[1].As<Object>()->Get(context, env->transfer_string())
          .ToLocal(&transfer_option)) return;
      if (!transfer_option->IsUndefined()) {
        if (!ReadIterable(env, context, transfer_list, transfer_option)
            .To(&was_iterable)) return;
        if (!was_iterable) {
          return THROW_ERR_INVALID_ARG_TYPE(env,
              ""Optional options.transfer argument must be an iterable"");
        }
      }
    }",24,,1016,2,,void
204673,BLOCK,-1,,<empty>,39,,1019,2,,void
204681,BLOCK,-1,,"{
        if (!ReadIterable(env, context, transfer_list, transfer_option)
            .To(&was_iterable)) return;
        if (!was_iterable) {
          return THROW_ERR_INVALID_ARG_TYPE(env,
              ""Optional options.transfer argument must be an iterable"");
        }
      }",44,,1020,2,,void
204694,BLOCK,-1,,<empty>,33,,1022,2,,void
204699,BLOCK,-1,,"{
          return THROW_ERR_INVALID_ARG_TYPE(env,
              ""Optional options.transfer argument must be an iterable"");
        }",28,,1023,2,,void
204724,BLOCK,-1,,"{
    Message msg;
    USE(msg.Serialize(env, context, args[0], transfer_list, obj));
    return;
  }",51,,1035,2,,void
204757,BLOCK,-1,,<empty>,5,,1043,2,,void
204772,BLOCK,-1,,"{
  Debug(this, ""Start receiving messages"");
  receiving_messages_ = true;
  Mutex::ScopedLock lock(data_->mutex_);
  if (!data_->incoming_messages_.empty())
    TriggerAsync();
}",27,,1046,1,,void
204792,BLOCK,-1,,<empty>,5,,1051,2,,void
204797,BLOCK,-1,,"{
  Debug(this, ""Stop receiving messages"");
  receiving_messages_ = false;
}",26,,1054,1,,void
204808,BLOCK,-1,,"{
  MessagePort* port;
  ASSIGN_OR_RETURN_UNWRAP(&port, args.This());
  if (!port->data_) {
    return;
  }
  port->Start();
}",66,,1059,2,,void
204822,BLOCK,-1,,"{
    return;
  }",21,,1062,2,,void
204832,BLOCK,-1,,"{
  MessagePort* port;
  CHECK(args[0]->IsObject());
  ASSIGN_OR_RETURN_UNWRAP(&port, args[0].As<Object>());
  if (!port->data_) {
    return;
  }
  port->Stop();
}",65,,1068,2,,void
204855,BLOCK,-1,,"{
    return;
  }",21,,1072,2,,void
204865,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  args.GetReturnValue().Set(
      GetMessagePortConstructorTemplate(env)->HasInstance(args[0]));
}",70,,1078,2,,void
204893,BLOCK,-1,,"{
  MessagePort* port;
  ASSIGN_OR_RETURN_UNWRAP(&port, args[0].As<Object>());
  port->OnMessage(MessageProcessingMode::kForceReadMessages);
}",66,,1084,2,,void
204915,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  if (!args[0]->IsObject() ||
      !env->message_port_constructor_template()->HasInstance(args[0])) {
    return THROW_ERR_INVALID_ARG_TYPE(env,
        ""The \""port\"" argument must be a MessagePort instance"");
  }
  MessagePort* port = Unwrap<MessagePort>(args[0].As<Object>());
  if (port == nullptr) {
    // Return 'no messages' for a closed port.
    args.GetReturnValue().Set(
        Environment::GetCurrent(args)->no_message_symbol());
    return;
  }

  MaybeLocal<Value> payload = port->ReceiveMessage(
      port->object()->GetCreationContext().ToLocalChecked(),
      MessageProcessingMode::kForceReadMessages);
  if (!payload.IsEmpty())
    args.GetReturnValue().Set(payload.ToLocalChecked());
}",75,,1090,2,,void
204944,BLOCK,-1,,"{
    return THROW_ERR_INVALID_ARG_TYPE(env,
        ""The \""port\"" argument must be a MessagePort instance"");
  }",72,,1093,2,,void
204966,BLOCK,-1,,"{
    // Return 'no messages' for a closed port.
    args.GetReturnValue().Set(
        Environment::GetCurrent(args)->no_message_symbol());
    return;
  }",24,,1098,2,,void
205012,BLOCK,-1,,<empty>,5,,1109,2,,void
205028,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  if (!args[0]->IsObject() ||
      !env->message_port_constructor_template()->HasInstance(args[0])) {
    return THROW_ERR_INVALID_ARG_TYPE(env,
        ""The \""port\"" argument must be a MessagePort instance"");
  }
  MessagePort* port = Unwrap<MessagePort>(args[0].As<Object>());
  if (port == nullptr || port->IsHandleClosing()) {
    Isolate* isolate = env->isolate();
    THROW_ERR_CLOSED_MESSAGE_PORT(isolate);
    return;
  }

  Local<Value> context_arg = args[1];
  ContextifyContext* context_wrapper;
  if (!context_arg->IsObject() ||
      (context_wrapper = ContextifyContext::ContextFromContextifiedSandbox(
          env, context_arg.As<Object>())) == nullptr) {
    return THROW_ERR_INVALID_ARG_TYPE(env, ""Invalid context argument"");
  }

  std::unique_ptr<MessagePortData> data;
  if (!port->IsDetached())
    data = port->Detach();

  Context::Scope context_scope(context_wrapper->context());
  MessagePort* target =
      Messag...",74,,1112,2,,void
205057,BLOCK,-1,,"{
    return THROW_ERR_INVALID_ARG_TYPE(env,
        ""The \""port\"" argument must be a MessagePort instance"");
  }",72,,1115,2,,void
205084,BLOCK,-1,,"{
    Isolate* isolate = env->isolate();
    THROW_ERR_CLOSED_MESSAGE_PORT(isolate);
    return;
  }",51,,1120,2,,void
205125,BLOCK,-1,,"{
    return THROW_ERR_INVALID_ARG_TYPE(env, ""Invalid context argument"");
  }",55,,1130,2,,void
205143,BLOCK,-1,,<empty>,5,,1136,2,,void
205177,BLOCK,-1,,<empty>,5,,1142,2,,void
205194,BLOCK,-1,,"{
  MessagePortData::Entangle(a->data_.get(), b->data_.get());
}",60,,1145,3,,void
205216,BLOCK,-1,,"{
  MessagePortData::Entangle(a->data_.get(), b);
}",64,,1149,3,,void
205232,BLOCK,-1,,"{
  tracker->TrackField(""data"", data_);
  tracker->TrackField(""emit_message_fn"", emit_message_fn_);
}",60,,1153,2,,void
205249,BLOCK,-1,,"{
  // Factor generating the MessagePort JS constructor into its own piece
  // of code, because it is needed early on in the child environment setup.
  Local<FunctionTemplate> templ = env->message_port_constructor_template();
  if (!templ.IsEmpty())
    return templ;

  {
    Isolate* isolate = env->isolate();
    Local<FunctionTemplate> m = NewFunctionTemplate(isolate, MessagePort::New);
    m->SetClassName(env->message_port_constructor_string());
    m->InstanceTemplate()->SetInternalFieldCount(
        MessagePort::kInternalFieldCount);
    m->Inherit(HandleWrap::GetConstructorTemplate(env));

    SetProtoMethod(isolate, m, ""postMessage"", MessagePort::PostMessage);
    SetProtoMethod(isolate, m, ""start"", MessagePort::Start);

    env->set_message_port_constructor_template(m);
  }

  return GetMessagePortConstructorTemplate(env);
}",77,,1158,2,,void
205266,BLOCK,-1,,<empty>,5,,1163,2,,void
205269,BLOCK,3,,"{
    Isolate* isolate = env->isolate();
    Local<FunctionTemplate> m = NewFunctionTemplate(isolate, MessagePort::New);
    m->SetClassName(env->message_port_constructor_string());
    m->InstanceTemplate()->SetInternalFieldCount(
        MessagePort::kInternalFieldCount);
    m->Inherit(HandleWrap::GetConstructorTemplate(env));

    SetProtoMethod(isolate, m, ""postMessage"", MessagePort::PostMessage);
    SetProtoMethod(isolate, m, ""start"", MessagePort::Start);

    env->set_message_port_constructor_template(m);
  }",3,,1165,3,,void
205342,BLOCK,-1,,"{
  MakeWeak();
}",28,,1183,3,,void
205348,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  new JSTransferable(Environment::GetCurrent(args), args.This());
}",67,,1187,2,,void
205368,BLOCK,-1,,"{
  // Implement `kClone in this ? kCloneable : kTransferable`.
  HandleScope handle_scope(env()->isolate());
  errors::TryCatchScope ignore_exceptions(env());

  bool has_clone;
  if (!object()->Has(env()->context(),
                     env()->messaging_clone_symbol()).To(&has_clone)) {
    return TransferMode::kUntransferable;
  }

  return has_clone ? TransferMode::kCloneable : TransferMode::kTransferable;
}",70,,1192,1,,void
205398,BLOCK,-1,,"{
    return TransferMode::kUntransferable;
  }",71,,1199,2,,void
205415,BLOCK,-1,,"{
  return TransferOrClone(TransferMode::kTransferable);
}",70,,1206,1,,void
205424,BLOCK,-1,,"{
  return TransferOrClone(TransferMode::kCloneable);
}",73,,1210,1,,void
205434,BLOCK,-1,,"{
  // Call `this[symbol]()` where `symbol` is `kClone` or `kTransfer`,
  // which should return an object with `data` and `deserializeInfo` properties;
  // `data` is written to the serializer later, and `deserializeInfo` is stored
  // on the `TransferData` instance as a string.
  HandleScope handle_scope(env()->isolate());
  Local<Context> context = env()->isolate()->GetCurrentContext();
  Local<Symbol> method_name = mode == TransferMode::kCloneable ?
      env()->messaging_clone_symbol() : env()->messaging_transfer_symbol();

  Local<Value> method;
  if (!object()->Get(context, method_name).ToLocal(&method)) {
    return {};
  }
  if (method->IsFunction()) {
    Local<Value> result_v;
    if (!method.As<Function>()->Call(
            context, object(), 0, nullptr).ToLocal(&result_v)) {
      return {};
    }

    if (result_v->IsObject()) {
      Local<Object> result = result_v.As<Object>();
      Local<Value> data;
      Local<Value> deserialize_info;
      if (!result->Get(con...",30,,1215,2,,void
205492,BLOCK,-1,,"{
    return {};
  }",62,,1226,2,,void
205499,BLOCK,-1,,"{
    Local<Value> result_v;
    if (!method.As<Function>()->Call(
            context, object(), 0, nullptr).ToLocal(&result_v)) {
      return {};
    }

    if (result_v->IsObject()) {
      Local<Object> result = result_v.As<Object>();
      Local<Value> data;
      Local<Value> deserialize_info;
      if (!result->Get(context, env()->data_string()).ToLocal(&data) ||
          !result->Get(context, env()->deserialize_info_string())
              .ToLocal(&deserialize_info)) {
        return {};
      }
      Utf8Value deserialize_info_str(env()->isolate(), deserialize_info);
      if (*deserialize_info_str == nullptr) return {};
      return std::make_unique<Data>(
          *deserialize_info_str, Global<Value>(env()->isolate(), data));
    }
  }",29,,1229,2,,void
205523,BLOCK,-1,,"{
      return {};
    }",64,,1232,2,,void
205530,BLOCK,-1,,"{
      Local<Object> result = result_v.As<Object>();
      Local<Value> data;
      Local<Value> deserialize_info;
      if (!result->Get(context, env()->data_string()).ToLocal(&data) ||
          !result->Get(context, env()->deserialize_info_string())
              .ToLocal(&deserialize_info)) {
        return {};
      }
      Utf8Value deserialize_info_str(env()->isolate(), deserialize_info);
      if (*deserialize_info_str == nullptr) return {};
      return std::make_unique<Data>(
          *deserialize_info_str, Global<Value>(env()->isolate(), data));
    }",31,,1236,2,,void
205583,BLOCK,-1,,"{
        return {};
      }",44,,1242,2,,void
205597,BLOCK,-1,,<empty>,45,,1246,2,,void
205627,BLOCK,-1,,<empty>,5,,1253,2,,void
205634,BLOCK,-1,,<empty>,5,,1255,1,,void
205639,BLOCK,-1,,"{
  // Call `this[kTransferList]()` and return the resulting list of BaseObjects.
  HandleScope handle_scope(env()->isolate());
  Local<Context> context = env()->isolate()->GetCurrentContext();
  Local<Symbol> method_name = env()->messaging_transfer_list_symbol();

  Local<Value> method;
  if (!object()->Get(context, method_name).ToLocal(&method)) {
    return Nothing<BaseObjectList>();
  }
  if (!method->IsFunction()) return Just(BaseObjectList {});

  Local<Value> list_v;
  if (!method.As<Function>()->Call(
          context, object(), 0, nullptr).ToLocal(&list_v)) {
    return Nothing<BaseObjectList>();
  }
  if (!list_v->IsArray()) return Just(BaseObjectList {});
  Local<Array> list = list_v.As<Array>();

  BaseObjectList ret;
  for (size_t i = 0; i < list->Length(); i++) {
    Local<Value> value;
    if (!list->Get(context, i).ToLocal(&value))
      return Nothing<BaseObjectList>();
    if (value->IsObject() && BaseObject::IsBaseObject(value.As<Object>()))
      ret.emplace_bac...",45,,1259,1,,void
205687,BLOCK,-1,,"{
    return Nothing<BaseObjectList>();
  }",62,,1266,2,,void
205696,BLOCK,-1,,<empty>,30,,1269,2,,void
205724,BLOCK,-1,,"{
    return Nothing<BaseObjectList>();
  }",60,,1273,2,,void
205733,BLOCK,-1,,<empty>,27,,1276,2,,void
205750,BLOCK,-1,,<empty>,3,,1280,1,,void
205763,BLOCK,4,,"{
    Local<Value> value;
    if (!list->Get(context, i).ToLocal(&value))
      return Nothing<BaseObjectList>();
    if (value->IsObject() && BaseObject::IsBaseObject(value.As<Object>()))
      ret.emplace_back(Unwrap<BaseObject>(value));
  }",47,,1280,4,,void
205782,BLOCK,-1,,<empty>,7,,1283,2,,void
205799,BLOCK,-1,,<empty>,7,,1285,2,,void
205817,BLOCK,-1,,"{
  // Call `this[kDeserialize](data)` where `data` comes from the return value
  // of `this[kTransfer]()` or `this[kClone]()`.
  HandleScope handle_scope(env()->isolate());
  Local<Value> data;
  if (!deserializer->ReadValue(context).ToLocal(&data)) return Nothing<bool>();

  Local<Symbol> method_name = env()->messaging_deserialize_symbol();
  Local<Value> method;
  if (!object()->Get(context, method_name).ToLocal(&method)) {
    return Nothing<bool>();
  }
  if (!method->IsFunction()) return Just(true);

  if (method.As<Function>()->Call(context, object(), 1, &data).IsEmpty()) {
    return Nothing<bool>();
  }
  return Just(true);
}",62,,1291,3,,void
205841,BLOCK,-1,,<empty>,57,,1296,2,,void
205872,BLOCK,-1,,"{
    return Nothing<bool>();
  }",62,,1300,2,,void
205881,BLOCK,-1,,<empty>,30,,1303,2,,void
205901,BLOCK,-1,,"{
    return Nothing<bool>();
  }",75,,1305,2,,void
205912,BLOCK,-1,,<empty>,30,,1314,3,,void
205919,BLOCK,-1,,"{
  // Create the JS wrapper object that will later be filled with data passed to
  // the `[kDeserialize]()` method on it. This split is necessary, because here
  // we need to create an object with the right prototype and internal fields,
  // but the actual JS data stored in the serialized data can only be read at
  // the end of the stream, after the main message has been read.

  if (context != env->context()) {
    THROW_ERR_MESSAGE_TARGET_CONTEXT_UNAVAILABLE(env);
    return {};
  }
  HandleScope handle_scope(env->isolate());
  Local<Value> info;
  if (!ToV8Value(context, deserialize_info_).ToLocal(&info)) return {};

  Local<Value> ret;
  CHECK(!env->messaging_deserialize_create_object().IsEmpty());
  if (!env->messaging_deserialize_create_object()
           ->Call(context, Null(env->isolate()), 1, &info)
           .ToLocal(&ret) ||
      !ret->IsObject() || !BaseObject::IsBaseObject(ret.As<Object>())) {
    return {};
  }

  return BaseObjectPtr<BaseObject> { Unwrap<BaseO...",41,,1319,4,,void
205927,BLOCK,-1,,"{
    THROW_ERR_MESSAGE_TARGET_CONTEXT_UNAVAILABLE(env);
    return {};
  }",34,,1326,2,,void
205952,BLOCK,-1,,<empty>,62,,1332,2,,void
206007,BLOCK,-1,,"{
    return {};
  }",72,,1339,2,,void
206022,BLOCK,-1,,"{
  HandleScope handle_scope(context->GetIsolate());
  auto ret = serializer->WriteValue(context, PersistentToLocal::Strong(data_));
  data_.Reset();
  return ret;
}",58,,1347,3,,void
206052,BLOCK,-1,,"{
  Mutex::ScopedLock lock(SiblingGroup::groups_mutex_);
  std::shared_ptr<SiblingGroup> group;
  auto i = groups_.find(name);
  if (i == groups_.end() || i->second.expired()) {
    group = std::make_shared<SiblingGroup>(name);
    groups_[name] = group;
  } else {
    group = i->second.lock();
  }
  return group;
}",74,,1354,2,,void
206087,BLOCK,-1,,"{
    group = std::make_shared<SiblingGroup>(name);
    groups_[name] = group;
  }",50,,1358,2,,void
206103,BLOCK,-1,,"{
    group = i->second.lock();
  }",10,,1361,1,,void
206118,BLOCK,-1,,"{
  Mutex::ScopedLock lock(SiblingGroup::groups_mutex_);
  auto i = groups_.find(name);
  if (i != groups_.end() && i->second.expired())
    groups_.erase(name);
}",63,,1367,2,,void
206146,BLOCK,-1,,<empty>,5,,1371,2,,void
206156,BLOCK,-1,,{ },19,,1375,2,,void
206160,BLOCK,-1,,"{
  // If this is a named group, check to see if we can remove the group
  if (!name_.empty())
    CheckSiblingGroup(name_);
}",31,,1377,1,,void
206167,BLOCK,-1,,<empty>,5,,1380,2,,void
206175,BLOCK,-1,,"{

  RwLock::ScopedReadLock lock(group_mutex_);

  // The source MessagePortData is not part of this group.
  if (ports_.find(source) == ports_.end()) {
    if (error != nullptr)
      *error = ""Source MessagePort is not entangled with this group."";
    return Nothing<bool>();
  }

  // There are no destination ports.
  if (size() <= 1)
    return Just(false);

  // Transferables cannot be used when there is more
  // than a single destination.
  if (size() > 2 && message->has_transferables()) {
    if (error != nullptr)
      *error = ""Transferables cannot be used with multiple destinations."";
    return Nothing<bool>();
  }

  for (MessagePortData* port : ports_) {
    if (port == source)
      continue;
    // This loop should only be entered if there's only a single destination
    for (const auto& transferable : message->transferables()) {
      if (port == transferable.get()) {
        if (error != nullptr) {
          *error = ""The target port was posted to itself, and the ""
...",25,,1386,4,,void
206190,BLOCK,-1,,"{
    if (error != nullptr)
      *error = ""Source MessagePort is not entangled with this group."";
    return Nothing<bool>();
  }",44,,1391,2,,void
206195,BLOCK,-1,,<empty>,7,,1393,2,,void
206206,BLOCK,-1,,<empty>,5,,1399,2,,void
206219,BLOCK,-1,,"{
    if (error != nullptr)
      *error = ""Transferables cannot be used with multiple destinations."";
    return Nothing<bool>();
  }",51,,1403,2,,void
206224,BLOCK,-1,,<empty>,7,,1405,2,,void
206234,BLOCK,-1,,"{
    if (port == source)
      continue;
    // This loop should only be entered if there's only a single destination
    for (const auto& transferable : message->transferables()) {
      if (port == transferable.get()) {
        if (error != nullptr) {
          *error = ""The target port was posted to itself, and the ""
                   ""communication channel was lost"";
        }
        return Just(true);
      }
    }
    port->AddToIncomingQueue(message);
  }",40,,1409,3,,void
206239,BLOCK,-1,,<empty>,7,,1411,2,,void
206247,BLOCK,-1,,"{
      if (port == transferable.get()) {
        if (error != nullptr) {
          *error = ""The target port was posted to itself, and the ""
                   ""communication channel was lost"";
        }
        return Just(true);
      }
    }",63,,1413,3,,void
206255,BLOCK,-1,,"{
        if (error != nullptr) {
          *error = ""The target port was posted to itself, and the ""
                   ""communication channel was lost"";
        }
        return Just(true);
      }",39,,1414,2,,void
206260,BLOCK,-1,,"{
          *error = ""The target port was posted to itself, and the ""
                   ""communication channel was lost"";
        }",31,,1415,2,,void
206280,BLOCK,-1,,"{
  Entangle({ port });
}",52,,1428,2,,void
206288,BLOCK,-1,,"{
  RwLock::ScopedWriteLock lock(group_mutex_);
  for (MessagePortData* data : ports) {
    ports_.insert(data);
    CHECK(!data->group_);
    data->group_ = shared_from_this();
  }
}",76,,1432,2,,void
206295,BLOCK,-1,,"{
    ports_.insert(data);
    CHECK(!data->group_);
    data->group_ = shared_from_this();
  }",39,,1434,3,,void
206315,BLOCK,-1,,"{
  auto self = shared_from_this();  // Keep alive until end of function.
  RwLock::ScopedWriteLock lock(group_mutex_);
  ports_.erase(data);
  data->group_.reset();

  data->AddToIncomingQueue(std::make_shared<Message>());
  // If this is an anonymous group and there's another port, close it.
  if (size() == 1 && name_.empty())
    (*(ports_.begin()))->AddToIncomingQueue(std::make_shared<Message>());
}",55,,1441,2,,void
206351,BLOCK,-1,,<empty>,5,,1450,2,,void
206371,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  env->set_messaging_deserialize_create_object(args[0].As<Function>());
}",46,,1459,2,,void
206401,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  if (!args.IsConstructCall()) {
    THROW_ERR_CONSTRUCT_CALL_REQUIRED(env);
    return;
  }

  Local<Context> context = args.This()->GetCreationContext().ToLocalChecked();
  Context::Scope context_scope(context);

  MessagePort* port1 = MessagePort::New(env, context);
  if (port1 == nullptr) return;
  MessagePort* port2 = MessagePort::New(env, context);
  if (port2 == nullptr) {
    port1->Close();
    return;
  }

  MessagePort::Entangle(port1, port2);

  args.This()->Set(context, env->port1_string(), port1->object())
      .Check();
  args.This()->Set(context, env->port2_string(), port2->object())
      .Check();
}",69,,1465,2,,void
206416,BLOCK,-1,,"{
    THROW_ERR_CONSTRUCT_CALL_REQUIRED(env);
    return;
  }",32,,1467,2,,void
206452,BLOCK,-1,,<empty>,25,,1476,2,,void
206467,BLOCK,-1,,"{
    port1->Close();
    return;
  }",25,,1478,2,,void
206521,BLOCK,-1,,"{
  CHECK(args[0]->IsString());
  Environment* env = Environment::GetCurrent(args);
  Context::Scope context_scope(env->context());
  Utf8Value name(env->isolate(), args[0]);
  MessagePort* port =
      MessagePort::New(env, env->context(), {}, SiblingGroup::Get(*name));
  if (port != nullptr) {
    args.GetReturnValue().Set(port->object());
  }
}",71,,1491,2,,void
206575,BLOCK,-1,,"{
    args.GetReturnValue().Set(port->object());
  }",24,,1498,2,,void
206594,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  {
    SetConstructorFunction(context,
                           target,
                           ""MessageChannel"",
                           NewFunctionTemplate(isolate, MessageChannel));
  }

  {
    Local<FunctionTemplate> t =
        NewFunctionTemplate(isolate, JSTransferable::New);
    t->InstanceTemplate()->SetInternalFieldCount(
        JSTransferable::kInternalFieldCount);
    t->SetClassName(OneByteString(isolate, ""JSTransferable""));
    SetConstructorFunction(
        context, target, ""JSTransferable"", t, SetConstructorFunctionFlag::NONE);
  }

  SetConstructorFunction(context,
                         target,
                         env->message_port_constructor_string(),
                         GetMessagePortConstructorTemplate(env),
                         SetConstructorFunctionFlag::NONE);

  // These are not methods on the MessagePort prototype, because
  // the bro...",39,,1506,5,,void
206610,BLOCK,5,,"{
    SetConstructorFunction(context,
                           target,
                           ""MessageChannel"",
                           NewFunctionTemplate(isolate, MessageChannel));
  }",3,,1510,5,,void
206618,BLOCK,6,,"{
    Local<FunctionTemplate> t =
        NewFunctionTemplate(isolate, JSTransferable::New);
    t->InstanceTemplate()->SetInternalFieldCount(
        JSTransferable::kInternalFieldCount);
    t->SetClassName(OneByteString(isolate, ""JSTransferable""));
    SetConstructorFunction(
        context, target, ""JSTransferable"", t, SetConstructorFunctionFlag::NONE);
  }",3,,1517,6,,void
206712,BLOCK,15,,"{
    Local<Function> domexception = GetDOMException(context).ToLocalChecked();
    target
        ->Set(context,
              FIXED_ONE_BYTE_STRING(env->isolate(), ""DOMException""),
              domexception)
        .Check();
  }",3,,1548,15,,void
206743,BLOCK,-1,,"{
  registry->Register(MessageChannel);
  registry->Register(BroadcastChannel);
  registry->Register(JSTransferable::New);
  registry->Register(MessagePort::New);
  registry->Register(MessagePort::PostMessage);
  registry->Register(MessagePort::Start);
  registry->Register(MessagePort::Stop);
  registry->Register(MessagePort::CheckType);
  registry->Register(MessagePort::Drain);
  registry->Register(MessagePort::ReceiveMessage);
  registry->Register(MessagePort::MoveToContext);
  registry->Register(SetDeserializerCreateObjectFunction);
}",77,,1558,2,,void
206843,BLOCK,-1,,<empty>,1,,1,1,,ANY
206898,BLOCK,-1,,<empty>,1,,1,1,,ANY
206903,BLOCK,-1,,"{
  node = NODE_VERSION_STRING;
  v8 = v8::V8::GetVersion();
  uv = uv_version_string();
  zlib = ZLIB_VERSION;
  ares = ARES_VERSION_STR;
  modules = NODE_STRINGIFY(NODE_MODULE_VERSION);
  nghttp2 = NGHTTP2_VERSION;
  napi = NODE_STRINGIFY(NAPI_VERSION);
  llhttp =
      NODE_STRINGIFY(LLHTTP_VERSION_MAJOR)
      "".""
      NODE_STRINGIFY(LLHTTP_VERSION_MINOR)
      "".""
      NODE_STRINGIFY(LLHTTP_VERSION_PATCH);

  brotli =
    std::to_string(BrotliEncoderVersion() >> 24) +
    ""."" +
    std::to_string((BrotliEncoderVersion() & 0xFFF000) >> 12) +
    ""."" +
    std::to_string(BrotliEncoderVersion() & 0xFFF);
#ifndef NODE_SHARED_BUILTIN_UNDICI_UNDICI_PATH
  undici = UNDICI_VERSION;
#endif

  acorn = ACORN_VERSION;
  cjs_module_lexer = CJS_MODULE_LEXER_VERSION;
  base64 = BASE64_VERSION;
  uvwasi = UVWASI_VERSION_STRING;

#if HAVE_OPENSSL
  openssl = GetOpenSSLVersion();
#endif

#ifdef NODE_HAVE_I18N_SUPPORT
  icu = U_ICU_VERSION;
  unicode = U_UNICODE_VERSION;
#endif  // NODE_HAVE_I1...",32,,77,1,,void
206907,BLOCK,1,,<empty>,,,,1,,void
206929,BLOCK,1,,<empty>,,,,1,,void
206937,BLOCK,1,,<empty>,,,,1,,void
206942,BLOCK,1,,<empty>,,,,1,,void
206978,BLOCK,1,,<empty>,,,,1,,void
206983,BLOCK,1,,<empty>,,,,1,,void
206988,BLOCK,1,,<empty>,,,,1,,void
206993,BLOCK,1,,<empty>,,,,1,,void
207007,BLOCK,-1,,"{
#if NODE_VERSION_IS_LTS
  lts = NODE_VERSION_LTS_CODENAME;
#endif  // NODE_VERSION_IS_LTS

#ifdef NODE_HAS_RELEASE_URLS
#define NODE_RELEASE_URLPFX NODE_RELEASE_URLBASE ""v"" NODE_VERSION_STRING ""/""
#define NODE_RELEASE_URLFPFX NODE_RELEASE_URLPFX ""node-v"" NODE_VERSION_STRING

  source_url = NODE_RELEASE_URLFPFX "".tar.gz"";
  headers_url = NODE_RELEASE_URLFPFX ""-headers.tar.gz"";
#ifdef _WIN32
  lib_url = strcmp(NODE_ARCH, ""ia32"") ? NODE_RELEASE_URLPFX ""win-"" NODE_ARCH
                                                           ""/node.lib""
                                     : NODE_RELEASE_URLPFX ""win-x86/node.lib"";
#endif  // _WIN32

#endif  // NODE_HAS_RELEASE_URLS
}",51,,126,1,,void
207011,BLOCK,-1,,<empty>,65,,146,1,,void
207026,BLOCK,-1,,<empty>,1,,1,1,,ANY
207039,BLOCK,-1,,<empty>,1,,1,1,,ANY
207048,BLOCK,-1,,<empty>,1,,1,1,,ANY
207052,BLOCK,-1,,"{
    refs_ = 0;
  }",16,,33,1,,void
207059,BLOCK,-1,,"{
    if (persistent().IsEmpty())
      return;
    persistent().ClearWeak();
    persistent().Reset();
  }",25,,38,1,,void
207065,BLOCK,-1,,<empty>,7,,40,2,,void
207079,BLOCK,-1,,"{
    assert(!handle.IsEmpty());
    assert(handle->InternalFieldCount() > 0);
    // Cast to ObjectWrap before casting to T.  A direct cast from void
    // to T won't work right when T has more than one base class.
    void* ptr = handle->GetAlignedPointerFromInternalField(0);
    ObjectWrap* wrap = static_cast<ObjectWrap*>(ptr);
    return static_cast<T*>(wrap);
  }",57,,47,2,,void
207114,BLOCK,-1,,"{
    return handle(v8::Isolate::GetCurrent());
  }",41,,58,1,,void
207127,BLOCK,-1,,"{
    return v8::Local<v8::Object>::New(isolate, persistent());
  }",61,,63,2,,void
207146,BLOCK,-1,,"{
    return handle_;
  }",51,,69,1,,void
207153,BLOCK,-1,,"{
    assert(persistent().IsEmpty());
    assert(handle->InternalFieldCount() > 0);
    handle->SetAlignedPointerInInternalField(0, this);
    persistent().Reset(v8::Isolate::GetCurrent(), handle);
    MakeWeak();
  }",50,,75,2,,void
207187,BLOCK,-1,,"{
    persistent().SetWeak(this, WeakCallback, v8::WeakCallbackType::kParameter);
  }",26,,84,1,,void
207202,BLOCK,-1,,"{
    assert(!persistent().IsEmpty());
    persistent().ClearWeak();
    refs_++;
  }",22,,92,1,,void
207218,BLOCK,-1,,"{
    assert(!persistent().IsEmpty());
    assert(!persistent().IsWeak());
    assert(refs_ > 0);
    if (--refs_ == 0)
      MakeWeak();
  }",24,,107,1,,void
207240,BLOCK,-1,,<empty>,7,,112,2,,void
207247,BLOCK,-1,,"{
    ObjectWrap* wrap = data.GetParameter();
    assert(wrap->refs_ == 0);
    wrap->handle_.Reset();
    delete wrap;
  }",53,,119,2,,void
207282,BLOCK,-1,,<empty>,1,,1,1,,ANY
207285,BLOCK,-1,,"{
    per_process::cli_options->per_isolate->per_env = original_per_env;
    per_process::cli_options->per_isolate = original_per_isolate;
  }",44,,1098,1,,void
207310,BLOCK,-1,,"{
    std::string text;
    return credentials::SafeGetenv(name, &text) ? text : """";
  }",54,,1281,2,,void
207354,BLOCK,-1,,<empty>,1,,1,1,,ANY
207367,BLOCK,-1,,"{
#if !NODE_USE_V8_PLATFORM && !HAVE_INSPECTOR
  if (inspector_enabled) {
    errors->push_back(""Inspector is not available when Node is compiled ""
                      ""--without-v8-platform and --without-inspector."");
  }
#endif

  if (deprecated_debug) {
    errors->push_back(""[DEP0062]: `node --debug` and `node --debug-brk` ""
                      ""are invalid. Please use `node --inspect` and ""
                      ""`node --inspect-brk` instead."");
  }

  std::vector<std::string> destinations =
      SplitString(inspect_publish_uid_string, ',');
  inspect_publish_uid.console = false;
  inspect_publish_uid.http = false;
  for (const std::string& destination : destinations) {
    if (destination == ""stderr"") {
      inspect_publish_uid.console = true;
    } else if (destination == ""http"") {
      inspect_publish_uid.http = true;
    } else {
      errors->push_back(""--inspect-publish-uid destination can be ""
                        ""stderr or http"");
    }
  }
}",65,,39,3,,void
207370,BLOCK,-1,,"{
    errors->push_back(""Inspector is not available when Node is compiled ""
                      ""--without-v8-platform and --without-inspector."");
  }",26,,41,2,,void
207378,BLOCK,-1,,"{
    errors->push_back(""[DEP0062]: `node --debug` and `node --debug-brk` ""
                      ""are invalid. Please use `node --inspect` and ""
                      ""`node --inspect-brk` instead."");
  }",25,,47,2,,void
207410,BLOCK,-1,,"{
    if (destination == ""stderr"") {
      inspect_publish_uid.console = true;
    } else if (destination == ""http"") {
      inspect_publish_uid.http = true;
    } else {
      errors->push_back(""--inspect-publish-uid destination can be ""
                        ""stderr or http"");
    }
  }",55,,57,3,,void
207415,BLOCK,-1,,"{
      inspect_publish_uid.console = true;
    }",34,,58,2,,void
207422,BLOCK,-1,,<empty>,12,,60,1,,void
207427,BLOCK,-1,,"{
      inspect_publish_uid.http = true;
    }",39,,60,2,,void
207434,BLOCK,-1,,"{
      errors->push_back(""--inspect-publish-uid destination can be ""
                        ""stderr or http"");
    }",12,,62,1,,void
207445,BLOCK,-1,,"{
#if HAVE_OPENSSL
  if (use_openssl_ca && use_bundled_ca) {
    errors->push_back(""either --use-openssl-ca or --use-bundled-ca can be ""
                      ""used, not both"");
  }

  // Any value less than 2 disables use of the secure heap.
  if (secure_heap >= 2) {
    if ((secure_heap & (secure_heap - 1)) != 0)
      errors->push_back(""--secure-heap must be a power of 2"");
    secure_heap_min =
        std::min({
            secure_heap,
            secure_heap_min,
            static_cast<int64_t>(std::numeric_limits<int>::max())});
    secure_heap_min = std::max(static_cast<int64_t>(2), secure_heap_min);
    if ((secure_heap_min & (secure_heap_min - 1)) != 0)
      errors->push_back(""--secure-heap-min must be a power of 2"");
  }
#endif  // HAVE_OPENSSL

  if (use_largepages != ""off"" &&
      use_largepages != ""on"" &&
      use_largepages != ""silent"") {
    errors->push_back(""invalid value for --use-largepages"");
  }
  per_isolate->CheckOptions(errors, argv);
}",70,,70,3,,void
207458,BLOCK,-1,,"{
    errors->push_back(""invalid value for --use-largepages"");
  }",35,,94,2,,void
207475,BLOCK,-1,,"{
  per_env->CheckOptions(errors, argv);
}",70,,101,3,,void
207487,BLOCK,-1,,"{
  if (has_policy_integrity_string && experimental_policy.empty()) {
    errors->push_back(""--policy-integrity requires ""
                      ""--experimental-policy be enabled"");
  }
  if (has_policy_integrity_string && experimental_policy_integrity.empty()) {
    errors->push_back(""--policy-integrity cannot be empty"");
  }

  if (!module_type.empty()) {
    if (module_type != ""commonjs"" && module_type != ""module"") {
      errors->push_back(""--input-type must be \""module\"" or \""commonjs\"""");
    }
  }

  if (syntax_check_only && has_eval_string) {
    errors->push_back(""either --check or --eval can be used, not both"");
  }

  if (!unhandled_rejections.empty() &&
      unhandled_rejections != ""warn-with-error-code"" &&
      unhandled_rejections != ""throw"" &&
      unhandled_rejections != ""strict"" &&
      unhandled_rejections != ""warn"" &&
      unhandled_rejections != ""none"") {
    errors->push_back(""invalid value for --unhandled-rejections"");
  }

  if (tls_min_v1_3 && tls_max_v1...",71,,106,3,,void
207495,BLOCK,-1,,"{
    errors->push_back(""--policy-integrity requires ""
                      ""--experimental-policy be enabled"");
  }",67,,107,2,,void
207508,BLOCK,-1,,"{
    errors->push_back(""--policy-integrity cannot be empty"");
  }",77,,111,2,,void
207520,BLOCK,-1,,"{
    if (module_type != ""commonjs"" && module_type != ""module"") {
      errors->push_back(""--input-type must be \""module\"" or \""commonjs\"""");
    }
  }",29,,115,2,,void
207529,BLOCK,-1,,"{
      errors->push_back(""--input-type must be \""module\"" or \""commonjs\"""");
    }",63,,116,2,,void
207536,BLOCK,-1,,<empty>,7,,121,1,,void
207538,BLOCK,-1,,"{
    errors->push_back(""either --check or --eval can be used, not both"");
  }",45,,121,2,,void
207570,BLOCK,-1,,"{
    errors->push_back(""invalid value for --unhandled-rejections"");
  }",39,,130,2,,void
207577,BLOCK,-1,,<empty>,7,,134,1,,void
207579,BLOCK,-1,,"{
    errors->push_back(""either --tls-min-v1.3 or --tls-max-v1.2 can be ""
                      ""used, not both"");
  }",37,,134,2,,void
207589,BLOCK,-1,,"{
    errors->push_back(""--heapsnapshot-near-heap-limit must not be negative"");
  }",42,,139,2,,void
207597,BLOCK,-1,,"{
    if (syntax_check_only) {
      errors->push_back(""either --test or --check can be used, not both"");
    }

    if (has_eval_string) {
      errors->push_back(""either --test or --eval can be used, not both"");
    }

    if (force_repl) {
      errors->push_back(""either --test or --interactive can be used, not both"");
    }

    if (watch_mode_paths.size() > 0) {
      errors->push_back(
          ""--watch-path cannot be used in combination with --test"");
    }

#ifndef ALLOW_ATTACHING_DEBUGGER_IN_TEST_RUNNER
    debug_options_.allow_attaching_debugger = false;
#endif
  }",20,,143,2,,void
207600,BLOCK,-1,,"{
      errors->push_back(""either --test or --check can be used, not both"");
    }",28,,144,2,,void
207608,BLOCK,-1,,"{
      errors->push_back(""either --test or --eval can be used, not both"");
    }",26,,148,2,,void
207616,BLOCK,-1,,"{
      errors->push_back(""either --test or --interactive can be used, not both"");
    }",21,,152,2,,void
207629,BLOCK,-1,,"{
      errors->push_back(
          ""--watch-path cannot be used in combination with --test"");
    }",38,,156,2,,void
207642,BLOCK,-1,,"{
    if (syntax_check_only) {
      errors->push_back(""either --watch or --check can be used, not both"");
    } else if (has_eval_string) {
      errors->push_back(""either --watch or --eval can be used, not both"");
    } else if (force_repl) {
      errors->push_back(""either --watch or --interactive ""
                        ""can be used, not both"");
    } else if (argv->size() < 1 || (*argv)[1].empty()) {
      errors->push_back(""--watch requires specifying a file"");
    }

#ifndef ALLOW_ATTACHING_DEBUGGER_IN_WATCH_MODE
    debug_options_.allow_attaching_debugger = false;
#endif
  }",19,,166,2,,void
207645,BLOCK,-1,,"{
      errors->push_back(""either --watch or --check can be used, not both"");
    }",28,,167,2,,void
207652,BLOCK,-1,,<empty>,12,,169,1,,void
207655,BLOCK,-1,,"{
      errors->push_back(""either --watch or --eval can be used, not both"");
    }",33,,169,2,,void
207662,BLOCK,-1,,<empty>,12,,171,1,,void
207665,BLOCK,-1,,"{
      errors->push_back(""either --watch or --interactive ""
                        ""can be used, not both"");
    }",28,,171,2,,void
207672,BLOCK,-1,,<empty>,12,,174,1,,void
207688,BLOCK,-1,,"{
      errors->push_back(""--watch requires specifying a file"");
    }",56,,174,2,,void
207704,BLOCK,-1,,<empty>,,,,1,,<empty>
207709,BLOCK,-1,,<empty>,,,,1,,<empty>
207714,BLOCK,-1,,"{
    Insert(dop, &EnvironmentOptions::get_debug_options);
  }",34,,235,2,,void
207725,BLOCK,-1,,<empty>,,,,1,,<empty>
207730,BLOCK,-1,,<empty>,,,,2,,<empty>
207735,BLOCK,-1,,<empty>,,,,1,,<empty>
207740,BLOCK,-1,,<empty>,,,,2,,<empty>
207764,BLOCK,-1,,"{
  _piop_instance.Parse(
    args, exec_args, v8_args, options, required_env_settings, errors);
}",75,,277,7,,void
207784,BLOCK,-1,,"{
  _ppop_instance.Parse(
    args, exec_args, v8_args, options, required_env_settings, errors);
}",75,,287,7,,void
207798,BLOCK,-1,,"{
#ifndef DISABLE_SINGLE_EXECUTABLE_APPLICATION
  if (sea::IsSingleExecutable()) return;
#endif

  AddOption(""--inspect-port"",
            ""set host:port for inspector"",
            &DebugOptions::host_port,
            kAllowedInEnvvar);
  AddAlias(""--debug-port"", ""--inspect-port"");

  AddOption(""--inspect"",
            ""activate inspector on host:port (default: 127.0.0.1:9229)"",
            &DebugOptions::inspector_enabled,
            kAllowedInEnvvar);
  AddAlias(""--inspect="", { ""--inspect-port"", ""--inspect"" });

  AddOption(""--debug"", """", &DebugOptions::deprecated_debug);
  AddAlias(""--debug="", ""--debug"");
  AddOption(""--debug-brk"", """", &DebugOptions::deprecated_debug);
  AddAlias(""--debug-brk="", ""--debug-brk"");

  AddOption(""--inspect-brk"",
            ""activate inspector on host:port and break at start of user script"",
            &DebugOptions::break_first_line,
            kAllowedInEnvvar);
  Implies(""--inspect-brk"", ""--inspect"");
  AddAlias(""--inspect-brk="", { ""--inspect-...",42,,296,1,,void
207804,BLOCK,-1,,<empty>,34,,298,2,,void
207892,BLOCK,-1,,"{
  AddOption(""--conditions"",
            ""additional user conditions for conditional exports and imports"",
            &EnvironmentOptions::conditions,
            kAllowedInEnvvar);
  AddAlias(""-C"", ""--conditions"");
  AddOption(""--diagnostic-dir"",
            ""set dir for all output files""
            "" (default: current working directory)"",
            &EnvironmentOptions::diagnostic_dir,
            kAllowedInEnvvar);
  AddOption(""--dns-result-order"",
            ""set default value of verbatim in dns.lookup. Options are ""
            ""'ipv4first' (IPv4 addresses are placed before IPv6 addresses) ""
            ""'verbatim' (addresses are in the order the DNS resolver ""
            ""returned)"",
            &EnvironmentOptions::dns_result_order,
            kAllowedInEnvvar);
  AddOption(""--network-family-autoselection"",
            ""Disable network address family autodetection algorithm"",
            &EnvironmentOptions::network_family_autoselection,
            kAllowedInEnvvar,
 ...",54,,336,1,,void
208614,BLOCK,-1,,"{
  AddOption(""--track-heap-objects"",
            ""track heap object allocations for heap snapshots"",
            &PerIsolateOptions::track_heap_objects,
            kAllowedInEnvvar);

  // Explicitly add some V8 flags to mark them as allowed in NODE_OPTIONS.
  AddOption(""--abort-on-uncaught-exception"",
            ""aborting instead of exiting causes a core file to be generated ""
            ""for analysis"",
            V8Option{},
            kAllowedInEnvvar);
  AddOption(""--interpreted-frames-native-stack"",
            ""help system profilers to translate JavaScript interpreted frames"",
            V8Option{},
            kAllowedInEnvvar);
  AddOption(""--max-old-space-size"", """", V8Option{}, kAllowedInEnvvar);
  AddOption(""--max-semi-space-size"", """", V8Option{}, kAllowedInEnvvar);
  AddOption(""--perf-basic-prof"", """", V8Option{}, kAllowedInEnvvar);
  AddOption(
      ""--perf-basic-prof-only-functions"", """", V8Option{}, kAllowedInEnvvar);
  AddOption(""--perf-prof"", """", V8Option{}, kA...",40,,736,2,,void
208774,BLOCK,-1,,"{
  AddOption(""--title"",
            ""the process title to use on startup"",
            &PerProcessOptions::title,
            kAllowedInEnvvar);
  AddOption(""--trace-event-categories"",
            ""comma separated list of trace event categories to record"",
            &PerProcessOptions::trace_event_categories,
            kAllowedInEnvvar);
  AddOption(""--trace-event-file-pattern"",
            ""Template string specifying the filepath for the trace-events ""
            ""data, it supports ${rotation} and ${pid}."",
            &PerProcessOptions::trace_event_file_pattern,
            kAllowedInEnvvar);
  AddAlias(""--trace-events-enabled"", {
    ""--trace-event-categories"", ""v8,node,node.async_hooks"" });
  AddOption(""--v8-pool-size"",
            ""set V8's thread pool size"",
            &PerProcessOptions::v8_thread_pool_size,
            kAllowedInEnvvar);
  AddOption(""--zero-fill-buffers"",
            ""automatically zero-fill all newly allocated Buffer and ""
            ""SlowBuffer in...",39,,811,2,,void
208976,BLOCK,-1,,"{
  if (!host.empty() && host.front() == '[' && host.back() == ']')
    return host.substr(1, host.size() - 2);
  else
    return host;
}",60,,994,2,,void
208997,BLOCK,-1,,<empty>,5,,996,2,,void
209011,BLOCK,-1,,<empty>,5,,998,1,,void
209019,BLOCK,-1,,"{
  char* endptr;
  errno = 0;
  const unsigned long result =                 // NOLINT(runtime/int)
    strtoul(port.c_str(), &endptr, 10);
  if (errno != 0 || *endptr != '\0'||
      (result != 0 && result < 1024) || result > 65535) {
    errors->push_back("" must be 0 or in range 1024 to 65535."");
  }
  return static_cast<int>(result);
}",67,,1002,3,,void
209056,BLOCK,-1,,"{
    errors->push_back("" must be 0 or in range 1024 to 65535."");
  }",57,,1008,2,,void
209071,BLOCK,-1,,"{
  // remove_brackets only works if no port is specified
  // so if it has an effect only an IPv6 address was specified.
  std::string host = RemoveBrackets(arg);
  if (host.length() < arg.length())
    return HostPort{host, DebugOptions::kDefaultInspectorPort};

  size_t colon = arg.rfind(':');
  if (colon == std::string::npos) {
    // Either a port number or a host name.  Assume that
    // if it's not all decimal digits, it's a host name.
    for (char c : arg) {
      if (c < '0' || c > '9') {
        return HostPort{arg, DebugOptions::kDefaultInspectorPort};
      }
    }
    return HostPort { """", ParseAndValidatePort(arg, errors) };
  }
  // Host and port found:
  return HostPort { RemoveBrackets(arg.substr(0, colon)),
                    ParseAndValidatePort(arg.substr(colon + 1), errors) };
}",57,,1015,3,,void
209087,BLOCK,-1,,<empty>,5,,1020,2,,void
209111,BLOCK,-1,,"{
    // Either a port number or a host name.  Assume that
    // if it's not all decimal digits, it's a host name.
    for (char c : arg) {
      if (c < '0' || c > '9') {
        return HostPort{arg, DebugOptions::kDefaultInspectorPort};
      }
    }
    return HostPort { """", ParseAndValidatePort(arg, errors) };
  }",35,,1023,2,,void
209115,BLOCK,-1,,"{
      if (c < '0' || c > '9') {
        return HostPort{arg, DebugOptions::kDefaultInspectorPort};
      }
    }",24,,1026,3,,void
209124,BLOCK,-1,,"{
        return HostPort{arg, DebugOptions::kDefaultInspectorPort};
      }",31,,1027,2,,void
209161,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  const auto& parser = _ppop_instance;

  std::ostringstream out;

  out << ""_node_complete() {\n""
         ""  local cur_word options\n""
         ""  cur_word=\""${COMP_WORDS[COMP_CWORD]}\""\n""
         ""  if [[ \""${cur_word}\"" == -* ]] ; then\n""
         ""    COMPREPLY=( $(compgen -W '"";

  for (const auto& item : parser.options_) {
    if (item.first[0] != '[') {
      out << item.first << "" "";
    }
  }
  for (const auto& item : parser.aliases_) {
    if (item.first[0] != '[') {
      out << item.first << "" "";
    }
  }
  if (parser.aliases_.size() > 0) {
    out.seekp(-1, out.cur);  // Strip the trailing space
  }

  out << ""' -- \""${cur_word}\"") )\n""
         ""    return 0\n""
         ""  else\n""
         ""    COMPREPLY=( $(compgen -f \""${cur_word}\"") )\n""
         ""    return 0\n""
         ""  fi\n""
         ""}\n""
         ""complete -o filenames -o nospace -o bashdefault ""
         ""-F _node_complete node node_g"";
  return...",33,,1038,1,,void
209180,BLOCK,-1,,"{
    if (item.first[0] != '[') {
      out << item.first << "" "";
    }
  }",44,,1050,3,,void
209189,BLOCK,-1,,"{
      out << item.first << "" "";
    }",31,,1051,2,,void
209202,BLOCK,-1,,"{
    if (item.first[0] != '[') {
      out << item.first << "" "";
    }
  }",44,,1055,3,,void
209211,BLOCK,-1,,"{
      out << item.first << "" "";
    }",31,,1056,2,,void
209228,BLOCK,-1,,"{
    out.seekp(-1, out.cur);  // Strip the trailing space
  }",35,,1060,2,,void
209250,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Environment* env = Environment::GetCurrent(args);
  if (!env->has_run_bootstrapping_code()) {
    // No code because this is an assertion.
    return env->ThrowError(
        ""Should not query options before bootstrapping is done"");
  }
  env->set_has_serialized_options(true);

  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();

  // Temporarily act as if the current Environment's/IsolateData's options were
  // the default options, i.e. like they are the ones we'd access for global
  // options parsing, so that all options are available from the main parser.
  auto original_per_isolate = per_process::cli_options->per_isolate;
  per_process::cli_options->per_isolate = env->isolate_data()->options();
  auto original_per_env = per_process::cli_options->per_isolate->per_env;
  per_process::cli_options->per_isolate->per_env = env->options();
  auto on_scope_leave = OnScopeLeave([&]() {
    per_pro...",61,,1078,2,,void
209270,BLOCK,-1,,"{
    // No code because this is an assertion.
    return env->ThrowError(
        ""Should not query options before bootstrapping is done"");
  }",43,,1081,2,,void
209369,BLOCK,-1,,"{
    return;
  }",25,,1106,2,,void
209376,BLOCK,-1,,"{
    Local<Value> value;
    const auto& option_info = item.second;
    auto field = option_info.field;
    PerProcessOptions* opts = per_process::cli_options.get();
    switch (option_info.type) {
      case kNoOp:
      case kV8Option:
        // Special case for --abort-on-uncaught-exception which is also
        // respected by Node.js internals
        if (item.first == ""--abort-on-uncaught-exception"") {
          value = Boolean::New(
            isolate, original_per_env->abort_on_uncaught_exception);
        } else {
          value = Undefined(isolate);
        }
        break;
      case kBoolean:
        value = Boolean::New(isolate,
                             *_ppop_instance.Lookup<bool>(field, opts));
        break;
      case kInteger:
        value = Number::New(
            isolate,
            static_cast<double>(*_ppop_instance.Lookup<int64_t>(field, opts)));
        break;
      case kUInteger:
        value = Number::New(
            isolate,
            stati...",52,,1110,3,,void
209407,BLOCK,-1,,"{
      case kNoOp:
      case kV8Option:
        // Special case for --abort-on-uncaught-exception which is also
        // respected by Node.js internals
        if (item.first == ""--abort-on-uncaught-exception"") {
          value = Boolean::New(
            isolate, original_per_env->abort_on_uncaught_exception);
        } else {
          value = Undefined(isolate);
        }
        break;
      case kBoolean:
        value = Boolean::New(isolate,
                             *_ppop_instance.Lookup<bool>(field, opts));
        break;
      case kInteger:
        value = Number::New(
            isolate,
            static_cast<double>(*_ppop_instance.Lookup<int64_t>(field, opts)));
        break;
      case kUInteger:
        value = Number::New(
            isolate,
            static_cast<double>(*_ppop_instance.Lookup<uint64_t>(field, opts)));
        break;
      case kString:
        if (!ToV8Value(context,
                       *_ppop_instance.Lookup<std::string>(field, ...",31,,1115,2,,void
209418,BLOCK,-1,,"{
          value = Boolean::New(
            isolate, original_per_env->abort_on_uncaught_exception);
        }",60,,1120,2,,void
209430,BLOCK,-1,,"{
          value = Undefined(isolate);
        }",16,,1123,1,,void
209523,BLOCK,-1,,"{
          return;
        }",36,,1144,2,,void
209548,BLOCK,-1,,"{
          return;
        }",36,,1151,2,,void
209553,BLOCK,29,,"{
        const HostPort& host_port =
          *_ppop_instance.Lookup<HostPort>(field, opts);
        Local<Object> obj = Object::New(isolate);
        Local<Value> host;
        if (!ToV8Value(context, host_port.host()).ToLocal(&host) ||
            obj->Set(context, env->host_string(), host).IsNothing() ||
            obj->Set(context,
                     env->port_string(),
                     Integer::New(isolate, host_port.port()))
                .IsNothing()) {
          return;
        }
        value = obj;
        break;
      }",23,,1155,29,,void
209633,BLOCK,-1,,"{
          return;
        }",31,,1165,2,,void
209803,BLOCK,-1,,"{
      return;
    }",54,,1196,2,,void
209822,BLOCK,-1,,<empty>,71,,1202,2,,void
209840,BLOCK,-1,,"{
    return;
  }",25,,1206,2,,void
209881,BLOCK,-1,,"{
    return;
  }",70,,1212,2,,void
209895,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  if (!env->has_run_bootstrapping_code()) {
    // No code because this is an assertion.
    return env->ThrowError(
        ""Should not query options before bootstrapping is done"");
  }
  Isolate* isolate = args.GetIsolate();
  Local<Context> context = env->context();
  Local<Object> ret = Object::New(isolate);

  if (ret->Set(context,
           FIXED_ONE_BYTE_STRING(env->isolate(), ""shouldNotRegisterESMLoader""),
           Boolean::New(isolate, env->should_not_register_esm_loader()))
      .IsNothing()) return;

  if (ret->Set(context,
           FIXED_ONE_BYTE_STRING(env->isolate(), ""noGlobalSearchPaths""),
           Boolean::New(isolate, env->no_global_search_paths()))
      .IsNothing()) return;

  args.GetReturnValue().Set(ret);
}",66,,1219,2,,void
209910,BLOCK,-1,,"{
    // No code because this is an assertion.
    return env->ThrowError(
        ""Should not query options before bootstrapping is done"");
  }",43,,1221,2,,void
209969,BLOCK,-1,,<empty>,21,,1233,2,,void
209995,BLOCK,-1,,<empty>,21,,1238,2,,void
210012,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();
  SetMethodNoSideEffect(context, target, ""getCLIOptions"", GetCLIOptions);
  SetMethodNoSideEffect(
      context, target, ""getEmbedderOptions"", GetEmbedderOptions);

  Local<Object> env_settings = Object::New(isolate);
  NODE_DEFINE_CONSTANT(env_settings, kAllowedInEnvvar);
  NODE_DEFINE_CONSTANT(env_settings, kDisallowedInEnvvar);
  target
      ->Set(
          context, FIXED_ONE_BYTE_STRING(isolate, ""envSettings""), env_settings)
      .Check();

  Local<Object> types = Object::New(isolate);
  NODE_DEFINE_CONSTANT(types, kNoOp);
  NODE_DEFINE_CONSTANT(types, kV8Option);
  NODE_DEFINE_CONSTANT(types, kBoolean);
  NODE_DEFINE_CONSTANT(types, kInteger);
  NODE_DEFINE_CONSTANT(types, kUInteger);
  NODE_DEFINE_CONSTANT(types, kString);
  NODE_DEFINE_CONSTANT(types, kHostPort);
  NODE_DEFINE_CONSTANT(types, kStringList);
  target->Set(context, FIXED_ONE_BYTE_STRING(isolate, ""types""), types)
   ...",29,,1246,5,,void
210118,BLOCK,-1,,"{
  registry->Register(GetCLIOptions);
  registry->Register(GetEmbedderOptions);
}",70,,1274,2,,void
210133,BLOCK,-1,,"{
  HandleEnvOptions(env_options, [](const char* name) {
    std::string text;
    return credentials::SafeGetenv(name, &text) ? text : """";
  });
}",72,,1280,2,,void
210142,BLOCK,-1,,"{
  env_options->pending_deprecation =
      opt_getter(""NODE_PENDING_DEPRECATION"") == ""1"";

  env_options->preserve_symlinks = opt_getter(""NODE_PRESERVE_SYMLINKS"") == ""1"";

  env_options->preserve_symlinks_main =
      opt_getter(""NODE_PRESERVE_SYMLINKS_MAIN"") == ""1"";

  if (env_options->redirect_warnings.empty())
    env_options->redirect_warnings = opt_getter(""NODE_REDIRECT_WARNINGS"");
}",75,,1288,3,,void
210174,BLOCK,-1,,<empty>,5,,1298,2,,void
210186,BLOCK,-1,,"{
  std::vector<std::string> env_argv;

  bool is_in_string = false;
  bool will_start_new_arg = true;
  for (std::string::size_type index = 0; index < node_options.size(); ++index) {
    char c = node_options.at(index);

    // Backslashes escape the following character
    if (c == '\\' && is_in_string) {
      if (index + 1 == node_options.size()) {
        errors->push_back(""invalid value for NODE_OPTIONS ""
                          ""(invalid escape)\n"");
        return env_argv;
      } else {
        c = node_options.at(++index);
      }
    } else if (c == ' ' && !is_in_string) {
      will_start_new_arg = true;
      continue;
    } else if (c == '""') {
      is_in_string = !is_in_string;
      continue;
    }

    if (will_start_new_arg) {
      env_argv.emplace_back(std::string(1, c));
      will_start_new_arg = false;
    } else {
      env_argv.back() += c;
    }
  }

  if (is_in_string) {
    errors->push_back(""invalid value for NODE_OPTIONS ""
                      ""(un...",72,,1302,3,,void
210205,BLOCK,-1,,<empty>,3,,1307,1,,void
210218,BLOCK,4,,"{
    char c = node_options.at(index);

    // Backslashes escape the following character
    if (c == '\\' && is_in_string) {
      if (index + 1 == node_options.size()) {
        errors->push_back(""invalid value for NODE_OPTIONS ""
                          ""(invalid escape)\n"");
        return env_argv;
      } else {
        c = node_options.at(++index);
      }
    } else if (c == ' ' && !is_in_string) {
      will_start_new_arg = true;
      continue;
    } else if (c == '""') {
      is_in_string = !is_in_string;
      continue;
    }

    if (will_start_new_arg) {
      env_argv.emplace_back(std::string(1, c));
      will_start_new_arg = false;
    } else {
      env_argv.back() += c;
    }
  }",80,,1307,4,,void
210233,BLOCK,-1,,"{
      if (index + 1 == node_options.size()) {
        errors->push_back(""invalid value for NODE_OPTIONS ""
                          ""(invalid escape)\n"");
        return env_argv;
      } else {
        c = node_options.at(++index);
      }
    }",36,,1311,2,,void
210243,BLOCK,-1,,"{
        errors->push_back(""invalid value for NODE_OPTIONS ""
                          ""(invalid escape)\n"");
        return env_argv;
      }",45,,1312,2,,void
210252,BLOCK,-1,,"{
        c = node_options.at(++index);
      }",14,,1316,1,,void
210262,BLOCK,-1,,<empty>,12,,1319,1,,void
210270,BLOCK,-1,,"{
      will_start_new_arg = true;
      continue;
    }",43,,1319,2,,void
210276,BLOCK,-1,,<empty>,12,,1322,1,,void
210281,BLOCK,-1,,"{
      is_in_string = !is_in_string;
      continue;
    }",26,,1322,2,,void
210289,BLOCK,-1,,"{
      env_argv.emplace_back(std::string(1, c));
      will_start_new_arg = false;
    }",29,,1327,2,,void
210304,BLOCK,-1,,"{
      env_argv.back() += c;
    }",12,,1330,1,,void
210313,BLOCK,-1,,"{
    errors->push_back(""invalid value for NODE_OPTIONS ""
                      ""(unterminated string)\n"");
  }",21,,1335,2,,void
210344,BLOCK,-1,,<empty>,1,,1,1,,ANY
210347,BLOCK,-1,,{ uv_os_free_passwd(&pwd); },41,,299,1,,void
210374,BLOCK,-1,,<empty>,1,,1,1,,ANY
210379,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  char buf[UV_MAXHOSTNAMESIZE];
  size_t size = sizeof(buf);
  int r = uv_os_gethostname(buf, &size);

  if (r != 0) {
    CHECK_GE(args.Length(), 1);
    env->CollectUVExceptionInfo(args[args.Length() - 1], r,
                                ""uv_os_gethostname"");
    return args.GetReturnValue().SetUndefined();
  }

  args.GetReturnValue().Set(
      String::NewFromUtf8(env->isolate(), buf).ToLocalChecked());
}",66,,60,2,,void
210405,BLOCK,-1,,"{
    CHECK_GE(args.Length(), 1);
    env->CollectUVExceptionInfo(args[args.Length() - 1], r,
                                ""uv_os_gethostname"");
    return args.GetReturnValue().SetUndefined();
  }",15,,66,2,,void
210457,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  uv_utsname_t info;
  int err = uv_os_uname(&info);

  if (err != 0) {
    CHECK_GE(args.Length(), 1);
    env->CollectUVExceptionInfo(args[args.Length() - 1], err, ""uv_os_uname"");
    return args.GetReturnValue().SetUndefined();
  }

  // [sysname, version, release, machine]
  Local<Value> osInformation[] = {
      String::NewFromUtf8(env->isolate(), info.sysname).ToLocalChecked(),
      String::NewFromUtf8(env->isolate(), info.version).ToLocalChecked(),
      String::NewFromUtf8(env->isolate(), info.release).ToLocalChecked(),
      String::NewFromUtf8(env->isolate(), info.machine).ToLocalChecked()};

  args.GetReturnValue().Set(Array::New(env->isolate(),
                                       osInformation,
                                       arraysize(osInformation)));
}",71,,77,2,,void
210477,BLOCK,-1,,"{
    CHECK_GE(args.Length(), 1);
    env->CollectUVExceptionInfo(args[args.Length() - 1], err, ""uv_os_uname"");
    return args.GetReturnValue().SetUndefined();
  }",17,,82,2,,void
210588,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  uv_cpu_info_t* cpu_infos;
  int count;

  int err = uv_cpu_info(&cpu_infos, &count);
  if (err)
    return;

  // It's faster to create an array packed with all the data and
  // assemble them into objects in JS than to call Object::Set() repeatedly
  // The array is in the format
  // [model, speed, (5 entries of cpu_times), model2, speed2, ...]
  std::vector<Local<Value>> result;
  result.reserve(count * 7);
  for (int i = 0; i < count; i++) {
    uv_cpu_info_t* ci = cpu_infos + i;
    result.emplace_back(OneByteString(isolate, ci->model));
    result.emplace_back(Number::New(isolate, ci->speed));
    result.emplace_back(
        Number::New(isolate, static_cast<double>(ci->cpu_times.user)));
    result.emplace_back(
        Number::New(isolate, static_cast<double>(ci->cpu_times.nice)));
    result.emplace_back(
        Number::New(isolate, static_cast<double>(ci->cpu_times.sys)));
    re...",65,,100,2,,void
210616,BLOCK,-1,,<empty>,5,,109,2,,void
210635,BLOCK,-1,,<empty>,3,,117,1,,void
210645,BLOCK,4,,"{
    uv_cpu_info_t* ci = cpu_infos + i;
    result.emplace_back(OneByteString(isolate, ci->model));
    result.emplace_back(Number::New(isolate, ci->speed));
    result.emplace_back(
        Number::New(isolate, static_cast<double>(ci->cpu_times.user)));
    result.emplace_back(
        Number::New(isolate, static_cast<double>(ci->cpu_times.nice)));
    result.emplace_back(
        Number::New(isolate, static_cast<double>(ci->cpu_times.sys)));
    result.emplace_back(
        Number::New(isolate, static_cast<double>(ci->cpu_times.idle)));
    result.emplace_back(
        Number::New(isolate, static_cast<double>(ci->cpu_times.irq)));
  }",35,,117,4,,void
210780,BLOCK,-1,,"{
  double amount = static_cast<double>(uv_get_free_memory());
  args.GetReturnValue().Set(amount);
}",68,,138,2,,void
210799,BLOCK,-1,,"{
  double amount = static_cast<double>(uv_get_total_memory());
  args.GetReturnValue().Set(amount);
}",69,,144,2,,void
210818,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  double uptime;
  int err = uv_uptime(&uptime);
  if (err != 0) {
    env->CollectUVExceptionInfo(args[args.Length() - 1], err, ""uv_uptime"");
    return args.GetReturnValue().SetUndefined();
  }

  args.GetReturnValue().Set(uptime);
}",64,,150,2,,void
210838,BLOCK,-1,,"{
    env->CollectUVExceptionInfo(args[args.Length() - 1], err, ""uv_uptime"");
    return args.GetReturnValue().SetUndefined();
  }",17,,154,2,,void
210873,BLOCK,-1,,"{
  CHECK(args[0]->IsFloat64Array());
  Local<Float64Array> array = args[0].As<Float64Array>();
  CHECK_EQ(array->Length(), 3);
  Local<ArrayBuffer> ab = array->Buffer();
  double* loadavg = static_cast<double*>(ab->Data());
  uv_loadavg(loadavg);
}",65,,163,2,,void
210924,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  uv_interface_address_t* interfaces;
  int count, i;
  char ip[INET6_ADDRSTRLEN];
  char netmask[INET6_ADDRSTRLEN];
  std::array<char, 18> mac;
  Local<String> name, family;

  int err = uv_interface_addresses(&interfaces, &count);

  if (err == UV_ENOSYS)
    return args.GetReturnValue().SetUndefined();

  if (err) {
    CHECK_GE(args.Length(), 1);
    env->CollectUVExceptionInfo(args[args.Length() - 1], errno,
                                ""uv_interface_addresses"");
    return args.GetReturnValue().SetUndefined();
  }

  Local<Value> no_scope_id = Integer::New(isolate, -1);
  std::vector<Local<Value>> result;
  result.reserve(count * 7);
  for (i = 0; i < count; i++) {
    const char* const raw_name = interfaces[i].name;

    // Use UTF-8 on both Windows and Unixes (While it may be true that UNIX
    // systems are somewhat encoding-agnostic here, it’s more than reasonable
    // to assum...",76,,173,2,,void
210960,BLOCK,-1,,<empty>,5,,186,2,,void
210971,BLOCK,-1,,"{
    CHECK_GE(args.Length(), 1);
    env->CollectUVExceptionInfo(args[args.Length() - 1], errno,
                                ""uv_interface_addresses"");
    return args.GetReturnValue().SetUndefined();
  }",12,,188,2,,void
211030,BLOCK,-1,,<empty>,3,,198,1,,void
211039,BLOCK,4,,"{
    const char* const raw_name = interfaces[i].name;

    // Use UTF-8 on both Windows and Unixes (While it may be true that UNIX
    // systems are somewhat encoding-agnostic here, it’s more than reasonable
    // to assume UTF8 as the default as well. It’s what people will expect if
    // they name the interface from any input that uses UTF-8, which should be
    // the most frequent case by far these days.)
    name = String::NewFromUtf8(isolate, raw_name).ToLocalChecked();

    snprintf(mac.data(),
             mac.size(),
             ""%02x:%02x:%02x:%02x:%02x:%02x"",
             static_cast<unsigned char>(interfaces[i].phys_addr[0]),
             static_cast<unsigned char>(interfaces[i].phys_addr[1]),
             static_cast<unsigned char>(interfaces[i].phys_addr[2]),
             static_cast<unsigned char>(interfaces[i].phys_addr[3]),
             static_cast<unsigned char>(interfaces[i].phys_addr[4]),
             static_cast<unsigned char>(interfaces[i].phys_addr[5]));
...",31,,198,4,,void
211135,BLOCK,-1,,"{
      uv_ip4_name(&interfaces[i].address.address4, ip, sizeof(ip));
      uv_ip4_name(&interfaces[i].netmask.netmask4, netmask, sizeof(netmask));
      family = env->ipv4_string();
    }",63,,218,2,,void
211167,BLOCK,-1,,<empty>,12,,222,1,,void
211180,BLOCK,-1,,"{
      uv_ip6_name(&interfaces[i].address.address6, ip, sizeof(ip));
      uv_ip6_name(&interfaces[i].netmask.netmask6, netmask, sizeof(netmask));
      family = env->ipv6_string();
    }",71,,222,2,,void
211212,BLOCK,-1,,"{
      strncpy(ip, ""<unknown sa family>"", INET6_ADDRSTRLEN);
      family = env->unknown_string();
    }",12,,226,1,,void
211283,BLOCK,-1,,"{
      uint32_t scopeid = interfaces[i].address.address6.sin6_scope_id;
      result.emplace_back(Integer::NewFromUnsigned(isolate, scopeid));
    }",64,,238,2,,void
211307,BLOCK,-1,,"{
      result.emplace_back(no_scope_id);
    }",12,,241,1,,void
211340,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  char buf[PATH_MAX];

  size_t len = sizeof(buf);
  const int err = uv_os_homedir(buf, &len);

  if (err) {
    CHECK_GE(args.Length(), 1);
    env->CollectUVExceptionInfo(args[args.Length() - 1], err, ""uv_os_homedir"");
    return args.GetReturnValue().SetUndefined();
  }

  Local<String> home = String::NewFromUtf8(env->isolate(),
                                           buf,
                                           NewStringType::kNormal,
                                           len).ToLocalChecked();
  args.GetReturnValue().Set(home);
}",71,,251,2,,void
211364,BLOCK,-1,,"{
    CHECK_GE(args.Length(), 1);
    env->CollectUVExceptionInfo(args[args.Length() - 1], err, ""uv_os_homedir"");
    return args.GetReturnValue().SetUndefined();
  }",12,,258,2,,void
211427,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  uv_passwd_t pwd;
  enum encoding encoding;

  if (args[0]->IsObject()) {
    Local<Object> options = args[0].As<Object>();
    MaybeLocal<Value> maybe_encoding = options->Get(env->context(),
                                                    env->encoding_string());
    Local<Value> encoding_opt;
    if (!maybe_encoding.ToLocal(&encoding_opt))
        return;

    encoding = ParseEncoding(env->isolate(), encoding_opt, UTF8);
  } else {
    encoding = UTF8;
  }

  const int err = uv_os_get_passwd(&pwd);

  if (err) {
    CHECK_GE(args.Length(), 2);
    env->CollectUVExceptionInfo(args[args.Length() - 1], err,
                                ""uv_os_get_passwd"");
    return args.GetReturnValue().SetUndefined();
  }

  auto free_passwd = OnScopeLeave([&]() { uv_os_free_passwd(&pwd); });

  Local<Value> error;

  Local<Value> uid = Number::New(env->isolate(), pwd.uid);
  Local<Value> gid = Number::New(env->isolate(), pwd.gid);
  Ma...",66,,272,2,,void
211444,BLOCK,-1,,"{
    Local<Object> options = args[0].As<Object>();
    MaybeLocal<Value> maybe_encoding = options->Get(env->context(),
                                                    env->encoding_string());
    Local<Value> encoding_opt;
    if (!maybe_encoding.ToLocal(&encoding_opt))
        return;

    encoding = ParseEncoding(env->isolate(), encoding_opt, UTF8);
  }",28,,277,2,,void
211488,BLOCK,-1,,<empty>,9,,283,2,,void
211500,BLOCK,-1,,"{
    encoding = UTF8;
  }",10,,286,1,,void
211512,BLOCK,-1,,"{
    CHECK_GE(args.Length(), 2);
    env->CollectUVExceptionInfo(args[args.Length() - 1], err,
                                ""uv_os_get_passwd"");
    return args.GetReturnValue().SetUndefined();
  }",12,,292,2,,void
211636,BLOCK,-1,,<empty>,5,,316,2,,void
211645,BLOCK,-1,,<empty>,5,,318,1,,void
211677,BLOCK,-1,,"{
    CHECK(!error.IsEmpty());
    env->isolate()->ThrowException(error);
    return;
  }",67,,320,2,,void
211808,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK_EQ(args.Length(), 3);
  CHECK(args[0]->IsInt32());
  CHECK(args[1]->IsInt32());

  const int pid = args[0].As<Int32>()->Value();
  const int priority = args[1].As<Int32>()->Value();
  const int err = uv_os_setpriority(pid, priority);

  if (err) {
    CHECK(args[2]->IsObject());
    env->CollectUVExceptionInfo(args[2], err, ""uv_os_setpriority"");
  }

  args.GetReturnValue().Set(err);
}",66,,344,2,,void
211869,BLOCK,-1,,"{
    CHECK(args[2]->IsObject());
    env->CollectUVExceptionInfo(args[2], err, ""uv_os_setpriority"");
  }",12,,355,2,,void
211898,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK_EQ(args.Length(), 2);
  CHECK(args[0]->IsInt32());

  const int pid = args[0].As<Int32>()->Value();
  int priority;
  const int err = uv_os_getpriority(pid, &priority);

  if (err) {
    CHECK(args[1]->IsObject());
    env->CollectUVExceptionInfo(args[1], err, ""uv_os_getpriority"");
    return;
  }

  args.GetReturnValue().Set(priority);
}",66,,364,2,,void
211942,BLOCK,-1,,"{
    CHECK(args[1]->IsObject());
    env->CollectUVExceptionInfo(args[1], err, ""uv_os_getpriority"");
    return;
  }",12,,374,2,,void
211972,BLOCK,-1,,"{
  unsigned int parallelism = uv_available_parallelism();
  args.GetReturnValue().Set(parallelism);
}",78,,383,2,,void
211992,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  SetMethod(context, target, ""getHostname"", GetHostname);
  SetMethod(context, target, ""getLoadAvg"", GetLoadAvg);
  SetMethod(context, target, ""getUptime"", GetUptime);
  SetMethod(context, target, ""getTotalMem"", GetTotalMemory);
  SetMethod(context, target, ""getFreeMem"", GetFreeMemory);
  SetMethod(context, target, ""getCPUs"", GetCPUInfo);
  SetMethod(context, target, ""getInterfaceAddresses"", GetInterfaceAddresses);
  SetMethod(context, target, ""getHomeDirectory"", GetHomeDirectory);
  SetMethod(context, target, ""getUserInfo"", GetUserInfo);
  SetMethod(context, target, ""setPriority"", SetPriority);
  SetMethod(context, target, ""getPriority"", GetPriority);
  SetMethod(
      context, target, ""getAvailableParallelism"", GetAvailableParallelism);
  SetMethod(context, target, ""getOSInformation"", GetOSInformation);
  target
      ->Set(context,
            FIXED_ONE_BYTE_STRING(env->isolate(), ""isBigEndian""),
            Boolean::New(e...",29,,391,5,,void
212093,BLOCK,-1,,"{
  registry->Register(GetHostname);
  registry->Register(GetLoadAvg);
  registry->Register(GetUptime);
  registry->Register(GetTotalMemory);
  registry->Register(GetFreeMemory);
  registry->Register(GetCPUInfo);
  registry->Register(GetInterfaceAddresses);
  registry->Register(GetHomeDirectory);
  registry->Register(GetUserInfo);
  registry->Register(SetPriority);
  registry->Register(GetPriority);
  registry->Register(GetAvailableParallelism);
  registry->Register(GetOSInformation);
}",70,,414,2,,void
212165,BLOCK,-1,,"{
    entry->Notify(env);
  }",66,,192,2,,void
212178,BLOCK,-1,,"{
        uint64_t delta = histogram.RecordDelta();
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                        ""delay"", delta);
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""min"", histogram.Min());
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""max"", histogram.Max());
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""mean"", histogram.Mean());
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""stddev"", histogram.Stddev());
      }",73,,263,2,,void
212255,BLOCK,-1,,<empty>,1,,1,1,,ANY
212270,BLOCK,-1,,"{
  if (info == nullptr) {
    for (size_t i = 0; i < milestones.Length(); i++) milestones[i] = -1.;
  }
}",51,,60,3,,void
212275,BLOCK,-1,,"{
    for (size_t i = 0; i < milestones.Length(); i++) milestones[i] = -1.;
  }",24,,61,2,,void
212277,BLOCK,-1,,<empty>,5,,62,1,,void
212301,BLOCK,-1,,"{
  SerializeInfo info{root.Serialize(context, creator),
                     milestones.Serialize(context, creator),
                     observers.Serialize(context, creator)};
  return info;
}",67,,67,3,,void
212330,BLOCK,-1,,"{
  root.Deserialize(context);
  // This is just done to set up the pointers, we will actually reset
  // all the milestones after deserialization.
  milestones.Deserialize(context);
  observers.Deserialize(context);
}",68,,74,2,,void
212351,BLOCK,-1,,"{
  o << ""{\n""
    << ""  "" << i.root << "",  // root\n""
    << ""  "" << i.milestones << "",  // milestones\n""
    << ""  "" << i.observers << "",  // observers\n""
    << ""}"";
  return o;
}",68,,83,3,,void
212388,BLOCK,-1,,"{
  this->milestones[milestone] = static_cast<double>(ts);
  TRACE_EVENT_INSTANT_WITH_TIMESTAMP0(
      TRACING_CATEGORY_NODE1(bootstrap),
      GetPerformanceMilestoneName(milestone),
      TRACE_EVENT_SCOPE_THREAD, ts / 1000);
}",74,,92,3,,void
212411,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(args);
  // TODO(legendecas): Remove this check once the sub-realms are supported.
  CHECK_EQ(realm->kind(), Realm::Kind::kPrincipal);
  Environment* env = realm->env();
  PerformanceMilestone milestone =
      static_cast<PerformanceMilestone>(args[0].As<Int32>()->Value());
  if (milestone != NODE_PERFORMANCE_MILESTONE_INVALID)
    env->performance_state()->Mark(milestone);
}",61,,101,2,,void
212455,BLOCK,-1,,<empty>,5,,109,2,,void
212468,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(args);
  // TODO(legendecas): Remove this check once the sub-realms are supported.
  CHECK_EQ(realm->kind(), Realm::Kind::kPrincipal);
  CHECK(args[0]->IsFunction());
  realm->set_performance_entry_callback(args[0].As<Function>());
}",73,,112,2,,void
212511,BLOCK,-1,,"{
  Environment* env = static_cast<Environment*>(data);
  // Prevent gc callback from reentering with different type
  // See https://github.com/nodejs/node/issues/44046
  if (env->performance_state()->current_gc_type != 0) {
    return;
  }
  env->performance_state()->performance_last_gc_start_mark = PERFORMANCE_NOW();
  env->performance_state()->current_gc_type = type;
}",17,,125,5,,void
212527,BLOCK,-1,,"{
    return;
  }",55,,129,2,,void
212550,BLOCK,-1,,"{
  Local<Object> obj = Object::New(env->isolate());

  if (!obj->Set(
          env->context(),
          env->kind_string(),
          Integer::NewFromUnsigned(
              env->isolate(),
              entry.details.kind)).IsJust()) {
    return MaybeLocal<Object>();
  }

  if (!obj->Set(
          env->context(),
          env->flags_string(),
          Integer::NewFromUnsigned(
              env->isolate(),
              entry.details.flags)).IsJust()) {
    return MaybeLocal<Object>();
  }

  return obj;
}",38,,138,3,,void
212595,BLOCK,-1,,"{
    return MaybeLocal<Object>();
  }",46,,146,2,,void
212628,BLOCK,-1,,"{
    return MaybeLocal<Object>();
  }",47,,155,2,,void
212640,BLOCK,-1,,"{
  Environment* env = static_cast<Environment*>(data);
  PerformanceState* state = env->performance_state();
  if (type != state->current_gc_type) {
    return;
  }
  env->performance_state()->current_gc_type = 0;
  // If no one is listening to gc performance entries, do not create them.
  if (LIKELY(!state->observers[NODE_PERFORMANCE_ENTRY_TYPE_GC]))
    return;

  double start_time =
      (state->performance_last_gc_start_mark - env->time_origin()) /
      NANOS_PER_MILLIS;
  double duration = (PERFORMANCE_NOW() / NANOS_PER_MILLIS) -
                    (state->performance_last_gc_start_mark / NANOS_PER_MILLIS);

  std::unique_ptr<GCPerformanceEntry> entry =
      std::make_unique<GCPerformanceEntry>(
          ""gc"",
          start_time,
          duration,
          GCPerformanceEntry::Details(static_cast<PerformanceGCKind>(type),
                                      static_cast<PerformanceGCFlags>(flags)));

  env->SetImmediate([entry = std::move(entry)](Environment* env) {
...",17,,167,5,,void
212659,BLOCK,-1,,"{
    return;
  }",39,,170,2,,void
212677,BLOCK,-1,,<empty>,5,,176,2,,void
212692,BLOCK,1,,<empty>,,,,1,,void
212701,BLOCK,1,,<empty>,,,,1,,void
212708,BLOCK,1,,<empty>,,,,1,,void
212751,BLOCK,-1,,"{
  Environment* env = static_cast<Environment*>(data);
  // Reset current_gc_type to 0
  env->performance_state()->current_gc_type = 0;
  env->isolate()->RemoveGCPrologueCallback(MarkGarbageCollectionStart, data);
  env->isolate()->RemoveGCEpilogueCallback(MarkGarbageCollectionEnd, data);
}",47,,197,2,,void
212788,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  // Reset current_gc_type to 0
  env->performance_state()->current_gc_type = 0;
  env->isolate()->AddGCPrologueCallback(MarkGarbageCollectionStart,
                                        static_cast<void*>(env));
  env->isolate()->AddGCEpilogueCallback(MarkGarbageCollectionEnd,
                                        static_cast<void*>(env));
  env->AddCleanupHook(GarbageCollectionCleanupHook, env);
}",46,,206,2,,void
212837,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  env->RemoveCleanupHook(GarbageCollectionCleanupHook, env);
  GarbageCollectionCleanupHook(env);
}",44,,218,2,,void
212858,BLOCK,-1,,"{
  Local<Value> val = fn->GetDebugName();
  if (val.IsEmpty() || val->IsUndefined()) {
    Local<Value> boundFunction = fn->GetBoundFunction();
    if (!boundFunction.IsEmpty() && !boundFunction->IsUndefined()) {
      val = GetName(boundFunction.As<Function>());
    }
  }
  return val;
}",49,,226,2,,void
212879,BLOCK,-1,,"{
    Local<Value> boundFunction = fn->GetBoundFunction();
    if (!boundFunction.IsEmpty() && !boundFunction->IsUndefined()) {
      val = GetName(boundFunction.As<Function>());
    }
  }",44,,228,2,,void
212902,BLOCK,-1,,"{
      val = GetName(boundFunction.As<Function>());
    }",68,,230,2,,void
212916,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Utf8Value type(env->isolate(), args[0]);
  Local<Value> entry = args[1];
  PerformanceEntryType entry_type = ToPerformanceEntryTypeEnum(*type);
  AliasedUint32Array& observers = env->performance_state()->observers;
  if (entry_type != NODE_PERFORMANCE_ENTRY_TYPE_INVALID &&
      observers[entry_type]) {
    USE(env->performance_entry_callback()->
      Call(env->context(), Undefined(env->isolate()), 1, &entry));
  }
}",54,,238,2,,void
212966,BLOCK,-1,,"{
    USE(env->performance_entry_callback()->
      Call(env->context(), Undefined(env->isolate()), 1, &entry));
  }",30,,245,2,,void
212991,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  uint64_t idle_time = uv_metrics_idle_time(env->event_loop());
  args.GetReturnValue().Set(1.0 * idle_time / 1e6);
}",60,,252,2,,void
213024,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  int64_t interval = args[0].As<Integer>()->Value();
  CHECK_GT(interval, 0);
  BaseObjectPtr<IntervalHistogram> histogram =
      IntervalHistogram::Create(env, interval, [](Histogram& histogram) {
        uint64_t delta = histogram.RecordDelta();
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                        ""delay"", delta);
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""min"", histogram.Min());
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""max"", histogram.Max());
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""mean"", histogram.Mean());
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""stddev"", histogram.Stddev());
      }, Histogram::Options { 1000 });
  args.GetReturnValue().Set(histogram->object());
}",66,,258,2,,void
213079,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  args.GetReturnValue().Set(
      Number::New(args.GetIsolate(), env->time_origin() / NANOS_PER_MILLIS));
}",61,,279,2,,void
213109,BLOCK,1,,<empty>,,,,1,,void
213115,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  args.GetReturnValue().Set(Number::New(
      args.GetIsolate(), env->time_origin_timestamp() / MICROS_PER_MILLIS));
}",70,,285,2,,void
213145,BLOCK,1,,<empty>,,,,1,,void
213151,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(args);
  CHECK_EQ(realm->kind(), Realm::Kind::kPrincipal);
  realm->env()->performance_state()->Mark(
      performance::NODE_PERFORMANCE_MILESTONE_BOOTSTRAP_COMPLETE);
}",69,,291,2,,void
213188,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();
  Local<ObjectTemplate> proto = target->PrototypeTemplate();

  HistogramBase::Initialize(isolate_data, proto);

  SetMethod(isolate, proto, ""markMilestone"", MarkMilestone);
  SetMethod(isolate, proto, ""setupObservers"", SetupPerformanceObservers);
  SetMethod(isolate,
            proto,
            ""installGarbageCollectionTracking"",
            InstallGarbageCollectionTracking);
  SetMethod(isolate,
            proto,
            ""removeGarbageCollectionTracking"",
            RemoveGarbageCollectionTracking);
  SetMethod(isolate, proto, ""notify"", Notify);
  SetMethod(isolate, proto, ""loopIdleTime"", LoopIdleTime);
  SetMethod(isolate, proto, ""getTimeOrigin"", GetTimeOrigin);
  SetMethod(isolate, proto, ""getTimeOriginTimestamp"", GetTimeOriginTimeStamp);
  SetMethod(isolate, proto, ""createELDHistogram"", CreateELDHistogram);
  SetMethod(isolate, proto, ""markBootstrapComplete"", MarkBootstrapComplete);
}",72,,299,3,,void
213269,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();
  PerformanceState* state = env->performance_state();

  target->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""observerCounts""),
              state->observers.GetJSArray()).Check();
  target->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""milestones""),
              state->milestones.GetJSArray()).Check();

  Local<Object> constants = Object::New(isolate);

  NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_MAJOR);
  NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_MINOR);
  NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_INCREMENTAL);
  NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_WEAKCB);

  NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_NO);
  NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_CONSTRUCT_RETAINED);
  NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_FORCED);
  NODE_DEFINE_CONSTANT(
    con...",45,,326,5,,void
213342,BLOCK,1,,<empty>,,,,7,,void
213344,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_MAJOR)",3,,340,1,,void
213441,BLOCK,1,,<empty>,,,,7,,void
213443,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_MINOR)",3,,341,1,,void
213540,BLOCK,1,,<empty>,,,,7,,void
213542,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_INCREMENTAL)",3,,342,1,,void
213639,BLOCK,1,,<empty>,,,,7,,void
213641,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_WEAKCB)",3,,343,1,,void
213738,BLOCK,1,,<empty>,,,,7,,void
213740,BLOCK,-1,,"NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_NO)",3,,345,1,,void
213837,BLOCK,1,,<empty>,,,,7,,void
213839,BLOCK,-1,,"NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_CONSTRUCT_RETAINED)",3,,347,1,,void
213936,BLOCK,1,,<empty>,,,,7,,void
213938,BLOCK,-1,,"NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_FORCED)",3,,349,1,,void
214035,BLOCK,1,,<empty>,,,,7,,void
214037,BLOCK,-1,,"NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_SYNCHRONOUS_PHANTOM_PROCESSING)",3,,351,1,,void
214134,BLOCK,1,,<empty>,,,,7,,void
214136,BLOCK,-1,,"NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_ALL_AVAILABLE_GARBAGE)",3,,353,1,,void
214233,BLOCK,1,,<empty>,,,,7,,void
214235,BLOCK,-1,,"NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_ALL_EXTERNAL_MEMORY)",3,,355,1,,void
214332,BLOCK,1,,<empty>,,,,7,,void
214334,BLOCK,-1,,"NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_SCHEDULE_IDLE)",3,,357,1,,void
214456,BLOCK,-1,,"{
  registry->Register(MarkMilestone);
  registry->Register(SetupPerformanceObservers);
  registry->Register(InstallGarbageCollectionTracking);
  registry->Register(RemoveGarbageCollectionTracking);
  registry->Register(Notify);
  registry->Register(LoopIdleTime);
  registry->Register(GetTimeOrigin);
  registry->Register(GetTimeOriginTimeStamp);
  registry->Register(CreateELDHistogram);
  registry->Register(MarkBootstrapComplete);
  HistogramBase::RegisterExternalReferences(registry);
  IntervalHistogram::RegisterExternalReferences(registry);
}",70,,377,2,,void
214540,BLOCK,-1,,<empty>,1,,1,1,,ANY
214561,BLOCK,-1,,<empty>,1,,1,1,,ANY
214565,BLOCK,-1,,"{
      static_cast<DelayedTaskScheduler*>(data)->Run();
    }",40,,63,2,,void
214578,BLOCK,-1,,<empty>,40,,117,2,,void
214585,BLOCK,-1,,"{
      delete reinterpret_cast<uv_timer_t*>(handle);
    }",77,,157,2,,void
214595,BLOCK,-1,,"{
    std::unique_ptr<uv_async_t> flush_tasks {
        reinterpret_cast<uv_async_t*>(handle) };
    PerIsolatePlatformData* platform_data =
        static_cast<PerIsolatePlatformData*>(flush_tasks->data);
    platform_data->DecreaseHandleCount();
    platform_data->self_reference_.reset();
  }",36,,314,2,,void
214631,BLOCK,-1,,"{
          return delayed.get() == task;
      }",76,,437,2,,void
214645,BLOCK,-1,,"{
        std::unique_ptr<DelayedTask> task {
            static_cast<DelayedTask*>(handle->data) };
        task->platform_data->DecreaseHandleCount();
      }",40,,479,2,,void
214670,BLOCK,-1,,"{
      uv_close(reinterpret_cast<uv_handle_t*>(&delayed->timer),
               [](uv_handle_t* handle) {
        std::unique_ptr<DelayedTask> task {
            static_cast<DelayedTask*>(handle->data) };
        task->platform_data->DecreaseHandleCount();
      });
    }",68,,477,2,,void
214683,BLOCK,-1,,"{
    fprintf(stderr, ""\n"");
    DumpBacktrace(stderr);
    fflush(stderr);
  }",15,,561,1,,void
214709,BLOCK,-1,,<empty>,1,,1,1,,ANY
214720,BLOCK,-1,,"{
  std::unique_ptr<PlatformWorkerData>
      worker_data(static_cast<PlatformWorkerData*>(data));

  TaskQueue<Task>* pending_worker_tasks = worker_data->task_queue;
  TRACE_EVENT_METADATA1(""__metadata"", ""thread_name"", ""name"",
                        ""PlatformWorkerThread"");

  // Notify the main thread that the platform worker is ready.
  {
    Mutex::ScopedLock lock(*worker_data->platform_workers_mutex);
    (*worker_data->pending_platform_workers)--;
    worker_data->platform_workers_ready->Signal(lock);
  }

  while (std::unique_ptr<Task> task = pending_worker_tasks->BlockingPop()) {
    task->Run();
    pending_worker_tasks->NotifyOfCompletion();
  }
}",46,,27,2,,void
214741,BLOCK,5,,"{
    Mutex::ScopedLock lock(*worker_data->platform_workers_mutex);
    (*worker_data->pending_platform_workers)--;
    worker_data->platform_workers_ready->Signal(lock);
  }",3,,36,5,,void
214773,BLOCK,-1,,"{
    task->Run();
    pending_worker_tasks->NotifyOfCompletion();
  }",76,,42,2,,void
214786,BLOCK,-1,,"{
  if (thread_pool_size < 1) {
    thread_pool_size = uv_available_parallelism() - 1;
  }
  return std::max(thread_pool_size, 1);
}",58,,48,2,,void
214791,BLOCK,-1,,"{
    thread_pool_size = uv_available_parallelism() - 1;
  }",29,,49,2,,void
214808,BLOCK,-1,,<empty>,36,,60,2,,void
214812,BLOCK,-1,,"{
    auto start_thread = [](void* data) {
      static_cast<DelayedTaskScheduler*>(data)->Run();
    };
    std::unique_ptr<uv_thread_t> t { new uv_thread_t() };
    uv_sem_init(&ready_, 0);
    CHECK_EQ(0, uv_thread_create(t.get(), start_thread, this));
    uv_sem_wait(&ready_);
    uv_sem_destroy(&ready_);
    return t;
  }",40,,62,1,,void
214853,BLOCK,-1,,"{
    tasks_.Push(std::make_unique<ScheduleTask>(this, std::move(task),
                                               delay_in_seconds));
    uv_async_send(&flush_tasks_);
  }",77,,74,3,,void
214879,BLOCK,-1,,"{
    tasks_.Push(std::make_unique<StopTask>(this));
    uv_async_send(&flush_tasks_);
  }",15,,80,1,,void
214897,BLOCK,-1,,"{
    TRACE_EVENT_METADATA1(""__metadata"", ""thread_name"", ""name"",
                          ""WorkerThreadsTaskRunner::DelayedTaskScheduler"");
    loop_.data = this;
    CHECK_EQ(0, uv_loop_init(&loop_));
    flush_tasks_.data = this;
    CHECK_EQ(0, uv_async_init(&loop_, &flush_tasks_, FlushTasks));
    uv_sem_post(&ready_);

    uv_run(&loop_, UV_RUN_DEFAULT);
    CheckedUvLoopClose(&loop_);
  }",14,,86,1,,void
214940,BLOCK,-1,,"{
    DelayedTaskScheduler* scheduler =
        ContainerOf(&DelayedTaskScheduler::loop_, flush_tasks->loop);
    while (std::unique_ptr<Task> task = scheduler->tasks_.Pop())
      task->Run();
  }",51,,99,2,,void
214975,BLOCK,-1,,<empty>,79,,108,2,,void
214979,BLOCK,-1,,"{
      std::vector<uv_timer_t*> timers;
      for (uv_timer_t* timer : scheduler_->timers_)
        timers.push_back(timer);
      for (uv_timer_t* timer : timers)
        scheduler_->TakeTimerTask(timer);
      uv_close(reinterpret_cast<uv_handle_t*>(&scheduler_->flush_tasks_),
               [](uv_handle_t* handle) {});
    }",25,,110,1,,void
215015,BLOCK,-1,,<empty>,45,,131,4,,void
215019,BLOCK,-1,,"{
      uint64_t delay_millis = llround(delay_in_seconds_ * 1000);
      std::unique_ptr<uv_timer_t> timer(new uv_timer_t());
      CHECK_EQ(0, uv_timer_init(&scheduler_->loop_, timer.get()));
      timer->data = task_.release();
      CHECK_EQ(0, uv_timer_start(timer.get(), RunTask, delay_millis, 0));
      scheduler_->timers_.insert(timer.release());
    }",25,,133,1,,void
215082,BLOCK,-1,,"{
    DelayedTaskScheduler* scheduler =
        ContainerOf(&DelayedTaskScheduler::loop_, timer->loop);
    scheduler->pending_worker_tasks_->Push(scheduler->TakeTimerTask(timer));
  }",42,,148,2,,void
215109,BLOCK,-1,,"{
    std::unique_ptr<Task> task(static_cast<Task*>(timer->data));
    uv_timer_stop(timer);
    uv_close(reinterpret_cast<uv_handle_t*>(timer), [](uv_handle_t* handle) {
      delete reinterpret_cast<uv_timer_t*>(handle);
    });
    timers_.erase(timer);
    return task;
  }",58,,154,2,,void
215146,BLOCK,-1,,"{
  Mutex platform_workers_mutex;
  ConditionVariable platform_workers_ready;

  Mutex::ScopedLock lock(platform_workers_mutex);
  int pending_platform_workers = thread_pool_size;

  delayed_task_scheduler_ = std::make_unique<DelayedTaskScheduler>(
      &pending_worker_tasks_);
  threads_.push_back(delayed_task_scheduler_->Start());

  for (int i = 0; i < thread_pool_size; i++) {
    PlatformWorkerData* worker_data = new PlatformWorkerData{
      &pending_worker_tasks_, &platform_workers_mutex,
      &platform_workers_ready, &pending_platform_workers, i
    };
    std::unique_ptr<uv_thread_t> t { new uv_thread_t() };
    if (uv_thread_create(t.get(), PlatformWorkerThread,
                         worker_data) != 0) {
      break;
    }
    threads_.push_back(std::move(t));
  }

  // Wait for platform workers to initialize before continuing with the
  // bootstrap.
  while (pending_platform_workers > 0) {
    platform_workers_ready.Wait(lock);
  }
}",72,,173,2,,void
215175,BLOCK,-1,,<empty>,3,,184,1,,void
215185,BLOCK,4,,"{
    PlatformWorkerData* worker_data = new PlatformWorkerData{
      &pending_worker_tasks_, &platform_workers_mutex,
      &platform_workers_ready, &pending_platform_workers, i
    };
    std::unique_ptr<uv_thread_t> t { new uv_thread_t() };
    if (uv_thread_create(t.get(), PlatformWorkerThread,
                         worker_data) != 0) {
      break;
    }
    threads_.push_back(std::move(t));
  }",46,,184,4,,void
215211,BLOCK,-1,,"{
      break;
    }",45,,191,2,,void
215226,BLOCK,-1,,"{
    platform_workers_ready.Wait(lock);
  }",40,,199,2,,void
215236,BLOCK,-1,,"{
  pending_worker_tasks_.Push(std::move(task));
}",68,,204,2,,void
215251,BLOCK,-1,,"{
  delayed_task_scheduler_->PostDelayedTask(std::move(task), delay_in_seconds);
}",72,,209,3,,void
215265,BLOCK,-1,,"{
  pending_worker_tasks_.BlockingDrain();
}",47,,213,1,,void
215273,BLOCK,-1,,"{
  pending_worker_tasks_.Stop();
  delayed_task_scheduler_->Stop();
  for (size_t i = 0; i < threads_.size(); i++) {
    CHECK_EQ(0, uv_thread_join(threads_[i].get()));
  }
}",42,,217,1,,void
215283,BLOCK,-1,,<empty>,3,,220,1,,void
215296,BLOCK,4,,"{
    CHECK_EQ(0, uv_thread_join(threads_[i].get()));
  }",48,,220,4,,void
215309,BLOCK,-1,,"{
  return threads_.size();
}",60,,225,1,,void
215320,BLOCK,-1,,"{
  flush_tasks_ = new uv_async_t();
  CHECK_EQ(0, uv_async_init(loop, flush_tasks_, FlushTasks));
  flush_tasks_->data = static_cast<void*>(this);
  uv_unref(reinterpret_cast<uv_handle_t*>(flush_tasks_));
}",36,,231,3,,void
215345,BLOCK,-1,,"{
  return shared_from_this();
}",51,,239,1,,void
215352,BLOCK,-1,,"{
  auto platform_data = static_cast<PerIsolatePlatformData*>(handle->data);
  platform_data->FlushForegroundTasksInternal();
}",61,,243,2,,void
215369,BLOCK,-1,,"{
  UNREACHABLE();
}",79,,248,2,,void
215375,BLOCK,-1,,"{
  if (flush_tasks_ == nullptr) {
    // V8 may post tasks during Isolate disposal. In that case, the only
    // sensible path forward is to discard the task.
    return;
  }
  foreground_tasks_.Push(std::move(task));
  uv_async_send(flush_tasks_);
}",67,,252,2,,void
215380,BLOCK,-1,,"{
    // V8 may post tasks during Isolate disposal. In that case, the only
    // sensible path forward is to discard the task.
    return;
  }",32,,253,2,,void
215397,BLOCK,-1,,"{
  if (flush_tasks_ == nullptr) {
    // V8 may post tasks during Isolate disposal. In that case, the only
    // sensible path forward is to discard the task.
    return;
  }
  std::unique_ptr<DelayedTask> delayed(new DelayedTask());
  delayed->task = std::move(task);
  delayed->platform_data = shared_from_this();
  delayed->timeout = delay_in_seconds;
  foreground_delayed_tasks_.Push(std::move(delayed));
  uv_async_send(flush_tasks_);
}",58,,263,3,,void
215402,BLOCK,-1,,"{
    // V8 may post tasks during Isolate disposal. In that case, the only
    // sensible path forward is to discard the task.
    return;
  }",32,,264,2,,void
215446,BLOCK,-1,,"{
  PostTask(std::move(task));
}",78,,277,2,,void
215458,BLOCK,-1,,"{
  PostDelayedTask(std::move(task), delay_in_seconds);
}",30,,283,3,,void
215469,BLOCK,-1,,"{
  CHECK(!flush_tasks_);
}",51,,287,1,,void
215478,BLOCK,-1,,"{
  shutdown_callbacks_.emplace_back(ShutdownCallback { callback, data });
}",62,,292,3,,void
215490,BLOCK,-1,,"{
  if (flush_tasks_ == nullptr)
    return;

  // While there should be no V8 tasks in the queues at this point, it is
  // possible that Node.js-internal tasks from e.g. the inspector are still
  // lying around. We clear these queues and ignore the return value,
  // effectively deleting the tasks instead of running them.
  foreground_delayed_tasks_.PopAll();
  foreground_tasks_.PopAll();
  scheduled_delayed_tasks_.clear();

  // Both destroying the scheduled_delayed_tasks_ lists and closing
  // flush_tasks_ handle add tasks to the event loop. We keep a count of all
  // non-closed handles, and when that reaches zero, we inform any shutdown
  // callbacks that the platform is done as far as this Isolate is concerned.
  self_reference_ = shared_from_this();
  uv_close(reinterpret_cast<uv_handle_t*>(flush_tasks_),
           [](uv_handle_t* handle) {
    std::unique_ptr<uv_async_t> flush_tasks {
        reinterpret_cast<uv_async_t*>(handle) };
    PerIsolatePlatformData* platform_...",41,,296,1,,void
215495,BLOCK,-1,,<empty>,5,,298,2,,void
215523,BLOCK,-1,,"{
  CHECK_GE(uv_handle_count_, 1);
  if (--uv_handle_count_ == 0) {
    for (const auto& callback : shutdown_callbacks_)
      callback.cb(callback.data);
  }
}",52,,325,1,,void
215532,BLOCK,-1,,"{
    for (const auto& callback : shutdown_callbacks_)
      callback.cb(callback.data);
  }",32,,327,2,,void
215549,BLOCK,-1,,"{
  if (tracing_controller != nullptr) {
    tracing_controller_ = tracing_controller;
  } else {
    tracing_controller_ = new v8::TracingController();
  }

  // V8 will default to its built in allocator if none is provided.
  page_allocator_ = page_allocator;

  // TODO(addaleax): It's a bit icky that we use global state here, but we can't
  // really do anything about it unless V8 starts exposing a way to access the
  // current v8::Platform instance.
  SetTracingController(tracing_controller_);
  DCHECK_EQ(GetTracingController(), tracing_controller_);

  thread_pool_size = GetActualThreadPoolSize(thread_pool_size);
  worker_thread_task_runner_ =
      std::make_shared<WorkerThreadsTaskRunner>(thread_pool_size);
}",63,,335,4,,void
215554,BLOCK,-1,,"{
    tracing_controller_ = tracing_controller;
  }",38,,336,2,,void
215559,BLOCK,-1,,"{
    tracing_controller_ = new v8::TracingController();
  }",10,,338,1,,void
215587,BLOCK,-1,,"{
  Shutdown();
}",31,,356,1,,void
215594,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_isolate_mutex_);
  auto delegate = std::make_shared<PerIsolatePlatformData>(isolate, loop);
  IsolatePlatformDelegate* ptr = delegate.get();
  auto insertion = per_isolate_.emplace(
    isolate,
    std::make_pair(ptr, std::move(delegate)));
  CHECK(insertion.second);
}",71,,360,3,,void
215645,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_isolate_mutex_);
  auto insertion = per_isolate_.emplace(
    isolate,
    std::make_pair(delegate, std::shared_ptr<PerIsolatePlatformData>{}));
  CHECK(insertion.second);
}",71,,371,3,,void
215672,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_isolate_mutex_);
  auto existing_it = per_isolate_.find(isolate);
  CHECK_NE(existing_it, per_isolate_.end());
  auto& existing = existing_it->second;
  if (existing.second) {
    existing.second->Shutdown();
  }
  per_isolate_.erase(existing_it);
}",56,,379,2,,void
215700,BLOCK,-1,,"{
    existing.second->Shutdown();
  }",24,,384,2,,void
215718,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_isolate_mutex_);
  auto it = per_isolate_.find(isolate);
  if (it == per_isolate_.end()) {
    cb(data);
    return;
  }
  CHECK(it->second.second);
  it->second.second->AddShutdownCallback(cb, data);
}",78,,391,4,,void
215737,BLOCK,-1,,"{
    cb(data);
    return;
  }",33,,394,2,,void
215760,BLOCK,-1,,"{
  if (has_shut_down_) return;
  has_shut_down_ = true;
  worker_thread_task_runner_->Shutdown();

  {
    Mutex::ScopedLock lock(per_isolate_mutex_);
    per_isolate_.clear();
  }
}",31,,402,1,,void
215763,BLOCK,-1,,<empty>,23,,403,2,,void
215772,BLOCK,4,,"{
    Mutex::ScopedLock lock(per_isolate_mutex_);
    per_isolate_.clear();
  }",3,,407,4,,void
215783,BLOCK,-1,,"{
  return worker_thread_task_runner_->NumberOfWorkerThreads();
}",43,,413,1,,void
215793,BLOCK,-1,,"{
  if (isolate_->IsExecutionTerminating()) return;
  DebugSealHandleScope scope(isolate_);
  Environment* env = Environment::GetCurrent(isolate_);
  if (env != nullptr) {
    v8::HandleScope scope(isolate_);
    InternalCallbackScope cb_scope(env, Object::New(isolate_), { 0, 0 },
                                   InternalCallbackScope::kNoFlags);
    task->Run();
  } else {
    // The task is moved out of InternalCallbackScope if env is not available.
    // This is a required else block, and should not be removed.
    // See comment: https://github.com/nodejs/node/pull/34688#pullrequestreview-463867489
    task->Run();
  }
}",76,,417,2,,void
215799,BLOCK,-1,,<empty>,43,,418,2,,void
215816,BLOCK,-1,,"{
    v8::HandleScope scope(isolate_);
    InternalCallbackScope cb_scope(env, Object::New(isolate_), { 0, 0 },
                                   InternalCallbackScope::kNoFlags);
    task->Run();
  }",23,,421,2,,void
215839,BLOCK,-1,,"{
    // The task is moved out of InternalCallbackScope if env is not available.
    // This is a required else block, and should not be removed.
    // See comment: https://github.com/nodejs/node/pull/34688#pullrequestreview-463867489
    task->Run();
  }",10,,426,1,,void
215847,BLOCK,-1,,"{
  auto it = std::find_if(scheduled_delayed_tasks_.begin(),
                         scheduled_delayed_tasks_.end(),
                         [task](const DelayedTaskPointer& delayed) -> bool {
          return delayed.get() == task;
      });
  CHECK_NE(it, scheduled_delayed_tasks_.end());
  scheduled_delayed_tasks_.erase(it);
}",74,,434,2,,void
215879,BLOCK,-1,,"{
  DelayedTask* delayed = ContainerOf(&DelayedTask::timer, handle);
  delayed->platform_data->RunForegroundTask(std::move(delayed->task));
  delayed->platform_data->DeleteFromScheduledTasks(delayed);
}",68,,444,2,,void
215913,BLOCK,-1,,"{
  std::shared_ptr<PerIsolatePlatformData> per_isolate = ForNodeIsolate(isolate);
  if (!per_isolate) return;

  do {
    // Worker tasks aren't associated with an Isolate.
    worker_thread_task_runner_->BlockingDrain();
  } while (per_isolate->FlushForegroundTasksInternal());
}",49,,450,2,,void
215927,BLOCK,-1,,<empty>,21,,452,2,,void
215930,BLOCK,-1,,"{
    // Worker tasks aren't associated with an Isolate.
    worker_thread_task_runner_->BlockingDrain();
  }",6,,454,1,,void
215942,BLOCK,-1,,"{
  bool did_work = false;

  while (std::unique_ptr<DelayedTask> delayed =
      foreground_delayed_tasks_.Pop()) {
    did_work = true;
    uint64_t delay_millis = llround(delayed->timeout * 1000);

    delayed->timer.data = static_cast<void*>(delayed.get());
    uv_timer_init(loop_, &delayed->timer);
    // Timers may not guarantee queue ordering of events with the same delay if
    // the delay is non-zero. This should not be a problem in practice.
    uv_timer_start(&delayed->timer, RunForegroundTask, delay_millis, 0);
    uv_unref(reinterpret_cast<uv_handle_t*>(&delayed->timer));
    uv_handle_count_++;

    scheduled_delayed_tasks_.emplace_back(delayed.release(),
                                          [](DelayedTask* delayed) {
      uv_close(reinterpret_cast<uv_handle_t*>(&delayed->timer),
               [](uv_handle_t* handle) {
        std::unique_ptr<DelayedTask> task {
            static_cast<DelayedTask*>(handle->data) };
        task->platform_data->DecreaseHandleCo...",61,,460,1,,void
215960,BLOCK,-1,,"{
    did_work = true;
    uint64_t delay_millis = llround(delayed->timeout * 1000);

    delayed->timer.data = static_cast<void*>(delayed.get());
    uv_timer_init(loop_, &delayed->timer);
    // Timers may not guarantee queue ordering of events with the same delay if
    // the delay is non-zero. This should not be a problem in practice.
    uv_timer_start(&delayed->timer, RunForegroundTask, delay_millis, 0);
    uv_unref(reinterpret_cast<uv_handle_t*>(&delayed->timer));
    uv_handle_count_++;

    scheduled_delayed_tasks_.emplace_back(delayed.release(),
                                          [](DelayedTask* delayed) {
      uv_close(reinterpret_cast<uv_handle_t*>(&delayed->timer),
               [](uv_handle_t* handle) {
        std::unique_ptr<DelayedTask> task {
            static_cast<DelayedTask*>(handle->data) };
        task->platform_data->DecreaseHandleCount();
      });
    });
  }",40,,464,2,,void
216039,BLOCK,-1,,"{
    std::unique_ptr<Task> task = std::move(tasks.front());
    tasks.pop();
    did_work = true;
    RunForegroundTask(std::move(task));
  }",26,,490,2,,void
216075,BLOCK,-1,,"{
  worker_thread_task_runner_->PostTask(std::move(task));
}",67,,499,2,,void
216090,BLOCK,-1,,"{
  worker_thread_task_runner_->PostDelayedTask(std::move(task),
                                              delay_in_seconds);
}",71,,504,3,,void
216105,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_isolate_mutex_);
  auto data = per_isolate_[isolate];
  CHECK_NOT_NULL(data.first);
  return data.first;
}",69,,510,2,,void
216127,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_isolate_mutex_);
  auto data = per_isolate_[isolate];
  CHECK_NOT_NULL(data.first);
  return data.second;
}",48,,518,2,,void
216149,BLOCK,-1,,"{
  std::shared_ptr<PerIsolatePlatformData> per_isolate = ForNodeIsolate(isolate);
  if (!per_isolate) return false;
  return per_isolate->FlushForegroundTasksInternal();
}",59,,525,2,,void
216163,BLOCK,-1,,<empty>,21,,527,2,,void
216176,BLOCK,-1,,"{
  return v8::platform::NewDefaultJobHandle(
      this, priority, std::move(job_task), NumberOfWorkerThreads());
}",71,,532,3,,void
216196,BLOCK,-1,,"{
  return ForIsolate(isolate)->IdleTasksEnabled();
}",55,,537,2,,void
216207,BLOCK,-1,,"{
  return ForIsolate(isolate)->GetForegroundTaskRunner();
}",57,,542,2,,void
216217,BLOCK,-1,,"{
  // Convert nanos to seconds.
  return uv_hrtime() / 1e9;
}",52,,546,1,,void
216225,BLOCK,-1,,"{
  return SystemClockTimeMillis();
}",47,,551,1,,void
216231,BLOCK,-1,,"{
  CHECK_NOT_NULL(tracing_controller_);
  return tracing_controller_;
}",61,,555,1,,void
216238,BLOCK,-1,,"{
  return []() {
    fprintf(stderr, ""\n"");
    DumpBacktrace(stderr);
    fflush(stderr);
  };
}",66,,560,1,,void
216244,BLOCK,-1,,"{
  return page_allocator_;
}",53,,568,1,,void
216250,BLOCK,-1,,{ },61,,575,1,,void
216255,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(lock_);
  outstanding_tasks_++;
  task_queue_.push(std::move(task));
  tasks_available_.Signal(scoped_lock);
}",50,,578,2,,void
216278,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(lock_);
  if (task_queue_.empty()) {
    return std::unique_ptr<T>(nullptr);
  }
  std::unique_ptr<T> result = std::move(task_queue_.front());
  task_queue_.pop();
  return result;
}",40,,586,1,,void
216287,BLOCK,-1,,"{
    return std::unique_ptr<T>(nullptr);
  }",28,,588,2,,void
216321,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(lock_);
  while (task_queue_.empty() && !stopped_) {
    tasks_available_.Wait(scoped_lock);
  }
  if (stopped_) {
    return std::unique_ptr<T>(nullptr);
  }
  std::unique_ptr<T> result = std::move(task_queue_.front());
  task_queue_.pop();
  return result;
}",48,,597,1,,void
216333,BLOCK,-1,,"{
    tasks_available_.Wait(scoped_lock);
  }",44,,599,2,,void
216341,BLOCK,-1,,"{
    return std::unique_ptr<T>(nullptr);
  }",17,,602,2,,void
216375,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(lock_);
  if (--outstanding_tasks_ == 0) {
    tasks_drained_.Broadcast(scoped_lock);
  }
}",41,,611,1,,void
216384,BLOCK,-1,,"{
    tasks_drained_.Broadcast(scoped_lock);
  }",34,,613,2,,void
216393,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(lock_);
  while (outstanding_tasks_ > 0) {
    tasks_drained_.Wait(scoped_lock);
  }
}",36,,619,1,,void
216401,BLOCK,-1,,"{
    tasks_drained_.Wait(scoped_lock);
  }",34,,621,2,,void
216410,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(lock_);
  stopped_ = true;
  tasks_available_.Broadcast(scoped_lock);
}",27,,627,1,,void
216425,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(lock_);
  std::queue<std::unique_ptr<T>> result;
  result.swap(task_queue_);
  return result;
}",55,,634,1,,void
216469,BLOCK,-1,,<empty>,1,,1,1,,ANY
216486,BLOCK,-1,,<empty>,1,,1,1,,ANY
216513,BLOCK,-1,,"{
  nodedbg_const_ContextEmbedderIndex__kEnvironment__int =
      ContextEmbedderIndex::kEnvironment;
  nodedbg_const_BaseObject__kInternalFieldCount__int =
      BaseObject::kInternalFieldCount;

  nodedbg_offset_ExternalString__data__uintptr_t = NODE_OFF_EXTSTR_DATA;
  nodedbg_offset_ReqWrap__req_wrap_queue___ListNode_ReqWrapQueue =
      OffsetOf<ListNode<ReqWrapBase>, ReqWrap<uv_req_t>>(
          &ReqWrap<uv_req_t>::req_wrap_queue_);

  #define V(Class, Member, Type, Accessor)                                    \
    NODEDBG_OFFSET(Class, Member, Type) = OffsetOf(&Accessor);
    NODE_OFFSET_POSTMORTEM_METADATA(V)
  #undef V

  return 1;
}",23,,52,1,,void
216527,BLOCK,1,,<empty>,,,,1,,void
216542,BLOCK,1,,<empty>,,,,2,,void
216651,BLOCK,-1,,<empty>,1,,1,1,,ANY
216662,BLOCK,-1,,<empty>,1,,1,1,,ANY
216675,BLOCK,-1,,<empty>,1,,1,1,,ANY
216681,BLOCK,-1,,"{
  Isolate* isolate = env->isolate();

  Local<String> event_string;
  if (!String::NewFromOneByte(isolate, reinterpret_cast<const uint8_t*>(event))
      .ToLocal(&event_string)) return MaybeLocal<Value>();

  Local<Object> process = env->process_object();
  Local<Value> argv[] = {event_string, message};
  return MakeCallback(isolate, process, ""emit"", arraysize(argv), argv, {0, 0});
}",53,,23,4,,void
216709,BLOCK,-1,,<empty>,32,,28,2,,void
216746,BLOCK,-1,,"{
  if (!env->can_call_into_js()) return Just(false);

  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Object> process = env->process_object();
  Local<Value> emit_warning;
  if (!process->Get(env->context(), env->emit_warning_string())
           .ToLocal(&emit_warning)) {
    return Nothing<bool>();
  }

  if (!emit_warning->IsFunction()) return Just(false);

  int argc = 0;
  Local<Value> args[3];  // warning, type, code

  // The caller has to be able to handle a failure anyway, so we might as well
  // do proper error checking for string creation.
  if (!String::NewFromUtf8(env->isolate(), warning).ToLocal(&args[argc++]))
    return Nothing<bool>();

  if (type != nullptr) {
    if (!String::NewFromOneByte(env->isolate(),
                                reinterpret_cast<const uint8_t*>(type))
             .ToLocal(&args[argc++])) {
      return Nothing<bool>();
    }
    if (code != nullptr &&
        !String::NewFromOneByte(...",57,,38,5,,void
216753,BLOCK,-1,,<empty>,33,,39,2,,void
216803,BLOCK,-1,,"{
    return Nothing<bool>();
  }",37,,47,2,,void
216812,BLOCK,-1,,<empty>,36,,51,2,,void
216846,BLOCK,-1,,<empty>,5,,59,2,,void
216853,BLOCK,-1,,"{
    if (!String::NewFromOneByte(env->isolate(),
                                reinterpret_cast<const uint8_t*>(type))
             .ToLocal(&args[argc++])) {
      return Nothing<bool>();
    }
    if (code != nullptr &&
        !String::NewFromOneByte(env->isolate(),
                                reinterpret_cast<const uint8_t*>(code))
             .ToLocal(&args[argc++])) {
      return Nothing<bool>();
    }
  }",24,,61,2,,void
216875,BLOCK,-1,,"{
      return Nothing<bool>();
    }",39,,64,2,,void
216903,BLOCK,-1,,"{
      return Nothing<bool>();
    }",39,,70,2,,void
216924,BLOCK,-1,,"{
    return Nothing<bool>();
  }",23,,79,2,,void
216936,BLOCK,-1,,"{
  if (experimental_warnings.find(warning) != experimental_warnings.end())
    return Nothing<bool>();

  experimental_warnings.insert(warning);
  std::string message(warning);
  message.append("" is an experimental feature and might change at any time"");
  return ProcessEmitWarningGeneric(env, message.c_str(), ""ExperimentalWarning"");
}",64,,89,3,,void
216948,BLOCK,-1,,<empty>,5,,91,2,,void
216978,BLOCK,-1,,"{
  return ProcessEmitWarningGeneric(
      env, warning, ""DeprecationWarning"", deprecation_code);
}",73,,101,4,,void
217037,BLOCK,-1,,<empty>,1,,1,1,,ANY
217043,BLOCK,-1,,"{
  Abort();
}",60,,67,2,,void
217049,BLOCK,-1,,"{
  // This should crash hard all platforms.
  volatile void** d = static_cast<volatile void**>(nullptr);
  *d = nullptr;
}",68,,72,2,,void
217064,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(env->owns_process_state());

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());
  Utf8Value path(env->isolate(), args[0]);
  int err = uv_chdir(*path);
  if (err) {
    // Also include the original working directory, since that will usually
    // be helpful information when debugging a `chdir()` failure.
    char buf[PATH_MAX_BYTES];
    size_t cwd_len = sizeof(buf);
    uv_cwd(buf, &cwd_len);
    return env->ThrowUVException(err, ""chdir"", nullptr, buf, *path);
  }
}",60,,78,2,,void
217108,BLOCK,-1,,"{
    // Also include the original working directory, since that will usually
    // be helpful information when debugging a `chdir()` failure.
    char buf[PATH_MAX_BYTES];
    size_t cwd_len = sizeof(buf);
    uv_cwd(buf, &cwd_len);
    return env->ThrowUVException(err, ""chdir"", nullptr, buf, *path);
  }",12,,86,2,,void
217136,BLOCK,-1,,"{
  CHECK(args[index]->IsFloat64Array());
  Local<Float64Array> arr = args[index].As<Float64Array>();
  CHECK_EQ(arr->Length(), array_length);
  return arr->Buffer();
}",26,,99,4,,void
217171,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  uv_rusage_t rusage;

  // Call libuv to get the values we'll return.
  int err = uv_getrusage(&rusage);
  if (err)
    return env->ThrowUVException(err, ""uv_getrusage"");

  // Get the double array pointer from the Float64Array argument.
  Local<ArrayBuffer> ab = get_fields_array_buffer(args, 0, 2);
  double* fields = static_cast<double*>(ab->Data());

  // Set the Float64Array elements to be user / system values in microseconds.
  fields[0] = MICROS_PER_SEC * rusage.ru_utime.tv_sec + rusage.ru_utime.tv_usec;
  fields[1] = MICROS_PER_SEC * rusage.ru_stime.tv_sec + rusage.ru_stime.tv_usec;
}",63,,111,2,,void
217189,BLOCK,-1,,<empty>,5,,118,2,,void
217223,BLOCK,1,,<empty>,,,,1,,void
217242,BLOCK,1,,<empty>,,,,1,,void
217258,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(env->has_run_bootstrapping_code());
  char buf[PATH_MAX_BYTES];
  size_t cwd_len = sizeof(buf);
  int err = uv_cwd(buf, &cwd_len);
  if (err)
    return env->ThrowUVException(err, ""uv_cwd"");

  Local<String> cwd = String::NewFromUtf8(env->isolate(),
                                          buf,
                                          NewStringType::kNormal,
                                          cwd_len).ToLocalChecked();
  args.GetReturnValue().Set(cwd);
}",58,,129,2,,void
217287,BLOCK,-1,,<empty>,5,,136,2,,void
217329,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Local<Context> context = env->context();

  if (args.Length() < 2) {
    THROW_ERR_MISSING_ARGS(env, ""Bad argument."");
  }

  int pid;
  if (!args[0]->Int32Value(context).To(&pid)) return;
  int sig;
  if (!args[1]->Int32Value(context).To(&sig)) return;

  uv_pid_t own_pid = uv_os_getpid();
  if (sig > 0 &&
      (pid == 0 || pid == -1 || pid == own_pid || pid == -own_pid) &&
      !HasSignalJSHandler(sig)) {
    // This is most likely going to terminate this process.
    // It's not an exact method but it might be close enough.
    RunAtExit(env);
  }

  int err = uv_kill(pid, sig);
  args.GetReturnValue().Set(err);
}",59,,145,2,,void
217355,BLOCK,-1,,"{
    THROW_ERR_MISSING_ARGS(env, ""Bad argument."");
  }",26,,149,2,,void
217374,BLOCK,-1,,<empty>,47,,154,2,,void
217391,BLOCK,-1,,<empty>,47,,156,2,,void
217423,BLOCK,-1,,"{
    // This is most likely going to terminate this process.
    // It's not an exact method but it might be close enough.
    RunAtExit(env);
  }",33,,161,2,,void
217444,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  size_t rss;
  int err = uv_resident_set_memory(&rss);
  if (err)
    return env->ThrowUVException(err, ""uv_resident_set_memory"");

  args.GetReturnValue().Set(static_cast<double>(rss));
}",58,,171,2,,void
217462,BLOCK,-1,,<empty>,5,,177,2,,void
217484,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  Isolate* isolate = env->isolate();
  // V8 memory usage
  HeapStatistics v8_heap_stats;
  isolate->GetHeapStatistics(&v8_heap_stats);

  NodeArrayBufferAllocator* array_buffer_allocator =
      env->isolate_data()->node_allocator();

  // Get the double array pointer from the Float64Array argument.
  Local<ArrayBuffer> ab = get_fields_array_buffer(args, 0, 5);
  double* fields = static_cast<double*>(ab->Data());

  size_t rss;
  int err = uv_resident_set_memory(&rss);
  if (err)
    return env->ThrowUVException(err, ""uv_resident_set_memory"");

  fields[0] = static_cast<double>(rss);
  fields[1] = static_cast<double>(v8_heap_stats.total_heap_size());
  fields[2] = static_cast<double>(v8_heap_stats.used_heap_size());
  fields[3] = static_cast<double>(v8_heap_stats.external_memory());
  fields[4] =
      array_buffer_allocator == nullptr
          ? 0
          : static_cast<double>(array_buffer_allocator->total_mem_usage());
}",66,,182,2,,void
217545,BLOCK,-1,,<empty>,5,,200,2,,void
217609,BLOCK,-1,,"{
  uint64_t value = uv_get_constrained_memory();
  if (value != 0) {
    args.GetReturnValue().Set(static_cast<double>(value));
  }
}",75,,212,2,,void
217618,BLOCK,-1,,"{
    args.GetReturnValue().Set(static_cast<double>(value));
  }",19,,214,2,,void
217633,BLOCK,-1,,"{
  CHECK(args.Length() == 1 && args[0]->IsString() &&
        ""must be called with a single string"");
  Utf8Value message(args.GetIsolate(), args[0]);
  FPrintF(stderr, ""%s\n"", message);
  fflush(stderr);
}",56,,219,2,,void
217668,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(env->has_run_bootstrapping_code());
  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsUndefined() || args[0]->IsUint32());
  Mutex::ScopedLock scoped_lock(per_process::umask_mutex);

  uint32_t old;
  if (args[0]->IsUndefined()) {
    old = umask(0);
    umask(static_cast<mode_t>(old));
  } else {
    int oct = args[0].As<Uint32>()->Value();
    old = umask(static_cast<mode_t>(oct));
  }

  args.GetReturnValue().Set(old);
}",60,,227,2,,void
217715,BLOCK,-1,,"{
    old = umask(0);
    umask(static_cast<mode_t>(old));
  }",31,,235,2,,void
217725,BLOCK,-1,,"{
    int oct = args[0].As<Uint32>()->Value();
    old = umask(static_cast<mode_t>(oct));
  }",10,,238,1,,void
217756,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  uv_update_time(env->event_loop());
  double uptime =
      static_cast<double>(uv_hrtime() - per_process::node_start_time);
  Local<Number> result = Number::New(env->isolate(), uptime / NANOS_PER_SEC);
  args.GetReturnValue().Set(result);
}",61,,246,2,,void
217797,BLOCK,1,,<empty>,,,,1,,void
217811,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  std::vector<Local<Value>> request_v;
  for (ReqWrapBase* req_wrap : *env->req_wrap_queue()) {
    AsyncWrap* w = req_wrap->GetAsyncWrap();
    if (w->persistent().IsEmpty())
      continue;
    request_v.emplace_back(w->GetOwner());
  }

  args.GetReturnValue().Set(
      Array::New(env->isolate(), request_v.data(), request_v.size()));
}",72,,256,2,,void
217836,BLOCK,-1,,"{
    AsyncWrap* w = req_wrap->GetAsyncWrap();
    if (w->persistent().IsEmpty())
      continue;
    request_v.emplace_back(w->GetOwner());
  }",56,,260,3,,void
217852,BLOCK,-1,,<empty>,7,,263,2,,void
217889,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  std::vector<Local<Value>> handle_v;
  for (auto w : *env->handle_wrap_queue()) {
    if (!HandleWrap::HasRef(w))
      continue;
    handle_v.emplace_back(w->GetOwner());
  }
  args.GetReturnValue().Set(
      Array::New(env->isolate(), handle_v.data(), handle_v.size()));
}",64,,273,2,,void
217914,BLOCK,-1,,"{
    if (!HandleWrap::HasRef(w))
      continue;
    handle_v.emplace_back(w->GetOwner());
  }",44,,277,3,,void
217922,BLOCK,-1,,<empty>,7,,279,2,,void
217959,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  std::vector<Local<Value>> resources_info;

  // Active requests
  for (ReqWrapBase* req_wrap : *env->req_wrap_queue()) {
    AsyncWrap* w = req_wrap->GetAsyncWrap();
    if (w->persistent().IsEmpty()) continue;
    resources_info.emplace_back(
        OneByteString(env->isolate(), w->MemoryInfoName()));
  }

  // Active handles
  for (HandleWrap* w : *env->handle_wrap_queue()) {
    if (w->persistent().IsEmpty() || !HandleWrap::HasRef(w)) continue;
    resources_info.emplace_back(
        OneByteString(env->isolate(), w->MemoryInfoName()));
  }

  // Active timeouts
  resources_info.insert(resources_info.end(),
                        env->timeout_info()[0],
                        OneByteString(env->isolate(), ""Timeout""));

  // Active immediates
  resources_info.insert(resources_info.end(),
                        env->immediate_info()->ref_count(),
                        OneByteString(env->isolate(), ""Immediate""));

  args....",77,,286,2,,void
217984,BLOCK,-1,,"{
    AsyncWrap* w = req_wrap->GetAsyncWrap();
    if (w->persistent().IsEmpty()) continue;
    resources_info.emplace_back(
        OneByteString(env->isolate(), w->MemoryInfoName()));
  }",56,,291,3,,void
218000,BLOCK,-1,,<empty>,36,,293,2,,void
218022,BLOCK,-1,,"{
    if (w->persistent().IsEmpty() || !HandleWrap::HasRef(w)) continue;
    resources_info.emplace_back(
        OneByteString(env->isolate(), w->MemoryInfoName()));
  }",51,,299,3,,void
218038,BLOCK,-1,,<empty>,62,,300,2,,void
218121,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  uv_rusage_t rusage;
  int err = uv_getrusage(&rusage);
  if (err)
    return env->ThrowUVException(err, ""uv_getrusage"");

  Local<ArrayBuffer> ab = get_fields_array_buffer(args, 0, 16);
  double* fields = static_cast<double*>(ab->Data());

  fields[0] = MICROS_PER_SEC * rusage.ru_utime.tv_sec + rusage.ru_utime.tv_usec;
  fields[1] = MICROS_PER_SEC * rusage.ru_stime.tv_sec + rusage.ru_stime.tv_usec;
  fields[2] = static_cast<double>(rusage.ru_maxrss);
  fields[3] = static_cast<double>(rusage.ru_ixrss);
  fields[4] = static_cast<double>(rusage.ru_idrss);
  fields[5] = static_cast<double>(rusage.ru_isrss);
  fields[6] = static_cast<double>(rusage.ru_minflt);
  fields[7] = static_cast<double>(rusage.ru_majflt);
  fields[8] = static_cast<double>(rusage.ru_nswap);
  fields[9] = static_cast<double>(rusage.ru_inblock);
  fields[10] = static_cast<double>(rusage.ru_oublock);
  fields[11] = static_cast<double>(rusage.ru_msgsnd);
  fields...",68,,319,2,,void
218139,BLOCK,-1,,<empty>,5,,325,2,,void
218173,BLOCK,1,,<empty>,,,,1,,void
218192,BLOCK,1,,<empty>,,,,1,,void
218334,BLOCK,-1,,"{
#if HAVE_INSPECTOR
  Environment* env = Environment::GetCurrent(args);
  if (env->inspector_agent()->IsListening()) {
    env->inspector_agent()->Stop();
  }
#endif
}",63,,447,2,,void
218339,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  RunAtExit(env);
  ExitCode code = ExitCode::kNoFailure;
  Maybe<int32_t> code_int = args[0]->Int32Value(env->context());
  if (!code_int.IsNothing()) {
    code = static_cast<ExitCode>(code_int.FromJust());
  }
  env->Exit(code);
}",65,,456,2,,void
218378,BLOCK,-1,,"{
    code = static_cast<ExitCode>(code_int.FromJust());
  }",30,,461,2,,void
218398,BLOCK,-1,,"{
  Isolate* isolate = realm->isolate();
  Local<Context> context = realm->context();
  Local<ArrayBuffer> ab = ArrayBuffer::New(isolate, kBufferSize);
  array_buffer_.Reset(isolate, ab);
  object->Set(context, FIXED_ONE_BYTE_STRING(isolate, ""hrtimeBuffer""), ab)
      .ToChecked();
  backing_store_ = ab->GetBackingStore();
}",51,,470,3,,void
218456,BLOCK,-1,,<empty>,,,,2,,<empty>
218461,BLOCK,-1,,<empty>,,,,2,,<empty>
218467,BLOCK,-1,,"{
  SetFastMethodNoSideEffect(
      isolate, target, ""hrtime"", SlowNumber, &fast_number_);
  SetFastMethodNoSideEffect(
      isolate, target, ""hrtimeBigInt"", SlowBigInt, &fast_bigint_);
}",78,,483,3,,void
218486,BLOCK,-1,,"{
  registry->Register(SlowNumber);
  registry->Register(SlowBigInt);
  registry->Register(FastNumber);
  registry->Register(FastBigInt);
  registry->Register(fast_number_.GetTypeInfo());
  registry->Register(fast_bigint_.GetTypeInfo());
}",42,,491,2,,void
218527,BLOCK,-1,,"{
  Local<Object> v8_object = value.As<Object>();
  return static_cast<BindingData*>(
      v8_object->GetAlignedPointerFromInternalField(BaseObject::kSlot));
}",59,,500,2,,void
218552,BLOCK,-1,,"{
  tracker->TrackField(""array_buffer"", array_buffer_);
}",60,,506,2,,void
218563,BLOCK,-1,,"{
  // Make sure we don't accidentally access buffers wiped for snapshot.
  CHECK(!receiver->array_buffer_.IsEmpty());
  uint64_t t = uv_hrtime();
  uint32_t* fields = static_cast<uint32_t*>(receiver->backing_store_->Data());
  fields[0] = (t / NANOS_PER_SEC) >> 32;
  fields[1] = (t / NANOS_PER_SEC) & 0xffffffff;
  fields[2] = t % NANOS_PER_SEC;
}",53,,519,2,,void
218595,BLOCK,1,,<empty>,,,,1,,void
218606,BLOCK,1,,<empty>,,,,1,,void
218616,BLOCK,1,,<empty>,,,,1,,void
218622,BLOCK,-1,,"{
  // Make sure we don't accidentally access buffers wiped for snapshot.
  CHECK(!receiver->array_buffer_.IsEmpty());
  uint64_t t = uv_hrtime();
  uint64_t* fields = static_cast<uint64_t*>(receiver->backing_store_->Data());
  fields[0] = t;
}",53,,529,2,,void
218655,BLOCK,-1,,"{
  BigIntImpl(FromJSObject<BindingData>(args.Holder()));
}",71,,537,2,,void
218669,BLOCK,-1,,"{
  NumberImpl(FromJSObject<BindingData>(args.Holder()));
}",79,,541,2,,void
218684,BLOCK,-1,,"{
  // It's not worth keeping.
  // Release it, we will recreate it when the instance is dehydrated.
  array_buffer_.Reset();
  // Return true because we need to maintain the reference to the binding from
  // JS land.
  return true;
}",73,,546,3,,void
218695,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info =
      InternalFieldInfoBase::New<InternalFieldInfo>(type());
  return info;
}",58,,555,2,,void
218720,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  v8::HandleScope scope(context->GetIsolate());
  Realm* realm = Realm::GetCurrent(context);
  // Recreate the buffer in the constructor.
  BindingData* binding = realm->AddBindingData<BindingData>(context, holder);
  CHECK_NOT_NULL(binding);
}",60,,565,5,,void
218760,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();
  Local<ObjectTemplate> target = ctor->InstanceTemplate();

  BindingData::AddMethods(isolate, target);
  // define various internal methods
  SetMethod(isolate, target, ""_debugProcess"", DebugProcess);
  SetMethod(isolate, target, ""abort"", Abort);
  SetMethod(isolate, target, ""causeSegfault"", CauseSegfault);
  SetMethod(isolate, target, ""chdir"", Chdir);

  SetMethod(isolate, target, ""umask"", Umask);
  SetMethod(isolate, target, ""memoryUsage"", MemoryUsage);
  SetMethod(isolate, target, ""constrainedMemory"", GetConstrainedMemory);
  SetMethod(isolate, target, ""rss"", Rss);
  SetMethod(isolate, target, ""cpuUsage"", CPUUsage);
  SetMethod(isolate, target, ""resourceUsage"", ResourceUsage);

  SetMethod(isolate, target, ""_debugEnd"", DebugEnd);
  SetMethod(isolate, target, ""_getActiveRequests"", GetActiveRequests);
  SetMethod(isolate, target, ""_getActiveHandles"", GetActiveHandles);
  SetMethod(isolate, target, ""getActiveResourcesInfo"", GetActiveR...",70,,575,3,,void
218898,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(context);
  realm->AddBindingData<BindingData>(context, target);
}",52,,610,5,,void
218921,BLOCK,-1,,"{
  BindingData::RegisterExternalReferences(registry);

  registry->Register(DebugProcess);
  registry->Register(DebugEnd);
  registry->Register(Abort);
  registry->Register(CauseSegfault);
  registry->Register(Chdir);

  registry->Register(Umask);
  registry->Register(RawDebug);
  registry->Register(MemoryUsage);
  registry->Register(GetConstrainedMemory);
  registry->Register(Rss);
  registry->Register(CPUUsage);
  registry->Register(ResourceUsage);

  registry->Register(GetActiveRequests);
  registry->Register(GetActiveHandles);
  registry->Register(GetActiveResourcesInfo);
  registry->Register(Kill);

  registry->Register(Cwd);
  registry->Register(binding::DLOpen);
  registry->Register(ReallyExit);
  registry->Register(Uptime);
  registry->Register(PatchProcessObject);
}",70,,615,2,,void
219041,BLOCK,-1,,{ return a.first < b.first; },34,,129,3,,void
219078,BLOCK,-1,,<empty>,1,,1,1,,ANY
219083,BLOCK,-1,,"{
  std::string title = GetProcessTitle(""node"");
  info.GetReturnValue().Set(
      String::NewFromUtf8(info.GetIsolate(), title.data(),
                          NewStringType::kNormal, title.size())
      .ToLocalChecked());
}",73,,35,3,,void
219124,BLOCK,-1,,"{
  node::Utf8Value title(info.GetIsolate(), value);
  TRACE_EVENT_METADATA1(
      ""__metadata"", ""process_name"", ""name"", TRACE_STR_COPY(*title));
  uv_set_process_title(*title);
}",72,,45,4,,void
219147,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  ExclusiveAccess<HostPort>::Scoped host_port(env->inspector_host_port());
  int port = host_port->port();
  info.GetReturnValue().Set(port);
}",70,,53,3,,void
219183,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  int32_t port = value->Int32Value(env->context()).FromMaybe(0);

  if ((port != 0 && port < 1024) || port > 65535) {
    return THROW_ERR_OUT_OF_RANGE(
      env,
      ""process.debugPort must be 0 or in range 1024 to 65535"");
  }

  ExclusiveAccess<HostPort>::Scoped host_port(env->inspector_host_port());
  host_port->set_port(static_cast<int>(port));
}",69,,62,4,,void
219219,BLOCK,-1,,"{
    return THROW_ERR_OUT_OF_RANGE(
      env,
      ""process.debugPort must be 0 or in range 1024 to 65535"");
  }",51,,66,2,,void
219242,BLOCK,-1,,"{
  info.GetReturnValue().Set(uv_os_getppid());
}",73,,77,3,,void
219255,BLOCK,-1,,"{
  Isolate* isolate = realm->isolate();
  EscapableHandleScope scope(isolate);
  Local<Context> context = realm->context();

  Local<FunctionTemplate> process_template = FunctionTemplate::New(isolate);
  process_template->SetClassName(realm->env()->process_string());
  Local<Function> process_ctor;
  Local<Object> process;
  if (!process_template->GetFunction(context).ToLocal(&process_ctor) ||
      !process_ctor->NewInstance(context).ToLocal(&process)) {
    return MaybeLocal<Object>();
  }

  // process[exit_info_private_symbol]
  if (process
          ->SetPrivate(context,
                       realm->env()->exit_info_private_symbol(),
                       realm->env()->exit_info().GetJSArray())
          .IsNothing()) {
    return {};
  }

  // process.version
  READONLY_PROPERTY(
      process, ""version"", FIXED_ONE_BYTE_STRING(isolate, NODE_VERSION));

  Local<Object> versions = Object::New(isolate);
  // Node.js version is always on the top
  READONLY_STRING_PROPERTY(
    ...",54,,81,2,,void
219332,BLOCK,-1,,"{
    return MaybeLocal<Object>();
  }",62,,91,2,,void
219361,BLOCK,-1,,"{
    return {};
  }",25,,100,2,,void
219432,BLOCK,-1,,"{
    versions
        ->DefineOwnProperty(
            context,
            OneByteString(isolate, version.first.data(), version.first.size()),
            OneByteString(
                isolate, version.second.data(), version.second.size()),
            v8::ReadOnly)
        .Check();
  }",46,,131,3,,void
219532,BLOCK,-1,,"{
  Isolate* isolate = args.GetIsolate();
  Local<Context> context = isolate->GetCurrentContext();
  Environment* env = Environment::GetCurrent(context);
  CHECK(args[0]->IsObject());
  Local<Object> process = args[0].As<Object>();

  // process.title
  CHECK(process
            ->SetAccessor(
                context,
                FIXED_ONE_BYTE_STRING(isolate, ""title""),
                ProcessTitleGetter,
                env->owns_process_state() ? ProcessTitleSetter : nullptr,
                Local<Value>(),
                DEFAULT,
                None,
                SideEffectType::kHasNoSideEffect)
            .FromJust());

  // process.argv
  process->Set(context,
               FIXED_ONE_BYTE_STRING(isolate, ""argv""),
               ToV8Value(context, env->argv()).ToLocalChecked()).Check();

  // process.execArgv
  process->Set(context,
               FIXED_ONE_BYTE_STRING(isolate, ""execArgv""),
               ToV8Value(context, env->exec_argv())
                   .ToLoc...",66,,177,2,,void
219728,BLOCK,-1,,"{
  registry->Register(RawDebug);
  registry->Register(GetParentProcessId);
  registry->Register(DebugPortSetter);
  registry->Register(DebugPortGetter);
  registry->Register(ProcessTitleSetter);
  registry->Register(ProcessTitleGetter);
}",77,,246,2,,void
219770,BLOCK,-1,,<empty>,1,,1,1,,ANY
219774,BLOCK,-1,,"{
    std::cout << ""#"" << i++ << "" "" << obj << "": "" << obj->MemoryInfoName()
              << ""\n"";
  }",42,,224,2,,void
219803,BLOCK,-1,,"{
    if (obj->IsNotIndicativeOfMemoryLeakAtExit()) return;
    fprintf(stderr,
            ""Found bad BaseObject during clean exit: %s\n"",
            obj->MemoryInfoName());
    fflush(stderr);
    ABORT();
  }",41,,267,2,,void
219809,BLOCK,-1,,<empty>,51,,268,2,,void
219837,BLOCK,-1,,<empty>,1,,1,1,,ANY
219843,BLOCK,-1,,"{
  context_.Reset(isolate_, context);
}",63,,22,4,,void
219853,BLOCK,-1,,"{
  CHECK_EQ(base_object_count_, 0);
}",17,,26,1,,void
219861,BLOCK,-1,,"{
#define V(PropertyName, TypeName)                                              \
  tracker->TrackField(#PropertyName, PropertyName());
  PER_REALM_STRONG_PERSISTENT_VALUES(V)
#undef V

  tracker->TrackField(""cleanup_queue"", cleanup_queue_);
  tracker->TrackField(""builtins_with_cache"", builtins_with_cache);
  tracker->TrackField(""builtins_without_cache"", builtins_without_cache);
}",54,,30,2,,void
219885,BLOCK,-1,,"{
  HandleScope handle_scope(isolate_);
  Local<Context> ctx = context();

  // Store primordials setup by the per-context script in the environment.
  Local<Object> per_context_bindings =
      GetPerContextExports(ctx).ToLocalChecked();
  Local<Value> primordials =
      per_context_bindings->Get(ctx, env_->primordials_string())
          .ToLocalChecked();
  CHECK(primordials->IsObject());
  set_primordials(primordials.As<Object>());

  Local<String> prototype_string =
      FIXED_ONE_BYTE_STRING(isolate(), ""prototype"");

#define V(EnvPropertyName, PrimordialsPropertyName)                            \
  {                                                                            \
    Local<Value> ctor =                                                        \
        primordials.As<Object>()                                               \
            ->Get(ctx,                                                         \
                  FIXED_ONE_BYTE_STRING(isolate(), Primordial...",32,,41,1,,void
219946,BLOCK,1,,"V(primordials_safe_map_prototype_object, ""SafeMap"")",3,,71,9,,void
220002,BLOCK,1,,"V(primordials_safe_set_prototype_object, ""SafeSet"")",3,,72,10,,void
220058,BLOCK,1,,"V(primordials_safe_weak_map_prototype_object, ""SafeWeakMap"")",3,,73,11,,void
220114,BLOCK,1,,"V(primordials_safe_weak_set_prototype_object, ""SafeWeakSet"")",3,,74,12,,void
220188,BLOCK,-1,,"{
  RealmSerializeInfo info;
  Local<Context> ctx = context();

  // Currently all modules are compiled without cache in builtin snapshot
  // builder.
  info.builtins = std::vector<std::string>(builtins_without_cache.begin(),
                                           builtins_without_cache.end());

  uint32_t id = 0;
#define V(PropertyName, TypeName)                                              \
  do {                                                                         \
    Local<TypeName> field = PropertyName();                                    \
    if (!field.IsEmpty()) {                                                    \
      size_t index = creator->AddData(ctx, field);                             \
      info.persistent_values.push_back({#PropertyName, id, index});            \
    }                                                                          \
    id++;                                                                      \
  } while (0);
  PER_REALM_S...",63,,85,2,,void
220246,BLOCK,-1,,"{
  Local<Context> ctx = context();

  builtins_in_snapshot = info->builtins;

  const std::vector<PropInfo>& values = info->persistent_values;
  size_t i = 0;  // index to the array
  uint32_t id = 0;
#define V(PropertyName, TypeName)                                              \
  do {                                                                         \
    if (values.size() > i && id == values[i].id) {                             \
      const PropInfo& d = values[i];                                           \
      DCHECK_EQ(d.name, #PropertyName);                                        \
      MaybeLocal<TypeName> maybe_field =                                       \
          ctx->GetDataFromSnapshotOnce<TypeName>(d.index);                     \
      Local<TypeName> field;                                                   \
      if (!maybe_field.ToLocal(&field)) {                                      \
        fprintf(stderr,                                           ...",67,,115,2,,void
220302,BLOCK,-1,,"{
    fprintf(stderr,
            ""Failed to deserialize context back reference from the snapshot\n"");
  }",61,,147,2,,void
220314,BLOCK,-1,,"{
  EscapableHandleScope scope(isolate());
  Local<Context> ctx = context();
  MaybeLocal<Value> result =
      env()->builtin_loader()->CompileAndCall(ctx, id, this);

  // If there was an error during bootstrap, it must be unrecoverable
  // (e.g. max call stack exceeded). Clear the stack so that the
  // AsyncCallbackScope destructor doesn't fail on the id check.
  // There are only two ways to have a stack size > 1: 1) the user manually
  // called MakeCallback or 2) user awaited during bootstrap, which triggered
  // _tickCallback().
  if (result.IsEmpty()) {
    env()->async_hooks()->clear_async_id_stack();
  }

  return scope.EscapeMaybe(result);
}",62,,156,2,,void
220346,BLOCK,-1,,"{
    env()->async_hooks()->clear_async_id_stack();
  }",25,,168,2,,void
220363,BLOCK,-1,,"{
  EscapableHandleScope scope(isolate_);

  CHECK(!has_run_bootstrapping_code());

  Local<Value> result;
  if (!ExecuteBootstrapper(""internal/bootstrap/realm"").ToLocal(&result) ||
      !BootstrapRealm().ToLocal(&result)) {
    return MaybeLocal<Value>();
  }

  DoneBootstrapping();

  return scope.Escape(result);
}",45,,175,1,,void
220392,BLOCK,-1,,"{
    return MaybeLocal<Value>();
  }",43,,182,2,,void
220405,BLOCK,-1,,"{
  // Make sure that no request or handle is created during bootstrap -
  // if necessary those should be done in pre-execution.
  // Usually, doing so would trigger the checks present in the ReqWrap and
  // HandleWrap classes, so this is only a consistency check.

  // TODO(legendecas): track req_wrap and handle_wrap by realms instead of
  // environments.
  if (kind_ == kPrincipal) {
    CHECK(env_->req_wrap_queue()->IsEmpty());
    CHECK(env_->handle_wrap_queue()->IsEmpty());
  }

  has_run_bootstrapping_code_ = true;

  // This adjusts the return value of base_object_created_after_bootstrap() so
  // that tests that check the count do not have to account for internally
  // created BaseObjects.
  base_object_created_by_bootstrap_ = base_object_count_;
}",33,,191,1,,void
220410,BLOCK,-1,,"{
    CHECK(env_->req_wrap_queue()->IsEmpty());
    CHECK(env_->handle_wrap_queue()->IsEmpty());
  }",28,,199,2,,void
220436,BLOCK,-1,,"{
  TRACE_EVENT0(TRACING_CATEGORY_NODE1(realm), ""RunCleanup"");
  for (size_t i = 0; i < binding_data_store_.size(); ++i) {
    binding_data_store_[i].reset();
  }
  cleanup_queue_.Drain();
}",26,,212,1,,void
220442,BLOCK,-1,,<empty>,3,,214,1,,void
220455,BLOCK,4,,"{
    binding_data_store_[i].reset();
  }",59,,214,4,,void
220469,BLOCK,-1,,"{
  fprintf(stderr, ""Realm = %p\n"", this);
  fprintf(stderr, ""BaseObjects of the Realm:\n"");
  size_t i = 0;
  ForEachBaseObject([&](BaseObject* obj) {
    std::cout << ""#"" << i++ << "" "" << obj << "": "" << obj->MemoryInfoName()
              << ""\n"";
  });

  fprintf(stderr, ""\nBuiltins without cache:\n"");
  for (const auto& s : builtins_without_cache) {
    fprintf(stderr, ""%s\n"", s.c_str());
  }
  fprintf(stderr, ""\nBuiltins with cache:\n"");
  for (const auto& s : builtins_with_cache) {
    fprintf(stderr, ""%s\n"", s.c_str());
  }
  fprintf(stderr, ""\nStatic bindings (need to be registered):\n"");
  for (const auto mod : internal_bindings) {
    fprintf(stderr, ""%s:%s\n"", mod->nm_filename, mod->nm_modname);
  }

  fprintf(stderr, ""End of the Realm.\n"");
}",36,,220,1,,void
220488,BLOCK,-1,,"{
    fprintf(stderr, ""%s\n"", s.c_str());
  }",48,,230,3,,void
220502,BLOCK,-1,,"{
    fprintf(stderr, ""%s\n"", s.c_str());
  }",45,,234,3,,void
220516,BLOCK,-1,,"{
    fprintf(stderr, ""%s:%s\n"", mod->nm_filename, mod->nm_modname);
  }",44,,238,3,,void
220532,BLOCK,-1,,"{
  // When a process exits cleanly, i.e. because the event loop ends up without
  // things to wait for, the Node.js objects that are left on the heap should
  // be:
  //
  //   1. weak, i.e. ready for garbage collection once no longer referenced, or
  //   2. detached, i.e. scheduled for destruction once no longer referenced, or
  //   3. an unrefed libuv handle, i.e. does not keep the event loop alive, or
  //   4. an inactive libuv handle (essentially the same here)
  //
  // There are a few exceptions to this rule, but generally, if there are
  // C++-backed Node.js objects on the heap that do not fall into the above
  // categories, we may be looking at a potential memory leak. Most likely,
  // the cause is a missing MakeWeak() call on the corresponding object.
  //
  // In order to avoid this kind of problem, we check the list of BaseObjects
  // for these criteria. Currently, we only do so when explicitly instructed to
  // or when in debug mode (where --verify-base-object...",41,,245,1,,void
220541,BLOCK,-1,,<empty>,47,,265,2,,void
220548,BLOCK,-1,,"{
  return PersistentToLocal::Strong(context_);
}",47,,277,1,,void
220563,BLOCK,-1,,"{
  // Create properties if not deserializing from snapshot.
  // Or the properties are deserialized with DeserializeProperties() when the
  // env drained the deserialize requests.
  if (realm_info == nullptr) {
    CreateProperties();
  }
}",39,,294,4,,void
220568,BLOCK,-1,,"{
    CreateProperties();
  }",30,,298,2,,void
220573,BLOCK,-1,,"{
  HandleScope scope(isolate_);

  if (ExecuteBootstrapper(""internal/bootstrap/node"").IsEmpty()) {
    return MaybeLocal<Value>();
  }

  if (!env_->no_browser_globals()) {
    if (ExecuteBootstrapper(""internal/bootstrap/web/exposed-wildcard"")
            .IsEmpty() ||
        ExecuteBootstrapper(""internal/bootstrap/web/exposed-window-or-worker"")
            .IsEmpty()) {
      return MaybeLocal<Value>();
    }
  }

  // TODO(joyeecheung): skip these in the snapshot building for workers.
  auto thread_switch_id =
      env_->is_main_thread() ? ""internal/bootstrap/switches/is_main_thread""
                             : ""internal/bootstrap/switches/is_not_main_thread"";
  if (ExecuteBootstrapper(thread_switch_id).IsEmpty()) {
    return MaybeLocal<Value>();
  }

  auto process_state_switch_id =
      env_->owns_process_state()
          ? ""internal/bootstrap/switches/does_own_process_state""
          : ""internal/bootstrap/switches/does_not_own_process_state"";
  if (ExecuteBootstrapper...",52,,303,1,,void
220583,BLOCK,-1,,"{
    return MaybeLocal<Value>();
  }",65,,306,2,,void
220592,BLOCK,-1,,"{
    if (ExecuteBootstrapper(""internal/bootstrap/web/exposed-wildcard"")
            .IsEmpty() ||
        ExecuteBootstrapper(""internal/bootstrap/web/exposed-window-or-worker"")
            .IsEmpty()) {
      return MaybeLocal<Value>();
    }
  }",36,,310,2,,void
220605,BLOCK,-1,,"{
      return MaybeLocal<Value>();
    }",25,,314,2,,void
220624,BLOCK,-1,,"{
    return MaybeLocal<Value>();
  }",56,,323,2,,void
220643,BLOCK,-1,,"{
    return MaybeLocal<Value>();
  }",63,,331,2,,void
220692,BLOCK,-1,,"{
    return MaybeLocal<Value>();
  }",76,,339,2,,void
220719,BLOCK,-1,,<empty>,1,,1,1,,ANY
220723,BLOCK,-1,,"{
        std::ostringstream os;

        GetNodeReport(
            env, ""Worker thread subreport"", trigger, Local<Value>(), os);

        Mutex::ScopedLock lock(workers_mutex);
        worker_infos.emplace_back(os.str());
        notify.Signal(lock);
      }",69,,222,2,,void
220757,BLOCK,-1,,"{
      expected_results += w->RequestInterrupt([&](Environment* env) {
        std::ostringstream os;

        GetNodeReport(
            env, ""Worker thread subreport"", trigger, Local<Value>(), os);

        Mutex::ScopedLock lock(workers_mutex);
        worker_infos.emplace_back(os.str());
        notify.Signal(lock);
      });
    }",39,,221,2,,void
220771,BLOCK,-1,,"{
                return !std::iswspace(ch);
              }",70,,532,2,,void
220785,BLOCK,-1,,{ return a.first < b.first; },34,,811,3,,void
220837,BLOCK,-1,,<empty>,1,,1,1,,ANY
220869,BLOCK,-1,,<empty>,,,,9,,<empty>
220874,BLOCK,-1,,<empty>,,,,2,,<empty>
220882,BLOCK,-1,,<empty>,,,,5,,<empty>
220889,BLOCK,-1,,<empty>,,,,4,,<empty>
220896,BLOCK,-1,,<empty>,,,,4,,<empty>
220901,BLOCK,-1,,<empty>,,,,2,,<empty>
220906,BLOCK,-1,,<empty>,,,,2,,<empty>
220912,BLOCK,-1,,<empty>,,,,3,,<empty>
220917,BLOCK,-1,,<empty>,,,,2,,<empty>
220922,BLOCK,-1,,<empty>,,,,2,,<empty>
220927,BLOCK,-1,,<empty>,,,,2,,<empty>
220932,BLOCK,-1,,<empty>,,,,2,,<empty>
220937,BLOCK,-1,,<empty>,,,,2,,<empty>
220942,BLOCK,-1,,<empty>,,,,2,,<empty>
220952,BLOCK,-1,,"{
  // Obtain the current time and the pid.
  TIME_TYPE tm_struct;
  DiagnosticFilename::LocalTime(&tm_struct);
  uv_pid_t pid = uv_os_getpid();

  // Save formatting for output stream.
  std::ios old_state(nullptr);
  old_state.copyfmt(out);

  // File stream opened OK, now start printing the report content:
  // the title and header information (event, filename, timestamp and pid)

  JSONWriter writer(out, compact);
  writer.json_start();
  writer.json_objectstart(""header"");
  writer.json_keyvalue(""reportVersion"", NODE_REPORT_VERSION);
  writer.json_keyvalue(""event"", message);
  writer.json_keyvalue(""trigger"", trigger);
  if (!filename.empty())
    writer.json_keyvalue(""filename"", filename);
  else
    writer.json_keyvalue(""filename"", JSONWriter::Null{});

  // Report dump event and module load date/time stamps
  char timebuf[64];
#ifdef _WIN32
  snprintf(timebuf,
           sizeof(timebuf),
           ""%4d-%02d-%02dT%02d:%02d:%02dZ"",
           tm_struct.wYear,
           tm_stru...",43,,94,9,,void
221009,BLOCK,-1,,<empty>,5,,114,2,,void
221017,BLOCK,-1,,<empty>,5,,116,1,,void
221066,BLOCK,-1,,"{
    writer.json_keyvalue(""dumpEventTimeStamp"",
                         std::to_string(ts.tv_sec * 1000 + ts.tv_usec / 1000));
  }",34,,145,2,,void
221097,BLOCK,-1,,<empty>,5,,153,2,,void
221108,BLOCK,-1,,<empty>,5,,155,1,,void
221116,BLOCK,23,,"{
    // Report the process cwd.
    char buf[PATH_MAX_BYTES];
    size_t cwd_size = sizeof(buf);
    if (uv_cwd(buf, &cwd_size) == 0)
      writer.json_keyvalue(""cwd"", buf);
  }",3,,157,23,,void
221130,BLOCK,-1,,<empty>,7,,162,2,,void
221147,BLOCK,-1,,"{
    writer.json_arraystart(""commandLine"");
    for (const std::string& arg : per_process::cli_options->cmdline) {
      writer.json_element(arg);
    }
    writer.json_arrayend();
  }",51,,166,2,,void
221160,BLOCK,-1,,"{
      writer.json_element(arg);
    }",70,,168,3,,void
221181,BLOCK,-1,,"{
    writer.json_objectstart(""javascriptStack"");
    // Report summary JavaScript error stack backtrace
    PrintJavaScriptErrorStack(&writer, isolate, error, trigger);

    writer.json_objectend();  // the end of 'javascriptStack'

    // Report V8 Heap and Garbage Collector information
    PrintGCStatistics(&writer, isolate);
  }",27,,178,2,,void
221216,BLOCK,-1,,"{
    uv_walk(env->event_loop(), WalkHandle, static_cast<void*>(&writer));

    writer.json_start();
    writer.json_keyvalue(""type"", ""loop"");
    writer.json_keyvalue(""is_active"",
        static_cast<bool>(uv_loop_alive(env->event_loop())));
    writer.json_keyvalue(""address"",
        ValueToHexString(reinterpret_cast<int64_t>(env->event_loop())));

    // Report Event loop idle time
    uint64_t idle_time = uv_metrics_idle_time(env->event_loop());
    writer.json_keyvalue(""loopIdleTimeSeconds"", 1.0 * idle_time / 1e9);
    writer.json_end();
  }",23,,196,2,,void
221296,BLOCK,-1,,"{
    Mutex workers_mutex;
    ConditionVariable notify;
    std::vector<std::string> worker_infos;
    size_t expected_results = 0;

    env->ForEachWorker([&](Worker* w) {
      expected_results += w->RequestInterrupt([&](Environment* env) {
        std::ostringstream os;

        GetNodeReport(
            env, ""Worker thread subreport"", trigger, Local<Value>(), os);

        Mutex::ScopedLock lock(workers_mutex);
        worker_infos.emplace_back(os.str());
        notify.Signal(lock);
      });
    });

    Mutex::ScopedLock lock(workers_mutex);
    worker_infos.reserve(expected_results);
    while (worker_infos.size() < expected_results)
      notify.Wait(lock);
    for (const std::string& worker_info : worker_infos)
      writer.json_element(JSONWriter::ForeignJSON { worker_info });
  }",23,,215,2,,void
221364,BLOCK,-1,,"{
  std::ostringstream buf;
  // Report Node version
  buf << ""v"" << NODE_VERSION_STRING;
  writer->json_keyvalue(""nodejsVersion"", buf.str());
  buf.str("""");

#ifndef _WIN32
  // Report compiler and runtime glibc versions where possible.
  const char* (*libc_version)();
  *(reinterpret_cast<void**>(&libc_version)) =
      dlsym(RTLD_DEFAULT, ""gnu_get_libc_version"");
  if (libc_version != nullptr)
    writer->json_keyvalue(""glibcVersionRuntime"", (*libc_version)());
#endif /* _WIN32 */

#ifdef __GLIBC__
  buf << __GLIBC__ << ""."" << __GLIBC_MINOR__;
  writer->json_keyvalue(""glibcVersionCompiler"", buf.str());
  buf.str("""");
#endif

  // Report Process word size
  writer->json_keyvalue(""wordSize"", sizeof(void*) * 8);
  writer->json_keyvalue(""arch"", per_process::metadata.arch);
  writer->json_keyvalue(""platform"", per_process::metadata.platform);

  // Report deps component versions
  PrintComponentVersions(writer);

  // Report release metadata.
  PrintRelease(writer);

  // Report operat...",57,,253,2,,void
221386,BLOCK,-1,,<empty>,,,,1,,<empty>
221402,BLOCK,-1,,<empty>,5,,266,2,,void
221451,BLOCK,-1,,"{
    writer->json_keyvalue(""osName"", os_info.sysname);
    writer->json_keyvalue(""osRelease"", os_info.release);
    writer->json_keyvalue(""osVersion"", os_info.version);
    writer->json_keyvalue(""osMachine"", os_info.machine);
  }",35,,289,2,,void
221501,BLOCK,-1,,<empty>,5,,303,2,,void
221512,BLOCK,-1,,"{
  uv_cpu_info_t* cpu_info;
  int count;
  if (uv_cpu_info(&cpu_info, &count) == 0) {
    writer->json_arraystart(""cpus"");
    for (int i = 0; i < count; i++) {
      writer->json_start();
      writer->json_keyvalue(""model"", cpu_info[i].model);
      writer->json_keyvalue(""speed"", cpu_info[i].speed);
      writer->json_keyvalue(""user"", cpu_info[i].cpu_times.user);
      writer->json_keyvalue(""nice"", cpu_info[i].cpu_times.nice);
      writer->json_keyvalue(""sys"", cpu_info[i].cpu_times.sys);
      writer->json_keyvalue(""idle"", cpu_info[i].cpu_times.idle);
      writer->json_keyvalue(""irq"", cpu_info[i].cpu_times.irq);
      writer->json_end();
    }
    writer->json_arrayend();
    uv_free_cpu_info(cpu_info, count);
  }
}",46,,307,2,,void
221523,BLOCK,-1,,"{
    writer->json_arraystart(""cpus"");
    for (int i = 0; i < count; i++) {
      writer->json_start();
      writer->json_keyvalue(""model"", cpu_info[i].model);
      writer->json_keyvalue(""speed"", cpu_info[i].speed);
      writer->json_keyvalue(""user"", cpu_info[i].cpu_times.user);
      writer->json_keyvalue(""nice"", cpu_info[i].cpu_times.nice);
      writer->json_keyvalue(""sys"", cpu_info[i].cpu_times.sys);
      writer->json_keyvalue(""idle"", cpu_info[i].cpu_times.idle);
      writer->json_keyvalue(""irq"", cpu_info[i].cpu_times.irq);
      writer->json_end();
    }
    writer->json_arrayend();
    uv_free_cpu_info(cpu_info, count);
  }",44,,310,2,,void
221530,BLOCK,-1,,<empty>,5,,312,1,,void
221540,BLOCK,4,,"{
      writer->json_start();
      writer->json_keyvalue(""model"", cpu_info[i].model);
      writer->json_keyvalue(""speed"", cpu_info[i].speed);
      writer->json_keyvalue(""user"", cpu_info[i].cpu_times.user);
      writer->json_keyvalue(""nice"", cpu_info[i].cpu_times.nice);
      writer->json_keyvalue(""sys"", cpu_info[i].cpu_times.sys);
      writer->json_keyvalue(""idle"", cpu_info[i].cpu_times.idle);
      writer->json_keyvalue(""irq"", cpu_info[i].cpu_times.irq);
      writer->json_end();
    }",37,,312,4,,void
221640,BLOCK,-1,,"{
  uv_interface_address_t* interfaces;
  char ip[INET6_ADDRSTRLEN];
  char netmask[INET6_ADDRSTRLEN];
  char mac[18];
  int count;

  if (uv_interface_addresses(&interfaces, &count) == 0) {
    writer->json_arraystart(""networkInterfaces"");

    for (int i = 0; i < count; i++) {
      writer->json_start();
      writer->json_keyvalue(""name"", interfaces[i].name);
      writer->json_keyvalue(""internal"", !!interfaces[i].is_internal);
      snprintf(mac,
               sizeof(mac),
               ""%02x:%02x:%02x:%02x:%02x:%02x"",
               static_cast<unsigned char>(interfaces[i].phys_addr[0]),
               static_cast<unsigned char>(interfaces[i].phys_addr[1]),
               static_cast<unsigned char>(interfaces[i].phys_addr[2]),
               static_cast<unsigned char>(interfaces[i].phys_addr[3]),
               static_cast<unsigned char>(interfaces[i].phys_addr[4]),
               static_cast<unsigned char>(interfaces[i].phys_addr[5]));
      writer->json_keyvalue(""mac"", mac)...",59,,328,2,,void
221654,BLOCK,-1,,"{
    writer->json_arraystart(""networkInterfaces"");

    for (int i = 0; i < count; i++) {
      writer->json_start();
      writer->json_keyvalue(""name"", interfaces[i].name);
      writer->json_keyvalue(""internal"", !!interfaces[i].is_internal);
      snprintf(mac,
               sizeof(mac),
               ""%02x:%02x:%02x:%02x:%02x:%02x"",
               static_cast<unsigned char>(interfaces[i].phys_addr[0]),
               static_cast<unsigned char>(interfaces[i].phys_addr[1]),
               static_cast<unsigned char>(interfaces[i].phys_addr[2]),
               static_cast<unsigned char>(interfaces[i].phys_addr[3]),
               static_cast<unsigned char>(interfaces[i].phys_addr[4]),
               static_cast<unsigned char>(interfaces[i].phys_addr[5]));
      writer->json_keyvalue(""mac"", mac);

      if (interfaces[i].address.address4.sin_family == AF_INET) {
        uv_ip4_name(&interfaces[i].address.address4, ip, sizeof(ip));
        uv_ip4_name(&interfaces[i].netmask.netmask...",57,,335,2,,void
221661,BLOCK,-1,,<empty>,5,,338,1,,void
221671,BLOCK,4,,"{
      writer->json_start();
      writer->json_keyvalue(""name"", interfaces[i].name);
      writer->json_keyvalue(""internal"", !!interfaces[i].is_internal);
      snprintf(mac,
               sizeof(mac),
               ""%02x:%02x:%02x:%02x:%02x:%02x"",
               static_cast<unsigned char>(interfaces[i].phys_addr[0]),
               static_cast<unsigned char>(interfaces[i].phys_addr[1]),
               static_cast<unsigned char>(interfaces[i].phys_addr[2]),
               static_cast<unsigned char>(interfaces[i].phys_addr[3]),
               static_cast<unsigned char>(interfaces[i].phys_addr[4]),
               static_cast<unsigned char>(interfaces[i].phys_addr[5]));
      writer->json_keyvalue(""mac"", mac);

      if (interfaces[i].address.address4.sin_family == AF_INET) {
        uv_ip4_name(&interfaces[i].address.address4, ip, sizeof(ip));
        uv_ip4_name(&interfaces[i].netmask.netmask4, netmask, sizeof(netmask));
        writer->json_keyvalue(""address"", ip);
        write...",37,,338,4,,void
221775,BLOCK,-1,,"{
        uv_ip4_name(&interfaces[i].address.address4, ip, sizeof(ip));
        uv_ip4_name(&interfaces[i].netmask.netmask4, netmask, sizeof(netmask));
        writer->json_keyvalue(""address"", ip);
        writer->json_keyvalue(""netmask"", netmask);
        writer->json_keyvalue(""family"", ""IPv4"");
      }",65,,353,2,,void
221819,BLOCK,-1,,<empty>,14,,359,1,,void
221832,BLOCK,-1,,"{
        uv_ip6_name(&interfaces[i].address.address6, ip, sizeof(ip));
        uv_ip6_name(&interfaces[i].netmask.netmask6, netmask, sizeof(netmask));
        writer->json_keyvalue(""address"", ip);
        writer->json_keyvalue(""netmask"", netmask);
        writer->json_keyvalue(""family"", ""IPv6"");
        writer->json_keyvalue(""scopeid"",
                              interfaces[i].address.address6.sin6_scope_id);
      }",73,,359,2,,void
221890,BLOCK,-1,,"{
        writer->json_keyvalue(""family"", ""unknown"");
      }",14,,367,1,,void
221914,BLOCK,-1,,"{
  writer->json_objectstart(""errorProperties"");
  if (!error.IsEmpty() && error->IsObject()) {
    TryCatch try_catch(isolate);
    Local<Object> error_obj = error.As<Object>();
    Local<Context> context = error_obj->GetIsolate()->GetCurrentContext();
    Local<Array> keys;
    if (!error_obj->GetOwnPropertyNames(context).ToLocal(&keys)) {
      return writer->json_objectend();  // the end of 'errorProperties'
    }
    uint32_t keys_length = keys->Length();
    for (uint32_t i = 0; i < keys_length; i++) {
      Local<Value> key;
      if (!keys->Get(context, i).ToLocal(&key) || !key->IsString()) {
        continue;
      }
      Local<Value> value;
      Local<String> value_string;
      if (!error_obj->Get(context, key).ToLocal(&value) ||
          !value->ToString(context).ToLocal(&value_string)) {
        continue;
      }
      node::Utf8Value k(isolate, key);
      if (k == ""stack"" || k == ""message"") continue;
      node::Utf8Value v(isolate, value_string);
      writer->jso...",64,,381,4,,void
221931,BLOCK,-1,,"{
    TryCatch try_catch(isolate);
    Local<Object> error_obj = error.As<Object>();
    Local<Context> context = error_obj->GetIsolate()->GetCurrentContext();
    Local<Array> keys;
    if (!error_obj->GetOwnPropertyNames(context).ToLocal(&keys)) {
      return writer->json_objectend();  // the end of 'errorProperties'
    }
    uint32_t keys_length = keys->Length();
    for (uint32_t i = 0; i < keys_length; i++) {
      Local<Value> key;
      if (!keys->Get(context, i).ToLocal(&key) || !key->IsString()) {
        continue;
      }
      Local<Value> value;
      Local<String> value_string;
      if (!error_obj->Get(context, key).ToLocal(&value) ||
          !value->ToString(context).ToLocal(&value_string)) {
        continue;
      }
      node::Utf8Value k(isolate, key);
      if (k == ""stack"" || k == ""message"") continue;
      node::Utf8Value v(isolate, value_string);
      writer->json_keyvalue(k.ToStringView(), v.ToStringView());
    }
  }",46,,383,2,,void
221975,BLOCK,-1,,"{
      return writer->json_objectend();  // the end of 'errorProperties'
    }",66,,388,2,,void
221989,BLOCK,-1,,<empty>,5,,392,1,,void
221999,BLOCK,4,,"{
      Local<Value> key;
      if (!keys->Get(context, i).ToLocal(&key) || !key->IsString()) {
        continue;
      }
      Local<Value> value;
      Local<String> value_string;
      if (!error_obj->Get(context, key).ToLocal(&value) ||
          !value->ToString(context).ToLocal(&value_string)) {
        continue;
      }
      node::Utf8Value k(isolate, key);
      if (k == ""stack"" || k == ""message"") continue;
      node::Utf8Value v(isolate, value_string);
      writer->json_keyvalue(k.ToStringView(), v.ToStringView());
    }",48,,392,4,,void
222024,BLOCK,-1,,"{
        continue;
      }",69,,394,2,,void
222061,BLOCK,-1,,"{
        continue;
      }",61,,400,2,,void
222075,BLOCK,-1,,<empty>,43,,404,2,,void
222103,BLOCK,-1,,"{
  if (error.IsEmpty()) {
    return Nothing<std::string>();
  }

  MaybeLocal<String> maybe_str;
  // `ToString` is not available to Symbols.
  if (error->IsSymbol()) {
    maybe_str = error.As<v8::Symbol>()->ToDetailString(context);
  } else if (!error->IsObject()) {
    maybe_str = error->ToString(context);
  } else if (error->IsObject()) {
    MaybeLocal<Value> stack = error.As<Object>()->Get(
        context, FIXED_ONE_BYTE_STRING(isolate, ""stack""));
    if (!stack.IsEmpty() && stack.ToLocalChecked()->IsString()) {
      maybe_str = stack.ToLocalChecked().As<String>();
    }
  }

  Local<String> js_str;
  if (!maybe_str.ToLocal(&js_str)) {
    return Nothing<std::string>();
  }
  String::Utf8Value sv(isolate, js_str);
  return Just<>(std::string(*sv, sv.length()));
}",61,,414,4,,void
222109,BLOCK,-1,,"{
    return Nothing<std::string>();
  }",24,,415,2,,void
222123,BLOCK,-1,,"{
    maybe_str = error.As<v8::Symbol>()->ToDetailString(context);
  }",26,,421,2,,void
222135,BLOCK,-1,,<empty>,10,,423,1,,void
222142,BLOCK,-1,,"{
    maybe_str = error->ToString(context);
  }",34,,423,2,,void
222151,BLOCK,-1,,<empty>,10,,425,1,,void
222157,BLOCK,-1,,"{
    MaybeLocal<Value> stack = error.As<Object>()->Get(
        context, FIXED_ONE_BYTE_STRING(isolate, ""stack""));
    if (!stack.IsEmpty() && stack.ToLocalChecked()->IsString()) {
      maybe_str = stack.ToLocalChecked().As<String>();
    }
  }",33,,425,2,,void
222189,BLOCK,-1,,"{
      maybe_str = stack.ToLocalChecked().As<String>();
    }",65,,428,2,,void
222212,BLOCK,-1,,"{
    return Nothing<std::string>();
  }",36,,434,2,,void
222236,BLOCK,-1,,"{
  writer->json_keyvalue(""message"", ""No stack."");
  writer->json_arraystart(""stack"");
  writer->json_element(""Unavailable."");
  writer->json_arrayend();

  writer->json_objectstart(""errorProperties"");
  writer->json_objectend();
}",59,,441,2,,void
222272,BLOCK,-1,,"{
  // Can not capture the stacktrace when the isolate is in a OOM state.
  if (!strcmp(trigger, ""OOMError"")) {
    PrintEmptyJavaScriptStack(writer);
    return;
  }

  HandleScope scope(isolate);
  RegisterState state;
  state.pc = nullptr;
  state.fp = &state;
  state.sp = &state;

  // in-out params
  SampleInfo info;
  void* samples[MAX_FRAME_COUNT];
  isolate->GetStackSample(state, samples, MAX_FRAME_COUNT, &info);

  constexpr StackTrace::StackTraceOptions stack_trace_options =
      static_cast<StackTrace::StackTraceOptions>(
          StackTrace::kDetailed |
          StackTrace::kExposeFramesAcrossSecurityOrigins);
  Local<StackTrace> stack = StackTrace::CurrentStackTrace(
      isolate, MAX_FRAME_COUNT, stack_trace_options);

  if (stack->GetFrameCount() == 0) {
    PrintEmptyJavaScriptStack(writer);
    return;
  }

  writer->json_keyvalue(""message"", trigger);
  writer->json_arraystart(""stack"");
  for (int i = 0; i < stack->GetFrameCount(); i++) {
    Local<StackFrame> f...",55,,454,4,,void
222278,BLOCK,-1,,"{
    PrintEmptyJavaScriptStack(writer);
    return;
  }",37,,456,2,,void
222346,BLOCK,-1,,"{
    PrintEmptyJavaScriptStack(writer);
    return;
  }",36,,479,2,,void
222362,BLOCK,-1,,<empty>,3,,486,1,,void
222375,BLOCK,4,,"{
    Local<StackFrame> frame = stack->GetFrame(isolate, i);

    Utf8Value function_name(isolate, frame->GetFunctionName());
    Utf8Value script_name(isolate, frame->GetScriptName());
    const int line_number = frame->GetLineNumber();
    const int column = frame->GetColumn();

    std::string stack_line = SPrintF(
        ""at %s (%s:%d:%d)"", *function_name, *script_name, line_number, column);
    writer->json_element(stack_line);
  }",52,,486,4,,void
222452,BLOCK,-1,,"{
  if (error.IsEmpty()) {
    return PrintJavaScriptStack(writer, isolate, trigger);
  }

  TryCatch try_catch(isolate);
  HandleScope scope(isolate);
  Local<Context> context = isolate->GetCurrentContext();
  std::string ss = """";
  if (!ErrorToString(isolate, context, error).To(&ss)) {
    PrintEmptyJavaScriptStack(writer);
    return;
  }

  int line = ss.find('\n');
  if (line == -1) {
    writer->json_keyvalue(""message"", ss);
  } else {
    std::string l = ss.substr(0, line);
    writer->json_keyvalue(""message"", l);
    writer->json_arraystart(""stack"");
    ss = ss.substr(line + 1);
    line = ss.find('\n');
    while (line != -1) {
      l = ss.substr(0, line);
      l.erase(l.begin(), std::find_if(l.begin(), l.end(), [](int ch) {
                return !std::iswspace(ch);
              }));
      writer->json_element(l);
      ss = ss.substr(line + 1);
      line = ss.find('\n');
    }
    writer->json_arrayend();
  }

  // Report summary JavaScript error properties backtrace...",60,,507,5,,void
222458,BLOCK,-1,,"{
    return PrintJavaScriptStack(writer, isolate, trigger);
  }",24,,508,2,,void
222495,BLOCK,-1,,"{
    PrintEmptyJavaScriptStack(writer);
    return;
  }",56,,516,2,,void
222512,BLOCK,-1,,"{
    writer->json_keyvalue(""message"", ss);
  }",19,,522,2,,void
222520,BLOCK,-1,,"{
    std::string l = ss.substr(0, line);
    writer->json_keyvalue(""message"", l);
    writer->json_arraystart(""stack"");
    ss = ss.substr(line + 1);
    line = ss.find('\n');
    while (line != -1) {
      l = ss.substr(0, line);
      l.erase(l.begin(), std::find_if(l.begin(), l.end(), [](int ch) {
                return !std::iswspace(ch);
              }));
      writer->json_element(l);
      ss = ss.substr(line + 1);
      line = ss.find('\n');
    }
    writer->json_arrayend();
  }",10,,524,1,,void
222562,BLOCK,-1,,"{
      l = ss.substr(0, line);
      l.erase(l.begin(), std::find_if(l.begin(), l.end(), [](int ch) {
                return !std::iswspace(ch);
              }));
      writer->json_element(l);
      ss = ss.substr(line + 1);
      line = ss.find('\n');
    }",24,,530,2,,void
222625,BLOCK,-1,,"{
  auto sym_ctx = NativeSymbolDebuggingContext::New();
  void* frames[256];
  const int size = sym_ctx->GetStackTrace(frames, arraysize(frames));
  writer->json_arraystart(""nativeStack"");
  int i;
  for (i = 1; i < size; i++) {
    void* frame = frames[i];
    writer->json_start();
    writer->json_keyvalue(""pc"",
                          ValueToHexString(reinterpret_cast<uintptr_t>(frame)));
    writer->json_keyvalue(""symbol"", sym_ctx->LookupSymbol(frame).Display());
    writer->json_end();
  }
  writer->json_arrayend();
}",50,,547,2,,void
222651,BLOCK,-1,,<empty>,3,,553,1,,void
222660,BLOCK,4,,"{
    void* frame = frames[i];
    writer->json_start();
    writer->json_keyvalue(""pc"",
                          ValueToHexString(reinterpret_cast<uintptr_t>(frame)));
    writer->json_keyvalue(""symbol"", sym_ctx->LookupSymbol(frame).Display());
    writer->json_end();
  }",30,,553,4,,void
222706,BLOCK,-1,,"{
  HeapStatistics v8_heap_stats;
  isolate->GetHeapStatistics(&v8_heap_stats);
  HeapSpaceStatistics v8_heap_space_stats;

  writer->json_objectstart(""javascriptHeap"");
  writer->json_keyvalue(""totalMemory"", v8_heap_stats.total_heap_size());
  writer->json_keyvalue(""executableMemory"",
                        v8_heap_stats.total_heap_size_executable());
  writer->json_keyvalue(""totalCommittedMemory"",
                        v8_heap_stats.total_physical_size());
  writer->json_keyvalue(""availableMemory"",
                        v8_heap_stats.total_available_size());
  writer->json_keyvalue(""totalGlobalHandlesMemory"",
                        v8_heap_stats.total_global_handles_size());
  writer->json_keyvalue(""usedGlobalHandlesMemory"",
                        v8_heap_stats.used_global_handles_size());
  writer->json_keyvalue(""usedMemory"", v8_heap_stats.used_heap_size());
  writer->json_keyvalue(""memoryLimit"", v8_heap_stats.heap_size_limit());
  writer->json_keyvalue(""mallocedMemory"", v...",69,,568,3,,void
222852,BLOCK,-1,,<empty>,3,,599,1,,void
222865,BLOCK,4,,"{
    isolate->GetHeapSpaceStatistics(&v8_heap_space_stats, i);
    writer->json_objectstart(v8_heap_space_stats.space_name());
    writer->json_keyvalue(""memorySize"", v8_heap_space_stats.space_size());
    writer->json_keyvalue(
        ""committedMemory"",
        v8_heap_space_stats.physical_space_size());
    writer->json_keyvalue(
        ""capacity"",
        v8_heap_space_stats.space_used_size() +
            v8_heap_space_stats.space_available_size());
    writer->json_keyvalue(""used"", v8_heap_space_stats.space_used_size());
    writer->json_keyvalue(
        ""available"", v8_heap_space_stats.space_available_size());
    writer->json_objectend();
  }",62,,599,4,,void
222947,BLOCK,-1,,"{
  // Get process uptime in seconds
  uint64_t uptime =
      (uv_hrtime() - per_process::node_start_time) / (NANOS_PER_SEC);
  if (uptime == 0) uptime = 1;  // avoid division by zero.

  // Process and current thread usage statistics
  uv_rusage_t rusage;
  writer->json_objectstart(""resourceUsage"");

  uint64_t free_memory = uv_get_free_memory();
  uint64_t total_memory = uv_get_total_memory();

  writer->json_keyvalue(""free_memory"", free_memory);
  writer->json_keyvalue(""total_memory"", total_memory);

  size_t rss;
  int err = uv_resident_set_memory(&rss);
  if (!err) {
    writer->json_keyvalue(""rss"", rss);
  }

  uint64_t constrained_memory = uv_get_constrained_memory();
  if (constrained_memory) {
    writer->json_keyvalue(""constrained_memory"", constrained_memory);
  }

  // See GuessMemoryAvailableToTheProcess
  if (!err && constrained_memory && constrained_memory >= rss) {
    uint64_t available_memory = constrained_memory - rss;
    writer->json_keyvalue(""available_memory"",...",52,,620,2,,void
222962,BLOCK,-1,,<empty>,20,,624,2,,void
223002,BLOCK,-1,,"{
    writer->json_keyvalue(""rss"", rss);
  }",13,,638,2,,void
223015,BLOCK,-1,,"{
    writer->json_keyvalue(""constrained_memory"", constrained_memory);
  }",27,,643,2,,void
223031,BLOCK,-1,,"{
    uint64_t available_memory = constrained_memory - rss;
    writer->json_keyvalue(""available_memory"", available_memory);
  }",64,,648,2,,void
223045,BLOCK,-1,,"{
    writer->json_keyvalue(""available_memory"", free_memory);
  }",10,,651,1,,void
223058,BLOCK,-1,,"{
    double user_cpu =
        rusage.ru_utime.tv_sec + SEC_PER_MICROS * rusage.ru_utime.tv_usec;
    double kernel_cpu =
        rusage.ru_stime.tv_sec + SEC_PER_MICROS * rusage.ru_stime.tv_usec;
    writer->json_keyvalue(""userCpuSeconds"", user_cpu);
    writer->json_keyvalue(""kernelCpuSeconds"", kernel_cpu);
    double cpu_abs = user_cpu + kernel_cpu;
    double cpu_percentage = (cpu_abs / uptime) * 100.0;
    double user_cpu_percentage = (user_cpu / uptime) * 100.0;
    double kernel_cpu_percentage = (kernel_cpu / uptime) * 100.0;
    writer->json_keyvalue(""cpuConsumptionPercent"", cpu_percentage);
    writer->json_keyvalue(""userCpuConsumptionPercent"", user_cpu_percentage);
    writer->json_keyvalue(""kernelCpuConsumptionPercent"", kernel_cpu_percentage);
    writer->json_keyvalue(""maxRss"", rusage.ru_maxrss * 1024);
    writer->json_objectstart(""pageFaults"");
    writer->json_keyvalue(""IORequired"", rusage.ru_majflt);
    writer->json_keyvalue(""IONotRequired"", rusage.ru_minflt);
    ...",35,,655,2,,void
223219,BLOCK,-1,,"{
  uv_env_item_t* envitems;
  int envcount;
  int r;

  writer->json_objectstart(""environmentVariables"");

  {
    Mutex::ScopedLock lock(per_process::env_var_mutex);
    r = uv_os_environ(&envitems, &envcount);
  }

  if (r == 0) {
    for (int i = 0; i < envcount; i++)
      writer->json_keyvalue(envitems[i].name, envitems[i].value);

    uv_os_free_environ(envitems, envcount);
  }

  writer->json_objectend();

#ifndef _WIN32
  static struct {
    const char* description;
    int id;
  } rlimit_strings[] = {
    {""core_file_size_blocks"", RLIMIT_CORE},
    {""data_seg_size_kbytes"", RLIMIT_DATA},
    {""file_size_blocks"", RLIMIT_FSIZE},
#if !(defined(_AIX) || defined(__sun))
    {""max_locked_memory_bytes"", RLIMIT_MEMLOCK},
#endif
#ifndef __sun
    {""max_memory_size_kbytes"", RLIMIT_RSS},
#endif
    {""open_files"", RLIMIT_NOFILE},
    {""stack_size_bytes"", RLIMIT_STACK},
    {""cpu_time_seconds"", RLIMIT_CPU},
#ifndef __sun
    {""max_user_processes"", RLIMIT_NPROC},
#endif
#ifndef __OpenBSD...",56,,707,2,,void
223228,BLOCK,5,,"{
    Mutex::ScopedLock lock(per_process::env_var_mutex);
    r = uv_os_environ(&envitems, &envcount);
  }",3,,714,5,,void
223245,BLOCK,-1,,"{
    for (int i = 0; i < envcount; i++)
      writer->json_keyvalue(envitems[i].name, envitems[i].value);

    uv_os_free_environ(envitems, envcount);
  }",15,,719,2,,void
223247,BLOCK,-1,,<empty>,5,,720,1,,void
223321,BLOCK,-1,,<empty>,3,,757,1,,void
223332,BLOCK,4,,"{
    if (getrlimit(rlimit_strings[i].id, &limit) == 0) {
      writer->json_objectstart(rlimit_strings[i].description);

      if (limit.rlim_cur == RLIM_INFINITY)
        writer->json_keyvalue(""soft"", ""unlimited"");
      else
        writer->json_keyvalue(""soft"", limit.rlim_cur);

      if (limit.rlim_max == RLIM_INFINITY)
        writer->json_keyvalue(""hard"", ""unlimited"");
      else
        writer->json_keyvalue(""hard"", limit.rlim_max);

      writer->json_objectend();
    }
  }",58,,757,4,,void
223344,BLOCK,-1,,"{
      writer->json_objectstart(rlimit_strings[i].description);

      if (limit.rlim_cur == RLIM_INFINITY)
        writer->json_keyvalue(""soft"", ""unlimited"");
      else
        writer->json_keyvalue(""soft"", limit.rlim_cur);

      if (limit.rlim_max == RLIM_INFINITY)
        writer->json_keyvalue(""hard"", ""unlimited"");
      else
        writer->json_keyvalue(""hard"", limit.rlim_max);

      writer->json_objectend();
    }",55,,758,2,,void
223360,BLOCK,-1,,<empty>,9,,762,2,,void
223368,BLOCK,-1,,<empty>,9,,764,1,,void
223383,BLOCK,-1,,<empty>,9,,767,2,,void
223391,BLOCK,-1,,<empty>,9,,769,1,,void
223414,BLOCK,-1,,"{
  writer->json_arraystart(""sharedObjects"");
  std::vector<std::string> modules =
      NativeSymbolDebuggingContext::GetLoadedLibraries();
  for (auto const& module_name : modules) writer->json_element(module_name);
  writer->json_arrayend();
}",54,,781,2,,void
223450,BLOCK,-1,,"{
  std::stringstream buf;

  writer->json_objectstart(""componentVersions"");

#define V(key) +1
  std::pair<std::string_view, std::string_view>
      versions_array[NODE_VERSIONS_KEYS(V)];
#undef V
  auto* slot = &versions_array[0];

#define V(key)                                                                 \
  do {                                                                         \
    *slot++ = std::pair<std::string_view, std::string_view>(                   \
        #key, per_process::metadata.versions.key);                             \
  } while (0);
  NODE_VERSIONS_KEYS(V)
#undef V

  std::sort(&versions_array[0],
            &versions_array[arraysize(versions_array)],
            [](auto& a, auto& b) { return a.first < b.first; });

  for (const auto& version : versions_array) {
    writer->json_keyvalue(version.first, version.second);
  }

  writer->json_objectend();
}",56,,790,2,,void
223499,BLOCK,-1,,"{
    writer->json_keyvalue(version.first, version.second);
  }",46,,813,3,,void
223518,BLOCK,-1,,"{
  writer->json_objectstart(""release"");
  writer->json_keyvalue(""name"", per_process::metadata.release.name);
#if NODE_VERSION_IS_LTS
  writer->json_keyvalue(""lts"", per_process::metadata.release.lts);
#endif

#ifdef NODE_HAS_RELEASE_URLS
  writer->json_keyvalue(""headersUrl"",
                        per_process::metadata.release.headers_url);
  writer->json_keyvalue(""sourceUrl"", per_process::metadata.release.source_url);
#ifdef _WIN32
  writer->json_keyvalue(""libUrl"", per_process::metadata.release.lib_url);
#endif  // _WIN32
#endif  // NODE_HAS_RELEASE_URLS

  writer->json_objectend();
}",46,,821,2,,void
223549,BLOCK,-1,,"{
  std::string filename;

  // Determine the required report filename. In order of priority:
  //   1) supplied on API 2) configured on startup 3) default generated
  if (!name.empty()) {
    // Filename was specified as API parameter.
    filename = name;
  } else {
    std::string report_filename;
    {
      Mutex::ScopedLock lock(per_process::cli_options_mutex);
      report_filename = per_process::cli_options->report_filename;
    }
    if (report_filename.length() > 0) {
      // File name was supplied via start-up option.
      filename = report_filename;
    } else {
      filename = *DiagnosticFilename(
          env != nullptr ? env->thread_id() : 0, ""report"", ""json"");
    }
  }

  // Open the report file stream for writing. Supports stdout/err,
  // user-specified or (default) generated name
  std::ofstream outfile;
  std::ostream* outstream;
  if (filename == ""stdout"") {
    outstream = &std::cout;
  } else if (filename == ""stderr"") {
    outstream = &std::cerr;
  } els...",51,,847,7,,void
223557,BLOCK,-1,,"{
    // Filename was specified as API parameter.
    filename = name;
  }",22,,852,2,,void
223562,BLOCK,-1,,"{
    std::string report_filename;
    {
      Mutex::ScopedLock lock(per_process::cli_options_mutex);
      report_filename = per_process::cli_options->report_filename;
    }
    if (report_filename.length() > 0) {
      // File name was supplied via start-up option.
      filename = report_filename;
    } else {
      filename = *DiagnosticFilename(
          env != nullptr ? env->thread_id() : 0, ""report"", ""json"");
    }
  }",10,,855,1,,void
223564,BLOCK,2,,"{
      Mutex::ScopedLock lock(per_process::cli_options_mutex);
      report_filename = per_process::cli_options->report_filename;
    }",5,,857,2,,void
223584,BLOCK,-1,,"{
      // File name was supplied via start-up option.
      filename = report_filename;
    }",39,,861,2,,void
223589,BLOCK,-1,,"{
      filename = *DiagnosticFilename(
          env != nullptr ? env->thread_id() : 0, ""report"", ""json"");
    }",12,,864,1,,void
223611,BLOCK,-1,,"{
    outstream = &std::cout;
  }",29,,874,2,,void
223619,BLOCK,-1,,<empty>,10,,876,1,,void
223624,BLOCK,-1,,"{
    outstream = &std::cerr;
  }",36,,876,2,,void
223632,BLOCK,-1,,"{
    std::string report_directory;
    {
      Mutex::ScopedLock lock(per_process::cli_options_mutex);
      report_directory = per_process::cli_options->report_directory;
    }
    // Regular file. Append filename to directory path if one was specified
    if (report_directory.length() > 0) {
      std::string pathname = report_directory;
      pathname += kPathSeparator;
      pathname += filename;
      outfile.open(pathname, std::ios::out | std::ios::binary);
    } else {
      outfile.open(filename, std::ios::out | std::ios::binary);
    }
    // Check for errors on the file open
    if (!outfile.is_open()) {
      std::cerr << ""\nFailed to open Node.js report file: "" << filename;

      if (report_directory.length() > 0)
        std::cerr << "" directory: "" << report_directory;

      std::cerr << "" (errno: "" << errno << "")"" << std::endl;
      return """";
    }
    outstream = &outfile;
    std::cerr << ""\nWriting Node.js report to file: "" << filename;
  }",10,,878,1,,void
223634,BLOCK,2,,"{
      Mutex::ScopedLock lock(per_process::cli_options_mutex);
      report_directory = per_process::cli_options->report_directory;
    }",5,,880,2,,void
223654,BLOCK,-1,,"{
      std::string pathname = report_directory;
      pathname += kPathSeparator;
      pathname += filename;
      outfile.open(pathname, std::ios::out | std::ios::binary);
    }",40,,885,2,,void
223682,BLOCK,-1,,"{
      outfile.open(filename, std::ios::out | std::ios::binary);
    }",12,,890,1,,void
223705,BLOCK,-1,,"{
      std::cerr << ""\nFailed to open Node.js report file: "" << filename;

      if (report_directory.length() > 0)
        std::cerr << "" directory: "" << report_directory;

      std::cerr << "" (errno: "" << errno << "")"" << std::endl;
      return """";
    }",29,,894,2,,void
223720,BLOCK,-1,,<empty>,9,,898,2,,void
223755,BLOCK,7,,"{
    Mutex::ScopedLock lock(per_process::cli_options_mutex);
    compact = per_process::cli_options->report_compact;
  }",3,,908,7,,void
223786,BLOCK,-1,,"{
    outfile.close();
  }",26,,917,2,,void
223795,BLOCK,-1,,"{
    std::cerr << ""\nNode.js report completed"" << std::endl;
  }",29,,922,2,,void
223815,BLOCK,-1,,"{
  Environment* env = nullptr;
  if (isolate != nullptr) {
    env = Environment::GetCurrent(isolate);
  }
  return TriggerNodeReport(isolate, env, message, trigger, name, error);
}",51,,933,6,,void
223824,BLOCK,-1,,"{
    env = Environment::GetCurrent(isolate);
  }",27,,935,2,,void
223848,BLOCK,-1,,"{
  return TriggerNodeReport(env != nullptr ? env->isolate() : nullptr,
                           env,
                           message,
                           trigger,
                           name,
                           error);
}",51,,946,6,,void
223873,BLOCK,-1,,"{
  Environment* env = nullptr;
  if (isolate != nullptr) {
    env = Environment::GetCurrent(isolate);
  }
  report::WriteNodeReport(
      isolate, env, message, trigger, """", out, error, false);
}",39,,960,6,,void
223882,BLOCK,-1,,"{
    env = Environment::GetCurrent(isolate);
  }",27,,962,2,,void
223910,BLOCK,-1,,"{
  Isolate* isolate = nullptr;
  if (env != nullptr) {
    isolate = env->isolate();
  }
  report::WriteNodeReport(
      isolate, env, message, trigger, """", out, error, false);
}",39,,974,6,,void
223919,BLOCK,-1,,"{
    isolate = env->isolate();
  }",23,,976,2,,void
223960,BLOCK,-1,,<empty>,1,,1,1,,ANY
223993,BLOCK,-1,,<empty>,1,,1,1,,ANY
223998,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  Isolate* isolate = env->isolate();
  HandleScope scope(isolate);
  std::string filename;
  Local<Value> error;

  CHECK_EQ(info.Length(), 4);
  String::Utf8Value message(isolate, info[0].As<String>());
  String::Utf8Value trigger(isolate, info[1].As<String>());

  if (info[2]->IsString())
    filename = *String::Utf8Value(isolate, info[2]);
  if (!info[3].IsEmpty())
    error = info[3];
  else
    error = Local<Value>();

  filename = TriggerNodeReport(env, *message, *trigger, filename, error);
  // Return value is the report filename
  info.GetReturnValue().Set(
      String::NewFromUtf8(isolate, filename.c_str()).ToLocalChecked());
}",59,,29,2,,void
224054,BLOCK,-1,,<empty>,5,,41,2,,void
224074,BLOCK,-1,,<empty>,5,,43,2,,void
224081,BLOCK,-1,,<empty>,5,,45,1,,void
224118,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  Isolate* isolate = env->isolate();
  HandleScope scope(isolate);
  Local<Object> error;
  std::ostringstream out;

  CHECK_EQ(info.Length(), 1);
  if (!info[0].IsEmpty() && info[0]->IsObject())
    error = info[0].As<Object>();
  else
    error = Local<Object>();

  GetNodeReport(env, ""JavaScript API"", __func__, error, out);

  // Return value is the contents of a report as a string.
  info.GetReturnValue().Set(
      String::NewFromUtf8(isolate, out.str().c_str()).ToLocalChecked());
}",57,,54,2,,void
224164,BLOCK,-1,,<empty>,5,,63,2,,void
224174,BLOCK,-1,,<empty>,5,,65,1,,void
224210,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  info.GetReturnValue().Set(per_process::cli_options->report_compact);
}",65,,74,2,,void
224232,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Environment* env = Environment::GetCurrent(info);
  Isolate* isolate = env->isolate();
  bool compact = info[0]->ToBoolean(isolate)->Value();
  per_process::cli_options->report_compact = compact;
}",65,,79,2,,void
224277,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Environment* env = Environment::GetCurrent(info);
  std::string directory = per_process::cli_options->report_directory;
  auto result = String::NewFromUtf8(env->isolate(), directory.c_str());
  info.GetReturnValue().Set(result.ToLocalChecked());
}",67,,87,2,,void
224329,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Environment* env = Environment::GetCurrent(info);
  CHECK(info[0]->IsString());
  Utf8Value dir(env->isolate(), info[0].As<String>());
  per_process::cli_options->report_directory = *dir;
}",67,,95,2,,void
224374,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Environment* env = Environment::GetCurrent(info);
  std::string filename = per_process::cli_options->report_filename;
  auto result = String::NewFromUtf8(env->isolate(), filename.c_str());
  info.GetReturnValue().Set(result.ToLocalChecked());
}",66,,103,2,,void
224426,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Environment* env = Environment::GetCurrent(info);
  CHECK(info[0]->IsString());
  Utf8Value name(env->isolate(), info[0].As<String>());
  per_process::cli_options->report_filename = *name;
}",66,,111,2,,void
224471,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  std::string signal = env->isolate_data()->options()->report_signal;
  auto result = String::NewFromUtf8(env->isolate(), signal.c_str());
  info.GetReturnValue().Set(result.ToLocalChecked());
}",64,,119,2,,void
224522,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  CHECK(info[0]->IsString());
  Utf8Value signal(env->isolate(), info[0].As<String>());
  env->isolate_data()->options()->report_signal = *signal;
}",64,,126,2,,void
224566,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  info.GetReturnValue().Set(per_process::cli_options->report_on_fatalerror);
}",79,,133,2,,void
224588,BLOCK,-1,,"{
  CHECK(info[0]->IsBoolean());
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  per_process::cli_options->report_on_fatalerror = info[0]->IsTrue();
}",76,,138,2,,void
224617,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  info.GetReturnValue().Set(env->isolate_data()->options()->report_on_signal);
}",75,,144,2,,void
224646,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  CHECK(info[0]->IsBoolean());
  env->isolate_data()->options()->report_on_signal = info[0]->IsTrue();
}",72,,149,2,,void
224682,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  info.GetReturnValue().Set(
      env->isolate_data()->options()->report_uncaught_exception);
}",46,,156,2,,void
224711,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  CHECK(info[0]->IsBoolean());
  env->isolate_data()->options()->report_uncaught_exception = info[0]->IsTrue();
}",46,,163,2,,void
224750,BLOCK,-1,,"{
  SetMethod(context, exports, ""writeReport"", WriteReport);
  SetMethod(context, exports, ""getReport"", GetReport);
  SetMethod(context, exports, ""getCompact"", GetCompact);
  SetMethod(context, exports, ""setCompact"", SetCompact);
  SetMethod(context, exports, ""getDirectory"", GetDirectory);
  SetMethod(context, exports, ""setDirectory"", SetDirectory);
  SetMethod(context, exports, ""getFilename"", GetFilename);
  SetMethod(context, exports, ""setFilename"", SetFilename);
  SetMethod(context, exports, ""getSignal"", GetSignal);
  SetMethod(context, exports, ""setSignal"", SetSignal);
  SetMethod(
      context, exports, ""shouldReportOnFatalError"", ShouldReportOnFatalError);
  SetMethod(context, exports, ""setReportOnFatalError"", SetReportOnFatalError);
  SetMethod(context, exports, ""shouldReportOnSignal"", ShouldReportOnSignal);
  SetMethod(context, exports, ""setReportOnSignal"", SetReportOnSignal);
  SetMethod(context,
            exports,
            ""shouldReportOnUncaughtException"",
         ...",36,,172,5,,void
224835,BLOCK,-1,,"{
  registry->Register(WriteReport);
  registry->Register(GetReport);
  registry->Register(GetCompact);
  registry->Register(SetCompact);
  registry->Register(GetDirectory);
  registry->Register(SetDirectory);
  registry->Register(GetFilename);
  registry->Register(SetFilename);
  registry->Register(GetSignal);
  registry->Register(SetSignal);
  registry->Register(ShouldReportOnFatalError);
  registry->Register(SetReportOnFatalError);
  registry->Register(ShouldReportOnSignal);
  registry->Register(SetReportOnSignal);
  registry->Register(ShouldReportOnUncaughtException);
  registry->Register(SetReportOnUncaughtException);
}",70,,198,2,,void
224931,BLOCK,-1,,<empty>,1,,1,1,,ANY
224944,BLOCK,-1,,"{
  if (addr == nullptr) {
    writer->json_keyvalue(name, null);
    return;
  }

  uv_getnameinfo_t endpoint;
  char* host = nullptr;
  char hostbuf[INET6_ADDRSTRLEN];
  const int family = addr->sa_family;
  const int port = ntohs(family == AF_INET ?
                         reinterpret_cast<sockaddr_in*>(addr)->sin_port :
                         reinterpret_cast<sockaddr_in6*>(addr)->sin6_port);

  if (uv_getnameinfo(h->loop, &endpoint, nullptr, addr, NI_NUMERICSERV) == 0) {
    host = endpoint.host;
    DCHECK_EQ(port, std::stoi(endpoint.service));
  } else {
    const void* src = family == AF_INET ?
                      static_cast<void*>(
                        &(reinterpret_cast<sockaddr_in*>(addr)->sin_addr)) :
                      static_cast<void*>(
                        &(reinterpret_cast<sockaddr_in6*>(addr)->sin6_addr));
    if (uv_inet_ntop(family, src, hostbuf, sizeof(hostbuf)) == 0) {
      host = hostbuf;
    }
  }
  writer->json_objectstart(name);
  if (host ...",48,,15,5,,void
224949,BLOCK,-1,,"{
    writer->json_keyvalue(name, null);
    return;
  }",24,,16,2,,void
224999,BLOCK,-1,,"{
    host = endpoint.host;
    DCHECK_EQ(port, std::stoi(endpoint.service));
  }",79,,29,2,,void
225015,BLOCK,-1,,"{
    const void* src = family == AF_INET ?
                      static_cast<void*>(
                        &(reinterpret_cast<sockaddr_in*>(addr)->sin_addr)) :
                      static_cast<void*>(
                        &(reinterpret_cast<sockaddr_in6*>(addr)->sin6_addr));
    if (uv_inet_ntop(family, src, hostbuf, sizeof(hostbuf)) == 0) {
      host = hostbuf;
    }
  }",10,,32,1,,void
225048,BLOCK,-1,,"{
      host = hostbuf;
    }",67,,38,2,,void
225061,BLOCK,-1,,"{
    writer->json_keyvalue(""host"", host);
  }",24,,43,2,,void
225083,BLOCK,-1,,"{
  struct sockaddr_storage addr_storage;
  struct sockaddr* addr = reinterpret_cast<sockaddr*>(&addr_storage);
  uv_any_handle* handle = reinterpret_cast<uv_any_handle*>(h);
  int addr_size = sizeof(addr_storage);
  int rc = -1;

  switch (h->type) {
    case UV_UDP:
      rc = uv_udp_getsockname(&handle->udp, addr, &addr_size);
      break;
    case UV_TCP:
      rc = uv_tcp_getsockname(&handle->tcp, addr, &addr_size);
      break;
    default:
      break;
  }
  ReportEndpoint(h, rc == 0 ? addr : nullptr,  ""localEndpoint"", writer);

  switch (h->type) {
    case UV_UDP:
      rc = uv_udp_getpeername(&handle->udp, addr, &addr_size);
      break;
    case UV_TCP:
      rc = uv_tcp_getpeername(&handle->tcp, addr, &addr_size);
      break;
    default:
      break;
  }
  ReportEndpoint(h, rc == 0 ? addr : nullptr, ""remoteEndpoint"", writer);
}",65,,51,3,,void
225112,BLOCK,-1,,"{
    case UV_UDP:
      rc = uv_udp_getsockname(&handle->udp, addr, &addr_size);
      break;
    case UV_TCP:
      rc = uv_tcp_getsockname(&handle->tcp, addr, &addr_size);
      break;
    default:
      break;
  }",20,,58,2,,void
225155,BLOCK,-1,,"{
    case UV_UDP:
      rc = uv_udp_getpeername(&handle->udp, addr, &addr_size);
      break;
    case UV_TCP:
      rc = uv_tcp_getpeername(&handle->tcp, addr, &addr_size);
      break;
    default:
      break;
  }",20,,70,2,,void
225199,BLOCK,-1,,"{
  uv_any_handle* handle = reinterpret_cast<uv_any_handle*>(h);
  MaybeStackBuffer<char> buffer;
  size_t buffer_size = buffer.capacity();
  int rc = -1;

  // First call to get required buffer size.
  rc = uv_pipe_getsockname(&handle->pipe, buffer.out(), &buffer_size);
  if (rc == UV_ENOBUFS) {
    buffer.AllocateSufficientStorage(buffer_size);
    rc = uv_pipe_getsockname(&handle->pipe, buffer.out(), &buffer_size);
  }
  if (rc == 0 && buffer_size != 0) {
    buffer.SetLength(buffer_size);
    writer->json_keyvalue(""localEndpoint"", buffer.ToStringView());
  } else {
    writer->json_keyvalue(""localEndpoint"", null);
  }

  // First call to get required buffer size.
  buffer_size = buffer.capacity();
  rc = uv_pipe_getpeername(&handle->pipe, buffer.out(), &buffer_size);
  if (rc == UV_ENOBUFS) {
    buffer.AllocateSufficientStorage(buffer_size);
    rc = uv_pipe_getpeername(&handle->pipe, buffer.out(), &buffer_size);
  }
  if (rc == 0 && buffer_size != 0) {
    buffer.SetLength(buf...",69,,84,3,,void
225236,BLOCK,-1,,"{
    buffer.AllocateSufficientStorage(buffer_size);
    rc = uv_pipe_getsockname(&handle->pipe, buffer.out(), &buffer_size);
  }",25,,92,2,,void
225263,BLOCK,-1,,"{
    buffer.SetLength(buffer_size);
    writer->json_keyvalue(""localEndpoint"", buffer.ToStringView());
  }",36,,96,2,,void
225279,BLOCK,-1,,"{
    writer->json_keyvalue(""localEndpoint"", null);
  }",10,,99,1,,void
225309,BLOCK,-1,,"{
    buffer.AllocateSufficientStorage(buffer_size);
    rc = uv_pipe_getpeername(&handle->pipe, buffer.out(), &buffer_size);
  }",25,,106,2,,void
225336,BLOCK,-1,,"{
    buffer.SetLength(buffer_size);
    writer->json_keyvalue(""remoteEndpoint"", buffer.ToStringView());
  }",36,,110,2,,void
225352,BLOCK,-1,,"{
    writer->json_keyvalue(""remoteEndpoint"", null);
  }",10,,113,1,,void
225364,BLOCK,-1,,"{
  MaybeStackBuffer<char> buffer;
  int rc = -1;
  size_t size = buffer.capacity();
  uv_any_handle* handle = reinterpret_cast<uv_any_handle*>(h);
  // First call to get required buffer size.
  switch (h->type) {
    case UV_FS_EVENT:
      rc = uv_fs_event_getpath(&(handle->fs_event), buffer.out(), &size);
      break;
    case UV_FS_POLL:
      rc = uv_fs_poll_getpath(&(handle->fs_poll), buffer.out(), &size);
      break;
    default:
      break;
  }
  if (rc == UV_ENOBUFS) {
    buffer.AllocateSufficientStorage(size);
    switch (h->type) {
      case UV_FS_EVENT:
        rc = uv_fs_event_getpath(&(handle->fs_event), buffer.out(), &size);
        break;
      case UV_FS_POLL:
        rc = uv_fs_poll_getpath(&(handle->fs_poll), buffer.out(), &size);
        break;
      default:
        break;
    }
  }

  if (rc == 0 && size > 0) {
    buffer.SetLength(size);
    writer->json_keyvalue(""filename"", buffer.ToStringView());
  } else {
    writer->json_keyvalue(""filename"", null);
  }
}",60,,119,3,,void
225388,BLOCK,-1,,"{
    case UV_FS_EVENT:
      rc = uv_fs_event_getpath(&(handle->fs_event), buffer.out(), &size);
      break;
    case UV_FS_POLL:
      rc = uv_fs_poll_getpath(&(handle->fs_poll), buffer.out(), &size);
      break;
    default:
      break;
  }",20,,125,2,,void
225427,BLOCK,-1,,"{
    buffer.AllocateSufficientStorage(size);
    switch (h->type) {
      case UV_FS_EVENT:
        rc = uv_fs_event_getpath(&(handle->fs_event), buffer.out(), &size);
        break;
      case UV_FS_POLL:
        rc = uv_fs_poll_getpath(&(handle->fs_poll), buffer.out(), &size);
        break;
      default:
        break;
    }
  }",25,,135,2,,void
225437,BLOCK,-1,,"{
      case UV_FS_EVENT:
        rc = uv_fs_event_getpath(&(handle->fs_event), buffer.out(), &size);
        break;
      case UV_FS_POLL:
        rc = uv_fs_poll_getpath(&(handle->fs_poll), buffer.out(), &size);
        break;
      default:
        break;
    }",22,,137,2,,void
225480,BLOCK,-1,,"{
    buffer.SetLength(size);
    writer->json_keyvalue(""filename"", buffer.ToStringView());
  }",28,,149,2,,void
225496,BLOCK,-1,,"{
    writer->json_keyvalue(""filename"", null);
  }",10,,152,1,,void
225508,BLOCK,-1,,"{
  const char* type = uv_handle_type_name(h->type);
  JSONWriter* writer = static_cast<JSONWriter*>(arg);
  uv_any_handle* handle = reinterpret_cast<uv_any_handle*>(h);

  writer->json_start();
  writer->json_keyvalue(""type"", type);
  writer->json_keyvalue(""is_active"", static_cast<bool>(uv_is_active(h)));
  writer->json_keyvalue(""is_referenced"", static_cast<bool>(uv_has_ref(h)));
  writer->json_keyvalue(""address"",
                        ValueToHexString(reinterpret_cast<uint64_t>(h)));

  switch (h->type) {
    case UV_FS_EVENT:
    case UV_FS_POLL:
      ReportPath(h, writer);
      break;
    case UV_PROCESS:
      writer->json_keyvalue(""pid"", handle->process.pid);
      break;
    case UV_TCP:
    case UV_UDP:
      ReportEndpoints(h, writer);
      break;
    case UV_NAMED_PIPE:
      ReportPipeEndpoints(h, writer);
      break;
    case UV_TIMER: {
      uint64_t due = handle->timer.timeout;
      uint64_t now = uv_now(handle->timer.loop);
      writer->json_keyvalue(""repeat""...",44,,158,3,,void
225569,BLOCK,-1,,"{
    case UV_FS_EVENT:
    case UV_FS_POLL:
      ReportPath(h, writer);
      break;
    case UV_PROCESS:
      writer->json_keyvalue(""pid"", handle->process.pid);
      break;
    case UV_TCP:
    case UV_UDP:
      ReportEndpoints(h, writer);
      break;
    case UV_NAMED_PIPE:
      ReportPipeEndpoints(h, writer);
      break;
    case UV_TIMER: {
      uint64_t due = handle->timer.timeout;
      uint64_t now = uv_now(handle->timer.loop);
      writer->json_keyvalue(""repeat"", uv_timer_get_repeat(&handle->timer));
      writer->json_keyvalue(""firesInMsFromNow"",
                            static_cast<int64_t>(due - now));
      writer->json_keyvalue(""expired"", now >= due);
      break;
    }
    case UV_TTY: {
      int height, width, rc;
      rc = uv_tty_get_winsize(&(handle->tty), &width, &height);
      if (rc == 0) {
        writer->json_keyvalue(""width"", width);
        writer->json_keyvalue(""height"", height);
      }
      break;
    }
    case UV_SIGNAL:
      // SIGWINC...",20,,170,2,,void
225607,BLOCK,23,,"{
      uint64_t due = handle->timer.timeout;
      uint64_t now = uv_now(handle->timer.loop);
      writer->json_keyvalue(""repeat"", uv_timer_get_repeat(&handle->timer));
      writer->json_keyvalue(""firesInMsFromNow"",
                            static_cast<int64_t>(due - now));
      writer->json_keyvalue(""expired"", now >= due);
      break;
    }",20,,185,23,,void
225656,BLOCK,26,,"{
      int height, width, rc;
      rc = uv_tty_get_winsize(&(handle->tty), &width, &height);
      if (rc == 0) {
        writer->json_keyvalue(""width"", width);
        writer->json_keyvalue(""height"", height);
      }
      break;
    }",18,,194,26,,void
225675,BLOCK,-1,,"{
        writer->json_keyvalue(""width"", width);
        writer->json_keyvalue(""height"", height);
      }",20,,197,2,,void
225733,BLOCK,-1,,"{
    // These *must* be 0 or libuv will set the buffer sizes to the non-zero
    // values they contain.
    int send_size = 0;
    int recv_size = 0;
    uv_send_buffer_size(h, &send_size);
    uv_recv_buffer_size(h, &recv_size);
    writer->json_keyvalue(""sendBufferSize"", send_size);
    writer->json_keyvalue(""recvBufferSize"", recv_size);
  }",5,,217,2,,void
225792,BLOCK,-1,,"{
    uv_os_fd_t fd_v;
    int rc = uv_fileno(h, &fd_v);

    if (rc == 0) {
      writer->json_keyvalue(""fd"", static_cast<int>(fd_v));
      switch (fd_v) {
        case STDIN_FILENO:
          writer->json_keyvalue(""stdio"", ""stdin"");
          break;
        case STDOUT_FILENO:
          writer->json_keyvalue(""stdio"", ""stdout"");
          break;
        case STDERR_FILENO:
          writer->json_keyvalue(""stdio"", ""stderr"");
          break;
        default:
          break;
      }
    }
  }",48,,230,2,,void
225805,BLOCK,-1,,"{
      writer->json_keyvalue(""fd"", static_cast<int>(fd_v));
      switch (fd_v) {
        case STDIN_FILENO:
          writer->json_keyvalue(""stdio"", ""stdin"");
          break;
        case STDOUT_FILENO:
          writer->json_keyvalue(""stdio"", ""stdout"");
          break;
        case STDERR_FILENO:
          writer->json_keyvalue(""stdio"", ""stderr"");
          break;
        default:
          break;
      }
    }",18,,234,2,,void
225816,BLOCK,-1,,"{
        case STDIN_FILENO:
          writer->json_keyvalue(""stdio"", ""stdin"");
          break;
        case STDOUT_FILENO:
          writer->json_keyvalue(""stdio"", ""stdout"");
          break;
        case STDERR_FILENO:
          writer->json_keyvalue(""stdio"", ""stderr"");
          break;
        default:
          break;
      }",21,,236,2,,void
225864,BLOCK,-1,,"{
    writer->json_keyvalue(""writeQueueSize"", handle->stream.write_queue_size);
    writer->json_keyvalue(""readable"",
                          static_cast<bool>(uv_is_readable(&handle->stream)));
    writer->json_keyvalue(""writable"",
                          static_cast<bool>(uv_is_writable(&handle->stream)));
  }",75,,253,2,,void
225905,BLOCK,-1,,"{
    writer->json_keyvalue(
        ""writeQueueSize"",
        uv_udp_get_send_queue_size(reinterpret_cast<uv_udp_t*>(h)));
    writer->json_keyvalue(
        ""writeQueueCount"",
        uv_udp_get_send_queue_count(reinterpret_cast<uv_udp_t*>(h)));
  }",26,,260,2,,void
225936,BLOCK,-1,,<empty>,1,,1,1,,ANY
225941,BLOCK,-1,,<empty>,1,,1,1,,ANY
225944,BLOCK,-1,,"{
    size_t size;
#ifdef __APPLE__
    postject_options options;
    postject_options_init(&options);
    options.macho_segment_name = ""NODE_SEA"";
    const char* code = static_cast<const char*>(
        postject_find_resource(""NODE_SEA_BLOB"", &size, &options));
#else
    const char* code = static_cast<const char*>(
        postject_find_resource(""NODE_SEA_BLOB"", &size, nullptr));
#endif
    uint32_t first_word = reinterpret_cast<const uint32_t*>(code)[0];
    CHECK_EQ(first_word, kMagic);
    SeaFlags flags{
        reinterpret_cast<const SeaFlags*>(code + sizeof(first_word))[0]};
    // TODO(joyeecheung): do more checks here e.g. matching the versions.
    return {
        flags,
        {
            code + SeaResource::kHeaderSize,
            size - SeaResource::kHeaderSize,
        },
    };
  }",63,,70,1,,void
226011,BLOCK,-1,,<empty>,1,,1,1,,ANY
226022,BLOCK,-1,,<empty>,,,,1,,<empty>
226036,BLOCK,-1,,"{
  return static_cast<SeaFlags>(static_cast<uint32_t>(x) |
                               static_cast<uint32_t>(y));
}",44,,48,3,,void
226052,BLOCK,-1,,"{
  return static_cast<SeaFlags>(static_cast<uint32_t>(x) &
                               static_cast<uint32_t>(y));
}",44,,53,3,,void
226068,BLOCK,-1,,"{
  return x = x | y;
}",80,,58,3,,void
226082,BLOCK,-1,,<empty>,,,,1,,<empty>
226098,BLOCK,-1,,"{
  CHECK(IsSingleExecutable());
  static const SeaResource sea_resource = []() -> SeaResource {
    size_t size;
#ifdef __APPLE__
    postject_options options;
    postject_options_init(&options);
    options.macho_segment_name = ""NODE_SEA"";
    const char* code = static_cast<const char*>(
        postject_find_resource(""NODE_SEA_BLOB"", &size, &options));
#else
    const char* code = static_cast<const char*>(
        postject_find_resource(""NODE_SEA_BLOB"", &size, nullptr));
#endif
    uint32_t first_word = reinterpret_cast<const uint32_t*>(code)[0];
    CHECK_EQ(first_word, kMagic);
    SeaFlags flags{
        reinterpret_cast<const SeaFlags*>(code + sizeof(first_word))[0]};
    // TODO(joyeecheung): do more checks here e.g. matching the versions.
    return {
        flags,
        {
            code + SeaResource::kHeaderSize,
            size - SeaResource::kHeaderSize,
        },
    };
  }();
  return sea_resource;
}",44,,68,1,,void
226110,BLOCK,-1,,"{
  SeaResource sea_resource = FindSingleExecutableResource();
  return sea_resource.code;
}",45,,100,1,,void
226122,BLOCK,-1,,"{
  return postject_has_resource();
}",27,,105,1,,void
226129,BLOCK,-1,,"{
  if (!IsSingleExecutable()) {
    args.GetReturnValue().Set(false);
    return;
  }

  SeaResource sea_resource = FindSingleExecutableResource();
  args.GetReturnValue().Set(!static_cast<bool>(
      sea_resource.flags & SeaFlags::kDisableExperimentalSeaWarning));
}",78,,109,2,,void
226133,BLOCK,-1,,"{
    args.GetReturnValue().Set(false);
    return;
  }",30,,110,2,,void
226169,BLOCK,-1,,"{
  // Repeats argv[0] at position 1 on argv as a replacement for the missing
  // entry point file path.
  if (IsSingleExecutable()) {
    static std::vector<char*> new_argv;
    new_argv.reserve(argc + 2);
    new_argv.emplace_back(argv[0]);
    new_argv.insert(new_argv.end(), argv, argv + argc);
    new_argv.emplace_back(nullptr);
    argc = new_argv.size() - 1;
    argv = new_argv.data();
  }

  return {argc, argv};
}",64,,120,3,,void
226172,BLOCK,-1,,"{
    static std::vector<char*> new_argv;
    new_argv.reserve(argc + 2);
    new_argv.emplace_back(argv[0]);
    new_argv.insert(new_argv.end(), argv, argv + argc);
    new_argv.emplace_back(nullptr);
    argc = new_argv.size() - 1;
    argv = new_argv.data();
  }",29,,123,2,,void
226228,BLOCK,-1,,<empty>,,,,1,,<empty>
226238,BLOCK,-1,,"{
  std::string config;
  int r = ReadFileSync(&config, config_path.c_str());
  if (r != 0) {
    const char* err = uv_strerror(r);
    FPrintF(stderr,
            ""Cannot read single executable configuration from %s: %s\n"",
            config_path,
            err);
    return std::nullopt;
  }

  SeaConfig result;
  JSONParser parser;
  if (!parser.Parse(config)) {
    FPrintF(stderr, ""Cannot parse JSON from %s\n"", config_path);
    return std::nullopt;
  }

  result.main_path =
      parser.GetTopLevelStringField(""main"").value_or(std::string());
  if (result.main_path.empty()) {
    FPrintF(stderr,
            ""\""main\"" field of %s is not a non-empty string\n"",
            config_path);
    return std::nullopt;
  }

  result.output_path =
      parser.GetTopLevelStringField(""output"").value_or(std::string());
  if (result.output_path.empty()) {
    FPrintF(stderr,
            ""\""output\"" field of %s is not a non-empty string\n"",
            config_path);
    return std::nullopt;
 ...",37,,145,2,,void
226254,BLOCK,-1,,"{
    const char* err = uv_strerror(r);
    FPrintF(stderr,
            ""Cannot read single executable configuration from %s: %s\n"",
            config_path,
            err);
    return std::nullopt;
  }",15,,148,2,,void
226278,BLOCK,-1,,"{
    FPrintF(stderr, ""Cannot parse JSON from %s\n"", config_path);
    return std::nullopt;
  }",30,,159,2,,void
226310,BLOCK,-1,,"{
    FPrintF(stderr,
            ""\""main\"" field of %s is not a non-empty string\n"",
            config_path);
    return std::nullopt;
  }",33,,166,2,,void
226342,BLOCK,-1,,"{
    FPrintF(stderr,
            ""\""output\"" field of %s is not a non-empty string\n"",
            config_path);
    return std::nullopt;
  }",35,,175,2,,void
226365,BLOCK,-1,,"{
    FPrintF(stderr,
            ""\""disableExperimentalSEAWarning\"" field of %s is not a Boolean\n"",
            config_path);
    return std::nullopt;
  }",54,,184,2,,void
226379,BLOCK,-1,,"{
    result.flags |= SeaFlags::kDisableExperimentalSeaWarning;
  }",49,,190,2,,void
226393,BLOCK,-1,,"{
  std::string main_script;
  // TODO(joyeecheung): unify the file utils.
  int r = ReadFileSync(&main_script, config.main_path.c_str());
  if (r != 0) {
    const char* err = uv_strerror(r);
    FPrintF(stderr, ""Cannot read main script %s:%s\n"", config.main_path, err);
    return false;
  }

  std::vector<char> sink;
  // TODO(joyeecheung): reuse the SnapshotSerializerDeserializer for this.
  sink.reserve(SeaResource::kHeaderSize + main_script.size());
  const char* pos = reinterpret_cast<const char*>(&kMagic);
  sink.insert(sink.end(), pos, pos + sizeof(kMagic));
  pos = reinterpret_cast<const char*>(&(config.flags));
  sink.insert(sink.end(), pos, pos + sizeof(SeaFlags));
  sink.insert(
      sink.end(), main_script.data(), main_script.data() + main_script.size());

  uv_buf_t buf = uv_buf_init(sink.data(), sink.size());
  r = WriteFileSync(config.output_path.c_str(), buf);
  if (r != 0) {
    const char* err = uv_strerror(r);
    FPrintF(stderr, ""Cannot write output to %s:%s\n""...",60,,197,2,,void
226411,BLOCK,-1,,"{
    const char* err = uv_strerror(r);
    FPrintF(stderr, ""Cannot read main script %s:%s\n"", config.main_path, err);
    return false;
  }",15,,201,2,,void
226527,BLOCK,-1,,"{
    const char* err = uv_strerror(r);
    FPrintF(stderr, ""Cannot write output to %s:%s\n"", config.output_path, err);
    return false;
  }",15,,219,2,,void
226554,BLOCK,-1,,"{
  std::optional<SeaConfig> config_opt =
      ParseSingleExecutableConfig(config_path);
  if (!config_opt.has_value() ||
      !GenerateSingleExecutableBlob(config_opt.value())) {
    return ExitCode::kGenericUserError;
  }

  return ExitCode::kNoFailure;
}",68,,233,2,,void
226573,BLOCK,-1,,"{
    return ExitCode::kGenericUserError;
  }",58,,237,2,,void
226589,BLOCK,-1,,"{
  SetMethod(context,
            target,
            ""isExperimentalSeaWarningNeeded"",
            IsExperimentalSeaWarningNeeded);
}",29,,247,5,,void
226599,BLOCK,-1,,"{
  registry->Register(IsExperimentalSeaWarningNeeded);
}",70,,254,2,,void
226618,BLOCK,-1,,<empty>,1,,1,1,,ANY
226635,BLOCK,-1,,<empty>,1,,1,1,,ANY
226642,BLOCK,-1,,<empty>,,,,3,,<empty>
226646,BLOCK,-1,,<empty>,,,,1,,<empty>
226651,BLOCK,-1,,<empty>,,,,2,,<empty>
226657,BLOCK,-1,,<empty>,,,,3,,<empty>
226663,BLOCK,-1,,<empty>,,,,3,,<empty>
226668,BLOCK,-1,,<empty>,,,,2,,<empty>
226673,BLOCK,-1,,<empty>,,,,2,,<empty>
226678,BLOCK,-1,,<empty>,,,,2,,<empty>
226683,BLOCK,-1,,<empty>,,,,2,,<empty>
226688,BLOCK,-1,,<empty>,,,,2,,<empty>
226693,BLOCK,-1,,<empty>,,,,2,,<empty>
226698,BLOCK,-1,,<empty>,,,,2,,<empty>
226703,BLOCK,-1,,<empty>,,,,2,,<empty>
226708,BLOCK,-1,,<empty>,,,,2,,<empty>
226713,BLOCK,-1,,<empty>,,,,2,,<empty>
226722,BLOCK,-1,,<empty>,,,,4,,<empty>
226726,BLOCK,-1,,<empty>,,,,1,,<empty>
226731,BLOCK,-1,,<empty>,,,,2,,<empty>
226736,BLOCK,-1,,<empty>,,,,2,,<empty>
226741,BLOCK,-1,,<empty>,,,,2,,<empty>
226746,BLOCK,-1,,<empty>,,,,2,,<empty>
226751,BLOCK,-1,,<empty>,,,,2,,<empty>
226756,BLOCK,-1,,<empty>,,,,2,,<empty>
226761,BLOCK,-1,,<empty>,,,,2,,<empty>
226766,BLOCK,-1,,<empty>,,,,2,,<empty>
226771,BLOCK,-1,,<empty>,,,,2,,<empty>
226776,BLOCK,-1,,<empty>,,,,2,,<empty>
226785,BLOCK,-1,,"{
  MakeWeak();
}",39,,100,3,,void
226791,BLOCK,-1,,"{
  Local<Value> args[1] = { message };
  Local<Value> get_data_clone_error =
      object()->Get(env()->context(),
                    env()->get_data_clone_error_string())
                      .ToLocalChecked();

  CHECK(get_data_clone_error->IsFunction());
  MaybeLocal<Value> error =
      get_data_clone_error.As<Function>()->Call(env()->context(),
                                                object(),
                                                arraysize(args),
                                                args);

  if (error.IsEmpty()) return;

  env()->isolate()->ThrowException(error.ToLocalChecked());
}",68,,104,2,,void
226852,BLOCK,-1,,<empty>,24,,118,2,,void
226870,BLOCK,-1,,"{
  Local<Value> args[1] = { shared_array_buffer };
  Local<Value> get_shared_array_buffer_id =
      object()->Get(env()->context(),
                    env()->get_shared_array_buffer_id_string())
                      .ToLocalChecked();

  if (!get_shared_array_buffer_id->IsFunction()) {
    return ValueSerializer::Delegate::GetSharedArrayBufferId(
        isolate, shared_array_buffer);
  }

  MaybeLocal<Value> id =
      get_shared_array_buffer_id.As<Function>()->Call(env()->context(),
                                                      object(),
                                                      arraysize(args),
                                                      args);

  if (id.IsEmpty()) return Nothing<uint32_t>();

  return id.ToLocalChecked()->Uint32Value(env()->context());
}",69,,124,3,,void
226906,BLOCK,-1,,"{
    return ValueSerializer::Delegate::GetSharedArrayBufferId(
        isolate, shared_array_buffer);
  }",50,,131,2,,void
226942,BLOCK,-1,,<empty>,21,,142,2,,void
226962,BLOCK,-1,,"{
  MaybeLocal<Value> ret;
  Local<Value> args[1] = { input };

  Local<Value> write_host_object =
      object()->Get(env()->context(),
                    env()->write_host_object_string()).ToLocalChecked();

  if (!write_host_object->IsFunction()) {
    return ValueSerializer::Delegate::WriteHostObject(isolate, input);
  }

  ret = write_host_object.As<Function>()->Call(env()->context(),
                                               object(),
                                               arraysize(args),
                                               args);

  if (ret.IsEmpty())
    return Nothing<bool>();

  return Just(true);
}",69,,148,3,,void
227003,BLOCK,-1,,"{
    return ValueSerializer::Delegate::WriteHostObject(isolate, input);
  }",41,,156,2,,void
227035,BLOCK,-1,,<empty>,5,,166,2,,void
227045,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  if (!args.IsConstructCall()) {
    return THROW_ERR_CONSTRUCT_CALL_REQUIRED(
        env, ""Class constructor Serializer cannot be invoked without 'new'"");
  }

  new SerializerContext(env, args.This());
}",70,,171,2,,void
227060,BLOCK,-1,,"{
    return THROW_ERR_CONSTRUCT_CALL_REQUIRED(
        env, ""Class constructor Serializer cannot be invoked without 'new'"");
  }",32,,173,2,,void
227076,BLOCK,-1,,"{
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());
  ctx->serializer_.WriteHeader();
}",78,,181,2,,void
227095,BLOCK,-1,,"{
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());
  Maybe<bool> ret =
      ctx->serializer_.WriteValue(ctx->env()->context(), args[0]);

  if (ret.IsJust()) args.GetReturnValue().Set(ret.FromJust());
}",77,,187,2,,void
227128,BLOCK,-1,,<empty>,21,,193,2,,void
227144,BLOCK,-1,,"{
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  bool value = args[0]->BooleanValue(ctx->env()->isolate());
  ctx->serializer_.SetTreatArrayBufferViewsAsHostObjects(value);
}",46,,197,2,,void
227180,BLOCK,-1,,"{
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  // Note: Both ValueSerializer and this Buffer::New() variant use malloc()
  // as the underlying allocator.
  std::pair<uint8_t*, size_t> ret = ctx->serializer_.Release();
  auto buf = Buffer::New(ctx->env(),
                         reinterpret_cast<char*>(ret.first),
                         ret.second);

  if (!buf.IsEmpty()) {
    args.GetReturnValue().Set(buf.ToLocalChecked());
  }
}",80,,205,2,,void
227223,BLOCK,-1,,"{
    args.GetReturnValue().Set(buf.ToLocalChecked());
  }",23,,216,2,,void
227239,BLOCK,-1,,"{
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  Maybe<uint32_t> id = args[0]->Uint32Value(ctx->env()->context());
  if (id.IsNothing()) return;

  if (!args[1]->IsArrayBuffer())
    return node::THROW_ERR_INVALID_ARG_TYPE(
        ctx->env(), ""arrayBuffer must be an ArrayBuffer"");

  Local<ArrayBuffer> ab = args[1].As<ArrayBuffer>();
  ctx->serializer_.TransferArrayBuffer(id.FromJust(), ab);
  return;
}",46,,222,2,,void
227272,BLOCK,-1,,<empty>,23,,227,2,,void
227282,BLOCK,-1,,<empty>,5,,230,2,,void
227321,BLOCK,-1,,"{
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  Maybe<uint32_t> value = args[0]->Uint32Value(ctx->env()->context());
  if (value.IsNothing()) return;

  ctx->serializer_.WriteUint32(value.FromJust());
}",78,,238,2,,void
227354,BLOCK,-1,,<empty>,26,,243,2,,void
227370,BLOCK,-1,,"{
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  Maybe<uint32_t> arg0 = args[0]->Uint32Value(ctx->env()->context());
  Maybe<uint32_t> arg1 = args[1]->Uint32Value(ctx->env()->context());
  if (arg0.IsNothing() || arg1.IsNothing())
    return;

  uint64_t hi = arg0.FromJust();
  uint64_t lo = arg1.FromJust();
  ctx->serializer_.WriteUint64((hi << 32) | lo);
}",78,,248,2,,void
227427,BLOCK,-1,,<empty>,5,,255,2,,void
227458,BLOCK,-1,,"{
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  Maybe<double> value = args[0]->NumberValue(ctx->env()->context());
  if (value.IsNothing()) return;

  ctx->serializer_.WriteDouble(value.FromJust());
}",78,,262,2,,void
227488,BLOCK,-1,,<empty>,26,,267,2,,void
227504,BLOCK,-1,,"{
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  if (!args[0]->IsArrayBufferView()) {
    return node::THROW_ERR_INVALID_ARG_TYPE(
        ctx->env(), ""source must be a TypedArray or a DataView"");
  }

  ArrayBufferViewContents<char> bytes(args[0]);
  ctx->serializer_.WriteRawBytes(bytes.data(), bytes.length());
}",80,,272,2,,void
227521,BLOCK,-1,,"{
    return node::THROW_ERR_INVALID_ARG_TYPE(
        ctx->env(), ""source must be a TypedArray or a DataView"");
  }",38,,276,2,,void
227557,BLOCK,-1,,"{
  object()->Set(env->context(), env->buffer_string(), buffer).Check();

  MakeWeak();
}",57,,291,4,,void
227579,BLOCK,-1,,"{
  Local<Value> read_host_object =
      object()->Get(env()->context(),
                    env()->read_host_object_string()).ToLocalChecked();

  if (!read_host_object->IsFunction()) {
    return ValueDeserializer::Delegate::ReadHostObject(isolate);
  }

  Isolate::AllowJavascriptExecutionScope allow_js(isolate);
  MaybeLocal<Value> ret =
      read_host_object.As<Function>()->Call(env()->context(),
                                            object(),
                                            0,
                                            nullptr);

  if (ret.IsEmpty())
    return MaybeLocal<Object>();

  Local<Value> return_value = ret.ToLocalChecked();
  if (!return_value->IsObject()) {
    env()->ThrowTypeError(""readHostObject must return an object"");
    return MaybeLocal<Object>();
  }

  return return_value.As<Object>();
}",74,,297,2,,void
227607,BLOCK,-1,,"{
    return ValueDeserializer::Delegate::ReadHostObject(isolate);
  }",40,,302,2,,void
227644,BLOCK,-1,,<empty>,5,,314,2,,void
227663,BLOCK,-1,,"{
    env()->ThrowTypeError(""readHostObject must return an object"");
    return MaybeLocal<Object>();
  }",34,,317,2,,void
227680,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  if (!args.IsConstructCall()) {
    return THROW_ERR_CONSTRUCT_CALL_REQUIRED(
        env, ""Class constructor Deserializer cannot be invoked without 'new'"");
  }

  if (!args[0]->IsArrayBufferView()) {
    return node::THROW_ERR_INVALID_ARG_TYPE(
        env, ""buffer must be a TypedArray or a DataView"");
  }

  new DeserializerContext(env, args.This(), args[0]);
}",72,,325,2,,void
227695,BLOCK,-1,,"{
    return THROW_ERR_CONSTRUCT_CALL_REQUIRED(
        env, ""Class constructor Deserializer cannot be invoked without 'new'"");
  }",32,,327,2,,void
227708,BLOCK,-1,,"{
    return node::THROW_ERR_INVALID_ARG_TYPE(
        env, ""buffer must be a TypedArray or a DataView"");
  }",38,,332,2,,void
227730,BLOCK,-1,,"{
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  Maybe<bool> ret = ctx->deserializer_.ReadHeader(ctx->env()->context());

  if (ret.IsJust()) args.GetReturnValue().Set(ret.FromJust());
}",79,,340,2,,void
227760,BLOCK,-1,,<empty>,21,,346,2,,void
227776,BLOCK,-1,,"{
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  MaybeLocal<Value> ret = ctx->deserializer_.ReadValue(ctx->env()->context());

  if (!ret.IsEmpty()) args.GetReturnValue().Set(ret.ToLocalChecked());
}",78,,349,2,,void
227810,BLOCK,-1,,<empty>,23,,355,2,,void
227826,BLOCK,-1,,"{
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  Maybe<uint32_t> id = args[0]->Uint32Value(ctx->env()->context());
  if (id.IsNothing()) return;

  if (args[1]->IsArrayBuffer()) {
    Local<ArrayBuffer> ab = args[1].As<ArrayBuffer>();
    ctx->deserializer_.TransferArrayBuffer(id.FromJust(), ab);
    return;
  }

  if (args[1]->IsSharedArrayBuffer()) {
    Local<SharedArrayBuffer> sab = args[1].As<SharedArrayBuffer>();
    ctx->deserializer_.TransferSharedArrayBuffer(id.FromJust(), sab);
    return;
  }

  return node::THROW_ERR_INVALID_ARG_TYPE(
      ctx->env(), ""arrayBuffer must be an ArrayBuffer or SharedArrayBuffer"");
}",46,,359,2,,void
227859,BLOCK,-1,,<empty>,23,,364,2,,void
227868,BLOCK,-1,,"{
    Local<ArrayBuffer> ab = args[1].As<ArrayBuffer>();
    ctx->deserializer_.TransferArrayBuffer(id.FromJust(), ab);
    return;
  }",33,,366,2,,void
227900,BLOCK,-1,,"{
    Local<SharedArrayBuffer> sab = args[1].As<SharedArrayBuffer>();
    ctx->deserializer_.TransferSharedArrayBuffer(id.FromJust(), sab);
    return;
  }",39,,372,2,,void
227939,BLOCK,-1,,"{
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  args.GetReturnValue().Set(ctx->deserializer_.GetWireFormatVersion());
}",46,,383,2,,void
227965,BLOCK,-1,,"{
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  uint32_t value;
  bool ok = ctx->deserializer_.ReadUint32(&value);
  if (!ok) return ctx->env()->ThrowError(""ReadUint32() failed"");
  return args.GetReturnValue().Set(value);
}",79,,390,2,,void
227989,BLOCK,-1,,<empty>,12,,396,2,,void
228012,BLOCK,-1,,"{
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  uint64_t value;
  bool ok = ctx->deserializer_.ReadUint64(&value);
  if (!ok) return ctx->env()->ThrowError(""ReadUint64() failed"");

  uint32_t hi = static_cast<uint32_t>(value >> 32);
  uint32_t lo = static_cast<uint32_t>(value);

  Isolate* isolate = ctx->env()->isolate();

  Local<Value> ret[] = {
    Integer::NewFromUnsigned(isolate, hi),
    Integer::NewFromUnsigned(isolate, lo)
  };
  return args.GetReturnValue().Set(Array::New(isolate, ret, arraysize(ret)));
}",79,,400,2,,void
228036,BLOCK,-1,,<empty>,12,,406,2,,void
228106,BLOCK,-1,,"{
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  double value;
  bool ok = ctx->deserializer_.ReadDouble(&value);
  if (!ok) return ctx->env()->ThrowError(""ReadDouble() failed"");
  return args.GetReturnValue().Set(value);
}",79,,420,2,,void
228130,BLOCK,-1,,<empty>,12,,426,2,,void
228153,BLOCK,-1,,"{
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  Maybe<int64_t> length_arg = args[0]->IntegerValue(ctx->env()->context());
  if (length_arg.IsNothing()) return;
  size_t length = length_arg.FromJust();

  const void* data;
  bool ok = ctx->deserializer_.ReadRawBytes(length, &data);
  if (!ok) return ctx->env()->ThrowError(""ReadRawBytes() failed"");

  const uint8_t* position = reinterpret_cast<const uint8_t*>(data);
  CHECK_GE(position, ctx->data_);
  CHECK_LE(position + length, ctx->data_ + ctx->length_);

  const uint32_t offset = static_cast<uint32_t>(position - ctx->data_);
  CHECK_EQ(ctx->data_ + offset, position);

  args.GetReturnValue().Set(offset);
}",46,,431,2,,void
228186,BLOCK,-1,,<empty>,31,,436,2,,void
228211,BLOCK,-1,,<empty>,12,,441,2,,void
228275,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> ser =
      NewFunctionTemplate(isolate, SerializerContext::New);

  ser->InstanceTemplate()->SetInternalFieldCount(
      SerializerContext::kInternalFieldCount);

  SetProtoMethod(isolate, ser, ""writeHeader"", SerializerContext::WriteHeader);
  SetProtoMethod(isolate, ser, ""writeValue"", SerializerContext::WriteValue);
  SetProtoMethod(
      isolate, ser, ""releaseBuffer"", SerializerContext::ReleaseBuffer);
  SetProtoMethod(isolate,
                 ser,
                 ""transferArrayBuffer"",
                 SerializerContext::TransferArrayBuffer);
  SetProtoMethod(isolate, ser, ""writeUint32"", SerializerContext::WriteUint32);
  SetProtoMethod(isolate, ser, ""writeUint64"", SerializerContext::WriteUint64);
  SetProtoMethod(isolate, ser, ""writeDouble"", SerializerContext::WriteDouble);
  SetProtoMethod(
      isolate, ser, ""writeRawBytes"", SerializerContext::WriteRaw...",29,,456,5,,void
228479,BLOCK,-1,,"{
  registry->Register(SerializerContext::New);

  registry->Register(SerializerContext::WriteHeader);
  registry->Register(SerializerContext::WriteValue);
  registry->Register(SerializerContext::ReleaseBuffer);
  registry->Register(SerializerContext::TransferArrayBuffer);
  registry->Register(SerializerContext::WriteUint32);
  registry->Register(SerializerContext::WriteUint64);
  registry->Register(SerializerContext::WriteDouble);
  registry->Register(SerializerContext::WriteRawBytes);
  registry->Register(SerializerContext::SetTreatArrayBufferViewsAsHostObjects);

  registry->Register(DeserializerContext::New);
  registry->Register(DeserializerContext::ReadHeader);
  registry->Register(DeserializerContext::ReadValue);
  registry->Register(DeserializerContext::GetWireFormatVersion);
  registry->Register(DeserializerContext::TransferArrayBuffer);
  registry->Register(DeserializerContext::ReadUint32);
  registry->Register(DeserializerContext::ReadUint64);
  registry->Register(Deseria...",70,,514,2,,void
228626,BLOCK,-1,,<empty>,1,,1,1,,ANY
228632,BLOCK,-1,,"{
  ShadowRealm* realm = new ShadowRealm(env);
  env->AssignToContext(realm->context(), realm, ContextInfo(""""));

  // We do not expect the realm bootstrapping to throw any
  // exceptions. If it does, exit the current Node.js instance.
  TryCatchScope try_catch(env, TryCatchScope::CatchMode::kFatal);
  if (realm->RunBootstrapping().IsEmpty()) {
    delete realm;
    return nullptr;
  }
  return realm;
}",49,,16,2,,void
228666,BLOCK,-1,,"{
    delete realm;
    return nullptr;
  }",44,,23,2,,void
228677,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(initiator_context);
  ShadowRealm* realm = ShadowRealm::New(env);
  if (realm != nullptr) {
    return realm->context();
  }
  return MaybeLocal<Context>();
}",39,,32,2,,void
228698,BLOCK,-1,,"{
    return realm->context();
  }",25,,35,2,,void
228710,BLOCK,-1,,"{
  ShadowRealm* realm = data.GetParameter();
  delete realm;
}",79,,42,2,,void
228724,BLOCK,-1,,"{
  env->TrackShadowRealm(this);
  context_.SetWeak(this, WeakCallback, v8::WeakCallbackType::kParameter);
  CreateProperties();
}",60,,48,2,,void
228745,BLOCK,-1,,"{
  while (HasCleanupHooks()) {
    RunCleanup();
  }
  if (env_ != nullptr) {
    env_->UntrackShadowRealm(this);
  }
}",29,,54,1,,void
228748,BLOCK,-1,,"{
    RunCleanup();
  }",29,,55,2,,void
228754,BLOCK,-1,,"{
    env_->UntrackShadowRealm(this);
  }",24,,58,2,,void
228763,BLOCK,-1,,"{
  CHECK_NOT_NULL(env_);
  env_ = nullptr;  // This means that the shadow realm has out-lived the
                   // environment.
}",43,,63,1,,void
228771,BLOCK,-1,,"{
  Local<Context> ctx = PersistentToLocal::Default(isolate_, context_);
  DCHECK(!ctx.IsEmpty());
  return ctx;
}",53,,69,1,,void
228797,BLOCK,-1,,"{
  HandleScope scope(isolate_);

  // Skip ""internal/bootstrap/node"" as it installs node globals and per-isolate
  // callbacks.

  if (!env_->no_browser_globals()) {
    if (ExecuteBootstrapper(""internal/bootstrap/web/exposed-wildcard"")
            .IsEmpty()) {
      return MaybeLocal<Value>();
    }
  }

  return v8::True(isolate_);
}",57,,104,1,,void
228807,BLOCK,-1,,"{
    if (ExecuteBootstrapper(""internal/bootstrap/web/exposed-wildcard"")
            .IsEmpty()) {
      return MaybeLocal<Value>();
    }
  }",36,,110,2,,void
228814,BLOCK,-1,,"{
      return MaybeLocal<Value>();
    }",25,,112,2,,void
228833,BLOCK,-1,,<empty>,1,,1,1,,ANY
228846,BLOCK,-1,,<empty>,1,,1,1,,ANY
228853,BLOCK,-1,,<empty>,1,,1,1,,ANY
228856,BLOCK,-1,,"{
  return nullptr;
}",64,,9,1,,void
228863,BLOCK,-1,,"{
      if (bootstrapCatch.HasCaught()) {
        PrintCaughtException(
            isolate, isolate->GetCurrentContext(), bootstrapCatch);
      }
    }",47,,867,1,,void
228869,BLOCK,-1,,"{
        PrintCaughtException(
            isolate, isolate->GetCurrentContext(), bootstrapCatch);
      }",39,,868,2,,void
228885,BLOCK,-1,,{ realm->PrintInfoForSnapshot(); },44,,948,2,,void
228895,BLOCK,-1,,"{
    // If there are any BaseObjects that are not snapshotable left
    // during context serialization, V8 would crash due to unregistered
    // global handles and print detailed information about them.
    if (!obj->is_snapshotable()) {
      return;
    }
    SnapshotableObject* ptr = static_cast<SnapshotableObject*>(obj);

    std::string type_name = ptr->GetTypeName();
    per_process::Debug(DebugCategory::MKSNAPSHOT,
                       ""Serialize snapshotable object %i (%p), ""
                       ""object=%p, type=%s\n"",
                       static_cast<int>(i),
                       ptr,
                       *(ptr->object()),
                       type_name);

    if (ptr->PrepareForSerialization(context, creator)) {
      SnapshotIndex index = creator->AddData(context, obj->object());
      per_process::Debug(DebugCategory::MKSNAPSHOT,
                         ""Serialized with index=%d\n"",
                         static_cast<int>(index));
      info->native_ob...",49,,1147,2,,void
228902,BLOCK,-1,,"{
      return;
    }",34,,1151,2,,void
228942,BLOCK,-1,,"{
      SnapshotIndex index = creator->AddData(context, obj->object());
      per_process::Debug(DebugCategory::MKSNAPSHOT,
                         ""Serialized with index=%d\n"",
                         static_cast<int>(index));
      info->native_objects.push_back({type_name, i, index});
    }",57,,1165,2,,void
228986,BLOCK,-1,,"{
                      Environment* env = Environment::GetCurrent(args);
                      Local<Value> require_fn = args[0];
                      Local<Value> runcjs_fn = args[1];
                      CHECK(require_fn->IsFunction());
                      CHECK(runcjs_fn->IsFunction());
                      MaybeLocal<Value> retval = env->embedder_entry_point()(
                          {env->process_object(),
                           require_fn.As<Function>(),
                           runcjs_fn.As<Function>()});
                      if (!retval.IsEmpty())
                        args.GetReturnValue().Set(retval.ToLocalChecked());
                    }",65,,1185,2,,void
229053,BLOCK,-1,,<empty>,25,,1196,2,,void
229123,BLOCK,-1,,<empty>,1,,1,1,,ANY
229129,BLOCK,-1,,"{
  output << ""<builtins::CodeCacheInfo id="" << info.id
         << "", length="" << info.data.length << "">\n"";
  return output;
}",63,,54,3,,void
229154,BLOCK,-1,,"{
  output << ""{\n"";
  for (const auto& info : vec) {
    output << info;
  }
  output << ""}\n"";
  return output;
}",75,,61,3,,void
229161,BLOCK,-1,,"{
    output << info;
  }",32,,63,3,,void
229175,BLOCK,-1,,"{
  output << ""{\n"";
  for (const auto& i : vec) {
    output << i << "","";
  }
  output << ""}"";
  return output;
}",59,,71,3,,void
229182,BLOCK,-1,,"{
    output << i << "","";
  }",29,,73,3,,void
229198,BLOCK,-1,,"{
  output << ""{\n"";
  for (const auto& info : vec) {
    output << ""  "" << info << "",\n"";
  }
  output << ""}"";
  return output;
}",60,,81,3,,void
229205,BLOCK,-1,,"{
    output << ""  "" << info << "",\n"";
  }",32,,83,3,,void
229223,BLOCK,-1,,"{
  output << ""{ \"""" << info.name << ""\"", "" << std::to_string(info.id) << "", ""
         << std::to_string(info.index) << "" }"";
  return output;
}",70,,90,3,,void
229260,BLOCK,-1,,"{
  output << ""{\n"";
  for (const auto& info : vec) {
    output << ""  \"""" << info << ""\"",\n"";
  }
  output << ""}"";
  return output;
}",63,,97,3,,void
229267,BLOCK,-1,,"{
    output << ""  \"""" << info << ""\"",\n"";
  }",32,,99,3,,void
229285,BLOCK,-1,,"{
  output << ""{\n""
         << ""// -- builtins begins --\n""
         << i.builtins << "",\n""
         << ""// -- builtins ends --\n""
         << ""// -- persistent_values begins --\n""
         << i.persistent_values << "",\n""
         << ""// -- persistent_values ends --\n""
         << ""// -- native_objects begins --\n""
         << i.native_objects << "",\n""
         << ""// -- native_objects ends --\n""
         << i.context << "",  // context\n""
         << ""}"";
  return output;
}",77,,106,3,,void
229334,BLOCK,-1,,"{
  output << ""{\n""
         << ""// -- async_hooks begins --\n""
         << i.async_hooks << "",\n""
         << ""// -- async_hooks ends --\n""
         << i.tick_info << "",  // tick_info\n""
         << i.immediate_info << "",  // immediate_info\n""
         << i.timeout_info << "",  // timeout_info\n""
         << ""// -- performance_state begins --\n""
         << i.performance_state << "",\n""
         << ""// -- performance_state ends --\n""
         << i.exit_info << "",  // exit_info\n""
         << i.stream_base_state << "",  // stream_base_state\n""
         << i.should_abort_on_uncaught_toggle
         << "",  // should_abort_on_uncaught_toggle\n""
         << ""// -- principal_realm begins --\n""
         << i.principal_realm << "",\n""
         << ""// -- principal_realm ends --\n""
         << ""}"";
  return output;
}",75,,122,3,,void
229413,BLOCK,-1,,<empty>,16,,149,2,,void
229417,BLOCK,-1,,<empty>,,,,1,,<empty>
229422,BLOCK,-1,,<empty>,45,,162,1,,void
229427,BLOCK,-1,,<empty>,,,,2,,<empty>
229431,BLOCK,-1,,"{
  Debug(""Read<v8::StartupData>()\n"");

  int raw_size = ReadArithmetic<int>();
  Debug(""size=%d\n"", raw_size);

  CHECK_GT(raw_size, 0);  // There should be no startup data of size 0.
  // The data pointer of v8::StartupData would be deleted so it must be new'ed.
  std::unique_ptr<char> buf = std::unique_ptr<char>(new char[raw_size]);
  ReadArithmetic<char>(buf.get(), raw_size);

  return v8::StartupData{buf.release(), raw_size};
}",46,,174,1,,void
229471,BLOCK,-1,,"{
  Debug(""\nWrite<v8::StartupData>() size=%d\n"", data.raw_size);

  CHECK_GT(data.raw_size, 0);  // There should be no startup data of size 0.
  size_t written_total = WriteArithmetic<int>(data.raw_size);
  written_total +=
      WriteArithmetic<char>(data.data, static_cast<size_t>(data.raw_size));

  Debug(""Write<v8::StartupData>() wrote %d bytes\n\n"", written_total);
  return written_total;
}",63,,189,2,,void
229508,BLOCK,-1,,"{
  Debug(""Read<builtins::CodeCacheInfo>()\n"");

  std::string id = ReadString();
  auto owning_ptr =
      std::make_shared<std::vector<uint8_t>>(ReadVector<uint8_t>());
  builtins::BuiltinCodeCacheData code_cache_data{std::move(owning_ptr)};
  builtins::CodeCacheInfo result{id, code_cache_data};

  if (is_debug) {
    std::string str = ToStr(result);
    Debug(""Read<builtins::CodeCacheInfo>() %s\n"", str.c_str());
  }
  return result;
}",54,,207,1,,void
229546,BLOCK,-1,,"{
    std::string str = ToStr(result);
    Debug(""Read<builtins::CodeCacheInfo>() %s\n"", str.c_str());
  }",17,,216,2,,void
229564,BLOCK,-1,,"{
  Debug(""\nWrite<builtins::CodeCacheInfo>() id = %s""
        "", length=%d\n"",
        info.id.c_str(),
        info.data.length);

  size_t written_total = WriteString(info.id);

  written_total += WriteArithmetic<size_t>(info.data.length);
  written_total += WriteArithmetic(info.data.data, info.data.length);

  Debug(""Write<builtins::CodeCacheInfo>() wrote %d bytes\n"", written_total);
  return written_total;
}",71,,224,2,,void
229617,BLOCK,-1,,"{
  Debug(""Read<PropInfo>()\n"");

  PropInfo result;
  result.name = ReadString();
  result.id = ReadArithmetic<uint32_t>();
  result.index = ReadArithmetic<SnapshotIndex>();

  if (is_debug) {
    std::string str = ToStr(result);
    Debug(""Read<PropInfo>() %s\n"", str.c_str());
  }

  return result;
}",39,,246,1,,void
229638,BLOCK,-1,,"{
    std::string str = ToStr(result);
    Debug(""Read<PropInfo>() %s\n"", str.c_str());
  }",17,,254,2,,void
229656,BLOCK,-1,,"{
  if (is_debug) {
    std::string str = ToStr(data);
    Debug(""Write<PropInfo>() %s\n"", str.c_str());
  }

  size_t written_total = WriteString(data.name);
  written_total += WriteArithmetic<uint32_t>(data.id);
  written_total += WriteArithmetic<SnapshotIndex>(data.index);

  Debug(""Write<PropInfo>() wrote %d bytes\n"", written_total);
  return written_total;
}",56,,263,2,,void
229659,BLOCK,-1,,"{
    std::string str = ToStr(data);
    Debug(""Write<PropInfo>() %s\n"", str.c_str());
  }",17,,264,2,,void
229704,BLOCK,-1,,"{
  Debug(""Read<AsyncHooks::SerializeInfo>()\n"");

  AsyncHooks::SerializeInfo result;
  result.async_ids_stack = ReadArithmetic<AliasedBufferIndex>();
  result.fields = ReadArithmetic<AliasedBufferIndex>();
  result.async_id_fields = ReadArithmetic<AliasedBufferIndex>();
  result.js_execution_async_resources = ReadArithmetic<SnapshotIndex>();
  result.native_execution_async_resources = ReadVector<SnapshotIndex>();

  if (is_debug) {
    std::string str = ToStr(result);
    Debug(""Read<AsyncHooks::SerializeInfo>() %s\n"", str.c_str());
  }

  return result;
}",56,,286,1,,void
229735,BLOCK,-1,,"{
    std::string str = ToStr(result);
    Debug(""Read<AsyncHooks::SerializeInfo>() %s\n"", str.c_str());
  }",17,,296,2,,void
229753,BLOCK,-1,,"{
  if (is_debug) {
    std::string str = ToStr(data);
    Debug(""Write<AsyncHooks::SerializeInfo>() %s\n"", str.c_str());
  }

  size_t written_total =
      WriteArithmetic<AliasedBufferIndex>(data.async_ids_stack);
  written_total += WriteArithmetic<AliasedBufferIndex>(data.fields);
  written_total += WriteArithmetic<AliasedBufferIndex>(data.async_id_fields);
  written_total +=
      WriteArithmetic<SnapshotIndex>(data.js_execution_async_resources);
  written_total +=
      WriteVector<SnapshotIndex>(data.native_execution_async_resources);

  Debug(""Write<AsyncHooks::SerializeInfo>() wrote %d bytes\n"", written_total);
  return written_total;
}",73,,304,2,,void
229756,BLOCK,-1,,"{
    std::string str = ToStr(data);
    Debug(""Write<AsyncHooks::SerializeInfo>() %s\n"", str.c_str());
  }",17,,305,2,,void
229822,BLOCK,-1,,"{
  Debug(""Read<TickInfo::SerializeInfo>()\n"");

  TickInfo::SerializeInfo result;
  result.fields = ReadArithmetic<AliasedBufferIndex>();

  if (is_debug) {
    std::string str = ToStr(result);
    Debug(""Read<TickInfo::SerializeInfo>() %s\n"", str.c_str());
  }

  return result;
}",54,,326,1,,void
229833,BLOCK,-1,,"{
    std::string str = ToStr(result);
    Debug(""Read<TickInfo::SerializeInfo>() %s\n"", str.c_str());
  }",17,,332,2,,void
229851,BLOCK,-1,,"{
  if (is_debug) {
    std::string str = ToStr(data);
    Debug(""Write<TickInfo::SerializeInfo>() %s\n"", str.c_str());
  }

  size_t written_total = WriteArithmetic<AliasedBufferIndex>(data.fields);

  Debug(""Write<TickInfo::SerializeInfo>() wrote %d bytes\n"", written_total);
  return written_total;
}",71,,341,2,,void
229854,BLOCK,-1,,"{
    std::string str = ToStr(data);
    Debug(""Write<TickInfo::SerializeInfo>() %s\n"", str.c_str());
  }",17,,342,2,,void
229884,BLOCK,-1,,"{
  Debug(""Read<ImmediateInfo::SerializeInfo>()\n"");

  ImmediateInfo::SerializeInfo result;
  result.fields = ReadArithmetic<AliasedBufferIndex>();
  if (is_debug) {
    std::string str = ToStr(result);
    Debug(""Read<ImmediateInfo::SerializeInfo>() %s\n"", str.c_str());
  }
  return result;
}",59,,356,1,,void
229895,BLOCK,-1,,"{
    std::string str = ToStr(result);
    Debug(""Read<ImmediateInfo::SerializeInfo>() %s\n"", str.c_str());
  }",17,,361,2,,void
229913,BLOCK,-1,,"{
  if (is_debug) {
    std::string str = ToStr(data);
    Debug(""Write<ImmediateInfo::SerializeInfo>() %s\n"", str.c_str());
  }

  size_t written_total = WriteArithmetic<AliasedBufferIndex>(data.fields);

  Debug(""Write<ImmediateInfo::SerializeInfo>() wrote %d bytes\n"",
        written_total);
  return written_total;
}",76,,369,2,,void
229916,BLOCK,-1,,"{
    std::string str = ToStr(data);
    Debug(""Write<ImmediateInfo::SerializeInfo>() %s\n"", str.c_str());
  }",17,,370,2,,void
229946,BLOCK,-1,,"{
  Debug(""Read<PerformanceState::SerializeInfo>()\n"");

  performance::PerformanceState::SerializeInfo result;
  result.root = ReadArithmetic<AliasedBufferIndex>();
  result.milestones = ReadArithmetic<AliasedBufferIndex>();
  result.observers = ReadArithmetic<AliasedBufferIndex>();
  if (is_debug) {
    std::string str = ToStr(result);
    Debug(""Read<PerformanceState::SerializeInfo>() %s\n"", str.c_str());
  }
  return result;
}",75,,387,1,,void
229967,BLOCK,-1,,"{
    std::string str = ToStr(result);
    Debug(""Read<PerformanceState::SerializeInfo>() %s\n"", str.c_str());
  }",17,,394,2,,void
229985,BLOCK,-1,,"{
  if (is_debug) {
    std::string str = ToStr(data);
    Debug(""Write<PerformanceState::SerializeInfo>() %s\n"", str.c_str());
  }

  size_t written_total = WriteArithmetic<AliasedBufferIndex>(data.root);
  written_total += WriteArithmetic<AliasedBufferIndex>(data.milestones);
  written_total += WriteArithmetic<AliasedBufferIndex>(data.observers);

  Debug(""Write<PerformanceState::SerializeInfo>() wrote %d bytes\n"",
        written_total);
  return written_total;
}",63,,403,2,,void
229988,BLOCK,-1,,"{
    std::string str = ToStr(data);
    Debug(""Write<PerformanceState::SerializeInfo>() %s\n"", str.c_str());
  }",17,,404,2,,void
230036,BLOCK,-1,,"{
  Debug(""Read<IsolateDataSerializeInfo>()\n"");

  IsolateDataSerializeInfo result;
  result.primitive_values = ReadVector<SnapshotIndex>();
  result.template_values = ReadVector<PropInfo>();
  if (is_debug) {
    std::string str = ToStr(result);
    Debug(""Read<IsolateDataSerializeInfo>() %s\n"", str.c_str());
  }
  return result;
}",55,,424,1,,void
230052,BLOCK,-1,,"{
    std::string str = ToStr(result);
    Debug(""Read<IsolateDataSerializeInfo>() %s\n"", str.c_str());
  }",17,,430,2,,void
230070,BLOCK,-1,,"{
  if (is_debug) {
    std::string str = ToStr(data);
    Debug(""Write<IsolateDataSerializeInfo>() %s\n"", str.c_str());
  }

  size_t written_total = WriteVector<SnapshotIndex>(data.primitive_values);
  written_total += WriteVector<PropInfo>(data.template_values);

  Debug(""Write<IsolateDataSerializeInfo>() wrote %d bytes\n"", written_total);
  return written_total;
}",72,,438,2,,void
230073,BLOCK,-1,,"{
    std::string str = ToStr(data);
    Debug(""Write<IsolateDataSerializeInfo>() %s\n"", str.c_str());
  }",17,,439,2,,void
230112,BLOCK,-1,,"{
  Debug(""Read<RealmSerializeInfo>()\n"");
  RealmSerializeInfo result;
  result.builtins = ReadVector<std::string>();
  result.persistent_values = ReadVector<PropInfo>();
  result.native_objects = ReadVector<PropInfo>();
  result.context = ReadArithmetic<SnapshotIndex>();
  return result;
}",49,,452,1,,void
230143,BLOCK,-1,,"{
  if (is_debug) {
    std::string str = ToStr(data);
    Debug(""\nWrite<RealmSerializeInfo>() %s\n"", str.c_str());
  }

  // Use += here to ensure order of evaluation.
  size_t written_total = WriteVector<std::string>(data.builtins);
  written_total += WriteVector<PropInfo>(data.persistent_values);
  written_total += WriteVector<PropInfo>(data.native_objects);
  written_total += WriteArithmetic<SnapshotIndex>(data.context);

  Debug(""Write<RealmSerializeInfo>() wrote %d bytes\n"", written_total);
  return written_total;
}",66,,463,2,,void
230146,BLOCK,-1,,"{
    std::string str = ToStr(data);
    Debug(""\nWrite<RealmSerializeInfo>() %s\n"", str.c_str());
  }",17,,464,2,,void
230205,BLOCK,-1,,"{
  Debug(""Read<EnvSerializeInfo>()\n"");
  EnvSerializeInfo result;
  result.async_hooks = Read<AsyncHooks::SerializeInfo>();
  result.tick_info = Read<TickInfo::SerializeInfo>();
  result.immediate_info = Read<ImmediateInfo::SerializeInfo>();
  result.timeout_info = ReadArithmetic<AliasedBufferIndex>();
  result.performance_state =
      Read<performance::PerformanceState::SerializeInfo>();
  result.exit_info = ReadArithmetic<AliasedBufferIndex>();
  result.stream_base_state = ReadArithmetic<AliasedBufferIndex>();
  result.should_abort_on_uncaught_toggle = ReadArithmetic<AliasedBufferIndex>();
  result.principal_realm = Read<RealmSerializeInfo>();
  return result;
}",47,,480,1,,void
230264,BLOCK,-1,,"{
  if (is_debug) {
    std::string str = ToStr(data);
    Debug(""\nWrite<EnvSerializeInfo>() %s\n"", str.c_str());
  }

  // Use += here to ensure order of evaluation.
  size_t written_total = Write<AsyncHooks::SerializeInfo>(data.async_hooks);
  written_total += Write<TickInfo::SerializeInfo>(data.tick_info);
  written_total += Write<ImmediateInfo::SerializeInfo>(data.immediate_info);
  written_total += WriteArithmetic<AliasedBufferIndex>(data.timeout_info);
  written_total += Write<performance::PerformanceState::SerializeInfo>(
      data.performance_state);
  written_total += WriteArithmetic<AliasedBufferIndex>(data.exit_info);
  written_total += WriteArithmetic<AliasedBufferIndex>(data.stream_base_state);
  written_total +=
      WriteArithmetic<AliasedBufferIndex>(data.should_abort_on_uncaught_toggle);
  written_total += Write<RealmSerializeInfo>(data.principal_realm);

  Debug(""Write<EnvSerializeInfo>() wrote %d bytes\n"", written_total);
  return written_total;
}",64,,497,2,,void
230267,BLOCK,-1,,"{
    std::string str = ToStr(data);
    Debug(""\nWrite<EnvSerializeInfo>() %s\n"", str.c_str());
  }",17,,498,2,,void
230358,BLOCK,-1,,"{
  Debug(""Read<SnapshotMetadata>()\n"");

  SnapshotMetadata result;
  result.type = static_cast<SnapshotMetadata::Type>(ReadArithmetic<uint8_t>());
  result.node_version = ReadString();
  result.node_arch = ReadString();
  result.node_platform = ReadString();
  result.v8_cache_version_tag = ReadArithmetic<uint32_t>();

  if (is_debug) {
    std::string str = ToStr(result);
    Debug(""Read<SnapshotMetadata>() %s\n"", str.c_str());
  }
  return result;
}",47,,530,1,,void
230391,BLOCK,-1,,"{
    std::string str = ToStr(result);
    Debug(""Read<SnapshotMetadata>() %s\n"", str.c_str());
  }",17,,540,2,,void
230409,BLOCK,-1,,"{
  if (is_debug) {
    std::string str = ToStr(data);
    Debug(""\nWrite<SnapshotMetadata>() %s\n"", str.c_str());
  }
  size_t written_total = 0;
  // We need the Node.js version, platform and arch to match because
  // Node.js may perform synchronizations that are platform-specific and they
  // can be changed in semver-patches.
  Debug(""Write snapshot type %"" PRIu8 ""\n"", static_cast<uint8_t>(data.type));
  written_total += WriteArithmetic<uint8_t>(static_cast<uint8_t>(data.type));
  Debug(""Write Node.js version %s\n"", data.node_version.c_str());
  written_total += WriteString(data.node_version);
  Debug(""Write Node.js arch %s\n"", data.node_arch);
  written_total += WriteString(data.node_arch);
  Debug(""Write Node.js platform %s\n"", data.node_platform);
  written_total += WriteString(data.node_platform);
  Debug(""Write V8 cached data version tag %"" PRIx32 ""\n"",
        data.v8_cache_version_tag);
  written_total += WriteArithmetic<uint32_t>(data.v8_cache_version_tag);
  return wri...",64,,548,2,,void
230412,BLOCK,-1,,"{
    std::string str = ToStr(data);
    Debug(""\nWrite<SnapshotMetadata>() %s\n"", str.c_str());
  }",17,,549,2,,void
230491,BLOCK,-1,,"{
  SnapshotSerializer w;
  w.Debug(""SnapshotData::ToBlob()\n"");

  size_t written_total = 0;

  // Metadata
  w.Debug(""Write magic %"" PRIx32 ""\n"", kMagic);
  written_total += w.WriteArithmetic<uint32_t>(kMagic);
  w.Debug(""Write metadata\n"");
  written_total += w.Write<SnapshotMetadata>(metadata);

  written_total += w.Write<v8::StartupData>(v8_snapshot_blob_data);
  w.Debug(""Write isolate_data_indices\n"");
  written_total += w.Write<IsolateDataSerializeInfo>(isolate_data_info);
  written_total += w.Write<EnvSerializeInfo>(env_info);
  w.Debug(""Write code_cache\n"");
  written_total += w.WriteVector<builtins::CodeCacheInfo>(code_cache);
  w.Debug(""SnapshotData::ToBlob() Wrote %d bytes\n"", written_total);
  return w.sink;
}",48,,582,1,,void
230590,BLOCK,-1,,"{
  const std::vector<char> sink = ToBlob();
  size_t num_written = fwrite(sink.data(), sink.size(), 1, out);
  CHECK_EQ(num_written, 1);
  CHECK_EQ(fflush(out), 0);
}",44,,604,2,,void
230620,BLOCK,-1,,"{
  return data != nullptr ? data->impl_ : nullptr;
}",39,,612,2,,void
230633,BLOCK,-1,,"{
  return EmbedderSnapshotData::Pointer{new EmbedderSnapshotData(this, false)};
}",71,,616,1,,void
230646,BLOCK,-1,,"{
  return FromBlob(out, ReadFileSync(in));
}",58,,620,3,,void
230657,BLOCK,-1,,"{
  return FromBlob(out, std::string_view(in.data(), in.size()));
}",77,,624,3,,void
230678,BLOCK,-1,,"{
  SnapshotDeserializer r(in);
  r.Debug(""SnapshotData::FromBlob()\n"");

  DCHECK_EQ(out->data_ownership, SnapshotData::DataOwnership::kOwned);

  // Metadata
  uint32_t magic = r.ReadArithmetic<uint32_t>();
  r.Debug(""Read magic %"" PRIx32 ""\n"", magic);
  CHECK_EQ(magic, kMagic);
  out->metadata = r.Read<SnapshotMetadata>();
  r.Debug(""Read metadata\n"");
  if (!out->Check()) {
    return false;
  }

  out->v8_snapshot_blob_data = r.Read<v8::StartupData>();
  r.Debug(""Read isolate_data_info\n"");
  out->isolate_data_info = r.Read<IsolateDataSerializeInfo>();
  out->env_info = r.Read<EnvSerializeInfo>();
  r.Debug(""Read code_cache\n"");
  out->code_cache = r.ReadVector<builtins::CodeCacheInfo>();

  r.Debug(""SnapshotData::FromBlob() read %d bytes\n"", r.read_total);
  return true;
}",69,,628,3,,void
230726,BLOCK,-1,,"{
    return false;
  }",22,,640,2,,void
230784,BLOCK,-1,,"{
  if (metadata.node_version != per_process::metadata.versions.node) {
    fprintf(stderr,
            ""Failed to load the startup snapshot because it was built with""
            ""Node.js version %s and the current Node.js version is %s.\n"",
            metadata.node_version.c_str(),
            NODE_VERSION);
    return false;
  }

  if (metadata.node_arch != per_process::metadata.arch) {
    fprintf(stderr,
            ""Failed to load the startup snapshot because it was built with""
            ""architecture %s and the architecture is %s.\n"",
            metadata.node_arch.c_str(),
            NODE_ARCH);
    return false;
  }

  if (metadata.node_platform != per_process::metadata.platform) {
    fprintf(stderr,
            ""Failed to load the startup snapshot because it was built with""
            ""platform %s and the current platform is %s.\n"",
            metadata.node_platform.c_str(),
            NODE_PLATFORM);
    return false;
  }

  uint32_t current_cache_version = v8::Sc...",34,,655,1,,void
230797,BLOCK,-1,,"{
    fprintf(stderr,
            ""Failed to load the startup snapshot because it was built with""
            ""Node.js version %s and the current Node.js version is %s.\n"",
            metadata.node_version.c_str(),
            NODE_VERSION);
    return false;
  }",69,,656,2,,void
230820,BLOCK,-1,,"{
    fprintf(stderr,
            ""Failed to load the startup snapshot because it was built with""
            ""architecture %s and the architecture is %s.\n"",
            metadata.node_arch.c_str(),
            NODE_ARCH);
    return false;
  }",57,,665,2,,void
230843,BLOCK,-1,,"{
    fprintf(stderr,
            ""Failed to load the startup snapshot because it was built with""
            ""platform %s and the current platform is %s.\n"",
            metadata.node_platform.c_str(),
            NODE_PLATFORM);
    return false;
  }",65,,674,2,,void
230881,BLOCK,-1,,"{
    // For now we only do this check for the customized snapshots - we know
    // that the flags we use in the default snapshot are limited and safe
    // enough so we can relax the constraints for it.
    fprintf(stderr,
            ""Failed to load the startup snapshot because it was built with ""
            ""a different version of V8 or with different V8 configurations.\n""
            ""Expected tag %"" PRIx32 "", read %"" PRIx32 ""\n"",
            current_cache_version,
            metadata.v8_cache_version_tag);
    return false;
  }",66,,685,2,,void
230890,BLOCK,-1,,"{
  if (data_ownership == DataOwnership::kOwned &&
      v8_snapshot_blob_data.data != nullptr) {
    delete[] v8_snapshot_blob_data.data;
  }
}",31,,702,1,,void
230903,BLOCK,-1,,"{
    delete[] v8_snapshot_blob_data.data;
  }",46,,704,2,,void
230914,BLOCK,-1,,"{
  for (size_t i = 0; i < size; i++) {
    *ss << std::to_string(vec[i]) << (i == size - 1 ? '\n' : ',');
  }
}",63,,710,4,,void
230916,BLOCK,-1,,<empty>,3,,711,1,,void
230926,BLOCK,4,,"{
    *ss << std::to_string(vec[i]) << (i == size - 1 ? '\n' : ',');
  }",37,,711,4,,void
230950,BLOCK,-1,,"{
  char buf[64] = {0};
  size_t size = id.size();
  CHECK_LT(size, sizeof(buf));
  for (size_t i = 0; i < size; ++i) {
    char ch = id[i];
    buf[i] = (ch == '-' || ch == '/') ? '_' : ch;
  }
  return std::string(buf) + std::string(""_cache_data"");
}",63,,716,2,,void
230968,BLOCK,-1,,<empty>,3,,720,1,,void
230978,BLOCK,4,,"{
    char ch = id[i];
    buf[i] = (ch == '-' || ch == '/') ? '_' : ch;
  }",37,,720,4,,void
231015,BLOCK,-1,,"{
  char buf[64] = {0};
  if (size < 1024) {
    snprintf(buf, sizeof(buf), ""%.2fB"", static_cast<double>(size));
  } else if (size < 1024 * 1024) {
    snprintf(buf, sizeof(buf), ""%.2fKB"", static_cast<double>(size / 1024));
  } else {
    snprintf(
        buf, sizeof(buf), ""%.2fMB"", static_cast<double>(size / 1024 / 1024));
  }
  return buf;
}",44,,727,2,,void
231025,BLOCK,-1,,"{
    snprintf(buf, sizeof(buf), ""%.2fB"", static_cast<double>(size));
  }",20,,729,2,,void
231035,BLOCK,-1,,<empty>,10,,731,1,,void
231042,BLOCK,-1,,"{
    snprintf(buf, sizeof(buf), ""%.2fKB"", static_cast<double>(size / 1024));
  }",34,,731,2,,void
231054,BLOCK,-1,,"{
    snprintf(
        buf, sizeof(buf), ""%.2fMB"", static_cast<double>(size / 1024 / 1024));
  }",10,,733,1,,void
231074,BLOCK,-1,,"{
  *ss << ""static const uint8_t "" << GetCodeCacheDefName(info.id) << ""[] = {\n"";
  WriteVector(ss, info.data.data, info.data.length);
  *ss << ""};"";
}",75,,741,3,,void
231107,BLOCK,-1,,"{
  std::string def_name = GetCodeCacheDefName(id);
  *ss << ""    { \"""" << id << ""\"",\n"";
  *ss << ""      {"" << def_name << "",\n"";
  *ss << ""       arraysize("" << def_name << ""),\n"";
  *ss << ""      }\n"";
  *ss << ""    },\n"";
}",80,,747,3,,void
231150,BLOCK,-1,,"{
  ss << R""(#include <cstddef>
#include ""env.hpp""
#include ""node_snapshot_builder.hpp""
#include ""v8.hpp""

// This file is generated by tools/snapshot. Do not edit.

namespace node {

static const char v8_snapshot_blob_data[] = {
)"";
  WriteVector(&ss,
              data->v8_snapshot_blob_data.data,
              data->v8_snapshot_blob_data.raw_size);
  ss << R""(};

static const int v8_snapshot_blob_size = )""
     << data->v8_snapshot_blob_data.raw_size << "";"";

  // Windows can't deal with too many large vector initializers.
  // Store the data into static arrays first.
  for (const auto& item : data->code_cache) {
    WriteStaticCodeCacheData(&ss, item);
  }

  ss << R""(const SnapshotData snapshot_data {
  // -- data_ownership begins --
  SnapshotData::DataOwnership::kNotOwned,
  // -- data_ownership ends --
  // -- metadata begins --
)"" << data->metadata
     << R""(,
  // -- metadata ends --
  // -- v8_snapshot_blob_data begins --
  { v8_snapshot_blob_data, v8_snapshot_blob_size ...",61,,756,3,,void
231183,BLOCK,-1,,"{
    WriteStaticCodeCacheData(&ss, item);
  }",45,,778,3,,void
231214,BLOCK,-1,,"{
    WriteCodeCacheInitializer(&ss, item.id);
  }",45,,805,3,,void
231228,BLOCK,-1,,"{
  // Reset the AllowCodeGenerationFromStrings flag to true (default value) so
  // that it can be re-initialized with v8 flag
  // --disallow-code-generation-from-strings and recognized in
  // node::InitializeContextRuntime.
  context->AllowCodeGenerationFromStrings(true);
}",72,,822,2,,void
231237,BLOCK,-1,,"{
  static auto registry = std::make_unique<ExternalReferenceRegistry>();
  return registry->external_references();
}",75,,830,1,,void
231255,BLOCK,-1,,"{
  CHECK_NULL(params->external_references);
  CHECK_NULL(params->snapshot_blob);
  params->external_references = CollectExternalReferences().data();
  params->snapshot_blob =
      const_cast<v8::StartupData*>(&(data->v8_snapshot_blob_data));
}",78,,836,3,,void
231288,BLOCK,-1,,"{
  std::vector<std::string> errors;
  auto setup = CommonEnvironmentSetup::CreateForSnapshotting(
      per_process::v8_platform.Platform(), &errors, args, exec_args);
  if (!setup) {
    for (const std::string& err : errors)
      fprintf(stderr, ""%s: %s\n"", args[0].c_str(), err.c_str());
    return ExitCode::kBootstrapFailure;
  }
  Isolate* isolate = setup->isolate();

  // It's only possible to be kDefault in node_mksnapshot.
  SnapshotMetadata::Type snapshot_type =
      per_process::cli_options->per_isolate->build_snapshot
          ? SnapshotMetadata::Type::kFullyCustomized
          : SnapshotMetadata::Type::kDefault;

  {
    HandleScope scope(isolate);
    TryCatch bootstrapCatch(isolate);

    auto print_Exception = OnScopeLeave([&]() {
      if (bootstrapCatch.HasCaught()) {
        PrintCaughtException(
            isolate, isolate->GetCurrentContext(), bootstrapCatch);
      }
    });

    // Initialize the main instance context.
    {
      Context::Scope context_sco...",78,,846,4,,void
231318,BLOCK,-1,,"{
    for (const std::string& err : errors)
      fprintf(stderr, ""%s: %s\n"", args[0].c_str(), err.c_str());
    return ExitCode::kBootstrapFailure;
  }",15,,850,2,,void
231366,BLOCK,9,,"{
    HandleScope scope(isolate);
    TryCatch bootstrapCatch(isolate);

    auto print_Exception = OnScopeLeave([&]() {
      if (bootstrapCatch.HasCaught()) {
        PrintCaughtException(
            isolate, isolate->GetCurrentContext(), bootstrapCatch);
      }
    });

    // Initialize the main instance context.
    {
      Context::Scope context_scope(setup->context());
      Environment* env = setup->env();

      // If --build-snapshot is true, lib/internal/main/mksnapshot.js would be
      // loaded via LoadEnvironment() to execute process.argv[1] as the entry
      // point (we currently only support this kind of entry point, but we
      // could also explore snapshotting other kinds of execution modes
      // in the future).
      if (snapshot_type == SnapshotMetadata::Type::kFullyCustomized) {
#if HAVE_INSPECTOR
        env->InitializeInspector({});
#endif
        if (LoadEnvironment(env, StartExecutionCallback{}).IsEmpty()) {
          return ExitCode::kGenericUserE...",3,,863,9,,void
231377,BLOCK,7,,"{
      Context::Scope context_scope(setup->context());
      Environment* env = setup->env();

      // If --build-snapshot is true, lib/internal/main/mksnapshot.js would be
      // loaded via LoadEnvironment() to execute process.argv[1] as the entry
      // point (we currently only support this kind of entry point, but we
      // could also explore snapshotting other kinds of execution modes
      // in the future).
      if (snapshot_type == SnapshotMetadata::Type::kFullyCustomized) {
#if HAVE_INSPECTOR
        env->InitializeInspector({});
#endif
        if (LoadEnvironment(env, StartExecutionCallback{}).IsEmpty()) {
          return ExitCode::kGenericUserError;
        }
        // FIXME(joyeecheung): right now running the loop in the snapshot
        // builder seems to introduces inconsistencies in JS land that need to
        // be synchronized again after snapshot restoration.
        ExitCode exit_code =
            SpinEventLoopInternal(env).FromMaybe(ExitCode::kGeneri...",5,,875,7,,void
231399,BLOCK,-1,,"{
#if HAVE_INSPECTOR
        env->InitializeInspector({});
#endif
        if (LoadEnvironment(env, StartExecutionCallback{}).IsEmpty()) {
          return ExitCode::kGenericUserError;
        }
        // FIXME(joyeecheung): right now running the loop in the snapshot
        // builder seems to introduces inconsistencies in JS land that need to
        // be synchronized again after snapshot restoration.
        ExitCode exit_code =
            SpinEventLoopInternal(env).FromMaybe(ExitCode::kGenericUserError);
        if (exit_code != ExitCode::kNoFailure) {
          return exit_code;
        }
      }",70,,884,2,,void
231408,BLOCK,-1,,"{
          return ExitCode::kGenericUserError;
        }",71,,888,2,,void
231430,BLOCK,-1,,"{
          return exit_code;
        }",48,,896,2,,void
231449,BLOCK,-1,,"{
  SnapshotMetadata::Type snapshot_type =
      static_cast<SnapshotMetadata::Type>(snapshot_type_u8);
  Isolate* isolate = setup->isolate();
  Environment* env = setup->env();
  SnapshotCreator* creator = setup->snapshot_creator();

  {
    HandleScope scope(isolate);
    Local<Context> main_context = setup->context();

    // The default context with only things created by V8.
    Local<Context> default_context = Context::New(isolate);

    // The context used by the vm module.
    Local<Context> vm_context;
    {
      Local<ObjectTemplate> global_template =
          setup->isolate_data()->contextify_global_template();
      CHECK(!global_template.IsEmpty());
      if (!contextify::ContextifyContext::CreateV8Context(
               isolate, global_template, nullptr, nullptr)
               .ToLocal(&vm_context)) {
        return ExitCode::kStartupSnapshotFailure;
      }
    }

    // The Node.js-specific context with primodials, can be used by workers
    // TODO(joyeecheung):...",68,,908,4,,void
231477,BLOCK,9,,"{
    HandleScope scope(isolate);
    Local<Context> main_context = setup->context();

    // The default context with only things created by V8.
    Local<Context> default_context = Context::New(isolate);

    // The context used by the vm module.
    Local<Context> vm_context;
    {
      Local<ObjectTemplate> global_template =
          setup->isolate_data()->contextify_global_template();
      CHECK(!global_template.IsEmpty());
      if (!contextify::ContextifyContext::CreateV8Context(
               isolate, global_template, nullptr, nullptr)
               .ToLocal(&vm_context)) {
        return ExitCode::kStartupSnapshotFailure;
      }
    }

    // The Node.js-specific context with primodials, can be used by workers
    // TODO(joyeecheung): investigate if this can be used by vm contexts
    // without breaking compatibility.
    Local<Context> base_context = NewContext(isolate);
    if (base_context.IsEmpty()) {
      return ExitCode::kBootstrapFailure;
    }
    ResetCont...",3,,915,9,,void
231507,BLOCK,6,,"{
      Local<ObjectTemplate> global_template =
          setup->isolate_data()->contextify_global_template();
      CHECK(!global_template.IsEmpty());
      if (!contextify::ContextifyContext::CreateV8Context(
               isolate, global_template, nullptr, nullptr)
               .ToLocal(&vm_context)) {
        return ExitCode::kStartupSnapshotFailure;
      }
    }",5,,924,6,,void
231544,BLOCK,-1,,"{
        return ExitCode::kStartupSnapshotFailure;
      }",39,,930,2,,void
231562,BLOCK,-1,,"{
      return ExitCode::kBootstrapFailure;
    }",33,,939,2,,void
231568,BLOCK,10,,"{
      Context::Scope context_scope(main_context);

      if (per_process::enabled_debug_list.enabled(DebugCategory::MKSNAPSHOT)) {
        env->ForEachRealm([](Realm* realm) { realm->PrintInfoForSnapshot(); });
        printf(""Environment = %p\n"", env);
      }

      // Serialize the native states
      out->isolate_data_info = setup->isolate_data()->Serialize(creator);
      out->env_info = env->Serialize(creator);

#ifdef NODE_USE_NODE_CODE_CACHE
      // Regenerate all the code cache.
      if (!env->builtin_loader()->CompileAllBuiltins(main_context)) {
        return ExitCode::kGenericUserError;
      }
      env->builtin_loader()->CopyCodeCache(&(out->code_cache));
      for (const auto& item : out->code_cache) {
        std::string size_str = FormatSize(item.data.length);
        per_process::Debug(DebugCategory::MKSNAPSHOT,
                           ""Generated code cache for %d: %s\n"",
                           item.id.c_str(),
                           size_str.c_str()...",5,,944,10,,void
231582,BLOCK,-1,,"{
        env->ForEachRealm([](Realm* realm) { realm->PrintInfoForSnapshot(); });
        printf(""Environment = %p\n"", env);
      }",79,,947,2,,void
231679,BLOCK,-1,,"{
    return ExitCode::kStartupSnapshotFailure;
  }",52,,993,2,,void
231745,BLOCK,-1,,"{
    PrintLibuvHandleInformation(env->event_loop(), stderr);
  }",75,,1009,2,,void
231755,BLOCK,-1,,"{
    return ExitCode::kStartupSnapshotFailure;
  }",26,,1012,2,,void
231770,BLOCK,-1,,"{
  SnapshotData data;
  ExitCode exit_code = Generate(&data, args, exec_args);
  if (exit_code != ExitCode::kNoFailure) {
    return exit_code;
  }
  FormatBlob(out, &data);
  return exit_code;
}",78,,1020,4,,void
231786,BLOCK,-1,,"{
    return exit_code;
  }",42,,1023,2,,void
231801,BLOCK,-1,,<empty>,44,,1033,4,,void
231805,BLOCK,-1,,"{
  switch (type_) {
#define V(PropertyName, NativeTypeName)                                        \
  case EmbedderObjectType::k_##PropertyName: {                                 \
    return #NativeTypeName;                                                    \
  }
    SERIALIZABLE_OBJECT_TYPES(V)
#undef V
    default: { UNREACHABLE(); }
  }
}",53,,1035,1,,void
231808,BLOCK,-1,,"{
#define V(PropertyName, NativeTypeName)                                        \
  case EmbedderObjectType::k_##PropertyName: {                                 \
    return #NativeTypeName;                                                    \
  }
    SERIALIZABLE_OBJECT_TYPES(V)
#undef V
    default: { UNREACHABLE(); }
  }",18,,1036,2,,void
231812,BLOCK,4,,{ UNREACHABLE(); },14,,1043,4,,void
231821,BLOCK,-1,,"{
  if (payload.raw_size == 0) {
    holder->SetAlignedPointerInInternalField(index, nullptr);
    return;
  }
  per_process::Debug(DebugCategory::MKSNAPSHOT,
                     ""Deserialize internal field %d of %p, size=%d\n"",
                     static_cast<int>(index),
                     (*holder),
                     static_cast<int>(payload.raw_size));

  if (payload.raw_size == 0) {
    holder->SetAlignedPointerInInternalField(index, nullptr);
    return;
  }

  DCHECK_EQ(index, BaseObject::kEmbedderType);

  Environment* env_ptr = static_cast<Environment*>(env);
  const InternalFieldInfoBase* info =
      reinterpret_cast<const InternalFieldInfoBase*>(payload.data);
  // TODO(joyeecheung): we can add a constant kNodeEmbedderId to the
  // beginning of every InternalFieldInfoBase to ensure that we don't
  // step on payloads that were not serialized by Node.js.
  switch (info->type) {
#define V(PropertyName, NativeTypeName)                                        \
  case...",47,,1050,5,,void
231828,BLOCK,-1,,"{
    holder->SetAlignedPointerInInternalField(index, nullptr);
    return;
  }",30,,1051,2,,void
231860,BLOCK,-1,,"{
    holder->SetAlignedPointerInInternalField(index, nullptr);
    return;
  }",30,,1061,2,,void
231891,BLOCK,-1,,"{
#define V(PropertyName, NativeTypeName)                                        \
  case EmbedderObjectType::k_##PropertyName: {                                 \
    per_process::Debug(DebugCategory::MKSNAPSHOT,                              \
                       ""Object %p is %s\n"",                                    \
                       (*holder),                                              \
                       #NativeTypeName);                                       \
    env_ptr->EnqueueDeserializeRequest(                                        \
        NativeTypeName::Deserialize,                                           \
        holder,                                                                \
        index,                                                                 \
        info->Copy<NativeTypeName::InternalFieldInfo>());                      \
    break;                                                                     \
  }
    SERIALIZABLE_OB...",23,,1074,2,,void
231895,BLOCK,4,,"{
      // This should only be reachable during development when trying to
      // deserialize a snapshot blob built by a version of Node.js that
      // has more recognizable EmbedderObjectTypes than the deserializing
      // Node.js binary.
      fprintf(stderr,
              ""Unknown embedder object type %"" PRIu8 "", possibly caused by ""
              ""mismatched Node.js versions\n"",
              static_cast<uint8_t>(info->type));
      ABORT();
    }",14,,1090,4,,void
231904,BLOCK,-1,,"{
  // We only do one serialization for the kEmbedderType slot, the result
  // contains everything necessary for deserializing the entire object,
  // including the fields whose index is bigger than kEmbedderType
  // (most importantly, BaseObject::kSlot).
  // For Node.js this design is enough for all the native binding that are
  // serializable.
  if (index != BaseObject::kEmbedderType || !BaseObject::IsBaseObject(holder)) {
    return StartupData{nullptr, 0};
  }

  per_process::Debug(DebugCategory::MKSNAPSHOT,
                     ""Serialize internal field, index=%d, holder=%p\n"",
                     static_cast<int>(index),
                     *holder);

  void* native_ptr =
      holder->GetAlignedPointerFromInternalField(BaseObject::kSlot);
  per_process::Debug(DebugCategory::MKSNAPSHOT, ""native = %p\n"", native_ptr);
  DCHECK(static_cast<BaseObject*>(native_ptr)->is_snapshotable());
  SnapshotableObject* obj = static_cast<SnapshotableObject*>(native_ptr);

  per_process::...",59,,1106,4,,void
231918,BLOCK,-1,,"{
    return StartupData{nullptr, 0};
  }",80,,1113,2,,void
232019,BLOCK,-1,,"{
  HandleScope scope(realm->isolate());
  Local<Context> context = realm->context();
  uint32_t i = 0;
  realm->ForEachBaseObject([&](BaseObject* obj) {
    // If there are any BaseObjects that are not snapshotable left
    // during context serialization, V8 would crash due to unregistered
    // global handles and print detailed information about them.
    if (!obj->is_snapshotable()) {
      return;
    }
    SnapshotableObject* ptr = static_cast<SnapshotableObject*>(obj);

    std::string type_name = ptr->GetTypeName();
    per_process::Debug(DebugCategory::MKSNAPSHOT,
                       ""Serialize snapshotable object %i (%p), ""
                       ""object=%p, type=%s\n"",
                       static_cast<int>(i),
                       ptr,
                       *(ptr->object()),
                       type_name);

    if (ptr->PrepareForSerialization(context, creator)) {
      SnapshotIndex index = creator->AddData(context, obj->object());
      per_process::Debug(De...",61,,1143,4,,void
232048,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  if (!env->embedder_entry_point()) return;
  MaybeLocal<Function> jsfn =
      Function::New(isolate->GetCurrentContext(),
                    [](const FunctionCallbackInfo<Value>& args) {
                      Environment* env = Environment::GetCurrent(args);
                      Local<Value> require_fn = args[0];
                      Local<Value> runcjs_fn = args[1];
                      CHECK(require_fn->IsFunction());
                      CHECK(runcjs_fn->IsFunction());
                      MaybeLocal<Value> retval = env->embedder_entry_point()(
                          {env->process_object(),
                           require_fn.As<Function>(),
                           runcjs_fn.As<Function>()});
                      if (!retval.IsEmpty())
                        args.GetReturnValue().Set(retval.ToLocalChecked());
                    });
  if (!jsfn.IsEmpty()) args.GetReturnVal...",72,,1179,2,,void
232070,BLOCK,-1,,<empty>,37,,1182,2,,void
232093,BLOCK,-1,,<empty>,24,,1198,2,,void
232109,BLOCK,-1,,"{
  CHECK(args[0]->IsString());
  Local<String> filename = args[0].As<String>();
  Local<String> source = args[1].As<String>();
  Isolate* isolate = args.GetIsolate();
  Local<Context> context = isolate->GetCurrentContext();
  ScriptOrigin origin(isolate, filename, 0, 0, true);
  // TODO(joyeecheung): do we need all of these? Maybe we would want a less
  // internal version of them.
  std::vector<Local<String>> parameters = {
      FIXED_ONE_BYTE_STRING(isolate, ""require""),
      FIXED_ONE_BYTE_STRING(isolate, ""__filename""),
      FIXED_ONE_BYTE_STRING(isolate, ""__dirname""),
  };
  ScriptCompiler::Source script_source(source, origin);
  Local<Function> fn;
  if (ScriptCompiler::CompileFunction(context,
                                      &script_source,
                                      parameters.size(),
                                      parameters.data(),
                                      0,
                                      nullptr,
                             ...",68,,1201,2,,void
232210,BLOCK,-1,,"{
    args.GetReturnValue().Set(fn);
  }",26,,1224,2,,void
232223,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(env->snapshot_serialize_callback().IsEmpty());
  CHECK(args[0]->IsFunction());
  env->set_snapshot_serialize_callback(args[0].As<Function>());
}",68,,1229,2,,void
232261,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(env->snapshot_deserialize_callback().IsEmpty());
  CHECK(args[0]->IsFunction());
  env->set_snapshot_deserialize_callback(args[0].As<Function>());
}",70,,1236,2,,void
232299,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(env->snapshot_deserialize_main().IsEmpty());
  CHECK(args[0]->IsFunction());
  env->set_snapshot_deserialize_main(args[0].As<Function>());
}",74,,1243,2,,void
232340,BLOCK,-1,,"{
  SetMethod(
      context, target, ""getEmbedderEntryFunction"", GetEmbedderEntryFunction);
  SetMethod(context, target, ""compileSerializeMain"", CompileSerializeMain);
  SetMethod(context, target, ""setSerializeCallback"", SetSerializeCallback);
  SetMethod(context, target, ""setDeserializeCallback"", SetDeserializeCallback);
  SetMethod(context,
            target,
            ""setDeserializeMainFunction"",
            SetDeserializeMainFunction);
}",29,,1253,5,,void
232370,BLOCK,-1,,"{
  registry->Register(GetEmbedderEntryFunction);
  registry->Register(CompileSerializeMain);
  registry->Register(SetSerializeCallback);
  registry->Register(SetDeserializeCallback);
  registry->Register(SetDeserializeMainFunction);
}",70,,1265,2,,void
232407,BLOCK,-1,,<empty>,1,,1,1,,ANY
232426,BLOCK,-1,,<empty>,1,,1,1,,ANY
232451,BLOCK,-1,,<empty>,1,,1,1,,ANY
232457,BLOCK,-1,,"{
  SocketAddress addr;
  int len = sizeof(sockaddr_storage);
  if (fn(&handle, addr.storage(), &len) == 0)
    CHECK_EQ(static_cast<size_t>(len), addr.length());
  else
    addr.storage()->sa_family = 0;
  return addr;
}",51,,29,3,,void
232476,BLOCK,-1,,<empty>,5,,33,2,,void
232486,BLOCK,-1,,<empty>,5,,35,1,,void
232504,BLOCK,-1,,"{
  switch (family) {
    case AF_INET:
      return uv_ip4_addr(
          host,
          port,
          reinterpret_cast<sockaddr_in*>(addr)) == 0;
    case AF_INET6:
      return uv_ip6_addr(
          host,
          port,
          reinterpret_cast<sockaddr_in6*>(addr)) == 0;
    default:
      UNREACHABLE();
  }
}",29,,44,5,,void
232507,BLOCK,-1,,"{
    case AF_INET:
      return uv_ip4_addr(
          host,
          port,
          reinterpret_cast<sockaddr_in*>(addr)) == 0;
    case AF_INET6:
      return uv_ip6_addr(
          host,
          port,
          reinterpret_cast<sockaddr_in6*>(addr)) == 0;
    default:
      UNREACHABLE();
  }",19,,45,2,,void
232538,BLOCK,-1,,"{
  return New(AF_INET, host, port, addr) || New(AF_INET6, host, port, addr);
}",26,,64,4,,void
232558,BLOCK,-1,,"{
  return ToSockAddr(family, host, port,
                    reinterpret_cast<sockaddr_storage*>(addr->storage()));
}",26,,72,5,,void
232574,BLOCK,-1,,"{
  size_t hash = 0;
  switch (addr.family()) {
    case AF_INET: {
      const sockaddr_in* ipv4 =
          reinterpret_cast<const sockaddr_in*>(addr.raw());
      hash_combine(&hash, ipv4->sin_port, ipv4->sin_addr.s_addr);
      break;
    }
    case AF_INET6: {
      const sockaddr_in6* ipv6 =
          reinterpret_cast<const sockaddr_in6*>(addr.raw());
      const uint64_t* a =
          reinterpret_cast<const uint64_t*>(&ipv6->sin6_addr);
      hash_combine(&hash, ipv6->sin6_port, a[0], a[1]);
      break;
    }
    default:
      UNREACHABLE();
  }
  return hash;
}",73,,77,2,,void
232584,BLOCK,-1,,"{
    case AF_INET: {
      const sockaddr_in* ipv4 =
          reinterpret_cast<const sockaddr_in*>(addr.raw());
      hash_combine(&hash, ipv4->sin_port, ipv4->sin_addr.s_addr);
      break;
    }
    case AF_INET6: {
      const sockaddr_in6* ipv6 =
          reinterpret_cast<const sockaddr_in6*>(addr.raw());
      const uint64_t* a =
          reinterpret_cast<const uint64_t*>(&ipv6->sin6_addr);
      hash_combine(&hash, ipv6->sin6_port, a[0], a[1]);
      break;
    }
    default:
      UNREACHABLE();
  }",26,,79,2,,void
232587,BLOCK,3,,"{
      const sockaddr_in* ipv4 =
          reinterpret_cast<const sockaddr_in*>(addr.raw());
      hash_combine(&hash, ipv4->sin_port, ipv4->sin_addr.s_addr);
      break;
    }",19,,80,3,,void
232611,BLOCK,6,,"{
      const sockaddr_in6* ipv6 =
          reinterpret_cast<const sockaddr_in6*>(addr.raw());
      const uint64_t* a =
          reinterpret_cast<const uint64_t*>(&ipv6->sin6_addr);
      hash_combine(&hash, ipv6->sin6_port, a[0], a[1]);
      break;
    }",20,,86,6,,void
232651,BLOCK,-1,,"{
  return FromUVHandle(uv_tcp_getsockname, handle);
}",67,,100,2,,void
232660,BLOCK,-1,,"{
  return FromUVHandle(uv_udp_getsockname, handle);
}",67,,104,2,,void
232669,BLOCK,-1,,"{
  return FromUVHandle(uv_tcp_getpeername, handle);
}",67,,108,2,,void
232678,BLOCK,-1,,"{
  return FromUVHandle(uv_udp_getpeername, handle);
}",67,,112,2,,void
232705,BLOCK,-1,,"{
  const sockaddr_in* one_in =
      reinterpret_cast<const sockaddr_in*>(one.data());
  const sockaddr_in* two_in =
      reinterpret_cast<const sockaddr_in*>(two.data());
  return memcmp(&one_in->sin_addr, &two_in->sin_addr, sizeof(uint32_t)) == 0;
}",31,,121,3,,void
232743,BLOCK,-1,,"{
  const sockaddr_in6* one_in =
      reinterpret_cast<const sockaddr_in6*>(one.data());
  const sockaddr_in6* two_in =
      reinterpret_cast<const sockaddr_in6*>(two.data());
  return memcmp(&one_in->sin6_addr, &two_in->sin6_addr, 16) == 0;
}",31,,131,3,,void
232780,BLOCK,-1,,"{
  const sockaddr_in* check_ipv4 =
      reinterpret_cast<const sockaddr_in*>(ipv4.data());
  const sockaddr_in6* check_ipv6 =
      reinterpret_cast<const sockaddr_in6*>(ipv6.data());

  const uint8_t* ptr =
      reinterpret_cast<const uint8_t*>(&check_ipv6->sin6_addr);

  return memcmp(ptr, mask, sizeof(mask)) == 0 &&
         memcmp(ptr + sizeof(mask),
                &check_ipv4->sin_addr,
                sizeof(uint32_t)) == 0;
}",32,,141,3,,void
232835,BLOCK,-1,,"{
  const sockaddr_in* one_in =
      reinterpret_cast<const sockaddr_in*>(one.data());
  const sockaddr_in* two_in =
      reinterpret_cast<const sockaddr_in*>(two.data());
  const uint32_t s_addr_one = ntohl(one_in->sin_addr.s_addr);
  const uint32_t s_addr_two = ntohl(two_in->sin_addr.s_addr);

  if (s_addr_one < s_addr_two)
    return SocketAddress::CompareResult::LESS_THAN;
  else if (s_addr_one == s_addr_two)
    return SocketAddress::CompareResult::SAME;
  else
    return SocketAddress::CompareResult::GREATER_THAN;
}",31,,158,3,,void
232876,BLOCK,-1,,<empty>,5,,167,2,,void
232884,BLOCK,-1,,<empty>,8,,168,1,,void
232889,BLOCK,-1,,<empty>,5,,169,2,,void
232897,BLOCK,-1,,<empty>,5,,171,1,,void
232909,BLOCK,-1,,"{
  const sockaddr_in6* one_in =
      reinterpret_cast<const sockaddr_in6*>(one.data());
  const sockaddr_in6* two_in =
      reinterpret_cast<const sockaddr_in6*>(two.data());
  int ret = memcmp(&one_in->sin6_addr, &two_in->sin6_addr, 16);
  if (ret < 0)
    return SocketAddress::CompareResult::LESS_THAN;
  else if (ret > 0)
    return SocketAddress::CompareResult::GREATER_THAN;
  return SocketAddress::CompareResult::SAME;
}",31,,176,3,,void
232945,BLOCK,-1,,<empty>,5,,183,2,,void
232953,BLOCK,-1,,<empty>,8,,184,1,,void
232958,BLOCK,-1,,<empty>,5,,185,2,,void
232976,BLOCK,-1,,"{
  const sockaddr_in* ipv4_in =
      reinterpret_cast<const sockaddr_in*>(ipv4.data());
  const sockaddr_in6 * ipv6_in =
      reinterpret_cast<const sockaddr_in6*>(ipv6.data());

  const uint8_t* ptr =
      reinterpret_cast<const uint8_t*>(&ipv6_in->sin6_addr);

  if (memcmp(ptr, mask, sizeof(mask)) != 0)
    return SocketAddress::CompareResult::NOT_COMPARABLE;

  int ret = memcmp(
      &ipv4_in->sin_addr,
      ptr + sizeof(mask),
      sizeof(uint32_t));

  if (ret < 0)
    return SocketAddress::CompareResult::LESS_THAN;
  else if (ret > 0)
    return SocketAddress::CompareResult::GREATER_THAN;
  return SocketAddress::CompareResult::SAME;
}",32,,191,3,,void
233012,BLOCK,-1,,<empty>,5,,201,2,,void
233037,BLOCK,-1,,<empty>,5,,209,2,,void
233045,BLOCK,-1,,<empty>,8,,210,1,,void
233050,BLOCK,-1,,<empty>,5,,211,2,,void
233069,BLOCK,-1,,"{
  uint32_t mask = ((1ull << prefix) - 1) << (32 - prefix);

  const sockaddr_in* ip_in =
      reinterpret_cast<const sockaddr_in*>(ip.data());
  const sockaddr_in* net_in =
      reinterpret_cast<const sockaddr_in*>(net.data());

  return (htonl(ip_in->sin_addr.s_addr) & mask) ==
         (htonl(net_in->sin_addr.s_addr) & mask);
}",17,,218,4,,void
233124,BLOCK,-1,,"{
  // Special case, if prefix == 128, then just do a
  // straight comparison.
  if (prefix == 128)
    return compare_ipv6(ip, net) == SocketAddress::CompareResult::SAME;

  uint8_t r = prefix % 8;
  int len = (prefix - r) / 8;
  uint8_t mask = ((1 << r) - 1) << (8 - r);

  const sockaddr_in6* ip_in =
      reinterpret_cast<const sockaddr_in6*>(ip.data());
  const sockaddr_in6* net_in =
      reinterpret_cast<const sockaddr_in6*>(net.data());

  if (memcmp(&ip_in->sin6_addr, &net_in->sin6_addr, len) != 0)
    return false;

  const uint8_t* p1 = reinterpret_cast<const uint8_t*>(
      ip_in->sin6_addr.s6_addr);
  const uint8_t* p2 = reinterpret_cast<const uint8_t*>(
      net_in->sin6_addr.s6_addr);

  return (p1[len] & mask) == (p2[len] & mask);
}",17,,233,4,,void
233129,BLOCK,-1,,<empty>,5,,237,2,,void
233197,BLOCK,-1,,<empty>,5,,249,2,,void
233238,BLOCK,-1,,"{

  if (prefix == 128)
    return compare_ipv4_ipv6(ip, net) == SocketAddress::CompareResult::SAME;

  uint8_t r = prefix % 8;
  int len = (prefix - r) / 8;
  uint8_t mask = ((1 << r) - 1) << (8 - r);

  const sockaddr_in* ip_in =
      reinterpret_cast<const sockaddr_in*>(ip.data());
  const sockaddr_in6* net_in =
      reinterpret_cast<const sockaddr_in6*>(net.data());

  uint8_t ip_mask[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff, 0, 0, 0, 0};
  uint8_t* ptr = ip_mask;
  memcpy(ptr + 12, &ip_in->sin_addr, 4);

  if (memcmp(ptr, &net_in->sin6_addr, len) != 0)
    return false;

  ptr += len;
  const uint8_t* p2 = reinterpret_cast<const uint8_t*>(
      net_in->sin6_addr.s6_addr);

  return (ptr[0] & mask) == (p2[len] & mask);
}",17,,262,4,,void
233243,BLOCK,-1,,<empty>,5,,265,2,,void
233341,BLOCK,-1,,<empty>,5,,281,2,,void
233375,BLOCK,-1,,"{
  if (prefix == 32)
    return compare_ipv4_ipv6(net, ip) == SocketAddress::CompareResult::SAME;

  uint32_t m = ((1ull << prefix) - 1) << (32 - prefix);

  const sockaddr_in6* ip_in =
      reinterpret_cast<const sockaddr_in6*>(ip.data());
  const sockaddr_in* net_in =
      reinterpret_cast<const sockaddr_in*>(net.data());

  const uint8_t* ptr =
      reinterpret_cast<const uint8_t*>(&ip_in->sin6_addr);

  if (memcmp(ptr, mask, sizeof(mask)) != 0)
    return false;

  ptr += sizeof(mask);
  uint32_t check = ReadUint32BE(ptr);

  return (check & m) == (htonl(net_in->sin_addr.s_addr) & m);
}",17,,293,4,,void
233380,BLOCK,-1,,<empty>,5,,295,2,,void
233438,BLOCK,-1,,<empty>,5,,308,2,,void
233467,BLOCK,-1,,"{
  switch (family()) {
    case AF_INET:
      switch (other.family()) {
        case AF_INET: return is_match_ipv4(*this, other);
        case AF_INET6: return is_match_ipv4_ipv6(*this, other);
      }
      break;
    case AF_INET6:
      switch (other.family()) {
        case AF_INET: return is_match_ipv4_ipv6(other, *this);
        case AF_INET6: return is_match_ipv6(*this, other);
      }
      break;
  }
  return false;
}",64,,321,2,,void
233470,BLOCK,-1,,"{
    case AF_INET:
      switch (other.family()) {
        case AF_INET: return is_match_ipv4(*this, other);
        case AF_INET6: return is_match_ipv4_ipv6(*this, other);
      }
      break;
    case AF_INET6:
      switch (other.family()) {
        case AF_INET: return is_match_ipv4_ipv6(other, *this);
        case AF_INET6: return is_match_ipv6(*this, other);
      }
      break;
  }",21,,322,2,,void
233478,BLOCK,-1,,"{
        case AF_INET: return is_match_ipv4(*this, other);
        case AF_INET6: return is_match_ipv4_ipv6(*this, other);
      }",31,,324,2,,void
233501,BLOCK,-1,,"{
        case AF_INET: return is_match_ipv4_ipv6(other, *this);
        case AF_INET6: return is_match_ipv6(*this, other);
      }",31,,330,2,,void
233523,BLOCK,-1,,"{
  switch (family()) {
    case AF_INET:
      switch (other.family()) {
        case AF_INET: return compare_ipv4(*this, other);
        case AF_INET6: return compare_ipv4_ipv6(*this, other);
      }
      break;
    case AF_INET6:
      switch (other.family()) {
        case AF_INET: {
          CompareResult c = compare_ipv4_ipv6(other, *this);
          switch (c) {
            case SocketAddress::CompareResult::NOT_COMPARABLE:
              // Fall through
            case SocketAddress::CompareResult::SAME:
              return c;
            case SocketAddress::CompareResult::GREATER_THAN:
              return SocketAddress::CompareResult::LESS_THAN;
            case SocketAddress::CompareResult::LESS_THAN:
              return SocketAddress::CompareResult::GREATER_THAN;
          }
          break;
        }
        case AF_INET6: return compare_ipv6(*this, other);
      }
      break;
  }
  return SocketAddress::CompareResult::NOT_COMPARABLE;
}",39,,340,2,,void
233526,BLOCK,-1,,"{
    case AF_INET:
      switch (other.family()) {
        case AF_INET: return compare_ipv4(*this, other);
        case AF_INET6: return compare_ipv4_ipv6(*this, other);
      }
      break;
    case AF_INET6:
      switch (other.family()) {
        case AF_INET: {
          CompareResult c = compare_ipv4_ipv6(other, *this);
          switch (c) {
            case SocketAddress::CompareResult::NOT_COMPARABLE:
              // Fall through
            case SocketAddress::CompareResult::SAME:
              return c;
            case SocketAddress::CompareResult::GREATER_THAN:
              return SocketAddress::CompareResult::LESS_THAN;
            case SocketAddress::CompareResult::LESS_THAN:
              return SocketAddress::CompareResult::GREATER_THAN;
          }
          break;
        }
        case AF_INET6: return compare_ipv6(*this, other);
      }
      break;
  }",21,,341,2,,void
233534,BLOCK,-1,,"{
        case AF_INET: return compare_ipv4(*this, other);
        case AF_INET6: return compare_ipv4_ipv6(*this, other);
      }",31,,343,2,,void
233557,BLOCK,-1,,"{
        case AF_INET: {
          CompareResult c = compare_ipv4_ipv6(other, *this);
          switch (c) {
            case SocketAddress::CompareResult::NOT_COMPARABLE:
              // Fall through
            case SocketAddress::CompareResult::SAME:
              return c;
            case SocketAddress::CompareResult::GREATER_THAN:
              return SocketAddress::CompareResult::LESS_THAN;
            case SocketAddress::CompareResult::LESS_THAN:
              return SocketAddress::CompareResult::GREATER_THAN;
          }
          break;
        }
        case AF_INET6: return compare_ipv6(*this, other);
      }",31,,349,2,,void
233560,BLOCK,3,,"{
          CompareResult c = compare_ipv4_ipv6(other, *this);
          switch (c) {
            case SocketAddress::CompareResult::NOT_COMPARABLE:
              // Fall through
            case SocketAddress::CompareResult::SAME:
              return c;
            case SocketAddress::CompareResult::GREATER_THAN:
              return SocketAddress::CompareResult::LESS_THAN;
            case SocketAddress::CompareResult::LESS_THAN:
              return SocketAddress::CompareResult::GREATER_THAN;
          }
          break;
        }",23,,350,3,,void
233570,BLOCK,-1,,"{
            case SocketAddress::CompareResult::NOT_COMPARABLE:
              // Fall through
            case SocketAddress::CompareResult::SAME:
              return c;
            case SocketAddress::CompareResult::GREATER_THAN:
              return SocketAddress::CompareResult::LESS_THAN;
            case SocketAddress::CompareResult::LESS_THAN:
              return SocketAddress::CompareResult::GREATER_THAN;
          }",22,,352,2,,void
233629,BLOCK,-1,,"{

  switch (family()) {
    case AF_INET:
      switch (other.family()) {
        case AF_INET: return in_network_ipv4(*this, other, prefix);
        case AF_INET6: return in_network_ipv4_ipv6(*this, other, prefix);
      }
      break;
    case AF_INET6:
      switch (other.family()) {
        case AF_INET: return in_network_ipv6_ipv4(*this, other, prefix);
        case AF_INET6: return in_network_ipv6(*this, other, prefix);
      }
      break;
  }

  return false;
}",23,,373,3,,void
233632,BLOCK,-1,,"{
    case AF_INET:
      switch (other.family()) {
        case AF_INET: return in_network_ipv4(*this, other, prefix);
        case AF_INET6: return in_network_ipv4_ipv6(*this, other, prefix);
      }
      break;
    case AF_INET6:
      switch (other.family()) {
        case AF_INET: return in_network_ipv6_ipv4(*this, other, prefix);
        case AF_INET6: return in_network_ipv6(*this, other, prefix);
      }
      break;
  }",21,,375,2,,void
233640,BLOCK,-1,,"{
        case AF_INET: return in_network_ipv4(*this, other, prefix);
        case AF_INET6: return in_network_ipv4_ipv6(*this, other, prefix);
      }",31,,377,2,,void
233665,BLOCK,-1,,"{
        case AF_INET: return in_network_ipv6_ipv4(*this, other, prefix);
        case AF_INET6: return in_network_ipv6(*this, other, prefix);
      }",31,,383,2,,void
233689,BLOCK,-1,,<empty>,23,,395,2,,void
233694,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  std::unique_ptr<Rule> rule =
      std::make_unique<SocketAddressRule>(address);
  rules_.emplace_front(std::move(rule));
  address_rules_[*address.get()] = rules_.begin();
}",52,,398,2,,void
233738,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  auto it = address_rules_.find(*address.get());
  if (it != std::end(address_rules_)) {
    rules_.erase(it->second);
    address_rules_.erase(it);
  }
}",52,,407,2,,void
233762,BLOCK,-1,,"{
    rules_.erase(it->second);
    address_rules_.erase(it);
  }",39,,410,2,,void
233780,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  std::unique_ptr<Rule> rule =
      std::make_unique<SocketAddressRangeRule>(start, end);
  rules_.emplace_front(std::move(rule));
}",48,,418,3,,void
233816,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  std::unique_ptr<Rule> rule =
      std::make_unique<SocketAddressMaskRule>(network, prefix);
  rules_.emplace_front(std::move(rule));
}",17,,427,3,,void
233851,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  for (const auto& rule : rules_) {
    if (rule->Apply(address))
      return true;
  }
  return parent_ ? parent_->Apply(address) : false;
}",52,,435,2,,void
233858,BLOCK,-1,,"{
    if (rule->Apply(address))
      return true;
  }",35,,437,3,,void
233865,BLOCK,-1,,<empty>,7,,439,2,,void
233881,BLOCK,-1,,<empty>,25,,446,2,,void
233887,BLOCK,-1,,<empty>,17,,452,3,,void
233893,BLOCK,-1,,<empty>,23,,458,3,,void
233898,BLOCK,-1,,"{
  return this->address->is_match(*address.get());
}",52,,461,2,,void
233914,BLOCK,-1,,"{
  std::string ret = ""Address: "";
  ret += address->family() == AF_INET ? ""IPv4"" : ""IPv6"";
  ret += "" "";
  ret += address->address();
  return ret;
}",67,,465,1,,void
233945,BLOCK,-1,,"{
  return *address.get() >= *start.get() &&
         *address.get() <= *end.get();
}",52,,474,2,,void
233973,BLOCK,-1,,"{
  std::string ret = ""Range: "";
  ret += start->family() == AF_INET ? ""IPv4"" : ""IPv6"";
  ret += "" "";
  ret += start->address();
  ret += ""-"";
  ret += end->address();
  return ret;
}",72,,479,1,,void
234013,BLOCK,-1,,"{
  return address->is_in_network(*network.get(), prefix);
}",52,,490,2,,void
234028,BLOCK,-1,,"{
  std::string ret = ""Subnet: "";
  ret += network->family() == AF_INET ? ""IPv4"" : ""IPv6"";
  ret += "" "";
  ret += network->address();
  ret += ""/"" + std::to_string(prefix);
  return ret;
}",71,,494,1,,void
234068,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  std::vector<Local<Value>> rules;
  if (!ListRules(env, &rules))
    return MaybeLocal<Array>();
  return Array::New(env->isolate(), rules.data(), rules.size());
}",71,,503,2,,void
234087,BLOCK,-1,,<empty>,5,,507,2,,void
234112,BLOCK,-1,,"{
  if (parent_ && !parent_->ListRules(env, rules))
    return false;
  for (const auto& rule : rules_) {
    Local<Value> str;
    if (!rule->ToV8String(env).ToLocal(&str))
      return false;
    rules->push_back(str);
  }
  return true;
}",47,,513,3,,void
234123,BLOCK,-1,,<empty>,5,,515,2,,void
234129,BLOCK,-1,,"{
    Local<Value> str;
    if (!rule->ToV8String(env).ToLocal(&str))
      return false;
    rules->push_back(str);
  }",35,,516,3,,void
234147,BLOCK,-1,,<empty>,7,,519,2,,void
234161,BLOCK,-1,,"{
  tracker->TrackField(""rules"", rules_);
}",77,,525,2,,void
234172,BLOCK,-1,,"{
  tracker->TrackField(""address"", address);
}",41,,530,2,,void
234183,BLOCK,-1,,"{
  tracker->TrackField(""start"", start);
  tracker->TrackField(""end"", end);
}",41,,535,2,,void
234200,BLOCK,-1,,"{
  tracker->TrackField(""network"", network);
}",41,,541,2,,void
234213,BLOCK,-1,,"{
  MakeWeak();
}",40,,550,4,,void
234219,BLOCK,-1,,"{
  Local<Object> obj;
  if (!env->blocklist_constructor_template()
          ->InstanceTemplate()
          ->NewInstance(env->context()).ToLocal(&obj)) {
    return BaseObjectPtr<SocketAddressBlockListWrap>();
  }
  BaseObjectPtr<SocketAddressBlockListWrap> wrap =
      MakeBaseObject<SocketAddressBlockListWrap>(env, obj);
  CHECK(wrap);
  return wrap;
}",23,,555,2,,void
234246,BLOCK,-1,,"{
    return BaseObjectPtr<SocketAddressBlockListWrap>();
  }",56,,559,2,,void
234271,BLOCK,-1,,"{
  Local<Object> obj;
  if (!env->blocklist_constructor_template()
          ->InstanceTemplate()
          ->NewInstance(env->context()).ToLocal(&obj)) {
    return BaseObjectPtr<SocketAddressBlockListWrap>();
  }
  BaseObjectPtr<SocketAddressBlockListWrap> wrap =
      MakeBaseObject<SocketAddressBlockListWrap>(
          env,
          obj,
          std::move(blocklist));
  CHECK(wrap);
  return wrap;
}",56,,570,3,,void
234298,BLOCK,-1,,"{
    return BaseObjectPtr<SocketAddressBlockListWrap>();
  }",56,,574,2,,void
234327,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new SocketAddressBlockListWrap(env, args.This());
}",46,,587,2,,void
234352,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  SocketAddressBlockListWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK(SocketAddressBase::HasInstance(env, args[0]));
  SocketAddressBase* addr;
  ASSIGN_OR_RETURN_UNWRAP(&addr, args[0]);

  wrap->blocklist_->AddSocketAddress(addr->address());

  args.GetReturnValue().Set(true);
}",46,,594,2,,void
234407,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  SocketAddressBlockListWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK(SocketAddressBase::HasInstance(env, args[0]));
  CHECK(SocketAddressBase::HasInstance(env, args[1]));

  SocketAddressBase* start_addr;
  SocketAddressBase* end_addr;
  ASSIGN_OR_RETURN_UNWRAP(&start_addr, args[0]);
  ASSIGN_OR_RETURN_UNWRAP(&end_addr, args[1]);

  // Starting address must come before the end address
  if (*start_addr->address().get() > *end_addr->address().get())
    return args.GetReturnValue().Set(false);

  wrap->blocklist_->AddSocketAddressRange(
      start_addr->address(),
      end_addr->address());

  args.GetReturnValue().Set(true);
}",46,,609,2,,void
234474,BLOCK,-1,,<empty>,5,,624,2,,void
234510,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  SocketAddressBlockListWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK(SocketAddressBase::HasInstance(env, args[0]));
  CHECK(args[1]->IsInt32());

  SocketAddressBase* addr;
  ASSIGN_OR_RETURN_UNWRAP(&addr, args[0]);

  int32_t prefix;
  if (!args[1]->Int32Value(env->context()).To(&prefix)) {
    return;
  }

  CHECK_IMPLIES(addr->address()->family() == AF_INET, prefix <= 32);
  CHECK_IMPLIES(addr->address()->family() == AF_INET6, prefix <= 128);
  CHECK_GE(prefix, 0);

  wrap->blocklist_->AddSocketAddressMask(addr->address(), prefix);

  args.GetReturnValue().Set(true);
}",46,,634,2,,void
234568,BLOCK,-1,,"{
    return;
  }",57,,646,2,,void
234622,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  SocketAddressBlockListWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK(SocketAddressBase::HasInstance(env, args[0]));
  SocketAddressBase* addr;
  ASSIGN_OR_RETURN_UNWRAP(&addr, args[0]);

  args.GetReturnValue().Set(wrap->blocklist_->Apply(addr->address()));
}",46,,660,2,,void
234676,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  SocketAddressBlockListWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  Local<Array> rules;
  if (wrap->blocklist_->ListRules(env).ToLocal(&rules))
    args.GetReturnValue().Set(rules);
}",46,,673,2,,void
234711,BLOCK,-1,,<empty>,5,,679,2,,void
234724,BLOCK,-1,,"{
  blocklist_->MemoryInfo(tracker);
}",75,,682,2,,void
234733,BLOCK,-1,,"{
  return std::make_unique<TransferData>(this);
}",55,,687,1,,void
234747,BLOCK,-1,,"{
  return GetConstructorTemplate(env)->HasInstance(value);
}",25,,693,3,,void
234759,BLOCK,-1,,"{
  Local<FunctionTemplate> tmpl = env->blocklist_constructor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, SocketAddressBlockListWrap::New);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), ""BlockList""));
    tmpl->InstanceTemplate()->SetInternalFieldCount(kInternalFieldCount);
    SetProtoMethod(isolate, tmpl, ""addAddress"", AddAddress);
    SetProtoMethod(isolate, tmpl, ""addRange"", AddRange);
    SetProtoMethod(isolate, tmpl, ""addSubnet"", AddSubnet);
    SetProtoMethod(isolate, tmpl, ""check"", Check);
    SetProtoMethod(isolate, tmpl, ""getRules"", GetRules);
    env->set_blocklist_constructor_template(tmpl);
  }
  return tmpl;
}",23,,698,2,,void
234775,BLOCK,-1,,"{
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, SocketAddressBlockListWrap::New);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), ""BlockList""));
    tmpl->InstanceTemplate()->SetInternalFieldCount(kInternalFieldCount);
    SetProtoMethod(isolate, tmpl, ""addAddress"", AddAddress);
    SetProtoMethod(isolate, tmpl, ""addRange"", AddRange);
    SetProtoMethod(isolate, tmpl, ""addSubnet"", AddSubnet);
    SetProtoMethod(isolate, tmpl, ""check"", Check);
    SetProtoMethod(isolate, tmpl, ""getRules"", GetRules);
    env->set_blocklist_constructor_template(tmpl);
  }",23,,700,2,,void
234847,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);

  SetConstructorFunction(context,
                         target,
                         ""BlockList"",
                         GetConstructorTemplate(env),
                         SetConstructorFunctionFlag::NONE);

  SocketAddressBase::Initialize(env, target);

  NODE_DEFINE_CONSTANT(target, AF_INET);
  NODE_DEFINE_CONSTANT(target, AF_INET6);
}",17,,719,5,,void
234883,BLOCK,-1,,"{
  return New(env, std::move(blocklist_));
}",49,,737,4,,void
234896,BLOCK,-1,,"{
  blocklist_->MemoryInfo(tracker);
}",35,,742,2,,void
234907,BLOCK,-1,,"{
  return GetConstructorTemplate(env)->HasInstance(value);
}",75,,746,3,,void
234919,BLOCK,-1,,"{
  Local<FunctionTemplate> tmpl = env->socketaddress_constructor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, New);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), ""SocketAddress""));
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        SocketAddressBase::kInternalFieldCount);
    SetProtoMethod(isolate, tmpl, ""detail"", Detail);
    SetProtoMethod(isolate, tmpl, ""legacyDetail"", LegacyDetail);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""flowlabel"", GetFlowLabel);
    env->set_socketaddress_constructor_template(tmpl);
  }
  return tmpl;
}",23,,751,2,,void
234935,BLOCK,-1,,"{
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, New);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), ""SocketAddress""));
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        SocketAddressBase::kInternalFieldCount);
    SetProtoMethod(isolate, tmpl, ""detail"", Detail);
    SetProtoMethod(isolate, tmpl, ""legacyDetail"", LegacyDetail);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""flowlabel"", GetFlowLabel);
    env->set_socketaddress_constructor_template(tmpl);
  }",23,,753,2,,void
234995,BLOCK,-1,,"{
  SetConstructorFunction(env->context(),
                         target,
                         ""SocketAddress"",
                         GetConstructorTemplate(env),
                         SetConstructorFunctionFlag::NONE);
}",76,,767,3,,void
235013,BLOCK,-1,,"{
  Local<Object> obj;
  if (!GetConstructorTemplate(env)
          ->InstanceTemplate()
          ->NewInstance(env->context()).ToLocal(&obj)) {
    return BaseObjectPtr<SocketAddressBase>();
  }

  return MakeBaseObject<SocketAddressBase>(env, obj, std::move(address));
}",45,,777,3,,void
235038,BLOCK,-1,,"{
    return BaseObjectPtr<SocketAddressBase>();
  }",56,,781,2,,void
235059,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args.IsConstructCall());
  CHECK(args[0]->IsString());  // address
  CHECK(args[1]->IsInt32());  // port
  CHECK(args[2]->IsInt32());  // family
  CHECK(args[3]->IsUint32());  // flow label

  Utf8Value address(env->isolate(), args[0]);
  int32_t port = args[1].As<Int32>()->Value();
  int32_t family = args[2].As<Int32>()->Value();
  uint32_t flow_label = args[3].As<Uint32>()->Value();

  std::shared_ptr<SocketAddress> addr = std::make_shared<SocketAddress>();

  if (!SocketAddress::New(family, *address, port, addr.get()))
    return THROW_ERR_INVALID_ADDRESS(env);

  addr->set_flow_label(flow_label);

  new SocketAddressBase(env, args.This(), std::move(addr));
}",70,,788,2,,void
235172,BLOCK,-1,,<empty>,5,,804,2,,void
235197,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsObject());
  Local<Object> detail = args[0].As<Object>();

  SocketAddressBase* base;
  ASSIGN_OR_RETURN_UNWRAP(&base, args.Holder());

  Local<Value> address;
  if (!ToV8Value(env->context(), base->address_->address()).ToLocal(&address))
    return;

  if (detail->Set(env->context(), env->address_string(), address).IsJust() &&
      detail->Set(
          env->context(),
          env->port_string(),
          Int32::New(env->isolate(), base->address_->port())).IsJust() &&
      detail->Set(
          env->context(),
          env->family_string(),
          Int32::New(env->isolate(), base->address_->family())).IsJust() &&
      detail->Set(
          env->context(),
          env->flowlabel_string(),
          Uint32::New(env->isolate(), base->address_->flow_label()))
              .IsJust()) {
    args.GetReturnValue().Set(detail);
  }
}",73,,811,2,,void
235256,BLOCK,-1,,<empty>,5,,821,2,,void
235365,BLOCK,-1,,"{
    args.GetReturnValue().Set(detail);
  }",26,,836,2,,void
235378,BLOCK,-1,,"{
  SocketAddressBase* base;
  ASSIGN_OR_RETURN_UNWRAP(&base, args.Holder());
  args.GetReturnValue().Set(base->address_->flow_label());
}",79,,841,2,,void
235404,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  SocketAddressBase* base;
  ASSIGN_OR_RETURN_UNWRAP(&base, args.Holder());
  Local<Object> address;
  if (!base->address_->ToJS(env).ToLocal(&address)) return;
  args.GetReturnValue().Set(address);
}",79,,847,2,,void
235440,BLOCK,-1,,<empty>,53,,852,2,,void
235456,BLOCK,-1,,"{
  MakeWeak();
}",36,,861,4,,void
235462,BLOCK,-1,,"{
  tracker->TrackField(""address"", address_);
}",66,,865,2,,void
235472,BLOCK,-1,,"{
  return std::make_unique<TransferData>(this);
}",46,,870,1,,void
235485,BLOCK,-1,,"{
  tracker->TrackField(""address"", address_);
}",80,,874,2,,void
235498,BLOCK,-1,,"{
  return SocketAddressBase::Create(env, std::move(address_));
}",49,,881,4,,void
235539,BLOCK,-1,,<empty>,1,,1,1,,ANY
235562,BLOCK,-1,,<empty>,1,,1,1,,ANY
235567,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();
  Local<ObjectTemplate> target = ctor->InstanceTemplate();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, StatWatcher::New);
  t->InstanceTemplate()->SetInternalFieldCount(
      StatWatcher::kInternalFieldCount);
  t->Inherit(HandleWrap::GetConstructorTemplate(isolate_data));
  SetProtoMethod(isolate, t, ""start"", StatWatcher::Start);

  SetConstructorFunction(isolate, target, ""StatWatcher"", t);
}",76,,48,3,,void
235631,BLOCK,-1,,"{
  registry->Register(StatWatcher::New);
  registry->Register(StatWatcher::Start);
}",42,,62,2,,void
235652,BLOCK,-1,,"{
  CHECK_EQ(0, uv_fs_poll_init(env()->event_loop(), &watcher_));
}",35,,75,4,,void
235669,BLOCK,-1,,"{
  StatWatcher* wrap = ContainerOf(&StatWatcher::watcher_, handle);
  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Value> arr = fs::FillGlobalStatsArray(
      wrap->binding_data_.get(), wrap->use_bigint_, curr);
  USE(fs::FillGlobalStatsArray(
      wrap->binding_data_.get(), wrap->use_bigint_, prev, true));

  Local<Value> argv[2] = { Integer::New(env->isolate(), status), arr };
  wrap->MakeCallback(env->onchange_string(), arraysize(argv), argv);
}",51,,83,5,,void
235757,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  fs::BindingData* binding_data = Realm::GetBindingData<fs::BindingData>(args);
  new StatWatcher(binding_data, args.This(), args[0]->IsTrue());
}",64,,99,2,,void
235792,BLOCK,-1,,"{
  CHECK_EQ(args.Length(), 2);

  StatWatcher* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  CHECK(!uv_is_active(wrap->GetHandle()));

  node::Utf8Value path(args.GetIsolate(), args[0]);
  CHECK_NOT_NULL(*path);

  CHECK(args[1]->IsUint32());
  const uint32_t interval = args[1].As<Uint32>()->Value();

  // Note that uv_fs_poll_start does not return ENOENT, we are handling
  // mostly memory errors here.
  const int err = uv_fs_poll_start(&wrap->watcher_, Callback, *path, interval);
  if (err != 0) {
    args.GetReturnValue().Set(err);
  }
}",66,,106,2,,void
235861,BLOCK,-1,,"{
    args.GetReturnValue().Set(err);
  }",17,,122,2,,void
235884,BLOCK,-1,,<empty>,1,,1,1,,ANY
235895,BLOCK,-1,,<empty>,1,,1,1,,ANY
235903,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
#define V(PropertyName, StringValue)                                           \
  target                                                                       \
      ->Set(env->context(),                                                    \
            env->PropertyName()->Description(env->isolate()),                  \
            env->PropertyName())                                               \
      .Check();
  PER_ISOLATE_SYMBOL_PROPERTIES(V)
#undef V
}",36,,17,5,,void
235941,BLOCK,-1,,<empty>,1,,1,1,,ANY
235947,BLOCK,-1,,"{
  Local<Value> maybe_async_id;
  if (!promise->Get(env->context(), id_symbol).ToLocal(&maybe_async_id)) {
    return v8::Just(AsyncWrap::kInvalidAsyncId);
  }
  return maybe_async_id->IsNumber()
      ? maybe_async_id->NumberValue(env->context())
      : v8::Just(AsyncWrap::kInvalidAsyncId);
}",72,,36,4,,void
235969,BLOCK,-1,,"{
    return v8::Just(AsyncWrap::kInvalidAsyncId);
  }",74,,38,2,,void
236005,BLOCK,-1,,"{
  // This check is imperfect. If the internal field is set, it should
  // be an object. If it's not, we just ignore it. Ideally v8 would
  // have had GetInternalField returning a MaybeLocal but this works
  // for now.
  Local<Value> promiseWrap = promise->GetInternalField(0);
  if (promiseWrap->IsObject()) {
        Local<Value> maybe_async_id;
    if (!promiseWrap.As<Object>()->Get(env->context(), id_symbol)
        .ToLocal(&maybe_async_id)) {
      return v8::Just(AsyncWrap::kInvalidAsyncId);
    }
    return maybe_async_id->IsNumber()
        ? maybe_async_id->NumberValue(env->context())
        : v8::Just(AsyncWrap::kInvalidAsyncId);
  } else {
      return v8::Just(AsyncWrap::kInvalidAsyncId);
  }
}",76,,48,4,,void
236022,BLOCK,-1,,"{
        Local<Value> maybe_async_id;
    if (!promiseWrap.As<Object>()->Get(env->context(), id_symbol)
        .ToLocal(&maybe_async_id)) {
      return v8::Just(AsyncWrap::kInvalidAsyncId);
    }
    return maybe_async_id->IsNumber()
        ? maybe_async_id->NumberValue(env->context())
        : v8::Just(AsyncWrap::kInvalidAsyncId);
  }",32,,54,2,,void
236047,BLOCK,-1,,"{
      return v8::Just(AsyncWrap::kInvalidAsyncId);
    }",36,,57,2,,void
236078,BLOCK,-1,,"{
      return v8::Just(AsyncWrap::kInvalidAsyncId);
  }",10,,63,1,,void
236091,BLOCK,-1,,"{
  static std::atomic<uint64_t> unhandledRejections{0};
  static std::atomic<uint64_t> rejectionsHandledAfter{0};

  Local<Promise> promise = message.GetPromise();
  Isolate* isolate = promise->GetIsolate();
  PromiseRejectEvent event = message.GetEvent();

  Environment* env = Environment::GetCurrent(isolate);

  if (env == nullptr || !env->can_call_into_js()) return;

  Local<Function> callback = env->promise_reject_callback();
  // The promise is rejected before JS land calls SetPromiseRejectCallback
  // to initializes the promise reject callback during bootstrap.
  CHECK(!callback.IsEmpty());

  Local<Value> value;
  Local<Value> type = Number::New(env->isolate(), event);

  if (event == kPromiseRejectWithNoHandler) {
    value = message.GetValue();
    unhandledRejections++;
    TRACE_COUNTER2(TRACING_CATEGORY_NODE2(promises, rejections),
                  ""rejections"",
                  ""unhandled"", unhandledRejections,
                  ""handledAfter"", rejectionsHandledAfte...",58,,68,2,,void
236144,BLOCK,-1,,<empty>,51,,78,2,,void
236186,BLOCK,-1,,"{
    value = message.GetValue();
    unhandledRejections++;
    TRACE_COUNTER2(TRACING_CATEGORY_NODE2(promises, rejections),
                  ""rejections"",
                  ""unhandled"", unhandledRejections,
                  ""handledAfter"", rejectionsHandledAfter);
  }",45,,88,2,,void
236205,BLOCK,-1,,<empty>,10,,95,1,,void
236210,BLOCK,-1,,"{
    value = Undefined(isolate);
    rejectionsHandledAfter++;
    TRACE_COUNTER2(TRACING_CATEGORY_NODE2(promises, rejections),
                  ""rejections"",
                  ""unhandled"", unhandledRejections,
                  ""handledAfter"", rejectionsHandledAfter);
  }",56,,95,2,,void
236227,BLOCK,-1,,<empty>,10,,102,1,,void
236232,BLOCK,-1,,"{
    value = message.GetValue();
  }",53,,102,2,,void
236240,BLOCK,-1,,<empty>,10,,104,1,,void
236245,BLOCK,-1,,"{
    value = message.GetValue();
  }",52,,104,2,,void
236253,BLOCK,-1,,"{
    return;
  }",10,,106,1,,void
236260,BLOCK,-1,,"{
    value = Undefined(isolate);
  }",24,,110,2,,void
236301,BLOCK,-1,,<empty>,27,,121,2,,void
236317,BLOCK,-1,,<empty>,35,,123,2,,void
236331,BLOCK,-1,,"{
    // That means that promise might be a PromiseWrap, so we'll
    // check there as well.
    if (!GetAssignedPromiseWrapAsyncId(env, promise, env->async_id_symbol())
              .To(&async_id)) return;
    if (!GetAssignedPromiseWrapAsyncId(
          env, promise, env->trigger_async_id_symbol())
              .To(&trigger_async_id)) return;
  }",55,,126,2,,void
236346,BLOCK,-1,,<empty>,31,,130,2,,void
236362,BLOCK,-1,,<empty>,39,,133,2,,void
236376,BLOCK,-1,,"{
    env->async_hooks()->push_async_context(
        async_id, trigger_async_id, promise);
  }",55,,137,2,,void
236420,BLOCK,-1,,"{
    // This condition might not be true if async_hooks was enabled during
    // the promise callback execution.
    env->async_hooks()->pop_async_context(async_id);
  }",46,,147,2,,void
236440,BLOCK,-1,,"{
    fprintf(stderr, ""Exception in PromiseRejectCallback:\n"");
    PrintCaughtException(isolate, env->context(), try_catch);
  }",60,,156,2,,void
236456,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  CHECK(args[0]->IsFunction());

  isolate->GetCurrentContext()->GetMicrotaskQueue()
      ->EnqueueMicrotask(isolate, args[0].As<Function>());
}",71,,163,2,,void
236500,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  env->context()->GetMicrotaskQueue()->PerformCheckpoint(env->isolate());
}",68,,173,2,,void
236527,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  env->set_tick_callback_function(args[0].As<Function>());
}",70,,178,2,,void
236557,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsFunction());
  env->set_promise_reject_callback(args[0].As<Function>());
}",46,,185,2,,void
236590,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  SetMethod(context, target, ""enqueueMicrotask"", EnqueueMicrotask);
  SetMethod(context, target, ""setTickCallback"", SetTickCallback);
  SetMethod(context, target, ""runMicrotasks"", RunMicrotasks);
  target->Set(env->context(),
              FIXED_ONE_BYTE_STRING(isolate, ""tickInfo""),
              env->tick_info()->fields().GetJSArray()).Check();

  Local<Object> events = Object::New(isolate);
  NODE_DEFINE_CONSTANT(events, kPromiseRejectWithNoHandler);
  NODE_DEFINE_CONSTANT(events, kPromiseHandlerAddedAfterReject);
  NODE_DEFINE_CONSTANT(events, kPromiseResolveAfterResolved);
  NODE_DEFINE_CONSTANT(events, kPromiseRejectAfterResolved);

  target->Set(env->context(),
              FIXED_ONE_BYTE_STRING(isolate, ""promiseRejectEvents""),
              events).Check();
  SetMethod(
      context, target, ""setPromiseRejectCallback"", SetPromiseRejectCallback);
}",36,,195,5,,void
236661,BLOCK,1,,<empty>,,,,7,,void
236663,BLOCK,-1,,"NODE_DEFINE_CONSTANT(events, kPromiseRejectWithNoHandler)",3,,207,1,,void
236760,BLOCK,1,,<empty>,,,,7,,void
236762,BLOCK,-1,,"NODE_DEFINE_CONSTANT(events, kPromiseHandlerAddedAfterReject)",3,,208,1,,void
236859,BLOCK,1,,<empty>,,,,7,,void
236861,BLOCK,-1,,"NODE_DEFINE_CONSTANT(events, kPromiseResolveAfterResolved)",3,,209,1,,void
236958,BLOCK,1,,<empty>,,,,7,,void
236960,BLOCK,-1,,"NODE_DEFINE_CONSTANT(events, kPromiseRejectAfterResolved)",3,,210,1,,void
237076,BLOCK,-1,,"{
  registry->Register(EnqueueMicrotask);
  registry->Register(SetTickCallback);
  registry->Register(RunMicrotasks);
  registry->Register(SetPromiseRejectCallback);
}",70,,219,2,,void
237104,BLOCK,-1,,<empty>,1,,1,1,,ANY
237117,BLOCK,-1,,<empty>,1,,1,1,,ANY
237144,BLOCK,-1,,<empty>,1,,1,1,,ANY
237153,BLOCK,-1,,<empty>,,,,5,,<empty>
237158,BLOCK,-1,,<empty>,,,,2,,<empty>
237163,BLOCK,-1,,<empty>,,,,2,,<empty>
237168,BLOCK,-1,,<empty>,,,,2,,<empty>
237173,BLOCK,-1,,<empty>,,,,2,,<empty>
237177,BLOCK,-1,,{ return categories_; },54,,41,1,,void
237184,BLOCK,-1,,"{
    tracker->TrackField(""categories"", categories_);
  }",58,,43,2,,void
237201,BLOCK,-1,,"{
    MakeWeak();
  }",67,,54,4,,void
237208,BLOCK,-1,,<empty>,,,,1,,<empty>
237216,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  std::set<std::string> categories;
  CHECK(args[0]->IsArray());
  Local<Array> cats = args[0].As<Array>();
  for (size_t n = 0; n < cats->Length(); n++) {
    Local<Value> category;
    if (!cats->Get(env->context(), n).ToLocal(&category)) return;
    Utf8Value val(env->isolate(), category);
    if (!*val) return;
    categories.emplace(*val);
  }
  CHECK_NOT_NULL(GetTracingAgentWriter());
  new NodeCategorySet(env, args.This(), std::move(categories));
}",68,,62,2,,void
237254,BLOCK,-1,,<empty>,3,,67,1,,void
237267,BLOCK,4,,"{
    Local<Value> category;
    if (!cats->Get(env->context(), n).ToLocal(&category)) return;
    Utf8Value val(env->isolate(), category);
    if (!*val) return;
    categories.emplace(*val);
  }",47,,67,4,,void
237289,BLOCK,-1,,<empty>,59,,69,2,,void
237302,BLOCK,-1,,<empty>,16,,71,2,,void
237327,BLOCK,-1,,"{
  NodeCategorySet* category_set;
  ASSIGN_OR_RETURN_UNWRAP(&category_set, args.Holder());
  CHECK_NOT_NULL(category_set);
  const auto& categories = category_set->GetCategories();
  if (!category_set->enabled_ && !categories.empty()) {
    // Starts the Tracing Agent if it wasn't started already (e.g. through
    // a command line flag.)
    StartTracingAgent();
    GetTracingAgentWriter()->Enable(categories);
    category_set->enabled_ = true;
  }
}",71,,78,2,,void
237356,BLOCK,-1,,"{
    // Starts the Tracing Agent if it wasn't started already (e.g. through
    // a command line flag.)
    StartTracingAgent();
    GetTracingAgentWriter()->Enable(categories);
    category_set->enabled_ = true;
  }",55,,83,2,,void
237372,BLOCK,-1,,"{
  NodeCategorySet* category_set;
  ASSIGN_OR_RETURN_UNWRAP(&category_set, args.Holder());
  CHECK_NOT_NULL(category_set);
  const auto& categories = category_set->GetCategories();
  if (category_set->enabled_ && !categories.empty()) {
    GetTracingAgentWriter()->Disable(categories);
    category_set->enabled_ = false;
  }
}",72,,92,2,,void
237400,BLOCK,-1,,"{
    GetTracingAgentWriter()->Disable(categories);
    category_set->enabled_ = false;
  }",54,,97,2,,void
237415,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  std::string categories =
      GetTracingAgentWriter()->agent()->GetEnabledCategories();
  if (!categories.empty()) {
    args.GetReturnValue().Set(
      String::NewFromUtf8(env->isolate(),
                          categories.c_str(),
                          NewStringType::kNormal,
                          categories.size()).ToLocalChecked());
  }
}",68,,103,2,,void
237440,BLOCK,-1,,"{
    args.GetReturnValue().Set(
      String::NewFromUtf8(env->isolate(),
                          categories.c_str(),
                          NewStringType::kNormal,
                          categories.size()).ToLocalChecked());
  }",28,,107,2,,void
237474,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  env->set_trace_category_state_function(args[0].As<Function>());
}",46,,117,2,,void
237507,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  SetMethod(context, target, ""getEnabledCategories"", GetEnabledCategories);
  SetMethod(context,
            target,
            ""setTraceCategoryStateUpdateHandler"",
            SetTraceCategoryStateUpdateHandler);

  Local<FunctionTemplate> category_set =
      NewFunctionTemplate(isolate, NodeCategorySet::New);
  category_set->InstanceTemplate()->SetInternalFieldCount(
      NodeCategorySet::kInternalFieldCount);
  SetProtoMethod(isolate, category_set, ""enable"", NodeCategorySet::Enable);
  SetProtoMethod(isolate, category_set, ""disable"", NodeCategorySet::Disable);

  SetConstructorFunction(context, target, ""CategorySet"", category_set);

  Local<String> isTraceCategoryEnabled =
      FIXED_ONE_BYTE_STRING(env->isolate(), ""isTraceCategoryEnabled"");
  Local<String> trace = FIXED_ONE_BYTE_STRING(env->isolate(), ""trace"");

  // Grab the trace and isTraceCategoryEnabled intrinsics from the bi...",29,,126,5,,void
237647,BLOCK,-1,,"{
  registry->Register(GetEnabledCategories);
  registry->Register(SetTraceCategoryStateUpdateHandler);
  registry->Register(NodeCategorySet::New);
  registry->Register(NodeCategorySet::Enable);
  registry->Register(NodeCategorySet::Disable);
}",42,,160,2,,void
237692,BLOCK,-1,,<empty>,1,,1,1,,ANY
237697,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
237715,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
237733,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
237751,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
237769,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
237787,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
237805,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
237823,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
237841,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
237859,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
237877,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
237895,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
237913,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
237931,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
237949,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
237967,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
237985,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
238003,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
238021,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
238039,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
238057,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
238075,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
238093,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
238111,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
238129,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
238147,BLOCK,-1,,"{
  args.GetReturnValue().Set(
    args[0]->IsArrayBuffer() || args[0]->IsSharedArrayBuffer());
}",71,,50,2,,void
238172,BLOCK,-1,,"{
  args.GetReturnValue().Set(
    args[0]->IsNumberObject() ||
    args[0]->IsStringObject() ||
    args[0]->IsBooleanObject() ||
    args[0]->IsBigIntObject() ||
    args[0]->IsSymbolObject());
}",71,,55,2,,void
238221,BLOCK,-1,,"{
#define V(type) SetMethodNoSideEffect(context, target, ""is"" #type, Is##type);
  VALUE_METHOD_MAP(V)
#undef V

  SetMethodNoSideEffect(context, target, ""isAnyArrayBuffer"", IsAnyArrayBuffer);
  SetMethodNoSideEffect(context, target, ""isBoxedPrimitive"", IsBoxedPrimitive);
}",34,,67,5,,void
238223,BLOCK,1,,<empty>,,,,1,,void
238230,BLOCK,1,,<empty>,,,,1,,void
238365,BLOCK,-1,,"{
#define V(type) registry->Register(Is##type);
  VALUE_METHOD_MAP(V)
#undef V

  registry->Register(IsAnyArrayBuffer);
  registry->Register(IsBoxedPrimitive);
}",75,,78,2,,void
238367,BLOCK,1,,<empty>,,,,1,,void
238512,BLOCK,-1,,<empty>,1,,1,1,,ANY
238541,BLOCK,-1,,<empty>,1,,1,1,,ANY
238546,BLOCK,-1,,"{
  tracker->TrackField(""url_components_buffer"", url_components_buffer_);
}",60,,32,2,,void
238558,BLOCK,-1,,"{
  object
      ->Set(realm->context(),
            FIXED_ONE_BYTE_STRING(realm->isolate(), ""urlComponents""),
            url_components_buffer_.GetJSArray())
      .Check();
}",70,,38,3,,void
238585,BLOCK,-1,,"{
  // We'll just re-initialize the buffers in the constructor since their
  // contents can be thrown away once consumed in the previous call.
  url_components_buffer_.Release();
  // Return true because we need to maintain the reference to the binding from
  // JS land.
  return true;
}",73,,47,3,,void
238596,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info =
      InternalFieldInfoBase::New<InternalFieldInfo>(type());
  return info;
}",58,,56,2,,void
238621,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  v8::HandleScope scope(context->GetIsolate());
  Realm* realm = Realm::GetCurrent(context);
  BindingData* binding = realm->AddBindingData<BindingData>(context, holder);
  CHECK_NOT_NULL(binding);
}",60,,66,5,,void
238660,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());

  std::string input = Utf8Value(env->isolate(), args[0]).ToString();
  if (input.empty()) {
    return args.GetReturnValue().Set(FIXED_ONE_BYTE_STRING(env->isolate(), """"));
  }

  // It is important to have an initial value that contains a special scheme.
  // Since it will change the implementation of `set_hostname` according to URL
  // spec.
  auto out = ada::parse<ada::url>(""ws://x"");
  DCHECK(out);
  if (!out->set_hostname(input)) {
    return args.GetReturnValue().Set(FIXED_ONE_BYTE_STRING(env->isolate(), """"));
  }
  std::string host = out->get_hostname();
  args.GetReturnValue().Set(
      String::NewFromUtf8(env->isolate(), host.c_str()).ToLocalChecked());
}",74,,74,2,,void
238701,BLOCK,-1,,"{
    return args.GetReturnValue().Set(FIXED_ONE_BYTE_STRING(env->isolate(), """"));
  }",22,,80,2,,void
238737,BLOCK,-1,,"{
    return args.GetReturnValue().Set(FIXED_ONE_BYTE_STRING(env->isolate(), """"));
  }",34,,89,2,,void
238785,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());

  std::string input = Utf8Value(env->isolate(), args[0]).ToString();
  // It is important to have an initial value that contains a special scheme.
  // Since it will change the implementation of `set_hostname` according to URL
  // spec.
  auto out = ada::parse<ada::url>(""ws://x"");
  DCHECK(out);
  if (!out->set_hostname(input)) {
    return args.GetReturnValue().Set(
        String::NewFromUtf8(env->isolate(), """").ToLocalChecked());
  }
  std::string result = ada::unicode::to_unicode(out->get_hostname());

  args.GetReturnValue().Set(String::NewFromUtf8(env->isolate(),
                                                result.c_str(),
                                                NewStringType::kNormal,
                                                result.length())
                                .ToLocalChecked());
}",76,,97,2,,void
238842,BLOCK,-1,,"{
    return args.GetReturnValue().Set(
        String::NewFromUtf8(env->isolate(), """").ToLocalChecked());
  }",34,,108,2,,void
238909,BLOCK,-1,,"{
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());  // input
  // args[1] // base url

  Environment* env = Environment::GetCurrent(args);
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Utf8Value input(env->isolate(), args[0]);
  ada::result<ada::url_aggregator> base;
  ada::url_aggregator* base_pointer = nullptr;
  if (args[1]->IsString()) {
    base = ada::parse<ada::url_aggregator>(
        Utf8Value(env->isolate(), args[1]).ToString());
    if (!base) {
      return args.GetReturnValue().Set(false);
    }
    base_pointer = &base.value();
  }
  auto out =
      ada::parse<ada::url_aggregator>(input.ToStringView(), base_pointer);

  args.GetReturnValue().Set(out.has_value());
}",69,,121,2,,void
238972,BLOCK,-1,,"{
    base = ada::parse<ada::url_aggregator>(
        Utf8Value(env->isolate(), args[1]).ToString());
    if (!base) {
      return args.GetReturnValue().Set(false);
    }
    base_pointer = &base.value();
  }",28,,133,2,,void
238997,BLOCK,-1,,"{
      return args.GetReturnValue().Set(false);
    }",16,,136,2,,void
239048,BLOCK,-1,,"{
  std::string_view input_view(input.data, input.length);

  auto output = ada::parse<ada::url_aggregator>(input_view);

  return output.has_value();
}",64,,148,3,,void
239078,BLOCK,-1,,<empty>,,,,2,,<empty>
239083,BLOCK,-1,,"{
  CHECK_GT(args.Length(), 4);
  CHECK(args[0]->IsString());  // url href

  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  Utf8Value href(isolate, args[0].As<String>());
  const bool hash = args[1]->IsTrue();
  const bool unicode = args[2]->IsTrue();
  const bool search = args[3]->IsTrue();
  const bool auth = args[4]->IsTrue();

  // ada::url provides a faster alternative to ada::url_aggregator if we
  // directly want to manipulate the url components without using the respective
  // setters. therefore we are using ada::url here.
  auto out = ada::parse<ada::url>(href.ToStringView());
  CHECK(out);

  if (!hash) {
    out->hash = std::nullopt;
  }

  if (unicode) {
    out->host = ada::idna::to_unicode(out->get_hostname());
  }

  if (!search) {
    out->query = std::nullopt;
  }

  if (!auth) {
    out->username = """";
    out->password = """";
  }

  std::string result = out->get_href();
  args.GetReturnValue().Set(String::NewFromUtf8(en...",67,,158,2,,void
239177,BLOCK,-1,,"{
    out->hash = std::nullopt;
  }",14,,177,2,,void
239187,BLOCK,-1,,"{
    out->host = ada::idna::to_unicode(out->get_hostname());
  }",16,,181,2,,void
239205,BLOCK,-1,,"{
    out->query = std::nullopt;
  }",16,,185,2,,void
239216,BLOCK,-1,,"{
    out->username = """";
    out->password = """";
  }",14,,189,2,,void
239267,BLOCK,-1,,"{
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());  // input
  // args[1] // base url

  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = Environment::GetCurrent(args);
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Utf8Value input(env->isolate(), args[0]);
  ada::result<ada::url_aggregator> base;
  ada::url_aggregator* base_pointer = nullptr;
  if (args[1]->IsString()) {
    base = ada::parse<ada::url_aggregator>(
        Utf8Value(env->isolate(), args[1]).ToString());
    if (!base) {
      return args.GetReturnValue().Set(false);
    }
    base_pointer = &base.value();
  }
  auto out =
      ada::parse<ada::url_aggregator>(input.ToStringView(), base_pointer);

  if (!out) {
    return args.GetReturnValue().Set(false);
  }

  binding_data->UpdateComponents(out->get_components(), out->type);

  args.GetReturnValue().Set(
      ToV8Value(env->context(), out->get_href(), env->isolate(...",66,,202,2,,void
239340,BLOCK,-1,,"{
    base = ada::parse<ada::url_aggregator>(
        Utf8Value(env->isolate(), args[1]).ToString());
    if (!base) {
      return args.GetReturnValue().Set(false);
    }
    base_pointer = &base.value();
  }",28,,215,2,,void
239365,BLOCK,-1,,"{
      return args.GetReturnValue().Set(false);
    }",16,,218,2,,void
239403,BLOCK,-1,,"{
    return args.GetReturnValue().Set(false);
  }",13,,226,2,,void
239451,BLOCK,-1,,"{
  CHECK(args[0]->IsString());    // href
  CHECK(args[1]->IsNumber());    // action type
  CHECK(args[2]->IsString());    // new value

  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  enum url_update_action action = static_cast<enum url_update_action>(
      args[1]->Uint32Value(env->context()).FromJust());
  Utf8Value input(isolate, args[0].As<String>());
  Utf8Value new_value(isolate, args[2].As<String>());

  std::string_view new_value_view = new_value.ToStringView();
  auto out = ada::parse<ada::url_aggregator>(input.ToStringView());
  CHECK(out);

  bool result{true};

  switch (action) {
    case kPathname: {
      result = out->set_pathname(new_value_view);
      break;
    }
    case kHash: {
      out->set_hash(new_value_view);
      break;
    }
    case kHost: {
      result = out->set_host(new_value_view);
      break;
    }
    case kHostname: {
      re...",67,,237,2,,void
239565,BLOCK,-1,,"{
    case kPathname: {
      result = out->set_pathname(new_value_view);
      break;
    }
    case kHash: {
      out->set_hash(new_value_view);
      break;
    }
    case kHost: {
      result = out->set_host(new_value_view);
      break;
    }
    case kHostname: {
      result = out->set_hostname(new_value_view);
      break;
    }
    case kHref: {
      result = out->set_href(new_value_view);
      break;
    }
    case kPassword: {
      result = out->set_password(new_value_view);
      break;
    }
    case kPort: {
      result = out->set_port(new_value_view);
      break;
    }
    case kProtocol: {
      result = out->set_protocol(new_value_view);
      break;
    }
    case kSearch: {
      out->set_search(new_value_view);
      break;
    }
    case kUsername: {
      result = out->set_username(new_value_view);
      break;
    }
    default:
      UNREACHABLE(""Unsupported URL update action"");
  }",19,,257,2,,void
239568,BLOCK,3,,"{
      result = out->set_pathname(new_value_view);
      break;
    }",21,,258,3,,void
239579,BLOCK,6,,"{
      out->set_hash(new_value_view);
      break;
    }",17,,262,6,,void
239588,BLOCK,9,,"{
      result = out->set_host(new_value_view);
      break;
    }",17,,266,9,,void
239599,BLOCK,12,,"{
      result = out->set_hostname(new_value_view);
      break;
    }",21,,270,12,,void
239610,BLOCK,15,,"{
      result = out->set_href(new_value_view);
      break;
    }",17,,274,15,,void
239621,BLOCK,18,,"{
      result = out->set_password(new_value_view);
      break;
    }",21,,278,18,,void
239632,BLOCK,21,,"{
      result = out->set_port(new_value_view);
      break;
    }",17,,282,21,,void
239643,BLOCK,24,,"{
      result = out->set_protocol(new_value_view);
      break;
    }",21,,286,24,,void
239654,BLOCK,27,,"{
      out->set_search(new_value_view);
      break;
    }",19,,290,27,,void
239663,BLOCK,30,,"{
      result = out->set_username(new_value_view);
      break;
    }",21,,294,30,,void
239678,BLOCK,-1,,"{
    return args.GetReturnValue().Set(false);
  }",16,,302,2,,void
239727,BLOCK,-1,,"{
  url_components_buffer_[0] = components.protocol_end;
  url_components_buffer_[1] = components.username_end;
  url_components_buffer_[2] = components.host_start;
  url_components_buffer_[3] = components.host_end;
  url_components_buffer_[4] = components.port;
  url_components_buffer_[5] = components.pathname_start;
  url_components_buffer_[6] = components.search_start;
  url_components_buffer_[7] = components.hash_start;
  url_components_buffer_[8] = type;
  static_assert(kURLComponentsLength == 9,
                ""kURLComponentsLength should be up-to-date"");
}",66,,313,3,,void
239799,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();
  Local<ObjectTemplate> target = ctor->InstanceTemplate();
  SetMethodNoSideEffect(isolate, target, ""domainToASCII"", DomainToASCII);
  SetMethodNoSideEffect(isolate, target, ""domainToUnicode"", DomainToUnicode);
  SetMethodNoSideEffect(isolate, target, ""format"", Format);
  SetMethod(isolate, target, ""parse"", Parse);
  SetMethod(isolate, target, ""update"", Update);
  SetFastMethodNoSideEffect(
      isolate, target, ""canParse"", CanParse, &fast_can_parse_);
}",76,,328,3,,void
239856,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(context);
  realm->AddBindingData<BindingData>(context, target);
}",58,,343,5,,void
239879,BLOCK,-1,,"{
  registry->Register(DomainToASCII);
  registry->Register(DomainToUnicode);
  registry->Register(Format);
  registry->Register(Parse);
  registry->Register(Update);
  registry->Register(CanParse);
  registry->Register(FastCanParse);
  registry->Register(fast_can_parse_.GetTypeInfo());
}",42,,349,2,,void
239927,BLOCK,-1,,"{
  std::string escaped_file_path;
  for (size_t i = 0; i < file_path.length(); ++i) {
    escaped_file_path += file_path[i];
    if (file_path[i] == '%') escaped_file_path += ""25"";
  }
  return ada::href_from_file(escaped_file_path);
}",60,,360,2,,void
239930,BLOCK,-1,,<empty>,3,,362,1,,void
239943,BLOCK,4,,"{
    escaped_file_path += file_path[i];
    if (file_path[i] == '%') escaped_file_path += ""25"";
  }",51,,362,4,,void
239955,BLOCK,-1,,<empty>,30,,364,2,,void
239990,BLOCK,-1,,<empty>,1,,1,1,,ANY
240005,BLOCK,-1,,<empty>,1,,1,1,,ANY
240015,BLOCK,-1,,"{
  CHECK(args[0]->IsObject());

  Local<Object> object = args[0].As<Object>();
  Local<String> name = object->GetConstructorName();

  args.GetReturnValue().Set(name);
}",46,,77,2,,void
240057,BLOCK,-1,,"{
  CHECK(args[0]->IsExternal());
  Isolate* isolate = args.GetIsolate();
  Local<External> external = args[0].As<External>();

  void* ptr = external->Value();
  uint64_t value = reinterpret_cast<uint64_t>(ptr);
  Local<BigInt> ret = BigInt::NewFromUnsigned(isolate, value);
  args.GetReturnValue().Set(ret);
}",46,,87,2,,void
240121,BLOCK,-1,,"{
  // Return undefined if it's not a Promise.
  if (!args[0]->IsPromise())
    return;

  auto isolate = args.GetIsolate();

  Local<Promise> promise = args[0].As<Promise>();

  int state = promise->State();
  Local<Value> values[2] = { Integer::New(isolate, state) };
  size_t number_of_values = 1;
  if (state != Promise::PromiseState::kPending)
    values[number_of_values++] = promise->Result();
  Local<Array> ret = Array::New(isolate, values, number_of_values);
  args.GetReturnValue().Set(ret);
}",72,,98,2,,void
240130,BLOCK,-1,,<empty>,5,,101,2,,void
240178,BLOCK,-1,,<empty>,5,,111,2,,void
240213,BLOCK,-1,,"{
  // Return undefined if it's not a proxy.
  if (!args[0]->IsProxy())
    return;

  Local<Proxy> proxy = args[0].As<Proxy>();

  // TODO(BridgeAR): Remove the length check as soon as we prohibit access to
  // the util binding layer. It's accessed in the wild and `esm` would break in
  // case the check is removed.
  if (args.Length() == 1 || args[1]->IsTrue()) {
    Local<Value> ret[] = {
      proxy->GetTarget(),
      proxy->GetHandler()
    };

    args.GetReturnValue().Set(
        Array::New(args.GetIsolate(), ret, arraysize(ret)));
  } else {
    Local<Value> ret = proxy->GetTarget();

    args.GetReturnValue().Set(ret);
  }
}",70,,116,2,,void
240222,BLOCK,-1,,<empty>,5,,119,2,,void
240250,BLOCK,-1,,"{
    Local<Value> ret[] = {
      proxy->GetTarget(),
      proxy->GetHandler()
    };

    args.GetReturnValue().Set(
        Array::New(args.GetIsolate(), ret, arraysize(ret)));
  }",48,,126,2,,void
240282,BLOCK,-1,,"{
    Local<Value> ret = proxy->GetTarget();

    args.GetReturnValue().Set(ret);
  }",10,,134,1,,void
240305,BLOCK,-1,,"{
  if (args[0]->IsArrayBuffer()) {
    auto buffer = args[0].As<v8::ArrayBuffer>();
    args.GetReturnValue().Set(buffer->WasDetached());
    return;
  }
  args.GetReturnValue().Set(false);
}",76,,141,2,,void
240313,BLOCK,-1,,"{
    auto buffer = args[0].As<v8::ArrayBuffer>();
    args.GetReturnValue().Set(buffer->WasDetached());
    return;
  }",33,,142,2,,void
240347,BLOCK,-1,,"{
  if (!args[0]->IsObject())
    return;

  Environment* env = Environment::GetCurrent(args);
  bool is_key_value;
  Local<Array> entries;
  if (!args[0].As<Object>()->PreviewEntries(&is_key_value).ToLocal(&entries))
    return;
  // Fast path for WeakMap and WeakSet.
  if (args.Length() == 1)
    return args.GetReturnValue().Set(entries);

  Local<Value> ret[] = {
    entries,
    Boolean::New(env->isolate(), is_key_value)
  };
  return args.GetReturnValue().Set(
      Array::New(env->isolate(), ret, arraysize(ret)));
}",69,,150,2,,void
240356,BLOCK,-1,,<empty>,5,,152,2,,void
240390,BLOCK,-1,,<empty>,5,,158,2,,void
240399,BLOCK,-1,,<empty>,5,,161,2,,void
240446,BLOCK,-1,,"{
  CHECK(args[0]->IsUint32());
  uint32_t msec = args[0].As<Uint32>()->Value();
  uv_sleep(msec);
}",60,,171,2,,void
240472,BLOCK,-1,,"{
  CHECK(args[0]->IsArrayBufferView());
  args.GetReturnValue().Set(args[0].As<ArrayBufferView>()->HasBuffer());
}",72,,177,2,,void
240502,BLOCK,-1,,<empty>,47,,185,4,,void
240510,BLOCK,-1,,"{
  MakeWeak();
  if (!target.IsEmpty()) {
    target_.Reset(realm->isolate(), target);
    if (reference_count_ == 0) {
      target_.SetWeak();
    }
  }
}",41,,192,5,,void
240518,BLOCK,-1,,"{
    target_.Reset(realm->isolate(), target);
    if (reference_count_ == 0) {
      target_.SetWeak();
    }
  }",26,,194,2,,void
240532,BLOCK,-1,,"{
      target_.SetWeak();
    }",32,,196,2,,void
240542,BLOCK,-1,,"{
  if (target_.IsEmpty()) {
    target_index_ = 0;
    return true;
  }

  // Users can still hold strong references to target in addition to the
  // reference that we manage here, and they could expect that the referenced
  // object remains the same as long as that external strong reference
  // is alive. Since we have no way to know if there is any other reference
  // keeping the target alive, the best we can do to maintain consistency is to
  // simply save a reference to the target in the snapshot (effectively making
  // it strong) during serialization, and restore it during deserialization.
  // If there's no known counted reference from our side, we'll make the
  // reference here weak upon deserialization so that it can be GC'ed if users
  // do not hold additional references to it.
  Local<Object> target = target_.Get(context->GetIsolate());
  target_index_ = creator->AddData(context, target);
  DCHECK_NE(target_index_, 0);
  target_.Reset();
  return true;
}",75,,203,3,,void
240548,BLOCK,-1,,"{
    target_index_ = 0;
    return true;
  }",26,,204,2,,void
240589,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info =
      InternalFieldInfoBase::New<InternalFieldInfo>(type());
  info->target = target_index_;
  info->reference_count = reference_count_;
  return info;
}",60,,226,2,,void
240624,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  HandleScope scope(context->GetIsolate());

  InternalFieldInfo* weak_info = reinterpret_cast<InternalFieldInfo*>(info);
  Local<Object> target;
  if (weak_info->target != 0) {
    target = context->GetDataFromSnapshotOnce<Object>(weak_info->target)
                 .ToLocalChecked();
  }
  new WeakReference(
      Realm::GetCurrent(context), holder, target, weak_info->reference_count);
}",62,,238,5,,void
240653,BLOCK,-1,,"{
    target = context->GetDataFromSnapshotOnce<Object>(weak_info->target)
                 .ToLocalChecked();
  }",31,,244,2,,void
240684,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(args);
  CHECK(args.IsConstructCall());
  CHECK(args[0]->IsObject());
  new WeakReference(realm, args.This(), args[0].As<Object>());
}",66,,252,2,,void
240722,BLOCK,-1,,"{
  WeakReference* weak_ref = Unwrap<WeakReference>(args.Holder());
  Isolate* isolate = args.GetIsolate();
  if (!weak_ref->target_.IsEmpty())
    args.GetReturnValue().Set(weak_ref->target_.Get(isolate));
}",66,,259,2,,void
240749,BLOCK,-1,,<empty>,5,,263,2,,void
240768,BLOCK,-1,,"{
  WeakReference* weak_ref = Unwrap<WeakReference>(args.Holder());
  weak_ref->reference_count_++;
  if (weak_ref->target_.IsEmpty()) return;
  if (weak_ref->reference_count_ == 1) weak_ref->target_.ClearWeak();
  args.GetReturnValue().Set(
      v8::Number::New(args.GetIsolate(), weak_ref->reference_count_));
}",69,,266,2,,void
240791,BLOCK,-1,,<empty>,36,,269,2,,void
240799,BLOCK,-1,,<empty>,40,,270,2,,void
240830,BLOCK,-1,,"{
  WeakReference* weak_ref = Unwrap<WeakReference>(args.Holder());
  CHECK_GE(weak_ref->reference_count_, 1);
  weak_ref->reference_count_--;
  if (weak_ref->target_.IsEmpty()) return;
  if (weak_ref->reference_count_ == 0) weak_ref->target_.SetWeak();
  args.GetReturnValue().Set(
      v8::Number::New(args.GetIsolate(), weak_ref->reference_count_));
}",69,,275,2,,void
240858,BLOCK,-1,,<empty>,36,,279,2,,void
240866,BLOCK,-1,,<empty>,40,,280,2,,void
240897,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  int fd;
  if (!args[0]->Int32Value(env->context()).To(&fd)) return;
  CHECK_GE(fd, 0);

  uv_handle_type t = uv_guess_handle(fd);
  const char* type = nullptr;

  switch (t) {
    case UV_TCP:
      type = ""TCP"";
      break;
    case UV_TTY:
      type = ""TTY"";
      break;
    case UV_UDP:
      type = ""UDP"";
      break;
    case UV_FILE:
      type = ""FILE"";
      break;
    case UV_NAMED_PIPE:
      type = ""PIPE"";
      break;
    case UV_UNKNOWN_HANDLE:
      type = ""UNKNOWN"";
      break;
    default:
      ABORT();
  }

  args.GetReturnValue().Set(OneByteString(env->isolate(), type));
}",70,,285,2,,void
240924,BLOCK,-1,,<empty>,53,,288,2,,void
240940,BLOCK,-1,,"{
    case UV_TCP:
      type = ""TCP"";
      break;
    case UV_TTY:
      type = ""TTY"";
      break;
    case UV_UDP:
      type = ""UDP"";
      break;
    case UV_FILE:
      type = ""FILE"";
      break;
    case UV_NAMED_PIPE:
      type = ""PIPE"";
      break;
    case UV_UNKNOWN_HANDLE:
      type = ""UNKNOWN"";
      break;
    default:
      ABORT();
  }",14,,294,2,,void
240996,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK_GE(args.Length(), 2);
  CHECK(args[0]->IsString());
  CHECK(args[1]->IsNumber());

  TwoByteValue value(env->isolate(), args[0]);

  int64_t start = args[1]->IntegerValue(env->context()).FromJust();
  CHECK_GE(start, 0);

  for (size_t i = start; i < value.length(); i++) {
    char16_t c = value[i];
    if (!IsUnicodeSurrogate(c)) {
      continue;
    } else if (IsUnicodeSurrogateTrail(c) || i == value.length() - 1) {
      value[i] = kUnicodeReplacementCharacter;
    } else {
      char16_t d = value[i + 1];
      if (IsUnicodeTrail(d)) {
        i++;
      } else {
        value[i] = kUnicodeReplacementCharacter;
      }
    }
  }

  args.GetReturnValue().Set(
      String::NewFromTwoByte(env->isolate(),
                             *value,
                             v8::NewStringType::kNormal,
                             value.length()).ToLocalChecked());
}",66,,320,2,,void
241054,BLOCK,-1,,<empty>,3,,331,1,,void
241067,BLOCK,4,,"{
    char16_t c = value[i];
    if (!IsUnicodeSurrogate(c)) {
      continue;
    } else if (IsUnicodeSurrogateTrail(c) || i == value.length() - 1) {
      value[i] = kUnicodeReplacementCharacter;
    } else {
      char16_t d = value[i + 1];
      if (IsUnicodeTrail(d)) {
        i++;
      } else {
        value[i] = kUnicodeReplacementCharacter;
      }
    }
  }",51,,331,4,,void
241078,BLOCK,-1,,"{
      continue;
    }",33,,333,2,,void
241081,BLOCK,-1,,<empty>,12,,335,1,,void
241094,BLOCK,-1,,"{
      value[i] = kUnicodeReplacementCharacter;
    }",71,,335,2,,void
241101,BLOCK,-1,,"{
      char16_t d = value[i + 1];
      if (IsUnicodeTrail(d)) {
        i++;
      } else {
        value[i] = kUnicodeReplacementCharacter;
      }
    }",12,,337,1,,void
241113,BLOCK,-1,,"{
        i++;
      }",30,,339,2,,void
241117,BLOCK,-1,,"{
        value[i] = kUnicodeReplacementCharacter;
      }",14,,341,1,,void
241156,BLOCK,-1,,"{
  registry->Register(GetPromiseDetails);
  registry->Register(GetProxyDetails);
  registry->Register(IsArrayBufferDetached);
  registry->Register(PreviewEntries);
  registry->Register(GetOwnNonIndexProperties);
  registry->Register(GetConstructorName);
  registry->Register(GetExternalValue);
  registry->Register(Sleep);
  registry->Register(ArrayBufferViewHasBuffer);
  registry->Register(WeakReference::New);
  registry->Register(WeakReference::Get);
  registry->Register(WeakReference::IncRef);
  registry->Register(WeakReference::DecRef);
  registry->Register(GuessHandleType);
  registry->Register(ToUSVString);
}",70,,354,2,,void
241247,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  {
    Local<ObjectTemplate> tmpl = ObjectTemplate::New(isolate);
#define V(PropertyName, _)                                                     \
  tmpl->Set(FIXED_ONE_BYTE_STRING(env->isolate(), #PropertyName),              \
            env->PropertyName());

    PER_ISOLATE_PRIVATE_SYMBOL_PROPERTIES(V)
#undef V

    target
        ->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""privateSymbols""),
              tmpl->NewInstance(context).ToLocalChecked())
        .Check();
  }

  {
    Local<Object> constants = Object::New(isolate);
#define V(name)                                                                \
  constants                                                                    \
      ->Set(context,                                                           \
            FIXED_ONE_BYTE_STRING(isolate, #name),                             \
            Integer::Ne...",29,,375,5,,void
241263,BLOCK,5,,"{
    Local<ObjectTemplate> tmpl = ObjectTemplate::New(isolate);
#define V(PropertyName, _)                                                     \
  tmpl->Set(FIXED_ONE_BYTE_STRING(env->isolate(), #PropertyName),              \
            env->PropertyName());

    PER_ISOLATE_PRIVATE_SYMBOL_PROPERTIES(V)
#undef V

    target
        ->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""privateSymbols""),
              tmpl->NewInstance(context).ToLocalChecked())
        .Check();
  }",3,,379,5,,void
241296,BLOCK,6,,"{
    Local<Object> constants = Object::New(isolate);
#define V(name)                                                                \
  constants                                                                    \
      ->Set(context,                                                           \
            FIXED_ONE_BYTE_STRING(isolate, #name),                             \
            Integer::New(isolate, Promise::PromiseState::name))                \
      .Check();

    V(kPending);
    V(kFulfilled);
    V(kRejected);
#undef V

#define V(name)                                                                \
  constants                                                                    \
      ->Set(context,                                                           \
            FIXED_ONE_BYTE_STRING(isolate, #name),                             \
            Integer::New(isolate, Environment::ExitInfoField::name))           \
      .Check();

    V(kExiting);
    V(kExitCode);
...",3,,395,6,,void
241309,BLOCK,1,,<empty>,,,,3,,void
241332,BLOCK,1,,<empty>,,,,3,,void
241355,BLOCK,1,,<empty>,,,,3,,void
241378,BLOCK,1,,<empty>,,,,3,,void
241401,BLOCK,1,,<empty>,,,,3,,void
241424,BLOCK,1,,<empty>,,,,3,,void
241447,BLOCK,1,,<empty>,,,,3,,void
241468,BLOCK,1,,<empty>,,,,3,,void
241489,BLOCK,1,,<empty>,,,,3,,void
241510,BLOCK,1,,<empty>,,,,3,,void
241531,BLOCK,1,,<empty>,,,,3,,void
241552,BLOCK,1,,<empty>,,,,3,,void
241729,BLOCK,-1,,<empty>,1,,1,1,,ANY
241752,BLOCK,-1,,<empty>,1,,1,1,,ANY
241759,BLOCK,1,,<empty>,,,,1,,void
241792,BLOCK,1,,<empty>,,,,1,,void
241805,BLOCK,1,,<empty>,,,,1,,void
241818,BLOCK,-1,,"{
  Local<Context> context = realm->context();
  if (info == nullptr) {
    obj->Set(context,
             FIXED_ONE_BYTE_STRING(realm->isolate(), ""heapStatisticsBuffer""),
             heap_statistics_buffer.GetJSArray())
        .Check();
    obj->Set(
           context,
           FIXED_ONE_BYTE_STRING(realm->isolate(), ""heapCodeStatisticsBuffer""),
           heap_code_statistics_buffer.GetJSArray())
        .Check();
    obj->Set(
           context,
           FIXED_ONE_BYTE_STRING(realm->isolate(), ""heapSpaceStatisticsBuffer""),
           heap_space_statistics_buffer.GetJSArray())
        .Check();
  } else {
    heap_statistics_buffer.Deserialize(realm->context());
    heap_code_statistics_buffer.Deserialize(realm->context());
    heap_space_statistics_buffer.Deserialize(realm->context());
  }
  heap_statistics_buffer.MakeWeak();
  heap_space_statistics_buffer.MakeWeak();
  heap_code_statistics_buffer.MakeWeak();
}",63,,109,4,,void
241833,BLOCK,-1,,"{
    obj->Set(context,
             FIXED_ONE_BYTE_STRING(realm->isolate(), ""heapStatisticsBuffer""),
             heap_statistics_buffer.GetJSArray())
        .Check();
    obj->Set(
           context,
           FIXED_ONE_BYTE_STRING(realm->isolate(), ""heapCodeStatisticsBuffer""),
           heap_code_statistics_buffer.GetJSArray())
        .Check();
    obj->Set(
           context,
           FIXED_ONE_BYTE_STRING(realm->isolate(), ""heapSpaceStatisticsBuffer""),
           heap_space_statistics_buffer.GetJSArray())
        .Check();
  }",24,,111,2,,void
241889,BLOCK,-1,,"{
    heap_statistics_buffer.Deserialize(realm->context());
    heap_code_statistics_buffer.Deserialize(realm->context());
    heap_space_statistics_buffer.Deserialize(realm->context());
  }",10,,126,1,,void
241931,BLOCK,-1,,"{
  DCHECK_NULL(internal_field_info_);
  internal_field_info_ = InternalFieldInfoBase::New<InternalFieldInfo>(type());
  internal_field_info_->heap_statistics_buffer =
      heap_statistics_buffer.Serialize(context, creator);
  internal_field_info_->heap_space_statistics_buffer =
      heap_space_statistics_buffer.Serialize(context, creator);
  internal_field_info_->heap_code_statistics_buffer =
      heap_code_statistics_buffer.Serialize(context, creator);
  // Return true because we need to maintain the reference to the binding from
  // JS land.
  return true;
}",73,,137,3,,void
241981,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  HandleScope scope(context->GetIsolate());
  Realm* realm = Realm::GetCurrent(context);
  // Recreate the buffer in the constructor.
  InternalFieldInfo* casted_info = static_cast<InternalFieldInfo*>(info);
  BindingData* binding =
      realm->AddBindingData<BindingData>(context, holder, casted_info);
  CHECK_NOT_NULL(binding);
}",60,,154,5,,void
242027,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info = internal_field_info_;
  internal_field_info_ = nullptr;
  return info;
}",58,,165,2,,void
242046,BLOCK,-1,,"{
  tracker->TrackField(""heap_statistics_buffer"", heap_statistics_buffer);
  tracker->TrackField(""heap_space_statistics_buffer"",
                      heap_space_statistics_buffer);
  tracker->TrackField(""heap_code_statistics_buffer"",
                      heap_code_statistics_buffer);
}",60,,172,2,,void
242069,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Local<Integer> result =
      Integer::NewFromUnsigned(env->isolate(),
                               ScriptCompiler::CachedDataVersionTag());
  args.GetReturnValue().Set(result);
}",68,,180,2,,void
242108,BLOCK,-1,,"{
  CHECK(args[0]->IsUint32());
  Environment* env = Environment::GetCurrent(args);
  uint32_t limit = args[0].As<v8::Uint32>()->Value();
  CHECK_GT(limit, 0);
  env->AddHeapSnapshotNearHeapLimitCallback();
  env->set_heap_snapshot_near_heap_limit(limit);
}",76,,188,2,,void
242152,BLOCK,-1,,"{
  BindingData* data = Realm::GetBindingData<BindingData>(args);
  HeapStatistics s;
  args.GetIsolate()->GetHeapStatistics(&s);
  AliasedFloat64Array& buffer = data->heap_statistics_buffer;
#define V(index, name, _) buffer[index] = static_cast<double>(s.name());
  HEAP_STATISTICS_PROPERTIES(V)
#undef V
}",74,,197,2,,void
242180,BLOCK,1,,<empty>,,,,3,,void
242325,BLOCK,-1,,"{
  BindingData* data = Realm::GetBindingData<BindingData>(args);
  HeapSpaceStatistics s;
  Isolate* const isolate = args.GetIsolate();
  CHECK(args[0]->IsUint32());
  size_t space_index = static_cast<size_t>(args[0].As<v8::Uint32>()->Value());
  isolate->GetHeapSpaceStatistics(&s, space_index);

  AliasedFloat64Array& buffer = data->heap_space_statistics_buffer;

#define V(index, name, _) buffer[index] = static_cast<double>(s.name());
  HEAP_SPACE_STATISTICS_PROPERTIES(V)
#undef V
}",79,,208,2,,void
242379,BLOCK,1,,<empty>,,,,3,,void
242424,BLOCK,-1,,"{
  BindingData* data = Realm::GetBindingData<BindingData>(args);
  HeapCodeStatistics s;
  args.GetIsolate()->GetHeapCodeAndMetadataStatistics(&s);
  AliasedFloat64Array& buffer = data->heap_code_statistics_buffer;

#define V(index, name, _) buffer[index] = static_cast<double>(s.name());
  HEAP_CODE_STATISTICS_PROPERTIES(V)
#undef V
}",78,,223,2,,void
242452,BLOCK,1,,<empty>,,,,3,,void
242497,BLOCK,-1,,"{
  CHECK(args[0]->IsString());
  String::Utf8Value flags(args.GetIsolate(), args[0]);
  V8::SetFlagsFromString(*flags, static_cast<size_t>(flags.length()));
}",66,,235,2,,void
242530,BLOCK,-1,,"{
  switch (gc_type) {
    case v8::GCType::kGCTypeScavenge:
      return ""Scavenge"";
    case v8::GCType::kGCTypeMarkSweepCompact:
      return ""MarkSweepCompact"";
    case v8::GCType::kGCTypeIncrementalMarking:
      return ""IncrementalMarking"";
    case v8::GCType::kGCTypeProcessWeakCallbacks:
      return ""ProcessWeakCallbacks"";
    default:
      return ""Unknown"";
  }
}",54,,241,2,,void
242533,BLOCK,-1,,"{
    case v8::GCType::kGCTypeScavenge:
      return ""Scavenge"";
    case v8::GCType::kGCTypeMarkSweepCompact:
      return ""MarkSweepCompact"";
    case v8::GCType::kGCTypeIncrementalMarking:
      return ""IncrementalMarking"";
    case v8::GCType::kGCTypeProcessWeakCallbacks:
      return ""ProcessWeakCallbacks"";
    default:
      return ""Unknown"";
  }",20,,242,2,,void
242574,BLOCK,-1,,"{
  HeapStatistics heap_statistics;
  isolate->GetHeapStatistics(&heap_statistics);
  writer->json_objectstart(""heapStatistics"");
  writer->json_keyvalue(""totalHeapSize"", heap_statistics.total_heap_size());
  writer->json_keyvalue(""totalHeapSizeExecutable"",
                        heap_statistics.total_heap_size_executable());
  writer->json_keyvalue(""totalPhysicalSize"",
                        heap_statistics.total_physical_size());
  writer->json_keyvalue(""totalAvailableSize"",
                        heap_statistics.total_available_size());
  writer->json_keyvalue(""totalGlobalHandlesSize"",
                        heap_statistics.total_global_handles_size());
  writer->json_keyvalue(""usedGlobalHandlesSize"",
                        heap_statistics.used_global_handles_size());
  writer->json_keyvalue(""usedHeapSize"", heap_statistics.used_heap_size());
  writer->json_keyvalue(""heapSizeLimit"", heap_statistics.heap_size_limit());
  writer->json_keyvalue(""mallocedMemory"", heap_statistics....",69,,256,3,,void
242703,BLOCK,-1,,<empty>,3,,281,1,,void
242713,BLOCK,4,,"{
    HeapSpaceStatistics heap_space_statistics;
    isolate->GetHeapSpaceStatistics(&heap_space_statistics, i);
    writer->json_start();
    writer->json_keyvalue(""spaceName"", heap_space_statistics.space_name());
    writer->json_keyvalue(""spaceSize"", heap_space_statistics.space_size());
    writer->json_keyvalue(""spaceUsedSize"",
                          heap_space_statistics.space_used_size());
    writer->json_keyvalue(""spaceAvailableSize"",
                          heap_space_statistics.space_available_size());
    writer->json_keyvalue(""physicalSpaceSize"",
                          heap_space_statistics.physical_space_size());
    writer->json_end();
  }",41,,281,4,,void
242786,BLOCK,-1,,"{
  GCProfiler* profiler = static_cast<GCProfiler*>(data);
  if (profiler->current_gc_type != 0) {
    return;
  }
  JSONWriter* writer = profiler->writer();
  writer->json_start();
  writer->json_keyvalue(""gcType"", GetGCTypeName(gc_type));
  writer->json_objectstart(""beforeGC"");
  SetHeapStatistics(writer, isolate);
  writer->json_objectend();
  profiler->current_gc_type = gc_type;
  profiler->start_time = uv_hrtime();
}",42,,301,5,,void
242799,BLOCK,-1,,"{
    return;
  }",39,,303,2,,void
242848,BLOCK,-1,,"{
  GCProfiler* profiler = static_cast<GCProfiler*>(data);
  if (profiler->current_gc_type != gc_type) {
    return;
  }
  JSONWriter* writer = profiler->writer();
  profiler->current_gc_type = 0;
  writer->json_keyvalue(""cost"", (uv_hrtime() - profiler->start_time) / 1e3);
  profiler->start_time = 0;
  writer->json_objectstart(""afterGC"");
  SetHeapStatistics(writer, isolate);
  writer->json_objectend();
  writer->json_end();
}",41,,319,5,,void
242861,BLOCK,-1,,"{
    return;
  }",45,,321,2,,void
242913,BLOCK,-1,,"{
  MakeWeak();
}",35,,339,3,,void
242918,BLOCK,-1,,"{
  if (state != GCProfiler::GCProfilerState::kInitialized) {
    env()->isolate()->RemoveGCPrologueCallback(BeforeGCCallback, this);
    env()->isolate()->RemoveGCEpilogueCallback(AfterGCCallback, this);
  }
}",27,,348,1,,void
242927,BLOCK,-1,,"{
    env()->isolate()->RemoveGCPrologueCallback(BeforeGCCallback, this);
    env()->isolate()->RemoveGCEpilogueCallback(AfterGCCallback, this);
  }",59,,349,2,,void
242949,BLOCK,-1,,"{
  return &writer_;
}",34,,355,1,,void
242956,BLOCK,-1,,"{
  return &out_stream_;
}",46,,359,1,,void
242964,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new GCProfiler(env, args.This());
}",63,,363,2,,void
242989,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  GCProfiler* profiler;
  ASSIGN_OR_RETURN_UNWRAP(&profiler, args.Holder());
  if (profiler->state != GCProfiler::GCProfilerState::kInitialized) {
    return;
  }
  profiler->writer()->json_start();
  profiler->writer()->json_keyvalue(""version"", 1);

  uv_timeval64_t ts;
  if (uv_gettimeofday(&ts) == 0) {
    profiler->writer()->json_keyvalue(""startTime"",
                                      ts.tv_sec * 1000 + ts.tv_usec / 1000);
  } else {
    profiler->writer()->json_keyvalue(""startTime"", 0);
  }
  profiler->writer()->json_arraystart(""statistics"");
  env->isolate()->AddGCPrologueCallback(BeforeGCCallback,
                                        static_cast<void*>(profiler));
  env->isolate()->AddGCEpilogueCallback(AfterGCCallback,
                                        static_cast<void*>(profiler));
  profiler->state = GCProfiler::GCProfilerState::kStarted;
}",65,,369,2,,void
243016,BLOCK,-1,,"{
    return;
  }",69,,373,2,,void
243041,BLOCK,-1,,"{
    profiler->writer()->json_keyvalue(""startTime"",
                                      ts.tv_sec * 1000 + ts.tv_usec / 1000);
  }",34,,380,2,,void
243062,BLOCK,-1,,"{
    profiler->writer()->json_keyvalue(""startTime"", 0);
  }",10,,383,1,,void
243115,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  GCProfiler* profiler;
  ASSIGN_OR_RETURN_UNWRAP(&profiler, args.Holder());
  if (profiler->state != GCProfiler::GCProfilerState::kStarted) {
    return;
  }
  profiler->writer()->json_arrayend();
  uv_timeval64_t ts;
  if (uv_gettimeofday(&ts) == 0) {
    profiler->writer()->json_keyvalue(""endTime"",
                                      ts.tv_sec * 1000 + ts.tv_usec / 1000);
  } else {
    profiler->writer()->json_keyvalue(""endTime"", 0);
  }
  profiler->writer()->json_end();
  profiler->state = GCProfiler::GCProfilerState::kStopped;
  auto string = profiler->out_stream()->str();
  args.GetReturnValue().Set(String::NewFromUtf8(env->isolate(),
                                                string.data(),
                                                v8::NewStringType::kNormal,
                                                string.size())
                                .ToLocalChecked());
}",68,,394,2,,void
243142,BLOCK,-1,,"{
    return;
  }",65,,398,2,,void
243158,BLOCK,-1,,"{
    profiler->writer()->json_keyvalue(""endTime"",
                                      ts.tv_sec * 1000 + ts.tv_usec / 1000);
  }",34,,403,2,,void
243179,BLOCK,-1,,"{
    profiler->writer()->json_keyvalue(""endTime"", 0);
  }",10,,406,1,,void
243253,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(context);
  Environment* env = realm->env();
  BindingData* const binding_data =
      realm->AddBindingData<BindingData>(context, target);
  if (binding_data == nullptr) return;

  SetMethodNoSideEffect(
      context, target, ""cachedDataVersionTag"", CachedDataVersionTag);
  SetMethodNoSideEffect(context,
                        target,
                        ""setHeapSnapshotNearHeapLimit"",
                        SetHeapSnapshotNearHeapLimit);
  SetMethod(context,
            target,
            ""updateHeapStatisticsBuffer"",
            UpdateHeapStatisticsBuffer);

  SetMethod(context,
            target,
            ""updateHeapCodeStatisticsBuffer"",
            UpdateHeapCodeStatisticsBuffer);

  size_t number_of_heap_spaces = env->isolate()->NumberOfHeapSpaces();

  // Heap space names are extracted once and exposed to JavaScript to
  // avoid excessive creation of heap space name Strings.
  HeapSpaceStatistics s;
  MaybeStackBuffer<Local<V...",29,,422,5,,void
243286,BLOCK,-1,,<empty>,32,,427,2,,void
243323,BLOCK,-1,,<empty>,3,,451,1,,void
243333,BLOCK,4,,"{
    env->isolate()->GetHeapSpaceStatistics(&s, i);
    heap_spaces[i] = String::NewFromUtf8(env->isolate(), s.space_name())
                                             .ToLocalChecked();
  }",54,,451,4,,void
243396,BLOCK,1,,<empty>,,,,3,,void
243720,BLOCK,1,,<empty>,,,,3,,void
243814,BLOCK,1,,<empty>,,,,3,,void
243965,BLOCK,-1,,"{
  registry->Register(CachedDataVersionTag);
  registry->Register(UpdateHeapStatisticsBuffer);
  registry->Register(UpdateHeapCodeStatisticsBuffer);
  registry->Register(UpdateHeapSpaceStatisticsBuffer);
  registry->Register(SetFlagsFromString);
  registry->Register(SetHeapSnapshotNearHeapLimit);
  registry->Register(GCProfiler::New);
  registry->Register(GCProfiler::Start);
  registry->Register(GCProfiler::Stop);
}",70,,492,2,,void
244038,BLOCK,-1,,<empty>,1,,1,1,,ANY
244063,BLOCK,-1,,<empty>,1,,1,1,,ANY
244068,BLOCK,-1,,<empty>,1,,1,1,,ANY
244095,BLOCK,-1,,<empty>,1,,1,1,,ANY
244101,BLOCK,-1,,"{
  Debug(wasi.env(), DebugCategory::WASI, std::forward<Args>(args)...);
}",53,,17,3,,void
244123,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  Environment* env = Environment::GetCurrent(context);
  CHECK_NOT_NULL(env);
  const char* err_name = uvwasi_embedder_err_code_to_string(errorno);
  Local<String> js_code = OneByteString(isolate, err_name);
  Local<String> js_syscall = OneByteString(isolate, syscall);
  Local<String> js_msg = js_code;
  js_msg =
      String::Concat(isolate, js_msg, FIXED_ONE_BYTE_STRING(isolate, "", ""));
  js_msg = String::Concat(isolate, js_msg, js_syscall);
  Local<Object> e;
  if (!Exception::Error(js_msg)->ToObject(context).ToLocal(&e))
    return MaybeLocal<Value>();

  if (e->Set(context,
             env->errno_string(),
             Integer::New(isolate, errorno)).IsNothing() ||
      e->Set(context, env->code_string(), js_code).IsNothing() ||
      e->Set(context, env->syscall_string(), js_syscall).IsNothing()) {
    return MaybeLocal<Value>();
  }

  return e;
}",61,,50,4,,void
244212,BLOCK,-1,,<empty>,5,,63,2,,void
244262,BLOCK,-1,,"{
    return MaybeLocal<Value>();
  }",71,,69,2,,void
244273,BLOCK,-1,,"{
  MakeWeak();
  alloc_info_ = MakeAllocator();
  options->allocator = &alloc_info_;
  int err = uvwasi_init(&uvw_, options);
  if (err != UVWASI_ESUCCESS) {
    Local<Value> exception;
    if (!WASIException(env->context(), err, ""uvwasi_init"").ToLocal(&exception))
      return;

    env->isolate()->ThrowException(exception);
  }
}",65,,79,4,,void
244295,BLOCK,-1,,"{
    Local<Value> exception;
    if (!WASIException(env->context(), err, ""uvwasi_init"").ToLocal(&exception))
      return;

    env->isolate()->ThrowException(exception);
  }",31,,84,2,,void
244315,BLOCK,-1,,<empty>,7,,87,2,,void
244328,BLOCK,-1,,"{
  uvwasi_destroy(&uvw_);
  CHECK_EQ(current_uvwasi_memory_, 0);
}",15,,94,1,,void
244337,BLOCK,-1,,"{
  tracker->TrackField(""memory"", memory_);
  tracker->TrackFieldWithSize(""uvwasi_memory"", current_uvwasi_memory_);
}",53,,99,2,,void
244354,BLOCK,-1,,"{
  CHECK_GE(current_uvwasi_memory_, previous_size);
}",59,,104,2,,void
244362,BLOCK,-1,,"{
  current_uvwasi_memory_ += size;
}",47,,108,2,,void
244370,BLOCK,-1,,"{
  current_uvwasi_memory_ -= size;
}",47,,112,2,,void
244378,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  CHECK_EQ(args.Length(), 4);
  CHECK(args[0]->IsArray());
  CHECK(args[1]->IsArray());
  CHECK(args[2]->IsArray());
  CHECK(args[3]->IsArray());

  Environment* env = Environment::GetCurrent(args);
  Local<Context> context = env->context();
  Local<Array> argv = args[0].As<Array>();
  const uint32_t argc = argv->Length();
  uvwasi_options_t options;

  uvwasi_options_init(&options);

  Local<Array> stdio = args[3].As<Array>();
  CHECK_EQ(stdio->Length(), 3);
  options.in = stdio->Get(context, 0).ToLocalChecked()->
    Int32Value(context).FromJust();
  options.out = stdio->Get(context, 1).ToLocalChecked()->
    Int32Value(context).FromJust();
  options.err = stdio->Get(context, 2).ToLocalChecked()->
    Int32Value(context).FromJust();

  options.fd_table_size = 3;
  options.argc = argc;
  options.argv =
    const_cast<const char**>(argc == 0 ? nullptr : new char*[argc]);

  for (uint32_t i = 0; i < argc; i++) {
    auto arg = argv->Get(context, i)....",57,,116,2,,void
244561,BLOCK,-1,,<empty>,3,,146,1,,void
244571,BLOCK,4,,"{
    auto arg = argv->Get(context, i).ToLocalChecked();
    CHECK(arg->IsString());
    node::Utf8Value str(env->isolate(), arg);
    options.argv[i] = strdup(*str);
    CHECK_NOT_NULL(options.argv[i]);
  }",39,,146,4,,void
244639,BLOCK,-1,,<empty>,3,,157,1,,void
244649,BLOCK,4,,"{
    auto pair = env_pairs->Get(context, i).ToLocalChecked();
    CHECK(pair->IsString());
    node::Utf8Value str(env->isolate(), pair);
    options.envp[i] = strdup(*str);
    CHECK_NOT_NULL(options.envp[i]);
  }",39,,157,4,,void
244742,BLOCK,-1,,<empty>,3,,171,1,,void
244756,BLOCK,4,,"{
    auto mapped = preopens->Get(context, i).ToLocalChecked();
    auto real = preopens->Get(context, i + 1).ToLocalChecked();
    CHECK(mapped->IsString());
    CHECK(real->IsString());
    node::Utf8Value mapped_path(env->isolate(), mapped);
    node::Utf8Value real_path(env->isolate(), real);
    options.preopens[index].mapped_path = strdup(*mapped_path);
    CHECK_NOT_NULL(options.preopens[index].mapped_path);
    options.preopens[index].real_path = strdup(*real_path);
    CHECK_NOT_NULL(options.preopens[index].real_path);
    index++;
  }",56,,171,4,,void
244862,BLOCK,-1,,"{
    for (uint32_t i = 0; i < argc; i++)
      free(const_cast<char*>(options.argv[i]));
    delete[] options.argv;
  }",32,,187,2,,void
244864,BLOCK,-1,,<empty>,5,,188,1,,void
244887,BLOCK,-1,,<empty>,3,,193,1,,void
244917,BLOCK,-1,,"{
    for (uint32_t i = 0; i < options.preopenc; i++) {
      free(const_cast<char*>(options.preopens[i].mapped_path));
      free(const_cast<char*>(options.preopens[i].real_path));
    }

    free(options.preopens);
  }",36,,197,2,,void
244919,BLOCK,-1,,<empty>,5,,198,1,,void
244931,BLOCK,4,,"{
      free(const_cast<char*>(options.preopens[i].mapped_path));
      free(const_cast<char*>(options.preopens[i].real_path));
    }",53,,198,4,,void
244962,BLOCK,-1,,"{
  auto c_function = CFunction::Make(FastCallback);
  Local<FunctionTemplate> t =
      FunctionTemplate::New(env->isolate(),
                            SlowCallback,
                            Local<Value>(),
                            Local<Signature>(),
                            sizeof...(Args),
                            v8::ConstructorBehavior::kThrow,
                            v8::SideEffectType::kHasSideEffect,
                            &c_function);
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<String> name_string =
      String::NewFromUtf8(env->isolate(), name, type).ToLocalChecked();
  tmpl->PrototypeTemplate()->Set(name_string, t);
  t->SetClassName(name_string);
}",71,,209,4,,void
245047,BLOCK,-1,,<empty>,,,,1,,<empty>
245051,BLOCK,-1,,"{
  return UVWASI_EINVAL;
}",31,,232,1,,void
245057,BLOCK,-1,,<empty>,27,,237,1,,void
245064,BLOCK,-1,,"{
  WASI* wasi = reinterpret_cast<WASI*>(BaseObject::FromJSObject(receiver));
  if (UNLIKELY(wasi == nullptr)) return EinvalError<R>();

  if (UNLIKELY(options.wasm_memory == nullptr || wasi->memory_.IsEmpty())) {
    // fallback to slow path which to throw an error about missing memory.
    options.fallback = true;
    return EinvalError<R>();
  }
  uint8_t* memory = nullptr;
  CHECK(LIKELY(options.wasm_memory->getStorageIfAligned(&memory)));

  return F(*wasi,
           {reinterpret_cast<char*>(memory), options.wasm_memory->length()},
           args...);
}",38,,245,4,,void
245080,BLOCK,-1,,<empty>,34,,247,2,,void
245097,BLOCK,-1,,"{
    // fallback to slow path which to throw an error about missing memory.
    options.fallback = true;
    return EinvalError<R>();
  }",76,,249,2,,void
245139,BLOCK,-1,,<empty>,,,,2,,<empty>
245144,BLOCK,-1,,<empty>,,,,2,,<empty>
245149,BLOCK,-1,,"{
  return value->IsUint32();
}",46,,270,2,,void
245159,BLOCK,-1,,"{
  return value.As<Uint32>()->Value();
}",42,,275,2,,void
245172,BLOCK,-1,,"{
  return value->IsBigInt();
}",46,,280,2,,void
245182,BLOCK,-1,,"{
  Local<BigInt> js_value = value.As<BigInt>();
  bool lossless;
  return js_value->Uint64Value(&lossless);
}",42,,285,2,,void
245205,BLOCK,-1,,"{
  return value->IsBigInt();
}",45,,292,2,,void
245215,BLOCK,-1,,"{
  Local<BigInt> js_value = value.As<BigInt>();
  bool lossless;
  return js_value->Int64Value(&lossless);
}",41,,297,2,,void
245240,BLOCK,-1,,"{
  return CheckType<T>(info[i]);
}",68,,304,4,,void
245253,BLOCK,-1,,"{
  if (!CheckTypes<T>(info, i, arg)) return false;
  return CheckTypes<Ts...>(info, i + 1, args...);
}",29,,312,5,,void
245260,BLOCK,-1,,<empty>,37,,313,2,,void
245274,BLOCK,-1,,"{
  return CheckTypes<Args...>(info, 0, Args()...);
}",58,,318,2,,void
245284,BLOCK,-1,,"{
  return true;
}",58,,323,2,,void
245294,BLOCK,-1,,"{
  args.GetReturnValue().Set(
      F(*wasi, memory, ConvertType<Args>(args[Indices])...));
}",49,,336,5,,void
245317,BLOCK,-1,,"{
  F(*wasi, memory, ConvertType<Args>(args[Indices])...);
}",49,,350,5,,void
245330,BLOCK,-1,,"{
  if (args.Length() != sizeof...(Args)) {
    args.GetReturnValue().Set(UVWASI_EINVAL);
    return;
  }
  if (!CheckTypes<Args...>(args)) {
    args.GetReturnValue().Set(UVWASI_EINVAL);
    return;
  }

  WASI* wasi;
  ASSIGN_OR_RETURN_UNWRAP(&wasi, args.This());
  if (wasi->memory_.IsEmpty()) {
    THROW_ERR_WASI_NOT_STARTED(Environment::GetCurrent(args));
    return;
  }

  Local<WasmMemoryObject> memory = PersistentToLocal::Strong(wasi->memory_);
  Local<ArrayBuffer> ab = memory->Buffer();
  size_t mem_size = ab->ByteLength();
  char* mem_data = static_cast<char*>(ab->Data());
  CHECK_NOT_NULL(mem_data);

  CallAndSetReturn<FT, F, R, Args...>(
      std::make_index_sequence<sizeof...(Args)>{},
      args,
      wasi,
      {mem_data, mem_size});
}",46,,358,2,,void
245339,BLOCK,-1,,"{
    args.GetReturnValue().Set(UVWASI_EINVAL);
    return;
  }",41,,359,2,,void
245353,BLOCK,-1,,"{
    args.GetReturnValue().Set(UVWASI_EINVAL);
    return;
  }",35,,363,2,,void
245378,BLOCK,-1,,"{
    THROW_ERR_WASI_NOT_STARTED(Environment::GetCurrent(args));
    return;
  }",32,,370,2,,void
245442,BLOCK,-1,,"{
  WASI::WasiFunction<FT, F, R, Args...>::SetFunction(env, name, tmpl);
}",55,,392,5,,void
245459,BLOCK,-1,,"{
  Debug(wasi, ""args_get(%d, %d)\n"", argv_offset, argv_buf_offset);

  CHECK_BOUNDS_OR_RETURN(memory.size, argv_buf_offset, wasi.uvw_.argv_buf_size);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, argv_offset, wasi.uvw_.argc * UVWASI_SERDES_SIZE_uint32_t);
  std::vector<char*> argv(wasi.uvw_.argc);
  char* argv_buf = &memory.data[argv_buf_offset];
  uvwasi_errno_t err = uvwasi_args_get(&wasi.uvw_, argv.data(), argv_buf);

  if (err == UVWASI_ESUCCESS) {
    for (size_t i = 0; i < wasi.uvw_.argc; i++) {
      uint32_t offset =
          static_cast<uint32_t>(argv_buf_offset + (argv[i] - argv[0]));
      uvwasi_serdes_write_uint32_t(
          memory.data, argv_offset + (i * UVWASI_SERDES_SIZE_uint32_t), offset);
    }
  }

  return err;
}",50,,399,5,,void
245475,BLOCK,1,,<empty>,,,,4,,void
245477,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, argv_buf_offset, wasi.uvw_.argv_buf_size)",3,,402,1,,void
245490,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, argv_buf_offset, wasi.uvw_.argv_buf_size)",3,,402,2,,void
245499,BLOCK,1,,<empty>,,,,3,,void
245501,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, argv_offset, wasi.uvw_.argc * UVWASI_SERDES_SIZE_uint32_t)",3,,403,1,,void
245516,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, argv_offset, wasi.uvw_.argc * UVWASI_SERDES_SIZE_uint32_t)",3,,403,2,,void
245553,BLOCK,-1,,"{
    for (size_t i = 0; i < wasi.uvw_.argc; i++) {
      uint32_t offset =
          static_cast<uint32_t>(argv_buf_offset + (argv[i] - argv[0]));
      uvwasi_serdes_write_uint32_t(
          memory.data, argv_offset + (i * UVWASI_SERDES_SIZE_uint32_t), offset);
    }
  }",31,,409,2,,void
245555,BLOCK,-1,,<empty>,5,,410,1,,void
245569,BLOCK,4,,"{
      uint32_t offset =
          static_cast<uint32_t>(argv_buf_offset + (argv[i] - argv[0]));
      uvwasi_serdes_write_uint32_t(
          memory.data, argv_offset + (i * UVWASI_SERDES_SIZE_uint32_t), offset);
    }",49,,410,4,,void
245603,BLOCK,-1,,"{
  Debug(wasi, ""args_sizes_get(%d, %d)\n"", argc_offset, argv_buf_offset);
  CHECK_BOUNDS_OR_RETURN(memory.size, argc_offset, UVWASI_SERDES_SIZE_size_t);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, argv_buf_offset, UVWASI_SERDES_SIZE_size_t);
  uvwasi_size_t argc;
  uvwasi_size_t argv_buf_size;
  uvwasi_errno_t err = uvwasi_args_sizes_get(&wasi.uvw_, &argc, &argv_buf_size);
  if (err == UVWASI_ESUCCESS) {
    uvwasi_serdes_write_size_t(memory.data, argc_offset, argc);
    uvwasi_serdes_write_size_t(memory.data, argv_buf_offset, argv_buf_size);
  }

  return err;
}",55,,424,5,,void
245615,BLOCK,1,,<empty>,,,,4,,void
245617,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, argc_offset, UVWASI_SERDES_SIZE_size_t)",3,,426,1,,void
245626,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, argc_offset, UVWASI_SERDES_SIZE_size_t)",3,,426,2,,void
245636,BLOCK,1,,<empty>,,,,4,,void
245638,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, argv_buf_offset, UVWASI_SERDES_SIZE_size_t)",3,,427,1,,void
245647,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, argv_buf_offset, UVWASI_SERDES_SIZE_size_t)",3,,427,2,,void
245669,BLOCK,-1,,"{
    uvwasi_serdes_write_size_t(memory.data, argc_offset, argc);
    uvwasi_serdes_write_size_t(memory.data, argv_buf_offset, argv_buf_size);
  }",31,,432,2,,void
245691,BLOCK,-1,,"{
  Debug(wasi, ""clock_res_get(%d, %d)\n"", clock_id, resolution_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, resolution_ptr, UVWASI_SERDES_SIZE_timestamp_t);
  uvwasi_timestamp_t resolution;
  uvwasi_errno_t err = uvwasi_clock_res_get(&wasi.uvw_, clock_id, &resolution);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_timestamp_t(memory.data, resolution_ptr, resolution);

  return err;
}",53,,443,5,,void
245703,BLOCK,1,,<empty>,,,,4,,void
245705,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, resolution_ptr, UVWASI_SERDES_SIZE_timestamp_t)",3,,445,1,,void
245714,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, resolution_ptr, UVWASI_SERDES_SIZE_timestamp_t)",3,,445,2,,void
245734,BLOCK,-1,,<empty>,5,,450,2,,void
245751,BLOCK,-1,,"{
  Debug(wasi, ""clock_time_get(%d, %d, %d)\n"", clock_id, precision, time_ptr);
  CHECK_BOUNDS_OR_RETURN(memory.size, time_ptr, UVWASI_SERDES_SIZE_timestamp_t);
  uvwasi_timestamp_t time;
  uvwasi_errno_t err =
      uvwasi_clock_time_get(&wasi.uvw_, clock_id, precision, &time);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_timestamp_t(memory.data, time_ptr, time);

  return err;
}",48,,459,6,,void
245764,BLOCK,1,,<empty>,,,,4,,void
245766,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, time_ptr, UVWASI_SERDES_SIZE_timestamp_t)",3,,461,1,,void
245775,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, time_ptr, UVWASI_SERDES_SIZE_timestamp_t)",3,,461,2,,void
245796,BLOCK,-1,,<empty>,5,,466,2,,void
245812,BLOCK,-1,,"{
  Debug(wasi, ""environ_get(%d, %d)\n"", environ_offset, environ_buf_offset);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, environ_buf_offset, wasi.uvw_.env_buf_size);
  CHECK_BOUNDS_OR_RETURN(memory.size,
                         environ_offset,
                         wasi.uvw_.envc * UVWASI_SERDES_SIZE_uint32_t);
  std::vector<char*> environment(wasi.uvw_.envc);
  char* environ_buf = &memory.data[environ_buf_offset];
  uvwasi_errno_t err =
      uvwasi_environ_get(&wasi.uvw_, environment.data(), environ_buf);

  if (err == UVWASI_ESUCCESS) {
    for (size_t i = 0; i < wasi.uvw_.envc; i++) {
      uint32_t offset = static_cast<uint32_t>(
          environ_buf_offset + (environment[i] - environment[0]));

      uvwasi_serdes_write_uint32_t(
          memory.data,
          environ_offset + (i * UVWASI_SERDES_SIZE_uint32_t),
          offset);
    }
  }

  return err;
}",56,,474,5,,void
245828,BLOCK,1,,<empty>,,,,4,,void
245830,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, environ_buf_offset, wasi.uvw_.env_buf_size)",3,,476,1,,void
245843,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, environ_buf_offset, wasi.uvw_.env_buf_size)",3,,476,2,,void
245852,BLOCK,1,,<empty>,,,,3,,void
245854,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size,
                         environ_offset,
                         wasi.uvw_.envc * UVWASI_SERDES_SIZE_uint32_t)",3,,478,1,,void
245869,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size,
                         environ_offset,
                         wasi.uvw_.envc * UVWASI_SERDES_SIZE_uint32_t)",3,,478,2,,void
245906,BLOCK,-1,,"{
    for (size_t i = 0; i < wasi.uvw_.envc; i++) {
      uint32_t offset = static_cast<uint32_t>(
          environ_buf_offset + (environment[i] - environment[0]));

      uvwasi_serdes_write_uint32_t(
          memory.data,
          environ_offset + (i * UVWASI_SERDES_SIZE_uint32_t),
          offset);
    }
  }",31,,486,2,,void
245908,BLOCK,-1,,<empty>,5,,487,1,,void
245922,BLOCK,4,,"{
      uint32_t offset = static_cast<uint32_t>(
          environ_buf_offset + (environment[i] - environment[0]));

      uvwasi_serdes_write_uint32_t(
          memory.data,
          environ_offset + (i * UVWASI_SERDES_SIZE_uint32_t),
          offset);
    }",49,,487,4,,void
245956,BLOCK,-1,,"{
  Debug(wasi, ""environ_sizes_get(%d, %d)\n"", envc_offset, env_buf_offset);
  CHECK_BOUNDS_OR_RETURN(memory.size, envc_offset, UVWASI_SERDES_SIZE_size_t);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, env_buf_offset, UVWASI_SERDES_SIZE_size_t);
  uvwasi_size_t envc;
  uvwasi_size_t env_buf_size;
  uvwasi_errno_t err =
      uvwasi_environ_sizes_get(&wasi.uvw_, &envc, &env_buf_size);
  if (err == UVWASI_ESUCCESS) {
    uvwasi_serdes_write_size_t(memory.data, envc_offset, envc);
    uvwasi_serdes_write_size_t(memory.data, env_buf_offset, env_buf_size);
  }

  return err;
}",57,,504,5,,void
245968,BLOCK,1,,<empty>,,,,4,,void
245970,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, envc_offset, UVWASI_SERDES_SIZE_size_t)",3,,506,1,,void
245979,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, envc_offset, UVWASI_SERDES_SIZE_size_t)",3,,506,2,,void
245989,BLOCK,1,,<empty>,,,,4,,void
245991,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, env_buf_offset, UVWASI_SERDES_SIZE_size_t)",3,,507,1,,void
246000,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, env_buf_offset, UVWASI_SERDES_SIZE_size_t)",3,,507,2,,void
246022,BLOCK,-1,,"{
    uvwasi_serdes_write_size_t(memory.data, envc_offset, envc);
    uvwasi_serdes_write_size_t(memory.data, env_buf_offset, env_buf_size);
  }",31,,513,2,,void
246046,BLOCK,-1,,"{
  Debug(wasi, ""fd_advise(%d, %d, %d, %d)\n"", fd, offset, len, advice);
  return uvwasi_fd_advise(&wasi.uvw_, fd, offset, len, advice);
}",42,,526,7,,void
246072,BLOCK,-1,,"{
  Debug(wasi, ""fd_allocate(%d, %d, %d)\n"", fd, offset, len);
  return uvwasi_fd_allocate(&wasi.uvw_, fd, offset, len);
}",73,,532,6,,void
246094,BLOCK,-1,,"{
  Debug(wasi, ""fd_close(%d)\n"", fd);
  return uvwasi_fd_close(&wasi.uvw_, fd);
}",61,,537,4,,void
246112,BLOCK,-1,,"{
  Debug(wasi, ""fd_datasync(%d)\n"", fd);
  return uvwasi_fd_datasync(&wasi.uvw_, fd);
}",64,,542,4,,void
246131,BLOCK,-1,,"{
  Debug(wasi, ""fd_fdstat_get(%d, %d)\n"", fd, buf);
  CHECK_BOUNDS_OR_RETURN(memory.size, buf, UVWASI_SERDES_SIZE_fdstat_t);
  uvwasi_fdstat_t stats;
  uvwasi_errno_t err = uvwasi_fd_fdstat_get(&wasi.uvw_, fd, &stats);

  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_fdstat_t(memory.data, buf, &stats);

  return err;
}",42,,550,5,,void
246143,BLOCK,1,,<empty>,,,,4,,void
246145,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf, UVWASI_SERDES_SIZE_fdstat_t)",3,,552,1,,void
246154,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf, UVWASI_SERDES_SIZE_fdstat_t)",3,,552,2,,void
246174,BLOCK,-1,,<empty>,5,,557,2,,void
246191,BLOCK,-1,,"{
  Debug(wasi, ""fd_fdstat_set_flags(%d, %d)\n"", fd, flags);
  return uvwasi_fd_fdstat_set_flags(&wasi.uvw_, fd, flags);
}",49,,565,5,,void
246213,BLOCK,-1,,"{
  Debug(wasi,
        ""fd_fdstat_set_rights(%d, %d, %d)\n"",
        fd,
        fs_rights_base,
        fs_rights_inheriting);
  return uvwasi_fd_fdstat_set_rights(
      &wasi.uvw_, fd, fs_rights_base, fs_rights_inheriting);
}",65,,574,6,,void
246236,BLOCK,-1,,"{
  Debug(wasi, ""fd_filestat_get(%d, %d)\n"", fd, buf);
  CHECK_BOUNDS_OR_RETURN(memory.size, buf, UVWASI_SERDES_SIZE_filestat_t);
  uvwasi_filestat_t stats;
  uvwasi_errno_t err = uvwasi_fd_filestat_get(&wasi.uvw_, fd, &stats);

  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_filestat_t(memory.data, buf, &stats);

  return err;
}",44,,587,5,,void
246248,BLOCK,1,,<empty>,,,,4,,void
246250,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf, UVWASI_SERDES_SIZE_filestat_t)",3,,589,1,,void
246259,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf, UVWASI_SERDES_SIZE_filestat_t)",3,,589,2,,void
246279,BLOCK,-1,,<empty>,5,,594,2,,void
246296,BLOCK,-1,,"{
  Debug(wasi, ""fd_filestat_set_size(%d, %d)\n"", fd, st_size);
  return uvwasi_fd_filestat_set_size(&wasi.uvw_, fd, st_size);
}",52,,602,5,,void
246319,BLOCK,-1,,"{
  Debug(wasi,
        ""fd_filestat_set_times(%d, %d, %d, %d)\n"",
        fd,
        st_atim,
        st_mtim,
        fst_flags);
  return uvwasi_fd_filestat_set_times(
      &wasi.uvw_, fd, st_atim, st_mtim, fst_flags);
}",55,,612,7,,void
246347,BLOCK,-1,,"{
  Debug(wasi,
        ""uvwasi_fd_pread(%d, %d, %d, %d, %d)\n"",
        fd,
        iovs_ptr,
        iovs_len,
        offset,
        nread_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_iovec_t);
  CHECK_BOUNDS_OR_RETURN(memory.size, nread_ptr, UVWASI_SERDES_SIZE_size_t);
  std::vector<uvwasi_iovec_t> iovs(iovs_len);
  uvwasi_errno_t err;

  err = uvwasi_serdes_readv_iovec_t(
      memory.data, memory.size, iovs_ptr, iovs.data(), iovs_len);
  if (err != UVWASI_ESUCCESS) {
    return err;
  }

  uvwasi_size_t nread;
  err = uvwasi_fd_pread(&wasi.uvw_, fd, iovs.data(), iovs_len, offset, &nread);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_size_t(memory.data, nread_ptr, nread);

  return err;
}",44,,629,8,,void
246361,BLOCK,1,,<empty>,,,,3,,void
246363,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_iovec_t)",3,,637,1,,void
246374,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_iovec_t)",3,,637,2,,void
246384,BLOCK,1,,<empty>,,,,4,,void
246386,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, nread_ptr, UVWASI_SERDES_SIZE_size_t)",3,,639,1,,void
246395,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, nread_ptr, UVWASI_SERDES_SIZE_size_t)",3,,639,2,,void
246427,BLOCK,-1,,"{
    return err;
  }",31,,645,2,,void
246451,BLOCK,-1,,<empty>,5,,652,2,,void
246467,BLOCK,-1,,"{
  Debug(wasi, ""fd_prestat_get(%d, %d)\n"", fd, buf);
  CHECK_BOUNDS_OR_RETURN(memory.size, buf, UVWASI_SERDES_SIZE_prestat_t);
  uvwasi_prestat_t prestat;
  uvwasi_errno_t err = uvwasi_fd_prestat_get(&wasi.uvw_, fd, &prestat);

  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_prestat_t(memory.data, buf, &prestat);

  return err;
}",43,,660,5,,void
246479,BLOCK,1,,<empty>,,,,4,,void
246481,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf, UVWASI_SERDES_SIZE_prestat_t)",3,,662,1,,void
246490,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf, UVWASI_SERDES_SIZE_prestat_t)",3,,662,2,,void
246510,BLOCK,-1,,<empty>,5,,667,2,,void
246528,BLOCK,-1,,"{
  Debug(wasi, ""fd_prestat_dir_name(%d, %d, %d)\n"", fd, path_ptr, path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  return uvwasi_fd_prestat_dir_name(
      &wasi.uvw_, fd, &memory.data[path_ptr], path_len);
}",52,,676,6,,void
246541,BLOCK,1,,<empty>,,,,4,,void
246543,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,678,1,,void
246552,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,678,2,,void
246580,BLOCK,-1,,"{
  Debug(wasi,
        ""uvwasi_fd_pwrite(%d, %d, %d, %d, %d)\n"",
        fd,
        iovs_ptr,
        iovs_len,
        offset,
        nwritten_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_ciovec_t);
  CHECK_BOUNDS_OR_RETURN(memory.size, nwritten_ptr, UVWASI_SERDES_SIZE_size_t);
  std::vector<uvwasi_ciovec_t> iovs(iovs_len);
  uvwasi_errno_t err;

  err = uvwasi_serdes_readv_ciovec_t(
      memory.data, memory.size, iovs_ptr, iovs.data(), iovs_len);
  if (err != UVWASI_ESUCCESS) {
    return err;
  }

  uvwasi_size_t nwritten;
  err = uvwasi_fd_pwrite(
      &wasi.uvw_, fd, iovs.data(), iovs_len, offset, &nwritten);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_size_t(memory.data, nwritten_ptr, nwritten);

  return err;
}",48,,689,8,,void
246594,BLOCK,1,,<empty>,,,,3,,void
246596,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_ciovec_t)",3,,697,1,,void
246607,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_ciovec_t)",3,,697,2,,void
246617,BLOCK,1,,<empty>,,,,4,,void
246619,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, nwritten_ptr, UVWASI_SERDES_SIZE_size_t)",3,,699,1,,void
246628,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, nwritten_ptr, UVWASI_SERDES_SIZE_size_t)",3,,699,2,,void
246660,BLOCK,-1,,"{
    return err;
  }",31,,705,2,,void
246684,BLOCK,-1,,<empty>,5,,713,2,,void
246702,BLOCK,-1,,"{
  Debug(wasi, ""fd_read(%d, %d, %d, %d)\n"", fd, iovs_ptr, iovs_len, nread_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_iovec_t);
  CHECK_BOUNDS_OR_RETURN(memory.size, nread_ptr, UVWASI_SERDES_SIZE_size_t);
  std::vector<uvwasi_iovec_t> iovs(iovs_len);
  uvwasi_errno_t err;

  err = uvwasi_serdes_readv_iovec_t(
      memory.data, memory.size, iovs_ptr, iovs.data(), iovs_len);
  if (err != UVWASI_ESUCCESS) {
    return err;
  }

  uvwasi_size_t nread;
  err = uvwasi_fd_read(&wasi.uvw_, fd, iovs.data(), iovs_len, &nread);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_size_t(memory.data, nread_ptr, nread);

  return err;
}",43,,723,7,,void
246715,BLOCK,1,,<empty>,,,,3,,void
246717,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_iovec_t)",3,,725,1,,void
246728,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_iovec_t)",3,,725,2,,void
246738,BLOCK,1,,<empty>,,,,4,,void
246740,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, nread_ptr, UVWASI_SERDES_SIZE_size_t)",3,,727,1,,void
246749,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, nread_ptr, UVWASI_SERDES_SIZE_size_t)",3,,727,2,,void
246781,BLOCK,-1,,"{
    return err;
  }",31,,733,2,,void
246804,BLOCK,-1,,<empty>,5,,740,2,,void
246823,BLOCK,-1,,"{
  Debug(wasi,
        ""uvwasi_fd_readdir(%d, %d, %d, %d, %d)\n"",
        fd,
        buf_ptr,
        buf_len,
        cookie,
        bufused_ptr);
  CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, buf_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, bufused_ptr, UVWASI_SERDES_SIZE_size_t);
  uvwasi_size_t bufused;
  uvwasi_errno_t err = uvwasi_fd_readdir(
      &wasi.uvw_, fd, &memory.data[buf_ptr], buf_len, cookie, &bufused);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_size_t(memory.data, bufused_ptr, bufused);

  return err;
}",48,,751,8,,void
246838,BLOCK,1,,<empty>,,,,4,,void
246840,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, buf_len)",3,,759,1,,void
246849,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, buf_len)",3,,759,2,,void
246859,BLOCK,1,,<empty>,,,,4,,void
246861,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, bufused_ptr, UVWASI_SERDES_SIZE_size_t)",3,,760,1,,void
246870,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, bufused_ptr, UVWASI_SERDES_SIZE_size_t)",3,,760,2,,void
246898,BLOCK,-1,,<empty>,5,,765,2,,void
246914,BLOCK,-1,,"{
  Debug(wasi, ""fd_renumber(%d, %d)\n"", from, to);
  return uvwasi_fd_renumber(&wasi.uvw_, from, to);
}",79,,770,5,,void
246937,BLOCK,-1,,"{
  Debug(wasi, ""fd_seek(%d, %d, %d, %d)\n"", fd, offset, whence, newoffset_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, newoffset_ptr, UVWASI_SERDES_SIZE_filesize_t);
  uvwasi_filesize_t newoffset;
  uvwasi_errno_t err =
      uvwasi_fd_seek(&wasi.uvw_, fd, offset, whence, &newoffset);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_filesize_t(memory.data, newoffset_ptr, newoffset);

  return err;
}",47,,780,7,,void
246951,BLOCK,1,,<empty>,,,,4,,void
246953,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, newoffset_ptr, UVWASI_SERDES_SIZE_filesize_t)",3,,782,1,,void
246962,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, newoffset_ptr, UVWASI_SERDES_SIZE_filesize_t)",3,,782,2,,void
246984,BLOCK,-1,,<empty>,5,,788,2,,void
246999,BLOCK,-1,,"{
  Debug(wasi, ""fd_sync(%d)\n"", fd);
  return uvwasi_fd_sync(&wasi.uvw_, fd);
}",60,,793,4,,void
247018,BLOCK,-1,,"{
  Debug(wasi, ""fd_tell(%d, %d)\n"", fd, offset_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, offset_ptr, UVWASI_SERDES_SIZE_filesize_t);
  uvwasi_filesize_t offset;
  uvwasi_errno_t err = uvwasi_fd_tell(&wasi.uvw_, fd, &offset);

  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_filesize_t(memory.data, offset_ptr, offset);

  return err;
}",44,,801,5,,void
247030,BLOCK,1,,<empty>,,,,4,,void
247032,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, offset_ptr, UVWASI_SERDES_SIZE_filesize_t)",3,,803,1,,void
247041,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, offset_ptr, UVWASI_SERDES_SIZE_filesize_t)",3,,803,2,,void
247061,BLOCK,-1,,<empty>,5,,809,2,,void
247079,BLOCK,-1,,"{
  Debug(wasi,
        ""fd_write(%d, %d, %d, %d)\n"",
        fd,
        iovs_ptr,
        iovs_len,
        nwritten_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_ciovec_t);
  CHECK_BOUNDS_OR_RETURN(memory.size, nwritten_ptr, UVWASI_SERDES_SIZE_size_t);
  std::vector<uvwasi_ciovec_t> iovs(iovs_len);
  uvwasi_errno_t err;

  err = uvwasi_serdes_readv_ciovec_t(
      memory.data, memory.size, iovs_ptr, iovs.data(), iovs_len);
  if (err != UVWASI_ESUCCESS) {
    return err;
  }

  uvwasi_size_t nwritten;
  err = uvwasi_fd_write(&wasi.uvw_, fd, iovs.data(), iovs_len, &nwritten);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_size_t(memory.data, nwritten_ptr, nwritten);

  return err;
}",47,,819,7,,void
247092,BLOCK,1,,<empty>,,,,3,,void
247094,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_ciovec_t)",3,,826,1,,void
247105,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_ciovec_t)",3,,826,2,,void
247115,BLOCK,1,,<empty>,,,,4,,void
247117,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, nwritten_ptr, UVWASI_SERDES_SIZE_size_t)",3,,828,1,,void
247126,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, nwritten_ptr, UVWASI_SERDES_SIZE_size_t)",3,,828,2,,void
247158,BLOCK,-1,,"{
    return err;
  }",31,,834,2,,void
247181,BLOCK,-1,,<empty>,5,,841,2,,void
247198,BLOCK,-1,,"{
  Debug(wasi, ""path_create_directory(%d, %d, %d)\n"", fd, path_ptr, path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  uvwasi_errno_t err = uvwasi_path_create_directory(
      &wasi.uvw_, fd, &memory.data[path_ptr], path_len);
  return err;
}",55,,850,6,,void
247211,BLOCK,1,,<empty>,,,,4,,void
247213,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,852,1,,void
247222,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,852,2,,void
247254,BLOCK,-1,,"{
  Debug(wasi,
        ""path_filestat_get(%d, %d, %d)\n"",
        fd,
        path_ptr,
        path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, UVWASI_SERDES_SIZE_filestat_t);
  uvwasi_filestat_t stats;
  uvwasi_errno_t err = uvwasi_path_filestat_get(
      &wasi.uvw_, fd, flags, &memory.data[path_ptr], path_len, &stats);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_filestat_t(memory.data, buf_ptr, &stats);

  return err;
}",50,,864,8,,void
247267,BLOCK,1,,<empty>,,,,4,,void
247269,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,870,1,,void
247278,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,870,2,,void
247288,BLOCK,1,,<empty>,,,,4,,void
247290,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, UVWASI_SERDES_SIZE_filestat_t)",3,,871,1,,void
247299,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, UVWASI_SERDES_SIZE_filestat_t)",3,,871,2,,void
247327,BLOCK,-1,,<empty>,5,,876,2,,void
247349,BLOCK,-1,,"{
  Debug(wasi,
        ""path_filestat_set_times(%d, %d, %d, %d, %d, %d, %d)\n"",
        fd,
        flags,
        path_ptr,
        path_len,
        st_atim,
        st_mtim,
        fst_flags);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  return uvwasi_path_filestat_set_times(&wasi.uvw_,
                                        fd,
                                        flags,
                                        &memory.data[path_ptr],
                                        path_len,
                                        st_atim,
                                        st_mtim,
                                        fst_flags);
}",57,,889,10,,void
247366,BLOCK,1,,<empty>,,,,4,,void
247368,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,899,1,,void
247377,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,899,2,,void
247411,BLOCK,-1,,"{
  Debug(wasi,
        ""path_link(%d, %d, %d, %d, %d, %d, %d)\n"",
        old_fd,
        old_flags,
        old_path_ptr,
        old_path_len,
        new_fd,
        new_path_ptr,
        new_path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, old_path_ptr, old_path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, new_path_ptr, new_path_len);
  return uvwasi_path_link(&wasi.uvw_,
                          old_fd,
                          old_flags,
                          &memory.data[old_path_ptr],
                          old_path_len,
                          new_fd,
                          &memory.data[new_path_ptr],
                          new_path_len);
}",48,,918,10,,void
247428,BLOCK,1,,<empty>,,,,4,,void
247430,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, old_path_ptr, old_path_len)",3,,928,1,,void
247439,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, old_path_ptr, old_path_len)",3,,928,2,,void
247449,BLOCK,1,,<empty>,,,,4,,void
247451,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, new_path_ptr, new_path_len)",3,,929,1,,void
247460,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, new_path_ptr, new_path_len)",3,,929,2,,void
247501,BLOCK,-1,,"{
  Debug(wasi,
        ""path_open(%d, %d, %d, %d, %d, %d, %d, %d, %d)\n"",
        dirfd,
        dirflags,
        path_ptr,
        path_len,
        o_flags,
        fs_rights_base,
        fs_rights_inheriting,
        fs_flags,
        fd_ptr);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, fd_ptr, UVWASI_SERDES_SIZE_fd_t);
  uvwasi_fd_t fd;
  uvwasi_errno_t err = uvwasi_path_open(&wasi.uvw_,
                                        dirfd,
                                        dirflags,
                                        &memory.data[path_ptr],
                                        path_len,
                                        static_cast<uvwasi_oflags_t>(o_flags),
                                        fs_rights_base,
                                        fs_rights_inheriting,
                                        static_cast<uvwasi_fdflags_t>(fs_flags),
                                        &fd);
  if (err =...",42,,950,12,,void
247520,BLOCK,1,,<empty>,,,,4,,void
247522,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,962,1,,void
247531,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,962,2,,void
247541,BLOCK,1,,<empty>,,,,4,,void
247543,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, fd_ptr, UVWASI_SERDES_SIZE_fd_t)",3,,963,1,,void
247552,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, fd_ptr, UVWASI_SERDES_SIZE_fd_t)",3,,963,2,,void
247588,BLOCK,-1,,<empty>,5,,976,2,,void
247608,BLOCK,-1,,"{
  Debug(wasi,
        ""path_readlink(%d, %d, %d, %d, %d, %d)\n"",
        fd,
        path_ptr,
        path_len,
        buf_ptr,
        buf_len,
        bufused_ptr);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, buf_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, bufused_ptr, UVWASI_SERDES_SIZE_size_t);
  uvwasi_size_t bufused;
  uvwasi_errno_t err = uvwasi_path_readlink(&wasi.uvw_,
                                            fd,
                                            &memory.data[path_ptr],
                                            path_len,
                                            &memory.data[buf_ptr],
                                            buf_len,
                                            &bufused);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_size_t(memory.data, bufused_ptr, bufused);

  return err;
}",51,,988,9,,void
247624,BLOCK,1,,<empty>,,,,4,,void
247626,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,997,1,,void
247635,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,997,2,,void
247645,BLOCK,1,,<empty>,,,,4,,void
247647,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, buf_len)",3,,998,1,,void
247656,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, buf_len)",3,,998,2,,void
247666,BLOCK,1,,<empty>,,,,4,,void
247668,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, bufused_ptr, UVWASI_SERDES_SIZE_size_t)",3,,999,1,,void
247677,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, bufused_ptr, UVWASI_SERDES_SIZE_size_t)",3,,999,2,,void
247711,BLOCK,-1,,<empty>,5,,1009,2,,void
247728,BLOCK,-1,,"{
  Debug(wasi, ""path_remove_directory(%d, %d, %d)\n"", fd, path_ptr, path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  return uvwasi_path_remove_directory(
      &wasi.uvw_, fd, &memory.data[path_ptr], path_len);
}",55,,1018,6,,void
247741,BLOCK,1,,<empty>,,,,4,,void
247743,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,1020,1,,void
247752,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,1020,2,,void
247781,BLOCK,-1,,"{
  Debug(wasi,
        ""path_rename(%d, %d, %d, %d, %d, %d)\n"",
        old_fd,
        old_path_ptr,
        old_path_len,
        new_fd,
        new_path_ptr,
        new_path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, old_path_ptr, old_path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, new_path_ptr, new_path_len);
  return uvwasi_path_rename(&wasi.uvw_,
                            old_fd,
                            &memory.data[old_path_ptr],
                            old_path_len,
                            new_fd,
                            &memory.data[new_path_ptr],
                            new_path_len);
}",50,,1032,9,,void
247797,BLOCK,1,,<empty>,,,,4,,void
247799,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, old_path_ptr, old_path_len)",3,,1041,1,,void
247808,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, old_path_ptr, old_path_len)",3,,1041,2,,void
247818,BLOCK,1,,<empty>,,,,4,,void
247820,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, new_path_ptr, new_path_len)",3,,1042,1,,void
247829,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, new_path_ptr, new_path_len)",3,,1042,2,,void
247865,BLOCK,-1,,"{
  Debug(wasi,
        ""path_symlink(%d, %d, %d, %d, %d)\n"",
        old_path_ptr,
        old_path_len,
        fd,
        new_path_ptr,
        new_path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, old_path_ptr, old_path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, new_path_ptr, new_path_len);
  return uvwasi_path_symlink(&wasi.uvw_,
                             &memory.data[old_path_ptr],
                             old_path_len,
                             fd,
                             &memory.data[new_path_ptr],
                             new_path_len);
}",51,,1058,8,,void
247880,BLOCK,1,,<empty>,,,,4,,void
247882,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, old_path_ptr, old_path_len)",3,,1066,1,,void
247891,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, old_path_ptr, old_path_len)",3,,1066,2,,void
247901,BLOCK,1,,<empty>,,,,4,,void
247903,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, new_path_ptr, new_path_len)",3,,1067,1,,void
247912,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, new_path_ptr, new_path_len)",3,,1067,2,,void
247945,BLOCK,-1,,"{
  Debug(wasi, ""path_unlink_file(%d, %d, %d)\n"", fd, path_ptr, path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  return uvwasi_path_unlink_file(
      &wasi.uvw_, fd, &memory.data[path_ptr], path_len);
}",50,,1080,6,,void
247958,BLOCK,1,,<empty>,,,,4,,void
247960,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,1082,1,,void
247969,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,1082,2,,void
247996,BLOCK,-1,,"{
  Debug(wasi,
        ""poll_oneoff(%d, %d, %d, %d)\n"",
        in_ptr,
        out_ptr,
        nsubscriptions,
        nevents_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, in_ptr, nsubscriptions * UVWASI_SERDES_SIZE_subscription_t);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, out_ptr, nsubscriptions * UVWASI_SERDES_SIZE_event_t);
  CHECK_BOUNDS_OR_RETURN(memory.size, nevents_ptr, UVWASI_SERDES_SIZE_size_t);
  std::vector<uvwasi_subscription_t> in(nsubscriptions);
  std::vector<uvwasi_event_t> out(nsubscriptions);

  for (uint32_t i = 0; i < nsubscriptions; ++i) {
    uvwasi_serdes_read_subscription_t(memory.data, in_ptr, &in[i]);
    in_ptr += UVWASI_SERDES_SIZE_subscription_t;
  }

  uvwasi_size_t nevents;
  uvwasi_errno_t err = uvwasi_poll_oneoff(
      &wasi.uvw_, in.data(), out.data(), nsubscriptions, &nevents);
  if (err == UVWASI_ESUCCESS) {
    uvwasi_serdes_write_size_t(memory.data, nevents_ptr, nevents);

    for (uint32_t i = 0; i < nsubscriptions; ++i) {
      u...",49,,1092,7,,void
248009,BLOCK,1,,<empty>,,,,3,,void
248011,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, in_ptr, nsubscriptions * UVWASI_SERDES_SIZE_subscription_t)",3,,1099,1,,void
248022,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, in_ptr, nsubscriptions * UVWASI_SERDES_SIZE_subscription_t)",3,,1099,2,,void
248031,BLOCK,1,,<empty>,,,,3,,void
248033,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, out_ptr, nsubscriptions * UVWASI_SERDES_SIZE_event_t)",3,,1101,1,,void
248044,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, out_ptr, nsubscriptions * UVWASI_SERDES_SIZE_event_t)",3,,1101,2,,void
248054,BLOCK,1,,<empty>,,,,4,,void
248056,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, nevents_ptr, UVWASI_SERDES_SIZE_size_t)",3,,1103,1,,void
248065,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, nevents_ptr, UVWASI_SERDES_SIZE_size_t)",3,,1103,2,,void
248086,BLOCK,-1,,<empty>,3,,1107,1,,void
248096,BLOCK,4,,"{
    uvwasi_serdes_read_subscription_t(memory.data, in_ptr, &in[i]);
    in_ptr += UVWASI_SERDES_SIZE_subscription_t;
  }",49,,1107,4,,void
248133,BLOCK,-1,,"{
    uvwasi_serdes_write_size_t(memory.data, nevents_ptr, nevents);

    for (uint32_t i = 0; i < nsubscriptions; ++i) {
      uvwasi_serdes_write_event_t(memory.data, out_ptr, &out[i]);
      out_ptr += UVWASI_SERDES_SIZE_event_t;
    }
  }",31,,1115,2,,void
248141,BLOCK,-1,,<empty>,5,,1118,1,,void
248151,BLOCK,4,,"{
      uvwasi_serdes_write_event_t(memory.data, out_ptr, &out[i]);
      out_ptr += UVWASI_SERDES_SIZE_event_t;
    }",51,,1118,4,,void
248172,BLOCK,-1,,"{
  Debug(wasi, ""proc_exit(%d)\n"", code);
  uvwasi_proc_exit(&wasi.uvw_, code);
}",60,,1127,4,,void
248189,BLOCK,-1,,"{
  Debug(wasi, ""proc_raise(%d)\n"", sig);
  return uvwasi_proc_raise(&wasi.uvw_, sig);
}",64,,1132,4,,void
248208,BLOCK,-1,,"{
  Debug(wasi, ""random_get(%d, %d)\n"", buf_ptr, buf_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, buf_len);
  return uvwasi_random_get(&wasi.uvw_, &memory.data[buf_ptr], buf_len);
}",44,,1140,5,,void
248220,BLOCK,1,,<empty>,,,,4,,void
248222,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, buf_len)",3,,1142,1,,void
248231,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, buf_len)",3,,1142,2,,void
248253,BLOCK,-1,,"{
  Debug(wasi, ""sched_yield()\n"");
  return uvwasi_sched_yield(&wasi.uvw_);
}",51,,1146,3,,void
248271,BLOCK,-1,,"{
  Debug(wasi, ""sock_accept(%d, %d, %d)\n"", sock, flags, fd_ptr);
  uvwasi_fd_t fd;
  uvwasi_errno_t err = uvwasi_sock_accept(&wasi.uvw_, sock, flags, &fd);

  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_size_t(memory.data, fd_ptr, fd);

  return err;
}",44,,1155,6,,void
248295,BLOCK,-1,,<empty>,5,,1161,2,,void
248315,BLOCK,-1,,"{
  Debug(wasi,
        ""sock_recv(%d, %d, %d, %d, %d, %d)\n"",
        sock,
        ri_data_ptr,
        ri_data_len,
        ri_flags,
        ro_datalen_ptr,
        ro_flags_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, ri_data_ptr, ri_data_len * UVWASI_SERDES_SIZE_iovec_t);
  CHECK_BOUNDS_OR_RETURN(memory.size, ro_datalen_ptr, 4);
  CHECK_BOUNDS_OR_RETURN(memory.size, ro_flags_ptr, 4);
  std::vector<uvwasi_iovec_t> ri_data(ri_data_len);
  uvwasi_errno_t err = uvwasi_serdes_readv_iovec_t(
      memory.data, memory.size, ri_data_ptr, ri_data.data(), ri_data_len);
  if (err != UVWASI_ESUCCESS) {
    return err;
  }

  uvwasi_size_t ro_datalen;
  uvwasi_roflags_t ro_flags;
  err = uvwasi_sock_recv(&wasi.uvw_,
                         sock,
                         ri_data.data(),
                         ri_data_len,
                         ri_flags,
                         &ro_datalen,
                         &ro_flags);
  if (err == UVWASI_ESUCCESS) {
    uvwasi_serdes_wr...",48,,1173,9,,void
248330,BLOCK,1,,<empty>,,,,3,,void
248332,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, ri_data_ptr, ri_data_len * UVWASI_SERDES_SIZE_iovec_t)",3,,1182,1,,void
248343,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, ri_data_ptr, ri_data_len * UVWASI_SERDES_SIZE_iovec_t)",3,,1182,2,,void
248353,BLOCK,1,,<empty>,,,,4,,void
248355,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, ro_datalen_ptr, 4)",3,,1184,1,,void
248364,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, ro_datalen_ptr, 4)",3,,1184,2,,void
248374,BLOCK,1,,<empty>,,,,4,,void
248376,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, ro_flags_ptr, 4)",3,,1185,1,,void
248385,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, ro_flags_ptr, 4)",3,,1185,2,,void
248417,BLOCK,-1,,"{
    return err;
  }",31,,1189,2,,void
248444,BLOCK,-1,,"{
    uvwasi_serdes_write_size_t(memory.data, ro_datalen_ptr, ro_datalen);
    uvwasi_serdes_write_roflags_t(memory.data, ro_flags_ptr, ro_flags);
  }",31,,1202,2,,void
248469,BLOCK,-1,,"{
  Debug(wasi,
        ""sock_send(%d, %d, %d, %d, %d)\n"",
        sock,
        si_data_ptr,
        si_data_len,
        si_flags,
        so_datalen_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, si_data_ptr, si_data_len * UVWASI_SERDES_SIZE_ciovec_t);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, so_datalen_ptr, UVWASI_SERDES_SIZE_size_t);
  std::vector<uvwasi_ciovec_t> si_data(si_data_len);
  uvwasi_errno_t err = uvwasi_serdes_readv_ciovec_t(
      memory.data, memory.size, si_data_ptr, si_data.data(), si_data_len);
  if (err != UVWASI_ESUCCESS) {
    return err;
  }

  uvwasi_size_t so_datalen;
  err = uvwasi_sock_send(
      &wasi.uvw_, sock, si_data.data(), si_data_len, si_flags, &so_datalen);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_size_t(memory.data, so_datalen_ptr, so_datalen);

  return err;
}",50,,1216,8,,void
248483,BLOCK,1,,<empty>,,,,3,,void
248485,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, si_data_ptr, si_data_len * UVWASI_SERDES_SIZE_ciovec_t)",3,,1224,1,,void
248496,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, si_data_ptr, si_data_len * UVWASI_SERDES_SIZE_ciovec_t)",3,,1224,2,,void
248506,BLOCK,1,,<empty>,,,,4,,void
248508,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, so_datalen_ptr, UVWASI_SERDES_SIZE_size_t)",3,,1226,1,,void
248517,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, so_datalen_ptr, UVWASI_SERDES_SIZE_size_t)",3,,1226,2,,void
248549,BLOCK,-1,,"{
    return err;
  }",31,,1231,2,,void
248573,BLOCK,-1,,<empty>,5,,1239,2,,void
248589,BLOCK,-1,,"{
  Debug(wasi, ""sock_shutdown(%d, %d)\n"", sock, how);
  return uvwasi_sock_shutdown(&wasi.uvw_, sock, how);
}",43,,1247,5,,void
248607,BLOCK,-1,,"{
  WASI* wasi;
  ASSIGN_OR_RETURN_UNWRAP(&wasi, args.This());
  CHECK_EQ(args.Length(), 1);
  if (!args[0]->IsWasmMemoryObject()) {
    return node::THROW_ERR_INVALID_ARG_TYPE(
        wasi->env(),
        ""\""instance.exports.memory\"" property must be a WebAssembly.Memory ""
        ""object"");
  }
  wasi->memory_.Reset(wasi->env()->isolate(), args[0].As<WasmMemoryObject>());
}",64,,1252,2,,void
248630,BLOCK,-1,,"{
    return node::THROW_ERR_INVALID_ARG_TYPE(
        wasi->env(),
        ""\""instance.exports.memory\"" property must be a WebAssembly.Memory ""
        ""object"");
  }",39,,1256,2,,void
248667,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> tmpl = NewFunctionTemplate(isolate, WASI::New);
  tmpl->InstanceTemplate()->SetInternalFieldCount(WASI::kInternalFieldCount);

#define V(F, name)                                                             \
  SetFunction<decltype(&WASI::F), WASI::F>(WASI::F, env, name, tmpl);

  V(ArgsGet, ""args_get"")
  V(ArgsSizesGet, ""args_sizes_get"")
  V(ClockResGet, ""clock_res_get"")
  V(ClockTimeGet, ""clock_time_get"")
  V(EnvironGet, ""environ_get"")
  V(EnvironSizesGet, ""environ_sizes_get"")
  V(FdAdvise, ""fd_advise"")
  V(FdAllocate, ""fd_allocate"")
  V(FdClose, ""fd_close"")
  V(FdDatasync, ""fd_datasync"")
  V(FdFdstatGet, ""fd_fdstat_get"")
  V(FdFdstatSetFlags, ""fd_fdstat_set_flags"")
  V(FdFdstatSetRights, ""fd_fdstat_set_rights"")
  V(FdFilestatGet, ""fd_filestat_get"")
  V(FdFilestatSetSize, ""fd_filestat_set_size"")
  V(FdFilestatSetTimes, ""fd_filestat_set_times"")
  V(FdPread, ""fd_pr...",44,,1268,5,,void
248706,BLOCK,1,,<empty>,,,,3,,void
248717,BLOCK,1,,<empty>,,,,3,,void
248728,BLOCK,1,,<empty>,,,,3,,void
248739,BLOCK,1,,<empty>,,,,3,,void
248750,BLOCK,1,,<empty>,,,,3,,void
248761,BLOCK,1,,<empty>,,,,3,,void
248772,BLOCK,1,,<empty>,,,,3,,void
248783,BLOCK,1,,<empty>,,,,3,,void
248794,BLOCK,1,,<empty>,,,,3,,void
248805,BLOCK,1,,<empty>,,,,3,,void
248816,BLOCK,1,,<empty>,,,,3,,void
248827,BLOCK,1,,<empty>,,,,3,,void
248838,BLOCK,1,,<empty>,,,,3,,void
248849,BLOCK,1,,<empty>,,,,3,,void
248860,BLOCK,1,,<empty>,,,,3,,void
248871,BLOCK,1,,<empty>,,,,3,,void
248882,BLOCK,1,,<empty>,,,,3,,void
248893,BLOCK,1,,<empty>,,,,3,,void
248904,BLOCK,1,,<empty>,,,,3,,void
248915,BLOCK,1,,<empty>,,,,3,,void
248926,BLOCK,1,,<empty>,,,,3,,void
248937,BLOCK,1,,<empty>,,,,3,,void
248948,BLOCK,1,,<empty>,,,,3,,void
248959,BLOCK,1,,<empty>,,,,3,,void
248970,BLOCK,1,,<empty>,,,,3,,void
248981,BLOCK,1,,<empty>,,,,3,,void
248992,BLOCK,1,,<empty>,,,,3,,void
249003,BLOCK,1,,<empty>,,,,3,,void
249014,BLOCK,1,,<empty>,,,,3,,void
249025,BLOCK,1,,<empty>,,,,3,,void
249036,BLOCK,1,,<empty>,,,,3,,void
249047,BLOCK,1,,<empty>,,,,3,,void
249058,BLOCK,1,,<empty>,,,,3,,void
249069,BLOCK,1,,<empty>,,,,3,,void
249080,BLOCK,1,,<empty>,,,,3,,void
249091,BLOCK,1,,<empty>,,,,3,,void
249102,BLOCK,1,,<empty>,,,,3,,void
249113,BLOCK,1,,<empty>,,,,3,,void
249124,BLOCK,1,,<empty>,,,,3,,void
249135,BLOCK,1,,<empty>,,,,3,,void
249146,BLOCK,1,,<empty>,,,,3,,void
249157,BLOCK,1,,<empty>,,,,3,,void
249168,BLOCK,1,,<empty>,,,,3,,void
249179,BLOCK,1,,<empty>,,,,3,,void
249190,BLOCK,1,,<empty>,,,,3,,void
249201,BLOCK,1,,<empty>,,,,3,,void
249237,BLOCK,-1,,<empty>,1,,1,1,,ANY
249250,BLOCK,-1,,<empty>,1,,1,1,,ANY
249255,BLOCK,-1,,"{
  Local<Function> templ = env->wasm_streaming_object_constructor();
  if (!templ.IsEmpty()) {
    return templ;
  }

  Isolate* isolate = env->isolate();
  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->InstanceTemplate()->SetInternalFieldCount(
      WasmStreamingObject::kInternalFieldCount);

  SetProtoMethod(isolate, t, ""setURL"", SetURL);
  SetProtoMethod(isolate, t, ""push"", Push);
  SetProtoMethod(isolate, t, ""finish"", Finish);
  SetProtoMethod(isolate, t, ""abort"", Abort);

  auto function = t->GetFunction(env->context()).ToLocalChecked();
  env->set_wasm_streaming_object_constructor(function);
  return function;
}",67,,23,2,,void
249272,BLOCK,-1,,"{
    return templ;
  }",25,,25,2,,void
249346,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(Push);
  registry->Register(Finish);
  registry->Register(Abort);
}",42,,45,2,,void
249371,BLOCK,-1,,"{
  // v8::WasmStreaming is opaque. We assume that the size of the WebAssembly
  // module that is being compiled is roughly what V8 allocates (as in, off by
  // only a small factor).
  tracker->TrackFieldWithSize(""streaming"", wasm_size_);
}",68,,52,2,,void
249383,BLOCK,-1,,"{
  Local<Function> ctor = Initialize(env);
  Local<Object> obj;
  if (!ctor->NewInstance(env->context(), 0, nullptr).ToLocal(&obj)) {
    return MaybeLocal<Object>();
  }

  CHECK(streaming);

  WasmStreamingObject* ptr = Unwrap<WasmStreamingObject>(obj);
  CHECK_NOT_NULL(ptr);
  ptr->streaming_ = streaming;
  ptr->wasm_size_ = 0;
  return obj;
}",65,,60,3,,void
249414,BLOCK,-1,,"{
    return MaybeLocal<Object>();
  }",69,,63,2,,void
249445,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new WasmStreamingObject(env, args.This());
}",72,,76,2,,void
249470,BLOCK,-1,,"{
  WasmStreamingObject* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.Holder());
  CHECK(obj->streaming_);

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());
  Utf8Value url(Environment::GetCurrent(args)->isolate(), args[0]);
  obj->streaming_->SetUrl(url.out(), url.length());
}",75,,82,2,,void
249527,BLOCK,-1,,"{
  WasmStreamingObject* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.Holder());
  CHECK(obj->streaming_);

  CHECK_EQ(args.Length(), 1);
  Local<Value> chunk = args[0];

  // The start of the memory section backing the ArrayBuffer(View), the offset
  // of the ArrayBuffer(View) within the memory section, and its size in bytes.
  const void* bytes;
  size_t offset;
  size_t size;

  if (LIKELY(chunk->IsArrayBufferView())) {
    Local<ArrayBufferView> view = chunk.As<ArrayBufferView>();
    bytes = view->Buffer()->Data();
    offset = view->ByteOffset();
    size = view->ByteLength();
  } else if (LIKELY(chunk->IsArrayBuffer())) {
    Local<ArrayBuffer> buffer = chunk.As<ArrayBuffer>();
    bytes = buffer->Data();
    offset = 0;
    size = buffer->ByteLength();
  } else {
    return node::THROW_ERR_INVALID_ARG_TYPE(
        Environment::GetCurrent(args),
        ""chunk must be an ArrayBufferView or an ArrayBuffer"");
  }

  // Forward the data to V8. Internally, V8 will make a copy.
  o...",73,,93,2,,void
249564,BLOCK,-1,,"{
    Local<ArrayBufferView> view = chunk.As<ArrayBufferView>();
    bytes = view->Buffer()->Data();
    offset = view->ByteOffset();
    size = view->ByteLength();
  }",43,,107,2,,void
249597,BLOCK,-1,,<empty>,10,,112,1,,void
249604,BLOCK,-1,,"{
    Local<ArrayBuffer> buffer = chunk.As<ArrayBuffer>();
    bytes = buffer->Data();
    offset = 0;
    size = buffer->ByteLength();
  }",46,,112,2,,void
249631,BLOCK,-1,,"{
    return node::THROW_ERR_INVALID_ARG_TYPE(
        Environment::GetCurrent(args),
        ""chunk must be an ArrayBufferView or an ArrayBuffer"");
  }",10,,117,1,,void
249664,BLOCK,-1,,"{
  WasmStreamingObject* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.Holder());
  CHECK(obj->streaming_);

  CHECK_EQ(args.Length(), 0);
  obj->streaming_->Finish();
}",75,,129,2,,void
249693,BLOCK,-1,,"{
  WasmStreamingObject* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.Holder());
  CHECK(obj->streaming_);

  CHECK_EQ(args.Length(), 1);
  obj->streaming_->Abort(args[0]);
}",74,,138,2,,void
249725,BLOCK,-1,,"{
  // V8 passes an instance of v8::WasmStreaming to this callback, which we can
  // use to pass the WebAssembly module bytes to V8 as we receive them.
  // Unfortunately, our fetch() implementation is a JavaScript dependency, so it
  // is difficult to implement the required logic here. Instead, we create a
  // a WasmStreamingObject that encapsulates v8::WasmStreaming and that we can
  // pass to the JavaScript implementation. The JavaScript implementation can
  // then push() bytes from the Response and eventually either finish() or
  // abort() the operation.

  // Create the wrapper object.
  std::shared_ptr<WasmStreaming> streaming =
      WasmStreaming::Unpack(info.GetIsolate(), info.Data());
  Environment* env = Environment::GetCurrent(info);
  Local<Object> obj;
  if (!WasmStreamingObject::Create(env, streaming).ToLocal(&obj)) {
    // A JavaScript exception is pending. Let V8 deal with it.
    return;
  }

  // V8 always passes one argument to this callback.
  CHECK_EQ(in...",73,,147,2,,void
249772,BLOCK,-1,,"{
    // A JavaScript exception is pending. Let V8 deal with it.
    return;
  }",67,,162,2,,void
249844,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  env->set_wasm_streaming_compilation_impl(info[0].As<Function>());
}",65,,189,2,,void
249870,BLOCK,-1,,"{
  SetMethod(context, target, ""setImplementation"", SetImplementation);
}",24,,197,5,,void
249880,BLOCK,-1,,"{
  registry->Register(SetImplementation);
  registry->Register(StartStreamingCompilation);
  WasmStreamingObject::RegisterExternalReferences(registry);
}",70,,201,2,,void
249907,BLOCK,-1,,<empty>,1,,1,1,,ANY
249911,BLOCK,-1,,"{
    Watchdog* w = ContainerOf(&Watchdog::async_, signal);
    uv_stop(&w->loop_);
  }",62,,51,2,,void
249932,BLOCK,-1,,"{
    TraceSigintWatchdog* watchdog =
        ContainerOf(&TraceSigintWatchdog::handle_, handle);
    watchdog->signal_flag_ = SignalFlags::FromIdle;
    watchdog->HandleInterrupt();
  }",77,,172,2,,void
249959,BLOCK,-1,,"{
        TraceSigintWatchdog* self = static_cast<TraceSigintWatchdog*>(data);
        if (self->signal_flag_ == SignalFlags::None) {
          self->signal_flag_ = SignalFlags::FromInterrupt;
        }
        self->HandleInterrupt();
      }",44,,189,3,,void
249974,BLOCK,-1,,"{
          self->signal_flag_ = SignalFlags::FromInterrupt;
        }",54,,191,2,,void
250007,BLOCK,-1,,<empty>,1,,1,1,,ANY
250013,BLOCK,-1,,"{

  int rc;
  rc = uv_loop_init(&loop_);
  if (rc != 0) {
    OnFatalError(""node::Watchdog::Watchdog()"", ""Failed to initialize uv loop."");
  }

  rc = uv_async_init(&loop_, &async_, [](uv_async_t* signal) {
    Watchdog* w = ContainerOf(&Watchdog::async_, signal);
    uv_stop(&w->loop_);
  });

  CHECK_EQ(0, rc);

  rc = uv_timer_init(&loop_, &timer_);
  CHECK_EQ(0, rc);

  rc = uv_timer_start(&timer_, &Watchdog::Timer, ms, 0);
  CHECK_EQ(0, rc);

  rc = uv_thread_create(&thread_, &Watchdog::Run, this);
  CHECK_EQ(0, rc);
}",48,,43,4,,void
250024,BLOCK,-1,,"{
    OnFatalError(""node::Watchdog::Watchdog()"", ""Failed to initialize uv loop."");
  }",16,,47,2,,void
250079,BLOCK,-1,,"{
  uv_async_send(&async_);
  uv_thread_join(&thread_);

  uv_close(reinterpret_cast<uv_handle_t*>(&async_), nullptr);

  // UV_RUN_DEFAULT so that libuv has a chance to clean up.
  uv_run(&loop_, UV_RUN_DEFAULT);

  CheckedUvLoopClose(&loop_);
}",23,,69,1,,void
250097,BLOCK,-1,,"{
  Watchdog* wd = static_cast<Watchdog*>(arg);

  // UV_RUN_DEFAULT the loop will be stopped either by the async or the
  // timer handle.
  uv_run(&wd->loop_, UV_RUN_DEFAULT);

  // Loop ref count reaches zero when both handles are closed.
  // Close the timer handle on this side and let ~Watchdog() close async_
  uv_close(reinterpret_cast<uv_handle_t*>(&wd->timer_), nullptr);
}",31,,82,2,,void
250122,BLOCK,-1,,"{
  Watchdog* w = ContainerOf(&Watchdog::timer_, timer);
  *w->timed_out_ = true;
  w->isolate()->TerminateExecution();
  uv_stop(&w->loop_);
}",41,,94,2,,void
250155,BLOCK,-1,,"{
  Mutex::ScopedLock lock(SigintWatchdogHelper::GetInstanceActionMutex());
  // Register this watchdog with the global SIGINT/Ctrl+C listener.
  SigintWatchdogHelper::GetInstance()->Register(this);
  // Start the helper thread, if that has not already happened.
  SigintWatchdogHelper::GetInstance()->Start();
}",60,,104,3,,void
250180,BLOCK,-1,,"{
  Mutex::ScopedLock lock(SigintWatchdogHelper::GetInstanceActionMutex());
  SigintWatchdogHelper::GetInstance()->Unregister(this);
  SigintWatchdogHelper::GetInstance()->Stop();
}",35,,113,1,,void
250205,BLOCK,-1,,"{
  *received_signal_ = true;
  isolate_->TerminateExecution();
  return SignalPropagation::kStopPropagation;
}",50,,119,1,,void
250223,BLOCK,-1,,"{
  Isolate* isolate = env->isolate();
  Local<FunctionTemplate> constructor = NewFunctionTemplate(isolate, New);
  constructor->InstanceTemplate()->SetInternalFieldCount(
      TraceSigintWatchdog::kInternalFieldCount);
  constructor->Inherit(HandleWrap::GetConstructorTemplate(env));

  SetProtoMethod(isolate, constructor, ""start"", Start);
  SetProtoMethod(isolate, constructor, ""stop"", Stop);

  SetConstructorFunction(
      env->context(), target, ""TraceSigintWatchdog"", constructor);
}",72,,125,3,,void
250281,BLOCK,-1,,"{
  // This constructor should not be exposed to public javascript.
  // Therefore we assert that we are not trying to call this as a
  // normal function.
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new TraceSigintWatchdog(env, args.This());
}",72,,139,2,,void
250306,BLOCK,-1,,"{
  TraceSigintWatchdog* watchdog;
  ASSIGN_OR_RETURN_UNWRAP(&watchdog, args.Holder());
  Mutex::ScopedLock lock(SigintWatchdogHelper::GetInstanceActionMutex());
  // Register this watchdog with the global SIGINT/Ctrl+C listener.
  SigintWatchdogHelper::GetInstance()->Register(watchdog);
  // Start the helper thread, if that has not already happened.
  int r = SigintWatchdogHelper::GetInstance()->Start();
  CHECK_EQ(r, 0);
}",74,,148,2,,void
250346,BLOCK,-1,,"{
  TraceSigintWatchdog* watchdog;
  ASSIGN_OR_RETURN_UNWRAP(&watchdog, args.Holder());
  Mutex::ScopedLock lock(SigintWatchdogHelper::GetInstanceActionMutex());
  SigintWatchdogHelper::GetInstance()->Unregister(watchdog);
  SigintWatchdogHelper::GetInstance()->Stop();
}",73,,159,2,,void
250381,BLOCK,-1,,"{
  int r = uv_async_init(env->event_loop(), &handle_, [](uv_async_t* handle) {
    TraceSigintWatchdog* watchdog =
        ContainerOf(&TraceSigintWatchdog::handle_, handle);
    watchdog->signal_flag_ = SignalFlags::FromIdle;
    watchdog->HandleInterrupt();
  });
  CHECK_EQ(r, 0);
  uv_unref(reinterpret_cast<uv_handle_t*>(&handle_));
}",54,,171,3,,void
250404,BLOCK,-1,,"{
  /**
   * In case of uv loop polling, i.e. no JS currently running, activate the
   * loop to run a piece of JS code to trigger interruption.
   */
  CHECK_EQ(uv_async_send(&handle_), 0);
  env()->isolate()->RequestInterrupt(
      [](v8::Isolate* isolate, void* data) {
        TraceSigintWatchdog* self = static_cast<TraceSigintWatchdog*>(data);
        if (self->signal_flag_ == SignalFlags::None) {
          self->signal_flag_ = SignalFlags::FromInterrupt;
        }
        self->HandleInterrupt();
      },
      this);
  return SignalPropagation::kContinuePropagation;
}",55,,182,1,,void
250426,BLOCK,-1,,"{
  // Do not nest interrupts.
  if (interrupting) {
    return;
  }
  interrupting = true;
  if (signal_flag_ == SignalFlags::None) {
    return;
  }
  Environment* env_ = env();
  // FIXME: Before
  // https://github.com/nodejs/node/pull/29207#issuecomment-527667993 get
  // fixed, additional JavaScript code evaluation shall be prevented from
  // running during interruption.
  FPrintF(stderr,
      ""KEYBOARD_INTERRUPT: Script execution was interrupted by `SIGINT`\n"");
  if (signal_flag_ == SignalFlags::FromInterrupt) {
    PrintStackTrace(env_->isolate(),
                    v8::StackTrace::CurrentStackTrace(
                        env_->isolate(), 10, v8::StackTrace::kDetailed));
  }
  signal_flag_ = SignalFlags::None;
  interrupting = false;

  Mutex::ScopedLock lock(SigintWatchdogHelper::GetInstanceActionMutex());
  SigintWatchdogHelper::GetInstance()->Unregister(this);
  SigintWatchdogHelper::GetInstance()->Stop();
  raise(SIGINT);
}",45,,200,1,,void
250429,BLOCK,-1,,"{
    return;
  }",21,,202,2,,void
250440,BLOCK,-1,,"{
    return;
  }",42,,206,2,,void
250455,BLOCK,-1,,"{
    PrintStackTrace(env_->isolate(),
                    v8::StackTrace::CurrentStackTrace(
                        env_->isolate(), 10, v8::StackTrace::kDetailed));
  }",51,,216,2,,void
250512,BLOCK,-1,,"{
  if (!instance.watchdog_disabled_ &&
      (dwCtrlType == CTRL_C_EVENT || dwCtrlType == CTRL_BREAK_EVENT)) {
    InformWatchdogsAboutSignal();

    // Return true because the signal has been handled.
    return TRUE;
  } else {
    return FALSE;
  }
}",76,,253,2,,void
250526,BLOCK,-1,,"{
    InformWatchdogsAboutSignal();

    // Return true because the signal has been handled.
    return TRUE;
  }",71,,255,2,,void
250531,BLOCK,-1,,"{
    return FALSE;
  }",10,,260,1,,void
250537,BLOCK,-1,,"{
  Mutex::ScopedLock list_lock(instance.list_mutex_);

  bool is_stopping = false;
#ifdef __POSIX__
  is_stopping = instance.stopping_;
#endif

  // If there are no listeners and the helper thread has been awoken by a signal
  // (= not when stopping it), indicate that by setting has_pending_signal_.
  if (instance.watchdogs_.empty() && !is_stopping) {
    instance.has_pending_signal_ = true;
  }

  for (auto it = instance.watchdogs_.rbegin(); it != instance.watchdogs_.rend();
       it++) {
    SignalPropagation wp = (*it)->HandleSigint();
    if (wp == SignalPropagation::kStopPropagation) {
      break;
    }
  }

  return is_stopping;
}",57,,267,1,,void
250557,BLOCK,-1,,"{
    instance.has_pending_signal_ = true;
  }",52,,277,2,,void
250564,BLOCK,-1,,<empty>,3,,281,1,,void
250584,BLOCK,4,,"{
    SignalPropagation wp = (*it)->HandleSigint();
    if (wp == SignalPropagation::kStopPropagation) {
      break;
    }
  }",14,,282,4,,void
250599,BLOCK,-1,,"{
      break;
    }",52,,284,2,,void
250606,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);

  if (start_stop_count_++ > 0) {
    return 0;
  }

#ifdef __POSIX__
  CHECK_EQ(has_running_thread_, false);
  has_pending_signal_ = false;
  stopping_ = false;

  sigset_t sigmask;
  sigfillset(&sigmask);
  sigset_t savemask;
  CHECK_EQ(0, pthread_sigmask(SIG_SETMASK, &sigmask, &savemask));
  sigmask = savemask;
  int ret = pthread_create(&thread_, nullptr, RunSigintWatchdog, nullptr);
  CHECK_EQ(0, pthread_sigmask(SIG_SETMASK, &sigmask, nullptr));
  if (ret != 0) {
    return ret;
  }
  has_running_thread_ = true;

  RegisterSignalHandler(SIGINT, HandleSignal);
#else
  if (watchdog_disabled_) {
    watchdog_disabled_ = false;
  } else {
    SetConsoleCtrlHandler(WinCtrlCHandlerRoutine, TRUE);
  }
#endif

  return 0;
}",35,,293,1,,void
250615,BLOCK,-1,,"{
    return 0;
  }",32,,296,2,,void
250620,BLOCK,-1,,"{
    watchdog_disabled_ = false;
  }",27,,319,2,,void
250625,BLOCK,-1,,"{
    SetConsoleCtrlHandler(WinCtrlCHandlerRoutine, TRUE);
  }",10,,321,1,,void
250634,BLOCK,-1,,"{
  bool had_pending_signal;
  Mutex::ScopedLock lock(mutex_);

  {
    Mutex::ScopedLock list_lock(list_mutex_);

    had_pending_signal = has_pending_signal_;

    if (--start_stop_count_ > 0) {
      has_pending_signal_ = false;
      return had_pending_signal;
    }

#ifdef __POSIX__
    // Set stopping now because it's only protected by list_mutex_.
    stopping_ = true;
#endif

    watchdogs_.clear();
  }

#ifdef __POSIX__
  if (!has_running_thread_) {
    has_pending_signal_ = false;
    return had_pending_signal;
  }

  // Wake up the helper thread.
  uv_sem_post(&sem_);

  // Wait for the helper thread to finish.
  CHECK_EQ(0, pthread_join(thread_, nullptr));
  has_running_thread_ = false;

  RegisterSignalHandler(SIGINT, SignalExit, true);
#else
  watchdog_disabled_ = true;
#endif

  had_pending_signal = has_pending_signal_;
  has_pending_signal_ = false;

  return had_pending_signal;
}",35,,330,1,,void
250639,BLOCK,4,,"{
    Mutex::ScopedLock list_lock(list_mutex_);

    had_pending_signal = has_pending_signal_;

    if (--start_stop_count_ > 0) {
      has_pending_signal_ = false;
      return had_pending_signal;
    }

#ifdef __POSIX__
    // Set stopping now because it's only protected by list_mutex_.
    stopping_ = true;
#endif

    watchdogs_.clear();
  }",3,,334,4,,void
250651,BLOCK,-1,,"{
      has_pending_signal_ = false;
      return had_pending_signal;
    }",34,,339,2,,void
250675,BLOCK,-1,,"{
  Mutex::ScopedLock lock(list_mutex_);

  return has_pending_signal_;
}",47,,377,1,,void
250685,BLOCK,-1,,"{
  Mutex::ScopedLock lock(list_mutex_);

  watchdogs_.push_back(wd);
}",61,,383,2,,void
250698,BLOCK,-1,,"{
  Mutex::ScopedLock lock(list_mutex_);

  auto it = std::find(watchdogs_.begin(), watchdogs_.end(), wd);

  CHECK_NE(it, watchdogs_.end());
  watchdogs_.erase(it);
}",63,,389,2,,void
250732,BLOCK,-1,,"{
#ifdef __POSIX__
  has_running_thread_ = false;
  stopping_ = false;
  CHECK_EQ(0, uv_sem_init(&sem_, 0));
#else
  watchdog_disabled_ = false;
#endif
}",34,,401,1,,void
250739,BLOCK,-1,,"{
  start_stop_count_ = 0;
  Stop();

#ifdef __POSIX__
  CHECK_EQ(has_running_thread_, false);
  uv_sem_destroy(&sem_);
#endif
}",47,,412,1,,void
250754,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  TraceSigintWatchdog::Init(env, target);
}",36,,429,5,,void
250790,BLOCK,-1,,<empty>,1,,1,1,,ANY
250794,BLOCK,-1,,"{
        *static_cast<bool*>(data) = true;
      }",73,,215,2,,void
250806,BLOCK,-1,,"{
      // TODO(addaleax): This call is harmless but should not be necessary.
      // Figure out why V8 is raising a DCHECK() here without it
      // (in test/parallel/test-async-hooks-worker-asyncfn-terminate-4.js).
      isolate_->CancelTerminateExecution();

      if (!env_) return;
      env_->set_can_call_into_js(false);

      {
        Mutex::ScopedLock lock(mutex_);
        stopped_ = true;
        this->env_ = nullptr;
      }

      env_.reset();
    }",43,,291,1,,void
250814,BLOCK,-1,,<empty>,18,,297,2,,void
250821,BLOCK,4,,"{
        Mutex::ScopedLock lock(mutex_);
        stopped_ = true;
        this->env_ = nullptr;
      }",7,,300,4,,void
250844,BLOCK,-1,,"{
          Exit(static_cast<ExitCode>(exit_code));
        }",79,,360,3,,void
250854,BLOCK,-1,,"{
      return env_vars->Get(name).FromMaybe("""");
    }",79,,521,2,,void
250871,BLOCK,-1,,"{
          if (w->has_ref_)
            env->add_refs(-1);
          w->JoinThread();
          // implicitly delete w
        }",60,,679,2,,void
250876,BLOCK,-1,,<empty>,13,,681,2,,void
250893,BLOCK,-1,,"{
    // XXX: This could become a std::unique_ptr, but that makes at least
    // gcc 6.3 detect undefined behaviour when there shouldn't be any.
    // gcc 7+ handles this well.
    Worker* w = static_cast<Worker*>(arg);
    const uintptr_t stack_top = reinterpret_cast<uintptr_t>(&arg);

    // Leave a few kilobytes just to make sure we're within limits and have
    // some space to do work in C++ land.
    w->stack_base_ = stack_top - (w->stack_size_ - kStackBufferSize);

    w->Run();

    Mutex::ScopedLock lock(w->mutex_);
    w->env()->SetImmediateThreadsafe(
        [w = std::unique_ptr<Worker>(w)](Environment* env) {
          if (w->has_ref_)
            env->add_refs(-1);
          w->JoinThread();
          // implicitly delete w
        });
  }",69,,664,2,,void
250939,BLOCK,-1,,"{
          HandleScope handle_scope(env->isolate());
          Context::Scope context_scope(env->context());

          AsyncHooks::DefaultTriggerAsyncIdScope trigger_id_scope(taker->get());
          BaseObjectPtr<AsyncWrap> stream =
              heap::CreateHeapSnapshotStream(env, std::move(snapshot));
          Local<Value> args[] = {stream->object()};
          taker->get()->MakeCallback(
              env->ondone_string(), arraysize(args), args);
          // implicitly delete `taker`
        }",68,,830,2,,void
251003,BLOCK,-1,,"{
    heap::HeapSnapshotPointer snapshot{
        worker_env->isolate()->GetHeapProfiler()->TakeHeapSnapshot(options)};
    CHECK(snapshot);

    // Here, the worker thread temporarily owns the WorkerHeapSnapshotTaker
    // object.

    env->SetImmediateThreadsafe(
        [taker = std::move(taker),
         snapshot = std::move(snapshot)](Environment* env) mutable {
          HandleScope handle_scope(env->isolate());
          Context::Scope context_scope(env->context());

          AsyncHooks::DefaultTriggerAsyncIdScope trigger_id_scope(taker->get());
          BaseObjectPtr<AsyncWrap> stream =
              heap::CreateHeapSnapshotStream(env, std::move(snapshot));
          Local<Value> args[] = {stream->object()};
          taker->get()->MakeCallback(
              env->ondone_string(), arraysize(args), args);
          // implicitly delete `taker`
        },
        CallbackFlags::kUnrefed);

    // Now, the lambda is delivered to the main thread, as a result, the
    // Worke...",77,,820,2,,void
251066,BLOCK,-1,,<empty>,1,,1,1,,ANY
251084,BLOCK,-1,,"{
  Debug(this, ""Creating new worker instance with thread id %llu"",
        thread_id_.id);

  // Set up everything that needs to be set up in the parent environment.
  MessagePort* parent_port = MessagePort::New(env, env->context());
  if (parent_port == nullptr) {
    // This can happen e.g. because execution is terminating.
    return;
  }

  child_port_data_ = std::make_unique<MessagePortData>(nullptr);
  MessagePort::Entangle(parent_port, child_port_data_.get());

  object()
      ->Set(env->context(), env->message_port_string(), parent_port->object())
      .Check();

  object()->Set(env->context(),
                env->thread_id_string(),
                Number::New(env->isolate(), static_cast<double>(thread_id_.id)))
      .Check();

  inspector_parent_handle_ =
      GetInspectorParentHandle(env, thread_id_, url.c_str(), name.c_str());

  argv_ = std::vector<std::string>{env->argv()[0]};
  // Mark this Worker object as weak until we actually start the thread.
  MakeWeak();
...",37,,65,9,,void
251107,BLOCK,-1,,"{
    // This can happen e.g. because execution is terminating.
    return;
  }",31,,71,2,,void
251207,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  if (env_ != nullptr)
    return env_->is_stopping();
  return stopped_;
}",33,,98,1,,void
251215,BLOCK,-1,,<empty>,5,,101,2,,void
251227,BLOCK,-1,,"{
  constraints->set_stack_limit(reinterpret_cast<uint32_t*>(stack_base_));

  if (resource_limits_[kMaxYoungGenerationSizeMb] > 0) {
    constraints->set_max_young_generation_size_in_bytes(
        static_cast<size_t>(resource_limits_[kMaxYoungGenerationSizeMb] * kMB));
  } else {
    resource_limits_[kMaxYoungGenerationSizeMb] =
        constraints->max_young_generation_size_in_bytes() / kMB;
  }

  if (resource_limits_[kMaxOldGenerationSizeMb] > 0) {
    constraints->set_max_old_generation_size_in_bytes(
        static_cast<size_t>(resource_limits_[kMaxOldGenerationSizeMb] * kMB));
  } else {
    resource_limits_[kMaxOldGenerationSizeMb] =
        constraints->max_old_generation_size_in_bytes() / kMB;
  }

  if (resource_limits_[kCodeRangeSizeMb] > 0) {
    constraints->set_code_range_size_in_bytes(
        static_cast<size_t>(resource_limits_[kCodeRangeSizeMb] * kMB));
  } else {
    resource_limits_[kCodeRangeSizeMb] =
        constraints->code_range_size_in_bytes() / kMB;
  }
}",74,,105,2,,void
251241,BLOCK,-1,,"{
    constraints->set_max_young_generation_size_in_bytes(
        static_cast<size_t>(resource_limits_[kMaxYoungGenerationSizeMb] * kMB));
  }",56,,108,2,,void
251254,BLOCK,-1,,"{
    resource_limits_[kMaxYoungGenerationSizeMb] =
        constraints->max_young_generation_size_in_bytes() / kMB;
  }",10,,111,1,,void
251271,BLOCK,-1,,"{
    constraints->set_max_old_generation_size_in_bytes(
        static_cast<size_t>(resource_limits_[kMaxOldGenerationSizeMb] * kMB));
  }",54,,116,2,,void
251284,BLOCK,-1,,"{
    resource_limits_[kMaxOldGenerationSizeMb] =
        constraints->max_old_generation_size_in_bytes() / kMB;
  }",10,,119,1,,void
251301,BLOCK,-1,,"{
    constraints->set_code_range_size_in_bytes(
        static_cast<size_t>(resource_limits_[kCodeRangeSizeMb] * kMB));
  }",47,,124,2,,void
251314,BLOCK,-1,,"{
    resource_limits_[kCodeRangeSizeMb] =
        constraints->code_range_size_in_bytes() / kMB;
  }",10,,127,1,,void
251329,BLOCK,-1,,"{
    int ret = uv_loop_init(&loop_);
    if (ret != 0) {
      char err_buf[128];
      uv_err_name_r(ret, err_buf, sizeof(err_buf));
      // TODO(joyeecheung): maybe this should be kBootstrapFailure instead?
      w->Exit(ExitCode::kGenericUserError, ""ERR_WORKER_INIT_FAILED"", err_buf);
      return;
    }
    loop_init_failed_ = false;
    uv_loop_configure(&loop_, UV_METRICS_IDLE_TIME);

    std::shared_ptr<ArrayBufferAllocator> allocator =
        ArrayBufferAllocator::Create();
    Isolate::CreateParams params;
    SetIsolateCreateParamsForNode(&params);
    w->UpdateResourceConstraints(&params.constraints);
    params.array_buffer_allocator_shared = allocator;
    Isolate* isolate =
        NewIsolate(&params, &loop_, w->platform_, w->snapshot_data());
    if (isolate == nullptr) {
      // TODO(joyeecheung): maybe this should be kBootstrapFailure instead?
      w->Exit(ExitCode::kGenericUserError,
              ""ERR_WORKER_INIT_FAILED"",
              ""Failed to create new Is...",13,,139,2,,void
251340,BLOCK,-1,,"{
      char err_buf[128];
      uv_err_name_r(ret, err_buf, sizeof(err_buf));
      // TODO(joyeecheung): maybe this should be kBootstrapFailure instead?
      w->Exit(ExitCode::kGenericUserError, ""ERR_WORKER_INIT_FAILED"", err_buf);
      return;
    }",19,,141,2,,void
251407,BLOCK,-1,,"{
      // TODO(joyeecheung): maybe this should be kBootstrapFailure instead?
      w->Exit(ExitCode::kGenericUserError,
              ""ERR_WORKER_INIT_FAILED"",
              ""Failed to create new Isolate"");
      return;
    }",29,,159,2,,void
251428,BLOCK,17,,"{
      Locker locker(isolate);
      Isolate::Scope isolate_scope(isolate);
      // V8 computes its stack limit the first time a `Locker` is used based on
      // --stack-size. Reset it to the correct value.
      isolate->SetStackLimit(w->stack_base_);

      HandleScope handle_scope(isolate);
      isolate_data_.reset(
          CreateIsolateData(isolate,
                            &loop_,
                            w_->platform_,
                            allocator.get(),
                            w->snapshot_data()->AsEmbedderWrapper().get()));
      CHECK(isolate_data_);
      if (w_->per_isolate_opts_)
        isolate_data_->set_options(std::move(w_->per_isolate_opts_));
      isolate_data_->set_worker_context(w_);
      isolate_data_->max_young_gen_size =
          params.constraints.max_young_generation_size_in_bytes();
    }",5,,174,17,,void
251476,BLOCK,-1,,<empty>,9,,190,2,,void
251516,BLOCK,-1,,"{
    Debug(w_, ""Worker %llu dispose isolate"", w_->thread_id_.id);
    Isolate* isolate;
    {
      Mutex::ScopedLock lock(w_->mutex_);
      isolate = w_->isolate_;
      w_->isolate_ = nullptr;
    }

    if (isolate != nullptr) {
      CHECK(!loop_init_failed_);
      bool platform_finished = false;

      isolate_data_.reset();

      w_->platform_->AddIsolateFinishedCallback(isolate, [](void* data) {
        *static_cast<bool*>(data) = true;
      }, &platform_finished);

      // The order of these calls is important; if the Isolate is first disposed
      // and then unregistered, there is a race condition window in which no
      // new Isolate at the same address can successfully be registered with
      // the platform.
      // (Refs: https://github.com/nodejs/node/issues/30846)
      w_->platform_->UnregisterIsolate(isolate);
      isolate->Dispose();

      // Wait until the platform has cleaned up all relevant resources.
      while (!platform_finished) {
        uv_r...",23,,200,1,,void
251526,BLOCK,3,,"{
      Mutex::ScopedLock lock(w_->mutex_);
      isolate = w_->isolate_;
      w_->isolate_ = nullptr;
    }",5,,203,3,,void
251546,BLOCK,-1,,"{
      CHECK(!loop_init_failed_);
      bool platform_finished = false;

      isolate_data_.reset();

      w_->platform_->AddIsolateFinishedCallback(isolate, [](void* data) {
        *static_cast<bool*>(data) = true;
      }, &platform_finished);

      // The order of these calls is important; if the Isolate is first disposed
      // and then unregistered, there is a race condition window in which no
      // new Isolate at the same address can successfully be registered with
      // the platform.
      // (Refs: https://github.com/nodejs/node/issues/30846)
      w_->platform_->UnregisterIsolate(isolate);
      isolate->Dispose();

      // Wait until the platform has cleaned up all relevant resources.
      while (!platform_finished) {
        uv_run(&loop_, UV_RUN_ONCE);
      }
    }",29,,209,2,,void
251582,BLOCK,-1,,"{
        uv_run(&loop_, UV_RUN_ONCE);
      }",34,,228,2,,void
251590,BLOCK,-1,,"{
      CheckedUvLoopClose(&loop_);
    }",29,,232,2,,void
251597,BLOCK,-1,,{ return !loop_init_failed_; },31,,237,1,,void
251610,BLOCK,-1,,<empty>,,,,1,,<empty>
251623,BLOCK,-1,,"{
  Worker* worker = static_cast<Worker*>(data);
  // Give the current GC some extra leeway to let it finish rather than
  // crash hard. We are not going to perform further allocations anyway.
  constexpr size_t kExtraHeapAllowance = 16 * 1024 * 1024;
  size_t new_limit = current_heap_limit + kExtraHeapAllowance;
  Environment* env = worker->env();
  if (env != nullptr) {
    DCHECK(!env->is_in_heapsnapshot_heap_limit_callback());
    Debug(env,
          DebugCategory::DIAGNOSTICS,
          ""Throwing ERR_WORKER_OUT_OF_MEMORY, ""
          ""new_limit=%"" PRIu64 ""\n"",
          static_cast<uint64_t>(new_limit));
  }
  // TODO(joyeecheung): maybe this should be kV8FatalError instead?
  worker->Exit(ExitCode::kGenericUserError,
               ""ERR_WORKER_OUT_OF_MEMORY"",
               ""JS heap out of memory"");
  return new_limit;
}",57,,249,4,,void
251655,BLOCK,-1,,"{
    DCHECK(!env->is_in_heapsnapshot_heap_limit_callback());
    Debug(env,
          DebugCategory::DIAGNOSTICS,
          ""Throwing ERR_WORKER_OUT_OF_MEMORY, ""
          ""new_limit=%"" PRIu64 ""\n"",
          static_cast<uint64_t>(new_limit));
  }",23,,256,2,,void
251677,BLOCK,-1,,"{
  std::string trace_name = ""[worker "" + std::to_string(thread_id_.id) + ""]"" +
                           (name_ == """" ? """" : "" "" + name_);
  TRACE_EVENT_METADATA1(
      ""__metadata"", ""thread_name"", ""name"", TRACE_STR_COPY(trace_name.c_str()));
  CHECK_NOT_NULL(platform_);

  Debug(this, ""Creating isolate for worker with id %llu"", thread_id_.id);

  WorkerThreadData data(this);
  if (isolate_ == nullptr) return;
  CHECK(data.loop_is_usable());

  Debug(this, ""Starting worker with id %llu"", thread_id_.id);
  {
    Locker locker(isolate_);
    Isolate::Scope isolate_scope(isolate_);
    SealHandleScope outer_seal(isolate_);

    DeleteFnPtr<Environment, FreeEnvironment> env_;
    auto cleanup_env = OnScopeLeave([&]() {
      // TODO(addaleax): This call is harmless but should not be necessary.
      // Figure out why V8 is raising a DCHECK() here without it
      // (in test/parallel/test-async-hooks-worker-asyncfn-terminate-4.js).
      isolate_->CancelTerminateExecution();

      i...",20,,271,1,,void
251724,BLOCK,-1,,<empty>,28,,281,2,,void
251737,BLOCK,11,,"{
    Locker locker(isolate_);
    Isolate::Scope isolate_scope(isolate_);
    SealHandleScope outer_seal(isolate_);

    DeleteFnPtr<Environment, FreeEnvironment> env_;
    auto cleanup_env = OnScopeLeave([&]() {
      // TODO(addaleax): This call is harmless but should not be necessary.
      // Figure out why V8 is raising a DCHECK() here without it
      // (in test/parallel/test-async-hooks-worker-asyncfn-terminate-4.js).
      isolate_->CancelTerminateExecution();

      if (!env_) return;
      env_->set_can_call_into_js(false);

      {
        Mutex::ScopedLock lock(mutex_);
        stopped_ = true;
        this->env_ = nullptr;
      }

      env_.reset();
    });

    if (is_stopped()) return;
    {
      HandleScope handle_scope(isolate_);
      Local<Context> context;
      {
        // We create the Context object before we have an Environment* in place
        // that we could use for error handling. If creation fails due to
        // resource constraints, we need so...",3,,285,11,,void
251761,BLOCK,-1,,<empty>,23,,309,2,,void
251763,BLOCK,11,,"{
      HandleScope handle_scope(isolate_);
      Local<Context> context;
      {
        // We create the Context object before we have an Environment* in place
        // that we could use for error handling. If creation fails due to
        // resource constraints, we need something in place to handle it,
        // though.
        TryCatch try_catch(isolate_);
        if (snapshot_data_ != nullptr) {
          Debug(this,
                ""Worker %llu uses context from snapshot %d\n"",
                thread_id_.id,
                static_cast<int>(SnapshotData::kNodeBaseContextIndex));
          context = Context::FromSnapshot(isolate_,
                                          SnapshotData::kNodeBaseContextIndex)
                        .ToLocalChecked();
          if (!context.IsEmpty() &&
              !InitializeContextRuntime(context).IsJust()) {
            context = Local<Context>();
          }
        } else {
          Debug(
              this, ""Worker %llu builds cont...",5,,310,11,,void
251772,BLOCK,4,,"{
        // We create the Context object before we have an Environment* in place
        // that we could use for error handling. If creation fails due to
        // resource constraints, we need something in place to handle it,
        // though.
        TryCatch try_catch(isolate_);
        if (snapshot_data_ != nullptr) {
          Debug(this,
                ""Worker %llu uses context from snapshot %d\n"",
                thread_id_.id,
                static_cast<int>(SnapshotData::kNodeBaseContextIndex));
          context = Context::FromSnapshot(isolate_,
                                          SnapshotData::kNodeBaseContextIndex)
                        .ToLocalChecked();
          if (!context.IsEmpty() &&
              !InitializeContextRuntime(context).IsJust()) {
            context = Local<Context>();
          }
        } else {
          Debug(
              this, ""Worker %llu builds context from scratch\n"", thread_id_.id);
          context = NewContext(isolate_);
 ...",7,,313,4,,void
251780,BLOCK,-1,,"{
          Debug(this,
                ""Worker %llu uses context from snapshot %d\n"",
                thread_id_.id,
                static_cast<int>(SnapshotData::kNodeBaseContextIndex));
          context = Context::FromSnapshot(isolate_,
                                          SnapshotData::kNodeBaseContextIndex)
                        .ToLocalChecked();
          if (!context.IsEmpty() &&
              !InitializeContextRuntime(context).IsJust()) {
            context = Local<Context>();
          }
        }",40,,319,2,,void
251818,BLOCK,-1,,"{
            context = Local<Context>();
          }",60,,328,2,,void
251823,BLOCK,-1,,"{
          Debug(
              this, ""Worker %llu builds context from scratch\n"", thread_id_.id);
          context = NewContext(isolate_);
        }",16,,331,1,,void
251839,BLOCK,-1,,"{
          // TODO(joyeecheung): maybe this should be kBootstrapFailure instead?
          Exit(ExitCode::kGenericUserError,
               ""ERR_WORKER_INIT_FAILED"",
               ""Failed to create new Context"");
          return;
        }",32,,336,2,,void
251849,BLOCK,-1,,<empty>,25,,345,2,,void
251860,BLOCK,9,,"{
        env_.reset(CreateEnvironment(
            data.isolate_data_.get(),
            context,
            std::move(argv_),
            std::move(exec_argv_),
            static_cast<EnvironmentFlags::Flags>(environment_flags_),
            thread_id_,
            std::move(inspector_parent_handle_)));
        if (is_stopped()) return;
        CHECK_NOT_NULL(env_);
        env_->set_env_vars(std::move(env_vars_));
        SetProcessExitHandler(env_.get(), [this](Environment*, int exit_code) {
          Exit(static_cast<ExitCode>(exit_code));
        });
      }",7,,348,9,,void
251894,BLOCK,-1,,<empty>,27,,357,2,,void
251912,BLOCK,10,,"{
        Mutex::ScopedLock lock(mutex_);
        if (stopped_) return;
        this->env_ = env_.get();
      }",7,,364,10,,void
251918,BLOCK,-1,,<empty>,23,,366,2,,void
251936,BLOCK,-1,,<empty>,25,,370,2,,void
251938,BLOCK,13,,"{
        if (!CreateEnvMessagePort(env_.get())) {
          return;
        }

        Debug(this, ""Created message port for worker %llu"", thread_id_.id);
        if (LoadEnvironment(env_.get(), StartExecutionCallback{}).IsEmpty())
          return;

        Debug(this, ""Loaded environment for worker %llu"", thread_id_.id);
      }",7,,371,13,,void
251946,BLOCK,-1,,"{
          return;
        }",48,,372,2,,void
251965,BLOCK,-1,,<empty>,11,,378,2,,void
251973,BLOCK,12,,"{
      Maybe<ExitCode> exit_code = SpinEventLoopInternal(env_.get());
      Mutex::ScopedLock lock(mutex_);
      if (exit_code_ == ExitCode::kNoFailure && exit_code.IsJust()) {
        exit_code_ = exit_code.FromJust();
      }

      Debug(this,
            ""Exiting thread for worker %llu with exit code %d"",
            thread_id_.id,
            static_cast<int>(exit_code_));
    }",5,,384,12,,void
251999,BLOCK,-1,,"{
        exit_code_ = exit_code.FromJust();
      }",69,,387,2,,void
252025,BLOCK,-1,,"{
  HandleScope handle_scope(isolate_);
  std::unique_ptr<MessagePortData> data;
  {
    Mutex::ScopedLock lock(mutex_);
    data = std::move(child_port_data_);
  }

  // Set up the message channel for receiving messages in the child.
  MessagePort* child_port = MessagePort::New(env,
                                             env->context(),
                                             std::move(data));
  // MessagePort::New() may return nullptr if execution is terminated
  // within it.
  if (child_port != nullptr)
    env->set_message_port(child_port->object(isolate_));

  return child_port;
}",53,,401,2,,void
252036,BLOCK,4,,"{
    Mutex::ScopedLock lock(mutex_);
    data = std::move(child_port_data_);
  }",3,,404,4,,void
252068,BLOCK,-1,,<empty>,5,,416,2,,void
252083,BLOCK,-1,,"{
  if (!tid_.has_value())
    return;
  CHECK_EQ(uv_thread_join(&tid_.value()), 0);
  tid_.reset();

  env()->remove_sub_worker_context(this);

  {
    HandleScope handle_scope(env()->isolate());
    Context::Scope context_scope(env()->context());

    // Reset the parent port as we're closing it now anyway.
    object()->Set(env()->context(),
                  env()->message_port_string(),
                  Undefined(env()->isolate())).Check();

    Local<Value> args[] = {
        Integer::New(env()->isolate(), static_cast<int>(exit_code_)),
        custom_error_ != nullptr
            ? OneByteString(env()->isolate(), custom_error_).As<Value>()
            : Null(env()->isolate()).As<Value>(),
        !custom_error_str_.empty()
            ? OneByteString(env()->isolate(), custom_error_str_.c_str())
                  .As<Value>()
            : Null(env()->isolate()).As<Value>(),
    };

    MakeCallback(env()->onexit_string(), arraysize(args), args);
  }

  // If we get here, the...",27,,421,1,,void
252090,BLOCK,-1,,<empty>,5,,423,2,,void
252109,BLOCK,5,,"{
    HandleScope handle_scope(env()->isolate());
    Context::Scope context_scope(env()->context());

    // Reset the parent port as we're closing it now anyway.
    object()->Set(env()->context(),
                  env()->message_port_string(),
                  Undefined(env()->isolate())).Check();

    Local<Value> args[] = {
        Integer::New(env()->isolate(), static_cast<int>(exit_code_)),
        custom_error_ != nullptr
            ? OneByteString(env()->isolate(), custom_error_).As<Value>()
            : Null(env()->isolate()).As<Value>(),
        !custom_error_str_.empty()
            ? OneByteString(env()->isolate(), custom_error_str_.c_str())
                  .As<Value>()
            : Null(env()->isolate()).As<Value>(),
    };

    MakeCallback(env()->onexit_string(), arraysize(args), args);
  }",3,,429,5,,void
252215,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);

  CHECK(stopped_);
  CHECK_NULL(env_);
  CHECK(!tid_.has_value());

  Debug(this, ""Worker %llu destroyed"", thread_id_.id);
}",19,,458,1,,void
252237,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  auto is_internal = args[5];
  CHECK(is_internal->IsBoolean());
  if (is_internal->IsFalse()) {
    THROW_IF_INSUFFICIENT_PERMISSIONS(
        env, permission::PermissionScope::kWorkerThreads, """");
  }
  Isolate* isolate = args.GetIsolate();

  CHECK(args.IsConstructCall());

  if (env->isolate_data()->platform() == nullptr) {
    THROW_ERR_MISSING_PLATFORM_FOR_WORKER(env);
    return;
  }

  std::string url;
  std::string name;
  std::shared_ptr<PerIsolateOptions> per_isolate_opts = nullptr;
  std::shared_ptr<KVStore> env_vars = nullptr;

  std::vector<std::string> exec_argv_out;

  // Argument might be a string or URL
  if (!args[0]->IsNullOrUndefined()) {
    Utf8Value value(
        isolate, args[0]->ToString(env->context()).FromMaybe(Local<String>()));
    url.append(value.out(), value.length());
  }

  if (!args[6]->IsNullOrUndefined()) {
    Utf8Value value(
        isolate, args[6]->ToString(env->context()).FromMaybe(Loc...",59,,468,2,,void
252262,BLOCK,-1,,"{
    THROW_IF_INSUFFICIENT_PERMISSIONS(
        env, permission::PermissionScope::kWorkerThreads, """");
  }",31,,472,2,,void
252293,BLOCK,-1,,"{
    THROW_ERR_MISSING_PLATFORM_FOR_WORKER(env);
    return;
  }",51,,480,2,,void
252333,BLOCK,-1,,"{
    Utf8Value value(
        isolate, args[0]->ToString(env->context()).FromMaybe(Local<String>()));
    url.append(value.out(), value.length());
  }",38,,493,2,,void
252371,BLOCK,-1,,"{
    Utf8Value value(
        isolate, args[6]->ToString(env->context()).FromMaybe(Local<String>()));
    name.append(value.out(), value.length());
  }",38,,499,2,,void
252408,BLOCK,-1,,"{
    // Means worker.env = { ...process.env }.
    env_vars = env->env_vars()->Clone(isolate);
  }",26,,505,2,,void
252420,BLOCK,-1,,<empty>,10,,508,1,,void
252428,BLOCK,-1,,"{
    // User provided env.
    env_vars = KVStore::CreateMapKVStore();
    env_vars->AssignFromObject(isolate->GetCurrentContext(),
                               args[1].As<Object>());
  }",35,,508,2,,void
252450,BLOCK,-1,,"{
    // Env is shared.
    env_vars = env->env_vars();
  }",10,,513,1,,void
252471,BLOCK,-1,,"{
    per_isolate_opts.reset(new PerIsolateOptions());

    HandleEnvOptions(per_isolate_opts->per_env, [&env_vars](const char* name) {
      return env_vars->Get(name).FromMaybe("""");
    });

#ifndef NODE_WITHOUT_NODE_OPTIONS
    MaybeLocal<String> maybe_node_opts =
        env_vars->Get(isolate, OneByteString(isolate, ""NODE_OPTIONS""));
    Local<String> node_opts;
    if (maybe_node_opts.ToLocal(&node_opts)) {
      std::string node_options(*String::Utf8Value(isolate, node_opts));
      std::vector<std::string> errors{};
      std::vector<std::string> env_argv =
          ParseNodeOptionsEnvVar(node_options, &errors);
      // [0] is expected to be the program name, add dummy string.
      env_argv.insert(env_argv.begin(), """");
      std::vector<std::string> invalid_args{};
      options_parser::Parse(&env_argv,
                            nullptr,
                            &invalid_args,
                            per_isolate_opts.get(),
                            kAllowedInE...",50,,518,2,,void
252509,BLOCK,-1,,"{
      std::string node_options(*String::Utf8Value(isolate, node_opts));
      std::vector<std::string> errors{};
      std::vector<std::string> env_argv =
          ParseNodeOptionsEnvVar(node_options, &errors);
      // [0] is expected to be the program name, add dummy string.
      env_argv.insert(env_argv.begin(), """");
      std::vector<std::string> invalid_args{};
      options_parser::Parse(&env_argv,
                            nullptr,
                            &invalid_args,
                            per_isolate_opts.get(),
                            kAllowedInEnvvar,
                            &errors);
      if (!errors.empty() && args[1]->IsObject()) {
        // Only fail for explicitly provided env, this protects from failures
        // when NODE_OPTIONS from parent's env is used (which is the default).
        Local<Value> error;
        if (!ToV8Value(env->context(), errors).ToLocal(&error)) return;
        Local<String> key =
            FIXED_ONE_BYTE_STRIN...",46,,529,2,,void
252591,BLOCK,-1,,"{
        // Only fail for explicitly provided env, this protects from failures
        // when NODE_OPTIONS from parent's env is used (which is the default).
        Local<Value> error;
        if (!ToV8Value(env->context(), errors).ToLocal(&error)) return;
        Local<String> key =
            FIXED_ONE_BYTE_STRING(env->isolate(), ""invalidNodeOptions"");
        // Ignore the return value of Set() because exceptions bubble up to JS
        // when we return anyway.
        USE(args.This()->Set(env->context(), key, error));
        return;
      }",51,,543,2,,void
252610,BLOCK,-1,,<empty>,65,,547,2,,void
252646,BLOCK,-1,,"{
    Local<Array> array = args[2].As<Array>();
    // The first argument is reserved for program name, but we don't need it
    // in workers.
    std::vector<std::string> exec_argv = {""""};
    uint32_t length = array->Length();
    for (uint32_t i = 0; i < length; i++) {
      Local<Value> arg;
      if (!array->Get(env->context(), i).ToLocal(&arg)) {
        return;
      }
      Local<String> arg_v8;
      if (!arg->ToString(env->context()).ToLocal(&arg_v8)) {
        return;
      }
      Utf8Value arg_utf8_value(args.GetIsolate(), arg_v8);
      std::string arg_string(arg_utf8_value.out(), arg_utf8_value.length());
      exec_argv.push_back(arg_string);
    }

    std::vector<std::string> invalid_args{};
    std::vector<std::string> errors{};
    // Using invalid_args as the v8_args argument as it stores unknown
    // options for the per isolate parser.
    options_parser::Parse(&exec_argv,
                          &exec_argv_out,
                          &invalid_args,
   ...",27,,559,2,,void
252677,BLOCK,-1,,<empty>,5,,565,1,,void
252687,BLOCK,4,,"{
      Local<Value> arg;
      if (!array->Get(env->context(), i).ToLocal(&arg)) {
        return;
      }
      Local<String> arg_v8;
      if (!arg->ToString(env->context()).ToLocal(&arg_v8)) {
        return;
      }
      Utf8Value arg_utf8_value(args.GetIsolate(), arg_v8);
      std::string arg_string(arg_utf8_value.out(), arg_utf8_value.length());
      exec_argv.push_back(arg_string);
    }",43,,565,4,,void
252709,BLOCK,-1,,"{
        return;
      }",57,,567,2,,void
252731,BLOCK,-1,,"{
        return;
      }",60,,571,2,,void
252814,BLOCK,-1,,"{
      Local<Value> error;
      if (!ToV8Value(env->context(),
                     errors.size() > 0 ? errors : invalid_args)
                         .ToLocal(&error)) {
        return;
      }
      Local<String> key =
          FIXED_ONE_BYTE_STRING(env->isolate(), ""invalidExecArgv"");
      // Ignore the return value of Set() because exceptions bubble up to JS
      // when we return anyway.
      USE(args.This()->Set(env->context(), key, error));
      return;
    }",55,,592,2,,void
252841,BLOCK,-1,,"{
        return;
      }",44,,596,2,,void
252871,BLOCK,-1,,"{
    exec_argv_out = env->exec_argv();
  }",10,,606,1,,void
252963,BLOCK,-1,,<empty>,5,,629,2,,void
252976,BLOCK,-1,,<empty>,5,,631,2,,void
252989,BLOCK,-1,,<empty>,5,,633,2,,void
253002,BLOCK,-1,,<empty>,5,,635,2,,void
253015,BLOCK,-1,,<empty>,5,,637,2,,void
253027,BLOCK,-1,,"{
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
  Mutex::ScopedLock lock(w->mutex_);

  w->stopped_ = false;

  if (w->resource_limits_[kStackSizeMb] > 0) {
    if (w->resource_limits_[kStackSizeMb] * kMB < kStackBufferSize) {
      w->resource_limits_[kStackSizeMb] = kStackBufferSize / kMB;
      w->stack_size_ = kStackBufferSize;
    } else {
      w->stack_size_ =
          static_cast<size_t>(w->resource_limits_[kStackSizeMb] * kMB);
    }
  } else {
    w->resource_limits_[kStackSizeMb] = w->stack_size_ / kMB;
  }

  uv_thread_options_t thread_options;
  thread_options.flags = UV_THREAD_HAS_STACK_SIZE;
  thread_options.stack_size = w->stack_size_;

  uv_thread_t* tid = &w->tid_.emplace();  // Create uv_thread_t instance
  int ret = uv_thread_create_ex(tid, &thread_options, [](void* arg) {
    // XXX: This could become a std::unique_ptr, but that makes at least
    // gcc 6.3 detect undefined behaviour when there shouldn't be any.
    // gcc 7+ handles this well.
    ...",67,,640,2,,void
253054,BLOCK,-1,,"{
    if (w->resource_limits_[kStackSizeMb] * kMB < kStackBufferSize) {
      w->resource_limits_[kStackSizeMb] = kStackBufferSize / kMB;
      w->stack_size_ = kStackBufferSize;
    } else {
      w->stack_size_ =
          static_cast<size_t>(w->resource_limits_[kStackSizeMb] * kMB);
    }
  }",46,,647,2,,void
253065,BLOCK,-1,,"{
      w->resource_limits_[kStackSizeMb] = kStackBufferSize / kMB;
      w->stack_size_ = kStackBufferSize;
    }",69,,648,2,,void
253081,BLOCK,-1,,"{
      w->stack_size_ =
          static_cast<size_t>(w->resource_limits_[kStackSizeMb] * kMB);
    }",12,,651,1,,void
253096,BLOCK,-1,,"{
    w->resource_limits_[kStackSizeMb] = w->stack_size_ / kMB;
  }",10,,655,1,,void
253146,BLOCK,-1,,"{
    // The object now owns the created thread and should not be garbage
    // collected until that finishes.
    w->ClearWeak();

    if (w->has_ref_)
      w->env()->add_refs(1);

    w->env()->add_sub_worker_context(w);
  }",17,,687,2,,void
253155,BLOCK,-1,,<empty>,7,,693,2,,void
253173,BLOCK,-1,,"{
    w->stopped_ = true;
    w->tid_.reset();

    char err_buf[128];
    uv_err_name_r(ret, err_buf, sizeof(err_buf));
    {
      Isolate* isolate = w->env()->isolate();
      HandleScope handle_scope(isolate);
      THROW_ERR_WORKER_INIT_FAILED(isolate, err_buf);
    }
  }",10,,696,1,,void
253191,BLOCK,5,,"{
      Isolate* isolate = w->env()->isolate();
      HandleScope handle_scope(isolate);
      THROW_ERR_WORKER_INIT_FAILED(isolate, err_buf);
    }",5,,702,5,,void
253212,BLOCK,-1,,"{
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());

  Debug(w, ""Worker %llu is getting stopped by parent"", w->thread_id_.id);
  w->Exit(ExitCode::kGenericUserError);
}",66,,710,2,,void
253240,BLOCK,-1,,"{
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
  if (!w->has_ref_ && w->tid_.has_value()) {
    w->has_ref_ = true;
    w->env()->add_refs(1);
  }
}",59,,718,2,,void
253261,BLOCK,-1,,"{
    w->has_ref_ = true;
    w->env()->add_refs(1);
  }",44,,721,2,,void
253279,BLOCK,-1,,"{
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
  args.GetReturnValue().Set(w->has_ref_);
}",62,,727,2,,void
253302,BLOCK,-1,,"{
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
  if (w->has_ref_ && w->tid_.has_value()) {
    w->has_ref_ = false;
    w->env()->add_refs(-1);
  }
}",61,,733,2,,void
253322,BLOCK,-1,,"{
    w->has_ref_ = false;
    w->env()->add_refs(-1);
  }",43,,736,2,,void
253341,BLOCK,-1,,"{
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
  args.GetReturnValue().Set(w->GetResourceLimits(args.GetIsolate()));
}",73,,742,2,,void
253369,BLOCK,-1,,"{
  Local<ArrayBuffer> ab = ArrayBuffer::New(isolate, sizeof(resource_limits_));

  memcpy(ab->Data(), resource_limits_, sizeof(resource_limits_));
  return Float64Array::New(ab, 0, kTotalResourceLimitCount);
}",71,,748,2,,void
253405,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  Debug(this,
        ""Worker %llu called Exit(%d, %s, %s)"",
        thread_id_.id,
        static_cast<int>(code),
        error_code,
        error_message);

  if (error_code != nullptr) {
    custom_error_ = error_code;
    custom_error_str_ = error_message;
  }

  if (env_ != nullptr) {
    exit_code_ = code;
    Stop(env_);
  } else {
    stopped_ = true;
  }
}",46,,757,4,,void
253424,BLOCK,-1,,"{
    custom_error_ = error_code;
    custom_error_str_ = error_message;
  }",30,,766,2,,void
253435,BLOCK,-1,,"{
    exit_code_ = code;
    Stop(env_);
  }",24,,771,2,,void
253441,BLOCK,-1,,"{
    stopped_ = true;
  }",10,,774,1,,void
253448,BLOCK,-1,,"{
  // Worker objects always stay alive as long as the child thread, regardless
  // of whether they are being referenced in the parent thread.
  return true;
}",56,,779,1,,void
253457,BLOCK,-1,,<empty>,67,,788,3,,void
253463,BLOCK,-1,,"{
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
  CHECK_EQ(args.Length(), 1);
  auto options = heap::GetHeapSnapshotOptions(args[0]);

  Debug(w, ""Worker %llu taking heap snapshot"", w->thread_id_.id);

  Environment* env = w->env();
  AsyncHooks::DefaultTriggerAsyncIdScope trigger_id_scope(w);
  Local<Object> wrap;
  if (!env->worker_heap_snapshot_taker_template()
      ->NewInstance(env->context()).ToLocal(&wrap)) {
    return;
  }

  // The created WorkerHeapSnapshotTaker is an object owned by main
  // thread's Isolate, it can not be accessed by worker thread
  std::unique_ptr<BaseObjectPtr<WorkerHeapSnapshotTaker>> taker =
      std::make_unique<BaseObjectPtr<WorkerHeapSnapshotTaker>>(
          MakeDetachedBaseObject<WorkerHeapSnapshotTaker>(env, wrap));

  // Interrupt the worker thread and take a snapshot, then schedule a call
  // on the parent thread that turns that snapshot into a readable stream.
  bool scheduled = w->RequestInterrupt([taker = std::move(taker),...",72,,795,2,,void
253527,BLOCK,-1,,"{
    return;
  }",53,,807,2,,void
253565,BLOCK,-1,,"{
    args.GetReturnValue().Set(wrap);
  }",18,,848,2,,void
253575,BLOCK,-1,,"{
    args.GetReturnValue().Set(Local<Object>());
  }",10,,850,1,,void
253588,BLOCK,-1,,"{
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());

  Mutex::ScopedLock lock(w->mutex_);
  // Using w->is_stopped() here leads to a deadlock, and checking is_stopped()
  // before locking the mutex is a race condition. So manually do the same
  // check.
  if (w->stopped_ || w->env_ == nullptr)
    return args.GetReturnValue().Set(-1);

  uint64_t idle_time = uv_metrics_idle_time(w->env_->event_loop());
  args.GetReturnValue().Set(1.0 * idle_time / 1e6);
}",68,,855,2,,void
253612,BLOCK,-1,,<empty>,5,,864,2,,void
253649,BLOCK,-1,,"{
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());

  Mutex::ScopedLock lock(w->mutex_);
  // Using w->is_stopped() here leads to a deadlock, and checking is_stopped()
  // before locking the mutex is a race condition. So manually do the same
  // check.
  if (w->stopped_ || w->env_ == nullptr)
    return args.GetReturnValue().Set(-1);

  double loop_start_time = w->env_->performance_state()->milestones[
      node::performance::NODE_PERFORMANCE_MILESTONE_LOOP_START];
  CHECK_GE(loop_start_time, 0);
  args.GetReturnValue().Set(loop_start_time / 1e6);
}",69,,870,2,,void
253673,BLOCK,-1,,<empty>,5,,879,2,,void
253719,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Local<Object> port = env->message_port();
  CHECK_IMPLIES(!env->is_main_thread(), !port.IsEmpty());
  if (!port.IsEmpty()) {
    CHECK_EQ(port->GetCreationContext().ToLocalChecked()->GetIsolate(),
             args.GetIsolate());
    args.GetReturnValue().Set(port);
  }
}",65,,891,2,,void
253755,BLOCK,-1,,"{
    CHECK_EQ(port->GetCreationContext().ToLocalChecked()->GetIsolate(),
             args.GetIsolate());
    args.GetReturnValue().Set(port);
  }",24,,895,2,,void
253784,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();
  Local<ObjectTemplate> proto = target->PrototypeTemplate();

  {
    Local<FunctionTemplate> w = NewFunctionTemplate(isolate, Worker::New);

    w->InstanceTemplate()->SetInternalFieldCount(
        Worker::kInternalFieldCount);
    w->Inherit(AsyncWrap::GetConstructorTemplate(isolate_data));

    SetProtoMethod(isolate, w, ""startThread"", Worker::StartThread);
    SetProtoMethod(isolate, w, ""stopThread"", Worker::StopThread);
    SetProtoMethod(isolate, w, ""hasRef"", Worker::HasRef);
    SetProtoMethod(isolate, w, ""ref"", Worker::Ref);
    SetProtoMethod(isolate, w, ""unref"", Worker::Unref);
    SetProtoMethod(isolate, w, ""getResourceLimits"", Worker::GetResourceLimits);
    SetProtoMethod(isolate, w, ""takeHeapSnapshot"", Worker::TakeHeapSnapshot);
    SetProtoMethod(isolate, w, ""loopIdleTime"", Worker::LoopIdleTime);
    SetProtoMethod(isolate, w, ""loopStartTime"", Worker::LoopStartTime);

    SetConstructorFunction(isolate, proto, ""Worker"",...",71,,903,3,,void
253802,BLOCK,4,,"{
    Local<FunctionTemplate> w = NewFunctionTemplate(isolate, Worker::New);

    w->InstanceTemplate()->SetInternalFieldCount(
        Worker::kInternalFieldCount);
    w->Inherit(AsyncWrap::GetConstructorTemplate(isolate_data));

    SetProtoMethod(isolate, w, ""startThread"", Worker::StartThread);
    SetProtoMethod(isolate, w, ""stopThread"", Worker::StopThread);
    SetProtoMethod(isolate, w, ""hasRef"", Worker::HasRef);
    SetProtoMethod(isolate, w, ""ref"", Worker::Ref);
    SetProtoMethod(isolate, w, ""unref"", Worker::Unref);
    SetProtoMethod(isolate, w, ""getResourceLimits"", Worker::GetResourceLimits);
    SetProtoMethod(isolate, w, ""takeHeapSnapshot"", Worker::TakeHeapSnapshot);
    SetProtoMethod(isolate, w, ""loopIdleTime"", Worker::LoopIdleTime);
    SetProtoMethod(isolate, w, ""loopStartTime"", Worker::LoopStartTime);

    SetConstructorFunction(isolate, proto, ""Worker"", w);
  }",3,,907,4,,void
253901,BLOCK,5,,"{
    Local<FunctionTemplate> wst = NewFunctionTemplate(isolate, nullptr);

    wst->InstanceTemplate()->SetInternalFieldCount(
        WorkerHeapSnapshotTaker::kInternalFieldCount);
    wst->Inherit(AsyncWrap::GetConstructorTemplate(isolate_data));

    Local<String> wst_string =
        FIXED_ONE_BYTE_STRING(isolate, ""WorkerHeapSnapshotTaker"");
    wst->SetClassName(wst_string);
    isolate_data->set_worker_heap_snapshot_taker_template(
        wst->InstanceTemplate());
  }",3,,927,5,,void
253964,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  target
      ->Set(env->context(),
            env->thread_id_string(),
            Number::New(isolate, static_cast<double>(env->thread_id())))
      .Check();

  target
      ->Set(env->context(),
            FIXED_ONE_BYTE_STRING(isolate, ""isMainThread""),
            Boolean::New(isolate, env->is_main_thread()))
      .Check();

  target
      ->Set(env->context(),
            FIXED_ONE_BYTE_STRING(isolate, ""ownsProcessState""),
            Boolean::New(isolate, env->owns_process_state()))
      .Check();

  if (!env->is_main_thread()) {
    target
        ->Set(env->context(),
              FIXED_ONE_BYTE_STRING(isolate, ""resourceLimits""),
              env->worker_context()->GetResourceLimits(isolate))
        .Check();
  }

  NODE_DEFINE_CONSTANT(target, kMaxYoungGenerationSizeMb);
  NODE_DEFINE_CONSTANT(target, kMaxOldGenerationSizeMb);
  NODE_DEFINE_CONSTANT(target, kCodeRangeSize...",51,,947,5,,void
254058,BLOCK,-1,,"{
    target
        ->Set(env->context(),
              FIXED_ONE_BYTE_STRING(isolate, ""resourceLimits""),
              env->worker_context()->GetResourceLimits(isolate))
        .Check();
  }",31,,969,2,,void
254086,BLOCK,1,,<empty>,,,,7,,void
254088,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kMaxYoungGenerationSizeMb)",3,,977,1,,void
254185,BLOCK,1,,<empty>,,,,7,,void
254187,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kMaxOldGenerationSizeMb)",3,,978,1,,void
254284,BLOCK,1,,<empty>,,,,7,,void
254286,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kCodeRangeSizeMb)",3,,979,1,,void
254383,BLOCK,1,,<empty>,,,,7,,void
254385,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kStackSizeMb)",3,,980,1,,void
254482,BLOCK,1,,<empty>,,,,7,,void
254484,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kTotalResourceLimitCount)",3,,981,1,,void
254580,BLOCK,-1,,"{
  registry->Register(GetEnvMessagePort);
  registry->Register(Worker::New);
  registry->Register(Worker::StartThread);
  registry->Register(Worker::StopThread);
  registry->Register(Worker::HasRef);
  registry->Register(Worker::Ref);
  registry->Register(Worker::Unref);
  registry->Register(Worker::GetResourceLimits);
  registry->Register(Worker::TakeHeapSnapshot);
  registry->Register(Worker::LoopIdleTime);
  registry->Register(Worker::LoopStartTime);
}",70,,984,2,,void
254673,BLOCK,-1,,<empty>,1,,1,1,,ANY
254676,BLOCK,-1,,{ Unref(); },46,,405,1,,void
254719,BLOCK,-1,,<empty>,1,,1,1,,ANY
254724,BLOCK,-1,,"{
#define V(code) if (err == code) return #code;
  ZLIB_ERROR_CODES(V)
#undef V
  return ""Z_UNKNOWN_ERROR"";
}",42,,90,2,,void
254726,BLOCK,1,,<empty>,,,,1,,void
254731,BLOCK,-1,,<empty>,3,,92,2,,void
254738,BLOCK,-1,,<empty>,3,,92,2,,void
254745,BLOCK,-1,,<empty>,3,,92,2,,void
254752,BLOCK,-1,,<empty>,3,,92,2,,void
254759,BLOCK,-1,,<empty>,3,,92,2,,void
254766,BLOCK,-1,,<empty>,3,,92,2,,void
254773,BLOCK,-1,,<empty>,3,,92,2,,void
254780,BLOCK,-1,,<empty>,3,,92,2,,void
254787,BLOCK,-1,,<empty>,3,,92,2,,void
254818,BLOCK,-1,,"{
    CHECK_NOT_NULL(message);
  }",18,,117,4,,void
254824,BLOCK,-1,,<empty>,,,,1,,<empty>
254831,BLOCK,-1,,{ return code != nullptr; },31,,127,1,,void
254839,BLOCK,-1,,<empty>,,,,1,,<empty>
254853,BLOCK,-1,,<empty>,,,,1,,<empty>
254857,BLOCK,-1,,<empty>,,,,1,,<empty>
254861,BLOCK,-1,,<empty>,,,,1,,<empty>
254869,BLOCK,-1,,<empty>,,,,5,,<empty>
254874,BLOCK,-1,,<empty>,,,,2,,<empty>
254880,BLOCK,-1,,<empty>,,,,3,,<empty>
254884,BLOCK,-1,,<empty>,,,,1,,<empty>
254889,BLOCK,-1,,{ mode_ = mode; },44,,141,2,,void
254896,BLOCK,-1,,<empty>,,,,1,,<empty>
254905,BLOCK,-1,,<empty>,,,,6,,<empty>
254912,BLOCK,-1,,<empty>,,,,4,,<empty>
254918,BLOCK,-1,,<empty>,,,,3,,<empty>
254927,BLOCK,-1,,"{
    tracker->TrackField(""dictionary"", dictionary_);
  }",58,,153,2,,void
254938,BLOCK,-1,,<empty>,,,,2,,<empty>
254943,BLOCK,-1,,<empty>,,,,2,,<empty>
254948,BLOCK,-1,,<empty>,,,,2,,<empty>
254952,BLOCK,-1,,<empty>,,,,1,,<empty>
254956,BLOCK,-1,,<empty>,,,,1,,<empty>
254972,BLOCK,-1,,<empty>,,,,1,,<empty>
255004,BLOCK,-1,,<empty>,,,,1,,<empty>
255012,BLOCK,-1,,<empty>,,,,5,,<empty>
255017,BLOCK,-1,,<empty>,,,,2,,<empty>
255023,BLOCK,-1,,<empty>,,,,3,,<empty>
255028,BLOCK,-1,,{ mode_ = mode; },44,,189,2,,void
255036,BLOCK,-1,,<empty>,,,,2,,<empty>
255041,BLOCK,-1,,<empty>,,,,2,,<empty>
255054,BLOCK,-1,,<empty>,,,,1,,<empty>
255086,BLOCK,-1,,<empty>,,,,1,,<empty>
255090,BLOCK,-1,,<empty>,,,,1,,<empty>
255097,BLOCK,-1,,<empty>,,,,4,,<empty>
255101,BLOCK,-1,,<empty>,,,,1,,<empty>
255107,BLOCK,-1,,<empty>,,,,3,,<empty>
255111,BLOCK,-1,,<empty>,,,,1,,<empty>
255122,BLOCK,-1,,<empty>,,,,1,,<empty>
255126,BLOCK,-1,,<empty>,,,,1,,<empty>
255133,BLOCK,-1,,<empty>,,,,4,,<empty>
255137,BLOCK,-1,,<empty>,,,,1,,<empty>
255143,BLOCK,-1,,<empty>,,,,3,,<empty>
255147,BLOCK,-1,,<empty>,,,,1,,<empty>
255159,BLOCK,-1,,<empty>,,,,1,,<empty>
255170,BLOCK,-1,,<empty>,,,,1,,<empty>
255181,BLOCK,-1,,"{
    MakeWeak();
  }",32,,263,3,,void
255186,BLOCK,-1,,"{
    CHECK(!write_in_progress_);
    Close();
    CHECK_EQ(zlib_memory_, 0);
    CHECK_EQ(unreported_allocations_, 0);
  }",33,,267,1,,void
255200,BLOCK,-1,,"{
    if (write_in_progress_) {
      pending_close_ = true;
      return;
    }

    pending_close_ = false;
    closed_ = true;
    CHECK(init_done_ && ""close before init"");

    AllocScope alloc_scope(this);
    ctx_.Close();
  }",16,,274,1,,void
255203,BLOCK,-1,,"{
      pending_close_ = true;
      return;
    }",29,,275,2,,void
255229,BLOCK,-1,,"{
    CompressionStream* ctx;
    ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());
    ctx->Close();
  }",62,,289,2,,void
255246,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(args);
    Local<Context> context = env->context();
    CHECK_EQ(args.Length(), 7);

    uint32_t in_off, in_len, out_off, out_len, flush;
    const char* in;
    char* out;

    CHECK_EQ(false, args[0]->IsUndefined() && ""must provide flush value"");
    if (!args[0]->Uint32Value(context).To(&flush)) return;

    if (flush != Z_NO_FLUSH &&
        flush != Z_PARTIAL_FLUSH &&
        flush != Z_SYNC_FLUSH &&
        flush != Z_FULL_FLUSH &&
        flush != Z_FINISH &&
        flush != Z_BLOCK) {
      UNREACHABLE(""Invalid flush value"");
    }

    if (args[1]->IsNull()) {
      // just a flush
      in = nullptr;
      in_len = 0;
      in_off = 0;
    } else {
      CHECK(Buffer::HasInstance(args[1]));
      Local<Object> in_buf = args[1].As<Object>();
      if (!args[2]->Uint32Value(context).To(&in_off)) return;
      if (!args[3]->Uint32Value(context).To(&in_len)) return;

      CHECK(Buffer::IsWithinBounds(in_off, in_len, Buffer::L...",62,,298,2,,void
255302,BLOCK,-1,,<empty>,52,,308,2,,void
255328,BLOCK,-1,,"{
      UNREACHABLE(""Invalid flush value"");
    }",27,,315,2,,void
255338,BLOCK,-1,,"{
      // just a flush
      in = nullptr;
      in_len = 0;
      in_off = 0;
    }",28,,319,2,,void
255349,BLOCK,-1,,"{
      CHECK(Buffer::HasInstance(args[1]));
      Local<Object> in_buf = args[1].As<Object>();
      if (!args[2]->Uint32Value(context).To(&in_off)) return;
      if (!args[3]->Uint32Value(context).To(&in_len)) return;

      CHECK(Buffer::IsWithinBounds(in_off, in_len, Buffer::Length(in_buf)));
      in = Buffer::Data(in_buf) + in_off;
    }",12,,324,1,,void
255384,BLOCK,-1,,<empty>,55,,327,2,,void
255400,BLOCK,-1,,<empty>,55,,328,2,,void
255457,BLOCK,-1,,<empty>,54,,336,2,,void
255473,BLOCK,-1,,<empty>,54,,337,2,,void
255521,BLOCK,-1,,"{
    AllocScope alloc_scope(this);

    CHECK(init_done_ && ""write before init"");
    CHECK(!closed_ && ""already finalized"");

    CHECK_EQ(false, write_in_progress_);
    CHECK_EQ(false, pending_close_);
    write_in_progress_ = true;
    Ref();

    ctx_.SetBuffers(in, in_len, out, out_len);
    ctx_.SetFlush(flush);

    if constexpr (!async) {
      // sync version
      AsyncWrap::env()->PrintSyncTrace();
      DoThreadPoolWork();
      if (CheckError()) {
        UpdateWriteResult();
        write_in_progress_ = false;
      }
      Unref();
      return;
    }

    // async version
    ScheduleWork();
  }",43,,350,6,,void
255560,BLOCK,-1,,"{
      // sync version
      AsyncWrap::env()->PrintSyncTrace();
      DoThreadPoolWork();
      if (CheckError()) {
        UpdateWriteResult();
        write_in_progress_ = false;
      }
      Unref();
      return;
    }",27,,364,2,,void
255571,BLOCK,-1,,"{
        UpdateWriteResult();
        write_in_progress_ = false;
      }",25,,368,2,,void
255582,BLOCK,-1,,"{
    ctx_.GetAfterWriteOffsets(&write_result_[1], &write_result_[0]);
  }",28,,380,1,,void
255598,BLOCK,-1,,"{
    ctx_.DoThreadPoolWork();
  }",36,,388,1,,void
255606,BLOCK,-1,,"{
    const CompressionError err = ctx_.GetErrorInfo();
    if (!err.IsError()) return true;
    EmitError(err);
    return false;
  }",21,,393,1,,void
255620,BLOCK,-1,,<empty>,25,,395,2,,void
255631,BLOCK,-1,,"{
    DCHECK(init_done_);
    AllocScope alloc_scope(this);
    auto on_scope_leave = OnScopeLeave([&]() { Unref(); });

    write_in_progress_ = false;

    if (status == UV_ECANCELED) {
      Close();
      return;
    }

    CHECK_EQ(status, 0);

    Environment* env = AsyncWrap::env();
    HandleScope handle_scope(env->isolate());
    Context::Scope context_scope(env->context());

    if (!CheckError())
      return;

    UpdateWriteResult();

    // call the write() cb
    Local<Value> cb = object()->GetInternalField(kWriteJSCallback);
    MakeCallback(cb.As<Function>(), 0, nullptr);

    if (pending_close_)
      Close();
  }",49,,402,2,,void
255649,BLOCK,-1,,"{
      Close();
      return;
    }",33,,409,2,,void
255677,BLOCK,-1,,<empty>,7,,421,2,,void
255700,BLOCK,-1,,<empty>,7,,430,2,,void
255706,BLOCK,-1,,"{
    Environment* env = AsyncWrap::env();
    // If you hit this assertion, you forgot to enter the v8::Context first.
    CHECK_EQ(env->context(), env->isolate()->GetCurrentContext());

    HandleScope scope(env->isolate());
    Local<Value> args[] = {
      OneByteString(env->isolate(), err.message),
      Integer::New(env->isolate(), err.err),
      OneByteString(env->isolate(), err.code)
    };
    MakeCallback(env->onerror_string(), arraysize(args), args);

    // no hope of rescue.
    write_in_progress_ = false;
    if (pending_close_)
      Close();
  }",47,,434,2,,void
255776,BLOCK,-1,,<empty>,7,,450,2,,void
255782,BLOCK,-1,,"{
    CompressionStream* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

    AllocScope alloc_scope(wrap);
    const CompressionError err = wrap->context()->ResetStream();
    if (err.IsError())
      wrap->EmitError(err);
  }",62,,453,2,,void
255809,BLOCK,-1,,<empty>,7,,460,2,,void
255819,BLOCK,-1,,"{
    tracker->TrackField(""compression context"", ctx_);
    tracker->TrackFieldWithSize(""zlib_memory"",
                                zlib_memory_ + unreported_allocations_);
  }",58,,463,2,,void
255837,BLOCK,-1,,{ return &ctx_; },33,,470,1,,void
255846,BLOCK,-1,,"{
    write_result_ = write_result;
    object()->SetInternalField(kWriteJSCallback, write_js_callback);
    init_done_ = true;
  }",78,,472,3,,void
255865,BLOCK,-1,,"{
    size_t real_size =
        MultiplyWithOverflowCheck(static_cast<size_t>(items),
                                  static_cast<size_t>(size));
    return AllocForBrotli(data, real_size);
  }",64,,484,4,,void
255885,BLOCK,-1,,"{
    size += sizeof(size_t);
    CompressionStream* ctx = static_cast<CompressionStream*>(data);
    char* memory = UncheckedMalloc(size);
    if (UNLIKELY(memory == nullptr)) return nullptr;
    *reinterpret_cast<size_t*>(memory) = size;
    ctx->unreported_allocations_.fetch_add(size,
                                           std::memory_order_relaxed);
    return memory + sizeof(size_t);
  }",56,,491,3,,void
255906,BLOCK,-1,,<empty>,38,,495,2,,void
255935,BLOCK,-1,,"{
    if (UNLIKELY(pointer == nullptr)) return;
    CompressionStream* ctx = static_cast<CompressionStream*>(data);
    char* real_pointer = static_cast<char*>(pointer) - sizeof(size_t);
    size_t real_size = *reinterpret_cast<size_t*>(real_pointer);
    ctx->unreported_allocations_.fetch_sub(real_size,
                                           std::memory_order_relaxed);
    free(real_pointer);
  }",54,,502,3,,void
255941,BLOCK,-1,,<empty>,39,,503,2,,void
255980,BLOCK,-1,,"{
    ssize_t report =
        unreported_allocations_.exchange(0, std::memory_order_relaxed);
    if (report == 0) return;
    CHECK_IMPLIES(report < 0, zlib_memory_ >= static_cast<size_t>(-report));
    zlib_memory_ += report;
    AsyncWrap::env()->isolate()->AdjustAmountOfExternalAllocatedMemory(report);
  }",48,,514,1,,void
255996,BLOCK,-1,,<empty>,22,,517,2,,void
256027,BLOCK,-1,,<empty>,69,,524,2,,void
256031,BLOCK,-1,,{ stream->AdjustAmountOfExternalAllocatedMemory(); },19,,525,1,,void
256040,BLOCK,-1,,"{
    if (++refs_ == 1) {
      ClearWeak();
    }
  }",14,,530,1,,void
256046,BLOCK,-1,,"{
      ClearWeak();
    }",23,,531,2,,void
256051,BLOCK,-1,,"{
    CHECK_GT(refs_, 0);
    if (--refs_ == 0) {
      MakeWeak();
    }
  }",16,,536,1,,void
256060,BLOCK,-1,,"{
      MakeWeak();
    }",23,,538,2,,void
256074,BLOCK,-1,,<empty>,,,,1,,<empty>
256107,BLOCK,-1,,"{
    context()->SetMode(mode);
  }",36,,558,4,,void
256117,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(args);
    CHECK(args[0]->IsInt32());
    node_zlib_mode mode =
        static_cast<node_zlib_mode>(args[0].As<Int32>()->Value());
    new ZlibStream(env, args.This(), mode);
  }",60,,562,2,,void
256159,BLOCK,-1,,"{
    // Refs: https://github.com/nodejs/node/issues/16649
    // Refs: https://github.com/nodejs/node/issues/14161
    if (args.Length() == 5) {
      fprintf(stderr,
          ""WARNING: You are likely using a version of node-tar or npm that ""
          ""is incompatible with this version of Node.js.\nPlease use ""
          ""either the version of npm that is bundled with Node.js, or ""
          ""a version of npm (> 5.5.1 or < 5.4.0) or node-tar (> 4.0.1) ""
          ""that is compatible with Node.js 9 and above.\n"");
    }
    CHECK(args.Length() == 7 &&
      ""init(windowBits, level, memLevel, strategy, writeResult, writeCallback,""
      "" dictionary)"");

    ZlibStream* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

    Local<Context> context = args.GetIsolate()->GetCurrentContext();

    // windowBits is special. On the compression side, 0 is an invalid value.
    // But on the decompression side, a value of 0 for windowBits tells zlib
    // to use the window size in t...",61,,571,2,,void
256167,BLOCK,-1,,"{
      fprintf(stderr,
          ""WARNING: You are likely using a version of node-tar or npm that ""
          ""is incompatible with this version of Node.js.\nPlease use ""
          ""either the version of npm that is bundled with Node.js, or ""
          ""a version of npm (> 5.5.1 or < 5.4.0) or node-tar (> 4.0.1) ""
          ""that is compatible with Node.js 9 and above.\n"");
    }",29,,574,2,,void
256216,BLOCK,-1,,<empty>,58,,595,2,,void
256233,BLOCK,-1,,<empty>,51,,598,2,,void
256250,BLOCK,-1,,<empty>,56,,601,2,,void
256267,BLOCK,-1,,<empty>,55,,604,2,,void
256335,BLOCK,-1,,"{
      unsigned char* data =
          reinterpret_cast<unsigned char*>(Buffer::Data(args[6]));
      dictionary = std::vector<unsigned char>(
          data,
          data + Buffer::Length(args[6]));
    }",39,,615,2,,void
256405,BLOCK,-1,,"{
    CHECK(args.Length() == 2 && ""params(level, strategy)"");
    ZlibStream* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
    Local<Context> context = args.GetIsolate()->GetCurrentContext();
    int level;
    if (!args[0]->Int32Value(context).To(&level)) return;
    int strategy;
    if (!args[1]->Int32Value(context).To(&strategy)) return;

    AllocScope alloc_scope(wrap);
    const CompressionError err = wrap->context()->SetParams(level, strategy);
    if (err.IsError())
      wrap->EmitError(err);
  }",63,,632,2,,void
256451,BLOCK,-1,,<empty>,51,,638,2,,void
256468,BLOCK,-1,,<empty>,54,,640,2,,void
256490,BLOCK,-1,,<empty>,7,,645,2,,void
256507,BLOCK,-1,,"{
    context()->SetMode(mode);
  }",56,,659,4,,void
256516,BLOCK,-1,,"{
    return this->CompressionStream<CompressionContext>::context();
  }",40,,663,1,,void
256527,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(args);
    CHECK(args[0]->IsInt32());
    node_zlib_mode mode =
        static_cast<node_zlib_mode>(args[0].As<Int32>()->Value());
    new BrotliCompressionStream(env, args.This(), mode);
  }",60,,668,2,,void
256569,BLOCK,-1,,"{
    BrotliCompressionStream* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
    CHECK(args.Length() == 3 && ""init(params, writeResult, writeCallback)"");

    CHECK(args[1]->IsUint32Array());
    uint32_t* write_result = reinterpret_cast<uint32_t*>(Buffer::Data(args[1]));

    CHECK(args[2]->IsFunction());
    Local<Function> write_js_callback = args[2].As<Function>();
    wrap->InitStream(write_result, write_js_callback);

    AllocScope alloc_scope(wrap);
    CompressionError err =
        wrap->context()->Init(
          CompressionStream<CompressionContext>::AllocForBrotli,
          CompressionStream<CompressionContext>::FreeForZlib,
          static_cast<CompressionStream<CompressionContext>*>(wrap));
    if (err.IsError()) {
      wrap->EmitError(err);
      args.GetReturnValue().Set(false);
      return;
    }

    CHECK(args[0]->IsUint32Array());
    const uint32_t* data = reinterpret_cast<uint32_t*>(Buffer::Data(args[0]));
    size_t len = args[0].As<Uint32Array...",61,,676,2,,void
256660,BLOCK,-1,,"{
      wrap->EmitError(err);
      args.GetReturnValue().Set(false);
      return;
    }",24,,694,2,,void
256707,BLOCK,-1,,<empty>,5,,704,1,,void
256719,BLOCK,4,,"{
      if (data[i] == static_cast<uint32_t>(-1))
        continue;
      err = wrap->context()->SetParams(i, data[i]);
      if (err.IsError()) {
        wrap->EmitError(err);
        args.GetReturnValue().Set(false);
        return;
      }
    }",56,,704,4,,void
256729,BLOCK,-1,,<empty>,9,,706,2,,void
256749,BLOCK,-1,,"{
        wrap->EmitError(err);
        args.GetReturnValue().Set(false);
        return;
      }",26,,708,2,,void
256776,BLOCK,-1,,"{
    // Currently a no-op, and not accessed from JS land.
    // At some point Brotli may support changing parameters on the fly,
    // in which case we can implement this and a JS equivalent similar to
    // the zlib Params() function.
  }",63,,718,2,,void
256786,BLOCK,-1,,"{
  {
    Mutex::ScopedLock lock(mutex_);
    if (!zlib_init_done_) {
      dictionary_.clear();
      mode_ = NONE;
      return;
    }
  }

  CHECK_LE(mode_, UNZIP);

  int status = Z_OK;
  if (mode_ == DEFLATE || mode_ == GZIP || mode_ == DEFLATERAW) {
    status = deflateEnd(&strm_);
  } else if (mode_ == INFLATE || mode_ == GUNZIP || mode_ == INFLATERAW ||
             mode_ == UNZIP) {
    status = inflateEnd(&strm_);
  }

  CHECK(status == Z_OK || status == Z_DATA_ERROR);
  mode_ = NONE;

  dictionary_.clear();
}",27,,732,1,,void
256787,BLOCK,1,,"{
    Mutex::ScopedLock lock(mutex_);
    if (!zlib_init_done_) {
      dictionary_.clear();
      mode_ = NONE;
      return;
    }
  }",3,,733,1,,void
256794,BLOCK,-1,,"{
      dictionary_.clear();
      mode_ = NONE;
      return;
    }",27,,735,2,,void
256822,BLOCK,-1,,"{
    status = deflateEnd(&strm_);
  }",65,,745,2,,void
256829,BLOCK,-1,,<empty>,10,,747,1,,void
256846,BLOCK,-1,,"{
    status = inflateEnd(&strm_);
  }",30,,748,2,,void
256870,BLOCK,-1,,"{
  bool first_init_call = InitZlib();
  if (first_init_call && err_ != Z_OK) {
    return;
  }

  const Bytef* next_expected_header_byte = nullptr;

  // If the avail_out is left at 0, then it means that it ran out
  // of room.  If there was avail_out left over, then it means
  // that all of the input was consumed.
  switch (mode_) {
    case DEFLATE:
    case GZIP:
    case DEFLATERAW:
      err_ = deflate(&strm_, flush_);
      break;
    case UNZIP:
      if (strm_.avail_in > 0) {
        next_expected_header_byte = strm_.next_in;
      }

      switch (gzip_id_bytes_read_) {
        case 0:
          if (next_expected_header_byte == nullptr) {
            break;
          }

          if (*next_expected_header_byte == GZIP_HEADER_ID1) {
            gzip_id_bytes_read_ = 1;
            next_expected_header_byte++;

            if (strm_.avail_in == 1) {
              // The only available byte was already read.
              break;
            }
          } else {
            ...",38,,759,1,,void
256881,BLOCK,-1,,"{
    return;
  }",40,,761,2,,void
256889,BLOCK,-1,,"{
    case DEFLATE:
    case GZIP:
    case DEFLATERAW:
      err_ = deflate(&strm_, flush_);
      break;
    case UNZIP:
      if (strm_.avail_in > 0) {
        next_expected_header_byte = strm_.next_in;
      }

      switch (gzip_id_bytes_read_) {
        case 0:
          if (next_expected_header_byte == nullptr) {
            break;
          }

          if (*next_expected_header_byte == GZIP_HEADER_ID1) {
            gzip_id_bytes_read_ = 1;
            next_expected_header_byte++;

            if (strm_.avail_in == 1) {
              // The only available byte was already read.
              break;
            }
          } else {
            mode_ = INFLATE;
            break;
          }

          [[fallthrough]];
        case 1:
          if (next_expected_header_byte == nullptr) {
            break;
          }

          if (*next_expected_header_byte == GZIP_HEADER_ID2) {
            gzip_id_bytes_read_ = 2;
            mode_ = GUNZIP;
          } else {
            ...",18,,770,2,,void
256911,BLOCK,-1,,"{
        next_expected_header_byte = strm_.next_in;
      }",31,,777,2,,void
256919,BLOCK,-1,,"{
        case 0:
          if (next_expected_header_byte == nullptr) {
            break;
          }

          if (*next_expected_header_byte == GZIP_HEADER_ID1) {
            gzip_id_bytes_read_ = 1;
            next_expected_header_byte++;

            if (strm_.avail_in == 1) {
              // The only available byte was already read.
              break;
            }
          } else {
            mode_ = INFLATE;
            break;
          }

          [[fallthrough]];
        case 1:
          if (next_expected_header_byte == nullptr) {
            break;
          }

          if (*next_expected_header_byte == GZIP_HEADER_ID2) {
            gzip_id_bytes_read_ = 2;
            mode_ = GUNZIP;
          } else {
            // There is no actual difference between INFLATE and INFLATERAW
            // (after initialization).
            mode_ = INFLATE;
          }

          break;
        default:
          UNREACHABLE(""invalid number of gzip magic number bytes read"")...",36,,781,2,,void
256926,BLOCK,-1,,"{
            break;
          }",53,,783,2,,void
256933,BLOCK,-1,,"{
            gzip_id_bytes_read_ = 1;
            next_expected_header_byte++;

            if (strm_.avail_in == 1) {
              // The only available byte was already read.
              break;
            }
          }",62,,787,2,,void
256945,BLOCK,-1,,"{
              // The only available byte was already read.
              break;
            }",38,,791,2,,void
256948,BLOCK,-1,,"{
            mode_ = INFLATE;
            break;
          }",18,,795,1,,void
256959,BLOCK,-1,,"{
            break;
          }",53,,802,2,,void
256966,BLOCK,-1,,"{
            gzip_id_bytes_read_ = 2;
            mode_ = GUNZIP;
          }",62,,806,2,,void
256974,BLOCK,-1,,"{
            // There is no actual difference between INFLATE and INFLATERAW
            // (after initialization).
            mode_ = INFLATE;
          }",18,,809,1,,void
257008,BLOCK,-1,,"{
        // Load it
        err_ = inflateSetDictionary(&strm_,
                                    dictionary_.data(),
                                    dictionary_.size());
        if (err_ == Z_OK) {
          // And try to decode again
          err_ = inflate(&strm_, flush_);
        } else if (err_ == Z_DATA_ERROR) {
          // Both inflateSetDictionary() and inflate() return Z_DATA_ERROR.
          // Make it possible for After() to tell a bad dictionary from bad
          // input.
          err_ = Z_NEED_DICT;
        }
      }",33,,830,2,,void
257026,BLOCK,-1,,"{
          // And try to decode again
          err_ = inflate(&strm_, flush_);
        }",27,,835,2,,void
257034,BLOCK,-1,,<empty>,16,,838,1,,void
257039,BLOCK,-1,,"{
          // Both inflateSetDictionary() and inflate() return Z_DATA_ERROR.
          // Make it possible for After() to tell a bad dictionary from bad
          // input.
          err_ = Z_NEED_DICT;
        }",42,,838,2,,void
257065,BLOCK,-1,,"{
        // Bytes remain in input buffer. Perhaps this is another compressed
        // member in the same archive, or just trailing garbage.
        // Trailing zero bytes are okay, though, since they are frequently
        // used for padding.

        ResetStream();
        err_ = inflate(&strm_, flush_);
      }",40,,849,2,,void
257083,BLOCK,-1,,"{
  strm_.avail_in = in_len;
  strm_.next_in = const_cast<Bytef*>(reinterpret_cast<const Bytef*>(in));
  strm_.avail_out = out_len;
  strm_.next_out = reinterpret_cast<Bytef*>(out);
}",59,,866,5,,void
257114,BLOCK,-1,,"{
  flush_ = flush;
}",39,,874,2,,void
257123,BLOCK,-1,,"{
  *avail_in = strm_.avail_in;
  *avail_out = strm_.avail_out;
}",67,,880,3,,void
257140,BLOCK,-1,,"{
  if (strm_.msg != nullptr)
    message = strm_.msg;

  return CompressionError { message, ZlibStrerror(err_), err_ };
}",74,,886,2,,void
257147,BLOCK,-1,,<empty>,5,,888,2,,void
257163,BLOCK,-1,,"{
  // Acceptable error states depend on the type of zlib stream.
  switch (err_) {
  case Z_OK:
  case Z_BUF_ERROR:
    if (strm_.avail_out != 0 && flush_ == Z_FINISH) {
      return ErrorForMessage(""unexpected end of file"");
    }
  case Z_STREAM_END:
    // normal statuses, not fatal
    break;
  case Z_NEED_DICT:
    if (dictionary_.empty())
      return ErrorForMessage(""Missing dictionary"");
    else
      return ErrorForMessage(""Bad dictionary"");
  default:
    // something else.
    return ErrorForMessage(""Zlib error"");
  }

  return CompressionError {};
}",52,,894,1,,void
257166,BLOCK,-1,,"{
  case Z_OK:
  case Z_BUF_ERROR:
    if (strm_.avail_out != 0 && flush_ == Z_FINISH) {
      return ErrorForMessage(""unexpected end of file"");
    }
  case Z_STREAM_END:
    // normal statuses, not fatal
    break;
  case Z_NEED_DICT:
    if (dictionary_.empty())
      return ErrorForMessage(""Missing dictionary"");
    else
      return ErrorForMessage(""Bad dictionary"");
  default:
    // something else.
    return ErrorForMessage(""Zlib error"");
  }",17,,896,2,,void
257181,BLOCK,-1,,"{
      return ErrorForMessage(""unexpected end of file"");
    }",53,,899,2,,void
257195,BLOCK,-1,,<empty>,7,,907,2,,void
257200,BLOCK,-1,,<empty>,7,,909,1,,void
257214,BLOCK,-1,,"{
  bool first_init_call = InitZlib();
  if (first_init_call && err_ != Z_OK) {
    return ErrorForMessage(""Failed to init stream before reset"");
  }

  err_ = Z_OK;

  switch (mode_) {
    case DEFLATE:
    case DEFLATERAW:
    case GZIP:
      err_ = deflateReset(&strm_);
      break;
    case INFLATE:
    case INFLATERAW:
    case GUNZIP:
      err_ = inflateReset(&strm_);
      break;
    default:
      break;
  }

  if (err_ != Z_OK)
    return ErrorForMessage(""Failed to reset stream"");

  return SetDictionary();
}",45,,919,1,,void
257225,BLOCK,-1,,"{
    return ErrorForMessage(""Failed to init stream before reset"");
  }",40,,921,2,,void
257234,BLOCK,-1,,"{
    case DEFLATE:
    case DEFLATERAW:
    case GZIP:
      err_ = deflateReset(&strm_);
      break;
    case INFLATE:
    case INFLATERAW:
    case GUNZIP:
      err_ = inflateReset(&strm_);
      break;
    default:
      break;
  }",18,,927,2,,void
257265,BLOCK,-1,,<empty>,5,,943,2,,void
257277,BLOCK,-1,,"{
  strm_.zalloc = alloc;
  strm_.zfree = free;
  strm_.opaque = opaque;
}",56,,951,4,,void
257301,BLOCK,-1,,"{
  if (!((window_bits == 0) &&
        (mode_ == INFLATE ||
         mode_ == GUNZIP ||
         mode_ == UNZIP))) {
    CHECK(
        (window_bits >= Z_MIN_WINDOWBITS && window_bits <= Z_MAX_WINDOWBITS) &&
        ""invalid windowBits"");
  }

  CHECK((level >= Z_MIN_LEVEL && level <= Z_MAX_LEVEL) &&
    ""invalid compression level"");

  CHECK((mem_level >= Z_MIN_MEMLEVEL && mem_level <= Z_MAX_MEMLEVEL) &&
        ""invalid memlevel"");

  CHECK((strategy == Z_FILTERED || strategy == Z_HUFFMAN_ONLY ||
         strategy == Z_RLE || strategy == Z_FIXED ||
         strategy == Z_DEFAULT_STRATEGY) &&
        ""invalid strategy"");

  level_ = level;
  window_bits_ = window_bits;
  mem_level_ = mem_level;
  strategy_ = strategy;

  flush_ = Z_NO_FLUSH;

  err_ = Z_OK;

  if (mode_ == GZIP || mode_ == GUNZIP) {
    window_bits_ += 16;
  }

  if (mode_ == UNZIP) {
    window_bits_ += 32;
  }

  if (mode_ == DEFLATERAW || mode_ == INFLATERAW) {
    window_bits_ *= -1;
  }

  dictionary_ = std::...",46,,960,6,,void
257319,BLOCK,-1,,"{
    CHECK(
        (window_bits >= Z_MIN_WINDOWBITS && window_bits <= Z_MAX_WINDOWBITS) &&
        ""invalid windowBits"");
  }",28,,964,2,,void
257326,BLOCK,1,,<empty>,,,,1,,void
257331,BLOCK,1,,<empty>,,,,1,,void
257340,BLOCK,1,,<empty>,,,,1,,void
257346,BLOCK,1,,<empty>,,,,1,,void
257355,BLOCK,1,,<empty>,,,,1,,void
257360,BLOCK,1,,<empty>,,,,1,,void
257411,BLOCK,-1,,"{
    window_bits_ += 16;
  }",41,,990,2,,void
257419,BLOCK,-1,,"{
    window_bits_ += 32;
  }",23,,994,2,,void
257431,BLOCK,-1,,"{
    window_bits_ *= -1;
  }",51,,998,2,,void
257446,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  if (zlib_init_done_) {
    return false;
  }

  switch (mode_) {
    case DEFLATE:
    case GZIP:
    case DEFLATERAW:
      err_ = deflateInit2(&strm_,
                          level_,
                          Z_DEFLATED,
                          window_bits_,
                          mem_level_,
                          strategy_);
      break;
    case INFLATE:
    case GUNZIP:
    case INFLATERAW:
    case UNZIP:
      err_ = inflateInit2(&strm_, window_bits_);
      break;
    default:
      UNREACHABLE();
  }

  if (err_ != Z_OK) {
    dictionary_.clear();
    mode_ = NONE;
    return true;
  }

  SetDictionary();
  zlib_init_done_ = true;
  return true;
}",30,,1005,1,,void
257452,BLOCK,-1,,"{
    return false;
  }",24,,1007,2,,void
257457,BLOCK,-1,,"{
    case DEFLATE:
    case GZIP:
    case DEFLATERAW:
      err_ = deflateInit2(&strm_,
                          level_,
                          Z_DEFLATED,
                          window_bits_,
                          mem_level_,
                          strategy_);
      break;
    case INFLATE:
    case GUNZIP:
    case INFLATERAW:
    case UNZIP:
      err_ = inflateInit2(&strm_, window_bits_);
      break;
    default:
      UNREACHABLE();
  }",18,,1011,2,,void
257496,BLOCK,-1,,"{
    dictionary_.clear();
    mode_ = NONE;
    return true;
  }",21,,1032,2,,void
257515,BLOCK,-1,,"{
  if (dictionary_.empty())
    return CompressionError {};

  err_ = Z_OK;

  switch (mode_) {
    case DEFLATE:
    case DEFLATERAW:
      err_ = deflateSetDictionary(&strm_,
                                  dictionary_.data(),
                                  dictionary_.size());
      break;
    case INFLATERAW:
      // The other inflate cases will have the dictionary set when inflate()
      // returns Z_NEED_DICT in Process()
      err_ = inflateSetDictionary(&strm_,
                                  dictionary_.data(),
                                  dictionary_.size());
      break;
    default:
      break;
  }

  if (err_ != Z_OK) {
    return ErrorForMessage(""Failed to set dictionary"");
  }

  return CompressionError {};
}",47,,1044,1,,void
257521,BLOCK,-1,,<empty>,5,,1046,2,,void
257530,BLOCK,-1,,"{
    case DEFLATE:
    case DEFLATERAW:
      err_ = deflateSetDictionary(&strm_,
                                  dictionary_.data(),
                                  dictionary_.size());
      break;
    case INFLATERAW:
      // The other inflate cases will have the dictionary set when inflate()
      // returns Z_NEED_DICT in Process()
      err_ = inflateSetDictionary(&strm_,
                                  dictionary_.data(),
                                  dictionary_.size());
      break;
    default:
      break;
  }",18,,1050,2,,void
257571,BLOCK,-1,,"{
    return ErrorForMessage(""Failed to set dictionary"");
  }",21,,1068,2,,void
257583,BLOCK,-1,,"{
  bool first_init_call = InitZlib();
  if (first_init_call && err_ != Z_OK) {
    return ErrorForMessage(""Failed to init stream before set parameters"");
  }

  err_ = Z_OK;

  switch (mode_) {
    case DEFLATE:
    case DEFLATERAW:
      err_ = deflateParams(&strm_, level, strategy);
      break;
    default:
      break;
  }

  if (err_ != Z_OK && err_ != Z_BUF_ERROR) {
    return ErrorForMessage(""Failed to set parameters"");
  }

  return CompressionError {};
}",66,,1076,3,,void
257594,BLOCK,-1,,"{
    return ErrorForMessage(""Failed to init stream before set parameters"");
  }",40,,1078,2,,void
257603,BLOCK,-1,,"{
    case DEFLATE:
    case DEFLATERAW:
      err_ = deflateParams(&strm_, level, strategy);
      break;
    default:
      break;
  }",18,,1084,2,,void
257626,BLOCK,-1,,"{
    return ErrorForMessage(""Failed to set parameters"");
  }",44,,1093,2,,void
257640,BLOCK,-1,,"{
  next_in_ = reinterpret_cast<const uint8_t*>(in);
  next_out_ = reinterpret_cast<uint8_t*>(out);
  avail_in_ = in_len;
  avail_out_ = out_len;
}",61,,1102,5,,void
257661,BLOCK,-1,,"{
  flush_ = static_cast<BrotliEncoderOperation>(flush);
}",41,,1110,2,,void
257672,BLOCK,-1,,"{
  *avail_in = avail_in_;
  *avail_out = avail_out_;
}",69,,1116,3,,void
257684,BLOCK,-1,,"{
  CHECK_EQ(mode_, BROTLI_ENCODE);
  CHECK(state_);
  const uint8_t* next_in = next_in_;
  last_result_ = BrotliEncoderCompressStream(state_.get(),
                                             flush_,
                                             &avail_in_,
                                             &next_in,
                                             &avail_out_,
                                             &next_out_,
                                             nullptr);
  next_in_ += next_in - next_in_;
}",47,,1122,1,,void
257719,BLOCK,-1,,"{
  state_.reset();
  mode_ = NONE;
}",36,,1137,1,,void
257733,BLOCK,-1,,"{
  alloc_ = alloc;
  free_ = free;
  alloc_opaque_ = opaque;
  state_.reset(BrotliEncoderCreateInstance(alloc, free, opaque));
  if (!state_) {
    return CompressionError(""Could not initialize Brotli instance"",
                            ""ERR_ZLIB_INITIALIZATION_FAILED"",
                            -1);
  } else {
    return CompressionError {};
  }
}",59,,1144,4,,void
257754,BLOCK,-1,,"{
    return CompressionError(""Could not initialize Brotli instance"",
                            ""ERR_ZLIB_INITIALIZATION_FAILED"",
                            -1);
  }",16,,1149,2,,void
257762,BLOCK,-1,,"{
    return CompressionError {};
  }",10,,1153,1,,void
257769,BLOCK,-1,,"{
  return Init(alloc_, free_, alloc_opaque_);
}",54,,1158,1,,void
257780,BLOCK,-1,,"{
  if (!BrotliEncoderSetParameter(state_.get(),
                                 static_cast<BrotliEncoderParameter>(key),
                                 value)) {
    return CompressionError(""Setting parameter failed"",
                            ""ERR_BROTLI_PARAM_SET_FAILED"",
                            -1);
  } else {
    return CompressionError {};
  }
}",75,,1162,3,,void
257792,BLOCK,-1,,"{
    return CompressionError(""Setting parameter failed"",
                            ""ERR_BROTLI_PARAM_SET_FAILED"",
                            -1);
  }",42,,1165,2,,void
257800,BLOCK,-1,,"{
    return CompressionError {};
  }",10,,1169,1,,void
257807,BLOCK,-1,,"{
  if (!last_result_) {
    return CompressionError(""Compression failed"",
                            ""ERR_BROTLI_COMPRESSION_FAILED"",
                            -1);
  } else {
    return CompressionError {};
  }
}",61,,1174,1,,void
257811,BLOCK,-1,,"{
    return CompressionError(""Compression failed"",
                            ""ERR_BROTLI_COMPRESSION_FAILED"",
                            -1);
  }",22,,1175,2,,void
257819,BLOCK,-1,,"{
    return CompressionError {};
  }",10,,1179,1,,void
257826,BLOCK,-1,,"{
  state_.reset();
  mode_ = NONE;
}",36,,1185,1,,void
257837,BLOCK,-1,,"{
  CHECK_EQ(mode_, BROTLI_DECODE);
  CHECK(state_);
  const uint8_t* next_in = next_in_;
  last_result_ = BrotliDecoderDecompressStream(state_.get(),
                                               &avail_in_,
                                               &next_in,
                                               &avail_out_,
                                               &next_out_,
                                               nullptr);
  next_in_ += next_in - next_in_;
  if (last_result_ == BROTLI_DECODER_RESULT_ERROR) {
    error_ = BrotliDecoderGetErrorCode(state_.get());
    error_string_ = std::string(""ERR_"") + BrotliDecoderErrorString(error_);
  }
}",47,,1190,1,,void
257872,BLOCK,-1,,"{
    error_ = BrotliDecoderGetErrorCode(state_.get());
    error_string_ = std::string(""ERR_"") + BrotliDecoderErrorString(error_);
  }",52,,1201,2,,void
257896,BLOCK,-1,,"{
  alloc_ = alloc;
  free_ = free;
  alloc_opaque_ = opaque;
  state_.reset(BrotliDecoderCreateInstance(alloc, free, opaque));
  if (!state_) {
    return CompressionError(""Could not initialize Brotli instance"",
                            ""ERR_ZLIB_INITIALIZATION_FAILED"",
                            -1);
  } else {
    return CompressionError {};
  }
}",59,,1209,4,,void
257917,BLOCK,-1,,"{
    return CompressionError(""Could not initialize Brotli instance"",
                            ""ERR_ZLIB_INITIALIZATION_FAILED"",
                            -1);
  }",16,,1214,2,,void
257925,BLOCK,-1,,"{
    return CompressionError {};
  }",10,,1218,1,,void
257932,BLOCK,-1,,"{
  return Init(alloc_, free_, alloc_opaque_);
}",54,,1223,1,,void
257943,BLOCK,-1,,"{
  if (!BrotliDecoderSetParameter(state_.get(),
                                 static_cast<BrotliDecoderParameter>(key),
                                 value)) {
    return CompressionError(""Setting parameter failed"",
                            ""ERR_BROTLI_PARAM_SET_FAILED"",
                            -1);
  } else {
    return CompressionError {};
  }
}",75,,1227,3,,void
257955,BLOCK,-1,,"{
    return CompressionError(""Setting parameter failed"",
                            ""ERR_BROTLI_PARAM_SET_FAILED"",
                            -1);
  }",42,,1230,2,,void
257963,BLOCK,-1,,"{
    return CompressionError {};
  }",10,,1234,1,,void
257970,BLOCK,-1,,"{
  if (error_ != BROTLI_DECODER_NO_ERROR) {
    return CompressionError(""Decompression failed"",
                            error_string_.c_str(),
                            static_cast<int>(error_));
  } else if (flush_ == BROTLI_OPERATION_FINISH &&
             last_result_ == BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT) {
    // Match zlib's behaviour, as brotli doesn't have its own code for this.
    return CompressionError(""unexpected end of file"",
                            ""Z_BUF_ERROR"",
                            Z_BUF_ERROR);
  } else {
    return CompressionError {};
  }
}",61,,1239,1,,void
257975,BLOCK,-1,,"{
    return CompressionError(""Decompression failed"",
                            error_string_.c_str(),
                            static_cast<int>(error_));
  }",42,,1240,2,,void
257987,BLOCK,-1,,<empty>,10,,1244,1,,void
257996,BLOCK,-1,,"{
    // Match zlib's behaviour, as brotli doesn't have its own code for this.
    return CompressionError(""unexpected end of file"",
                            ""Z_BUF_ERROR"",
                            Z_BUF_ERROR);
  }",70,,1245,2,,void
258003,BLOCK,-1,,"{
    return CompressionError {};
  }",10,,1250,1,,void
258014,BLOCK,-1,,"{
    Isolate* isolate = env->isolate();
    Local<FunctionTemplate> z = NewFunctionTemplate(isolate, Stream::New);

    z->InstanceTemplate()->SetInternalFieldCount(
        Stream::kInternalFieldCount);
    z->Inherit(AsyncWrap::GetConstructorTemplate(env));

    SetProtoMethod(isolate, z, ""write"", Stream::template Write<true>);
    SetProtoMethod(isolate, z, ""writeSync"", Stream::template Write<false>);
    SetProtoMethod(isolate, z, ""close"", Stream::Close);

    SetProtoMethod(isolate, z, ""init"", Stream::Init);
    SetProtoMethod(isolate, z, ""params"", Stream::Params);
    SetProtoMethod(isolate, z, ""reset"", Stream::Reset);

    SetConstructorFunction(env->context(), target, name, z);
  }",78,,1258,4,,void
258106,BLOCK,-1,,"{
    registry->Register(Stream::New);
    registry->Register(Stream::template Write<true>);
    registry->Register(Stream::template Write<false>);
    registry->Register(Stream::Close);
    registry->Register(Stream::Init);
    registry->Register(Stream::Params);
    registry->Register(Stream::Reset);
  }",57,,1277,2,,void
258163,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);

  MakeClass<ZlibStream>::Make(env, target, ""Zlib"");
  MakeClass<BrotliEncoderStream>::Make(env, target, ""BrotliEncoder"");
  MakeClass<BrotliDecoderStream>::Make(env, target, ""BrotliDecoder"");

  target->Set(env->context(),
              FIXED_ONE_BYTE_STRING(env->isolate(), ""ZLIB_VERSION""),
              FIXED_ONE_BYTE_STRING(env->isolate(), ZLIB_VERSION)).Check();
}",29,,1291,5,,void
258220,BLOCK,-1,,"{
  MakeClass<ZlibStream>::Make(registry);
  MakeClass<BrotliEncoderStream>::Make(registry);
  MakeClass<BrotliDecoderStream>::Make(registry);
}",70,,1303,2,,void
258240,BLOCK,-1,,"{
  NODE_DEFINE_CONSTANT(target, Z_NO_FLUSH);
  NODE_DEFINE_CONSTANT(target, Z_PARTIAL_FLUSH);
  NODE_DEFINE_CONSTANT(target, Z_SYNC_FLUSH);
  NODE_DEFINE_CONSTANT(target, Z_FULL_FLUSH);
  NODE_DEFINE_CONSTANT(target, Z_FINISH);
  NODE_DEFINE_CONSTANT(target, Z_BLOCK);

  // return/error codes
  NODE_DEFINE_CONSTANT(target, Z_OK);
  NODE_DEFINE_CONSTANT(target, Z_STREAM_END);
  NODE_DEFINE_CONSTANT(target, Z_NEED_DICT);
  NODE_DEFINE_CONSTANT(target, Z_ERRNO);
  NODE_DEFINE_CONSTANT(target, Z_STREAM_ERROR);
  NODE_DEFINE_CONSTANT(target, Z_DATA_ERROR);
  NODE_DEFINE_CONSTANT(target, Z_MEM_ERROR);
  NODE_DEFINE_CONSTANT(target, Z_BUF_ERROR);
  NODE_DEFINE_CONSTANT(target, Z_VERSION_ERROR);

  NODE_DEFINE_CONSTANT(target, Z_NO_COMPRESSION);
  NODE_DEFINE_CONSTANT(target, Z_BEST_SPEED);
  NODE_DEFINE_CONSTANT(target, Z_BEST_COMPRESSION);
  NODE_DEFINE_CONSTANT(target, Z_DEFAULT_COMPRESSION);
  NODE_DEFINE_CONSTANT(target, Z_FILTERED);
  NODE_DEFINE_CONSTANT(target, Z_HUFFMAN_ONLY);
  N...",48,,1311,2,,void
258246,BLOCK,1,,<empty>,,,,7,,void
258248,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_NO_FLUSH)",3,,1312,1,,void
258345,BLOCK,1,,<empty>,,,,7,,void
258347,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_PARTIAL_FLUSH)",3,,1313,1,,void
258444,BLOCK,1,,<empty>,,,,7,,void
258446,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_SYNC_FLUSH)",3,,1314,1,,void
258543,BLOCK,1,,<empty>,,,,7,,void
258545,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_FULL_FLUSH)",3,,1315,1,,void
258642,BLOCK,1,,<empty>,,,,7,,void
258644,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_FINISH)",3,,1316,1,,void
258741,BLOCK,1,,<empty>,,,,7,,void
258743,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_BLOCK)",3,,1317,1,,void
258840,BLOCK,1,,<empty>,,,,7,,void
258842,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_OK)",3,,1320,1,,void
258939,BLOCK,1,,<empty>,,,,7,,void
258941,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_STREAM_END)",3,,1321,1,,void
259038,BLOCK,1,,<empty>,,,,7,,void
259040,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_NEED_DICT)",3,,1322,1,,void
259137,BLOCK,1,,<empty>,,,,7,,void
259139,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_ERRNO)",3,,1323,1,,void
259236,BLOCK,1,,<empty>,,,,7,,void
259238,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_STREAM_ERROR)",3,,1324,1,,void
259335,BLOCK,1,,<empty>,,,,7,,void
259337,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_DATA_ERROR)",3,,1325,1,,void
259434,BLOCK,1,,<empty>,,,,7,,void
259436,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_MEM_ERROR)",3,,1326,1,,void
259533,BLOCK,1,,<empty>,,,,7,,void
259535,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_BUF_ERROR)",3,,1327,1,,void
259632,BLOCK,1,,<empty>,,,,7,,void
259634,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_VERSION_ERROR)",3,,1328,1,,void
259731,BLOCK,1,,<empty>,,,,7,,void
259733,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_NO_COMPRESSION)",3,,1330,1,,void
259830,BLOCK,1,,<empty>,,,,7,,void
259832,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_BEST_SPEED)",3,,1331,1,,void
259929,BLOCK,1,,<empty>,,,,7,,void
259931,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_BEST_COMPRESSION)",3,,1332,1,,void
260028,BLOCK,1,,<empty>,,,,7,,void
260030,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_DEFAULT_COMPRESSION)",3,,1333,1,,void
260127,BLOCK,1,,<empty>,,,,7,,void
260129,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_FILTERED)",3,,1334,1,,void
260226,BLOCK,1,,<empty>,,,,7,,void
260228,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_HUFFMAN_ONLY)",3,,1335,1,,void
260325,BLOCK,1,,<empty>,,,,7,,void
260327,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_RLE)",3,,1336,1,,void
260424,BLOCK,1,,<empty>,,,,7,,void
260426,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_FIXED)",3,,1337,1,,void
260523,BLOCK,1,,<empty>,,,,7,,void
260525,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_DEFAULT_STRATEGY)",3,,1338,1,,void
260622,BLOCK,1,,<empty>,,,,7,,void
260624,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, ZLIB_VERNUM)",3,,1339,1,,void
260721,BLOCK,1,,<empty>,,,,7,,void
260723,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, DEFLATE)",3,,1341,1,,void
260820,BLOCK,1,,<empty>,,,,7,,void
260822,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, INFLATE)",3,,1342,1,,void
260919,BLOCK,1,,<empty>,,,,7,,void
260921,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, GZIP)",3,,1343,1,,void
261018,BLOCK,1,,<empty>,,,,7,,void
261020,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, GUNZIP)",3,,1344,1,,void
261117,BLOCK,1,,<empty>,,,,7,,void
261119,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, DEFLATERAW)",3,,1345,1,,void
261216,BLOCK,1,,<empty>,,,,7,,void
261218,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, INFLATERAW)",3,,1346,1,,void
261315,BLOCK,1,,<empty>,,,,7,,void
261317,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, UNZIP)",3,,1347,1,,void
261414,BLOCK,1,,<empty>,,,,7,,void
261416,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODE)",3,,1348,1,,void
261513,BLOCK,1,,<empty>,,,,7,,void
261515,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_ENCODE)",3,,1349,1,,void
261611,BLOCK,1,,<empty>,,,,6,,void
261613,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_MIN_WINDOWBITS)",3,,1351,1,,void
261709,BLOCK,1,,<empty>,,,,6,,void
261711,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_MAX_WINDOWBITS)",3,,1352,1,,void
261807,BLOCK,1,,<empty>,,,,6,,void
261809,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_DEFAULT_WINDOWBITS)",3,,1353,1,,void
261905,BLOCK,1,,<empty>,,,,6,,void
261907,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_MIN_CHUNK)",3,,1354,1,,void
262003,BLOCK,1,,<empty>,,,,6,,void
262005,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_MAX_CHUNK)",3,,1355,1,,void
262106,BLOCK,1,,<empty>,,,,6,,void
262108,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_DEFAULT_CHUNK)",3,,1356,1,,void
262206,BLOCK,1,,<empty>,,,,6,,void
262208,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_MIN_MEMLEVEL)",3,,1357,1,,void
262304,BLOCK,1,,<empty>,,,,6,,void
262306,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_MAX_MEMLEVEL)",3,,1358,1,,void
262402,BLOCK,1,,<empty>,,,,6,,void
262404,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_DEFAULT_MEMLEVEL)",3,,1359,1,,void
262500,BLOCK,1,,<empty>,,,,6,,void
262502,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_MIN_LEVEL)",3,,1360,1,,void
262599,BLOCK,1,,<empty>,,,,6,,void
262601,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_MAX_LEVEL)",3,,1361,1,,void
262697,BLOCK,1,,<empty>,,,,6,,void
262699,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_DEFAULT_LEVEL)",3,,1362,1,,void
262796,BLOCK,1,,<empty>,,,,7,,void
262798,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_OPERATION_PROCESS)",3,,1365,1,,void
262895,BLOCK,1,,<empty>,,,,7,,void
262897,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_OPERATION_FLUSH)",3,,1366,1,,void
262994,BLOCK,1,,<empty>,,,,7,,void
262996,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_OPERATION_FINISH)",3,,1367,1,,void
263093,BLOCK,1,,<empty>,,,,7,,void
263095,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_OPERATION_EMIT_METADATA)",3,,1368,1,,void
263192,BLOCK,1,,<empty>,,,,7,,void
263194,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_MODE)",3,,1369,1,,void
263291,BLOCK,1,,<empty>,,,,7,,void
263293,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_MODE_GENERIC)",3,,1370,1,,void
263390,BLOCK,1,,<empty>,,,,7,,void
263392,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_MODE_TEXT)",3,,1371,1,,void
263489,BLOCK,1,,<empty>,,,,7,,void
263491,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_MODE_FONT)",3,,1372,1,,void
263588,BLOCK,1,,<empty>,,,,7,,void
263590,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DEFAULT_MODE)",3,,1373,1,,void
263687,BLOCK,1,,<empty>,,,,7,,void
263689,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_QUALITY)",3,,1374,1,,void
263786,BLOCK,1,,<empty>,,,,7,,void
263788,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_MIN_QUALITY)",3,,1375,1,,void
263885,BLOCK,1,,<empty>,,,,7,,void
263887,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_MAX_QUALITY)",3,,1376,1,,void
263984,BLOCK,1,,<empty>,,,,7,,void
263986,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DEFAULT_QUALITY)",3,,1377,1,,void
264083,BLOCK,1,,<empty>,,,,7,,void
264085,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_LGWIN)",3,,1378,1,,void
264182,BLOCK,1,,<empty>,,,,7,,void
264184,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_MIN_WINDOW_BITS)",3,,1379,1,,void
264281,BLOCK,1,,<empty>,,,,7,,void
264283,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_MAX_WINDOW_BITS)",3,,1380,1,,void
264380,BLOCK,1,,<empty>,,,,7,,void
264382,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_LARGE_MAX_WINDOW_BITS)",3,,1381,1,,void
264479,BLOCK,1,,<empty>,,,,7,,void
264481,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DEFAULT_WINDOW)",3,,1382,1,,void
264578,BLOCK,1,,<empty>,,,,7,,void
264580,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_LGBLOCK)",3,,1383,1,,void
264677,BLOCK,1,,<empty>,,,,7,,void
264679,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_MIN_INPUT_BLOCK_BITS)",3,,1384,1,,void
264776,BLOCK,1,,<empty>,,,,7,,void
264778,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_MAX_INPUT_BLOCK_BITS)",3,,1385,1,,void
264875,BLOCK,1,,<empty>,,,,7,,void
264877,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING)",3,,1386,1,,void
264974,BLOCK,1,,<empty>,,,,7,,void
264976,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_SIZE_HINT)",3,,1387,1,,void
265073,BLOCK,1,,<empty>,,,,7,,void
265075,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_LARGE_WINDOW)",3,,1388,1,,void
265172,BLOCK,1,,<empty>,,,,7,,void
265174,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_NPOSTFIX)",3,,1389,1,,void
265271,BLOCK,1,,<empty>,,,,7,,void
265273,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_NDIRECT)",3,,1390,1,,void
265370,BLOCK,1,,<empty>,,,,7,,void
265372,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_RESULT_ERROR)",3,,1391,1,,void
265469,BLOCK,1,,<empty>,,,,7,,void
265471,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_RESULT_SUCCESS)",3,,1392,1,,void
265568,BLOCK,1,,<empty>,,,,7,,void
265570,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT)",3,,1393,1,,void
265667,BLOCK,1,,<empty>,,,,7,,void
265669,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT)",3,,1394,1,,void
265766,BLOCK,1,,<empty>,,,,7,,void
265768,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target,
      BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION)",3,,1395,1,,void
265865,BLOCK,1,,<empty>,,,,7,,void
265867,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_PARAM_LARGE_WINDOW)",3,,1397,1,,void
265964,BLOCK,1,,<empty>,,,,7,,void
265966,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_NO_ERROR)",3,,1398,1,,void
266063,BLOCK,1,,<empty>,,,,7,,void
266065,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_SUCCESS)",3,,1399,1,,void
266162,BLOCK,1,,<empty>,,,,7,,void
266164,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_NEEDS_MORE_INPUT)",3,,1400,1,,void
266261,BLOCK,1,,<empty>,,,,7,,void
266263,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_NEEDS_MORE_OUTPUT)",3,,1401,1,,void
266360,BLOCK,1,,<empty>,,,,7,,void
266362,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE)",3,,1402,1,,void
266459,BLOCK,1,,<empty>,,,,7,,void
266461,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_RESERVED)",3,,1403,1,,void
266558,BLOCK,1,,<empty>,,,,7,,void
266560,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target,
      BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE)",3,,1404,1,,void
266657,BLOCK,1,,<empty>,,,,7,,void
266659,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target,
      BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET)",3,,1406,1,,void
266756,BLOCK,1,,<empty>,,,,7,,void
266758,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME)",3,,1408,1,,void
266855,BLOCK,1,,<empty>,,,,7,,void
266857,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_CL_SPACE)",3,,1409,1,,void
266954,BLOCK,1,,<empty>,,,,7,,void
266956,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE)",3,,1410,1,,void
267053,BLOCK,1,,<empty>,,,,7,,void
267055,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT)",3,,1411,1,,void
267152,BLOCK,1,,<empty>,,,,7,,void
267154,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1)",3,,1412,1,,void
267251,BLOCK,1,,<empty>,,,,7,,void
267253,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2)",3,,1413,1,,void
267350,BLOCK,1,,<empty>,,,,7,,void
267352,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_TRANSFORM)",3,,1414,1,,void
267449,BLOCK,1,,<empty>,,,,7,,void
267451,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_DICTIONARY)",3,,1415,1,,void
267548,BLOCK,1,,<empty>,,,,7,,void
267550,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS)",3,,1416,1,,void
267647,BLOCK,1,,<empty>,,,,7,,void
267649,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_PADDING_1)",3,,1417,1,,void
267746,BLOCK,1,,<empty>,,,,7,,void
267748,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_PADDING_2)",3,,1418,1,,void
267845,BLOCK,1,,<empty>,,,,7,,void
267847,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_DISTANCE)",3,,1419,1,,void
267944,BLOCK,1,,<empty>,,,,7,,void
267946,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET)",3,,1420,1,,void
268043,BLOCK,1,,<empty>,,,,7,,void
268045,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_INVALID_ARGUMENTS)",3,,1421,1,,void
268142,BLOCK,1,,<empty>,,,,7,,void
268144,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES)",3,,1422,1,,void
268241,BLOCK,1,,<empty>,,,,7,,void
268243,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS)",3,,1423,1,,void
268340,BLOCK,1,,<empty>,,,,7,,void
268342,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP)",3,,1424,1,,void
268439,BLOCK,1,,<empty>,,,,7,,void
268441,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1)",3,,1425,1,,void
268538,BLOCK,1,,<empty>,,,,7,,void
268540,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2)",3,,1426,1,,void
268637,BLOCK,1,,<empty>,,,,7,,void
268639,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES)",3,,1427,1,,void
268736,BLOCK,1,,<empty>,,,,7,,void
268738,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_UNREACHABLE)",3,,1428,1,,void
268843,BLOCK,-1,,<empty>,1,,1,1,,ANY
268849,BLOCK,-1,,"{
  deny_all_ = true;
}",59,,13,3,,void
268858,BLOCK,-1,,"{
  return deny_all_ == false;
}",72,,18,3,,void
268873,BLOCK,-1,,<empty>,1,,1,1,,ANY
268900,BLOCK,-1,,<empty>,1,,1,1,,ANY
268904,BLOCK,-1,,"{
  uv_fs_t req;
  int rc = uv_fs_stat(nullptr, &req, res.c_str(), nullptr);
  if (rc == 0) {
    const uv_stat_t* const s = static_cast<const uv_stat_t*>(req.ptr);
    if (s->st_mode & S_IFDIR) {
      // add wildcard when directory
      if (res.back() == node::kPathSeparator) {
        return res + ""*"";
      }
      return res + node::kPathSeparator + ""*"";
    }
  }
  uv_fs_req_cleanup(&req);
  return res;
}",60,,16,2,,void
268922,BLOCK,-1,,"{
    const uv_stat_t* const s = static_cast<const uv_stat_t*>(req.ptr);
    if (s->st_mode & S_IFDIR) {
      // add wildcard when directory
      if (res.back() == node::kPathSeparator) {
        return res + ""*"";
      }
      return res + node::kPathSeparator + ""*"";
    }
  }",16,,19,2,,void
268937,BLOCK,-1,,"{
      // add wildcard when directory
      if (res.back() == node::kPathSeparator) {
        return res + ""*"";
      }
      return res + node::kPathSeparator + ""*"";
    }",31,,21,2,,void
268947,BLOCK,-1,,"{
        return res + ""*"";
      }",47,,23,2,,void
268969,BLOCK,-1,,"{
  if (node == nullptr) {
    return;
  }

  if (node->children.size()) {
    for (auto& c : node->children) {
      FreeRecursivelyNode(c.second);
    }
  }

  if (node->wildcard_child != nullptr) {
    delete node->wildcard_child;
  }
  delete node;
}",60,,34,2,,void
268974,BLOCK,-1,,"{
    return;
  }",24,,35,2,,void
268983,BLOCK,-1,,"{
    for (auto& c : node->children) {
      FreeRecursivelyNode(c.second);
    }
  }",30,,39,2,,void
268989,BLOCK,-1,,"{
      FreeRecursivelyNode(c.second);
    }",36,,40,3,,void
269000,BLOCK,-1,,"{
    delete node->wildcard_child;
  }",40,,45,2,,void
269012,BLOCK,-1,,"{
#ifdef _WIN32
  // is UNC file path
  if (param.rfind(""\\\\"", 0) == 0) {
    // return lookup with normalized param
    int starting_pos = 4;  // ""\\?\""
    if (param.rfind(""\\\\?\\UNC\\"") == 0) {
      starting_pos += 4;  // ""UNC\""
    }
    auto normalized = param.substr(starting_pos);
    return granted_tree->Lookup(normalized, true);
  }
#endif
  return granted_tree->Lookup(param, true);
}",53,,52,3,,void
269027,BLOCK,-1,,"{
  for (const auto& res : SplitString(allow, ',')) {
    if (res == ""*"") {
      if (scope == PermissionScope::kFileSystemRead) {
        deny_all_in_ = false;
        allow_all_in_ = true;
      } else {
        deny_all_out_ = false;
        allow_all_out_ = true;
      }
      return;
    }
    GrantAccess(scope, res);
  }
}",75,,76,3,,void
269033,BLOCK,-1,,"{
    if (res == ""*"") {
      if (scope == PermissionScope::kFileSystemRead) {
        deny_all_in_ = false;
        allow_all_in_ = true;
      } else {
        deny_all_out_ = false;
        allow_all_out_ = true;
      }
      return;
    }
    GrantAccess(scope, res);
  }",51,,77,3,,void
269038,BLOCK,-1,,"{
      if (scope == PermissionScope::kFileSystemRead) {
        deny_all_in_ = false;
        allow_all_in_ = true;
      } else {
        deny_all_out_ = false;
        allow_all_out_ = true;
      }
      return;
    }",21,,78,2,,void
269045,BLOCK,-1,,"{
        deny_all_in_ = false;
        allow_all_in_ = true;
      }",54,,79,2,,void
269053,BLOCK,-1,,"{
        deny_all_out_ = false;
        allow_all_out_ = true;
      }",14,,82,1,,void
269069,BLOCK,-1,,"{
  const std::string path = WildcardIfDir(res);
  if (perm == PermissionScope::kFileSystemRead) {
    granted_in_fs_.Insert(path);
    deny_all_in_ = false;
  } else if (perm == PermissionScope::kFileSystemWrite) {
    granted_out_fs_.Insert(path);
    deny_all_out_ = false;
  }
}",78,,92,3,,void
269081,BLOCK,-1,,"{
    granted_in_fs_.Insert(path);
    deny_all_in_ = false;
  }",49,,94,2,,void
269091,BLOCK,-1,,<empty>,10,,97,1,,void
269098,BLOCK,-1,,"{
    granted_out_fs_.Insert(path);
    deny_all_out_ = false;
  }",57,,97,2,,void
269112,BLOCK,-1,,"{
  switch (perm) {
    case PermissionScope::kFileSystem:
      return allow_all_in_ && allow_all_out_;
    case PermissionScope::kFileSystemRead:
      return !deny_all_in_ &&
             ((param.empty() && allow_all_in_) || allow_all_in_ ||
              is_tree_granted(&granted_in_fs_, param));
    case PermissionScope::kFileSystemWrite:
      return !deny_all_out_ &&
             ((param.empty() && allow_all_out_) || allow_all_out_ ||
              is_tree_granted(&granted_out_fs_, param));
    default:
      return false;
  }
}",67,,104,3,,void
269115,BLOCK,-1,,"{
    case PermissionScope::kFileSystem:
      return allow_all_in_ && allow_all_out_;
    case PermissionScope::kFileSystemRead:
      return !deny_all_in_ &&
             ((param.empty() && allow_all_in_) || allow_all_in_ ||
              is_tree_granted(&granted_in_fs_, param));
    case PermissionScope::kFileSystemWrite:
      return !deny_all_out_ &&
             ((param.empty() && allow_all_out_) || allow_all_out_ ||
              is_tree_granted(&granted_out_fs_, param));
    default:
      return false;
  }",17,,105,2,,void
269172,BLOCK,-1,,<empty>,65,,121,1,,void
269176,BLOCK,-1,,"{
  FreeRecursivelyNode(root_node_);
}",39,,123,1,,void
269183,BLOCK,-1,,"{
  FSPermission::RadixTree::Node* current_node = root_node_;
  if (current_node->children.size() == 0) {
    return when_empty_return;
  }

  unsigned int parent_node_prefix_len = current_node->prefix.length();
  const std::string path(s);
  auto path_len = path.length();

  while (true) {
    if (parent_node_prefix_len == path_len && current_node->IsEndNode()) {
      return true;
    }

    auto node = current_node->NextNode(path, parent_node_prefix_len);
    if (node == nullptr) {
      return false;
    }

    current_node = node;
    parent_node_prefix_len += current_node->prefix.length();
    if (current_node->wildcard_child != nullptr &&
        path_len >= (parent_node_prefix_len - 2 /* slash* */)) {
      return true;
    }
  }
}",70,,128,3,,void
269197,BLOCK,-1,,"{
    return when_empty_return;
  }",43,,130,2,,void
269221,BLOCK,-1,,"{
    if (parent_node_prefix_len == path_len && current_node->IsEndNode()) {
      return true;
    }

    auto node = current_node->NextNode(path, parent_node_prefix_len);
    if (node == nullptr) {
      return false;
    }

    current_node = node;
    parent_node_prefix_len += current_node->prefix.length();
    if (current_node->wildcard_child != nullptr &&
        path_len >= (parent_node_prefix_len - 2 /* slash* */)) {
      return true;
    }
  }",16,,138,2,,void
269231,BLOCK,-1,,"{
      return true;
    }",74,,139,2,,void
269247,BLOCK,-1,,"{
      return false;
    }",26,,144,2,,void
269273,BLOCK,-1,,"{
      return true;
    }",64,,151,2,,void
269280,BLOCK,-1,,"{
  FSPermission::RadixTree::Node* current_node = root_node_;

  unsigned int parent_node_prefix_len = current_node->prefix.length();
  int path_len = path.length();

  for (int i = 1; i <= path_len; ++i) {
    bool is_wildcard_node = path[i - 1] == '*';
    bool is_last_char = i == path_len;

    if (is_wildcard_node || is_last_char) {
      std::string node_path = path.substr(parent_node_prefix_len, i);
      current_node = current_node->CreateChild(node_path);
    }

    if (is_wildcard_node) {
      current_node = current_node->CreateWildcardChild();
      parent_node_prefix_len = i;
    }
  }
}",63,,157,2,,void
269302,BLOCK,-1,,<empty>,3,,163,1,,void
269312,BLOCK,4,,"{
    bool is_wildcard_node = path[i - 1] == '*';
    bool is_last_char = i == path_len;

    if (is_wildcard_node || is_last_char) {
      std::string node_path = path.substr(parent_node_prefix_len, i);
      current_node = current_node->CreateChild(node_path);
    }

    if (is_wildcard_node) {
      current_node = current_node->CreateWildcardChild();
      parent_node_prefix_len = i;
    }
  }",39,,163,4,,void
269333,BLOCK,-1,,"{
      std::string node_path = path.substr(parent_node_prefix_len, i);
      current_node = current_node->CreateChild(node_path);
    }",43,,167,2,,void
269352,BLOCK,-1,,"{
      current_node = current_node->CreateWildcardChild();
      parent_node_prefix_len = i;
    }",27,,172,2,,void
269376,BLOCK,-1,,<empty>,1,,1,1,,ANY
269403,BLOCK,-1,,<empty>,1,,1,1,,ANY
269409,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  v8::Isolate* isolate = env->isolate();
  CHECK(args[0]->IsString());

  String::Utf8Value utf8_deny_scope(isolate, args[0]);
  if (*utf8_deny_scope == nullptr) {
    return;
  }

  const std::string deny_scope = *utf8_deny_scope;
  PermissionScope scope = Permission::StringToPermission(deny_scope);
  if (scope == PermissionScope::kPermissionsRoot) {
    return args.GetReturnValue().Set(false);
  }

  if (args.Length() > 1 && !args[1]->IsUndefined()) {
    String::Utf8Value utf8_arg(isolate, args[1]);
    if (*utf8_arg == nullptr) {
      return;
    }
    return args.GetReturnValue().Set(
        env->permission()->is_granted(scope, *utf8_arg));
  }

  return args.GetReturnValue().Set(env->permission()->is_granted(scope));
}",58,,30,2,,void
269443,BLOCK,-1,,"{
    return;
  }",36,,36,2,,void
269464,BLOCK,-1,,"{
    return args.GetReturnValue().Set(false);
  }",51,,42,2,,void
269489,BLOCK,-1,,"{
    String::Utf8Value utf8_arg(isolate, args[1]);
    if (*utf8_arg == nullptr) {
      return;
    }
    return args.GetReturnValue().Set(
        env->permission()->is_granted(scope, *utf8_arg));
  }",53,,46,2,,void
269501,BLOCK,-1,,"{
      return;
    }",31,,48,2,,void
269541,BLOCK,-1,,"{
  PERMISSIONS(V)
  return nullptr;
}",72,,62,2,,void
269550,BLOCK,-1,,"{
  PERMISSIONS(V)
  return PermissionScope::kPermissionsRoot;
}",73,,70,2,,void
269560,BLOCK,-1,,"{
  std::shared_ptr<PermissionBase> fs = std::make_shared<FSPermission>();
  std::shared_ptr<PermissionBase> child_p =
      std::make_shared<ChildProcessPermission>();
  std::shared_ptr<PermissionBase> worker_t =
      std::make_shared<WorkerPermission>();
#define V(Name, _, __)                                                         \
  nodes_.insert(std::make_pair(PermissionScope::k##Name, fs));
  FILESYSTEM_PERMISSIONS(V)
#undef V
#define V(Name, _, __)                                                         \
  nodes_.insert(std::make_pair(PermissionScope::k##Name, child_p));
  CHILD_PROCESS_PERMISSIONS(V)
#undef V
#define V(Name, _, __)                                                         \
  nodes_.insert(std::make_pair(PermissionScope::k##Name, worker_t));
  WORKER_THREADS_PERMISSIONS(V)
#undef V
}",44,,76,1,,void
269609,BLOCK,-1,,"{
  Local<Value> err = ERR_ACCESS_DENIED(env->isolate());
  CHECK(err->IsObject());
  if (err.As<Object>()
          ->Set(env->context(),
                env->permission_string(),
                v8::String::NewFromUtf8(env->isolate(),
                                        PermissionToString(perm),
                                        v8::NewStringType::kNormal)
                    .ToLocalChecked())
          .IsNothing() ||
      err.As<Object>()
          ->Set(env->context(),
                env->resource_string(),
                v8::String::NewFromUtf8(env->isolate(),
                                        std::string(res).c_str(),
                                        v8::NewStringType::kNormal)
                    .ToLocalChecked())
          .IsNothing())
    return;
  env->isolate()->ThrowException(err);
}",65,,98,4,,void
269710,BLOCK,-1,,<empty>,5,,117,2,,void
269723,BLOCK,-1,,"{
  if (!enabled_) {
    enabled_ = true;
  }
}",38,,121,1,,void
269727,BLOCK,-1,,"{
    enabled_ = true;
  }",18,,122,2,,void
269736,BLOCK,-1,,"{
  auto permission = nodes_.find(scope);
  if (permission != nodes_.end()) {
    permission->second->Apply(allow, scope);
  }
}",73,,127,3,,void
269752,BLOCK,-1,,"{
    permission->second->Apply(allow, scope);
  }",35,,129,2,,void
269768,BLOCK,-1,,"{
  SetMethodNoSideEffect(context, target, ""has"", Has);

  target->SetIntegrityLevel(context, v8::IntegrityLevel::kFrozen).FromJust();
}",29,,137,5,,void
269791,BLOCK,-1,,"{
  registry->Register(Has);
}",70,,143,2,,void
269822,BLOCK,-1,,<empty>,1,,1,1,,ANY
269835,BLOCK,-1,,<empty>,1,,1,1,,ANY
269846,BLOCK,-1,,<empty>,1,,1,1,,ANY
269852,BLOCK,-1,,"{
  deny_all_ = true;
}",79,,12,3,,void
269861,BLOCK,-1,,"{
  return deny_all_ == false;
}",66,,17,3,,void
269876,BLOCK,-1,,<empty>,1,,1,1,,ANY
269905,BLOCK,-1,,<empty>,1,,1,1,,ANY
269911,BLOCK,-1,,"{
  EscapableHandleScope handle_scope(env->isolate());
  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(parent);
  CHECK_EQ(false, env->pipe_constructor_template().IsEmpty());
  Local<Function> constructor = env->pipe_constructor_template()
                                    ->GetFunction(env->context())
                                    .ToLocalChecked();
  CHECK_EQ(false, constructor.IsEmpty());
  Local<Value> type_value = Int32::New(env->isolate(), type);
  return handle_scope.EscapeMaybe(
      constructor->NewInstance(env->context(), 1, &type_value));
}",69,,52,4,,void
269994,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->InstanceTemplate()
    ->SetInternalFieldCount(StreamBase::kInternalFieldCount);

  t->Inherit(LibuvStreamWrap::GetConstructorTemplate(env));

  SetProtoMethod(isolate, t, ""bind"", Bind);
  SetProtoMethod(isolate, t, ""listen"", Listen);
  SetProtoMethod(isolate, t, ""connect"", Connect);
  SetProtoMethod(isolate, t, ""open"", Open);

#ifdef _WIN32
  SetProtoMethod(isolate, t, ""setPendingInstances"", SetPendingInstances);
#endif

  SetProtoMethod(isolate, t, ""fchmod"", Fchmod);

  SetConstructorFunction(context, target, ""Pipe"", t);
  env->set_pipe_constructor_template(t);

  // Create FunctionTemplate for PipeConnectWrap.
  auto cwt = BaseObject::MakeLazilyInitializedJSTemplate(env);
  cwt->Inherit(AsyncWrap::GetConstructorTemplate(env));
  SetConstructorFunction(context, target, ""PipeConnectWrap"", cwt);

  // Define constants
  ...",39,,69,5,,void
270114,BLOCK,1,,<empty>,,,,7,,void
270116,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, SOCKET)",3,,100,1,,void
270213,BLOCK,1,,<empty>,,,,7,,void
270215,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, SERVER)",3,,101,1,,void
270312,BLOCK,1,,<empty>,,,,7,,void
270314,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, IPC)",3,,102,1,,void
270411,BLOCK,1,,<empty>,,,,7,,void
270413,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, UV_READABLE)",3,,103,1,,void
270510,BLOCK,1,,<empty>,,,,7,,void
270512,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, UV_WRITABLE)",3,,104,1,,void
270621,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(Bind);
  registry->Register(Listen);
  registry->Register(Connect);
  registry->Register(Open);
#ifdef _WIN32
  registry->Register(SetPendingInstances);
#endif
  registry->Register(Fchmod);
}",80,,110,2,,void
270656,BLOCK,-1,,"{
  // This constructor should not be exposed to public javascript.
  // Therefore we assert that we are not trying to call this as a
  // normal function.
  CHECK(args.IsConstructCall());
  CHECK(args[0]->IsInt32());
  Environment* env = Environment::GetCurrent(args);

  int type_value = args[0].As<Int32>()->Value();
  PipeWrap::SocketType type = static_cast<PipeWrap::SocketType>(type_value);

  bool ipc;
  ProviderType provider;
  switch (type) {
    case SOCKET:
      provider = PROVIDER_PIPEWRAP;
      ipc = false;
      break;
    case SERVER:
      provider = PROVIDER_PIPESERVERWRAP;
      ipc = false;
      break;
    case IPC:
      provider = PROVIDER_PIPEWRAP;
      ipc = true;
      break;
    default:
      UNREACHABLE();
  }

  new PipeWrap(env, args.This(), provider, ipc);
}",61,,122,2,,void
270699,BLOCK,-1,,"{
    case SOCKET:
      provider = PROVIDER_PIPEWRAP;
      ipc = false;
      break;
    case SERVER:
      provider = PROVIDER_PIPESERVERWRAP;
      ipc = false;
      break;
    case IPC:
      provider = PROVIDER_PIPEWRAP;
      ipc = true;
      break;
    default:
      UNREACHABLE();
  }",17,,135,2,,void
270745,BLOCK,-1,,"{
  int r = uv_pipe_init(env->event_loop(), &handle_, ipc);
  CHECK_EQ(r, 0);  // How do we proxy this error up to javascript?
                   // Suggestion: uv_pipe_init() returns void.
}",45,,160,5,,void
270764,BLOCK,-1,,"{
  PipeWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  node::Utf8Value name(args.GetIsolate(), args[0]);
  int err = uv_pipe_bind(&wrap->handle_, *name);
  args.GetReturnValue().Set(err);
}",62,,167,2,,void
270804,BLOCK,-1,,"{
  PipeWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  CHECK(args[0]->IsInt32());
  int mode = args[0].As<Int32>()->Value();
  int err = uv_pipe_chmod(&wrap->handle_, mode);
  args.GetReturnValue().Set(err);
}",72,,187,2,,void
270853,BLOCK,-1,,"{
  PipeWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  Environment* env = wrap->env();
  int backlog;
  if (!args[0]->Int32Value(env->context()).To(&backlog)) return;
  int err = uv_listen(reinterpret_cast<uv_stream_t*>(&wrap->handle_),
                      backlog,
                      OnConnection);
  args.GetReturnValue().Set(err);
}",64,,197,2,,void
270887,BLOCK,-1,,<empty>,58,,202,2,,void
270913,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  PipeWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  int fd;
  if (!args[0]->Int32Value(env->context()).To(&fd)) return;

  int err = uv_pipe_open(&wrap->handle_, fd);
  if (err == 0) wrap->set_fd(fd);

  args.GetReturnValue().Set(err);
}",62,,210,2,,void
270948,BLOCK,-1,,<empty>,53,,217,2,,void
270963,BLOCK,-1,,<empty>,17,,220,2,,void
270981,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  PipeWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsString());

  Local<Object> req_wrap_obj = args[0].As<Object>();
  node::Utf8Value name(env->isolate(), args[1]);

  ConnectWrap* req_wrap =
      new ConnectWrap(env, req_wrap_obj, AsyncWrap::PROVIDER_PIPECONNECTWRAP);
  req_wrap->Dispatch(uv_pipe_connect,
                     &wrap->handle_,
                     *name,
                     AfterConnect);

  TRACE_EVENT_NESTABLE_ASYNC_BEGIN1(TRACING_CATEGORY_NODE2(net, native),
                                    ""connect"",
                                    req_wrap,
                                    ""pipe_path"",
                                    TRACE_STR_COPY(*name));

  args.GetReturnValue().Set(0);  // uv_pipe_connect() doesn't return errors.
}",65,,226,2,,void
271084,BLOCK,-1,,<empty>,1,,1,1,,ANY
271105,BLOCK,-1,,<empty>,1,,1,1,,ANY
271114,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(context);
    Isolate* isolate = env->isolate();
    Local<FunctionTemplate> constructor = NewFunctionTemplate(isolate, New);
    constructor->InstanceTemplate()->SetInternalFieldCount(
        ProcessWrap::kInternalFieldCount);

    constructor->Inherit(HandleWrap::GetConstructorTemplate(env));

    SetProtoMethod(isolate, constructor, ""spawn"", Spawn);
    SetProtoMethod(isolate, constructor, ""kill"", Kill);

    SetConstructorFunction(context, target, ""Process"", constructor);
  }",38,,55,5,,void
271179,BLOCK,-1,,"{
    MarkAsUninitialized();
  }",53,,88,3,,void
271186,BLOCK,-1,,"{
    Local<String> handle_key = env->handle_string();
    // This property has always been set by JS land if we are in this code path.
    Local<Object> handle =
        stdio->Get(env->context(), handle_key).ToLocalChecked().As<Object>();

    uv_stream_t* stream = LibuvStreamWrap::From(env, handle)->stream();
    CHECK_NOT_NULL(stream);
    return stream;
  }",76,,92,3,,void
271240,BLOCK,-1,,"{
    Local<Context> context = env->context();
    Local<String> stdio_key = env->stdio_string();
    Local<Array> stdios =
        js_options->Get(context, stdio_key).ToLocalChecked().As<Array>();

    uint32_t len = stdios->Length();
    options->stdio = new uv_stdio_container_t[len];
    options->stdio_count = len;

    for (uint32_t i = 0; i < len; i++) {
      Local<Object> stdio =
          stdios->Get(context, i).ToLocalChecked().As<Object>();
      Local<Value> type =
          stdio->Get(context, env->type_string()).ToLocalChecked();

      if (type->StrictEquals(env->ignore_string())) {
        options->stdio[i].flags = UV_IGNORE;
      } else if (type->StrictEquals(env->pipe_string())) {
        options->stdio[i].flags = static_cast<uv_stdio_flags>(
            UV_CREATE_PIPE | UV_READABLE_PIPE | UV_WRITABLE_PIPE);
        options->stdio[i].data.stream = StreamForWrap(env, stdio);
      } else if (type->StrictEquals(env->overlapped_string())) {
        options->stdio[i].f...",64,,105,4,,void
271298,BLOCK,-1,,<empty>,5,,115,1,,void
271308,BLOCK,4,,"{
      Local<Object> stdio =
          stdios->Get(context, i).ToLocalChecked().As<Object>();
      Local<Value> type =
          stdio->Get(context, env->type_string()).ToLocalChecked();

      if (type->StrictEquals(env->ignore_string())) {
        options->stdio[i].flags = UV_IGNORE;
      } else if (type->StrictEquals(env->pipe_string())) {
        options->stdio[i].flags = static_cast<uv_stdio_flags>(
            UV_CREATE_PIPE | UV_READABLE_PIPE | UV_WRITABLE_PIPE);
        options->stdio[i].data.stream = StreamForWrap(env, stdio);
      } else if (type->StrictEquals(env->overlapped_string())) {
        options->stdio[i].flags = static_cast<uv_stdio_flags>(
            UV_CREATE_PIPE | UV_READABLE_PIPE | UV_WRITABLE_PIPE |
            UV_OVERLAPPED_PIPE);
        options->stdio[i].data.stream = StreamForWrap(env, stdio);
      } else if (type->StrictEquals(env->wrap_string())) {
        options->stdio[i].flags = UV_INHERIT_STREAM;
        options->stdio[i].data.stream = Strea...",40,,115,4,,void
271354,BLOCK,-1,,"{
        options->stdio[i].flags = UV_IGNORE;
      }",53,,121,2,,void
271365,BLOCK,-1,,<empty>,14,,123,1,,void
271375,BLOCK,-1,,"{
        options->stdio[i].flags = static_cast<uv_stdio_flags>(
            UV_CREATE_PIPE | UV_READABLE_PIPE | UV_WRITABLE_PIPE);
        options->stdio[i].data.stream = StreamForWrap(env, stdio);
      }",58,,123,2,,void
271405,BLOCK,-1,,<empty>,14,,127,1,,void
271415,BLOCK,-1,,"{
        options->stdio[i].flags = static_cast<uv_stdio_flags>(
            UV_CREATE_PIPE | UV_READABLE_PIPE | UV_WRITABLE_PIPE |
            UV_OVERLAPPED_PIPE);
        options->stdio[i].data.stream = StreamForWrap(env, stdio);
      }",64,,127,2,,void
271447,BLOCK,-1,,<empty>,14,,132,1,,void
271457,BLOCK,-1,,"{
        options->stdio[i].flags = UV_INHERIT_STREAM;
        options->stdio[i].data.stream = StreamForWrap(env, stdio);
      }",58,,132,2,,void
271481,BLOCK,-1,,"{
        Local<String> fd_key = env->fd_string();
        Local<Value> fd_value = stdio->Get(context, fd_key).ToLocalChecked();
        CHECK(fd_value->IsNumber());
        int fd = static_cast<int>(fd_value.As<Integer>()->Value());
        options->stdio[i].flags = UV_INHERIT_FD;
        options->stdio[i].data.fd = fd;
      }",14,,135,1,,void
271548,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(args);
    Local<Context> context = env->context();
    ProcessWrap* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
    THROW_IF_INSUFFICIENT_PERMISSIONS(
        env, permission::PermissionScope::kChildProcess, """");

    Local<Object> js_options =
        args[0]->ToObject(env->context()).ToLocalChecked();

    uv_process_options_t options;
    memset(&options, 0, sizeof(uv_process_options_t));

    options.exit_cb = OnExit;

    // options.uid
    Local<Value> uid_v =
        js_options->Get(context, env->uid_string()).ToLocalChecked();
    if (!uid_v->IsUndefined() && !uid_v->IsNull()) {
      CHECK(uid_v->IsInt32());
      const int32_t uid = uid_v.As<Int32>()->Value();
      options.flags |= UV_PROCESS_SETUID;
      options.uid = static_cast<uv_uid_t>(uid);
    }

    // options.gid
    Local<Value> gid_v =
        js_options->Get(context, env->gid_string()).ToLocalChecked();
    if (!gid_v->IsUndefined() && !gid_v->IsN...",62,,146,2,,void
271644,BLOCK,-1,,"{
      CHECK(uid_v->IsInt32());
      const int32_t uid = uid_v.As<Int32>()->Value();
      options.flags |= UV_PROCESS_SETUID;
      options.uid = static_cast<uv_uid_t>(uid);
    }",52,,165,2,,void
271702,BLOCK,-1,,"{
      CHECK(gid_v->IsInt32());
      const int32_t gid = gid_v.As<Int32>()->Value();
      options.flags |= UV_PROCESS_SETGID;
      options.gid = static_cast<uv_gid_t>(gid);
    }",52,,175,2,,void
271795,BLOCK,-1,,"{
      Local<Array> js_argv = argv_v.As<Array>();
      int argc = js_argv->Length();
      CHECK_LT(argc, INT_MAX);  // Check for overflow.

      // Heap allocate to detect errors. +1 is for nullptr.
      options.args = new char*[argc + 1];
      for (int i = 0; i < argc; i++) {
        node::Utf8Value arg(env->isolate(),
                            js_argv->Get(context, i).ToLocalChecked());
        options.args[i] = strdup(*arg);
        CHECK_NOT_NULL(options.args[i]);
      }
      options.args[argc] = nullptr;
    }",49,,194,2,,void
271823,BLOCK,-1,,<empty>,7,,201,1,,void
271833,BLOCK,4,,"{
        node::Utf8Value arg(env->isolate(),
                            js_argv->Get(context, i).ToLocalChecked());
        options.args[i] = strdup(*arg);
        CHECK_NOT_NULL(options.args[i]);
      }",38,,201,4,,void
271909,BLOCK,-1,,"{
      options.cwd = *cwd;
    }",27,,215,2,,void
271945,BLOCK,-1,,"{
      Local<Array> env_opt = env_v.As<Array>();
      int envc = env_opt->Length();
      CHECK_LT(envc, INT_MAX);            // Check for overflow.
      options.env = new char*[envc + 1];  // Heap allocated to detect errors.
      for (int i = 0; i < envc; i++) {
        node::Utf8Value pair(env->isolate(),
                             env_opt->Get(context, i).ToLocalChecked());
        options.env[i] = strdup(*pair);
        CHECK_NOT_NULL(options.env[i]);
      }
      options.env[envc] = nullptr;
    }",47,,222,2,,void
271973,BLOCK,-1,,<empty>,7,,227,1,,void
271983,BLOCK,4,,"{
        node::Utf8Value pair(env->isolate(),
                             env_opt->Get(context, i).ToLocalChecked());
        options.env[i] = strdup(*pair);
        CHECK_NOT_NULL(options.env[i]);
      }",38,,227,4,,void
272049,BLOCK,-1,,"{
      options.flags |= UV_PROCESS_WINDOWS_HIDE;
    }",27,,243,2,,void
272060,BLOCK,-1,,"{
      options.flags |= UV_PROCESS_WINDOWS_HIDE_CONSOLE;
    }",38,,247,2,,void
272089,BLOCK,-1,,"{
      options.flags |= UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS;
    }",26,,256,2,,void
272118,BLOCK,-1,,"{
      options.flags |= UV_PROCESS_DETACHED;
    }",31,,264,2,,void
272146,BLOCK,-1,,"{
      CHECK_EQ(wrap->process_.data, wrap);
      wrap->object()->Set(context, env->pid_string(),
                          Integer::New(env->isolate(),
                                       wrap->process_.pid)).Check();
    }",19,,271,2,,void
272186,BLOCK,-1,,"{
      for (int i = 0; options.args[i]; i++) free(options.args[i]);
      delete [] options.args;
    }",23,,278,2,,void
272188,BLOCK,-1,,<empty>,7,,279,1,,void
272214,BLOCK,-1,,"{
      for (int i = 0; options.env[i]; i++) free(options.env[i]);
      delete [] options.env;
    }",22,,283,2,,void
272216,BLOCK,-1,,<empty>,7,,284,1,,void
272254,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(args);
    ProcessWrap* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
    int signal = args[0]->Int32Value(env->context()).FromJust();
    int err = uv_process_kill(&wrap->process_, signal);
    args.GetReturnValue().Set(err);
  }",61,,293,2,,void
272310,BLOCK,-1,,"{
    ProcessWrap* wrap = ContainerOf(&ProcessWrap::process_, handle);
    CHECK_EQ(&wrap->process_, handle);

    Environment* env = wrap->env();
    HandleScope handle_scope(env->isolate());
    Context::Scope context_scope(env->context());

    Local<Value> argv[] = {
      Number::New(env->isolate(), static_cast<double>(exit_status)),
      OneByteString(env->isolate(), signo_string(term_signal))
    };

    wrap->MakeCallback(env->onexit_string(), arraysize(argv), argv);
  }",39,,304,4,,void
272410,BLOCK,-1,,<empty>,1,,1,1,,ANY
272435,BLOCK,-1,,<empty>,1,,1,1,,ANY
272450,BLOCK,-1,,<empty>,1,,1,1,,ANY
272461,BLOCK,-1,,<empty>,1,,1,1,,ANY
272480,BLOCK,-1,,<empty>,1,,1,1,,ANY
272499,BLOCK,-1,,<empty>,1,,1,1,,ANY
272514,BLOCK,-1,,<empty>,1,,1,1,,ANY
272522,BLOCK,-1,,"{
  v8::Local<v8::Value> value;
  if (!object->Get(env->context(), name).ToLocal(&value)) return false;
  if (!value->IsUndefined()) {
    Utf8Value utf8(env->isolate(), value);
    options->*member = *utf8;
  }
  return true;
}",51,,16,5,,void
272548,BLOCK,-1,,<empty>,59,,18,2,,void
272557,BLOCK,-1,,"{
    Utf8Value utf8(env->isolate(), value);
    options->*member = *utf8;
  }",30,,19,2,,void
272580,BLOCK,-1,,"{
  v8::Local<v8::Value> value;
  if (!object->Get(env->context(), name).ToLocal(&value)) return false;
  if (!value->IsUndefined()) {
    CHECK(value->IsBoolean());
    options->*member = value->IsTrue();
  }
  return true;
}",51,,30,5,,void
272606,BLOCK,-1,,<empty>,59,,32,2,,void
272615,BLOCK,-1,,"{
    CHECK(value->IsBoolean());
    options->*member = value->IsTrue();
  }",30,,33,2,,void
272638,BLOCK,-1,,"{
  v8::Local<v8::Value> value;
  if (!object->Get(env->context(), name).ToLocal(&value)) return false;

  if (!value->IsUndefined()) {
    CHECK_IMPLIES(!value->IsBigInt(), value->IsNumber());

    uint64_t val = 0;
    if (value->IsBigInt()) {
      bool lossless = true;
      val = value.As<v8::BigInt>()->Uint64Value(&lossless);
      if (!lossless) {
        Utf8Value label(env->isolate(), name);
        THROW_ERR_OUT_OF_RANGE(
            env, (""options."" + label.ToString() + "" is out of range"").c_str());
        return false;
      }
    } else {
      val = static_cast<int64_t>(value.As<v8::Number>()->Value());
    }
    options->*member = val;
  }
  return true;
}",51,,44,5,,void
272664,BLOCK,-1,,<empty>,59,,46,2,,void
272673,BLOCK,-1,,"{
    CHECK_IMPLIES(!value->IsBigInt(), value->IsNumber());

    uint64_t val = 0;
    if (value->IsBigInt()) {
      bool lossless = true;
      val = value.As<v8::BigInt>()->Uint64Value(&lossless);
      if (!lossless) {
        Utf8Value label(env->isolate(), name);
        THROW_ERR_OUT_OF_RANGE(
            env, (""options."" + label.ToString() + "" is out of range"").c_str());
        return false;
      }
    } else {
      val = static_cast<int64_t>(value.As<v8::Number>()->Value());
    }
    options->*member = val;
  }",30,,48,2,,void
272693,BLOCK,-1,,"{
      bool lossless = true;
      val = value.As<v8::BigInt>()->Uint64Value(&lossless);
      if (!lossless) {
        Utf8Value label(env->isolate(), name);
        THROW_ERR_OUT_OF_RANGE(
            env, (""options."" + label.ToString() + "" is out of range"").c_str());
        return false;
      }
    }",28,,52,2,,void
272712,BLOCK,-1,,"{
        Utf8Value label(env->isolate(), name);
        THROW_ERR_OUT_OF_RANGE(
            env, (""options."" + label.ToString() + "" is out of range"").c_str());
        return false;
      }",22,,55,2,,void
272736,BLOCK,-1,,"{
      val = static_cast<int64_t>(value.As<v8::Number>()->Value());
    }",12,,61,1,,void
272760,BLOCK,-1,,"{
  stats->*member += amt;
}",52,,74,3,,void
272770,BLOCK,-1,,"{
  stats->*member = uv_hrtime();
}",40,,79,2,,void
272781,BLOCK,-1,,"{
  stats->*member = val;
}",42,,84,3,,void
272791,BLOCK,-1,,"{
  return stats->*member;
}",32,,89,2,,void
272822,BLOCK,-1,,<empty>,1,,1,1,,ANY
272837,BLOCK,-1,,<empty>,1,,1,1,,ANY
272870,BLOCK,-1,,<empty>,1,,1,1,,ANY
272901,BLOCK,-1,,<empty>,1,,1,1,,ANY
272922,BLOCK,-1,,<empty>,1,,1,1,,ANY
272937,BLOCK,-1,,<empty>,1,,1,1,,ANY
272954,BLOCK,-1,,<empty>,1,,1,1,,ANY
272971,BLOCK,-1,,<empty>,1,,1,1,,ANY
273000,BLOCK,-1,,<empty>,1,,1,1,,ANY
273021,BLOCK,-1,,<empty>,1,,1,1,,ANY
273040,BLOCK,-1,,<empty>,1,,1,1,,ANY
273055,BLOCK,-1,,<empty>,1,,1,1,,ANY
273078,BLOCK,-1,,<empty>,1,,1,1,,ANY
273099,BLOCK,-1,,<empty>,1,,1,1,,ANY
273110,BLOCK,-1,,<empty>,1,,1,1,,ANY
273121,BLOCK,-1,,<empty>,1,,1,1,,ANY
273126,BLOCK,-1,,"{
          SignalWrap* wrap = ContainerOf(&SignalWrap::handle_, handle);
          Environment* env = wrap->env();
          HandleScope handle_scope(env->isolate());
          Context::Scope context_scope(env->context());
          Local<Value> arg = Integer::New(env->isolate(), signum);
          wrap->MakeCallback(env->onsignal_string(), 1, &arg);
        }",45,,123,3,,void
273203,BLOCK,-1,,<empty>,1,,1,1,,ANY
273207,BLOCK,-1,,<empty>,,,,2,,<empty>
273218,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(context);
    Isolate* isolate = env->isolate();
    Local<FunctionTemplate> constructor = NewFunctionTemplate(isolate, New);
    constructor->InstanceTemplate()->SetInternalFieldCount(
        SignalWrap::kInternalFieldCount);
    constructor->Inherit(HandleWrap::GetConstructorTemplate(env));

    SetProtoMethod(isolate, constructor, ""start"", Start);
    SetProtoMethod(isolate, constructor, ""stop"", Stop);

    SetConstructorFunction(context, target, ""Signal"", constructor);
  }",38,,54,5,,void
273281,BLOCK,-1,,"{
    registry->Register(New);
    registry->Register(Start);
    registry->Register(Stop);
  }",79,,68,2,,void
273303,BLOCK,-1,,"{
    int r = uv_signal_init(env->event_loop(), &handle_);
    CHECK_EQ(r, 0);
  }",52,,92,3,,void
273321,BLOCK,-1,,"{
    if (active_) {
      DecreaseSignalHandlerCount(handle_.signum);
      active_ = false;
    }
    HandleWrap::Close(close_callback);
  }",60,,97,2,,void
273324,BLOCK,-1,,"{
      DecreaseSignalHandlerCount(handle_.signum);
      active_ = false;
    }",18,,98,2,,void
273341,BLOCK,-1,,"{
    SignalWrap* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
    Environment* env = wrap->env();
    int signum;
    if (!args[0]->Int32Value(env->context()).To(&signum)) return;
#if defined(__POSIX__) && HAVE_INSPECTOR
    if (signum == SIGPROF) {
      Environment* env = Environment::GetCurrent(args);
      if (env->inspector_agent()->IsListening()) {
        ProcessEmitWarning(env,
                           ""process.on(SIGPROF) is reserved while debugging"");
        return;
      }
    }
#endif
    int err = uv_signal_start(
        &wrap->handle_,
        [](uv_signal_t* handle, int signum) {
          SignalWrap* wrap = ContainerOf(&SignalWrap::handle_, handle);
          Environment* env = wrap->env();
          HandleScope handle_scope(env->isolate());
          Context::Scope context_scope(env->context());
          Local<Value> arg = Integer::New(env->isolate(), signum);
          wrap->MakeCallback(env->onsignal_string(), 1, &arg);
        },
        signum)...",62,,105,2,,void
273374,BLOCK,-1,,<empty>,59,,110,2,,void
273390,BLOCK,-1,,"{
      CHECK(!wrap->active_);
      wrap->active_ = true;
      Mutex::ScopedLock lock(handled_signals_mutex);
      handled_signals[signum]++;
    }",19,,133,2,,void
273420,BLOCK,-1,,"{
    SignalWrap* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

    if (wrap->active_)  {
      wrap->active_ = false;
      DecreaseSignalHandlerCount(wrap->handle_.signum);
    }

    int err = uv_signal_stop(&wrap->handle_);
    args.GetReturnValue().Set(err);
  }",61,,143,2,,void
273433,BLOCK,-1,,"{
      wrap->active_ = false;
      DecreaseSignalHandlerCount(wrap->handle_.signum);
    }",25,,147,2,,void
273466,BLOCK,-1,,<empty>,,,,1,,<empty>
273474,BLOCK,-1,,"{
  Mutex::ScopedLock lock(handled_signals_mutex);
  int64_t new_handler_count = --handled_signals[signum];
  CHECK_GE(new_handler_count, 0);
  if (new_handler_count == 0)
    handled_signals.erase(signum);
}",45,,163,2,,void
273492,BLOCK,-1,,<empty>,5,,168,2,,void
273502,BLOCK,-1,,"{
  Mutex::ScopedLock lock(handled_signals_mutex);
  return handled_signals.find(signum) != handled_signals.end();
}",37,,171,2,,void
273538,BLOCK,-1,,<empty>,1,,1,1,,ANY
273543,BLOCK,-1,,"{
  if (used() == kBufferSize)
    *buf = uv_buf_init(nullptr, 0);
  else
    *buf = uv_buf_init(data_ + used(), available());
}",60,,54,3,,void
273548,BLOCK,-1,,<empty>,5,,56,2,,void
273556,BLOCK,-1,,<empty>,5,,58,1,,void
273570,BLOCK,-1,,"{
  // If we hand out the same chunk twice, this should catch it.
  CHECK_EQ(buf->base, data_ + used());
  used_ += static_cast<unsigned int>(nread);
}",73,,62,3,,void
273587,BLOCK,-1,,"{
  memcpy(dest, data_, used());
  return used();
}",56,,69,2,,void
273597,BLOCK,-1,,"{
  return sizeof data_ - used();
}",57,,75,1,,void
273606,BLOCK,-1,,"{
  return used_;
}",52,,80,1,,void
273612,BLOCK,-1,,"{
  return next_;
}",64,,85,1,,void
273619,BLOCK,-1,,"{
  next_ = next;
}",71,,90,2,,void
273630,BLOCK,-1,,"{
  CHECK(readable || writable);
}",34,,111,5,,void
273638,BLOCK,-1,,"{
  CHECK(lifecycle_ == kUninitialized || lifecycle_ == kClosed);

  SyncProcessOutputBuffer* buf;
  SyncProcessOutputBuffer* next;

  for (buf = first_output_buffer_; buf != nullptr; buf = next) {
    next = buf->next();
    delete buf;
  }
}",47,,116,1,,void
273650,BLOCK,-1,,<empty>,3,,122,1,,void
273660,BLOCK,4,,"{
    next = buf->next();
    delete buf;
  }",64,,122,4,,void
273673,BLOCK,-1,,"{
  CHECK_EQ(lifecycle_, kUninitialized);

  int r = uv_pipe_init(loop, uv_pipe(), 0);
  if (r < 0)
    return r;

  uv_pipe()->data = this;

  lifecycle_ = kInitialized;
  return 0;
}",55,,129,2,,void
273688,BLOCK,-1,,<empty>,5,,134,2,,void
273704,BLOCK,-1,,"{
  CHECK_EQ(lifecycle_, kInitialized);

  // Set the busy flag already. If this function fails no recovery is
  // possible.
  lifecycle_ = kStarted;

  if (readable()) {
    if (input_buffer_.len > 0) {
      CHECK_NOT_NULL(input_buffer_.base);

      int r = uv_write(&write_req_,
                       uv_stream(),
                       &input_buffer_,
                       1,
                       WriteCallback);
      if (r < 0)
        return r;
    }

    int r = uv_shutdown(&shutdown_req_, uv_stream(), ShutdownCallback);
    if (r < 0)
      return r;
  }

  if (writable()) {
    int r = uv_read_start(uv_stream(), AllocCallback, ReadCallback);
    if (r < 0)
      return r;
  }

  return 0;
}",35,,143,1,,void
273713,BLOCK,-1,,"{
    if (input_buffer_.len > 0) {
      CHECK_NOT_NULL(input_buffer_.base);

      int r = uv_write(&write_req_,
                       uv_stream(),
                       &input_buffer_,
                       1,
                       WriteCallback);
      if (r < 0)
        return r;
    }

    int r = uv_shutdown(&shutdown_req_, uv_stream(), ShutdownCallback);
    if (r < 0)
      return r;
  }",19,,150,2,,void
273720,BLOCK,-1,,"{
      CHECK_NOT_NULL(input_buffer_.base);

      int r = uv_write(&write_req_,
                       uv_stream(),
                       &input_buffer_,
                       1,
                       WriteCallback);
      if (r < 0)
        return r;
    }",32,,151,2,,void
273740,BLOCK,-1,,<empty>,9,,160,2,,void
273755,BLOCK,-1,,<empty>,7,,165,2,,void
273760,BLOCK,-1,,"{
    int r = uv_read_start(uv_stream(), AllocCallback, ReadCallback);
    if (r < 0)
      return r;
  }",19,,168,2,,void
273772,BLOCK,-1,,<empty>,7,,171,2,,void
273780,BLOCK,-1,,"{
  CHECK(lifecycle_ == kInitialized || lifecycle_ == kStarted);

  uv_close(uv_handle(), CloseCallback);

  lifecycle_ = kClosing;
}",36,,178,1,,void
273799,BLOCK,-1,,"{
  size_t length = OutputLength();
  Local<Object> js_buffer = Buffer::New(env, length).ToLocalChecked();
  CopyOutput(Buffer::Data(js_buffer));
  return js_buffer;
}",79,,187,2,,void
273830,BLOCK,-1,,"{
  return readable_;
}",45,,195,1,,void
273836,BLOCK,-1,,"{
  return writable_;
}",45,,200,1,,void
273842,BLOCK,-1,,"{
  unsigned int flags;

  flags = UV_CREATE_PIPE;
  if (readable())
    flags |= UV_READABLE_PIPE;
  if (writable())
    flags |= UV_WRITABLE_PIPE;

  return static_cast<uv_stdio_flags>(flags);
}",55,,205,1,,void
273849,BLOCK,-1,,<empty>,5,,210,2,,void
273855,BLOCK,-1,,<empty>,5,,212,2,,void
273866,BLOCK,-1,,"{
  CHECK_LT(lifecycle_, kClosing);
  return &uv_pipe_;
}",50,,218,1,,void
273876,BLOCK,-1,,"{
  return reinterpret_cast<uv_stream_t*>(uv_pipe());
}",54,,224,1,,void
273884,BLOCK,-1,,"{
  return reinterpret_cast<uv_handle_t*>(uv_pipe());
}",54,,229,1,,void
273892,BLOCK,-1,,"{
  SyncProcessOutputBuffer* buf;
  size_t size = 0;

  for (buf = first_output_buffer_; buf != nullptr; buf = buf->next())
    size += buf->used();

  return size;
}",51,,234,1,,void
273899,BLOCK,-1,,<empty>,3,,238,1,,void
273924,BLOCK,-1,,"{
  SyncProcessOutputBuffer* buf;
  size_t offset = 0;

  for (buf = first_output_buffer_; buf != nullptr; buf = buf->next())
    offset += buf->Copy(dest + offset);
}",57,,245,2,,void
273931,BLOCK,-1,,<empty>,3,,249,1,,void
273958,BLOCK,-1,,"{
  // This function assumes that libuv will never allocate two buffers for the
  // same stream at the same time. There's an assert in
  // SyncProcessOutputBuffer::OnRead that would fail if this assumption was
  // ever violated.

  if (last_output_buffer_ == nullptr) {
    // Allocate the first capture buffer.
    first_output_buffer_ = new SyncProcessOutputBuffer();
    last_output_buffer_ = first_output_buffer_;

  } else if (last_output_buffer_->available() == 0) {
    // The current capture buffer is full so get us a new one.
    SyncProcessOutputBuffer* buf = new SyncProcessOutputBuffer();
    last_output_buffer_->set_next(buf);
    last_output_buffer_ = buf;
  }

  last_output_buffer_->OnAlloc(suggested_size, buf);
}",74,,254,3,,void
273963,BLOCK,-1,,"{
    // Allocate the first capture buffer.
    first_output_buffer_ = new SyncProcessOutputBuffer();
    last_output_buffer_ = first_output_buffer_;

  }",39,,260,2,,void
273972,BLOCK,-1,,<empty>,10,,265,1,,void
273980,BLOCK,-1,,"{
    // The current capture buffer is full so get us a new one.
    SyncProcessOutputBuffer* buf = new SyncProcessOutputBuffer();
    last_output_buffer_->set_next(buf);
    last_output_buffer_ = buf;
  }",53,,265,2,,void
274005,BLOCK,-1,,"{
  if (nread == UV_EOF) {
    // Libuv implicitly stops reading on EOF.

  } else if (nread < 0) {
    SetError(static_cast<int>(nread));
    // At some point libuv should really implicitly stop reading on error.
    uv_read_stop(uv_stream());

  } else {
    last_output_buffer_->OnRead(buf, nread);
    process_handler_->IncrementBufferSizeAndCheckOverflow(nread);
  }
}",71,,276,3,,void
274010,BLOCK,-1,,"{
    // Libuv implicitly stops reading on EOF.

  }",24,,277,2,,void
274012,BLOCK,-1,,<empty>,10,,280,1,,void
274017,BLOCK,-1,,"{
    SetError(static_cast<int>(nread));
    // At some point libuv should really implicitly stop reading on error.
    uv_read_stop(uv_stream());

  }",25,,280,2,,void
274024,BLOCK,-1,,"{
    last_output_buffer_->OnRead(buf, nread);
    process_handler_->IncrementBufferSizeAndCheckOverflow(nread);
  }",10,,285,1,,void
274040,BLOCK,-1,,"{
  if (result < 0)
    SetError(result);
}",52,,292,2,,void
274045,BLOCK,-1,,<empty>,5,,294,2,,void
274052,BLOCK,-1,,"{
  if (result < 0)
    SetError(result);
}",55,,298,2,,void
274057,BLOCK,-1,,<empty>,5,,300,2,,void
274063,BLOCK,-1,,"{
  lifecycle_ = kClosed;
}",38,,304,1,,void
274071,BLOCK,-1,,"{
  CHECK_NE(error, 0);
  process_handler_->SetPipeError(error);
}",48,,309,2,,void
274086,BLOCK,-1,,"{
  SyncProcessStdioPipe* self =
      reinterpret_cast<SyncProcessStdioPipe*>(handle->data);
  self->OnAlloc(suggested_size, buf);
}",57,,317,4,,void
274107,BLOCK,-1,,"{
  SyncProcessStdioPipe* self =
        reinterpret_cast<SyncProcessStdioPipe*>(stream->data);
  self->OnRead(buf, nread);
}",62,,326,4,,void
274127,BLOCK,-1,,"{
  SyncProcessStdioPipe* self =
      reinterpret_cast<SyncProcessStdioPipe*>(req->handle->data);
  self->OnWriteDone(result);
}",71,,333,3,,void
274148,BLOCK,-1,,"{
  SyncProcessStdioPipe* self =
      reinterpret_cast<SyncProcessStdioPipe*>(req->handle->data);

  // On AIX, OS X and the BSDs, calling shutdown() on one end of a pipe
  // when the other end has closed the connection fails with ENOTCONN.
  // Libuv is not the right place to handle that because it can't tell
  // if the error is genuine but we here can.
  if (result == UV_ENOTCONN)
    result = 0;

  self->OnShutdownDone(result);
}",77,,340,3,,void
274163,BLOCK,-1,,<empty>,5,,349,2,,void
274176,BLOCK,-1,,"{
  SyncProcessStdioPipe* self =
      reinterpret_cast<SyncProcessStdioPipe*>(handle->data);
  self->OnClose();
}",63,,355,2,,void
274196,BLOCK,-1,,"{
  SetMethod(context, target, ""spawn"", Spawn);
}",48,,365,5,,void
274206,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kChildProcess, """");
  env->PrintSyncTrace();
  SyncProcessRunner p(env);
  Local<Value> result;
  if (!p.Run(args[0]).ToLocal(&result)) return;
  args.GetReturnValue().Set(result);
}",72,,370,2,,void
274249,BLOCK,-1,,<empty>,41,,377,2,,void
274263,BLOCK,-1,,"{
}",17,,414,2,,void
274267,BLOCK,-1,,"{
  CHECK_EQ(lifecycle_, kHandlesClosed);

  stdio_pipes_.clear();
  delete[] file_buffer_;
  delete[] args_buffer_;
  delete[] cwd_buffer_;
  delete[] env_buffer_;
  delete[] uv_stdio_containers_;
}",41,,418,1,,void
274288,BLOCK,-1,,"{
  return env_;
}",45,,430,1,,void
274295,BLOCK,-1,,"{
  EscapableHandleScope scope(env()->isolate());

  CHECK_EQ(lifecycle_, kUninitialized);

  Maybe<bool> r = TryInitializeAndRunLoop(options);
  CloseHandlesAndDeleteLoop();
  if (r.IsNothing()) return MaybeLocal<Object>();

  Local<Object> result = BuildResultObject();

  return scope.Escape(result);
}",65,,434,2,,void
274316,BLOCK,-1,,<empty>,22,,441,2,,void
274336,BLOCK,-1,,"{
  int r;

  // There is no recovery from failure inside TryInitializeAndRunLoop - the
  // only option we'd have is to close all handles and destroy the loop.
  CHECK_EQ(lifecycle_, kUninitialized);
  lifecycle_ = kInitialized;

  uv_loop_ = new uv_loop_t;
  if (uv_loop_ == nullptr) {
    SetError(UV_ENOMEM);
    return Just(false);
  }

  r = uv_loop_init(uv_loop_);
  if (r < 0) {
    delete uv_loop_;
    uv_loop_ = nullptr;
    SetError(r);
    return Just(false);
  }

  if (!ParseOptions(options).To(&r)) return Nothing<bool>();

  if (r < 0) {
    SetError(r);
    return Just(false);
  }

  if (timeout_ > 0) {
    r = uv_timer_init(uv_loop_, &uv_timer_);
    if (r < 0) {
      SetError(r);
      return Just(false);
    }

    uv_unref(reinterpret_cast<uv_handle_t*>(&uv_timer_));

    uv_timer_.data = this;
    kill_timer_initialized_ = true;

    // Start the timer immediately. If uv_spawn fails then
    // CloseHandlesAndDeleteLoop() will immediately close the timer handle
   ...",78,,448,2,,void
274352,BLOCK,-1,,"{
    SetError(UV_ENOMEM);
    return Just(false);
  }",28,,457,2,,void
274365,BLOCK,-1,,"{
    delete uv_loop_;
    uv_loop_ = nullptr;
    SetError(r);
    return Just(false);
  }",14,,463,2,,void
274385,BLOCK,-1,,<empty>,38,,470,2,,void
274392,BLOCK,-1,,"{
    SetError(r);
    return Just(false);
  }",14,,472,2,,void
274402,BLOCK,-1,,"{
    r = uv_timer_init(uv_loop_, &uv_timer_);
    if (r < 0) {
      SetError(r);
      return Just(false);
    }

    uv_unref(reinterpret_cast<uv_handle_t*>(&uv_timer_));

    uv_timer_.data = this;
    kill_timer_initialized_ = true;

    // Start the timer immediately. If uv_spawn fails then
    // CloseHandlesAndDeleteLoop() will immediately close the timer handle
    // which implicitly stops it, so there is no risk that the timeout callback
    // runs when the process didn't start.
    r = uv_timer_start(&uv_timer_, KillTimerCallback, timeout_, 0);
    if (r < 0) {
      SetError(r);
      return Just(false);
    }
  }",21,,477,2,,void
274413,BLOCK,-1,,"{
      SetError(r);
      return Just(false);
    }",16,,479,2,,void
274444,BLOCK,-1,,"{
      SetError(r);
      return Just(false);
    }",16,,494,2,,void
274467,BLOCK,-1,,"{
    SetError(r);
    return Just(false);
  }",14,,502,2,,void
274481,BLOCK,-1,,"{
    if (pipe != nullptr) {
      r = pipe->Start();
      if (r < 0) {
        SetPipeError(r);
        return Just(false);
      }
    }
  }",41,,508,3,,void
274486,BLOCK,-1,,"{
      r = pipe->Start();
      if (r < 0) {
        SetPipeError(r);
        return Just(false);
      }
    }",26,,509,2,,void
274497,BLOCK,-1,,"{
        SetPipeError(r);
        return Just(false);
      }",18,,511,2,,void
274512,BLOCK,-1,,<empty>,5,,521,2,,void
274523,BLOCK,-1,,"{
  CHECK_LT(lifecycle_, kHandlesClosed);

  if (uv_loop_ != nullptr) {
    CloseStdioPipes();
    CloseKillTimer();
    // Close the process handle when ExitCallback was not called.
    uv_handle_t* uv_process_handle =
        reinterpret_cast<uv_handle_t*>(&uv_process_);

    // Close the process handle if it is still open. The handle type also
    // needs to be checked because TryInitializeAndRunLoop() won't spawn a
    // process if input validation fails.
    if (uv_process_handle->type == UV_PROCESS &&
        !uv_is_closing(uv_process_handle))
      uv_close(uv_process_handle, nullptr);

    // Give closing watchers a chance to finish closing and get their close
    // callbacks called.
    int r = uv_run(uv_loop_, UV_RUN_DEFAULT);
    if (r < 0)
      ABORT();

    CheckedUvLoopClose(uv_loop_);
    delete uv_loop_;
    uv_loop_ = nullptr;

  } else {
    // If the loop doesn't exist, neither should any pipes or timers.
    CHECK_EQ(false, stdio_pipes_initialized_);
    CHEC...",53,,529,1,,void
274531,BLOCK,-1,,"{
    CloseStdioPipes();
    CloseKillTimer();
    // Close the process handle when ExitCallback was not called.
    uv_handle_t* uv_process_handle =
        reinterpret_cast<uv_handle_t*>(&uv_process_);

    // Close the process handle if it is still open. The handle type also
    // needs to be checked because TryInitializeAndRunLoop() won't spawn a
    // process if input validation fails.
    if (uv_process_handle->type == UV_PROCESS &&
        !uv_is_closing(uv_process_handle))
      uv_close(uv_process_handle, nullptr);

    // Give closing watchers a chance to finish closing and get their close
    // callbacks called.
    int r = uv_run(uv_loop_, UV_RUN_DEFAULT);
    if (r < 0)
      ABORT();

    CheckedUvLoopClose(uv_loop_);
    delete uv_loop_;
    uv_loop_ = nullptr;

  }",28,,532,2,,void
274551,BLOCK,-1,,<empty>,7,,544,2,,void
274565,BLOCK,-1,,<empty>,7,,550,2,,void
274574,BLOCK,-1,,"{
    // If the loop doesn't exist, neither should any pipes or timers.
    CHECK_EQ(false, stdio_pipes_initialized_);
    CHECK_EQ(false, kill_timer_initialized_);
  }",10,,556,1,,void
274587,BLOCK,-1,,"{
  CHECK_LT(lifecycle_, kHandlesClosed);

  if (stdio_pipes_initialized_) {
    CHECK(!stdio_pipes_.empty());
    CHECK_NOT_NULL(uv_loop_);

    for (const auto& pipe : stdio_pipes_) {
      if (pipe)
        pipe->Close();
    }

    stdio_pipes_initialized_ = false;
  }
}",43,,566,1,,void
274593,BLOCK,-1,,"{
    CHECK(!stdio_pipes_.empty());
    CHECK_NOT_NULL(uv_loop_);

    for (const auto& pipe : stdio_pipes_) {
      if (pipe)
        pipe->Close();
    }

    stdio_pipes_initialized_ = false;
  }",33,,569,2,,void
274604,BLOCK,-1,,"{
      if (pipe)
        pipe->Close();
    }",43,,573,3,,void
274607,BLOCK,-1,,<empty>,9,,575,2,,void
274618,BLOCK,-1,,"{
  CHECK_LT(lifecycle_, kHandlesClosed);

  if (kill_timer_initialized_) {
    CHECK_GT(timeout_, 0);
    CHECK_NOT_NULL(uv_loop_);

    uv_handle_t* uv_timer_handle = reinterpret_cast<uv_handle_t*>(&uv_timer_);
    uv_ref(uv_timer_handle);
    uv_close(uv_timer_handle, KillTimerCloseCallback);

    kill_timer_initialized_ = false;
  }
}",42,,583,1,,void
274624,BLOCK,-1,,"{
    CHECK_GT(timeout_, 0);
    CHECK_NOT_NULL(uv_loop_);

    uv_handle_t* uv_timer_handle = reinterpret_cast<uv_handle_t*>(&uv_timer_);
    uv_ref(uv_timer_handle);
    uv_close(uv_timer_handle, KillTimerCloseCallback);

    kill_timer_initialized_ = false;
  }",32,,586,2,,void
274647,BLOCK,-1,,"{
  // Only attempt to kill once.
  if (killed_)
    return;
  killed_ = true;

  // We might get here even if the process we spawned has already exited. This
  // could happen when our child process spawned another process which
  // inherited (one of) the stdio pipes. In this case we won't attempt to send
  // a signal to the process, however we will still close our end of the stdio
  // pipes so this situation won't make us hang.
  if (exit_status_ < 0) {
    int r = uv_process_kill(&uv_process_, kill_signal_);

    // If uv_kill failed with an error that isn't ESRCH, the user probably
    // specified an invalid or unsupported signal. Signal this to the user as
    // and error and kill the process with SIGKILL instead.
    if (r < 0 && r != UV_ESRCH) {
      SetError(r);

      // Deliberately ignore the return value, we might not have
      // sufficient privileges to signal the child process.
      USE(uv_process_kill(&uv_process_, SIGKILL));
    }
  }

  // Close all stdio p...",32,,599,1,,void
274650,BLOCK,-1,,<empty>,5,,602,2,,void
274659,BLOCK,-1,,"{
    int r = uv_process_kill(&uv_process_, kill_signal_);

    // If uv_kill failed with an error that isn't ESRCH, the user probably
    // specified an invalid or unsupported signal. Signal this to the user as
    // and error and kill the process with SIGKILL instead.
    if (r < 0 && r != UV_ESRCH) {
      SetError(r);

      // Deliberately ignore the return value, we might not have
      // sufficient privileges to signal the child process.
      USE(uv_process_kill(&uv_process_, SIGKILL));
    }
  }",25,,610,2,,void
274675,BLOCK,-1,,"{
      SetError(r);

      // Deliberately ignore the return value, we might not have
      // sufficient privileges to signal the child process.
      USE(uv_process_kill(&uv_process_, SIGKILL));
    }",33,,616,2,,void
274689,BLOCK,-1,,"{
  buffered_output_size_ += length;

  if (max_buffer_ > 0 && buffered_output_size_ > max_buffer_) {
    SetError(UV_ENOBUFS);
    Kill();
  }
}",77,,633,2,,void
274701,BLOCK,-1,,"{
    SetError(UV_ENOBUFS);
    Kill();
  }",63,,636,2,,void
274709,BLOCK,-1,,"{
  if (exit_status < 0)
    return SetError(static_cast<int>(exit_status));

  exit_status_ = exit_status;
  term_signal_ = term_signal;
}",70,,643,3,,void
274714,BLOCK,-1,,<empty>,5,,645,2,,void
274729,BLOCK,-1,,"{
  SetError(UV_ETIMEDOUT);
  Kill();
}",46,,652,1,,void
274735,BLOCK,-1,,"{
  if (error_ != 0)
    return error_;
  else
    return pipe_error_;
}",35,,658,1,,void
274740,BLOCK,-1,,<empty>,5,,660,2,,void
274744,BLOCK,-1,,<empty>,5,,662,1,,void
274751,BLOCK,-1,,"{
  if (error_ == 0)
    error_ = error;
}",45,,666,2,,void
274756,BLOCK,-1,,<empty>,5,,668,2,,void
274764,BLOCK,-1,,"{
  if (pipe_error_ == 0)
    pipe_error_ = pipe_error;
}",54,,672,2,,void
274769,BLOCK,-1,,<empty>,5,,674,2,,void
274776,BLOCK,-1,,"{
  EscapableHandleScope scope(env()->isolate());
  Local<Context> context = env()->context();

  Local<Object> js_result = Object::New(env()->isolate());

  if (GetError() != 0) {
    js_result->Set(context, env()->error_string(),
                   Integer::New(env()->isolate(), GetError())).Check();
  }

  if (exit_status_ >= 0) {
    if (term_signal_ > 0) {
      js_result->Set(context, env()->status_string(),
                     Null(env()->isolate())).Check();
    } else {
      js_result->Set(context, env()->status_string(),
                     Number::New(env()->isolate(),
                                 static_cast<double>(exit_status_))).Check();
    }
  } else {
    // If exit_status_ < 0 the process was never started because of some error.
    js_result->Set(context, env()->status_string(),
                   Null(env()->isolate())).Check();
  }

  if (term_signal_ > 0)
    js_result->Set(context, env()->signal_string(),
                   String::NewFromUtf8(env()->i...",54,,678,1,,void
274811,BLOCK,-1,,"{
    js_result->Set(context, env()->error_string(),
                   Integer::New(env()->isolate(), GetError())).Check();
  }",24,,684,2,,void
274837,BLOCK,-1,,"{
    if (term_signal_ > 0) {
      js_result->Set(context, env()->status_string(),
                     Null(env()->isolate())).Check();
    } else {
      js_result->Set(context, env()->status_string(),
                     Number::New(env()->isolate(),
                                 static_cast<double>(exit_status_))).Check();
    }
  }",26,,689,2,,void
274842,BLOCK,-1,,"{
      js_result->Set(context, env()->status_string(),
                     Null(env()->isolate())).Check();
    }",27,,690,2,,void
274861,BLOCK,-1,,"{
      js_result->Set(context, env()->status_string(),
                     Number::New(env()->isolate(),
                                 static_cast<double>(exit_status_))).Check();
    }",12,,693,1,,void
274886,BLOCK,-1,,"{
    // If exit_status_ < 0 the process was never started because of some error.
    js_result->Set(context, env()->status_string(),
                   Null(env()->isolate())).Check();
  }",10,,698,1,,void
274908,BLOCK,-1,,<empty>,5,,705,2,,void
274935,BLOCK,-1,,<empty>,5,,711,1,,void
274957,BLOCK,-1,,<empty>,5,,715,2,,void
274972,BLOCK,-1,,<empty>,5,,718,1,,void
275022,BLOCK,-1,,"{
  CHECK_GE(lifecycle_, kInitialized);
  CHECK(!stdio_pipes_.empty());

  EscapableHandleScope scope(env()->isolate());
  MaybeStackBuffer<Local<Value>, 8> js_output(stdio_pipes_.size());

  for (uint32_t i = 0; i < stdio_pipes_.size(); i++) {
    SyncProcessStdioPipe* h = stdio_pipes_[i].get();
    if (h != nullptr && h->writable())
      js_output[i] = h->GetOutputAsBuffer(env());
    else
      js_output[i] = Null(env()->isolate());
  }

  return scope.Escape(
      Array::New(env()->isolate(), js_output.out(), js_output.length()));
}",52,,728,1,,void
275045,BLOCK,-1,,<empty>,3,,735,1,,void
275058,BLOCK,4,,"{
    SyncProcessStdioPipe* h = stdio_pipes_[i].get();
    if (h != nullptr && h->writable())
      js_output[i] = h->GetOutputAsBuffer(env());
    else
      js_output[i] = Null(env()->isolate());
  }",54,,735,4,,void
275077,BLOCK,-1,,<empty>,7,,738,2,,void
275088,BLOCK,-1,,<empty>,7,,740,1,,void
275123,BLOCK,-1,,"{
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  int r;

  if (!js_value->IsObject()) return Just<int>(UV_EINVAL);

  Local<Context> context = env()->context();
  Local<Object> js_options = js_value.As<Object>();

  Local<Value> js_file =
      js_options->Get(context, env()->file_string()).ToLocalChecked();
  if (!CopyJsString(js_file, &file_buffer_).To(&r)) return Nothing<int>();
  if (r < 0) return Just(r);
  uv_process_options_.file = file_buffer_;

  Local<Value> js_args =
      js_options->Get(context, env()->args_string()).ToLocalChecked();
  if (!CopyJsStringArray(js_args, &args_buffer_).To(&r)) return Nothing<int>();
  if (r < 0) return Just(r);
  uv_process_options_.args = reinterpret_cast<char**>(args_buffer_);

  Local<Value> js_cwd =
      js_options->Get(context, env()->cwd_string()).ToLocalChecked();
  if (IsSet(js_cwd)) {
    if (!CopyJsString(js_cwd, &cwd_buffer_).To(&r)) return Nothing<int>();
    if (r < 0) return Just(r);
    uv_process_op...",67,,747,2,,void
275141,BLOCK,-1,,<empty>,30,,752,2,,void
275194,BLOCK,-1,,<empty>,53,,759,2,,void
275201,BLOCK,-1,,<empty>,14,,760,2,,void
275239,BLOCK,-1,,<empty>,58,,765,2,,void
275246,BLOCK,-1,,<empty>,14,,766,2,,void
275276,BLOCK,-1,,<empty>,7,,771,1,,void
275278,BLOCK,-1,,"{
    if (!CopyJsString(js_cwd, &cwd_buffer_).To(&r)) return Nothing<int>();
    if (r < 0) return Just(r);
    uv_process_options_.cwd = cwd_buffer_;
  }",22,,771,2,,void
275290,BLOCK,-1,,<empty>,53,,772,2,,void
275297,BLOCK,-1,,<empty>,16,,773,2,,void
275325,BLOCK,-1,,<empty>,7,,779,1,,void
275327,BLOCK,-1,,"{
    if (!CopyJsStringArray(js_env_pairs, &env_buffer_).To(&r))
      return Nothing<int>();
    if (r < 0) return Just(r);

    uv_process_options_.env = reinterpret_cast<char**>(env_buffer_);
  }",28,,779,2,,void
275339,BLOCK,-1,,<empty>,7,,781,2,,void
275346,BLOCK,-1,,<empty>,16,,782,2,,void
275376,BLOCK,-1,,<empty>,7,,788,1,,void
275378,BLOCK,-1,,"{
    CHECK(js_uid->IsInt32());
    const int32_t uid = js_uid.As<Int32>()->Value();
    uv_process_options_.uid = static_cast<uv_uid_t>(uid);
    uv_process_options_.flags |= UV_PROCESS_SETUID;
  }",22,,788,2,,void
275425,BLOCK,-1,,<empty>,7,,797,1,,void
275427,BLOCK,-1,,"{
    CHECK(js_gid->IsInt32());
    const int32_t gid = js_gid.As<Int32>()->Value();
    uv_process_options_.gid = static_cast<uv_gid_t>(gid);
    uv_process_options_.flags |= UV_PROCESS_SETGID;
  }",22,,797,2,,void
275479,BLOCK,-1,,<empty>,5,,807,2,,void
275509,BLOCK,-1,,<empty>,5,,812,2,,void
275520,BLOCK,-1,,<empty>,5,,815,2,,void
275550,BLOCK,-1,,<empty>,5,,822,2,,void
275575,BLOCK,-1,,<empty>,7,,826,1,,void
275577,BLOCK,-1,,"{
    CHECK(js_timeout->IsNumber());
    int64_t timeout = js_timeout->IntegerValue(context).FromJust();
    timeout_ = static_cast<uint64_t>(timeout);
  }",26,,826,2,,void
275618,BLOCK,-1,,<empty>,7,,834,1,,void
275620,BLOCK,-1,,"{
    CHECK(js_max_buffer->IsNumber());
    max_buffer_ = js_max_buffer->NumberValue(context).FromJust();
  }",29,,834,2,,void
275655,BLOCK,-1,,<empty>,7,,841,1,,void
275657,BLOCK,-1,,"{
    CHECK(js_kill_signal->IsInt32());
    kill_signal_ = js_kill_signal.As<Int32>()->Value();
  }",30,,841,2,,void
275698,BLOCK,-1,,<empty>,14,,849,2,,void
275709,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());
  Local<Array> js_stdio_options;

  if (!js_value->IsArray())
    return UV_EINVAL;

  Local<Context> context = env()->context();
  js_stdio_options = js_value.As<Array>();

  stdio_count_ = js_stdio_options->Length();
  uv_stdio_containers_ = new uv_stdio_container_t[stdio_count_];

  stdio_pipes_.clear();
  stdio_pipes_.resize(stdio_count_);
  stdio_pipes_initialized_ = true;

  for (uint32_t i = 0; i < stdio_count_; i++) {
    Local<Value> js_stdio_option =
        js_stdio_options->Get(context, i).ToLocalChecked();

    if (!js_stdio_option->IsObject())
      return UV_EINVAL;

    int r = ParseStdioOption(i, js_stdio_option.As<Object>());
    if (r < 0)
      return r;
  }

  uv_process_options_.stdio = uv_stdio_containers_;
  uv_process_options_.stdio_count = stdio_count_;

  return 0;
}",65,,855,2,,void
275727,BLOCK,-1,,<empty>,5,,860,2,,void
275769,BLOCK,-1,,<empty>,3,,872,1,,void
275779,BLOCK,4,,"{
    Local<Value> js_stdio_option =
        js_stdio_options->Get(context, i).ToLocalChecked();

    if (!js_stdio_option->IsObject())
      return UV_EINVAL;

    int r = ParseStdioOption(i, js_stdio_option.As<Object>());
    if (r < 0)
      return r;
  }",47,,872,4,,void
275801,BLOCK,-1,,<empty>,7,,877,2,,void
275817,BLOCK,-1,,<empty>,7,,881,2,,void
275837,BLOCK,-1,,"{
  Local<Context> context = env()->context();
  Local<Value> js_type =
      js_stdio_option->Get(context, env()->type_string()).ToLocalChecked();

  if (js_type->StrictEquals(env()->ignore_string())) {
    return AddStdioIgnore(child_fd);

  } else if (js_type->StrictEquals(env()->pipe_string())) {
    Isolate* isolate = env()->isolate();
    Local<String> rs = env()->readable_string();
    Local<String> ws = env()->writable_string();

    bool readable = js_stdio_option->Get(context, rs)
        .ToLocalChecked()->BooleanValue(isolate);
    bool writable =
        js_stdio_option->Get(context, ws)
        .ToLocalChecked()->BooleanValue(isolate);

    uv_buf_t buf = uv_buf_init(nullptr, 0);

    if (readable) {
      Local<Value> input =
          js_stdio_option->Get(context, env()->input_string()).ToLocalChecked();
      if (Buffer::HasInstance(input)) {
        buf = uv_buf_init(Buffer::Data(input),
                          static_cast<unsigned int>(Buffer::Length(input)));
 ...",72,,892,3,,void
275875,BLOCK,-1,,"{
    return AddStdioIgnore(child_fd);

  }",54,,897,2,,void
275880,BLOCK,-1,,<empty>,10,,900,1,,void
275890,BLOCK,-1,,"{
    Isolate* isolate = env()->isolate();
    Local<String> rs = env()->readable_string();
    Local<String> ws = env()->writable_string();

    bool readable = js_stdio_option->Get(context, rs)
        .ToLocalChecked()->BooleanValue(isolate);
    bool writable =
        js_stdio_option->Get(context, ws)
        .ToLocalChecked()->BooleanValue(isolate);

    uv_buf_t buf = uv_buf_init(nullptr, 0);

    if (readable) {
      Local<Value> input =
          js_stdio_option->Get(context, env()->input_string()).ToLocalChecked();
      if (Buffer::HasInstance(input)) {
        buf = uv_buf_init(Buffer::Data(input),
                          static_cast<unsigned int>(Buffer::Length(input)));
      } else if (!input->IsUndefined() && !input->IsNull()) {
        // Strings, numbers etc. are currently unsupported. It's not possible
        // to create a buffer for them here because there is no way to free
        // them afterwards.
        return UV_EINVAL;
      }
    }

    return AddSt...",59,,900,2,,void
275958,BLOCK,-1,,"{
      Local<Value> input =
          js_stdio_option->Get(context, env()->input_string()).ToLocalChecked();
      if (Buffer::HasInstance(input)) {
        buf = uv_buf_init(Buffer::Data(input),
                          static_cast<unsigned int>(Buffer::Length(input)));
      } else if (!input->IsUndefined() && !input->IsNull()) {
        // Strings, numbers etc. are currently unsupported. It's not possible
        // to create a buffer for them here because there is no way to free
        // them afterwards.
        return UV_EINVAL;
      }
    }",19,,913,2,,void
275978,BLOCK,-1,,<empty>,11,,916,1,,void
275980,BLOCK,-1,,"{
        buf = uv_buf_init(Buffer::Data(input),
                          static_cast<unsigned int>(Buffer::Length(input)));
      }",39,,916,2,,void
275997,BLOCK,-1,,<empty>,14,,919,1,,void
276010,BLOCK,-1,,"{
        // Strings, numbers etc. are currently unsupported. It's not possible
        // to create a buffer for them here because there is no way to free
        // them afterwards.
        return UV_EINVAL;
      }",61,,919,2,,void
276020,BLOCK,-1,,<empty>,10,,929,1,,void
276039,BLOCK,-1,,"{
    int inherit_fd = js_stdio_option->Get(context, env()->fd_string())
        .ToLocalChecked()->Int32Value(context).FromJust();
    return AddStdioInheritFD(child_fd, inherit_fd);

  }",57,,930,2,,void
276067,BLOCK,-1,,"{
    UNREACHABLE(""invalid child stdio type"");
  }",10,,935,1,,void
276074,BLOCK,-1,,"{
  CHECK_LT(child_fd, stdio_count_);
  CHECK(!stdio_pipes_[child_fd]);

  uv_stdio_containers_[child_fd].flags = UV_IGNORE;

  return 0;
}",58,,941,2,,void
276099,BLOCK,-1,,"{
  CHECK_LT(child_fd, stdio_count_);
  CHECK(!stdio_pipes_[child_fd]);

  std::unique_ptr<SyncProcessStdioPipe> h(
      new SyncProcessStdioPipe(this, readable, writable, input_buffer));

  int r = h->Initialize(uv_loop_);
  if (r < 0) {
    h.reset();
    return r;
  }

  uv_stdio_containers_[child_fd].flags = h->uv_flags();
  uv_stdio_containers_[child_fd].data.stream = h->uv_stream();

  stdio_pipes_[child_fd] = std::move(h);

  return 0;
}",60,,954,5,,void
276133,BLOCK,-1,,"{
    h.reset();
    return r;
  }",14,,962,2,,void
276178,BLOCK,-1,,"{
  CHECK_LT(child_fd, stdio_count_);
  CHECK(!stdio_pipes_[child_fd]);

  uv_stdio_containers_[child_fd].flags = UV_INHERIT_FD;
  uv_stdio_containers_[child_fd].data.fd = inherit_fd;

  return 0;
}",77,,976,3,,void
276209,BLOCK,-1,,"{
  return !value->IsUndefined() && !value->IsNull();
}",51,,987,2,,void
276227,BLOCK,-1,,"{
  Isolate* isolate = env()->isolate();
  Local<String> js_string;
  size_t size, written;
  char* buffer;

  if (js_value->IsString())
    js_string = js_value.As<String>();
  else if (!js_value->ToString(env()->isolate()->GetCurrentContext())
                .ToLocal(&js_string))
    return Nothing<int>();

  // Include space for null terminator byte.
  if (!StringBytes::StorageSize(isolate, js_string, UTF8).To(&size))
    return Nothing<int>();
  size += 1;

  buffer = new char[size];

  written = StringBytes::Write(isolate, buffer, -1, js_string, UTF8);
  buffer[written] = '\0';

  *target = buffer;
  return Just(0);
}",65,,992,3,,void
276248,BLOCK,-1,,<empty>,5,,999,2,,void
276256,BLOCK,-1,,<empty>,8,,1000,1,,void
276275,BLOCK,-1,,<empty>,5,,1002,2,,void
276292,BLOCK,-1,,<empty>,5,,1006,2,,void
276331,BLOCK,-1,,"{
  Isolate* isolate = env()->isolate();
  Local<Array> js_array;
  uint32_t length;
  size_t list_size, data_size, data_offset;
  char** list;
  char* buffer;

  if (!js_value->IsArray()) return Just<int>(UV_EINVAL);

  Local<Context> context = env()->context();
  js_array = js_value.As<Array>()->Clone().As<Array>();
  length = js_array->Length();
  data_size = 0;

  // Index has a pointer to every string element, plus one more for a final
  // null pointer.
  list_size = (length + 1) * sizeof *list;

  // Convert all array elements to string. Modify the js object itself if
  // needed - it's okay since we cloned the original object. Also compute the
  // length of all strings, including room for a null terminator after every
  // string. Align strings to cache lines.
  for (uint32_t i = 0; i < length; i++) {
    auto value = js_array->Get(context, i).ToLocalChecked();

    if (!value->IsString()) {
      Local<String> string;
      if (!value->ToString(env()->isolate()->GetCurrent...",64,,1019,3,,void
276356,BLOCK,-1,,<empty>,29,,1027,2,,void
276401,BLOCK,-1,,<empty>,3,,1042,1,,void
276411,BLOCK,4,,"{
    auto value = js_array->Get(context, i).ToLocalChecked();

    if (!value->IsString()) {
      Local<String> string;
      if (!value->ToString(env()->isolate()->GetCurrentContext())
               .ToLocal(&string))
        return Nothing<int>();
      js_array
          ->Set(context,
                i,
                string)
          .Check();
    }

    Maybe<size_t> maybe_size = StringBytes::StorageSize(isolate, value, UTF8);
    if (maybe_size.IsNothing()) return Nothing<int>();
    data_size += maybe_size.FromJust() + 1;
    data_size = RoundUp(data_size, sizeof(void*));
  }",41,,1042,4,,void
276430,BLOCK,-1,,"{
      Local<String> string;
      if (!value->ToString(env()->isolate()->GetCurrentContext())
               .ToLocal(&string))
        return Nothing<int>();
      js_array
          ->Set(context,
                i,
                string)
          .Check();
    }",29,,1045,2,,void
276454,BLOCK,-1,,<empty>,9,,1049,2,,void
276485,BLOCK,-1,,<empty>,33,,1058,2,,void
276515,BLOCK,-1,,<empty>,3,,1068,1,,void
276525,BLOCK,4,,"{
    list[i] = buffer + data_offset;
    auto value = js_array->Get(context, i).ToLocalChecked();
    data_offset += StringBytes::Write(isolate,
                                      buffer + data_offset,
                                      -1,
                                      value,
                                      UTF8);
    buffer[data_offset++] = '\0';
    data_offset = RoundUp(data_offset, sizeof(void*));
  }",41,,1068,4,,void
276589,BLOCK,-1,,"{
  SyncProcessRunner* self = reinterpret_cast<SyncProcessRunner*>(handle->data);
  uv_close(reinterpret_cast<uv_handle_t*>(handle), nullptr);
  self->OnExit(exit_status, term_signal);
}",55,,1089,4,,void
276613,BLOCK,-1,,"{
  SyncProcessRunner* self = reinterpret_cast<SyncProcessRunner*>(handle->data);
  self->OnKillTimerTimeout();
}",63,,1096,2,,void
276630,BLOCK,-1,,"{
  // No-op.
}",69,,1102,2,,void
276644,BLOCK,-1,,<empty>,1,,1,1,,ANY
276659,BLOCK,-1,,<empty>,1,,1,1,,ANY
276690,BLOCK,-1,,<empty>,1,,1,1,,ANY
276694,BLOCK,-1,,"{
  Environment* env = stream_env();

  v8::HandleScope handle_scope(env->isolate());

  if (req_wrap_obj.IsEmpty()) {
    if (!env->shutdown_wrap_template()
             ->NewInstance(env->context())
             .ToLocal(&req_wrap_obj)) {
      return UV_EBUSY;
    }
    StreamReq::ResetObject(req_wrap_obj);
  }

  BaseObjectPtr<AsyncWrap> req_wrap_ptr;
  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(GetAsyncWrap());
  ShutdownWrap* req_wrap = CreateShutdownWrap(req_wrap_obj);
  if (req_wrap != nullptr) req_wrap_ptr.reset(req_wrap->GetAsyncWrap());
  int err = DoShutdown(req_wrap);

  if (err != 0 && req_wrap != nullptr) {
    req_wrap->Dispose();
  }

  const char* msg = Error();
  if (msg != nullptr) {
    if (req_wrap_obj
            ->Set(env->context(),
                  env->error_string(),
                  OneByteString(env->isolate(), msg))
            .IsNothing()) {
      return UV_EBUSY;
    }
    ClearError();
  }

  return err;
}",62,,43,2,,void
276710,BLOCK,-1,,"{
    if (!env->shutdown_wrap_template()
             ->NewInstance(env->context())
             .ToLocal(&req_wrap_obj)) {
      return UV_EBUSY;
    }
    StreamReq::ResetObject(req_wrap_obj);
  }",31,,48,2,,void
276729,BLOCK,-1,,"{
      return UV_EBUSY;
    }",39,,51,2,,void
276754,BLOCK,-1,,<empty>,28,,60,2,,void
276776,BLOCK,-1,,"{
    req_wrap->Dispose();
  }",40,,63,2,,void
276789,BLOCK,-1,,"{
    if (req_wrap_obj
            ->Set(env->context(),
                  env->error_string(),
                  OneByteString(env->isolate(), msg))
            .IsNothing()) {
      return UV_EBUSY;
    }
    ClearError();
  }",23,,68,2,,void
276812,BLOCK,-1,,"{
      return UV_EBUSY;
    }",27,,73,2,,void
276826,BLOCK,-1,,"{
  Environment* env = stream_env();
  int err;

  size_t total_bytes = 0;
  for (size_t i = 0; i < count; ++i) total_bytes += bufs[i].len;
  bytes_written_ += total_bytes;

  if (send_handle == nullptr && !skip_try_write) {
    err = DoTryWrite(&bufs, &count);
    if (err != 0 || count == 0) {
      return StreamWriteResult{false, err, nullptr, total_bytes, {}};
    }
  }

  v8::HandleScope handle_scope(env->isolate());

  if (req_wrap_obj.IsEmpty()) {
    if (!env->write_wrap_template()
             ->NewInstance(env->context())
             .ToLocal(&req_wrap_obj)) {
      return StreamWriteResult{false, UV_EBUSY, nullptr, 0, {}};
    }
    StreamReq::ResetObject(req_wrap_obj);
  }

  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(GetAsyncWrap());
  WriteWrap* req_wrap = CreateWriteWrap(req_wrap_obj);
  BaseObjectPtr<AsyncWrap> req_wrap_ptr(req_wrap->GetAsyncWrap());

  err = DoWrite(req_wrap, bufs, count, send_handle);
  bool async = err == 0;

  if (!async) {
    req_wrap...",58,,86,6,,void
276837,BLOCK,-1,,<empty>,3,,91,1,,void
276864,BLOCK,-1,,"{
    err = DoTryWrite(&bufs, &count);
    if (err != 0 || count == 0) {
      return StreamWriteResult{false, err, nullptr, total_bytes, {}};
    }
  }",50,,94,2,,void
276880,BLOCK,-1,,"{
      return StreamWriteResult{false, err, nullptr, total_bytes, {}};
    }",33,,96,2,,void
276900,BLOCK,-1,,"{
    if (!env->write_wrap_template()
             ->NewInstance(env->context())
             .ToLocal(&req_wrap_obj)) {
      return StreamWriteResult{false, UV_EBUSY, nullptr, 0, {}};
    }
    StreamReq::ResetObject(req_wrap_obj);
  }",31,,103,2,,void
276919,BLOCK,-1,,"{
      return StreamWriteResult{false, UV_EBUSY, nullptr, 0, {}};
    }",39,,106,2,,void
276966,BLOCK,-1,,"{
    req_wrap->Dispose();
    req_wrap = nullptr;
  }",15,,119,2,,void
276982,BLOCK,-1,,"{
    if (req_wrap_obj
            ->Set(env->context(),
                  env->error_string(),
                  OneByteString(env->isolate(), msg))
            .IsNothing()) {
      return StreamWriteResult{false, UV_EBUSY, nullptr, 0, {}};
    }
    ClearError();
  }",23,,125,2,,void
277005,BLOCK,-1,,"{
      return StreamWriteResult{false, UV_EBUSY, nullptr, 0, {}};
    }",27,,130,2,,void
277031,BLOCK,-1,,"{
  return ReadStart();
}",70,,150,2,,void
277038,BLOCK,-1,,"{
  return ReadStop();
}",69,,155,2,,void
277045,BLOCK,-1,,"{
  CHECK(Buffer::HasInstance(args[0]));

  uv_buf_t buf = uv_buf_init(Buffer::Data(args[0]), Buffer::Length(args[0]));
  PushStreamListener(new CustomBufferJSListener(buf));
  return 0;
}",72,,159,2,,void
277082,BLOCK,-1,,"{
  CHECK(args[0]->IsObject());
  Local<Object> req_wrap_obj = args[0].As<Object>();

  return Shutdown(req_wrap_obj);
}",67,,167,2,,void
277109,BLOCK,-1,,"{
  env_->stream_base_state()[kBytesWritten] = res.bytes;
  env_->stream_base_state()[kLastWriteWasAsync] = res.async;
}",63,,174,2,,void
277134,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();

  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsArray());

  Local<Object> req_wrap_obj = args[0].As<Object>();
  Local<Array> chunks = args[1].As<Array>();
  bool all_buffers = args[2]->IsTrue();

  size_t count;
  if (all_buffers)
    count = chunks->Length();
  else
    count = chunks->Length() >> 1;

  MaybeStackBuffer<uv_buf_t, 16> bufs(count);

  size_t storage_size = 0;
  size_t offset;

  if (!all_buffers) {
    // Determine storage size first
    for (size_t i = 0; i < count; i++) {
      Local<Value> chunk;
      if (!chunks->Get(context, i * 2).ToLocal(&chunk))
        return -1;

      if (Buffer::HasInstance(chunk))
        continue;
        // Buffer chunk, no additional storage required

      // String chunk
      Local<String> string;
      if (!chunk->ToString(context).ToLocal(&string))
        return -1;
      Local<Value> next_ch...",65,,179,2,,void
277210,BLOCK,-1,,<empty>,5,,193,2,,void
277218,BLOCK,-1,,<empty>,5,,195,1,,void
277243,BLOCK,-1,,"{
    // Determine storage size first
    for (size_t i = 0; i < count; i++) {
      Local<Value> chunk;
      if (!chunks->Get(context, i * 2).ToLocal(&chunk))
        return -1;

      if (Buffer::HasInstance(chunk))
        continue;
        // Buffer chunk, no additional storage required

      // String chunk
      Local<String> string;
      if (!chunk->ToString(context).ToLocal(&string))
        return -1;
      Local<Value> next_chunk;
      if (!chunks->Get(context, i * 2 + 1).ToLocal(&next_chunk))
        return -1;
      enum encoding encoding = ParseEncoding(isolate, next_chunk);
      size_t chunk_size;
      if ((encoding == UTF8 &&
             string->Length() > 65535 &&
             !StringBytes::Size(isolate, string, encoding).To(&chunk_size)) ||
              !StringBytes::StorageSize(isolate, string, encoding)
                  .To(&chunk_size)) {
        return -1;
      }
      storage_size += chunk_size;
    }

    if (storage_size > INT_MAX)
      return UV_E...",21,,202,2,,void
277245,BLOCK,-1,,<empty>,5,,204,1,,void
277255,BLOCK,4,,"{
      Local<Value> chunk;
      if (!chunks->Get(context, i * 2).ToLocal(&chunk))
        return -1;

      if (Buffer::HasInstance(chunk))
        continue;
        // Buffer chunk, no additional storage required

      // String chunk
      Local<String> string;
      if (!chunk->ToString(context).ToLocal(&string))
        return -1;
      Local<Value> next_chunk;
      if (!chunks->Get(context, i * 2 + 1).ToLocal(&next_chunk))
        return -1;
      enum encoding encoding = ParseEncoding(isolate, next_chunk);
      size_t chunk_size;
      if ((encoding == UTF8 &&
             string->Length() > 65535 &&
             !StringBytes::Size(isolate, string, encoding).To(&chunk_size)) ||
              !StringBytes::StorageSize(isolate, string, encoding)
                  .To(&chunk_size)) {
        return -1;
      }
      storage_size += chunk_size;
    }",40,,204,4,,void
277276,BLOCK,-1,,<empty>,9,,207,2,,void
277281,BLOCK,-1,,<empty>,11,,209,1,,void
277283,BLOCK,-1,,<empty>,9,,210,2,,void
277302,BLOCK,-1,,<empty>,9,,216,2,,void
277328,BLOCK,-1,,<empty>,9,,219,2,,void
277378,BLOCK,-1,,"{
        return -1;
      }",37,,226,2,,void
277389,BLOCK,-1,,<empty>,7,,233,2,,void
277393,BLOCK,-1,,"{
    for (size_t i = 0; i < count; i++) {
      Local<Value> chunk;
      if (!chunks->Get(context, i).ToLocal(&chunk))
        return -1;
      bufs[i].base = Buffer::Data(chunk);
      bufs[i].len = Buffer::Length(chunk);
    }
  }",10,,234,1,,void
277395,BLOCK,-1,,<empty>,5,,235,1,,void
277405,BLOCK,4,,"{
      Local<Value> chunk;
      if (!chunks->Get(context, i).ToLocal(&chunk))
        return -1;
      bufs[i].base = Buffer::Data(chunk);
      bufs[i].len = Buffer::Length(chunk);
    }",40,,235,4,,void
277424,BLOCK,-1,,<empty>,9,,238,2,,void
277461,BLOCK,-1,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(isolate, storage_size);
  }",25,,245,2,,void
277482,BLOCK,-1,,"{
    for (size_t i = 0; i < count; i++) {
      Local<Value> chunk;
      if (!chunks->Get(context, i * 2).ToLocal(&chunk))
        return -1;

      // Write buffer
      if (Buffer::HasInstance(chunk)) {
        bufs[i].base = Buffer::Data(chunk);
        bufs[i].len = Buffer::Length(chunk);
        continue;
      }

      // Write string
      CHECK_LE(offset, storage_size);
      char* str_storage =
          static_cast<char*>(bs ? bs->Data() : nullptr) + offset;
      size_t str_size = (bs ? bs->ByteLength() : 0) - offset;

      Local<String> string;
      if (!chunk->ToString(context).ToLocal(&string))
        return -1;
      Local<Value> next_chunk;
      if (!chunks->Get(context, i * 2 + 1).ToLocal(&next_chunk))
        return -1;
      enum encoding encoding = ParseEncoding(isolate, next_chunk);
      str_size = StringBytes::Write(isolate,
                                    str_storage,
                                    str_size,
                                    ...",21,,251,2,,void
277484,BLOCK,-1,,<empty>,5,,252,1,,void
277494,BLOCK,4,,"{
      Local<Value> chunk;
      if (!chunks->Get(context, i * 2).ToLocal(&chunk))
        return -1;

      // Write buffer
      if (Buffer::HasInstance(chunk)) {
        bufs[i].base = Buffer::Data(chunk);
        bufs[i].len = Buffer::Length(chunk);
        continue;
      }

      // Write string
      CHECK_LE(offset, storage_size);
      char* str_storage =
          static_cast<char*>(bs ? bs->Data() : nullptr) + offset;
      size_t str_size = (bs ? bs->ByteLength() : 0) - offset;

      Local<String> string;
      if (!chunk->ToString(context).ToLocal(&string))
        return -1;
      Local<Value> next_chunk;
      if (!chunks->Get(context, i * 2 + 1).ToLocal(&next_chunk))
        return -1;
      enum encoding encoding = ParseEncoding(isolate, next_chunk);
      str_size = StringBytes::Write(isolate,
                                    str_storage,
                                    str_size,
                                    string,
                                 ...",40,,252,4,,void
277515,BLOCK,-1,,<empty>,9,,255,2,,void
277520,BLOCK,-1,,<empty>,11,,258,1,,void
277522,BLOCK,-1,,"{
        bufs[i].base = Buffer::Data(chunk);
        bufs[i].len = Buffer::Length(chunk);
        continue;
      }",39,,258,2,,void
277592,BLOCK,-1,,<empty>,9,,272,2,,void
277618,BLOCK,-1,,<empty>,9,,275,2,,void
277677,BLOCK,-1,,<empty>,5,,291,2,,void
277697,BLOCK,-1,,"{
  CHECK(args[0]->IsObject());

  Environment* env = Environment::GetCurrent(args);

  if (!args[1]->IsUint8Array()) {
    node::THROW_ERR_INVALID_ARG_TYPE(env, ""Second argument must be a buffer"");
    return 0;
  }

  Local<Object> req_wrap_obj = args[0].As<Object>();
  uv_buf_t buf;
  buf.base = Buffer::Data(args[1]);
  buf.len = Buffer::Length(args[1]);

  uv_stream_t* send_handle = nullptr;

  if (args[2]->IsObject() && IsIPCPipe()) {
    Local<Object> send_handle_obj = args[2].As<Object>();

    HandleWrap* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, send_handle_obj, UV_EINVAL);
    send_handle = reinterpret_cast<uv_stream_t*>(wrap->GetHandle());
    // Reference LibuvStreamWrap instance to prevent it from being garbage
    // collected before `AfterWrite` is called.
    if (req_wrap_obj->Set(env->context(),
                          env->handle_string(),
                          send_handle_obj).IsNothing()) {
      return -1;
    }
  }

  StreamWriteResult res = Write(&buf, 1,...",70,,296,2,,void
277721,BLOCK,-1,,"{
    node::THROW_ERR_INVALID_ARG_TYPE(env, ""Second argument must be a buffer"");
    return 0;
  }",33,,301,2,,void
277778,BLOCK,-1,,"{
    Local<Object> send_handle_obj = args[2].As<Object>();

    HandleWrap* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, send_handle_obj, UV_EINVAL);
    send_handle = reinterpret_cast<uv_stream_t*>(wrap->GetHandle());
    // Reference LibuvStreamWrap instance to prevent it from being garbage
    // collected before `AfterWrite` is called.
    if (req_wrap_obj->Set(env->context(),
                          env->handle_string(),
                          send_handle_obj).IsNothing()) {
      return -1;
    }
  }",43,,313,2,,void
277822,BLOCK,-1,,"{
      return -1;
    }",57,,323,2,,void
277845,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsString());

  Local<Object> req_wrap_obj = args[0].As<Object>();
  Local<String> string = args[1].As<String>();
  Local<Object> send_handle_obj;
  if (args[2]->IsObject())
    send_handle_obj = args[2].As<Object>();

  // Compute the size of the storage that the string will be flattened into.
  // For UTF8 strings that are very long, go ahead and take the hit for
  // computing their actual size, rather than tripling the storage.
  size_t storage_size;
  if ((enc == UTF8 &&
         string->Length() > 65535 &&
         !StringBytes::Size(isolate, string, enc).To(&storage_size)) ||
          !StringBytes::StorageSize(isolate, string, enc).To(&storage_size)) {
    return -1;
  }

  if (storage_size > INT_MAX)
    return UV_ENOBUFS;

  // Try writing immediately if write size isn't too big
  char stack_storage[16384];  // 16kb
  size_t data_size;
 ...",70,,336,2,,void
277911,BLOCK,-1,,<empty>,5,,346,2,,void
277960,BLOCK,-1,,"{
    return -1;
  }",78,,355,2,,void
277968,BLOCK,-1,,<empty>,5,,360,2,,void
277995,BLOCK,-1,,"{
    data_size = StringBytes::Write(isolate,
                                   stack_storage,
                                   storage_size,
                                   string,
                                   enc);
    buf = uv_buf_init(stack_storage, data_size);

    uv_buf_t* bufs = &buf;
    size_t count = 1;
    const int err = DoTryWrite(&bufs, &count);
    // Keep track of the bytes written here, because we're taking a shortcut
    // by using `DoTryWrite()` directly instead of using the utilities
    // provided by `Write()`.
    synchronously_written = count == 0 ? data_size : data_size - buf.len;
    bytes_written_ += synchronously_written;

    // Immediate failure or success
    if (err != 0 || count == 0) {
      SetWriteResult(StreamWriteResult { false, err, nullptr, data_size, {} });
      return err;
    }

    // Partial write
    CHECK_EQ(count, 1);
  }",18,,370,2,,void
278052,BLOCK,-1,,"{
      SetWriteResult(StreamWriteResult { false, err, nullptr, data_size, {} });
      return err;
    }",33,,388,2,,void
278075,BLOCK,-1,,"{
    // Copy partial data
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(isolate, buf.len);
    memcpy(static_cast<char*>(bs->Data()), buf.base, buf.len);
    data_size = buf.len;
  }",18,,399,2,,void
278111,BLOCK,-1,,"{
    // Write it
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(isolate, storage_size);
    data_size = StringBytes::Write(isolate,
                                   static_cast<char*>(bs->Data()),
                                   storage_size,
                                   string,
                                   enc);
  }",10,,405,1,,void
278167,BLOCK,-1,,"{
    HandleWrap* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, send_handle_obj, UV_EINVAL);
    send_handle = reinterpret_cast<uv_stream_t*>(wrap->GetHandle());
    // Reference LibuvStreamWrap instance to prevent it from being garbage
    // collected before `AfterWrite` is called.
    if (req_wrap_obj->Set(env->context(),
                          env->handle_string(),
                          send_handle_obj).IsNothing()) {
      return -1;
    }
  }",50,,422,2,,void
278199,BLOCK,-1,,"{
      return -1;
    }",57,,430,2,,void
278226,BLOCK,-1,,<empty>,5,,440,2,,void
278249,BLOCK,-1,,"{
  Environment* env = env_;

  DCHECK_EQ(static_cast<int32_t>(nread), nread);
  DCHECK_LE(offset, INT32_MAX);

  if (checks == DONT_SKIP_NREAD_CHECKS) {
    if (ab.IsEmpty()) {
      DCHECK_EQ(offset, 0);
      DCHECK_LE(nread, 0);
    } else {
      DCHECK_GE(nread, 0);
    }
  }

  env->stream_base_state()[kReadBytesOrError] = static_cast<int32_t>(nread);
  env->stream_base_state()[kArrayBufferOffset] = offset;

  Local<Value> argv[] = {
    ab.IsEmpty() ? Undefined(env->isolate()).As<Value>() : ab.As<Value>()
  };

  AsyncWrap* wrap = GetAsyncWrap();
  CHECK_NOT_NULL(wrap);
  Local<Value> onread = wrap->object()->GetInternalField(
      StreamBase::kOnReadFunctionField);
  CHECK(onread->IsFunction());
  return wrap->MakeCallback(onread.As<Function>(), arraysize(argv), argv);
}",77,,449,5,,void
278266,BLOCK,-1,,"{
    if (ab.IsEmpty()) {
      DCHECK_EQ(offset, 0);
      DCHECK_LE(nread, 0);
    } else {
      DCHECK_GE(nread, 0);
    }
  }",41,,455,2,,void
278272,BLOCK,-1,,"{
      DCHECK_EQ(offset, 0);
      DCHECK_LE(nread, 0);
    }",23,,456,2,,void
278280,BLOCK,-1,,"{
      DCHECK_GE(nread, 0);
    }",12,,459,1,,void
278365,BLOCK,-1,,"{
  return false;
}",30,,480,1,,void
278371,BLOCK,-1,,"{
  return -1;
}",25,,485,1,,void
278378,BLOCK,-1,,"{
  return GetAsyncWrap()->object();
}",39,,490,1,,void
278393,BLOCK,-1,,"{
  Local<FunctionTemplate> templ =
      NewFunctionTemplate(isolate,
                          stream_method,
                          signature,
                          ConstructorBehavior::kThrow,
                          SideEffectType::kHasNoSideEffect);
  t->PrototypeTemplate()->SetAccessorProperty(
      string, templ, Local<FunctionTemplate>(), attributes);
}",50,,499,7,,void
278426,BLOCK,-1,,"{
  AddMethods(env->isolate_data(), t);
}",74,,510,3,,void
278438,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();
  HandleScope scope(isolate);

  enum PropertyAttribute attributes =
      static_cast<PropertyAttribute>(ReadOnly | DontDelete | DontEnum);
  Local<Signature> sig = Signature::New(isolate, t);

  AddMethod(isolate, sig, attributes, t, GetFD, isolate_data->fd_string());
  AddMethod(isolate,
            sig,
            attributes,
            t,
            GetExternal,
            isolate_data->external_stream_string());
  AddMethod(isolate,
            sig,
            attributes,
            t,
            GetBytesRead,
            isolate_data->bytes_read_string());
  AddMethod(isolate,
            sig,
            attributes,
            t,
            GetBytesWritten,
            isolate_data->bytes_written_string());
  SetProtoMethod(isolate, t, ""readStart"", JSMethod<&StreamBase::ReadStartJS>);
  SetProtoMethod(isolate, t, ""readStop"", JSMethod<&StreamBase::ReadStopJS>);
  SetProtoMethod(isolate, t, ""shutdown"", JSMethod<&StreamBa...",56,,515,3,,void
278593,BLOCK,-1,,"{
  // This function is called by a single thread during start up, so it is safe
  // to use a local static variable here.
  static bool is_registered = false;
  if (is_registered) return;
  registry->Register(GetFD);
  registry->Register(GetExternal);
  registry->Register(GetBytesRead);
  registry->Register(GetBytesWritten);
  registry->Register(JSMethod<&StreamBase::ReadStartJS>);
  registry->Register(JSMethod<&StreamBase::ReadStopJS>);
  registry->Register(JSMethod<&StreamBase::Shutdown>);
  registry->Register(JSMethod<&StreamBase::UseUserBuffer>);
  registry->Register(JSMethod<&StreamBase::Writev>);
  registry->Register(JSMethod<&StreamBase::WriteBuffer>);
  registry->Register(JSMethod<&StreamBase::WriteString<ASCII>>);
  registry->Register(JSMethod<&StreamBase::WriteString<UTF8>>);
  registry->Register(JSMethod<&StreamBase::WriteString<UCS2>>);
  registry->Register(JSMethod<&StreamBase::WriteString<LATIN1>>);
  registry->Register(
      BaseObject::InternalFieldGet<StreamBase::...",42,,571,2,,void
278600,BLOCK,-1,,<empty>,22,,575,2,,void
278693,BLOCK,-1,,"{
  // Mimic implementation of StreamBase::GetFD() and UDPWrap::GetFD().
  StreamBase* wrap = StreamBase::FromObject(args.This().As<Object>());
  if (wrap == nullptr) return args.GetReturnValue().Set(UV_EINVAL);

  if (!wrap->IsAlive()) return args.GetReturnValue().Set(UV_EINVAL);

  args.GetReturnValue().Set(wrap->GetFD());
}",65,,598,2,,void
278712,BLOCK,-1,,<empty>,24,,601,2,,void
278728,BLOCK,-1,,<empty>,25,,603,2,,void
278753,BLOCK,-1,,"{
  StreamBase* wrap = StreamBase::FromObject(args.This().As<Object>());
  if (wrap == nullptr) return args.GetReturnValue().Set(0);

  // uint64_t -> double. 53bits is enough for all real cases.
  args.GetReturnValue().Set(static_cast<double>(wrap->bytes_read_));
}",72,,608,2,,void
278772,BLOCK,-1,,<empty>,24,,610,2,,void
278798,BLOCK,-1,,"{
  StreamBase* wrap = StreamBase::FromObject(args.This().As<Object>());
  if (wrap == nullptr) return args.GetReturnValue().Set(0);

  // uint64_t -> double. 53bits is enough for all real cases.
  args.GetReturnValue().Set(static_cast<double>(wrap->bytes_written_));
}",75,,616,2,,void
278817,BLOCK,-1,,<empty>,24,,618,2,,void
278843,BLOCK,-1,,"{
  StreamBase* wrap = StreamBase::FromObject(args.This().As<Object>());
  if (wrap == nullptr) return;

  Local<External> ext = External::New(args.GetIsolate(), wrap);
  args.GetReturnValue().Set(ext);
}",71,,624,2,,void
278862,BLOCK,-1,,<empty>,24,,626,2,,void
278891,BLOCK,-1,,"{
  StreamBase* wrap = StreamBase::FromObject(args.Holder().As<Object>());
  if (wrap == nullptr) return;

  if (!wrap->IsAlive()) return args.GetReturnValue().Set(UV_EINVAL);

  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(wrap->GetAsyncWrap());
  args.GetReturnValue().Set((wrap->*Method)(args));
}",68,,633,2,,void
278910,BLOCK,-1,,<empty>,24,,635,2,,void
278918,BLOCK,-1,,<empty>,25,,637,2,,void
278951,BLOCK,-1,,"{
  // No TryWrite by default
  return 0;
}",64,,643,3,,void
278957,BLOCK,-1,,"{
  return nullptr;
}",43,,649,1,,void
278963,BLOCK,-1,,"{
  // No-op
}",35,,654,1,,void
278968,BLOCK,-1,,"{
  CHECK_NOT_NULL(stream_);
  Environment* env = static_cast<StreamBase*>(stream_)->stream_env();
  return env->allocate_managed_buffer(suggested_size);
}",71,,659,2,,void
278990,BLOCK,-1,,"{
  CHECK_NOT_NULL(stream_);
  StreamBase* stream = static_cast<StreamBase*>(stream_);
  Environment* env = stream->stream_env();
  Isolate* isolate = env->isolate();
  HandleScope handle_scope(isolate);
  Context::Scope context_scope(env->context());
  std::unique_ptr<BackingStore> bs = env->release_managed_buffer(buf_);

  if (nread <= 0)  {
    if (nread < 0)
      stream->CallJSOnreadMethod(nread, Local<ArrayBuffer>());
    return;
  }

  CHECK_LE(static_cast<size_t>(nread), bs->ByteLength());
  bs = BackingStore::Reallocate(isolate, std::move(bs), nread);

  stream->CallJSOnreadMethod(nread, ArrayBuffer::New(isolate, std::move(bs)));
}",80,,665,3,,void
279038,BLOCK,-1,,"{
    if (nread < 0)
      stream->CallJSOnreadMethod(nread, Local<ArrayBuffer>());
    return;
  }",20,,674,2,,void
279043,BLOCK,-1,,<empty>,7,,676,2,,void
279091,BLOCK,-1,,"{
  return buffer_;
}",71,,687,2,,void
279099,BLOCK,-1,,"{
  CHECK_NOT_NULL(stream_);

  StreamBase* stream = static_cast<StreamBase*>(stream_);
  Environment* env = stream->stream_env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  // In the case that there's an error and buf is null, return immediately.
  // This can happen on unices when POLLHUP is received and UV_EOF is returned
  // or when getting an error while performing a UV_HANDLE_ZERO_READ on Windows.
  if (buf.base == nullptr && nread < 0) {
    stream->CallJSOnreadMethod(nread, Local<ArrayBuffer>());
    return;
  }

  CHECK_EQ(buf.base, buffer_.base);

  MaybeLocal<Value> ret = stream->CallJSOnreadMethod(nread,
                             Local<ArrayBuffer>(),
                             0,
                             StreamBase::SKIP_NREAD_CHECKS);
  Local<Value> next_buf_v;
  if (ret.ToLocal(&next_buf_v) && !next_buf_v->IsUndefined()) {
    buffer_.base = Buffer::Data(next_buf_v);
    buffer_.len = Buffer::Length(next_bu...",79,,692,3,,void
279136,BLOCK,-1,,"{
    stream->CallJSOnreadMethod(nread, Local<ArrayBuffer>());
    return;
  }",41,,703,2,,void
279185,BLOCK,-1,,"{
    buffer_.base = Buffer::Data(next_buf_v);
    buffer_.len = Buffer::Length(next_buf_v);
  }",63,,715,2,,void
279209,BLOCK,-1,,"{
  StreamBase* stream = static_cast<StreamBase*>(stream_);
  Environment* env = stream->stream_env();
  if (!env->can_call_into_js()) return;
  AsyncWrap* async_wrap = req_wrap->GetAsyncWrap();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());
  CHECK(!async_wrap->persistent().IsEmpty());
  Local<Object> req_wrap_obj = async_wrap->object();

  Local<Value> argv[] = {
    Integer::New(env->isolate(), status),
    stream->GetObject(),
    Undefined(env->isolate())
  };

  const char* msg = stream->Error();
  if (msg != nullptr) {
    argv[2] = OneByteString(env->isolate(), msg);
    stream->ClearError();
  }

  if (req_wrap_obj->Has(env->context(), env->oncomplete_string()).FromJust())
    async_wrap->MakeCallback(env->oncomplete_string(), arraysize(argv), argv);
}",38,,723,3,,void
279229,BLOCK,-1,,<empty>,33,,726,2,,void
279302,BLOCK,-1,,"{
    argv[2] = OneByteString(env->isolate(), msg);
    stream->ClearError();
  }",23,,740,2,,void
279333,BLOCK,-1,,<empty>,5,,746,2,,void
279350,BLOCK,-1,,"{
  OnStreamAfterReqFinished(req_wrap, status);
}",38,,750,3,,void
279359,BLOCK,-1,,"{
  OnStreamAfterReqFinished(req_wrap, status);
}",41,,755,3,,void
279367,BLOCK,-1,,"{
  stream()->EmitAfterShutdown(this, status);
  Dispose();
}",39,,759,2,,void
279379,BLOCK,-1,,"{
  stream()->EmitAfterWrite(this, status);
  Dispose();
}",36,,764,2,,void
279390,BLOCK,-1,,"{
  if (stream_ != nullptr)
    stream_->RemoveStreamListener(this);
}",35,,769,1,,void
279395,BLOCK,-1,,<empty>,5,,771,2,,void
279406,BLOCK,-1,,"{
  CHECK_NOT_NULL(previous_listener_);
  previous_listener_->OnStreamAfterShutdown(w, status);
}",73,,774,3,,void
279419,BLOCK,-1,,"{
  CHECK_NOT_NULL(previous_listener_);
  previous_listener_->OnStreamAfterWrite(w, status);
}",67,,779,3,,void
279430,BLOCK,-1,,"{
  while (listener_ != nullptr) {
    StreamListener* listener = listener_;
    listener->OnStreamDestroy();
    // Remove the listener if it didn’t remove itself. This makes the logic
    // in `OnStreamDestroy()` implementations easier, because they
    // may call generic cleanup functions which can just remove the
    // listener unconditionally.
    if (listener == listener_)
      RemoveStreamListener(listener_);
  }
}",35,,784,1,,void
279435,BLOCK,-1,,"{
    StreamListener* listener = listener_;
    listener->OnStreamDestroy();
    // Remove the listener if it didn’t remove itself. This makes the logic
    // in `OnStreamDestroy()` implementations easier, because they
    // may call generic cleanup functions which can just remove the
    // listener unconditionally.
    if (listener == listener_)
      RemoveStreamListener(listener_);
  }",32,,785,2,,void
279448,BLOCK,-1,,<empty>,7,,793,2,,void
279454,BLOCK,-1,,"{
  CHECK_NOT_NULL(listener);

  StreamListener* previous;
  StreamListener* current;

  // Remove from the linked list.
  // No loop condition because we want a crash if listener is not found.
  for (current = listener_, previous = nullptr;;
       previous = current, current = current->previous_listener_) {
    CHECK_NOT_NULL(current);
    if (current == listener) {
      if (previous != nullptr)
        previous->previous_listener_ = current->previous_listener_;
      else
        listener_ = listener->previous_listener_;
      break;
    }
  }

  listener->stream_ = nullptr;
  listener->previous_listener_ = nullptr;
}",69,,797,2,,void
279460,BLOCK,-1,,<empty>,3,,805,1,,void
279477,BLOCK,4,,"{
    CHECK_NOT_NULL(current);
    if (current == listener) {
      if (previous != nullptr)
        previous->previous_listener_ = current->previous_listener_;
      else
        listener_ = listener->previous_listener_;
      break;
    }
  }",67,,806,4,,void
279484,BLOCK,-1,,"{
      if (previous != nullptr)
        previous->previous_listener_ = current->previous_listener_;
      else
        listener_ = listener->previous_listener_;
      break;
    }",30,,808,2,,void
279489,BLOCK,-1,,<empty>,9,,810,2,,void
279498,BLOCK,-1,,<empty>,9,,812,1,,void
279519,BLOCK,-1,,"{
  auto* wrap = new SimpleShutdownWrap<AsyncWrap>(this, object);
  wrap->MakeWeak();
  return wrap;
}",27,,822,2,,void
279537,BLOCK,-1,,"{
  auto* wrap = new SimpleWriteWrap<AsyncWrap>(this, object);
  wrap->MakeWeak();
  return wrap;
}",27,,829,2,,void
279556,BLOCK,-1,,"{
  AsyncWrap* async_wrap = GetAsyncWrap();
  Environment* env = async_wrap->env();
  if (error_str != nullptr) {
    v8::HandleScope handle_scope(env->isolate());
    if (async_wrap->object()
            ->Set(env->context(),
                  env->error_string(),
                  OneByteString(env->isolate(), error_str))
            .IsNothing()) {
      return;
    }
  }

  OnDone(status);
}",57,,835,3,,void
279572,BLOCK,-1,,"{
    v8::HandleScope handle_scope(env->isolate());
    if (async_wrap->object()
            ->Set(env->context(),
                  env->error_string(),
                  OneByteString(env->isolate(), error_str))
            .IsNothing()) {
      return;
    }
  }",29,,838,2,,void
279604,BLOCK,-1,,"{
      return;
    }",27,,844,2,,void
279624,BLOCK,-1,,<empty>,1,,1,1,,ANY
279628,BLOCK,-1,,"{
    HandleScope handle_scope(env->isolate());
    Context::Scope context_scope(env->context());
    Local<Object> object = this->object();

    Local<Value> onunpipe;
    if (!object->Get(env->context(), env->onunpipe_string()).ToLocal(&onunpipe))
      return;
    if (onunpipe->IsFunction() &&
        MakeCallback(onunpipe.As<Function>(), 0, nullptr).IsEmpty()) {
      return;
    }

    // Set all the links established in the constructor to `null`.
    Local<Value> null = Null(env->isolate());

    Local<Value> source_v;
    Local<Value> sink_v;
    if (!object->Get(env->context(), env->source_string()).ToLocal(&source_v) ||
        !object->Get(env->context(), env->sink_string()).ToLocal(&sink_v) ||
        !source_v->IsObject() || !sink_v->IsObject()) {
      return;
    }

    if (object->Set(env->context(), env->source_string(), null).IsNothing() ||
        object->Set(env->context(), env->sink_string(), null).IsNothing() ||
        source_v.As<Object>()
            ->Set(en...",60,,71,2,,void
279675,BLOCK,-1,,<empty>,7,,78,2,,void
279693,BLOCK,-1,,"{
      return;
    }",70,,80,2,,void
279766,BLOCK,-1,,"{
      return;
    }",55,,91,2,,void
279842,BLOCK,-1,,"{
      return;
    }",27,,102,2,,void
279858,BLOCK,-1,,<empty>,1,,1,1,,ANY
279864,BLOCK,-1,,"{
  MakeWeak();

  CHECK_NOT_NULL(sink);
  CHECK_NOT_NULL(source);

  source->PushStreamListener(&readable_listener_);
  sink->PushStreamListener(&writable_listener_);

  uses_wants_write_ = sink->HasWantsWrite();
}",76,,25,4,,void
279891,BLOCK,-1,,"{
  Unpipe(true);
}",27,,37,1,,void
279897,BLOCK,-1,,"{
  return static_cast<StreamBase*>(readable_listener_.stream());
}",34,,41,1,,void
279908,BLOCK,-1,,"{
  return static_cast<StreamBase*>(writable_listener_.stream());
}",32,,45,1,,void
279920,BLOCK,-1,,"{
  if (is_closed_)
    return;

  // Note that we possibly cannot use virtual methods on `source` and `sink`
  // here, because this function can be called from their destructors via
  // `OnStreamDestroy()`.
  if (!source_destroyed_)
    source()->ReadStop();

  is_closed_ = true;
  is_reading_ = false;
  source()->RemoveStreamListener(&readable_listener_);
  if (pending_writes_ == 0)
    sink()->RemoveStreamListener(&writable_listener_);

  if (is_in_deletion) return;

  // Delay the JS-facing part with SetImmediate, because this might be from
  // inside the garbage collector, so we can’t run JS here.
  HandleScope handle_scope(env()->isolate());
  BaseObjectPtr<StreamPipe> strong_ref{this};
  env()->SetImmediate([this, strong_ref](Environment* env) {
    HandleScope handle_scope(env->isolate());
    Context::Scope context_scope(env->context());
    Local<Object> object = this->object();

    Local<Value> onunpipe;
    if (!object->Get(env->context(), env->onunpipe_string()).ToL...",46,,49,2,,void
279923,BLOCK,-1,,<empty>,5,,51,2,,void
279928,BLOCK,-1,,<empty>,5,,57,2,,void
279949,BLOCK,-1,,<empty>,5,,63,2,,void
279958,BLOCK,-1,,<empty>,23,,65,2,,void
279982,BLOCK,-1,,"{
  StreamPipe* pipe = ContainerOf(&StreamPipe::readable_listener_, this);
  size_t size = std::min(suggested_size, pipe->wanted_data_);
  CHECK_GT(size, 0);
  return pipe->env()->allocate_managed_buffer(size);
}",77,,108,2,,void
280020,BLOCK,-1,,"{
  StreamPipe* pipe = ContainerOf(&StreamPipe::readable_listener_, this);
  std::unique_ptr<BackingStore> bs = pipe->env()->release_managed_buffer(buf_);
  if (nread < 0) {
    // EOF or error; stop reading and pass the error to the previous listener
    // (which might end up in JS).
    pipe->is_eof_ = true;
    // Cache `sink()` here because the previous listener might do things
    // that eventually lead to an `Unpipe()` call.
    StreamBase* sink = pipe->sink();
    stream()->ReadStop();
    CHECK_NOT_NULL(previous_listener_);
    previous_listener_->OnStreamRead(nread, uv_buf_init(nullptr, 0));
    // If we’re not writing, close now. Otherwise, we’ll do that in
    // `OnStreamAfterWrite()`.
    if (pipe->pending_writes_ == 0) {
      sink->Shutdown();
      pipe->Unpipe();
    }
    return;
  }

  pipe->ProcessData(nread, std::move(bs));
}",71,,116,3,,void
280050,BLOCK,-1,,"{
    // EOF or error; stop reading and pass the error to the previous listener
    // (which might end up in JS).
    pipe->is_eof_ = true;
    // Cache `sink()` here because the previous listener might do things
    // that eventually lead to an `Unpipe()` call.
    StreamBase* sink = pipe->sink();
    stream()->ReadStop();
    CHECK_NOT_NULL(previous_listener_);
    previous_listener_->OnStreamRead(nread, uv_buf_init(nullptr, 0));
    // If we’re not writing, close now. Otherwise, we’ll do that in
    // `OnStreamAfterWrite()`.
    if (pipe->pending_writes_ == 0) {
      sink->Shutdown();
      pipe->Unpipe();
    }
    return;
  }",18,,119,2,,void
280082,BLOCK,-1,,"{
      sink->Shutdown();
      pipe->Unpipe();
    }",37,,131,2,,void
280107,BLOCK,-1,,"{
  CHECK(uses_wants_write_ || pending_writes_ == 0);
  uv_buf_t buffer = uv_buf_init(static_cast<char*>(bs->Data()), nread);
  StreamWriteResult res = sink()->Write(&buffer, 1);
  pending_writes_++;
  if (!res.async) {
    writable_listener_.OnStreamAfterWrite(nullptr, res.err);
  } else {
    is_reading_ = false;
    res.wrap->SetBackingStore(std::move(bs));
    if (source() != nullptr)
      source()->ReadStop();
  }
}",64,,142,3,,void
280142,BLOCK,-1,,"{
    writable_listener_.OnStreamAfterWrite(nullptr, res.err);
  }",19,,147,2,,void
280152,BLOCK,-1,,"{
    is_reading_ = false;
    res.wrap->SetBackingStore(std::move(bs));
    if (source() != nullptr)
      source()->ReadStop();
  }",10,,149,1,,void
280171,BLOCK,-1,,<empty>,7,,153,2,,void
280181,BLOCK,-1,,"{
  StreamPipe* pipe = ContainerOf(&StreamPipe::writable_listener_, this);
  pipe->pending_writes_--;
  if (pipe->is_closed_) {
    if (pipe->pending_writes_ == 0) {
      Environment* env = pipe->env();
      HandleScope handle_scope(env->isolate());
      Context::Scope context_scope(env->context());
      if (pipe->MakeCallback(env->oncomplete_string(), 0, nullptr).IsEmpty())
        return;
      stream()->RemoveStreamListener(this);
    }
    return;
  }

  if (pipe->is_eof_) {
    HandleScope handle_scope(pipe->env()->isolate());
    InternalCallbackScope callback_scope(pipe,
        InternalCallbackScope::kSkipTaskQueues);
    pipe->sink()->Shutdown();
    pipe->Unpipe();
    return;
  }

  if (status != 0) {
    CHECK_NOT_NULL(previous_listener_);
    StreamListener* prev = previous_listener_;
    pipe->Unpipe();
    prev->OnStreamAfterWrite(w, status);
    return;
  }

  if (!pipe->uses_wants_write_) {
    OnStreamWantsWrite(65536);
  }
}",67,,158,3,,void
280199,BLOCK,-1,,"{
    if (pipe->pending_writes_ == 0) {
      Environment* env = pipe->env();
      HandleScope handle_scope(env->isolate());
      Context::Scope context_scope(env->context());
      if (pipe->MakeCallback(env->oncomplete_string(), 0, nullptr).IsEmpty())
        return;
      stream()->RemoveStreamListener(this);
    }
    return;
  }",25,,161,2,,void
280206,BLOCK,-1,,"{
      Environment* env = pipe->env();
      HandleScope handle_scope(env->isolate());
      Context::Scope context_scope(env->context());
      if (pipe->MakeCallback(env->oncomplete_string(), 0, nullptr).IsEmpty())
        return;
      stream()->RemoveStreamListener(this);
    }",37,,162,2,,void
280240,BLOCK,-1,,<empty>,9,,167,2,,void
280252,BLOCK,-1,,"{
    HandleScope handle_scope(pipe->env()->isolate());
    InternalCallbackScope callback_scope(pipe,
        InternalCallbackScope::kSkipTaskQueues);
    pipe->sink()->Shutdown();
    pipe->Unpipe();
    return;
  }",22,,173,2,,void
280284,BLOCK,-1,,"{
    CHECK_NOT_NULL(previous_listener_);
    StreamListener* prev = previous_listener_;
    pipe->Unpipe();
    prev->OnStreamAfterWrite(w, status);
    return;
  }",20,,182,2,,void
280306,BLOCK,-1,,"{
    OnStreamWantsWrite(65536);
  }",33,,190,2,,void
280314,BLOCK,-1,,"{
  StreamPipe* pipe = ContainerOf(&StreamPipe::writable_listener_, this);
  CHECK_NOT_NULL(previous_listener_);
  StreamListener* prev = previous_listener_;
  pipe->Unpipe();
  prev->OnStreamAfterShutdown(w, status);
}",70,,196,3,,void
280342,BLOCK,-1,,"{
  StreamPipe* pipe = ContainerOf(&StreamPipe::readable_listener_, this);
  pipe->source_destroyed_ = true;
  if (!pipe->is_eof_) {
    OnStreamRead(UV_EPIPE, uv_buf_init(nullptr, 0));
  }
}",54,,204,1,,void
280362,BLOCK,-1,,"{
    OnStreamRead(UV_EPIPE, uv_buf_init(nullptr, 0));
  }",23,,207,2,,void
280371,BLOCK,-1,,"{
  StreamPipe* pipe = ContainerOf(&StreamPipe::writable_listener_, this);
  pipe->sink_destroyed_ = true;
  pipe->is_eof_ = true;
  pipe->pending_writes_ = 0;
  pipe->Unpipe();
}",54,,212,1,,void
280404,BLOCK,-1,,"{
  StreamPipe* pipe = ContainerOf(&StreamPipe::writable_listener_, this);
  pipe->wanted_data_ = suggested_size;
  if (pipe->is_reading_ || pipe->is_closed_)
    return;
  HandleScope handle_scope(pipe->env()->isolate());
  InternalCallbackScope callback_scope(pipe,
      InternalCallbackScope::kSkipTaskQueues);
  pipe->is_reading_ = true;
  pipe->source()->ReadStart();
}",78,,220,2,,void
280427,BLOCK,-1,,<empty>,5,,224,2,,void
280460,BLOCK,-1,,"{
  CHECK_NOT_NULL(previous_listener_);
  return previous_listener_->OnStreamAlloc(suggested_size);
}",77,,232,2,,void
280473,BLOCK,-1,,"{
  CHECK_NOT_NULL(previous_listener_);
  return previous_listener_->OnStreamRead(nread, buf);
}",70,,238,3,,void
280488,BLOCK,-1,,"{
  std::unique_ptr<StreamPipe> stream_pipe(new StreamPipe(source, sink, obj));

  // Set up links between this object and the source/sink objects.
  // In particular, this makes sure that they are garbage collected as a group,
  // if that applies to the given streams (for example, Http2Streams use
  // weak references).
  Environment* env = source->stream_env();
  if (obj->Set(env->context(), env->source_string(), source->GetObject())
          .IsNothing()) {
    return Nothing<StreamPipe*>();
  }
  if (source->GetObject()
          ->Set(env->context(), env->pipe_target_string(), obj)
          .IsNothing()) {
    return Nothing<StreamPipe*>();
  }
  if (obj->Set(env->context(), env->sink_string(), sink->GetObject())
          .IsNothing()) {
    return Nothing<StreamPipe*>();
  }
  if (sink->GetObject()
          ->Set(env->context(), env->pipe_source_string(), obj)
          .IsNothing()) {
    return Nothing<StreamPipe*>();
  }

  return Just(stream_pipe.release());
}",55,,245,4,,void
280528,BLOCK,-1,,"{
    return Nothing<StreamPipe*>();
  }",25,,254,2,,void
280551,BLOCK,-1,,"{
    return Nothing<StreamPipe*>();
  }",25,,259,2,,void
280574,BLOCK,-1,,"{
    return Nothing<StreamPipe*>();
  }",25,,263,2,,void
280597,BLOCK,-1,,"{
    return Nothing<StreamPipe*>();
  }",25,,268,2,,void
280610,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsObject());
  StreamBase* source = StreamBase::FromObject(args[0].As<Object>());
  StreamBase* sink = StreamBase::FromObject(args[1].As<Object>());

  if (StreamPipe::New(source, sink, args.This()).IsNothing()) return;
}",63,,275,2,,void
280670,BLOCK,-1,,<empty>,63,,282,2,,void
280676,BLOCK,-1,,"{
  StreamPipe* pipe;
  ASSIGN_OR_RETURN_UNWRAP(&pipe, args.Holder());
  pipe->is_closed_ = false;
  pipe->writable_listener_.OnStreamWantsWrite(65536);
}",65,,285,2,,void
280701,BLOCK,-1,,"{
  StreamPipe* pipe;
  ASSIGN_OR_RETURN_UNWRAP(&pipe, args.Holder());
  pipe->Unpipe();
}",66,,292,2,,void
280718,BLOCK,-1,,"{
  StreamPipe* pipe;
  ASSIGN_OR_RETURN_UNWRAP(&pipe, args.Holder());
  args.GetReturnValue().Set(pipe->is_closed_);
}",68,,298,2,,void
280741,BLOCK,-1,,"{
  StreamPipe* pipe;
  ASSIGN_OR_RETURN_UNWRAP(&pipe, args.Holder());
  args.GetReturnValue().Set(pipe->pending_writes_);
}",73,,304,2,,void
280768,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  // Create FunctionTemplate for FileHandle::CloseReq
  Local<FunctionTemplate> pipe = NewFunctionTemplate(isolate, StreamPipe::New);
  SetProtoMethod(isolate, pipe, ""unpipe"", StreamPipe::Unpipe);
  SetProtoMethod(isolate, pipe, ""start"", StreamPipe::Start);
  SetProtoMethod(isolate, pipe, ""isClosed"", StreamPipe::IsClosed);
  SetProtoMethod(isolate, pipe, ""pendingWrites"", StreamPipe::PendingWrites);
  pipe->Inherit(AsyncWrap::GetConstructorTemplate(env));
  pipe->InstanceTemplate()->SetInternalFieldCount(
      StreamPipe::kInternalFieldCount);
  SetConstructorFunction(context, target, ""StreamPipe"", pipe);
}",39,,315,5,,void
280856,BLOCK,-1,,<empty>,1,,1,1,,ANY
280862,BLOCK,-1,,"{
        static_cast<LibuvStreamWrap*>(handle->data)
            ->OnUvAlloc(suggested_size, buf);
      }",69,,205,4,,void
280881,BLOCK,-1,,"{
        LibuvStreamWrap* wrap = static_cast<LibuvStreamWrap*>(stream->data);
        TryCatchScope try_catch(wrap->env());
        try_catch.SetVerbose(true);
        wrap->OnUvRead(nread, buf);
      }",67,,209,4,,void
280940,BLOCK,-1,,<empty>,1,,1,1,,ANY
280944,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  StreamReq::ResetObject(args.This());
}",71,,61,2,,void
280965,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> sw =
      NewFunctionTemplate(isolate, IsConstructCallCallback);
  sw->InstanceTemplate()->SetInternalFieldCount(StreamReq::kInternalFieldCount);

  // we need to set handle and callback to null,
  // so that those fields are created and functions
  // do not become megamorphic
  // Fields:
  // - oncomplete
  // - callback
  // - handle
  sw->InstanceTemplate()->Set(env->oncomplete_string(), v8::Null(isolate));
  sw->InstanceTemplate()->Set(FIXED_ONE_BYTE_STRING(isolate, ""callback""),
                              v8::Null(isolate));
  sw->InstanceTemplate()->Set(FIXED_ONE_BYTE_STRING(isolate, ""handle""),
                              v8::Null(isolate));

  sw->Inherit(AsyncWrap::GetConstructorTemplate(env));

  SetConstructorFunction(context, target, ""ShutdownWrap"", sw);
  env->set_shutdown_wrap_template(sw->InstanceTemplate());

  Local<FunctionTemplate> ww =
  ...",46,,69,5,,void
281117,BLOCK,1,,<empty>,,,,7,,void
281119,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kReadBytesOrError)",3,,103,1,,void
281216,BLOCK,1,,<empty>,,,,7,,void
281218,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kArrayBufferOffset)",3,,104,1,,void
281315,BLOCK,1,,<empty>,,,,7,,void
281317,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kBytesWritten)",3,,105,1,,void
281414,BLOCK,1,,<empty>,,,,7,,void
281416,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kLastWriteWasAsync)",3,,106,1,,void
281530,BLOCK,-1,,"{
  registry->Register(IsConstructCallCallback);
  registry->Register(GetWriteQueueSize);
  registry->Register(SetBlocking);
  StreamBase::RegisterExternalReferences(registry);
}",42,,115,2,,void
281558,BLOCK,-1,,"{
  StreamBase::AttachToObject(object);
}",23,,131,5,,void
281568,BLOCK,-1,,"{
  Local<FunctionTemplate> tmpl = env->libuv_stream_wrap_ctor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(isolate, ""LibuvStreamWrap""));
    tmpl->Inherit(HandleWrap::GetConstructorTemplate(env));
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        StreamBase::kInternalFieldCount);
    Local<FunctionTemplate> get_write_queue_size =
        FunctionTemplate::New(isolate,
                              GetWriteQueueSize,
                              Local<Value>(),
                              Signature::New(isolate, tmpl));
    tmpl->PrototypeTemplate()->SetAccessorProperty(
        env->write_queue_size_string(),
        get_write_queue_size,
        Local<FunctionTemplate>(),
        static_cast<PropertyAttribute>(ReadOnly | DontDelete));
    SetProtoMethod(isolate, tmpl, ""setBlocking"", SetBlocking);
    StreamBase::AddMethods(env, tmpl);
    env->...",23,,137,2,,void
281584,BLOCK,-1,,"{
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(isolate, ""LibuvStreamWrap""));
    tmpl->Inherit(HandleWrap::GetConstructorTemplate(env));
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        StreamBase::kInternalFieldCount);
    Local<FunctionTemplate> get_write_queue_size =
        FunctionTemplate::New(isolate,
                              GetWriteQueueSize,
                              Local<Value>(),
                              Signature::New(isolate, tmpl));
    tmpl->PrototypeTemplate()->SetAccessorProperty(
        env->write_queue_size_string(),
        get_write_queue_size,
        Local<FunctionTemplate>(),
        static_cast<PropertyAttribute>(ReadOnly | DontDelete));
    SetProtoMethod(isolate, tmpl, ""setBlocking"", SetBlocking);
    StreamBase::AddMethods(env, tmpl);
    env->set_libuv_stream_wrap_ctor_template(tmpl);
  }",23,,139,2,,void
281683,BLOCK,-1,,"{
  Local<FunctionTemplate> sw = env->libuv_stream_wrap_ctor_template();
  CHECK(!sw.IsEmpty() && sw->HasInstance(object));
  return Unwrap<LibuvStreamWrap>(object);
}",80,,164,3,,void
281715,BLOCK,-1,,"{
#ifdef _WIN32
  return fd_;
#else
  int fd = -1;
  if (stream() != nullptr)
    uv_fileno(reinterpret_cast<uv_handle_t*>(stream()), &fd);
  return fd;
#endif
}",30,,171,1,,void
281725,BLOCK,-1,,<empty>,5,,177,2,,void
281737,BLOCK,-1,,"{
  return HandleWrap::IsAlive(this);
}",33,,183,1,,void
281747,BLOCK,-1,,"{
  return uv_is_closing(reinterpret_cast<uv_handle_t*>(stream()));
}",35,,188,1,,void
281756,BLOCK,-1,,"{
  return static_cast<AsyncWrap*>(this);
}",44,,193,1,,void
281764,BLOCK,-1,,"{
  return is_named_pipe_ipc();
}",35,,198,1,,void
281770,BLOCK,-1,,"{
  return uv_read_start(
      stream(),
      [](uv_handle_t* handle, size_t suggested_size, uv_buf_t* buf) {
        static_cast<LibuvStreamWrap*>(handle->data)
            ->OnUvAlloc(suggested_size, buf);
      },
      [](uv_stream_t* stream, ssize_t nread, const uv_buf_t* buf) {
        LibuvStreamWrap* wrap = static_cast<LibuvStreamWrap*>(stream->data);
        TryCatchScope try_catch(wrap->env());
        try_catch.SetVerbose(true);
        wrap->OnUvRead(nread, buf);
      });
}",34,,202,1,,void
281779,BLOCK,-1,,"{
  return uv_read_stop(stream());
}",33,,218,1,,void
281788,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());

  *buf = EmitAlloc(suggested_size);
}",71,,223,3,,void
281811,BLOCK,-1,,"{
  static_assert(std::is_base_of<LibuvStreamWrap, WrapType>::value ||
                std::is_base_of<UDPWrap, WrapType>::value,
                ""Can only accept stream handles"");

  EscapableHandleScope scope(env->isolate());
  Local<Object> wrap_obj;

  if (!WrapType::Instantiate(env, parent, WrapType::SOCKET).ToLocal(&wrap_obj))
    return Local<Object>();

  HandleWrap* wrap = Unwrap<HandleWrap>(wrap_obj);
  CHECK_NOT_NULL(wrap);
  uv_stream_t* stream = reinterpret_cast<uv_stream_t*>(wrap->GetHandle());
  CHECK_NOT_NULL(stream);

  if (uv_accept(parent->stream(), stream))
    ABORT();

  return scope.Escape(wrap_obj);
}",65,,232,3,,void
281852,BLOCK,-1,,<empty>,5,,241,2,,void
281883,BLOCK,-1,,<empty>,5,,249,2,,void
281896,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  uv_handle_type type = UV_UNKNOWN_HANDLE;

  if (is_named_pipe_ipc() &&
      uv_pipe_pending_count(reinterpret_cast<uv_pipe_t*>(stream())) > 0) {
    type = uv_pipe_pending_type(reinterpret_cast<uv_pipe_t*>(stream()));
  }

  // We should not be getting this callback if someone has already called
  // uv_close() on the handle.
  CHECK_EQ(persistent().IsEmpty(), false);

  if (nread > 0) {
    MaybeLocal<Object> pending_obj;

    if (type == UV_TCP) {
      pending_obj = AcceptHandle<TCPWrap>(env(), this);
    } else if (type == UV_NAMED_PIPE) {
      pending_obj = AcceptHandle<PipeWrap>(env(), this);
    } else if (type == UV_UDP) {
      pending_obj = AcceptHandle<UDPWrap>(env(), this);
    } else {
      CHECK_EQ(type, UV_UNKNOWN_HANDLE);
    }

    Local<Object> local_pending_obj;
    if (type != UV_UNKNOWN_HANDLE &&
        (!pending_obj.ToLocal(&local_pending_obj) ||
         object()
 ...",75,,254,3,,void
281922,BLOCK,-1,,"{
    type = uv_pipe_pending_type(reinterpret_cast<uv_pipe_t*>(stream()));
  }",74,,260,2,,void
281939,BLOCK,-1,,"{
    MaybeLocal<Object> pending_obj;

    if (type == UV_TCP) {
      pending_obj = AcceptHandle<TCPWrap>(env(), this);
    } else if (type == UV_NAMED_PIPE) {
      pending_obj = AcceptHandle<PipeWrap>(env(), this);
    } else if (type == UV_UDP) {
      pending_obj = AcceptHandle<UDPWrap>(env(), this);
    } else {
      CHECK_EQ(type, UV_UNKNOWN_HANDLE);
    }

    Local<Object> local_pending_obj;
    if (type != UV_UNKNOWN_HANDLE &&
        (!pending_obj.ToLocal(&local_pending_obj) ||
         object()
             ->Set(env()->context(),
                   env()->pending_handle_string(),
                   local_pending_obj)
             .IsNothing())) {
      return Nothing<void>();
    }
  }",18,,268,2,,void
281949,BLOCK,-1,,"{
      pending_obj = AcceptHandle<TCPWrap>(env(), this);
    }",25,,271,2,,void
281961,BLOCK,-1,,<empty>,12,,273,1,,void
281966,BLOCK,-1,,"{
      pending_obj = AcceptHandle<PipeWrap>(env(), this);
    }",39,,273,2,,void
281978,BLOCK,-1,,<empty>,12,,275,1,,void
281983,BLOCK,-1,,"{
      pending_obj = AcceptHandle<UDPWrap>(env(), this);
    }",32,,275,2,,void
281995,BLOCK,-1,,"{
      CHECK_EQ(type, UV_UNKNOWN_HANDLE);
    }",12,,277,1,,void
282033,BLOCK,-1,,"{
      return Nothing<void>();
    }",29,,288,2,,void
282046,BLOCK,-1,,"{
  LibuvStreamWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, info.This());

  if (wrap->stream() == nullptr) {
    info.GetReturnValue().Set(0);
    return;
  }

  uint32_t write_queue_size = wrap->stream()->write_queue_size;
  info.GetReturnValue().Set(write_queue_size);
}",46,,298,2,,void
282062,BLOCK,-1,,"{
    info.GetReturnValue().Set(0);
    return;
  }",34,,302,2,,void
282093,BLOCK,-1,,"{
  LibuvStreamWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK_GT(args.Length(), 0);
  if (!wrap->IsAlive())
    return args.GetReturnValue().Set(UV_EINVAL);

  bool enable = args[0]->IsTrue();
  args.GetReturnValue().Set(uv_stream_set_blocking(wrap->stream(), enable));
}",76,,312,2,,void
282114,BLOCK,-1,,<empty>,5,,318,2,,void
282152,BLOCK,-1,,"{
  return new LibuvShutdownWrap(this, object);
}",73,,327,2,,void
282162,BLOCK,-1,,"{
  return new LibuvWriteWrap(this, object);
}",67,,331,2,,void
282172,BLOCK,-1,,"{
  LibuvShutdownWrap* req_wrap = static_cast<LibuvShutdownWrap*>(req_wrap_);
  return req_wrap->Dispatch(uv_shutdown, stream(), AfterUvShutdown);
}",58,,336,2,,void
282192,BLOCK,-1,,"{
  LibuvShutdownWrap* req_wrap = static_cast<LibuvShutdownWrap*>(
      LibuvShutdownWrap::from_req(req));
  CHECK_NOT_NULL(req_wrap);
  HandleScope scope(req_wrap->env()->isolate());
  Context::Scope context_scope(req_wrap->env()->context());
  req_wrap->Done(status);
}",71,,342,3,,void
282233,BLOCK,-1,,"{
  int err;
  size_t written;
  uv_buf_t* vbufs = *bufs;
  size_t vcount = *count;

  err = uv_try_write(stream(), vbufs, vcount);
  if (err == UV_ENOSYS || err == UV_EAGAIN)
    return 0;
  if (err < 0)
    return err;

  // Slice off the buffers: skip all written buffers and slice the one that
  // was partially written.
  written = err;
  for (; vcount > 0; vbufs++, vcount--) {
    // Slice
    if (vbufs[0].len > written) {
      vbufs[0].base += written;
      vbufs[0].len -= written;
      written = 0;
      break;

    // Discard
    } else {
      written -= vbufs[0].len;
    }
  }

  *bufs = vbufs;
  *count = vcount;

  return 0;
}",65,,356,3,,void
282260,BLOCK,-1,,<empty>,5,,364,2,,void
282267,BLOCK,-1,,<empty>,5,,366,2,,void
282274,BLOCK,-1,,<empty>,3,,371,1,,void
282283,BLOCK,4,,"{
    // Slice
    if (vbufs[0].len > written) {
      vbufs[0].base += written;
      vbufs[0].len -= written;
      written = 0;
      break;

    // Discard
    } else {
      written -= vbufs[0].len;
    }
  }",41,,371,4,,void
282292,BLOCK,-1,,"{
      vbufs[0].base += written;
      vbufs[0].len -= written;
      written = 0;
      break;

    // Discard
    }",33,,373,2,,void
282312,BLOCK,-1,,"{
      written -= vbufs[0].len;
    }",12,,380,1,,void
282337,BLOCK,-1,,"{
  LibuvWriteWrap* w = static_cast<LibuvWriteWrap*>(req_wrap);
  return w->Dispatch(uv_write2,
                     stream(),
                     bufs,
                     count,
                     send_handle,
                     AfterUvWrite);
}",56,,395,5,,void
282360,BLOCK,-1,,"{
  LibuvWriteWrap* req_wrap = static_cast<LibuvWriteWrap*>(
      LibuvWriteWrap::from_req(req));
  CHECK_NOT_NULL(req_wrap);
  HandleScope scope(req_wrap->env()->isolate());
  Context::Scope context_scope(req_wrap->env()->context());
  req_wrap->Done(status);
}",65,,407,3,,void
282409,BLOCK,-1,,<empty>,1,,1,1,,ANY
282434,BLOCK,-1,,<empty>,1,,1,1,,ANY
282439,BLOCK,-1,,"{
    free(const_cast<TypeName*>(data_));
    isolate()->AdjustAmountOfExternalAllocatedMemory(-byte_length());
  }",28,,58,1,,void
282453,BLOCK,-1,,"{
    return data_;
  }",41,,63,1,,void
282459,BLOCK,-1,,"{
    return length_;
  }",34,,67,1,,void
282465,BLOCK,-1,,"{
    return length() * sizeof(*data());
  }",31,,71,1,,void
282479,BLOCK,-1,,"{
    if (length == 0)
      return String::Empty(isolate);

    if (length < EXTERN_APEX)
      return NewSimpleFromCopy(isolate, data, length, error);

    TypeName* new_data = node::UncheckedMalloc<TypeName>(length);
    if (new_data == nullptr) {
      *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
      return MaybeLocal<Value>();
    }
    memcpy(new_data, data, length * sizeof(*new_data));

    return ExternString<ResourceType, TypeName>::New(isolate,
                                                     new_data,
                                                     length,
                                                     error);
  }",61,,78,5,,void
282484,BLOCK,-1,,<empty>,7,,80,2,,void
282495,BLOCK,1,,<empty>,,,,1,,void
282497,BLOCK,-1,,<empty>,7,,83,2,,void
282518,BLOCK,-1,,"{
      *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
      return MaybeLocal<Value>();
    }",30,,86,2,,void
282553,BLOCK,-1,,"{
    if (length == 0)
      return String::Empty(isolate);

    if (length < EXTERN_APEX) {
      MaybeLocal<Value> str = NewSimpleFromCopy(isolate, data, length, error);
      free(data);
      return str;
    }

    ExternString* h_str = new ExternString<ResourceType, TypeName>(isolate,
                                                                   data,
                                                                   length);
    MaybeLocal<Value> str = NewExternal(isolate, h_str);
    isolate->AdjustAmountOfExternalAllocatedMemory(h_str->byte_length());

    if (str.IsEmpty()) {
      delete h_str;
      *error = node::ERR_STRING_TOO_LONG(isolate);
      return MaybeLocal<Value>();
    }

    return str.ToLocalChecked();
  }",53,,102,5,,void
282558,BLOCK,-1,,<empty>,7,,104,2,,void
282569,BLOCK,1,,<empty>,,,,1,,void
282571,BLOCK,-1,,"{
      MaybeLocal<Value> str = NewSimpleFromCopy(isolate, data, length, error);
      free(data);
      return str;
    }",31,,106,2,,void
282617,BLOCK,-1,,"{
      delete h_str;
      *error = node::ERR_STRING_TOO_LONG(isolate);
      return MaybeLocal<Value>();
    }",24,,118,2,,void
282638,BLOCK,-1,,{ return isolate_; },35,,127,1,,void
282647,BLOCK,-1,,{ },55,,131,4,,void
282653,BLOCK,-1,,<empty>,,,,3,,<empty>
282661,BLOCK,-1,,<empty>,,,,5,,<empty>
282672,BLOCK,-1,,"{
  return String::NewExternalOneByte(isolate, h_str).FromMaybe(Local<Value>());
}",51,,155,3,,void
282689,BLOCK,-1,,"{
  return String::NewExternalTwoByte(isolate, h_str).FromMaybe(Local<Value>());
}",51,,162,3,,void
282708,BLOCK,-1,,"{
  MaybeLocal<String> str =
      String::NewFromOneByte(isolate,
                             reinterpret_cast<const uint8_t*>(data),
                             v8::NewStringType::kNormal,
                             length);
  if (str.IsEmpty()) {
    *error = node::ERR_STRING_TOO_LONG(isolate);
    return MaybeLocal<Value>();
  }
  return str.ToLocalChecked();
}",79,,170,5,,void
282734,BLOCK,-1,,"{
    *error = node::ERR_STRING_TOO_LONG(isolate);
    return MaybeLocal<Value>();
  }",22,,176,2,,void
282757,BLOCK,-1,,"{
  MaybeLocal<String> str =
      String::NewFromTwoByte(isolate,
                             data,
                             v8::NewStringType::kNormal,
                             length);
  if (str.IsEmpty()) {
    *error = node::ERR_STRING_TOO_LONG(isolate);
    return MaybeLocal<Value>();
  }
  return str.ToLocalChecked();
}",79,,188,5,,void
282781,BLOCK,-1,,"{
    *error = node::ERR_STRING_TOO_LONG(isolate);
    return MaybeLocal<Value>();
  }",22,,194,2,,void
283745,BLOCK,-1,,"{
  return unhex_table[x];
}",41,,243,2,,void
283757,BLOCK,-1,,"{
  size_t i;
  for (i = 0; i < len && i * 2 + 1 < srcLen; ++i) {
    unsigned a = unhex(static_cast<uint8_t>(src[i * 2 + 0]));
    unsigned b = unhex(static_cast<uint8_t>(src[i * 2 + 1]));
    if (!~a || !~b)
      return i;
    buf[i] = (a << 4) | b;
  }

  return i;
}",47,,251,5,,void
283760,BLOCK,-1,,<empty>,3,,253,1,,void
283777,BLOCK,4,,"{
    unsigned a = unhex(static_cast<uint8_t>(src[i * 2 + 0]));
    unsigned b = unhex(static_cast<uint8_t>(src[i * 2 + 1]));
    if (!~a || !~b)
      return i;
    buf[i] = (a << 4) | b;
  }",51,,253,4,,void
283812,BLOCK,-1,,<empty>,7,,257,2,,void
283834,BLOCK,-1,,"{
  uint16_t* const dst = reinterpret_cast<uint16_t*>(buf);

  size_t max_chars = buflen / sizeof(*dst);
  if (max_chars == 0) {
    return 0;
  }

  uint16_t* const aligned_dst = AlignUp(dst, sizeof(*dst));
  size_t nchars;
  if (aligned_dst == dst) {
    nchars = str->Write(isolate, dst, 0, max_chars, flags);
    return nchars * sizeof(*dst);
  }

  CHECK_EQ(reinterpret_cast<uintptr_t>(aligned_dst) % sizeof(*dst), 0);

  // Write all but the last char
  max_chars = std::min(max_chars, static_cast<size_t>(str->Length()));
  if (max_chars == 0) {
    return 0;
  }
  nchars = str->Write(isolate, aligned_dst, 0, max_chars - 1, flags);
  CHECK_EQ(nchars, max_chars - 1);

  // Shift everything to unaligned-left
  memmove(dst, aligned_dst, nchars * sizeof(*dst));

  // One more char to be written
  uint16_t last;
  CHECK_EQ(str->Write(isolate, &last, nchars, 1, flags), 1);
  memcpy(buf + nchars * sizeof(*dst), &last, sizeof(last));
  nchars++;

  return nchars * sizeof(*dst);
}",79,,265,6,,void
283853,BLOCK,-1,,"{
    return 0;
  }",23,,269,2,,void
283869,BLOCK,-1,,"{
    nchars = str->Write(isolate, dst, 0, max_chars, flags);
    return nchars * sizeof(*dst);
  }",27,,275,2,,void
283913,BLOCK,-1,,"{
    return 0;
  }",23,,284,2,,void
283983,BLOCK,-1,,"{
  HandleScope scope(isolate);
  size_t nbytes;

  CHECK(val->IsString() == true);
  Local<String> str = val.As<String>();

  int flags = String::HINT_MANY_WRITES_EXPECTED |
              String::NO_NULL_TERMINATION |
              String::REPLACE_INVALID_UTF8;

  switch (encoding) {
    case ASCII:
    case LATIN1:
      if (str->IsExternalOneByte()) {
        auto ext = str->GetExternalOneByteStringResource();
        nbytes = std::min(buflen, ext->length());
        memcpy(buf, ext->data(), nbytes);
      } else {
        uint8_t* const dst = reinterpret_cast<uint8_t*>(buf);
        nbytes = str->WriteOneByte(isolate, dst, 0, buflen, flags);
      }
      break;

    case BUFFER:
    case UTF8:
      nbytes = str->WriteUtf8(isolate, buf, buflen, nullptr, flags);
      break;

    case UCS2: {
      nbytes = WriteUCS2(isolate, buf, buflen, str, flags);

      // Node's ""ucs2"" encoding wants LE character data stored in
      // the Buffer, so we need to reorder on BE platforms.  S...",51,,306,6,,void
284021,BLOCK,-1,,"{
    case ASCII:
    case LATIN1:
      if (str->IsExternalOneByte()) {
        auto ext = str->GetExternalOneByteStringResource();
        nbytes = std::min(buflen, ext->length());
        memcpy(buf, ext->data(), nbytes);
      } else {
        uint8_t* const dst = reinterpret_cast<uint8_t*>(buf);
        nbytes = str->WriteOneByte(isolate, dst, 0, buflen, flags);
      }
      break;

    case BUFFER:
    case UTF8:
      nbytes = str->WriteUtf8(isolate, buf, buflen, nullptr, flags);
      break;

    case UCS2: {
      nbytes = WriteUCS2(isolate, buf, buflen, str, flags);

      // Node's ""ucs2"" encoding wants LE character data stored in
      // the Buffer, so we need to reorder on BE platforms.  See
      // https://nodejs.org/api/buffer.html regarding Node's ""ucs2""
      // encoding specification
      if (IsBigEndian())
        SwapBytes16(buf, nbytes);

      break;
    }

    case BASE64URL:
      // Fall through
    case BASE64:
      if (str->IsExternalOneByte()) {
    ...",21,,317,2,,void
284031,BLOCK,-1,,"{
        auto ext = str->GetExternalOneByteStringResource();
        nbytes = std::min(buflen, ext->length());
        memcpy(buf, ext->data(), nbytes);
      }",37,,320,2,,void
284058,BLOCK,-1,,"{
        uint8_t* const dst = reinterpret_cast<uint8_t*>(buf);
        nbytes = str->WriteOneByte(isolate, dst, 0, buflen, flags);
      }",14,,324,1,,void
284095,BLOCK,15,,"{
      nbytes = WriteUCS2(isolate, buf, buflen, str, flags);

      // Node's ""ucs2"" encoding wants LE character data stored in
      // the Buffer, so we need to reorder on BE platforms.  See
      // https://nodejs.org/api/buffer.html regarding Node's ""ucs2""
      // encoding specification
      if (IsBigEndian())
        SwapBytes16(buf, nbytes);

      break;
    }",16,,335,15,,void
284106,BLOCK,-1,,<empty>,9,,343,2,,void
284120,BLOCK,-1,,"{
        auto ext = str->GetExternalOneByteStringResource();
        nbytes = base64_decode(buf, buflen, ext->data(), ext->length());
      }",37,,351,2,,void
284142,BLOCK,-1,,"{
        String::Value value(isolate, str);
        nbytes = base64_decode(buf, buflen, *value, value.length());
      }",14,,354,1,,void
284166,BLOCK,-1,,"{
        auto ext = str->GetExternalOneByteStringResource();
        nbytes = hex_decode(buf, buflen, ext->data(), ext->length());
      }",37,,361,2,,void
284188,BLOCK,-1,,"{
        String::Value value(isolate, str);
        nbytes = hex_decode(buf, buflen, *value, value.length());
      }",14,,364,1,,void
284216,BLOCK,-1,,"{
  HandleScope scope(isolate);
  size_t data_size = 0;
  bool is_buffer = Buffer::HasInstance(val);

  if (is_buffer && (encoding == BUFFER || encoding == LATIN1)) {
    return Just(Buffer::Length(val));
  }

  Local<String> str;
  if (!val->ToString(isolate->GetCurrentContext()).ToLocal(&str))
    return Nothing<size_t>();

  switch (encoding) {
    case ASCII:
    case LATIN1:
      data_size = str->Length();
      break;

    case BUFFER:
    case UTF8:
      // A single UCS2 codepoint never takes up more than 3 utf8 bytes.
      // It is an exercise for the caller to decide when a string is
      // long enough to justify calling Size() instead of StorageSize()
      data_size = 3 * str->Length();
      break;

    case UCS2:
      data_size = str->Length() * sizeof(uint16_t);
      break;

    case BASE64URL:
      // Fall through
    case BASE64:
      data_size = base64_decoded_size_fast(str->Length());
      break;

    case HEX:
      CHECK(str->Length() % 2 == 0 && ""inval...",64,,382,4,,void
284242,BLOCK,-1,,"{
    return Just(Buffer::Length(val));
  }",64,,387,2,,void
284270,BLOCK,-1,,<empty>,5,,393,2,,void
284275,BLOCK,-1,,"{
    case ASCII:
    case LATIN1:
      data_size = str->Length();
      break;

    case BUFFER:
    case UTF8:
      // A single UCS2 codepoint never takes up more than 3 utf8 bytes.
      // It is an exercise for the caller to decide when a string is
      // long enough to justify calling Size() instead of StorageSize()
      data_size = 3 * str->Length();
      break;

    case UCS2:
      data_size = str->Length() * sizeof(uint16_t);
      break;

    case BASE64URL:
      // Fall through
    case BASE64:
      data_size = base64_decoded_size_fast(str->Length());
      break;

    case HEX:
      CHECK(str->Length() % 2 == 0 && ""invalid hex string length"");
      data_size = str->Length() / 2;
      break;

    default:
      UNREACHABLE(""unknown encoding"");
  }",21,,395,2,,void
284358,BLOCK,-1,,"{
  HandleScope scope(isolate);

  if (Buffer::HasInstance(val) && (encoding == BUFFER || encoding == LATIN1))
    return Just(Buffer::Length(val));

  Local<String> str;
  if (!val->ToString(isolate->GetCurrentContext()).ToLocal(&str))
    return Nothing<size_t>();

  switch (encoding) {
    case ASCII:
    case LATIN1:
      return Just<size_t>(str->Length());

    case BUFFER:
    case UTF8:
      return Just<size_t>(str->Utf8Length(isolate));

    case UCS2:
      return Just(str->Length() * sizeof(uint16_t));

    case BASE64URL:
      // Fall through
    case BASE64: {
      String::Value value(isolate, str);
      return Just(base64_decoded_size(*value, value.length()));
    }

    case HEX:
      return Just<size_t>(str->Length() / 2);
  }

  UNREACHABLE();
}",57,,433,4,,void
284376,BLOCK,-1,,<empty>,5,,437,2,,void
284404,BLOCK,-1,,<empty>,5,,441,2,,void
284409,BLOCK,-1,,"{
    case ASCII:
    case LATIN1:
      return Just<size_t>(str->Length());

    case BUFFER:
    case UTF8:
      return Just<size_t>(str->Utf8Length(isolate));

    case UCS2:
      return Just(str->Length() * sizeof(uint16_t));

    case BASE64URL:
      // Fall through
    case BASE64: {
      String::Value value(isolate, str);
      return Just(base64_decoded_size(*value, value.length()));
    }

    case HEX:
      return Just<size_t>(str->Length() / 2);
  }",21,,443,2,,void
284452,BLOCK,18,,"{
      String::Value value(isolate, str);
      return Just(base64_decoded_size(*value, value.length()));
    }",18,,457,18,,void
284486,BLOCK,-1,,"{
  for (size_t i = 0; i < len; ++i) {
    dst[i] = src[i] & 0x7f;
  }
}",70,,469,4,,void
284488,BLOCK,-1,,<empty>,3,,470,1,,void
284498,BLOCK,4,,"{
    dst[i] = src[i] & 0x7f;
  }",36,,470,4,,void
284514,BLOCK,-1,,"{
  if (len < 16) {
    force_ascii_slow(src, dst, len);
    return;
  }

  const unsigned bytes_per_word = sizeof(uintptr_t);
  const unsigned align_mask = bytes_per_word - 1;
  const unsigned src_unalign = reinterpret_cast<uintptr_t>(src) & align_mask;
  const unsigned dst_unalign = reinterpret_cast<uintptr_t>(dst) & align_mask;

  if (src_unalign > 0) {
    if (src_unalign == dst_unalign) {
      const unsigned unalign = bytes_per_word - src_unalign;
      force_ascii_slow(src, dst, unalign);
      src += unalign;
      dst += unalign;
      len -= src_unalign;
    } else {
      force_ascii_slow(src, dst, len);
      return;
    }
  }

#if defined(_WIN64) || defined(_LP64)
  const uintptr_t mask = ~0x8080808080808080ll;
#else
  const uintptr_t mask = ~0x80808080l;
#endif

  const uintptr_t* srcw = reinterpret_cast<const uintptr_t*>(src);
  uintptr_t* dstw = reinterpret_cast<uintptr_t*>(dst);

  for (size_t i = 0, n = len / bytes_per_word; i < n; ++i) {
    dstw[i] = srcw[i] & ma...",65,,476,4,,void
284519,BLOCK,-1,,"{
    force_ascii_slow(src, dst, len);
    return;
  }",17,,477,2,,void
284556,BLOCK,-1,,"{
    if (src_unalign == dst_unalign) {
      const unsigned unalign = bytes_per_word - src_unalign;
      force_ascii_slow(src, dst, unalign);
      src += unalign;
      dst += unalign;
      len -= src_unalign;
    } else {
      force_ascii_slow(src, dst, len);
      return;
    }
  }",24,,487,2,,void
284561,BLOCK,-1,,"{
      const unsigned unalign = bytes_per_word - src_unalign;
      force_ascii_slow(src, dst, unalign);
      src += unalign;
      dst += unalign;
      len -= src_unalign;
    }",37,,488,2,,void
284582,BLOCK,-1,,"{
      force_ascii_slow(src, dst, len);
      return;
    }",12,,494,1,,void
284606,BLOCK,-1,,<empty>,3,,509,1,,void
284622,BLOCK,4,,"{
    dstw[i] = srcw[i] & mask;
  }",60,,509,4,,void
284642,BLOCK,-1,,"{
    const size_t offset = len - remainder;
    force_ascii_slow(src + offset, dst + offset, remainder);
  }",22,,514,2,,void
284664,BLOCK,-1,,"{
  // We know how much we'll write, just make sure that there's space.
  CHECK(dlen >= slen * 2 &&
      ""not enough space provided for hex encode"");

  dlen = slen * 2;
  for (uint32_t i = 0, k = 0; k < dlen; i += 1, k += 2) {
    static const char hex[] = ""0123456789abcdef"";
    uint8_t val = static_cast<uint8_t>(src[i]);
    dst[k + 0] = hex[val >> 4];
    dst[k + 1] = hex[val & 15];
  }

  return dlen;
}",18,,525,5,,void
284679,BLOCK,-1,,<empty>,3,,531,1,,void
284698,BLOCK,4,,"{
    static const char hex[] = ""0123456789abcdef"";
    uint8_t val = static_cast<uint8_t>(src[i]);
    dst[k + 0] = hex[val >> 4];
    dst[k + 1] = hex[val & 15];
  }",57,,531,4,,void
284740,BLOCK,-1,,"{
  size_t dlen = slen * 2;
  std::string dst(dlen, '\0');
  hex_encode(src, slen, dst.data(), dlen);
  return dst;
}",67,,541,3,,void
284769,BLOCK,-1,,"{
  CHECK_BUFLEN_IN_RANGE(buflen);

  if (!buflen && encoding != BUFFER) {
    return String::Empty(isolate);
  }

  MaybeLocal<String> val;

  switch (encoding) {
    case BUFFER:
      {
        auto maybe_buf = Buffer::Copy(isolate, buf, buflen);
        Local<v8::Object> buf;
        if (!maybe_buf.ToLocal(&buf)) {
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
        }
        return buf;
      }

    case ASCII:
      if (simdutf::validate_ascii_with_errors(buf, buflen).error) {
        // The input contains non-ASCII bytes.
        char* out = node::UncheckedMalloc(buflen);
        if (out == nullptr) {
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
          return MaybeLocal<Value>();
        }
        force_ascii(buf, out, buflen);
        return ExternOneByteString::New(isolate, out, buflen, error);
      } else {
        return ExternOneByteString::NewFromCopy(isolate, buf, buflen, error);
      }

    case UTF8:
      {
        val = S...",60,,561,6,,void
284772,BLOCK,1,,<empty>,,,,2,,void
284774,BLOCK,-1,,CHECK_BUFLEN_IN_RANGE(buflen),3,,562,1,,void
284781,BLOCK,-1,,CHECK_BUFLEN_IN_RANGE(buflen),3,,562,2,,void
284800,BLOCK,-1,,"{
    return String::Empty(isolate);
  }",38,,564,2,,void
284814,BLOCK,-1,,"{
    case BUFFER:
      {
        auto maybe_buf = Buffer::Copy(isolate, buf, buflen);
        Local<v8::Object> buf;
        if (!maybe_buf.ToLocal(&buf)) {
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
        }
        return buf;
      }

    case ASCII:
      if (simdutf::validate_ascii_with_errors(buf, buflen).error) {
        // The input contains non-ASCII bytes.
        char* out = node::UncheckedMalloc(buflen);
        if (out == nullptr) {
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
          return MaybeLocal<Value>();
        }
        force_ascii(buf, out, buflen);
        return ExternOneByteString::New(isolate, out, buflen, error);
      } else {
        return ExternOneByteString::NewFromCopy(isolate, buf, buflen, error);
      }

    case UTF8:
      {
        val = String::NewFromUtf8(isolate,
                                  buf,
                                  v8::NewStringType::kNormal,
                                 ...",21,,570,2,,void
284817,BLOCK,3,,"{
        auto maybe_buf = Buffer::Copy(isolate, buf, buflen);
        Local<v8::Object> buf;
        if (!maybe_buf.ToLocal(&buf)) {
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
        }
        return buf;
      }",7,,572,3,,void
284843,BLOCK,-1,,"{
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
        }",39,,575,2,,void
284865,BLOCK,-1,,"{
        // The input contains non-ASCII bytes.
        char* out = node::UncheckedMalloc(buflen);
        if (out == nullptr) {
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
          return MaybeLocal<Value>();
        }
        force_ascii(buf, out, buflen);
        return ExternOneByteString::New(isolate, out, buflen, error);
      }",67,,582,2,,void
284878,BLOCK,-1,,"{
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
          return MaybeLocal<Value>();
        }",29,,585,2,,void
284903,BLOCK,-1,,"{
        return ExternOneByteString::NewFromCopy(isolate, buf, buflen, error);
      }",14,,591,1,,void
284915,BLOCK,9,,"{
        val = String::NewFromUtf8(isolate,
                                  buf,
                                  v8::NewStringType::kNormal,
                                  buflen);
        Local<String> str;
        if (!val.ToLocal(&str)) {
          *error = node::ERR_STRING_TOO_LONG(isolate);
        }
        return str;
      }",7,,596,9,,void
284943,BLOCK,-1,,"{
          *error = node::ERR_STRING_TOO_LONG(isolate);
        }",33,,602,2,,void
284967,BLOCK,15,,"{
      size_t dlen = base64_encoded_size(buflen);
      char* dst = node::UncheckedMalloc(dlen);
      if (dst == nullptr) {
        *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
        return MaybeLocal<Value>();
      }

      size_t written = base64_encode(buf, buflen, dst, dlen);
      CHECK_EQ(written, dlen);

      return ExternOneByteString::New(isolate, dst, dlen, error);
    }",18,,611,15,,void
284985,BLOCK,-1,,"{
        *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
        return MaybeLocal<Value>();
      }",27,,614,2,,void
285018,BLOCK,18,,"{
      size_t dlen = base64_encoded_size(buflen, Base64Mode::URL);
      char* dst = node::UncheckedMalloc(dlen);
      if (dst == nullptr) {
        *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
        return MaybeLocal<Value>();
      }

      size_t written = base64_encode(buf, buflen, dst, dlen, Base64Mode::URL);
      CHECK_EQ(written, dlen);

      return ExternOneByteString::New(isolate, dst, dlen, error);
    }",21,,625,18,,void
285039,BLOCK,-1,,"{
        *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
        return MaybeLocal<Value>();
      }",27,,628,2,,void
285075,BLOCK,21,,"{
      size_t dlen = buflen * 2;
      char* dst = node::UncheckedMalloc(dlen);
      if (dst == nullptr) {
        *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
        return MaybeLocal<Value>();
      }
      size_t written = hex_encode(buf, buflen, dst, dlen);
      CHECK_EQ(written, dlen);

      return ExternOneByteString::New(isolate, dst, dlen, error);
    }",15,,639,21,,void
285094,BLOCK,-1,,"{
        *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
        return MaybeLocal<Value>();
      }",27,,642,2,,void
285127,BLOCK,24,,"{
      size_t str_len = buflen / 2;
      if (IsBigEndian()) {
        uint16_t* dst = node::UncheckedMalloc<uint16_t>(str_len);
        if (str_len != 0 && dst == nullptr) {
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
          return MaybeLocal<Value>();
        }
        for (size_t i = 0, k = 0; k < str_len; i += 2, k += 1) {
          // The input is in *little endian*, because that's what Node.js
          // expects, so the high byte comes after the low byte.
          const uint8_t hi = static_cast<uint8_t>(buf[i + 1]);
          const uint8_t lo = static_cast<uint8_t>(buf[i + 0]);
          dst[k] = static_cast<uint16_t>(hi) << 8 | lo;
        }
        return ExternTwoByteString::New(isolate, dst, str_len, error);
      }
      if (reinterpret_cast<uintptr_t>(buf) % 2 != 0) {
        // Unaligned data still means we can't directly pass it to V8.
        char* dst = node::UncheckedMalloc(buflen);
        if (dst == nullptr) {
          *error = node::ER...",16,,652,24,,void
285136,BLOCK,-1,,"{
        uint16_t* dst = node::UncheckedMalloc<uint16_t>(str_len);
        if (str_len != 0 && dst == nullptr) {
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
          return MaybeLocal<Value>();
        }
        for (size_t i = 0, k = 0; k < str_len; i += 2, k += 1) {
          // The input is in *little endian*, because that's what Node.js
          // expects, so the high byte comes after the low byte.
          const uint8_t hi = static_cast<uint8_t>(buf[i + 1]);
          const uint8_t lo = static_cast<uint8_t>(buf[i + 0]);
          dst[k] = static_cast<uint16_t>(hi) << 8 | lo;
        }
        return ExternTwoByteString::New(isolate, dst, str_len, error);
      }",26,,654,2,,void
285155,BLOCK,-1,,"{
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
          return MaybeLocal<Value>();
        }",45,,656,2,,void
285167,BLOCK,-1,,<empty>,9,,660,1,,void
285186,BLOCK,4,,"{
          // The input is in *little endian*, because that's what Node.js
          // expects, so the high byte comes after the low byte.
          const uint8_t hi = static_cast<uint8_t>(buf[i + 1]);
          const uint8_t lo = static_cast<uint8_t>(buf[i + 0]);
          dst[k] = static_cast<uint16_t>(hi) << 8 | lo;
        }",64,,660,4,,void
285235,BLOCK,-1,,"{
        // Unaligned data still means we can't directly pass it to V8.
        char* dst = node::UncheckedMalloc(buflen);
        if (dst == nullptr) {
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
          return MaybeLocal<Value>();
        }
        memcpy(dst, buf, buflen);
        return ExternTwoByteString::New(
            isolate, reinterpret_cast<uint16_t*>(dst), str_len, error);
      }",54,,669,2,,void
285248,BLOCK,-1,,"{
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
          return MaybeLocal<Value>();
        }",29,,672,2,,void
285295,BLOCK,-1,,"{
  if (buflen == 0) return String::Empty(isolate);
  CHECK_BUFLEN_IN_RANGE(buflen);

  // Node's ""ucs2"" encoding expects LE character data inside a
  // Buffer, so we need to reorder on BE platforms.  See
  // https://nodejs.org/api/buffer.html regarding Node's ""ucs2""
  // encoding specification
  if (IsBigEndian()) {
    uint16_t* dst = node::UncheckedMalloc<uint16_t>(buflen);
    if (dst == nullptr) {
      *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
      return MaybeLocal<Value>();
    }
    size_t nbytes = buflen * sizeof(uint16_t);
    memcpy(dst, buf, nbytes);
    SwapBytes16(reinterpret_cast<char*>(dst), nbytes);
    return ExternTwoByteString::New(isolate, dst, buflen, error);
  } else {
    return ExternTwoByteString::NewFromCopy(isolate, buf, buflen, error);
  }
}",60,,693,5,,void
285300,BLOCK,-1,,<empty>,20,,694,2,,void
285309,BLOCK,1,,<empty>,,,,2,,void
285311,BLOCK,-1,,CHECK_BUFLEN_IN_RANGE(buflen),3,,695,1,,void
285318,BLOCK,-1,,CHECK_BUFLEN_IN_RANGE(buflen),3,,695,2,,void
285332,BLOCK,-1,,"{
    uint16_t* dst = node::UncheckedMalloc<uint16_t>(buflen);
    if (dst == nullptr) {
      *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
      return MaybeLocal<Value>();
    }
    size_t nbytes = buflen * sizeof(uint16_t);
    memcpy(dst, buf, nbytes);
    SwapBytes16(reinterpret_cast<char*>(dst), nbytes);
    return ExternTwoByteString::New(isolate, dst, buflen, error);
  }",22,,701,2,,void
285347,BLOCK,-1,,"{
      *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
      return MaybeLocal<Value>();
    }",25,,703,2,,void
285384,BLOCK,-1,,"{
    return ExternTwoByteString::NewFromCopy(isolate, buf, buflen, error);
  }",10,,711,1,,void
285401,BLOCK,-1,,"{
  const size_t len = strlen(buf);
  return Encode(isolate, buf, len, encoding, error);
}",60,,719,5,,void
285426,BLOCK,-1,,<empty>,1,,1,1,,ANY
285433,BLOCK,-1,,<empty>,1,,1,1,,ANY
285454,BLOCK,-1,,<empty>,1,,1,1,,ANY
285462,BLOCK,-1,,"{
  Local<Value> error;
  MaybeLocal<Value> ret;
  if (encoding == UTF8) {
    MaybeLocal<String> utf8_string = String::NewFromUtf8(
        isolate,
        data,
        v8::NewStringType::kNormal,
        length);
    if (utf8_string.IsEmpty()) {
      isolate->ThrowException(node::ERR_STRING_TOO_LONG(isolate));
      return MaybeLocal<String>();
    } else {
      return utf8_string;
    }
  } else {
    ret = StringBytes::Encode(
        isolate,
        data,
        length,
        encoding,
        &error);
  }

  if (ret.IsEmpty()) {
    CHECK(!error.IsEmpty());
    isolate->ThrowException(error);
  }

  DCHECK(ret.IsEmpty() || ret.ToLocalChecked()->IsString());
  return ret.FromMaybe(Local<Value>()).As<String>();
}",55,,30,5,,void
285477,BLOCK,-1,,"{
    MaybeLocal<String> utf8_string = String::NewFromUtf8(
        isolate,
        data,
        v8::NewStringType::kNormal,
        length);
    if (utf8_string.IsEmpty()) {
      isolate->ThrowException(node::ERR_STRING_TOO_LONG(isolate));
      return MaybeLocal<String>();
    } else {
      return utf8_string;
    }
  }",25,,33,2,,void
285501,BLOCK,-1,,"{
      isolate->ThrowException(node::ERR_STRING_TOO_LONG(isolate));
      return MaybeLocal<String>();
    }",32,,39,2,,void
285514,BLOCK,-1,,"{
      return utf8_string;
    }",12,,42,1,,void
285518,BLOCK,-1,,"{
    ret = StringBytes::Encode(
        isolate,
        data,
        length,
        encoding,
        &error);
  }",10,,45,1,,void
285536,BLOCK,-1,,"{
    CHECK(!error.IsEmpty());
    isolate->ThrowException(error);
  }",22,,54,2,,void
285576,BLOCK,-1,,"{
  Local<String> prepend, body;

  size_t nread = *nread_ptr;

  if (Encoding() == UTF8 ||
      Encoding() == UCS2 ||
      Encoding() == BASE64 ||
      Encoding() == BASE64URL) {
    // See if we want bytes to finish a character from the previous
    // chunk; if so, copy the new bytes to the missing bytes buffer
    // and create a small string from it that is to be prepended to the
    // main body.
    if (MissingBytes() > 0) {
      // There are never more bytes missing than the pre-calculated maximum.
      CHECK_LE(MissingBytes() + BufferedBytes(),
               kIncompleteCharactersEnd);
      if (Encoding() == UTF8) {
        // For UTF-8, we need special treatment to align with the V8 decoder:
        // If an incomplete character is found at a chunk boundary, we use
        // its remainder and pass it to V8 as-is.
        for (size_t i = 0; i < nread && i < MissingBytes(); ++i) {
          if ((data[i] & 0xC0) != 0x80) {
            // This byte is not a continuation...",65,,68,4,,void
285600,BLOCK,-1,,"{
    // See if we want bytes to finish a character from the previous
    // chunk; if so, copy the new bytes to the missing bytes buffer
    // and create a small string from it that is to be prepended to the
    // main body.
    if (MissingBytes() > 0) {
      // There are never more bytes missing than the pre-calculated maximum.
      CHECK_LE(MissingBytes() + BufferedBytes(),
               kIncompleteCharactersEnd);
      if (Encoding() == UTF8) {
        // For UTF-8, we need special treatment to align with the V8 decoder:
        // If an incomplete character is found at a chunk boundary, we use
        // its remainder and pass it to V8 as-is.
        for (size_t i = 0; i < nread && i < MissingBytes(); ++i) {
          if ((data[i] & 0xC0) != 0x80) {
            // This byte is not a continuation byte even though it should have
            // been one. We stop decoding of the incomplete character at this
            // point (but still use the rest of the incomplete bytes f...",32,,76,2,,void
285605,BLOCK,-1,,"{
      // There are never more bytes missing than the pre-calculated maximum.
      CHECK_LE(MissingBytes() + BufferedBytes(),
               kIncompleteCharactersEnd);
      if (Encoding() == UTF8) {
        // For UTF-8, we need special treatment to align with the V8 decoder:
        // If an incomplete character is found at a chunk boundary, we use
        // its remainder and pass it to V8 as-is.
        for (size_t i = 0; i < nread && i < MissingBytes(); ++i) {
          if ((data[i] & 0xC0) != 0x80) {
            // This byte is not a continuation byte even though it should have
            // been one. We stop decoding of the incomplete character at this
            // point (but still use the rest of the incomplete bytes from this
            // chunk) and assume that the new, unexpected byte starts a new one.
            state_[kMissingBytes] = 0;
            memcpy(IncompleteCharacterBuffer() + BufferedBytes(), data, i);
            state_[kBufferedBytes] += i;
          ...",29,,81,2,,void
285615,BLOCK,-1,,"{
        // For UTF-8, we need special treatment to align with the V8 decoder:
        // If an incomplete character is found at a chunk boundary, we use
        // its remainder and pass it to V8 as-is.
        for (size_t i = 0; i < nread && i < MissingBytes(); ++i) {
          if ((data[i] & 0xC0) != 0x80) {
            // This byte is not a continuation byte even though it should have
            // been one. We stop decoding of the incomplete character at this
            // point (but still use the rest of the incomplete bytes from this
            // chunk) and assume that the new, unexpected byte starts a new one.
            state_[kMissingBytes] = 0;
            memcpy(IncompleteCharacterBuffer() + BufferedBytes(), data, i);
            state_[kBufferedBytes] += i;
            data += i;
            nread -= i;
            break;
          }
        }
      }",31,,85,2,,void
285617,BLOCK,-1,,<empty>,9,,89,1,,void
285631,BLOCK,4,,"{
          if ((data[i] & 0xC0) != 0x80) {
            // This byte is not a continuation byte even though it should have
            // been one. We stop decoding of the incomplete character at this
            // point (but still use the rest of the incomplete bytes from this
            // chunk) and assume that the new, unexpected byte starts a new one.
            state_[kMissingBytes] = 0;
            memcpy(IncompleteCharacterBuffer() + BufferedBytes(), data, i);
            state_[kBufferedBytes] += i;
            data += i;
            nread -= i;
            break;
          }
        }",66,,89,4,,void
285640,BLOCK,-1,,"{
            // This byte is not a continuation byte even though it should have
            // been one. We stop decoding of the incomplete character at this
            // point (but still use the rest of the incomplete bytes from this
            // chunk) and assume that the new, unexpected byte starts a new one.
            state_[kMissingBytes] = 0;
            memcpy(IncompleteCharacterBuffer() + BufferedBytes(), data, i);
            state_[kBufferedBytes] += i;
            data += i;
            nread -= i;
            break;
          }",41,,90,2,,void
285702,BLOCK,-1,,"{
        // If no more bytes are missing, create a small string that we
        // will later prepend.
        if (!MakeString(isolate,
                        IncompleteCharacterBuffer(),
                        BufferedBytes(),
                        Encoding()).ToLocal(&prepend)) {
          return MaybeLocal<String>();
        }

        *nread_ptr += BufferedBytes();
        // No more buffered bytes.
        state_[kBufferedBytes] = 0;
      }",40,,117,2,,void
285715,BLOCK,-1,,"{
          return MaybeLocal<String>();
        }",56,,123,2,,void
285732,BLOCK,-1,,"{
      body = !prepend.IsEmpty() ? prepend : String::Empty(isolate);
      prepend = Local<String>();
    }",31,,135,2,,void
285751,BLOCK,-1,,"{
      // If not, that means is no character left to finish at this point.
      DCHECK_EQ(MissingBytes(), 0);
      DCHECK_EQ(BufferedBytes(), 0);

      // See whether there is a character that we may have to cut off and
      // finish when receiving the next chunk.
      if (Encoding() == UTF8 && data[nread - 1] & 0x80) {
        // This is UTF-8 encoded data and we ended on a non-ASCII UTF-8 byte.
        // This means we'll need to figure out where the character to which
        // the byte belongs begins.
        for (size_t i = nread - 1; ; --i) {
          DCHECK_LT(i, nread);
          state_[kBufferedBytes]++;
          if ((data[i] & 0xC0) == 0x80) {
            // This byte does not start a character (a ""trailing"" byte).
            if (state_[kBufferedBytes] >= 4 || i == 0) {
              // We either have more then 4 trailing bytes (which means
              // the current character would not be inside the range for
              // valid Unicode, and in particular ...",12,,138,1,,void
285770,BLOCK,-1,,"{
        // This is UTF-8 encoded data and we ended on a non-ASCII UTF-8 byte.
        // This means we'll need to figure out where the character to which
        // the byte belongs begins.
        for (size_t i = nread - 1; ; --i) {
          DCHECK_LT(i, nread);
          state_[kBufferedBytes]++;
          if ((data[i] & 0xC0) == 0x80) {
            // This byte does not start a character (a ""trailing"" byte).
            if (state_[kBufferedBytes] >= 4 || i == 0) {
              // We either have more then 4 trailing bytes (which means
              // the current character would not be inside the range for
              // valid Unicode, and in particular cannot be represented
              // through JavaScript's UTF-16-based approach to strings), or the
              // current buffer does not contain the start of an UTF-8 character
              // at all. Either way, this is invalid UTF8 and we can just
              // let the engine's decoder handle it.
              sta...",57,,145,2,,void
285772,BLOCK,-1,,<empty>,9,,149,1,,void
285781,BLOCK,4,,"{
          DCHECK_LT(i, nread);
          state_[kBufferedBytes]++;
          if ((data[i] & 0xC0) == 0x80) {
            // This byte does not start a character (a ""trailing"" byte).
            if (state_[kBufferedBytes] >= 4 || i == 0) {
              // We either have more then 4 trailing bytes (which means
              // the current character would not be inside the range for
              // valid Unicode, and in particular cannot be represented
              // through JavaScript's UTF-16-based approach to strings), or the
              // current buffer does not contain the start of an UTF-8 character
              // at all. Either way, this is invalid UTF8 and we can just
              // let the engine's decoder handle it.
              state_[kBufferedBytes] = 0;
              break;
            }
          } else {
            // Found the first byte of a UTF-8 character. By looking at the
            // upper bits we can tell how long the character *should* be.
     ...",43,,149,4,,void
285797,BLOCK,-1,,"{
            // This byte does not start a character (a ""trailing"" byte).
            if (state_[kBufferedBytes] >= 4 || i == 0) {
              // We either have more then 4 trailing bytes (which means
              // the current character would not be inside the range for
              // valid Unicode, and in particular cannot be represented
              // through JavaScript's UTF-16-based approach to strings), or the
              // current buffer does not contain the start of an UTF-8 character
              // at all. Either way, this is invalid UTF8 and we can just
              // let the engine's decoder handle it.
              state_[kBufferedBytes] = 0;
              break;
            }
          }",41,,152,2,,void
285808,BLOCK,-1,,"{
              // We either have more then 4 trailing bytes (which means
              // the current character would not be inside the range for
              // valid Unicode, and in particular cannot be represented
              // through JavaScript's UTF-16-based approach to strings), or the
              // current buffer does not contain the start of an UTF-8 character
              // at all. Either way, this is invalid UTF8 and we can just
              // let the engine's decoder handle it.
              state_[kBufferedBytes] = 0;
              break;
            }",56,,154,2,,void
285816,BLOCK,-1,,"{
            // Found the first byte of a UTF-8 character. By looking at the
            // upper bits we can tell how long the character *should* be.
            if ((data[i] & 0xE0) == 0xC0) {
              state_[kMissingBytes] = 2;
            } else if ((data[i] & 0xF0) == 0xE0) {
              state_[kMissingBytes] = 3;
            } else if ((data[i] & 0xF8) == 0xF0) {
              state_[kMissingBytes] = 4;
            } else {
              // This lead byte would indicate a character outside of the
              // representable range.
              state_[kBufferedBytes] = 0;
              break;
            }

            if (BufferedBytes() >= MissingBytes()) {
              // Received more or exactly as many trailing bytes than the lead
              // character would indicate. In the ""=="" case, we have valid
              // data and don't need to slice anything off;
              // in the "">"" case, this is invalid UTF-8 anyway.
              state_[kMissingBytes...",18,,165,1,,void
285825,BLOCK,-1,,"{
              state_[kMissingBytes] = 2;
            }",43,,168,2,,void
285832,BLOCK,-1,,<empty>,20,,170,1,,void
285841,BLOCK,-1,,"{
              state_[kMissingBytes] = 3;
            }",50,,170,2,,void
285848,BLOCK,-1,,<empty>,20,,172,1,,void
285857,BLOCK,-1,,"{
              state_[kMissingBytes] = 4;
            }",50,,172,2,,void
285864,BLOCK,-1,,"{
              // This lead byte would indicate a character outside of the
              // representable range.
              state_[kBufferedBytes] = 0;
              break;
            }",20,,174,1,,void
285875,BLOCK,-1,,"{
              // Received more or exactly as many trailing bytes than the lead
              // character would indicate. In the ""=="" case, we have valid
              // data and don't need to slice anything off;
              // in the "">"" case, this is invalid UTF-8 anyway.
              state_[kMissingBytes] = 0;
              state_[kBufferedBytes] = 0;
            }",52,,181,2,,void
285895,BLOCK,-1,,<empty>,14,,194,1,,void
285900,BLOCK,-1,,"{
        if ((nread % 2) == 1) {
          // We got half a codepoint, and need the second byte of it.
          state_[kBufferedBytes] = 1;
          state_[kMissingBytes] = 1;
        } else if ((data[nread - 1] & 0xFC) == 0xD8) {
          // Half a split UTF-16 character.
          state_[kBufferedBytes] = 2;
          state_[kMissingBytes] = 2;
        }
      }",38,,194,2,,void
285907,BLOCK,-1,,"{
          // We got half a codepoint, and need the second byte of it.
          state_[kBufferedBytes] = 1;
          state_[kMissingBytes] = 1;
        }",31,,195,2,,void
285919,BLOCK,-1,,<empty>,16,,199,1,,void
285930,BLOCK,-1,,"{
          // Half a split UTF-16 character.
          state_[kBufferedBytes] = 2;
          state_[kMissingBytes] = 2;
        }",54,,199,2,,void
285942,BLOCK,-1,,<empty>,14,,204,1,,void
285951,BLOCK,-1,,"{
        state_[kBufferedBytes] = nread % 3;
        if (state_[kBufferedBytes] > 0)
          state_[kMissingBytes] = 3 - BufferedBytes();
      }",67,,204,2,,void
285965,BLOCK,-1,,<empty>,11,,207,2,,void
285977,BLOCK,-1,,"{
        // Copy the requested number of buffered bytes from the end of the
        // input into the incomplete character buffer.
        nread -= BufferedBytes();
        *nread_ptr -= BufferedBytes();
        memcpy(IncompleteCharacterBuffer(), data + nread, BufferedBytes());
      }",32,,210,2,,void
285995,BLOCK,-1,,"{
        if (!MakeString(isolate, data, nread, Encoding()).ToLocal(&body))
          return MaybeLocal<String>();
      }",22,,218,2,,void
286008,BLOCK,-1,,<empty>,11,,220,2,,void
286012,BLOCK,-1,,"{
        body = String::Empty(isolate);
      }",14,,221,1,,void
286025,BLOCK,-1,,"{
      return body;
    }",28,,226,2,,void
286029,BLOCK,-1,,"{
      return String::Concat(isolate, prepend, body);
    }",12,,228,1,,void
286039,BLOCK,-1,,"{
    CHECK(Encoding() == ASCII || Encoding() == HEX || Encoding() == LATIN1);
    return MakeString(isolate, data, nread, Encoding());
  }",10,,231,1,,void
286062,BLOCK,-1,,"{
  if (Encoding() == ASCII || Encoding() == HEX || Encoding() == LATIN1) {
    CHECK_EQ(MissingBytes(), 0);
    CHECK_EQ(BufferedBytes(), 0);
  }

  if (Encoding() == UCS2 && BufferedBytes() % 2 == 1) {
    // Ignore a single trailing byte, like the JS decoder does.
    state_[kMissingBytes]--;
    state_[kBufferedBytes]--;
  }

  if (BufferedBytes() == 0)
    return String::Empty(isolate);

  MaybeLocal<String> ret =
      MakeString(isolate,
                 IncompleteCharacterBuffer(),
                 BufferedBytes(),
                 Encoding());

  state_[kMissingBytes] = 0;
  state_[kBufferedBytes] = 0;

  return ret;
}",63,,237,2,,void
286075,BLOCK,-1,,"{
    CHECK_EQ(MissingBytes(), 0);
    CHECK_EQ(BufferedBytes(), 0);
  }",73,,238,2,,void
286092,BLOCK,-1,,"{
    // Ignore a single trailing byte, like the JS decoder does.
    state_[kMissingBytes]--;
    state_[kBufferedBytes]--;
  }",55,,243,2,,void
286105,BLOCK,-1,,<empty>,5,,250,2,,void
286140,BLOCK,-1,,"{
  StringDecoder* decoder =
      reinterpret_cast<StringDecoder*>(Buffer::Data(args[0]));
  CHECK_NOT_NULL(decoder);

  CHECK(args[1]->IsArrayBufferView());
  ArrayBufferViewContents<char> content(args[1].As<ArrayBufferView>());
  size_t length = content.length();

  MaybeLocal<String> ret =
      decoder->DecodeData(args.GetIsolate(), content.data(), &length);
  if (!ret.IsEmpty())
    args.GetReturnValue().Set(ret.ToLocalChecked());
}",58,,266,2,,void
286203,BLOCK,-1,,<empty>,5,,278,2,,void
286219,BLOCK,-1,,"{
  StringDecoder* decoder =
      reinterpret_cast<StringDecoder*>(Buffer::Data(args[0]));
  CHECK_NOT_NULL(decoder);
  MaybeLocal<String> ret = decoder->FlushData(args.GetIsolate());
  if (!ret.IsEmpty())
    args.GetReturnValue().Set(ret.ToLocalChecked());
}",57,,281,2,,void
286254,BLOCK,-1,,<empty>,5,,287,2,,void
286273,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

#define SET_DECODER_CONSTANT(name)                                            \
  target->Set(context,                                                        \
              FIXED_ONE_BYTE_STRING(isolate, #name),                          \
              Integer::New(isolate, StringDecoder::name)).FromJust()

  SET_DECODER_CONSTANT(kIncompleteCharactersStart);
  SET_DECODER_CONSTANT(kIncompleteCharactersEnd);
  SET_DECODER_CONSTANT(kMissingBytes);
  SET_DECODER_CONSTANT(kBufferedBytes);
  SET_DECODER_CONSTANT(kEncodingField);
  SET_DECODER_CONSTANT(kNumFields);

  Local<Array> encodings = Array::New(isolate);
#define ADD_TO_ENCODINGS_ARRAY(cname, jsname)                                 \
  encodings->Set(context,                                                     \
                 static_cast<int32_t>(cname),                                 \
                 FIXED_ONE_BYTE_STRING(isolate...",42,,293,5,,void
286290,BLOCK,1,,<empty>,,,,3,,void
286311,BLOCK,1,,<empty>,,,,3,,void
286332,BLOCK,1,,<empty>,,,,3,,void
286353,BLOCK,1,,<empty>,,,,3,,void
286374,BLOCK,1,,<empty>,,,,3,,void
286395,BLOCK,1,,<empty>,,,,3,,void
286429,BLOCK,1,,<empty>,,,,4,,void
286447,BLOCK,1,,<empty>,,,,4,,void
286465,BLOCK,1,,<empty>,,,,4,,void
286483,BLOCK,1,,<empty>,,,,4,,void
286501,BLOCK,1,,<empty>,,,,4,,void
286519,BLOCK,1,,<empty>,,,,4,,void
286537,BLOCK,1,,<empty>,,,,4,,void
286555,BLOCK,1,,<empty>,,,,4,,void
286614,BLOCK,-1,,"{
  registry->Register(DecodeData);
  registry->Register(FlushData);
}",42,,338,2,,void
286634,BLOCK,-1,,<empty>,1,,1,1,,ANY
286645,BLOCK,-1,,<empty>,1,,1,1,,ANY
286650,BLOCK,-1,,"{
      return uv_ip4_addr(ip_address, port, addr);
  }",74,,300,3,,void
286664,BLOCK,-1,,"{
      return uv_ip6_addr(ip_address, port, addr);
  }",76,,312,3,,void
286700,BLOCK,-1,,<empty>,1,,1,1,,ANY
286706,BLOCK,-1,,"{
  EscapableHandleScope handle_scope(env->isolate());
  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(parent);
  CHECK_EQ(env->tcp_constructor_template().IsEmpty(), false);
  Local<Function> constructor = env->tcp_constructor_template()
                                    ->GetFunction(env->context())
                                    .ToLocalChecked();
  CHECK_EQ(constructor.IsEmpty(), false);
  Local<Value> type_value = Int32::New(env->isolate(), type);
  return handle_scope.EscapeMaybe(
      constructor->NewInstance(env->context(), 1, &type_value));
}",67,,58,4,,void
286789,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->InstanceTemplate()->SetInternalFieldCount(StreamBase::kInternalFieldCount);

  // Init properties
  t->InstanceTemplate()->Set(FIXED_ONE_BYTE_STRING(env->isolate(), ""reading""),
                             Boolean::New(env->isolate(), false));
  t->InstanceTemplate()->Set(env->owner_symbol(), Null(env->isolate()));
  t->InstanceTemplate()->Set(env->onconnection_string(), Null(env->isolate()));

  t->Inherit(LibuvStreamWrap::GetConstructorTemplate(env));

  SetProtoMethod(isolate, t, ""open"", Open);
  SetProtoMethod(isolate, t, ""bind"", Bind);
  SetProtoMethod(isolate, t, ""listen"", Listen);
  SetProtoMethod(isolate, t, ""connect"", Connect);
  SetProtoMethod(isolate, t, ""bind6"", Bind6);
  SetProtoMethod(isolate, t, ""connect6"", Connect6);
  SetProtoMethod(isolate,
                 t,
                 ""getsockname"",
           ...",38,,75,5,,void
286996,BLOCK,1,,<empty>,,,,7,,void
286998,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, SOCKET)",3,,123,1,,void
287095,BLOCK,1,,<empty>,,,,7,,void
287097,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, SERVER)",3,,124,1,,void
287194,BLOCK,1,,<empty>,,,,7,,void
287196,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, UV_TCP_IPV6ONLY)",3,,125,1,,void
287305,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(Open);
  registry->Register(Bind);
  registry->Register(Listen);
  registry->Register(Connect);
  registry->Register(Bind6);
  registry->Register(Connect6);

  registry->Register(GetSockOrPeerName<TCPWrap, uv_tcp_getsockname>);
  registry->Register(GetSockOrPeerName<TCPWrap, uv_tcp_getpeername>);
  registry->Register(SetNoDelay);
  registry->Register(SetKeepAlive);
  registry->Register(Reset);
#ifdef _WIN32
  registry->Register(SetSimultaneousAccepts);
#endif
}",79,,131,2,,void
287370,BLOCK,-1,,"{
  // This constructor should not be exposed to public javascript.
  // Therefore we assert that we are not trying to call this as a
  // normal function.
  CHECK(args.IsConstructCall());
  CHECK(args[0]->IsInt32());
  Environment* env = Environment::GetCurrent(args);

  int type_value = args[0].As<Int32>()->Value();
  TCPWrap::SocketType type = static_cast<TCPWrap::SocketType>(type_value);

  ProviderType provider;
  switch (type) {
    case SOCKET:
      provider = PROVIDER_TCPWRAP;
      break;
    case SERVER:
      provider = PROVIDER_TCPSERVERWRAP;
      break;
    default:
      UNREACHABLE();
  }

  new TCPWrap(env, args.This(), provider);
}",60,,150,2,,void
287412,BLOCK,-1,,"{
    case SOCKET:
      provider = PROVIDER_TCPWRAP;
      break;
    case SERVER:
      provider = PROVIDER_TCPSERVERWRAP;
      break;
    default:
      UNREACHABLE();
  }",17,,162,2,,void
287441,BLOCK,-1,,"{
  int r = uv_tcp_init(env->event_loop(), &handle_);
  CHECK_EQ(r, 0);  // How do we proxy this error up to javascript?
                   // Suggestion: uv_tcp_init() returns void.
}",45,,178,4,,void
287459,BLOCK,-1,,"{
  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  int enable = static_cast<int>(args[0]->IsTrue());
  int err = uv_tcp_nodelay(&wrap->handle_, enable);
  args.GetReturnValue().Set(err);
}",67,,185,2,,void
287508,BLOCK,-1,,"{
  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  Environment* env = wrap->env();
  int enable;
  if (!args[0]->Int32Value(env->context()).To(&enable)) return;
  unsigned int delay = static_cast<unsigned int>(args[1].As<Uint32>()->Value());
  int err = uv_tcp_keepalive(&wrap->handle_, enable, delay);
  args.GetReturnValue().Set(err);
}",69,,196,2,,void
287550,BLOCK,-1,,<empty>,57,,203,2,,void
287588,BLOCK,-1,,"{
  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  int64_t val;
  if (!args[0]->IntegerValue(args.GetIsolate()->GetCurrentContext()).To(&val))
    return;
  int fd = static_cast<int>(val);
  int err = uv_tcp_open(&wrap->handle_, fd);

  if (err == 0)
    wrap->set_fd(fd);

  args.GetReturnValue().Set(err);
}",61,,223,2,,void
287626,BLOCK,-1,,<empty>,5,,230,2,,void
287647,BLOCK,-1,,<empty>,5,,235,2,,void
287667,BLOCK,-1,,"{
  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  Environment* env = wrap->env();
  node::Utf8Value ip_address(env->isolate(), args[0]);
  int port;
  unsigned int flags = 0;
  if (!args[1]->Int32Value(env->context()).To(&port)) return;
  if (family == AF_INET6 &&
      !args[2]->Uint32Value(env->context()).To(&flags)) {
    return;
  }

  T addr;
  int err = uv_ip_addr(*ip_address, port, &addr);

  if (err == 0) {
    err = uv_tcp_bind(&wrap->handle_,
                      reinterpret_cast<const sockaddr*>(&addr),
                      flags);
  }
  args.GetReturnValue().Set(err);
}",79,,244,4,,void
287722,BLOCK,-1,,<empty>,55,,253,2,,void
287745,BLOCK,-1,,"{
    return;
  }",57,,255,2,,void
287761,BLOCK,-1,,"{
    err = uv_tcp_bind(&wrap->handle_,
                      reinterpret_cast<const sockaddr*>(&addr),
                      flags);
  }",17,,262,2,,void
287786,BLOCK,-1,,"{
  Bind<sockaddr_in>(args, AF_INET, uv_ip4_addr);
}",61,,270,2,,void
287800,BLOCK,-1,,"{
  Bind<sockaddr_in6>(args, AF_INET6, uv_ip6_addr);
}",62,,275,2,,void
287814,BLOCK,-1,,"{
  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  Environment* env = wrap->env();
  int backlog;
  if (!args[0]->Int32Value(env->context()).To(&backlog)) return;
  int err = uv_listen(reinterpret_cast<uv_stream_t*>(&wrap->handle_),
                      backlog,
                      OnConnection);
  args.GetReturnValue().Set(err);
}",63,,280,2,,void
287856,BLOCK,-1,,<empty>,58,,287,2,,void
287882,BLOCK,-1,,"{
  CHECK(args[2]->IsUint32());
  // explicit cast to fit to libuv's type expectation
  int port = static_cast<int>(args[2].As<Uint32>()->Value());
  Connect<sockaddr_in>(args,
                       [port](const char* ip_address, sockaddr_in* addr) {
      return uv_ip4_addr(ip_address, port, addr);
  });
}",64,,295,2,,void
287915,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[2]->IsUint32());
  int port;
  if (!args[2]->Int32Value(env->context()).To(&port)) return;
  Connect<sockaddr_in6>(args,
                        [port](const char* ip_address, sockaddr_in6* addr) {
      return uv_ip6_addr(ip_address, port, addr);
  });
}",65,,306,2,,void
287948,BLOCK,-1,,<empty>,55,,310,2,,void
287963,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsString());

  Local<Object> req_wrap_obj = args[0].As<Object>();
  node::Utf8Value ip_address(env->isolate(), args[1]);

  T addr;
  int err = uv_ip_addr(*ip_address, &addr);

  if (err == 0) {
    AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(wrap);
    ConnectWrap* req_wrap =
        new ConnectWrap(env, req_wrap_obj, AsyncWrap::PROVIDER_TCPCONNECTWRAP);
    err = req_wrap->Dispatch(uv_tcp_connect,
                             &wrap->handle_,
                             reinterpret_cast<const sockaddr*>(&addr),
                             AfterConnect);
    if (err) {
      delete req_wrap;
    } else {
      CHECK(args[2]->Uint32Value(env->context()).IsJust());
      int port = args[2]->Uint32Value(env->context()).F...",69,,319,3,,void
288036,BLOCK,-1,,"{
    AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(wrap);
    ConnectWrap* req_wrap =
        new ConnectWrap(env, req_wrap_obj, AsyncWrap::PROVIDER_TCPCONNECTWRAP);
    err = req_wrap->Dispatch(uv_tcp_connect,
                             &wrap->handle_,
                             reinterpret_cast<const sockaddr*>(&addr),
                             AfterConnect);
    if (err) {
      delete req_wrap;
    } else {
      CHECK(args[2]->Uint32Value(env->context()).IsJust());
      int port = args[2]->Uint32Value(env->context()).FromJust();
      TRACE_EVENT_NESTABLE_ASYNC_BEGIN2(TRACING_CATEGORY_NODE2(net, native),
                                        ""connect"",
                                        req_wrap,
                                        ""ip"",
                                        TRACE_STR_COPY(*ip_address),
                                        ""port"",
                                        port);
    }
  }",17,,336,2,,void
288068,BLOCK,-1,,"{
      delete req_wrap;
    }",14,,344,2,,void
288072,BLOCK,-1,,"{
      CHECK(args[2]->Uint32Value(env->context()).IsJust());
      int port = args[2]->Uint32Value(env->context()).FromJust();
      TRACE_EVENT_NESTABLE_ASYNC_BEGIN2(TRACING_CATEGORY_NODE2(net, native),
                                        ""connect"",
                                        req_wrap,
                                        ""ip"",
                                        TRACE_STR_COPY(*ip_address),
                                        ""port"",
                                        port);
    }",12,,346,1,,void
288127,BLOCK,-1,,"{
  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(
      &wrap, args.Holder(), args.GetReturnValue().Set(UV_EBADF));

  int err = wrap->Reset(args[0]);

  args.GetReturnValue().Set(err);
}",62,,361,2,,void
288166,BLOCK,-1,,"{
  if (state_ != kInitialized) return 0;

  int err = uv_tcp_close_reset(&handle_, OnClose);
  state_ = kClosing;
  if (!err & !close_callback.IsEmpty() && close_callback->IsFunction() &&
      !persistent().IsEmpty()) {
    object()
        ->Set(env()->context(), env()->handle_onclose_symbol(), close_callback)
        .Check();
  }
  return err;
}",49,,371,2,,void
288171,BLOCK,-1,,<empty>,31,,372,2,,void
288204,BLOCK,-1,,"{
    object()
        ->Set(env()->context(), env()->handle_onclose_symbol(), close_callback)
        .Check();
  }",32,,377,2,,void
288229,BLOCK,-1,,"{
  EscapableHandleScope scope(env->isolate());
  char ip[INET6_ADDRSTRLEN + UV_IF_NAMESIZE];
  const sockaddr_in* a4;
  const sockaddr_in6* a6;

  int port;

  if (info.IsEmpty())
    info = Object::New(env->isolate());

  switch (addr->sa_family) {
  case AF_INET6:
    a6 = reinterpret_cast<const sockaddr_in6*>(addr);
    uv_inet_ntop(AF_INET6, &a6->sin6_addr, ip, sizeof ip);
    // Add an interface identifier to a link local address.
    if (IN6_IS_ADDR_LINKLOCAL(&a6->sin6_addr) && a6->sin6_scope_id > 0) {
      const size_t addrlen = strlen(ip);
      CHECK_LT(addrlen, sizeof(ip));
      ip[addrlen] = '%';
      size_t scopeidlen = sizeof(ip) - addrlen - 1;
      CHECK_GE(scopeidlen, UV_IF_NAMESIZE);
      const int r = uv_if_indextoiid(a6->sin6_scope_id,
                                     ip + addrlen + 1,
                                     &scopeidlen);
      if (r) {
        env->ThrowUVException(r, ""uv_if_indextoiid"");
        return {};
      }
    }
    port = ntohs(a6...",52,,388,4,,void
288245,BLOCK,-1,,<empty>,5,,397,2,,void
288260,BLOCK,-1,,"{
  case AF_INET6:
    a6 = reinterpret_cast<const sockaddr_in6*>(addr);
    uv_inet_ntop(AF_INET6, &a6->sin6_addr, ip, sizeof ip);
    // Add an interface identifier to a link local address.
    if (IN6_IS_ADDR_LINKLOCAL(&a6->sin6_addr) && a6->sin6_scope_id > 0) {
      const size_t addrlen = strlen(ip);
      CHECK_LT(addrlen, sizeof(ip));
      ip[addrlen] = '%';
      size_t scopeidlen = sizeof(ip) - addrlen - 1;
      CHECK_GE(scopeidlen, UV_IF_NAMESIZE);
      const int r = uv_if_indextoiid(a6->sin6_scope_id,
                                     ip + addrlen + 1,
                                     &scopeidlen);
      if (r) {
        env->ThrowUVException(r, ""uv_if_indextoiid"");
        return {};
      }
    }
    port = ntohs(a6->sin6_port);
    info->Set(env->context(),
              env->address_string(),
              OneByteString(env->isolate(), ip)).Check();
    info->Set(env->context(), env->family_string(), env->ipv6_string()).Check();
    info->Set(env->context(),...",28,,399,2,,void
288289,BLOCK,-1,,"{
      const size_t addrlen = strlen(ip);
      CHECK_LT(addrlen, sizeof(ip));
      ip[addrlen] = '%';
      size_t scopeidlen = sizeof(ip) - addrlen - 1;
      CHECK_GE(scopeidlen, UV_IF_NAMESIZE);
      const int r = uv_if_indextoiid(a6->sin6_scope_id,
                                     ip + addrlen + 1,
                                     &scopeidlen);
      if (r) {
        env->ThrowUVException(r, ""uv_if_indextoiid"");
        return {};
      }
    }",73,,404,2,,void
288332,BLOCK,-1,,"{
        env->ThrowUVException(r, ""uv_if_indextoiid"");
        return {};
      }",14,,413,2,,void
288539,BLOCK,-1,,<empty>,1,,1,1,,ANY
288550,BLOCK,-1,,<empty>,1,,1,1,,ANY
288563,BLOCK,-1,,<empty>,1,,1,1,,ANY
288578,BLOCK,-1,,<empty>,1,,1,1,,ANY
288581,BLOCK,-1,,"{
  if (timer_.data == nullptr) return;
  uv_timer_stop(&timer_);
}",24,,10,1,,void
288588,BLOCK,-1,,<empty>,31,,11,2,,void
288594,BLOCK,-1,,"{
  timer_.data = nullptr;
  env_->CloseHandle(reinterpret_cast<uv_handle_t*>(&timer_), TimerClosedCb);
}",25,,15,1,,void
288613,BLOCK,-1,,"{
  std::unique_ptr<TimerWrap> ptr(
      ContainerOf(&TimerWrap::timer_,
                  reinterpret_cast<uv_timer_t*>(handle)));
}",52,,20,2,,void
288634,BLOCK,-1,,"{
  if (timer_.data == nullptr) return;
  uv_timer_start(&timer_, OnTimeout, interval, repeat);
}",60,,26,3,,void
288641,BLOCK,-1,,<empty>,31,,27,2,,void
288652,BLOCK,-1,,"{
  if (timer_.data == nullptr) return;
  uv_ref(reinterpret_cast<uv_handle_t*>(&timer_));
}",23,,31,1,,void
288659,BLOCK,-1,,<empty>,31,,32,2,,void
288669,BLOCK,-1,,"{
  if (timer_.data == nullptr) return;
  uv_unref(reinterpret_cast<uv_handle_t*>(&timer_));
}",25,,36,1,,void
288676,BLOCK,-1,,<empty>,31,,37,2,,void
288687,BLOCK,-1,,"{
  TimerWrap* t = ContainerOf(&TimerWrap::timer_, timer);
  t->fn_();
}",46,,41,2,,void
288704,BLOCK,-1,,"{
  if (timer_ != nullptr)
    return timer_->Stop();
}",30,,46,1,,void
288709,BLOCK,-1,,<empty>,5,,48,2,,void
288718,BLOCK,-1,,"{
  if (timer_ != nullptr) {
    timer_->env()->RemoveCleanupHook(CleanupHook, this);
    timer_->Close();
  }
  timer_ = nullptr;
}",31,,51,1,,void
288723,BLOCK,-1,,"{
    timer_->env()->RemoveCleanupHook(CleanupHook, this);
    timer_->Close();
  }",26,,52,2,,void
288743,BLOCK,-1,,"{
  if (timer_ != nullptr)
    timer_->Ref();
}",29,,59,1,,void
288748,BLOCK,-1,,<empty>,5,,61,2,,void
288756,BLOCK,-1,,"{
  if (timer_ != nullptr)
    timer_->Unref();
}",31,,64,1,,void
288761,BLOCK,-1,,<empty>,5,,66,2,,void
288771,BLOCK,-1,,"{
  if (timer_ != nullptr)
    timer_->Update(interval, repeat);
}",66,,69,3,,void
288776,BLOCK,-1,,<empty>,5,,71,2,,void
288787,BLOCK,-1,,"{
  if (timer_ != nullptr)
    tracker->TrackField(""timer"", *timer_);
}",64,,74,2,,void
288792,BLOCK,-1,,<empty>,5,,76,2,,void
288804,BLOCK,-1,,"{
  static_cast<TimerWrapHandle*>(data)->Close();
}",47,,79,2,,void
288825,BLOCK,-1,,<empty>,1,,1,1,,ANY
288842,BLOCK,-1,,<empty>,1,,1,1,,ANY
288847,BLOCK,-1,,"{
  CHECK(args[0]->IsFunction());
  CHECK(args[1]->IsFunction());
  auto env = Environment::GetCurrent(args);

  env->set_immediate_callback_function(args[0].As<Function>());
  env->set_timers_callback_function(args[1].As<Function>());
}",72,,23,2,,void
288894,BLOCK,-1,,"{
  double now = GetLibuvNowImpl(Realm::GetBindingData<BindingData>(args));
  args.GetReturnValue().Set(Number::New(args.GetIsolate(), now));
}",76,,32,2,,void
288926,BLOCK,-1,,"{
  return GetLibuvNowImpl(FromJSObject<BindingData>(receiver));
}",61,,37,2,,void
288938,BLOCK,-1,,"{
  return static_cast<double>(data->env()->GetNowUint64());
}",56,,41,2,,void
288953,BLOCK,-1,,"{
  int64_t duration =
      args[0]->IntegerValue(args.GetIsolate()->GetCurrentContext()).FromJust();
  ScheduleTimerImpl(Realm::GetBindingData<BindingData>(args), duration);
}",78,,45,2,,void
288987,BLOCK,-1,,"{
  ScheduleTimerImpl(FromJSObject<BindingData>(receiver), duration);
}",79,,51,3,,void
289000,BLOCK,-1,,"{
  data->env()->ScheduleTimer(duration);
}",74,,55,3,,void
289013,BLOCK,-1,,"{
  ToggleTimerRefImpl(Realm::GetBindingData<BindingData>(args),
                     args[0]->IsTrue());
}",54,,60,2,,void
289033,BLOCK,-1,,"{
  ToggleTimerRefImpl(FromJSObject<BindingData>(receiver), ref);
}",72,,65,3,,void
289046,BLOCK,-1,,"{
  data->env()->ToggleTimerRef(ref);
}",67,,69,3,,void
289059,BLOCK,-1,,"{
  ToggleImmediateRefImpl(Realm::GetBindingData<BindingData>(args),
                         args[0]->IsTrue());
}",54,,74,2,,void
289079,BLOCK,-1,,"{
  ToggleImmediateRefImpl(FromJSObject<BindingData>(receiver), ref);
}",76,,79,3,,void
289092,BLOCK,-1,,"{
  data->env()->ToggleImmediateRef(ref);
}",71,,83,3,,void
289106,BLOCK,-1,,<empty>,51,,88,3,,void
289112,BLOCK,-1,,"{
  // Return true because we need to maintain the reference to the binding from
  // JS land.
  return true;
}",73,,91,3,,void
289119,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info =
      InternalFieldInfoBase::New<InternalFieldInfo>(type());
  return info;
}",58,,97,2,,void
289144,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  v8::HandleScope scope(context->GetIsolate());
  Realm* realm = Realm::GetCurrent(context);
  // Recreate the buffer in the constructor.
  BindingData* binding = realm->AddBindingData<BindingData>(context, holder);
  CHECK_NOT_NULL(binding);
}",60,,107,5,,void
289183,BLOCK,-1,,<empty>,,,,2,,<empty>
289188,BLOCK,-1,,<empty>,,,,2,,<empty>
289193,BLOCK,-1,,<empty>,,,,2,,<empty>
289198,BLOCK,-1,,<empty>,,,,2,,<empty>
289204,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();
  Local<ObjectTemplate> target = ctor->InstanceTemplate();

  SetMethod(isolate, target, ""setupTimers"", SetupTimers);
  SetFastMethod(
      isolate, target, ""getLibuvNow"", SlowGetLibuvNow, &fast_get_libuv_now_);
  SetFastMethod(isolate,
                target,
                ""scheduleTimer"",
                SlowScheduleTimer,
                &fast_schedule_timers_);
  SetFastMethod(isolate,
                target,
                ""toggleTimerRef"",
                SlowToggleTimerRef,
                &fast_toggle_timer_ref_);
  SetFastMethod(isolate,
                target,
                ""toggleImmediateRef"",
                SlowToggleImmediateRef,
                &fast_toggle_immediate_ref_);
}",76,,126,3,,void
289262,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(context);
  Environment* env = realm->env();
  BindingData* const binding_data =
      realm->AddBindingData<BindingData>(context, target);
  if (binding_data == nullptr) return;

  // TODO(joyeecheung): move these into BindingData.
  target
      ->Set(context,
            FIXED_ONE_BYTE_STRING(realm->isolate(), ""immediateInfo""),
            env->immediate_info()->fields().GetJSArray())
      .Check();

  target
      ->Set(context,
            FIXED_ONE_BYTE_STRING(realm->isolate(), ""timeoutInfo""),
            env->timeout_info().GetJSArray())
      .Check();
}",58,,153,5,,void
289295,BLOCK,-1,,<empty>,32,,158,2,,void
289346,BLOCK,-1,,"{
  registry->Register(SetupTimers);

  registry->Register(SlowGetLibuvNow);
  registry->Register(FastGetLibuvNow);
  registry->Register(fast_get_libuv_now_.GetTypeInfo());

  registry->Register(SlowScheduleTimer);
  registry->Register(FastScheduleTimer);
  registry->Register(fast_schedule_timers_.GetTypeInfo());

  registry->Register(SlowToggleTimerRef);
  registry->Register(FastToggleTimerRef);
  registry->Register(fast_toggle_timer_ref_.GetTypeInfo());

  registry->Register(SlowToggleImmediateRef);
  registry->Register(FastToggleImmediateRef);
  registry->Register(fast_toggle_immediate_ref_.GetTypeInfo());
}",42,,175,2,,void
289435,BLOCK,-1,,<empty>,1,,1,1,,ANY
289439,BLOCK,-1,,"{
    Agent* agent = ContainerOf(&Agent::initialize_writer_async_, async);
    agent->InitializeWritersOnThread();
  }",48,,58,2,,void
289459,BLOCK,-1,,"{
    Agent* agent = static_cast<Agent*>(arg);
    uv_run(&agent->tracing_loop_, UV_RUN_DEFAULT);
  }",56,,97,2,,void
289489,BLOCK,-1,,<empty>,1,,1,1,,ANY
289497,BLOCK,-1,,"{
    if (do_suspend) {
      CHECK(agent_->started_);
      controller->StopTracing();
    }
  }",69,,16,4,,void
289500,BLOCK,-1,,"{
      CHECK(agent_->started_);
      controller->StopTracing();
    }",21,,17,2,,void
289512,BLOCK,-1,,"{
    if (agent_ == nullptr) return;
    TraceConfig* config = agent_->CreateTraceConfig();
    if (config != nullptr) {
      controller_->StartTracing(config);
    }
  }",27,,23,1,,void
289517,BLOCK,-1,,<empty>,28,,24,2,,void
289530,BLOCK,-1,,"{
      controller_->StartTracing(config);
    }",28,,26,2,,void
289543,BLOCK,-1,,"{
  std::set<std::string> result;
  for (const auto& id_value : map)
    result.insert(id_value.second.begin(), id_value.second.end());
  return result;
}",69,,39,2,,void
289577,BLOCK,-1,,"{
  tracing_controller_->Initialize(nullptr);

  CHECK_EQ(uv_loop_init(&tracing_loop_), 0);
  CHECK_EQ(uv_async_init(&tracing_loop_,
                         &initialize_writer_async_,
                         [](uv_async_t* async) {
    Agent* agent = ContainerOf(&Agent::initialize_writer_async_, async);
    agent->InitializeWritersOnThread();
  }), 0);
  uv_unref(reinterpret_cast<uv_handle_t*>(&initialize_writer_async_));
}",63,,52,1,,void
289604,BLOCK,-1,,"{
  Mutex::ScopedLock lock(initialize_writer_mutex_);
  while (!to_be_initialized_.empty()) {
    AsyncTraceWriter* head = *to_be_initialized_.begin();
    head->InitializeOnThread(&tracing_loop_);
    to_be_initialized_.erase(head);
  }
  initialize_writer_condvar_.Broadcast(lock);
}",41,,65,1,,void
289614,BLOCK,-1,,"{
    AsyncTraceWriter* head = *to_be_initialized_.begin();
    head->InitializeOnThread(&tracing_loop_);
    to_be_initialized_.erase(head);
  }",39,,67,2,,void
289642,BLOCK,-1,,"{
  categories_.clear();
  writers_.clear();

  StopTracing();

  uv_close(reinterpret_cast<uv_handle_t*>(&initialize_writer_async_), nullptr);
  uv_run(&tracing_loop_, UV_RUN_ONCE);
  CheckedUvLoopClose(&tracing_loop_);
}",17,,75,1,,void
289668,BLOCK,-1,,"{
  if (started_)
    return;

  NodeTraceBuffer* trace_buffer_ = new NodeTraceBuffer(
      NodeTraceBuffer::kBufferChunks, this, &tracing_loop_);
  tracing_controller_->Initialize(trace_buffer_);

  // This thread should be created *after* async handles are created
  // (within NodeTraceWriter and NodeTraceBuffer constructors).
  // Otherwise the thread could shut down prematurely.
  CHECK_EQ(0, uv_thread_create(&thread_, [](void* arg) {
    Agent* agent = static_cast<Agent*>(arg);
    uv_run(&agent->tracing_loop_, UV_RUN_DEFAULT);
  }, this));
  started_ = true;
}",21,,86,1,,void
289671,BLOCK,-1,,<empty>,5,,88,2,,void
289705,BLOCK,-1,,"{
  Start();

  const std::set<std::string>* use_categories = &categories;

  std::set<std::string> categories_with_default;
  if (mode == kUseDefaultCategories) {
    categories_with_default.insert(categories.begin(), categories.end());
    categories_with_default.insert(categories_[kDefaultHandleId].begin(),
                                   categories_[kDefaultHandleId].end());
    use_categories = &categories_with_default;
  }

  ScopedSuspendTracing suspend(tracing_controller_.get(), this);
  int id = next_writer_id_++;
  AsyncTraceWriter* raw = writer.get();
  writers_[id] = std::move(writer);
  categories_[id] = { use_categories->begin(), use_categories->end() };

  {
    Mutex::ScopedLock lock(initialize_writer_mutex_);
    to_be_initialized_.insert(raw);
    uv_async_send(&initialize_writer_async_);
    while (to_be_initialized_.count(raw) > 0)
      initialize_writer_condvar_.Wait(lock);
  }

  return AgentWriterHandle(this, id);
}",39,,107,4,,void
289725,BLOCK,-1,,"{
    categories_with_default.insert(categories.begin(), categories.end());
    categories_with_default.insert(categories_[kDefaultHandleId].begin(),
                                   categories_[kDefaultHandleId].end());
    use_categories = &categories_with_default;
  }",38,,113,2,,void
289790,BLOCK,14,,"{
    Mutex::ScopedLock lock(initialize_writer_mutex_);
    to_be_initialized_.insert(raw);
    uv_async_send(&initialize_writer_async_);
    while (to_be_initialized_.count(raw) > 0)
      initialize_writer_condvar_.Wait(lock);
  }",3,,126,14,,void
289822,BLOCK,-1,,"{
  return AgentWriterHandle(this, kDefaultHandleId);
}",42,,137,1,,void
289830,BLOCK,-1,,"{
  if (!started_)
    return;
  // Perform final Flush on TraceBuffer. We don't want the tracing controller
  // to flush the buffer again on destruction of the V8::Platform.
  tracing_controller_->StopTracing();
  tracing_controller_->Initialize(nullptr);
  started_ = false;

  // Thread should finish when the tracing loop is stopped.
  uv_thread_join(&thread_);
}",27,,141,1,,void
289834,BLOCK,-1,,<empty>,5,,143,2,,void
289855,BLOCK,-1,,"{
  if (client == kDefaultHandleId) return;
  {
    Mutex::ScopedLock lock(initialize_writer_mutex_);
    to_be_initialized_.erase(writers_[client].get());
  }
  ScopedSuspendTracing suspend(tracing_controller_.get(), this);
  writers_.erase(client);
  categories_.erase(client);
}",36,,154,2,,void
289860,BLOCK,-1,,<empty>,35,,155,2,,void
289862,BLOCK,2,,"{
    Mutex::ScopedLock lock(initialize_writer_mutex_);
    to_be_initialized_.erase(writers_[client].get());
  }",3,,156,2,,void
289898,BLOCK,-1,,"{
  if (categories.empty())
    return;

  ScopedSuspendTracing suspend(tracing_controller_.get(), this,
                               id != kDefaultHandleId);
  categories_[id].insert(categories.begin(), categories.end());
}",69,,165,3,,void
289904,BLOCK,-1,,<empty>,5,,167,2,,void
289935,BLOCK,-1,,"{
  ScopedSuspendTracing suspend(tracing_controller_.get(), this,
                               id != kDefaultHandleId);
  std::multiset<std::string>& writer_categories = categories_[id];
  for (const std::string& category : categories) {
    auto it = writer_categories.find(category);
    if (it != writer_categories.end())
      writer_categories.erase(it);
  }
}",70,,174,3,,void
289963,BLOCK,-1,,"{
    auto it = writer_categories.find(category);
    if (it != writer_categories.end())
      writer_categories.erase(it);
  }",50,,178,3,,void
289979,BLOCK,-1,,<empty>,7,,181,2,,void
289988,BLOCK,-1,,"{
  if (categories_.empty())
    return nullptr;
  TraceConfig* trace_config = new TraceConfig();
  for (const auto& category : flatten(categories_)) {
    trace_config->AddIncludedCategory(category.c_str());
  }
  return trace_config;
}",47,,185,1,,void
289994,BLOCK,-1,,<empty>,5,,187,2,,void
290006,BLOCK,-1,,"{
    trace_config->AddIncludedCategory(category.c_str());
  }",53,,189,3,,void
290020,BLOCK,-1,,"{
  std::string categories;
  for (const std::string& category : flatten(categories_)) {
    if (!categories.empty())
      categories += ',';
    categories += category;
  }
  return categories;
}",49,,195,1,,void
290026,BLOCK,-1,,"{
    if (!categories.empty())
      categories += ',';
    categories += category;
  }",60,,197,3,,void
290033,BLOCK,-1,,<empty>,7,,199,2,,void
290046,BLOCK,-1,,"{
  for (const auto& id_writer : writers_)
    id_writer.second->AppendTraceEvent(trace_event);
}",56,,205,2,,void
290061,BLOCK,-1,,"{
  Mutex::ScopedLock lock(metadata_events_mutex_);
  metadata_events_.push_back(std::move(event));
}",66,,210,2,,void
290078,BLOCK,-1,,"{
  {
    Mutex::ScopedLock lock(metadata_events_mutex_);
    for (const auto& event : metadata_events_)
      AppendTraceEvent(event.get());
  }

  for (const auto& id_writer : writers_)
    id_writer.second->Flush(blocking);
}",34,,215,2,,void
290079,BLOCK,1,,"{
    Mutex::ScopedLock lock(metadata_events_mutex_);
    for (const auto& event : metadata_events_)
      AppendTraceEvent(event.get());
  }",3,,216,1,,void
290112,BLOCK,-1,,"{
  std::unique_ptr<TraceObject> trace_event(new TraceObject);
  trace_event->Initialize(
      TRACE_EVENT_PHASE_METADATA, category_group_enabled, name,
      node::tracing::kGlobalScope,  // scope
      node::tracing::kNoId,         // id
      node::tracing::kNoId,         // bind_id
      num_args, arg_names, arg_types, arg_values, convertable_values,
      TRACE_EVENT_FLAG_NONE,
      CurrentTimestampMicroseconds(),
      CurrentCpuTimestampMicroseconds());
  Agent* node_agent = node::tracing::TraceEventHelper::GetAgent();
  if (node_agent != nullptr)
    node_agent->AddMetadataEvent(std::move(trace_event));
}",25,,234,9,,void
290127,BLOCK,1,,<empty>,,,,1,,void
290152,BLOCK,1,,<empty>,,,,1,,void
290173,BLOCK,-1,,<empty>,5,,247,2,,void
290205,BLOCK,-1,,<empty>,1,,1,1,,ANY
290214,BLOCK,-1,,<empty>,,,,1,,<empty>
290219,BLOCK,-1,,<empty>,,,,2,,<empty>
290224,BLOCK,-1,,<empty>,,,,2,,<empty>
290229,BLOCK,-1,,<empty>,52,,32,2,,void
290234,BLOCK,-1,,<empty>,68,,37,1,,void
290238,BLOCK,-1,,"{
    return uv_hrtime() / 1000;
  }",51,,39,1,,void
290254,BLOCK,-1,,<empty>,,,,9,,<empty>
290259,BLOCK,-1,,<empty>,,,,1,,<empty>
290263,BLOCK,-1,,{ reset(); },31,,56,1,,void
290269,BLOCK,-1,,<empty>,,,,2,,<empty>
290274,BLOCK,-1,,<empty>,,,,2,,<empty>
290278,BLOCK,-1,,{ return agent_ == nullptr; },29,,60,1,,void
290286,BLOCK,-1,,<empty>,,,,1,,<empty>
290291,BLOCK,-1,,<empty>,,,,2,,<empty>
290296,BLOCK,-1,,<empty>,,,,2,,<empty>
290300,BLOCK,-1,,<empty>,,,,1,,<empty>
290304,BLOCK,-1,,{ return agent_; },25,,68,1,,void
290310,BLOCK,-1,,<empty>,,,,1,,<empty>
290315,BLOCK,-1,,<empty>,,,,2,,<empty>
290320,BLOCK,-1,,<empty>,,,,2,,<empty>
290326,BLOCK,-1,,<empty>,75,,76,3,,void
290333,BLOCK,-1,,<empty>,,,,1,,<empty>
290344,BLOCK,-1,,<empty>,,,,1,,<empty>
290348,BLOCK,-1,,<empty>,,,,1,,<empty>
290352,BLOCK,-1,,"{
    TracingController* controller = tracing_controller_.get();
    CHECK_NOT_NULL(controller);
    return controller;
  }",45,,89,1,,void
290373,BLOCK,-1,,<empty>,,,,4,,<empty>
290377,BLOCK,-1,,<empty>,,,,1,,<empty>
290381,BLOCK,-1,,<empty>,,,,1,,<empty>
290386,BLOCK,-1,,<empty>,,,,2,,<empty>
290391,BLOCK,-1,,<empty>,,,,2,,<empty>
290396,BLOCK,-1,,<empty>,,,,2,,<empty>
290400,BLOCK,-1,,<empty>,,,,1,,<empty>
290405,BLOCK,-1,,<empty>,,,,1,,<empty>
290409,BLOCK,-1,,<empty>,,,,1,,<empty>
290413,BLOCK,-1,,<empty>,,,,1,,<empty>
290418,BLOCK,-1,,<empty>,,,,2,,<empty>
290424,BLOCK,-1,,<empty>,,,,3,,<empty>
290430,BLOCK,-1,,<empty>,,,,3,,<empty>
290441,BLOCK,-1,,<empty>,,,,1,,<empty>
290458,BLOCK,-1,,<empty>,,,,1,,<empty>
290468,BLOCK,-1,,"{
  if (agent_ != nullptr)
    agent_->Disconnect(id_);
  agent_ = nullptr;
}",33,,158,1,,void
290473,BLOCK,-1,,<empty>,5,,160,2,,void
290486,BLOCK,-1,,"{
  reset();
  agent_ = other.agent_;
  id_ = other.id_;
  other.agent_ = nullptr;
  return *this;
}",76,,164,2,,void
290510,BLOCK,-1,,"{
  *this = std::move(other);
}",65,,172,2,,void
290523,BLOCK,-1,,"{
  if (agent_ != nullptr) agent_->Enable(id_, categories);
}",73,,176,2,,void
290528,BLOCK,-1,,<empty>,26,,177,2,,void
290539,BLOCK,-1,,"{
  if (agent_ != nullptr) agent_->Disable(id_, categories);
}",74,,180,2,,void
290544,BLOCK,-1,,<empty>,26,,181,2,,void
290554,BLOCK,-1,,"{
  return agent_ != nullptr && id_ == Agent::kDefaultHandleId;
}",43,,184,1,,void
290568,BLOCK,-1,,"{
  return agent_ != nullptr ? agent_->GetTracingController() : nullptr;
}",73,,188,1,,void
290584,BLOCK,-1,,"{
      NodeTraceBuffer* buffer =
          ContainerOf(&NodeTraceBuffer::exit_signal_,
                      reinterpret_cast<uv_async_t*>(signal));
        Mutex::ScopedLock scoped_lock(buffer->exit_mutex_);
        buffer->exited_ = true;
        buffer->exit_cond_.Signal(scoped_lock);
    }",38,,187,2,,void
290620,BLOCK,-1,,"{
    NodeTraceBuffer* buffer =
        ContainerOf(&NodeTraceBuffer::flush_signal_,
                    reinterpret_cast<uv_async_t*>(signal));

    uv_close(reinterpret_cast<uv_handle_t*>(&buffer->exit_signal_),
             [](uv_handle_t* signal) {
      NodeTraceBuffer* buffer =
          ContainerOf(&NodeTraceBuffer::exit_signal_,
                      reinterpret_cast<uv_async_t*>(signal));
        Mutex::ScopedLock scoped_lock(buffer->exit_mutex_);
        buffer->exited_ = true;
        buffer->exit_cond_.Signal(scoped_lock);
    });
  }",36,,181,2,,void
290651,BLOCK,-1,,<empty>,1,,1,1,,ANY
290658,BLOCK,-1,,"{
  chunks_.resize(max_chunks);
}",30,,12,4,,void
290668,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(mutex_);
  // Create new chunk if last chunk is full or there is no chunk.
  if (total_chunks_ == 0 || chunks_[total_chunks_ - 1]->IsFull()) {
    auto& chunk = chunks_[total_chunks_++];
    if (chunk) {
      chunk->Reset(current_chunk_seq_++);
    } else {
      chunk = std::make_unique<TraceBufferChunk>(current_chunk_seq_++);
    }
  }
  auto& chunk = chunks_[total_chunks_ - 1];
  size_t event_index;
  TraceObject* trace_object = chunk->AddTraceEvent(&event_index);
  *handle = MakeHandle(total_chunks_ - 1, chunk->seq(), event_index);
  return trace_object;
}",67,,16,2,,void
290685,BLOCK,-1,,"{
    auto& chunk = chunks_[total_chunks_++];
    if (chunk) {
      chunk->Reset(current_chunk_seq_++);
    } else {
      chunk = std::make_unique<TraceBufferChunk>(current_chunk_seq_++);
    }
  }",67,,19,2,,void
290695,BLOCK,-1,,"{
      chunk->Reset(current_chunk_seq_++);
    }",16,,21,2,,void
290703,BLOCK,-1,,"{
      chunk = std::make_unique<TraceBufferChunk>(current_chunk_seq_++);
    }",12,,23,1,,void
290750,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(mutex_);
  if (handle == 0) {
    // A handle value of zero never has a trace event associated with it.
    return nullptr;
  }
  size_t chunk_index, event_index;
  uint32_t buffer_id, chunk_seq;
  ExtractHandle(handle, &buffer_id, &chunk_index, &chunk_seq, &event_index);
  if (buffer_id != id_ || chunk_index >= total_chunks_) {
    // Either the chunk belongs to the other buffer, or is outside the current
    // range of chunks loaded in memory (the latter being true suggests that
    // the chunk has already been flushed and is no longer in memory.)
    return nullptr;
  }
  auto& chunk = chunks_[chunk_index];
  if (chunk->seq() != chunk_seq) {
    // Chunk is no longer in memory.
    return nullptr;
  }
  return chunk->GetEventAt(event_index);
}",69,,34,2,,void
290758,BLOCK,-1,,"{
    // A handle value of zero never has a trace event associated with it.
    return nullptr;
  }",20,,36,2,,void
290783,BLOCK,-1,,"{
    // Either the chunk belongs to the other buffer, or is outside the current
    // range of chunks loaded in memory (the latter being true suggests that
    // the chunk has already been flushed and is no longer in memory.)
    return nullptr;
  }",57,,43,2,,void
290799,BLOCK,-1,,"{
    // Chunk is no longer in memory.
    return nullptr;
  }",34,,50,2,,void
290812,BLOCK,-1,,"{
  {
    Mutex::ScopedLock scoped_lock(mutex_);
    if (total_chunks_ > 0) {
      flushing_ = true;
      for (size_t i = 0; i < total_chunks_; ++i) {
        auto& chunk = chunks_[i];
        for (size_t j = 0; j < chunk->size(); ++j) {
          TraceObject* trace_event = chunk->GetEventAt(j);
          // Another thread may have added a trace that is yet to be
          // initialized. Skip such traces.
          // https://github.com/nodejs/node/issues/21038.
          if (trace_event->name()) {
            agent_->AppendTraceEvent(trace_event);
          }
        }
      }
      total_chunks_ = 0;
      flushing_ = false;
    }
  }
  agent_->Flush(blocking);
}",48,,57,2,,void
290813,BLOCK,1,,"{
    Mutex::ScopedLock scoped_lock(mutex_);
    if (total_chunks_ > 0) {
      flushing_ = true;
      for (size_t i = 0; i < total_chunks_; ++i) {
        auto& chunk = chunks_[i];
        for (size_t j = 0; j < chunk->size(); ++j) {
          TraceObject* trace_event = chunk->GetEventAt(j);
          // Another thread may have added a trace that is yet to be
          // initialized. Skip such traces.
          // https://github.com/nodejs/node/issues/21038.
          if (trace_event->name()) {
            agent_->AppendTraceEvent(trace_event);
          }
        }
      }
      total_chunks_ = 0;
      flushing_ = false;
    }
  }",3,,58,1,,void
290821,BLOCK,-1,,"{
      flushing_ = true;
      for (size_t i = 0; i < total_chunks_; ++i) {
        auto& chunk = chunks_[i];
        for (size_t j = 0; j < chunk->size(); ++j) {
          TraceObject* trace_event = chunk->GetEventAt(j);
          // Another thread may have added a trace that is yet to be
          // initialized. Skip such traces.
          // https://github.com/nodejs/node/issues/21038.
          if (trace_event->name()) {
            agent_->AppendTraceEvent(trace_event);
          }
        }
      }
      total_chunks_ = 0;
      flushing_ = false;
    }",28,,60,2,,void
290826,BLOCK,-1,,<empty>,7,,62,1,,void
290836,BLOCK,4,,"{
        auto& chunk = chunks_[i];
        for (size_t j = 0; j < chunk->size(); ++j) {
          TraceObject* trace_event = chunk->GetEventAt(j);
          // Another thread may have added a trace that is yet to be
          // initialized. Skip such traces.
          // https://github.com/nodejs/node/issues/21038.
          if (trace_event->name()) {
            agent_->AppendTraceEvent(trace_event);
          }
        }
      }",50,,62,4,,void
290844,BLOCK,-1,,<empty>,9,,64,1,,void
290857,BLOCK,4,,"{
          TraceObject* trace_event = chunk->GetEventAt(j);
          // Another thread may have added a trace that is yet to be
          // initialized. Skip such traces.
          // https://github.com/nodejs/node/issues/21038.
          if (trace_event->name()) {
            agent_->AppendTraceEvent(trace_event);
          }
        }",52,,64,4,,void
290871,BLOCK,-1,,"{
            agent_->AppendTraceEvent(trace_event);
          }",36,,69,2,,void
290894,BLOCK,-1,,"{
  return ((static_cast<uint64_t>(chunk_seq) * Capacity() +
          chunk_index * TraceBufferChunk::kChunkSize + event_index) << 1) + id_;
}",71,,82,4,,void
290921,BLOCK,-1,,"{
  *buffer_id = static_cast<uint32_t>(handle & 0x1);
  handle >>= 1;
  *chunk_seq = static_cast<uint32_t>(handle / Capacity());
  size_t indices = handle % Capacity();
  *chunk_index = indices / TraceBufferChunk::kChunkSize;
  *event_index = indices % TraceBufferChunk::kChunkSize;
}",53,,89,6,,void
290969,BLOCK,-1,,"{
  current_buf_.store(&buffer1_);

  flush_signal_.data = this;
  int err = uv_async_init(tracing_loop_, &flush_signal_,
                          NonBlockingFlushSignalCb);
  CHECK_EQ(err, 0);

  exit_signal_.data = this;
  err = uv_async_init(tracing_loop_, &exit_signal_, ExitSignalCb);
  CHECK_EQ(err, 0);
}",38,,102,4,,void
291010,BLOCK,-1,,"{
  uv_async_send(&exit_signal_);
  Mutex::ScopedLock scoped_lock(exit_mutex_);
  while (!exited_) {
    exit_cond_.Wait(scoped_lock);
  }
}",37,,115,1,,void
291020,BLOCK,-1,,"{
    exit_cond_.Wait(scoped_lock);
  }",20,,118,2,,void
291030,BLOCK,-1,,"{
  // If the buffer is full, attempt to perform a flush.
  if (!TryLoadAvailableBuffer()) {
    // Assign a value of zero as the trace event handle.
    // This is equivalent to calling InternalTraceBuffer::MakeHandle(0, 0, 0),
    // and will cause GetEventByHandle to return NULL if passed as an argument.
    *handle = 0;
    return nullptr;
  }
  return current_buf_.load()->AddTraceEvent(handle);
}",63,,123,2,,void
291034,BLOCK,-1,,"{
    // Assign a value of zero as the trace event handle.
    // This is equivalent to calling InternalTraceBuffer::MakeHandle(0, 0, 0),
    // and will cause GetEventByHandle to return NULL if passed as an argument.
    *handle = 0;
    return nullptr;
  }",34,,125,2,,void
291054,BLOCK,-1,,"{
  return current_buf_.load()->GetEventByHandle(handle);
}",65,,135,2,,void
291067,BLOCK,-1,,"{
  buffer1_.Flush(true);
  buffer2_.Flush(true);
  return true;
}",31,,139,1,,void
291083,BLOCK,-1,,"{
  InternalTraceBuffer* prev_buf = current_buf_.load();
  if (prev_buf->IsFull()) {
    uv_async_send(&flush_signal_);  // trigger flush on a separate thread
    InternalTraceBuffer* other_buf = prev_buf == &buffer1_ ?
      &buffer2_ : &buffer1_;
    if (!other_buf->IsFull()) {
      current_buf_.store(other_buf);
    } else {
      return false;
    }
  }
  return true;
}",48,,148,1,,void
291096,BLOCK,-1,,"{
    uv_async_send(&flush_signal_);  // trigger flush on a separate thread
    InternalTraceBuffer* other_buf = prev_buf == &buffer1_ ?
      &buffer2_ : &buffer1_;
    if (!other_buf->IsFull()) {
      current_buf_.store(other_buf);
    } else {
      return false;
    }
  }",27,,150,2,,void
291118,BLOCK,-1,,"{
      current_buf_.store(other_buf);
    }",31,,154,2,,void
291125,BLOCK,-1,,"{
      return false;
    }",12,,156,1,,void
291134,BLOCK,-1,,"{
  NodeTraceBuffer* buffer = static_cast<NodeTraceBuffer*>(signal->data);
  if (buffer->buffer1_.IsFull() && !buffer->buffer1_.IsFlushing()) {
    buffer->buffer1_.Flush(false);
  }
  if (buffer->buffer2_.IsFull() && !buffer->buffer2_.IsFlushing()) {
    buffer->buffer2_.Flush(false);
  }
}",68,,164,2,,void
291158,BLOCK,-1,,"{
    buffer->buffer1_.Flush(false);
  }",68,,166,2,,void
291181,BLOCK,-1,,"{
    buffer->buffer2_.Flush(false);
  }",68,,169,2,,void
291192,BLOCK,-1,,"{
  NodeTraceBuffer* buffer =
      ContainerOf(&NodeTraceBuffer::exit_signal_, signal);

  // Close both flush_signal_ and exit_signal_.
  uv_close(reinterpret_cast<uv_handle_t*>(&buffer->flush_signal_),
           [](uv_handle_t* signal) {
    NodeTraceBuffer* buffer =
        ContainerOf(&NodeTraceBuffer::flush_signal_,
                    reinterpret_cast<uv_async_t*>(signal));

    uv_close(reinterpret_cast<uv_handle_t*>(&buffer->exit_signal_),
             [](uv_handle_t* signal) {
      NodeTraceBuffer* buffer =
          ContainerOf(&NodeTraceBuffer::exit_signal_,
                      reinterpret_cast<uv_async_t*>(signal));
        Mutex::ScopedLock scoped_lock(buffer->exit_mutex_);
        buffer->exited_ = true;
        buffer->exit_cond_.Signal(scoped_lock);
    });
  });
}",56,,175,2,,void
291224,BLOCK,-1,,<empty>,1,,1,1,,ANY
291233,BLOCK,-1,,<empty>,,,,4,,<empty>
291238,BLOCK,-1,,<empty>,,,,2,,<empty>
291243,BLOCK,-1,,<empty>,,,,2,,<empty>
291248,BLOCK,-1,,<empty>,,,,2,,<empty>
291252,BLOCK,-1,,"{
    return total_chunks_ == max_chunks_ && chunks_[total_chunks_ - 1]->IsFull();
  }",23,,27,1,,void
291269,BLOCK,-1,,"{
    return flushing_;
  }",27,,30,1,,void
291278,BLOCK,-1,,<empty>,,,,4,,<empty>
291287,BLOCK,-1,,<empty>,,,,6,,<empty>
291291,BLOCK,-1,,{ return max_chunks_ * TraceBufferChunk::kChunkSize; },27,,39,1,,void
291309,BLOCK,-1,,<empty>,,,,1,,<empty>
291323,BLOCK,-1,,<empty>,,,,4,,<empty>
291327,BLOCK,-1,,<empty>,,,,1,,<empty>
291332,BLOCK,-1,,<empty>,,,,2,,<empty>
291337,BLOCK,-1,,<empty>,,,,2,,<empty>
291341,BLOCK,-1,,<empty>,,,,1,,<empty>
291346,BLOCK,-1,,<empty>,,,,1,,<empty>
291351,BLOCK,-1,,<empty>,,,,2,,<empty>
291356,BLOCK,-1,,<empty>,,,,2,,<empty>
291369,BLOCK,-1,,<empty>,,,,1,,<empty>
291381,BLOCK,-1,,"{
    NodeTraceWriter* trace_writer =
        ContainerOf(&NodeTraceWriter::flush_signal_, signal);
    trace_writer->FlushPrivate();
  }",50,,20,2,,void
291401,BLOCK,-1,,"{
        NodeTraceWriter* writer =
            ContainerOf(&NodeTraceWriter::write_req_, req);
        writer->AfterWrite();
      }",24,,187,2,,void
291420,BLOCK,-1,,"{
                   NodeTraceWriter* trace_writer =
                       ContainerOf(&NodeTraceWriter::exit_signal_,
                                   reinterpret_cast<uv_async_t*>(signal));
                   Mutex::ScopedLock scoped_lock(trace_writer->request_mutex_);
                   trace_writer->exited_ = true;
                   trace_writer->exit_cond_.Signal(scoped_lock);
                 }",42,,229,2,,void
291455,BLOCK,-1,,"{
             NodeTraceWriter* trace_writer =
                 ContainerOf(&NodeTraceWriter::flush_signal_,
                             reinterpret_cast<uv_async_t*>(signal));
             uv_close(
                 reinterpret_cast<uv_handle_t*>(&trace_writer->exit_signal_),
                 [](uv_handle_t* signal) {
                   NodeTraceWriter* trace_writer =
                       ContainerOf(&NodeTraceWriter::exit_signal_,
                                   reinterpret_cast<uv_async_t*>(signal));
                   Mutex::ScopedLock scoped_lock(trace_writer->request_mutex_);
                   trace_writer->exited_ = true;
                   trace_writer->exit_cond_.Signal(scoped_lock);
                 });
           }",36,,223,2,,void
291488,BLOCK,-1,,<empty>,1,,1,1,,ANY
291493,BLOCK,-1,,<empty>,43,,12,2,,void
291498,BLOCK,-1,,"{
  CHECK_NULL(tracing_loop_);
  tracing_loop_ = loop;

  flush_signal_.data = this;
  int err = uv_async_init(tracing_loop_, &flush_signal_,
                          [](uv_async_t* signal) {
    NodeTraceWriter* trace_writer =
        ContainerOf(&NodeTraceWriter::flush_signal_, signal);
    trace_writer->FlushPrivate();
  });
  CHECK_EQ(err, 0);

  exit_signal_.data = this;
  err = uv_async_init(tracing_loop_, &exit_signal_, ExitSignalCb);
  CHECK_EQ(err, 0);
}",59,,14,2,,void
291538,BLOCK,-1,,"{
  // If our final log file has traces, then end the file appropriately.
  // This means that if no trace events are recorded, then no trace file is
  // produced.
  bool should_flush = false;
  {
    Mutex::ScopedLock scoped_lock(stream_mutex_);
    if (total_traces_ > 0) {
      total_traces_ = kTracesPerFile;  // Act as if we reached the file limit.
      should_flush = true;
    }
  }
  if (should_flush) {
    Flush(true);
  }
}",37,,32,1,,void
291543,BLOCK,3,,"{
    Mutex::ScopedLock scoped_lock(stream_mutex_);
    if (total_traces_ > 0) {
      total_traces_ = kTracesPerFile;  // Act as if we reached the file limit.
      should_flush = true;
    }
  }",3,,37,3,,void
291551,BLOCK,-1,,"{
      total_traces_ = kTracesPerFile;  // Act as if we reached the file limit.
      should_flush = true;
    }",28,,39,2,,void
291560,BLOCK,-1,,"{
    Flush(true);
  }",21,,44,2,,void
291566,BLOCK,-1,,"{
  WriteSuffix();
  uv_fs_t req;
  if (fd_ != -1) {
    CHECK_EQ(0, uv_fs_close(nullptr, &req, fd_, nullptr));
    uv_fs_req_cleanup(&req);
  }
  uv_async_send(&exit_signal_);
  Mutex::ScopedLock scoped_lock(request_mutex_);
  while (!exited_) {
    exit_cond_.Wait(scoped_lock);
  }
}",37,,49,1,,void
291574,BLOCK,-1,,"{
    CHECK_EQ(0, uv_fs_close(nullptr, &req, fd_, nullptr));
    uv_fs_req_cleanup(&req);
  }",18,,52,2,,void
291595,BLOCK,-1,,"{
    exit_cond_.Wait(scoped_lock);
  }",20,,58,2,,void
291607,BLOCK,-1,,"{
  size_t pos = target->find(search);
  for (; pos != std::string::npos; pos = target->find(search, pos)) {
    target->replace(pos, search.size(), insert);
    pos += insert.size();
  }
}",51,,65,4,,void
291617,BLOCK,-1,,<empty>,3,,67,1,,void
291633,BLOCK,4,,"{
    target->replace(pos, search.size(), insert);
    pos += insert.size();
  }",69,,67,4,,void
291653,BLOCK,-1,,"{
  ++file_num_;
  uv_fs_t req;

  // Evaluate a JS-style template string, it accepts the values ${pid} and
  // ${rotation}
  std::string filepath(log_file_pattern_);
  replace_substring(&filepath, ""${pid}"", std::to_string(uv_os_getpid()));
  replace_substring(&filepath, ""${rotation}"", std::to_string(file_num_));

  if (fd_ != -1) {
    CHECK_EQ(uv_fs_close(nullptr, &req, fd_, nullptr), 0);
    uv_fs_req_cleanup(&req);
  }

  fd_ = uv_fs_open(nullptr, &req, filepath.c_str(),
      O_CREAT | O_WRONLY | O_TRUNC, 0644, nullptr);
  uv_fs_req_cleanup(&req);
  if (fd_ < 0) {
    fprintf(stderr, ""Could not open trace file %s: %s\n"",
                    filepath.c_str(),
                    uv_strerror(fd_));
    fd_ = -1;
  }
}",49,,73,1,,void
291683,BLOCK,-1,,"{
    CHECK_EQ(uv_fs_close(nullptr, &req, fd_, nullptr), 0);
    uv_fs_req_cleanup(&req);
  }",18,,83,2,,void
291719,BLOCK,-1,,"{
    fprintf(stderr, ""Could not open trace file %s: %s\n"",
                    filepath.c_str(),
                    uv_strerror(fd_));
    fd_ = -1;
  }",16,,91,2,,void
291737,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(stream_mutex_);
  // If this is the first trace event, open a new file for streaming.
  if (total_traces_ == 0) {
    OpenNewFileForStreaming();
    // Constructing a new JSONTraceWriter object appends ""{\""traceEvents\"":[""
    // to stream_.
    // In other words, the constructor initializes the serialization stream
    // to a state where we can start writing trace events to it.
    // Repeatedly constructing and destroying json_trace_writer_ allows
    // us to use V8's JSON writer instead of implementing our own.
    json_trace_writer_.reset(TraceWriter::CreateJSONTraceWriter(stream_));
  }
  ++total_traces_;
  json_trace_writer_->AppendTraceEvent(trace_event);
}",66,,99,2,,void
291745,BLOCK,-1,,"{
    OpenNewFileForStreaming();
    // Constructing a new JSONTraceWriter object appends ""{\""traceEvents\"":[""
    // to stream_.
    // In other words, the constructor initializes the serialization stream
    // to a state where we can start writing trace events to it.
    // Repeatedly constructing and destroying json_trace_writer_ allows
    // us to use V8's JSON writer instead of implementing our own.
    json_trace_writer_.reset(TraceWriter::CreateJSONTraceWriter(stream_));
  }",27,,102,2,,void
291766,BLOCK,-1,,"{
  std::string str;
  int highest_request_id;
  {
    Mutex::ScopedLock stream_scoped_lock(stream_mutex_);
    if (total_traces_ >= kTracesPerFile) {
      total_traces_ = 0;
      // Destroying the member JSONTraceWriter object appends ""]}"" to
      // stream_ - in other words, ending a JSON file.
      json_trace_writer_.reset();
    }
    // str() makes a copy of the contents of the stream.
    str = stream_.str();
    stream_.str("""");
    stream_.clear();
  }
  {
    Mutex::ScopedLock request_scoped_lock(request_mutex_);
    highest_request_id = num_write_requests_;
  }
  WriteToFile(std::move(str), highest_request_id);
}",38,,116,1,,void
291769,BLOCK,3,,"{
    Mutex::ScopedLock stream_scoped_lock(stream_mutex_);
    if (total_traces_ >= kTracesPerFile) {
      total_traces_ = 0;
      // Destroying the member JSONTraceWriter object appends ""]}"" to
      // stream_ - in other words, ending a JSON file.
      json_trace_writer_.reset();
    }
    // str() makes a copy of the contents of the stream.
    str = stream_.str();
    stream_.str("""");
    stream_.clear();
  }",3,,119,3,,void
291777,BLOCK,-1,,"{
      total_traces_ = 0;
      // Destroying the member JSONTraceWriter object appends ""]}"" to
      // stream_ - in other words, ending a JSON file.
      json_trace_writer_.reset();
    }",42,,121,2,,void
291800,BLOCK,4,,"{
    Mutex::ScopedLock request_scoped_lock(request_mutex_);
    highest_request_id = num_write_requests_;
  }",3,,132,4,,void
291818,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(request_mutex_);
  {
    // We need to lock the mutexes here in a nested fashion; stream_mutex_
    // protects json_trace_writer_, and without request_mutex_ there might be
    // a time window in which the stream state changes?
    Mutex::ScopedLock stream_mutex_lock(stream_mutex_);
    if (!json_trace_writer_)
      return;
  }
  int request_id = ++num_write_requests_;
  int err = uv_async_send(&flush_signal_);
  CHECK_EQ(err, 0);
  if (blocking) {
    // Wait until data associated with this request id has been written to disk.
    // This guarantees that data from all earlier requests have also been
    // written.
    while (request_id > highest_request_id_completed_) {
      request_cond_.Wait(scoped_lock);
    }
  }
}",44,,139,2,,void
291822,BLOCK,3,,"{
    // We need to lock the mutexes here in a nested fashion; stream_mutex_
    // protects json_trace_writer_, and without request_mutex_ there might be
    // a time window in which the stream state changes?
    Mutex::ScopedLock stream_mutex_lock(stream_mutex_);
    if (!json_trace_writer_)
      return;
  }",3,,141,3,,void
291829,BLOCK,-1,,<empty>,7,,147,2,,void
291847,BLOCK,-1,,"{
    // Wait until data associated with this request id has been written to disk.
    // This guarantees that data from all earlier requests have also been
    // written.
    while (request_id > highest_request_id_completed_) {
      request_cond_.Wait(scoped_lock);
    }
  }",17,,152,2,,void
291852,BLOCK,-1,,"{
      request_cond_.Wait(scoped_lock);
    }",56,,156,2,,void
291863,BLOCK,-1,,"{
  if (fd_ == -1) return;

  uv_buf_t buf = uv_buf_init(nullptr, 0);
  {
    Mutex::ScopedLock lock(request_mutex_);
    write_req_queue_.emplace(WriteRequest {
      std::move(str), highest_request_id
    });
    if (write_req_queue_.size() == 1) {
      buf = uv_buf_init(
          const_cast<char*>(write_req_queue_.front().str.c_str()),
          write_req_queue_.front().str.length());
    }
  }
  // Only one write request for the same file descriptor should be active at
  // a time.
  if (buf.base != nullptr && fd_ != -1) {
    StartWrite(buf);
  }
}",78,,162,3,,void
291869,BLOCK,-1,,<empty>,18,,163,2,,void
291877,BLOCK,4,,"{
    Mutex::ScopedLock lock(request_mutex_);
    write_req_queue_.emplace(WriteRequest {
      std::move(str), highest_request_id
    });
    if (write_req_queue_.size() == 1) {
      buf = uv_buf_init(
          const_cast<char*>(write_req_queue_.front().str.c_str()),
          write_req_queue_.front().str.length());
    }
  }",3,,166,4,,void
291900,BLOCK,-1,,"{
      buf = uv_buf_init(
          const_cast<char*>(write_req_queue_.front().str.c_str()),
          write_req_queue_.front().str.length());
    }",39,,171,2,,void
291935,BLOCK,-1,,"{
    StartWrite(buf);
  }",41,,179,2,,void
291942,BLOCK,-1,,"{
  int err = uv_fs_write(
      tracing_loop_, &write_req_, fd_, &buf, 1, -1,
      [](uv_fs_t* req) {
        NodeTraceWriter* writer =
            ContainerOf(&NodeTraceWriter::write_req_, req);
        writer->AfterWrite();
      });
  CHECK_EQ(err, 0);
}",48,,184,2,,void
291963,BLOCK,-1,,"{
  CHECK_GE(write_req_.result, 0);
  uv_fs_req_cleanup(&write_req_);

  uv_buf_t buf = uv_buf_init(nullptr, 0);
  {
    Mutex::ScopedLock scoped_lock(request_mutex_);
    int highest_request_id = write_req_queue_.front().highest_request_id;
    write_req_queue_.pop();
    highest_request_id_completed_ = highest_request_id;
    request_cond_.Broadcast(scoped_lock);
    if (!write_req_queue_.empty()) {
      buf = uv_buf_init(
          const_cast<char*>(write_req_queue_.front().str.c_str()),
          write_req_queue_.front().str.length());
    }
  }
  if (buf.base != nullptr && fd_ != -1) {
    StartWrite(buf);
  }
}",36,,195,1,,void
291978,BLOCK,5,,"{
    Mutex::ScopedLock scoped_lock(request_mutex_);
    int highest_request_id = write_req_queue_.front().highest_request_id;
    write_req_queue_.pop();
    highest_request_id_completed_ = highest_request_id;
    request_cond_.Broadcast(scoped_lock);
    if (!write_req_queue_.empty()) {
      buf = uv_buf_init(
          const_cast<char*>(write_req_queue_.front().str.c_str()),
          write_req_queue_.front().str.length());
    }
  }",3,,200,5,,void
292009,BLOCK,-1,,"{
      buf = uv_buf_init(
          const_cast<char*>(write_req_queue_.front().str.c_str()),
          write_req_queue_.front().str.length());
    }",36,,206,2,,void
292044,BLOCK,-1,,"{
    StartWrite(buf);
  }",41,,212,2,,void
292050,BLOCK,-1,,"{
  NodeTraceWriter* trace_writer =
      ContainerOf(&NodeTraceWriter::exit_signal_, signal);
  // Close both flush_signal_ and exit_signal_.
  uv_close(reinterpret_cast<uv_handle_t*>(&trace_writer->flush_signal_),
           [](uv_handle_t* signal) {
             NodeTraceWriter* trace_writer =
                 ContainerOf(&NodeTraceWriter::flush_signal_,
                             reinterpret_cast<uv_async_t*>(signal));
             uv_close(
                 reinterpret_cast<uv_handle_t*>(&trace_writer->exit_signal_),
                 [](uv_handle_t* signal) {
                   NodeTraceWriter* trace_writer =
                       ContainerOf(&NodeTraceWriter::exit_signal_,
                                   reinterpret_cast<uv_async_t*>(signal));
                   Mutex::ScopedLock scoped_lock(trace_writer->request_mutex_);
                   trace_writer->exited_ = true;
                   trace_writer->exit_cond_.Signal(scoped_lock);
                 });
           });
}",56,,218,2,,void
292084,BLOCK,-1,,<empty>,1,,1,1,,ANY
292090,BLOCK,-1,,<empty>,,,,2,,<empty>
292094,BLOCK,-1,,<empty>,,,,1,,<empty>
292099,BLOCK,-1,,<empty>,,,,2,,<empty>
292104,BLOCK,-1,,<empty>,,,,2,,<empty>
292109,BLOCK,-1,,<empty>,,,,2,,<empty>
292117,BLOCK,-1,,<empty>,,,,1,,<empty>
292122,BLOCK,-1,,<empty>,,,,2,,<empty>
292126,BLOCK,-1,,<empty>,,,,1,,<empty>
292132,BLOCK,-1,,<empty>,,,,3,,<empty>
292136,BLOCK,-1,,<empty>,,,,1,,<empty>
292140,BLOCK,-1,,<empty>,,,,1,,<empty>
292145,BLOCK,-1,,<empty>,,,,2,,<empty>
292167,BLOCK,-1,,<empty>,,,,1,,<empty>
292205,BLOCK,-1,,<empty>,1,,1,1,,ANY
292218,BLOCK,-1,,"{
  if (agent) {
    g_agent = agent;
    g_controller = agent->GetTracingController();
  } else {
    g_agent = nullptr;
    g_controller = nullptr;
  }
}",47,,10,2,,void
292221,BLOCK,-1,,"{
    g_agent = agent;
    g_controller = agent->GetTracingController();
  }",14,,11,2,,void
292232,BLOCK,-1,,"{
    g_agent = nullptr;
    g_controller = nullptr;
  }",10,,14,1,,void
292242,BLOCK,-1,,"{
  return g_agent;
}",37,,20,1,,void
292248,BLOCK,-1,,"{
  return g_controller;
}",65,,24,1,,void
292255,BLOCK,-1,,"{
  g_controller = controller;
}",80,,28,2,,void
292262,BLOCK,-1,,"{
  return tracing::TraceEventHelper::GetTracingController();
}",47,,34,1,,void
292274,BLOCK,-1,,"{
  tracing::TraceEventHelper::SetTracingController(controller);
}",62,,38,2,,void
292296,BLOCK,-1,,<empty>,1,,1,1,,ANY
292302,BLOCK,-1,,<empty>,,,,1,,<empty>
292336,BLOCK,-1,,<empty>,,,,1,,<empty>
292341,BLOCK,-1,,<empty>,,,,2,,<empty>
292345,BLOCK,-1,,<empty>,,,,1,,<empty>
292350,BLOCK,-1,,<empty>,,,,2,,<empty>
292355,BLOCK,-1,,"{
    v8::TracingController* controller = GetTracingController();
    static const uint8_t disabled = 0;
    if (UNLIKELY(controller == nullptr)) return &disabled;
    return controller->GetCategoryGroupEnabled(group);
  }",75,,321,2,,void
292369,BLOCK,-1,,<empty>,42,,324,2,,void
292386,BLOCK,-1,,<empty>,42,,337,3,,void
292390,BLOCK,-1,,{ return raw_id_; },29,,338,1,,void
292396,BLOCK,-1,,{ return scope_; },31,,339,1,,void
292404,BLOCK,-1,,<empty>,,,,1,,<empty>
292413,BLOCK,-1,,<empty>,79,,349,2,,void
292418,BLOCK,-1,,<empty>,60,,350,2,,void
292423,BLOCK,-1,,<empty>,64,,351,2,,void
292428,BLOCK,-1,,<empty>,60,,352,2,,void
292433,BLOCK,-1,,<empty>,65,,353,2,,void
292438,BLOCK,-1,,<empty>,50,,355,2,,void
292443,BLOCK,-1,,<empty>,78,,356,2,,void
292448,BLOCK,-1,,<empty>,50,,358,2,,void
292453,BLOCK,-1,,<empty>,50,,360,2,,void
292458,BLOCK,-1,,<empty>,66,,362,2,,void
292462,BLOCK,-1,,{ return scope_; },31,,363,1,,void
292468,BLOCK,-1,,{ return raw_id_; },29,,364,1,,void
292476,BLOCK,-1,,<empty>,,,,1,,<empty>
292485,BLOCK,-1,,<empty>,61,,373,2,,void
292490,BLOCK,-1,,<empty>,65,,374,2,,void
292495,BLOCK,-1,,<empty>,61,,375,2,,void
292500,BLOCK,-1,,<empty>,66,,376,2,,void
292505,BLOCK,-1,,<empty>,50,,378,2,,void
292510,BLOCK,-1,,<empty>,79,,379,2,,void
292515,BLOCK,-1,,<empty>,50,,381,2,,void
292520,BLOCK,-1,,<empty>,50,,383,2,,void
292524,BLOCK,-1,,{ return raw_id_; },29,,384,1,,void
292533,BLOCK,-1,,"{
    *flags |= TRACE_EVENT_FLAG_MANGLE_ID;
  }",77,,391,3,,void
292538,BLOCK,1,,<empty>,,,,1,,void
292549,BLOCK,-1,,"{
    *flags |= TRACE_EVENT_FLAG_MANGLE_ID;
  }",79,,394,3,,void
292554,BLOCK,1,,<empty>,,,,1,,void
292565,BLOCK,-1,,<empty>,76,,398,3,,void
292571,BLOCK,-1,,"{
    (void)flags;
  }",67,,399,3,,void
292580,BLOCK,-1,,"{
    (void)flags;
  }",71,,402,3,,void
292589,BLOCK,-1,,"{
    (void)flags;
  }",67,,405,3,,void
292598,BLOCK,-1,,"{
    (void)flags;
  }",72,,408,3,,void
292607,BLOCK,-1,,"{
    (void)flags;
  }",48,,412,3,,void
292616,BLOCK,-1,,"{
    (void)flags;
  }",48,,416,3,,void
292625,BLOCK,-1,,"{
    (void)flags;
  }",48,,420,3,,void
292634,BLOCK,-1,,"{
    (void)flags;
  }",48,,424,3,,void
292643,BLOCK,-1,,<empty>,64,,428,3,,void
292647,BLOCK,-1,,{ return raw_id_; },27,,430,1,,void
292653,BLOCK,-1,,{ return scope_; },29,,431,1,,void
292661,BLOCK,-1,,<empty>,,,,1,,<empty>
292677,BLOCK,-1,,<empty>,61,,451,2,,void
292681,BLOCK,-1,,{ return str_; },32,,452,1,,void
292699,BLOCK,-1,,"{
  std::unique_ptr<v8::ConvertableToTraceFormat> arg_convertibles[2];
  if (num_args > 0 && arg_types[0] == TRACE_VALUE_TYPE_CONVERTABLE) {
    arg_convertibles[0].reset(reinterpret_cast<v8::ConvertableToTraceFormat*>(
        static_cast<intptr_t>(arg_values[0])));
  }
  if (num_args > 1 && arg_types[1] == TRACE_VALUE_TYPE_CONVERTABLE) {
    arg_convertibles[1].reset(reinterpret_cast<v8::ConvertableToTraceFormat*>(
        static_cast<intptr_t>(arg_values[1])));
  }
  // DCHECK(num_args, 2);
  v8::TracingController* controller =
      node::tracing::TraceEventHelper::GetTracingController();
  if (controller == nullptr) return 0;
  return controller->AddTraceEvent(phase, category_group_enabled, name, scope, id,
                                   bind_id, num_args, arg_names, arg_types,
                                   arg_values, arg_convertibles, flags);
}",53,,462,12,,void
292711,BLOCK,1,,<empty>,,,,1,,void
292715,BLOCK,-1,,"{
    arg_convertibles[0].reset(reinterpret_cast<v8::ConvertableToTraceFormat*>(
        static_cast<intptr_t>(arg_values[0])));
  }",69,,464,2,,void
292739,BLOCK,1,,<empty>,,,,1,,void
292743,BLOCK,-1,,"{
    arg_convertibles[1].reset(reinterpret_cast<v8::ConvertableToTraceFormat*>(
        static_cast<intptr_t>(arg_values[1])));
  }",69,,468,2,,void
292772,BLOCK,-1,,<empty>,30,,475,2,,void
292800,BLOCK,-1,,"INTERNAL_DECLARE_SET_TRACE_VALUE_INT(uint64_t, TRACE_VALUE_TYPE_UINT)",1,,545,4,,void
292819,BLOCK,-1,,"INTERNAL_DECLARE_SET_TRACE_VALUE_INT(unsigned int, TRACE_VALUE_TYPE_UINT)",1,,546,4,,void
292838,BLOCK,-1,,"INTERNAL_DECLARE_SET_TRACE_VALUE_INT(uint16_t, TRACE_VALUE_TYPE_UINT)",1,,547,4,,void
292857,BLOCK,-1,,"INTERNAL_DECLARE_SET_TRACE_VALUE_INT(unsigned char, TRACE_VALUE_TYPE_UINT)",1,,548,4,,void
292876,BLOCK,-1,,"INTERNAL_DECLARE_SET_TRACE_VALUE_INT(int64_t, TRACE_VALUE_TYPE_INT)",1,,549,4,,void
292895,BLOCK,-1,,"INTERNAL_DECLARE_SET_TRACE_VALUE_INT(int, TRACE_VALUE_TYPE_INT)",1,,550,4,,void
292914,BLOCK,-1,,"INTERNAL_DECLARE_SET_TRACE_VALUE_INT(int16_t, TRACE_VALUE_TYPE_INT)",1,,551,4,,void
292933,BLOCK,-1,,"INTERNAL_DECLARE_SET_TRACE_VALUE_INT(signed char, TRACE_VALUE_TYPE_INT)",1,,552,4,,void
292952,BLOCK,-1,,"INTERNAL_DECLARE_SET_TRACE_VALUE(bool, as_bool, TRACE_VALUE_TYPE_BOOL)",1,,553,4,,void
292977,BLOCK,-1,,"INTERNAL_DECLARE_SET_TRACE_VALUE(double, as_double, TRACE_VALUE_TYPE_DOUBLE)",1,,554,4,,void
293002,BLOCK,-1,,"INTERNAL_DECLARE_SET_TRACE_VALUE(const void*, as_pointer,
                                 TRACE_VALUE_TYPE_POINTER)",1,,555,4,,void
293027,BLOCK,-1,,"INTERNAL_DECLARE_SET_TRACE_VALUE(const char*, as_string,
                                 TRACE_VALUE_TYPE_STRING)",1,,557,4,,void
293052,BLOCK,-1,,"INTERNAL_DECLARE_SET_TRACE_VALUE(const TraceStringWithCopy&, as_string,
                                 TRACE_VALUE_TYPE_COPY_STRING)",1,,559,4,,void
293077,BLOCK,-1,,"{
  *type = TRACE_VALUE_TYPE_CONVERTABLE;
  *value = static_cast<uint64_t>(reinterpret_cast<intptr_t>(convertable_value));
}",75,,566,4,,void
293082,BLOCK,1,,<empty>,,,,1,,void
293100,BLOCK,-1,,"{
  SetTraceValue(ptr.release(), type, value);
}",77,,574,4,,void
293118,BLOCK,-1,,"{
  return TRACE_EVENT_API_ADD_TRACE_EVENT(phase, category_group_enabled, name,
                                         scope, id, bind_id, kZeroNumArgs,
                                         nullptr, nullptr, nullptr, flags);
}",61,,588,8,,void
293121,BLOCK,1,,<empty>,,,,2,,void
293151,BLOCK,-1,,"{
  const int num_args = 1;
  uint8_t arg_type;
  uint64_t arg_value;
  SetTraceValue(std::forward<ARG1_TYPE>(arg1_val), &arg_type, &arg_value);
  return TRACE_EVENT_API_ADD_TRACE_EVENT(
      phase, category_group_enabled, name, scope, id, bind_id, num_args,
      &arg1_name, &arg_type, &arg_value, flags);
}",50,,598,10,,void
293172,BLOCK,1,,<empty>,,,,4,,void
293207,BLOCK,-1,,"{
  const int num_args = 2;
  const char* arg_names[2] = {arg1_name, arg2_name};
  unsigned char arg_types[2];
  uint64_t arg_values[2];
  SetTraceValue(std::forward<ARG1_TYPE>(arg1_val), &arg_types[0],
                &arg_values[0]);
  SetTraceValue(std::forward<ARG2_TYPE>(arg2_val), &arg_types[1],
                &arg_values[1]);
  return TRACE_EVENT_API_ADD_TRACE_EVENT(
      phase, category_group_enabled, name, scope, id, bind_id, num_args,
      arg_names, arg_types, arg_values, flags);
}",27,,613,12,,void
293254,BLOCK,1,,<empty>,,,,5,,void
293280,BLOCK,-1,,<empty>,37,,686,1,,void
293284,BLOCK,-1,,"{
    if (p_data_ && *data_.category_group_enabled)
      TRACE_EVENT_API_UPDATE_TRACE_EVENT_DURATION(
          data_.category_group_enabled, data_.name, data_.event_handle);
  }",19,,688,1,,void
293292,BLOCK,-1,,<empty>,7,,690,2,,void
293294,BLOCK,1,,<empty>,,,,1,,void
293296,BLOCK,-1,,<empty>,7,,690,1,,void
293308,BLOCK,-1,,<empty>,7,,690,2,,void
293328,BLOCK,-1,,"{
    data_.category_group_enabled = category_group_enabled;
    data_.name = name;
    data_.event_handle = event_handle;
    p_data_ = &data_;
  }",42,,695,4,,void
293360,BLOCK,-1,,<empty>,1,,1,1,,ANY
293379,BLOCK,-1,,<empty>,1,,1,1,,ANY
293385,BLOCK,-1,,"{
  std::string result;
  result += '""';
  char number_buffer[10];
#if defined(NODE_HAVE_I18N_SUPPORT)
  int32_t len = strlen(value);
  int32_t p = 0;
  int32_t i = 0;
  for (; i < len; p = i) {
    UChar32 c;
    U8_NEXT_OR_FFFD(value, i, len, c);
    switch (c) {
      case '\b': result += ""\\b""; break;
      case '\f': result += ""\\f""; break;
      case '\n': result += ""\\n""; break;
      case '\r': result += ""\\r""; break;
      case '\t': result += ""\\t""; break;
      case '\\': result += ""\\\\""; break;
      case '""': result += ""\\\""""; break;
      default:
        if (c < 32 || c > 126) {
          snprintf(
              number_buffer, arraysize(number_buffer), ""\\u%04X"",
              static_cast<uint16_t>(static_cast<uint16_t>(c)));
          result += number_buffer;
        } else {
          result.append(value + p, i - p);
        }
    }
  }
#else
  // If we do not have ICU, use a modified version of the non-UTF8 aware
  // code from V8's own TracedValue implementation....",45,,29,2,,void
293394,BLOCK,-1,,"{
    char c = *value++;
    switch (c) {
      case '\b': result += ""\\b""; break;
      case '\f': result += ""\\f""; break;
      case '\n': result += ""\\n""; break;
      case '\r': result += ""\\r""; break;
      case '\t': result += ""\\t""; break;
      case '\\': result += ""\\\\""; break;
      case '""': result += ""\\\""""; break;
      default:
        if (c < '\x20') {
          snprintf(
              number_buffer, arraysize(number_buffer), ""\\u%04X"",
              static_cast<unsigned>(static_cast<unsigned char>(c)));
          result += number_buffer;
        } else {
          result += c;
        }
    }
  }",18,,63,2,,void
293403,BLOCK,-1,,"{
      case '\b': result += ""\\b""; break;
      case '\f': result += ""\\f""; break;
      case '\n': result += ""\\n""; break;
      case '\r': result += ""\\r""; break;
      case '\t': result += ""\\t""; break;
      case '\\': result += ""\\\\""; break;
      case '""': result += ""\\\""""; break;
      default:
        if (c < '\x20') {
          snprintf(
              number_buffer, arraysize(number_buffer), ""\\u%04X"",
              static_cast<unsigned>(static_cast<unsigned char>(c)));
          result += number_buffer;
        } else {
          result += c;
        }
    }",16,,65,2,,void
293451,BLOCK,-1,,"{
          snprintf(
              number_buffer, arraysize(number_buffer), ""\\u%04X"",
              static_cast<unsigned>(static_cast<unsigned char>(c)));
          result += number_buffer;
        }",25,,74,2,,void
293466,BLOCK,-1,,"{
          result += c;
        }",16,,79,1,,void
293479,BLOCK,-1,,"{
  switch (FPCLASSIFY_NAMESPACE::fpclassify(v)) {
    case FP_NAN: return ""\""NaN\"""";
    case FP_INFINITE: return (v < 0.0 ? ""\""-Infinity\"""" : ""\""Infinity\"""");
    case FP_ZERO: return ""0"";
    default:
      // This is a far less sophisticated version than the one used inside v8.
      std::ostringstream stream;
      stream.imbue(std::locale::classic());  // Ignore current locale
      stream << v;
      return stream.str();
  }
}",39,,89,2,,void
293482,BLOCK,1,,<empty>,,,,1,,void
293488,BLOCK,-1,,"{
    case FP_NAN: return ""\""NaN\"""";
    case FP_INFINITE: return (v < 0.0 ? ""\""-Infinity\"""" : ""\""Infinity\"""");
    case FP_ZERO: return ""0"";
    default:
      // This is a far less sophisticated version than the one used inside v8.
      std::ostringstream stream;
      stream.imbue(std::locale::classic());  // Ignore current locale
      stream << v;
      return stream.str();
  }",48,,90,2,,void
293529,BLOCK,-1,,"{
  return std::unique_ptr<TracedValue>(new TracedValue(false));
}",52,,105,1,,void
293543,BLOCK,-1,,"{
  return std::unique_ptr<TracedValue>(new TracedValue(true));
}",57,,109,1,,void
293558,BLOCK,-1,,<empty>,54,,114,2,,void
293564,BLOCK,-1,,"{
  WriteName(name);
  data_ += std::to_string(value);
}",59,,116,3,,void
293579,BLOCK,-1,,"{
  WriteName(name);
  data_ += DoubleToCString(value);
}",61,,121,3,,void
293591,BLOCK,-1,,"{
  WriteName(name);
  data_ += value ? ""true"" : ""false"";
}",60,,126,3,,void
293604,BLOCK,-1,,"{
  WriteName(name);
  data_ += ""null"";
}",45,,131,2,,void
293615,BLOCK,-1,,"{
  WriteName(name);
  data_ += EscapeString(value);
}",66,,136,3,,void
293626,BLOCK,-1,,"{
  WriteName(name);
  data_ += '{';
  first_item_ = true;
}",53,,141,2,,void
293639,BLOCK,-1,,"{
  WriteName(name);
  data_ += '[';
  first_item_ = true;
}",48,,147,2,,void
293652,BLOCK,-1,,"{
  WriteComma();
  data_ += std::to_string(value);
}",44,,153,2,,void
293665,BLOCK,-1,,"{
  WriteComma();
  data_ += DoubleToCString(value);
}",46,,158,2,,void
293675,BLOCK,-1,,"{
  WriteComma();
  data_ += value ? ""true"" : ""false"";
}",45,,163,2,,void
293686,BLOCK,-1,,"{
  WriteComma();
  data_ += ""null"";
}",32,,168,1,,void
293695,BLOCK,-1,,"{
  WriteComma();
  data_ += EscapeString(value);
}",51,,173,2,,void
293704,BLOCK,-1,,"{
  WriteComma();
  data_ += '{';
  first_item_ = true;
}",37,,178,1,,void
293715,BLOCK,-1,,"{
  WriteComma();
  data_ += '[';
  first_item_ = true;
}",32,,184,1,,void
293726,BLOCK,-1,,"{
  data_ += '}';
  first_item_ = false;
}",35,,190,1,,void
293736,BLOCK,-1,,"{
  data_ += ']';
  first_item_ = false;
}",30,,195,1,,void
293746,BLOCK,-1,,"{
  if (first_item_) {
    first_item_ = false;
  } else {
    data_ += ',';
  }
}",32,,200,1,,void
293749,BLOCK,-1,,"{
    first_item_ = false;
  }",20,,201,2,,void
293754,BLOCK,-1,,"{
    data_ += ',';
  }",10,,203,1,,void
293762,BLOCK,-1,,"{
  WriteComma();
  data_ += '""';
  data_ += name;
  data_ += ""\"":"";
}",47,,208,2,,void
293777,BLOCK,-1,,"{
  *out += root_is_array_ ? '[' : '{';
  *out += data_;
  *out += root_is_array_ ? ']' : '}';
}",63,,215,2,,void
293814,BLOCK,-1,,<empty>,1,,1,1,,ANY
293819,BLOCK,-1,,<empty>,,,,1,,<empty>
293823,BLOCK,-1,,<empty>,,,,1,,<empty>
293827,BLOCK,-1,,<empty>,,,,1,,<empty>
293831,BLOCK,-1,,<empty>,,,,1,,<empty>
293835,BLOCK,-1,,<empty>,,,,1,,<empty>
293841,BLOCK,-1,,<empty>,,,,3,,<empty>
293847,BLOCK,-1,,<empty>,,,,3,,<empty>
293853,BLOCK,-1,,<empty>,,,,3,,<empty>
293858,BLOCK,-1,,<empty>,,,,2,,<empty>
293864,BLOCK,-1,,<empty>,,,,3,,<empty>
293870,BLOCK,-1,,"{
    SetString(name, value.c_str());
  }",62,,35,3,,void
293881,BLOCK,-1,,<empty>,,,,2,,<empty>
293886,BLOCK,-1,,<empty>,,,,2,,<empty>
293891,BLOCK,-1,,<empty>,,,,2,,<empty>
293896,BLOCK,-1,,<empty>,,,,2,,<empty>
293901,BLOCK,-1,,<empty>,,,,2,,<empty>
293905,BLOCK,-1,,<empty>,,,,1,,<empty>
293910,BLOCK,-1,,<empty>,,,,2,,<empty>
293915,BLOCK,-1,,{ AppendString(value.c_str()); },47,,46,2,,void
293924,BLOCK,-1,,<empty>,,,,1,,<empty>
293928,BLOCK,-1,,<empty>,,,,1,,<empty>
293933,BLOCK,-1,,<empty>,,,,2,,<empty>
293938,BLOCK,-1,,<empty>,,,,2,,<empty>
293943,BLOCK,-1,,<empty>,,,,2,,<empty>
293948,BLOCK,-1,,<empty>,,,,2,,<empty>
293952,BLOCK,-1,,<empty>,,,,1,,<empty>
293957,BLOCK,-1,,<empty>,,,,2,,<empty>
293983,BLOCK,-1,,<empty>,1,,1,1,,ANY
293987,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(GetWindowSize);
  registry->Register(SetRawMode);
  registry->Register(IsTTY);
}",79,,45,2,,void
294015,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<String> ttyString = FIXED_ONE_BYTE_STRING(env->isolate(), ""TTY"");

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->SetClassName(ttyString);
  t->InstanceTemplate()->SetInternalFieldCount(StreamBase::kInternalFieldCount);
  t->Inherit(LibuvStreamWrap::GetConstructorTemplate(env));

  SetProtoMethodNoSideEffect(
      isolate, t, ""getWindowSize"", TTYWrap::GetWindowSize);
  SetProtoMethod(isolate, t, ""setRawMode"", SetRawMode);

  SetMethodNoSideEffect(context, target, ""isTTY"", IsTTY);

  Local<Value> func;
  if (t->GetFunction(context).ToLocal(&func) &&
      target->Set(context, ttyString, func).IsJust()) {
    env->set_tty_constructor_template(t);
  }
}",38,,55,5,,void
294120,BLOCK,-1,,"{
    env->set_tty_constructor_template(t);
  }",55,,74,2,,void
294130,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  int fd;
  if (!args[0]->Int32Value(env->context()).To(&fd)) return;
  CHECK_GE(fd, 0);
  bool rc = uv_guess_handle(fd) == UV_TTY;
  args.GetReturnValue().Set(rc);
}",62,,80,2,,void
294157,BLOCK,-1,,<empty>,53,,83,2,,void
294181,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  TTYWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  CHECK(args[0]->IsArray());

  int width, height;
  int err = uv_tty_get_winsize(&wrap->handle_, &width, &height);

  if (err == 0) {
    Local<Array> a = args[0].As<Array>();
    a->Set(env->context(), 0, Integer::New(env->isolate(), width)).Check();
    a->Set(env->context(), 1, Integer::New(env->isolate(), height)).Check();
  }

  args.GetReturnValue().Set(err);
}",70,,90,2,,void
294231,BLOCK,-1,,"{
    Local<Array> a = args[0].As<Array>();
    a->Set(env->context(), 0, Integer::New(env->isolate(), width)).Check();
    a->Set(env->context(), 1, Integer::New(env->isolate(), height)).Check();
  }",17,,102,2,,void
294298,BLOCK,-1,,"{
  TTYWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  int err = uv_tty_set_mode(&wrap->handle_, args[0]->IsTrue());
  args.GetReturnValue().Set(err);
}",67,,112,2,,void
294341,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  // This constructor should not be exposed to public javascript.
  // Therefore we assert that we are not trying to call this as a
  // normal function.
  CHECK(args.IsConstructCall());

  int fd;
  if (!args[0]->Int32Value(env->context()).To(&fd)) return;
  CHECK_GE(fd, 0);

  int err = 0;
  new TTYWrap(env, args.This(), fd, &err);
  if (err != 0) {
    env->CollectUVExceptionInfo(args[1], err, ""uv_tty_init"");
    args.GetReturnValue().SetUndefined();
  }
}",60,,122,2,,void
294373,BLOCK,-1,,<empty>,53,,131,2,,void
294396,BLOCK,-1,,"{
    env->CollectUVExceptionInfo(args[1], err, ""uv_tty_init"");
    args.GetReturnValue().SetUndefined();
  }",17,,136,2,,void
294420,BLOCK,-1,,"{
  *init_err = uv_tty_init(env->event_loop(), &handle_, fd, 0);
  set_fd(fd);
  if (*init_err != 0)
    MarkAsUninitialized();
}",52,,150,5,,void
294440,BLOCK,-1,,<empty>,5,,154,2,,void
294453,BLOCK,-1,,<empty>,1,,1,1,,ANY
294458,BLOCK,-1,,"{
          UDPWrap* self = ContainerOf(&UDPWrap::handle_, req->handle);
          self->listener()->OnSendDone(
              ReqWrap<uv_udp_send_t>::from_req(req), status);
        }",59,,601,3,,void
294509,BLOCK,-1,,<empty>,1,,1,1,,ANY
294514,BLOCK,-1,,"{
  UDPWrap* wrap = Unwrap<UDPWrap>(args.Holder());
  if (wrap == nullptr) {
    args.GetReturnValue().Set(UV_EBADF);
    return;
  }
  Environment* env = wrap->env();
  CHECK_EQ(args.Length(), 1);
  int flag;
  if (!args[0]->Int32Value(env->context()).To(&flag)) {
    return;
  }
  int err = fn(wrap->GetLibuvHandle(), flag);
  args.GetReturnValue().Set(err);
}",61,,57,2,,void
294530,BLOCK,-1,,"{
    args.GetReturnValue().Set(UV_EBADF);
    return;
  }",24,,59,2,,void
294571,BLOCK,-1,,"{
    return;
  }",55,,66,2,,void
294597,BLOCK,-1,,<empty>,,,,4,,<empty>
294601,BLOCK,-1,,<empty>,,,,1,,<empty>
294610,BLOCK,-1,,"{
}",37,,93,4,,void
294614,BLOCK,-1,,"{
  return have_callback_;
}",38,,97,1,,void
294620,BLOCK,-1,,"{
  if (wrap_ != nullptr)
    wrap_->set_listener(nullptr);
}",29,,101,1,,void
294625,BLOCK,-1,,<empty>,5,,103,2,,void
294634,BLOCK,-1,,"{
  set_listener(nullptr);
}",29,,106,1,,void
294640,BLOCK,-1,,"{
  CHECK_NOT_NULL(listener_);
  return listener_;
}",44,,110,1,,void
294648,BLOCK,-1,,"{
  if (listener_ != nullptr)
    listener_->wrap_ = nullptr;
  listener_ = listener;
  if (listener_ != nullptr) {
    CHECK_NULL(listener_->wrap_);
    listener_->wrap_ = this;
  }
}",55,,115,2,,void
294653,BLOCK,-1,,<empty>,5,,117,2,,void
294666,BLOCK,-1,,"{
    CHECK_NULL(listener_->wrap_);
    listener_->wrap_ = this;
  }",29,,119,2,,void
294680,BLOCK,-1,,"{
  CHECK_GT(obj->InternalFieldCount(), UDPWrapBase::kUDPWrapBaseField);
  return static_cast<UDPWrapBase*>(
      obj->GetAlignedPointerFromInternalField(UDPWrapBase::kUDPWrapBaseField));
}",57,,125,2,,void
294704,BLOCK,-1,,"{
  SetProtoMethod(env->isolate(), t, ""recvStart"", RecvStart);
  SetProtoMethod(env->isolate(), t, ""recvStop"", RecvStop);
}",75,,131,3,,void
294726,BLOCK,-1,,"{
  object->SetAlignedPointerInInternalField(
      UDPWrapBase::kUDPWrapBaseField, static_cast<UDPWrapBase*>(this));

  int r = uv_udp_init(env->event_loop(), &handle_);
  CHECK_EQ(r, 0);  // can't fail anyway

  set_listener(this);
}",47,,140,3,,void
294759,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->InstanceTemplate()->SetInternalFieldCount(
      UDPWrapBase::kInternalFieldCount);

  enum PropertyAttribute attributes =
      static_cast<PropertyAttribute>(ReadOnly | DontDelete);

  Local<Signature> signature = Signature::New(isolate, t);

  Local<FunctionTemplate> get_fd_templ =
      FunctionTemplate::New(isolate, UDPWrap::GetFD, Local<Value>(), signature);

  t->PrototypeTemplate()->SetAccessorProperty(env->fd_string(),
                                              get_fd_templ,
                                              Local<FunctionTemplate>(),
                                              attributes);

  UDPWrapBase::AddMethods(env, t);
  SetProtoMethod(isolate, t, ""open"", Open);
  SetProtoMethod(isolate, t, ""bind"", Bind);
  SetProtoMethod(isolate, t, ""connect"", Connect);
  SetProtoMethod(isolate, t, ""send...",38,,154,5,,void
295027,BLOCK,1,,<empty>,,,,7,,void
295029,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, UV_UDP_IPV6ONLY)",3,,225,1,,void
295126,BLOCK,1,,<empty>,,,,7,,void
295128,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, UV_UDP_REUSEADDR)",3,,226,1,,void
295237,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new UDPWrap(env, args.This());
}",60,,233,2,,void
295262,BLOCK,-1,,"{
  int fd = UV_EBADF;
#if !defined(_WIN32)
  UDPWrap* wrap = Unwrap<UDPWrap>(args.This());
  if (wrap != nullptr)
    uv_fileno(reinterpret_cast<uv_handle_t*>(&wrap->handle_), &fd);
#endif
  args.GetReturnValue().Set(fd);
}",62,,240,2,,void
295282,BLOCK,-1,,<empty>,5,,245,2,,void
295307,BLOCK,-1,,"{
  switch (address_family) {
    case AF_INET:
      return uv_ip4_addr(address, port, reinterpret_cast<sockaddr_in*>(addr));
    case AF_INET6:
      return uv_ip6_addr(address, port, reinterpret_cast<sockaddr_in6*>(addr));
    default:
      UNREACHABLE(""unexpected address family"");
  }
}",56,,253,5,,void
295310,BLOCK,-1,,"{
    case AF_INET:
      return uv_ip4_addr(address, port, reinterpret_cast<sockaddr_in*>(addr));
    case AF_INET6:
      return uv_ip6_addr(address, port, reinterpret_cast<sockaddr_in6*>(addr));
    default:
      UNREACHABLE(""unexpected address family"");
  }",27,,254,2,,void
295337,BLOCK,-1,,"{
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  // bind(ip, port, flags)
  CHECK_EQ(args.Length(), 3);

  node::Utf8Value address(args.GetIsolate(), args[0]);
  Local<Context> ctx = args.GetIsolate()->GetCurrentContext();
  uint32_t port, flags;
  if (!args[1]->Uint32Value(ctx).To(&port) ||
      !args[2]->Uint32Value(ctx).To(&flags))
    return;
  struct sockaddr_storage addr_storage;
  int err = sockaddr_for_family(family, address.out(), port, &addr_storage);
  if (err == 0) {
    err = uv_udp_bind(&wrap->handle_,
                      reinterpret_cast<const sockaddr*>(&addr_storage),
                      flags);
  }

  if (err == 0)
    wrap->listener()->OnAfterBind();

  args.GetReturnValue().Set(err);
}",75,,264,3,,void
295412,BLOCK,-1,,<empty>,5,,278,2,,void
295431,BLOCK,-1,,"{
    err = uv_udp_bind(&wrap->handle_,
                      reinterpret_cast<const sockaddr*>(&addr_storage),
                      flags);
  }",17,,281,2,,void
295448,BLOCK,-1,,<empty>,5,,288,2,,void
295469,BLOCK,-1,,"{
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK_EQ(args.Length(), 2);

  node::Utf8Value address(args.GetIsolate(), args[0]);
  Local<Context> ctx = args.GetIsolate()->GetCurrentContext();
  uint32_t port;
  if (!args[1]->Uint32Value(ctx).To(&port))
    return;
  struct sockaddr_storage addr_storage;
  int err = sockaddr_for_family(family, address.out(), port, &addr_storage);
  if (err == 0) {
    err = uv_udp_connect(&wrap->handle_,
                         reinterpret_cast<const sockaddr*>(&addr_storage));
  }

  args.GetReturnValue().Set(err);
}",78,,294,3,,void
295529,BLOCK,-1,,<empty>,5,,306,2,,void
295548,BLOCK,-1,,"{
    err = uv_udp_connect(&wrap->handle_,
                         reinterpret_cast<const sockaddr*>(&addr_storage));
  }",17,,309,2,,void
295572,BLOCK,-1,,"{
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  CHECK(args[0]->IsNumber());
  int fd = static_cast<int>(args[0].As<Integer>()->Value());
  int err = uv_udp_open(&wrap->handle_, fd);

  args.GetReturnValue().Set(err);
}",61,,318,2,,void
295631,BLOCK,-1,,"{
  DoBind(args, AF_INET);
}",61,,331,2,,void
295639,BLOCK,-1,,"{
  DoBind(args, AF_INET6);
}",62,,336,2,,void
295647,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK(args[0]->IsUint32());
  CHECK(args[1]->IsBoolean());
  bool is_recv = args[1].As<Boolean>()->Value();
  const char* uv_func_name = is_recv ? ""uv_recv_buffer_size"" :
                                       ""uv_send_buffer_size"";

  if (!args[0]->IsInt32()) {
    env->CollectUVExceptionInfo(args[2], UV_EINVAL, uv_func_name);
    return args.GetReturnValue().SetUndefined();
  }

  uv_handle_t* handle = reinterpret_cast<uv_handle_t*>(&wrap->handle_);
  int size = static_cast<int>(args[0].As<Uint32>()->Value());
  int err;

  if (is_recv)
    err = uv_recv_buffer_size(handle, &size);
  else
    err = uv_send_buffer_size(handle, &size);

  if (err != 0) {
    env->CollectUVExceptionInfo(args[2], err, uv_func_name);
    return args.GetReturnValue().SetUndefined();
  }

  args....",67,,341,2,,void
295713,BLOCK,-1,,"{
    env->CollectUVExceptionInfo(args[2], UV_EINVAL, uv_func_name);
    return args.GetReturnValue().SetUndefined();
  }",28,,354,2,,void
295757,BLOCK,-1,,<empty>,5,,364,2,,void
295765,BLOCK,-1,,<empty>,5,,366,1,,void
295776,BLOCK,-1,,"{
    env->CollectUVExceptionInfo(args[2], err, uv_func_name);
    return args.GetReturnValue().SetUndefined();
  }",17,,368,2,,void
295806,BLOCK,-1,,"{
  DoConnect(args, AF_INET);
}",64,,377,2,,void
295814,BLOCK,-1,,"{
  DoConnect(args, AF_INET6);
}",65,,382,2,,void
295822,BLOCK,-1,,"{
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK_EQ(args.Length(), 0);

  int err = uv_udp_connect(&wrap->handle_, nullptr);

  args.GetReturnValue().Set(err);
}",67,,387,2,,void
295866,BLOCK,-1,,"{
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());

  Utf8Value iface(args.GetIsolate(), args[0]);

  const char* iface_cstr = *iface;

  int err = uv_udp_set_multicast_interface(&wrap->handle_, iface_cstr);
  args.GetReturnValue().Set(err);
}",78,,400,2,,void
295932,BLOCK,-1,,"{
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK_EQ(args.Length(), 2);

  node::Utf8Value address(args.GetIsolate(), args[0]);
  node::Utf8Value iface(args.GetIsolate(), args[1]);

  const char* iface_cstr = *iface;
  if (args[1]->IsUndefined() || args[1]->IsNull()) {
      iface_cstr = nullptr;
  }

  int err = uv_udp_set_membership(&wrap->handle_,
                                  *address,
                                  iface_cstr,
                                  membership);
  args.GetReturnValue().Set(err);
}",55,,418,3,,void
295992,BLOCK,-1,,"{
      iface_cstr = nullptr;
  }",52,,430,2,,void
296020,BLOCK,-1,,"{
  SetMembership(args, UV_JOIN_GROUP);
}",70,,442,2,,void
296028,BLOCK,-1,,"{
  SetMembership(args, UV_LEAVE_GROUP);
}",71,,447,2,,void
296037,BLOCK,-1,,"{
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK_EQ(args.Length(), 3);

  node::Utf8Value source_address(args.GetIsolate(), args[0]);
  node::Utf8Value group_address(args.GetIsolate(), args[1]);
  node::Utf8Value iface(args.GetIsolate(), args[2]);

  if (*iface == nullptr) return;
  const char* iface_cstr = *iface;
  if (args[2]->IsUndefined() || args[2]->IsNull()) {
    iface_cstr = nullptr;
  }

  int err = uv_udp_set_source_membership(&wrap->handle_,
                                         *group_address,
                                         iface_cstr,
                                         *source_address,
                                         membership);
  args.GetReturnValue().Set(err);
}",61,,452,3,,void
296092,BLOCK,-1,,<empty>,26,,464,2,,void
296113,BLOCK,-1,,"{
    iface_cstr = nullptr;
  }",52,,466,2,,void
296143,BLOCK,-1,,"{
  SetSourceMembership(args, UV_JOIN_GROUP);
}",44,,479,2,,void
296151,BLOCK,-1,,"{
  SetSourceMembership(args, UV_LEAVE_GROUP);
}",44,,485,2,,void
296160,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK(args.Length() == 4 || args.Length() == 6);
  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsArray());
  CHECK(args[2]->IsUint32());

  bool sendto = args.Length() == 6;
  if (sendto) {
    // send(req, list, list.length, port, address, hasCallback)
    CHECK(args[3]->IsUint32());
    CHECK(args[4]->IsString());
    CHECK(args[5]->IsBoolean());
  } else {
    // send(req, list, list.length, hasCallback)
    CHECK(args[3]->IsBoolean());
  }

  Local<Array> chunks = args[1].As<Array>();
  // it is faster to fetch the length of the
  // array in js-land
  size_t count = args[2].As<Uint32>()->Value();

  MaybeStackBuffer<uv_buf_t, 16> bufs(count);

  // construct uv_buf_t array
  for (size_t i = 0; i < count; i++) {
    Local<Value> chunk;
    if (!chunks->Get(env->context...",75,,490,3,,void
296231,BLOCK,-1,,"{
    // send(req, list, list.length, port, address, hasCallback)
    CHECK(args[3]->IsUint32());
    CHECK(args[4]->IsString());
    CHECK(args[5]->IsBoolean());
  }",15,,504,2,,void
296254,BLOCK,-1,,"{
    // send(req, list, list.length, hasCallback)
    CHECK(args[3]->IsBoolean());
  }",10,,509,1,,void
296295,BLOCK,-1,,<empty>,3,,522,1,,void
296305,BLOCK,4,,"{
    Local<Value> chunk;
    if (!chunks->Get(env->context(), i).ToLocal(&chunk)) return;

    size_t length = Buffer::Length(chunk);

    bufs[i] = uv_buf_init(Buffer::Data(chunk), length);
  }",38,,522,4,,void
296327,BLOCK,-1,,<empty>,58,,524,2,,void
296359,BLOCK,-1,,"{
    const unsigned short port = args[3].As<Uint32>()->Value();
    node::Utf8Value address(env->isolate(), args[4]);
    err = sockaddr_for_family(family, address.out(), port, &addr_storage);
    if (err == 0)
      addr = reinterpret_cast<sockaddr*>(&addr_storage);
  }",15,,534,2,,void
296396,BLOCK,-1,,<empty>,7,,539,2,,void
296407,BLOCK,-1,,"{
    wrap->current_send_req_wrap_ = args[0].As<Object>();
    wrap->current_send_has_callback_ =
        sendto ? args[5]->IsTrue() : args[3]->IsTrue();

    err = static_cast<int>(wrap->Send(*bufs, count, addr));

    wrap->current_send_req_wrap_.Clear();
    wrap->current_send_has_callback_ = false;
  }",17,,542,2,,void
296473,BLOCK,-1,,"{
  if (IsHandleClosing()) return UV_EBADF;

  size_t msg_size = 0;
  for (size_t i = 0; i < count; i++)
    msg_size += bufs_ptr[i].len;

  int err = 0;
  if (!UNLIKELY(env()->options()->test_udp_no_try_send)) {
    err = uv_udp_try_send(&handle_, bufs_ptr, count, addr);
    if (err == UV_ENOSYS || err == UV_EAGAIN) {
      err = 0;
    } else if (err >= 0) {
      size_t sent = err;
      while (count > 0 && bufs_ptr->len <= sent) {
        sent -= bufs_ptr->len;
        bufs_ptr++;
        count--;
      }
      if (count > 0) {
        CHECK_LT(sent, bufs_ptr->len);
        bufs_ptr->base += sent;
        bufs_ptr->len -= sent;
      } else {
        CHECK_EQ(static_cast<size_t>(err), msg_size);
        // + 1 so that the JS side can distinguish 0-length async sends from
        // 0-length sync sends.
        return msg_size + 1;
      }
    }
  }

  if (err == 0) {
    AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(this);
    ReqWrap<uv_udp_send_t>* req_wrap = listener()...",45,,558,4,,void
296476,BLOCK,-1,,<empty>,26,,559,2,,void
296484,BLOCK,-1,,<empty>,3,,562,1,,void
296514,BLOCK,-1,,"{
    err = uv_udp_try_send(&handle_, bufs_ptr, count, addr);
    if (err == UV_ENOSYS || err == UV_EAGAIN) {
      err = 0;
    } else if (err >= 0) {
      size_t sent = err;
      while (count > 0 && bufs_ptr->len <= sent) {
        sent -= bufs_ptr->len;
        bufs_ptr++;
        count--;
      }
      if (count > 0) {
        CHECK_LT(sent, bufs_ptr->len);
        bufs_ptr->base += sent;
        bufs_ptr->len -= sent;
      } else {
        CHECK_EQ(static_cast<size_t>(err), msg_size);
        // + 1 so that the JS side can distinguish 0-length async sends from
        // 0-length sync sends.
        return msg_size + 1;
      }
    }
  }",58,,566,2,,void
296531,BLOCK,-1,,"{
      err = 0;
    }",47,,568,2,,void
296536,BLOCK,-1,,<empty>,12,,570,1,,void
296541,BLOCK,-1,,"{
      size_t sent = err;
      while (count > 0 && bufs_ptr->len <= sent) {
        sent -= bufs_ptr->len;
        bufs_ptr++;
        count--;
      }
      if (count > 0) {
        CHECK_LT(sent, bufs_ptr->len);
        bufs_ptr->base += sent;
        bufs_ptr->len -= sent;
      } else {
        CHECK_EQ(static_cast<size_t>(err), msg_size);
        // + 1 so that the JS side can distinguish 0-length async sends from
        // 0-length sync sends.
        return msg_size + 1;
      }
    }",26,,570,2,,void
296556,BLOCK,-1,,"{
        sent -= bufs_ptr->len;
        bufs_ptr++;
        count--;
      }",50,,572,2,,void
296570,BLOCK,-1,,"{
        CHECK_LT(sent, bufs_ptr->len);
        bufs_ptr->base += sent;
        bufs_ptr->len -= sent;
      }",22,,577,2,,void
296587,BLOCK,-1,,"{
        CHECK_EQ(static_cast<size_t>(err), msg_size);
        // + 1 so that the JS side can distinguish 0-length async sends from
        // 0-length sync sends.
        return msg_size + 1;
      }",14,,581,1,,void
296601,BLOCK,-1,,"{
    AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(this);
    ReqWrap<uv_udp_send_t>* req_wrap = listener()->CreateSendWrap(msg_size);
    if (req_wrap == nullptr) return UV_ENOSYS;

    err = req_wrap->Dispatch(
        uv_udp_send,
        &handle_,
        bufs_ptr,
        count,
        addr,
        uv_udp_send_cb{[](uv_udp_send_t* req, int status) {
          UDPWrap* self = ContainerOf(&UDPWrap::handle_, req->handle);
          self->listener()->OnSendDone(
              ReqWrap<uv_udp_send_t>::from_req(req), status);
        }});
    if (err)
      delete req_wrap;
  }",17,,590,2,,void
296621,BLOCK,-1,,<empty>,30,,593,2,,void
296641,BLOCK,-1,,<empty>,7,,607,2,,void
296650,BLOCK,-1,,"{
  SendWrap* req_wrap = new SendWrap(env(),
                                    current_send_req_wrap_,
                                    current_send_has_callback_);
  req_wrap->msg_size = msg_size;
  return req_wrap;
}",66,,614,2,,void
296670,BLOCK,-1,,"{
  DoSend(args, AF_INET);
}",61,,623,2,,void
296678,BLOCK,-1,,"{
  DoSend(args, AF_INET6);
}",62,,628,2,,void
296685,BLOCK,-1,,"{
  return this;
}",36,,633,1,,void
296691,BLOCK,-1,,"{
  return SocketAddress::FromPeerName(handle_);
}",38,,637,1,,void
296701,BLOCK,-1,,"{
  return SocketAddress::FromSockName(handle_);
}",38,,641,1,,void
296712,BLOCK,-1,,"{
  UDPWrapBase* wrap = UDPWrapBase::FromObject(args.Holder());
  args.GetReturnValue().Set(wrap == nullptr ? UV_EBADF : wrap->RecvStart());
}",70,,645,2,,void
296743,BLOCK,-1,,"{
  if (IsHandleClosing()) return UV_EBADF;
  int err = uv_udp_recv_start(&handle_, OnAlloc, OnRecv);
  // UV_EALREADY means that the socket is already bound but that's okay
  if (err == UV_EALREADY)
    err = 0;
  return err;
}",26,,650,1,,void
296746,BLOCK,-1,,<empty>,26,,651,2,,void
296761,BLOCK,-1,,<empty>,5,,655,2,,void
296771,BLOCK,-1,,"{
  UDPWrapBase* wrap = UDPWrapBase::FromObject(args.Holder());
  args.GetReturnValue().Set(wrap == nullptr ? UV_EBADF : wrap->RecvStop());
}",69,,660,2,,void
296802,BLOCK,-1,,"{
  if (IsHandleClosing()) return UV_EBADF;
  return uv_udp_recv_stop(&handle_);
}",25,,665,1,,void
296805,BLOCK,-1,,<empty>,26,,666,2,,void
296817,BLOCK,-1,,"{
  BaseObjectPtr<SendWrap> req_wrap{static_cast<SendWrap*>(req)};
  if (req_wrap->have_callback()) {
    Environment* env = req_wrap->env();
    HandleScope handle_scope(env->isolate());
    Context::Scope context_scope(env->context());
    Local<Value> arg[] = {
      Integer::New(env->isolate(), status),
      Integer::New(env->isolate(), req_wrap->msg_size),
    };
    req_wrap->MakeCallback(env->oncomplete_string(), 2, arg);
  }
}",67,,671,3,,void
296832,BLOCK,-1,,"{
    Environment* env = req_wrap->env();
    HandleScope handle_scope(env->isolate());
    Context::Scope context_scope(env->context());
    Local<Value> arg[] = {
      Integer::New(env->isolate(), status),
      Integer::New(env->isolate(), req_wrap->msg_size),
    };
    req_wrap->MakeCallback(env->oncomplete_string(), 2, arg);
  }",34,,673,2,,void
296892,BLOCK,-1,,"{
  UDPWrap* wrap = ContainerOf(&UDPWrap::handle_,
                              reinterpret_cast<uv_udp_t*>(handle));
  *buf = wrap->listener()->OnAlloc(suggested_size);
}",38,,688,4,,void
296919,BLOCK,-1,,"{
  return env()->allocate_managed_buffer(suggested_size);
}",50,,694,2,,void
296934,BLOCK,-1,,"{
  UDPWrap* wrap = ContainerOf(&UDPWrap::handle_, handle);
  wrap->listener()->OnRecv(nread, *buf, addr, flags);
}",42,,702,6,,void
296963,BLOCK,-1,,"{
  Environment* env = this->env();
  Isolate* isolate = env->isolate();
  std::unique_ptr<BackingStore> bs = env->release_managed_buffer(buf_);
  if (nread == 0 && addr == nullptr) {
    return;
  }

  HandleScope handle_scope(isolate);
  Context::Scope context_scope(env->context());

  Local<Value> argv[] = {
      Integer::New(isolate, static_cast<int32_t>(nread)),
      object(),
      Undefined(isolate),
      Undefined(isolate)};

  if (nread < 0) {
    MakeCallback(env->onmessage_string(), arraysize(argv), argv);
    return;
  } else if (nread == 0) {
    bs = ArrayBuffer::NewBackingStore(isolate, 0);
  } else {
    CHECK_LE(static_cast<size_t>(nread), bs->ByteLength());
    bs = BackingStore::Reallocate(isolate, std::move(bs), nread);
  }

  Local<Object> address;
  {
    bool has_caught = false;
    {
      TryCatchScope try_catch(env);
      if (!AddressToJS(env, addr).ToLocal(&address)) {
        DCHECK(try_catch.HasCaught() && !try_catch.HasTerminated());
        argv[2]...",42,,710,5,,void
296999,BLOCK,-1,,"{
    return;
  }",38,,714,2,,void
297031,BLOCK,-1,,"{
    MakeCallback(env->onmessage_string(), arraysize(argv), argv);
    return;
  }",18,,727,2,,void
297042,BLOCK,-1,,<empty>,10,,730,1,,void
297047,BLOCK,-1,,"{
    bs = ArrayBuffer::NewBackingStore(isolate, 0);
  }",26,,730,2,,void
297057,BLOCK,-1,,"{
    CHECK_LE(static_cast<size_t>(nread), bs->ByteLength());
    bs = BackingStore::Reallocate(isolate, std::move(bs), nread);
  }",10,,732,1,,void
297084,BLOCK,15,,"{
    bool has_caught = false;
    {
      TryCatchScope try_catch(env);
      if (!AddressToJS(env, addr).ToLocal(&address)) {
        DCHECK(try_catch.HasCaught() && !try_catch.HasTerminated());
        argv[2] = try_catch.Exception();
        DCHECK(!argv[2].IsEmpty());
        has_caught = true;
      }
    }
    if (has_caught) {
      DCHECK(!argv[2].IsEmpty());
      MakeCallback(env->onerror_string(), arraysize(argv), argv);
      return;
    }
  }",3,,738,15,,void
297089,BLOCK,3,,"{
      TryCatchScope try_catch(env);
      if (!AddressToJS(env, addr).ToLocal(&address)) {
        DCHECK(try_catch.HasCaught() && !try_catch.HasTerminated());
        argv[2] = try_catch.Exception();
        DCHECK(!argv[2].IsEmpty());
        has_caught = true;
      }
    }",5,,740,3,,void
297103,BLOCK,-1,,"{
        DCHECK(try_catch.HasCaught() && !try_catch.HasTerminated());
        argv[2] = try_catch.Exception();
        DCHECK(!argv[2].IsEmpty());
        has_caught = true;
      }",54,,742,2,,void
297136,BLOCK,-1,,"{
      DCHECK(!argv[2].IsEmpty());
      MakeCallback(env->onerror_string(), arraysize(argv), argv);
      return;
    }",21,,749,2,,void
297170,BLOCK,17,,"{
    bool has_caught = false;
    {
      TryCatchScope try_catch(env);
      if (!Buffer::New(env, ab, 0, ab->ByteLength()).ToLocal(&argv[2])) {
        DCHECK(try_catch.HasCaught() && !try_catch.HasTerminated());
        argv[2] = try_catch.Exception();
        DCHECK(!argv[2].IsEmpty());
        has_caught = true;
      }
    }
    if (has_caught) {
      DCHECK(!argv[2].IsEmpty());
      MakeCallback(env->onerror_string(), arraysize(argv), argv);
      return;
    }
  }",3,,757,17,,void
297175,BLOCK,3,,"{
      TryCatchScope try_catch(env);
      if (!Buffer::New(env, ab, 0, ab->ByteLength()).ToLocal(&argv[2])) {
        DCHECK(try_catch.HasCaught() && !try_catch.HasTerminated());
        argv[2] = try_catch.Exception();
        DCHECK(!argv[2].IsEmpty());
        has_caught = true;
      }
    }",5,,759,3,,void
297199,BLOCK,-1,,"{
        DCHECK(try_catch.HasCaught() && !try_catch.HasTerminated());
        argv[2] = try_catch.Exception();
        DCHECK(!argv[2].IsEmpty());
        has_caught = true;
      }",73,,761,2,,void
297232,BLOCK,-1,,"{
      DCHECK(!argv[2].IsEmpty());
      MakeCallback(env->onerror_string(), arraysize(argv), argv);
      return;
    }",21,,768,2,,void
297269,BLOCK,-1,,"{
  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(parent);

  // If this assert fires then Initialize hasn't been called yet.
  CHECK_EQ(env->udp_constructor_function().IsEmpty(), false);
  return env->udp_constructor_function()->NewInstance(env->context());
}",67,,781,4,,void
297298,BLOCK,-1,,"{
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(
      &wrap, args.Holder(), args.GetReturnValue().Set(UV_EBADF));

  size_t size = uv_udp_get_send_queue_size(&wrap->handle_);
  args.GetReturnValue().Set(static_cast<double>(size));
}",73,,789,2,,void
297337,BLOCK,-1,,"{
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(
      &wrap, args.Holder(), args.GetReturnValue().Set(UV_EBADF));

  size_t count = uv_udp_get_send_queue_count(&wrap->handle_);
  args.GetReturnValue().Set(static_cast<double>(count));
}",74,,798,2,,void
297389,BLOCK,-1,,<empty>,1,,1,1,,ANY
297394,BLOCK,-1,,<empty>,1,,1,1,,ANY
297409,BLOCK,-1,,<empty>,1,,1,1,,ANY
297412,BLOCK,-1,,"{
    uv_fs_req_cleanup(&req);
  }",50,,233,1,,void
297422,BLOCK,-1,,"{
    uv_fs_t close_req;
    CHECK_EQ(0, uv_fs_close(nullptr, &close_req, file, nullptr));
    uv_fs_req_cleanup(&close_req);
  }",44,,244,1,,void
297479,BLOCK,-1,,<empty>,1,,1,1,,ANY
297490,BLOCK,-1,,"{
  Local<String> string;
  if (!value->ToString(isolate->GetCurrentContext()).ToLocal(&string)) return;

  size_t storage;
  if (!StringBytes::StorageSize(isolate, string, UTF8).To(&storage)) return;
  storage += 1;
  target->AllocateSufficientStorage(storage);
  const int flags =
      String::NO_NULL_TERMINATION | String::REPLACE_INVALID_UTF8;
  const int length =
      string->WriteUtf8(isolate, target->out(), storage, nullptr, flags);
  target->SetLengthAndZeroTerminate(length);
}",57,,71,4,,void
297511,BLOCK,-1,,<empty>,72,,73,2,,void
297528,BLOCK,-1,,<empty>,70,,76,2,,void
297573,BLOCK,-1,,"{
  if (value.IsEmpty())
    return;

  MakeUtf8String(isolate, value, this);
}",60,,86,3,,void
297579,BLOCK,-1,,<empty>,5,,88,2,,void
297590,BLOCK,-1,,"{
  if (value.IsEmpty()) {
    return;
  }

  Local<String> string;
  if (!value->ToString(isolate->GetCurrentContext()).ToLocal(&string)) return;

  // Allocate enough space to include the null terminator
  const size_t storage = string->Length() + 1;
  AllocateSufficientStorage(storage);

  const int flags = String::NO_NULL_TERMINATION;
  const int length = string->Write(isolate, out(), 0, storage, flags);
  SetLengthAndZeroTerminate(length);
}",66,,94,3,,void
297596,BLOCK,-1,,"{
    return;
  }",24,,95,2,,void
297618,BLOCK,-1,,<empty>,72,,100,2,,void
297656,BLOCK,-1,,"{
  // Slightly different take on Utf8Value. If value is a String,
  // it will return a Utf8 encoded string. If value is a Buffer,
  // it will copy the data out of the Buffer as is.
  if (value.IsEmpty()) {
    // Dereferencing this object will return nullptr.
    Invalidate();
    return;
  }

  if (value->IsString()) {
    MakeUtf8String(isolate, value, this);
  } else if (value->IsArrayBufferView()) {
    const size_t len = value.As<ArrayBufferView>()->ByteLength();
    // Leave place for the terminating '\0' byte.
    AllocateSufficientStorage(len + 1);
    value.As<ArrayBufferView>()->CopyContents(out(), len);
    SetLengthAndZeroTerminate(len);
  } else {
    Invalidate();
  }
}",64,,111,3,,void
297662,BLOCK,-1,,"{
    // Dereferencing this object will return nullptr.
    Invalidate();
    return;
  }",24,,115,2,,void
297670,BLOCK,-1,,"{
    MakeUtf8String(isolate, value, this);
  }",26,,121,2,,void
297676,BLOCK,-1,,<empty>,10,,123,1,,void
297682,BLOCK,-1,,"{
    const size_t len = value.As<ArrayBufferView>()->ByteLength();
    // Leave place for the terminating '\0' byte.
    AllocateSufficientStorage(len + 1);
    value.As<ArrayBufferView>()->CopyContents(out(), len);
    SetLengthAndZeroTerminate(len);
  }",42,,123,2,,void
297709,BLOCK,-1,,"{
    Invalidate();
  }",10,,129,1,,void
297714,BLOCK,-1,,"{
  if (per_process::v8_initialized) {
    auto isolate = Isolate::TryGetCurrent();
    if (isolate != nullptr) {
      isolate->LowMemoryNotification();
    }
  }
}",30,,134,1,,void
297719,BLOCK,-1,,"{
    auto isolate = Isolate::TryGetCurrent();
    if (isolate != nullptr) {
      isolate->LowMemoryNotification();
    }
  }",36,,135,2,,void
297731,BLOCK,-1,,"{
      isolate->LowMemoryNotification();
    }",29,,137,2,,void
297740,BLOCK,-1,,"{
  std::string buf(16, '\0');

  for (;;) {
    const int rc = uv_get_process_title(buf.data(), buf.size());

    if (rc == 0)
      break;

    // If uv_setup_args() was not called, `uv_get_process_title()` will always
    // return `UV_ENOBUFS`, no matter the input size. Guard against a possible
    // infinite loop by limiting the buffer size.
    if (rc != UV_ENOBUFS || buf.size() >= 1024 * 1024)
      return default_title;

    buf.resize(2 * buf.size());
  }

  // Strip excess trailing nul bytes. Using strlen() here is safe,
  // uv_get_process_title() always zero-terminates the result.
  buf.resize(strlen(buf.data()));

  return buf;
}",56,,143,2,,void
297746,BLOCK,-1,,<empty>,3,,146,1,,void
297747,BLOCK,4,,"{
    const int rc = uv_get_process_title(buf.data(), buf.size());

    if (rc == 0)
      break;

    // If uv_setup_args() was not called, `uv_get_process_title()` will always
    // return `UV_ENOBUFS`, no matter the input size. Guard against a possible
    // infinite loop by limiting the buffer size.
    if (rc != UV_ENOBUFS || buf.size() >= 1024 * 1024)
      return default_title;

    buf.resize(2 * buf.size());
  }",12,,146,4,,void
297764,BLOCK,-1,,<empty>,7,,150,2,,void
297779,BLOCK,-1,,<empty>,7,,156,2,,void
297806,BLOCK,-1,,"{
  return SPrintF(""%s[%d]"", GetProcessTitle(""Node.js""), uv_os_getpid());
}",43,,168,1,,void
297819,BLOCK,-1,,"{
  std::vector<std::string> out;
  if (in.empty())
    return out;
  std::istringstream in_stream(in);
  while (in_stream.good()) {
    std::string item;
    std::getline(in_stream, item, delim);
    if (item.empty() && skipEmpty) continue;
    out.emplace_back(std::move(item));
  }
  return out;
}",54,,174,4,,void
297834,BLOCK,-1,,<empty>,5,,177,2,,void
297845,BLOCK,-1,,"{
    std::string item;
    std::getline(in_stream, item, delim);
    if (item.empty() && skipEmpty) continue;
    out.emplace_back(std::move(item));
  }",28,,179,2,,void
297861,BLOCK,-1,,<empty>,36,,182,2,,void
297878,BLOCK,-1,,"{
  isolate->ThrowException(ERR_STRING_TOO_LONG(isolate));
}",46,,188,2,,void
297888,BLOCK,-1,,"{
  constexpr double kMicrosecondsPerSecond = 1e6;
  uv_timeval64_t tv;
  CHECK_EQ(0, uv_gettimeofday(&tv));
  return kMicrosecondsPerSecond * tv.tv_sec + tv.tv_usec;
}",39,,192,1,,void
297914,BLOCK,-1,,"{
  uv_fs_t req;
  int fd = uv_fs_open(nullptr,
                      &req,
                      path,
                      O_WRONLY | O_CREAT | O_TRUNC,
                      S_IWUSR | S_IRUSR,
                      nullptr);
  uv_fs_req_cleanup(&req);
  if (fd < 0) {
    return fd;
  }

  int err = uv_fs_write(nullptr, &req, fd, &buf, 1, 0, nullptr);
  uv_fs_req_cleanup(&req);
  if (err < 0) {
    return err;
  }

  err = uv_fs_close(nullptr, &req, fd, nullptr);
  uv_fs_req_cleanup(&req);
  return err;
}",51,,199,3,,void
297940,BLOCK,-1,,"{
    return fd;
  }",15,,208,2,,void
297963,BLOCK,-1,,"{
    return err;
  }",16,,214,2,,void
297985,BLOCK,-1,,"{
  node::Utf8Value utf8(isolate, string);
  uv_buf_t buf = uv_buf_init(utf8.out(), utf8.length());
  return WriteFileSync(path, buf);
}",49,,225,4,,void
298011,BLOCK,-1,,"{
  uv_fs_t req;
  auto defer_req_cleanup = OnScopeLeave([&req]() {
    uv_fs_req_cleanup(&req);
  });

  uv_file file = uv_fs_open(nullptr, &req, path, O_RDONLY, 0, nullptr);
  if (req.result < 0) {
    // req will be cleaned up by scope leave.
    return req.result;
  }
  uv_fs_req_cleanup(&req);

  auto defer_close = OnScopeLeave([file]() {
    uv_fs_t close_req;
    CHECK_EQ(0, uv_fs_close(nullptr, &close_req, file, nullptr));
    uv_fs_req_cleanup(&close_req);
  });

  *result = std::string("""");
  char buffer[4096];
  uv_buf_t buf = uv_buf_init(buffer, sizeof(buffer));

  while (true) {
    const int r =
        uv_fs_read(nullptr, &req, file, &buf, 1, result->length(), nullptr);
    if (req.result < 0) {
      // req will be cleaned up by scope leave.
      return req.result;
    }
    uv_fs_req_cleanup(&req);
    if (r <= 0) {
      break;
    }
    result->append(buf.base, r);
  }
  return 0;
}",57,,231,3,,void
298033,BLOCK,-1,,"{
    // req will be cleaned up by scope leave.
    return req.result;
  }",23,,238,2,,void
298064,BLOCK,-1,,"{
    const int r =
        uv_fs_read(nullptr, &req, file, &buf, 1, result->length(), nullptr);
    if (req.result < 0) {
      // req will be cleaned up by scope leave.
      return req.result;
    }
    uv_fs_req_cleanup(&req);
    if (r <= 0) {
      break;
    }
    result->append(buf.base, r);
  }",16,,254,2,,void
298087,BLOCK,-1,,"{
      // req will be cleaned up by scope leave.
      return req.result;
    }",25,,257,2,,void
298099,BLOCK,-1,,"{
      break;
    }",17,,262,2,,void
298115,BLOCK,-1,,"{
  CHECK_EQ(ftell(fp), 0);
  int err = fseek(fp, 0, SEEK_END);
  CHECK_EQ(err, 0);
  size_t size = ftell(fp);
  CHECK_NE(size, static_cast<size_t>(-1L));
  err = fseek(fp, 0, SEEK_SET);
  CHECK_EQ(err, 0);

  std::vector<char> contents(size);
  size_t num_read = fread(contents.data(), size, 1, fp);
  CHECK_EQ(num_read, 1);
  return contents;
}",42,,270,2,,void
298173,BLOCK,-1,,"{
#ifdef _WIN32
  GetLocalTime(tm_struct);
#else  // UNIX, OSX
  struct timeval time_val;
  gettimeofday(&time_val, nullptr);
  localtime_r(&time_val.tv_sec, tm_struct);
#endif
}",58,,285,2,,void
298191,BLOCK,-1,,"{
  std::ostringstream oss;
  TIME_TYPE tm_struct;
  LocalTime(&tm_struct);
  oss << prefix;
#ifdef _WIN32
  oss << ""."" << std::setfill('0') << std::setw(4) << tm_struct.wYear;
  oss << std::setfill('0') << std::setw(2) << tm_struct.wMonth;
  oss << std::setfill('0') << std::setw(2) << tm_struct.wDay;
  oss << ""."" << std::setfill('0') << std::setw(2) << tm_struct.wHour;
  oss << std::setfill('0') << std::setw(2) << tm_struct.wMinute;
  oss << std::setfill('0') << std::setw(2) << tm_struct.wSecond;
#else  // UNIX, OSX
  oss << "".""
            << std::setfill('0')
            << std::setw(4)
            << tm_struct.tm_year + 1900;
  oss << std::setfill('0')
            << std::setw(2)
            << tm_struct.tm_mon + 1;
  oss << std::setfill('0')
            << std::setw(2)
            << tm_struct.tm_mday;
  oss << "".""
            << std::setfill('0')
            << std::setw(2)
            << tm_struct.tm_hour;
  oss << std::setfill('0')
            << std::setw(2)
            << ...",22,,299,4,,void
298357,BLOCK,-1,,"{
  return v8::FunctionTemplate::New(isolate,
                                   callback,
                                   Local<v8::Value>(),
                                   signature,
                                   0,
                                   behavior,
                                   side_effect_type,
                                   c_function);
}",38,,346,7,,void
298381,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  Local<v8::Function> function =
      NewFunctionTemplate(isolate,
                          callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasSideEffect)
          ->GetFunction(context)
          .ToLocalChecked();
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->Set(context, name_string, function).Check();
  function->SetName(name_string);  // NODE_SET_METHOD() compatibility.
}",47,,360,5,,void
298469,BLOCK,-1,,"{
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasSideEffect);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->Set(name_string, t);
}",47,,381,5,,void
298535,BLOCK,-1,,"{
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          slow_callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasSideEffect,
                          c_function);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->Set(name_string, t);
}",53,,399,6,,void
298602,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  Local<v8::Function> function =
      NewFunctionTemplate(isolate,
                          slow_callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasSideEffect,
                          c_function)
          ->GetFunction(context)
          .ToLocalChecked();
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->Set(context, name_string, function).Check();
}",53,,418,6,,void
298687,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  Local<v8::Function> function =
      NewFunctionTemplate(isolate,
                          slow_callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasNoSideEffect,
                          c_function)
          ->GetFunction(context)
          .ToLocalChecked();
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->Set(context, name_string, function).Check();
}",65,,439,6,,void
298772,BLOCK,-1,,"{
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          slow_callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasNoSideEffect,
                          c_function);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->Set(name_string, t);
}",65,,460,6,,void
298838,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  Local<v8::Function> function =
      NewFunctionTemplate(isolate,
                          callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasNoSideEffect)
          ->GetFunction(context)
          .ToLocalChecked();
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->Set(context, name_string, function).Check();
  function->SetName(name_string);  // NODE_SET_METHOD() compatibility.
}",59,,478,5,,void
298926,BLOCK,-1,,"{
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasNoSideEffect);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->Set(name_string, t);
}",59,,499,5,,void
298991,BLOCK,-1,,"{
  Local<v8::Signature> signature = v8::Signature::New(isolate, that);
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          callback,
                          signature,
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasSideEffect);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->PrototypeTemplate()->Set(name_string, t);
  t->SetClassName(name_string);  // NODE_SET_PROTOTYPE_METHOD() compatibility.
}",52,,516,5,,void
299079,BLOCK,-1,,"{
  Local<v8::Signature> signature = v8::Signature::New(isolate, that);
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          callback,
                          signature,
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasNoSideEffect);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->PrototypeTemplate()->Set(name_string, t);
  t->SetClassName(name_string);  // NODE_SET_PROTOTYPE_METHOD() compatibility.
}",64,,535,5,,void
299167,BLOCK,-1,,"{
  Local<v8::Signature> signature = v8::Signature::New(isolate, that);
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          callback,
                          signature,
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasSideEffect);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->InstanceTemplate()->Set(name_string, t);
  t->SetClassName(name_string);
}",55,,554,5,,void
299256,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  SetConstructorFunction(
      context, that, OneByteString(isolate, name), tmpl, flag);
}",62,,574,6,,void
299280,BLOCK,-1,,"{
  if (LIKELY(flag == SetConstructorFunctionFlag::SET_CLASS_NAME))
    tmpl->SetClassName(name);
  that->Set(context, name, tmpl->GetFunction(context).ToLocalChecked()).Check();
}",62,,584,6,,void
299288,BLOCK,-1,,<empty>,5,,586,2,,void
299319,BLOCK,-1,,"{
  SetConstructorFunction(
      isolate, that, OneByteString(isolate, name), tmpl, flag);
}",62,,594,6,,void
299336,BLOCK,-1,,"{
  if (LIKELY(flag == SetConstructorFunctionFlag::SET_CLASS_NAME))
    tmpl->SetClassName(name);
  that->Set(name, tmpl);
}",62,,603,6,,void
299344,BLOCK,-1,,<empty>,5,,605,2,,void
299360,BLOCK,-1,,"{
  if (is_one_byte()) {
    return String::NewExternalOneByte(isolate, one_byte_resource_)
        .ToLocalChecked();
  } else {
    return String::NewExternalTwoByte(isolate, two_byte_resource_)
        .ToLocalChecked();
  }
}",67,,609,2,,void
299363,BLOCK,-1,,"{
    return String::NewExternalOneByte(isolate, one_byte_resource_)
        .ToLocalChecked();
  }",22,,610,2,,void
299375,BLOCK,-1,,"{
    return String::NewExternalTwoByte(isolate, two_byte_resource_)
        .ToLocalChecked();
  }",10,,613,1,,void
299428,BLOCK,-1,,<empty>,1,,1,1,,ANY
299443,BLOCK,-1,,<empty>,1,,1,1,,ANY
299460,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  if (env->options()->pending_deprecation && env->EmitErrNameWarning()) {
    if (ProcessEmitDeprecationWarning(
        env,
        ""Directly calling process.binding('uv').errname(<val>) is being""
        "" deprecated. ""
        ""Please make sure to use util.getSystemErrorName() instead."",
        ""DEP0119"").IsNothing())
    return;
  }
  int err;
  if (!args[0]->Int32Value(env->context()).To(&err)) return;
  CHECK_LT(err, 0);
  char name[50];
  uv_err_name_r(err, name, sizeof(name));
  args.GetReturnValue().Set(OneByteString(env->isolate(), name));
}",55,,62,2,,void
299481,BLOCK,-1,,"{
    if (ProcessEmitDeprecationWarning(
        env,
        ""Directly calling process.binding('uv').errname(<val>) is being""
        "" deprecated. ""
        ""Please make sure to use util.getSystemErrorName() instead."",
        ""DEP0119"").IsNothing())
    return;
  }",73,,64,2,,void
299490,BLOCK,-1,,<empty>,5,,71,2,,void
299510,BLOCK,-1,,<empty>,54,,74,2,,void
299538,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();

  // This can't return a SafeMap, because the uv binding can be referenced
  // by user code by using `process.binding('uv').getErrorMap()`:
  Local<Map> err_map = Map::New(isolate);

  size_t errors_len = arraysize(per_process::uv_errors_map);
  for (size_t i = 0; i < errors_len; ++i) {
    const auto& error = per_process::uv_errors_map[i];
    Local<Value> arr[] = {OneByteString(isolate, error.name),
                          OneByteString(isolate, error.message)};
    if (err_map
            ->Set(context,
                  Integer::New(isolate, error.value),
                  Array::New(isolate, arr, arraysize(arr)))
            .IsEmpty()) {
      return;
    }
  }

  args.GetReturnValue().Set(err_map);
}",57,,81,2,,void
299583,BLOCK,-1,,<empty>,3,,91,1,,void
299593,BLOCK,4,,"{
    const auto& error = per_process::uv_errors_map[i];
    Local<Value> arr[] = {OneByteString(isolate, error.name),
                          OneByteString(isolate, error.message)};
    if (err_map
            ->Set(context,
                  Integer::New(isolate, error.value),
                  Array::New(isolate, arr, arraysize(arr)))
            .IsEmpty()) {
      return;
    }
  }",43,,91,4,,void
299641,BLOCK,-1,,"{
      return;
    }",25,,99,2,,void
299658,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();
  SetConstructorFunction(
      context, target, ""errname"", NewFunctionTemplate(isolate, ErrName));

  // TODO(joyeecheung): This should be deprecated in user land in favor of
  // `util.getSystemErrorName(err)`.
  PropertyAttribute attributes =
      static_cast<PropertyAttribute>(ReadOnly | DontDelete);
  size_t errors_len = arraysize(per_process::uv_errors_map);
  const std::string prefix = ""UV_"";
  for (size_t i = 0; i < errors_len; ++i) {
    const auto& error = per_process::uv_errors_map[i];
    const std::string prefixed_name = prefix + error.name;
    Local<String> name = OneByteString(isolate, prefixed_name.c_str());
    Local<Integer> value = Integer::New(isolate, error.value);
    target->DefineOwnProperty(context, name, value, attributes).Check();
  }

  SetMethod(context, target, ""getErrorMap"", GetErrMap);
}",29,,110,5,,void
299701,BLOCK,-1,,<empty>,3,,122,1,,void
299711,BLOCK,4,,"{
    const auto& error = per_process::uv_errors_map[i];
    const std::string prefixed_name = prefix + error.name;
    Local<String> name = OneByteString(isolate, prefixed_name.c_str());
    Local<Integer> value = Integer::New(isolate, error.value);
    target->DefineOwnProperty(context, name, value, attributes).Check();
  }",43,,122,4,,void
299774,BLOCK,-1,,"{
  registry->Register(ErrName);
  registry->Register(GetErrMap);
}",70,,133,2,,void
303534,BLOCK,-1,,<empty>,,,,1,,ANY
303946,BLOCK,1,,<empty>,,,,1,,ANY
303951,BLOCK,1,,<empty>,,,,1,,ANY
303959,BLOCK,1,,<empty>,,,,1,,ANY
303964,BLOCK,1,,<empty>,,,,1,,ANY
303969,BLOCK,1,,<empty>,,,,1,,ANY
303973,BLOCK,1,,<empty>,,,,1,,ANY
303978,BLOCK,1,,<empty>,,,,1,,ANY
303981,BLOCK,1,,<empty>,,,,1,,ANY
303987,BLOCK,1,,<empty>,,,,1,,ANY
303991,BLOCK,1,,<empty>,,,,1,,ANY
303995,BLOCK,1,,<empty>,,,,1,,ANY
303999,BLOCK,1,,<empty>,,,,1,,ANY
304003,BLOCK,1,,<empty>,,,,1,,ANY
304008,BLOCK,1,,<empty>,,,,1,,ANY
304012,BLOCK,1,,<empty>,,,,1,,ANY
304017,BLOCK,1,,<empty>,,,,1,,ANY
304021,BLOCK,1,,<empty>,,,,1,,ANY
304025,BLOCK,1,,<empty>,,,,1,,ANY
304029,BLOCK,1,,<empty>,,,,1,,ANY
304033,BLOCK,1,,<empty>,,,,1,,ANY
304037,BLOCK,1,,<empty>,,,,1,,ANY
304041,BLOCK,1,,<empty>,,,,1,,ANY
304046,BLOCK,1,,<empty>,,,,1,,ANY
304051,BLOCK,1,,<empty>,,,,1,,ANY
304055,BLOCK,1,,<empty>,,,,1,,ANY
304059,BLOCK,1,,<empty>,,,,1,,ANY
304064,BLOCK,1,,<empty>,,,,1,,ANY
304068,BLOCK,1,,<empty>,,,,1,,ANY
304073,BLOCK,1,,<empty>,,,,1,,ANY
304078,BLOCK,1,,<empty>,,,,1,,ANY
304085,BLOCK,1,,<empty>,,,,1,,ANY
304090,BLOCK,1,,<empty>,,,,1,,ANY
304096,BLOCK,1,,<empty>,,,,1,,ANY
304100,BLOCK,1,,<empty>,,,,1,,ANY
304104,BLOCK,1,,<empty>,,,,1,,ANY
304107,BLOCK,1,,<empty>,,,,1,,ANY
304111,BLOCK,1,,<empty>,,,,1,,ANY
304117,BLOCK,1,,<empty>,,,,1,,ANY
304122,BLOCK,1,,<empty>,,,,1,,ANY
304127,BLOCK,1,,<empty>,,,,1,,ANY
304131,BLOCK,1,,<empty>,,,,1,,ANY
304135,BLOCK,1,,<empty>,,,,1,,ANY
304139,BLOCK,1,,<empty>,,,,1,,ANY
304144,BLOCK,1,,<empty>,,,,1,,ANY
304148,BLOCK,1,,<empty>,,,,1,,ANY
304153,BLOCK,1,,<empty>,,,,1,,ANY
304157,BLOCK,1,,<empty>,,,,1,,ANY
304161,BLOCK,1,,<empty>,,,,1,,ANY
304165,BLOCK,1,,<empty>,,,,1,,ANY
304169,BLOCK,1,,<empty>,,,,1,,ANY
304173,BLOCK,1,,<empty>,,,,1,,ANY
304177,BLOCK,1,,<empty>,,,,1,,ANY
304181,BLOCK,1,,<empty>,,,,1,,ANY
304185,BLOCK,1,,<empty>,,,,1,,ANY
304193,BLOCK,1,,<empty>,,,,1,,ANY
304197,BLOCK,1,,<empty>,,,,1,,ANY
304202,BLOCK,1,,<empty>,,,,1,,ANY
304206,BLOCK,1,,<empty>,,,,1,,ANY
304210,BLOCK,1,,<empty>,,,,1,,ANY
304213,BLOCK,1,,<empty>,,,,1,,ANY
304217,BLOCK,1,,<empty>,,,,1,,ANY
304223,BLOCK,1,,<empty>,,,,1,,ANY
304227,BLOCK,1,,<empty>,,,,1,,ANY
304231,BLOCK,1,,<empty>,,,,1,,ANY
304235,BLOCK,1,,<empty>,,,,1,,ANY
304239,BLOCK,1,,<empty>,,,,1,,ANY
304243,BLOCK,1,,<empty>,,,,1,,ANY
304247,BLOCK,1,,<empty>,,,,1,,ANY
304255,BLOCK,1,,<empty>,,,,1,,ANY
304261,BLOCK,1,,<empty>,,,,1,,ANY
304265,BLOCK,1,,<empty>,,,,1,,ANY
304268,BLOCK,1,,<empty>,,,,1,,ANY
304273,BLOCK,1,,<empty>,,,,1,,ANY
304277,BLOCK,1,,<empty>,,,,1,,ANY
304281,BLOCK,1,,<empty>,,,,1,,ANY
304285,BLOCK,1,,<empty>,,,,1,,ANY
304289,BLOCK,1,,<empty>,,,,1,,ANY
304299,BLOCK,1,,<empty>,,,,1,,ANY
304304,BLOCK,1,,<empty>,,,,1,,ANY
304308,BLOCK,1,,<empty>,,,,1,,ANY
304313,BLOCK,1,,<empty>,,,,1,,ANY
304318,BLOCK,1,,<empty>,,,,1,,ANY
304323,BLOCK,1,,<empty>,,,,1,,ANY
304327,BLOCK,1,,<empty>,,,,1,,ANY
304332,BLOCK,1,,<empty>,,,,1,,ANY
304340,BLOCK,1,,<empty>,,,,1,,ANY
304350,BLOCK,1,,<empty>,,,,1,,ANY
304354,BLOCK,1,,<empty>,,,,1,,ANY
304359,BLOCK,1,,<empty>,,,,1,,ANY
304363,BLOCK,1,,<empty>,,,,1,,ANY
304367,BLOCK,1,,<empty>,,,,1,,ANY
304371,BLOCK,1,,<empty>,,,,1,,ANY
304374,BLOCK,1,,<empty>,,,,1,,ANY
304379,BLOCK,1,,<empty>,,,,1,,ANY
304383,BLOCK,1,,<empty>,,,,1,,ANY
304388,BLOCK,1,,<empty>,,,,1,,ANY
304392,BLOCK,1,,<empty>,,,,1,,ANY
304397,BLOCK,1,,<empty>,,,,1,,ANY
304401,BLOCK,1,,<empty>,,,,1,,ANY
304406,BLOCK,1,,<empty>,,,,1,,ANY
304410,BLOCK,1,,<empty>,,,,1,,ANY
304414,BLOCK,1,,<empty>,,,,1,,ANY
304418,BLOCK,1,,<empty>,,,,1,,ANY
304422,BLOCK,1,,<empty>,,,,1,,ANY
304427,BLOCK,1,,<empty>,,,,1,,ANY
304430,BLOCK,1,,<empty>,,,,1,,ANY
304434,BLOCK,1,,<empty>,,,,1,,ANY
304439,BLOCK,1,,<empty>,,,,1,,ANY
304443,BLOCK,1,,<empty>,,,,1,,ANY
304447,BLOCK,1,,<empty>,,,,1,,ANY
304453,BLOCK,1,,<empty>,,,,1,,ANY
304457,BLOCK,1,,<empty>,,,,1,,ANY
304462,BLOCK,1,,<empty>,,,,1,,ANY
304467,BLOCK,1,,<empty>,,,,1,,ANY
304471,BLOCK,1,,<empty>,,,,1,,ANY
304475,BLOCK,1,,<empty>,,,,1,,ANY
304481,BLOCK,1,,<empty>,,,,1,,ANY
304486,BLOCK,1,,<empty>,,,,1,,ANY
304490,BLOCK,1,,<empty>,,,,1,,ANY
304495,BLOCK,1,,<empty>,,,,1,,ANY
304500,BLOCK,1,,<empty>,,,,1,,ANY
304504,BLOCK,1,,<empty>,,,,1,,ANY
304511,BLOCK,1,,<empty>,,,,1,,ANY
304515,BLOCK,1,,<empty>,,,,1,,ANY
304519,BLOCK,1,,<empty>,,,,1,,ANY
304523,BLOCK,1,,<empty>,,,,1,,ANY
304528,BLOCK,1,,<empty>,,,,1,,ANY
304536,BLOCK,1,,<empty>,,,,1,,ANY
304540,BLOCK,1,,<empty>,,,,1,,ANY
304544,BLOCK,1,,<empty>,,,,1,,ANY
304548,BLOCK,1,,<empty>,,,,1,,ANY
304553,BLOCK,1,,<empty>,,,,1,,ANY
304557,BLOCK,1,,<empty>,,,,1,,ANY
304562,BLOCK,1,,<empty>,,,,1,,ANY
304569,BLOCK,1,,<empty>,,,,1,,ANY
304573,BLOCK,1,,<empty>,,,,1,,ANY
304580,BLOCK,1,,<empty>,,,,1,,ANY
304585,BLOCK,1,,<empty>,,,,1,,ANY
304588,BLOCK,1,,<empty>,,,,1,,ANY
304592,BLOCK,1,,<empty>,,,,1,,ANY
304595,BLOCK,1,,<empty>,,,,1,,ANY
304602,BLOCK,1,,<empty>,,,,1,,ANY
304606,BLOCK,1,,<empty>,,,,1,,ANY
304609,BLOCK,1,,<empty>,,,,1,,ANY
304613,BLOCK,1,,<empty>,,,,1,,ANY
304617,BLOCK,1,,<empty>,,,,1,,ANY
304623,BLOCK,1,,<empty>,,,,1,,ANY
304628,BLOCK,1,,<empty>,,,,1,,ANY
304633,BLOCK,1,,<empty>,,,,1,,ANY
304637,BLOCK,1,,<empty>,,,,1,,ANY
304641,BLOCK,1,,<empty>,,,,1,,ANY
304647,BLOCK,1,,<empty>,,,,1,,ANY
304652,BLOCK,1,,<empty>,,,,1,,ANY
304656,BLOCK,1,,<empty>,,,,1,,ANY
304659,BLOCK,1,,<empty>,,,,1,,ANY
304664,BLOCK,1,,<empty>,,,,1,,ANY
304670,BLOCK,1,,<empty>,,,,1,,ANY
304675,BLOCK,1,,<empty>,,,,1,,ANY
304679,BLOCK,1,,<empty>,,,,1,,ANY
304683,BLOCK,1,,<empty>,,,,1,,ANY
304688,BLOCK,1,,<empty>,,,,1,,ANY
304693,BLOCK,1,,<empty>,,,,1,,ANY
304702,BLOCK,1,,<empty>,,,,1,,ANY
304709,BLOCK,1,,<empty>,,,,1,,ANY
304713,BLOCK,1,,<empty>,,,,1,,ANY
304722,BLOCK,1,,<empty>,,,,1,,ANY
304727,BLOCK,1,,<empty>,,,,1,,ANY
304731,BLOCK,1,,<empty>,,,,1,,ANY
304736,BLOCK,1,,<empty>,,,,1,,ANY
304741,BLOCK,1,,<empty>,,,,1,,ANY
304745,BLOCK,1,,<empty>,,,,1,,ANY
304749,BLOCK,1,,<empty>,,,,1,,ANY
304753,BLOCK,1,,<empty>,,,,1,,ANY
304757,BLOCK,1,,<empty>,,,,1,,ANY
304761,BLOCK,1,,<empty>,,,,1,,ANY
304765,BLOCK,1,,<empty>,,,,1,,ANY
304770,BLOCK,1,,<empty>,,,,1,,ANY
304775,BLOCK,1,,<empty>,,,,1,,ANY
304779,BLOCK,1,,<empty>,,,,1,,ANY
304783,BLOCK,1,,<empty>,,,,1,,ANY
304787,BLOCK,1,,<empty>,,,,1,,ANY
304791,BLOCK,1,,<empty>,,,,1,,ANY
304795,BLOCK,1,,<empty>,,,,1,,ANY
304799,BLOCK,1,,<empty>,,,,1,,ANY
304803,BLOCK,1,,<empty>,,,,1,,ANY
304808,BLOCK,1,,<empty>,,,,1,,ANY
304813,BLOCK,1,,<empty>,,,,1,,ANY
304817,BLOCK,1,,<empty>,,,,1,,ANY
304823,BLOCK,1,,<empty>,,,,1,,ANY
304830,BLOCK,1,,<empty>,,,,1,,ANY
304835,BLOCK,1,,<empty>,,,,1,,ANY
304841,BLOCK,1,,<empty>,,,,1,,ANY
304847,BLOCK,1,,<empty>,,,,1,,ANY
304851,BLOCK,1,,<empty>,,,,1,,ANY
304856,BLOCK,1,,<empty>,,,,1,,ANY
304861,BLOCK,1,,<empty>,,,,1,,ANY
304866,BLOCK,1,,<empty>,,,,1,,ANY
304871,BLOCK,1,,<empty>,,,,1,,ANY
304877,BLOCK,1,,<empty>,,,,1,,ANY
304884,BLOCK,1,,<empty>,,,,1,,ANY
304890,BLOCK,1,,<empty>,,,,1,,ANY
304894,BLOCK,1,,<empty>,,,,1,,ANY
304899,BLOCK,1,,<empty>,,,,1,,ANY
304905,BLOCK,1,,<empty>,,,,1,,ANY
304911,BLOCK,1,,<empty>,,,,1,,ANY
304916,BLOCK,1,,<empty>,,,,1,,ANY
304920,BLOCK,1,,<empty>,,,,1,,ANY
304924,BLOCK,1,,<empty>,,,,1,,ANY
304928,BLOCK,1,,<empty>,,,,1,,ANY
304931,BLOCK,1,,<empty>,,,,1,,ANY
304937,BLOCK,1,,<empty>,,,,1,,ANY
304940,BLOCK,1,,<empty>,,,,1,,ANY
304944,BLOCK,1,,<empty>,,,,1,,ANY
304950,BLOCK,1,,<empty>,,,,1,,ANY
304954,BLOCK,1,,<empty>,,,,1,,ANY
304960,BLOCK,1,,<empty>,,,,1,,ANY
304965,BLOCK,1,,<empty>,,,,1,,ANY
304970,BLOCK,1,,<empty>,,,,1,,ANY
304975,BLOCK,1,,<empty>,,,,1,,ANY
304980,BLOCK,1,,<empty>,,,,1,,ANY
304985,BLOCK,1,,<empty>,,,,1,,ANY
304990,BLOCK,1,,<empty>,,,,1,,ANY
304995,BLOCK,1,,<empty>,,,,1,,ANY
304999,BLOCK,1,,<empty>,,,,1,,ANY
305003,BLOCK,1,,<empty>,,,,1,,ANY
305008,BLOCK,1,,<empty>,,,,1,,ANY
305013,BLOCK,1,,<empty>,,,,1,,ANY
305018,BLOCK,1,,<empty>,,,,1,,ANY
305023,BLOCK,1,,<empty>,,,,1,,ANY
305028,BLOCK,1,,<empty>,,,,1,,ANY
305032,BLOCK,1,,<empty>,,,,1,,ANY
305038,BLOCK,1,,<empty>,,,,1,,ANY
305042,BLOCK,1,,<empty>,,,,1,,ANY
305048,BLOCK,1,,<empty>,,,,1,,ANY
305053,BLOCK,1,,<empty>,,,,1,,ANY
305057,BLOCK,1,,<empty>,,,,1,,ANY
305063,BLOCK,1,,<empty>,,,,1,,ANY
305067,BLOCK,1,,<empty>,,,,1,,ANY
305071,BLOCK,1,,<empty>,,,,1,,ANY
305077,BLOCK,1,,<empty>,,,,1,,ANY
305081,BLOCK,1,,<empty>,,,,1,,ANY
305086,BLOCK,1,,<empty>,,,,1,,ANY
305090,BLOCK,1,,<empty>,,,,1,,ANY
305095,BLOCK,1,,<empty>,,,,1,,ANY
305099,BLOCK,1,,<empty>,,,,1,,ANY
305103,BLOCK,1,,<empty>,,,,1,,ANY
305106,BLOCK,1,,<empty>,,,,1,,ANY
305110,BLOCK,1,,<empty>,,,,1,,ANY
305114,BLOCK,1,,<empty>,,,,1,,ANY
305121,BLOCK,1,,<empty>,,,,1,,ANY
305125,BLOCK,1,,<empty>,,,,1,,ANY
305129,BLOCK,1,,<empty>,,,,1,,ANY
305133,BLOCK,1,,<empty>,,,,1,,ANY
305138,BLOCK,1,,<empty>,,,,1,,ANY
305143,BLOCK,1,,<empty>,,,,1,,ANY
305147,BLOCK,1,,<empty>,,,,1,,ANY
305152,BLOCK,1,,<empty>,,,,1,,ANY
305156,BLOCK,1,,<empty>,,,,1,,ANY
305161,BLOCK,1,,<empty>,,,,1,,ANY
305165,BLOCK,1,,<empty>,,,,1,,ANY
305171,BLOCK,1,,<empty>,,,,1,,ANY
305176,BLOCK,1,,<empty>,,,,1,,ANY
305182,BLOCK,1,,<empty>,,,,1,,ANY
305185,BLOCK,1,,<empty>,,,,1,,ANY
305189,BLOCK,1,,<empty>,,,,1,,ANY
305193,BLOCK,1,,<empty>,,,,1,,ANY
305198,BLOCK,1,,<empty>,,,,1,,ANY
305205,BLOCK,1,,<empty>,,,,1,,ANY
305209,BLOCK,1,,<empty>,,,,1,,ANY
305214,BLOCK,1,,<empty>,,,,1,,ANY
305218,BLOCK,1,,<empty>,,,,1,,ANY
305221,BLOCK,1,,<empty>,,,,1,,ANY
305225,BLOCK,1,,<empty>,,,,1,,ANY
305229,BLOCK,1,,<empty>,,,,1,,ANY
305234,BLOCK,1,,<empty>,,,,1,,ANY
305240,BLOCK,1,,<empty>,,,,1,,ANY
305246,BLOCK,1,,<empty>,,,,1,,ANY
305249,BLOCK,1,,<empty>,,,,1,,ANY
305255,BLOCK,1,,<empty>,,,,1,,ANY
305261,BLOCK,1,,<empty>,,,,1,,ANY
305266,BLOCK,1,,<empty>,,,,1,,ANY
305271,BLOCK,1,,<empty>,,,,1,,ANY
305276,BLOCK,1,,<empty>,,,,1,,ANY
305283,BLOCK,1,,<empty>,,,,1,,ANY
305288,BLOCK,1,,<empty>,,,,1,,ANY
305292,BLOCK,1,,<empty>,,,,1,,ANY
305296,BLOCK,1,,<empty>,,,,1,,ANY
305302,BLOCK,1,,<empty>,,,,1,,ANY
305306,BLOCK,1,,<empty>,,,,1,,ANY
305311,BLOCK,1,,<empty>,,,,1,,ANY
305318,BLOCK,1,,<empty>,,,,1,,ANY
305322,BLOCK,1,,<empty>,,,,1,,ANY
305326,BLOCK,1,,<empty>,,,,1,,ANY
305330,BLOCK,1,,<empty>,,,,1,,ANY
305334,BLOCK,1,,<empty>,,,,1,,ANY
305338,BLOCK,1,,<empty>,,,,1,,ANY
305342,BLOCK,1,,<empty>,,,,1,,ANY
305347,BLOCK,1,,<empty>,,,,1,,ANY
305350,BLOCK,1,,<empty>,,,,1,,ANY
305354,BLOCK,1,,<empty>,,,,1,,ANY
305358,BLOCK,1,,<empty>,,,,1,,ANY
305362,BLOCK,1,,<empty>,,,,1,,ANY
305366,BLOCK,1,,<empty>,,,,1,,ANY
305369,BLOCK,1,,<empty>,,,,1,,ANY
305372,BLOCK,1,,<empty>,,,,1,,ANY
305377,BLOCK,1,,<empty>,,,,1,,ANY
305382,BLOCK,1,,<empty>,,,,1,,ANY
305387,BLOCK,1,,<empty>,,,,1,,ANY
305392,BLOCK,1,,<empty>,,,,1,,ANY
305397,BLOCK,1,,<empty>,,,,1,,ANY
305402,BLOCK,1,,<empty>,,,,1,,ANY
305406,BLOCK,1,,<empty>,,,,1,,ANY
305413,BLOCK,1,,<empty>,,,,1,,ANY
305418,BLOCK,1,,<empty>,,,,1,,ANY
305422,BLOCK,1,,<empty>,,,,1,,ANY
305426,BLOCK,1,,<empty>,,,,1,,ANY
305432,BLOCK,1,,<empty>,,,,1,,ANY
305436,BLOCK,1,,<empty>,,,,1,,ANY
305440,BLOCK,1,,<empty>,,,,1,,ANY
305444,BLOCK,1,,<empty>,,,,1,,ANY
305448,BLOCK,1,,<empty>,,,,1,,ANY
305453,BLOCK,1,,<empty>,,,,1,,ANY
305458,BLOCK,1,,<empty>,,,,1,,ANY
305462,BLOCK,1,,<empty>,,,,1,,ANY
305470,BLOCK,1,,<empty>,,,,1,,ANY
305477,BLOCK,1,,<empty>,,,,1,,ANY
305481,BLOCK,1,,<empty>,,,,1,,ANY
305487,BLOCK,1,,<empty>,,,,1,,ANY
305491,BLOCK,1,,<empty>,,,,1,,ANY
305496,BLOCK,1,,<empty>,,,,1,,ANY
305500,BLOCK,1,,<empty>,,,,1,,ANY
305504,BLOCK,1,,<empty>,,,,1,,ANY
305509,BLOCK,1,,<empty>,,,,1,,ANY
305514,BLOCK,1,,<empty>,,,,1,,ANY
305520,BLOCK,1,,<empty>,,,,1,,ANY
305524,BLOCK,1,,<empty>,,,,1,,ANY
305528,BLOCK,1,,<empty>,,,,1,,ANY
305534,BLOCK,1,,<empty>,,,,1,,ANY
305540,BLOCK,1,,<empty>,,,,1,,ANY
305544,BLOCK,1,,<empty>,,,,1,,ANY
305548,BLOCK,1,,<empty>,,,,1,,ANY
305552,BLOCK,1,,<empty>,,,,1,,ANY
305557,BLOCK,1,,<empty>,,,,1,,ANY
305561,BLOCK,1,,<empty>,,,,1,,ANY
305565,BLOCK,1,,<empty>,,,,1,,ANY
305574,BLOCK,1,,<empty>,,,,1,,ANY
305580,BLOCK,1,,<empty>,,,,1,,ANY
305583,BLOCK,1,,<empty>,,,,1,,ANY
305587,BLOCK,1,,<empty>,,,,1,,ANY
305593,BLOCK,1,,<empty>,,,,1,,ANY
305597,BLOCK,1,,<empty>,,,,1,,ANY
305601,BLOCK,1,,<empty>,,,,1,,ANY
305606,BLOCK,1,,<empty>,,,,1,,ANY
305612,BLOCK,1,,<empty>,,,,1,,ANY
305619,BLOCK,1,,<empty>,,,,1,,ANY
305623,BLOCK,1,,<empty>,,,,1,,ANY
305626,BLOCK,1,,<empty>,,,,1,,ANY
305630,BLOCK,1,,<empty>,,,,1,,ANY
305634,BLOCK,1,,<empty>,,,,1,,ANY
305638,BLOCK,1,,<empty>,,,,1,,ANY
305642,BLOCK,1,,<empty>,,,,1,,ANY
305645,BLOCK,1,,<empty>,,,,1,,ANY
305649,BLOCK,1,,<empty>,,,,1,,ANY
305653,BLOCK,1,,<empty>,,,,1,,ANY
305657,BLOCK,1,,<empty>,,,,1,,ANY
305661,BLOCK,1,,<empty>,,,,1,,ANY
305665,BLOCK,1,,<empty>,,,,1,,ANY
305673,BLOCK,1,,<empty>,,,,1,,ANY
305677,BLOCK,1,,<empty>,,,,1,,ANY
305681,BLOCK,1,,<empty>,,,,1,,ANY
305687,BLOCK,1,,<empty>,,,,1,,ANY
305691,BLOCK,1,,<empty>,,,,1,,ANY
305695,BLOCK,1,,<empty>,,,,1,,ANY
305699,BLOCK,1,,<empty>,,,,1,,ANY
305703,BLOCK,1,,<empty>,,,,1,,ANY
305707,BLOCK,1,,<empty>,,,,1,,ANY
305711,BLOCK,1,,<empty>,,,,1,,ANY
305715,BLOCK,1,,<empty>,,,,1,,ANY
305719,BLOCK,1,,<empty>,,,,1,,ANY
305725,BLOCK,1,,<empty>,,,,1,,ANY
305729,BLOCK,1,,<empty>,,,,1,,ANY
305732,BLOCK,1,,<empty>,,,,1,,ANY
305737,BLOCK,1,,<empty>,,,,1,,ANY
305742,BLOCK,1,,<empty>,,,,1,,ANY
305747,BLOCK,1,,<empty>,,,,1,,ANY
305752,BLOCK,1,,<empty>,,,,1,,ANY
305757,BLOCK,1,,<empty>,,,,1,,ANY
305761,BLOCK,1,,<empty>,,,,1,,ANY
305764,BLOCK,1,,<empty>,,,,1,,ANY
305769,BLOCK,1,,<empty>,,,,1,,ANY
305773,BLOCK,1,,<empty>,,,,1,,ANY
305778,BLOCK,1,,<empty>,,,,1,,ANY
305783,BLOCK,1,,<empty>,,,,1,,ANY
305790,BLOCK,1,,<empty>,,,,1,,ANY
305795,BLOCK,1,,<empty>,,,,1,,ANY
305799,BLOCK,1,,<empty>,,,,1,,ANY
305806,BLOCK,1,,<empty>,,,,1,,ANY
305811,BLOCK,1,,<empty>,,,,1,,ANY
305815,BLOCK,1,,<empty>,,,,1,,ANY
305819,BLOCK,1,,<empty>,,,,1,,ANY
305823,BLOCK,1,,<empty>,,,,1,,ANY
305827,BLOCK,1,,<empty>,,,,1,,ANY
305831,BLOCK,1,,<empty>,,,,1,,ANY
305835,BLOCK,1,,<empty>,,,,1,,ANY
305839,BLOCK,1,,<empty>,,,,1,,ANY
305842,BLOCK,1,,<empty>,,,,1,,ANY
305848,BLOCK,1,,<empty>,,,,1,,ANY
305854,BLOCK,1,,<empty>,,,,1,,ANY
305860,BLOCK,1,,<empty>,,,,1,,ANY
305866,BLOCK,1,,<empty>,,,,1,,ANY
305872,BLOCK,1,,<empty>,,,,1,,ANY
305878,BLOCK,1,,<empty>,,,,1,,ANY
305884,BLOCK,1,,<empty>,,,,1,,ANY
305890,BLOCK,1,,<empty>,,,,1,,ANY
305896,BLOCK,1,,<empty>,,,,1,,ANY
305902,BLOCK,1,,<empty>,,,,1,,ANY
305908,BLOCK,1,,<empty>,,,,1,,ANY
305914,BLOCK,1,,<empty>,,,,1,,ANY
305920,BLOCK,1,,<empty>,,,,1,,ANY
305928,BLOCK,1,,<empty>,,,,1,,ANY
305936,BLOCK,1,,<empty>,,,,1,,ANY
305941,BLOCK,1,,<empty>,,,,1,,ANY
305946,BLOCK,1,,<empty>,,,,1,,ANY
305951,BLOCK,1,,<empty>,,,,1,,ANY
305956,BLOCK,1,,<empty>,,,,1,,ANY
305961,BLOCK,1,,<empty>,,,,1,,ANY
305966,BLOCK,1,,<empty>,,,,1,,ANY
305971,BLOCK,1,,<empty>,,,,1,,ANY
305976,BLOCK,1,,<empty>,,,,1,,ANY
305980,BLOCK,1,,<empty>,,,,1,,ANY
305984,BLOCK,1,,<empty>,,,,1,,ANY
305989,BLOCK,1,,<empty>,,,,1,,ANY
305993,BLOCK,1,,<empty>,,,,1,,ANY
305996,BLOCK,1,,<empty>,,,,1,,ANY
306000,BLOCK,1,,<empty>,,,,1,,ANY
306005,BLOCK,1,,<empty>,,,,1,,ANY
306008,BLOCK,1,,<empty>,,,,1,,ANY
306011,BLOCK,1,,<empty>,,,,1,,ANY
306016,BLOCK,1,,<empty>,,,,1,,ANY
306020,BLOCK,1,,<empty>,,,,1,,ANY
306024,BLOCK,1,,<empty>,,,,1,,ANY
306028,BLOCK,1,,<empty>,,,,1,,ANY
306032,BLOCK,1,,<empty>,,,,1,,ANY
306036,BLOCK,1,,<empty>,,,,1,,ANY
306039,BLOCK,1,,<empty>,,,,1,,ANY
306044,BLOCK,1,,<empty>,,,,1,,ANY
306048,BLOCK,1,,<empty>,,,,1,,ANY
306053,BLOCK,1,,<empty>,,,,1,,ANY
306058,BLOCK,1,,<empty>,,,,1,,ANY
306061,BLOCK,1,,<empty>,,,,1,,ANY
306067,BLOCK,1,,<empty>,,,,1,,ANY
306071,BLOCK,1,,<empty>,,,,1,,ANY
306075,BLOCK,1,,<empty>,,,,1,,ANY
306079,BLOCK,1,,<empty>,,,,1,,ANY
306083,BLOCK,1,,<empty>,,,,1,,ANY
306088,BLOCK,1,,<empty>,,,,1,,ANY
306092,BLOCK,1,,<empty>,,,,1,,ANY
306097,BLOCK,1,,<empty>,,,,1,,ANY
306101,BLOCK,1,,<empty>,,,,1,,ANY
306104,BLOCK,1,,<empty>,,,,1,,ANY
306107,BLOCK,1,,<empty>,,,,1,,ANY
306111,BLOCK,1,,<empty>,,,,1,,ANY
306114,BLOCK,1,,<empty>,,,,1,,ANY
306118,BLOCK,1,,<empty>,,,,1,,ANY
306125,BLOCK,1,,<empty>,,,,1,,ANY
306129,BLOCK,1,,<empty>,,,,1,,ANY
306133,BLOCK,1,,<empty>,,,,1,,ANY
306138,BLOCK,1,,<empty>,,,,1,,ANY
306143,BLOCK,1,,<empty>,,,,1,,ANY
306147,BLOCK,1,,<empty>,,,,1,,ANY
306150,BLOCK,1,,<empty>,,,,1,,ANY
306156,BLOCK,1,,<empty>,,,,1,,ANY
306160,BLOCK,1,,<empty>,,,,1,,ANY
306164,BLOCK,1,,<empty>,,,,1,,ANY
306168,BLOCK,1,,<empty>,,,,1,,ANY
306172,BLOCK,1,,<empty>,,,,1,,ANY
306178,BLOCK,1,,<empty>,,,,1,,ANY
306184,BLOCK,1,,<empty>,,,,1,,ANY
306190,BLOCK,1,,<empty>,,,,1,,ANY
306196,BLOCK,1,,<empty>,,,,1,,ANY
306199,BLOCK,1,,<empty>,,,,1,,ANY
306204,BLOCK,1,,<empty>,,,,1,,ANY
306208,BLOCK,1,,<empty>,,,,1,,ANY
306213,BLOCK,1,,<empty>,,,,1,,ANY
306220,BLOCK,1,,<empty>,,,,1,,ANY
306224,BLOCK,1,,<empty>,,,,1,,ANY
306230,BLOCK,1,,<empty>,,,,1,,ANY
306234,BLOCK,1,,<empty>,,,,1,,ANY
306242,BLOCK,1,,<empty>,,,,1,,ANY
306250,BLOCK,1,,<empty>,,,,1,,ANY
306256,BLOCK,1,,<empty>,,,,1,,ANY
306265,BLOCK,1,,<empty>,,,,1,,ANY
306269,BLOCK,1,,<empty>,,,,1,,ANY
306274,BLOCK,1,,<empty>,,,,1,,ANY
306280,BLOCK,1,,<empty>,,,,1,,ANY
306284,BLOCK,1,,<empty>,,,,1,,ANY
306288,BLOCK,1,,<empty>,,,,1,,ANY
306292,BLOCK,1,,<empty>,,,,1,,ANY
306296,BLOCK,1,,<empty>,,,,1,,ANY
306302,BLOCK,1,,<empty>,,,,1,,ANY
306306,BLOCK,1,,<empty>,,,,1,,ANY
306310,BLOCK,1,,<empty>,,,,1,,ANY
306316,BLOCK,1,,<empty>,,,,1,,ANY
306320,BLOCK,1,,<empty>,,,,1,,ANY
306324,BLOCK,1,,<empty>,,,,1,,ANY
306330,BLOCK,1,,<empty>,,,,1,,ANY
306335,BLOCK,1,,<empty>,,,,1,,ANY
306339,BLOCK,1,,<empty>,,,,1,,ANY
306343,BLOCK,1,,<empty>,,,,1,,ANY
306347,BLOCK,1,,<empty>,,,,1,,ANY
306353,BLOCK,1,,<empty>,,,,1,,ANY
306357,BLOCK,1,,<empty>,,,,1,,ANY
306361,BLOCK,1,,<empty>,,,,1,,ANY
306365,BLOCK,1,,<empty>,,,,1,,ANY
306369,BLOCK,1,,<empty>,,,,1,,ANY
306373,BLOCK,1,,<empty>,,,,1,,ANY
306377,BLOCK,1,,<empty>,,,,1,,ANY
306381,BLOCK,1,,<empty>,,,,1,,ANY
306385,BLOCK,1,,<empty>,,,,1,,ANY
306393,BLOCK,1,,<empty>,,,,1,,ANY
306397,BLOCK,1,,<empty>,,,,1,,ANY
306402,BLOCK,1,,<empty>,,,,1,,ANY
306406,BLOCK,1,,<empty>,,,,1,,ANY
306410,BLOCK,1,,<empty>,,,,1,,ANY
306414,BLOCK,1,,<empty>,,,,1,,ANY
306418,BLOCK,1,,<empty>,,,,1,,ANY
306422,BLOCK,1,,<empty>,,,,1,,ANY
306426,BLOCK,1,,<empty>,,,,1,,ANY
306430,BLOCK,1,,<empty>,,,,1,,ANY
306434,BLOCK,1,,<empty>,,,,1,,ANY
306438,BLOCK,1,,<empty>,,,,1,,ANY
306442,BLOCK,1,,<empty>,,,,1,,ANY
306446,BLOCK,1,,<empty>,,,,1,,ANY
306450,BLOCK,1,,<empty>,,,,1,,ANY
306453,BLOCK,1,,<empty>,,,,1,,ANY
306459,BLOCK,1,,<empty>,,,,1,,ANY
306463,BLOCK,1,,<empty>,,,,1,,ANY
306467,BLOCK,1,,<empty>,,,,1,,ANY
306473,BLOCK,1,,<empty>,,,,1,,ANY
306479,BLOCK,1,,<empty>,,,,1,,ANY
306483,BLOCK,1,,<empty>,,,,1,,ANY
306488,BLOCK,1,,<empty>,,,,1,,ANY
306492,BLOCK,1,,<empty>,,,,1,,ANY
306498,BLOCK,1,,<empty>,,,,1,,ANY
306501,BLOCK,1,,<empty>,,,,1,,ANY
306506,BLOCK,1,,<empty>,,,,1,,ANY
306510,BLOCK,1,,<empty>,,,,1,,ANY
306517,BLOCK,1,,<empty>,,,,1,,ANY
306522,BLOCK,1,,<empty>,,,,1,,ANY
306526,BLOCK,1,,<empty>,,,,1,,ANY
306533,BLOCK,1,,<empty>,,,,1,,ANY
306536,BLOCK,1,,<empty>,,,,1,,ANY
306544,BLOCK,1,,<empty>,,,,1,,ANY
306548,BLOCK,1,,<empty>,,,,1,,ANY
306552,BLOCK,1,,<empty>,,,,1,,ANY
306556,BLOCK,1,,<empty>,,,,1,,ANY
306560,BLOCK,1,,<empty>,,,,1,,ANY
306564,BLOCK,1,,<empty>,,,,1,,ANY
306568,BLOCK,1,,<empty>,,,,1,,ANY
306575,BLOCK,1,,<empty>,,,,1,,ANY
306579,BLOCK,1,,<empty>,,,,1,,ANY
306586,BLOCK,1,,<empty>,,,,1,,ANY
306593,BLOCK,1,,<empty>,,,,1,,ANY
306597,BLOCK,1,,<empty>,,,,1,,ANY
306604,BLOCK,1,,<empty>,,,,1,,ANY
306607,BLOCK,1,,<empty>,,,,1,,ANY
306614,BLOCK,1,,<empty>,,,,1,,ANY
306621,BLOCK,1,,<empty>,,,,1,,ANY
306626,BLOCK,1,,<empty>,,,,1,,ANY
306632,BLOCK,1,,<empty>,,,,1,,ANY
306638,BLOCK,1,,<empty>,,,,1,,ANY
306648,BLOCK,1,,<empty>,,,,1,,ANY
306653,BLOCK,1,,<empty>,,,,1,,ANY
306657,BLOCK,1,,<empty>,,,,1,,ANY
306666,BLOCK,1,,<empty>,,,,1,,ANY
306670,BLOCK,1,,<empty>,,,,1,,ANY
306674,BLOCK,1,,<empty>,,,,1,,ANY
306678,BLOCK,1,,<empty>,,,,1,,ANY
306683,BLOCK,1,,<empty>,,,,1,,ANY
306690,BLOCK,1,,<empty>,,,,1,,ANY
306694,BLOCK,1,,<empty>,,,,1,,ANY
306698,BLOCK,1,,<empty>,,,,1,,ANY
306702,BLOCK,1,,<empty>,,,,1,,ANY
306712,BLOCK,1,,<empty>,,,,1,,ANY
306716,BLOCK,1,,<empty>,,,,1,,ANY
306721,BLOCK,1,,<empty>,,,,1,,ANY
306725,BLOCK,1,,<empty>,,,,1,,ANY
306730,BLOCK,1,,<empty>,,,,1,,ANY
306735,BLOCK,1,,<empty>,,,,1,,ANY
306739,BLOCK,1,,<empty>,,,,1,,ANY
306749,BLOCK,1,,<empty>,,,,1,,ANY
306753,BLOCK,1,,<empty>,,,,1,,ANY
306759,BLOCK,1,,<empty>,,,,1,,ANY
306765,BLOCK,1,,<empty>,,,,1,,ANY
306769,BLOCK,1,,<empty>,,,,1,,ANY
306773,BLOCK,1,,<empty>,,,,1,,ANY
306777,BLOCK,1,,<empty>,,,,1,,ANY
306782,BLOCK,1,,<empty>,,,,1,,ANY
306786,BLOCK,1,,<empty>,,,,1,,ANY
306791,BLOCK,1,,<empty>,,,,1,,ANY
306796,BLOCK,1,,<empty>,,,,1,,ANY
306801,BLOCK,1,,<empty>,,,,1,,ANY
306806,BLOCK,1,,<empty>,,,,1,,ANY
306811,BLOCK,1,,<empty>,,,,1,,ANY
306816,BLOCK,1,,<empty>,,,,1,,ANY
306821,BLOCK,1,,<empty>,,,,1,,ANY
306826,BLOCK,1,,<empty>,,,,1,,ANY
306832,BLOCK,1,,<empty>,,,,1,,ANY
306836,BLOCK,1,,<empty>,,,,1,,ANY
306840,BLOCK,1,,<empty>,,,,1,,ANY
306844,BLOCK,1,,<empty>,,,,1,,ANY
306851,BLOCK,1,,<empty>,,,,1,,ANY
306854,BLOCK,1,,<empty>,,,,1,,ANY
306857,BLOCK,1,,<empty>,,,,1,,ANY
306862,BLOCK,1,,<empty>,,,,1,,ANY
306867,BLOCK,1,,<empty>,,,,1,,ANY
306874,BLOCK,1,,<empty>,,,,1,,ANY
306881,BLOCK,1,,<empty>,,,,1,,ANY
306886,BLOCK,1,,<empty>,,,,1,,ANY
306890,BLOCK,1,,<empty>,,,,1,,ANY
306897,BLOCK,1,,<empty>,,,,1,,ANY
306901,BLOCK,1,,<empty>,,,,1,,ANY
306906,BLOCK,1,,<empty>,,,,1,,ANY
306910,BLOCK,1,,<empty>,,,,1,,ANY
306917,BLOCK,1,,<empty>,,,,1,,ANY
306922,BLOCK,1,,<empty>,,,,1,,ANY
306926,BLOCK,1,,<empty>,,,,1,,ANY
306930,BLOCK,1,,<empty>,,,,1,,ANY
306934,BLOCK,1,,<empty>,,,,1,,ANY
306942,BLOCK,1,,<empty>,,,,1,,ANY
306946,BLOCK,1,,<empty>,,,,1,,ANY
306950,BLOCK,1,,<empty>,,,,1,,ANY
306954,BLOCK,1,,<empty>,,,,1,,ANY
306957,BLOCK,1,,<empty>,,,,1,,ANY
306961,BLOCK,1,,<empty>,,,,1,,ANY
306966,BLOCK,1,,<empty>,,,,1,,ANY
306975,BLOCK,1,,<empty>,,,,1,,ANY
306982,BLOCK,1,,<empty>,,,,1,,ANY
306987,BLOCK,1,,<empty>,,,,1,,ANY
306991,BLOCK,1,,<empty>,,,,1,,ANY
306995,BLOCK,1,,<empty>,,,,1,,ANY
306999,BLOCK,1,,<empty>,,,,1,,ANY
307003,BLOCK,1,,<empty>,,,,1,,ANY
307007,BLOCK,1,,<empty>,,,,1,,ANY
307015,BLOCK,1,,<empty>,,,,1,,ANY
307020,BLOCK,1,,<empty>,,,,1,,ANY
307025,BLOCK,1,,<empty>,,,,1,,ANY
307031,BLOCK,1,,<empty>,,,,1,,ANY
307036,BLOCK,1,,<empty>,,,,1,,ANY
307041,BLOCK,1,,<empty>,,,,1,,ANY
307045,BLOCK,1,,<empty>,,,,1,,ANY
307051,BLOCK,1,,<empty>,,,,1,,ANY
307056,BLOCK,1,,<empty>,,,,1,,ANY
307061,BLOCK,1,,<empty>,,,,1,,ANY
307066,BLOCK,1,,<empty>,,,,1,,ANY
307070,BLOCK,1,,<empty>,,,,1,,ANY
307075,BLOCK,1,,<empty>,,,,1,,ANY
307079,BLOCK,1,,<empty>,,,,1,,ANY
307083,BLOCK,1,,<empty>,,,,1,,ANY
307086,BLOCK,1,,<empty>,,,,1,,ANY
307092,BLOCK,1,,<empty>,,,,1,,ANY
307095,BLOCK,1,,<empty>,,,,1,,ANY
307099,BLOCK,1,,<empty>,,,,1,,ANY
307103,BLOCK,1,,<empty>,,,,1,,ANY
307108,BLOCK,1,,<empty>,,,,1,,ANY
307113,BLOCK,1,,<empty>,,,,1,,ANY
307117,BLOCK,1,,<empty>,,,,1,,ANY
307123,BLOCK,1,,<empty>,,,,1,,ANY
307128,BLOCK,1,,<empty>,,,,1,,ANY
307137,BLOCK,1,,<empty>,,,,1,,ANY
307141,BLOCK,1,,<empty>,,,,1,,ANY
307147,BLOCK,1,,<empty>,,,,1,,ANY
307151,BLOCK,1,,<empty>,,,,1,,ANY
307155,BLOCK,1,,<empty>,,,,1,,ANY
307159,BLOCK,1,,<empty>,,,,1,,ANY
307164,BLOCK,1,,<empty>,,,,1,,ANY
307168,BLOCK,1,,<empty>,,,,1,,ANY
307172,BLOCK,1,,<empty>,,,,1,,ANY
307176,BLOCK,1,,<empty>,,,,1,,ANY
307180,BLOCK,1,,<empty>,,,,1,,ANY
307184,BLOCK,1,,<empty>,,,,1,,ANY
307188,BLOCK,1,,<empty>,,,,1,,ANY
307192,BLOCK,1,,<empty>,,,,1,,ANY
307196,BLOCK,1,,<empty>,,,,1,,ANY
307200,BLOCK,1,,<empty>,,,,1,,ANY
307204,BLOCK,1,,<empty>,,,,1,,ANY
307210,BLOCK,1,,<empty>,,,,1,,ANY
307217,BLOCK,1,,<empty>,,,,1,,ANY
307223,BLOCK,1,,<empty>,,,,1,,ANY
307227,BLOCK,1,,<empty>,,,,1,,ANY
307235,BLOCK,1,,<empty>,,,,1,,ANY
307242,BLOCK,1,,<empty>,,,,1,,ANY
307246,BLOCK,1,,<empty>,,,,1,,ANY
307250,BLOCK,1,,<empty>,,,,1,,ANY
307254,BLOCK,1,,<empty>,,,,1,,ANY
307258,BLOCK,1,,<empty>,,,,1,,ANY
307264,BLOCK,1,,<empty>,,,,1,,ANY
307269,BLOCK,1,,<empty>,,,,1,,ANY
307274,BLOCK,1,,<empty>,,,,1,,ANY
307279,BLOCK,1,,<empty>,,,,1,,ANY
307284,BLOCK,1,,<empty>,,,,1,,ANY
307289,BLOCK,1,,<empty>,,,,1,,ANY
307294,BLOCK,1,,<empty>,,,,1,,ANY
307299,BLOCK,1,,<empty>,,,,1,,ANY
307304,BLOCK,1,,<empty>,,,,1,,ANY
307309,BLOCK,1,,<empty>,,,,1,,ANY
307314,BLOCK,1,,<empty>,,,,1,,ANY
307319,BLOCK,1,,<empty>,,,,1,,ANY
307325,BLOCK,1,,<empty>,,,,1,,ANY
307330,BLOCK,1,,<empty>,,,,1,,ANY
307333,BLOCK,1,,<empty>,,,,1,,ANY
307338,BLOCK,1,,<empty>,,,,1,,ANY
307343,BLOCK,1,,<empty>,,,,1,,ANY
307347,BLOCK,1,,<empty>,,,,1,,ANY
307351,BLOCK,1,,<empty>,,,,1,,ANY
307355,BLOCK,1,,<empty>,,,,1,,ANY
307359,BLOCK,1,,<empty>,,,,1,,ANY
307363,BLOCK,1,,<empty>,,,,1,,ANY
307368,BLOCK,1,,<empty>,,,,1,,ANY
307372,BLOCK,1,,<empty>,,,,1,,ANY
307376,BLOCK,1,,<empty>,,,,1,,ANY
307385,BLOCK,1,,<empty>,,,,1,,ANY
307391,BLOCK,1,,<empty>,,,,1,,ANY
307395,BLOCK,1,,<empty>,,,,1,,ANY
307400,BLOCK,1,,<empty>,,,,1,,ANY
307405,BLOCK,1,,<empty>,,,,1,,ANY
307411,BLOCK,1,,<empty>,,,,1,,ANY
307416,BLOCK,1,,<empty>,,,,1,,ANY
307419,BLOCK,1,,<empty>,,,,1,,ANY
307422,BLOCK,1,,<empty>,,,,1,,ANY
307426,BLOCK,1,,<empty>,,,,1,,ANY
307431,BLOCK,1,,<empty>,,,,1,,ANY
307437,BLOCK,1,,<empty>,,,,1,,ANY
307442,BLOCK,1,,<empty>,,,,1,,ANY
307445,BLOCK,1,,<empty>,,,,1,,ANY
307451,BLOCK,1,,<empty>,,,,1,,ANY
307459,BLOCK,1,,<empty>,,,,1,,ANY
307463,BLOCK,1,,<empty>,,,,1,,ANY
307467,BLOCK,1,,<empty>,,,,1,,ANY
307471,BLOCK,1,,<empty>,,,,1,,ANY
307475,BLOCK,1,,<empty>,,,,1,,ANY
307479,BLOCK,1,,<empty>,,,,1,,ANY
307483,BLOCK,1,,<empty>,,,,1,,ANY
307487,BLOCK,1,,<empty>,,,,1,,ANY
307491,BLOCK,1,,<empty>,,,,1,,ANY
307497,BLOCK,1,,<empty>,,,,1,,ANY
307501,BLOCK,1,,<empty>,,,,1,,ANY
307505,BLOCK,1,,<empty>,,,,1,,ANY
307509,BLOCK,1,,<empty>,,,,1,,ANY
307513,BLOCK,1,,<empty>,,,,1,,ANY
307517,BLOCK,1,,<empty>,,,,1,,ANY
307521,BLOCK,1,,<empty>,,,,1,,ANY
307526,BLOCK,1,,<empty>,,,,1,,ANY
307530,BLOCK,1,,<empty>,,,,1,,ANY
307535,BLOCK,1,,<empty>,,,,1,,ANY
307539,BLOCK,1,,<empty>,,,,1,,ANY
307544,BLOCK,1,,<empty>,,,,1,,ANY
307552,BLOCK,1,,<empty>,,,,1,,ANY
307560,BLOCK,1,,<empty>,,,,1,,ANY
307566,BLOCK,1,,<empty>,,,,1,,ANY
307570,BLOCK,1,,<empty>,,,,1,,ANY
307573,BLOCK,1,,<empty>,,,,1,,ANY
307577,BLOCK,1,,<empty>,,,,1,,ANY
307588,BLOCK,1,,<empty>,,,,1,,ANY
307591,BLOCK,1,,<empty>,,,,1,,ANY
307596,BLOCK,1,,<empty>,,,,1,,ANY
307606,BLOCK,1,,<empty>,,,,1,,ANY
307611,BLOCK,1,,<empty>,,,,1,,ANY
307615,BLOCK,1,,<empty>,,,,1,,ANY
307622,BLOCK,1,,<empty>,,,,1,,ANY
307628,BLOCK,1,,<empty>,,,,1,,ANY
307632,BLOCK,1,,<empty>,,,,1,,ANY
307636,BLOCK,1,,<empty>,,,,1,,ANY
307644,BLOCK,1,,<empty>,,,,1,,ANY
307648,BLOCK,1,,<empty>,,,,1,,ANY
307652,BLOCK,1,,<empty>,,,,1,,ANY
307658,BLOCK,1,,<empty>,,,,1,,ANY
307662,BLOCK,1,,<empty>,,,,1,,ANY
307669,BLOCK,1,,<empty>,,,,1,,ANY
307673,BLOCK,1,,<empty>,,,,1,,ANY
307677,BLOCK,1,,<empty>,,,,1,,ANY
307683,BLOCK,1,,<empty>,,,,1,,ANY
307688,BLOCK,1,,<empty>,,,,1,,ANY
307692,BLOCK,1,,<empty>,,,,1,,ANY
307695,BLOCK,1,,<empty>,,,,1,,ANY
307701,BLOCK,1,,<empty>,,,,1,,ANY
307705,BLOCK,1,,<empty>,,,,1,,ANY
307711,BLOCK,1,,<empty>,,,,1,,ANY
307715,BLOCK,1,,<empty>,,,,1,,ANY
307722,BLOCK,1,,<empty>,,,,1,,ANY
307727,BLOCK,1,,<empty>,,,,1,,ANY
307732,BLOCK,1,,<empty>,,,,1,,ANY
307737,BLOCK,1,,<empty>,,,,1,,ANY
307742,BLOCK,1,,<empty>,,,,1,,ANY
307747,BLOCK,1,,<empty>,,,,1,,ANY
307751,BLOCK,1,,<empty>,,,,1,,ANY
307756,BLOCK,1,,<empty>,,,,1,,ANY
307761,BLOCK,1,,<empty>,,,,1,,ANY
307766,BLOCK,1,,<empty>,,,,1,,ANY
307774,BLOCK,1,,<empty>,,,,1,,ANY
307780,BLOCK,1,,<empty>,,,,1,,ANY
307785,BLOCK,1,,<empty>,,,,1,,ANY
307789,BLOCK,1,,<empty>,,,,1,,ANY
307793,BLOCK,1,,<empty>,,,,1,,ANY
307797,BLOCK,1,,<empty>,,,,1,,ANY
307807,BLOCK,1,,<empty>,,,,1,,ANY
307812,BLOCK,1,,<empty>,,,,1,,ANY
307817,BLOCK,1,,<empty>,,,,1,,ANY
307821,BLOCK,1,,<empty>,,,,1,,ANY
307826,BLOCK,1,,<empty>,,,,1,,ANY
307831,BLOCK,1,,<empty>,,,,1,,ANY
307837,BLOCK,1,,<empty>,,,,1,,ANY
307841,BLOCK,1,,<empty>,,,,1,,ANY
307845,BLOCK,1,,<empty>,,,,1,,ANY
307849,BLOCK,1,,<empty>,,,,1,,ANY
307852,BLOCK,1,,<empty>,,,,1,,ANY
307859,BLOCK,1,,<empty>,,,,1,,ANY
307865,BLOCK,1,,<empty>,,,,1,,ANY
307869,BLOCK,1,,<empty>,,,,1,,ANY
307873,BLOCK,1,,<empty>,,,,1,,ANY
307879,BLOCK,1,,<empty>,,,,1,,ANY
307885,BLOCK,1,,<empty>,,,,1,,ANY
307890,BLOCK,1,,<empty>,,,,1,,ANY
307894,BLOCK,1,,<empty>,,,,1,,ANY
307899,BLOCK,1,,<empty>,,,,1,,ANY
307904,BLOCK,1,,<empty>,,,,1,,ANY
307908,BLOCK,1,,<empty>,,,,1,,ANY
307914,BLOCK,1,,<empty>,,,,1,,ANY
307918,BLOCK,1,,<empty>,,,,1,,ANY
307922,BLOCK,1,,<empty>,,,,1,,ANY
307926,BLOCK,1,,<empty>,,,,1,,ANY
307930,BLOCK,1,,<empty>,,,,1,,ANY
307934,BLOCK,1,,<empty>,,,,1,,ANY
307938,BLOCK,1,,<empty>,,,,1,,ANY
307942,BLOCK,1,,<empty>,,,,1,,ANY
307946,BLOCK,1,,<empty>,,,,1,,ANY
307950,BLOCK,1,,<empty>,,,,1,,ANY
307954,BLOCK,1,,<empty>,,,,1,,ANY
307959,BLOCK,1,,<empty>,,,,1,,ANY
307964,BLOCK,1,,<empty>,,,,1,,ANY
307969,BLOCK,1,,<empty>,,,,1,,ANY
307974,BLOCK,1,,<empty>,,,,1,,ANY
307981,BLOCK,1,,<empty>,,,,1,,ANY
307986,BLOCK,1,,<empty>,,,,1,,ANY
307991,BLOCK,1,,<empty>,,,,1,,ANY
307994,BLOCK,1,,<empty>,,,,1,,ANY
307998,BLOCK,1,,<empty>,,,,1,,ANY
308002,BLOCK,1,,<empty>,,,,1,,ANY
308006,BLOCK,1,,<empty>,,,,1,,ANY
308011,BLOCK,1,,<empty>,,,,1,,ANY
308016,BLOCK,1,,<empty>,,,,1,,ANY
308020,BLOCK,1,,<empty>,,,,1,,ANY
308024,BLOCK,1,,<empty>,,,,1,,ANY
308029,BLOCK,1,,<empty>,,,,1,,ANY
308033,BLOCK,1,,<empty>,,,,1,,ANY
308038,BLOCK,1,,<empty>,,,,1,,ANY
308043,BLOCK,1,,<empty>,,,,1,,ANY
308050,BLOCK,1,,<empty>,,,,1,,ANY
308054,BLOCK,1,,<empty>,,,,1,,ANY
308059,BLOCK,1,,<empty>,,,,1,,ANY
308064,BLOCK,1,,<empty>,,,,1,,ANY
308068,BLOCK,1,,<empty>,,,,1,,ANY
308072,BLOCK,1,,<empty>,,,,1,,ANY
308080,BLOCK,1,,<empty>,,,,1,,ANY
308084,BLOCK,1,,<empty>,,,,1,,ANY
308088,BLOCK,1,,<empty>,,,,1,,ANY
308093,BLOCK,1,,<empty>,,,,1,,ANY
308097,BLOCK,1,,<empty>,,,,1,,ANY
308102,BLOCK,1,,<empty>,,,,1,,ANY
308107,BLOCK,1,,<empty>,,,,1,,ANY
308111,BLOCK,1,,<empty>,,,,1,,ANY
308115,BLOCK,1,,<empty>,,,,1,,ANY
308120,BLOCK,1,,<empty>,,,,1,,ANY
308124,BLOCK,1,,<empty>,,,,1,,ANY
308130,BLOCK,1,,<empty>,,,,1,,ANY
308134,BLOCK,1,,<empty>,,,,1,,ANY
308138,BLOCK,1,,<empty>,,,,1,,ANY
308145,BLOCK,1,,<empty>,,,,1,,ANY
308150,BLOCK,1,,<empty>,,,,1,,ANY
308155,BLOCK,1,,<empty>,,,,1,,ANY
308160,BLOCK,1,,<empty>,,,,1,,ANY
308167,BLOCK,1,,<empty>,,,,1,,ANY
308173,BLOCK,1,,<empty>,,,,1,,ANY
308178,BLOCK,1,,<empty>,,,,1,,ANY
308182,BLOCK,1,,<empty>,,,,1,,ANY
308186,BLOCK,1,,<empty>,,,,1,,ANY
308192,BLOCK,1,,<empty>,,,,1,,ANY
308198,BLOCK,1,,<empty>,,,,1,,ANY
308206,BLOCK,1,,<empty>,,,,1,,ANY
308212,BLOCK,1,,<empty>,,,,1,,ANY
308219,BLOCK,1,,<empty>,,,,1,,ANY
308224,BLOCK,1,,<empty>,,,,1,,ANY
308230,BLOCK,1,,<empty>,,,,1,,ANY
308234,BLOCK,1,,<empty>,,,,1,,ANY
308238,BLOCK,1,,<empty>,,,,1,,ANY
308242,BLOCK,1,,<empty>,,,,1,,ANY
308246,BLOCK,1,,<empty>,,,,1,,ANY
308251,BLOCK,1,,<empty>,,,,1,,ANY
308256,BLOCK,1,,<empty>,,,,1,,ANY
308261,BLOCK,1,,<empty>,,,,1,,ANY
308265,BLOCK,1,,<empty>,,,,1,,ANY
308270,BLOCK,1,,<empty>,,,,1,,ANY
308276,BLOCK,1,,<empty>,,,,1,,ANY
308281,BLOCK,1,,<empty>,,,,1,,ANY
308287,BLOCK,1,,<empty>,,,,1,,ANY
308292,BLOCK,1,,<empty>,,,,1,,ANY
308297,BLOCK,1,,<empty>,,,,1,,ANY
308302,BLOCK,1,,<empty>,,,,1,,ANY
308307,BLOCK,1,,<empty>,,,,1,,ANY
308311,BLOCK,1,,<empty>,,,,1,,ANY
308315,BLOCK,1,,<empty>,,,,1,,ANY
308319,BLOCK,1,,<empty>,,,,1,,ANY
308323,BLOCK,1,,<empty>,,,,1,,ANY
308328,BLOCK,1,,<empty>,,,,1,,ANY
308332,BLOCK,1,,<empty>,,,,1,,ANY
308336,BLOCK,1,,<empty>,,,,1,,ANY
308340,BLOCK,1,,<empty>,,,,1,,ANY
308345,BLOCK,1,,<empty>,,,,1,,ANY
308351,BLOCK,1,,<empty>,,,,1,,ANY
308356,BLOCK,1,,<empty>,,,,1,,ANY
308361,BLOCK,1,,<empty>,,,,1,,ANY
308366,BLOCK,1,,<empty>,,,,1,,ANY
308370,BLOCK,1,,<empty>,,,,1,,ANY
308375,BLOCK,1,,<empty>,,,,1,,ANY
308379,BLOCK,1,,<empty>,,,,1,,ANY
308382,BLOCK,1,,<empty>,,,,1,,ANY
308389,BLOCK,1,,<empty>,,,,1,,ANY
308394,BLOCK,1,,<empty>,,,,1,,ANY
308399,BLOCK,1,,<empty>,,,,1,,ANY
308404,BLOCK,1,,<empty>,,,,1,,ANY
308408,BLOCK,1,,<empty>,,,,1,,ANY
308413,BLOCK,1,,<empty>,,,,1,,ANY
308418,BLOCK,1,,<empty>,,,,1,,ANY
308422,BLOCK,1,,<empty>,,,,1,,ANY
308426,BLOCK,1,,<empty>,,,,1,,ANY
308433,BLOCK,1,,<empty>,,,,1,,ANY
308437,BLOCK,1,,<empty>,,,,1,,ANY
308444,BLOCK,1,,<empty>,,,,1,,ANY
308448,BLOCK,1,,<empty>,,,,1,,ANY
308452,BLOCK,1,,<empty>,,,,1,,ANY
308456,BLOCK,1,,<empty>,,,,1,,ANY
308460,BLOCK,1,,<empty>,,,,1,,ANY
308464,BLOCK,1,,<empty>,,,,1,,ANY
308468,BLOCK,1,,<empty>,,,,1,,ANY
308477,BLOCK,1,,<empty>,,,,1,,ANY
308481,BLOCK,1,,<empty>,,,,1,,ANY
308485,BLOCK,1,,<empty>,,,,1,,ANY
308490,BLOCK,1,,<empty>,,,,1,,ANY
308494,BLOCK,1,,<empty>,,,,1,,ANY
308501,BLOCK,1,,<empty>,,,,1,,ANY
308508,BLOCK,1,,<empty>,,,,1,,ANY
308512,BLOCK,1,,<empty>,,,,1,,ANY
308516,BLOCK,1,,<empty>,,,,1,,ANY
308520,BLOCK,1,,<empty>,,,,1,,ANY
308525,BLOCK,1,,<empty>,,,,1,,ANY
308529,BLOCK,1,,<empty>,,,,1,,ANY
308534,BLOCK,1,,<empty>,,,,1,,ANY
308538,BLOCK,1,,<empty>,,,,1,,ANY
308544,BLOCK,1,,<empty>,,,,1,,ANY
308548,BLOCK,1,,<empty>,,,,1,,ANY
308554,BLOCK,1,,<empty>,,,,1,,ANY
308561,BLOCK,1,,<empty>,,,,1,,ANY
308565,BLOCK,1,,<empty>,,,,1,,ANY
308569,BLOCK,1,,<empty>,,,,1,,ANY
308573,BLOCK,1,,<empty>,,,,1,,ANY
308577,BLOCK,1,,<empty>,,,,1,,ANY
308584,BLOCK,1,,<empty>,,,,1,,ANY
308588,BLOCK,1,,<empty>,,,,1,,ANY
308594,BLOCK,1,,<empty>,,,,1,,ANY
308598,BLOCK,1,,<empty>,,,,1,,ANY
308603,BLOCK,1,,<empty>,,,,1,,ANY
308607,BLOCK,1,,<empty>,,,,1,,ANY
308613,BLOCK,1,,<empty>,,,,1,,ANY
308617,BLOCK,1,,<empty>,,,,1,,ANY
308622,BLOCK,1,,<empty>,,,,1,,ANY
308628,BLOCK,1,,<empty>,,,,1,,ANY
308634,BLOCK,1,,<empty>,,,,1,,ANY
308638,BLOCK,1,,<empty>,,,,1,,ANY
308643,BLOCK,1,,<empty>,,,,1,,ANY
308647,BLOCK,1,,<empty>,,,,1,,ANY
308652,BLOCK,1,,<empty>,,,,1,,ANY
308656,BLOCK,1,,<empty>,,,,1,,ANY
308662,BLOCK,1,,<empty>,,,,1,,ANY
308666,BLOCK,1,,<empty>,,,,1,,ANY
308672,BLOCK,1,,<empty>,,,,1,,ANY
308676,BLOCK,1,,<empty>,,,,1,,ANY
308682,BLOCK,1,,<empty>,,,,1,,ANY
308685,BLOCK,1,,<empty>,,,,1,,ANY
308689,BLOCK,1,,<empty>,,,,1,,ANY
308692,BLOCK,1,,<empty>,,,,1,,ANY
308696,BLOCK,1,,<empty>,,,,1,,ANY
308699,BLOCK,1,,<empty>,,,,1,,ANY
308703,BLOCK,1,,<empty>,,,,1,,ANY
308708,BLOCK,1,,<empty>,,,,1,,ANY
308712,BLOCK,1,,<empty>,,,,1,,ANY
308717,BLOCK,1,,<empty>,,,,1,,ANY
308721,BLOCK,1,,<empty>,,,,1,,ANY
308726,BLOCK,1,,<empty>,,,,1,,ANY
308729,BLOCK,1,,<empty>,,,,1,,ANY
308734,BLOCK,1,,<empty>,,,,1,,ANY
308740,BLOCK,1,,<empty>,,,,1,,ANY
308744,BLOCK,1,,<empty>,,,,1,,ANY
308748,BLOCK,1,,<empty>,,,,1,,ANY
308751,BLOCK,1,,<empty>,,,,1,,ANY
308755,BLOCK,1,,<empty>,,,,1,,ANY
308762,BLOCK,1,,<empty>,,,,1,,ANY
308766,BLOCK,1,,<empty>,,,,1,,ANY
308769,BLOCK,1,,<empty>,,,,1,,ANY
308774,BLOCK,1,,<empty>,,,,1,,ANY
308777,BLOCK,1,,<empty>,,,,1,,ANY
308781,BLOCK,1,,<empty>,,,,1,,ANY
308785,BLOCK,1,,<empty>,,,,1,,ANY
308793,BLOCK,1,,<empty>,,,,1,,ANY
308800,BLOCK,1,,<empty>,,,,1,,ANY
308803,BLOCK,1,,<empty>,,,,1,,ANY
308806,BLOCK,1,,<empty>,,,,1,,ANY
308812,BLOCK,1,,<empty>,,,,1,,ANY
308815,BLOCK,1,,<empty>,,,,1,,ANY
308819,BLOCK,1,,<empty>,,,,1,,ANY
308823,BLOCK,1,,<empty>,,,,1,,ANY
308827,BLOCK,1,,<empty>,,,,1,,ANY
308832,BLOCK,1,,<empty>,,,,1,,ANY
308840,BLOCK,1,,<empty>,,,,1,,ANY
308845,BLOCK,1,,<empty>,,,,1,,ANY
308849,BLOCK,1,,<empty>,,,,1,,ANY
308853,BLOCK,1,,<empty>,,,,1,,ANY
308858,BLOCK,1,,<empty>,,,,1,,ANY
308864,BLOCK,1,,<empty>,,,,1,,ANY
308870,BLOCK,1,,<empty>,,,,1,,ANY
308876,BLOCK,1,,<empty>,,,,1,,ANY
308882,BLOCK,1,,<empty>,,,,1,,ANY
308888,BLOCK,1,,<empty>,,,,1,,ANY
308896,BLOCK,1,,<empty>,,,,1,,ANY
308902,BLOCK,1,,<empty>,,,,1,,ANY
308910,BLOCK,1,,<empty>,,,,1,,ANY
308914,BLOCK,1,,<empty>,,,,1,,ANY
308917,BLOCK,1,,<empty>,,,,1,,ANY
308922,BLOCK,1,,<empty>,,,,1,,ANY
308927,BLOCK,1,,<empty>,,,,1,,ANY
308932,BLOCK,1,,<empty>,,,,1,,ANY
308935,BLOCK,1,,<empty>,,,,1,,ANY
308940,BLOCK,1,,<empty>,,,,1,,ANY
308946,BLOCK,1,,<empty>,,,,1,,ANY
308949,BLOCK,1,,<empty>,,,,1,,ANY
308952,BLOCK,1,,<empty>,,,,1,,ANY
308956,BLOCK,1,,<empty>,,,,1,,ANY
308961,BLOCK,1,,<empty>,,,,1,,ANY
308966,BLOCK,1,,<empty>,,,,1,,ANY
308971,BLOCK,1,,<empty>,,,,1,,ANY
308976,BLOCK,1,,<empty>,,,,1,,ANY
308981,BLOCK,1,,<empty>,,,,1,,ANY
308986,BLOCK,1,,<empty>,,,,1,,ANY
308990,BLOCK,1,,<empty>,,,,1,,ANY
308995,BLOCK,1,,<empty>,,,,1,,ANY
308999,BLOCK,1,,<empty>,,,,1,,ANY
309004,BLOCK,1,,<empty>,,,,1,,ANY
309008,BLOCK,1,,<empty>,,,,1,,ANY
309013,BLOCK,1,,<empty>,,,,1,,ANY
309018,BLOCK,1,,<empty>,,,,1,,ANY
309023,BLOCK,1,,<empty>,,,,1,,ANY
309028,BLOCK,1,,<empty>,,,,1,,ANY
309032,BLOCK,1,,<empty>,,,,1,,ANY
309037,BLOCK,1,,<empty>,,,,1,,ANY
309041,BLOCK,1,,<empty>,,,,1,,ANY
309045,BLOCK,1,,<empty>,,,,1,,ANY
309050,BLOCK,1,,<empty>,,,,1,,ANY
309056,BLOCK,1,,<empty>,,,,1,,ANY
309063,BLOCK,1,,<empty>,,,,1,,ANY
309068,BLOCK,1,,<empty>,,,,1,,ANY
309073,BLOCK,1,,<empty>,,,,1,,ANY
309078,BLOCK,1,,<empty>,,,,1,,ANY
309083,BLOCK,1,,<empty>,,,,1,,ANY
309089,BLOCK,1,,<empty>,,,,1,,ANY
309094,BLOCK,1,,<empty>,,,,1,,ANY
309098,BLOCK,1,,<empty>,,,,1,,ANY
309103,BLOCK,1,,<empty>,,,,1,,ANY
309110,BLOCK,1,,<empty>,,,,1,,ANY
309116,BLOCK,1,,<empty>,,,,1,,ANY
309119,BLOCK,1,,<empty>,,,,1,,ANY
309124,BLOCK,1,,<empty>,,,,1,,ANY
309129,BLOCK,1,,<empty>,,,,1,,ANY
309134,BLOCK,1,,<empty>,,,,1,,ANY
309138,BLOCK,1,,<empty>,,,,1,,ANY
309145,BLOCK,1,,<empty>,,,,1,,ANY
309150,BLOCK,1,,<empty>,,,,1,,ANY
309155,BLOCK,1,,<empty>,,,,1,,ANY
309161,BLOCK,1,,<empty>,,,,1,,ANY
309165,BLOCK,1,,<empty>,,,,1,,ANY
309169,BLOCK,1,,<empty>,,,,1,,ANY
309174,BLOCK,1,,<empty>,,,,1,,ANY
309179,BLOCK,1,,<empty>,,,,1,,ANY
309184,BLOCK,1,,<empty>,,,,1,,ANY
309189,BLOCK,1,,<empty>,,,,1,,ANY
309194,BLOCK,1,,<empty>,,,,1,,ANY
309201,BLOCK,1,,<empty>,,,,1,,ANY
309208,BLOCK,1,,<empty>,,,,1,,ANY
309213,BLOCK,1,,<empty>,,,,1,,ANY
309217,BLOCK,1,,<empty>,,,,1,,ANY
309221,BLOCK,1,,<empty>,,,,1,,ANY
309226,BLOCK,1,,<empty>,,,,1,,ANY
309231,BLOCK,1,,<empty>,,,,1,,ANY
309237,BLOCK,1,,<empty>,,,,1,,ANY
309241,BLOCK,1,,<empty>,,,,1,,ANY
309246,BLOCK,1,,<empty>,,,,1,,ANY
309251,BLOCK,1,,<empty>,,,,1,,ANY
309255,BLOCK,1,,<empty>,,,,1,,ANY
309261,BLOCK,1,,<empty>,,,,1,,ANY
309266,BLOCK,1,,<empty>,,,,1,,ANY
309272,BLOCK,1,,<empty>,,,,1,,ANY
309277,BLOCK,1,,<empty>,,,,1,,ANY
309285,BLOCK,1,,<empty>,,,,1,,ANY
309289,BLOCK,1,,<empty>,,,,1,,ANY
309294,BLOCK,1,,<empty>,,,,1,,ANY
309299,BLOCK,1,,<empty>,,,,1,,ANY
309303,BLOCK,1,,<empty>,,,,1,,ANY
309307,BLOCK,1,,<empty>,,,,1,,ANY
309312,BLOCK,1,,<empty>,,,,1,,ANY
309316,BLOCK,1,,<empty>,,,,1,,ANY
309324,BLOCK,1,,<empty>,,,,1,,ANY
309328,BLOCK,1,,<empty>,,,,1,,ANY
309336,BLOCK,1,,<empty>,,,,1,,ANY
309339,BLOCK,1,,<empty>,,,,1,,ANY
309347,BLOCK,1,,<empty>,,,,1,,ANY
309353,BLOCK,1,,<empty>,,,,1,,ANY
309359,BLOCK,1,,<empty>,,,,1,,ANY
309363,BLOCK,1,,<empty>,,,,1,,ANY
309368,BLOCK,1,,<empty>,,,,1,,ANY
309371,BLOCK,1,,<empty>,,,,1,,ANY
309376,BLOCK,1,,<empty>,,,,1,,ANY
309382,BLOCK,1,,<empty>,,,,1,,ANY
309389,BLOCK,1,,<empty>,,,,1,,ANY
309393,BLOCK,1,,<empty>,,,,1,,ANY
309399,BLOCK,1,,<empty>,,,,1,,ANY
309405,BLOCK,1,,<empty>,,,,1,,ANY
309410,BLOCK,1,,<empty>,,,,1,,ANY
309416,BLOCK,1,,<empty>,,,,1,,ANY
309421,BLOCK,1,,<empty>,,,,1,,ANY
309427,BLOCK,1,,<empty>,,,,1,,ANY
309433,BLOCK,1,,<empty>,,,,1,,ANY
309439,BLOCK,1,,<empty>,,,,1,,ANY
309444,BLOCK,1,,<empty>,,,,1,,ANY
309449,BLOCK,1,,<empty>,,,,1,,ANY
309454,BLOCK,1,,<empty>,,,,1,,ANY
309457,BLOCK,1,,<empty>,,,,1,,ANY
309464,BLOCK,1,,<empty>,,,,1,,ANY
309467,BLOCK,1,,<empty>,,,,1,,ANY
309471,BLOCK,1,,<empty>,,,,1,,ANY
309478,BLOCK,1,,<empty>,,,,1,,ANY
309486,BLOCK,1,,<empty>,,,,1,,ANY
309489,BLOCK,1,,<empty>,,,,1,,ANY
309492,BLOCK,1,,<empty>,,,,1,,ANY
309496,BLOCK,1,,<empty>,,,,1,,ANY
309500,BLOCK,1,,<empty>,,,,1,,ANY
309504,BLOCK,1,,<empty>,,,,1,,ANY
309508,BLOCK,1,,<empty>,,,,1,,ANY
309514,BLOCK,1,,<empty>,,,,1,,ANY
309519,BLOCK,1,,<empty>,,,,1,,ANY
309523,BLOCK,1,,<empty>,,,,1,,ANY
309527,BLOCK,1,,<empty>,,,,1,,ANY
309531,BLOCK,1,,<empty>,,,,1,,ANY
309535,BLOCK,1,,<empty>,,,,1,,ANY
309539,BLOCK,1,,<empty>,,,,1,,ANY
309543,BLOCK,1,,<empty>,,,,1,,ANY
309547,BLOCK,1,,<empty>,,,,1,,ANY
309551,BLOCK,1,,<empty>,,,,1,,ANY
309557,BLOCK,1,,<empty>,,,,1,,ANY
309561,BLOCK,1,,<empty>,,,,1,,ANY
309567,BLOCK,1,,<empty>,,,,1,,ANY
309571,BLOCK,1,,<empty>,,,,1,,ANY
309577,BLOCK,1,,<empty>,,,,1,,ANY
309583,BLOCK,1,,<empty>,,,,1,,ANY
309589,BLOCK,1,,<empty>,,,,1,,ANY
309594,BLOCK,1,,<empty>,,,,1,,ANY
309600,BLOCK,1,,<empty>,,,,1,,ANY
309605,BLOCK,1,,<empty>,,,,1,,ANY
309610,BLOCK,1,,<empty>,,,,1,,ANY
309614,BLOCK,1,,<empty>,,,,1,,ANY
309617,BLOCK,1,,<empty>,,,,1,,ANY
309621,BLOCK,1,,<empty>,,,,1,,ANY
309624,BLOCK,1,,<empty>,,,,1,,ANY
309629,BLOCK,1,,<empty>,,,,1,,ANY
309634,BLOCK,1,,<empty>,,,,1,,ANY
309638,BLOCK,1,,<empty>,,,,1,,ANY
309643,BLOCK,1,,<empty>,,,,1,,ANY
309647,BLOCK,1,,<empty>,,,,1,,ANY
309652,BLOCK,1,,<empty>,,,,1,,ANY
309657,BLOCK,1,,<empty>,,,,1,,ANY
309662,BLOCK,1,,<empty>,,,,1,,ANY
309666,BLOCK,1,,<empty>,,,,1,,ANY
309671,BLOCK,1,,<empty>,,,,1,,ANY
309676,BLOCK,1,,<empty>,,,,1,,ANY
309680,BLOCK,1,,<empty>,,,,1,,ANY
309685,BLOCK,1,,<empty>,,,,1,,ANY
309691,BLOCK,1,,<empty>,,,,1,,ANY
309697,BLOCK,1,,<empty>,,,,1,,ANY
309702,BLOCK,1,,<empty>,,,,1,,ANY
309707,BLOCK,1,,<empty>,,,,1,,ANY
309711,BLOCK,1,,<empty>,,,,1,,ANY
309716,BLOCK,1,,<empty>,,,,1,,ANY
309721,BLOCK,1,,<empty>,,,,1,,ANY
309725,BLOCK,1,,<empty>,,,,1,,ANY
309734,BLOCK,1,,<empty>,,,,1,,ANY
309738,BLOCK,1,,<empty>,,,,1,,ANY
309742,BLOCK,1,,<empty>,,,,1,,ANY
309746,BLOCK,1,,<empty>,,,,1,,ANY
309750,BLOCK,1,,<empty>,,,,1,,ANY
309757,BLOCK,1,,<empty>,,,,1,,ANY
309761,BLOCK,1,,<empty>,,,,1,,ANY
309765,BLOCK,1,,<empty>,,,,1,,ANY
309771,BLOCK,1,,<empty>,,,,1,,ANY
309777,BLOCK,1,,<empty>,,,,1,,ANY
309782,BLOCK,1,,<empty>,,,,1,,ANY
309787,BLOCK,1,,<empty>,,,,1,,ANY
309791,BLOCK,1,,<empty>,,,,1,,ANY
309795,BLOCK,1,,<empty>,,,,1,,ANY
309800,BLOCK,1,,<empty>,,,,1,,ANY
309806,BLOCK,1,,<empty>,,,,1,,ANY
309812,BLOCK,1,,<empty>,,,,1,,ANY
309818,BLOCK,1,,<empty>,,,,1,,ANY
309826,BLOCK,1,,<empty>,,,,1,,ANY
309834,BLOCK,1,,<empty>,,,,1,,ANY
309839,BLOCK,1,,<empty>,,,,1,,ANY
309844,BLOCK,1,,<empty>,,,,1,,ANY
309849,BLOCK,1,,<empty>,,,,1,,ANY
309854,BLOCK,1,,<empty>,,,,1,,ANY
309858,BLOCK,1,,<empty>,,,,1,,ANY
309866,BLOCK,1,,<empty>,,,,1,,ANY
309870,BLOCK,1,,<empty>,,,,1,,ANY
309874,BLOCK,1,,<empty>,,,,1,,ANY
309878,BLOCK,1,,<empty>,,,,1,,ANY
309882,BLOCK,1,,<empty>,,,,1,,ANY
309886,BLOCK,1,,<empty>,,,,1,,ANY
309889,BLOCK,1,,<empty>,,,,1,,ANY
309897,BLOCK,1,,<empty>,,,,1,,ANY
309901,BLOCK,1,,<empty>,,,,1,,ANY
309905,BLOCK,1,,<empty>,,,,1,,ANY
309912,BLOCK,1,,<empty>,,,,1,,ANY
309916,BLOCK,1,,<empty>,,,,1,,ANY
309924,BLOCK,1,,<empty>,,,,1,,ANY
309928,BLOCK,1,,<empty>,,,,1,,ANY
309932,BLOCK,1,,<empty>,,,,1,,ANY
309936,BLOCK,1,,<empty>,,,,1,,ANY
309941,BLOCK,1,,<empty>,,,,1,,ANY
309945,BLOCK,1,,<empty>,,,,1,,ANY
309949,BLOCK,1,,<empty>,,,,1,,ANY
309954,BLOCK,1,,<empty>,,,,1,,ANY
309963,BLOCK,1,,<empty>,,,,1,,ANY
309968,BLOCK,1,,<empty>,,,,1,,ANY
309972,BLOCK,1,,<empty>,,,,1,,ANY
309978,BLOCK,1,,<empty>,,,,1,,ANY
309982,BLOCK,1,,<empty>,,,,1,,ANY
309986,BLOCK,1,,<empty>,,,,1,,ANY
309990,BLOCK,1,,<empty>,,,,1,,ANY
309994,BLOCK,1,,<empty>,,,,1,,ANY
309998,BLOCK,1,,<empty>,,,,1,,ANY
310002,BLOCK,1,,<empty>,,,,1,,ANY
310006,BLOCK,1,,<empty>,,,,1,,ANY
310010,BLOCK,1,,<empty>,,,,1,,ANY
310015,BLOCK,1,,<empty>,,,,1,,ANY
310020,BLOCK,1,,<empty>,,,,1,,ANY
310025,BLOCK,1,,<empty>,,,,1,,ANY
310029,BLOCK,1,,<empty>,,,,1,,ANY
310034,BLOCK,1,,<empty>,,,,1,,ANY
310040,BLOCK,1,,<empty>,,,,1,,ANY
310043,BLOCK,1,,<empty>,,,,1,,ANY
310048,BLOCK,1,,<empty>,,,,1,,ANY
310052,BLOCK,1,,<empty>,,,,1,,ANY
310057,BLOCK,1,,<empty>,,,,1,,ANY
310062,BLOCK,1,,<empty>,,,,1,,ANY
310067,BLOCK,1,,<empty>,,,,1,,ANY
310071,BLOCK,1,,<empty>,,,,1,,ANY
310079,BLOCK,1,,<empty>,,,,1,,ANY
310082,BLOCK,1,,<empty>,,,,1,,ANY
310086,BLOCK,1,,<empty>,,,,1,,ANY
310090,BLOCK,1,,<empty>,,,,1,,ANY
310097,BLOCK,1,,<empty>,,,,1,,ANY
310101,BLOCK,1,,<empty>,,,,1,,ANY
310105,BLOCK,1,,<empty>,,,,1,,ANY
310111,BLOCK,1,,<empty>,,,,1,,ANY
310115,BLOCK,1,,<empty>,,,,1,,ANY
310119,BLOCK,1,,<empty>,,,,1,,ANY
310123,BLOCK,1,,<empty>,,,,1,,ANY
310126,BLOCK,1,,<empty>,,,,1,,ANY
310132,BLOCK,1,,<empty>,,,,1,,ANY
310138,BLOCK,1,,<empty>,,,,1,,ANY
310142,BLOCK,1,,<empty>,,,,1,,ANY
310146,BLOCK,1,,<empty>,,,,1,,ANY
310150,BLOCK,1,,<empty>,,,,1,,ANY
310155,BLOCK,1,,<empty>,,,,1,,ANY
310161,BLOCK,1,,<empty>,,,,1,,ANY
310167,BLOCK,1,,<empty>,,,,1,,ANY
310171,BLOCK,1,,<empty>,,,,1,,ANY
310177,BLOCK,1,,<empty>,,,,1,,ANY
310181,BLOCK,1,,<empty>,,,,1,,ANY
310185,BLOCK,1,,<empty>,,,,1,,ANY
310191,BLOCK,1,,<empty>,,,,1,,ANY
310196,BLOCK,1,,<empty>,,,,1,,ANY
310202,BLOCK,1,,<empty>,,,,1,,ANY
310207,BLOCK,1,,<empty>,,,,1,,ANY
310211,BLOCK,1,,<empty>,,,,1,,ANY
310216,BLOCK,1,,<empty>,,,,1,,ANY
310219,BLOCK,1,,<empty>,,,,1,,ANY
310223,BLOCK,1,,<empty>,,,,1,,ANY
310229,BLOCK,1,,<empty>,,,,1,,ANY
310234,BLOCK,1,,<empty>,,,,1,,ANY
310237,BLOCK,1,,<empty>,,,,1,,ANY
310243,BLOCK,1,,<empty>,,,,1,,ANY
310247,BLOCK,1,,<empty>,,,,1,,ANY
310251,BLOCK,1,,<empty>,,,,1,,ANY
310256,BLOCK,1,,<empty>,,,,1,,ANY
310262,BLOCK,1,,<empty>,,,,1,,ANY
310267,BLOCK,1,,<empty>,,,,1,,ANY
310271,BLOCK,1,,<empty>,,,,1,,ANY
310277,BLOCK,1,,<empty>,,,,1,,ANY
310283,BLOCK,1,,<empty>,,,,1,,ANY
310287,BLOCK,1,,<empty>,,,,1,,ANY
310293,BLOCK,1,,<empty>,,,,1,,ANY
310297,BLOCK,1,,<empty>,,,,1,,ANY
310302,BLOCK,1,,<empty>,,,,1,,ANY
310306,BLOCK,1,,<empty>,,,,1,,ANY
310310,BLOCK,1,,<empty>,,,,1,,ANY
310315,BLOCK,1,,<empty>,,,,1,,ANY
310321,BLOCK,1,,<empty>,,,,1,,ANY
310331,BLOCK,1,,<empty>,,,,1,,ANY
310336,BLOCK,1,,<empty>,,,,1,,ANY
310342,BLOCK,1,,<empty>,,,,1,,ANY
310348,BLOCK,1,,<empty>,,,,1,,ANY
310354,BLOCK,1,,<empty>,,,,1,,ANY
310359,BLOCK,1,,<empty>,,,,1,,ANY
310362,BLOCK,1,,<empty>,,,,1,,ANY
310369,BLOCK,1,,<empty>,,,,1,,ANY
310375,BLOCK,1,,<empty>,,,,1,,ANY
310381,BLOCK,1,,<empty>,,,,1,,ANY
310385,BLOCK,1,,<empty>,,,,1,,ANY
310389,BLOCK,1,,<empty>,,,,1,,ANY
310394,BLOCK,1,,<empty>,,,,1,,ANY
310398,BLOCK,1,,<empty>,,,,1,,ANY
310402,BLOCK,1,,<empty>,,,,1,,ANY
310407,BLOCK,1,,<empty>,,,,1,,ANY
310413,BLOCK,1,,<empty>,,,,1,,ANY
310419,BLOCK,1,,<empty>,,,,1,,ANY
310425,BLOCK,1,,<empty>,,,,1,,ANY
310430,BLOCK,1,,<empty>,,,,1,,ANY
310435,BLOCK,1,,<empty>,,,,1,,ANY
310441,BLOCK,1,,<empty>,,,,1,,ANY
310448,BLOCK,1,,<empty>,,,,1,,ANY
310452,BLOCK,1,,<empty>,,,,1,,ANY
310458,BLOCK,1,,<empty>,,,,1,,ANY
310462,BLOCK,1,,<empty>,,,,1,,ANY
310465,BLOCK,1,,<empty>,,,,1,,ANY
310475,BLOCK,1,,<empty>,,,,1,,ANY
310480,BLOCK,1,,<empty>,,,,1,,ANY
310485,BLOCK,1,,<empty>,,,,1,,ANY
310489,BLOCK,1,,<empty>,,,,1,,ANY
310494,BLOCK,1,,<empty>,,,,1,,ANY
310501,BLOCK,1,,<empty>,,,,1,,ANY
310507,BLOCK,1,,<empty>,,,,1,,ANY
310511,BLOCK,1,,<empty>,,,,1,,ANY
310518,BLOCK,1,,<empty>,,,,1,,ANY
310525,BLOCK,1,,<empty>,,,,1,,ANY
310530,BLOCK,1,,<empty>,,,,1,,ANY
310537,BLOCK,1,,<empty>,,,,1,,ANY
310541,BLOCK,1,,<empty>,,,,1,,ANY
310546,BLOCK,1,,<empty>,,,,1,,ANY
310550,BLOCK,1,,<empty>,,,,1,,ANY
310554,BLOCK,1,,<empty>,,,,1,,ANY
310564,BLOCK,1,,<empty>,,,,1,,ANY
310568,BLOCK,1,,<empty>,,,,1,,ANY
310573,BLOCK,1,,<empty>,,,,1,,ANY
310583,BLOCK,1,,<empty>,,,,1,,ANY
310593,BLOCK,1,,<empty>,,,,1,,ANY
310597,BLOCK,1,,<empty>,,,,1,,ANY
310607,BLOCK,1,,<empty>,,,,1,,ANY
310612,BLOCK,1,,<empty>,,,,1,,ANY
310618,BLOCK,1,,<empty>,,,,1,,ANY
310623,BLOCK,1,,<empty>,,,,1,,ANY
310628,BLOCK,1,,<empty>,,,,1,,ANY
310633,BLOCK,1,,<empty>,,,,1,,ANY
310639,BLOCK,1,,<empty>,,,,1,,ANY
310643,BLOCK,1,,<empty>,,,,1,,ANY
310647,BLOCK,1,,<empty>,,,,1,,ANY
310653,BLOCK,1,,<empty>,,,,1,,ANY
310659,BLOCK,1,,<empty>,,,,1,,ANY
310665,BLOCK,1,,<empty>,,,,1,,ANY
310669,BLOCK,1,,<empty>,,,,1,,ANY
310676,BLOCK,1,,<empty>,,,,1,,ANY
310683,BLOCK,1,,<empty>,,,,1,,ANY
310687,BLOCK,1,,<empty>,,,,1,,ANY
310693,BLOCK,1,,<empty>,,,,1,,ANY
310699,BLOCK,1,,<empty>,,,,1,,ANY
310705,BLOCK,1,,<empty>,,,,1,,ANY
310711,BLOCK,1,,<empty>,,,,1,,ANY
310715,BLOCK,1,,<empty>,,,,1,,ANY
310718,BLOCK,1,,<empty>,,,,1,,ANY
310721,BLOCK,1,,<empty>,,,,1,,ANY
310727,BLOCK,1,,<empty>,,,,1,,ANY
310734,BLOCK,1,,<empty>,,,,1,,ANY
310738,BLOCK,1,,<empty>,,,,1,,ANY
310745,BLOCK,1,,<empty>,,,,1,,ANY
310751,BLOCK,1,,<empty>,,,,1,,ANY
310757,BLOCK,1,,<empty>,,,,1,,ANY
310764,BLOCK,1,,<empty>,,,,1,,ANY
310769,BLOCK,1,,<empty>,,,,1,,ANY
310772,BLOCK,1,,<empty>,,,,1,,ANY
310776,BLOCK,1,,<empty>,,,,1,,ANY
310780,BLOCK,1,,<empty>,,,,1,,ANY
310786,BLOCK,1,,<empty>,,,,1,,ANY
310792,BLOCK,1,,<empty>,,,,1,,ANY
310799,BLOCK,1,,<empty>,,,,1,,ANY
310803,BLOCK,1,,<empty>,,,,1,,ANY
310810,BLOCK,1,,<empty>,,,,1,,ANY
310815,BLOCK,1,,<empty>,,,,1,,ANY
310822,BLOCK,1,,<empty>,,,,1,,ANY
310830,BLOCK,1,,<empty>,,,,1,,ANY
310835,BLOCK,1,,<empty>,,,,1,,ANY
310839,BLOCK,1,,<empty>,,,,1,,ANY
310844,BLOCK,1,,<empty>,,,,1,,ANY
310849,BLOCK,1,,<empty>,,,,1,,ANY
310854,BLOCK,1,,<empty>,,,,1,,ANY
310861,BLOCK,1,,<empty>,,,,1,,ANY
310866,BLOCK,1,,<empty>,,,,1,,ANY
310871,BLOCK,1,,<empty>,,,,1,,ANY
310879,BLOCK,1,,<empty>,,,,1,,ANY
310883,BLOCK,1,,<empty>,,,,1,,ANY
310887,BLOCK,1,,<empty>,,,,1,,ANY
310892,BLOCK,1,,<empty>,,,,1,,ANY
310896,BLOCK,1,,<empty>,,,,1,,ANY
310902,BLOCK,1,,<empty>,,,,1,,ANY
310907,BLOCK,1,,<empty>,,,,1,,ANY
310913,BLOCK,1,,<empty>,,,,1,,ANY
310919,BLOCK,1,,<empty>,,,,1,,ANY
310923,BLOCK,1,,<empty>,,,,1,,ANY
310927,BLOCK,1,,<empty>,,,,1,,ANY
310931,BLOCK,1,,<empty>,,,,1,,ANY
310935,BLOCK,1,,<empty>,,,,1,,ANY
310939,BLOCK,1,,<empty>,,,,1,,ANY
310943,BLOCK,1,,<empty>,,,,1,,ANY
310947,BLOCK,1,,<empty>,,,,1,,ANY
310951,BLOCK,1,,<empty>,,,,1,,ANY
310955,BLOCK,1,,<empty>,,,,1,,ANY
310959,BLOCK,1,,<empty>,,,,1,,ANY
310963,BLOCK,1,,<empty>,,,,1,,ANY
310970,BLOCK,1,,<empty>,,,,1,,ANY
310975,BLOCK,1,,<empty>,,,,1,,ANY
310982,BLOCK,1,,<empty>,,,,1,,ANY
310987,BLOCK,1,,<empty>,,,,1,,ANY
310992,BLOCK,1,,<empty>,,,,1,,ANY
310997,BLOCK,1,,<empty>,,,,1,,ANY
311002,BLOCK,1,,<empty>,,,,1,,ANY
311006,BLOCK,1,,<empty>,,,,1,,ANY
311010,BLOCK,1,,<empty>,,,,1,,ANY
311014,BLOCK,1,,<empty>,,,,1,,ANY
311018,BLOCK,1,,<empty>,,,,1,,ANY
311022,BLOCK,1,,<empty>,,,,1,,ANY
311026,BLOCK,1,,<empty>,,,,1,,ANY
311031,BLOCK,1,,<empty>,,,,1,,ANY
311039,BLOCK,1,,<empty>,,,,1,,ANY
311047,BLOCK,1,,<empty>,,,,1,,ANY
311055,BLOCK,1,,<empty>,,,,1,,ANY
311063,BLOCK,1,,<empty>,,,,1,,ANY
311071,BLOCK,1,,<empty>,,,,1,,ANY
311079,BLOCK,1,,<empty>,,,,1,,ANY
311087,BLOCK,1,,<empty>,,,,1,,ANY
311095,BLOCK,1,,<empty>,,,,1,,ANY
311103,BLOCK,1,,<empty>,,,,1,,ANY
311111,BLOCK,1,,<empty>,,,,1,,ANY
311119,BLOCK,1,,<empty>,,,,1,,ANY
311127,BLOCK,1,,<empty>,,,,1,,ANY
311135,BLOCK,1,,<empty>,,,,1,,ANY
311143,BLOCK,1,,<empty>,,,,1,,ANY
311151,BLOCK,1,,<empty>,,,,1,,ANY
311159,BLOCK,1,,<empty>,,,,1,,ANY
311167,BLOCK,1,,<empty>,,,,1,,ANY
311175,BLOCK,1,,<empty>,,,,1,,ANY
311183,BLOCK,1,,<empty>,,,,1,,ANY
311191,BLOCK,1,,<empty>,,,,1,,ANY
311196,BLOCK,1,,<empty>,,,,1,,ANY
311200,BLOCK,1,,<empty>,,,,1,,ANY
311204,BLOCK,1,,<empty>,,,,1,,ANY
311215,BLOCK,1,,<empty>,,,,1,,ANY
311220,BLOCK,1,,<empty>,,,,1,,ANY
311224,BLOCK,1,,<empty>,,,,1,,ANY
311228,BLOCK,1,,<empty>,,,,1,,ANY
311231,BLOCK,1,,<empty>,,,,1,,ANY
311240,BLOCK,1,,<empty>,,,,1,,ANY
311244,BLOCK,1,,<empty>,,,,1,,ANY
311247,BLOCK,1,,<empty>,,,,1,,ANY
311254,BLOCK,1,,<empty>,,,,1,,ANY
311260,BLOCK,1,,<empty>,,,,1,,ANY
311266,BLOCK,1,,<empty>,,,,1,,ANY
311272,BLOCK,1,,<empty>,,,,1,,ANY
311277,BLOCK,1,,<empty>,,,,1,,ANY
311282,BLOCK,1,,<empty>,,,,1,,ANY
311287,BLOCK,1,,<empty>,,,,1,,ANY
311292,BLOCK,1,,<empty>,,,,1,,ANY
311297,BLOCK,1,,<empty>,,,,1,,ANY
311302,BLOCK,1,,<empty>,,,,1,,ANY
311307,BLOCK,1,,<empty>,,,,1,,ANY
311312,BLOCK,1,,<empty>,,,,1,,ANY
311317,BLOCK,1,,<empty>,,,,1,,ANY
311322,BLOCK,1,,<empty>,,,,1,,ANY
311330,BLOCK,1,,<empty>,,,,1,,ANY
311336,BLOCK,1,,<empty>,,,,1,,ANY
311341,BLOCK,1,,<empty>,,,,1,,ANY
311349,BLOCK,1,,<empty>,,,,1,,ANY
311357,BLOCK,1,,<empty>,,,,1,,ANY
311360,BLOCK,1,,<empty>,,,,1,,ANY
311364,BLOCK,1,,<empty>,,,,1,,ANY
311368,BLOCK,1,,<empty>,,,,1,,ANY
311372,BLOCK,1,,<empty>,,,,1,,ANY
311376,BLOCK,1,,<empty>,,,,1,,ANY
311380,BLOCK,1,,<empty>,,,,1,,ANY
311386,BLOCK,1,,<empty>,,,,1,,ANY
311393,BLOCK,1,,<empty>,,,,1,,ANY
311397,BLOCK,1,,<empty>,,,,1,,ANY
311401,BLOCK,1,,<empty>,,,,1,,ANY
311405,BLOCK,1,,<empty>,,,,1,,ANY
311409,BLOCK,1,,<empty>,,,,1,,ANY
311413,BLOCK,1,,<empty>,,,,1,,ANY
311416,BLOCK,1,,<empty>,,,,1,,ANY
311423,BLOCK,1,,<empty>,,,,1,,ANY
311429,BLOCK,1,,<empty>,,,,1,,ANY
311436,BLOCK,1,,<empty>,,,,1,,ANY
311441,BLOCK,1,,<empty>,,,,1,,ANY
311445,BLOCK,1,,<empty>,,,,1,,ANY
311449,BLOCK,1,,<empty>,,,,1,,ANY
311453,BLOCK,1,,<empty>,,,,1,,ANY
311457,BLOCK,1,,<empty>,,,,1,,ANY
311461,BLOCK,1,,<empty>,,,,1,,ANY
311466,BLOCK,1,,<empty>,,,,1,,ANY
311470,BLOCK,1,,<empty>,,,,1,,ANY
311474,BLOCK,1,,<empty>,,,,1,,ANY
311480,BLOCK,1,,<empty>,,,,1,,ANY
311486,BLOCK,1,,<empty>,,,,1,,ANY
311492,BLOCK,1,,<empty>,,,,1,,ANY
311497,BLOCK,1,,<empty>,,,,1,,ANY
311502,BLOCK,1,,<empty>,,,,1,,ANY
311507,BLOCK,1,,<empty>,,,,1,,ANY
311512,BLOCK,1,,<empty>,,,,1,,ANY
311516,BLOCK,1,,<empty>,,,,1,,ANY
311529,BLOCK,1,,<empty>,,,,1,,ANY
311533,BLOCK,1,,<empty>,,,,1,,ANY
311539,BLOCK,1,,<empty>,,,,1,,ANY
311543,BLOCK,1,,<empty>,,,,1,,ANY
311548,BLOCK,1,,<empty>,,,,1,,ANY
311552,BLOCK,1,,<empty>,,,,1,,ANY
311556,BLOCK,1,,<empty>,,,,1,,ANY
311560,BLOCK,1,,<empty>,,,,1,,ANY
311567,BLOCK,1,,<empty>,,,,1,,ANY
311572,BLOCK,1,,<empty>,,,,1,,ANY
311580,BLOCK,1,,<empty>,,,,1,,ANY
311584,BLOCK,1,,<empty>,,,,1,,ANY
311588,BLOCK,1,,<empty>,,,,1,,ANY
311594,BLOCK,1,,<empty>,,,,1,,ANY
311598,BLOCK,1,,<empty>,,,,1,,ANY
311602,BLOCK,1,,<empty>,,,,1,,ANY
311606,BLOCK,1,,<empty>,,,,1,,ANY
311613,BLOCK,1,,<empty>,,,,1,,ANY
311617,BLOCK,1,,<empty>,,,,1,,ANY
311620,BLOCK,1,,<empty>,,,,1,,ANY
311626,BLOCK,1,,<empty>,,,,1,,ANY
311631,BLOCK,1,,<empty>,,,,1,,ANY
311634,BLOCK,1,,<empty>,,,,1,,ANY
311640,BLOCK,1,,<empty>,,,,1,,ANY
311645,BLOCK,1,,<empty>,,,,1,,ANY
311650,BLOCK,1,,<empty>,,,,1,,ANY
311655,BLOCK,1,,<empty>,,,,1,,ANY
311659,BLOCK,1,,<empty>,,,,1,,ANY
311667,BLOCK,1,,<empty>,,,,1,,ANY
311673,BLOCK,1,,<empty>,,,,1,,ANY
311677,BLOCK,1,,<empty>,,,,1,,ANY
311681,BLOCK,1,,<empty>,,,,1,,ANY
311689,BLOCK,1,,<empty>,,,,1,,ANY
311694,BLOCK,1,,<empty>,,,,1,,ANY
311698,BLOCK,1,,<empty>,,,,1,,ANY
311706,BLOCK,1,,<empty>,,,,1,,ANY
311710,BLOCK,1,,<empty>,,,,1,,ANY
311715,BLOCK,1,,<empty>,,,,1,,ANY
311724,BLOCK,1,,<empty>,,,,1,,ANY
311728,BLOCK,1,,<empty>,,,,1,,ANY
311733,BLOCK,1,,<empty>,,,,1,,ANY
311738,BLOCK,1,,<empty>,,,,1,,ANY
311746,BLOCK,1,,<empty>,,,,1,,ANY
311754,BLOCK,1,,<empty>,,,,1,,ANY
311758,BLOCK,1,,<empty>,,,,1,,ANY
311766,BLOCK,1,,<empty>,,,,1,,ANY
311772,BLOCK,1,,<empty>,,,,1,,ANY
311778,BLOCK,1,,<empty>,,,,1,,ANY
311786,BLOCK,1,,<empty>,,,,1,,ANY
311790,BLOCK,1,,<empty>,,,,1,,ANY
311795,BLOCK,1,,<empty>,,,,1,,ANY
311799,BLOCK,1,,<empty>,,,,1,,ANY
311804,BLOCK,1,,<empty>,,,,1,,ANY
311808,BLOCK,1,,<empty>,,,,1,,ANY
311812,BLOCK,1,,<empty>,,,,1,,ANY
311816,BLOCK,1,,<empty>,,,,1,,ANY
311820,BLOCK,1,,<empty>,,,,1,,ANY
311828,BLOCK,1,,<empty>,,,,1,,ANY
311833,BLOCK,1,,<empty>,,,,1,,ANY
311837,BLOCK,1,,<empty>,,,,1,,ANY
311841,BLOCK,1,,<empty>,,,,1,,ANY
311845,BLOCK,1,,<empty>,,,,1,,ANY
311851,BLOCK,1,,<empty>,,,,1,,ANY
311856,BLOCK,1,,<empty>,,,,1,,ANY
311862,BLOCK,1,,<empty>,,,,1,,ANY
311866,BLOCK,1,,<empty>,,,,1,,ANY
311871,BLOCK,1,,<empty>,,,,1,,ANY
311881,BLOCK,1,,<empty>,,,,1,,ANY
311885,BLOCK,1,,<empty>,,,,1,,ANY
311889,BLOCK,1,,<empty>,,,,1,,ANY
311894,BLOCK,1,,<empty>,,,,1,,ANY
311899,BLOCK,1,,<empty>,,,,1,,ANY
311903,BLOCK,1,,<empty>,,,,1,,ANY
311907,BLOCK,1,,<empty>,,,,1,,ANY
311911,BLOCK,1,,<empty>,,,,1,,ANY
311915,BLOCK,1,,<empty>,,,,1,,ANY
311919,BLOCK,1,,<empty>,,,,1,,ANY
311923,BLOCK,1,,<empty>,,,,1,,ANY
311927,BLOCK,1,,<empty>,,,,1,,ANY
311931,BLOCK,1,,<empty>,,,,1,,ANY
311935,BLOCK,1,,<empty>,,,,1,,ANY
311939,BLOCK,1,,<empty>,,,,1,,ANY
311944,BLOCK,1,,<empty>,,,,1,,ANY
311949,BLOCK,1,,<empty>,,,,1,,ANY
311953,BLOCK,1,,<empty>,,,,1,,ANY
311958,BLOCK,1,,<empty>,,,,1,,ANY
311962,BLOCK,1,,<empty>,,,,1,,ANY
311966,BLOCK,1,,<empty>,,,,1,,ANY
311970,BLOCK,1,,<empty>,,,,1,,ANY
311974,BLOCK,1,,<empty>,,,,1,,ANY
311978,BLOCK,1,,<empty>,,,,1,,ANY
311982,BLOCK,1,,<empty>,,,,1,,ANY
311986,BLOCK,1,,<empty>,,,,1,,ANY
311990,BLOCK,1,,<empty>,,,,1,,ANY
311999,BLOCK,1,,<empty>,,,,1,,ANY
312003,BLOCK,1,,<empty>,,,,1,,ANY
312009,BLOCK,1,,<empty>,,,,1,,ANY
312013,BLOCK,1,,<empty>,,,,1,,ANY
312017,BLOCK,1,,<empty>,,,,1,,ANY
312020,BLOCK,1,,<empty>,,,,1,,ANY
312024,BLOCK,1,,<empty>,,,,1,,ANY
312030,BLOCK,1,,<empty>,,,,1,,ANY
312034,BLOCK,1,,<empty>,,,,1,,ANY
312039,BLOCK,1,,<empty>,,,,1,,ANY
312044,BLOCK,1,,<empty>,,,,1,,ANY
312049,BLOCK,1,,<empty>,,,,1,,ANY
312053,BLOCK,1,,<empty>,,,,1,,ANY
312058,BLOCK,1,,<empty>,,,,1,,ANY
312063,BLOCK,1,,<empty>,,,,1,,ANY
312068,BLOCK,1,,<empty>,,,,1,,ANY
312071,BLOCK,1,,<empty>,,,,1,,ANY
312077,BLOCK,1,,<empty>,,,,1,,ANY
312081,BLOCK,1,,<empty>,,,,1,,ANY
312084,BLOCK,1,,<empty>,,,,1,,ANY
312089,BLOCK,1,,<empty>,,,,1,,ANY
312093,BLOCK,1,,<empty>,,,,1,,ANY
312098,BLOCK,1,,<empty>,,,,1,,ANY
312104,BLOCK,1,,<empty>,,,,1,,ANY
312110,BLOCK,1,,<empty>,,,,1,,ANY
312115,BLOCK,1,,<empty>,,,,1,,ANY
312120,BLOCK,1,,<empty>,,,,1,,ANY
312125,BLOCK,1,,<empty>,,,,1,,ANY
312130,BLOCK,1,,<empty>,,,,1,,ANY
312134,BLOCK,1,,<empty>,,,,1,,ANY
312140,BLOCK,1,,<empty>,,,,1,,ANY
312144,BLOCK,1,,<empty>,,,,1,,ANY
312149,BLOCK,1,,<empty>,,,,1,,ANY
312153,BLOCK,1,,<empty>,,,,1,,ANY
312158,BLOCK,1,,<empty>,,,,1,,ANY
312162,BLOCK,1,,<empty>,,,,1,,ANY
312166,BLOCK,1,,<empty>,,,,1,,ANY
312170,BLOCK,1,,<empty>,,,,1,,ANY
312173,BLOCK,1,,<empty>,,,,1,,ANY
312178,BLOCK,1,,<empty>,,,,1,,ANY
312184,BLOCK,1,,<empty>,,,,1,,ANY
312187,BLOCK,1,,<empty>,,,,1,,ANY
312190,BLOCK,1,,<empty>,,,,1,,ANY
312194,BLOCK,1,,<empty>,,,,1,,ANY
312198,BLOCK,1,,<empty>,,,,1,,ANY
312202,BLOCK,1,,<empty>,,,,1,,ANY
312206,BLOCK,1,,<empty>,,,,1,,ANY
312210,BLOCK,1,,<empty>,,,,1,,ANY
312213,BLOCK,1,,<empty>,,,,1,,ANY
312217,BLOCK,1,,<empty>,,,,1,,ANY
312221,BLOCK,1,,<empty>,,,,1,,ANY
312228,BLOCK,1,,<empty>,,,,1,,ANY
312233,BLOCK,1,,<empty>,,,,1,,ANY
312236,BLOCK,1,,<empty>,,,,1,,ANY
312239,BLOCK,1,,<empty>,,,,1,,ANY
312245,BLOCK,1,,<empty>,,,,1,,ANY
312249,BLOCK,1,,<empty>,,,,1,,ANY
312254,BLOCK,1,,<empty>,,,,1,,ANY
312259,BLOCK,1,,<empty>,,,,1,,ANY
312262,BLOCK,1,,<empty>,,,,1,,ANY
312266,BLOCK,1,,<empty>,,,,1,,ANY
312270,BLOCK,1,,<empty>,,,,1,,ANY
312274,BLOCK,1,,<empty>,,,,1,,ANY
312278,BLOCK,1,,<empty>,,,,1,,ANY
312282,BLOCK,1,,<empty>,,,,1,,ANY
312286,BLOCK,1,,<empty>,,,,1,,ANY
312290,BLOCK,1,,<empty>,,,,1,,ANY
312295,BLOCK,1,,<empty>,,,,1,,ANY
312301,BLOCK,1,,<empty>,,,,1,,ANY
312306,BLOCK,1,,<empty>,,,,1,,ANY
312309,BLOCK,1,,<empty>,,,,1,,ANY
312313,BLOCK,1,,<empty>,,,,1,,ANY
312317,BLOCK,1,,<empty>,,,,1,,ANY
312321,BLOCK,1,,<empty>,,,,1,,ANY
312325,BLOCK,1,,<empty>,,,,1,,ANY
312329,BLOCK,1,,<empty>,,,,1,,ANY
312332,BLOCK,1,,<empty>,,,,1,,ANY
312337,BLOCK,1,,<empty>,,,,1,,ANY
312342,BLOCK,1,,<empty>,,,,1,,ANY
312347,BLOCK,1,,<empty>,,,,1,,ANY
312352,BLOCK,1,,<empty>,,,,1,,ANY
312356,BLOCK,1,,<empty>,,,,1,,ANY
312360,BLOCK,1,,<empty>,,,,1,,ANY
312364,BLOCK,1,,<empty>,,,,1,,ANY
312368,BLOCK,1,,<empty>,,,,1,,ANY
312372,BLOCK,1,,<empty>,,,,1,,ANY
312377,BLOCK,1,,<empty>,,,,1,,ANY
312382,BLOCK,1,,<empty>,,,,1,,ANY
312387,BLOCK,1,,<empty>,,,,1,,ANY
312392,BLOCK,1,,<empty>,,,,1,,ANY
312397,BLOCK,1,,<empty>,,,,1,,ANY
312403,BLOCK,1,,<empty>,,,,1,,ANY
312408,BLOCK,1,,<empty>,,,,1,,ANY
312412,BLOCK,1,,<empty>,,,,1,,ANY
312416,BLOCK,1,,<empty>,,,,1,,ANY
312421,BLOCK,1,,<empty>,,,,1,,ANY
312426,BLOCK,1,,<empty>,,,,1,,ANY
312431,BLOCK,1,,<empty>,,,,1,,ANY
312435,BLOCK,1,,<empty>,,,,1,,ANY
312439,BLOCK,1,,<empty>,,,,1,,ANY
312444,BLOCK,1,,<empty>,,,,1,,ANY
312449,BLOCK,1,,<empty>,,,,1,,ANY
312454,BLOCK,1,,<empty>,,,,1,,ANY
312459,BLOCK,1,,<empty>,,,,1,,ANY
312464,BLOCK,1,,<empty>,,,,1,,ANY
312469,BLOCK,1,,<empty>,,,,1,,ANY
312472,BLOCK,1,,<empty>,,,,1,,ANY
312477,BLOCK,1,,<empty>,,,,1,,ANY
312481,BLOCK,1,,<empty>,,,,1,,ANY
312485,BLOCK,1,,<empty>,,,,1,,ANY
312489,BLOCK,1,,<empty>,,,,1,,ANY
312493,BLOCK,1,,<empty>,,,,1,,ANY
312498,BLOCK,1,,<empty>,,,,1,,ANY
312503,BLOCK,1,,<empty>,,,,1,,ANY
312507,BLOCK,1,,<empty>,,,,1,,ANY
312512,BLOCK,1,,<empty>,,,,1,,ANY
312517,BLOCK,1,,<empty>,,,,1,,ANY
312521,BLOCK,1,,<empty>,,,,1,,ANY
312527,BLOCK,1,,<empty>,,,,1,,ANY
312533,BLOCK,1,,<empty>,,,,1,,ANY
312539,BLOCK,1,,<empty>,,,,1,,ANY
312546,BLOCK,1,,<empty>,,,,1,,ANY
312553,BLOCK,1,,<empty>,,,,1,,ANY
312558,BLOCK,1,,<empty>,,,,1,,ANY
312564,BLOCK,1,,<empty>,,,,1,,ANY
312570,BLOCK,1,,<empty>,,,,1,,ANY
312576,BLOCK,1,,<empty>,,,,1,,ANY
312580,BLOCK,1,,<empty>,,,,1,,ANY
312585,BLOCK,1,,<empty>,,,,1,,ANY
312590,BLOCK,1,,<empty>,,,,1,,ANY
312595,BLOCK,1,,<empty>,,,,1,,ANY
312600,BLOCK,1,,<empty>,,,,1,,ANY
312610,BLOCK,1,,<empty>,,,,1,,ANY
312614,BLOCK,1,,<empty>,,,,1,,ANY
312619,BLOCK,1,,<empty>,,,,1,,ANY
312624,BLOCK,1,,<empty>,,,,1,,ANY
312635,BLOCK,1,,<empty>,,,,1,,ANY
312639,BLOCK,1,,<empty>,,,,1,,ANY
312645,BLOCK,1,,<empty>,,,,1,,ANY
312649,BLOCK,1,,<empty>,,,,1,,ANY
312654,BLOCK,1,,<empty>,,,,1,,ANY
312659,BLOCK,1,,<empty>,,,,1,,ANY
312663,BLOCK,1,,<empty>,,,,1,,ANY
312669,BLOCK,1,,<empty>,,,,1,,ANY
312673,BLOCK,1,,<empty>,,,,1,,ANY
312677,BLOCK,1,,<empty>,,,,1,,ANY
312681,BLOCK,1,,<empty>,,,,1,,ANY
312689,BLOCK,1,,<empty>,,,,1,,ANY
312693,BLOCK,1,,<empty>,,,,1,,ANY
312699,BLOCK,1,,<empty>,,,,1,,ANY
312704,BLOCK,1,,<empty>,,,,1,,ANY
312709,BLOCK,1,,<empty>,,,,1,,ANY
312712,BLOCK,1,,<empty>,,,,1,,ANY
312717,BLOCK,1,,<empty>,,,,1,,ANY
312720,BLOCK,1,,<empty>,,,,1,,ANY
312724,BLOCK,1,,<empty>,,,,1,,ANY
312729,BLOCK,1,,<empty>,,,,1,,ANY
312733,BLOCK,1,,<empty>,,,,1,,ANY
312736,BLOCK,1,,<empty>,,,,1,,ANY
312741,BLOCK,1,,<empty>,,,,1,,ANY
312746,BLOCK,1,,<empty>,,,,1,,ANY
312750,BLOCK,1,,<empty>,,,,1,,ANY
312755,BLOCK,1,,<empty>,,,,1,,ANY
312758,BLOCK,1,,<empty>,,,,1,,ANY
312761,BLOCK,1,,<empty>,,,,1,,ANY
312765,BLOCK,1,,<empty>,,,,1,,ANY
312770,BLOCK,1,,<empty>,,,,1,,ANY
312776,BLOCK,1,,<empty>,,,,1,,ANY
312781,BLOCK,1,,<empty>,,,,1,,ANY
312786,BLOCK,1,,<empty>,,,,1,,ANY
312790,BLOCK,1,,<empty>,,,,1,,ANY
312794,BLOCK,1,,<empty>,,,,1,,ANY
312799,BLOCK,1,,<empty>,,,,1,,ANY
312803,BLOCK,1,,<empty>,,,,1,,ANY
312807,BLOCK,1,,<empty>,,,,1,,ANY
312810,BLOCK,1,,<empty>,,,,1,,ANY
312815,BLOCK,1,,<empty>,,,,1,,ANY
312821,BLOCK,1,,<empty>,,,,1,,ANY
312826,BLOCK,1,,<empty>,,,,1,,ANY
312835,BLOCK,1,,<empty>,,,,1,,ANY
312840,BLOCK,1,,<empty>,,,,1,,ANY
312845,BLOCK,1,,<empty>,,,,1,,ANY
312850,BLOCK,1,,<empty>,,,,1,,ANY
312853,BLOCK,1,,<empty>,,,,1,,ANY
312860,BLOCK,1,,<empty>,,,,1,,ANY
312864,BLOCK,1,,<empty>,,,,1,,ANY
312871,BLOCK,1,,<empty>,,,,1,,ANY
312875,BLOCK,1,,<empty>,,,,1,,ANY
312879,BLOCK,1,,<empty>,,,,1,,ANY
312883,BLOCK,1,,<empty>,,,,1,,ANY
312890,BLOCK,1,,<empty>,,,,1,,ANY
312895,BLOCK,1,,<empty>,,,,1,,ANY
312900,BLOCK,1,,<empty>,,,,1,,ANY
312907,BLOCK,1,,<empty>,,,,1,,ANY
312912,BLOCK,1,,<empty>,,,,1,,ANY
312918,BLOCK,1,,<empty>,,,,1,,ANY
312922,BLOCK,1,,<empty>,,,,1,,ANY
312926,BLOCK,1,,<empty>,,,,1,,ANY
312933,BLOCK,1,,<empty>,,,,1,,ANY
312936,BLOCK,1,,<empty>,,,,1,,ANY
312942,BLOCK,1,,<empty>,,,,1,,ANY
312945,BLOCK,1,,<empty>,,,,1,,ANY
312953,BLOCK,1,,<empty>,,,,1,,ANY
312961,BLOCK,1,,<empty>,,,,1,,ANY
312964,BLOCK,1,,<empty>,,,,1,,ANY
312968,BLOCK,1,,<empty>,,,,1,,ANY
312973,BLOCK,1,,<empty>,,,,1,,ANY
312977,BLOCK,1,,<empty>,,,,1,,ANY
312981,BLOCK,1,,<empty>,,,,1,,ANY
312985,BLOCK,1,,<empty>,,,,1,,ANY
312991,BLOCK,1,,<empty>,,,,1,,ANY
312997,BLOCK,1,,<empty>,,,,1,,ANY
313003,BLOCK,1,,<empty>,,,,1,,ANY
313007,BLOCK,1,,<empty>,,,,1,,ANY
313012,BLOCK,1,,<empty>,,,,1,,ANY
313020,BLOCK,1,,<empty>,,,,1,,ANY
313027,BLOCK,1,,<empty>,,,,1,,ANY
313033,BLOCK,1,,<empty>,,,,1,,ANY
313039,BLOCK,1,,<empty>,,,,1,,ANY
313044,BLOCK,1,,<empty>,,,,1,,ANY
313049,BLOCK,1,,<empty>,,,,1,,ANY
313057,BLOCK,1,,<empty>,,,,1,,ANY
313061,BLOCK,1,,<empty>,,,,1,,ANY
313065,BLOCK,1,,<empty>,,,,1,,ANY
313069,BLOCK,1,,<empty>,,,,1,,ANY
313073,BLOCK,1,,<empty>,,,,1,,ANY
313077,BLOCK,1,,<empty>,,,,1,,ANY
313081,BLOCK,1,,<empty>,,,,1,,ANY
313085,BLOCK,1,,<empty>,,,,1,,ANY
313091,BLOCK,1,,<empty>,,,,1,,ANY
313096,BLOCK,1,,<empty>,,,,1,,ANY
313101,BLOCK,1,,<empty>,,,,1,,ANY
313107,BLOCK,1,,<empty>,,,,1,,ANY
313110,BLOCK,1,,<empty>,,,,1,,ANY
313114,BLOCK,1,,<empty>,,,,1,,ANY
313117,BLOCK,1,,<empty>,,,,1,,ANY
313120,BLOCK,1,,<empty>,,,,1,,ANY
313128,BLOCK,1,,<empty>,,,,1,,ANY
313132,BLOCK,1,,<empty>,,,,1,,ANY
313136,BLOCK,1,,<empty>,,,,1,,ANY
313139,BLOCK,1,,<empty>,,,,1,,ANY
313143,BLOCK,1,,<empty>,,,,1,,ANY
313147,BLOCK,1,,<empty>,,,,1,,ANY
313152,BLOCK,1,,<empty>,,,,1,,ANY
313155,BLOCK,1,,<empty>,,,,1,,ANY
313162,BLOCK,1,,<empty>,,,,1,,ANY
313167,BLOCK,1,,<empty>,,,,1,,ANY
313174,BLOCK,1,,<empty>,,,,1,,ANY
313179,BLOCK,1,,<empty>,,,,1,,ANY
313188,BLOCK,1,,<empty>,,,,1,,ANY
313194,BLOCK,1,,<empty>,,,,1,,ANY
313201,BLOCK,1,,<empty>,,,,1,,ANY
313210,BLOCK,1,,<empty>,,,,1,,ANY
313213,BLOCK,1,,<empty>,,,,1,,ANY
313218,BLOCK,1,,<empty>,,,,1,,ANY
313223,BLOCK,1,,<empty>,,,,1,,ANY
313226,BLOCK,1,,<empty>,,,,1,,ANY
313231,BLOCK,1,,<empty>,,,,1,,ANY
313239,BLOCK,1,,<empty>,,,,1,,ANY
313245,BLOCK,1,,<empty>,,,,1,,ANY
313249,BLOCK,1,,<empty>,,,,1,,ANY
313256,BLOCK,1,,<empty>,,,,1,,ANY
313260,BLOCK,1,,<empty>,,,,1,,ANY
313264,BLOCK,1,,<empty>,,,,1,,ANY
313268,BLOCK,1,,<empty>,,,,1,,ANY
313272,BLOCK,1,,<empty>,,,,1,,ANY
313278,BLOCK,1,,<empty>,,,,1,,ANY
313284,BLOCK,1,,<empty>,,,,1,,ANY
313288,BLOCK,1,,<empty>,,,,1,,ANY
313292,BLOCK,1,,<empty>,,,,1,,ANY
313297,BLOCK,1,,<empty>,,,,1,,ANY
313302,BLOCK,1,,<empty>,,,,1,,ANY
313309,BLOCK,1,,<empty>,,,,1,,ANY
313315,BLOCK,1,,<empty>,,,,1,,ANY
313319,BLOCK,1,,<empty>,,,,1,,ANY
313325,BLOCK,1,,<empty>,,,,1,,ANY
313328,BLOCK,1,,<empty>,,,,1,,ANY
313334,BLOCK,1,,<empty>,,,,1,,ANY
313338,BLOCK,1,,<empty>,,,,1,,ANY
313345,BLOCK,1,,<empty>,,,,1,,ANY
313348,BLOCK,1,,<empty>,,,,1,,ANY
313351,BLOCK,1,,<empty>,,,,1,,ANY
313358,BLOCK,1,,<empty>,,,,1,,ANY
313365,BLOCK,1,,<empty>,,,,1,,ANY
313369,BLOCK,1,,<empty>,,,,1,,ANY
313375,BLOCK,1,,<empty>,,,,1,,ANY
313379,BLOCK,1,,<empty>,,,,1,,ANY
313383,BLOCK,1,,<empty>,,,,1,,ANY
313389,BLOCK,1,,<empty>,,,,1,,ANY
313396,BLOCK,1,,<empty>,,,,1,,ANY
313400,BLOCK,1,,<empty>,,,,1,,ANY
313404,BLOCK,1,,<empty>,,,,1,,ANY
313410,BLOCK,1,,<empty>,,,,1,,ANY
313414,BLOCK,1,,<empty>,,,,1,,ANY
313419,BLOCK,1,,<empty>,,,,1,,ANY
313425,BLOCK,1,,<empty>,,,,1,,ANY
313428,BLOCK,1,,<empty>,,,,1,,ANY
313433,BLOCK,1,,<empty>,,,,1,,ANY
313436,BLOCK,1,,<empty>,,,,1,,ANY
313442,BLOCK,1,,<empty>,,,,1,,ANY
313447,BLOCK,1,,<empty>,,,,1,,ANY
313451,BLOCK,1,,<empty>,,,,1,,ANY
313455,BLOCK,1,,<empty>,,,,1,,ANY
313459,BLOCK,1,,<empty>,,,,1,,ANY
313463,BLOCK,1,,<empty>,,,,1,,ANY
313469,BLOCK,1,,<empty>,,,,1,,ANY
313475,BLOCK,1,,<empty>,,,,1,,ANY
313481,BLOCK,1,,<empty>,,,,1,,ANY
313486,BLOCK,1,,<empty>,,,,1,,ANY
313490,BLOCK,1,,<empty>,,,,1,,ANY
313494,BLOCK,1,,<empty>,,,,1,,ANY
313498,BLOCK,1,,<empty>,,,,1,,ANY
313504,BLOCK,1,,<empty>,,,,1,,ANY
313509,BLOCK,1,,<empty>,,,,1,,ANY
313514,BLOCK,1,,<empty>,,,,1,,ANY
313518,BLOCK,1,,<empty>,,,,1,,ANY
313526,BLOCK,1,,<empty>,,,,1,,ANY
313532,BLOCK,1,,<empty>,,,,1,,ANY
313535,BLOCK,1,,<empty>,,,,1,,ANY
313539,BLOCK,1,,<empty>,,,,1,,ANY
313543,BLOCK,1,,<empty>,,,,1,,ANY
313547,BLOCK,1,,<empty>,,,,1,,ANY
313550,BLOCK,1,,<empty>,,,,1,,ANY
313555,BLOCK,1,,<empty>,,,,1,,ANY
313562,BLOCK,1,,<empty>,,,,1,,ANY
313566,BLOCK,1,,<empty>,,,,1,,ANY
313572,BLOCK,1,,<empty>,,,,1,,ANY
313576,BLOCK,1,,<empty>,,,,1,,ANY
313581,BLOCK,1,,<empty>,,,,1,,ANY
313586,BLOCK,1,,<empty>,,,,1,,ANY
313591,BLOCK,1,,<empty>,,,,1,,ANY
313594,BLOCK,1,,<empty>,,,,1,,ANY
313599,BLOCK,1,,<empty>,,,,1,,ANY
313603,BLOCK,1,,<empty>,,,,1,,ANY
313607,BLOCK,1,,<empty>,,,,1,,ANY
313613,BLOCK,1,,<empty>,,,,1,,ANY
313617,BLOCK,1,,<empty>,,,,1,,ANY
313622,BLOCK,1,,<empty>,,,,1,,ANY
313627,BLOCK,1,,<empty>,,,,1,,ANY
313631,BLOCK,1,,<empty>,,,,1,,ANY
313635,BLOCK,1,,<empty>,,,,1,,ANY
313640,BLOCK,1,,<empty>,,,,1,,ANY
313645,BLOCK,1,,<empty>,,,,1,,ANY
313649,BLOCK,1,,<empty>,,,,1,,ANY
313653,BLOCK,1,,<empty>,,,,1,,ANY
313661,BLOCK,1,,<empty>,,,,1,,ANY
313666,BLOCK,1,,<empty>,,,,1,,ANY
313670,BLOCK,1,,<empty>,,,,1,,ANY
313675,BLOCK,1,,<empty>,,,,1,,ANY
313679,BLOCK,1,,<empty>,,,,1,,ANY
313684,BLOCK,1,,<empty>,,,,1,,ANY
313689,BLOCK,1,,<empty>,,,,1,,ANY
313693,BLOCK,1,,<empty>,,,,1,,ANY
313697,BLOCK,1,,<empty>,,,,1,,ANY
313701,BLOCK,1,,<empty>,,,,1,,ANY
313704,BLOCK,1,,<empty>,,,,1,,ANY
313707,BLOCK,1,,<empty>,,,,1,,ANY
313712,BLOCK,1,,<empty>,,,,1,,ANY
313717,BLOCK,1,,<empty>,,,,1,,ANY
313722,BLOCK,1,,<empty>,,,,1,,ANY
313726,BLOCK,1,,<empty>,,,,1,,ANY
313731,BLOCK,1,,<empty>,,,,1,,ANY
313735,BLOCK,1,,<empty>,,,,1,,ANY
313739,BLOCK,1,,<empty>,,,,1,,ANY
313747,BLOCK,1,,<empty>,,,,1,,ANY
313751,BLOCK,1,,<empty>,,,,1,,ANY
313755,BLOCK,1,,<empty>,,,,1,,ANY
313761,BLOCK,1,,<empty>,,,,1,,ANY
313768,BLOCK,1,,<empty>,,,,1,,ANY
313772,BLOCK,1,,<empty>,,,,1,,ANY
313776,BLOCK,1,,<empty>,,,,1,,ANY
313780,BLOCK,1,,<empty>,,,,1,,ANY
313784,BLOCK,1,,<empty>,,,,1,,ANY
313790,BLOCK,1,,<empty>,,,,1,,ANY
313795,BLOCK,1,,<empty>,,,,1,,ANY
313800,BLOCK,1,,<empty>,,,,1,,ANY
313806,BLOCK,1,,<empty>,,,,1,,ANY
313810,BLOCK,1,,<empty>,,,,1,,ANY
313815,BLOCK,1,,<empty>,,,,1,,ANY
313821,BLOCK,1,,<empty>,,,,1,,ANY
313825,BLOCK,1,,<empty>,,,,1,,ANY
313830,BLOCK,1,,<empty>,,,,1,,ANY
313833,BLOCK,1,,<empty>,,,,1,,ANY
313838,BLOCK,1,,<empty>,,,,1,,ANY
313841,BLOCK,1,,<empty>,,,,1,,ANY
313846,BLOCK,1,,<empty>,,,,1,,ANY
313851,BLOCK,1,,<empty>,,,,1,,ANY
313857,BLOCK,1,,<empty>,,,,1,,ANY
313860,BLOCK,1,,<empty>,,,,1,,ANY
313863,BLOCK,1,,<empty>,,,,1,,ANY
313867,BLOCK,1,,<empty>,,,,1,,ANY
313873,BLOCK,1,,<empty>,,,,1,,ANY
313877,BLOCK,1,,<empty>,,,,1,,ANY
313881,BLOCK,1,,<empty>,,,,1,,ANY
313886,BLOCK,1,,<empty>,,,,1,,ANY
313891,BLOCK,1,,<empty>,,,,1,,ANY
313894,BLOCK,1,,<empty>,,,,1,,ANY
313899,BLOCK,1,,<empty>,,,,1,,ANY
313906,BLOCK,1,,<empty>,,,,1,,ANY
313909,BLOCK,1,,<empty>,,,,1,,ANY
313913,BLOCK,1,,<empty>,,,,1,,ANY
313918,BLOCK,1,,<empty>,,,,1,,ANY
313922,BLOCK,1,,<empty>,,,,1,,ANY
313925,BLOCK,1,,<empty>,,,,1,,ANY
313928,BLOCK,1,,<empty>,,,,1,,ANY
313932,BLOCK,1,,<empty>,,,,1,,ANY
313937,BLOCK,1,,<empty>,,,,1,,ANY
313941,BLOCK,1,,<empty>,,,,1,,ANY
313946,BLOCK,1,,<empty>,,,,1,,ANY
313953,BLOCK,1,,<empty>,,,,1,,ANY
313957,BLOCK,1,,<empty>,,,,1,,ANY
313962,BLOCK,1,,<empty>,,,,1,,ANY
313966,BLOCK,1,,<empty>,,,,1,,ANY
313970,BLOCK,1,,<empty>,,,,1,,ANY
313975,BLOCK,1,,<empty>,,,,1,,ANY
313981,BLOCK,1,,<empty>,,,,1,,ANY
313986,BLOCK,1,,<empty>,,,,1,,ANY
313990,BLOCK,1,,<empty>,,,,1,,ANY
313994,BLOCK,1,,<empty>,,,,1,,ANY
313998,BLOCK,1,,<empty>,,,,1,,ANY
314001,BLOCK,1,,<empty>,,,,1,,ANY
314006,BLOCK,1,,<empty>,,,,1,,ANY
314011,BLOCK,1,,<empty>,,,,1,,ANY
314015,BLOCK,1,,<empty>,,,,1,,ANY
314019,BLOCK,1,,<empty>,,,,1,,ANY
314024,BLOCK,1,,<empty>,,,,1,,ANY
314028,BLOCK,1,,<empty>,,,,1,,ANY
314032,BLOCK,1,,<empty>,,,,1,,ANY
314036,BLOCK,1,,<empty>,,,,1,,ANY
314040,BLOCK,1,,<empty>,,,,1,,ANY
314044,BLOCK,1,,<empty>,,,,1,,ANY
314047,BLOCK,1,,<empty>,,,,1,,ANY
314052,BLOCK,1,,<empty>,,,,1,,ANY
314056,BLOCK,1,,<empty>,,,,1,,ANY
314061,BLOCK,1,,<empty>,,,,1,,ANY
314065,BLOCK,1,,<empty>,,,,1,,ANY
314069,BLOCK,1,,<empty>,,,,1,,ANY
314072,BLOCK,1,,<empty>,,,,1,,ANY
314076,BLOCK,1,,<empty>,,,,1,,ANY
314080,BLOCK,1,,<empty>,,,,1,,ANY
314083,BLOCK,1,,<empty>,,,,1,,ANY
314086,BLOCK,1,,<empty>,,,,1,,ANY
314090,BLOCK,1,,<empty>,,,,1,,ANY
314095,BLOCK,1,,<empty>,,,,1,,ANY
314100,BLOCK,1,,<empty>,,,,1,,ANY
314104,BLOCK,1,,<empty>,,,,1,,ANY
314110,BLOCK,1,,<empty>,,,,1,,ANY
314114,BLOCK,1,,<empty>,,,,1,,ANY
314118,BLOCK,1,,<empty>,,,,1,,ANY
314121,BLOCK,1,,<empty>,,,,1,,ANY
314125,BLOCK,1,,<empty>,,,,1,,ANY
314132,BLOCK,1,,<empty>,,,,1,,ANY
314137,BLOCK,1,,<empty>,,,,1,,ANY
314142,BLOCK,1,,<empty>,,,,1,,ANY
314146,BLOCK,1,,<empty>,,,,1,,ANY
314149,BLOCK,1,,<empty>,,,,1,,ANY
314152,BLOCK,1,,<empty>,,,,1,,ANY
314157,BLOCK,1,,<empty>,,,,1,,ANY
314161,BLOCK,1,,<empty>,,,,1,,ANY
314167,BLOCK,1,,<empty>,,,,1,,ANY
314172,BLOCK,1,,<empty>,,,,1,,ANY
314179,BLOCK,1,,<empty>,,,,1,,ANY
314183,BLOCK,1,,<empty>,,,,1,,ANY
314188,BLOCK,1,,<empty>,,,,1,,ANY
314192,BLOCK,1,,<empty>,,,,1,,ANY
314196,BLOCK,1,,<empty>,,,,1,,ANY
314200,BLOCK,1,,<empty>,,,,1,,ANY
314204,BLOCK,1,,<empty>,,,,1,,ANY
314208,BLOCK,1,,<empty>,,,,1,,ANY
314213,BLOCK,1,,<empty>,,,,1,,ANY
314217,BLOCK,1,,<empty>,,,,1,,ANY
314221,BLOCK,1,,<empty>,,,,1,,ANY
314226,BLOCK,1,,<empty>,,,,1,,ANY
314231,BLOCK,1,,<empty>,,,,1,,ANY
314235,BLOCK,1,,<empty>,,,,1,,ANY
314239,BLOCK,1,,<empty>,,,,1,,ANY
314242,BLOCK,1,,<empty>,,,,1,,ANY
314246,BLOCK,1,,<empty>,,,,1,,ANY
314250,BLOCK,1,,<empty>,,,,1,,ANY
314256,BLOCK,1,,<empty>,,,,1,,ANY
314260,BLOCK,1,,<empty>,,,,1,,ANY
314265,BLOCK,1,,<empty>,,,,1,,ANY
314268,BLOCK,1,,<empty>,,,,1,,ANY
314272,BLOCK,1,,<empty>,,,,1,,ANY
314276,BLOCK,1,,<empty>,,,,1,,ANY
314280,BLOCK,1,,<empty>,,,,1,,ANY
314284,BLOCK,1,,<empty>,,,,1,,ANY
314288,BLOCK,1,,<empty>,,,,1,,ANY
314293,BLOCK,1,,<empty>,,,,1,,ANY
314297,BLOCK,1,,<empty>,,,,1,,ANY
314301,BLOCK,1,,<empty>,,,,1,,ANY
314307,BLOCK,1,,<empty>,,,,1,,ANY
314311,BLOCK,1,,<empty>,,,,1,,ANY
314315,BLOCK,1,,<empty>,,,,1,,ANY
314319,BLOCK,1,,<empty>,,,,1,,ANY
314323,BLOCK,1,,<empty>,,,,1,,ANY
314327,BLOCK,1,,<empty>,,,,1,,ANY
314331,BLOCK,1,,<empty>,,,,1,,ANY
314335,BLOCK,1,,<empty>,,,,1,,ANY
314342,BLOCK,1,,<empty>,,,,1,,ANY
314346,BLOCK,1,,<empty>,,,,1,,ANY
314356,BLOCK,1,,<empty>,,,,1,,ANY
314361,BLOCK,1,,<empty>,,,,1,,ANY
314367,BLOCK,1,,<empty>,,,,1,,ANY
314370,BLOCK,1,,<empty>,,,,1,,ANY
314376,BLOCK,1,,<empty>,,,,1,,ANY
314380,BLOCK,1,,<empty>,,,,1,,ANY
314384,BLOCK,1,,<empty>,,,,1,,ANY
314389,BLOCK,1,,<empty>,,,,1,,ANY
314393,BLOCK,1,,<empty>,,,,1,,ANY
314398,BLOCK,1,,<empty>,,,,1,,ANY
314404,BLOCK,1,,<empty>,,,,1,,ANY
314411,BLOCK,1,,<empty>,,,,1,,ANY
314414,BLOCK,1,,<empty>,,,,1,,ANY
314417,BLOCK,1,,<empty>,,,,1,,ANY
314421,BLOCK,1,,<empty>,,,,1,,ANY
314427,BLOCK,1,,<empty>,,,,1,,ANY
314431,BLOCK,1,,<empty>,,,,1,,ANY
314435,BLOCK,1,,<empty>,,,,1,,ANY
314439,BLOCK,1,,<empty>,,,,1,,ANY
314443,BLOCK,1,,<empty>,,,,1,,ANY
314447,BLOCK,1,,<empty>,,,,1,,ANY
314452,BLOCK,1,,<empty>,,,,1,,ANY
314456,BLOCK,1,,<empty>,,,,1,,ANY
314460,BLOCK,1,,<empty>,,,,1,,ANY
314465,BLOCK,1,,<empty>,,,,1,,ANY
314469,BLOCK,1,,<empty>,,,,1,,ANY
314473,BLOCK,1,,<empty>,,,,1,,ANY
314478,BLOCK,1,,<empty>,,,,1,,ANY
314482,BLOCK,1,,<empty>,,,,1,,ANY
314487,BLOCK,1,,<empty>,,,,1,,ANY
314492,BLOCK,1,,<empty>,,,,1,,ANY
314495,BLOCK,1,,<empty>,,,,1,,ANY
314499,BLOCK,1,,<empty>,,,,1,,ANY
314503,BLOCK,1,,<empty>,,,,1,,ANY
314507,BLOCK,1,,<empty>,,,,1,,ANY
314511,BLOCK,1,,<empty>,,,,1,,ANY
314516,BLOCK,1,,<empty>,,,,1,,ANY
314521,BLOCK,1,,<empty>,,,,1,,ANY
314525,BLOCK,1,,<empty>,,,,1,,ANY
314530,BLOCK,1,,<empty>,,,,1,,ANY
314533,BLOCK,1,,<empty>,,,,1,,ANY
314538,BLOCK,1,,<empty>,,,,1,,ANY
314543,BLOCK,1,,<empty>,,,,1,,ANY
314547,BLOCK,1,,<empty>,,,,1,,ANY
314552,BLOCK,1,,<empty>,,,,1,,ANY
314556,BLOCK,1,,<empty>,,,,1,,ANY
314560,BLOCK,1,,<empty>,,,,1,,ANY
314564,BLOCK,1,,<empty>,,,,1,,ANY
314570,BLOCK,1,,<empty>,,,,1,,ANY
314574,BLOCK,1,,<empty>,,,,1,,ANY
314578,BLOCK,1,,<empty>,,,,1,,ANY
314583,BLOCK,1,,<empty>,,,,1,,ANY
314589,BLOCK,1,,<empty>,,,,1,,ANY
314596,BLOCK,1,,<empty>,,,,1,,ANY
314601,BLOCK,1,,<empty>,,,,1,,ANY
314609,BLOCK,1,,<empty>,,,,1,,ANY
314614,BLOCK,1,,<empty>,,,,1,,ANY
314618,BLOCK,1,,<empty>,,,,1,,ANY
314624,BLOCK,1,,<empty>,,,,1,,ANY
314629,BLOCK,1,,<empty>,,,,1,,ANY
314633,BLOCK,1,,<empty>,,,,1,,ANY
314638,BLOCK,1,,<empty>,,,,1,,ANY
314643,BLOCK,1,,<empty>,,,,1,,ANY
314649,BLOCK,1,,<empty>,,,,1,,ANY
314653,BLOCK,1,,<empty>,,,,1,,ANY
314659,BLOCK,1,,<empty>,,,,1,,ANY
314666,BLOCK,1,,<empty>,,,,1,,ANY
314671,BLOCK,1,,<empty>,,,,1,,ANY
314674,BLOCK,1,,<empty>,,,,1,,ANY
314679,BLOCK,1,,<empty>,,,,1,,ANY
314685,BLOCK,1,,<empty>,,,,1,,ANY
314690,BLOCK,1,,<empty>,,,,1,,ANY
314694,BLOCK,1,,<empty>,,,,1,,ANY
314698,BLOCK,1,,<empty>,,,,1,,ANY
314702,BLOCK,1,,<empty>,,,,1,,ANY
314708,BLOCK,1,,<empty>,,,,1,,ANY
314715,BLOCK,1,,<empty>,,,,1,,ANY
314720,BLOCK,1,,<empty>,,,,1,,ANY
314725,BLOCK,1,,<empty>,,,,1,,ANY
314729,BLOCK,1,,<empty>,,,,1,,ANY
314733,BLOCK,1,,<empty>,,,,1,,ANY
314739,BLOCK,1,,<empty>,,,,1,,ANY
314743,BLOCK,1,,<empty>,,,,1,,ANY
314749,BLOCK,1,,<empty>,,,,1,,ANY
314755,BLOCK,1,,<empty>,,,,1,,ANY
314761,BLOCK,1,,<empty>,,,,1,,ANY
314766,BLOCK,1,,<empty>,,,,1,,ANY
314772,BLOCK,1,,<empty>,,,,1,,ANY
314776,BLOCK,1,,<empty>,,,,1,,ANY
314780,BLOCK,1,,<empty>,,,,1,,ANY
314785,BLOCK,1,,<empty>,,,,1,,ANY
314790,BLOCK,1,,<empty>,,,,1,,ANY
314795,BLOCK,1,,<empty>,,,,1,,ANY
314800,BLOCK,1,,<empty>,,,,1,,ANY
314805,BLOCK,1,,<empty>,,,,1,,ANY
314809,BLOCK,1,,<empty>,,,,1,,ANY
314815,BLOCK,1,,<empty>,,,,1,,ANY
314820,BLOCK,1,,<empty>,,,,1,,ANY
314824,BLOCK,1,,<empty>,,,,1,,ANY
314831,BLOCK,1,,<empty>,,,,1,,ANY
314835,BLOCK,1,,<empty>,,,,1,,ANY
314839,BLOCK,1,,<empty>,,,,1,,ANY
314843,BLOCK,1,,<empty>,,,,1,,ANY
314848,BLOCK,1,,<empty>,,,,1,,ANY
314856,BLOCK,1,,<empty>,,,,1,,ANY
314861,BLOCK,1,,<empty>,,,,1,,ANY
314866,BLOCK,1,,<empty>,,,,1,,ANY
314870,BLOCK,1,,<empty>,,,,1,,ANY
314875,BLOCK,1,,<empty>,,,,1,,ANY
314880,BLOCK,1,,<empty>,,,,1,,ANY
314885,BLOCK,1,,<empty>,,,,1,,ANY
314890,BLOCK,1,,<empty>,,,,1,,ANY
314894,BLOCK,1,,<empty>,,,,1,,ANY
314900,BLOCK,1,,<empty>,,,,1,,ANY
314904,BLOCK,1,,<empty>,,,,1,,ANY
314910,BLOCK,1,,<empty>,,,,1,,ANY
314916,BLOCK,1,,<empty>,,,,1,,ANY
314921,BLOCK,1,,<empty>,,,,1,,ANY
314926,BLOCK,1,,<empty>,,,,1,,ANY
314931,BLOCK,1,,<empty>,,,,1,,ANY
314938,BLOCK,1,,<empty>,,,,1,,ANY
314944,BLOCK,1,,<empty>,,,,1,,ANY
314950,BLOCK,1,,<empty>,,,,1,,ANY
314954,BLOCK,1,,<empty>,,,,1,,ANY
314959,BLOCK,1,,<empty>,,,,1,,ANY
314963,BLOCK,1,,<empty>,,,,1,,ANY
314969,BLOCK,1,,<empty>,,,,1,,ANY
314974,BLOCK,1,,<empty>,,,,1,,ANY
314978,BLOCK,1,,<empty>,,,,1,,ANY
314984,BLOCK,1,,<empty>,,,,1,,ANY
314990,BLOCK,1,,<empty>,,,,1,,ANY
314995,BLOCK,1,,<empty>,,,,1,,ANY
314998,BLOCK,1,,<empty>,,,,1,,ANY
315004,BLOCK,1,,<empty>,,,,1,,ANY
315008,BLOCK,1,,<empty>,,,,1,,ANY
315011,BLOCK,1,,<empty>,,,,1,,ANY
315015,BLOCK,1,,<empty>,,,,1,,ANY
315020,BLOCK,1,,<empty>,,,,1,,ANY
315024,BLOCK,1,,<empty>,,,,1,,ANY
315032,BLOCK,1,,<empty>,,,,1,,ANY
315037,BLOCK,1,,<empty>,,,,1,,ANY
315041,BLOCK,1,,<empty>,,,,1,,ANY
315045,BLOCK,1,,<empty>,,,,1,,ANY
315052,BLOCK,1,,<empty>,,,,1,,ANY
315057,BLOCK,1,,<empty>,,,,1,,ANY
315063,BLOCK,1,,<empty>,,,,1,,ANY
315070,BLOCK,1,,<empty>,,,,1,,ANY
315075,BLOCK,1,,<empty>,,,,1,,ANY
315080,BLOCK,1,,<empty>,,,,1,,ANY
315088,BLOCK,1,,<empty>,,,,1,,ANY
315093,BLOCK,1,,<empty>,,,,1,,ANY
315097,BLOCK,1,,<empty>,,,,1,,ANY
315101,BLOCK,1,,<empty>,,,,1,,ANY
315105,BLOCK,1,,<empty>,,,,1,,ANY
315112,BLOCK,1,,<empty>,,,,1,,ANY
315118,BLOCK,1,,<empty>,,,,1,,ANY
315121,BLOCK,1,,<empty>,,,,1,,ANY
315125,BLOCK,1,,<empty>,,,,1,,ANY
315131,BLOCK,1,,<empty>,,,,1,,ANY
315134,BLOCK,1,,<empty>,,,,1,,ANY
315137,BLOCK,1,,<empty>,,,,1,,ANY
315140,BLOCK,1,,<empty>,,,,1,,ANY
315146,BLOCK,1,,<empty>,,,,1,,ANY
315151,BLOCK,1,,<empty>,,,,1,,ANY
315154,BLOCK,1,,<empty>,,,,1,,ANY
315157,BLOCK,1,,<empty>,,,,1,,ANY
315161,BLOCK,1,,<empty>,,,,1,,ANY
315165,BLOCK,1,,<empty>,,,,1,,ANY
315169,BLOCK,1,,<empty>,,,,1,,ANY
315173,BLOCK,1,,<empty>,,,,1,,ANY
315177,BLOCK,1,,<empty>,,,,1,,ANY
315181,BLOCK,1,,<empty>,,,,1,,ANY
315187,BLOCK,1,,<empty>,,,,1,,ANY
315200,BLOCK,1,,<empty>,,,,1,,ANY
315205,BLOCK,1,,<empty>,,,,1,,ANY
315209,BLOCK,1,,<empty>,,,,1,,ANY
315213,BLOCK,1,,<empty>,,,,1,,ANY
315218,BLOCK,1,,<empty>,,,,1,,ANY
315223,BLOCK,1,,<empty>,,,,1,,ANY
315229,BLOCK,1,,<empty>,,,,1,,ANY
315236,BLOCK,1,,<empty>,,,,1,,ANY
315241,BLOCK,1,,<empty>,,,,1,,ANY
315246,BLOCK,1,,<empty>,,,,1,,ANY
315251,BLOCK,1,,<empty>,,,,1,,ANY
315255,BLOCK,1,,<empty>,,,,1,,ANY
315259,BLOCK,1,,<empty>,,,,1,,ANY
315262,BLOCK,1,,<empty>,,,,1,,ANY
315265,BLOCK,1,,<empty>,,,,1,,ANY
315269,BLOCK,1,,<empty>,,,,1,,ANY
315273,BLOCK,1,,<empty>,,,,1,,ANY
315277,BLOCK,1,,<empty>,,,,1,,ANY
315281,BLOCK,1,,<empty>,,,,1,,ANY
315284,BLOCK,1,,<empty>,,,,1,,ANY
315288,BLOCK,1,,<empty>,,,,1,,ANY
315292,BLOCK,1,,<empty>,,,,1,,ANY
315296,BLOCK,1,,<empty>,,,,1,,ANY
315300,BLOCK,1,,<empty>,,,,1,,ANY
315304,BLOCK,1,,<empty>,,,,1,,ANY
315308,BLOCK,1,,<empty>,,,,1,,ANY
315312,BLOCK,1,,<empty>,,,,1,,ANY
315320,BLOCK,1,,<empty>,,,,1,,ANY
315324,BLOCK,1,,<empty>,,,,1,,ANY
315330,BLOCK,1,,<empty>,,,,1,,ANY
315334,BLOCK,1,,<empty>,,,,1,,ANY
315338,BLOCK,1,,<empty>,,,,1,,ANY
315342,BLOCK,1,,<empty>,,,,1,,ANY
315346,BLOCK,1,,<empty>,,,,1,,ANY
315352,BLOCK,1,,<empty>,,,,1,,ANY
315357,BLOCK,1,,<empty>,,,,1,,ANY
315362,BLOCK,1,,<empty>,,,,1,,ANY
315366,BLOCK,1,,<empty>,,,,1,,ANY
315371,BLOCK,1,,<empty>,,,,1,,ANY
315377,BLOCK,1,,<empty>,,,,1,,ANY
315384,BLOCK,1,,<empty>,,,,1,,ANY
315389,BLOCK,1,,<empty>,,,,1,,ANY
315394,BLOCK,1,,<empty>,,,,1,,ANY
315399,BLOCK,1,,<empty>,,,,1,,ANY
315403,BLOCK,1,,<empty>,,,,1,,ANY
315407,BLOCK,1,,<empty>,,,,1,,ANY
315411,BLOCK,1,,<empty>,,,,1,,ANY
315418,BLOCK,1,,<empty>,,,,1,,ANY
315422,BLOCK,1,,<empty>,,,,1,,ANY
315429,BLOCK,1,,<empty>,,,,1,,ANY
315433,BLOCK,1,,<empty>,,,,1,,ANY
315437,BLOCK,1,,<empty>,,,,1,,ANY
315442,BLOCK,1,,<empty>,,,,1,,ANY
315448,BLOCK,1,,<empty>,,,,1,,ANY
315454,BLOCK,1,,<empty>,,,,1,,ANY
315458,BLOCK,1,,<empty>,,,,1,,ANY
315465,BLOCK,1,,<empty>,,,,1,,ANY
315471,BLOCK,1,,<empty>,,,,1,,ANY
315475,BLOCK,1,,<empty>,,,,1,,ANY
315479,BLOCK,1,,<empty>,,,,1,,ANY
315482,BLOCK,1,,<empty>,,,,1,,ANY
315487,BLOCK,1,,<empty>,,,,1,,ANY
315493,BLOCK,1,,<empty>,,,,1,,ANY
315497,BLOCK,1,,<empty>,,,,1,,ANY
315501,BLOCK,1,,<empty>,,,,1,,ANY
315506,BLOCK,1,,<empty>,,,,1,,ANY
315511,BLOCK,1,,<empty>,,,,1,,ANY
315515,BLOCK,1,,<empty>,,,,1,,ANY
315519,BLOCK,1,,<empty>,,,,1,,ANY
315523,BLOCK,1,,<empty>,,,,1,,ANY
315531,BLOCK,1,,<empty>,,,,1,,ANY
315535,BLOCK,1,,<empty>,,,,1,,ANY
315540,BLOCK,1,,<empty>,,,,1,,ANY
315544,BLOCK,1,,<empty>,,,,1,,ANY
315551,BLOCK,1,,<empty>,,,,1,,ANY
315557,BLOCK,1,,<empty>,,,,1,,ANY
315565,BLOCK,1,,<empty>,,,,1,,ANY
315570,BLOCK,1,,<empty>,,,,1,,ANY
315576,BLOCK,1,,<empty>,,,,1,,ANY
315580,BLOCK,1,,<empty>,,,,1,,ANY
315585,BLOCK,1,,<empty>,,,,1,,ANY
315590,BLOCK,1,,<empty>,,,,1,,ANY
315595,BLOCK,1,,<empty>,,,,1,,ANY
315600,BLOCK,1,,<empty>,,,,1,,ANY
315605,BLOCK,1,,<empty>,,,,1,,ANY
315609,BLOCK,1,,<empty>,,,,1,,ANY
315613,BLOCK,1,,<empty>,,,,1,,ANY
315617,BLOCK,1,,<empty>,,,,1,,ANY
315622,BLOCK,1,,<empty>,,,,1,,ANY
315627,BLOCK,1,,<empty>,,,,1,,ANY
315631,BLOCK,1,,<empty>,,,,1,,ANY
315636,BLOCK,1,,<empty>,,,,1,,ANY
315641,BLOCK,1,,<empty>,,,,1,,ANY
315648,BLOCK,1,,<empty>,,,,1,,ANY
315653,BLOCK,1,,<empty>,,,,1,,ANY
315657,BLOCK,1,,<empty>,,,,1,,ANY
315662,BLOCK,1,,<empty>,,,,1,,ANY
315666,BLOCK,1,,<empty>,,,,1,,ANY
315672,BLOCK,1,,<empty>,,,,1,,ANY
315678,BLOCK,1,,<empty>,,,,1,,ANY
315682,BLOCK,1,,<empty>,,,,1,,ANY
315685,BLOCK,1,,<empty>,,,,1,,ANY
315690,BLOCK,1,,<empty>,,,,1,,ANY
315696,BLOCK,1,,<empty>,,,,1,,ANY
315702,BLOCK,1,,<empty>,,,,1,,ANY
315707,BLOCK,1,,<empty>,,,,1,,ANY
315712,BLOCK,1,,<empty>,,,,1,,ANY
315717,BLOCK,1,,<empty>,,,,1,,ANY
315726,BLOCK,1,,<empty>,,,,1,,ANY
315729,BLOCK,1,,<empty>,,,,1,,ANY
315733,BLOCK,1,,<empty>,,,,1,,ANY
315739,BLOCK,1,,<empty>,,,,1,,ANY
315742,BLOCK,1,,<empty>,,,,1,,ANY
315747,BLOCK,1,,<empty>,,,,1,,ANY
315750,BLOCK,1,,<empty>,,,,1,,ANY
315756,BLOCK,1,,<empty>,,,,1,,ANY
315760,BLOCK,1,,<empty>,,,,1,,ANY
315764,BLOCK,1,,<empty>,,,,1,,ANY
315770,BLOCK,1,,<empty>,,,,1,,ANY
315774,BLOCK,1,,<empty>,,,,1,,ANY
315778,BLOCK,1,,<empty>,,,,1,,ANY
315782,BLOCK,1,,<empty>,,,,1,,ANY
315786,BLOCK,1,,<empty>,,,,1,,ANY
315790,BLOCK,1,,<empty>,,,,1,,ANY
315794,BLOCK,1,,<empty>,,,,1,,ANY
315798,BLOCK,1,,<empty>,,,,1,,ANY
315802,BLOCK,1,,<empty>,,,,1,,ANY
315806,BLOCK,1,,<empty>,,,,1,,ANY
315810,BLOCK,1,,<empty>,,,,1,,ANY
315815,BLOCK,1,,<empty>,,,,1,,ANY
315820,BLOCK,1,,<empty>,,,,1,,ANY
315825,BLOCK,1,,<empty>,,,,1,,ANY
315830,BLOCK,1,,<empty>,,,,1,,ANY
315835,BLOCK,1,,<empty>,,,,1,,ANY
315840,BLOCK,1,,<empty>,,,,1,,ANY
315845,BLOCK,1,,<empty>,,,,1,,ANY
315850,BLOCK,1,,<empty>,,,,1,,ANY
315855,BLOCK,1,,<empty>,,,,1,,ANY
315860,BLOCK,1,,<empty>,,,,1,,ANY
315865,BLOCK,1,,<empty>,,,,1,,ANY
315870,BLOCK,1,,<empty>,,,,1,,ANY
315875,BLOCK,1,,<empty>,,,,1,,ANY
315879,BLOCK,1,,<empty>,,,,1,,ANY
315884,BLOCK,1,,<empty>,,,,1,,ANY
315890,BLOCK,1,,<empty>,,,,1,,ANY
315898,BLOCK,1,,<empty>,,,,1,,ANY
315903,BLOCK,1,,<empty>,,,,1,,ANY
315910,BLOCK,1,,<empty>,,,,1,,ANY
315917,BLOCK,1,,<empty>,,,,1,,ANY
315922,BLOCK,1,,<empty>,,,,1,,ANY
315927,BLOCK,1,,<empty>,,,,1,,ANY
315932,BLOCK,1,,<empty>,,,,1,,ANY
315936,BLOCK,1,,<empty>,,,,1,,ANY
315941,BLOCK,1,,<empty>,,,,1,,ANY
315945,BLOCK,1,,<empty>,,,,1,,ANY
315951,BLOCK,1,,<empty>,,,,1,,ANY
315954,BLOCK,1,,<empty>,,,,1,,ANY
315959,BLOCK,1,,<empty>,,,,1,,ANY
315963,BLOCK,1,,<empty>,,,,1,,ANY
315969,BLOCK,1,,<empty>,,,,1,,ANY
315977,BLOCK,1,,<empty>,,,,1,,ANY
315980,BLOCK,1,,<empty>,,,,1,,ANY
315984,BLOCK,1,,<empty>,,,,1,,ANY
315989,BLOCK,1,,<empty>,,,,1,,ANY
315992,BLOCK,1,,<empty>,,,,1,,ANY
315998,BLOCK,1,,<empty>,,,,1,,ANY
316002,BLOCK,1,,<empty>,,,,1,,ANY
316007,BLOCK,1,,<empty>,,,,1,,ANY
316012,BLOCK,1,,<empty>,,,,1,,ANY
316017,BLOCK,1,,<empty>,,,,1,,ANY
316023,BLOCK,1,,<empty>,,,,1,,ANY
316027,BLOCK,1,,<empty>,,,,1,,ANY
316030,BLOCK,1,,<empty>,,,,1,,ANY
316034,BLOCK,1,,<empty>,,,,1,,ANY
316040,BLOCK,1,,<empty>,,,,1,,ANY
316043,BLOCK,1,,<empty>,,,,1,,ANY
316050,BLOCK,1,,<empty>,,,,1,,ANY
316055,BLOCK,1,,<empty>,,,,1,,ANY
316061,BLOCK,1,,<empty>,,,,1,,ANY
316065,BLOCK,1,,<empty>,,,,1,,ANY
316069,BLOCK,1,,<empty>,,,,1,,ANY
316075,BLOCK,1,,<empty>,,,,1,,ANY
316079,BLOCK,1,,<empty>,,,,1,,ANY
316083,BLOCK,1,,<empty>,,,,1,,ANY
316087,BLOCK,1,,<empty>,,,,1,,ANY
316092,BLOCK,1,,<empty>,,,,1,,ANY
316099,BLOCK,1,,<empty>,,,,1,,ANY
316103,BLOCK,1,,<empty>,,,,1,,ANY
316107,BLOCK,1,,<empty>,,,,1,,ANY
316113,BLOCK,1,,<empty>,,,,1,,ANY
316118,BLOCK,1,,<empty>,,,,1,,ANY
316124,BLOCK,1,,<empty>,,,,1,,ANY
316128,BLOCK,1,,<empty>,,,,1,,ANY
316134,BLOCK,1,,<empty>,,,,1,,ANY
316140,BLOCK,1,,<empty>,,,,1,,ANY
316145,BLOCK,1,,<empty>,,,,1,,ANY
316151,BLOCK,1,,<empty>,,,,1,,ANY
316156,BLOCK,1,,<empty>,,,,1,,ANY
316164,BLOCK,1,,<empty>,,,,1,,ANY
316170,BLOCK,1,,<empty>,,,,1,,ANY
316174,BLOCK,1,,<empty>,,,,1,,ANY
316179,BLOCK,1,,<empty>,,,,1,,ANY
316183,BLOCK,1,,<empty>,,,,1,,ANY
316189,BLOCK,1,,<empty>,,,,1,,ANY
316194,BLOCK,1,,<empty>,,,,1,,ANY
316199,BLOCK,1,,<empty>,,,,1,,ANY
316203,BLOCK,1,,<empty>,,,,1,,ANY
316207,BLOCK,1,,<empty>,,,,1,,ANY
316211,BLOCK,1,,<empty>,,,,1,,ANY
316217,BLOCK,1,,<empty>,,,,1,,ANY
316223,BLOCK,1,,<empty>,,,,1,,ANY
316227,BLOCK,1,,<empty>,,,,1,,ANY
316232,BLOCK,1,,<empty>,,,,1,,ANY
316236,BLOCK,1,,<empty>,,,,1,,ANY
316242,BLOCK,1,,<empty>,,,,1,,ANY
316247,BLOCK,1,,<empty>,,,,1,,ANY
316252,BLOCK,1,,<empty>,,,,1,,ANY
316256,BLOCK,1,,<empty>,,,,1,,ANY
316260,BLOCK,1,,<empty>,,,,1,,ANY
316265,BLOCK,1,,<empty>,,,,1,,ANY
316269,BLOCK,1,,<empty>,,,,1,,ANY
316273,BLOCK,1,,<empty>,,,,1,,ANY
316279,BLOCK,1,,<empty>,,,,1,,ANY
316285,BLOCK,1,,<empty>,,,,1,,ANY
316290,BLOCK,1,,<empty>,,,,1,,ANY
316299,BLOCK,1,,<empty>,,,,1,,ANY
316303,BLOCK,1,,<empty>,,,,1,,ANY
316307,BLOCK,1,,<empty>,,,,1,,ANY
316311,BLOCK,1,,<empty>,,,,1,,ANY
316316,BLOCK,1,,<empty>,,,,1,,ANY
316322,BLOCK,1,,<empty>,,,,1,,ANY
316326,BLOCK,1,,<empty>,,,,1,,ANY
316330,BLOCK,1,,<empty>,,,,1,,ANY
316334,BLOCK,1,,<empty>,,,,1,,ANY
316339,BLOCK,1,,<empty>,,,,1,,ANY
316344,BLOCK,1,,<empty>,,,,1,,ANY
316348,BLOCK,1,,<empty>,,,,1,,ANY
316353,BLOCK,1,,<empty>,,,,1,,ANY
316357,BLOCK,1,,<empty>,,,,1,,ANY
316366,BLOCK,1,,<empty>,,,,1,,ANY
316370,BLOCK,1,,<empty>,,,,1,,ANY
316376,BLOCK,1,,<empty>,,,,1,,ANY
316379,BLOCK,1,,<empty>,,,,1,,ANY
316386,BLOCK,1,,<empty>,,,,1,,ANY
316390,BLOCK,1,,<empty>,,,,1,,ANY
316395,BLOCK,1,,<empty>,,,,1,,ANY
316399,BLOCK,1,,<empty>,,,,1,,ANY
316405,BLOCK,1,,<empty>,,,,1,,ANY
316410,BLOCK,1,,<empty>,,,,1,,ANY
316417,BLOCK,1,,<empty>,,,,1,,ANY
316420,BLOCK,1,,<empty>,,,,1,,ANY
316427,BLOCK,1,,<empty>,,,,1,,ANY
316433,BLOCK,1,,<empty>,,,,1,,ANY
316437,BLOCK,1,,<empty>,,,,1,,ANY
316443,BLOCK,1,,<empty>,,,,1,,ANY
316449,BLOCK,1,,<empty>,,,,1,,ANY
316452,BLOCK,1,,<empty>,,,,1,,ANY
316457,BLOCK,1,,<empty>,,,,1,,ANY
316461,BLOCK,1,,<empty>,,,,1,,ANY
316467,BLOCK,1,,<empty>,,,,1,,ANY
316471,BLOCK,1,,<empty>,,,,1,,ANY
316476,BLOCK,1,,<empty>,,,,1,,ANY
316480,BLOCK,1,,<empty>,,,,1,,ANY
316484,BLOCK,1,,<empty>,,,,1,,ANY
316488,BLOCK,1,,<empty>,,,,1,,ANY
316492,BLOCK,1,,<empty>,,,,1,,ANY
316497,BLOCK,1,,<empty>,,,,1,,ANY
316501,BLOCK,1,,<empty>,,,,1,,ANY
316505,BLOCK,1,,<empty>,,,,1,,ANY
316509,BLOCK,1,,<empty>,,,,1,,ANY
316514,BLOCK,1,,<empty>,,,,1,,ANY
316519,BLOCK,1,,<empty>,,,,1,,ANY
316524,BLOCK,1,,<empty>,,,,1,,ANY
316528,BLOCK,1,,<empty>,,,,1,,ANY
316532,BLOCK,1,,<empty>,,,,1,,ANY
316536,BLOCK,1,,<empty>,,,,1,,ANY
316540,BLOCK,1,,<empty>,,,,1,,ANY
316544,BLOCK,1,,<empty>,,,,1,,ANY
316549,BLOCK,1,,<empty>,,,,1,,ANY
316553,BLOCK,1,,<empty>,,,,1,,ANY
316557,BLOCK,1,,<empty>,,,,1,,ANY
316563,BLOCK,1,,<empty>,,,,1,,ANY
316567,BLOCK,1,,<empty>,,,,1,,ANY
316571,BLOCK,1,,<empty>,,,,1,,ANY
316577,BLOCK,1,,<empty>,,,,1,,ANY
316588,BLOCK,1,,<empty>,,,,1,,ANY
316593,BLOCK,1,,<empty>,,,,1,,ANY
316598,BLOCK,1,,<empty>,,,,1,,ANY
316602,BLOCK,1,,<empty>,,,,1,,ANY
316606,BLOCK,1,,<empty>,,,,1,,ANY
316613,BLOCK,1,,<empty>,,,,1,,ANY
316617,BLOCK,1,,<empty>,,,,1,,ANY
316624,BLOCK,1,,<empty>,,,,1,,ANY
316630,BLOCK,1,,<empty>,,,,1,,ANY
316634,BLOCK,1,,<empty>,,,,1,,ANY
316641,BLOCK,1,,<empty>,,,,1,,ANY
316653,BLOCK,1,,<empty>,,,,1,,ANY
316657,BLOCK,1,,<empty>,,,,1,,ANY
316662,BLOCK,1,,<empty>,,,,1,,ANY
316666,BLOCK,1,,<empty>,,,,1,,ANY
316670,BLOCK,1,,<empty>,,,,1,,ANY
316673,BLOCK,1,,<empty>,,,,1,,ANY
316676,BLOCK,1,,<empty>,,,,1,,ANY
316679,BLOCK,1,,<empty>,,,,1,,ANY
316682,BLOCK,1,,<empty>,,,,1,,ANY
316686,BLOCK,1,,<empty>,,,,1,,ANY
316690,BLOCK,1,,<empty>,,,,1,,ANY
316694,BLOCK,1,,<empty>,,,,1,,ANY
316698,BLOCK,1,,<empty>,,,,1,,ANY
316702,BLOCK,1,,<empty>,,,,1,,ANY
316706,BLOCK,1,,<empty>,,,,1,,ANY
316711,BLOCK,1,,<empty>,,,,1,,ANY
316714,BLOCK,1,,<empty>,,,,1,,ANY
316722,BLOCK,1,,<empty>,,,,1,,ANY
316729,BLOCK,1,,<empty>,,,,1,,ANY
316733,BLOCK,1,,<empty>,,,,1,,ANY
316741,BLOCK,1,,<empty>,,,,1,,ANY
316748,BLOCK,1,,<empty>,,,,1,,ANY
316753,BLOCK,1,,<empty>,,,,1,,ANY
316761,BLOCK,1,,<empty>,,,,1,,ANY
316769,BLOCK,1,,<empty>,,,,1,,ANY
316775,BLOCK,1,,<empty>,,,,1,,ANY
316779,BLOCK,1,,<empty>,,,,1,,ANY
316786,BLOCK,1,,<empty>,,,,1,,ANY
316790,BLOCK,1,,<empty>,,,,1,,ANY
316795,BLOCK,1,,<empty>,,,,1,,ANY
316801,BLOCK,1,,<empty>,,,,1,,ANY
316805,BLOCK,1,,<empty>,,,,1,,ANY
316809,BLOCK,1,,<empty>,,,,1,,ANY
316814,BLOCK,1,,<empty>,,,,1,,ANY
316820,BLOCK,1,,<empty>,,,,1,,ANY
316824,BLOCK,1,,<empty>,,,,1,,ANY
316828,BLOCK,1,,<empty>,,,,1,,ANY
316832,BLOCK,1,,<empty>,,,,1,,ANY
316836,BLOCK,1,,<empty>,,,,1,,ANY
316840,BLOCK,1,,<empty>,,,,1,,ANY
316848,BLOCK,1,,<empty>,,,,1,,ANY
316856,BLOCK,1,,<empty>,,,,1,,ANY
316864,BLOCK,1,,<empty>,,,,1,,ANY
316870,BLOCK,1,,<empty>,,,,1,,ANY
316876,BLOCK,1,,<empty>,,,,1,,ANY
316881,BLOCK,1,,<empty>,,,,1,,ANY
316885,BLOCK,1,,<empty>,,,,1,,ANY
316890,BLOCK,1,,<empty>,,,,1,,ANY
316894,BLOCK,1,,<empty>,,,,1,,ANY
316898,BLOCK,1,,<empty>,,,,1,,ANY
316902,BLOCK,1,,<empty>,,,,1,,ANY
316907,BLOCK,1,,<empty>,,,,1,,ANY
316911,BLOCK,1,,<empty>,,,,1,,ANY
316916,BLOCK,1,,<empty>,,,,1,,ANY
316922,BLOCK,1,,<empty>,,,,1,,ANY
316930,BLOCK,1,,<empty>,,,,1,,ANY
316934,BLOCK,1,,<empty>,,,,1,,ANY
316942,BLOCK,1,,<empty>,,,,1,,ANY
316948,BLOCK,1,,<empty>,,,,1,,ANY
316954,BLOCK,1,,<empty>,,,,1,,ANY
316960,BLOCK,1,,<empty>,,,,1,,ANY
316966,BLOCK,1,,<empty>,,,,1,,ANY
316974,BLOCK,1,,<empty>,,,,1,,ANY
316978,BLOCK,1,,<empty>,,,,1,,ANY
316982,BLOCK,1,,<empty>,,,,1,,ANY
316987,BLOCK,1,,<empty>,,,,1,,ANY
316992,BLOCK,1,,<empty>,,,,1,,ANY
316998,BLOCK,1,,<empty>,,,,1,,ANY
317002,BLOCK,1,,<empty>,,,,1,,ANY
317006,BLOCK,1,,<empty>,,,,1,,ANY
317012,BLOCK,1,,<empty>,,,,1,,ANY
317016,BLOCK,1,,<empty>,,,,1,,ANY
317020,BLOCK,1,,<empty>,,,,1,,ANY
317024,BLOCK,1,,<empty>,,,,1,,ANY
317029,BLOCK,1,,<empty>,,,,1,,ANY
317033,BLOCK,1,,<empty>,,,,1,,ANY
317038,BLOCK,1,,<empty>,,,,1,,ANY
317043,BLOCK,1,,<empty>,,,,1,,ANY
317048,BLOCK,1,,<empty>,,,,1,,ANY
317053,BLOCK,1,,<empty>,,,,1,,ANY
317057,BLOCK,1,,<empty>,,,,1,,ANY
317060,BLOCK,1,,<empty>,,,,1,,ANY
317064,BLOCK,1,,<empty>,,,,1,,ANY
317068,BLOCK,1,,<empty>,,,,1,,ANY
317074,BLOCK,1,,<empty>,,,,1,,ANY
317078,BLOCK,1,,<empty>,,,,1,,ANY
317082,BLOCK,1,,<empty>,,,,1,,ANY
317086,BLOCK,1,,<empty>,,,,1,,ANY
317090,BLOCK,1,,<empty>,,,,1,,ANY
317094,BLOCK,1,,<empty>,,,,1,,ANY
317098,BLOCK,1,,<empty>,,,,1,,ANY
317102,BLOCK,1,,<empty>,,,,1,,ANY
317107,BLOCK,1,,<empty>,,,,1,,ANY
317111,BLOCK,1,,<empty>,,,,1,,ANY
317115,BLOCK,1,,<empty>,,,,1,,ANY
317120,BLOCK,1,,<empty>,,,,1,,ANY
317124,BLOCK,1,,<empty>,,,,1,,ANY
317131,BLOCK,1,,<empty>,,,,1,,ANY
317135,BLOCK,1,,<empty>,,,,1,,ANY
317139,BLOCK,1,,<empty>,,,,1,,ANY
317143,BLOCK,1,,<empty>,,,,1,,ANY
317152,BLOCK,1,,<empty>,,,,1,,ANY
317157,BLOCK,1,,<empty>,,,,1,,ANY
317162,BLOCK,1,,<empty>,,,,1,,ANY
317166,BLOCK,1,,<empty>,,,,1,,ANY
317170,BLOCK,1,,<empty>,,,,1,,ANY
317174,BLOCK,1,,<empty>,,,,1,,ANY
317179,BLOCK,1,,<empty>,,,,1,,ANY
317183,BLOCK,1,,<empty>,,,,1,,ANY
317187,BLOCK,1,,<empty>,,,,1,,ANY
317191,BLOCK,1,,<empty>,,,,1,,ANY
317196,BLOCK,1,,<empty>,,,,1,,ANY
317200,BLOCK,1,,<empty>,,,,1,,ANY
317204,BLOCK,1,,<empty>,,,,1,,ANY
317208,BLOCK,1,,<empty>,,,,1,,ANY
317218,BLOCK,1,,<empty>,,,,1,,ANY
317226,BLOCK,1,,<empty>,,,,1,,ANY
317233,BLOCK,1,,<empty>,,,,1,,ANY
317237,BLOCK,1,,<empty>,,,,1,,ANY
317241,BLOCK,1,,<empty>,,,,1,,ANY
317246,BLOCK,1,,<empty>,,,,1,,ANY
317250,BLOCK,1,,<empty>,,,,1,,ANY
317255,BLOCK,1,,<empty>,,,,1,,ANY
317261,BLOCK,1,,<empty>,,,,1,,ANY
317267,BLOCK,1,,<empty>,,,,1,,ANY
317271,BLOCK,1,,<empty>,,,,1,,ANY
317275,BLOCK,1,,<empty>,,,,1,,ANY
317279,BLOCK,1,,<empty>,,,,1,,ANY
317283,BLOCK,1,,<empty>,,,,1,,ANY
317287,BLOCK,1,,<empty>,,,,1,,ANY
317291,BLOCK,1,,<empty>,,,,1,,ANY
317295,BLOCK,1,,<empty>,,,,1,,ANY
317299,BLOCK,1,,<empty>,,,,1,,ANY
317303,BLOCK,1,,<empty>,,,,1,,ANY
317307,BLOCK,1,,<empty>,,,,1,,ANY
317311,BLOCK,1,,<empty>,,,,1,,ANY
317315,BLOCK,1,,<empty>,,,,1,,ANY
317319,BLOCK,1,,<empty>,,,,1,,ANY
317323,BLOCK,1,,<empty>,,,,1,,ANY
317327,BLOCK,1,,<empty>,,,,1,,ANY
317331,BLOCK,1,,<empty>,,,,1,,ANY
317336,BLOCK,1,,<empty>,,,,1,,ANY
317341,BLOCK,1,,<empty>,,,,1,,ANY
317346,BLOCK,1,,<empty>,,,,1,,ANY
317351,BLOCK,1,,<empty>,,,,1,,ANY
317355,BLOCK,1,,<empty>,,,,1,,ANY
317359,BLOCK,1,,<empty>,,,,1,,ANY
317363,BLOCK,1,,<empty>,,,,1,,ANY
317367,BLOCK,1,,<empty>,,,,1,,ANY
317373,BLOCK,1,,<empty>,,,,1,,ANY
317377,BLOCK,1,,<empty>,,,,1,,ANY
317383,BLOCK,1,,<empty>,,,,1,,ANY
317387,BLOCK,1,,<empty>,,,,1,,ANY
317391,BLOCK,1,,<empty>,,,,1,,ANY
317395,BLOCK,1,,<empty>,,,,1,,ANY
317404,BLOCK,1,,<empty>,,,,1,,ANY
317411,BLOCK,1,,<empty>,,,,1,,ANY
317418,BLOCK,1,,<empty>,,,,1,,ANY
317425,BLOCK,1,,<empty>,,,,1,,ANY
317432,BLOCK,1,,<empty>,,,,1,,ANY
317439,BLOCK,1,,<empty>,,,,1,,ANY
317446,BLOCK,1,,<empty>,,,,1,,ANY
317453,BLOCK,1,,<empty>,,,,1,,ANY
317460,BLOCK,1,,<empty>,,,,1,,ANY
317467,BLOCK,1,,<empty>,,,,1,,ANY
317474,BLOCK,1,,<empty>,,,,1,,ANY
317481,BLOCK,1,,<empty>,,,,1,,ANY
317485,BLOCK,1,,<empty>,,,,1,,ANY
317489,BLOCK,1,,<empty>,,,,1,,ANY
317493,BLOCK,1,,<empty>,,,,1,,ANY
317497,BLOCK,1,,<empty>,,,,1,,ANY
317501,BLOCK,1,,<empty>,,,,1,,ANY
317505,BLOCK,1,,<empty>,,,,1,,ANY
317509,BLOCK,1,,<empty>,,,,1,,ANY
317513,BLOCK,1,,<empty>,,,,1,,ANY
317517,BLOCK,1,,<empty>,,,,1,,ANY
317521,BLOCK,1,,<empty>,,,,1,,ANY
317525,BLOCK,1,,<empty>,,,,1,,ANY
317529,BLOCK,1,,<empty>,,,,1,,ANY
317536,BLOCK,1,,<empty>,,,,1,,ANY
317540,BLOCK,1,,<empty>,,,,1,,ANY
317544,BLOCK,1,,<empty>,,,,1,,ANY
317548,BLOCK,1,,<empty>,,,,1,,ANY
317551,BLOCK,1,,<empty>,,,,1,,ANY
317556,BLOCK,1,,<empty>,,,,1,,ANY
317561,BLOCK,1,,<empty>,,,,1,,ANY
317565,BLOCK,1,,<empty>,,,,1,,ANY
317573,BLOCK,1,,<empty>,,,,1,,ANY
317577,BLOCK,1,,<empty>,,,,1,,ANY
317583,BLOCK,1,,<empty>,,,,1,,ANY
317587,BLOCK,1,,<empty>,,,,1,,ANY
317591,BLOCK,1,,<empty>,,,,1,,ANY
317595,BLOCK,1,,<empty>,,,,1,,ANY
317599,BLOCK,1,,<empty>,,,,1,,ANY
317603,BLOCK,1,,<empty>,,,,1,,ANY
317609,BLOCK,1,,<empty>,,,,1,,ANY
317613,BLOCK,1,,<empty>,,,,1,,ANY
317617,BLOCK,1,,<empty>,,,,1,,ANY
317621,BLOCK,1,,<empty>,,,,1,,ANY
317625,BLOCK,1,,<empty>,,,,1,,ANY
317629,BLOCK,1,,<empty>,,,,1,,ANY
317633,BLOCK,1,,<empty>,,,,1,,ANY
317637,BLOCK,1,,<empty>,,,,1,,ANY
317642,BLOCK,1,,<empty>,,,,1,,ANY
317646,BLOCK,1,,<empty>,,,,1,,ANY
317650,BLOCK,1,,<empty>,,,,1,,ANY
317655,BLOCK,1,,<empty>,,,,1,,ANY
317660,BLOCK,1,,<empty>,,,,1,,ANY
317663,BLOCK,1,,<empty>,,,,1,,ANY
317667,BLOCK,1,,<empty>,,,,1,,ANY
317672,BLOCK,1,,<empty>,,,,1,,ANY
317676,BLOCK,1,,<empty>,,,,1,,ANY
317680,BLOCK,1,,<empty>,,,,1,,ANY
317684,BLOCK,1,,<empty>,,,,1,,ANY
317688,BLOCK,1,,<empty>,,,,1,,ANY
317692,BLOCK,1,,<empty>,,,,1,,ANY
317696,BLOCK,1,,<empty>,,,,1,,ANY
317701,BLOCK,1,,<empty>,,,,1,,ANY
317704,BLOCK,1,,<empty>,,,,1,,ANY
317708,BLOCK,1,,<empty>,,,,1,,ANY
317713,BLOCK,1,,<empty>,,,,1,,ANY
317718,BLOCK,1,,<empty>,,,,1,,ANY
317722,BLOCK,1,,<empty>,,,,1,,ANY
317730,BLOCK,1,,<empty>,,,,1,,ANY
317735,BLOCK,1,,<empty>,,,,1,,ANY
317742,BLOCK,1,,<empty>,,,,1,,ANY
317747,BLOCK,1,,<empty>,,,,1,,ANY
317755,BLOCK,1,,<empty>,,,,1,,ANY
317761,BLOCK,1,,<empty>,,,,1,,ANY
317765,BLOCK,1,,<empty>,,,,1,,ANY
317771,BLOCK,1,,<empty>,,,,1,,ANY
317775,BLOCK,1,,<empty>,,,,1,,ANY
317778,BLOCK,1,,<empty>,,,,1,,ANY
317783,BLOCK,1,,<empty>,,,,1,,ANY
317788,BLOCK,1,,<empty>,,,,1,,ANY
317793,BLOCK,1,,<empty>,,,,1,,ANY
317799,BLOCK,1,,<empty>,,,,1,,ANY
317804,BLOCK,1,,<empty>,,,,1,,ANY
317809,BLOCK,1,,<empty>,,,,1,,ANY
317815,BLOCK,1,,<empty>,,,,1,,ANY
317821,BLOCK,1,,<empty>,,,,1,,ANY
317825,BLOCK,1,,<empty>,,,,1,,ANY
317829,BLOCK,1,,<empty>,,,,1,,ANY
317837,BLOCK,1,,<empty>,,,,1,,ANY
317845,BLOCK,1,,<empty>,,,,1,,ANY
317849,BLOCK,1,,<empty>,,,,1,,ANY
317853,BLOCK,1,,<empty>,,,,1,,ANY
317860,BLOCK,1,,<empty>,,,,1,,ANY
317863,BLOCK,1,,<empty>,,,,1,,ANY
317870,BLOCK,1,,<empty>,,,,1,,ANY
317875,BLOCK,1,,<empty>,,,,1,,ANY
317879,BLOCK,1,,<empty>,,,,1,,ANY
317883,BLOCK,1,,<empty>,,,,1,,ANY
317887,BLOCK,1,,<empty>,,,,1,,ANY
317891,BLOCK,1,,<empty>,,,,1,,ANY
317895,BLOCK,1,,<empty>,,,,1,,ANY
317899,BLOCK,1,,<empty>,,,,1,,ANY
317904,BLOCK,1,,<empty>,,,,1,,ANY
317909,BLOCK,1,,<empty>,,,,1,,ANY
317913,BLOCK,1,,<empty>,,,,1,,ANY
317919,BLOCK,1,,<empty>,,,,1,,ANY
317925,BLOCK,1,,<empty>,,,,1,,ANY
317929,BLOCK,1,,<empty>,,,,1,,ANY
317935,BLOCK,1,,<empty>,,,,1,,ANY
317939,BLOCK,1,,<empty>,,,,1,,ANY
317943,BLOCK,1,,<empty>,,,,1,,ANY
317949,BLOCK,1,,<empty>,,,,1,,ANY
317954,BLOCK,1,,<empty>,,,,1,,ANY
317957,BLOCK,1,,<empty>,,,,1,,ANY
317961,BLOCK,1,,<empty>,,,,1,,ANY
317966,BLOCK,1,,<empty>,,,,1,,ANY
317970,BLOCK,1,,<empty>,,,,1,,ANY
317974,BLOCK,1,,<empty>,,,,1,,ANY
317978,BLOCK,1,,<empty>,,,,1,,ANY
317982,BLOCK,1,,<empty>,,,,1,,ANY
317986,BLOCK,1,,<empty>,,,,1,,ANY
317990,BLOCK,1,,<empty>,,,,1,,ANY
317993,BLOCK,1,,<empty>,,,,1,,ANY
317998,BLOCK,1,,<empty>,,,,1,,ANY
318002,BLOCK,1,,<empty>,,,,1,,ANY
318006,BLOCK,1,,<empty>,,,,1,,ANY
318009,BLOCK,1,,<empty>,,,,1,,ANY
318013,BLOCK,1,,<empty>,,,,1,,ANY
318017,BLOCK,1,,<empty>,,,,1,,ANY
318022,BLOCK,1,,<empty>,,,,1,,ANY
318028,BLOCK,1,,<empty>,,,,1,,ANY
318033,BLOCK,1,,<empty>,,,,1,,ANY
318038,BLOCK,1,,<empty>,,,,1,,ANY
318042,BLOCK,1,,<empty>,,,,1,,ANY
318047,BLOCK,1,,<empty>,,,,1,,ANY
318052,BLOCK,1,,<empty>,,,,1,,ANY
318059,BLOCK,1,,<empty>,,,,1,,ANY
318063,BLOCK,1,,<empty>,,,,1,,ANY
318066,BLOCK,1,,<empty>,,,,1,,ANY
318070,BLOCK,1,,<empty>,,,,1,,ANY
318074,BLOCK,1,,<empty>,,,,1,,ANY
318078,BLOCK,1,,<empty>,,,,1,,ANY
318082,BLOCK,1,,<empty>,,,,1,,ANY
318086,BLOCK,1,,<empty>,,,,1,,ANY
318090,BLOCK,1,,<empty>,,,,1,,ANY
318096,BLOCK,1,,<empty>,,,,1,,ANY
318101,BLOCK,1,,<empty>,,,,1,,ANY
318104,BLOCK,1,,<empty>,,,,1,,ANY
318108,BLOCK,1,,<empty>,,,,1,,ANY
318111,BLOCK,1,,<empty>,,,,1,,ANY
318117,BLOCK,1,,<empty>,,,,1,,ANY
318121,BLOCK,1,,<empty>,,,,1,,ANY
318125,BLOCK,1,,<empty>,,,,1,,ANY
318130,BLOCK,1,,<empty>,,,,1,,ANY
318134,BLOCK,1,,<empty>,,,,1,,ANY
318138,BLOCK,1,,<empty>,,,,1,,ANY
318142,BLOCK,1,,<empty>,,,,1,,ANY
318146,BLOCK,1,,<empty>,,,,1,,ANY
318149,BLOCK,1,,<empty>,,,,1,,ANY
318159,BLOCK,1,,<empty>,,,,1,,ANY
318164,BLOCK,1,,<empty>,,,,1,,ANY
318168,BLOCK,1,,<empty>,,,,1,,ANY
318175,BLOCK,1,,<empty>,,,,1,,ANY
318182,BLOCK,1,,<empty>,,,,1,,ANY
318185,BLOCK,1,,<empty>,,,,1,,ANY
318189,BLOCK,1,,<empty>,,,,1,,ANY
318192,BLOCK,1,,<empty>,,,,1,,ANY
318198,BLOCK,1,,<empty>,,,,1,,ANY
318203,BLOCK,1,,<empty>,,,,1,,ANY
318208,BLOCK,1,,<empty>,,,,1,,ANY
318213,BLOCK,1,,<empty>,,,,1,,ANY
318217,BLOCK,1,,<empty>,,,,1,,ANY
318224,BLOCK,1,,<empty>,,,,1,,ANY
318228,BLOCK,1,,<empty>,,,,1,,ANY
318232,BLOCK,1,,<empty>,,,,1,,ANY
318236,BLOCK,1,,<empty>,,,,1,,ANY
318241,BLOCK,1,,<empty>,,,,1,,ANY
318244,BLOCK,1,,<empty>,,,,1,,ANY
318248,BLOCK,1,,<empty>,,,,1,,ANY
318253,BLOCK,1,,<empty>,,,,1,,ANY
318257,BLOCK,1,,<empty>,,,,1,,ANY
318261,BLOCK,1,,<empty>,,,,1,,ANY
318264,BLOCK,1,,<empty>,,,,1,,ANY
318268,BLOCK,1,,<empty>,,,,1,,ANY
318271,BLOCK,1,,<empty>,,,,1,,ANY
318274,BLOCK,1,,<empty>,,,,1,,ANY
318278,BLOCK,1,,<empty>,,,,1,,ANY
318282,BLOCK,1,,<empty>,,,,1,,ANY
318286,BLOCK,1,,<empty>,,,,1,,ANY
318290,BLOCK,1,,<empty>,,,,1,,ANY
318294,BLOCK,1,,<empty>,,,,1,,ANY
318298,BLOCK,1,,<empty>,,,,1,,ANY
318303,BLOCK,1,,<empty>,,,,1,,ANY
318307,BLOCK,1,,<empty>,,,,1,,ANY
318313,BLOCK,1,,<empty>,,,,1,,ANY
318321,BLOCK,1,,<empty>,,,,1,,ANY
318326,BLOCK,1,,<empty>,,,,1,,ANY
318330,BLOCK,1,,<empty>,,,,1,,ANY
318334,BLOCK,1,,<empty>,,,,1,,ANY
318339,BLOCK,1,,<empty>,,,,1,,ANY
318344,BLOCK,1,,<empty>,,,,1,,ANY
318349,BLOCK,1,,<empty>,,,,1,,ANY
318354,BLOCK,1,,<empty>,,,,1,,ANY
318360,BLOCK,1,,<empty>,,,,1,,ANY
318365,BLOCK,1,,<empty>,,,,1,,ANY
318370,BLOCK,1,,<empty>,,,,1,,ANY
318378,BLOCK,1,,<empty>,,,,1,,ANY
318382,BLOCK,1,,<empty>,,,,1,,ANY
318390,BLOCK,1,,<empty>,,,,1,,ANY
318394,BLOCK,1,,<empty>,,,,1,,ANY
318399,BLOCK,1,,<empty>,,,,1,,ANY
318403,BLOCK,1,,<empty>,,,,1,,ANY
318407,BLOCK,1,,<empty>,,,,1,,ANY
318411,BLOCK,1,,<empty>,,,,1,,ANY
318415,BLOCK,1,,<empty>,,,,1,,ANY
318419,BLOCK,1,,<empty>,,,,1,,ANY
318425,BLOCK,1,,<empty>,,,,1,,ANY
318429,BLOCK,1,,<empty>,,,,1,,ANY
318435,BLOCK,1,,<empty>,,,,1,,ANY
318439,BLOCK,1,,<empty>,,,,1,,ANY
318443,BLOCK,1,,<empty>,,,,1,,ANY
318447,BLOCK,1,,<empty>,,,,1,,ANY
318451,BLOCK,1,,<empty>,,,,1,,ANY
318457,BLOCK,1,,<empty>,,,,1,,ANY
318464,BLOCK,1,,<empty>,,,,1,,ANY
318470,BLOCK,1,,<empty>,,,,1,,ANY
318474,BLOCK,1,,<empty>,,,,1,,ANY
318478,BLOCK,1,,<empty>,,,,1,,ANY
318484,BLOCK,1,,<empty>,,,,1,,ANY
318487,BLOCK,1,,<empty>,,,,1,,ANY
318491,BLOCK,1,,<empty>,,,,1,,ANY
318496,BLOCK,1,,<empty>,,,,1,,ANY
318500,BLOCK,1,,<empty>,,,,1,,ANY
318506,BLOCK,1,,<empty>,,,,1,,ANY
318513,BLOCK,1,,<empty>,,,,1,,ANY
318516,BLOCK,1,,<empty>,,,,1,,ANY
318519,BLOCK,1,,<empty>,,,,1,,ANY
318524,BLOCK,1,,<empty>,,,,1,,ANY
318530,BLOCK,1,,<empty>,,,,1,,ANY
318534,BLOCK,1,,<empty>,,,,1,,ANY
318539,BLOCK,1,,<empty>,,,,1,,ANY
318542,BLOCK,1,,<empty>,,,,1,,ANY
318547,BLOCK,1,,<empty>,,,,1,,ANY
318551,BLOCK,1,,<empty>,,,,1,,ANY
318555,BLOCK,1,,<empty>,,,,1,,ANY
318558,BLOCK,1,,<empty>,,,,1,,ANY
318561,BLOCK,1,,<empty>,,,,1,,ANY
318566,BLOCK,1,,<empty>,,,,1,,ANY
318573,BLOCK,1,,<empty>,,,,1,,ANY
318576,BLOCK,1,,<empty>,,,,1,,ANY
318581,BLOCK,1,,<empty>,,,,1,,ANY
318586,BLOCK,1,,<empty>,,,,1,,ANY
318589,BLOCK,1,,<empty>,,,,1,,ANY
318592,BLOCK,1,,<empty>,,,,1,,ANY
318595,BLOCK,1,,<empty>,,,,1,,ANY
318602,BLOCK,1,,<empty>,,,,1,,ANY
318606,BLOCK,1,,<empty>,,,,1,,ANY
318613,BLOCK,1,,<empty>,,,,1,,ANY
318617,BLOCK,1,,<empty>,,,,1,,ANY
318623,BLOCK,1,,<empty>,,,,1,,ANY
318626,BLOCK,1,,<empty>,,,,1,,ANY
318630,BLOCK,1,,<empty>,,,,1,,ANY
318636,BLOCK,1,,<empty>,,,,1,,ANY
318640,BLOCK,1,,<empty>,,,,1,,ANY
318647,BLOCK,1,,<empty>,,,,1,,ANY
318651,BLOCK,1,,<empty>,,,,1,,ANY
318655,BLOCK,1,,<empty>,,,,1,,ANY
318659,BLOCK,1,,<empty>,,,,1,,ANY
318667,BLOCK,1,,<empty>,,,,1,,ANY
318670,BLOCK,1,,<empty>,,,,1,,ANY
318673,BLOCK,1,,<empty>,,,,1,,ANY
318676,BLOCK,1,,<empty>,,,,1,,ANY
318679,BLOCK,1,,<empty>,,,,1,,ANY
318684,BLOCK,1,,<empty>,,,,1,,ANY
318689,BLOCK,1,,<empty>,,,,1,,ANY
318693,BLOCK,1,,<empty>,,,,1,,ANY
318697,BLOCK,1,,<empty>,,,,1,,ANY
318707,BLOCK,1,,<empty>,,,,1,,ANY
318712,BLOCK,1,,<empty>,,,,1,,ANY
318715,BLOCK,1,,<empty>,,,,1,,ANY
318720,BLOCK,1,,<empty>,,,,1,,ANY
318725,BLOCK,1,,<empty>,,,,1,,ANY
318729,BLOCK,1,,<empty>,,,,1,,ANY
318733,BLOCK,1,,<empty>,,,,1,,ANY
318737,BLOCK,1,,<empty>,,,,1,,ANY
318741,BLOCK,1,,<empty>,,,,1,,ANY
318746,BLOCK,1,,<empty>,,,,1,,ANY
318750,BLOCK,1,,<empty>,,,,1,,ANY
318754,BLOCK,1,,<empty>,,,,1,,ANY
318759,BLOCK,1,,<empty>,,,,1,,ANY
318763,BLOCK,1,,<empty>,,,,1,,ANY
318767,BLOCK,1,,<empty>,,,,1,,ANY
318772,BLOCK,1,,<empty>,,,,1,,ANY
318776,BLOCK,1,,<empty>,,,,1,,ANY
318780,BLOCK,1,,<empty>,,,,1,,ANY
318784,BLOCK,1,,<empty>,,,,1,,ANY
318787,BLOCK,1,,<empty>,,,,1,,ANY
318791,BLOCK,1,,<empty>,,,,1,,ANY
318795,BLOCK,1,,<empty>,,,,1,,ANY
318803,BLOCK,1,,<empty>,,,,1,,ANY
318810,BLOCK,1,,<empty>,,,,1,,ANY
318815,BLOCK,1,,<empty>,,,,1,,ANY
318819,BLOCK,1,,<empty>,,,,1,,ANY
318825,BLOCK,1,,<empty>,,,,1,,ANY
318829,BLOCK,1,,<empty>,,,,1,,ANY
318834,BLOCK,1,,<empty>,,,,1,,ANY
318839,BLOCK,1,,<empty>,,,,1,,ANY
318843,BLOCK,1,,<empty>,,,,1,,ANY
318848,BLOCK,1,,<empty>,,,,1,,ANY
318852,BLOCK,1,,<empty>,,,,1,,ANY
318859,BLOCK,1,,<empty>,,,,1,,ANY
318863,BLOCK,1,,<empty>,,,,1,,ANY
318867,BLOCK,1,,<empty>,,,,1,,ANY
318873,BLOCK,1,,<empty>,,,,1,,ANY
318878,BLOCK,1,,<empty>,,,,1,,ANY
318884,BLOCK,1,,<empty>,,,,1,,ANY
318889,BLOCK,1,,<empty>,,,,1,,ANY
318894,BLOCK,1,,<empty>,,,,1,,ANY
318899,BLOCK,1,,<empty>,,,,1,,ANY
318903,BLOCK,1,,<empty>,,,,1,,ANY
318908,BLOCK,1,,<empty>,,,,1,,ANY
318913,BLOCK,1,,<empty>,,,,1,,ANY
318918,BLOCK,1,,<empty>,,,,1,,ANY
318922,BLOCK,1,,<empty>,,,,1,,ANY
318926,BLOCK,1,,<empty>,,,,1,,ANY
318932,BLOCK,1,,<empty>,,,,1,,ANY
318935,BLOCK,1,,<empty>,,,,1,,ANY
318942,BLOCK,1,,<empty>,,,,1,,ANY
318946,BLOCK,1,,<empty>,,,,1,,ANY
318951,BLOCK,1,,<empty>,,,,1,,ANY
318955,BLOCK,1,,<empty>,,,,1,,ANY
318959,BLOCK,1,,<empty>,,,,1,,ANY
318965,BLOCK,1,,<empty>,,,,1,,ANY
318971,BLOCK,1,,<empty>,,,,1,,ANY
318976,BLOCK,1,,<empty>,,,,1,,ANY
318982,BLOCK,1,,<empty>,,,,1,,ANY
318986,BLOCK,1,,<empty>,,,,1,,ANY
318991,BLOCK,1,,<empty>,,,,1,,ANY
318994,BLOCK,1,,<empty>,,,,1,,ANY
318998,BLOCK,1,,<empty>,,,,1,,ANY
319004,BLOCK,1,,<empty>,,,,1,,ANY
319010,BLOCK,1,,<empty>,,,,1,,ANY
319015,BLOCK,1,,<empty>,,,,1,,ANY
319021,BLOCK,1,,<empty>,,,,1,,ANY
319028,BLOCK,1,,<empty>,,,,1,,ANY
319032,BLOCK,1,,<empty>,,,,1,,ANY
319037,BLOCK,1,,<empty>,,,,1,,ANY
319041,BLOCK,1,,<empty>,,,,1,,ANY
319045,BLOCK,1,,<empty>,,,,1,,ANY
319051,BLOCK,1,,<empty>,,,,1,,ANY
319058,BLOCK,1,,<empty>,,,,1,,ANY
319062,BLOCK,1,,<empty>,,,,1,,ANY
319067,BLOCK,1,,<empty>,,,,1,,ANY
319072,BLOCK,1,,<empty>,,,,1,,ANY
319076,BLOCK,1,,<empty>,,,,1,,ANY
319084,BLOCK,1,,<empty>,,,,1,,ANY
319088,BLOCK,1,,<empty>,,,,1,,ANY
319092,BLOCK,1,,<empty>,,,,1,,ANY
319096,BLOCK,1,,<empty>,,,,1,,ANY
319099,BLOCK,1,,<empty>,,,,1,,ANY
319103,BLOCK,1,,<empty>,,,,1,,ANY
319107,BLOCK,1,,<empty>,,,,1,,ANY
319111,BLOCK,1,,<empty>,,,,1,,ANY
319114,BLOCK,1,,<empty>,,,,1,,ANY
319123,BLOCK,1,,<empty>,,,,1,,ANY
319127,BLOCK,1,,<empty>,,,,1,,ANY
319132,BLOCK,1,,<empty>,,,,1,,ANY
319136,BLOCK,1,,<empty>,,,,1,,ANY
319139,BLOCK,1,,<empty>,,,,1,,ANY
319146,BLOCK,1,,<empty>,,,,1,,ANY
319152,BLOCK,1,,<empty>,,,,1,,ANY
319158,BLOCK,1,,<empty>,,,,1,,ANY
319164,BLOCK,1,,<empty>,,,,1,,ANY
319169,BLOCK,1,,<empty>,,,,1,,ANY
319175,BLOCK,1,,<empty>,,,,1,,ANY
319181,BLOCK,1,,<empty>,,,,1,,ANY
319187,BLOCK,1,,<empty>,,,,1,,ANY
319193,BLOCK,1,,<empty>,,,,1,,ANY
319199,BLOCK,1,,<empty>,,,,1,,ANY
319202,BLOCK,1,,<empty>,,,,1,,ANY
319207,BLOCK,1,,<empty>,,,,1,,ANY
319212,BLOCK,1,,<empty>,,,,1,,ANY
319218,BLOCK,1,,<empty>,,,,1,,ANY
319224,BLOCK,1,,<empty>,,,,1,,ANY
319230,BLOCK,1,,<empty>,,,,1,,ANY
319235,BLOCK,1,,<empty>,,,,1,,ANY
319241,BLOCK,1,,<empty>,,,,1,,ANY
319247,BLOCK,1,,<empty>,,,,1,,ANY
319253,BLOCK,1,,<empty>,,,,1,,ANY
319257,BLOCK,1,,<empty>,,,,1,,ANY
319261,BLOCK,1,,<empty>,,,,1,,ANY
319268,BLOCK,1,,<empty>,,,,1,,ANY
319273,BLOCK,1,,<empty>,,,,1,,ANY
319280,BLOCK,1,,<empty>,,,,1,,ANY
319289,BLOCK,1,,<empty>,,,,1,,ANY
319294,BLOCK,1,,<empty>,,,,1,,ANY
319299,BLOCK,1,,<empty>,,,,1,,ANY
319303,BLOCK,1,,<empty>,,,,1,,ANY
319307,BLOCK,1,,<empty>,,,,1,,ANY
319313,BLOCK,1,,<empty>,,,,1,,ANY
319320,BLOCK,1,,<empty>,,,,1,,ANY
319325,BLOCK,1,,<empty>,,,,1,,ANY
319330,BLOCK,1,,<empty>,,,,1,,ANY
319334,BLOCK,1,,<empty>,,,,1,,ANY
319340,BLOCK,1,,<empty>,,,,1,,ANY
319346,BLOCK,1,,<empty>,,,,1,,ANY
319352,BLOCK,1,,<empty>,,,,1,,ANY
319356,BLOCK,1,,<empty>,,,,1,,ANY
319361,BLOCK,1,,<empty>,,,,1,,ANY
319365,BLOCK,1,,<empty>,,,,1,,ANY
319372,BLOCK,1,,<empty>,,,,1,,ANY
319376,BLOCK,1,,<empty>,,,,1,,ANY
319380,BLOCK,1,,<empty>,,,,1,,ANY
319388,BLOCK,1,,<empty>,,,,1,,ANY
319392,BLOCK,1,,<empty>,,,,1,,ANY
319395,BLOCK,1,,<empty>,,,,1,,ANY
319399,BLOCK,1,,<empty>,,,,1,,ANY
319403,BLOCK,1,,<empty>,,,,1,,ANY
319408,BLOCK,1,,<empty>,,,,1,,ANY
319412,BLOCK,1,,<empty>,,,,1,,ANY
319416,BLOCK,1,,<empty>,,,,1,,ANY
319421,BLOCK,1,,<empty>,,,,1,,ANY
319426,BLOCK,1,,<empty>,,,,1,,ANY
319430,BLOCK,1,,<empty>,,,,1,,ANY
319441,BLOCK,1,,<empty>,,,,1,,ANY
319444,BLOCK,1,,<empty>,,,,1,,ANY
319450,BLOCK,1,,<empty>,,,,1,,ANY
319454,BLOCK,1,,<empty>,,,,1,,ANY
319461,BLOCK,1,,<empty>,,,,1,,ANY
319467,BLOCK,1,,<empty>,,,,1,,ANY
319474,BLOCK,1,,<empty>,,,,1,,ANY
319478,BLOCK,1,,<empty>,,,,1,,ANY
319485,BLOCK,1,,<empty>,,,,1,,ANY
319489,BLOCK,1,,<empty>,,,,1,,ANY
319494,BLOCK,1,,<empty>,,,,1,,ANY
319500,BLOCK,1,,<empty>,,,,1,,ANY
319504,BLOCK,1,,<empty>,,,,1,,ANY
319509,BLOCK,1,,<empty>,,,,1,,ANY
319514,BLOCK,1,,<empty>,,,,1,,ANY
319521,BLOCK,1,,<empty>,,,,1,,ANY
319525,BLOCK,1,,<empty>,,,,1,,ANY
319530,BLOCK,1,,<empty>,,,,1,,ANY
319535,BLOCK,1,,<empty>,,,,1,,ANY
319541,BLOCK,1,,<empty>,,,,1,,ANY
319545,BLOCK,1,,<empty>,,,,1,,ANY
319549,BLOCK,1,,<empty>,,,,1,,ANY
319553,BLOCK,1,,<empty>,,,,1,,ANY
319557,BLOCK,1,,<empty>,,,,1,,ANY
319561,BLOCK,1,,<empty>,,,,1,,ANY
319567,BLOCK,1,,<empty>,,,,1,,ANY
319571,BLOCK,1,,<empty>,,,,1,,ANY
319578,BLOCK,1,,<empty>,,,,1,,ANY
319581,BLOCK,1,,<empty>,,,,1,,ANY
319586,BLOCK,1,,<empty>,,,,1,,ANY
319591,BLOCK,1,,<empty>,,,,1,,ANY
319595,BLOCK,1,,<empty>,,,,1,,ANY
319606,BLOCK,1,,<empty>,,,,1,,ANY
319617,BLOCK,1,,<empty>,,,,1,,ANY
319622,BLOCK,1,,<empty>,,,,1,,ANY
319627,BLOCK,1,,<empty>,,,,1,,ANY
319630,BLOCK,1,,<empty>,,,,1,,ANY
319635,BLOCK,1,,<empty>,,,,1,,ANY
319639,BLOCK,1,,<empty>,,,,1,,ANY
319644,BLOCK,1,,<empty>,,,,1,,ANY
319649,BLOCK,1,,<empty>,,,,1,,ANY
319653,BLOCK,1,,<empty>,,,,1,,ANY
319659,BLOCK,1,,<empty>,,,,1,,ANY
319663,BLOCK,1,,<empty>,,,,1,,ANY
319671,BLOCK,1,,<empty>,,,,1,,ANY
319676,BLOCK,1,,<empty>,,,,1,,ANY
319680,BLOCK,1,,<empty>,,,,1,,ANY
319684,BLOCK,1,,<empty>,,,,1,,ANY
319688,BLOCK,1,,<empty>,,,,1,,ANY
319695,BLOCK,1,,<empty>,,,,1,,ANY
319700,BLOCK,1,,<empty>,,,,1,,ANY
319705,BLOCK,1,,<empty>,,,,1,,ANY
319709,BLOCK,1,,<empty>,,,,1,,ANY
319713,BLOCK,1,,<empty>,,,,1,,ANY
319719,BLOCK,1,,<empty>,,,,1,,ANY
319723,BLOCK,1,,<empty>,,,,1,,ANY
319729,BLOCK,1,,<empty>,,,,1,,ANY
319733,BLOCK,1,,<empty>,,,,1,,ANY
319739,BLOCK,1,,<empty>,,,,1,,ANY
319743,BLOCK,1,,<empty>,,,,1,,ANY
319747,BLOCK,1,,<empty>,,,,1,,ANY
319751,BLOCK,1,,<empty>,,,,1,,ANY
319755,BLOCK,1,,<empty>,,,,1,,ANY
319759,BLOCK,1,,<empty>,,,,1,,ANY
319763,BLOCK,1,,<empty>,,,,1,,ANY
319767,BLOCK,1,,<empty>,,,,1,,ANY
319771,BLOCK,1,,<empty>,,,,1,,ANY
319777,BLOCK,1,,<empty>,,,,1,,ANY
319782,BLOCK,1,,<empty>,,,,1,,ANY
319789,BLOCK,1,,<empty>,,,,1,,ANY
319795,BLOCK,1,,<empty>,,,,1,,ANY
319802,BLOCK,1,,<empty>,,,,1,,ANY
319807,BLOCK,1,,<empty>,,,,1,,ANY
319814,BLOCK,1,,<empty>,,,,1,,ANY
319821,BLOCK,1,,<empty>,,,,1,,ANY
319827,BLOCK,1,,<empty>,,,,1,,ANY
319832,BLOCK,1,,<empty>,,,,1,,ANY
319837,BLOCK,1,,<empty>,,,,1,,ANY
319846,BLOCK,1,,<empty>,,,,1,,ANY
319850,BLOCK,1,,<empty>,,,,1,,ANY
319854,BLOCK,1,,<empty>,,,,1,,ANY
319858,BLOCK,1,,<empty>,,,,1,,ANY
319862,BLOCK,1,,<empty>,,,,1,,ANY
319866,BLOCK,1,,<empty>,,,,1,,ANY
319870,BLOCK,1,,<empty>,,,,1,,ANY
319881,BLOCK,1,,<empty>,,,,1,,ANY
319887,BLOCK,1,,<empty>,,,,1,,ANY
319892,BLOCK,1,,<empty>,,,,1,,ANY
319896,BLOCK,1,,<empty>,,,,1,,ANY
319902,BLOCK,1,,<empty>,,,,1,,ANY
319907,BLOCK,1,,<empty>,,,,1,,ANY
319911,BLOCK,1,,<empty>,,,,1,,ANY
319915,BLOCK,1,,<empty>,,,,1,,ANY
319919,BLOCK,1,,<empty>,,,,1,,ANY
319923,BLOCK,1,,<empty>,,,,1,,ANY
319928,BLOCK,1,,<empty>,,,,1,,ANY
319932,BLOCK,1,,<empty>,,,,1,,ANY
319936,BLOCK,1,,<empty>,,,,1,,ANY
319944,BLOCK,1,,<empty>,,,,1,,ANY
319950,BLOCK,1,,<empty>,,,,1,,ANY
319955,BLOCK,1,,<empty>,,,,1,,ANY
319961,BLOCK,1,,<empty>,,,,1,,ANY
319967,BLOCK,1,,<empty>,,,,1,,ANY
319973,BLOCK,1,,<empty>,,,,1,,ANY
319978,BLOCK,1,,<empty>,,,,1,,ANY
319982,BLOCK,1,,<empty>,,,,1,,ANY
319987,BLOCK,1,,<empty>,,,,1,,ANY
319992,BLOCK,1,,<empty>,,,,1,,ANY
319997,BLOCK,1,,<empty>,,,,1,,ANY
320000,BLOCK,1,,<empty>,,,,1,,ANY
320003,BLOCK,1,,<empty>,,,,1,,ANY
320006,BLOCK,1,,<empty>,,,,1,,ANY
320009,BLOCK,1,,<empty>,,,,1,,ANY
320012,BLOCK,1,,<empty>,,,,1,,ANY
320016,BLOCK,1,,<empty>,,,,1,,ANY
320020,BLOCK,1,,<empty>,,,,1,,ANY
320026,BLOCK,1,,<empty>,,,,1,,ANY
320030,BLOCK,1,,<empty>,,,,1,,ANY
320035,BLOCK,1,,<empty>,,,,1,,ANY
320042,BLOCK,1,,<empty>,,,,1,,ANY
320046,BLOCK,1,,<empty>,,,,1,,ANY
320049,BLOCK,1,,<empty>,,,,1,,ANY
320054,BLOCK,1,,<empty>,,,,1,,ANY
320057,BLOCK,1,,<empty>,,,,1,,ANY
320061,BLOCK,1,,<empty>,,,,1,,ANY
320064,BLOCK,1,,<empty>,,,,1,,ANY
320067,BLOCK,1,,<empty>,,,,1,,ANY
320078,BLOCK,1,,<empty>,,,,1,,ANY
320085,BLOCK,1,,<empty>,,,,1,,ANY
320088,BLOCK,1,,<empty>,,,,1,,ANY
320099,BLOCK,1,,<empty>,,,,1,,ANY
320104,BLOCK,1,,<empty>,,,,1,,ANY
320109,BLOCK,1,,<empty>,,,,1,,ANY
320116,BLOCK,1,,<empty>,,,,1,,ANY
320129,BLOCK,1,,<empty>,,,,1,,ANY
320134,BLOCK,1,,<empty>,,,,1,,ANY
320138,BLOCK,1,,<empty>,,,,1,,ANY
320142,BLOCK,1,,<empty>,,,,1,,ANY
320146,BLOCK,1,,<empty>,,,,1,,ANY
320151,BLOCK,1,,<empty>,,,,1,,ANY
320156,BLOCK,1,,<empty>,,,,1,,ANY
320160,BLOCK,1,,<empty>,,,,1,,ANY
320171,BLOCK,1,,<empty>,,,,1,,ANY
320176,BLOCK,1,,<empty>,,,,1,,ANY
320185,BLOCK,1,,<empty>,,,,1,,ANY
320193,BLOCK,1,,<empty>,,,,1,,ANY
320197,BLOCK,1,,<empty>,,,,1,,ANY
320208,BLOCK,1,,<empty>,,,,1,,ANY
320219,BLOCK,1,,<empty>,,,,1,,ANY
320223,BLOCK,1,,<empty>,,,,1,,ANY
320229,BLOCK,1,,<empty>,,,,1,,ANY
320235,BLOCK,1,,<empty>,,,,1,,ANY
320240,BLOCK,1,,<empty>,,,,1,,ANY
320244,BLOCK,1,,<empty>,,,,1,,ANY
320255,BLOCK,1,,<empty>,,,,1,,ANY
320266,BLOCK,1,,<empty>,,,,1,,ANY
320271,BLOCK,1,,<empty>,,,,1,,ANY
320276,BLOCK,1,,<empty>,,,,1,,ANY
320280,BLOCK,1,,<empty>,,,,1,,ANY
320283,BLOCK,1,,<empty>,,,,1,,ANY
320288,BLOCK,1,,<empty>,,,,1,,ANY
320292,BLOCK,1,,<empty>,,,,1,,ANY
320295,BLOCK,1,,<empty>,,,,1,,ANY
320300,BLOCK,1,,<empty>,,,,1,,ANY
320305,BLOCK,1,,<empty>,,,,1,,ANY
320311,BLOCK,1,,<empty>,,,,1,,ANY
320315,BLOCK,1,,<empty>,,,,1,,ANY
320320,BLOCK,1,,<empty>,,,,1,,ANY
320324,BLOCK,1,,<empty>,,,,1,,ANY
320328,BLOCK,1,,<empty>,,,,1,,ANY
320331,BLOCK,1,,<empty>,,,,1,,ANY
320335,BLOCK,1,,<empty>,,,,1,,ANY
320340,BLOCK,1,,<empty>,,,,1,,ANY
320345,BLOCK,1,,<empty>,,,,1,,ANY
320350,BLOCK,1,,<empty>,,,,1,,ANY
320354,BLOCK,1,,<empty>,,,,1,,ANY
320359,BLOCK,1,,<empty>,,,,1,,ANY
320363,BLOCK,1,,<empty>,,,,1,,ANY
320367,BLOCK,1,,<empty>,,,,1,,ANY
320372,BLOCK,1,,<empty>,,,,1,,ANY
320378,BLOCK,1,,<empty>,,,,1,,ANY
320382,BLOCK,1,,<empty>,,,,1,,ANY
320387,BLOCK,1,,<empty>,,,,1,,ANY
320399,BLOCK,1,,<empty>,,,,1,,ANY
320404,BLOCK,1,,<empty>,,,,1,,ANY
320409,BLOCK,1,,<empty>,,,,1,,ANY
320413,BLOCK,1,,<empty>,,,,1,,ANY
320419,BLOCK,1,,<empty>,,,,1,,ANY
320423,BLOCK,1,,<empty>,,,,1,,ANY
320428,BLOCK,1,,<empty>,,,,1,,ANY
320433,BLOCK,1,,<empty>,,,,1,,ANY
320438,BLOCK,1,,<empty>,,,,1,,ANY
320443,BLOCK,1,,<empty>,,,,1,,ANY
320447,BLOCK,1,,<empty>,,,,1,,ANY
320454,BLOCK,1,,<empty>,,,,1,,ANY
320458,BLOCK,1,,<empty>,,,,1,,ANY
320462,BLOCK,1,,<empty>,,,,1,,ANY
320467,BLOCK,1,,<empty>,,,,1,,ANY
320472,BLOCK,1,,<empty>,,,,1,,ANY
320476,BLOCK,1,,<empty>,,,,1,,ANY
320481,BLOCK,1,,<empty>,,,,1,,ANY
320485,BLOCK,1,,<empty>,,,,1,,ANY
320489,BLOCK,1,,<empty>,,,,1,,ANY
320493,BLOCK,1,,<empty>,,,,1,,ANY
320497,BLOCK,1,,<empty>,,,,1,,ANY
320502,BLOCK,1,,<empty>,,,,1,,ANY
320507,BLOCK,1,,<empty>,,,,1,,ANY
320514,BLOCK,1,,<empty>,,,,1,,ANY
320518,BLOCK,1,,<empty>,,,,1,,ANY
320522,BLOCK,1,,<empty>,,,,1,,ANY
320527,BLOCK,1,,<empty>,,,,1,,ANY
320532,BLOCK,1,,<empty>,,,,1,,ANY
320537,BLOCK,1,,<empty>,,,,1,,ANY
320540,BLOCK,1,,<empty>,,,,1,,ANY
320544,BLOCK,1,,<empty>,,,,1,,ANY
320548,BLOCK,1,,<empty>,,,,1,,ANY
320552,BLOCK,1,,<empty>,,,,1,,ANY
320556,BLOCK,1,,<empty>,,,,1,,ANY
320561,BLOCK,1,,<empty>,,,,1,,ANY
320566,BLOCK,1,,<empty>,,,,1,,ANY
320571,BLOCK,1,,<empty>,,,,1,,ANY
320577,BLOCK,1,,<empty>,,,,1,,ANY
320585,BLOCK,1,,<empty>,,,,1,,ANY
320589,BLOCK,1,,<empty>,,,,1,,ANY
320593,BLOCK,1,,<empty>,,,,1,,ANY
320596,BLOCK,1,,<empty>,,,,1,,ANY
320602,BLOCK,1,,<empty>,,,,1,,ANY
320609,BLOCK,1,,<empty>,,,,1,,ANY
320613,BLOCK,1,,<empty>,,,,1,,ANY
320617,BLOCK,1,,<empty>,,,,1,,ANY
320622,BLOCK,1,,<empty>,,,,1,,ANY
320629,BLOCK,1,,<empty>,,,,1,,ANY
320636,BLOCK,1,,<empty>,,,,1,,ANY
320641,BLOCK,1,,<empty>,,,,1,,ANY
320646,BLOCK,1,,<empty>,,,,1,,ANY
320651,BLOCK,1,,<empty>,,,,1,,ANY
320656,BLOCK,1,,<empty>,,,,1,,ANY
320661,BLOCK,1,,<empty>,,,,1,,ANY
320666,BLOCK,1,,<empty>,,,,1,,ANY
320670,BLOCK,1,,<empty>,,,,1,,ANY
320674,BLOCK,1,,<empty>,,,,1,,ANY
320678,BLOCK,1,,<empty>,,,,1,,ANY
320682,BLOCK,1,,<empty>,,,,1,,ANY
320686,BLOCK,1,,<empty>,,,,1,,ANY
320691,BLOCK,1,,<empty>,,,,1,,ANY
320696,BLOCK,1,,<empty>,,,,1,,ANY
320703,BLOCK,1,,<empty>,,,,1,,ANY
320707,BLOCK,1,,<empty>,,,,1,,ANY
320711,BLOCK,1,,<empty>,,,,1,,ANY
320715,BLOCK,1,,<empty>,,,,1,,ANY
320718,BLOCK,1,,<empty>,,,,1,,ANY
320722,BLOCK,1,,<empty>,,,,1,,ANY
320727,BLOCK,1,,<empty>,,,,1,,ANY
320731,BLOCK,1,,<empty>,,,,1,,ANY
320736,BLOCK,1,,<empty>,,,,1,,ANY
320740,BLOCK,1,,<empty>,,,,1,,ANY
320744,BLOCK,1,,<empty>,,,,1,,ANY
320748,BLOCK,1,,<empty>,,,,1,,ANY
320752,BLOCK,1,,<empty>,,,,1,,ANY
320760,BLOCK,1,,<empty>,,,,1,,ANY
320764,BLOCK,1,,<empty>,,,,1,,ANY
320769,BLOCK,1,,<empty>,,,,1,,ANY
320774,BLOCK,1,,<empty>,,,,1,,ANY
320778,BLOCK,1,,<empty>,,,,1,,ANY
320782,BLOCK,1,,<empty>,,,,1,,ANY
320785,BLOCK,1,,<empty>,,,,1,,ANY
320789,BLOCK,1,,<empty>,,,,1,,ANY
320795,BLOCK,1,,<empty>,,,,1,,ANY
320799,BLOCK,1,,<empty>,,,,1,,ANY
320802,BLOCK,1,,<empty>,,,,1,,ANY
320813,BLOCK,1,,<empty>,,,,1,,ANY
320816,BLOCK,1,,<empty>,,,,1,,ANY
320827,BLOCK,1,,<empty>,,,,1,,ANY
320831,BLOCK,1,,<empty>,,,,1,,ANY
320835,BLOCK,1,,<empty>,,,,1,,ANY
320839,BLOCK,1,,<empty>,,,,1,,ANY
320844,BLOCK,1,,<empty>,,,,1,,ANY
320848,BLOCK,1,,<empty>,,,,1,,ANY
320852,BLOCK,1,,<empty>,,,,1,,ANY
320856,BLOCK,1,,<empty>,,,,1,,ANY
320860,BLOCK,1,,<empty>,,,,1,,ANY
320864,BLOCK,1,,<empty>,,,,1,,ANY
320868,BLOCK,1,,<empty>,,,,1,,ANY
320872,BLOCK,1,,<empty>,,,,1,,ANY
320878,BLOCK,1,,<empty>,,,,1,,ANY
320882,BLOCK,1,,<empty>,,,,1,,ANY
320885,BLOCK,1,,<empty>,,,,1,,ANY
320891,BLOCK,1,,<empty>,,,,1,,ANY
320895,BLOCK,1,,<empty>,,,,1,,ANY
320899,BLOCK,1,,<empty>,,,,1,,ANY
320912,BLOCK,1,,<empty>,,,,1,,ANY
320916,BLOCK,1,,<empty>,,,,1,,ANY
320921,BLOCK,1,,<empty>,,,,1,,ANY
320926,BLOCK,1,,<empty>,,,,1,,ANY
320930,BLOCK,1,,<empty>,,,,1,,ANY
320935,BLOCK,1,,<empty>,,,,1,,ANY
320939,BLOCK,1,,<empty>,,,,1,,ANY
320943,BLOCK,1,,<empty>,,,,1,,ANY
320947,BLOCK,1,,<empty>,,,,1,,ANY
320952,BLOCK,1,,<empty>,,,,1,,ANY
320958,BLOCK,1,,<empty>,,,,1,,ANY
320963,BLOCK,1,,<empty>,,,,1,,ANY
320967,BLOCK,1,,<empty>,,,,1,,ANY
320978,BLOCK,1,,<empty>,,,,1,,ANY
320989,BLOCK,1,,<empty>,,,,1,,ANY
320994,BLOCK,1,,<empty>,,,,1,,ANY
321005,BLOCK,1,,<empty>,,,,1,,ANY
321009,BLOCK,1,,<empty>,,,,1,,ANY
321019,BLOCK,1,,<empty>,,,,1,,ANY
321024,BLOCK,1,,<empty>,,,,1,,ANY
321028,BLOCK,1,,<empty>,,,,1,,ANY
321039,BLOCK,1,,<empty>,,,,1,,ANY
321050,BLOCK,1,,<empty>,,,,1,,ANY
321055,BLOCK,1,,<empty>,,,,1,,ANY
321059,BLOCK,1,,<empty>,,,,1,,ANY
321070,BLOCK,1,,<empty>,,,,1,,ANY
321081,BLOCK,1,,<empty>,,,,1,,ANY
321092,BLOCK,1,,<empty>,,,,1,,ANY
321096,BLOCK,1,,<empty>,,,,1,,ANY
321107,BLOCK,1,,<empty>,,,,1,,ANY
321118,BLOCK,1,,<empty>,,,,1,,ANY
321123,BLOCK,1,,<empty>,,,,1,,ANY
321127,BLOCK,1,,<empty>,,,,1,,ANY
321138,BLOCK,1,,<empty>,,,,1,,ANY
321149,BLOCK,1,,<empty>,,,,1,,ANY
321156,BLOCK,1,,<empty>,,,,1,,ANY
321161,BLOCK,1,,<empty>,,,,1,,ANY
321165,BLOCK,1,,<empty>,,,,1,,ANY
321180,BLOCK,1,,<empty>,,,,1,,ANY
321191,BLOCK,1,,<empty>,,,,1,,ANY
321202,BLOCK,1,,<empty>,,,,1,,ANY
321207,BLOCK,1,,<empty>,,,,1,,ANY
321212,BLOCK,1,,<empty>,,,,1,,ANY
321217,BLOCK,1,,<empty>,,,,1,,ANY
321221,BLOCK,1,,<empty>,,,,1,,ANY
321232,BLOCK,1,,<empty>,,,,1,,ANY
321243,BLOCK,1,,<empty>,,,,1,,ANY
321248,BLOCK,1,,<empty>,,,,1,,ANY
321252,BLOCK,1,,<empty>,,,,1,,ANY
321263,BLOCK,1,,<empty>,,,,1,,ANY
321274,BLOCK,1,,<empty>,,,,1,,ANY
321279,BLOCK,1,,<empty>,,,,1,,ANY
321284,BLOCK,1,,<empty>,,,,1,,ANY
321289,BLOCK,1,,<empty>,,,,1,,ANY
321293,BLOCK,1,,<empty>,,,,1,,ANY
321304,BLOCK,1,,<empty>,,,,1,,ANY
321315,BLOCK,1,,<empty>,,,,1,,ANY
321326,BLOCK,1,,<empty>,,,,1,,ANY
321330,BLOCK,1,,<empty>,,,,1,,ANY
321341,BLOCK,1,,<empty>,,,,1,,ANY
321352,BLOCK,1,,<empty>,,,,1,,ANY
321363,BLOCK,1,,<empty>,,,,1,,ANY
321367,BLOCK,1,,<empty>,,,,1,,ANY
321378,BLOCK,1,,<empty>,,,,1,,ANY
321389,BLOCK,1,,<empty>,,,,1,,ANY
321400,BLOCK,1,,<empty>,,,,1,,ANY
321404,BLOCK,1,,<empty>,,,,1,,ANY
321415,BLOCK,1,,<empty>,,,,1,,ANY
321426,BLOCK,1,,<empty>,,,,1,,ANY
321431,BLOCK,1,,<empty>,,,,1,,ANY
321435,BLOCK,1,,<empty>,,,,1,,ANY
321446,BLOCK,1,,<empty>,,,,1,,ANY
321457,BLOCK,1,,<empty>,,,,1,,ANY
321462,BLOCK,1,,<empty>,,,,1,,ANY
321466,BLOCK,1,,<empty>,,,,1,,ANY
321477,BLOCK,1,,<empty>,,,,1,,ANY
321488,BLOCK,1,,<empty>,,,,1,,ANY
321493,BLOCK,1,,<empty>,,,,1,,ANY
321497,BLOCK,1,,<empty>,,,,1,,ANY
321505,BLOCK,1,,<empty>,,,,1,,ANY
321509,BLOCK,1,,<empty>,,,,1,,ANY
321517,BLOCK,1,,<empty>,,,,1,,ANY
321528,BLOCK,1,,<empty>,,,,1,,ANY
321536,BLOCK,1,,<empty>,,,,1,,ANY
321547,BLOCK,1,,<empty>,,,,1,,ANY
321552,BLOCK,1,,<empty>,,,,1,,ANY
321556,BLOCK,1,,<empty>,,,,1,,ANY
321567,BLOCK,1,,<empty>,,,,1,,ANY
321578,BLOCK,1,,<empty>,,,,1,,ANY
321583,BLOCK,1,,<empty>,,,,1,,ANY
321588,BLOCK,1,,<empty>,,,,1,,ANY
321592,BLOCK,1,,<empty>,,,,1,,ANY
321603,BLOCK,1,,<empty>,,,,1,,ANY
321614,BLOCK,1,,<empty>,,,,1,,ANY
321620,BLOCK,1,,<empty>,,,,1,,ANY
321625,BLOCK,1,,<empty>,,,,1,,ANY
321630,BLOCK,1,,<empty>,,,,1,,ANY
321634,BLOCK,1,,<empty>,,,,1,,ANY
321645,BLOCK,1,,<empty>,,,,1,,ANY
321656,BLOCK,1,,<empty>,,,,1,,ANY
321661,BLOCK,1,,<empty>,,,,1,,ANY
321665,BLOCK,1,,<empty>,,,,1,,ANY
321676,BLOCK,1,,<empty>,,,,1,,ANY
321687,BLOCK,1,,<empty>,,,,1,,ANY
321694,BLOCK,1,,<empty>,,,,1,,ANY
321698,BLOCK,1,,<empty>,,,,1,,ANY
321709,BLOCK,1,,<empty>,,,,1,,ANY
321713,BLOCK,1,,<empty>,,,,1,,ANY
321724,BLOCK,1,,<empty>,,,,1,,ANY
321737,BLOCK,1,,<empty>,,,,1,,ANY
321741,BLOCK,1,,<empty>,,,,1,,ANY
321745,BLOCK,1,,<empty>,,,,1,,ANY
321749,BLOCK,1,,<empty>,,,,1,,ANY
321752,BLOCK,1,,<empty>,,,,1,,ANY
321756,BLOCK,1,,<empty>,,,,1,,ANY
321760,BLOCK,1,,<empty>,,,,1,,ANY
321767,BLOCK,1,,<empty>,,,,1,,ANY
321771,BLOCK,1,,<empty>,,,,1,,ANY
321775,BLOCK,1,,<empty>,,,,1,,ANY
321786,BLOCK,1,,<empty>,,,,1,,ANY
321790,BLOCK,1,,<empty>,,,,1,,ANY
321801,BLOCK,1,,<empty>,,,,1,,ANY
321814,BLOCK,1,,<empty>,,,,1,,ANY
321819,BLOCK,1,,<empty>,,,,1,,ANY
321823,BLOCK,1,,<empty>,,,,1,,ANY
321834,BLOCK,1,,<empty>,,,,1,,ANY
321845,BLOCK,1,,<empty>,,,,1,,ANY
321856,BLOCK,1,,<empty>,,,,1,,ANY
321860,BLOCK,1,,<empty>,,,,1,,ANY
321871,BLOCK,1,,<empty>,,,,1,,ANY
321882,BLOCK,1,,<empty>,,,,1,,ANY
321887,BLOCK,1,,<empty>,,,,1,,ANY
321891,BLOCK,1,,<empty>,,,,1,,ANY
321902,BLOCK,1,,<empty>,,,,1,,ANY
321913,BLOCK,1,,<empty>,,,,1,,ANY
321924,BLOCK,1,,<empty>,,,,1,,ANY
321928,BLOCK,1,,<empty>,,,,1,,ANY
321939,BLOCK,1,,<empty>,,,,1,,ANY
321950,BLOCK,1,,<empty>,,,,1,,ANY
321955,BLOCK,1,,<empty>,,,,1,,ANY
321959,BLOCK,1,,<empty>,,,,1,,ANY
321970,BLOCK,1,,<empty>,,,,1,,ANY
321981,BLOCK,1,,<empty>,,,,1,,ANY
321986,BLOCK,1,,<empty>,,,,1,,ANY
321990,BLOCK,1,,<empty>,,,,1,,ANY
322001,BLOCK,1,,<empty>,,,,1,,ANY
322012,BLOCK,1,,<empty>,,,,1,,ANY
322023,BLOCK,1,,<empty>,,,,1,,ANY
322027,BLOCK,1,,<empty>,,,,1,,ANY
322038,BLOCK,1,,<empty>,,,,1,,ANY
322049,BLOCK,1,,<empty>,,,,1,,ANY
322054,BLOCK,1,,<empty>,,,,1,,ANY
322058,BLOCK,1,,<empty>,,,,1,,ANY
322069,BLOCK,1,,<empty>,,,,1,,ANY
322080,BLOCK,1,,<empty>,,,,1,,ANY
322085,BLOCK,1,,<empty>,,,,1,,ANY
322090,BLOCK,1,,<empty>,,,,1,,ANY
322094,BLOCK,1,,<empty>,,,,1,,ANY
322105,BLOCK,1,,<empty>,,,,1,,ANY
322116,BLOCK,1,,<empty>,,,,1,,ANY
322122,BLOCK,1,,<empty>,,,,1,,ANY
322127,BLOCK,1,,<empty>,,,,1,,ANY
322132,BLOCK,1,,<empty>,,,,1,,ANY
322137,BLOCK,1,,<empty>,,,,1,,ANY
322142,BLOCK,1,,<empty>,,,,1,,ANY
322146,BLOCK,1,,<empty>,,,,1,,ANY
322151,BLOCK,1,,<empty>,,,,1,,ANY
322156,BLOCK,1,,<empty>,,,,1,,ANY
322160,BLOCK,1,,<empty>,,,,1,,ANY
322165,BLOCK,1,,<empty>,,,,1,,ANY
322169,BLOCK,1,,<empty>,,,,1,,ANY
322172,BLOCK,1,,<empty>,,,,1,,ANY
322176,BLOCK,1,,<empty>,,,,1,,ANY
322181,BLOCK,1,,<empty>,,,,1,,ANY
322185,BLOCK,1,,<empty>,,,,1,,ANY
322189,BLOCK,1,,<empty>,,,,1,,ANY
322194,BLOCK,1,,<empty>,,,,1,,ANY
322197,BLOCK,1,,<empty>,,,,1,,ANY
322201,BLOCK,1,,<empty>,,,,1,,ANY
322206,BLOCK,1,,<empty>,,,,1,,ANY
322211,BLOCK,1,,<empty>,,,,1,,ANY
322216,BLOCK,1,,<empty>,,,,1,,ANY
322221,BLOCK,1,,<empty>,,,,1,,ANY
322226,BLOCK,1,,<empty>,,,,1,,ANY
322231,BLOCK,1,,<empty>,,,,1,,ANY
322236,BLOCK,1,,<empty>,,,,1,,ANY
322240,BLOCK,1,,<empty>,,,,1,,ANY
322244,BLOCK,1,,<empty>,,,,1,,ANY
322248,BLOCK,1,,<empty>,,,,1,,ANY
322252,BLOCK,1,,<empty>,,,,1,,ANY
322256,BLOCK,1,,<empty>,,,,1,,ANY
322261,BLOCK,1,,<empty>,,,,1,,ANY
322265,BLOCK,1,,<empty>,,,,1,,ANY
322271,BLOCK,1,,<empty>,,,,1,,ANY
322278,BLOCK,1,,<empty>,,,,1,,ANY
322282,BLOCK,1,,<empty>,,,,1,,ANY
322289,BLOCK,1,,<empty>,,,,1,,ANY
322296,BLOCK,1,,<empty>,,,,1,,ANY
322301,BLOCK,1,,<empty>,,,,1,,ANY
322305,BLOCK,1,,<empty>,,,,1,,ANY
322310,BLOCK,1,,<empty>,,,,1,,ANY
322315,BLOCK,1,,<empty>,,,,1,,ANY
322320,BLOCK,1,,<empty>,,,,1,,ANY
322325,BLOCK,1,,<empty>,,,,1,,ANY
322330,BLOCK,1,,<empty>,,,,1,,ANY
322335,BLOCK,1,,<empty>,,,,1,,ANY
322340,BLOCK,1,,<empty>,,,,1,,ANY
322345,BLOCK,1,,<empty>,,,,1,,ANY
322350,BLOCK,1,,<empty>,,,,1,,ANY
322355,BLOCK,1,,<empty>,,,,1,,ANY
322360,BLOCK,1,,<empty>,,,,1,,ANY
322365,BLOCK,1,,<empty>,,,,1,,ANY
322369,BLOCK,1,,<empty>,,,,1,,ANY
322374,BLOCK,1,,<empty>,,,,1,,ANY
322378,BLOCK,1,,<empty>,,,,1,,ANY
322382,BLOCK,1,,<empty>,,,,1,,ANY
322386,BLOCK,1,,<empty>,,,,1,,ANY
322390,BLOCK,1,,<empty>,,,,1,,ANY
322394,BLOCK,1,,<empty>,,,,1,,ANY
322398,BLOCK,1,,<empty>,,,,1,,ANY
322402,BLOCK,1,,<empty>,,,,1,,ANY
322405,BLOCK,1,,<empty>,,,,1,,ANY
322409,BLOCK,1,,<empty>,,,,1,,ANY
322413,BLOCK,1,,<empty>,,,,1,,ANY
322416,BLOCK,1,,<empty>,,,,1,,ANY
322419,BLOCK,1,,<empty>,,,,1,,ANY
322423,BLOCK,1,,<empty>,,,,1,,ANY
322427,BLOCK,1,,<empty>,,,,1,,ANY
322431,BLOCK,1,,<empty>,,,,1,,ANY
322434,BLOCK,1,,<empty>,,,,1,,ANY
322438,BLOCK,1,,<empty>,,,,1,,ANY
322442,BLOCK,1,,<empty>,,,,1,,ANY
322446,BLOCK,1,,<empty>,,,,1,,ANY
322449,BLOCK,1,,<empty>,,,,1,,ANY
322453,BLOCK,1,,<empty>,,,,1,,ANY
322457,BLOCK,1,,<empty>,,,,1,,ANY
322461,BLOCK,1,,<empty>,,,,1,,ANY
322465,BLOCK,1,,<empty>,,,,1,,ANY
322469,BLOCK,1,,<empty>,,,,1,,ANY
322473,BLOCK,1,,<empty>,,,,1,,ANY
322477,BLOCK,1,,<empty>,,,,1,,ANY
322481,BLOCK,1,,<empty>,,,,1,,ANY
322485,BLOCK,1,,<empty>,,,,1,,ANY
322488,BLOCK,1,,<empty>,,,,1,,ANY
322491,BLOCK,1,,<empty>,,,,1,,ANY
322494,BLOCK,1,,<empty>,,,,1,,ANY
322499,BLOCK,1,,<empty>,,,,1,,ANY
322502,BLOCK,1,,<empty>,,,,1,,ANY
322505,BLOCK,1,,<empty>,,,,1,,ANY
322509,BLOCK,1,,<empty>,,,,1,,ANY
322512,BLOCK,1,,<empty>,,,,1,,ANY
322516,BLOCK,1,,<empty>,,,,1,,ANY
322519,BLOCK,1,,<empty>,,,,1,,ANY
322522,BLOCK,1,,<empty>,,,,1,,ANY
322527,BLOCK,1,,<empty>,,,,1,,ANY
322531,BLOCK,1,,<empty>,,,,1,,ANY
322536,BLOCK,1,,<empty>,,,,1,,ANY
322540,BLOCK,1,,<empty>,,,,1,,ANY
322545,BLOCK,1,,<empty>,,,,1,,ANY
322549,BLOCK,1,,<empty>,,,,1,,ANY
322553,BLOCK,1,,<empty>,,,,1,,ANY
322557,BLOCK,1,,<empty>,,,,1,,ANY
322563,BLOCK,1,,<empty>,,,,1,,ANY
322566,BLOCK,1,,<empty>,,,,1,,ANY
322569,BLOCK,1,,<empty>,,,,1,,ANY
322573,BLOCK,1,,<empty>,,,,1,,ANY
322577,BLOCK,1,,<empty>,,,,1,,ANY
322581,BLOCK,1,,<empty>,,,,1,,ANY
322589,BLOCK,1,,<empty>,,,,1,,ANY
322596,BLOCK,1,,<empty>,,,,1,,ANY
322601,BLOCK,1,,<empty>,,,,1,,ANY
322608,BLOCK,1,,<empty>,,,,1,,ANY
322613,BLOCK,1,,<empty>,,,,1,,ANY
322618,BLOCK,1,,<empty>,,,,1,,ANY
322623,BLOCK,1,,<empty>,,,,1,,ANY
322628,BLOCK,1,,<empty>,,,,1,,ANY
322633,BLOCK,1,,<empty>,,,,1,,ANY
322638,BLOCK,1,,<empty>,,,,1,,ANY
322643,BLOCK,1,,<empty>,,,,1,,ANY
322648,BLOCK,1,,<empty>,,,,1,,ANY
322653,BLOCK,1,,<empty>,,,,1,,ANY
322657,BLOCK,1,,<empty>,,,,1,,ANY
322661,BLOCK,1,,<empty>,,,,1,,ANY
322665,BLOCK,1,,<empty>,,,,1,,ANY
322670,BLOCK,1,,<empty>,,,,1,,ANY
322674,BLOCK,1,,<empty>,,,,1,,ANY
322678,BLOCK,1,,<empty>,,,,1,,ANY
322683,BLOCK,1,,<empty>,,,,1,,ANY
322686,BLOCK,1,,<empty>,,,,1,,ANY
322692,BLOCK,1,,<empty>,,,,1,,ANY
322695,BLOCK,1,,<empty>,,,,1,,ANY
322701,BLOCK,1,,<empty>,,,,1,,ANY
322707,BLOCK,1,,<empty>,,,,1,,ANY
322711,BLOCK,1,,<empty>,,,,1,,ANY
322719,BLOCK,1,,<empty>,,,,1,,ANY
322723,BLOCK,1,,<empty>,,,,1,,ANY
322727,BLOCK,1,,<empty>,,,,1,,ANY
322732,BLOCK,1,,<empty>,,,,1,,ANY
322736,BLOCK,1,,<empty>,,,,1,,ANY
322740,BLOCK,1,,<empty>,,,,1,,ANY
322744,BLOCK,1,,<empty>,,,,1,,ANY
322748,BLOCK,1,,<empty>,,,,1,,ANY
322752,BLOCK,1,,<empty>,,,,1,,ANY
322756,BLOCK,1,,<empty>,,,,1,,ANY
322760,BLOCK,1,,<empty>,,,,1,,ANY
322764,BLOCK,1,,<empty>,,,,1,,ANY
322768,BLOCK,1,,<empty>,,,,1,,ANY
322771,BLOCK,1,,<empty>,,,,1,,ANY
322775,BLOCK,1,,<empty>,,,,1,,ANY
322779,BLOCK,1,,<empty>,,,,1,,ANY
322782,BLOCK,1,,<empty>,,,,1,,ANY
322786,BLOCK,1,,<empty>,,,,1,,ANY
322790,BLOCK,1,,<empty>,,,,1,,ANY
322793,BLOCK,1,,<empty>,,,,1,,ANY
322796,BLOCK,1,,<empty>,,,,1,,ANY
322801,BLOCK,1,,<empty>,,,,1,,ANY
322805,BLOCK,1,,<empty>,,,,1,,ANY
322808,BLOCK,1,,<empty>,,,,1,,ANY
322813,BLOCK,1,,<empty>,,,,1,,ANY
322819,BLOCK,1,,<empty>,,,,1,,ANY
322822,BLOCK,1,,<empty>,,,,1,,ANY
322827,BLOCK,1,,<empty>,,,,1,,ANY
322836,BLOCK,1,,<empty>,,,,1,,ANY
322840,BLOCK,1,,<empty>,,,,1,,ANY
322844,BLOCK,1,,<empty>,,,,1,,ANY
322849,BLOCK,1,,<empty>,,,,1,,ANY
322853,BLOCK,1,,<empty>,,,,1,,ANY
322858,BLOCK,1,,<empty>,,,,1,,ANY
322861,BLOCK,1,,<empty>,,,,1,,ANY
322864,BLOCK,1,,<empty>,,,,1,,ANY
322869,BLOCK,1,,<empty>,,,,1,,ANY
322874,BLOCK,1,,<empty>,,,,1,,ANY
322879,BLOCK,1,,<empty>,,,,1,,ANY
322883,BLOCK,1,,<empty>,,,,1,,ANY
322891,BLOCK,1,,<empty>,,,,1,,ANY
322901,BLOCK,1,,<empty>,,,,1,,ANY
322905,BLOCK,1,,<empty>,,,,1,,ANY
322912,BLOCK,1,,<empty>,,,,1,,ANY
322919,BLOCK,1,,<empty>,,,,1,,ANY
322925,BLOCK,1,,<empty>,,,,1,,ANY
322932,BLOCK,1,,<empty>,,,,1,,ANY
322936,BLOCK,1,,<empty>,,,,1,,ANY
322941,BLOCK,1,,<empty>,,,,1,,ANY
322950,BLOCK,1,,<empty>,,,,1,,ANY
322953,BLOCK,1,,<empty>,,,,1,,ANY
322956,BLOCK,1,,<empty>,,,,1,,ANY
322960,BLOCK,1,,<empty>,,,,1,,ANY
322965,BLOCK,1,,<empty>,,,,1,,ANY
322972,BLOCK,1,,<empty>,,,,1,,ANY
322977,BLOCK,1,,<empty>,,,,1,,ANY
322982,BLOCK,1,,<empty>,,,,1,,ANY
322988,BLOCK,1,,<empty>,,,,1,,ANY
322992,BLOCK,1,,<empty>,,,,1,,ANY
322996,BLOCK,1,,<empty>,,,,1,,ANY
323000,BLOCK,1,,<empty>,,,,1,,ANY
323005,BLOCK,1,,<empty>,,,,1,,ANY
323010,BLOCK,1,,<empty>,,,,1,,ANY
323015,BLOCK,1,,<empty>,,,,1,,ANY
323022,BLOCK,1,,<empty>,,,,1,,ANY
323028,BLOCK,1,,<empty>,,,,1,,ANY
323032,BLOCK,1,,<empty>,,,,1,,ANY
323036,BLOCK,1,,<empty>,,,,1,,ANY
323040,BLOCK,1,,<empty>,,,,1,,ANY
323044,BLOCK,1,,<empty>,,,,1,,ANY
323048,BLOCK,1,,<empty>,,,,1,,ANY
323052,BLOCK,1,,<empty>,,,,1,,ANY
323056,BLOCK,1,,<empty>,,,,1,,ANY
323060,BLOCK,1,,<empty>,,,,1,,ANY
323064,BLOCK,1,,<empty>,,,,1,,ANY
323069,BLOCK,1,,<empty>,,,,1,,ANY
323077,BLOCK,1,,<empty>,,,,1,,ANY
323084,BLOCK,1,,<empty>,,,,1,,ANY
323089,BLOCK,1,,<empty>,,,,1,,ANY
323098,BLOCK,1,,<empty>,,,,1,,ANY
323106,BLOCK,1,,<empty>,,,,1,,ANY
323110,BLOCK,1,,<empty>,,,,1,,ANY
323116,BLOCK,1,,<empty>,,,,1,,ANY
323121,BLOCK,1,,<empty>,,,,1,,ANY
323126,BLOCK,1,,<empty>,,,,1,,ANY
323133,BLOCK,1,,<empty>,,,,1,,ANY
323139,BLOCK,1,,<empty>,,,,1,,ANY
323143,BLOCK,1,,<empty>,,,,1,,ANY
323147,BLOCK,1,,<empty>,,,,1,,ANY
323151,BLOCK,1,,<empty>,,,,1,,ANY
323156,BLOCK,1,,<empty>,,,,1,,ANY
323161,BLOCK,1,,<empty>,,,,1,,ANY
323166,BLOCK,1,,<empty>,,,,1,,ANY
323176,BLOCK,1,,<empty>,,,,1,,ANY
323183,BLOCK,1,,<empty>,,,,1,,ANY
323192,BLOCK,1,,<empty>,,,,1,,ANY
323197,BLOCK,1,,<empty>,,,,1,,ANY
323203,BLOCK,1,,<empty>,,,,1,,ANY
323209,BLOCK,1,,<empty>,,,,1,,ANY
323214,BLOCK,1,,<empty>,,,,1,,ANY
323218,BLOCK,1,,<empty>,,,,1,,ANY
323222,BLOCK,1,,<empty>,,,,1,,ANY
323228,BLOCK,1,,<empty>,,,,1,,ANY
323232,BLOCK,1,,<empty>,,,,1,,ANY
323236,BLOCK,1,,<empty>,,,,1,,ANY
323240,BLOCK,1,,<empty>,,,,1,,ANY
323244,BLOCK,1,,<empty>,,,,1,,ANY
323248,BLOCK,1,,<empty>,,,,1,,ANY
323252,BLOCK,1,,<empty>,,,,1,,ANY
323256,BLOCK,1,,<empty>,,,,1,,ANY
323260,BLOCK,1,,<empty>,,,,1,,ANY
323264,BLOCK,1,,<empty>,,,,1,,ANY
323268,BLOCK,1,,<empty>,,,,1,,ANY
323272,BLOCK,1,,<empty>,,,,1,,ANY
323276,BLOCK,1,,<empty>,,,,1,,ANY
323281,BLOCK,1,,<empty>,,,,1,,ANY
323285,BLOCK,1,,<empty>,,,,1,,ANY
323289,BLOCK,1,,<empty>,,,,1,,ANY
323293,BLOCK,1,,<empty>,,,,1,,ANY
323297,BLOCK,1,,<empty>,,,,1,,ANY
323301,BLOCK,1,,<empty>,,,,1,,ANY
323305,BLOCK,1,,<empty>,,,,1,,ANY
323313,BLOCK,1,,<empty>,,,,1,,ANY
323321,BLOCK,1,,<empty>,,,,1,,ANY
323329,BLOCK,1,,<empty>,,,,1,,ANY
323337,BLOCK,1,,<empty>,,,,1,,ANY
323345,BLOCK,1,,<empty>,,,,1,,ANY
323353,BLOCK,1,,<empty>,,,,1,,ANY
323361,BLOCK,1,,<empty>,,,,1,,ANY
323369,BLOCK,1,,<empty>,,,,1,,ANY
323377,BLOCK,1,,<empty>,,,,1,,ANY
323385,BLOCK,1,,<empty>,,,,1,,ANY
323390,BLOCK,1,,<empty>,,,,1,,ANY
323395,BLOCK,1,,<empty>,,,,1,,ANY
323400,BLOCK,1,,<empty>,,,,1,,ANY
323404,BLOCK,1,,<empty>,,,,1,,ANY
323412,BLOCK,1,,<empty>,,,,1,,ANY
323418,BLOCK,1,,<empty>,,,,1,,ANY
323423,BLOCK,1,,<empty>,,,,1,,ANY
323428,BLOCK,1,,<empty>,,,,1,,ANY
323434,BLOCK,1,,<empty>,,,,1,,ANY
323438,BLOCK,1,,<empty>,,,,1,,ANY
323441,BLOCK,1,,<empty>,,,,1,,ANY
323445,BLOCK,1,,<empty>,,,,1,,ANY
323449,BLOCK,1,,<empty>,,,,1,,ANY
323453,BLOCK,1,,<empty>,,,,1,,ANY
323456,BLOCK,1,,<empty>,,,,1,,ANY
323459,BLOCK,1,,<empty>,,,,1,,ANY
323463,BLOCK,1,,<empty>,,,,1,,ANY
323468,BLOCK,1,,<empty>,,,,1,,ANY
323472,BLOCK,1,,<empty>,,,,1,,ANY
323477,BLOCK,1,,<empty>,,,,1,,ANY
323481,BLOCK,1,,<empty>,,,,1,,ANY
323486,BLOCK,1,,<empty>,,,,1,,ANY
323491,BLOCK,1,,<empty>,,,,1,,ANY
323496,BLOCK,1,,<empty>,,,,1,,ANY
323500,BLOCK,1,,<empty>,,,,1,,ANY
323504,BLOCK,1,,<empty>,,,,1,,ANY
323508,BLOCK,1,,<empty>,,,,1,,ANY
323512,BLOCK,1,,<empty>,,,,1,,ANY
323515,BLOCK,1,,<empty>,,,,1,,ANY
323519,BLOCK,1,,<empty>,,,,1,,ANY
323523,BLOCK,1,,<empty>,,,,1,,ANY
323527,BLOCK,1,,<empty>,,,,1,,ANY
323531,BLOCK,1,,<empty>,,,,1,,ANY
323536,BLOCK,1,,<empty>,,,,1,,ANY
323540,BLOCK,1,,<empty>,,,,1,,ANY
323545,BLOCK,1,,<empty>,,,,1,,ANY
323550,BLOCK,1,,<empty>,,,,1,,ANY
323555,BLOCK,1,,<empty>,,,,1,,ANY
323560,BLOCK,1,,<empty>,,,,1,,ANY
323565,BLOCK,1,,<empty>,,,,1,,ANY
323569,BLOCK,1,,<empty>,,,,1,,ANY
323573,BLOCK,1,,<empty>,,,,1,,ANY
323577,BLOCK,1,,<empty>,,,,1,,ANY
323581,BLOCK,1,,<empty>,,,,1,,ANY
323585,BLOCK,1,,<empty>,,,,1,,ANY
323589,BLOCK,1,,<empty>,,,,1,,ANY
323593,BLOCK,1,,<empty>,,,,1,,ANY
323598,BLOCK,1,,<empty>,,,,1,,ANY
323602,BLOCK,1,,<empty>,,,,1,,ANY
323606,BLOCK,1,,<empty>,,,,1,,ANY
323611,BLOCK,1,,<empty>,,,,1,,ANY
323616,BLOCK,1,,<empty>,,,,1,,ANY
323622,BLOCK,1,,<empty>,,,,1,,ANY
323626,BLOCK,1,,<empty>,,,,1,,ANY
323630,BLOCK,1,,<empty>,,,,1,,ANY
323634,BLOCK,1,,<empty>,,,,1,,ANY
323640,BLOCK,1,,<empty>,,,,1,,ANY
323647,BLOCK,1,,<empty>,,,,1,,ANY
323653,BLOCK,1,,<empty>,,,,1,,ANY
323658,BLOCK,1,,<empty>,,,,1,,ANY
323664,BLOCK,1,,<empty>,,,,1,,ANY
323668,BLOCK,1,,<empty>,,,,1,,ANY
323673,BLOCK,1,,<empty>,,,,1,,ANY
323678,BLOCK,1,,<empty>,,,,1,,ANY
323682,BLOCK,1,,<empty>,,,,1,,ANY
323686,BLOCK,1,,<empty>,,,,1,,ANY
323693,BLOCK,1,,<empty>,,,,1,,ANY
323698,BLOCK,1,,<empty>,,,,1,,ANY
323704,BLOCK,1,,<empty>,,,,1,,ANY
323708,BLOCK,1,,<empty>,,,,1,,ANY
323712,BLOCK,1,,<empty>,,,,1,,ANY
323716,BLOCK,1,,<empty>,,,,1,,ANY
323721,BLOCK,1,,<empty>,,,,1,,ANY
323726,BLOCK,1,,<empty>,,,,1,,ANY
323730,BLOCK,1,,<empty>,,,,1,,ANY
323735,BLOCK,1,,<empty>,,,,1,,ANY
323739,BLOCK,1,,<empty>,,,,1,,ANY
323745,BLOCK,1,,<empty>,,,,1,,ANY
323750,BLOCK,1,,<empty>,,,,1,,ANY
323754,BLOCK,1,,<empty>,,,,1,,ANY
323759,BLOCK,1,,<empty>,,,,1,,ANY
323763,BLOCK,1,,<empty>,,,,1,,ANY
323767,BLOCK,1,,<empty>,,,,1,,ANY
323772,BLOCK,1,,<empty>,,,,1,,ANY
323776,BLOCK,1,,<empty>,,,,1,,ANY
323780,BLOCK,1,,<empty>,,,,1,,ANY
323784,BLOCK,1,,<empty>,,,,1,,ANY
323788,BLOCK,1,,<empty>,,,,1,,ANY
323792,BLOCK,1,,<empty>,,,,1,,ANY
323796,BLOCK,1,,<empty>,,,,1,,ANY
323801,BLOCK,1,,<empty>,,,,1,,ANY
323805,BLOCK,1,,<empty>,,,,1,,ANY
323808,BLOCK,1,,<empty>,,,,1,,ANY
323812,BLOCK,1,,<empty>,,,,1,,ANY
323816,BLOCK,1,,<empty>,,,,1,,ANY
323820,BLOCK,1,,<empty>,,,,1,,ANY
323824,BLOCK,1,,<empty>,,,,1,,ANY
323828,BLOCK,1,,<empty>,,,,1,,ANY
323833,BLOCK,1,,<empty>,,,,1,,ANY
323837,BLOCK,1,,<empty>,,,,1,,ANY
323841,BLOCK,1,,<empty>,,,,1,,ANY
323845,BLOCK,1,,<empty>,,,,1,,ANY
323850,BLOCK,1,,<empty>,,,,1,,ANY
323856,BLOCK,1,,<empty>,,,,1,,ANY
323860,BLOCK,1,,<empty>,,,,1,,ANY
323864,BLOCK,1,,<empty>,,,,1,,ANY
323871,BLOCK,1,,<empty>,,,,1,,ANY
323875,BLOCK,1,,<empty>,,,,1,,ANY
323880,BLOCK,1,,<empty>,,,,1,,ANY
323884,BLOCK,1,,<empty>,,,,1,,ANY
323888,BLOCK,1,,<empty>,,,,1,,ANY
323895,BLOCK,1,,<empty>,,,,1,,ANY
323899,BLOCK,1,,<empty>,,,,1,,ANY
323907,BLOCK,1,,<empty>,,,,1,,ANY
323911,BLOCK,1,,<empty>,,,,1,,ANY
323917,BLOCK,1,,<empty>,,,,1,,ANY
323921,BLOCK,1,,<empty>,,,,1,,ANY
323926,BLOCK,1,,<empty>,,,,1,,ANY
323930,BLOCK,1,,<empty>,,,,1,,ANY
323934,BLOCK,1,,<empty>,,,,1,,ANY
323938,BLOCK,1,,<empty>,,,,1,,ANY
323942,BLOCK,1,,<empty>,,,,1,,ANY
323946,BLOCK,1,,<empty>,,,,1,,ANY
323951,BLOCK,1,,<empty>,,,,1,,ANY
323955,BLOCK,1,,<empty>,,,,1,,ANY
323958,BLOCK,1,,<empty>,,,,1,,ANY
323962,BLOCK,1,,<empty>,,,,1,,ANY
323966,BLOCK,1,,<empty>,,,,1,,ANY
323970,BLOCK,1,,<empty>,,,,1,,ANY
323974,BLOCK,1,,<empty>,,,,1,,ANY
323978,BLOCK,1,,<empty>,,,,1,,ANY
323983,BLOCK,1,,<empty>,,,,1,,ANY
323988,BLOCK,1,,<empty>,,,,1,,ANY
323993,BLOCK,1,,<empty>,,,,1,,ANY
323999,BLOCK,1,,<empty>,,,,1,,ANY
324003,BLOCK,1,,<empty>,,,,1,,ANY
324007,BLOCK,1,,<empty>,,,,1,,ANY
324012,BLOCK,1,,<empty>,,,,1,,ANY
324015,BLOCK,1,,<empty>,,,,1,,ANY
324019,BLOCK,1,,<empty>,,,,1,,ANY
324022,BLOCK,1,,<empty>,,,,1,,ANY
324025,BLOCK,1,,<empty>,,,,1,,ANY
324028,BLOCK,1,,<empty>,,,,1,,ANY
324031,BLOCK,1,,<empty>,,,,1,,ANY
324034,BLOCK,1,,<empty>,,,,1,,ANY
324037,BLOCK,1,,<empty>,,,,1,,ANY
324040,BLOCK,1,,<empty>,,,,1,,ANY
324044,BLOCK,1,,<empty>,,,,1,,ANY
324049,BLOCK,1,,<empty>,,,,1,,ANY
324052,BLOCK,1,,<empty>,,,,1,,ANY
324057,BLOCK,1,,<empty>,,,,1,,ANY
324063,BLOCK,1,,<empty>,,,,1,,ANY
324069,BLOCK,1,,<empty>,,,,1,,ANY
324074,BLOCK,1,,<empty>,,,,1,,ANY
324079,BLOCK,1,,<empty>,,,,1,,ANY
324083,BLOCK,1,,<empty>,,,,1,,ANY
324087,BLOCK,1,,<empty>,,,,1,,ANY
324092,BLOCK,1,,<empty>,,,,1,,ANY
324098,BLOCK,1,,<empty>,,,,1,,ANY
324102,BLOCK,1,,<empty>,,,,1,,ANY
324106,BLOCK,1,,<empty>,,,,1,,ANY
324111,BLOCK,1,,<empty>,,,,1,,ANY
324117,BLOCK,1,,<empty>,,,,1,,ANY
324122,BLOCK,1,,<empty>,,,,1,,ANY
324127,BLOCK,1,,<empty>,,,,1,,ANY
324131,BLOCK,1,,<empty>,,,,1,,ANY
324137,BLOCK,1,,<empty>,,,,1,,ANY
324141,BLOCK,1,,<empty>,,,,1,,ANY
324145,BLOCK,1,,<empty>,,,,1,,ANY
324149,BLOCK,1,,<empty>,,,,1,,ANY
324153,BLOCK,1,,<empty>,,,,1,,ANY
324157,BLOCK,1,,<empty>,,,,1,,ANY
324161,BLOCK,1,,<empty>,,,,1,,ANY
324165,BLOCK,1,,<empty>,,,,1,,ANY
324169,BLOCK,1,,<empty>,,,,1,,ANY
324173,BLOCK,1,,<empty>,,,,1,,ANY
324177,BLOCK,1,,<empty>,,,,1,,ANY
324182,BLOCK,1,,<empty>,,,,1,,ANY
324189,BLOCK,1,,<empty>,,,,1,,ANY
324193,BLOCK,1,,<empty>,,,,1,,ANY
324198,BLOCK,1,,<empty>,,,,1,,ANY
324203,BLOCK,1,,<empty>,,,,1,,ANY
324207,BLOCK,1,,<empty>,,,,1,,ANY
324211,BLOCK,1,,<empty>,,,,1,,ANY
324215,BLOCK,1,,<empty>,,,,1,,ANY
324220,BLOCK,1,,<empty>,,,,1,,ANY
324224,BLOCK,1,,<empty>,,,,1,,ANY
324228,BLOCK,1,,<empty>,,,,1,,ANY
324234,BLOCK,1,,<empty>,,,,1,,ANY
324238,BLOCK,1,,<empty>,,,,1,,ANY
324243,BLOCK,1,,<empty>,,,,1,,ANY
324248,BLOCK,1,,<empty>,,,,1,,ANY
324252,BLOCK,1,,<empty>,,,,1,,ANY
324256,BLOCK,1,,<empty>,,,,1,,ANY
324260,BLOCK,1,,<empty>,,,,1,,ANY
324264,BLOCK,1,,<empty>,,,,1,,ANY
324268,BLOCK,1,,<empty>,,,,1,,ANY
324272,BLOCK,1,,<empty>,,,,1,,ANY
324276,BLOCK,1,,<empty>,,,,1,,ANY
324281,BLOCK,1,,<empty>,,,,1,,ANY
324286,BLOCK,1,,<empty>,,,,1,,ANY
324289,BLOCK,1,,<empty>,,,,1,,ANY
324295,BLOCK,1,,<empty>,,,,1,,ANY
324302,BLOCK,1,,<empty>,,,,1,,ANY
324306,BLOCK,1,,<empty>,,,,1,,ANY
324311,BLOCK,1,,<empty>,,,,1,,ANY
324315,BLOCK,1,,<empty>,,,,1,,ANY
324318,BLOCK,1,,<empty>,,,,1,,ANY
324324,BLOCK,1,,<empty>,,,,1,,ANY
324330,BLOCK,1,,<empty>,,,,1,,ANY
324336,BLOCK,1,,<empty>,,,,1,,ANY
324342,BLOCK,1,,<empty>,,,,1,,ANY
324348,BLOCK,1,,<empty>,,,,1,,ANY
324352,BLOCK,1,,<empty>,,,,1,,ANY
324356,BLOCK,1,,<empty>,,,,1,,ANY
324360,BLOCK,1,,<empty>,,,,1,,ANY
324364,BLOCK,1,,<empty>,,,,1,,ANY
324368,BLOCK,1,,<empty>,,,,1,,ANY
324372,BLOCK,1,,<empty>,,,,1,,ANY
324380,BLOCK,1,,<empty>,,,,1,,ANY
324384,BLOCK,1,,<empty>,,,,1,,ANY
324387,BLOCK,1,,<empty>,,,,1,,ANY
324393,BLOCK,1,,<empty>,,,,1,,ANY
324401,BLOCK,1,,<empty>,,,,1,,ANY
324409,BLOCK,1,,<empty>,,,,1,,ANY
324417,BLOCK,1,,<empty>,,,,1,,ANY
324425,BLOCK,1,,<empty>,,,,1,,ANY
324433,BLOCK,1,,<empty>,,,,1,,ANY
324441,BLOCK,1,,<empty>,,,,1,,ANY
324449,BLOCK,1,,<empty>,,,,1,,ANY
324457,BLOCK,1,,<empty>,,,,1,,ANY
324465,BLOCK,1,,<empty>,,,,1,,ANY
324473,BLOCK,1,,<empty>,,,,1,,ANY
324481,BLOCK,1,,<empty>,,,,1,,ANY
324486,BLOCK,1,,<empty>,,,,1,,ANY
324491,BLOCK,1,,<empty>,,,,1,,ANY
324495,BLOCK,1,,<empty>,,,,1,,ANY
324499,BLOCK,1,,<empty>,,,,1,,ANY
324503,BLOCK,1,,<empty>,,,,1,,ANY
324507,BLOCK,1,,<empty>,,,,1,,ANY
324514,BLOCK,1,,<empty>,,,,1,,ANY
324518,BLOCK,1,,<empty>,,,,1,,ANY
324522,BLOCK,1,,<empty>,,,,1,,ANY
324526,BLOCK,1,,<empty>,,,,1,,ANY
324531,BLOCK,1,,<empty>,,,,1,,ANY
324535,BLOCK,1,,<empty>,,,,1,,ANY
324539,BLOCK,1,,<empty>,,,,1,,ANY
324543,BLOCK,1,,<empty>,,,,1,,ANY
324548,BLOCK,1,,<empty>,,,,1,,ANY
324552,BLOCK,1,,<empty>,,,,1,,ANY
324556,BLOCK,1,,<empty>,,,,1,,ANY
324560,BLOCK,1,,<empty>,,,,1,,ANY
324566,BLOCK,1,,<empty>,,,,1,,ANY
324570,BLOCK,1,,<empty>,,,,1,,ANY
324574,BLOCK,1,,<empty>,,,,1,,ANY
324578,BLOCK,1,,<empty>,,,,1,,ANY
324583,BLOCK,1,,<empty>,,,,1,,ANY
324587,BLOCK,1,,<empty>,,,,1,,ANY
324591,BLOCK,1,,<empty>,,,,1,,ANY
324595,BLOCK,1,,<empty>,,,,1,,ANY
324599,BLOCK,1,,<empty>,,,,1,,ANY
324605,BLOCK,1,,<empty>,,,,1,,ANY
324608,BLOCK,1,,<empty>,,,,1,,ANY
324615,BLOCK,1,,<empty>,,,,1,,ANY
324619,BLOCK,1,,<empty>,,,,1,,ANY
324624,BLOCK,1,,<empty>,,,,1,,ANY
324628,BLOCK,1,,<empty>,,,,1,,ANY
324636,BLOCK,1,,<empty>,,,,1,,ANY
324640,BLOCK,1,,<empty>,,,,1,,ANY
324644,BLOCK,1,,<empty>,,,,1,,ANY
324648,BLOCK,1,,<empty>,,,,1,,ANY
324651,BLOCK,1,,<empty>,,,,1,,ANY
324654,BLOCK,1,,<empty>,,,,1,,ANY
324658,BLOCK,1,,<empty>,,,,1,,ANY
324661,BLOCK,1,,<empty>,,,,1,,ANY
324665,BLOCK,1,,<empty>,,,,1,,ANY
324668,BLOCK,1,,<empty>,,,,1,,ANY
324672,BLOCK,1,,<empty>,,,,1,,ANY
324676,BLOCK,1,,<empty>,,,,1,,ANY
324680,BLOCK,1,,<empty>,,,,1,,ANY
324686,BLOCK,1,,<empty>,,,,1,,ANY
324689,BLOCK,1,,<empty>,,,,1,,ANY
324693,BLOCK,1,,<empty>,,,,1,,ANY
324698,BLOCK,1,,<empty>,,,,1,,ANY
324703,BLOCK,1,,<empty>,,,,1,,ANY
324707,BLOCK,1,,<empty>,,,,1,,ANY
324711,BLOCK,1,,<empty>,,,,1,,ANY
324715,BLOCK,1,,<empty>,,,,1,,ANY
324719,BLOCK,1,,<empty>,,,,1,,ANY
324723,BLOCK,1,,<empty>,,,,1,,ANY
324727,BLOCK,1,,<empty>,,,,1,,ANY
324730,BLOCK,1,,<empty>,,,,1,,ANY
324734,BLOCK,1,,<empty>,,,,1,,ANY
324738,BLOCK,1,,<empty>,,,,1,,ANY
324742,BLOCK,1,,<empty>,,,,1,,ANY
324746,BLOCK,1,,<empty>,,,,1,,ANY
324750,BLOCK,1,,<empty>,,,,1,,ANY
324756,BLOCK,1,,<empty>,,,,1,,ANY
324761,BLOCK,1,,<empty>,,,,1,,ANY
324765,BLOCK,1,,<empty>,,,,1,,ANY
324770,BLOCK,1,,<empty>,,,,1,,ANY
324774,BLOCK,1,,<empty>,,,,1,,ANY
324777,BLOCK,1,,<empty>,,,,1,,ANY
324781,BLOCK,1,,<empty>,,,,1,,ANY
324785,BLOCK,1,,<empty>,,,,1,,ANY
324789,BLOCK,1,,<empty>,,,,1,,ANY
324795,BLOCK,1,,<empty>,,,,1,,ANY
324799,BLOCK,1,,<empty>,,,,1,,ANY
324803,BLOCK,1,,<empty>,,,,1,,ANY
324807,BLOCK,1,,<empty>,,,,1,,ANY
324811,BLOCK,1,,<empty>,,,,1,,ANY
324815,BLOCK,1,,<empty>,,,,1,,ANY
324819,BLOCK,1,,<empty>,,,,1,,ANY
324823,BLOCK,1,,<empty>,,,,1,,ANY
324827,BLOCK,1,,<empty>,,,,1,,ANY
324831,BLOCK,1,,<empty>,,,,1,,ANY
324835,BLOCK,1,,<empty>,,,,1,,ANY
324839,BLOCK,1,,<empty>,,,,1,,ANY
324843,BLOCK,1,,<empty>,,,,1,,ANY
324847,BLOCK,1,,<empty>,,,,1,,ANY
324851,BLOCK,1,,<empty>,,,,1,,ANY
324855,BLOCK,1,,<empty>,,,,1,,ANY
324861,BLOCK,1,,<empty>,,,,1,,ANY
324864,BLOCK,1,,<empty>,,,,1,,ANY
324867,BLOCK,1,,<empty>,,,,1,,ANY
324872,BLOCK,1,,<empty>,,,,1,,ANY
324876,BLOCK,1,,<empty>,,,,1,,ANY
324881,BLOCK,1,,<empty>,,,,1,,ANY
324889,BLOCK,1,,<empty>,,,,1,,ANY
324894,BLOCK,1,,<empty>,,,,1,,ANY
324899,BLOCK,1,,<empty>,,,,1,,ANY
324903,BLOCK,1,,<empty>,,,,1,,ANY
324908,BLOCK,1,,<empty>,,,,1,,ANY
324912,BLOCK,1,,<empty>,,,,1,,ANY
324916,BLOCK,1,,<empty>,,,,1,,ANY
324921,BLOCK,1,,<empty>,,,,1,,ANY
324927,BLOCK,1,,<empty>,,,,1,,ANY
324931,BLOCK,1,,<empty>,,,,1,,ANY
324935,BLOCK,1,,<empty>,,,,1,,ANY
324940,BLOCK,1,,<empty>,,,,1,,ANY
324945,BLOCK,1,,<empty>,,,,1,,ANY
324949,BLOCK,1,,<empty>,,,,1,,ANY
324953,BLOCK,1,,<empty>,,,,1,,ANY
324957,BLOCK,1,,<empty>,,,,1,,ANY
324964,BLOCK,1,,<empty>,,,,1,,ANY
324969,BLOCK,1,,<empty>,,,,1,,ANY
324973,BLOCK,1,,<empty>,,,,1,,ANY
324977,BLOCK,1,,<empty>,,,,1,,ANY
324981,BLOCK,1,,<empty>,,,,1,,ANY
324985,BLOCK,1,,<empty>,,,,1,,ANY
324990,BLOCK,1,,<empty>,,,,1,,ANY
324994,BLOCK,1,,<empty>,,,,1,,ANY
324998,BLOCK,1,,<empty>,,,,1,,ANY
325003,BLOCK,1,,<empty>,,,,1,,ANY
325007,BLOCK,1,,<empty>,,,,1,,ANY
325011,BLOCK,1,,<empty>,,,,1,,ANY
325015,BLOCK,1,,<empty>,,,,1,,ANY
325019,BLOCK,1,,<empty>,,,,1,,ANY
325023,BLOCK,1,,<empty>,,,,1,,ANY
325028,BLOCK,1,,<empty>,,,,1,,ANY
325033,BLOCK,1,,<empty>,,,,1,,ANY
325037,BLOCK,1,,<empty>,,,,1,,ANY
325042,BLOCK,1,,<empty>,,,,1,,ANY
325046,BLOCK,1,,<empty>,,,,1,,ANY
325050,BLOCK,1,,<empty>,,,,1,,ANY
325058,BLOCK,1,,<empty>,,,,1,,ANY
325063,BLOCK,1,,<empty>,,,,1,,ANY
325069,BLOCK,1,,<empty>,,,,1,,ANY
325075,BLOCK,1,,<empty>,,,,1,,ANY
325081,BLOCK,1,,<empty>,,,,1,,ANY
325085,BLOCK,1,,<empty>,,,,1,,ANY
325089,BLOCK,1,,<empty>,,,,1,,ANY
325093,BLOCK,1,,<empty>,,,,1,,ANY
325097,BLOCK,1,,<empty>,,,,1,,ANY
325101,BLOCK,1,,<empty>,,,,1,,ANY
325105,BLOCK,1,,<empty>,,,,1,,ANY
325109,BLOCK,1,,<empty>,,,,1,,ANY
325113,BLOCK,1,,<empty>,,,,1,,ANY
325117,BLOCK,1,,<empty>,,,,1,,ANY
325121,BLOCK,1,,<empty>,,,,1,,ANY
325125,BLOCK,1,,<empty>,,,,1,,ANY
325129,BLOCK,1,,<empty>,,,,1,,ANY
325133,BLOCK,1,,<empty>,,,,1,,ANY
325137,BLOCK,1,,<empty>,,,,1,,ANY
325142,BLOCK,1,,<empty>,,,,1,,ANY
325146,BLOCK,1,,<empty>,,,,1,,ANY
325150,BLOCK,1,,<empty>,,,,1,,ANY
325156,BLOCK,1,,<empty>,,,,1,,ANY
325162,BLOCK,1,,<empty>,,,,1,,ANY
325166,BLOCK,1,,<empty>,,,,1,,ANY
325178,BLOCK,1,,<empty>,,,,1,,ANY
325183,BLOCK,1,,<empty>,,,,1,,ANY
325189,BLOCK,1,,<empty>,,,,1,,ANY
325194,BLOCK,1,,<empty>,,,,1,,ANY
325202,BLOCK,1,,<empty>,,,,1,,ANY
325207,BLOCK,1,,<empty>,,,,1,,ANY
325213,BLOCK,1,,<empty>,,,,1,,ANY
325220,BLOCK,1,,<empty>,,,,1,,ANY
325226,BLOCK,1,,<empty>,,,,1,,ANY
325232,BLOCK,1,,<empty>,,,,1,,ANY
325238,BLOCK,1,,<empty>,,,,1,,ANY
325243,BLOCK,1,,<empty>,,,,1,,ANY
325249,BLOCK,1,,<empty>,,,,1,,ANY
325255,BLOCK,1,,<empty>,,,,1,,ANY
325261,BLOCK,1,,<empty>,,,,1,,ANY
325265,BLOCK,1,,<empty>,,,,1,,ANY
325270,BLOCK,1,,<empty>,,,,1,,ANY
325275,BLOCK,1,,<empty>,,,,1,,ANY
325280,BLOCK,1,,<empty>,,,,1,,ANY
325284,BLOCK,1,,<empty>,,,,1,,ANY
325290,BLOCK,1,,<empty>,,,,1,,ANY
325294,BLOCK,1,,<empty>,,,,1,,ANY
325299,BLOCK,1,,<empty>,,,,1,,ANY
325304,BLOCK,1,,<empty>,,,,1,,ANY
325309,BLOCK,1,,<empty>,,,,1,,ANY
325313,BLOCK,1,,<empty>,,,,1,,ANY
325317,BLOCK,1,,<empty>,,,,1,,ANY
325323,BLOCK,1,,<empty>,,,,1,,ANY
325326,BLOCK,1,,<empty>,,,,1,,ANY
325329,BLOCK,1,,<empty>,,,,1,,ANY
325332,BLOCK,1,,<empty>,,,,1,,ANY
325337,BLOCK,1,,<empty>,,,,1,,ANY
325342,BLOCK,1,,<empty>,,,,1,,ANY
325346,BLOCK,1,,<empty>,,,,1,,ANY
325350,BLOCK,1,,<empty>,,,,1,,ANY
325354,BLOCK,1,,<empty>,,,,1,,ANY
325358,BLOCK,1,,<empty>,,,,1,,ANY
325364,BLOCK,1,,<empty>,,,,1,,ANY
325367,BLOCK,1,,<empty>,,,,1,,ANY
325371,BLOCK,1,,<empty>,,,,1,,ANY
325377,BLOCK,1,,<empty>,,,,1,,ANY
325382,BLOCK,1,,<empty>,,,,1,,ANY
325387,BLOCK,1,,<empty>,,,,1,,ANY
325392,BLOCK,1,,<empty>,,,,1,,ANY
325398,BLOCK,1,,<empty>,,,,1,,ANY
325402,BLOCK,1,,<empty>,,,,1,,ANY
325406,BLOCK,1,,<empty>,,,,1,,ANY
325411,BLOCK,1,,<empty>,,,,1,,ANY
325415,BLOCK,1,,<empty>,,,,1,,ANY
325421,BLOCK,1,,<empty>,,,,1,,ANY
325425,BLOCK,1,,<empty>,,,,1,,ANY
325430,BLOCK,1,,<empty>,,,,1,,ANY
325435,BLOCK,1,,<empty>,,,,1,,ANY
325441,BLOCK,1,,<empty>,,,,1,,ANY
325445,BLOCK,1,,<empty>,,,,1,,ANY
325450,BLOCK,1,,<empty>,,,,1,,ANY
325455,BLOCK,1,,<empty>,,,,1,,ANY
325460,BLOCK,1,,<empty>,,,,1,,ANY
325464,BLOCK,1,,<empty>,,,,1,,ANY
325468,BLOCK,1,,<empty>,,,,1,,ANY
325474,BLOCK,1,,<empty>,,,,1,,ANY
325479,BLOCK,1,,<empty>,,,,1,,ANY
325483,BLOCK,1,,<empty>,,,,1,,ANY
325486,BLOCK,1,,<empty>,,,,1,,ANY
325491,BLOCK,1,,<empty>,,,,1,,ANY
325496,BLOCK,1,,<empty>,,,,1,,ANY
325500,BLOCK,1,,<empty>,,,,1,,ANY
325504,BLOCK,1,,<empty>,,,,1,,ANY
325509,BLOCK,1,,<empty>,,,,1,,ANY
325512,BLOCK,1,,<empty>,,,,1,,ANY
325515,BLOCK,1,,<empty>,,,,1,,ANY
325519,BLOCK,1,,<empty>,,,,1,,ANY
325523,BLOCK,1,,<empty>,,,,1,,ANY
325528,BLOCK,1,,<empty>,,,,1,,ANY
325532,BLOCK,1,,<empty>,,,,1,,ANY
325535,BLOCK,1,,<empty>,,,,1,,ANY
325538,BLOCK,1,,<empty>,,,,1,,ANY
325541,BLOCK,1,,<empty>,,,,1,,ANY
325544,BLOCK,1,,<empty>,,,,1,,ANY
325548,BLOCK,1,,<empty>,,,,1,,ANY
325552,BLOCK,1,,<empty>,,,,1,,ANY
325556,BLOCK,1,,<empty>,,,,1,,ANY
325560,BLOCK,1,,<empty>,,,,1,,ANY
325564,BLOCK,1,,<empty>,,,,1,,ANY
325567,BLOCK,1,,<empty>,,,,1,,ANY
325572,BLOCK,1,,<empty>,,,,1,,ANY
325577,BLOCK,1,,<empty>,,,,1,,ANY
325582,BLOCK,1,,<empty>,,,,1,,ANY
325587,BLOCK,1,,<empty>,,,,1,,ANY
325591,BLOCK,1,,<empty>,,,,1,,ANY
325594,BLOCK,1,,<empty>,,,,1,,ANY
325600,BLOCK,1,,<empty>,,,,1,,ANY
325604,BLOCK,1,,<empty>,,,,1,,ANY
325608,BLOCK,1,,<empty>,,,,1,,ANY
325612,BLOCK,1,,<empty>,,,,1,,ANY
325616,BLOCK,1,,<empty>,,,,1,,ANY
325620,BLOCK,1,,<empty>,,,,1,,ANY
325624,BLOCK,1,,<empty>,,,,1,,ANY
325628,BLOCK,1,,<empty>,,,,1,,ANY
325632,BLOCK,1,,<empty>,,,,1,,ANY
325638,BLOCK,1,,<empty>,,,,1,,ANY
325643,BLOCK,1,,<empty>,,,,1,,ANY
325648,BLOCK,1,,<empty>,,,,1,,ANY
325652,BLOCK,1,,<empty>,,,,1,,ANY
325656,BLOCK,1,,<empty>,,,,1,,ANY
325659,BLOCK,1,,<empty>,,,,1,,ANY
325667,BLOCK,1,,<empty>,,,,1,,ANY
325673,BLOCK,1,,<empty>,,,,1,,ANY
325677,BLOCK,1,,<empty>,,,,1,,ANY
325685,BLOCK,1,,<empty>,,,,1,,ANY
325690,BLOCK,1,,<empty>,,,,1,,ANY
325696,BLOCK,1,,<empty>,,,,1,,ANY
325701,BLOCK,1,,<empty>,,,,1,,ANY
325705,BLOCK,1,,<empty>,,,,1,,ANY
325709,BLOCK,1,,<empty>,,,,1,,ANY
325715,BLOCK,1,,<empty>,,,,1,,ANY
325720,BLOCK,1,,<empty>,,,,1,,ANY
325724,BLOCK,1,,<empty>,,,,1,,ANY
325728,BLOCK,1,,<empty>,,,,1,,ANY
325733,BLOCK,1,,<empty>,,,,1,,ANY
325738,BLOCK,1,,<empty>,,,,1,,ANY
325742,BLOCK,1,,<empty>,,,,1,,ANY
325749,BLOCK,1,,<empty>,,,,1,,ANY
325753,BLOCK,1,,<empty>,,,,1,,ANY
325757,BLOCK,1,,<empty>,,,,1,,ANY
325764,BLOCK,1,,<empty>,,,,1,,ANY
325769,BLOCK,1,,<empty>,,,,1,,ANY
325773,BLOCK,1,,<empty>,,,,1,,ANY
325778,BLOCK,1,,<empty>,,,,1,,ANY
325783,BLOCK,1,,<empty>,,,,1,,ANY
325788,BLOCK,1,,<empty>,,,,1,,ANY
325793,BLOCK,1,,<empty>,,,,1,,ANY
325798,BLOCK,1,,<empty>,,,,1,,ANY
325803,BLOCK,1,,<empty>,,,,1,,ANY
325809,BLOCK,1,,<empty>,,,,1,,ANY
325815,BLOCK,1,,<empty>,,,,1,,ANY
325821,BLOCK,1,,<empty>,,,,1,,ANY
325827,BLOCK,1,,<empty>,,,,1,,ANY
325832,BLOCK,1,,<empty>,,,,1,,ANY
325837,BLOCK,1,,<empty>,,,,1,,ANY
325843,BLOCK,1,,<empty>,,,,1,,ANY
325848,BLOCK,1,,<empty>,,,,1,,ANY
325853,BLOCK,1,,<empty>,,,,1,,ANY
325857,BLOCK,1,,<empty>,,,,1,,ANY
325860,BLOCK,1,,<empty>,,,,1,,ANY
325866,BLOCK,1,,<empty>,,,,1,,ANY
325871,BLOCK,1,,<empty>,,,,1,,ANY
325877,BLOCK,1,,<empty>,,,,1,,ANY
325883,BLOCK,1,,<empty>,,,,1,,ANY
325888,BLOCK,1,,<empty>,,,,1,,ANY
325893,BLOCK,1,,<empty>,,,,1,,ANY
325899,BLOCK,1,,<empty>,,,,1,,ANY
325903,BLOCK,1,,<empty>,,,,1,,ANY
325908,BLOCK,1,,<empty>,,,,1,,ANY
325911,BLOCK,1,,<empty>,,,,1,,ANY
325915,BLOCK,1,,<empty>,,,,1,,ANY
325919,BLOCK,1,,<empty>,,,,1,,ANY
325924,BLOCK,1,,<empty>,,,,1,,ANY
325928,BLOCK,1,,<empty>,,,,1,,ANY
325932,BLOCK,1,,<empty>,,,,1,,ANY
325936,BLOCK,1,,<empty>,,,,1,,ANY
325941,BLOCK,1,,<empty>,,,,1,,ANY
325947,BLOCK,1,,<empty>,,,,1,,ANY
325952,BLOCK,1,,<empty>,,,,1,,ANY
325960,BLOCK,1,,<empty>,,,,1,,ANY
325967,BLOCK,1,,<empty>,,,,1,,ANY
325972,BLOCK,1,,<empty>,,,,1,,ANY
325976,BLOCK,1,,<empty>,,,,1,,ANY
325980,BLOCK,1,,<empty>,,,,1,,ANY
325989,BLOCK,1,,<empty>,,,,1,,ANY
325995,BLOCK,1,,<empty>,,,,1,,ANY
325999,BLOCK,1,,<empty>,,,,1,,ANY
326003,BLOCK,1,,<empty>,,,,1,,ANY
326009,BLOCK,1,,<empty>,,,,1,,ANY
326014,BLOCK,1,,<empty>,,,,1,,ANY
326019,BLOCK,1,,<empty>,,,,1,,ANY
326027,BLOCK,1,,<empty>,,,,1,,ANY
326035,BLOCK,1,,<empty>,,,,1,,ANY
326043,BLOCK,1,,<empty>,,,,1,,ANY
326051,BLOCK,1,,<empty>,,,,1,,ANY
326055,BLOCK,1,,<empty>,,,,1,,ANY
326058,BLOCK,1,,<empty>,,,,1,,ANY
326064,BLOCK,1,,<empty>,,,,1,,ANY
326070,BLOCK,1,,<empty>,,,,1,,ANY
326074,BLOCK,1,,<empty>,,,,1,,ANY
326079,BLOCK,1,,<empty>,,,,1,,ANY
326084,BLOCK,1,,<empty>,,,,1,,ANY
326088,BLOCK,1,,<empty>,,,,1,,ANY
326092,BLOCK,1,,<empty>,,,,1,,ANY
326096,BLOCK,1,,<empty>,,,,1,,ANY
326100,BLOCK,1,,<empty>,,,,1,,ANY
326104,BLOCK,1,,<empty>,,,,1,,ANY
326107,BLOCK,1,,<empty>,,,,1,,ANY
326112,BLOCK,1,,<empty>,,,,1,,ANY
326117,BLOCK,1,,<empty>,,,,1,,ANY
326121,BLOCK,1,,<empty>,,,,1,,ANY
326126,BLOCK,1,,<empty>,,,,1,,ANY
326131,BLOCK,1,,<empty>,,,,1,,ANY
326136,BLOCK,1,,<empty>,,,,1,,ANY
326140,BLOCK,1,,<empty>,,,,1,,ANY
326146,BLOCK,1,,<empty>,,,,1,,ANY
326150,BLOCK,1,,<empty>,,,,1,,ANY
326155,BLOCK,1,,<empty>,,,,1,,ANY
326160,BLOCK,1,,<empty>,,,,1,,ANY
326165,BLOCK,1,,<empty>,,,,1,,ANY
326170,BLOCK,1,,<empty>,,,,1,,ANY
326175,BLOCK,1,,<empty>,,,,1,,ANY
326180,BLOCK,1,,<empty>,,,,1,,ANY
326185,BLOCK,1,,<empty>,,,,1,,ANY
326190,BLOCK,1,,<empty>,,,,1,,ANY
326195,BLOCK,1,,<empty>,,,,1,,ANY
326199,BLOCK,1,,<empty>,,,,1,,ANY
326203,BLOCK,1,,<empty>,,,,1,,ANY
326207,BLOCK,1,,<empty>,,,,1,,ANY
326211,BLOCK,1,,<empty>,,,,1,,ANY
326215,BLOCK,1,,<empty>,,,,1,,ANY
326220,BLOCK,1,,<empty>,,,,1,,ANY
326224,BLOCK,1,,<empty>,,,,1,,ANY
326228,BLOCK,1,,<empty>,,,,1,,ANY
326233,BLOCK,1,,<empty>,,,,1,,ANY
326237,BLOCK,1,,<empty>,,,,1,,ANY
326241,BLOCK,1,,<empty>,,,,1,,ANY
326245,BLOCK,1,,<empty>,,,,1,,ANY
326248,BLOCK,1,,<empty>,,,,1,,ANY
326254,BLOCK,1,,<empty>,,,,1,,ANY
326260,BLOCK,1,,<empty>,,,,1,,ANY
326266,BLOCK,1,,<empty>,,,,1,,ANY
326269,BLOCK,1,,<empty>,,,,1,,ANY
326275,BLOCK,1,,<empty>,,,,1,,ANY
326281,BLOCK,1,,<empty>,,,,1,,ANY
326287,BLOCK,1,,<empty>,,,,1,,ANY
326290,BLOCK,1,,<empty>,,,,1,,ANY
326296,BLOCK,1,,<empty>,,,,1,,ANY
326302,BLOCK,1,,<empty>,,,,1,,ANY
326308,BLOCK,1,,<empty>,,,,1,,ANY
326314,BLOCK,1,,<empty>,,,,1,,ANY
326320,BLOCK,1,,<empty>,,,,1,,ANY
326326,BLOCK,1,,<empty>,,,,1,,ANY
326329,BLOCK,1,,<empty>,,,,1,,ANY
326333,BLOCK,1,,<empty>,,,,1,,ANY
326336,BLOCK,1,,<empty>,,,,1,,ANY
326339,BLOCK,1,,<empty>,,,,1,,ANY
326343,BLOCK,1,,<empty>,,,,1,,ANY
326348,BLOCK,1,,<empty>,,,,1,,ANY
326352,BLOCK,1,,<empty>,,,,1,,ANY
326356,BLOCK,1,,<empty>,,,,1,,ANY
326361,BLOCK,1,,<empty>,,,,1,,ANY
326365,BLOCK,1,,<empty>,,,,1,,ANY
326369,BLOCK,1,,<empty>,,,,1,,ANY
326374,BLOCK,1,,<empty>,,,,1,,ANY
326378,BLOCK,1,,<empty>,,,,1,,ANY
326382,BLOCK,1,,<empty>,,,,1,,ANY
326386,BLOCK,1,,<empty>,,,,1,,ANY
326391,BLOCK,1,,<empty>,,,,1,,ANY
326397,BLOCK,1,,<empty>,,,,1,,ANY
326401,BLOCK,1,,<empty>,,,,1,,ANY
326405,BLOCK,1,,<empty>,,,,1,,ANY
326410,BLOCK,1,,<empty>,,,,1,,ANY
326415,BLOCK,1,,<empty>,,,,1,,ANY
326420,BLOCK,1,,<empty>,,,,1,,ANY
326423,BLOCK,1,,<empty>,,,,1,,ANY
326428,BLOCK,1,,<empty>,,,,1,,ANY
326431,BLOCK,1,,<empty>,,,,1,,ANY
326436,BLOCK,1,,<empty>,,,,1,,ANY
326442,BLOCK,1,,<empty>,,,,1,,ANY
326446,BLOCK,1,,<empty>,,,,1,,ANY
326452,BLOCK,1,,<empty>,,,,1,,ANY
326458,BLOCK,1,,<empty>,,,,1,,ANY
326462,BLOCK,1,,<empty>,,,,1,,ANY
326466,BLOCK,1,,<empty>,,,,1,,ANY
326470,BLOCK,1,,<empty>,,,,1,,ANY
326477,BLOCK,1,,<empty>,,,,1,,ANY
326481,BLOCK,1,,<empty>,,,,1,,ANY
326488,BLOCK,1,,<empty>,,,,1,,ANY
326494,BLOCK,1,,<empty>,,,,1,,ANY
326500,BLOCK,1,,<empty>,,,,1,,ANY
326506,BLOCK,1,,<empty>,,,,1,,ANY
326512,BLOCK,1,,<empty>,,,,1,,ANY
326518,BLOCK,1,,<empty>,,,,1,,ANY
326524,BLOCK,1,,<empty>,,,,1,,ANY
326530,BLOCK,1,,<empty>,,,,1,,ANY
326536,BLOCK,1,,<empty>,,,,1,,ANY
326543,BLOCK,1,,<empty>,,,,1,,ANY
326547,BLOCK,1,,<empty>,,,,1,,ANY
326553,BLOCK,1,,<empty>,,,,1,,ANY
326559,BLOCK,1,,<empty>,,,,1,,ANY
326567,BLOCK,1,,<empty>,,,,1,,ANY
326574,BLOCK,1,,<empty>,,,,1,,ANY
326579,BLOCK,1,,<empty>,,,,1,,ANY
326584,BLOCK,1,,<empty>,,,,1,,ANY
326590,BLOCK,1,,<empty>,,,,1,,ANY
326596,BLOCK,1,,<empty>,,,,1,,ANY
326602,BLOCK,1,,<empty>,,,,1,,ANY
326609,BLOCK,1,,<empty>,,,,1,,ANY
326615,BLOCK,1,,<empty>,,,,1,,ANY
326621,BLOCK,1,,<empty>,,,,1,,ANY
326627,BLOCK,1,,<empty>,,,,1,,ANY
326635,BLOCK,1,,<empty>,,,,1,,ANY
326643,BLOCK,1,,<empty>,,,,1,,ANY
326652,BLOCK,1,,<empty>,,,,1,,ANY
326658,BLOCK,1,,<empty>,,,,1,,ANY
326664,BLOCK,1,,<empty>,,,,1,,ANY
326671,BLOCK,1,,<empty>,,,,1,,ANY
326679,BLOCK,1,,<empty>,,,,1,,ANY
326688,BLOCK,1,,<empty>,,,,1,,ANY
326696,BLOCK,1,,<empty>,,,,1,,ANY
326705,BLOCK,1,,<empty>,,,,1,,ANY
326711,BLOCK,1,,<empty>,,,,1,,ANY
326719,BLOCK,1,,<empty>,,,,1,,ANY
326725,BLOCK,1,,<empty>,,,,1,,ANY
326730,BLOCK,1,,<empty>,,,,1,,ANY
326736,BLOCK,1,,<empty>,,,,1,,ANY
326744,BLOCK,1,,<empty>,,,,1,,ANY
326751,BLOCK,1,,<empty>,,,,1,,ANY
326760,BLOCK,1,,<empty>,,,,1,,ANY
326771,BLOCK,1,,<empty>,,,,1,,ANY
326782,BLOCK,1,,<empty>,,,,1,,ANY
326795,BLOCK,1,,<empty>,,,,1,,ANY
326805,BLOCK,1,,<empty>,,,,1,,ANY
326812,BLOCK,1,,<empty>,,,,1,,ANY
326822,BLOCK,1,,<empty>,,,,1,,ANY
326831,BLOCK,1,,<empty>,,,,1,,ANY
326838,BLOCK,1,,<empty>,,,,1,,ANY
326844,BLOCK,1,,<empty>,,,,1,,ANY
326852,BLOCK,1,,<empty>,,,,1,,ANY
326858,BLOCK,1,,<empty>,,,,1,,ANY
326863,BLOCK,1,,<empty>,,,,1,,ANY
326868,BLOCK,1,,<empty>,,,,1,,ANY
326874,BLOCK,1,,<empty>,,,,1,,ANY
326878,BLOCK,1,,<empty>,,,,1,,ANY
326885,BLOCK,1,,<empty>,,,,1,,ANY
326889,BLOCK,1,,<empty>,,,,1,,ANY
326899,BLOCK,1,,<empty>,,,,1,,ANY
326905,BLOCK,1,,<empty>,,,,1,,ANY
326909,BLOCK,1,,<empty>,,,,1,,ANY
326918,BLOCK,1,,<empty>,,,,1,,ANY
326924,BLOCK,1,,<empty>,,,,1,,ANY
326928,BLOCK,1,,<empty>,,,,1,,ANY
326932,BLOCK,1,,<empty>,,,,1,,ANY
326936,BLOCK,1,,<empty>,,,,1,,ANY
326944,BLOCK,1,,<empty>,,,,1,,ANY
326952,BLOCK,1,,<empty>,,,,1,,ANY
326960,BLOCK,1,,<empty>,,,,1,,ANY
326968,BLOCK,1,,<empty>,,,,1,,ANY
326976,BLOCK,1,,<empty>,,,,1,,ANY
326984,BLOCK,1,,<empty>,,,,1,,ANY
326992,BLOCK,1,,<empty>,,,,1,,ANY
327000,BLOCK,1,,<empty>,,,,1,,ANY
327008,BLOCK,1,,<empty>,,,,1,,ANY
327016,BLOCK,1,,<empty>,,,,1,,ANY
327024,BLOCK,1,,<empty>,,,,1,,ANY
327032,BLOCK,1,,<empty>,,,,1,,ANY
327040,BLOCK,1,,<empty>,,,,1,,ANY
327048,BLOCK,1,,<empty>,,,,1,,ANY
327056,BLOCK,1,,<empty>,,,,1,,ANY
327064,BLOCK,1,,<empty>,,,,1,,ANY
327072,BLOCK,1,,<empty>,,,,1,,ANY
327080,BLOCK,1,,<empty>,,,,1,,ANY
327088,BLOCK,1,,<empty>,,,,1,,ANY
327096,BLOCK,1,,<empty>,,,,1,,ANY
327104,BLOCK,1,,<empty>,,,,1,,ANY
327112,BLOCK,1,,<empty>,,,,1,,ANY
327120,BLOCK,1,,<empty>,,,,1,,ANY
327128,BLOCK,1,,<empty>,,,,1,,ANY
327136,BLOCK,1,,<empty>,,,,1,,ANY
327144,BLOCK,1,,<empty>,,,,1,,ANY
327152,BLOCK,1,,<empty>,,,,1,,ANY
327160,BLOCK,1,,<empty>,,,,1,,ANY
327168,BLOCK,1,,<empty>,,,,1,,ANY
327176,BLOCK,1,,<empty>,,,,1,,ANY
327184,BLOCK,1,,<empty>,,,,1,,ANY
327192,BLOCK,1,,<empty>,,,,1,,ANY
327200,BLOCK,1,,<empty>,,,,1,,ANY
327208,BLOCK,1,,<empty>,,,,1,,ANY
327216,BLOCK,1,,<empty>,,,,1,,ANY
327224,BLOCK,1,,<empty>,,,,1,,ANY
327232,BLOCK,1,,<empty>,,,,1,,ANY
327240,BLOCK,1,,<empty>,,,,1,,ANY
327248,BLOCK,1,,<empty>,,,,1,,ANY
327256,BLOCK,1,,<empty>,,,,1,,ANY
327264,BLOCK,1,,<empty>,,,,1,,ANY
327272,BLOCK,1,,<empty>,,,,1,,ANY
327280,BLOCK,1,,<empty>,,,,1,,ANY
327288,BLOCK,1,,<empty>,,,,1,,ANY
327296,BLOCK,1,,<empty>,,,,1,,ANY
327304,BLOCK,1,,<empty>,,,,1,,ANY
327311,BLOCK,1,,<empty>,,,,1,,ANY
327315,BLOCK,1,,<empty>,,,,1,,ANY
327320,BLOCK,1,,<empty>,,,,1,,ANY
327325,BLOCK,1,,<empty>,,,,1,,ANY
327331,BLOCK,1,,<empty>,,,,1,,ANY
327337,BLOCK,1,,<empty>,,,,1,,ANY
327343,BLOCK,1,,<empty>,,,,1,,ANY
327349,BLOCK,1,,<empty>,,,,1,,ANY
327353,BLOCK,1,,<empty>,,,,1,,ANY
327358,BLOCK,1,,<empty>,,,,1,,ANY
327363,BLOCK,1,,<empty>,,,,1,,ANY
327367,BLOCK,1,,<empty>,,,,1,,ANY
327371,BLOCK,1,,<empty>,,,,1,,ANY
327376,BLOCK,1,,<empty>,,,,1,,ANY
327383,BLOCK,1,,<empty>,,,,1,,ANY
327386,BLOCK,1,,<empty>,,,,1,,ANY
327390,BLOCK,1,,<empty>,,,,1,,ANY
327394,BLOCK,1,,<empty>,,,,1,,ANY
327398,BLOCK,1,,<empty>,,,,1,,ANY
327402,BLOCK,1,,<empty>,,,,1,,ANY
327407,BLOCK,1,,<empty>,,,,1,,ANY
327413,BLOCK,1,,<empty>,,,,1,,ANY
327418,BLOCK,1,,<empty>,,,,1,,ANY
327422,BLOCK,1,,<empty>,,,,1,,ANY
327428,BLOCK,1,,<empty>,,,,1,,ANY
327432,BLOCK,1,,<empty>,,,,1,,ANY
327436,BLOCK,1,,<empty>,,,,1,,ANY
327440,BLOCK,1,,<empty>,,,,1,,ANY
327445,BLOCK,1,,<empty>,,,,1,,ANY
327450,BLOCK,1,,<empty>,,,,1,,ANY
327455,BLOCK,1,,<empty>,,,,1,,ANY
327460,BLOCK,1,,<empty>,,,,1,,ANY
327464,BLOCK,1,,<empty>,,,,1,,ANY
327469,BLOCK,1,,<empty>,,,,1,,ANY
327475,BLOCK,1,,<empty>,,,,1,,ANY
327480,BLOCK,1,,<empty>,,,,1,,ANY
327485,BLOCK,1,,<empty>,,,,1,,ANY
327490,BLOCK,1,,<empty>,,,,1,,ANY
327494,BLOCK,1,,<empty>,,,,1,,ANY
327498,BLOCK,1,,<empty>,,,,1,,ANY
327502,BLOCK,1,,<empty>,,,,1,,ANY
327505,BLOCK,1,,<empty>,,,,1,,ANY
327510,BLOCK,1,,<empty>,,,,1,,ANY
327514,BLOCK,1,,<empty>,,,,1,,ANY
327519,BLOCK,1,,<empty>,,,,1,,ANY
327523,BLOCK,1,,<empty>,,,,1,,ANY
327527,BLOCK,1,,<empty>,,,,1,,ANY
327531,BLOCK,1,,<empty>,,,,1,,ANY
327537,BLOCK,1,,<empty>,,,,1,,ANY
327541,BLOCK,1,,<empty>,,,,1,,ANY
327545,BLOCK,1,,<empty>,,,,1,,ANY
327550,BLOCK,1,,<empty>,,,,1,,ANY
327555,BLOCK,1,,<empty>,,,,1,,ANY
327559,BLOCK,1,,<empty>,,,,1,,ANY
327566,BLOCK,1,,<empty>,,,,1,,ANY
327571,BLOCK,1,,<empty>,,,,1,,ANY
327576,BLOCK,1,,<empty>,,,,1,,ANY
327581,BLOCK,1,,<empty>,,,,1,,ANY
327588,BLOCK,1,,<empty>,,,,1,,ANY
327593,BLOCK,1,,<empty>,,,,1,,ANY
327597,BLOCK,1,,<empty>,,,,1,,ANY
327601,BLOCK,1,,<empty>,,,,1,,ANY
327606,BLOCK,1,,<empty>,,,,1,,ANY
327614,BLOCK,1,,<empty>,,,,1,,ANY
327622,BLOCK,1,,<empty>,,,,1,,ANY
327630,BLOCK,1,,<empty>,,,,1,,ANY
327638,BLOCK,1,,<empty>,,,,1,,ANY
327646,BLOCK,1,,<empty>,,,,1,,ANY
327649,BLOCK,1,,<empty>,,,,1,,ANY
327653,BLOCK,1,,<empty>,,,,1,,ANY
327662,BLOCK,1,,<empty>,,,,1,,ANY
327670,BLOCK,1,,<empty>,,,,1,,ANY
327675,BLOCK,1,,<empty>,,,,1,,ANY
327679,BLOCK,1,,<empty>,,,,1,,ANY
327683,BLOCK,1,,<empty>,,,,1,,ANY
327687,BLOCK,1,,<empty>,,,,1,,ANY
327690,BLOCK,1,,<empty>,,,,1,,ANY
327693,BLOCK,1,,<empty>,,,,1,,ANY
327699,BLOCK,1,,<empty>,,,,1,,ANY
327703,BLOCK,1,,<empty>,,,,1,,ANY
327707,BLOCK,1,,<empty>,,,,1,,ANY
327712,BLOCK,1,,<empty>,,,,1,,ANY
327717,BLOCK,1,,<empty>,,,,1,,ANY
327721,BLOCK,1,,<empty>,,,,1,,ANY
327727,BLOCK,1,,<empty>,,,,1,,ANY
327732,BLOCK,1,,<empty>,,,,1,,ANY
327737,BLOCK,1,,<empty>,,,,1,,ANY
327741,BLOCK,1,,<empty>,,,,1,,ANY
327747,BLOCK,1,,<empty>,,,,1,,ANY
327753,BLOCK,1,,<empty>,,,,1,,ANY
327758,BLOCK,1,,<empty>,,,,1,,ANY
327763,BLOCK,1,,<empty>,,,,1,,ANY
327766,BLOCK,1,,<empty>,,,,1,,ANY
327770,BLOCK,1,,<empty>,,,,1,,ANY
327776,BLOCK,1,,<empty>,,,,1,,ANY
327783,BLOCK,1,,<empty>,,,,1,,ANY
327789,BLOCK,1,,<empty>,,,,1,,ANY
327793,BLOCK,1,,<empty>,,,,1,,ANY
327797,BLOCK,1,,<empty>,,,,1,,ANY
327801,BLOCK,1,,<empty>,,,,1,,ANY
327804,BLOCK,1,,<empty>,,,,1,,ANY
327809,BLOCK,1,,<empty>,,,,1,,ANY
327815,BLOCK,1,,<empty>,,,,1,,ANY
327818,BLOCK,1,,<empty>,,,,1,,ANY
327822,BLOCK,1,,<empty>,,,,1,,ANY
327826,BLOCK,1,,<empty>,,,,1,,ANY
327830,BLOCK,1,,<empty>,,,,1,,ANY
327834,BLOCK,1,,<empty>,,,,1,,ANY
327838,BLOCK,1,,<empty>,,,,1,,ANY
327842,BLOCK,1,,<empty>,,,,1,,ANY
327845,BLOCK,1,,<empty>,,,,1,,ANY
327848,BLOCK,1,,<empty>,,,,1,,ANY
327851,BLOCK,1,,<empty>,,,,1,,ANY
327854,BLOCK,1,,<empty>,,,,1,,ANY
327857,BLOCK,1,,<empty>,,,,1,,ANY
327860,BLOCK,1,,<empty>,,,,1,,ANY
327863,BLOCK,1,,<empty>,,,,1,,ANY
327872,BLOCK,1,,<empty>,,,,1,,ANY
327877,BLOCK,1,,<empty>,,,,1,,ANY
327883,BLOCK,1,,<empty>,,,,1,,ANY
327889,BLOCK,1,,<empty>,,,,1,,ANY
327899,BLOCK,1,,<empty>,,,,1,,ANY
327905,BLOCK,1,,<empty>,,,,1,,ANY
327911,BLOCK,1,,<empty>,,,,1,,ANY
327917,BLOCK,1,,<empty>,,,,1,,ANY
327926,BLOCK,1,,<empty>,,,,1,,ANY
327930,BLOCK,1,,<empty>,,,,1,,ANY
327934,BLOCK,1,,<empty>,,,,1,,ANY
327940,BLOCK,1,,<empty>,,,,1,,ANY
327946,BLOCK,1,,<empty>,,,,1,,ANY
327952,BLOCK,1,,<empty>,,,,1,,ANY
327957,BLOCK,1,,<empty>,,,,1,,ANY
327962,BLOCK,1,,<empty>,,,,1,,ANY
327967,BLOCK,1,,<empty>,,,,1,,ANY
327975,BLOCK,1,,<empty>,,,,1,,ANY
327983,BLOCK,1,,<empty>,,,,1,,ANY
327991,BLOCK,1,,<empty>,,,,1,,ANY
327999,BLOCK,1,,<empty>,,,,1,,ANY
328007,BLOCK,1,,<empty>,,,,1,,ANY
328015,BLOCK,1,,<empty>,,,,1,,ANY
328023,BLOCK,1,,<empty>,,,,1,,ANY
328031,BLOCK,1,,<empty>,,,,1,,ANY
328039,BLOCK,1,,<empty>,,,,1,,ANY
328047,BLOCK,1,,<empty>,,,,1,,ANY
328055,BLOCK,1,,<empty>,,,,1,,ANY
328063,BLOCK,1,,<empty>,,,,1,,ANY
328071,BLOCK,1,,<empty>,,,,1,,ANY
328079,BLOCK,1,,<empty>,,,,1,,ANY
328087,BLOCK,1,,<empty>,,,,1,,ANY
328095,BLOCK,1,,<empty>,,,,1,,ANY
328103,BLOCK,1,,<empty>,,,,1,,ANY
328111,BLOCK,1,,<empty>,,,,1,,ANY
328119,BLOCK,1,,<empty>,,,,1,,ANY
328127,BLOCK,1,,<empty>,,,,1,,ANY
328135,BLOCK,1,,<empty>,,,,1,,ANY
328143,BLOCK,1,,<empty>,,,,1,,ANY
328151,BLOCK,1,,<empty>,,,,1,,ANY
328159,BLOCK,1,,<empty>,,,,1,,ANY
328167,BLOCK,1,,<empty>,,,,1,,ANY
328175,BLOCK,1,,<empty>,,,,1,,ANY
328183,BLOCK,1,,<empty>,,,,1,,ANY
328191,BLOCK,1,,<empty>,,,,1,,ANY
328199,BLOCK,1,,<empty>,,,,1,,ANY
328207,BLOCK,1,,<empty>,,,,1,,ANY
328215,BLOCK,1,,<empty>,,,,1,,ANY
328223,BLOCK,1,,<empty>,,,,1,,ANY
328231,BLOCK,1,,<empty>,,,,1,,ANY
328239,BLOCK,1,,<empty>,,,,1,,ANY
328247,BLOCK,1,,<empty>,,,,1,,ANY
328255,BLOCK,1,,<empty>,,,,1,,ANY
328263,BLOCK,1,,<empty>,,,,1,,ANY
328271,BLOCK,1,,<empty>,,,,1,,ANY
328279,BLOCK,1,,<empty>,,,,1,,ANY
328287,BLOCK,1,,<empty>,,,,1,,ANY
328295,BLOCK,1,,<empty>,,,,1,,ANY
328303,BLOCK,1,,<empty>,,,,1,,ANY
328311,BLOCK,1,,<empty>,,,,1,,ANY
328319,BLOCK,1,,<empty>,,,,1,,ANY
328327,BLOCK,1,,<empty>,,,,1,,ANY
328335,BLOCK,1,,<empty>,,,,1,,ANY
328343,BLOCK,1,,<empty>,,,,1,,ANY
328351,BLOCK,1,,<empty>,,,,1,,ANY
328359,BLOCK,1,,<empty>,,,,1,,ANY
328367,BLOCK,1,,<empty>,,,,1,,ANY
328375,BLOCK,1,,<empty>,,,,1,,ANY
328383,BLOCK,1,,<empty>,,,,1,,ANY
328391,BLOCK,1,,<empty>,,,,1,,ANY
328399,BLOCK,1,,<empty>,,,,1,,ANY
328407,BLOCK,1,,<empty>,,,,1,,ANY
328415,BLOCK,1,,<empty>,,,,1,,ANY
328423,BLOCK,1,,<empty>,,,,1,,ANY
328431,BLOCK,1,,<empty>,,,,1,,ANY
328439,BLOCK,1,,<empty>,,,,1,,ANY
328447,BLOCK,1,,<empty>,,,,1,,ANY
328455,BLOCK,1,,<empty>,,,,1,,ANY
328463,BLOCK,1,,<empty>,,,,1,,ANY
328471,BLOCK,1,,<empty>,,,,1,,ANY
328479,BLOCK,1,,<empty>,,,,1,,ANY
328487,BLOCK,1,,<empty>,,,,1,,ANY
328495,BLOCK,1,,<empty>,,,,1,,ANY
328503,BLOCK,1,,<empty>,,,,1,,ANY
328511,BLOCK,1,,<empty>,,,,1,,ANY
328519,BLOCK,1,,<empty>,,,,1,,ANY
328527,BLOCK,1,,<empty>,,,,1,,ANY
328535,BLOCK,1,,<empty>,,,,1,,ANY
328543,BLOCK,1,,<empty>,,,,1,,ANY
328551,BLOCK,1,,<empty>,,,,1,,ANY
328559,BLOCK,1,,<empty>,,,,1,,ANY
328567,BLOCK,1,,<empty>,,,,1,,ANY
328575,BLOCK,1,,<empty>,,,,1,,ANY
328583,BLOCK,1,,<empty>,,,,1,,ANY
328591,BLOCK,1,,<empty>,,,,1,,ANY
328599,BLOCK,1,,<empty>,,,,1,,ANY
328607,BLOCK,1,,<empty>,,,,1,,ANY
328615,BLOCK,1,,<empty>,,,,1,,ANY
328623,BLOCK,1,,<empty>,,,,1,,ANY
328631,BLOCK,1,,<empty>,,,,1,,ANY
328639,BLOCK,1,,<empty>,,,,1,,ANY
328647,BLOCK,1,,<empty>,,,,1,,ANY
328655,BLOCK,1,,<empty>,,,,1,,ANY
328663,BLOCK,1,,<empty>,,,,1,,ANY
328671,BLOCK,1,,<empty>,,,,1,,ANY
328679,BLOCK,1,,<empty>,,,,1,,ANY
328687,BLOCK,1,,<empty>,,,,1,,ANY
328695,BLOCK,1,,<empty>,,,,1,,ANY
328703,BLOCK,1,,<empty>,,,,1,,ANY
328711,BLOCK,1,,<empty>,,,,1,,ANY
328719,BLOCK,1,,<empty>,,,,1,,ANY
328727,BLOCK,1,,<empty>,,,,1,,ANY
328735,BLOCK,1,,<empty>,,,,1,,ANY
328743,BLOCK,1,,<empty>,,,,1,,ANY
328751,BLOCK,1,,<empty>,,,,1,,ANY
328759,BLOCK,1,,<empty>,,,,1,,ANY
328767,BLOCK,1,,<empty>,,,,1,,ANY
328775,BLOCK,1,,<empty>,,,,1,,ANY
328783,BLOCK,1,,<empty>,,,,1,,ANY
328791,BLOCK,1,,<empty>,,,,1,,ANY
328799,BLOCK,1,,<empty>,,,,1,,ANY
328807,BLOCK,1,,<empty>,,,,1,,ANY
328815,BLOCK,1,,<empty>,,,,1,,ANY
328823,BLOCK,1,,<empty>,,,,1,,ANY
328827,BLOCK,1,,<empty>,,,,1,,ANY
328833,BLOCK,1,,<empty>,,,,1,,ANY
328838,BLOCK,1,,<empty>,,,,1,,ANY
328842,BLOCK,1,,<empty>,,,,1,,ANY
328847,BLOCK,1,,<empty>,,,,1,,ANY
328851,BLOCK,1,,<empty>,,,,1,,ANY
328857,BLOCK,1,,<empty>,,,,1,,ANY
328862,BLOCK,1,,<empty>,,,,1,,ANY
328866,BLOCK,1,,<empty>,,,,1,,ANY
328871,BLOCK,1,,<empty>,,,,1,,ANY
328876,BLOCK,1,,<empty>,,,,1,,ANY
328881,BLOCK,1,,<empty>,,,,1,,ANY
328886,BLOCK,1,,<empty>,,,,1,,ANY
328890,BLOCK,1,,<empty>,,,,1,,ANY
328894,BLOCK,1,,<empty>,,,,1,,ANY
328898,BLOCK,1,,<empty>,,,,1,,ANY
328902,BLOCK,1,,<empty>,,,,1,,ANY
328906,BLOCK,1,,<empty>,,,,1,,ANY
328910,BLOCK,1,,<empty>,,,,1,,ANY
328914,BLOCK,1,,<empty>,,,,1,,ANY
328918,BLOCK,1,,<empty>,,,,1,,ANY
328923,BLOCK,1,,<empty>,,,,1,,ANY
328928,BLOCK,1,,<empty>,,,,1,,ANY
328936,BLOCK,1,,<empty>,,,,1,,ANY
328944,BLOCK,1,,<empty>,,,,1,,ANY
328952,BLOCK,1,,<empty>,,,,1,,ANY
328960,BLOCK,1,,<empty>,,,,1,,ANY
328968,BLOCK,1,,<empty>,,,,1,,ANY
328974,BLOCK,1,,<empty>,,,,1,,ANY
328979,BLOCK,1,,<empty>,,,,1,,ANY
328984,BLOCK,1,,<empty>,,,,1,,ANY
328989,BLOCK,1,,<empty>,,,,1,,ANY
328993,BLOCK,1,,<empty>,,,,1,,ANY
328999,BLOCK,1,,<empty>,,,,1,,ANY
329003,BLOCK,1,,<empty>,,,,1,,ANY
329007,BLOCK,1,,<empty>,,,,1,,ANY
329011,BLOCK,1,,<empty>,,,,1,,ANY
329016,BLOCK,1,,<empty>,,,,1,,ANY
329020,BLOCK,1,,<empty>,,,,1,,ANY
329024,BLOCK,1,,<empty>,,,,1,,ANY
329028,BLOCK,1,,<empty>,,,,1,,ANY
329032,BLOCK,1,,<empty>,,,,1,,ANY
329037,BLOCK,1,,<empty>,,,,1,,ANY
329041,BLOCK,1,,<empty>,,,,1,,ANY
329046,BLOCK,1,,<empty>,,,,1,,ANY
329050,BLOCK,1,,<empty>,,,,1,,ANY
329055,BLOCK,1,,<empty>,,,,1,,ANY
329059,BLOCK,1,,<empty>,,,,1,,ANY
329064,BLOCK,1,,<empty>,,,,1,,ANY
329068,BLOCK,1,,<empty>,,,,1,,ANY
329072,BLOCK,1,,<empty>,,,,1,,ANY
329076,BLOCK,1,,<empty>,,,,1,,ANY
329080,BLOCK,1,,<empty>,,,,1,,ANY
329086,BLOCK,1,,<empty>,,,,1,,ANY
329090,BLOCK,1,,<empty>,,,,1,,ANY
329095,BLOCK,1,,<empty>,,,,1,,ANY
329100,BLOCK,1,,<empty>,,,,1,,ANY
329104,BLOCK,1,,<empty>,,,,1,,ANY
329109,BLOCK,1,,<empty>,,,,1,,ANY
329113,BLOCK,1,,<empty>,,,,1,,ANY
329119,BLOCK,1,,<empty>,,,,1,,ANY
329123,BLOCK,1,,<empty>,,,,1,,ANY
329127,BLOCK,1,,<empty>,,,,1,,ANY
329131,BLOCK,1,,<empty>,,,,1,,ANY
329135,BLOCK,1,,<empty>,,,,1,,ANY
329138,BLOCK,1,,<empty>,,,,1,,ANY
329141,BLOCK,1,,<empty>,,,,1,,ANY
329145,BLOCK,1,,<empty>,,,,1,,ANY
329151,BLOCK,1,,<empty>,,,,1,,ANY
329154,BLOCK,1,,<empty>,,,,1,,ANY
329157,BLOCK,1,,<empty>,,,,1,,ANY
329161,BLOCK,1,,<empty>,,,,1,,ANY
329166,BLOCK,1,,<empty>,,,,1,,ANY
329171,BLOCK,1,,<empty>,,,,1,,ANY
329175,BLOCK,1,,<empty>,,,,1,,ANY
329180,BLOCK,1,,<empty>,,,,1,,ANY
329184,BLOCK,1,,<empty>,,,,1,,ANY
329189,BLOCK,1,,<empty>,,,,1,,ANY
329194,BLOCK,1,,<empty>,,,,1,,ANY
329198,BLOCK,1,,<empty>,,,,1,,ANY
329201,BLOCK,1,,<empty>,,,,1,,ANY
329204,BLOCK,1,,<empty>,,,,1,,ANY
329208,BLOCK,1,,<empty>,,,,1,,ANY
329211,BLOCK,1,,<empty>,,,,1,,ANY
329214,BLOCK,1,,<empty>,,,,1,,ANY
329218,BLOCK,1,,<empty>,,,,1,,ANY
329221,BLOCK,1,,<empty>,,,,1,,ANY
329224,BLOCK,1,,<empty>,,,,1,,ANY
329228,BLOCK,1,,<empty>,,,,1,,ANY
329232,BLOCK,1,,<empty>,,,,1,,ANY
329236,BLOCK,1,,<empty>,,,,1,,ANY
329239,BLOCK,1,,<empty>,,,,1,,ANY
329243,BLOCK,1,,<empty>,,,,1,,ANY
329248,BLOCK,1,,<empty>,,,,1,,ANY
329253,BLOCK,1,,<empty>,,,,1,,ANY
329258,BLOCK,1,,<empty>,,,,1,,ANY
329262,BLOCK,1,,<empty>,,,,1,,ANY
329266,BLOCK,1,,<empty>,,,,1,,ANY
329270,BLOCK,1,,<empty>,,,,1,,ANY
329275,BLOCK,1,,<empty>,,,,1,,ANY
329279,BLOCK,1,,<empty>,,,,1,,ANY
329283,BLOCK,1,,<empty>,,,,1,,ANY
329287,BLOCK,1,,<empty>,,,,1,,ANY
329291,BLOCK,1,,<empty>,,,,1,,ANY
329298,BLOCK,1,,<empty>,,,,1,,ANY
329302,BLOCK,1,,<empty>,,,,1,,ANY
329307,BLOCK,1,,<empty>,,,,1,,ANY
329311,BLOCK,1,,<empty>,,,,1,,ANY
329315,BLOCK,1,,<empty>,,,,1,,ANY
329320,BLOCK,1,,<empty>,,,,1,,ANY
329326,BLOCK,1,,<empty>,,,,1,,ANY
329330,BLOCK,1,,<empty>,,,,1,,ANY
329334,BLOCK,1,,<empty>,,,,1,,ANY
329338,BLOCK,1,,<empty>,,,,1,,ANY
329343,BLOCK,1,,<empty>,,,,1,,ANY
329347,BLOCK,1,,<empty>,,,,1,,ANY
329352,BLOCK,1,,<empty>,,,,1,,ANY
329356,BLOCK,1,,<empty>,,,,1,,ANY
329360,BLOCK,1,,<empty>,,,,1,,ANY
329364,BLOCK,1,,<empty>,,,,1,,ANY
329368,BLOCK,1,,<empty>,,,,1,,ANY
329375,BLOCK,1,,<empty>,,,,1,,ANY
329379,BLOCK,1,,<empty>,,,,1,,ANY
329383,BLOCK,1,,<empty>,,,,1,,ANY
329387,BLOCK,1,,<empty>,,,,1,,ANY
329392,BLOCK,1,,<empty>,,,,1,,ANY
329397,BLOCK,1,,<empty>,,,,1,,ANY
329402,BLOCK,1,,<empty>,,,,1,,ANY
329411,BLOCK,1,,<empty>,,,,1,,ANY
329415,BLOCK,1,,<empty>,,,,1,,ANY
329419,BLOCK,1,,<empty>,,,,1,,ANY
329423,BLOCK,1,,<empty>,,,,1,,ANY
329428,BLOCK,1,,<empty>,,,,1,,ANY
329431,BLOCK,1,,<empty>,,,,1,,ANY
329436,BLOCK,1,,<empty>,,,,1,,ANY
329442,BLOCK,1,,<empty>,,,,1,,ANY
329448,BLOCK,1,,<empty>,,,,1,,ANY
329454,BLOCK,1,,<empty>,,,,1,,ANY
329458,BLOCK,1,,<empty>,,,,1,,ANY
329462,BLOCK,1,,<empty>,,,,1,,ANY
329466,BLOCK,1,,<empty>,,,,1,,ANY
329470,BLOCK,1,,<empty>,,,,1,,ANY
329474,BLOCK,1,,<empty>,,,,1,,ANY
329478,BLOCK,1,,<empty>,,,,1,,ANY
329482,BLOCK,1,,<empty>,,,,1,,ANY
329486,BLOCK,1,,<empty>,,,,1,,ANY
329490,BLOCK,1,,<empty>,,,,1,,ANY
329494,BLOCK,1,,<empty>,,,,1,,ANY
329500,BLOCK,1,,<empty>,,,,1,,ANY
329505,BLOCK,1,,<empty>,,,,1,,ANY
329509,BLOCK,1,,<empty>,,,,1,,ANY
329512,BLOCK,1,,<empty>,,,,1,,ANY
329519,BLOCK,1,,<empty>,,,,1,,ANY
329525,BLOCK,1,,<empty>,,,,1,,ANY
329531,BLOCK,1,,<empty>,,,,1,,ANY
329536,BLOCK,1,,<empty>,,,,1,,ANY
329541,BLOCK,1,,<empty>,,,,1,,ANY
329549,BLOCK,1,,<empty>,,,,1,,ANY
329557,BLOCK,1,,<empty>,,,,1,,ANY
329565,BLOCK,1,,<empty>,,,,1,,ANY
329573,BLOCK,1,,<empty>,,,,1,,ANY
329577,BLOCK,1,,<empty>,,,,1,,ANY
329582,BLOCK,1,,<empty>,,,,1,,ANY
329587,BLOCK,1,,<empty>,,,,1,,ANY
329590,BLOCK,1,,<empty>,,,,1,,ANY
329594,BLOCK,1,,<empty>,,,,1,,ANY
329598,BLOCK,1,,<empty>,,,,1,,ANY
329602,BLOCK,1,,<empty>,,,,1,,ANY
329606,BLOCK,1,,<empty>,,,,1,,ANY
329611,BLOCK,1,,<empty>,,,,1,,ANY
329616,BLOCK,1,,<empty>,,,,1,,ANY
329622,BLOCK,1,,<empty>,,,,1,,ANY
329627,BLOCK,1,,<empty>,,,,1,,ANY
329631,BLOCK,1,,<empty>,,,,1,,ANY
329634,BLOCK,1,,<empty>,,,,1,,ANY
329641,BLOCK,1,,<empty>,,,,1,,ANY
329646,BLOCK,1,,<empty>,,,,1,,ANY
329654,BLOCK,1,,<empty>,,,,1,,ANY
329659,BLOCK,1,,<empty>,,,,1,,ANY
329664,BLOCK,1,,<empty>,,,,1,,ANY
329670,BLOCK,1,,<empty>,,,,1,,ANY
329676,BLOCK,1,,<empty>,,,,1,,ANY
329680,BLOCK,1,,<empty>,,,,1,,ANY
329688,BLOCK,1,,<empty>,,,,1,,ANY
329695,BLOCK,1,,<empty>,,,,1,,ANY
329702,BLOCK,1,,<empty>,,,,1,,ANY
329705,BLOCK,1,,<empty>,,,,1,,ANY
329709,BLOCK,1,,<empty>,,,,1,,ANY
329714,BLOCK,1,,<empty>,,,,1,,ANY
329720,BLOCK,1,,<empty>,,,,1,,ANY
329725,BLOCK,1,,<empty>,,,,1,,ANY
329732,BLOCK,1,,<empty>,,,,1,,ANY
329736,BLOCK,1,,<empty>,,,,1,,ANY
329741,BLOCK,1,,<empty>,,,,1,,ANY
329747,BLOCK,1,,<empty>,,,,1,,ANY
329752,BLOCK,1,,<empty>,,,,1,,ANY
329758,BLOCK,1,,<empty>,,,,1,,ANY
329766,BLOCK,1,,<empty>,,,,1,,ANY
329774,BLOCK,1,,<empty>,,,,1,,ANY
329779,BLOCK,1,,<empty>,,,,1,,ANY
329787,BLOCK,1,,<empty>,,,,1,,ANY
329795,BLOCK,1,,<empty>,,,,1,,ANY
329803,BLOCK,1,,<empty>,,,,1,,ANY
329806,BLOCK,1,,<empty>,,,,1,,ANY
329809,BLOCK,1,,<empty>,,,,1,,ANY
329812,BLOCK,1,,<empty>,,,,1,,ANY
329815,BLOCK,1,,<empty>,,,,1,,ANY
329822,BLOCK,1,,<empty>,,,,1,,ANY
329827,BLOCK,1,,<empty>,,,,1,,ANY
329831,BLOCK,1,,<empty>,,,,1,,ANY
329838,BLOCK,1,,<empty>,,,,1,,ANY
329843,BLOCK,1,,<empty>,,,,1,,ANY
329846,BLOCK,1,,<empty>,,,,1,,ANY
329852,BLOCK,1,,<empty>,,,,1,,ANY
329858,BLOCK,1,,<empty>,,,,1,,ANY
329864,BLOCK,1,,<empty>,,,,1,,ANY
329870,BLOCK,1,,<empty>,,,,1,,ANY
329876,BLOCK,1,,<empty>,,,,1,,ANY
329882,BLOCK,1,,<empty>,,,,1,,ANY
329887,BLOCK,1,,<empty>,,,,1,,ANY
329894,BLOCK,1,,<empty>,,,,1,,ANY
329901,BLOCK,1,,<empty>,,,,1,,ANY
329908,BLOCK,1,,<empty>,,,,1,,ANY
329915,BLOCK,1,,<empty>,,,,1,,ANY
329922,BLOCK,1,,<empty>,,,,1,,ANY
329929,BLOCK,1,,<empty>,,,,1,,ANY
329936,BLOCK,1,,<empty>,,,,1,,ANY
329943,BLOCK,1,,<empty>,,,,1,,ANY
329947,BLOCK,1,,<empty>,,,,1,,ANY
329952,BLOCK,1,,<empty>,,,,1,,ANY
329960,BLOCK,1,,<empty>,,,,1,,ANY
329965,BLOCK,1,,<empty>,,,,1,,ANY
329971,BLOCK,1,,<empty>,,,,1,,ANY
329976,BLOCK,1,,<empty>,,,,1,,ANY
329981,BLOCK,1,,<empty>,,,,1,,ANY
329986,BLOCK,1,,<empty>,,,,1,,ANY
329991,BLOCK,1,,<empty>,,,,1,,ANY
329995,BLOCK,1,,<empty>,,,,1,,ANY
330001,BLOCK,1,,<empty>,,,,1,,ANY
330006,BLOCK,1,,<empty>,,,,1,,ANY
330011,BLOCK,1,,<empty>,,,,1,,ANY
330015,BLOCK,1,,<empty>,,,,1,,ANY
330020,BLOCK,1,,<empty>,,,,1,,ANY
330025,BLOCK,1,,<empty>,,,,1,,ANY
330030,BLOCK,1,,<empty>,,,,1,,ANY
330035,BLOCK,1,,<empty>,,,,1,,ANY
330043,BLOCK,1,,<empty>,,,,1,,ANY
330047,BLOCK,1,,<empty>,,,,1,,ANY
330051,BLOCK,1,,<empty>,,,,1,,ANY
330055,BLOCK,1,,<empty>,,,,1,,ANY
330060,BLOCK,1,,<empty>,,,,1,,ANY
330065,BLOCK,1,,<empty>,,,,1,,ANY
330068,BLOCK,1,,<empty>,,,,1,,ANY
330071,BLOCK,1,,<empty>,,,,1,,ANY
330077,BLOCK,1,,<empty>,,,,1,,ANY
330082,BLOCK,1,,<empty>,,,,1,,ANY
330086,BLOCK,1,,<empty>,,,,1,,ANY
330091,BLOCK,1,,<empty>,,,,1,,ANY
330096,BLOCK,1,,<empty>,,,,1,,ANY
330100,BLOCK,1,,<empty>,,,,1,,ANY
330103,BLOCK,1,,<empty>,,,,1,,ANY
330106,BLOCK,1,,<empty>,,,,1,,ANY
330109,BLOCK,1,,<empty>,,,,1,,ANY
330112,BLOCK,1,,<empty>,,,,1,,ANY
330117,BLOCK,1,,<empty>,,,,1,,ANY
330120,BLOCK,1,,<empty>,,,,1,,ANY
330124,BLOCK,1,,<empty>,,,,1,,ANY
330140,BLOCK,1,,<empty>,,,,1,,ANY
330146,BLOCK,1,,<empty>,,,,1,,ANY
330150,BLOCK,1,,<empty>,,,,1,,ANY
330158,BLOCK,1,,<empty>,,,,1,,ANY
330163,BLOCK,1,,<empty>,,,,1,,ANY
330166,BLOCK,1,,<empty>,,,,1,,ANY
330169,BLOCK,1,,<empty>,,,,1,,ANY
330174,BLOCK,1,,<empty>,,,,1,,ANY
330178,BLOCK,1,,<empty>,,,,1,,ANY
330182,BLOCK,1,,<empty>,,,,1,,ANY
330186,BLOCK,1,,<empty>,,,,1,,ANY
330190,BLOCK,1,,<empty>,,,,1,,ANY
330193,BLOCK,1,,<empty>,,,,1,,ANY
330200,BLOCK,1,,<empty>,,,,1,,ANY
330204,BLOCK,1,,<empty>,,,,1,,ANY
330210,BLOCK,1,,<empty>,,,,1,,ANY
330213,BLOCK,1,,<empty>,,,,1,,ANY
330217,BLOCK,1,,<empty>,,,,1,,ANY
330221,BLOCK,1,,<empty>,,,,1,,ANY
330226,BLOCK,1,,<empty>,,,,1,,ANY
330230,BLOCK,1,,<empty>,,,,1,,ANY
330234,BLOCK,1,,<empty>,,,,1,,ANY
330238,BLOCK,1,,<empty>,,,,1,,ANY
330242,BLOCK,1,,<empty>,,,,1,,ANY
330247,BLOCK,1,,<empty>,,,,1,,ANY
330250,BLOCK,1,,<empty>,,,,1,,ANY
330253,BLOCK,1,,<empty>,,,,1,,ANY
330259,BLOCK,1,,<empty>,,,,1,,ANY
330262,BLOCK,1,,<empty>,,,,1,,ANY
330277,BLOCK,1,,<empty>,,,,1,,ANY
330280,BLOCK,1,,<empty>,,,,1,,ANY
330287,BLOCK,1,,<empty>,,,,1,,ANY
330290,BLOCK,1,,<empty>,,,,1,,ANY
330295,BLOCK,1,,<empty>,,,,1,,ANY
330299,BLOCK,1,,<empty>,,,,1,,ANY
330303,BLOCK,1,,<empty>,,,,1,,ANY
330307,BLOCK,1,,<empty>,,,,1,,ANY
330310,BLOCK,1,,<empty>,,,,1,,ANY
330315,BLOCK,1,,<empty>,,,,1,,ANY
330320,BLOCK,1,,<empty>,,,,1,,ANY
330325,BLOCK,1,,<empty>,,,,1,,ANY
330332,BLOCK,1,,<empty>,,,,1,,ANY
330337,BLOCK,1,,<empty>,,,,1,,ANY
330341,BLOCK,1,,<empty>,,,,1,,ANY
330345,BLOCK,1,,<empty>,,,,1,,ANY
330350,BLOCK,1,,<empty>,,,,1,,ANY
330355,BLOCK,1,,<empty>,,,,1,,ANY
330363,BLOCK,1,,<empty>,,,,1,,ANY
330371,BLOCK,1,,<empty>,,,,1,,ANY
330377,BLOCK,1,,<empty>,,,,1,,ANY
330382,BLOCK,1,,<empty>,,,,1,,ANY
330387,BLOCK,1,,<empty>,,,,1,,ANY
330392,BLOCK,1,,<empty>,,,,1,,ANY
330397,BLOCK,1,,<empty>,,,,1,,ANY
330402,BLOCK,1,,<empty>,,,,1,,ANY
330407,BLOCK,1,,<empty>,,,,1,,ANY
330414,BLOCK,1,,<empty>,,,,1,,ANY
330419,BLOCK,1,,<empty>,,,,1,,ANY
330424,BLOCK,1,,<empty>,,,,1,,ANY
330429,BLOCK,1,,<empty>,,,,1,,ANY
330437,BLOCK,1,,<empty>,,,,1,,ANY
330442,BLOCK,1,,<empty>,,,,1,,ANY
330449,BLOCK,1,,<empty>,,,,1,,ANY
330453,BLOCK,1,,<empty>,,,,1,,ANY
330458,BLOCK,1,,<empty>,,,,1,,ANY
330463,BLOCK,1,,<empty>,,,,1,,ANY
330468,BLOCK,1,,<empty>,,,,1,,ANY
330473,BLOCK,1,,<empty>,,,,1,,ANY
330477,BLOCK,1,,<empty>,,,,1,,ANY
330483,BLOCK,1,,<empty>,,,,1,,ANY
330487,BLOCK,1,,<empty>,,,,1,,ANY
330491,BLOCK,1,,<empty>,,,,1,,ANY
330495,BLOCK,1,,<empty>,,,,1,,ANY
330499,BLOCK,1,,<empty>,,,,1,,ANY
330503,BLOCK,1,,<empty>,,,,1,,ANY
330509,BLOCK,1,,<empty>,,,,1,,ANY
330512,BLOCK,1,,<empty>,,,,1,,ANY
330516,BLOCK,1,,<empty>,,,,1,,ANY
330521,BLOCK,1,,<empty>,,,,1,,ANY
330525,BLOCK,1,,<empty>,,,,1,,ANY
330529,BLOCK,1,,<empty>,,,,1,,ANY
330536,BLOCK,1,,<empty>,,,,1,,ANY
330540,BLOCK,1,,<empty>,,,,1,,ANY
330546,BLOCK,1,,<empty>,,,,1,,ANY
330550,BLOCK,1,,<empty>,,,,1,,ANY
330557,BLOCK,1,,<empty>,,,,1,,ANY
330562,BLOCK,1,,<empty>,,,,1,,ANY
330567,BLOCK,1,,<empty>,,,,1,,ANY
330571,BLOCK,1,,<empty>,,,,1,,ANY
330576,BLOCK,1,,<empty>,,,,1,,ANY
330581,BLOCK,1,,<empty>,,,,1,,ANY
330585,BLOCK,1,,<empty>,,,,1,,ANY
330589,BLOCK,1,,<empty>,,,,1,,ANY
330592,BLOCK,1,,<empty>,,,,1,,ANY
330596,BLOCK,1,,<empty>,,,,1,,ANY
330600,BLOCK,1,,<empty>,,,,1,,ANY
