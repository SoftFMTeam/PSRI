5,METHOD,acorn_version.hpp:<global>,TYPE_DECL,<global>,1,31,acorn_version.hpp,acorn_version.hpp:<global>,,false,1,6,<global>,,,1,
14,METHOD,aliased_buffer-inl.hpp:<global>,TYPE_DECL,<global>,1,36,aliased_buffer-inl.hpp,aliased_buffer-inl.hpp:<global>,,false,1,243,<global>,,,1,
25,METHOD,aliased_buffer.hpp:<global>,TYPE_DECL,<global>,1,32,aliased_buffer.hpp,aliased_buffer.hpp:<global>,,false,1,206,<global>,,,1,
36,METHOD,aliased_struct-inl.hpp:<global>,TYPE_DECL,<global>,1,36,aliased_struct-inl.hpp,aliased_struct-inl.hpp:<global>,,false,1,54,<global>,,,1,
47,METHOD,aliased_struct.hpp:<global>,TYPE_DECL,<global>,1,32,aliased_struct.hpp,aliased_struct.hpp:<global>,,false,1,63,<global>,,,1,
56,METHOD,api\async_resource.cc:<global>,TYPE_DECL,<global>,1,59,node.hpp,api\async_resource.cc:<global>,,false,1,70,<global>,,,1,
59,METHOD,api\async_resource.cc:<global>,TYPE_DECL,"AsyncResource::AsyncResource(Isolate* isolate,
                             Local<Object> resource,
                             const char* name,
                             async_id trigger_async_id)
    : env_(Environment::GetCurrent(isolate)),
      resource_(isolate, resource) {
  CHECK_NOT_NULL(env_);
  async_context_ = EmitAsyncInit(isolate, resource, name,
                                 trigger_async_id);
}",1,1,api\async_resource.cc,node.AsyncResource.AsyncResource,,false,14,23,AsyncResource,,,1,"ANY node.AsyncResource.AsyncResource (Isolate*,Local<Object>,char*,async_id)"
76,METHOD,api\async_resource.cc:<global>,TYPE_DECL,"AsyncResource::~AsyncResource() {
  EmitAsyncDestroy(env_, async_context_);
}",1,1,api\async_resource.cc,node.AsyncResource.~AsyncResource,,false,25,27,~AsyncResource,,,2,ANY node.AsyncResource.~AsyncResource ()
83,METHOD,api\async_resource.cc:<global>,TYPE_DECL,"MaybeLocal<Value> AsyncResource::MakeCallback(Local<Function> callback,
                                              int argc,
                                              Local<Value>* argv) {
  return node::MakeCallback(env_->isolate(), get_resource(),
                            callback, argc, argv,
                            async_context_);
}",1,1,api\async_resource.cc,node.AsyncResource.MakeCallback,,false,29,35,MakeCallback,,,3,"MaybeLocal<Value> node.AsyncResource.MakeCallback (Local<Function>,int,Local<Value>*)"
104,METHOD,api\async_resource.cc:<global>,TYPE_DECL,"MaybeLocal<Value> AsyncResource::MakeCallback(const char* method,
                                              int argc,
                                              Local<Value>* argv) {
  return node::MakeCallback(env_->isolate(), get_resource(),
                            method, argc, argv,
                            async_context_);
}",1,1,api\async_resource.cc,node.AsyncResource.MakeCallback,,false,37,43,MakeCallback,,,4,"MaybeLocal<Value> node.AsyncResource.MakeCallback (char*,int,Local<Value>*)"
125,METHOD,api\async_resource.cc:<global>,TYPE_DECL,"MaybeLocal<Value> AsyncResource::MakeCallback(Local<String> symbol,
                                              int argc,
                                              Local<Value>* argv) {
  return node::MakeCallback(env_->isolate(), get_resource(),
                            symbol, argc, argv,
                            async_context_);
}",1,1,api\async_resource.cc,node.AsyncResource.MakeCallback,,false,45,51,MakeCallback,,,5,"MaybeLocal<Value> node.AsyncResource.MakeCallback (Local<String>,int,Local<Value>*)"
146,METHOD,api\async_resource.cc:<global>,TYPE_DECL,"Local<Object> AsyncResource::get_resource() {
  return resource_.Get(env_->isolate());
}",1,1,api\async_resource.cc,node.AsyncResource.get_resource,,false,53,55,get_resource,,,6,Local<Object> node.AsyncResource.get_resource ()
159,METHOD,api\async_resource.cc:<global>,TYPE_DECL,"async_id AsyncResource::get_async_id() const {
  return async_context_.async_id;
}",1,1,api\async_resource.cc,node.AsyncResource.get_async_id,,false,57,59,get_async_id,,,7,async_id node.AsyncResource.get_async_id ()
167,METHOD,api\async_resource.cc:<global>,TYPE_DECL,"async_id AsyncResource::get_trigger_async_id() const {
  return async_context_.trigger_async_id;
}",1,1,api\async_resource.cc,node.AsyncResource.get_trigger_async_id,,false,61,63,get_trigger_async_id,,,8,async_id node.AsyncResource.get_trigger_async_id ()
175,METHOD,api\async_resource.cc:<global>,TYPE_DECL,"AsyncResource::CallbackScope::CallbackScope(AsyncResource* res)
    : node::CallbackScope(res->env_,
                          res->resource_.Get(res->env_->isolate()),
                          res->async_context_) {}",1,49,api\async_resource.cc,node.AsyncResource.CallbackScope.CallbackScope,,false,65,68,CallbackScope,,,9,ANY node.AsyncResource.CallbackScope.CallbackScope (AsyncResource*)
181,METHOD,api\callback.cc:<global>,TYPE_DECL,"[&]() {
    if (env_->is_stopping()) {
      MarkAsFailed();
      env_->async_hooks()->clear_async_id_stack();
    }
  }",33,3,api\callback.cc,node.InternalCallbackScope.Close.<lambda>0,,false,103,108,<lambda>0,,,1,ANY node.InternalCallbackScope.Close.<lambda>0 ()
201,METHOD,api\callback.cc:<global>,TYPE_DECL,[&]() { isolate->SetIdle(true); },28,60,api\callback.cc,node.InternalCallbackScope.Close.<lambda>1,,false,114,114,<lambda>1,,,1,ANY node.InternalCallbackScope.Close.<lambda>1 ()
212,METHOD,api\callback.cc:<global>,TYPE_DECL,[&]() { env_->RunWeakRefCleanup(); },39,74,api\callback.cc,node.InternalCallbackScope.Close.<lambda>2,,false,133,133,<lambda>2,,,1,ANY node.InternalCallbackScope.Close.<lambda>2 ()
230,METHOD,api\callback.cc:<global>,TYPE_DECL,<global>,1,59,node.hpp,api\callback.cc:<global>,,false,1,360,<global>,,,1,
233,METHOD,api\callback.cc:<global>,TYPE_DECL,"CallbackScope::CallbackScope(Isolate* isolate,
                             Local<Object> object,
                             async_context async_context)
  : CallbackScope(Environment::GetCurrent(isolate), object, async_context) {}",1,77,api\callback.cc,node.CallbackScope.CallbackScope,,false,19,22,CallbackScope,,,1,"ANY node.CallbackScope.CallbackScope (Isolate*,Local<Object>,async_context)"
240,METHOD,api\callback.cc:<global>,TYPE_DECL,"CallbackScope::CallbackScope(Environment* env,
                             Local<Object> object,
                             async_context asyncContext)
  : private_(new InternalCallbackScope(env,
                                       object,
                                       asyncContext)),
    try_catch_(env->isolate()) {
  try_catch_.SetVerbose(true);
}",1,1,api\callback.cc,node.CallbackScope.CallbackScope,,false,24,32,CallbackScope,,,2,"ANY node.CallbackScope.CallbackScope (Environment*,Local<Object>,async_context)"
252,METHOD,api\callback.cc:<global>,TYPE_DECL,"CallbackScope::~CallbackScope() {
  if (try_catch_.HasCaught())
    private_->MarkAsFailed();
  delete private_;
}",1,1,api\callback.cc,node.CallbackScope.~CallbackScope,,false,34,38,~CallbackScope,,,3,ANY node.CallbackScope.~CallbackScope ()
268,METHOD,api\callback.cc:<global>,TYPE_DECL,"InternalCallbackScope::InternalCallbackScope(AsyncWrap* async_wrap, int flags)
    : InternalCallbackScope(async_wrap->env(),
                            async_wrap->object(),
                            { async_wrap->get_async_id(),
                              async_wrap->get_trigger_async_id() },
                            flags) {}",1,37,api\callback.cc,node.InternalCallbackScope.InternalCallbackScope,,false,40,45,InternalCallbackScope,,,4,"ANY node.InternalCallbackScope.InternalCallbackScope (AsyncWrap*,int)"
274,METHOD,api\callback.cc:<global>,TYPE_DECL,"InternalCallbackScope::InternalCallbackScope(Environment* env,
                                             Local<Object> object,
                                             const async_context& asyncContext,
                                             int flags)
  : env_(env),
    async_context_(asyncContext),
    object_(object),
    skip_hooks_(flags & kSkipAsyncHooks),
    skip_task_queues_(flags & kSkipTaskQueues) {
  CHECK_NOT_NULL(env);
  env->PushAsyncCallbackScope();

  if (!env->can_call_into_js()) {
    failed_ = true;
    return;
  }

  Isolate* isolate = env->isolate();

  HandleScope handle_scope(isolate);
  Local<Context> current_context = isolate->GetCurrentContext();
  // If you hit this assertion, the caller forgot to enter the right Node.js
  // Environment's v8::Context first.
  // We first check `env->context() != current_context` because the contexts
  // likely *are* the same, in which case we can skip the slightly more
  // expensive Environment::GetCurrent...",1,1,api\callback.cc,node.InternalCallbackScope.InternalCallbackScope,,false,47,89,InternalCallbackScope,,,5,"ANY node.InternalCallbackScope.InternalCallbackScope (Environment*,Local<Object>,async_context,int)"
375,METHOD,api\callback.cc:<global>,TYPE_DECL,"InternalCallbackScope::~InternalCallbackScope() {
  Close();
  env_->PopAsyncCallbackScope();
}",1,1,api\callback.cc,node.InternalCallbackScope.~InternalCallbackScope,,false,91,94,~InternalCallbackScope,,,6,ANY node.InternalCallbackScope.~InternalCallbackScope ()
384,METHOD,api\callback.cc:<global>,TYPE_DECL,"void InternalCallbackScope::Close() {
  if (closed_) return;
  closed_ = true;

  // This function must ends up with either cleanup the
  // async id stack or pop the topmost one from it

  auto perform_stopping_check = [&]() {
    if (env_->is_stopping()) {
      MarkAsFailed();
      env_->async_hooks()->clear_async_id_stack();
    }
  };
  perform_stopping_check();

  if (env_->is_stopping()) return;

  Isolate* isolate = env_->isolate();
  auto idle = OnScopeLeave([&]() { isolate->SetIdle(true); });

  if (!failed_ && async_context_.async_id != 0 && !skip_hooks_) {
    AsyncWrap::EmitAfter(env_, async_context_.async_id);
  }

  if (pushed_ids_)
    env_->async_hooks()->pop_async_context(async_context_.async_id);

  if (failed_) return;

  if (env_->async_callback_scope_depth() > 1 || skip_task_queues_) {
    return;
  }

  TickInfo* tick_info = env_->tick_info();

  if (!env_->can_call_into_js()) return;

  auto weakref_cleanup = OnScopeLeave([&]() { env_->RunWeakRefCleanup(); }...",1,1,api\callback.cc,node.InternalCallbackScope.Close,,false,96,168,Close,,,7,void node.InternalCallbackScope.Close ()
606,METHOD,api\callback.cc:<global>,TYPE_DECL,"MaybeLocal<Value> InternalMakeCallback(Environment* env,
                                       Local<Object> resource,
                                       Local<Object> recv,
                                       const Local<Function> callback,
                                       int argc,
                                       Local<Value> argv[],
                                       async_context asyncContext) {
  CHECK(!recv.IsEmpty());
#ifdef DEBUG
  for (int i = 0; i < argc; i++)
    CHECK(!argv[i].IsEmpty());
#endif

  Local<Function> hook_cb = env->async_hooks_callback_trampoline();
  int flags = InternalCallbackScope::kNoFlags;
  bool use_async_hooks_trampoline = false;
  AsyncHooks* async_hooks = env->async_hooks();
  if (!hook_cb.IsEmpty()) {
    // Use the callback trampoline if there are any before or after hooks, or
    // we can expect some kind of usage of async_hooks.executionAsyncResource().
    flags = InternalCallbackScope::kSkipAsyncHooks;
    use_async...",1,1,api\callback.cc,node.InternalMakeCallback,,false,170,229,InternalMakeCallback,,,8,"MaybeLocal<Value> node.InternalMakeCallback (Environment*,Local<Object>,Local<Object>,Local<Function>,int,Local<Value>[],async_context)"
831,METHOD,api\callback.cc:<global>,TYPE_DECL,"MaybeLocal<Value> MakeCallback(Isolate* isolate,
                               Local<Object> recv,
                               const char* method,
                               int argc,
                               Local<Value> argv[],
                               async_context asyncContext) {
  Local<String> method_string =
      String::NewFromUtf8(isolate, method).ToLocalChecked();
  return MakeCallback(isolate, recv, method_string, argc, argv, asyncContext);
}",1,1,api\callback.cc,node.MakeCallback,,false,233,242,MakeCallback,,,9,"MaybeLocal<Value> node.MakeCallback (Isolate*,Local<Object>,char*,int,Local<Value>[],async_context)"
864,METHOD,api\callback.cc:<global>,TYPE_DECL,"MaybeLocal<Value> MakeCallback(Isolate* isolate,
                               Local<Object> recv,
                               Local<String> symbol,
                               int argc,
                               Local<Value> argv[],
                               async_context asyncContext) {
  // Check can_call_into_js() first because calling Get() might do so.
  Environment* env =
      Environment::GetCurrent(recv->GetCreationContext().ToLocalChecked());
  CHECK_NOT_NULL(env);
  if (!env->can_call_into_js()) return Local<Value>();

  Local<Value> callback_v;
  if (!recv->Get(isolate->GetCurrentContext(), symbol).ToLocal(&callback_v))
    return Local<Value>();
  if (!callback_v->IsFunction()) {
    // This used to return an empty value, but Undefined() makes more sense
    // since no exception is pending here.
    return Undefined(isolate);
  }
  Local<Function> callback = callback_v.As<Function>();
  return MakeCallback(isolate, recv, callback, argc, argv, asyncCon...",1,1,api\callback.cc,node.MakeCallback,,false,244,266,MakeCallback,,,10,"MaybeLocal<Value> node.MakeCallback (Isolate*,Local<Object>,Local<String>,int,Local<Value>[],async_context)"
951,METHOD,api\callback.cc:<global>,TYPE_DECL,"MaybeLocal<Value> MakeCallback(Isolate* isolate,
                               Local<Object> recv,
                               Local<Function> callback,
                               int argc,
                               Local<Value> argv[],
                               async_context asyncContext) {
  // Observe the following two subtleties:
  //
  // 1. The environment is retrieved from the callback function's context.
  // 2. The context to enter is retrieved from the environment.
  //
  // Because of the AssignToContext() call in src/node_contextify.cc,
  // the two contexts need not be the same.
  Environment* env =
      Environment::GetCurrent(callback->GetCreationContext().ToLocalChecked());
  CHECK_NOT_NULL(env);
  Context::Scope context_scope(env->context());
  MaybeLocal<Value> ret =
      InternalMakeCallback(env, recv, recv, callback, argc, argv, asyncContext);
  if (ret.IsEmpty() && env->async_callback_scope_depth() == 0) {
    // This is only for legacy compa...",1,1,api\callback.cc,node.MakeCallback,,false,268,293,MakeCallback,,,11,"MaybeLocal<Value> node.MakeCallback (Isolate*,Local<Object>,Local<Function>,int,Local<Value>[],async_context)"
1015,METHOD,api\callback.cc:<global>,TYPE_DECL,"MaybeLocal<Value> MakeSyncCallback(Isolate* isolate,
                                   Local<Object> recv,
                                   Local<Function> callback,
                                   int argc,
                                   Local<Value> argv[]) {
  Environment* env =
      Environment::GetCurrent(callback->GetCreationContext().ToLocalChecked());
  CHECK_NOT_NULL(env);
  if (!env->can_call_into_js()) return Local<Value>();

  Local<Context> context = env->context();
  Context::Scope context_scope(context);
  if (env->async_callback_scope_depth()) {
    // There's another MakeCallback() on the stack, piggy back on it.
    // In particular, retain the current async_context.
    return callback->Call(context, recv, argc, argv);
  }

  // This is a toplevel invocation and the caller (intentionally)
  // didn't provide any async_context to run in. Install a default context.
  MaybeLocal<Value> ret =
    InternalMakeCallback(env, env->process_object(), recv, callba...",1,1,api\callback.cc,node.MakeSyncCallback,,false,299,323,MakeSyncCallback,,,12,"MaybeLocal<Value> node.MakeSyncCallback (Isolate*,Local<Object>,Local<Function>,int,Local<Value>[])"
1099,METHOD,api\callback.cc:<global>,TYPE_DECL,"Local<Value> MakeCallback(Isolate* isolate,
                          Local<Object> recv,
                          const char* method,
                          int argc,
                          Local<Value>* argv) {
  EscapableHandleScope handle_scope(isolate);
  return handle_scope.Escape(
      MakeCallback(isolate, recv, method, argc, argv, {0, 0})
          .FromMaybe(Local<Value>()));
}",1,1,api\callback.cc,node.MakeCallback,,false,327,336,MakeCallback,,,13,"Local<Value> node.MakeCallback (Isolate*,Local<Object>,char*,int,Local<Value>*)"
1129,METHOD,api\callback.cc:<global>,TYPE_DECL,"Local<Value> MakeCallback(Isolate* isolate,
                          Local<Object> recv,
                          Local<String> symbol,
                          int argc,
                          Local<Value>* argv) {
  EscapableHandleScope handle_scope(isolate);
  return handle_scope.Escape(
      MakeCallback(isolate, recv, symbol, argc, argv, {0, 0})
          .FromMaybe(Local<Value>()));
}",1,1,api\callback.cc,node.MakeCallback,,false,338,347,MakeCallback,,,14,"Local<Value> node.MakeCallback (Isolate*,Local<Object>,Local<String>,int,Local<Value>*)"
1159,METHOD,api\callback.cc:<global>,TYPE_DECL,"Local<Value> MakeCallback(Isolate* isolate,
                          Local<Object> recv,
                          Local<Function> callback,
                          int argc,
                          Local<Value>* argv) {
  EscapableHandleScope handle_scope(isolate);
  return handle_scope.Escape(
      MakeCallback(isolate, recv, callback, argc, argv, {0, 0})
          .FromMaybe(Local<Value>()));
}",1,1,api\callback.cc,node.MakeCallback,,false,349,358,MakeCallback,,,15,"Local<Value> node.MakeCallback (Isolate*,Local<Object>,Local<Function>,int,Local<Value>*)"
1190,METHOD,api\embed_helpers.cc:<global>,TYPE_DECL,[](Realm* realm) { realm->VerifyNoStrongBaseObjects(); },21,76,api\embed_helpers.cc,node.SpinEventLoopInternal.<lambda>0,,false,75,75,<lambda>0,,,1,ANY node.SpinEventLoopInternal.<lambda>0 (Realm*)
1201,METHOD,api\embed_helpers.cc:<global>,TYPE_DECL,"[&]() {
      if (bootstrapCatch.HasCaught()) {
        errors->push_back(FormatCaughtException(
            isolate, isolate->GetCurrentContext(), bootstrapCatch));
      }
    }",41,5,api\embed_helpers.cc,node.CommonEnvironmentSetup.CommonEnvironmentSetup.<lambda>1,,false,136,141,<lambda>1,,,1,ANY node.CommonEnvironmentSetup.CommonEnvironmentSetup.<lambda>1 ()
1225,METHOD,api\embed_helpers.cc:<global>,TYPE_DECL,"[&](const CommonEnvironmentSetup* setup) -> Environment* {
        return CreateEnvironment(
            setup->isolate_data(),
            setup->context(),
            args,
            exec_args,
            static_cast<EnvironmentFlags::Flags>(env_flags));
      }",7,7,api\embed_helpers.cc,"new CommonEnvironmentSetup( platform, errors, nullptr, true, [&](const CommonEnvironmentSetup* setup) -> Environment* { return CreateEnvironment( setup->isolate_data(), setup->context(), args, exec_args, static_cast<EnvironmentFlags.Flags>(env_flags)); }).<lambda>2",,false,192,199,<lambda>2,,,1,"Environment new CommonEnvironmentSetup( platform, errors, nullptr, true, [&](const CommonEnvironmentSetup* setup) -> Environment* { return CreateEnvironment( setup->isolate_data(), setup->context(), args, exec_args, static_cast<EnvironmentFlags.Flags>(env_flags)); }).<lambda>2 (CommonEnvironmentSetup*)"
1249,METHOD,api\embed_helpers.cc:<global>,TYPE_DECL,"[](void* data) {
      *static_cast<bool*>(data) = true;
    }",58,5,api\embed_helpers.cc,node.CommonEnvironmentSetup.~CommonEnvironmentSetup.<lambda>3,,false,217,219,<lambda>3,,,1,ANY node.CommonEnvironmentSetup.~CommonEnvironmentSetup.<lambda>3 (void*)
1270,METHOD,api\embed_helpers.cc:<global>,TYPE_DECL,<global>,1,33,debug_utils-inl.hpp,api\embed_helpers.cc:<global>,,false,1,340,<global>,,,1,
1273,METHOD,api\embed_helpers.cc:<global>,TYPE_DECL,"Maybe<ExitCode> SpinEventLoopInternal(Environment* env) {
  CHECK_NOT_NULL(env);
  MultiIsolatePlatform* platform = GetMultiIsolatePlatform(env);
  CHECK_NOT_NULL(platform);

  Isolate* isolate = env->isolate();
  HandleScope handle_scope(isolate);
  Context::Scope context_scope(env->context());
  SealHandleScope seal(isolate);

  if (env->is_stopping()) return Nothing<ExitCode>();

  env->set_trace_sync_io(env->options()->trace_sync_io);
  {
    bool more;
    env->performance_state()->Mark(
        node::performance::NODE_PERFORMANCE_MILESTONE_LOOP_START);
    do {
      if (env->is_stopping()) break;
      uv_run(env->event_loop(), UV_RUN_DEFAULT);
      if (env->is_stopping()) break;

      platform->DrainTasks(isolate);

      more = uv_loop_alive(env->event_loop());
      if (more && !env->is_stopping()) continue;

      if (EmitProcessBeforeExit(env).IsNothing())
        break;

      {
        HandleScope handle_scope(isolate);
        if (env->RunSnapshotSerializeCallback()...",1,1,api\embed_helpers.cc,node.SpinEventLoopInternal,,false,22,77,SpinEventLoopInternal,,,1,Maybe<ExitCode> node.SpinEventLoopInternal (Environment*)
1471,METHOD,<empty>,<empty>,<empty>,1,,api\embed_helpers.cc,node.Impl:<clinit>,,false,79,,<clinit>,,,9,
1481,METHOD,api\embed_helpers.cc:<global>,TYPE_DECL,"CommonEnvironmentSetup::CommonEnvironmentSetup(
    MultiIsolatePlatform* platform,
    std::vector<std::string>* errors,
    const EmbedderSnapshotData* snapshot_data,
    uint32_t flags,
    std::function<Environment*(const CommonEnvironmentSetup*)> make_env)
    : impl_(new Impl()) {
  CHECK_NOT_NULL(platform);
  CHECK_NOT_NULL(errors);

  impl_->platform = platform;
  uv_loop_t* loop = &impl_->loop;
  // Use `data` to tell the destructor whether the loop was initialized or not.
  loop->data = nullptr;
  int ret = uv_loop_init(loop);
  if (ret != 0) {
    errors->push_back(
        SPrintF(""Failed to initialize loop: %s"", uv_err_name(ret)));
    return;
  }
  loop->data = this;

  Isolate* isolate;
  if (flags & Flags::kIsForSnapshotting) {
    const std::vector<intptr_t>& external_references =
        SnapshotBuilder::CollectExternalReferences();
    isolate = impl_->isolate = Isolate::Allocate();
    // Must be done before the SnapshotCreator creation so  that the
    // memory...",1,1,api\embed_helpers.cc,node.CommonEnvironmentSetup.CommonEnvironmentSetup,,false,90,166,CommonEnvironmentSetup,,,3,"ANY node.CommonEnvironmentSetup.CommonEnvironmentSetup (MultiIsolatePlatform*,ANY*,EmbedderSnapshotData*,uint32_t,ANY)"
1735,METHOD,api\embed_helpers.cc:<global>,TYPE_DECL,"CommonEnvironmentSetup::CommonEnvironmentSetup(
    MultiIsolatePlatform* platform,
    std::vector<std::string>* errors,
    std::function<Environment*(const CommonEnvironmentSetup*)> make_env)
    : CommonEnvironmentSetup(platform, errors, nullptr, false, make_env) {}",1,75,api\embed_helpers.cc,node.CommonEnvironmentSetup.CommonEnvironmentSetup,,false,168,172,CommonEnvironmentSetup,,,4,"ANY node.CommonEnvironmentSetup.CommonEnvironmentSetup (MultiIsolatePlatform*,ANY*,ANY)"
1742,METHOD,api\embed_helpers.cc:<global>,TYPE_DECL,"std::unique_ptr<CommonEnvironmentSetup>
CommonEnvironmentSetup::CreateForSnapshotting(
    MultiIsolatePlatform* platform,
    std::vector<std::string>* errors,
    const std::vector<std::string>& args,
    const std::vector<std::string>& exec_args) {
  // It's not guaranteed that a context that goes through
  // v8_inspector::V8Inspector::contextCreated() is runtime-independent,
  // so do not start the inspector on the main context when building
  // the default snapshot.
  uint64_t env_flags =
      EnvironmentFlags::kDefaultFlags | EnvironmentFlags::kNoCreateInspector;

  auto ret = std::unique_ptr<CommonEnvironmentSetup>(new CommonEnvironmentSetup(
      platform,
      errors,
      nullptr,
      true,
      [&](const CommonEnvironmentSetup* setup) -> Environment* {
        return CreateEnvironment(
            setup->isolate_data(),
            setup->context(),
            args,
            exec_args,
            static_cast<EnvironmentFlags::Flags>(env_flags));
      }));
...",1,1,api\embed_helpers.cc,node.CommonEnvironmentSetup.CreateForSnapshotting,,false,174,202,CreateForSnapshotting,,,5,"unique_ptr<CommonEnvironmentSetup> node.CommonEnvironmentSetup.CreateForSnapshotting (MultiIsolatePlatform*,ANY*,ANY,ANY)"
1786,METHOD,api\embed_helpers.cc:<global>,TYPE_DECL,"CommonEnvironmentSetup::~CommonEnvironmentSetup() {
  if (impl_->isolate != nullptr) {
    Isolate* isolate = impl_->isolate;
    {
      Locker locker(isolate);
      Isolate::Scope isolate_scope(isolate);

      impl_->main_context.Reset();
      impl_->env.reset();
      impl_->isolate_data.reset();
    }

    bool platform_finished = false;
    impl_->platform->AddIsolateFinishedCallback(isolate, [](void* data) {
      *static_cast<bool*>(data) = true;
    }, &platform_finished);
    impl_->platform->UnregisterIsolate(isolate);
    if (impl_->snapshot_creator.has_value())
      impl_->snapshot_creator.reset();
    else
      isolate->Dispose();

    // Wait until the platform has cleaned up all relevant resources.
    while (!platform_finished)
      uv_run(&impl_->loop, UV_RUN_ONCE);
  }

  if (impl_->isolate || impl_->loop.data != nullptr)
    CheckedUvLoopClose(&impl_->loop);

  delete impl_;
}",1,1,api\embed_helpers.cc,node.CommonEnvironmentSetup.~CommonEnvironmentSetup,,false,204,235,~CommonEnvironmentSetup,,,6,ANY node.CommonEnvironmentSetup.~CommonEnvironmentSetup ()
1898,METHOD,api\embed_helpers.cc:<global>,TYPE_DECL,"EmbedderSnapshotData::Pointer CommonEnvironmentSetup::CreateSnapshot() {
  CHECK_NOT_NULL(snapshot_creator());
  SnapshotData* snapshot_data = new SnapshotData();
  EmbedderSnapshotData::Pointer result{
      new EmbedderSnapshotData(snapshot_data, true)};

  auto exit_code = SnapshotBuilder::CreateSnapshot(
      snapshot_data,
      this,
      static_cast<uint8_t>(SnapshotMetadata::Type::kFullyCustomized));
  if (exit_code != ExitCode::kNoFailure) return {};

  return result;
}",1,1,api\embed_helpers.cc,node.CommonEnvironmentSetup.CreateSnapshot,,false,237,250,CreateSnapshot,,,7,Pointer node.CommonEnvironmentSetup.CreateSnapshot ()
1943,METHOD,api\embed_helpers.cc:<global>,TYPE_DECL,"Maybe<int> SpinEventLoop(Environment* env) {
  Maybe<ExitCode> result = SpinEventLoopInternal(env);
  if (result.IsNothing()) {
    return Nothing<int>();
  }
  return Just(static_cast<int>(result.FromJust()));
}",1,1,api\embed_helpers.cc,node.SpinEventLoop,,false,252,258,SpinEventLoop,,,8,Maybe<int> node.SpinEventLoop (Environment*)
1972,METHOD,api\embed_helpers.cc:<global>,TYPE_DECL,"uv_loop_t* CommonEnvironmentSetup::event_loop() const {
  return &impl_->loop;
}",1,1,api\embed_helpers.cc,node.CommonEnvironmentSetup.event_loop,,false,260,262,event_loop,,,9,uv_loop_t node.CommonEnvironmentSetup.event_loop ()
1981,METHOD,api\embed_helpers.cc:<global>,TYPE_DECL,"std::shared_ptr<ArrayBufferAllocator>
CommonEnvironmentSetup::array_buffer_allocator() const {
  return impl_->allocator;
}",1,1,api\embed_helpers.cc,node.CommonEnvironmentSetup.array_buffer_allocator,,false,264,267,array_buffer_allocator,,,10,shared_ptr<ArrayBufferAllocator> node.CommonEnvironmentSetup.array_buffer_allocator ()
1989,METHOD,api\embed_helpers.cc:<global>,TYPE_DECL,"Isolate* CommonEnvironmentSetup::isolate() const {
  return impl_->isolate;
}",1,1,api\embed_helpers.cc,node.CommonEnvironmentSetup.isolate,,false,269,271,isolate,,,11,Isolate node.CommonEnvironmentSetup.isolate ()
1997,METHOD,api\embed_helpers.cc:<global>,TYPE_DECL,"IsolateData* CommonEnvironmentSetup::isolate_data() const {
  return impl_->isolate_data.get();
}",1,1,api\embed_helpers.cc,node.CommonEnvironmentSetup.isolate_data,,false,273,275,isolate_data,,,12,IsolateData node.CommonEnvironmentSetup.isolate_data ()
2008,METHOD,api\embed_helpers.cc:<global>,TYPE_DECL,"Environment* CommonEnvironmentSetup::env() const {
  return impl_->env.get();
}",1,1,api\embed_helpers.cc,node.CommonEnvironmentSetup.env,,false,277,279,env,,,13,Environment node.CommonEnvironmentSetup.env ()
2019,METHOD,api\embed_helpers.cc:<global>,TYPE_DECL,"v8::Local<v8::Context> CommonEnvironmentSetup::context() const {
  return impl_->main_context.Get(impl_->isolate);
}",1,1,api\embed_helpers.cc,node.CommonEnvironmentSetup.context,,false,281,283,context,,,14,Local<v8::Context> node.CommonEnvironmentSetup.context ()
2033,METHOD,api\embed_helpers.cc:<global>,TYPE_DECL,"v8::SnapshotCreator* CommonEnvironmentSetup::snapshot_creator() {
  return impl_->snapshot_creator ? &impl_->snapshot_creator.value() : nullptr;
}",1,1,api\embed_helpers.cc,node.CommonEnvironmentSetup.snapshot_creator,,false,285,287,snapshot_creator,,,15,SnapshotCreator node.CommonEnvironmentSetup.snapshot_creator ()
2050,METHOD,api\embed_helpers.cc:<global>,TYPE_DECL,"void EmbedderSnapshotData::DeleteSnapshotData::operator()(
    const EmbedderSnapshotData* data) const {
  CHECK_IMPLIES(data->owns_impl_, data->impl_);
  if (data->owns_impl_ &&
      data->impl_->data_ownership == SnapshotData::DataOwnership::kOwned) {
    delete data->impl_;
  }
  delete data;
}",1,1,api\embed_helpers.cc,node.EmbedderSnapshotData.DeleteSnapshotData.operator (),,false,289,297,operator (),,,16,void node.EmbedderSnapshotData.DeleteSnapshotData.operator () (EmbedderSnapshotData*)
2085,METHOD,api\embed_helpers.cc:<global>,TYPE_DECL,"EmbedderSnapshotData::Pointer EmbedderSnapshotData::BuiltinSnapshotData() {
  return EmbedderSnapshotData::Pointer{new EmbedderSnapshotData(
      SnapshotBuilder::GetEmbeddedSnapshotData(), false)};
}",1,1,api\embed_helpers.cc,node.EmbedderSnapshotData.BuiltinSnapshotData,,false,299,302,BuiltinSnapshotData,,,17,Pointer node.EmbedderSnapshotData.BuiltinSnapshotData ()
2099,METHOD,api\embed_helpers.cc:<global>,TYPE_DECL,"EmbedderSnapshotData::Pointer EmbedderSnapshotData::FromBlob(
    const std::vector<char>& in) {
  SnapshotData* snapshot_data = new SnapshotData();
  CHECK_EQ(snapshot_data->data_ownership, SnapshotData::DataOwnership::kOwned);
  EmbedderSnapshotData::Pointer result{
      new EmbedderSnapshotData(snapshot_data, true)};
  if (!SnapshotData::FromBlob(snapshot_data, in)) {
    return {};
  }
  return result;
}",1,1,api\embed_helpers.cc,node.EmbedderSnapshotData.FromBlob,,false,304,314,FromBlob,,,18,Pointer node.EmbedderSnapshotData.FromBlob (ANY)
2138,METHOD,api\embed_helpers.cc:<global>,TYPE_DECL,"EmbedderSnapshotData::Pointer EmbedderSnapshotData::FromFile(FILE* in) {
  return FromBlob(ReadFileSync(in));
}",1,1,api\embed_helpers.cc,node.EmbedderSnapshotData.FromFile,,false,316,318,FromFile,,,19,Pointer node.EmbedderSnapshotData.FromFile (FILE*)
2147,METHOD,api\embed_helpers.cc:<global>,TYPE_DECL,"std::vector<char> EmbedderSnapshotData::ToBlob() const {
  return impl_->ToBlob();
}",1,1,api\embed_helpers.cc,node.EmbedderSnapshotData.ToBlob,,false,320,322,ToBlob,,,20,vector<char> node.EmbedderSnapshotData.ToBlob ()
2156,METHOD,api\embed_helpers.cc:<global>,TYPE_DECL,"void EmbedderSnapshotData::ToFile(FILE* out) const {
  impl_->ToFile(out);
}",1,1,api\embed_helpers.cc,node.EmbedderSnapshotData.ToFile,,false,324,326,ToFile,,,21,void node.EmbedderSnapshotData.ToFile (FILE*)
2166,METHOD,api\embed_helpers.cc:<global>,TYPE_DECL,"EmbedderSnapshotData::EmbedderSnapshotData(const SnapshotData* impl,
                                           bool owns_impl)
    : impl_(impl), owns_impl_(owns_impl) {}",1,43,api\embed_helpers.cc,node.EmbedderSnapshotData.EmbedderSnapshotData,,false,328,330,EmbedderSnapshotData,,,22,"ANY node.EmbedderSnapshotData.EmbedderSnapshotData (SnapshotData*,bool)"
2172,METHOD,api\embed_helpers.cc:<global>,TYPE_DECL,"bool EmbedderSnapshotData::CanUseCustomSnapshotPerIsolate() {
#ifdef NODE_V8_SHARED_RO_HEAP
  return false;
#else
  return true;
#endif
}",1,1,api\embed_helpers.cc,node.EmbedderSnapshotData.CanUseCustomSnapshotPerIsolate,,false,332,338,CanUseCustomSnapshotPerIsolate,,,23,bool node.EmbedderSnapshotData.CanUseCustomSnapshotPerIsolate ()
2189,METHOD,api\encoding.cc:<global>,TYPE_DECL,<global>,1,59,node.hpp,api\encoding.cc:<global>,,false,1,160,<global>,,,1,
2192,METHOD,api\encoding.cc:<global>,TYPE_DECL,"enum encoding ParseEncoding(const char* encoding,
                            enum encoding default_encoding) {
  switch (encoding[0]) {
    case 'u':
    case 'U':
      // Note: the two first conditions are needed for performance reasons
      // as ""utf8""/""utf-8"" is a common case.
      // (same for other cases below)

      // utf8, utf16le
      if (encoding[1] == 't' && encoding[2] == 'f') {
        // Skip `-`
        const size_t skip = encoding[3] == '-' ? 4 : 3;
        if (encoding[skip] == '8' && encoding[skip + 1] == '\0')
          return UTF8;
        if (strncmp(encoding + skip, ""16le"", 5) == 0)
          return UCS2;
      // ucs2
      } else if (encoding[1] == 'c' && encoding[2] == 's') {
        const size_t skip = encoding[3] == '-' ? 4 : 3;
        if (encoding[skip] == '2' && encoding[skip + 1] == '\0')
          return UCS2;
      }
      if (StringEqualNoCase(encoding, ""utf8""))
        return UTF8;
      if (StringEqualNoCase(encoding, ""utf-8""))
        retu...",1,1,api\encoding.cc,node.ParseEncoding,,false,13,110,ParseEncoding,,,1,"enum encoding node.ParseEncoding (char*,encoding)"
2550,METHOD,api\encoding.cc:<global>,TYPE_DECL,"enum encoding ParseEncoding(Isolate* isolate,
                            Local<Value> encoding_v,
                            enum encoding default_encoding) {
  CHECK(!encoding_v.IsEmpty());

  if (!encoding_v->IsString())
    return default_encoding;

  Utf8Value encoding(isolate, encoding_v);

  return ParseEncoding(*encoding, default_encoding);
}",1,1,api\encoding.cc,node.ParseEncoding,,false,113,124,ParseEncoding,,,2,"enum encoding node.ParseEncoding (Isolate*,Local<Value>,encoding)"
2581,METHOD,api\encoding.cc:<global>,TYPE_DECL,"Local<Value> Encode(Isolate* isolate,
                    const char* buf,
                    size_t len,
                    enum encoding encoding) {
  CHECK_NE(encoding, UCS2);
  Local<Value> error;
  return StringBytes::Encode(isolate, buf, len, encoding, &error)
      .ToLocalChecked();
}",1,1,api\encoding.cc,node.Encode,,false,126,134,Encode,,,3,"Local<Value> node.Encode (Isolate*,char*,size_t,encoding)"
2611,METHOD,api\encoding.cc:<global>,TYPE_DECL,"Local<Value> Encode(Isolate* isolate, const uint16_t* buf, size_t len) {
  Local<Value> error;
  return StringBytes::Encode(isolate, buf, len, &error)
      .ToLocalChecked();
}",1,1,api\encoding.cc,node.Encode,,false,136,140,Encode,,,4,"Local<Value> node.Encode (Isolate*,uint16_t*,size_t)"
2636,METHOD,api\encoding.cc:<global>,TYPE_DECL,"ssize_t DecodeBytes(Isolate* isolate,
                    Local<Value> val,
                    enum encoding encoding) {
  HandleScope scope(isolate);

  return StringBytes::Size(isolate, val, encoding).FromMaybe(-1);
}",1,1,api\encoding.cc,node.DecodeBytes,,false,143,149,DecodeBytes,,,5,"ssize_t node.DecodeBytes (Isolate*,Local<Value>,encoding)"
2659,METHOD,api\encoding.cc:<global>,TYPE_DECL,"ssize_t DecodeWrite(Isolate* isolate,
                    char* buf,
                    size_t buflen,
                    Local<Value> val,
                    enum encoding encoding) {
  return StringBytes::Write(isolate, buf, buflen, val, encoding);
}",1,1,api\encoding.cc,node.DecodeWrite,,false,152,158,DecodeWrite,,,6,"ssize_t node.DecodeWrite (Isolate*,char*,size_t,Local<Value>,encoding)"
2679,METHOD,api\environment.cc:<global>,TYPE_DECL,"[&](const StartExecutionCallbackInfo& info) -> MaybeLocal<Value> {
        Local<Value> main_script =
            ToV8Value(env->context(), main_script_source_utf8).ToLocalChecked();
        return info.run_cjs->Call(
            env->context(), Null(env->isolate()), 1, &main_script);
      }",12,7,api\environment.cc,node.LoadEnvironment.<lambda>0,,false,556,561,<lambda>0,,,1,MaybeLocal<Value> node.LoadEnvironment.<lambda>0 (StartExecutionCallbackInfo)
2722,METHOD,api\environment.cc:<global>,TYPE_DECL,"[=](Environment* env, ExitCode exit_code) {
    movedHandler(env, static_cast<int>(exit_code));
  }",33,3,api\environment.cc,node.SetProcessExitHandler.<lambda>1,,false,932,934,<lambda>1,,,1,"ANY node.SetProcessExitHandler.<lambda>1 (Environment*,ExitCode)"
2770,METHOD,api\environment.cc:<global>,TYPE_DECL,<global>,1,19,api\environment.cc,api\environment.cc:<global>,,false,1,937,<global>,,,1,
2773,METHOD,api\environment.cc:<global>,TYPE_DECL,"bool AllowWasmCodeGenerationCallback(Local<Context> context,
                                     Local<String>) {
  Local<Value> wasm_code_gen =
      context->GetEmbedderData(ContextEmbedderIndex::kAllowWasmCodeGeneration);
  return wasm_code_gen->IsUndefined() || wasm_code_gen->IsTrue();
}",1,1,api\environment.cc,node.AllowWasmCodeGenerationCallback,,false,47,52,AllowWasmCodeGenerationCallback,,,1,"bool node.AllowWasmCodeGenerationCallback (Local<Context>,Local<String>)"
2802,METHOD,api\environment.cc:<global>,TYPE_DECL,"bool ShouldAbortOnUncaughtException(Isolate* isolate) {
  DebugSealHandleScope scope(isolate);
  Environment* env = Environment::GetCurrent(isolate);
  return env != nullptr &&
         (env->is_main_thread() || !env->is_stopping()) &&
         env->abort_on_uncaught_exception() &&
         env->should_abort_on_uncaught_toggle()[0] &&
         !env->inside_should_not_abort_on_uncaught_scope();
}",1,1,api\environment.cc,node.ShouldAbortOnUncaughtException,,false,54,62,ShouldAbortOnUncaughtException,,,2,bool node.ShouldAbortOnUncaughtException (Isolate*)
2851,METHOD,api\environment.cc:<global>,TYPE_DECL,"MaybeLocal<Value> PrepareStackTraceCallback(Local<Context> context,
                                            Local<Value> exception,
                                            Local<Array> trace) {
  Environment* env = Environment::GetCurrent(context);
  if (env == nullptr) {
    return exception->ToString(context).FromMaybe(Local<Value>());
  }
  Realm* realm = Realm::GetCurrent(context);
  Local<Function> prepare;
  if (realm != nullptr) {
    // If we are in a Realm, call the realm specific prepareStackTrace callback
    // to avoid passing the JS objects (the exception and trace) across the
    // realm boundary with the `Error.prepareStackTrace` override.
    prepare = realm->prepare_stack_trace_callback();
  } else {
    // The context is created with ContextifyContext, call the principal
    // realm's prepareStackTrace callback.
    prepare = env->principal_realm()->prepare_stack_trace_callback();
  }
  if (prepare.IsEmpty()) {
    return exception->ToString(context).Fro...",1,1,api\environment.cc,node.PrepareStackTraceCallback,,false,64,102,PrepareStackTraceCallback,,,3,"MaybeLocal<Value> node.PrepareStackTraceCallback (Local<Context>,Local<Value>,Local<Array>)"
2982,METHOD,api\environment.cc:<global>,TYPE_DECL,"void* NodeArrayBufferAllocator::Allocate(size_t size) {
  void* ret;
  if (zero_fill_field_ || per_process::cli_options->zero_fill_all_buffers)
    ret = allocator_->Allocate(size);
  else
    ret = allocator_->AllocateUninitialized(size);
  if (LIKELY(ret != nullptr))
    total_mem_usage_.fetch_add(size, std::memory_order_relaxed);
  return ret;
}",1,1,api\environment.cc,node.NodeArrayBufferAllocator.Allocate,,false,104,113,Allocate,,,4,void* node.NodeArrayBufferAllocator.Allocate (size_t)
3029,METHOD,api\environment.cc:<global>,TYPE_DECL,"void* NodeArrayBufferAllocator::AllocateUninitialized(size_t size) {
  void* ret = allocator_->AllocateUninitialized(size);
  if (LIKELY(ret != nullptr))
    total_mem_usage_.fetch_add(size, std::memory_order_relaxed);
  return ret;
}",1,1,api\environment.cc,node.NodeArrayBufferAllocator.AllocateUninitialized,,false,115,120,AllocateUninitialized,,,5,void* node.NodeArrayBufferAllocator.AllocateUninitialized (size_t)
3058,METHOD,api\environment.cc:<global>,TYPE_DECL,"void* NodeArrayBufferAllocator::Reallocate(
    void* data, size_t old_size, size_t size) {
  void* ret = allocator_->Reallocate(data, old_size, size);
  if (LIKELY(ret != nullptr) || UNLIKELY(size == 0))
    total_mem_usage_.fetch_add(size - old_size, std::memory_order_relaxed);
  return ret;
}",1,1,api\environment.cc,node.NodeArrayBufferAllocator.Reallocate,,false,122,128,Reallocate,,,6,"void* node.NodeArrayBufferAllocator.Reallocate (void*,size_t,size_t)"
3098,METHOD,api\environment.cc:<global>,TYPE_DECL,"void NodeArrayBufferAllocator::Free(void* data, size_t size) {
  total_mem_usage_.fetch_sub(size, std::memory_order_relaxed);
  allocator_->Free(data, size);
}",1,1,api\environment.cc,node.NodeArrayBufferAllocator.Free,,false,130,133,Free,,,7,"void node.NodeArrayBufferAllocator.Free (void*,size_t)"
3118,METHOD,api\environment.cc:<global>,TYPE_DECL,"DebuggingArrayBufferAllocator::~DebuggingArrayBufferAllocator() {
  CHECK(allocations_.empty());
}",1,1,api\environment.cc,node.DebuggingArrayBufferAllocator.~DebuggingArrayBufferAllocator,,false,135,137,~DebuggingArrayBufferAllocator,,,8,ANY node.DebuggingArrayBufferAllocator.~DebuggingArrayBufferAllocator ()
3127,METHOD,api\environment.cc:<global>,TYPE_DECL,"void* DebuggingArrayBufferAllocator::Allocate(size_t size) {
  Mutex::ScopedLock lock(mutex_);
  void* data = NodeArrayBufferAllocator::Allocate(size);
  RegisterPointerInternal(data, size);
  return data;
}",1,1,api\environment.cc,node.DebuggingArrayBufferAllocator.Allocate,,false,139,144,Allocate,,,9,void* node.DebuggingArrayBufferAllocator.Allocate (size_t)
3148,METHOD,api\environment.cc:<global>,TYPE_DECL,"void* DebuggingArrayBufferAllocator::AllocateUninitialized(size_t size) {
  Mutex::ScopedLock lock(mutex_);
  void* data = NodeArrayBufferAllocator::AllocateUninitialized(size);
  RegisterPointerInternal(data, size);
  return data;
}",1,1,api\environment.cc,node.DebuggingArrayBufferAllocator.AllocateUninitialized,,false,146,151,AllocateUninitialized,,,10,void* node.DebuggingArrayBufferAllocator.AllocateUninitialized (size_t)
3169,METHOD,api\environment.cc:<global>,TYPE_DECL,"void DebuggingArrayBufferAllocator::Free(void* data, size_t size) {
  Mutex::ScopedLock lock(mutex_);
  UnregisterPointerInternal(data, size);
  NodeArrayBufferAllocator::Free(data, size);
}",1,1,api\environment.cc,node.DebuggingArrayBufferAllocator.Free,,false,153,157,Free,,,11,"void node.DebuggingArrayBufferAllocator.Free (void*,size_t)"
3187,METHOD,api\environment.cc:<global>,TYPE_DECL,"void* DebuggingArrayBufferAllocator::Reallocate(void* data,
                                                size_t old_size,
                                                size_t size) {
  Mutex::ScopedLock lock(mutex_);
  void* ret = NodeArrayBufferAllocator::Reallocate(data, old_size, size);
  if (ret == nullptr) {
    if (size == 0) {  // i.e. equivalent to free().
      // suppress coverity warning as data is used as key versus as pointer
      // in UnregisterPointerInternal
      // coverity[pass_freed_arg]
      UnregisterPointerInternal(data, old_size);
    }
    return nullptr;
  }

  if (data != nullptr) {
    auto it = allocations_.find(data);
    CHECK_NE(it, allocations_.end());
    allocations_.erase(it);
  }

  RegisterPointerInternal(ret, size);
  return ret;
}",1,1,api\environment.cc,node.DebuggingArrayBufferAllocator.Reallocate,,false,159,182,Reallocate,,,12,"void* node.DebuggingArrayBufferAllocator.Reallocate (void*,size_t,size_t)"
3251,METHOD,api\environment.cc:<global>,TYPE_DECL,"void DebuggingArrayBufferAllocator::RegisterPointer(void* data, size_t size) {
  Mutex::ScopedLock lock(mutex_);
  NodeArrayBufferAllocator::RegisterPointer(data, size);
  RegisterPointerInternal(data, size);
}",1,1,api\environment.cc,node.DebuggingArrayBufferAllocator.RegisterPointer,,false,184,188,RegisterPointer,,,13,"void node.DebuggingArrayBufferAllocator.RegisterPointer (void*,size_t)"
3269,METHOD,api\environment.cc:<global>,TYPE_DECL,"void DebuggingArrayBufferAllocator::UnregisterPointer(void* data, size_t size) {
  Mutex::ScopedLock lock(mutex_);
  NodeArrayBufferAllocator::UnregisterPointer(data, size);
  UnregisterPointerInternal(data, size);
}",1,1,api\environment.cc,node.DebuggingArrayBufferAllocator.UnregisterPointer,,false,190,194,UnregisterPointer,,,14,"void node.DebuggingArrayBufferAllocator.UnregisterPointer (void*,size_t)"
3287,METHOD,api\environment.cc:<global>,TYPE_DECL,"void DebuggingArrayBufferAllocator::UnregisterPointerInternal(void* data,
                                                              size_t size) {
  if (data == nullptr) return;
  auto it = allocations_.find(data);
  CHECK_NE(it, allocations_.end());
  if (size > 0) {
    // We allow allocations with size 1 for 0-length buffers to avoid having
    // to deal with nullptr values.
    CHECK_EQ(it->second, size);
  }
  allocations_.erase(it);
}",1,1,api\environment.cc,node.DebuggingArrayBufferAllocator.UnregisterPointerInternal,,false,196,207,UnregisterPointerInternal,,,15,"void node.DebuggingArrayBufferAllocator.UnregisterPointerInternal (void*,size_t)"
3328,METHOD,api\environment.cc:<global>,TYPE_DECL,"void DebuggingArrayBufferAllocator::RegisterPointerInternal(void* data,
                                                            size_t size) {
  if (data == nullptr) return;
  CHECK_EQ(allocations_.count(data), 0);
  allocations_[data] = size;
}",1,1,api\environment.cc,node.DebuggingArrayBufferAllocator.RegisterPointerInternal,,false,209,214,RegisterPointerInternal,,,16,"void node.DebuggingArrayBufferAllocator.RegisterPointerInternal (void*,size_t)"
3352,METHOD,api\environment.cc:<global>,TYPE_DECL,"std::unique_ptr<ArrayBufferAllocator> ArrayBufferAllocator::Create(bool debug) {
  if (debug || per_process::cli_options->debug_arraybuffer_allocations)
    return std::make_unique<DebuggingArrayBufferAllocator>();
  else
    return std::make_unique<NodeArrayBufferAllocator>();
}",1,1,api\environment.cc,node.ArrayBufferAllocator.Create,,false,216,221,Create,,,17,unique_ptr<ArrayBufferAllocator> node.ArrayBufferAllocator.Create (bool)
3378,METHOD,api\environment.cc:<global>,TYPE_DECL,"ArrayBufferAllocator* CreateArrayBufferAllocator() {
  return ArrayBufferAllocator::Create().release();
}",1,1,api\environment.cc,node.CreateArrayBufferAllocator,,false,223,225,CreateArrayBufferAllocator,,,18,ArrayBufferAllocator node.CreateArrayBufferAllocator ()
3390,METHOD,api\environment.cc:<global>,TYPE_DECL,"void FreeArrayBufferAllocator(ArrayBufferAllocator* allocator) {
  delete allocator;
}",1,1,api\environment.cc,node.FreeArrayBufferAllocator,,false,227,229,FreeArrayBufferAllocator,,,19,void node.FreeArrayBufferAllocator (ArrayBufferAllocator*)
3397,METHOD,api\environment.cc:<global>,TYPE_DECL,"void SetIsolateCreateParamsForNode(Isolate::CreateParams* params) {
  const uint64_t constrained_memory = uv_get_constrained_memory();
  const uint64_t total_memory = constrained_memory > 0 ?
      std::min(uv_get_total_memory(), constrained_memory) :
      uv_get_total_memory();
  if (total_memory > 0 &&
      params->constraints.max_old_generation_size_in_bytes() == 0) {
    // V8 defaults to 700MB or 1.4GB on 32 and 64 bit platforms respectively.
    // This default is based on browser use-cases. Tell V8 to configure the
    // heap based on the actual physical memory.
    params->constraints.ConfigureDefaults(total_memory, 0);
  }
  params->embedder_wrapper_object_index = BaseObject::InternalFields::kSlot;
  params->embedder_wrapper_type_index = std::numeric_limits<int>::max();

#ifdef NODE_ENABLE_VTUNE_PROFILING
  params->code_event_handler = vTune::GetVtuneCodeEventHandler();
#endif
}",1,1,api\environment.cc,node.SetIsolateCreateParamsForNode,,false,231,249,SetIsolateCreateParamsForNode,,,20,void node.SetIsolateCreateParamsForNode (ANY*)
3461,METHOD,api\environment.cc:<global>,TYPE_DECL,"void SetIsolateErrorHandlers(v8::Isolate* isolate, const IsolateSettings& s) {
  if (s.flags & MESSAGE_LISTENER_WITH_ERROR_LEVEL)
    isolate->AddMessageListenerWithErrorLevel(
            errors::PerIsolateMessageListener,
            Isolate::MessageErrorLevel::kMessageError |
                Isolate::MessageErrorLevel::kMessageWarning);

  auto* abort_callback = s.should_abort_on_uncaught_exception_callback ?
      s.should_abort_on_uncaught_exception_callback :
      ShouldAbortOnUncaughtException;
  isolate->SetAbortOnUncaughtExceptionCallback(abort_callback);

  auto* fatal_error_cb = s.fatal_error_callback ?
      s.fatal_error_callback : OnFatalError;
  isolate->SetFatalErrorHandler(fatal_error_cb);
  isolate->SetOOMErrorHandler(OOMErrorHandler);

  if ((s.flags & SHOULD_NOT_SET_PREPARE_STACK_TRACE_CALLBACK) == 0) {
    auto* prepare_stack_trace_cb = s.prepare_stack_trace_callback ?
        s.prepare_stack_trace_callback : PrepareStackTraceCallback;
    isolate->SetPrepareSt...",1,1,api\environment.cc,node.SetIsolateErrorHandlers,,false,251,273,SetIsolateErrorHandlers,,,21,"void node.SetIsolateErrorHandlers (ANY*,IsolateSettings)"
3554,METHOD,api\environment.cc:<global>,TYPE_DECL,"void SetIsolateMiscHandlers(v8::Isolate* isolate, const IsolateSettings& s) {
  isolate->SetMicrotasksPolicy(s.policy);

  auto* allow_wasm_codegen_cb = s.allow_wasm_code_generation_callback ?
    s.allow_wasm_code_generation_callback : AllowWasmCodeGenerationCallback;
  isolate->SetAllowWasmCodeGenerationCallback(allow_wasm_codegen_cb);

  auto* modify_code_generation_from_strings_callback =
      ModifyCodeGenerationFromStrings;
  if (s.modify_code_generation_from_strings_callback != nullptr) {
    modify_code_generation_from_strings_callback =
        s.modify_code_generation_from_strings_callback;
  }
  isolate->SetModifyCodeGenerationFromStringsCallback(
      modify_code_generation_from_strings_callback);

  Mutex::ScopedLock lock(node::per_process::cli_options_mutex);
  if (per_process::cli_options->get_per_isolate_options()
          ->get_per_env_options()
          ->experimental_fetch) {
    isolate->SetWasmStreamingCallback(wasm_web_api::StartStreamingCompilation);
  }

...",1,1,api\environment.cc,node.SetIsolateMiscHandlers,,false,275,312,SetIsolateMiscHandlers,,,22,"void node.SetIsolateMiscHandlers (ANY*,IsolateSettings)"
3687,METHOD,api\environment.cc:<global>,TYPE_DECL,"void SetIsolateUpForNode(v8::Isolate* isolate,
                         const IsolateSettings& settings) {
  SetIsolateErrorHandlers(isolate, settings);
  SetIsolateMiscHandlers(isolate, settings);
}",1,1,api\environment.cc,node.SetIsolateUpForNode,,false,314,318,SetIsolateUpForNode,,,23,"void node.SetIsolateUpForNode (ANY*,IsolateSettings)"
3699,METHOD,api\environment.cc:<global>,TYPE_DECL,"void SetIsolateUpForNode(v8::Isolate* isolate) {
  IsolateSettings settings;
  SetIsolateUpForNode(isolate, settings);
}",1,1,api\environment.cc,node.SetIsolateUpForNode,,false,320,323,SetIsolateUpForNode,,,24,void node.SetIsolateUpForNode (ANY*)
3708,METHOD,api\environment.cc:<global>,TYPE_DECL,"Isolate* NewIsolate(Isolate::CreateParams* params,
                    uv_loop_t* event_loop,
                    MultiIsolatePlatform* platform,
                    const SnapshotData* snapshot_data,
                    const IsolateSettings& settings) {
  Isolate* isolate = Isolate::Allocate();
  if (isolate == nullptr) return nullptr;

  if (snapshot_data != nullptr) {
    SnapshotBuilder::InitializeIsolateParams(snapshot_data, params);
  }

#ifdef NODE_V8_SHARED_RO_HEAP
  {
    // In shared-readonly-heap mode, V8 requires all snapshots used for
    // creating Isolates to be identical. This isn't really memory-safe
    // but also otherwise just doesn't work, and the only real alternative
    // is disabling shared-readonly-heap mode altogether.
    static Isolate::CreateParams first_params = *params;
    params->snapshot_blob = first_params.snapshot_blob;
    params->external_references = first_params.external_references;
  }
#endif

  // Register the isolate on the platform be...",1,1,api\environment.cc,node.NewIsolate,,false,327,366,NewIsolate,,,25,"Isolate node.NewIsolate (ANY*,uv_loop_t*,MultiIsolatePlatform*,SnapshotData*,IsolateSettings)"
3772,METHOD,api\environment.cc:<global>,TYPE_DECL,"Isolate* NewIsolate(ArrayBufferAllocator* allocator,
                    uv_loop_t* event_loop,
                    MultiIsolatePlatform* platform,
                    const EmbedderSnapshotData* snapshot_data,
                    const IsolateSettings& settings) {
  Isolate::CreateParams params;
  if (allocator != nullptr) params.array_buffer_allocator = allocator;
  return NewIsolate(&params,
                    event_loop,
                    platform,
                    SnapshotData::FromEmbedderWrapper(snapshot_data),
                    settings);
}",1,1,api\environment.cc,node.NewIsolate,,false,368,380,NewIsolate,,,26,"Isolate node.NewIsolate (ArrayBufferAllocator*,uv_loop_t*,MultiIsolatePlatform*,EmbedderSnapshotData*,IsolateSettings)"
3804,METHOD,api\environment.cc:<global>,TYPE_DECL,"Isolate* NewIsolate(std::shared_ptr<ArrayBufferAllocator> allocator,
                    uv_loop_t* event_loop,
                    MultiIsolatePlatform* platform,
                    const EmbedderSnapshotData* snapshot_data,
                    const IsolateSettings& settings) {
  Isolate::CreateParams params;
  if (allocator) params.array_buffer_allocator_shared = allocator;
  return NewIsolate(&params,
                    event_loop,
                    platform,
                    SnapshotData::FromEmbedderWrapper(snapshot_data),
                    settings);
}",1,1,api\environment.cc,node.NewIsolate,,false,382,394,NewIsolate,,,27,"Isolate node.NewIsolate (ANY,uv_loop_t*,MultiIsolatePlatform*,EmbedderSnapshotData*,IsolateSettings)"
3834,METHOD,api\environment.cc:<global>,TYPE_DECL,"IsolateData* CreateIsolateData(
    Isolate* isolate,
    uv_loop_t* loop,
    MultiIsolatePlatform* platform,
    ArrayBufferAllocator* allocator,
    const EmbedderSnapshotData* embedder_snapshot_data) {
  const SnapshotData* snapshot_data =
      SnapshotData::FromEmbedderWrapper(embedder_snapshot_data);
  return new IsolateData(isolate, loop, platform, allocator, snapshot_data);
}",1,1,api\environment.cc,node.CreateIsolateData,,false,396,405,CreateIsolateData,,,28,"IsolateData node.CreateIsolateData (Isolate*,uv_loop_t*,MultiIsolatePlatform*,ArrayBufferAllocator*,EmbedderSnapshotData*)"
3859,METHOD,api\environment.cc:<global>,TYPE_DECL,"void FreeIsolateData(IsolateData* isolate_data) {
  delete isolate_data;
}",1,1,api\environment.cc,node.FreeIsolateData,,false,407,409,FreeIsolateData,,,29,void node.FreeIsolateData (IsolateData*)
3866,METHOD,api\environment.cc:<global>,TYPE_DECL,InspectorParentHandle::~InspectorParentHandle() {},1,50,api\environment.cc,node.InspectorParentHandle.~InspectorParentHandle,,false,411,411,~InspectorParentHandle,,,30,ANY node.InspectorParentHandle.~InspectorParentHandle ()
3870,METHOD,api\environment.cc:<global>,TYPE_DECL,"Environment* CreateEnvironment(
    IsolateData* isolate_data,
    Local<Context> context,
    const std::vector<std::string>& args,
    const std::vector<std::string>& exec_args,
    EnvironmentFlags::Flags flags,
    ThreadId thread_id,
    std::unique_ptr<InspectorParentHandle> inspector_parent_handle) {
  Isolate* isolate = isolate_data->isolate();
  HandleScope handle_scope(isolate);

  const bool use_snapshot = context.IsEmpty();
  const EnvSerializeInfo* env_snapshot_info = nullptr;
  if (use_snapshot) {
    CHECK_NOT_NULL(isolate_data->snapshot_data());
    env_snapshot_info = &isolate_data->snapshot_data()->env_info;
  }

  // TODO(addaleax): This is a much better place for parsing per-Environment
  // options than the global parse call.
  Environment* env = new Environment(isolate_data,
                                     isolate,
                                     args,
                                     exec_args,
                                     env_snapshot_in...",1,1,api\environment.cc,node.CreateEnvironment,,false,424,490,CreateEnvironment,,,31,"Environment node.CreateEnvironment (IsolateData*,Local<Context>,ANY,ANY,ANY,ThreadId,ANY)"
4005,METHOD,api\environment.cc:<global>,TYPE_DECL,"void FreeEnvironment(Environment* env) {
  Isolate* isolate = env->isolate();
  Isolate::DisallowJavascriptExecutionScope disallow_js(isolate,
      Isolate::DisallowJavascriptExecutionScope::THROW_ON_FAILURE);
  {
    HandleScope handle_scope(isolate);  // For env->context().
    Context::Scope context_scope(env->context());
    SealHandleScope seal_handle_scope(isolate);

    // Set the flag in accordance with the DisallowJavascriptExecutionScope
    // above.
    env->set_can_call_into_js(false);
    env->set_stopping(true);
    env->stop_sub_worker_contexts();
    env->RunCleanup();
    RunAtExit(env);
  }

  // This call needs to be made while the `Environment` is still alive
  // because we assume that it is available for async tracking in the
  // NodePlatform implementation.
  MultiIsolatePlatform* platform = env->isolate_data()->platform();
  if (platform != nullptr)
    platform->DrainTasks(isolate);

  delete env;
}",1,1,api\environment.cc,node.FreeEnvironment,,false,492,518,FreeEnvironment,,,32,void node.FreeEnvironment (Environment*)
4080,METHOD,api\environment.cc:<global>,TYPE_DECL,"NODE_EXTERN std::unique_ptr<InspectorParentHandle> GetInspectorParentHandle(
    Environment* env,
    ThreadId thread_id,
    const char* url) {
  return GetInspectorParentHandle(env, thread_id, url, """");
}",1,11,api\environment.cc,node.GetInspectorParentHandle,,false,520,525,GetInspectorParentHandle,,,33,"unique_ptr<InspectorParentHandle> node.GetInspectorParentHandle (Environment*,ThreadId,char*)"
4093,METHOD,api\environment.cc:<global>,TYPE_DECL,"NODE_EXTERN std::unique_ptr<InspectorParentHandle> GetInspectorParentHandle(
    Environment* env, ThreadId thread_id, const char* url, const char* name) {
  CHECK_NOT_NULL(env);
  if (name == nullptr) name = """";
  CHECK_NE(thread_id.id, static_cast<uint64_t>(-1));
  if (!env->should_create_inspector()) {
    return nullptr;
  }
#if HAVE_INSPECTOR
  return std::make_unique<InspectorParentHandleImpl>(
      env->inspector_agent()->GetParentHandle(thread_id.id, url, name));
#else
  return {};
#endif
}",1,11,api\environment.cc,node.GetInspectorParentHandle,,false,527,541,GetInspectorParentHandle,,,34,"unique_ptr<InspectorParentHandle> node.GetInspectorParentHandle (Environment*,ThreadId,char*,char*)"
4129,METHOD,api\environment.cc:<global>,TYPE_DECL,"MaybeLocal<Value> LoadEnvironment(
    Environment* env,
    StartExecutionCallback cb) {
  env->InitializeLibuv();
  env->InitializeDiagnostics();

  return StartExecution(env, cb);
}",1,1,api\environment.cc,node.LoadEnvironment,,false,543,550,LoadEnvironment,,,35,"MaybeLocal<Value> node.LoadEnvironment (Environment*,StartExecutionCallback)"
4147,METHOD,api\environment.cc:<global>,TYPE_DECL,"MaybeLocal<Value> LoadEnvironment(Environment* env,
                                  std::string_view main_script_source_utf8) {
  CHECK_NOT_NULL(main_script_source_utf8.data());
  return LoadEnvironment(
      env, [&](const StartExecutionCallbackInfo& info) -> MaybeLocal<Value> {
        Local<Value> main_script =
            ToV8Value(env->context(), main_script_source_utf8).ToLocalChecked();
        return info.run_cjs->Call(
            env->context(), Null(env->isolate()), 1, &main_script);
      });
}",1,1,api\environment.cc,node.LoadEnvironment,,false,552,562,LoadEnvironment,,,36,"MaybeLocal<Value> node.LoadEnvironment (Environment*,ANY)"
4160,METHOD,api\environment.cc:<global>,TYPE_DECL,"Environment* GetCurrentEnvironment(Local<Context> context) {
  return Environment::GetCurrent(context);
}",1,1,api\environment.cc,node.GetCurrentEnvironment,,false,564,566,GetCurrentEnvironment,,,37,Environment node.GetCurrentEnvironment (Local<Context>)
4171,METHOD,api\environment.cc:<global>,TYPE_DECL,"IsolateData* GetEnvironmentIsolateData(Environment* env) {
  return env->isolate_data();
}",1,1,api\environment.cc,node.GetEnvironmentIsolateData,,false,568,570,GetEnvironmentIsolateData,,,38,IsolateData node.GetEnvironmentIsolateData (Environment*)
4181,METHOD,api\environment.cc:<global>,TYPE_DECL,"ArrayBufferAllocator* GetArrayBufferAllocator(IsolateData* isolate_data) {
  return isolate_data->node_allocator();
}",1,1,api\environment.cc,node.GetArrayBufferAllocator,,false,572,574,GetArrayBufferAllocator,,,39,ArrayBufferAllocator node.GetArrayBufferAllocator (IsolateData*)
4191,METHOD,api\environment.cc:<global>,TYPE_DECL,"Local<Context> GetMainContext(Environment* env) {
  return env->context();
}",1,1,api\environment.cc,node.GetMainContext,,false,576,578,GetMainContext,,,40,Local<Context> node.GetMainContext (Environment*)
4201,METHOD,api\environment.cc:<global>,TYPE_DECL,"MultiIsolatePlatform* GetMultiIsolatePlatform(Environment* env) {
  return GetMultiIsolatePlatform(env->isolate_data());
}",1,1,api\environment.cc,node.GetMultiIsolatePlatform,,false,580,582,GetMultiIsolatePlatform,,,41,MultiIsolatePlatform node.GetMultiIsolatePlatform (Environment*)
4212,METHOD,api\environment.cc:<global>,TYPE_DECL,"MultiIsolatePlatform* GetMultiIsolatePlatform(IsolateData* env) {
  return env->platform();
}",1,1,api\environment.cc,node.GetMultiIsolatePlatform,,false,584,586,GetMultiIsolatePlatform,,,42,MultiIsolatePlatform node.GetMultiIsolatePlatform (IsolateData*)
4222,METHOD,api\environment.cc:<global>,TYPE_DECL,"MultiIsolatePlatform* CreatePlatform(
    int thread_pool_size,
    node::tracing::TracingController* tracing_controller) {
  return CreatePlatform(
      thread_pool_size,
      static_cast<v8::TracingController*>(tracing_controller));
}",1,1,api\environment.cc,node.CreatePlatform,,false,588,594,CreatePlatform,,,43,"MultiIsolatePlatform node.CreatePlatform (int,ANY*)"
4234,METHOD,api\environment.cc:<global>,TYPE_DECL,"MultiIsolatePlatform* CreatePlatform(
    int thread_pool_size,
    v8::TracingController* tracing_controller) {
  return MultiIsolatePlatform::Create(thread_pool_size,
                                      tracing_controller)
      .release();
}",1,1,api\environment.cc,node.CreatePlatform,,false,596,602,CreatePlatform,,,44,"MultiIsolatePlatform node.CreatePlatform (int,ANY*)"
4250,METHOD,api\environment.cc:<global>,TYPE_DECL,"void FreePlatform(MultiIsolatePlatform* platform) {
  delete platform;
}",1,1,api\environment.cc,node.FreePlatform,,false,604,606,FreePlatform,,,45,void node.FreePlatform (MultiIsolatePlatform*)
4257,METHOD,api\environment.cc:<global>,TYPE_DECL,"std::unique_ptr<MultiIsolatePlatform> MultiIsolatePlatform::Create(
    int thread_pool_size,
    v8::TracingController* tracing_controller,
    v8::PageAllocator* page_allocator) {
  return std::make_unique<NodePlatform>(thread_pool_size,
                                        tracing_controller,
                                        page_allocator);
}",1,1,api\environment.cc,node.MultiIsolatePlatform.Create,,false,608,615,Create,,,46,"unique_ptr<MultiIsolatePlatform> node.MultiIsolatePlatform.Create (int,ANY*,ANY*)"
4276,METHOD,api\environment.cc:<global>,TYPE_DECL,"MaybeLocal<Object> GetPerContextExports(Local<Context> context) {
  Isolate* isolate = context->GetIsolate();
  EscapableHandleScope handle_scope(isolate);

  Local<Object> global = context->Global();
  Local<Private> key = Private::ForApi(isolate,
      FIXED_ONE_BYTE_STRING(isolate, ""node:per_context_binding_exports""));

  Local<Value> existing_value;
  if (!global->GetPrivate(context, key).ToLocal(&existing_value))
    return MaybeLocal<Object>();
  if (existing_value->IsObject())
    return handle_scope.Escape(existing_value.As<Object>());

  Local<Object> exports = Object::New(isolate);
  if (context->Global()->SetPrivate(context, key, exports).IsNothing() ||
      InitializePrimordials(context).IsNothing())
    return MaybeLocal<Object>();
  return handle_scope.Escape(exports);
}",1,1,api\environment.cc,node.GetPerContextExports,,false,617,636,GetPerContextExports,,,47,MaybeLocal<Object> node.GetPerContextExports (Local<Context>)
4391,METHOD,api\environment.cc:<global>,TYPE_DECL,"Local<Context> NewContext(Isolate* isolate,
                          Local<ObjectTemplate> object_template) {
  auto context = Context::New(isolate, nullptr, object_template);
  if (context.IsEmpty()) return context;

  if (InitializeContext(context).IsNothing()) {
    return Local<Context>();
  }

  return context;
}",1,1,api\environment.cc,node.NewContext,,false,641,651,NewContext,,,48,"Local<Context> node.NewContext (Isolate*,Local<ObjectTemplate>)"
4426,METHOD,api\environment.cc:<global>,TYPE_DECL,"void ProtoThrower(const FunctionCallbackInfo<Value>& info) {
  THROW_ERR_PROTO_ACCESS(info.GetIsolate());
}",1,1,api\environment.cc,node.ProtoThrower,,false,653,655,ProtoThrower,,,49,void node.ProtoThrower (FunctionCallbackInfo<Value>)
4436,METHOD,api\environment.cc:<global>,TYPE_DECL,"Maybe<bool> InitializeContextRuntime(Local<Context> context) {
  Isolate* isolate = context->GetIsolate();
  HandleScope handle_scope(isolate);

  // When `IsCodeGenerationFromStringsAllowed` is true, V8 takes the fast path
  // and ignores the ModifyCodeGenerationFromStrings callback. Set it to false
  // to delegate the code generation validation to
  // node::ModifyCodeGenerationFromStrings.
  // The `IsCodeGenerationFromStringsAllowed` can be refreshed by V8 according
  // to the runtime flags, propagate the value to the embedder data.
  bool is_code_generation_from_strings_allowed =
      context->IsCodeGenerationFromStringsAllowed();
  context->AllowCodeGenerationFromStrings(false);
  context->SetEmbedderData(
      ContextEmbedderIndex::kAllowCodeGenerationFromStrings,
      Boolean::New(isolate, is_code_generation_from_strings_allowed));

  if (per_process::cli_options->disable_proto == """") {
    return Just(true);
  }

  // Remove __proto__
  // https://github.com/nodejs/no...",1,1,api\environment.cc,node.InitializeContextRuntime,,false,659,736,InitializeContextRuntime,,,50,Maybe<bool> node.InitializeContextRuntime (Local<Context>)
4674,METHOD,api\environment.cc:<global>,TYPE_DECL,"Maybe<bool> InitializeBaseContextForSnapshot(Local<Context> context) {
  Isolate* isolate = context->GetIsolate();
  HandleScope handle_scope(isolate);

  // Delete `Intl.v8BreakIterator`
  // https://github.com/nodejs/node/issues/14909
  {
    Context::Scope context_scope(context);
    Local<String> intl_string = FIXED_ONE_BYTE_STRING(isolate, ""Intl"");
    Local<String> break_iter_string =
        FIXED_ONE_BYTE_STRING(isolate, ""v8BreakIterator"");

    Local<Value> intl_v;
    if (!context->Global()->Get(context, intl_string).ToLocal(&intl_v)) {
      return Nothing<bool>();
    }

    if (intl_v->IsObject() &&
        intl_v.As<Object>()->Delete(context, break_iter_string).IsNothing()) {
      return Nothing<bool>();
    }
  }
  return Just(true);
}",1,1,api\environment.cc,node.InitializeBaseContextForSnapshot,,false,738,761,InitializeBaseContextForSnapshot,,,51,Maybe<bool> node.InitializeBaseContextForSnapshot (Local<Context>)
4759,METHOD,api\environment.cc:<global>,TYPE_DECL,"Maybe<bool> InitializeMainContextForSnapshot(Local<Context> context) {
  Isolate* isolate = context->GetIsolate();
  HandleScope handle_scope(isolate);

  // Initialize the default values.
  context->SetEmbedderData(ContextEmbedderIndex::kAllowWasmCodeGeneration,
                           True(isolate));
  context->SetEmbedderData(
      ContextEmbedderIndex::kAllowCodeGenerationFromStrings, True(isolate));

  if (InitializeBaseContextForSnapshot(context).IsNothing()) {
    return Nothing<bool>();
  }
  return InitializePrimordials(context);
}",1,1,api\environment.cc,node.InitializeMainContextForSnapshot,,false,763,777,InitializeMainContextForSnapshot,,,52,Maybe<bool> node.InitializeMainContextForSnapshot (Local<Context>)
4804,METHOD,api\environment.cc:<global>,TYPE_DECL,"Maybe<bool> InitializePrimordials(Local<Context> context) {
  // Run per-context JS files.
  Isolate* isolate = context->GetIsolate();
  Context::Scope context_scope(context);
  Local<Object> exports;

  Local<String> primordials_string =
      FIXED_ONE_BYTE_STRING(isolate, ""primordials"");

  // Create primordials first and make it available to per-context scripts.
  Local<Object> primordials = Object::New(isolate);
  if (primordials->SetPrototype(context, Null(isolate)).IsNothing() ||
      !GetPerContextExports(context).ToLocal(&exports) ||
      exports->Set(context, primordials_string, primordials).IsNothing()) {
    return Nothing<bool>();
  }

  static const char* context_files[] = {""internal/per_context/primordials"",
                                        ""internal/per_context/domexception"",
                                        ""internal/per_context/messageport"",
                                        nullptr};

  // We do not have access to a per-Environment BuiltinLoa...",1,1,api\environment.cc,node.InitializePrimordials,,false,779,819,InitializePrimordials,,,53,Maybe<bool> node.InitializePrimordials (Local<Context>)
4927,METHOD,api\environment.cc:<global>,TYPE_DECL,"Maybe<bool> InitializeContext(Local<Context> context) {
  if (InitializeMainContextForSnapshot(context).IsNothing()) {
    return Nothing<bool>();
  }

  return InitializeContextRuntime(context);
}",1,1,api\environment.cc,node.InitializeContext,,false,822,828,InitializeContext,,,54,Maybe<bool> node.InitializeContext (Local<Context>)
4944,METHOD,api\environment.cc:<global>,TYPE_DECL,"uv_loop_t* GetCurrentEventLoop(Isolate* isolate) {
  HandleScope handle_scope(isolate);
  Local<Context> context = isolate->GetCurrentContext();
  if (context.IsEmpty()) return nullptr;
  Environment* env = Environment::GetCurrent(context);
  if (env == nullptr) return nullptr;
  return env->event_loop();
}",1,1,api\environment.cc,node.GetCurrentEventLoop,,false,830,837,GetCurrentEventLoop,,,55,uv_loop_t node.GetCurrentEventLoop (Isolate*)
4990,METHOD,api\environment.cc:<global>,TYPE_DECL,"void AddLinkedBinding(Environment* env, const node_module& mod) {
  CHECK_NOT_NULL(env);
  Mutex::ScopedLock lock(env->extra_linked_bindings_mutex());

  node_module* prev_tail = env->extra_linked_bindings_tail();
  env->extra_linked_bindings()->push_back(mod);
  if (prev_tail != nullptr)
    prev_tail->nm_link = &env->extra_linked_bindings()->back();
}",1,1,api\environment.cc,node.AddLinkedBinding,,false,839,847,AddLinkedBinding,,,56,"void node.AddLinkedBinding (Environment*,node_module)"
5036,METHOD,api\environment.cc:<global>,TYPE_DECL,"void AddLinkedBinding(Environment* env, const napi_module& mod) {
  node_module node_mod = napi_module_to_node_module(&mod);
  node_mod.nm_flags = NM_F_LINKED;
  AddLinkedBinding(env, node_mod);
}",1,1,api\environment.cc,node.AddLinkedBinding,,false,849,853,AddLinkedBinding,,,57,"void node.AddLinkedBinding (Environment*,napi_module)"
5056,METHOD,api\environment.cc:<global>,TYPE_DECL,"void AddLinkedBinding(Environment* env,
                      const char* name,
                      addon_context_register_func fn,
                      void* priv) {
  node_module mod = {
    NODE_MODULE_VERSION,
    NM_F_LINKED,
    nullptr,  // nm_dso_handle
    nullptr,  // nm_filename
    nullptr,  // nm_register_func
    fn,
    name,
    priv,
    nullptr   // nm_link
  };
  AddLinkedBinding(env, mod);
}",1,4,api\environment.cc,node.AddLinkedBinding,,false,855,871,AddLinkedBinding,,,58,"void node.AddLinkedBinding (Environment*,char*,addon_context_register_func,void*)"
5082,METHOD,api\environment.cc:<global>,TYPE_DECL,"void AddLinkedBinding(Environment* env,
                      const char* name,
                      napi_addon_register_func fn,
                      int32_t module_api_version) {
  node_module mod = {
      -1,           // nm_version for Node-API
      NM_F_LINKED,  // nm_flags
      nullptr,      // nm_dso_handle
      nullptr,      // nm_filename
      nullptr,      // nm_register_func
      get_node_api_context_register_func(env, name, module_api_version),
      name,                         // nm_modname
      reinterpret_cast<void*>(fn),  // nm_priv
      nullptr                       // nm_link
  };
  AddLinkedBinding(env, mod);
}",1,1,api\environment.cc,node.AddLinkedBinding,,false,873,889,AddLinkedBinding,,,59,"void node.AddLinkedBinding (Environment*,char*,napi_addon_register_func,int32_t)"
5117,METHOD,api\environment.cc:<global>,TYPE_DECL,"ThreadId AllocateEnvironmentThreadId() {
  return ThreadId { next_thread_id++ };
}",1,1,api\environment.cc,node.AllocateEnvironmentThreadId,,false,893,895,AllocateEnvironmentThreadId,,,62,ThreadId node.AllocateEnvironmentThreadId ()
5126,METHOD,api\environment.cc:<global>,TYPE_DECL,"[[noreturn]] void Exit(ExitCode exit_code) {
  exit(static_cast<int>(exit_code));
}",1,1,api\environment.cc,node.Exit,,false,897,899,Exit,,,63,void node.Exit (ExitCode)
5135,METHOD,api\environment.cc:<global>,TYPE_DECL,"void DefaultProcessExitHandlerInternal(Environment* env, ExitCode exit_code) {
  env->set_stopping(true);
  env->set_can_call_into_js(false);
  env->stop_sub_worker_contexts();
  env->isolate()->DumpAndResetStats();
  // The tracing agent could be in the process of writing data using the
  // threadpool. Stop it before shutting down libuv. The rest of the tracing
  // agent disposal will be performed in DisposePlatform().
  per_process::v8_platform.StopTracingAgent();
  // When the process exits, the tasks in the thread pool may also need to
  // access the data of V8Platform, such as trace agent, or a field
  // added in the future. So make sure the thread pool exits first.
  // And make sure V8Platform don not call into Libuv threadpool, see Dispose
  // in node_v8_platform-inl.h
  uv_library_shutdown();
  DisposePlatform();
  Exit(exit_code);
}",1,1,api\environment.cc,node.DefaultProcessExitHandlerInternal,,false,901,918,DefaultProcessExitHandlerInternal,,,64,"void node.DefaultProcessExitHandlerInternal (Environment*,ExitCode)"
5172,METHOD,api\environment.cc:<global>,TYPE_DECL,"void DefaultProcessExitHandler(Environment* env, int exit_code) {
  DefaultProcessExitHandlerInternal(env, static_cast<ExitCode>(exit_code));
}",1,1,api\environment.cc,node.DefaultProcessExitHandler,,false,920,922,DefaultProcessExitHandler,,,65,"void node.DefaultProcessExitHandler (Environment*,int)"
5183,METHOD,api\environment.cc:<global>,TYPE_DECL,"void SetProcessExitHandler(
    Environment* env, std::function<void(Environment*, ExitCode)>&& handler) {
  env->set_process_exit_handler(std::move(handler));
}",1,1,api\environment.cc,node.SetProcessExitHandler,,false,924,927,SetProcessExitHandler,,,66,"void node.SetProcessExitHandler (Environment*,ANY)"
5198,METHOD,api\environment.cc:<global>,TYPE_DECL,"void SetProcessExitHandler(Environment* env,
                           std::function<void(Environment*, int)>&& handler) {
  auto movedHandler = std::move(handler);
  env->set_process_exit_handler([=](Environment* env, ExitCode exit_code) {
    movedHandler(env, static_cast<int>(exit_code));
  });
}",1,1,api\environment.cc,node.SetProcessExitHandler,,false,929,935,SetProcessExitHandler,,,67,"void node.SetProcessExitHandler (Environment*,ANY)"
5233,METHOD,api\exceptions.cc:<global>,TYPE_DECL,<global>,1,1,api\exceptions.cc,api\exceptions.cc:<global>,,false,1,250,<global>,,,1,
5236,METHOD,api\exceptions.cc:<global>,TYPE_DECL,"Local<Value> ErrnoException(Isolate* isolate,
                            int errorno,
                            const char* syscall,
                            const char* msg,
                            const char* path) {
  Environment* env = Environment::GetCurrent(isolate);
  CHECK_NOT_NULL(env);

  Local<Value> e;
  Local<String> estring = OneByteString(isolate, errors::errno_string(errorno));
  if (msg == nullptr || msg[0] == '\0') {
    msg = strerror(errorno);
  }
  Local<String> message = OneByteString(isolate, msg);

  Local<String> cons =
      String::Concat(isolate, estring, FIXED_ONE_BYTE_STRING(isolate, "", ""));
  cons = String::Concat(isolate, cons, message);

  Local<String> path_string;
  if (path != nullptr) {
    // FIXME(bnoordhuis) It's questionable to interpret the file path as UTF-8.
    path_string = String::NewFromUtf8(isolate, path).ToLocalChecked();
  }

  if (path_string.IsEmpty() == false) {
    cons = String::Concat(isolate, cons, FIXED_ONE_BYTE_ST...",1,1,api\exceptions.cc,node.ErrnoException,,false,23,73,ErrnoException,,,1,"Local<Value> node.ErrnoException (Isolate*,int,char*,char*,char*)"
5482,METHOD,api\exceptions.cc:<global>,TYPE_DECL,"static Local<String> StringFromPath(Isolate* isolate, const char* path) {
#ifdef _WIN32
  if (strncmp(path, ""\\\\?\\UNC\\"", 8) == 0) {
    return String::Concat(
        isolate,
        FIXED_ONE_BYTE_STRING(isolate, ""\\\\""),
        String::NewFromUtf8(isolate, path + 8).ToLocalChecked());
  } else if (strncmp(path, ""\\\\?\\"", 4) == 0) {
    return String::NewFromUtf8(isolate, path + 4).ToLocalChecked();
  }
#endif

  return String::NewFromUtf8(isolate, path).ToLocalChecked();
}",1,1,api\exceptions.cc,node.StringFromPath,,false,75,88,StringFromPath,,,2,"Local<String> node.StringFromPath (Isolate*,char*)"
5498,METHOD,api\exceptions.cc:<global>,TYPE_DECL,"Local<Value> UVException(Isolate* isolate,
                         int errorno,
                         const char* syscall,
                         const char* msg,
                         const char* path,
                         const char* dest) {
  Environment* env = Environment::GetCurrent(isolate);
  CHECK_NOT_NULL(env);

  if (!msg || !msg[0])
    msg = uv_strerror(errorno);

  Local<String> js_code = OneByteString(isolate, uv_err_name(errorno));
  Local<String> js_syscall = OneByteString(isolate, syscall);
  Local<String> js_path;
  Local<String> js_dest;

  Local<String> js_msg = js_code;
  js_msg =
      String::Concat(isolate, js_msg, FIXED_ONE_BYTE_STRING(isolate, "": ""));
  js_msg = String::Concat(isolate, js_msg, OneByteString(isolate, msg));
  js_msg =
      String::Concat(isolate, js_msg, FIXED_ONE_BYTE_STRING(isolate, "", ""));
  js_msg = String::Concat(isolate, js_msg, js_syscall);

  if (path != nullptr) {
    js_path = StringFromPath(isolate, path);

    js_ms...",1,1,api\exceptions.cc,node.UVException,,false,91,152,UVException,,,3,"Local<Value> node.UVException (Isolate*,int,char*,char*,char*,char*)"
5808,METHOD,api\exceptions.cc:<global>,TYPE_DECL,"void FatalException(Isolate* isolate, const v8::TryCatch& try_catch) {
  errors::TriggerUncaughtException(isolate, try_catch);
}",1,1,api\exceptions.cc,node.FatalException,,false,246,248,FatalException,,,4,"void node.FatalException (Isolate*,ANY)"
5821,METHOD,api\hooks.cc:<global>,TYPE_DECL,"[fun, arg](Environment* env) {
    // Disallow JavaScript execution during interrupt.
    Isolate::DisallowJavascriptExecutionScope scope(
        env->isolate(),
        Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
    fun(arg);
  }",25,3,api\hooks.cc,node.RequestInterrupt.<lambda>0,,false,172,178,<lambda>0,,,1,ANY node.RequestInterrupt.<lambda>0 (Environment*)
5852,METHOD,api\hooks.cc:<global>,TYPE_DECL,<global>,1,25,env-inl.hpp,api\hooks.cc:<global>,,false,1,237,<global>,,,1,
5855,METHOD,api\hooks.cc:<global>,TYPE_DECL,"void RunAtExit(Environment* env) {
  env->RunAtExitCallbacks();
}",1,1,api\hooks.cc,node.RunAtExit,,false,20,22,RunAtExit,,,1,void node.RunAtExit (Environment*)
5864,METHOD,api\hooks.cc:<global>,TYPE_DECL,"void AtExit(Environment* env, void (*cb)(void* arg), void* arg) {
  CHECK_NOT_NULL(env);
  env->AtExit(cb, arg);
}",1,1,api\hooks.cc,node.AtExit,,false,24,27,AtExit,,,2,"void node.AtExit (Environment*,void,void*)"
5879,METHOD,api\hooks.cc:<global>,TYPE_DECL,"void EmitBeforeExit(Environment* env) {
  USE(EmitProcessBeforeExit(env));
}",1,1,api\hooks.cc,node.EmitBeforeExit,,false,29,31,EmitBeforeExit,,,3,void node.EmitBeforeExit (Environment*)
5887,METHOD,api\hooks.cc:<global>,TYPE_DECL,"Maybe<bool> EmitProcessBeforeExit(Environment* env) {
  TRACE_EVENT0(TRACING_CATEGORY_NODE1(environment), ""BeforeExit"");
  if (!env->destroy_async_id_list()->empty())
    AsyncWrap::DestroyAsyncIdsCallback(env);

  Isolate* isolate = env->isolate();
  HandleScope handle_scope(isolate);
  Context::Scope context_scope(env->context());

  if (!env->can_call_into_js()) {
    return Nothing<bool>();
  }

  Local<Integer> exit_code = Integer::New(
      isolate, static_cast<int32_t>(env->exit_code(ExitCode::kNoFailure)));

  return ProcessEmit(env, ""beforeExit"", exit_code).IsEmpty() ?
      Nothing<bool>() : Just(true);
}",1,1,api\hooks.cc,node.EmitProcessBeforeExit,,false,33,51,EmitProcessBeforeExit,,,4,Maybe<bool> node.EmitProcessBeforeExit (Environment*)
5968,METHOD,api\hooks.cc:<global>,TYPE_DECL,"static ExitCode EmitExitInternal(Environment* env) {
  return EmitProcessExitInternal(env).FromMaybe(ExitCode::kGenericUserError);
}",1,1,api\hooks.cc,node.EmitExitInternal,,false,53,55,EmitExitInternal,,,5,ExitCode node.EmitExitInternal (Environment*)
5982,METHOD,api\hooks.cc:<global>,TYPE_DECL,"int EmitExit(Environment* env) {
  return static_cast<int>(EmitExitInternal(env));
}",1,1,api\hooks.cc,node.EmitExit,,false,57,59,EmitExit,,,6,int node.EmitExit (Environment*)
5992,METHOD,api\hooks.cc:<global>,TYPE_DECL,"Maybe<ExitCode> EmitProcessExitInternal(Environment* env) {
  // process.emit('exit')
  Isolate* isolate = env->isolate();
  HandleScope handle_scope(isolate);
  Context::Scope context_scope(env->context());

  env->set_exiting(true);

  if (!env->can_call_into_js()) {
    return Nothing<ExitCode>();
  }

  Local<Integer> exit_code = Integer::New(
      isolate, static_cast<int32_t>(env->exit_code(ExitCode::kNoFailure)));

  if (ProcessEmit(env, ""exit"", exit_code).IsEmpty()) {
    return Nothing<ExitCode>();
  }
  // Reload exit code, it may be changed by `emit('exit')`
  return Just(env->exit_code(ExitCode::kNoFailure));
}",1,1,api\hooks.cc,node.EmitProcessExitInternal,,false,61,81,EmitProcessExitInternal,,,7,Maybe<ExitCode> node.EmitProcessExitInternal (Environment*)
6067,METHOD,api\hooks.cc:<global>,TYPE_DECL,"Maybe<int> EmitProcessExit(Environment* env) {
  Maybe<ExitCode> result = EmitProcessExitInternal(env);
  if (result.IsNothing()) {
    return Nothing<int>();
  }
  return Just(static_cast<int>(result.FromJust()));
}",1,1,api\hooks.cc,node.EmitProcessExit,,false,83,89,EmitProcessExit,,,8,Maybe<int> node.EmitProcessExit (Environment*)
6096,METHOD,api\hooks.cc:<global>,TYPE_DECL,typedef void (*CleanupHook)(void* arg);,14,38,api\hooks.cc,node.CleanupHook,,false,91,91,CleanupHook,,,9,void node.CleanupHook (void*)
6101,METHOD,api\hooks.cc:<global>,TYPE_DECL,"typedef void (*AsyncCleanupHook)(void* arg, void(*)(void*), void*);",14,66,api\hooks.cc,node.AsyncCleanupHook,,false,92,92,AsyncCleanupHook,,,10,"void node.AsyncCleanupHook (void*,void,void*)"
6114,METHOD,<empty>,<empty>,<empty>,1,,api\hooks.cc,node.AsyncCleanupHookInfo:<clinit>,,false,94,,<clinit>,,,6,
6123,METHOD,api\hooks.cc:<global>,TYPE_DECL,void DeleteACHHandle::operator ()(ACHHandle* handle) const { delete handle; },1,77,api\hooks.cc,node.DeleteACHHandle.operator (),,false,116,116,operator (),,,13,void node.DeleteACHHandle.operator () (ACHHandle*)
6130,METHOD,api\hooks.cc:<global>,TYPE_DECL,"void AddEnvironmentCleanupHook(Isolate* isolate,
                               CleanupHook fun,
                               void* arg) {
  Environment* env = Environment::GetCurrent(isolate);
  CHECK_NOT_NULL(env);
  env->AddCleanupHook(fun, arg);
}",1,1,api\hooks.cc,node.AddEnvironmentCleanupHook,,false,118,124,AddEnvironmentCleanupHook,,,14,"void node.AddEnvironmentCleanupHook (Isolate*,CleanupHook,void*)"
6153,METHOD,api\hooks.cc:<global>,TYPE_DECL,"void RemoveEnvironmentCleanupHook(Isolate* isolate,
                                  CleanupHook fun,
                                  void* arg) {
  Environment* env = Environment::GetCurrent(isolate);
  CHECK_NOT_NULL(env);
  env->RemoveCleanupHook(fun, arg);
}",1,1,api\hooks.cc,node.RemoveEnvironmentCleanupHook,,false,126,132,RemoveEnvironmentCleanupHook,,,15,"void node.RemoveEnvironmentCleanupHook (Isolate*,CleanupHook,void*)"
6176,METHOD,api\hooks.cc:<global>,TYPE_DECL,"static void FinishAsyncCleanupHook(void* arg) {
  AsyncCleanupHookInfo* info = static_cast<AsyncCleanupHookInfo*>(arg);
  std::shared_ptr<AsyncCleanupHookInfo> keep_alive = info->self;

  info->env->DecreaseWaitingRequestCounter();
  info->self.reset();
}",1,1,api\hooks.cc,node.FinishAsyncCleanupHook,,false,134,140,FinishAsyncCleanupHook,,,16,void node.FinishAsyncCleanupHook (void*)
6205,METHOD,api\hooks.cc:<global>,TYPE_DECL,"static void RunAsyncCleanupHook(void* arg) {
  AsyncCleanupHookInfo* info = static_cast<AsyncCleanupHookInfo*>(arg);
  info->env->IncreaseWaitingRequestCounter();
  info->started = true;
  info->fun(info->arg, FinishAsyncCleanupHook, info);
}",1,1,api\hooks.cc,node.RunAsyncCleanupHook,,false,142,147,RunAsyncCleanupHook,,,17,void node.RunAsyncCleanupHook (void*)
6236,METHOD,api\hooks.cc:<global>,TYPE_DECL,"ACHHandle* AddEnvironmentCleanupHookInternal(
    Isolate* isolate,
    AsyncCleanupHook fun,
    void* arg) {
  Environment* env = Environment::GetCurrent(isolate);
  CHECK_NOT_NULL(env);
  auto info = std::make_shared<AsyncCleanupHookInfo>();
  info->env = env;
  info->fun = fun;
  info->arg = arg;
  info->self = info;
  env->AddCleanupHook(RunAsyncCleanupHook, info.get());
  return new ACHHandle { info };
}",1,1,api\hooks.cc,node.AddEnvironmentCleanupHookInternal,,false,149,162,AddEnvironmentCleanupHookInternal,,,18,"ACHHandle node.AddEnvironmentCleanupHookInternal (Isolate*,AsyncCleanupHook,void*)"
6292,METHOD,api\hooks.cc:<global>,TYPE_DECL,"void RemoveEnvironmentCleanupHookInternal(
    ACHHandle* handle) {
  if (handle->info->started) return;
  handle->info->self.reset();
  handle->info->env->RemoveCleanupHook(RunAsyncCleanupHook, handle->info.get());
}",1,1,api\hooks.cc,node.RemoveEnvironmentCleanupHookInternal,,false,164,169,RemoveEnvironmentCleanupHookInternal,,,19,void node.RemoveEnvironmentCleanupHookInternal (ACHHandle*)
6328,METHOD,api\hooks.cc:<global>,TYPE_DECL,"void RequestInterrupt(Environment* env, void (*fun)(void* arg), void* arg) {
  env->RequestInterrupt([fun, arg](Environment* env) {
    // Disallow JavaScript execution during interrupt.
    Isolate::DisallowJavascriptExecutionScope scope(
        env->isolate(),
        Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
    fun(arg);
  });
}",1,1,api\hooks.cc,node.RequestInterrupt,,false,171,179,RequestInterrupt,,,20,"void node.RequestInterrupt (Environment*,void,void*)"
6338,METHOD,api\hooks.cc:<global>,TYPE_DECL,"async_id AsyncHooksGetExecutionAsyncId(Isolate* isolate) {
  Environment* env = Environment::GetCurrent(isolate);
  if (env == nullptr) return -1;
  return env->execution_async_id();
}",1,1,api\hooks.cc,node.AsyncHooksGetExecutionAsyncId,,false,181,185,AsyncHooksGetExecutionAsyncId,,,21,async_id node.AsyncHooksGetExecutionAsyncId (Isolate*)
6364,METHOD,api\hooks.cc:<global>,TYPE_DECL,"async_id AsyncHooksGetTriggerAsyncId(Isolate* isolate) {
  Environment* env = Environment::GetCurrent(isolate);
  if (env == nullptr) return -1;
  return env->trigger_async_id();
}",1,1,api\hooks.cc,node.AsyncHooksGetTriggerAsyncId,,false,187,191,AsyncHooksGetTriggerAsyncId,,,22,async_id node.AsyncHooksGetTriggerAsyncId (Isolate*)
6390,METHOD,api\hooks.cc:<global>,TYPE_DECL,"async_context EmitAsyncInit(Isolate* isolate,
                            Local<Object> resource,
                            const char* name,
                            async_id trigger_async_id) {
  HandleScope handle_scope(isolate);
  Local<String> type =
      String::NewFromUtf8(isolate, name, NewStringType::kInternalized)
          .ToLocalChecked();
  return EmitAsyncInit(isolate, resource, type, trigger_async_id);
}",1,1,api\hooks.cc,node.EmitAsyncInit,,false,194,203,EmitAsyncInit,,,23,"async_context node.EmitAsyncInit (Isolate*,Local<Object>,char*,async_id)"
6425,METHOD,api\hooks.cc:<global>,TYPE_DECL,"async_context EmitAsyncInit(Isolate* isolate,
                            Local<Object> resource,
                            Local<String> name,
                            async_id trigger_async_id) {
  DebugSealHandleScope handle_scope(isolate);
  Environment* env = Environment::GetCurrent(isolate);
  CHECK_NOT_NULL(env);

  // Initialize async context struct
  if (trigger_async_id == -1)
    trigger_async_id = env->get_default_trigger_async_id();

  async_context context = {
    env->new_async_id(),  // async_id_
    trigger_async_id  // trigger_async_id_
  };

  // Run init hooks
  AsyncWrap::EmitAsyncInit(env, resource, name, context.async_id,
                           context.trigger_async_id);

  return context;
}",1,1,api\hooks.cc,node.EmitAsyncInit,,false,205,227,EmitAsyncInit,,,24,"async_context node.EmitAsyncInit (Isolate*,Local<Object>,Local<String>,async_id)"
6482,METHOD,api\hooks.cc:<global>,TYPE_DECL,"void EmitAsyncDestroy(Isolate* isolate, async_context asyncContext) {
  EmitAsyncDestroy(Environment::GetCurrent(isolate), asyncContext);
}",1,1,api\hooks.cc,node.EmitAsyncDestroy,,false,229,231,EmitAsyncDestroy,,,25,"void node.EmitAsyncDestroy (Isolate*,async_context)"
6495,METHOD,api\hooks.cc:<global>,TYPE_DECL,"void EmitAsyncDestroy(Environment* env, async_context asyncContext) {
  AsyncWrap::EmitDestroy(env, asyncContext.async_id);
}",1,1,api\hooks.cc,node.EmitAsyncDestroy,,false,233,235,EmitAsyncDestroy,,,26,"void node.EmitAsyncDestroy (Environment*,async_context)"
6516,METHOD,api\utils.cc:<global>,TYPE_DECL,<global>,1,59,node.hpp,api\utils.cc:<global>,,false,1,169,<global>,,,1,
6519,METHOD,api\utils.cc:<global>,TYPE_DECL,"const char* signo_string(int signo) {
#define SIGNO_CASE(e)                                                          \
  case e:                                                                      \
    return #e;
  switch (signo) {
#ifdef SIGHUP
    SIGNO_CASE(SIGHUP);
#endif

#ifdef SIGINT
    SIGNO_CASE(SIGINT);
#endif

#ifdef SIGQUIT
    SIGNO_CASE(SIGQUIT);
#endif

#ifdef SIGILL
    SIGNO_CASE(SIGILL);
#endif

#ifdef SIGTRAP
    SIGNO_CASE(SIGTRAP);
#endif

#ifdef SIGABRT
    SIGNO_CASE(SIGABRT);
#endif

#ifdef SIGIOT
#if SIGABRT != SIGIOT
    SIGNO_CASE(SIGIOT);
#endif
#endif

#ifdef SIGBUS
    SIGNO_CASE(SIGBUS);
#endif

#ifdef SIGFPE
    SIGNO_CASE(SIGFPE);
#endif

#ifdef SIGKILL
    SIGNO_CASE(SIGKILL);
#endif

#ifdef SIGUSR1
    SIGNO_CASE(SIGUSR1);
#endif

#ifdef SIGSEGV
    SIGNO_CASE(SIGSEGV);
#endif

#ifdef SIGUSR2
    SIGNO_CASE(SIGUSR2);
#endif

#ifdef SIGPIPE
    SIGNO_CASE(SIGPIPE);
#endif

#ifdef SIGALRM
    SIGNO_CASE(SIGALRM);
#endif

    SIGNO_CASE(SIGTERM);

...",1,4,api\utils.cc,node.signo_string,,false,7,167,signo_string,,,1,const char* node.signo_string (int)
6545,METHOD,async_wrap-inl.hpp:<global>,TYPE_DECL,<global>,1,32,async_wrap-inl.hpp,async_wrap-inl.hpp:<global>,,false,1,93,<global>,,,1,
6548,METHOD,async_wrap.cc:<global>,TYPE_DECL,"[](void* arg) {
          DestroyAsyncIdsCallback(static_cast<Environment*>(arg));
        }",9,9,async_wrap.cc,node.AsyncWrap.EmitDestroy..<lambda>1,,false,569,571,<lambda>1,,,1,ANY node.AsyncWrap.EmitDestroy..<lambda>1 (void*)
6559,METHOD,async_wrap.cc:<global>,TYPE_DECL,"[](Environment* env) {
      env->context()->GetMicrotaskQueue()->EnqueueMicrotask(
        env->isolate(),
        [](void* arg) {
          DestroyAsyncIdsCallback(static_cast<Environment*>(arg));
        }, env);
      }",27,7,async_wrap.cc,node.AsyncWrap.EmitDestroy.<lambda>0,,false,566,572,<lambda>0,,,1,ANY node.AsyncWrap.EmitDestroy.<lambda>0 (Environment*)
6599,METHOD,async_wrap.cc:<global>,TYPE_DECL,<global>,1,1,async_wrap.cc,async_wrap.cc:<global>,,false,1,724,<global>,,,1,
6609,METHOD,async_wrap.cc:<global>,TYPE_DECL,"void AsyncWrap::DestroyAsyncIdsCallback(Environment* env) {
  Local<Function> fn = env->async_hooks_destroy_function();

  TryCatchScope try_catch(env, TryCatchScope::CatchMode::kFatal);

  do {
    std::vector<double> destroy_async_id_list;
    destroy_async_id_list.swap(*env->destroy_async_id_list());
    if (!env->can_call_into_js()) return;
    for (auto async_id : destroy_async_id_list) {
      // Want each callback to be cleaned up after itself, instead of cleaning
      // them all up after the while() loop completes.
      HandleScope scope(env->isolate());
      Local<Value> async_id_value = Number::New(env->isolate(), async_id);
      MaybeLocal<Value> ret = fn->Call(
          env->context(), Undefined(env->isolate()), 1, &async_id_value);

      if (ret.IsEmpty())
        return;
    }
  } while (!env->destroy_async_id_list()->empty());
}",1,1,async_wrap.cc,node.AsyncWrap.DestroyAsyncIdsCallback,,false,67,88,DestroyAsyncIdsCallback,,,3,void node.AsyncWrap.DestroyAsyncIdsCallback (Environment*)
6714,METHOD,async_wrap.cc:<global>,TYPE_DECL,"void Emit(Environment* env, double async_id, AsyncHooks::Fields type,
          Local<Function> fn) {
  AsyncHooks* async_hooks = env->async_hooks();

  if (async_hooks->fields()[type] == 0 || !env->can_call_into_js())
    return;

  HandleScope handle_scope(env->isolate());
  Local<Value> async_id_value = Number::New(env->isolate(), async_id);
  TryCatchScope try_catch(env, TryCatchScope::CatchMode::kFatal);
  USE(fn->Call(env->context(), Undefined(env->isolate()), 1, &async_id_value));
}",1,1,async_wrap.cc,node.Emit,,false,90,101,Emit,,,4,"void node.Emit (Environment*,double,ANY,Local<Function>)"
6792,METHOD,async_wrap.cc:<global>,TYPE_DECL,"void AsyncWrap::EmitPromiseResolve(Environment* env, double async_id) {
  Emit(env, async_id, AsyncHooks::kPromiseResolve,
       env->async_hooks_promise_resolve_function());
}",1,1,async_wrap.cc,node.AsyncWrap.EmitPromiseResolve,,false,104,107,EmitPromiseResolve,,,5,"void node.AsyncWrap.EmitPromiseResolve (Environment*,double)"
6808,METHOD,async_wrap.cc:<global>,TYPE_DECL,"void AsyncWrap::EmitTraceEventBefore() {
  switch (provider_type()) {
#define V(PROVIDER)                                                           \
    case PROVIDER_ ## PROVIDER:                                               \
      TRACE_EVENT_NESTABLE_ASYNC_BEGIN0(                                      \
        TRACING_CATEGORY_NODE1(async_hooks),                                  \
        #PROVIDER ""_CALLBACK"", static_cast<int64_t>(get_async_id()));         \
      break;
    NODE_ASYNC_PROVIDER_TYPES(V)
#undef V
    default:
      UNREACHABLE();
  }
}",1,1,async_wrap.cc,node.AsyncWrap.EmitTraceEventBefore,,false,110,123,EmitTraceEventBefore,,,6,void node.AsyncWrap.EmitTraceEventBefore ()
6819,METHOD,async_wrap.cc:<global>,TYPE_DECL,"void AsyncWrap::EmitBefore(Environment* env, double async_id) {
  Emit(env, async_id, AsyncHooks::kBefore,
       env->async_hooks_before_function());
}",1,1,async_wrap.cc,node.AsyncWrap.EmitBefore,,false,126,129,EmitBefore,,,7,"void node.AsyncWrap.EmitBefore (Environment*,double)"
6835,METHOD,async_wrap.cc:<global>,TYPE_DECL,"void AsyncWrap::EmitTraceEventAfter(ProviderType type, double async_id) {
  switch (type) {
#define V(PROVIDER)                                                           \
    case PROVIDER_ ## PROVIDER:                                               \
      TRACE_EVENT_NESTABLE_ASYNC_END0(                                        \
        TRACING_CATEGORY_NODE1(async_hooks),                                  \
        #PROVIDER ""_CALLBACK"", static_cast<int64_t>(async_id));               \
      break;
    NODE_ASYNC_PROVIDER_TYPES(V)
#undef V
    default:
      UNREACHABLE();
  }
}",1,1,async_wrap.cc,node.AsyncWrap.EmitTraceEventAfter,,false,132,145,EmitTraceEventAfter,,,8,"void node.AsyncWrap.EmitTraceEventAfter (ProviderType,double)"
6848,METHOD,async_wrap.cc:<global>,TYPE_DECL,"void AsyncWrap::EmitAfter(Environment* env, double async_id) {
  // If the user's callback failed then the after() hooks will be called at the
  // end of _fatalException().
  Emit(env, async_id, AsyncHooks::kAfter,
       env->async_hooks_after_function());
}",1,1,async_wrap.cc,node.AsyncWrap.EmitAfter,,false,148,153,EmitAfter,,,9,"void node.AsyncWrap.EmitAfter (Environment*,double)"
6864,METHOD,async_wrap.cc:<global>,TYPE_DECL,"static void SetupHooks(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsObject());

  // All of init, before, after, destroy, and promise_resolve are supplied by
  // async_hooks internally, so this should only ever be called once. At which
  // time all the functions should be set. Detect this by checking if
  // init !IsEmpty().
  CHECK(env->async_hooks_init_function().IsEmpty());

  Local<Object> fn_obj = args[0].As<Object>();

#define SET_HOOK_FN(name)                                                      \
  do {                                                                         \
    Local<Value> v =                                                           \
        fn_obj->Get(env->context(),                                            \
                    FIXED_ONE_BYTE_STRING(env->isolate(), #name))              \
            .ToLocalChecked();                                                 \
    CHECK(...",1,2,async_wrap.cc,node.SetupHooks,,false,155,184,SetupHooks,,,10,void node.SetupHooks (FunctionCallbackInfo<Value>)
7109,METHOD,async_wrap.cc:<global>,TYPE_DECL,"static void SetPromiseHooks(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  env->ResetPromiseHooks(
      args[0]->IsFunction() ? args[0].As<Function>() : Local<Function>(),
      args[1]->IsFunction() ? args[1].As<Function>() : Local<Function>(),
      args[2]->IsFunction() ? args[2].As<Function>() : Local<Function>(),
      args[3]->IsFunction() ? args[3].As<Function>() : Local<Function>());
}",1,1,async_wrap.cc,node.SetPromiseHooks,,false,186,194,SetPromiseHooks,,,11,void node.SetPromiseHooks (FunctionCallbackInfo<Value>)
7187,METHOD,async_wrap.cc:<global>,TYPE_DECL,"static void DestroyParamCleanupHook(void* ptr) {
  delete static_cast<DestroyParam*>(ptr);
}",1,1,async_wrap.cc,node.DestroyParamCleanupHook,,false,204,206,DestroyParamCleanupHook,,,13,void node.DestroyParamCleanupHook (void*)
7196,METHOD,async_wrap.cc:<global>,TYPE_DECL,"void AsyncWrap::WeakCallback(const WeakCallbackInfo<DestroyParam>& info) {
  HandleScope scope(info.GetIsolate());

  std::unique_ptr<DestroyParam> p{info.GetParameter()};
  Local<Object> prop_bag = PersistentToLocal::Default(info.GetIsolate(),
                                                      p->propBag);
  Local<Value> val;

  p->env->RemoveCleanupHook(DestroyParamCleanupHook, p.get());

  if (!prop_bag.IsEmpty() &&
      !prop_bag->Get(p->env->context(), p->env->destroyed_string())
        .ToLocal(&val)) {
    return;
  }

  if (val.IsEmpty() || val->IsFalse()) {
    AsyncWrap::EmitDestroy(p->env, p->asyncId);
  }
  // unique_ptr goes out of scope here and pointer is deleted.
}",1,1,async_wrap.cc,node.AsyncWrap.WeakCallback,,false,208,228,WeakCallback,,,14,void node.AsyncWrap.WeakCallback (WeakCallbackInfo<DestroyParam>)
7304,METHOD,async_wrap.cc:<global>,TYPE_DECL,"static void RegisterDestroyHook(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsNumber());
  CHECK(args.Length() == 2 || args[2]->IsObject());

  Isolate* isolate = args.GetIsolate();
  DestroyParam* p = new DestroyParam();
  p->asyncId = args[1].As<Number>()->Value();
  p->env = Environment::GetCurrent(args);
  p->target.Reset(isolate, args[0].As<Object>());
  if (args.Length() > 2) {
    p->propBag.Reset(isolate, args[2].As<Object>());
  }
  p->target.SetWeak(p, AsyncWrap::WeakCallback, WeakCallbackType::kParameter);
  p->env->AddCleanupHook(DestroyParamCleanupHook, p);
}",1,1,async_wrap.cc,node.RegisterDestroyHook,,false,231,246,RegisterDestroyHook,,,15,void node.RegisterDestroyHook (FunctionCallbackInfo<Value>)
7426,METHOD,async_wrap.cc:<global>,TYPE_DECL,"void AsyncWrap::GetAsyncId(const FunctionCallbackInfo<Value>& args) {
  AsyncWrap* wrap;
  args.GetReturnValue().Set(kInvalidAsyncId);
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  args.GetReturnValue().Set(wrap->get_async_id());
}",1,1,async_wrap.cc,node.AsyncWrap.GetAsyncId,,false,248,253,GetAsyncId,,,16,void node.AsyncWrap.GetAsyncId (FunctionCallbackInfo<Value>)
7458,METHOD,async_wrap.cc:<global>,TYPE_DECL,"void AsyncWrap::PushAsyncContext(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  // No need for CHECK(IsNumber()) on args because if FromJust() doesn't fail
  // then the checks in push_async_ids() and pop_async_id() will.
  double async_id = args[0]->NumberValue(env->context()).FromJust();
  double trigger_async_id = args[1]->NumberValue(env->context()).FromJust();
  env->async_hooks()->push_async_context(async_id, trigger_async_id, {});
}",1,1,async_wrap.cc,node.AsyncWrap.PushAsyncContext,,false,256,263,PushAsyncContext,,,17,void node.AsyncWrap.PushAsyncContext (FunctionCallbackInfo<Value>)
7513,METHOD,async_wrap.cc:<global>,TYPE_DECL,"void AsyncWrap::PopAsyncContext(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  double async_id = args[0]->NumberValue(env->context()).FromJust();
  args.GetReturnValue().Set(env->async_hooks()->pop_async_context(async_id));
}",1,1,async_wrap.cc,node.AsyncWrap.PopAsyncContext,,false,266,270,PopAsyncContext,,,18,void node.AsyncWrap.PopAsyncContext (FunctionCallbackInfo<Value>)
7557,METHOD,async_wrap.cc:<global>,TYPE_DECL,"void AsyncWrap::ExecutionAsyncResource(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  uint32_t index;
  if (!args[0]->Uint32Value(env->context()).To(&index)) return;
  args.GetReturnValue().Set(
      env->async_hooks()->native_execution_async_resource(index));
}",1,1,async_wrap.cc,node.AsyncWrap.ExecutionAsyncResource,,false,273,280,ExecutionAsyncResource,,,19,void node.AsyncWrap.ExecutionAsyncResource (FunctionCallbackInfo<Value>)
7605,METHOD,async_wrap.cc:<global>,TYPE_DECL,"void AsyncWrap::ClearAsyncIdStack(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  env->async_hooks()->clear_async_id_stack();
}",1,1,async_wrap.cc,node.AsyncWrap.ClearAsyncIdStack,,false,283,286,ClearAsyncIdStack,,,20,void node.AsyncWrap.ClearAsyncIdStack (FunctionCallbackInfo<Value>)
7625,METHOD,async_wrap.cc:<global>,TYPE_DECL,"void AsyncWrap::AsyncReset(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsObject());

  AsyncWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  Local<Object> resource = args[0].As<Object>();
  double execution_async_id =
      args[1]->IsNumber() ? args[1].As<Number>()->Value() : kInvalidAsyncId;
  wrap->AsyncReset(resource, execution_async_id);
}",1,1,async_wrap.cc,node.AsyncWrap.AsyncReset,,false,289,299,AsyncReset,,,21,void node.AsyncWrap.AsyncReset (FunctionCallbackInfo<Value>)
7683,METHOD,async_wrap.cc:<global>,TYPE_DECL,"void AsyncWrap::GetProviderType(const FunctionCallbackInfo<Value>& args) {
  AsyncWrap* wrap;
  args.GetReturnValue().Set(AsyncWrap::PROVIDER_NONE);
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  args.GetReturnValue().Set(wrap->provider_type());
}",1,1,async_wrap.cc,node.AsyncWrap.GetProviderType,,false,302,307,GetProviderType,,,22,void node.AsyncWrap.GetProviderType (FunctionCallbackInfo<Value>)
7717,METHOD,async_wrap.cc:<global>,TYPE_DECL,"void AsyncWrap::EmitDestroy(bool from_gc) {
  AsyncWrap::EmitDestroy(env(), async_id_);
  // Ensure no double destroy is emitted via AsyncReset().
  async_id_ = kInvalidAsyncId;

  if (!persistent().IsEmpty() && !from_gc) {
    HandleScope handle_scope(env()->isolate());
    USE(object()->Set(env()->context(), env()->resource_symbol(), object()));
  }
}",1,1,async_wrap.cc,node.AsyncWrap.EmitDestroy,,false,310,319,EmitDestroy,,,23,void node.AsyncWrap.EmitDestroy (bool)
7748,METHOD,async_wrap.cc:<global>,TYPE_DECL,"void AsyncWrap::QueueDestroyAsyncId(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsNumber());
  AsyncWrap::EmitDestroy(
      Environment::GetCurrent(args),
      args[0].As<Number>()->Value());
}",1,1,async_wrap.cc,node.AsyncWrap.QueueDestroyAsyncId,,false,321,326,QueueDestroyAsyncId,,,24,void node.AsyncWrap.QueueDestroyAsyncId (FunctionCallbackInfo<Value>)
7778,METHOD,async_wrap.cc:<global>,TYPE_DECL,"void AsyncWrap::SetCallbackTrampoline(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  if (args[0]->IsFunction()) {
    env->set_async_hooks_callback_trampoline(args[0].As<Function>());
  } else {
    env->set_async_hooks_callback_trampoline(Local<Function>());
  }
}",1,1,async_wrap.cc,node.AsyncWrap.SetCallbackTrampoline,,false,328,336,SetCallbackTrampoline,,,25,void node.AsyncWrap.SetCallbackTrampoline (FunctionCallbackInfo<Value>)
7816,METHOD,async_wrap.cc:<global>,TYPE_DECL,"Local<FunctionTemplate> AsyncWrap::GetConstructorTemplate(
    IsolateData* isolate_data) {
  Local<FunctionTemplate> tmpl = isolate_data->async_wrap_ctor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = isolate_data->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->SetClassName(
        FIXED_ONE_BYTE_STRING(isolate_data->isolate(), ""AsyncWrap""));
    SetProtoMethod(isolate, tmpl, ""getAsyncId"", AsyncWrap::GetAsyncId);
    SetProtoMethod(isolate, tmpl, ""asyncReset"", AsyncWrap::AsyncReset);
    SetProtoMethod(
        isolate, tmpl, ""getProviderType"", AsyncWrap::GetProviderType);
    isolate_data->set_async_wrap_ctor_template(tmpl);
  }
  return tmpl;
}",1,1,async_wrap.cc,node.AsyncWrap.GetConstructorTemplate,,false,338,353,GetConstructorTemplate,,,26,Local<FunctionTemplate> node.AsyncWrap.GetConstructorTemplate (IsolateData*)
7887,METHOD,async_wrap.cc:<global>,TYPE_DECL,"void AsyncWrap::CreatePerIsolateProperties(IsolateData* isolate_data,
                                           Local<ObjectTemplate> target) {
  Isolate* isolate = isolate_data->isolate();

  SetMethod(isolate, target, ""setupHooks"", SetupHooks);
  SetMethod(isolate, target, ""setCallbackTrampoline"", SetCallbackTrampoline);
  SetMethod(isolate, target, ""pushAsyncContext"", PushAsyncContext);
  SetMethod(isolate, target, ""popAsyncContext"", PopAsyncContext);
  SetMethod(isolate, target, ""executionAsyncResource"", ExecutionAsyncResource);
  SetMethod(isolate, target, ""clearAsyncIdStack"", ClearAsyncIdStack);
  SetMethod(isolate, target, ""queueDestroyAsyncId"", QueueDestroyAsyncId);
  SetMethod(isolate, target, ""setPromiseHooks"", SetPromiseHooks);
  SetMethod(isolate, target, ""registerDestroyHook"", RegisterDestroyHook);
  AsyncWrap::GetConstructorTemplate(isolate_data);
}",1,1,async_wrap.cc,node.AsyncWrap.CreatePerIsolateProperties,,false,355,369,CreatePerIsolateProperties,,,27,"void node.AsyncWrap.CreatePerIsolateProperties (IsolateData*,Local<ObjectTemplate>)"
7950,METHOD,async_wrap.cc:<global>,TYPE_DECL,"void AsyncWrap::CreatePerContextProperties(Local<Object> target,
                                           Local<Value> unused,
                                           Local<Context> context,
                                           void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();
  HandleScope scope(isolate);

  PropertyAttribute ReadOnlyDontDelete =
      static_cast<PropertyAttribute>(ReadOnly | DontDelete);

#define FORCE_SET_TARGET_FIELD(obj, str, field)                               \
  (obj)->DefineOwnProperty(context,                                           \
                           FIXED_ONE_BYTE_STRING(isolate, str),               \
                           field,                                             \
                           ReadOnlyDontDelete).FromJust()

  // Attach the uint32_t[] where each slot contains the count of the number of
  // callbacks waiting to be called on a particular event. I...",1,2,async_wrap.cc,node.AsyncWrap.CreatePerContextProperties,,false,371,456,CreatePerContextProperties,,,28,"void node.AsyncWrap.CreatePerContextProperties (Local<Object>,Local<Value>,Local<Context>,void*)"
8488,METHOD,async_wrap.cc:<global>,TYPE_DECL,"void AsyncWrap::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(SetupHooks);
  registry->Register(SetCallbackTrampoline);
  registry->Register(PushAsyncContext);
  registry->Register(PopAsyncContext);
  registry->Register(ExecutionAsyncResource);
  registry->Register(ClearAsyncIdStack);
  registry->Register(QueueDestroyAsyncId);
  registry->Register(SetPromiseHooks);
  registry->Register(RegisterDestroyHook);
  registry->Register(AsyncWrap::GetAsyncId);
  registry->Register(AsyncWrap::AsyncReset);
  registry->Register(AsyncWrap::GetProviderType);
}",1,1,async_wrap.cc,node.AsyncWrap.RegisterExternalReferences,,false,458,472,RegisterExternalReferences,,,29,void node.AsyncWrap.RegisterExternalReferences (ExternalReferenceRegistry*)
8559,METHOD,async_wrap.cc:<global>,TYPE_DECL,"AsyncWrap::AsyncWrap(Environment* env,
                     Local<Object> object,
                     ProviderType provider,
                     double execution_async_id)
    : AsyncWrap(env, object, provider, execution_async_id, false) {}",1,68,async_wrap.cc,node.AsyncWrap.AsyncWrap,,false,474,478,AsyncWrap,,,30,"ANY node.AsyncWrap.AsyncWrap (Environment*,Local<Object>,ProviderType,double)"
8567,METHOD,async_wrap.cc:<global>,TYPE_DECL,"AsyncWrap::AsyncWrap(Environment* env,
                     Local<Object> object,
                     ProviderType provider,
                     double execution_async_id,
                     bool silent)
    : AsyncWrap(env, object) {
  CHECK_NE(provider, PROVIDER_NONE);
  provider_type_ = provider;

  // Use AsyncReset() call to execute the init() callbacks.
  AsyncReset(object, execution_async_id, silent);
  init_hook_ran_ = true;
}",1,1,async_wrap.cc,node.AsyncWrap.AsyncWrap,,false,480,492,AsyncWrap,,,31,"ANY node.AsyncWrap.AsyncWrap (Environment*,Local<Object>,ProviderType,double,bool)"
8589,METHOD,async_wrap.cc:<global>,TYPE_DECL,"AsyncWrap::AsyncWrap(Environment* env,
                     Local<Object> object,
                     ProviderType provider,
                     double execution_async_id,
                     double trigger_async_id)
    : AsyncWrap(env, object, provider, execution_async_id, true) {
  trigger_async_id_ = trigger_async_id;
}",1,1,async_wrap.cc,node.AsyncWrap.AsyncWrap,,false,494,501,AsyncWrap,,,32,"ANY node.AsyncWrap.AsyncWrap (Environment*,Local<Object>,ProviderType,double,double)"
8601,METHOD,async_wrap.cc:<global>,TYPE_DECL,"AsyncWrap::AsyncWrap(Environment* env, Local<Object> object)
  : BaseObject(env, object) {
}",1,1,async_wrap.cc,node.AsyncWrap.AsyncWrap,,false,503,505,AsyncWrap,,,33,"ANY node.AsyncWrap.AsyncWrap (Environment*,Local<Object>)"
8607,METHOD,async_wrap.cc:<global>,TYPE_DECL,"bool AsyncWrap::IsDoneInitializing() const {
  return init_hook_ran_;
}",1,1,async_wrap.cc,node.AsyncWrap.IsDoneInitializing,,false,528,530,IsDoneInitializing,,,34,bool node.AsyncWrap.IsDoneInitializing ()
8613,METHOD,async_wrap.cc:<global>,TYPE_DECL,"AsyncWrap::~AsyncWrap() {
  EmitTraceEventDestroy();
  EmitDestroy(true /* from gc */);
}",1,1,async_wrap.cc,node.AsyncWrap.~AsyncWrap,,false,532,535,~AsyncWrap,,,35,ANY node.AsyncWrap.~AsyncWrap ()
8620,METHOD,async_wrap.cc:<global>,TYPE_DECL,"void AsyncWrap::EmitTraceEventDestroy() {
  switch (provider_type()) {
  #define V(PROVIDER)                                                         \
    case PROVIDER_ ## PROVIDER:                                               \
      TRACE_EVENT_NESTABLE_ASYNC_END0(                                        \
        TRACING_CATEGORY_NODE1(async_hooks),                                  \
        #PROVIDER, static_cast<int64_t>(get_async_id()));                     \
      break;
    NODE_ASYNC_PROVIDER_TYPES(V)
  #undef V
    default:
      UNREACHABLE();
  }
}",1,1,async_wrap.cc,node.AsyncWrap.EmitTraceEventDestroy,,false,537,550,EmitTraceEventDestroy,,,36,void node.AsyncWrap.EmitTraceEventDestroy ()
8631,METHOD,async_wrap.cc:<global>,TYPE_DECL,"void AsyncWrap::EmitDestroy(Environment* env, double async_id) {
  if (env->async_hooks()->fields()[AsyncHooks::kDestroy] == 0 ||
      !env->can_call_into_js()) {
    return;
  }

  if (env->destroy_async_id_list()->empty()) {
    env->SetImmediate(&DestroyAsyncIdsCallback, CallbackFlags::kUnrefed);
  }

  // If the list gets very large empty it faster using a Microtask.
  // Microtasks can't be added in GC context therefore we use an
  // interrupt to get this Microtask scheduled as fast as possible.
  if (env->destroy_async_id_list()->size() == 16384) {
    env->RequestInterrupt([](Environment* env) {
      env->context()->GetMicrotaskQueue()->EnqueueMicrotask(
        env->isolate(),
        [](void* arg) {
          DestroyAsyncIdsCallback(static_cast<Environment*>(arg));
        }, env);
      });
  }

  env->destroy_async_id_list()->push_back(async_id);
}",1,1,async_wrap.cc,node.AsyncWrap.EmitDestroy,,false,552,576,EmitDestroy,,,37,"void node.AsyncWrap.EmitDestroy (Environment*,double)"
8700,METHOD,async_wrap.cc:<global>,TYPE_DECL,"void AsyncWrap::AsyncReset(Local<Object> resource, double execution_async_id,
                           bool silent) {
  CHECK_NE(provider_type(), PROVIDER_NONE);

  if (async_id_ != kInvalidAsyncId) {
    // This instance was in use before, we have already emitted an init with
    // its previous async_id and need to emit a matching destroy for that
    // before generating a new async_id.
    EmitDestroy();
  }

  // Now we can assign a new async_id_ to this instance.
  async_id_ = execution_async_id == kInvalidAsyncId ? env()->new_async_id()
                                                     : execution_async_id;
  trigger_async_id_ = env()->get_default_trigger_async_id();

  {
    HandleScope handle_scope(env()->isolate());
    Local<Object> obj = object();
    CHECK(!obj.IsEmpty());
    if (resource != obj) {
      USE(obj->Set(env()->context(), env()->resource_symbol(), resource));
    }
  }

  switch (provider_type()) {
#define V(PROVIDER)                                  ...",1,1,async_wrap.cc,node.AsyncWrap.AsyncReset,,false,581,633,AsyncReset,,,38,"void node.AsyncWrap.AsyncReset (Local<Object>,double,bool)"
8796,METHOD,async_wrap.cc:<global>,TYPE_DECL,"void AsyncWrap::EmitAsyncInit(Environment* env,
                              Local<Object> object,
                              Local<String> type,
                              double async_id,
                              double trigger_async_id) {
  CHECK(!object.IsEmpty());
  CHECK(!type.IsEmpty());
  AsyncHooks* async_hooks = env->async_hooks();

  // Nothing to execute, so can continue normally.
  if (async_hooks->fields()[AsyncHooks::kInit] == 0) {
    return;
  }

  HandleScope scope(env->isolate());
  Local<Function> init_fn = env->async_hooks_init_function();

  Local<Value> argv[] = {
    Number::New(env->isolate(), async_id),
    type,
    Number::New(env->isolate(), trigger_async_id),
    object,
  };

  TryCatchScope try_catch(env, TryCatchScope::CatchMode::kFatal);
  USE(init_fn->Call(env->context(), object, arraysize(argv), argv));
}",1,1,async_wrap.cc,node.AsyncWrap.EmitAsyncInit,,false,635,661,EmitAsyncInit,,,39,"void node.AsyncWrap.EmitAsyncInit (Environment*,Local<Object>,Local<String>,double,double)"
8898,METHOD,async_wrap.cc:<global>,TYPE_DECL,"MaybeLocal<Value> AsyncWrap::MakeCallback(const Local<Function> cb,
                                          int argc,
                                          Local<Value>* argv) {
  EmitTraceEventBefore();

  ProviderType provider = provider_type();
  async_context context { get_async_id(), get_trigger_async_id() };
  MaybeLocal<Value> ret = InternalMakeCallback(
      env(), object(), object(), cb, argc, argv, context);

  // This is a static call with cached values because the `this` object may
  // no longer be alive at this point.
  EmitTraceEventAfter(provider, context.async_id);

  return ret;
}",1,1,async_wrap.cc,node.AsyncWrap.MakeCallback,,false,664,679,MakeCallback,,,40,"MaybeLocal<Value> node.AsyncWrap.MakeCallback (Local<Function>,int,Local<Value>*)"
8937,METHOD,async_wrap.cc:<global>,TYPE_DECL,"const char* AsyncWrap::MemoryInfoName() const {
  return provider_names[provider_type()];
}",1,1,async_wrap.cc,node.AsyncWrap.MemoryInfoName,,false,681,683,MemoryInfoName,,,41,const char* node.AsyncWrap.MemoryInfoName ()
8945,METHOD,async_wrap.cc:<global>,TYPE_DECL,"std::string AsyncWrap::diagnostic_name() const {
  char buf[64];
  snprintf(buf,
           sizeof(buf),
           ""%s(%"" PRIu64 "":%.0f)"",
           MemoryInfoName(),
           env()->thread_id(),
           async_id_);
  return buf;
}",1,1,async_wrap.cc,node.AsyncWrap.diagnostic_name,,false,685,694,diagnostic_name,,,42,string node.AsyncWrap.diagnostic_name ()
8953,METHOD,async_wrap.cc:<global>,TYPE_DECL,"Local<Object> AsyncWrap::GetOwner() {
  return GetOwner(env(), object());
}",1,1,async_wrap.cc,node.AsyncWrap.GetOwner,,false,696,698,GetOwner,,,43,Local<Object> node.AsyncWrap.GetOwner ()
8961,METHOD,async_wrap.cc:<global>,TYPE_DECL,"Local<Object> AsyncWrap::GetOwner(Environment* env, Local<Object> obj) {
  EscapableHandleScope handle_scope(env->isolate());
  CHECK(!obj.IsEmpty());

  TryCatchScope ignore_exceptions(env);
  while (true) {
    Local<Value> owner;
    if (!obj->Get(env->context(),
                  env->owner_symbol()).ToLocal(&owner) ||
        !owner->IsObject()) {
      return handle_scope.Escape(obj);
    }

    obj = owner.As<Object>();
  }
}",1,1,async_wrap.cc,node.AsyncWrap.GetOwner,,false,700,715,GetOwner,,,44,"Local<Object> node.AsyncWrap.GetOwner (Environment*,Local<Object>)"
9038,METHOD,async_wrap.hpp:<global>,TYPE_DECL,<global>,1,28,async_wrap.hpp,async_wrap.hpp:<global>,,false,1,252,<global>,,,1,
9049,METHOD,base64-inl.hpp:<global>,TYPE_DECL,<global>,1,28,base64-inl.hpp,base64-inl.hpp:<global>,,false,1,193,<global>,,,1,
9062,METHOD,base64.hpp:<global>,TYPE_DECL,<global>,1,24,base64.hpp,base64.hpp:<global>,,false,1,53,<global>,,,1,
9067,METHOD,base64_version.hpp:<global>,TYPE_DECL,<global>,1,32,base64_version.hpp,base64_version.hpp:<global>,,false,1,6,<global>,,,1,
9080,METHOD,base_object-inl.hpp:<global>,TYPE_DECL,<global>,1,33,base_object-inl.hpp,base_object-inl.hpp:<global>,,false,1,310,<global>,,,1,
9083,METHOD,base_object.cc:<global>,TYPE_DECL,"[](const WeakCallbackInfo<BaseObject>& data) {
        BaseObject* obj = data.GetParameter();
        // Clear the persistent handle so that ~BaseObject() doesn't attempt
        // to mess with internal fields, since the JS object may have
        // transitioned into an invalid state.
        // Refs: https://github.com/nodejs/node/issues/18897
        obj->persistent_handle_.Reset();
        CHECK_IMPLIES(obj->has_pointer_data(),
                      obj->pointer_data()->strong_ptr_count == 0);
        obj->OnGCCollect();
      }",7,7,base_object.cc,node.BaseObject.MakeWeak.<lambda>0,,false,55,65,<lambda>0,,,1,ANY node.BaseObject.MakeWeak.<lambda>0 (WeakCallbackInfo<BaseObject>)
9127,METHOD,base_object.cc:<global>,TYPE_DECL,<global>,1,29,base_object.hpp,base_object.cc:<global>,,false,1,151,<global>,,,1,
9130,METHOD,base_object.cc:<global>,TYPE_DECL,"BaseObject::BaseObject(Realm* realm, Local<Object> object)
    : persistent_handle_(realm->isolate(), object), realm_(realm) {
  CHECK_EQ(false, object.IsEmpty());
  CHECK_GE(object->InternalFieldCount(), BaseObject::kInternalFieldCount);
  SetInternalFields(object, static_cast<void*>(this));
  realm->AddCleanupHook(DeleteMe, static_cast<void*>(this));
  realm->modify_base_object_count(1);
}",1,1,base_object.cc,node.BaseObject.BaseObject,,false,16,23,BaseObject,,,1,"ANY node.BaseObject.BaseObject (Realm*,Local<Object>)"
9168,METHOD,base_object.cc:<global>,TYPE_DECL,"BaseObject::~BaseObject() {
  realm()->modify_base_object_count(-1);
  realm()->RemoveCleanupHook(DeleteMe, static_cast<void*>(this));

  if (UNLIKELY(has_pointer_data())) {
    PointerData* metadata = pointer_data();
    CHECK_EQ(metadata->strong_ptr_count, 0);
    metadata->self = nullptr;
    if (metadata->weak_ptr_count == 0) delete metadata;
  }

  if (persistent_handle_.IsEmpty()) {
    // This most likely happened because the weak callback below cleared it.
    return;
  }

  {
    HandleScope handle_scope(realm()->isolate());
    object()->SetAlignedPointerInInternalField(BaseObject::kSlot, nullptr);
  }
}",1,1,base_object.cc,node.BaseObject.~BaseObject,,false,25,45,~BaseObject,,,2,ANY node.BaseObject.~BaseObject ()
9235,METHOD,base_object.cc:<global>,TYPE_DECL,"void BaseObject::MakeWeak() {
  if (has_pointer_data()) {
    pointer_data()->wants_weak_jsobj = true;
    if (pointer_data()->strong_ptr_count > 0) return;
  }

  persistent_handle_.SetWeak(
      this,
      [](const WeakCallbackInfo<BaseObject>& data) {
        BaseObject* obj = data.GetParameter();
        // Clear the persistent handle so that ~BaseObject() doesn't attempt
        // to mess with internal fields, since the JS object may have
        // transitioned into an invalid state.
        // Refs: https://github.com/nodejs/node/issues/18897
        obj->persistent_handle_.Reset();
        CHECK_IMPLIES(obj->has_pointer_data(),
                      obj->pointer_data()->strong_ptr_count == 0);
        obj->OnGCCollect();
      },
      WeakCallbackType::kParameter);
}",1,1,base_object.cc,node.BaseObject.MakeWeak,,false,47,67,MakeWeak,,,3,void node.BaseObject.MakeWeak ()
9268,METHOD,base_object.cc:<global>,TYPE_DECL,"void BaseObject::LazilyInitializedJSTemplateConstructor(
    const FunctionCallbackInfo<Value>& args) {
  DCHECK(args.IsConstructCall());
  CHECK_GE(args.This()->InternalFieldCount(), BaseObject::kInternalFieldCount);
  SetInternalFields(args.This(), nullptr);
}",1,1,base_object.cc,node.BaseObject.LazilyInitializedJSTemplateConstructor,,false,76,81,LazilyInitializedJSTemplateConstructor,,,6,void node.BaseObject.LazilyInitializedJSTemplateConstructor (FunctionCallbackInfo<Value>)
9295,METHOD,base_object.cc:<global>,TYPE_DECL,"Local<FunctionTemplate> BaseObject::MakeLazilyInitializedJSTemplate(
    Environment* env) {
  return MakeLazilyInitializedJSTemplate(env->isolate_data());
}",1,1,base_object.cc,node.BaseObject.MakeLazilyInitializedJSTemplate,,false,83,86,MakeLazilyInitializedJSTemplate,,,7,Local<FunctionTemplate> node.BaseObject.MakeLazilyInitializedJSTemplate (Environment*)
9306,METHOD,base_object.cc:<global>,TYPE_DECL,"Local<FunctionTemplate> BaseObject::MakeLazilyInitializedJSTemplate(
    IsolateData* isolate_data) {
  Local<FunctionTemplate> t = NewFunctionTemplate(
      isolate_data->isolate(), LazilyInitializedJSTemplateConstructor);
  t->InstanceTemplate()->SetInternalFieldCount(BaseObject::kInternalFieldCount);
  return t;
}",1,1,base_object.cc,node.BaseObject.MakeLazilyInitializedJSTemplate,,false,88,94,MakeLazilyInitializedJSTemplate,,,8,Local<FunctionTemplate> node.BaseObject.MakeLazilyInitializedJSTemplate (IsolateData*)
9335,METHOD,base_object.cc:<global>,TYPE_DECL,"BaseObject::PointerData* BaseObject::pointer_data() {
  if (!has_pointer_data()) {
    PointerData* metadata = new PointerData();
    metadata->wants_weak_jsobj = persistent_handle_.IsWeak();
    metadata->self = this;
    pointer_data_ = metadata;
  }
  CHECK(has_pointer_data());
  return pointer_data_;
}",1,1,base_object.cc,node.BaseObject.pointer_data,,false,96,105,pointer_data,,,9,PointerData node.BaseObject.pointer_data ()
9367,METHOD,base_object.cc:<global>,TYPE_DECL,"void BaseObject::decrease_refcount() {
  CHECK(has_pointer_data());
  PointerData* metadata = pointer_data();
  CHECK_GT(metadata->strong_ptr_count, 0);
  unsigned int new_refcount = --metadata->strong_ptr_count;
  if (new_refcount == 0) {
    if (metadata->is_detached) {
      OnGCCollect();
    } else if (metadata->wants_weak_jsobj && !persistent_handle_.IsEmpty()) {
      MakeWeak();
    }
  }
}",1,1,base_object.cc,node.BaseObject.decrease_refcount,,false,107,119,decrease_refcount,,,10,void node.BaseObject.decrease_refcount ()
9413,METHOD,base_object.cc:<global>,TYPE_DECL,"void BaseObject::increase_refcount() {
  unsigned int prev_refcount = pointer_data()->strong_ptr_count++;
  if (prev_refcount == 0 && !persistent_handle_.IsEmpty())
    persistent_handle_.ClearWeak();
}",1,1,base_object.cc,node.BaseObject.increase_refcount,,false,121,125,increase_refcount,,,11,void node.BaseObject.increase_refcount ()
9439,METHOD,base_object.cc:<global>,TYPE_DECL,"void BaseObject::DeleteMe(void* data) {
  BaseObject* self = static_cast<BaseObject*>(data);
  if (self->has_pointer_data() && self->pointer_data()->strong_ptr_count > 0) {
    return self->Detach();
  }
  delete self;
}",1,1,base_object.cc,node.BaseObject.DeleteMe,,false,127,133,DeleteMe,,,12,void node.BaseObject.DeleteMe (void*)
9472,METHOD,base_object.cc:<global>,TYPE_DECL,"bool BaseObject::IsDoneInitializing() const {
  return true;
}",1,1,base_object.cc,node.BaseObject.IsDoneInitializing,,false,135,137,IsDoneInitializing,,,13,bool node.BaseObject.IsDoneInitializing ()
9478,METHOD,base_object.cc:<global>,TYPE_DECL,"Local<Object> BaseObject::WrappedObject() const {
  return object();
}",1,1,base_object.cc,node.BaseObject.WrappedObject,,false,139,141,WrappedObject,,,14,Local<Object> node.BaseObject.WrappedObject ()
9484,METHOD,base_object.cc:<global>,TYPE_DECL,"bool BaseObject::IsRootNode() const {
  return !persistent_handle_.IsWeak();
}",1,1,base_object.cc,node.BaseObject.IsRootNode,,false,143,145,IsRootNode,,,15,bool node.BaseObject.IsRootNode ()
9494,METHOD,base_object.cc:<global>,TYPE_DECL,"bool BaseObject::IsNotIndicativeOfMemoryLeakAtExit() const {
  return IsWeakOrDetached();
}",1,1,base_object.cc,node.BaseObject.IsNotIndicativeOfMemoryLeakAtExit,,false,147,149,IsNotIndicativeOfMemoryLeakAtExit,,,16,bool node.BaseObject.IsNotIndicativeOfMemoryLeakAtExit ()
9511,METHOD,base_object.hpp:<global>,TYPE_DECL,<global>,1,29,base_object.hpp,base_object.hpp:<global>,,false,1,319,<global>,,,1,
9518,METHOD,base_object_types.hpp:<global>,TYPE_DECL,<global>,1,35,base_object_types.hpp,base_object_types.hpp:<global>,,false,1,74,<global>,,,1,
9537,METHOD,blob_serializer_deserializer-inl.hpp:<global>,TYPE_DECL,<global>,1,50,blob_serializer_deserializer-inl.hpp,blob_serializer_deserializer-inl.hpp:<global>,,false,1,361,<global>,,,1,
9546,METHOD,blob_serializer_deserializer.hpp:<global>,TYPE_DECL,<global>,1,46,blob_serializer_deserializer.hpp,blob_serializer_deserializer.hpp:<global>,,false,1,132,<global>,,,1,
9553,METHOD,callback_queue-inl.hpp:<global>,TYPE_DECL,<global>,1,36,callback_queue-inl.hpp,callback_queue-inl.hpp:<global>,,false,1,97,<global>,,,1,
9560,METHOD,callback_queue.hpp:<global>,TYPE_DECL,<global>,1,32,callback_queue.hpp,callback_queue.hpp:<global>,,false,1,78,<global>,,,1,
9563,METHOD,cares_wrap.cc:<global>,TYPE_DECL,[](uv_timer_t* handle) { delete handle; },37,77,cares_wrap.cc,node.cares_wrap.ChannelWrap.CloseTimer.<lambda>0,,false,763,763,<lambda>0,,,1,ANY node.cares_wrap.ChannelWrap.CloseTimer.<lambda>0 (uv_timer_t*)
9572,METHOD,cares_wrap.cc:<global>,TYPE_DECL,[&]() { uv_freeaddrinfo(res); },31,61,cares_wrap.cc,node.cares_wrap.anonymous_namespace_23.AfterGetAddrInfo.<lambda>1,,false,1434,1434,<lambda>1,,,1,ANY node.cares_wrap.anonymous_namespace_23.AfterGetAddrInfo.<lambda>1 ()
9580,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"[&] (bool want_ipv4, bool want_ipv6) -> Maybe<bool> {
      for (auto p = res; p != nullptr; p = p->ai_next) {
        CHECK_EQ(p->ai_socktype, SOCK_STREAM);

        const char* addr;
        if (want_ipv4 && p->ai_family == AF_INET) {
          addr = reinterpret_cast<char*>(
              &(reinterpret_cast<struct sockaddr_in*>(p->ai_addr)->sin_addr));
        } else if (want_ipv6 && p->ai_family == AF_INET6) {
          addr = reinterpret_cast<char*>(
              &(reinterpret_cast<struct sockaddr_in6*>(p->ai_addr)->sin6_addr));
        } else {
          continue;
        }

        char ip[INET6_ADDRSTRLEN];
        if (uv_inet_ntop(p->ai_family, addr, ip, sizeof(ip)))
          continue;

        Local<String> s = OneByteString(env->isolate(), ip);
        if (results->Set(env->context(), n, s).IsNothing())
          return Nothing<bool>();
        n++;
      }
      return Just(true);
    }",16,5,cares_wrap.cc,node.cares_wrap.anonymous_namespace_24.AfterGetAddrInfo.<lambda>2,,false,1453,1478,<lambda>2,,,1,"Maybe<bool> node.cares_wrap.anonymous_namespace_24.AfterGetAddrInfo.<lambda>2 (bool,bool)"
9703,METHOD,cares_wrap.cc:<global>,TYPE_DECL,[&]() { ares_free_data(servers); },31,64,cares_wrap.cc,node.cares_wrap.anonymous_namespace_32.GetServers.<lambda>3,,false,1660,1660,<lambda>3,,,1,ANY node.cares_wrap.anonymous_namespace_32.GetServers.<lambda>3 ()
9750,METHOD,cares_wrap.cc:<global>,TYPE_DECL,<global>,1,1,cares_wrap.cc,cares_wrap.cc:<global>,,false,1,1985,<global>,,,1,
9756,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"inline uint16_t cares_get_16bit(const unsigned char* p) {
  return static_cast<uint32_t>(p[0] << 8U) | (static_cast<uint32_t>(p[1]));
}",1,1,cares_wrap.cc,node.cares_wrap.anonymous_namespace_1.cares_get_16bit,,false,81,83,cares_get_16bit,,,2,uint16_t node.cares_wrap.anonymous_namespace_1.cares_get_16bit (unsigned char*)
9775,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"void ares_poll_cb(uv_poll_t* watcher, int status, int events) {
  NodeAresTask* task = ContainerOf(&NodeAresTask::poll_watcher, watcher);
  ChannelWrap* channel = task->channel;

  /* Reset the idle timer */
  uv_timer_again(channel->timer_handle());

  if (status < 0) {
    /* An error happened. Just pretend that the socket is both readable and */
    /* writable. */
    ares_process_fd(channel->cares_channel(), task->sock, task->sock);
    return;
  }

  /* Process DNS responses */
  ares_process_fd(channel->cares_channel(),
                  events & UV_READABLE ? task->sock : ARES_SOCKET_BAD,
                  events & UV_WRITABLE ? task->sock : ARES_SOCKET_BAD);
}",1,1,cares_wrap.cc,node.cares_wrap.anonymous_namespace_2.ares_poll_cb,,false,85,103,ares_poll_cb,,,3,"void node.cares_wrap.anonymous_namespace_2.ares_poll_cb (uv_poll_t*,int,int)"
9840,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"void ares_poll_close_cb(uv_poll_t* watcher) {
  std::unique_ptr<NodeAresTask> free_me(
        ContainerOf(&NodeAresTask::poll_watcher, watcher));
}",1,1,cares_wrap.cc,node.cares_wrap.anonymous_namespace_3.ares_poll_close_cb,,false,106,109,ares_poll_close_cb,,,4,void node.cares_wrap.anonymous_namespace_3.ares_poll_close_cb (uv_poll_t*)
9858,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"void ares_sockstate_cb(void* data, ares_socket_t sock, int read, int write) {
  ChannelWrap* channel = static_cast<ChannelWrap*>(data);
  NodeAresTask* task;

  NodeAresTask lookup_task;
  lookup_task.sock = sock;
  auto it = channel->task_list()->find(&lookup_task);

  task = (it == channel->task_list()->end()) ? nullptr : *it;

  if (read || write) {
    if (!task) {
      /* New socket */
      channel->StartTimer();

      task = NodeAresTask::Create(channel, sock);
      if (task == nullptr) {
        /* This should never happen unless we're out of memory or something */
        /* is seriously wrong. The socket won't be polled, but the query will */
        /* eventually time out. */
        return;
      }

      channel->task_list()->insert(task);
    }

    /* This should never fail. If it fails anyway, the query will eventually */
    /* time out. */
    uv_poll_start(&task->poll_watcher,
                  (read ? UV_READABLE : 0) | (write ? UV_WRITABLE : 0),
             ...",1,1,cares_wrap.cc,node.cares_wrap.anonymous_namespace_4.ares_sockstate_cb,,false,113,159,ares_sockstate_cb,,,5,"void node.cares_wrap.anonymous_namespace_4.ares_sockstate_cb (void*,ares_socket_t,int,int)"
9995,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"Local<Array> HostentToNames(Environment* env, struct hostent* host) {
  EscapableHandleScope scope(env->isolate());

  std::vector<Local<Value>> names;

  for (uint32_t i = 0; host->h_aliases[i] != nullptr; ++i)
    names.emplace_back(OneByteString(env->isolate(), host->h_aliases[i]));

  Local<Array> ret = Array::New(env->isolate(), names.data(), names.size());

  return scope.Escape(ret);
}",1,1,cares_wrap.cc,node.cares_wrap.anonymous_namespace_7.HostentToNames,,false,161,172,HostentToNames,,,6,"Local<Array> node.cares_wrap.anonymous_namespace_7.HostentToNames (Environment*,hostent*)"
10073,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"Local<Array> HostentToNames(Environment* env,
                            struct hostent* host,
                            Local<Array> names) {
  size_t offset = names->Length();

  for (uint32_t i = 0; host->h_aliases[i] != nullptr; ++i) {
    names->Set(
        env->context(),
        i + offset,
        OneByteString(env->isolate(), host->h_aliases[i])).Check();
  }

  return names;
}",1,1,cares_wrap.cc,node.cares_wrap.anonymous_namespace_8.HostentToNames,,false,174,187,HostentToNames,,,7,"Local<Array> node.cares_wrap.anonymous_namespace_8.HostentToNames (Environment*,hostent*,Local<Array>)"
10129,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"Local<Array> AddrTTLToArray(
    Environment* env,
    const T* addrttls,
    size_t naddrttls) {
  MaybeStackBuffer<Local<Value>, 8> ttls(naddrttls);
  for (size_t i = 0; i < naddrttls; i++)
    ttls[i] = Integer::NewFromUnsigned(env->isolate(), addrttls[i].ttl);

  return Array::New(env->isolate(), ttls.out(), naddrttls);
}",1,1,cares_wrap.cc,node.cares_wrap.anonymous_namespace_9.AddrTTLToArray,,false,190,199,AddrTTLToArray,,,8,"Local<Array> node.cares_wrap.anonymous_namespace_9.AddrTTLToArray<T> (Environment*,T*,size_t)"
10181,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"int ParseGeneralReply(
    Environment* env,
    const unsigned char* buf,
    int len,
    int* type,
    Local<Array> ret,
    void* addrttls = nullptr,
    int* naddrttls = nullptr) {
  HandleScope handle_scope(env->isolate());
  hostent* host;

  int status;
  switch (*type) {
    case ns_t_a:
    case ns_t_cname:
    case ns_t_cname_or_a:
      status = ares_parse_a_reply(buf,
                                  len,
                                  &host,
                                  static_cast<ares_addrttl*>(addrttls),
                                  naddrttls);
      break;
    case ns_t_aaaa:
      status = ares_parse_aaaa_reply(buf,
                                     len,
                                     &host,
                                     static_cast<ares_addr6ttl*>(addrttls),
                                     naddrttls);
      break;
    case ns_t_ns:
      status = ares_parse_ns_reply(buf, len, &host);
      break;
    case ns_t_ptr:
      status...",1,1,cares_wrap.cc,node.cares_wrap.anonymous_namespace_10.ParseGeneralReply,,false,201,282,ParseGeneralReply,,,9,"int node.cares_wrap.anonymous_namespace_10.ParseGeneralReply (Environment*,unsigned char*,int,int*,Local<Array>,void*,int*)"
10470,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"int ParseMxReply(
    Environment* env,
    const unsigned char* buf,
    int len,
    Local<Array> ret,
    bool need_type = false) {
  HandleScope handle_scope(env->isolate());

  struct ares_mx_reply* mx_start;
  int status = ares_parse_mx_reply(buf, len, &mx_start);
  if (status != ARES_SUCCESS)
    return status;

  uint32_t offset = ret->Length();
  ares_mx_reply* current = mx_start;
  for (uint32_t i = 0; current != nullptr; ++i, current = current->next) {
    Local<Object> mx_record = Object::New(env->isolate());
    mx_record->Set(env->context(),
                   env->exchange_string(),
                   OneByteString(env->isolate(), current->host)).Check();
    mx_record->Set(env->context(),
                   env->priority_string(),
                   Integer::New(env->isolate(), current->priority)).Check();
    if (need_type)
      mx_record->Set(env->context(),
                     env->type_string(),
                     env->dns_mx_string()).Check();

    ret->Set(...",1,1,cares_wrap.cc,node.cares_wrap.anonymous_namespace_11.ParseMxReply,,false,284,317,ParseMxReply,,,10,"int node.cares_wrap.anonymous_namespace_11.ParseMxReply (Environment*,unsigned char*,int,Local<Array>,bool)"
10634,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"int ParseCaaReply(
    Environment* env,
    const unsigned char* buf,
    int len,
    Local<Array> ret,
    bool need_type = false) {
  HandleScope handle_scope(env->isolate());

  struct ares_caa_reply* caa_start;
  int status = ares_parse_caa_reply(buf, len, &caa_start);
  if (status != ARES_SUCCESS)
    return status;

  uint32_t offset = ret->Length();
  ares_caa_reply* current = caa_start;
  for (uint32_t i = 0; current != nullptr; ++i, current = current->next) {
    Local<Object> caa_record = Object::New(env->isolate());

    caa_record->Set(env->context(),
                    env->dns_critical_string(),
                    Integer::New(env->isolate(), current->critical)).Check();
    caa_record->Set(env->context(),
                    OneByteString(env->isolate(), current->property),
                    OneByteString(env->isolate(), current->value)).Check();
    if (need_type)
      caa_record->Set(env->context(),
                      env->type_string(),
                  ...",1,1,cares_wrap.cc,node.cares_wrap.anonymous_namespace_12.ParseCaaReply,,false,319,353,ParseCaaReply,,,11,"int node.cares_wrap.anonymous_namespace_12.ParseCaaReply (Environment*,unsigned char*,int,Local<Array>,bool)"
10802,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"int ParseTxtReply(
    Environment* env,
    const unsigned char* buf,
    int len,
    Local<Array> ret,
    bool need_type = false) {
  HandleScope handle_scope(env->isolate());

  struct ares_txt_ext* txt_out;

  int status = ares_parse_txt_reply_ext(buf, len, &txt_out);
  if (status != ARES_SUCCESS)
    return status;

  Local<Array> txt_chunk;

  struct ares_txt_ext* current = txt_out;
  uint32_t i = 0, j;
  uint32_t offset = ret->Length();
  for (j = 0; current != nullptr; current = current->next) {
    Local<String> txt =
        OneByteString(env->isolate(), current->txt, current->length);

    // New record found - write out the current chunk
    if (current->record_start) {
      if (!txt_chunk.IsEmpty()) {
        if (need_type) {
          Local<Object> elem = Object::New(env->isolate());
          elem->Set(env->context(), env->entries_string(), txt_chunk).Check();
          elem->Set(env->context(),
                    env->type_string(),
                    env->dns_t...",1,1,cares_wrap.cc,node.cares_wrap.anonymous_namespace_13.ParseTxtReply,,false,355,416,ParseTxtReply,,,12,"int node.cares_wrap.anonymous_namespace_13.ParseTxtReply (Environment*,unsigned char*,int,Local<Array>,bool)"
11105,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"int ParseSrvReply(
    Environment* env,
    const unsigned char* buf,
    int len,
    Local<Array> ret,
    bool need_type = false) {
  HandleScope handle_scope(env->isolate());

  struct ares_srv_reply* srv_start;
  int status = ares_parse_srv_reply(buf, len, &srv_start);
  if (status != ARES_SUCCESS)
    return status;

  ares_srv_reply* current = srv_start;
  int offset = ret->Length();
  for (uint32_t i = 0; current != nullptr; ++i, current = current->next) {
    Local<Object> srv_record = Object::New(env->isolate());
    srv_record->Set(env->context(),
                    env->name_string(),
                    OneByteString(env->isolate(), current->host)).Check();
    srv_record->Set(env->context(),
                    env->port_string(),
                    Integer::New(env->isolate(), current->port)).Check();
    srv_record->Set(env->context(),
                    env->priority_string(),
                    Integer::New(env->isolate(), current->priority)).Check();
    srv_...",1,1,cares_wrap.cc,node.cares_wrap.anonymous_namespace_14.ParseSrvReply,,false,419,458,ParseSrvReply,,,13,"int node.cares_wrap.anonymous_namespace_14.ParseSrvReply (Environment*,unsigned char*,int,Local<Array>,bool)"
11321,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"int ParseNaptrReply(
    Environment* env,
    const unsigned char* buf,
    int len,
    Local<Array> ret,
    bool need_type = false) {
  HandleScope handle_scope(env->isolate());

  ares_naptr_reply* naptr_start;
  int status = ares_parse_naptr_reply(buf, len, &naptr_start);

  if (status != ARES_SUCCESS)
    return status;

  ares_naptr_reply* current = naptr_start;
  int offset = ret->Length();
  for (uint32_t i = 0; current != nullptr; ++i, current = current->next) {
    Local<Object> naptr_record = Object::New(env->isolate());
    naptr_record->Set(env->context(),
                      env->flags_string(),
                      OneByteString(env->isolate(), current->flags)).Check();
    naptr_record->Set(env->context(),
                      env->service_string(),
                      OneByteString(env->isolate(),
                                    current->service)).Check();
    naptr_record->Set(env->context(),
                      env->regexp_string(),
                 ...",1,1,cares_wrap.cc,node.cares_wrap.anonymous_namespace_15.ParseNaptrReply,,false,461,511,ParseNaptrReply,,,14,"int node.cares_wrap.anonymous_namespace_15.ParseNaptrReply (Environment*,unsigned char*,int,Local<Array>,bool)"
11580,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"int ParseSoaReply(
    Environment* env,
    unsigned char* buf,
    int len,
    Local<Object>* ret) {
  EscapableHandleScope handle_scope(env->isolate());

  // Manage memory using standardard smart pointer std::unique_tr
  struct AresDeleter {
    void operator()(char* ptr) const noexcept { ares_free_string(ptr); }
  };
  using ares_unique_ptr = std::unique_ptr<char[], AresDeleter>;

  // Can't use ares_parse_soa_reply() here which can only parse single record
  const unsigned int ancount = cares_get_16bit(buf + 6);
  unsigned char* ptr = buf + NS_HFIXEDSZ;
  char* name_temp = nullptr;
  long temp_len;  // NOLINT(runtime/int)
  int status = ares_expand_name(ptr, buf, len, &name_temp, &temp_len);
  if (status != ARES_SUCCESS) {
    // returns EBADRESP in case of invalid input
    return status == ARES_EBADNAME ? ARES_EBADRESP : status;
  }

  const ares_unique_ptr name(name_temp);

  if (ptr + temp_len + NS_QFIXEDSZ > buf + len) {
    return ARES_EBADRESP;
  }
  ptr += temp_len + ...",1,1,cares_wrap.cc,node.cares_wrap.anonymous_namespace_16.ParseSoaReply,,false,514,635,ParseSoaReply,,,15,"int node.cares_wrap.anonymous_namespace_16.ParseSoaReply (Environment*,unsigned char*,int,Local<Object>*)"
12075,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"ChannelWrap::ChannelWrap(
      Environment* env,
      Local<Object> object,
      int timeout,
      int tries)
    : AsyncWrap(env, object, PROVIDER_DNSCHANNEL),
      timeout_(timeout),
      tries_(tries) {
  MakeWeak();

  Setup();
}",1,1,cares_wrap.cc,node.cares_wrap.ChannelWrap.ChannelWrap,,false,638,649,ChannelWrap,,,2,"ANY node.cares_wrap.ChannelWrap.ChannelWrap (Environment*,Local<Object>,int,int)"
12085,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"void ChannelWrap::MemoryInfo(MemoryTracker* tracker) const {
  if (timer_handle_ != nullptr)
    tracker->TrackField(""timer_handle"", *timer_handle_);
  tracker->TrackField(""task_list"", task_list_, ""NodeAresTask::List"");
}",1,1,cares_wrap.cc,node.cares_wrap.ChannelWrap.MemoryInfo,,false,651,655,MemoryInfo,,,3,void node.cares_wrap.ChannelWrap.MemoryInfo (MemoryTracker*)
12109,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"void ChannelWrap::New(const FunctionCallbackInfo<Value>& args) {
  CHECK(args.IsConstructCall());
  CHECK_EQ(args.Length(), 2);
  CHECK(args[0]->IsInt32());
  CHECK(args[1]->IsInt32());
  const int timeout = args[0].As<Int32>()->Value();
  const int tries = args[1].As<Int32>()->Value();
  Environment* env = Environment::GetCurrent(args);
  new ChannelWrap(env, args.This(), timeout, tries);
}",1,1,cares_wrap.cc,node.cares_wrap.ChannelWrap.New,,false,657,666,New,,,4,void node.cares_wrap.ChannelWrap.New (FunctionCallbackInfo<Value>)
12180,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"GetAddrInfoReqWrap::GetAddrInfoReqWrap(
    Environment* env,
    Local<Object> req_wrap_obj,
    bool verbatim)
    : ReqWrap(env, req_wrap_obj, AsyncWrap::PROVIDER_GETADDRINFOREQWRAP),
      verbatim_(verbatim) {}",1,28,cares_wrap.cc,node.cares_wrap.GetAddrInfoReqWrap.GetAddrInfoReqWrap,,false,668,673,GetAddrInfoReqWrap,,,5,"ANY node.cares_wrap.GetAddrInfoReqWrap.GetAddrInfoReqWrap (Environment*,Local<Object>,bool)"
12187,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"GetNameInfoReqWrap::GetNameInfoReqWrap(
    Environment* env,
    Local<Object> req_wrap_obj)
    : ReqWrap(env, req_wrap_obj, AsyncWrap::PROVIDER_GETNAMEINFOREQWRAP) {}",1,75,cares_wrap.cc,node.cares_wrap.GetNameInfoReqWrap.GetNameInfoReqWrap,,false,675,678,GetNameInfoReqWrap,,,6,"ANY node.cares_wrap.GetNameInfoReqWrap.GetNameInfoReqWrap (Environment*,Local<Object>)"
12193,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"void ChannelWrap::AresTimeout(uv_timer_t* handle) {
  ChannelWrap* channel = static_cast<ChannelWrap*>(handle->data);
  CHECK_EQ(channel->timer_handle(), handle);
  CHECK_EQ(false, channel->task_list()->empty());
  ares_process_fd(channel->cares_channel(), ARES_SOCKET_BAD, ARES_SOCKET_BAD);
}",1,1,cares_wrap.cc,node.cares_wrap.ChannelWrap.AresTimeout,,false,682,687,AresTimeout,,,7,void node.cares_wrap.ChannelWrap.AresTimeout (uv_timer_t*)
12228,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"void NodeAresTask::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""channel"", channel);
}",1,1,cares_wrap.cc,node.cares_wrap.NodeAresTask.MemoryInfo,,false,690,692,MemoryInfo,,,8,void node.cares_wrap.NodeAresTask.MemoryInfo (MemoryTracker*)
12239,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"NodeAresTask* NodeAresTask::Create(ChannelWrap* channel, ares_socket_t sock) {
  auto task = new NodeAresTask();

  task->channel = channel;
  task->sock = sock;

  if (uv_poll_init_socket(channel->env()->event_loop(),
                          &task->poll_watcher, sock) < 0) {
    /* This should never happen. */
    delete task;
    return nullptr;
  }

  return task;
}",1,1,cares_wrap.cc,node.cares_wrap.NodeAresTask.Create,,false,695,709,Create,,,9,"NodeAresTask node.cares_wrap.NodeAresTask.Create (ChannelWrap*,ares_socket_t)"
12283,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"void ChannelWrap::Setup() {
  struct ares_options options;
  memset(&options, 0, sizeof(options));
  options.flags = ARES_FLAG_NOCHECKRESP;
  options.sock_state_cb = ares_sockstate_cb;
  options.sock_state_cb_data = this;
  options.timeout = timeout_;
  options.tries = tries_;

  int r;
  if (!library_inited_) {
    Mutex::ScopedLock lock(ares_library_mutex);
    // Multiple calls to ares_library_init() increase a reference counter,
    // so this is a no-op except for the first call to it.
    r = ares_library_init(ARES_LIB_INIT_ALL);
    if (r != ARES_SUCCESS)
      return env()->ThrowError(ToErrorCodeString(r));
  }

  /* We do the call to ares_init_option for caller. */
  const int optmask =
      ARES_OPT_FLAGS | ARES_OPT_TIMEOUTMS |
      ARES_OPT_SOCK_STATE_CB | ARES_OPT_TRIES;
  r = ares_init_options(&channel_, &options, optmask);

  if (r != ARES_SUCCESS) {
    Mutex::ScopedLock lock(ares_library_mutex);
    ares_library_cleanup();
    return env()->ThrowError(ToErrorCodeSt...",1,1,cares_wrap.cc,node.cares_wrap.ChannelWrap.Setup,,false,711,743,Setup,,,10,void node.cares_wrap.ChannelWrap.Setup ()
12380,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"void ChannelWrap::StartTimer() {
  if (timer_handle_ == nullptr) {
    timer_handle_ = new uv_timer_t();
    timer_handle_->data = static_cast<void*>(this);
    uv_timer_init(env()->event_loop(), timer_handle_);
  } else if (uv_is_active(reinterpret_cast<uv_handle_t*>(timer_handle_))) {
    return;
  }
  int timeout = timeout_;
  if (timeout == 0) timeout = 1;
  if (timeout < 0 || timeout > 1000) timeout = 1000;
  uv_timer_start(timer_handle_, AresTimeout, timeout, timeout);
}",1,1,cares_wrap.cc,node.cares_wrap.ChannelWrap.StartTimer,,false,745,757,StartTimer,,,11,void node.cares_wrap.ChannelWrap.StartTimer ()
12444,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"void ChannelWrap::CloseTimer() {
  if (timer_handle_ == nullptr)
    return;

  env()->CloseHandle(timer_handle_, [](uv_timer_t* handle) { delete handle; });
  timer_handle_ = nullptr;
}",1,1,cares_wrap.cc,node.cares_wrap.ChannelWrap.CloseTimer,,false,759,765,CloseTimer,,,12,void node.cares_wrap.ChannelWrap.CloseTimer ()
12463,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"ChannelWrap::~ChannelWrap() {
  ares_destroy(channel_);

  if (library_inited_) {
    Mutex::ScopedLock lock(ares_library_mutex);
    // This decreases the reference counter increased by ares_library_init().
    ares_library_cleanup();
  }

  CloseTimer();
}",1,1,cares_wrap.cc,node.cares_wrap.ChannelWrap.~ChannelWrap,,false,767,777,~ChannelWrap,,,13,ANY node.cares_wrap.ChannelWrap.~ChannelWrap ()
12476,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"void ChannelWrap::ModifyActivityQueryCount(int count) {
  active_query_count_ += count;
  CHECK_GE(active_query_count_, 0);
}",1,1,cares_wrap.cc,node.cares_wrap.ChannelWrap.ModifyActivityQueryCount,,false,780,783,ModifyActivityQueryCount,,,14,void node.cares_wrap.ChannelWrap.ModifyActivityQueryCount (int)
12487,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"void ChannelWrap::EnsureServers() {
  /* if last query is OK or servers are set by user self, do not check */
  if (query_last_ok_ || !is_servers_default_) {
    return;
  }

  ares_addr_port_node* servers = nullptr;

  ares_get_servers_ports(channel_, &servers);

  /* if no server or multi-servers, ignore */
  if (servers == nullptr) return;
  if (servers->next != nullptr) {
    ares_free_data(servers);
    is_servers_default_ = false;
    return;
  }

  /* if the only server is not 127.0.0.1, ignore */
  if (servers[0].family != AF_INET ||
      servers[0].addr.addr4.s_addr != htonl(INADDR_LOOPBACK) ||
      servers[0].tcp_port != 0 ||
      servers[0].udp_port != 0) {
    ares_free_data(servers);
    is_servers_default_ = false;
    return;
  }

  ares_free_data(servers);
  servers = nullptr;

  /* destroy channel and reset channel */
  ares_destroy(channel_);

  CloseTimer();
  Setup();
}",1,1,cares_wrap.cc,node.cares_wrap.ChannelWrap.EnsureServers,,false,793,829,EnsureServers,,,15,void node.cares_wrap.ChannelWrap.EnsureServers ()
12577,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"int AnyTraits::Send(QueryWrap<AnyTraits>* wrap, const char* name) {
  wrap->AresQuery(name, ns_c_in, ns_t_any);
  return 0;
}",1,1,cares_wrap.cc,node.cares_wrap.AnyTraits.Send,,false,831,834,Send,,,16,"int node.cares_wrap.AnyTraits.Send (QueryWrap<AnyTraits>*,char*)"
12592,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"int ATraits::Send(QueryWrap<ATraits>* wrap, const char* name) {
  wrap->AresQuery(name, ns_c_in, ns_t_a);
  return 0;
}",1,1,cares_wrap.cc,node.cares_wrap.ATraits.Send,,false,836,839,Send,,,17,"int node.cares_wrap.ATraits.Send (QueryWrap<ATraits>*,char*)"
12607,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"int AaaaTraits::Send(QueryWrap<AaaaTraits>* wrap, const char* name) {
  wrap->AresQuery(name, ns_c_in, ns_t_aaaa);
  return 0;
}",1,1,cares_wrap.cc,node.cares_wrap.AaaaTraits.Send,,false,841,844,Send,,,18,"int node.cares_wrap.AaaaTraits.Send (QueryWrap<AaaaTraits>*,char*)"
12622,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"int CaaTraits::Send(QueryWrap<CaaTraits>* wrap, const char* name) {
  wrap->AresQuery(name, ns_c_in, T_CAA);
  return 0;
}",1,33,cares_wrap.cc,node.cares_wrap.CaaTraits.Send,,false,846,849,Send,,,19,"int node.cares_wrap.CaaTraits.Send (QueryWrap<CaaTraits>*,char*)"
12639,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"int CnameTraits::Send(QueryWrap<CnameTraits>* wrap, const char* name) {
  wrap->AresQuery(name, ns_c_in, ns_t_cname);
  return 0;
}",1,1,cares_wrap.cc,node.cares_wrap.CnameTraits.Send,,false,851,854,Send,,,20,"int node.cares_wrap.CnameTraits.Send (QueryWrap<CnameTraits>*,char*)"
12654,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"int MxTraits::Send(QueryWrap<MxTraits>* wrap, const char* name) {
  wrap->AresQuery(name, ns_c_in, ns_t_mx);
  return 0;
}",1,1,cares_wrap.cc,node.cares_wrap.MxTraits.Send,,false,856,859,Send,,,21,"int node.cares_wrap.MxTraits.Send (QueryWrap<MxTraits>*,char*)"
12669,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"int NsTraits::Send(QueryWrap<NsTraits>* wrap, const char* name) {
  wrap->AresQuery(name, ns_c_in, ns_t_ns);
  return 0;
}",1,1,cares_wrap.cc,node.cares_wrap.NsTraits.Send,,false,861,864,Send,,,22,"int node.cares_wrap.NsTraits.Send (QueryWrap<NsTraits>*,char*)"
12684,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"int TxtTraits::Send(QueryWrap<TxtTraits>* wrap, const char* name) {
  wrap->AresQuery(name, ns_c_in, ns_t_txt);
  return 0;
}",1,1,cares_wrap.cc,node.cares_wrap.TxtTraits.Send,,false,866,869,Send,,,23,"int node.cares_wrap.TxtTraits.Send (QueryWrap<TxtTraits>*,char*)"
12699,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"int SrvTraits::Send(QueryWrap<SrvTraits>* wrap, const char* name) {
  wrap->AresQuery(name, ns_c_in, ns_t_srv);
  return 0;
}",1,1,cares_wrap.cc,node.cares_wrap.SrvTraits.Send,,false,871,874,Send,,,24,"int node.cares_wrap.SrvTraits.Send (QueryWrap<SrvTraits>*,char*)"
12714,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"int PtrTraits::Send(QueryWrap<PtrTraits>* wrap, const char* name) {
  wrap->AresQuery(name, ns_c_in, ns_t_ptr);
  return 0;
}",1,1,cares_wrap.cc,node.cares_wrap.PtrTraits.Send,,false,876,879,Send,,,25,"int node.cares_wrap.PtrTraits.Send (QueryWrap<PtrTraits>*,char*)"
12729,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"int NaptrTraits::Send(QueryWrap<NaptrTraits>* wrap, const char* name) {
  wrap->AresQuery(name, ns_c_in, ns_t_naptr);
  return 0;
}",1,1,cares_wrap.cc,node.cares_wrap.NaptrTraits.Send,,false,881,884,Send,,,26,"int node.cares_wrap.NaptrTraits.Send (QueryWrap<NaptrTraits>*,char*)"
12744,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"int SoaTraits::Send(QueryWrap<SoaTraits>* wrap, const char* name) {
  wrap->AresQuery(name, ns_c_in, ns_t_soa);
  return 0;
}",1,1,cares_wrap.cc,node.cares_wrap.SoaTraits.Send,,false,886,889,Send,,,27,"int node.cares_wrap.SoaTraits.Send (QueryWrap<SoaTraits>*,char*)"
12759,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"int AnyTraits::Parse(
    QueryAnyWrap* wrap,
    const std::unique_ptr<ResponseData>& response) {
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Array> ret = Array::New(env->isolate());
  int type, status, old_count;

  /* Parse A records or CNAME records */
  ares_addrttl addrttls[256];
  int naddrttls = arraysize(addrttls);

  type = ns_t_cname_or_a;
  status = ParseGeneralReply(env,
                             buf,
                             len,
                             &type,
                             ret,
                             addrttls,
                             &naddrttls);
  uint32_t a_count = ret->Length();
  if (status != ARES_SUCCESS && status != ARES_ENODATA)
    return status;

  if (type == ns_t_a) {
    CHECK_EQ(static_cast<u...",1,1,cares_wrap.cc,node.cares_wrap.AnyTraits.Parse,,false,891,1056,Parse,,,28,"int node.cares_wrap.AnyTraits.Parse (QueryAnyWrap*,ANY)"
13631,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"int ATraits::Parse(
    QueryAWrap* wrap,
    const std::unique_ptr<ResponseData>& response) {
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  ares_addrttl addrttls[256];
  int naddrttls = arraysize(addrttls), status;
  Local<Array> ret = Array::New(env->isolate());

  int type = ns_t_a;
  status = ParseGeneralReply(env,
                             buf,
                             len,
                             &type,
                             ret,
                             addrttls,
                             &naddrttls);
  if (status != ARES_SUCCESS)
    return status;

  Local<Array> ttls = AddrTTLToArray<ares_addrttl>(env, addrttls, naddrttls);

  wrap->CallOnComplete(ret, ttls);
  return 0;
}",1,1,cares_wrap.cc,node.cares_wrap.ATraits.Parse,,false,1058,1090,Parse,,,29,"int node.cares_wrap.ATraits.Parse (QueryAWrap*,ANY)"
13747,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"int AaaaTraits::Parse(
    QueryAaaaWrap* wrap,
    const std::unique_ptr<ResponseData>& response) {
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  ares_addr6ttl addrttls[256];
  int naddrttls = arraysize(addrttls), status;
  Local<Array> ret = Array::New(env->isolate());

  int type = ns_t_aaaa;
  status = ParseGeneralReply(env,
                             buf,
                             len,
                             &type,
                             ret,
                             addrttls,
                             &naddrttls);
  if (status != ARES_SUCCESS)
    return status;

  Local<Array> ttls = AddrTTLToArray<ares_addr6ttl>(env, addrttls, naddrttls);

  wrap->CallOnComplete(ret, ttls);
  return 0;
}",1,1,cares_wrap.cc,node.cares_wrap.AaaaTraits.Parse,,false,1092,1124,Parse,,,30,"int node.cares_wrap.AaaaTraits.Parse (QueryAaaaWrap*,ANY)"
13863,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"int CaaTraits::Parse(
    QueryCaaWrap* wrap,
    const std::unique_ptr<ResponseData>& response) {
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Array> ret = Array::New(env->isolate());
  int status = ParseCaaReply(env, buf, len, ret);
  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(ret);
  return 0;
}",1,1,cares_wrap.cc,node.cares_wrap.CaaTraits.Parse,,false,1126,1146,Parse,,,31,"int node.cares_wrap.CaaTraits.Parse (QueryCaaWrap*,ANY)"
13948,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"int CnameTraits::Parse(
    QueryCnameWrap* wrap,
    const std::unique_ptr<ResponseData>& response) {
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Array> ret = Array::New(env->isolate());
  int type = ns_t_cname;
  int status = ParseGeneralReply(env, buf, len, &type, ret);
  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(ret);
  return 0;
}",1,1,cares_wrap.cc,node.cares_wrap.CnameTraits.Parse,,false,1148,1169,Parse,,,32,"int node.cares_wrap.CnameTraits.Parse (QueryCnameWrap*,ANY)"
14039,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"int MxTraits::Parse(
    QueryMxWrap* wrap,
    const std::unique_ptr<ResponseData>& response) {
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Array> mx_records = Array::New(env->isolate());
  int status = ParseMxReply(env, buf, len, mx_records);

  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(mx_records);
  return 0;
}",1,1,cares_wrap.cc,node.cares_wrap.MxTraits.Parse,,false,1171,1192,Parse,,,33,"int node.cares_wrap.MxTraits.Parse (QueryMxWrap*,ANY)"
14124,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"int NsTraits::Parse(
    QueryNsWrap* wrap,
    const std::unique_ptr<ResponseData>& response) {
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  int type = ns_t_ns;
  Local<Array> names = Array::New(env->isolate());
  int status = ParseGeneralReply(env, buf, len, &type, names);
  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(names);
  return 0;
}",1,1,cares_wrap.cc,node.cares_wrap.NsTraits.Parse,,false,1194,1215,Parse,,,34,"int node.cares_wrap.NsTraits.Parse (QueryNsWrap*,ANY)"
14215,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"int TxtTraits::Parse(
    QueryTxtWrap* wrap,
    const std::unique_ptr<ResponseData>& response) {
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Array> txt_records = Array::New(env->isolate());
  int status = ParseTxtReply(env, buf, len, txt_records);
  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(txt_records);
  return 0;
}",1,1,cares_wrap.cc,node.cares_wrap.TxtTraits.Parse,,false,1217,1237,Parse,,,35,"int node.cares_wrap.TxtTraits.Parse (QueryTxtWrap*,ANY)"
14300,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"int SrvTraits::Parse(
    QuerySrvWrap* wrap,
    const std::unique_ptr<ResponseData>& response) {
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Array> srv_records = Array::New(env->isolate());
  int status = ParseSrvReply(env, buf, len, srv_records);
  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(srv_records);
  return 0;
}",1,1,cares_wrap.cc,node.cares_wrap.SrvTraits.Parse,,false,1239,1259,Parse,,,36,"int node.cares_wrap.SrvTraits.Parse (QuerySrvWrap*,ANY)"
14385,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"int PtrTraits::Parse(
    QueryPtrWrap* wrap,
    const std::unique_ptr<ResponseData>& response) {
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  int type = ns_t_ptr;
  Local<Array> aliases = Array::New(env->isolate());

  int status = ParseGeneralReply(env, buf, len, &type, aliases);
  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(aliases);
  return 0;
}",1,1,cares_wrap.cc,node.cares_wrap.PtrTraits.Parse,,false,1261,1283,Parse,,,37,"int node.cares_wrap.PtrTraits.Parse (QueryPtrWrap*,ANY)"
14476,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"int NaptrTraits::Parse(
    QueryNaptrWrap* wrap,
    const std::unique_ptr<ResponseData>& response) {
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Array> naptr_records = Array::New(env->isolate());
  int status = ParseNaptrReply(env, buf, len, naptr_records);
  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(naptr_records);
  return 0;
}",1,1,cares_wrap.cc,node.cares_wrap.NaptrTraits.Parse,,false,1285,1305,Parse,,,38,"int node.cares_wrap.NaptrTraits.Parse (QueryNaptrWrap*,ANY)"
14561,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"int SoaTraits::Parse(
    QuerySoaWrap* wrap,
    const std::unique_ptr<ResponseData>& response) {
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  ares_soa_reply* soa_out;
  int status = ares_parse_soa_reply(buf, len, &soa_out);

  if (status != ARES_SUCCESS)
    return status;

  Local<Object> soa_record = Object::New(env->isolate());

  soa_record->Set(env->context(),
                  env->nsname_string(),
                  OneByteString(env->isolate(), soa_out->nsname)).Check();
  soa_record->Set(env->context(),
                  env->hostmaster_string(),
                  OneByteString(env->isolate(), soa_out->hostmaster)).Check();
  soa_record->Set(env->context(),
                  env->serial_string(),
                  Integer::NewFromUnsigned(
               ...",1,1,cares_wrap.cc,node.cares_wrap.SoaTraits.Parse,,false,1307,1356,Parse,,,39,"int node.cares_wrap.SoaTraits.Parse (QuerySoaWrap*,ANY)"
14825,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"int ReverseTraits::Send(GetHostByAddrWrap* wrap, const char* name) {
  int length, family;
  char address_buffer[sizeof(struct in6_addr)];

  if (uv_inet_pton(AF_INET, name, &address_buffer) == 0) {
    length = sizeof(struct in_addr);
    family = AF_INET;
  } else if (uv_inet_pton(AF_INET6, name, &address_buffer) == 0) {
    length = sizeof(struct in6_addr);
    family = AF_INET6;
  } else {
    return UV_EINVAL;  // So errnoException() reports a proper error.
  }

  TRACE_EVENT_NESTABLE_ASYNC_BEGIN2(
      TRACING_CATEGORY_NODE2(dns, native), ""reverse"", wrap,
      ""name"", TRACE_STR_COPY(name),
      ""family"", family == AF_INET ? ""ipv4"" : ""ipv6"");

  ares_gethostbyaddr(
      wrap->channel()->cares_channel(),
      address_buffer,
      length,
      family,
      GetHostByAddrWrap::Callback,
      wrap->MakeCallbackPointer());
  return 0;
}",1,1,cares_wrap.cc,node.cares_wrap.ReverseTraits.Send,,false,1358,1385,Send,,,40,"int node.cares_wrap.ReverseTraits.Send (GetHostByAddrWrap*,char*)"
14908,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"int ReverseTraits::Parse(
    GetHostByAddrWrap* wrap,
    const std::unique_ptr<ResponseData>& response) {
  if (UNLIKELY(!response->is_host))
    return ARES_EBADRESP;

  struct hostent* host = response->host.get();

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());
  wrap->CallOnComplete(HostentToNames(env, host));
  return 0;
}",1,1,cares_wrap.cc,node.cares_wrap.ReverseTraits.Parse,,false,1387,1400,Parse,,,41,"int node.cares_wrap.ReverseTraits.Parse (GetHostByAddrWrap*,ANY)"
14961,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"static void Query(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  ChannelWrap* channel;
  ASSIGN_OR_RETURN_UNWRAP(&channel, args.Holder());

  CHECK_EQ(false, args.IsConstructCall());
  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsString());

  Local<Object> req_wrap_obj = args[0].As<Object>();
  Local<String> string = args[1].As<String>();
  auto wrap = std::make_unique<Wrap>(channel, req_wrap_obj);

  node::Utf8Value utf8name(env->isolate(), string);
  auto plain_name = utf8name.ToStringView();
  std::string name = ada::idna::to_ascii(plain_name);
  channel->ModifyActivityQueryCount(1);
  int err = wrap->Send(name.c_str());
  if (err) {
    channel->ModifyActivityQueryCount(-1);
  } else {
    // Release ownership of the pointer allowing the ownership to be transferred
    USE(wrap.release());
  }

  args.GetReturnValue().Set(err);
}",1,1,cares_wrap.cc,node.cares_wrap.anonymous_namespace_21.Query,,false,1404,1430,Query,,,1,void node.cares_wrap.anonymous_namespace_21.Query<Wrap> (FunctionCallbackInfo<Value>)
15103,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"void AfterGetAddrInfo(uv_getaddrinfo_t* req, int status, struct addrinfo* res) {
  auto cleanup = OnScopeLeave([&]() { uv_freeaddrinfo(res); });
  BaseObjectPtr<GetAddrInfoReqWrap> req_wrap{
      static_cast<GetAddrInfoReqWrap*>(req->data)};
  Environment* env = req_wrap->env();

  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Value> argv[] = {
    Integer::New(env->isolate(), status),
    Null(env->isolate())
  };

  uint32_t n = 0;
  const bool verbatim = req_wrap->verbatim();

  if (status == 0) {
    Local<Array> results = Array::New(env->isolate());

    auto add = [&] (bool want_ipv4, bool want_ipv6) -> Maybe<bool> {
      for (auto p = res; p != nullptr; p = p->ai_next) {
        CHECK_EQ(p->ai_socktype, SOCK_STREAM);

        const char* addr;
        if (want_ipv4 && p->ai_family == AF_INET) {
          addr = reinterpret_cast<char*>(
              &(reinterpret_cast<struct sockaddr_in*>(p->ai_addr)->sin_addr));
        ...",1,1,cares_wrap.cc,node.cares_wrap.anonymous_namespace_22.AfterGetAddrInfo,,false,1433,1501,AfterGetAddrInfo,,,2,"void node.cares_wrap.anonymous_namespace_22.AfterGetAddrInfo (uv_getaddrinfo_t*,int,addrinfo*)"
15264,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"void AfterGetNameInfo(uv_getnameinfo_t* req,
                      int status,
                      const char* hostname,
                      const char* service) {
  BaseObjectPtr<GetNameInfoReqWrap> req_wrap{
      static_cast<GetNameInfoReqWrap*>(req->data)};
  Environment* env = req_wrap->env();

  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Value> argv[] = {
    Integer::New(env->isolate(), status),
    Null(env->isolate()),
    Null(env->isolate())
  };

  if (status == 0) {
    // Success
    Local<String> js_hostname = OneByteString(env->isolate(), hostname);
    Local<String> js_service = OneByteString(env->isolate(), service);
    argv[1] = js_hostname;
    argv[2] = js_service;
  }

  TRACE_EVENT_NESTABLE_ASYNC_END2(
      TRACING_CATEGORY_NODE2(dns, native), ""lookupService"", req_wrap.get(),
      ""hostname"", TRACE_STR_COPY(hostname),
      ""service"", TRACE_STR_COPY(service));

  // Make the callback into JavaScrip...",1,1,cares_wrap.cc,node.cares_wrap.anonymous_namespace_25.AfterGetNameInfo,,false,1504,1536,AfterGetNameInfo,,,3,"void node.cares_wrap.anonymous_namespace_25.AfterGetNameInfo (uv_getnameinfo_t*,int,char*,char*)"
15390,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"void CanonicalizeIP(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();
  node::Utf8Value ip(isolate, args[0]);

  int af;
  unsigned char result[sizeof(ares_addr_port_node::addr)];
  if (uv_inet_pton(af = AF_INET, *ip, result) != 0 &&
      uv_inet_pton(af = AF_INET6, *ip, result) != 0)
    return;

  char canonical_ip[INET6_ADDRSTRLEN];
  CHECK_EQ(0, uv_inet_ntop(af, result, canonical_ip, sizeof(canonical_ip)));
  Local<String> val = String::NewFromUtf8(isolate, canonical_ip)
      .ToLocalChecked();
  args.GetReturnValue().Set(val);
}",1,1,cares_wrap.cc,node.cares_wrap.anonymous_namespace_26.CanonicalizeIP,,false,1538,1553,CanonicalizeIP,,,4,void node.cares_wrap.anonymous_namespace_26.CanonicalizeIP (FunctionCallbackInfo<Value>)
15464,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"void GetAddrInfo(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsString());
  CHECK(args[2]->IsInt32());
  CHECK(args[4]->IsBoolean());
  Local<Object> req_wrap_obj = args[0].As<Object>();
  node::Utf8Value hostname(env->isolate(), args[1]);
  std::string ascii_hostname = ada::idna::to_ascii(hostname.ToStringView());

  int32_t flags = 0;
  if (args[3]->IsInt32()) {
    flags = args[3].As<Int32>()->Value();
  }

  int family;

  switch (args[2].As<Int32>()->Value()) {
    case 0:
      family = AF_UNSPEC;
      break;
    case 4:
      family = AF_INET;
      break;
    case 6:
      family = AF_INET6;
      break;
    default:
      UNREACHABLE(""bad address family"");
  }

  auto req_wrap = std::make_unique<GetAddrInfoReqWrap>(env,
                                                       req_wrap_obj,
                                                       args[4]->IsTrue());

  struct addr...",1,1,cares_wrap.cc,node.cares_wrap.anonymous_namespace_27.GetAddrInfo,,false,1555,1614,GetAddrInfo,,,5,void node.cares_wrap.anonymous_namespace_27.GetAddrInfo (FunctionCallbackInfo<Value>)
15697,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"void GetNameInfo(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsString());
  CHECK(args[2]->IsUint32());
  Local<Object> req_wrap_obj = args[0].As<Object>();
  node::Utf8Value ip(env->isolate(), args[1]);
  const unsigned port = args[2]->Uint32Value(env->context()).FromJust();
  struct sockaddr_storage addr;

  CHECK(uv_ip4_addr(*ip, port, reinterpret_cast<sockaddr_in*>(&addr)) == 0 ||
        uv_ip6_addr(*ip, port, reinterpret_cast<sockaddr_in6*>(&addr)) == 0);

  auto req_wrap = std::make_unique<GetNameInfoReqWrap>(env, req_wrap_obj);

  TRACE_EVENT_NESTABLE_ASYNC_BEGIN2(
      TRACING_CATEGORY_NODE2(dns, native), ""lookupService"", req_wrap.get(),
      ""ip"", TRACE_STR_COPY(*ip), ""port"", port);

  int err = req_wrap->Dispatch(uv_getnameinfo,
                               AfterGetNameInfo,
                               reinterpret_cast<struct sockaddr*>(&addr),
                       ...",1,1,cares_wrap.cc,node.cares_wrap.anonymous_namespace_29.GetNameInfo,,false,1617,1646,GetNameInfo,,,6,void node.cares_wrap.anonymous_namespace_29.GetNameInfo (FunctionCallbackInfo<Value>)
15851,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"void GetServers(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  ChannelWrap* channel;
  ASSIGN_OR_RETURN_UNWRAP(&channel, args.Holder());

  Local<Array> server_array = Array::New(env->isolate());

  ares_addr_port_node* servers;

  int r = ares_get_servers_ports(channel->cares_channel(), &servers);
  CHECK_EQ(r, ARES_SUCCESS);
  auto cleanup = OnScopeLeave([&]() { ares_free_data(servers); });

  ares_addr_port_node* cur = servers;

  for (uint32_t i = 0; cur != nullptr; ++i, cur = cur->next) {
    char ip[INET6_ADDRSTRLEN];

    const void* caddr = static_cast<const void*>(&cur->addr);
    int err = uv_inet_ntop(cur->family, caddr, ip, sizeof(ip));
    CHECK_EQ(err, 0);

    Local<Value> ret[] = {
      OneByteString(env->isolate(), ip),
      Integer::New(env->isolate(), cur->udp_port)
    };

    if (server_array->Set(env->context(), i,
                          Array::New(env->isolate(), ret, arraysize(ret)))
          .IsNothing(...",1,1,cares_wrap.cc,node.cares_wrap.anonymous_namespace_31.GetServers,,false,1649,1684,GetServers,,,7,void node.cares_wrap.anonymous_namespace_31.GetServers (FunctionCallbackInfo<Value>)
16005,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"void SetServers(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  ChannelWrap* channel;
  ASSIGN_OR_RETURN_UNWRAP(&channel, args.Holder());

  if (channel->active_query_count()) {
    return args.GetReturnValue().Set(DNS_ESETSRVPENDING);
  }

  CHECK(args[0]->IsArray());

  Local<Array> arr = args[0].As<Array>();

  uint32_t len = arr->Length();

  if (len == 0) {
    int rv = ares_set_servers(channel->cares_channel(), nullptr);
    return args.GetReturnValue().Set(rv);
  }

  std::vector<ares_addr_port_node> servers(len);
  ares_addr_port_node* last = nullptr;

  int err;

  for (uint32_t i = 0; i < len; i++) {
    CHECK(arr->Get(env->context(), i).ToLocalChecked()->IsArray());

    Local<Array> elm = arr->Get(env->context(), i).ToLocalChecked().As<Array>();

    CHECK(elm->Get(env->context(),
                   0).ToLocalChecked()->Int32Value(env->context()).FromJust());
    CHECK(elm->Get(env->context(), 1).ToLocalChecked()->IsString...",1,1,cares_wrap.cc,node.cares_wrap.anonymous_namespace_33.SetServers,,false,1687,1766,SetServers,,,8,void node.cares_wrap.anonymous_namespace_33.SetServers (FunctionCallbackInfo<Value>)
16401,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"void SetLocalAddress(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  ChannelWrap* channel;
  ASSIGN_OR_RETURN_UNWRAP(&channel, args.Holder());

  CHECK_EQ(args.Length(), 2);
  CHECK(args[0]->IsString());

  Isolate* isolate = args.GetIsolate();
  node::Utf8Value ip0(isolate, args[0]);

  unsigned char addr0[sizeof(struct in6_addr)];
  unsigned char addr1[sizeof(struct in6_addr)];
  int type0 = 0;

  // This function accepts 2 arguments.  The first may be either an IPv4
  // address or an IPv6 address.  If present, the second argument must be the
  // other type of address.  Otherwise, the unspecified type of IP is set
  // to 0 (any).

  if (uv_inet_pton(AF_INET, *ip0, &addr0) == 0) {
    ares_set_local_ip4(channel->cares_channel(), ReadUint32BE(addr0));
    type0 = 4;
  } else if (uv_inet_pton(AF_INET6, *ip0, &addr0) == 0) {
    ares_set_local_ip6(channel->cares_channel(), addr0);
    type0 = 6;
  } else {
    THROW_ERR_INVALID_ARG_V...",1,1,cares_wrap.cc,node.cares_wrap.anonymous_namespace_34.SetLocalAddress,,false,1768,1830,SetLocalAddress,,,9,void node.cares_wrap.anonymous_namespace_34.SetLocalAddress (FunctionCallbackInfo<Value>)
16613,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"void Cancel(const FunctionCallbackInfo<Value>& args) {
  ChannelWrap* channel;
  ASSIGN_OR_RETURN_UNWRAP(&channel, args.Holder());

  TRACE_EVENT_INSTANT0(TRACING_CATEGORY_NODE2(dns, native),
      ""cancel"", TRACE_EVENT_SCOPE_THREAD);

  ares_cancel(channel->cares_channel());
}",1,1,cares_wrap.cc,node.cares_wrap.anonymous_namespace_35.Cancel,,false,1832,1840,Cancel,,,10,void node.cares_wrap.anonymous_namespace_35.Cancel (FunctionCallbackInfo<Value>)
16641,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"void StrError(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  int code = args[0]->Int32Value(env->context()).FromJust();
  const char* errmsg = (code == DNS_ESETSRVPENDING) ?
    EMSG_ESETSRVPENDING :
    ares_strerror(code);
  args.GetReturnValue().Set(OneByteString(env->isolate(), errmsg));
}",1,1,cares_wrap.cc,node.cares_wrap.anonymous_namespace_36.StrError,,false,1843,1850,StrError,,,13,void node.cares_wrap.anonymous_namespace_36.StrError (FunctionCallbackInfo<Value>)
16693,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"inline void safe_free_hostent(struct hostent* host) {
  int idx;

  if (host->h_addr_list != nullptr) {
    idx = 0;
    while (host->h_addr_list[idx]) {
      free(host->h_addr_list[idx++]);
    }
    free(host->h_addr_list);
    host->h_addr_list = nullptr;
  }

  if (host->h_aliases != nullptr) {
    idx = 0;
    while (host->h_aliases[idx]) {
      free(host->h_aliases[idx++]);
    }
    free(host->h_aliases);
    host->h_aliases = nullptr;
  }

  free(host->h_name);
  free(host);
}",1,1,cares_wrap.cc,node.cares_wrap.safe_free_hostent,,false,1854,1877,safe_free_hostent,,,43,void node.cares_wrap.safe_free_hostent (hostent*)
16771,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"void Initialize(Local<Object> target,
                Local<Value> unused,
                Local<Context> context,
                void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  SetMethod(context, target, ""getaddrinfo"", GetAddrInfo);
  SetMethod(context, target, ""getnameinfo"", GetNameInfo);
  SetMethodNoSideEffect(context, target, ""canonicalizeIP"", CanonicalizeIP);

  SetMethod(context, target, ""strerror"", StrError);

  target->Set(env->context(), FIXED_ONE_BYTE_STRING(env->isolate(), ""AF_INET""),
              Integer::New(env->isolate(), AF_INET)).Check();
  target->Set(env->context(), FIXED_ONE_BYTE_STRING(env->isolate(), ""AF_INET6""),
              Integer::New(env->isolate(), AF_INET6)).Check();
  target->Set(env->context(), FIXED_ONE_BYTE_STRING(env->isolate(),
                                                    ""AF_UNSPEC""),
              Integer::New(env->isolate(), AF_UNSPEC)).Check();
  target->Set(env->context(),...",1,43,cares_wrap.cc,node.cares_wrap.Initialize,,false,1879,1951,Initialize,,,44,"void node.cares_wrap.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
17169,METHOD,cares_wrap.cc:<global>,TYPE_DECL,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(GetAddrInfo);
  registry->Register(GetNameInfo);
  registry->Register(CanonicalizeIP);
  registry->Register(StrError);
  registry->Register(ChannelWrap::New);

  registry->Register(Query<QueryAnyWrap>);
  registry->Register(Query<QueryAWrap>);
  registry->Register(Query<QueryAaaaWrap>);
  registry->Register(Query<QueryCaaWrap>);
  registry->Register(Query<QueryCnameWrap>);
  registry->Register(Query<QueryMxWrap>);
  registry->Register(Query<QueryNsWrap>);
  registry->Register(Query<QueryTxtWrap>);
  registry->Register(Query<QuerySrvWrap>);
  registry->Register(Query<QueryPtrWrap>);
  registry->Register(Query<QueryNaptrWrap>);
  registry->Register(Query<QuerySoaWrap>);
  registry->Register(Query<GetHostByAddrWrap>);

  registry->Register(GetServers);
  registry->Register(SetServers);
  registry->Register(SetLocalAddress);
  registry->Register(Cancel);
}",1,1,cares_wrap.cc,node.cares_wrap.RegisterExternalReferences,,false,1953,1978,RegisterExternalReferences,,,45,void node.cares_wrap.RegisterExternalReferences (ExternalReferenceRegistry*)
17316,METHOD,cares_wrap.hpp:<global>,TYPE_DECL,<global>,1,28,cares_wrap.hpp,cares_wrap.hpp:<global>,,false,1,524,<global>,,,1,
17321,METHOD,cjs_module_lexer_version.hpp:<global>,TYPE_DECL,<global>,1,42,cjs_module_lexer_version.hpp,cjs_module_lexer_version.hpp:<global>,,false,1,6,<global>,,,1,
17334,METHOD,cleanup_queue-inl.hpp:<global>,TYPE_DECL,<global>,1,35,cleanup_queue-inl.hpp,cleanup_queue-inl.hpp:<global>,,false,1,62,<global>,,,1,
17337,METHOD,cleanup_queue.cc:<global>,TYPE_DECL,"[](const CleanupHookCallback& a, const CleanupHookCallback& b) {
              // Sort in descending order so that the most recently inserted
              // callbacks are run first.
              return a.insertion_order_counter_ > b.insertion_order_counter_;
            }",13,13,cleanup_queue.cc,node.CleanupQueue.GetOrdered.<lambda>0,,false,18,22,<lambda>0,,,1,"ANY node.CleanupQueue.GetOrdered.<lambda>0 (CleanupHookCallback,CleanupHookCallback)"
17362,METHOD,cleanup_queue.cc:<global>,TYPE_DECL,<global>,1,31,cleanup_queue.hpp,cleanup_queue.cc:<global>,,false,1,52,<global>,,,1,
17365,METHOD,cleanup_queue.cc:<global>,TYPE_DECL,"std::vector<CleanupQueue::CleanupHookCallback> CleanupQueue::GetOrdered()
    const {
  // Copy into a vector, since we can't sort an unordered_set in-place.
  std::vector<CleanupHookCallback> callbacks(cleanup_hooks_.begin(),
                                             cleanup_hooks_.end());
  // We can't erase the copied elements from `cleanup_hooks_` yet, because we
  // need to be able to check whether they were un-scheduled by another hook.

  std::sort(callbacks.begin(),
            callbacks.end(),
            [](const CleanupHookCallback& a, const CleanupHookCallback& b) {
              // Sort in descending order so that the most recently inserted
              // callbacks are run first.
              return a.insertion_order_counter_ > b.insertion_order_counter_;
            });

  return callbacks;
}",1,1,cleanup_queue.cc,node.CleanupQueue.GetOrdered,,false,8,25,GetOrdered,,,1,vector<CleanupQueue::CleanupHookCallback> node.CleanupQueue.GetOrdered ()
17399,METHOD,cleanup_queue.cc:<global>,TYPE_DECL,"void CleanupQueue::Drain() {
  std::vector<CleanupHookCallback> callbacks = GetOrdered();

  for (const CleanupHookCallback& cb : callbacks) {
    if (cleanup_hooks_.count(cb) == 0) {
      // This hook was removed from the `cleanup_hooks_` set during another
      // hook that was run earlier. Nothing to do here.
      continue;
    }

    cb.fn_(cb.arg_);
    cleanup_hooks_.erase(cb);
  }
}",1,1,cleanup_queue.cc,node.CleanupQueue.Drain,,false,27,40,Drain,,,2,void node.CleanupQueue.Drain ()
17438,METHOD,cleanup_queue.cc:<global>,TYPE_DECL,"size_t CleanupQueue::CleanupHookCallback::Hash::operator()(
    const CleanupHookCallback& cb) const {
  return std::hash<void*>()(cb.arg_);
}",1,1,cleanup_queue.cc,node.CleanupQueue.CleanupHookCallback.Hash.operator (),,false,42,45,operator (),,,3,size_t node.CleanupQueue.CleanupHookCallback.Hash.operator () (CleanupHookCallback)
17452,METHOD,cleanup_queue.cc:<global>,TYPE_DECL,"bool CleanupQueue::CleanupHookCallback::Equal::operator()(
    const CleanupHookCallback& a, const CleanupHookCallback& b) const {
  return a.fn_ == b.fn_ && a.arg_ == b.arg_;
}",1,1,cleanup_queue.cc,node.CleanupQueue.CleanupHookCallback.Equal.operator (),,false,47,50,operator (),,,4,"bool node.CleanupQueue.CleanupHookCallback.Equal.operator () (CleanupHookCallback,CleanupHookCallback)"
17487,METHOD,cleanup_queue.hpp:<global>,TYPE_DECL,<global>,1,31,cleanup_queue.hpp,cleanup_queue.hpp:<global>,,false,1,85,<global>,,,1,
17496,METHOD,connect_wrap.cc:<global>,TYPE_DECL,<global>,1,30,connect_wrap.hpp,connect_wrap.cc:<global>,,false,1,16,<global>,,,1,
17500,METHOD,connect_wrap.cc:<global>,TYPE_DECL,"ConnectWrap::ConnectWrap(Environment* env,
    Local<Object> req_wrap_obj,
    AsyncWrap::ProviderType provider) : ReqWrap(env, req_wrap_obj, provider) {
}",1,1,connect_wrap.cc,node.ConnectWrap.ConnectWrap,,false,11,14,ConnectWrap,,,2,"ANY node.ConnectWrap.ConnectWrap (Environment*,Local<Object>,ANY)"
17514,METHOD,connect_wrap.hpp:<global>,TYPE_DECL,<global>,1,30,connect_wrap.hpp,connect_wrap.hpp:<global>,,false,1,26,<global>,,,1,
17535,METHOD,connection_wrap.cc:<global>,TYPE_DECL,<global>,1,33,connection_wrap.hpp,connection_wrap.cc:<global>,,false,1,142,<global>,,,1,
17538,METHOD,connection_wrap.cc:<global>,TYPE_DECL,"ConnectionWrap<WrapType, UVType>::ConnectionWrap(Environment* env,
                                                 Local<Object> object,
                                                 ProviderType provider)
    : LibuvStreamWrap(env,
                      object,
                      reinterpret_cast<uv_stream_t*>(&handle_),
                      provider) {}",1,34,connection_wrap.cc,"node.ConnectionWrap<WrapType,UVType>.ConnectionWrap",,false,23,29,ConnectionWrap,,,1,"ANY node.ConnectionWrap<WrapType,UVType>.ConnectionWrap<WrapType,UVType> (Environment*,Local<Object>,ProviderType)"
17545,METHOD,connection_wrap.cc:<global>,TYPE_DECL,"void ConnectionWrap<WrapType, UVType>::OnConnection(uv_stream_t* handle,
                                                    int status) {
  WrapType* wrap_data = static_cast<WrapType*>(handle->data);
  CHECK_NOT_NULL(wrap_data);
  CHECK_EQ(&wrap_data->handle_, reinterpret_cast<UVType*>(handle));

  Environment* env = wrap_data->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  // We should not be getting this callback if someone has already called
  // uv_close() on the handle.
  CHECK_EQ(wrap_data->persistent().IsEmpty(), false);

  Local<Value> client_handle;

  if (status == 0) {
    // Instantiate the client javascript object and handle.
    Local<Object> client_obj;
    if (!WrapType::Instantiate(env, wrap_data, WrapType::SOCKET)
             .ToLocal(&client_obj))
      return;

    // Unwrap the client javascript object.
    WrapType* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, client_obj);
    uv_stream_t* client = reinterpre...",1,1,connection_wrap.cc,"node.ConnectionWrap<WrapType,UVType>.OnConnection",,false,33,74,OnConnection,,,2,"void node.ConnectionWrap<WrapType,UVType>.OnConnection<WrapType,UVType> (uv_stream_t*,int)"
17687,METHOD,connection_wrap.cc:<global>,TYPE_DECL,"void ConnectionWrap<WrapType, UVType>::AfterConnect(uv_connect_t* req,
                                                    int status) {
  BaseObjectPtr<ConnectWrap> req_wrap{static_cast<ConnectWrap*>(req->data)};
  CHECK(req_wrap);
  WrapType* wrap = static_cast<WrapType*>(req->handle->data);
  CHECK_EQ(req_wrap->env(), wrap->env());
  Environment* env = wrap->env();

  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  // The wrap and request objects should still be there.
  CHECK_EQ(req_wrap->persistent().IsEmpty(), false);
  CHECK_EQ(wrap->persistent().IsEmpty(), false);

  bool readable, writable;

  if (status) {
    readable = writable = false;
  } else {
    readable = uv_is_readable(req->handle) != 0;
    writable = uv_is_writable(req->handle) != 0;
  }

  Local<Value> argv[5] = {
    Integer::New(env->isolate(), status),
    wrap->object(),
    req_wrap->object(),
    Boolean::New(env->isolate(), readable),
    Boolean::New(env->is...",1,1,connection_wrap.cc,"node.ConnectionWrap<WrapType,UVType>.AfterConnect",,false,78,117,AfterConnect,,,3,"void node.ConnectionWrap<WrapType,UVType>.AfterConnect<WrapType,UVType> (uv_connect_t*,int)"
17824,METHOD,connection_wrap.hpp:<global>,TYPE_DECL,<global>,1,33,connection_wrap.hpp,connection_wrap.hpp:<global>,,false,1,30,<global>,,,1,
17855,METHOD,crypto\crypto_aes.cc:<global>,TYPE_DECL,<global>,1,35,crypto\crypto_aes.hpp,crypto\crypto_aes.cc:<global>,,false,1,604,<global>,,,1,
17860,METHOD,crypto\crypto_aes.cc:<global>,TYPE_DECL,"WebCryptoCipherStatus AES_Cipher(
    Environment* env,
    KeyObjectData* key_data,
    WebCryptoCipherMode cipher_mode,
    const AESCipherConfig& params,
    const ByteSource& in,
    ByteSource* out) {
  CHECK_NOT_NULL(key_data);
  CHECK_EQ(key_data->GetKeyType(), kKeyTypeSecret);

  const int mode = EVP_CIPHER_mode(params.cipher);

  CipherCtxPointer ctx(EVP_CIPHER_CTX_new());
  EVP_CIPHER_CTX_init(ctx.get());
  if (mode == EVP_CIPH_WRAP_MODE)
    EVP_CIPHER_CTX_set_flags(ctx.get(), EVP_CIPHER_CTX_FLAG_WRAP_ALLOW);

  const bool encrypt = cipher_mode == kWebCryptoCipherEncrypt;

  if (!EVP_CipherInit_ex(
          ctx.get(),
          params.cipher,
          nullptr,
          nullptr,
          nullptr,
          encrypt)) {
    // Cipher init failed
    return WebCryptoCipherStatus::FAILED;
  }

  if (mode == EVP_CIPH_GCM_MODE && !EVP_CIPHER_CTX_ctrl(
        ctx.get(),
        EVP_CTRL_AEAD_SET_IVLEN,
        params.iv.size(),
        nullptr)) {
    return WebCryptoCipherS...",1,1,crypto\crypto_aes.cc,node.crypto.anonymous_namespace_1.AES_Cipher,,false,34,171,AES_Cipher,,,1,"WebCryptoCipherStatus node.crypto.anonymous_namespace_1.AES_Cipher (Environment*,KeyObjectData*,WebCryptoCipherMode,AESCipherConfig,ByteSource,ByteSource*)"
18231,METHOD,crypto\crypto_aes.cc:<global>,TYPE_DECL,"T CeilDiv(T a, T b) {
  return a == 0 ? 0 : 1 + (a - 1) / b;
}",1,1,crypto\crypto_aes.cc,node.crypto.anonymous_namespace_2.CeilDiv,,false,178,180,CeilDiv,,,2,"T node.crypto.anonymous_namespace_2.CeilDiv<T> (T,T)"
18250,METHOD,crypto\crypto_aes.cc:<global>,TYPE_DECL,"BignumPointer GetCounter(const AESCipherConfig& params) {
  unsigned int remainder = (params.length % CHAR_BIT);
  const unsigned char* data = params.iv.data<unsigned char>();

  if (remainder == 0) {
    unsigned int byte_length = params.length / CHAR_BIT;
    return BignumPointer(BN_bin2bn(
        data + params.iv.size() - byte_length,
        byte_length,
        nullptr));
  }

  unsigned int byte_length =
      CeilDiv(params.length, static_cast<size_t>(CHAR_BIT));

  std::vector<unsigned char> counter(
      data + params.iv.size() - byte_length,
      data + params.iv.size());
  counter[0] &= ~(0xFF << remainder);

  return BignumPointer(BN_bin2bn(counter.data(), counter.size(), nullptr));
}",1,1,crypto\crypto_aes.cc,node.crypto.anonymous_namespace_3.GetCounter,,false,182,203,GetCounter,,,3,BignumPointer node.crypto.anonymous_namespace_3.GetCounter (AESCipherConfig)
18350,METHOD,crypto\crypto_aes.cc:<global>,TYPE_DECL,"std::vector<unsigned char> BlockWithZeroedCounter(
    const AESCipherConfig& params) {
  unsigned int length_bytes = params.length / CHAR_BIT;
  unsigned int remainder = params.length % CHAR_BIT;

  const unsigned char* data = params.iv.data<unsigned char>();

  std::vector<unsigned char> new_counter_block(data, data + params.iv.size());

  size_t index = new_counter_block.size() - length_bytes;
  memset(&new_counter_block.front() + index, 0, length_bytes);

  if (remainder)
    new_counter_block[index - 1] &= 0xFF << remainder;

  return new_counter_block;
}",1,1,crypto\crypto_aes.cc,node.crypto.anonymous_namespace_4.BlockWithZeroedCounter,,false,205,221,BlockWithZeroedCounter,,,4,vector<unsigned char> node.crypto.anonymous_namespace_4.BlockWithZeroedCounter (AESCipherConfig)
18424,METHOD,crypto\crypto_aes.cc:<global>,TYPE_DECL,"WebCryptoCipherStatus AES_CTR_Cipher2(
    KeyObjectData* key_data,
    WebCryptoCipherMode cipher_mode,
    const AESCipherConfig& params,
    const ByteSource& in,
    unsigned const char* counter,
    unsigned char* out) {
  CipherCtxPointer ctx(EVP_CIPHER_CTX_new());
  const bool encrypt = cipher_mode == kWebCryptoCipherEncrypt;

  if (!EVP_CipherInit_ex(
          ctx.get(),
          params.cipher,
          nullptr,
          reinterpret_cast<const unsigned char*>(key_data->GetSymmetricKey()),
          counter,
          encrypt)) {
    // Cipher init failed
    return WebCryptoCipherStatus::FAILED;
  }

  int out_len = 0;
  int final_len = 0;
  if (!EVP_CipherUpdate(
          ctx.get(),
          out,
          &out_len,
          in.data<unsigned char>(),
          in.size())) {
    return WebCryptoCipherStatus::FAILED;
  }

  if (!EVP_CipherFinal_ex(ctx.get(), out + out_len, &final_len))
    return WebCryptoCipherStatus::FAILED;

  out_len += final_len;
  if (static_cast...",1,1,crypto\crypto_aes.cc,node.crypto.anonymous_namespace_5.AES_CTR_Cipher2,,false,223,263,AES_CTR_Cipher2,,,5,"WebCryptoCipherStatus node.crypto.anonymous_namespace_5.AES_CTR_Cipher2 (KeyObjectData*,WebCryptoCipherMode,AESCipherConfig,ByteSource,unsigned char*,unsigned char*)"
18536,METHOD,crypto\crypto_aes.cc:<global>,TYPE_DECL,"WebCryptoCipherStatus AES_CTR_Cipher(
    Environment* env,
    KeyObjectData* key_data,
    WebCryptoCipherMode cipher_mode,
    const AESCipherConfig& params,
    const ByteSource& in,
    ByteSource* out) {
  BignumPointer num_counters(BN_new());
  if (!BN_lshift(num_counters.get(), BN_value_one(), params.length))
    return WebCryptoCipherStatus::FAILED;

  BignumPointer current_counter = GetCounter(params);

  BignumPointer num_output(BN_new());

  if (!BN_set_word(num_output.get(), CeilDiv(in.size(), kAesBlockSize)))
    return WebCryptoCipherStatus::FAILED;

  // Just like in chromium's implementation, if the counter will
  // be incremented more than there are counter values, we fail.
  if (BN_cmp(num_output.get(), num_counters.get()) > 0)
    return WebCryptoCipherStatus::FAILED;

  BignumPointer remaining_until_reset(BN_new());
  if (!BN_sub(remaining_until_reset.get(),
              num_counters.get(),
              current_counter.get())) {
    return WebCryptoCipherStat...",1,1,crypto\crypto_aes.cc,node.crypto.anonymous_namespace_6.AES_CTR_Cipher,,false,265,343,AES_CTR_Cipher,,,6,"WebCryptoCipherStatus node.crypto.anonymous_namespace_6.AES_CTR_Cipher (Environment*,KeyObjectData*,WebCryptoCipherMode,AESCipherConfig,ByteSource,ByteSource*)"
18794,METHOD,crypto\crypto_aes.cc:<global>,TYPE_DECL,"bool ValidateIV(
    Environment* env,
    CryptoJobMode mode,
    Local<Value> value,
    AESCipherConfig* params) {
  ArrayBufferOrViewContents<char> iv(value);
  if (UNLIKELY(!iv.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""iv is too big"");
    return false;
  }
  params->iv = (mode == kCryptoJobAsync)
      ? iv.ToCopy()
      : iv.ToByteSource();
  return true;
}",1,1,crypto\crypto_aes.cc,node.crypto.anonymous_namespace_9.ValidateIV,,false,345,359,ValidateIV,,,7,"bool node.crypto.anonymous_namespace_9.ValidateIV (Environment*,CryptoJobMode,Local<Value>,AESCipherConfig*)"
18836,METHOD,crypto\crypto_aes.cc:<global>,TYPE_DECL,"bool ValidateCounter(
  Environment* env,
  Local<Value> value,
  AESCipherConfig* params) {
  CHECK(value->IsUint32());  // Length
  params->length = value.As<Uint32>()->Value();
  if (params->iv.size() != 16 ||
      params->length == 0 ||
      params->length > 128) {
    THROW_ERR_CRYPTO_INVALID_COUNTER(env);
    return false;
  }
  return true;
}",1,1,crypto\crypto_aes.cc,node.crypto.anonymous_namespace_10.ValidateCounter,,false,361,374,ValidateCounter,,,8,"bool node.crypto.anonymous_namespace_10.ValidateCounter (Environment*,Local<Value>,AESCipherConfig*)"
18887,METHOD,crypto\crypto_aes.cc:<global>,TYPE_DECL,"bool ValidateAuthTag(
    Environment* env,
    CryptoJobMode mode,
    WebCryptoCipherMode cipher_mode,
    Local<Value> value,
    AESCipherConfig* params) {
  switch (cipher_mode) {
    case kWebCryptoCipherDecrypt: {
      if (!IsAnyByteSource(value)) {
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }
      ArrayBufferOrViewContents<char> tag_contents(value);
      if (UNLIKELY(!tag_contents.CheckSizeInt32())) {
        THROW_ERR_OUT_OF_RANGE(env, ""tagLength is too big"");
        return false;
      }
      params->tag = mode == kCryptoJobAsync
          ? tag_contents.ToCopy()
          : tag_contents.ToByteSource();
      break;
    }
    case kWebCryptoCipherEncrypt: {
      if (!value->IsUint32()) {
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }
      params->length = value.As<Uint32>()->Value();
      if (params->length > 128) {
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }
   ...",1,1,crypto\crypto_aes.cc,node.crypto.anonymous_namespace_11.ValidateAuthTag,,false,376,414,ValidateAuthTag,,,9,"bool node.crypto.anonymous_namespace_11.ValidateAuthTag (Environment*,CryptoJobMode,WebCryptoCipherMode,Local<Value>,AESCipherConfig*)"
18985,METHOD,crypto\crypto_aes.cc:<global>,TYPE_DECL,"bool ValidateAdditionalData(
    Environment* env,
    CryptoJobMode mode,
    Local<Value> value,
    AESCipherConfig* params) {
  // Additional Data
  if (IsAnyByteSource(value)) {
    ArrayBufferOrViewContents<char> additional(value);
    if (UNLIKELY(!additional.CheckSizeInt32())) {
      THROW_ERR_OUT_OF_RANGE(env, ""additionalData is too big"");
      return false;
    }
    params->additional_data = mode == kCryptoJobAsync
        ? additional.ToCopy()
        : additional.ToByteSource();
  }
  return true;
}",1,1,crypto\crypto_aes.cc,node.crypto.anonymous_namespace_12.ValidateAdditionalData,,false,416,433,ValidateAdditionalData,,,10,"bool node.crypto.anonymous_namespace_12.ValidateAdditionalData (Environment*,CryptoJobMode,Local<Value>,AESCipherConfig*)"
19031,METHOD,crypto\crypto_aes.cc:<global>,TYPE_DECL,"void UseDefaultIV(AESCipherConfig* params) {
  params->iv = ByteSource::Foreign(kDefaultWrapIV, strlen(kDefaultWrapIV));
}",1,1,crypto\crypto_aes.cc,node.crypto.anonymous_namespace_13.UseDefaultIV,,false,435,437,UseDefaultIV,,,11,void node.crypto.anonymous_namespace_13.UseDefaultIV (AESCipherConfig*)
19047,METHOD,crypto\crypto_aes.cc:<global>,TYPE_DECL,"AESCipherConfig::AESCipherConfig(AESCipherConfig&& other) noexcept
    : mode(other.mode),
      variant(other.variant),
      cipher(other.cipher),
      length(other.length),
      iv(std::move(other.iv)),
      additional_data(std::move(other.additional_data)),
      tag(std::move(other.tag)) {}",1,34,crypto\crypto_aes.cc,node.crypto.AESCipherConfig.AESCipherConfig,,false,440,447,AESCipherConfig,,,2,ANY node.crypto.AESCipherConfig.AESCipherConfig (AESCipherConfig)
19052,METHOD,crypto\crypto_aes.cc:<global>,TYPE_DECL,"AESCipherConfig& AESCipherConfig::operator=(AESCipherConfig&& other) noexcept {
  if (&other == this) return *this;
  this->~AESCipherConfig();
  return *new (this) AESCipherConfig(std::move(other));
}",1,1,crypto\crypto_aes.cc,node.crypto.AESCipherConfig.operator =,,false,449,453,operator =,,,3,AESCipherConfig node.crypto.AESCipherConfig.operator = (AESCipherConfig)
19080,METHOD,crypto\crypto_aes.cc:<global>,TYPE_DECL,"void AESCipherConfig::MemoryInfo(MemoryTracker* tracker) const {
  // If mode is sync, then the data in each of these properties
  // is not owned by the AESCipherConfig, so we ignore it.
  if (mode == kCryptoJobAsync) {
    tracker->TrackFieldWithSize(""iv"", iv.size());
    tracker->TrackFieldWithSize(""additional_data"", additional_data.size());
    tracker->TrackFieldWithSize(""tag"", tag.size());
  }
}",1,1,crypto\crypto_aes.cc,node.crypto.AESCipherConfig.MemoryInfo,,false,455,463,MemoryInfo,,,4,void node.crypto.AESCipherConfig.MemoryInfo (MemoryTracker*)
19117,METHOD,crypto\crypto_aes.cc:<global>,TYPE_DECL,"Maybe<bool> AESCipherTraits::AdditionalConfig(
    CryptoJobMode mode,
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset,
    WebCryptoCipherMode cipher_mode,
    AESCipherConfig* params) {
  Environment* env = Environment::GetCurrent(args);

  params->mode = mode;

  CHECK(args[offset]->IsUint32());  // Key Variant
  params->variant =
      static_cast<AESKeyVariant>(args[offset].As<Uint32>()->Value());

  int cipher_nid;

  switch (params->variant) {
    case kKeyVariantAES_CTR_128:
      if (!ValidateIV(env, mode, args[offset + 1], params) ||
          !ValidateCounter(env, args[offset + 2], params)) {
        return Nothing<bool>();
      }
      cipher_nid = NID_aes_128_ctr;
      break;
    case kKeyVariantAES_CTR_192:
      if (!ValidateIV(env, mode, args[offset + 1], params) ||
          !ValidateCounter(env, args[offset + 2], params)) {
        return Nothing<bool>();
      }
      cipher_nid = NID_aes_192_ctr;
      break;
    case kKeyVariantAES_CTR_256...",1,1,crypto\crypto_aes.cc,node.crypto.AESCipherTraits.AdditionalConfig,,false,465,571,AdditionalConfig,,,5,"Maybe<bool> node.crypto.AESCipherTraits.AdditionalConfig (CryptoJobMode,FunctionCallbackInfo<Value>,unsigned int,WebCryptoCipherMode,AESCipherConfig*)"
19511,METHOD,crypto\crypto_aes.cc:<global>,TYPE_DECL,"WebCryptoCipherStatus AESCipherTraits::DoCipher(
    Environment* env,
    std::shared_ptr<KeyObjectData> key_data,
    WebCryptoCipherMode cipher_mode,
    const AESCipherConfig& params,
    const ByteSource& in,
    ByteSource* out) {
#define V(name, fn)                                                           \
  case kKeyVariantAES_ ## name:                                               \
    return fn(env, key_data.get(), cipher_mode, params, in, out);
  switch (params.variant) {
    VARIANTS(V)
    default:
      UNREACHABLE();
  }
#undef V
}",1,1,crypto\crypto_aes.cc,node.crypto.AESCipherTraits.DoCipher,,false,573,589,DoCipher,,,6,"WebCryptoCipherStatus node.crypto.AESCipherTraits.DoCipher (Environment*,ANY,WebCryptoCipherMode,AESCipherConfig,ByteSource,ByteSource*)"
19530,METHOD,crypto\crypto_aes.cc:<global>,TYPE_DECL,"void AES::Initialize(Environment* env, Local<Object> target) {
  AESCryptoJob::Initialize(env, target);

#define V(name, _) NODE_DEFINE_CONSTANT(target, kKeyVariantAES_ ## name);
  VARIANTS(V)
#undef V
}",1,1,crypto\crypto_aes.cc,node.crypto.AES.Initialize,,false,591,597,Initialize,,,7,"void node.crypto.AES.Initialize (Environment*,Local<Object>)"
19544,METHOD,crypto\crypto_aes.cc:<global>,TYPE_DECL,"void AES::RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  AESCryptoJob::RegisterExternalReferences(registry);
}",1,1,crypto\crypto_aes.cc,node.crypto.AES.RegisterExternalReferences,,false,599,601,RegisterExternalReferences,,,8,void node.crypto.AES.RegisterExternalReferences (ExternalReferenceRegistry*)
19567,METHOD,crypto\crypto_aes.hpp:<global>,TYPE_DECL,<global>,1,35,crypto\crypto_aes.hpp,crypto\crypto_aes.hpp:<global>,,false,1,89,<global>,,,1,
19570,METHOD,crypto\crypto_bio.cc:<global>,TYPE_DECL,"[&]() {
    BIO_METHOD* method = BIO_meth_new(BIO_TYPE_MEM, ""node.js SSL buffer"");
    BIO_meth_set_write(method, Write);
    BIO_meth_set_read(method, Read);
    BIO_meth_set_puts(method, Puts);
    BIO_meth_set_gets(method, Gets);
    BIO_meth_set_ctrl(method, Ctrl);
    BIO_meth_set_create(method, New);
    BIO_meth_set_destroy(method, Free);
    return method;
  }",37,3,crypto\crypto_bio.cc,node.crypto.NodeBIO.GetMethod.<lambda>0,,false,224,234,<lambda>0,,,1,ANY node.crypto.NodeBIO.GetMethod.<lambda>0 ()
19620,METHOD,crypto\crypto_bio.cc:<global>,TYPE_DECL,<global>,1,1,crypto\crypto_bio.cc,crypto\crypto_bio.cc:<global>,,false,1,500,<global>,,,1,
19624,METHOD,crypto\crypto_bio.cc:<global>,TYPE_DECL,"BIOPointer NodeBIO::New(Environment* env) {
  BIOPointer bio(BIO_new(GetMethod()));
  if (bio && env != nullptr)
    NodeBIO::FromBIO(bio.get())->env_ = env;
  return bio;
}",1,1,crypto\crypto_bio.cc,node.crypto.NodeBIO.New,,false,35,40,New,,,1,BIOPointer node.crypto.NodeBIO.New (Environment*)
19627,METHOD,crypto\crypto_bio.cc:<global>,TYPE_DECL,BIOPointer bio(BIO_new(GetMethod()));,14,38,crypto\crypto_bio.cc,node.crypto.NodeBIO.New.bio,,false,36,36,bio,,,1,BIOPointer node.crypto.NodeBIO.New.bio (BIO_new)
19655,METHOD,crypto\crypto_bio.cc:<global>,TYPE_DECL,"BIOPointer NodeBIO::NewFixed(const char* data, size_t len, Environment* env) {
  BIOPointer bio = New(env);

  if (!bio ||
      len > INT_MAX ||
      BIO_write(bio.get(), data, len) != static_cast<int>(len) ||
      BIO_set_mem_eof_return(bio.get(), 0) != 1) {
    return BIOPointer();
  }

  return bio;
}",1,1,crypto\crypto_bio.cc,node.crypto.NodeBIO.NewFixed,,false,43,54,NewFixed,,,2,"BIOPointer node.crypto.NodeBIO.NewFixed (char*,size_t,Environment*)"
19700,METHOD,crypto\crypto_bio.cc:<global>,TYPE_DECL,"int NodeBIO::New(BIO* bio) {
  BIO_set_data(bio, new NodeBIO());
  BIO_set_init(bio, 1);

  return 1;
}",1,1,crypto\crypto_bio.cc,node.crypto.NodeBIO.New,,false,57,62,New,,,3,int node.crypto.NodeBIO.New (BIO*)
19714,METHOD,crypto\crypto_bio.cc:<global>,TYPE_DECL,"int NodeBIO::Free(BIO* bio) {
  if (bio == nullptr)
    return 0;

  if (BIO_get_shutdown(bio)) {
    if (BIO_get_init(bio) && BIO_get_data(bio) != nullptr) {
      delete FromBIO(bio);
      BIO_set_data(bio, nullptr);
    }
  }

  return 1;
}",1,1,crypto\crypto_bio.cc,node.crypto.NodeBIO.Free,,false,65,77,Free,,,4,int node.crypto.NodeBIO.Free (BIO*)
19747,METHOD,crypto\crypto_bio.cc:<global>,TYPE_DECL,"int NodeBIO::Read(BIO* bio, char* out, int len) {
  BIO_clear_retry_flags(bio);

  NodeBIO* nbio = FromBIO(bio);
  int bytes = nbio->Read(out, len);

  if (bytes == 0) {
    bytes = nbio->eof_return();
    if (bytes != 0) {
      BIO_set_retry_read(bio);
    }
  }

  return bytes;
}",1,1,crypto\crypto_bio.cc,node.crypto.NodeBIO.Read,,false,80,94,Read,,,5,"int node.crypto.NodeBIO.Read (BIO*,char*,int)"
19790,METHOD,crypto\crypto_bio.cc:<global>,TYPE_DECL,"char* NodeBIO::Peek(size_t* size) {
  *size = read_head_->write_pos_ - read_head_->read_pos_;
  return read_head_->data_ + read_head_->read_pos_;
}",1,1,crypto\crypto_bio.cc,node.crypto.NodeBIO.Peek,,false,97,100,Peek,,,6,char* node.crypto.NodeBIO.Peek (size_t*)
19813,METHOD,crypto\crypto_bio.cc:<global>,TYPE_DECL,"size_t NodeBIO::PeekMultiple(char** out, size_t* size, size_t* count) {
  Buffer* pos = read_head_;
  size_t max = *count;
  size_t total = 0;

  size_t i;
  for (i = 0; i < max; i++) {
    size[i] = pos->write_pos_ - pos->read_pos_;
    total += size[i];
    out[i] = pos->data_ + pos->read_pos_;

    /* Don't get past write head */
    if (pos == write_head_)
      break;
    else
      pos = pos->next_;
  }

  if (i == max)
    *count = i;
  else
    *count = i + 1;

  return total;
}",1,1,crypto\crypto_bio.cc,node.crypto.NodeBIO.PeekMultiple,,false,103,127,PeekMultiple,,,7,"size_t node.crypto.NodeBIO.PeekMultiple (char**,size_t*,size_t*)"
19904,METHOD,crypto\crypto_bio.cc:<global>,TYPE_DECL,"int NodeBIO::Write(BIO* bio, const char* data, int len) {
  BIO_clear_retry_flags(bio);

  FromBIO(bio)->Write(data, len);

  return len;
}",1,1,crypto\crypto_bio.cc,node.crypto.NodeBIO.Write,,false,130,136,Write,,,8,"int node.crypto.NodeBIO.Write (BIO*,char*,int)"
19922,METHOD,crypto\crypto_bio.cc:<global>,TYPE_DECL,"int NodeBIO::Puts(BIO* bio, const char* str) {
  return Write(bio, str, strlen(str));
}",1,1,crypto\crypto_bio.cc,node.crypto.NodeBIO.Puts,,false,139,141,Puts,,,9,"int node.crypto.NodeBIO.Puts (BIO*,char*)"
19934,METHOD,crypto\crypto_bio.cc:<global>,TYPE_DECL,"int NodeBIO::Gets(BIO* bio, char* out, int size) {
  NodeBIO* nbio = FromBIO(bio);

  if (nbio->Length() == 0)
    return 0;

  int i = nbio->IndexOf('\n', size);

  // Include '\n', if it's there.  If not, don't read off the end.
  if (i < size && i >= 0 && static_cast<size_t>(i) < nbio->Length())
    i++;

  // Shift `i` a bit to nullptr-terminate string later
  if (size == i)
    i--;

  // Flush read data
  nbio->Read(out, i);

  out[i] = 0;

  return i;
}",1,1,crypto\crypto_bio.cc,node.crypto.NodeBIO.Gets,,false,144,166,Gets,,,10,"int node.crypto.NodeBIO.Gets (BIO*,char*,int)"
20005,METHOD,crypto\crypto_bio.cc:<global>,TYPE_DECL,"long NodeBIO::Ctrl(BIO* bio, int cmd, long num,  // NOLINT(runtime/int)
                   void* ptr) {
  NodeBIO* nbio;
  long ret;  // NOLINT(runtime/int)

  nbio = FromBIO(bio);
  ret = 1;

  switch (cmd) {
    case BIO_CTRL_RESET:
      nbio->Reset();
      break;
    case BIO_CTRL_EOF:
      ret = nbio->Length() == 0;
      break;
    case BIO_C_SET_BUF_MEM_EOF_RETURN:
      nbio->set_eof_return(num);
      break;
    case BIO_CTRL_INFO:
      ret = nbio->Length();
      if (ptr != nullptr)
        *reinterpret_cast<void**>(ptr) = nullptr;
      break;
    case BIO_C_SET_BUF_MEM:
      UNREACHABLE(""Can't use SET_BUF_MEM_PTR with NodeBIO"");
    case BIO_C_GET_BUF_MEM_PTR:
      UNREACHABLE(""Can't use GET_BUF_MEM_PTR with NodeBIO"");
    case BIO_CTRL_GET_CLOSE:
      ret = BIO_get_shutdown(bio);
      break;
    case BIO_CTRL_SET_CLOSE:
      BIO_set_shutdown(bio, num);
      break;
    case BIO_CTRL_WPENDING:
      ret = 0;
      break;
    case BIO_CTRL_PENDING:
      ret = nbi...",1,1,crypto\crypto_bio.cc,node.crypto.NodeBIO.Ctrl,,false,169,219,Ctrl,,,11,"long node.crypto.NodeBIO.Ctrl (BIO*,int,long,void*)"
20126,METHOD,crypto\crypto_bio.cc:<global>,TYPE_DECL,"const BIO_METHOD* NodeBIO::GetMethod() {
  // Static initialization ensures that this is safe to use concurrently.
  static const BIO_METHOD* method = [&]() {
    BIO_METHOD* method = BIO_meth_new(BIO_TYPE_MEM, ""node.js SSL buffer"");
    BIO_meth_set_write(method, Write);
    BIO_meth_set_read(method, Read);
    BIO_meth_set_puts(method, Puts);
    BIO_meth_set_gets(method, Gets);
    BIO_meth_set_ctrl(method, Ctrl);
    BIO_meth_set_create(method, New);
    BIO_meth_set_destroy(method, Free);
    return method;
  }();

  return method;
}",1,1,crypto\crypto_bio.cc,node.crypto.NodeBIO.GetMethod,,false,222,237,GetMethod,,,12,BIO_METHOD node.crypto.NodeBIO.GetMethod ()
20137,METHOD,crypto\crypto_bio.cc:<global>,TYPE_DECL,"void NodeBIO::TryMoveReadHead() {
  // `read_pos_` and `write_pos_` means the position of the reader and writer
  // inside the buffer, respectively. When they're equal - its safe to reset
  // them, because both reader and writer will continue doing their stuff
  // from new (zero) positions.
  while (read_head_->read_pos_ != 0 &&
         read_head_->read_pos_ == read_head_->write_pos_) {
    // Reset positions
    read_head_->read_pos_ = 0;
    read_head_->write_pos_ = 0;

    // Move read_head_ forward, just in case if there're still some data to
    // read in the next buffer.
    if (read_head_ != write_head_)
      read_head_ = read_head_->next_;
  }
}",1,1,crypto\crypto_bio.cc,node.crypto.NodeBIO.TryMoveReadHead,,false,240,256,TryMoveReadHead,,,13,void node.crypto.NodeBIO.TryMoveReadHead ()
20176,METHOD,crypto\crypto_bio.cc:<global>,TYPE_DECL,"size_t NodeBIO::Read(char* out, size_t size) {
  size_t bytes_read = 0;
  size_t expected = Length() > size ? size : Length();
  size_t offset = 0;
  size_t left = size;

  while (bytes_read < expected) {
    CHECK_LE(read_head_->read_pos_, read_head_->write_pos_);
    size_t avail = read_head_->write_pos_ - read_head_->read_pos_;
    if (avail > left)
      avail = left;

    // Copy data
    if (out != nullptr)
      memcpy(out + offset, read_head_->data_ + read_head_->read_pos_, avail);
    read_head_->read_pos_ += avail;

    // Move pointers
    bytes_read += avail;
    offset += avail;
    left -= avail;

    TryMoveReadHead();
  }
  CHECK_EQ(expected, bytes_read);
  length_ -= bytes_read;

  // Free all empty buffers, but write_head's child
  FreeEmpty();

  return bytes_read;
}",1,1,crypto\crypto_bio.cc,node.crypto.NodeBIO.Read,,false,259,290,Read,,,14,"size_t node.crypto.NodeBIO.Read (char*,size_t)"
20274,METHOD,crypto\crypto_bio.cc:<global>,TYPE_DECL,"void NodeBIO::FreeEmpty() {
  if (write_head_ == nullptr)
    return;
  Buffer* child = write_head_->next_;
  if (child == write_head_ || child == read_head_)
    return;
  Buffer* cur = child->next_;
  if (cur == write_head_ || cur == read_head_)
    return;

  Buffer* prev = child;
  while (cur != read_head_) {
    CHECK_NE(cur, write_head_);
    CHECK_EQ(cur->write_pos_, cur->read_pos_);

    Buffer* next = cur->next_;
    delete cur;
    cur = next;
  }
  prev->next_ = cur;
}",1,1,crypto\crypto_bio.cc,node.crypto.NodeBIO.FreeEmpty,,false,293,313,FreeEmpty,,,15,void node.crypto.NodeBIO.FreeEmpty ()
20351,METHOD,crypto\crypto_bio.cc:<global>,TYPE_DECL,"size_t NodeBIO::IndexOf(char delim, size_t limit) {
  size_t bytes_read = 0;
  size_t max = Length() > limit ? limit : Length();
  size_t left = limit;
  Buffer* current = read_head_;

  while (bytes_read < max) {
    CHECK_LE(current->read_pos_, current->write_pos_);
    size_t avail = current->write_pos_ - current->read_pos_;
    if (avail > left)
      avail = left;

    // Walk through data
    char* tmp = current->data_ + current->read_pos_;
    size_t off = 0;
    while (off < avail && *tmp != delim) {
      off++;
      tmp++;
    }

    // Move pointers
    bytes_read += off;
    left -= off;

    // Found `delim`
    if (off != avail) {
      return bytes_read;
    }

    // Move to next buffer
    if (current->read_pos_ + avail == current->len_) {
      current = current->next_;
    }
  }
  CHECK_EQ(max, bytes_read);

  return max;
}",1,1,crypto\crypto_bio.cc,node.crypto.NodeBIO.IndexOf,,false,316,353,IndexOf,,,16,"size_t node.crypto.NodeBIO.IndexOf (char,size_t)"
20470,METHOD,crypto\crypto_bio.cc:<global>,TYPE_DECL,"void NodeBIO::Write(const char* data, size_t size) {
  size_t offset = 0;
  size_t left = size;

  // Allocate initial buffer if the ring is empty
  TryAllocateForWrite(left);

  while (left > 0) {
    size_t to_write = left;
    CHECK_LE(write_head_->write_pos_, write_head_->len_);
    size_t avail = write_head_->len_ - write_head_->write_pos_;

    if (to_write > avail)
      to_write = avail;

    // Copy data
    memcpy(write_head_->data_ + write_head_->write_pos_,
           data + offset,
           to_write);

    // Move pointers
    left -= to_write;
    offset += to_write;
    length_ += to_write;
    write_head_->write_pos_ += to_write;
    CHECK_LE(write_head_->write_pos_, write_head_->len_);

    // Go to next buffer if there still are some bytes to write
    if (left != 0) {
      CHECK_EQ(write_head_->write_pos_, write_head_->len_);
      TryAllocateForWrite(left);
      write_head_ = write_head_->next_;

      // Additionally, since we're moved to the next buffer, re...",1,1,crypto\crypto_bio.cc,node.crypto.NodeBIO.Write,,false,356,395,Write,,,17,"void node.crypto.NodeBIO.Write (char*,size_t)"
20576,METHOD,crypto\crypto_bio.cc:<global>,TYPE_DECL,"char* NodeBIO::PeekWritable(size_t* size) {
  TryAllocateForWrite(*size);

  size_t available = write_head_->len_ - write_head_->write_pos_;
  if (*size == 0 || available <= *size)
    *size = available;

  return write_head_->data_ + write_head_->write_pos_;
}",1,1,crypto\crypto_bio.cc,node.crypto.NodeBIO.PeekWritable,,false,398,406,PeekWritable,,,18,char* node.crypto.NodeBIO.PeekWritable (size_t*)
20617,METHOD,crypto\crypto_bio.cc:<global>,TYPE_DECL,"void NodeBIO::Commit(size_t size) {
  write_head_->write_pos_ += size;
  length_ += size;
  CHECK_LE(write_head_->write_pos_, write_head_->len_);

  // Allocate new buffer if write head is full,
  // and there're no other place to go
  TryAllocateForWrite(0);
  if (write_head_->write_pos_ == write_head_->len_) {
    write_head_ = write_head_->next_;

    // Additionally, since we're moved to the next buffer, read head
    // may be moved as well.
    TryMoveReadHead();
  }
}",1,1,crypto\crypto_bio.cc,node.crypto.NodeBIO.Commit,,false,409,424,Commit,,,19,void node.crypto.NodeBIO.Commit (size_t)
20654,METHOD,crypto\crypto_bio.cc:<global>,TYPE_DECL,"void NodeBIO::TryAllocateForWrite(size_t hint) {
  Buffer* w = write_head_;
  Buffer* r = read_head_;
  // If write head is full, next buffer is either read head or not empty.
  if (w == nullptr ||
      (w->write_pos_ == w->len_ &&
       (w->next_ == r || w->next_->write_pos_ != 0))) {
    size_t len = w == nullptr ? initial_ :
                             kThroughputBufferLength;
    if (len < hint)
      len = hint;

    // If there is a one time allocation size hint, use it.
    if (allocate_hint_ > len) {
      len = allocate_hint_;
      allocate_hint_ = 0;
    }

    Buffer* next = new Buffer(env_, len);

    if (w == nullptr) {
      next->next_ = next;
      write_head_ = next;
      read_head_ = next;
    } else {
      next->next_ = w->next_;
      w->next_ = next;
    }
  }
}",1,1,crypto\crypto_bio.cc,node.crypto.NodeBIO.TryAllocateForWrite,,false,427,456,TryAllocateForWrite,,,20,void node.crypto.NodeBIO.TryAllocateForWrite (size_t)
20759,METHOD,crypto\crypto_bio.cc:<global>,TYPE_DECL,"void NodeBIO::Reset() {
  if (read_head_ == nullptr)
    return;

  while (read_head_->read_pos_ != read_head_->write_pos_) {
    CHECK(read_head_->write_pos_ > read_head_->read_pos_);

    length_ -= read_head_->write_pos_ - read_head_->read_pos_;
    read_head_->write_pos_ = 0;
    read_head_->read_pos_ = 0;

    read_head_ = read_head_->next_;
  }
  write_head_ = read_head_;
  CHECK_EQ(length_, 0);
}",1,1,crypto\crypto_bio.cc,node.crypto.NodeBIO.Reset,,false,459,474,Reset,,,21,void node.crypto.NodeBIO.Reset ()
20816,METHOD,crypto\crypto_bio.cc:<global>,TYPE_DECL,"NodeBIO::~NodeBIO() {
  if (read_head_ == nullptr)
    return;

  Buffer* current = read_head_;
  do {
    Buffer* next = current->next_;
    delete current;
    current = next;
  } while (current != read_head_);

  read_head_ = nullptr;
  write_head_ = nullptr;
}",1,1,crypto\crypto_bio.cc,node.crypto.NodeBIO.~NodeBIO,,false,477,490,~NodeBIO,,,22,ANY node.crypto.NodeBIO.~NodeBIO ()
20852,METHOD,crypto\crypto_bio.cc:<global>,TYPE_DECL,"NodeBIO* NodeBIO::FromBIO(BIO* bio) {
  CHECK_NOT_NULL(BIO_get_data(bio));
  return static_cast<NodeBIO*>(BIO_get_data(bio));
}",1,1,crypto\crypto_bio.cc,node.crypto.NodeBIO.FromBIO,,false,493,496,FromBIO,,,23,NodeBIO node.crypto.NodeBIO.FromBIO (BIO*)
20876,METHOD,crypto\crypto_bio.hpp:<global>,TYPE_DECL,<global>,1,35,crypto\crypto_bio.hpp,crypto\crypto_bio.hpp:<global>,,false,1,192,<global>,,,1,
20879,METHOD,crypto\crypto_cipher.cc:<global>,TYPE_DECL,"[](CipherBase* cipher,
                              const FunctionCallbackInfo<Value>& args,
                              const char* data, size_t size) {
    std::unique_ptr<BackingStore> out;
    Environment* env = Environment::GetCurrent(args);

    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");

    UpdateResult r = cipher->Update(data, size, &out);

    if (r != kSuccess) {
      if (r == kErrorState) {
        ThrowCryptoError(env, ERR_get_error(),
                         ""Trying to add data in unsupported state"");
      }
      return;
    }

    Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(out));
    args.GetReturnValue().Set(
        Buffer::New(env, ab, 0, ab->ByteLength()).FromMaybe(Local<Value>()));
  }",28,3,crypto\crypto_cipher.cc,"args, [](CipherBase* cipher, const FunctionCallbackInfo<Value>& args, const char* data, size_t size) { std.unique_ptr<BackingStore> out; Environment* env = Environment.GetCurrent(args); if (UNLIKELY(size > INT_MAX)) return THROW_ERR_OUT_OF_RANGE(env, ""data is too long""); UpdateResult r = cipher->Update(data, size, &out); if (r != kSuccess) { if (r == kErrorState) { ThrowCryptoError(env, ERR_get_error(), ""Trying to add data in unsupported state""); } return; } Local<ArrayBuffer> ab = ArrayBuffer.New(env->isolate(), std.move(out)); args.GetReturnValue().Set( Buffer.New(env, ab, 0, ab->ByteLength()).FromMaybe(Local<Value>())); }.<lambda>0",,false,847,869,<lambda>0,,,1,"ANY args, [](CipherBase* cipher, const FunctionCallbackInfo<Value>& args, const char* data, size_t size) { std.unique_ptr<BackingStore> out; Environment* env = Environment.GetCurrent(args); if (UNLIKELY(size > INT_MAX)) return THROW_ERR_OUT_OF_RANGE(env, ""data is too long""); UpdateResult r = cipher->Update(data, size, &out); if (r != kSuccess) { if (r == kErrorState) { ThrowCryptoError(env, ERR_get_error(), ""Trying to add data in unsupported state""); } return; } Local<ArrayBuffer> ab = ArrayBuffer.New(env->isolate(), std.move(out)); args.GetReturnValue().Set( Buffer.New(env, ab, 0, ab->ByteLength()).FromMaybe(Local<Value>())); }.<lambda>0 (CipherBase*,FunctionCallbackInfo<Value>,char*,size_t)"
21001,METHOD,crypto\crypto_cipher.cc:<global>,TYPE_DECL,<global>,1,38,crypto\crypto_cipher.hpp,crypto\crypto_cipher.cc:<global>,,false,1,1080,<global>,,,1,
21006,METHOD,crypto\crypto_cipher.cc:<global>,TYPE_DECL,"bool IsSupportedAuthenticatedMode(const EVP_CIPHER* cipher) {
  switch (EVP_CIPHER_mode(cipher)) {
  case EVP_CIPH_CCM_MODE:
  case EVP_CIPH_GCM_MODE:
#ifndef OPENSSL_NO_OCB
  case EVP_CIPH_OCB_MODE:
#endif
    return true;
  case EVP_CIPH_STREAM_CIPHER:
    return EVP_CIPHER_nid(cipher) == NID_chacha20_poly1305;
  default:
    return false;
  }
}",1,1,crypto\crypto_cipher.cc,node.crypto.anonymous_namespace_1.IsSupportedAuthenticatedMode,,false,29,42,IsSupportedAuthenticatedMode,,,1,bool node.crypto.anonymous_namespace_1.IsSupportedAuthenticatedMode (EVP_CIPHER*)
21033,METHOD,crypto\crypto_cipher.cc:<global>,TYPE_DECL,"bool IsSupportedAuthenticatedMode(const EVP_CIPHER_CTX* ctx) {
  const EVP_CIPHER* cipher = EVP_CIPHER_CTX_cipher(ctx);
  return IsSupportedAuthenticatedMode(cipher);
}",1,1,crypto\crypto_cipher.cc,node.crypto.anonymous_namespace_2.IsSupportedAuthenticatedMode,,false,44,47,IsSupportedAuthenticatedMode,,,2,bool node.crypto.anonymous_namespace_2.IsSupportedAuthenticatedMode (EVP_CIPHER_CTX*)
21046,METHOD,crypto\crypto_cipher.cc:<global>,TYPE_DECL,"bool IsValidGCMTagLength(unsigned int tag_len) {
  return tag_len == 4 || tag_len == 8 || (tag_len >= 12 && tag_len <= 16);
}",1,1,crypto\crypto_cipher.cc,node.crypto.anonymous_namespace_4.IsValidGCMTagLength,,false,49,51,IsValidGCMTagLength,,,3,bool node.crypto.anonymous_namespace_4.IsValidGCMTagLength (unsigned int)
21067,METHOD,crypto\crypto_cipher.cc:<global>,TYPE_DECL,"void GetCipherInfo(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsObject());
  Local<Object> info = args[0].As<Object>();

  CHECK(args[1]->IsString() || args[1]->IsInt32());

  const EVP_CIPHER* cipher;
  if (args[1]->IsString()) {
    Utf8Value name(env->isolate(), args[1]);
    cipher = EVP_get_cipherbyname(*name);
  } else {
    int nid = args[1].As<Int32>()->Value();
    cipher = EVP_get_cipherbynid(nid);
  }

  if (cipher == nullptr)
    return;

  int mode = EVP_CIPHER_mode(cipher);
  int iv_length = EVP_CIPHER_iv_length(cipher);
  int key_length = EVP_CIPHER_key_length(cipher);
  int block_length = EVP_CIPHER_block_size(cipher);
  const char* mode_label = nullptr;
  switch (mode) {
    case EVP_CIPH_CBC_MODE: mode_label = ""cbc""; break;
    case EVP_CIPH_CCM_MODE: mode_label = ""ccm""; break;
    case EVP_CIPH_CFB_MODE: mode_label = ""cfb""; break;
    case EVP_CIPH_CTR_MODE: mode_label = ""ctr""; break;
    case EV...",1,1,crypto\crypto_cipher.cc,node.crypto.anonymous_namespace_5.GetCipherInfo,,false,54,194,GetCipherInfo,,,4,void node.crypto.anonymous_namespace_5.GetCipherInfo (FunctionCallbackInfo<Value>)
21570,METHOD,crypto\crypto_cipher.cc:<global>,TYPE_DECL,"void CipherBase::GetSSLCiphers(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  SSLCtxPointer ctx(SSL_CTX_new(TLS_method()));
  if (!ctx) {
    return ThrowCryptoError(env, ERR_get_error(), ""SSL_CTX_new"");
  }

  SSLPointer ssl(SSL_new(ctx.get()));
  if (!ssl) {
    return ThrowCryptoError(env, ERR_get_error(), ""SSL_new"");
  }

  STACK_OF(SSL_CIPHER)* ciphers = SSL_get_ciphers(ssl.get());

  // TLSv1.3 ciphers aren't listed by EVP. There are only 5, we could just
  // document them, but since there are only 5, easier to just add them manually
  // and not have to explain their absence in the API docs. They are lower-cased
  // because the docs say they will be.
  static const char* TLS13_CIPHERS[] = {
    ""tls_aes_256_gcm_sha384"",
    ""tls_chacha20_poly1305_sha256"",
    ""tls_aes_128_gcm_sha256"",
    ""tls_aes_128_ccm_8_sha256"",
    ""tls_aes_128_ccm_sha256""
  };

  const int n = sk_SSL_CIPHER_num(ciphers);
  std::vector<Local<Value>> ar...",1,1,crypto\crypto_cipher.cc,node.crypto.CipherBase.GetSSLCiphers,,false,197,238,GetSSLCiphers,,,2,void node.crypto.CipherBase.GetSSLCiphers (FunctionCallbackInfo<Value>)
21581,METHOD,crypto\crypto_cipher.cc:<global>,TYPE_DECL,SSLCtxPointer ctx(SSL_CTX_new(TLS_method()));,17,46,crypto\crypto_cipher.cc,node.crypto.CipherBase.GetSSLCiphers.ctx,,false,200,200,ctx,,,3,SSLCtxPointer node.crypto.CipherBase.GetSSLCiphers.ctx (SSL_CTX_new)
21733,METHOD,crypto\crypto_cipher.cc:<global>,TYPE_DECL,"void CipherBase::GetCiphers(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  MarkPopErrorOnReturn mark_pop_error_on_return;
  CipherPushContext ctx(env);
  EVP_CIPHER_do_all_sorted(
#if OPENSSL_VERSION_MAJOR >= 3
    array_push_back<EVP_CIPHER,
                    EVP_CIPHER_fetch,
                    EVP_CIPHER_free,
                    EVP_get_cipherbyname,
                    EVP_CIPHER_get0_name>,
#else
    array_push_back<EVP_CIPHER>,
#endif
    &ctx);
  args.GetReturnValue().Set(ctx.ToJSArray());
}",1,1,crypto\crypto_cipher.cc,node.crypto.CipherBase.GetCiphers,,false,240,256,GetCiphers,,,3,void node.crypto.CipherBase.GetCiphers (FunctionCallbackInfo<Value>)
21765,METHOD,crypto\crypto_cipher.cc:<global>,TYPE_DECL,"CipherBase::CipherBase(Environment* env,
                       Local<Object> wrap,
                       CipherKind kind)
    : BaseObject(env, wrap),
      ctx_(nullptr),
      kind_(kind),
      auth_tag_state_(kAuthTagUnknown),
      auth_tag_len_(kNoAuthTagLength),
      pending_auth_failed_(false) {
  MakeWeak();
}",1,1,crypto\crypto_cipher.cc,node.crypto.CipherBase.CipherBase,,false,258,268,CipherBase,,,4,"ANY node.crypto.CipherBase.CipherBase (Environment*,Local<Object>,CipherKind)"
21773,METHOD,crypto\crypto_cipher.cc:<global>,TYPE_DECL,"void CipherBase::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackFieldWithSize(""context"", ctx_ ? kSizeOf_EVP_CIPHER_CTX : 0);
}",1,1,crypto\crypto_cipher.cc,node.crypto.CipherBase.MemoryInfo,,false,270,272,MemoryInfo,,,5,void node.crypto.CipherBase.MemoryInfo (MemoryTracker*)
21787,METHOD,crypto\crypto_cipher.cc:<global>,TYPE_DECL,"void CipherBase::Initialize(Environment* env, Local<Object> target) {
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);

  t->InstanceTemplate()->SetInternalFieldCount(CipherBase::kInternalFieldCount);

  SetProtoMethod(isolate, t, ""init"", Init);
  SetProtoMethod(isolate, t, ""initiv"", InitIv);
  SetProtoMethod(isolate, t, ""update"", Update);
  SetProtoMethod(isolate, t, ""final"", Final);
  SetProtoMethod(isolate, t, ""setAutoPadding"", SetAutoPadding);
  SetProtoMethodNoSideEffect(isolate, t, ""getAuthTag"", GetAuthTag);
  SetProtoMethod(isolate, t, ""setAuthTag"", SetAuthTag);
  SetProtoMethod(isolate, t, ""setAAD"", SetAAD);
  SetConstructorFunction(context, target, ""CipherBase"", t);

  SetMethodNoSideEffect(context, target, ""getSSLCiphers"", GetSSLCiphers);
  SetMethodNoSideEffect(context, target, ""getCiphers"", GetCiphers);

  SetMethod(context,
            target,
            ""publicEncrypt"",
  ...",1,2,crypto\crypto_cipher.cc,node.crypto.CipherBase.Initialize,,false,274,324,Initialize,,,6,"void node.crypto.CipherBase.Initialize (Environment*,Local<Object>)"
22115,METHOD,crypto\crypto_cipher.cc:<global>,TYPE_DECL,"void CipherBase::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(New);

  registry->Register(Init);
  registry->Register(InitIv);
  registry->Register(Update);
  registry->Register(Final);
  registry->Register(SetAutoPadding);
  registry->Register(GetAuthTag);
  registry->Register(SetAuthTag);
  registry->Register(SetAAD);

  registry->Register(GetSSLCiphers);
  registry->Register(GetCiphers);

  registry->Register(PublicKeyCipher::Cipher<PublicKeyCipher::kPublic,
                                             EVP_PKEY_encrypt_init,
                                             EVP_PKEY_encrypt>);
  registry->Register(PublicKeyCipher::Cipher<PublicKeyCipher::kPrivate,
                                             EVP_PKEY_decrypt_init,
                                             EVP_PKEY_decrypt>);
  registry->Register(PublicKeyCipher::Cipher<PublicKeyCipher::kPrivate,
                                             EVP_PKEY_sign_init,
         ...",1,1,crypto\crypto_cipher.cc,node.crypto.CipherBase.RegisterExternalReferences,,false,326,356,RegisterExternalReferences,,,7,void node.crypto.CipherBase.RegisterExternalReferences (ExternalReferenceRegistry*)
22208,METHOD,crypto\crypto_cipher.cc:<global>,TYPE_DECL,"void CipherBase::New(const FunctionCallbackInfo<Value>& args) {
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new CipherBase(env, args.This(), args[0]->IsTrue() ? kCipher : kDecipher);
}",1,1,crypto\crypto_cipher.cc,node.crypto.CipherBase.New,,false,358,362,New,,,8,void node.crypto.CipherBase.New (FunctionCallbackInfo<Value>)
22242,METHOD,crypto\crypto_cipher.cc:<global>,TYPE_DECL,"void CipherBase::CommonInit(const char* cipher_type,
                            const EVP_CIPHER* cipher,
                            const unsigned char* key,
                            int key_len,
                            const unsigned char* iv,
                            int iv_len,
                            unsigned int auth_tag_len) {
  CHECK(!ctx_);
  ctx_.reset(EVP_CIPHER_CTX_new());

  const int mode = EVP_CIPHER_mode(cipher);
  if (mode == EVP_CIPH_WRAP_MODE)
    EVP_CIPHER_CTX_set_flags(ctx_.get(), EVP_CIPHER_CTX_FLAG_WRAP_ALLOW);

  const bool encrypt = (kind_ == kCipher);
  if (1 != EVP_CipherInit_ex(ctx_.get(), cipher, nullptr,
                             nullptr, nullptr, encrypt)) {
    return ThrowCryptoError(env(), ERR_get_error(),
                            ""Failed to initialize cipher"");
  }

  if (IsSupportedAuthenticatedMode(cipher)) {
    CHECK_GE(iv_len, 0);
    if (!InitAuthenticated(cipher_type, iv_len, auth_tag_len))
      return;
  }

  if (!EV...",1,1,crypto\crypto_cipher.cc,node.crypto.CipherBase.CommonInit,,false,364,400,CommonInit,,,9,"void node.crypto.CipherBase.CommonInit (char*,EVP_CIPHER*,unsigned char*,int,unsigned char*,int,unsigned int)"
22352,METHOD,crypto\crypto_cipher.cc:<global>,TYPE_DECL,"void CipherBase::Init(const char* cipher_type,
                      const ArrayBufferOrViewContents<unsigned char>& key_buf,
                      unsigned int auth_tag_len) {
  HandleScope scope(env()->isolate());
  MarkPopErrorOnReturn mark_pop_error_on_return;
#if OPENSSL_VERSION_MAJOR >= 3
  if (EVP_default_properties_is_fips_enabled(nullptr)) {
#else
  if (FIPS_mode()) {
#endif
    return THROW_ERR_CRYPTO_UNSUPPORTED_OPERATION(env(),
        ""crypto.createCipher() is not supported in FIPS mode."");
  }

  const EVP_CIPHER* const cipher = EVP_get_cipherbyname(cipher_type);
  if (cipher == nullptr)
    return THROW_ERR_CRYPTO_UNKNOWN_CIPHER(env());

  unsigned char key[EVP_MAX_KEY_LENGTH];
  unsigned char iv[EVP_MAX_IV_LENGTH];

  int key_len = EVP_BytesToKey(cipher,
                               EVP_md5(),
                               nullptr,
                               key_buf.data(),
                               key_buf.size(),
                               1,
      ...",1,1,crypto\crypto_cipher.cc,node.crypto.CipherBase.Init,,false,402,446,Init,,,10,"void node.crypto.CipherBase.Init (char*,ArrayBufferOrViewContents<unsigned char>,unsigned int)"
22444,METHOD,crypto\crypto_cipher.cc:<global>,TYPE_DECL,"void CipherBase::Init(const FunctionCallbackInfo<Value>& args) {
  CipherBase* cipher;
  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());
  Environment* env = Environment::GetCurrent(args);

  CHECK_GE(args.Length(), 3);

  const Utf8Value cipher_type(args.GetIsolate(), args[0]);
  ArrayBufferOrViewContents<unsigned char> key_buf(args[1]);
  if (!key_buf.CheckSizeInt32())
    return THROW_ERR_OUT_OF_RANGE(env, ""password is too large"");

  // Don't assign to cipher->auth_tag_len_ directly; the value might not
  // represent a valid length at this point.
  unsigned int auth_tag_len;
  if (args[2]->IsUint32()) {
    auth_tag_len = args[2].As<Uint32>()->Value();
  } else {
    CHECK(args[2]->IsInt32() && args[2].As<Int32>()->Value() == -1);
    auth_tag_len = kNoAuthTagLength;
  }

  cipher->Init(*cipher_type, key_buf, auth_tag_len);
}",1,1,crypto\crypto_cipher.cc,node.crypto.CipherBase.Init,,false,448,471,Init,,,11,void node.crypto.CipherBase.Init (FunctionCallbackInfo<Value>)
22549,METHOD,crypto\crypto_cipher.cc:<global>,TYPE_DECL,"void CipherBase::InitIv(const char* cipher_type,
                        const ByteSource& key_buf,
                        const ArrayBufferOrViewContents<unsigned char>& iv_buf,
                        unsigned int auth_tag_len) {
  HandleScope scope(env()->isolate());
  MarkPopErrorOnReturn mark_pop_error_on_return;

  const EVP_CIPHER* const cipher = EVP_get_cipherbyname(cipher_type);
  if (cipher == nullptr)
    return THROW_ERR_CRYPTO_UNKNOWN_CIPHER(env());

  const int expected_iv_len = EVP_CIPHER_iv_length(cipher);
  const bool is_authenticated_mode = IsSupportedAuthenticatedMode(cipher);
  const bool has_iv = iv_buf.size() > 0;

  // Throw if no IV was passed and the cipher requires an IV
  if (!has_iv && expected_iv_len != 0)
    return THROW_ERR_CRYPTO_INVALID_IV(env());

  // Throw if an IV was passed which does not match the cipher's fixed IV length
  // static_cast<int> for the iv_buf.size() is safe because we've verified
  // prior that the value is not larger than IN...",1,1,crypto\crypto_cipher.cc,node.crypto.CipherBase.InitIv,,false,473,518,InitIv,,,12,"void node.crypto.CipherBase.InitIv (char*,ByteSource,ArrayBufferOrViewContents<unsigned char>,unsigned int)"
22664,METHOD,crypto\crypto_cipher.cc:<global>,TYPE_DECL,"void CipherBase::InitIv(const FunctionCallbackInfo<Value>& args) {
  CipherBase* cipher;
  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());
  Environment* env = cipher->env();

  CHECK_GE(args.Length(), 4);

  const Utf8Value cipher_type(env->isolate(), args[0]);

  // The argument can either be a KeyObjectHandle or a byte source
  // (e.g. ArrayBuffer, TypedArray, etc). Whichever it is, grab the
  // raw bytes and proceed...
  const ByteSource key_buf = ByteSource::FromSecretKeyBytes(env, args[1]);

  if (UNLIKELY(key_buf.size() > INT_MAX))
    return THROW_ERR_OUT_OF_RANGE(env, ""key is too big"");

  ArrayBufferOrViewContents<unsigned char> iv_buf(
      !args[2]->IsNull() ? args[2] : Local<Value>());

  if (UNLIKELY(!iv_buf.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""iv is too big"");

  // Don't assign to cipher->auth_tag_len_ directly; the value might not
  // represent a valid length at this point.
  unsigned int auth_tag_len;
  if (args[3]->IsUint32()) {
    auth...",1,1,crypto\crypto_cipher.cc,node.crypto.CipherBase.InitIv,,false,520,554,InitIv,,,13,void node.crypto.CipherBase.InitIv (FunctionCallbackInfo<Value>)
22803,METHOD,crypto\crypto_cipher.cc:<global>,TYPE_DECL,"bool CipherBase::InitAuthenticated(
    const char* cipher_type,
    int iv_len,
    unsigned int auth_tag_len) {
  CHECK(IsAuthenticatedMode());
  MarkPopErrorOnReturn mark_pop_error_on_return;

  if (!EVP_CIPHER_CTX_ctrl(ctx_.get(),
                           EVP_CTRL_AEAD_SET_IVLEN,
                           iv_len,
                           nullptr)) {
    THROW_ERR_CRYPTO_INVALID_IV(env());
    return false;
  }

  const int mode = EVP_CIPHER_CTX_mode(ctx_.get());
  if (mode == EVP_CIPH_GCM_MODE) {
    if (auth_tag_len != kNoAuthTagLength) {
      if (!IsValidGCMTagLength(auth_tag_len)) {
        THROW_ERR_CRYPTO_INVALID_AUTH_TAG(
          env(),
          ""Invalid authentication tag length: %u"",
          auth_tag_len);
        return false;
      }

      // Remember the given authentication tag length for later.
      auth_tag_len_ = auth_tag_len;
    }
  } else {
    if (auth_tag_len == kNoAuthTagLength) {
      // We treat ChaCha20-Poly1305 specially. Like GCM, the auth...",1,1,crypto\crypto_cipher.cc,node.crypto.CipherBase.InitAuthenticated,,false,556,634,InitAuthenticated,,,14,"bool node.crypto.CipherBase.InitAuthenticated (char*,int,unsigned int)"
22955,METHOD,crypto\crypto_cipher.cc:<global>,TYPE_DECL,"bool CipherBase::CheckCCMMessageLength(int message_len) {
  CHECK(ctx_);
  CHECK(EVP_CIPHER_CTX_mode(ctx_.get()) == EVP_CIPH_CCM_MODE);

  if (message_len > max_message_size_) {
    THROW_ERR_CRYPTO_INVALID_MESSAGELEN(env());
    return false;
  }

  return true;
}",1,1,crypto\crypto_cipher.cc,node.crypto.CipherBase.CheckCCMMessageLength,,false,636,646,CheckCCMMessageLength,,,15,bool node.crypto.CipherBase.CheckCCMMessageLength (int)
22979,METHOD,crypto\crypto_cipher.cc:<global>,TYPE_DECL,"bool CipherBase::IsAuthenticatedMode() const {
  // Check if this cipher operates in an AEAD mode that we support.
  CHECK(ctx_);
  return IsSupportedAuthenticatedMode(ctx_.get());
}",1,1,crypto\crypto_cipher.cc,node.crypto.CipherBase.IsAuthenticatedMode,,false,648,652,IsAuthenticatedMode,,,16,bool node.crypto.CipherBase.IsAuthenticatedMode ()
22990,METHOD,crypto\crypto_cipher.cc:<global>,TYPE_DECL,"void CipherBase::GetAuthTag(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CipherBase* cipher;
  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());

  // Only callable after Final and if encrypting.
  if (cipher->ctx_ ||
      cipher->kind_ != kCipher ||
      cipher->auth_tag_len_ == kNoAuthTagLength) {
    return;
  }

  args.GetReturnValue().Set(
      Buffer::Copy(env, cipher->auth_tag_, cipher->auth_tag_len_)
          .FromMaybe(Local<Value>()));
}",1,1,crypto\crypto_cipher.cc,node.crypto.CipherBase.GetAuthTag,,false,654,669,GetAuthTag,,,17,void node.crypto.CipherBase.GetAuthTag (FunctionCallbackInfo<Value>)
23051,METHOD,crypto\crypto_cipher.cc:<global>,TYPE_DECL,"void CipherBase::SetAuthTag(const FunctionCallbackInfo<Value>& args) {
  CipherBase* cipher;
  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());
  Environment* env = Environment::GetCurrent(args);

  if (!cipher->ctx_ ||
      !cipher->IsAuthenticatedMode() ||
      cipher->kind_ != kDecipher ||
      cipher->auth_tag_state_ != kAuthTagUnknown) {
    return args.GetReturnValue().Set(false);
  }

  ArrayBufferOrViewContents<char> auth_tag(args[0]);
  if (UNLIKELY(!auth_tag.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""buffer is too big"");

  unsigned int tag_len = auth_tag.size();

  const int mode = EVP_CIPHER_CTX_mode(cipher->ctx_.get());
  bool is_valid;
  if (mode == EVP_CIPH_GCM_MODE) {
    // Restrict GCM tag lengths according to NIST 800-38d, page 9.
    is_valid = (cipher->auth_tag_len_ == kNoAuthTagLength ||
                cipher->auth_tag_len_ == tag_len) &&
               IsValidGCMTagLength(tag_len);
  } else {
    // At this point, the tag length is already ...",1,1,crypto\crypto_cipher.cc,node.crypto.CipherBase.SetAuthTag,,false,671,717,SetAuthTag,,,18,void node.crypto.CipherBase.SetAuthTag (FunctionCallbackInfo<Value>)
23237,METHOD,crypto\crypto_cipher.cc:<global>,TYPE_DECL,"bool CipherBase::MaybePassAuthTagToOpenSSL() {
  if (auth_tag_state_ == kAuthTagKnown) {
    if (!EVP_CIPHER_CTX_ctrl(ctx_.get(),
                             EVP_CTRL_AEAD_SET_TAG,
                             auth_tag_len_,
                             reinterpret_cast<unsigned char*>(auth_tag_))) {
      return false;
    }
    auth_tag_state_ = kAuthTagPassedToOpenSSL;
  }
  return true;
}",1,1,crypto\crypto_cipher.cc,node.crypto.CipherBase.MaybePassAuthTagToOpenSSL,,false,719,730,MaybePassAuthTagToOpenSSL,,,19,bool node.crypto.CipherBase.MaybePassAuthTagToOpenSSL ()
23266,METHOD,crypto\crypto_cipher.cc:<global>,TYPE_DECL,"bool CipherBase::SetAAD(
    const ArrayBufferOrViewContents<unsigned char>& data,
    int plaintext_len) {
  if (!ctx_ || !IsAuthenticatedMode())
    return false;
  MarkPopErrorOnReturn mark_pop_error_on_return;

  int outlen;
  const int mode = EVP_CIPHER_CTX_mode(ctx_.get());

  // When in CCM mode, we need to set the authentication tag and the plaintext
  // length in advance.
  if (mode == EVP_CIPH_CCM_MODE) {
    if (plaintext_len < 0) {
      THROW_ERR_MISSING_ARGS(env(),
          ""options.plaintextLength required for CCM mode with AAD"");
      return false;
    }

    if (!CheckCCMMessageLength(plaintext_len))
      return false;

    if (kind_ == kDecipher) {
      if (!MaybePassAuthTagToOpenSSL())
        return false;
    }

    // Specify the plaintext length.
    if (!EVP_CipherUpdate(ctx_.get(), nullptr, &outlen, nullptr, plaintext_len))
      return false;
  }

  return 1 == EVP_CipherUpdate(ctx_.get(),
                               nullptr,
                       ...",1,1,crypto\crypto_cipher.cc,node.crypto.CipherBase.SetAAD,,false,732,769,SetAAD,,,20,"bool node.crypto.CipherBase.SetAAD (ArrayBufferOrViewContents<unsigned char>,int)"
23358,METHOD,crypto\crypto_cipher.cc:<global>,TYPE_DECL,"void CipherBase::SetAAD(const FunctionCallbackInfo<Value>& args) {
  CipherBase* cipher;
  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());
  Environment* env = Environment::GetCurrent(args);

  CHECK_EQ(args.Length(), 2);
  CHECK(args[1]->IsInt32());
  int plaintext_len = args[1].As<Int32>()->Value();
  ArrayBufferOrViewContents<unsigned char> buf(args[0]);

  if (UNLIKELY(!buf.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""buffer is too big"");
  args.GetReturnValue().Set(cipher->SetAAD(buf, plaintext_len));
}",1,1,crypto\crypto_cipher.cc,node.crypto.CipherBase.SetAAD,,false,771,784,SetAAD,,,21,void node.crypto.CipherBase.SetAAD (FunctionCallbackInfo<Value>)
23434,METHOD,crypto\crypto_cipher.cc:<global>,TYPE_DECL,"CipherBase::UpdateResult CipherBase::Update(
    const char* data,
    size_t len,
    std::unique_ptr<BackingStore>* out) {
  if (!ctx_ || len > INT_MAX)
    return kErrorState;
  MarkPopErrorOnReturn mark_pop_error_on_return;

  const int mode = EVP_CIPHER_CTX_mode(ctx_.get());

  if (mode == EVP_CIPH_CCM_MODE && !CheckCCMMessageLength(len))
    return kErrorMessageSize;

  // Pass the authentication tag to OpenSSL if possible. This will only happen
  // once, usually on the first update.
  if (kind_ == kDecipher && IsAuthenticatedMode())
    CHECK(MaybePassAuthTagToOpenSSL());

  const int block_size = EVP_CIPHER_CTX_block_size(ctx_.get());
  CHECK_GT(block_size, 0);
  if (len + block_size > INT_MAX) return kErrorState;
  int buf_len = len + block_size;

  // For key wrapping algorithms, get output size by calling
  // EVP_CipherUpdate() with null output.
  if (kind_ == kCipher && mode == EVP_CIPH_WRAP_MODE &&
      EVP_CipherUpdate(ctx_.get(),
                       nullptr,
   ...",1,1,crypto\crypto_cipher.cc,node.crypto.CipherBase.Update,,false,786,844,Update,,,22,"UpdateResult node.crypto.CipherBase.Update (char*,size_t,ANY*)"
23641,METHOD,crypto\crypto_cipher.cc:<global>,TYPE_DECL,"void CipherBase::Update(const FunctionCallbackInfo<Value>& args) {
  Decode<CipherBase>(args, [](CipherBase* cipher,
                              const FunctionCallbackInfo<Value>& args,
                              const char* data, size_t size) {
    std::unique_ptr<BackingStore> out;
    Environment* env = Environment::GetCurrent(args);

    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");

    UpdateResult r = cipher->Update(data, size, &out);

    if (r != kSuccess) {
      if (r == kErrorState) {
        ThrowCryptoError(env, ERR_get_error(),
                         ""Trying to add data in unsupported state"");
      }
      return;
    }

    Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(out));
    args.GetReturnValue().Set(
        Buffer::New(env, ab, 0, ab->ByteLength()).FromMaybe(Local<Value>()));
  });
}",1,1,crypto\crypto_cipher.cc,node.crypto.CipherBase.Update,,false,846,870,Update,,,23,void node.crypto.CipherBase.Update (FunctionCallbackInfo<Value>)
23653,METHOD,crypto\crypto_cipher.cc:<global>,TYPE_DECL,"bool CipherBase::SetAutoPadding(bool auto_padding) {
  if (!ctx_)
    return false;
  MarkPopErrorOnReturn mark_pop_error_on_return;
  return EVP_CIPHER_CTX_set_padding(ctx_.get(), auto_padding);
}",1,1,crypto\crypto_cipher.cc,node.crypto.CipherBase.SetAutoPadding,,false,872,877,SetAutoPadding,,,24,bool node.crypto.CipherBase.SetAutoPadding (bool)
23672,METHOD,crypto\crypto_cipher.cc:<global>,TYPE_DECL,"void CipherBase::SetAutoPadding(const FunctionCallbackInfo<Value>& args) {
  CipherBase* cipher;
  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());

  bool b = cipher->SetAutoPadding(args.Length() < 1 || args[0]->IsTrue());
  args.GetReturnValue().Set(b);  // Possibly report invalid state failure
}",1,1,crypto\crypto_cipher.cc,node.crypto.CipherBase.SetAutoPadding,,false,879,885,SetAutoPadding,,,25,void node.crypto.CipherBase.SetAutoPadding (FunctionCallbackInfo<Value>)
23713,METHOD,crypto\crypto_cipher.cc:<global>,TYPE_DECL,"bool CipherBase::Final(std::unique_ptr<BackingStore>* out) {
  if (!ctx_)
    return false;

  const int mode = EVP_CIPHER_CTX_mode(ctx_.get());

  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env()->isolate_data());
    *out = ArrayBuffer::NewBackingStore(env()->isolate(),
        static_cast<size_t>(EVP_CIPHER_CTX_block_size(ctx_.get())));
  }

  if (kind_ == kDecipher && IsSupportedAuthenticatedMode(ctx_.get()))
    MaybePassAuthTagToOpenSSL();

  // OpenSSL v1.x doesn't verify the presence of the auth tag so do
  // it ourselves, see https://github.com/nodejs/node/issues/45874.
  if (OPENSSL_VERSION_NUMBER < 0x30000000L && kind_ == kDecipher &&
      NID_chacha20_poly1305 == EVP_CIPHER_CTX_nid(ctx_.get()) &&
      auth_tag_state_ != kAuthTagPassedToOpenSSL) {
    return false;
  }

  // In CCM mode, final() only checks whether authentication failed in update().
  // EVP_CipherFinal_ex must not be called and will fail.
  bool ok;
  if (kind_ == kDecipher && mode == EVP_CIP...",1,1,crypto\crypto_cipher.cc,node.crypto.CipherBase.Final,,false,887,947,Final,,,26,bool node.crypto.CipherBase.Final (ANY*)
23934,METHOD,crypto\crypto_cipher.cc:<global>,TYPE_DECL,"void CipherBase::Final(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  CipherBase* cipher;
  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());
  if (cipher->ctx_ == nullptr)
    return THROW_ERR_CRYPTO_INVALID_STATE(env);

  std::unique_ptr<BackingStore> out;

  // Check IsAuthenticatedMode() first, Final() destroys the EVP_CIPHER_CTX.
  const bool is_auth_mode = cipher->IsAuthenticatedMode();
  bool r = cipher->Final(&out);

  if (!r) {
    const char* msg = is_auth_mode
                          ? ""Unsupported state or unable to authenticate data""
                          : ""Unsupported state"";

    return ThrowCryptoError(env, ERR_get_error(), msg);
  }

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(out));
  args.GetReturnValue().Set(
      Buffer::New(env, ab, 0, ab->ByteLength()).FromMaybe(Local<Value>()));
}",1,1,crypto\crypto_cipher.cc,node.crypto.CipherBase.Final,,false,949,974,Final,,,27,void node.crypto.CipherBase.Final (FunctionCallbackInfo<Value>)
24045,METHOD,crypto\crypto_cipher.cc:<global>,TYPE_DECL,"bool PublicKeyCipher::Cipher(
    Environment* env,
    const ManagedEVPPKey& pkey,
    int padding,
    const EVP_MD* digest,
    const ArrayBufferOrViewContents<unsigned char>& oaep_label,
    const ArrayBufferOrViewContents<unsigned char>& data,
    std::unique_ptr<BackingStore>* out) {
  EVPKeyCtxPointer ctx(EVP_PKEY_CTX_new(pkey.get(), nullptr));
  if (!ctx)
    return false;
  if (EVP_PKEY_cipher_init(ctx.get()) <= 0)
    return false;
  if (EVP_PKEY_CTX_set_rsa_padding(ctx.get(), padding) <= 0)
    return false;

  if (digest != nullptr) {
    if (EVP_PKEY_CTX_set_rsa_oaep_md(ctx.get(), digest) <= 0)
      return false;
  }

  if (!SetRsaOaepLabel(ctx, oaep_label.ToByteSource())) return false;

  size_t out_len = 0;
  if (EVP_PKEY_cipher(
          ctx.get(),
          nullptr,
          &out_len,
          data.data(),
          data.size()) <= 0) {
    return false;
  }

  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    *out = ArrayBuffer::NewB...",1,1,crypto\crypto_cipher.cc,node.crypto.PublicKeyCipher.Cipher,,false,979,1033,Cipher,,,28,"bool node.crypto.PublicKeyCipher.Cipher<PublicKeyCipher::Operation,PublicKeyCipher::EVP_PKEY_cipher_init_t,PublicKeyCipher::EVP_PKEY_cipher_t> (Environment*,ManagedEVPPKey,int,EVP_MD*,ArrayBufferOrViewContents<unsigned char>,ArrayBufferOrViewContents<unsigned char>,ANY*)"
24240,METHOD,crypto\crypto_cipher.cc:<global>,TYPE_DECL,"void PublicKeyCipher::Cipher(const FunctionCallbackInfo<Value>& args) {
  MarkPopErrorOnReturn mark_pop_error_on_return;
  Environment* env = Environment::GetCurrent(args);

  unsigned int offset = 0;
  ManagedEVPPKey pkey =
      ManagedEVPPKey::GetPublicOrPrivateKeyFromJs(args, &offset);
  if (!pkey)
    return;

  ArrayBufferOrViewContents<unsigned char> buf(args[offset]);
  if (UNLIKELY(!buf.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""buffer is too long"");

  uint32_t padding;
  if (!args[offset + 1]->Uint32Value(env->context()).To(&padding)) return;

  const EVP_MD* digest = nullptr;
  if (args[offset + 2]->IsString()) {
    const Utf8Value oaep_str(env->isolate(), args[offset + 2]);
    digest = EVP_get_digestbyname(*oaep_str);
    if (digest == nullptr)
      return THROW_ERR_OSSL_EVP_INVALID_DIGEST(env);
  }

  ArrayBufferOrViewContents<unsigned char> oaep_label(
      !args[offset + 3]->IsUndefined() ? args[offset + 3] : Local<Value>());
  if (UNLIKELY(!oaep_...",1,1,crypto\crypto_cipher.cc,node.crypto.PublicKeyCipher.Cipher,,false,1038,1077,Cipher,,,29,"void node.crypto.PublicKeyCipher.Cipher<PublicKeyCipher::Operation,PublicKeyCipher::EVP_PKEY_cipher_init_t,PublicKeyCipher::EVP_PKEY_cipher_t> (FunctionCallbackInfo<Value>)"
24461,METHOD,crypto\crypto_cipher.hpp:<global>,TYPE_DECL,<global>,1,38,crypto\crypto_cipher.hpp,crypto\crypto_cipher.hpp:<global>,,false,1,291,<global>,,,1,
24470,METHOD,crypto\crypto_clienthello-inl.hpp:<global>,TYPE_DECL,<global>,1,47,crypto\crypto_clienthello-inl.hpp,crypto\crypto_clienthello-inl.hpp:<global>,,false,1,90,<global>,,,1,
24479,METHOD,crypto\crypto_clienthello.cc:<global>,TYPE_DECL,<global>,1,1,crypto\crypto_clienthello.cc,crypto\crypto_clienthello.cc:<global>,,false,1,238,<global>,,,1,
24483,METHOD,crypto\crypto_clienthello.cc:<global>,TYPE_DECL,"void ClientHelloParser::Parse(const uint8_t* data, size_t avail) {
  switch (state_) {
    case kWaiting:
      if (!ParseRecordHeader(data, avail))
        break;
      [[fallthrough]];
    case kTLSHeader:
      ParseHeader(data, avail);
      break;
    case kPaused:
      // Just nop
    case kEnded:
      // Already ended, just ignore it
      break;
    default:
      break;
  }
}",1,1,crypto\crypto_clienthello.cc,node.crypto.ClientHelloParser.Parse,,false,27,44,Parse,,,1,"void node.crypto.ClientHelloParser.Parse (uint8_t*,size_t)"
24514,METHOD,crypto\crypto_clienthello.cc:<global>,TYPE_DECL,"bool ClientHelloParser::ParseRecordHeader(const uint8_t* data, size_t avail) {
  // >= 5 bytes for header parsing
  if (avail < 5)
    return false;

  if (data[0] == kChangeCipherSpec ||
      data[0] == kAlert ||
      data[0] == kHandshake ||
      data[0] == kApplicationData) {
    frame_len_ = (data[3] << 8) + data[4];
    state_ = kTLSHeader;
    body_offset_ = 5;
  } else {
    End();
    return false;
  }

  // Sanity check (too big frame, or too small)
  // Let OpenSSL handle it
  if (frame_len_ >= kMaxTLSFrameLen) {
    End();
    return false;
  }

  return true;
}",1,1,crypto\crypto_clienthello.cc,node.crypto.ClientHelloParser.ParseRecordHeader,,false,47,72,ParseRecordHeader,,,2,"bool node.crypto.ClientHelloParser.ParseRecordHeader (uint8_t*,size_t)"
24584,METHOD,crypto\crypto_clienthello.cc:<global>,TYPE_DECL,"void ClientHelloParser::ParseHeader(const uint8_t* data, size_t avail) {
  ClientHello hello;

  // We need at least six bytes (one byte for kClientHello, three bytes for the
  // length of the handshake message, and two bytes for the protocol version).
  // If the client sent a frame that suggests a smaller ClientHello, give up.
  if (frame_len_ < 6) return End();

  // >= 5 + frame size bytes for frame parsing
  if (body_offset_ + frame_len_ > avail)
    return;

  // Check hello protocol version.  Protocol tuples that we know about:
  //
  // (3,1) TLS v1.0
  // (3,2) TLS v1.1
  // (3,3) TLS v1.2
  //
  // Note that TLS v1.3 uses a TLS v1.2 handshake so requires no specific
  // support here.
  if (data[body_offset_ + 4] != 0x03 ||
      data[body_offset_ + 5] < 0x01 ||
      data[body_offset_ + 5] > 0x03) {
    return End();
  }

  if (data[body_offset_] == kClientHello) {
    if (state_ == kTLSHeader) {
      if (!ParseTLSClientHello(data, avail))
        return End();
    } el...",1,1,crypto\crypto_clienthello.cc,node.crypto.ClientHelloParser.ParseHeader,,false,75,125,ParseHeader,,,3,"void node.crypto.ClientHelloParser.ParseHeader (uint8_t*,size_t)"
24715,METHOD,crypto\crypto_clienthello.cc:<global>,TYPE_DECL,"void ClientHelloParser::ParseExtension(const uint16_t type,
                                       const uint8_t* data,
                                       size_t len) {
  // NOTE: In case of anything we're just returning back, ignoring the problem.
  // That's because we're heavily relying on OpenSSL to solve any problem with
  // incoming data.
  switch (type) {
    case kServerName:
      {
        if (len < 2)
          return;
        uint32_t server_names_len = (data[0] << 8) + data[1];
        if (server_names_len + 2 > len)
          return;
        for (size_t offset = 2; offset < 2 + server_names_len; ) {
          if (offset + 3 > len)
            return;
          uint8_t name_type = data[offset];
          if (name_type != kServernameHostname)
            return;
          uint16_t name_len = (data[offset + 1] << 8) + data[offset + 2];
          offset += 3;
          if (offset + name_len > len)
            return;
          servername_ = data + offset;
          se...",1,1,crypto\crypto_clienthello.cc,node.crypto.ClientHelloParser.ParseExtension,,false,128,166,ParseExtension,,,4,"void node.crypto.ClientHelloParser.ParseExtension (uint16_t,uint8_t*,size_t)"
24838,METHOD,crypto\crypto_clienthello.cc:<global>,TYPE_DECL,"bool ClientHelloParser::ParseTLSClientHello(const uint8_t* data, size_t avail) {
  const uint8_t* body;

  // Skip frame header, hello header, protocol version and random data
  size_t session_offset = body_offset_ + 4 + 2 + 32;

  if (session_offset + 1 >= avail)
    return false;

  body = data + session_offset;
  session_size_ = *body;
  session_id_ = body + 1;

  size_t cipher_offset = session_offset + 1 + session_size_;

  // Session OOB failure
  if (cipher_offset + 1 >= avail)
    return false;

  uint16_t cipher_len =
      (data[cipher_offset] << 8) + data[cipher_offset + 1];
  size_t comp_offset = cipher_offset + 2 + cipher_len;

  // Cipher OOB failure
  if (comp_offset >= avail)
    return false;

  uint8_t comp_len = data[comp_offset];
  size_t extension_offset = comp_offset + 1 + comp_len;

  // Compression OOB failure
  if (extension_offset > avail)
    return false;

  // No extensions present
  if (extension_offset == avail)
    return true;

  size_t ext_off = exte...",1,1,crypto\crypto_clienthello.cc,node.crypto.ClientHelloParser.ParseTLSClientHello,,false,169,235,ParseTLSClientHello,,,5,"bool node.crypto.ClientHelloParser.ParseTLSClientHello (uint8_t*,size_t)"
25039,METHOD,crypto\crypto_clienthello.hpp:<global>,TYPE_DECL,<global>,1,43,crypto\crypto_clienthello.hpp,crypto\crypto_clienthello.hpp:<global>,,false,1,131,<global>,,,1,
25042,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,[&]() { OPENSSL_free(value_str); },40,73,crypto\crypto_common.cc,node.crypto.GetX509NameObject.<lambda>0,,false,995,995,<lambda>0,,,1,ANY node.crypto.GetX509NameObject.<lambda>0 ()
25092,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,<global>,1,38,crypto\crypto_common.hpp,crypto\crypto_common.cc:<global>,,false,1,1404,<global>,,,1,
25118,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"X509Pointer SSL_CTX_get_issuer(SSL_CTX* ctx, X509* cert) {
  X509_STORE* store = SSL_CTX_get_cert_store(ctx);
  DeleteFnPtr<X509_STORE_CTX, X509_STORE_CTX_free> store_ctx(
      X509_STORE_CTX_new());
  X509Pointer result;
  X509* issuer;
  if (store_ctx.get() != nullptr &&
      X509_STORE_CTX_init(store_ctx.get(), store, nullptr, nullptr) == 1 &&
      X509_STORE_CTX_get1_issuer(&issuer, store_ctx.get(), cert) == 1) {
    result.reset(issuer);
  }
  return result;
}",1,1,crypto\crypto_common.cc,node.crypto.SSL_CTX_get_issuer,,false,54,66,SSL_CTX_get_issuer,,,5,"X509Pointer node.crypto.SSL_CTX_get_issuer (SSL_CTX*,X509*)"
25176,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"void LogSecret(
    const SSLPointer& ssl,
    const char* name,
    const unsigned char* secret,
    size_t secretlen) {
  auto keylog_cb = SSL_CTX_get_keylog_callback(SSL_get_SSL_CTX(ssl.get()));
  // All supported versions of TLS/SSL fix the client random to the same size.
  constexpr size_t kTlsClientRandomSize = SSL3_RANDOM_SIZE;
  unsigned char crandom[kTlsClientRandomSize];

  if (keylog_cb == nullptr ||
      SSL_get_client_random(ssl.get(), crandom, kTlsClientRandomSize) !=
          kTlsClientRandomSize) {
    return;
  }

  std::string line = name;
  line += "" "" + StringBytes::hex_encode(reinterpret_cast<const char*>(crandom),
                                        kTlsClientRandomSize);
  line += "" "" + StringBytes::hex_encode(
      reinterpret_cast<const char*>(secret), secretlen);
  keylog_cb(ssl.get(), line.c_str());
}",1,1,crypto\crypto_common.cc,node.crypto.LogSecret,,false,68,90,LogSecret,,,6,"void node.crypto.LogSecret (SSLPointer,char*,unsigned char*,size_t)"
25251,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"MaybeLocal<Value> GetSSLOCSPResponse(
    Environment* env,
    SSL* ssl,
    Local<Value> default_value) {
  const unsigned char* resp;
  int len = SSL_get_tlsext_status_ocsp_resp(ssl, &resp);
  if (resp == nullptr)
    return default_value;

  Local<Value> ret;
  MaybeLocal<Object> maybe_buffer =
      Buffer::Copy(env, reinterpret_cast<const char*>(resp), len);

  if (!maybe_buffer.ToLocal(&ret))
    return MaybeLocal<Value>();

  return ret;
}",1,1,crypto\crypto_common.cc,node.crypto.GetSSLOCSPResponse,,false,92,109,GetSSLOCSPResponse,,,7,"MaybeLocal<Value> node.crypto.GetSSLOCSPResponse (Environment*,SSL*,Local<Value>)"
25306,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"bool SetTLSSession(
    const SSLPointer& ssl,
    const SSLSessionPointer& session) {
  return session != nullptr && SSL_set_session(ssl.get(), session.get()) == 1;
}",1,1,crypto\crypto_common.cc,node.crypto.SetTLSSession,,false,111,115,SetTLSSession,,,8,"bool node.crypto.SetTLSSession (SSLPointer,SSLSessionPointer)"
25328,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"SSLSessionPointer GetTLSSession(const unsigned char* buf, size_t length) {
  return SSLSessionPointer(d2i_SSL_SESSION(nullptr, &buf, length));
}",1,1,crypto\crypto_common.cc,node.crypto.GetTLSSession,,false,117,119,GetTLSSession,,,9,"SSLSessionPointer node.crypto.GetTLSSession (unsigned char*,size_t)"
25341,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"long VerifyPeerCertificate(  // NOLINT(runtime/int)
    const SSLPointer& ssl,
    long def) {  // NOLINT(runtime/int)
  long err = def;  // NOLINT(runtime/int)
  if (X509* peer_cert = SSL_get_peer_certificate(ssl.get())) {
    X509_free(peer_cert);
    err = SSL_get_verify_result(ssl.get());
  } else {
    const SSL_CIPHER* curr_cipher = SSL_get_current_cipher(ssl.get());
    const SSL_SESSION* sess = SSL_get_session(ssl.get());
    // Allow no-cert for PSK authentication in TLS1.2 and lower.
    // In TLS1.3 check that session was reused because TLS1.3 PSK
    // looks like session resumption.
    if (SSL_CIPHER_get_auth_nid(curr_cipher) == NID_auth_psk ||
        (SSL_SESSION_get_protocol_version(sess) == TLS1_3_VERSION &&
         SSL_session_reused(ssl.get()))) {
      return X509_V_OK;
    }
  }
  return err;
}",1,1,crypto\crypto_common.cc,node.crypto.VerifyPeerCertificate,,false,121,141,VerifyPeerCertificate,,,10,"long node.crypto.VerifyPeerCertificate (SSLPointer,long)"
25410,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"bool UseSNIContext(
    const SSLPointer& ssl, BaseObjectPtr<SecureContext> context) {
  SSL_CTX* ctx = context->ctx().get();
  X509* x509 = SSL_CTX_get0_certificate(ctx);
  EVP_PKEY* pkey = SSL_CTX_get0_privatekey(ctx);
  STACK_OF(X509)* chain;

  int err = SSL_CTX_get0_chain_certs(ctx, &chain);
  if (err == 1) err = SSL_use_certificate(ssl.get(), x509);
  if (err == 1) err = SSL_use_PrivateKey(ssl.get(), pkey);
  if (err == 1 && chain != nullptr) err = SSL_set1_chain(ssl.get(), chain);
  return err == 1;
}",1,1,crypto\crypto_common.cc,node.crypto.UseSNIContext,,false,143,155,UseSNIContext,,,11,"bool node.crypto.UseSNIContext (SSLPointer,BaseObjectPtr<SecureContext>)"
25494,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"const char* GetClientHelloALPN(const SSLPointer& ssl) {
  const unsigned char* buf;
  size_t len;
  size_t rem;

  if (!SSL_client_hello_get0_ext(
          ssl.get(),
          TLSEXT_TYPE_application_layer_protocol_negotiation,
          &buf,
          &rem) ||
      rem < 2) {
    return nullptr;
  }

  len = (buf[0] << 8) | buf[1];
  if (len + 2 != rem) return nullptr;
  return reinterpret_cast<const char*>(buf + 3);
}",1,1,crypto\crypto_common.cc,node.crypto.GetClientHelloALPN,,false,157,174,GetClientHelloALPN,,,12,const char* node.crypto.GetClientHelloALPN (SSLPointer)
25547,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"const char* GetClientHelloServerName(const SSLPointer& ssl) {
  const unsigned char* buf;
  size_t len;
  size_t rem;

  if (!SSL_client_hello_get0_ext(
          ssl.get(),
          TLSEXT_TYPE_server_name,
          &buf,
          &rem) || rem <= 2) {
    return nullptr;
  }

  len = (*buf << 8) | *(buf + 1);
  if (len + 2 != rem)
    return nullptr;
  rem = len;

  if (rem == 0 || *(buf + 2) != TLSEXT_NAMETYPE_host_name) return nullptr;
  rem--;
  if (rem <= 2)
    return nullptr;
  len = (*(buf + 3) << 8) | *(buf + 4);
  if (len + 2 > rem)
    return nullptr;
  return reinterpret_cast<const char*>(buf + 5);
}",1,1,crypto\crypto_common.cc,node.crypto.GetClientHelloServerName,,false,176,202,GetClientHelloServerName,,,13,const char* node.crypto.GetClientHelloServerName (SSLPointer)
25648,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"const char* GetServerName(SSL* ssl) {
  return SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name);
}",1,1,crypto\crypto_common.cc,node.crypto.GetServerName,,false,204,206,GetServerName,,,14,const char* node.crypto.GetServerName (SSL*)
25657,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"bool SetGroups(SecureContext* sc, const char* groups) {
  return SSL_CTX_set1_groups_list(sc->ctx().get(), groups) == 1;
}",1,1,crypto\crypto_common.cc,node.crypto.SetGroups,,false,208,210,SetGroups,,,15,"bool node.crypto.SetGroups (SecureContext*,char*)"
25675,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"const char* X509ErrorCode(long err) {  // NOLINT(runtime/int)
  const char* code = ""UNSPECIFIED"";
#define CASE_X509_ERR(CODE) case X509_V_ERR_##CODE: code = #CODE; break;
  switch (err) {
    // if you modify anything in here, *please* update the respective section in
    // doc/api/tls.md as well
    CASE_X509_ERR(UNABLE_TO_GET_ISSUER_CERT)
    CASE_X509_ERR(UNABLE_TO_GET_CRL)
    CASE_X509_ERR(UNABLE_TO_DECRYPT_CERT_SIGNATURE)
    CASE_X509_ERR(UNABLE_TO_DECRYPT_CRL_SIGNATURE)
    CASE_X509_ERR(UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY)
    CASE_X509_ERR(CERT_SIGNATURE_FAILURE)
    CASE_X509_ERR(CRL_SIGNATURE_FAILURE)
    CASE_X509_ERR(CERT_NOT_YET_VALID)
    CASE_X509_ERR(CERT_HAS_EXPIRED)
    CASE_X509_ERR(CRL_NOT_YET_VALID)
    CASE_X509_ERR(CRL_HAS_EXPIRED)
    CASE_X509_ERR(ERROR_IN_CERT_NOT_BEFORE_FIELD)
    CASE_X509_ERR(ERROR_IN_CERT_NOT_AFTER_FIELD)
    CASE_X509_ERR(ERROR_IN_CRL_LAST_UPDATE_FIELD)
    CASE_X509_ERR(ERROR_IN_CRL_NEXT_UPDATE_FIELD)
    CASE_X509_ERR(OUT_OF_MEM)
 ...",1,4,crypto\crypto_common.cc,node.crypto.X509ErrorCode,,false,212,249,X509ErrorCode,,,16,const char* node.crypto.X509ErrorCode (long)
25913,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"MaybeLocal<Value> GetValidationErrorReason(Environment* env, int err) {
  if (err == 0)
    return Undefined(env->isolate());
  const char* reason = X509_verify_cert_error_string(err);
  return OneByteString(env->isolate(), reason);
}",1,1,crypto\crypto_common.cc,node.crypto.GetValidationErrorReason,,false,251,256,GetValidationErrorReason,,,17,"MaybeLocal<Value> node.crypto.GetValidationErrorReason (Environment*,int)"
25942,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"MaybeLocal<Value> GetValidationErrorCode(Environment* env, int err) {
  if (err == 0)
    return Undefined(env->isolate());
  return OneByteString(env->isolate(), X509ErrorCode(err));
}",1,1,crypto\crypto_common.cc,node.crypto.GetValidationErrorCode,,false,258,262,GetValidationErrorCode,,,18,"MaybeLocal<Value> node.crypto.GetValidationErrorCode (Environment*,int)"
25967,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"MaybeLocal<Value> GetCert(Environment* env, const SSLPointer& ssl) {
  ClearErrorOnReturn clear_error_on_return;
  X509* cert = SSL_get_certificate(ssl.get());
  if (cert == nullptr)
    return Undefined(env->isolate());

  MaybeLocal<Object> maybe_cert = X509ToObject(env, cert);
  return maybe_cert.FromMaybe<Value>(Local<Value>());
}",1,1,crypto\crypto_common.cc,node.crypto.GetCert,,false,264,272,GetCert,,,19,"MaybeLocal<Value> node.crypto.GetCert (Environment*,SSLPointer)"
26010,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"Local<Value> ToV8Value(Environment* env, const BIOPointer& bio) {
  BUF_MEM* mem;
  BIO_get_mem_ptr(bio.get(), &mem);
  MaybeLocal<String> ret =
      String::NewFromUtf8(
          env->isolate(),
          mem->data,
          NewStringType::kNormal,
          mem->length);
  CHECK_EQ(BIO_reset(bio.get()), 1);
  return ret.FromMaybe(Local<Value>());
}",1,1,crypto\crypto_common.cc,node.crypto.ToV8Value,,false,274,285,ToV8Value,,,20,"Local<Value> node.crypto.ToV8Value (Environment*,BIOPointer)"
26061,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"bool Set(
    Local<Context> context,
    Local<Object> target,
    Local<Value> name,
    MaybeLocal<T> maybe_value) {
  Local<Value> value;
  if (!maybe_value.ToLocal(&value))
    return false;

  // Undefined is ignored, but still considered successful
  if (value->IsUndefined())
    return true;

  return !target->Set(context, name, value).IsNothing();
}",1,1,crypto\crypto_common.cc,node.crypto.anonymous_namespace_1.Set,,false,289,303,Set,,,1,"bool node.crypto.anonymous_namespace_1.Set<T> (Local<Context>,Local<Object>,Local<Value>,MaybeLocal<T>)"
26105,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"MaybeLocal<Value> GetCipherValue(Environment* env, const SSL_CIPHER* cipher) {
  if (cipher == nullptr)
    return Undefined(env->isolate());

  return OneByteString(env->isolate(), getstr(cipher));
}",1,1,crypto\crypto_common.cc,node.crypto.anonymous_namespace_2.GetCipherValue,,false,306,311,GetCipherValue,,,2,"MaybeLocal<Value> node.crypto.anonymous_namespace_2.GetCipherValue<const char*(*)(const SSL_CIPHER*)> (Environment*,SSL_CIPHER*)"
26143,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"MaybeLocal<Object> AddIssuerChainToObject(
    X509Pointer* cert,
    Local<Object> object,
    StackOfX509&& peer_certs,
    Environment* const env) {
  Local<Context> context = env->isolate()->GetCurrentContext();
  cert->reset(sk_X509_delete(peer_certs.get(), 0));
  for (;;) {
    int i;
    for (i = 0; i < sk_X509_num(peer_certs.get()); i++) {
      X509* ca = sk_X509_value(peer_certs.get(), i);
      if (X509_check_issued(ca, cert->get()) != X509_V_OK)
        continue;

      Local<Object> ca_info;
      MaybeLocal<Object> maybe_ca_info = X509ToObject(env, ca);
      if (!maybe_ca_info.ToLocal(&ca_info))
        return MaybeLocal<Object>();

      if (!Set<Object>(context, object, env->issuercert_string(), ca_info))
        return MaybeLocal<Object>();
      object = ca_info;

      // NOTE: Intentionally freeing cert that is not used anymore.
      // Delete cert and continue aggregating issuers.
      cert->reset(sk_X509_delete(peer_certs.get(), i));
      break;
    }

    ...",1,1,crypto\crypto_common.cc,node.crypto.anonymous_namespace_3.AddIssuerChainToObject,,false,333,367,AddIssuerChainToObject,,,10,"MaybeLocal<Object> node.crypto.anonymous_namespace_3.AddIssuerChainToObject (X509Pointer*,Local<Object>,StackOfX509,Environment*)"
26281,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"MaybeLocal<Object> GetLastIssuedCert(
    X509Pointer* cert,
    const SSLPointer& ssl,
    Local<Object> issuer_chain,
    Environment* const env) {
  Local<Context> context = env->isolate()->GetCurrentContext();
  while (X509_check_issued(cert->get(), cert->get()) != X509_V_OK) {
    X509Pointer ca;
    if (!(ca = SSL_CTX_get_issuer(SSL_get_SSL_CTX(ssl.get()), cert->get())))
      break;

    Local<Object> ca_info;
    MaybeLocal<Object> maybe_ca_info = X509ToObject(env, ca.get());
    if (!maybe_ca_info.ToLocal(&ca_info))
      return MaybeLocal<Object>();

    if (!Set<Object>(context, issuer_chain, env->issuercert_string(), ca_info))
      return MaybeLocal<Object>();
    issuer_chain = ca_info;

    // For self-signed certificates whose keyUsage field does not include
    // keyCertSign, X509_check_issued() will return false. Avoid going into an
    // infinite loop by checking if SSL_CTX_get_issuer() returned the same
    // certificate.
    if (cert->get() == ca.get()) break...",1,1,crypto\crypto_common.cc,node.crypto.anonymous_namespace_4.GetLastIssuedCert,,false,369,399,GetLastIssuedCert,,,11,"MaybeLocal<Object> node.crypto.anonymous_namespace_4.GetLastIssuedCert (X509Pointer*,SSLPointer,Local<Object>,Environment*)"
26402,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"void AddFingerprintDigest(
    const unsigned char* md,
    unsigned int md_size,
    char fingerprint[3 * EVP_MAX_MD_SIZE]) {
  unsigned int i;
  const char hex[] = ""0123456789ABCDEF"";

  for (i = 0; i < md_size; i++) {
    fingerprint[3*i] = hex[(md[i] & 0xf0) >> 4];
    fingerprint[(3*i)+1] = hex[(md[i] & 0x0f)];
    fingerprint[(3*i)+2] = ':';
  }

  DCHECK_GT(md_size, 0);
  fingerprint[(3 * (md_size - 1)) + 2] = '\0';
}",1,1,crypto\crypto_common.cc,node.crypto.anonymous_namespace_5.AddFingerprintDigest,,false,401,416,AddFingerprintDigest,,,12,"void node.crypto.anonymous_namespace_5.AddFingerprintDigest (unsigned char*,unsigned int,char[3 * EVP_MAX_MD_SIZE])"
26478,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"MaybeLocal<Value> GetCurveName(Environment* env, const int nid) {
  const char* name = nid2string(nid);
  return name != nullptr ?
      MaybeLocal<Value>(OneByteString(env->isolate(), name)) :
      MaybeLocal<Value>(Undefined(env->isolate()));
}",1,1,crypto\crypto_common.cc,node.crypto.anonymous_namespace_6.GetCurveName,,false,419,424,GetCurveName,,,13,"MaybeLocal<Value> node.crypto.anonymous_namespace_6.GetCurveName<const char*(*)(int)> (Environment*,int)"
26513,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"MaybeLocal<Value> GetECPubKey(
    Environment* env,
    const EC_GROUP* group,
    const ECPointer& ec) {
  const EC_POINT* pubkey = EC_KEY_get0_public_key(ec.get());
  if (pubkey == nullptr)
    return Undefined(env->isolate());

  return ECPointToBuffer(
      env,
      group,
      pubkey,
      EC_KEY_get_conv_form(ec.get()),
      nullptr).FromMaybe(Local<Object>());
}",1,1,crypto\crypto_common.cc,node.crypto.anonymous_namespace_7.GetECPubKey,,false,426,440,GetECPubKey,,,14,"MaybeLocal<Value> node.crypto.anonymous_namespace_7.GetECPubKey (Environment*,EC_GROUP*,ECPointer)"
26554,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"MaybeLocal<Value> GetECGroup(
    Environment* env,
    const EC_GROUP* group,
    const ECPointer& ec) {
  if (group == nullptr)
    return Undefined(env->isolate());

  int bits = EC_GROUP_order_bits(group);
  if (bits <= 0)
    return Undefined(env->isolate());

  return Integer::New(env->isolate(), bits);
}",1,1,crypto\crypto_common.cc,node.crypto.anonymous_namespace_8.GetECGroup,,false,442,454,GetECGroup,,,15,"MaybeLocal<Value> node.crypto.anonymous_namespace_8.GetECGroup (Environment*,EC_GROUP*,ECPointer)"
26598,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"MaybeLocal<Object> GetPubKey(Environment* env, const RSAPointer& rsa) {
  int size = i2d_RSA_PUBKEY(rsa.get(), nullptr);
  CHECK_GE(size, 0);

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), size);
  }

  unsigned char* serialized = reinterpret_cast<unsigned char*>(bs->Data());
  CHECK_GE(i2d_RSA_PUBKEY(rsa.get(), &serialized), 0);

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  return Buffer::New(env, ab, 0, ab->ByteLength()).FromMaybe(Local<Object>());
}",1,1,crypto\crypto_common.cc,node.crypto.anonymous_namespace_9.GetPubKey,,false,456,471,GetPubKey,,,16,"MaybeLocal<Object> node.crypto.anonymous_namespace_9.GetPubKey (Environment*,RSAPointer)"
26694,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"MaybeLocal<Value> GetExponentString(
    Environment* env,
    const BIOPointer& bio,
    const BIGNUM* e) {
  uint64_t exponent_word = static_cast<uint64_t>(BN_get_word(e));
  BIO_printf(bio.get(), ""0x%"" PRIx64, exponent_word);
  return ToV8Value(env, bio);
}",1,1,crypto\crypto_common.cc,node.crypto.anonymous_namespace_10.GetExponentString,,false,473,480,GetExponentString,,,17,"MaybeLocal<Value> node.crypto.anonymous_namespace_10.GetExponentString (Environment*,BIOPointer,BIGNUM*)"
26713,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"Local<Value> GetBits(Environment* env, const BIGNUM* n) {
  return Integer::New(env->isolate(), BN_num_bits(n));
}",1,1,crypto\crypto_common.cc,node.crypto.anonymous_namespace_11.GetBits,,false,482,484,GetBits,,,18,"Local<Value> node.crypto.anonymous_namespace_11.GetBits (Environment*,BIGNUM*)"
26730,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"MaybeLocal<Value> GetModulusString(
    Environment* env,
    const BIOPointer& bio,
    const BIGNUM* n) {
  BN_print(bio.get(), n);
  return ToV8Value(env, bio);
}",1,1,crypto\crypto_common.cc,node.crypto.anonymous_namespace_12.GetModulusString,,false,486,492,GetModulusString,,,19,"MaybeLocal<Value> node.crypto.anonymous_namespace_12.GetModulusString (Environment*,BIOPointer,BIGNUM*)"
26747,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"MaybeLocal<Value> GetRawDERCertificate(Environment* env, X509* cert) {
  int size = i2d_X509(cert, nullptr);

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), size);
  }

  unsigned char* serialized = reinterpret_cast<unsigned char*>(bs->Data());
  CHECK_GE(i2d_X509(cert, &serialized), 0);

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  return Buffer::New(env, ab, 0, ab->ByteLength()).FromMaybe(Local<Object>());
}",1,1,crypto\crypto_common.cc,node.crypto.GetRawDERCertificate,,false,495,509,GetRawDERCertificate,,,22,"MaybeLocal<Value> node.crypto.GetRawDERCertificate (Environment*,X509*)"
26834,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"MaybeLocal<Value> GetSerialNumber(Environment* env, X509* cert) {
  if (ASN1_INTEGER* serial_number = X509_get_serialNumber(cert)) {
    BignumPointer bn(ASN1_INTEGER_to_BN(serial_number, nullptr));
    if (bn) {
      char* data = BN_bn2hex(bn.get());
      ByteSource buf = ByteSource::Allocated(data, strlen(data));
      if (buf) return OneByteString(env->isolate(), buf.data<unsigned char>());
    }
  }

  return Undefined(env->isolate());
}",1,1,crypto\crypto_common.cc,node.crypto.GetSerialNumber,,false,511,522,GetSerialNumber,,,23,"MaybeLocal<Value> node.crypto.GetSerialNumber (Environment*,X509*)"
26893,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"MaybeLocal<Value> GetKeyUsage(Environment* env, X509* cert) {
  StackOfASN1 eku(static_cast<STACK_OF(ASN1_OBJECT)*>(
      X509_get_ext_d2i(cert, NID_ext_key_usage, nullptr, nullptr)));
  if (eku) {
    const int count = sk_ASN1_OBJECT_num(eku.get());
    MaybeStackBuffer<Local<Value>, 16> ext_key_usage(count);
    char buf[256];

    int j = 0;
    for (int i = 0; i < count; i++) {
      if (OBJ_obj2txt(buf,
                      sizeof(buf),
                      sk_ASN1_OBJECT_value(eku.get(), i), 1) >= 0) {
        ext_key_usage[j++] = OneByteString(env->isolate(), buf);
      }
    }

    return Array::New(env->isolate(), ext_key_usage.out(), count);
  }

  return Undefined(env->isolate());
}",1,1,crypto\crypto_common.cc,node.crypto.GetKeyUsage,,false,524,545,GetKeyUsage,,,24,"MaybeLocal<Value> node.crypto.GetKeyUsage (Environment*,X509*)"
26979,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"MaybeLocal<Value> GetCurrentCipherName(Environment* env,
                                       const SSLPointer& ssl) {
  return GetCipherName(env, SSL_get_current_cipher(ssl.get()));
}",1,1,crypto\crypto_common.cc,node.crypto.GetCurrentCipherName,,false,547,550,GetCurrentCipherName,,,25,"MaybeLocal<Value> node.crypto.GetCurrentCipherName (Environment*,SSLPointer)"
26993,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"MaybeLocal<Value> GetCurrentCipherVersion(Environment* env,
                                          const SSLPointer& ssl) {
  return GetCipherVersion(env, SSL_get_current_cipher(ssl.get()));
}",1,1,crypto\crypto_common.cc,node.crypto.GetCurrentCipherVersion,,false,552,555,GetCurrentCipherVersion,,,26,"MaybeLocal<Value> node.crypto.GetCurrentCipherVersion (Environment*,SSLPointer)"
27007,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"MaybeLocal<Value> GetFingerprintDigest(
    Environment* env,
    const EVP_MD* method,
    X509* cert) {
  unsigned char md[EVP_MAX_MD_SIZE];
  unsigned int md_size;
  char fingerprint[EVP_MAX_MD_SIZE * 3];

  if (X509_digest(cert, method, md, &md_size)) {
    AddFingerprintDigest(md, md_size, fingerprint);
    return OneByteString(env->isolate(), fingerprint);
  }
  return Undefined(env->isolate());
}",1,1,crypto\crypto_common.cc,node.crypto.GetFingerprintDigest,,false,557,570,GetFingerprintDigest,,,27,"MaybeLocal<Value> node.crypto.GetFingerprintDigest (Environment*,EVP_MD*,X509*)"
27042,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"MaybeLocal<Value> GetValidTo(
    Environment* env,
    X509* cert,
    const BIOPointer& bio) {
  ASN1_TIME_print(bio.get(), X509_get0_notAfter(cert));
  return ToV8Value(env, bio);
}",1,1,crypto\crypto_common.cc,node.crypto.GetValidTo,,false,572,578,GetValidTo,,,28,"MaybeLocal<Value> node.crypto.GetValidTo (Environment*,X509*,BIOPointer)"
27060,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"MaybeLocal<Value> GetValidFrom(
    Environment* env,
    X509* cert,
    const BIOPointer& bio) {
  ASN1_TIME_print(bio.get(), X509_get0_notBefore(cert));
  return ToV8Value(env, bio);
}",1,1,crypto\crypto_common.cc,node.crypto.GetValidFrom,,false,580,586,GetValidFrom,,,29,"MaybeLocal<Value> node.crypto.GetValidFrom (Environment*,X509*,BIOPointer)"
27078,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"static inline bool IsSafeAltName(const char* name, size_t length, bool utf8) {
  for (size_t i = 0; i < length; i++) {
    char c = name[i];
    switch (c) {
    case '""':
    case '\\':
      // These mess with encoding rules.
      // Fall through.
    case ',':
      // Commas make it impossible to split the list of subject alternative
      // names unambiguously, which is why we have to escape.
      // Fall through.
    case '\'':
      // Single quotes are unlikely to appear in any legitimate values, but they
      // could be used to make a value look like it was escaped (i.e., enclosed
      // in single/double quotes).
      return false;
    default:
      if (utf8) {
        // In UTF8 strings, we require escaping for any ASCII control character,
        // but NOT for non-ASCII characters. Note that all bytes of any code
        // point that consists of more than a single byte have their MSB set.
        if (static_cast<unsigned char>(c) < ' ' || c == '\x7f') {
       ...",1,1,crypto\crypto_common.cc,node.crypto.IsSafeAltName,,false,588,624,IsSafeAltName,,,30,"bool node.crypto.IsSafeAltName (char*,size_t,bool)"
27148,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"static inline void PrintAltName(const BIOPointer& out, const char* name,
                                size_t length, bool utf8,
                                const char* safe_prefix) {
  if (IsSafeAltName(name, length, utf8)) {
    // For backward-compatibility, append ""safe"" names without any
    // modifications.
    if (safe_prefix != nullptr) {
      BIO_printf(out.get(), ""%s:"", safe_prefix);
    }
    BIO_write(out.get(), name, length);
  } else {
    // If a name is not ""safe"", we cannot embed it without special
    // encoding. This does not usually happen, but we don't want to hide
    // it from the user either. We use JSON compatible escaping here.
    BIO_write(out.get(), ""\"""", 1);
    if (safe_prefix != nullptr) {
      BIO_printf(out.get(), ""%s:"", safe_prefix);
    }
    for (size_t j = 0; j < length; j++) {
      char c = static_cast<char>(name[j]);
      if (c == '\\') {
        BIO_write(out.get(), ""\\\\"", 2);
      } else if (c == '""') {
        BIO_write(out.g...",1,1,crypto\crypto_common.cc,node.crypto.PrintAltName,,false,626,668,PrintAltName,,,31,"void node.crypto.PrintAltName (BIOPointer,char*,size_t,bool,char*)"
27319,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"static inline void PrintLatin1AltName(const BIOPointer& out,
                                      const ASN1_IA5STRING* name,
                                      const char* safe_prefix = nullptr) {
  PrintAltName(out, reinterpret_cast<const char*>(name->data), name->length,
               false, safe_prefix);
}",1,1,crypto\crypto_common.cc,node.crypto.PrintLatin1AltName,,false,670,675,PrintLatin1AltName,,,32,"void node.crypto.PrintLatin1AltName (BIOPointer,ASN1_IA5STRING*,char*)"
27338,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"static inline void PrintUtf8AltName(const BIOPointer& out,
                                    const ASN1_UTF8STRING* name,
                                    const char* safe_prefix = nullptr) {
  PrintAltName(out, reinterpret_cast<const char*>(name->data), name->length,
               true, safe_prefix);
}",1,1,crypto\crypto_common.cc,node.crypto.PrintUtf8AltName,,false,677,682,PrintUtf8AltName,,,33,"void node.crypto.PrintUtf8AltName (BIOPointer,ASN1_UTF8STRING*,char*)"
27357,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"static bool PrintGeneralName(const BIOPointer& out, const GENERAL_NAME* gen) {
  if (gen->type == GEN_DNS) {
    ASN1_IA5STRING* name = gen->d.dNSName;
    BIO_write(out.get(), ""DNS:"", 4);
    // Note that the preferred name syntax (see RFCs 5280 and 1034) with
    // wildcards is a subset of what we consider ""safe"", so spec-compliant DNS
    // names will never need to be escaped.
    PrintLatin1AltName(out, name);
  } else if (gen->type == GEN_EMAIL) {
    ASN1_IA5STRING* name = gen->d.rfc822Name;
    BIO_write(out.get(), ""email:"", 6);
    PrintLatin1AltName(out, name);
  } else if (gen->type == GEN_URI) {
    ASN1_IA5STRING* name = gen->d.uniformResourceIdentifier;
    BIO_write(out.get(), ""URI:"", 4);
    // The set of ""safe"" names was designed to include just about any URI,
    // with a few exceptions, most notably URIs that contains commas (see
    // RFC 2396). In other words, most legitimate URIs will not require
    // escaping.
    PrintLatin1AltName(out, name);
  } else i...",1,1,crypto\crypto_common.cc,node.crypto.PrintGeneralName,,false,686,815,PrintGeneralName,,,34,"bool node.crypto.PrintGeneralName (BIOPointer,GENERAL_NAME*)"
27455,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,BIOPointer tmp(BIO_new(BIO_s_mem()));,16,40,crypto\crypto_common.cc,node.crypto.PrintGeneralName.tmp,,false,720,720,tmp,,,2,BIOPointer node.crypto.PrintGeneralName.tmp (BIO_new)
27783,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"bool SafeX509SubjectAltNamePrint(const BIOPointer& out, X509_EXTENSION* ext) {
  const X509V3_EXT_METHOD* method = X509V3_EXT_get(ext);
  CHECK(method == X509V3_EXT_get_nid(NID_subject_alt_name));

  GENERAL_NAMES* names = static_cast<GENERAL_NAMES*>(X509V3_EXT_d2i(ext));
  if (names == nullptr)
    return false;

  bool ok = true;

  for (int i = 0; i < sk_GENERAL_NAME_num(names); i++) {
    GENERAL_NAME* gen = sk_GENERAL_NAME_value(names, i);

    if (i != 0)
      BIO_write(out.get(), "", "", 2);

    if (!(ok = PrintGeneralName(out, gen))) {
      break;
    }
  }
  sk_GENERAL_NAME_pop_free(names, GENERAL_NAME_free);

  return ok;
}",1,1,crypto\crypto_common.cc,node.crypto.SafeX509SubjectAltNamePrint,,false,817,840,SafeX509SubjectAltNamePrint,,,35,"bool node.crypto.SafeX509SubjectAltNamePrint (BIOPointer,X509_EXTENSION*)"
27862,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"bool SafeX509InfoAccessPrint(const BIOPointer& out, X509_EXTENSION* ext) {
  const X509V3_EXT_METHOD* method = X509V3_EXT_get(ext);
  CHECK(method == X509V3_EXT_get_nid(NID_info_access));

  AUTHORITY_INFO_ACCESS* descs =
      static_cast<AUTHORITY_INFO_ACCESS*>(X509V3_EXT_d2i(ext));
  if (descs == nullptr)
    return false;

  bool ok = true;

  for (int i = 0; i < sk_ACCESS_DESCRIPTION_num(descs); i++) {
    ACCESS_DESCRIPTION* desc = sk_ACCESS_DESCRIPTION_value(descs, i);

    if (i != 0)
      BIO_write(out.get(), ""\n"", 1);

    char objtmp[80];
    i2t_ASN1_OBJECT(objtmp, sizeof(objtmp), desc->method);
    BIO_printf(out.get(), ""%s - "", objtmp);
    if (!(ok = PrintGeneralName(out, desc->location))) {
      break;
    }
  }
  sk_ACCESS_DESCRIPTION_pop_free(descs, ACCESS_DESCRIPTION_free);

#if OPENSSL_VERSION_MAJOR < 3
  BIO_write(out.get(), ""\n"", 1);
#endif

  return ok;
}",1,1,crypto\crypto_common.cc,node.crypto.SafeX509InfoAccessPrint,,false,842,873,SafeX509InfoAccessPrint,,,36,"bool node.crypto.SafeX509InfoAccessPrint (BIOPointer,X509_EXTENSION*)"
27965,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"v8::MaybeLocal<v8::Value> GetSubjectAltNameString(Environment* env,
                                                  X509* cert,
                                                  const BIOPointer& bio) {
  int index = X509_get_ext_by_NID(cert, NID_subject_alt_name, -1);
  if (index < 0)
    return Undefined(env->isolate());

  X509_EXTENSION* ext = X509_get_ext(cert, index);
  CHECK_NOT_NULL(ext);

  if (!SafeX509SubjectAltNamePrint(bio, ext)) {
    CHECK_EQ(BIO_reset(bio.get()), 1);
    return v8::Null(env->isolate());
  }

  return ToV8Value(env, bio);
}",1,1,crypto\crypto_common.cc,node.crypto.GetSubjectAltNameString,,false,875,891,GetSubjectAltNameString,,,37,"MaybeLocal<v8::Value> node.crypto.GetSubjectAltNameString (Environment*,X509*,BIOPointer)"
28025,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"v8::MaybeLocal<v8::Value> GetInfoAccessString(Environment* env,
                                              X509* cert,
                                              const BIOPointer& bio) {
  int index = X509_get_ext_by_NID(cert, NID_info_access, -1);
  if (index < 0)
    return Undefined(env->isolate());

  X509_EXTENSION* ext = X509_get_ext(cert, index);
  CHECK_NOT_NULL(ext);

  if (!SafeX509InfoAccessPrint(bio, ext)) {
    CHECK_EQ(BIO_reset(bio.get()), 1);
    return v8::Null(env->isolate());
  }

  return ToV8Value(env, bio);
}",1,1,crypto\crypto_common.cc,node.crypto.GetInfoAccessString,,false,893,909,GetInfoAccessString,,,38,"MaybeLocal<v8::Value> node.crypto.GetInfoAccessString (Environment*,X509*,BIOPointer)"
28085,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"MaybeLocal<Value> GetIssuerString(Environment* env,
                                  X509* cert,
                                  const BIOPointer& bio) {
  X509_NAME* issuer_name = X509_get_issuer_name(cert);
  if (X509_NAME_print_ex(
          bio.get(),
          issuer_name,
          0,
          kX509NameFlagsMultiline) <= 0) {
    CHECK_EQ(BIO_reset(bio.get()), 1);
    return Undefined(env->isolate());
  }

  return ToV8Value(env, bio);
}",1,1,crypto\crypto_common.cc,node.crypto.GetIssuerString,,false,911,925,GetIssuerString,,,39,"MaybeLocal<Value> node.crypto.GetIssuerString (Environment*,X509*,BIOPointer)"
28126,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"MaybeLocal<Value> GetSubject(Environment* env,
                             X509* cert,
                             const BIOPointer& bio) {
  if (X509_NAME_print_ex(
          bio.get(),
          X509_get_subject_name(cert),
          0,
          kX509NameFlagsMultiline) <= 0) {
    CHECK_EQ(BIO_reset(bio.get()), 1);
    return Undefined(env->isolate());
  }

  return ToV8Value(env, bio);
}",1,1,crypto\crypto_common.cc,node.crypto.GetSubject,,false,927,940,GetSubject,,,40,"MaybeLocal<Value> node.crypto.GetSubject (Environment*,X509*,BIOPointer)"
28163,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"static MaybeLocal<Value> GetX509NameObject(Environment* env, X509* cert) {
  X509_NAME* name = get_name(cert);
  CHECK_NOT_NULL(name);

  int cnt = X509_NAME_entry_count(name);
  CHECK_GE(cnt, 0);

  Local<Object> result =
      Object::New(env->isolate(), Null(env->isolate()), nullptr, nullptr, 0);
  if (result.IsEmpty()) {
    return MaybeLocal<Value>();
  }

  for (int i = 0; i < cnt; i++) {
    X509_NAME_ENTRY* entry = X509_NAME_get_entry(name, i);
    CHECK_NOT_NULL(entry);

    // We intentionally ignore the value of X509_NAME_ENTRY_set because the
    // representation as an object does not allow grouping entries into sets
    // anyway, and multi-value RDNs are rare, i.e., the vast majority of
    // Relative Distinguished Names contains a single type-value pair only.
    const ASN1_OBJECT* type = X509_NAME_ENTRY_get_object(entry);
    const ASN1_STRING* value = X509_NAME_ENTRY_get_data(entry);

    // If OpenSSL knows the type, use the short name of the type as the key, and...",1,1,crypto\crypto_common.cc,node.crypto.GetX509NameObject,,false,943,1035,GetX509NameObject,,,41,"MaybeLocal<Value> node.crypto.GetX509NameObject<X509_NAME*(const X509*)> (Environment*,X509*)"
28487,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"MaybeLocal<Value> GetCurrentCipherValue(Environment* env,
                                        const SSLPointer& ssl) {
  return Get(env, SSL_get_current_cipher(ssl.get()));
}",1,1,crypto\crypto_common.cc,node.crypto.GetCurrentCipherValue,,false,1038,1041,GetCurrentCipherValue,,,42,"MaybeLocal<Value> node.crypto.GetCurrentCipherValue<MaybeLocal<Value>(*)(Environment*, const SSL_CIPHER*)> (Environment*,SSLPointer)"
28501,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"MaybeLocal<Array> GetClientHelloCiphers(
    Environment* env,
    const SSLPointer& ssl) {
  EscapableHandleScope scope(env->isolate());
  const unsigned char* buf;
  size_t len = SSL_client_hello_get0_ciphers(ssl.get(), &buf);
  size_t count = len / 2;
  MaybeStackBuffer<Local<Value>, 16> ciphers(count);
  int j = 0;
  for (size_t n = 0; n < len; n += 2) {
    const SSL_CIPHER* cipher = SSL_CIPHER_find(ssl.get(), buf);
    buf += 2;
    Local<Object> obj = Object::New(env->isolate());
    if (!Set(env->context(),
             obj,
             env->name_string(),
             GetCipherName(env, cipher)) ||
        !Set(env->context(),
             obj,
             env->standard_name_string(),
             GetCipherStandardName(env, cipher)) ||
        !Set(env->context(),
             obj,
             env->version_string(),
             GetCipherVersion(env, cipher))) {
      return MaybeLocal<Array>();
    }
    ciphers[j++] = obj;
  }
  Local<Array> ret = Array::New(env->isola...",1,1,crypto\crypto_common.cc,node.crypto.GetClientHelloCiphers,,false,1043,1074,GetClientHelloCiphers,,,43,"MaybeLocal<Array> node.crypto.GetClientHelloCiphers (Environment*,SSLPointer)"
28655,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"MaybeLocal<Object> GetCipherInfo(Environment* env, const SSLPointer& ssl) {
  if (SSL_get_current_cipher(ssl.get()) == nullptr)
    return MaybeLocal<Object>();
  EscapableHandleScope scope(env->isolate());
  Local<Object> info = Object::New(env->isolate());

  if (!Set<Value>(env->context(),
                  info,
                  env->name_string(),
                  GetCurrentCipherValue<GetCipherName>(env, ssl)) ||
      !Set<Value>(env->context(),
                  info,
                  env->standard_name_string(),
                  GetCurrentCipherValue<GetCipherStandardName>(env, ssl)) ||
      !Set<Value>(env->context(),
                  info,
                  env->version_string(),
                  GetCurrentCipherValue<GetCipherVersion>(env, ssl))) {
    return MaybeLocal<Object>();
  }

  return scope.Escape(info);
}",1,1,crypto\crypto_common.cc,node.crypto.GetCipherInfo,,false,1077,1099,GetCipherInfo,,,44,"MaybeLocal<Object> node.crypto.GetCipherInfo (Environment*,SSLPointer)"
28746,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"MaybeLocal<Object> GetEphemeralKey(Environment* env, const SSLPointer& ssl) {
  CHECK_EQ(SSL_is_server(ssl.get()), 0);
  EVP_PKEY* raw_key;

  EscapableHandleScope scope(env->isolate());
  Local<Object> info = Object::New(env->isolate());
  if (!SSL_get_server_tmp_key(ssl.get(), &raw_key))
    return scope.Escape(info);

  Local<Context> context = env->context();
  crypto::EVPKeyPointer key(raw_key);

  int kid = EVP_PKEY_id(key.get());
  int bits = EVP_PKEY_bits(key.get());
  switch (kid) {
    case EVP_PKEY_DH:
      if (!Set<String>(context, info, env->type_string(), env->dh_string()) ||
          !Set<Integer>(context,
               info,
               env->size_string(),
               Integer::New(env->isolate(), bits))) {
        return MaybeLocal<Object>();
      }
      break;
    case EVP_PKEY_EC:
    case EVP_PKEY_X25519:
    case EVP_PKEY_X448:
      {
        const char* curve_name;
        if (kid == EVP_PKEY_EC) {
          ECKeyPointer ec(EVP_PKEY_get1_EC_KEY(key.g...",1,1,crypto\crypto_common.cc,node.crypto.GetEphemeralKey,,false,1101,1156,GetEphemeralKey,,,45,"MaybeLocal<Object> node.crypto.GetEphemeralKey (Environment*,SSLPointer)"
28960,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"MaybeLocal<Object> ECPointToBuffer(Environment* env,
                                   const EC_GROUP* group,
                                   const EC_POINT* point,
                                   point_conversion_form_t form,
                                   const char** error) {
  size_t len = EC_POINT_point2oct(group, point, form, nullptr, 0, nullptr);
  if (len == 0) {
    if (error != nullptr) *error = ""Failed to get public key length"";
    return MaybeLocal<Object>();
  }

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), len);
  }

  len = EC_POINT_point2oct(group,
                           point,
                           form,
                           reinterpret_cast<unsigned char*>(bs->Data()),
                           bs->ByteLength(),
                           nullptr);
  if (len == 0) {
    if (error != nullptr) *error = ""Failed to get pub...",1,1,crypto\crypto_common.cc,node.crypto.ECPointToBuffer,,false,1158,1188,ECPointToBuffer,,,46,"MaybeLocal<Object> node.crypto.ECPointToBuffer (Environment*,EC_GROUP*,EC_POINT*,point_conversion_form_t,char**)"
29088,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"MaybeLocal<Value> GetPeerCert(
    Environment* env,
    const SSLPointer& ssl,
    bool abbreviated,
    bool is_server) {
  ClearErrorOnReturn clear_error_on_return;
  Local<Object> result;
  MaybeLocal<Object> maybe_cert;

  // NOTE: This is because of the odd OpenSSL behavior. On client `cert_chain`
  // contains the `peer_certificate`, but on server it doesn't.
  X509Pointer cert(is_server ? SSL_get_peer_certificate(ssl.get()) : nullptr);
  STACK_OF(X509)* ssl_certs = SSL_get_peer_cert_chain(ssl.get());
  if (!cert && (ssl_certs == nullptr || sk_X509_num(ssl_certs) == 0))
    return Undefined(env->isolate());

  // Short result requested.
  if (abbreviated) {
    maybe_cert =
        X509ToObject(env, cert ? cert.get() : sk_X509_value(ssl_certs, 0));
    return maybe_cert.ToLocal(&result) ? result : MaybeLocal<Value>();
  }

  StackOfX509 peer_certs = CloneSSLCerts(std::move(cert), ssl_certs);
  if (peer_certs == nullptr)
    return Undefined(env->isolate());

  // First and ma...",1,1,crypto\crypto_common.cc,node.crypto.GetPeerCert,,false,1190,1257,GetPeerCert,,,47,"MaybeLocal<Value> node.crypto.GetPeerCert (Environment*,SSLPointer,bool,bool)"
29308,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,"MaybeLocal<Object> X509ToObject(
    Environment* env,
    X509* cert) {
  EscapableHandleScope scope(env->isolate());
  Local<Context> context = env->context();
  Local<Object> info = Object::New(env->isolate());

  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);

  // X509_check_ca() returns a range of values. Only 1 means ""is a CA""
  auto is_ca = Boolean::New(env->isolate(), 1 == X509_check_ca(cert));
  if (!Set<Value>(context,
                  info,
                  env->subject_string(),
                  GetX509NameObject<X509_get_subject_name>(env, cert)) ||
      !Set<Value>(context,
                  info,
                  env->issuer_string(),
                  GetX509NameObject<X509_get_issuer_name>(env, cert)) ||
      !Set<Value>(context,
                  info,
                  env->subjectaltname_string(),
                  GetSubjectAltNameString(env, cert, bio)) ||
      !Set<Value>(context,
                  info,
                  env->infoaccess_string(),...",1,1,crypto\crypto_common.cc,node.crypto.X509ToObject,,false,1259,1401,X509ToObject,,,48,"MaybeLocal<Object> node.crypto.X509ToObject (Environment*,X509*)"
29342,METHOD,crypto\crypto_common.cc:<global>,TYPE_DECL,BIOPointer bio(BIO_new(BIO_s_mem()));,14,38,crypto\crypto_common.cc,node.crypto.X509ToObject.bio,,false,1266,1266,bio,,,5,BIOPointer node.crypto.X509ToObject.bio (BIO_new)
29760,METHOD,crypto\crypto_common.hpp:<global>,TYPE_DECL,<global>,1,38,crypto\crypto_common.hpp,crypto\crypto_common.hpp:<global>,,false,1,147,<global>,,,1,
29799,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,<global>,1,39,crypto\crypto_context.hpp,crypto\crypto_context.cc:<global>,,false,1,1400,<global>,,,1,
29815,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"inline X509_STORE* GetOrCreateRootCertStore() {
  // Guaranteed thread-safe by standard, just don't use -fno-threadsafe-statics.
  static X509_STORE* store = NewRootCertStore();
  return store;
}",1,1,crypto\crypto_context.cc,node.crypto.GetOrCreateRootCertStore,,false,56,60,GetOrCreateRootCertStore,,,7,X509_STORE node.crypto.GetOrCreateRootCertStore ()
29825,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"BIOPointer LoadBIO(Environment* env, Local<Value> v) {
  if (v->IsString() || v->IsArrayBufferView()) {
    BIOPointer bio(BIO_new(BIO_s_secmem()));
    if (!bio) return nullptr;
    ByteSource bsrc = ByteSource::FromStringOrBuffer(env, v);
    if (bsrc.size() > INT_MAX) return nullptr;
    int written = BIO_write(bio.get(), bsrc.data<char>(), bsrc.size());
    if (written < 0) return nullptr;
    if (static_cast<size_t>(written) != bsrc.size()) return nullptr;
    return bio;
  }
  return nullptr;
}",1,1,crypto\crypto_context.cc,node.crypto.LoadBIO,,false,64,76,LoadBIO,,,8,"BIOPointer node.crypto.LoadBIO (Environment*,Local<Value>)"
29840,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,BIOPointer bio(BIO_new(BIO_s_secmem()));,16,43,crypto\crypto_context.cc,node.crypto.LoadBIO.bio,,false,66,66,bio,,,1,BIOPointer node.crypto.LoadBIO.bio (BIO_new)
29913,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"int SSL_CTX_use_certificate_chain(SSL_CTX* ctx,
                                  BIOPointer&& in,
                                  X509Pointer* cert,
                                  X509Pointer* issuer) {
  // Just to ensure that `ERR_peek_last_error` below will return only errors
  // that we are interested in
  ERR_clear_error();

  X509Pointer x(
      PEM_read_bio_X509_AUX(in.get(), nullptr, NoPasswordCallback, nullptr));

  if (!x)
    return 0;

  unsigned long err = 0;  // NOLINT(runtime/int)

  StackOfX509 extra_certs(sk_X509_new_null());
  if (!extra_certs)
    return 0;

  while (X509Pointer extra {PEM_read_bio_X509(in.get(),
                                    nullptr,
                                    NoPasswordCallback,
                                    nullptr)}) {
    if (sk_X509_push(extra_certs.get(), extra.get())) {
      extra.release();
      continue;
    }

    return 0;
  }

  // When the while loop ends, it's usually just EOF.
  err = ERR_peek_last_er...",1,1,crypto\crypto_context.cc,node.crypto.anonymous_namespace_1.SSL_CTX_use_certificate_chain,,false,148,195,SSL_CTX_use_certificate_chain,,,2,"int node.crypto.anonymous_namespace_1.SSL_CTX_use_certificate_chain (SSL_CTX*,BIOPointer,X509Pointer*,X509Pointer*)"
30004,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"X509_STORE* NewRootCertStore() {
  static std::vector<X509*> root_certs_vector;
  static Mutex root_certs_vector_mutex;
  Mutex::ScopedLock lock(root_certs_vector_mutex);

  if (root_certs_vector.empty() &&
      per_process::cli_options->ssl_openssl_cert_store == false) {
    for (size_t i = 0; i < arraysize(root_certs); i++) {
      X509* x509 =
          PEM_read_bio_X509(NodeBIO::NewFixed(root_certs[i],
                                              strlen(root_certs[i])).get(),
                            nullptr,   // no re-use of X509 structure
                            NoPasswordCallback,
                            nullptr);  // no callback data

      // Parse errors from the built-in roots are fatal.
      CHECK_NOT_NULL(x509);

      root_certs_vector.push_back(x509);
    }
  }

  X509_STORE* store = X509_STORE_new();
  if (*system_cert_path != '\0') {
    ERR_set_mark();
    X509_STORE_load_locations(store, system_cert_path, nullptr);
    ERR_pop_to_mark();
  }

  Mute...",1,1,crypto\crypto_context.cc,node.crypto.NewRootCertStore,,false,199,239,NewRootCertStore,,,10,X509_STORE node.crypto.NewRootCertStore ()
30113,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"void GetRootCertificates(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Local<Value> result[arraysize(root_certs)];

  for (size_t i = 0; i < arraysize(root_certs); i++) {
    if (!String::NewFromOneByte(
            env->isolate(),
            reinterpret_cast<const uint8_t*>(root_certs[i]))
            .ToLocal(&result[i])) {
      return;
    }
  }

  args.GetReturnValue().Set(
      Array::New(env->isolate(), result, arraysize(root_certs)));
}",1,1,crypto\crypto_context.cc,node.crypto.GetRootCertificates,,false,241,256,GetRootCertificates,,,11,void node.crypto.GetRootCertificates (FunctionCallbackInfo<Value>)
30189,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"bool SecureContext::HasInstance(Environment* env, const Local<Value>& value) {
  return GetConstructorTemplate(env)->HasInstance(value);
}",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.HasInstance,,false,258,260,HasInstance,,,12,"bool node.crypto.SecureContext.HasInstance (Environment*,Local<Value>)"
30202,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"Local<FunctionTemplate> SecureContext::GetConstructorTemplate(
    Environment* env) {
  Local<FunctionTemplate> tmpl = env->secure_context_constructor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, New);
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        SecureContext::kInternalFieldCount);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), ""SecureContext""));

    SetProtoMethod(isolate, tmpl, ""init"", Init);
    SetProtoMethod(isolate, tmpl, ""setKey"", SetKey);
    SetProtoMethod(isolate, tmpl, ""setCert"", SetCert);
    SetProtoMethod(isolate, tmpl, ""addCACert"", AddCACert);
    SetProtoMethod(isolate, tmpl, ""addCRL"", AddCRL);
    SetProtoMethod(isolate, tmpl, ""addRootCerts"", AddRootCerts);
    SetProtoMethod(isolate, tmpl, ""setCipherSuites"", SetCipherSuites);
    SetProtoMethod(isolate, tmpl, ""setCiphers"", SetCiphers);
    SetProtoMethod(isolate, tmpl, ""setSigalgs"", SetSigalgs);
    SetProtoMethod...",1,4,crypto\crypto_context.cc,node.crypto.SecureContext.GetConstructorTemplate,,false,262,329,GetConstructorTemplate,,,13,Local<FunctionTemplate> node.crypto.SecureContext.GetConstructorTemplate (Environment*)
30518,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"void SecureContext::Initialize(Environment* env, Local<Object> target) {
  Local<Context> context = env->context();
  SetConstructorFunction(context,
                         target,
                         ""SecureContext"",
                         GetConstructorTemplate(env),
                         SetConstructorFunctionFlag::NONE);

  SetMethodNoSideEffect(
      context, target, ""getRootCertificates"", GetRootCertificates);
  // Exposed for testing purposes only.
  SetMethodNoSideEffect(context,
                        target,
                        ""isExtraRootCertsFileLoaded"",
                        IsExtraRootCertsFileLoaded);
}",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.Initialize,,false,331,346,Initialize,,,14,"void node.crypto.SecureContext.Initialize (Environment*,Local<Object>)"
30553,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"void SecureContext::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(New);
  registry->Register(Init);
  registry->Register(SetKey);
  registry->Register(SetCert);
  registry->Register(AddCACert);
  registry->Register(AddCRL);
  registry->Register(AddRootCerts);
  registry->Register(SetCipherSuites);
  registry->Register(SetCiphers);
  registry->Register(SetSigalgs);
  registry->Register(SetECDHCurve);
  registry->Register(SetDHParam);
  registry->Register(SetMaxProto);
  registry->Register(SetMinProto);
  registry->Register(GetMaxProto);
  registry->Register(GetMinProto);
  registry->Register(SetOptions);
  registry->Register(SetSessionIdContext);
  registry->Register(SetSessionTimeout);
  registry->Register(Close);
  registry->Register(LoadPKCS12);
  registry->Register(SetTicketKeys);
  registry->Register(EnableTicketKeyCallback);
  registry->Register(GetTicketKeys);
  registry->Register(GetCertificate<true>);
  registry->Register(GetCert...",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.RegisterExternalReferences,,false,348,386,RegisterExternalReferences,,,15,void node.crypto.SecureContext.RegisterExternalReferences (ExternalReferenceRegistry*)
30713,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"SecureContext* SecureContext::Create(Environment* env) {
  Local<Object> obj;
  if (!GetConstructorTemplate(env)
          ->InstanceTemplate()
          ->NewInstance(env->context()).ToLocal(&obj)) {
    return nullptr;
  }

  return new SecureContext(env, obj);
}",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.Create,,false,388,397,Create,,,16,SecureContext node.crypto.SecureContext.Create (Environment*)
30750,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"SecureContext::SecureContext(Environment* env, Local<Object> wrap)
    : BaseObject(env, wrap) {
  MakeWeak();
  env->isolate()->AdjustAmountOfExternalAllocatedMemory(kExternalSize);
}",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.SecureContext,,false,399,403,SecureContext,,,17,"ANY node.crypto.SecureContext.SecureContext (Environment*,Local<Object>)"
30765,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"inline void SecureContext::Reset() {
  if (ctx_ != nullptr) {
    env()->isolate()->AdjustAmountOfExternalAllocatedMemory(-kExternalSize);
  }
  ctx_.reset();
  cert_.reset();
  issuer_.reset();
}",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.Reset,,false,405,412,Reset,,,18,void node.crypto.SecureContext.Reset ()
30795,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"SecureContext::~SecureContext() {
  Reset();
}",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.~SecureContext,,false,414,416,~SecureContext,,,19,ANY node.crypto.SecureContext.~SecureContext ()
30800,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"void SecureContext::New(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  new SecureContext(env, args.This());
}",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.New,,false,418,421,New,,,20,void node.crypto.SecureContext.New (FunctionCallbackInfo<Value>)
30820,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"void SecureContext::Init(const FunctionCallbackInfo<Value>& args) {
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  Environment* env = sc->env();

  CHECK_EQ(args.Length(), 3);
  CHECK(args[1]->IsInt32());
  CHECK(args[2]->IsInt32());

  int min_version = args[1].As<Int32>()->Value();
  int max_version = args[2].As<Int32>()->Value();
  const SSL_METHOD* method = TLS_method();

  if (max_version == 0)
    max_version = kMaxSupportedVersion;

  if (args[0]->IsString()) {
    Utf8Value sslmethod(env->isolate(), args[0]);

    // Note that SSLv2 and SSLv3 are disallowed but SSLv23_method and friends
    // are still accepted.  They are OpenSSL's way of saying that all known
    // protocols below TLS 1.3 are supported unless explicitly disabled (which
    // we do below for SSLv2 and SSLv3.)
    if (sslmethod == ""SSLv2_method"" ||
        sslmethod == ""SSLv2_server_method"" ||
        sslmethod == ""SSLv2_client_method"") {
      THROW_ERR_TLS_INVALID_PROTOCOL_METHOD(e...",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.Init,,false,423,556,Init,,,21,void node.crypto.SecureContext.Init (FunctionCallbackInfo<Value>)
31303,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"SSLPointer SecureContext::CreateSSL() {
  return SSLPointer(SSL_new(ctx_.get()));
}",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.CreateSSL,,false,558,560,CreateSSL,,,22,SSLPointer node.crypto.SecureContext.CreateSSL ()
31314,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"void SecureContext::SetNewSessionCallback(NewSessionCb cb) {
  SSL_CTX_sess_set_new_cb(ctx_.get(), cb);
}",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.SetNewSessionCallback,,false,562,564,SetNewSessionCallback,,,23,void node.crypto.SecureContext.SetNewSessionCallback (NewSessionCb)
31325,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"void SecureContext::SetGetSessionCallback(GetSessionCb cb) {
  SSL_CTX_sess_set_get_cb(ctx_.get(), cb);
}",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.SetGetSessionCallback,,false,566,568,SetGetSessionCallback,,,24,void node.crypto.SecureContext.SetGetSessionCallback (GetSessionCb)
31336,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"void SecureContext::SetSelectSNIContextCallback(SelectSNIContextCb cb) {
  SSL_CTX_set_tlsext_servername_callback(ctx_.get(), cb);
}",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.SetSelectSNIContextCallback,,false,570,572,SetSelectSNIContextCallback,,,25,void node.crypto.SecureContext.SetSelectSNIContextCallback (SelectSNIContextCb)
31347,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"void SecureContext::SetKeylogCallback(KeylogCb cb) {
  SSL_CTX_set_keylog_callback(ctx_.get(), cb);
}",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.SetKeylogCallback,,false,574,576,SetKeylogCallback,,,26,void node.crypto.SecureContext.SetKeylogCallback (KeylogCb)
31358,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"Maybe<bool> SecureContext::UseKey(Environment* env,
                                  std::shared_ptr<KeyObjectData> key) {
  if (key->GetKeyType() != KeyType::kKeyTypePrivate) {
    THROW_ERR_CRYPTO_INVALID_KEYTYPE(env);
    return Nothing<bool>();
  }

  ClearErrorOnReturn clear_error_on_return;
  if (!SSL_CTX_use_PrivateKey(ctx_.get(), key->GetAsymmetricKey().get())) {
    ThrowCryptoError(env, ERR_get_error(), ""SSL_CTX_use_PrivateKey"");
    return Nothing<bool>();
  }

  return Just(true);
}",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.UseKey,,false,578,592,UseKey,,,27,"Maybe<bool> node.crypto.SecureContext.UseKey (Environment*,ANY)"
31403,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"void SecureContext::SetKey(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_GE(args.Length(), 1);  // Private key argument is mandatory

  BIOPointer bio(LoadBIO(env, args[0]));
  if (!bio)
    return;

  ByteSource passphrase;
  if (args[1]->IsString())
    passphrase = ByteSource::FromString(env, args[1].As<String>());
  // This redirection is necessary because the PasswordCallback expects a
  // pointer to a pointer to the passphrase ByteSource to allow passing in
  // const ByteSources.
  const ByteSource* pass_ptr = &passphrase;

  EVPKeyPointer key(
      PEM_read_bio_PrivateKey(bio.get(),
                              nullptr,
                              PasswordCallback,
                              &pass_ptr));

  if (!key)
    return ThrowCryptoError(env, ERR_get_error(), ""PEM_read_bio_PrivateKey"");

  if (!SSL_CTX_use_PrivateKey(sc->ctx_.get(), ke...",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.SetKey,,false,594,625,SetKey,,,28,void node.crypto.SecureContext.SetKey (FunctionCallbackInfo<Value>)
31508,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"void SecureContext::SetSigalgs(const FunctionCallbackInfo<Value>& args) {
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  Environment* env = sc->env();
  ClearErrorOnReturn clear_error_on_return;

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());

  const Utf8Value sigalgs(env->isolate(), args[0]);

  if (!SSL_CTX_set1_sigalgs_list(sc->ctx_.get(), *sigalgs))
    return ThrowCryptoError(env, ERR_get_error());
}",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.SetSigalgs,,false,627,640,SetSigalgs,,,29,void node.crypto.SecureContext.SetSigalgs (FunctionCallbackInfo<Value>)
31567,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"void SecureContext::SetEngineKey(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_EQ(args.Length(), 2);

  if (UNLIKELY(env->permission()->enabled())) {
    return THROW_ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED(
        env,
        ""Programmatic selection of OpenSSL engines is unsupported while the ""
        ""experimental permission model is enabled"");
  }

  CryptoErrorStore errors;
  Utf8Value engine_id(env->isolate(), args[1]);
  EnginePointer engine = LoadEngineById(*engine_id, &errors);
  if (!engine) {
    Local<Value> exception;
    if (errors.ToException(env).ToLocal(&exception))
      env->isolate()->ThrowException(exception);
    return;
  }

  if (!ENGINE_init(engine.get())) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(
        env, ""Failure to initialize engine"");
  }

  engine.finish_on_exit = true;

  Utf8Value key_name(env->isolate(), args[0]);
...",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.SetEngineKey,,false,643,686,SetEngineKey,,,30,void node.crypto.SecureContext.SetEngineKey (FunctionCallbackInfo<Value>)
31730,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"Maybe<bool> SecureContext::AddCert(Environment* env, BIOPointer&& bio) {
  ClearErrorOnReturn clear_error_on_return;
  if (!bio) return Just(false);
  cert_.reset();
  issuer_.reset();

  // The SSL_CTX_use_certificate_chain call here is not from openssl, this is
  // the method implemented elsewhere in this file. The naming is a bit
  // confusing, unfortunately.
  if (SSL_CTX_use_certificate_chain(
          ctx_.get(), std::move(bio), &cert_, &issuer_) == 0) {
    ThrowCryptoError(env, ERR_get_error(), ""SSL_CTX_use_certificate_chain"");
    return Nothing<bool>();
  }
  return Just(true);
}",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.AddCert,,false,689,704,AddCert,,,31,"Maybe<bool> node.crypto.SecureContext.AddCert (Environment*,BIOPointer)"
31779,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"void SecureContext::SetCert(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_GE(args.Length(), 1);  // Certificate argument is mandatory

  BIOPointer bio(LoadBIO(env, args[0]));
  USE(sc->AddCert(env, std::move(bio)));
}",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.SetCert,,false,706,716,SetCert,,,32,void node.crypto.SecureContext.SetCert (FunctionCallbackInfo<Value>)
31824,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"void SecureContext::SetCACert(const BIOPointer& bio) {
  ClearErrorOnReturn clear_error_on_return;
  if (!bio) return;
  X509_STORE* cert_store = SSL_CTX_get_cert_store(ctx_.get());
  while (X509Pointer x509 = X509Pointer(PEM_read_bio_X509_AUX(
             bio.get(), nullptr, NoPasswordCallback, nullptr))) {
    if (cert_store == GetOrCreateRootCertStore()) {
      cert_store = NewRootCertStore();
      SSL_CTX_set_cert_store(ctx_.get(), cert_store);
    }
    CHECK_EQ(1, X509_STORE_add_cert(cert_store, x509.get()));
    CHECK_EQ(1, SSL_CTX_add_client_CA(ctx_.get(), x509.get()));
  }
}",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.SetCACert,,false,718,731,SetCACert,,,33,void node.crypto.SecureContext.SetCACert (BIOPointer)
31878,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"void SecureContext::AddCACert(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_GE(args.Length(), 1);  // CA certificate argument is mandatory

  BIOPointer bio(LoadBIO(env, args[0]));
  sc->SetCACert(bio);
}",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.AddCACert,,false,733,743,AddCACert,,,34,void node.crypto.SecureContext.AddCACert (FunctionCallbackInfo<Value>)
31917,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"Maybe<bool> SecureContext::SetCRL(Environment* env, const BIOPointer& bio) {
  ClearErrorOnReturn clear_error_on_return;
  if (!bio) return Just(false);

  DeleteFnPtr<X509_CRL, X509_CRL_free> crl(
      PEM_read_bio_X509_CRL(bio.get(), nullptr, NoPasswordCallback, nullptr));

  if (!crl) {
    THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""Failed to parse CRL"");
    return Nothing<bool>();
  }

  X509_STORE* cert_store = SSL_CTX_get_cert_store(ctx_.get());
  if (cert_store == GetOrCreateRootCertStore()) {
    cert_store = NewRootCertStore();
    SSL_CTX_set_cert_store(ctx_.get(), cert_store);
  }

  CHECK_EQ(1, X509_STORE_add_crl(cert_store, crl.get()));
  CHECK_EQ(1,
           X509_STORE_set_flags(
               cert_store, X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL));
  return Just(true);
}",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.SetCRL,,false,745,768,SetCRL,,,35,"Maybe<bool> node.crypto.SecureContext.SetCRL (Environment*,BIOPointer)"
31995,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"void SecureContext::AddCRL(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_GE(args.Length(), 1);  // CRL argument is mandatory

  BIOPointer bio(LoadBIO(env, args[0]));
  USE(sc->SetCRL(env, bio));
}",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.AddCRL,,false,770,780,AddCRL,,,36,void node.crypto.SecureContext.AddCRL (FunctionCallbackInfo<Value>)
32036,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"void SecureContext::SetRootCerts() {
  ClearErrorOnReturn clear_error_on_return;
  auto store = GetOrCreateRootCertStore();

  // Increment reference count so global store is not deleted along with CTX.
  X509_STORE_up_ref(store);
  SSL_CTX_set_cert_store(ctx_.get(), store);
}",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.SetRootCerts,,false,782,789,SetRootCerts,,,37,void node.crypto.SecureContext.SetRootCerts ()
32053,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"void SecureContext::AddRootCerts(const FunctionCallbackInfo<Value>& args) {
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  sc->SetRootCerts();
}",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.AddRootCerts,,false,791,795,AddRootCerts,,,38,void node.crypto.SecureContext.AddRootCerts (FunctionCallbackInfo<Value>)
32070,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"void SecureContext::SetCipherSuites(const FunctionCallbackInfo<Value>& args) {
  // BoringSSL doesn't allow API config of TLS1.3 cipher suites.
#ifndef OPENSSL_IS_BORINGSSL
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  Environment* env = sc->env();
  ClearErrorOnReturn clear_error_on_return;

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());

  const Utf8Value ciphers(env->isolate(), args[0]);
  if (!SSL_CTX_set_ciphersuites(sc->ctx_.get(), *ciphers))
    return ThrowCryptoError(env, ERR_get_error(), ""Failed to set ciphers"");
#endif
}",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.SetCipherSuites,,false,797,812,SetCipherSuites,,,39,void node.crypto.SecureContext.SetCipherSuites (FunctionCallbackInfo<Value>)
32130,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"void SecureContext::SetCiphers(const FunctionCallbackInfo<Value>& args) {
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  Environment* env = sc->env();
  ClearErrorOnReturn clear_error_on_return;

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());

  Utf8Value ciphers(env->isolate(), args[0]);
  if (!SSL_CTX_set_cipher_list(sc->ctx_.get(), *ciphers)) {
    unsigned long err = ERR_get_error();  // NOLINT(runtime/int)

    if (strlen(*ciphers) == 0 && ERR_GET_REASON(err) == SSL_R_NO_CIPHER_MATCH) {
      // TLS1.2 ciphers were deliberately cleared, so don't consider
      // SSL_R_NO_CIPHER_MATCH to be an error (this is how _set_cipher_suites()
      // works). If the user actually sets a value (like ""no-such-cipher""), then
      // that's actually an error.
      return;
    }
    return ThrowCryptoError(env, err, ""Failed to set ciphers"");
  }
}",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.SetCiphers,,false,814,836,SetCiphers,,,40,void node.crypto.SecureContext.SetCiphers (FunctionCallbackInfo<Value>)
32207,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"void SecureContext::SetECDHCurve(const FunctionCallbackInfo<Value>& args) {
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  Environment* env = sc->env();

  CHECK_GE(args.Length(), 1);  // ECDH curve name argument is mandatory
  CHECK(args[0]->IsString());

  Utf8Value curve(env->isolate(), args[0]);

  if (curve != ""auto"" && !SSL_CTX_set1_curves_list(sc->ctx_.get(), *curve)) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""Failed to set ECDH curve"");
  }
}",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.SetECDHCurve,,false,838,851,SetECDHCurve,,,41,void node.crypto.SecureContext.SetECDHCurve (FunctionCallbackInfo<Value>)
32269,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"void SecureContext::SetDHParam(const FunctionCallbackInfo<Value>& args) {
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.This());
  Environment* env = sc->env();
  ClearErrorOnReturn clear_error_on_return;

  CHECK_GE(args.Length(), 1);  // DH argument is mandatory

  // If the user specified ""auto"" for dhparams, the JavaScript layer will pass
  // true to this function instead of the original string. Any other string
  // value will be interpreted as custom DH parameters below.
  if (args[0]->IsTrue()) {
    CHECK(SSL_CTX_set_dh_auto(sc->ctx_.get(), true));
    return;
  }

  DHPointer dh;
  {
    BIOPointer bio(LoadBIO(env, args[0]));
    if (!bio)
      return;

    dh.reset(PEM_read_bio_DHparams(bio.get(), nullptr, nullptr, nullptr));
  }

  // Invalid dhparam is silently discarded and DHE is no longer used.
  // TODO(tniessen): don't silently discard invalid dhparam.
  if (!dh)
    return;

  const BIGNUM* p;
  DH_get0_pqg(dh.get(), &p, nullptr, nullptr);
  const int ...",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.SetDHParam,,false,853,898,SetDHParam,,,42,void node.crypto.SecureContext.SetDHParam (FunctionCallbackInfo<Value>)
32407,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"void SecureContext::SetMinProto(const FunctionCallbackInfo<Value>& args) {
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsInt32());

  int version = args[0].As<Int32>()->Value();

  CHECK(SSL_CTX_set_min_proto_version(sc->ctx_.get(), version));
}",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.SetMinProto,,false,900,910,SetMinProto,,,43,void node.crypto.SecureContext.SetMinProto (FunctionCallbackInfo<Value>)
32454,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"void SecureContext::SetMaxProto(const FunctionCallbackInfo<Value>& args) {
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsInt32());

  int version = args[0].As<Int32>()->Value();

  CHECK(SSL_CTX_set_max_proto_version(sc->ctx_.get(), version));
}",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.SetMaxProto,,false,912,922,SetMaxProto,,,44,void node.crypto.SecureContext.SetMaxProto (FunctionCallbackInfo<Value>)
32501,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"void SecureContext::GetMinProto(const FunctionCallbackInfo<Value>& args) {
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_EQ(args.Length(), 0);

  long version =  // NOLINT(runtime/int)
    SSL_CTX_get_min_proto_version(sc->ctx_.get());
  args.GetReturnValue().Set(static_cast<uint32_t>(version));
}",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.GetMinProto,,false,924,933,GetMinProto,,,45,void node.crypto.SecureContext.GetMinProto (FunctionCallbackInfo<Value>)
32540,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"void SecureContext::GetMaxProto(const FunctionCallbackInfo<Value>& args) {
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_EQ(args.Length(), 0);

  long version =  // NOLINT(runtime/int)
    SSL_CTX_get_max_proto_version(sc->ctx_.get());
  args.GetReturnValue().Set(static_cast<uint32_t>(version));
}",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.GetMaxProto,,false,935,944,GetMaxProto,,,46,void node.crypto.SecureContext.GetMaxProto (FunctionCallbackInfo<Value>)
32579,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"void SecureContext::SetOptions(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsNumber());

  int64_t val = args[0]->IntegerValue(env->context()).FromMaybe(0);

  SSL_CTX_set_options(sc->ctx_.get(),
                      static_cast<long>(val));  // NOLINT(runtime/int)
}",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.SetOptions,,false,946,958,SetOptions,,,47,void node.crypto.SecureContext.SetOptions (FunctionCallbackInfo<Value>)
32640,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"void SecureContext::SetSessionIdContext(
    const FunctionCallbackInfo<Value>& args) {
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  Environment* env = sc->env();

  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());

  const Utf8Value sessionIdContext(env->isolate(), args[0]);
  const unsigned char* sid_ctx =
      reinterpret_cast<const unsigned char*>(*sessionIdContext);
  unsigned int sid_ctx_len = sessionIdContext.length();

  if (SSL_CTX_set_session_id_context(sc->ctx_.get(), sid_ctx, sid_ctx_len) == 1)
    return;

  BUF_MEM* mem;
  Local<String> message;

  BIOPointer bio(BIO_new(BIO_s_mem()));
  if (!bio) {
    message = FIXED_ONE_BYTE_STRING(env->isolate(),
                                    ""SSL_CTX_set_session_id_context error"");
  } else {
    ERR_print_errors(bio.get());
    BIO_get_mem_ptr(bio.get(), &mem);
    message = OneByteString(env->isolate(), mem->data, mem->length);
  }

  env->isolate()->ThrowException(Exception::TypeError(me...",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.SetSessionIdContext,,false,960,991,SetSessionIdContext,,,48,void node.crypto.SecureContext.SetSessionIdContext (FunctionCallbackInfo<Value>)
32714,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,BIOPointer bio(BIO_new(BIO_s_mem()));,14,38,crypto\crypto_context.cc,node.crypto.SecureContext.SetSessionIdContext.bio,,false,980,980,bio,,,16,BIOPointer node.crypto.SecureContext.SetSessionIdContext.bio (BIO_new)
32772,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"void SecureContext::SetSessionTimeout(const FunctionCallbackInfo<Value>& args) {
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsInt32());

  int32_t sessionTimeout = args[0].As<Int32>()->Value();
  SSL_CTX_set_timeout(sc->ctx_.get(), sessionTimeout);
}",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.SetSessionTimeout,,false,993,1002,SetSessionTimeout,,,49,void node.crypto.SecureContext.SetSessionTimeout (FunctionCallbackInfo<Value>)
32818,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"void SecureContext::Close(const FunctionCallbackInfo<Value>& args) {
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  sc->Reset();
}",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.Close,,false,1004,1008,Close,,,50,void node.crypto.SecureContext.Close (FunctionCallbackInfo<Value>)
32835,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"void SecureContext::LoadPKCS12(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  std::vector<char> pass;
  bool ret = false;

  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  ClearErrorOnReturn clear_error_on_return;

  if (args.Length() < 1) {
    return THROW_ERR_MISSING_ARGS(env, ""PFX certificate argument is mandatory"");
  }

  BIOPointer in(LoadBIO(env, args[0]));
  if (!in) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(
        env, ""Unable to load PFX certificate"");
  }

  if (args.Length() >= 2) {
    THROW_AND_RETURN_IF_NOT_BUFFER(env, args[1], ""Pass phrase"");
    Local<ArrayBufferView> abv = args[1].As<ArrayBufferView>();
    size_t passlen = abv->ByteLength();
    pass.resize(passlen + 1);
    abv->CopyContents(pass.data(), passlen);
    pass[passlen] = '\0';
  }

  // Free previous certs
  sc->issuer_.reset();
  sc->cert_.reset();

  X509_STORE* cert_store = SSL_CTX_get_cert_store(sc->ctx_.get());

  De...",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.LoadPKCS12,,false,1011,1091,LoadPKCS12,,,51,void node.crypto.SecureContext.LoadPKCS12 (FunctionCallbackInfo<Value>)
33165,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"void SecureContext::SetClientCertEngine(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());

  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  MarkPopErrorOnReturn mark_pop_error_on_return;

  // SSL_CTX_set_client_cert_engine does not itself support multiple
  // calls by cleaning up before overwriting the client_cert_engine
  // internal context variable.
  // Instead of trying to fix up this problem we in turn also do not
  // support multiple calls to SetClientCertEngine.
  CHECK(!sc->client_cert_engine_provided_);

  if (UNLIKELY(env->permission()->enabled())) {
    return THROW_ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED(
        env,
        ""Programmatic selection of OpenSSL engines is unsupported while the ""
        ""experimental permission model is enabled"");
  }

  CryptoErrorStore errors;
  const Utf8Value engine_id(env->isolate(), args[0]);
  Engin...",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.SetClientCertEngine,,false,1094,1133,SetClientCertEngine,,,52,void node.crypto.SecureContext.SetClientCertEngine (FunctionCallbackInfo<Value>)
33290,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"void SecureContext::GetTicketKeys(const FunctionCallbackInfo<Value>& args) {
  SecureContext* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  Local<Object> buff;
  if (!Buffer::New(wrap->env(), 48).ToLocal(&buff))
    return;

  memcpy(Buffer::Data(buff), wrap->ticket_key_name_, 16);
  memcpy(Buffer::Data(buff) + 16, wrap->ticket_key_hmac_, 16);
  memcpy(Buffer::Data(buff) + 32, wrap->ticket_key_aes_, 16);

  args.GetReturnValue().Set(buff);
}",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.GetTicketKeys,,false,1136,1149,GetTicketKeys,,,53,void node.crypto.SecureContext.GetTicketKeys (FunctionCallbackInfo<Value>)
33368,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"void SecureContext::SetTicketKeys(const FunctionCallbackInfo<Value>& args) {
  SecureContext* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK_GE(args.Length(), 1);  // Ticket keys argument is mandatory
  CHECK(args[0]->IsArrayBufferView());
  ArrayBufferViewContents<char> buf(args[0].As<ArrayBufferView>());

  CHECK_EQ(buf.length(), 48);

  memcpy(wrap->ticket_key_name_, buf.data(), 16);
  memcpy(wrap->ticket_key_hmac_, buf.data() + 16, 16);
  memcpy(wrap->ticket_key_aes_, buf.data() + 32, 16);

  args.GetReturnValue().Set(true);
}",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.SetTicketKeys,,false,1151,1166,SetTicketKeys,,,54,void node.crypto.SecureContext.SetTicketKeys (FunctionCallbackInfo<Value>)
33447,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"void SecureContext::EnableTicketKeyCallback(
    const FunctionCallbackInfo<Value>& args) {
  SecureContext* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  SSL_CTX_set_tlsext_ticket_key_cb(wrap->ctx_.get(), TicketKeyCallback);
}",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.EnableTicketKeyCallback,,false,1170,1176,EnableTicketKeyCallback,,,55,void node.crypto.SecureContext.EnableTicketKeyCallback (FunctionCallbackInfo<Value>)
33468,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"int SecureContext::TicketKeyCallback(SSL* ssl,
                                     unsigned char* name,
                                     unsigned char* iv,
                                     EVP_CIPHER_CTX* ectx,
                                     HMAC_CTX* hctx,
                                     int enc) {
  static const int kTicketPartSize = 16;

  SecureContext* sc = static_cast<SecureContext*>(
      SSL_CTX_get_app_data(SSL_get_SSL_CTX(ssl)));

  Environment* env = sc->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Value> argv[3];

  if (!Buffer::Copy(
          env,
          reinterpret_cast<char*>(name),
          kTicketPartSize).ToLocal(&argv[0]) ||
      !Buffer::Copy(
          env,
          reinterpret_cast<char*>(iv),
          kTicketPartSize).ToLocal(&argv[1])) {
    return -1;
  }

  argv[2] = Boolean::New(env->isolate(), enc != 0);

  Local<Value> ret;
  if (!node::MakeCallback(
          env...",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.TicketKeyCallback,,false,1178,1277,TicketKeyCallback,,,56,"int node.crypto.SecureContext.TicketKeyCallback (SSL*,unsigned char*,unsigned char*,EVP_CIPHER_CTX*,HMAC_CTX*,int)"
33856,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"int SecureContext::TicketCompatibilityCallback(SSL* ssl,
                                               unsigned char* name,
                                               unsigned char* iv,
                                               EVP_CIPHER_CTX* ectx,
                                               HMAC_CTX* hctx,
                                               int enc) {
  SecureContext* sc = static_cast<SecureContext*>(
      SSL_CTX_get_app_data(SSL_get_SSL_CTX(ssl)));

  if (enc) {
    memcpy(name, sc->ticket_key_name_, sizeof(sc->ticket_key_name_));
    if (CSPRNG(iv, 16).is_err() ||
        EVP_EncryptInit_ex(
            ectx, EVP_aes_128_cbc(), nullptr, sc->ticket_key_aes_, iv) <= 0 ||
        HMAC_Init_ex(hctx,
                     sc->ticket_key_hmac_,
                     sizeof(sc->ticket_key_hmac_),
                     EVP_sha256(),
                     nullptr) <= 0) {
      return -1;
    }
    return 1;
  }

  if (memcmp(name, sc->ticket_key_name_, sizeof(sc->...",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.TicketCompatibilityCallback,,false,1279,1315,TicketCompatibilityCallback,,,57,"int node.crypto.SecureContext.TicketCompatibilityCallback (SSL*,unsigned char*,unsigned char*,EVP_CIPHER_CTX*,HMAC_CTX*,int)"
33970,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"void SecureContext::CtxGetter(const FunctionCallbackInfo<Value>& info) {
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, info.This());
  Local<External> ext = External::New(info.GetIsolate(), sc->ctx_.get());
  info.GetReturnValue().Set(ext);
}",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.CtxGetter,,false,1317,1322,CtxGetter,,,58,void node.crypto.SecureContext.CtxGetter (FunctionCallbackInfo<Value>)
34011,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"void SecureContext::GetCertificate(const FunctionCallbackInfo<Value>& args) {
  SecureContext* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  Environment* env = wrap->env();
  X509* cert;

  if (primary)
    cert = wrap->cert_.get();
  else
    cert = wrap->issuer_.get();
  if (cert == nullptr)
    return args.GetReturnValue().SetNull();

  int size = i2d_X509(cert, nullptr);
  Local<Object> buff;
  if (!Buffer::New(env, size).ToLocal(&buff))
    return;
  unsigned char* serialized = reinterpret_cast<unsigned char*>(
      Buffer::Data(buff));
  i2d_X509(cert, &serialized);

  args.GetReturnValue().Set(buff);
}",1,1,crypto\crypto_context.cc,node.crypto.SecureContext.GetCertificate,,false,1325,1347,GetCertificate,,,59,void node.crypto.SecureContext.GetCertificate<bool> (FunctionCallbackInfo<Value>)
34115,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"unsigned long AddCertsFromFile(  // NOLINT(runtime/int)
    X509_STORE* store,
    const char* file) {
  ERR_clear_error();
  MarkPopErrorOnReturn mark_pop_error_on_return;

  BIOPointer bio(BIO_new_file(file, ""r""));
  if (!bio)
    return ERR_get_error();

  while (X509Pointer x509 = X509Pointer(PEM_read_bio_X509(
             bio.get(), nullptr, NoPasswordCallback, nullptr))) {
    X509_STORE_add_cert(store, x509.get());
  }

  unsigned long err = ERR_peek_error();  // NOLINT(runtime/int)
  // Ignore error if its EOF/no start line found.
  if (ERR_GET_LIB(err) == ERR_LIB_PEM &&
      ERR_GET_REASON(err) == PEM_R_NO_START_LINE) {
    return 0;
  }

  return err;
}",1,1,crypto\crypto_context.cc,node.crypto.anonymous_namespace_3.AddCertsFromFile,,false,1350,1373,AddCertsFromFile,,,1,"unsigned long node.crypto.anonymous_namespace_3.AddCertsFromFile (X509_STORE*,char*)"
34161,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"void UseExtraCaCerts(const std::string& file) {
  if (file.empty()) return;
  ClearErrorOnReturn clear_error_on_return;
  X509_STORE* store = GetOrCreateRootCertStore();
  if (auto err = AddCertsFromFile(store, file.c_str())) {
    char buf[256];
    ERR_error_string_n(err, buf, sizeof(buf));
    fprintf(stderr,
            ""Warning: Ignoring extra certs from `%s`, load failed: %s\n"",
            file.c_str(),
            buf);
  } else {
    extra_root_certs_loaded = true;
  }
}",1,1,crypto\crypto_context.cc,node.crypto.UseExtraCaCerts,,false,1377,1391,UseExtraCaCerts,,,61,void node.crypto.UseExtraCaCerts (ANY)
34209,METHOD,crypto\crypto_context.cc:<global>,TYPE_DECL,"void IsExtraRootCertsFileLoaded(
    const FunctionCallbackInfo<Value>& args) {
  return args.GetReturnValue().Set(extra_root_certs_loaded);
}",1,1,crypto\crypto_context.cc,node.crypto.IsExtraRootCertsFileLoaded,,false,1394,1397,IsExtraRootCertsFileLoaded,,,62,void node.crypto.IsExtraRootCertsFileLoaded (FunctionCallbackInfo<Value>)
34238,METHOD,crypto\crypto_context.hpp:<global>,TYPE_DECL,<global>,1,39,crypto\crypto_context.hpp,crypto\crypto_context.hpp:<global>,,false,1,160,<global>,,,1,
34241,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"[&](Local<String> name, FunctionCallback callback) {
    Local<FunctionTemplate> t = NewFunctionTemplate(isolate, callback);

    const PropertyAttribute attributes =
        static_cast<PropertyAttribute>(ReadOnly | DontDelete);

    t->InstanceTemplate()->SetInternalFieldCount(
        DiffieHellman::kInternalFieldCount);

    SetProtoMethod(isolate, t, ""generateKeys"", GenerateKeys);
    SetProtoMethod(isolate, t, ""computeSecret"", ComputeSecret);
    SetProtoMethodNoSideEffect(isolate, t, ""getPrime"", GetPrime);
    SetProtoMethodNoSideEffect(isolate, t, ""getGenerator"", GetGenerator);
    SetProtoMethodNoSideEffect(isolate, t, ""getPublicKey"", GetPublicKey);
    SetProtoMethodNoSideEffect(isolate, t, ""getPrivateKey"", GetPrivateKey);
    SetProtoMethod(isolate, t, ""setPublicKey"", SetPublicKey);
    SetProtoMethod(isolate, t, ""setPrivateKey"", SetPrivateKey);

    Local<FunctionTemplate> verify_error_getter_templ =
        FunctionTemplate::New(isolate,
                              Di...",15,3,crypto\crypto_dh.cc,node.crypto.DiffieHellman.Initialize.<lambda>0,,false,64,98,<lambda>0,,,1,"ANY node.crypto.DiffieHellman.Initialize.<lambda>0 (Local<String>,FunctionCallback)"
34369,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"[](const DH* dh) -> const BIGNUM* {
    const BIGNUM* p;
    DH_get0_pqg(dh, &p, nullptr, nullptr);
    return p;
  }",18,3,crypto\crypto_dh.cc,node.crypto.DiffieHellman.GetPrime.<lambda>1,,false,355,359,<lambda>1,,,1,BIGNUM node.crypto.DiffieHellman.GetPrime.<lambda>1 (DH*)
34384,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"[](const DH* dh) -> const BIGNUM* {
    const BIGNUM* g;
    DH_get0_pqg(dh, nullptr, nullptr, &g);
    return g;
  }",18,3,crypto\crypto_dh.cc,node.crypto.DiffieHellman.GetGenerator.<lambda>2,,false,363,367,<lambda>2,,,1,BIGNUM node.crypto.DiffieHellman.GetGenerator.<lambda>2 (DH*)
34399,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"[](const DH* dh) -> const BIGNUM* {
    const BIGNUM* pub_key;
    DH_get0_key(dh, &pub_key, nullptr);
    return pub_key;
  }",18,3,crypto\crypto_dh.cc,node.crypto.DiffieHellman.GetPublicKey.<lambda>3,,false,371,375,<lambda>3,,,1,BIGNUM node.crypto.DiffieHellman.GetPublicKey.<lambda>3 (DH*)
34413,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"[](const DH* dh) -> const BIGNUM* {
    const BIGNUM* priv_key;
    DH_get0_key(dh, nullptr, &priv_key);
    return priv_key;
  }",18,3,crypto\crypto_dh.cc,node.crypto.DiffieHellman.GetPrivateKey.<lambda>4,,false,379,383,<lambda>4,,,1,BIGNUM node.crypto.DiffieHellman.GetPrivateKey.<lambda>4 (DH*)
34427,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"[](DH* dh, BIGNUM* num) { return DH_set0_key(dh, num, nullptr); }",10,74,crypto\crypto_dh.cc,node.crypto.DiffieHellman.SetPublicKey.<lambda>5,,false,461,461,<lambda>5,,,1,"ANY node.crypto.DiffieHellman.SetPublicKey.<lambda>5 (DH*,BIGNUM*)"
34439,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"[](DH* dh, BIGNUM* num) { return DH_set0_key(dh, nullptr, num); }",10,74,crypto\crypto_dh.cc,node.crypto.DiffieHellman.SetPrivateKey.<lambda>6,,false,467,467,<lambda>6,,,1,"ANY node.crypto.DiffieHellman.SetPrivateKey.<lambda>6 (DH*,BIGNUM*)"
34470,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,<global>,1,34,crypto\crypto_dh.hpp,crypto\crypto_dh.cc:<global>,,false,1,727,<global>,,,1,
34475,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"void ZeroPadDiffieHellmanSecret(size_t remainder_size,
                                char* data,
                                size_t length) {
  // DH_size returns number of bytes in a prime number.
  // DH_compute_key returns number of bytes in a remainder of exponent, which
  // may have less bytes than a prime number. Therefore add 0-padding to the
  // allocated buffer.
  const size_t prime_size = length;
  if (remainder_size != prime_size) {
    CHECK_LT(remainder_size, prime_size);
    const size_t padding = prime_size - remainder_size;
    memmove(data + padding, data, remainder_size);
    memset(data, 0, padding);
  }
}",1,1,crypto\crypto_dh.cc,node.crypto.anonymous_namespace_1.ZeroPadDiffieHellmanSecret,,false,39,53,ZeroPadDiffieHellmanSecret,,,1,"void node.crypto.anonymous_namespace_1.ZeroPadDiffieHellmanSecret (size_t,char*,size_t)"
34510,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"DiffieHellman::DiffieHellman(Environment* env, Local<Object> wrap)
    : BaseObject(env, wrap), verifyError_(0) {
  MakeWeak();
}",1,1,crypto\crypto_dh.cc,node.crypto.DiffieHellman.DiffieHellman,,false,56,59,DiffieHellman,,,2,"ANY node.crypto.DiffieHellman.DiffieHellman (Environment*,Local<Object>)"
34517,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"void DiffieHellman::Initialize(Environment* env, Local<Object> target) {
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();
  auto make = [&](Local<String> name, FunctionCallback callback) {
    Local<FunctionTemplate> t = NewFunctionTemplate(isolate, callback);

    const PropertyAttribute attributes =
        static_cast<PropertyAttribute>(ReadOnly | DontDelete);

    t->InstanceTemplate()->SetInternalFieldCount(
        DiffieHellman::kInternalFieldCount);

    SetProtoMethod(isolate, t, ""generateKeys"", GenerateKeys);
    SetProtoMethod(isolate, t, ""computeSecret"", ComputeSecret);
    SetProtoMethodNoSideEffect(isolate, t, ""getPrime"", GetPrime);
    SetProtoMethodNoSideEffect(isolate, t, ""getGenerator"", GetGenerator);
    SetProtoMethodNoSideEffect(isolate, t, ""getPublicKey"", GetPublicKey);
    SetProtoMethodNoSideEffect(isolate, t, ""getPrivateKey"", GetPrivateKey);
    SetProtoMethod(isolate, t, ""setPublicKey"", SetPublicKey);
    SetProtoMethod(isolat...",1,1,crypto\crypto_dh.cc,node.crypto.DiffieHellman.Initialize,,false,61,109,Initialize,,,3,"void node.crypto.DiffieHellman.Initialize (Environment*,Local<Object>)"
34582,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"void DiffieHellman::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(New);
  registry->Register(DiffieHellmanGroup);

  registry->Register(GenerateKeys);
  registry->Register(ComputeSecret);
  registry->Register(GetPrime);
  registry->Register(GetGenerator);
  registry->Register(GetPublicKey);
  registry->Register(GetPrivateKey);
  registry->Register(SetPublicKey);
  registry->Register(SetPrivateKey);

  registry->Register(DiffieHellman::VerifyErrorGetter);
  registry->Register(DiffieHellman::Stateless);

  DHKeyPairGenJob::RegisterExternalReferences(registry);
  DHKeyExportJob::RegisterExternalReferences(registry);
  DHBitsJob::RegisterExternalReferences(registry);
}",1,1,crypto\crypto_dh.cc,node.crypto.DiffieHellman.RegisterExternalReferences,,false,111,131,RegisterExternalReferences,,,4,void node.crypto.DiffieHellman.RegisterExternalReferences (ExternalReferenceRegistry*)
34666,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"bool DiffieHellman::Init(int primeLength, int g) {
  dh_.reset(DH_new());
  if (!DH_generate_parameters_ex(dh_.get(), primeLength, g, nullptr))
    return false;
  return VerifyContext();
}",1,1,crypto\crypto_dh.cc,node.crypto.DiffieHellman.Init,,false,133,138,Init,,,5,"bool node.crypto.DiffieHellman.Init (int,int)"
34692,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"void DiffieHellman::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackFieldWithSize(""dh"", dh_ ? kSizeOf_DH : 0);
}",1,1,crypto\crypto_dh.cc,node.crypto.DiffieHellman.MemoryInfo,,false,140,142,MemoryInfo,,,6,void node.crypto.DiffieHellman.MemoryInfo (MemoryTracker*)
34706,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"bool DiffieHellman::Init(BignumPointer&& bn_p, int g) {
  dh_.reset(DH_new());
  CHECK_GE(g, 2);
  BignumPointer bn_g(BN_new());
  return bn_g && BN_set_word(bn_g.get(), g) &&
         DH_set0_pqg(dh_.get(), bn_p.release(), nullptr, bn_g.release()) &&
         VerifyContext();
}",1,1,crypto\crypto_dh.cc,node.crypto.DiffieHellman.Init,,false,144,151,Init,,,7,"bool node.crypto.DiffieHellman.Init (BignumPointer,int)"
34749,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"bool DiffieHellman::Init(const char* p, int p_len, int g) {
  dh_.reset(DH_new());
  if (p_len <= 0) {
    ERR_put_error(ERR_LIB_BN, BN_F_BN_GENERATE_PRIME_EX,
      BN_R_BITS_TOO_SMALL, __FILE__, __LINE__);
    return false;
  }
  if (g <= 1) {
    ERR_put_error(ERR_LIB_DH, DH_F_DH_BUILTIN_GENPARAMS,
      DH_R_BAD_GENERATOR, __FILE__, __LINE__);
    return false;
  }
  BIGNUM* bn_p =
      BN_bin2bn(reinterpret_cast<const unsigned char*>(p), p_len, nullptr);
  BIGNUM* bn_g = BN_new();
  if (!BN_set_word(bn_g, g) ||
      !DH_set0_pqg(dh_.get(), bn_p, nullptr, bn_g)) {
    BN_free(bn_p);
    BN_free(bn_g);
    return false;
  }
  return VerifyContext();
}",1,27,crypto\crypto_dh.cc,node.crypto.DiffieHellman.Init,,false,153,175,Init,,,8,"bool node.crypto.DiffieHellman.Init (char*,int,int)"
34832,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"bool DiffieHellman::Init(const char* p, int p_len, const char* g, int g_len) {
  dh_.reset(DH_new());
  if (p_len <= 0) {
    ERR_put_error(ERR_LIB_BN, BN_F_BN_GENERATE_PRIME_EX,
      BN_R_BITS_TOO_SMALL, __FILE__, __LINE__);
    return false;
  }
  if (g_len <= 0) {
    ERR_put_error(ERR_LIB_DH, DH_F_DH_BUILTIN_GENPARAMS,
      DH_R_BAD_GENERATOR, __FILE__, __LINE__);
    return false;
  }
  BIGNUM* bn_g =
      BN_bin2bn(reinterpret_cast<const unsigned char*>(g), g_len, nullptr);
  if (BN_is_zero(bn_g) || BN_is_one(bn_g)) {
    BN_free(bn_g);
    ERR_put_error(ERR_LIB_DH, DH_F_DH_BUILTIN_GENPARAMS,
      DH_R_BAD_GENERATOR, __FILE__, __LINE__);
    return false;
  }
  BIGNUM* bn_p =
      BN_bin2bn(reinterpret_cast<const unsigned char*>(p), p_len, nullptr);
  if (!DH_set0_pqg(dh_.get(), bn_p, nullptr, bn_g)) {
    BN_free(bn_p);
    BN_free(bn_g);
    return false;
  }
  return VerifyContext();
}",1,27,crypto\crypto_dh.cc,node.crypto.DiffieHellman.Init,,false,177,205,Init,,,9,"bool node.crypto.DiffieHellman.Init (char*,int,char*,int)"
34941,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"BignumPointer InstantiateStandardizedGroup() {
  return BignumPointer(p(nullptr));
}",1,1,crypto\crypto_dh.cc,node.crypto.InstantiateStandardizedGroup,,false,210,212,InstantiateStandardizedGroup,,,12,BignumPointer node.crypto.InstantiateStandardizedGroup<BIGNUM*(*)(BIGNUM*)> ()
34949,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,typedef BignumPointer (*StandardizedGroupInstantiator)();,23,56,crypto\crypto_dh.cc,node.crypto.StandardizedGroupInstantiator,,false,214,214,StandardizedGroupInstantiator,,,13,BignumPointer node.crypto.StandardizedGroupInstantiator ()
34953,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"inline StandardizedGroupInstantiator FindDiffieHellmanGroup(const char* name) {
#define V(n, p)                                                                \
  if (StringEqualNoCase(name, n)) return InstantiateStandardizedGroup<p>
  V(""modp1"", BN_get_rfc2409_prime_768);
  V(""modp2"", BN_get_rfc2409_prime_1024);
  V(""modp5"", BN_get_rfc3526_prime_1536);
  V(""modp14"", BN_get_rfc3526_prime_2048);
  V(""modp15"", BN_get_rfc3526_prime_3072);
  V(""modp16"", BN_get_rfc3526_prime_4096);
  V(""modp17"", BN_get_rfc3526_prime_6144);
  V(""modp18"", BN_get_rfc3526_prime_8192);
#undef V
  return nullptr;
}",1,2,crypto\crypto_dh.cc,node.crypto.FindDiffieHellmanGroup,,false,218,231,FindDiffieHellmanGroup,,,14,StandardizedGroupInstantiator node.crypto.FindDiffieHellmanGroup (char*)
35040,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"void DiffieHellman::DiffieHellmanGroup(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  DiffieHellman* diffieHellman = new DiffieHellman(env, args.This());

  CHECK_EQ(args.Length(), 1);
  THROW_AND_RETURN_IF_NOT_STRING(env, args[0], ""Group name"");

  bool initialized = false;

  const node::Utf8Value group_name(env->isolate(), args[0]);
  auto group = FindDiffieHellmanGroup(*group_name);
  if (group == nullptr)
    return THROW_ERR_CRYPTO_UNKNOWN_DH_GROUP(env);

  initialized = diffieHellman->Init(group(), kStandardizedGenerator);
  if (!initialized)
    THROW_ERR_CRYPTO_INITIALIZATION_FAILED(env);
}",1,1,crypto\crypto_dh.cc,node.crypto.DiffieHellman.DiffieHellmanGroup,,false,233,251,DiffieHellmanGroup,,,15,void node.crypto.DiffieHellman.DiffieHellmanGroup (FunctionCallbackInfo<Value>)
35116,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"void DiffieHellman::New(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  DiffieHellman* diffieHellman =
      new DiffieHellman(env, args.This());
  bool initialized = false;

  if (args.Length() == 2) {
    if (args[0]->IsInt32()) {
      if (args[1]->IsInt32()) {
        initialized = diffieHellman->Init(args[0].As<Int32>()->Value(),
                                          args[1].As<Int32>()->Value());
      }
    } else {
      ArrayBufferOrViewContents<char> arg0(args[0]);
      if (UNLIKELY(!arg0.CheckSizeInt32()))
        return THROW_ERR_OUT_OF_RANGE(env, ""prime is too big"");
      if (args[1]->IsInt32()) {
        initialized = diffieHellman->Init(arg0.data(),
                                          arg0.size(),
                                          args[1].As<Int32>()->Value());
      } else {
        ArrayBufferOrViewContents<char> arg1(args[1]);
        if (UNLIKELY(!arg1.CheckSizeInt32()))
          return THROW_ER...",1,1,crypto\crypto_dh.cc,node.crypto.DiffieHellman.New,,false,254,287,New,,,16,void node.crypto.DiffieHellman.New (FunctionCallbackInfo<Value>)
35291,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"void DiffieHellman::GenerateKeys(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  DiffieHellman* diffieHellman;
  ASSIGN_OR_RETURN_UNWRAP(&diffieHellman, args.Holder());

  if (!DH_generate_key(diffieHellman->dh_.get())) {
    return ThrowCryptoError(env, ERR_get_error(), ""Key generation failed"");
  }

  const BIGNUM* pub_key;
  DH_get0_key(diffieHellman->dh_.get(), &pub_key, nullptr);

  std::unique_ptr<BackingStore> bs;
  {
    const int size = BN_num_bytes(pub_key);
    CHECK_GE(size, 0);
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), size);
  }

  CHECK_EQ(static_cast<int>(bs->ByteLength()),
           BN_bn2binpad(pub_key,
                        static_cast<unsigned char*>(bs->Data()),
                        bs->ByteLength()));

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  Local<Value> buffer;
  if (!Buffer::New(env, a...",1,1,crypto\crypto_dh.cc,node.crypto.DiffieHellman.GenerateKeys,,false,290,320,GenerateKeys,,,17,void node.crypto.DiffieHellman.GenerateKeys (FunctionCallbackInfo<Value>)
35442,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"void DiffieHellman::GetField(const FunctionCallbackInfo<Value>& args,
                             const BIGNUM* (*get_field)(const DH*),
                             const char* err_if_null) {
  Environment* env = Environment::GetCurrent(args);

  DiffieHellman* dh;
  ASSIGN_OR_RETURN_UNWRAP(&dh, args.Holder());

  const BIGNUM* num = get_field(dh->dh_.get());
  if (num == nullptr)
    return THROW_ERR_CRYPTO_INVALID_STATE(env, err_if_null);

  std::unique_ptr<BackingStore> bs;
  {
    const int size = BN_num_bytes(num);
    CHECK_GE(size, 0);
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), size);
  }

  CHECK_EQ(static_cast<int>(bs->ByteLength()),
           BN_bn2binpad(num,
                        static_cast<unsigned char*>(bs->Data()),
                        bs->ByteLength()));

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  Local<Value> buffer;
  if (!Buffer::New(env, ...",1,1,crypto\crypto_dh.cc,node.crypto.DiffieHellman.GetField,,false,323,352,GetField,,,18,"void node.crypto.DiffieHellman.GetField (FunctionCallbackInfo<Value>,BIGNUM*,char*)"
35588,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"void DiffieHellman::GetPrime(const FunctionCallbackInfo<Value>& args) {
  GetField(args, [](const DH* dh) -> const BIGNUM* {
    const BIGNUM* p;
    DH_get0_pqg(dh, &p, nullptr, nullptr);
    return p;
  }, ""p is null"");
}",1,1,crypto\crypto_dh.cc,node.crypto.DiffieHellman.GetPrime,,false,354,360,GetPrime,,,19,void node.crypto.DiffieHellman.GetPrime (FunctionCallbackInfo<Value>)
35597,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"void DiffieHellman::GetGenerator(const FunctionCallbackInfo<Value>& args) {
  GetField(args, [](const DH* dh) -> const BIGNUM* {
    const BIGNUM* g;
    DH_get0_pqg(dh, nullptr, nullptr, &g);
    return g;
  }, ""g is null"");
}",1,1,crypto\crypto_dh.cc,node.crypto.DiffieHellman.GetGenerator,,false,362,368,GetGenerator,,,20,void node.crypto.DiffieHellman.GetGenerator (FunctionCallbackInfo<Value>)
35606,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"void DiffieHellman::GetPublicKey(const FunctionCallbackInfo<Value>& args) {
  GetField(args, [](const DH* dh) -> const BIGNUM* {
    const BIGNUM* pub_key;
    DH_get0_key(dh, &pub_key, nullptr);
    return pub_key;
  }, ""No public key - did you forget to generate one?"");
}",1,1,crypto\crypto_dh.cc,node.crypto.DiffieHellman.GetPublicKey,,false,370,376,GetPublicKey,,,21,void node.crypto.DiffieHellman.GetPublicKey (FunctionCallbackInfo<Value>)
35615,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"void DiffieHellman::GetPrivateKey(const FunctionCallbackInfo<Value>& args) {
  GetField(args, [](const DH* dh) -> const BIGNUM* {
    const BIGNUM* priv_key;
    DH_get0_key(dh, nullptr, &priv_key);
    return priv_key;
  }, ""No private key - did you forget to generate one?"");
}",1,1,crypto\crypto_dh.cc,node.crypto.DiffieHellman.GetPrivateKey,,false,378,384,GetPrivateKey,,,22,void node.crypto.DiffieHellman.GetPrivateKey (FunctionCallbackInfo<Value>)
35624,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"void DiffieHellman::ComputeSecret(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  DiffieHellman* diffieHellman;
  ASSIGN_OR_RETURN_UNWRAP(&diffieHellman, args.Holder());

  ClearErrorOnReturn clear_error_on_return;

  CHECK_EQ(args.Length(), 1);
  ArrayBufferOrViewContents<unsigned char> key_buf(args[0]);
  if (UNLIKELY(!key_buf.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""secret is too big"");
  BignumPointer key(BN_bin2bn(key_buf.data(), key_buf.size(), nullptr));

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(),
                                      DH_size(diffieHellman->dh_.get()));
  }

  int size = DH_compute_key(static_cast<unsigned char*>(bs->Data()),
                            key.get(),
                            diffieHellman->dh_.get());

  if (size == -1) {
    int checkResult;
    int chec...",1,1,crypto\crypto_dh.cc,node.crypto.DiffieHellman.ComputeSecret,,false,386,443,ComputeSecret,,,23,void node.crypto.DiffieHellman.ComputeSecret (FunctionCallbackInfo<Value>)
35859,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"void DiffieHellman::SetKey(const FunctionCallbackInfo<Value>& args,
                           int (*set_field)(DH*, BIGNUM*), const char* what) {
  Environment* env = Environment::GetCurrent(args);
  DiffieHellman* dh;
  ASSIGN_OR_RETURN_UNWRAP(&dh, args.Holder());
  CHECK_EQ(args.Length(), 1);
  ArrayBufferOrViewContents<unsigned char> buf(args[0]);
  if (UNLIKELY(!buf.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""buf is too big"");
  BIGNUM* num = BN_bin2bn(buf.data(), buf.size(), nullptr);
  CHECK_NOT_NULL(num);
  CHECK_EQ(1, set_field(dh->dh_.get(), num));
}",1,1,crypto\crypto_dh.cc,node.crypto.DiffieHellman.SetKey,,false,445,457,SetKey,,,24,"void node.crypto.DiffieHellman.SetKey (FunctionCallbackInfo<Value>,int,char*)"
35930,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"void DiffieHellman::SetPublicKey(const FunctionCallbackInfo<Value>& args) {
  SetKey(args,
         [](DH* dh, BIGNUM* num) { return DH_set0_key(dh, num, nullptr); },
         ""Public key"");
}",1,1,crypto\crypto_dh.cc,node.crypto.DiffieHellman.SetPublicKey,,false,459,463,SetPublicKey,,,25,void node.crypto.DiffieHellman.SetPublicKey (FunctionCallbackInfo<Value>)
35939,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"void DiffieHellman::SetPrivateKey(const FunctionCallbackInfo<Value>& args) {
  SetKey(args,
         [](DH* dh, BIGNUM* num) { return DH_set0_key(dh, nullptr, num); },
         ""Private key"");
}",1,1,crypto\crypto_dh.cc,node.crypto.DiffieHellman.SetPrivateKey,,false,465,469,SetPrivateKey,,,26,void node.crypto.DiffieHellman.SetPrivateKey (FunctionCallbackInfo<Value>)
35948,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"void DiffieHellman::VerifyErrorGetter(const FunctionCallbackInfo<Value>& args) {
  HandleScope scope(args.GetIsolate());

  DiffieHellman* diffieHellman;
  ASSIGN_OR_RETURN_UNWRAP(&diffieHellman, args.Holder());

  args.GetReturnValue().Set(diffieHellman->verifyError_);
}",1,1,crypto\crypto_dh.cc,node.crypto.DiffieHellman.VerifyErrorGetter,,false,471,478,VerifyErrorGetter,,,27,void node.crypto.DiffieHellman.VerifyErrorGetter (FunctionCallbackInfo<Value>)
35977,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"bool DiffieHellman::VerifyContext() {
  int codes;
  if (!DH_check(dh_.get(), &codes))
    return false;
  verifyError_ = codes;
  return true;
}",1,1,crypto\crypto_dh.cc,node.crypto.DiffieHellman.VerifyContext,,false,480,486,VerifyContext,,,28,bool node.crypto.DiffieHellman.VerifyContext ()
35999,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"Maybe<bool> DhKeyGenTraits::AdditionalConfig(
    CryptoJobMode mode,
    const FunctionCallbackInfo<Value>& args,
    unsigned int* offset,
    DhKeyPairGenConfig* params) {
  Environment* env = Environment::GetCurrent(args);

  if (args[*offset]->IsString()) {
    Utf8Value group_name(env->isolate(), args[*offset]);
    auto group = FindDiffieHellmanGroup(*group_name);
    if (group == nullptr) {
      THROW_ERR_CRYPTO_UNKNOWN_DH_GROUP(env);
      return Nothing<bool>();
    }

    params->params.prime = group();
    params->params.generator = kStandardizedGenerator;
    *offset += 1;
  } else {
    if (args[*offset]->IsInt32()) {
      int size = args[*offset].As<Int32>()->Value();
      if (size < 0) {
        THROW_ERR_OUT_OF_RANGE(env, ""Invalid prime size"");
        return Nothing<bool>();
      }
      params->params.prime = size;
    } else {
      ArrayBufferOrViewContents<unsigned char> input(args[*offset]);
      if (UNLIKELY(!input.CheckSizeInt32())) {
        THROW_ERR_...",1,1,crypto\crypto_dh.cc,node.crypto.DhKeyGenTraits.AdditionalConfig,,false,502,544,AdditionalConfig,,,29,"Maybe<bool> node.crypto.DhKeyGenTraits.AdditionalConfig (CryptoJobMode,FunctionCallbackInfo<Value>,unsigned int*,DhKeyPairGenConfig*)"
36181,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"EVPKeyCtxPointer DhKeyGenTraits::Setup(DhKeyPairGenConfig* params) {
  EVPKeyPointer key_params;
  if (BignumPointer* prime_fixed_value =
          std::get_if<BignumPointer>(&params->params.prime)) {
    DHPointer dh(DH_new());
    if (!dh)
      return EVPKeyCtxPointer();

    BIGNUM* prime = prime_fixed_value->get();
    BignumPointer bn_g(BN_new());
    if (!BN_set_word(bn_g.get(), params->params.generator) ||
        !DH_set0_pqg(dh.get(), prime, nullptr, bn_g.get())) {
      return EVPKeyCtxPointer();
    }

    prime_fixed_value->release();
    bn_g.release();

    key_params = EVPKeyPointer(EVP_PKEY_new());
    CHECK(key_params);
    CHECK_EQ(EVP_PKEY_assign_DH(key_params.get(), dh.release()), 1);
  } else if (int* prime_size = std::get_if<int>(&params->params.prime)) {
    EVPKeyCtxPointer param_ctx(EVP_PKEY_CTX_new_id(EVP_PKEY_DH, nullptr));
    EVP_PKEY* raw_params = nullptr;
    if (!param_ctx ||
        EVP_PKEY_paramgen_init(param_ctx.get()) <= 0 ||
        EVP_PKEY_CT...",1,1,crypto\crypto_dh.cc,node.crypto.DhKeyGenTraits.Setup,,false,546,592,Setup,,,30,EVPKeyCtxPointer node.crypto.DhKeyGenTraits.Setup (DhKeyPairGenConfig*)
36382,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"Maybe<bool> DHKeyExportTraits::AdditionalConfig(
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset,
    DHKeyExportConfig* params) {
  return Just(true);
}",1,1,crypto\crypto_dh.cc,node.crypto.DHKeyExportTraits.AdditionalConfig,,false,594,599,AdditionalConfig,,,31,"Maybe<bool> node.crypto.DHKeyExportTraits.AdditionalConfig (FunctionCallbackInfo<Value>,unsigned int,DHKeyExportConfig*)"
36392,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"WebCryptoKeyExportStatus DHKeyExportTraits::DoExport(
    std::shared_ptr<KeyObjectData> key_data,
    WebCryptoKeyFormat format,
    const DHKeyExportConfig& params,
    ByteSource* out) {
  CHECK_NE(key_data->GetKeyType(), kKeyTypeSecret);

  switch (format) {
    case kWebCryptoKeyFormatPKCS8:
      if (key_data->GetKeyType() != kKeyTypePrivate)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_PKCS8_Export(key_data.get(), out);
    case kWebCryptoKeyFormatSPKI:
      if (key_data->GetKeyType() != kKeyTypePublic)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_SPKI_Export(key_data.get(), out);
    default:
      UNREACHABLE();
  }
}",1,1,crypto\crypto_dh.cc,node.crypto.DHKeyExportTraits.DoExport,,false,601,620,DoExport,,,32,"WebCryptoKeyExportStatus node.crypto.DHKeyExportTraits.DoExport (ANY,WebCryptoKeyFormat,DHKeyExportConfig,ByteSource*)"
36454,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"ByteSource StatelessDiffieHellmanThreadsafe(
    const ManagedEVPPKey& our_key,
    const ManagedEVPPKey& their_key) {
  size_t out_size;

  EVPKeyCtxPointer ctx(EVP_PKEY_CTX_new(our_key.get(), nullptr));
  if (!ctx ||
      EVP_PKEY_derive_init(ctx.get()) <= 0 ||
      EVP_PKEY_derive_set_peer(ctx.get(), their_key.get()) <= 0 ||
      EVP_PKEY_derive(ctx.get(), nullptr, &out_size) <= 0)
    return ByteSource();

  ByteSource::Builder out(out_size);
  if (EVP_PKEY_derive(ctx.get(), out.data<unsigned char>(), &out_size) <= 0) {
    return ByteSource();
  }

  ZeroPadDiffieHellmanSecret(out_size, out.data<char>(), out.size());
  return std::move(out).release();
}",1,1,crypto\crypto_dh.cc,node.crypto.anonymous_namespace_3.StatelessDiffieHellmanThreadsafe,,false,623,642,StatelessDiffieHellmanThreadsafe,,,1,"ByteSource node.crypto.anonymous_namespace_3.StatelessDiffieHellmanThreadsafe (ManagedEVPPKey,ManagedEVPPKey)"
36545,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"void DiffieHellman::Stateless(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsObject() && args[1]->IsObject());
  KeyObjectHandle* our_key_object;
  ASSIGN_OR_RETURN_UNWRAP(&our_key_object, args[0].As<Object>());
  CHECK_EQ(our_key_object->Data()->GetKeyType(), kKeyTypePrivate);
  KeyObjectHandle* their_key_object;
  ASSIGN_OR_RETURN_UNWRAP(&their_key_object, args[1].As<Object>());
  CHECK_NE(their_key_object->Data()->GetKeyType(), kKeyTypeSecret);

  ManagedEVPPKey our_key = our_key_object->Data()->GetAsymmetricKey();
  ManagedEVPPKey their_key = their_key_object->Data()->GetAsymmetricKey();

  Local<Value> out;
  if (!StatelessDiffieHellmanThreadsafe(our_key, their_key)
          .ToBuffer(env)
              .ToLocal(&out)) return;

  if (Buffer::Length(out) == 0)
    return ThrowCryptoError(env, ERR_get_error(), ""diffieHellman failed"");

  args.GetReturnValue().Set(out);
}",1,1,crypto\crypto_dh.cc,node.crypto.DiffieHellman.Stateless,,false,645,668,Stateless,,,34,void node.crypto.DiffieHellman.Stateless (FunctionCallbackInfo<Value>)
36673,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"Maybe<bool> DHBitsTraits::AdditionalConfig(
    CryptoJobMode mode,
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset,
    DHBitsConfig* params) {
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[offset]->IsObject());  // public key
  CHECK(args[offset + 1]->IsObject());  // private key

  KeyObjectHandle* private_key;
  KeyObjectHandle* public_key;

  ASSIGN_OR_RETURN_UNWRAP(&public_key, args[offset], Nothing<bool>());
  ASSIGN_OR_RETURN_UNWRAP(&private_key, args[offset + 1], Nothing<bool>());

  if (private_key->Data()->GetKeyType() != kKeyTypePrivate ||
      public_key->Data()->GetKeyType() != kKeyTypePublic) {
    THROW_ERR_CRYPTO_INVALID_KEYTYPE(env);
    return Nothing<bool>();
  }

  params->public_key = public_key->Data();
  params->private_key = private_key->Data();

  return Just(true);
}",1,1,crypto\crypto_dh.cc,node.crypto.DHBitsTraits.AdditionalConfig,,false,670,696,AdditionalConfig,,,35,"Maybe<bool> node.crypto.DHBitsTraits.AdditionalConfig (CryptoJobMode,FunctionCallbackInfo<Value>,unsigned int,DHBitsConfig*)"
36767,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"Maybe<bool> DHBitsTraits::EncodeOutput(
    Environment* env,
    const DHBitsConfig& params,
    ByteSource* out,
    v8::Local<v8::Value>* result) {
  *result = out->ToArrayBuffer(env);
  return Just(!result->IsEmpty());
}",1,1,crypto\crypto_dh.cc,node.crypto.DHBitsTraits.EncodeOutput,,false,698,705,EncodeOutput,,,36,"Maybe<bool> node.crypto.DHBitsTraits.EncodeOutput (Environment*,DHBitsConfig,ByteSource*,ANY*)"
36790,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"bool DHBitsTraits::DeriveBits(
    Environment* env,
    const DHBitsConfig& params,
    ByteSource* out) {
  *out = StatelessDiffieHellmanThreadsafe(
      params.private_key->GetAsymmetricKey(),
      params.public_key->GetAsymmetricKey());
  return true;
}",1,1,crypto\crypto_dh.cc,node.crypto.DHBitsTraits.DeriveBits,,false,707,715,DeriveBits,,,37,"bool node.crypto.DHBitsTraits.DeriveBits (Environment*,DHBitsConfig,ByteSource*)"
36815,METHOD,crypto\crypto_dh.cc:<global>,TYPE_DECL,"Maybe<bool> GetDhKeyDetail(
    Environment* env,
    std::shared_ptr<KeyObjectData> key,
    Local<Object> target) {
  ManagedEVPPKey pkey = key->GetAsymmetricKey();
  CHECK_EQ(EVP_PKEY_id(pkey.get()), EVP_PKEY_DH);
  return Just(true);
}",1,1,crypto\crypto_dh.cc,node.crypto.GetDhKeyDetail,,false,717,724,GetDhKeyDetail,,,38,"Maybe<bool> node.crypto.GetDhKeyDetail (Environment*,ANY,Local<Object>)"
36856,METHOD,crypto\crypto_dh.hpp:<global>,TYPE_DECL,<global>,1,34,crypto\crypto_dh.hpp,crypto\crypto_dh.hpp:<global>,,false,1,157,<global>,,,1,
36883,METHOD,crypto\crypto_dsa.cc:<global>,TYPE_DECL,<global>,1,35,crypto\crypto_dsa.hpp,crypto\crypto_dsa.cc:<global>,,false,1,179,<global>,,,1,
36887,METHOD,crypto\crypto_dsa.cc:<global>,TYPE_DECL,"EVPKeyCtxPointer DsaKeyGenTraits::Setup(DsaKeyPairGenConfig* params) {
  EVPKeyCtxPointer param_ctx(EVP_PKEY_CTX_new_id(EVP_PKEY_DSA, nullptr));
  EVP_PKEY* raw_params = nullptr;

  if (!param_ctx ||
      EVP_PKEY_paramgen_init(param_ctx.get()) <= 0 ||
      EVP_PKEY_CTX_set_dsa_paramgen_bits(
          param_ctx.get(),
          params->params.modulus_bits) <= 0) {
    return EVPKeyCtxPointer();
  }

  if (params->params.divisor_bits != -1) {
    if (EVP_PKEY_CTX_set_dsa_paramgen_q_bits(
            param_ctx.get(), params->params.divisor_bits) <= 0) {
      return EVPKeyCtxPointer();
    }
  }

  if (EVP_PKEY_paramgen(param_ctx.get(), &raw_params) <= 0)
    return EVPKeyCtxPointer();

  EVPKeyPointer key_params(raw_params);
  EVPKeyCtxPointer key_ctx(EVP_PKEY_CTX_new(key_params.get(), nullptr));

  if (!key_ctx || EVP_PKEY_keygen_init(key_ctx.get()) <= 0)
    return EVPKeyCtxPointer();

  return key_ctx;
}",1,8,crypto\crypto_dsa.cc,node.crypto.DsaKeyGenTraits.Setup,,false,40,69,Setup,,,1,EVPKeyCtxPointer node.crypto.DsaKeyGenTraits.Setup (DsaKeyPairGenConfig*)
37009,METHOD,crypto\crypto_dsa.cc:<global>,TYPE_DECL,"Maybe<bool> DsaKeyGenTraits::AdditionalConfig(
    CryptoJobMode mode,
    const FunctionCallbackInfo<Value>& args,
    unsigned int* offset,
    DsaKeyPairGenConfig* params) {
  CHECK(args[*offset]->IsUint32());  // modulus bits
  CHECK(args[*offset + 1]->IsInt32());  // divisor bits

  params->params.modulus_bits = args[*offset].As<Uint32>()->Value();
  params->params.divisor_bits = args[*offset + 1].As<Int32>()->Value();
  CHECK_GE(params->params.divisor_bits, -1);

  *offset += 2;

  return Just(true);
}",1,1,crypto\crypto_dsa.cc,node.crypto.DsaKeyGenTraits.AdditionalConfig,,false,81,96,AdditionalConfig,,,2,"Maybe<bool> node.crypto.DsaKeyGenTraits.AdditionalConfig (CryptoJobMode,FunctionCallbackInfo<Value>,unsigned int*,DsaKeyPairGenConfig*)"
37084,METHOD,crypto\crypto_dsa.cc:<global>,TYPE_DECL,"Maybe<bool> DSAKeyExportTraits::AdditionalConfig(
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset,
    DSAKeyExportConfig* params) {
  return Just(true);
}",1,1,crypto\crypto_dsa.cc,node.crypto.DSAKeyExportTraits.AdditionalConfig,,false,98,103,AdditionalConfig,,,3,"Maybe<bool> node.crypto.DSAKeyExportTraits.AdditionalConfig (FunctionCallbackInfo<Value>,unsigned int,DSAKeyExportConfig*)"
37094,METHOD,crypto\crypto_dsa.cc:<global>,TYPE_DECL,"WebCryptoKeyExportStatus DSAKeyExportTraits::DoExport(
    std::shared_ptr<KeyObjectData> key_data,
    WebCryptoKeyFormat format,
    const DSAKeyExportConfig& params,
    ByteSource* out) {
  CHECK_NE(key_data->GetKeyType(), kKeyTypeSecret);

  switch (format) {
    case kWebCryptoKeyFormatRaw:
      // Not supported for RSA keys of either type
      return WebCryptoKeyExportStatus::FAILED;
    case kWebCryptoKeyFormatPKCS8:
      if (key_data->GetKeyType() != kKeyTypePrivate)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_PKCS8_Export(key_data.get(), out);
    case kWebCryptoKeyFormatSPKI:
      if (key_data->GetKeyType() != kKeyTypePublic)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_SPKI_Export(key_data.get(), out);
    default:
      UNREACHABLE();
  }
}",1,1,crypto\crypto_dsa.cc,node.crypto.DSAKeyExportTraits.DoExport,,false,105,127,DoExport,,,4,"WebCryptoKeyExportStatus node.crypto.DSAKeyExportTraits.DoExport (ANY,WebCryptoKeyFormat,DSAKeyExportConfig,ByteSource*)"
37161,METHOD,crypto\crypto_dsa.cc:<global>,TYPE_DECL,"Maybe<bool> GetDsaKeyDetail(
    Environment* env,
    std::shared_ptr<KeyObjectData> key,
    Local<Object> target) {
  const BIGNUM* p;  // Modulus length
  const BIGNUM* q;  // Divisor length

  ManagedEVPPKey m_pkey = key->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());
  int type = EVP_PKEY_id(m_pkey.get());
  CHECK(type == EVP_PKEY_DSA);

  const DSA* dsa = EVP_PKEY_get0_DSA(m_pkey.get());
  CHECK_NOT_NULL(dsa);

  DSA_get0_pqg(dsa, &p, &q, nullptr);

  size_t modulus_length = BN_num_bits(p);
  size_t divisor_length = BN_num_bits(q);

  if (target
          ->Set(
              env->context(),
              env->modulus_length_string(),
              Number::New(env->isolate(), static_cast<double>(modulus_length)))
          .IsNothing() ||
      target
          ->Set(
              env->context(),
              env->divisor_length_string(),
              Number::New(env->isolate(), static_cast<double>(divisor_length)))
          .IsNothing()) {
    return Noth...",1,1,crypto\crypto_dsa.cc,node.crypto.GetDsaKeyDetail,,false,129,165,GetDsaKeyDetail,,,5,"Maybe<bool> node.crypto.GetDsaKeyDetail (Environment*,ANY,Local<Object>)"
37284,METHOD,crypto\crypto_dsa.cc:<global>,TYPE_DECL,"void Initialize(Environment* env, Local<Object> target) {
  DsaKeyPairGenJob::Initialize(env, target);
  DSAKeyExportJob::Initialize(env, target);
}",1,1,crypto\crypto_dsa.cc,node.crypto.DSAAlg.Initialize,,false,168,171,Initialize,,,1,"void node.crypto.DSAAlg.Initialize (Environment*,Local<Object>)"
37302,METHOD,crypto\crypto_dsa.cc:<global>,TYPE_DECL,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  DsaKeyPairGenJob::RegisterExternalReferences(registry);
  DSAKeyExportJob::RegisterExternalReferences(registry);
}",1,1,crypto\crypto_dsa.cc,node.crypto.DSAAlg.RegisterExternalReferences,,false,173,176,RegisterExternalReferences,,,2,void node.crypto.DSAAlg.RegisterExternalReferences (ExternalReferenceRegistry*)
37332,METHOD,crypto\crypto_dsa.hpp:<global>,TYPE_DECL,<global>,1,35,crypto\crypto_dsa.hpp,crypto\crypto_dsa.hpp:<global>,,false,1,77,<global>,,,1,
37335,METHOD,crypto\crypto_ec.cc:<global>,TYPE_DECL,"[env](auto& curve) {
    return OneByteString(env->isolate(), OBJ_nid2sn(curve.nid));
  }",61,3,crypto\crypto_ec.cc,node.crypto.ECDH.GetCurves.<lambda>0,,false,115,117,<lambda>0,,,1,ANY node.crypto.ECDH.GetCurves.<lambda>0 (auto)
37384,METHOD,crypto\crypto_ec.cc:<global>,TYPE_DECL,<global>,1,34,crypto\crypto_ec.hpp,crypto\crypto_ec.cc:<global>,,false,1,1017,<global>,,,1,
37388,METHOD,crypto\crypto_ec.cc:<global>,TYPE_DECL,"int GetCurveFromName(const char* name) {
  int nid = EC_curve_nist2nid(name);
  if (nid == NID_undef)
    nid = OBJ_sn2nid(name);
  return nid;
}",1,1,crypto\crypto_ec.cc,node.crypto.GetCurveFromName,,false,41,46,GetCurveFromName,,,1,int node.crypto.GetCurveFromName (char*)
37409,METHOD,crypto\crypto_ec.cc:<global>,TYPE_DECL,"int GetOKPCurveFromName(const char* name) {
  int nid;
  if (strcmp(name, ""Ed25519"") == 0) {
    nid = EVP_PKEY_ED25519;
  } else if (strcmp(name, ""Ed448"") == 0) {
    nid = EVP_PKEY_ED448;
  } else if (strcmp(name, ""X25519"") == 0) {
    nid = EVP_PKEY_X25519;
  } else if (strcmp(name, ""X448"") == 0) {
    nid = EVP_PKEY_X448;
  } else {
    nid = NID_undef;
  }
  return nid;
}",1,1,crypto\crypto_ec.cc,node.crypto.GetOKPCurveFromName,,false,48,62,GetOKPCurveFromName,,,2,int node.crypto.GetOKPCurveFromName (char*)
37468,METHOD,crypto\crypto_ec.cc:<global>,TYPE_DECL,"void ECDH::Initialize(Environment* env, Local<Object> target) {
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);

  t->InstanceTemplate()->SetInternalFieldCount(ECDH::kInternalFieldCount);

  SetProtoMethod(isolate, t, ""generateKeys"", GenerateKeys);
  SetProtoMethod(isolate, t, ""computeSecret"", ComputeSecret);
  SetProtoMethodNoSideEffect(isolate, t, ""getPublicKey"", GetPublicKey);
  SetProtoMethodNoSideEffect(isolate, t, ""getPrivateKey"", GetPrivateKey);
  SetProtoMethod(isolate, t, ""setPublicKey"", SetPublicKey);
  SetProtoMethod(isolate, t, ""setPrivateKey"", SetPrivateKey);

  SetConstructorFunction(context, target, ""ECDH"", t);

  SetMethodNoSideEffect(context, target, ""ECDHConvertKey"", ECDH::ConvertKey);
  SetMethodNoSideEffect(context, target, ""getCurves"", ECDH::GetCurves);

  ECDHBitsJob::Initialize(env, target);
  ECKeyPairGenJob::Initialize(env, target);
  ECKeyExportJob::Initialize(...",1,2,crypto\crypto_ec.cc,node.crypto.ECDH.Initialize,,false,64,90,Initialize,,,3,"void node.crypto.ECDH.Initialize (Environment*,Local<Object>)"
37775,METHOD,crypto\crypto_ec.cc:<global>,TYPE_DECL,"void ECDH::RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(New);
  registry->Register(GenerateKeys);
  registry->Register(ComputeSecret);
  registry->Register(GetPublicKey);
  registry->Register(GetPrivateKey);
  registry->Register(SetPublicKey);
  registry->Register(SetPrivateKey);
  registry->Register(ECDH::ConvertKey);
  registry->Register(ECDH::GetCurves);

  ECDHBitsJob::RegisterExternalReferences(registry);
  ECKeyPairGenJob::RegisterExternalReferences(registry);
  ECKeyExportJob::RegisterExternalReferences(registry);
}",1,1,crypto\crypto_ec.cc,node.crypto.ECDH.RegisterExternalReferences,,false,92,106,RegisterExternalReferences,,,4,void node.crypto.ECDH.RegisterExternalReferences (ExternalReferenceRegistry*)
37844,METHOD,crypto\crypto_ec.cc:<global>,TYPE_DECL,"void ECDH::GetCurves(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  const size_t num_curves = EC_get_builtin_curves(nullptr, 0);
  std::vector<EC_builtin_curve> curves(num_curves);
  CHECK_EQ(EC_get_builtin_curves(curves.data(), num_curves), num_curves);

  std::vector<Local<Value>> arr(num_curves);
  std::transform(curves.begin(), curves.end(), arr.begin(), [env](auto& curve) {
    return OneByteString(env->isolate(), OBJ_nid2sn(curve.nid));
  });
  args.GetReturnValue().Set(Array::New(env->isolate(), arr.data(), arr.size()));
}",1,1,crypto\crypto_ec.cc,node.crypto.ECDH.GetCurves,,false,108,119,GetCurves,,,5,void node.crypto.ECDH.GetCurves (FunctionCallbackInfo<Value>)
37928,METHOD,crypto\crypto_ec.cc:<global>,TYPE_DECL,"ECDH::ECDH(Environment* env, Local<Object> wrap, ECKeyPointer&& key)
    : BaseObject(env, wrap),
    key_(std::move(key)),
    group_(EC_KEY_get0_group(key_.get())) {
  MakeWeak();
  CHECK_NOT_NULL(group_);
}",1,1,crypto\crypto_ec.cc,node.crypto.ECDH.ECDH,,false,121,127,ECDH,,,6,"ANY node.crypto.ECDH.ECDH (Environment*,Local<Object>,ECKeyPointer)"
37937,METHOD,crypto\crypto_ec.cc:<global>,TYPE_DECL,"void ECDH::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackFieldWithSize(""key"", key_ ? kSizeOf_EC_KEY : 0);
}",1,1,crypto\crypto_ec.cc,node.crypto.ECDH.MemoryInfo,,false,129,131,MemoryInfo,,,7,void node.crypto.ECDH.MemoryInfo (MemoryTracker*)
37951,METHOD,crypto\crypto_ec.cc:<global>,TYPE_DECL,ECDH::~ECDH() {},1,16,crypto\crypto_ec.cc,node.crypto.ECDH.~ECDH,,false,133,133,~ECDH,,,8,ANY node.crypto.ECDH.~ECDH ()
37955,METHOD,crypto\crypto_ec.cc:<global>,TYPE_DECL,"void ECDH::New(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  MarkPopErrorOnReturn mark_pop_error_on_return;

  // TODO(indutny): Support raw curves?
  CHECK(args[0]->IsString());
  node::Utf8Value curve(env->isolate(), args[0]);

  int nid = OBJ_sn2nid(*curve);
  if (nid == NID_undef)
    return THROW_ERR_CRYPTO_INVALID_CURVE(env);

  ECKeyPointer key(EC_KEY_new_by_curve_name(nid));
  if (!key)
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
      ""Failed to create key using named curve"");

  new ECDH(env, args.This(), std::move(key));
}",1,1,crypto\crypto_ec.cc,node.crypto.ECDH.New,,false,135,154,New,,,9,void node.crypto.ECDH.New (FunctionCallbackInfo<Value>)
38023,METHOD,crypto\crypto_ec.cc:<global>,TYPE_DECL,"void ECDH::GenerateKeys(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  ECDH* ecdh;
  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());

  if (!EC_KEY_generate_key(ecdh->key_.get()))
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""Failed to generate key"");
}",1,1,crypto\crypto_ec.cc,node.crypto.ECDH.GenerateKeys,,false,156,164,GenerateKeys,,,10,void node.crypto.ECDH.GenerateKeys (FunctionCallbackInfo<Value>)
38058,METHOD,crypto\crypto_ec.cc:<global>,TYPE_DECL,"ECPointPointer ECDH::BufferToPoint(Environment* env,
                                   const EC_GROUP* group,
                                   Local<Value> buf) {
  int r;

  ECPointPointer pub(EC_POINT_new(group));
  if (!pub) {
    THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to allocate EC_POINT for a public key"");
    return pub;
  }

  ArrayBufferOrViewContents<unsigned char> input(buf);
  if (UNLIKELY(!input.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""buffer is too big"");
    return ECPointPointer();
  }
  r = EC_POINT_oct2point(
      group,
      pub.get(),
      input.data(),
      input.size(),
      nullptr);
  if (!r)
    return ECPointPointer();

  return pub;
}",1,1,crypto\crypto_ec.cc,node.crypto.ECDH.BufferToPoint,,false,166,193,BufferToPoint,,,11,"ECPointPointer node.crypto.ECDH.BufferToPoint (Environment*,EC_GROUP*,Local<Value>)"
38120,METHOD,crypto\crypto_ec.cc:<global>,TYPE_DECL,"void ECDH::ComputeSecret(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  CHECK(IsAnyByteSource(args[0]));

  ECDH* ecdh;
  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());

  MarkPopErrorOnReturn mark_pop_error_on_return;

  if (!ecdh->IsKeyPairValid())
    return THROW_ERR_CRYPTO_INVALID_KEYPAIR(env);

  ECPointPointer pub(
      ECDH::BufferToPoint(env,
                          ecdh->group_,
                          args[0]));
  if (!pub) {
    args.GetReturnValue().Set(
        FIXED_ONE_BYTE_STRING(env->isolate(),
        ""ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY""));
    return;
  }

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    // NOTE: field_size is in bits
    int field_size = EC_GROUP_get_degree(ecdh->group_);
    size_t out_len = (field_size + 7) / 8;
    bs = ArrayBuffer::NewBackingStore(env->isolate(), out_len);
  }

  if (!ECDH_compute_key(
          bs->Data...",1,1,crypto\crypto_ec.cc,node.crypto.ECDH.ComputeSecret,,false,195,236,ComputeSecret,,,12,void node.crypto.ECDH.ComputeSecret (FunctionCallbackInfo<Value>)
38307,METHOD,crypto\crypto_ec.cc:<global>,TYPE_DECL,"void ECDH::GetPublicKey(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  // Conversion form
  CHECK_EQ(args.Length(), 1);

  ECDH* ecdh;
  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());

  const EC_GROUP* group = EC_KEY_get0_group(ecdh->key_.get());
  const EC_POINT* pub = EC_KEY_get0_public_key(ecdh->key_.get());
  if (pub == nullptr)
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to get ECDH public key"");

  CHECK(args[0]->IsUint32());
  uint32_t val = args[0].As<Uint32>()->Value();
  point_conversion_form_t form = static_cast<point_conversion_form_t>(val);

  const char* error;
  Local<Object> buf;
  if (!ECPointToBuffer(env, group, pub, form, &error).ToLocal(&buf))
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env, error);
  args.GetReturnValue().Set(buf);
}",1,1,crypto\crypto_ec.cc,node.crypto.ECDH.GetPublicKey,,false,238,262,GetPublicKey,,,13,void node.crypto.ECDH.GetPublicKey (FunctionCallbackInfo<Value>)
38421,METHOD,crypto\crypto_ec.cc:<global>,TYPE_DECL,"void ECDH::GetPrivateKey(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  ECDH* ecdh;
  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());

  const BIGNUM* b = EC_KEY_get0_private_key(ecdh->key_.get());
  if (b == nullptr)
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to get ECDH private key"");

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), BN_num_bytes(b));
  }
  CHECK_EQ(static_cast<int>(bs->ByteLength()),
           BN_bn2binpad(
               b, static_cast<unsigned char*>(bs->Data()), bs->ByteLength()));

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  Local<Value> buffer;
  if (!Buffer::New(env, ab, 0, ab->ByteLength()).ToLocal(&buffer)) return;
  args.GetReturnValue().Set(buffer);
}",1,1,crypto\crypto_ec.cc,node.crypto.ECDH.GetPrivateKey,,false,264,288,GetPrivateKey,,,14,void node.crypto.ECDH.GetPrivateKey (FunctionCallbackInfo<Value>)
38558,METHOD,crypto\crypto_ec.cc:<global>,TYPE_DECL,"void ECDH::SetPrivateKey(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  ECDH* ecdh;
  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());

  ArrayBufferOrViewContents<unsigned char> priv_buffer(args[0]);
  if (UNLIKELY(!priv_buffer.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""key is too big"");

  BignumPointer priv(BN_bin2bn(
      priv_buffer.data(), priv_buffer.size(), nullptr));
  if (!priv) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to convert Buffer to BN"");
  }

  if (!ecdh->IsKeyValidForCurve(priv)) {
    return THROW_ERR_CRYPTO_INVALID_KEYTYPE(env,
        ""Private key is not valid for specified curve."");
  }

  ECKeyPointer new_key(EC_KEY_dup(ecdh->key_.get()));
  CHECK(new_key);

  int result = EC_KEY_set_private_key(new_key.get(), priv.get());
  priv.reset();

  if (!result) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to convert BN to a private key"");
  }

  MarkPo...",1,1,crypto\crypto_ec.cc,node.crypto.ECDH.SetPrivateKey,,false,290,344,SetPrivateKey,,,15,void node.crypto.ECDH.SetPrivateKey (FunctionCallbackInfo<Value>)
38740,METHOD,crypto\crypto_ec.cc:<global>,TYPE_DECL,"void ECDH::SetPublicKey(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  ECDH* ecdh;
  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());

  CHECK(IsAnyByteSource(args[0]));

  MarkPopErrorOnReturn mark_pop_error_on_return;

  ECPointPointer pub(
      ECDH::BufferToPoint(env,
                          ecdh->group_,
                          args[0]));
  if (!pub) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to convert Buffer to EC_POINT"");
  }

  int r = EC_KEY_set_public_key(ecdh->key_.get(), pub.get());
  if (!r) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to set EC_POINT as the public key"");
  }
}",1,1,crypto\crypto_ec.cc,node.crypto.ECDH.SetPublicKey,,false,346,370,SetPublicKey,,,16,void node.crypto.ECDH.SetPublicKey (FunctionCallbackInfo<Value>)
38810,METHOD,crypto\crypto_ec.cc:<global>,TYPE_DECL,"bool ECDH::IsKeyValidForCurve(const BignumPointer& private_key) {
  CHECK(group_);
  CHECK(private_key);
  // Private keys must be in the range [1, n-1].
  // Ref: Section 3.2.1 - http://www.secg.org/sec1-v2.pdf
  if (BN_cmp(private_key.get(), BN_value_one()) < 0) {
    return false;
  }
  BignumPointer order(BN_new());
  CHECK(order);
  return EC_GROUP_get_order(group_, order.get(), nullptr) &&
         BN_cmp(private_key.get(), order.get()) < 0;
}",1,1,crypto\crypto_ec.cc,node.crypto.ECDH.IsKeyValidForCurve,,false,372,384,IsKeyValidForCurve,,,17,bool node.crypto.ECDH.IsKeyValidForCurve (BignumPointer)
38855,METHOD,crypto\crypto_ec.cc:<global>,TYPE_DECL,"bool ECDH::IsKeyPairValid() {
  MarkPopErrorOnReturn mark_pop_error_on_return;
  USE(&mark_pop_error_on_return);
  return 1 == EC_KEY_check_key(key_.get());
}",1,1,crypto\crypto_ec.cc,node.crypto.ECDH.IsKeyPairValid,,false,386,390,IsKeyPairValid,,,18,bool node.crypto.ECDH.IsKeyPairValid ()
38871,METHOD,crypto\crypto_ec.cc:<global>,TYPE_DECL,"void ECDH::ConvertKey(const FunctionCallbackInfo<Value>& args) {
  MarkPopErrorOnReturn mark_pop_error_on_return;
  Environment* env = Environment::GetCurrent(args);

  CHECK_EQ(args.Length(), 3);
  CHECK(IsAnyByteSource(args[0]));

  ArrayBufferOrViewContents<char> args0(args[0]);
  if (UNLIKELY(!args0.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""key is too big"");
  if (args0.size() == 0)
    return args.GetReturnValue().SetEmptyString();

  node::Utf8Value curve(env->isolate(), args[1]);

  int nid = OBJ_sn2nid(*curve);
  if (nid == NID_undef)
    return THROW_ERR_CRYPTO_INVALID_CURVE(env);

  ECGroupPointer group(
      EC_GROUP_new_by_curve_name(nid));
  if (group == nullptr)
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""Failed to get EC_GROUP"");

  ECPointPointer pub(
      ECDH::BufferToPoint(env,
                          group.get(),
                          args[0]));

  if (pub == nullptr) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Fai...",1,1,crypto\crypto_ec.cc,node.crypto.ECDH.ConvertKey,,false,393,436,ConvertKey,,,19,void node.crypto.ECDH.ConvertKey (FunctionCallbackInfo<Value>)
39052,METHOD,crypto\crypto_ec.cc:<global>,TYPE_DECL,"void ECDHBitsConfig::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""public"", public_);
  tracker->TrackField(""private"", private_);
}",1,1,crypto\crypto_ec.cc,node.crypto.ECDHBitsConfig.MemoryInfo,,false,438,441,MemoryInfo,,,20,void node.crypto.ECDHBitsConfig.MemoryInfo (MemoryTracker*)
39069,METHOD,crypto\crypto_ec.cc:<global>,TYPE_DECL,"Maybe<bool> ECDHBitsTraits::EncodeOutput(
    Environment* env,
    const ECDHBitsConfig& params,
    ByteSource* out,
    v8::Local<v8::Value>* result) {
  *result = out->ToArrayBuffer(env);
  return Just(!result->IsEmpty());
}",1,1,crypto\crypto_ec.cc,node.crypto.ECDHBitsTraits.EncodeOutput,,false,443,450,EncodeOutput,,,21,"Maybe<bool> node.crypto.ECDHBitsTraits.EncodeOutput (Environment*,ECDHBitsConfig,ByteSource*,ANY*)"
39092,METHOD,crypto\crypto_ec.cc:<global>,TYPE_DECL,"Maybe<bool> ECDHBitsTraits::AdditionalConfig(
    CryptoJobMode mode,
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset,
    ECDHBitsConfig* params) {
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[offset]->IsString());  // curve name
  CHECK(args[offset + 1]->IsObject());  // public key
  CHECK(args[offset + 2]->IsObject());  // private key

  KeyObjectHandle* private_key;
  KeyObjectHandle* public_key;

  Utf8Value name(env->isolate(), args[offset]);

  ASSIGN_OR_RETURN_UNWRAP(&public_key, args[offset + 1], Nothing<bool>());
  ASSIGN_OR_RETURN_UNWRAP(&private_key, args[offset + 2], Nothing<bool>());

  if (private_key->Data()->GetKeyType() != kKeyTypePrivate ||
      public_key->Data()->GetKeyType() != kKeyTypePublic) {
    THROW_ERR_CRYPTO_INVALID_KEYTYPE(env);
    return Nothing<bool>();
  }

  params->id_ = GetOKPCurveFromName(*name);
  params->private_ = private_key->Data();
  params->public_ = public_key->Data();

  return Just(true);
}",1,1,crypto\crypto_ec.cc,node.crypto.ECDHBitsTraits.AdditionalConfig,,false,452,482,AdditionalConfig,,,22,"Maybe<bool> node.crypto.ECDHBitsTraits.AdditionalConfig (CryptoJobMode,FunctionCallbackInfo<Value>,unsigned int,ECDHBitsConfig*)"
39213,METHOD,crypto\crypto_ec.cc:<global>,TYPE_DECL,"bool ECDHBitsTraits::DeriveBits(Environment* env,
                                const ECDHBitsConfig& params,
                                ByteSource* out) {
  size_t len = 0;
  ManagedEVPPKey m_privkey = params.private_->GetAsymmetricKey();
  ManagedEVPPKey m_pubkey = params.public_->GetAsymmetricKey();

  switch (params.id_) {
    case EVP_PKEY_X25519:
      // Fall through
    case EVP_PKEY_X448: {
      EVPKeyCtxPointer ctx = nullptr;
      {
        ctx.reset(EVP_PKEY_CTX_new(m_privkey.get(), nullptr));
      }
      Mutex::ScopedLock pub_lock(*m_pubkey.mutex());
      if (EVP_PKEY_derive_init(ctx.get()) <= 0 ||
          EVP_PKEY_derive_set_peer(
              ctx.get(),
              m_pubkey.get()) <= 0 ||
          EVP_PKEY_derive(ctx.get(), nullptr, &len) <= 0) {
        return false;
      }

      ByteSource::Builder buf(len);

      if (EVP_PKEY_derive(ctx.get(), buf.data<unsigned char>(), &len) <= 0) {
        return false;
      }

      *out = std::move(buf).rel...",1,1,crypto\crypto_ec.cc,node.crypto.ECDHBitsTraits.DeriveBits,,false,484,550,DeriveBits,,,23,"bool node.crypto.ECDHBitsTraits.DeriveBits (Environment*,ECDHBitsConfig,ByteSource*)"
39446,METHOD,crypto\crypto_ec.cc:<global>,TYPE_DECL,"EVPKeyCtxPointer EcKeyGenTraits::Setup(EcKeyPairGenConfig* params) {
  EVPKeyCtxPointer key_ctx;
  switch (params->params.curve_nid) {
    case EVP_PKEY_ED25519:
      // Fall through
    case EVP_PKEY_ED448:
      // Fall through
    case EVP_PKEY_X25519:
      // Fall through
    case EVP_PKEY_X448:
      key_ctx.reset(EVP_PKEY_CTX_new_id(params->params.curve_nid, nullptr));
      break;
    default: {
      EVPKeyCtxPointer param_ctx(EVP_PKEY_CTX_new_id(EVP_PKEY_EC, nullptr));
      EVP_PKEY* raw_params = nullptr;
      if (!param_ctx ||
          EVP_PKEY_paramgen_init(param_ctx.get()) <= 0 ||
          EVP_PKEY_CTX_set_ec_paramgen_curve_nid(
              param_ctx.get(), params->params.curve_nid) <= 0 ||
          EVP_PKEY_CTX_set_ec_param_enc(
              param_ctx.get(), params->params.param_encoding) <= 0 ||
          EVP_PKEY_paramgen(param_ctx.get(), &raw_params) <= 0) {
        return EVPKeyCtxPointer();
      }
      EVPKeyPointer key_params(raw_params);
      key_ctx...",1,1,crypto\crypto_ec.cc,node.crypto.EcKeyGenTraits.Setup,,false,552,585,Setup,,,24,EVPKeyCtxPointer node.crypto.EcKeyGenTraits.Setup (EcKeyPairGenConfig*)
39570,METHOD,crypto\crypto_ec.cc:<global>,TYPE_DECL,"Maybe<bool> EcKeyGenTraits::AdditionalConfig(
    CryptoJobMode mode,
    const FunctionCallbackInfo<Value>& args,
    unsigned int* offset,
    EcKeyPairGenConfig* params) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[*offset]->IsString());  // curve name
  CHECK(args[*offset + 1]->IsInt32());  // param encoding

  Utf8Value curve_name(env->isolate(), args[*offset]);
  params->params.curve_nid = GetCurveFromName(*curve_name);
  if (params->params.curve_nid == NID_undef) {
    THROW_ERR_CRYPTO_INVALID_CURVE(env);
    return Nothing<bool>();
  }

  params->params.param_encoding = args[*offset + 1].As<Int32>()->Value();
  if (params->params.param_encoding != OPENSSL_EC_NAMED_CURVE &&
      params->params.param_encoding != OPENSSL_EC_EXPLICIT_CURVE) {
    THROW_ERR_OUT_OF_RANGE(env, ""Invalid param_encoding specified"");
    return Nothing<bool>();
  }

  *offset += 2;

  return Just(true);
}",1,1,crypto\crypto_ec.cc,node.crypto.EcKeyGenTraits.AdditionalConfig,,false,597,623,AdditionalConfig,,,25,"Maybe<bool> node.crypto.EcKeyGenTraits.AdditionalConfig (CryptoJobMode,FunctionCallbackInfo<Value>,unsigned int*,EcKeyPairGenConfig*)"
39684,METHOD,crypto\crypto_ec.cc:<global>,TYPE_DECL,"WebCryptoKeyExportStatus EC_Raw_Export(
    KeyObjectData* key_data,
    const ECKeyExportConfig& params,
    ByteSource* out) {
  ManagedEVPPKey m_pkey = key_data->GetAsymmetricKey();
  CHECK(m_pkey);
  Mutex::ScopedLock lock(*m_pkey.mutex());

  const EC_KEY* ec_key = EVP_PKEY_get0_EC_KEY(m_pkey.get());

  size_t len = 0;

  if (ec_key == nullptr) {
    typedef int (*export_fn)(const EVP_PKEY*, unsigned char*, size_t* len);
    export_fn fn = nullptr;
    switch (key_data->GetKeyType()) {
      case kKeyTypePrivate:
        fn = EVP_PKEY_get_raw_private_key;
        break;
      case kKeyTypePublic:
        fn = EVP_PKEY_get_raw_public_key;
        break;
      case kKeyTypeSecret:
        UNREACHABLE();
    }
    CHECK_NOT_NULL(fn);
    // Get the size of the raw key data
    if (fn(m_pkey.get(), nullptr, &len) == 0)
      return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
    ByteSource::Builder data(len);
    if (fn(m_pkey.get(), data.data<unsigned char>(), &len) == 0)
      re...",1,1,crypto\crypto_ec.cc,node.crypto.anonymous_namespace_1.EC_Raw_Export,,false,626,681,EC_Raw_Export,,,1,"WebCryptoKeyExportStatus node.crypto.anonymous_namespace_1.EC_Raw_Export (KeyObjectData*,ECKeyExportConfig,ByteSource*)"
39722,METHOD,crypto\crypto_ec.cc:<global>,TYPE_DECL,"typedef int (*export_fn)(const EVP_PKEY*, unsigned char*, size_t* len);",17,74,crypto\crypto_ec.cc,node.crypto.anonymous_namespace_2.EC_Raw_Export.export_fn,,false,639,639,export_fn,,,1,"int node.crypto.anonymous_namespace_2.EC_Raw_Export.export_fn (EVP_PKEY*,unsigned char*,size_t*)"
39897,METHOD,crypto\crypto_ec.cc:<global>,TYPE_DECL,"Maybe<bool> ECKeyExportTraits::AdditionalConfig(
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset,
    ECKeyExportConfig* params) {
  return Just(true);
}",1,1,crypto\crypto_ec.cc,node.crypto.ECKeyExportTraits.AdditionalConfig,,false,684,689,AdditionalConfig,,,27,"Maybe<bool> node.crypto.ECKeyExportTraits.AdditionalConfig (FunctionCallbackInfo<Value>,unsigned int,ECKeyExportConfig*)"
39907,METHOD,crypto\crypto_ec.cc:<global>,TYPE_DECL,"WebCryptoKeyExportStatus ECKeyExportTraits::DoExport(
    std::shared_ptr<KeyObjectData> key_data,
    WebCryptoKeyFormat format,
    const ECKeyExportConfig& params,
    ByteSource* out) {
  CHECK_NE(key_data->GetKeyType(), kKeyTypeSecret);

  switch (format) {
    case kWebCryptoKeyFormatRaw:
      return EC_Raw_Export(key_data.get(), params, out);
    case kWebCryptoKeyFormatPKCS8:
      if (key_data->GetKeyType() != kKeyTypePrivate)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_PKCS8_Export(key_data.get(), out);
    case kWebCryptoKeyFormatSPKI: {
      if (key_data->GetKeyType() != kKeyTypePublic)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;

      ManagedEVPPKey m_pkey = key_data->GetAsymmetricKey();
      if (EVP_PKEY_id(m_pkey.get()) != EVP_PKEY_EC) {
        return PKEY_SPKI_Export(key_data.get(), out);
      } else {
        // Ensure exported key is in uncompressed point format.
        // The temporary EC key is so we can have...",1,1,crypto\crypto_ec.cc,node.crypto.ECKeyExportTraits.DoExport,,false,691,753,DoExport,,,28,"WebCryptoKeyExportStatus node.crypto.ECKeyExportTraits.DoExport (ANY,WebCryptoKeyFormat,ECKeyExportConfig,ByteSource*)"
40123,METHOD,crypto\crypto_ec.cc:<global>,TYPE_DECL,BIOPointer bio(BIO_new(BIO_s_mem()));,20,44,crypto\crypto_ec.cc,node.crypto.ECKeyExportTraits.DoExport.bio,,false,742,742,bio,,,29,BIOPointer node.crypto.ECKeyExportTraits.DoExport.bio (BIO_new)
40162,METHOD,crypto\crypto_ec.cc:<global>,TYPE_DECL,"Maybe<void> ExportJWKEcKey(
    Environment* env,
    std::shared_ptr<KeyObjectData> key,
    Local<Object> target) {
  ManagedEVPPKey m_pkey = key->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());
  CHECK_EQ(EVP_PKEY_id(m_pkey.get()), EVP_PKEY_EC);

  const EC_KEY* ec = EVP_PKEY_get0_EC_KEY(m_pkey.get());
  CHECK_NOT_NULL(ec);

  const EC_POINT* pub = EC_KEY_get0_public_key(ec);
  const EC_GROUP* group = EC_KEY_get0_group(ec);

  int degree_bits = EC_GROUP_get_degree(group);
  int degree_bytes =
    (degree_bits / CHAR_BIT) + (7 + (degree_bits % CHAR_BIT)) / 8;

  BignumPointer x(BN_new());
  BignumPointer y(BN_new());

  if (!EC_POINT_get_affine_coordinates(group, pub, x.get(), y.get(), nullptr)) {
    ThrowCryptoError(env, ERR_get_error(),
                     ""Failed to get elliptic-curve point coordinates"");
    return Nothing<void>();
  }

  if (target->Set(
          env->context(),
          env->jwk_kty_string(),
          env->jwk_ec_string()).IsNothing()) {
...",1,1,crypto\crypto_ec.cc,node.crypto.ExportJWKEcKey,,false,755,843,ExportJWKEcKey,,,29,"Maybe<void> node.crypto.ExportJWKEcKey (Environment*,ANY,Local<Object>)"
40431,METHOD,crypto\crypto_ec.cc:<global>,TYPE_DECL,"Maybe<bool> ExportJWKEdKey(
    Environment* env,
    std::shared_ptr<KeyObjectData> key,
    Local<Object> target) {
  ManagedEVPPKey pkey = key->GetAsymmetricKey();
  Mutex::ScopedLock lock(*pkey.mutex());

  const char* curve = nullptr;
  switch (EVP_PKEY_id(pkey.get())) {
    case EVP_PKEY_ED25519:
      curve = ""Ed25519"";
      break;
    case EVP_PKEY_ED448:
      curve = ""Ed448"";
      break;
    case EVP_PKEY_X25519:
      curve = ""X25519"";
      break;
    case EVP_PKEY_X448:
      curve = ""X448"";
      break;
    default:
      UNREACHABLE();
  }
  if (target->Set(
          env->context(),
          env->jwk_crv_string(),
          OneByteString(env->isolate(), curve)).IsNothing()) {
    return Nothing<bool>();
  }

  size_t len = 0;
  Local<Value> encoded;
  Local<Value> error;

  if (!EVP_PKEY_get_raw_public_key(pkey.get(), nullptr, &len))
    return Nothing<bool>();

  ByteSource::Builder out(len);

  if (key->GetKeyType() == kKeyTypePrivate) {
    if (!EVP_PKEY_get_ra...",1,1,crypto\crypto_ec.cc,node.crypto.ExportJWKEdKey,,false,845,917,ExportJWKEdKey,,,30,"Maybe<bool> node.crypto.ExportJWKEdKey (Environment*,ANY,Local<Object>)"
40722,METHOD,crypto\crypto_ec.cc:<global>,TYPE_DECL,"std::shared_ptr<KeyObjectData> ImportJWKEcKey(
    Environment* env,
    Local<Object> jwk,
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset) {
  CHECK(args[offset]->IsString());  // curve name
  Utf8Value curve(env->isolate(), args[offset].As<String>());

  int nid = GetCurveFromName(*curve);
  if (nid == NID_undef) {  // Unknown curve
    THROW_ERR_CRYPTO_INVALID_CURVE(env);
    return std::shared_ptr<KeyObjectData>();
  }

  Local<Value> x_value;
  Local<Value> y_value;
  Local<Value> d_value;

  if (!jwk->Get(env->context(), env->jwk_x_string()).ToLocal(&x_value) ||
      !jwk->Get(env->context(), env->jwk_y_string()).ToLocal(&y_value) ||
      !jwk->Get(env->context(), env->jwk_d_string()).ToLocal(&d_value)) {
    return std::shared_ptr<KeyObjectData>();
  }

  if (!x_value->IsString() ||
      !y_value->IsString() ||
      (!d_value->IsUndefined() && !d_value->IsString())) {
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK EC key"");
    return std::shared...",1,1,crypto\crypto_ec.cc,node.crypto.ImportJWKEcKey,,false,919,981,ImportJWKEcKey,,,31,"shared_ptr<KeyObjectData> node.crypto.ImportJWKEcKey (Environment*,Local<Object>,FunctionCallbackInfo<Value>,unsigned int)"
41024,METHOD,crypto\crypto_ec.cc:<global>,TYPE_DECL,"Maybe<bool> GetEcKeyDetail(
    Environment* env,
    std::shared_ptr<KeyObjectData> key,
    Local<Object> target) {
  ManagedEVPPKey m_pkey = key->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());
  CHECK_EQ(EVP_PKEY_id(m_pkey.get()), EVP_PKEY_EC);

  const EC_KEY* ec = EVP_PKEY_get0_EC_KEY(m_pkey.get());
  CHECK_NOT_NULL(ec);

  const EC_GROUP* group = EC_KEY_get0_group(ec);
  int nid = EC_GROUP_get_curve_name(group);

  return target->Set(
      env->context(),
      env->named_curve_string(),
      OneByteString(env->isolate(), OBJ_nid2sn(nid)));
}",1,1,crypto\crypto_ec.cc,node.crypto.GetEcKeyDetail,,false,983,1001,GetEcKeyDetail,,,32,"Maybe<bool> node.crypto.GetEcKeyDetail (Environment*,ANY,Local<Object>)"
41092,METHOD,crypto\crypto_ec.cc:<global>,TYPE_DECL,"size_t GroupOrderSize(const ManagedEVPPKey& key) {
  const EC_KEY* ec = EVP_PKEY_get0_EC_KEY(key.get());
  CHECK_NOT_NULL(ec);
  const EC_GROUP* group = EC_KEY_get0_group(ec);
  BignumPointer order(BN_new());
  CHECK(EC_GROUP_get_order(group, order.get(), nullptr));
  return BN_num_bytes(order.get());
}",1,1,crypto\crypto_ec.cc,node.crypto.GroupOrderSize,,false,1008,1015,GroupOrderSize,,,33,size_t node.crypto.GroupOrderSize (ManagedEVPPKey)
41150,METHOD,crypto\crypto_ec.hpp:<global>,TYPE_DECL,<global>,1,34,crypto\crypto_ec.hpp,crypto\crypto_ec.hpp:<global>,,false,1,170,<global>,,,1,
41153,METHOD,crypto\crypto_hash.cc:<global>,TYPE_DECL,"[](Hash* hash, const FunctionCallbackInfo<Value>& args,
                        const char* data, size_t size) {
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    bool r = hash->HashUpdate(data, size);
    args.GetReturnValue().Set(r);
  }",22,3,crypto\crypto_hash.cc,"args, [](Hash* hash, const FunctionCallbackInfo<Value>& args, const char* data, size_t size) { Environment* env = Environment.GetCurrent(args); if (UNLIKELY(size > INT_MAX)) return THROW_ERR_OUT_OF_RANGE(env, ""data is too long""); bool r = hash->HashUpdate(data, size); args.GetReturnValue().Set(r); }.<lambda>0",,false,141,148,<lambda>0,,,1,"ANY args, [](Hash* hash, const FunctionCallbackInfo<Value>& args, const char* data, size_t size) { Environment* env = Environment.GetCurrent(args); if (UNLIKELY(size > INT_MAX)) return THROW_ERR_OUT_OF_RANGE(env, ""data is too long""); bool r = hash->HashUpdate(data, size); args.GetReturnValue().Set(r); }.<lambda>0 (Hash*,FunctionCallbackInfo<Value>,char*,size_t)"
41218,METHOD,crypto\crypto_hash.cc:<global>,TYPE_DECL,<global>,1,36,crypto\crypto_hash.hpp,crypto\crypto_hash.cc:<global>,,false,1,312,<global>,,,1,
41222,METHOD,crypto\crypto_hash.cc:<global>,TYPE_DECL,"Hash::Hash(Environment* env, Local<Object> wrap) : BaseObject(env, wrap) {
  MakeWeak();
}",1,1,crypto\crypto_hash.cc,node.crypto.Hash.Hash,,false,28,30,Hash,,,1,"ANY node.crypto.Hash.Hash (Environment*,Local<Object>)"
41229,METHOD,crypto\crypto_hash.cc:<global>,TYPE_DECL,"void Hash::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackFieldWithSize(""mdctx"", mdctx_ ? kSizeOf_EVP_MD_CTX : 0);
  tracker->TrackFieldWithSize(""md"", digest_ ? md_len_ : 0);
}",1,1,crypto\crypto_hash.cc,node.crypto.Hash.MemoryInfo,,false,32,35,MemoryInfo,,,2,void node.crypto.Hash.MemoryInfo (MemoryTracker*)
41252,METHOD,crypto\crypto_hash.cc:<global>,TYPE_DECL,"void Hash::GetHashes(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  MarkPopErrorOnReturn mark_pop_error_on_return;
  CipherPushContext ctx(env);
  EVP_MD_do_all_sorted(
#if OPENSSL_VERSION_MAJOR >= 3
    array_push_back<EVP_MD,
                    EVP_MD_fetch,
                    EVP_MD_free,
                    EVP_get_digestbyname,
                    EVP_MD_get0_name>,
#else
    array_push_back<EVP_MD>,
#endif
    &ctx);
  args.GetReturnValue().Set(ctx.ToJSArray());
}",1,1,crypto\crypto_hash.cc,node.crypto.Hash.GetHashes,,false,37,53,GetHashes,,,3,void node.crypto.Hash.GetHashes (FunctionCallbackInfo<Value>)
41284,METHOD,crypto\crypto_hash.cc:<global>,TYPE_DECL,"void Hash::Initialize(Environment* env, Local<Object> target) {
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();
  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);

  t->InstanceTemplate()->SetInternalFieldCount(Hash::kInternalFieldCount);

  SetProtoMethod(isolate, t, ""update"", HashUpdate);
  SetProtoMethod(isolate, t, ""digest"", HashDigest);

  SetConstructorFunction(context, target, ""Hash"", t);

  SetMethodNoSideEffect(context, target, ""getHashes"", GetHashes);

  HashJob::Initialize(env, target);
}",1,1,crypto\crypto_hash.cc,node.crypto.Hash.Initialize,,false,55,70,Initialize,,,4,"void node.crypto.Hash.Initialize (Environment*,Local<Object>)"
41352,METHOD,crypto\crypto_hash.cc:<global>,TYPE_DECL,"void Hash::RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(New);
  registry->Register(HashUpdate);
  registry->Register(HashDigest);
  registry->Register(GetHashes);

  HashJob::RegisterExternalReferences(registry);
}",1,1,crypto\crypto_hash.cc,node.crypto.Hash.RegisterExternalReferences,,false,72,79,RegisterExternalReferences,,,5,void node.crypto.Hash.RegisterExternalReferences (ExternalReferenceRegistry*)
41382,METHOD,crypto\crypto_hash.cc:<global>,TYPE_DECL,"void Hash::New(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const Hash* orig = nullptr;
  const EVP_MD* md = nullptr;

  if (args[0]->IsObject()) {
    ASSIGN_OR_RETURN_UNWRAP(&orig, args[0].As<Object>());
    md = EVP_MD_CTX_md(orig->mdctx_.get());
  } else {
    const Utf8Value hash_type(env->isolate(), args[0]);
    md = EVP_get_digestbyname(*hash_type);
  }

  Maybe<unsigned int> xof_md_len = Nothing<unsigned int>();
  if (!args[1]->IsUndefined()) {
    CHECK(args[1]->IsUint32());
    xof_md_len = Just<unsigned int>(args[1].As<Uint32>()->Value());
  }

  Hash* hash = new Hash(env, args.This());
  if (md == nullptr || !hash->HashInit(md, xof_md_len)) {
    return ThrowCryptoError(env, ERR_get_error(),
                            ""Digest method not supported"");
  }

  if (orig != nullptr &&
      0 >= EVP_MD_CTX_copy(hash->mdctx_.get(), orig->mdctx_.get())) {
    return ThrowCryptoError(env, ERR_get_error(), ""Digest copy error"")...",1,1,crypto\crypto_hash.cc,node.crypto.Hash.New,,false,81,111,New,,,6,void node.crypto.Hash.New (FunctionCallbackInfo<Value>)
41531,METHOD,crypto\crypto_hash.cc:<global>,TYPE_DECL,"bool Hash::HashInit(const EVP_MD* md, Maybe<unsigned int> xof_md_len) {
  mdctx_.reset(EVP_MD_CTX_new());
  if (!mdctx_ || EVP_DigestInit_ex(mdctx_.get(), md, nullptr) <= 0) {
    mdctx_.reset();
    return false;
  }

  md_len_ = EVP_MD_size(md);
  if (xof_md_len.IsJust() && xof_md_len.FromJust() != md_len_) {
    // This is a little hack to cause createHash to fail when an incorrect
    // hashSize option was passed for a non-XOF hash function.
    if ((EVP_MD_flags(md) & EVP_MD_FLAG_XOF) == 0) {
      EVPerr(EVP_F_EVP_DIGESTFINALXOF, EVP_R_NOT_XOF_OR_INVALID_LENGTH);
      return false;
    }
    md_len_ = xof_md_len.FromJust();
  }

  return true;
}",1,1,crypto\crypto_hash.cc,node.crypto.Hash.HashInit,,false,113,132,HashInit,,,7,"bool node.crypto.Hash.HashInit (EVP_MD*,Maybe<unsigned int>)"
41600,METHOD,crypto\crypto_hash.cc:<global>,TYPE_DECL,"bool Hash::HashUpdate(const char* data, size_t len) {
  if (!mdctx_)
    return false;
  return EVP_DigestUpdate(mdctx_.get(), data, len) == 1;
}",1,1,crypto\crypto_hash.cc,node.crypto.Hash.HashUpdate,,false,134,138,HashUpdate,,,8,"bool node.crypto.Hash.HashUpdate (char*,size_t)"
41622,METHOD,crypto\crypto_hash.cc:<global>,TYPE_DECL,"void Hash::HashUpdate(const FunctionCallbackInfo<Value>& args) {
  Decode<Hash>(args, [](Hash* hash, const FunctionCallbackInfo<Value>& args,
                        const char* data, size_t size) {
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    bool r = hash->HashUpdate(data, size);
    args.GetReturnValue().Set(r);
  });
}",1,1,crypto\crypto_hash.cc,node.crypto.Hash.HashUpdate,,false,140,149,HashUpdate,,,9,void node.crypto.Hash.HashUpdate (FunctionCallbackInfo<Value>)
41634,METHOD,crypto\crypto_hash.cc:<global>,TYPE_DECL,"void Hash::HashDigest(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  Hash* hash;
  ASSIGN_OR_RETURN_UNWRAP(&hash, args.Holder());

  enum encoding encoding = BUFFER;
  if (args.Length() >= 1) {
    encoding = ParseEncoding(env->isolate(), args[0], BUFFER);
  }

  unsigned int len = hash->md_len_;

  // TODO(tniessen): SHA3_squeeze does not work for zero-length outputs on all
  // platforms and will cause a segmentation fault if called. This workaround
  // causes hash.digest() to correctly return an empty buffer / string.
  // See https://github.com/openssl/openssl/issues/9431.

  if (!hash->digest_ && len > 0) {
    // Some hash algorithms such as SHA3 do not support calling
    // EVP_DigestFinal_ex more than once, however, Hash._flush
    // and Hash.digest can both be used to retrieve the digest,
    // so we need to cache it.
    // See https://github.com/nodejs/node/issues/28245.

    ByteSource::Builder digest(len);

    size...",1,1,crypto\crypto_hash.cc,node.crypto.Hash.HashDigest,,false,151,205,HashDigest,,,10,void node.crypto.Hash.HashDigest (FunctionCallbackInfo<Value>)
41832,METHOD,crypto\crypto_hash.cc:<global>,TYPE_DECL,"HashConfig::HashConfig(HashConfig&& other) noexcept
    : mode(other.mode),
      in(std::move(other.in)),
      digest(other.digest),
      length(other.length) {}",1,29,crypto\crypto_hash.cc,node.crypto.HashConfig.HashConfig,,false,207,211,HashConfig,,,11,ANY node.crypto.HashConfig.HashConfig (HashConfig)
41837,METHOD,crypto\crypto_hash.cc:<global>,TYPE_DECL,"HashConfig& HashConfig::operator=(HashConfig&& other) noexcept {
  if (&other == this) return *this;
  this->~HashConfig();
  return *new (this) HashConfig(std::move(other));
}",1,1,crypto\crypto_hash.cc,node.crypto.HashConfig.operator =,,false,213,217,operator =,,,12,HashConfig node.crypto.HashConfig.operator = (HashConfig)
41865,METHOD,crypto\crypto_hash.cc:<global>,TYPE_DECL,"void HashConfig::MemoryInfo(MemoryTracker* tracker) const {
  // If the Job is sync, then the HashConfig does not own the data.
  if (mode == kCryptoJobAsync)
    tracker->TrackFieldWithSize(""in"", in.size());
}",1,1,crypto\crypto_hash.cc,node.crypto.HashConfig.MemoryInfo,,false,219,223,MemoryInfo,,,13,void node.crypto.HashConfig.MemoryInfo (MemoryTracker*)
41884,METHOD,crypto\crypto_hash.cc:<global>,TYPE_DECL,"Maybe<bool> HashTraits::EncodeOutput(
    Environment* env,
    const HashConfig& params,
    ByteSource* out,
    v8::Local<v8::Value>* result) {
  *result = out->ToArrayBuffer(env);
  return Just(!result->IsEmpty());
}",1,1,crypto\crypto_hash.cc,node.crypto.HashTraits.EncodeOutput,,false,225,232,EncodeOutput,,,14,"Maybe<bool> node.crypto.HashTraits.EncodeOutput (Environment*,HashConfig,ByteSource*,ANY*)"
41907,METHOD,crypto\crypto_hash.cc:<global>,TYPE_DECL,"Maybe<bool> HashTraits::AdditionalConfig(
    CryptoJobMode mode,
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset,
    HashConfig* params) {
  Environment* env = Environment::GetCurrent(args);

  params->mode = mode;

  CHECK(args[offset]->IsString());  // Hash algorithm
  Utf8Value digest(env->isolate(), args[offset]);
  params->digest = EVP_get_digestbyname(*digest);
  if (UNLIKELY(params->digest == nullptr)) {
    THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
    return Nothing<bool>();
  }

  ArrayBufferOrViewContents<char> data(args[offset + 1]);
  if (UNLIKELY(!data.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""data is too big"");
    return Nothing<bool>();
  }
  params->in = mode == kCryptoJobAsync
      ? data.ToCopy()
      : data.ToByteSource();

  unsigned int expected = EVP_MD_size(params->digest);
  params->length = expected;
  if (UNLIKELY(args[offset + 2]->IsUint32())) {
    // length is expressed in terms of bits
  ...",1,1,crypto\crypto_hash.cc,node.crypto.HashTraits.AdditionalConfig,,false,234,276,AdditionalConfig,,,15,"Maybe<bool> node.crypto.HashTraits.AdditionalConfig (CryptoJobMode,FunctionCallbackInfo<Value>,unsigned int,HashConfig*)"
42069,METHOD,crypto\crypto_hash.cc:<global>,TYPE_DECL,"bool HashTraits::DeriveBits(
    Environment* env,
    const HashConfig& params,
    ByteSource* out) {
  EVPMDPointer ctx(EVP_MD_CTX_new());

  if (UNLIKELY(!ctx ||
               EVP_DigestInit_ex(ctx.get(), params.digest, nullptr) <= 0 ||
               EVP_DigestUpdate(
                   ctx.get(), params.in.data<char>(), params.in.size()) <= 0)) {
    return false;
  }

  if (LIKELY(params.length > 0)) {
    unsigned int length = params.length;
    ByteSource::Builder buf(length);

    size_t expected = EVP_MD_CTX_size(ctx.get());

    int ret =
        (length == expected)
            ? EVP_DigestFinal_ex(ctx.get(), buf.data<unsigned char>(), &length)
            : EVP_DigestFinalXOF(ctx.get(), buf.data<unsigned char>(), length);

    if (UNLIKELY(ret != 1))
      return false;

    *out = std::move(buf).release();
  }

  return true;
}",1,1,crypto\crypto_hash.cc,node.crypto.HashTraits.DeriveBits,,false,278,309,DeriveBits,,,16,"bool node.crypto.HashTraits.DeriveBits (Environment*,HashConfig,ByteSource*)"
42207,METHOD,crypto\crypto_hash.hpp:<global>,TYPE_DECL,<global>,1,36,crypto\crypto_hash.hpp,crypto\crypto_hash.hpp:<global>,,false,1,89,<global>,,,1,
42228,METHOD,crypto\crypto_hkdf.cc:<global>,TYPE_DECL,<global>,1,36,crypto\crypto_hkdf.hpp,crypto\crypto_hkdf.cc:<global>,,false,1,167,<global>,,,1,
42232,METHOD,crypto\crypto_hkdf.cc:<global>,TYPE_DECL,"HKDFConfig::HKDFConfig(HKDFConfig&& other) noexcept
    : mode(other.mode),
      length(other.length),
      digest(other.digest),
      key(other.key),
      salt(std::move(other.salt)),
      info(std::move(other.info)) {}",1,36,crypto\crypto_hkdf.cc,node.crypto.HKDFConfig.HKDFConfig,,false,20,26,HKDFConfig,,,1,ANY node.crypto.HKDFConfig.HKDFConfig (HKDFConfig)
42237,METHOD,crypto\crypto_hkdf.cc:<global>,TYPE_DECL,"HKDFConfig& HKDFConfig::operator=(HKDFConfig&& other) noexcept {
  if (&other == this) return *this;
  this->~HKDFConfig();
  return *new (this) HKDFConfig(std::move(other));
}",1,1,crypto\crypto_hkdf.cc,node.crypto.HKDFConfig.operator =,,false,28,32,operator =,,,2,HKDFConfig node.crypto.HKDFConfig.operator = (HKDFConfig)
42265,METHOD,crypto\crypto_hkdf.cc:<global>,TYPE_DECL,"Maybe<bool> HKDFTraits::EncodeOutput(
    Environment* env,
    const HKDFConfig& params,
    ByteSource* out,
    v8::Local<v8::Value>* result) {
  *result = out->ToArrayBuffer(env);
  return Just(!result->IsEmpty());
}",1,1,crypto\crypto_hkdf.cc,node.crypto.HKDFTraits.EncodeOutput,,false,34,41,EncodeOutput,,,3,"Maybe<bool> node.crypto.HKDFTraits.EncodeOutput (Environment*,HKDFConfig,ByteSource*,ANY*)"
42288,METHOD,crypto\crypto_hkdf.cc:<global>,TYPE_DECL,"Maybe<bool> HKDFTraits::AdditionalConfig(
    CryptoJobMode mode,
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset,
    HKDFConfig* params) {
  Environment* env = Environment::GetCurrent(args);

  params->mode = mode;

  CHECK(args[offset]->IsString());  // Hash
  CHECK(args[offset + 1]->IsObject());  // Key
  CHECK(IsAnyByteSource(args[offset + 2]));  // Salt
  CHECK(IsAnyByteSource(args[offset + 3]));  // Info
  CHECK(args[offset + 4]->IsUint32());  // Length

  Utf8Value hash(env->isolate(), args[offset]);
  params->digest = EVP_get_digestbyname(*hash);
  if (params->digest == nullptr) {
    THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *hash);
    return Nothing<bool>();
  }

  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args[offset + 1], Nothing<bool>());
  params->key = key->Data();

  ArrayBufferOrViewContents<char> salt(args[offset + 2]);
  ArrayBufferOrViewContents<char> info(args[offset + 3]);

  if (UNLIKELY(!salt.CheckSizeInt32(...",1,1,crypto\crypto_hkdf.cc,node.crypto.HKDFTraits.AdditionalConfig,,false,43,101,AdditionalConfig,,,4,"Maybe<bool> node.crypto.HKDFTraits.AdditionalConfig (CryptoJobMode,FunctionCallbackInfo<Value>,unsigned int,HKDFConfig*)"
42510,METHOD,crypto\crypto_hkdf.cc:<global>,TYPE_DECL,"bool HKDFTraits::DeriveBits(
    Environment* env,
    const HKDFConfig& params,
    ByteSource* out) {
  EVPKeyCtxPointer ctx =
      EVPKeyCtxPointer(EVP_PKEY_CTX_new_id(EVP_PKEY_HKDF, nullptr));
  if (!ctx || !EVP_PKEY_derive_init(ctx.get()) ||
      !EVP_PKEY_CTX_set_hkdf_md(ctx.get(), params.digest) ||
      !EVP_PKEY_CTX_add1_hkdf_info(
          ctx.get(), params.info.data<unsigned char>(), params.info.size())) {
    return false;
  }

  // TODO(panva): Once support for OpenSSL 1.1.1 is dropped the whole
  // of HKDFTraits::DeriveBits can be refactored to use
  // EVP_KDF which does handle zero length key.

  std::string_view salt;
  if (params.salt.size() != 0) {
    salt = {params.salt.data<char>(), params.salt.size()};
  } else {
    static const char default_salt[EVP_MAX_MD_SIZE] = {0};
    salt = {default_salt, static_cast<unsigned>(EVP_MD_size(params.digest))};
  }

  // We do not use EVP_PKEY_HKDEF_MODE_EXTRACT_AND_EXPAND and instead implement
  // the extraction step ...",1,1,crypto\crypto_hkdf.cc,node.crypto.HKDFTraits.DeriveBits,,false,103,155,DeriveBits,,,5,"bool node.crypto.HKDFTraits.DeriveBits (Environment*,HKDFConfig,ByteSource*)"
42688,METHOD,crypto\crypto_hkdf.cc:<global>,TYPE_DECL,"void HKDFConfig::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""key"", key);
  // If the job is sync, then the HKDFConfig does not own the data
  if (mode == kCryptoJobAsync) {
    tracker->TrackFieldWithSize(""salt"", salt.size());
    tracker->TrackFieldWithSize(""info"", info.size());
  }
}",1,1,crypto\crypto_hkdf.cc,node.crypto.HKDFConfig.MemoryInfo,,false,157,164,MemoryInfo,,,6,void node.crypto.HKDFConfig.MemoryInfo (MemoryTracker*)
42735,METHOD,crypto\crypto_hkdf.hpp:<global>,TYPE_DECL,<global>,1,36,crypto\crypto_hkdf.hpp,crypto\crypto_hkdf.hpp:<global>,,false,1,63,<global>,,,1,
42738,METHOD,crypto\crypto_hmac.cc:<global>,TYPE_DECL,"[](Hmac* hmac, const FunctionCallbackInfo<Value>& args,
                        const char* data, size_t size) {
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    bool r = hmac->HmacUpdate(data, size);
    args.GetReturnValue().Set(r);
  }",22,3,crypto\crypto_hmac.cc,"args, [](Hmac* hmac, const FunctionCallbackInfo<Value>& args, const char* data, size_t size) { Environment* env = Environment.GetCurrent(args); if (UNLIKELY(size > INT_MAX)) return THROW_ERR_OUT_OF_RANGE(env, ""data is too long""); bool r = hmac->HmacUpdate(data, size); args.GetReturnValue().Set(r); }.<lambda>0",,false,103,110,<lambda>0,,,1,"ANY args, [](Hmac* hmac, const FunctionCallbackInfo<Value>& args, const char* data, size_t size) { Environment* env = Environment.GetCurrent(args); if (UNLIKELY(size > INT_MAX)) return THROW_ERR_OUT_OF_RANGE(env, ""data is too long""); bool r = hmac->HmacUpdate(data, size); args.GetReturnValue().Set(r); }.<lambda>0 (Hmac*,FunctionCallbackInfo<Value>,char*,size_t)"
42809,METHOD,crypto\crypto_hmac.cc:<global>,TYPE_DECL,<global>,1,36,crypto\crypto_hmac.hpp,crypto\crypto_hmac.cc:<global>,,false,1,280,<global>,,,1,
42813,METHOD,crypto\crypto_hmac.cc:<global>,TYPE_DECL,"Hmac::Hmac(Environment* env, Local<Object> wrap)
    : BaseObject(env, wrap),
      ctx_(nullptr) {
  MakeWeak();
}",1,1,crypto\crypto_hmac.cc,node.crypto.Hmac.Hmac,,false,31,35,Hmac,,,1,"ANY node.crypto.Hmac.Hmac (Environment*,Local<Object>)"
42820,METHOD,crypto\crypto_hmac.cc:<global>,TYPE_DECL,"void Hmac::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackFieldWithSize(""context"", ctx_ ? kSizeOf_HMAC_CTX : 0);
}",1,1,crypto\crypto_hmac.cc,node.crypto.Hmac.MemoryInfo,,false,37,39,MemoryInfo,,,2,void node.crypto.Hmac.MemoryInfo (MemoryTracker*)
42834,METHOD,crypto\crypto_hmac.cc:<global>,TYPE_DECL,"void Hmac::Initialize(Environment* env, Local<Object> target) {
  Isolate* isolate = env->isolate();
  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);

  t->InstanceTemplate()->SetInternalFieldCount(Hmac::kInternalFieldCount);

  SetProtoMethod(isolate, t, ""init"", HmacInit);
  SetProtoMethod(isolate, t, ""update"", HmacUpdate);
  SetProtoMethod(isolate, t, ""digest"", HmacDigest);

  SetConstructorFunction(env->context(), target, ""Hmac"", t);

  HmacJob::Initialize(env, target);
}",1,1,crypto\crypto_hmac.cc,node.crypto.Hmac.Initialize,,false,41,54,Initialize,,,3,"void node.crypto.Hmac.Initialize (Environment*,Local<Object>)"
42895,METHOD,crypto\crypto_hmac.cc:<global>,TYPE_DECL,"void Hmac::RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(New);
  registry->Register(HmacInit);
  registry->Register(HmacUpdate);
  registry->Register(HmacDigest);
  HmacJob::RegisterExternalReferences(registry);
}",1,1,crypto\crypto_hmac.cc,node.crypto.Hmac.RegisterExternalReferences,,false,56,62,RegisterExternalReferences,,,4,void node.crypto.Hmac.RegisterExternalReferences (ExternalReferenceRegistry*)
42925,METHOD,crypto\crypto_hmac.cc:<global>,TYPE_DECL,"void Hmac::New(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  new Hmac(env, args.This());
}",1,1,crypto\crypto_hmac.cc,node.crypto.Hmac.New,,false,64,67,New,,,5,void node.crypto.Hmac.New (FunctionCallbackInfo<Value>)
42945,METHOD,crypto\crypto_hmac.cc:<global>,TYPE_DECL,"void Hmac::HmacInit(const char* hash_type, const char* key, int key_len) {
  HandleScope scope(env()->isolate());

  const EVP_MD* md = EVP_get_digestbyname(hash_type);
  if (md == nullptr)
    return THROW_ERR_CRYPTO_INVALID_DIGEST(
        env(), ""Invalid digest: %s"", hash_type);
  if (key_len == 0) {
    key = """";
  }
  ctx_.reset(HMAC_CTX_new());
  if (!ctx_ || !HMAC_Init_ex(ctx_.get(), key, key_len, md, nullptr)) {
    ctx_.reset();
    return ThrowCryptoError(env(), ERR_get_error());
  }
}",1,1,crypto\crypto_hmac.cc,node.crypto.Hmac.HmacInit,,false,69,84,HmacInit,,,6,"void node.crypto.Hmac.HmacInit (char*,char*,int)"
43009,METHOD,crypto\crypto_hmac.cc:<global>,TYPE_DECL,"void Hmac::HmacInit(const FunctionCallbackInfo<Value>& args) {
  Hmac* hmac;
  ASSIGN_OR_RETURN_UNWRAP(&hmac, args.Holder());
  Environment* env = hmac->env();

  const node::Utf8Value hash_type(env->isolate(), args[0]);
  ByteSource key = ByteSource::FromSecretKeyBytes(env, args[1]);
  hmac->HmacInit(*hash_type, key.data<char>(), key.size());
}",1,1,crypto\crypto_hmac.cc,node.crypto.Hmac.HmacInit,,false,86,94,HmacInit,,,7,void node.crypto.Hmac.HmacInit (FunctionCallbackInfo<Value>)
43063,METHOD,crypto\crypto_hmac.cc:<global>,TYPE_DECL,"bool Hmac::HmacUpdate(const char* data, size_t len) {
  return ctx_ && HMAC_Update(ctx_.get(),
                             reinterpret_cast<const unsigned char*>(data),
                             len) == 1;
}",1,1,crypto\crypto_hmac.cc,node.crypto.Hmac.HmacUpdate,,false,96,100,HmacUpdate,,,8,"bool node.crypto.Hmac.HmacUpdate (char*,size_t)"
43083,METHOD,crypto\crypto_hmac.cc:<global>,TYPE_DECL,"void Hmac::HmacUpdate(const FunctionCallbackInfo<Value>& args) {
  Decode<Hmac>(args, [](Hmac* hmac, const FunctionCallbackInfo<Value>& args,
                        const char* data, size_t size) {
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    bool r = hmac->HmacUpdate(data, size);
    args.GetReturnValue().Set(r);
  });
}",1,1,crypto\crypto_hmac.cc,node.crypto.Hmac.HmacUpdate,,false,102,111,HmacUpdate,,,9,void node.crypto.Hmac.HmacUpdate (FunctionCallbackInfo<Value>)
43095,METHOD,crypto\crypto_hmac.cc:<global>,TYPE_DECL,"void Hmac::HmacDigest(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  Hmac* hmac;
  ASSIGN_OR_RETURN_UNWRAP(&hmac, args.Holder());

  enum encoding encoding = BUFFER;
  if (args.Length() >= 1) {
    encoding = ParseEncoding(env->isolate(), args[0], BUFFER);
  }

  unsigned char md_value[EVP_MAX_MD_SIZE];
  unsigned int md_len = 0;

  if (hmac->ctx_) {
    bool ok = HMAC_Final(hmac->ctx_.get(), md_value, &md_len);
    hmac->ctx_.reset();
    if (!ok) {
      return ThrowCryptoError(env, ERR_get_error(), ""Failed to finalize HMAC"");
    }
  }

  Local<Value> error;
  MaybeLocal<Value> rc =
      StringBytes::Encode(env->isolate(),
                          reinterpret_cast<const char*>(md_value),
                          md_len,
                          encoding,
                          &error);
  if (rc.IsEmpty()) {
    CHECK(!error.IsEmpty());
    env->isolate()->ThrowException(error);
    return;
  }
  args.GetReturnValue().Set(r...",1,1,crypto\crypto_hmac.cc,node.crypto.Hmac.HmacDigest,,false,113,148,HmacDigest,,,10,void node.crypto.Hmac.HmacDigest (FunctionCallbackInfo<Value>)
43236,METHOD,crypto\crypto_hmac.cc:<global>,TYPE_DECL,"HmacConfig::HmacConfig(HmacConfig&& other) noexcept
    : job_mode(other.job_mode),
      mode(other.mode),
      key(std::move(other.key)),
      data(std::move(other.data)),
      signature(std::move(other.signature)),
      digest(other.digest) {}",1,29,crypto\crypto_hmac.cc,node.crypto.HmacConfig.HmacConfig,,false,150,156,HmacConfig,,,11,ANY node.crypto.HmacConfig.HmacConfig (HmacConfig)
43241,METHOD,crypto\crypto_hmac.cc:<global>,TYPE_DECL,"HmacConfig& HmacConfig::operator=(HmacConfig&& other) noexcept {
  if (&other == this) return *this;
  this->~HmacConfig();
  return *new (this) HmacConfig(std::move(other));
}",1,1,crypto\crypto_hmac.cc,node.crypto.HmacConfig.operator =,,false,158,162,operator =,,,12,HmacConfig node.crypto.HmacConfig.operator = (HmacConfig)
43269,METHOD,crypto\crypto_hmac.cc:<global>,TYPE_DECL,"void HmacConfig::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""key"", key.get());
  // If the job is sync, then the HmacConfig does not own the data
  if (job_mode == kCryptoJobAsync) {
    tracker->TrackFieldWithSize(""data"", data.size());
    tracker->TrackFieldWithSize(""signature"", signature.size());
  }
}",1,1,crypto\crypto_hmac.cc,node.crypto.HmacConfig.MemoryInfo,,false,164,171,MemoryInfo,,,13,void node.crypto.HmacConfig.MemoryInfo (MemoryTracker*)
43306,METHOD,crypto\crypto_hmac.cc:<global>,TYPE_DECL,"Maybe<bool> HmacTraits::AdditionalConfig(
    CryptoJobMode mode,
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset,
    HmacConfig* params) {
  Environment* env = Environment::GetCurrent(args);

  params->job_mode = mode;

  CHECK(args[offset]->IsUint32());  // SignConfiguration::Mode
  params->mode =
    static_cast<SignConfiguration::Mode>(args[offset].As<Uint32>()->Value());

  CHECK(args[offset + 1]->IsString());  // Hash
  CHECK(args[offset + 2]->IsObject());  // Key

  Utf8Value digest(env->isolate(), args[offset + 1]);
  params->digest = EVP_get_digestbyname(*digest);
  if (params->digest == nullptr) {
    THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
    return Nothing<bool>();
  }

  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args[offset + 2], Nothing<bool>());
  params->key = key->Data();

  ArrayBufferOrViewContents<char> data(args[offset + 3]);
  if (UNLIKELY(!data.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ...",1,1,crypto\crypto_hmac.cc,node.crypto.HmacTraits.AdditionalConfig,,false,173,221,AdditionalConfig,,,14,"Maybe<bool> node.crypto.HmacTraits.AdditionalConfig (CryptoJobMode,FunctionCallbackInfo<Value>,unsigned int,HmacConfig*)"
43503,METHOD,crypto\crypto_hmac.cc:<global>,TYPE_DECL,"bool HmacTraits::DeriveBits(
    Environment* env,
    const HmacConfig& params,
    ByteSource* out) {
  HMACCtxPointer ctx(HMAC_CTX_new());

  if (!ctx ||
      !HMAC_Init_ex(
          ctx.get(),
          params.key->GetSymmetricKey(),
          params.key->GetSymmetricKeySize(),
          params.digest,
          nullptr)) {
    return false;
  }

  if (!HMAC_Update(
          ctx.get(),
          params.data.data<unsigned char>(),
          params.data.size())) {
    return false;
  }

  ByteSource::Builder buf(EVP_MAX_MD_SIZE);
  unsigned int len;

  if (!HMAC_Final(ctx.get(), buf.data<unsigned char>(), &len)) {
    return false;
  }

  *out = std::move(buf).release(len);

  return true;
}",1,1,crypto\crypto_hmac.cc,node.crypto.HmacTraits.DeriveBits,,false,223,256,DeriveBits,,,15,"bool node.crypto.HmacTraits.DeriveBits (Environment*,HmacConfig,ByteSource*)"
43598,METHOD,crypto\crypto_hmac.cc:<global>,TYPE_DECL,"Maybe<bool> HmacTraits::EncodeOutput(
    Environment* env,
    const HmacConfig& params,
    ByteSource* out,
    Local<Value>* result) {
  switch (params.mode) {
    case SignConfiguration::kSign:
      *result = out->ToArrayBuffer(env);
      break;
    case SignConfiguration::kVerify:
      *result = Boolean::New(
          env->isolate(),
          out->size() > 0 && out->size() == params.signature.size() &&
              memcmp(out->data(), params.signature.data(), out->size()) == 0);
      break;
    default:
      UNREACHABLE();
  }
  return Just(!result->IsEmpty());
}",1,1,crypto\crypto_hmac.cc,node.crypto.HmacTraits.EncodeOutput,,false,258,277,EncodeOutput,,,16,"Maybe<bool> node.crypto.HmacTraits.EncodeOutput (Environment*,HmacConfig,ByteSource*,Local<Value>*)"
43702,METHOD,crypto\crypto_hmac.hpp:<global>,TYPE_DECL,<global>,1,36,crypto\crypto_hmac.hpp,crypto\crypto_hmac.hpp:<global>,,false,1,94,<global>,,,1,
43725,METHOD,crypto\crypto_keygen.cc:<global>,TYPE_DECL,<global>,1,39,crypto\crypto_keygen.hpp,crypto\crypto_keygen.cc:<global>,,false,1,101,<global>,,,1,
43729,METHOD,crypto\crypto_keygen.cc:<global>,TYPE_DECL,"Maybe<bool> NidKeyPairGenTraits::AdditionalConfig(
    CryptoJobMode mode,
    const FunctionCallbackInfo<Value>& args,
    unsigned int* offset,
    NidKeyPairGenConfig* params) {
  CHECK(args[*offset]->IsInt32());
  params->params.id = args[*offset].As<Int32>()->Value();

  *offset += 1;

  return Just(true);
}",1,1,crypto\crypto_keygen.cc,node.crypto.NidKeyPairGenTraits.AdditionalConfig,,false,33,44,AdditionalConfig,,,1,"Maybe<bool> node.crypto.NidKeyPairGenTraits.AdditionalConfig (CryptoJobMode,FunctionCallbackInfo<Value>,unsigned int*,NidKeyPairGenConfig*)"
43768,METHOD,crypto\crypto_keygen.cc:<global>,TYPE_DECL,"EVPKeyCtxPointer NidKeyPairGenTraits::Setup(NidKeyPairGenConfig* params) {
  EVPKeyCtxPointer ctx =
      EVPKeyCtxPointer(EVP_PKEY_CTX_new_id(params->params.id, nullptr));
  if (!ctx || EVP_PKEY_keygen_init(ctx.get()) <= 0)
    return EVPKeyCtxPointer();

  return ctx;
}",1,1,crypto\crypto_keygen.cc,node.crypto.NidKeyPairGenTraits.Setup,,false,46,53,Setup,,,2,EVPKeyCtxPointer node.crypto.NidKeyPairGenTraits.Setup (NidKeyPairGenConfig*)
43800,METHOD,crypto\crypto_keygen.cc:<global>,TYPE_DECL,"void SecretKeyGenConfig::MemoryInfo(MemoryTracker* tracker) const {
  if (out) tracker->TrackFieldWithSize(""out"", length);
}",1,1,crypto\crypto_keygen.cc,node.crypto.SecretKeyGenConfig.MemoryInfo,,false,55,57,MemoryInfo,,,3,void node.crypto.SecretKeyGenConfig.MemoryInfo (MemoryTracker*)
43814,METHOD,crypto\crypto_keygen.cc:<global>,TYPE_DECL,"Maybe<bool> SecretKeyGenTraits::AdditionalConfig(
    CryptoJobMode mode,
    const FunctionCallbackInfo<Value>& args,
    unsigned int* offset,
    SecretKeyGenConfig* params) {
  CHECK(args[*offset]->IsUint32());
  uint32_t bits = args[*offset].As<Uint32>()->Value();
  params->length = bits / CHAR_BIT;
  *offset += 1;
  return Just(true);
}",1,1,crypto\crypto_keygen.cc,node.crypto.SecretKeyGenTraits.AdditionalConfig,,false,59,69,AdditionalConfig,,,4,"Maybe<bool> node.crypto.SecretKeyGenTraits.AdditionalConfig (CryptoJobMode,FunctionCallbackInfo<Value>,unsigned int*,SecretKeyGenConfig*)"
43857,METHOD,crypto\crypto_keygen.cc:<global>,TYPE_DECL,"KeyGenJobStatus SecretKeyGenTraits::DoKeyGen(Environment* env,
                                             SecretKeyGenConfig* params) {
  ByteSource::Builder bytes(params->length);
  if (CSPRNG(bytes.data<unsigned char>(), params->length).is_err())
    return KeyGenJobStatus::FAILED;
  params->out = std::move(bytes).release();
  return KeyGenJobStatus::OK;
}",1,1,crypto\crypto_keygen.cc,node.crypto.SecretKeyGenTraits.DoKeyGen,,false,71,78,DoKeyGen,,,5,"KeyGenJobStatus node.crypto.SecretKeyGenTraits.DoKeyGen (Environment*,SecretKeyGenConfig*)"
43901,METHOD,crypto\crypto_keygen.cc:<global>,TYPE_DECL,"Maybe<bool> SecretKeyGenTraits::EncodeKey(Environment* env,
                                          SecretKeyGenConfig* params,
                                          Local<Value>* result) {
  std::shared_ptr<KeyObjectData> data =
      KeyObjectData::CreateSecret(std::move(params->out));
  return Just(KeyObjectHandle::Create(env, data).ToLocal(result));
}",1,1,crypto\crypto_keygen.cc,node.crypto.SecretKeyGenTraits.EncodeKey,,false,80,86,EncodeKey,,,6,"Maybe<bool> node.crypto.SecretKeyGenTraits.EncodeKey (Environment*,SecretKeyGenConfig*,Local<Value>*)"
43940,METHOD,crypto\crypto_keygen.cc:<global>,TYPE_DECL,"void Initialize(Environment* env, Local<Object> target) {
  NidKeyPairGenJob::Initialize(env, target);
  SecretKeyGenJob::Initialize(env, target);
}",1,1,crypto\crypto_keygen.cc,node.crypto.Keygen.Initialize,,false,89,92,Initialize,,,1,"void node.crypto.Keygen.Initialize (Environment*,Local<Object>)"
43958,METHOD,crypto\crypto_keygen.cc:<global>,TYPE_DECL,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  NidKeyPairGenJob::RegisterExternalReferences(registry);
  SecretKeyGenJob::RegisterExternalReferences(registry);
}",1,1,crypto\crypto_keygen.cc,node.crypto.Keygen.RegisterExternalReferences,,false,94,97,RegisterExternalReferences,,,2,void node.crypto.Keygen.RegisterExternalReferences (ExternalReferenceRegistry*)
43990,METHOD,crypto\crypto_keygen.hpp:<global>,TYPE_DECL,<global>,1,39,crypto\crypto_keygen.hpp,crypto\crypto_keygen.hpp:<global>,,false,1,297,<global>,,,1,
43993,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"[](const unsigned char** p, long l) {  // NOLINT(runtime/int)
        return d2i_PUBKEY(nullptr, p, l);
      }",7,7,crypto\crypto_keys.cc,node.crypto.anonymous_namespace_4.ParsePublicKeyPEM.<lambda>0,,false,115,117,<lambda>0,,,1,"ANY node.crypto.anonymous_namespace_4.ParsePublicKeyPEM.<lambda>0 (unsigned char**,long)"
44006,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"[](const unsigned char** p, long l) {  // NOLINT(runtime/int)
        return d2i_PublicKey(EVP_PKEY_RSA, nullptr, p, l);
      }",7,7,crypto\crypto_keys.cc,node.crypto.anonymous_namespace_5.ParsePublicKeyPEM.<lambda>1,,false,124,126,<lambda>1,,,1,"ANY node.crypto.anonymous_namespace_5.ParsePublicKeyPEM.<lambda>1 (unsigned char**,long)"
44019,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"[](const unsigned char** p, long l) {  // NOLINT(runtime/int)
        X509Pointer x509(d2i_X509(nullptr, p, l));
        return x509 ? X509_get_pubkey(x509.get()) : nullptr;
      }",7,7,crypto\crypto_keys.cc,node.crypto.anonymous_namespace_6.ParsePublicKeyPEM.<lambda>2,,false,133,136,<lambda>2,,,1,"ANY node.crypto.anonymous_namespace_6.ParsePublicKeyPEM.<lambda>2 (unsigned char**,long)"
44076,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,<global>,1,36,crypto\crypto_keys.hpp,crypto\crypto_keys.cc:<global>,,false,1,1483,<global>,,,1,
44081,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"void GetKeyFormatAndTypeFromJs(
    AsymmetricKeyEncodingConfig* config,
    const FunctionCallbackInfo<Value>& args,
    unsigned int* offset,
    KeyEncodingContext context) {
  // During key pair generation, it is possible not to specify a key encoding,
  // which will lead to a key object being returned.
  if (args[*offset]->IsUndefined()) {
    CHECK_EQ(context, kKeyContextGenerate);
    CHECK(args[*offset + 1]->IsUndefined());
    config->output_key_object_ = true;
  } else {
    config->output_key_object_ = false;

    CHECK(args[*offset]->IsInt32());
    config->format_ = static_cast<PKFormatType>(
        args[*offset].As<Int32>()->Value());

    if (args[*offset + 1]->IsInt32()) {
      config->type_ = Just<PKEncodingType>(static_cast<PKEncodingType>(
          args[*offset + 1].As<Int32>()->Value()));
    } else {
      CHECK(
          (context == kKeyContextInput &&
           config->format_ == kKeyFormatPEM) ||
          (context == kKeyContextGenerate &&
           c...",1,1,crypto\crypto_keys.cc,node.crypto.anonymous_namespace_1.GetKeyFormatAndTypeFromJs,,false,43,76,GetKeyFormatAndTypeFromJs,,,1,"void node.crypto.anonymous_namespace_1.GetKeyFormatAndTypeFromJs (AsymmetricKeyEncodingConfig*,FunctionCallbackInfo<Value>,unsigned int*,KeyEncodingContext)"
44221,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"ParseKeyResult TryParsePublicKey(
    EVPKeyPointer* pkey,
    const BIOPointer& bp,
    const char* name,
    // NOLINTNEXTLINE(runtime/int)
    const std::function<EVP_PKEY*(const unsigned char** p, long l)>& parse) {
  unsigned char* der_data;
  long der_len;  // NOLINT(runtime/int)

  // This skips surrounding data and decodes PEM to DER.
  {
    MarkPopErrorOnReturn mark_pop_error_on_return;
    if (PEM_bytes_read_bio(&der_data, &der_len, nullptr, name,
                           bp.get(), nullptr, nullptr) != 1)
      return ParseKeyResult::kParseKeyNotRecognized;
  }

  // OpenSSL might modify the pointer, so we need to make a copy before parsing.
  const unsigned char* p = der_data;
  pkey->reset(parse(&p, der_len));
  OPENSSL_clear_free(der_data, der_len);

  return *pkey ? ParseKeyResult::kParseKeyOk :
                 ParseKeyResult::kParseKeyFailed;
}",1,1,crypto\crypto_keys.cc,node.crypto.anonymous_namespace_2.TryParsePublicKey,,false,78,102,TryParsePublicKey,,,2,"ParseKeyResult node.crypto.anonymous_namespace_2.TryParsePublicKey (EVPKeyPointer*,BIOPointer,char*,ANY)"
44279,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"ParseKeyResult ParsePublicKeyPEM(EVPKeyPointer* pkey,
                                 const char* key_pem,
                                 int key_pem_len) {
  BIOPointer bp(BIO_new_mem_buf(const_cast<char*>(key_pem), key_pem_len));
  if (!bp)
    return ParseKeyResult::kParseKeyFailed;

  ParseKeyResult ret;

  // Try parsing as a SubjectPublicKeyInfo first.
  ret = TryParsePublicKey(pkey, bp, ""PUBLIC KEY"",
      [](const unsigned char** p, long l) {  // NOLINT(runtime/int)
        return d2i_PUBKEY(nullptr, p, l);
      });
  if (ret != ParseKeyResult::kParseKeyNotRecognized)
    return ret;

  // Maybe it is PKCS#1.
  CHECK(BIO_reset(bp.get()));
  ret = TryParsePublicKey(pkey, bp, ""RSA PUBLIC KEY"",
      [](const unsigned char** p, long l) {  // NOLINT(runtime/int)
        return d2i_PublicKey(EVP_PKEY_RSA, nullptr, p, l);
      });
  if (ret != ParseKeyResult::kParseKeyNotRecognized)
    return ret;

  // X.509 fallback.
  CHECK(BIO_reset(bp.get()));
  return TryParsePublicKey...",1,1,crypto\crypto_keys.cc,node.crypto.anonymous_namespace_3.ParsePublicKeyPEM,,false,104,137,ParsePublicKeyPEM,,,3,"ParseKeyResult node.crypto.anonymous_namespace_3.ParsePublicKeyPEM (EVPKeyPointer*,char*,int)"
44352,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"ParseKeyResult ParsePublicKey(EVPKeyPointer* pkey,
                              const PublicKeyEncodingConfig& config,
                              const char* key,
                              size_t key_len) {
  if (config.format_ == kKeyFormatPEM) {
    return ParsePublicKeyPEM(pkey, key, key_len);
  } else {
    CHECK_EQ(config.format_, kKeyFormatDER);

    const unsigned char* p = reinterpret_cast<const unsigned char*>(key);
    if (config.type_.ToChecked() == kKeyEncodingPKCS1) {
      pkey->reset(d2i_PublicKey(EVP_PKEY_RSA, nullptr, &p, key_len));
    } else {
      CHECK_EQ(config.type_.ToChecked(), kKeyEncodingSPKI);
      pkey->reset(d2i_PUBKEY(nullptr, &p, key_len));
    }

    return *pkey ? ParseKeyResult::kParseKeyOk :
                   ParseKeyResult::kParseKeyFailed;
  }
}",1,1,crypto\crypto_keys.cc,node.crypto.anonymous_namespace_7.ParsePublicKey,,false,139,159,ParsePublicKey,,,4,"ParseKeyResult node.crypto.anonymous_namespace_7.ParsePublicKey (EVPKeyPointer*,PublicKeyEncodingConfig,char*,size_t)"
44434,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"bool IsASN1Sequence(const unsigned char* data, size_t size,
                    size_t* data_offset, size_t* data_size) {
  if (size < 2 || data[0] != 0x30)
    return false;

  if (data[1] & 0x80) {
    // Long form.
    size_t n_bytes = data[1] & ~0x80;
    if (n_bytes + 2 > size || n_bytes > sizeof(size_t))
      return false;
    size_t length = 0;
    for (size_t i = 0; i < n_bytes; i++)
      length = (length << 8) | data[i + 2];
    *data_offset = 2 + n_bytes;
    *data_size = std::min(size - 2 - n_bytes, length);
  } else {
    // Short form.
    *data_offset = 2;
    *data_size = std::min<size_t>(size - 2, data[1]);
  }

  return true;
}",1,1,crypto\crypto_keys.cc,node.crypto.anonymous_namespace_8.IsASN1Sequence,,false,161,183,IsASN1Sequence,,,5,"bool node.crypto.anonymous_namespace_8.IsASN1Sequence (unsigned char*,size_t,size_t*,size_t*)"
44555,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"bool IsRSAPrivateKey(const unsigned char* data, size_t size) {
  // Both RSAPrivateKey and RSAPublicKey structures start with a SEQUENCE.
  size_t offset, len;
  if (!IsASN1Sequence(data, size, &offset, &len))
    return false;

  // An RSAPrivateKey sequence always starts with a single-byte integer whose
  // value is either 0 or 1, whereas an RSAPublicKey starts with the modulus
  // (which is the product of two primes and therefore at least 4), so we can
  // decide the type of the structure based on the first three bytes of the
  // sequence.
  return len >= 3 &&
         data[offset] == 2 &&
         data[offset + 1] == 1 &&
         !(data[offset + 2] & 0xfe);
}",1,1,crypto\crypto_keys.cc,node.crypto.anonymous_namespace_9.IsRSAPrivateKey,,false,185,200,IsRSAPrivateKey,,,6,"bool node.crypto.anonymous_namespace_9.IsRSAPrivateKey (unsigned char*,size_t)"
44602,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"bool IsEncryptedPrivateKeyInfo(const unsigned char* data, size_t size) {
  // Both PrivateKeyInfo and EncryptedPrivateKeyInfo start with a SEQUENCE.
  size_t offset, len;
  if (!IsASN1Sequence(data, size, &offset, &len))
    return false;

  // A PrivateKeyInfo sequence always starts with an integer whereas an
  // EncryptedPrivateKeyInfo starts with an AlgorithmIdentifier.
  return len >= 1 &&
         data[offset] != 2;
}",1,1,crypto\crypto_keys.cc,node.crypto.anonymous_namespace_11.IsEncryptedPrivateKeyInfo,,false,202,212,IsEncryptedPrivateKeyInfo,,,7,"bool node.crypto.anonymous_namespace_11.IsEncryptedPrivateKeyInfo (unsigned char*,size_t)"
44632,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"ParseKeyResult ParsePrivateKey(EVPKeyPointer* pkey,
                               const PrivateKeyEncodingConfig& config,
                               const char* key,
                               size_t key_len) {
  const ByteSource* passphrase = config.passphrase_.get();

  if (config.format_ == kKeyFormatPEM) {
    BIOPointer bio(BIO_new_mem_buf(key, key_len));
    if (!bio)
      return ParseKeyResult::kParseKeyFailed;

    pkey->reset(PEM_read_bio_PrivateKey(bio.get(),
                                        nullptr,
                                        PasswordCallback,
                                        &passphrase));
  } else {
    CHECK_EQ(config.format_, kKeyFormatDER);

    if (config.type_.ToChecked() == kKeyEncodingPKCS1) {
      const unsigned char* p = reinterpret_cast<const unsigned char*>(key);
      pkey->reset(d2i_PrivateKey(EVP_PKEY_RSA, nullptr, &p, key_len));
    } else if (config.type_.ToChecked() == kKeyEncodingPKCS8) {
      BIOPointer bio(BIO_n...",1,1,crypto\crypto_keys.cc,node.crypto.anonymous_namespace_13.ParsePrivateKey,,false,214,271,ParsePrivateKey,,,8,"ParseKeyResult node.crypto.anonymous_namespace_13.ParsePrivateKey (EVPKeyPointer*,PrivateKeyEncodingConfig,char*,size_t)"
44856,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"MaybeLocal<Value> BIOToStringOrBuffer(
    Environment* env,
    BIO* bio,
    PKFormatType format) {
  BUF_MEM* bptr;
  BIO_get_mem_ptr(bio, &bptr);
  if (format == kKeyFormatPEM) {
    // PEM is an ASCII format, so we will return it as a string.
    return String::NewFromUtf8(env->isolate(), bptr->data,
                               NewStringType::kNormal,
                               bptr->length).FromMaybe(Local<Value>());
  } else {
    CHECK_EQ(format, kKeyFormatDER);
    // DER is binary, return it as a buffer.
    return Buffer::Copy(env, bptr->data, bptr->length)
        .FromMaybe(Local<Value>());
  }
}",1,1,crypto\crypto_keys.cc,node.crypto.anonymous_namespace_15.BIOToStringOrBuffer,,false,273,290,BIOToStringOrBuffer,,,9,"MaybeLocal<Value> node.crypto.anonymous_namespace_15.BIOToStringOrBuffer (Environment*,BIO*,PKFormatType)"
44916,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"MaybeLocal<Value> WritePrivateKey(
    Environment* env,
    EVP_PKEY* pkey,
    const PrivateKeyEncodingConfig& config) {
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);

  // If an empty string was passed as the passphrase, the ByteSource might
  // contain a null pointer, which OpenSSL will ignore, causing it to invoke its
  // default passphrase callback, which would block the thread until the user
  // manually enters a passphrase. We could supply our own passphrase callback
  // to handle this special case, but it is easier to avoid passing a null
  // pointer to OpenSSL.
  char* pass = nullptr;
  size_t pass_len = 0;
  if (!config.passphrase_.IsEmpty()) {
    pass = const_cast<char*>(config.passphrase_->data<char>());
    pass_len = config.passphrase_->size();
    if (pass == nullptr) {
      // OpenSSL will not actually dereference this pointer, so it can be any
      // non-null pointer. We cannot assert that directly, which is why we
      // intentionally use a poin...",1,1,crypto\crypto_keys.cc,node.crypto.anonymous_namespace_16.WritePrivateKey,,false,293,392,WritePrivateKey,,,10,"MaybeLocal<Value> node.crypto.anonymous_namespace_16.WritePrivateKey (Environment*,EVP_PKEY*,PrivateKeyEncodingConfig)"
44921,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,BIOPointer bio(BIO_new(BIO_s_mem()));,14,38,crypto\crypto_keys.cc,node.crypto.anonymous_namespace_17.WritePrivateKey.bio,,false,297,297,bio,,,1,BIOPointer node.crypto.anonymous_namespace_17.WritePrivateKey.bio (BIO_new)
45199,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"bool WritePublicKeyInner(EVP_PKEY* pkey,
                         const BIOPointer& bio,
                         const PublicKeyEncodingConfig& config) {
  if (config.type_.ToChecked() == kKeyEncodingPKCS1) {
    // PKCS#1 is only valid for RSA keys.
    CHECK_EQ(EVP_PKEY_id(pkey), EVP_PKEY_RSA);
    RSAPointer rsa(EVP_PKEY_get1_RSA(pkey));
    if (config.format_ == kKeyFormatPEM) {
      // Encode PKCS#1 as PEM.
      return PEM_write_bio_RSAPublicKey(bio.get(), rsa.get()) == 1;
    } else {
      // Encode PKCS#1 as DER.
      CHECK_EQ(config.format_, kKeyFormatDER);
      return i2d_RSAPublicKey_bio(bio.get(), rsa.get()) == 1;
    }
  } else {
    CHECK_EQ(config.type_.ToChecked(), kKeyEncodingSPKI);
    if (config.format_ == kKeyFormatPEM) {
      // Encode SPKI as PEM.
      return PEM_write_bio_PUBKEY(bio.get(), pkey) == 1;
    } else {
      // Encode SPKI as DER.
      CHECK_EQ(config.format_, kKeyFormatDER);
      return i2d_PUBKEY_bio(bio.get(), pkey) == 1;
    }
  }
}",1,1,crypto\crypto_keys.cc,node.crypto.anonymous_namespace_18.WritePublicKeyInner,,false,394,420,WritePublicKeyInner,,,11,"bool node.crypto.anonymous_namespace_18.WritePublicKeyInner (EVP_PKEY*,BIOPointer,PublicKeyEncodingConfig)"
45304,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"MaybeLocal<Value> WritePublicKey(Environment* env,
                                 EVP_PKEY* pkey,
                                 const PublicKeyEncodingConfig& config) {
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);

  if (!WritePublicKeyInner(pkey, bio, config)) {
    ThrowCryptoError(env, ERR_get_error(), ""Failed to encode public key"");
    return MaybeLocal<Value>();
  }
  return BIOToStringOrBuffer(env, bio.get(), config.format_);
}",1,1,crypto\crypto_keys.cc,node.crypto.anonymous_namespace_19.WritePublicKey,,false,422,433,WritePublicKey,,,12,"MaybeLocal<Value> node.crypto.anonymous_namespace_19.WritePublicKey (Environment*,EVP_PKEY*,PublicKeyEncodingConfig)"
45309,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,BIOPointer bio(BIO_new(BIO_s_mem()));,14,38,crypto\crypto_keys.cc,node.crypto.anonymous_namespace_20.WritePublicKey.bio,,false,425,425,bio,,,1,BIOPointer node.crypto.anonymous_namespace_20.WritePublicKey.bio (BIO_new)
45341,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"Maybe<bool> ExportJWKSecretKey(
    Environment* env,
    std::shared_ptr<KeyObjectData> key,
    Local<Object> target) {
  CHECK_EQ(key->GetKeyType(), kKeyTypeSecret);

  Local<Value> error;
  Local<Value> raw;
  MaybeLocal<Value> key_data =
      StringBytes::Encode(
          env->isolate(),
          key->GetSymmetricKey(),
          key->GetSymmetricKeySize(),
          BASE64URL,
          &error);
  if (key_data.IsEmpty()) {
    CHECK(!error.IsEmpty());
    env->isolate()->ThrowException(error);
    return Nothing<bool>();
  }
  if (!key_data.ToLocal(&raw))
    return Nothing<bool>();

  if (target->Set(
          env->context(),
          env->jwk_kty_string(),
          env->jwk_oct_string()).IsNothing() ||
      target->Set(
          env->context(),
          env->jwk_k_string(),
          raw).IsNothing()) {
    return Nothing<bool>();
  }

  return Just(true);
}",1,1,crypto\crypto_keys.cc,node.crypto.anonymous_namespace_21.ExportJWKSecretKey,,false,435,470,ExportJWKSecretKey,,,13,"Maybe<bool> node.crypto.anonymous_namespace_21.ExportJWKSecretKey (Environment*,ANY,Local<Object>)"
45465,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"std::shared_ptr<KeyObjectData> ImportJWKSecretKey(
    Environment* env,
    Local<Object> jwk) {
  Local<Value> key;
  if (!jwk->Get(env->context(), env->jwk_k_string()).ToLocal(&key) ||
      !key->IsString()) {
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK secret key format"");
    return std::shared_ptr<KeyObjectData>();
  }

  static_assert(String::kMaxLength <= INT_MAX);
  ByteSource key_data = ByteSource::FromEncodedString(env, key.As<String>());
  return KeyObjectData::CreateSecret(std::move(key_data));
}",1,1,crypto\crypto_keys.cc,node.crypto.anonymous_namespace_22.ImportJWKSecretKey,,false,472,485,ImportJWKSecretKey,,,14,"shared_ptr<KeyObjectData> node.crypto.anonymous_namespace_22.ImportJWKSecretKey (Environment*,Local<Object>)"
45538,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"Maybe<bool> ExportJWKAsymmetricKey(
    Environment* env,
    std::shared_ptr<KeyObjectData> key,
    Local<Object> target,
    bool handleRsaPss) {
  switch (EVP_PKEY_id(key->GetAsymmetricKey().get())) {
    case EVP_PKEY_RSA_PSS: {
      if (handleRsaPss) return ExportJWKRsaKey(env, key, target);
      break;
    }
    case EVP_PKEY_RSA: return ExportJWKRsaKey(env, key, target);
    case EVP_PKEY_EC: return ExportJWKEcKey(env, key, target).IsJust() ?
                               Just(true) : Nothing<bool>();
    case EVP_PKEY_ED25519:
      // Fall through
    case EVP_PKEY_ED448:
      // Fall through
    case EVP_PKEY_X25519:
      // Fall through
    case EVP_PKEY_X448: return ExportJWKEdKey(env, key, target);
  }
  THROW_ERR_CRYPTO_JWK_UNSUPPORTED_KEY_TYPE(env);
  return Just(false);
}",1,1,crypto\crypto_keys.cc,node.crypto.anonymous_namespace_23.ExportJWKAsymmetricKey,,false,487,510,ExportJWKAsymmetricKey,,,15,"Maybe<bool> node.crypto.anonymous_namespace_23.ExportJWKAsymmetricKey (Environment*,ANY,Local<Object>,bool)"
45607,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"std::shared_ptr<KeyObjectData> ImportJWKAsymmetricKey(
    Environment* env,
    Local<Object> jwk,
    const char* kty,
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset) {
  if (strcmp(kty, ""RSA"") == 0) {
    return ImportJWKRsaKey(env, jwk, args, offset);
  } else if (strcmp(kty, ""EC"") == 0) {
    return ImportJWKEcKey(env, jwk, args, offset);
  }

  THROW_ERR_CRYPTO_INVALID_JWK(env, ""%s is not a supported JWK key type"", kty);
  return std::shared_ptr<KeyObjectData>();
}",1,1,crypto\crypto_keys.cc,node.crypto.anonymous_namespace_24.ImportJWKAsymmetricKey,,false,512,526,ImportJWKAsymmetricKey,,,16,"shared_ptr<KeyObjectData> node.crypto.anonymous_namespace_24.ImportJWKAsymmetricKey (Environment*,Local<Object>,char*,FunctionCallbackInfo<Value>,unsigned int)"
45653,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"Maybe<bool> GetSecretKeyDetail(
    Environment* env,
    std::shared_ptr<KeyObjectData> key,
    Local<Object> target) {
  // For the secret key detail, all we care about is the length,
  // converted to bits.

  size_t length = key->GetSymmetricKeySize() * CHAR_BIT;
  return target->Set(env->context(),
                     env->length_string(),
                     Number::New(env->isolate(), static_cast<double>(length)));
}",1,1,crypto\crypto_keys.cc,node.crypto.anonymous_namespace_25.GetSecretKeyDetail,,false,528,539,GetSecretKeyDetail,,,17,"Maybe<bool> node.crypto.anonymous_namespace_25.GetSecretKeyDetail (Environment*,ANY,Local<Object>)"
45693,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"Maybe<bool> GetAsymmetricKeyDetail(
  Environment* env,
  std::shared_ptr<KeyObjectData> key,
  Local<Object> target) {
  switch (EVP_PKEY_id(key->GetAsymmetricKey().get())) {
    case EVP_PKEY_RSA:
      // Fall through
    case EVP_PKEY_RSA_PSS: return GetRsaKeyDetail(env, key, target);
    case EVP_PKEY_DSA: return GetDsaKeyDetail(env, key, target);
    case EVP_PKEY_EC: return GetEcKeyDetail(env, key, target);
    case EVP_PKEY_DH: return GetDhKeyDetail(env, key, target);
  }
  THROW_ERR_CRYPTO_INVALID_KEYTYPE(env);
  return Nothing<bool>();
}",1,1,crypto\crypto_keys.cc,node.crypto.anonymous_namespace_26.GetAsymmetricKeyDetail,,false,541,555,GetAsymmetricKeyDetail,,,18,"Maybe<bool> node.crypto.anonymous_namespace_26.GetAsymmetricKeyDetail (Environment*,ANY,Local<Object>)"
45744,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"ManagedEVPPKey::ManagedEVPPKey(EVPKeyPointer&& pkey) : pkey_(std::move(pkey)),
    mutex_(std::make_shared<Mutex>()) {}",1,40,crypto\crypto_keys.cc,node.crypto.ManagedEVPPKey.ManagedEVPPKey,,false,558,559,ManagedEVPPKey,,,2,ANY node.crypto.ManagedEVPPKey.ManagedEVPPKey (EVPKeyPointer)
45749,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"ManagedEVPPKey::ManagedEVPPKey(const ManagedEVPPKey& that) {
  *this = that;
}",1,1,crypto\crypto_keys.cc,node.crypto.ManagedEVPPKey.ManagedEVPPKey,,false,561,563,ManagedEVPPKey,,,3,ANY node.crypto.ManagedEVPPKey.ManagedEVPPKey (ManagedEVPPKey)
45758,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"ManagedEVPPKey& ManagedEVPPKey::operator=(const ManagedEVPPKey& that) {
  Mutex::ScopedLock lock(*that.mutex_);

  pkey_.reset(that.get());

  if (pkey_)
    EVP_PKEY_up_ref(pkey_.get());

  mutex_ = that.mutex_;

  return *this;
}",1,1,crypto\crypto_keys.cc,node.crypto.ManagedEVPPKey.operator =,,false,565,576,operator =,,,4,ManagedEVPPKey node.crypto.ManagedEVPPKey.operator = (ManagedEVPPKey)
45793,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"ManagedEVPPKey::operator bool() const {
  return !!pkey_;
}",1,1,crypto\crypto_keys.cc,node.crypto.ManagedEVPPKey.operator bool,,false,578,580,operator bool,,,5,ANY node.crypto.ManagedEVPPKey.operator bool ()
45801,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"EVP_PKEY* ManagedEVPPKey::get() const {
  return pkey_.get();
}",1,1,crypto\crypto_keys.cc,node.crypto.ManagedEVPPKey.get,,false,582,584,get,,,6,EVP_PKEY node.crypto.ManagedEVPPKey.get ()
45810,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"Mutex* ManagedEVPPKey::mutex() const {
  return mutex_.get();
}",1,1,crypto\crypto_keys.cc,node.crypto.ManagedEVPPKey.mutex,,false,586,588,mutex,,,7,Mutex node.crypto.ManagedEVPPKey.mutex ()
45819,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"void ManagedEVPPKey::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackFieldWithSize(""pkey"",
                              !pkey_ ? 0 : kSizeOf_EVP_PKEY +
                              size_of_private_key() +
                              size_of_public_key());
}",1,1,crypto\crypto_keys.cc,node.crypto.ManagedEVPPKey.MemoryInfo,,false,590,595,MemoryInfo,,,8,void node.crypto.ManagedEVPPKey.MemoryInfo (MemoryTracker*)
45838,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"size_t ManagedEVPPKey::size_of_private_key() const {
  size_t len = 0;
  return (pkey_ && EVP_PKEY_get_raw_private_key(
      pkey_.get(), nullptr, &len) == 1) ? len : 0;
}",1,1,crypto\crypto_keys.cc,node.crypto.ManagedEVPPKey.size_of_private_key,,false,597,601,size_of_private_key,,,9,size_t node.crypto.ManagedEVPPKey.size_of_private_key ()
45862,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"size_t ManagedEVPPKey::size_of_public_key() const {
  size_t len = 0;
  return (pkey_ && EVP_PKEY_get_raw_public_key(
      pkey_.get(), nullptr, &len) == 1) ? len : 0;
}",1,1,crypto\crypto_keys.cc,node.crypto.ManagedEVPPKey.size_of_public_key,,false,603,607,size_of_public_key,,,10,size_t node.crypto.ManagedEVPPKey.size_of_public_key ()
45886,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"static inline Maybe<bool> Tristate(bool b) {
  return b ? Just(true) : Nothing<bool>();
}",1,1,crypto\crypto_keys.cc,node.crypto.Tristate,,false,610,612,Tristate,,,11,Maybe<bool> node.crypto.Tristate (bool)
45897,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"Maybe<bool> ExportJWKInner(Environment* env,
                           std::shared_ptr<KeyObjectData> key,
                           Local<Value> result,
                           bool handleRsaPss) {
  switch (key->GetKeyType()) {
    case kKeyTypeSecret:
      return ExportJWKSecretKey(env, key, result.As<Object>());
    case kKeyTypePublic:
      // Fall through
    case kKeyTypePrivate:
      return ExportJWKAsymmetricKey(
        env, key, result.As<Object>(), handleRsaPss);
    default:
      UNREACHABLE();
  }
}",1,1,crypto\crypto_keys.cc,node.crypto.ExportJWKInner,,false,614,629,ExportJWKInner,,,12,"Maybe<bool> node.crypto.ExportJWKInner (Environment*,ANY,Local<Value>,bool)"
45936,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"Maybe<bool> ManagedEVPPKey::ToEncodedPublicKey(
    Environment* env,
    const PublicKeyEncodingConfig& config,
    Local<Value>* out) {
  if (!*this) return Nothing<bool>();
  if (config.output_key_object_) {
    // Note that this has the downside of containing sensitive data of the
    // private key.
    std::shared_ptr<KeyObjectData> data =
        KeyObjectData::CreateAsymmetric(kKeyTypePublic, *this);
    return Tristate(KeyObjectHandle::Create(env, data).ToLocal(out));
  } else if (config.format_ == kKeyFormatJWK) {
    std::shared_ptr<KeyObjectData> data =
        KeyObjectData::CreateAsymmetric(kKeyTypePublic, *this);
    *out = Object::New(env->isolate());
    return ExportJWKInner(env, data, *out, false);
  }

  return Tristate(WritePublicKey(env, get(), config).ToLocal(out));
}",1,1,crypto\crypto_keys.cc,node.crypto.ManagedEVPPKey.ToEncodedPublicKey,,false,631,650,ToEncodedPublicKey,,,13,"Maybe<bool> node.crypto.ManagedEVPPKey.ToEncodedPublicKey (Environment*,PublicKeyEncodingConfig,Local<Value>*)"
46034,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"Maybe<bool> ManagedEVPPKey::ToEncodedPrivateKey(
    Environment* env,
    const PrivateKeyEncodingConfig& config,
    Local<Value>* out) {
  if (!*this) return Nothing<bool>();
  if (config.output_key_object_) {
    std::shared_ptr<KeyObjectData> data =
        KeyObjectData::CreateAsymmetric(kKeyTypePrivate, *this);
    return Tristate(KeyObjectHandle::Create(env, data).ToLocal(out));
  } else if (config.format_ == kKeyFormatJWK) {
    std::shared_ptr<KeyObjectData> data =
        KeyObjectData::CreateAsymmetric(kKeyTypePrivate, *this);
    *out = Object::New(env->isolate());
    return ExportJWKInner(env, data, *out, false);
  }

  return Tristate(WritePrivateKey(env, get(), config).ToLocal(out));
}",1,1,crypto\crypto_keys.cc,node.crypto.ManagedEVPPKey.ToEncodedPrivateKey,,false,652,669,ToEncodedPrivateKey,,,14,"Maybe<bool> node.crypto.ManagedEVPPKey.ToEncodedPrivateKey (Environment*,PrivateKeyEncodingConfig,Local<Value>*)"
46132,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"NonCopyableMaybe<PrivateKeyEncodingConfig>
ManagedEVPPKey::GetPrivateKeyEncodingFromJs(
    const FunctionCallbackInfo<Value>& args,
    unsigned int* offset,
    KeyEncodingContext context) {
  Environment* env = Environment::GetCurrent(args);

  PrivateKeyEncodingConfig result;
  GetKeyFormatAndTypeFromJs(&result, args, offset, context);

  if (result.output_key_object_) {
    if (context != kKeyContextInput)
      (*offset)++;
  } else {
    bool needs_passphrase = false;
    if (context != kKeyContextInput) {
      if (args[*offset]->IsString()) {
        Utf8Value cipher_name(env->isolate(), args[*offset]);
        result.cipher_ = EVP_get_cipherbyname(*cipher_name);
        if (result.cipher_ == nullptr) {
          THROW_ERR_CRYPTO_UNKNOWN_CIPHER(env);
          return NonCopyableMaybe<PrivateKeyEncodingConfig>();
        }
        needs_passphrase = true;
      } else {
        CHECK(args[*offset]->IsNullOrUndefined());
        result.cipher_ = nullptr;
      }
      (*offse...",1,1,crypto\crypto_keys.cc,node.crypto.ManagedEVPPKey.GetPrivateKeyEncodingFromJs,,false,671,718,GetPrivateKeyEncodingFromJs,,,15,"NonCopyableMaybe<PrivateKeyEncodingConfig> node.crypto.ManagedEVPPKey.GetPrivateKeyEncodingFromJs (FunctionCallbackInfo<Value>,unsigned int*,KeyEncodingContext)"
46309,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"PublicKeyEncodingConfig ManagedEVPPKey::GetPublicKeyEncodingFromJs(
    const FunctionCallbackInfo<Value>& args,
    unsigned int* offset,
    KeyEncodingContext context) {
  PublicKeyEncodingConfig result;
  GetKeyFormatAndTypeFromJs(&result, args, offset, context);
  return result;
}",1,1,crypto\crypto_keys.cc,node.crypto.ManagedEVPPKey.GetPublicKeyEncodingFromJs,,false,720,727,GetPublicKeyEncodingFromJs,,,16,"PublicKeyEncodingConfig node.crypto.ManagedEVPPKey.GetPublicKeyEncodingFromJs (FunctionCallbackInfo<Value>,unsigned int*,KeyEncodingContext)"
46325,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"ManagedEVPPKey ManagedEVPPKey::GetPrivateKeyFromJs(
    const FunctionCallbackInfo<Value>& args,
    unsigned int* offset,
    bool allow_key_object) {
  if (args[*offset]->IsString() || IsAnyByteSource(args[*offset])) {
    Environment* env = Environment::GetCurrent(args);
    ByteSource key = ByteSource::FromStringOrBuffer(env, args[(*offset)++]);
    NonCopyableMaybe<PrivateKeyEncodingConfig> config =
        GetPrivateKeyEncodingFromJs(args, offset, kKeyContextInput);
    if (config.IsEmpty())
      return ManagedEVPPKey();

    EVPKeyPointer pkey;
    ParseKeyResult ret =
        ParsePrivateKey(&pkey, config.Release(), key.data<char>(), key.size());
    return GetParsedKey(env, std::move(pkey), ret,
                        ""Failed to read private key"");
  } else {
    CHECK(args[*offset]->IsObject() && allow_key_object);
    KeyObjectHandle* key;
    ASSIGN_OR_RETURN_UNWRAP(&key, args[*offset].As<Object>(), ManagedEVPPKey());
    CHECK_EQ(key->Data()->GetKeyType(), kKeyTypePri...",1,1,crypto\crypto_keys.cc,node.crypto.ManagedEVPPKey.GetPrivateKeyFromJs,,false,729,754,GetPrivateKeyFromJs,,,17,"ManagedEVPPKey node.crypto.ManagedEVPPKey.GetPrivateKeyFromJs (FunctionCallbackInfo<Value>,unsigned int*,bool)"
46460,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"ManagedEVPPKey ManagedEVPPKey::GetPublicOrPrivateKeyFromJs(
    const FunctionCallbackInfo<Value>& args,
    unsigned int* offset) {
  if (IsAnyByteSource(args[*offset])) {
    Environment* env = Environment::GetCurrent(args);
    ArrayBufferOrViewContents<char> data(args[(*offset)++]);
    if (UNLIKELY(!data.CheckSizeInt32())) {
      THROW_ERR_OUT_OF_RANGE(env, ""keyData is too big"");
      return ManagedEVPPKey();
    }
    NonCopyableMaybe<PrivateKeyEncodingConfig> config_ =
        GetPrivateKeyEncodingFromJs(args, offset, kKeyContextInput);
    if (config_.IsEmpty())
      return ManagedEVPPKey();

    ParseKeyResult ret;
    PrivateKeyEncodingConfig config = config_.Release();
    EVPKeyPointer pkey;
    if (config.format_ == kKeyFormatPEM) {
      // For PEM, we can easily determine whether it is a public or private key
      // by looking for the respective PEM tags.
      ret = ParsePublicKeyPEM(&pkey, data.data(), data.size());
      if (ret == ParseKeyResult::kParseKeyNot...",1,1,crypto\crypto_keys.cc,node.crypto.ManagedEVPPKey.GetPublicOrPrivateKeyFromJs,,false,756,818,GetPublicOrPrivateKeyFromJs,,,18,"ManagedEVPPKey node.crypto.ManagedEVPPKey.GetPublicOrPrivateKeyFromJs (FunctionCallbackInfo<Value>,unsigned int*)"
46707,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"ManagedEVPPKey ManagedEVPPKey::GetParsedKey(Environment* env,
                                            EVPKeyPointer&& pkey,
                                            ParseKeyResult ret,
                                            const char* default_msg) {
  switch (ret) {
    case ParseKeyResult::kParseKeyOk:
      CHECK(pkey);
      break;
    case ParseKeyResult::kParseKeyNeedPassphrase:
      THROW_ERR_MISSING_PASSPHRASE(env,
                                   ""Passphrase required for encrypted key"");
      break;
    default:
      ThrowCryptoError(env, ERR_get_error(), default_msg);
  }

  return ManagedEVPPKey(std::move(pkey));
}",1,1,crypto\crypto_keys.cc,node.crypto.ManagedEVPPKey.GetParsedKey,,false,820,837,GetParsedKey,,,19,"ManagedEVPPKey node.crypto.ManagedEVPPKey.GetParsedKey (Environment*,EVPKeyPointer,ParseKeyResult,char*)"
46745,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"KeyObjectData::KeyObjectData(ByteSource symmetric_key)
    : key_type_(KeyType::kKeyTypeSecret),
      symmetric_key_(std::move(symmetric_key)),
      asymmetric_key_() {}",1,26,crypto\crypto_keys.cc,node.crypto.KeyObjectData.KeyObjectData,,false,839,842,KeyObjectData,,,20,ANY node.crypto.KeyObjectData.KeyObjectData (ByteSource)
46750,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"KeyObjectData::KeyObjectData(KeyType type, const ManagedEVPPKey& pkey)
    : key_type_(type), symmetric_key_(), asymmetric_key_{pkey} {}",1,65,crypto\crypto_keys.cc,node.crypto.KeyObjectData.KeyObjectData,,false,844,845,KeyObjectData,,,21,"ANY node.crypto.KeyObjectData.KeyObjectData (KeyType,ManagedEVPPKey)"
46756,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"void KeyObjectData::MemoryInfo(MemoryTracker* tracker) const {
  switch (GetKeyType()) {
    case kKeyTypeSecret:
      tracker->TrackFieldWithSize(""symmetric_key"", symmetric_key_.size());
      break;
    case kKeyTypePrivate:
      // Fall through
    case kKeyTypePublic:
      tracker->TrackFieldWithSize(""key"", asymmetric_key_);
      break;
    default:
      UNREACHABLE();
  }
}",1,1,crypto\crypto_keys.cc,node.crypto.KeyObjectData.MemoryInfo,,false,847,860,MemoryInfo,,,22,void node.crypto.KeyObjectData.MemoryInfo (MemoryTracker*)
46789,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"std::shared_ptr<KeyObjectData> KeyObjectData::CreateSecret(ByteSource key) {
  return std::shared_ptr<KeyObjectData>(new KeyObjectData(std::move(key)));
}",1,1,crypto\crypto_keys.cc,node.crypto.KeyObjectData.CreateSecret,,false,862,864,CreateSecret,,,23,shared_ptr<KeyObjectData> node.crypto.KeyObjectData.CreateSecret (ByteSource)
46808,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"std::shared_ptr<KeyObjectData> KeyObjectData::CreateAsymmetric(
    KeyType key_type,
    const ManagedEVPPKey& pkey) {
  CHECK(pkey);
  return std::shared_ptr<KeyObjectData>(new KeyObjectData(key_type, pkey));
}",1,1,crypto\crypto_keys.cc,node.crypto.KeyObjectData.CreateAsymmetric,,false,866,871,CreateAsymmetric,,,24,"shared_ptr<KeyObjectData> node.crypto.KeyObjectData.CreateAsymmetric (KeyType,ManagedEVPPKey)"
46827,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"KeyType KeyObjectData::GetKeyType() const {
  return key_type_;
}",1,1,crypto\crypto_keys.cc,node.crypto.KeyObjectData.GetKeyType,,false,873,875,GetKeyType,,,25,KeyType node.crypto.KeyObjectData.GetKeyType ()
46833,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"ManagedEVPPKey KeyObjectData::GetAsymmetricKey() const {
  CHECK_NE(key_type_, kKeyTypeSecret);
  return asymmetric_key_;
}",1,1,crypto\crypto_keys.cc,node.crypto.KeyObjectData.GetAsymmetricKey,,false,877,880,GetAsymmetricKey,,,26,ManagedEVPPKey node.crypto.KeyObjectData.GetAsymmetricKey ()
46842,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"const char* KeyObjectData::GetSymmetricKey() const {
  CHECK_EQ(key_type_, kKeyTypeSecret);
  return symmetric_key_.data<char>();
}",1,1,crypto\crypto_keys.cc,node.crypto.KeyObjectData.GetSymmetricKey,,false,882,885,GetSymmetricKey,,,27,const char* node.crypto.KeyObjectData.GetSymmetricKey ()
46854,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"size_t KeyObjectData::GetSymmetricKeySize() const {
  CHECK_EQ(key_type_, kKeyTypeSecret);
  return symmetric_key_.size();
}",1,1,crypto\crypto_keys.cc,node.crypto.KeyObjectData.GetSymmetricKeySize,,false,887,890,GetSymmetricKeySize,,,28,size_t node.crypto.KeyObjectData.GetSymmetricKeySize ()
46866,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"bool KeyObjectHandle::HasInstance(Environment* env, Local<Value> value) {
  Local<FunctionTemplate> t = env->crypto_key_object_handle_constructor();
  return !t.IsEmpty() && t->HasInstance(value);
}",1,1,crypto\crypto_keys.cc,node.crypto.KeyObjectHandle.HasInstance,,false,892,895,HasInstance,,,29,"bool node.crypto.KeyObjectHandle.HasInstance (Environment*,Local<Value>)"
46894,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"v8::Local<v8::Function> KeyObjectHandle::Initialize(Environment* env) {
  Local<FunctionTemplate> templ = env->crypto_key_object_handle_constructor();
  if (templ.IsEmpty()) {
    Isolate* isolate = env->isolate();
    templ = NewFunctionTemplate(isolate, New);
    templ->InstanceTemplate()->SetInternalFieldCount(
        KeyObjectHandle::kInternalFieldCount);

    SetProtoMethod(isolate, templ, ""init"", Init);
    SetProtoMethodNoSideEffect(
        isolate, templ, ""getSymmetricKeySize"", GetSymmetricKeySize);
    SetProtoMethodNoSideEffect(
        isolate, templ, ""getAsymmetricKeyType"", GetAsymmetricKeyType);
    SetProtoMethod(isolate, templ, ""export"", Export);
    SetProtoMethod(isolate, templ, ""exportJwk"", ExportJWK);
    SetProtoMethod(isolate, templ, ""initECRaw"", InitECRaw);
    SetProtoMethod(isolate, templ, ""initEDRaw"", InitEDRaw);
    SetProtoMethod(isolate, templ, ""initJwk"", InitJWK);
    SetProtoMethod(isolate, templ, ""keyDetail"", GetKeyDetail);
    SetProtoMethod(isolate...",1,1,crypto\crypto_keys.cc,node.crypto.KeyObjectHandle.Initialize,,false,897,921,Initialize,,,30,Local<v8::Function> node.crypto.KeyObjectHandle.Initialize (Environment*)
47004,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"void KeyObjectHandle::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(New);
  registry->Register(Init);
  registry->Register(GetSymmetricKeySize);
  registry->Register(GetAsymmetricKeyType);
  registry->Register(Export);
  registry->Register(ExportJWK);
  registry->Register(InitECRaw);
  registry->Register(InitEDRaw);
  registry->Register(InitJWK);
  registry->Register(GetKeyDetail);
  registry->Register(Equals);
}",1,1,crypto\crypto_keys.cc,node.crypto.KeyObjectHandle.RegisterExternalReferences,,false,923,936,RegisterExternalReferences,,,31,void node.crypto.KeyObjectHandle.RegisterExternalReferences (ExternalReferenceRegistry*)
47064,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"MaybeLocal<Object> KeyObjectHandle::Create(
    Environment* env,
    std::shared_ptr<KeyObjectData> data) {
  Local<Object> obj;
  Local<Function> ctor = KeyObjectHandle::Initialize(env);
  CHECK(!env->crypto_key_object_handle_constructor().IsEmpty());
  if (!ctor->NewInstance(env->context(), 0, nullptr).ToLocal(&obj))
    return MaybeLocal<Object>();

  KeyObjectHandle* key = Unwrap<KeyObjectHandle>(obj);
  CHECK_NOT_NULL(key);
  key->data_ = data;
  return obj;
}",1,1,crypto\crypto_keys.cc,node.crypto.KeyObjectHandle.Create,,false,938,951,Create,,,32,"MaybeLocal<Object> node.crypto.KeyObjectHandle.Create (Environment*,ANY)"
47132,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"const std::shared_ptr<KeyObjectData>& KeyObjectHandle::Data() {
  return data_;
}",1,1,crypto\crypto_keys.cc,node.crypto.KeyObjectHandle.Data,,false,953,955,Data,,,33,shared_ptr<KeyObjectData> node.crypto.KeyObjectHandle.Data ()
47138,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"void KeyObjectHandle::New(const FunctionCallbackInfo<Value>& args) {
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new KeyObjectHandle(env, args.This());
}",1,1,crypto\crypto_keys.cc,node.crypto.KeyObjectHandle.New,,false,957,961,New,,,34,void node.crypto.KeyObjectHandle.New (FunctionCallbackInfo<Value>)
47163,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"KeyObjectHandle::KeyObjectHandle(Environment* env,
                                 Local<Object> wrap)
    : BaseObject(env, wrap) {
  MakeWeak();
}",1,1,crypto\crypto_keys.cc,node.crypto.KeyObjectHandle.KeyObjectHandle,,false,963,967,KeyObjectHandle,,,35,"ANY node.crypto.KeyObjectHandle.KeyObjectHandle (Environment*,Local<Object>)"
47170,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"void KeyObjectHandle::Init(const FunctionCallbackInfo<Value>& args) {
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());
  MarkPopErrorOnReturn mark_pop_error_on_return;

  CHECK(args[0]->IsInt32());
  KeyType type = static_cast<KeyType>(args[0].As<Uint32>()->Value());

  unsigned int offset;
  ManagedEVPPKey pkey;

  switch (type) {
  case kKeyTypeSecret: {
    CHECK_EQ(args.Length(), 2);
    ArrayBufferOrViewContents<char> buf(args[1]);
    key->data_ = KeyObjectData::CreateSecret(buf.ToCopy());
    break;
  }
  case kKeyTypePublic: {
    CHECK_EQ(args.Length(), 5);

    offset = 1;
    pkey = ManagedEVPPKey::GetPublicOrPrivateKeyFromJs(args, &offset);
    if (!pkey)
      return;
    key->data_ = KeyObjectData::CreateAsymmetric(type, pkey);
    break;
  }
  case kKeyTypePrivate: {
    CHECK_EQ(args.Length(), 5);

    offset = 1;
    pkey = ManagedEVPPKey::GetPrivateKeyFromJs(args, &offset, false);
    if (!pkey)
      return;
    key->data_ = KeyObjectData::C...",1,1,crypto\crypto_keys.cc,node.crypto.KeyObjectHandle.Init,,false,969,1010,Init,,,36,void node.crypto.KeyObjectHandle.Init (FunctionCallbackInfo<Value>)
47314,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"void KeyObjectHandle::InitJWK(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());
  MarkPopErrorOnReturn mark_pop_error_on_return;

  // The argument must be a JavaScript object that we will inspect
  // to get the JWK properties from.
  CHECK(args[0]->IsObject());

  // Step one, Secret key or not?
  Local<Object> input = args[0].As<Object>();

  Local<Value> kty;
  if (!input->Get(env->context(), env->jwk_kty_string()).ToLocal(&kty) ||
      !kty->IsString()) {
    return THROW_ERR_CRYPTO_INVALID_JWK(env);
  }

  Utf8Value kty_string(env->isolate(), kty);

  if (strcmp(*kty_string, ""oct"") == 0) {
    // Secret key
    key->data_ = ImportJWKSecretKey(env, input);
    if (!key->data_) {
      // ImportJWKSecretKey is responsible for throwing an appropriate error
      return;
    }
  } else {
    key->data_ = ImportJWKAsymmetricKey(env, input, *kty_string, args, 1);
   ...",1,1,crypto\crypto_keys.cc,node.crypto.KeyObjectHandle.InitJWK,,false,1012,1049,InitJWK,,,37,void node.crypto.KeyObjectHandle.InitJWK (FunctionCallbackInfo<Value>)
47451,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"void KeyObjectHandle::InitECRaw(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());

  CHECK(args[0]->IsString());
  Utf8Value name(env->isolate(), args[0]);

  MarkPopErrorOnReturn mark_pop_error_on_return;

  int id = OBJ_txt2nid(*name);
  ECKeyPointer eckey(EC_KEY_new_by_curve_name(id));
  if (!eckey)
    return args.GetReturnValue().Set(false);

  const EC_GROUP* group = EC_KEY_get0_group(eckey.get());
  ECPointPointer pub(ECDH::BufferToPoint(env, group, args[1]));

  if (!pub ||
      !eckey ||
      !EC_KEY_set_public_key(eckey.get(), pub.get())) {
    return args.GetReturnValue().Set(false);
  }

  EVPKeyPointer pkey(EVP_PKEY_new());
  if (!EVP_PKEY_assign_EC_KEY(pkey.get(), eckey.get()))
    args.GetReturnValue().Set(false);

  eckey.release();  // Release ownership of the key

  key->data_ =
      KeyObjectData::CreateAsymmetric(
          kKeyTypePublic,
     ...",1,1,crypto\crypto_keys.cc,node.crypto.KeyObjectHandle.InitECRaw,,false,1051,1087,InitECRaw,,,38,void node.crypto.KeyObjectHandle.InitECRaw (FunctionCallbackInfo<Value>)
47608,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"void KeyObjectHandle::InitEDRaw(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());

  CHECK(args[0]->IsString());
  Utf8Value name(env->isolate(), args[0]);

  ArrayBufferOrViewContents<unsigned char> key_data(args[1]);
  KeyType type = static_cast<KeyType>(args[2].As<Int32>()->Value());

  MarkPopErrorOnReturn mark_pop_error_on_return;

  typedef EVP_PKEY* (*new_key_fn)(int, ENGINE*, const unsigned char*, size_t);
  new_key_fn fn = type == kKeyTypePrivate
      ? EVP_PKEY_new_raw_private_key
      : EVP_PKEY_new_raw_public_key;

  int id = GetOKPCurveFromName(*name);

  switch (id) {
    case EVP_PKEY_X25519:
    case EVP_PKEY_X448:
    case EVP_PKEY_ED25519:
    case EVP_PKEY_ED448: {
      EVPKeyPointer pkey(fn(id, nullptr, key_data.data(), key_data.size()));
      if (!pkey)
        return args.GetReturnValue().Set(false);
      key->data_ =
          KeyObjectData...",1,1,crypto\crypto_keys.cc,node.crypto.KeyObjectHandle.InitEDRaw,,false,1089,1129,InitEDRaw,,,39,void node.crypto.KeyObjectHandle.InitEDRaw (FunctionCallbackInfo<Value>)
47663,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"typedef EVP_PKEY* (*new_key_fn)(int, ENGINE*, const unsigned char*, size_t);",19,77,crypto\crypto_keys.cc,node.crypto.KeyObjectHandle.InitEDRaw.new_key_fn,,false,1102,1102,new_key_fn,,,13,"EVP_PKEY* node.crypto.KeyObjectHandle.InitEDRaw.new_key_fn (int,ENGINE*,unsigned char*,size_t)"
47756,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"void KeyObjectHandle::Equals(const FunctionCallbackInfo<Value>& args) {
  KeyObjectHandle* self_handle;
  KeyObjectHandle* arg_handle;
  ASSIGN_OR_RETURN_UNWRAP(&self_handle, args.Holder());
  ASSIGN_OR_RETURN_UNWRAP(&arg_handle, args[0].As<Object>());
  std::shared_ptr<KeyObjectData> key = self_handle->Data();
  std::shared_ptr<KeyObjectData> key2 = arg_handle->Data();

  KeyType key_type = key->GetKeyType();
  CHECK_EQ(key_type, key2->GetKeyType());

  bool ret;
  switch (key_type) {
    case kKeyTypeSecret: {
      size_t size = key->GetSymmetricKeySize();
      if (size == key2->GetSymmetricKeySize()) {
        ret = CRYPTO_memcmp(
          key->GetSymmetricKey(),
          key2->GetSymmetricKey(),
          size) == 0;
      } else {
        ret = false;
      }
      break;
    }
    case kKeyTypePublic:
    case kKeyTypePrivate: {
      EVP_PKEY* pkey = key->GetAsymmetricKey().get();
      EVP_PKEY* pkey2 = key2->GetAsymmetricKey().get();
#if OPENSSL_VERSION_MAJOR >= 3
     ...",1,1,crypto\crypto_keys.cc,node.crypto.KeyObjectHandle.Equals,,false,1131,1177,Equals,,,40,void node.crypto.KeyObjectHandle.Equals (FunctionCallbackInfo<Value>)
47923,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"void KeyObjectHandle::GetKeyDetail(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());

  CHECK(args[0]->IsObject());

  std::shared_ptr<KeyObjectData> data = key->Data();

  switch (data->GetKeyType()) {
    case kKeyTypeSecret:
      if (GetSecretKeyDetail(env, data, args[0].As<Object>()).IsNothing())
        return;
      break;
    case kKeyTypePublic:
      // Fall through
    case kKeyTypePrivate:
      if (GetAsymmetricKeyDetail(env, data, args[0].As<Object>()).IsNothing())
        return;
      break;
    default:
      UNREACHABLE();
  }

  args.GetReturnValue().Set(args[0]);
}",1,1,crypto\crypto_keys.cc,node.crypto.KeyObjectHandle.GetKeyDetail,,false,1179,1204,GetKeyDetail,,,41,void node.crypto.KeyObjectHandle.GetKeyDetail (FunctionCallbackInfo<Value>)
48019,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"Local<Value> KeyObjectHandle::GetAsymmetricKeyType() const {
  const ManagedEVPPKey& key = data_->GetAsymmetricKey();
  switch (EVP_PKEY_id(key.get())) {
  case EVP_PKEY_RSA:
    return env()->crypto_rsa_string();
  case EVP_PKEY_RSA_PSS:
    return env()->crypto_rsa_pss_string();
  case EVP_PKEY_DSA:
    return env()->crypto_dsa_string();
  case EVP_PKEY_DH:
    return env()->crypto_dh_string();
  case EVP_PKEY_EC:
    return env()->crypto_ec_string();
  case EVP_PKEY_ED25519:
    return env()->crypto_ed25519_string();
  case EVP_PKEY_ED448:
    return env()->crypto_ed448_string();
  case EVP_PKEY_X25519:
    return env()->crypto_x25519_string();
  case EVP_PKEY_X448:
    return env()->crypto_x448_string();
  default:
    return Undefined(env()->isolate());
  }
}",1,1,crypto\crypto_keys.cc,node.crypto.KeyObjectHandle.GetAsymmetricKeyType,,false,1206,1230,GetAsymmetricKeyType,,,42,Local<Value> node.crypto.KeyObjectHandle.GetAsymmetricKeyType ()
48107,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"void KeyObjectHandle::GetAsymmetricKeyType(
    const FunctionCallbackInfo<Value>& args) {
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());

  args.GetReturnValue().Set(key->GetAsymmetricKeyType());
}",1,1,crypto\crypto_keys.cc,node.crypto.KeyObjectHandle.GetAsymmetricKeyType,,false,1232,1238,GetAsymmetricKeyType,,,43,void node.crypto.KeyObjectHandle.GetAsymmetricKeyType (FunctionCallbackInfo<Value>)
48131,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"void KeyObjectHandle::GetSymmetricKeySize(
    const FunctionCallbackInfo<Value>& args) {
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());
  args.GetReturnValue().Set(
      static_cast<uint32_t>(key->Data()->GetSymmetricKeySize()));
}",1,1,crypto\crypto_keys.cc,node.crypto.KeyObjectHandle.GetSymmetricKeySize,,false,1240,1246,GetSymmetricKeySize,,,44,void node.crypto.KeyObjectHandle.GetSymmetricKeySize (FunctionCallbackInfo<Value>)
48160,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"void KeyObjectHandle::Export(const FunctionCallbackInfo<Value>& args) {
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());

  KeyType type = key->Data()->GetKeyType();

  MaybeLocal<Value> result;
  if (type == kKeyTypeSecret) {
    result = key->ExportSecretKey();
  } else if (type == kKeyTypePublic) {
    unsigned int offset = 0;
    PublicKeyEncodingConfig config =
        ManagedEVPPKey::GetPublicKeyEncodingFromJs(
            args, &offset, kKeyContextExport);
    CHECK_EQ(offset, static_cast<unsigned int>(args.Length()));
    result = key->ExportPublicKey(config);
  } else {
    CHECK_EQ(type, kKeyTypePrivate);
    unsigned int offset = 0;
    NonCopyableMaybe<PrivateKeyEncodingConfig> config =
        ManagedEVPPKey::GetPrivateKeyEncodingFromJs(
            args, &offset, kKeyContextExport);
    if (config.IsEmpty())
      return;
    CHECK_EQ(offset, static_cast<unsigned int>(args.Length()));
    result = key->ExportPrivateKey(config.Release());
  }

  i...",1,1,crypto\crypto_keys.cc,node.crypto.KeyObjectHandle.Export,,false,1248,1278,Export,,,45,void node.crypto.KeyObjectHandle.Export (FunctionCallbackInfo<Value>)
48303,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"MaybeLocal<Value> KeyObjectHandle::ExportSecretKey() const {
  const char* buf = data_->GetSymmetricKey();
  unsigned int len = data_->GetSymmetricKeySize();
  return Buffer::Copy(env(), buf, len).FromMaybe(Local<Value>());
}",1,1,crypto\crypto_keys.cc,node.crypto.KeyObjectHandle.ExportSecretKey,,false,1280,1284,ExportSecretKey,,,46,MaybeLocal<Value> node.crypto.KeyObjectHandle.ExportSecretKey ()
48333,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"MaybeLocal<Value> KeyObjectHandle::ExportPublicKey(
    const PublicKeyEncodingConfig& config) const {
  return WritePublicKey(env(), data_->GetAsymmetricKey().get(), config);
}",1,1,crypto\crypto_keys.cc,node.crypto.KeyObjectHandle.ExportPublicKey,,false,1286,1289,ExportPublicKey,,,47,MaybeLocal<Value> node.crypto.KeyObjectHandle.ExportPublicKey (PublicKeyEncodingConfig)
48349,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"MaybeLocal<Value> KeyObjectHandle::ExportPrivateKey(
    const PrivateKeyEncodingConfig& config) const {
  return WritePrivateKey(env(), data_->GetAsymmetricKey().get(), config);
}",1,1,crypto\crypto_keys.cc,node.crypto.KeyObjectHandle.ExportPrivateKey,,false,1291,1294,ExportPrivateKey,,,48,MaybeLocal<Value> node.crypto.KeyObjectHandle.ExportPrivateKey (PrivateKeyEncodingConfig)
48365,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"void KeyObjectHandle::ExportJWK(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());

  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsBoolean());

  ExportJWKInner(env, key->Data(), args[0], args[1]->IsTrue());

  args.GetReturnValue().Set(args[0]);
}",1,1,crypto\crypto_keys.cc,node.crypto.KeyObjectHandle.ExportJWK,,false,1296,1308,ExportJWK,,,49,void node.crypto.KeyObjectHandle.ExportJWK (ANY)
48425,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"void NativeKeyObject::Initialize(Environment* env, Local<Object> target) {
  SetMethod(env->context(),
            target,
            ""createNativeKeyObjectClass"",
            NativeKeyObject::CreateNativeKeyObjectClass);
}",1,1,crypto\crypto_keys.cc,node.crypto.NativeKeyObject.Initialize,,false,1310,1315,Initialize,,,50,"void node.crypto.NativeKeyObject.Initialize (Environment*,Local<Object>)"
48441,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"void NativeKeyObject::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(NativeKeyObject::CreateNativeKeyObjectClass);
  registry->Register(NativeKeyObject::New);
}",1,1,crypto\crypto_keys.cc,node.crypto.NativeKeyObject.RegisterExternalReferences,,false,1317,1321,RegisterExternalReferences,,,51,void node.crypto.NativeKeyObject.RegisterExternalReferences (ExternalReferenceRegistry*)
48460,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"void NativeKeyObject::New(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsObject());
  KeyObjectHandle* handle = Unwrap<KeyObjectHandle>(args[0].As<Object>());
  new NativeKeyObject(env, args.This(), handle->Data());
}",1,1,crypto\crypto_keys.cc,node.crypto.NativeKeyObject.New,,false,1323,1329,New,,,52,void node.crypto.NativeKeyObject.New (FunctionCallbackInfo<Value>)
48510,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"void NativeKeyObject::CreateNativeKeyObjectClass(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  CHECK_EQ(args.Length(), 1);
  Local<Value> callback = args[0];
  CHECK(callback->IsFunction());

  Local<FunctionTemplate> t =
      NewFunctionTemplate(isolate, NativeKeyObject::New);
  t->InstanceTemplate()->SetInternalFieldCount(
      KeyObjectHandle::kInternalFieldCount);

  Local<Value> ctor;
  if (!t->GetFunction(env->context()).ToLocal(&ctor))
    return;

  Local<Value> recv = Undefined(env->isolate());
  Local<Value> ret_v;
  if (!callback.As<Function>()->Call(
          env->context(), recv, 1, &ctor).ToLocal(&ret_v)) {
    return;
  }
  Local<Array> ret = ret_v.As<Array>();
  if (!ret->Get(env->context(), 1).ToLocal(&ctor)) return;
  env->set_crypto_key_object_secret_constructor(ctor.As<Function>());
  if (!ret->Get(env->context(), 2).ToLocal(&ctor)) return;
  env->set_crypto_key_objec...",1,1,crypto\crypto_keys.cc,node.crypto.NativeKeyObject.CreateNativeKeyObjectClass,,false,1331,1363,CreateNativeKeyObjectClass,,,53,void node.crypto.NativeKeyObject.CreateNativeKeyObjectClass (FunctionCallbackInfo<Value>)
48729,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"BaseObjectPtr<BaseObject> NativeKeyObject::KeyObjectTransferData::Deserialize(
        Environment* env,
        Local<Context> context,
        std::unique_ptr<worker::TransferData> self) {
  if (context != env->context()) {
    THROW_ERR_MESSAGE_TARGET_CONTEXT_UNAVAILABLE(env);
    return {};
  }

  Local<Value> handle;
  if (!KeyObjectHandle::Create(env, data_).ToLocal(&handle))
    return {};

  Local<Function> key_ctor;
  Local<Value> arg = FIXED_ONE_BYTE_STRING(env->isolate(),
                                           ""internal/crypto/keys"");
  if (env->builtin_module_require()
          ->Call(context, Null(env->isolate()), 1, &arg)
          .IsEmpty()) {
    return {};
  }
  switch (data_->GetKeyType()) {
    case kKeyTypeSecret:
      key_ctor = env->crypto_key_object_secret_constructor();
      break;
    case kKeyTypePublic:
      key_ctor = env->crypto_key_object_public_constructor();
      break;
    case kKeyTypePrivate:
      key_ctor = env->crypto_key_object_privat...",1,1,crypto\crypto_keys.cc,node.crypto.NativeKeyObject.KeyObjectTransferData.Deserialize,,false,1365,1405,Deserialize,,,54,"BaseObjectPtr<BaseObject> node.crypto.NativeKeyObject.KeyObjectTransferData.Deserialize (Environment*,Local<Context>,ANY)"
48876,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"BaseObject::TransferMode NativeKeyObject::GetTransferMode() const {
  return BaseObject::TransferMode::kCloneable;
}",1,1,crypto\crypto_keys.cc,node.crypto.NativeKeyObject.GetTransferMode,,false,1407,1409,GetTransferMode,,,55,TransferMode node.crypto.NativeKeyObject.GetTransferMode ()
48886,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"std::unique_ptr<worker::TransferData> NativeKeyObject::CloneForMessaging()
    const {
  return std::make_unique<KeyObjectTransferData>(handle_data_);
}",1,1,crypto\crypto_keys.cc,node.crypto.NativeKeyObject.CloneForMessaging,,false,1411,1414,CloneForMessaging,,,56,unique_ptr<worker::TransferData> node.crypto.NativeKeyObject.CloneForMessaging ()
48898,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"WebCryptoKeyExportStatus PKEY_SPKI_Export(
    KeyObjectData* key_data,
    ByteSource* out) {
  CHECK_EQ(key_data->GetKeyType(), kKeyTypePublic);
  ManagedEVPPKey m_pkey = key_data->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);
  if (!i2d_PUBKEY_bio(bio.get(), m_pkey.get()))
    return WebCryptoKeyExportStatus::FAILED;

  *out = ByteSource::FromBIO(bio);
  return WebCryptoKeyExportStatus::OK;
}",1,1,crypto\crypto_keys.cc,node.crypto.PKEY_SPKI_Export,,false,1416,1429,PKEY_SPKI_Export,,,57,"WebCryptoKeyExportStatus node.crypto.PKEY_SPKI_Export (KeyObjectData*,ByteSource*)"
48922,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,BIOPointer bio(BIO_new(BIO_s_mem()));,14,38,crypto\crypto_keys.cc,node.crypto.PKEY_SPKI_Export.bio,,false,1422,1422,bio,,,6,BIOPointer node.crypto.PKEY_SPKI_Export.bio (BIO_new)
48959,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"WebCryptoKeyExportStatus PKEY_PKCS8_Export(
    KeyObjectData* key_data,
    ByteSource* out) {
  CHECK_EQ(key_data->GetKeyType(), kKeyTypePrivate);
  ManagedEVPPKey m_pkey = key_data->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());

  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);
  PKCS8Pointer p8inf(EVP_PKEY2PKCS8(m_pkey.get()));
  if (!i2d_PKCS8_PRIV_KEY_INFO_bio(bio.get(), p8inf.get()))
    return WebCryptoKeyExportStatus::FAILED;

  *out = ByteSource::FromBIO(bio);
  return WebCryptoKeyExportStatus::OK;
}",1,1,crypto\crypto_keys.cc,node.crypto.PKEY_PKCS8_Export,,false,1431,1446,PKEY_PKCS8_Export,,,58,"WebCryptoKeyExportStatus node.crypto.PKEY_PKCS8_Export (KeyObjectData*,ByteSource*)"
48983,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,BIOPointer bio(BIO_new(BIO_s_mem()));,14,38,crypto\crypto_keys.cc,node.crypto.PKEY_PKCS8_Export.bio,,false,1438,1438,bio,,,6,BIOPointer node.crypto.PKEY_PKCS8_Export.bio (BIO_new)
49028,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"void Initialize(Environment* env, Local<Object> target) {
  target->Set(env->context(),
              FIXED_ONE_BYTE_STRING(env->isolate(), ""KeyObjectHandle""),
              KeyObjectHandle::Initialize(env)).Check();

  NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatRaw);
  NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatPKCS8);
  NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatSPKI);
  NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatJWK);

  NODE_DEFINE_CONSTANT(target, EVP_PKEY_ED25519);
  NODE_DEFINE_CONSTANT(target, EVP_PKEY_ED448);
  NODE_DEFINE_CONSTANT(target, EVP_PKEY_X25519);
  NODE_DEFINE_CONSTANT(target, EVP_PKEY_X448);
  NODE_DEFINE_CONSTANT(target, kKeyEncodingPKCS1);
  NODE_DEFINE_CONSTANT(target, kKeyEncodingPKCS8);
  NODE_DEFINE_CONSTANT(target, kKeyEncodingSPKI);
  NODE_DEFINE_CONSTANT(target, kKeyEncodingSEC1);
  NODE_DEFINE_CONSTANT(target, kKeyFormatDER);
  NODE_DEFINE_CONSTANT(target, kKeyFormatPEM);
  NODE_DEFINE_CONSTANT(target, kKeyFormatJWK);
  NODE_DEFINE_...",1,2,crypto\crypto_keys.cc,node.crypto.Keys.Initialize,,false,1449,1475,Initialize,,,1,"void node.crypto.Keys.Initialize (Environment*,Local<Object>)"
51036,METHOD,crypto\crypto_keys.cc:<global>,TYPE_DECL,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  KeyObjectHandle::RegisterExternalReferences(registry);
}",1,1,crypto\crypto_keys.cc,node.crypto.Keys.RegisterExternalReferences,,false,1477,1479,RegisterExternalReferences,,,2,void node.crypto.Keys.RegisterExternalReferences (ExternalReferenceRegistry*)
51069,METHOD,crypto\crypto_keys.hpp:<global>,TYPE_DECL,<global>,1,36,crypto\crypto_keys.hpp,crypto\crypto_keys.hpp:<global>,,false,1,416,<global>,,,1,
51090,METHOD,crypto\crypto_pbkdf2.cc:<global>,TYPE_DECL,<global>,1,38,crypto\crypto_pbkdf2.hpp,crypto\crypto_pbkdf2.cc:<global>,,false,1,139,<global>,,,1,
51094,METHOD,crypto\crypto_pbkdf2.cc:<global>,TYPE_DECL,"PBKDF2Config::PBKDF2Config(PBKDF2Config&& other) noexcept
    : mode(other.mode),
      pass(std::move(other.pass)),
      salt(std::move(other.salt)),
      iterations(other.iterations),
      length(other.length),
      digest(other.digest) {}",1,29,crypto\crypto_pbkdf2.cc,node.crypto.PBKDF2Config.PBKDF2Config,,false,20,26,PBKDF2Config,,,1,ANY node.crypto.PBKDF2Config.PBKDF2Config (PBKDF2Config)
51099,METHOD,crypto\crypto_pbkdf2.cc:<global>,TYPE_DECL,"PBKDF2Config& PBKDF2Config::operator=(PBKDF2Config&& other) noexcept {
  if (&other == this) return *this;
  this->~PBKDF2Config();
  return *new (this) PBKDF2Config(std::move(other));
}",1,1,crypto\crypto_pbkdf2.cc,node.crypto.PBKDF2Config.operator =,,false,28,32,operator =,,,2,PBKDF2Config node.crypto.PBKDF2Config.operator = (PBKDF2Config)
51127,METHOD,crypto\crypto_pbkdf2.cc:<global>,TYPE_DECL,"void PBKDF2Config::MemoryInfo(MemoryTracker* tracker) const {
  // The job is sync, the PBKDF2Config does not own the data.
  if (mode == kCryptoJobAsync) {
    tracker->TrackFieldWithSize(""pass"", pass.size());
    tracker->TrackFieldWithSize(""salt"", salt.size());
  }
}",1,1,crypto\crypto_pbkdf2.cc,node.crypto.PBKDF2Config.MemoryInfo,,false,34,40,MemoryInfo,,,3,void node.crypto.PBKDF2Config.MemoryInfo (MemoryTracker*)
51155,METHOD,crypto\crypto_pbkdf2.cc:<global>,TYPE_DECL,"Maybe<bool> PBKDF2Traits::EncodeOutput(
    Environment* env,
    const PBKDF2Config& params,
    ByteSource* out,
    v8::Local<v8::Value>* result) {
  *result = out->ToArrayBuffer(env);
  return Just(!result->IsEmpty());
}",1,1,crypto\crypto_pbkdf2.cc,node.crypto.PBKDF2Traits.EncodeOutput,,false,42,49,EncodeOutput,,,4,"Maybe<bool> node.crypto.PBKDF2Traits.EncodeOutput (Environment*,PBKDF2Config,ByteSource*,ANY*)"
51178,METHOD,crypto\crypto_pbkdf2.cc:<global>,TYPE_DECL,"Maybe<bool> PBKDF2Traits::AdditionalConfig(
    CryptoJobMode mode,
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset,
    PBKDF2Config* params) {
  Environment* env = Environment::GetCurrent(args);

  params->mode = mode;

  ArrayBufferOrViewContents<char> pass(args[offset]);
  ArrayBufferOrViewContents<char> salt(args[offset + 1]);

  if (UNLIKELY(!pass.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""pass is too large"");
    return Nothing<bool>();
  }

  if (UNLIKELY(!salt.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""salt is too large"");
    return Nothing<bool>();
  }

  params->pass = mode == kCryptoJobAsync
      ? pass.ToCopy()
      : pass.ToByteSource();

  params->salt = mode == kCryptoJobAsync
      ? salt.ToCopy()
      : salt.ToByteSource();

  CHECK(args[offset + 2]->IsInt32());  // iteration_count
  CHECK(args[offset + 3]->IsInt32());  // length
  CHECK(args[offset + 4]->IsString());  // digest_name

  params->iterations = args[offset...",1,1,crypto\crypto_pbkdf2.cc,node.crypto.PBKDF2Traits.AdditionalConfig,,false,58,112,AdditionalConfig,,,5,"Maybe<bool> node.crypto.PBKDF2Traits.AdditionalConfig (CryptoJobMode,FunctionCallbackInfo<Value>,unsigned int,PBKDF2Config*)"
51387,METHOD,crypto\crypto_pbkdf2.cc:<global>,TYPE_DECL,"bool PBKDF2Traits::DeriveBits(
    Environment* env,
    const PBKDF2Config& params,
    ByteSource* out) {
  ByteSource::Builder buf(params.length);

  // Both pass and salt may be zero length here.
  // The generated bytes are stored in buf, which is
  // assigned to out on success.

  if (PKCS5_PBKDF2_HMAC(params.pass.data<char>(),
                        params.pass.size(),
                        params.salt.data<unsigned char>(),
                        params.salt.size(),
                        params.iterations,
                        params.digest,
                        params.length,
                        buf.data<unsigned char>()) <= 0) {
    return false;
  }
  *out = std::move(buf).release();
  return true;
}",1,1,crypto\crypto_pbkdf2.cc,node.crypto.PBKDF2Traits.DeriveBits,,false,114,136,DeriveBits,,,6,"bool node.crypto.PBKDF2Traits.DeriveBits (Environment*,PBKDF2Config,ByteSource*)"
51469,METHOD,crypto\crypto_pbkdf2.hpp:<global>,TYPE_DECL,<global>,1,38,crypto\crypto_pbkdf2.hpp,crypto\crypto_pbkdf2.hpp:<global>,,false,1,76,<global>,,,1,
51492,METHOD,crypto\crypto_random.cc:<global>,TYPE_DECL,<global>,1,38,crypto\crypto_random.hpp,crypto\crypto_random.cc:<global>,,false,1,239,<global>,,,1,
51496,METHOD,crypto\crypto_random.cc:<global>,TYPE_DECL,"Maybe<bool> RandomBytesTraits::EncodeOutput(
    Environment* env,
    const RandomBytesConfig& params,
    ByteSource* unused,
    v8::Local<v8::Value>* result) {
  *result = v8::Undefined(env->isolate());
  return Just(!result->IsEmpty());
}",1,1,crypto\crypto_random.cc,node.crypto.RandomBytesTraits.EncodeOutput,,false,28,35,EncodeOutput,,,1,"Maybe<bool> node.crypto.RandomBytesTraits.EncodeOutput (Environment*,RandomBytesConfig,ByteSource*,ANY*)"
51522,METHOD,crypto\crypto_random.cc:<global>,TYPE_DECL,"Maybe<bool> RandomBytesTraits::AdditionalConfig(
    CryptoJobMode mode,
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset,
    RandomBytesConfig* params) {
  CHECK(IsAnyByteSource(args[offset]));  // Buffer to fill
  CHECK(args[offset + 1]->IsUint32());  // Offset
  CHECK(args[offset + 2]->IsUint32());  // Size

  ArrayBufferOrViewContents<unsigned char> in(args[offset]);

  const uint32_t byte_offset = args[offset + 1].As<Uint32>()->Value();
  const uint32_t size = args[offset + 2].As<Uint32>()->Value();
  CHECK_GE(byte_offset + size, byte_offset);  // Overflow check.
  CHECK_LE(byte_offset + size, in.size());  // Bounds check.

  params->buffer = in.data() + byte_offset;
  params->size = size;

  return Just(true);
}",1,1,crypto\crypto_random.cc,node.crypto.RandomBytesTraits.AdditionalConfig,,false,37,57,AdditionalConfig,,,2,"Maybe<bool> node.crypto.RandomBytesTraits.AdditionalConfig (CryptoJobMode,FunctionCallbackInfo<Value>,unsigned int,RandomBytesConfig*)"
51617,METHOD,crypto\crypto_random.cc:<global>,TYPE_DECL,"bool RandomBytesTraits::DeriveBits(
    Environment* env,
    const RandomBytesConfig& params,
    ByteSource* unused) {
  return CSPRNG(params.buffer, params.size).is_ok();
}",1,1,crypto\crypto_random.cc,node.crypto.RandomBytesTraits.DeriveBits,,false,59,64,DeriveBits,,,3,"bool node.crypto.RandomBytesTraits.DeriveBits (Environment*,RandomBytesConfig,ByteSource*)"
51635,METHOD,crypto\crypto_random.cc:<global>,TYPE_DECL,"void RandomPrimeConfig::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackFieldWithSize(""prime"", prime ? bits * 8 : 0);
}",1,1,crypto\crypto_random.cc,node.crypto.RandomPrimeConfig.MemoryInfo,,false,66,68,MemoryInfo,,,4,void node.crypto.RandomPrimeConfig.MemoryInfo (MemoryTracker*)
51651,METHOD,crypto\crypto_random.cc:<global>,TYPE_DECL,"Maybe<bool> RandomPrimeTraits::EncodeOutput(
    Environment* env,
    const RandomPrimeConfig& params,
    ByteSource* unused,
    v8::Local<v8::Value>* result) {
  size_t size = BN_num_bytes(params.prime.get());
  std::shared_ptr<BackingStore> store =
      ArrayBuffer::NewBackingStore(env->isolate(), size);
  BN_bn2binpad(
      params.prime.get(),
      reinterpret_cast<unsigned char*>(store->Data()),
      size);
  *result = ArrayBuffer::New(env->isolate(), store);
  return Just(true);
}",1,1,crypto\crypto_random.cc,node.crypto.RandomPrimeTraits.EncodeOutput,,false,70,84,EncodeOutput,,,5,"Maybe<bool> node.crypto.RandomPrimeTraits.EncodeOutput (Environment*,RandomPrimeConfig,ByteSource*,ANY*)"
51715,METHOD,crypto\crypto_random.cc:<global>,TYPE_DECL,"Maybe<bool> RandomPrimeTraits::AdditionalConfig(
    CryptoJobMode mode,
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset,
    RandomPrimeConfig* params) {
  ClearErrorOnReturn clear_error;
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[offset]->IsUint32());  // Size
  CHECK(args[offset + 1]->IsBoolean());  // Safe

  const uint32_t size = args[offset].As<Uint32>()->Value();
  bool safe = args[offset + 1]->IsTrue();

  if (!args[offset + 2]->IsUndefined()) {
    ArrayBufferOrViewContents<unsigned char> add(args[offset + 2]);
    params->add.reset(BN_bin2bn(add.data(), add.size(), nullptr));
    if (!params->add) {
      THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""could not generate prime"");
      return Nothing<bool>();
    }
  }

  if (!args[offset + 3]->IsUndefined()) {
    ArrayBufferOrViewContents<unsigned char> rem(args[offset + 3]);
    params->rem.reset(BN_bin2bn(rem.data(), rem.size(), nullptr));
    if (!params->rem) {
      THROW_ERR_CRYPT...",1,1,crypto\crypto_random.cc,node.crypto.RandomPrimeTraits.AdditionalConfig,,false,86,150,AdditionalConfig,,,6,"Maybe<bool> node.crypto.RandomPrimeTraits.AdditionalConfig (CryptoJobMode,FunctionCallbackInfo<Value>,unsigned int,RandomPrimeConfig*)"
51949,METHOD,crypto\crypto_random.cc:<global>,TYPE_DECL,"bool RandomPrimeTraits::DeriveBits(Environment* env,
                                   const RandomPrimeConfig& params,
                                   ByteSource* unused) {
  // BN_generate_prime_ex() calls RAND_bytes_ex() internally.
  // Make sure the CSPRNG is properly seeded.
  CHECK(CSPRNG(nullptr, 0).is_ok());

  if (BN_generate_prime_ex(
          params.prime.get(),
          params.bits,
          params.safe ? 1 : 0,
          params.add.get(),
          params.rem.get(),
          nullptr) == 0) {
    return false;
  }

  return true;
}",1,1,crypto\crypto_random.cc,node.crypto.RandomPrimeTraits.DeriveBits,,false,152,170,DeriveBits,,,7,"bool node.crypto.RandomPrimeTraits.DeriveBits (Environment*,RandomPrimeConfig,ByteSource*)"
52000,METHOD,crypto\crypto_random.cc:<global>,TYPE_DECL,"void CheckPrimeConfig::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackFieldWithSize(
      ""prime"", candidate ? BN_num_bytes(candidate.get()) : 0);
}",1,1,crypto\crypto_random.cc,node.crypto.CheckPrimeConfig.MemoryInfo,,false,172,175,MemoryInfo,,,8,void node.crypto.CheckPrimeConfig.MemoryInfo (MemoryTracker*)
52018,METHOD,crypto\crypto_random.cc:<global>,TYPE_DECL,"Maybe<bool> CheckPrimeTraits::AdditionalConfig(
    CryptoJobMode mode,
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset,
    CheckPrimeConfig* params) {
  ArrayBufferOrViewContents<unsigned char> candidate(args[offset]);

  params->candidate =
      BignumPointer(BN_bin2bn(
          candidate.data(),
          candidate.size(),
          nullptr));

  CHECK(args[offset + 1]->IsInt32());  // Checks
  params->checks = args[offset + 1].As<Int32>()->Value();
  CHECK_GE(params->checks, 0);

  return Just(true);
}",1,1,crypto\crypto_random.cc,node.crypto.CheckPrimeTraits.AdditionalConfig,,false,177,195,AdditionalConfig,,,9,"Maybe<bool> node.crypto.CheckPrimeTraits.AdditionalConfig (CryptoJobMode,FunctionCallbackInfo<Value>,unsigned int,CheckPrimeConfig*)"
52078,METHOD,crypto\crypto_random.cc:<global>,TYPE_DECL,"bool CheckPrimeTraits::DeriveBits(
    Environment* env,
    const CheckPrimeConfig& params,
    ByteSource* out) {

  BignumCtxPointer ctx(BN_CTX_new());

  int ret = BN_is_prime_ex(
            params.candidate.get(),
            params.checks,
            ctx.get(),
            nullptr);
  if (ret < 0) return false;
  ByteSource::Builder buf(1);
  buf.data<char>()[0] = ret;
  *out = std::move(buf).release();
  return true;
}",1,1,crypto\crypto_random.cc,node.crypto.CheckPrimeTraits.DeriveBits,,false,197,214,DeriveBits,,,10,"bool node.crypto.CheckPrimeTraits.DeriveBits (Environment*,CheckPrimeConfig,ByteSource*)"
52137,METHOD,crypto\crypto_random.cc:<global>,TYPE_DECL,"Maybe<bool> CheckPrimeTraits::EncodeOutput(
    Environment* env,
    const CheckPrimeConfig& params,
    ByteSource* out,
    v8::Local<v8::Value>* result) {
  *result = Boolean::New(env->isolate(), out->data<char>()[0] != 0);
  return Just(true);
}",1,1,crypto\crypto_random.cc,node.crypto.CheckPrimeTraits.EncodeOutput,,false,216,223,EncodeOutput,,,11,"Maybe<bool> node.crypto.CheckPrimeTraits.EncodeOutput (Environment*,CheckPrimeConfig,ByteSource*,ANY*)"
52168,METHOD,crypto\crypto_random.cc:<global>,TYPE_DECL,"void Initialize(Environment* env, Local<Object> target) {
  RandomBytesJob::Initialize(env, target);
  RandomPrimeJob::Initialize(env, target);
  CheckPrimeJob::Initialize(env, target);
}",1,1,crypto\crypto_random.cc,node.crypto.Random.Initialize,,false,226,230,Initialize,,,1,"void node.crypto.Random.Initialize (Environment*,Local<Object>)"
52192,METHOD,crypto\crypto_random.cc:<global>,TYPE_DECL,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  RandomBytesJob::RegisterExternalReferences(registry);
  RandomPrimeJob::RegisterExternalReferences(registry);
  CheckPrimeJob::RegisterExternalReferences(registry);
}",1,1,crypto\crypto_random.cc,node.crypto.Random.RegisterExternalReferences,,false,232,236,RegisterExternalReferences,,,2,void node.crypto.Random.RegisterExternalReferences (ExternalReferenceRegistry*)
52227,METHOD,crypto\crypto_random.hpp:<global>,TYPE_DECL,<global>,1,38,crypto\crypto_random.hpp,crypto\crypto_random.hpp:<global>,,false,1,130,<global>,,,1,
52256,METHOD,crypto\crypto_rsa.cc:<global>,TYPE_DECL,<global>,1,35,crypto\crypto_rsa.hpp,crypto\crypto_rsa.cc:<global>,,false,1,651,<global>,,,1,
52260,METHOD,crypto\crypto_rsa.cc:<global>,TYPE_DECL,"EVPKeyCtxPointer RsaKeyGenTraits::Setup(RsaKeyPairGenConfig* params) {
  EVPKeyCtxPointer ctx(
      EVP_PKEY_CTX_new_id(
          params->params.variant == kKeyVariantRSA_PSS
              ? EVP_PKEY_RSA_PSS
              : EVP_PKEY_RSA,
          nullptr));

  if (EVP_PKEY_keygen_init(ctx.get()) <= 0)
    return EVPKeyCtxPointer();

  if (EVP_PKEY_CTX_set_rsa_keygen_bits(
          ctx.get(),
          params->params.modulus_bits) <= 0) {
    return EVPKeyCtxPointer();
  }

  // 0x10001 is the default RSA exponent.
  if (params->params.exponent != 0x10001) {
    BignumPointer bn(BN_new());
    CHECK_NOT_NULL(bn.get());
    CHECK(BN_set_word(bn.get(), params->params.exponent));
    // EVP_CTX accepts ownership of bn on success.
    if (EVP_PKEY_CTX_set_rsa_keygen_pubexp(ctx.get(), bn.get()) <= 0)
      return EVPKeyCtxPointer();

    bn.release();
  }

  if (params->params.variant == kKeyVariantRSA_PSS) {
    if (params->params.md != nullptr &&
        EVP_PKEY_CTX_set_rsa_pss_key...",1,1,crypto\crypto_rsa.cc,node.crypto.RsaKeyGenTraits.Setup,,false,32,97,Setup,,,1,EVPKeyCtxPointer node.crypto.RsaKeyGenTraits.Setup (RsaKeyPairGenConfig*)
52477,METHOD,crypto\crypto_rsa.cc:<global>,TYPE_DECL,"Maybe<bool> RsaKeyGenTraits::AdditionalConfig(
    CryptoJobMode mode,
    const FunctionCallbackInfo<Value>& args,
    unsigned int* offset,
    RsaKeyPairGenConfig* params) {
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[*offset]->IsUint32());  // Variant
  CHECK(args[*offset + 1]->IsUint32());  // Modulus bits
  CHECK(args[*offset + 2]->IsUint32());  // Exponent

  params->params.variant =
      static_cast<RSAKeyVariant>(args[*offset].As<Uint32>()->Value());

  CHECK_IMPLIES(params->params.variant != kKeyVariantRSA_PSS,
                args.Length() == 10);
  CHECK_IMPLIES(params->params.variant == kKeyVariantRSA_PSS,
                args.Length() == 13);

  params->params.modulus_bits = args[*offset + 1].As<Uint32>()->Value();
  params->params.exponent = args[*offset + 2].As<Uint32>()->Value();

  *offset += 3;

  if (params->params.variant == kKeyVariantRSA_PSS) {
    if (!args[*offset]->IsUndefined()) {
      CHECK(args[*offset]->IsString());
      Utf8Val...",1,1,crypto\crypto_rsa.cc,node.crypto.RsaKeyGenTraits.AdditionalConfig,,false,126,187,AdditionalConfig,,,2,"Maybe<bool> node.crypto.RsaKeyGenTraits.AdditionalConfig (CryptoJobMode,FunctionCallbackInfo<Value>,unsigned int*,RsaKeyPairGenConfig*)"
52790,METHOD,crypto\crypto_rsa.cc:<global>,TYPE_DECL,"WebCryptoKeyExportStatus RSA_JWK_Export(
    KeyObjectData* key_data,
    const RSAKeyExportConfig& params,
    ByteSource* out) {
  return WebCryptoKeyExportStatus::FAILED;
}",1,1,crypto\crypto_rsa.cc,node.crypto.anonymous_namespace_1.RSA_JWK_Export,,false,190,195,RSA_JWK_Export,,,1,"WebCryptoKeyExportStatus node.crypto.anonymous_namespace_1.RSA_JWK_Export (KeyObjectData*,RSAKeyExportConfig,ByteSource*)"
52801,METHOD,crypto\crypto_rsa.cc:<global>,TYPE_DECL,"WebCryptoCipherStatus RSA_Cipher(
    Environment* env,
    KeyObjectData* key_data,
    const RSACipherConfig& params,
    const ByteSource& in,
    ByteSource* out) {
  CHECK_NE(key_data->GetKeyType(), kKeyTypeSecret);
  ManagedEVPPKey m_pkey = key_data->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());

  EVPKeyCtxPointer ctx(EVP_PKEY_CTX_new(m_pkey.get(), nullptr));

  if (!ctx || init(ctx.get()) <= 0)
    return WebCryptoCipherStatus::FAILED;

  if (EVP_PKEY_CTX_set_rsa_padding(ctx.get(), params.padding) <= 0) {
    return WebCryptoCipherStatus::FAILED;
  }

  if (params.digest != nullptr &&
      (EVP_PKEY_CTX_set_rsa_oaep_md(ctx.get(), params.digest) <= 0 ||
       EVP_PKEY_CTX_set_rsa_mgf1_md(ctx.get(), params.digest) <= 0)) {
    return WebCryptoCipherStatus::FAILED;
  }

  if (!SetRsaOaepLabel(ctx, params.label)) return WebCryptoCipherStatus::FAILED;

  size_t out_len = 0;
  if (cipher(
          ctx.get(),
          nullptr,
          &out_len,
          in.d...",1,1,crypto\crypto_rsa.cc,node.crypto.anonymous_namespace_2.RSA_Cipher,,false,199,248,RSA_Cipher,,,2,"WebCryptoCipherStatus node.crypto.anonymous_namespace_2.RSA_Cipher<PublicKeyCipher::EVP_PKEY_cipher_init_t,PublicKeyCipher::EVP_PKEY_cipher_t> (Environment*,KeyObjectData*,RSACipherConfig,ByteSource,ByteSource*)"
52989,METHOD,crypto\crypto_rsa.cc:<global>,TYPE_DECL,"Maybe<bool> RSAKeyExportTraits::AdditionalConfig(
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset,
    RSAKeyExportConfig* params) {
  CHECK(args[offset]->IsUint32());  // RSAKeyVariant
  params->variant =
      static_cast<RSAKeyVariant>(args[offset].As<Uint32>()->Value());
  return Just(true);
}",1,1,crypto\crypto_rsa.cc,node.crypto.RSAKeyExportTraits.AdditionalConfig,,false,251,259,AdditionalConfig,,,4,"Maybe<bool> node.crypto.RSAKeyExportTraits.AdditionalConfig (FunctionCallbackInfo<Value>,unsigned int,RSAKeyExportConfig*)"
53021,METHOD,crypto\crypto_rsa.cc:<global>,TYPE_DECL,"WebCryptoKeyExportStatus RSAKeyExportTraits::DoExport(
    std::shared_ptr<KeyObjectData> key_data,
    WebCryptoKeyFormat format,
    const RSAKeyExportConfig& params,
    ByteSource* out) {
  CHECK_NE(key_data->GetKeyType(), kKeyTypeSecret);

  switch (format) {
    case kWebCryptoKeyFormatRaw:
      // Not supported for RSA keys of either type
      return WebCryptoKeyExportStatus::FAILED;
    case kWebCryptoKeyFormatJWK:
      return RSA_JWK_Export(key_data.get(), params, out);
    case kWebCryptoKeyFormatPKCS8:
      if (key_data->GetKeyType() != kKeyTypePrivate)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_PKCS8_Export(key_data.get(), out);
    case kWebCryptoKeyFormatSPKI:
      if (key_data->GetKeyType() != kKeyTypePublic)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_SPKI_Export(key_data.get(), out);
    default:
      UNREACHABLE();
  }
}",1,1,crypto\crypto_rsa.cc,node.crypto.RSAKeyExportTraits.DoExport,,false,261,285,DoExport,,,5,"WebCryptoKeyExportStatus node.crypto.RSAKeyExportTraits.DoExport (ANY,WebCryptoKeyFormat,RSAKeyExportConfig,ByteSource*)"
53098,METHOD,crypto\crypto_rsa.cc:<global>,TYPE_DECL,"RSACipherConfig::RSACipherConfig(RSACipherConfig&& other) noexcept
    : mode(other.mode),
      label(std::move(other.label)),
      padding(other.padding),
      digest(other.digest) {}",1,29,crypto\crypto_rsa.cc,node.crypto.RSACipherConfig.RSACipherConfig,,false,287,291,RSACipherConfig,,,6,ANY node.crypto.RSACipherConfig.RSACipherConfig (RSACipherConfig)
53103,METHOD,crypto\crypto_rsa.cc:<global>,TYPE_DECL,"void RSACipherConfig::MemoryInfo(MemoryTracker* tracker) const {
  if (mode == kCryptoJobAsync)
    tracker->TrackFieldWithSize(""label"", label.size());
}",1,1,crypto\crypto_rsa.cc,node.crypto.RSACipherConfig.MemoryInfo,,false,293,296,MemoryInfo,,,7,void node.crypto.RSACipherConfig.MemoryInfo (MemoryTracker*)
53122,METHOD,crypto\crypto_rsa.cc:<global>,TYPE_DECL,"Maybe<bool> RSACipherTraits::AdditionalConfig(
    CryptoJobMode mode,
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset,
    WebCryptoCipherMode cipher_mode,
    RSACipherConfig* params) {
  Environment* env = Environment::GetCurrent(args);

  params->mode = mode;
  params->padding = RSA_PKCS1_OAEP_PADDING;

  CHECK(args[offset]->IsUint32());
  RSAKeyVariant variant =
      static_cast<RSAKeyVariant>(args[offset].As<Uint32>()->Value());

  switch (variant) {
    case kKeyVariantRSA_OAEP: {
      CHECK(args[offset + 1]->IsString());  // digest
      Utf8Value digest(env->isolate(), args[offset + 1]);

      params->digest = EVP_get_digestbyname(*digest);
      if (params->digest == nullptr) {
        THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
        return Nothing<bool>();
      }

      if (IsAnyByteSource(args[offset + 2])) {
        ArrayBufferOrViewContents<char> label(args[offset + 2]);
        if (UNLIKELY(!label.CheckSizeInt32()))...",1,1,crypto\crypto_rsa.cc,node.crypto.RSACipherTraits.AdditionalConfig,,false,298,340,AdditionalConfig,,,8,"Maybe<bool> node.crypto.RSACipherTraits.AdditionalConfig (CryptoJobMode,FunctionCallbackInfo<Value>,unsigned int,WebCryptoCipherMode,RSACipherConfig*)"
53262,METHOD,crypto\crypto_rsa.cc:<global>,TYPE_DECL,"WebCryptoCipherStatus RSACipherTraits::DoCipher(
    Environment* env,
    std::shared_ptr<KeyObjectData> key_data,
    WebCryptoCipherMode cipher_mode,
    const RSACipherConfig& params,
    const ByteSource& in,
    ByteSource* out) {
  switch (cipher_mode) {
    case kWebCryptoCipherEncrypt:
      CHECK_EQ(key_data->GetKeyType(), kKeyTypePublic);
      return RSA_Cipher<EVP_PKEY_encrypt_init, EVP_PKEY_encrypt>(
          env, key_data.get(), params, in, out);
    case kWebCryptoCipherDecrypt:
      CHECK_EQ(key_data->GetKeyType(), kKeyTypePrivate);
      return RSA_Cipher<EVP_PKEY_decrypt_init, EVP_PKEY_decrypt>(
          env, key_data.get(), params, in, out);
  }
  return WebCryptoCipherStatus::FAILED;
}",1,1,crypto\crypto_rsa.cc,node.crypto.RSACipherTraits.DoCipher,,false,342,360,DoCipher,,,9,"WebCryptoCipherStatus node.crypto.RSACipherTraits.DoCipher (Environment*,ANY,WebCryptoCipherMode,RSACipherConfig,ByteSource,ByteSource*)"
53315,METHOD,crypto\crypto_rsa.cc:<global>,TYPE_DECL,"Maybe<bool> ExportJWKRsaKey(
    Environment* env,
    std::shared_ptr<KeyObjectData> key,
    Local<Object> target) {
  ManagedEVPPKey m_pkey = key->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());
  int type = EVP_PKEY_id(m_pkey.get());
  CHECK(type == EVP_PKEY_RSA || type == EVP_PKEY_RSA_PSS);

  // TODO(tniessen): Remove the ""else"" branch once we drop support for OpenSSL
  // versions older than 1.1.1e via FIPS / dynamic linking.
  const RSA* rsa;
  if (OpenSSL_version_num() >= 0x1010105fL) {
    rsa = EVP_PKEY_get0_RSA(m_pkey.get());
  } else {
    rsa = static_cast<const RSA*>(EVP_PKEY_get0(m_pkey.get()));
  }
  CHECK_NOT_NULL(rsa);

  const BIGNUM* n;
  const BIGNUM* e;
  const BIGNUM* d;
  const BIGNUM* p;
  const BIGNUM* q;
  const BIGNUM* dp;
  const BIGNUM* dq;
  const BIGNUM* qi;
  RSA_get0_key(rsa, &n, &e, &d);

  if (target->Set(
          env->context(),
          env->jwk_kty_string(),
          env->jwk_rsa_string()).IsNothing()) {
    return Nothing<b...",1,1,crypto\crypto_rsa.cc,node.crypto.ExportJWKRsaKey,,false,362,417,ExportJWKRsaKey,,,10,"Maybe<bool> node.crypto.ExportJWKRsaKey (Environment*,ANY,Local<Object>)"
53544,METHOD,crypto\crypto_rsa.cc:<global>,TYPE_DECL,"std::shared_ptr<KeyObjectData> ImportJWKRsaKey(
    Environment* env,
    Local<Object> jwk,
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset) {
  Local<Value> n_value;
  Local<Value> e_value;
  Local<Value> d_value;

  if (!jwk->Get(env->context(), env->jwk_n_string()).ToLocal(&n_value) ||
      !jwk->Get(env->context(), env->jwk_e_string()).ToLocal(&e_value) ||
      !jwk->Get(env->context(), env->jwk_d_string()).ToLocal(&d_value) ||
      !n_value->IsString() ||
      !e_value->IsString()) {
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK RSA key"");
    return std::shared_ptr<KeyObjectData>();
  }

  if (!d_value->IsUndefined() && !d_value->IsString()) {
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK RSA key"");
    return std::shared_ptr<KeyObjectData>();
  }

  KeyType type = d_value->IsString() ? kKeyTypePrivate : kKeyTypePublic;

  RsaPointer rsa(RSA_new());

  ByteSource n = ByteSource::FromEncodedString(env, n_value.As<String>());
  ByteSource e = ...",1,1,crypto\crypto_rsa.cc,node.crypto.ImportJWKRsaKey,,false,419,506,ImportJWKRsaKey,,,11,"shared_ptr<KeyObjectData> node.crypto.ImportJWKRsaKey (Environment*,Local<Object>,FunctionCallbackInfo<Value>,unsigned int)"
54079,METHOD,crypto\crypto_rsa.cc:<global>,TYPE_DECL,"Maybe<bool> GetRsaKeyDetail(
    Environment* env,
    std::shared_ptr<KeyObjectData> key,
    Local<Object> target) {
  const BIGNUM* e;  // Public Exponent
  const BIGNUM* n;  // Modulus

  ManagedEVPPKey m_pkey = key->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());
  int type = EVP_PKEY_id(m_pkey.get());
  CHECK(type == EVP_PKEY_RSA || type == EVP_PKEY_RSA_PSS);

  // TODO(tniessen): Remove the ""else"" branch once we drop support for OpenSSL
  // versions older than 1.1.1e via FIPS / dynamic linking.
  const RSA* rsa;
  if (OpenSSL_version_num() >= 0x1010105fL) {
    rsa = EVP_PKEY_get0_RSA(m_pkey.get());
  } else {
    rsa = static_cast<const RSA*>(EVP_PKEY_get0(m_pkey.get()));
  }
  CHECK_NOT_NULL(rsa);

  RSA_get0_key(rsa, &n, &e, nullptr);

  size_t modulus_length = BN_num_bits(n);

  if (target
          ->Set(
              env->context(),
              env->modulus_length_string(),
              Number::New(env->isolate(), static_cast<double>(modulus_length))...",1,1,crypto\crypto_rsa.cc,node.crypto.GetRsaKeyDetail,,false,508,631,GetRsaKeyDetail,,,12,"Maybe<bool> node.crypto.GetRsaKeyDetail (Environment*,ANY,Local<Object>)"
54451,METHOD,crypto\crypto_rsa.cc:<global>,TYPE_DECL,"void Initialize(Environment* env, Local<Object> target) {
  RSAKeyPairGenJob::Initialize(env, target);
  RSAKeyExportJob::Initialize(env, target);
  RSACipherJob::Initialize(env, target);

  NODE_DEFINE_CONSTANT(target, kKeyVariantRSA_SSA_PKCS1_v1_5);
  NODE_DEFINE_CONSTANT(target, kKeyVariantRSA_PSS);
  NODE_DEFINE_CONSTANT(target, kKeyVariantRSA_OAEP);
}",1,1,crypto\crypto_rsa.cc,node.crypto.RSAAlg.Initialize,,false,634,642,Initialize,,,1,"void node.crypto.RSAAlg.Initialize (Environment*,Local<Object>)"
54484,METHOD,crypto\crypto_rsa.cc:<global>,TYPE_DECL,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  RSAKeyPairGenJob::RegisterExternalReferences(registry);
  RSAKeyExportJob::RegisterExternalReferences(registry);
  RSACipherJob::RegisterExternalReferences(registry);
}",1,1,crypto\crypto_rsa.cc,node.crypto.RSAAlg.RegisterExternalReferences,,false,644,648,RegisterExternalReferences,,,2,void node.crypto.RSAAlg.RegisterExternalReferences (ExternalReferenceRegistry*)
54521,METHOD,crypto\crypto_rsa.hpp:<global>,TYPE_DECL,<global>,1,35,crypto\crypto_rsa.hpp,crypto\crypto_rsa.hpp:<global>,,false,1,141,<global>,,,1,
54542,METHOD,crypto\crypto_scrypt.cc:<global>,TYPE_DECL,<global>,1,38,crypto\crypto_scrypt.hpp,crypto\crypto_scrypt.cc:<global>,,false,1,144,<global>,,,1,
54546,METHOD,crypto\crypto_scrypt.cc:<global>,TYPE_DECL,"ScryptConfig::ScryptConfig(ScryptConfig&& other) noexcept
  : mode(other.mode),
    pass(std::move(other.pass)),
    salt(std::move(other.salt)),
    N(other.N),
    r(other.r),
    p(other.p),
    maxmem(other.maxmem),
    length(other.length) {}",1,27,crypto\crypto_scrypt.cc,node.crypto.ScryptConfig.ScryptConfig,,false,23,31,ScryptConfig,,,1,ANY node.crypto.ScryptConfig.ScryptConfig (ScryptConfig)
54551,METHOD,crypto\crypto_scrypt.cc:<global>,TYPE_DECL,"ScryptConfig& ScryptConfig::operator=(ScryptConfig&& other) noexcept {
  if (&other == this) return *this;
  this->~ScryptConfig();
  return *new (this) ScryptConfig(std::move(other));
}",1,1,crypto\crypto_scrypt.cc,node.crypto.ScryptConfig.operator =,,false,33,37,operator =,,,2,ScryptConfig node.crypto.ScryptConfig.operator = (ScryptConfig)
54579,METHOD,crypto\crypto_scrypt.cc:<global>,TYPE_DECL,"void ScryptConfig::MemoryInfo(MemoryTracker* tracker) const {
  if (mode == kCryptoJobAsync) {
    tracker->TrackFieldWithSize(""pass"", pass.size());
    tracker->TrackFieldWithSize(""salt"", salt.size());
  }
}",1,1,crypto\crypto_scrypt.cc,node.crypto.ScryptConfig.MemoryInfo,,false,39,44,MemoryInfo,,,3,void node.crypto.ScryptConfig.MemoryInfo (MemoryTracker*)
54607,METHOD,crypto\crypto_scrypt.cc:<global>,TYPE_DECL,"Maybe<bool> ScryptTraits::EncodeOutput(
    Environment* env,
    const ScryptConfig& params,
    ByteSource* out,
    v8::Local<v8::Value>* result) {
  *result = out->ToArrayBuffer(env);
  return Just(!result->IsEmpty());
}",1,1,crypto\crypto_scrypt.cc,node.crypto.ScryptTraits.EncodeOutput,,false,46,53,EncodeOutput,,,4,"Maybe<bool> node.crypto.ScryptTraits.EncodeOutput (Environment*,ScryptConfig,ByteSource*,ANY*)"
54630,METHOD,crypto\crypto_scrypt.cc:<global>,TYPE_DECL,"Maybe<bool> ScryptTraits::AdditionalConfig(
    CryptoJobMode mode,
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset,
    ScryptConfig* params) {
  Environment* env = Environment::GetCurrent(args);

  params->mode = mode;

  ArrayBufferOrViewContents<char> pass(args[offset]);
  ArrayBufferOrViewContents<char> salt(args[offset + 1]);

  if (UNLIKELY(!pass.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""pass is too large"");
    return Nothing<bool>();
  }

  if (UNLIKELY(!salt.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""salt is too large"");
    return Nothing<bool>();
  }

  params->pass = mode == kCryptoJobAsync
      ? pass.ToCopy()
      : pass.ToByteSource();

  params->salt = mode == kCryptoJobAsync
      ? salt.ToCopy()
      : salt.ToByteSource();

  CHECK(args[offset + 2]->IsUint32());  // N
  CHECK(args[offset + 3]->IsUint32());  // r
  CHECK(args[offset + 4]->IsUint32());  // p
  CHECK(args[offset + 5]->IsNumber());  // maxmem
  CHECK(args...",1,1,crypto\crypto_scrypt.cc,node.crypto.ScryptTraits.AdditionalConfig,,false,55,115,AdditionalConfig,,,5,"Maybe<bool> node.crypto.ScryptTraits.AdditionalConfig (CryptoJobMode,FunctionCallbackInfo<Value>,unsigned int,ScryptConfig*)"
54880,METHOD,crypto\crypto_scrypt.cc:<global>,TYPE_DECL,"bool ScryptTraits::DeriveBits(
    Environment* env,
    const ScryptConfig& params,
    ByteSource* out) {
  ByteSource::Builder buf(params.length);

  // Both the pass and salt may be zero-length at this point

  if (!EVP_PBE_scrypt(params.pass.data<char>(),
                      params.pass.size(),
                      params.salt.data<unsigned char>(),
                      params.salt.size(),
                      params.N,
                      params.r,
                      params.p,
                      params.maxmem,
                      buf.data<unsigned char>(),
                      params.length)) {
    return false;
  }
  *out = std::move(buf).release();
  return true;
}",1,1,crypto\crypto_scrypt.cc,node.crypto.ScryptTraits.DeriveBits,,false,117,139,DeriveBits,,,6,"bool node.crypto.ScryptTraits.DeriveBits (Environment*,ScryptConfig,ByteSource*)"
54965,METHOD,crypto\crypto_scrypt.hpp:<global>,TYPE_DECL,<global>,1,38,crypto\crypto_scrypt.hpp,crypto\crypto_scrypt.hpp:<global>,,false,1,87,<global>,,,1,
54968,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"[](Sign* sign, const FunctionCallbackInfo<Value>& args,
                        const char* data, size_t size) {
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    Error err = sign->Update(data, size);
    crypto::CheckThrow(sign->env(), err);
  }",22,3,crypto\crypto_sig.cc,"args, [](Sign* sign, const FunctionCallbackInfo<Value>& args, const char* data, size_t size) { Environment* env = Environment.GetCurrent(args); if (UNLIKELY(size > INT_MAX)) return THROW_ERR_OUT_OF_RANGE(env, ""data is too long""); Error err = sign->Update(data, size); crypto.CheckThrow(sign->env(), err); }.<lambda>0",,false,376,383,<lambda>0,,,1,"ANY args, [](Sign* sign, const FunctionCallbackInfo<Value>& args, const char* data, size_t size) { Environment* env = Environment.GetCurrent(args); if (UNLIKELY(size > INT_MAX)) return THROW_ERR_OUT_OF_RANGE(env, ""data is too long""); Error err = sign->Update(data, size); crypto.CheckThrow(sign->env(), err); }.<lambda>0 (Sign*,FunctionCallbackInfo<Value>,char*,size_t)"
55015,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"[](Verify* verify,
                          const FunctionCallbackInfo<Value>& args,
                          const char* data, size_t size) {
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    Error err = verify->Update(data, size);
    crypto::CheckThrow(verify->env(), err);
  }",24,3,crypto\crypto_sig.cc,"args, [](Verify* verify, const FunctionCallbackInfo<Value>& args, const char* data, size_t size) { Environment* env = Environment.GetCurrent(args); if (UNLIKELY(size > INT_MAX)) return THROW_ERR_OUT_OF_RANGE(env, ""data is too long""); Error err = verify->Update(data, size); crypto.CheckThrow(verify->env(), err); }.<lambda>1",,false,492,500,<lambda>1,,,1,"ANY args, [](Verify* verify, const FunctionCallbackInfo<Value>& args, const char* data, size_t size) { Environment* env = Environment.GetCurrent(args); if (UNLIKELY(size > INT_MAX)) return THROW_ERR_OUT_OF_RANGE(env, ""data is too long""); Error err = verify->Update(data, size); crypto.CheckThrow(verify->env(), err); }.<lambda>1 (Verify*,FunctionCallbackInfo<Value>,char*,size_t)"
55082,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,<global>,1,35,crypto\crypto_sig.hpp,crypto\crypto_sig.cc:<global>,,false,1,829,<global>,,,1,
55087,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"bool ValidateDSAParameters(EVP_PKEY* key) {
  /* Validate DSA2 parameters from FIPS 186-4 */
#if OPENSSL_VERSION_MAJOR >= 3
  if (EVP_default_properties_is_fips_enabled(nullptr) &&
      EVP_PKEY_DSA == EVP_PKEY_base_id(key)) {
#else
  if (FIPS_mode() && EVP_PKEY_DSA == EVP_PKEY_base_id(key)) {
#endif
    const DSA* dsa = EVP_PKEY_get0_DSA(key);
    const BIGNUM* p;
    DSA_get0_pqg(dsa, &p, nullptr, nullptr);
    size_t L = BN_num_bits(p);
    const BIGNUM* q;
    DSA_get0_pqg(dsa, nullptr, &q, nullptr);
    size_t N = BN_num_bits(q);

    return (L == 1024 && N == 160) ||
           (L == 2048 && N == 224) ||
           (L == 2048 && N == 256) ||
           (L == 3072 && N == 256);
  }

  return true;
}",1,1,crypto\crypto_sig.cc,node.crypto.anonymous_namespace_1.ValidateDSAParameters,,false,32,55,ValidateDSAParameters,,,1,bool node.crypto.anonymous_namespace_1.ValidateDSAParameters (EVP_PKEY*)
55163,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"bool ApplyRSAOptions(const ManagedEVPPKey& pkey,
                     EVP_PKEY_CTX* pkctx,
                     int padding,
                     const Maybe<int>& salt_len) {
  if (EVP_PKEY_id(pkey.get()) == EVP_PKEY_RSA ||
      EVP_PKEY_id(pkey.get()) == EVP_PKEY_RSA2 ||
      EVP_PKEY_id(pkey.get()) == EVP_PKEY_RSA_PSS) {
    if (EVP_PKEY_CTX_set_rsa_padding(pkctx, padding) <= 0)
      return false;
    if (padding == RSA_PKCS1_PSS_PADDING && salt_len.IsJust()) {
      if (EVP_PKEY_CTX_set_rsa_pss_saltlen(pkctx, salt_len.FromJust()) <= 0)
        return false;
    }
  }

  return true;
}",1,1,crypto\crypto_sig.cc,node.crypto.anonymous_namespace_2.ApplyRSAOptions,,false,57,73,ApplyRSAOptions,,,2,"bool node.crypto.anonymous_namespace_2.ApplyRSAOptions (ManagedEVPPKey,EVP_PKEY_CTX*,int,Maybe<int>)"
55229,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"std::unique_ptr<BackingStore> Node_SignFinal(Environment* env,
                                             EVPMDPointer&& mdctx,
                                             const ManagedEVPPKey& pkey,
                                             int padding,
                                             Maybe<int> pss_salt_len) {
  unsigned char m[EVP_MAX_MD_SIZE];
  unsigned int m_len;

  if (!EVP_DigestFinal_ex(mdctx.get(), m, &m_len))
    return nullptr;

  int signed_sig_len = EVP_PKEY_size(pkey.get());
  CHECK_GE(signed_sig_len, 0);
  size_t sig_len = static_cast<size_t>(signed_sig_len);
  std::unique_ptr<BackingStore> sig;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    sig = ArrayBuffer::NewBackingStore(env->isolate(), sig_len);
  }
  EVPKeyCtxPointer pkctx(EVP_PKEY_CTX_new(pkey.get(), nullptr));
  if (pkctx &&
      EVP_PKEY_sign_init(pkctx.get()) &&
      ApplyRSAOptions(pkey, pkctx.get(), padding, pss_salt_len) &&
      EVP_PKEY_CTX_set_sig...",1,1,crypto\crypto_sig.cc,node.crypto.anonymous_namespace_3.Node_SignFinal,,false,75,110,Node_SignFinal,,,3,"unique_ptr<BackingStore> node.crypto.anonymous_namespace_3.Node_SignFinal (Environment*,EVPMDPointer,ManagedEVPPKey,int,Maybe<int>)"
55392,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"int GetDefaultSignPadding(const ManagedEVPPKey& m_pkey) {
  return EVP_PKEY_id(m_pkey.get()) == EVP_PKEY_RSA_PSS ? RSA_PKCS1_PSS_PADDING :
                                                         RSA_PKCS1_PADDING;
}",1,1,crypto\crypto_sig.cc,node.crypto.anonymous_namespace_4.GetDefaultSignPadding,,false,112,115,GetDefaultSignPadding,,,4,int node.crypto.anonymous_namespace_4.GetDefaultSignPadding (ManagedEVPPKey)
55408,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"unsigned int GetBytesOfRS(const ManagedEVPPKey& pkey) {
  int bits, base_id = EVP_PKEY_base_id(pkey.get());

  if (base_id == EVP_PKEY_DSA) {
    const DSA* dsa_key = EVP_PKEY_get0_DSA(pkey.get());
    // Both r and s are computed mod q, so their width is limited by that of q.
    bits = BN_num_bits(DSA_get0_q(dsa_key));
  } else if (base_id == EVP_PKEY_EC) {
    const EC_KEY* ec_key = EVP_PKEY_get0_EC_KEY(pkey.get());
    const EC_GROUP* ec_group = EC_KEY_get0_group(ec_key);
    bits = EC_GROUP_order_bits(ec_group);
  } else {
    return kNoDsaSignature;
  }

  return (bits + 7) / 8;
}",1,1,crypto\crypto_sig.cc,node.crypto.anonymous_namespace_5.GetBytesOfRS,,false,117,133,GetBytesOfRS,,,5,unsigned int node.crypto.anonymous_namespace_5.GetBytesOfRS (ManagedEVPPKey)
55474,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"bool ExtractP1363(
    const unsigned char* sig_data,
    unsigned char* out,
    size_t len,
    size_t n) {
  ECDSASigPointer asn1_sig(d2i_ECDSA_SIG(nullptr, &sig_data, len));
  if (!asn1_sig)
    return false;

  const BIGNUM* pr = ECDSA_SIG_get0_r(asn1_sig.get());
  const BIGNUM* ps = ECDSA_SIG_get0_s(asn1_sig.get());

  return BN_bn2binpad(pr, out, n) > 0 && BN_bn2binpad(ps, out + n, n) > 0;
}",1,1,crypto\crypto_sig.cc,node.crypto.anonymous_namespace_6.ExtractP1363,,false,135,148,ExtractP1363,,,6,"bool node.crypto.anonymous_namespace_6.ExtractP1363 (unsigned char*,unsigned char*,size_t,size_t)"
55527,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"std::unique_ptr<BackingStore> ConvertSignatureToP1363(Environment* env,
    const ManagedEVPPKey& pkey, std::unique_ptr<BackingStore>&& signature) {
  unsigned int n = GetBytesOfRS(pkey);
  if (n == kNoDsaSignature)
    return std::move(signature);

  std::unique_ptr<BackingStore> buf;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    buf = ArrayBuffer::NewBackingStore(env->isolate(), 2 * n);
  }
  if (!ExtractP1363(static_cast<unsigned char*>(signature->Data()),
                    static_cast<unsigned char*>(buf->Data()),
                    signature->ByteLength(), n))
    return std::move(signature);

  return buf;
}",1,1,crypto\crypto_sig.cc,node.crypto.anonymous_namespace_7.ConvertSignatureToP1363,,false,151,168,ConvertSignatureToP1363,,,7,"unique_ptr<BackingStore> node.crypto.anonymous_namespace_7.ConvertSignatureToP1363 (Environment*,ManagedEVPPKey,ANY)"
55606,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"ByteSource ConvertSignatureToP1363(
    Environment* env,
    const ManagedEVPPKey& pkey,
    const ByteSource& signature) {
  unsigned int n = GetBytesOfRS(pkey);
  if (n == kNoDsaSignature)
    return ByteSource();

  const unsigned char* sig_data = signature.data<unsigned char>();

  ByteSource::Builder out(n * 2);
  memset(out.data<void>(), 0, n * 2);

  if (!ExtractP1363(sig_data, out.data<unsigned char>(), signature.size(), n))
    return ByteSource();

  return std::move(out).release();
}",1,1,crypto\crypto_sig.cc,node.crypto.anonymous_namespace_9.ConvertSignatureToP1363,,false,171,188,ConvertSignatureToP1363,,,8,"ByteSource node.crypto.anonymous_namespace_9.ConvertSignatureToP1363 (Environment*,ManagedEVPPKey,ByteSource)"
55671,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"ByteSource ConvertSignatureToDER(
      const ManagedEVPPKey& pkey,
      ByteSource&& out) {
  unsigned int n = GetBytesOfRS(pkey);
  if (n == kNoDsaSignature)
    return std::move(out);

  const unsigned char* sig_data = out.data<unsigned char>();

  if (out.size() != 2 * n)
    return ByteSource();

  ECDSASigPointer asn1_sig(ECDSA_SIG_new());
  CHECK(asn1_sig);
  BIGNUM* r = BN_new();
  CHECK_NOT_NULL(r);
  BIGNUM* s = BN_new();
  CHECK_NOT_NULL(s);
  CHECK_EQ(r, BN_bin2bn(sig_data, n, r));
  CHECK_EQ(s, BN_bin2bn(sig_data + n, n, s));
  CHECK_EQ(1, ECDSA_SIG_set0(asn1_sig.get(), r, s));

  unsigned char* data = nullptr;
  int len = i2d_ECDSA_SIG(asn1_sig.get(), &data);

  if (len <= 0)
    return ByteSource();

  CHECK_NOT_NULL(data);

  return ByteSource::Allocated(data, len);
}",1,1,crypto\crypto_sig.cc,node.crypto.anonymous_namespace_11.ConvertSignatureToDER,,false,190,221,ConvertSignatureToDER,,,9,"ByteSource node.crypto.anonymous_namespace_11.ConvertSignatureToDER (ManagedEVPPKey,ByteSource)"
55782,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"void CheckThrow(Environment* env, SignBase::Error error) {
  HandleScope scope(env->isolate());

  switch (error) {
    case SignBase::Error::kSignUnknownDigest:
      return THROW_ERR_CRYPTO_INVALID_DIGEST(env);

    case SignBase::Error::kSignNotInitialised:
      return THROW_ERR_CRYPTO_INVALID_STATE(env, ""Not initialised"");

    case SignBase::Error::kSignMalformedSignature:
      return THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""Malformed signature"");

    case SignBase::Error::kSignInit:
    case SignBase::Error::kSignUpdate:
    case SignBase::Error::kSignPrivateKey:
    case SignBase::Error::kSignPublicKey:
      {
        unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
        if (err)
          return ThrowCryptoError(env, err);
        switch (error) {
          case SignBase::Error::kSignInit:
            return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                ""EVP_SignInit_ex failed"");
          case SignBase::Error::kSignUpdate:
            return THROW...",1,1,crypto\crypto_sig.cc,node.crypto.anonymous_namespace_13.CheckThrow,,false,223,265,CheckThrow,,,10,"void node.crypto.anonymous_namespace_13.CheckThrow (Environment*,ANY)"
55914,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"bool IsOneShot(const ManagedEVPPKey& key) {
  switch (EVP_PKEY_id(key.get())) {
    case EVP_PKEY_ED25519:
    case EVP_PKEY_ED448:
      return true;
    default:
      return false;
  }
}",1,1,crypto\crypto_sig.cc,node.crypto.anonymous_namespace_14.IsOneShot,,false,267,275,IsOneShot,,,11,bool node.crypto.anonymous_namespace_14.IsOneShot (ManagedEVPPKey)
55935,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"bool UseP1363Encoding(const ManagedEVPPKey& key,
                      const DSASigEnc& dsa_encoding) {
  switch (EVP_PKEY_id(key.get())) {
    case EVP_PKEY_EC:
    case EVP_PKEY_DSA:
      return dsa_encoding == kSigEncP1363;
    default:
      return false;
  }
}",1,1,crypto\crypto_sig.cc,node.crypto.anonymous_namespace_15.UseP1363Encoding,,false,277,286,UseP1363Encoding,,,12,"bool node.crypto.anonymous_namespace_15.UseP1363Encoding (ManagedEVPPKey,DSASigEnc)"
55959,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"SignBase::Error SignBase::Init(const char* sign_type) {
  CHECK_NULL(mdctx_);
  // Historically, ""dss1"" and ""DSS1"" were DSA aliases for SHA-1
  // exposed through the public API.
  if (strcmp(sign_type, ""dss1"") == 0 ||
      strcmp(sign_type, ""DSS1"") == 0) {
    sign_type = ""SHA1"";
  }
  const EVP_MD* md = EVP_get_digestbyname(sign_type);
  if (md == nullptr)
    return kSignUnknownDigest;

  mdctx_.reset(EVP_MD_CTX_new());
  if (!mdctx_ || !EVP_DigestInit_ex(mdctx_.get(), md, nullptr)) {
    mdctx_.reset();
    return kSignInit;
  }

  return kSignOk;
}",1,1,crypto\crypto_sig.cc,node.crypto.SignBase.Init,,false,289,308,Init,,,2,Error node.crypto.SignBase.Init (char*)
56019,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"SignBase::Error SignBase::Update(const char* data, size_t len) {
  if (mdctx_ == nullptr)
    return kSignNotInitialised;
  if (!EVP_DigestUpdate(mdctx_.get(), data, len))
    return kSignUpdate;
  return kSignOk;
}",1,1,crypto\crypto_sig.cc,node.crypto.SignBase.Update,,false,310,316,Update,,,3,"Error node.crypto.SignBase.Update (char*,size_t)"
56046,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"SignBase::SignBase(Environment* env, Local<Object> wrap)
    : BaseObject(env, wrap) {}",1,30,crypto\crypto_sig.cc,node.crypto.SignBase.SignBase,,false,318,319,SignBase,,,4,"ANY node.crypto.SignBase.SignBase (Environment*,Local<Object>)"
56052,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"void SignBase::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackFieldWithSize(""mdctx"", mdctx_ ? kSizeOf_EVP_MD_CTX : 0);
}",1,1,crypto\crypto_sig.cc,node.crypto.SignBase.MemoryInfo,,false,321,323,MemoryInfo,,,5,void node.crypto.SignBase.MemoryInfo (MemoryTracker*)
56066,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"Sign::Sign(Environment* env, Local<Object> wrap) : SignBase(env, wrap) {
  MakeWeak();
}",1,1,crypto\crypto_sig.cc,node.crypto.Sign.Sign,,false,325,327,Sign,,,6,"ANY node.crypto.Sign.Sign (Environment*,Local<Object>)"
56073,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"void Sign::Initialize(Environment* env, Local<Object> target) {
  Isolate* isolate = env->isolate();
  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);

  t->InstanceTemplate()->SetInternalFieldCount(SignBase::kInternalFieldCount);

  SetProtoMethod(isolate, t, ""init"", SignInit);
  SetProtoMethod(isolate, t, ""update"", SignUpdate);
  SetProtoMethod(isolate, t, ""sign"", SignFinal);

  SetConstructorFunction(env->context(), target, ""Sign"", t);

  SignJob::Initialize(env, target);

  constexpr int kSignJobModeSign = SignConfiguration::kSign;
  constexpr int kSignJobModeVerify = SignConfiguration::kVerify;

  NODE_DEFINE_CONSTANT(target, kSignJobModeSign);
  NODE_DEFINE_CONSTANT(target, kSignJobModeVerify);
  NODE_DEFINE_CONSTANT(target, kSigEncDER);
  NODE_DEFINE_CONSTANT(target, kSigEncP1363);
  NODE_DEFINE_CONSTANT(target, RSA_PKCS1_PSS_PADDING);
}",1,1,crypto\crypto_sig.cc,node.crypto.Sign.Initialize,,false,329,351,Initialize,,,7,"void node.crypto.Sign.Initialize (Environment*,Local<Object>)"
56161,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"void Sign::RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(New);
  registry->Register(SignInit);
  registry->Register(SignUpdate);
  registry->Register(SignFinal);
  SignJob::RegisterExternalReferences(registry);
}",1,1,crypto\crypto_sig.cc,node.crypto.Sign.RegisterExternalReferences,,false,353,359,RegisterExternalReferences,,,8,void node.crypto.Sign.RegisterExternalReferences (ExternalReferenceRegistry*)
56191,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"void Sign::New(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  new Sign(env, args.This());
}",1,1,crypto\crypto_sig.cc,node.crypto.Sign.New,,false,361,364,New,,,9,void node.crypto.Sign.New (FunctionCallbackInfo<Value>)
56211,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"void Sign::SignInit(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Sign* sign;
  ASSIGN_OR_RETURN_UNWRAP(&sign, args.Holder());

  const node::Utf8Value sign_type(args.GetIsolate(), args[0]);
  crypto::CheckThrow(env, sign->Init(*sign_type));
}",1,1,crypto\crypto_sig.cc,node.crypto.Sign.SignInit,,false,366,373,SignInit,,,10,void node.crypto.Sign.SignInit (FunctionCallbackInfo<Value>)
56252,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"void Sign::SignUpdate(const FunctionCallbackInfo<Value>& args) {
  Decode<Sign>(args, [](Sign* sign, const FunctionCallbackInfo<Value>& args,
                        const char* data, size_t size) {
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    Error err = sign->Update(data, size);
    crypto::CheckThrow(sign->env(), err);
  });
}",1,1,crypto\crypto_sig.cc,node.crypto.Sign.SignUpdate,,false,375,384,SignUpdate,,,11,void node.crypto.Sign.SignUpdate (FunctionCallbackInfo<Value>)
56264,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"Sign::SignResult Sign::SignFinal(
    const ManagedEVPPKey& pkey,
    int padding,
    const Maybe<int>& salt_len,
    DSASigEnc dsa_sig_enc) {
  if (!mdctx_)
    return SignResult(kSignNotInitialised);

  EVPMDPointer mdctx = std::move(mdctx_);

  if (!ValidateDSAParameters(pkey.get()))
    return SignResult(kSignPrivateKey);

  std::unique_ptr<BackingStore> buffer =
      Node_SignFinal(env(), std::move(mdctx), pkey, padding, salt_len);
  Error error = buffer ? kSignOk : kSignPrivateKey;
  if (error == kSignOk && dsa_sig_enc == kSigEncP1363) {
    buffer = ConvertSignatureToP1363(env(), pkey, std::move(buffer));
    CHECK_NOT_NULL(buffer->Data());
  }
  return SignResult(error, std::move(buffer));
}",1,1,crypto\crypto_sig.cc,node.crypto.Sign.SignFinal,,false,386,407,SignFinal,,,12,"SignResult node.crypto.Sign.SignFinal (ManagedEVPPKey,int,Maybe<int>,DSASigEnc)"
56355,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"void Sign::SignFinal(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Sign* sign;
  ASSIGN_OR_RETURN_UNWRAP(&sign, args.Holder());

  ClearErrorOnReturn clear_error_on_return;

  unsigned int offset = 0;
  ManagedEVPPKey key = ManagedEVPPKey::GetPrivateKeyFromJs(args, &offset, true);
  if (!key)
    return;

  int padding = GetDefaultSignPadding(key);
  if (!args[offset]->IsUndefined()) {
    CHECK(args[offset]->IsInt32());
    padding = args[offset].As<Int32>()->Value();
  }

  Maybe<int> salt_len = Nothing<int>();
  if (!args[offset + 1]->IsUndefined()) {
    CHECK(args[offset + 1]->IsInt32());
    salt_len = Just<int>(args[offset + 1].As<Int32>()->Value());
  }

  CHECK(args[offset + 2]->IsInt32());
  DSASigEnc dsa_sig_enc =
      static_cast<DSASigEnc>(args[offset + 2].As<Int32>()->Value());

  SignResult ret = sign->SignFinal(
      key,
      padding,
      salt_len,
      dsa_sig_enc);

  if (ret.error != kSignOk)
    return cry...",1,1,crypto\crypto_sig.cc,node.crypto.Sign.SignFinal,,false,409,450,SignFinal,,,13,void node.crypto.Sign.SignFinal (FunctionCallbackInfo<Value>)
56562,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"Verify::Verify(Environment* env, Local<Object> wrap)
  : SignBase(env, wrap) {
  MakeWeak();
}",1,1,crypto\crypto_sig.cc,node.crypto.Verify.Verify,,false,452,455,Verify,,,14,"ANY node.crypto.Verify.Verify (Environment*,Local<Object>)"
56569,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"void Verify::Initialize(Environment* env, Local<Object> target) {
  Isolate* isolate = env->isolate();
  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);

  t->InstanceTemplate()->SetInternalFieldCount(SignBase::kInternalFieldCount);

  SetProtoMethod(isolate, t, ""init"", VerifyInit);
  SetProtoMethod(isolate, t, ""update"", VerifyUpdate);
  SetProtoMethod(isolate, t, ""verify"", VerifyFinal);

  SetConstructorFunction(env->context(), target, ""Verify"", t);
}",1,1,crypto\crypto_sig.cc,node.crypto.Verify.Initialize,,false,457,468,Initialize,,,15,"void node.crypto.Verify.Initialize (Environment*,Local<Object>)"
56624,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"void Verify::RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(New);
  registry->Register(VerifyInit);
  registry->Register(VerifyUpdate);
  registry->Register(VerifyFinal);
}",1,1,crypto\crypto_sig.cc,node.crypto.Verify.RegisterExternalReferences,,false,470,475,RegisterExternalReferences,,,16,void node.crypto.Verify.RegisterExternalReferences (ExternalReferenceRegistry*)
56649,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"void Verify::New(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  new Verify(env, args.This());
}",1,1,crypto\crypto_sig.cc,node.crypto.Verify.New,,false,477,480,New,,,17,void node.crypto.Verify.New (FunctionCallbackInfo<Value>)
56669,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"void Verify::VerifyInit(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Verify* verify;
  ASSIGN_OR_RETURN_UNWRAP(&verify, args.Holder());

  const node::Utf8Value verify_type(args.GetIsolate(), args[0]);
  crypto::CheckThrow(env, verify->Init(*verify_type));
}",1,1,crypto\crypto_sig.cc,node.crypto.Verify.VerifyInit,,false,482,489,VerifyInit,,,18,void node.crypto.Verify.VerifyInit (FunctionCallbackInfo<Value>)
56710,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"void Verify::VerifyUpdate(const FunctionCallbackInfo<Value>& args) {
  Decode<Verify>(args, [](Verify* verify,
                          const FunctionCallbackInfo<Value>& args,
                          const char* data, size_t size) {
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    Error err = verify->Update(data, size);
    crypto::CheckThrow(verify->env(), err);
  });
}",1,1,crypto\crypto_sig.cc,node.crypto.Verify.VerifyUpdate,,false,491,501,VerifyUpdate,,,19,void node.crypto.Verify.VerifyUpdate (FunctionCallbackInfo<Value>)
56722,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"SignBase::Error Verify::VerifyFinal(const ManagedEVPPKey& pkey,
                                    const ByteSource& sig,
                                    int padding,
                                    const Maybe<int>& saltlen,
                                    bool* verify_result) {
  if (!mdctx_)
    return kSignNotInitialised;

  unsigned char m[EVP_MAX_MD_SIZE];
  unsigned int m_len;
  *verify_result = false;
  EVPMDPointer mdctx = std::move(mdctx_);

  if (!EVP_DigestFinal_ex(mdctx.get(), m, &m_len))
    return kSignPublicKey;

  EVPKeyCtxPointer pkctx(EVP_PKEY_CTX_new(pkey.get(), nullptr));
  if (pkctx &&
      EVP_PKEY_verify_init(pkctx.get()) > 0 &&
      ApplyRSAOptions(pkey, pkctx.get(), padding, saltlen) &&
      EVP_PKEY_CTX_set_signature_md(pkctx.get(),
                                    EVP_MD_CTX_md(mdctx.get())) > 0) {
    const unsigned char* s = sig.data<unsigned char>();
    const int r = EVP_PKEY_verify(pkctx.get(), s, sig.size(), m, m_len);
    *verify...",1,1,crypto\crypto_sig.cc,node.crypto.Verify.VerifyFinal,,false,503,531,VerifyFinal,,,20,"Error node.crypto.Verify.VerifyFinal (ManagedEVPPKey,ByteSource,int,Maybe<int>,bool*)"
56835,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"void Verify::VerifyFinal(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  ClearErrorOnReturn clear_error_on_return;

  Verify* verify;
  ASSIGN_OR_RETURN_UNWRAP(&verify, args.Holder());

  unsigned int offset = 0;
  ManagedEVPPKey pkey =
      ManagedEVPPKey::GetPublicOrPrivateKeyFromJs(args, &offset);
  if (!pkey)
    return;

  ArrayBufferOrViewContents<char> hbuf(args[offset]);
  if (UNLIKELY(!hbuf.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""buffer is too big"");

  int padding = GetDefaultSignPadding(pkey);
  if (!args[offset + 1]->IsUndefined()) {
    CHECK(args[offset + 1]->IsInt32());
    padding = args[offset + 1].As<Int32>()->Value();
  }

  Maybe<int> salt_len = Nothing<int>();
  if (!args[offset + 2]->IsUndefined()) {
    CHECK(args[offset + 2]->IsInt32());
    salt_len = Just<int>(args[offset + 2].As<Int32>()->Value());
  }

  CHECK(args[offset + 3]->IsInt32());
  DSASigEnc dsa_sig_enc =
      static_cast<DSAS...",1,1,crypto\crypto_sig.cc,node.crypto.Verify.VerifyFinal,,false,533,579,VerifyFinal,,,21,void node.crypto.Verify.VerifyFinal (FunctionCallbackInfo<Value>)
57065,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"SignConfiguration::SignConfiguration(SignConfiguration&& other) noexcept
    : job_mode(other.job_mode),
      mode(other.mode),
      key(std::move(other.key)),
      data(std::move(other.data)),
      signature(std::move(other.signature)),
      digest(other.digest),
      flags(other.flags),
      padding(other.padding),
      salt_length(other.salt_length),
      dsa_encoding(other.dsa_encoding) {}",1,41,crypto\crypto_sig.cc,node.crypto.SignConfiguration.SignConfiguration,,false,581,591,SignConfiguration,,,22,ANY node.crypto.SignConfiguration.SignConfiguration (SignConfiguration)
57070,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"SignConfiguration& SignConfiguration::operator=(
    SignConfiguration&& other) noexcept {
  if (&other == this) return *this;
  this->~SignConfiguration();
  return *new (this) SignConfiguration(std::move(other));
}",1,1,crypto\crypto_sig.cc,node.crypto.SignConfiguration.operator =,,false,593,598,operator =,,,23,SignConfiguration node.crypto.SignConfiguration.operator = (SignConfiguration)
57098,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"void SignConfiguration::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""key"", key);
  if (job_mode == kCryptoJobAsync) {
    tracker->TrackFieldWithSize(""data"", data.size());
    tracker->TrackFieldWithSize(""signature"", signature.size());
  }
}",1,1,crypto\crypto_sig.cc,node.crypto.SignConfiguration.MemoryInfo,,false,600,606,MemoryInfo,,,24,void node.crypto.SignConfiguration.MemoryInfo (MemoryTracker*)
57132,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"Maybe<bool> SignTraits::AdditionalConfig(
    CryptoJobMode mode,
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset,
    SignConfiguration* params) {
  ClearErrorOnReturn clear_error_on_return;
  Environment* env = Environment::GetCurrent(args);

  params->job_mode = mode;

  CHECK(args[offset]->IsUint32());  // Sign Mode

  params->mode =
      static_cast<SignConfiguration::Mode>(args[offset].As<Uint32>()->Value());

  ManagedEVPPKey key;
  unsigned int keyParamOffset = offset + 1;
  if (params->mode == SignConfiguration::kVerify) {
    key = ManagedEVPPKey::GetPublicOrPrivateKeyFromJs(args, &keyParamOffset);
  } else {
    key = ManagedEVPPKey::GetPrivateKeyFromJs(args, &keyParamOffset, true);
  }
  if (!key)
    return Nothing<bool>();
  params->key = key;

  ArrayBufferOrViewContents<char> data(args[offset + 5]);
  if (UNLIKELY(!data.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""data is too big"");
    return Nothing<bool>();
  }
  params->data = mode ...",1,1,crypto\crypto_sig.cc,node.crypto.SignTraits.AdditionalConfig,,false,608,692,AdditionalConfig,,,25,"Maybe<bool> node.crypto.SignTraits.AdditionalConfig (CryptoJobMode,FunctionCallbackInfo<Value>,unsigned int,SignConfiguration*)"
57491,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"bool SignTraits::DeriveBits(
    Environment* env,
    const SignConfiguration& params,
    ByteSource* out) {
  ClearErrorOnReturn clear_error_on_return;
  EVPMDPointer context(EVP_MD_CTX_new());
  EVP_PKEY_CTX* ctx = nullptr;

  switch (params.mode) {
    case SignConfiguration::kSign:
      if (!EVP_DigestSignInit(
              context.get(),
              &ctx,
              params.digest,
              nullptr,
              params.key.get())) {
        crypto::CheckThrow(env, SignBase::Error::kSignInit);
        return false;
      }
      break;
    case SignConfiguration::kVerify:
      if (!EVP_DigestVerifyInit(
              context.get(),
              &ctx,
              params.digest,
              nullptr,
              params.key.get())) {
        crypto::CheckThrow(env, SignBase::Error::kSignInit);
        return false;
      }
      break;
  }

  int padding = params.flags & SignConfiguration::kHasPadding
      ? params.padding
      : GetDefaultSignPadding(params....",1,1,crypto\crypto_sig.cc,node.crypto.SignTraits.DeriveBits,,false,694,808,DeriveBits,,,26,"bool node.crypto.SignTraits.DeriveBits (Environment*,SignConfiguration,ByteSource*)"
57930,METHOD,crypto\crypto_sig.cc:<global>,TYPE_DECL,"Maybe<bool> SignTraits::EncodeOutput(
    Environment* env,
    const SignConfiguration& params,
    ByteSource* out,
    Local<Value>* result) {
  switch (params.mode) {
    case SignConfiguration::kSign:
      *result = out->ToArrayBuffer(env);
      break;
    case SignConfiguration::kVerify:
      *result = Boolean::New(env->isolate(), out->data<char>()[0] == 1);
      break;
    default:
      UNREACHABLE();
  }
  return Just(!result->IsEmpty());
}",1,1,crypto\crypto_sig.cc,node.crypto.SignTraits.EncodeOutput,,false,810,826,EncodeOutput,,,27,"Maybe<bool> node.crypto.SignTraits.EncodeOutput (Environment*,SignConfiguration,ByteSource*,Local<Value>*)"
58002,METHOD,crypto\crypto_sig.hpp:<global>,TYPE_DECL,<global>,1,35,crypto\crypto_sig.hpp,crypto\crypto_sig.hpp:<global>,,false,1,168,<global>,,,1,
58021,METHOD,crypto\crypto_spkac.cc:<global>,TYPE_DECL,<global>,1,37,crypto\crypto_spkac.hpp,crypto\crypto_spkac.cc:<global>,,false,1,144,<global>,,,1,
58026,METHOD,crypto\crypto_spkac.cc:<global>,TYPE_DECL,"bool VerifySpkac(const ArrayBufferOrViewContents<char>& input) {
  size_t length = input.size();
#ifdef OPENSSL_IS_BORINGSSL
  // OpenSSL uses EVP_DecodeBlock, which explicitly removes trailing characters,
  // while BoringSSL uses EVP_DecodedLength and EVP_DecodeBase64, which do not.
  // As such, we trim those characters here for compatibility.
  length = std::string(input.data()).find_last_not_of("" \n\r\t"") + 1;
#endif
  NetscapeSPKIPointer spki(
      NETSCAPE_SPKI_b64_decode(input.data(), length));
  if (!spki)
    return false;

  EVPKeyPointer pkey(X509_PUBKEY_get(spki->spkac->pubkey));
  if (!pkey)
    return false;

  return NETSCAPE_SPKI_verify(spki.get(), pkey.get()) > 0;
}",1,1,crypto\crypto_spkac.cc,node.crypto.SPKAC.VerifySpkac,,false,19,37,VerifySpkac,,,1,bool node.crypto.SPKAC.VerifySpkac (ArrayBufferOrViewContents<char>)
58078,METHOD,crypto\crypto_spkac.cc:<global>,TYPE_DECL,"void VerifySpkac(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  ArrayBufferOrViewContents<char> input(args[0]);
  if (input.size() == 0)
    return args.GetReturnValue().SetEmptyString();

  if (UNLIKELY(!input.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""spkac is too large"");

  args.GetReturnValue().Set(VerifySpkac(input));
}",1,1,crypto\crypto_spkac.cc,node.crypto.SPKAC.VerifySpkac,,false,39,49,VerifySpkac,,,2,void node.crypto.SPKAC.VerifySpkac (FunctionCallbackInfo<Value>)
58133,METHOD,crypto\crypto_spkac.cc:<global>,TYPE_DECL,"ByteSource ExportPublicKey(Environment* env,
                           const ArrayBufferOrViewContents<char>& input) {
  BIOPointer bio(BIO_new(BIO_s_mem()));
  if (!bio) return ByteSource();

  size_t length = input.size();
#ifdef OPENSSL_IS_BORINGSSL
  // OpenSSL uses EVP_DecodeBlock, which explicitly removes trailing characters,
  // while BoringSSL uses EVP_DecodedLength and EVP_DecodeBase64, which do not.
  // As such, we trim those characters here for compatibility.
  length = std::string(input.data()).find_last_not_of("" \n\r\t"") + 1;
#endif
  NetscapeSPKIPointer spki(
      NETSCAPE_SPKI_b64_decode(input.data(), length));
  if (!spki) return ByteSource();

  EVPKeyPointer pkey(NETSCAPE_SPKI_get_pubkey(spki.get()));
  if (!pkey) return ByteSource();

  if (PEM_write_bio_PUBKEY(bio.get(), pkey.get()) <= 0) return ByteSource();

  return ByteSource::FromBIO(bio);
}",1,1,crypto\crypto_spkac.cc,node.crypto.SPKAC.ExportPublicKey,,false,51,73,ExportPublicKey,,,3,"ByteSource node.crypto.SPKAC.ExportPublicKey (Environment*,ArrayBufferOrViewContents<char>)"
58137,METHOD,crypto\crypto_spkac.cc:<global>,TYPE_DECL,BIOPointer bio(BIO_new(BIO_s_mem()));,14,38,crypto\crypto_spkac.cc,node.crypto.SPKAC.ExportPublicKey.bio,,false,53,53,bio,,,1,BIOPointer node.crypto.SPKAC.ExportPublicKey.bio (BIO_new)
58205,METHOD,crypto\crypto_spkac.cc:<global>,TYPE_DECL,"void ExportPublicKey(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  ArrayBufferOrViewContents<char> input(args[0]);
  if (input.size() == 0) return args.GetReturnValue().SetEmptyString();

  if (UNLIKELY(!input.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""spkac is too large"");

  ByteSource pkey = ExportPublicKey(env, input);
  if (!pkey) return args.GetReturnValue().SetEmptyString();

  args.GetReturnValue().Set(pkey.ToBuffer(env).FromMaybe(Local<Value>()));
}",1,1,crypto\crypto_spkac.cc,node.crypto.SPKAC.ExportPublicKey,,false,75,88,ExportPublicKey,,,4,void node.crypto.SPKAC.ExportPublicKey (FunctionCallbackInfo<Value>)
58285,METHOD,crypto\crypto_spkac.cc:<global>,TYPE_DECL,"ByteSource ExportChallenge(const ArrayBufferOrViewContents<char>& input) {
  size_t length = input.size();
#ifdef OPENSSL_IS_BORINGSSL
  // OpenSSL uses EVP_DecodeBlock, which explicitly removes trailing characters,
  // while BoringSSL uses EVP_DecodedLength and EVP_DecodeBase64, which do not.
  // As such, we trim those characters here for compatibility.
  length = std::string(input.data()).find_last_not_of("" \n\r\t"") + 1;
#endif
  NetscapeSPKIPointer sp(
      NETSCAPE_SPKI_b64_decode(input.data(), length));
  if (!sp)
    return ByteSource();

  unsigned char* buf = nullptr;
  int buf_size = ASN1_STRING_to_UTF8(&buf, sp->spkac->challenge);
  return (buf_size >= 0) ? ByteSource::Allocated(buf, buf_size) : ByteSource();
}",1,1,crypto\crypto_spkac.cc,node.crypto.SPKAC.ExportChallenge,,false,90,106,ExportChallenge,,,5,ByteSource node.crypto.SPKAC.ExportChallenge (ArrayBufferOrViewContents<char>)
58338,METHOD,crypto\crypto_spkac.cc:<global>,TYPE_DECL,"void ExportChallenge(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  ArrayBufferOrViewContents<char> input(args[0]);
  if (input.size() == 0)
    return args.GetReturnValue().SetEmptyString();

  if (UNLIKELY(!input.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""spkac is too large"");

  ByteSource cert = ExportChallenge(input);
  if (!cert)
    return args.GetReturnValue().SetEmptyString();

  Local<Value> outString =
      Encode(env->isolate(), cert.data<char>(), cert.size(), BUFFER);

  args.GetReturnValue().Set(outString);
}",1,1,crypto\crypto_spkac.cc,node.crypto.SPKAC.ExportChallenge,,false,108,126,ExportChallenge,,,6,void node.crypto.SPKAC.ExportChallenge (FunctionCallbackInfo<Value>)
58429,METHOD,crypto\crypto_spkac.cc:<global>,TYPE_DECL,"void Initialize(Environment* env, Local<Object> target) {
  Local<Context> context = env->context();
  SetMethodNoSideEffect(context, target, ""certVerifySpkac"", VerifySpkac);
  SetMethodNoSideEffect(
      context, target, ""certExportPublicKey"", ExportPublicKey);
  SetMethodNoSideEffect(
      context, target, ""certExportChallenge"", ExportChallenge);
}",1,1,crypto\crypto_spkac.cc,node.crypto.SPKAC.Initialize,,false,128,135,Initialize,,,7,"void node.crypto.SPKAC.Initialize (Environment*,Local<Object>)"
58460,METHOD,crypto\crypto_spkac.cc:<global>,TYPE_DECL,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(VerifySpkac);
  registry->Register(ExportPublicKey);
  registry->Register(ExportChallenge);
}",1,1,crypto\crypto_spkac.cc,node.crypto.SPKAC.RegisterExternalReferences,,false,137,141,RegisterExternalReferences,,,8,void node.crypto.SPKAC.RegisterExternalReferences (ExternalReferenceRegistry*)
58489,METHOD,crypto\crypto_spkac.hpp:<global>,TYPE_DECL,<global>,1,37,crypto\crypto_spkac.hpp,crypto\crypto_spkac.hpp:<global>,,false,1,21,<global>,,,1,
58508,METHOD,crypto\crypto_timing.cc:<global>,TYPE_DECL,<global>,1,38,crypto\crypto_timing.hpp,crypto\crypto_timing.cc:<global>,,false,1,59,<global>,,,1,
58513,METHOD,crypto\crypto_timing.cc:<global>,TYPE_DECL,"void TimingSafeEqual(const FunctionCallbackInfo<Value>& args) {
  // Moving the type checking into JS leads to test failures, most likely due
  // to V8 inlining certain parts of the wrapper. Therefore, keep them in C++.
  // Refs: https://github.com/nodejs/node/issues/34073.
  Environment* env = Environment::GetCurrent(args);
  if (!IsAnyByteSource(args[0])) {
    THROW_ERR_INVALID_ARG_TYPE(
      env, ""The \""buf1\"" argument must be an instance of ""
      ""ArrayBuffer, Buffer, TypedArray, or DataView."");
    return;
  }
  if (!IsAnyByteSource(args[1])) {
    THROW_ERR_INVALID_ARG_TYPE(
      env, ""The \""buf2\"" argument must be an instance of ""
      ""ArrayBuffer, Buffer, TypedArray, or DataView."");
    return;
  }

  ArrayBufferOrViewContents<char> buf1(args[0]);
  ArrayBufferOrViewContents<char> buf2(args[1]);

  if (buf1.size() != buf2.size()) {
    THROW_ERR_CRYPTO_TIMING_SAFE_EQUAL_LENGTH(env);
    return;
  }

  return args.GetReturnValue().Set(
      CRYPTO_memcmp(buf1.data()...",1,1,crypto\crypto_timing.cc,node.crypto.Timing.TimingSafeEqual,,false,19,47,TimingSafeEqual,,,1,void node.crypto.Timing.TimingSafeEqual (FunctionCallbackInfo<Value>)
58595,METHOD,crypto\crypto_timing.cc:<global>,TYPE_DECL,"void Initialize(Environment* env, Local<Object> target) {
  SetMethodNoSideEffect(
      env->context(), target, ""timingSafeEqual"", TimingSafeEqual);
}",1,1,crypto\crypto_timing.cc,node.crypto.Timing.Initialize,,false,49,52,Initialize,,,2,"void node.crypto.Timing.Initialize (Environment*,Local<Object>)"
58609,METHOD,crypto\crypto_timing.cc:<global>,TYPE_DECL,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(TimingSafeEqual);
}",1,1,crypto\crypto_timing.cc,node.crypto.Timing.RegisterExternalReferences,,false,53,55,RegisterExternalReferences,,,3,void node.crypto.Timing.RegisterExternalReferences (ExternalReferenceRegistry*)
58626,METHOD,crypto\crypto_timing.hpp:<global>,TYPE_DECL,<global>,1,38,crypto\crypto_timing.hpp,crypto\crypto_timing.hpp:<global>,,false,1,20,<global>,,,1,
58629,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"[](const char* str, size_t len, void* opaque) {
        static_cast<std::string*>(opaque)->assign(str, len);
        return 0;
      }",7,7,crypto\crypto_tls.cc,node.crypto.anonymous_namespace_12.GetBIOError.<lambda>0,,false,347,350,<lambda>0,,,1,"ANY node.crypto.anonymous_namespace_12.GetBIOError.<lambda>0 (char*,size_t,void*)"
58648,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"[this, strong_ref](Environment* env) {
          InvokeQueued(0);
        }",29,9,crypto\crypto_tls.cc,node.crypto.TLSWrap.EncOut.<lambda>1,,false,629,631,<lambda>1,,,1,ANY node.crypto.TLSWrap.EncOut.<lambda>1 (Environment*)
58656,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"[this, strong_ref](Environment* env) {
      OnStreamAfterWrite(nullptr, 0);
    }",25,5,crypto\crypto_tls.cc,node.crypto.TLSWrap.EncOut.<lambda>2,,false,661,663,<lambda>2,,,1,ANY node.crypto.TLSWrap.EncOut.<lambda>2 (Environment*)
58665,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,[](char c) { return c == ' ' ? '_' : ToUpper(c); },26,75,crypto\crypto_tls.cc,node.crypto.TLSWrap.ClearOut.<lambda>3,,false,807,807,<lambda>3,,,1,ANY node.crypto.TLSWrap.ClearOut.<lambda>3 (char)
58679,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"[this, strong_ref](Environment* env) {
          OnStreamAfterWrite(WriteWrap::FromObject(current_empty_write_), 0);
        }",29,9,crypto\crypto_tls.cc,node.crypto.TLSWrap.DoWrite.<lambda>4,,false,974,976,<lambda>4,,,1,ANY node.crypto.TLSWrap.DoWrite.<lambda>4 (Environment*)
58692,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"[](int write_p, int version, int
          content_type, const void* buf, size_t len, SSL* ssl, void* arg)
        -> void {
        // BIO_write(), etc., called by SSL_trace, may error. The error should
        // be ignored, trace is a ""best effort"", and its usually because stderr
        // is a non-blocking pipe, and its buffer has overflowed. Leaving errors
        // on the stack that can get picked up by later SSL_ calls causes
        // unwanted failures in SSL_ calls, so keep the error stack unchanged.
        MarkPopErrorOnReturn mark_pop_error_on_return;
        SSL_trace(write_p,  version, content_type, buf, len, ssl, arg);
    }",44,5,crypto\crypto_tls.cc,node.crypto.TLSWrap.EnableTrace.<lambda>5,,false,1203,1213,<lambda>5,,,1,"void node.crypto.TLSWrap.EnableTrace.<lambda>5 (int,int,int,void*,size_t,SSL*,void*)"
58740,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,<global>,1,1,crypto\crypto_tls.cc,crypto\crypto_tls.cc:<global>,,false,1,2199,<global>,,,1,
58745,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"SSL_SESSION* GetSessionCallback(
    SSL* s,
    const unsigned char* key,
    int len,
    int* copy) {
  TLSWrap* w = static_cast<TLSWrap*>(SSL_get_app_data(s));
  *copy = 0;
  return w->ReleaseSession();
}",1,1,crypto\crypto_tls.cc,node.crypto.anonymous_namespace_1.GetSessionCallback,,false,67,75,GetSessionCallback,,,1,"SSL_SESSION node.crypto.anonymous_namespace_1.GetSessionCallback (SSL*,unsigned char*,int,int*)"
58769,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void OnClientHello(
    void* arg,
    const ClientHelloParser::ClientHello& hello) {
  TLSWrap* w = static_cast<TLSWrap*>(arg);
  Environment* env = w->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Object> hello_obj = Object::New(env->isolate());
  Local<String> servername = (hello.servername() == nullptr)
      ? String::Empty(env->isolate())
      : OneByteString(env->isolate(),
                      hello.servername(),
                      hello.servername_size());
  Local<Object> buf =
      Buffer::Copy(
          env,
          reinterpret_cast<const char*>(hello.session_id()),
          hello.session_size()).FromMaybe(Local<Object>());

  if ((buf.IsEmpty() ||
       hello_obj->Set(env->context(), env->session_id_string(), buf)
           .IsNothing()) ||
      hello_obj->Set(env->context(), env->servername_string(), servername)
          .IsNothing() ||
      hello_obj
          ->Set(env->context(),
           ...",1,1,crypto\crypto_tls.cc,node.crypto.anonymous_namespace_2.OnClientHello,,false,77,112,OnClientHello,,,2,"void node.crypto.anonymous_namespace_2.OnClientHello (void*,ANY)"
58958,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void KeylogCallback(const SSL* s, const char* line) {
  TLSWrap* w = static_cast<TLSWrap*>(SSL_get_app_data(s));
  Environment* env = w->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  const size_t size = strlen(line);
  Local<Value> line_bf = Buffer::Copy(env, line, 1 + size)
      .FromMaybe(Local<Value>());
  if (UNLIKELY(line_bf.IsEmpty()))
    return;

  char* data = Buffer::Data(line_bf);
  data[size] = '\n';
  w->MakeCallback(env->onkeylog_string(), 1, &line_bf);
}",1,1,crypto\crypto_tls.cc,node.crypto.anonymous_namespace_3.KeylogCallback,,false,114,129,KeylogCallback,,,3,"void node.crypto.anonymous_namespace_3.KeylogCallback (SSL*,char*)"
59046,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"int NewSessionCallback(SSL* s, SSL_SESSION* sess) {
  TLSWrap* w = static_cast<TLSWrap*>(SSL_get_app_data(s));
  Environment* env = w->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  if (!w->has_session_callbacks())
    return 0;

  // Check if session is small enough to be stored
  int size = i2d_SSL_SESSION(sess, nullptr);
  if (UNLIKELY(size > SecureContext::kMaxSessionSize))
    return 0;

  // Serialize session
  Local<Object> session = Buffer::New(env, size).FromMaybe(Local<Object>());
  if (UNLIKELY(session.IsEmpty()))
    return 0;

  unsigned char* session_data =
      reinterpret_cast<unsigned char*>(Buffer::Data(session));

  CHECK_EQ(i2d_SSL_SESSION(sess, &session_data), size);

  unsigned int session_id_length;
  const unsigned char* session_id_data =
      SSL_SESSION_get_id(sess, &session_id_length);

  Local<Object> session_id = Buffer::Copy(
      env,
      reinterpret_cast<const char*>(session_id_data),
      s...",1,1,crypto\crypto_tls.cc,node.crypto.anonymous_namespace_4.NewSessionCallback,,false,131,179,NewSessionCallback,,,4,"int node.crypto.anonymous_namespace_4.NewSessionCallback (SSL*,SSL_SESSION*)"
59210,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"int SSLCertCallback(SSL* s, void* arg) {
  TLSWrap* w = static_cast<TLSWrap*>(SSL_get_app_data(s));

  if (!w->is_server() || !w->is_waiting_cert_cb())
    return 1;

  if (w->is_cert_cb_running())
    // Not an error. Suspend handshake with SSL_ERROR_WANT_X509_LOOKUP, and
    // handshake will continue after certcb is done.
    return -1;

  Environment* env = w->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());
  w->set_cert_cb_running();

  Local<Object> info = Object::New(env->isolate());

  const char* servername = GetServerName(s);
  Local<String> servername_str = (servername == nullptr)
      ? String::Empty(env->isolate())
      : OneByteString(env->isolate(), servername, strlen(servername));

  Local<Value> ocsp = Boolean::New(
      env->isolate(), SSL_get_tlsext_status_type(s) == TLSEXT_STATUSTYPE_ocsp);

  if (info->Set(env->context(), env->servername_string(), servername_str)
          .IsNothing() ||
      info->Set(env-...",1,1,crypto\crypto_tls.cc,node.crypto.anonymous_namespace_5.SSLCertCallback,,false,181,217,SSLCertCallback,,,5,"int node.crypto.anonymous_namespace_5.SSLCertCallback (SSL*,void*)"
59395,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"int SelectALPNCallback(
    SSL* s,
    const unsigned char** out,
    unsigned char* outlen,
    const unsigned char* in,
    unsigned int inlen,
    void* arg) {
  TLSWrap* w = static_cast<TLSWrap*>(arg);
  if (w->alpn_callback_enabled_) {
    Environment* env = w->env();
    HandleScope handle_scope(env->isolate());

    Local<Value> callback_arg =
        Buffer::Copy(env, reinterpret_cast<const char*>(in), inlen)
            .ToLocalChecked();

    MaybeLocal<Value> maybe_callback_result =
        w->MakeCallback(env->alpn_callback_string(), 1, &callback_arg);

    if (UNLIKELY(maybe_callback_result.IsEmpty())) {
      // Implies the callback didn't return, because some exception was thrown
      // during processing, e.g. if callback returned an invalid ALPN value.
      return SSL_TLSEXT_ERR_ALERT_FATAL;
    }

    Local<Value> callback_result = maybe_callback_result.ToLocalChecked();

    if (callback_result->IsUndefined()) {
      // If you set an ALPN callback, but you ret...",1,1,crypto\crypto_tls.cc,node.crypto.anonymous_namespace_6.SelectALPNCallback,,false,219,283,SelectALPNCallback,,,6,"int node.crypto.anonymous_namespace_6.SelectALPNCallback (SSL*,unsigned char**,unsigned char*,unsigned char*,unsigned int,void*)"
59562,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"int TLSExtStatusCallback(SSL* s, void* arg) {
  TLSWrap* w = static_cast<TLSWrap*>(SSL_get_app_data(s));
  Environment* env = w->env();
  HandleScope handle_scope(env->isolate());

  if (w->is_client()) {
    // Incoming response
    Local<Value> arg;
    if (GetSSLOCSPResponse(env, s, Null(env->isolate())).ToLocal(&arg))
      w->MakeCallback(env->onocspresponse_string(), 1, &arg);

    // No async acceptance is possible, so always return 1 to accept the
    // response.  The listener for 'OCSPResponse' event has no control over
    // return value, but it can .destroy() the connection if the response is not
    // acceptable.
    return 1;
  }

  // Outgoing response
  Local<ArrayBufferView> obj =
      w->ocsp_response().FromMaybe(Local<ArrayBufferView>());
  if (UNLIKELY(obj.IsEmpty()))
    return SSL_TLSEXT_ERR_NOACK;

  size_t len = obj->ByteLength();

  // OpenSSL takes control of the pointer after accepting it
  unsigned char* data = MallocOpenSSL<unsigned char>(len);
  obj-...",1,1,crypto\crypto_tls.cc,node.crypto.anonymous_namespace_7.TLSExtStatusCallback,,false,285,321,TLSExtStatusCallback,,,7,"int node.crypto.anonymous_namespace_7.TLSExtStatusCallback (SSL*,void*)"
59683,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void ConfigureSecureContext(SecureContext* sc) {
  // OCSP stapling
  SSL_CTX_set_tlsext_status_cb(sc->ctx().get(), TLSExtStatusCallback);
  SSL_CTX_set_tlsext_status_arg(sc->ctx().get(), nullptr);
}",1,1,crypto\crypto_tls.cc,node.crypto.anonymous_namespace_8.ConfigureSecureContext,,false,323,327,ConfigureSecureContext,,,8,void node.crypto.anonymous_namespace_8.ConfigureSecureContext (SecureContext*)
59706,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"inline bool Set(
    Environment* env,
    Local<Object> target,
    Local<String> name,
    const char* value,
    bool ignore_null = true) {
  if (value == nullptr)
    return ignore_null;
  return !target->Set(
      env->context(),
      name,
      OneByteString(env->isolate(), value))
          .IsNothing();
}",1,1,crypto\crypto_tls.cc,node.crypto.anonymous_namespace_10.Set,,false,329,342,Set,,,9,"bool node.crypto.anonymous_namespace_10.Set (Environment*,Local<Object>,Local<String>,char*,bool)"
59742,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"std::string GetBIOError() {
  std::string ret;
  ERR_print_errors_cb(
      [](const char* str, size_t len, void* opaque) {
        static_cast<std::string*>(opaque)->assign(str, len);
        return 0;
      },
      static_cast<void*>(&ret));
  return ret;
}",1,1,crypto\crypto_tls.cc,node.crypto.anonymous_namespace_11.GetBIOError,,false,344,353,GetBIOError,,,10,string node.crypto.anonymous_namespace_11.GetBIOError ()
59755,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"TLSWrap::TLSWrap(Environment* env,
                 Local<Object> obj,
                 Kind kind,
                 StreamBase* stream,
                 SecureContext* sc)
    : AsyncWrap(env, obj, AsyncWrap::PROVIDER_TLSWRAP),
      StreamBase(env),
      env_(env),
      kind_(kind),
      sc_(sc) {
  MakeWeak();
  CHECK(sc_);
  ssl_ = sc_->CreateSSL();
  CHECK(ssl_);

  sc_->SetGetSessionCallback(GetSessionCallback);
  sc_->SetNewSessionCallback(NewSessionCallback);

  StreamBase::AttachToObject(GetObject());
  stream->PushStreamListener(this);

  env_->isolate()->AdjustAmountOfExternalAllocatedMemory(kExternalSize);

  InitSSL();
  Debug(this, ""Created new TLSWrap"");
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.TLSWrap,,false,356,381,TLSWrap,,,2,"ANY node.crypto.TLSWrap.TLSWrap (Environment*,Local<Object>,Kind,StreamBase*,SecureContext*)"
59801,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"TLSWrap::~TLSWrap() {
  Destroy();
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.~TLSWrap,,false,383,385,~TLSWrap,,,3,ANY node.crypto.TLSWrap.~TLSWrap ()
59806,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"MaybeLocal<ArrayBufferView> TLSWrap::ocsp_response() const {
  if (ocsp_response_.IsEmpty())
    return MaybeLocal<ArrayBufferView>();
  return PersistentToLocal::Default(env()->isolate(), ocsp_response_);
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.ocsp_response,,false,387,391,ocsp_response,,,4,MaybeLocal<ArrayBufferView> node.crypto.TLSWrap.ocsp_response ()
59828,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::ClearOcspResponse() {
  ocsp_response_.Reset();
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.ClearOcspResponse,,false,393,395,ClearOcspResponse,,,5,void node.crypto.TLSWrap.ClearOcspResponse ()
59836,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"SSL_SESSION* TLSWrap::ReleaseSession() {
  return next_sess_.release();
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.ReleaseSession,,false,397,399,ReleaseSession,,,6,SSL_SESSION node.crypto.TLSWrap.ReleaseSession ()
59845,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::InvokeQueued(int status, const char* error_str) {
  Debug(this, ""Invoking queued write callbacks (%d, %s)"", status, error_str);
  if (!write_callback_scheduled_)
    return;

  if (current_write_) {
    BaseObjectPtr<AsyncWrap> current_write = std::move(current_write_);
    current_write_.reset();
    WriteWrap* w = WriteWrap::FromObject(current_write);
    w->Done(status, error_str);
  }
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.InvokeQueued,,false,401,412,InvokeQueued,,,7,"void node.crypto.TLSWrap.InvokeQueued (int,char*)"
59893,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::NewSessionDoneCb() {
  Debug(this, ""New session callback done"");
  Cycle();
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.NewSessionDoneCb,,false,414,417,NewSessionDoneCb,,,8,void node.crypto.TLSWrap.NewSessionDoneCb ()
59901,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::InitSSL() {
  // Initialize SSL  OpenSSL takes ownership of these.
  enc_in_ = NodeBIO::New(env()).release();
  enc_out_ = NodeBIO::New(env()).release();

  SSL_set_bio(ssl_.get(), enc_in_, enc_out_);

  // NOTE: This could be overridden in SetVerifyMode
  SSL_set_verify(ssl_.get(), SSL_VERIFY_NONE, VerifyCallback);

#ifdef SSL_MODE_RELEASE_BUFFERS
  SSL_set_mode(ssl_.get(), SSL_MODE_RELEASE_BUFFERS);
#endif  // SSL_MODE_RELEASE_BUFFERS

  // This is default in 1.1.1, but set it anyway, Cycle() doesn't currently
  // re-call ClearIn() if SSL_read() returns SSL_ERROR_WANT_READ, so data can be
  // left sitting in the incoming enc_in_ and never get processed.
  // - https://wiki.openssl.org/index.php/TLS1.3#Non-application_data_records
  SSL_set_mode(ssl_.get(), SSL_MODE_AUTO_RETRY);

#ifdef OPENSSL_IS_BORINGSSL
  // OpenSSL allows renegotiation by default, but BoringSSL disables it.
  // Configure BoringSSL to match OpenSSL's behavior.
  SSL_set_renegotiate_mode(ssl_.g...",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.InitSSL,,false,419,470,InitSSL,,,9,void node.crypto.TLSWrap.InitSSL ()
60007,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::Wrap(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  CHECK_EQ(args.Length(), 3);
  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsObject());
  CHECK(args[2]->IsBoolean());

  Local<Object> sc = args[1].As<Object>();
  Kind kind = args[2]->IsTrue() ? Kind::kServer : Kind::kClient;

  StreamBase* stream = StreamBase::FromObject(args[0].As<Object>());
  CHECK_NOT_NULL(stream);

  Local<Object> obj;
  if (!env->tls_wrap_constructor_function()
           ->NewInstance(env->context())
           .ToLocal(&obj)) {
    return;
  }

  TLSWrap* res = new TLSWrap(env, obj, kind, stream, Unwrap<SecureContext>(sc));

  args.GetReturnValue().Set(res->object());
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.Wrap,,false,472,496,Wrap,,,10,void node.crypto.TLSWrap.Wrap (FunctionCallbackInfo<Value>)
60140,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::Receive(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  ArrayBufferViewContents<char> buffer(args[0]);
  const char* data = buffer.data();
  size_t len = buffer.length();
  Debug(wrap, ""Receiving %zu bytes injected from JS"", len);

  // Copy given buffer entirely or partiall if handle becomes closed
  while (len > 0 && wrap->IsAlive() && !wrap->IsClosing()) {
    uv_buf_t buf = wrap->OnStreamAlloc(len);
    size_t copy = buf.len > len ? len : buf.len;
    memcpy(buf.base, data, copy);
    buf.len = copy;
    wrap->OnStreamRead(copy, buf);

    data += copy;
    len -= copy;
  }
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.Receive,,false,498,518,Receive,,,11,void node.crypto.TLSWrap.Receive (FunctionCallbackInfo<Value>)
60236,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::Start(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK(!wrap->started_);
  wrap->started_ = true;

  // Send ClientHello handshake
  CHECK(wrap->is_client());
  // Seems odd to read when when we want to send, but SSL_read() triggers a
  // handshake if a session isn't established, and handshake will cause
  // encrypted data to become available for output.
  wrap->ClearOut();
  wrap->EncOut();
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.Start,,false,520,534,Start,,,12,void node.crypto.TLSWrap.Start (FunctionCallbackInfo<Value>)
60272,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::SSLInfoCallback(const SSL* ssl_, int where, int ret) {
  if (!(where & (SSL_CB_HANDSHAKE_START | SSL_CB_HANDSHAKE_DONE)))
    return;

  // SSL_renegotiate_pending() should take `const SSL*`, but it does not.
  SSL* ssl = const_cast<SSL*>(ssl_);
  TLSWrap* c = static_cast<TLSWrap*>(SSL_get_app_data(ssl_));
  Environment* env = c->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());
  Local<Object> object = c->object();

  if (where & SSL_CB_HANDSHAKE_START) {
    Debug(c, ""SSLInfoCallback(SSL_CB_HANDSHAKE_START);"");
    // Start is tracked to limit number and frequency of renegotiation attempts,
    // since excessive renegotiation may be an attack.
    Local<Value> callback;

    if (object->Get(env->context(), env->onhandshakestart_string())
            .ToLocal(&callback) && callback->IsFunction()) {
      Local<Value> argv[] = { env->GetNow() };
      c->MakeCallback(callback.As<Function>(), arraysize(argv), argv);
    ...",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.SSLInfoCallback,,false,536,576,SSLInfoCallback,,,13,"void node.crypto.TLSWrap.SSLInfoCallback (SSL*,int,int)"
60446,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::EncOut() {
  Debug(this, ""Trying to write encrypted output"");

  // Ignore cycling data if ClientHello wasn't yet parsed
  if (!hello_parser_.IsEnded()) {
    Debug(this, ""Returning from EncOut(), hello_parser_ active"");
    return;
  }

  // Write in progress
  if (write_size_ != 0) {
    Debug(this, ""Returning from EncOut(), write currently in progress"");
    return;
  }

  // Wait for `newSession` callback to be invoked
  if (is_awaiting_new_session()) {
    Debug(this, ""Returning from EncOut(), awaiting new session"");
    return;
  }

  // Split-off queue
  if (established_ && current_write_) {
    Debug(this, ""EncOut() write is scheduled"");
    write_callback_scheduled_ = true;
  }

  if (ssl_ == nullptr) {
    Debug(this, ""Returning from EncOut(), ssl_ == nullptr"");
    return;
  }

  // No encrypted output ready to write to the underlying stream.
  if (BIO_pending(enc_out_) == 0) {
    Debug(this, ""No pending encrypted output"");
    if (!pending_cleartext_input_...",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.EncOut,,false,578,665,EncOut,,,14,void node.crypto.TLSWrap.EncOut ()
60654,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::OnStreamAfterWrite(WriteWrap* req_wrap, int status) {
  Debug(this, ""OnStreamAfterWrite(status = %d)"", status);
  if (current_empty_write_) {
    Debug(this, ""Had empty write"");
    BaseObjectPtr<AsyncWrap> current_empty_write =
        std::move(current_empty_write_);
    current_empty_write_.reset();
    WriteWrap* finishing = WriteWrap::FromObject(current_empty_write);
    finishing->Done(status);
    return;
  }

  if (ssl_ == nullptr) {
    Debug(this, ""ssl_ == nullptr, marking as cancelled"");
    status = UV_ECANCELED;
  }

  // Handle error
  if (status) {
    if (shutdown_) {
      Debug(this, ""Ignoring error after shutdown"");
      return;
    }

    // Notify about error
    InvokeQueued(status);
    return;
  }

  // Commit
  NodeBIO::FromBIO(enc_out_)->Read(nullptr, write_size_);

  // Ensure that the progress will be made and `InvokeQueued` will be called.
  ClearIn();

  // Try writing more data
  write_size_ = 0;
  EncOut();
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.OnStreamAfterWrite,,false,667,705,OnStreamAfterWrite,,,15,"void node.crypto.TLSWrap.OnStreamAfterWrite (WriteWrap*,int)"
60738,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::ClearOut() {
  Debug(this, ""Trying to read cleartext output"");
  // Ignore cycling data if ClientHello wasn't yet parsed
  if (!hello_parser_.IsEnded()) {
    Debug(this, ""Returning from ClearOut(), hello_parser_ active"");
    return;
  }

  // No reads after EOF
  if (eof_) {
    Debug(this, ""Returning from ClearOut(), EOF reached"");
    return;
  }

  if (ssl_ == nullptr) {
    Debug(this, ""Returning from ClearOut(), ssl_ == nullptr"");
    return;
  }

  MarkPopErrorOnReturn mark_pop_error_on_return;

  char out[kClearOutChunkSize];
  int read;
  for (;;) {
    read = SSL_read(ssl_.get(), out, sizeof(out));
    Debug(this, ""Read %d bytes of cleartext output"", read);

    if (read <= 0)
      break;

    char* current = out;
    while (read > 0) {
      int avail = read;

      uv_buf_t buf = EmitAlloc(avail);
      if (static_cast<int>(buf.len) < avail)
        avail = buf.len;
      memcpy(buf.base, current, avail);
      EmitRead(avail, buf);

      // Caveat empto...",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.ClearOut,,false,707,825,ClearOut,,,16,void node.crypto.TLSWrap.ClearOut ()
61096,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::ClearIn() {
  Debug(this, ""Trying to write cleartext input"");
  // Ignore cycling data if ClientHello wasn't yet parsed
  if (!hello_parser_.IsEnded()) {
    Debug(this, ""Returning from ClearIn(), hello_parser_ active"");
    return;
  }

  if (ssl_ == nullptr) {
    Debug(this, ""Returning from ClearIn(), ssl_ == nullptr"");
    return;
  }

  if (!pending_cleartext_input_ ||
      pending_cleartext_input_->ByteLength() == 0) {
    Debug(this, ""Returning from ClearIn(), no pending data"");
    return;
  }

  std::unique_ptr<BackingStore> bs = std::move(pending_cleartext_input_);
  MarkPopErrorOnReturn mark_pop_error_on_return;

  NodeBIO::FromBIO(enc_out_)->set_allocate_tls_hint(bs->ByteLength());
  int written = SSL_write(ssl_.get(), bs->Data(), bs->ByteLength());
  Debug(this, ""Writing %zu bytes, written = %d"", bs->ByteLength(), written);
  CHECK(written == -1 || written == static_cast<int>(bs->ByteLength()));

  // All written
  if (written != -1) {
    Debug(this, ""Su...",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.ClearIn,,false,827,875,ClearIn,,,17,void node.crypto.TLSWrap.ClearIn ()
61254,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"std::string TLSWrap::diagnostic_name() const {
  std::string name = ""TLSWrap "";
  name += is_server() ? ""server ("" : ""client ("";
  name += std::to_string(static_cast<int64_t>(get_async_id())) + "")"";
  return name;
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.diagnostic_name,,false,877,882,diagnostic_name,,,18,string node.crypto.TLSWrap.diagnostic_name ()
61281,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"AsyncWrap* TLSWrap::GetAsyncWrap() {
  return static_cast<AsyncWrap*>(this);
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.GetAsyncWrap,,false,884,886,GetAsyncWrap,,,19,AsyncWrap node.crypto.TLSWrap.GetAsyncWrap ()
61289,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"bool TLSWrap::IsIPCPipe() {
  return underlying_stream()->IsIPCPipe();
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.IsIPCPipe,,false,888,890,IsIPCPipe,,,20,bool node.crypto.TLSWrap.IsIPCPipe ()
61298,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"int TLSWrap::GetFD() {
  return underlying_stream()->GetFD();
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.GetFD,,false,892,894,GetFD,,,21,int node.crypto.TLSWrap.GetFD ()
61307,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"bool TLSWrap::IsAlive() {
  return ssl_ &&
      underlying_stream() != nullptr &&
      underlying_stream()->IsAlive();
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.IsAlive,,false,896,900,IsAlive,,,22,bool node.crypto.TLSWrap.IsAlive ()
61322,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"bool TLSWrap::IsClosing() {
  return underlying_stream()->IsClosing();
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.IsClosing,,false,902,904,IsClosing,,,23,bool node.crypto.TLSWrap.IsClosing ()
61331,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"int TLSWrap::ReadStart() {
  Debug(this, ""ReadStart()"");
  if (underlying_stream() != nullptr && !eof_)
    return underlying_stream()->ReadStart();
  return 0;
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.ReadStart,,false,906,911,ReadStart,,,24,int node.crypto.TLSWrap.ReadStart ()
61353,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"int TLSWrap::ReadStop() {
  Debug(this, ""ReadStop()"");
  return underlying_stream() != nullptr ? underlying_stream()->ReadStop() : 0;
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.ReadStop,,false,913,916,ReadStop,,,25,int node.crypto.TLSWrap.ReadStop ()
61370,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"const char* TLSWrap::Error() const {
  return error_.empty() ? nullptr : error_.c_str();
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.Error,,false,918,920,Error,,,26,const char* node.crypto.TLSWrap.Error ()
61385,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::ClearError() {
  error_.clear();
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.ClearError,,false,922,924,ClearError,,,27,void node.crypto.TLSWrap.ClearError ()
61393,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"int TLSWrap::DoWrite(WriteWrap* w,
                     uv_buf_t* bufs,
                     size_t count,
                     uv_stream_t* send_handle) {
  CHECK_NULL(send_handle);
  Debug(this, ""DoWrite()"");

  if (ssl_ == nullptr) {
    ClearError();
    error_ = ""Write after DestroySSL"";
    return UV_EPROTO;
  }

  size_t length = 0;
  size_t i;
  size_t nonempty_i = 0;
  size_t nonempty_count = 0;
  for (i = 0; i < count; i++) {
    length += bufs[i].len;
    if (bufs[i].len > 0) {
      nonempty_i = i;
      nonempty_count += 1;
    }
  }

  // We want to trigger a Write() on the underlying stream to drive the stream
  // system, but don't want to encrypt empty buffers into a TLS frame, so see
  // if we can find something to Write().
  // First, call ClearOut(). It does an SSL_read(), which might cause handshake
  // or other internal messages to be encrypted. If it does, write them later
  // with EncOut().
  // If there is still no encrypted output, call Write(bufs) on th...",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.DoWrite,,false,928,1059,DoWrite,,,28,"int node.crypto.TLSWrap.DoWrite (WriteWrap*,uv_buf_t*,size_t,uv_stream_t*)"
61784,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"uv_buf_t TLSWrap::OnStreamAlloc(size_t suggested_size) {
  CHECK_NOT_NULL(ssl_);

  size_t size = suggested_size;
  char* base = NodeBIO::FromBIO(enc_in_)->PeekWritable(&size);
  return uv_buf_init(base, size);
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.OnStreamAlloc,,false,1061,1067,OnStreamAlloc,,,29,uv_buf_t node.crypto.TLSWrap.OnStreamAlloc (size_t)
61811,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::OnStreamRead(ssize_t nread, const uv_buf_t& buf) {
  Debug(this, ""Read %zd bytes from underlying stream"", nread);

  // Ignore everything after close_notify (rfc5246#section-7.2.1)
  if (eof_)
    return;

  if (nread < 0)  {
    // Error should be emitted only after all data was read
    ClearOut();

    if (nread == UV_EOF) {
      // underlying stream already should have also called ReadStop on itself
      eof_ = true;
    }

    EmitRead(nread);
    return;
  }

  // DestroySSL() is the only thing that un-sets ssl_, but that also removes
  // this TLSWrap as a stream listener, so we should not receive OnStreamRead()
  // calls anymore.
  CHECK(ssl_);

  // Commit the amount of data actually read into the peeked/allocated buffer
  // from the underlying stream.
  NodeBIO* enc_in = NodeBIO::FromBIO(enc_in_);
  enc_in->Commit(nread);

  // Parse ClientHello first, if we need to. It's only parsed if session event
  // listeners are used on the server side.  ""ended"" is...",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.OnStreamRead,,false,1069,1113,OnStreamRead,,,30,"void node.crypto.TLSWrap.OnStreamRead (ssize_t,uv_buf_t)"
61897,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"ShutdownWrap* TLSWrap::CreateShutdownWrap(Local<Object> req_wrap_object) {
  return underlying_stream()->CreateShutdownWrap(req_wrap_object);
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.CreateShutdownWrap,,false,1115,1117,CreateShutdownWrap,,,31,ShutdownWrap node.crypto.TLSWrap.CreateShutdownWrap (Local<Object>)
61908,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"int TLSWrap::DoShutdown(ShutdownWrap* req_wrap) {
  Debug(this, ""DoShutdown()"");
  MarkPopErrorOnReturn mark_pop_error_on_return;

  if (ssl_ && SSL_shutdown(ssl_.get()) == 0)
    SSL_shutdown(ssl_.get());

  shutdown_ = true;
  EncOut();
  return underlying_stream()->DoShutdown(req_wrap);
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.DoShutdown,,false,1119,1129,DoShutdown,,,32,int node.crypto.TLSWrap.DoShutdown (ShutdownWrap*)
61943,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::SetVerifyMode(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK_EQ(args.Length(), 2);
  CHECK(args[0]->IsBoolean());
  CHECK(args[1]->IsBoolean());
  CHECK_NOT_NULL(wrap->ssl_);

  int verify_mode;
  if (wrap->is_server()) {
    bool request_cert = args[0]->IsTrue();
    if (!request_cert) {
      // If no cert is requested, there will be none to reject as unauthorized.
      verify_mode = SSL_VERIFY_NONE;
    } else {
      bool reject_unauthorized = args[1]->IsTrue();
      verify_mode = SSL_VERIFY_PEER;
      if (reject_unauthorized)
        verify_mode |= SSL_VERIFY_FAIL_IF_NO_PEER_CERT;
    }
  } else {
    // Servers always send a cert if the cipher is not anonymous (anon is
    // disabled by default), so use VERIFY_NONE and check the cert after the
    // handshake has completed.
    verify_mode = SSL_VERIFY_NONE;
  }

  // Always allow a connection. We'll reject in javascript.
  SSL_set_verify...",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.SetVerifyMode,,false,1131,1161,SetVerifyMode,,,33,void node.crypto.TLSWrap.SetVerifyMode (FunctionCallbackInfo<Value>)
62037,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::EnableSessionCallbacks(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  CHECK_NOT_NULL(wrap->ssl_);
  wrap->enable_session_callbacks();

  // Clients don't use the HelloParser.
  if (wrap->is_client())
    return;

  NodeBIO::FromBIO(wrap->enc_in_)->set_initial(kMaxHelloLength);
  wrap->hello_parser_.Start(OnClientHello,
                            OnClientHelloParseEnd,
                            wrap);
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.EnableSessionCallbacks,,false,1163,1177,EnableSessionCallbacks,,,34,void node.crypto.TLSWrap.EnableSessionCallbacks (FunctionCallbackInfo<Value>)
62085,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::EnableKeylogCallback(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  CHECK(wrap->sc_);
  wrap->sc_->SetKeylogCallback(KeylogCallback);
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.EnableKeylogCallback,,false,1179,1184,EnableKeylogCallback,,,35,void node.crypto.TLSWrap.EnableKeylogCallback (FunctionCallbackInfo<Value>)
62109,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::EnableTrace(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

#if HAVE_SSL_TRACE
  if (wrap->ssl_) {
    wrap->bio_trace_.reset(BIO_new_fp(stderr,  BIO_NOCLOSE | BIO_FP_TEXT));
    SSL_set_msg_callback(wrap->ssl_.get(), [](int write_p, int version, int
          content_type, const void* buf, size_t len, SSL* ssl, void* arg)
        -> void {
        // BIO_write(), etc., called by SSL_trace, may error. The error should
        // be ignored, trace is a ""best effort"", and its usually because stderr
        // is a non-blocking pipe, and its buffer has overflowed. Leaving errors
        // on the stack that can get picked up by later SSL_ calls causes
        // unwanted failures in SSL_ calls, so keep the error stack unchanged.
        MarkPopErrorOnReturn mark_pop_error_on_return;
        SSL_trace(write_p,  version, content_type, buf, len, ssl, arg);
    });
    SSL_set_msg_callback_arg(wrap->ssl_.get(), wra...",1,4,crypto\crypto_tls.cc,node.crypto.TLSWrap.EnableTrace,,false,1196,1217,EnableTrace,,,36,void node.crypto.TLSWrap.EnableTrace (FunctionCallbackInfo<Value>)
62159,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::DestroySSL(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  wrap->Destroy();
  Debug(wrap, ""DestroySSL() finished"");
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.DestroySSL,,false,1219,1224,DestroySSL,,,37,void node.crypto.TLSWrap.DestroySSL (FunctionCallbackInfo<Value>)
62179,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::Destroy() {
  if (!ssl_)
    return;

  // If there is a write happening, mark it as finished.
  write_callback_scheduled_ = true;

  // And destroy
  InvokeQueued(UV_ECANCELED, ""Canceled because of SSL destruction"");

  env()->isolate()->AdjustAmountOfExternalAllocatedMemory(-kExternalSize);
  ssl_.reset();

  enc_in_ = nullptr;
  enc_out_ = nullptr;

  if (underlying_stream() != nullptr)
    underlying_stream()->RemoveStreamListener(this);

  sc_.reset();
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.Destroy,,false,1226,1246,Destroy,,,38,void node.crypto.TLSWrap.Destroy ()
62227,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::EnableCertCb(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  wrap->WaitForCertCb(OnClientHelloParseEnd, wrap);
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.EnableCertCb,,false,1248,1252,EnableCertCb,,,39,void node.crypto.TLSWrap.EnableCertCb (FunctionCallbackInfo<Value>)
62246,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::WaitForCertCb(CertCb cb, void* arg) {
  cert_cb_ = cb;
  cert_cb_arg_ = arg;
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.WaitForCertCb,,false,1254,1257,WaitForCertCb,,,40,"void node.crypto.TLSWrap.WaitForCertCb (CertCb,void*)"
62258,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::OnClientHelloParseEnd(void* arg) {
  TLSWrap* c = static_cast<TLSWrap*>(arg);
  Debug(c, ""OnClientHelloParseEnd()"");
  c->Cycle();
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.OnClientHelloParseEnd,,false,1259,1263,OnClientHelloParseEnd,,,41,void node.crypto.TLSWrap.OnClientHelloParseEnd (void*)
62276,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::EnableALPNCb(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  wrap->alpn_callback_enabled_ = true;

  SSL* ssl = wrap->ssl_.get();
  SSL_CTX_set_alpn_select_cb(SSL_get_SSL_CTX(ssl), SelectALPNCallback, wrap);
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.EnableALPNCb,,false,1265,1272,EnableALPNCb,,,42,void node.crypto.TLSWrap.EnableALPNCb (FunctionCallbackInfo<Value>)
62308,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::GetServername(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK_NOT_NULL(wrap->ssl_);

  const char* servername = GetServerName(wrap->ssl_.get());
  if (servername != nullptr) {
    args.GetReturnValue().Set(OneByteString(env->isolate(), servername));
  } else {
    args.GetReturnValue().Set(false);
  }
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.GetServername,,false,1274,1288,GetServername,,,43,void node.crypto.TLSWrap.GetServername (FunctionCallbackInfo<Value>)
62371,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::SetServername(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());
  CHECK(!wrap->started_);
  CHECK(wrap->is_client());

  CHECK(wrap->ssl_);

  Utf8Value servername(env->isolate(), args[0].As<String>());
  SSL_set_tlsext_host_name(wrap->ssl_.get(), *servername);
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.SetServername,,false,1290,1305,SetServername,,,44,void node.crypto.TLSWrap.SetServername (FunctionCallbackInfo<Value>)
62440,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"int TLSWrap::SelectSNIContextCallback(SSL* s, int* ad, void* arg) {
  TLSWrap* p = static_cast<TLSWrap*>(SSL_get_app_data(s));
  Environment* env = p->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  const char* servername = GetServerName(s);
  if (!Set(env, p->GetOwner(), env->servername_string(), servername))
    return SSL_TLSEXT_ERR_NOACK;

  Local<Value> ctx = p->object()->Get(env->context(), env->sni_context_string())
      .FromMaybe(Local<Value>());

  if (UNLIKELY(ctx.IsEmpty()) || !ctx->IsObject())
    return SSL_TLSEXT_ERR_NOACK;

  if (!env->secure_context_constructor_template()->HasInstance(ctx)) {
    // Failure: incorrect SNI context object
    Local<Value> err = Exception::TypeError(env->sni_context_err_string());
    p->MakeCallback(env->onerror_string(), 1, &err);
    return SSL_TLSEXT_ERR_NOACK;
  }

  SecureContext* sc = Unwrap<SecureContext>(ctx.As<Object>());
  CHECK_NOT_NULL(sc);
  p->sni_context_ = BaseObje...",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.SelectSNIContextCallback,,false,1307,1339,SelectSNIContextCallback,,,45,"int node.crypto.TLSWrap.SelectSNIContextCallback (SSL*,int*,void*)"
62625,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"int TLSWrap::SetCACerts(SecureContext* sc) {
  int err = SSL_set1_verify_cert_store(ssl_.get(),
                                       SSL_CTX_get_cert_store(sc->ctx().get()));
  if (err != 1)
    return err;

  STACK_OF(X509_NAME)* list =
      SSL_dup_CA_list(SSL_CTX_get_client_CA_list(sc->ctx().get()));

  // NOTE: `SSL_set_client_CA_list` takes the ownership of `list`
  SSL_set_client_CA_list(ssl_.get(), list);
  return 1;
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.SetCACerts,,false,1341,1353,SetCACerts,,,46,int node.crypto.TLSWrap.SetCACerts (SecureContext*)
62675,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::SetPskIdentityHint(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* p;
  ASSIGN_OR_RETURN_UNWRAP(&p, args.Holder());
  CHECK_NOT_NULL(p->ssl_);

  Environment* env = p->env();
  Isolate* isolate = env->isolate();

  CHECK(args[0]->IsString());
  Utf8Value hint(isolate, args[0].As<String>());

  if (!SSL_use_psk_identity_hint(p->ssl_.get(), *hint)) {
    Local<Value> err = node::ERR_TLS_PSK_SET_IDENTIY_HINT_FAILED(isolate);
    p->MakeCallback(env->onerror_string(), 1, &err);
  }
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.SetPskIdentityHint,,false,1357,1372,SetPskIdentityHint,,,47,void node.crypto.TLSWrap.SetPskIdentityHint (FunctionCallbackInfo<Value>)
62756,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::EnablePskCallback(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  CHECK_NOT_NULL(wrap->ssl_);

  SSL_set_psk_server_callback(wrap->ssl_.get(), PskServerCallback);
  SSL_set_psk_client_callback(wrap->ssl_.get(), PskClientCallback);
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.EnablePskCallback,,false,1374,1381,EnablePskCallback,,,48,void node.crypto.TLSWrap.EnablePskCallback (FunctionCallbackInfo<Value>)
62789,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"unsigned int TLSWrap::PskServerCallback(
    SSL* s,
    const char* identity,
    unsigned char* psk,
    unsigned int max_psk_len) {
  TLSWrap* p = static_cast<TLSWrap*>(SSL_get_app_data(s));

  Environment* env = p->env();
  HandleScope scope(env->isolate());

  Local<String> identity_str =
      String::NewFromUtf8(env->isolate(), identity).FromMaybe(Local<String>());
  if (UNLIKELY(identity_str.IsEmpty()))
    return 0;

  // Make sure there are no utf8 replacement symbols.
  Utf8Value identity_utf8(env->isolate(), identity_str);
  if (identity_utf8 != identity) return 0;

  Local<Value> argv[] = {
    identity_str,
    Integer::NewFromUnsigned(env->isolate(), max_psk_len)
  };

  Local<Value> psk_val =
      p->MakeCallback(env->onpskexchange_symbol(), arraysize(argv), argv)
          .FromMaybe(Local<Value>());
  if (UNLIKELY(psk_val.IsEmpty()) || !psk_val->IsArrayBufferView())
    return 0;

  ArrayBufferViewContents<char> psk_buf(psk_val);

  if (psk_buf.length() > max_psk_...",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.PskServerCallback,,false,1383,1420,PskServerCallback,,,49,"unsigned int node.crypto.TLSWrap.PskServerCallback (SSL*,char*,unsigned char*,unsigned int)"
62937,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"unsigned int TLSWrap::PskClientCallback(
    SSL* s,
    const char* hint,
    char* identity,
    unsigned int max_identity_len,
    unsigned char* psk,
    unsigned int max_psk_len) {
  TLSWrap* p = static_cast<TLSWrap*>(SSL_get_app_data(s));

  Environment* env = p->env();
  HandleScope scope(env->isolate());

  Local<Value> argv[] = {
    Null(env->isolate()),
    Integer::NewFromUnsigned(env->isolate(), max_psk_len),
    Integer::NewFromUnsigned(env->isolate(), max_identity_len)
  };

  if (hint != nullptr) {
    Local<String> local_hint =
        String::NewFromUtf8(env->isolate(), hint).FromMaybe(Local<String>());
    if (UNLIKELY(local_hint.IsEmpty()))
      return 0;

    argv[0] = local_hint;
  }

  Local<Value> ret =
      p->MakeCallback(env->onpskexchange_symbol(), arraysize(argv), argv)
          .FromMaybe(Local<Value>());
  if (UNLIKELY(ret.IsEmpty()) || !ret->IsObject())
    return 0;

  Local<Object> obj = ret.As<Object>();

  Local<Value> psk_val = obj->Get(env->c...",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.PskClientCallback,,false,1422,1480,PskClientCallback,,,50,"unsigned int node.crypto.TLSWrap.PskClientCallback (SSL*,char*,char*,unsigned int,unsigned char*,unsigned int)"
63205,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::GetWriteQueueSize(const FunctionCallbackInfo<Value>& info) {
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, info.This());

  if (!wrap->ssl_)
    return info.GetReturnValue().Set(0);

  uint32_t write_queue_size = BIO_pending(wrap->enc_out_);
  info.GetReturnValue().Set(write_queue_size);
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.GetWriteQueueSize,,false,1484,1493,GetWriteQueueSize,,,51,void node.crypto.TLSWrap.GetWriteQueueSize (FunctionCallbackInfo<Value>)
63248,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""ocsp_response"", ocsp_response_);
  tracker->TrackField(""sni_context"", sni_context_);
  tracker->TrackField(""error"", error_);
  if (pending_cleartext_input_)
    tracker->TrackField(""pending_cleartext_input"", pending_cleartext_input_);
  if (enc_in_ != nullptr)
    tracker->TrackField(""enc_in"", NodeBIO::FromBIO(enc_in_));
  if (enc_out_ != nullptr)
    tracker->TrackField(""enc_out"", NodeBIO::FromBIO(enc_out_));
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.MemoryInfo,,false,1495,1505,MemoryInfo,,,52,void node.crypto.TLSWrap.MemoryInfo (MemoryTracker*)
63310,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::CertCbDone(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  CHECK(w->is_waiting_cert_cb() && w->cert_cb_running_);

  Local<Object> object = w->object();
  Local<Value> ctx = object->Get(env->context(), env->sni_context_string())
      .FromMaybe(Local<Value>());
  if (UNLIKELY(ctx.IsEmpty()))
    return;

  Local<FunctionTemplate> cons = env->secure_context_constructor_template();
  if (cons->HasInstance(ctx)) {
    SecureContext* sc = Unwrap<SecureContext>(ctx.As<Object>());
    CHECK_NOT_NULL(sc);
    // Store the SNI context for later use.
    w->sni_context_ = BaseObjectPtr<SecureContext>(sc);

    if (UseSNIContext(w->ssl_, w->sni_context_) && !w->SetCACerts(sc)) {
      // Not clear why sometimes we throw error, and sometimes we call
      // onerror(). Both cause .destroy(), but onerror does a bit more.
      unsigned long err = ERR_get_error();  // NOLI...",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.CertCbDone,,false,1507,1551,CertCbDone,,,53,void node.crypto.TLSWrap.CertCbDone (FunctionCallbackInfo<Value>)
63507,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::SetALPNProtocols(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = w->env();
  if (args.Length() < 1 || !Buffer::HasInstance(args[0]))
    return env->ThrowTypeError(""Must give a Buffer as first argument"");

  ArrayBufferViewContents<uint8_t> protos(args[0].As<ArrayBufferView>());
  SSL* ssl = w->ssl_.get();
  if (w->is_client()) {
    CHECK_EQ(0, SSL_set_alpn_protos(ssl, protos.data(), protos.length()));
  } else {
    w->alpn_protos_ = std::vector<unsigned char>(
        protos.data(), protos.data() + protos.length());
    SSL_CTX_set_alpn_select_cb(SSL_get_SSL_CTX(ssl), SelectALPNCallback, w);
  }
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.SetALPNProtocols,,false,1553,1569,SetALPNProtocols,,,54,void node.crypto.TLSWrap.SetALPNProtocols (FunctionCallbackInfo<Value>)
63616,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::GetPeerCertificate(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = w->env();

  bool abbreviated = args.Length() < 1 || !args[0]->IsTrue();

  Local<Value> ret;
  if (GetPeerCert(
          env,
          w->ssl_,
          abbreviated,
          w->is_server()).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.GetPeerCertificate,,false,1571,1585,GetPeerCertificate,,,55,void node.crypto.TLSWrap.GetPeerCertificate (FunctionCallbackInfo<Value>)
63683,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::GetPeerX509Certificate(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = w->env();

  X509Certificate::GetPeerCertificateFlag flag = w->is_server()
      ? X509Certificate::GetPeerCertificateFlag::SERVER
      : X509Certificate::GetPeerCertificateFlag::NONE;

  Local<Value> ret;
  if (X509Certificate::GetPeerCert(env, w->ssl_, flag).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.GetPeerX509Certificate,,false,1587,1599,GetPeerX509Certificate,,,56,void node.crypto.TLSWrap.GetPeerX509Certificate (FunctionCallbackInfo<Value>)
63750,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::GetCertificate(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = w->env();

  Local<Value> ret;
  if (GetCert(env, w->ssl_).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.GetCertificate,,false,1601,1609,GetCertificate,,,57,void node.crypto.TLSWrap.GetCertificate (FunctionCallbackInfo<Value>)
63795,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::GetX509Certificate(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = w->env();
  Local<Value> ret;
  if (X509Certificate::GetCert(env, w->ssl_).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.GetX509Certificate,,false,1611,1618,GetX509Certificate,,,58,void node.crypto.TLSWrap.GetX509Certificate (FunctionCallbackInfo<Value>)
63843,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::GetFinished(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  // We cannot just pass nullptr to SSL_get_finished()
  // because it would further be propagated to memcpy(),
  // where the standard requirements as described in ISO/IEC 9899:2011
  // sections 7.21.2.1, 7.21.1.2, and 7.1.4, would be violated.
  // Thus, we use a dummy byte.
  char dummy[1];
  size_t len = SSL_get_finished(w->ssl_.get(), dummy, sizeof dummy);
  if (len == 0)
    return;

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), len);
  }

  CHECK_EQ(bs->ByteLength(),
           SSL_get_finished(w->ssl_.get(), bs->Data(), bs->ByteLength()));

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  Local<Value> buffer;
  if (!Buffer::New(env, ab, 0, ab->ByteL...",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.GetFinished,,false,1620,1649,GetFinished,,,59,void node.crypto.TLSWrap.GetFinished (FunctionCallbackInfo<Value>)
63981,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::GetPeerFinished(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  // We cannot just pass nullptr to SSL_get_peer_finished()
  // because it would further be propagated to memcpy(),
  // where the standard requirements as described in ISO/IEC 9899:2011
  // sections 7.21.2.1, 7.21.1.2, and 7.1.4, would be violated.
  // Thus, we use a dummy byte.
  char dummy[1];
  size_t len = SSL_get_peer_finished(w->ssl_.get(), dummy, sizeof dummy);
  if (len == 0)
    return;

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), len);
  }

  CHECK_EQ(bs->ByteLength(),
           SSL_get_peer_finished(w->ssl_.get(), bs->Data(), bs->ByteLength()));

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  Local<Value> buffer;
  if (!Buffer::New(en...",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.GetPeerFinished,,false,1651,1680,GetPeerFinished,,,60,void node.crypto.TLSWrap.GetPeerFinished (FunctionCallbackInfo<Value>)
64119,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::GetSession(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  SSL_SESSION* sess = SSL_get_session(w->ssl_.get());
  if (sess == nullptr)
    return;

  int slen = i2d_SSL_SESSION(sess, nullptr);
  if (slen <= 0)
    return;  // Invalid or malformed session.

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), slen);
  }

  unsigned char* p = static_cast<unsigned char*>(bs->Data());
  CHECK_LT(0, i2d_SSL_SESSION(sess, &p));

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  Local<Value> buffer;
  if (!Buffer::New(env, ab, 0, ab->ByteLength()).ToLocal(&buffer)) return;
  args.GetReturnValue().Set(buffer);
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.GetSession,,false,1682,1709,GetSession,,,61,void node.crypto.TLSWrap.GetSession (FunctionCallbackInfo<Value>)
64260,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::SetSession(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  if (args.Length() < 1)
    return THROW_ERR_MISSING_ARGS(env, ""Session argument is mandatory"");

  THROW_AND_RETURN_IF_NOT_BUFFER(env, args[0], ""Session"");
  ArrayBufferViewContents<unsigned char> sbuf(args[0]);
  SSLSessionPointer sess = GetTLSSession(sbuf.data(), sbuf.length());
  if (sess == nullptr)
    return;  // TODO(tniessen): figure out error handling

  if (!SetTLSSession(w->ssl_, sess))
    return env->ThrowError(""SSL_set_session error"");
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.SetSession,,false,1711,1728,SetSession,,,62,void node.crypto.TLSWrap.SetSession (FunctionCallbackInfo<Value>)
64336,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::IsSessionReused(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  bool yes = SSL_session_reused(w->ssl_.get());
  args.GetReturnValue().Set(yes);
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.IsSessionReused,,false,1730,1735,IsSessionReused,,,63,void node.crypto.TLSWrap.IsSessionReused (FunctionCallbackInfo<Value>)
64367,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::VerifyError(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  // XXX(bnoordhuis) The UNABLE_TO_GET_ISSUER_CERT error when there is no
  // peer certificate is questionable but it's compatible with what was
  // here before.
  long x509_verify_error =  // NOLINT(runtime/int)
      VerifyPeerCertificate(
          w->ssl_,
          X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT);

  if (x509_verify_error == X509_V_OK)
    return args.GetReturnValue().SetNull();

  const char* reason = X509_verify_cert_error_string(x509_verify_error);
  const char* code = X509ErrorCode(x509_verify_error);

  Local<Object> error =
      Exception::Error(OneByteString(env->isolate(), reason))
          ->ToObject(env->isolate()->GetCurrentContext())
              .FromMaybe(Local<Object>());

  if (Set(env, error, env->code_string(), code))
    args.GetReturnValue().Set(error);
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.VerifyError,,false,1737,1763,VerifyError,,,64,void node.crypto.TLSWrap.VerifyError (FunctionCallbackInfo<Value>)
64467,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::GetCipher(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  args.GetReturnValue().Set(
      GetCipherInfo(env, w->ssl_).FromMaybe(Local<Object>()));
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.GetCipher,,false,1765,1771,GetCipher,,,65,void node.crypto.TLSWrap.GetCipher (FunctionCallbackInfo<Value>)
64504,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::LoadSession(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  // TODO(@sam-github) check arg length and types in js, and CHECK in c++
  if (args.Length() >= 1 && Buffer::HasInstance(args[0])) {
    ArrayBufferViewContents<unsigned char> sbuf(args[0]);

    const unsigned char* p = sbuf.data();
    SSL_SESSION* sess = d2i_SSL_SESSION(nullptr, &p, sbuf.length());

    // Setup next session and move hello to the BIO buffer
    w->next_sess_.reset(sess);
  }
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.LoadSession,,false,1773,1787,LoadSession,,,66,void node.crypto.TLSWrap.LoadSession (FunctionCallbackInfo<Value>)
64563,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::GetSharedSigalgs(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  SSL* ssl = w->ssl_.get();
  int nsig = SSL_get_shared_sigalgs(ssl, 0, nullptr, nullptr, nullptr, nullptr,
                                    nullptr);
  MaybeStackBuffer<Local<Value>, 16> ret_arr(nsig);

  for (int i = 0; i < nsig; i++) {
    int hash_nid;
    int sign_nid;
    std::string sig_with_md;

    SSL_get_shared_sigalgs(ssl, i, &sign_nid, &hash_nid, nullptr, nullptr,
                           nullptr);

    switch (sign_nid) {
      case EVP_PKEY_RSA:
        sig_with_md = ""RSA+"";
        break;

      case EVP_PKEY_RSA_PSS:
        sig_with_md = ""RSA-PSS+"";
        break;

      case EVP_PKEY_DSA:
        sig_with_md = ""DSA+"";
        break;

      case EVP_PKEY_EC:
        sig_with_md = ""ECDSA+"";
        break;

      case NID_ED25519:
        sig_with_md = ""Ed25519+"";
        break;...",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.GetSharedSigalgs,,false,1789,1866,GetSharedSigalgs,,,67,void node.crypto.TLSWrap.GetSharedSigalgs (FunctionCallbackInfo<Value>)
64773,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::ExportKeyingMaterial(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsInt32());
  CHECK(args[1]->IsString());

  Environment* env = Environment::GetCurrent(args);
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  uint32_t olen = args[0].As<Uint32>()->Value();
  Utf8Value label(env->isolate(), args[1]);

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), olen);
  }

  ByteSource context;
  bool use_context = !args[2]->IsUndefined();
  if (use_context)
    context = ByteSource::FromBuffer(args[2]);

  if (SSL_export_keying_material(
          w->ssl_.get(),
          static_cast<unsigned char*>(bs->Data()),
          olen,
          *label,
          label.length(),
          context.data<unsigned char>(),
          context.size(),
          use_context) != 1) {
    return ThrowCryptoError(
         env,
         ERR_get_error(),
  ...",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.ExportKeyingMaterial,,false,1868,1909,ExportKeyingMaterial,,,68,void node.crypto.TLSWrap.ExportKeyingMaterial (FunctionCallbackInfo<Value>)
64967,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::EndParser(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  w->hello_parser_.End();
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.EndParser,,false,1911,1915,EndParser,,,69,void node.crypto.TLSWrap.EndParser (FunctionCallbackInfo<Value>)
64986,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::Renegotiate(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  ClearErrorOnReturn clear_error_on_return;
  if (SSL_renegotiate(w->ssl_.get()) != 1)
    return ThrowCryptoError(w->env(), ERR_get_error());
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.Renegotiate,,false,1917,1923,Renegotiate,,,70,void node.crypto.TLSWrap.Renegotiate (FunctionCallbackInfo<Value>)
65018,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::GetTLSTicket(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = w->env();

  SSL_SESSION* sess = SSL_get_session(w->ssl_.get());
  if (sess == nullptr)
    return;

  const unsigned char* ticket;
  size_t length;
  SSL_SESSION_get0_ticket(sess, &ticket, &length);

  if (ticket != nullptr) {
    args.GetReturnValue().Set(
        Buffer::Copy(env, reinterpret_cast<const char*>(ticket), length)
            .FromMaybe(Local<Object>()));
  }
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.GetTLSTicket,,false,1925,1943,GetTLSTicket,,,71,void node.crypto.TLSWrap.GetTLSTicket (FunctionCallbackInfo<Value>)
65087,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::NewSessionDone(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  w->awaiting_new_session_ = false;
  w->NewSessionDoneCb();
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.NewSessionDone,,false,1945,1950,NewSessionDone,,,72,void node.crypto.TLSWrap.NewSessionDone (FunctionCallbackInfo<Value>)
65109,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::SetOCSPResponse(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = w->env();

  if (args.Length() < 1)
    return THROW_ERR_MISSING_ARGS(env, ""OCSP response argument is mandatory"");

  THROW_AND_RETURN_IF_NOT_BUFFER(env, args[0], ""OCSP response"");

  w->ocsp_response_.Reset(args.GetIsolate(), args[0].As<ArrayBufferView>());
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.SetOCSPResponse,,false,1952,1963,SetOCSPResponse,,,73,void node.crypto.TLSWrap.SetOCSPResponse (FunctionCallbackInfo<Value>)
65163,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::RequestOCSP(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  SSL_set_tlsext_status_type(w->ssl_.get(), TLSEXT_STATUSTYPE_ocsp);
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.RequestOCSP,,false,1965,1970,RequestOCSP,,,74,void node.crypto.TLSWrap.RequestOCSP (FunctionCallbackInfo<Value>)
65184,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::GetEphemeralKeyInfo(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = Environment::GetCurrent(args);

  CHECK(w->ssl_);

  // tmp key is available on only client
  if (w->is_server())
    return args.GetReturnValue().SetNull();

  args.GetReturnValue().Set(GetEphemeralKey(env, w->ssl_)
      .FromMaybe(Local<Value>()));

  // TODO(@sam-github) semver-major: else return ThrowCryptoError(env,
  // ERR_get_error())
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.GetEphemeralKeyInfo,,false,1972,1988,GetEphemeralKeyInfo,,,75,void node.crypto.TLSWrap.GetEphemeralKeyInfo (FunctionCallbackInfo<Value>)
65239,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::GetProtocol(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  args.GetReturnValue().Set(
      OneByteString(env->isolate(), SSL_get_version(w->ssl_.get())));
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.GetProtocol,,false,1990,1996,GetProtocol,,,76,void node.crypto.TLSWrap.GetProtocol (FunctionCallbackInfo<Value>)
65279,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::GetALPNNegotiatedProto(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  const unsigned char* alpn_proto;
  unsigned int alpn_proto_len;

  SSL_get0_alpn_selected(w->ssl_.get(), &alpn_proto, &alpn_proto_len);

  Local<Value> result;
  if (alpn_proto_len == 0) {
    result = False(env->isolate());
  } else if (alpn_proto_len == sizeof(""h2"") - 1 &&
             0 == memcmp(alpn_proto, ""h2"", sizeof(""h2"") - 1)) {
    result = env->h2_string();
  } else if (alpn_proto_len == sizeof(""http/1.1"") - 1 &&
             0 == memcmp(alpn_proto, ""http/1.1"", sizeof(""http/1.1"") - 1)) {
    result = env->http_1_1_string();
  } else {
    result = OneByteString(env->isolate(), alpn_proto, alpn_proto_len);
  }

  args.GetReturnValue().Set(result);
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.GetALPNNegotiatedProto,,false,1998,2022,GetALPNNegotiatedProto,,,77,void node.crypto.TLSWrap.GetALPNNegotiatedProto (FunctionCallbackInfo<Value>)
65401,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::Cycle() {
  // Prevent recursion
  if (++cycle_depth_ > 1)
    return;

  for (; cycle_depth_ > 0; cycle_depth_--) {
    ClearIn();
    ClearOut();
    // EncIn() doesn't exist, it happens via stream listener callbacks.
    EncOut();
  }
}",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.Cycle,,false,2024,2035,Cycle,,,78,void node.crypto.TLSWrap.Cycle ()
65423,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::Initialize(
    Local<Object> target,
    Local<Value> unused,
    Local<Context> context,
    void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  SetMethod(context, target, ""wrap"", TLSWrap::Wrap);

  NODE_DEFINE_CONSTANT(target, HAVE_SSL_TRACE);

  Local<FunctionTemplate> t = BaseObject::MakeLazilyInitializedJSTemplate(env);
  Local<String> tlsWrapString =
      FIXED_ONE_BYTE_STRING(env->isolate(), ""TLSWrap"");
  t->SetClassName(tlsWrapString);
  t->InstanceTemplate()->SetInternalFieldCount(StreamBase::kInternalFieldCount);

  Local<FunctionTemplate> get_write_queue_size =
      FunctionTemplate::New(env->isolate(),
                            GetWriteQueueSize,
                            Local<Value>(),
                            Signature::New(env->isolate(), t));
  t->PrototypeTemplate()->SetAccessorProperty(
      env->write_queue_size_string(),
      get_write_queue_size,
      Local<FunctionTemplate>(),
...",1,2,crypto\crypto_tls.cc,node.crypto.TLSWrap.Initialize,,false,2050,2141,Initialize,,,79,"void node.crypto.TLSWrap.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
65872,METHOD,crypto\crypto_tls.cc:<global>,TYPE_DECL,"void TLSWrap::RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(TLSWrap::Wrap);
  registry->Register(GetWriteQueueSize);

  registry->Register(CertCbDone);
  registry->Register(DestroySSL);
  registry->Register(EnableCertCb);
  registry->Register(EnableALPNCb);
  registry->Register(EndParser);
  registry->Register(EnableKeylogCallback);
  registry->Register(EnableSessionCallbacks);
  registry->Register(EnableTrace);
  registry->Register(GetServername);
  registry->Register(LoadSession);
  registry->Register(NewSessionDone);
  registry->Register(Receive);
  registry->Register(Renegotiate);
  registry->Register(RequestOCSP);
  registry->Register(SetALPNProtocols);
  registry->Register(SetOCSPResponse);
  registry->Register(SetServername);
  registry->Register(SetSession);
  registry->Register(SetVerifyMode);
  registry->Register(Start);
  registry->Register(ExportKeyingMaterial);
  registry->Register(IsSessionReused);
  registry->Register(GetALPNNe...",1,1,crypto\crypto_tls.cc,node.crypto.TLSWrap.RegisterExternalReferences,,false,2143,2192,RegisterExternalReferences,,,80,void node.crypto.TLSWrap.RegisterExternalReferences (ExternalReferenceRegistry*)
66099,METHOD,crypto\crypto_tls.hpp:<global>,TYPE_DECL,<global>,1,35,crypto\crypto_tls.hpp,crypto\crypto_tls.hpp:<global>,,false,1,297,<global>,,,1,
66102,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"[](void* data, size_t length, void* deleter_data) {
        OPENSSL_clear_free(deleter_data, length);
      }",7,7,crypto\crypto_util.cc,node.crypto.ByteSource.ReleaseToBackingStore.<lambda>0,,false,358,360,<lambda>0,,,1,"ANY node.crypto.ByteSource.ReleaseToBackingStore.<lambda>0 (void*,size_t,void*)"
66114,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"[](void* data, size_t len, void* deleter_data) {
            OPENSSL_secure_clear_free(data, len);
          }",11,11,crypto\crypto_util.cc,node.crypto.anonymous_namespace_2.SecureBuffer.<lambda>1,,false,728,730,<lambda>1,,,1,"ANY node.crypto.anonymous_namespace_2.SecureBuffer.<lambda>1 (void*,size_t,void*)"
66158,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,<global>,1,36,crypto\crypto_util.hpp,crypto\crypto_util.cc:<global>,,false,1,776,<global>,,,1,
66162,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"int VerifyCallback(int preverify_ok, X509_STORE_CTX* ctx) {
  // From https://www.openssl.org/docs/man1.1.1/man3/SSL_verify_cb:
  //
  //   If VerifyCallback returns 1, the verification process is continued. If
  //   VerifyCallback always returns 1, the TLS/SSL handshake will not be
  //   terminated with respect to verification failures and the connection will
  //   be established. The calling process can however retrieve the error code
  //   of the last verification error using SSL_get_verify_result(3) or by
  //   maintaining its own error storage managed by VerifyCallback.
  //
  // Since we cannot perform I/O quickly enough with X509_STORE_CTX_ APIs in
  // this callback, we ignore all preverify_ok errors and let the handshake
  // continue. It is imperative that the user use Connection::VerifyError after
  // the 'secure' callback has been made.
  return 1;
}",1,1,crypto\crypto_util.cc,node.crypto.VerifyCallback,,false,46,61,VerifyCallback,,,1,"int node.crypto.VerifyCallback (int,X509_STORE_CTX*)"
66171,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"CSPRNGResult CSPRNG(void* buffer, size_t length) {
  unsigned char* buf = static_cast<unsigned char*>(buffer);
  do {
    if (1 == RAND_status()) {
#if OPENSSL_VERSION_MAJOR >= 3
      if (1 == RAND_bytes_ex(nullptr, buf, length, 0)) return {true};
#else
      while (length > INT_MAX && 1 == RAND_bytes(buf, INT_MAX)) {
        buf += INT_MAX;
        length -= INT_MAX;
      }
      if (length <= INT_MAX && 1 == RAND_bytes(buf, static_cast<int>(length)))
        return {true};
#endif
    }
#if OPENSSL_VERSION_MAJOR >= 3
    const auto code = ERR_peek_last_error();
    // A misconfigured OpenSSL 3 installation may report 1 from RAND_poll()
    // and RAND_status() but fail in RAND_bytes() if it cannot look up
    // a matching algorithm for the CSPRNG.
    if (ERR_GET_LIB(code) == ERR_LIB_RAND) {
      const auto reason = ERR_GET_REASON(code);
      if (reason == RAND_R_ERROR_INSTANTIATING_DRBG ||
          reason == RAND_R_UNABLE_TO_FETCH_DRBG ||
          reason == RAND_R_UNABLE_TO...",17,1,crypto\crypto_util.cc,node.crypto.CSPRNG,,false,63,95,CSPRNG,,,3,"CSPRNGResult node.crypto.CSPRNG (void*,size_t)"
66225,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"int PasswordCallback(char* buf, int size, int rwflag, void* u) {
  const ByteSource* passphrase = *static_cast<const ByteSource**>(u);
  if (passphrase != nullptr) {
    size_t buflen = static_cast<size_t>(size);
    size_t len = passphrase->size();
    if (buflen < len)
      return -1;
    memcpy(buf, passphrase->data(), len);
    return len;
  }

  return -1;
}",1,1,crypto\crypto_util.cc,node.crypto.PasswordCallback,,false,97,109,PasswordCallback,,,4,"int node.crypto.PasswordCallback (char*,int,int,void*)"
66278,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"int NoPasswordCallback(char* buf, int size, int rwflag, void* u) {
  return 0;
}",1,1,crypto\crypto_util.cc,node.crypto.NoPasswordCallback,,false,116,118,NoPasswordCallback,,,5,"int node.crypto.NoPasswordCallback (char*,int,int,void*)"
66288,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"bool ProcessFipsOptions() {
  /* Override FIPS settings in configuration file, if needed. */
  if (per_process::cli_options->enable_fips_crypto ||
      per_process::cli_options->force_fips_crypto) {
#if OPENSSL_VERSION_MAJOR >= 3
    OSSL_PROVIDER* fips_provider = OSSL_PROVIDER_load(nullptr, ""fips"");
    if (fips_provider == nullptr)
      return false;
    OSSL_PROVIDER_unload(fips_provider);

    return EVP_default_properties_enable_fips(nullptr, 1) &&
           EVP_default_properties_is_fips_enabled(nullptr);
#else
    if (FIPS_mode() == 0) return FIPS_mode_set(1);

#endif
  }
  return true;
}",1,1,crypto\crypto_util.cc,node.crypto.ProcessFipsOptions,,false,120,138,ProcessFipsOptions,,,6,bool node.crypto.ProcessFipsOptions ()
66315,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"bool InitCryptoOnce(Isolate* isolate) {
  static uv_once_t init_once = UV_ONCE_INIT;
  TryCatch try_catch{isolate};
  uv_once(&init_once, InitCryptoOnce);
  if (try_catch.HasCaught() && !try_catch.HasTerminated()) {
    try_catch.ReThrow();
    return false;
  }
  return true;
}",1,1,crypto\crypto_util.cc,node.crypto.InitCryptoOnce,,false,140,149,InitCryptoOnce,,,7,bool node.crypto.InitCryptoOnce (Isolate*)
66354,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"void InitCryptoOnce() {
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Mutex::ScopedLock fips_lock(fips_mutex);
#ifndef OPENSSL_IS_BORINGSSL
  OPENSSL_INIT_SETTINGS* settings = OPENSSL_INIT_new();

#if OPENSSL_VERSION_MAJOR < 3
  // --openssl-config=...
  if (!per_process::cli_options->openssl_config.empty()) {
    const char* conf = per_process::cli_options->openssl_config.c_str();
    OPENSSL_INIT_set_config_filename(settings, conf);
  }
#endif

#if OPENSSL_VERSION_MAJOR >= 3
  // --openssl-legacy-provider
  if (per_process::cli_options->openssl_legacy_provider) {
    OSSL_PROVIDER* legacy_provider = OSSL_PROVIDER_load(nullptr, ""legacy"");
    if (legacy_provider == nullptr) {
      fprintf(stderr, ""Unable to load legacy provider.\n"");
    }
  }
#endif

  OPENSSL_init_ssl(0, settings);
  OPENSSL_INIT_free(settings);
  settings = nullptr;

#ifndef _WIN32
  if (per_process::cli_options->secure_heap != 0) {
    switch (CRYPTO_secure_malloc_init(
                per_proces...",1,1,crypto\crypto_util.cc,node.crypto.InitCryptoOnce,,false,155,212,InitCryptoOnce,,,9,void node.crypto.InitCryptoOnce ()
66445,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"void GetFipsCrypto(const FunctionCallbackInfo<Value>& args) {
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Mutex::ScopedLock fips_lock(fips_mutex);

#if OPENSSL_VERSION_MAJOR >= 3
  args.GetReturnValue().Set(EVP_default_properties_is_fips_enabled(nullptr) ?
      1 : 0);
#else
  args.GetReturnValue().Set(FIPS_mode() ? 1 : 0);
#endif
}",1,1,crypto\crypto_util.cc,node.crypto.GetFipsCrypto,,false,214,224,GetFipsCrypto,,,10,void node.crypto.GetFipsCrypto (FunctionCallbackInfo<Value>)
66469,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"void SetFipsCrypto(const FunctionCallbackInfo<Value>& args) {
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Mutex::ScopedLock fips_lock(fips_mutex);

  CHECK(!per_process::cli_options->force_fips_crypto);
  Environment* env = Environment::GetCurrent(args);
  CHECK(env->owns_process_state());
  bool enable = args[0]->BooleanValue(env->isolate());

#if OPENSSL_VERSION_MAJOR >= 3
  if (enable == EVP_default_properties_is_fips_enabled(nullptr))
#else
  if (static_cast<int>(enable) == FIPS_mode())
#endif
    return;  // No action needed.

#if OPENSSL_VERSION_MAJOR >= 3
  if (!EVP_default_properties_enable_fips(nullptr, enable)) {
#else
  if (!FIPS_mode_set(enable)) {
#endif
    unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
    return ThrowCryptoError(env, err);
  }
}",1,1,crypto\crypto_util.cc,node.crypto.SetFipsCrypto,,false,226,250,SetFipsCrypto,,,11,void node.crypto.SetFipsCrypto (FunctionCallbackInfo<Value>)
66536,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"void TestFipsCrypto(const v8::FunctionCallbackInfo<v8::Value>& args) {
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Mutex::ScopedLock fips_lock(fips_mutex);

#if OPENSSL_VERSION_MAJOR >= 3
  OSSL_PROVIDER* fips_provider = nullptr;
  if (OSSL_PROVIDER_available(nullptr, ""fips"")) {
    fips_provider = OSSL_PROVIDER_load(nullptr, ""fips"");
  }
  const auto enabled = fips_provider == nullptr ? 0 :
      OSSL_PROVIDER_self_test(fips_provider) ? 1 : 0;
#else
#ifdef OPENSSL_FIPS
  const auto enabled = FIPS_selftest() ? 1 : 0;
#else  // OPENSSL_FIPS
  const auto enabled = 0;
#endif  // OPENSSL_FIPS
#endif

  args.GetReturnValue().Set(enabled);
}",1,1,crypto\crypto_util.cc,node.crypto.TestFipsCrypto,,false,252,272,TestFipsCrypto,,,12,void node.crypto.TestFipsCrypto (ANY)
66561,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"void CryptoErrorStore::Capture() {
  errors_.clear();
  while (const uint32_t err = ERR_get_error()) {
    char buf[256];
    ERR_error_string_n(err, buf, sizeof(buf));
    errors_.emplace_back(buf);
  }
  std::reverse(std::begin(errors_), std::end(errors_));
}",1,1,crypto\crypto_util.cc,node.crypto.CryptoErrorStore.Capture,,false,274,282,Capture,,,13,void node.crypto.CryptoErrorStore.Capture ()
66596,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"bool CryptoErrorStore::Empty() const {
  return errors_.empty();
}",1,1,crypto\crypto_util.cc,node.crypto.CryptoErrorStore.Empty,,false,284,286,Empty,,,14,bool node.crypto.CryptoErrorStore.Empty ()
66605,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"MaybeLocal<Value> CryptoErrorStore::ToException(
    Environment* env,
    Local<String> exception_string) const {
  if (exception_string.IsEmpty()) {
    CryptoErrorStore copy(*this);
    if (copy.Empty()) {
      // But possibly a bug...
      copy.Insert(NodeCryptoError::OK);
    }
    // Use last element as the error message, everything else goes
    // into the .opensslErrorStack property on the exception object.
    const std::string& last_error_string = copy.errors_.back();
    Local<String> exception_string;
    if (!String::NewFromUtf8(
            env->isolate(),
            last_error_string.data(),
            NewStringType::kNormal,
            last_error_string.size()).ToLocal(&exception_string)) {
      return MaybeLocal<Value>();
    }
    copy.errors_.pop_back();
    return copy.ToException(env, exception_string);
  }

  Local<Value> exception_v = Exception::Error(exception_string);
  CHECK(!exception_v.IsEmpty());

  if (!Empty()) {
    CHECK(exception_v->IsObject(...",1,1,crypto\crypto_util.cc,node.crypto.CryptoErrorStore.ToException,,false,288,327,ToException,,,15,"MaybeLocal<Value> node.crypto.CryptoErrorStore.ToException (Environment*,Local<String>)"
66766,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"ByteSource::ByteSource(ByteSource&& other) noexcept
    : data_(other.data_),
      allocated_data_(other.allocated_data_),
      size_(other.size_) {
  other.allocated_data_ = nullptr;
}",1,1,crypto\crypto_util.cc,node.crypto.ByteSource.ByteSource,,false,329,334,ByteSource,,,16,ANY node.crypto.ByteSource.ByteSource (ByteSource)
66776,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"ByteSource::~ByteSource() {
  OPENSSL_clear_free(allocated_data_, size_);
}",1,1,crypto\crypto_util.cc,node.crypto.ByteSource.~ByteSource,,false,336,338,~ByteSource,,,17,ANY node.crypto.ByteSource.~ByteSource ()
66783,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"ByteSource& ByteSource::operator=(ByteSource&& other) noexcept {
  if (&other != this) {
    OPENSSL_clear_free(allocated_data_, size_);
    data_ = other.data_;
    allocated_data_ = other.allocated_data_;
    other.allocated_data_ = nullptr;
    size_ = other.size_;
  }
  return *this;
}",1,1,crypto\crypto_util.cc,node.crypto.ByteSource.operator =,,false,340,349,operator =,,,18,ByteSource node.crypto.ByteSource.operator = (ByteSource)
66820,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"std::unique_ptr<BackingStore> ByteSource::ReleaseToBackingStore() {
  // It's ok for allocated_data_ to be nullptr but
  // only if size_ is zero.
  CHECK_IMPLIES(size_ > 0, allocated_data_ != nullptr);
  std::unique_ptr<BackingStore> ptr = ArrayBuffer::NewBackingStore(
      allocated_data_,
      size(),
      [](void* data, size_t length, void* deleter_data) {
        OPENSSL_clear_free(deleter_data, length);
      }, allocated_data_);
  CHECK(ptr);
  allocated_data_ = nullptr;
  data_ = nullptr;
  size_ = 0;
  return ptr;
}",1,1,crypto\crypto_util.cc,node.crypto.ByteSource.ReleaseToBackingStore,,false,351,366,ReleaseToBackingStore,,,19,unique_ptr<BackingStore> node.crypto.ByteSource.ReleaseToBackingStore ()
66859,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"Local<ArrayBuffer> ByteSource::ToArrayBuffer(Environment* env) {
  std::unique_ptr<BackingStore> store = ReleaseToBackingStore();
  return ArrayBuffer::New(env->isolate(), std::move(store));
}",1,1,crypto\crypto_util.cc,node.crypto.ByteSource.ToArrayBuffer,,false,368,371,ToArrayBuffer,,,20,Local<ArrayBuffer> node.crypto.ByteSource.ToArrayBuffer (Environment*)
66887,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"MaybeLocal<Uint8Array> ByteSource::ToBuffer(Environment* env) {
  Local<ArrayBuffer> ab = ToArrayBuffer(env);
  return Buffer::New(env, ab, 0, ab->ByteLength());
}",1,1,crypto\crypto_util.cc,node.crypto.ByteSource.ToBuffer,,false,373,376,ToBuffer,,,21,MaybeLocal<Uint8Array> node.crypto.ByteSource.ToBuffer (Environment*)
66912,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"ByteSource ByteSource::FromBIO(const BIOPointer& bio) {
  CHECK(bio);
  BUF_MEM* bptr;
  BIO_get_mem_ptr(bio.get(), &bptr);
  ByteSource::Builder out(bptr->length);
  memcpy(out.data<void>(), bptr->data, bptr->length);
  return std::move(out).release();
}",1,1,crypto\crypto_util.cc,node.crypto.ByteSource.FromBIO,,false,378,385,FromBIO,,,22,ByteSource node.crypto.ByteSource.FromBIO (BIOPointer)
66952,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"ByteSource ByteSource::FromEncodedString(Environment* env,
                                         Local<String> key,
                                         enum encoding enc) {
  size_t length = 0;
  ByteSource out;

  if (StringBytes::Size(env->isolate(), key, enc).To(&length) && length > 0) {
    ByteSource::Builder buf(length);
    size_t actual =
        StringBytes::Write(env->isolate(), buf.data<char>(), length, key, enc);
    out = std::move(buf).release(actual);
  }

  return out;
}",1,1,crypto\crypto_util.cc,node.crypto.ByteSource.FromEncodedString,,false,387,401,FromEncodedString,,,23,"ByteSource node.crypto.ByteSource.FromEncodedString (Environment*,Local<String>,encoding)"
67019,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"ByteSource ByteSource::FromStringOrBuffer(Environment* env,
                                          Local<Value> value) {
  return IsAnyByteSource(value) ? FromBuffer(value)
                                : FromString(env, value.As<String>());
}",1,1,crypto\crypto_util.cc,node.crypto.ByteSource.FromStringOrBuffer,,false,403,407,FromStringOrBuffer,,,24,"ByteSource node.crypto.ByteSource.FromStringOrBuffer (Environment*,Local<Value>)"
67037,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"ByteSource ByteSource::FromString(Environment* env, Local<String> str,
                                  bool ntc) {
  CHECK(str->IsString());
  size_t size = str->Utf8Length(env->isolate());
  size_t alloc_size = ntc ? size + 1 : size;
  ByteSource::Builder out(alloc_size);
  int opts = String::NO_OPTIONS;
  if (!ntc) opts |= String::NO_NULL_TERMINATION;
  str->WriteUtf8(env->isolate(), out.data<char>(), alloc_size, nullptr, opts);
  return std::move(out).release();
}",1,1,crypto\crypto_util.cc,node.crypto.ByteSource.FromString,,false,409,419,FromString,,,25,"ByteSource node.crypto.ByteSource.FromString (Environment*,Local<String>,bool)"
67111,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"ByteSource ByteSource::FromBuffer(Local<Value> buffer, bool ntc) {
  ArrayBufferOrViewContents<char> buf(buffer);
  return ntc ? buf.ToNullTerminatedCopy() : buf.ToByteSource();
}",1,1,crypto\crypto_util.cc,node.crypto.ByteSource.FromBuffer,,false,421,424,FromBuffer,,,26,"ByteSource node.crypto.ByteSource.FromBuffer (Local<Value>,bool)"
67131,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"ByteSource ByteSource::FromSecretKeyBytes(
    Environment* env,
    Local<Value> value) {
  // A key can be passed as a string, buffer or KeyObject with type 'secret'.
  // If it is a string, we need to convert it to a buffer. We are not doing that
  // in JS to avoid creating an unprotected copy on the heap.
  return value->IsString() || IsAnyByteSource(value) ?
           ByteSource::FromStringOrBuffer(env, value) :
           ByteSource::FromSymmetricKeyObjectHandle(value);
}",1,1,crypto\crypto_util.cc,node.crypto.ByteSource.FromSecretKeyBytes,,false,426,435,FromSecretKeyBytes,,,27,"ByteSource node.crypto.ByteSource.FromSecretKeyBytes (Environment*,Local<Value>)"
67157,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"ByteSource ByteSource::NullTerminatedCopy(Environment* env,
                                          Local<Value> value) {
  return Buffer::HasInstance(value) ? FromBuffer(value, true)
                                    : FromString(env, value.As<String>(), true);
}",1,1,crypto\crypto_util.cc,node.crypto.ByteSource.NullTerminatedCopy,,false,437,441,NullTerminatedCopy,,,28,"ByteSource node.crypto.ByteSource.NullTerminatedCopy (Environment*,Local<Value>)"
67180,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"ByteSource ByteSource::FromSymmetricKeyObjectHandle(Local<Value> handle) {
  CHECK(handle->IsObject());
  KeyObjectHandle* key = Unwrap<KeyObjectHandle>(handle.As<Object>());
  CHECK_NOT_NULL(key);
  return Foreign(key->Data()->GetSymmetricKey(),
                 key->Data()->GetSymmetricKeySize());
}",1,1,crypto\crypto_util.cc,node.crypto.ByteSource.FromSymmetricKeyObjectHandle,,false,443,449,FromSymmetricKeyObjectHandle,,,29,ByteSource node.crypto.ByteSource.FromSymmetricKeyObjectHandle (Local<Value>)
67219,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"ByteSource ByteSource::Allocated(void* data, size_t size) {
  return ByteSource(data, data, size);
}",1,1,crypto\crypto_util.cc,node.crypto.ByteSource.Allocated,,false,451,453,Allocated,,,30,"ByteSource node.crypto.ByteSource.Allocated (void*,size_t)"
67230,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"ByteSource ByteSource::Foreign(const void* data, size_t size) {
  return ByteSource(data, nullptr, size);
}",1,1,crypto\crypto_util.cc,node.crypto.ByteSource.Foreign,,false,455,457,Foreign,,,31,"ByteSource node.crypto.ByteSource.Foreign (void*,size_t)"
67242,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"Maybe<bool> Decorate(Environment* env, Local<Object> obj,
              unsigned long err) {  // NOLINT(runtime/int)
  if (err == 0) return Just(true);  // No decoration necessary.

  const char* ls = ERR_lib_error_string(err);
  const char* fs = ERR_func_error_string(err);
  const char* rs = ERR_reason_error_string(err);

  Isolate* isolate = env->isolate();
  Local<Context> context = isolate->GetCurrentContext();

  if (ls != nullptr) {
    if (obj->Set(context, env->library_string(),
                 OneByteString(isolate, ls)).IsNothing()) {
      return Nothing<bool>();
    }
  }
  if (fs != nullptr) {
    if (obj->Set(context, env->function_string(),
                 OneByteString(isolate, fs)).IsNothing()) {
      return Nothing<bool>();
    }
  }
  if (rs != nullptr) {
    if (obj->Set(context, env->reason_string(),
                 OneByteString(isolate, rs)).IsNothing()) {
      return Nothing<bool>();
    }

    // SSL has no API to recover the error name from the number,...",1,32,crypto\crypto_util.cc,node.crypto.error.Decorate,,false,460,563,Decorate,,,1,"Maybe<bool> node.crypto.error.Decorate (Environment*,Local<Object>,long unsigned)"
67673,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"void ThrowCryptoError(Environment* env,
                      unsigned long err,  // NOLINT(runtime/int)
                      // Default, only used if there is no SSL `err` which can
                      // be used to create a long-style message string.
                      const char* message) {
  char message_buffer[128] = {0};
  if (err != 0 || message == nullptr) {
    ERR_error_string_n(err, message_buffer, sizeof(message_buffer));
    message = message_buffer;
  }
  HandleScope scope(env->isolate());
  Local<String> exception_string;
  Local<Value> exception;
  Local<Object> obj;
  if (!String::NewFromUtf8(env->isolate(), message).ToLocal(&exception_string))
    return;
  CryptoErrorStore errors;
  errors.Capture();
  if (!errors.ToException(env, exception_string).ToLocal(&exception) ||
      !exception->ToObject(env->context()).ToLocal(&obj) ||
      error::Decorate(env, obj, err).IsNothing()) {
    return;
  }
  env->isolate()->ThrowException(exception);
}",1,1,crypto\crypto_util.cc,node.crypto.ThrowCryptoError,,false,566,590,ThrowCryptoError,,,33,"void node.crypto.ThrowCryptoError (Environment*,long unsigned,char*)"
67795,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"EnginePointer LoadEngineById(const char* id, CryptoErrorStore* errors) {
  MarkPopErrorOnReturn mark_pop_error_on_return;

  EnginePointer engine(ENGINE_by_id(id));
  if (!engine) {
    // Engine not found, try loading dynamically.
    engine = EnginePointer(ENGINE_by_id(""dynamic""));
    if (engine) {
      if (!ENGINE_ctrl_cmd_string(engine.get(), ""SO_PATH"", id, 0) ||
          !ENGINE_ctrl_cmd_string(engine.get(), ""LOAD"", nullptr, 0)) {
        engine.reset();
      }
    }
  }

  if (!engine && errors != nullptr) {
    errors->Capture();
    if (errors->Empty()) {
      errors->Insert(NodeCryptoError::ENGINE_NOT_FOUND, id);
    }
  }

  return engine;
}",1,1,crypto\crypto_util.cc,node.crypto.LoadEngineById,,false,593,616,LoadEngineById,,,34,"EnginePointer node.crypto.LoadEngineById (char*,CryptoErrorStore*)"
67871,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"bool SetEngine(const char* id, uint32_t flags, CryptoErrorStore* errors) {
  ClearErrorOnReturn clear_error_on_return;
  EnginePointer engine = LoadEngineById(id, errors);
  if (!engine)
    return false;

  if (!ENGINE_set_default(engine.get(), flags)) {
    if (errors != nullptr)
      errors->Capture();
    return false;
  }

  return true;
}",1,1,crypto\crypto_util.cc,node.crypto.SetEngine,,false,618,631,SetEngine,,,35,"bool node.crypto.SetEngine (char*,uint32_t,CryptoErrorStore*)"
67913,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"void SetEngine(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(args.Length() >= 2 && args[0]->IsString());
  uint32_t flags;
  if (!args[1]->Uint32Value(env->context()).To(&flags)) return;

  const node::Utf8Value engine_id(env->isolate(), args[0]);

  if (UNLIKELY(env->permission()->enabled())) {
    return THROW_ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED(
        env,
        ""Programmatic selection of OpenSSL engines is unsupported while the ""
        ""experimental permission model is enabled"");
  }

  args.GetReturnValue().Set(SetEngine(*engine_id, flags));
}",1,1,crypto\crypto_util.cc,node.crypto.SetEngine,,false,633,649,SetEngine,,,36,void node.crypto.SetEngine (FunctionCallbackInfo<Value>)
67994,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"MaybeLocal<Value> EncodeBignum(
    Environment* env,
    const BIGNUM* bn,
    int size,
    Local<Value>* error) {
  std::vector<uint8_t> buf(size);
  CHECK_EQ(BN_bn2binpad(bn, buf.data(), size), size);
  return StringBytes::Encode(
      env->isolate(),
      reinterpret_cast<const char*>(buf.data()),
      buf.size(),
      BASE64URL,
      error);
}",1,1,crypto\crypto_util.cc,node.crypto.EncodeBignum,,false,652,665,EncodeBignum,,,37,"MaybeLocal<Value> node.crypto.EncodeBignum (Environment*,BIGNUM*,int,Local<Value>*)"
68040,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"Maybe<bool> SetEncodedValue(
    Environment* env,
    Local<Object> target,
    Local<String> name,
    const BIGNUM* bn,
    int size) {
  Local<Value> value;
  Local<Value> error;
  CHECK_NOT_NULL(bn);
  if (size == 0)
    size = BN_num_bytes(bn);
  if (!EncodeBignum(env, bn, size, &error).ToLocal(&value)) {
    if (!error.IsEmpty())
      env->isolate()->ThrowException(error);
    return Nothing<bool>();
  }
  return target->Set(env->context(), name, value);
}",1,1,crypto\crypto_util.cc,node.crypto.SetEncodedValue,,false,667,684,SetEncodedValue,,,38,"Maybe<bool> node.crypto.SetEncodedValue (Environment*,Local<Object>,Local<String>,BIGNUM*,int)"
68112,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"bool SetRsaOaepLabel(const EVPKeyCtxPointer& ctx, const ByteSource& label) {
  if (label.size() != 0) {
    // OpenSSL takes ownership of the label, so we need to create a copy.
    void* label_copy = OPENSSL_memdup(label.data(), label.size());
    CHECK_NOT_NULL(label_copy);
    int ret = EVP_PKEY_CTX_set0_rsa_oaep_label(
        ctx.get(), static_cast<unsigned char*>(label_copy), label.size());
    if (ret <= 0) {
      OPENSSL_free(label_copy);
      return false;
    }
  }
  return true;
}",1,1,crypto\crypto_util.cc,node.crypto.SetRsaOaepLabel,,false,686,699,SetRsaOaepLabel,,,39,"bool node.crypto.SetRsaOaepLabel (EVPKeyCtxPointer,ByteSource)"
68166,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"CryptoJobMode GetCryptoJobMode(v8::Local<v8::Value> args) {
  CHECK(args->IsUint32());
  uint32_t mode = args.As<v8::Uint32>()->Value();
  CHECK_LE(mode, kCryptoJobSync);
  return static_cast<CryptoJobMode>(mode);
}",1,1,crypto\crypto_util.cc,node.crypto.GetCryptoJobMode,,false,701,706,GetCryptoJobMode,,,40,CryptoJobMode node.crypto.GetCryptoJobMode (ANY)
68194,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"void SecureBuffer(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsUint32());
  Environment* env = Environment::GetCurrent(args);
  uint32_t len = args[0].As<Uint32>()->Value();
  void* data = OPENSSL_secure_zalloc(len);
  if (data == nullptr) {
    // There's no memory available for the allocation.
    // Return nothing.
    return;
  }
  std::shared_ptr<BackingStore> store =
      ArrayBuffer::NewBackingStore(
          data,
          len,
          [](void* data, size_t len, void* deleter_data) {
            OPENSSL_secure_clear_free(data, len);
          },
          data);
  Local<ArrayBuffer> buffer = ArrayBuffer::New(env->isolate(), store);
  args.GetReturnValue().Set(Uint8Array::New(buffer, 0, len));
}",1,1,crypto\crypto_util.cc,node.crypto.anonymous_namespace_1.SecureBuffer,,false,714,734,SecureBuffer,,,1,void node.crypto.anonymous_namespace_1.SecureBuffer (FunctionCallbackInfo<Value>)
68280,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"void SecureHeapUsed(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  if (CRYPTO_secure_malloc_initialized())
    args.GetReturnValue().Set(
        BigInt::New(env->isolate(), CRYPTO_secure_used()));
}",1,1,crypto\crypto_util.cc,node.crypto.anonymous_namespace_3.SecureHeapUsed,,false,736,741,SecureHeapUsed,,,2,void node.crypto.anonymous_namespace_3.SecureHeapUsed (FunctionCallbackInfo<Value>)
68313,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"void Initialize(Environment* env, Local<Object> target) {
  Local<Context> context = env->context();
#ifndef OPENSSL_NO_ENGINE
  SetMethod(context, target, ""setEngine"", SetEngine);
#endif  // !OPENSSL_NO_ENGINE

  SetMethodNoSideEffect(context, target, ""getFipsCrypto"", GetFipsCrypto);
  SetMethod(context, target, ""setFipsCrypto"", SetFipsCrypto);
  SetMethodNoSideEffect(context, target, ""testFipsCrypto"", TestFipsCrypto);

  NODE_DEFINE_CONSTANT(target, kCryptoJobAsync);
  NODE_DEFINE_CONSTANT(target, kCryptoJobSync);

  SetMethod(context, target, ""secureBuffer"", SecureBuffer);
  SetMethod(context, target, ""secureHeapUsed"", SecureHeapUsed);
}",1,2,crypto\crypto_util.cc,node.crypto.Util.Initialize,,false,745,760,Initialize,,,1,"void node.crypto.Util.Initialize (Environment*,Local<Object>)"
68557,METHOD,crypto\crypto_util.cc:<global>,TYPE_DECL,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
#ifndef OPENSSL_NO_ENGINE
  registry->Register(SetEngine);
#endif  // !OPENSSL_NO_ENGINE

  registry->Register(GetFipsCrypto);
  registry->Register(SetFipsCrypto);
  registry->Register(TestFipsCrypto);
  registry->Register(SecureBuffer);
  registry->Register(SecureHeapUsed);
}",1,1,crypto\crypto_util.cc,node.crypto.Util.RegisterExternalReferences,,false,761,771,RegisterExternalReferences,,,2,void node.crypto.Util.RegisterExternalReferences (ExternalReferenceRegistry*)
68645,METHOD,crypto\crypto_util.hpp:<global>,TYPE_DECL,<global>,1,36,crypto\crypto_util.hpp,crypto\crypto_util.hpp:<global>,,false,1,805,<global>,,,1,
68676,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,<global>,1,33,base_object-inl.hpp,crypto\crypto_x509.cc:<global>,,false,1,546,<global>,,,1,
68680,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,ManagedX509::ManagedX509(X509Pointer&& cert) : cert_(std::move(cert)) {},1,72,crypto\crypto_x509.cc,node.crypto.ManagedX509.ManagedX509,,false,33,33,ManagedX509,,,1,ANY node.crypto.ManagedX509.ManagedX509 (X509Pointer)
68685,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,"ManagedX509::ManagedX509(const ManagedX509& that) {
  *this = that;
}",1,1,crypto\crypto_x509.cc,node.crypto.ManagedX509.ManagedX509,,false,35,37,ManagedX509,,,2,ANY node.crypto.ManagedX509.ManagedX509 (ManagedX509)
68694,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,"ManagedX509& ManagedX509::operator=(const ManagedX509& that) {
  cert_.reset(that.get());

  if (cert_)
    X509_up_ref(cert_.get());

  return *this;
}",1,1,crypto\crypto_x509.cc,node.crypto.ManagedX509.operator =,,false,39,46,operator =,,,3,ManagedX509 node.crypto.ManagedX509.operator = (ManagedX509)
68718,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,"void ManagedX509::MemoryInfo(MemoryTracker* tracker) const {
  // This is an approximation based on the der encoding size.
  int size = i2d_X509(cert_.get(), nullptr);
  tracker->TrackFieldWithSize(""cert"", size);
}",1,1,crypto\crypto_x509.cc,node.crypto.ManagedX509.MemoryInfo,,false,48,52,MemoryInfo,,,4,void node.crypto.ManagedX509.MemoryInfo (MemoryTracker*)
68739,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,"void Fingerprint(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  Local<Value> ret;
  if (GetFingerprintDigest(env, algo(), cert->get()).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",1,1,crypto\crypto_x509.cc,node.crypto.anonymous_namespace_1.Fingerprint,,false,56,63,Fingerprint,,,1,void node.crypto.anonymous_namespace_1.Fingerprint<const EVP_MD*(*)()> (FunctionCallbackInfo<Value>)
68787,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,"Local<FunctionTemplate> X509Certificate::GetConstructorTemplate(
    Environment* env) {
  Local<FunctionTemplate> tmpl = env->x509_constructor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        BaseObject::kInternalFieldCount);
    tmpl->SetClassName(
        FIXED_ONE_BYTE_STRING(env->isolate(), ""X509Certificate""));
    SetProtoMethod(isolate, tmpl, ""subject"", Subject);
    SetProtoMethod(isolate, tmpl, ""subjectAltName"", SubjectAltName);
    SetProtoMethod(isolate, tmpl, ""infoAccess"", InfoAccess);
    SetProtoMethod(isolate, tmpl, ""issuer"", Issuer);
    SetProtoMethod(isolate, tmpl, ""validTo"", ValidTo);
    SetProtoMethod(isolate, tmpl, ""validFrom"", ValidFrom);
    SetProtoMethod(isolate, tmpl, ""fingerprint"", Fingerprint<EVP_sha1>);
    SetProtoMethod(isolate, tmpl, ""fingerprint256"", Fingerprint<EVP_sha256>);
    SetProtoMethod(isolate, tmpl, ""fing...",1,1,crypto\crypto_x509.cc,node.crypto.X509Certificate.GetConstructorTemplate,,false,66,102,GetConstructorTemplate,,,6,Local<FunctionTemplate> node.crypto.X509Certificate.GetConstructorTemplate (Environment*)
68962,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,"bool X509Certificate::HasInstance(Environment* env, Local<Object> object) {
  return GetConstructorTemplate(env)->HasInstance(object);
}",1,1,crypto\crypto_x509.cc,node.crypto.X509Certificate.HasInstance,,false,104,106,HasInstance,,,7,"bool node.crypto.X509Certificate.HasInstance (Environment*,Local<Object>)"
68977,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,"MaybeLocal<Object> X509Certificate::GetCert(
    Environment* env,
    const SSLPointer& ssl) {
  ClearErrorOnReturn clear_error_on_return;
  X509* cert = SSL_get_certificate(ssl.get());
  if (cert == nullptr)
    return MaybeLocal<Object>();

  X509Pointer ptr(X509_dup(cert));
  return New(env, std::move(ptr));
}",1,1,crypto\crypto_x509.cc,node.crypto.X509Certificate.GetCert,,false,133,143,GetCert,,,10,"MaybeLocal<Object> node.crypto.X509Certificate.GetCert (Environment*,SSLPointer)"
69011,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,"MaybeLocal<Object> X509Certificate::GetPeerCert(
    Environment* env,
    const SSLPointer& ssl,
    GetPeerCertificateFlag flag) {
  ClearErrorOnReturn clear_error_on_return;
  MaybeLocal<Object> maybe_cert;

  bool is_server =
      static_cast<int>(flag) & static_cast<int>(GetPeerCertificateFlag::SERVER);

  X509Pointer cert(is_server ? SSL_get_peer_certificate(ssl.get()) : nullptr);
  STACK_OF(X509)* ssl_certs = SSL_get_peer_cert_chain(ssl.get());
  if (!cert && (ssl_certs == nullptr || sk_X509_num(ssl_certs) == 0))
    return MaybeLocal<Object>();

  std::vector<Local<Value>> certs;

  if (!cert) {
    cert.reset(sk_X509_value(ssl_certs, 0));
    sk_X509_delete(ssl_certs, 0);
  }

  return sk_X509_num(ssl_certs)
      ? New(env, std::move(cert), ssl_certs)
      : New(env, std::move(cert));
}",1,1,crypto\crypto_x509.cc,node.crypto.X509Certificate.GetPeerCert,,false,145,170,GetPeerCert,,,11,"MaybeLocal<Object> node.crypto.X509Certificate.GetPeerCert (Environment*,SSLPointer,GetPeerCertificateFlag)"
69113,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,"void X509Certificate::Parse(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsArrayBufferView());
  ArrayBufferViewContents<unsigned char> buf(args[0].As<ArrayBufferView>());
  const unsigned char* data = buf.data();
  unsigned data_len = buf.length();

  ClearErrorOnReturn clear_error_on_return;
  BIOPointer bio(LoadBIO(env, args[0]));
  if (!bio)
    return ThrowCryptoError(env, ERR_get_error());

  Local<Object> cert;

  X509Pointer pem(PEM_read_bio_X509_AUX(
      bio.get(), nullptr, NoPasswordCallback, nullptr));
  if (!pem) {
    // Try as DER, but return the original PEM failure if it isn't DER.
    MarkPopErrorOnReturn mark_here;

    X509Pointer der(d2i_X509(nullptr, &data, data_len));
    if (!der)
      return ThrowCryptoError(env, ERR_get_error());

    if (!X509Certificate::New(env, std::move(der)).ToLocal(&cert))
      return;
  } else if (!X509Certificate::New(env, std::move(pem)).ToLocal(&cert)) {
    r...",1,1,crypto\crypto_x509.cc,node.crypto.X509Certificate.Parse,,false,172,204,Parse,,,12,void node.crypto.X509Certificate.Parse (FunctionCallbackInfo<Value>)
69254,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,"static void ReturnPropertyThroughBIO(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);
  Local<Value> ret;
  if (Property(env, cert->get(), bio).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",1,1,crypto\crypto_x509.cc,node.crypto.ReturnPropertyThroughBIO,,false,208,217,ReturnPropertyThroughBIO,,,13,"void node.crypto.ReturnPropertyThroughBIO<MaybeLocal<Value>(Environment*, X509*, const BIOPointer&)> (FunctionCallbackInfo<Value>)"
69308,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,"void X509Certificate::Subject(const FunctionCallbackInfo<Value>& args) {
  ReturnPropertyThroughBIO<GetSubject>(args);
}",1,1,crypto\crypto_x509.cc,node.crypto.X509Certificate.Subject,,false,219,221,Subject,,,14,void node.crypto.X509Certificate.Subject (FunctionCallbackInfo<Value>)
69318,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,"void X509Certificate::Issuer(const FunctionCallbackInfo<Value>& args) {
  ReturnPropertyThroughBIO<GetIssuerString>(args);
}",1,1,crypto\crypto_x509.cc,node.crypto.X509Certificate.Issuer,,false,223,225,Issuer,,,15,void node.crypto.X509Certificate.Issuer (FunctionCallbackInfo<Value>)
69328,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,"void X509Certificate::SubjectAltName(const FunctionCallbackInfo<Value>& args) {
  ReturnPropertyThroughBIO<GetSubjectAltNameString>(args);
}",1,1,crypto\crypto_x509.cc,node.crypto.X509Certificate.SubjectAltName,,false,227,229,SubjectAltName,,,16,void node.crypto.X509Certificate.SubjectAltName (FunctionCallbackInfo<Value>)
69338,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,"void X509Certificate::InfoAccess(const FunctionCallbackInfo<Value>& args) {
  ReturnPropertyThroughBIO<GetInfoAccessString>(args);
}",1,1,crypto\crypto_x509.cc,node.crypto.X509Certificate.InfoAccess,,false,231,233,InfoAccess,,,17,void node.crypto.X509Certificate.InfoAccess (FunctionCallbackInfo<Value>)
69348,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,"void X509Certificate::ValidFrom(const FunctionCallbackInfo<Value>& args) {
  ReturnPropertyThroughBIO<GetValidFrom>(args);
}",1,1,crypto\crypto_x509.cc,node.crypto.X509Certificate.ValidFrom,,false,235,237,ValidFrom,,,18,void node.crypto.X509Certificate.ValidFrom (FunctionCallbackInfo<Value>)
69358,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,"void X509Certificate::ValidTo(const FunctionCallbackInfo<Value>& args) {
  ReturnPropertyThroughBIO<GetValidTo>(args);
}",1,1,crypto\crypto_x509.cc,node.crypto.X509Certificate.ValidTo,,false,239,241,ValidTo,,,19,void node.crypto.X509Certificate.ValidTo (FunctionCallbackInfo<Value>)
69368,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,"static void ReturnProperty(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  Local<Value> ret;
  if (Property(env, cert->get()).ToLocal(&ret)) args.GetReturnValue().Set(ret);
}",1,1,crypto\crypto_x509.cc,node.crypto.ReturnProperty,,false,244,250,ReturnProperty,,,20,"void node.crypto.ReturnProperty<MaybeLocal<Value>(Environment*, X509*)> (FunctionCallbackInfo<Value>)"
69415,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,"void X509Certificate::KeyUsage(const FunctionCallbackInfo<Value>& args) {
  ReturnProperty<GetKeyUsage>(args);
}",1,1,crypto\crypto_x509.cc,node.crypto.X509Certificate.KeyUsage,,false,252,254,KeyUsage,,,21,void node.crypto.X509Certificate.KeyUsage (FunctionCallbackInfo<Value>)
69425,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,"void X509Certificate::SerialNumber(const FunctionCallbackInfo<Value>& args) {
  ReturnProperty<GetSerialNumber>(args);
}",1,1,crypto\crypto_x509.cc,node.crypto.X509Certificate.SerialNumber,,false,256,258,SerialNumber,,,22,void node.crypto.X509Certificate.SerialNumber (FunctionCallbackInfo<Value>)
69435,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,"void X509Certificate::Raw(const FunctionCallbackInfo<Value>& args) {
  ReturnProperty<GetRawDERCertificate>(args);
}",1,1,crypto\crypto_x509.cc,node.crypto.X509Certificate.Raw,,false,260,262,Raw,,,23,void node.crypto.X509Certificate.Raw (FunctionCallbackInfo<Value>)
69445,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,"void X509Certificate::PublicKey(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());

  // TODO(tniessen): consider checking X509_get_pubkey() when the
  // X509Certificate object is being created.
  ClearErrorOnReturn clear_error_on_return;
  EVPKeyPointer pkey(X509_get_pubkey(cert->get()));
  if (!pkey) return ThrowCryptoError(env, ERR_get_error());
  ManagedEVPPKey epkey(std::move(pkey));
  std::shared_ptr<KeyObjectData> key_data =
      KeyObjectData::CreateAsymmetric(kKeyTypePublic, epkey);

  Local<Value> ret;
  if (KeyObjectHandle::Create(env, key_data).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",1,1,crypto\crypto_x509.cc,node.crypto.X509Certificate.PublicKey,,false,264,281,PublicKey,,,24,void node.crypto.X509Certificate.PublicKey (FunctionCallbackInfo<Value>)
69529,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,"void X509Certificate::Pem(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);
  if (PEM_write_bio_X509(bio.get(), cert->get()))
    args.GetReturnValue().Set(ToV8Value(env, bio));
}",1,1,crypto\crypto_x509.cc,node.crypto.X509Certificate.Pem,,false,283,291,Pem,,,25,void node.crypto.X509Certificate.Pem (FunctionCallbackInfo<Value>)
69548,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,BIOPointer bio(BIO_new(BIO_s_mem()));,14,38,crypto\crypto_x509.cc,node.crypto.X509Certificate.Pem.bio,,false,287,287,bio,,,5,BIOPointer node.crypto.X509Certificate.Pem.bio (BIO_new)
69578,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,"void X509Certificate::CheckCA(const FunctionCallbackInfo<Value>& args) {
  X509Certificate* cert;
  ClearErrorOnReturn clear_error_on_return;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  args.GetReturnValue().Set(X509_check_ca(cert->get()) == 1);
}",1,1,crypto\crypto_x509.cc,node.crypto.X509Certificate.CheckCA,,false,293,298,CheckCA,,,26,void node.crypto.X509Certificate.CheckCA (FunctionCallbackInfo<Value>)
69606,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,"void X509Certificate::CheckHost(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());

  CHECK(args[0]->IsString());  // name
  CHECK(args[1]->IsUint32());  // flags

  Utf8Value name(env->isolate(), args[0]);
  uint32_t flags = args[1].As<Uint32>()->Value();
  char* peername;

  switch (X509_check_host(
              cert->get(),
              *name,
              name.length(),
              flags,
              &peername)) {
    case 1:  {  // Match!
      Local<Value> ret = args[0];
      if (peername != nullptr) {
        ret = OneByteString(env->isolate(), peername);
        OPENSSL_free(peername);
      }
      return args.GetReturnValue().Set(ret);
    }
    case 0:  // No Match!
      return;  // No return value is set
    case -2:  // Error!
      return THROW_ERR_INVALID_ARG_VALUE(env, ""Invalid name"");
    default:  // Error!
      return THROW_ERR_CRYPTO_OPE...",1,1,crypto\crypto_x509.cc,node.crypto.X509Certificate.CheckHost,,false,300,333,CheckHost,,,27,void node.crypto.X509Certificate.CheckHost (FunctionCallbackInfo<Value>)
69729,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,"void X509Certificate::CheckEmail(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());

  CHECK(args[0]->IsString());  // name
  CHECK(args[1]->IsUint32());  // flags

  Utf8Value name(env->isolate(), args[0]);
  uint32_t flags = args[1].As<Uint32>()->Value();

  switch (X509_check_email(
              cert->get(),
              *name,
              name.length(),
              flags)) {
    case 1:  // Match!
      return args.GetReturnValue().Set(args[0]);
    case 0:  // No Match!
      return;  // No return value is set
    case -2:  // Error!
      return THROW_ERR_INVALID_ARG_VALUE(env, ""Invalid name"");
    default:  // Error!
      return THROW_ERR_CRYPTO_OPERATION_FAILED(env);
  }
}",1,1,crypto\crypto_x509.cc,node.crypto.X509Certificate.CheckEmail,,false,335,360,CheckEmail,,,28,void node.crypto.X509Certificate.CheckEmail (FunctionCallbackInfo<Value>)
69826,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,"void X509Certificate::CheckIP(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());

  CHECK(args[0]->IsString());  // IP
  CHECK(args[1]->IsUint32());  // flags

  Utf8Value name(env->isolate(), args[0]);
  uint32_t flags = args[1].As<Uint32>()->Value();

  switch (X509_check_ip_asc(cert->get(), *name, flags)) {
    case 1:  // Match!
      return args.GetReturnValue().Set(args[0]);
    case 0:  // No Match!
      return;  // No return value is set
    case -2:  // Error!
      return THROW_ERR_INVALID_ARG_VALUE(env, ""Invalid IP"");
    default:  // Error!
      return THROW_ERR_CRYPTO_OPERATION_FAILED(env);
  }
}",1,1,crypto\crypto_x509.cc,node.crypto.X509Certificate.CheckIP,,false,362,383,CheckIP,,,29,void node.crypto.X509Certificate.CheckIP (FunctionCallbackInfo<Value>)
69919,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,"void X509Certificate::CheckIssued(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());

  CHECK(args[0]->IsObject());
  CHECK(X509Certificate::HasInstance(env, args[0].As<Object>()));

  X509Certificate* issuer;
  ASSIGN_OR_RETURN_UNWRAP(&issuer, args[0]);

  ClearErrorOnReturn clear_error_on_return;

  args.GetReturnValue().Set(
    X509_check_issued(issuer->get(), cert->get()) == X509_V_OK);
}",1,1,crypto\crypto_x509.cc,node.crypto.X509Certificate.CheckIssued,,false,385,400,CheckIssued,,,30,void node.crypto.X509Certificate.CheckIssued (FunctionCallbackInfo<Value>)
69985,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,"void X509Certificate::CheckPrivateKey(const FunctionCallbackInfo<Value>& args) {
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());

  CHECK(args[0]->IsObject());
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args[0]);
  CHECK_EQ(key->Data()->GetKeyType(), kKeyTypePrivate);

  ClearErrorOnReturn clear_error_on_return;

  args.GetReturnValue().Set(
      X509_check_private_key(
          cert->get(),
          key->Data()->GetAsymmetricKey().get()) == 1);
}",1,1,crypto\crypto_x509.cc,node.crypto.X509Certificate.CheckPrivateKey,,false,402,417,CheckPrivateKey,,,31,void node.crypto.X509Certificate.CheckPrivateKey (FunctionCallbackInfo<Value>)
70046,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,"void X509Certificate::Verify(const FunctionCallbackInfo<Value>& args) {
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());

  CHECK(args[0]->IsObject());
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args[0]);
  CHECK_EQ(key->Data()->GetKeyType(), kKeyTypePublic);

  ClearErrorOnReturn clear_error_on_return;

  args.GetReturnValue().Set(
      X509_verify(
          cert->get(),
          key->Data()->GetAsymmetricKey().get()) > 0);
}",1,1,crypto\crypto_x509.cc,node.crypto.X509Certificate.Verify,,false,419,434,Verify,,,32,void node.crypto.X509Certificate.Verify (FunctionCallbackInfo<Value>)
70107,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,"void X509Certificate::ToLegacy(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  ClearErrorOnReturn clear_error_on_return;
  Local<Value> ret;
  if (X509ToObject(env, cert->get()).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",1,1,crypto\crypto_x509.cc,node.crypto.X509Certificate.ToLegacy,,false,436,444,ToLegacy,,,33,void node.crypto.X509Certificate.ToLegacy (FunctionCallbackInfo<Value>)
70155,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,"void X509Certificate::GetIssuerCert(const FunctionCallbackInfo<Value>& args) {
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  if (cert->issuer_cert_)
    args.GetReturnValue().Set(cert->issuer_cert_->object());
}",1,1,crypto\crypto_x509.cc,node.crypto.X509Certificate.GetIssuerCert,,false,446,451,GetIssuerCert,,,34,void node.crypto.X509Certificate.GetIssuerCert (FunctionCallbackInfo<Value>)
70187,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,"void X509Certificate::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""cert"", cert_);
}",1,1,crypto\crypto_x509.cc,node.crypto.X509Certificate.MemoryInfo,,false,474,476,MemoryInfo,,,36,void node.crypto.X509Certificate.MemoryInfo (MemoryTracker*)
70198,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,"BaseObjectPtr<BaseObject>
X509Certificate::X509CertificateTransferData::Deserialize(
    Environment* env,
    Local<Context> context,
    std::unique_ptr<worker::TransferData> self) {
  if (context != env->context()) {
    THROW_ERR_MESSAGE_TARGET_CONTEXT_UNAVAILABLE(env);
    return {};
  }

  Local<Value> handle;
  if (!X509Certificate::New(env, data_).ToLocal(&handle))
    return {};

  return BaseObjectPtr<BaseObject>(
      Unwrap<X509Certificate>(handle.As<Object>()));
}",1,1,crypto\crypto_x509.cc,node.crypto.X509Certificate.X509CertificateTransferData.Deserialize,,false,478,494,Deserialize,,,37,"BaseObjectPtr<BaseObject> node.crypto.X509Certificate.X509CertificateTransferData.Deserialize (Environment*,Local<Context>,ANY)"
70249,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,"BaseObject::TransferMode X509Certificate::GetTransferMode() const {
  return BaseObject::TransferMode::kCloneable;
}",1,1,crypto\crypto_x509.cc,node.crypto.X509Certificate.GetTransferMode,,false,497,499,GetTransferMode,,,38,TransferMode node.crypto.X509Certificate.GetTransferMode ()
70259,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,"std::unique_ptr<worker::TransferData> X509Certificate::CloneForMessaging()
    const {
  return std::make_unique<X509CertificateTransferData>(cert_);
}",1,1,crypto\crypto_x509.cc,node.crypto.X509Certificate.CloneForMessaging,,false,501,504,CloneForMessaging,,,39,unique_ptr<worker::TransferData> node.crypto.X509Certificate.CloneForMessaging ()
70271,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,"void X509Certificate::Initialize(Environment* env, Local<Object> target) {
  SetMethod(env->context(), target, ""parseX509"", X509Certificate::Parse);

  NODE_DEFINE_CONSTANT(target, X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT);
  NODE_DEFINE_CONSTANT(target, X509_CHECK_FLAG_NEVER_CHECK_SUBJECT);
  NODE_DEFINE_CONSTANT(target, X509_CHECK_FLAG_NO_WILDCARDS);
  NODE_DEFINE_CONSTANT(target, X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS);
  NODE_DEFINE_CONSTANT(target, X509_CHECK_FLAG_MULTI_LABEL_WILDCARDS);
  NODE_DEFINE_CONSTANT(target, X509_CHECK_FLAG_SINGLE_LABEL_SUBDOMAINS);
}",1,1,crypto\crypto_x509.cc,node.crypto.X509Certificate.Initialize,,false,507,516,Initialize,,,40,"void node.crypto.X509Certificate.Initialize (Environment*,Local<Object>)"
70305,METHOD,crypto\crypto_x509.cc:<global>,TYPE_DECL,"void X509Certificate::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(X509Certificate::Parse);
  registry->Register(Subject);
  registry->Register(SubjectAltName);
  registry->Register(InfoAccess);
  registry->Register(Issuer);
  registry->Register(ValidTo);
  registry->Register(ValidFrom);
  registry->Register(Fingerprint<EVP_sha1>);
  registry->Register(Fingerprint<EVP_sha256>);
  registry->Register(Fingerprint<EVP_sha512>);
  registry->Register(KeyUsage);
  registry->Register(SerialNumber);
  registry->Register(Pem);
  registry->Register(Raw);
  registry->Register(PublicKey);
  registry->Register(CheckCA);
  registry->Register(CheckHost);
  registry->Register(CheckEmail);
  registry->Register(CheckIP);
  registry->Register(CheckIssued);
  registry->Register(CheckPrivateKey);
  registry->Register(Verify);
  registry->Register(ToLegacy);
  registry->Register(GetIssuerCert);
}",1,1,crypto\crypto_x509.cc,node.crypto.X509Certificate.RegisterExternalReferences,,false,518,544,RegisterExternalReferences,,,41,void node.crypto.X509Certificate.RegisterExternalReferences (ExternalReferenceRegistry*)
70447,METHOD,crypto\crypto_x509.hpp:<global>,TYPE_DECL,<global>,1,36,crypto\crypto_x509.hpp,crypto\crypto_x509.hpp:<global>,,false,1,140,<global>,,,1,
70450,METHOD,node.anonymous_namespace_25.IdempotentDataQueueReader,TYPE_DECL,[](uint64_t) {},60,74,dataqueue\queue.cc,node.anonymous_namespace_32.IdempotentDataQueueReader.Pull.<lambda>0,,false,211,211,<lambda>0,,,1,ANY node.anonymous_namespace_32.IdempotentDataQueueReader.Pull.<lambda>0 (uint64_t)
70457,METHOD,node.anonymous_namespace_25.IdempotentDataQueueReader,TYPE_DECL,[](uint64_t) {},62,76,dataqueue\queue.cc,node.anonymous_namespace_33.IdempotentDataQueueReader.Pull.<lambda>1,,false,224,224,<lambda>1,,,1,ANY node.anonymous_namespace_33.IdempotentDataQueueReader.Pull.<lambda>1 (uint64_t)
70463,METHOD,node.anonymous_namespace_25.IdempotentDataQueueReader,TYPE_DECL,[](uint64_t) {},46,60,dataqueue\queue.cc,node.anonymous_namespace_35.IdempotentDataQueueReader.Pull.<lambda>2,,false,240,240,<lambda>2,,,1,ANY node.anonymous_namespace_35.IdempotentDataQueueReader.Pull.<lambda>2 (uint64_t)
70469,METHOD,node.anonymous_namespace_25.IdempotentDataQueueReader,TYPE_DECL,[](uint64_t) {},49,63,dataqueue\queue.cc,node.anonymous_namespace_37.IdempotentDataQueueReader.Pull..<lambda>4,,false,272,272,<lambda>4,,,1,ANY node.anonymous_namespace_37.IdempotentDataQueueReader.Pull..<lambda>4 (uint64_t)
70475,METHOD,node.anonymous_namespace_25.IdempotentDataQueueReader,TYPE_DECL,"[this, next = std::move(next)](
            int status, const DataQueue::Vec* vecs, uint64_t count, Done done) {
          pull_pending_ = false;
          // In each of these cases, we do not expect that the source will
          // actually have provided any actual data.
          CHECK_IMPLIES(status == bob::Status::STATUS_BLOCK ||
                            status == bob::Status::STATUS_WAIT ||
                            status == bob::Status::STATUS_EOS,
                        vecs == nullptr && count == 0);
          if (status == bob::Status::STATUS_EOS) {
            uint32_t current = current_index_.value() + 1;
            current_reader_ = nullptr;
            // We have reached the end of this entry. If this is the last entry,
            // then we are done. Otherwise, we advance the current_index_, clear
            // the current_reader_ and wait for the next read.

            if (current == data_queue_->entries_.size()) {
              // Yes, this was the final ...",9,9,dataqueue\queue.cc,node.anonymous_namespace_36.IdempotentDataQueueReader.Pull.<lambda>3,,false,247,277,<lambda>3,,,1,"ANY node.anonymous_namespace_36.IdempotentDataQueueReader.Pull.<lambda>3 (int,ANY*,uint64_t,Done)"
70590,METHOD,node.anonymous_namespace_39.NonIdempotentDataQueueReader,TYPE_DECL,[](uint64_t) {},60,74,dataqueue\queue.cc,node.anonymous_namespace_46.NonIdempotentDataQueueReader.Pull.<lambda>5,,false,364,364,<lambda>5,,,1,ANY node.anonymous_namespace_46.NonIdempotentDataQueueReader.Pull.<lambda>5 (uint64_t)
70597,METHOD,node.anonymous_namespace_39.NonIdempotentDataQueueReader,TYPE_DECL,[](uint64_t) {},64,78,dataqueue\queue.cc,node.anonymous_namespace_47.NonIdempotentDataQueueReader.Pull.<lambda>6,,false,377,377,<lambda>6,,,1,ANY node.anonymous_namespace_47.NonIdempotentDataQueueReader.Pull.<lambda>6 (uint64_t)
70603,METHOD,node.anonymous_namespace_39.NonIdempotentDataQueueReader,TYPE_DECL,[](uint64_t) {},54,68,dataqueue\queue.cc,node.anonymous_namespace_48.NonIdempotentDataQueueReader.Pull.<lambda>7,,false,390,390,<lambda>7,,,1,ANY node.anonymous_namespace_48.NonIdempotentDataQueueReader.Pull.<lambda>7 (uint64_t)
70609,METHOD,node.anonymous_namespace_39.NonIdempotentDataQueueReader,TYPE_DECL,[](uint64_t) {},60,74,dataqueue\queue.cc,node.anonymous_namespace_49.NonIdempotentDataQueueReader.Pull.<lambda>8,,false,403,403,<lambda>8,,,1,ANY node.anonymous_namespace_49.NonIdempotentDataQueueReader.Pull.<lambda>8 (uint64_t)
70615,METHOD,node.anonymous_namespace_39.NonIdempotentDataQueueReader,TYPE_DECL,[](uint64_t) {},46,60,dataqueue\queue.cc,node.anonymous_namespace_51.NonIdempotentDataQueueReader.Pull.<lambda>9,,false,409,409,<lambda>9,,,1,ANY node.anonymous_namespace_51.NonIdempotentDataQueueReader.Pull.<lambda>9 (uint64_t)
70621,METHOD,node.anonymous_namespace_39.NonIdempotentDataQueueReader,TYPE_DECL,[](uint64_t) {},49,63,dataqueue\queue.cc,node.anonymous_namespace_53.NonIdempotentDataQueueReader.Pull..<lambda>11,,false,432,432,<lambda>11,,,1,ANY node.anonymous_namespace_53.NonIdempotentDataQueueReader.Pull..<lambda>11 (uint64_t)
70627,METHOD,node.anonymous_namespace_39.NonIdempotentDataQueueReader,TYPE_DECL,"[this, next = std::move(next)](
            int status, const DataQueue::Vec* vecs, uint64_t count, Done done) {
          pull_pending_ = false;

          // In each of these cases, we do not expect that the source will
          // actually have provided any actual data.
          CHECK_IMPLIES(status == bob::Status::STATUS_BLOCK ||
                            status == bob::Status::STATUS_WAIT ||
                            status == bob::Status::STATUS_EOS,
                        vecs == nullptr && count == 0);
          if (status == bob::Status::STATUS_EOS) {
            data_queue_->entries_.erase(data_queue_->entries_.begin());
            ended_ = data_queue_->entries_.empty();
            current_reader_ = nullptr;
            if (!ended_) status = bob::Status::STATUS_CONTINUE;
            std::move(next)(status, nullptr, 0, [](uint64_t) {});
            return;
          }

          // Now that we have updated this readers state, we can forward
          // everything ...",9,9,dataqueue\queue.cc,node.anonymous_namespace_52.NonIdempotentDataQueueReader.Pull.<lambda>10,,false,417,439,<lambda>10,,,1,"ANY node.anonymous_namespace_52.NonIdempotentDataQueueReader.Pull.<lambda>10 (int,ANY*,uint64_t,Done)"
70741,METHOD,node.anonymous_namespace_58.EmptyEntry.EmptyReader,TYPE_DECL,[](uint64_t) {},62,76,dataqueue\queue.cc,node.anonymous_namespace_60.EmptyEntry.EmptyReader.Pull.<lambda>12,,false,516,516,<lambda>12,,,1,ANY node.anonymous_namespace_60.EmptyEntry.EmptyReader.Pull.<lambda>12 (uint64_t)
70748,METHOD,node.anonymous_namespace_58.EmptyEntry.EmptyReader,TYPE_DECL,[](uint64_t) {},53,67,dataqueue\queue.cc,node.anonymous_namespace_61.EmptyEntry.EmptyReader.Pull.<lambda>13,,false,522,522,<lambda>13,,,1,ANY node.anonymous_namespace_61.EmptyEntry.EmptyReader.Pull.<lambda>13 (uint64_t)
70754,METHOD,node.anonymous_namespace_74.InMemoryEntry.InMemoryReader,TYPE_DECL,[](uint64_t) {},62,76,dataqueue\queue.cc,node.anonymous_namespace_77.InMemoryEntry.InMemoryReader.Pull.<lambda>14,,false,586,586,<lambda>14,,,1,ANY node.anonymous_namespace_77.InMemoryEntry.InMemoryReader.Pull.<lambda>14 (uint64_t)
70761,METHOD,node.anonymous_namespace_71.InMemoryEntry,TYPE_DECL,"[&](uint64_t start,
                               uint64_t len) -> std::unique_ptr<Entry> {
      if (len == 0) {
        return std::make_unique<EmptyEntry>();
      }

      return std::make_unique<InMemoryEntry>(backing_store_, start, len);
    }",28,5,dataqueue\queue.cc,node.anonymous_namespace_85.InMemoryEntry.slice.<lambda>15,,false,637,644,<lambda>15,,,1,"unique_ptr<Entry> node.anonymous_namespace_85.InMemoryEntry.slice.<lambda>15 (uint64_t,uint64_t)"
70792,METHOD,node.anonymous_namespace_105.FdEntry,TYPE_DECL,[&] { uv_fs_req_cleanup(&req); },33,64,dataqueue\queue.cc,node.anonymous_namespace_107.FdEntry.Create.<lambda>16,,false,791,791,<lambda>16,,,1,ANY node.anonymous_namespace_107.FdEntry.Create.<lambda>16 ()
70802,METHOD,node.anonymous_namespace_105.FdEntry,TYPE_DECL,[&] { uv_fs_req_cleanup(&req); },33,64,dataqueue\queue.cc,node.anonymous_namespace_117.FdEntry.CheckModified.<lambda>17,,false,853,853,<lambda>17,,,1,ANY node.anonymous_namespace_117.FdEntry.CheckModified.<lambda>17 ()
70811,METHOD,node.anonymous_namespace_118.FdEntry.ReaderImpl,TYPE_DECL,[&] { uv_fs_req_cleanup(&req); },35,66,dataqueue\queue.cc,node.anonymous_namespace_120.FdEntry.ReaderImpl.Create.<lambda>18,,false,870,870,<lambda>18,,,1,ANY node.anonymous_namespace_120.FdEntry.ReaderImpl.Create.<lambda>18 ()
70821,METHOD,node.anonymous_namespace_118.FdEntry.ReaderImpl,TYPE_DECL,[](uint64_t) {},56,70,dataqueue\queue.cc,node.anonymous_namespace_131.FdEntry.ReaderImpl.OnStreamRead.<lambda>19,,false,921,921,<lambda>19,,,1,ANY node.anonymous_namespace_131.FdEntry.ReaderImpl.OnStreamRead.<lambda>19 (uint64_t)
70827,METHOD,node.anonymous_namespace_118.FdEntry.ReaderImpl,TYPE_DECL,[](uint64_t) {},64,78,dataqueue\queue.cc,node.anonymous_namespace_132.FdEntry.ReaderImpl.OnStreamRead.<lambda>20,,false,927,927,<lambda>20,,,1,ANY node.anonymous_namespace_132.FdEntry.ReaderImpl.OnStreamRead.<lambda>20 (uint64_t)
70833,METHOD,node.anonymous_namespace_118.FdEntry.ReaderImpl,TYPE_DECL,[](uint64_t) {},54,68,dataqueue\queue.cc,node.anonymous_namespace_133.FdEntry.ReaderImpl.OnStreamRead.<lambda>21,,false,929,929,<lambda>21,,,1,ANY node.anonymous_namespace_133.FdEntry.ReaderImpl.OnStreamRead.<lambda>21 (uint64_t)
70839,METHOD,node.anonymous_namespace_118.FdEntry.ReaderImpl,TYPE_DECL,[store](uint64_t) {},42,61,dataqueue\queue.cc,node.anonymous_namespace_135.FdEntry.ReaderImpl.OnStreamRead.<lambda>22,,false,939,939,<lambda>22,,,1,ANY node.anonymous_namespace_135.FdEntry.ReaderImpl.OnStreamRead.<lambda>22 (uint64_t)
70845,METHOD,node.anonymous_namespace_118.FdEntry.ReaderImpl,TYPE_DECL,[](uint64_t) {},54,68,dataqueue\queue.cc,node.anonymous_namespace_137.FdEntry.ReaderImpl.Pull.<lambda>23,,false,953,953,<lambda>23,,,1,ANY node.anonymous_namespace_137.FdEntry.ReaderImpl.Pull.<lambda>23 (uint64_t)
70851,METHOD,node.anonymous_namespace_118.FdEntry.ReaderImpl,TYPE_DECL,[](uint64_t) {},48,62,dataqueue\queue.cc,node.anonymous_namespace_139.FdEntry.ReaderImpl.Pull.<lambda>24,,false,959,959,<lambda>24,,,1,ANY node.anonymous_namespace_139.FdEntry.ReaderImpl.Pull.<lambda>24 (uint64_t)
70857,METHOD,node.anonymous_namespace_118.FdEntry.ReaderImpl,TYPE_DECL,[](uint64_t) {},62,76,dataqueue\queue.cc,node.anonymous_namespace_143.FdEntry.ReaderImpl.DrainAndClose.<lambda>25,,false,1000,1000,<lambda>25,,,1,ANY node.anonymous_namespace_143.FdEntry.ReaderImpl.DrainAndClose.<lambda>25 (uint64_t)
70863,METHOD,node.anonymous_namespace_118.FdEntry.ReaderImpl,TYPE_DECL,[this] { pending_pulls_.pop_front(); },31,68,dataqueue\queue.cc,node.anonymous_namespace_145.FdEntry.ReaderImpl.DequeuePendingPull.<lambda>26,,false,1018,1018,<lambda>26,,,1,ANY node.anonymous_namespace_145.FdEntry.ReaderImpl.DequeuePendingPull.<lambda>26 ()
70872,METHOD,dataqueue\queue.cc:<global>,TYPE_DECL,"[&size](auto& item) {
    if (item == nullptr || !item->is_idempotent()) {
      return true;  // true means the entry is not valid here.
    }

    // To keep from having to iterate over the entries
    // again, we'll try calculating the size. If any
    // of the entries are unable to provide a size, then
    // we assume we cannot safely treat this entry as
    // idempotent even if it claims to be.
    if (item->size().has_value()) {
      size += item->size().value();
    } else {
      return true;  // true means the entry is not valid here.
    }

    return false;
  }",26,3,dataqueue\queue.cc,node.DataQueue.CreateIdempotent.<lambda>27,,false,1037,1054,<lambda>27,,,1,ANY node.DataQueue.CreateIdempotent.<lambda>27 (auto)
70956,METHOD,dataqueue\queue.cc:<global>,TYPE_DECL,<global>,1,62,dataqueue\queue.hpp,dataqueue\queue.cc:<global>,,false,1,1113,<global>,,,1,
70963,METHOD,node.anonymous_namespace_3.EntryImpl,TYPE_DECL,virtual std::shared_ptr<DataQueue::Reader> get_reader() = 0;,46,61,dataqueue\queue.cc,node.anonymous_namespace_4.EntryImpl.get_reader,,false,36,36,get_reader,,,1,ANY node.anonymous_namespace_4.EntryImpl.get_reader ()
70968,METHOD,node.anonymous_namespace_5.DataQueueImpl,TYPE_DECL,"DataQueueImpl(std::vector<std::unique_ptr<Entry>>&& list, uint64_t size)
      : entries_(std::move(list)),
        idempotent_(true),
        size_(size),
        capped_size_(0) {}",3,26,dataqueue\queue.cc,node.anonymous_namespace_6.DataQueueImpl.DataQueueImpl,,false,43,47,DataQueueImpl,,,1,"ANY node.anonymous_namespace_6.DataQueueImpl.DataQueueImpl (ANY,uint64_t)"
70974,METHOD,node.anonymous_namespace_5.DataQueueImpl,TYPE_DECL,"DataQueueImpl(std::optional<uint64_t> cap = std::nullopt)
      : idempotent_(false), size_(0), capped_size_(cap) {}",3,58,dataqueue\queue.cc,node.anonymous_namespace_7.DataQueueImpl.DataQueueImpl,,false,54,55,DataQueueImpl,,,2,ANY node.anonymous_namespace_7.DataQueueImpl.DataQueueImpl (ANY)
70979,METHOD,node.anonymous_namespace_5.DataQueueImpl,TYPE_DECL,DataQueueImpl(const DataQueueImpl&) = delete;,3,47,dataqueue\queue.cc,node.anonymous_namespace_8.DataQueueImpl.DataQueueImpl,,false,58,58,DataQueueImpl,,,3,ANY node.anonymous_namespace_8.DataQueueImpl.DataQueueImpl (DataQueueImpl)
70984,METHOD,node.anonymous_namespace_5.DataQueueImpl,TYPE_DECL,DataQueueImpl(DataQueueImpl&&) = delete;,3,42,dataqueue\queue.cc,node.anonymous_namespace_9.DataQueueImpl.DataQueueImpl,,false,59,59,DataQueueImpl,,,4,ANY node.anonymous_namespace_9.DataQueueImpl.DataQueueImpl (DataQueueImpl)
70989,METHOD,node.anonymous_namespace_5.DataQueueImpl,TYPE_DECL,DataQueueImpl& operator=(const DataQueueImpl&) = delete;,3,58,dataqueue\queue.cc,node.anonymous_namespace_10.DataQueueImpl.operator =,,false,60,60,operator =,,,5,DataQueueImpl node.anonymous_namespace_10.DataQueueImpl.operator = (DataQueueImpl)
70994,METHOD,node.anonymous_namespace_5.DataQueueImpl,TYPE_DECL,DataQueueImpl& operator=(DataQueueImpl&&) = delete;,3,53,dataqueue\queue.cc,node.anonymous_namespace_11.DataQueueImpl.operator =,,false,61,61,operator =,,,6,DataQueueImpl node.anonymous_namespace_11.DataQueueImpl.operator = (DataQueueImpl)
70999,METHOD,node.anonymous_namespace_5.DataQueueImpl,TYPE_DECL,"std::shared_ptr<DataQueue> slice(
      uint64_t start,
      std::optional<uint64_t> maybeEnd = std::nullopt) override {
    // If the data queue is not idempotent, or the size cannot be determined,
    // we cannot reasonably create a slice. Therefore, return nothing.
    if (!idempotent_ || !size_.has_value()) return nullptr;

    uint64_t size = size_.value();

    // start cannot be greater than the size.
    start = std::min(start, size);

    uint64_t end = std::max(start, std::min(maybeEnd.value_or(size), size));

    DCHECK_LE(start, end);

    uint64_t len = end - start;
    uint64_t remaining = end - start;
    std::vector<std::unique_ptr<Entry>> slices;

    if (remaining > 0) {
      for (const auto& entry : entries_) {
        // The size of every entry should be known since this is an
        // idempotent queue.
        uint64_t entrySize = entry->size().value();
        if (start > entrySize) {
          start -= entrySize;
          continue;
        }

        uin...",3,3,dataqueue\queue.cc,node.anonymous_namespace_12.DataQueueImpl.slice,,false,63,104,slice,,,7,"shared_ptr<DataQueue> node.anonymous_namespace_12.DataQueueImpl.slice (uint64_t,ANY)"
71158,METHOD,node.anonymous_namespace_5.DataQueueImpl,TYPE_DECL,std::optional<uint64_t> size() const override { return size_; },3,65,dataqueue\queue.cc,node.anonymous_namespace_13.DataQueueImpl.size,,false,106,106,size,,,8,optional<uint64_t> node.anonymous_namespace_13.DataQueueImpl.size ()
71164,METHOD,node.anonymous_namespace_5.DataQueueImpl,TYPE_DECL,bool is_idempotent() const override { return idempotent_; },3,61,dataqueue\queue.cc,node.anonymous_namespace_14.DataQueueImpl.is_idempotent,,false,108,108,is_idempotent,,,9,bool node.anonymous_namespace_14.DataQueueImpl.is_idempotent ()
71170,METHOD,node.anonymous_namespace_5.DataQueueImpl,TYPE_DECL,bool is_capped() const override { return capped_size_.has_value(); },3,70,dataqueue\queue.cc,node.anonymous_namespace_15.DataQueueImpl.is_capped,,false,110,110,is_capped,,,10,bool node.anonymous_namespace_15.DataQueueImpl.is_capped ()
71179,METHOD,node.anonymous_namespace_5.DataQueueImpl,TYPE_DECL,"std::optional<bool> append(std::unique_ptr<Entry> entry) override {
    if (idempotent_) return std::nullopt;
    if (!entry) return false;

    // If this entry successfully provides a size, we can add it to our size_
    // if that has a value, otherwise, we keep uint64_t empty.
    if (entry->size().has_value() && size_.has_value()) {
      uint64_t entrySize = entry->size().value();
      uint64_t size = size_.value();
      // If capped_size_ is set, size + entrySize cannot exceed capped_size_
      // or the entry cannot be added.
      if (capped_size_.has_value() &&
          (capped_size_.value() < entrySize + size)) {
        return false;
      }
      size_ = size + entrySize;
    } else {
      // This entry cannot provide a size. We can still add it but we have to
      // clear the known size.
      size_ = std::nullopt;
    }

    entries_.push_back(std::move(entry));
    return true;
  }",3,3,dataqueue\queue.cc,node.anonymous_namespace_16.DataQueueImpl.append,,false,112,136,append,,,11,optional<bool> node.anonymous_namespace_16.DataQueueImpl.append (ANY)
71268,METHOD,node.anonymous_namespace_5.DataQueueImpl,TYPE_DECL,"void cap(uint64_t limit = 0) override {
    if (is_idempotent()) return;
    // If the data queue is already capped, it is possible to call
    // cap again with a smaller size.
    if (capped_size_.has_value()) {
      capped_size_ = std::min(limit, capped_size_.value());
      return;
    }

    // Otherwise just set the limit.
    capped_size_ = limit;
  }",3,3,dataqueue\queue.cc,node.anonymous_namespace_17.DataQueueImpl.cap,,false,138,149,cap,,,12,void node.anonymous_namespace_17.DataQueueImpl.cap (uint64_t)
71298,METHOD,node.anonymous_namespace_5.DataQueueImpl,TYPE_DECL,"std::optional<uint64_t> maybeCapRemaining() const override {
    if (capped_size_.has_value() && size_.has_value()) {
      uint64_t capped_size = capped_size_.value();
      uint64_t size = size_.value();
      return capped_size > size ? capped_size - size : 0UL;
    }
    return std::nullopt;
  }",3,3,dataqueue\queue.cc,node.anonymous_namespace_19.DataQueueImpl.maybeCapRemaining,,false,151,158,maybeCapRemaining,,,13,optional<uint64_t> node.anonymous_namespace_19.DataQueueImpl.maybeCapRemaining ()
71340,METHOD,node.anonymous_namespace_5.DataQueueImpl,TYPE_DECL,"void MemoryInfo(node::MemoryTracker* tracker) const override {
    tracker->TrackField(
        ""entries"", entries_, ""std::vector<std::unique_ptr<Entry>>"");
  }",3,3,dataqueue\queue.cc,node.anonymous_namespace_20.DataQueueImpl.MemoryInfo,,false,160,163,MemoryInfo,,,14,void node.anonymous_namespace_20.DataQueueImpl.MemoryInfo (ANY*)
71352,METHOD,node.anonymous_namespace_5.DataQueueImpl,TYPE_DECL,std::shared_ptr<Reader> get_reader() override;,27,47,dataqueue\queue.cc,node.anonymous_namespace_21.DataQueueImpl.get_reader,,false,165,165,get_reader,,,15,ANY node.anonymous_namespace_21.DataQueueImpl.get_reader ()
71368,METHOD,<empty>,<empty>,<empty>,1,,dataqueue\queue.cc,node.anonymous_namespace_5.DataQueueImpl:<clinit>,,false,39,,<clinit>,,,28,
71385,METHOD,node.anonymous_namespace_25.IdempotentDataQueueReader,TYPE_DECL,"IdempotentDataQueueReader(std::shared_ptr<DataQueueImpl> data_queue)
      : data_queue_(std::move(data_queue)) {
    CHECK(data_queue_->is_idempotent());
  }",3,3,dataqueue\queue.cc,node.anonymous_namespace_26.IdempotentDataQueueReader.IdempotentDataQueueReader,,false,189,192,IdempotentDataQueueReader,,,1,ANY node.anonymous_namespace_26.IdempotentDataQueueReader.IdempotentDataQueueReader (ANY)
71395,METHOD,node.anonymous_namespace_25.IdempotentDataQueueReader,TYPE_DECL,IdempotentDataQueueReader(const IdempotentDataQueueReader&) = delete;,3,71,dataqueue\queue.cc,node.anonymous_namespace_27.IdempotentDataQueueReader.IdempotentDataQueueReader,,false,195,195,IdempotentDataQueueReader,,,2,ANY node.anonymous_namespace_27.IdempotentDataQueueReader.IdempotentDataQueueReader (IdempotentDataQueueReader)
71400,METHOD,node.anonymous_namespace_25.IdempotentDataQueueReader,TYPE_DECL,IdempotentDataQueueReader(IdempotentDataQueueReader&&) = delete;,3,66,dataqueue\queue.cc,node.anonymous_namespace_28.IdempotentDataQueueReader.IdempotentDataQueueReader,,false,196,196,IdempotentDataQueueReader,,,3,ANY node.anonymous_namespace_28.IdempotentDataQueueReader.IdempotentDataQueueReader (IdempotentDataQueueReader)
71405,METHOD,node.anonymous_namespace_25.IdempotentDataQueueReader,TYPE_DECL,"IdempotentDataQueueReader& operator=(const IdempotentDataQueueReader&) =
      delete;",3,13,dataqueue\queue.cc,node.anonymous_namespace_29.IdempotentDataQueueReader.operator =,,false,197,198,operator =,,,4,IdempotentDataQueueReader node.anonymous_namespace_29.IdempotentDataQueueReader.operator = (IdempotentDataQueueReader)
71410,METHOD,node.anonymous_namespace_25.IdempotentDataQueueReader,TYPE_DECL,IdempotentDataQueueReader& operator=(IdempotentDataQueueReader&&) = delete;,3,77,dataqueue\queue.cc,node.anonymous_namespace_30.IdempotentDataQueueReader.operator =,,false,199,199,operator =,,,5,IdempotentDataQueueReader node.anonymous_namespace_30.IdempotentDataQueueReader.operator = (IdempotentDataQueueReader)
71415,METHOD,node.anonymous_namespace_25.IdempotentDataQueueReader,TYPE_DECL,"int Pull(Next next,
           int options,
           DataQueue::Vec* data,
           size_t count,
           size_t max_count_hint = bob::kMaxCountHint) override {
    std::shared_ptr<DataQueue::Reader> self = shared_from_this();

    // If ended is true, this reader has already reached the end and cannot
    // provide any more data.
    if (ended_) {
      std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
      return bob::Status::STATUS_EOS;
    }

    // If this is the first pull from this reader, we are first going to
    // check to see if there is anything at all to actually do.
    if (!current_index_.has_value()) {
      // First, let's check the number of entries. If there are no entries,
      // we've reached the end and have nothing to do.
      // Because this is an idempotent dataqueue, we should always know the
      // size...
      if (data_queue_->entries_.empty()) {
        ended_ = true;
        std::move(next)(bob::Status::STATUS_EOS, n...",3,3,dataqueue\queue.cc,node.anonymous_namespace_31.IdempotentDataQueueReader.Pull,,false,201,306,Pull,,,6,"int node.anonymous_namespace_31.IdempotentDataQueueReader.Pull (Next,int,ANY*,size_t,size_t)"
71551,METHOD,node.anonymous_namespace_25.IdempotentDataQueueReader,TYPE_DECL,"DataQueue::Reader* getCurrentReader() {
    CHECK(!ended_);
    CHECK(current_index_.has_value());
    if (current_reader_ == nullptr) {
      auto& entry = data_queue_->entries_[current_index_.value()];
      // Because this is an idempotent reader, let's just be sure to
      // doublecheck that the entry itself is actually idempotent
      DCHECK(entry->is_idempotent());
      current_reader_ = static_cast<EntryImpl&>(*entry).get_reader();
    }
    return current_reader_.get();
  }",3,3,dataqueue\queue.cc,node.anonymous_namespace_38.IdempotentDataQueueReader.getCurrentReader,,false,308,319,getCurrentReader,,,7,Reader node.anonymous_namespace_38.IdempotentDataQueueReader.getCurrentReader ()
71603,METHOD,<empty>,<empty>,<empty>,1,,dataqueue\queue.cc,node.anonymous_namespace_25.IdempotentDataQueueReader:<clinit>,,false,185,,<clinit>,,,13,
71621,METHOD,node.anonymous_namespace_39.NonIdempotentDataQueueReader,TYPE_DECL,"NonIdempotentDataQueueReader(std::shared_ptr<DataQueueImpl> data_queue)
      : data_queue_(std::move(data_queue)) {
    CHECK(!data_queue_->is_idempotent());
  }",3,3,dataqueue\queue.cc,node.anonymous_namespace_40.NonIdempotentDataQueueReader.NonIdempotentDataQueueReader,,false,341,344,NonIdempotentDataQueueReader,,,1,ANY node.anonymous_namespace_40.NonIdempotentDataQueueReader.NonIdempotentDataQueueReader (ANY)
71632,METHOD,node.anonymous_namespace_39.NonIdempotentDataQueueReader,TYPE_DECL,NonIdempotentDataQueueReader(const NonIdempotentDataQueueReader&) = delete;,3,77,dataqueue\queue.cc,node.anonymous_namespace_41.NonIdempotentDataQueueReader.NonIdempotentDataQueueReader,,false,347,347,NonIdempotentDataQueueReader,,,2,ANY node.anonymous_namespace_41.NonIdempotentDataQueueReader.NonIdempotentDataQueueReader (NonIdempotentDataQueueReader)
71637,METHOD,node.anonymous_namespace_39.NonIdempotentDataQueueReader,TYPE_DECL,NonIdempotentDataQueueReader(NonIdempotentDataQueueReader&&) = delete;,3,72,dataqueue\queue.cc,node.anonymous_namespace_42.NonIdempotentDataQueueReader.NonIdempotentDataQueueReader,,false,348,348,NonIdempotentDataQueueReader,,,3,ANY node.anonymous_namespace_42.NonIdempotentDataQueueReader.NonIdempotentDataQueueReader (NonIdempotentDataQueueReader)
71642,METHOD,node.anonymous_namespace_39.NonIdempotentDataQueueReader,TYPE_DECL,"NonIdempotentDataQueueReader& operator=(const NonIdempotentDataQueueReader&) =
      delete;",3,13,dataqueue\queue.cc,node.anonymous_namespace_43.NonIdempotentDataQueueReader.operator =,,false,349,350,operator =,,,4,NonIdempotentDataQueueReader node.anonymous_namespace_43.NonIdempotentDataQueueReader.operator = (NonIdempotentDataQueueReader)
71647,METHOD,node.anonymous_namespace_39.NonIdempotentDataQueueReader,TYPE_DECL,"NonIdempotentDataQueueReader& operator=(NonIdempotentDataQueueReader&&) =
      delete;",3,13,dataqueue\queue.cc,node.anonymous_namespace_44.NonIdempotentDataQueueReader.operator =,,false,351,352,operator =,,,5,NonIdempotentDataQueueReader node.anonymous_namespace_44.NonIdempotentDataQueueReader.operator = (NonIdempotentDataQueueReader)
71652,METHOD,node.anonymous_namespace_39.NonIdempotentDataQueueReader,TYPE_DECL,"int Pull(Next next,
           int options,
           DataQueue::Vec* data,
           size_t count,
           size_t max_count_hint = bob::kMaxCountHint) override {
    std::shared_ptr<DataQueue::Reader> self = shared_from_this();

    // If ended is true, this reader has already reached the end and cannot
    // provide any more data.
    if (ended_) {
      std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
      return bob::Status::STATUS_EOS;
    }

    // If the collection of entries is empty, there's nothing currently left to
    // read. How we respond depends on whether the data queue has been capped
    // or not.
    if (data_queue_->entries_.empty()) {
      // If the data_queue_ is empty, and not capped, then we can reasonably
      // expect more data to be provided later, but we don't know exactly when
      // that'll happe, so the proper response here is to return a blocked
      // status.
      if (!data_queue_->is_capped()) {
        std::mo...",3,3,dataqueue\queue.cc,node.anonymous_namespace_45.NonIdempotentDataQueueReader.Pull,,false,354,467,Pull,,,6,"int node.anonymous_namespace_45.NonIdempotentDataQueueReader.Pull (Next,int,ANY*,size_t,size_t)"
71847,METHOD,node.anonymous_namespace_39.NonIdempotentDataQueueReader,TYPE_DECL,"DataQueue::Reader* getCurrentReader() {
    CHECK(!ended_);
    CHECK(!data_queue_->entries_.empty());
    if (current_reader_ == nullptr) {
      auto& entry = data_queue_->entries_.front();
      current_reader_ = static_cast<EntryImpl&>(*entry).get_reader();
    }
    return current_reader_.get();
  }",3,3,dataqueue\queue.cc,node.anonymous_namespace_54.NonIdempotentDataQueueReader.getCurrentReader,,false,469,477,getCurrentReader,,,7,Reader node.anonymous_namespace_54.NonIdempotentDataQueueReader.getCurrentReader ()
71894,METHOD,<empty>,<empty>,<empty>,1,,dataqueue\queue.cc,node.anonymous_namespace_39.NonIdempotentDataQueueReader:<clinit>,,false,337,,<clinit>,,,12,
71907,METHOD,dataqueue\queue.cc:<global>,TYPE_DECL,"std::shared_ptr<DataQueue::Reader> DataQueueImpl::get_reader() {
  if (is_idempotent()) {
    return std::make_shared<IdempotentDataQueueReader>(shared_from_this());
  }

  if (locked_to_reader_) return nullptr;
  locked_to_reader_ = true;

  return std::make_shared<NonIdempotentDataQueueReader>(shared_from_this());
}",1,1,dataqueue\queue.cc,node.anonymous_namespace_55.DataQueueImpl.get_reader,,false,490,499,get_reader,,,7,shared_ptr<DataQueue::Reader> node.anonymous_namespace_55.DataQueueImpl.get_reader ()
71939,METHOD,node.anonymous_namespace_58.EmptyEntry.EmptyReader,TYPE_DECL,"int Pull(Next next,
             int options,
             DataQueue::Vec* data,
             size_t count,
             size_t max_count_hint = bob::kMaxCountHint) override {
      auto self = shared_from_this();
      if (ended_) {
        std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        return bob::Status::STATUS_EOS;
      }

      ended_ = true;
      std::move(next)(
          bob::Status::STATUS_CONTINUE, nullptr, 0, [](uint64_t) {});
      return bob::Status::STATUS_CONTINUE;
    }",5,5,dataqueue\queue.cc,node.anonymous_namespace_59.EmptyEntry.EmptyReader.Pull,,false,509,524,Pull,,,1,"int node.anonymous_namespace_59.EmptyEntry.EmptyReader.Pull (Next,int,ANY*,size_t,size_t)"
71999,METHOD,node.anonymous_namespace_57.EmptyEntry,TYPE_DECL,EmptyEntry() = default;,3,25,dataqueue\queue.cc,node.anonymous_namespace_62.EmptyEntry.EmptyEntry,,false,534,534,EmptyEntry,,,2,ANY node.anonymous_namespace_62.EmptyEntry.EmptyEntry ()
72003,METHOD,node.anonymous_namespace_57.EmptyEntry,TYPE_DECL,EmptyEntry(const EmptyEntry&) = delete;,3,41,dataqueue\queue.cc,node.anonymous_namespace_63.EmptyEntry.EmptyEntry,,false,537,537,EmptyEntry,,,3,ANY node.anonymous_namespace_63.EmptyEntry.EmptyEntry (EmptyEntry)
72008,METHOD,node.anonymous_namespace_57.EmptyEntry,TYPE_DECL,EmptyEntry(EmptyEntry&&) = delete;,3,36,dataqueue\queue.cc,node.anonymous_namespace_64.EmptyEntry.EmptyEntry,,false,538,538,EmptyEntry,,,4,ANY node.anonymous_namespace_64.EmptyEntry.EmptyEntry (EmptyEntry)
72013,METHOD,node.anonymous_namespace_57.EmptyEntry,TYPE_DECL,EmptyEntry& operator=(const EmptyEntry&) = delete;,3,52,dataqueue\queue.cc,node.anonymous_namespace_65.EmptyEntry.operator =,,false,539,539,operator =,,,5,EmptyEntry node.anonymous_namespace_65.EmptyEntry.operator = (EmptyEntry)
72018,METHOD,node.anonymous_namespace_57.EmptyEntry,TYPE_DECL,EmptyEntry& operator=(EmptyEntry&&) = delete;,3,47,dataqueue\queue.cc,node.anonymous_namespace_66.EmptyEntry.operator =,,false,540,540,operator =,,,6,EmptyEntry node.anonymous_namespace_66.EmptyEntry.operator = (EmptyEntry)
72023,METHOD,node.anonymous_namespace_57.EmptyEntry,TYPE_DECL,"std::shared_ptr<DataQueue::Reader> get_reader() override {
    return std::make_shared<EmptyReader>();
  }",3,3,dataqueue\queue.cc,node.anonymous_namespace_67.EmptyEntry.get_reader,,false,542,544,get_reader,,,7,shared_ptr<DataQueue::Reader> node.anonymous_namespace_67.EmptyEntry.get_reader ()
72032,METHOD,node.anonymous_namespace_57.EmptyEntry,TYPE_DECL,"std::unique_ptr<Entry> slice(
      uint64_t start,
      std::optional<uint64_t> maybeEnd = std::nullopt) override {
    if (start != 0) return nullptr;
    return std::make_unique<EmptyEntry>();
  }",3,3,dataqueue\queue.cc,node.anonymous_namespace_68.EmptyEntry.slice,,false,546,551,slice,,,8,"unique_ptr<Entry> node.anonymous_namespace_68.EmptyEntry.slice (uint64_t,ANY)"
72050,METHOD,node.anonymous_namespace_57.EmptyEntry,TYPE_DECL,std::optional<uint64_t> size() const override { return 0; },3,61,dataqueue\queue.cc,node.anonymous_namespace_69.EmptyEntry.size,,false,553,553,size,,,9,optional<uint64_t> node.anonymous_namespace_69.EmptyEntry.size ()
72056,METHOD,node.anonymous_namespace_57.EmptyEntry,TYPE_DECL,bool is_idempotent() const override { return true; },3,54,dataqueue\queue.cc,node.anonymous_namespace_70.EmptyEntry.is_idempotent,,false,555,555,is_idempotent,,,10,bool node.anonymous_namespace_70.EmptyEntry.is_idempotent ()
72065,METHOD,node.anonymous_namespace_72.InMemoryEntry.InMemoryFunctor,TYPE_DECL,void operator()(uint64_t) { backing_store = nullptr; },5,58,dataqueue\queue.cc,node.anonymous_namespace_73.InMemoryEntry.InMemoryFunctor.operator (),,false,570,570,operator (),,,2,void node.anonymous_namespace_73.InMemoryEntry.InMemoryFunctor.operator () (uint64_t)
72073,METHOD,node.anonymous_namespace_74.InMemoryEntry.InMemoryReader,TYPE_DECL,InMemoryReader(InMemoryEntry& entry) : entry_(entry) {},5,59,dataqueue\queue.cc,node.anonymous_namespace_75.InMemoryEntry.InMemoryReader.InMemoryReader,,false,577,577,InMemoryReader,,,1,ANY node.anonymous_namespace_75.InMemoryEntry.InMemoryReader.InMemoryReader (InMemoryEntry)
72078,METHOD,node.anonymous_namespace_74.InMemoryEntry.InMemoryReader,TYPE_DECL,"int Pull(Next next,
             int options,
             DataQueue::Vec* data,
             size_t count,
             size_t max_count_hint = bob::kMaxCountHint) override {
      auto self = shared_from_this();
      if (ended_) {
        std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        return bob::Status::STATUS_EOS;
      }

      ended_ = true;
      DataQueue::Vec vec{
          reinterpret_cast<uint8_t*>(entry_.backing_store_->Data()) +
              entry_.offset_,
          entry_.byte_length_,
      };

      std::move(next)(bob::Status::STATUS_CONTINUE,
                      &vec,
                      1,
                      InMemoryFunctor({entry_.backing_store_}));
      return bob::Status::STATUS_CONTINUE;
    }",5,5,dataqueue\queue.cc,node.anonymous_namespace_76.InMemoryEntry.InMemoryReader.Pull,,false,579,602,Pull,,,2,"int node.anonymous_namespace_76.InMemoryEntry.InMemoryReader.Pull (Next,int,ANY*,size_t,size_t)"
72163,METHOD,<empty>,<empty>,<empty>,3,,dataqueue\queue.cc,node.anonymous_namespace_74.InMemoryEntry.InMemoryReader:<clinit>,,false,573,,<clinit>,,,5,
72170,METHOD,node.anonymous_namespace_71.InMemoryEntry,TYPE_DECL,"InMemoryEntry(std::shared_ptr<BackingStore> backing_store,
                uint64_t offset,
                uint64_t byte_length)
      : backing_store_(std::move(backing_store)),
        offset_(offset),
        byte_length_(byte_length) {
    // The offset_ + byte_length_ cannot extend beyond the size of the
    // backing store, because that would just be silly.
    CHECK_LE(offset_ + byte_length_, backing_store_->ByteLength());
  }",3,3,dataqueue\queue.cc,node.anonymous_namespace_78.InMemoryEntry.InMemoryEntry,,false,613,622,InMemoryEntry,,,3,"ANY node.anonymous_namespace_78.InMemoryEntry.InMemoryEntry (ANY,uint64_t,uint64_t)"
72185,METHOD,node.anonymous_namespace_71.InMemoryEntry,TYPE_DECL,InMemoryEntry(const InMemoryEntry&) = delete;,3,47,dataqueue\queue.cc,node.anonymous_namespace_79.InMemoryEntry.InMemoryEntry,,false,625,625,InMemoryEntry,,,4,ANY node.anonymous_namespace_79.InMemoryEntry.InMemoryEntry (InMemoryEntry)
72190,METHOD,node.anonymous_namespace_71.InMemoryEntry,TYPE_DECL,InMemoryEntry(InMemoryEntry&&) = delete;,3,42,dataqueue\queue.cc,node.anonymous_namespace_80.InMemoryEntry.InMemoryEntry,,false,626,626,InMemoryEntry,,,5,ANY node.anonymous_namespace_80.InMemoryEntry.InMemoryEntry (InMemoryEntry)
72195,METHOD,node.anonymous_namespace_71.InMemoryEntry,TYPE_DECL,InMemoryEntry& operator=(const InMemoryEntry&) = delete;,3,58,dataqueue\queue.cc,node.anonymous_namespace_81.InMemoryEntry.operator =,,false,627,627,operator =,,,6,InMemoryEntry node.anonymous_namespace_81.InMemoryEntry.operator = (InMemoryEntry)
72200,METHOD,node.anonymous_namespace_71.InMemoryEntry,TYPE_DECL,InMemoryEntry& operator=(InMemoryEntry&&) = delete;,3,53,dataqueue\queue.cc,node.anonymous_namespace_82.InMemoryEntry.operator =,,false,628,628,operator =,,,7,InMemoryEntry node.anonymous_namespace_82.InMemoryEntry.operator = (InMemoryEntry)
72205,METHOD,node.anonymous_namespace_71.InMemoryEntry,TYPE_DECL,"std::shared_ptr<DataQueue::Reader> get_reader() override {
    return std::make_shared<InMemoryReader>(*this);
  }",3,3,dataqueue\queue.cc,node.anonymous_namespace_83.InMemoryEntry.get_reader,,false,630,632,get_reader,,,8,shared_ptr<DataQueue::Reader> node.anonymous_namespace_83.InMemoryEntry.get_reader ()
72218,METHOD,node.anonymous_namespace_71.InMemoryEntry,TYPE_DECL,"std::unique_ptr<Entry> slice(
      uint64_t start,
      std::optional<uint64_t> maybeEnd = std::nullopt) override {
    const auto makeEntry = [&](uint64_t start,
                               uint64_t len) -> std::unique_ptr<Entry> {
      if (len == 0) {
        return std::make_unique<EmptyEntry>();
      }

      return std::make_unique<InMemoryEntry>(backing_store_, start, len);
    };

    start += offset_;

    // The start cannot extend beyond the maximum end point of this entry.
    start = std::min(start, offset_ + byte_length_);

    if (maybeEnd.has_value()) {
      uint64_t end = maybeEnd.value();
      // The end cannot extend beyond the maximum end point of this entry,
      // and the end must be equal to or greater than the start.
      end = std::max(start, std::min(offset_ + end, offset_ + byte_length_));

      return makeEntry(start, end - start);
    }

    // If no end is given, then the new length is the current length
    // minus the adjusted start.
    ...",3,3,dataqueue\queue.cc,node.anonymous_namespace_84.InMemoryEntry.slice,,false,634,663,slice,,,9,"unique_ptr<Entry> node.anonymous_namespace_84.InMemoryEntry.slice (uint64_t,ANY)"
72282,METHOD,node.anonymous_namespace_71.InMemoryEntry,TYPE_DECL,std::optional<uint64_t> size() const override { return byte_length_; },3,72,dataqueue\queue.cc,node.anonymous_namespace_86.InMemoryEntry.size,,false,665,665,size,,,10,optional<uint64_t> node.anonymous_namespace_86.InMemoryEntry.size ()
72288,METHOD,node.anonymous_namespace_71.InMemoryEntry,TYPE_DECL,bool is_idempotent() const override { return true; },3,54,dataqueue\queue.cc,node.anonymous_namespace_87.InMemoryEntry.is_idempotent,,false,667,667,is_idempotent,,,11,bool node.anonymous_namespace_87.InMemoryEntry.is_idempotent ()
72294,METHOD,node.anonymous_namespace_71.InMemoryEntry,TYPE_DECL,"void MemoryInfo(node::MemoryTracker* tracker) const override {
    tracker->TrackField(
        ""store"", backing_store_, ""std::shared_ptr<v8::BackingStore>"");
  }",3,3,dataqueue\queue.cc,node.anonymous_namespace_88.InMemoryEntry.MemoryInfo,,false,669,672,MemoryInfo,,,12,void node.anonymous_namespace_88.InMemoryEntry.MemoryInfo (ANY*)
72315,METHOD,node.anonymous_namespace_90.DataQueueEntry,TYPE_DECL,"explicit DataQueueEntry(std::shared_ptr<DataQueue> data_queue)
      : data_queue_(std::move(data_queue)) {
    CHECK(data_queue_);
  }",3,3,dataqueue\queue.cc,node.anonymous_namespace_91.DataQueueEntry.DataQueueEntry,,false,690,693,DataQueueEntry,,,1,ANY node.anonymous_namespace_91.DataQueueEntry.DataQueueEntry (ANY)
72322,METHOD,node.anonymous_namespace_90.DataQueueEntry,TYPE_DECL,DataQueueEntry(const DataQueueEntry&) = delete;,3,49,dataqueue\queue.cc,node.anonymous_namespace_92.DataQueueEntry.DataQueueEntry,,false,696,696,DataQueueEntry,,,2,ANY node.anonymous_namespace_92.DataQueueEntry.DataQueueEntry (DataQueueEntry)
72327,METHOD,node.anonymous_namespace_90.DataQueueEntry,TYPE_DECL,DataQueueEntry(DataQueueEntry&&) = delete;,3,44,dataqueue\queue.cc,node.anonymous_namespace_93.DataQueueEntry.DataQueueEntry,,false,697,697,DataQueueEntry,,,3,ANY node.anonymous_namespace_93.DataQueueEntry.DataQueueEntry (DataQueueEntry)
72332,METHOD,node.anonymous_namespace_90.DataQueueEntry,TYPE_DECL,DataQueueEntry& operator=(const DataQueueEntry&) = delete;,3,60,dataqueue\queue.cc,node.anonymous_namespace_94.DataQueueEntry.operator =,,false,698,698,operator =,,,4,DataQueueEntry node.anonymous_namespace_94.DataQueueEntry.operator = (DataQueueEntry)
72337,METHOD,node.anonymous_namespace_90.DataQueueEntry,TYPE_DECL,DataQueueEntry& operator=(DataQueueEntry&&) = delete;,3,55,dataqueue\queue.cc,node.anonymous_namespace_95.DataQueueEntry.operator =,,false,699,699,operator =,,,5,DataQueueEntry node.anonymous_namespace_95.DataQueueEntry.operator = (DataQueueEntry)
72342,METHOD,node.anonymous_namespace_90.DataQueueEntry,TYPE_DECL,"std::shared_ptr<DataQueue::Reader> get_reader() override {
    return std::make_shared<ReaderImpl>(data_queue_->get_reader());
  }",3,3,dataqueue\queue.cc,node.anonymous_namespace_96.DataQueueEntry.get_reader,,false,701,703,get_reader,,,6,shared_ptr<DataQueue::Reader> node.anonymous_namespace_96.DataQueueEntry.get_reader ()
72357,METHOD,node.anonymous_namespace_90.DataQueueEntry,TYPE_DECL,"std::unique_ptr<Entry> slice(
      uint64_t start, std::optional<uint64_t> end = std::nullopt) override {
    std::shared_ptr<DataQueue> sliced = data_queue_->slice(start, end);
    if (!sliced) return nullptr;

    return std::make_unique<DataQueueEntry>(std::move(sliced));
  }",3,3,dataqueue\queue.cc,node.anonymous_namespace_97.DataQueueEntry.slice,,false,705,711,slice,,,7,"unique_ptr<Entry> node.anonymous_namespace_97.DataQueueEntry.slice (uint64_t,ANY)"
72395,METHOD,node.anonymous_namespace_90.DataQueueEntry,TYPE_DECL,std::optional<uint64_t> size() const override { return data_queue_->size(); },3,79,dataqueue\queue.cc,node.anonymous_namespace_98.DataQueueEntry.size,,false,719,719,size,,,8,optional<uint64_t> node.anonymous_namespace_98.DataQueueEntry.size ()
72404,METHOD,node.anonymous_namespace_90.DataQueueEntry,TYPE_DECL,bool is_idempotent() const override { return data_queue_->is_idempotent(); },3,78,dataqueue\queue.cc,node.anonymous_namespace_99.DataQueueEntry.is_idempotent,,false,727,727,is_idempotent,,,9,bool node.anonymous_namespace_99.DataQueueEntry.is_idempotent ()
72413,METHOD,node.anonymous_namespace_90.DataQueueEntry,TYPE_DECL,"void MemoryInfo(node::MemoryTracker* tracker) const override {
    tracker->TrackField(
        ""data_queue"", data_queue_, ""std::shared_ptr<DataQueue>"");
  }",3,3,dataqueue\queue.cc,node.anonymous_namespace_100.DataQueueEntry.MemoryInfo,,false,729,732,MemoryInfo,,,10,void node.anonymous_namespace_100.DataQueueEntry.MemoryInfo (ANY*)
72425,METHOD,node.anonymous_namespace_90.DataQueueEntry,TYPE_DECL,DataQueue& getDataQueue() { return *data_queue_; },3,52,dataqueue\queue.cc,node.anonymous_namespace_101.DataQueueEntry.getDataQueue,,false,734,734,getDataQueue,,,11,DataQueue node.anonymous_namespace_101.DataQueueEntry.getDataQueue ()
72438,METHOD,node.anonymous_namespace_102.DataQueueEntry.ReaderImpl,TYPE_DECL,"explicit ReaderImpl(std::shared_ptr<DataQueue::Reader> inner)
        : inner_(std::move(inner)) {}",5,37,dataqueue\queue.cc,node.anonymous_namespace_103.DataQueueEntry.ReaderImpl.ReaderImpl,,false,745,746,ReaderImpl,,,1,ANY node.anonymous_namespace_103.DataQueueEntry.ReaderImpl.ReaderImpl (ANY)
72443,METHOD,node.anonymous_namespace_102.DataQueueEntry.ReaderImpl,TYPE_DECL,"int Pull(DataQueue::Reader::Next next,
             int options,
             DataQueue::Vec* data,
             size_t count,
             size_t max_count_hint) override {
      auto self = shared_from_this();
      return inner_->Pull(
          std::move(next), options, data, count, max_count_hint);
    }",5,5,dataqueue\queue.cc,node.anonymous_namespace_104.DataQueueEntry.ReaderImpl.Pull,,false,748,756,Pull,,,2,"int node.anonymous_namespace_104.DataQueueEntry.ReaderImpl.Pull (ANY,int,ANY*,size_t,size_t)"
72471,METHOD,node.anonymous_namespace_105.FdEntry,TYPE_DECL,"static std::unique_ptr<FdEntry> Create(Environment* env, Local<Value> path) {
    // We're only going to create the FdEntry if the file exists.
    uv_fs_t req = uv_fs_t();
    auto cleanup = OnScopeLeave([&] { uv_fs_req_cleanup(&req); });

    auto buf = std::make_shared<BufferValue>(env->isolate(), path);
    if (uv_fs_stat(nullptr, &req, buf->out(), nullptr) < 0) return nullptr;

    return std::make_unique<FdEntry>(
        env, std::move(buf), req.statbuf, 0, req.statbuf.st_size);
  }",3,3,dataqueue\queue.cc,node.anonymous_namespace_106.FdEntry.Create,,false,788,798,Create,,,1,"unique_ptr<FdEntry> node.anonymous_namespace_106.FdEntry.Create (Environment*,Local<Value>)"
72540,METHOD,node.anonymous_namespace_105.FdEntry,TYPE_DECL,"FdEntry(Environment* env,
          std::shared_ptr<BufferValue> path_,
          uv_stat_t stat,
          uint64_t start,
          uint64_t end)
      : env_(env),
        path_(std::move(path_)),
        stat_(stat),
        start_(start),
        end_(end) {}",3,20,dataqueue\queue.cc,node.anonymous_namespace_108.FdEntry.FdEntry,,false,800,809,FdEntry,,,2,"ANY node.anonymous_namespace_108.FdEntry.FdEntry (Environment*,ANY,uv_stat_t,uint64_t,uint64_t)"
72549,METHOD,node.anonymous_namespace_105.FdEntry,TYPE_DECL,"std::shared_ptr<DataQueue::Reader> get_reader() override {
    return ReaderImpl::Create(this);
  }",3,3,dataqueue\queue.cc,node.anonymous_namespace_109.FdEntry.get_reader,,false,811,813,get_reader,,,3,shared_ptr<DataQueue::Reader> node.anonymous_namespace_109.FdEntry.get_reader ()
72559,METHOD,node.anonymous_namespace_105.FdEntry,TYPE_DECL,"std::unique_ptr<Entry> slice(
      uint64_t start, std::optional<uint64_t> end = std::nullopt) override {
    uint64_t new_start = start_ + start;
    uint64_t new_end = end_;
    if (end.has_value()) {
      new_end = std::min(end.value(), end_);
    }

    CHECK(new_start >= start_);
    CHECK(new_end <= end_);

    return std::make_unique<FdEntry>(env_, path_, stat_, new_start, new_end);
  }",3,3,dataqueue\queue.cc,node.anonymous_namespace_111.FdEntry.slice,,false,815,827,slice,,,4,"unique_ptr<Entry> node.anonymous_namespace_111.FdEntry.slice (uint64_t,ANY)"
72614,METHOD,node.anonymous_namespace_105.FdEntry,TYPE_DECL,std::optional<uint64_t> size() const override { return end_ - start_; },3,73,dataqueue\queue.cc,node.anonymous_namespace_112.FdEntry.size,,false,829,829,size,,,5,optional<uint64_t> node.anonymous_namespace_112.FdEntry.size ()
72622,METHOD,node.anonymous_namespace_105.FdEntry,TYPE_DECL,bool is_idempotent() const override { return true; },3,54,dataqueue\queue.cc,node.anonymous_namespace_113.FdEntry.is_idempotent,,false,831,831,is_idempotent,,,6,bool node.anonymous_namespace_113.FdEntry.is_idempotent ()
72628,METHOD,node.anonymous_namespace_105.FdEntry,TYPE_DECL,Environment* env() const { return env_; },3,43,dataqueue\queue.cc,node.anonymous_namespace_114.FdEntry.env,,false,833,833,env,,,7,Environment node.anonymous_namespace_114.FdEntry.env ()
72639,METHOD,node.anonymous_namespace_105.FdEntry,TYPE_DECL,"bool is_modified(const uv_stat_t& other) {
    return other.st_size != stat_.st_size ||
           other.st_mtim.tv_nsec != stat_.st_mtim.tv_nsec;
  }",3,3,dataqueue\queue.cc,node.anonymous_namespace_115.FdEntry.is_modified,,false,846,849,is_modified,,,13,bool node.anonymous_namespace_115.FdEntry.is_modified (uv_stat_t)
72664,METHOD,node.anonymous_namespace_105.FdEntry,TYPE_DECL,"static bool CheckModified(FdEntry* entry, int fd) {
    uv_fs_t req = uv_fs_t();
    auto cleanup = OnScopeLeave([&] { uv_fs_req_cleanup(&req); });
    // TODO(jasnell): Note the use of a sync fs call here is a bit unfortunate.
    // Doing this asynchronously creates a bit of a race condition tho, a file
    // could be unmodified when we call the operation but then by the time the
    // async callback is triggered to give us that answer the file is modified.
    // While such silliness is still possible here, the sync call at least makes
    // it less likely to hit the race.
    if (uv_fs_fstat(nullptr, &req, fd, nullptr) < 0) return true;
    return entry->is_modified(req.statbuf);
  }",3,3,dataqueue\queue.cc,node.anonymous_namespace_116.FdEntry.CheckModified,,false,851,862,CheckModified,,,14,"bool node.anonymous_namespace_116.FdEntry.CheckModified (FdEntry*,int)"
72698,METHOD,node.anonymous_namespace_118.FdEntry.ReaderImpl,TYPE_DECL,"static std::shared_ptr<ReaderImpl> Create(FdEntry* entry) {
      uv_fs_t req;
      auto cleanup = OnScopeLeave([&] { uv_fs_req_cleanup(&req); });
      int file =
          uv_fs_open(nullptr, &req, entry->path_->out(), O_RDONLY, 0, nullptr);
      if (file < 0 || FdEntry::CheckModified(entry, file)) {
        uv_fs_close(nullptr, &req, file, nullptr);
        return nullptr;
      }
      Realm* realm = entry->env()->principal_realm();
      return std::make_shared<ReaderImpl>(
          BaseObjectPtr<fs::FileHandle>(fs::FileHandle::New(
              realm->GetBindingData<fs::BindingData>(realm->context()),
              file,
              Local<Object>(),
              entry->start_,
              entry->end_ - entry->start_)),
          entry);
    }",5,5,dataqueue\queue.cc,node.anonymous_namespace_119.FdEntry.ReaderImpl.Create,,false,868,886,Create,,,1,shared_ptr<ReaderImpl> node.anonymous_namespace_119.FdEntry.ReaderImpl.Create (FdEntry*)
72800,METHOD,node.anonymous_namespace_118.FdEntry.ReaderImpl,TYPE_DECL,"explicit ReaderImpl(BaseObjectPtr<fs::FileHandle> handle, FdEntry* entry)
        : env_(handle->env()), handle_(std::move(handle)), entry_(entry) {
      handle_->PushStreamListener(this);
      handle_->env()->AddCleanupHook(cleanup, this);
    }",5,5,dataqueue\queue.cc,node.anonymous_namespace_122.FdEntry.ReaderImpl.ReaderImpl,,false,888,892,ReaderImpl,,,2,"ANY node.anonymous_namespace_122.FdEntry.ReaderImpl.ReaderImpl (ANY,FdEntry*)"
72820,METHOD,node.anonymous_namespace_118.FdEntry.ReaderImpl,TYPE_DECL,"~ReaderImpl() override {
      handle_->env()->RemoveCleanupHook(cleanup, this);
      DrainAndClose();
      handle_->RemoveStreamListener(this);
    }",5,5,dataqueue\queue.cc,node.anonymous_namespace_124.FdEntry.ReaderImpl.~ReaderImpl,,false,894,898,~ReaderImpl,,,3,ANY node.anonymous_namespace_124.FdEntry.ReaderImpl.~ReaderImpl ()
72839,METHOD,node.anonymous_namespace_118.FdEntry.ReaderImpl,TYPE_DECL,"uv_buf_t OnStreamAlloc(size_t suggested_size) override {
      return env_->allocate_managed_buffer(suggested_size);
    }",5,5,dataqueue\queue.cc,node.anonymous_namespace_127.FdEntry.ReaderImpl.OnStreamAlloc,,false,900,902,OnStreamAlloc,,,4,uv_buf_t node.anonymous_namespace_127.FdEntry.ReaderImpl.OnStreamAlloc (size_t)
72850,METHOD,node.anonymous_namespace_118.FdEntry.ReaderImpl,TYPE_DECL,"void OnStreamRead(ssize_t nread, const uv_buf_t& buf) override {
      std::shared_ptr<v8::BackingStore> store =
          env_->release_managed_buffer(buf);

      if (ended_) {
        // If we got here and ended_ is true, it means we ended and drained
        // while the read was pending. We're just going to do nothing.
        CHECK(pending_pulls_.empty());
        return;
      }

      CHECK(reading_);
      auto pending = DequeuePendingPull();

      if (CheckModified(entry_, handle_->GetFD())) {
        DrainAndClose();
        // The file was modified while the read was pending. We need to error.
        std::move(pending.next)(UV_EINVAL, nullptr, 0, [](uint64_t) {});
        return;
      }

      if (nread < 0) {
        if (nread == UV_EOF) {
          std::move(pending.next)(bob::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        } else {
          std::move(pending.next)(nread, nullptr, 0, [](uint64_t) {});
        }

        return DrainAndClose();
      }

      Data...",5,5,dataqueue\queue.cc,node.anonymous_namespace_128.FdEntry.ReaderImpl.OnStreamRead,,false,904,945,OnStreamRead,,,5,"void node.anonymous_namespace_128.FdEntry.ReaderImpl.OnStreamRead (ssize_t,uv_buf_t)"
73000,METHOD,node.anonymous_namespace_118.FdEntry.ReaderImpl,TYPE_DECL,"int Pull(Next next,
             int options,
             DataQueue::Vec* data,
             size_t count,
             size_t max_count_hint = bob::kMaxCountHint) override {
      if (ended_ || !handle_->IsAlive()) {
        std::move(next)(bob::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        return bob::STATUS_EOS;
      }

      if (FdEntry::CheckModified(entry_, handle_->GetFD())) {
        DrainAndClose();
        std::move(next)(UV_EINVAL, nullptr, 0, [](uint64_t) {});
        return UV_EINVAL;
      }

      pending_pulls_.emplace_back(std::move(next), shared_from_this());
      if (!reading_) {
        reading_ = true;
        handle_->ReadStart();
      }
      return bob::STATUS_WAIT;
    }",5,5,dataqueue\queue.cc,node.anonymous_namespace_136.FdEntry.ReaderImpl.Pull,,false,947,969,Pull,,,6,"int node.anonymous_namespace_136.FdEntry.ReaderImpl.Pull (Next,int,ANY*,size_t,size_t)"
73090,METHOD,node.anonymous_namespace_118.FdEntry.ReaderImpl,TYPE_DECL,"static void cleanup(void* self) {
      auto ptr = static_cast<ReaderImpl*>(self);
      ptr->DrainAndClose();
    }",5,5,dataqueue\queue.cc,node.anonymous_namespace_140.FdEntry.ReaderImpl.cleanup,,false,990,993,cleanup,,,14,void node.anonymous_namespace_140.FdEntry.ReaderImpl.cleanup (void*)
73105,METHOD,node.anonymous_namespace_118.FdEntry.ReaderImpl,TYPE_DECL,"void DrainAndClose() {
      if (ended_) return;
      ended_ = true;
      while (!pending_pulls_.empty()) {
        auto pending = DequeuePendingPull();
        std::move(pending.next)(bob::STATUS_EOS, nullptr, 0, [](uint64_t) {});
      }
      handle_->ReadStop();

      // We fallback to a sync close on the raw fd here because it is the
      // easiest, simplest thing to do. All of FileHandle's close mechanisms
      // assume async close and cleanup, while DrainAndClose might be running
      // in the destructor during GC, for instance. As a todo, FileHandle could
      // provide a sync mechanism for closing the FD but, for now, this
      // approach works.
      int fd = handle_->Release();
      uv_fs_t req;
      uv_fs_close(nullptr, &req, fd, nullptr);
      uv_fs_req_cleanup(&req);
    }",5,5,dataqueue\queue.cc,node.anonymous_namespace_141.FdEntry.ReaderImpl.DrainAndClose,,false,995,1014,DrainAndClose,,,15,void node.anonymous_namespace_141.FdEntry.ReaderImpl.DrainAndClose ()
73162,METHOD,node.anonymous_namespace_118.FdEntry.ReaderImpl,TYPE_DECL,"PendingPull DequeuePendingPull() {
      CHECK(!pending_pulls_.empty());
      auto pop = OnScopeLeave([this] { pending_pulls_.pop_front(); });
      return std::move(pending_pulls_.front());
    }",5,5,dataqueue\queue.cc,node.anonymous_namespace_144.FdEntry.ReaderImpl.DequeuePendingPull,,false,1016,1020,DequeuePendingPull,,,16,PendingPull node.anonymous_namespace_144.FdEntry.ReaderImpl.DequeuePendingPull ()
73187,METHOD,<empty>,<empty>,<empty>,3,,dataqueue\queue.cc,node.anonymous_namespace_118.FdEntry.ReaderImpl:<clinit>,,false,864,,<clinit>,,,18,
73198,METHOD,<empty>,<empty>,<empty>,1,,dataqueue\queue.cc,node.anonymous_namespace_105.FdEntry:<clinit>,,false,777,,<clinit>,,,17,
73208,METHOD,dataqueue\queue.cc:<global>,TYPE_DECL,"std::shared_ptr<DataQueue> DataQueue::CreateIdempotent(
    std::vector<std::unique_ptr<Entry>> list) {
  // Any entry is invalid for an idempotent DataQueue if any of the entries
  // are nullptr or is not idempotent.
  uint64_t size = 0;
  const auto isInvalid = [&size](auto& item) {
    if (item == nullptr || !item->is_idempotent()) {
      return true;  // true means the entry is not valid here.
    }

    // To keep from having to iterate over the entries
    // again, we'll try calculating the size. If any
    // of the entries are unable to provide a size, then
    // we assume we cannot safely treat this entry as
    // idempotent even if it claims to be.
    if (item->size().has_value()) {
      size += item->size().value();
    } else {
      return true;  // true means the entry is not valid here.
    }

    return false;
  };

  if (std::any_of(list.begin(), list.end(), isInvalid)) {
    return nullptr;
  }

  return std::make_shared<DataQueueImpl>(std::move(list), size);
}",1,1,dataqueue\queue.cc,node.DataQueue.CreateIdempotent,,false,1032,1061,CreateIdempotent,,,2,shared_ptr<DataQueue> node.DataQueue.CreateIdempotent (ANY)
73252,METHOD,dataqueue\queue.cc:<global>,TYPE_DECL,"std::shared_ptr<DataQueue> DataQueue::Create(std::optional<uint64_t> capped) {
  return std::make_shared<DataQueueImpl>(capped);
}",1,1,dataqueue\queue.cc,node.DataQueue.Create,,false,1063,1065,Create,,,3,shared_ptr<DataQueue> node.DataQueue.Create (ANY)
73265,METHOD,dataqueue\queue.cc:<global>,TYPE_DECL,"std::unique_ptr<DataQueue::Entry> DataQueue::CreateInMemoryEntryFromView(
    Local<ArrayBufferView> view) {
  // If the view is not detachable, we do not want to create an InMemoryEntry
  // from it. Why? Because if we're not able to detach the backing store from
  // the underlying buffer, something else could modify the buffer while we're
  // holding the reference, which means we cannot guarantee that reads will be
  // idempotent.
  if (!view->Buffer()->IsDetachable()) {
    return nullptr;
  }
  auto store = view->Buffer()->GetBackingStore();
  auto offset = view->ByteOffset();
  auto length = view->ByteLength();
  USE(view->Buffer()->Detach(Local<Value>()));
  return CreateInMemoryEntryFromBackingStore(std::move(store), offset, length);
}",1,1,dataqueue\queue.cc,node.DataQueue.CreateInMemoryEntryFromView,,false,1067,1082,CreateInMemoryEntryFromView,,,4,unique_ptr<DataQueue::Entry> node.DataQueue.CreateInMemoryEntryFromView (Local<ArrayBufferView>)
73324,METHOD,dataqueue\queue.cc:<global>,TYPE_DECL,"std::unique_ptr<DataQueue::Entry>
DataQueue::CreateInMemoryEntryFromBackingStore(
    std::shared_ptr<BackingStore> store, uint64_t offset, uint64_t length) {
  CHECK(store);
  if (offset + length > store->ByteLength()) {
    return nullptr;
  }
  return std::make_unique<InMemoryEntry>(std::move(store), offset, length);
}",1,1,dataqueue\queue.cc,node.DataQueue.CreateInMemoryEntryFromBackingStore,,false,1084,1092,CreateInMemoryEntryFromBackingStore,,,5,"unique_ptr<DataQueue::Entry> node.DataQueue.CreateInMemoryEntryFromBackingStore (ANY,uint64_t,uint64_t)"
73361,METHOD,dataqueue\queue.cc:<global>,TYPE_DECL,"std::unique_ptr<DataQueue::Entry> DataQueue::CreateDataQueueEntry(
    std::shared_ptr<DataQueue> data_queue) {
  return std::make_unique<DataQueueEntry>(std::move(data_queue));
}",1,1,dataqueue\queue.cc,node.DataQueue.CreateDataQueueEntry,,false,1094,1097,CreateDataQueueEntry,,,6,unique_ptr<DataQueue::Entry> node.DataQueue.CreateDataQueueEntry (ANY)
73378,METHOD,dataqueue\queue.cc:<global>,TYPE_DECL,"std::unique_ptr<DataQueue::Entry> DataQueue::CreateFdEntry(Environment* env,
                                                           Local<Value> path) {
  return FdEntry::Create(env, path);
}",1,1,dataqueue\queue.cc,node.DataQueue.CreateFdEntry,,false,1099,1102,CreateFdEntry,,,7,"unique_ptr<DataQueue::Entry> node.DataQueue.CreateFdEntry (Environment*,Local<Value>)"
73391,METHOD,dataqueue\queue.cc:<global>,TYPE_DECL,"void DataQueue::Initialize(Environment* env, v8::Local<v8::Object> target) {
  // Nothing to do here currently.
}",1,1,dataqueue\queue.cc,node.DataQueue.Initialize,,false,1104,1106,Initialize,,,8,"void node.DataQueue.Initialize (Environment*,ANY)"
73397,METHOD,dataqueue\queue.cc:<global>,TYPE_DECL,"void DataQueue::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  // Nothing to do here currently.
}",1,1,dataqueue\queue.cc,node.DataQueue.RegisterExternalReferences,,false,1108,1111,RegisterExternalReferences,,,9,void node.DataQueue.RegisterExternalReferences (ExternalReferenceRegistry*)
73427,METHOD,dataqueue\queue.hpp:<global>,TYPE_DECL,<global>,1,62,dataqueue\queue.hpp,dataqueue\queue.hpp:<global>,,false,1,294,<global>,,,1,
73438,METHOD,debug_utils-inl.hpp:<global>,TYPE_DECL,<global>,1,33,debug_utils-inl.hpp,debug_utils-inl.hpp:<global>,,false,1,226,<global>,,,1,
73441,METHOD,debug_utils.cc:<global>,TYPE_DECL,"[](uv_handle_t* handle, void* arg) {
    Info* info = static_cast<Info*>(arg);
    NativeSymbolDebuggingContext* sym_ctx = info->ctx.get();
    FILE* stream = info->stream;
    info->num_handles++;

    fprintf(stream, ""[%p] %s%s\n"", handle, uv_handle_type_name(handle->type),
            uv_is_active(handle) ? "" (active)"" : """");

    void* close_cb = reinterpret_cast<void*>(handle->close_cb);
    fprintf(stream, ""\tClose callback: %p %s\n"",
        close_cb, sym_ctx->LookupSymbol(close_cb).Display().c_str());

    fprintf(stream, ""\tData: %p %s\n"",
        handle->data, sym_ctx->LookupSymbol(handle->data).Display().c_str());

    // We are also interested in the first field of what `handle->data`
    // points to, because for C++ code that is usually the virtual table pointer
    // and gives us information about the exact kind of object we're looking at.
    void* first_field = nullptr;
    // `handle->data` might be any value, including `nullptr`, or something
    // cast from a c...",17,3,debug_utils.cc,node.PrintLibuvHandleInformation.<lambda>0,,false,338,368,<lambda>0,,,1,"ANY node.PrintLibuvHandleInformation.<lambda>0 (uv_handle_t*,void*)"
73570,METHOD,debug_utils.cc:<global>,TYPE_DECL,"[&]() {
    // The return value is ignored because there's no good way to handle it.
    fwrite(str.data(), str.size(), 1, file);
  }",24,3,debug_utils.cc,node.FWrite.<lambda>1,,false,477,480,<lambda>1,,,1,ANY node.FWrite.<lambda>1 ()
73631,METHOD,debug_utils.cc:<global>,TYPE_DECL,<global>,1,33,debug_utils-inl.hpp,debug_utils.cc:<global>,,false,1,518,<global>,,,1,
73636,METHOD,debug_utils.cc:<global>,TYPE_DECL,"void EnabledDebugList::Parse(std::shared_ptr<KVStore> env_vars,
                             v8::Isolate* isolate) {
  std::string cats;
  credentials::SafeGetenv(""NODE_DEBUG_NATIVE"", &cats, env_vars, isolate);
  Parse(cats);
}",1,1,debug_utils.cc,node.EnabledDebugList.Parse,,false,62,67,Parse,,,2,"void node.EnabledDebugList.Parse (ANY,ANY*)"
73654,METHOD,debug_utils.cc:<global>,TYPE_DECL,"void EnabledDebugList::Parse(const std::string& cats) {
  std::string debug_categories = cats;
  while (!debug_categories.empty()) {
    std::string::size_type comma_pos = debug_categories.find(',');
    std::string wanted = ToLower(debug_categories.substr(0, comma_pos));

#define V(name)                                                                \
  {                                                                            \
    static const std::string available_category = ToLower(#name);              \
    if (available_category.find(wanted) != std::string::npos)                  \
      set_enabled(DebugCategory::name);                                        \
  }

    DEBUG_CATEGORY_NAMES(V)
#undef V

    if (comma_pos == std::string::npos) break;
    // Use everything after the `,` as the list for the next iteration.
    debug_categories = debug_categories.substr(comma_pos + 1);
  }
}",1,1,debug_utils.cc,node.EnabledDebugList.Parse,,false,69,89,Parse,,,3,void node.EnabledDebugList.Parse (ANY)
73710,METHOD,node.Win32SymbolDebuggingContext,TYPE_DECL,"Win32SymbolDebuggingContext() {
    current_process_ = GetCurrentProcess();
    USE(SymInitialize(current_process_, nullptr, true));
  }",3,3,debug_utils.cc,node.Win32SymbolDebuggingContext.Win32SymbolDebuggingContext,,false,153,156,Win32SymbolDebuggingContext,,,1,ANY node.Win32SymbolDebuggingContext.Win32SymbolDebuggingContext ()
73722,METHOD,node.Win32SymbolDebuggingContext,TYPE_DECL,"~Win32SymbolDebuggingContext() override {
    USE(SymCleanup(current_process_));
  }",3,3,debug_utils.cc,node.Win32SymbolDebuggingContext.~Win32SymbolDebuggingContext,,false,158,160,~Win32SymbolDebuggingContext,,,2,ANY node.Win32SymbolDebuggingContext.~Win32SymbolDebuggingContext ()
73730,METHOD,node.Win32SymbolDebuggingContext,TYPE_DECL,"NameAndDisplacement WrappedSymFromAddr(DWORD64 dwAddress) const {
    // Refs: https://docs.microsoft.com/en-us/windows/desktop/Debug/retrieving-symbol-information-by-address
    // Patches:
    // Use `fprintf(stderr, ` instead of `printf`
    // `sym.filename = pSymbol->Name` on success
    // `current_process_` instead of `hProcess.
    DWORD64 dwDisplacement = 0;
    // Patch: made into arg - DWORD64  dwAddress = SOME_ADDRESS;

    char buffer[sizeof(SYMBOL_INFO) + MAX_SYM_NAME * sizeof(TCHAR)];
    const auto pSymbol = reinterpret_cast<PSYMBOL_INFO>(buffer);

    pSymbol->SizeOfStruct = sizeof(SYMBOL_INFO);
    pSymbol->MaxNameLen = MAX_SYM_NAME;

    if (SymFromAddr(current_process_, dwAddress, &dwDisplacement, pSymbol)) {
      // SymFromAddr returned success
      return NameAndDisplacement(pSymbol->Name, dwDisplacement);
    } else {
      // SymFromAddr failed
      const DWORD error = GetLastError();  // ""eat"" the error anyway
#ifdef DEBUG
      fprintf(stderr, ""SymFromAd...",3,3,debug_utils.cc,node.Win32SymbolDebuggingContext.WrappedSymFromAddr,,false,163,191,WrappedSymFromAddr,,,4,NameAndDisplacement node.Win32SymbolDebuggingContext.WrappedSymFromAddr (DWORD64)
73779,METHOD,node.Win32SymbolDebuggingContext,TYPE_DECL,"SymbolInfo WrappedGetLine(DWORD64 dwAddress) const {
    SymbolInfo sym{};

    // Refs: https://docs.microsoft.com/en-us/windows/desktop/Debug/retrieving-symbol-information-by-address
    // Patches:
    // Use `fprintf(stderr, ` instead of `printf`.
    // Assign values to `sym` on success.
    // `current_process_` instead of `hProcess.

    // Patch: made into arg - DWORD64  dwAddress;
    DWORD dwDisplacement;
    IMAGEHLP_LINE64 line;

    SymSetOptions(SYMOPT_LOAD_LINES);

    line.SizeOfStruct = sizeof(IMAGEHLP_LINE64);
    // Patch: made into arg - dwAddress = 0x1000000;

    if (SymGetLineFromAddr64(current_process_, dwAddress,
                             &dwDisplacement, &line)) {
      // SymGetLineFromAddr64 returned success
      sym.filename = line.FileName;
      sym.line = line.LineNumber;
    } else {
      // SymGetLineFromAddr64 failed
      const DWORD error = GetLastError();  // ""eat"" the error anyway
#ifdef DEBUG
      fprintf(stderr, ""SymGetLineFromAddr64 re...",3,3,debug_utils.cc,node.Win32SymbolDebuggingContext.WrappedGetLine,,false,193,226,WrappedGetLine,,,5,SymbolInfo node.Win32SymbolDebuggingContext.WrappedGetLine (DWORD64)
73828,METHOD,node.Win32SymbolDebuggingContext,TYPE_DECL,"std::string WrappedUnDecorateSymbolName(const char* name) const {
    // Refs: https://docs.microsoft.com/en-us/windows/desktop/Debug/retrieving-undecorated-symbol-names
    // Patches:
    // Use `fprintf(stderr, ` instead of `printf`.
    // return `szUndName` instead of `printf` on success
    char szUndName[MAX_SYM_NAME];
    if (UnDecorateSymbolName(name, szUndName, sizeof(szUndName),
                             UNDNAME_COMPLETE)) {
      // UnDecorateSymbolName returned success
      return szUndName;
    } else {
      // UnDecorateSymbolName failed
      const DWORD error = GetLastError();  // ""eat"" the error anyway
#ifdef DEBUG
      fprintf(stderr, ""UnDecorateSymbolName returned error %lu\n"", error);
#endif
    }
    return nullptr;
  }",3,3,debug_utils.cc,node.Win32SymbolDebuggingContext.WrappedUnDecorateSymbolName,,false,229,247,WrappedUnDecorateSymbolName,,,6,string node.Win32SymbolDebuggingContext.WrappedUnDecorateSymbolName (char*)
73852,METHOD,node.Win32SymbolDebuggingContext,TYPE_DECL,"SymbolInfo LookupSymbol(void* address) override {
    const DWORD64 dw_address = reinterpret_cast<DWORD64>(address);
    SymbolInfo ret = WrappedGetLine(dw_address);
    std::tie(ret.name, ret.dis) = WrappedSymFromAddr(dw_address);
    if (!ret.name.empty()) {
      ret.name = WrappedUnDecorateSymbolName(ret.name.c_str());
    }
    return ret;
  }",3,3,debug_utils.cc,node.Win32SymbolDebuggingContext.LookupSymbol,,false,249,257,LookupSymbol,,,7,SymbolInfo node.Win32SymbolDebuggingContext.LookupSymbol (void*)
73903,METHOD,node.Win32SymbolDebuggingContext,TYPE_DECL,"bool IsMapped(void* address) override {
    MEMORY_BASIC_INFORMATION info;

    if (VirtualQuery(address, &info, sizeof(info)) != sizeof(info))
      return false;

    return info.State == MEM_COMMIT && info.Protect != 0;
  }",3,3,debug_utils.cc,node.Win32SymbolDebuggingContext.IsMapped,,false,259,266,IsMapped,,,8,bool node.Win32SymbolDebuggingContext.IsMapped (void*)
73934,METHOD,node.Win32SymbolDebuggingContext,TYPE_DECL,"int GetStackTrace(void** frames, int count) override {
    return CaptureStackBackTrace(0, count, frames, nullptr);
  }",3,3,debug_utils.cc,node.Win32SymbolDebuggingContext.GetStackTrace,,false,268,270,GetStackTrace,,,9,"int node.Win32SymbolDebuggingContext.GetStackTrace (void**,int)"
73946,METHOD,node.Win32SymbolDebuggingContext,TYPE_DECL,Win32SymbolDebuggingContext(const Win32SymbolDebuggingContext&) = delete;,3,75,debug_utils.cc,node.Win32SymbolDebuggingContext.Win32SymbolDebuggingContext,,false,272,272,Win32SymbolDebuggingContext,,,10,ANY node.Win32SymbolDebuggingContext.Win32SymbolDebuggingContext (Win32SymbolDebuggingContext)
73951,METHOD,node.Win32SymbolDebuggingContext,TYPE_DECL,Win32SymbolDebuggingContext(Win32SymbolDebuggingContext&&) = delete;,3,70,debug_utils.cc,node.Win32SymbolDebuggingContext.Win32SymbolDebuggingContext,,false,273,273,Win32SymbolDebuggingContext,,,11,ANY node.Win32SymbolDebuggingContext.Win32SymbolDebuggingContext (Win32SymbolDebuggingContext)
73956,METHOD,node.Win32SymbolDebuggingContext,TYPE_DECL,"Win32SymbolDebuggingContext operator=(const Win32SymbolDebuggingContext&)
    = delete;",3,13,debug_utils.cc,node.Win32SymbolDebuggingContext.operator =,,false,274,275,operator =,,,12,Win32SymbolDebuggingContext node.Win32SymbolDebuggingContext.operator = (Win32SymbolDebuggingContext)
73961,METHOD,node.Win32SymbolDebuggingContext,TYPE_DECL,"Win32SymbolDebuggingContext operator=(Win32SymbolDebuggingContext&&)
    = delete;",3,13,debug_utils.cc,node.Win32SymbolDebuggingContext.operator =,,false,276,277,operator =,,,13,Win32SymbolDebuggingContext node.Win32SymbolDebuggingContext.operator = (Win32SymbolDebuggingContext)
73967,METHOD,debug_utils.cc:<global>,TYPE_DECL,"std::unique_ptr<NativeSymbolDebuggingContext>
NativeSymbolDebuggingContext::New() {
  return std::unique_ptr<NativeSymbolDebuggingContext>(
      new Win32SymbolDebuggingContext());
}",1,1,debug_utils.cc,node.NativeSymbolDebuggingContext.New,,false,283,287,New,,,5,unique_ptr<NativeSymbolDebuggingContext> node.NativeSymbolDebuggingContext.New ()
73980,METHOD,debug_utils.cc:<global>,TYPE_DECL,"std::string NativeSymbolDebuggingContext::SymbolInfo::Display() const {
  std::ostringstream oss;
  oss << name;
  if (dis != 0) {
    oss << ""+"" << dis;
  }
  if (!filename.empty()) {
    oss << "" ["" << filename << ']';
  }
  if (line != 0) {
    oss << "":L"" << line;
  }
  return oss.str();
}",1,1,debug_utils.cc,node.NativeSymbolDebuggingContext.SymbolInfo.Display,,false,291,304,Display,,,6,string node.NativeSymbolDebuggingContext.SymbolInfo.Display ()
74027,METHOD,debug_utils.cc:<global>,TYPE_DECL,"void DumpBacktrace(FILE* fp) {
  auto sym_ctx = NativeSymbolDebuggingContext::New();
  void* frames[256];
  const int size = sym_ctx->GetStackTrace(frames, arraysize(frames));
  for (int i = 1; i < size; i += 1) {
    void* frame = frames[i];
    NativeSymbolDebuggingContext::SymbolInfo s = sym_ctx->LookupSymbol(frame);
    fprintf(fp, ""%2d: %p %s\n"", i, frame, s.Display().c_str());
  }
}",1,1,debug_utils.cc,node.DumpBacktrace,,false,306,315,DumpBacktrace,,,7,void node.DumpBacktrace (FILE*)
74089,METHOD,debug_utils.cc:<global>,TYPE_DECL,"void CheckedUvLoopClose(uv_loop_t* loop) {
  if (uv_loop_close(loop) == 0) return;

  PrintLibuvHandleInformation(loop, stderr);

  fflush(stderr);
  // Finally, abort.
  UNREACHABLE(""uv_loop_close() while having open handles"");
}",1,1,debug_utils.cc,node.CheckedUvLoopClose,,false,317,325,CheckedUvLoopClose,,,8,void node.CheckedUvLoopClose (uv_loop_t*)
74107,METHOD,debug_utils.cc:<global>,TYPE_DECL,"void PrintLibuvHandleInformation(uv_loop_t* loop, FILE* stream) {
  struct Info {
    std::unique_ptr<NativeSymbolDebuggingContext> ctx;
    FILE* stream;
    size_t num_handles;
  };

  Info info { NativeSymbolDebuggingContext::New(), stream, 0 };

  fprintf(stream, ""uv loop at [%p] has open handles:\n"", loop);

  uv_walk(loop, [](uv_handle_t* handle, void* arg) {
    Info* info = static_cast<Info*>(arg);
    NativeSymbolDebuggingContext* sym_ctx = info->ctx.get();
    FILE* stream = info->stream;
    info->num_handles++;

    fprintf(stream, ""[%p] %s%s\n"", handle, uv_handle_type_name(handle->type),
            uv_is_active(handle) ? "" (active)"" : """");

    void* close_cb = reinterpret_cast<void*>(handle->close_cb);
    fprintf(stream, ""\tClose callback: %p %s\n"",
        close_cb, sym_ctx->LookupSymbol(close_cb).Display().c_str());

    fprintf(stream, ""\tData: %p %s\n"",
        handle->data, sym_ctx->LookupSymbol(handle->data).Display().c_str());

    // We are also interested in...",1,1,debug_utils.cc,node.PrintLibuvHandleInformation,,false,327,372,PrintLibuvHandleInformation,,,9,"void node.PrintLibuvHandleInformation (uv_loop_t*,FILE*)"
74139,METHOD,debug_utils.cc:<global>,TYPE_DECL,"std::vector<std::string> NativeSymbolDebuggingContext::GetLoadedLibraries() {
  std::vector<std::string> list;
#if defined(__linux__) || defined(__FreeBSD__) || \
    defined(__OpenBSD__) || defined(__DragonFly__)
  dl_iterate_phdr(
      [](struct dl_phdr_info* info, size_t size, void* data) {
        auto list = static_cast<std::vector<std::string>*>(data);
        if (*info->dlpi_name != '\0') {
          list->emplace_back(info->dlpi_name);
        }
        return 0;
      },
      &list);
#elif __APPLE__
  uint32_t i = 0;
  for (const char* name = _dyld_get_image_name(i); name != nullptr;
       name = _dyld_get_image_name(++i)) {
    list.emplace_back(name);
  }

#elif _AIX
  // We can't tell in advance how large the buffer needs to be.
  // Retry until we reach too large a size (1Mb).
  const unsigned int kBufferGrowStep = 4096;
  MallocedBuffer<char> buffer(kBufferGrowStep);
  int rc = -1;
  do {
    rc = loadquery(L_GETINFO, buffer.data, buffer.size);
    if (rc == 0) brea...",1,1,debug_utils.cc,node.NativeSymbolDebuggingContext.GetLoadedLibraries,,false,374,474,GetLoadedLibraries,,,10,vector<std::string> node.NativeSymbolDebuggingContext.GetLoadedLibraries ()
74154,METHOD,debug_utils.cc:<global>,TYPE_DECL,"void FWrite(FILE* file, const std::string& str) {
  auto simple_fwrite = [&]() {
    // The return value is ignored because there's no good way to handle it.
    fwrite(str.data(), str.size(), 1, file);
  };

  if (file != stderr && file != stdout) {
    simple_fwrite();
    return;
  }
#ifdef _WIN32
  HANDLE handle =
      GetStdHandle(file == stdout ? STD_OUTPUT_HANDLE : STD_ERROR_HANDLE);

  // Check if stderr is something other than a tty/console
  if (handle == INVALID_HANDLE_VALUE || handle == nullptr ||
      uv_guess_handle(_fileno(file)) != UV_TTY) {
    simple_fwrite();
    return;
  }

  // Get required wide buffer size
  int n = MultiByteToWideChar(CP_UTF8, 0, str.data(), str.size(), nullptr, 0);

  std::vector<wchar_t> wbuf(n);
  MultiByteToWideChar(CP_UTF8, 0, str.data(), str.size(), wbuf.data(), n);

  WriteConsoleW(handle, wbuf.data(), n, nullptr, nullptr);
  return;
#elif defined(__ANDROID__)
  if (file == stderr) {
    __android_log_print(ANDROID_LOG_ERROR, ""nodejs...",1,1,debug_utils.cc,node.FWrite,,false,476,512,FWrite,,,11,"void node.FWrite (FILE*,ANY)"
74174,METHOD,debug_utils.cc:<global>,TYPE_DECL,"void __DumpBacktrace(FILE* fp) {
  node::DumpBacktrace(fp);
}",12,1,debug_utils.cc,__DumpBacktrace,,false,516,518,__DumpBacktrace,,,2,void __DumpBacktrace (FILE*)
74197,METHOD,debug_utils.hpp:<global>,TYPE_DECL,<global>,1,29,debug_utils.hpp,debug_utils.hpp:<global>,,false,1,187,<global>,,,1,
74204,METHOD,diagnosticfilename-inl.hpp:<global>,TYPE_DECL,<global>,1,40,diagnosticfilename-inl.hpp,diagnosticfilename-inl.hpp:<global>,,false,1,33,<global>,,,1,
74227,METHOD,encoding_binding.cc:<global>,TYPE_DECL,<global>,1,34,encoding_binding.hpp,encoding_binding.cc:<global>,,false,1,258,<global>,,,1,
74231,METHOD,encoding_binding.cc:<global>,TYPE_DECL,"void BindingData::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""encode_into_results_buffer"",
                      encode_into_results_buffer_);
}",1,1,encoding_binding.cc,node.encoding_binding.BindingData.MemoryInfo,,false,28,31,MemoryInfo,,,1,void node.encoding_binding.BindingData.MemoryInfo (MemoryTracker*)
74242,METHOD,encoding_binding.cc:<global>,TYPE_DECL,"BindingData::BindingData(Realm* realm,
                         v8::Local<v8::Object> object,
                         InternalFieldInfo* info)
    : SnapshotableObject(realm, object, type_int),
      encode_into_results_buffer_(
          realm->isolate(),
          kEncodeIntoResultsLength,
          MAYBE_FIELD_PTR(info, encode_into_results_buffer)) {
  if (info == nullptr) {
    object
        ->Set(realm->context(),
              FIXED_ONE_BYTE_STRING(realm->isolate(), ""encodeIntoResults""),
              encode_into_results_buffer_.GetJSArray())
        .Check();
  } else {
    encode_into_results_buffer_.Deserialize(realm->context());
  }
  encode_into_results_buffer_.MakeWeak();
}",1,1,encoding_binding.cc,node.encoding_binding.BindingData.BindingData,,false,33,51,BindingData,,,2,"ANY node.encoding_binding.BindingData.BindingData (Realm*,ANY,InternalFieldInfo*)"
74289,METHOD,encoding_binding.cc:<global>,TYPE_DECL,"bool BindingData::PrepareForSerialization(Local<Context> context,
                                          v8::SnapshotCreator* creator) {
  DCHECK_NULL(internal_field_info_);
  internal_field_info_ = InternalFieldInfoBase::New<InternalFieldInfo>(type());
  internal_field_info_->encode_into_results_buffer =
      encode_into_results_buffer_.Serialize(context, creator);
  // Return true because we need to maintain the reference to the binding from
  // JS land.
  return true;
}",1,1,encoding_binding.cc,node.encoding_binding.BindingData.PrepareForSerialization,,false,53,62,PrepareForSerialization,,,3,"bool node.encoding_binding.BindingData.PrepareForSerialization (Local<Context>,ANY*)"
74317,METHOD,encoding_binding.cc:<global>,TYPE_DECL,"InternalFieldInfoBase* BindingData::Serialize(int index) {
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info = internal_field_info_;
  internal_field_info_ = nullptr;
  return info;
}",1,1,encoding_binding.cc,node.encoding_binding.BindingData.Serialize,,false,64,69,Serialize,,,4,InternalFieldInfoBase node.encoding_binding.BindingData.Serialize (int)
74336,METHOD,encoding_binding.cc:<global>,TYPE_DECL,"void BindingData::Deserialize(Local<Context> context,
                              Local<Object> holder,
                              int index,
                              InternalFieldInfoBase* info) {
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  v8::HandleScope scope(context->GetIsolate());
  Realm* realm = Realm::GetCurrent(context);
  // Recreate the buffer in the constructor.
  InternalFieldInfo* casted_info = static_cast<InternalFieldInfo*>(info);
  BindingData* binding =
      realm->AddBindingData<BindingData>(context, holder, casted_info);
  CHECK_NOT_NULL(binding);
}",1,1,encoding_binding.cc,node.encoding_binding.BindingData.Deserialize,,false,71,83,Deserialize,,,5,"void node.encoding_binding.BindingData.Deserialize (Local<Context>,Local<Object>,int,InternalFieldInfoBase*)"
74385,METHOD,encoding_binding.cc:<global>,TYPE_DECL,"void BindingData::EncodeInto(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  CHECK_GE(args.Length(), 2);
  CHECK(args[0]->IsString());
  CHECK(args[1]->IsUint8Array());
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);

  Local<String> source = args[0].As<String>();

  Local<Uint8Array> dest = args[1].As<Uint8Array>();
  Local<ArrayBuffer> buf = dest->Buffer();
  char* write_result = static_cast<char*>(buf->Data()) + dest->ByteOffset();
  size_t dest_length = dest->ByteLength();

  int nchars;
  int written = source->WriteUtf8(
      isolate,
      write_result,
      dest_length,
      &nchars,
      String::NO_NULL_TERMINATION | String::REPLACE_INVALID_UTF8);

  binding_data->encode_into_results_buffer_[0] = nchars;
  binding_data->encode_into_results_buffer_[1] = written;
}",1,1,encoding_binding.cc,node.encoding_binding.BindingData.EncodeInto,,false,85,110,EncodeInto,,,6,void node.encoding_binding.BindingData.EncodeInto (FunctionCallbackInfo<Value>)
74524,METHOD,encoding_binding.cc:<global>,TYPE_DECL,"void BindingData::EncodeUtf8String(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());

  Local<String> str = args[0].As<String>();
  size_t length = str->Utf8Length(isolate);

  Local<ArrayBuffer> ab;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    std::unique_ptr<BackingStore> bs =
        ArrayBuffer::NewBackingStore(isolate, length);

    CHECK(bs);

    str->WriteUtf8(isolate,
                   static_cast<char*>(bs->Data()),
                   -1,  // We are certain that `data` is sufficiently large
                   nullptr,
                   String::NO_NULL_TERMINATION | String::REPLACE_INVALID_UTF8);

    ab = ArrayBuffer::New(isolate, std::move(bs));
  }

  auto array = Uint8Array::New(ab, 0, length);
  args.GetReturnValue().Set(array);
}",1,1,encoding_binding.cc,node.encoding_binding.BindingData.EncodeUtf8String,,false,114,142,EncodeUtf8String,,,7,void node.encoding_binding.BindingData.EncodeUtf8String (FunctionCallbackInfo<Value>)
74655,METHOD,encoding_binding.cc:<global>,TYPE_DECL,"void BindingData::DecodeUTF8(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);  // list, flags

  CHECK_GE(args.Length(), 1);

  if (!(args[0]->IsArrayBuffer() || args[0]->IsSharedArrayBuffer() ||
        args[0]->IsArrayBufferView())) {
    return node::THROW_ERR_INVALID_ARG_TYPE(
        env->isolate(),
        ""The \""list\"" argument must be an instance of SharedArrayBuffer, ""
        ""ArrayBuffer or ArrayBufferView."");
  }

  ArrayBufferViewContents<char> buffer(args[0]);

  bool ignore_bom = args[1]->IsTrue();
  bool has_fatal = args[2]->IsTrue();

  const char* data = buffer.data();
  size_t length = buffer.length();

  if (has_fatal) {
    auto result = simdutf::validate_utf8_with_errors(data, length);

    if (result.error) {
      return node::THROW_ERR_ENCODING_INVALID_ENCODED_DATA(
          env->isolate(), ""The encoded data was not valid for encoding utf-8"");
    }
  }

  if (!ignore_bom && length >= 3) {
    if (memcmp(data, ""...",1,1,encoding_binding.cc,node.encoding_binding.BindingData.DecodeUTF8,,false,145,196,DecodeUTF8,,,8,void node.encoding_binding.BindingData.DecodeUTF8 (FunctionCallbackInfo<Value>)
74867,METHOD,encoding_binding.cc:<global>,TYPE_DECL,"void BindingData::ToASCII(const v8::FunctionCallbackInfo<v8::Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());

  Utf8Value input(env->isolate(), args[0]);
  auto out = ada::idna::to_ascii(input.ToStringView());
  args.GetReturnValue().Set(
      String::NewFromUtf8(env->isolate(), out.c_str()).ToLocalChecked());
}",1,1,encoding_binding.cc,node.encoding_binding.BindingData.ToASCII,,false,198,207,ToASCII,,,9,void node.encoding_binding.BindingData.ToASCII (ANY)
74937,METHOD,encoding_binding.cc:<global>,TYPE_DECL,"void BindingData::ToUnicode(const v8::FunctionCallbackInfo<v8::Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());

  Utf8Value input(env->isolate(), args[0]);
  auto out = ada::idna::to_unicode(input.ToStringView());
  args.GetReturnValue().Set(
      String::NewFromUtf8(env->isolate(), out.c_str()).ToLocalChecked());
}",1,1,encoding_binding.cc,node.encoding_binding.BindingData.ToUnicode,,false,209,218,ToUnicode,,,10,void node.encoding_binding.BindingData.ToUnicode (ANY)
75007,METHOD,encoding_binding.cc:<global>,TYPE_DECL,"void BindingData::CreatePerIsolateProperties(IsolateData* isolate_data,
                                             Local<ObjectTemplate> target) {
  Isolate* isolate = isolate_data->isolate();
  SetMethod(isolate, target, ""encodeInto"", EncodeInto);
  SetMethodNoSideEffect(isolate, target, ""encodeUtf8String"", EncodeUtf8String);
  SetMethodNoSideEffect(isolate, target, ""decodeUTF8"", DecodeUTF8);
  SetMethodNoSideEffect(isolate, target, ""toASCII"", ToASCII);
  SetMethodNoSideEffect(isolate, target, ""toUnicode"", ToUnicode);
}",1,1,encoding_binding.cc,node.encoding_binding.BindingData.CreatePerIsolateProperties,,false,220,228,CreatePerIsolateProperties,,,11,"void node.encoding_binding.BindingData.CreatePerIsolateProperties (IsolateData*,Local<ObjectTemplate>)"
75045,METHOD,encoding_binding.cc:<global>,TYPE_DECL,"void BindingData::CreatePerContextProperties(Local<Object> target,
                                             Local<Value> unused,
                                             Local<Context> context,
                                             void* priv) {
  Realm* realm = Realm::GetCurrent(context);
  realm->AddBindingData<BindingData>(context, target);
}",1,1,encoding_binding.cc,node.encoding_binding.BindingData.CreatePerContextProperties,,false,230,236,CreatePerContextProperties,,,12,"void node.encoding_binding.BindingData.CreatePerContextProperties (Local<Object>,Local<Value>,Local<Context>,void*)"
75071,METHOD,encoding_binding.cc:<global>,TYPE_DECL,"void BindingData::RegisterTimerExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(EncodeInto);
  registry->Register(EncodeUtf8String);
  registry->Register(DecodeUTF8);
  registry->Register(ToASCII);
  registry->Register(ToUnicode);
}",1,1,encoding_binding.cc,node.encoding_binding.BindingData.RegisterTimerExternalReferences,,false,238,245,RegisterTimerExternalReferences,,,13,void node.encoding_binding.BindingData.RegisterTimerExternalReferences (ExternalReferenceRegistry*)
75113,METHOD,encoding_binding.hpp:<global>,TYPE_DECL,<global>,1,34,encoding_binding.hpp,encoding_binding.hpp:<global>,,false,1,59,<global>,,,1,
75148,METHOD,env-inl.hpp:<global>,TYPE_DECL,<global>,1,25,env-inl.hpp,env-inl.hpp:<global>,,false,1,899,<global>,,,1,
75151,METHOD,env.cc:<global>,TYPE_DECL,[&](auto&& el) { return el.IsEmpty(); },34,72,env.cc,node.Environment.UntrackContext.<lambda>0,,false,216,216,<lambda>0,,,1,ANY node.Environment.UntrackContext.<lambda>0 (auto)
75163,METHOD,env.cc:<global>,TYPE_DECL,"[](uv_async_t* async) {
        Environment* env = ContainerOf(
            &Environment::task_queues_async_, async);
        HandleScope handle_scope(env->isolate());
        Context::Scope context_scope(env->context());
        env->RunAndClearNativeImmediates();
      }",7,7,env.cc,node.Environment.InitializeLibuv.<lambda>1,,false,957,963,<lambda>1,,,1,ANY node.Environment.InitializeLibuv.<lambda>1 (uv_async_t*)
75194,METHOD,env.cc:<global>,TYPE_DECL,"[](Environment* env) {
    env->set_can_call_into_js(false);
    uv_stop(env->event_loop());
  }",26,3,env.cc,node.Environment.ExitEnv.<lambda>2,,false,991,994,<lambda>2,,,1,ANY node.Environment.ExitEnv.<lambda>2 (Environment*)
75210,METHOD,env.cc:<global>,TYPE_DECL,"[](uv_handle_t* handle) {
#ifdef DEBUG
      memset(handle, 0xab, uv_handle_size(handle->type));
#endif
    }",30,5,env.cc,node.Environment.RegisterHandleCleanups..<lambda>4,,false,1002,1006,<lambda>4,,,1,ANY node.Environment.RegisterHandleCleanups..<lambda>4 (uv_handle_t*)
75216,METHOD,env.cc:<global>,TYPE_DECL,"[](Environment* env, uv_handle_t* handle,
                                        void* arg) {
    handle->data = env;

    env->CloseHandle(handle, [](uv_handle_t* handle) {
#ifdef DEBUG
      memset(handle, 0xab, uv_handle_size(handle->type));
#endif
    });
  }",38,3,env.cc,node.Environment.RegisterHandleCleanups.<lambda>3,,false,998,1007,<lambda>3,,,1,"ANY node.Environment.RegisterHandleCleanups.<lambda>3 (Environment*,uv_handle_t*,void*)"
75235,METHOD,env.cc:<global>,TYPE_DECL,"[&](uv_handle_t* handle) {
    RegisterHandleCleanup(handle, close_and_finish, nullptr);
  }",26,3,env.cc,node.Environment.RegisterHandleCleanups.<lambda>5,,false,1009,1011,<lambda>5,,,1,ANY node.Environment.RegisterHandleCleanups.<lambda>5 (uv_handle_t*)
75246,METHOD,env.cc:<global>,TYPE_DECL,"[](uv_prepare_t* handle) {
    Environment* env = ContainerOf(&Environment::idle_prepare_handle_, handle);
    env->isolate()->SetIdle(true);
  }",43,3,env.cc,node.Environment.StartProfilerIdleNotifier.<lambda>6,,false,1049,1052,<lambda>6,,,1,ANY node.Environment.StartProfilerIdleNotifier.<lambda>6 (uv_prepare_t*)
75269,METHOD,env.cc:<global>,TYPE_DECL,"[](uv_check_t* handle) {
    Environment* env = ContainerOf(&Environment::idle_check_handle_, handle);
    env->isolate()->SetIdle(false);
  }",39,3,env.cc,node.Environment.StartProfilerIdleNotifier.<lambda>7,,false,1053,1056,<lambda>7,,,1,ANY node.Environment.StartProfilerIdleNotifier.<lambda>7 (uv_check_t*)
75292,METHOD,env.cc:<global>,TYPE_DECL,"[&](NativeImmediateQueue* queue) {
    TryCatchScope try_catch(this);
    DebugSealHandleScope seal_handle_scope(isolate());
    while (auto head = queue->Shift()) {
      bool is_refed = head->flags() & CallbackFlags::kRefed;
      if (is_refed)
        ref_count++;

      if (is_refed || !only_refed)
        head->Call(this);

      head.reset();  // Destroy now so that this is also observed by try_catch.

      if (UNLIKELY(try_catch.HasCaught())) {
        if (!try_catch.HasTerminated() && can_call_into_js())
          errors::TriggerUncaughtException(isolate(), try_catch);

        return true;
      }
    }
    return false;
  }",21,3,env.cc,node.Environment.RunAndClearNativeImmediates.<lambda>8,,false,1159,1180,<lambda>8,,,1,ANY node.Environment.RunAndClearNativeImmediates.<lambda>8 (NativeImmediateQueue*)
75365,METHOD,env.cc:<global>,TYPE_DECL,"[](Isolate* isolate, void* data) {
    std::unique_ptr<Environment*> env_ptr { static_cast<Environment**>(data) };
    Environment* env = *env_ptr;
    if (env == nullptr) {
      // The Environment has already been destroyed. That should be okay; any
      // callback added before the Environment shuts down would have been
      // handled during cleanup.
      return;
    }
    env->interrupt_data_.store(nullptr);
    env->RunAndClearInterrupts();
  }",31,3,env.cc,node.Environment.RequestInterruptFromV8.<lambda>9,,false,1222,1233,<lambda>9,,,1,"ANY node.Environment.RequestInterruptFromV8.<lambda>9 (Isolate*,void*)"
75401,METHOD,env.cc:<global>,TYPE_DECL,[](uv_idle_t*){ },44,60,env.cc,node.Environment.ToggleImmediateRef.<lambda>10,,false,1342,1342,<lambda>10,,,1,ANY node.Environment.ToggleImmediateRef.<lambda>10 (uv_idle_t*)
75466,METHOD,env.cc:<global>,TYPE_DECL,<global>,1,21,env.hpp,env.cc:<global>,,false,1,1943,<global>,,,1,
75484,METHOD,env.cc:<global>,TYPE_DECL,"void AsyncHooks::ResetPromiseHooks(Local<Function> init,
                                   Local<Function> before,
                                   Local<Function> after,
                                   Local<Function> resolve) {
  js_promise_hooks_[0].Reset(env()->isolate(), init);
  js_promise_hooks_[1].Reset(env()->isolate(), before);
  js_promise_hooks_[2].Reset(env()->isolate(), after);
  js_promise_hooks_[3].Reset(env()->isolate(), resolve);
}",1,1,env.cc,node.AsyncHooks.ResetPromiseHooks,,false,68,76,ResetPromiseHooks,,,5,"void node.AsyncHooks.ResetPromiseHooks (Local<Function>,Local<Function>,Local<Function>,Local<Function>)"
75536,METHOD,env.cc:<global>,TYPE_DECL,"void Environment::ResetPromiseHooks(Local<Function> init,
                                    Local<Function> before,
                                    Local<Function> after,
                                    Local<Function> resolve) {
  async_hooks()->ResetPromiseHooks(init, before, after, resolve);

  for (auto it = contexts_.begin(); it != contexts_.end(); it++) {
    if (it->IsEmpty()) {
      contexts_.erase(it--);
      continue;
    }
    PersistentToLocal::Weak(isolate_, *it)
        ->SetPromiseHooks(init, before, after, resolve);
  }
}",1,1,env.cc,node.Environment.ResetPromiseHooks,,false,78,92,ResetPromiseHooks,,,6,"void node.Environment.ResetPromiseHooks (Local<Function>,Local<Function>,Local<Function>,Local<Function>)"
75597,METHOD,env.cc:<global>,TYPE_DECL,"void AsyncHooks::push_async_context(double async_id,
                                    double trigger_async_id,
                                    Local<Object> resource) {
  // Since async_hooks is experimental, do only perform the check
  // when async_hooks is enabled.
  if (fields_[kCheck] > 0) {
    CHECK_GE(async_id, -1);
    CHECK_GE(trigger_async_id, -1);
  }

  uint32_t offset = fields_[kStackLength];
  if (offset * 2 >= async_ids_stack_.Length()) grow_async_ids_stack();
  async_ids_stack_[2 * offset] = async_id_fields_[kExecutionAsyncId];
  async_ids_stack_[2 * offset + 1] = async_id_fields_[kTriggerAsyncId];
  fields_[kStackLength] += 1;
  async_id_fields_[kExecutionAsyncId] = async_id;
  async_id_fields_[kTriggerAsyncId] = trigger_async_id;

#ifdef DEBUG
  for (uint32_t i = offset; i < native_execution_async_resources_.size(); i++)
    CHECK(native_execution_async_resources_[i].IsEmpty());
#endif

  // When this call comes from JS (as a way of increasing the stack siz...",1,1,env.cc,node.AsyncHooks.push_async_context,,false,95,125,push_async_context,,,7,"void node.AsyncHooks.push_async_context (double,double,Local<Object>)"
75690,METHOD,env.cc:<global>,TYPE_DECL,"bool AsyncHooks::pop_async_context(double async_id) {
  // In case of an exception then this may have already been reset, if the
  // stack was multiple MakeCallback()'s deep.
  if (UNLIKELY(fields_[kStackLength] == 0)) return false;

  // Ask for the async_id to be restored as a check that the stack
  // hasn't been corrupted.
  if (UNLIKELY(fields_[kCheck] > 0 &&
               async_id_fields_[kExecutionAsyncId] != async_id)) {
    FailWithCorruptedAsyncStack(async_id);
  }

  uint32_t offset = fields_[kStackLength] - 1;
  async_id_fields_[kExecutionAsyncId] = async_ids_stack_[2 * offset];
  async_id_fields_[kTriggerAsyncId] = async_ids_stack_[2 * offset + 1];
  fields_[kStackLength] = offset;

  if (LIKELY(offset < native_execution_async_resources_.size() &&
             !native_execution_async_resources_[offset].IsEmpty())) {
#ifdef DEBUG
    for (uint32_t i = offset + 1; i < native_execution_async_resources_.size();
         i++) {
      CHECK(native_execution_async_resources_...",1,1,env.cc,node.AsyncHooks.pop_async_context,,false,128,170,pop_async_context,,,8,bool node.AsyncHooks.pop_async_context (double)
75843,METHOD,env.cc:<global>,TYPE_DECL,"void AsyncHooks::clear_async_id_stack() {
  if (!js_execution_async_resources_.IsEmpty() && env()->can_call_into_js()) {
    Isolate* isolate = env()->isolate();
    HandleScope handle_scope(isolate);
    USE(PersistentToLocal::Strong(js_execution_async_resources_)
            ->Set(env()->context(),
                  env()->length_string(),
                  Integer::NewFromUnsigned(isolate, 0)));
  }

  native_execution_async_resources_.clear();
  native_execution_async_resources_.shrink_to_fit();

  async_id_fields_[kExecutionAsyncId] = 0;
  async_id_fields_[kTriggerAsyncId] = 0;
  fields_[kStackLength] = 0;
}",1,1,env.cc,node.AsyncHooks.clear_async_id_stack,,false,172,188,clear_async_id_stack,,,9,void node.AsyncHooks.clear_async_id_stack ()
75915,METHOD,env.cc:<global>,TYPE_DECL,"void AsyncHooks::InstallPromiseHooks(Local<Context> ctx) {
  ctx->SetPromiseHooks(js_promise_hooks_[0].IsEmpty()
                           ? Local<Function>()
                           : PersistentToLocal::Strong(js_promise_hooks_[0]),
                       js_promise_hooks_[1].IsEmpty()
                           ? Local<Function>()
                           : PersistentToLocal::Strong(js_promise_hooks_[1]),
                       js_promise_hooks_[2].IsEmpty()
                           ? Local<Function>()
                           : PersistentToLocal::Strong(js_promise_hooks_[2]),
                       js_promise_hooks_[3].IsEmpty()
                           ? Local<Function>()
                           : PersistentToLocal::Strong(js_promise_hooks_[3]));
}",1,1,env.cc,node.AsyncHooks.InstallPromiseHooks,,false,190,203,InstallPromiseHooks,,,10,void node.AsyncHooks.InstallPromiseHooks (Local<Context>)
75984,METHOD,env.cc:<global>,TYPE_DECL,"void Environment::TrackContext(Local<Context> context) {
  size_t id = contexts_.size();
  contexts_.resize(id + 1);
  contexts_[id].Reset(isolate_, context);
  contexts_[id].SetWeak();
}",1,1,env.cc,node.Environment.TrackContext,,false,205,210,TrackContext,,,11,void node.Environment.TrackContext (Local<Context>)
76017,METHOD,env.cc:<global>,TYPE_DECL,"void Environment::UntrackContext(Local<Context> context) {
  HandleScope handle_scope(isolate_);
  contexts_.erase(std::remove_if(contexts_.begin(),
                                 contexts_.end(),
                                 [&](auto&& el) { return el.IsEmpty(); }),
                  contexts_.end());
  for (auto it = contexts_.begin(); it != contexts_.end(); it++) {
    Local<Context> saved_context = PersistentToLocal::Weak(isolate_, *it);
    if (saved_context == context) {
      it->Reset();
      contexts_.erase(it);
      break;
    }
  }
}",1,1,env.cc,node.Environment.UntrackContext,,false,212,226,UntrackContext,,,12,void node.Environment.UntrackContext (Local<Context>)
76092,METHOD,env.cc:<global>,TYPE_DECL,"void Environment::TrackShadowRealm(shadow_realm::ShadowRealm* realm) {
  shadow_realms_.insert(realm);
}",1,1,env.cc,node.Environment.TrackShadowRealm,,false,228,230,TrackShadowRealm,,,13,void node.Environment.TrackShadowRealm (ANY*)
76102,METHOD,env.cc:<global>,TYPE_DECL,"void Environment::UntrackShadowRealm(shadow_realm::ShadowRealm* realm) {
  shadow_realms_.erase(realm);
}",1,1,env.cc,node.Environment.UntrackShadowRealm,,false,232,234,UntrackShadowRealm,,,14,void node.Environment.UntrackShadowRealm (ANY*)
76112,METHOD,env.cc:<global>,TYPE_DECL,"AsyncHooks::DefaultTriggerAsyncIdScope::DefaultTriggerAsyncIdScope(
    Environment* env, double default_trigger_async_id)
    : async_hooks_(env->async_hooks()) {
  if (env->async_hooks()->fields()[AsyncHooks::kCheck] > 0) {
    CHECK_GE(default_trigger_async_id, 0);
  }

  old_default_trigger_async_id_ =
      async_hooks_->async_id_fields()[AsyncHooks::kDefaultTriggerAsyncId];
  async_hooks_->async_id_fields()[AsyncHooks::kDefaultTriggerAsyncId] =
      default_trigger_async_id;
}",1,1,env.cc,node.AsyncHooks.DefaultTriggerAsyncIdScope.DefaultTriggerAsyncIdScope,,false,236,247,DefaultTriggerAsyncIdScope,,,15,"ANY node.AsyncHooks.DefaultTriggerAsyncIdScope.DefaultTriggerAsyncIdScope (Environment*,double)"
76156,METHOD,env.cc:<global>,TYPE_DECL,"AsyncHooks::DefaultTriggerAsyncIdScope::~DefaultTriggerAsyncIdScope() {
  async_hooks_->async_id_fields()[AsyncHooks::kDefaultTriggerAsyncId] =
      old_default_trigger_async_id_;
}",1,1,env.cc,node.AsyncHooks.DefaultTriggerAsyncIdScope.~DefaultTriggerAsyncIdScope,,false,249,252,~DefaultTriggerAsyncIdScope,,,16,ANY node.AsyncHooks.DefaultTriggerAsyncIdScope.~DefaultTriggerAsyncIdScope ()
76170,METHOD,env.cc:<global>,TYPE_DECL,"AsyncHooks::DefaultTriggerAsyncIdScope::DefaultTriggerAsyncIdScope(
    AsyncWrap* async_wrap)
    : DefaultTriggerAsyncIdScope(async_wrap->env(),
                                 async_wrap->get_async_id()) {}",1,63,env.cc,node.AsyncHooks.DefaultTriggerAsyncIdScope.DefaultTriggerAsyncIdScope,,false,254,257,DefaultTriggerAsyncIdScope,,,17,ANY node.AsyncHooks.DefaultTriggerAsyncIdScope.DefaultTriggerAsyncIdScope (AsyncWrap*)
76175,METHOD,env.cc:<global>,TYPE_DECL,"std::ostream& operator<<(std::ostream& output,
                         const std::vector<SnapshotIndex>& v) {
  output << ""{ "";
  for (const SnapshotIndex i : v) {
    output << i << "", "";
  }
  output << "" }"";
  return output;
}",1,1,env.cc,node.operator <<,,false,259,267,operator <<,,,18,"ostream node.operator << (ANY,ANY)"
76198,METHOD,env.cc:<global>,TYPE_DECL,"std::ostream& operator<<(std::ostream& output,
                         const IsolateDataSerializeInfo& i) {
  output << ""{\n""
         << ""// -- primitive begins --\n""
         << i.primitive_values << "",\n""
         << ""// -- primitive ends --\n""
         << ""// -- template_values begins --\n""
         << i.template_values << "",\n""
         << ""// -- template_values ends --\n""
         << ""}"";
  return output;
}",1,1,env.cc,node.operator <<,,false,269,280,operator <<,,,19,"ostream node.operator << (ANY,IsolateDataSerializeInfo)"
76231,METHOD,env.cc:<global>,TYPE_DECL,"std::ostream& operator<<(std::ostream& output, const SnapshotMetadata& i) {
  output << ""{\n""
         << ""  ""
         << (i.type == SnapshotMetadata::Type::kDefault
                 ? ""SnapshotMetadata::Type::kDefault""
                 : ""SnapshotMetadata::Type::kFullyCustomized"")
         << "", // type\n""
         << ""  \"""" << i.node_version << ""\"", // node_version\n""
         << ""  \"""" << i.node_arch << ""\"", // node_arch\n""
         << ""  \"""" << i.node_platform << ""\"", // node_platform\n""
         << ""  "" << i.v8_cache_version_tag << "", // v8_cache_version_tag\n""
         << ""}"";
  return output;
}",1,1,env.cc,node.operator <<,,false,282,295,operator <<,,,20,"ostream node.operator << (ANY,SnapshotMetadata)"
76293,METHOD,env.cc:<global>,TYPE_DECL,"IsolateDataSerializeInfo IsolateData::Serialize(SnapshotCreator* creator) {
  Isolate* isolate = creator->GetIsolate();
  IsolateDataSerializeInfo info;
  HandleScope handle_scope(isolate);
  // XXX(joyeecheung): technically speaking, the indexes here should be
  // consecutive and we could just return a range instead of an array,
  // but that's not part of the V8 API contract so we use an array
  // just to be safe.

#define VP(PropertyName, StringValue) V(Private, PropertyName)
#define VY(PropertyName, StringValue) V(Symbol, PropertyName)
#define VS(PropertyName, StringValue) V(String, PropertyName)
#define VR(PropertyName, TypeName) V(Private, per_realm_##PropertyName)
#define V(TypeName, PropertyName)                                              \
  info.primitive_values.push_back(                                             \
      creator->AddData(PropertyName##_.Get(isolate)));
  PER_ISOLATE_PRIVATE_SYMBOL_PROPERTIES(VP)
  PER_ISOLATE_SYMBOL_PROPERTIES(VY)
  PER_ISOLATE_STRI...",1,1,env.cc,node.IsolateData.Serialize,,false,297,342,Serialize,,,21,IsolateDataSerializeInfo node.IsolateData.Serialize (SnapshotCreator*)
76352,METHOD,env.cc:<global>,TYPE_DECL,"void IsolateData::DeserializeProperties(const IsolateDataSerializeInfo* info) {
  size_t i = 0;
  HandleScope handle_scope(isolate_);

  if (per_process::enabled_debug_list.enabled(DebugCategory::MKSNAPSHOT)) {
    fprintf(stderr, ""deserializing IsolateDataSerializeInfo...\n"");
    std::cerr << *info << ""\n"";
  }

#define VP(PropertyName, StringValue) V(Private, PropertyName)
#define VY(PropertyName, StringValue) V(Symbol, PropertyName)
#define VS(PropertyName, StringValue) V(String, PropertyName)
#define VR(PropertyName, TypeName) V(Private, per_realm_##PropertyName)
#define V(TypeName, PropertyName)                                              \
  do {                                                                         \
    MaybeLocal<TypeName> maybe_field =                                         \
        isolate_->GetDataFromSnapshotOnce<TypeName>(                           \
            info->primitive_values[i++]);                                      \
    Local<TypeNam...",1,1,env.cc,node.IsolateData.DeserializeProperties,,false,344,414,DeserializeProperties,,,22,void node.IsolateData.DeserializeProperties (IsolateDataSerializeInfo*)
76467,METHOD,env.cc:<global>,TYPE_DECL,"void IsolateData::CreateProperties() {
  // Create string and private symbol properties as internalized one byte
  // strings after the platform is properly initialized.
  //
  // Internalized because it makes property lookups a little faster and
  // because the string is created in the old space straight away.  It's going
  // to end up in the old space sooner or later anyway but now it doesn't go
  // through v8::Eternal's new space handling first.
  //
  // One byte because our strings are ASCII and we can safely skip V8's UTF-8
  // decoding step.

  HandleScope handle_scope(isolate_);

#define V(PropertyName, StringValue)                                           \
  PropertyName##_.Set(                                                         \
      isolate_,                                                                \
      Private::New(isolate_,                                                   \
                   String::NewFromOneByte(                                ...",1,1,env.cc,node.IsolateData.CreateProperties,,false,416,498,CreateProperties,,,23,void node.IsolateData.CreateProperties ()
76515,METHOD,env.cc:<global>,TYPE_DECL,"IsolateData::IsolateData(Isolate* isolate,
                         uv_loop_t* event_loop,
                         MultiIsolatePlatform* platform,
                         ArrayBufferAllocator* node_allocator,
                         const SnapshotData* snapshot_data)
    : isolate_(isolate),
      event_loop_(event_loop),
      node_allocator_(node_allocator == nullptr ? nullptr
                                                : node_allocator->GetImpl()),
      platform_(platform),
      snapshot_data_(snapshot_data) {
  options_.reset(
      new PerIsolateOptions(*(per_process::cli_options->per_isolate)));

  if (snapshot_data == nullptr) {
    CreateProperties();
  } else {
    DeserializeProperties(&snapshot_data->isolate_data_info);
  }
}",1,1,env.cc,node.IsolateData.IsolateData,,false,500,519,IsolateData,,,24,"ANY node.IsolateData.IsolateData (Isolate*,uv_loop_t*,MultiIsolatePlatform*,ArrayBufferAllocator*,SnapshotData*)"
76549,METHOD,env.cc:<global>,TYPE_DECL,"void IsolateData::MemoryInfo(MemoryTracker* tracker) const {
#define V(PropertyName, StringValue)                                           \
  tracker->TrackField(#PropertyName, PropertyName());
  PER_ISOLATE_SYMBOL_PROPERTIES(V)

  PER_ISOLATE_STRING_PROPERTIES(V)
#undef V

  tracker->TrackField(""async_wrap_providers"", async_wrap_providers_);

  if (node_allocator_ != nullptr) {
    tracker->TrackFieldWithSize(
        ""node_allocator"", sizeof(*node_allocator_), ""NodeArrayBufferAllocator"");
  }
  tracker->TrackFieldWithSize(
      ""platform"", sizeof(*platform_), ""MultiIsolatePlatform"");
  // TODO(joyeecheung): implement MemoryRetainer in the option classes.
}",1,1,env.cc,node.IsolateData.MemoryInfo,,false,521,538,MemoryInfo,,,25,void node.IsolateData.MemoryInfo (MemoryTracker*)
76587,METHOD,env.cc:<global>,TYPE_DECL,"void TrackingTraceStateObserver::UpdateTraceCategoryState() {
  if (!env_->owns_process_state() || !env_->can_call_into_js()) {
    // Ideally, wed have a consistent story that treats all threads/Environment
    // instances equally here. However, tracing is essentially global, and this
    // callback is called from whichever thread calls `StartTracing()` or
    // `StopTracing()`. The only way to do this in a threadsafe fashion
    // seems to be only tracking this from the main thread, and only allowing
    // these state modifications from the main thread.
    return;
  }

  if (env_->principal_realm() == nullptr) {
    return;
  }

  bool async_hooks_enabled = (*(TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED(
                                 TRACING_CATEGORY_NODE1(async_hooks)))) != 0;

  Isolate* isolate = env_->isolate();
  HandleScope handle_scope(isolate);
  Local<Function> cb = env_->trace_category_state_function();
  if (cb.IsEmpty())
    return;
  TryCatchScope try_catch(e...",1,1,env.cc,node.TrackingTraceStateObserver.UpdateTraceCategoryState,,false,540,567,UpdateTraceCategoryState,,,26,void node.TrackingTraceStateObserver.UpdateTraceCategoryState ()
76682,METHOD,env.cc:<global>,TYPE_DECL,"void Environment::AssignToContext(Local<v8::Context> context,
                                  Realm* realm,
                                  const ContextInfo& info) {
  context->SetAlignedPointerInEmbedderData(ContextEmbedderIndex::kEnvironment,
                                           this);
  context->SetAlignedPointerInEmbedderData(ContextEmbedderIndex::kRealm, realm);
  // Used to retrieve bindings
  context->SetAlignedPointerInEmbedderData(
      ContextEmbedderIndex::kBindingDataStoreIndex,
      realm->binding_data_store());

  // ContextifyContexts will update this to a pointer to the native object.
  context->SetAlignedPointerInEmbedderData(
      ContextEmbedderIndex::kContextifyContext, nullptr);

  // This must not be done before other context fields are initialized.
  ContextEmbedderTag::TagNodeContext(context);

#if HAVE_INSPECTOR
  inspector_agent()->ContextCreated(context, info);
#endif  // HAVE_INSPECTOR

  this->async_hooks()->InstallPromiseHooks(context);
  ...",1,1,env.cc,node.Environment.AssignToContext,,false,569,593,AssignToContext,,,27,"void node.Environment.AssignToContext (ANY,Realm*,ContextInfo)"
76739,METHOD,env.cc:<global>,TYPE_DECL,"void Environment::UnassignFromContext(Local<v8::Context> context) {
  if (!context.IsEmpty()) {
    context->SetAlignedPointerInEmbedderData(ContextEmbedderIndex::kEnvironment,
                                             nullptr);
    context->SetAlignedPointerInEmbedderData(ContextEmbedderIndex::kRealm,
                                             nullptr);
    context->SetAlignedPointerInEmbedderData(
        ContextEmbedderIndex::kBindingDataStoreIndex, nullptr);
    context->SetAlignedPointerInEmbedderData(
        ContextEmbedderIndex::kContextifyContext, nullptr);
  }
  UntrackContext(context);
}",1,1,env.cc,node.Environment.UnassignFromContext,,false,595,607,UnassignFromContext,,,28,void node.Environment.UnassignFromContext (ANY)
76785,METHOD,env.cc:<global>,TYPE_DECL,"void Environment::TryLoadAddon(
    const char* filename,
    int flags,
    const std::function<bool(binding::DLib*)>& was_loaded) {
  loaded_addons_.emplace_back(filename, flags);
  if (!was_loaded(&loaded_addons_.back())) {
    loaded_addons_.pop_back();
  }
}",1,1,env.cc,node.Environment.TryLoadAddon,,false,609,617,TryLoadAddon,,,29,"void node.Environment.TryLoadAddon (char*,int,ANY)"
76811,METHOD,env.cc:<global>,TYPE_DECL,"std::string Environment::GetCwd() {
  char cwd[PATH_MAX_BYTES];
  size_t size = PATH_MAX_BYTES;
  const int err = uv_cwd(cwd, &size);

  if (err == 0) {
    CHECK_GT(size, 0);
    return cwd;
  }

  // This can fail if the cwd is deleted. In that case, fall back to
  // exec_path.
  const std::string& exec_path = exec_path_;
  return exec_path.substr(0, exec_path.find_last_of(kPathSeparator));
}",1,1,env.cc,node.Environment.GetCwd,,false,619,633,GetCwd,,,30,string node.Environment.GetCwd ()
76852,METHOD,env.cc:<global>,TYPE_DECL,"void Environment::add_refs(int64_t diff) {
  task_queues_async_refs_ += diff;
  CHECK_GE(task_queues_async_refs_, 0);
  if (task_queues_async_refs_ == 0)
    uv_unref(reinterpret_cast<uv_handle_t*>(&task_queues_async_));
  else
    uv_ref(reinterpret_cast<uv_handle_t*>(&task_queues_async_));
}",1,1,env.cc,node.Environment.add_refs,,false,635,642,add_refs,,,31,void node.Environment.add_refs (int64_t)
76880,METHOD,env.cc:<global>,TYPE_DECL,"uv_buf_t Environment::allocate_managed_buffer(const size_t suggested_size) {
  NoArrayBufferZeroFillScope no_zero_fill_scope(isolate_data());
  std::unique_ptr<v8::BackingStore> bs =
      v8::ArrayBuffer::NewBackingStore(isolate(), suggested_size);
  uv_buf_t buf = uv_buf_init(static_cast<char*>(bs->Data()), bs->ByteLength());
  released_allocated_buffers_.emplace(buf.base, std::move(bs));
  return buf;
}",1,1,env.cc,node.Environment.allocate_managed_buffer,,false,644,651,allocate_managed_buffer,,,32,uv_buf_t node.Environment.allocate_managed_buffer (size_t)
76934,METHOD,env.cc:<global>,TYPE_DECL,"std::unique_ptr<v8::BackingStore> Environment::release_managed_buffer(
    const uv_buf_t& buf) {
  std::unique_ptr<v8::BackingStore> bs;
  if (buf.base != nullptr) {
    auto it = released_allocated_buffers_.find(buf.base);
    CHECK_NE(it, released_allocated_buffers_.end());
    bs = std::move(it->second);
    released_allocated_buffers_.erase(it);
  }
  return bs;
}",1,1,env.cc,node.Environment.release_managed_buffer,,false,653,663,release_managed_buffer,,,33,unique_ptr<v8::BackingStore> node.Environment.release_managed_buffer (uv_buf_t)
76987,METHOD,env.cc:<global>,TYPE_DECL,"std::string GetExecPath(const std::vector<std::string>& argv) {
  char exec_path_buf[2 * PATH_MAX];
  size_t exec_path_len = sizeof(exec_path_buf);
  std::string exec_path;
  if (uv_exepath(exec_path_buf, &exec_path_len) == 0) {
    exec_path = std::string(exec_path_buf, exec_path_len);
  } else if (argv.size() > 0) {
    exec_path = argv[0];
  }

  // On OpenBSD process.execPath will be relative unless we
  // get the full path before process.execPath is used.
#if defined(__OpenBSD__)
  uv_fs_t req;
  req.ptr = nullptr;
  if (0 ==
      uv_fs_realpath(nullptr, &req, exec_path.c_str(), nullptr)) {
    CHECK_NOT_NULL(req.ptr);
    exec_path = std::string(static_cast<char*>(req.ptr));
  }
  uv_fs_req_cleanup(&req);
#endif

  return exec_path;
}",1,1,env.cc,node.GetExecPath,,false,665,689,GetExecPath,,,34,string node.GetExecPath (ANY)
77032,METHOD,env.cc:<global>,TYPE_DECL,"Environment::Environment(IsolateData* isolate_data,
                         Isolate* isolate,
                         const std::vector<std::string>& args,
                         const std::vector<std::string>& exec_args,
                         const EnvSerializeInfo* env_info,
                         EnvironmentFlags::Flags flags,
                         ThreadId thread_id)
    : isolate_(isolate),
      isolate_data_(isolate_data),
      async_hooks_(isolate, MAYBE_FIELD_PTR(env_info, async_hooks)),
      immediate_info_(isolate, MAYBE_FIELD_PTR(env_info, immediate_info)),
      timeout_info_(isolate_, 1, MAYBE_FIELD_PTR(env_info, timeout_info)),
      tick_info_(isolate, MAYBE_FIELD_PTR(env_info, tick_info)),
      timer_base_(uv_now(isolate_data->event_loop())),
      exec_argv_(exec_args),
      argv_(args),
      exec_path_(GetExecPath(args)),
      exit_info_(
          isolate_, kExitInfoFieldCount, MAYBE_FIELD_PTR(env_info, exit_info)),
      should_abort_on_uncaugh...",1,1,env.cc,node.Environment.Environment,,false,691,831,Environment,,,35,"ANY node.Environment.Environment (IsolateData*,Isolate*,ANY,ANY,EnvSerializeInfo*,ANY,ThreadId)"
77410,METHOD,env.cc:<global>,TYPE_DECL,"void Environment::InitializeMainContext(Local<Context> context,
                                        const EnvSerializeInfo* env_info) {
  principal_realm_ = std::make_unique<PrincipalRealm>(
      this, context, MAYBE_FIELD_PTR(env_info, principal_realm));
  if (env_info != nullptr) {
    DeserializeProperties(env_info);
  }

  if (!options_->force_async_hooks_checks) {
    async_hooks_.no_force_checks();
  }

  // By default, always abort when --abort-on-uncaught-exception was passed.
  should_abort_on_uncaught_toggle_[0] = 1;

  // The process is not exiting by default.
  set_exiting(false);

  performance_state_->Mark(performance::NODE_PERFORMANCE_MILESTONE_ENVIRONMENT,
                           environment_start_);
  performance_state_->Mark(performance::NODE_PERFORMANCE_MILESTONE_NODE_START,
                           per_process::node_start_time);

  if (per_process::v8_initialized) {
    performance_state_->Mark(performance::NODE_PERFORMANCE_MILESTONE_V8_START,
         ...",1,1,env.cc,node.Environment.InitializeMainContext,,false,833,860,InitializeMainContext,,,36,"void node.Environment.InitializeMainContext (Local<Context>,EnvSerializeInfo*)"
77488,METHOD,env.cc:<global>,TYPE_DECL,"Environment::~Environment() {
  HandleScope handle_scope(isolate());
  Local<Context> ctx = context();

  if (Environment** interrupt_data = interrupt_data_.load()) {
    // There are pending RequestInterrupt() callbacks. Tell them not to run,
    // then force V8 to run interrupts by compiling and running an empty script
    // so as not to leak memory.
    *interrupt_data = nullptr;

    Isolate::AllowJavascriptExecutionScope allow_js_here(isolate());
    TryCatch try_catch(isolate());
    Context::Scope context_scope(ctx);

#ifdef DEBUG
    bool consistency_check = false;
    isolate()->RequestInterrupt([](Isolate*, void* data) {
      *static_cast<bool*>(data) = true;
    }, &consistency_check);
#endif

    Local<Script> script;
    if (Script::Compile(ctx, String::Empty(isolate())).ToLocal(&script))
      USE(script->Run(ctx));

    DCHECK(consistency_check);
  }

  // FreeEnvironment() should have set this.
  CHECK(is_stopping());

  if (heapsnapshot_near_heap_limit_callback_a...",1,1,env.cc,node.Environment.~Environment,,false,862,931,~Environment,,,37,ANY node.Environment.~Environment ()
77623,METHOD,env.cc:<global>,TYPE_DECL,"void Environment::InitializeLibuv() {
  HandleScope handle_scope(isolate());
  Context::Scope context_scope(context());

  CHECK_EQ(0, uv_timer_init(event_loop(), timer_handle()));
  uv_unref(reinterpret_cast<uv_handle_t*>(timer_handle()));

  CHECK_EQ(0, uv_check_init(event_loop(), immediate_check_handle()));
  uv_unref(reinterpret_cast<uv_handle_t*>(immediate_check_handle()));

  CHECK_EQ(0, uv_idle_init(event_loop(), immediate_idle_handle()));

  CHECK_EQ(0, uv_check_start(immediate_check_handle(), CheckImmediate));

  // Inform V8's CPU profiler when we're idle.  The profiler is sampling-based
  // but not all samples are created equal; mark the wall clock time spent in
  // epoll_wait() and friends so profiling tools can filter it out.  The samples
  // still end up in v8.log but with state=IDLE rather than state=EXTERNAL.
  CHECK_EQ(0, uv_prepare_init(event_loop(), &idle_prepare_handle_));
  CHECK_EQ(0, uv_check_init(event_loop(), &idle_check_handle_));

  CHECK_EQ(0, uv_async...",1,1,env.cc,node.Environment.InitializeLibuv,,false,933,984,InitializeLibuv,,,38,void node.Environment.InitializeLibuv ()
77720,METHOD,env.cc:<global>,TYPE_DECL,"void Environment::ExitEnv(StopFlags::Flags flags) {
  // Should not access non-thread-safe methods here.
  set_stopping(true);
  if ((flags & StopFlags::kDoNotTerminateIsolate) == 0)
    isolate_->TerminateExecution();
  SetImmediateThreadsafe([](Environment* env) {
    env->set_can_call_into_js(false);
    uv_stop(env->event_loop());
  });
}",1,1,env.cc,node.Environment.ExitEnv,,false,986,995,ExitEnv,,,39,void node.Environment.ExitEnv (ANY)
77742,METHOD,env.cc:<global>,TYPE_DECL,"void Environment::RegisterHandleCleanups() {
  HandleCleanupCb close_and_finish = [](Environment* env, uv_handle_t* handle,
                                        void* arg) {
    handle->data = env;

    env->CloseHandle(handle, [](uv_handle_t* handle) {
#ifdef DEBUG
      memset(handle, 0xab, uv_handle_size(handle->type));
#endif
    });
  };

  auto register_handle = [&](uv_handle_t* handle) {
    RegisterHandleCleanup(handle, close_and_finish, nullptr);
  };
  register_handle(reinterpret_cast<uv_handle_t*>(timer_handle()));
  register_handle(reinterpret_cast<uv_handle_t*>(immediate_check_handle()));
  register_handle(reinterpret_cast<uv_handle_t*>(immediate_idle_handle()));
  register_handle(reinterpret_cast<uv_handle_t*>(&idle_prepare_handle_));
  register_handle(reinterpret_cast<uv_handle_t*>(&idle_check_handle_));
  register_handle(reinterpret_cast<uv_handle_t*>(&task_queues_async_));
}",1,1,env.cc,node.Environment.RegisterHandleCleanups,,false,997,1018,RegisterHandleCleanups,,,40,void node.Environment.RegisterHandleCleanups ()
77780,METHOD,env.cc:<global>,TYPE_DECL,"void Environment::CleanupHandles() {
  {
    Mutex::ScopedLock lock(native_immediates_threadsafe_mutex_);
    task_queues_async_initialized_ = false;
  }

  Isolate::DisallowJavascriptExecutionScope disallow_js(isolate(),
      Isolate::DisallowJavascriptExecutionScope::THROW_ON_FAILURE);

  RunAndClearNativeImmediates(true /* skip unrefed SetImmediate()s */);

  for (ReqWrapBase* request : req_wrap_queue_)
    request->Cancel();

  for (HandleWrap* handle : handle_wrap_queue_)
    handle->Close();

  for (HandleCleanup& hc : handle_cleanup_queue_)
    hc.cb_(this, hc.handle_, hc.arg_);
  handle_cleanup_queue_.clear();

  while (handle_cleanup_waiting_ != 0 ||
         request_waiting_ != 0 ||
         !handle_wrap_queue_.IsEmpty()) {
    uv_run(event_loop(), UV_RUN_ONCE);
  }
}",1,1,env.cc,node.Environment.CleanupHandles,,false,1020,1046,CleanupHandles,,,41,void node.Environment.CleanupHandles ()
77851,METHOD,env.cc:<global>,TYPE_DECL,"void Environment::StartProfilerIdleNotifier() {
  uv_prepare_start(&idle_prepare_handle_, [](uv_prepare_t* handle) {
    Environment* env = ContainerOf(&Environment::idle_prepare_handle_, handle);
    env->isolate()->SetIdle(true);
  });
  uv_check_start(&idle_check_handle_, [](uv_check_t* handle) {
    Environment* env = ContainerOf(&Environment::idle_check_handle_, handle);
    env->isolate()->SetIdle(false);
  });
}",1,1,env.cc,node.Environment.StartProfilerIdleNotifier,,false,1048,1057,StartProfilerIdleNotifier,,,42,void node.Environment.StartProfilerIdleNotifier ()
77863,METHOD,env.cc:<global>,TYPE_DECL,"void Environment::PrintSyncTrace() const {
  if (!trace_sync_io_) return;

  HandleScope handle_scope(isolate());

  fprintf(
      stderr, ""(node:%d) WARNING: Detected use of sync API\n"", uv_os_getpid());
  PrintStackTrace(isolate(),
                  StackTrace::CurrentStackTrace(
                      isolate(), stack_trace_limit(), StackTrace::kDetailed));
}",1,1,env.cc,node.Environment.PrintSyncTrace,,false,1059,1069,PrintSyncTrace,,,43,void node.Environment.PrintSyncTrace ()
77890,METHOD,env.cc:<global>,TYPE_DECL,"MaybeLocal<Value> Environment::RunSnapshotSerializeCallback() const {
  EscapableHandleScope handle_scope(isolate());
  if (!snapshot_serialize_callback().IsEmpty()) {
    Context::Scope context_scope(context());
    return handle_scope.EscapeMaybe(snapshot_serialize_callback()->Call(
        context(), v8::Undefined(isolate()), 0, nullptr));
  }
  return handle_scope.Escape(Undefined(isolate()));
}",1,1,env.cc,node.Environment.RunSnapshotSerializeCallback,,false,1071,1079,RunSnapshotSerializeCallback,,,44,MaybeLocal<Value> node.Environment.RunSnapshotSerializeCallback ()
77931,METHOD,env.cc:<global>,TYPE_DECL,"MaybeLocal<Value> Environment::RunSnapshotDeserializeMain() const {
  EscapableHandleScope handle_scope(isolate());
  if (!snapshot_deserialize_main().IsEmpty()) {
    Context::Scope context_scope(context());
    return handle_scope.EscapeMaybe(snapshot_deserialize_main()->Call(
        context(), v8::Undefined(isolate()), 0, nullptr));
  }
  return handle_scope.Escape(Undefined(isolate()));
}",1,1,env.cc,node.Environment.RunSnapshotDeserializeMain,,false,1081,1089,RunSnapshotDeserializeMain,,,45,MaybeLocal<Value> node.Environment.RunSnapshotDeserializeMain ()
77972,METHOD,env.cc:<global>,TYPE_DECL,"void Environment::RunCleanup() {
  started_cleanup_ = true;
  TRACE_EVENT0(TRACING_CATEGORY_NODE1(environment), ""RunCleanup"");
  // Only BaseObject's cleanups are registered as per-realm cleanup hooks now.
  // Defer the BaseObject cleanup after handles are cleaned up.
  CleanupHandles();

  while (!cleanup_queue_.empty() || principal_realm_->HasCleanupHooks() ||
         native_immediates_.size() > 0 ||
         native_immediates_threadsafe_.size() > 0 ||
         native_immediates_interrupts_.size() > 0) {
    // TODO(legendecas): cleanup handles in per-realm cleanup hooks as well.
    principal_realm_->RunCleanup();
    cleanup_queue_.Drain();
    CleanupHandles();
  }

  for (const int fd : unmanaged_fds_) {
    uv_fs_t close_req;
    uv_fs_close(nullptr, &close_req, fd, nullptr);
    uv_fs_req_cleanup(&close_req);
  }
}",1,1,env.cc,node.Environment.RunCleanup,,false,1091,1113,RunCleanup,,,46,void node.Environment.RunCleanup ()
78040,METHOD,env.cc:<global>,TYPE_DECL,"void Environment::RunAtExitCallbacks() {
  TRACE_EVENT0(TRACING_CATEGORY_NODE1(environment), ""AtExit"");
  for (ExitCallback at_exit : at_exit_functions_) {
    at_exit.cb_(at_exit.arg_);
  }
  at_exit_functions_.clear();
}",1,1,env.cc,node.Environment.RunAtExitCallbacks,,false,1115,1121,RunAtExitCallbacks,,,47,void node.Environment.RunAtExitCallbacks ()
78063,METHOD,env.cc:<global>,TYPE_DECL,"void Environment::AtExit(void (*cb)(void* arg), void* arg) {
  at_exit_functions_.push_front(ExitCallback{cb, arg});
}",1,1,env.cc,node.Environment.AtExit,,false,1123,1125,AtExit,,,48,"void node.Environment.AtExit (void,void*)"
78077,METHOD,env.cc:<global>,TYPE_DECL,"void Environment::RunAndClearInterrupts() {
  while (native_immediates_interrupts_.size() > 0) {
    NativeImmediateQueue queue;
    {
      Mutex::ScopedLock lock(native_immediates_threadsafe_mutex_);
      queue.ConcatMove(std::move(native_immediates_interrupts_));
    }
    DebugSealHandleScope seal_handle_scope(isolate());

    while (auto head = queue.Shift())
      head->Call(this);
  }
}",1,1,env.cc,node.Environment.RunAndClearInterrupts,,false,1127,1139,RunAndClearInterrupts,,,49,void node.Environment.RunAndClearInterrupts ()
78112,METHOD,env.cc:<global>,TYPE_DECL,"void Environment::RunAndClearNativeImmediates(bool only_refed) {
  TRACE_EVENT0(TRACING_CATEGORY_NODE1(environment),
               ""RunAndClearNativeImmediates"");
  HandleScope handle_scope(isolate_);
  // In case the Isolate is no longer accessible just use an empty Local. This
  // is not an issue for InternalCallbackScope as this case is already handled
  // in its constructor but we avoid calls into v8 which can crash the process
  // in debug builds.
  Local<Object> obj =
      can_call_into_js() ? Object::New(isolate_) : Local<Object>();
  InternalCallbackScope cb_scope(this, obj, {0, 0});

  size_t ref_count = 0;

  // Handle interrupts first. These functions are not allowed to throw
  // exceptions, so we do not need to handle that.
  RunAndClearInterrupts();

  auto drain_list = [&](NativeImmediateQueue* queue) {
    TryCatchScope try_catch(this);
    DebugSealHandleScope seal_handle_scope(isolate());
    while (auto head = queue->Shift()) {
      bool is_refed = head->fla...",1,1,env.cc,node.Environment.RunAndClearNativeImmediates,,false,1141,1201,RunAndClearNativeImmediates,,,50,void node.Environment.RunAndClearNativeImmediates (bool)
78198,METHOD,env.cc:<global>,TYPE_DECL,"void Environment::RequestInterruptFromV8() {
  // The Isolate may outlive the Environment, so some logic to handle the
  // situation in which the Environment is destroyed before the handler runs
  // is required.

  // We allocate a new pointer to a pointer to this Environment instance, and
  // try to set it as interrupt_data_. If interrupt_data_ was already set, then
  // callbacks are already scheduled to run and we can delete our own pointer
  // and just return. If it was nullptr previously, the Environment** is stored;
  // ~Environment sets the Environment* contained in it to nullptr, so that
  // the callback can check whether ~Environment has already run and it is thus
  // not safe to access the Environment instance itself.
  Environment** interrupt_data = new Environment*(this);
  Environment** dummy = nullptr;
  if (!interrupt_data_.compare_exchange_strong(dummy, interrupt_data)) {
    delete interrupt_data;
    return;  // Already scheduled.
  }

  isolate()->RequestIn...",1,1,env.cc,node.Environment.RequestInterruptFromV8,,false,1203,1234,RequestInterruptFromV8,,,51,void node.Environment.RequestInterruptFromV8 ()
78230,METHOD,env.cc:<global>,TYPE_DECL,"void Environment::ScheduleTimer(int64_t duration_ms) {
  if (started_cleanup_) return;
  uv_timer_start(timer_handle(), RunTimers, duration_ms, 0);
}",1,1,env.cc,node.Environment.ScheduleTimer,,false,1236,1239,ScheduleTimer,,,52,void node.Environment.ScheduleTimer (int64_t)
78244,METHOD,env.cc:<global>,TYPE_DECL,"void Environment::ToggleTimerRef(bool ref) {
  if (started_cleanup_) return;

  if (ref) {
    uv_ref(reinterpret_cast<uv_handle_t*>(timer_handle()));
  } else {
    uv_unref(reinterpret_cast<uv_handle_t*>(timer_handle()));
  }
}",1,1,env.cc,node.Environment.ToggleTimerRef,,false,1241,1249,ToggleTimerRef,,,53,void node.Environment.ToggleTimerRef (bool)
78266,METHOD,env.cc:<global>,TYPE_DECL,"void Environment::RunTimers(uv_timer_t* handle) {
  Environment* env = Environment::from_timer_handle(handle);
  TRACE_EVENT0(TRACING_CATEGORY_NODE1(environment), ""RunTimers"");

  if (!env->can_call_into_js())
    return;

  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Object> process = env->process_object();
  InternalCallbackScope scope(env, process, {0, 0});

  Local<Function> cb = env->timers_callback_function();
  MaybeLocal<Value> ret;
  Local<Value> arg = env->GetNow();
  // This code will loop until all currently due timers will process. It is
  // impossible for us to end up in an infinite loop due to how the JS-side
  // is structured.
  do {
    TryCatchScope try_catch(env);
    try_catch.SetVerbose(true);
    ret = cb->Call(env->context(), process, 1, &arg);
  } while (ret.IsEmpty() && env->can_call_into_js());

  // NOTE(apapirovski): If it ever becomes possible that `call_into_js` above
  // is reset back to `true` ...",1,1,env.cc,node.Environment.RunTimers,,false,1251,1309,RunTimers,,,54,void node.Environment.RunTimers (uv_timer_t*)
78454,METHOD,env.cc:<global>,TYPE_DECL,"void Environment::CheckImmediate(uv_check_t* handle) {
  Environment* env = Environment::from_immediate_check_handle(handle);
  TRACE_EVENT0(TRACING_CATEGORY_NODE1(environment), ""CheckImmediate"");

  HandleScope scope(env->isolate());
  Context::Scope context_scope(env->context());

  env->RunAndClearNativeImmediates();

  if (env->immediate_info()->count() == 0 || !env->can_call_into_js())
    return;

  do {
    MakeCallback(env->isolate(),
                 env->process_object(),
                 env->immediate_callback_function(),
                 0,
                 nullptr,
                 {0, 0}).ToLocalChecked();
  } while (env->immediate_info()->has_outstanding() && env->can_call_into_js());

  if (env->immediate_info()->ref_count() == 0)
    env->ToggleImmediateRef(false);
}",1,1,env.cc,node.Environment.CheckImmediate,,false,1312,1335,CheckImmediate,,,55,void node.Environment.CheckImmediate (uv_check_t*)
78556,METHOD,env.cc:<global>,TYPE_DECL,"void Environment::ToggleImmediateRef(bool ref) {
  if (started_cleanup_) return;

  if (ref) {
    // Idle handle is needed only to stop the event loop from blocking in poll.
    uv_idle_start(immediate_idle_handle(), [](uv_idle_t*){ });
  } else {
    uv_idle_stop(immediate_idle_handle());
  }
}",1,1,env.cc,node.Environment.ToggleImmediateRef,,false,1337,1346,ToggleImmediateRef,,,56,void node.Environment.ToggleImmediateRef (bool)
78574,METHOD,env.cc:<global>,TYPE_DECL,"uint64_t Environment::GetNowUint64() {
  uv_update_time(event_loop());
  uint64_t now = uv_now(event_loop());
  CHECK_GE(now, timer_base());
  now -= timer_base();
  return now;
}",1,1,env.cc,node.Environment.GetNowUint64,,false,1348,1354,GetNowUint64,,,57,uint64_t node.Environment.GetNowUint64 ()
78592,METHOD,env.cc:<global>,TYPE_DECL,"Local<Value> Environment::GetNow() {
  uint64_t now = GetNowUint64();
  if (now <= 0xffffffff)
    return Integer::NewFromUnsigned(isolate(), static_cast<uint32_t>(now));
  else
    return Number::New(isolate(), static_cast<double>(now));
}",1,1,env.cc,node.Environment.GetNow,,false,1356,1362,GetNow,,,58,Local<Value> node.Environment.GetNow ()
78625,METHOD,env.cc:<global>,TYPE_DECL,"void CollectExceptionInfo(Environment* env,
                          Local<Object> obj,
                          int errorno,
                          const char* err_string,
                          const char* syscall,
                          const char* message,
                          const char* path,
                          const char* dest) {
  obj->Set(env->context(),
           env->errno_string(),
           Integer::New(env->isolate(), errorno)).Check();

  obj->Set(env->context(), env->code_string(),
           OneByteString(env->isolate(), err_string)).Check();

  if (message != nullptr) {
    obj->Set(env->context(), env->message_string(),
             OneByteString(env->isolate(), message)).Check();
  }

  Local<Value> path_buffer;
  if (path != nullptr) {
    path_buffer =
      Buffer::Copy(env->isolate(), path, strlen(path)).ToLocalChecked();
    obj->Set(env->context(), env->path_string(), path_buffer).Check();
  }

  Local<Value> dest_buffer;
  if (dest...",1,1,env.cc,node.CollectExceptionInfo,,false,1364,1402,CollectExceptionInfo,,,59,"void node.CollectExceptionInfo (Environment*,Local<Object>,int,char*,char*,char*,char*,char*)"
78818,METHOD,env.cc:<global>,TYPE_DECL,"void Environment::CollectUVExceptionInfo(Local<Value> object,
                                         int errorno,
                                         const char* syscall,
                                         const char* message,
                                         const char* path,
                                         const char* dest) {
  if (!object->IsObject() || errorno == 0)
    return;

  Local<Object> obj = object.As<Object>();
  const char* err_string = uv_err_name(errorno);

  if (message == nullptr || message[0] == '\0') {
    message = uv_strerror(errorno);
  }

  node::CollectExceptionInfo(this, obj, errorno, err_string,
                             syscall, message, path, dest);
}",1,1,env.cc,node.Environment.CollectUVExceptionInfo,,false,1404,1422,CollectUVExceptionInfo,,,60,"void node.Environment.CollectUVExceptionInfo (Local<Value>,int,char*,char*,char*,char*)"
78882,METHOD,env.cc:<global>,TYPE_DECL,"ImmediateInfo::ImmediateInfo(Isolate* isolate, const SerializeInfo* info)
    : fields_(isolate, kFieldsCount, MAYBE_FIELD_PTR(info, fields)) {}",1,70,env.cc,node.ImmediateInfo.ImmediateInfo,,false,1424,1425,ImmediateInfo,,,61,"ANY node.ImmediateInfo.ImmediateInfo (Isolate*,SerializeInfo*)"
78888,METHOD,env.cc:<global>,TYPE_DECL,"ImmediateInfo::SerializeInfo ImmediateInfo::Serialize(
    Local<Context> context, SnapshotCreator* creator) {
  return {fields_.Serialize(context, creator)};
}",1,1,env.cc,node.ImmediateInfo.Serialize,,false,1427,1430,Serialize,,,62,"SerializeInfo node.ImmediateInfo.Serialize (Local<Context>,SnapshotCreator*)"
78895,METHOD,env.cc:<global>,TYPE_DECL,"void ImmediateInfo::Deserialize(Local<Context> context) {
  fields_.Deserialize(context);
}",1,1,env.cc,node.ImmediateInfo.Deserialize,,false,1432,1434,Deserialize,,,63,void node.ImmediateInfo.Deserialize (Local<Context>)
78905,METHOD,env.cc:<global>,TYPE_DECL,"std::ostream& operator<<(std::ostream& output,
                         const ImmediateInfo::SerializeInfo& i) {
  output << ""{ "" << i.fields << "" }"";
  return output;
}",1,1,env.cc,node.operator <<,,false,1436,1440,operator <<,,,64,"ostream node.operator << (ANY,ANY)"
78922,METHOD,env.cc:<global>,TYPE_DECL,"void ImmediateInfo::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""fields"", fields_);
}",1,1,env.cc,node.ImmediateInfo.MemoryInfo,,false,1442,1444,MemoryInfo,,,65,void node.ImmediateInfo.MemoryInfo (MemoryTracker*)
78933,METHOD,env.cc:<global>,TYPE_DECL,"TickInfo::SerializeInfo TickInfo::Serialize(Local<Context> context,
                                            SnapshotCreator* creator) {
  return {fields_.Serialize(context, creator)};
}",1,1,env.cc,node.TickInfo.Serialize,,false,1446,1449,Serialize,,,66,"SerializeInfo node.TickInfo.Serialize (Local<Context>,SnapshotCreator*)"
78940,METHOD,env.cc:<global>,TYPE_DECL,"void TickInfo::Deserialize(Local<Context> context) {
  fields_.Deserialize(context);
}",1,1,env.cc,node.TickInfo.Deserialize,,false,1451,1453,Deserialize,,,67,void node.TickInfo.Deserialize (Local<Context>)
78950,METHOD,env.cc:<global>,TYPE_DECL,"std::ostream& operator<<(std::ostream& output,
                         const TickInfo::SerializeInfo& i) {
  output << ""{ "" << i.fields << "" }"";
  return output;
}",1,1,env.cc,node.operator <<,,false,1455,1459,operator <<,,,68,"ostream node.operator << (ANY,ANY)"
78967,METHOD,env.cc:<global>,TYPE_DECL,"void TickInfo::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""fields"", fields_);
}",1,1,env.cc,node.TickInfo.MemoryInfo,,false,1461,1463,MemoryInfo,,,69,void node.TickInfo.MemoryInfo (MemoryTracker*)
78978,METHOD,env.cc:<global>,TYPE_DECL,"TickInfo::TickInfo(Isolate* isolate, const SerializeInfo* info)
    : fields_(
          isolate, kFieldsCount, info == nullptr ? nullptr : &(info->fields)) {}",1,80,env.cc,node.TickInfo.TickInfo,,false,1465,1467,TickInfo,,,70,"ANY node.TickInfo.TickInfo (Isolate*,SerializeInfo*)"
78984,METHOD,env.cc:<global>,TYPE_DECL,"AsyncHooks::AsyncHooks(Isolate* isolate, const SerializeInfo* info)
    : async_ids_stack_(isolate, 16 * 2, MAYBE_FIELD_PTR(info, async_ids_stack)),
      fields_(isolate, kFieldsCount, MAYBE_FIELD_PTR(info, fields)),
      async_id_fields_(
          isolate, kUidFieldsCount, MAYBE_FIELD_PTR(info, async_id_fields)),
      info_(info) {
  HandleScope handle_scope(isolate);
  if (info == nullptr) {
    clear_async_id_stack();

    // Always perform async_hooks checks, not just when async_hooks is enabled.
    // TODO(AndreasMadsen): Consider removing this for LTS releases.
    // See discussion in https://github.com/nodejs/node/pull/15454
    // When removing this, do it by reverting the commit. Otherwise the test
    // and flag changes won't be included.
    fields_[kCheck] = 1;

    // kDefaultTriggerAsyncId should be -1, this indicates that there is no
    // specified default value and it should fallback to the executionAsyncId.
    // 0 is not used as the magic value, because t...",1,1,env.cc,node.AsyncHooks.AsyncHooks,,false,1469,1496,AsyncHooks,,,71,"ANY node.AsyncHooks.AsyncHooks (Isolate*,SerializeInfo*)"
79019,METHOD,env.cc:<global>,TYPE_DECL,"void AsyncHooks::Deserialize(Local<Context> context) {
  async_ids_stack_.Deserialize(context);
  fields_.Deserialize(context);
  async_id_fields_.Deserialize(context);

  Local<Array> js_execution_async_resources;
  if (info_->js_execution_async_resources != 0) {
    js_execution_async_resources =
        context->GetDataFromSnapshotOnce<Array>(
            info_->js_execution_async_resources).ToLocalChecked();
  } else {
    js_execution_async_resources = Array::New(context->GetIsolate());
  }
  js_execution_async_resources_.Reset(
      context->GetIsolate(), js_execution_async_resources);

  // The native_execution_async_resources_ field requires v8::Local<> instances
  // for async calls whose resources were on the stack as JS objects when they
  // were entered. We cannot recreate this here; however, storing these values
  // on the JS equivalent gives the same result, so we do that instead.
  for (size_t i = 0; i < info_->native_execution_async_resources.size(); ++i) {
    if...",1,1,env.cc,node.AsyncHooks.Deserialize,,false,1498,1527,Deserialize,,,72,void node.AsyncHooks.Deserialize (Local<Context>)
79146,METHOD,env.cc:<global>,TYPE_DECL,"std::ostream& operator<<(std::ostream& output,
                         const AsyncHooks::SerializeInfo& i) {
  output << ""{\n""
         << ""  "" << i.async_ids_stack << "",  // async_ids_stack\n""
         << ""  "" << i.fields << "",  // fields\n""
         << ""  "" << i.async_id_fields << "",  // async_id_fields\n""
         << ""  "" << i.js_execution_async_resources
         << "",  // js_execution_async_resources\n""
         << ""  "" << i.native_execution_async_resources
         << "",  // native_execution_async_resources\n""
         << ""}"";
  return output;
}",1,1,env.cc,node.operator <<,,false,1529,1541,operator <<,,,73,"ostream node.operator << (ANY,ANY)"
79199,METHOD,env.cc:<global>,TYPE_DECL,"AsyncHooks::SerializeInfo AsyncHooks::Serialize(Local<Context> context,
                                                SnapshotCreator* creator) {
  SerializeInfo info;
  // TODO(joyeecheung): some of these probably don't need to be serialized.
  info.async_ids_stack = async_ids_stack_.Serialize(context, creator);
  info.fields = fields_.Serialize(context, creator);
  info.async_id_fields = async_id_fields_.Serialize(context, creator);
  if (!js_execution_async_resources_.IsEmpty()) {
    info.js_execution_async_resources = creator->AddData(
        context, js_execution_async_resources_.Get(context->GetIsolate()));
    CHECK_NE(info.js_execution_async_resources, 0);
  } else {
    info.js_execution_async_resources = 0;
  }

  info.native_execution_async_resources.resize(
      native_execution_async_resources_.size());
  for (size_t i = 0; i < native_execution_async_resources_.size(); i++) {
    info.native_execution_async_resources[i] =
        native_execution_async_resources_[i...",1,1,env.cc,node.AsyncHooks.Serialize,,false,1543,1576,Serialize,,,74,"SerializeInfo node.AsyncHooks.Serialize (Local<Context>,SnapshotCreator*)"
79349,METHOD,env.cc:<global>,TYPE_DECL,"void AsyncHooks::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""async_ids_stack"", async_ids_stack_);
  tracker->TrackField(""fields"", fields_);
  tracker->TrackField(""async_id_fields"", async_id_fields_);
  tracker->TrackField(""js_promise_hooks"", js_promise_hooks_);
}",1,1,env.cc,node.AsyncHooks.MemoryInfo,,false,1578,1583,MemoryInfo,,,75,void node.AsyncHooks.MemoryInfo (MemoryTracker*)
79378,METHOD,env.cc:<global>,TYPE_DECL,"void AsyncHooks::grow_async_ids_stack() {
  async_ids_stack_.reserve(async_ids_stack_.Length() * 3);

  env()->async_hooks_binding()->Set(
      env()->context(),
      env()->async_ids_stack_string(),
      async_ids_stack_.GetJSArray()).Check();
}",1,1,env.cc,node.AsyncHooks.grow_async_ids_stack,,false,1585,1592,grow_async_ids_stack,,,76,void node.AsyncHooks.grow_async_ids_stack ()
79414,METHOD,env.cc:<global>,TYPE_DECL,"void AsyncHooks::FailWithCorruptedAsyncStack(double expected_async_id) {
  fprintf(stderr,
          ""Error: async hook stack has become corrupted (""
          ""actual: %.f, expected: %.f)\n"",
          async_id_fields_.GetValue(kExecutionAsyncId),
          expected_async_id);
  DumpBacktrace(stderr);
  fflush(stderr);
  // TODO(joyeecheung): should this exit code be more specific?
  if (!env()->abort_on_uncaught_exception()) Exit(ExitCode::kGenericUserError);
  fprintf(stderr, ""\n"");
  fflush(stderr);
  ABORT_NO_BACKTRACE();
}",1,1,env.cc,node.AsyncHooks.FailWithCorruptedAsyncStack,,false,1594,1607,FailWithCorruptedAsyncStack,,,77,void node.AsyncHooks.FailWithCorruptedAsyncStack (double)
79448,METHOD,env.cc:<global>,TYPE_DECL,"void Environment::Exit(ExitCode exit_code) {
  if (options()->trace_exit) {
    HandleScope handle_scope(isolate());
    Isolate::DisallowJavascriptExecutionScope disallow_js(
        isolate(), Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);

    if (is_main_thread()) {
      fprintf(stderr, ""(node:%d) "", uv_os_getpid());
    } else {
      fprintf(stderr, ""(node:%d, thread:%"" PRIu64 "") "",
              uv_os_getpid(), thread_id());
    }

    fprintf(stderr,
            ""WARNING: Exited the environment with code %d\n"",
            static_cast<int>(exit_code));
    PrintStackTrace(isolate(),
                    StackTrace::CurrentStackTrace(
                        isolate(), stack_trace_limit(), StackTrace::kDetailed));
  }
  process_exit_handler_(this, exit_code);
}",1,1,env.cc,node.Environment.Exit,,false,1609,1630,Exit,,,78,void node.Environment.Exit (ExitCode)
79499,METHOD,env.cc:<global>,TYPE_DECL,"void Environment::stop_sub_worker_contexts() {
  DCHECK_EQ(Isolate::GetCurrent(), isolate());

  while (!sub_worker_contexts_.empty()) {
    Worker* w = *sub_worker_contexts_.begin();
    remove_sub_worker_context(w);
    w->Exit(ExitCode::kGenericUserError);
    w->JoinThread();
  }
}",1,1,env.cc,node.Environment.stop_sub_worker_contexts,,false,1632,1641,stop_sub_worker_contexts,,,79,void node.Environment.stop_sub_worker_contexts ()
79537,METHOD,env.cc:<global>,TYPE_DECL,"Environment* Environment::worker_parent_env() const {
  if (worker_context() == nullptr) return nullptr;
  return worker_context()->env();
}",1,1,env.cc,node.Environment.worker_parent_env,,false,1643,1646,worker_parent_env,,,80,Environment node.Environment.worker_parent_env ()
79553,METHOD,env.cc:<global>,TYPE_DECL,"void Environment::AddUnmanagedFd(int fd) {
  if (!tracks_unmanaged_fds()) return;
  auto result = unmanaged_fds_.insert(fd);
  if (!result.second) {
    ProcessEmitWarning(
        this, ""File descriptor %d opened in unmanaged mode twice"", fd);
  }
}",1,1,env.cc,node.Environment.AddUnmanagedFd,,false,1648,1655,AddUnmanagedFd,,,81,void node.Environment.AddUnmanagedFd (int)
79581,METHOD,env.cc:<global>,TYPE_DECL,"void Environment::RemoveUnmanagedFd(int fd) {
  if (!tracks_unmanaged_fds()) return;
  size_t removed_count = unmanaged_fds_.erase(fd);
  if (removed_count == 0) {
    ProcessEmitWarning(
        this, ""File descriptor %d closed but not opened in unmanaged mode"", fd);
  }
}",1,1,env.cc,node.Environment.RemoveUnmanagedFd,,false,1657,1664,RemoveUnmanagedFd,,,82,void node.Environment.RemoveUnmanagedFd (int)
79608,METHOD,env.cc:<global>,TYPE_DECL,"void Environment::PrintInfoForSnapshotIfDebug() {
  if (enabled_debug_list()->enabled(DebugCategory::MKSNAPSHOT)) {
    fprintf(stderr, ""At the exit of the Environment:\n"");
    principal_realm()->PrintInfoForSnapshot();
  }
}",1,1,env.cc,node.Environment.PrintInfoForSnapshotIfDebug,,false,1666,1671,PrintInfoForSnapshotIfDebug,,,83,void node.Environment.PrintInfoForSnapshotIfDebug ()
79628,METHOD,env.cc:<global>,TYPE_DECL,"EnvSerializeInfo Environment::Serialize(SnapshotCreator* creator) {
  EnvSerializeInfo info;
  Local<Context> ctx = context();

  info.async_hooks = async_hooks_.Serialize(ctx, creator);
  info.immediate_info = immediate_info_.Serialize(ctx, creator);
  info.timeout_info = timeout_info_.Serialize(ctx, creator);
  info.tick_info = tick_info_.Serialize(ctx, creator);
  info.performance_state = performance_state_->Serialize(ctx, creator);
  info.exit_info = exit_info_.Serialize(ctx, creator);
  info.stream_base_state = stream_base_state_.Serialize(ctx, creator);
  info.should_abort_on_uncaught_toggle =
      should_abort_on_uncaught_toggle_.Serialize(ctx, creator);

  info.principal_realm = principal_realm_->Serialize(creator);
  // For now we only support serialization of the main context.
  // TODO(joyeecheung): support de/serialization of vm contexts.
  CHECK_EQ(contexts_.size(), 1);
  CHECK_EQ(contexts_[0], context());
  return info;
}",1,1,env.cc,node.Environment.Serialize,,false,1673,1693,Serialize,,,84,EnvSerializeInfo node.Environment.Serialize (SnapshotCreator*)
79743,METHOD,env.cc:<global>,TYPE_DECL,"void Environment::EnqueueDeserializeRequest(DeserializeRequestCallback cb,
                                            Local<Object> holder,
                                            int index,
                                            InternalFieldInfoBase* info) {
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  DeserializeRequest request{cb, {isolate(), holder}, index, info};
  deserialize_requests_.push_back(std::move(request));
}",1,1,env.cc,node.Environment.EnqueueDeserializeRequest,,false,1695,1702,EnqueueDeserializeRequest,,,85,"void node.Environment.EnqueueDeserializeRequest (DeserializeRequestCallback,Local<Object>,int,InternalFieldInfoBase*)"
79775,METHOD,env.cc:<global>,TYPE_DECL,"void Environment::RunDeserializeRequests() {
  HandleScope scope(isolate());
  Local<Context> ctx = context();
  Isolate* is = isolate();
  while (!deserialize_requests_.empty()) {
    DeserializeRequest request(std::move(deserialize_requests_.front()));
    deserialize_requests_.pop_front();
    Local<Object> holder = request.holder.Get(is);
    request.cb(ctx, holder, request.index, request.info);
    request.holder.Reset();
    request.info->Delete();
  }
}",1,1,env.cc,node.Environment.RunDeserializeRequests,,false,1704,1716,RunDeserializeRequests,,,86,void node.Environment.RunDeserializeRequests ()
79851,METHOD,env.cc:<global>,TYPE_DECL,"void Environment::DeserializeProperties(const EnvSerializeInfo* info) {
  Local<Context> ctx = context();

  if (enabled_debug_list_.enabled(DebugCategory::MKSNAPSHOT)) {
    fprintf(stderr, ""deserializing EnvSerializeInfo...\n"");
    std::cerr << *info << ""\n"";
  }

  // Deserialize the realm's properties before running the deserialize
  // requests as the requests may need to access the realm's properties.
  principal_realm_->DeserializeProperties(&info->principal_realm);
  RunDeserializeRequests();

  async_hooks_.Deserialize(ctx);
  immediate_info_.Deserialize(ctx);
  timeout_info_.Deserialize(ctx);
  tick_info_.Deserialize(ctx);
  performance_state_->Deserialize(ctx);
  exit_info_.Deserialize(ctx);
  stream_base_state_.Deserialize(ctx);
  should_abort_on_uncaught_toggle_.Deserialize(ctx);
}",1,1,env.cc,node.Environment.DeserializeProperties,,false,1718,1739,DeserializeProperties,,,87,void node.Environment.DeserializeProperties (EnvSerializeInfo*)
79932,METHOD,env.cc:<global>,TYPE_DECL,"uint64_t GuessMemoryAvailableToTheProcess() {
  uint64_t free_in_system = uv_get_free_memory();
  size_t allowed = uv_get_constrained_memory();
  if (allowed == 0) {
    return free_in_system;
  }
  size_t rss;
  int err = uv_resident_set_memory(&rss);
  if (err) {
    return free_in_system;
  }
  if (allowed < rss) {
    // Something is probably wrong. Fallback to the free memory.
    return free_in_system;
  }
  // There may still be room for swap, but we will just leave it here.
  return allowed - rss;
}",1,1,env.cc,node.GuessMemoryAvailableToTheProcess,,false,1741,1758,GuessMemoryAvailableToTheProcess,,,88,uint64_t node.GuessMemoryAvailableToTheProcess ()
79974,METHOD,env.cc:<global>,TYPE_DECL,"void Environment::BuildEmbedderGraph(Isolate* isolate,
                                     EmbedderGraph* graph,
                                     void* data) {
  MemoryTracker tracker(isolate, graph);
  Environment* env = static_cast<Environment*>(data);
  // Start traversing embedder objects from the root Environment object.
  tracker.Track(env);
}",1,1,env.cc,node.Environment.BuildEmbedderGraph,,false,1760,1767,BuildEmbedderGraph,,,89,"void node.Environment.BuildEmbedderGraph (Isolate*,EmbedderGraph*,void*)"
79996,METHOD,env.cc:<global>,TYPE_DECL,"size_t Environment::NearHeapLimitCallback(void* data,
                                          size_t current_heap_limit,
                                          size_t initial_heap_limit) {
  Environment* env = static_cast<Environment*>(data);

  Debug(env,
        DebugCategory::DIAGNOSTICS,
        ""Invoked NearHeapLimitCallback, processing=%d, ""
        ""current_limit=%"" PRIu64 "", ""
        ""initial_limit=%"" PRIu64 ""\n"",
        env->is_in_heapsnapshot_heap_limit_callback_,
        static_cast<uint64_t>(current_heap_limit),
        static_cast<uint64_t>(initial_heap_limit));

  size_t max_young_gen_size = env->isolate_data()->max_young_gen_size;
  size_t young_gen_size = 0;
  size_t old_gen_size = 0;

  HeapSpaceStatistics stats;
  size_t num_heap_spaces = env->isolate()->NumberOfHeapSpaces();
  for (size_t i = 0; i < num_heap_spaces; ++i) {
    env->isolate()->GetHeapSpaceStatistics(&stats, i);
    if (strcmp(stats.space_name(), ""new_space"") == 0 ||
        strcmp(stats.spac...",1,1,env.cc,node.Environment.NearHeapLimitCallback,,false,1769,1896,NearHeapLimitCallback,,,90,"size_t node.Environment.NearHeapLimitCallback (void*,size_t,size_t)"
80260,METHOD,env.cc:<global>,TYPE_DECL,"inline size_t Environment::SelfSize() const {
  size_t size = sizeof(*this);
  // Remove non pointer fields that will be tracked in MemoryInfo()
  // TODO(joyeecheung): refactor the MemoryTracker interface so
  // this can be done for common types within the Track* calls automatically
  // if a certain scope is entered.
  size -= sizeof(async_hooks_);
  size -= sizeof(cleanup_queue_);
  size -= sizeof(tick_info_);
  size -= sizeof(immediate_info_);
  return size;
}",1,1,env.cc,node.Environment.SelfSize,,false,1898,1909,SelfSize,,,91,size_t node.Environment.SelfSize ()
80288,METHOD,env.cc:<global>,TYPE_DECL,"void Environment::MemoryInfo(MemoryTracker* tracker) const {
  // Iteratable STLs have their own sizes subtracted from the parent
  // by default.
  tracker->TrackField(""isolate_data"", isolate_data_);
  tracker->TrackField(""destroy_async_id_list"", destroy_async_id_list_);
  tracker->TrackField(""exec_argv"", exec_argv_);
  tracker->TrackField(""exit_info"", exit_info_);
  tracker->TrackField(""should_abort_on_uncaught_toggle"",
                      should_abort_on_uncaught_toggle_);
  tracker->TrackField(""stream_base_state"", stream_base_state_);
  tracker->TrackField(""cleanup_queue"", cleanup_queue_);
  tracker->TrackField(""async_hooks"", async_hooks_);
  tracker->TrackField(""immediate_info"", immediate_info_);
  tracker->TrackField(""timeout_info"", timeout_info_);
  tracker->TrackField(""tick_info"", tick_info_);
  tracker->TrackField(""principal_realm"", principal_realm_);
  tracker->TrackField(""shadow_realms"", shadow_realms_);

  // FIXME(joyeecheung): track other fields in Environment.
  // ...",1,1,env.cc,node.Environment.MemoryInfo,,false,1911,1938,MemoryInfo,,,92,void node.Environment.MemoryInfo (MemoryTracker*)
80371,METHOD,env.cc:<global>,TYPE_DECL,"void Environment::RunWeakRefCleanup() {
  isolate()->ClearKeptObjects();
}",1,1,env.cc,node.Environment.RunWeakRefCleanup,,false,1940,1942,RunWeakRefCleanup,,,93,void node.Environment.RunWeakRefCleanup ()
80450,METHOD,env.hpp:<global>,TYPE_DECL,<global>,1,21,env.hpp,env.hpp:<global>,,false,1,1176,<global>,,,1,
80455,METHOD,env_properties.hpp:<global>,TYPE_DECL,<global>,1,32,env_properties.hpp,env_properties.hpp:<global>,,false,1,443,<global>,,,1,
80474,METHOD,fs_event_wrap.cc:<global>,TYPE_DECL,<global>,1,1,fs_event_wrap.cc,fs_event_wrap.cc:<global>,,false,1,246,<global>,,,1,
80479,METHOD,node.anonymous_namespace_1.FSEventWrap,TYPE_DECL,"static void Initialize(Local<Object> target,
                         Local<Value> unused,
                         Local<Context> context,
                         void* priv);",15,36,fs_event_wrap.cc,node.anonymous_namespace_2.FSEventWrap.Initialize,,false,53,56,Initialize,,,1,"void node.anonymous_namespace_2.FSEventWrap.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
80487,METHOD,node.anonymous_namespace_1.FSEventWrap,TYPE_DECL,static void RegisterExternalReferences(ExternalReferenceRegistry* registry);,15,77,fs_event_wrap.cc,node.anonymous_namespace_3.FSEventWrap.RegisterExternalReferences,,false,57,57,RegisterExternalReferences,,,2,void node.anonymous_namespace_3.FSEventWrap.RegisterExternalReferences (ExternalReferenceRegistry*)
80492,METHOD,node.anonymous_namespace_1.FSEventWrap,TYPE_DECL,static void New(const FunctionCallbackInfo<Value>& args);,15,58,fs_event_wrap.cc,node.anonymous_namespace_4.FSEventWrap.New,,false,58,58,New,,,3,void node.anonymous_namespace_4.FSEventWrap.New (FunctionCallbackInfo<Value>)
80497,METHOD,node.anonymous_namespace_1.FSEventWrap,TYPE_DECL,static void Start(const FunctionCallbackInfo<Value>& args);,15,60,fs_event_wrap.cc,node.anonymous_namespace_5.FSEventWrap.Start,,false,59,59,Start,,,4,void node.anonymous_namespace_5.FSEventWrap.Start (FunctionCallbackInfo<Value>)
80502,METHOD,node.anonymous_namespace_1.FSEventWrap,TYPE_DECL,static void GetInitialized(const FunctionCallbackInfo<Value>& args);,15,69,fs_event_wrap.cc,node.anonymous_namespace_6.FSEventWrap.GetInitialized,,false,60,60,GetInitialized,,,5,void node.anonymous_namespace_6.FSEventWrap.GetInitialized (FunctionCallbackInfo<Value>)
80508,METHOD,node.anonymous_namespace_1.FSEventWrap,TYPE_DECL,"FSEventWrap(Environment* env, Local<Object> object);",3,53,fs_event_wrap.cc,node.anonymous_namespace_7.FSEventWrap.FSEventWrap,,false,69,69,FSEventWrap,,,7,"ANY node.anonymous_namespace_7.FSEventWrap.FSEventWrap (Environment*,Local<Object>)"
80514,METHOD,node.anonymous_namespace_1.FSEventWrap,TYPE_DECL,~FSEventWrap() override = default;,3,36,fs_event_wrap.cc,node.anonymous_namespace_8.FSEventWrap.~FSEventWrap,,false,70,70,~FSEventWrap,,,8,ANY node.anonymous_namespace_8.FSEventWrap.~FSEventWrap ()
80518,METHOD,node.anonymous_namespace_1.FSEventWrap,TYPE_DECL,"static void OnEvent(uv_fs_event_t* handle, const char* filename, int events,
    int status);",15,15,fs_event_wrap.cc,node.anonymous_namespace_9.FSEventWrap.OnEvent,,false,72,73,OnEvent,,,9,"void node.anonymous_namespace_9.FSEventWrap.OnEvent (uv_fs_event_t*,char*,int,int)"
80529,METHOD,<empty>,<empty>,<empty>,1,,fs_event_wrap.cc,node.anonymous_namespace_1.FSEventWrap:<clinit>,,false,51,,<clinit>,,,13,
80536,METHOD,fs_event_wrap.cc:<global>,TYPE_DECL,"FSEventWrap::FSEventWrap(Environment* env, Local<Object> object)
    : HandleWrap(env,
                 object,
                 reinterpret_cast<uv_handle_t*>(&handle_),
                 AsyncWrap::PROVIDER_FSEVENTWRAP) {
  MarkAsUninitialized();
}",1,1,fs_event_wrap.cc,node.anonymous_namespace_11.FSEventWrap.FSEventWrap,,false,80,86,FSEventWrap,,,2,"ANY node.anonymous_namespace_11.FSEventWrap.FSEventWrap (Environment*,Local<Object>)"
80543,METHOD,fs_event_wrap.cc:<global>,TYPE_DECL,"void FSEventWrap::GetInitialized(const FunctionCallbackInfo<Value>& args) {
  FSEventWrap* wrap = Unwrap<FSEventWrap>(args.This());
  CHECK_NOT_NULL(wrap);
  args.GetReturnValue().Set(!wrap->IsHandleClosing());
}",1,1,fs_event_wrap.cc,node.anonymous_namespace_12.FSEventWrap.GetInitialized,,false,89,93,GetInitialized,,,3,void node.anonymous_namespace_12.FSEventWrap.GetInitialized (FunctionCallbackInfo<Value>)
80573,METHOD,fs_event_wrap.cc:<global>,TYPE_DECL,"void FSEventWrap::Initialize(Local<Object> target,
                             Local<Value> unused,
                             Local<Context> context,
                             void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->InstanceTemplate()->SetInternalFieldCount(
      FSEventWrap::kInternalFieldCount);

  t->Inherit(HandleWrap::GetConstructorTemplate(env));
  SetProtoMethod(isolate, t, ""start"", Start);

  Local<FunctionTemplate> get_initialized_templ =
      FunctionTemplate::New(env->isolate(),
                            GetInitialized,
                            Local<Value>(),
                            Signature::New(env->isolate(), t));

  t->PrototypeTemplate()->SetAccessorProperty(
      FIXED_ONE_BYTE_STRING(env->isolate(), ""initialized""),
      get_initialized_templ,
      Local<FunctionTemplate>(),
      static_cast<PropertyAttribut...",1,1,fs_event_wrap.cc,node.anonymous_namespace_13.FSEventWrap.Initialize,,false,95,122,Initialize,,,4,"void node.anonymous_namespace_13.FSEventWrap.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
80681,METHOD,fs_event_wrap.cc:<global>,TYPE_DECL,"void FSEventWrap::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(New);
  registry->Register(Start);
  registry->Register(GetInitialized);
}",1,1,fs_event_wrap.cc,node.anonymous_namespace_16.FSEventWrap.RegisterExternalReferences,,false,124,129,RegisterExternalReferences,,,5,void node.anonymous_namespace_16.FSEventWrap.RegisterExternalReferences (ExternalReferenceRegistry*)
80701,METHOD,fs_event_wrap.cc:<global>,TYPE_DECL,"void FSEventWrap::New(const FunctionCallbackInfo<Value>& args) {
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new FSEventWrap(env, args.This());
}",1,1,fs_event_wrap.cc,node.anonymous_namespace_19.FSEventWrap.New,,false,131,135,New,,,6,void node.anonymous_namespace_19.FSEventWrap.New (FunctionCallbackInfo<Value>)
80726,METHOD,fs_event_wrap.cc:<global>,TYPE_DECL,"void FSEventWrap::Start(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  FSEventWrap* wrap = Unwrap<FSEventWrap>(args.This());
  CHECK_NOT_NULL(wrap);
  CHECK(wrap->IsHandleClosing());  // Check that Start() has not been called.

  const int argc = args.Length();
  CHECK_GE(argc, 4);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, *path);

  unsigned int flags = 0;
  if (args[2]->IsTrue())
    flags |= UV_FS_EVENT_RECURSIVE;

  wrap->encoding_ = ParseEncoding(env->isolate(), args[3], kDefaultEncoding);

  int err = uv_fs_event_init(wrap->env()->event_loop(), &wrap->handle_);
  if (err != 0) {
    return args.GetReturnValue().Set(err);
  }

  err = uv_fs_event_start(&wrap->handle_, OnEvent, *path, flags);
  wrap->MarkAsInitialized();

  if (err != 0) {
    FSEventWrap::Close(args);
    return args.GetReturnValue().Set(er...",1,1,fs_event_wrap.cc,node.anonymous_namespace_20.FSEventWrap.Start,,false,138,178,Start,,,7,void node.anonymous_namespace_20.FSEventWrap.Start (FunctionCallbackInfo<Value>)
80903,METHOD,fs_event_wrap.cc:<global>,TYPE_DECL,"void FSEventWrap::OnEvent(uv_fs_event_t* handle, const char* filename,
    int events, int status) {
  FSEventWrap* wrap = static_cast<FSEventWrap*>(handle->data);
  Environment* env = wrap->env();

  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  CHECK_EQ(wrap->persistent().IsEmpty(), false);

  // We're in a bind here. libuv can set both UV_RENAME and UV_CHANGE but
  // the Node API only lets us pass a single event to JS land.
  //
  // The obvious solution is to run the callback twice, once for each event.
  // However, since the second event is not allowed to fire if the handle is
  // closed after the first event, and since there is no good way to detect
  // closed handles, that option is out.
  //
  // For now, ignore the UV_CHANGE event if UV_RENAME is also set. Make the
  // assumption that a rename implicitly means an attribute change. Not too
  // unreasonable, right? Still, we should revisit this before v1.0.
  Local<String> ...",1,1,fs_event_wrap.cc,node.anonymous_namespace_22.FSEventWrap.OnEvent,,false,181,238,OnEvent,,,8,"void node.anonymous_namespace_22.FSEventWrap.OnEvent (uv_fs_event_t*,char*,int,int)"
81119,METHOD,handle_wrap.cc:<global>,TYPE_DECL,<global>,1,1,handle_wrap.cc,handle_wrap.cc:<global>,,false,1,190,<global>,,,1,
81122,METHOD,handle_wrap.cc:<global>,TYPE_DECL,"void HandleWrap::Ref(const FunctionCallbackInfo<Value>& args) {
  HandleWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  if (IsAlive(wrap))
    uv_ref(wrap->GetHandle());
}",1,1,handle_wrap.cc,node.HandleWrap.Ref,,false,40,46,Ref,,,1,void node.HandleWrap.Ref (FunctionCallbackInfo<Value>)
81144,METHOD,handle_wrap.cc:<global>,TYPE_DECL,"void HandleWrap::Unref(const FunctionCallbackInfo<Value>& args) {
  HandleWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  if (IsAlive(wrap))
    uv_unref(wrap->GetHandle());
}",1,1,handle_wrap.cc,node.HandleWrap.Unref,,false,49,55,Unref,,,2,void node.HandleWrap.Unref (FunctionCallbackInfo<Value>)
81166,METHOD,handle_wrap.cc:<global>,TYPE_DECL,"void HandleWrap::HasRef(const FunctionCallbackInfo<Value>& args) {
  HandleWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  args.GetReturnValue().Set(HasRef(wrap));
}",1,1,handle_wrap.cc,node.HandleWrap.HasRef,,false,58,62,HasRef,,,3,void node.HandleWrap.HasRef (FunctionCallbackInfo<Value>)
81188,METHOD,handle_wrap.cc:<global>,TYPE_DECL,"void HandleWrap::Close(const FunctionCallbackInfo<Value>& args) {
  HandleWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  wrap->Close(args[0]);
}",1,1,handle_wrap.cc,node.HandleWrap.Close,,false,65,70,Close,,,4,void node.HandleWrap.Close (FunctionCallbackInfo<Value>)
81208,METHOD,handle_wrap.cc:<global>,TYPE_DECL,"void HandleWrap::Close(Local<Value> close_callback) {
  if (state_ != kInitialized)
    return;

  uv_close(handle_, OnClose);
  state_ = kClosing;

  if (!close_callback.IsEmpty() && close_callback->IsFunction() &&
      !persistent().IsEmpty()) {
    object()->Set(env()->context(),
                  env()->handle_onclose_symbol(),
                  close_callback).Check();
  }
}",1,1,handle_wrap.cc,node.HandleWrap.Close,,false,72,85,Close,,,5,void node.HandleWrap.Close (Local<Value>)
81259,METHOD,handle_wrap.cc:<global>,TYPE_DECL,"void HandleWrap::OnGCCollect() {
  // When all references to a HandleWrap are lost and the object is supposed to
  // be destroyed, we first call Close() to clean up the underlying libuv
  // handle. The OnClose callback then acquires and destroys another reference
  // to that object, and when that reference is lost, we perform the default
  // action (i.e. destroying `this`).
  if (state_ != kClosed) {
    Close();
  } else {
    BaseObject::OnGCCollect();
  }
}",1,1,handle_wrap.cc,node.HandleWrap.OnGCCollect,,false,88,99,OnGCCollect,,,6,void node.HandleWrap.OnGCCollect ()
81275,METHOD,handle_wrap.cc:<global>,TYPE_DECL,"bool HandleWrap::IsNotIndicativeOfMemoryLeakAtExit() const {
  return IsWeakOrDetached() ||
         !HandleWrap::HasRef(this) ||
         !uv_is_active(GetHandle());
}",1,1,handle_wrap.cc,node.HandleWrap.IsNotIndicativeOfMemoryLeakAtExit,,false,102,106,IsNotIndicativeOfMemoryLeakAtExit,,,7,bool node.HandleWrap.IsNotIndicativeOfMemoryLeakAtExit ()
81292,METHOD,handle_wrap.cc:<global>,TYPE_DECL,"void HandleWrap::MarkAsInitialized() {
  env()->handle_wrap_queue()->PushBack(this);
  state_ = kInitialized;
}",1,1,handle_wrap.cc,node.HandleWrap.MarkAsInitialized,,false,109,112,MarkAsInitialized,,,8,void node.HandleWrap.MarkAsInitialized ()
81307,METHOD,handle_wrap.cc:<global>,TYPE_DECL,"void HandleWrap::MarkAsUninitialized() {
  handle_wrap_queue_.Remove();
  state_ = kClosed;
}",1,1,handle_wrap.cc,node.HandleWrap.MarkAsUninitialized,,false,115,118,MarkAsUninitialized,,,9,void node.HandleWrap.MarkAsUninitialized ()
81318,METHOD,handle_wrap.cc:<global>,TYPE_DECL,"HandleWrap::HandleWrap(Environment* env,
                       Local<Object> object,
                       uv_handle_t* handle,
                       AsyncWrap::ProviderType provider)
    : AsyncWrap(env, object, provider),
      state_(kInitialized),
      handle_(handle) {
  handle_->data = this;
  HandleScope scope(env->isolate());
  CHECK(env->has_run_bootstrapping_code());
  env->handle_wrap_queue()->PushBack(this);
}",1,1,handle_wrap.cc,node.HandleWrap.HandleWrap,,false,121,132,HandleWrap,,,10,"ANY node.HandleWrap.HandleWrap (Environment*,Local<Object>,uv_handle_t*,ANY)"
81350,METHOD,handle_wrap.cc:<global>,TYPE_DECL,"void HandleWrap::OnClose(uv_handle_t* handle) {
  CHECK_NOT_NULL(handle->data);
  BaseObjectPtr<HandleWrap> wrap { static_cast<HandleWrap*>(handle->data) };
  wrap->Detach();

  Environment* env = wrap->env();
  HandleScope scope(env->isolate());
  Context::Scope context_scope(env->context());

  CHECK_EQ(wrap->state_, kClosing);

  wrap->state_ = kClosed;

  wrap->OnClose();
  wrap->handle_wrap_queue_.Remove();

  if (!wrap->persistent().IsEmpty() &&
      wrap->object()->Has(env->context(), env->handle_onclose_symbol())
      .FromMaybe(false)) {
    wrap->MakeCallback(env->handle_onclose_symbol(), 0, nullptr);
  }
}",1,1,handle_wrap.cc,node.HandleWrap.OnClose,,false,135,156,OnClose,,,11,void node.HandleWrap.OnClose (uv_handle_t*)
81453,METHOD,handle_wrap.cc:<global>,TYPE_DECL,"Local<FunctionTemplate> HandleWrap::GetConstructorTemplate(Environment* env) {
  return GetConstructorTemplate(env->isolate_data());
}",1,1,handle_wrap.cc,node.HandleWrap.GetConstructorTemplate,,false,157,159,GetConstructorTemplate,,,12,Local<FunctionTemplate> node.HandleWrap.GetConstructorTemplate (Environment*)
81464,METHOD,handle_wrap.cc:<global>,TYPE_DECL,"Local<FunctionTemplate> HandleWrap::GetConstructorTemplate(
    IsolateData* isolate_data) {
  Local<FunctionTemplate> tmpl = isolate_data->handle_wrap_ctor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = isolate_data->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->SetClassName(
        FIXED_ONE_BYTE_STRING(isolate_data->isolate(), ""HandleWrap""));
    tmpl->Inherit(AsyncWrap::GetConstructorTemplate(isolate_data));
    SetProtoMethod(isolate, tmpl, ""close"", HandleWrap::Close);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""hasRef"", HandleWrap::HasRef);
    SetProtoMethod(isolate, tmpl, ""ref"", HandleWrap::Ref);
    SetProtoMethod(isolate, tmpl, ""unref"", HandleWrap::Unref);
    isolate_data->set_handle_wrap_ctor_template(tmpl);
  }
  return tmpl;
}",1,1,handle_wrap.cc,node.HandleWrap.GetConstructorTemplate,,false,161,177,GetConstructorTemplate,,,13,Local<FunctionTemplate> node.HandleWrap.GetConstructorTemplate (IsolateData*)
81551,METHOD,handle_wrap.cc:<global>,TYPE_DECL,"void HandleWrap::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(HandleWrap::Close);
  registry->Register(HandleWrap::HasRef);
  registry->Register(HandleWrap::Ref);
  registry->Register(HandleWrap::Unref);
}",1,1,handle_wrap.cc,node.HandleWrap.RegisterExternalReferences,,false,179,185,RegisterExternalReferences,,,14,void node.HandleWrap.RegisterExternalReferences (ExternalReferenceRegistry*)
81596,METHOD,handle_wrap.hpp:<global>,TYPE_DECL,<global>,1,29,handle_wrap.hpp,handle_wrap.hpp:<global>,,false,1,123,<global>,,,1,
81617,METHOD,heap_utils.cc:<global>,TYPE_DECL,<global>,1,40,diagnosticfilename-inl.hpp,heap_utils.cc:<global>,,false,1,496,<global>,,,1,
81622,METHOD,node.heap.JSGraphJSNode,TYPE_DECL,"const char* Name() override { return ""<JS Node>""; }",3,53,heap_utils.cc,node.heap.JSGraphJSNode.Name,,false,49,49,Name,,,1,const char* node.heap.JSGraphJSNode.Name ()
81628,METHOD,node.heap.JSGraphJSNode,TYPE_DECL,size_t SizeInBytes() override { return 0; },3,45,heap_utils.cc,node.heap.JSGraphJSNode.SizeInBytes,,false,50,50,SizeInBytes,,,2,size_t node.heap.JSGraphJSNode.SizeInBytes ()
81634,METHOD,node.heap.JSGraphJSNode,TYPE_DECL,bool IsEmbedderNode() override { return false; },3,50,heap_utils.cc,node.heap.JSGraphJSNode.IsEmbedderNode,,false,51,51,IsEmbedderNode,,,3,bool node.heap.JSGraphJSNode.IsEmbedderNode ()
81640,METHOD,node.heap.JSGraphJSNode,TYPE_DECL,Local<Value> JSValue() { return PersistentToLocal::Strong(persistent_); },3,75,heap_utils.cc,node.heap.JSGraphJSNode.JSValue,,false,52,52,JSValue,,,4,Local<Value> node.heap.JSGraphJSNode.JSValue ()
81650,METHOD,node.heap.JSGraphJSNode,TYPE_DECL,"int IdentityHash() {
    Local<Value> v = JSValue();
    if (v->IsObject()) return v.As<Object>()->GetIdentityHash();
    if (v->IsName()) return v.As<v8::Name>()->GetIdentityHash();
    if (v->IsInt32()) return v.As<v8::Int32>()->Value();
    return 0;
  }",3,3,heap_utils.cc,node.heap.JSGraphJSNode.IdentityHash,,false,54,60,IdentityHash,,,5,int node.heap.JSGraphJSNode.IdentityHash ()
81705,METHOD,node.heap.JSGraphJSNode,TYPE_DECL,"JSGraphJSNode(Isolate* isolate, Local<Value> val)
      : persistent_(isolate, val) {
    CHECK(!val.IsEmpty());
  }",3,3,heap_utils.cc,node.heap.JSGraphJSNode.JSGraphJSNode,,false,62,65,JSGraphJSNode,,,6,"ANY node.heap.JSGraphJSNode.JSGraphJSNode (Isolate*,Local<Value>)"
81718,METHOD,node.heap.JSGraphJSNode.Hash,TYPE_DECL,"inline size_t operator()(JSGraphJSNode* n) const {
      return static_cast<size_t>(n->IdentityHash());
    }",5,5,heap_utils.cc,node.heap.JSGraphJSNode.Hash.operator (),,false,68,70,operator (),,,1,size_t node.heap.JSGraphJSNode.Hash.operator () (JSGraphJSNode*)
81731,METHOD,node.heap.JSGraphJSNode.Equal,TYPE_DECL,"inline bool operator()(JSGraphJSNode* a, JSGraphJSNode* b) const {
      return a->JSValue()->SameValue(b->JSValue());
    }",5,5,heap_utils.cc,node.heap.JSGraphJSNode.Equal.operator (),,false,74,76,operator (),,,1,"bool node.heap.JSGraphJSNode.Equal.operator () (JSGraphJSNode*,JSGraphJSNode*)"
81751,METHOD,node.heap.JSGraph,TYPE_DECL,explicit JSGraph(Isolate* isolate) : isolate_(isolate) {},3,59,heap_utils.cc,node.heap.JSGraph.JSGraph,,false,85,85,JSGraph,,,1,ANY node.heap.JSGraph.JSGraph (Isolate*)
81756,METHOD,node.heap.JSGraph,TYPE_DECL,"Node* V8Node(const Local<Value>& value) override {
    std::unique_ptr<JSGraphJSNode> n { new JSGraphJSNode(isolate_, value) };
    auto it = engine_nodes_.find(n.get());
    if (it != engine_nodes_.end())
      return *it;
    engine_nodes_.insert(n.get());
    return AddNode(std::unique_ptr<Node>(n.release()));
  }",3,3,heap_utils.cc,node.heap.JSGraph.V8Node,,false,87,94,V8Node,,,2,Node node.heap.JSGraph.V8Node (Local<Value>)
81811,METHOD,node.heap.JSGraph,TYPE_DECL,"Node* AddNode(std::unique_ptr<Node> node) override {
    Node* n = node.get();
    nodes_.emplace(std::move(node));
    return n;
  }",3,3,heap_utils.cc,node.heap.JSGraph.AddNode,,false,96,100,AddNode,,,3,Node node.heap.JSGraph.AddNode (ANY)
81834,METHOD,node.heap.JSGraph,TYPE_DECL,"void AddEdge(Node* from, Node* to, const char* name = nullptr) override {
    edges_[from].insert(std::make_pair(name, to));
  }",3,3,heap_utils.cc,node.heap.JSGraph.AddEdge,,false,102,104,AddEdge,,,4,"void node.heap.JSGraph.AddEdge (Node*,Node*,char*)"
81853,METHOD,node.heap.JSGraph,TYPE_DECL,"MaybeLocal<Array> CreateObject() const {
    EscapableHandleScope handle_scope(isolate_);
    Local<Context> context = isolate_->GetCurrentContext();
    Environment* env = Environment::GetCurrent(context);

    std::unordered_map<Node*, Local<Object>> info_objects;
    Local<Array> nodes = Array::New(isolate_, nodes_.size());
    Local<String> edges_string = FIXED_ONE_BYTE_STRING(isolate_, ""edges"");
    Local<String> is_root_string = FIXED_ONE_BYTE_STRING(isolate_, ""isRoot"");
    Local<String> name_string = env->name_string();
    Local<String> size_string = env->size_string();
    Local<String> value_string = env->value_string();
    Local<String> wraps_string = FIXED_ONE_BYTE_STRING(isolate_, ""wraps"");
    Local<String> to_string = FIXED_ONE_BYTE_STRING(isolate_, ""to"");

    for (const std::unique_ptr<Node>& n : nodes_)
      info_objects[n.get()] = Object::New(isolate_);

    {
      HandleScope handle_scope(isolate_);
      size_t i = 0;
      for (const std::unique_ptr<Node>& ...",3,3,heap_utils.cc,node.heap.JSGraph.CreateObject,,false,106,204,CreateObject,,,5,MaybeLocal<Array> node.heap.JSGraph.CreateObject ()
82394,METHOD,heap_utils.cc:<global>,TYPE_DECL,"void BuildEmbedderGraph(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  JSGraph graph(env->isolate());
  Environment::BuildEmbedderGraph(env->isolate(), &graph, env);
  Local<Array> ret;
  if (graph.CreateObject().ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",1,1,heap_utils.cc,node.heap.BuildEmbedderGraph,,false,214,221,BuildEmbedderGraph,,,3,void node.heap.BuildEmbedderGraph (FunctionCallbackInfo<Value>)
82450,METHOD,node.heap.anonymous_namespace_1.FileOutputStream,TYPE_DECL,"FileOutputStream(const int fd, uv_fs_t* req) : fd_(fd), req_(req) {}",3,70,heap_utils.cc,node.heap.anonymous_namespace_2.FileOutputStream.FileOutputStream,,false,226,226,FileOutputStream,,,1,"ANY node.heap.anonymous_namespace_2.FileOutputStream.FileOutputStream (int,uv_fs_t*)"
82456,METHOD,node.heap.anonymous_namespace_1.FileOutputStream,TYPE_DECL,"int GetChunkSize() override {
    return 65536;  // big chunks == faster
  }",3,3,heap_utils.cc,node.heap.anonymous_namespace_3.FileOutputStream.GetChunkSize,,false,228,230,GetChunkSize,,,2,int node.heap.anonymous_namespace_3.FileOutputStream.GetChunkSize ()
82462,METHOD,node.heap.anonymous_namespace_1.FileOutputStream,TYPE_DECL,void EndOfStream() override {},3,32,heap_utils.cc,node.heap.anonymous_namespace_4.FileOutputStream.EndOfStream,,false,232,232,EndOfStream,,,3,void node.heap.anonymous_namespace_4.FileOutputStream.EndOfStream ()
82466,METHOD,node.heap.anonymous_namespace_1.FileOutputStream,TYPE_DECL,"WriteResult WriteAsciiChunk(char* data, const int size) override {
    DCHECK_EQ(status_, 0);
    int offset = 0;
    while (offset < size) {
      const uv_buf_t buf = uv_buf_init(data + offset, size - offset);
      const int num_bytes_written = uv_fs_write(nullptr,
                                                req_,
                                                fd_,
                                                &buf,
                                                1,
                                                -1,
                                                nullptr);
      uv_fs_req_cleanup(req_);
      if (num_bytes_written < 0) {
        status_ = num_bytes_written;
        return kAbort;
      }
      DCHECK_LE(static_cast<size_t>(num_bytes_written), buf.len);
      offset += num_bytes_written;
    }
    DCHECK_EQ(offset, size);
    return kContinue;
  }",3,3,heap_utils.cc,node.heap.anonymous_namespace_5.FileOutputStream.WriteAsciiChunk,,false,234,256,WriteAsciiChunk,,,4,"WriteResult node.heap.anonymous_namespace_5.FileOutputStream.WriteAsciiChunk (char*,int)"
82534,METHOD,node.heap.anonymous_namespace_1.FileOutputStream,TYPE_DECL,int status() const { return status_; },3,40,heap_utils.cc,node.heap.anonymous_namespace_6.FileOutputStream.status,,false,258,258,status,,,5,int node.heap.anonymous_namespace_6.FileOutputStream.status ()
82543,METHOD,<empty>,<empty>,<empty>,1,,heap_utils.cc,node.heap.anonymous_namespace_1.FileOutputStream:<clinit>,,false,224,,<clinit>,,,9,
82551,METHOD,node.heap.anonymous_namespace_7.HeapSnapshotStream,TYPE_DECL,"HeapSnapshotStream(
      Environment* env,
      HeapSnapshotPointer&& snapshot,
      Local<Object> obj) :
      AsyncWrap(env, obj, AsyncWrap::PROVIDER_HEAPSNAPSHOT),
      StreamBase(env),
      snapshot_(std::move(snapshot)) {
    MakeWeak();
    StreamBase::AttachToObject(GetObject());
  }",3,3,heap_utils.cc,node.heap.anonymous_namespace_8.HeapSnapshotStream.HeapSnapshotStream,,false,270,279,HeapSnapshotStream,,,1,"ANY node.heap.anonymous_namespace_8.HeapSnapshotStream.HeapSnapshotStream (Environment*,HeapSnapshotPointer,Local<Object>)"
82560,METHOD,node.heap.anonymous_namespace_7.HeapSnapshotStream,TYPE_DECL,~HeapSnapshotStream() override {},3,35,heap_utils.cc,node.heap.anonymous_namespace_9.HeapSnapshotStream.~HeapSnapshotStream,,false,281,281,~HeapSnapshotStream,,,2,ANY node.heap.anonymous_namespace_9.HeapSnapshotStream.~HeapSnapshotStream ()
82564,METHOD,node.heap.anonymous_namespace_7.HeapSnapshotStream,TYPE_DECL,"int GetChunkSize() override {
    return 65536;  // big chunks == faster
  }",3,3,heap_utils.cc,node.heap.anonymous_namespace_10.HeapSnapshotStream.GetChunkSize,,false,283,285,GetChunkSize,,,3,int node.heap.anonymous_namespace_10.HeapSnapshotStream.GetChunkSize ()
82570,METHOD,node.heap.anonymous_namespace_7.HeapSnapshotStream,TYPE_DECL,"void EndOfStream() override {
    EmitRead(UV_EOF);
    snapshot_.reset();
  }",3,3,heap_utils.cc,node.heap.anonymous_namespace_11.HeapSnapshotStream.EndOfStream,,false,287,290,EndOfStream,,,4,void node.heap.anonymous_namespace_11.HeapSnapshotStream.EndOfStream ()
82579,METHOD,node.heap.anonymous_namespace_7.HeapSnapshotStream,TYPE_DECL,"WriteResult WriteAsciiChunk(char* data, int size) override {
    int len = size;
    while (len != 0) {
      uv_buf_t buf = EmitAlloc(size);
      ssize_t avail = len;
      if (static_cast<ssize_t>(buf.len) < avail)
        avail = buf.len;
      memcpy(buf.base, data, avail);
      data += avail;
      len -= static_cast<int>(avail);
      EmitRead(size, buf);
    }
    return kContinue;
  }",3,3,heap_utils.cc,node.heap.anonymous_namespace_12.HeapSnapshotStream.WriteAsciiChunk,,false,292,305,WriteAsciiChunk,,,5,"WriteResult node.heap.anonymous_namespace_12.HeapSnapshotStream.WriteAsciiChunk (char*,int)"
82636,METHOD,node.heap.anonymous_namespace_7.HeapSnapshotStream,TYPE_DECL,"int ReadStart() override {
    CHECK_NE(snapshot_, nullptr);
    snapshot_->Serialize(this, HeapSnapshot::kJSON);
    return 0;
  }",3,3,heap_utils.cc,node.heap.anonymous_namespace_13.HeapSnapshotStream.ReadStart,,false,307,311,ReadStart,,,6,int node.heap.anonymous_namespace_13.HeapSnapshotStream.ReadStart ()
82653,METHOD,node.heap.anonymous_namespace_7.HeapSnapshotStream,TYPE_DECL,"int ReadStop() override {
    return 0;
  }",3,3,heap_utils.cc,node.heap.anonymous_namespace_14.HeapSnapshotStream.ReadStop,,false,313,315,ReadStop,,,7,int node.heap.anonymous_namespace_14.HeapSnapshotStream.ReadStop ()
82659,METHOD,node.heap.anonymous_namespace_7.HeapSnapshotStream,TYPE_DECL,"int DoShutdown(ShutdownWrap* req_wrap) override {
    UNREACHABLE();
  }",3,3,heap_utils.cc,node.heap.anonymous_namespace_15.HeapSnapshotStream.DoShutdown,,false,317,319,DoShutdown,,,8,int node.heap.anonymous_namespace_15.HeapSnapshotStream.DoShutdown (ShutdownWrap*)
82665,METHOD,node.heap.anonymous_namespace_7.HeapSnapshotStream,TYPE_DECL,"int DoWrite(WriteWrap* w,
              uv_buf_t* bufs,
              size_t count,
              uv_stream_t* send_handle) override {
    UNREACHABLE();
  }",3,3,heap_utils.cc,node.heap.anonymous_namespace_16.HeapSnapshotStream.DoWrite,,false,321,326,DoWrite,,,9,"int node.heap.anonymous_namespace_16.HeapSnapshotStream.DoWrite (WriteWrap*,uv_buf_t*,size_t,uv_stream_t*)"
82674,METHOD,node.heap.anonymous_namespace_7.HeapSnapshotStream,TYPE_DECL,bool IsAlive() override { return snapshot_ != nullptr; },3,58,heap_utils.cc,node.heap.anonymous_namespace_17.HeapSnapshotStream.IsAlive,,false,328,328,IsAlive,,,10,bool node.heap.anonymous_namespace_17.HeapSnapshotStream.IsAlive ()
82682,METHOD,node.heap.anonymous_namespace_7.HeapSnapshotStream,TYPE_DECL,bool IsClosing() override { return snapshot_ == nullptr; },3,60,heap_utils.cc,node.heap.anonymous_namespace_18.HeapSnapshotStream.IsClosing,,false,329,329,IsClosing,,,11,bool node.heap.anonymous_namespace_18.HeapSnapshotStream.IsClosing ()
82690,METHOD,node.heap.anonymous_namespace_7.HeapSnapshotStream,TYPE_DECL,AsyncWrap* GetAsyncWrap() override { return this; },3,53,heap_utils.cc,node.heap.anonymous_namespace_19.HeapSnapshotStream.GetAsyncWrap,,false,330,330,GetAsyncWrap,,,12,AsyncWrap node.heap.anonymous_namespace_19.HeapSnapshotStream.GetAsyncWrap ()
82696,METHOD,node.heap.anonymous_namespace_7.HeapSnapshotStream,TYPE_DECL,"void MemoryInfo(MemoryTracker* tracker) const override {
    if (snapshot_ != nullptr) {
      tracker->TrackFieldWithSize(
          ""snapshot"", sizeof(*snapshot_), ""HeapSnapshot"");
    }
  }",3,3,heap_utils.cc,node.heap.anonymous_namespace_20.HeapSnapshotStream.MemoryInfo,,false,332,337,MemoryInfo,,,13,void node.heap.anonymous_namespace_20.HeapSnapshotStream.MemoryInfo (MemoryTracker*)
82720,METHOD,heap_utils.cc:<global>,TYPE_DECL,"inline void TakeSnapshot(Environment* env,
                         v8::OutputStream* out,
                         HeapProfiler::HeapSnapshotOptions options) {
  HeapSnapshotPointer snapshot{
      env->isolate()->GetHeapProfiler()->TakeHeapSnapshot(options)};
  snapshot->Serialize(out, HeapSnapshot::kJSON);
}",1,1,heap_utils.cc,node.heap.anonymous_namespace_21.TakeSnapshot,,false,346,352,TakeSnapshot,,,3,"void node.heap.anonymous_namespace_21.TakeSnapshot (Environment*,ANY*,ANY)"
82750,METHOD,heap_utils.cc:<global>,TYPE_DECL,"Maybe<void> WriteSnapshot(Environment* env,
                          const char* filename,
                          HeapProfiler::HeapSnapshotOptions options) {
  uv_fs_t req;
  int err;

  const int fd = uv_fs_open(nullptr,
                            &req,
                            filename,
                            O_WRONLY | O_CREAT | O_TRUNC,
                            S_IWUSR | S_IRUSR,
                            nullptr);
  uv_fs_req_cleanup(&req);
  if ((err = fd) < 0) {
    env->ThrowUVException(err, ""open"", nullptr, filename);
    return Nothing<void>();
  }

  FileOutputStream stream(fd, &req);
  TakeSnapshot(env, &stream, options);
  if ((err = stream.status()) < 0) {
    env->ThrowUVException(err, ""write"", nullptr, filename);
    return Nothing<void>();
  }

  err = uv_fs_close(nullptr, &req, fd, nullptr);
  uv_fs_req_cleanup(&req);
  if (err < 0) {
    env->ThrowUVException(err, ""close"", nullptr, filename);
    return Nothing<void>();
  }

  return JustVoid();
}",1,1,heap_utils.cc,node.heap.WriteSnapshot,,false,356,389,WriteSnapshot,,,5,"Maybe<void> node.heap.WriteSnapshot (Environment*,char*,ANY)"
82854,METHOD,heap_utils.cc:<global>,TYPE_DECL,"void DeleteHeapSnapshot(const HeapSnapshot* snapshot) {
  const_cast<HeapSnapshot*>(snapshot)->Delete();
}",1,1,heap_utils.cc,node.heap.DeleteHeapSnapshot,,false,391,393,DeleteHeapSnapshot,,,6,void node.heap.DeleteHeapSnapshot (HeapSnapshot*)
82865,METHOD,heap_utils.cc:<global>,TYPE_DECL,"BaseObjectPtr<AsyncWrap> CreateHeapSnapshotStream(
    Environment* env, HeapSnapshotPointer&& snapshot) {
  HandleScope scope(env->isolate());

  if (env->streambaseoutputstream_constructor_template().IsEmpty()) {
    // Create FunctionTemplate for HeapSnapshotStream
    Local<FunctionTemplate> os = FunctionTemplate::New(env->isolate());
    os->Inherit(AsyncWrap::GetConstructorTemplate(env));
    Local<ObjectTemplate> ost = os->InstanceTemplate();
    ost->SetInternalFieldCount(StreamBase::kInternalFieldCount);
    os->SetClassName(
        FIXED_ONE_BYTE_STRING(env->isolate(), ""HeapSnapshotStream""));
    StreamBase::AddMethods(env, os);
    env->set_streambaseoutputstream_constructor_template(ost);
  }

  Local<Object> obj;
  if (!env->streambaseoutputstream_constructor_template()
           ->NewInstance(env->context())
           .ToLocal(&obj)) {
    return {};
  }
  return MakeBaseObject<HeapSnapshotStream>(env, std::move(snapshot), obj);
}",1,1,heap_utils.cc,node.heap.CreateHeapSnapshotStream,,false,395,418,CreateHeapSnapshotStream,,,7,"BaseObjectPtr<AsyncWrap> node.heap.CreateHeapSnapshotStream (Environment*,HeapSnapshotPointer)"
82986,METHOD,heap_utils.cc:<global>,TYPE_DECL,"HeapProfiler::HeapSnapshotOptions GetHeapSnapshotOptions(
    Local<Value> options_value) {
  CHECK(options_value->IsUint8Array());
  Local<Uint8Array> arr = options_value.As<Uint8Array>();
  uint8_t* options =
      static_cast<uint8_t*>(arr->Buffer()->Data()) + arr->ByteOffset();
  HeapProfiler::HeapSnapshotOptions result;
  result.snapshot_mode = options[0]
                             ? HeapProfiler::HeapSnapshotMode::kExposeInternals
                             : HeapProfiler::HeapSnapshotMode::kRegular;
  result.numerics_mode = options[1]
                             ? HeapProfiler::NumericsMode::kExposeNumericValues
                             : HeapProfiler::NumericsMode::kHideNumericValues;
  return result;
}",1,1,heap_utils.cc,node.heap.GetHeapSnapshotOptions,,false,420,434,GetHeapSnapshotOptions,,,8,HeapSnapshotOptions node.heap.GetHeapSnapshotOptions (Local<Value>)
83062,METHOD,heap_utils.cc:<global>,TYPE_DECL,"void CreateHeapSnapshotStream(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK_EQ(args.Length(), 1);
  auto options = GetHeapSnapshotOptions(args[0]);
  HeapSnapshotPointer snapshot{
      env->isolate()->GetHeapProfiler()->TakeHeapSnapshot(options)};
  CHECK(snapshot);
  BaseObjectPtr<AsyncWrap> stream =
      CreateHeapSnapshotStream(env, std::move(snapshot));
  if (stream)
    args.GetReturnValue().Set(stream->object());
}",1,1,heap_utils.cc,node.heap.CreateHeapSnapshotStream,,false,436,447,CreateHeapSnapshotStream,,,9,void node.heap.CreateHeapSnapshotStream (FunctionCallbackInfo<Value>)
83132,METHOD,heap_utils.cc:<global>,TYPE_DECL,"void TriggerHeapSnapshot(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = args.GetIsolate();
  CHECK_EQ(args.Length(), 2);
  Local<Value> filename_v = args[0];
  auto options = GetHeapSnapshotOptions(args[1]);

  if (filename_v->IsUndefined()) {
    DiagnosticFilename name(env, ""Heap"", ""heapsnapshot"");
    THROW_IF_INSUFFICIENT_PERMISSIONS(
        env, permission::PermissionScope::kFileSystemWrite, env->GetCwd());
    if (WriteSnapshot(env, *name, options).IsNothing()) return;
    if (String::NewFromUtf8(isolate, *name).ToLocal(&filename_v)) {
      args.GetReturnValue().Set(filename_v);
    }
    return;
  }

  BufferValue path(isolate, filename_v);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());
  if (WriteSnapshot(env, *path, options).IsNothing()) return;
  return args.GetReturnValue().Set(filename_v);
}",1,1,heap_utils.cc,node.heap.TriggerHeapSnapshot,,false,449,473,TriggerHeapSnapshot,,,10,void node.heap.TriggerHeapSnapshot (FunctionCallbackInfo<Value>)
83268,METHOD,heap_utils.cc:<global>,TYPE_DECL,"void Initialize(Local<Object> target,
                Local<Value> unused,
                Local<Context> context,
                void* priv) {
  SetMethod(context, target, ""buildEmbedderGraph"", BuildEmbedderGraph);
  SetMethod(context, target, ""triggerHeapSnapshot"", TriggerHeapSnapshot);
  SetMethod(
      context, target, ""createHeapSnapshotStream"", CreateHeapSnapshotStream);
}",1,1,heap_utils.cc,node.heap.Initialize,,false,475,483,Initialize,,,11,"void node.heap.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
83291,METHOD,heap_utils.cc:<global>,TYPE_DECL,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(BuildEmbedderGraph);
  registry->Register(TriggerHeapSnapshot);
  registry->Register(CreateHeapSnapshotStream);
}",1,1,heap_utils.cc,node.heap.RegisterExternalReferences,,false,485,489,RegisterExternalReferences,,,12,void node.heap.RegisterExternalReferences (ExternalReferenceRegistry*)
83321,METHOD,histogram-inl.hpp:<global>,TYPE_DECL,<global>,1,31,histogram-inl.hpp,histogram-inl.hpp:<global>,,false,1,107,<global>,,,1,
83324,METHOD,histogram.cc:<global>,TYPE_DECL,"[map, env](double key, int64_t value) {
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          Number::New(env->isolate(), static_cast<double>(value))));
  }",29,3,histogram.cc,node.HistogramBase.GetPercentiles.<lambda>0,,false,163,168,<lambda>0,,,1,"ANY node.HistogramBase.GetPercentiles.<lambda>0 (double,int64_t)"
83362,METHOD,histogram.cc:<global>,TYPE_DECL,"[map, env](double key, int64_t value) {
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          BigInt::New(env->isolate(), value)));
  }",29,3,histogram.cc,node.HistogramBase.GetPercentilesBigInt.<lambda>1,,false,178,183,<lambda>1,,,1,"ANY node.HistogramBase.GetPercentilesBigInt.<lambda>1 (double,int64_t)"
83397,METHOD,histogram.cc:<global>,TYPE_DECL,"[map, env](double key, int64_t value) {
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          Number::New(env->isolate(), static_cast<double>(value))));
  }",29,3,histogram.cc,node.IntervalHistogram.GetPercentiles.<lambda>2,,false,603,608,<lambda>2,,,1,"ANY node.IntervalHistogram.GetPercentiles.<lambda>2 (double,int64_t)"
83434,METHOD,histogram.cc:<global>,TYPE_DECL,"[map, env](double key, int64_t value) {
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          BigInt::New(env->isolate(), value)));
  }",29,3,histogram.cc,node.IntervalHistogram.GetPercentilesBigInt.<lambda>3,,false,618,623,<lambda>3,,,1,"ANY node.IntervalHistogram.GetPercentilesBigInt.<lambda>3 (double,int64_t)"
83482,METHOD,histogram.cc:<global>,TYPE_DECL,<global>,1,27,histogram.hpp,histogram.cc:<global>,,false,1,637,<global>,,,1,
83485,METHOD,histogram.cc:<global>,TYPE_DECL,"Histogram::Histogram(const Options& options) {
  hdr_histogram* histogram;
  CHECK_EQ(0, hdr_init(options.lowest,
                       options.highest,
                       options.figures,
                       &histogram));
  histogram_.reset(histogram);
}",1,1,histogram.cc,node.Histogram.Histogram,,false,24,31,Histogram,,,1,ANY node.Histogram.Histogram (Options)
83510,METHOD,histogram.cc:<global>,TYPE_DECL,"void Histogram::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackFieldWithSize(""histogram"", GetMemorySize());
}",1,1,histogram.cc,node.Histogram.MemoryInfo,,false,33,35,MemoryInfo,,,2,void node.Histogram.MemoryInfo (MemoryTracker*)
83521,METHOD,histogram.cc:<global>,TYPE_DECL,"HistogramImpl::HistogramImpl(const Histogram::Options& options)
    : histogram_(new Histogram(options)) {}",1,43,histogram.cc,node.HistogramImpl.HistogramImpl,,false,37,38,HistogramImpl,,,3,ANY node.HistogramImpl.HistogramImpl (ANY)
83526,METHOD,histogram.cc:<global>,TYPE_DECL,"HistogramImpl::HistogramImpl(std::shared_ptr<Histogram> histogram)
    : histogram_(std::move(histogram)) {}",1,41,histogram.cc,node.HistogramImpl.HistogramImpl,,false,40,41,HistogramImpl,,,4,ANY node.HistogramImpl.HistogramImpl (ANY)
83531,METHOD,histogram.cc:<global>,TYPE_DECL,"HistogramBase::HistogramBase(
    Environment* env,
    Local<Object> wrap,
    const Histogram::Options& options)
    : BaseObject(env, wrap),
      HistogramImpl(options) {
  MakeWeak();
}",1,1,histogram.cc,node.HistogramBase.HistogramBase,,false,43,50,HistogramBase,,,5,"ANY node.HistogramBase.HistogramBase (Environment*,Local<Object>,ANY)"
83539,METHOD,histogram.cc:<global>,TYPE_DECL,"HistogramBase::HistogramBase(
    Environment* env,
    Local<Object> wrap,
    std::shared_ptr<Histogram> histogram)
    : BaseObject(env, wrap),
      HistogramImpl(std::move(histogram)) {
  MakeWeak();
}",1,1,histogram.cc,node.HistogramBase.HistogramBase,,false,52,59,HistogramBase,,,6,"ANY node.HistogramBase.HistogramBase (Environment*,Local<Object>,ANY)"
83547,METHOD,histogram.cc:<global>,TYPE_DECL,"void HistogramBase::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""histogram"", histogram());
}",1,1,histogram.cc,node.HistogramBase.MemoryInfo,,false,61,63,MemoryInfo,,,7,void node.HistogramBase.MemoryInfo (MemoryTracker*)
83558,METHOD,histogram.cc:<global>,TYPE_DECL,"void HistogramBase::GetCount(const v8::FunctionCallbackInfo<v8::Value>& args) {
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Count());
  args.GetReturnValue().Set(value);
}",1,1,histogram.cc,node.HistogramBase.GetCount,,false,65,70,GetCount,,,8,void node.HistogramBase.GetCount (ANY)
83589,METHOD,histogram.cc:<global>,TYPE_DECL,"void HistogramBase::GetCountBigInt(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(
      BigInt::NewFromUnsigned(env->isolate(), (*histogram)->Count()));
}",1,1,histogram.cc,node.HistogramBase.GetCountBigInt,,false,72,79,GetCountBigInt,,,9,void node.HistogramBase.GetCountBigInt (ANY)
83630,METHOD,histogram.cc:<global>,TYPE_DECL,"void HistogramBase::GetMin(const FunctionCallbackInfo<Value>& args) {
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Min());
  args.GetReturnValue().Set(value);
}",1,1,histogram.cc,node.HistogramBase.GetMin,,false,81,86,GetMin,,,10,void node.HistogramBase.GetMin (FunctionCallbackInfo<Value>)
83661,METHOD,histogram.cc:<global>,TYPE_DECL,"void HistogramBase::GetMinBigInt(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(BigInt::New(env->isolate(), (*histogram)->Min()));
}",1,1,histogram.cc,node.HistogramBase.GetMinBigInt,,false,88,93,GetMinBigInt,,,11,void node.HistogramBase.GetMinBigInt (FunctionCallbackInfo<Value>)
83702,METHOD,histogram.cc:<global>,TYPE_DECL,"void HistogramBase::GetMax(const FunctionCallbackInfo<Value>& args) {
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Max());
  args.GetReturnValue().Set(value);
}",1,1,histogram.cc,node.HistogramBase.GetMax,,false,95,100,GetMax,,,12,void node.HistogramBase.GetMax (FunctionCallbackInfo<Value>)
83733,METHOD,histogram.cc:<global>,TYPE_DECL,"void HistogramBase::GetMaxBigInt(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(
      BigInt::New(env->isolate(), (*histogram)->Max()));
}",1,1,histogram.cc,node.HistogramBase.GetMaxBigInt,,false,102,108,GetMaxBigInt,,,13,void node.HistogramBase.GetMaxBigInt (FunctionCallbackInfo<Value>)
83774,METHOD,histogram.cc:<global>,TYPE_DECL,"void HistogramBase::GetMean(const FunctionCallbackInfo<Value>& args) {
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set((*histogram)->Mean());
}",1,1,histogram.cc,node.HistogramBase.GetMean,,false,110,114,GetMean,,,14,void node.HistogramBase.GetMean (FunctionCallbackInfo<Value>)
83799,METHOD,histogram.cc:<global>,TYPE_DECL,"void HistogramBase::GetExceeds(const FunctionCallbackInfo<Value>& args) {
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Exceeds());
  args.GetReturnValue().Set(value);
}",1,1,histogram.cc,node.HistogramBase.GetExceeds,,false,116,121,GetExceeds,,,15,void node.HistogramBase.GetExceeds (FunctionCallbackInfo<Value>)
83830,METHOD,histogram.cc:<global>,TYPE_DECL,"void HistogramBase::GetExceedsBigInt(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(
      BigInt::NewFromUnsigned(env->isolate(), (*histogram)->Exceeds()));
}",1,1,histogram.cc,node.HistogramBase.GetExceedsBigInt,,false,123,129,GetExceedsBigInt,,,16,void node.HistogramBase.GetExceedsBigInt (FunctionCallbackInfo<Value>)
83871,METHOD,histogram.cc:<global>,TYPE_DECL,"void HistogramBase::GetStddev(const FunctionCallbackInfo<Value>& args) {
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set((*histogram)->Stddev());
}",1,1,histogram.cc,node.HistogramBase.GetStddev,,false,131,135,GetStddev,,,17,void node.HistogramBase.GetStddev (FunctionCallbackInfo<Value>)
83896,METHOD,histogram.cc:<global>,TYPE_DECL,"void HistogramBase::GetPercentile(const FunctionCallbackInfo<Value>& args) {
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsNumber());
  double percentile = args[0].As<Number>()->Value();
  double value = static_cast<double>((*histogram)->Percentile(percentile));
  args.GetReturnValue().Set(value);
}",1,1,histogram.cc,node.HistogramBase.GetPercentile,,false,137,144,GetPercentile,,,18,void node.HistogramBase.GetPercentile (FunctionCallbackInfo<Value>)
83947,METHOD,histogram.cc:<global>,TYPE_DECL,"void HistogramBase::GetPercentileBigInt(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsNumber());
  double percentile = args[0].As<Number>()->Value();
  int64_t value = (*histogram)->Percentile(percentile);
  args.GetReturnValue().Set(BigInt::New(env->isolate(), value));
}",1,1,histogram.cc,node.HistogramBase.GetPercentileBigInt,,false,146,155,GetPercentileBigInt,,,19,void node.HistogramBase.GetPercentileBigInt (FunctionCallbackInfo<Value>)
84012,METHOD,histogram.cc:<global>,TYPE_DECL,"void HistogramBase::GetPercentiles(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsMap());
  Local<Map> map = args[0].As<Map>();
  (*histogram)->Percentiles([map, env](double key, int64_t value) {
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          Number::New(env->isolate(), static_cast<double>(value))));
  });
}",1,1,histogram.cc,node.HistogramBase.GetPercentiles,,false,157,169,GetPercentiles,,,20,void node.HistogramBase.GetPercentiles (FunctionCallbackInfo<Value>)
84057,METHOD,histogram.cc:<global>,TYPE_DECL,"void HistogramBase::GetPercentilesBigInt(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsMap());
  Local<Map> map = args[0].As<Map>();
  (*histogram)->Percentiles([map, env](double key, int64_t value) {
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          BigInt::New(env->isolate(), value)));
  });
}",1,1,histogram.cc,node.HistogramBase.GetPercentilesBigInt,,false,171,184,GetPercentilesBigInt,,,21,void node.HistogramBase.GetPercentilesBigInt (FunctionCallbackInfo<Value>)
84102,METHOD,histogram.cc:<global>,TYPE_DECL,"void HistogramBase::DoReset(const FunctionCallbackInfo<Value>& args) {
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  (*histogram)->Reset();
}",1,1,histogram.cc,node.HistogramBase.DoReset,,false,186,190,DoReset,,,22,void node.HistogramBase.DoReset (FunctionCallbackInfo<Value>)
84120,METHOD,histogram.cc:<global>,TYPE_DECL,"void HistogramBase::RecordDelta(const FunctionCallbackInfo<Value>& args) {
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  (*histogram)->RecordDelta();
}",1,1,histogram.cc,node.HistogramBase.RecordDelta,,false,192,196,RecordDelta,,,23,void node.HistogramBase.RecordDelta (FunctionCallbackInfo<Value>)
84138,METHOD,histogram.cc:<global>,TYPE_DECL,"void HistogramBase::Record(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK_IMPLIES(!args[0]->IsNumber(), args[0]->IsBigInt());
  bool lossless = true;
  int64_t value = args[0]->IsBigInt()
      ? args[0].As<BigInt>()->Int64Value(&lossless)
      : static_cast<int64_t>(args[0].As<Number>()->Value());
  if (!lossless || value < 1)
    return THROW_ERR_OUT_OF_RANGE(env, ""value is out of range"");
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  (*histogram)->Record(value);
}",1,1,histogram.cc,node.HistogramBase.Record,,false,198,210,Record,,,24,void node.HistogramBase.Record (FunctionCallbackInfo<Value>)
84227,METHOD,histogram.cc:<global>,TYPE_DECL,"void HistogramBase::Add(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());

  CHECK(GetConstructorTemplate(env->isolate_data())->HasInstance(args[0]));
  HistogramBase* other;
  ASSIGN_OR_RETURN_UNWRAP(&other, args[0]);

  double count = (*histogram)->Add(*(other->histogram()));
  args.GetReturnValue().Set(count);
}",1,1,histogram.cc,node.HistogramBase.Add,,false,212,223,Add,,,25,void node.HistogramBase.Add (FunctionCallbackInfo<Value>)
84288,METHOD,histogram.cc:<global>,TYPE_DECL,"BaseObjectPtr<HistogramBase> HistogramBase::Create(
    Environment* env,
    const Histogram::Options& options) {
  Local<Object> obj;
  if (!GetConstructorTemplate(env->isolate_data())
           ->InstanceTemplate()
           ->NewInstance(env->context())
           .ToLocal(&obj)) {
    return BaseObjectPtr<HistogramBase>();
  }

  return MakeBaseObject<HistogramBase>(env, obj, options);
}",1,1,histogram.cc,node.HistogramBase.Create,,false,225,237,Create,,,26,"BaseObjectPtr<HistogramBase> node.HistogramBase.Create (Environment*,ANY)"
84334,METHOD,histogram.cc:<global>,TYPE_DECL,"BaseObjectPtr<HistogramBase> HistogramBase::Create(
    Environment* env,
    std::shared_ptr<Histogram> histogram) {
  Local<Object> obj;
  if (!GetConstructorTemplate(env->isolate_data())
           ->InstanceTemplate()
           ->NewInstance(env->context())
           .ToLocal(&obj)) {
    return BaseObjectPtr<HistogramBase>();
  }
  return MakeBaseObject<HistogramBase>(env, obj, std::move(histogram));
}",1,1,histogram.cc,node.HistogramBase.Create,,false,239,250,Create,,,27,"BaseObjectPtr<HistogramBase> node.HistogramBase.Create (Environment*,ANY)"
84384,METHOD,histogram.cc:<global>,TYPE_DECL,"void HistogramBase::New(const FunctionCallbackInfo<Value>& args) {
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);

  CHECK_IMPLIES(!args[0]->IsNumber(), args[0]->IsBigInt());
  CHECK_IMPLIES(!args[1]->IsNumber(), args[1]->IsBigInt());
  CHECK(args[2]->IsUint32());

  int64_t lowest = 1;
  int64_t highest = std::numeric_limits<int64_t>::max();

  bool lossless_ignored;

  if (args[0]->IsNumber()) {
    lowest = args[0].As<Integer>()->Value();
  } else if (args[0]->IsBigInt()) {
    lowest = args[0].As<BigInt>()->Int64Value(&lossless_ignored);
  }

  if (args[1]->IsNumber()) {
    highest = args[1].As<Integer>()->Value();
  } else if (args[1]->IsBigInt()) {
    highest = args[1].As<BigInt>()->Int64Value(&lossless_ignored);
  }

  int32_t figures = args[2].As<Uint32>()->Value();
  new HistogramBase(env, args.This(), Histogram::Options {
    lowest, highest, figures
  });
}",1,1,histogram.cc,node.HistogramBase.New,,false,252,281,New,,,28,void node.HistogramBase.New (FunctionCallbackInfo<Value>)
84563,METHOD,histogram.cc:<global>,TYPE_DECL,"Local<FunctionTemplate> HistogramBase::GetConstructorTemplate(
    IsolateData* isolate_data) {
  Local<FunctionTemplate> tmpl = isolate_data->histogram_ctor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = isolate_data->isolate();
    tmpl = NewFunctionTemplate(isolate, New);
    Local<String> classname = FIXED_ONE_BYTE_STRING(isolate, ""Histogram"");
    tmpl->SetClassName(classname);

    tmpl->InstanceTemplate()->SetInternalFieldCount(
        HistogramBase::kInternalFieldCount);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""count"", GetCount);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""countBigInt"", GetCountBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""exceeds"", GetExceeds);
    SetProtoMethodNoSideEffect(
        isolate, tmpl, ""exceedsBigInt"", GetExceedsBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""min"", GetMin);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""minBigInt"", GetMinBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""max"", GetMax...",1,1,histogram.cc,node.HistogramBase.GetConstructorTemplate,,false,283,318,GetConstructorTemplate,,,29,Local<FunctionTemplate> node.HistogramBase.GetConstructorTemplate (IsolateData*)
84717,METHOD,histogram.cc:<global>,TYPE_DECL,"void HistogramBase::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(New);
  registry->Register(GetCount);
  registry->Register(GetCountBigInt);
  registry->Register(GetExceeds);
  registry->Register(GetExceedsBigInt);
  registry->Register(GetMin);
  registry->Register(GetMinBigInt);
  registry->Register(GetMax);
  registry->Register(GetMaxBigInt);
  registry->Register(GetMean);
  registry->Register(GetStddev);
  registry->Register(GetPercentile);
  registry->Register(GetPercentileBigInt);
  registry->Register(GetPercentiles);
  registry->Register(GetPercentilesBigInt);
  registry->Register(DoReset);
  registry->Register(Record);
  registry->Register(RecordDelta);
  registry->Register(Add);
}",1,1,histogram.cc,node.HistogramBase.RegisterExternalReferences,,false,320,341,RegisterExternalReferences,,,30,void node.HistogramBase.RegisterExternalReferences (ExternalReferenceRegistry*)
84817,METHOD,histogram.cc:<global>,TYPE_DECL,"void HistogramBase::Initialize(IsolateData* isolate_data,
                               Local<ObjectTemplate> target) {
  SetConstructorFunction(isolate_data->isolate(),
                         target,
                         ""Histogram"",
                         GetConstructorTemplate(isolate_data),
                         SetConstructorFunctionFlag::NONE);
}",1,1,histogram.cc,node.HistogramBase.Initialize,,false,343,350,Initialize,,,31,"void node.HistogramBase.Initialize (IsolateData*,Local<ObjectTemplate>)"
84835,METHOD,histogram.cc:<global>,TYPE_DECL,"BaseObjectPtr<BaseObject> HistogramBase::HistogramTransferData::Deserialize(
    Environment* env,
    v8::Local<v8::Context> context,
    std::unique_ptr<worker::TransferData> self) {
  return Create(env, std::move(histogram_));
}",1,1,histogram.cc,node.HistogramBase.HistogramTransferData.Deserialize,,false,352,357,Deserialize,,,32,"BaseObjectPtr<BaseObject> node.HistogramBase.HistogramTransferData.Deserialize (Environment*,ANY,ANY)"
84850,METHOD,histogram.cc:<global>,TYPE_DECL,"std::unique_ptr<worker::TransferData> HistogramBase::CloneForMessaging() const {
  return std::make_unique<HistogramTransferData>(this);
}",1,1,histogram.cc,node.HistogramBase.CloneForMessaging,,false,359,361,CloneForMessaging,,,33,unique_ptr<worker::TransferData> node.HistogramBase.CloneForMessaging ()
84862,METHOD,histogram.cc:<global>,TYPE_DECL,"void HistogramBase::HistogramTransferData::MemoryInfo(
    MemoryTracker* tracker) const {
  tracker->TrackField(""histogram"", histogram_);
}",1,1,histogram.cc,node.HistogramBase.HistogramTransferData.MemoryInfo,,false,363,366,MemoryInfo,,,34,void node.HistogramBase.HistogramTransferData.MemoryInfo (MemoryTracker*)
84873,METHOD,histogram.cc:<global>,TYPE_DECL,"Local<FunctionTemplate> IntervalHistogram::GetConstructorTemplate(
    Environment* env) {
  Local<FunctionTemplate> tmpl = env->intervalhistogram_constructor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->Inherit(HandleWrap::GetConstructorTemplate(env));
    tmpl->SetClassName(OneByteString(isolate, ""Histogram""));
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        HistogramBase::kInternalFieldCount);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""count"", GetCount);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""countBigInt"", GetCountBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""exceeds"", GetExceeds);
    SetProtoMethodNoSideEffect(
        isolate, tmpl, ""exceedsBigInt"", GetExceedsBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""min"", GetMin);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""minBigInt"", GetMinBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""max"", ...",1,1,histogram.cc,node.IntervalHistogram.GetConstructorTemplate,,false,368,401,GetConstructorTemplate,,,35,Local<FunctionTemplate> node.IntervalHistogram.GetConstructorTemplate (Environment*)
85024,METHOD,histogram.cc:<global>,TYPE_DECL,"void IntervalHistogram::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(GetCount);
  registry->Register(GetCountBigInt);
  registry->Register(GetExceeds);
  registry->Register(GetExceedsBigInt);
  registry->Register(GetMin);
  registry->Register(GetMinBigInt);
  registry->Register(GetMax);
  registry->Register(GetMaxBigInt);
  registry->Register(GetMean);
  registry->Register(GetStddev);
  registry->Register(GetPercentile);
  registry->Register(GetPercentileBigInt);
  registry->Register(GetPercentiles);
  registry->Register(GetPercentilesBigInt);
  registry->Register(DoReset);
  registry->Register(Start);
  registry->Register(Stop);
}",1,1,histogram.cc,node.IntervalHistogram.RegisterExternalReferences,,false,403,422,RegisterExternalReferences,,,36,void node.IntervalHistogram.RegisterExternalReferences (ExternalReferenceRegistry*)
85114,METHOD,histogram.cc:<global>,TYPE_DECL,"IntervalHistogram::IntervalHistogram(
    Environment* env,
    Local<Object> wrap,
    AsyncWrap::ProviderType type,
    int32_t interval,
    std::function<void(Histogram&)> on_interval,
    const Histogram::Options& options)
    : HandleWrap(
          env,
          wrap,
          reinterpret_cast<uv_handle_t*>(&timer_),
          type),
      HistogramImpl(options),
      interval_(interval),
      on_interval_(std::move(on_interval)) {
  MakeWeak();
  uv_timer_init(env->event_loop(), &timer_);
}",1,1,histogram.cc,node.IntervalHistogram.IntervalHistogram,,false,424,441,IntervalHistogram,,,37,"ANY node.IntervalHistogram.IntervalHistogram (Environment*,Local<Object>,ANY,int32_t,ANY,ANY)"
85132,METHOD,histogram.cc:<global>,TYPE_DECL,"BaseObjectPtr<IntervalHistogram> IntervalHistogram::Create(
    Environment* env,
    int32_t interval,
    std::function<void(Histogram&)> on_interval,
    const Histogram::Options& options) {
  Local<Object> obj;
  if (!GetConstructorTemplate(env)
          ->InstanceTemplate()
          ->NewInstance(env->context()).ToLocal(&obj)) {
    return BaseObjectPtr<IntervalHistogram>();
  }

  return MakeBaseObject<IntervalHistogram>(
      env,
      obj,
      AsyncWrap::PROVIDER_ELDHISTOGRAM,
      interval,
      std::move(on_interval),
      options);
}",1,1,histogram.cc,node.IntervalHistogram.Create,,false,443,462,Create,,,38,"BaseObjectPtr<IntervalHistogram> node.IntervalHistogram.Create (Environment*,int32_t,ANY,ANY)"
85186,METHOD,histogram.cc:<global>,TYPE_DECL,"void IntervalHistogram::TimerCB(uv_timer_t* handle) {
  IntervalHistogram* histogram =
      ContainerOf(&IntervalHistogram::timer_, handle);

  Histogram* h = histogram->histogram().get();

  histogram->on_interval_(*h);
}",1,1,histogram.cc,node.IntervalHistogram.TimerCB,,false,464,471,TimerCB,,,39,void node.IntervalHistogram.TimerCB (uv_timer_t*)
85216,METHOD,histogram.cc:<global>,TYPE_DECL,"void IntervalHistogram::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""histogram"", histogram());
}",1,1,histogram.cc,node.IntervalHistogram.MemoryInfo,,false,473,475,MemoryInfo,,,40,void node.IntervalHistogram.MemoryInfo (MemoryTracker*)
85227,METHOD,histogram.cc:<global>,TYPE_DECL,"void IntervalHistogram::OnStart(StartFlags flags) {
  if (enabled_ || IsHandleClosing()) return;
  enabled_ = true;
  if (flags == StartFlags::RESET)
    histogram()->Reset();
  uv_timer_start(&timer_, TimerCB, interval_, interval_);
  uv_unref(reinterpret_cast<uv_handle_t*>(&timer_));
}",1,1,histogram.cc,node.IntervalHistogram.OnStart,,false,477,484,OnStart,,,41,void node.IntervalHistogram.OnStart (StartFlags)
85263,METHOD,histogram.cc:<global>,TYPE_DECL,"void IntervalHistogram::OnStop() {
  if (!enabled_ || IsHandleClosing()) return;
  enabled_ = false;
  uv_timer_stop(&timer_);
}",1,1,histogram.cc,node.IntervalHistogram.OnStop,,false,486,490,OnStop,,,42,void node.IntervalHistogram.OnStop ()
85278,METHOD,histogram.cc:<global>,TYPE_DECL,"void IntervalHistogram::Start(const FunctionCallbackInfo<Value>& args) {
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  histogram->OnStart(args[0]->IsTrue() ? StartFlags::RESET : StartFlags::NONE);
}",1,1,histogram.cc,node.IntervalHistogram.Start,,false,492,496,Start,,,43,void node.IntervalHistogram.Start (FunctionCallbackInfo<Value>)
85308,METHOD,histogram.cc:<global>,TYPE_DECL,"void IntervalHistogram::Stop(const FunctionCallbackInfo<Value>& args) {
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  histogram->OnStop();
}",1,1,histogram.cc,node.IntervalHistogram.Stop,,false,498,502,Stop,,,44,void node.IntervalHistogram.Stop (FunctionCallbackInfo<Value>)
85325,METHOD,histogram.cc:<global>,TYPE_DECL,"void IntervalHistogram::GetCount(const FunctionCallbackInfo<Value>& args) {
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Count());
  args.GetReturnValue().Set(value);
}",1,1,histogram.cc,node.IntervalHistogram.GetCount,,false,504,509,GetCount,,,45,void node.IntervalHistogram.GetCount (FunctionCallbackInfo<Value>)
85356,METHOD,histogram.cc:<global>,TYPE_DECL,"void IntervalHistogram::GetCountBigInt(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(
      BigInt::NewFromUnsigned(env->isolate(), (*histogram)->Count()));
}",1,1,histogram.cc,node.IntervalHistogram.GetCountBigInt,,false,511,518,GetCountBigInt,,,46,void node.IntervalHistogram.GetCountBigInt (ANY)
85397,METHOD,histogram.cc:<global>,TYPE_DECL,"void IntervalHistogram::GetMin(const FunctionCallbackInfo<Value>& args) {
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Min());
  args.GetReturnValue().Set(value);
}",1,1,histogram.cc,node.IntervalHistogram.GetMin,,false,520,525,GetMin,,,47,void node.IntervalHistogram.GetMin (FunctionCallbackInfo<Value>)
85428,METHOD,histogram.cc:<global>,TYPE_DECL,"void IntervalHistogram::GetMinBigInt(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(BigInt::New(env->isolate(), (*histogram)->Min()));
}",1,1,histogram.cc,node.IntervalHistogram.GetMinBigInt,,false,527,532,GetMinBigInt,,,48,void node.IntervalHistogram.GetMinBigInt (FunctionCallbackInfo<Value>)
85469,METHOD,histogram.cc:<global>,TYPE_DECL,"void IntervalHistogram::GetMax(const FunctionCallbackInfo<Value>& args) {
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Max());
  args.GetReturnValue().Set(value);
}",1,1,histogram.cc,node.IntervalHistogram.GetMax,,false,534,539,GetMax,,,49,void node.IntervalHistogram.GetMax (FunctionCallbackInfo<Value>)
85500,METHOD,histogram.cc:<global>,TYPE_DECL,"void IntervalHistogram::GetMaxBigInt(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(BigInt::New(env->isolate(), (*histogram)->Min()));
}",1,1,histogram.cc,node.IntervalHistogram.GetMaxBigInt,,false,541,546,GetMaxBigInt,,,50,void node.IntervalHistogram.GetMaxBigInt (FunctionCallbackInfo<Value>)
85541,METHOD,histogram.cc:<global>,TYPE_DECL,"void IntervalHistogram::GetMean(const FunctionCallbackInfo<Value>& args) {
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set((*histogram)->Mean());
}",1,1,histogram.cc,node.IntervalHistogram.GetMean,,false,548,552,GetMean,,,51,void node.IntervalHistogram.GetMean (FunctionCallbackInfo<Value>)
85566,METHOD,histogram.cc:<global>,TYPE_DECL,"void IntervalHistogram::GetExceeds(const FunctionCallbackInfo<Value>& args) {
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Exceeds());
  args.GetReturnValue().Set(value);
}",1,1,histogram.cc,node.IntervalHistogram.GetExceeds,,false,554,559,GetExceeds,,,52,void node.IntervalHistogram.GetExceeds (FunctionCallbackInfo<Value>)
85597,METHOD,histogram.cc:<global>,TYPE_DECL,"void IntervalHistogram::GetExceedsBigInt(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(
      BigInt::New(env->isolate(), (*histogram)->Exceeds()));
}",1,1,histogram.cc,node.IntervalHistogram.GetExceedsBigInt,,false,561,568,GetExceedsBigInt,,,53,void node.IntervalHistogram.GetExceedsBigInt (FunctionCallbackInfo<Value>)
85638,METHOD,histogram.cc:<global>,TYPE_DECL,"void IntervalHistogram::GetStddev(const FunctionCallbackInfo<Value>& args) {
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set((*histogram)->Stddev());
}",1,1,histogram.cc,node.IntervalHistogram.GetStddev,,false,570,574,GetStddev,,,54,void node.IntervalHistogram.GetStddev (FunctionCallbackInfo<Value>)
85663,METHOD,histogram.cc:<global>,TYPE_DECL,"void IntervalHistogram::GetPercentile(const FunctionCallbackInfo<Value>& args) {
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsNumber());
  double percentile = args[0].As<Number>()->Value();
  double value = static_cast<double>((*histogram)->Percentile(percentile));
  args.GetReturnValue().Set(value);
}",1,1,histogram.cc,node.IntervalHistogram.GetPercentile,,false,576,583,GetPercentile,,,55,void node.IntervalHistogram.GetPercentile (FunctionCallbackInfo<Value>)
85714,METHOD,histogram.cc:<global>,TYPE_DECL,"void IntervalHistogram::GetPercentileBigInt(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsNumber());
  double percentile = args[0].As<Number>()->Value();
  int64_t value = (*histogram)->Percentile(percentile);
  args.GetReturnValue().Set(BigInt::New(env->isolate(), value));
}",1,1,histogram.cc,node.IntervalHistogram.GetPercentileBigInt,,false,585,594,GetPercentileBigInt,,,56,void node.IntervalHistogram.GetPercentileBigInt (FunctionCallbackInfo<Value>)
85779,METHOD,histogram.cc:<global>,TYPE_DECL,"void IntervalHistogram::GetPercentiles(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsMap());
  Local<Map> map = args[0].As<Map>();
  (*histogram)->Percentiles([map, env](double key, int64_t value) {
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          Number::New(env->isolate(), static_cast<double>(value))));
  });
}",1,1,histogram.cc,node.IntervalHistogram.GetPercentiles,,false,596,609,GetPercentiles,,,57,void node.IntervalHistogram.GetPercentiles (FunctionCallbackInfo<Value>)
85824,METHOD,histogram.cc:<global>,TYPE_DECL,"void IntervalHistogram::GetPercentilesBigInt(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsMap());
  Local<Map> map = args[0].As<Map>();
  (*histogram)->Percentiles([map, env](double key, int64_t value) {
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          BigInt::New(env->isolate(), value)));
  });
}",1,1,histogram.cc,node.IntervalHistogram.GetPercentilesBigInt,,false,611,624,GetPercentilesBigInt,,,58,void node.IntervalHistogram.GetPercentilesBigInt (FunctionCallbackInfo<Value>)
85869,METHOD,histogram.cc:<global>,TYPE_DECL,"void IntervalHistogram::DoReset(const FunctionCallbackInfo<Value>& args) {
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  (*histogram)->Reset();
}",1,1,histogram.cc,node.IntervalHistogram.DoReset,,false,626,630,DoReset,,,59,void node.IntervalHistogram.DoReset (FunctionCallbackInfo<Value>)
85887,METHOD,histogram.cc:<global>,TYPE_DECL,"std::unique_ptr<worker::TransferData>
IntervalHistogram::CloneForMessaging() const {
  return std::make_unique<HistogramBase::HistogramTransferData>(histogram());
}",1,1,histogram.cc,node.IntervalHistogram.CloneForMessaging,,false,632,635,CloneForMessaging,,,60,unique_ptr<worker::TransferData> node.IntervalHistogram.CloneForMessaging ()
85926,METHOD,histogram.hpp:<global>,TYPE_DECL,<global>,1,27,histogram.hpp,histogram.hpp:<global>,,false,1,240,<global>,,,1,
85929,METHOD,node.inspector.anonymous_namespace_34.ThreadSafeDelegate,TYPE_DECL,"[m = StringBuffer::create(message)]
        (InspectorSessionDelegate* delegate) {
      delegate->SendMessageToFrontend(m->string());
    }",9,5,inspector\main_thread_interface.cc,node.inspector.anonymous_namespace_37.ThreadSafeDelegate.SendMessageToFrontend.<lambda>0,,false,187,190,<lambda>0,,,1,ANY node.inspector.anonymous_namespace_37.ThreadSafeDelegate.SendMessageToFrontend.<lambda>0 (InspectorSessionDelegate*)
85944,METHOD,inspector\main_thread_interface.cc:<global>,TYPE_DECL,"[weak_self](Environment*) {
      if (auto iface = weak_self.lock()) iface->DispatchMessages();
    }",37,5,inspector\main_thread_interface.cc,node.inspector.MainThreadInterface.Post.<lambda>1,,false,214,216,<lambda>1,,,1,ANY node.inspector.MainThreadInterface.Post.<lambda>1 (Environment*)
85979,METHOD,inspector\main_thread_interface.cc:<global>,TYPE_DECL,<global>,1,1,inspector\main_thread_interface.hpp,inspector\main_thread_interface.cc:<global>,,false,1,335,<global>,,,1,
85985,METHOD,node.inspector.anonymous_namespace_3.DeletableWrapper,TYPE_DECL,"explicit DeletableWrapper(std::unique_ptr<T> object)
                        : object_(std::move(object)) {}",3,55,inspector\main_thread_interface.cc,node.inspector.anonymous_namespace_4.DeletableWrapper.DeletableWrapper,,false,20,21,DeletableWrapper,,,1,ANY node.inspector.anonymous_namespace_4.DeletableWrapper.DeletableWrapper (ANY)
85990,METHOD,node.inspector.anonymous_namespace_3.DeletableWrapper,TYPE_DECL,~DeletableWrapper() override = default;,3,41,inspector\main_thread_interface.cc,node.inspector.anonymous_namespace_5.DeletableWrapper.~DeletableWrapper,,false,22,22,~DeletableWrapper,,,2,ANY node.inspector.anonymous_namespace_5.DeletableWrapper.~DeletableWrapper ()
85994,METHOD,node.inspector.anonymous_namespace_3.DeletableWrapper,TYPE_DECL,"static T* get(MainThreadInterface* thread, int id) {
    return
        static_cast<DeletableWrapper<T>*>(thread->GetObject(id))->object_.get();
  }",3,3,inspector\main_thread_interface.cc,node.inspector.anonymous_namespace_6.DeletableWrapper.get,,false,24,27,get,,,3,"T node.inspector.anonymous_namespace_6.DeletableWrapper.get (MainThreadInterface*,int)"
86014,METHOD,inspector\main_thread_interface.cc:<global>,TYPE_DECL,"std::unique_ptr<Deletable> WrapInDeletable(std::unique_ptr<T> object) {
  return std::unique_ptr<DeletableWrapper<T>>(
      new DeletableWrapper<T>(std::move(object)));
}",1,1,inspector\main_thread_interface.cc,node.inspector.anonymous_namespace_7.WrapInDeletable,,false,34,37,WrapInDeletable,,,2,unique_ptr<Deletable> node.inspector.anonymous_namespace_7.WrapInDeletable<T> (ANY)
86036,METHOD,node.inspector.anonymous_namespace_8.CreateObjectRequest,TYPE_DECL,"CreateObjectRequest(int object_id, Factory factory)
                      : object_id_(object_id), factory_(std::move(factory)) {}",3,78,inspector\main_thread_interface.cc,node.inspector.anonymous_namespace_9.CreateObjectRequest.CreateObjectRequest,,false,42,43,CreateObjectRequest,,,1,"ANY node.inspector.anonymous_namespace_9.CreateObjectRequest.CreateObjectRequest (int,Factory)"
86042,METHOD,node.inspector.anonymous_namespace_8.CreateObjectRequest,TYPE_DECL,"void Call(MainThreadInterface* thread) override {
    thread->AddObject(object_id_, WrapInDeletable(factory_(thread)));
  }",3,3,inspector\main_thread_interface.cc,node.inspector.anonymous_namespace_10.CreateObjectRequest.Call,,false,45,47,Call,,,2,void node.inspector.anonymous_namespace_10.CreateObjectRequest.Call (MainThreadInterface*)
86057,METHOD,inspector\main_thread_interface.cc:<global>,TYPE_DECL,"std::unique_ptr<Request> NewCreateRequest(int object_id, Factory factory) {
  return std::unique_ptr<Request>(
      new CreateObjectRequest<Factory>(object_id, std::move(factory)));
}",1,1,inspector\main_thread_interface.cc,node.inspector.anonymous_namespace_11.NewCreateRequest,,false,55,58,NewCreateRequest,,,4,"unique_ptr<Request> node.inspector.anonymous_namespace_11.NewCreateRequest<Factory> (int,Factory)"
86079,METHOD,node.inspector.anonymous_namespace_12.DeleteRequest,TYPE_DECL,explicit DeleteRequest(int object_id) : object_id_(object_id) {},3,66,inspector\main_thread_interface.cc,node.inspector.anonymous_namespace_13.DeleteRequest.DeleteRequest,,false,62,62,DeleteRequest,,,1,ANY node.inspector.anonymous_namespace_13.DeleteRequest.DeleteRequest (int)
86084,METHOD,node.inspector.anonymous_namespace_12.DeleteRequest,TYPE_DECL,"void Call(MainThreadInterface* thread) override {
    thread->RemoveObject(object_id_);
  }",3,3,inspector\main_thread_interface.cc,node.inspector.anonymous_namespace_14.DeleteRequest.Call,,false,64,66,Call,,,2,void node.inspector.anonymous_namespace_14.DeleteRequest.Call (MainThreadInterface*)
86096,METHOD,node.inspector.anonymous_namespace_15.CallRequest,TYPE_DECL,"CallRequest(int id, Fn fn) : id_(id), fn_(std::move(fn)) {}",3,61,inspector\main_thread_interface.cc,node.inspector.anonymous_namespace_16.CallRequest.CallRequest,,false,75,75,CallRequest,,,1,"ANY node.inspector.anonymous_namespace_16.CallRequest.CallRequest (int,Fn)"
86102,METHOD,node.inspector.anonymous_namespace_15.CallRequest,TYPE_DECL,"void Call(MainThreadInterface* thread) override {
    fn_(DeletableWrapper<Target>::get(thread, id_));
  }",3,3,inspector\main_thread_interface.cc,node.inspector.anonymous_namespace_17.CallRequest.Call,,false,77,79,Call,,,2,void node.inspector.anonymous_namespace_17.CallRequest.Call (MainThreadInterface*)
86117,METHOD,node.inspector.anonymous_namespace_18.AnotherThreadObjectReference,TYPE_DECL,"AnotherThreadObjectReference(
      std::shared_ptr<MainThreadHandle> thread, int object_id)
      : thread_(thread), object_id_(object_id) {}",3,49,inspector\main_thread_interface.cc,node.inspector.anonymous_namespace_19.AnotherThreadObjectReference.AnotherThreadObjectReference,,false,89,91,AnotherThreadObjectReference,,,1,"ANY node.inspector.anonymous_namespace_19.AnotherThreadObjectReference.AnotherThreadObjectReference (ANY,int)"
86123,METHOD,node.inspector.anonymous_namespace_18.AnotherThreadObjectReference,TYPE_DECL,"AnotherThreadObjectReference(
      std::shared_ptr<MainThreadHandle> thread, Factory factory)
      : AnotherThreadObjectReference(thread, thread->newObjectId()) {
    thread_->Post(NewCreateRequest(object_id_, std::move(factory)));
  }",3,3,inspector\main_thread_interface.cc,node.inspector.anonymous_namespace_20.AnotherThreadObjectReference.AnotherThreadObjectReference,,false,94,98,AnotherThreadObjectReference,,,2,"ANY node.inspector.anonymous_namespace_20.AnotherThreadObjectReference.AnotherThreadObjectReference<Factory> (ANY,Factory)"
86140,METHOD,node.inspector.anonymous_namespace_18.AnotherThreadObjectReference,TYPE_DECL,AnotherThreadObjectReference(AnotherThreadObjectReference&) = delete;,3,71,inspector\main_thread_interface.cc,node.inspector.anonymous_namespace_21.AnotherThreadObjectReference.AnotherThreadObjectReference,,false,99,99,AnotherThreadObjectReference,,,3,ANY node.inspector.anonymous_namespace_21.AnotherThreadObjectReference.AnotherThreadObjectReference (AnotherThreadObjectReference)
86145,METHOD,node.inspector.anonymous_namespace_18.AnotherThreadObjectReference,TYPE_DECL,"~AnotherThreadObjectReference() {
    // Disappearing thread may cause a memory leak
    thread_->Post(std::make_unique<DeleteRequest>(object_id_));
  }",3,3,inspector\main_thread_interface.cc,node.inspector.anonymous_namespace_22.AnotherThreadObjectReference.~AnotherThreadObjectReference,,false,101,104,~AnotherThreadObjectReference,,,4,ANY node.inspector.anonymous_namespace_22.AnotherThreadObjectReference.~AnotherThreadObjectReference ()
86160,METHOD,node.inspector.anonymous_namespace_18.AnotherThreadObjectReference,TYPE_DECL,"void Call(Fn fn) const {
    using Request = CallRequest<T, Fn>;
    thread_->Post(std::unique_ptr<Request>(
        new Request(object_id_, std::move(fn))));
  }",3,3,inspector\main_thread_interface.cc,node.inspector.anonymous_namespace_23.AnotherThreadObjectReference.Call,,false,107,111,Call,,,5,void node.inspector.anonymous_namespace_23.AnotherThreadObjectReference.Call<Fn> (Fn)
86184,METHOD,node.inspector.anonymous_namespace_18.AnotherThreadObjectReference,TYPE_DECL,"void Call(void (T::*fn)(Arg), Arg argument) const {
    Call(std::bind(Apply<Arg>, std::placeholders::_1, fn, std::move(argument)));
  }",3,3,inspector\main_thread_interface.cc,node.inspector.anonymous_namespace_24.AnotherThreadObjectReference.Call,,false,114,116,Call,,,6,"void node.inspector.anonymous_namespace_24.AnotherThreadObjectReference.Call<Arg> (void,Arg)"
86207,METHOD,node.inspector.anonymous_namespace_18.AnotherThreadObjectReference,TYPE_DECL,"static void Apply(T* target, void (T::*fn)(Argument),
    /* NOLINT (runtime/references) */ Argument& argument) {
    (target->*fn)(std::move(argument));
  }",3,3,inspector\main_thread_interface.cc,node.inspector.anonymous_namespace_25.AnotherThreadObjectReference.Apply,,false,122,125,Apply,,,7,"void node.inspector.anonymous_namespace_25.AnotherThreadObjectReference.Apply<Argument> (T*,void,Argument)"
86226,METHOD,node.inspector.anonymous_namespace_26.MainThreadSessionState,TYPE_DECL,"MainThreadSessionState(MainThreadInterface* thread, bool prevent_shutdown)
                         : thread_(thread),
                           prevent_shutdown_(prevent_shutdown) {}",3,65,inspector\main_thread_interface.cc,node.inspector.anonymous_namespace_27.MainThreadSessionState.MainThreadSessionState,,false,133,135,MainThreadSessionState,,,1,"ANY node.inspector.anonymous_namespace_27.MainThreadSessionState.MainThreadSessionState (MainThreadInterface*,bool)"
86232,METHOD,node.inspector.anonymous_namespace_26.MainThreadSessionState,TYPE_DECL,"static std::unique_ptr<MainThreadSessionState> Create(
      MainThreadInterface* thread, bool prevent_shutdown) {
    return std::make_unique<MainThreadSessionState>(thread, prevent_shutdown);
  }",3,3,inspector\main_thread_interface.cc,node.inspector.anonymous_namespace_28.MainThreadSessionState.Create,,false,137,140,Create,,,2,"unique_ptr<MainThreadSessionState> node.inspector.anonymous_namespace_28.MainThreadSessionState.Create (MainThreadInterface*,bool)"
86249,METHOD,node.inspector.anonymous_namespace_26.MainThreadSessionState,TYPE_DECL,"void Connect(std::unique_ptr<InspectorSessionDelegate> delegate) {
    Agent* agent = thread_->inspector_agent();
    if (agent != nullptr)
      session_ = agent->Connect(std::move(delegate), prevent_shutdown_);
  }",3,3,inspector\main_thread_interface.cc,node.inspector.anonymous_namespace_29.MainThreadSessionState.Connect,,false,142,146,Connect,,,3,void node.inspector.anonymous_namespace_29.MainThreadSessionState.Connect (ANY)
86278,METHOD,node.inspector.anonymous_namespace_26.MainThreadSessionState,TYPE_DECL,"void Dispatch(std::unique_ptr<StringBuffer> message) {
    session_->Dispatch(message->string());
  }",3,3,inspector\main_thread_interface.cc,node.inspector.anonymous_namespace_30.MainThreadSessionState.Dispatch,,false,148,150,Dispatch,,,4,void node.inspector.anonymous_namespace_30.MainThreadSessionState.Dispatch (ANY)
86295,METHOD,node.inspector.anonymous_namespace_31.CrossThreadInspectorSession,TYPE_DECL,"CrossThreadInspectorSession(
      int id,
      std::shared_ptr<MainThreadHandle> thread,
      std::unique_ptr<InspectorSessionDelegate> delegate,
      bool prevent_shutdown)
      : state_(thread, std::bind(MainThreadSessionState::Create,
                                 std::placeholders::_1,
                                 prevent_shutdown)) {
    state_.Call(&MainThreadSessionState::Connect, std::move(delegate));
  }",3,3,inspector\main_thread_interface.cc,node.inspector.anonymous_namespace_32.CrossThreadInspectorSession.CrossThreadInspectorSession,,false,160,169,CrossThreadInspectorSession,,,1,"ANY node.inspector.anonymous_namespace_32.CrossThreadInspectorSession.CrossThreadInspectorSession (int,ANY,ANY,bool)"
86316,METHOD,node.inspector.anonymous_namespace_31.CrossThreadInspectorSession,TYPE_DECL,"void Dispatch(const StringView& message) override {
    state_.Call(&MainThreadSessionState::Dispatch,
                StringBuffer::create(message));
  }",3,3,inspector\main_thread_interface.cc,node.inspector.anonymous_namespace_33.CrossThreadInspectorSession.Dispatch,,false,171,174,Dispatch,,,2,void node.inspector.anonymous_namespace_33.CrossThreadInspectorSession.Dispatch (StringView)
86335,METHOD,node.inspector.anonymous_namespace_34.ThreadSafeDelegate,TYPE_DECL,"ThreadSafeDelegate(std::shared_ptr<MainThreadHandle> thread, int object_id)
                     : thread_(thread), delegate_(thread, object_id) {}",3,71,inspector\main_thread_interface.cc,node.inspector.anonymous_namespace_35.ThreadSafeDelegate.ThreadSafeDelegate,,false,182,183,ThreadSafeDelegate,,,1,"ANY node.inspector.anonymous_namespace_35.ThreadSafeDelegate.ThreadSafeDelegate (ANY,int)"
86341,METHOD,node.inspector.anonymous_namespace_34.ThreadSafeDelegate,TYPE_DECL,"void SendMessageToFrontend(const v8_inspector::StringView& message) override {
    delegate_.Call(
        [m = StringBuffer::create(message)]
        (InspectorSessionDelegate* delegate) {
      delegate->SendMessageToFrontend(m->string());
    });
  }",3,3,inspector\main_thread_interface.cc,node.inspector.anonymous_namespace_36.ThreadSafeDelegate.SendMessageToFrontend,,false,185,191,SendMessageToFrontend,,,2,void node.inspector.anonymous_namespace_36.ThreadSafeDelegate.SendMessageToFrontend (ANY)
86353,METHOD,inspector\main_thread_interface.cc:<global>,TYPE_DECL,MainThreadInterface::MainThreadInterface(Agent* agent) : agent_(agent) {},1,73,inspector\main_thread_interface.cc,node.inspector.MainThreadInterface.MainThreadInterface,,false,200,200,MainThreadInterface,,,2,ANY node.inspector.MainThreadInterface.MainThreadInterface (Agent*)
86358,METHOD,inspector\main_thread_interface.cc:<global>,TYPE_DECL,"MainThreadInterface::~MainThreadInterface() {
  if (handle_)
    handle_->Reset();
}",1,1,inspector\main_thread_interface.cc,node.inspector.MainThreadInterface.~MainThreadInterface,,false,202,205,~MainThreadInterface,,,3,ANY node.inspector.MainThreadInterface.~MainThreadInterface ()
86369,METHOD,inspector\main_thread_interface.cc:<global>,TYPE_DECL,"void MainThreadInterface::Post(std::unique_ptr<Request> request) {
  CHECK_NOT_NULL(agent_);
  Mutex::ScopedLock scoped_lock(requests_lock_);
  bool needs_notify = requests_.empty();
  requests_.push_back(std::move(request));
  if (needs_notify) {
    std::weak_ptr<MainThreadInterface> weak_self {shared_from_this()};
    agent_->env()->RequestInterrupt([weak_self](Environment*) {
      if (auto iface = weak_self.lock()) iface->DispatchMessages();
    });
  }
  incoming_message_cond_.Broadcast(scoped_lock);
}",1,1,inspector\main_thread_interface.cc,node.inspector.MainThreadInterface.Post,,false,207,219,Post,,,4,void node.inspector.MainThreadInterface.Post (ANY)
86415,METHOD,inspector\main_thread_interface.cc:<global>,TYPE_DECL,"bool MainThreadInterface::WaitForFrontendEvent() {
  // We allow DispatchMessages reentry as we enter the pause. This is important
  // to support debugging the code invoked by an inspector call, such
  // as Runtime.evaluate
  dispatching_messages_ = false;
  if (dispatching_message_queue_.empty()) {
    Mutex::ScopedLock scoped_lock(requests_lock_);
    while (requests_.empty()) incoming_message_cond_.Wait(scoped_lock);
  }
  return true;
}",1,1,inspector\main_thread_interface.cc,node.inspector.MainThreadInterface.WaitForFrontendEvent,,false,221,231,WaitForFrontendEvent,,,5,bool node.inspector.MainThreadInterface.WaitForFrontendEvent ()
86443,METHOD,inspector\main_thread_interface.cc:<global>,TYPE_DECL,"void MainThreadInterface::DispatchMessages() {
  if (dispatching_messages_)
    return;
  dispatching_messages_ = true;
  bool had_messages = false;
  do {
    if (dispatching_message_queue_.empty()) {
      Mutex::ScopedLock scoped_lock(requests_lock_);
      requests_.swap(dispatching_message_queue_);
    }
    had_messages = !dispatching_message_queue_.empty();
    while (!dispatching_message_queue_.empty()) {
      MessageQueue::value_type task;
      std::swap(dispatching_message_queue_.front(), task);
      dispatching_message_queue_.pop_front();

      v8::SealHandleScope seal_handle_scope(agent_->env()->isolate());
      task->Call(this);
    }
  } while (had_messages);
  dispatching_messages_ = false;
}",1,1,inspector\main_thread_interface.cc,node.inspector.MainThreadInterface.DispatchMessages,,false,233,254,DispatchMessages,,,6,void node.inspector.MainThreadInterface.DispatchMessages ()
86520,METHOD,inspector\main_thread_interface.cc:<global>,TYPE_DECL,"std::shared_ptr<MainThreadHandle> MainThreadInterface::GetHandle() {
  if (handle_ == nullptr)
    handle_ = std::make_shared<MainThreadHandle>(this);
  return handle_;
}",1,1,inspector\main_thread_interface.cc,node.inspector.MainThreadInterface.GetHandle,,false,256,260,GetHandle,,,7,shared_ptr<MainThreadHandle> node.inspector.MainThreadInterface.GetHandle ()
86540,METHOD,inspector\main_thread_interface.cc:<global>,TYPE_DECL,"void MainThreadInterface::AddObject(int id,
                                    std::unique_ptr<Deletable> object) {
  CHECK_NOT_NULL(object);
  managed_objects_[id] = std::move(object);
}",1,1,inspector\main_thread_interface.cc,node.inspector.MainThreadInterface.AddObject,,false,262,266,AddObject,,,8,"void node.inspector.MainThreadInterface.AddObject (int,ANY)"
86557,METHOD,inspector\main_thread_interface.cc:<global>,TYPE_DECL,"void MainThreadInterface::RemoveObject(int id) {
  CHECK_EQ(1, managed_objects_.erase(id));
}",1,1,inspector\main_thread_interface.cc,node.inspector.MainThreadInterface.RemoveObject,,false,268,270,RemoveObject,,,9,void node.inspector.MainThreadInterface.RemoveObject (int)
86569,METHOD,inspector\main_thread_interface.cc:<global>,TYPE_DECL,"Deletable* MainThreadInterface::GetObject(int id) {
  Deletable* pointer = GetObjectIfExists(id);
  // This would mean the object is requested after it was disposed, which is
  // a coding error.
  CHECK_NOT_NULL(pointer);
  return pointer;
}",1,1,inspector\main_thread_interface.cc,node.inspector.MainThreadInterface.GetObject,,false,272,278,GetObject,,,10,Deletable node.inspector.MainThreadInterface.GetObject (int)
86583,METHOD,inspector\main_thread_interface.cc:<global>,TYPE_DECL,"Deletable* MainThreadInterface::GetObjectIfExists(int id) {
  auto iterator = managed_objects_.find(id);
  if (iterator == managed_objects_.end()) {
    return nullptr;
  }
  return iterator->second.get();
}",1,1,inspector\main_thread_interface.cc,node.inspector.MainThreadInterface.GetObjectIfExists,,false,280,286,GetObjectIfExists,,,11,Deletable node.inspector.MainThreadInterface.GetObjectIfExists (int)
86613,METHOD,inspector\main_thread_interface.cc:<global>,TYPE_DECL,"std::unique_ptr<StringBuffer> Utf8ToStringView(const std::string_view message) {
  size_t expected_u16_length =
      simdutf::utf16_length_from_utf8(message.data(), message.length());
  MaybeStackBuffer<char16_t> buffer(expected_u16_length);
  size_t utf16_length = simdutf::convert_utf8_to_utf16(
      message.data(), message.length(), buffer.out());
  StringView view(reinterpret_cast<uint16_t*>(buffer.out()), utf16_length);
  return StringBuffer::create(view);
}",1,1,inspector\main_thread_interface.cc,node.inspector.Utf8ToStringView,,false,288,296,Utf8ToStringView,,,12,unique_ptr<StringBuffer> node.inspector.Utf8ToStringView (ANY)
86670,METHOD,inspector\main_thread_interface.cc:<global>,TYPE_DECL,"std::unique_ptr<InspectorSession> MainThreadHandle::Connect(
    std::unique_ptr<InspectorSessionDelegate> delegate,
    bool prevent_shutdown) {
  return std::unique_ptr<InspectorSession>(
      new CrossThreadInspectorSession(++next_session_id_,
                                      shared_from_this(),
                                      std::move(delegate),
                                      prevent_shutdown));
}",1,1,inspector\main_thread_interface.cc,node.inspector.MainThreadHandle.Connect,,false,298,306,Connect,,,13,"unique_ptr<InspectorSession> node.inspector.MainThreadHandle.Connect (ANY,bool)"
86694,METHOD,inspector\main_thread_interface.cc:<global>,TYPE_DECL,"bool MainThreadHandle::Post(std::unique_ptr<Request> request) {
  Mutex::ScopedLock scoped_lock(block_lock_);
  if (!main_thread_)
    return false;
  main_thread_->Post(std::move(request));
  return true;
}",1,1,inspector\main_thread_interface.cc,node.inspector.MainThreadHandle.Post,,false,308,314,Post,,,14,bool node.inspector.MainThreadHandle.Post (ANY)
86719,METHOD,inspector\main_thread_interface.cc:<global>,TYPE_DECL,"void MainThreadHandle::Reset() {
  Mutex::ScopedLock scoped_lock(block_lock_);
  main_thread_ = nullptr;
}",1,1,inspector\main_thread_interface.cc,node.inspector.MainThreadHandle.Reset,,false,316,319,Reset,,,15,void node.inspector.MainThreadHandle.Reset ()
86729,METHOD,inspector\main_thread_interface.cc:<global>,TYPE_DECL,"std::unique_ptr<InspectorSessionDelegate>
MainThreadHandle::MakeDelegateThreadSafe(
    std::unique_ptr<InspectorSessionDelegate> delegate) {
  int id = newObjectId();
  main_thread_->AddObject(id, WrapInDeletable(std::move(delegate)));
  return std::unique_ptr<InspectorSessionDelegate>(
      new ThreadSafeDelegate(shared_from_this(), id));
}",1,1,inspector\main_thread_interface.cc,node.inspector.MainThreadHandle.MakeDelegateThreadSafe,,false,321,328,MakeDelegateThreadSafe,,,16,unique_ptr<InspectorSessionDelegate> node.inspector.MainThreadHandle.MakeDelegateThreadSafe (ANY)
86760,METHOD,inspector\main_thread_interface.cc:<global>,TYPE_DECL,"bool MainThreadHandle::Expired() {
  Mutex::ScopedLock scoped_lock(block_lock_);
  return main_thread_ == nullptr;
}",1,1,inspector\main_thread_interface.cc,node.inspector.MainThreadHandle.Expired,,false,330,333,Expired,,,17,bool node.inspector.MainThreadHandle.Expired ()
86786,METHOD,inspector\main_thread_interface.hpp:<global>,TYPE_DECL,<global>,1,1,inspector\main_thread_interface.hpp,inspector\main_thread_interface.hpp:<global>,,false,1,106,<global>,,,1,
86795,METHOD,node.inspector.Request,TYPE_DECL,virtual void Call(MainThreadInterface*) = 0;,16,45,inspector\main_thread_interface.hpp,node.inspector.Request.Call,,false,27,27,Call,,,1,void node.inspector.Request.Call (MainThreadInterface*)
86800,METHOD,node.inspector.Request,TYPE_DECL,virtual ~Request() = default;,3,31,inspector\main_thread_interface.hpp,node.inspector.Request.~Request,,false,28,28,~Request,,,2,ANY node.inspector.Request.~Request ()
86805,METHOD,node.inspector.Deletable,TYPE_DECL,virtual ~Deletable() = default;,3,33,inspector\main_thread_interface.hpp,node.inspector.Deletable.~Deletable,,false,33,33,~Deletable,,,1,ANY node.inspector.Deletable.~Deletable ()
86809,METHOD,inspector\main_thread_interface.hpp:<global>,TYPE_DECL,"std::unique_ptr<v8_inspector::StringBuffer> Utf8ToStringView(
    const std::string_view message);",45,35,inspector\main_thread_interface.hpp,node.inspector.Utf8ToStringView,,false,36,37,Utf8ToStringView,,,4,ANY node.inspector.Utf8ToStringView (ANY)
86816,METHOD,node.inspector.MainThreadHandle,TYPE_DECL,"explicit MainThreadHandle(MainThreadInterface* main_thread)
                            : main_thread_(main_thread) {
  }",3,3,inspector\main_thread_interface.hpp,node.inspector.MainThreadHandle.MainThreadHandle,,false,43,45,MainThreadHandle,,,1,ANY node.inspector.MainThreadHandle.MainThreadHandle (MainThreadInterface*)
86821,METHOD,node.inspector.MainThreadHandle,TYPE_DECL,"~MainThreadHandle() {
    Mutex::ScopedLock scoped_lock(block_lock_);
    CHECK_NULL(main_thread_);  // main_thread_ should have called Reset
  }",3,3,inspector\main_thread_interface.hpp,node.inspector.MainThreadHandle.~MainThreadHandle,,false,46,49,~MainThreadHandle,,,2,ANY node.inspector.MainThreadHandle.~MainThreadHandle ()
86830,METHOD,node.inspector.MainThreadHandle,TYPE_DECL,"std::unique_ptr<InspectorSession> Connect(
      std::unique_ptr<InspectorSessionDelegate> delegate,
      bool prevent_shutdown);",37,28,inspector\main_thread_interface.hpp,node.inspector.MainThreadHandle.Connect,,false,50,52,Connect,,,3,"ANY node.inspector.MainThreadHandle.Connect (ANY,bool)"
86836,METHOD,node.inspector.MainThreadHandle,TYPE_DECL,"int newObjectId() {
    return ++next_object_id_;
  }",3,3,inspector\main_thread_interface.hpp,node.inspector.MainThreadHandle.newObjectId,,false,53,55,newObjectId,,,4,int node.inspector.MainThreadHandle.newObjectId ()
86843,METHOD,node.inspector.MainThreadHandle,TYPE_DECL,bool Post(std::unique_ptr<Request> request);,8,45,inspector\main_thread_interface.hpp,node.inspector.MainThreadHandle.Post,,false,56,56,Post,,,5,bool node.inspector.MainThreadHandle.Post (ANY)
86848,METHOD,node.inspector.MainThreadHandle,TYPE_DECL,"std::unique_ptr<InspectorSessionDelegate> MakeDelegateThreadSafe(
      std::unique_ptr<InspectorSessionDelegate> delegate);",45,57,inspector\main_thread_interface.hpp,node.inspector.MainThreadHandle.MakeDelegateThreadSafe,,false,57,58,MakeDelegateThreadSafe,,,6,ANY node.inspector.MainThreadHandle.MakeDelegateThreadSafe (ANY)
86853,METHOD,node.inspector.MainThreadHandle,TYPE_DECL,bool Expired();,8,16,inspector\main_thread_interface.hpp,node.inspector.MainThreadHandle.Expired,,false,59,59,Expired,,,7,bool node.inspector.MainThreadHandle.Expired ()
86857,METHOD,node.inspector.MainThreadHandle,TYPE_DECL,void Reset();,8,14,inspector\main_thread_interface.hpp,node.inspector.MainThreadHandle.Reset,,false,62,62,Reset,,,8,void node.inspector.MainThreadHandle.Reset ()
86866,METHOD,<empty>,<empty>,<empty>,1,,inspector\main_thread_interface.hpp,node.inspector.MainThreadHandle:<clinit>,,false,41,,<clinit>,,,14,
86878,METHOD,node.inspector.MainThreadInterface,TYPE_DECL,explicit MainThreadInterface(Agent* agent);,12,44,inspector\main_thread_interface.hpp,node.inspector.MainThreadInterface.MainThreadInterface,,false,75,75,MainThreadInterface,,,1,explicit node.inspector.MainThreadInterface.MainThreadInterface (Agent*)
86883,METHOD,node.inspector.MainThreadInterface,TYPE_DECL,~MainThreadInterface();,3,24,inspector\main_thread_interface.hpp,node.inspector.MainThreadInterface.~MainThreadInterface,,false,76,76,~MainThreadInterface,,,2,ANY node.inspector.MainThreadInterface.~MainThreadInterface ()
86887,METHOD,node.inspector.MainThreadInterface,TYPE_DECL,void DispatchMessages();,8,25,inspector\main_thread_interface.hpp,node.inspector.MainThreadInterface.DispatchMessages,,false,78,78,DispatchMessages,,,3,void node.inspector.MainThreadInterface.DispatchMessages ()
86891,METHOD,node.inspector.MainThreadInterface,TYPE_DECL,void Post(std::unique_ptr<Request> request);,8,45,inspector\main_thread_interface.hpp,node.inspector.MainThreadInterface.Post,,false,79,79,Post,,,4,void node.inspector.MainThreadInterface.Post (ANY)
86896,METHOD,node.inspector.MainThreadInterface,TYPE_DECL,bool WaitForFrontendEvent();,8,29,inspector\main_thread_interface.hpp,node.inspector.MainThreadInterface.WaitForFrontendEvent,,false,80,80,WaitForFrontendEvent,,,5,bool node.inspector.MainThreadInterface.WaitForFrontendEvent ()
86900,METHOD,node.inspector.MainThreadInterface,TYPE_DECL,std::shared_ptr<MainThreadHandle> GetHandle();,37,47,inspector\main_thread_interface.hpp,node.inspector.MainThreadInterface.GetHandle,,false,81,81,GetHandle,,,6,ANY node.inspector.MainThreadInterface.GetHandle ()
86904,METHOD,node.inspector.MainThreadInterface,TYPE_DECL,"Agent* inspector_agent() {
    return agent_;
  }",3,3,inspector\main_thread_interface.hpp,node.inspector.MainThreadInterface.inspector_agent,,false,82,84,inspector_agent,,,7,Agent node.inspector.MainThreadInterface.inspector_agent ()
86910,METHOD,node.inspector.MainThreadInterface,TYPE_DECL,"void AddObject(int handle, std::unique_ptr<Deletable> object);",8,63,inspector\main_thread_interface.hpp,node.inspector.MainThreadInterface.AddObject,,false,85,85,AddObject,,,8,"void node.inspector.MainThreadInterface.AddObject (int,ANY)"
86916,METHOD,node.inspector.MainThreadInterface,TYPE_DECL,Deletable* GetObject(int id);,12,30,inspector\main_thread_interface.hpp,node.inspector.MainThreadInterface.GetObject,,false,86,86,GetObject,,,9,Deletable* node.inspector.MainThreadInterface.GetObject (int)
86921,METHOD,node.inspector.MainThreadInterface,TYPE_DECL,Deletable* GetObjectIfExists(int id);,12,38,inspector\main_thread_interface.hpp,node.inspector.MainThreadInterface.GetObjectIfExists,,false,87,87,GetObjectIfExists,,,10,Deletable* node.inspector.MainThreadInterface.GetObjectIfExists (int)
86926,METHOD,node.inspector.MainThreadInterface,TYPE_DECL,void RemoveObject(int handle);,8,31,inspector\main_thread_interface.hpp,node.inspector.MainThreadInterface.RemoveObject,,false,88,88,RemoveObject,,,11,void node.inspector.MainThreadInterface.RemoveObject (int)
86939,METHOD,<empty>,<empty>,<empty>,1,,inspector\main_thread_interface.hpp,node.inspector.MainThreadInterface:<clinit>,,false,72,,<clinit>,,,20,
86959,METHOD,inspector\node_string.cc:<global>,TYPE_DECL,<global>,1,1,inspector\node_string.hpp,inspector\node_string.cc:<global>,,false,1,155,<global>,,,1,
86973,METHOD,inspector\node_string.cc:<global>,TYPE_DECL,"void builderAppendQuotedString(StringBuilder& builder,
                               const std::string_view string) {
  builder.put('""');
  if (!string.empty()) {
    size_t expected_utf16_length =
        simdutf::utf16_length_from_utf8(string.data(), string.length());
    MaybeStackBuffer<char16_t> buffer(expected_utf16_length);
    // simdutf::convert_utf8_to_utf16 returns zero in case of error.
    size_t utf16_length = simdutf::convert_utf8_to_utf16(
        string.data(), string.length(), buffer.out());
    // We have that utf16_length == expected_utf16_length if and only
    // if the input was a valid UTF-8 string.
    if (utf16_length != 0) {
      CHECK_EQ(expected_utf16_length, utf16_length);
      escapeWideStringForJSON(reinterpret_cast<const uint16_t*>(buffer.out()),
                              utf16_length,
                              &builder);
    }  // Otherwise, we had an invalid UTF-8 input.
  }
  builder.put('""');
}",1,1,inspector\node_string.cc,node.inspector.protocol.StringUtil.builderAppendQuotedString,,false,15,35,builderAppendQuotedString,,,3,"void node.inspector.protocol.StringUtil.builderAppendQuotedString (StringBuilder,ANY)"
87051,METHOD,inspector\node_string.cc:<global>,TYPE_DECL,"std::unique_ptr<Value> parseJSON(const std::string_view string) {
  if (string.empty())
    return nullptr;
  size_t expected_utf16_length =
      simdutf::utf16_length_from_utf8(string.data(), string.length());
  MaybeStackBuffer<char16_t> buffer(expected_utf16_length);
  // simdutf::convert_utf8_to_utf16 returns zero in case of error.
  size_t utf16_length = simdutf::convert_utf8_to_utf16(
      string.data(), string.length(), buffer.out());
  // We have that utf16_length == expected_utf16_length if and only
  // if the input was a valid UTF-8 string.
  if (utf16_length == 0) return nullptr;  // We had an invalid UTF-8 input.
  CHECK_EQ(expected_utf16_length, utf16_length);
  return parseJSONCharacters(reinterpret_cast<const uint16_t*>(buffer.out()),
                             utf16_length);
}",1,1,inspector\node_string.cc,node.inspector.protocol.StringUtil.parseJSON,,false,37,52,parseJSON,,,4,unique_ptr<Value> node.inspector.protocol.StringUtil.parseJSON (ANY)
87120,METHOD,inspector\node_string.cc:<global>,TYPE_DECL,"std::unique_ptr<Value> parseJSON(v8_inspector::StringView string) {
  if (string.length() == 0)
    return nullptr;
  if (string.is8Bit())
    return parseJSONCharacters(string.characters8(), string.length());
  return parseJSONCharacters(string.characters16(), string.length());
}",1,1,inspector\node_string.cc,node.inspector.protocol.StringUtil.parseJSON,,false,54,60,parseJSON,,,5,unique_ptr<Value> node.inspector.protocol.StringUtil.parseJSON (ANY)
87161,METHOD,inspector\node_string.cc:<global>,TYPE_DECL,"String StringViewToUtf8(v8_inspector::StringView view) {
  if (view.length() == 0)
    return """";
  if (view.is8Bit()) {
    return std::string(reinterpret_cast<const char*>(view.characters8()),
                       view.length());
  }
  const char16_t* source =
      reinterpret_cast<const char16_t*>(view.characters16());
  size_t expected_utf8_length =
      simdutf::utf8_length_from_utf16(source, view.length());
  MaybeStackBuffer<char> buffer(expected_utf8_length);
  // convert_utf16_to_utf8 returns zero in case of error.
  size_t utf8_length =
      simdutf::convert_utf16_to_utf8(source, view.length(), buffer.out());
  // We have that utf8_length == expected_utf8_length if and only
  // if the input was a valid UTF-16 string. Otherwise, utf8_length
  // must be zero.
  CHECK(utf8_length == 0 || utf8_length == expected_utf8_length);
  // An invalid UTF-16 input will generate the empty string:
  return String(buffer.out(), utf8_length);
}",1,1,inspector\node_string.cc,node.inspector.protocol.StringUtil.StringViewToUtf8,,false,62,83,StringViewToUtf8,,,6,String node.inspector.protocol.StringUtil.StringViewToUtf8 (ANY)
87252,METHOD,inspector\node_string.cc:<global>,TYPE_DECL,"String fromDouble(double d) {
  std::ostringstream stream;
  stream.imbue(std::locale::classic());  // Ignore current locale
  stream << d;
  return stream.str();
}",1,1,inspector\node_string.cc,node.inspector.protocol.StringUtil.fromDouble,,false,85,90,fromDouble,,,7,String node.inspector.protocol.StringUtil.fromDouble (double)
87276,METHOD,inspector\node_string.cc:<global>,TYPE_DECL,"double toDouble(const char* buffer, size_t length, bool* ok) {
  std::istringstream stream(std::string(buffer, length));
  stream.imbue(std::locale::classic());  // Ignore current locale
  double d;
  stream >> d;
  *ok = !stream.fail();
  return d;
}",1,1,inspector\node_string.cc,node.inspector.protocol.StringUtil.toDouble,,false,92,99,toDouble,,,8,"double node.inspector.protocol.StringUtil.toDouble (char*,size_t,bool*)"
87315,METHOD,inspector\node_string.cc:<global>,TYPE_DECL,"std::unique_ptr<Value> parseMessage(const std::string_view message,
                                    bool binary) {
  if (binary) {
    return Value::parseBinary(
        reinterpret_cast<const uint8_t*>(message.data()),
        message.length());
  }
  return parseJSON(message);
}",1,1,inspector\node_string.cc,node.inspector.protocol.StringUtil.parseMessage,,false,101,109,parseMessage,,,9,"unique_ptr<Value> node.inspector.protocol.StringUtil.parseMessage (ANY,bool)"
87342,METHOD,inspector\node_string.cc:<global>,TYPE_DECL,"ProtocolMessage jsonToMessage(String message) {
  return message;
}",1,1,inspector\node_string.cc,node.inspector.protocol.StringUtil.jsonToMessage,,false,111,113,jsonToMessage,,,10,ProtocolMessage node.inspector.protocol.StringUtil.jsonToMessage (String)
87349,METHOD,inspector\node_string.cc:<global>,TYPE_DECL,"ProtocolMessage binaryToMessage(std::vector<uint8_t> message) {
  return std::string(reinterpret_cast<const char*>(message.data()),
                     message.size());
}",1,1,inspector\node_string.cc,node.inspector.protocol.StringUtil.binaryToMessage,,false,115,118,binaryToMessage,,,11,ProtocolMessage node.inspector.protocol.StringUtil.binaryToMessage (ANY)
87369,METHOD,inspector\node_string.cc:<global>,TYPE_DECL,"String fromUTF8(const uint8_t* data, size_t length) {
  return std::string(reinterpret_cast<const char*>(data), length);
}",1,1,inspector\node_string.cc,node.inspector.protocol.StringUtil.fromUTF8,,false,120,122,fromUTF8,,,12,"String node.inspector.protocol.StringUtil.fromUTF8 (uint8_t*,size_t)"
87384,METHOD,inspector\node_string.cc:<global>,TYPE_DECL,"String fromUTF16(const uint16_t* data, size_t length) {
  auto casted_data = reinterpret_cast<const char16_t*>(data);
  size_t expected_utf8_length =
      simdutf::utf8_length_from_utf16(casted_data, length);
  MaybeStackBuffer<char> buffer(expected_utf8_length);
  // simdutf::convert_utf16_to_utf8 returns zero in case of error.
  size_t utf8_length =
      simdutf::convert_utf16_to_utf8(casted_data, length, buffer.out());
  // We have that utf8_length == expected_utf8_length if and only
  // if the input was a valid UTF-16 string. Otherwise, utf8_length
  // must be zero.
  CHECK(utf8_length == 0 || utf8_length == expected_utf8_length);
  // An invalid UTF-16 input will generate the empty string:
  return String(buffer.out(), utf8_length);
}",1,1,inspector\node_string.cc,node.inspector.protocol.StringUtil.fromUTF16,,false,124,138,fromUTF16,,,13,"String node.inspector.protocol.StringUtil.fromUTF16 (uint16_t*,size_t)"
87436,METHOD,inspector\node_string.cc:<global>,TYPE_DECL,"const uint8_t* CharactersUTF8(const std::string_view s) {
  return reinterpret_cast<const uint8_t*>(s.data());
}",1,1,inspector\node_string.cc,node.inspector.protocol.StringUtil.CharactersUTF8,,false,140,142,CharactersUTF8,,,14,uint8_t node.inspector.protocol.StringUtil.CharactersUTF8 (ANY)
87448,METHOD,inspector\node_string.cc:<global>,TYPE_DECL,"size_t CharacterCount(const std::string_view s) {
  // The utf32_length_from_utf8 function calls count_utf8.
  // The count_utf8 function counts the number of code points
  // (characters) in the string, assuming that the string is valid Unicode.
  // TODO(@anonrig): Test to make sure CharacterCount returns correctly.
  return simdutf::utf32_length_from_utf8(s.data(), s.length());
}",1,1,inspector\node_string.cc,node.inspector.protocol.StringUtil.CharacterCount,,false,144,150,CharacterCount,,,15,size_t node.inspector.protocol.StringUtil.CharacterCount (ANY)
87479,METHOD,inspector\node_string.hpp:<global>,TYPE_DECL,<global>,1,1,inspector\node_string.hpp,inspector\node_string.hpp:<global>,,false,1,110,<global>,,,1,
87489,METHOD,inspector\node_string.hpp:<global>,TYPE_DECL,"inline void builderAppend(StringBuilder& builder, char c) {
  builder.put(c);
}",1,1,inspector\node_string.hpp,node.inspector.protocol.StringUtil.builderAppend,,false,25,27,builderAppend,,,1,"void node.inspector.protocol.StringUtil.builderAppend (StringBuilder,char)"
87500,METHOD,inspector\node_string.hpp:<global>,TYPE_DECL,"inline void builderAppend(StringBuilder& builder, const char* value,
                          size_t length) {
  builder.write(value, length);
}",1,1,inspector\node_string.hpp,node.inspector.protocol.StringUtil.builderAppend,,false,30,33,builderAppend,,,2,"void node.inspector.protocol.StringUtil.builderAppend (StringBuilder,char*,size_t)"
87513,METHOD,inspector\node_string.hpp:<global>,TYPE_DECL,"inline void builderAppend(StringBuilder& builder, const char* value) {
  builderAppend(builder, value, std::strlen(value));
}",1,1,inspector\node_string.hpp,node.inspector.protocol.StringUtil.builderAppend,,false,36,38,builderAppend,,,3,"void node.inspector.protocol.StringUtil.builderAppend (StringBuilder,char*)"
87527,METHOD,inspector\node_string.hpp:<global>,TYPE_DECL,"inline void builderAppend(StringBuilder& builder, const String& string) {
  builder << string;
}",1,1,inspector\node_string.hpp,node.inspector.protocol.StringUtil.builderAppend,,false,41,43,builderAppend,,,4,"void node.inspector.protocol.StringUtil.builderAppend (StringBuilder,String)"
87536,METHOD,inspector\node_string.hpp:<global>,TYPE_DECL,"inline void builderReserve(StringBuilder& builder, size_t) {
  // ostringstream does not have a counterpart
}",1,1,inspector\node_string.hpp,node.inspector.protocol.StringUtil.builderReserve,,false,46,48,builderReserve,,,5,"void node.inspector.protocol.StringUtil.builderReserve (StringBuilder,size_t)"
87542,METHOD,inspector\node_string.hpp:<global>,TYPE_DECL,"inline String substring(const String& string, size_t start, size_t count) {
  return string.substr(start, count);
}",1,1,inspector\node_string.hpp,node.inspector.protocol.StringUtil.substring,,false,49,51,substring,,,6,"String node.inspector.protocol.StringUtil.substring (String,size_t,size_t)"
87556,METHOD,inspector\node_string.hpp:<global>,TYPE_DECL,"inline String fromInteger(int n) {
  return std::to_string(n);
}",1,1,inspector\node_string.hpp,node.inspector.protocol.StringUtil.fromInteger,,false,52,54,fromInteger,,,7,String node.inspector.protocol.StringUtil.fromInteger (int)
87567,METHOD,inspector\node_string.hpp:<global>,TYPE_DECL,"inline String builderToString(const StringBuilder& builder) {
  return builder.str();
}",1,1,inspector\node_string.hpp,node.inspector.protocol.StringUtil.builderToString,,false,55,57,builderToString,,,8,String node.inspector.protocol.StringUtil.builderToString (StringBuilder)
87577,METHOD,inspector\node_string.hpp:<global>,TYPE_DECL,"inline size_t find(const String& string, const char* substring) {
  return string.find(substring);
}",1,1,inspector\node_string.hpp,node.inspector.protocol.StringUtil.find,,false,58,60,find,,,9,"size_t node.inspector.protocol.StringUtil.find (String,char*)"
87589,METHOD,inspector\node_string.hpp:<global>,TYPE_DECL,String fromDouble(double d);,8,27,inspector\node_string.hpp,node.inspector.protocol.StringUtil.fromDouble,,false,61,61,fromDouble,,,10,String node.inspector.protocol.StringUtil.fromDouble (double)
87594,METHOD,inspector\node_string.hpp:<global>,TYPE_DECL,"double toDouble(const char* buffer, size_t length, bool* ok);",8,60,inspector\node_string.hpp,node.inspector.protocol.StringUtil.toDouble,,false,62,62,toDouble,,,11,"double node.inspector.protocol.StringUtil.toDouble (char*,size_t,bool*)"
87601,METHOD,inspector\node_string.hpp:<global>,TYPE_DECL,String StringViewToUtf8(v8_inspector::StringView view);,8,54,inspector\node_string.hpp,node.inspector.protocol.StringUtil.StringViewToUtf8,,false,64,64,StringViewToUtf8,,,12,String node.inspector.protocol.StringUtil.StringViewToUtf8 (ANY)
87606,METHOD,inspector\node_string.hpp:<global>,TYPE_DECL,"void builderAppendQuotedString(StringBuilder& builder, const std::string_view);",6,78,inspector\node_string.hpp,node.inspector.protocol.StringUtil.builderAppendQuotedString,,false,67,67,builderAppendQuotedString,,,13,"void node.inspector.protocol.StringUtil.builderAppendQuotedString (StringBuilder,ANY)"
87612,METHOD,inspector\node_string.hpp:<global>,TYPE_DECL,std::unique_ptr<Value> parseJSON(const std::string_view);,24,56,inspector\node_string.hpp,node.inspector.protocol.StringUtil.parseJSON,,false,68,68,parseJSON,,,14,ANY node.inspector.protocol.StringUtil.parseJSON (ANY)
87617,METHOD,inspector\node_string.hpp:<global>,TYPE_DECL,"std::unique_ptr<Value> parseMessage(const std::string_view message,
                                    bool binary);",24,48,inspector\node_string.hpp,node.inspector.protocol.StringUtil.parseMessage,,false,71,72,parseMessage,,,15,"ANY node.inspector.protocol.StringUtil.parseMessage (ANY,bool)"
87623,METHOD,inspector\node_string.hpp:<global>,TYPE_DECL,ProtocolMessage jsonToMessage(String message);,17,45,inspector\node_string.hpp,node.inspector.protocol.StringUtil.jsonToMessage,,false,73,73,jsonToMessage,,,16,ProtocolMessage node.inspector.protocol.StringUtil.jsonToMessage (String)
87628,METHOD,inspector\node_string.hpp:<global>,TYPE_DECL,ProtocolMessage binaryToMessage(std::vector<uint8_t> message);,17,61,inspector\node_string.hpp,node.inspector.protocol.StringUtil.binaryToMessage,,false,74,74,binaryToMessage,,,17,ProtocolMessage node.inspector.protocol.StringUtil.binaryToMessage (ANY)
87633,METHOD,inspector\node_string.hpp:<global>,TYPE_DECL,"String fromUTF8(const uint8_t* data, size_t length);",8,51,inspector\node_string.hpp,node.inspector.protocol.StringUtil.fromUTF8,,false,75,75,fromUTF8,,,18,"String node.inspector.protocol.StringUtil.fromUTF8 (uint8_t*,size_t)"
87639,METHOD,inspector\node_string.hpp:<global>,TYPE_DECL,"String fromUTF16(const uint16_t* data, size_t length);",8,53,inspector\node_string.hpp,node.inspector.protocol.StringUtil.fromUTF16,,false,76,76,fromUTF16,,,19,"String node.inspector.protocol.StringUtil.fromUTF16 (uint16_t*,size_t)"
87645,METHOD,inspector\node_string.hpp:<global>,TYPE_DECL,const uint8_t* CharactersUTF8(const std::string_view s);,14,55,inspector\node_string.hpp,node.inspector.protocol.StringUtil.CharactersUTF8,,false,77,77,CharactersUTF8,,,20,uint8_t* node.inspector.protocol.StringUtil.CharactersUTF8 (ANY)
87650,METHOD,inspector\node_string.hpp:<global>,TYPE_DECL,size_t CharacterCount(const std::string_view s);,8,47,inspector\node_string.hpp,node.inspector.protocol.StringUtil.CharacterCount,,false,78,78,CharacterCount,,,21,size_t node.inspector.protocol.StringUtil.CharacterCount (ANY)
87655,METHOD,inspector\node_string.hpp:<global>,TYPE_DECL,"inline uint8_t* CharactersLatin1(const std::string_view s) {
  return nullptr;
}",1,1,inspector\node_string.hpp,node.inspector.protocol.StringUtil.CharactersLatin1,,false,81,83,CharactersLatin1,,,22,uint8_t node.inspector.protocol.StringUtil.CharactersLatin1 (ANY)
87662,METHOD,inspector\node_string.hpp:<global>,TYPE_DECL,"inline const uint16_t* CharactersUTF16(const std::string_view s) {
  return nullptr;
}",1,1,inspector\node_string.hpp,node.inspector.protocol.StringUtil.CharactersUTF16,,false,84,86,CharactersUTF16,,,23,uint16_t node.inspector.protocol.StringUtil.CharactersUTF16 (ANY)
87671,METHOD,node.inspector.protocol.Binary,TYPE_DECL,const uint8_t* data() const { UNREACHABLE(); },3,48,inspector\node_string.hpp,node.inspector.protocol.Binary.data,,false,97,97,data,,,1,uint8_t node.inspector.protocol.Binary.data ()
87676,METHOD,node.inspector.protocol.Binary,TYPE_DECL,size_t size() const { UNREACHABLE(); },3,40,inspector\node_string.hpp,node.inspector.protocol.Binary.size,,false,98,98,size,,,2,size_t node.inspector.protocol.Binary.size ()
87681,METHOD,node.inspector.protocol.Binary,TYPE_DECL,String toBase64() const { UNREACHABLE(); },3,44,inspector\node_string.hpp,node.inspector.protocol.Binary.toBase64,,false,99,99,toBase64,,,3,String node.inspector.protocol.Binary.toBase64 ()
87686,METHOD,node.inspector.protocol.Binary,TYPE_DECL,"static Binary fromBase64(const std::string_view base64, bool* success) {
    UNREACHABLE();
  }",3,3,inspector\node_string.hpp,node.inspector.protocol.Binary.fromBase64,,false,100,102,fromBase64,,,4,"Binary node.inspector.protocol.Binary.fromBase64 (ANY,bool*)"
87693,METHOD,node.inspector.protocol.Binary,TYPE_DECL,"static Binary fromSpan(const uint8_t* data, size_t size) { UNREACHABLE(); }",3,77,inspector\node_string.hpp,node.inspector.protocol.Binary.fromSpan,,false,103,103,fromSpan,,,5,"Binary node.inspector.protocol.Binary.fromSpan (uint8_t*,size_t)"
87709,METHOD,inspector\runtime_agent.cc:<global>,TYPE_DECL,<global>,1,41,inspector\runtime_agent.hpp,inspector\runtime_agent.cc:<global>,,false,1,32,<global>,,,1,
87714,METHOD,inspector\runtime_agent.cc:<global>,TYPE_DECL,"RuntimeAgent::RuntimeAgent()
  : notify_when_waiting_for_disconnect_(false) {}",1,49,inspector\runtime_agent.cc,node.inspector.protocol.RuntimeAgent.RuntimeAgent,,false,10,11,RuntimeAgent,,,1,ANY node.inspector.protocol.RuntimeAgent.RuntimeAgent ()
87718,METHOD,inspector\runtime_agent.cc:<global>,TYPE_DECL,"void RuntimeAgent::Wire(UberDispatcher* dispatcher) {
  frontend_ = std::make_unique<NodeRuntime::Frontend>(dispatcher->channel());
  NodeRuntime::Dispatcher::wire(dispatcher, this);
}",1,1,inspector\runtime_agent.cc,node.inspector.protocol.RuntimeAgent.Wire,,false,13,16,Wire,,,2,void node.inspector.protocol.RuntimeAgent.Wire (UberDispatcher*)
87745,METHOD,inspector\runtime_agent.cc:<global>,TYPE_DECL,"DispatchResponse RuntimeAgent::notifyWhenWaitingForDisconnect(bool enabled) {
  notify_when_waiting_for_disconnect_ = enabled;
  return DispatchResponse::OK();
}",1,1,inspector\runtime_agent.cc,node.inspector.protocol.RuntimeAgent.notifyWhenWaitingForDisconnect,,false,18,21,notifyWhenWaitingForDisconnect,,,3,DispatchResponse node.inspector.protocol.RuntimeAgent.notifyWhenWaitingForDisconnect (bool)
87758,METHOD,inspector\runtime_agent.cc:<global>,TYPE_DECL,"bool RuntimeAgent::notifyWaitingForDisconnect() {
  if (notify_when_waiting_for_disconnect_) {
    frontend_->waitingForDisconnect();
    return true;
  }
  return false;
}",1,1,inspector\runtime_agent.cc,node.inspector.protocol.RuntimeAgent.notifyWaitingForDisconnect,,false,23,29,notifyWaitingForDisconnect,,,4,bool node.inspector.protocol.RuntimeAgent.notifyWaitingForDisconnect ()
87780,METHOD,inspector\runtime_agent.hpp:<global>,TYPE_DECL,<global>,1,41,inspector\runtime_agent.hpp,inspector\runtime_agent.hpp:<global>,,false,1,31,<global>,,,1,
87787,METHOD,node.inspector.protocol.RuntimeAgent,TYPE_DECL,RuntimeAgent();,3,16,inspector\runtime_agent.hpp,node.inspector.protocol.RuntimeAgent.RuntimeAgent,,false,15,15,RuntimeAgent,,,1,ANY node.inspector.protocol.RuntimeAgent.RuntimeAgent ()
87791,METHOD,node.inspector.protocol.RuntimeAgent,TYPE_DECL,void Wire(UberDispatcher* dispatcher);,8,39,inspector\runtime_agent.hpp,node.inspector.protocol.RuntimeAgent.Wire,,false,17,17,Wire,,,2,void node.inspector.protocol.RuntimeAgent.Wire (UberDispatcher*)
87796,METHOD,node.inspector.protocol.RuntimeAgent,TYPE_DECL,DispatchResponse notifyWhenWaitingForDisconnect(bool enabled) override;,20,72,inspector\runtime_agent.hpp,node.inspector.protocol.RuntimeAgent.notifyWhenWaitingForDisconnect,,false,19,19,notifyWhenWaitingForDisconnect,,,3,DispatchResponse node.inspector.protocol.RuntimeAgent.notifyWhenWaitingForDisconnect (bool)
87801,METHOD,node.inspector.protocol.RuntimeAgent,TYPE_DECL,bool notifyWaitingForDisconnect();,8,35,inspector\runtime_agent.hpp,node.inspector.protocol.RuntimeAgent.notifyWaitingForDisconnect,,false,21,21,notifyWaitingForDisconnect,,,4,bool node.inspector.protocol.RuntimeAgent.notifyWaitingForDisconnect ()
87824,METHOD,inspector\tracing_agent.cc:<global>,TYPE_DECL,<global>,1,51,inspector\tracing_agent.hpp,inspector\tracing_agent.cc:<global>,,false,1,203,<global>,,,1,
87831,METHOD,node.inspector.protocol.anonymous_namespace_2.DeletableFrontendWrapper,TYPE_DECL,"explicit DeletableFrontendWrapper(
      std::weak_ptr<NodeTracing::Frontend> frontend)
      : frontend_(frontend) {}",3,30,inspector\tracing_agent.cc,node.inspector.protocol.anonymous_namespace_3.DeletableFrontendWrapper.DeletableFrontendWrapper,,false,19,21,DeletableFrontendWrapper,,,1,ANY node.inspector.protocol.anonymous_namespace_3.DeletableFrontendWrapper.DeletableFrontendWrapper (ANY)
87836,METHOD,node.inspector.protocol.anonymous_namespace_2.DeletableFrontendWrapper,TYPE_DECL,NodeTracing::Frontend* get() { return frontend_.lock().get(); },3,65,inspector\tracing_agent.cc,node.inspector.protocol.anonymous_namespace_4.DeletableFrontendWrapper.get,,false,25,25,get,,,2,Frontend node.inspector.protocol.anonymous_namespace_4.DeletableFrontendWrapper.get ()
87850,METHOD,node.inspector.protocol.anonymous_namespace_5.CreateFrontendWrapperRequest,TYPE_DECL,"CreateFrontendWrapperRequest(int object_id,
                               std::weak_ptr<NodeTracing::Frontend> frontend)
      : object_id_(object_id) {
    frontend_wrapper_ = std::make_unique<DeletableFrontendWrapper>(frontend);
  }",3,3,inspector\tracing_agent.cc,node.inspector.protocol.anonymous_namespace_6.CreateFrontendWrapperRequest.CreateFrontendWrapperRequest,,false,33,37,CreateFrontendWrapperRequest,,,1,"ANY node.inspector.protocol.anonymous_namespace_6.CreateFrontendWrapperRequest.CreateFrontendWrapperRequest (int,ANY)"
87865,METHOD,node.inspector.protocol.anonymous_namespace_5.CreateFrontendWrapperRequest,TYPE_DECL,"void Call(MainThreadInterface* thread) override {
    thread->AddObject(object_id_, std::move(frontend_wrapper_));
  }",3,3,inspector\tracing_agent.cc,node.inspector.protocol.anonymous_namespace_7.CreateFrontendWrapperRequest.Call,,false,39,41,Call,,,2,void node.inspector.protocol.anonymous_namespace_7.CreateFrontendWrapperRequest.Call (MainThreadInterface*)
87883,METHOD,node.inspector.protocol.anonymous_namespace_8.DestroyFrontendWrapperRequest,TYPE_DECL,"explicit DestroyFrontendWrapperRequest(int object_id)
      : object_id_(object_id) {}",3,32,inspector\tracing_agent.cc,node.inspector.protocol.anonymous_namespace_9.DestroyFrontendWrapperRequest.DestroyFrontendWrapperRequest,,false,50,51,DestroyFrontendWrapperRequest,,,1,ANY node.inspector.protocol.anonymous_namespace_9.DestroyFrontendWrapperRequest.DestroyFrontendWrapperRequest (int)
87888,METHOD,node.inspector.protocol.anonymous_namespace_8.DestroyFrontendWrapperRequest,TYPE_DECL,"void Call(MainThreadInterface* thread) override {
    thread->RemoveObject(object_id_);
  }",3,3,inspector\tracing_agent.cc,node.inspector.protocol.anonymous_namespace_10.DestroyFrontendWrapperRequest.Call,,false,53,55,Call,,,2,void node.inspector.protocol.anonymous_namespace_10.DestroyFrontendWrapperRequest.Call (MainThreadInterface*)
87900,METHOD,node.inspector.protocol.anonymous_namespace_11.SendMessageRequest,TYPE_DECL,"explicit SendMessageRequest(int object_id, const std::string& message)
      : object_id_(object_id), message_(message) {}",3,51,inspector\tracing_agent.cc,node.inspector.protocol.anonymous_namespace_12.SendMessageRequest.SendMessageRequest,,false,63,64,SendMessageRequest,,,1,"ANY node.inspector.protocol.anonymous_namespace_12.SendMessageRequest.SendMessageRequest (int,ANY)"
87906,METHOD,node.inspector.protocol.anonymous_namespace_11.SendMessageRequest,TYPE_DECL,"void Call(MainThreadInterface* thread) override {
    DeletableFrontendWrapper* frontend_wrapper =
        static_cast<DeletableFrontendWrapper*>(
            thread->GetObjectIfExists(object_id_));
    if (frontend_wrapper == nullptr) return;
    auto frontend = frontend_wrapper->get();
    if (frontend != nullptr) {
      frontend->sendRawJSONNotification(message_);
    }
  }",3,3,inspector\tracing_agent.cc,node.inspector.protocol.anonymous_namespace_13.SendMessageRequest.Call,,false,66,75,Call,,,2,void node.inspector.protocol.anonymous_namespace_13.SendMessageRequest.Call (MainThreadInterface*)
87947,METHOD,node.inspector.protocol.anonymous_namespace_14.InspectorTraceWriter,TYPE_DECL,"explicit InspectorTraceWriter(int frontend_object_id,
                                std::shared_ptr<MainThreadHandle> main_thread)
      : frontend_object_id_(frontend_object_id), main_thread_(main_thread) {}",3,77,inspector\tracing_agent.cc,node.inspector.protocol.anonymous_namespace_15.InspectorTraceWriter.InspectorTraceWriter,,false,84,86,InspectorTraceWriter,,,1,"ANY node.inspector.protocol.anonymous_namespace_15.InspectorTraceWriter.InspectorTraceWriter (int,ANY)"
87953,METHOD,node.inspector.protocol.anonymous_namespace_14.InspectorTraceWriter,TYPE_DECL,"void AppendTraceEvent(
      v8::platform::tracing::TraceObject* trace_event) override {
    if (!json_writer_)
      json_writer_.reset(TraceWriter::CreateJSONTraceWriter(stream_, ""value""));
    json_writer_->AppendTraceEvent(trace_event);
  }",3,3,inspector\tracing_agent.cc,node.inspector.protocol.anonymous_namespace_16.InspectorTraceWriter.AppendTraceEvent,,false,88,93,AppendTraceEvent,,,2,void node.inspector.protocol.anonymous_namespace_16.InspectorTraceWriter.AppendTraceEvent (ANY*)
87977,METHOD,node.inspector.protocol.anonymous_namespace_14.InspectorTraceWriter,TYPE_DECL,"void Flush(bool) override {
    if (!json_writer_)
      return;
    json_writer_.reset();
    std::ostringstream result(
        ""{\""method\"":\""NodeTracing.dataCollected\"",\""params\"":"",
        std::ostringstream::ate);
    result << stream_.str();
    result << ""}"";
    main_thread_->Post(std::make_unique<SendMessageRequest>(frontend_object_id_,
                                                            result.str()));
    stream_.str("""");
  }",3,3,inspector\tracing_agent.cc,node.inspector.protocol.anonymous_namespace_17.InspectorTraceWriter.Flush,,false,95,107,Flush,,,3,void node.inspector.protocol.anonymous_namespace_17.InspectorTraceWriter.Flush (bool)
88034,METHOD,inspector\tracing_agent.cc:<global>,TYPE_DECL,"TracingAgent::TracingAgent(Environment* env,
                           std::shared_ptr<MainThreadHandle> main_thread)
    : env_(env), main_thread_(main_thread) {}",1,45,inspector\tracing_agent.cc,node.inspector.protocol.TracingAgent.TracingAgent,,false,117,119,TracingAgent,,,2,"ANY node.inspector.protocol.TracingAgent.TracingAgent (Environment*,ANY)"
88040,METHOD,inspector\tracing_agent.cc:<global>,TYPE_DECL,"TracingAgent::~TracingAgent() {
  trace_writer_.reset();
  main_thread_->Post(
      std::make_unique<DestroyFrontendWrapperRequest>(frontend_object_id_));
}",1,1,inspector\tracing_agent.cc,node.inspector.protocol.TracingAgent.~TracingAgent,,false,121,125,~TracingAgent,,,3,ANY node.inspector.protocol.TracingAgent.~TracingAgent ()
88059,METHOD,inspector\tracing_agent.cc:<global>,TYPE_DECL,"void TracingAgent::Wire(UberDispatcher* dispatcher) {
  // Note that frontend is still owned by TracingAgent
  frontend_ = std::make_shared<NodeTracing::Frontend>(dispatcher->channel());
  frontend_object_id_ = main_thread_->newObjectId();
  main_thread_->Post(std::make_unique<CreateFrontendWrapperRequest>(
      frontend_object_id_, frontend_));
  NodeTracing::Dispatcher::wire(dispatcher, this);
}",1,1,inspector\tracing_agent.cc,node.inspector.protocol.TracingAgent.Wire,,false,127,134,Wire,,,4,void node.inspector.protocol.TracingAgent.Wire (UberDispatcher*)
88106,METHOD,inspector\tracing_agent.cc:<global>,TYPE_DECL,"DispatchResponse TracingAgent::start(
    std::unique_ptr<protocol::NodeTracing::TraceConfig> traceConfig) {
  if (!trace_writer_.empty()) {
    return DispatchResponse::Error(
        ""Call NodeTracing::end to stop tracing before updating the config"");
  }
  if (!env_->owns_process_state()) {
    return DispatchResponse::Error(
        ""Tracing properties can only be changed through main thread sessions"");
  }

  std::set<std::string> categories_set;
  protocol::Array<std::string>* categories =
      traceConfig->getIncludedCategories();
  for (size_t i = 0; i < categories->length(); i++)
    categories_set.insert(categories->get(i));

  if (categories_set.empty())
    return DispatchResponse::Error(""At least one category should be enabled"");

  tracing::AgentWriterHandle* writer = GetTracingAgentWriter();
  if (writer != nullptr) {
    trace_writer_ =
        writer->agent()->AddClient(categories_set,
                                   std::make_unique<InspectorTraceWriter>(
     ...",1,1,inspector\tracing_agent.cc,node.inspector.protocol.TracingAgent.start,,false,136,165,start,,,5,DispatchResponse node.inspector.protocol.TracingAgent.start (ANY)
88235,METHOD,inspector\tracing_agent.cc:<global>,TYPE_DECL,"DispatchResponse TracingAgent::stop() {
  trace_writer_.reset();
  frontend_->tracingComplete();
  return DispatchResponse::OK();
}",1,1,inspector\tracing_agent.cc,node.inspector.protocol.TracingAgent.stop,,false,167,171,stop,,,6,DispatchResponse node.inspector.protocol.TracingAgent.stop ()
88252,METHOD,inspector\tracing_agent.cc:<global>,TYPE_DECL,"DispatchResponse TracingAgent::getCategories(
    std::unique_ptr<protocol::Array<String>>* categories) {
  *categories = Array<String>::create();
  protocol::Array<String>* categories_list = categories->get();
  // In alphabetical order
  categories_list->addItem(""node"");
  categories_list->addItem(""node.async_hooks"");
  categories_list->addItem(""node.bootstrap"");
  categories_list->addItem(""node.console"");
  categories_list->addItem(""node.dns.native"");
  categories_list->addItem(""node.environment"");
  categories_list->addItem(""node.fs.async"");
  categories_list->addItem(""node.fs.sync"");
  categories_list->addItem(""node.fs_dir.async"");
  categories_list->addItem(""node.fs_dir.sync"");
  categories_list->addItem(""node.http"");
  categories_list->addItem(""node.net.native"");
  categories_list->addItem(""node.perf"");
  categories_list->addItem(""node.perf.timerify"");
  categories_list->addItem(""node.perf.usertiming"");
  categories_list->addItem(""node.promises.rejections"");
  categories_list...",1,1,inspector\tracing_agent.cc,node.inspector.protocol.TracingAgent.getCategories,,false,173,199,getCategories,,,7,DispatchResponse node.inspector.protocol.TracingAgent.getCategories (ANY*)
88395,METHOD,inspector\tracing_agent.hpp:<global>,TYPE_DECL,<global>,1,51,inspector\tracing_agent.hpp,inspector\tracing_agent.hpp:<global>,,false,1,43,<global>,,,1,
88403,METHOD,node.inspector.protocol.TracingAgent,TYPE_DECL,"explicit TracingAgent(Environment*, std::shared_ptr<MainThreadHandle>);",12,72,inspector\tracing_agent.hpp,node.inspector.protocol.TracingAgent.TracingAgent,,false,19,19,TracingAgent,,,1,"explicit node.inspector.protocol.TracingAgent.TracingAgent (Environment*,ANY)"
88409,METHOD,node.inspector.protocol.TracingAgent,TYPE_DECL,~TracingAgent() override;,3,26,inspector\tracing_agent.hpp,node.inspector.protocol.TracingAgent.~TracingAgent,,false,20,20,~TracingAgent,,,2,ANY node.inspector.protocol.TracingAgent.~TracingAgent ()
88413,METHOD,node.inspector.protocol.TracingAgent,TYPE_DECL,void Wire(UberDispatcher* dispatcher);,8,39,inspector\tracing_agent.hpp,node.inspector.protocol.TracingAgent.Wire,,false,22,22,Wire,,,3,void node.inspector.protocol.TracingAgent.Wire (UberDispatcher*)
88418,METHOD,node.inspector.protocol.TracingAgent,TYPE_DECL,"DispatchResponse start(
      std::unique_ptr<protocol::NodeTracing::TraceConfig> traceConfig) override;",20,79,inspector\tracing_agent.hpp,node.inspector.protocol.TracingAgent.start,,false,24,25,start,,,4,DispatchResponse node.inspector.protocol.TracingAgent.start (ANY)
88423,METHOD,node.inspector.protocol.TracingAgent,TYPE_DECL,DispatchResponse stop() override;,20,34,inspector\tracing_agent.hpp,node.inspector.protocol.TracingAgent.stop,,false,26,26,stop,,,5,DispatchResponse node.inspector.protocol.TracingAgent.stop ()
88427,METHOD,node.inspector.protocol.TracingAgent,TYPE_DECL,"DispatchResponse getCategories(
      std::unique_ptr<protocol::Array<String>>* categories) override;",20,68,inspector\tracing_agent.hpp,node.inspector.protocol.TracingAgent.getCategories,,false,27,28,getCategories,,,6,DispatchResponse node.inspector.protocol.TracingAgent.getCategories (ANY*)
88437,METHOD,<empty>,<empty>,<empty>,1,,inspector\tracing_agent.hpp,node.inspector.protocol.TracingAgent:<clinit>,,false,17,,<clinit>,,,12,
88455,METHOD,inspector\worker_agent.cc:<global>,TYPE_DECL,<global>,1,40,inspector\worker_agent.hpp,inspector\worker_agent.cc:<global>,,false,1,160,<global>,,,1,
88461,METHOD,node.inspector.protocol.NodeWorkers,TYPE_DECL,"explicit NodeWorkers(std::weak_ptr<NodeWorker::Frontend> frontend,
                      std::shared_ptr<MainThreadHandle> thread)
                      : frontend_(frontend), thread_(thread) {}",3,63,inspector\worker_agent.cc,node.inspector.protocol.NodeWorkers.NodeWorkers,,false,14,16,NodeWorkers,,,1,"ANY node.inspector.protocol.NodeWorkers.NodeWorkers (ANY,ANY)"
88467,METHOD,node.inspector.protocol.NodeWorkers,TYPE_DECL,"void WorkerCreated(const std::string& title,
                     const std::string& url,
                     bool waiting,
                     std::shared_ptr<MainThreadHandle> target);",8,62,inspector\worker_agent.cc,node.inspector.protocol.NodeWorkers.WorkerCreated,,false,17,20,WorkerCreated,,,2,"void node.inspector.protocol.NodeWorkers.WorkerCreated (ANY,ANY,bool,ANY)"
88475,METHOD,node.inspector.protocol.NodeWorkers,TYPE_DECL,"void Receive(const std::string& id, const std::string& message);",8,65,inspector\worker_agent.cc,node.inspector.protocol.NodeWorkers.Receive,,false,21,21,Receive,,,3,"void node.inspector.protocol.NodeWorkers.Receive (ANY,ANY)"
88481,METHOD,node.inspector.protocol.NodeWorkers,TYPE_DECL,"void Send(const std::string& id, const std::string& message);",8,62,inspector\worker_agent.cc,node.inspector.protocol.NodeWorkers.Send,,false,22,22,Send,,,4,"void node.inspector.protocol.NodeWorkers.Send (ANY,ANY)"
88487,METHOD,node.inspector.protocol.NodeWorkers,TYPE_DECL,void Detached(const std::string& id);,8,38,inspector\worker_agent.cc,node.inspector.protocol.NodeWorkers.Detached,,false,23,23,Detached,,,5,void node.inspector.protocol.NodeWorkers.Detached (ANY)
88496,METHOD,<empty>,<empty>,<empty>,1,,inspector\worker_agent.cc,node.inspector.protocol.NodeWorkers:<clinit>,,false,11,,<clinit>,,,10,
88505,METHOD,node.inspector.protocol.anonymous_namespace_1.AgentWorkerInspectorDelegate,TYPE_DECL,"explicit AgentWorkerInspectorDelegate(std::shared_ptr<NodeWorkers> workers)
                                        : workers_(workers) {}",3,62,inspector\worker_agent.cc,node.inspector.protocol.anonymous_namespace_2.AgentWorkerInspectorDelegate.AgentWorkerInspectorDelegate,,false,35,36,AgentWorkerInspectorDelegate,,,1,ANY node.inspector.protocol.anonymous_namespace_2.AgentWorkerInspectorDelegate.AgentWorkerInspectorDelegate (ANY)
88510,METHOD,node.inspector.protocol.anonymous_namespace_1.AgentWorkerInspectorDelegate,TYPE_DECL,"void WorkerCreated(const std::string& title,
                     const std::string& url,
                     bool waiting,
                     std::shared_ptr<MainThreadHandle> target) override {
    workers_->WorkerCreated(title, url, waiting, target);
  }",3,3,inspector\worker_agent.cc,node.inspector.protocol.anonymous_namespace_3.AgentWorkerInspectorDelegate.WorkerCreated,,false,38,43,WorkerCreated,,,2,"void node.inspector.protocol.anonymous_namespace_3.AgentWorkerInspectorDelegate.WorkerCreated (ANY,ANY,bool,ANY)"
88528,METHOD,node.inspector.protocol.anonymous_namespace_4.ParentInspectorSessionDelegate,TYPE_DECL,"ParentInspectorSessionDelegate(const std::string& id,
                                 std::shared_ptr<NodeWorkers> workers)
                                 : id_(id), workers_(workers) {}",3,64,inspector\worker_agent.cc,node.inspector.protocol.anonymous_namespace_5.ParentInspectorSessionDelegate.ParentInspectorSessionDelegate,,false,51,53,ParentInspectorSessionDelegate,,,1,"ANY node.inspector.protocol.anonymous_namespace_5.ParentInspectorSessionDelegate.ParentInspectorSessionDelegate (ANY,ANY)"
88534,METHOD,node.inspector.protocol.anonymous_namespace_4.ParentInspectorSessionDelegate,TYPE_DECL,"~ParentInspectorSessionDelegate() override {
    workers_->Detached(id_);
  }",3,3,inspector\worker_agent.cc,node.inspector.protocol.anonymous_namespace_6.ParentInspectorSessionDelegate.~ParentInspectorSessionDelegate,,false,55,57,~ParentInspectorSessionDelegate,,,2,ANY node.inspector.protocol.anonymous_namespace_6.ParentInspectorSessionDelegate.~ParentInspectorSessionDelegate ()
88543,METHOD,node.inspector.protocol.anonymous_namespace_4.ParentInspectorSessionDelegate,TYPE_DECL,"void SendMessageToFrontend(const v8_inspector::StringView& msg) override {
    std::string message = protocol::StringUtil::StringViewToUtf8(msg);
    workers_->Send(id_, message);
  }",3,3,inspector\worker_agent.cc,node.inspector.protocol.anonymous_namespace_7.ParentInspectorSessionDelegate.SendMessageToFrontend,,false,59,62,SendMessageToFrontend,,,3,void node.inspector.protocol.anonymous_namespace_7.ParentInspectorSessionDelegate.SendMessageToFrontend (ANY)
88566,METHOD,inspector\worker_agent.cc:<global>,TYPE_DECL,"std::unique_ptr<NodeWorker::WorkerInfo> WorkerInfo(const std::string& id,
                                                   const std::string& title,
                                                   const std::string& url) {
  return NodeWorker::WorkerInfo::create()
      .setWorkerId(id)
      .setTitle(title)
      .setUrl(url)
      .setType(""worker"").build();
}",1,1,inspector\worker_agent.cc,node.inspector.protocol.anonymous_namespace_8.WorkerInfo,,false,69,77,WorkerInfo,,,3,"unique_ptr<NodeWorker::WorkerInfo> node.inspector.protocol.anonymous_namespace_8.WorkerInfo (ANY,ANY,ANY)"
88599,METHOD,inspector\worker_agent.cc:<global>,TYPE_DECL,"WorkerAgent::WorkerAgent(std::weak_ptr<WorkerManager> manager)
                         : manager_(manager) {}",1,47,inspector\worker_agent.cc,node.inspector.protocol.WorkerAgent.WorkerAgent,,false,80,81,WorkerAgent,,,3,ANY node.inspector.protocol.WorkerAgent.WorkerAgent (ANY)
88604,METHOD,inspector\worker_agent.cc:<global>,TYPE_DECL,"void WorkerAgent::Wire(UberDispatcher* dispatcher) {
  frontend_.reset(new NodeWorker::Frontend(dispatcher->channel()));
  NodeWorker::Dispatcher::wire(dispatcher, this);
  auto manager = manager_.lock();
  CHECK_NOT_NULL(manager);
  workers_ =
      std::make_shared<NodeWorkers>(frontend_, manager->MainThread());
}",1,1,inspector\worker_agent.cc,node.inspector.protocol.WorkerAgent.Wire,,false,84,91,Wire,,,4,void node.inspector.protocol.WorkerAgent.Wire (UberDispatcher*)
88651,METHOD,inspector\worker_agent.cc:<global>,TYPE_DECL,"DispatchResponse WorkerAgent::sendMessageToWorker(const String& message,
                                                  const String& sessionId) {
  workers_->Receive(sessionId, message);
  return DispatchResponse::OK();
}",1,1,inspector\worker_agent.cc,node.inspector.protocol.WorkerAgent.sendMessageToWorker,,false,93,97,sendMessageToWorker,,,5,"DispatchResponse node.inspector.protocol.WorkerAgent.sendMessageToWorker (String,String)"
88668,METHOD,inspector\worker_agent.cc:<global>,TYPE_DECL,"DispatchResponse WorkerAgent::enable(bool waitForDebuggerOnStart) {
  auto manager = manager_.lock();
  if (!manager) {
    return DispatchResponse::OK();
  }
  if (!event_handle_) {
    std::unique_ptr<AgentWorkerInspectorDelegate> delegate(
            new AgentWorkerInspectorDelegate(workers_));
    event_handle_ = manager->SetAutoAttach(std::move(delegate));
  }
  event_handle_->SetWaitOnStart(waitForDebuggerOnStart);
  return DispatchResponse::OK();
}",1,1,inspector\worker_agent.cc,node.inspector.protocol.WorkerAgent.enable,,false,99,111,enable,,,6,DispatchResponse node.inspector.protocol.WorkerAgent.enable (bool)
88719,METHOD,inspector\worker_agent.cc:<global>,TYPE_DECL,"DispatchResponse WorkerAgent::disable() {
  event_handle_.reset();
  return DispatchResponse::OK();
}",1,1,inspector\worker_agent.cc,node.inspector.protocol.WorkerAgent.disable,,false,113,116,disable,,,7,DispatchResponse node.inspector.protocol.WorkerAgent.disable ()
88732,METHOD,inspector\worker_agent.cc:<global>,TYPE_DECL,"DispatchResponse WorkerAgent::detach(const String& sessionId) {
  workers_->Detached(sessionId);
  return DispatchResponse::OK();
}",1,1,inspector\worker_agent.cc,node.inspector.protocol.WorkerAgent.detach,,false,118,121,detach,,,8,DispatchResponse node.inspector.protocol.WorkerAgent.detach (String)
88747,METHOD,inspector\worker_agent.cc:<global>,TYPE_DECL,"void NodeWorkers::WorkerCreated(const std::string& title,
                                const std::string& url,
                                bool waiting,
                                std::shared_ptr<MainThreadHandle> target) {
  auto frontend = frontend_.lock();
  if (!frontend)
    return;
  std::string id = std::to_string(++next_target_id_);
  auto delegate = thread_->MakeDelegateThreadSafe(
      std::unique_ptr<InspectorSessionDelegate>(
          new ParentInspectorSessionDelegate(id, shared_from_this())));
  sessions_[id] = target->Connect(std::move(delegate), true);
  frontend->attachedToWorker(id, WorkerInfo(id, title, url), waiting);
}",1,1,inspector\worker_agent.cc,node.inspector.protocol.NodeWorkers.WorkerCreated,,false,123,136,WorkerCreated,,,9,"void node.inspector.protocol.NodeWorkers.WorkerCreated (ANY,ANY,bool,ANY)"
88817,METHOD,inspector\worker_agent.cc:<global>,TYPE_DECL,"void NodeWorkers::Send(const std::string& id, const std::string& message) {
  auto frontend = frontend_.lock();
  if (frontend)
    frontend->receivedMessageFromWorker(id, message);
}",1,1,inspector\worker_agent.cc,node.inspector.protocol.NodeWorkers.Send,,false,138,142,Send,,,10,"void node.inspector.protocol.NodeWorkers.Send (ANY,ANY)"
88839,METHOD,inspector\worker_agent.cc:<global>,TYPE_DECL,"void NodeWorkers::Receive(const std::string& id, const std::string& message) {
  auto it = sessions_.find(id);
  if (it != sessions_.end())
    it->second->Dispatch(Utf8ToStringView(message)->string());
}",1,1,inspector\worker_agent.cc,node.inspector.protocol.NodeWorkers.Receive,,false,144,148,Receive,,,11,"void node.inspector.protocol.NodeWorkers.Receive (ANY,ANY)"
88872,METHOD,inspector\worker_agent.cc:<global>,TYPE_DECL,"void NodeWorkers::Detached(const std::string& id) {
  if (sessions_.erase(id) == 0)
    return;
  auto frontend = frontend_.lock();
  if (frontend) {
    frontend->detachedFromWorker(id);
  }
}",1,1,inspector\worker_agent.cc,node.inspector.protocol.NodeWorkers.Detached,,false,150,157,Detached,,,12,void node.inspector.protocol.NodeWorkers.Detached (ANY)
88909,METHOD,inspector\worker_agent.hpp:<global>,TYPE_DECL,<global>,1,40,inspector\worker_agent.hpp,inspector\worker_agent.hpp:<global>,,false,1,40,<global>,,,1,
88918,METHOD,node.inspector.protocol.WorkerAgent,TYPE_DECL,explicit WorkerAgent(std::weak_ptr<WorkerManager> manager);,12,60,inspector\worker_agent.hpp,node.inspector.protocol.WorkerAgent.WorkerAgent,,false,18,18,WorkerAgent,,,1,explicit node.inspector.protocol.WorkerAgent.WorkerAgent (ANY)
88923,METHOD,node.inspector.protocol.WorkerAgent,TYPE_DECL,~WorkerAgent() override = default;,3,36,inspector\worker_agent.hpp,node.inspector.protocol.WorkerAgent.~WorkerAgent,,false,19,19,~WorkerAgent,,,2,ANY node.inspector.protocol.WorkerAgent.~WorkerAgent ()
88927,METHOD,node.inspector.protocol.WorkerAgent,TYPE_DECL,void Wire(UberDispatcher* dispatcher);,8,39,inspector\worker_agent.hpp,node.inspector.protocol.WorkerAgent.Wire,,false,21,21,Wire,,,3,void node.inspector.protocol.WorkerAgent.Wire (UberDispatcher*)
88932,METHOD,node.inspector.protocol.WorkerAgent,TYPE_DECL,"DispatchResponse sendMessageToWorker(const String& message,
                                       const String& sessionId) override;",20,72,inspector\worker_agent.hpp,node.inspector.protocol.WorkerAgent.sendMessageToWorker,,false,23,24,sendMessageToWorker,,,4,"DispatchResponse node.inspector.protocol.WorkerAgent.sendMessageToWorker (String,String)"
88938,METHOD,node.inspector.protocol.WorkerAgent,TYPE_DECL,DispatchResponse enable(bool waitForDebuggerOnStart) override;,20,63,inspector\worker_agent.hpp,node.inspector.protocol.WorkerAgent.enable,,false,26,26,enable,,,5,DispatchResponse node.inspector.protocol.WorkerAgent.enable (bool)
88943,METHOD,node.inspector.protocol.WorkerAgent,TYPE_DECL,DispatchResponse disable() override;,20,37,inspector\worker_agent.hpp,node.inspector.protocol.WorkerAgent.disable,,false,27,27,disable,,,6,DispatchResponse node.inspector.protocol.WorkerAgent.disable ()
88947,METHOD,node.inspector.protocol.WorkerAgent,TYPE_DECL,DispatchResponse detach(const String& sessionId) override;,20,59,inspector\worker_agent.hpp,node.inspector.protocol.WorkerAgent.detach,,false,28,28,detach,,,7,DispatchResponse node.inspector.protocol.WorkerAgent.detach (String)
88967,METHOD,inspector\worker_inspector.cc:<global>,TYPE_DECL,<global>,1,44,inspector\worker_inspector.hpp,inspector\worker_inspector.cc:<global>,,false,1,142,<global>,,,1,
88973,METHOD,node.inspector.anonymous_namespace_1.WorkerStartedRequest,TYPE_DECL,"WorkerStartedRequest(
      uint64_t id,
      const std::string& url,
      std::shared_ptr<node::inspector::MainThreadHandle> worker_thread,
      bool waiting,
      const std::string& name)
      : id_(id),
        info_(BuildWorkerTitle(id, name), url, worker_thread),
        waiting_(waiting) {}",3,28,inspector\worker_inspector.cc,node.inspector.anonymous_namespace_2.WorkerStartedRequest.WorkerStartedRequest,,false,13,21,WorkerStartedRequest,,,1,"ANY node.inspector.anonymous_namespace_2.WorkerStartedRequest.WorkerStartedRequest (uint64_t,ANY,ANY,bool,ANY)"
88982,METHOD,node.inspector.anonymous_namespace_1.WorkerStartedRequest,TYPE_DECL,"void Call(MainThreadInterface* thread) override {
    auto manager = thread->inspector_agent()->GetWorkerManager();
    manager->WorkerStarted(id_, info_, waiting_);
  }",3,3,inspector\worker_inspector.cc,node.inspector.anonymous_namespace_3.WorkerStartedRequest.Call,,false,22,25,Call,,,2,void node.inspector.anonymous_namespace_3.WorkerStartedRequest.Call (MainThreadInterface*)
89004,METHOD,node.inspector.anonymous_namespace_1.WorkerStartedRequest,TYPE_DECL,"static std::string BuildWorkerTitle(int id, const std::string& name) {
    return ""[worker "" + std::to_string(id) + ""]"" +
           (name == """" ? """" : "" "" + name);
  }",3,3,inspector\worker_inspector.cc,node.inspector.anonymous_namespace_4.WorkerStartedRequest.BuildWorkerTitle,,false,28,31,BuildWorkerTitle,,,3,"string node.inspector.anonymous_namespace_4.WorkerStartedRequest.BuildWorkerTitle (int,ANY)"
89032,METHOD,inspector\worker_inspector.cc:<global>,TYPE_DECL,"void Report(const std::unique_ptr<WorkerDelegate>& delegate,
            const WorkerInfo& info, bool waiting) {
  if (info.worker_thread)
    delegate->WorkerCreated(info.title, info.url, waiting, info.worker_thread);
}",1,1,inspector\worker_inspector.cc,node.inspector.anonymous_namespace_5.Report,,false,39,43,Report,,,2,"void node.inspector.anonymous_namespace_5.Report (ANY,WorkerInfo,bool)"
89059,METHOD,node.inspector.anonymous_namespace_6.WorkerFinishedRequest,TYPE_DECL,explicit WorkerFinishedRequest(uint64_t worker_id) : worker_id_(worker_id) {},3,79,inspector\worker_inspector.cc,node.inspector.anonymous_namespace_7.WorkerFinishedRequest.WorkerFinishedRequest,,false,47,47,WorkerFinishedRequest,,,1,ANY node.inspector.anonymous_namespace_7.WorkerFinishedRequest.WorkerFinishedRequest (uint64_t)
89064,METHOD,node.inspector.anonymous_namespace_6.WorkerFinishedRequest,TYPE_DECL,"void Call(MainThreadInterface* thread) override {
    thread->inspector_agent()->GetWorkerManager()->WorkerFinished(worker_id_);
  }",3,3,inspector\worker_inspector.cc,node.inspector.anonymous_namespace_8.WorkerFinishedRequest.Call,,false,49,51,Call,,,2,void node.inspector.anonymous_namespace_8.WorkerFinishedRequest.Call (MainThreadInterface*)
89081,METHOD,inspector\worker_inspector.cc:<global>,TYPE_DECL,"ParentInspectorHandle::ParentInspectorHandle(
    uint64_t id,
    const std::string& url,
    std::shared_ptr<MainThreadHandle> parent_thread,
    bool wait_for_connect,
    const std::string& name)
    : id_(id),
      url_(url),
      parent_thread_(parent_thread),
      wait_(wait_for_connect),
      name_(name) {}",1,20,inspector\worker_inspector.cc,node.inspector.ParentInspectorHandle.ParentInspectorHandle,,false,58,68,ParentInspectorHandle,,,2,"ANY node.inspector.ParentInspectorHandle.ParentInspectorHandle (uint64_t,ANY,ANY,bool,ANY)"
89090,METHOD,inspector\worker_inspector.cc:<global>,TYPE_DECL,"ParentInspectorHandle::~ParentInspectorHandle() {
  parent_thread_->Post(
      std::unique_ptr<Request>(new WorkerFinishedRequest(id_)));
}",1,1,inspector\worker_inspector.cc,node.inspector.ParentInspectorHandle.~ParentInspectorHandle,,false,70,73,~ParentInspectorHandle,,,3,ANY node.inspector.ParentInspectorHandle.~ParentInspectorHandle ()
89107,METHOD,inspector\worker_inspector.cc:<global>,TYPE_DECL,"void ParentInspectorHandle::WorkerStarted(
    std::shared_ptr<MainThreadHandle> worker_thread, bool waiting) {
  std::unique_ptr<Request> request(
      new WorkerStartedRequest(id_, url_, worker_thread, waiting, name_));
  parent_thread_->Post(std::move(request));
}",1,1,inspector\worker_inspector.cc,node.inspector.ParentInspectorHandle.WorkerStarted,,false,75,80,WorkerStarted,,,4,"void node.inspector.ParentInspectorHandle.WorkerStarted (ANY,bool)"
89131,METHOD,inspector\worker_inspector.cc:<global>,TYPE_DECL,"std::unique_ptr<inspector::InspectorSession> ParentInspectorHandle::Connect(
    std::unique_ptr<inspector::InspectorSessionDelegate> delegate,
    bool prevent_shutdown) {
  return parent_thread_->Connect(std::move(delegate), prevent_shutdown);
}",1,1,inspector\worker_inspector.cc,node.inspector.ParentInspectorHandle.Connect,,false,82,86,Connect,,,5,"unique_ptr<inspector::InspectorSession> node.inspector.ParentInspectorHandle.Connect (ANY,bool)"
89148,METHOD,inspector\worker_inspector.cc:<global>,TYPE_DECL,"void WorkerManager::WorkerFinished(uint64_t session_id) {
  children_.erase(session_id);
}",1,1,inspector\worker_inspector.cc,node.inspector.WorkerManager.WorkerFinished,,false,88,90,WorkerFinished,,,6,void node.inspector.WorkerManager.WorkerFinished (uint64_t)
89158,METHOD,inspector\worker_inspector.cc:<global>,TYPE_DECL,"void WorkerManager::WorkerStarted(uint64_t session_id,
                                  const WorkerInfo& info,
                                  bool waiting) {
  if (info.worker_thread->Expired())
    return;
  children_.emplace(session_id, info);
  for (const auto& delegate : delegates_) {
    Report(delegate.second, info, waiting);
  }
}",1,1,inspector\worker_inspector.cc,node.inspector.WorkerManager.WorkerStarted,,false,92,101,WorkerStarted,,,7,"void node.inspector.WorkerManager.WorkerStarted (uint64_t,WorkerInfo,bool)"
89190,METHOD,inspector\worker_inspector.cc:<global>,TYPE_DECL,"std::unique_ptr<ParentInspectorHandle> WorkerManager::NewParentHandle(
    uint64_t thread_id, const std::string& url, const std::string& name) {
  bool wait = !delegates_waiting_on_start_.empty();
  return std::make_unique<ParentInspectorHandle>(
      thread_id, url, thread_, wait, name);
}",1,1,inspector\worker_inspector.cc,node.inspector.WorkerManager.NewParentHandle,,false,103,108,NewParentHandle,,,8,"unique_ptr<ParentInspectorHandle> node.inspector.WorkerManager.NewParentHandle (uint64_t,ANY,ANY)"
89219,METHOD,inspector\worker_inspector.cc:<global>,TYPE_DECL,"void WorkerManager::RemoveAttachDelegate(int id) {
  delegates_.erase(id);
  delegates_waiting_on_start_.erase(id);
}",1,1,inspector\worker_inspector.cc,node.inspector.WorkerManager.RemoveAttachDelegate,,false,110,113,RemoveAttachDelegate,,,9,void node.inspector.WorkerManager.RemoveAttachDelegate (int)
89234,METHOD,inspector\worker_inspector.cc:<global>,TYPE_DECL,"std::unique_ptr<WorkerManagerEventHandle> WorkerManager::SetAutoAttach(
    std::unique_ptr<WorkerDelegate> attach_delegate) {
  int id = ++next_delegate_id_;
  delegates_[id] = std::move(attach_delegate);
  const auto& delegate = delegates_[id];
  for (const auto& worker : children_) {
    // Waiting is only reported when a worker is started, same as browser
    Report(delegate, worker.second, false);
  }
  return std::make_unique<WorkerManagerEventHandle>(shared_from_this(), id);
}",1,1,inspector\worker_inspector.cc,node.inspector.WorkerManager.SetAutoAttach,,false,115,125,SetAutoAttach,,,10,unique_ptr<WorkerManagerEventHandle> node.inspector.WorkerManager.SetAutoAttach (ANY)
89280,METHOD,inspector\worker_inspector.cc:<global>,TYPE_DECL,"void WorkerManager::SetWaitOnStartForDelegate(int id, bool wait) {
  if (wait)
    delegates_waiting_on_start_.insert(id);
  else
    delegates_waiting_on_start_.erase(id);
}",1,1,inspector\worker_inspector.cc,node.inspector.WorkerManager.SetWaitOnStartForDelegate,,false,127,132,SetWaitOnStartForDelegate,,,11,"void node.inspector.WorkerManager.SetWaitOnStartForDelegate (int,bool)"
89301,METHOD,inspector\worker_inspector.cc:<global>,TYPE_DECL,"void WorkerManagerEventHandle::SetWaitOnStart(bool wait_on_start) {
    manager_->SetWaitOnStartForDelegate(id_, wait_on_start);
}",1,1,inspector\worker_inspector.cc,node.inspector.WorkerManagerEventHandle.SetWaitOnStart,,false,134,136,SetWaitOnStart,,,12,void node.inspector.WorkerManagerEventHandle.SetWaitOnStart (bool)
89312,METHOD,inspector\worker_inspector.cc:<global>,TYPE_DECL,"WorkerManagerEventHandle::~WorkerManagerEventHandle() {
  manager_->RemoveAttachDelegate(id_);
}",1,1,inspector\worker_inspector.cc,node.inspector.WorkerManagerEventHandle.~WorkerManagerEventHandle,,false,138,140,~WorkerManagerEventHandle,,,13,ANY node.inspector.WorkerManagerEventHandle.~WorkerManagerEventHandle ()
89332,METHOD,inspector\worker_inspector.hpp:<global>,TYPE_DECL,<global>,1,44,inspector\worker_inspector.hpp,inspector\worker_inspector.hpp:<global>,,false,1,113,<global>,,,1,
89341,METHOD,node.inspector.WorkerDelegate,TYPE_DECL,"virtual void WorkerCreated(const std::string& title,
                             const std::string& url,
                             bool waiting,
                             std::shared_ptr<MainThreadHandle> worker) = 0;",16,74,inspector\worker_inspector.hpp,node.inspector.WorkerDelegate.WorkerCreated,,false,22,25,WorkerCreated,,,1,"void node.inspector.WorkerDelegate.WorkerCreated (ANY,ANY,bool,ANY)"
89349,METHOD,node.inspector.WorkerDelegate,TYPE_DECL,virtual ~WorkerDelegate() = default;,3,38,inspector\worker_inspector.hpp,node.inspector.WorkerDelegate.~WorkerDelegate,,false,26,26,~WorkerDelegate,,,2,ANY node.inspector.WorkerDelegate.~WorkerDelegate ()
89354,METHOD,node.inspector.WorkerManagerEventHandle,TYPE_DECL,"explicit WorkerManagerEventHandle(std::shared_ptr<WorkerManager> manager,
                                    int id)
                                    : manager_(manager), id_(id) {}",3,67,inspector\worker_inspector.hpp,node.inspector.WorkerManagerEventHandle.WorkerManagerEventHandle,,false,31,33,WorkerManagerEventHandle,,,1,"ANY node.inspector.WorkerManagerEventHandle.WorkerManagerEventHandle (ANY,int)"
89360,METHOD,node.inspector.WorkerManagerEventHandle,TYPE_DECL,void SetWaitOnStart(bool wait_on_start);,8,41,inspector\worker_inspector.hpp,node.inspector.WorkerManagerEventHandle.SetWaitOnStart,,false,34,34,SetWaitOnStart,,,2,void node.inspector.WorkerManagerEventHandle.SetWaitOnStart (bool)
89365,METHOD,node.inspector.WorkerManagerEventHandle,TYPE_DECL,~WorkerManagerEventHandle();,3,29,inspector\worker_inspector.hpp,node.inspector.WorkerManagerEventHandle.~WorkerManagerEventHandle,,false,35,35,~WorkerManagerEventHandle,,,3,ANY node.inspector.WorkerManagerEventHandle.~WorkerManagerEventHandle ()
89372,METHOD,node.inspector.WorkerInfo,TYPE_DECL,"WorkerInfo(const std::string& target_title,
             const std::string& target_url,
             std::shared_ptr<MainThreadHandle> worker_thread)
             : title(target_title),
               url(target_url),
               worker_thread(worker_thread) {}",3,46,inspector\worker_inspector.hpp,node.inspector.WorkerInfo.WorkerInfo,,false,43,48,WorkerInfo,,,1,"ANY node.inspector.WorkerInfo.WorkerInfo (ANY,ANY,ANY)"
89383,METHOD,node.inspector.ParentInspectorHandle,TYPE_DECL,"ParentInspectorHandle(uint64_t id,
                        const std::string& url,
                        std::shared_ptr<MainThreadHandle> parent_thread,
                        bool wait_for_connect,
                        const std::string& name);",3,48,inspector\worker_inspector.hpp,node.inspector.ParentInspectorHandle.ParentInspectorHandle,,false,56,60,ParentInspectorHandle,,,1,"ANY node.inspector.ParentInspectorHandle.ParentInspectorHandle (uint64_t,ANY,ANY,bool,ANY)"
89392,METHOD,node.inspector.ParentInspectorHandle,TYPE_DECL,~ParentInspectorHandle();,3,26,inspector\worker_inspector.hpp,node.inspector.ParentInspectorHandle.~ParentInspectorHandle,,false,61,61,~ParentInspectorHandle,,,2,ANY node.inspector.ParentInspectorHandle.~ParentInspectorHandle ()
89396,METHOD,node.inspector.ParentInspectorHandle,TYPE_DECL,"std::unique_ptr<ParentInspectorHandle> NewParentInspectorHandle(
      uint64_t thread_id, const std::string& url, const std::string& name) {
    return std::make_unique<ParentInspectorHandle>(
        thread_id, url, parent_thread_, wait_, name);
  }",3,3,inspector\worker_inspector.hpp,node.inspector.ParentInspectorHandle.NewParentInspectorHandle,,false,62,66,NewParentInspectorHandle,,,3,"unique_ptr<ParentInspectorHandle> node.inspector.ParentInspectorHandle.NewParentInspectorHandle (uint64_t,ANY,ANY)"
89417,METHOD,node.inspector.ParentInspectorHandle,TYPE_DECL,"void WorkerStarted(std::shared_ptr<MainThreadHandle> worker_thread,
                     bool waiting);",8,34,inspector\worker_inspector.hpp,node.inspector.ParentInspectorHandle.WorkerStarted,,false,67,68,WorkerStarted,,,4,"void node.inspector.ParentInspectorHandle.WorkerStarted (ANY,bool)"
89423,METHOD,node.inspector.ParentInspectorHandle,TYPE_DECL,"bool WaitForConnect() {
    return wait_;
  }",3,3,inspector\worker_inspector.hpp,node.inspector.ParentInspectorHandle.WaitForConnect,,false,69,71,WaitForConnect,,,5,bool node.inspector.ParentInspectorHandle.WaitForConnect ()
89429,METHOD,node.inspector.ParentInspectorHandle,TYPE_DECL,const std::string& url() const { return url_; },3,49,inspector\worker_inspector.hpp,node.inspector.ParentInspectorHandle.url,,false,72,72,url,,,6,string node.inspector.ParentInspectorHandle.url ()
89435,METHOD,node.inspector.ParentInspectorHandle,TYPE_DECL,"std::unique_ptr<inspector::InspectorSession> Connect(
      std::unique_ptr<inspector::InspectorSessionDelegate> delegate,
      bool prevent_shutdown);",48,28,inspector\worker_inspector.hpp,node.inspector.ParentInspectorHandle.Connect,,false,73,75,Connect,,,7,"ANY node.inspector.ParentInspectorHandle.Connect (ANY,bool)"
89447,METHOD,node.inspector.WorkerManager,TYPE_DECL,"explicit WorkerManager(std::shared_ptr<MainThreadHandle> thread)
                         : thread_(thread) {}",3,45,inspector\worker_inspector.hpp,node.inspector.WorkerManager.WorkerManager,,false,87,88,WorkerManager,,,1,ANY node.inspector.WorkerManager.WorkerManager (ANY)
89452,METHOD,node.inspector.WorkerManager,TYPE_DECL,"std::unique_ptr<ParentInspectorHandle> NewParentHandle(
      uint64_t thread_id, const std::string& url, const std::string& name);",42,74,inspector\worker_inspector.hpp,node.inspector.WorkerManager.NewParentHandle,,false,90,91,NewParentHandle,,,2,"ANY node.inspector.WorkerManager.NewParentHandle (uint64_t,ANY,ANY)"
89459,METHOD,node.inspector.WorkerManager,TYPE_DECL,"void WorkerStarted(uint64_t session_id, const WorkerInfo& info, bool waiting);",8,79,inspector\worker_inspector.hpp,node.inspector.WorkerManager.WorkerStarted,,false,92,92,WorkerStarted,,,3,"void node.inspector.WorkerManager.WorkerStarted (uint64_t,WorkerInfo,bool)"
89466,METHOD,node.inspector.WorkerManager,TYPE_DECL,void WorkerFinished(uint64_t session_id);,8,42,inspector\worker_inspector.hpp,node.inspector.WorkerManager.WorkerFinished,,false,93,93,WorkerFinished,,,4,void node.inspector.WorkerManager.WorkerFinished (uint64_t)
89471,METHOD,node.inspector.WorkerManager,TYPE_DECL,"std::unique_ptr<WorkerManagerEventHandle> SetAutoAttach(
      std::unique_ptr<WorkerDelegate> attach_delegate);",45,54,inspector\worker_inspector.hpp,node.inspector.WorkerManager.SetAutoAttach,,false,94,95,SetAutoAttach,,,5,ANY node.inspector.WorkerManager.SetAutoAttach (ANY)
89476,METHOD,node.inspector.WorkerManager,TYPE_DECL,"void SetWaitOnStartForDelegate(int id, bool wait);",8,51,inspector\worker_inspector.hpp,node.inspector.WorkerManager.SetWaitOnStartForDelegate,,false,96,96,SetWaitOnStartForDelegate,,,6,"void node.inspector.WorkerManager.SetWaitOnStartForDelegate (int,bool)"
89482,METHOD,node.inspector.WorkerManager,TYPE_DECL,void RemoveAttachDelegate(int id);,8,35,inspector\worker_inspector.hpp,node.inspector.WorkerManager.RemoveAttachDelegate,,false,97,97,RemoveAttachDelegate,,,7,void node.inspector.WorkerManager.RemoveAttachDelegate (int)
89487,METHOD,node.inspector.WorkerManager,TYPE_DECL,"std::shared_ptr<MainThreadHandle> MainThread() {
    return thread_;
  }",3,3,inspector\worker_inspector.hpp,node.inspector.WorkerManager.MainThread,,false,98,100,MainThread,,,8,shared_ptr<MainThreadHandle> node.inspector.WorkerManager.MainThread ()
89498,METHOD,<empty>,<empty>,<empty>,1,,inspector\worker_inspector.hpp,node.inspector.WorkerManager:<clinit>,,false,85,,<clinit>,,,14,
89506,METHOD,node.inspector.NodeInspectorClient,TYPE_DECL,[=]() { callback(data); },47,71,inspector_agent.cc,node.inspector.NodeInspectorClient.startRepeatingTimer.<lambda>0,,false,552,552,<lambda>0,,,1,ANY node.inspector.NodeInspectorClient.startRepeatingTimer.<lambda>0 ()
89515,METHOD,inspector_agent.cc:<global>,TYPE_DECL,"[](uv_async_t*) {
        CHECK(start_io_thread_async_initialized.exchange(false));
      }",48,7,inspector_agent.cc,node.inspector.Agent.Start..<lambda>2,,false,722,724,<lambda>2,,,1,ANY node.inspector.Agent.Start..<lambda>2 (uv_async_t*)
89528,METHOD,inspector_agent.cc:<global>,TYPE_DECL,"[](void* data) {
      Environment* env = static_cast<Environment*>(data);

      {
        Mutex::ScopedLock lock(start_io_thread_async_mutex);
        start_io_thread_async.data = nullptr;
      }

      // This is global, will never get freed
      env->CloseHandle(&start_io_thread_async, [](uv_async_t*) {
        CHECK(start_io_thread_async_initialized.exchange(false));
      });
    }",33,5,inspector_agent.cc,node.inspector.Agent.Start.<lambda>1,,false,713,725,<lambda>1,,,1,ANY node.inspector.Agent.Start.<lambda>1 (void*)
89556,METHOD,inspector_agent.cc:<global>,TYPE_DECL,"[](void* env) {
    Agent* agent = static_cast<Environment*>(env)->inspector_agent();
    if (agent->IsActive()) {
      agent->WaitForDisconnect();
    }
  }",23,3,inspector_agent.cc,node.inspector.Agent.Start.<lambda>3,,false,728,733,<lambda>3,,,1,ANY node.inspector.Agent.Start.<lambda>3 (void*)
89581,METHOD,inspector_agent.cc:<global>,TYPE_DECL,"[this](Environment*) {
    StartIoThread();
  }",33,3,inspector_agent.cc,node.inspector.Agent.RequestIoThreadStart.<lambda>4,,false,955,957,<lambda>4,,,1,ANY node.inspector.Agent.RequestIoThreadStart.<lambda>4 (Environment*)
89645,METHOD,inspector_agent.cc:<global>,TYPE_DECL,<global>,1,62,inspector_agent.hpp,inspector_agent.cc:<global>,,false,1,1045,<global>,,,1,
89657,METHOD,inspector_agent.cc:<global>,TYPE_DECL,"std::unique_ptr<StringBuffer> ToProtocolString(Isolate* isolate,
                                               Local<Value> value) {
  TwoByteValue buffer(isolate, value);
  return StringBuffer::create(StringView(*buffer, buffer.length()));
}",1,1,inspector_agent.cc,node.inspector.anonymous_namespace_14.ToProtocolString,,false,66,70,ToProtocolString,,,5,"unique_ptr<StringBuffer> node.inspector.anonymous_namespace_14.ToProtocolString (Isolate*,Local<Value>)"
89679,METHOD,inspector_agent.cc:<global>,TYPE_DECL,"void StartIoThreadAsyncCallback(uv_async_t* handle) {
  static_cast<Agent*>(handle->data)->StartIoThread();
}",1,1,inspector_agent.cc,node.inspector.anonymous_namespace_15.StartIoThreadAsyncCallback,,false,73,75,StartIoThreadAsyncCallback,,,6,void node.inspector.anonymous_namespace_15.StartIoThreadAsyncCallback (uv_async_t*)
89696,METHOD,inspector_agent.cc:<global>,TYPE_DECL,"std::string GetWorkerLabel(node::Environment* env) {
  std::ostringstream result;
  result << ""Worker["" << env->thread_id() << ""]"";
  return result.str();
}",1,1,inspector_agent.cc,node.inspector.anonymous_namespace_16.GetWorkerLabel,,false,206,210,GetWorkerLabel,,,9,string node.inspector.anonymous_namespace_16.GetWorkerLabel (ANY*)
89718,METHOD,node.inspector.anonymous_namespace_17.ChannelImpl,TYPE_DECL,"explicit ChannelImpl(Environment* env,
                       const std::unique_ptr<V8Inspector>& inspector,
                       std::shared_ptr<WorkerManager> worker_manager,
                       std::unique_ptr<InspectorSessionDelegate> delegate,
                       std::shared_ptr<MainThreadHandle> main_thread_,
                       bool prevent_shutdown)
      : delegate_(std::move(delegate)), prevent_shutdown_(prevent_shutdown),
        retaining_context_(false) {
    session_ = inspector->connect(CONTEXT_GROUP_ID,
                                  this,
                                  StringView(),
                                  V8Inspector::ClientTrustLevel::kFullyTrusted);
    node_dispatcher_ = std::make_unique<protocol::UberDispatcher>(this);
    tracing_agent_ =
        std::make_unique<protocol::TracingAgent>(env, main_thread_);
    tracing_agent_->Wire(node_dispatcher_.get());
    if (worker_manager) {
      worker_agent_ = std::make_unique<protocol::Work...",3,3,inspector_agent.cc,node.inspector.anonymous_namespace_18.ChannelImpl.ChannelImpl,,false,215,237,ChannelImpl,,,1,"ANY node.inspector.anonymous_namespace_18.ChannelImpl.ChannelImpl (Environment*,ANY,ANY,ANY,ANY,bool)"
89811,METHOD,node.inspector.anonymous_namespace_17.ChannelImpl,TYPE_DECL,"~ChannelImpl() override {
    tracing_agent_->disable();
    tracing_agent_.reset();  // Dispose before the dispatchers
    if (worker_agent_) {
      worker_agent_->disable();
      worker_agent_.reset();  // Dispose before the dispatchers
    }
    runtime_agent_->disable();
    runtime_agent_.reset();  // Dispose before the dispatchers
  }",3,3,inspector_agent.cc,node.inspector.anonymous_namespace_19.ChannelImpl.~ChannelImpl,,false,239,248,~ChannelImpl,,,2,ANY node.inspector.anonymous_namespace_19.ChannelImpl.~ChannelImpl ()
89842,METHOD,node.inspector.anonymous_namespace_17.ChannelImpl,TYPE_DECL,"void dispatchProtocolMessage(const StringView& message) {
    std::string raw_message = protocol::StringUtil::StringViewToUtf8(message);
    per_process::Debug(DebugCategory::INSPECTOR_SERVER,
                       ""[inspector received] %s\n"",
                       raw_message);
    std::unique_ptr<protocol::DictionaryValue> value =
        protocol::DictionaryValue::cast(protocol::StringUtil::parseMessage(
            raw_message, false));
    int call_id;
    std::string method;
    node_dispatcher_->parseCommand(value.get(), &call_id, &method);
    if (v8_inspector::V8InspectorSession::canDispatchMethod(
            Utf8ToStringView(method)->string())) {
      session_->dispatchProtocolMessage(message);
    } else {
      node_dispatcher_->dispatch(call_id, method, std::move(value),
                                 raw_message);
    }
  }",3,3,inspector_agent.cc,node.inspector.anonymous_namespace_20.ChannelImpl.dispatchProtocolMessage,,false,250,268,dispatchProtocolMessage,,,3,void node.inspector.anonymous_namespace_20.ChannelImpl.dispatchProtocolMessage (StringView)
89936,METHOD,node.inspector.anonymous_namespace_17.ChannelImpl,TYPE_DECL,"void schedulePauseOnNextStatement(const std::string& reason) {
    std::unique_ptr<StringBuffer> buffer = Utf8ToStringView(reason);
    session_->schedulePauseOnNextStatement(buffer->string(), buffer->string());
  }",3,3,inspector_agent.cc,node.inspector.anonymous_namespace_21.ChannelImpl.schedulePauseOnNextStatement,,false,270,273,schedulePauseOnNextStatement,,,4,void node.inspector.anonymous_namespace_21.ChannelImpl.schedulePauseOnNextStatement (ANY)
89958,METHOD,node.inspector.anonymous_namespace_17.ChannelImpl,TYPE_DECL,"bool preventShutdown() {
    return prevent_shutdown_;
  }",3,3,inspector_agent.cc,node.inspector.anonymous_namespace_22.ChannelImpl.preventShutdown,,false,275,277,preventShutdown,,,5,bool node.inspector.anonymous_namespace_22.ChannelImpl.preventShutdown ()
89964,METHOD,node.inspector.anonymous_namespace_17.ChannelImpl,TYPE_DECL,"bool notifyWaitingForDisconnect() {
    retaining_context_ = runtime_agent_->notifyWaitingForDisconnect();
    return retaining_context_;
  }",3,3,inspector_agent.cc,node.inspector.anonymous_namespace_23.ChannelImpl.notifyWaitingForDisconnect,,false,279,282,notifyWaitingForDisconnect,,,6,bool node.inspector.anonymous_namespace_23.ChannelImpl.notifyWaitingForDisconnect ()
89976,METHOD,node.inspector.anonymous_namespace_17.ChannelImpl,TYPE_DECL,"bool retainingContext() {
    return retaining_context_;
  }",3,3,inspector_agent.cc,node.inspector.anonymous_namespace_24.ChannelImpl.retainingContext,,false,284,286,retainingContext,,,7,bool node.inspector.anonymous_namespace_24.ChannelImpl.retainingContext ()
89982,METHOD,node.inspector.anonymous_namespace_17.ChannelImpl,TYPE_DECL,"void sendResponse(
      int callId,
      std::unique_ptr<v8_inspector::StringBuffer> message) override {
    sendMessageToFrontend(message->string());
  }",3,3,inspector_agent.cc,node.inspector.anonymous_namespace_25.ChannelImpl.sendResponse,,false,289,293,sendResponse,,,8,"void node.inspector.anonymous_namespace_25.ChannelImpl.sendResponse (int,ANY)"
89993,METHOD,node.inspector.anonymous_namespace_17.ChannelImpl,TYPE_DECL,"void sendNotification(
      std::unique_ptr<v8_inspector::StringBuffer> message) override {
    sendMessageToFrontend(message->string());
  }",3,3,inspector_agent.cc,node.inspector.anonymous_namespace_26.ChannelImpl.sendNotification,,false,295,298,sendNotification,,,9,void node.inspector.anonymous_namespace_26.ChannelImpl.sendNotification (ANY)
90003,METHOD,node.inspector.anonymous_namespace_17.ChannelImpl,TYPE_DECL,void flushProtocolNotifications() override { },3,48,inspector_agent.cc,node.inspector.anonymous_namespace_27.ChannelImpl.flushProtocolNotifications,,false,300,300,flushProtocolNotifications,,,10,void node.inspector.anonymous_namespace_27.ChannelImpl.flushProtocolNotifications ()
90007,METHOD,node.inspector.anonymous_namespace_17.ChannelImpl,TYPE_DECL,"void sendMessageToFrontend(const StringView& message) {
    if (per_process::enabled_debug_list.enabled(
            DebugCategory::INSPECTOR_SERVER)) {
      std::string raw_message = protocol::StringUtil::StringViewToUtf8(message);
      per_process::Debug(DebugCategory::INSPECTOR_SERVER,
                         ""[inspector send] %s\n"",
                         raw_message);
    }
    delegate_->SendMessageToFrontend(message);
  }",3,3,inspector_agent.cc,node.inspector.anonymous_namespace_28.ChannelImpl.sendMessageToFrontend,,false,302,311,sendMessageToFrontend,,,11,void node.inspector.anonymous_namespace_28.ChannelImpl.sendMessageToFrontend (StringView)
90047,METHOD,node.inspector.anonymous_namespace_17.ChannelImpl,TYPE_DECL,"void sendMessageToFrontend(const std::string& message) {
    sendMessageToFrontend(Utf8ToStringView(message)->string());
  }",3,3,inspector_agent.cc,node.inspector.anonymous_namespace_29.ChannelImpl.sendMessageToFrontend,,false,313,315,sendMessageToFrontend,,,12,void node.inspector.anonymous_namespace_29.ChannelImpl.sendMessageToFrontend (ANY)
90059,METHOD,node.inspector.anonymous_namespace_17.ChannelImpl,TYPE_DECL,"void sendProtocolResponse(int callId,
                            std::unique_ptr<Serializable> message) override {
    sendMessageToFrontend(message->serializeToJSON());
  }",3,3,inspector_agent.cc,node.inspector.anonymous_namespace_30.ChannelImpl.sendProtocolResponse,,false,319,322,sendProtocolResponse,,,14,"void node.inspector.anonymous_namespace_30.ChannelImpl.sendProtocolResponse (int,ANY)"
90070,METHOD,node.inspector.anonymous_namespace_17.ChannelImpl,TYPE_DECL,"void sendProtocolNotification(
      std::unique_ptr<Serializable> message) override {
    sendMessageToFrontend(message->serializeToJSON());
  }",3,3,inspector_agent.cc,node.inspector.anonymous_namespace_31.ChannelImpl.sendProtocolNotification,,false,323,326,sendProtocolNotification,,,15,void node.inspector.anonymous_namespace_31.ChannelImpl.sendProtocolNotification (ANY)
90080,METHOD,node.inspector.anonymous_namespace_17.ChannelImpl,TYPE_DECL,"void fallThrough(int callId,
                   const std::string& method,
                   const std::string& message) override {
    DCHECK(false);
  }",3,3,inspector_agent.cc,node.inspector.anonymous_namespace_32.ChannelImpl.fallThrough,,false,328,332,fallThrough,,,16,"void node.inspector.anonymous_namespace_32.ChannelImpl.fallThrough (int,ANY,ANY)"
90098,METHOD,node.inspector.anonymous_namespace_33.SameThreadInspectorSession,TYPE_DECL,"SameThreadInspectorSession(
      int session_id, std::shared_ptr<NodeInspectorClient> client)
      : session_id_(session_id), client_(client) {}",3,51,inspector_agent.cc,node.inspector.anonymous_namespace_34.SameThreadInspectorSession.SameThreadInspectorSession,,false,346,348,SameThreadInspectorSession,,,1,"ANY node.inspector.anonymous_namespace_34.SameThreadInspectorSession.SameThreadInspectorSession (int,ANY)"
90104,METHOD,node.inspector.anonymous_namespace_33.SameThreadInspectorSession,TYPE_DECL,~SameThreadInspectorSession() override;,3,40,inspector_agent.cc,node.inspector.anonymous_namespace_35.SameThreadInspectorSession.~SameThreadInspectorSession,,false,349,349,~SameThreadInspectorSession,,,2,ANY node.inspector.anonymous_namespace_35.SameThreadInspectorSession.~SameThreadInspectorSession ()
90108,METHOD,node.inspector.anonymous_namespace_33.SameThreadInspectorSession,TYPE_DECL,void Dispatch(const v8_inspector::StringView& message) override;,8,65,inspector_agent.cc,node.inspector.anonymous_namespace_36.SameThreadInspectorSession.Dispatch,,false,350,350,Dispatch,,,3,void node.inspector.anonymous_namespace_36.SameThreadInspectorSession.Dispatch (ANY)
90115,METHOD,inspector_agent.cc:<global>,TYPE_DECL,"void NotifyClusterWorkersDebugEnabled(Environment* env) {
  Isolate* isolate = env->isolate();
  HandleScope handle_scope(isolate);
  Local<Context> context = env->context();

  // Send message to enable debug in cluster workers
  Local<Object> message = Object::New(isolate);
  message->Set(context, FIXED_ONE_BYTE_STRING(isolate, ""cmd""),
               FIXED_ONE_BYTE_STRING(isolate, ""NODE_DEBUG_ENABLED"")).Check();
  ProcessEmit(env, ""internalMessage"", message);
}",1,1,inspector_agent.cc,node.inspector.anonymous_namespace_37.NotifyClusterWorkersDebugEnabled,,false,357,367,NotifyClusterWorkersDebugEnabled,,,12,void node.inspector.anonymous_namespace_37.NotifyClusterWorkersDebugEnabled (Environment*)
90169,METHOD,inspector_agent.cc:<global>,TYPE_DECL,"bool IsFilePath(const std::string& path) {
  return !path.empty() && path[0] == '/';
}",1,1,inspector_agent.cc,node.inspector.anonymous_namespace_38.IsFilePath,,false,382,384,IsFilePath,,,13,bool node.inspector.anonymous_namespace_38.IsFilePath (ANY)
90186,METHOD,inspector_agent.cc:<global>,TYPE_DECL,"void ThrowUninitializedInspectorError(Environment* env) {
  HandleScope scope(env->isolate());

  const char* msg = ""This Environment was initialized without a V8::Inspector"";
  Local<Value> exception =
    v8::String::NewFromUtf8(env->isolate(), msg).ToLocalChecked();

  env->isolate()->ThrowException(exception);
}",1,1,inspector_agent.cc,node.inspector.anonymous_namespace_39.ThrowUninitializedInspectorError,,false,387,395,ThrowUninitializedInspectorError,,,14,void node.inspector.anonymous_namespace_39.ThrowUninitializedInspectorError (Environment*)
90229,METHOD,node.inspector.NodeInspectorClient,TYPE_DECL,"explicit NodeInspectorClient(node::Environment* env, bool is_main)
      : env_(env), is_main_(is_main) {
    client_ = V8Inspector::create(env->isolate(), this);
    // TODO(bnoordhuis) Make name configurable from src/node.cc.
    std::string name =
        is_main_ ? GetHumanReadableProcessName() : GetWorkerLabel(env);
    ContextInfo info(name);
    info.is_default = true;
    contextCreated(env->context(), info);
  }",3,3,inspector_agent.cc,node.inspector.NodeInspectorClient.NodeInspectorClient,,false,401,410,NodeInspectorClient,,,1,"ANY node.inspector.NodeInspectorClient.NodeInspectorClient (ANY*,bool)"
90268,METHOD,node.inspector.NodeInspectorClient,TYPE_DECL,"void runMessageLoopOnPause(int context_group_id) override {
    waiting_for_resume_ = true;
    runMessageLoop();
  }",3,3,inspector_agent.cc,node.inspector.NodeInspectorClient.runMessageLoopOnPause,,false,412,415,runMessageLoopOnPause,,,2,void node.inspector.NodeInspectorClient.runMessageLoopOnPause (int)
90277,METHOD,node.inspector.NodeInspectorClient,TYPE_DECL,"void waitForSessionsDisconnect() {
    waiting_for_sessions_disconnect_ = true;
    runMessageLoop();
  }",3,3,inspector_agent.cc,node.inspector.NodeInspectorClient.waitForSessionsDisconnect,,false,417,420,waitForSessionsDisconnect,,,3,void node.inspector.NodeInspectorClient.waitForSessionsDisconnect ()
90285,METHOD,node.inspector.NodeInspectorClient,TYPE_DECL,"void waitForFrontend() {
    waiting_for_frontend_ = true;
    runMessageLoop();
  }",3,3,inspector_agent.cc,node.inspector.NodeInspectorClient.waitForFrontend,,false,422,425,waitForFrontend,,,4,void node.inspector.NodeInspectorClient.waitForFrontend ()
90293,METHOD,node.inspector.NodeInspectorClient,TYPE_DECL,"void maxAsyncCallStackDepthChanged(int depth) override {
    if (waiting_for_sessions_disconnect_) {
      // V8 isolate is mostly done and is only letting Inspector protocol
      // clients gather data.
      return;
    }
    if (auto agent = env_->inspector_agent()) {
      if (depth == 0) {
        agent->DisableAsyncHook();
      } else {
        agent->EnableAsyncHook();
      }
    }
  }",3,3,inspector_agent.cc,node.inspector.NodeInspectorClient.maxAsyncCallStackDepthChanged,,false,427,440,maxAsyncCallStackDepthChanged,,,5,void node.inspector.NodeInspectorClient.maxAsyncCallStackDepthChanged (int)
90327,METHOD,node.inspector.NodeInspectorClient,TYPE_DECL,"void contextCreated(Local<Context> context, const ContextInfo& info) {
    auto name_buffer = Utf8ToStringView(info.name);
    auto origin_buffer = Utf8ToStringView(info.origin);
    std::unique_ptr<StringBuffer> aux_data_buffer;

    v8_inspector::V8ContextInfo v8info(
        context, CONTEXT_GROUP_ID, name_buffer->string());
    v8info.origin = origin_buffer->string();

    if (info.is_default) {
      aux_data_buffer = Utf8ToStringView(""{\""isDefault\"":true}"");
    } else {
      aux_data_buffer = Utf8ToStringView(""{\""isDefault\"":false}"");
    }
    v8info.auxData = aux_data_buffer->string();

    client_->contextCreated(v8info);
  }",3,3,inspector_agent.cc,node.inspector.NodeInspectorClient.contextCreated,,false,442,459,contextCreated,,,6,"void node.inspector.NodeInspectorClient.contextCreated (Local<Context>,ContextInfo)"
90392,METHOD,node.inspector.NodeInspectorClient,TYPE_DECL,"void contextDestroyed(Local<Context> context) {
    client_->contextDestroyed(context);
  }",3,3,inspector_agent.cc,node.inspector.NodeInspectorClient.contextDestroyed,,false,461,463,contextDestroyed,,,7,void node.inspector.NodeInspectorClient.contextDestroyed (Local<Context>)
90402,METHOD,node.inspector.NodeInspectorClient,TYPE_DECL,"void quitMessageLoopOnPause() override {
    waiting_for_resume_ = false;
  }",3,3,inspector_agent.cc,node.inspector.NodeInspectorClient.quitMessageLoopOnPause,,false,465,467,quitMessageLoopOnPause,,,8,void node.inspector.NodeInspectorClient.quitMessageLoopOnPause ()
90409,METHOD,node.inspector.NodeInspectorClient,TYPE_DECL,"void runIfWaitingForDebugger(int context_group_id) override {
    waiting_for_frontend_ = false;
  }",3,3,inspector_agent.cc,node.inspector.NodeInspectorClient.runIfWaitingForDebugger,,false,469,471,runIfWaitingForDebugger,,,9,void node.inspector.NodeInspectorClient.runIfWaitingForDebugger (int)
90417,METHOD,node.inspector.NodeInspectorClient,TYPE_DECL,"int connectFrontend(std::unique_ptr<InspectorSessionDelegate> delegate,
                      bool prevent_shutdown) {
    int session_id = next_session_id_++;
    channels_[session_id] = std::make_unique<ChannelImpl>(env_,
                                                          client_,
                                                          getWorkerManager(),
                                                          std::move(delegate),
                                                          getThreadHandle(),
                                                          prevent_shutdown);
    return session_id;
  }",3,3,inspector_agent.cc,node.inspector.NodeInspectorClient.connectFrontend,,false,473,483,connectFrontend,,,10,"int node.inspector.NodeInspectorClient.connectFrontend (ANY,bool)"
90452,METHOD,node.inspector.NodeInspectorClient,TYPE_DECL,"void disconnectFrontend(int session_id) {
    auto it = channels_.find(session_id);
    if (it == channels_.end())
      return;
    bool retaining_context = it->second->retainingContext();
    channels_.erase(it);
    if (retaining_context) {
      for (const auto& id_channel : channels_) {
        if (id_channel.second->retainingContext())
          return;
      }
      contextDestroyed(env_->context());
    }
    if (waiting_for_sessions_disconnect_ && !is_main_)
      waiting_for_sessions_disconnect_ = false;
  }",3,3,inspector_agent.cc,node.inspector.NodeInspectorClient.disconnectFrontend,,false,485,500,disconnectFrontend,,,11,void node.inspector.NodeInspectorClient.disconnectFrontend (int)
90518,METHOD,node.inspector.NodeInspectorClient,TYPE_DECL,"void dispatchMessageFromFrontend(int session_id, const StringView& message) {
    channels_[session_id]->dispatchProtocolMessage(message);
  }",3,3,inspector_agent.cc,node.inspector.NodeInspectorClient.dispatchMessageFromFrontend,,false,502,504,dispatchMessageFromFrontend,,,12,"void node.inspector.NodeInspectorClient.dispatchMessageFromFrontend (int,StringView)"
90531,METHOD,node.inspector.NodeInspectorClient,TYPE_DECL,"Local<Context> ensureDefaultContextInGroup(int contextGroupId) override {
    return env_->context();
  }",3,3,inspector_agent.cc,node.inspector.NodeInspectorClient.ensureDefaultContextInGroup,,false,506,508,ensureDefaultContextInGroup,,,13,Local<Context> node.inspector.NodeInspectorClient.ensureDefaultContextInGroup (int)
90541,METHOD,node.inspector.NodeInspectorClient,TYPE_DECL,"void installAdditionalCommandLineAPI(Local<Context> context,
                                       Local<Object> target) override {
    Local<Function> installer = env_->inspector_console_extension_installer();
    if (!installer.IsEmpty()) {
      Local<Value> argv[] = {target};
      // If there is an exception, proceed in JS land
      USE(installer->Call(context, target, arraysize(argv), argv));
    }
  }",3,3,inspector_agent.cc,node.inspector.NodeInspectorClient.installAdditionalCommandLineAPI,,false,510,518,installAdditionalCommandLineAPI,,,14,"void node.inspector.NodeInspectorClient.installAdditionalCommandLineAPI (Local<Context>,Local<Object>)"
90579,METHOD,node.inspector.NodeInspectorClient,TYPE_DECL,"void ReportUncaughtException(Local<Value> error, Local<Message> message) {
    Isolate* isolate = env_->isolate();
    Local<Context> context = env_->context();

    int script_id = message->GetScriptOrigin().ScriptId();

    Local<v8::StackTrace> stack_trace = message->GetStackTrace();

    if (!stack_trace.IsEmpty() && stack_trace->GetFrameCount() > 0 &&
        script_id == stack_trace->GetFrame(isolate, 0)->GetScriptId()) {
      script_id = 0;
    }

    const uint8_t DETAILS[] = ""Uncaught"";

    client_->exceptionThrown(
        context,
        StringView(DETAILS, sizeof(DETAILS) - 1),
        error,
        ToProtocolString(isolate, message->Get())->string(),
        ToProtocolString(isolate, message->GetScriptResourceName())->string(),
        message->GetLineNumber(context).FromMaybe(0),
        message->GetStartColumn(context).FromMaybe(0),
        client_->createStackTrace(stack_trace),
        script_id);
  }",3,3,inspector_agent.cc,node.inspector.NodeInspectorClient.ReportUncaughtException,,false,520,545,ReportUncaughtException,,,15,"void node.inspector.NodeInspectorClient.ReportUncaughtException (Local<Value>,Local<Message>)"
90711,METHOD,node.inspector.NodeInspectorClient,TYPE_DECL,"void startRepeatingTimer(double interval_s,
                           TimerCallback callback,
                           void* data) override {
    auto result =
        timers_.emplace(std::piecewise_construct, std::make_tuple(data),
                        std::make_tuple(env_, [=]() { callback(data); }));
    CHECK(result.second);
    uint64_t interval = static_cast<uint64_t>(1000 * interval_s);
    result.first->second.Update(interval, interval);
  }",3,3,inspector_agent.cc,node.inspector.NodeInspectorClient.startRepeatingTimer,,false,547,556,startRepeatingTimer,,,16,"void node.inspector.NodeInspectorClient.startRepeatingTimer (double,TimerCallback,void*)"
90760,METHOD,node.inspector.NodeInspectorClient,TYPE_DECL,"void cancelTimer(void* data) override {
    timers_.erase(data);
  }",3,3,inspector_agent.cc,node.inspector.NodeInspectorClient.cancelTimer,,false,558,560,cancelTimer,,,17,void node.inspector.NodeInspectorClient.cancelTimer (void*)
90770,METHOD,node.inspector.NodeInspectorClient,TYPE_DECL,"void AsyncTaskScheduled(const StringView& task_name, void* task,
                          bool recurring) {
    client_->asyncTaskScheduled(task_name, task, recurring);
  }",3,3,inspector_agent.cc,node.inspector.NodeInspectorClient.AsyncTaskScheduled,,false,563,566,AsyncTaskScheduled,,,18,"void node.inspector.NodeInspectorClient.AsyncTaskScheduled (StringView,void*,bool)"
90784,METHOD,node.inspector.NodeInspectorClient,TYPE_DECL,"void AsyncTaskCanceled(void* task) {
    client_->asyncTaskCanceled(task);
  }",3,3,inspector_agent.cc,node.inspector.NodeInspectorClient.AsyncTaskCanceled,,false,568,570,AsyncTaskCanceled,,,19,void node.inspector.NodeInspectorClient.AsyncTaskCanceled (void*)
90794,METHOD,node.inspector.NodeInspectorClient,TYPE_DECL,"void AsyncTaskStarted(void* task) {
    client_->asyncTaskStarted(task);
  }",3,3,inspector_agent.cc,node.inspector.NodeInspectorClient.AsyncTaskStarted,,false,572,574,AsyncTaskStarted,,,20,void node.inspector.NodeInspectorClient.AsyncTaskStarted (void*)
90804,METHOD,node.inspector.NodeInspectorClient,TYPE_DECL,"void AsyncTaskFinished(void* task) {
    client_->asyncTaskFinished(task);
  }",3,3,inspector_agent.cc,node.inspector.NodeInspectorClient.AsyncTaskFinished,,false,576,578,AsyncTaskFinished,,,21,void node.inspector.NodeInspectorClient.AsyncTaskFinished (void*)
90814,METHOD,node.inspector.NodeInspectorClient,TYPE_DECL,"void AllAsyncTasksCanceled() {
    client_->allAsyncTasksCanceled();
  }",3,3,inspector_agent.cc,node.inspector.NodeInspectorClient.AllAsyncTasksCanceled,,false,580,582,AllAsyncTasksCanceled,,,22,void node.inspector.NodeInspectorClient.AllAsyncTasksCanceled ()
90822,METHOD,node.inspector.NodeInspectorClient,TYPE_DECL,"void schedulePauseOnNextStatement(const std::string& reason) {
    for (const auto& id_channel : channels_) {
      id_channel.second->schedulePauseOnNextStatement(reason);
    }
  }",3,3,inspector_agent.cc,node.inspector.NodeInspectorClient.schedulePauseOnNextStatement,,false,584,588,schedulePauseOnNextStatement,,,23,void node.inspector.NodeInspectorClient.schedulePauseOnNextStatement (ANY)
90838,METHOD,node.inspector.NodeInspectorClient,TYPE_DECL,"bool hasConnectedSessions() {
    for (const auto& id_channel : channels_) {
      // Other sessions are ""invisible"" more most purposes
      if (id_channel.second->preventShutdown())
        return true;
    }
    return false;
  }",3,3,inspector_agent.cc,node.inspector.NodeInspectorClient.hasConnectedSessions,,false,590,597,hasConnectedSessions,,,24,bool node.inspector.NodeInspectorClient.hasConnectedSessions ()
90858,METHOD,node.inspector.NodeInspectorClient,TYPE_DECL,"bool notifyWaitingForDisconnect() {
    bool retaining_context = false;
    for (const auto& id_channel : channels_) {
      if (id_channel.second->notifyWaitingForDisconnect())
        retaining_context = true;
    }
    return retaining_context;
  }",3,3,inspector_agent.cc,node.inspector.NodeInspectorClient.notifyWaitingForDisconnect,,false,599,606,notifyWaitingForDisconnect,,,25,bool node.inspector.NodeInspectorClient.notifyWaitingForDisconnect ()
90883,METHOD,node.inspector.NodeInspectorClient,TYPE_DECL,"std::shared_ptr<MainThreadHandle> getThreadHandle() {
    if (!interface_) {
      interface_ = std::make_shared<MainThreadInterface>(
          env_->inspector_agent());
    }
    return interface_->GetHandle();
  }",3,3,inspector_agent.cc,node.inspector.NodeInspectorClient.getThreadHandle,,false,608,614,getThreadHandle,,,26,shared_ptr<MainThreadHandle> node.inspector.NodeInspectorClient.getThreadHandle ()
90908,METHOD,node.inspector.NodeInspectorClient,TYPE_DECL,"std::shared_ptr<WorkerManager> getWorkerManager() {
    if (!is_main_) {
      return nullptr;
    }
    if (worker_manager_ == nullptr) {
      worker_manager_ =
          std::make_shared<WorkerManager>(getThreadHandle());
    }
    return worker_manager_;
  }",3,3,inspector_agent.cc,node.inspector.NodeInspectorClient.getWorkerManager,,false,616,625,getWorkerManager,,,27,shared_ptr<WorkerManager> node.inspector.NodeInspectorClient.getWorkerManager ()
90934,METHOD,node.inspector.NodeInspectorClient,TYPE_DECL,"bool IsActive() {
    return !channels_.empty();
  }",3,3,inspector_agent.cc,node.inspector.NodeInspectorClient.IsActive,,false,627,629,IsActive,,,28,bool node.inspector.NodeInspectorClient.IsActive ()
90944,METHOD,node.inspector.NodeInspectorClient,TYPE_DECL,"bool shouldRunMessageLoop() {
    if (waiting_for_frontend_)
      return true;
    if (waiting_for_sessions_disconnect_ || waiting_for_resume_) {
      return hasConnectedSessions();
    }
    return false;
  }",3,3,inspector_agent.cc,node.inspector.NodeInspectorClient.shouldRunMessageLoop,,false,632,639,shouldRunMessageLoop,,,29,bool node.inspector.NodeInspectorClient.shouldRunMessageLoop ()
90962,METHOD,node.inspector.NodeInspectorClient,TYPE_DECL,"void runMessageLoop() {
    if (running_nested_loop_)
      return;

    running_nested_loop_ = true;

    while (shouldRunMessageLoop()) {
      if (interface_) interface_->WaitForFrontendEvent();
      env_->RunAndClearInterrupts();
    }
    running_nested_loop_ = false;
  }",3,3,inspector_agent.cc,node.inspector.NodeInspectorClient.runMessageLoop,,false,641,652,runMessageLoop,,,30,void node.inspector.NodeInspectorClient.runMessageLoop ()
90990,METHOD,node.inspector.NodeInspectorClient,TYPE_DECL,"double currentTimeMS() override {
    return env_->isolate_data()->platform()->CurrentClockTimeMillis();
  }",3,3,inspector_agent.cc,node.inspector.NodeInspectorClient.currentTimeMS,,false,654,656,currentTimeMS,,,31,double node.inspector.NodeInspectorClient.currentTimeMS ()
91005,METHOD,node.inspector.NodeInspectorClient,TYPE_DECL,"std::unique_ptr<StringBuffer> resourceNameToUrl(
      const StringView& resource_name_view) override {
    std::string resource_name =
        protocol::StringUtil::StringViewToUtf8(resource_name_view);
    if (!IsFilePath(resource_name))
      return nullptr;

    std::string url = node::url::FromFilePath(resource_name);
    return Utf8ToStringView(url);
  }",3,3,inspector_agent.cc,node.inspector.NodeInspectorClient.resourceNameToUrl,,false,658,667,resourceNameToUrl,,,32,unique_ptr<StringBuffer> node.inspector.NodeInspectorClient.resourceNameToUrl (StringView)
91052,METHOD,<empty>,<empty>,<empty>,1,,inspector_agent.cc,node.inspector.NodeInspectorClient:<clinit>,,false,399,,<clinit>,,,45,
91071,METHOD,inspector_agent.cc:<global>,TYPE_DECL,"Agent::Agent(Environment* env)
    : parent_env_(env),
      debug_options_(env->options()->debug_options()),
      host_port_(env->inspector_host_port()) {}",1,47,inspector_agent.cc,node.inspector.Agent.Agent,,false,685,688,Agent,,,3,ANY node.inspector.Agent.Agent (Environment*)
91076,METHOD,inspector_agent.cc:<global>,TYPE_DECL,Agent::~Agent() {},1,18,inspector_agent.cc,node.inspector.Agent.~Agent,,false,690,690,~Agent,,,4,ANY node.inspector.Agent.~Agent ()
91080,METHOD,inspector_agent.cc:<global>,TYPE_DECL,"bool Agent::Start(const std::string& path,
                  const DebugOptions& options,
                  std::shared_ptr<ExclusiveAccess<HostPort>> host_port,
                  bool is_main) {
  path_ = path;
  debug_options_ = options;
  CHECK_NOT_NULL(host_port);
  host_port_ = host_port;

  client_ = std::make_shared<NodeInspectorClient>(parent_env_, is_main);
  if (parent_env_->owns_inspector()) {
    Mutex::ScopedLock lock(start_io_thread_async_mutex);
    CHECK_EQ(start_io_thread_async_initialized.exchange(true), false);
    CHECK_EQ(0, uv_async_init(parent_env_->event_loop(),
                              &start_io_thread_async,
                              StartIoThreadAsyncCallback));
    uv_unref(reinterpret_cast<uv_handle_t*>(&start_io_thread_async));
    start_io_thread_async.data = this;
    // Ignore failure, SIGUSR1 won't work, but that should not block node start.
    StartDebugSignalHandler();

    parent_env_->AddCleanupHook([](void* data) {
      Environment* ...",1,1,inspector_agent.cc,node.inspector.Agent.Start,,false,692,753,Start,,,5,"bool node.inspector.Agent.Start (ANY,DebugOptions,ANY,bool)"
91230,METHOD,inspector_agent.cc:<global>,TYPE_DECL,"bool Agent::StartIoThread() {
  if (io_ != nullptr)
    return true;

  THROW_IF_INSUFFICIENT_PERMISSIONS(parent_env_,
                                    permission::PermissionScope::kInspector,
                                    ""StartIoThread"",
                                    false);
  if (!parent_env_->should_create_inspector() && !client_) {
    ThrowUninitializedInspectorError(parent_env_);
    return false;
  }

  CHECK_NOT_NULL(client_);

  io_ = InspectorIo::Start(client_->getThreadHandle(),
                           path_,
                           host_port_,
                           debug_options_.inspect_publish_uid);
  if (io_ == nullptr) {
    return false;
  }
  NotifyClusterWorkersDebugEnabled(parent_env_);
  return true;
}",1,1,inspector_agent.cc,node.inspector.Agent.StartIoThread,,false,755,779,StartIoThread,,,6,bool node.inspector.Agent.StartIoThread ()
91289,METHOD,inspector_agent.cc:<global>,TYPE_DECL,"void Agent::Stop() {
  io_.reset();
}",1,1,inspector_agent.cc,node.inspector.Agent.Stop,,false,781,783,Stop,,,7,void node.inspector.Agent.Stop ()
91297,METHOD,inspector_agent.cc:<global>,TYPE_DECL,"std::unique_ptr<InspectorSession> Agent::Connect(
    std::unique_ptr<InspectorSessionDelegate> delegate,
    bool prevent_shutdown) {
  THROW_IF_INSUFFICIENT_PERMISSIONS(parent_env_,
                                    permission::PermissionScope::kInspector,
                                    ""Connect"",
                                    std::unique_ptr<InspectorSession>{});
  if (!parent_env_->should_create_inspector() && !client_) {
    ThrowUninitializedInspectorError(parent_env_);
    return std::unique_ptr<InspectorSession>{};
  }

  CHECK_NOT_NULL(client_);

  int session_id = client_->connectFrontend(std::move(delegate),
                                            prevent_shutdown);
  return std::unique_ptr<InspectorSession>(
      new SameThreadInspectorSession(session_id, client_));
}",1,1,inspector_agent.cc,node.inspector.Agent.Connect,,false,785,803,Connect,,,8,"unique_ptr<InspectorSession> node.inspector.Agent.Connect (ANY,bool)"
91352,METHOD,inspector_agent.cc:<global>,TYPE_DECL,"std::unique_ptr<InspectorSession> Agent::ConnectToMainThread(
    std::unique_ptr<InspectorSessionDelegate> delegate,
    bool prevent_shutdown) {
  THROW_IF_INSUFFICIENT_PERMISSIONS(parent_env_,
                                    permission::PermissionScope::kInspector,
                                    ""ConnectToMainThread"",
                                    std::unique_ptr<InspectorSession>{});
  if (!parent_env_->should_create_inspector() && !client_) {
    ThrowUninitializedInspectorError(parent_env_);
    return std::unique_ptr<InspectorSession>{};
  }

  CHECK_NOT_NULL(parent_handle_);
  CHECK_NOT_NULL(client_);
  auto thread_safe_delegate =
      client_->getThreadHandle()->MakeDelegateThreadSafe(std::move(delegate));
  return parent_handle_->Connect(std::move(thread_safe_delegate),
                                 prevent_shutdown);
}",1,1,inspector_agent.cc,node.inspector.Agent.ConnectToMainThread,,false,805,823,ConnectToMainThread,,,9,"unique_ptr<InspectorSession> node.inspector.Agent.ConnectToMainThread (ANY,bool)"
91410,METHOD,inspector_agent.cc:<global>,TYPE_DECL,"void Agent::WaitForDisconnect() {
  THROW_IF_INSUFFICIENT_PERMISSIONS(parent_env_,
                                    permission::PermissionScope::kInspector,
                                    ""WaitForDisconnect"");
  if (!parent_env_->should_create_inspector() && !client_) {
    ThrowUninitializedInspectorError(parent_env_);
    return;
  }

  CHECK_NOT_NULL(client_);
  bool is_worker = parent_handle_ != nullptr;
  parent_handle_.reset();
  if (client_->hasConnectedSessions() && !is_worker) {
    fprintf(stderr, ""Waiting for the debugger to disconnect...\n"");
    fflush(stderr);
  }
  if (!client_->notifyWaitingForDisconnect()) {
    client_->contextDestroyed(parent_env_->context());
  } else if (is_worker) {
    client_->waitForSessionsDisconnect();
  }
  if (io_ != nullptr) {
    io_->StopAcceptingNewConnections();
    client_->waitForSessionsDisconnect();
  }
}",1,1,inspector_agent.cc,node.inspector.Agent.WaitForDisconnect,,false,825,850,WaitForDisconnect,,,10,void node.inspector.Agent.WaitForDisconnect ()
91495,METHOD,inspector_agent.cc:<global>,TYPE_DECL,"void Agent::ReportUncaughtException(Local<Value> error,
                                    Local<Message> message) {
  if (!IsListening())
    return;
  client_->ReportUncaughtException(error, message);
  WaitForDisconnect();
}",1,1,inspector_agent.cc,node.inspector.Agent.ReportUncaughtException,,false,852,858,ReportUncaughtException,,,11,"void node.inspector.Agent.ReportUncaughtException (Local<Value>,Local<Message>)"
91513,METHOD,inspector_agent.cc:<global>,TYPE_DECL,"void Agent::PauseOnNextJavascriptStatement(const std::string& reason) {
  client_->schedulePauseOnNextStatement(reason);
}",1,1,inspector_agent.cc,node.inspector.Agent.PauseOnNextJavascriptStatement,,false,860,862,PauseOnNextJavascriptStatement,,,12,void node.inspector.Agent.PauseOnNextJavascriptStatement (ANY)
91523,METHOD,inspector_agent.cc:<global>,TYPE_DECL,"void Agent::RegisterAsyncHook(Isolate* isolate,
                              Local<Function> enable_function,
                              Local<Function> disable_function) {
  parent_env_->set_inspector_enable_async_hooks(enable_function);
  parent_env_->set_inspector_disable_async_hooks(disable_function);
  if (pending_enable_async_hook_) {
    CHECK(!pending_disable_async_hook_);
    pending_enable_async_hook_ = false;
    EnableAsyncHook();
  } else if (pending_disable_async_hook_) {
    CHECK(!pending_enable_async_hook_);
    pending_disable_async_hook_ = false;
    DisableAsyncHook();
  }
}",1,1,inspector_agent.cc,node.inspector.Agent.RegisterAsyncHook,,false,864,878,RegisterAsyncHook,,,13,"void node.inspector.Agent.RegisterAsyncHook (Isolate*,Local<Function>,Local<Function>)"
91562,METHOD,inspector_agent.cc:<global>,TYPE_DECL,"void Agent::EnableAsyncHook() {
  HandleScope scope(parent_env_->isolate());
  Local<Function> enable = parent_env_->inspector_enable_async_hooks();
  if (!enable.IsEmpty()) {
    ToggleAsyncHook(parent_env_->isolate(), enable);
  } else if (pending_disable_async_hook_) {
    CHECK(!pending_enable_async_hook_);
    pending_disable_async_hook_ = false;
  } else {
    pending_enable_async_hook_ = true;
  }
}",1,1,inspector_agent.cc,node.inspector.Agent.EnableAsyncHook,,false,880,891,EnableAsyncHook,,,14,void node.inspector.Agent.EnableAsyncHook ()
91611,METHOD,inspector_agent.cc:<global>,TYPE_DECL,"void Agent::DisableAsyncHook() {
  HandleScope scope(parent_env_->isolate());
  Local<Function> disable = parent_env_->inspector_enable_async_hooks();
  if (!disable.IsEmpty()) {
    ToggleAsyncHook(parent_env_->isolate(), disable);
  } else if (pending_enable_async_hook_) {
    CHECK(!pending_disable_async_hook_);
    pending_enable_async_hook_ = false;
  } else {
    pending_disable_async_hook_ = true;
  }
}",1,1,inspector_agent.cc,node.inspector.Agent.DisableAsyncHook,,false,893,904,DisableAsyncHook,,,15,void node.inspector.Agent.DisableAsyncHook ()
91660,METHOD,inspector_agent.cc:<global>,TYPE_DECL,"void Agent::ToggleAsyncHook(Isolate* isolate, Local<Function> fn) {
  // Guard against running this during cleanup -- no async events will be
  // emitted anyway at that point anymore, and calling into JS is not possible.
  // This should probably not be something we're attempting in the first place,
  // Refs: https://github.com/nodejs/node/pull/34362#discussion_r456006039
  if (!parent_env_->can_call_into_js()) return;
  CHECK(parent_env_->has_run_bootstrapping_code());
  HandleScope handle_scope(isolate);
  CHECK(!fn.IsEmpty());
  auto context = parent_env_->context();
  v8::TryCatch try_catch(isolate);
  USE(fn->Call(context, Undefined(isolate), 0, nullptr));
  if (try_catch.HasCaught() && !try_catch.HasTerminated()) {
    PrintCaughtException(isolate, context, try_catch);
    OnFatalError(""\nnode::inspector::Agent::ToggleAsyncHook"",
                 ""Cannot toggle Inspector's AsyncHook, please report this."");
  }
}",1,1,inspector_agent.cc,node.inspector.Agent.ToggleAsyncHook,,false,906,923,ToggleAsyncHook,,,16,"void node.inspector.Agent.ToggleAsyncHook (Isolate*,Local<Function>)"
91727,METHOD,inspector_agent.cc:<global>,TYPE_DECL,"void Agent::AsyncTaskScheduled(const StringView& task_name, void* task,
                               bool recurring) {
  client_->AsyncTaskScheduled(task_name, task, recurring);
}",1,1,inspector_agent.cc,node.inspector.Agent.AsyncTaskScheduled,,false,925,928,AsyncTaskScheduled,,,17,"void node.inspector.Agent.AsyncTaskScheduled (StringView,void*,bool)"
91741,METHOD,inspector_agent.cc:<global>,TYPE_DECL,"void Agent::AsyncTaskCanceled(void* task) {
  client_->AsyncTaskCanceled(task);
}",1,1,inspector_agent.cc,node.inspector.Agent.AsyncTaskCanceled,,false,930,932,AsyncTaskCanceled,,,18,void node.inspector.Agent.AsyncTaskCanceled (void*)
91751,METHOD,inspector_agent.cc:<global>,TYPE_DECL,"void Agent::AsyncTaskStarted(void* task) {
  client_->AsyncTaskStarted(task);
}",1,1,inspector_agent.cc,node.inspector.Agent.AsyncTaskStarted,,false,934,936,AsyncTaskStarted,,,19,void node.inspector.Agent.AsyncTaskStarted (void*)
91761,METHOD,inspector_agent.cc:<global>,TYPE_DECL,"void Agent::AsyncTaskFinished(void* task) {
  client_->AsyncTaskFinished(task);
}",1,1,inspector_agent.cc,node.inspector.Agent.AsyncTaskFinished,,false,938,940,AsyncTaskFinished,,,20,void node.inspector.Agent.AsyncTaskFinished (void*)
91771,METHOD,inspector_agent.cc:<global>,TYPE_DECL,"void Agent::AllAsyncTasksCanceled() {
  client_->AllAsyncTasksCanceled();
}",1,1,inspector_agent.cc,node.inspector.Agent.AllAsyncTasksCanceled,,false,942,944,AllAsyncTasksCanceled,,,21,void node.inspector.Agent.AllAsyncTasksCanceled ()
91779,METHOD,inspector_agent.cc:<global>,TYPE_DECL,"void Agent::RequestIoThreadStart() {
  // We need to attempt to interrupt V8 flow (in case Node is running
  // continuous JS code) and to wake up libuv thread (in case Node is waiting
  // for IO events)
  if (!options().allow_attaching_debugger) {
    return;
  }
  CHECK(start_io_thread_async_initialized);
  uv_async_send(&start_io_thread_async);
  parent_env_->RequestInterrupt([this](Environment*) {
    StartIoThread();
  });

  CHECK(start_io_thread_async_initialized);
  uv_async_send(&start_io_thread_async);
}",1,1,inspector_agent.cc,node.inspector.Agent.RequestIoThreadStart,,false,946,961,RequestIoThreadStart,,,22,void node.inspector.Agent.RequestIoThreadStart ()
91802,METHOD,inspector_agent.cc:<global>,TYPE_DECL,"void Agent::ContextCreated(Local<Context> context, const ContextInfo& info) {
  if (client_ == nullptr)  // This happens for a main context
    return;
  client_->contextCreated(context, info);
}",1,1,inspector_agent.cc,node.inspector.Agent.ContextCreated,,false,963,967,ContextCreated,,,23,"void node.inspector.Agent.ContextCreated (Local<Context>,ContextInfo)"
91820,METHOD,inspector_agent.cc:<global>,TYPE_DECL,"bool Agent::IsActive() {
  if (client_ == nullptr)
    return false;
  return io_ != nullptr || client_->IsActive();
}",1,1,inspector_agent.cc,node.inspector.Agent.IsActive,,false,969,973,IsActive,,,24,bool node.inspector.Agent.IsActive ()
91840,METHOD,inspector_agent.cc:<global>,TYPE_DECL,"void Agent::SetParentHandle(
    std::unique_ptr<ParentInspectorHandle> parent_handle) {
  parent_handle_ = std::move(parent_handle);
}",1,1,inspector_agent.cc,node.inspector.Agent.SetParentHandle,,false,975,978,SetParentHandle,,,25,void node.inspector.Agent.SetParentHandle (ANY)
91852,METHOD,inspector_agent.cc:<global>,TYPE_DECL,"std::unique_ptr<ParentInspectorHandle> Agent::GetParentHandle(
    uint64_t thread_id, const std::string& url, const std::string& name) {
  THROW_IF_INSUFFICIENT_PERMISSIONS(parent_env_,
                                    permission::PermissionScope::kInspector,
                                    ""GetParentHandle"",
                                    std::unique_ptr<ParentInspectorHandle>{});
  if (!parent_env_->should_create_inspector() && !client_) {
    ThrowUninitializedInspectorError(parent_env_);
    return std::unique_ptr<ParentInspectorHandle>{};
  }

  CHECK_NOT_NULL(client_);
  if (!parent_handle_) {
    return client_->getWorkerManager()->NewParentHandle(thread_id, url, name);
  } else {
    return parent_handle_->NewParentInspectorHandle(thread_id, url, name);
  }
}",1,1,inspector_agent.cc,node.inspector.Agent.GetParentHandle,,false,980,997,GetParentHandle,,,26,"unique_ptr<ParentInspectorHandle> node.inspector.Agent.GetParentHandle (uint64_t,ANY,ANY)"
91909,METHOD,inspector_agent.cc:<global>,TYPE_DECL,"void Agent::WaitForConnect() {
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      parent_env_, permission::PermissionScope::kInspector, ""WaitForConnect"");
  if (!parent_env_->should_create_inspector() && !client_) {
    ThrowUninitializedInspectorError(parent_env_);
    return;
  }

  CHECK_NOT_NULL(client_);
  client_->waitForFrontend();
}",1,1,inspector_agent.cc,node.inspector.Agent.WaitForConnect,,false,999,1009,WaitForConnect,,,27,void node.inspector.Agent.WaitForConnect ()
91938,METHOD,inspector_agent.cc:<global>,TYPE_DECL,"std::shared_ptr<WorkerManager> Agent::GetWorkerManager() {
  THROW_IF_INSUFFICIENT_PERMISSIONS(parent_env_,
                                    permission::PermissionScope::kInspector,
                                    ""GetWorkerManager"",
                                    std::unique_ptr<WorkerManager>{});
  if (!parent_env_->should_create_inspector() && !client_) {
    ThrowUninitializedInspectorError(parent_env_);
    return std::unique_ptr<WorkerManager>{};
  }

  CHECK_NOT_NULL(client_);
  return client_->getWorkerManager();
}",1,1,inspector_agent.cc,node.inspector.Agent.GetWorkerManager,,false,1011,1023,GetWorkerManager,,,28,shared_ptr<WorkerManager> node.inspector.Agent.GetWorkerManager ()
91972,METHOD,inspector_agent.cc:<global>,TYPE_DECL,"std::string Agent::GetWsUrl() const {
  if (io_ == nullptr)
    return """";
  return io_->GetWsUrl();
}",1,1,inspector_agent.cc,node.inspector.Agent.GetWsUrl,,false,1025,1029,GetWsUrl,,,29,string node.inspector.Agent.GetWsUrl ()
91988,METHOD,inspector_agent.cc:<global>,TYPE_DECL,"SameThreadInspectorSession::~SameThreadInspectorSession() {
  auto client = client_.lock();
  if (client)
    client->disconnectFrontend(session_id_);
}",1,1,inspector_agent.cc,node.inspector.SameThreadInspectorSession.~SameThreadInspectorSession,,false,1031,1035,~SameThreadInspectorSession,,,30,ANY node.inspector.SameThreadInspectorSession.~SameThreadInspectorSession ()
92007,METHOD,inspector_agent.cc:<global>,TYPE_DECL,"void SameThreadInspectorSession::Dispatch(
    const v8_inspector::StringView& message) {
  auto client = client_.lock();
  if (client)
    client->dispatchMessageFromFrontend(session_id_, message);
}",1,1,inspector_agent.cc,node.inspector.SameThreadInspectorSession.Dispatch,,false,1037,1042,Dispatch,,,31,void node.inspector.SameThreadInspectorSession.Dispatch (ANY)
92039,METHOD,inspector_agent.hpp:<global>,TYPE_DECL,<global>,1,62,inspector_agent.hpp,inspector_agent.hpp:<global>,,false,1,144,<global>,,,1,
92042,METHOD,node.inspector.anonymous_namespace_9.RequestQueueData,TYPE_DECL,"[](uv_async_t* async) {
      RequestQueueData* wrapper =
          node::ContainerOf(&RequestQueueData::async_, async);
      wrapper->DoDispatch();
    }",44,5,inspector_io.cc,node.inspector.anonymous_namespace_11.RequestQueueData.RequestQueueData.<lambda>0,,false,101,105,<lambda>0,,,1,ANY node.inspector.anonymous_namespace_11.RequestQueueData.RequestQueueData.<lambda>0 (uv_async_t*)
92065,METHOD,inspector_io.cc:<global>,TYPE_DECL,"[](uv_handle_t* handle) {
    uv_async_t* async = reinterpret_cast<uv_async_t*>(handle);
    RequestQueueData* wrapper =
        node::ContainerOf(&RequestQueueData::async_, async);
    delete wrapper;
  }",12,3,inspector_io.cc,node.inspector.RequestQueueData.CloseAndFree.<lambda>1,,false,376,381,<lambda>1,,,1,ANY node.inspector.RequestQueueData.CloseAndFree.<lambda>1 (uv_handle_t*)
92125,METHOD,inspector_io.cc:<global>,TYPE_DECL,<global>,1,62,inspector_io.hpp,inspector_io.cc:<global>,,false,1,384,<global>,,,1,
92134,METHOD,inspector_io.cc:<global>,TYPE_DECL,"std::string ScriptPath(uv_loop_t* loop, const std::string& script_name) {
  std::string script_path;

  if (!script_name.empty()) {
    uv_fs_t req;
    req.ptr = nullptr;
    if (0 == uv_fs_realpath(loop, &req, script_name.c_str(), nullptr)) {
      CHECK_NOT_NULL(req.ptr);
      script_path = std::string(static_cast<char*>(req.ptr));
    }
    uv_fs_req_cleanup(&req);
  }

  return script_path;
}",1,1,inspector_io.cc,node.inspector.anonymous_namespace_4.ScriptPath,,false,29,43,ScriptPath,,,2,"string node.inspector.anonymous_namespace_4.ScriptPath (uv_loop_t*,ANY)"
92187,METHOD,inspector_io.cc:<global>,TYPE_DECL,"std::string GenerateID() {
  uint16_t buffer[8];
  CHECK(crypto::CSPRNG(buffer, sizeof(buffer)).is_ok());

  char uuid[256];
  snprintf(uuid, sizeof(uuid), ""%04x%04x-%04x-%04x-%04x-%04x%04x%04x"",
           buffer[0],  // time_low
           buffer[1],  // time_mid
           buffer[2],  // time_low
           (buffer[3] & 0x0fff) | 0x4000,  // time_hi_and_version
           (buffer[4] & 0x3fff) | 0x8000,  // clk_seq_hi clk_seq_low
           buffer[5],  // node
           buffer[6],
           buffer[7]);
  return uuid;
}",1,1,inspector_io.cc,node.inspector.anonymous_namespace_5.GenerateID,,false,47,62,GenerateID,,,3,string node.inspector.anonymous_namespace_5.GenerateID ()
92244,METHOD,node.inspector.anonymous_namespace_6.RequestToServer,TYPE_DECL,"RequestToServer(TransportAction action,
                  int session_id,
                  std::unique_ptr<v8_inspector::StringBuffer> message)
                  : action_(action),
                    session_id_(session_id),
                    message_(std::move(message)) {}",3,51,inspector_io.cc,node.inspector.anonymous_namespace_7.RequestToServer.RequestToServer,,false,66,71,RequestToServer,,,1,"ANY node.inspector.anonymous_namespace_7.RequestToServer.RequestToServer (TransportAction,int,ANY)"
92251,METHOD,node.inspector.anonymous_namespace_6.RequestToServer,TYPE_DECL,"void Dispatch(InspectorSocketServer* server) const {
    switch (action_) {
      case TransportAction::kKill:
        server->TerminateConnections();
        [[fallthrough]];
      case TransportAction::kStop:
        server->Stop();
        break;
      case TransportAction::kSendMessage:
        server->Send(
            session_id_,
            protocol::StringUtil::StringViewToUtf8(message_->string()));
        break;
    }
  }",3,3,inspector_io.cc,node.inspector.anonymous_namespace_8.RequestToServer.Dispatch,,false,73,87,Dispatch,,,2,void node.inspector.anonymous_namespace_8.RequestToServer.Dispatch (InspectorSocketServer*)
92300,METHOD,node.inspector.anonymous_namespace_9.RequestQueueData,TYPE_DECL,"explicit RequestQueueData(uv_loop_t* loop)
                            : handle_(std::make_shared<RequestQueue>(this)) {
    int err = uv_async_init(loop, &async_, [](uv_async_t* async) {
      RequestQueueData* wrapper =
          node::ContainerOf(&RequestQueueData::async_, async);
      wrapper->DoDispatch();
    });
    CHECK_EQ(0, err);
  }",3,3,inspector_io.cc,node.inspector.anonymous_namespace_10.RequestQueueData.RequestQueueData,,false,99,107,RequestQueueData,,,2,ANY node.inspector.anonymous_namespace_10.RequestQueueData.RequestQueueData (uv_loop_t*)
92316,METHOD,node.inspector.anonymous_namespace_9.RequestQueueData,TYPE_DECL,static void CloseAndFree(RequestQueueData* queue);,15,51,inspector_io.cc,node.inspector.anonymous_namespace_12.RequestQueueData.CloseAndFree,,false,109,109,CloseAndFree,,,3,void node.inspector.anonymous_namespace_12.RequestQueueData.CloseAndFree (RequestQueueData*)
92321,METHOD,node.inspector.anonymous_namespace_9.RequestQueueData,TYPE_DECL,"void Post(int session_id,
            TransportAction action,
            std::unique_ptr<StringBuffer> message) {
    Mutex::ScopedLock scoped_lock(state_lock_);
    bool notify = messages_.empty();
    messages_.emplace_back(action, session_id, std::move(message));
    if (notify) {
      CHECK_EQ(0, uv_async_send(&async_));
      incoming_message_cond_.Broadcast(scoped_lock);
    }
  }",3,3,inspector_io.cc,node.inspector.anonymous_namespace_13.RequestQueueData.Post,,false,111,121,Post,,,4,"void node.inspector.anonymous_namespace_13.RequestQueueData.Post (int,TransportAction,ANY)"
92362,METHOD,node.inspector.anonymous_namespace_9.RequestQueueData,TYPE_DECL,"void Wait() {
    Mutex::ScopedLock scoped_lock(state_lock_);
    if (messages_.empty()) {
      incoming_message_cond_.Wait(scoped_lock);
    }
  }",3,3,inspector_io.cc,node.inspector.anonymous_namespace_14.RequestQueueData.Wait,,false,123,128,Wait,,,5,void node.inspector.anonymous_namespace_14.RequestQueueData.Wait ()
92380,METHOD,node.inspector.anonymous_namespace_9.RequestQueueData,TYPE_DECL,"void SetServer(InspectorSocketServer* server) {
    server_ = server;
  }",3,3,inspector_io.cc,node.inspector.anonymous_namespace_15.RequestQueueData.SetServer,,false,130,132,SetServer,,,6,void node.inspector.anonymous_namespace_15.RequestQueueData.SetServer (InspectorSocketServer*)
92388,METHOD,node.inspector.anonymous_namespace_9.RequestQueueData,TYPE_DECL,"std::shared_ptr<RequestQueue> handle() {
    return handle_;
  }",3,3,inspector_io.cc,node.inspector.anonymous_namespace_16.RequestQueueData.handle,,false,134,136,handle,,,7,shared_ptr<RequestQueue> node.inspector.anonymous_namespace_16.RequestQueueData.handle ()
92394,METHOD,node.inspector.anonymous_namespace_9.RequestQueueData,TYPE_DECL,~RequestQueueData() = default;,3,32,inspector_io.cc,node.inspector.anonymous_namespace_17.RequestQueueData.~RequestQueueData,,false,139,139,~RequestQueueData,,,8,ANY node.inspector.anonymous_namespace_17.RequestQueueData.~RequestQueueData ()
92398,METHOD,node.inspector.anonymous_namespace_9.RequestQueueData,TYPE_DECL,"MessageQueue GetMessages() {
    Mutex::ScopedLock scoped_lock(state_lock_);
    MessageQueue messages;
    messages_.swap(messages);
    return messages;
  }",3,3,inspector_io.cc,node.inspector.anonymous_namespace_18.RequestQueueData.GetMessages,,false,141,146,GetMessages,,,9,MessageQueue node.inspector.anonymous_namespace_18.RequestQueueData.GetMessages ()
92413,METHOD,node.inspector.anonymous_namespace_9.RequestQueueData,TYPE_DECL,"void DoDispatch() {
    if (server_ == nullptr)
      return;
    for (const auto& request : GetMessages()) {
      request.Dispatch(server_);
    }
  }",3,3,inspector_io.cc,node.inspector.anonymous_namespace_19.RequestQueueData.DoDispatch,,false,148,154,DoDispatch,,,10,void node.inspector.anonymous_namespace_19.RequestQueueData.DoDispatch ()
92438,METHOD,<empty>,<empty>,<empty>,1,,inspector_io.cc,node.inspector.anonymous_namespace_9.RequestQueueData:<clinit>,,false,95,,<clinit>,,,17,
92446,METHOD,node.inspector.RequestQueue,TYPE_DECL,explicit RequestQueue(RequestQueueData* data) : data_(data) {},3,64,inspector_io.cc,node.inspector.RequestQueue.RequestQueue,,false,167,167,RequestQueue,,,1,ANY node.inspector.RequestQueue.RequestQueue (RequestQueueData*)
92451,METHOD,node.inspector.RequestQueue,TYPE_DECL,"void Reset() {
    Mutex::ScopedLock scoped_lock(lock_);
    data_ = nullptr;
  }",3,3,inspector_io.cc,node.inspector.RequestQueue.Reset,,false,169,172,Reset,,,2,void node.inspector.RequestQueue.Reset ()
92461,METHOD,node.inspector.RequestQueue,TYPE_DECL,"void Post(int session_id,
            TransportAction action,
            std::unique_ptr<StringBuffer> message) {
    Mutex::ScopedLock scoped_lock(lock_);
    if (data_ != nullptr)
      data_->Post(session_id, action, std::move(message));
  }",3,3,inspector_io.cc,node.inspector.RequestQueue.Post,,false,174,180,Post,,,3,"void node.inspector.RequestQueue.Post (int,TransportAction,ANY)"
92487,METHOD,node.inspector.RequestQueue,TYPE_DECL,"bool Expired() {
    Mutex::ScopedLock scoped_lock(lock_);
    return data_ == nullptr;
  }",3,3,inspector_io.cc,node.inspector.RequestQueue.Expired,,false,182,185,Expired,,,4,bool node.inspector.RequestQueue.Expired ()
92501,METHOD,node.inspector.IoSessionDelegate,TYPE_DECL,"explicit IoSessionDelegate(std::shared_ptr<RequestQueue> queue, int id)
                             : request_queue_(queue), id_(id) { }",3,65,inspector_io.cc,node.inspector.IoSessionDelegate.IoSessionDelegate,,false,194,195,IoSessionDelegate,,,1,"ANY node.inspector.IoSessionDelegate.IoSessionDelegate (ANY,int)"
92507,METHOD,node.inspector.IoSessionDelegate,TYPE_DECL,"void SendMessageToFrontend(const v8_inspector::StringView& message) override {
    request_queue_->Post(id_, TransportAction::kSendMessage,
                         StringBuffer::create(message));
  }",3,3,inspector_io.cc,node.inspector.IoSessionDelegate.SendMessageToFrontend,,false,196,199,SendMessageToFrontend,,,2,void node.inspector.IoSessionDelegate.SendMessageToFrontend (ANY)
92528,METHOD,node.inspector.InspectorIoDelegate,TYPE_DECL,"InspectorIoDelegate(std::shared_ptr<RequestQueueData> queue,
                      std::shared_ptr<MainThreadHandle> main_thread,
                      const std::string& target_id,
                      const std::string& script_path,
                      const std::string& script_name);",3,53,inspector_io.cc,node.inspector.InspectorIoDelegate.InspectorIoDelegate,,false,210,214,InspectorIoDelegate,,,1,"ANY node.inspector.InspectorIoDelegate.InspectorIoDelegate (ANY,ANY,ANY,ANY,ANY)"
92537,METHOD,node.inspector.InspectorIoDelegate,TYPE_DECL,~InspectorIoDelegate() override = default;,3,44,inspector_io.cc,node.inspector.InspectorIoDelegate.~InspectorIoDelegate,,false,215,215,~InspectorIoDelegate,,,2,ANY node.inspector.InspectorIoDelegate.~InspectorIoDelegate ()
92541,METHOD,node.inspector.InspectorIoDelegate,TYPE_DECL,"void StartSession(int session_id, const std::string& target_id) override;",8,74,inspector_io.cc,node.inspector.InspectorIoDelegate.StartSession,,false,217,217,StartSession,,,3,"void node.inspector.InspectorIoDelegate.StartSession (int,ANY)"
92547,METHOD,node.inspector.InspectorIoDelegate,TYPE_DECL,"void MessageReceived(int session_id, const std::string& message) override;",8,75,inspector_io.cc,node.inspector.InspectorIoDelegate.MessageReceived,,false,218,218,MessageReceived,,,4,"void node.inspector.InspectorIoDelegate.MessageReceived (int,ANY)"
92553,METHOD,node.inspector.InspectorIoDelegate,TYPE_DECL,void EndSession(int session_id) override;,8,42,inspector_io.cc,node.inspector.InspectorIoDelegate.EndSession,,false,219,219,EndSession,,,5,void node.inspector.InspectorIoDelegate.EndSession (int)
92558,METHOD,node.inspector.InspectorIoDelegate,TYPE_DECL,std::vector<std::string> GetTargetIds() override;,28,50,inspector_io.cc,node.inspector.InspectorIoDelegate.GetTargetIds,,false,221,221,GetTargetIds,,,6,ANY node.inspector.InspectorIoDelegate.GetTargetIds ()
92562,METHOD,node.inspector.InspectorIoDelegate,TYPE_DECL,std::string GetTargetTitle(const std::string& id) override;,15,60,inspector_io.cc,node.inspector.InspectorIoDelegate.GetTargetTitle,,false,222,222,GetTargetTitle,,,7,ANY node.inspector.InspectorIoDelegate.GetTargetTitle (ANY)
92567,METHOD,node.inspector.InspectorIoDelegate,TYPE_DECL,std::string GetTargetUrl(const std::string& id) override;,15,58,inspector_io.cc,node.inspector.InspectorIoDelegate.GetTargetUrl,,false,223,223,GetTargetUrl,,,8,ANY node.inspector.InspectorIoDelegate.GetTargetUrl (ANY)
92572,METHOD,node.inspector.InspectorIoDelegate,TYPE_DECL,"void AssignServer(InspectorSocketServer* server) override {
    request_queue_->SetServer(server);
  }",3,3,inspector_io.cc,node.inspector.InspectorIoDelegate.AssignServer,,false,224,226,AssignServer,,,9,void node.inspector.InspectorIoDelegate.AssignServer (InspectorSocketServer*)
92588,METHOD,inspector_io.cc:<global>,TYPE_DECL,"std::unique_ptr<InspectorIo> InspectorIo::Start(
    std::shared_ptr<MainThreadHandle> main_thread,
    const std::string& path,
    std::shared_ptr<ExclusiveAccess<HostPort>> host_port,
    const InspectPublishUid& inspect_publish_uid) {
  auto io = std::unique_ptr<InspectorIo>(
      new InspectorIo(main_thread,
                      path,
                      host_port,
                      inspect_publish_uid));
  if (io->request_queue_->Expired()) {  // Thread is not running
    return nullptr;
  }
  return io;
}",1,1,inspector_io.cc,node.inspector.InspectorIo.Start,,false,238,252,Start,,,5,"unique_ptr<InspectorIo> node.inspector.InspectorIo.Start (ANY,ANY,ANY,InspectPublishUid)"
92623,METHOD,inspector_io.cc:<global>,TYPE_DECL,"InspectorIo::InspectorIo(std::shared_ptr<MainThreadHandle> main_thread,
                         const std::string& path,
                         std::shared_ptr<ExclusiveAccess<HostPort>> host_port,
                         const InspectPublishUid& inspect_publish_uid)
    : main_thread_(main_thread),
      host_port_(host_port),
      inspect_publish_uid_(inspect_publish_uid),
      thread_(),
      script_name_(path),
      id_(GenerateID()) {
  Mutex::ScopedLock scoped_lock(thread_start_lock_);
  CHECK_EQ(uv_thread_create(&thread_, InspectorIo::ThreadMain, this), 0);
  thread_start_condition_.Wait(scoped_lock);
}",1,1,inspector_io.cc,node.inspector.InspectorIo.InspectorIo,,false,254,267,InspectorIo,,,6,"ANY node.inspector.InspectorIo.InspectorIo (ANY,ANY,ANY,InspectPublishUid)"
92648,METHOD,inspector_io.cc:<global>,TYPE_DECL,"InspectorIo::~InspectorIo() {
  request_queue_->Post(0, TransportAction::kKill, nullptr);
  int err = uv_thread_join(&thread_);
  CHECK_EQ(err, 0);
}",1,1,inspector_io.cc,node.inspector.InspectorIo.~InspectorIo,,false,269,273,~InspectorIo,,,7,ANY node.inspector.InspectorIo.~InspectorIo ()
92670,METHOD,inspector_io.cc:<global>,TYPE_DECL,"void InspectorIo::StopAcceptingNewConnections() {
  request_queue_->Post(0, TransportAction::kStop, nullptr);
}",1,1,inspector_io.cc,node.inspector.InspectorIo.StopAcceptingNewConnections,,false,275,277,StopAcceptingNewConnections,,,8,void node.inspector.InspectorIo.StopAcceptingNewConnections ()
92683,METHOD,inspector_io.cc:<global>,TYPE_DECL,"void InspectorIo::ThreadMain(void* io) {
  static_cast<InspectorIo*>(io)->ThreadMain();
}",1,1,inspector_io.cc,node.inspector.InspectorIo.ThreadMain,,false,280,282,ThreadMain,,,9,void node.inspector.InspectorIo.ThreadMain (void*)
92694,METHOD,inspector_io.cc:<global>,TYPE_DECL,"void InspectorIo::ThreadMain() {
  uv_loop_t loop;
  loop.data = nullptr;
  int err = uv_loop_init(&loop);
  CHECK_EQ(err, 0);
  std::shared_ptr<RequestQueueData> queue(new RequestQueueData(&loop),
                                          RequestQueueData::CloseAndFree);
  std::string script_path = ScriptPath(&loop, script_name_);
  std::unique_ptr<InspectorIoDelegate> delegate(
      new InspectorIoDelegate(queue, main_thread_, id_,
                              script_path, script_name_));
  std::string host;
  int port;
  {
    ExclusiveAccess<HostPort>::Scoped host_port(host_port_);
    host = host_port->host();
    port = host_port->port();
  }
  InspectorSocketServer server(std::move(delegate),
                               &loop,
                               std::move(host),
                               port,
                               inspect_publish_uid_);
  request_queue_ = queue->handle();
  // Its lifetime is now that of the server delegate
  queue.reset();
  {...",1,1,inspector_io.cc,node.inspector.InspectorIo.ThreadMain,,false,284,320,ThreadMain,,,10,void node.inspector.InspectorIo.ThreadMain ()
92825,METHOD,inspector_io.cc:<global>,TYPE_DECL,"std::string InspectorIo::GetWsUrl() const {
  ExclusiveAccess<HostPort>::Scoped host_port(host_port_);
  return FormatWsAddress(host_port->host(), host_port->port(), id_, true);
}",1,1,inspector_io.cc,node.inspector.InspectorIo.GetWsUrl,,false,322,325,GetWsUrl,,,11,string node.inspector.InspectorIo.GetWsUrl ()
92844,METHOD,inspector_io.cc:<global>,TYPE_DECL,"InspectorIoDelegate::InspectorIoDelegate(
    std::shared_ptr<RequestQueueData> queue,
    std::shared_ptr<MainThreadHandle> main_thread,
    const std::string& target_id,
    const std::string& script_path,
    const std::string& script_name)
    : request_queue_(queue), main_thread_(main_thread),
      script_name_(script_name), script_path_(script_path),
      target_id_(target_id) {}",1,30,inspector_io.cc,node.inspector.InspectorIoDelegate.InspectorIoDelegate,,false,327,335,InspectorIoDelegate,,,12,"ANY node.inspector.InspectorIoDelegate.InspectorIoDelegate (ANY,ANY,ANY,ANY,ANY)"
92853,METHOD,inspector_io.cc:<global>,TYPE_DECL,"void InspectorIoDelegate::StartSession(int session_id,
                                       const std::string& target_id) {
  auto session = main_thread_->Connect(
      std::unique_ptr<InspectorSessionDelegate>(
          new IoSessionDelegate(request_queue_->handle(), session_id)), true);
  if (session) {
    sessions_[session_id] = std::move(session);
    fprintf(stderr, ""Debugger attached.\n"");
  }
}",1,1,inspector_io.cc,node.inspector.InspectorIoDelegate.StartSession,,false,337,346,StartSession,,,13,"void node.inspector.InspectorIoDelegate.StartSession (int,ANY)"
92895,METHOD,inspector_io.cc:<global>,TYPE_DECL,"void InspectorIoDelegate::MessageReceived(int session_id,
                                          const std::string& message) {
  auto session = sessions_.find(session_id);
  if (session != sessions_.end())
    session->second->Dispatch(Utf8ToStringView(message)->string());
}",1,1,inspector_io.cc,node.inspector.InspectorIoDelegate.MessageReceived,,false,348,353,MessageReceived,,,14,"void node.inspector.InspectorIoDelegate.MessageReceived (int,ANY)"
92928,METHOD,inspector_io.cc:<global>,TYPE_DECL,"void InspectorIoDelegate::EndSession(int session_id) {
  sessions_.erase(session_id);
}",1,1,inspector_io.cc,node.inspector.InspectorIoDelegate.EndSession,,false,355,357,EndSession,,,15,void node.inspector.InspectorIoDelegate.EndSession (int)
92938,METHOD,inspector_io.cc:<global>,TYPE_DECL,"std::vector<std::string> InspectorIoDelegate::GetTargetIds() {
  return { target_id_ };
}",1,1,inspector_io.cc,node.inspector.InspectorIoDelegate.GetTargetIds,,false,359,361,GetTargetIds,,,16,vector<std::string> node.inspector.InspectorIoDelegate.GetTargetIds ()
92943,METHOD,inspector_io.cc:<global>,TYPE_DECL,"std::string InspectorIoDelegate::GetTargetTitle(const std::string& id) {
  return script_name_.empty() ? GetHumanReadableProcessName() : script_name_;
}",1,1,inspector_io.cc,node.inspector.InspectorIoDelegate.GetTargetTitle,,false,363,365,GetTargetTitle,,,17,string node.inspector.InspectorIoDelegate.GetTargetTitle (ANY)
92956,METHOD,inspector_io.cc:<global>,TYPE_DECL,"std::string InspectorIoDelegate::GetTargetUrl(const std::string& id) {
  return ""file://"" + script_path_;
}",1,1,inspector_io.cc,node.inspector.InspectorIoDelegate.GetTargetUrl,,false,367,369,GetTargetUrl,,,18,string node.inspector.InspectorIoDelegate.GetTargetUrl (ANY)
92965,METHOD,inspector_io.cc:<global>,TYPE_DECL,"void RequestQueueData::CloseAndFree(RequestQueueData* queue) {
  queue->handle_->Reset();
  queue->handle_.reset();
  uv_close(reinterpret_cast<uv_handle_t*>(&queue->async_),
           [](uv_handle_t* handle) {
    uv_async_t* async = reinterpret_cast<uv_async_t*>(handle);
    RequestQueueData* wrapper =
        node::ContainerOf(&RequestQueueData::async_, async);
    delete wrapper;
  });
}",1,1,inspector_io.cc,node.inspector.RequestQueueData.CloseAndFree,,false,372,382,CloseAndFree,,,19,void node.inspector.RequestQueueData.CloseAndFree (RequestQueueData*)
93003,METHOD,inspector_io.hpp:<global>,TYPE_DECL,<global>,1,62,inspector_io.hpp,inspector_io.hpp:<global>,,false,1,78,<global>,,,1,
93028,METHOD,inspector_js_api.cc:<global>,TYPE_DECL,<global>,1,32,async_wrap-inl.hpp,inspector_js_api.cc:<global>,,false,1,407,<global>,,,1,
93033,METHOD,inspector_js_api.cc:<global>,TYPE_DECL,"std::unique_ptr<StringBuffer> ToProtocolString(Isolate* isolate,
                                               Local<Value> value) {
  TwoByteValue buffer(isolate, value);
  return StringBuffer::create(StringView(*buffer, buffer.length()));
}",1,1,inspector_js_api.cc,node.inspector.anonymous_namespace_17.ToProtocolString,,false,35,39,ToProtocolString,,,1,"unique_ptr<StringBuffer> node.inspector.anonymous_namespace_17.ToProtocolString (Isolate*,Local<Value>)"
93056,METHOD,node.inspector.anonymous_namespace_18.LocalConnection,TYPE_DECL,"static std::unique_ptr<InspectorSession> Connect(
      Agent* inspector, std::unique_ptr<InspectorSessionDelegate> delegate) {
    return inspector->Connect(std::move(delegate), false);
  }",3,3,inspector_js_api.cc,node.inspector.anonymous_namespace_19.LocalConnection.Connect,,false,42,45,Connect,,,1,"unique_ptr<InspectorSession> node.inspector.anonymous_namespace_19.LocalConnection.Connect (Agent*,ANY)"
93073,METHOD,node.inspector.anonymous_namespace_18.LocalConnection,TYPE_DECL,"static Local<String> GetClassName(Environment* env) {
    return FIXED_ONE_BYTE_STRING(env->isolate(), ""Connection"");
  }",3,3,inspector_js_api.cc,node.inspector.anonymous_namespace_20.LocalConnection.GetClassName,,false,47,49,GetClassName,,,2,Local<String> node.inspector.anonymous_namespace_20.LocalConnection.GetClassName (Environment*)
93086,METHOD,node.inspector.anonymous_namespace_21.MainThreadConnection,TYPE_DECL,"static std::unique_ptr<InspectorSession> Connect(
      Agent* inspector, std::unique_ptr<InspectorSessionDelegate> delegate) {
    return inspector->ConnectToMainThread(std::move(delegate), true);
  }",3,3,inspector_js_api.cc,node.inspector.anonymous_namespace_22.MainThreadConnection.Connect,,false,53,56,Connect,,,1,"unique_ptr<InspectorSession> node.inspector.anonymous_namespace_22.MainThreadConnection.Connect (Agent*,ANY)"
93103,METHOD,node.inspector.anonymous_namespace_21.MainThreadConnection,TYPE_DECL,"static Local<String> GetClassName(Environment* env) {
    return FIXED_ONE_BYTE_STRING(env->isolate(), ""MainThreadConnection"");
  }",3,3,inspector_js_api.cc,node.inspector.anonymous_namespace_23.MainThreadConnection.GetClassName,,false,58,60,GetClassName,,,2,Local<String> node.inspector.anonymous_namespace_23.MainThreadConnection.GetClassName (Environment*)
93117,METHOD,node.inspector.anonymous_namespace_25.JSBindingsConnection.JSBindingsSessionDelegate,TYPE_DECL,"JSBindingsSessionDelegate(Environment* env,
                              JSBindingsConnection* connection)
                              : env_(env),
                                connection_(connection) {
    }",5,5,inspector_js_api.cc,node.inspector.anonymous_namespace_26.JSBindingsConnection.JSBindingsSessionDelegate.JSBindingsSessionDelegate,,false,68,72,JSBindingsSessionDelegate,,,1,"ANY node.inspector.anonymous_namespace_26.JSBindingsConnection.JSBindingsSessionDelegate.JSBindingsSessionDelegate (Environment*,JSBindingsConnection*)"
93123,METHOD,node.inspector.anonymous_namespace_25.JSBindingsConnection.JSBindingsSessionDelegate,TYPE_DECL,"void SendMessageToFrontend(const v8_inspector::StringView& message)
        override {
      Isolate* isolate = env_->isolate();
      HandleScope handle_scope(isolate);
      Context::Scope context_scope(env_->context());
      Local<Value> argument;
      if (!String::NewFromTwoByte(isolate, message.characters16(),
                                  NewStringType::kNormal,
                                  message.length()).ToLocal(&argument)) return;
      connection_->OnMessage(argument);
    }",5,5,inspector_js_api.cc,node.inspector.anonymous_namespace_27.JSBindingsConnection.JSBindingsSessionDelegate.SendMessageToFrontend,,false,74,84,SendMessageToFrontend,,,2,void node.inspector.anonymous_namespace_27.JSBindingsConnection.JSBindingsSessionDelegate.SendMessageToFrontend (ANY)
93181,METHOD,node.inspector.anonymous_namespace_24.JSBindingsConnection,TYPE_DECL,"JSBindingsConnection(Environment* env,
                       Local<Object> wrap,
                       Local<Function> callback)
                       : AsyncWrap(env, wrap, PROVIDER_INSPECTORJSBINDING),
                         callback_(env->isolate(), callback) {
    Agent* inspector = env->inspector_agent();
    session_ = ConnectionType::Connect(
        inspector, std::make_unique<JSBindingsSessionDelegate>(env, this));
  }",3,3,inspector_js_api.cc,node.inspector.anonymous_namespace_28.JSBindingsConnection.JSBindingsConnection,,false,91,99,JSBindingsConnection,,,2,"ANY node.inspector.anonymous_namespace_28.JSBindingsConnection.JSBindingsConnection (Environment*,Local<Object>,Local<Function>)"
93212,METHOD,node.inspector.anonymous_namespace_24.JSBindingsConnection,TYPE_DECL,"void OnMessage(Local<Value> value) {
    MakeCallback(callback_.Get(env()->isolate()), 1, &value);
  }",3,3,inspector_js_api.cc,node.inspector.anonymous_namespace_29.JSBindingsConnection.OnMessage,,false,101,103,OnMessage,,,3,void node.inspector.anonymous_namespace_29.JSBindingsConnection.OnMessage (Local<Value>)
93229,METHOD,node.inspector.anonymous_namespace_24.JSBindingsConnection,TYPE_DECL,"static void Bind(Environment* env, Local<Object> target) {
    Isolate* isolate = env->isolate();
    Local<FunctionTemplate> tmpl =
        NewFunctionTemplate(isolate, JSBindingsConnection::New);
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        JSBindingsConnection::kInternalFieldCount);
    tmpl->Inherit(AsyncWrap::GetConstructorTemplate(env));
    SetProtoMethod(isolate, tmpl, ""dispatch"", JSBindingsConnection::Dispatch);
    SetProtoMethod(
        isolate, tmpl, ""disconnect"", JSBindingsConnection::Disconnect);
    SetConstructorFunction(
        env->context(), target, ConnectionType::GetClassName(env), tmpl);
  }",3,3,inspector_js_api.cc,node.inspector.anonymous_namespace_30.JSBindingsConnection.Bind,,false,105,117,Bind,,,4,"void node.inspector.anonymous_namespace_30.JSBindingsConnection.Bind (Environment*,Local<Object>)"
93298,METHOD,node.inspector.anonymous_namespace_24.JSBindingsConnection,TYPE_DECL,"static void New(const FunctionCallbackInfo<Value>& info) {
    Environment* env = Environment::GetCurrent(info);
    CHECK(info[0]->IsFunction());
    Local<Function> callback = info[0].As<Function>();
    new JSBindingsConnection(env, info.This(), callback);
  }",3,3,inspector_js_api.cc,node.inspector.anonymous_namespace_31.JSBindingsConnection.New,,false,119,124,New,,,5,void node.inspector.anonymous_namespace_31.JSBindingsConnection.New (FunctionCallbackInfo<Value>)
93338,METHOD,node.inspector.anonymous_namespace_24.JSBindingsConnection,TYPE_DECL,"void Disconnect() {
    BaseObjectPtr<JSBindingsConnection> strong_ref{this};
    session_.reset();
    Detach();
  }",3,3,inspector_js_api.cc,node.inspector.anonymous_namespace_32.JSBindingsConnection.Disconnect,,false,127,131,Disconnect,,,6,void node.inspector.anonymous_namespace_32.JSBindingsConnection.Disconnect ()
93354,METHOD,node.inspector.anonymous_namespace_24.JSBindingsConnection,TYPE_DECL,"static void Disconnect(const FunctionCallbackInfo<Value>& info) {
    JSBindingsConnection* session;
    ASSIGN_OR_RETURN_UNWRAP(&session, info.Holder());
    session->Disconnect();
  }",3,3,inspector_js_api.cc,node.inspector.anonymous_namespace_33.JSBindingsConnection.Disconnect,,false,133,137,Disconnect,,,7,void node.inspector.anonymous_namespace_33.JSBindingsConnection.Disconnect (FunctionCallbackInfo<Value>)
93371,METHOD,node.inspector.anonymous_namespace_24.JSBindingsConnection,TYPE_DECL,"static void Dispatch(const FunctionCallbackInfo<Value>& info) {
    Environment* env = Environment::GetCurrent(info);
    JSBindingsConnection* session;
    ASSIGN_OR_RETURN_UNWRAP(&session, info.Holder());
    CHECK(info[0]->IsString());

    if (session->session_) {
      session->session_->Dispatch(
          ToProtocolString(env->isolate(), info[0])->string());
    }
  }",3,3,inspector_js_api.cc,node.inspector.anonymous_namespace_34.JSBindingsConnection.Dispatch,,false,139,149,Dispatch,,,8,void node.inspector.anonymous_namespace_34.JSBindingsConnection.Dispatch (FunctionCallbackInfo<Value>)
93421,METHOD,node.inspector.anonymous_namespace_24.JSBindingsConnection,TYPE_DECL,"void MemoryInfo(MemoryTracker* tracker) const override {
    tracker->TrackField(""callback"", callback_);
    tracker->TrackFieldWithSize(
        ""session"", sizeof(*session_), ""InspectorSession"");
  }",3,3,inspector_js_api.cc,node.inspector.anonymous_namespace_35.JSBindingsConnection.MemoryInfo,,false,151,155,MemoryInfo,,,9,void node.inspector.anonymous_namespace_35.JSBindingsConnection.MemoryInfo (MemoryTracker*)
93445,METHOD,node.inspector.anonymous_namespace_24.JSBindingsConnection,TYPE_DECL,"bool IsNotIndicativeOfMemoryLeakAtExit() const override {
    return true;  // Binding connections emit events on their own.
  }",3,3,inspector_js_api.cc,node.inspector.anonymous_namespace_36.JSBindingsConnection.IsNotIndicativeOfMemoryLeakAtExit,,false,160,162,IsNotIndicativeOfMemoryLeakAtExit,,,14,bool node.inspector.anonymous_namespace_36.JSBindingsConnection.IsNotIndicativeOfMemoryLeakAtExit ()
93453,METHOD,inspector_js_api.cc:<global>,TYPE_DECL,"static bool InspectorEnabled(Environment* env) {
  Agent* agent = env->inspector_agent();
  return agent->IsActive();
}",1,1,inspector_js_api.cc,node.inspector.anonymous_namespace_37.InspectorEnabled,,false,169,172,InspectorEnabled,,,5,bool node.inspector.anonymous_namespace_37.InspectorEnabled (Environment*)
93470,METHOD,inspector_js_api.cc:<global>,TYPE_DECL,"void SetConsoleExtensionInstaller(const FunctionCallbackInfo<Value>& info) {
  Realm* realm = Realm::GetCurrent(info);

  CHECK_EQ(info.Length(), 1);
  CHECK(info[0]->IsFunction());

  realm->set_inspector_console_extension_installer(info[0].As<Function>());
}",1,1,inspector_js_api.cc,node.inspector.anonymous_namespace_38.SetConsoleExtensionInstaller,,false,174,181,SetConsoleExtensionInstaller,,,6,void node.inspector.anonymous_namespace_38.SetConsoleExtensionInstaller (FunctionCallbackInfo<Value>)
93506,METHOD,inspector_js_api.cc:<global>,TYPE_DECL,"void CallAndPauseOnStart(const FunctionCallbackInfo<v8::Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK_GT(args.Length(), 1);
  CHECK(args[0]->IsFunction());
  SlicedArguments call_args(args, /* start */ 2);
  env->inspector_agent()->PauseOnNextJavascriptStatement(""Break on start"");
  v8::MaybeLocal<v8::Value> retval =
      args[0].As<v8::Function>()->Call(env->context(), args[1],
                                       call_args.length(), call_args.out());
  if (!retval.IsEmpty()) {
    args.GetReturnValue().Set(retval.ToLocalChecked());
  }
}",1,1,inspector_js_api.cc,node.inspector.anonymous_namespace_39.CallAndPauseOnStart,,false,183,195,CallAndPauseOnStart,,,7,void node.inspector.anonymous_namespace_39.CallAndPauseOnStart (ANY)
93596,METHOD,inspector_js_api.cc:<global>,TYPE_DECL,"void InspectorConsoleCall(const FunctionCallbackInfo<Value>& info) {
  Environment* env = Environment::GetCurrent(info);
  Isolate* isolate = env->isolate();
  Local<Context> context = isolate->GetCurrentContext();
  CHECK_GE(info.Length(), 2);
  SlicedArguments call_args(info, /* start */ 2);
  if (InspectorEnabled(env)) {
    Local<Value> inspector_method = info[0];
    CHECK(inspector_method->IsFunction());
    if (!env->is_in_inspector_console_call()) {
      env->set_is_in_inspector_console_call(true);
      MaybeLocal<Value> ret =
          inspector_method.As<Function>()->Call(context,
                                                info.Holder(),
                                                call_args.length(),
                                                call_args.out());
      env->set_is_in_inspector_console_call(false);
      if (ret.IsEmpty())
        return;
    }
  }

  Local<Value> node_method = info[1];
  CHECK(node_method->IsFunction());
  USE(node_method.As<F...",1,1,inspector_js_api.cc,node.inspector.anonymous_namespace_40.InspectorConsoleCall,,false,197,225,InspectorConsoleCall,,,8,void node.inspector.anonymous_namespace_40.InspectorConsoleCall (FunctionCallbackInfo<Value>)
93739,METHOD,inspector_js_api.cc:<global>,TYPE_DECL,"static void* GetAsyncTask(int64_t asyncId) {
  // The inspector assumes that when other clients use its asyncTask* API,
  // they use real pointers, or at least something aligned like real pointer.
  // In general it means that our task_id should always be even.
  //
  // On 32bit platforms, the 64bit asyncId would get truncated when converted
  // to a 32bit pointer. However, the javascript part will never enable
  // the async_hook on 32bit platforms, therefore the truncation will never
  // happen in practice.
  return reinterpret_cast<void*>(asyncId << 1);
}",1,1,inspector_js_api.cc,node.inspector.anonymous_namespace_42.GetAsyncTask,,false,227,237,GetAsyncTask,,,9,void* node.inspector.anonymous_namespace_42.GetAsyncTask (int64_t)
93750,METHOD,inspector_js_api.cc:<global>,TYPE_DECL,"static void InvokeAsyncTaskFnWithId(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsNumber());
  int64_t task_id = args[0]->IntegerValue(env->context()).FromJust();
  (env->inspector_agent()->*asyncTaskFn)(GetAsyncTask(task_id));
}",1,1,inspector_js_api.cc,node.inspector.anonymous_namespace_43.InvokeAsyncTaskFnWithId,,false,240,245,InvokeAsyncTaskFnWithId,,,10,void node.inspector.anonymous_namespace_43.InvokeAsyncTaskFnWithId<void(Agent::*)(void*)> (FunctionCallbackInfo<Value>)
93795,METHOD,inspector_js_api.cc:<global>,TYPE_DECL,"static void AsyncTaskScheduledWrapper(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsString());
  Local<String> task_name = args[0].As<String>();
  String::Value task_name_value(args.GetIsolate(), task_name);
  StringView task_name_view(*task_name_value, task_name_value.length());

  CHECK(args[1]->IsNumber());
  int64_t task_id = args[1]->IntegerValue(env->context()).FromJust();
  void* task = GetAsyncTask(task_id);

  CHECK(args[2]->IsBoolean());
  bool recurring = args[2]->BooleanValue(args.GetIsolate());

  env->inspector_agent()->AsyncTaskScheduled(task_name_view, task, recurring);
}",1,1,inspector_js_api.cc,node.inspector.anonymous_namespace_45.AsyncTaskScheduledWrapper,,false,247,263,AsyncTaskScheduledWrapper,,,11,void node.inspector.anonymous_namespace_45.AsyncTaskScheduledWrapper (FunctionCallbackInfo<Value>)
93900,METHOD,inspector_js_api.cc:<global>,TYPE_DECL,"static void RegisterAsyncHookWrapper(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsFunction());
  Local<Function> enable_function = args[0].As<Function>();
  CHECK(args[1]->IsFunction());
  Local<Function> disable_function = args[1].As<Function>();
  env->inspector_agent()->RegisterAsyncHook(env->isolate(),
    enable_function, disable_function);
}",1,1,inspector_js_api.cc,node.inspector.anonymous_namespace_47.RegisterAsyncHookWrapper,,false,265,274,RegisterAsyncHookWrapper,,,12,void node.inspector.anonymous_namespace_47.RegisterAsyncHookWrapper (FunctionCallbackInfo<Value>)
93964,METHOD,inspector_js_api.cc:<global>,TYPE_DECL,"void IsEnabled(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  args.GetReturnValue().Set(env->inspector_agent()->IsListening());
}",1,1,inspector_js_api.cc,node.inspector.anonymous_namespace_48.IsEnabled,,false,276,279,IsEnabled,,,13,void node.inspector.anonymous_namespace_48.IsEnabled (FunctionCallbackInfo<Value>)
93991,METHOD,inspector_js_api.cc:<global>,TYPE_DECL,"void Open(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Agent* agent = env->inspector_agent();

  if (args.Length() > 0 && args[0]->IsUint32()) {
    uint32_t port = args[0].As<Uint32>()->Value();
    CHECK_LE(port, std::numeric_limits<uint16_t>::max());
    ExclusiveAccess<HostPort>::Scoped host_port(agent->host_port());
    host_port->set_port(static_cast<int>(port));
  }

  if (args.Length() > 1 && args[1]->IsString()) {
    Utf8Value host(env->isolate(), args[1].As<String>());
    ExclusiveAccess<HostPort>::Scoped host_port(agent->host_port());
    host_port->set_host(*host);
  }

  agent->StartIoThread();
}",1,1,inspector_js_api.cc,node.inspector.anonymous_namespace_49.Open,,false,281,299,Open,,,14,void node.inspector.anonymous_namespace_49.Open (FunctionCallbackInfo<Value>)
94106,METHOD,inspector_js_api.cc:<global>,TYPE_DECL,"void WaitForDebugger(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Agent* agent = env->inspector_agent();
  if (agent->IsActive())
    agent->WaitForConnect();
  args.GetReturnValue().Set(agent->IsActive());
}",1,1,inspector_js_api.cc,node.inspector.anonymous_namespace_50.WaitForDebugger,,false,301,307,WaitForDebugger,,,15,void node.inspector.anonymous_namespace_50.WaitForDebugger (FunctionCallbackInfo<Value>)
94147,METHOD,inspector_js_api.cc:<global>,TYPE_DECL,"void Url(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  std::string url = env->inspector_agent()->GetWsUrl();
  if (url.empty()) {
    return;
  }
  args.GetReturnValue().Set(OneByteString(env->isolate(), url.c_str()));
}",1,1,inspector_js_api.cc,node.inspector.anonymous_namespace_51.Url,,false,309,316,Url,,,16,void node.inspector.anonymous_namespace_51.Url (FunctionCallbackInfo<Value>)
94193,METHOD,inspector_js_api.cc:<global>,TYPE_DECL,"void Initialize(Local<Object> target, Local<Value> unused,
                Local<Context> context, void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  v8::Local<v8::Function> consoleCallFunc =
      NewFunctionTemplate(isolate,
                          InspectorConsoleCall,
                          v8::Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasSideEffect)
          ->GetFunction(context)
          .ToLocalChecked();
  auto name_string = FIXED_ONE_BYTE_STRING(isolate, ""consoleCall"");
  target->Set(context, name_string, consoleCallFunc).Check();
  consoleCallFunc->SetName(name_string);

  SetMethod(context,
            target,
            ""setConsoleExtensionInstaller"",
            SetConsoleExtensionInstaller);
  SetMethod(context, target, ""callAndPauseOnStart"", CallAndPauseOnStart);
  SetMethod(context, target, ""open"", Open);
  SetMeth...",1,1,inspector_js_api.cc,node.inspector.anonymous_namespace_52.Initialize,,false,318,374,Initialize,,,17,"void node.inspector.anonymous_namespace_52.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
94375,METHOD,inspector_js_api.cc:<global>,TYPE_DECL,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(InspectorConsoleCall);
  registry->Register(SetConsoleExtensionInstaller);
  registry->Register(CallAndPauseOnStart);
  registry->Register(Open);
  registry->Register(Url);
  registry->Register(WaitForDebugger);

  registry->Register(AsyncTaskScheduledWrapper);
  registry->Register(InvokeAsyncTaskFnWithId<&Agent::AsyncTaskCanceled>);
  registry->Register(InvokeAsyncTaskFnWithId<&Agent::AsyncTaskStarted>);
  registry->Register(InvokeAsyncTaskFnWithId<&Agent::AsyncTaskFinished>);

  registry->Register(RegisterAsyncHookWrapper);
  registry->Register(IsEnabled);

  registry->Register(JSBindingsConnection<LocalConnection>::New);
  registry->Register(JSBindingsConnection<LocalConnection>::Dispatch);
  registry->Register(JSBindingsConnection<LocalConnection>::Disconnect);
  registry->Register(JSBindingsConnection<MainThreadConnection>::New);
  registry->Register(JSBindingsConnection<MainThreadConnec...",1,1,inspector_js_api.cc,node.inspector.RegisterExternalReferences,,false,378,400,RegisterExternalReferences,,,2,void node.inspector.RegisterExternalReferences (ExternalReferenceRegistry*)
94484,METHOD,inspector_profiler.cc:<global>,TYPE_DECL,"[](void* env) {
    EndStartedProfilers(static_cast<Environment*>(env));
  }",15,3,inspector_profiler.cc,node.profiler.StartProfilers.<lambda>0,,false,417,419,<lambda>0,,,1,ANY node.profiler.StartProfilers.<lambda>0 (void*)
94523,METHOD,inspector_profiler.cc:<global>,TYPE_DECL,<global>,1,36,inspector_profiler.hpp,inspector_profiler.cc:<global>,,false,1,530,<global>,,,1,
94527,METHOD,inspector_profiler.cc:<global>,TYPE_DECL,"V8ProfilerConnection::V8ProfilerConnection(Environment* env)
    : session_(env->inspector_agent()->Connect(
          std::make_unique<V8ProfilerConnection::V8ProfilerSessionDelegate>(
              this),
          false)),
      env_(env) {}",1,18,inspector_profiler.cc,node.profiler.V8ProfilerConnection.V8ProfilerConnection,,false,34,39,V8ProfilerConnection,,,1,ANY node.profiler.V8ProfilerConnection.V8ProfilerConnection (Environment*)
94532,METHOD,inspector_profiler.cc:<global>,TYPE_DECL,"uint32_t V8ProfilerConnection::DispatchMessage(const char* method,
                                               const char* params,
                                               bool is_profile_request) {
  std::stringstream ss;
  uint32_t id = next_id();
  ss << R""({ ""id"": )"" << id;
  DCHECK(method != nullptr);
  ss << R""(, ""method"": "")"" << method << '""';
  if (params != nullptr) {
    ss << R""(, ""params"": )"" << params;
  }
  ss << "" }"";
  std::string message = ss.str();
  const uint8_t* message_data =
      reinterpret_cast<const uint8_t*>(message.c_str());
  // Save the id of the profile request to identify its response.
  if (is_profile_request) {
    profile_ids_.insert(id);
  }
  Debug(env(),
        DebugCategory::INSPECTOR_PROFILER,
        ""Dispatching message %s\n"",
        message.c_str());
  session_->Dispatch(StringView(message_data, message.length()));
  return id;
}",1,1,inspector_profiler.cc,node.profiler.V8ProfilerConnection.DispatchMessage,,false,41,66,DispatchMessage,,,2,"uint32_t node.profiler.V8ProfilerConnection.DispatchMessage (char*,char*,bool)"
94619,METHOD,inspector_profiler.cc:<global>,TYPE_DECL,"static void WriteResult(Environment* env,
                        const char* path,
                        Local<String> result) {
  int ret = WriteFileSync(env->isolate(), path, result);
  if (ret != 0) {
    char err_buf[128];
    uv_err_name_r(ret, err_buf, sizeof(err_buf));
    fprintf(stderr, ""%s: Failed to write file %s\n"", err_buf, path);
    return;
  }
  Debug(env, DebugCategory::INSPECTOR_PROFILER, ""Written result to %s\n"", path);
}",1,1,inspector_profiler.cc,node.profiler.WriteResult,,false,68,79,WriteResult,,,3,"void node.profiler.WriteResult (Environment*,char*,Local<String>)"
94660,METHOD,inspector_profiler.cc:<global>,TYPE_DECL,"void V8ProfilerConnection::V8ProfilerSessionDelegate::SendMessageToFrontend(
    const v8_inspector::StringView& message) {
  Environment* env = connection_->env();
  Isolate* isolate = env->isolate();
  HandleScope handle_scope(isolate);
  Local<Context> context = env->context();
  Context::Scope context_scope(context);

  const char* type = connection_->type();
  // Convert StringView to a Local<String>.
  Local<String> message_str;
  if (!String::NewFromTwoByte(isolate,
                              message.characters16(),
                              NewStringType::kNormal,
                              message.length())
           .ToLocal(&message_str)) {
    fprintf(
        stderr, ""Failed to convert %s profile message to V8 string\n"", type);
    return;
  }

  Debug(env,
        DebugCategory::INSPECTOR_PROFILER,
        ""Receive %s profile message\n"",
        type);

  Local<Value> parsed;
  if (!v8::JSON::Parse(context, message_str).ToLocal(&parsed) ||
      !parsed->IsO...",1,1,inspector_profiler.cc,node.profiler.V8ProfilerConnection.V8ProfilerSessionDelegate.SendMessageToFrontend,,false,81,153,SendMessageToFrontend,,,4,void node.profiler.V8ProfilerConnection.V8ProfilerSessionDelegate.SendMessageToFrontend (ANY)
94907,METHOD,inspector_profiler.cc:<global>,TYPE_DECL,"static bool EnsureDirectory(const std::string& directory, const char* type) {
  fs::FSReqWrapSync req_wrap_sync;
  int ret = fs::MKDirpSync(nullptr, &req_wrap_sync.req, directory, 0777,
                           nullptr);
  if (ret < 0 && ret != UV_EEXIST) {
    char err_buf[128];
    uv_err_name_r(ret, err_buf, sizeof(err_buf));
    fprintf(stderr,
            ""%s: Failed to create %s profile directory %s\n"",
            err_buf,
            type,
            directory.c_str());
    return false;
  }
  return true;
}",1,1,inspector_profiler.cc,node.profiler.EnsureDirectory,,false,155,170,EnsureDirectory,,,5,"bool node.profiler.EnsureDirectory (ANY,char*)"
94957,METHOD,inspector_profiler.cc:<global>,TYPE_DECL,"std::string V8CoverageConnection::GetFilename() const {
  uint64_t timestamp =
      static_cast<uint64_t>(GetCurrentTimeInMicroseconds() / 1000);
  return SPrintF(""coverage-%s-%s-%s.json"",
      uv_os_getpid(),
      timestamp,
      env()->thread_id());
}",1,1,inspector_profiler.cc,node.profiler.V8CoverageConnection.GetFilename,,false,172,179,GetFilename,,,6,string node.profiler.V8CoverageConnection.GetFilename ()
94978,METHOD,inspector_profiler.cc:<global>,TYPE_DECL,"void V8ProfilerConnection::WriteProfile(Local<Object> result) {
  Local<Context> context = env_->context();

  // Generate the profile output from the subclass.
  Local<Object> profile;
  if (!GetProfile(result).ToLocal(&profile)) {
    return;
  }

  Local<String> result_s;
  if (!v8::JSON::Stringify(context, profile).ToLocal(&result_s)) {
    fprintf(stderr, ""Failed to stringify %s profile result\n"", type());
    return;
  }

  // Create the directory if necessary.
  std::string directory = GetDirectory();
  DCHECK(!directory.empty());
  if (!EnsureDirectory(directory, type())) {
    return;
  }

  std::string filename = GetFilename();
  DCHECK(!filename.empty());
  std::string path = directory + kPathSeparator + filename;

  WriteResult(env_, path.c_str(), result_s);
}",1,1,inspector_profiler.cc,node.profiler.V8ProfilerConnection.WriteProfile,,false,181,208,WriteProfile,,,7,void node.profiler.V8ProfilerConnection.WriteProfile (Local<Object>)
95077,METHOD,inspector_profiler.cc:<global>,TYPE_DECL,"void V8CoverageConnection::WriteProfile(Local<Object> result) {
  Isolate* isolate = env_->isolate();
  Local<Context> context = env_->context();
  HandleScope handle_scope(isolate);
  Context::Scope context_scope(context);

  // This is only set up during pre-execution (when the environment variables
  // becomes available in the JS land). If it's empty, we don't have coverage
  // directory path (which is resolved in JS land at the moment) either, so
  // the best we could to is to just discard the profile and do nothing.
  // This should only happen in half-baked Environments created using the
  // embedder API.
  if (env_->source_map_cache_getter().IsEmpty()) {
    return;
  }

  // Generate the profile output from the subclass.
  Local<Object> profile;
  if (!GetProfile(result).ToLocal(&profile)) {
    return;
  }

  // append source-map cache information to coverage object:
  Local<Value> source_map_cache_v;
  {
    TryCatchScope try_catch(env());
    {
      Isolate::AllowJav...",1,1,inspector_profiler.cc,node.profiler.V8CoverageConnection.WriteProfile,,false,210,273,WriteProfile,,,8,void node.profiler.V8CoverageConnection.WriteProfile (Local<Object>)
95275,METHOD,inspector_profiler.cc:<global>,TYPE_DECL,"MaybeLocal<Object> V8CoverageConnection::GetProfile(Local<Object> result) {
  return result;
}",1,1,inspector_profiler.cc,node.profiler.V8CoverageConnection.GetProfile,,false,275,277,GetProfile,,,9,MaybeLocal<Object> node.profiler.V8CoverageConnection.GetProfile (Local<Object>)
95282,METHOD,inspector_profiler.cc:<global>,TYPE_DECL,"std::string V8CoverageConnection::GetDirectory() const {
  return env()->coverage_directory();
}",1,1,inspector_profiler.cc,node.profiler.V8CoverageConnection.GetDirectory,,false,279,281,GetDirectory,,,10,string node.profiler.V8CoverageConnection.GetDirectory ()
95291,METHOD,inspector_profiler.cc:<global>,TYPE_DECL,"void V8CoverageConnection::Start() {
  DispatchMessage(""Profiler.enable"");
  DispatchMessage(""Profiler.startPreciseCoverage"",
                  R""({ ""callCount"": true, ""detailed"": true })"");
}",1,1,inspector_profiler.cc,node.profiler.V8CoverageConnection.Start,,false,283,287,Start,,,11,void node.profiler.V8CoverageConnection.Start ()
95300,METHOD,inspector_profiler.cc:<global>,TYPE_DECL,"void V8CoverageConnection::TakeCoverage() {
  DispatchMessage(""Profiler.takePreciseCoverage"", nullptr, true);
}",1,1,inspector_profiler.cc,node.profiler.V8CoverageConnection.TakeCoverage,,false,289,291,TakeCoverage,,,12,void node.profiler.V8CoverageConnection.TakeCoverage ()
95308,METHOD,inspector_profiler.cc:<global>,TYPE_DECL,"void V8CoverageConnection::StopCoverage() {
  DispatchMessage(""Profiler.stopPreciseCoverage"");
}",1,1,inspector_profiler.cc,node.profiler.V8CoverageConnection.StopCoverage,,false,293,295,StopCoverage,,,13,void node.profiler.V8CoverageConnection.StopCoverage ()
95314,METHOD,inspector_profiler.cc:<global>,TYPE_DECL,"void V8CoverageConnection::End() {
  Debug(env_,
      DebugCategory::INSPECTOR_PROFILER,
      ""V8CoverageConnection::End(), ending = %d\n"", ending_);
  if (ending_) {
    return;
  }
  ending_ = true;
  TakeCoverage();
}",1,1,inspector_profiler.cc,node.profiler.V8CoverageConnection.End,,false,297,306,End,,,14,void node.profiler.V8CoverageConnection.End ()
95333,METHOD,inspector_profiler.cc:<global>,TYPE_DECL,"std::string V8CpuProfilerConnection::GetDirectory() const {
  return env()->cpu_prof_dir();
}",1,1,inspector_profiler.cc,node.profiler.V8CpuProfilerConnection.GetDirectory,,false,308,310,GetDirectory,,,15,string node.profiler.V8CpuProfilerConnection.GetDirectory ()
95342,METHOD,inspector_profiler.cc:<global>,TYPE_DECL,"std::string V8CpuProfilerConnection::GetFilename() const {
  return env()->cpu_prof_name();
}",1,1,inspector_profiler.cc,node.profiler.V8CpuProfilerConnection.GetFilename,,false,312,314,GetFilename,,,16,string node.profiler.V8CpuProfilerConnection.GetFilename ()
95351,METHOD,inspector_profiler.cc:<global>,TYPE_DECL,"MaybeLocal<Object> V8CpuProfilerConnection::GetProfile(Local<Object> result) {
  Local<Value> profile_v;
  if (!result
           ->Get(env()->context(),
                 FIXED_ONE_BYTE_STRING(env()->isolate(), ""profile""))
           .ToLocal(&profile_v)) {
    fprintf(stderr, ""'profile' from CPU profile result is undefined\n"");
    return MaybeLocal<Object>();
  }
  if (!profile_v->IsObject()) {
    fprintf(stderr, ""'profile' from CPU profile result is not an Object\n"");
    return MaybeLocal<Object>();
  }
  return profile_v.As<Object>();
}",1,1,inspector_profiler.cc,node.profiler.V8CpuProfilerConnection.GetProfile,,false,316,330,GetProfile,,,17,MaybeLocal<Object> node.profiler.V8CpuProfilerConnection.GetProfile (Local<Object>)
95405,METHOD,inspector_profiler.cc:<global>,TYPE_DECL,"void V8CpuProfilerConnection::Start() {
  DispatchMessage(""Profiler.enable"");
  std::string params = R""({ ""interval"": )"";
  params += std::to_string(env()->cpu_prof_interval());
  params += "" }"";
  DispatchMessage(""Profiler.setSamplingInterval"", params.c_str());
  DispatchMessage(""Profiler.start"");
}",1,1,inspector_profiler.cc,node.profiler.V8CpuProfilerConnection.Start,,false,332,339,Start,,,18,void node.profiler.V8CpuProfilerConnection.Start ()
95436,METHOD,inspector_profiler.cc:<global>,TYPE_DECL,"void V8CpuProfilerConnection::End() {
  Debug(env_,
      DebugCategory::INSPECTOR_PROFILER,
      ""V8CpuProfilerConnection::End(), ending = %d\n"", ending_);
  if (ending_) {
    return;
  }
  ending_ = true;
  DispatchMessage(""Profiler.stop"", nullptr, true);
}",1,1,inspector_profiler.cc,node.profiler.V8CpuProfilerConnection.End,,false,341,350,End,,,19,void node.profiler.V8CpuProfilerConnection.End ()
95458,METHOD,inspector_profiler.cc:<global>,TYPE_DECL,"std::string V8HeapProfilerConnection::GetDirectory() const {
  return env()->heap_prof_dir();
}",1,1,inspector_profiler.cc,node.profiler.V8HeapProfilerConnection.GetDirectory,,false,352,354,GetDirectory,,,20,string node.profiler.V8HeapProfilerConnection.GetDirectory ()
95467,METHOD,inspector_profiler.cc:<global>,TYPE_DECL,"std::string V8HeapProfilerConnection::GetFilename() const {
  return env()->heap_prof_name();
}",1,1,inspector_profiler.cc,node.profiler.V8HeapProfilerConnection.GetFilename,,false,356,358,GetFilename,,,21,string node.profiler.V8HeapProfilerConnection.GetFilename ()
95476,METHOD,inspector_profiler.cc:<global>,TYPE_DECL,"MaybeLocal<Object> V8HeapProfilerConnection::GetProfile(Local<Object> result) {
  Local<Value> profile_v;
  if (!result
           ->Get(env()->context(),
                 FIXED_ONE_BYTE_STRING(env()->isolate(), ""profile""))
           .ToLocal(&profile_v)) {
    fprintf(stderr, ""'profile' from heap profile result is undefined\n"");
    return MaybeLocal<Object>();
  }
  if (!profile_v->IsObject()) {
    fprintf(stderr, ""'profile' from heap profile result is not an Object\n"");
    return MaybeLocal<Object>();
  }
  return profile_v.As<Object>();
}",1,1,inspector_profiler.cc,node.profiler.V8HeapProfilerConnection.GetProfile,,false,360,374,GetProfile,,,22,MaybeLocal<Object> node.profiler.V8HeapProfilerConnection.GetProfile (Local<Object>)
95530,METHOD,inspector_profiler.cc:<global>,TYPE_DECL,"void V8HeapProfilerConnection::Start() {
  DispatchMessage(""HeapProfiler.enable"");
  std::string params = R""({ ""samplingInterval"": )"";
  params += std::to_string(env()->heap_prof_interval());
  params += "" }"";
  DispatchMessage(""HeapProfiler.startSampling"", params.c_str());
}",1,1,inspector_profiler.cc,node.profiler.V8HeapProfilerConnection.Start,,false,376,382,Start,,,23,void node.profiler.V8HeapProfilerConnection.Start ()
95559,METHOD,inspector_profiler.cc:<global>,TYPE_DECL,"void V8HeapProfilerConnection::End() {
  Debug(env_,
      DebugCategory::INSPECTOR_PROFILER,
      ""V8HeapProfilerConnection::End(), ending = %d\n"", ending_);
  if (ending_) {
    return;
  }
  ending_ = true;
  DispatchMessage(""HeapProfiler.stopSampling"", nullptr, true);
}",1,1,inspector_profiler.cc,node.profiler.V8HeapProfilerConnection.End,,false,384,393,End,,,24,void node.profiler.V8HeapProfilerConnection.End ()
95581,METHOD,inspector_profiler.cc:<global>,TYPE_DECL,"static void EndStartedProfilers(Environment* env) {
  // TODO(joyeechueng): merge these connections and use one session per env.
  Debug(env, DebugCategory::INSPECTOR_PROFILER, ""EndStartedProfilers\n"");
  V8ProfilerConnection* connection = env->cpu_profiler_connection();
  if (connection != nullptr) {
    connection->End();
  }

  connection = env->heap_profiler_connection();
  if (connection != nullptr) {
    connection->End();
  }

  connection = env->coverage_connection();
  if (connection != nullptr) {
    connection->End();
  }
}",1,1,inspector_profiler.cc,node.profiler.EndStartedProfilers,,false,397,414,EndStartedProfilers,,,25,void node.profiler.EndStartedProfilers (Environment*)
95638,METHOD,inspector_profiler.cc:<global>,TYPE_DECL,"void StartProfilers(Environment* env) {
  AtExit(env, [](void* env) {
    EndStartedProfilers(static_cast<Environment*>(env));
  }, env);

  Isolate* isolate = env->isolate();
  Local<String> coverage_str = env->env_vars()->Get(
      isolate, FIXED_ONE_BYTE_STRING(isolate, ""NODE_V8_COVERAGE""))
      .FromMaybe(Local<String>());
  if ((!coverage_str.IsEmpty() && coverage_str->Length() > 0) ||
      env->options()->test_runner_coverage) {
    CHECK_NULL(env->coverage_connection());
    env->set_coverage_connection(std::make_unique<V8CoverageConnection>(env));
    env->coverage_connection()->Start();
  }
  if (env->options()->cpu_prof) {
    const std::string& dir = env->options()->cpu_prof_dir;
    env->set_cpu_prof_interval(env->options()->cpu_prof_interval);
    env->set_cpu_prof_dir(dir.empty() ? env->GetCwd() : dir);
    if (env->options()->cpu_prof_name.empty()) {
      DiagnosticFilename filename(env, ""CPU"", ""cpuprofile"");
      env->set_cpu_prof_name(*filename);
    } else {
 ...",1,1,inspector_profiler.cc,node.profiler.StartProfilers,,false,416,460,StartProfilers,,,26,void node.profiler.StartProfilers (Environment*)
95911,METHOD,inspector_profiler.cc:<global>,TYPE_DECL,"static void SetCoverageDirectory(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsString());
  Environment* env = Environment::GetCurrent(args);
  node::Utf8Value directory(env->isolate(), args[0].As<String>());
  env->set_coverage_directory(*directory);
}",1,1,inspector_profiler.cc,node.profiler.SetCoverageDirectory,,false,462,467,SetCoverageDirectory,,,27,void node.profiler.SetCoverageDirectory (FunctionCallbackInfo<Value>)
95949,METHOD,inspector_profiler.cc:<global>,TYPE_DECL,"static void SetSourceMapCacheGetter(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsFunction());
  Environment* env = Environment::GetCurrent(args);
  env->set_source_map_cache_getter(args[0].As<Function>());
}",1,1,inspector_profiler.cc,node.profiler.SetSourceMapCacheGetter,,false,470,474,SetSourceMapCacheGetter,,,28,void node.profiler.SetSourceMapCacheGetter (FunctionCallbackInfo<Value>)
95979,METHOD,inspector_profiler.cc:<global>,TYPE_DECL,"static void TakeCoverage(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  V8CoverageConnection* connection = env->coverage_connection();

  Debug(
    env,
    DebugCategory::INSPECTOR_PROFILER,
    ""TakeCoverage, connection %s nullptr\n"",
    connection == nullptr ? ""=="" : ""!="");

  if (connection != nullptr) {
    Debug(env, DebugCategory::INSPECTOR_PROFILER, ""taking coverage\n"");
    connection->TakeCoverage();
  }
}",1,1,inspector_profiler.cc,node.profiler.TakeCoverage,,false,476,490,TakeCoverage,,,29,void node.profiler.TakeCoverage (FunctionCallbackInfo<Value>)
96026,METHOD,inspector_profiler.cc:<global>,TYPE_DECL,"static void StopCoverage(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  V8CoverageConnection* connection = env->coverage_connection();

  Debug(env,
        DebugCategory::INSPECTOR_PROFILER,
        ""StopCoverage, connection %s nullptr\n"",
        connection == nullptr ? ""=="" : ""!="");

  if (connection != nullptr) {
    Debug(env, DebugCategory::INSPECTOR_PROFILER, ""Stopping coverage\n"");
    connection->StopCoverage();
  }
}",1,1,inspector_profiler.cc,node.profiler.StopCoverage,,false,492,505,StopCoverage,,,30,void node.profiler.StopCoverage (FunctionCallbackInfo<Value>)
96073,METHOD,inspector_profiler.cc:<global>,TYPE_DECL,"static void Initialize(Local<Object> target,
                       Local<Value> unused,
                       Local<Context> context,
                       void* priv) {
  SetMethod(context, target, ""setCoverageDirectory"", SetCoverageDirectory);
  SetMethod(
      context, target, ""setSourceMapCacheGetter"", SetSourceMapCacheGetter);
  SetMethod(context, target, ""takeCoverage"", TakeCoverage);
  SetMethod(context, target, ""stopCoverage"", StopCoverage);
}",1,1,inspector_profiler.cc,node.profiler.Initialize,,false,507,516,Initialize,,,31,"void node.profiler.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
96101,METHOD,inspector_profiler.cc:<global>,TYPE_DECL,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(SetCoverageDirectory);
  registry->Register(SetSourceMapCacheGetter);
  registry->Register(TakeCoverage);
  registry->Register(StopCoverage);
}",1,1,inspector_profiler.cc,node.profiler.RegisterExternalReferences,,false,518,523,RegisterExternalReferences,,,32,void node.profiler.RegisterExternalReferences (ExternalReferenceRegistry*)
96134,METHOD,inspector_profiler.hpp:<global>,TYPE_DECL,<global>,1,36,inspector_profiler.hpp,inspector_profiler.hpp:<global>,,false,1,149,<global>,,,1,
96137,METHOD,inspector_socket.cc:<global>,TYPE_DECL,[](auto b) { return b == 0; },48,76,inspector_socket.cc,node.inspector.anonymous_namespace_12.IsIPAddress.<lambda>0,,false,204,204,<lambda>0,,,1,ANY node.inspector.anonymous_namespace_12.IsIPAddress.<lambda>0 (auto)
96165,METHOD,inspector_socket.cc:<global>,TYPE_DECL,<global>,1,34,inspector_socket.hpp,inspector_socket.cc:<global>,,false,1,819,<global>,,,1,
96170,METHOD,node.inspector.TcpHolder,TYPE_DECL,static void DisconnectAndDispose(TcpHolder* holder);,15,53,inspector_socket.cc,node.inspector.TcpHolder.DisconnectAndDispose,,false,23,23,DisconnectAndDispose,,,1,void node.inspector.TcpHolder.DisconnectAndDispose (TcpHolder*)
96176,METHOD,node.inspector.TcpHolder,TYPE_DECL,"static Pointer Accept(uv_stream_t* server,
                        InspectorSocket::DelegatePointer delegate);",18,66,inspector_socket.cc,node.inspector.TcpHolder.Accept,,false,26,27,Accept,,,3,"Pointer node.inspector.TcpHolder.Accept (uv_stream_t*,ANY)"
96182,METHOD,node.inspector.TcpHolder,TYPE_DECL,void SetHandler(ProtocolHandler* handler);,8,43,inspector_socket.cc,node.inspector.TcpHolder.SetHandler,,false,28,28,SetHandler,,,4,void node.inspector.TcpHolder.SetHandler (ProtocolHandler*)
96187,METHOD,node.inspector.TcpHolder,TYPE_DECL,"int WriteRaw(const std::vector<char>& buffer, uv_write_cb write_cb);",7,69,inspector_socket.cc,node.inspector.TcpHolder.WriteRaw,,false,29,29,WriteRaw,,,5,"int node.inspector.TcpHolder.WriteRaw (ANY,uv_write_cb)"
96193,METHOD,node.inspector.TcpHolder,TYPE_DECL,"uv_tcp_t* tcp() {
    return &tcp_;
  }",3,3,inspector_socket.cc,node.inspector.TcpHolder.tcp,,false,30,32,tcp,,,6,uv_tcp_t node.inspector.TcpHolder.tcp ()
96200,METHOD,node.inspector.TcpHolder,TYPE_DECL,InspectorSocket::Delegate* delegate();,28,39,inspector_socket.cc,node.inspector.TcpHolder.delegate,,false,33,33,delegate,,,7,ANY* node.inspector.TcpHolder.delegate ()
96204,METHOD,node.inspector.TcpHolder,TYPE_DECL,"static TcpHolder* From(void* handle) {
    return node::ContainerOf(&TcpHolder::tcp_,
                             reinterpret_cast<uv_tcp_t*>(handle));
  }",3,3,inspector_socket.cc,node.inspector.TcpHolder.From,,false,36,39,From,,,8,TcpHolder node.inspector.TcpHolder.From (void*)
96221,METHOD,node.inspector.TcpHolder,TYPE_DECL,static void OnClosed(uv_handle_t* handle);,15,43,inspector_socket.cc,node.inspector.TcpHolder.OnClosed,,false,40,40,OnClosed,,,9,void node.inspector.TcpHolder.OnClosed (uv_handle_t*)
96226,METHOD,node.inspector.TcpHolder,TYPE_DECL,"static void OnDataReceivedCb(uv_stream_t* stream, ssize_t nread,
                               const uv_buf_t* buf);",15,51,inspector_socket.cc,node.inspector.TcpHolder.OnDataReceivedCb,,false,41,42,OnDataReceivedCb,,,10,"void node.inspector.TcpHolder.OnDataReceivedCb (uv_stream_t*,ssize_t,uv_buf_t*)"
96233,METHOD,node.inspector.TcpHolder,TYPE_DECL,explicit TcpHolder(InspectorSocket::DelegatePointer delegate);,12,63,inspector_socket.cc,node.inspector.TcpHolder.TcpHolder,,false,43,43,TcpHolder,,,11,explicit node.inspector.TcpHolder.TcpHolder (ANY)
96238,METHOD,node.inspector.TcpHolder,TYPE_DECL,~TcpHolder() = default;,3,25,inspector_socket.cc,node.inspector.TcpHolder.~TcpHolder,,false,44,44,~TcpHolder,,,12,ANY node.inspector.TcpHolder.~TcpHolder ()
96242,METHOD,node.inspector.TcpHolder,TYPE_DECL,"void ReclaimUvBuf(const uv_buf_t* buf, ssize_t read);",8,54,inspector_socket.cc,node.inspector.TcpHolder.ReclaimUvBuf,,false,45,45,ReclaimUvBuf,,,13,"void node.inspector.TcpHolder.ReclaimUvBuf (uv_buf_t*,ssize_t)"
96253,METHOD,node.inspector.ProtocolHandler,TYPE_DECL,"ProtocolHandler(InspectorSocket* inspector, TcpHolder::Pointer tcp);",3,69,inspector_socket.cc,node.inspector.ProtocolHandler.ProtocolHandler,,false,56,56,ProtocolHandler,,,1,"ANY node.inspector.ProtocolHandler.ProtocolHandler (InspectorSocket*,ANY)"
96259,METHOD,node.inspector.ProtocolHandler,TYPE_DECL,virtual void AcceptUpgrade(const std::string& accept_key) = 0;,16,63,inspector_socket.cc,node.inspector.ProtocolHandler.AcceptUpgrade,,false,58,58,AcceptUpgrade,,,2,void node.inspector.ProtocolHandler.AcceptUpgrade (ANY)
96264,METHOD,node.inspector.ProtocolHandler,TYPE_DECL,virtual void OnData(std::vector<char>* data) = 0;,16,50,inspector_socket.cc,node.inspector.ProtocolHandler.OnData,,false,59,59,OnData,,,3,void node.inspector.ProtocolHandler.OnData (ANY*)
96269,METHOD,node.inspector.ProtocolHandler,TYPE_DECL,virtual void OnEof() = 0;,16,26,inspector_socket.cc,node.inspector.ProtocolHandler.OnEof,,false,60,60,OnEof,,,4,void node.inspector.ProtocolHandler.OnEof ()
96273,METHOD,node.inspector.ProtocolHandler,TYPE_DECL,virtual void Write(const std::vector<char> data) = 0;,16,54,inspector_socket.cc,node.inspector.ProtocolHandler.Write,,false,61,61,Write,,,5,void node.inspector.ProtocolHandler.Write (ANY)
96278,METHOD,node.inspector.ProtocolHandler,TYPE_DECL,virtual void CancelHandshake() = 0;,16,36,inspector_socket.cc,node.inspector.ProtocolHandler.CancelHandshake,,false,62,62,CancelHandshake,,,6,void node.inspector.ProtocolHandler.CancelHandshake ()
96282,METHOD,node.inspector.ProtocolHandler,TYPE_DECL,std::string GetHost() const;,15,29,inspector_socket.cc,node.inspector.ProtocolHandler.GetHost,,false,64,64,GetHost,,,7,ANY node.inspector.ProtocolHandler.GetHost ()
96286,METHOD,node.inspector.ProtocolHandler,TYPE_DECL,"InspectorSocket* inspector() {
    return inspector_;
  }",3,3,inspector_socket.cc,node.inspector.ProtocolHandler.inspector,,false,66,68,inspector,,,8,InspectorSocket node.inspector.ProtocolHandler.inspector ()
96292,METHOD,node.inspector.ProtocolHandler,TYPE_DECL,virtual void Shutdown() = 0;,16,29,inspector_socket.cc,node.inspector.ProtocolHandler.Shutdown,,false,69,69,Shutdown,,,9,void node.inspector.ProtocolHandler.Shutdown ()
96296,METHOD,node.inspector.ProtocolHandler,TYPE_DECL,virtual ~ProtocolHandler() = default;,3,39,inspector_socket.cc,node.inspector.ProtocolHandler.~ProtocolHandler,,false,72,72,~ProtocolHandler,,,10,ANY node.inspector.ProtocolHandler.~ProtocolHandler ()
96300,METHOD,node.inspector.ProtocolHandler,TYPE_DECL,"int WriteRaw(const std::vector<char>& buffer, uv_write_cb write_cb);",7,69,inspector_socket.cc,node.inspector.ProtocolHandler.WriteRaw,,false,73,73,WriteRaw,,,11,"int node.inspector.ProtocolHandler.WriteRaw (ANY,uv_write_cb)"
96306,METHOD,node.inspector.ProtocolHandler,TYPE_DECL,InspectorSocket::Delegate* delegate();,28,39,inspector_socket.cc,node.inspector.ProtocolHandler.delegate,,false,74,74,delegate,,,12,ANY* node.inspector.ProtocolHandler.delegate ()
96314,METHOD,node.inspector.anonymous_namespace_1.WriteRequest,TYPE_DECL,"WriteRequest(ProtocolHandler* handler, const std::vector<char>& buffer)
      : handler(handler)
      , storage(buffer)
      , req(uv_write_t())
      , buf(uv_buf_init(storage.data(), storage.size())) {}",3,59,inspector_socket.cc,node.inspector.anonymous_namespace_2.WriteRequest.WriteRequest,,false,110,114,WriteRequest,,,1,"ANY node.inspector.anonymous_namespace_2.WriteRequest.WriteRequest (ProtocolHandler*,ANY)"
96320,METHOD,node.inspector.anonymous_namespace_1.WriteRequest,TYPE_DECL,"static WriteRequest* from_write_req(uv_write_t* req) {
    return node::ContainerOf(&WriteRequest::req, req);
  }",3,3,inspector_socket.cc,node.inspector.anonymous_namespace_3.WriteRequest.from_write_req,,false,116,118,from_write_req,,,2,WriteRequest node.inspector.anonymous_namespace_3.WriteRequest.from_write_req (uv_write_t*)
96335,METHOD,node.inspector.anonymous_namespace_1.WriteRequest,TYPE_DECL,"static void Cleanup(uv_write_t* req, int status) {
    delete WriteRequest::from_write_req(req);
  }",3,3,inspector_socket.cc,node.inspector.anonymous_namespace_4.WriteRequest.Cleanup,,false,120,122,Cleanup,,,3,"void node.inspector.anonymous_namespace_4.WriteRequest.Cleanup (uv_write_t*,int)"
96351,METHOD,inspector_socket.cc:<global>,TYPE_DECL,"void allocate_buffer(uv_handle_t* stream, size_t len, uv_buf_t* buf) {
  *buf = uv_buf_init(new char[len], len);
}",1,1,inspector_socket.cc,node.inspector.anonymous_namespace_6.allocate_buffer,,false,130,132,allocate_buffer,,,2,"void node.inspector.anonymous_namespace_6.allocate_buffer (uv_handle_t*,size_t,uv_buf_t*)"
96365,METHOD,inspector_socket.cc:<global>,TYPE_DECL,"static void remove_from_beginning(std::vector<char>* buffer, size_t count) {
  buffer->erase(buffer->begin(), buffer->begin() + count);
}",1,1,inspector_socket.cc,node.inspector.anonymous_namespace_7.remove_from_beginning,,false,134,136,remove_from_beginning,,,3,"void node.inspector.anonymous_namespace_7.remove_from_beginning (ANY*,size_t)"
96396,METHOD,inspector_socket.cc:<global>,TYPE_DECL,"static void generate_accept_string(const std::string& client_key,
                                   char (*buffer)[ACCEPT_KEY_LENGTH]) {
  // Magic string from websockets spec.
  static const char ws_magic[] = ""258EAFA5-E914-47DA-95CA-C5AB0DC85B11"";
  std::string input(client_key + ws_magic);
  char hash[SHA_DIGEST_LENGTH];
  USE(SHA1(reinterpret_cast<const unsigned char*>(input.data()),
           input.size(),
           reinterpret_cast<unsigned char*>(hash)));
  node::base64_encode(hash, sizeof(hash), *buffer, sizeof(*buffer));
}",1,50,inspector_socket.cc,node.inspector.anonymous_namespace_9.generate_accept_string,,false,144,154,generate_accept_string,,,7,"void node.inspector.anonymous_namespace_9.generate_accept_string (ANY,char[ACCEPT_KEY_LENGTH])"
96439,METHOD,inspector_socket.cc:<global>,TYPE_DECL,"static std::string TrimPort(const std::string& host) {
  size_t last_colon_pos = host.rfind(':');
  if (last_colon_pos == std::string::npos)
    return host;
  size_t bracket = host.rfind(']');
  if (bracket == std::string::npos || last_colon_pos > bracket)
    return host.substr(0, last_colon_pos);
  return host;
}",1,1,inspector_socket.cc,node.inspector.anonymous_namespace_10.TrimPort,,false,156,164,TrimPort,,,8,string node.inspector.anonymous_namespace_10.TrimPort (ANY)
96493,METHOD,inspector_socket.cc:<global>,TYPE_DECL,"static bool IsIPAddress(const std::string& host) {
  // To avoid DNS rebinding attacks, we are aware of the following requirements:
  // * the host name must be an IP address (CVE-2018-7160, CVE-2022-32212),
  // * the IP address must be routable (hackerone.com/reports/1632921), and
  // * the IP address must be formatted unambiguously (CVE-2022-43548).

  // The logic below assumes that the string is null-terminated, so ensure that
  // we did not somehow end up with null characters within the string.
  if (host.find('\0') != std::string::npos) return false;

  // All IPv6 addresses must be enclosed in square brackets, and anything
  // enclosed in square brackets must be an IPv6 address.
  if (host.length() >= 4 && host.front() == '[' && host.back() == ']') {
    // INET6_ADDRSTRLEN is the maximum length of the dual format (including the
    // terminating null character), which is the longest possible representation
    // of an IPv6 address: xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:ddd.ddd...",1,1,inspector_socket.cc,node.inspector.anonymous_namespace_11.IsIPAddress,,false,166,230,IsIPAddress,,,9,bool node.inspector.anonymous_namespace_11.IsIPAddress (ANY)
96709,METHOD,inspector_socket.cc:<global>,TYPE_DECL,"static std::vector<char> encode_frame_hybi17(const std::vector<char>& message) {
  std::vector<char> frame;
  OpCode op_code = kOpCodeText;
  frame.push_back(kFinalBit | op_code);
  const size_t data_length = message.size();
  if (data_length <= kMaxSingleBytePayloadLength) {
    frame.push_back(static_cast<char>(data_length));
  } else if (data_length <= 0xFFFF) {
    frame.push_back(kTwoBytePayloadLengthField);
    frame.push_back((data_length & 0xFF00) >> 8);
    frame.push_back(data_length & 0xFF);
  } else {
    frame.push_back(kEightBytePayloadLengthField);
    char extended_payload_length[8];
    size_t remaining = data_length;
    // Fill the length into extended_payload_length in the network byte order.
    for (int i = 0; i < 8; ++i) {
      extended_payload_length[7 - i] = remaining & 0xFF;
      remaining >>= 8;
    }
    frame.insert(frame.end(), extended_payload_length,
                 extended_payload_length + 8);
    CHECK_EQ(0, remaining);
  }
  frame.insert(frame....",1,1,inspector_socket.cc,node.inspector.anonymous_namespace_13.encode_frame_hybi17,,false,256,282,encode_frame_hybi17,,,45,vector<char> node.inspector.anonymous_namespace_13.encode_frame_hybi17 (ANY)
96842,METHOD,inspector_socket.cc:<global>,TYPE_DECL,"static ws_decode_result decode_frame_hybi17(const std::vector<char>& buffer,
                                            bool client_frame,
                                            int* bytes_consumed,
                                            std::vector<char>* output,
                                            bool* compressed) {
  *bytes_consumed = 0;
  if (buffer.size() < 2)
    return FRAME_INCOMPLETE;

  auto it = buffer.begin();

  unsigned char first_byte = *it++;
  unsigned char second_byte = *it++;

  bool final = (first_byte & kFinalBit) != 0;
  bool reserved1 = (first_byte & kReserved1Bit) != 0;
  bool reserved2 = (first_byte & kReserved2Bit) != 0;
  bool reserved3 = (first_byte & kReserved3Bit) != 0;
  int op_code = first_byte & kOpCodeMask;
  bool masked = (second_byte & kMaskBit) != 0;
  *compressed = reserved1;
  if (!final || reserved2 || reserved3)
    return FRAME_ERROR;  // Only compression extension is supported.

  bool closed = false;
  switch (op_code) ...",1,1,inspector_socket.cc,node.inspector.anonymous_namespace_14.decode_frame_hybi17,,false,284,368,decode_frame_hybi17,,,46,"ws_decode_result node.inspector.anonymous_namespace_14.decode_frame_hybi17 (ANY,bool,int*,ANY*,bool*)"
97150,METHOD,node.inspector.anonymous_namespace_15.WsHandler,TYPE_DECL,"WsHandler(InspectorSocket* inspector, TcpHolder::Pointer tcp)
            : ProtocolHandler(inspector, std::move(tcp)),
              OnCloseSent(&WsHandler::WaitForCloseReply),
              OnCloseReceived(&WsHandler::CloseFrameReceived),
              dispose_(false) { }",3,33,inspector_socket.cc,node.inspector.anonymous_namespace_16.WsHandler.WsHandler,,false,373,377,WsHandler,,,1,"ANY node.inspector.anonymous_namespace_16.WsHandler.WsHandler (InspectorSocket*,ANY)"
97156,METHOD,node.inspector.anonymous_namespace_15.WsHandler,TYPE_DECL,void AcceptUpgrade(const std::string& accept_key) override { },3,64,inspector_socket.cc,node.inspector.anonymous_namespace_17.WsHandler.AcceptUpgrade,,false,379,379,AcceptUpgrade,,,2,void node.inspector.anonymous_namespace_17.WsHandler.AcceptUpgrade (ANY)
97161,METHOD,node.inspector.anonymous_namespace_15.WsHandler,TYPE_DECL,void CancelHandshake() override {},3,36,inspector_socket.cc,node.inspector.anonymous_namespace_18.WsHandler.CancelHandshake,,false,380,380,CancelHandshake,,,3,void node.inspector.anonymous_namespace_18.WsHandler.CancelHandshake ()
97165,METHOD,node.inspector.anonymous_namespace_15.WsHandler,TYPE_DECL,"void OnEof() override {
    tcp_.reset();
    if (dispose_)
      delete this;
  }",3,3,inspector_socket.cc,node.inspector.anonymous_namespace_19.WsHandler.OnEof,,false,382,386,OnEof,,,4,void node.inspector.anonymous_namespace_19.WsHandler.OnEof ()
97178,METHOD,node.inspector.anonymous_namespace_15.WsHandler,TYPE_DECL,"void OnData(std::vector<char>* data) override {
    // 1. Parse.
    int processed = 0;
    do {
      processed = ParseWsFrames(*data);
      // 2. Fix the data size & length
      if (processed > 0) {
        remove_from_beginning(data, processed);
      }
    } while (processed > 0 && !data->empty());
  }",3,3,inspector_socket.cc,node.inspector.anonymous_namespace_20.WsHandler.OnData,,false,388,398,OnData,,,5,void node.inspector.anonymous_namespace_20.WsHandler.OnData (ANY*)
97211,METHOD,node.inspector.anonymous_namespace_15.WsHandler,TYPE_DECL,"void Write(const std::vector<char> data) override {
    std::vector<char> output = encode_frame_hybi17(data);
    WriteRaw(output, WriteRequest::Cleanup);
  }",3,3,inspector_socket.cc,node.inspector.anonymous_namespace_22.WsHandler.Write,,false,400,403,Write,,,6,void node.inspector.anonymous_namespace_22.WsHandler.Write (ANY)
97226,METHOD,node.inspector.anonymous_namespace_15.WsHandler,TYPE_DECL,"void Shutdown() override {
    if (tcp_) {
      dispose_ = true;
      SendClose();
    } else {
      delete this;
    }
  }",3,3,inspector_socket.cc,node.inspector.anonymous_namespace_24.WsHandler.Shutdown,,false,406,413,Shutdown,,,7,void node.inspector.anonymous_namespace_24.WsHandler.Shutdown ()
97242,METHOD,node.inspector.anonymous_namespace_15.WsHandler,TYPE_DECL,"static void OnCloseFrameWritten(uv_write_t* req, int status) {
    WriteRequest* wr = WriteRequest::from_write_req(req);
    WsHandler* handler = static_cast<WsHandler*>(wr->handler);
    delete wr;
    Callback cb = handler->OnCloseSent;
    (handler->*cb)();
  }",3,3,inspector_socket.cc,node.inspector.anonymous_namespace_26.WsHandler.OnCloseFrameWritten,,false,418,424,OnCloseFrameWritten,,,9,"void node.inspector.anonymous_namespace_26.WsHandler.OnCloseFrameWritten (uv_write_t*,int)"
97276,METHOD,node.inspector.anonymous_namespace_15.WsHandler,TYPE_DECL,"void WaitForCloseReply() {
    OnCloseReceived = &WsHandler::OnEof;
  }",3,3,inspector_socket.cc,node.inspector.anonymous_namespace_28.WsHandler.WaitForCloseReply,,false,426,428,WaitForCloseReply,,,10,void node.inspector.anonymous_namespace_28.WsHandler.WaitForCloseReply ()
97286,METHOD,node.inspector.anonymous_namespace_15.WsHandler,TYPE_DECL,"void SendClose() {
    WriteRaw(std::vector<char>(CLOSE_FRAME, CLOSE_FRAME + sizeof(CLOSE_FRAME)),
             OnCloseFrameWritten);
  }",3,3,inspector_socket.cc,node.inspector.anonymous_namespace_29.WsHandler.SendClose,,false,430,433,SendClose,,,11,void node.inspector.anonymous_namespace_29.WsHandler.SendClose ()
97301,METHOD,node.inspector.anonymous_namespace_15.WsHandler,TYPE_DECL,"void CloseFrameReceived() {
    OnCloseSent = &WsHandler::OnEof;
    SendClose();
  }",3,3,inspector_socket.cc,node.inspector.anonymous_namespace_31.WsHandler.CloseFrameReceived,,false,435,438,CloseFrameReceived,,,12,void node.inspector.anonymous_namespace_31.WsHandler.CloseFrameReceived ()
97312,METHOD,node.inspector.anonymous_namespace_15.WsHandler,TYPE_DECL,"int ParseWsFrames(const std::vector<char>& buffer) {
    int bytes_consumed = 0;
    std::vector<char> output;
    bool compressed = false;

    ws_decode_result r =  decode_frame_hybi17(buffer,
                                              true /* client_frame */,
                                              &bytes_consumed, &output,
                                              &compressed);
    // Compressed frame means client is ignoring the headers and misbehaves
    if (compressed || r == FRAME_ERROR) {
      OnEof();
      bytes_consumed = 0;
    } else if (r == FRAME_CLOSE) {
      (this->*OnCloseReceived)();
      bytes_consumed = 0;
    } else if (r == FRAME_OK) {
      delegate()->OnWsFrame(output);
    }
    return bytes_consumed;
  }",3,3,inspector_socket.cc,node.inspector.anonymous_namespace_33.WsHandler.ParseWsFrames,,false,440,460,ParseWsFrames,,,13,int node.inspector.anonymous_namespace_33.WsHandler.ParseWsFrames (ANY)
97381,METHOD,node.inspector.anonymous_namespace_36.HttpEvent,TYPE_DECL,"HttpEvent(const std::string& path, bool upgrade, bool isGET,
            const std::string& ws_key, const std::string& host)
            : path(path), upgrade(upgrade), isGET(isGET), ws_key(ws_key),
              host(host) { }",3,28,inspector_socket.cc,node.inspector.anonymous_namespace_37.HttpEvent.HttpEvent,,false,471,474,HttpEvent,,,1,"ANY node.inspector.anonymous_namespace_37.HttpEvent.HttpEvent (ANY,bool,bool,ANY,ANY)"
97396,METHOD,node.inspector.anonymous_namespace_38.HttpHandler,TYPE_DECL,"explicit HttpHandler(InspectorSocket* inspector, TcpHolder::Pointer tcp)
                       : ProtocolHandler(inspector, std::move(tcp)),
                         parsing_value_(false) {
    llhttp_init(&parser_, HTTP_REQUEST, &parser_settings);
    llhttp_settings_init(&parser_settings);
    parser_settings.on_header_field = OnHeaderField;
    parser_settings.on_header_value = OnHeaderValue;
    parser_settings.on_message_complete = OnMessageComplete;
    parser_settings.on_url = OnPath;
  }",3,3,inspector_socket.cc,node.inspector.anonymous_namespace_39.HttpHandler.HttpHandler,,false,485,494,HttpHandler,,,1,"ANY node.inspector.anonymous_namespace_39.HttpHandler.HttpHandler (InspectorSocket*,ANY)"
97431,METHOD,node.inspector.anonymous_namespace_38.HttpHandler,TYPE_DECL,"void AcceptUpgrade(const std::string& accept_key) override {
    char accept_string[ACCEPT_KEY_LENGTH];
    generate_accept_string(accept_key, &accept_string);
    const char accept_ws_prefix[] = ""HTTP/1.1 101 Switching Protocols\r\n""
                                    ""Upgrade: websocket\r\n""
                                    ""Connection: Upgrade\r\n""
                                    ""Sec-WebSocket-Accept: "";
    const char accept_ws_suffix[] = ""\r\n\r\n"";
    std::vector<char> reply(accept_ws_prefix,
                            accept_ws_prefix + sizeof(accept_ws_prefix) - 1);
    reply.insert(reply.end(), accept_string,
                 accept_string + sizeof(accept_string));
    reply.insert(reply.end(), accept_ws_suffix,
                 accept_ws_suffix + sizeof(accept_ws_suffix) - 1);
    if (WriteRaw(reply, WriteRequest::Cleanup) >= 0) {
      inspector_->SwitchProtocol(new WsHandler(inspector_, std::move(tcp_)));
    } else {
      tcp_.reset();
    }
  }",3,23,inspector_socket.cc,node.inspector.anonymous_namespace_44.HttpHandler.AcceptUpgrade,,false,496,515,AcceptUpgrade,,,2,void node.inspector.anonymous_namespace_44.HttpHandler.AcceptUpgrade (ANY)
97513,METHOD,node.inspector.anonymous_namespace_38.HttpHandler,TYPE_DECL,"void CancelHandshake() override {
    const char HANDSHAKE_FAILED_RESPONSE[] =
        ""HTTP/1.0 400 Bad Request\r\n""
        ""Content-Type: text/html; charset=UTF-8\r\n\r\n""
        ""WebSockets request was expected\r\n"";
    WriteRaw(std::vector<char>(HANDSHAKE_FAILED_RESPONSE,
             HANDSHAKE_FAILED_RESPONSE + sizeof(HANDSHAKE_FAILED_RESPONSE) - 1),
             ThenCloseAndReportFailure);
  }",3,3,inspector_socket.cc,node.inspector.anonymous_namespace_46.HttpHandler.CancelHandshake,,false,517,525,CancelHandshake,,,3,void node.inspector.anonymous_namespace_46.HttpHandler.CancelHandshake ()
97534,METHOD,node.inspector.anonymous_namespace_38.HttpHandler,TYPE_DECL,"void OnEof() override {
    tcp_.reset();
  }",3,3,inspector_socket.cc,node.inspector.anonymous_namespace_48.HttpHandler.OnEof,,false,528,530,OnEof,,,4,void node.inspector.anonymous_namespace_48.HttpHandler.OnEof ()
97542,METHOD,node.inspector.anonymous_namespace_38.HttpHandler,TYPE_DECL,"void OnData(std::vector<char>* data) override {
    llhttp_errno_t err;
    err = llhttp_execute(&parser_, data->data(), data->size());

    if (err == HPE_PAUSED_UPGRADE) {
      err = HPE_OK;
      llhttp_resume_after_upgrade(&parser_);
    }
    data->clear();
    if (err != HPE_OK) {
      CancelHandshake();
    }
    // Event handling may delete *this
    std::vector<HttpEvent> events;
    std::swap(events, events_);
    for (const HttpEvent& event : events) {
      if (!IsAllowedHost(event.host) || !event.isGET) {
        CancelHandshake();
        return;
      } else if (!event.upgrade) {
        delegate()->OnHttpGet(event.host, event.path);
      } else if (event.ws_key.empty()) {
        CancelHandshake();
        return;
      } else {
        delegate()->OnSocketUpgrade(event.host, event.path, event.ws_key);
      }
    }
  }",3,3,inspector_socket.cc,node.inspector.anonymous_namespace_49.HttpHandler.OnData,,false,532,560,OnData,,,5,void node.inspector.anonymous_namespace_49.HttpHandler.OnData (ANY*)
97652,METHOD,node.inspector.anonymous_namespace_38.HttpHandler,TYPE_DECL,"void Write(const std::vector<char> data) override {
    WriteRaw(data, WriteRequest::Cleanup);
  }",3,3,inspector_socket.cc,node.inspector.anonymous_namespace_54.HttpHandler.Write,,false,562,564,Write,,,6,void node.inspector.anonymous_namespace_54.HttpHandler.Write (ANY)
97662,METHOD,node.inspector.anonymous_namespace_38.HttpHandler,TYPE_DECL,"void Shutdown() override {
    delete this;
  }",3,3,inspector_socket.cc,node.inspector.anonymous_namespace_55.HttpHandler.Shutdown,,false,567,569,Shutdown,,,7,void node.inspector.anonymous_namespace_55.HttpHandler.Shutdown ()
97668,METHOD,node.inspector.anonymous_namespace_38.HttpHandler,TYPE_DECL,"static void ThenCloseAndReportFailure(uv_write_t* req, int status) {
    ProtocolHandler* handler = WriteRequest::from_write_req(req)->handler;
    WriteRequest::Cleanup(req, status);
    handler->inspector()->SwitchProtocol(nullptr);
  }",3,3,inspector_socket.cc,node.inspector.anonymous_namespace_56.HttpHandler.ThenCloseAndReportFailure,,false,572,576,ThenCloseAndReportFailure,,,8,"void node.inspector.anonymous_namespace_56.HttpHandler.ThenCloseAndReportFailure (uv_write_t*,int)"
97698,METHOD,node.inspector.anonymous_namespace_38.HttpHandler,TYPE_DECL,"static int OnHeaderValue(llhttp_t* parser, const char* at, size_t length) {
    HttpHandler* handler = From(parser);
    handler->parsing_value_ = true;
    handler->headers_[handler->current_header_].append(at, length);
    return 0;
  }",3,3,inspector_socket.cc,node.inspector.anonymous_namespace_59.HttpHandler.OnHeaderValue,,false,578,583,OnHeaderValue,,,9,"int node.inspector.anonymous_namespace_59.HttpHandler.OnHeaderValue (llhttp_t*,char*,size_t)"
97729,METHOD,node.inspector.anonymous_namespace_38.HttpHandler,TYPE_DECL,"static int OnHeaderField(llhttp_t* parser, const char* at, size_t length) {
    HttpHandler* handler = From(parser);
    if (handler->parsing_value_) {
      handler->parsing_value_ = false;
      handler->current_header_.clear();
    }
    handler->current_header_.append(at, length);
    return 0;
  }",3,3,inspector_socket.cc,node.inspector.anonymous_namespace_62.HttpHandler.OnHeaderField,,false,585,593,OnHeaderField,,,10,"int node.inspector.anonymous_namespace_62.HttpHandler.OnHeaderField (llhttp_t*,char*,size_t)"
97767,METHOD,node.inspector.anonymous_namespace_38.HttpHandler,TYPE_DECL,"static int OnPath(llhttp_t* parser, const char* at, size_t length) {
    HttpHandler* handler = From(parser);
    handler->path_.append(at, length);
    return 0;
  }",3,3,inspector_socket.cc,node.inspector.anonymous_namespace_65.HttpHandler.OnPath,,false,595,599,OnPath,,,11,"int node.inspector.anonymous_namespace_65.HttpHandler.OnPath (llhttp_t*,char*,size_t)"
97789,METHOD,node.inspector.anonymous_namespace_38.HttpHandler,TYPE_DECL,"static HttpHandler* From(llhttp_t* parser) {
    return node::ContainerOf(&HttpHandler::parser_, parser);
  }",3,3,inspector_socket.cc,node.inspector.anonymous_namespace_68.HttpHandler.From,,false,601,603,From,,,12,HttpHandler node.inspector.anonymous_namespace_68.HttpHandler.From (llhttp_t*)
97804,METHOD,node.inspector.anonymous_namespace_38.HttpHandler,TYPE_DECL,"static int OnMessageComplete(llhttp_t* parser) {
    // Event needs to be fired after the parser is done.
    HttpHandler* handler = From(parser);
    handler->events_.emplace_back(handler->path_,
                                  parser->upgrade,
                                  parser->method == HTTP_GET,
                                  handler->HeaderValue(""Sec-WebSocket-Key""),
                                  handler->HeaderValue(""Host""));
    handler->path_ = """";
    handler->parsing_value_ = false;
    handler->headers_.clear();
    handler->current_header_ = """";
    return 0;
  }",3,3,inspector_socket.cc,node.inspector.anonymous_namespace_69.HttpHandler.OnMessageComplete,,false,605,618,OnMessageComplete,,,13,int node.inspector.anonymous_namespace_69.HttpHandler.OnMessageComplete (llhttp_t*)
97864,METHOD,node.inspector.anonymous_namespace_38.HttpHandler,TYPE_DECL,"std::string HeaderValue(const std::string& header) const {
    bool header_found = false;
    std::string value;
    for (const auto& header_value : headers_) {
      if (node::StringEqualNoCaseN(header_value.first.data(), header.data(),
                                   header.length())) {
        if (header_found)
          return """";
        value = header_value.second;
        header_found = true;
      }
    }
    return value;
  }",3,3,inspector_socket.cc,node.inspector.anonymous_namespace_72.HttpHandler.HeaderValue,,false,620,633,HeaderValue,,,14,string node.inspector.anonymous_namespace_72.HttpHandler.HeaderValue (ANY)
97913,METHOD,node.inspector.anonymous_namespace_38.HttpHandler,TYPE_DECL,"bool IsAllowedHost(const std::string& host_with_port) const {
    std::string host = TrimPort(host_with_port);
    return host.empty() || IsIPAddress(host)
           || node::StringEqualNoCase(host.data(), ""localhost"");
  }",3,3,inspector_socket.cc,node.inspector.anonymous_namespace_73.HttpHandler.IsAllowedHost,,false,635,639,IsAllowedHost,,,15,bool node.inspector.anonymous_namespace_73.HttpHandler.IsAllowedHost (ANY)
97948,METHOD,inspector_socket.cc:<global>,TYPE_DECL,"ProtocolHandler::ProtocolHandler(InspectorSocket* inspector,
                                 TcpHolder::Pointer tcp)
                                 : inspector_(inspector), tcp_(std::move(tcp)) {
  CHECK_NOT_NULL(tcp_);
  tcp_->SetHandler(this);
}",1,1,inspector_socket.cc,node.inspector.ProtocolHandler.ProtocolHandler,,false,653,658,ProtocolHandler,,,4,"ANY node.inspector.ProtocolHandler.ProtocolHandler (InspectorSocket*,ANY)"
97961,METHOD,inspector_socket.cc:<global>,TYPE_DECL,"int ProtocolHandler::WriteRaw(const std::vector<char>& buffer,
                              uv_write_cb write_cb) {
  return tcp_->WriteRaw(buffer, write_cb);
}",1,1,inspector_socket.cc,node.inspector.ProtocolHandler.WriteRaw,,false,660,663,WriteRaw,,,5,"int node.inspector.ProtocolHandler.WriteRaw (ANY,uv_write_cb)"
97974,METHOD,inspector_socket.cc:<global>,TYPE_DECL,"InspectorSocket::Delegate* ProtocolHandler::delegate() {
  return tcp_->delegate();
}",1,1,inspector_socket.cc,node.inspector.ProtocolHandler.delegate,,false,665,667,delegate,,,6,Delegate node.inspector.ProtocolHandler.delegate ()
97983,METHOD,inspector_socket.cc:<global>,TYPE_DECL,"std::string ProtocolHandler::GetHost() const {
  char ip[INET6_ADDRSTRLEN];
  sockaddr_storage addr;
  int len = sizeof(addr);
  int err = uv_tcp_getsockname(tcp_->tcp(),
                               reinterpret_cast<struct sockaddr*>(&addr),
                               &len);
  if (err != 0)
    return """";
  if (addr.ss_family == AF_INET6) {
    const sockaddr_in6* v6 = reinterpret_cast<const sockaddr_in6*>(&addr);
    err = uv_ip6_name(v6, ip, sizeof(ip));
  } else {
    const sockaddr_in* v4 = reinterpret_cast<const sockaddr_in*>(&addr);
    err = uv_ip4_name(v4, ip, sizeof(ip));
  }
  if (err != 0)
    return """";
  return ip;
}",1,1,inspector_socket.cc,node.inspector.ProtocolHandler.GetHost,,false,669,688,GetHost,,,7,string node.inspector.ProtocolHandler.GetHost ()
98061,METHOD,inspector_socket.cc:<global>,TYPE_DECL,"TcpHolder::TcpHolder(InspectorSocket::DelegatePointer delegate)
                     : tcp_(),
                       delegate_(std::move(delegate)),
                       handler_(nullptr) { }",1,44,inspector_socket.cc,node.inspector.TcpHolder.TcpHolder,,false,691,694,TcpHolder,,,8,ANY node.inspector.TcpHolder.TcpHolder (ANY)
98066,METHOD,inspector_socket.cc:<global>,TYPE_DECL,"TcpHolder::Pointer TcpHolder::Accept(
    uv_stream_t* server,
    InspectorSocket::DelegatePointer delegate) {
  TcpHolder* result = new TcpHolder(std::move(delegate));
  uv_stream_t* tcp = reinterpret_cast<uv_stream_t*>(&result->tcp_);
  int err = uv_tcp_init(server->loop, &result->tcp_);
  if (err == 0) {
    err = uv_accept(server, tcp);
  }
  if (err == 0) {
    err = uv_read_start(tcp, allocate_buffer, OnDataReceivedCb);
  }
  if (err == 0) {
    return TcpHolder::Pointer(result);
  } else {
    delete result;
    return nullptr;
  }
}",1,1,inspector_socket.cc,node.inspector.TcpHolder.Accept,,false,697,715,Accept,,,9,"Pointer node.inspector.TcpHolder.Accept (uv_stream_t*,ANY)"
98140,METHOD,inspector_socket.cc:<global>,TYPE_DECL,"void TcpHolder::SetHandler(ProtocolHandler* handler) {
  handler_ = handler;
}",1,1,inspector_socket.cc,node.inspector.TcpHolder.SetHandler,,false,717,719,SetHandler,,,10,void node.inspector.TcpHolder.SetHandler (ProtocolHandler*)
98148,METHOD,inspector_socket.cc:<global>,TYPE_DECL,"int TcpHolder::WriteRaw(const std::vector<char>& buffer, uv_write_cb write_cb) {
#if DUMP_WRITES
  printf(""%s (%ld bytes):\n"", __FUNCTION__, buffer.size());
  dump_hex(buffer.data(), buffer.size());
  printf(""\n"");
#endif

  // Freed in write_request_cleanup
  WriteRequest* wr = new WriteRequest(handler_, buffer);
  uv_stream_t* stream = reinterpret_cast<uv_stream_t*>(&tcp_);
  int err = uv_write(&wr->req, stream, &wr->buf, 1, write_cb);
  if (err < 0)
    delete wr;
  return err < 0;
}",1,4,inspector_socket.cc,node.inspector.TcpHolder.WriteRaw,,false,721,735,WriteRaw,,,11,"int node.inspector.TcpHolder.WriteRaw (ANY,uv_write_cb)"
98194,METHOD,inspector_socket.cc:<global>,TYPE_DECL,"InspectorSocket::Delegate* TcpHolder::delegate() {
  return delegate_.get();
}",1,1,inspector_socket.cc,node.inspector.TcpHolder.delegate,,false,737,739,delegate,,,12,Delegate node.inspector.TcpHolder.delegate ()
98203,METHOD,inspector_socket.cc:<global>,TYPE_DECL,"void TcpHolder::OnClosed(uv_handle_t* handle) {
  delete From(handle);
}",1,1,inspector_socket.cc,node.inspector.TcpHolder.OnClosed,,false,742,744,OnClosed,,,13,void node.inspector.TcpHolder.OnClosed (uv_handle_t*)
98211,METHOD,inspector_socket.cc:<global>,TYPE_DECL,"void TcpHolder::OnDataReceivedCb(uv_stream_t* tcp, ssize_t nread,
                                 const uv_buf_t* buf) {
#if DUMP_READS
  if (nread >= 0) {
    printf(""%s (%ld bytes)\n"", __FUNCTION__, nread);
    dump_hex(buf->base, nread);
  } else {
    printf(""[%s:%d] %s\n"", __FUNCTION__, __LINE__, uv_err_name(nread));
  }
#endif
  TcpHolder* holder = From(tcp);
  holder->ReclaimUvBuf(buf, nread);
  if (nread < 0 || nread == UV_EOF) {
    holder->handler_->OnEof();
  } else {
    holder->handler_->OnData(&holder->buffer);
  }
}",1,4,inspector_socket.cc,node.inspector.TcpHolder.OnDataReceivedCb,,false,746,763,OnDataReceivedCb,,,14,"void node.inspector.TcpHolder.OnDataReceivedCb (uv_stream_t*,ssize_t,uv_buf_t*)"
98256,METHOD,inspector_socket.cc:<global>,TYPE_DECL,"void TcpHolder::DisconnectAndDispose(TcpHolder* holder) {
  uv_handle_t* handle = reinterpret_cast<uv_handle_t*>(&holder->tcp_);
  uv_close(handle, OnClosed);
}",1,1,inspector_socket.cc,node.inspector.TcpHolder.DisconnectAndDispose,,false,766,769,DisconnectAndDispose,,,15,void node.inspector.TcpHolder.DisconnectAndDispose (TcpHolder*)
98273,METHOD,inspector_socket.cc:<global>,TYPE_DECL,"void TcpHolder::ReclaimUvBuf(const uv_buf_t* buf, ssize_t read) {
  if (read > 0) {
    buffer.insert(buffer.end(), buf->base, buf->base + read);
  }
  delete[] buf->base;
}",1,1,inspector_socket.cc,node.inspector.TcpHolder.ReclaimUvBuf,,false,771,776,ReclaimUvBuf,,,16,"void node.inspector.TcpHolder.ReclaimUvBuf (uv_buf_t*,ssize_t)"
98304,METHOD,inspector_socket.cc:<global>,TYPE_DECL,InspectorSocket::~InspectorSocket() = default;,1,46,inspector_socket.cc,node.inspector.InspectorSocket.~InspectorSocket,,false,778,778,~InspectorSocket,,,17,ANY node.inspector.InspectorSocket.~InspectorSocket ()
98308,METHOD,inspector_socket.cc:<global>,TYPE_DECL,"void InspectorSocket::Shutdown(ProtocolHandler* handler) {
  handler->Shutdown();
}",1,1,inspector_socket.cc,node.inspector.InspectorSocket.Shutdown,,false,781,783,Shutdown,,,18,void node.inspector.InspectorSocket.Shutdown (ProtocolHandler*)
98317,METHOD,inspector_socket.cc:<global>,TYPE_DECL,"InspectorSocket::Pointer InspectorSocket::Accept(uv_stream_t* server,
                                                 DelegatePointer delegate) {
  auto tcp = TcpHolder::Accept(server, std::move(delegate));
  if (tcp) {
    InspectorSocket* inspector = new InspectorSocket();
    inspector->SwitchProtocol(new HttpHandler(inspector, std::move(tcp)));
    return InspectorSocket::Pointer(inspector);
  } else {
    return InspectorSocket::Pointer(nullptr);
  }
}",1,1,inspector_socket.cc,node.inspector.InspectorSocket.Accept,,false,786,796,Accept,,,19,"Pointer node.inspector.InspectorSocket.Accept (uv_stream_t*,DelegatePointer)"
98370,METHOD,inspector_socket.cc:<global>,TYPE_DECL,"void InspectorSocket::AcceptUpgrade(const std::string& ws_key) {
  protocol_handler_->AcceptUpgrade(ws_key);
}",1,1,inspector_socket.cc,node.inspector.InspectorSocket.AcceptUpgrade,,false,798,800,AcceptUpgrade,,,20,void node.inspector.InspectorSocket.AcceptUpgrade (ANY)
98380,METHOD,inspector_socket.cc:<global>,TYPE_DECL,"void InspectorSocket::CancelHandshake() {
  protocol_handler_->CancelHandshake();
}",1,1,inspector_socket.cc,node.inspector.InspectorSocket.CancelHandshake,,false,802,804,CancelHandshake,,,21,void node.inspector.InspectorSocket.CancelHandshake ()
98388,METHOD,inspector_socket.cc:<global>,TYPE_DECL,"std::string InspectorSocket::GetHost() {
  return protocol_handler_->GetHost();
}",1,1,inspector_socket.cc,node.inspector.InspectorSocket.GetHost,,false,806,808,GetHost,,,22,string node.inspector.InspectorSocket.GetHost ()
98397,METHOD,inspector_socket.cc:<global>,TYPE_DECL,"void InspectorSocket::SwitchProtocol(ProtocolHandler* handler) {
  protocol_handler_.reset(std::move(handler));
}",1,1,inspector_socket.cc,node.inspector.InspectorSocket.SwitchProtocol,,false,810,812,SwitchProtocol,,,23,void node.inspector.InspectorSocket.SwitchProtocol (ProtocolHandler*)
98411,METHOD,inspector_socket.cc:<global>,TYPE_DECL,"void InspectorSocket::Write(const char* data, size_t len) {
  protocol_handler_->Write(std::vector<char>(data, data + len));
}",1,1,inspector_socket.cc,node.inspector.InspectorSocket.Write,,false,814,816,Write,,,24,"void node.inspector.InspectorSocket.Write (char*,size_t)"
98440,METHOD,inspector_socket.hpp:<global>,TYPE_DECL,<global>,1,34,inspector_socket.hpp,inspector_socket.hpp:<global>,,false,1,60,<global>,,,1,
98465,METHOD,inspector_socket_server.cc:<global>,TYPE_DECL,<global>,1,41,inspector_socket_server.hpp,inspector_socket_server.cc:<global>,,false,1,562,<global>,,,1,
98469,METHOD,inspector_socket_server.cc:<global>,TYPE_DECL,"std::string FormatWsAddress(const std::string& host, int port,
                            const std::string& target_id,
                            bool include_protocol);",13,50,inspector_socket_server.cc,node.inspector.FormatWsAddress,,false,18,20,FormatWsAddress,,,1,"ANY node.inspector.FormatWsAddress (ANY,int,ANY,bool)"
98482,METHOD,inspector_socket_server.cc:<global>,TYPE_DECL,"void Escape(std::string* string) {
  for (char& c : *string) {
    c = (c == '\""' || c == '\\') ? '_' : c;
  }
}",1,1,inspector_socket_server.cc,node.inspector.anonymous_namespace_1.Escape,,false,27,31,Escape,,,3,void node.inspector.anonymous_namespace_1.Escape (ANY*)
98504,METHOD,inspector_socket_server.cc:<global>,TYPE_DECL,"std::string FormatHostPort(const std::string& host, int port) {
  // Host is valid (socket was bound) so colon means it's a v6 IP address
  bool v6 = host.find(':') != std::string::npos;
  std::ostringstream url;
  if (v6) {
    url << '[';
  }
  url << host;
  if (v6) {
    url << ']';
  }
  url << ':' << port;
  return url.str();
}",1,1,inspector_socket_server.cc,node.inspector.anonymous_namespace_2.FormatHostPort,,false,33,46,FormatHostPort,,,4,"string node.inspector.anonymous_namespace_2.FormatHostPort (ANY,int)"
98550,METHOD,inspector_socket_server.cc:<global>,TYPE_DECL,"std::string FormatAddress(const std::string& host,
                          const std::string& target_id,
                          bool include_protocol) {
  std::ostringstream url;
  if (include_protocol)
    url << ""ws://"";
  url << host << '/' << target_id;
  return url.str();
}",1,1,inspector_socket_server.cc,node.inspector.anonymous_namespace_3.FormatAddress,,false,48,56,FormatAddress,,,5,"string node.inspector.anonymous_namespace_3.FormatAddress (ANY,ANY,bool)"
98576,METHOD,inspector_socket_server.cc:<global>,TYPE_DECL,"std::string MapToString(const std::map<std::string, std::string>& object) {
  bool first = true;
  std::ostringstream json;
  json << ""{\n"";
  for (const auto& name_value : object) {
    if (!first)
      json << "",\n"";
    first = false;
    json << ""  \"""" << name_value.first << ""\"": \"""";
    json << name_value.second << ""\"""";
  }
  json << ""\n} "";
  return json.str();
}",1,1,inspector_socket_server.cc,node.inspector.anonymous_namespace_4.MapToString,,false,58,71,MapToString,,,6,string node.inspector.anonymous_namespace_4.MapToString (ANY)
98627,METHOD,inspector_socket_server.cc:<global>,TYPE_DECL,"std::string MapsToString(
    const std::vector<std::map<std::string, std::string>>& array) {
  bool first = true;
  std::ostringstream json;
  json << ""[ "";
  for (const auto& object : array) {
    if (!first)
      json << "", "";
    first = false;
    json << MapToString(object);
  }
  json << ""]\n\n"";
  return json.str();
}",1,1,inspector_socket_server.cc,node.inspector.anonymous_namespace_5.MapsToString,,false,73,86,MapsToString,,,7,string node.inspector.anonymous_namespace_5.MapsToString (ANY)
98666,METHOD,inspector_socket_server.cc:<global>,TYPE_DECL,"const char* MatchPathSegment(const char* path, const char* expected) {
  size_t len = strlen(expected);
  if (StringEqualNoCaseN(path, expected, len)) {
    if (path[len] == '/') return path + len + 1;
    if (path[len] == '\0') return path + len;
  }
  return nullptr;
}",1,1,inspector_socket_server.cc,node.inspector.anonymous_namespace_6.MatchPathSegment,,false,88,95,MatchPathSegment,,,8,"const char* node.inspector.anonymous_namespace_6.MatchPathSegment (char*,char*)"
98709,METHOD,inspector_socket_server.cc:<global>,TYPE_DECL,"void SendHttpResponse(InspectorSocket* socket,
                      const std::string& response,
                      int code) {
  const char HEADERS[] = ""HTTP/1.0 %d OK\r\n""
                         ""Content-Type: application/json; charset=UTF-8\r\n""
                         ""Cache-Control: no-cache\r\n""
                         ""Content-Length: %zu\r\n""
                         ""\r\n"";
  char header[sizeof(HEADERS) + 20];
  int header_len = snprintf(header,
                            sizeof(header),
                            HEADERS,
                            code,
                            response.size());
  socket->Write(header, header_len);
  socket->Write(response.data(), response.size());
}",1,1,inspector_socket_server.cc,node.inspector.anonymous_namespace_7.SendHttpResponse,,false,97,113,SendHttpResponse,,,9,"void node.inspector.anonymous_namespace_7.SendHttpResponse (InspectorSocket*,ANY,int)"
98752,METHOD,inspector_socket_server.cc:<global>,TYPE_DECL,"void SendVersionResponse(InspectorSocket* socket) {
  std::map<std::string, std::string> response;
  response[""Browser""] = ""node.js/"" NODE_VERSION;
  response[""Protocol-Version""] = ""1.1"";
  SendHttpResponse(socket, MapToString(response), 200);
}",1,35,inspector_socket_server.cc,node.inspector.anonymous_namespace_8.SendVersionResponse,,false,115,120,SendVersionResponse,,,10,void node.inspector.anonymous_namespace_8.SendVersionResponse (InspectorSocket*)
98785,METHOD,inspector_socket_server.cc:<global>,TYPE_DECL,"void SendHttpNotFound(InspectorSocket* socket) {
  SendHttpResponse(socket, """", 404);
}",1,1,inspector_socket_server.cc,node.inspector.anonymous_namespace_9.SendHttpNotFound,,false,122,124,SendHttpNotFound,,,11,void node.inspector.anonymous_namespace_9.SendHttpNotFound (InspectorSocket*)
98794,METHOD,inspector_socket_server.cc:<global>,TYPE_DECL,"void SendProtocolJson(InspectorSocket* socket) {
  z_stream strm;
  strm.zalloc = Z_NULL;
  strm.zfree = Z_NULL;
  strm.opaque = Z_NULL;
  CHECK_EQ(Z_OK, inflateInit(&strm));
  static const size_t kDecompressedSize =
      PROTOCOL_JSON[0] * 0x10000u +
      PROTOCOL_JSON[1] * 0x100u +
      PROTOCOL_JSON[2];
  strm.next_in = const_cast<uint8_t*>(PROTOCOL_JSON + 3);
  strm.avail_in = sizeof(PROTOCOL_JSON) - 3;
  std::string data(kDecompressedSize, '\0');
  strm.next_out = reinterpret_cast<Byte*>(data.data());
  strm.avail_out = data.size();
  CHECK_EQ(Z_STREAM_END, inflate(&strm, Z_FINISH));
  CHECK_EQ(0, strm.avail_out);
  CHECK_EQ(Z_OK, inflateEnd(&strm));
  SendHttpResponse(socket, data, 200);
}",1,1,inspector_socket_server.cc,node.inspector.anonymous_namespace_10.SendProtocolJson,,false,126,145,SendProtocolJson,,,12,void node.inspector.anonymous_namespace_10.SendProtocolJson (InspectorSocket*)
98897,METHOD,inspector_socket_server.cc:<global>,TYPE_DECL,"std::string FormatWsAddress(const std::string& host, int port,
                            const std::string& target_id,
                            bool include_protocol) {
  return FormatAddress(FormatHostPort(host, port), target_id, include_protocol);
}",1,1,inspector_socket_server.cc,node.inspector.FormatWsAddress,,false,148,152,FormatWsAddress,,,3,"string node.inspector.FormatWsAddress (ANY,int,ANY,bool)"
98913,METHOD,node.inspector.SocketSession,TYPE_DECL,"SocketSession(InspectorSocketServer* server, int id, int server_port);",3,71,inspector_socket_server.cc,node.inspector.SocketSession.SocketSession,,false,156,156,SocketSession,,,1,"ANY node.inspector.SocketSession.SocketSession (InspectorSocketServer*,int,int)"
98920,METHOD,node.inspector.SocketSession,TYPE_DECL,"void Close() {
    ws_socket_.reset();
  }",3,3,inspector_socket_server.cc,node.inspector.SocketSession.Close,,false,157,159,Close,,,2,void node.inspector.SocketSession.Close ()
98928,METHOD,node.inspector.SocketSession,TYPE_DECL,void Send(const std::string& message);,8,39,inspector_socket_server.cc,node.inspector.SocketSession.Send,,false,160,160,Send,,,3,void node.inspector.SocketSession.Send (ANY)
98933,METHOD,node.inspector.SocketSession,TYPE_DECL,"void Own(InspectorSocket::Pointer ws_socket) {
    ws_socket_ = std::move(ws_socket);
  }",3,3,inspector_socket_server.cc,node.inspector.SocketSession.Own,,false,161,163,Own,,,4,void node.inspector.SocketSession.Own (ANY)
98945,METHOD,node.inspector.SocketSession,TYPE_DECL,int id() const { return id_; },3,32,inspector_socket_server.cc,node.inspector.SocketSession.id,,false,164,164,id,,,5,int node.inspector.SocketSession.id ()
98951,METHOD,node.inspector.SocketSession,TYPE_DECL,"int server_port() {
    return server_port_;
  }",3,3,inspector_socket_server.cc,node.inspector.SocketSession.server_port,,false,165,167,server_port,,,6,int node.inspector.SocketSession.server_port ()
98957,METHOD,node.inspector.SocketSession,TYPE_DECL,"InspectorSocket* ws_socket() {
    return ws_socket_.get();
  }",3,3,inspector_socket_server.cc,node.inspector.SocketSession.ws_socket,,false,168,170,ws_socket,,,7,InspectorSocket node.inspector.SocketSession.ws_socket ()
98966,METHOD,node.inspector.SocketSession,TYPE_DECL,"void Accept(const std::string& ws_key) {
    ws_socket_->AcceptUpgrade(ws_key);
  }",3,3,inspector_socket_server.cc,node.inspector.SocketSession.Accept,,false,171,173,Accept,,,8,void node.inspector.SocketSession.Accept (ANY)
98976,METHOD,node.inspector.SocketSession,TYPE_DECL,"void Decline() {
    ws_socket_->CancelHandshake();
  }",3,3,inspector_socket_server.cc,node.inspector.SocketSession.Decline,,false,174,176,Decline,,,9,void node.inspector.SocketSession.Decline ()
98985,METHOD,node.inspector.SocketSession.Delegate,TYPE_DECL,"Delegate(InspectorSocketServer* server, int session_id)
             : server_(server), session_id_(session_id) { }",5,59,inspector_socket_server.cc,node.inspector.SocketSession.Delegate.Delegate,,false,180,181,Delegate,,,1,"ANY node.inspector.SocketSession.Delegate.Delegate (InspectorSocketServer*,int)"
98991,METHOD,node.inspector.SocketSession.Delegate,TYPE_DECL,"~Delegate() override {
      server_->SessionTerminated(session_id_);
    }",5,5,inspector_socket_server.cc,node.inspector.SocketSession.Delegate.~Delegate,,false,182,184,~Delegate,,,2,ANY node.inspector.SocketSession.Delegate.~Delegate ()
99000,METHOD,node.inspector.SocketSession.Delegate,TYPE_DECL,"void OnHttpGet(const std::string& host, const std::string& path) override;",10,77,inspector_socket_server.cc,node.inspector.SocketSession.Delegate.OnHttpGet,,false,185,185,OnHttpGet,,,3,"void node.inspector.SocketSession.Delegate.OnHttpGet (ANY,ANY)"
99006,METHOD,node.inspector.SocketSession.Delegate,TYPE_DECL,"void OnSocketUpgrade(const std::string& host, const std::string& path,
                         const std::string& ws_key) override;",10,60,inspector_socket_server.cc,node.inspector.SocketSession.Delegate.OnSocketUpgrade,,false,186,187,OnSocketUpgrade,,,4,"void node.inspector.SocketSession.Delegate.OnSocketUpgrade (ANY,ANY,ANY)"
99013,METHOD,node.inspector.SocketSession.Delegate,TYPE_DECL,void OnWsFrame(const std::vector<char>& data) override;,10,58,inspector_socket_server.cc,node.inspector.SocketSession.Delegate.OnWsFrame,,false,188,188,OnWsFrame,,,5,void node.inspector.SocketSession.Delegate.OnWsFrame (ANY)
99018,METHOD,node.inspector.SocketSession.Delegate,TYPE_DECL,"SocketSession* Session() {
      return server_->Session(session_id_);
    }",5,5,inspector_socket_server.cc,node.inspector.SocketSession.Delegate.Session,,false,191,193,Session,,,6,SocketSession node.inspector.SocketSession.Delegate.Session ()
99034,METHOD,node.inspector.ServerSocket,TYPE_DECL,"explicit ServerSocket(InspectorSocketServer* server)
                        : tcp_socket_(uv_tcp_t()), server_(server) {}",3,69,inspector_socket_server.cc,node.inspector.ServerSocket.ServerSocket,,false,207,208,ServerSocket,,,1,ANY node.inspector.ServerSocket.ServerSocket (InspectorSocketServer*)
99039,METHOD,node.inspector.ServerSocket,TYPE_DECL,"int Listen(sockaddr* addr, uv_loop_t* loop);",7,45,inspector_socket_server.cc,node.inspector.ServerSocket.Listen,,false,209,209,Listen,,,2,"int node.inspector.ServerSocket.Listen (sockaddr*,uv_loop_t*)"
99045,METHOD,node.inspector.ServerSocket,TYPE_DECL,"void Close() {
    uv_close(reinterpret_cast<uv_handle_t*>(&tcp_socket_), FreeOnCloseCallback);
  }",3,3,inspector_socket_server.cc,node.inspector.ServerSocket.Close,,false,210,212,Close,,,3,void node.inspector.ServerSocket.Close ()
99055,METHOD,node.inspector.ServerSocket,TYPE_DECL,int port() const { return port_; },3,36,inspector_socket_server.cc,node.inspector.ServerSocket.port,,false,213,213,port,,,4,int node.inspector.ServerSocket.port ()
99061,METHOD,node.inspector.ServerSocket,TYPE_DECL,"static ServerSocket* FromTcpSocket(UvHandle* socket) {
    return node::ContainerOf(&ServerSocket::tcp_socket_,
                             reinterpret_cast<uv_tcp_t*>(socket));
  }",3,3,inspector_socket_server.cc,node.inspector.ServerSocket.FromTcpSocket,,false,217,220,FromTcpSocket,,,5,ServerSocket node.inspector.ServerSocket.FromTcpSocket<UvHandle> (UvHandle*)
99078,METHOD,node.inspector.ServerSocket,TYPE_DECL,"static void SocketConnectedCallback(uv_stream_t* tcp_socket, int status);",15,74,inspector_socket_server.cc,node.inspector.ServerSocket.SocketConnectedCallback,,false,221,221,SocketConnectedCallback,,,6,"void node.inspector.ServerSocket.SocketConnectedCallback (uv_stream_t*,int)"
99084,METHOD,node.inspector.ServerSocket,TYPE_DECL,"static void FreeOnCloseCallback(uv_handle_t* tcp_socket_) {
    delete FromTcpSocket(tcp_socket_);
  }",3,3,inspector_socket_server.cc,node.inspector.ServerSocket.FreeOnCloseCallback,,false,222,224,FreeOnCloseCallback,,,7,void node.inspector.ServerSocket.FreeOnCloseCallback (uv_handle_t*)
99092,METHOD,node.inspector.ServerSocket,TYPE_DECL,int DetectPort();,7,18,inspector_socket_server.cc,node.inspector.ServerSocket.DetectPort,,false,225,225,DetectPort,,,8,int node.inspector.ServerSocket.DetectPort ()
99096,METHOD,node.inspector.ServerSocket,TYPE_DECL,~ServerSocket() = default;,3,28,inspector_socket_server.cc,node.inspector.ServerSocket.~ServerSocket,,false,226,226,~ServerSocket,,,9,ANY node.inspector.ServerSocket.~ServerSocket ()
99103,METHOD,<empty>,<empty>,<empty>,1,,inspector_socket_server.cc,node.inspector.ServerSocket:<clinit>,,false,205,,<clinit>,,,13,
99111,METHOD,inspector_socket_server.cc:<global>,TYPE_DECL,"void PrintDebuggerReadyMessage(
    const std::string& host,
    const std::vector<InspectorSocketServer::ServerSocketPtr>& server_sockets,
    const std::vector<std::string>& ids,
    const char* verb,
    bool publish_uid_stderr,
    FILE* out) {
  if (!publish_uid_stderr || out == nullptr) {
    return;
  }
  for (const auto& server_socket : server_sockets) {
    for (const std::string& id : ids) {
      fprintf(out, ""Debugger %s on %s\n"",
              verb,
              FormatWsAddress(host, server_socket->port(), id, true).c_str());
    }
  }
  fprintf(out, ""For help, see: %s\n"",
          ""https://nodejs.org/en/docs/inspector"");
  fflush(out);
}",1,1,inspector_socket_server.cc,node.inspector.PrintDebuggerReadyMessage,,false,233,253,PrintDebuggerReadyMessage,,,6,"void node.inspector.PrintDebuggerReadyMessage (ANY,ANY,ANY,char*,bool,FILE*)"
99159,METHOD,inspector_socket_server.cc:<global>,TYPE_DECL,"InspectorSocketServer::InspectorSocketServer(
    std::unique_ptr<SocketServerDelegate> delegate, uv_loop_t* loop,
    const std::string& host, int port,
    const InspectPublishUid& inspect_publish_uid, FILE* out)
    : loop_(loop),
      delegate_(std::move(delegate)),
      host_(host),
      port_(port),
      inspect_publish_uid_(inspect_publish_uid),
      next_session_id_(0),
      out_(out) {
  delegate_->AssignServer(this);
  state_ = ServerState::kNew;
}",1,1,inspector_socket_server.cc,node.inspector.InspectorSocketServer.InspectorSocketServer,,false,255,268,InspectorSocketServer,,,7,"ANY node.inspector.InspectorSocketServer.InspectorSocketServer (ANY,uv_loop_t*,ANY,int,InspectPublishUid,FILE*)"
99179,METHOD,inspector_socket_server.cc:<global>,TYPE_DECL,InspectorSocketServer::~InspectorSocketServer() = default;,1,58,inspector_socket_server.cc,node.inspector.InspectorSocketServer.~InspectorSocketServer,,false,270,270,~InspectorSocketServer,,,8,ANY node.inspector.InspectorSocketServer.~InspectorSocketServer ()
99183,METHOD,inspector_socket_server.cc:<global>,TYPE_DECL,"SocketSession* InspectorSocketServer::Session(int session_id) {
  auto it = connected_sessions_.find(session_id);
  return it == connected_sessions_.end() ? nullptr : it->second.second.get();
}",1,1,inspector_socket_server.cc,node.inspector.InspectorSocketServer.Session,,false,272,275,Session,,,9,SocketSession node.inspector.InspectorSocketServer.Session (int)
99213,METHOD,inspector_socket_server.cc:<global>,TYPE_DECL,"void InspectorSocketServer::SessionStarted(int session_id,
                                           const std::string& id,
                                           const std::string& ws_key) {
  SocketSession* session = Session(session_id);
  if (!TargetExists(id)) {
    session->Decline();
    return;
  }
  connected_sessions_[session_id].first = id;
  session->Accept(ws_key);
  delegate_->StartSession(session_id, id);
}",1,1,inspector_socket_server.cc,node.inspector.InspectorSocketServer.SessionStarted,,false,277,288,SessionStarted,,,10,"void node.inspector.InspectorSocketServer.SessionStarted (int,ANY,ANY)"
99253,METHOD,inspector_socket_server.cc:<global>,TYPE_DECL,"void InspectorSocketServer::SessionTerminated(int session_id) {
  if (Session(session_id) == nullptr) {
    return;
  }
  bool was_attached = connected_sessions_[session_id].first != """";
  if (was_attached) {
    delegate_->EndSession(session_id);
  }
  connected_sessions_.erase(session_id);
  if (connected_sessions_.empty()) {
    if (was_attached && state_ == ServerState::kRunning
        && !server_sockets_.empty()) {
      PrintDebuggerReadyMessage(host_,
                                server_sockets_,
                                delegate_->GetTargetIds(),
                                ""ending"",
                                inspect_publish_uid_.console,
                                out_);
    }
    if (state_ == ServerState::kStopped) {
      delegate_.reset();
    }
  }
}",1,1,inspector_socket_server.cc,node.inspector.InspectorSocketServer.SessionTerminated,,false,290,313,SessionTerminated,,,11,void node.inspector.InspectorSocketServer.SessionTerminated (int)
99332,METHOD,inspector_socket_server.cc:<global>,TYPE_DECL,"bool InspectorSocketServer::HandleGetRequest(int session_id,
                                             const std::string& host,
                                             const std::string& path) {
  SocketSession* session = Session(session_id);
  InspectorSocket* socket = session->ws_socket();
  if (!inspect_publish_uid_.http) {
    SendHttpNotFound(socket);
    return true;
  }
  const char* command = MatchPathSegment(path.c_str(), ""/json"");
  if (command == nullptr)
    return false;

  if (MatchPathSegment(command, ""list"") || command[0] == '\0') {
    SendListResponse(socket, host, session);
    return true;
  } else if (MatchPathSegment(command, ""protocol"")) {
    SendProtocolJson(socket);
    return true;
  } else if (MatchPathSegment(command, ""version"")) {
    SendVersionResponse(socket);
    return true;
  }
  return false;
}",1,1,inspector_socket_server.cc,node.inspector.InspectorSocketServer.HandleGetRequest,,false,315,339,HandleGetRequest,,,12,"bool node.inspector.InspectorSocketServer.HandleGetRequest (int,ANY,ANY)"
99418,METHOD,inspector_socket_server.cc:<global>,TYPE_DECL,"void InspectorSocketServer::SendListResponse(InspectorSocket* socket,
                                             const std::string& host,
                                             SocketSession* session) {
  std::vector<std::map<std::string, std::string>> response;
  for (const std::string& id : delegate_->GetTargetIds()) {
    response.push_back(std::map<std::string, std::string>());
    std::map<std::string, std::string>& target_map = response.back();
    target_map[""description""] = ""node.js instance"";
    target_map[""faviconUrl""] =
                        ""https://nodejs.org/static/images/favicons/favicon.ico"";
    target_map[""id""] = id;
    target_map[""title""] = delegate_->GetTargetTitle(id);
    Escape(&target_map[""title""]);
    target_map[""type""] = ""node"";
    // This attribute value is a ""best effort"" URL that is passed as a JSON
    // string. It is not guaranteed to resolve to a valid resource.
    target_map[""url""] = delegate_->GetTargetUrl(id);
    Escape(&target_map...",1,1,inspector_socket_server.cc,node.inspector.InspectorSocketServer.SendListResponse,,false,341,374,SendListResponse,,,13,"void node.inspector.InspectorSocketServer.SendListResponse (InspectorSocket*,ANY,SocketSession*)"
99559,METHOD,inspector_socket_server.cc:<global>,TYPE_DECL,"std::string InspectorSocketServer::GetFrontendURL(bool is_compat,
    const std::string &formatted_address) {
  std::ostringstream frontend_url;
  frontend_url << ""devtools://devtools/bundled/"";
  frontend_url << (is_compat ? ""inspector"" : ""js_app"");
  frontend_url << "".html?experiments=true&v8only=true&ws="";
  frontend_url << formatted_address;
  return frontend_url.str();
}",1,1,inspector_socket_server.cc,node.inspector.InspectorSocketServer.GetFrontendURL,,false,376,384,GetFrontendURL,,,14,"string node.inspector.InspectorSocketServer.GetFrontendURL (bool,ANY)"
99586,METHOD,inspector_socket_server.cc:<global>,TYPE_DECL,"bool InspectorSocketServer::Start() {
  CHECK_NOT_NULL(delegate_);
  CHECK_EQ(state_, ServerState::kNew);
  std::unique_ptr<SocketServerDelegate> delegate_holder;
  // We will return it if startup is successful
  delegate_.swap(delegate_holder);
  struct addrinfo hints;
  memset(&hints, 0, sizeof(hints));
  hints.ai_flags = AI_NUMERICSERV;
  hints.ai_socktype = SOCK_STREAM;
  uv_getaddrinfo_t req;
  const std::string port_string = std::to_string(port_);
  int err = uv_getaddrinfo(loop_, &req, nullptr, host_.c_str(),
                           port_string.c_str(), &hints);
  if (err < 0) {
    if (out_ != nullptr) {
      fprintf(out_, ""Unable to resolve \""%s\"": %s\n"", host_.c_str(),
              uv_strerror(err));
    }
    return false;
  }
  for (addrinfo* address = req.addrinfo; address != nullptr;
       address = address->ai_next) {
    auto server_socket = ServerSocketPtr(new ServerSocket(this));
    err = server_socket->Listen(address->ai_addr, loop_);
    if (err == 0)
    ...",1,1,inspector_socket_server.cc,node.inspector.InspectorSocketServer.Start,,false,386,435,Start,,,15,bool node.inspector.InspectorSocketServer.Start ()
99773,METHOD,inspector_socket_server.cc:<global>,TYPE_DECL,"void InspectorSocketServer::Stop() {
  if (state_ == ServerState::kStopped)
    return;
  CHECK_EQ(state_, ServerState::kRunning);
  state_ = ServerState::kStopped;
  server_sockets_.clear();
  if (done())
    delegate_.reset();
}",1,1,inspector_socket_server.cc,node.inspector.InspectorSocketServer.Stop,,false,437,445,Stop,,,16,void node.inspector.InspectorSocketServer.Stop ()
99806,METHOD,inspector_socket_server.cc:<global>,TYPE_DECL,"void InspectorSocketServer::TerminateConnections() {
  for (const auto& key_value : connected_sessions_)
    key_value.second.second->Close();
}",1,1,inspector_socket_server.cc,node.inspector.InspectorSocketServer.TerminateConnections,,false,447,450,TerminateConnections,,,17,void node.inspector.InspectorSocketServer.TerminateConnections ()
99821,METHOD,inspector_socket_server.cc:<global>,TYPE_DECL,"bool InspectorSocketServer::TargetExists(const std::string& id) {
  const std::vector<std::string>& target_ids = delegate_->GetTargetIds();
  const auto& found = std::find(target_ids.begin(), target_ids.end(), id);
  return found != target_ids.end();
}",1,1,inspector_socket_server.cc,node.inspector.InspectorSocketServer.TargetExists,,false,452,456,TargetExists,,,18,bool node.inspector.InspectorSocketServer.TargetExists (ANY)
99856,METHOD,inspector_socket_server.cc:<global>,TYPE_DECL,"int InspectorSocketServer::Port() const {
  if (!server_sockets_.empty()) {
    return server_sockets_[0]->port();
  }
  return port_;
}",1,1,inspector_socket_server.cc,node.inspector.InspectorSocketServer.Port,,false,458,463,Port,,,19,int node.inspector.InspectorSocketServer.Port ()
99876,METHOD,inspector_socket_server.cc:<global>,TYPE_DECL,"void InspectorSocketServer::Accept(int server_port,
                                   uv_stream_t* server_socket) {
  std::unique_ptr<SocketSession> session(
      new SocketSession(this, next_session_id_++, server_port));

  InspectorSocket::DelegatePointer delegate =
      InspectorSocket::DelegatePointer(
          new SocketSession::Delegate(this, session->id()));

  InspectorSocket::Pointer inspector =
      InspectorSocket::Accept(server_socket, std::move(delegate));
  if (inspector) {
    session->Own(std::move(inspector));
    connected_sessions_[session->id()].second = std::move(session);
  }
}",1,1,inspector_socket_server.cc,node.inspector.InspectorSocketServer.Accept,,false,465,480,Accept,,,20,"void node.inspector.InspectorSocketServer.Accept (int,uv_stream_t*)"
99948,METHOD,inspector_socket_server.cc:<global>,TYPE_DECL,"void InspectorSocketServer::Send(int session_id, const std::string& message) {
  SocketSession* session = Session(session_id);
  if (session != nullptr) {
    session->Send(message);
  }
}",1,1,inspector_socket_server.cc,node.inspector.InspectorSocketServer.Send,,false,482,487,Send,,,21,"void node.inspector.InspectorSocketServer.Send (int,ANY)"
99969,METHOD,inspector_socket_server.cc:<global>,TYPE_DECL,"void InspectorSocketServer::CloseServerSocket(ServerSocket* server) {
  server->Close();
}",1,1,inspector_socket_server.cc,node.inspector.InspectorSocketServer.CloseServerSocket,,false,489,491,CloseServerSocket,,,22,void node.inspector.InspectorSocketServer.CloseServerSocket (ServerSocket*)
99978,METHOD,inspector_socket_server.cc:<global>,TYPE_DECL,"SocketSession::SocketSession(InspectorSocketServer* server, int id,
                             int server_port)
    : id_(id), server_port_(server_port) {}",1,43,inspector_socket_server.cc,node.inspector.SocketSession.SocketSession,,false,494,496,SocketSession,,,23,"ANY node.inspector.SocketSession.SocketSession (InspectorSocketServer*,int,int)"
99985,METHOD,inspector_socket_server.cc:<global>,TYPE_DECL,"void SocketSession::Send(const std::string& message) {
  ws_socket_->Write(message.data(), message.length());
}",1,1,inspector_socket_server.cc,node.inspector.SocketSession.Send,,false,498,500,Send,,,24,void node.inspector.SocketSession.Send (ANY)
100002,METHOD,inspector_socket_server.cc:<global>,TYPE_DECL,"void SocketSession::Delegate::OnHttpGet(const std::string& host,
                                        const std::string& path) {
  if (!server_->HandleGetRequest(session_id_, host, path))
    Session()->ws_socket()->CancelHandshake();
}",1,1,inspector_socket_server.cc,node.inspector.SocketSession.Delegate.OnHttpGet,,false,502,506,OnHttpGet,,,25,"void node.inspector.SocketSession.Delegate.OnHttpGet (ANY,ANY)"
100025,METHOD,inspector_socket_server.cc:<global>,TYPE_DECL,"void SocketSession::Delegate::OnSocketUpgrade(const std::string& host,
                                              const std::string& path,
                                              const std::string& ws_key) {
  std::string id = path.empty() ? path : path.substr(1);
  server_->SessionStarted(session_id_, id, ws_key);
}",1,1,inspector_socket_server.cc,node.inspector.SocketSession.Delegate.OnSocketUpgrade,,false,508,513,OnSocketUpgrade,,,26,"void node.inspector.SocketSession.Delegate.OnSocketUpgrade (ANY,ANY,ANY)"
100053,METHOD,inspector_socket_server.cc:<global>,TYPE_DECL,"void SocketSession::Delegate::OnWsFrame(const std::vector<char>& data) {
  server_->MessageReceived(session_id_,
                           std::string(data.data(), data.size()));
}",1,1,inspector_socket_server.cc,node.inspector.SocketSession.Delegate.OnWsFrame,,false,515,518,OnWsFrame,,,27,void node.inspector.SocketSession.Delegate.OnWsFrame (ANY)
100075,METHOD,inspector_socket_server.cc:<global>,TYPE_DECL,"int ServerSocket::DetectPort() {
  sockaddr_storage addr;
  int len = sizeof(addr);
  int err = uv_tcp_getsockname(&tcp_socket_,
                               reinterpret_cast<struct sockaddr*>(&addr), &len);
  if (err != 0)
    return err;
  int port;
  if (addr.ss_family == AF_INET6)
    port = reinterpret_cast<const sockaddr_in6*>(&addr)->sin6_port;
  else
    port = reinterpret_cast<const sockaddr_in*>(&addr)->sin_port;
  port_ = ntohs(port);
  return err;
}",1,1,inspector_socket_server.cc,node.inspector.ServerSocket.DetectPort,,false,521,535,DetectPort,,,28,int node.inspector.ServerSocket.DetectPort ()
100136,METHOD,inspector_socket_server.cc:<global>,TYPE_DECL,"int ServerSocket::Listen(sockaddr* addr, uv_loop_t* loop) {
  uv_tcp_t* server = &tcp_socket_;
  CHECK_EQ(0, uv_tcp_init(loop, server));
  int err = uv_tcp_bind(server, addr, 0);
  if (err == 0) {
    // 511 is the value used by a 'net' module by default
    err = uv_listen(reinterpret_cast<uv_stream_t*>(server), 511,
                    ServerSocket::SocketConnectedCallback);
  }
  if (err == 0) {
    err = DetectPort();
  }
  return err;
}",1,1,inspector_socket_server.cc,node.inspector.ServerSocket.Listen,,false,537,550,Listen,,,29,"int node.inspector.ServerSocket.Listen (sockaddr*,uv_loop_t*)"
100184,METHOD,inspector_socket_server.cc:<global>,TYPE_DECL,"void ServerSocket::SocketConnectedCallback(uv_stream_t* tcp_socket,
                                           int status) {
  if (status == 0) {
    ServerSocket* server_socket = ServerSocket::FromTcpSocket(tcp_socket);
    // Memory is freed when the socket closes.
    server_socket->server_->Accept(server_socket->port_, tcp_socket);
  }
}",1,1,inspector_socket_server.cc,node.inspector.ServerSocket.SocketConnectedCallback,,false,553,560,SocketConnectedCallback,,,30,"void node.inspector.ServerSocket.SocketConnectedCallback (uv_stream_t*,int)"
100228,METHOD,inspector_socket_server.hpp:<global>,TYPE_DECL,<global>,1,41,inspector_socket_server.hpp,inspector_socket_server.hpp:<global>,,false,1,110,<global>,,,1,
100239,METHOD,js_native_api.hpp:<global>,TYPE_DECL,<global>,1,1,js_native_api.hpp,js_native_api.hpp:<global>,,false,1,591,<global>,,,1,
100241,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, const napi_extended_error_info * *);",1,79,js_native_api.hpp,napi_get_last_error_info,,false,53,53,napi_get_last_error_info,,,1,"napi_status napi_get_last_error_info (napi_env,napi_extended_error_info**)"
100247,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value *);",36,73,js_native_api.hpp,napi_get_undefined,,false,56,57,napi_get_undefined,,,2,"napi_status napi_get_undefined (napi_env,napi_value*)"
100253,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value *);",36,68,js_native_api.hpp,napi_get_null,,false,58,59,napi_get_null,,,3,"napi_status napi_get_null (napi_env,napi_value*)"
100259,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value *);",36,70,js_native_api.hpp,napi_get_global,,false,60,61,napi_get_global,,,4,"napi_status napi_get_global (napi_env,napi_value*)"
100265,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, bool, napi_value *);",36,71,js_native_api.hpp,napi_get_boolean,,false,62,64,napi_get_boolean,,,5,"napi_status napi_get_boolean (napi_env,bool,napi_value*)"
100272,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value *);",36,73,js_native_api.hpp,napi_create_object,,false,67,68,napi_create_object,,,6,"napi_status napi_create_object (napi_env,napi_value*)"
100278,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value *);",36,72,js_native_api.hpp,napi_create_array,,false,69,70,napi_create_array,,,7,"napi_status napi_create_array (napi_env,napi_value*)"
100284,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, size_t, napi_value *);",1,78,js_native_api.hpp,napi_create_array_with_length,,false,72,72,napi_create_array_with_length,,,8,"napi_status napi_create_array_with_length (napi_env,size_t,napi_value*)"
100291,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, double, napi_value *);",36,73,js_native_api.hpp,napi_create_double,,false,73,75,napi_create_double,,,9,"napi_status napi_create_double (napi_env,double,napi_value*)"
100298,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, int32_t, napi_value *);",36,72,js_native_api.hpp,napi_create_int32,,false,76,78,napi_create_int32,,,10,"napi_status napi_create_int32 (napi_env,int32_t,napi_value*)"
100305,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, uint32_t, napi_value *);",36,73,js_native_api.hpp,napi_create_uint32,,false,79,81,napi_create_uint32,,,11,"napi_status napi_create_uint32 (napi_env,uint32_t,napi_value*)"
100312,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, int64_t, napi_value *);",36,72,js_native_api.hpp,napi_create_int64,,false,82,84,napi_create_int64,,,12,"napi_status napi_create_int64 (napi_env,int64_t,napi_value*)"
100319,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, const char *, size_t, napi_value *);",36,69,js_native_api.hpp,napi_create_string_latin1,,false,85,86,napi_create_string_latin1,,,13,"napi_status napi_create_string_latin1 (napi_env,char*,size_t,napi_value*)"
100327,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, const char *, size_t, napi_value *);",36,78,js_native_api.hpp,napi_create_string_utf8,,false,87,90,napi_create_string_utf8,,,14,"napi_status napi_create_string_utf8 (napi_env,char*,size_t,napi_value*)"
100335,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, const char16_t *, size_t, napi_value *);",36,79,js_native_api.hpp,napi_create_string_utf16,,false,91,94,napi_create_string_utf16,,,15,"napi_status napi_create_string_utf16 (napi_env,char16_t*,size_t,napi_value*)"
100343,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, napi_value *);",36,73,js_native_api.hpp,napi_create_symbol,,false,113,115,napi_create_symbol,,,16,"napi_status napi_create_symbol (napi_env,napi_value,napi_value*)"
100350,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, const char *, size_t, napi_callback, void *, napi_value *);",36,75,js_native_api.hpp,napi_create_function,,false,123,128,napi_create_function,,,17,"napi_status napi_create_function (napi_env,char*,size_t,napi_callback,void*,napi_value*)"
100360,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, napi_value, napi_value *);",36,72,js_native_api.hpp,napi_create_error,,false,129,132,napi_create_error,,,18,"napi_status napi_create_error (napi_env,napi_value,napi_value,napi_value*)"
100368,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, napi_value, napi_value *);",36,77,js_native_api.hpp,napi_create_type_error,,false,133,136,napi_create_type_error,,,19,"napi_status napi_create_type_error (napi_env,napi_value,napi_value,napi_value*)"
100376,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, napi_value, napi_value *);",36,78,js_native_api.hpp,napi_create_range_error,,false,137,140,napi_create_range_error,,,20,"napi_status napi_create_range_error (napi_env,napi_value,napi_value,napi_value*)"
100384,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, napi_valuetype *);",36,70,js_native_api.hpp,napi_typeof,,false,147,149,napi_typeof,,,21,"napi_status napi_typeof (napi_env,napi_value,napi_valuetype*)"
100391,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, double *);",36,72,js_native_api.hpp,napi_get_value_double,,false,150,152,napi_get_value_double,,,22,"napi_status napi_get_value_double (napi_env,napi_value,double*)"
100398,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, int32_t *);",36,72,js_native_api.hpp,napi_get_value_int32,,false,153,155,napi_get_value_int32,,,23,"napi_status napi_get_value_int32 (napi_env,napi_value,int32_t*)"
100405,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, uint32_t *);",36,74,js_native_api.hpp,napi_get_value_uint32,,false,156,158,napi_get_value_uint32,,,24,"napi_status napi_get_value_uint32 (napi_env,napi_value,uint32_t*)"
100412,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, int64_t *);",36,72,js_native_api.hpp,napi_get_value_int64,,false,159,161,napi_get_value_int64,,,25,"napi_status napi_get_value_int64 (napi_env,napi_value,int64_t*)"
100419,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, bool *);",36,68,js_native_api.hpp,napi_get_value_bool,,false,162,164,napi_get_value_bool,,,26,"napi_status napi_get_value_bool (napi_env,napi_value,bool*)"
100426,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, char *, size_t, size_t *);",36,78,js_native_api.hpp,napi_get_value_string_latin1,,false,167,168,napi_get_value_string_latin1,,,27,"napi_status napi_get_value_string_latin1 (napi_env,napi_value,char*,size_t,size_t*)"
100435,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, char *, size_t, size_t *);",36,78,js_native_api.hpp,napi_get_value_string_utf8,,false,171,172,napi_get_value_string_utf8,,,28,"napi_status napi_get_value_string_utf8 (napi_env,napi_value,char*,size_t,size_t*)"
100444,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, char16_t *, size_t, size_t *);",36,78,js_native_api.hpp,napi_get_value_string_utf16,,false,175,179,napi_get_value_string_utf16,,,29,"napi_status napi_get_value_string_utf16 (napi_env,napi_value,char16_t*,size_t,size_t*)"
100453,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, napi_value *);",36,74,js_native_api.hpp,napi_coerce_to_bool,,false,183,185,napi_coerce_to_bool,,,30,"napi_status napi_coerce_to_bool (napi_env,napi_value,napi_value*)"
100460,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, napi_value *);",36,76,js_native_api.hpp,napi_coerce_to_number,,false,186,188,napi_coerce_to_number,,,31,"napi_status napi_coerce_to_number (napi_env,napi_value,napi_value*)"
100467,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, napi_value *);",36,76,js_native_api.hpp,napi_coerce_to_object,,false,189,191,napi_coerce_to_object,,,32,"napi_status napi_coerce_to_object (napi_env,napi_value,napi_value*)"
100474,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, napi_value *);",36,76,js_native_api.hpp,napi_coerce_to_string,,false,192,194,napi_coerce_to_string,,,33,"napi_status napi_coerce_to_string (napi_env,napi_value,napi_value*)"
100481,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, napi_value *);",36,73,js_native_api.hpp,napi_get_prototype,,false,197,199,napi_get_prototype,,,34,"napi_status napi_get_prototype (napi_env,napi_value,napi_value*)"
100488,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, napi_value *);",36,78,js_native_api.hpp,napi_get_property_names,,false,200,202,napi_get_property_names,,,35,"napi_status napi_get_property_names (napi_env,napi_value,napi_value*)"
100495,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, napi_value, napi_value);",36,70,js_native_api.hpp,napi_set_property,,false,203,206,napi_set_property,,,36,"napi_status napi_set_property (napi_env,napi_value,napi_value,napi_value)"
100503,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, napi_value, bool *);",36,66,js_native_api.hpp,napi_has_property,,false,207,210,napi_has_property,,,37,"napi_status napi_has_property (napi_env,napi_value,napi_value,bool*)"
100511,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, napi_value, napi_value *);",36,72,js_native_api.hpp,napi_get_property,,false,211,214,napi_get_property,,,38,"napi_status napi_get_property (napi_env,napi_value,napi_value,napi_value*)"
100519,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, napi_value, bool *);",36,69,js_native_api.hpp,napi_delete_property,,false,215,218,napi_delete_property,,,39,"napi_status napi_delete_property (napi_env,napi_value,napi_value,bool*)"
100527,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, napi_value, bool *);",36,70,js_native_api.hpp,napi_has_own_property,,false,219,222,napi_has_own_property,,,40,"napi_status napi_has_own_property (napi_env,napi_value,napi_value,bool*)"
100535,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, const char *, napi_value);",36,76,js_native_api.hpp,napi_set_named_property,,false,223,226,napi_set_named_property,,,41,"napi_status napi_set_named_property (napi_env,napi_value,char*,napi_value)"
100543,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, const char *, bool *);",36,72,js_native_api.hpp,napi_has_named_property,,false,227,230,napi_has_named_property,,,42,"napi_status napi_has_named_property (napi_env,napi_value,char*,bool*)"
100551,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, const char *, napi_value *);",36,78,js_native_api.hpp,napi_get_named_property,,false,231,234,napi_get_named_property,,,43,"napi_status napi_get_named_property (napi_env,napi_value,char*,napi_value*)"
100559,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, uint32_t, napi_value);",36,69,js_native_api.hpp,napi_set_element,,false,235,238,napi_set_element,,,44,"napi_status napi_set_element (napi_env,napi_value,uint32_t,napi_value)"
100567,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, uint32_t, bool *);",36,65,js_native_api.hpp,napi_has_element,,false,239,242,napi_has_element,,,45,"napi_status napi_has_element (napi_env,napi_value,uint32_t,bool*)"
100575,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, uint32_t, napi_value *);",36,71,js_native_api.hpp,napi_get_element,,false,243,246,napi_get_element,,,46,"napi_status napi_get_element (napi_env,napi_value,uint32_t,napi_value*)"
100583,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, uint32_t, bool *);",36,68,js_native_api.hpp,napi_delete_element,,false,247,250,napi_delete_element,,,47,"napi_status napi_delete_element (napi_env,napi_value,uint32_t,bool*)"
100591,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, size_t, const napi_property_descriptor *);",1,66,js_native_api.hpp,napi_define_properties,,false,252,255,napi_define_properties,,,48,"napi_status napi_define_properties (napi_env,napi_value,size_t,napi_property_descriptor*)"
100599,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, bool *);",36,62,js_native_api.hpp,napi_is_array,,false,258,260,napi_is_array,,,49,"napi_status napi_is_array (napi_env,napi_value,bool*)"
100606,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, uint32_t *);",36,74,js_native_api.hpp,napi_get_array_length,,false,261,263,napi_get_array_length,,,50,"napi_status napi_get_array_length (napi_env,napi_value,uint32_t*)"
100613,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, napi_value, bool *);",36,67,js_native_api.hpp,napi_strict_equals,,false,266,269,napi_strict_equals,,,51,"napi_status napi_strict_equals (napi_env,napi_value,napi_value,bool*)"
100621,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, napi_value, size_t, const napi_value *, napi_value *);",36,73,js_native_api.hpp,napi_call_function,,false,272,277,napi_call_function,,,52,"napi_status napi_call_function (napi_env,napi_value,napi_value,size_t,napi_value*,napi_value*)"
100631,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, size_t, const napi_value *, napi_value *);",36,72,js_native_api.hpp,napi_new_instance,,false,278,282,napi_new_instance,,,53,"napi_status napi_new_instance (napi_env,napi_value,size_t,napi_value*,napi_value*)"
100640,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, napi_value, bool *);",36,64,js_native_api.hpp,napi_instanceof,,false,283,286,napi_instanceof,,,54,"napi_status napi_instanceof (napi_env,napi_value,napi_value,bool*)"
100648,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_callback_info, size_t *, napi_value *, napi_value *, void * *);",36,16,js_native_api.hpp,napi_get_cb_info,,false,291,298,napi_get_cb_info,,,55,"napi_status napi_get_cb_info (napi_env,napi_callback_info,size_t*,napi_value*,napi_value*,void**)"
100658,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_callback_info, napi_value *);",36,64,js_native_api.hpp,napi_get_new_target,,false,300,301,napi_get_new_target,,,56,"napi_status napi_get_new_target (napi_env,napi_callback_info,napi_value*)"
100665,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, const char *, size_t, napi_callback, void *, size_t, const napi_property_descriptor *, napi_value *);",1,37,js_native_api.hpp,napi_define_class,,false,303,310,napi_define_class,,,57,"napi_status napi_define_class (napi_env,char*,size_t,napi_callback,void*,size_t,napi_property_descriptor*,napi_value*)"
100677,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, void *, napi_finalize, void *, napi_ref *);",36,62,js_native_api.hpp,napi_wrap,,false,313,318,napi_wrap,,,58,"napi_status napi_wrap (napi_env,napi_value,void*,napi_finalize,void*,napi_ref*)"
100687,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, void * *);",36,61,js_native_api.hpp,napi_unwrap,,false,319,321,napi_unwrap,,,59,"napi_status napi_unwrap (napi_env,napi_value,void**)"
100694,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, void * *);",36,66,js_native_api.hpp,napi_remove_wrap,,false,322,324,napi_remove_wrap,,,60,"napi_status napi_remove_wrap (napi_env,napi_value,void**)"
100701,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, void *, napi_finalize, void *, napi_value *);",1,40,js_native_api.hpp,napi_create_external,,false,326,330,napi_create_external,,,61,"napi_status napi_create_external (napi_env,void*,napi_finalize,void*,napi_value*)"
100710,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, void * *);",36,73,js_native_api.hpp,napi_get_value_external,,false,331,333,napi_get_value_external,,,62,"napi_status napi_get_value_external (napi_env,napi_value,void**)"
100717,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, uint32_t, napi_ref *);",1,39,js_native_api.hpp,napi_create_reference,,false,339,342,napi_create_reference,,,63,"napi_status napi_create_reference (napi_env,napi_value,uint32_t,napi_ref*)"
100725,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_ref);",36,70,js_native_api.hpp,napi_delete_reference,,false,346,347,napi_delete_reference,,,64,"napi_status napi_delete_reference (napi_env,napi_ref)"
100731,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_ref, uint32_t *);",36,71,js_native_api.hpp,napi_reference_ref,,false,354,356,napi_reference_ref,,,65,"napi_status napi_reference_ref (napi_env,napi_ref,uint32_t*)"
100738,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_ref, uint32_t *);",36,73,js_native_api.hpp,napi_reference_unref,,false,362,364,napi_reference_unref,,,66,"napi_status napi_reference_unref (napi_env,napi_ref,uint32_t*)"
100745,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_ref, napi_value *);",36,79,js_native_api.hpp,napi_get_reference_value,,false,369,371,napi_get_reference_value,,,67,"napi_status napi_get_reference_value (napi_env,napi_ref,napi_value*)"
100752,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_handle_scope *);",1,63,js_native_api.hpp,napi_open_handle_scope,,false,374,374,napi_open_handle_scope,,,68,"napi_status napi_open_handle_scope (napi_env,napi_handle_scope*)"
100758,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_handle_scope);",1,62,js_native_api.hpp,napi_close_handle_scope,,false,376,376,napi_close_handle_scope,,,69,"napi_status napi_close_handle_scope (napi_env,napi_handle_scope)"
100764,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_escapable_handle_scope *);",36,54,js_native_api.hpp,napi_open_escapable_handle_scope,,false,377,378,napi_open_escapable_handle_scope,,,70,"napi_status napi_open_escapable_handle_scope (napi_env,napi_escapable_handle_scope*)"
100770,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_escapable_handle_scope);",36,52,js_native_api.hpp,napi_close_escapable_handle_scope,,false,379,380,napi_close_escapable_handle_scope,,,71,"napi_status napi_close_escapable_handle_scope (napi_env,napi_escapable_handle_scope)"
100776,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_escapable_handle_scope, napi_value, napi_value *);",1,38,js_native_api.hpp,napi_escape_handle,,false,383,386,napi_escape_handle,,,72,"napi_status napi_escape_handle (napi_env,napi_escapable_handle_scope,napi_value,napi_value*)"
100784,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value);",36,77,js_native_api.hpp,napi_throw,,false,389,389,napi_throw,,,73,"napi_status napi_throw (napi_env,napi_value)"
100790,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, const char *, const char *);",36,68,js_native_api.hpp,napi_throw_error,,false,390,392,napi_throw_error,,,74,"napi_status napi_throw_error (napi_env,char*,char*)"
100797,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, const char *, const char *);",36,73,js_native_api.hpp,napi_throw_type_error,,false,393,395,napi_throw_type_error,,,75,"napi_status napi_throw_type_error (napi_env,char*,char*)"
100804,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, const char *, const char *);",36,74,js_native_api.hpp,napi_throw_range_error,,false,396,398,napi_throw_range_error,,,76,"napi_status napi_throw_range_error (napi_env,char*,char*)"
100811,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, bool *);",36,62,js_native_api.hpp,napi_is_error,,false,404,406,napi_is_error,,,77,"napi_status napi_is_error (napi_env,napi_value,bool*)"
100818,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, bool *);",36,74,js_native_api.hpp,napi_is_exception_pending,,false,409,410,napi_is_exception_pending,,,78,"napi_status napi_is_exception_pending (napi_env,bool*)"
100824,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value *);",1,67,js_native_api.hpp,napi_get_and_clear_last_exception,,false,412,412,napi_get_and_clear_last_exception,,,79,"napi_status napi_get_and_clear_last_exception (napi_env,napi_value*)"
100830,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, bool *);",36,68,js_native_api.hpp,napi_is_arraybuffer,,false,415,417,napi_is_arraybuffer,,,80,"napi_status napi_is_arraybuffer (napi_env,napi_value,bool*)"
100837,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, size_t, void * *, napi_value *);",36,78,js_native_api.hpp,napi_create_arraybuffer,,false,418,421,napi_create_arraybuffer,,,81,"napi_status napi_create_arraybuffer (napi_env,size_t,void**,napi_value*)"
100845,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, void *, size_t, napi_finalize, void *, napi_value *);",1,52,js_native_api.hpp,napi_create_external_arraybuffer,,false,424,429,napi_create_external_arraybuffer,,,82,"napi_status napi_create_external_arraybuffer (napi_env,void*,size_t,napi_finalize,void*,napi_value*)"
100855,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, void * *, size_t *);",36,75,js_native_api.hpp,napi_get_arraybuffer_info,,false,431,432,napi_get_arraybuffer_info,,,83,"napi_status napi_get_arraybuffer_info (napi_env,napi_value,void**,size_t*)"
100863,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, bool *);",36,67,js_native_api.hpp,napi_is_typedarray,,false,433,435,napi_is_typedarray,,,84,"napi_status napi_is_typedarray (napi_env,napi_value,bool*)"
100870,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_typedarray_type, size_t, napi_value, size_t, napi_value *);",1,42,js_native_api.hpp,napi_create_typedarray,,false,437,442,napi_create_typedarray,,,85,"napi_status napi_create_typedarray (napi_env,napi_typedarray_type,size_t,napi_value,size_t,napi_value*)"
100880,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, napi_typedarray_type *, size_t *, void * *, napi_value *, size_t *);",1,45,js_native_api.hpp,napi_get_typedarray_info,,false,444,450,napi_get_typedarray_info,,,86,"napi_status napi_get_typedarray_info (napi_env,napi_value,napi_typedarray_type*,size_t*,void**,napi_value*,size_t*)"
100891,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, size_t, napi_value, size_t, napi_value *);",36,75,js_native_api.hpp,napi_create_dataview,,false,452,456,napi_create_dataview,,,87,"napi_status napi_create_dataview (napi_env,size_t,napi_value,size_t,napi_value*)"
100900,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, bool *);",36,65,js_native_api.hpp,napi_is_dataview,,false,457,459,napi_is_dataview,,,88,"napi_status napi_is_dataview (napi_env,napi_value,bool*)"
100907,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, size_t *, void * *, napi_value *, size_t *);",1,43,js_native_api.hpp,napi_get_dataview_info,,false,461,466,napi_get_dataview_info,,,89,"napi_status napi_get_dataview_info (napi_env,napi_value,size_t*,void**,napi_value*,size_t*)"
100917,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, uint32_t *);",36,69,js_native_api.hpp,napi_get_version,,false,469,470,napi_get_version,,,90,"napi_status napi_get_version (napi_env,uint32_t*)"
100923,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_deferred *, napi_value *);",36,75,js_native_api.hpp,napi_create_promise,,false,473,475,napi_create_promise,,,91,"napi_status napi_create_promise (napi_env,napi_deferred*,napi_value*)"
100930,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_deferred, napi_value);",36,79,js_native_api.hpp,napi_resolve_deferred,,false,476,478,napi_resolve_deferred,,,92,"napi_status napi_resolve_deferred (napi_env,napi_deferred,napi_value)"
100937,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_deferred, napi_value);",36,77,js_native_api.hpp,napi_reject_deferred,,false,479,481,napi_reject_deferred,,,93,"napi_status napi_reject_deferred (napi_env,napi_deferred,napi_value)"
100944,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, bool *);",36,68,js_native_api.hpp,napi_is_promise,,false,482,484,napi_is_promise,,,94,"napi_status napi_is_promise (napi_env,napi_value,bool*)"
100951,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, napi_value *);",36,70,js_native_api.hpp,napi_run_script,,false,487,489,napi_run_script,,,95,"napi_status napi_run_script (napi_env,napi_value,napi_value*)"
100958,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, int64_t, int64_t *);",36,67,js_native_api.hpp,napi_adjust_external_memory,,false,492,493,napi_adjust_external_memory,,,96,"napi_status napi_adjust_external_memory (napi_env,int64_t,int64_t*)"
100965,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, double, napi_value *);",36,71,js_native_api.hpp,napi_create_date,,false,498,500,napi_create_date,,,97,"napi_status napi_create_date (napi_env,double,napi_value*)"
100972,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, bool *);",36,62,js_native_api.hpp,napi_is_date,,false,502,504,napi_is_date,,,98,"napi_status napi_is_date (napi_env,napi_value,bool*)"
100979,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, double *);",36,70,js_native_api.hpp,napi_get_date_value,,false,506,508,napi_get_date_value,,,99,"napi_status napi_get_date_value (napi_env,napi_value,double*)"
100986,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, void *, napi_finalize, void *, napi_ref *);",36,71,js_native_api.hpp,napi_add_finalizer,,false,511,516,napi_add_finalizer,,,100,"napi_status napi_add_finalizer (napi_env,napi_value,void*,napi_finalize,void*,napi_ref*)"
100996,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, int64_t, napi_value *);",36,79,js_native_api.hpp,napi_create_bigint_int64,,false,523,525,napi_create_bigint_int64,,,101,"napi_status napi_create_bigint_int64 (napi_env,int64_t,napi_value*)"
101003,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, uint64_t, napi_value *);",1,75,js_native_api.hpp,napi_create_bigint_uint64,,false,527,527,napi_create_bigint_uint64,,,102,"napi_status napi_create_bigint_uint64 (napi_env,uint64_t,napi_value*)"
101010,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, int, size_t, const uint64_t *, napi_value *);",1,44,js_native_api.hpp,napi_create_bigint_words,,false,529,533,napi_create_bigint_words,,,103,"napi_status napi_create_bigint_words (napi_env,int,size_t,uint64_t*,napi_value*)"
101019,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, int64_t *, bool *);",36,78,js_native_api.hpp,napi_get_value_bigint_int64,,false,534,537,napi_get_value_bigint_int64,,,104,"napi_status napi_get_value_bigint_int64 (napi_env,napi_value,int64_t*,bool*)"
101027,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, uint64_t *, bool *);",36,69,js_native_api.hpp,napi_get_value_bigint_uint64,,false,538,539,napi_get_value_bigint_uint64,,,105,"napi_status napi_get_value_bigint_uint64 (napi_env,napi_value,uint64_t*,bool*)"
101035,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, int *, size_t *, uint64_t *);",1,44,js_native_api.hpp,napi_get_value_bigint_words,,false,541,545,napi_get_value_bigint_words,,,106,"napi_status napi_get_value_bigint_words (napi_env,napi_value,int*,size_t*,uint64_t*)"
101044,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, napi_key_collection_mode, napi_key_filter, napi_key_conversion, napi_value *);",1,47,js_native_api.hpp,napi_get_all_property_names,,false,549,554,napi_get_all_property_names,,,107,"napi_status napi_get_all_property_names (napi_env,napi_value,napi_key_collection_mode,napi_key_filter,napi_key_conversion,napi_value*)"
101054,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, void *, napi_finalize, void *);",36,77,js_native_api.hpp,napi_set_instance_data,,false,557,558,napi_set_instance_data,,,108,"napi_status napi_set_instance_data (napi_env,void*,napi_finalize,void*)"
101062,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, void * *);",36,70,js_native_api.hpp,napi_get_instance_data,,false,560,561,napi_get_instance_data,,,109,"napi_status napi_get_instance_data (napi_env,void**)"
101068,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value);",1,61,js_native_api.hpp,napi_detach_arraybuffer,,false,567,567,napi_detach_arraybuffer,,,110,"napi_status napi_detach_arraybuffer (napi_env,napi_value)"
101074,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, bool *);",1,74,js_native_api.hpp,napi_is_detached_arraybuffer,,false,570,570,napi_is_detached_arraybuffer,,,111,"napi_status napi_is_detached_arraybuffer (napi_env,napi_value,bool*)"
101081,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, const napi_type_tag *);",36,66,js_native_api.hpp,napi_type_tag_object,,false,575,576,napi_type_tag_object,,,112,"napi_status napi_type_tag_object (napi_env,napi_value,napi_type_tag*)"
101088,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, const napi_type_tag *, bool *);",1,40,js_native_api.hpp,napi_check_object_type_tag,,false,579,582,napi_check_object_type_tag,,,113,"napi_status napi_check_object_type_tag (napi_env,napi_value,napi_type_tag*,bool*)"
101096,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value);",36,72,js_native_api.hpp,napi_object_freeze,,false,583,584,napi_object_freeze,,,114,"napi_status napi_object_freeze (napi_env,napi_value)"
101102,METHOD,js_native_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value);",36,70,js_native_api.hpp,napi_object_seal,,false,585,586,napi_object_seal,,,115,"napi_status napi_object_seal (napi_env,napi_value)"
101115,METHOD,js_native_api_types.hpp:<global>,TYPE_DECL,<global>,1,19,js_native_api_types.hpp,js_native_api_types.hpp:<global>,,false,1,168,<global>,,,1,
101137,METHOD,<empty>,<empty>,<empty>,1,,js_native_api_types.hpp,napi_property_attributes:<clinit>,,false,32,,<clinit>,,,6,
101216,METHOD,js_native_api_types.hpp:<global>,TYPE_DECL,"typedef napi_value(NAPI_CDECL* napi_callback)(napi_env env,
                                              napi_callback_info info);",19,19,js_native_api_types.hpp,napi_callback,,false,113,114,napi_callback,,,23,"napi_value napi_callback (napi_env,napi_callback_info)"
101222,METHOD,js_native_api_types.hpp:<global>,TYPE_DECL,"typedef void(NAPI_CDECL* napi_finalize)(napi_env env,
                                        void* finalize_data,
                                        void* finalize_hint);",13,13,js_native_api_types.hpp,napi_finalize,,false,115,117,napi_finalize,,,24,"void napi_finalize (napi_env,void*,void*)"
101246,METHOD,v8impl.anonymous_namespace_45.CallbackWrapperBase,TYPE_DECL,"[&](napi_env env) { result = cb(env, cbinfo_wrapper); }",25,79,js_native_api_v8.cc,v8impl.anonymous_namespace_48.CallbackWrapperBase.InvokeCallback.<lambda>0,,false,441,441,<lambda>0,,,1,ANY v8impl.anonymous_namespace_48.CallbackWrapperBase.InvokeCallback.<lambda>0 (napi_env)
101261,METHOD,v8impl.anonymous_namespace_45.CallbackWrapperBase,TYPE_DECL,"[&](napi_env env, v8::Local<v8::Value> value) {
                          exceptionOccurred = true;
                          if (env->terminatedOrTerminating()) {
                            return;
                          }
                          env->isolate->ThrowException(value);
                        }",25,25,js_native_api_v8.cc,v8impl.anonymous_namespace_49.CallbackWrapperBase.InvokeCallback.<lambda>1,,false,442,448,<lambda>1,,,1,"ANY v8impl.anonymous_namespace_49.CallbackWrapperBase.InvokeCallback.<lambda>1 (napi_env,ANY)"
101286,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"[&](v8::Isolate* isolate) {
    return v8::String::NewFromOneByte(isolate,
                                      reinterpret_cast<const uint8_t*>(str),
                                      v8::NewStringType::kNormal,
                                      length);
  }",54,3,js_native_api_v8.cc,napi_create_string_latin1.<lambda>2,,false,1530,1535,<lambda>2,,,1,ANY napi_create_string_latin1.<lambda>2 (ANY*)
101312,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"[&](v8::Isolate* isolate) {
    return v8::String::NewFromUtf8(
        isolate, str, v8::NewStringType::kNormal, static_cast<int>(length));
  }",54,3,js_native_api_v8.cc,napi_create_string_utf8.<lambda>3,,false,1542,1545,<lambda>3,,,1,ANY napi_create_string_utf8.<lambda>3 (ANY*)
101337,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"[&](v8::Isolate* isolate) {
    return v8::String::NewFromTwoByte(isolate,
                                      reinterpret_cast<const uint16_t*>(str),
                                      v8::NewStringType::kNormal,
                                      length);
  }",54,3,js_native_api_v8.cc,napi_create_string_utf16.<lambda>4,,false,1552,1557,<lambda>4,,,1,ANY napi_create_string_utf16.<lambda>4 (ANY*)
101362,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"[&](v8::Isolate* isolate) {
        if (length == NAPI_AUTO_LENGTH) {
          length = (std::string_view(str)).length();
        }
        auto resource = new v8impl::ExternalOneByteStringResource(
            env, str, length, finalize_callback, finalize_hint);
        return v8::String::NewExternalOneByte(isolate, resource);
      }",7,22,js_native_api_v8.cc,node_api_create_external_string_latin1.<lambda>5,,false,1577,1584,<lambda>5,,,1,ANY node_api_create_external_string_latin1.<lambda>5 (ANY*)
101409,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"[&](v8::Isolate* isolate) {
        if (length == NAPI_AUTO_LENGTH) {
          length = (std::u16string_view(str)).length();
        }
        auto resource = new v8impl::ExternalStringResource(
            env, str, length, finalize_callback, finalize_hint);
        return v8::String::NewExternalTwoByte(isolate, resource);
      }",7,22,js_native_api_v8.cc,node_api_create_external_string_utf16.<lambda>6,,false,1604,1611,<lambda>6,,,1,ANY node_api_create_external_string_utf16.<lambda>6 (ANY*)
101471,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,<global>,1,26,js_native_api_v8.cc,js_native_api_v8.cc:<global>,,false,1,3386,<global>,,,1,
101475,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NewString(napi_env env,
                      const CCharType* str,
                      size_t length,
                      napi_value* result,
                      StringMaker string_maker) {
  CHECK_ENV(env);
  if (length > 0) CHECK_ARG(env, str);
  CHECK_ARG(env, result);
  RETURN_STATUS_IF_FALSE(
      env, (length == NAPI_AUTO_LENGTH) || length <= INT_MAX, napi_invalid_arg);

  auto isolate = env->isolate;
  auto str_maybe = string_maker(isolate);
  CHECK_MAYBE_EMPTY(env, str_maybe, napi_generic_failure);
  *result = v8impl::JsValueFromV8LocalValue(str_maybe.ToLocalChecked());
  return napi_clear_last_error(env);
}",1,2,js_native_api_v8.cc,v8impl.anonymous_namespace_1.NewString,,false,65,81,NewString,,,1,"napi_status v8impl.anonymous_namespace_1.NewString<CCharType,StringMaker> (napi_env,CCharType*,size_t,napi_value*,StringMaker)"
101602,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NewExternalString(napi_env env,
                              CharType* str,
                              size_t length,
                              napi_finalize finalize_callback,
                              void* finalize_hint,
                              napi_value* result,
                              bool* copied,
                              CreateAPI create_api,
                              StringMaker string_maker) {
  napi_status status;
#if defined(V8_ENABLE_SANDBOX)
  status = create_api(env, str, length, result);
  if (status == napi_ok) {
    if (copied != nullptr) {
      *copied = true;
    }
    if (finalize_callback) {
      env->CallFinalizer(
          finalize_callback, static_cast<CharType*>(str), finalize_hint);
    }
  }
#else
  status = NewString(env, str, length, result, string_maker);
  if (status == napi_ok && copied != nullptr) {
    *copied = false;
  }
#endif  // V8_ENABLE_SANDBOX
  return status;
}",1,1,js_native_api_v8.cc,v8impl.anonymous_namespace_2.NewExternalString,,false,84,112,NewExternalString,,,2,"napi_status v8impl.anonymous_namespace_2.NewExternalString<CharType,CreateAPI,StringMaker> (napi_env,CharType*,size_t,napi_finalize,void*,napi_value*,bool*,CreateAPI,StringMaker)"
101640,METHOD,v8impl.anonymous_namespace_3.TrackedStringResource,TYPE_DECL,"TrackedStringResource(napi_env env,
                        napi_finalize finalize_callback,
                        void* data,
                        void* finalize_hint)
      : Finalizer(env, finalize_callback, data, finalize_hint) {
    Link(finalize_callback == nullptr ? &env->reflist
                                      : &env->finalizing_reflist);
  }",3,3,js_native_api_v8.cc,v8impl.anonymous_namespace_4.TrackedStringResource.TrackedStringResource,,false,116,123,TrackedStringResource,,,1,"ANY v8impl.anonymous_namespace_4.TrackedStringResource.TrackedStringResource (napi_env,napi_finalize,void*,void*)"
101661,METHOD,v8impl.anonymous_namespace_3.TrackedStringResource,TYPE_DECL,"void Finalize() override {
    Unlink();
    env_ = nullptr;
  }",3,3,js_native_api_v8.cc,v8impl.anonymous_namespace_5.TrackedStringResource.Finalize,,false,131,134,Finalize,,,2,void v8impl.anonymous_namespace_5.TrackedStringResource.Finalize ()
101669,METHOD,v8impl.anonymous_namespace_3.TrackedStringResource,TYPE_DECL,"~TrackedStringResource() {
    if (finalize_callback_ == nullptr) return;
    if (env_ == nullptr) {
      // The environment is dead. Call the finalizer directly.
      finalize_callback_(nullptr, finalize_data_, finalize_hint_);
    } else {
      // The environment is still alive. Let's remove ourselves from its list
      // of references and call the user's finalizer.
      Unlink();
      env_->CallFinalizer(finalize_callback_, finalize_data_, finalize_hint_);
    }
  }",3,3,js_native_api_v8.cc,v8impl.anonymous_namespace_6.TrackedStringResource.~TrackedStringResource,,false,136,147,~TrackedStringResource,,,3,ANY v8impl.anonymous_namespace_6.TrackedStringResource.~TrackedStringResource ()
101699,METHOD,v8impl.anonymous_namespace_7.ExternalOneByteStringResource,TYPE_DECL,"ExternalOneByteStringResource(napi_env env,
                                char* string,
                                const size_t length,
                                napi_finalize finalize_callback,
                                void* finalize_hint)
      : TrackedStringResource(env, finalize_callback, string, finalize_hint),
        string_(string),
        length_(length) {}",3,26,js_native_api_v8.cc,v8impl.anonymous_namespace_8.ExternalOneByteStringResource.ExternalOneByteStringResource,,false,154,161,ExternalOneByteStringResource,,,1,"ANY v8impl.anonymous_namespace_8.ExternalOneByteStringResource.ExternalOneByteStringResource (napi_env,char*,size_t,napi_finalize,void*)"
101708,METHOD,v8impl.anonymous_namespace_7.ExternalOneByteStringResource,TYPE_DECL,const char* data() const override { return string_; },3,55,js_native_api_v8.cc,v8impl.anonymous_namespace_9.ExternalOneByteStringResource.data,,false,163,163,data,,,2,const char* v8impl.anonymous_namespace_9.ExternalOneByteStringResource.data ()
101714,METHOD,v8impl.anonymous_namespace_7.ExternalOneByteStringResource,TYPE_DECL,size_t length() const override { return length_; },3,52,js_native_api_v8.cc,v8impl.anonymous_namespace_10.ExternalOneByteStringResource.length,,false,164,164,length,,,3,size_t v8impl.anonymous_namespace_10.ExternalOneByteStringResource.length ()
101723,METHOD,v8impl.anonymous_namespace_11.ExternalStringResource,TYPE_DECL,"ExternalStringResource(napi_env env,
                         char16_t* string,
                         const size_t length,
                         napi_finalize finalize_callback,
                         void* finalize_hint)
      : TrackedStringResource(env, finalize_callback, string, finalize_hint),
        string_(reinterpret_cast<uint16_t*>(string)),
        length_(length) {}",3,26,js_native_api_v8.cc,v8impl.anonymous_namespace_12.ExternalStringResource.ExternalStringResource,,false,174,181,ExternalStringResource,,,1,"ANY v8impl.anonymous_namespace_12.ExternalStringResource.ExternalStringResource (napi_env,char16_t*,size_t,napi_finalize,void*)"
101732,METHOD,v8impl.anonymous_namespace_11.ExternalStringResource,TYPE_DECL,const uint16_t* data() const override { return string_; },3,59,js_native_api_v8.cc,v8impl.anonymous_namespace_13.ExternalStringResource.data,,false,183,183,data,,,2,uint16_t v8impl.anonymous_namespace_13.ExternalStringResource.data ()
101738,METHOD,v8impl.anonymous_namespace_11.ExternalStringResource,TYPE_DECL,size_t length() const override { return length_; },3,52,js_native_api_v8.cc,v8impl.anonymous_namespace_14.ExternalStringResource.length,,false,184,184,length,,,3,size_t v8impl.anonymous_namespace_14.ExternalStringResource.length ()
101746,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"inline napi_status V8NameFromPropertyDescriptor(
    napi_env env,
    const napi_property_descriptor* p,
    v8::Local<v8::Name>* result) {
  if (p->utf8name != nullptr) {
    CHECK_NEW_FROM_UTF8(env, *result, p->utf8name);
  } else {
    v8::Local<v8::Value> property_value =
        v8impl::V8LocalValueFromJsValue(p->name);

    RETURN_STATUS_IF_FALSE(env, property_value->IsName(), napi_name_expected);
    *result = property_value.As<v8::Name>();
  }

  return napi_ok;
}",1,4,js_native_api_v8.cc,v8impl.anonymous_namespace_15.V8NameFromPropertyDescriptor,,false,191,206,V8NameFromPropertyDescriptor,,,6,"napi_status v8impl.anonymous_namespace_15.V8NameFromPropertyDescriptor (napi_env,napi_property_descriptor*,ANY*)"
101907,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"inline v8::PropertyAttribute V8PropertyAttributesFromDescriptor(
    const napi_property_descriptor* descriptor) {
  unsigned int attribute_flags = v8::PropertyAttribute::None;

  // The napi_writable attribute is ignored for accessor descriptors, but
  // V8 would throw `TypeError`s on assignment with nonexistence of a setter.
  if ((descriptor->getter == nullptr && descriptor->setter == nullptr) &&
      (descriptor->attributes & napi_writable) == 0) {
    attribute_flags |= v8::PropertyAttribute::ReadOnly;
  }

  if ((descriptor->attributes & napi_enumerable) == 0) {
    attribute_flags |= v8::PropertyAttribute::DontEnum;
  }
  if ((descriptor->attributes & napi_configurable) == 0) {
    attribute_flags |= v8::PropertyAttribute::DontDelete;
  }

  return static_cast<v8::PropertyAttribute>(attribute_flags);
}",1,1,js_native_api_v8.cc,v8impl.anonymous_namespace_16.V8PropertyAttributesFromDescriptor,,false,209,228,V8PropertyAttributesFromDescriptor,,,7,PropertyAttribute v8impl.anonymous_namespace_16.V8PropertyAttributesFromDescriptor (napi_property_descriptor*)
101984,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"inline napi_deferred JsDeferredFromNodePersistent(
    v8impl::Persistent<v8::Value>* local) {
  return reinterpret_cast<napi_deferred>(local);
}",1,1,js_native_api_v8.cc,v8impl.anonymous_namespace_17.JsDeferredFromNodePersistent,,false,230,233,JsDeferredFromNodePersistent,,,8,napi_deferred v8impl.anonymous_namespace_17.JsDeferredFromNodePersistent (ANY*)
101993,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"inline v8impl::Persistent<v8::Value>* NodePersistentFromJsDeferred(
    napi_deferred local) {
  return reinterpret_cast<v8impl::Persistent<v8::Value>*>(local);
}",1,1,js_native_api_v8.cc,v8impl.anonymous_namespace_18.NodePersistentFromJsDeferred,,false,235,238,NodePersistentFromJsDeferred,,,9,Persistent<v8::Value> v8impl.anonymous_namespace_18.NodePersistentFromJsDeferred (napi_deferred)
102003,METHOD,v8impl.anonymous_namespace_19.HandleScopeWrapper,TYPE_DECL,explicit HandleScopeWrapper(v8::Isolate* isolate) : scope(isolate) {},3,71,js_native_api_v8.cc,v8impl.anonymous_namespace_20.HandleScopeWrapper.HandleScopeWrapper,,false,242,242,HandleScopeWrapper,,,1,ANY v8impl.anonymous_namespace_20.HandleScopeWrapper.HandleScopeWrapper (ANY*)
102010,METHOD,v8impl.anonymous_namespace_21.EscapableHandleScopeWrapper,TYPE_DECL,"explicit EscapableHandleScopeWrapper(v8::Isolate* isolate)
      : scope(isolate), escape_called_(false) {}",3,48,js_native_api_v8.cc,v8impl.anonymous_namespace_22.EscapableHandleScopeWrapper.EscapableHandleScopeWrapper,,false,255,256,EscapableHandleScopeWrapper,,,1,ANY v8impl.anonymous_namespace_22.EscapableHandleScopeWrapper.EscapableHandleScopeWrapper (ANY*)
102015,METHOD,v8impl.anonymous_namespace_21.EscapableHandleScopeWrapper,TYPE_DECL,bool escape_called() const { return escape_called_; },3,55,js_native_api_v8.cc,v8impl.anonymous_namespace_23.EscapableHandleScopeWrapper.escape_called,,false,257,257,escape_called,,,2,bool v8impl.anonymous_namespace_23.EscapableHandleScopeWrapper.escape_called ()
102021,METHOD,v8impl.anonymous_namespace_21.EscapableHandleScopeWrapper,TYPE_DECL,"v8::Local<T> Escape(v8::Local<T> handle) {
    escape_called_ = true;
    return scope.Escape(handle);
  }",3,3,js_native_api_v8.cc,v8impl.anonymous_namespace_24.EscapableHandleScopeWrapper.Escape,,false,259,262,Escape,,,3,Local<T> v8impl.anonymous_namespace_24.EscapableHandleScopeWrapper.Escape<T> (ANY)
102037,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"inline napi_handle_scope JsHandleScopeFromV8HandleScope(HandleScopeWrapper* s) {
  return reinterpret_cast<napi_handle_scope>(s);
}",1,1,js_native_api_v8.cc,v8impl.anonymous_namespace_25.JsHandleScopeFromV8HandleScope,,false,269,271,JsHandleScopeFromV8HandleScope,,,12,napi_handle_scope v8impl.anonymous_namespace_25.JsHandleScopeFromV8HandleScope (HandleScopeWrapper*)
102046,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"inline HandleScopeWrapper* V8HandleScopeFromJsHandleScope(napi_handle_scope s) {
  return reinterpret_cast<HandleScopeWrapper*>(s);
}",1,1,js_native_api_v8.cc,v8impl.anonymous_namespace_26.V8HandleScopeFromJsHandleScope,,false,273,275,V8HandleScopeFromJsHandleScope,,,13,HandleScopeWrapper v8impl.anonymous_namespace_26.V8HandleScopeFromJsHandleScope (napi_handle_scope)
102055,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"inline napi_escapable_handle_scope
JsEscapableHandleScopeFromV8EscapableHandleScope(
    EscapableHandleScopeWrapper* s) {
  return reinterpret_cast<napi_escapable_handle_scope>(s);
}",1,1,js_native_api_v8.cc,v8impl.anonymous_namespace_27.JsEscapableHandleScopeFromV8EscapableHandleScope,,false,277,281,JsEscapableHandleScopeFromV8EscapableHandleScope,,,14,napi_escapable_handle_scope v8impl.anonymous_namespace_27.JsEscapableHandleScopeFromV8EscapableHandleScope (EscapableHandleScopeWrapper*)
102064,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"inline EscapableHandleScopeWrapper*
V8EscapableHandleScopeFromJsEscapableHandleScope(
    napi_escapable_handle_scope s) {
  return reinterpret_cast<EscapableHandleScopeWrapper*>(s);
}",1,1,js_native_api_v8.cc,v8impl.anonymous_namespace_28.V8EscapableHandleScopeFromJsEscapableHandleScope,,false,283,287,V8EscapableHandleScopeFromJsEscapableHandleScope,,,15,EscapableHandleScopeWrapper v8impl.anonymous_namespace_28.V8EscapableHandleScopeFromJsEscapableHandleScope (napi_escapable_handle_scope)
102073,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"inline napi_status ConcludeDeferred(napi_env env,
                                    napi_deferred deferred,
                                    napi_value result,
                                    bool is_resolved) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();
  v8impl::Persistent<v8::Value>* deferred_ref =
      NodePersistentFromJsDeferred(deferred);
  v8::Local<v8::Value> v8_deferred =
      v8::Local<v8::Value>::New(env->isolate, *deferred_ref);

  auto v8_resolver = v8_deferred.As<v8::Promise::Resolver>();

  v8::Maybe<bool> success =
      is_resolved ? v8_resolver->Resolve(
                        context, v8impl::V8LocalValueFromJsValue(result))
                  : v8_resolver->Reject(
                        context, v8impl::V8LocalValueFromJsValue(result));

  delete deferred_ref;

  RETURN_STATUS_IF_FALSE(env, success.FromMaybe(false), napi_generic_failure);

  return GET_RETURN_STATUS(env);
}",1,2,js_native_api_v8.cc,v8impl.anonymous_namespace_29.ConcludeDeferred,,false,289,315,ConcludeDeferred,,,16,"napi_status v8impl.anonymous_namespace_29.ConcludeDeferred (napi_env,napi_deferred,napi_value,bool)"
102274,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"inline napi_status Unwrap(napi_env env,
                          napi_value js_object,
                          void** result,
                          UnwrapAction action) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, js_object);
  if (action == KeepWrap) {
    CHECK_ARG(env, result);
  }

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(js_object);
  RETURN_STATUS_IF_FALSE(env, value->IsObject(), napi_invalid_arg);
  v8::Local<v8::Object> obj = value.As<v8::Object>();

  auto val = obj->GetPrivate(context, NAPI_PRIVATE_KEY(context, wrapper))
                 .ToLocalChecked();
  RETURN_STATUS_IF_FALSE(env, val->IsExternal(), napi_invalid_arg);
  Reference* reference =
      static_cast<v8impl::Reference*>(val.As<v8::External>()->Value());

  if (result) {
    *result = reference->Data();
  }

  if (action == RemoveWrap) {
    CHECK(obj->DeletePrivate(context, NAPI_PRIVATE_KEY(context, wrapper))
              .FromJust...",1,2,js_native_api_v8.cc,v8impl.anonymous_namespace_32.Unwrap,,false,319,357,Unwrap,,,18,"napi_status v8impl.anonymous_namespace_32.Unwrap (napi_env,napi_value,void**,UnwrapAction)"
102569,METHOD,v8impl.anonymous_namespace_33.CallbackBundle,TYPE_DECL,"static inline v8::Local<v8::Value> New(napi_env env,
                                         napi_callback cb,
                                         void* data) {
    CallbackBundle* bundle = new CallbackBundle();
    bundle->cb = cb;
    bundle->cb_data = data;
    bundle->env = env;

    v8::Local<v8::Value> cbdata = v8::External::New(env->isolate, bundle);
    Reference::New(
        env, cbdata, 0, Ownership::kRuntime, Delete, bundle, nullptr);
    return cbdata;
  }",3,3,js_native_api_v8.cc,v8impl.anonymous_namespace_34.CallbackBundle.New,,false,371,383,New,,,1,"Local<v8::Value> v8impl.anonymous_namespace_34.CallbackBundle.New (napi_env,napi_callback,void*)"
102634,METHOD,v8impl.anonymous_namespace_33.CallbackBundle,TYPE_DECL,"static void Delete(napi_env env, void* data, void* hint) {
    CallbackBundle* bundle = static_cast<CallbackBundle*>(data);
    delete bundle;
  }",3,3,js_native_api_v8.cc,v8impl.anonymous_namespace_36.CallbackBundle.Delete,,false,389,392,Delete,,,5,"void v8impl.anonymous_namespace_36.CallbackBundle.Delete (napi_env,void*,void*)"
102650,METHOD,v8impl.anonymous_namespace_37.CallbackWrapper,TYPE_DECL,"inline CallbackWrapper(napi_value this_arg, size_t args_length, void* data)
      : _this(this_arg), _args_length(args_length), _data(data) {}",3,66,js_native_api_v8.cc,v8impl.anonymous_namespace_38.CallbackWrapper.CallbackWrapper,,false,399,400,CallbackWrapper,,,1,"ANY v8impl.anonymous_namespace_38.CallbackWrapper.CallbackWrapper (napi_value,size_t,void*)"
102657,METHOD,v8impl.anonymous_namespace_37.CallbackWrapper,TYPE_DECL,virtual napi_value GetNewTarget() = 0;,22,39,js_native_api_v8.cc,v8impl.anonymous_namespace_39.CallbackWrapper.GetNewTarget,,false,402,402,GetNewTarget,,,2,napi_value v8impl.anonymous_namespace_39.CallbackWrapper.GetNewTarget ()
102661,METHOD,v8impl.anonymous_namespace_37.CallbackWrapper,TYPE_DECL,"virtual void Args(napi_value* buffer, size_t bufferlength) = 0;",16,64,js_native_api_v8.cc,v8impl.anonymous_namespace_40.CallbackWrapper.Args,,false,403,403,Args,,,3,"void v8impl.anonymous_namespace_40.CallbackWrapper.Args (napi_value*,size_t)"
102667,METHOD,v8impl.anonymous_namespace_37.CallbackWrapper,TYPE_DECL,virtual void SetReturnValue(napi_value value) = 0;,16,51,js_native_api_v8.cc,v8impl.anonymous_namespace_41.CallbackWrapper.SetReturnValue,,false,404,404,SetReturnValue,,,4,void v8impl.anonymous_namespace_41.CallbackWrapper.SetReturnValue (napi_value)
102672,METHOD,v8impl.anonymous_namespace_37.CallbackWrapper,TYPE_DECL,napi_value This() { return _this; },3,37,js_native_api_v8.cc,v8impl.anonymous_namespace_42.CallbackWrapper.This,,false,406,406,This,,,5,napi_value v8impl.anonymous_namespace_42.CallbackWrapper.This ()
102678,METHOD,v8impl.anonymous_namespace_37.CallbackWrapper,TYPE_DECL,size_t ArgsLength() { return _args_length; },3,46,js_native_api_v8.cc,v8impl.anonymous_namespace_43.CallbackWrapper.ArgsLength,,false,408,408,ArgsLength,,,6,size_t v8impl.anonymous_namespace_43.CallbackWrapper.ArgsLength ()
102684,METHOD,v8impl.anonymous_namespace_37.CallbackWrapper,TYPE_DECL,void* Data() { return _data; },3,32,js_native_api_v8.cc,v8impl.anonymous_namespace_44.CallbackWrapper.Data,,false,410,410,Data,,,7,void* v8impl.anonymous_namespace_44.CallbackWrapper.Data ()
102693,METHOD,v8impl.anonymous_namespace_45.CallbackWrapperBase,TYPE_DECL,"inline CallbackWrapperBase(const v8::FunctionCallbackInfo<v8::Value>& cbinfo,
                             const size_t args_length)
      : CallbackWrapper(
            JsValueFromV8LocalValue(cbinfo.This()), args_length, nullptr),
        _cbinfo(cbinfo) {
    _bundle = reinterpret_cast<CallbackBundle*>(
        cbinfo.Data().As<v8::External>()->Value());
    _data = _bundle->cb_data;
  }",3,3,js_native_api_v8.cc,v8impl.anonymous_namespace_46.CallbackWrapperBase.CallbackWrapperBase,,false,420,428,CallbackWrapperBase,,,1,"ANY v8impl.anonymous_namespace_46.CallbackWrapperBase.CallbackWrapperBase (ANY,size_t)"
102718,METHOD,v8impl.anonymous_namespace_45.CallbackWrapperBase,TYPE_DECL,"inline void InvokeCallback() {
    napi_callback_info cbinfo_wrapper = reinterpret_cast<napi_callback_info>(
        static_cast<CallbackWrapper*>(this));

    // All other pointers we need are stored in `_bundle`
    napi_env env = _bundle->env;
    napi_callback cb = _bundle->cb;

    napi_value result = nullptr;
    bool exceptionOccurred = false;
    env->CallIntoModule([&](napi_env env) { result = cb(env, cbinfo_wrapper); },
                        [&](napi_env env, v8::Local<v8::Value> value) {
                          exceptionOccurred = true;
                          if (env->terminatedOrTerminating()) {
                            return;
                          }
                          env->isolate->ThrowException(value);
                        });

    if (!exceptionOccurred && (result != nullptr)) {
      this->SetReturnValue(result);
    }
  }",3,3,js_native_api_v8.cc,v8impl.anonymous_namespace_47.CallbackWrapperBase.InvokeCallback,,false,431,453,InvokeCallback,,,2,void v8impl.anonymous_namespace_47.CallbackWrapperBase.InvokeCallback ()
102768,METHOD,v8impl.anonymous_namespace_50.FunctionCallbackWrapper,TYPE_DECL,"static void Invoke(const v8::FunctionCallbackInfo<v8::Value>& info) {
    FunctionCallbackWrapper cbwrapper(info);
    cbwrapper.InvokeCallback();
  }",3,3,js_native_api_v8.cc,v8impl.anonymous_namespace_51.FunctionCallbackWrapper.Invoke,,false,461,464,Invoke,,,1,void v8impl.anonymous_namespace_51.FunctionCallbackWrapper.Invoke (ANY)
102780,METHOD,v8impl.anonymous_namespace_50.FunctionCallbackWrapper,TYPE_DECL,"static inline napi_status NewFunction(napi_env env,
                                        napi_callback cb,
                                        void* cb_data,
                                        v8::Local<v8::Function>* result) {
    v8::Local<v8::Value> cbdata = v8impl::CallbackBundle::New(env, cb, cb_data);
    RETURN_STATUS_IF_FALSE(env, !cbdata.IsEmpty(), napi_generic_failure);

    v8::MaybeLocal<v8::Function> maybe_function =
        v8::Function::New(env->context(), Invoke, cbdata);
    CHECK_MAYBE_EMPTY(env, maybe_function, napi_generic_failure);

    *result = maybe_function.ToLocalChecked();
    return napi_clear_last_error(env);
  }",3,4,js_native_api_v8.cc,v8impl.anonymous_namespace_52.FunctionCallbackWrapper.NewFunction,,false,466,479,NewFunction,,,2,"napi_status v8impl.anonymous_namespace_52.FunctionCallbackWrapper.NewFunction (napi_env,napi_callback,void*,ANY*)"
102883,METHOD,v8impl.anonymous_namespace_50.FunctionCallbackWrapper,TYPE_DECL,"static inline napi_status NewTemplate(
      napi_env env,
      napi_callback cb,
      void* cb_data,
      v8::Local<v8::FunctionTemplate>* result,
      v8::Local<v8::Signature> sig = v8::Local<v8::Signature>()) {
    v8::Local<v8::Value> cbdata = v8impl::CallbackBundle::New(env, cb, cb_data);
    RETURN_STATUS_IF_FALSE(env, !cbdata.IsEmpty(), napi_generic_failure);

    *result = v8::FunctionTemplate::New(env->isolate, Invoke, cbdata, sig);
    return napi_clear_last_error(env);
  }",3,4,js_native_api_v8.cc,v8impl.anonymous_namespace_55.FunctionCallbackWrapper.NewTemplate,,false,481,492,NewTemplate,,,3,"napi_status v8impl.anonymous_namespace_55.FunctionCallbackWrapper.NewTemplate (napi_env,napi_callback,void*,ANY*,ANY)"
102953,METHOD,v8impl.anonymous_namespace_50.FunctionCallbackWrapper,TYPE_DECL,"explicit FunctionCallbackWrapper(
      const v8::FunctionCallbackInfo<v8::Value>& cbinfo)
      : CallbackWrapperBase(cbinfo, cbinfo.Length()) {}",3,55,js_native_api_v8.cc,v8impl.anonymous_namespace_58.FunctionCallbackWrapper.FunctionCallbackWrapper,,false,494,496,FunctionCallbackWrapper,,,4,ANY v8impl.anonymous_namespace_58.FunctionCallbackWrapper.FunctionCallbackWrapper (ANY)
102958,METHOD,v8impl.anonymous_namespace_50.FunctionCallbackWrapper,TYPE_DECL,"napi_value GetNewTarget() override {
    if (_cbinfo.IsConstructCall()) {
      return v8impl::JsValueFromV8LocalValue(_cbinfo.NewTarget());
    } else {
      return nullptr;
    }
  }",3,3,js_native_api_v8.cc,v8impl.anonymous_namespace_59.FunctionCallbackWrapper.GetNewTarget,,false,498,504,GetNewTarget,,,5,napi_value v8impl.anonymous_namespace_59.FunctionCallbackWrapper.GetNewTarget ()
102981,METHOD,v8impl.anonymous_namespace_50.FunctionCallbackWrapper,TYPE_DECL,"void Args(napi_value* buffer, size_t buffer_length) override {
    size_t i = 0;
    size_t min = std::min(buffer_length, _args_length);

    for (; i < min; i += 1) {
      buffer[i] = v8impl::JsValueFromV8LocalValue(_cbinfo[i]);
    }

    if (i < buffer_length) {
      napi_value undefined =
          v8impl::JsValueFromV8LocalValue(v8::Undefined(_cbinfo.GetIsolate()));
      for (; i < buffer_length; i += 1) {
        buffer[i] = undefined;
      }
    }
  }",3,3,js_native_api_v8.cc,v8impl.anonymous_namespace_60.FunctionCallbackWrapper.Args,,false,507,522,Args,,,6,"void v8impl.anonymous_namespace_60.FunctionCallbackWrapper.Args (napi_value*,size_t)"
103054,METHOD,v8impl.anonymous_namespace_50.FunctionCallbackWrapper,TYPE_DECL,"void SetReturnValue(napi_value value) override {
    v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
    _cbinfo.GetReturnValue().Set(val);
  }",3,3,js_native_api_v8.cc,v8impl.anonymous_namespace_61.FunctionCallbackWrapper.SetReturnValue,,false,525,528,SetReturnValue,,,7,void v8impl.anonymous_namespace_61.FunctionCallbackWrapper.SetReturnValue (napi_value)
103082,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"inline napi_status Wrap(napi_env env,
                        napi_value js_object,
                        void* native_object,
                        napi_finalize finalize_cb,
                        void* finalize_hint,
                        napi_ref* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, js_object);

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(js_object);
  RETURN_STATUS_IF_FALSE(env, value->IsObject(), napi_invalid_arg);
  v8::Local<v8::Object> obj = value.As<v8::Object>();

  // If we've already wrapped this object, we error out.
  RETURN_STATUS_IF_FALSE(
      env,
      !obj->HasPrivate(context, NAPI_PRIVATE_KEY(context, wrapper)).FromJust(),
      napi_invalid_arg);

  v8impl::Reference* reference = nullptr;
  if (result != nullptr) {
    // The returned reference should be deleted via napi_delete_reference()
    // ONLY in response to the finalize callback invocation. (If it is deleted
  ...",1,2,js_native_api_v8.cc,v8impl.anonymous_namespace_62.Wrap,,false,531,585,Wrap,,,23,"napi_status v8impl.anonymous_namespace_62.Wrap (napi_env,napi_value,void*,napi_finalize,void*,napi_ref*)"
103385,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"inline bool CanBeHeldWeakly(v8::Local<v8::Value> value) {
  return value->IsObject() || value->IsSymbol();
}",1,1,js_native_api_v8.cc,v8impl.anonymous_namespace_63.CanBeHeldWeakly,,false,595,597,CanBeHeldWeakly,,,24,bool v8impl.anonymous_namespace_63.CanBeHeldWeakly (ANY)
103400,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"void Finalizer::ResetFinalizer() {
  finalize_callback_ = nullptr;
  finalize_data_ = nullptr;
  finalize_hint_ = nullptr;
}",1,1,js_native_api_v8.cc,v8impl.Finalizer.ResetFinalizer,,false,601,605,ResetFinalizer,,,2,void v8impl.Finalizer.ResetFinalizer ()
103413,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"RefBase::RefBase(napi_env env,
                 uint32_t initial_refcount,
                 Ownership ownership,
                 napi_finalize finalize_callback,
                 void* finalize_data,
                 void* finalize_hint)
    : Finalizer(env, finalize_callback, finalize_data, finalize_hint),
      refcount_(initial_refcount),
      ownership_(ownership) {
  Link(finalize_callback == nullptr ? &env->reflist : &env->finalizing_reflist);
}",1,1,js_native_api_v8.cc,v8impl.RefBase.RefBase,,false,608,618,RefBase,,,3,"ANY v8impl.RefBase.RefBase (napi_env,uint32_t,Ownership,napi_finalize,void*,void*)"
103436,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"RefBase::~RefBase() {
  // Remove from the env's tracked list.
  Unlink();
  // Try to remove the finalizer from the scheduled second pass callback.
  env_->DequeueFinalizer(this);
}",1,1,js_native_api_v8.cc,v8impl.RefBase.~RefBase,,false,622,627,~RefBase,,,4,ANY v8impl.RefBase.~RefBase ()
103446,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"RefBase* RefBase::New(napi_env env,
                      uint32_t initial_refcount,
                      Ownership ownership,
                      napi_finalize finalize_callback,
                      void* finalize_data,
                      void* finalize_hint) {
  return new RefBase(env,
                     initial_refcount,
                     ownership,
                     finalize_callback,
                     finalize_data,
                     finalize_hint);
}",1,1,js_native_api_v8.cc,v8impl.RefBase.New,,false,629,641,New,,,5,"RefBase v8impl.RefBase.New (napi_env,uint32_t,Ownership,napi_finalize,void*,void*)"
103465,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"void* RefBase::Data() {
  return finalize_data_;
}",1,1,js_native_api_v8.cc,v8impl.RefBase.Data,,false,643,645,Data,,,6,void* v8impl.RefBase.Data ()
103471,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"uint32_t RefBase::Ref() {
  return ++refcount_;
}",1,1,js_native_api_v8.cc,v8impl.RefBase.Ref,,false,647,649,Ref,,,7,uint32_t v8impl.RefBase.Ref ()
103478,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"uint32_t RefBase::Unref() {
  if (refcount_ == 0) {
    return 0;
  }
  return --refcount_;
}",1,1,js_native_api_v8.cc,v8impl.RefBase.Unref,,false,651,656,Unref,,,8,uint32_t v8impl.RefBase.Unref ()
103492,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"uint32_t RefBase::RefCount() {
  return refcount_;
}",1,1,js_native_api_v8.cc,v8impl.RefBase.RefCount,,false,658,660,RefCount,,,9,uint32_t v8impl.RefBase.RefCount ()
103498,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"void RefBase::Finalize() {
  Ownership ownership = ownership_;
  // Swap out the field finalize_callback so that it can not be accidentally
  // called more than once.
  napi_finalize finalize_callback = finalize_callback_;
  void* finalize_data = finalize_data_;
  void* finalize_hint = finalize_hint_;
  ResetFinalizer();

  // Either the RefBase is going to be deleted in the finalize_callback or not,
  // it should be removed from the tracked list.
  Unlink();
  // 1. If the finalize_callback is present, it should either delete the
  //    RefBase, or set ownership with Ownership::kRuntime.
  // 2. If the finalizer is not present, the RefBase can be deleted after the
  //    call.
  if (finalize_callback != nullptr) {
    env_->CallFinalizer(finalize_callback, finalize_data, finalize_hint);
    // No access to `this` after finalize_callback is called.
  }

  // If the RefBase is not Ownership::kRuntime, userland code should delete it.
  // Now delete it if it is Ownership::kRuntime...",1,1,js_native_api_v8.cc,v8impl.RefBase.Finalize,,false,662,688,Finalize,,,10,void v8impl.RefBase.Finalize ()
103541,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"Reference::Reference(napi_env env, v8::Local<v8::Value> value, Args&&... args)
    : RefBase(env, std::forward<Args>(args)...),
      persistent_(env->isolate, value),
      can_be_weak_(CanBeHeldWeakly(value)) {
  if (RefCount() == 0) {
    SetWeak();
  }
}",1,1,js_native_api_v8.cc,v8impl.Reference.Reference,,false,691,698,Reference,,,11,"ANY v8impl.Reference.Reference<Args> (napi_env,ANY,Args)"
103554,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"Reference::~Reference() {
  // Reset the handle. And no weak callback will be invoked.
  persistent_.Reset();
}",1,1,js_native_api_v8.cc,v8impl.Reference.~Reference,,false,700,703,~Reference,,,12,ANY v8impl.Reference.~Reference ()
103562,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"Reference* Reference::New(napi_env env,
                          v8::Local<v8::Value> value,
                          uint32_t initial_refcount,
                          Ownership ownership,
                          napi_finalize finalize_callback,
                          void* finalize_data,
                          void* finalize_hint) {
  return new Reference(env,
                       value,
                       initial_refcount,
                       ownership,
                       finalize_callback,
                       finalize_data,
                       finalize_hint);
}",1,1,js_native_api_v8.cc,v8impl.Reference.New,,false,705,719,New,,,13,"Reference v8impl.Reference.New (napi_env,ANY,uint32_t,Ownership,napi_finalize,void*,void*)"
103583,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"uint32_t Reference::Ref() {
  // When the persistent_ is cleared in the WeakCallback, and a second pass
  // callback is pending, return 0 unconditionally.
  if (persistent_.IsEmpty()) {
    return 0;
  }
  uint32_t refcount = RefBase::Ref();
  if (refcount == 1 && can_be_weak_) {
    persistent_.ClearWeak();
  }
  return refcount;
}",1,1,js_native_api_v8.cc,v8impl.Reference.Ref,,false,721,732,Ref,,,14,uint32_t v8impl.Reference.Ref ()
103615,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"uint32_t Reference::Unref() {
  // When the persistent_ is cleared in the WeakCallback, and a second pass
  // callback is pending, return 0 unconditionally.
  if (persistent_.IsEmpty()) {
    return 0;
  }
  uint32_t old_refcount = RefCount();
  uint32_t refcount = RefBase::Unref();
  if (old_refcount == 1 && refcount == 0) {
    SetWeak();
  }
  return refcount;
}",1,1,js_native_api_v8.cc,v8impl.Reference.Unref,,false,734,746,Unref,,,15,uint32_t v8impl.Reference.Unref ()
103650,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"v8::Local<v8::Value> Reference::Get() {
  if (persistent_.IsEmpty()) {
    return v8::Local<v8::Value>();
  } else {
    return v8::Local<v8::Value>::New(env_->isolate, persistent_);
  }
}",1,1,js_native_api_v8.cc,v8impl.Reference.Get,,false,748,754,Get,,,16,Local<v8::Value> v8impl.Reference.Get ()
103684,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"void Reference::Finalize() {
  // Unconditionally reset the persistent handle so that no weak callback will
  // be invoked again.
  persistent_.Reset();

  // Chain up to perform the rest of the finalization.
  RefBase::Finalize();
}",1,1,js_native_api_v8.cc,v8impl.Reference.Finalize,,false,756,763,Finalize,,,17,void v8impl.Reference.Finalize ()
103696,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"void Reference::SetWeak() {
  if (can_be_weak_) {
    persistent_.SetWeak(this, WeakCallback, v8::WeakCallbackType::kParameter);
  } else {
    persistent_.Reset();
  }
}",1,1,js_native_api_v8.cc,v8impl.Reference.SetWeak,,false,767,773,SetWeak,,,18,void v8impl.Reference.SetWeak ()
103720,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"void Reference::WeakCallback(const v8::WeakCallbackInfo<Reference>& data) {
  Reference* reference = data.GetParameter();
  // The reference must be reset during the weak callback as the API protocol.
  reference->persistent_.Reset();
  reference->env_->EnqueueFinalizer(reference);
}",1,1,js_native_api_v8.cc,v8impl.Reference.WeakCallback,,false,778,783,WeakCallback,,,19,void v8impl.Reference.WeakCallback (ANY)
103773,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_get_last_error_info(
    napi_env env, const napi_extended_error_info** result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  // The value of the constant below must be updated to reference the last
  // message in the `napi_status` enum each time a new error message is added.
  // We don't have a napi_status_last as this would result in an ABI
  // change each time a message was added.
  const int last_status = napi_cannot_run_js;

  static_assert(NAPI_ARRAYSIZE(error_messages) == last_status + 1,
                ""Count of error messages must match count of error values"");
  CHECK_LE(env->last_error.error_code, last_status);
  // Wait until someone requests the last error information to fetch the error
  // message string
  env->last_error.error_message = error_messages[env->last_error.error_code];

  if (env->last_error.error_code == napi_ok) {
    napi_clear_last_error(env);
  }
  *result = &(env->last_error);
  return napi_ok;
}",1,12,js_native_api_v8.cc,napi_get_last_error_info,,false,815,838,napi_get_last_error_info,,,4,"napi_status napi_get_last_error_info (napi_env,napi_extended_error_info**)"
103867,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_create_function(napi_env env,
                                            const char* utf8name,
                                            size_t length,
                                            napi_callback cb,
                                            void* callback_data,
                                            napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);
  CHECK_ARG(env, cb);

  v8::Local<v8::Function> return_value;
  v8::EscapableHandleScope scope(env->isolate);
  v8::Local<v8::Function> fn;
  STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
      env, cb, callback_data, &fn));
  return_value = scope.Escape(fn);

  if (utf8name != nullptr) {
    v8::Local<v8::String> name_string;
    CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length);
    return_value->SetName(name_string);
  }

  *result = v8impl::JsValueFromV8LocalValue(return_value);

  return GET_RETURN_STATUS(env);
}",1,12,js_native_api_v8.cc,napi_create_function,,false,840,866,napi_create_function,,,5,"napi_status napi_create_function (napi_env,char*,size_t,napi_callback,void*,napi_value*)"
104154,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL
napi_define_class(napi_env env,
                  const char* utf8name,
                  size_t length,
                  napi_callback constructor,
                  void* callback_data,
                  size_t property_count,
                  const napi_property_descriptor* properties,
                  napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);
  CHECK_ARG(env, constructor);

  if (property_count > 0) {
    CHECK_ARG(env, properties);
  }

  v8::Isolate* isolate = env->isolate;

  v8::EscapableHandleScope scope(isolate);
  v8::Local<v8::FunctionTemplate> tpl;
  STATUS_CALL(v8impl::FunctionCallbackWrapper::NewTemplate(
      env, constructor, callback_data, &tpl));

  v8::Local<v8::String> name_string;
  CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length);
  tpl->SetClassName(name_string);

  size_t static_property_count = 0;
  for (size_t i = 0; i < property_count; i++) {
    const napi_property_descriptor* p = properti...",1,12,js_native_api_v8.cc,napi_define_class,,false,868,965,napi_define_class,,,6,"napi_status napi_define_class (napi_env,char*,size_t,napi_callback,void*,size_t,napi_property_descriptor*,napi_value*)"
104839,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_get_property_names(napi_env env,
                                               napi_value object,
                                               napi_value* result) {
  return napi_get_all_property_names(
      env,
      object,
      napi_key_include_prototypes,
      static_cast<napi_key_filter>(napi_key_enumerable | napi_key_skip_symbols),
      napi_key_numbers_to_strings,
      result);
}",1,12,js_native_api_v8.cc,napi_get_property_names,,false,967,977,napi_get_property_names,,,7,"napi_status napi_get_property_names (napi_env,napi_value,napi_value*)"
104858,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL
napi_get_all_property_names(napi_env env,
                            napi_value object,
                            napi_key_collection_mode key_mode,
                            napi_key_filter key_filter,
                            napi_key_conversion key_conversion,
                            napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;
  CHECK_TO_OBJECT(env, context, obj, object);

  v8::PropertyFilter filter = v8::PropertyFilter::ALL_PROPERTIES;
  if (key_filter & napi_key_writable) {
    filter = static_cast<v8::PropertyFilter>(filter |
                                             v8::PropertyFilter::ONLY_WRITABLE);
  }
  if (key_filter & napi_key_enumerable) {
    filter = static_cast<v8::PropertyFilter>(
        filter | v8::PropertyFilter::ONLY_ENUMERABLE);
  }
  if (key_filter & napi_key_configurable) {
    filter = static_cast<v8::PropertyFil...",1,12,js_native_api_v8.cc,napi_get_all_property_names,,false,979,1052,napi_get_all_property_names,,,8,"napi_status napi_get_all_property_names (napi_env,napi_value,napi_key_collection_mode,napi_key_filter,napi_key_conversion,napi_value*)"
105239,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_set_property(napi_env env,
                                         napi_value object,
                                         napi_value key,
                                         napi_value value) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, key);
  CHECK_ARG(env, value);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Local<v8::Value> k = v8impl::V8LocalValueFromJsValue(key);
  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  v8::Maybe<bool> set_maybe = obj->Set(context, k, val);

  RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure);
  return GET_RETURN_STATUS(env);
}",1,12,js_native_api_v8.cc,napi_set_property,,false,1054,1074,napi_set_property,,,9,"napi_status napi_set_property (napi_env,napi_value,napi_value,napi_value)"
105493,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_has_property(napi_env env,
                                         napi_value object,
                                         napi_value key,
                                         bool* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);
  CHECK_ARG(env, key);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Local<v8::Value> k = v8impl::V8LocalValueFromJsValue(key);
  v8::Maybe<bool> has_maybe = obj->Has(context, k);

  CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure);

  *result = has_maybe.FromMaybe(false);
  return GET_RETURN_STATUS(env);
}",1,12,js_native_api_v8.cc,napi_has_property,,false,1076,1096,napi_has_property,,,10,"napi_status napi_has_property (napi_env,napi_value,napi_value,bool*)"
105735,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_get_property(napi_env env,
                                         napi_value object,
                                         napi_value key,
                                         napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, key);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Value> k = v8impl::V8LocalValueFromJsValue(key);
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  auto get_maybe = obj->Get(context, k);

  CHECK_MAYBE_EMPTY(env, get_maybe, napi_generic_failure);

  v8::Local<v8::Value> val = get_maybe.ToLocalChecked();
  *result = v8impl::JsValueFromV8LocalValue(val);
  return GET_RETURN_STATUS(env);
}",1,12,js_native_api_v8.cc,napi_get_property,,false,1098,1119,napi_get_property,,,11,"napi_status napi_get_property (napi_env,napi_value,napi_value,napi_value*)"
105991,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_delete_property(napi_env env,
                                            napi_value object,
                                            napi_value key,
                                            bool* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, key);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Value> k = v8impl::V8LocalValueFromJsValue(key);
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);
  v8::Maybe<bool> delete_maybe = obj->Delete(context, k);
  CHECK_MAYBE_NOTHING(env, delete_maybe, napi_generic_failure);

  if (result != nullptr) *result = delete_maybe.FromMaybe(false);

  return GET_RETURN_STATUS(env);
}",1,12,js_native_api_v8.cc,napi_delete_property,,false,1121,1139,napi_delete_property,,,12,"napi_status napi_delete_property (napi_env,napi_value,napi_value,bool*)"
106221,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_has_own_property(napi_env env,
                                             napi_value object,
                                             napi_value key,
                                             bool* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, key);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);
  v8::Local<v8::Value> k = v8impl::V8LocalValueFromJsValue(key);
  RETURN_STATUS_IF_FALSE(env, k->IsName(), napi_name_expected);
  v8::Maybe<bool> has_maybe = obj->HasOwnProperty(context, k.As<v8::Name>());
  CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure);
  *result = has_maybe.FromMaybe(false);

  return GET_RETURN_STATUS(env);
}",1,12,js_native_api_v8.cc,napi_has_own_property,,false,1141,1160,napi_has_own_property,,,13,"napi_status napi_has_own_property (napi_env,napi_value,napi_value,bool*)"
106488,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_set_named_property(napi_env env,
                                               napi_value object,
                                               const char* utf8name,
                                               napi_value value) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, value);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Local<v8::Name> key;
  CHECK_NEW_FROM_UTF8(env, key, utf8name);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  v8::Maybe<bool> set_maybe = obj->Set(context, key, val);

  RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure);
  return GET_RETURN_STATUS(env);
}",1,12,js_native_api_v8.cc,napi_set_named_property,,false,1162,1183,napi_set_named_property,,,14,"napi_status napi_set_named_property (napi_env,napi_value,char*,napi_value)"
106808,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_has_named_property(napi_env env,
                                               napi_value object,
                                               const char* utf8name,
                                               bool* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Local<v8::Name> key;
  CHECK_NEW_FROM_UTF8(env, key, utf8name);

  v8::Maybe<bool> has_maybe = obj->Has(context, key);

  CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure);

  *result = has_maybe.FromMaybe(false);
  return GET_RETURN_STATUS(env);
}",1,12,js_native_api_v8.cc,napi_has_named_property,,false,1185,1206,napi_has_named_property,,,15,"napi_status napi_has_named_property (napi_env,napi_value,char*,bool*)"
107116,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_get_named_property(napi_env env,
                                               napi_value object,
                                               const char* utf8name,
                                               napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Name> key;
  CHECK_NEW_FROM_UTF8(env, key, utf8name);

  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  auto get_maybe = obj->Get(context, key);

  CHECK_MAYBE_EMPTY(env, get_maybe, napi_generic_failure);

  v8::Local<v8::Value> val = get_maybe.ToLocalChecked();
  *result = v8impl::JsValueFromV8LocalValue(val);
  return GET_RETURN_STATUS(env);
}",1,12,js_native_api_v8.cc,napi_get_named_property,,false,1208,1231,napi_get_named_property,,,16,"napi_status napi_get_named_property (napi_env,napi_value,char*,napi_value*)"
107438,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_set_element(napi_env env,
                                        napi_value object,
                                        uint32_t index,
                                        napi_value value) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, value);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  auto set_maybe = obj->Set(context, index, val);

  RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure);

  return GET_RETURN_STATUS(env);
}",1,12,js_native_api_v8.cc,napi_set_element,,false,1233,1251,napi_set_element,,,17,"napi_status napi_set_element (napi_env,napi_value,uint32_t,napi_value)"
107660,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_has_element(napi_env env,
                                        napi_value object,
                                        uint32_t index,
                                        bool* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Maybe<bool> has_maybe = obj->Has(context, index);

  CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure);

  *result = has_maybe.FromMaybe(false);
  return GET_RETURN_STATUS(env);
}",1,12,js_native_api_v8.cc,napi_has_element,,false,1253,1271,napi_has_element,,,18,"napi_status napi_has_element (napi_env,napi_value,uint32_t,bool*)"
107870,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_get_element(napi_env env,
                                        napi_value object,
                                        uint32_t index,
                                        napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  auto get_maybe = obj->Get(context, index);

  CHECK_MAYBE_EMPTY(env, get_maybe, napi_generic_failure);

  *result = v8impl::JsValueFromV8LocalValue(get_maybe.ToLocalChecked());
  return GET_RETURN_STATUS(env);
}",1,12,js_native_api_v8.cc,napi_get_element,,false,1273,1291,napi_get_element,,,19,"napi_status napi_get_element (napi_env,napi_value,uint32_t,napi_value*)"
108083,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_delete_element(napi_env env,
                                           napi_value object,
                                           uint32_t index,
                                           bool* result) {
  NAPI_PREAMBLE(env);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);
  v8::Maybe<bool> delete_maybe = obj->Delete(context, index);
  CHECK_MAYBE_NOTHING(env, delete_maybe, napi_generic_failure);

  if (result != nullptr) *result = delete_maybe.FromMaybe(false);

  return GET_RETURN_STATUS(env);
}",1,12,js_native_api_v8.cc,napi_delete_element,,false,1293,1309,napi_delete_element,,,20,"napi_status napi_delete_element (napi_env,napi_value,uint32_t,bool*)"
108281,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL
napi_define_properties(napi_env env,
                       napi_value object,
                       size_t property_count,
                       const napi_property_descriptor* properties) {
  NAPI_PREAMBLE(env);
  if (property_count > 0) {
    CHECK_ARG(env, properties);
  }

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Object> obj;
  CHECK_TO_OBJECT(env, context, obj, object);

  for (size_t i = 0; i < property_count; i++) {
    const napi_property_descriptor* p = &properties[i];

    v8::Local<v8::Name> property_name;
    STATUS_CALL(v8impl::V8NameFromPropertyDescriptor(env, p, &property_name));

    if (p->getter != nullptr || p->setter != nullptr) {
      v8::Local<v8::Function> local_getter;
      v8::Local<v8::Function> local_setter;

      if (p->getter != nullptr) {
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
            env, p->getter, p->data, &local_getter));
      }
      if (p->setter != nullptr) {
...",1,12,js_native_api_v8.cc,napi_define_properties,,false,1311,1399,napi_define_properties,,,21,"napi_status napi_define_properties (napi_env,napi_value,size_t,napi_property_descriptor*)"
108887,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_object_freeze(napi_env env, napi_value object) {
  NAPI_PREAMBLE(env);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Maybe<bool> set_frozen =
      obj->SetIntegrityLevel(context, v8::IntegrityLevel::kFrozen);

  RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, set_frozen.FromMaybe(false), napi_generic_failure);

  return GET_RETURN_STATUS(env);
}",1,12,js_native_api_v8.cc,napi_object_freeze,,false,1401,1416,napi_object_freeze,,,22,"napi_status napi_object_freeze (napi_env,napi_value)"
109084,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_object_seal(napi_env env, napi_value object) {
  NAPI_PREAMBLE(env);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Maybe<bool> set_sealed =
      obj->SetIntegrityLevel(context, v8::IntegrityLevel::kSealed);

  RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, set_sealed.FromMaybe(false), napi_generic_failure);

  return GET_RETURN_STATUS(env);
}",1,12,js_native_api_v8.cc,napi_object_seal,,false,1418,1433,napi_object_seal,,,23,"napi_status napi_object_seal (napi_env,napi_value)"
109281,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_is_array(napi_env env,
                                     napi_value value,
                                     bool* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  *result = val->IsArray();
  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_is_array,,false,1435,1446,napi_is_array,,,24,"napi_status napi_is_array (napi_env,napi_value,bool*)"
109360,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_get_array_length(napi_env env,
                                             napi_value value,
                                             uint32_t* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsArray(), napi_array_expected);

  v8::Local<v8::Array> arr = val.As<v8::Array>();
  *result = arr->Length();

  return GET_RETURN_STATUS(env);
}",1,12,js_native_api_v8.cc,napi_get_array_length,,false,1448,1462,napi_get_array_length,,,25,"napi_status napi_get_array_length (napi_env,napi_value,uint32_t*)"
109528,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_strict_equals(napi_env env,
                                          napi_value lhs,
                                          napi_value rhs,
                                          bool* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, lhs);
  CHECK_ARG(env, rhs);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> a = v8impl::V8LocalValueFromJsValue(lhs);
  v8::Local<v8::Value> b = v8impl::V8LocalValueFromJsValue(rhs);

  *result = a->StrictEquals(b);
  return GET_RETURN_STATUS(env);
}",1,12,js_native_api_v8.cc,napi_strict_equals,,false,1464,1478,napi_strict_equals,,,26,"napi_status napi_strict_equals (napi_env,napi_value,napi_value,bool*)"
109694,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_get_prototype(napi_env env,
                                          napi_value object,
                                          napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Object> obj;
  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Local<v8::Value> val = obj->GetPrototype();
  *result = v8impl::JsValueFromV8LocalValue(val);
  return GET_RETURN_STATUS(env);
}",1,12,js_native_api_v8.cc,napi_get_prototype,,false,1480,1494,napi_get_prototype,,,27,"napi_status napi_get_prototype (napi_env,napi_value,napi_value*)"
109888,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_create_object(napi_env env, napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(v8::Object::New(env->isolate));

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_create_object,,false,1496,1503,napi_create_object,,,28,"napi_status napi_create_object (napi_env,napi_value*)"
109943,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_create_array(napi_env env, napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(v8::Array::New(env->isolate));

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_create_array,,false,1505,1512,napi_create_array,,,29,"napi_status napi_create_array (napi_env,napi_value*)"
109998,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_create_array_with_length(napi_env env,
                                                     size_t length,
                                                     napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result =
      v8impl::JsValueFromV8LocalValue(v8::Array::New(env->isolate, length));

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_create_array_with_length,,false,1514,1524,napi_create_array_with_length,,,30,"napi_status napi_create_array_with_length (napi_env,size_t,napi_value*)"
110055,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_create_string_latin1(napi_env env,
                                                 const char* str,
                                                 size_t length,
                                                 napi_value* result) {
  return v8impl::NewString(env, str, length, result, [&](v8::Isolate* isolate) {
    return v8::String::NewFromOneByte(isolate,
                                      reinterpret_cast<const uint8_t*>(str),
                                      v8::NewStringType::kNormal,
                                      length);
  });
}",1,12,js_native_api_v8.cc,napi_create_string_latin1,,false,1526,1536,napi_create_string_latin1,,,31,"napi_status napi_create_string_latin1 (napi_env,char*,size_t,napi_value*)"
110071,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_create_string_utf8(napi_env env,
                                               const char* str,
                                               size_t length,
                                               napi_value* result) {
  return v8impl::NewString(env, str, length, result, [&](v8::Isolate* isolate) {
    return v8::String::NewFromUtf8(
        isolate, str, v8::NewStringType::kNormal, static_cast<int>(length));
  });
}",1,12,js_native_api_v8.cc,napi_create_string_utf8,,false,1538,1546,napi_create_string_utf8,,,32,"napi_status napi_create_string_utf8 (napi_env,char*,size_t,napi_value*)"
110087,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_create_string_utf16(napi_env env,
                                                const char16_t* str,
                                                size_t length,
                                                napi_value* result) {
  return v8impl::NewString(env, str, length, result, [&](v8::Isolate* isolate) {
    return v8::String::NewFromTwoByte(isolate,
                                      reinterpret_cast<const uint16_t*>(str),
                                      v8::NewStringType::kNormal,
                                      length);
  });
}",1,12,js_native_api_v8.cc,napi_create_string_utf16,,false,1548,1558,napi_create_string_utf16,,,33,"napi_status napi_create_string_utf16 (napi_env,char16_t*,size_t,napi_value*)"
110103,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL
node_api_create_external_string_latin1(napi_env env,
                                       char* str,
                                       size_t length,
                                       napi_finalize finalize_callback,
                                       void* finalize_hint,
                                       napi_value* result,
                                       bool* copied) {
  return v8impl::NewExternalString(
      env,
      str,
      length,
      finalize_callback,
      finalize_hint,
      result,
      copied,
      napi_create_string_latin1,
      [&](v8::Isolate* isolate) {
        if (length == NAPI_AUTO_LENGTH) {
          length = (std::string_view(str)).length();
        }
        auto resource = new v8impl::ExternalOneByteStringResource(
            env, str, length, finalize_callback, finalize_hint);
        return v8::String::NewExternalOneByte(isolate, resource);
      });
}",1,12,js_native_api_v8.cc,node_api_create_external_string_latin1,,false,1560,1585,node_api_create_external_string_latin1,,,34,"napi_status node_api_create_external_string_latin1 (napi_env,char*,size_t,napi_finalize,void*,napi_value*,bool*)"
110123,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL
node_api_create_external_string_utf16(napi_env env,
                                      char16_t* str,
                                      size_t length,
                                      napi_finalize finalize_callback,
                                      void* finalize_hint,
                                      napi_value* result,
                                      bool* copied) {
  return v8impl::NewExternalString(
      env,
      str,
      length,
      finalize_callback,
      finalize_hint,
      result,
      copied,
      napi_create_string_utf16,
      [&](v8::Isolate* isolate) {
        if (length == NAPI_AUTO_LENGTH) {
          length = (std::u16string_view(str)).length();
        }
        auto resource = new v8impl::ExternalStringResource(
            env, str, length, finalize_callback, finalize_hint);
        return v8::String::NewExternalTwoByte(isolate, resource);
      });
}",1,12,js_native_api_v8.cc,node_api_create_external_string_utf16,,false,1587,1612,node_api_create_external_string_utf16,,,35,"napi_status node_api_create_external_string_utf16 (napi_env,char16_t*,size_t,napi_finalize,void*,napi_value*,bool*)"
110143,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_create_double(napi_env env,
                                          double value,
                                          napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result =
      v8impl::JsValueFromV8LocalValue(v8::Number::New(env->isolate, value));

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_create_double,,false,1614,1624,napi_create_double,,,36,"napi_status napi_create_double (napi_env,double,napi_value*)"
110200,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_create_int32(napi_env env,
                                         int32_t value,
                                         napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result =
      v8impl::JsValueFromV8LocalValue(v8::Integer::New(env->isolate, value));

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_create_int32,,false,1626,1636,napi_create_int32,,,37,"napi_status napi_create_int32 (napi_env,int32_t,napi_value*)"
110257,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_create_uint32(napi_env env,
                                          uint32_t value,
                                          napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(
      v8::Integer::NewFromUnsigned(env->isolate, value));

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_create_uint32,,false,1638,1648,napi_create_uint32,,,38,"napi_status napi_create_uint32 (napi_env,uint32_t,napi_value*)"
110314,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_create_int64(napi_env env,
                                         int64_t value,
                                         napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(
      v8::Number::New(env->isolate, static_cast<double>(value)));

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_create_int64,,false,1650,1660,napi_create_int64,,,39,"napi_status napi_create_int64 (napi_env,int64_t,napi_value*)"
110373,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_create_bigint_int64(napi_env env,
                                                int64_t value,
                                                napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result =
      v8impl::JsValueFromV8LocalValue(v8::BigInt::New(env->isolate, value));

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_create_bigint_int64,,false,1662,1672,napi_create_bigint_int64,,,40,"napi_status napi_create_bigint_int64 (napi_env,int64_t,napi_value*)"
110430,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_create_bigint_uint64(napi_env env,
                                                 uint64_t value,
                                                 napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(
      v8::BigInt::NewFromUnsigned(env->isolate, value));

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_create_bigint_uint64,,false,1674,1684,napi_create_bigint_uint64,,,41,"napi_status napi_create_bigint_uint64 (napi_env,uint64_t,napi_value*)"
110487,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_create_bigint_words(napi_env env,
                                                int sign_bit,
                                                size_t word_count,
                                                const uint64_t* words,
                                                napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, words);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();

  RETURN_STATUS_IF_FALSE(env, word_count <= INT_MAX, napi_invalid_arg);

  v8::MaybeLocal<v8::BigInt> b =
      v8::BigInt::NewFromWords(context, sign_bit, word_count, words);

  CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, b, napi_generic_failure);

  *result = v8impl::JsValueFromV8LocalValue(b.ToLocalChecked());
  return GET_RETURN_STATUS(env);
}",1,12,js_native_api_v8.cc,napi_create_bigint_words,,false,1686,1706,napi_create_bigint_words,,,42,"napi_status napi_create_bigint_words (napi_env,int,size_t,uint64_t*,napi_value*)"
110687,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_get_boolean(napi_env env,
                                        bool value,
                                        napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  v8::Isolate* isolate = env->isolate;

  if (value) {
    *result = v8impl::JsValueFromV8LocalValue(v8::True(isolate));
  } else {
    *result = v8impl::JsValueFromV8LocalValue(v8::False(isolate));
  }

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_get_boolean,,false,1708,1723,napi_get_boolean,,,43,"napi_status napi_get_boolean (napi_env,bool,napi_value*)"
110762,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_create_symbol(napi_env env,
                                          napi_value description,
                                          napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  v8::Isolate* isolate = env->isolate;

  if (description == nullptr) {
    *result = v8impl::JsValueFromV8LocalValue(v8::Symbol::New(isolate));
  } else {
    v8::Local<v8::Value> desc = v8impl::V8LocalValueFromJsValue(description);
    RETURN_STATUS_IF_FALSE(env, desc->IsString(), napi_string_expected);

    *result = v8impl::JsValueFromV8LocalValue(
        v8::Symbol::New(isolate, desc.As<v8::String>()));
  }

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_create_symbol,,false,1725,1744,napi_create_symbol,,,44,"napi_status napi_create_symbol (napi_env,napi_value,napi_value*)"
110884,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL node_api_symbol_for(napi_env env,
                                           const char* utf8description,
                                           size_t length,
                                           napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  napi_value js_description_string;
  STATUS_CALL(napi_create_string_utf8(
      env, utf8description, length, &js_description_string));
  v8::Local<v8::String> description_string =
      v8impl::V8LocalValueFromJsValue(js_description_string).As<v8::String>();

  *result = v8impl::JsValueFromV8LocalValue(
      v8::Symbol::For(env->isolate, description_string));

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,node_api_symbol_for,,false,1746,1763,node_api_symbol_for,,,45,"napi_status node_api_symbol_for (napi_env,char*,size_t,napi_value*)"
110983,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"static inline napi_status set_error_code(napi_env env,
                                         v8::Local<v8::Value> error,
                                         napi_value code,
                                         const char* code_cstring) {
  if ((code != nullptr) || (code_cstring != nullptr)) {
    v8::Local<v8::Context> context = env->context();
    v8::Local<v8::Object> err_object = error.As<v8::Object>();

    v8::Local<v8::Value> code_value = v8impl::V8LocalValueFromJsValue(code);
    if (code != nullptr) {
      code_value = v8impl::V8LocalValueFromJsValue(code);
      RETURN_STATUS_IF_FALSE(env, code_value->IsString(), napi_string_expected);
    } else {
      CHECK_NEW_FROM_UTF8(env, code_value, code_cstring);
    }

    v8::Local<v8::Name> code_key;
    CHECK_NEW_FROM_UTF8(env, code_key, ""code"");

    v8::Maybe<bool> set_maybe = err_object->Set(context, code_key, code_value);
    RETURN_STATUS_IF_FALSE(
        env, set_maybe.FromMaybe(false), napi_generic_failure...",1,6,js_native_api_v8.cc,set_error_code,,false,1765,1789,set_error_code,,,46,"napi_status set_error_code (napi_env,ANY,napi_value,char*)"
111302,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_create_error(napi_env env,
                                         napi_value code,
                                         napi_value msg,
                                         napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, msg);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> message_value = v8impl::V8LocalValueFromJsValue(msg);
  RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected);

  v8::Local<v8::Value> error_obj =
      v8::Exception::Error(message_value.As<v8::String>());
  STATUS_CALL(set_error_code(env, error_obj, code, nullptr));

  *result = v8impl::JsValueFromV8LocalValue(error_obj);

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_create_error,,false,1791,1809,napi_create_error,,,47,"napi_status napi_create_error (napi_env,napi_value,napi_value,napi_value*)"
111446,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_create_type_error(napi_env env,
                                              napi_value code,
                                              napi_value msg,
                                              napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, msg);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> message_value = v8impl::V8LocalValueFromJsValue(msg);
  RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected);

  v8::Local<v8::Value> error_obj =
      v8::Exception::TypeError(message_value.As<v8::String>());
  STATUS_CALL(set_error_code(env, error_obj, code, nullptr));

  *result = v8impl::JsValueFromV8LocalValue(error_obj);

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_create_type_error,,false,1811,1829,napi_create_type_error,,,48,"napi_status napi_create_type_error (napi_env,napi_value,napi_value,napi_value*)"
111590,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_create_range_error(napi_env env,
                                               napi_value code,
                                               napi_value msg,
                                               napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, msg);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> message_value = v8impl::V8LocalValueFromJsValue(msg);
  RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected);

  v8::Local<v8::Value> error_obj =
      v8::Exception::RangeError(message_value.As<v8::String>());
  STATUS_CALL(set_error_code(env, error_obj, code, nullptr));

  *result = v8impl::JsValueFromV8LocalValue(error_obj);

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_create_range_error,,false,1831,1849,napi_create_range_error,,,49,"napi_status napi_create_range_error (napi_env,napi_value,napi_value,napi_value*)"
111734,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL node_api_create_syntax_error(napi_env env,
                                                    napi_value code,
                                                    napi_value msg,
                                                    napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, msg);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> message_value = v8impl::V8LocalValueFromJsValue(msg);
  RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected);

  v8::Local<v8::Value> error_obj =
      v8::Exception::SyntaxError(message_value.As<v8::String>());
  STATUS_CALL(set_error_code(env, error_obj, code, nullptr));

  *result = v8impl::JsValueFromV8LocalValue(error_obj);

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,node_api_create_syntax_error,,false,1851,1869,node_api_create_syntax_error,,,50,"napi_status node_api_create_syntax_error (napi_env,napi_value,napi_value,napi_value*)"
111878,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_typeof(napi_env env,
                                   napi_value value,
                                   napi_valuetype* result) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> v = v8impl::V8LocalValueFromJsValue(value);

  if (v->IsNumber()) {
    *result = napi_number;
  } else if (v->IsBigInt()) {
    *result = napi_bigint;
  } else if (v->IsString()) {
    *result = napi_string;
  } else if (v->IsFunction()) {
    // This test has to come before IsObject because IsFunction
    // implies IsObject
    *result = napi_function;
  } else if (v->IsExternal()) {
    // This test has to come before IsObject because IsExternal
    // implies IsObject
    *result = napi_external;
  } else if (v->IsObject()) {
    *result = napi_object;
  } else if (v->IsBoolean()) {
    *result = napi_boolean;
  } else if (v->I...",1,12,js_native_api_v8.cc,napi_typeof,,false,1871,1912,napi_typeof,,,51,"napi_status napi_typeof (napi_env,napi_value,napi_valuetype*)"
112074,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_get_undefined(napi_env env, napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(v8::Undefined(env->isolate));

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_get_undefined,,false,1914,1921,napi_get_undefined,,,52,"napi_status napi_get_undefined (napi_env,napi_value*)"
112127,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_get_null(napi_env env, napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(v8::Null(env->isolate));

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_get_null,,false,1923,1930,napi_get_null,,,53,"napi_status napi_get_null (napi_env,napi_value*)"
112180,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_get_cb_info(
    napi_env env,               // [in] NAPI environment handle
    napi_callback_info cbinfo,  // [in] Opaque callback-info handle
    size_t* argc,      // [in-out] Specifies the size of the provided argv array
                       // and receives the actual count of args.
    napi_value* argv,  // [out] Array of values
    napi_value* this_arg,  // [out] Receives the JS 'this' arg for the call
    void** data) {         // [out] Receives the data pointer for the callback.
  CHECK_ENV(env);
  CHECK_ARG(env, cbinfo);

  v8impl::CallbackWrapper* info =
      reinterpret_cast<v8impl::CallbackWrapper*>(cbinfo);

  if (argv != nullptr) {
    CHECK_ARG(env, argc);
    info->Args(argv, *argc);
  }
  if (argc != nullptr) {
    *argc = info->ArgsLength();
  }
  if (this_arg != nullptr) {
    *this_arg = info->This();
  }
  if (data != nullptr) {
    *data = info->Data();
  }

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_get_cb_info,,false,1933,1962,napi_get_cb_info,,,54,"napi_status napi_get_cb_info (napi_env,napi_callback_info,size_t*,napi_value*,napi_value*,void**)"
112294,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_get_new_target(napi_env env,
                                           napi_callback_info cbinfo,
                                           napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, cbinfo);
  CHECK_ARG(env, result);

  v8impl::CallbackWrapper* info =
      reinterpret_cast<v8impl::CallbackWrapper*>(cbinfo);

  *result = info->GetNewTarget();
  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_get_new_target,,false,1964,1976,napi_get_new_target,,,55,"napi_status napi_get_new_target (napi_env,napi_callback_info,napi_value*)"
112364,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_call_function(napi_env env,
                                          napi_value recv,
                                          napi_value func,
                                          size_t argc,
                                          const napi_value* argv,
                                          napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, recv);
  if (argc > 0) {
    CHECK_ARG(env, argv);
  }

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Value> v8recv = v8impl::V8LocalValueFromJsValue(recv);

  v8::Local<v8::Function> v8func;
  CHECK_TO_FUNCTION(env, v8func, func);

  auto maybe = v8func->Call(
      context,
      v8recv,
      argc,
      reinterpret_cast<v8::Local<v8::Value>*>(const_cast<napi_value*>(argv)));

  if (try_catch.HasCaught()) {
    return napi_set_last_error(env, napi_pending_exception);
  } else {
    if (result != nullptr) {
      CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure);
   ...",1,12,js_native_api_v8.cc,napi_call_function,,false,1978,2012,napi_call_function,,,56,"napi_status napi_call_function (napi_env,napi_value,napi_value,size_t,napi_value*,napi_value*)"
112628,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_get_global(napi_env env, napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(env->context()->Global());

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_get_global,,false,2014,2021,napi_get_global,,,57,"napi_status napi_get_global (napi_env,napi_value*)"
112681,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_throw(napi_env env, napi_value error) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, error);

  v8::Isolate* isolate = env->isolate;

  isolate->ThrowException(v8impl::V8LocalValueFromJsValue(error));
  // any VM calls after this point and before returning
  // to the javascript invoker will fail
  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_throw,,false,2023,2033,napi_throw,,,58,"napi_status napi_throw (napi_env,napi_value)"
112777,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_throw_error(napi_env env,
                                        const char* code,
                                        const char* msg) {
  NAPI_PREAMBLE(env);

  v8::Isolate* isolate = env->isolate;
  v8::Local<v8::String> str;
  CHECK_NEW_FROM_UTF8(env, str, msg);

  v8::Local<v8::Value> error_obj = v8::Exception::Error(str);
  STATUS_CALL(set_error_code(env, error_obj, nullptr, code));

  isolate->ThrowException(error_obj);
  // any VM calls after this point and before returning
  // to the javascript invoker will fail
  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_throw_error,,false,2035,2051,napi_throw_error,,,59,"napi_status napi_throw_error (napi_env,char*,char*)"
112989,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_throw_type_error(napi_env env,
                                             const char* code,
                                             const char* msg) {
  NAPI_PREAMBLE(env);

  v8::Isolate* isolate = env->isolate;
  v8::Local<v8::String> str;
  CHECK_NEW_FROM_UTF8(env, str, msg);

  v8::Local<v8::Value> error_obj = v8::Exception::TypeError(str);
  STATUS_CALL(set_error_code(env, error_obj, nullptr, code));

  isolate->ThrowException(error_obj);
  // any VM calls after this point and before returning
  // to the javascript invoker will fail
  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_throw_type_error,,false,2053,2069,napi_throw_type_error,,,60,"napi_status napi_throw_type_error (napi_env,char*,char*)"
113201,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_throw_range_error(napi_env env,
                                              const char* code,
                                              const char* msg) {
  NAPI_PREAMBLE(env);

  v8::Isolate* isolate = env->isolate;
  v8::Local<v8::String> str;
  CHECK_NEW_FROM_UTF8(env, str, msg);

  v8::Local<v8::Value> error_obj = v8::Exception::RangeError(str);
  STATUS_CALL(set_error_code(env, error_obj, nullptr, code));

  isolate->ThrowException(error_obj);
  // any VM calls after this point and before returning
  // to the javascript invoker will fail
  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_throw_range_error,,false,2071,2087,napi_throw_range_error,,,61,"napi_status napi_throw_range_error (napi_env,char*,char*)"
113413,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL node_api_throw_syntax_error(napi_env env,
                                                   const char* code,
                                                   const char* msg) {
  NAPI_PREAMBLE(env);

  v8::Isolate* isolate = env->isolate;
  v8::Local<v8::String> str;
  CHECK_NEW_FROM_UTF8(env, str, msg);

  v8::Local<v8::Value> error_obj = v8::Exception::SyntaxError(str);
  STATUS_CALL(set_error_code(env, error_obj, nullptr, code));

  isolate->ThrowException(error_obj);
  // any VM calls after this point and before returning
  // to the javascript invoker will fail
  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,node_api_throw_syntax_error,,false,2089,2105,node_api_throw_syntax_error,,,62,"napi_status node_api_throw_syntax_error (napi_env,char*,char*)"
113625,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_is_error(napi_env env,
                                     napi_value value,
                                     bool* result) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot
  // throw JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  *result = val->IsNativeError();

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_is_error,,false,2107,2120,napi_is_error,,,63,"napi_status napi_is_error (napi_env,napi_value,bool*)"
113704,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_get_value_double(napi_env env,
                                             napi_value value,
                                             double* result) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected);

  *result = val.As<v8::Number>()->Value();

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_get_value_double,,false,2122,2137,napi_get_value_double,,,64,"napi_status napi_get_value_double (napi_env,napi_value,double*)"
113808,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_get_value_int32(napi_env env,
                                            napi_value value,
                                            int32_t* result) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  if (val->IsInt32()) {
    *result = val.As<v8::Int32>()->Value();
  } else {
    RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected);

    // Empty context: https://github.com/nodejs/node/issues/14379
    v8::Local<v8::Context> context;
    *result = val->Int32Value(context).FromJust();
  }

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_get_value_int32,,false,2139,2161,napi_get_value_int32,,,65,"napi_status napi_get_value_int32 (napi_env,napi_value,int32_t*)"
113940,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_get_value_uint32(napi_env env,
                                             napi_value value,
                                             uint32_t* result) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  if (val->IsUint32()) {
    *result = val.As<v8::Uint32>()->Value();
  } else {
    RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected);

    // Empty context: https://github.com/nodejs/node/issues/14379
    v8::Local<v8::Context> context;
    *result = val->Uint32Value(context).FromJust();
  }

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_get_value_uint32,,false,2163,2185,napi_get_value_uint32,,,66,"napi_status napi_get_value_uint32 (napi_env,napi_value,uint32_t*)"
114072,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_get_value_int64(napi_env env,
                                            napi_value value,
                                            int64_t* result) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  // This is still a fast path very likely to be taken.
  if (val->IsInt32()) {
    *result = val.As<v8::Int32>()->Value();
    return napi_clear_last_error(env);
  }

  RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected);

  // v8::Value::IntegerValue() converts NaN, +Inf, and -Inf to INT64_MIN,
  // inconsistent with v8::Value::Int32Value() which converts those values to 0.
  // Special-case all non-finite values to match that behavior.
  double doubleValue = val.As<v8::Number>()->Value();
  if (std::isfinite(doubleValue)) {
    // Empty context: htt...",1,12,js_native_api_v8.cc,napi_get_value_int64,,false,2187,2219,napi_get_value_int64,,,67,"napi_status napi_get_value_int64 (napi_env,napi_value,int64_t*)"
114228,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_get_value_bigint_int64(napi_env env,
                                                   napi_value value,
                                                   int64_t* result,
                                                   bool* lossless) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);
  CHECK_ARG(env, lossless);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  RETURN_STATUS_IF_FALSE(env, val->IsBigInt(), napi_bigint_expected);

  *result = val.As<v8::BigInt>()->Int64Value(lossless);

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_get_value_bigint_int64,,false,2221,2237,napi_get_value_bigint_int64,,,68,"napi_status napi_get_value_bigint_int64 (napi_env,napi_value,int64_t*,bool*)"
114351,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_get_value_bigint_uint64(napi_env env,
                                                    napi_value value,
                                                    uint64_t* result,
                                                    bool* lossless) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);
  CHECK_ARG(env, lossless);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  RETURN_STATUS_IF_FALSE(env, val->IsBigInt(), napi_bigint_expected);

  *result = val.As<v8::BigInt>()->Uint64Value(lossless);

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_get_value_bigint_uint64,,false,2239,2255,napi_get_value_bigint_uint64,,,69,"napi_status napi_get_value_bigint_uint64 (napi_env,napi_value,uint64_t*,bool*)"
114474,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_get_value_bigint_words(napi_env env,
                                                   napi_value value,
                                                   int* sign_bit,
                                                   size_t* word_count,
                                                   uint64_t* words) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, word_count);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  RETURN_STATUS_IF_FALSE(env, val->IsBigInt(), napi_bigint_expected);

  v8::Local<v8::BigInt> big = val.As<v8::BigInt>();

  int word_count_int = *word_count;

  if (sign_bit == nullptr && words == nullptr) {
    word_count_int = big->WordCount();
  } else {
    CHECK_ARG(env, sign_bit);
    CHECK_ARG(env, words);
    big->ToWordsArray(sign_bit, &word_count_int, words);
  }

  *word_count = word_count_int;

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_get_value_bigint_words,,false,2257,2285,napi_get_value_bigint_words,,,70,"napi_status napi_get_value_bigint_words (napi_env,napi_value,int*,size_t*,uint64_t*)"
114652,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_get_value_bool(napi_env env,
                                           napi_value value,
                                           bool* result) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsBoolean(), napi_boolean_expected);

  *result = val.As<v8::Boolean>()->Value();

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_get_value_bool,,false,2287,2302,napi_get_value_bool,,,71,"napi_status napi_get_value_bool (napi_env,napi_value,bool*)"
114756,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_get_value_string_latin1(
    napi_env env, napi_value value, char* buf, size_t bufsize, size_t* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected);

  if (!buf) {
    CHECK_ARG(env, result);
    *result = val.As<v8::String>()->Length();
  } else if (bufsize != 0) {
    int copied =
        val.As<v8::String>()->WriteOneByte(env->isolate,
                                           reinterpret_cast<uint8_t*>(buf),
                                           0,
                                           bufsize - 1,
                                           v8::String::NO_NULL_TERMINATION);

    buf[copied] = '\0';
    if (result != nullptr) {
      *result = copied;
    }
  } else if (result != nullptr) {
    *result = 0;
  }

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_get_value_string_latin1,,false,2312,2340,napi_get_value_string_latin1,,,72,"napi_status napi_get_value_string_latin1 (napi_env,napi_value,char*,size_t,size_t*)"
114923,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_get_value_string_utf8(
    napi_env env, napi_value value, char* buf, size_t bufsize, size_t* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected);

  if (!buf) {
    CHECK_ARG(env, result);
    *result = val.As<v8::String>()->Utf8Length(env->isolate);
  } else if (bufsize != 0) {
    int copied = val.As<v8::String>()->WriteUtf8(
        env->isolate,
        buf,
        bufsize - 1,
        nullptr,
        v8::String::REPLACE_INVALID_UTF8 | v8::String::NO_NULL_TERMINATION);

    buf[copied] = '\0';
    if (result != nullptr) {
      *result = copied;
    }
  } else if (result != nullptr) {
    *result = 0;
  }

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_get_value_string_utf8,,false,2350,2378,napi_get_value_string_utf8,,,73,"napi_status napi_get_value_string_utf8 (napi_env,napi_value,char*,size_t,size_t*)"
115097,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_get_value_string_utf16(napi_env env,
                                                   napi_value value,
                                                   char16_t* buf,
                                                   size_t bufsize,
                                                   size_t* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected);

  if (!buf) {
    CHECK_ARG(env, result);
    // V8 assumes UTF-16 length is the same as the number of characters.
    *result = val.As<v8::String>()->Length();
  } else if (bufsize != 0) {
    int copied = val.As<v8::String>()->Write(env->isolate,
                                             reinterpret_cast<uint16_t*>(buf),
                                             0,
                                             bufsize - 1,
                                           ...",1,12,js_native_api_v8.cc,napi_get_value_string_utf16,,false,2388,2419,napi_get_value_string_utf16,,,74,"napi_status napi_get_value_string_utf16 (napi_env,napi_value,char16_t*,size_t,size_t*)"
115264,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_coerce_to_bool(napi_env env,
                                           napi_value value,
                                           napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Isolate* isolate = env->isolate;
  v8::Local<v8::Boolean> b =
      v8impl::V8LocalValueFromJsValue(value)->ToBoolean(isolate);
  *result = v8impl::JsValueFromV8LocalValue(b);
  return GET_RETURN_STATUS(env);
}",1,12,js_native_api_v8.cc,napi_coerce_to_bool,,false,2421,2433,napi_coerce_to_bool,,,75,"napi_status napi_coerce_to_bool (napi_env,napi_value,napi_value*)"
115407,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,43,js_native_api_v8.cc,napi_coerce_to_number,,false,2451,2451,napi_coerce_to_number,,,76,"napi_status napi_coerce_to_number (napi_env,napi_value,napi_value*)"
115583,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,43,js_native_api_v8.cc,napi_coerce_to_object,,false,2452,2452,napi_coerce_to_object,,,77,"napi_status napi_coerce_to_object (napi_env,napi_value,napi_value*)"
115759,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"GEN_COERCE_FUNCTION(STRING, String, string)",1,43,js_native_api_v8.cc,napi_coerce_to_string,,false,2453,2453,napi_coerce_to_string,,,78,"napi_status napi_coerce_to_string (napi_env,napi_value,napi_value*)"
115935,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_wrap(napi_env env,
                                 napi_value js_object,
                                 void* native_object,
                                 napi_finalize finalize_cb,
                                 void* finalize_hint,
                                 napi_ref* result) {
  return v8impl::Wrap(
      env, js_object, native_object, finalize_cb, finalize_hint, result);
}",1,12,js_native_api_v8.cc,napi_wrap,,false,2457,2465,napi_wrap,,,79,"napi_status napi_wrap (napi_env,napi_value,void*,napi_finalize,void*,napi_ref*)"
115956,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_unwrap(napi_env env,
                                   napi_value obj,
                                   void** result) {
  return v8impl::Unwrap(env, obj, result, v8impl::KeepWrap);
}",1,12,js_native_api_v8.cc,napi_unwrap,,false,2467,2471,napi_unwrap,,,80,"napi_status napi_unwrap (napi_env,napi_value,void**)"
115974,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_remove_wrap(napi_env env,
                                        napi_value obj,
                                        void** result) {
  return v8impl::Unwrap(env, obj, result, v8impl::RemoveWrap);
}",1,12,js_native_api_v8.cc,napi_remove_wrap,,false,2473,2477,napi_remove_wrap,,,81,"napi_status napi_remove_wrap (napi_env,napi_value,void**)"
115992,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_create_external(napi_env env,
                                            void* data,
                                            napi_finalize finalize_cb,
                                            void* finalize_hint,
                                            napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Isolate* isolate = env->isolate;

  v8::Local<v8::Value> external_value = v8::External::New(isolate, data);

  if (finalize_cb) {
    // The Reference object will delete itself after invoking the finalizer
    // callback.
    v8impl::Reference::New(env,
                           external_value,
                           0,
                           v8impl::Ownership::kRuntime,
                           finalize_cb,
                           data,
                           finalize_hint);
  }

  *result = v8impl::JsValueFromV8LocalValue(external_value);

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_create_external,,false,2479,2506,napi_create_external,,,82,"napi_status napi_create_external (napi_env,void*,napi_finalize,void*,napi_value*)"
116128,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_type_tag_object(napi_env env,
                                            napi_value object,
                                            const napi_type_tag* type_tag) {
  NAPI_PREAMBLE(env);
  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;
  CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object);
  CHECK_ARG_WITH_PREAMBLE(env, type_tag);

  auto key = NAPI_PRIVATE_KEY(context, type_tag);
  auto maybe_has = obj->HasPrivate(context, key);
  CHECK_MAYBE_NOTHING_WITH_PREAMBLE(env, maybe_has, napi_generic_failure);
  RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, !maybe_has.FromJust(), napi_invalid_arg);

  auto tag = v8::BigInt::NewFromWords(
      context, 0, 2, reinterpret_cast<const uint64_t*>(type_tag));
  CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, tag, napi_generic_failure);

  auto maybe_set = obj->SetPrivate(context, key, tag.ToLocalChecked());
  CHECK_MAYBE_NOTHING_WITH_PREAMBLE(env, maybe_set, napi_generic_failure);
  RE...",1,12,js_native_api_v8.cc,napi_type_tag_object,,false,2508,2533,napi_type_tag_object,,,83,"napi_status napi_type_tag_object (napi_env,napi_value,napi_type_tag*)"
116507,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_check_object_type_tag(napi_env env,
                                                  napi_value object,
                                                  const napi_type_tag* type_tag,
                                                  bool* result) {
  NAPI_PREAMBLE(env);
  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;
  CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object);
  CHECK_ARG_WITH_PREAMBLE(env, type_tag);
  CHECK_ARG_WITH_PREAMBLE(env, result);

  auto maybe_value =
      obj->GetPrivate(context, NAPI_PRIVATE_KEY(context, type_tag));
  CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, maybe_value, napi_generic_failure);
  v8::Local<v8::Value> val = maybe_value.ToLocalChecked();

  // We consider the type check to have failed unless we reach the line below
  // where we set whether the type check succeeded or not based on the
  // comparison of the two type tags.
  *result = false;
  if (val->IsBigInt()) {
    int sign;
  ...",1,12,js_native_api_v8.cc,napi_check_object_type_tag,,false,2535,2574,napi_check_object_type_tag,,,84,"napi_status napi_check_object_type_tag (napi_env,napi_value,napi_type_tag*,bool*)"
116885,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_get_value_external(napi_env env,
                                               napi_value value,
                                               void** result) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsExternal(), napi_invalid_arg);

  v8::Local<v8::External> external_value = val.As<v8::External>();
  *result = external_value->Value();

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_get_value_external,,false,2576,2590,napi_get_value_external,,,85,"napi_status napi_get_value_external (napi_env,napi_value,void**)"
117000,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_create_reference(napi_env env,
                                             napi_value value,
                                             uint32_t initial_refcount,
                                             napi_ref* result) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> v8_value = v8impl::V8LocalValueFromJsValue(value);
  if (env->module_api_version != NAPI_VERSION_EXPERIMENTAL) {
    if (!(v8_value->IsObject() || v8_value->IsFunction() ||
          v8_value->IsSymbol())) {
      return napi_set_last_error(env, napi_invalid_arg);
    }
  }

  v8impl::Reference* reference = v8impl::Reference::New(
      env, v8_value, initial_refcount, v8impl::Ownership::kUserland);

  *result = reinterpret_cast<napi_ref>(reference);
  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_create_reference,,false,2593,2616,napi_create_reference,,,86,"napi_status napi_create_reference (napi_env,napi_value,uint32_t,napi_ref*)"
117126,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_delete_reference(napi_env env, napi_ref ref) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, ref);

  delete reinterpret_cast<v8impl::Reference*>(ref);

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_delete_reference,,false,2620,2629,napi_delete_reference,,,87,"napi_status napi_delete_reference (napi_env,napi_ref)"
117169,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_reference_ref(napi_env env,
                                          napi_ref ref,
                                          uint32_t* result) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, ref);

  v8impl::Reference* reference = reinterpret_cast<v8impl::Reference*>(ref);
  uint32_t count = reference->Ref();

  if (result != nullptr) {
    *result = count;
  }

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_reference_ref,,false,2636,2652,napi_reference_ref,,,88,"napi_status napi_reference_ref (napi_env,napi_ref,uint32_t*)"
117231,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_reference_unref(napi_env env,
                                            napi_ref ref,
                                            uint32_t* result) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, ref);

  v8impl::Reference* reference = reinterpret_cast<v8impl::Reference*>(ref);

  if (reference->RefCount() == 0) {
    return napi_set_last_error(env, napi_generic_failure);
  }

  uint32_t count = reference->Unref();

  if (result != nullptr) {
    *result = count;
  }

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_reference_unref,,false,2658,2679,napi_reference_unref,,,89,"napi_status napi_reference_unref (napi_env,napi_ref,uint32_t*)"
117305,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_get_reference_value(napi_env env,
                                                napi_ref ref,
                                                napi_value* result) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, ref);
  CHECK_ARG(env, result);

  v8impl::Reference* reference = reinterpret_cast<v8impl::Reference*>(ref);
  *result = v8impl::JsValueFromV8LocalValue(reference->Get());

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_get_reference_value,,false,2684,2697,napi_get_reference_value,,,90,"napi_status napi_get_reference_value (napi_env,napi_ref,napi_value*)"
117379,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_open_handle_scope(napi_env env,
                                              napi_handle_scope* result) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsHandleScopeFromV8HandleScope(
      new v8impl::HandleScopeWrapper(env->isolate));
  env->open_handle_scopes++;
  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_open_handle_scope,,false,2699,2710,napi_open_handle_scope,,,91,"napi_status napi_open_handle_scope (napi_env,napi_handle_scope*)"
117434,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_close_handle_scope(napi_env env,
                                               napi_handle_scope scope) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, scope);
  if (env->open_handle_scopes == 0) {
    return napi_handle_scope_mismatch;
  }

  env->open_handle_scopes--;
  delete v8impl::V8HandleScopeFromJsHandleScope(scope);
  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_close_handle_scope,,false,2712,2725,napi_close_handle_scope,,,92,"napi_status napi_close_handle_scope (napi_env,napi_handle_scope)"
117492,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_open_escapable_handle_scope(
    napi_env env, napi_escapable_handle_scope* result) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsEscapableHandleScopeFromV8EscapableHandleScope(
      new v8impl::EscapableHandleScopeWrapper(env->isolate));
  env->open_handle_scopes++;
  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_open_escapable_handle_scope,,false,2727,2738,napi_open_escapable_handle_scope,,,93,"napi_status napi_open_escapable_handle_scope (napi_env,napi_escapable_handle_scope*)"
117547,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_close_escapable_handle_scope(
    napi_env env, napi_escapable_handle_scope scope) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, scope);
  if (env->open_handle_scopes == 0) {
    return napi_handle_scope_mismatch;
  }

  delete v8impl::V8EscapableHandleScopeFromJsEscapableHandleScope(scope);
  env->open_handle_scopes--;
  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_close_escapable_handle_scope,,false,2740,2753,napi_close_escapable_handle_scope,,,94,"napi_status napi_close_escapable_handle_scope (napi_env,napi_escapable_handle_scope)"
117605,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_escape_handle(napi_env env,
                                          napi_escapable_handle_scope scope,
                                          napi_value escapee,
                                          napi_value* result) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, scope);
  CHECK_ARG(env, escapee);
  CHECK_ARG(env, result);

  v8impl::EscapableHandleScopeWrapper* s =
      v8impl::V8EscapableHandleScopeFromJsEscapableHandleScope(scope);
  if (!s->escape_called()) {
    *result = v8impl::JsValueFromV8LocalValue(
        s->Escape(v8impl::V8LocalValueFromJsValue(escapee)));
    return napi_clear_last_error(env);
  }
  return napi_set_last_error(env, napi_escape_called_twice);
}",1,12,js_native_api_v8.cc,napi_escape_handle,,false,2755,2774,napi_escape_handle,,,95,"napi_status napi_escape_handle (napi_env,napi_escapable_handle_scope,napi_value,napi_value*)"
117715,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_new_instance(napi_env env,
                                         napi_value constructor,
                                         size_t argc,
                                         const napi_value* argv,
                                         napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, constructor);
  if (argc > 0) {
    CHECK_ARG(env, argv);
  }
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Function> ctor;
  CHECK_TO_FUNCTION(env, ctor, constructor);

  auto maybe = ctor->NewInstance(
      context,
      argc,
      reinterpret_cast<v8::Local<v8::Value>*>(const_cast<napi_value*>(argv)));

  CHECK_MAYBE_EMPTY(env, maybe, napi_pending_exception);

  *result = v8impl::JsValueFromV8LocalValue(maybe.ToLocalChecked());
  return GET_RETURN_STATUS(env);
}",1,12,js_native_api_v8.cc,napi_new_instance,,false,2776,2802,napi_new_instance,,,96,"napi_status napi_new_instance (napi_env,napi_value,size_t,napi_value*,napi_value*)"
117973,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_instanceof(napi_env env,
                                       napi_value object,
                                       napi_value constructor,
                                       bool* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, object);
  CHECK_ARG(env, result);

  *result = false;

  v8::Local<v8::Object> ctor;
  v8::Local<v8::Context> context = env->context();

  CHECK_TO_OBJECT(env, context, ctor, constructor);

  if (!ctor->IsFunction()) {
    napi_throw_type_error(
        env, ""ERR_NAPI_CONS_FUNCTION"", ""Constructor must be a function"");

    return napi_set_last_error(env, napi_function_expected);
  }

  napi_status status = napi_generic_failure;

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(object);
  auto maybe_result = val->InstanceOf(context, ctor);
  CHECK_MAYBE_NOTHING(env, maybe_result, status);
  *result = maybe_result.FromJust();
  return GET_RETURN_STATUS(env);
}",1,12,js_native_api_v8.cc,napi_instanceof,,false,2804,2833,napi_instanceof,,,97,"napi_status napi_instanceof (napi_env,napi_value,napi_value,bool*)"
118237,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_is_exception_pending(napi_env env, bool* result) {
  // NAPI_PREAMBLE is not used here: this function must execute when there is a
  // pending exception.
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = !env->last_exception.IsEmpty();
  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_is_exception_pending,,false,2836,2844,napi_is_exception_pending,,,98,"napi_status napi_is_exception_pending (napi_env,bool*)"
118286,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_get_and_clear_last_exception(napi_env env,
                                                         napi_value* result) {
  // NAPI_PREAMBLE is not used here: this function must execute when there is a
  // pending exception.
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  if (env->last_exception.IsEmpty()) {
    return napi_get_undefined(env, result);
  } else {
    *result = v8impl::JsValueFromV8LocalValue(
        v8::Local<v8::Value>::New(env->isolate, env->last_exception));
    env->last_exception.Reset();
  }

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_get_and_clear_last_exception,,false,2846,2862,napi_get_and_clear_last_exception,,,99,"napi_status napi_get_and_clear_last_exception (napi_env,napi_value*)"
118370,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_is_arraybuffer(napi_env env,
                                           napi_value value,
                                           bool* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  *result = val->IsArrayBuffer();

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_is_arraybuffer,,false,2864,2875,napi_is_arraybuffer,,,100,"napi_status napi_is_arraybuffer (napi_env,napi_value,bool*)"
118449,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_create_arraybuffer(napi_env env,
                                               size_t byte_length,
                                               void** data,
                                               napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Isolate* isolate = env->isolate;
  v8::Local<v8::ArrayBuffer> buffer =
      v8::ArrayBuffer::New(isolate, byte_length);

  // Optionally return a pointer to the buffer's data, to avoid another call to
  // retrieve it.
  if (data != nullptr) {
    *data = buffer->Data();
  }

  *result = v8impl::JsValueFromV8LocalValue(buffer);
  return GET_RETURN_STATUS(env);
}",1,12,js_native_api_v8.cc,napi_create_arraybuffer,,false,2877,2896,napi_create_arraybuffer,,,101,"napi_status napi_create_arraybuffer (napi_env,size_t,void**,napi_value*)"
118587,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL
napi_create_external_arraybuffer(napi_env env,
                                 void* external_data,
                                 size_t byte_length,
                                 napi_finalize finalize_cb,
                                 void* finalize_hint,
                                 napi_value* result) {
  // The API contract here is that the cleanup function runs on the JS thread,
  // and is able to use napi_env. Implementing that properly is hard, so use the
  // `Buffer` variant for easier implementation.
  napi_value buffer;
  STATUS_CALL(napi_create_external_buffer(
      env, byte_length, external_data, finalize_cb, finalize_hint, &buffer));
  return napi_get_typedarray_info(
      env, buffer, nullptr, nullptr, nullptr, result, nullptr);
}",1,12,js_native_api_v8.cc,napi_create_external_arraybuffer,,false,2898,2913,napi_create_external_arraybuffer,,,102,"napi_status napi_create_external_arraybuffer (napi_env,void*,size_t,napi_finalize,void*,napi_value*)"
118631,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_get_arraybuffer_info(napi_env env,
                                                 napi_value arraybuffer,
                                                 void** data,
                                                 size_t* byte_length) {
  CHECK_ENV(env);
  CHECK_ARG(env, arraybuffer);

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(arraybuffer);
  RETURN_STATUS_IF_FALSE(env, value->IsArrayBuffer(), napi_invalid_arg);

  v8::Local<v8::ArrayBuffer> ab = value.As<v8::ArrayBuffer>();

  if (data != nullptr) {
    *data = ab->Data();
  }

  if (byte_length != nullptr) {
    *byte_length = ab->ByteLength();
  }

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_get_arraybuffer_info,,false,2915,2936,napi_get_arraybuffer_info,,,103,"napi_status napi_get_arraybuffer_info (napi_env,napi_value,void**,size_t*)"
118747,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_is_typedarray(napi_env env,
                                          napi_value value,
                                          bool* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  *result = val->IsTypedArray();

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_is_typedarray,,false,2938,2949,napi_is_typedarray,,,104,"napi_status napi_is_typedarray (napi_env,napi_value,bool*)"
118826,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_create_typedarray(napi_env env,
                                              napi_typedarray_type type,
                                              size_t length,
                                              napi_value arraybuffer,
                                              size_t byte_offset,
                                              napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, arraybuffer);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(arraybuffer);
  RETURN_STATUS_IF_FALSE(env, value->IsArrayBuffer(), napi_invalid_arg);

  v8::Local<v8::ArrayBuffer> buffer = value.As<v8::ArrayBuffer>();
  v8::Local<v8::TypedArray> typedArray;

  switch (type) {
    case napi_int8_array:
      CREATE_TYPED_ARRAY(
          env, Int8Array, 1, buffer, byte_offset, length, typedArray);
      break;
    case napi_uint8_array:
      CREATE_TYPED_ARRAY(
          env, Uint8Array, 1, buffer, byte_offset, le...",1,12,js_native_api_v8.cc,napi_create_typedarray,,false,2951,3018,napi_create_typedarray,,,105,"napi_status napi_create_typedarray (napi_env,napi_typedarray_type,size_t,napi_value,size_t,napi_value*)"
119818,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_get_typedarray_info(napi_env env,
                                                napi_value typedarray,
                                                napi_typedarray_type* type,
                                                size_t* length,
                                                void** data,
                                                napi_value* arraybuffer,
                                                size_t* byte_offset) {
  CHECK_ENV(env);
  CHECK_ARG(env, typedarray);

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(typedarray);
  RETURN_STATUS_IF_FALSE(env, value->IsTypedArray(), napi_invalid_arg);

  v8::Local<v8::TypedArray> array = value.As<v8::TypedArray>();

  if (type != nullptr) {
    if (value->IsInt8Array()) {
      *type = napi_int8_array;
    } else if (value->IsUint8Array()) {
      *type = napi_uint8_array;
    } else if (value->IsUint8ClampedArray()) {
      *type = napi_uint8_clamped_array;
    } els...",1,12,js_native_api_v8.cc,napi_get_typedarray_info,,false,3020,3085,napi_get_typedarray_info,,,106,"napi_status napi_get_typedarray_info (napi_env,napi_value,napi_typedarray_type*,size_t*,void**,napi_value*,size_t*)"
120128,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_create_dataview(napi_env env,
                                            size_t byte_length,
                                            napi_value arraybuffer,
                                            size_t byte_offset,
                                            napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, arraybuffer);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(arraybuffer);
  RETURN_STATUS_IF_FALSE(env, value->IsArrayBuffer(), napi_invalid_arg);

  v8::Local<v8::ArrayBuffer> buffer = value.As<v8::ArrayBuffer>();
  if (byte_length + byte_offset > buffer->ByteLength()) {
    napi_throw_range_error(env,
                           ""ERR_NAPI_INVALID_DATAVIEW_ARGS"",
                           ""byte_offset + byte_length should be less than or ""
                           ""equal to the size in bytes of the array passed in"");
    return napi_set_last_error(env, napi_pending_exception);
  }
  v...",1,12,js_native_api_v8.cc,napi_create_dataview,,false,3087,3112,napi_create_dataview,,,107,"napi_status napi_create_dataview (napi_env,size_t,napi_value,size_t,napi_value*)"
120336,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_is_dataview(napi_env env,
                                        napi_value value,
                                        bool* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  *result = val->IsDataView();

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_is_dataview,,false,3114,3125,napi_is_dataview,,,108,"napi_status napi_is_dataview (napi_env,napi_value,bool*)"
120415,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_get_dataview_info(napi_env env,
                                              napi_value dataview,
                                              size_t* byte_length,
                                              void** data,
                                              napi_value* arraybuffer,
                                              size_t* byte_offset) {
  CHECK_ENV(env);
  CHECK_ARG(env, dataview);

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(dataview);
  RETURN_STATUS_IF_FALSE(env, value->IsDataView(), napi_invalid_arg);

  v8::Local<v8::DataView> array = value.As<v8::DataView>();

  if (byte_length != nullptr) {
    *byte_length = array->ByteLength();
  }

  v8::Local<v8::ArrayBuffer> buffer;
  if (data != nullptr || arraybuffer != nullptr) {
    // Calling Buffer() may have the side effect of allocating the buffer,
    // so only do this when its needed.
    buffer = array->Buffer();
  }

  if (data != nullptr) {
    *data ...",1,12,js_native_api_v8.cc,napi_get_dataview_info,,false,3127,3165,napi_get_dataview_info,,,109,"napi_status napi_get_dataview_info (napi_env,napi_value,size_t*,void**,napi_value*,size_t*)"
120589,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_get_version(napi_env env, uint32_t* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);
  *result = NAPI_VERSION;
  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_get_version,,false,3167,3172,napi_get_version,,,110,"napi_status napi_get_version (napi_env,uint32_t*)"
120634,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_create_promise(napi_env env,
                                           napi_deferred* deferred,
                                           napi_value* promise) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, deferred);
  CHECK_ARG(env, promise);

  auto maybe = v8::Promise::Resolver::New(env->context());
  CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure);

  auto v8_resolver = maybe.ToLocalChecked();
  auto v8_deferred = new v8impl::Persistent<v8::Value>();
  v8_deferred->Reset(env->isolate, v8_resolver);

  *deferred = v8impl::JsDeferredFromNodePersistent(v8_deferred);
  *promise = v8impl::JsValueFromV8LocalValue(v8_resolver->GetPromise());
  return GET_RETURN_STATUS(env);
}",1,12,js_native_api_v8.cc,napi_create_promise,,false,3174,3191,napi_create_promise,,,111,"napi_status napi_create_promise (napi_env,napi_deferred*,napi_value*)"
120818,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_resolve_deferred(napi_env env,
                                             napi_deferred deferred,
                                             napi_value resolution) {
  return v8impl::ConcludeDeferred(env, deferred, resolution, true);
}",1,12,js_native_api_v8.cc,napi_resolve_deferred,,false,3193,3197,napi_resolve_deferred,,,112,"napi_status napi_resolve_deferred (napi_env,napi_deferred,napi_value)"
120834,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_reject_deferred(napi_env env,
                                            napi_deferred deferred,
                                            napi_value resolution) {
  return v8impl::ConcludeDeferred(env, deferred, resolution, false);
}",1,12,js_native_api_v8.cc,napi_reject_deferred,,false,3199,3203,napi_reject_deferred,,,113,"napi_status napi_reject_deferred (napi_env,napi_deferred,napi_value)"
120850,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_is_promise(napi_env env,
                                       napi_value value,
                                       bool* is_promise) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, is_promise);

  *is_promise = v8impl::V8LocalValueFromJsValue(value)->IsPromise();

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_is_promise,,false,3205,3215,napi_is_promise,,,114,"napi_status napi_is_promise (napi_env,napi_value,bool*)"
120918,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_create_date(napi_env env,
                                        double time,
                                        napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::MaybeLocal<v8::Value> maybe_date = v8::Date::New(env->context(), time);
  CHECK_MAYBE_EMPTY(env, maybe_date, napi_generic_failure);

  *result = v8impl::JsValueFromV8LocalValue(maybe_date.ToLocalChecked());

  return GET_RETURN_STATUS(env);
}",1,12,js_native_api_v8.cc,napi_create_date,,false,3217,3229,napi_create_date,,,115,"napi_status napi_create_date (napi_env,double,napi_value*)"
121063,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_is_date(napi_env env,
                                    napi_value value,
                                    bool* is_date) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, is_date);

  *is_date = v8impl::V8LocalValueFromJsValue(value)->IsDate();

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_is_date,,false,3231,3241,napi_is_date,,,116,"napi_status napi_is_date (napi_env,napi_value,bool*)"
121131,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_get_date_value(napi_env env,
                                           napi_value value,
                                           double* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsDate(), napi_date_expected);

  v8::Local<v8::Date> date = val.As<v8::Date>();
  *result = date->ValueOf();

  return GET_RETURN_STATUS(env);
}",1,12,js_native_api_v8.cc,napi_get_date_value,,false,3243,3257,napi_get_date_value,,,117,"napi_status napi_get_date_value (napi_env,napi_value,double*)"
121299,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_run_script(napi_env env,
                                       napi_value script,
                                       napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, script);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> v8_script = v8impl::V8LocalValueFromJsValue(script);

  if (!v8_script->IsString()) {
    return napi_set_last_error(env, napi_string_expected);
  }

  v8::Local<v8::Context> context = env->context();

  auto maybe_script = v8::Script::Compile(context, v8_script.As<v8::String>());
  CHECK_MAYBE_EMPTY(env, maybe_script, napi_generic_failure);

  auto script_result = maybe_script.ToLocalChecked()->Run(context);
  CHECK_MAYBE_EMPTY(env, script_result, napi_generic_failure);

  *result = v8impl::JsValueFromV8LocalValue(script_result.ToLocalChecked());
  return GET_RETURN_STATUS(env);
}",1,12,js_native_api_v8.cc,napi_run_script,,false,3259,3282,napi_run_script,,,118,"napi_status napi_run_script (napi_env,napi_value,napi_value*)"
121525,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_add_finalizer(napi_env env,
                                          napi_value js_object,
                                          void* finalize_data,
                                          napi_finalize finalize_cb,
                                          void* finalize_hint,
                                          napi_ref* result) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, js_object);
  CHECK_ARG(env, finalize_cb);

  v8::Local<v8::Value> v8_value = v8impl::V8LocalValueFromJsValue(js_object);
  RETURN_STATUS_IF_FALSE(env, v8_value->IsObject(), napi_invalid_arg);

  // Create a self-deleting reference if the optional out-param result is not
  // set.
  v8impl::Ownership ownership = result == nullptr
                                    ? v8impl::Ownership::kRuntime
                                    : v8impl::Ownership::kUserland;
  v8impl::Referenc...",1,12,js_native_api_v8.cc,napi_add_finalizer,,false,3284,3311,napi_add_finalizer,,,119,"napi_status napi_add_finalizer (napi_env,napi_value,void*,napi_finalize,void*,napi_ref*)"
121666,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_adjust_external_memory(napi_env env,
                                                   int64_t change_in_bytes,
                                                   int64_t* adjusted_value) {
  CHECK_ENV(env);
  CHECK_ARG(env, adjusted_value);

  *adjusted_value =
      env->isolate->AdjustAmountOfExternalAllocatedMemory(change_in_bytes);

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_adjust_external_memory,,false,3313,3323,napi_adjust_external_memory,,,120,"napi_status napi_adjust_external_memory (napi_env,int64_t,int64_t*)"
121716,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_set_instance_data(napi_env env,
                                              void* data,
                                              napi_finalize finalize_cb,
                                              void* finalize_hint) {
  CHECK_ENV(env);

  v8impl::RefBase* old_data = static_cast<v8impl::RefBase*>(env->instance_data);
  if (old_data != nullptr) {
    // Our contract so far has been to not finalize any old data there may be.
    // So we simply delete it.
    delete old_data;
  }

  env->instance_data = v8impl::RefBase::New(
      env, 0, v8impl::Ownership::kRuntime, finalize_cb, data, finalize_hint);

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_set_instance_data,,false,3325,3342,napi_set_instance_data,,,121,"napi_status napi_set_instance_data (napi_env,void*,napi_finalize,void*)"
121775,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_get_instance_data(napi_env env, void** data) {
  CHECK_ENV(env);
  CHECK_ARG(env, data);

  v8impl::RefBase* idata = static_cast<v8impl::RefBase*>(env->instance_data);

  *data = (idata == nullptr ? nullptr : idata->Data());

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_get_instance_data,,false,3344,3353,napi_get_instance_data,,,122,"napi_status napi_get_instance_data (napi_env,void**)"
121834,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_detach_arraybuffer(napi_env env,
                                               napi_value arraybuffer) {
  CHECK_ENV(env);
  CHECK_ARG(env, arraybuffer);

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(arraybuffer);
  RETURN_STATUS_IF_FALSE(
      env, value->IsArrayBuffer(), napi_arraybuffer_expected);

  v8::Local<v8::ArrayBuffer> it = value.As<v8::ArrayBuffer>();
  RETURN_STATUS_IF_FALSE(
      env, it->IsDetachable(), napi_detachable_arraybuffer_expected);

  it->Detach(v8::Local<v8::Value>()).Check();

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_detach_arraybuffer,,false,3355,3371,napi_detach_arraybuffer,,,123,"napi_status napi_detach_arraybuffer (napi_env,napi_value)"
121957,METHOD,js_native_api_v8.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_is_detached_arraybuffer(napi_env env,
                                                    napi_value arraybuffer,
                                                    bool* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, arraybuffer);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(arraybuffer);

  *result =
      value->IsArrayBuffer() && value.As<v8::ArrayBuffer>()->WasDetached();

  return napi_clear_last_error(env);
}",1,12,js_native_api_v8.cc,napi_is_detached_arraybuffer,,false,3373,3386,napi_is_detached_arraybuffer,,,124,"napi_status napi_is_detached_arraybuffer (napi_env,napi_value,bool*)"
122045,METHOD,napi_env__,TYPE_DECL,"[&](napi_env env) { cb(env, data, hint); }",20,61,js_native_api_v8.hpp,napi_env__.CallFinalizer.<lambda>0,,false,105,105,<lambda>0,,,1,ANY napi_env__.CallFinalizer.<lambda>0 (napi_env)
122064,METHOD,js_native_api_v8.hpp:<global>,TYPE_DECL,<global>,1,1,js_native_api_v8.hpp,js_native_api_v8.hpp:<global>,,false,1,434,<global>,,,1,
122066,METHOD,js_native_api_v8.hpp:<global>,TYPE_DECL,inline napi_status napi_clear_last_error(napi_env env);,20,54,js_native_api_v8.hpp,napi_clear_last_error,,false,7,7,napi_clear_last_error,,,1,napi_status napi_clear_last_error (napi_env)
122073,METHOD,v8impl.RefTracker,TYPE_DECL,RefTracker() {},3,17,js_native_api_v8.hpp,v8impl.RefTracker.RefTracker,,false,13,13,RefTracker,,,1,ANY v8impl.RefTracker.RefTracker ()
122077,METHOD,v8impl.RefTracker,TYPE_DECL,virtual ~RefTracker() {},3,26,js_native_api_v8.hpp,v8impl.RefTracker.~RefTracker,,false,14,14,~RefTracker,,,2,ANY v8impl.RefTracker.~RefTracker ()
122081,METHOD,v8impl.RefTracker,TYPE_DECL,virtual void Finalize() {},3,28,js_native_api_v8.hpp,v8impl.RefTracker.Finalize,,false,15,15,Finalize,,,3,void v8impl.RefTracker.Finalize ()
122086,METHOD,v8impl.RefTracker,TYPE_DECL,"inline void Link(RefList* list) {
    prev_ = list;
    next_ = list->next_;
    if (next_ != nullptr) {
      next_->prev_ = this;
    }
    list->next_ = this;
  }",3,3,js_native_api_v8.hpp,v8impl.RefTracker.Link,,false,19,26,Link,,,5,void v8impl.RefTracker.Link (RefList*)
122114,METHOD,v8impl.RefTracker,TYPE_DECL,"inline void Unlink() {
    if (prev_ != nullptr) {
      prev_->next_ = next_;
    }
    if (next_ != nullptr) {
      next_->prev_ = prev_;
    }
    prev_ = nullptr;
    next_ = nullptr;
  }",3,3,js_native_api_v8.hpp,v8impl.RefTracker.Unlink,,false,28,37,Unlink,,,6,void v8impl.RefTracker.Unlink ()
122144,METHOD,v8impl.RefTracker,TYPE_DECL,"static void FinalizeAll(RefList* list) {
    while (list->next_ != nullptr) {
      list->next_->Finalize();
    }
  }",3,3,js_native_api_v8.hpp,v8impl.RefTracker.FinalizeAll,,false,39,43,FinalizeAll,,,7,void v8impl.RefTracker.FinalizeAll (RefList*)
122164,METHOD,<empty>,<empty>,<empty>,1,,js_native_api_v8.hpp,v8impl.RefTracker:<clinit>,,false,11,,<clinit>,,,10,
122175,METHOD,napi_env__,TYPE_DECL,"explicit napi_env__(v8::Local<v8::Context> context,
                      int32_t module_api_version)
      : isolate(context->GetIsolate()),
        context_persistent(isolate, context),
        module_api_version(module_api_version) {
    napi_clear_last_error(this);
  }",3,3,js_native_api_v8.hpp,napi_env__.napi_env__,,false,54,60,napi_env__,,,1,"ANY napi_env__.napi_env__ (ANY,int32_t)"
122183,METHOD,napi_env__,TYPE_DECL,"inline v8::Local<v8::Context> context() const {
    return v8impl::PersistentToLocal::Strong(context_persistent);
  }",3,3,js_native_api_v8.hpp,napi_env__.context,,false,62,64,context,,,2,Local<v8::Context> napi_env__.context ()
122195,METHOD,napi_env__,TYPE_DECL,inline void Ref() { refs++; },3,31,js_native_api_v8.hpp,napi_env__.Ref,,false,66,66,Ref,,,3,void napi_env__.Ref ()
122201,METHOD,napi_env__,TYPE_DECL,"inline void Unref() {
    if (--refs == 0) DeleteMe();
  }",3,3,js_native_api_v8.hpp,napi_env__.Unref,,false,67,69,Unref,,,4,void napi_env__.Unref ()
122212,METHOD,napi_env__,TYPE_DECL,virtual bool can_call_into_js() const { return true; },3,56,js_native_api_v8.hpp,napi_env__.can_call_into_js,,false,71,71,can_call_into_js,,,5,bool napi_env__.can_call_into_js ()
122218,METHOD,napi_env__,TYPE_DECL,"static inline void HandleThrow(napi_env env, v8::Local<v8::Value> value) {
    if (env->terminatedOrTerminating()) {
      return;
    }
    env->isolate->ThrowException(value);
  }",3,3,js_native_api_v8.hpp,napi_env__.HandleThrow,,false,73,78,HandleThrow,,,6,"void napi_env__.HandleThrow (napi_env,ANY)"
122238,METHOD,napi_env__,TYPE_DECL,"inline bool terminatedOrTerminating() {
    return this->isolate->IsExecutionTerminating() || !can_call_into_js();
  }",3,3,js_native_api_v8.hpp,napi_env__.terminatedOrTerminating,,false,81,83,terminatedOrTerminating,,,7,bool napi_env__.terminatedOrTerminating ()
122252,METHOD,napi_env__,TYPE_DECL,"inline void CallIntoModule(T&& call, U&& handle_exception = HandleThrow) {
    int open_handle_scopes_before = open_handle_scopes;
    int open_callback_scopes_before = open_callback_scopes;
    napi_clear_last_error(this);
    call(this);
    CHECK_EQ(open_handle_scopes, open_handle_scopes_before);
    CHECK_EQ(open_callback_scopes, open_callback_scopes_before);
    if (!last_exception.IsEmpty()) {
      handle_exception(this, last_exception.Get(this->isolate));
      last_exception.Reset();
    }
  }",3,3,js_native_api_v8.hpp,napi_env__.CallIntoModule,,false,89,100,CallIntoModule,,,8,"void napi_env__.CallIntoModule<T,U> (T,U)"
122296,METHOD,napi_env__,TYPE_DECL,"virtual void CallFinalizer(napi_finalize cb, void* data, void* hint) {
    v8::HandleScope handle_scope(isolate);
    CallIntoModule([&](napi_env env) { cb(env, data, hint); });
  }",3,3,js_native_api_v8.hpp,napi_env__.CallFinalizer,,false,103,106,CallFinalizer,,,9,"void napi_env__.CallFinalizer (napi_finalize,void*,void*)"
122306,METHOD,napi_env__,TYPE_DECL,"virtual void EnqueueFinalizer(v8impl::RefTracker* finalizer) {
    pending_finalizers.emplace(finalizer);
  }",3,3,js_native_api_v8.hpp,napi_env__.EnqueueFinalizer,,false,112,114,EnqueueFinalizer,,,10,void napi_env__.EnqueueFinalizer (ANY*)
122316,METHOD,napi_env__,TYPE_DECL,"virtual void DequeueFinalizer(v8impl::RefTracker* finalizer) {
    pending_finalizers.erase(finalizer);
  }",3,3,js_native_api_v8.hpp,napi_env__.DequeueFinalizer,,false,118,120,DequeueFinalizer,,,11,void napi_env__.DequeueFinalizer (ANY*)
122326,METHOD,napi_env__,TYPE_DECL,"virtual void DeleteMe() {
    // First we must finalize those references that have `napi_finalizer`
    // callbacks. The reason is that addons might store other references which
    // they delete during their `napi_finalizer` callbacks. If we deleted such
    // references here first, they would be doubly deleted when the
    // `napi_finalizer` deleted them subsequently.
    v8impl::RefTracker::FinalizeAll(&finalizing_reflist);
    v8impl::RefTracker::FinalizeAll(&reflist);
    delete this;
  }",3,3,js_native_api_v8.hpp,napi_env__.DeleteMe,,false,122,131,DeleteMe,,,12,void napi_env__.DeleteMe ()
122360,METHOD,napi_env__,TYPE_DECL,virtual ~napi_env__() = default;,3,34,js_native_api_v8.hpp,napi_env__.~napi_env__,,false,155,155,~napi_env__,,,25,ANY napi_env__.~napi_env__ ()
122364,METHOD,<empty>,<empty>,<empty>,1,,js_native_api_v8.hpp,napi_env__:<clinit>,,false,53,,<clinit>,,,26,
122385,METHOD,js_native_api_v8.hpp:<global>,TYPE_DECL,"inline napi_status napi_clear_last_error(napi_env env) {
  env->last_error.error_code = napi_ok;
  env->last_error.engine_error_code = 0;
  env->last_error.engine_reserved = nullptr;
  env->last_error.error_message = nullptr;
  return napi_ok;
}",1,1,js_native_api_v8.hpp,napi_clear_last_error,,false,158,164,napi_clear_last_error,,,4,napi_status napi_clear_last_error (napi_env)
122420,METHOD,js_native_api_v8.hpp:<global>,TYPE_DECL,"inline napi_status napi_set_last_error(napi_env env,
                                       napi_status error_code,
                                       uint32_t engine_error_code = 0,
                                       void* engine_reserved = nullptr) {
  env->last_error.error_code = error_code;
  env->last_error.engine_error_code = engine_error_code;
  env->last_error.engine_reserved = engine_reserved;
  return error_code;
}",1,1,js_native_api_v8.hpp,napi_set_last_error,,false,166,174,napi_set_last_error,,,5,"napi_status napi_set_last_error (napi_env,napi_status,uint32_t,void*)"
122459,METHOD,js_native_api_v8.hpp:<global>,TYPE_DECL,"inline napi_value JsValueFromV8LocalValue(v8::Local<v8::Value> local) {
  return reinterpret_cast<napi_value>(*local);
}",1,1,js_native_api_v8.hpp,v8impl.JsValueFromV8LocalValue,,false,297,299,JsValueFromV8LocalValue,,,2,napi_value v8impl.JsValueFromV8LocalValue (ANY)
122469,METHOD,js_native_api_v8.hpp:<global>,TYPE_DECL,"inline v8::Local<v8::Value> V8LocalValueFromJsValue(napi_value v) {
  v8::Local<v8::Value> local;
  memcpy(static_cast<void*>(&local), &v, sizeof(v));
  return local;
}",1,1,js_native_api_v8.hpp,v8impl.V8LocalValueFromJsValue,,false,301,305,V8LocalValueFromJsValue,,,3,Local<v8::Value> v8impl.V8LocalValueFromJsValue (napi_value)
122495,METHOD,v8impl.Finalizer,TYPE_DECL,"Finalizer(napi_env env,
            napi_finalize finalize_callback,
            void* finalize_data,
            void* finalize_hint)
      : env_(env),
        finalize_callback_(finalize_callback),
        finalize_data_(finalize_data),
        finalize_hint_(finalize_hint) {}",3,40,js_native_api_v8.hpp,v8impl.Finalizer.Finalizer,,false,310,317,Finalizer,,,1,"ANY v8impl.Finalizer.Finalizer (napi_env,napi_finalize,void*,void*)"
122503,METHOD,v8impl.Finalizer,TYPE_DECL,virtual ~Finalizer() = default;,3,33,js_native_api_v8.hpp,v8impl.Finalizer.~Finalizer,,false,319,319,~Finalizer,,,2,ANY v8impl.Finalizer.~Finalizer ()
122507,METHOD,v8impl.Finalizer,TYPE_DECL,"static Finalizer* New(napi_env env,
                        napi_finalize finalize_callback = nullptr,
                        void* finalize_data = nullptr,
                        void* finalize_hint = nullptr) {
    return new Finalizer(env, finalize_callback, finalize_data, finalize_hint);
  }",3,3,js_native_api_v8.hpp,v8impl.Finalizer.New,,false,322,327,New,,,3,"Finalizer v8impl.Finalizer.New (napi_env,napi_finalize,void*,void*)"
122522,METHOD,v8impl.Finalizer,TYPE_DECL,napi_finalize callback() { return finalize_callback_; },3,57,js_native_api_v8.hpp,v8impl.Finalizer.callback,,false,329,329,callback,,,4,napi_finalize v8impl.Finalizer.callback ()
122528,METHOD,v8impl.Finalizer,TYPE_DECL,void* data() { return finalize_data_; },3,41,js_native_api_v8.hpp,v8impl.Finalizer.data,,false,330,330,data,,,5,void* v8impl.Finalizer.data ()
122534,METHOD,v8impl.Finalizer,TYPE_DECL,void* hint() { return finalize_hint_; },3,41,js_native_api_v8.hpp,v8impl.Finalizer.hint,,false,331,331,hint,,,6,void* v8impl.Finalizer.hint ()
122540,METHOD,v8impl.Finalizer,TYPE_DECL,void ResetFinalizer();,8,23,js_native_api_v8.hpp,v8impl.Finalizer.ResetFinalizer,,false,333,333,ResetFinalizer,,,7,void v8impl.Finalizer.ResetFinalizer ()
122549,METHOD,v8impl.TryCatch,TYPE_DECL,"explicit TryCatch(napi_env env) : v8::TryCatch(env->isolate), _env(env) {}",3,76,js_native_api_v8.hpp,v8impl.TryCatch.TryCatch,,false,344,344,TryCatch,,,1,ANY v8impl.TryCatch.TryCatch (napi_env)
122554,METHOD,v8impl.TryCatch,TYPE_DECL,"~TryCatch() {
    if (HasCaught()) {
      _env->last_exception.Reset(_env->isolate, Exception());
    }
  }",3,3,js_native_api_v8.hpp,v8impl.TryCatch.~TryCatch,,false,346,350,~TryCatch,,,2,ANY v8impl.TryCatch.~TryCatch ()
122576,METHOD,v8impl.RefBase,TYPE_DECL,"RefBase(napi_env env,
          uint32_t initial_refcount,
          Ownership ownership,
          napi_finalize finalize_callback,
          void* finalize_data,
          void* finalize_hint);",3,30,js_native_api_v8.hpp,v8impl.RefBase.RefBase,,false,369,374,RefBase,,,1,"ANY v8impl.RefBase.RefBase (napi_env,uint32_t,Ownership,napi_finalize,void*,void*)"
122586,METHOD,v8impl.RefBase,TYPE_DECL,"static RefBase* New(napi_env env,
                      uint32_t initial_refcount,
                      Ownership ownership,
                      napi_finalize finalize_callback,
                      void* finalize_data,
                      void* finalize_hint);",17,42,js_native_api_v8.hpp,v8impl.RefBase.New,,false,377,382,New,,,2,"RefBase* v8impl.RefBase.New (napi_env,uint32_t,Ownership,napi_finalize,void*,void*)"
122596,METHOD,v8impl.RefBase,TYPE_DECL,virtual ~RefBase();,11,20,js_native_api_v8.hpp,v8impl.RefBase.~RefBase,,false,383,383,~RefBase,,,3,virtual v8impl.RefBase.~RefBase ()
122600,METHOD,v8impl.RefBase,TYPE_DECL,void* Data();,7,14,js_native_api_v8.hpp,v8impl.RefBase.Data,,false,385,385,Data,,,4,void* v8impl.RefBase.Data ()
122604,METHOD,v8impl.RefBase,TYPE_DECL,uint32_t Ref();,12,16,js_native_api_v8.hpp,v8impl.RefBase.Ref,,false,386,386,Ref,,,5,uint32_t v8impl.RefBase.Ref ()
122608,METHOD,v8impl.RefBase,TYPE_DECL,uint32_t Unref();,12,18,js_native_api_v8.hpp,v8impl.RefBase.Unref,,false,387,387,Unref,,,6,uint32_t v8impl.RefBase.Unref ()
122612,METHOD,v8impl.RefBase,TYPE_DECL,uint32_t RefCount();,12,21,js_native_api_v8.hpp,v8impl.RefBase.RefCount,,false,388,388,RefCount,,,7,uint32_t v8impl.RefBase.RefCount ()
122616,METHOD,v8impl.RefBase,TYPE_DECL,Ownership ownership() { return ownership_; },3,46,js_native_api_v8.hpp,v8impl.RefBase.ownership,,false,390,390,ownership,,,8,Ownership v8impl.RefBase.ownership ()
122622,METHOD,v8impl.RefBase,TYPE_DECL,void Finalize() override;,8,26,js_native_api_v8.hpp,v8impl.RefBase.Finalize,,false,393,393,Finalize,,,9,void v8impl.RefBase.Finalize ()
122629,METHOD,v8impl.Reference,TYPE_DECL,"Reference(napi_env env, v8::Local<v8::Value> value, Args&&... args);",3,69,js_native_api_v8.hpp,v8impl.Reference.Reference,,false,404,404,Reference,,,1,"ANY v8impl.Reference.Reference<Args> (napi_env,ANY,Args)"
122636,METHOD,v8impl.Reference,TYPE_DECL,"static Reference* New(napi_env env,
                        v8::Local<v8::Value> value,
                        uint32_t initial_refcount,
                        Ownership ownership,
                        napi_finalize finalize_callback = nullptr,
                        void* finalize_data = nullptr,
                        void* finalize_hint = nullptr);",19,54,js_native_api_v8.hpp,v8impl.Reference.New,,false,407,413,New,,,2,"Reference* v8impl.Reference.New (napi_env,ANY,uint32_t,Ownership,napi_finalize,void*,void*)"
122647,METHOD,v8impl.Reference,TYPE_DECL,virtual ~Reference();,11,22,js_native_api_v8.hpp,v8impl.Reference.~Reference,,false,415,415,~Reference,,,3,virtual v8impl.Reference.~Reference ()
122651,METHOD,v8impl.Reference,TYPE_DECL,uint32_t Ref();,12,16,js_native_api_v8.hpp,v8impl.Reference.Ref,,false,416,416,Ref,,,4,uint32_t v8impl.Reference.Ref ()
122655,METHOD,v8impl.Reference,TYPE_DECL,uint32_t Unref();,12,18,js_native_api_v8.hpp,v8impl.Reference.Unref,,false,417,417,Unref,,,5,uint32_t v8impl.Reference.Unref ()
122659,METHOD,v8impl.Reference,TYPE_DECL,v8::Local<v8::Value> Get();,24,28,js_native_api_v8.hpp,v8impl.Reference.Get,,false,418,418,Get,,,6,ANY v8impl.Reference.Get ()
122663,METHOD,v8impl.Reference,TYPE_DECL,void Finalize() override;,8,26,js_native_api_v8.hpp,v8impl.Reference.Finalize,,false,421,421,Finalize,,,7,void v8impl.Reference.Finalize ()
122667,METHOD,v8impl.Reference,TYPE_DECL,static void WeakCallback(const v8::WeakCallbackInfo<Reference>& data);,15,71,js_native_api_v8.hpp,v8impl.Reference.WeakCallback,,false,424,424,WeakCallback,,,8,void v8impl.Reference.WeakCallback (ANY)
122672,METHOD,v8impl.Reference,TYPE_DECL,void SetWeak();,8,16,js_native_api_v8.hpp,v8impl.Reference.SetWeak,,false,426,426,SetWeak,,,9,void v8impl.Reference.SetWeak ()
122689,METHOD,js_native_api_v8_internals.hpp:<global>,TYPE_DECL,<global>,1,1,js_native_api_v8_internals.hpp,js_native_api_v8_internals.hpp:<global>,,false,1,39,<global>,,,1,
122711,METHOD,js_stream.cc:<global>,TYPE_DECL,<global>,1,27,js_stream.hpp,js_stream.cc:<global>,,false,1,219,<global>,,,1,
122714,METHOD,js_stream.cc:<global>,TYPE_DECL,"JSStream::JSStream(Environment* env, Local<Object> obj)
    : AsyncWrap(env, obj, AsyncWrap::PROVIDER_JSSTREAM),
      StreamBase(env) {
  MakeWeak();
  StreamBase::AttachToObject(obj);
}",1,1,js_stream.cc,node.JSStream.JSStream,,false,26,31,JSStream,,,1,"ANY node.JSStream.JSStream (Environment*,Local<Object>)"
122726,METHOD,js_stream.cc:<global>,TYPE_DECL,"AsyncWrap* JSStream::GetAsyncWrap() {
  return static_cast<AsyncWrap*>(this);
}",1,1,js_stream.cc,node.JSStream.GetAsyncWrap,,false,34,36,GetAsyncWrap,,,2,AsyncWrap node.JSStream.GetAsyncWrap ()
122734,METHOD,js_stream.cc:<global>,TYPE_DECL,"bool JSStream::IsAlive() {
  return true;
}",1,1,js_stream.cc,node.JSStream.IsAlive,,false,39,41,IsAlive,,,3,bool node.JSStream.IsAlive ()
122740,METHOD,js_stream.cc:<global>,TYPE_DECL,"bool JSStream::IsClosing() {
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  TryCatchScope try_catch(env());
  Local<Value> value;
  if (!MakeCallback(env()->isclosing_string(), 0, nullptr).ToLocal(&value)) {
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
    return true;
  }
  return value->IsTrue();
}",1,1,js_stream.cc,node.JSStream.IsClosing,,false,44,55,IsClosing,,,4,bool node.JSStream.IsClosing ()
122807,METHOD,js_stream.cc:<global>,TYPE_DECL,"int JSStream::ReadStart() {
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  TryCatchScope try_catch(env());
  Local<Value> value;
  int value_int = UV_EPROTO;
  if (!MakeCallback(env()->onreadstart_string(), 0, nullptr).ToLocal(&value) ||
      !value->Int32Value(env()->context()).To(&value_int)) {
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }
  return value_int;
}",1,1,js_stream.cc,node.JSStream.ReadStart,,false,58,70,ReadStart,,,5,int node.JSStream.ReadStart ()
122888,METHOD,js_stream.cc:<global>,TYPE_DECL,"int JSStream::ReadStop() {
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  TryCatchScope try_catch(env());
  Local<Value> value;
  int value_int = UV_EPROTO;
  if (!MakeCallback(env()->onreadstop_string(), 0, nullptr).ToLocal(&value) ||
      !value->Int32Value(env()->context()).To(&value_int)) {
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }
  return value_int;
}",1,1,js_stream.cc,node.JSStream.ReadStop,,false,73,85,ReadStop,,,6,int node.JSStream.ReadStop ()
122969,METHOD,js_stream.cc:<global>,TYPE_DECL,"int JSStream::DoShutdown(ShutdownWrap* req_wrap) {
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());

  Local<Value> argv[] = {
    req_wrap->object()
  };

  TryCatchScope try_catch(env());
  Local<Value> value;
  int value_int = UV_EPROTO;
  if (!MakeCallback(env()->onshutdown_string(),
                    arraysize(argv),
                    argv).ToLocal(&value) ||
      !value->Int32Value(env()->context()).To(&value_int)) {
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }
  return value_int;
}",1,1,js_stream.cc,node.JSStream.DoShutdown,,false,88,107,DoShutdown,,,7,int node.JSStream.DoShutdown (ShutdownWrap*)
123060,METHOD,js_stream.cc:<global>,TYPE_DECL,"int JSStream::DoWrite(WriteWrap* w,
                      uv_buf_t* bufs,
                      size_t count,
                      uv_stream_t* send_handle) {
  CHECK_NULL(send_handle);

  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());

  MaybeStackBuffer<Local<Value>, 16> bufs_arr(count);
  for (size_t i = 0; i < count; i++) {
    bufs_arr[i] =
        Buffer::Copy(env(), bufs[i].base, bufs[i].len).ToLocalChecked();
  }

  Local<Value> argv[] = {
    w->object(),
    Array::New(env()->isolate(), bufs_arr.out(), count)
  };

  TryCatchScope try_catch(env());
  Local<Value> value;
  int value_int = UV_EPROTO;
  if (!MakeCallback(env()->onwrite_string(),
                    arraysize(argv),
                    argv).ToLocal(&value) ||
      !value->Int32Value(env()->context()).To(&value_int)) {
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }
  return value_int;
}",1,1,js_stream.cc,node.JSStream.DoWrite,,false,110,141,DoWrite,,,8,"int node.JSStream.DoWrite (WriteWrap*,uv_buf_t*,size_t,uv_stream_t*)"
123206,METHOD,js_stream.cc:<global>,TYPE_DECL,"void JSStream::New(const FunctionCallbackInfo<Value>& args) {
  // This constructor should not be exposed to public javascript.
  // Therefore we assert that we are not trying to call this as a
  // normal function.
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new JSStream(env, args.This());
}",1,1,js_stream.cc,node.JSStream.New,,false,144,151,New,,,9,void node.JSStream.New (FunctionCallbackInfo<Value>)
123231,METHOD,js_stream.cc:<global>,TYPE_DECL,"void JSStream::Finish(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsObject());
  Wrap* w = static_cast<Wrap*>(StreamReq::FromObject(args[0].As<Object>()));

  CHECK(args[1]->IsInt32());
  w->Done(args[1].As<Int32>()->Value());
}",1,1,js_stream.cc,node.JSStream.Finish,,false,155,161,Finish,,,10,void node.JSStream.Finish<Wrap> (FunctionCallbackInfo<Value>)
123278,METHOD,js_stream.cc:<global>,TYPE_DECL,"void JSStream::ReadBuffer(const FunctionCallbackInfo<Value>& args) {
  JSStream* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  ArrayBufferViewContents<char> buffer(args[0]);
  const char* data = buffer.data();
  int len = buffer.length();

  // Repeatedly ask the stream's owner for memory, copy the data that we
  // just read from JS into those buffers and emit them as reads.
  while (len != 0) {
    uv_buf_t buf = wrap->EmitAlloc(len);
    ssize_t avail = len;
    if (static_cast<ssize_t>(buf.len) < avail)
      avail = buf.len;

    memcpy(buf.base, data, avail);
    data += avail;
    len -= static_cast<int>(avail);
    wrap->EmitRead(avail, buf);
  }
}",1,1,js_stream.cc,node.JSStream.ReadBuffer,,false,164,185,ReadBuffer,,,11,void node.JSStream.ReadBuffer (FunctionCallbackInfo<Value>)
123361,METHOD,js_stream.cc:<global>,TYPE_DECL,"void JSStream::EmitEOF(const FunctionCallbackInfo<Value>& args) {
  JSStream* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  wrap->EmitRead(UV_EOF);
}",1,1,js_stream.cc,node.JSStream.EmitEOF,,false,188,193,EmitEOF,,,12,void node.JSStream.EmitEOF (FunctionCallbackInfo<Value>)
123379,METHOD,js_stream.cc:<global>,TYPE_DECL,"void JSStream::Initialize(Local<Object> target,
                          Local<Value> unused,
                          Local<Context> context,
                          void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->InstanceTemplate()
    ->SetInternalFieldCount(StreamBase::kInternalFieldCount);
  t->Inherit(AsyncWrap::GetConstructorTemplate(env));

  SetProtoMethod(isolate, t, ""finishWrite"", Finish<WriteWrap>);
  SetProtoMethod(isolate, t, ""finishShutdown"", Finish<ShutdownWrap>);
  SetProtoMethod(isolate, t, ""readBuffer"", ReadBuffer);
  SetProtoMethod(isolate, t, ""emitEOF"", EmitEOF);

  StreamBase::AddMethods(env, t);
  SetConstructorFunction(context, target, ""JSStream"", t);
}",1,1,js_stream.cc,node.JSStream.Initialize,,false,196,215,Initialize,,,13,"void node.JSStream.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
123469,METHOD,js_stream.hpp:<global>,TYPE_DECL,<global>,1,27,js_stream.hpp,js_stream.hpp:<global>,,false,1,52,<global>,,,1,
123484,METHOD,js_udp_wrap.cc:<global>,TYPE_DECL,<global>,1,26,udp_wrap.hpp,js_udp_wrap.cc:<global>,,false,1,220,<global>,,,1,
123488,METHOD,node.JSUDPWrap,TYPE_DECL,"JSUDPWrap(Environment* env, Local<Object> obj);",3,48,js_udp_wrap.cc,node.JSUDPWrap.JSUDPWrap,,false,29,29,JSUDPWrap,,,1,"ANY node.JSUDPWrap.JSUDPWrap (Environment*,Local<Object>)"
123494,METHOD,node.JSUDPWrap,TYPE_DECL,int RecvStart() override;,7,26,js_udp_wrap.cc,node.JSUDPWrap.RecvStart,,false,31,31,RecvStart,,,2,int node.JSUDPWrap.RecvStart ()
123498,METHOD,node.JSUDPWrap,TYPE_DECL,int RecvStop() override;,7,25,js_udp_wrap.cc,node.JSUDPWrap.RecvStop,,false,32,32,RecvStop,,,3,int node.JSUDPWrap.RecvStop ()
123502,METHOD,node.JSUDPWrap,TYPE_DECL,"ssize_t Send(uv_buf_t* bufs,
               size_t nbufs,
               const sockaddr* addr) override;",11,45,js_udp_wrap.cc,node.JSUDPWrap.Send,,false,33,35,Send,,,4,"ssize_t node.JSUDPWrap.Send (uv_buf_t*,size_t,sockaddr*)"
123509,METHOD,node.JSUDPWrap,TYPE_DECL,SocketAddress GetPeerName() override;,17,38,js_udp_wrap.cc,node.JSUDPWrap.GetPeerName,,false,36,36,GetPeerName,,,5,SocketAddress node.JSUDPWrap.GetPeerName ()
123513,METHOD,node.JSUDPWrap,TYPE_DECL,SocketAddress GetSockName() override;,17,38,js_udp_wrap.cc,node.JSUDPWrap.GetSockName,,false,37,37,GetSockName,,,6,SocketAddress node.JSUDPWrap.GetSockName ()
123517,METHOD,node.JSUDPWrap,TYPE_DECL,AsyncWrap* GetAsyncWrap() override { return this; },3,53,js_udp_wrap.cc,node.JSUDPWrap.GetAsyncWrap,,false,38,38,GetAsyncWrap,,,7,AsyncWrap node.JSUDPWrap.GetAsyncWrap ()
123523,METHOD,node.JSUDPWrap,TYPE_DECL,static void New(const FunctionCallbackInfo<Value>& args);,15,58,js_udp_wrap.cc,node.JSUDPWrap.New,,false,40,40,New,,,8,void node.JSUDPWrap.New (FunctionCallbackInfo<Value>)
123528,METHOD,node.JSUDPWrap,TYPE_DECL,static void EmitReceived(const FunctionCallbackInfo<Value>& args);,15,67,js_udp_wrap.cc,node.JSUDPWrap.EmitReceived,,false,41,41,EmitReceived,,,9,void node.JSUDPWrap.EmitReceived (FunctionCallbackInfo<Value>)
123533,METHOD,node.JSUDPWrap,TYPE_DECL,static void OnSendDone(const FunctionCallbackInfo<Value>& args);,15,65,js_udp_wrap.cc,node.JSUDPWrap.OnSendDone,,false,42,42,OnSendDone,,,10,void node.JSUDPWrap.OnSendDone (FunctionCallbackInfo<Value>)
123538,METHOD,node.JSUDPWrap,TYPE_DECL,static void OnAfterBind(const FunctionCallbackInfo<Value>& args);,15,66,js_udp_wrap.cc,node.JSUDPWrap.OnAfterBind,,false,43,43,OnAfterBind,,,11,void node.JSUDPWrap.OnAfterBind (FunctionCallbackInfo<Value>)
123543,METHOD,node.JSUDPWrap,TYPE_DECL,"static void Initialize(Local<Object> target,
                         Local<Value> unused,
                         Local<Context> context,
                         void* priv);",15,36,js_udp_wrap.cc,node.JSUDPWrap.Initialize,,false,45,48,Initialize,,,12,"void node.JSUDPWrap.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
123552,METHOD,js_udp_wrap.cc:<global>,TYPE_DECL,"JSUDPWrap::JSUDPWrap(Environment* env, Local<Object> obj)
  : AsyncWrap(env, obj, PROVIDER_JSUDPWRAP) {
  MakeWeak();

  obj->SetAlignedPointerInInternalField(
      kUDPWrapBaseField, static_cast<UDPWrapBase*>(this));
}",1,1,js_udp_wrap.cc,node.JSUDPWrap.JSUDPWrap,,false,54,60,JSUDPWrap,,,2,"ANY node.JSUDPWrap.JSUDPWrap (Environment*,Local<Object>)"
123567,METHOD,js_udp_wrap.cc:<global>,TYPE_DECL,"int JSUDPWrap::RecvStart() {
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  TryCatchScope try_catch(env());
  Local<Value> value;
  int32_t value_int = JS_EXCEPTION_PENDING;
  if (!MakeCallback(env()->onreadstart_string(), 0, nullptr).ToLocal(&value) ||
      !value->Int32Value(env()->context()).To(&value_int)) {
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }
  return value_int;
}",1,22,js_udp_wrap.cc,node.JSUDPWrap.RecvStart,,false,62,74,RecvStart,,,3,int node.JSUDPWrap.RecvStart ()
123650,METHOD,js_udp_wrap.cc:<global>,TYPE_DECL,"int JSUDPWrap::RecvStop() {
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  TryCatchScope try_catch(env());
  Local<Value> value;
  int32_t value_int = JS_EXCEPTION_PENDING;
  if (!MakeCallback(env()->onreadstop_string(), 0, nullptr).ToLocal(&value) ||
      !value->Int32Value(env()->context()).To(&value_int)) {
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }
  return value_int;
}",1,22,js_udp_wrap.cc,node.JSUDPWrap.RecvStop,,false,76,88,RecvStop,,,4,int node.JSUDPWrap.RecvStop ()
123733,METHOD,js_udp_wrap.cc:<global>,TYPE_DECL,"ssize_t JSUDPWrap::Send(uv_buf_t* bufs,
                        size_t nbufs,
                        const sockaddr* addr) {
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  TryCatchScope try_catch(env());
  Local<Value> value;
  int64_t value_int = JS_EXCEPTION_PENDING;
  size_t total_len = 0;

  MaybeStackBuffer<Local<Value>, 16> buffers(nbufs);
  for (size_t i = 0; i < nbufs; i++) {
    buffers[i] = Buffer::Copy(env(), bufs[i].base, bufs[i].len)
        .ToLocalChecked();
    total_len += bufs[i].len;
  }

  Local<Object> address;
  if (!AddressToJS(env(), addr).ToLocal(&address)) return value_int;

  Local<Value> args[] = {
    listener()->CreateSendWrap(total_len)->object(),
    Array::New(env()->isolate(), buffers.out(), nbufs),
    address,
  };

  if (!MakeCallback(env()->onwrite_string(), arraysize(args), args)
          .ToLocal(&value) ||
      !value->IntegerValue(env()->context()).To(&value_int)) {
    if (try_catch.HasCaught()...",1,22,js_udp_wrap.cc,node.JSUDPWrap.Send,,false,90,123,Send,,,5,"ssize_t node.JSUDPWrap.Send (uv_buf_t*,size_t,sockaddr*)"
123912,METHOD,js_udp_wrap.cc:<global>,TYPE_DECL,"SocketAddress JSUDPWrap::GetPeerName() {
  SocketAddress ret;
  CHECK(SocketAddress::New(AF_INET, ""127.0.0.1"", 1337, &ret));
  return ret;
}",1,1,js_udp_wrap.cc,node.JSUDPWrap.GetPeerName,,false,125,129,GetPeerName,,,6,SocketAddress node.JSUDPWrap.GetPeerName ()
123929,METHOD,js_udp_wrap.cc:<global>,TYPE_DECL,"SocketAddress JSUDPWrap::GetSockName() {
  SocketAddress ret;
  CHECK(SocketAddress::New(AF_INET, ""127.0.0.1"", 1337, &ret));
  return ret;
}",1,1,js_udp_wrap.cc,node.JSUDPWrap.GetSockName,,false,131,135,GetSockName,,,7,SocketAddress node.JSUDPWrap.GetSockName ()
123946,METHOD,js_udp_wrap.cc:<global>,TYPE_DECL,"void JSUDPWrap::New(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(args.IsConstructCall());
  new JSUDPWrap(env, args.Holder());
}",1,1,js_udp_wrap.cc,node.JSUDPWrap.New,,false,137,141,New,,,8,void node.JSUDPWrap.New (FunctionCallbackInfo<Value>)
123971,METHOD,js_udp_wrap.cc:<global>,TYPE_DECL,"void JSUDPWrap::EmitReceived(const FunctionCallbackInfo<Value>& args) {
  JSUDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  Environment* env = wrap->env();

  ArrayBufferViewContents<char> buffer(args[0]);
  const char* data = buffer.data();
  int len = buffer.length();

  CHECK(args[1]->IsInt32());   // family
  CHECK(args[2]->IsString());  // address
  CHECK(args[3]->IsInt32());   // port
  CHECK(args[4]->IsInt32());   // flags
  int family = args[1].As<Int32>()->Value() == 4 ? AF_INET : AF_INET6;
  Utf8Value address(env->isolate(), args[2]);
  int port = args[3].As<Int32>()->Value();
  int flags = args[3].As<Int32>()->Value();

  sockaddr_storage addr;
  CHECK_EQ(sockaddr_for_family(family, *address, port, &addr), 0);

  // Repeatedly ask the stream's owner for memory, copy the data that we
  // just read from JS into those buffers and emit them as reads.
  while (len != 0) {
    uv_buf_t buf = wrap->listener()->OnAlloc(len);
    ssize_t avail = std::min<size_t>...",1,1,js_udp_wrap.cc,node.JSUDPWrap.EmitReceived,,false,143,175,EmitReceived,,,9,void node.JSUDPWrap.EmitReceived (FunctionCallbackInfo<Value>)
124157,METHOD,js_udp_wrap.cc:<global>,TYPE_DECL,"void JSUDPWrap::OnSendDone(const FunctionCallbackInfo<Value>& args) {
  JSUDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsInt32());
  ReqWrap<uv_udp_send_t>* req_wrap;
  ASSIGN_OR_RETURN_UNWRAP(&req_wrap, args[0].As<Object>());
  int status = args[1].As<Int32>()->Value();

  wrap->listener()->OnSendDone(req_wrap, status);
}",1,1,js_udp_wrap.cc,node.JSUDPWrap.OnSendDone,,false,177,188,OnSendDone,,,10,void node.JSUDPWrap.OnSendDone (FunctionCallbackInfo<Value>)
124220,METHOD,js_udp_wrap.cc:<global>,TYPE_DECL,"void JSUDPWrap::OnAfterBind(const FunctionCallbackInfo<Value>& args) {
  JSUDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  wrap->listener()->OnAfterBind();
}",1,1,js_udp_wrap.cc,node.JSUDPWrap.OnAfterBind,,false,190,195,OnAfterBind,,,11,void node.JSUDPWrap.OnAfterBind (FunctionCallbackInfo<Value>)
124240,METHOD,js_udp_wrap.cc:<global>,TYPE_DECL,"void JSUDPWrap::Initialize(Local<Object> target,
                           Local<Value> unused,
                           Local<Context> context,
                           void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->InstanceTemplate()
    ->SetInternalFieldCount(UDPWrapBase::kUDPWrapBaseField + 1);
  t->Inherit(AsyncWrap::GetConstructorTemplate(env));

  UDPWrapBase::AddMethods(env, t);
  SetProtoMethod(isolate, t, ""emitReceived"", EmitReceived);
  SetProtoMethod(isolate, t, ""onSendDone"", OnSendDone);
  SetProtoMethod(isolate, t, ""onAfterBind"", OnAfterBind);

  SetConstructorFunction(context, target, ""JSUDPWrap"", t);
}",1,1,js_udp_wrap.cc,node.JSUDPWrap.Initialize,,false,197,215,Initialize,,,12,"void node.JSUDPWrap.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
124331,METHOD,json_parser.cc:<global>,TYPE_DECL,<global>,1,29,json_parser.hpp,json_parser.cc:<global>,,false,1,108,<global>,,,1,
124334,METHOD,json_parser.cc:<global>,TYPE_DECL,"static Isolate* NewIsolate(v8::ArrayBuffer::Allocator* allocator) {
  Isolate* isolate = Isolate::Allocate();
  CHECK_NOT_NULL(isolate);
  per_process::v8_platform.Platform()->RegisterIsolate(isolate,
                                                       uv_default_loop());
  Isolate::CreateParams params;
  params.array_buffer_allocator = allocator;
  Isolate::Initialize(isolate, params);
  return isolate;
}",1,1,json_parser.cc,node.NewIsolate,,false,15,24,NewIsolate,,,1,Isolate node.NewIsolate (ANY*)
124373,METHOD,json_parser.cc:<global>,TYPE_DECL,"void JSONParser::FreeIsolate(Isolate* isolate) {
  per_process::v8_platform.Platform()->UnregisterIsolate(isolate);
  isolate->Dispose();
}",1,1,json_parser.cc,node.JSONParser.FreeIsolate,,false,26,29,FreeIsolate,,,2,void node.JSONParser.FreeIsolate (Isolate*)
124392,METHOD,json_parser.cc:<global>,TYPE_DECL,"JSONParser::JSONParser()
    : allocator_(ArrayBuffer::Allocator::NewDefaultAllocator()),
      isolate_(NewIsolate(allocator_.get())),
      handle_scope_(isolate_.get()),
      context_(isolate_.get(), Context::New(isolate_.get())),
      context_scope_(context_.Get(isolate_.get())) {}",1,53,json_parser.cc,node.JSONParser.JSONParser,,false,31,36,JSONParser,,,3,ANY node.JSONParser.JSONParser ()
124396,METHOD,json_parser.cc:<global>,TYPE_DECL,"bool JSONParser::Parse(const std::string& content) {
  DCHECK(!parsed_);

  Isolate* isolate = isolate_.get();
  Local<Context> context = context_.Get(isolate);

  // It's not a real script, so don't print the source line.
  errors::PrinterTryCatch bootstrapCatch(
      isolate, errors::PrinterTryCatch::kDontPrintSourceLine);
  Local<Value> json_string_value;
  Local<Value> result_value;
  if (!ToV8Value(context, content).ToLocal(&json_string_value) ||
      !json_string_value->IsString() ||
      !v8::JSON::Parse(context, json_string_value.As<String>())
           .ToLocal(&result_value) ||
      !result_value->IsObject()) {
    return false;
  }
  content_.Reset(isolate, result_value.As<Object>());
  parsed_ = true;
  return true;
}",1,1,json_parser.cc,node.JSONParser.Parse,,false,38,59,Parse,,,4,bool node.JSONParser.Parse (ANY)
124497,METHOD,json_parser.cc:<global>,TYPE_DECL,"std::optional<std::string> JSONParser::GetTopLevelStringField(
    std::string_view field) {
  Isolate* isolate = isolate_.get();
  Local<Context> context = context_.Get(isolate);
  Local<Object> content_object = content_.Get(isolate);
  Local<Value> value;
  // It's not a real script, so don't print the source line.
  errors::PrinterTryCatch bootstrapCatch(
      isolate, errors::PrinterTryCatch::kDontPrintSourceLine);
  Local<Value> field_local;
  if (!ToV8Value(context, field, isolate).ToLocal(&field_local)) {
    return {};
  }
  if (!content_object->Get(context, field_local).ToLocal(&value) ||
      !value->IsString()) {
    return {};
  }
  Utf8Value utf8_value(isolate, value);
  return utf8_value.ToString();
}",1,1,json_parser.cc,node.JSONParser.GetTopLevelStringField,,false,61,80,GetTopLevelStringField,,,5,optional<std::string> node.JSONParser.GetTopLevelStringField (ANY)
124592,METHOD,json_parser.cc:<global>,TYPE_DECL,"std::optional<bool> JSONParser::GetTopLevelBoolField(std::string_view field) {
  Isolate* isolate = isolate_.get();
  Local<Context> context = context_.Get(isolate);
  Local<Object> content_object = content_.Get(isolate);
  Local<Value> value;
  bool has_field;
  // It's not a real script, so don't print the source line.
  errors::PrinterTryCatch bootstrapCatch(
      isolate, errors::PrinterTryCatch::kDontPrintSourceLine);
  Local<Value> field_local;
  if (!ToV8Value(context, field, isolate).ToLocal(&field_local)) {
    return {};
  }
  if (!content_object->Has(context, field_local).To(&has_field)) {
    return {};
  }
  if (!has_field) {
    return false;
  }
  if (!content_object->Get(context, field_local).ToLocal(&value) ||
      !value->IsBoolean()) {
    return {};
  }
  return value->BooleanValue(isolate);
}",1,1,json_parser.cc,node.JSONParser.GetTopLevelBoolField,,false,82,106,GetTopLevelBoolField,,,6,optional<bool> node.JSONParser.GetTopLevelBoolField (ANY)
124719,METHOD,json_parser.hpp:<global>,TYPE_DECL,<global>,1,29,json_parser.hpp,json_parser.hpp:<global>,,false,1,40,<global>,,,1,
124726,METHOD,json_utils.cc:<global>,TYPE_DECL,<global>,1,28,json_utils.hpp,json_utils.cc:<global>,,false,1,69,<global>,,,1,
124729,METHOD,json_utils.cc:<global>,TYPE_DECL,"std::string EscapeJsonChars(std::string_view str) {
  // 'static constexpr' is slightly better than static const
  // since the initialization occurs at compile time.
  // See https://lemire.me/blog/I3Cah
  static constexpr std::string_view control_symbols[0x20] = {
      ""\\u0000"", ""\\u0001"", ""\\u0002"", ""\\u0003"", ""\\u0004"", ""\\u0005"",
      ""\\u0006"", ""\\u0007"", ""\\b"",     ""\\t"",     ""\\n"",     ""\\u000b"",
      ""\\f"",     ""\\r"",     ""\\u000e"", ""\\u000f"", ""\\u0010"", ""\\u0011"",
      ""\\u0012"", ""\\u0013"", ""\\u0014"", ""\\u0015"", ""\\u0016"", ""\\u0017"",
      ""\\u0018"", ""\\u0019"", ""\\u001a"", ""\\u001b"", ""\\u001c"", ""\\u001d"",
      ""\\u001e"", ""\\u001f""};

  std::string ret;
  size_t last_pos = 0;
  size_t pos = 0;
  for (; pos < str.size(); ++pos) {
    std::string replace;
    char ch = str[pos];
    if (ch == '\\') {
      replace = ""\\\\"";
    } else if (ch == '\""') {
      replace = ""\\\"""";
    } else {
      size_t num = static_cast<size_t>(ch);
      if (num < 0x20) replace = control...",1,1,json_utils.cc,node.EscapeJsonChars,,false,5,44,EscapeJsonChars,,,1,string node.EscapeJsonChars (ANY)
124883,METHOD,json_utils.cc:<global>,TYPE_DECL,"std::string Reindent(const std::string& str, int indent_depth) {
  if (indent_depth <= 0) return str;
  const std::string indent(indent_depth, ' ');
  std::string out;
  std::string::size_type pos = 0;
  for (;;) {
    std::string::size_type prev_pos = pos;
    pos = str.find('\n', pos);

    out.append(indent);

    if (pos == std::string::npos) {
      out.append(str, prev_pos, std::string::npos);
      break;
    } else {
      pos++;
      out.append(str, prev_pos, pos - prev_pos);
    }
  }

  return out;
}",1,1,json_utils.cc,node.Reindent,,false,46,67,Reindent,,,2,"string node.Reindent (ANY,int)"
124974,METHOD,json_utils.hpp:<global>,TYPE_DECL,<global>,1,28,json_utils.hpp,json_utils.hpp:<global>,,false,1,172,<global>,,,1,
125011,METHOD,large_pages\node_large_page.cc:<global>,TYPE_DECL,<global>,1,1,large_pages\node_large_page.cc,large_pages\node_large_page.cc:<global>,,false,1,464,<global>,,,1,
125014,METHOD,large_pages\node_large_page.cc:<global>,TYPE_DECL,"int MapStaticCodeToLargePages() {
#if defined(NODE_ENABLE_LARGE_CODE_PAGES) && NODE_ENABLE_LARGE_CODE_PAGES
  bool have_thp = false;
#if defined(__linux__)
  have_thp = IsTransparentHugePagesEnabled();
#elif defined(__FreeBSD__)
  have_thp = IsSuperPagesEnabled();
#elif defined(__APPLE__)
  // pse-36 flag is present in recent mac x64 products.
  have_thp = true;
#endif
  if (!have_thp)
    return EACCES;

  struct text_region r = FindNodeTextRegion();
  if (r.found_text_region == false)
    return ENOENT;

  return MoveTextRegionToLargePages(r);
#else
  return ENOTSUP;
#endif
}",1,1,large_pages\node_large_page.cc,node.MapStaticCodeToLargePages,,false,417,439,MapStaticCodeToLargePages,,,1,int node.MapStaticCodeToLargePages ()
125020,METHOD,large_pages\node_large_page.cc:<global>,TYPE_DECL,"const char* LargePagesError(int status) {
  switch (status) {
    case ENOTSUP:
      return ""Mapping to large pages is not supported."";

    case EACCES:
      return ""Large pages are not enabled."";

    case ENOENT:
      return ""failed to find text region"";

    case -1:
      return ""Mapping code to large pages failed. Reverting to default page ""
          ""size."";

    case 0:
      return ""OK"";

    default:
      return ""Unknown error"";
  }
}",1,1,large_pages\node_large_page.cc,node.LargePagesError,,false,441,462,LargePagesError,,,2,const char* node.LargePagesError (int)
125055,METHOD,large_pages\node_large_page.hpp:<global>,TYPE_DECL,<global>,1,45,large_pages\node_large_page.hpp,large_pages\node_large_page.hpp:<global>,,false,1,34,<global>,,,1,
125064,METHOD,memory_tracker-inl.hpp:<global>,TYPE_DECL,<global>,1,36,memory_tracker-inl.hpp,memory_tracker-inl.hpp:<global>,,false,1,356,<global>,,,1,
125083,METHOD,memory_tracker.hpp:<global>,TYPE_DECL,<global>,1,62,memory_tracker.hpp,memory_tracker.hpp:<global>,,false,1,289,<global>,,,1,
125086,METHOD,module_wrap.cc:<global>,TYPE_DECL,"[&]() {
    MaybeLocal<Value> result = module->Evaluate(context);
    if (!result.IsEmpty() && microtask_queue)
      microtask_queue->PerformCheckpoint(isolate);
    return result;
  }",14,3,module_wrap.cc,node.loader.ModuleWrap.Evaluate.<lambda>0,,false,384,389,<lambda>0,,,1,ANY node.loader.ModuleWrap.Evaluate.<lambda>0 ()
125145,METHOD,module_wrap.cc:<global>,TYPE_DECL,<global>,1,29,module_wrap.hpp,module_wrap.cc:<global>,,false,1,834,<global>,,,1,
125149,METHOD,module_wrap.cc:<global>,TYPE_DECL,"ModuleWrap::ModuleWrap(Environment* env,
                       Local<Object> object,
                       Local<Module> module,
                       Local<String> url)
  : BaseObject(env, object),
    module_(env->isolate(), module),
    id_(env->get_next_module_id()) {
  env->id_to_module_map.emplace(id_, this);

  Local<Value> undefined = Undefined(env->isolate());
  object->SetInternalField(kURLSlot, url);
  object->SetInternalField(kSyntheticEvaluationStepsSlot, undefined);
  object->SetInternalField(kContextObjectSlot, undefined);
}",1,1,module_wrap.cc,node.loader.ModuleWrap.ModuleWrap,,false,52,65,ModuleWrap,,,1,"ANY node.loader.ModuleWrap.ModuleWrap (Environment*,Local<Object>,Local<Module>,Local<String>)"
125194,METHOD,module_wrap.cc:<global>,TYPE_DECL,"ModuleWrap::~ModuleWrap() {
  HandleScope scope(env()->isolate());
  Local<Module> module = module_.Get(env()->isolate());
  env()->id_to_module_map.erase(id_);
  auto range = env()->hash_to_module_map.equal_range(module->GetIdentityHash());
  for (auto it = range.first; it != range.second; ++it) {
    if (it->second == this) {
      env()->hash_to_module_map.erase(it);
      break;
    }
  }
}",1,1,module_wrap.cc,node.loader.ModuleWrap.~ModuleWrap,,false,67,78,~ModuleWrap,,,2,ANY node.loader.ModuleWrap.~ModuleWrap ()
125269,METHOD,module_wrap.cc:<global>,TYPE_DECL,"Local<Context> ModuleWrap::context() const {
  Local<Value> obj = object()->GetInternalField(kContextObjectSlot);
  if (obj.IsEmpty()) return {};
  return obj.As<Object>()->GetCreationContext().ToLocalChecked();
}",1,1,module_wrap.cc,node.loader.ModuleWrap.context,,false,80,84,context,,,3,Local<Context> node.loader.ModuleWrap.context ()
125302,METHOD,module_wrap.cc:<global>,TYPE_DECL,"ModuleWrap* ModuleWrap::GetFromModule(Environment* env,
                                      Local<Module> module) {
  auto range = env->hash_to_module_map.equal_range(module->GetIdentityHash());
  for (auto it = range.first; it != range.second; ++it) {
    if (it->second->module_ == module) {
      return it->second;
    }
  }
  return nullptr;
}",1,1,module_wrap.cc,node.loader.ModuleWrap.GetFromModule,,false,86,95,GetFromModule,,,4,"ModuleWrap node.loader.ModuleWrap.GetFromModule (Environment*,Local<Module>)"
125352,METHOD,module_wrap.cc:<global>,TYPE_DECL,"ModuleWrap* ModuleWrap::GetFromID(Environment* env, uint32_t id) {
  auto module_wrap_it = env->id_to_module_map.find(id);
  if (module_wrap_it == env->id_to_module_map.end()) {
    return nullptr;
  }
  return module_wrap_it->second;
}",1,1,module_wrap.cc,node.loader.ModuleWrap.GetFromID,,false,97,103,GetFromID,,,5,"ModuleWrap node.loader.ModuleWrap.GetFromID (Environment*,uint32_t)"
125384,METHOD,module_wrap.cc:<global>,TYPE_DECL,"void ModuleWrap::New(const FunctionCallbackInfo<Value>& args) {
  CHECK(args.IsConstructCall());
  CHECK_GE(args.Length(), 3);

  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  Local<Object> that = args.This();

  CHECK(args[0]->IsString());
  Local<String> url = args[0].As<String>();

  Local<Context> context;
  ContextifyContext* contextify_context = nullptr;
  if (args[1]->IsUndefined()) {
    context = that->GetCreationContext().ToLocalChecked();
  } else {
    CHECK(args[1]->IsObject());
    contextify_context = ContextifyContext::ContextFromContextifiedSandbox(
        env, args[1].As<Object>());
    CHECK_NOT_NULL(contextify_context);
    context = contextify_context->context();
  }

  int line_offset = 0;
  int column_offset = 0;

  bool synthetic = args[2]->IsArray();
  if (synthetic) {
    // new ModuleWrap(url, context, exportNames, syntheticExecutionFunction)
    CHECK(args[3]->IsFunction());
  } else {
    // new ModuleWrap(url...",1,1,module_wrap.cc,node.loader.ModuleWrap.New,,false,107,251,New,,,6,void node.loader.ModuleWrap.New (FunctionCallbackInfo<Value>)
126011,METHOD,module_wrap.cc:<global>,TYPE_DECL,"static Local<Object> createImportAssertionContainer(Environment* env,
  Isolate* isolate, Local<FixedArray> raw_assertions) {
  Local<Object> assertions =
        Object::New(isolate, v8::Null(env->isolate()), nullptr, nullptr, 0);
  for (int i = 0; i < raw_assertions->Length(); i += 3) {
      assertions
          ->Set(env->context(),
                raw_assertions->Get(env->context(), i).As<String>(),
                raw_assertions->Get(env->context(), i + 1).As<Value>())
          .ToChecked();
  }

  return assertions;
}",1,1,module_wrap.cc,node.loader.createImportAssertionContainer,,false,253,266,createImportAssertionContainer,,,7,"Local<Object> node.loader.createImportAssertionContainer (Environment*,Isolate*,Local<FixedArray>)"
126095,METHOD,module_wrap.cc:<global>,TYPE_DECL,"void ModuleWrap::Link(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = args.GetIsolate();

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsFunction());

  Local<Object> that = args.This();

  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, that);

  if (obj->linked_)
    return;
  obj->linked_ = true;

  Local<Function> resolver_arg = args[0].As<Function>();

  Local<Context> mod_context = obj->context();
  Local<Module> module = obj->module_.Get(isolate);

  Local<FixedArray> module_requests = module->GetModuleRequests();
  const int module_requests_length = module_requests->Length();
  MaybeStackBuffer<Local<Value>, 16> promises(module_requests_length);

  // call the dependency resolve callbacks
  for (int i = 0; i < module_requests_length; i++) {
    Local<ModuleRequest> module_request =
      module_requests->Get(env->context(), i).As<ModuleRequest>();
    Local<String> specifier = module_request->GetSpecifier...",1,1,module_wrap.cc,node.loader.ModuleWrap.Link,,false,268,330,Link,,,8,void node.loader.ModuleWrap.Link (FunctionCallbackInfo<Value>)
126382,METHOD,module_wrap.cc:<global>,TYPE_DECL,"void ModuleWrap::Instantiate(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = args.GetIsolate();
  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());
  Local<Context> context = obj->context();
  Local<Module> module = obj->module_.Get(isolate);
  TryCatchScope try_catch(env);
  USE(module->InstantiateModule(context, ResolveModuleCallback));

  // clear resolve cache on instantiate
  obj->resolve_cache_.clear();

  if (try_catch.HasCaught() && !try_catch.HasTerminated()) {
    CHECK(!try_catch.Message().IsEmpty());
    CHECK(!try_catch.Exception().IsEmpty());
    AppendExceptionLine(env, try_catch.Exception(), try_catch.Message(),
                        ErrorHandlingMode::MODULE_ERROR);
    try_catch.ReThrow();
    return;
  }
}",1,1,module_wrap.cc,node.loader.ModuleWrap.Instantiate,,false,332,353,Instantiate,,,9,void node.loader.ModuleWrap.Instantiate (FunctionCallbackInfo<Value>)
126497,METHOD,module_wrap.cc:<global>,TYPE_DECL,"void ModuleWrap::Evaluate(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());
  Local<Context> context = obj->context();
  Local<Module> module = obj->module_.Get(isolate);

  ContextifyContext* contextify_context = obj->contextify_context_;
  std::shared_ptr<MicrotaskQueue> microtask_queue;
  if (contextify_context != nullptr)
      microtask_queue = contextify_context->microtask_queue();

  // module.evaluate(timeout, breakOnSigint)
  CHECK_EQ(args.Length(), 2);

  CHECK(args[0]->IsNumber());
  int64_t timeout = args[0]->IntegerValue(env->context()).FromJust();

  CHECK(args[1]->IsBoolean());
  bool break_on_sigint = args[1]->IsTrue();

  ShouldNotAbortOnUncaughtScope no_abort_scope(env);
  TryCatchScope try_catch(env);
  Isolate::SafeForTerminationScope safe_for_termination(env->isolate());

  bool timed_out = false;
  bool received_sign...",1,1,module_wrap.cc,node.loader.ModuleWrap.Evaluate,,false,355,430,Evaluate,,,10,void node.loader.ModuleWrap.Evaluate (FunctionCallbackInfo<Value>)
126780,METHOD,module_wrap.cc:<global>,TYPE_DECL,"void ModuleWrap::GetNamespace(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = args.GetIsolate();
  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());

  Local<Module> module = obj->module_.Get(isolate);

  switch (module->GetStatus()) {
    case v8::Module::Status::kUninstantiated:
    case v8::Module::Status::kInstantiating:
      return env->ThrowError(
          ""cannot get namespace, module has not been instantiated"");
    case v8::Module::Status::kInstantiated:
    case v8::Module::Status::kEvaluating:
    case v8::Module::Status::kEvaluated:
    case v8::Module::Status::kErrored:
      break;
    default:
      UNREACHABLE();
  }

  Local<Value> result = module->GetModuleNamespace();
  args.GetReturnValue().Set(result);
}",1,1,module_wrap.cc,node.loader.ModuleWrap.GetNamespace,,false,432,456,GetNamespace,,,11,void node.loader.ModuleWrap.GetNamespace (FunctionCallbackInfo<Value>)
126902,METHOD,module_wrap.cc:<global>,TYPE_DECL,"void ModuleWrap::GetStatus(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();
  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());

  Local<Module> module = obj->module_.Get(isolate);

  args.GetReturnValue().Set(module->GetStatus());
}",1,1,module_wrap.cc,node.loader.ModuleWrap.GetStatus,,false,458,466,GetStatus,,,12,void node.loader.ModuleWrap.GetStatus (FunctionCallbackInfo<Value>)
126946,METHOD,module_wrap.cc:<global>,TYPE_DECL,"void ModuleWrap::GetStaticDependencySpecifiers(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());

  Local<Module> module = obj->module_.Get(env->isolate());

  Local<FixedArray> module_requests = module->GetModuleRequests();
  int count = module_requests->Length();

  MaybeStackBuffer<Local<Value>, 16> specifiers(count);

  for (int i = 0; i < count; i++) {
    Local<ModuleRequest> module_request =
      module_requests->Get(env->context(), i).As<ModuleRequest>();
    specifiers[i] = module_request->GetSpecifier();
  }

  args.GetReturnValue().Set(
      Array::New(env->isolate(), specifiers.out(), count));
}",1,1,module_wrap.cc,node.loader.ModuleWrap.GetStaticDependencySpecifiers,,false,468,489,GetStaticDependencySpecifiers,,,13,void node.loader.ModuleWrap.GetStaticDependencySpecifiers (FunctionCallbackInfo<Value>)
127061,METHOD,module_wrap.cc:<global>,TYPE_DECL,"void ModuleWrap::GetError(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();
  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());

  Local<Module> module = obj->module_.Get(isolate);
  args.GetReturnValue().Set(module->GetException());
}",1,1,module_wrap.cc,node.loader.ModuleWrap.GetError,,false,491,498,GetError,,,14,void node.loader.ModuleWrap.GetError (FunctionCallbackInfo<Value>)
127105,METHOD,module_wrap.cc:<global>,TYPE_DECL,"MaybeLocal<Module> ModuleWrap::ResolveModuleCallback(
    Local<Context> context,
    Local<String> specifier,
    Local<FixedArray> import_assertions,
    Local<Module> referrer) {
  Environment* env = Environment::GetCurrent(context);
  if (env == nullptr) {
    Isolate* isolate = context->GetIsolate();
    THROW_ERR_EXECUTION_ENVIRONMENT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Module>();
  }

  Isolate* isolate = env->isolate();

  Utf8Value specifier_utf8(isolate, specifier);
  std::string specifier_std(*specifier_utf8, specifier_utf8.length());

  ModuleWrap* dependent = GetFromModule(env, referrer);
  if (dependent == nullptr) {
    THROW_ERR_VM_MODULE_LINK_FAILURE(
        env, ""request for '%s' is from invalid module"", specifier_std);
    return MaybeLocal<Module>();
  }

  if (dependent->resolve_cache_.count(specifier_std) != 1) {
    THROW_ERR_VM_MODULE_LINK_FAILURE(
        env, ""request for '%s' is not in cache"", specifier_std);
    return MaybeLocal<Module>();
  }...",1,1,module_wrap.cc,node.loader.ModuleWrap.ResolveModuleCallback,,false,500,549,ResolveModuleCallback,,,15,"MaybeLocal<Module> node.loader.ModuleWrap.ResolveModuleCallback (Local<Context>,Local<String>,Local<FixedArray>,Local<Module>)"
127266,METHOD,module_wrap.cc:<global>,TYPE_DECL,"static MaybeLocal<Promise> ImportModuleDynamically(
    Local<Context> context,
    Local<v8::Data> host_defined_options,
    Local<Value> resource_name,
    Local<String> specifier,
    Local<FixedArray> import_assertions) {
  Isolate* isolate = context->GetIsolate();
  Environment* env = Environment::GetCurrent(context);
  if (env == nullptr) {
    THROW_ERR_EXECUTION_ENVIRONMENT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Promise>();
  }

  EscapableHandleScope handle_scope(isolate);

  Local<Function> import_callback =
    env->host_import_module_dynamically_callback();

  Local<FixedArray> options = host_defined_options.As<FixedArray>();
  if (options->Length() != HostDefinedOptions::kLength) {
    Local<Promise::Resolver> resolver;
    if (!Promise::Resolver::New(context).ToLocal(&resolver)) return {};
    resolver
        ->Reject(context,
                 v8::Exception::TypeError(FIXED_ONE_BYTE_STRING(
                     context->GetIsolate(), ""Invalid host defined optio...",1,1,module_wrap.cc,node.loader.ImportModuleDynamically,,false,551,625,ImportModuleDynamically,,,16,"MaybeLocal<Promise> node.loader.ImportModuleDynamically (Local<Context>,ANY,Local<Value>,Local<String>,Local<FixedArray>)"
127577,METHOD,module_wrap.cc:<global>,TYPE_DECL,"void ModuleWrap::SetImportModuleDynamicallyCallback(
    const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();
  Environment* env = Environment::GetCurrent(args);
  HandleScope handle_scope(isolate);

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsFunction());
  Local<Function> import_callback = args[0].As<Function>();
  env->set_host_import_module_dynamically_callback(import_callback);

  isolate->SetHostImportModuleDynamicallyCallback(ImportModuleDynamically);
}",1,1,module_wrap.cc,node.loader.ModuleWrap.SetImportModuleDynamicallyCallback,,false,627,639,SetImportModuleDynamicallyCallback,,,17,void node.loader.ModuleWrap.SetImportModuleDynamicallyCallback (FunctionCallbackInfo<Value>)
127635,METHOD,module_wrap.cc:<global>,TYPE_DECL,"void ModuleWrap::HostInitializeImportMetaObjectCallback(
    Local<Context> context, Local<Module> module, Local<Object> meta) {
  Environment* env = Environment::GetCurrent(context);
  if (env == nullptr)
    return;
  ModuleWrap* module_wrap = GetFromModule(env, module);

  if (module_wrap == nullptr) {
    return;
  }

  Local<Object> wrap = module_wrap->object();
  Local<Function> callback =
      env->host_initialize_import_meta_object_callback();
  Local<Value> args[] = { wrap, meta };
  TryCatchScope try_catch(env);
  USE(callback->Call(
        context, Undefined(env->isolate()), arraysize(args), args));
  if (try_catch.HasCaught() && !try_catch.HasTerminated()) {
    try_catch.ReThrow();
  }
}",1,1,module_wrap.cc,node.loader.ModuleWrap.HostInitializeImportMetaObjectCallback,,false,641,662,HostInitializeImportMetaObjectCallback,,,18,"void node.loader.ModuleWrap.HostInitializeImportMetaObjectCallback (Local<Context>,Local<Module>,Local<Object>)"
127727,METHOD,module_wrap.cc:<global>,TYPE_DECL,"void ModuleWrap::SetInitializeImportMetaObjectCallback(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsFunction());
  Local<Function> import_meta_callback = args[0].As<Function>();
  env->set_host_initialize_import_meta_object_callback(import_meta_callback);

  isolate->SetHostInitializeImportMetaObjectCallback(
      HostInitializeImportMetaObjectCallback);
}",1,1,module_wrap.cc,node.loader.ModuleWrap.SetInitializeImportMetaObjectCallback,,false,664,676,SetInitializeImportMetaObjectCallback,,,19,void node.loader.ModuleWrap.SetInitializeImportMetaObjectCallback (FunctionCallbackInfo<Value>)
127782,METHOD,module_wrap.cc:<global>,TYPE_DECL,"MaybeLocal<Value> ModuleWrap::SyntheticModuleEvaluationStepsCallback(
    Local<Context> context, Local<Module> module) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  ModuleWrap* obj = GetFromModule(env, module);

  TryCatchScope try_catch(env);
  Local<Function> synthetic_evaluation_steps =
      obj->object()->GetInternalField(kSyntheticEvaluationStepsSlot)
          .As<Function>();
  obj->object()->SetInternalField(
      kSyntheticEvaluationStepsSlot, Undefined(isolate));
  MaybeLocal<Value> ret = synthetic_evaluation_steps->Call(context,
      obj->object(), 0, nullptr);
  if (ret.IsEmpty()) {
    CHECK(try_catch.HasCaught());
  }
  if (try_catch.HasCaught() && !try_catch.HasTerminated()) {
    CHECK(!try_catch.Message().IsEmpty());
    CHECK(!try_catch.Exception().IsEmpty());
    try_catch.ReThrow();
    return MaybeLocal<Value>();
  }

  Local<Promise::Resolver> resolver;
  if (!Promise::Resolver::New(context).ToLocal(&resolv...",1,1,module_wrap.cc,node.loader.ModuleWrap.SyntheticModuleEvaluationStepsCallback,,false,678,710,SyntheticModuleEvaluationStepsCallback,,,20,"MaybeLocal<Value> node.loader.ModuleWrap.SyntheticModuleEvaluationStepsCallback (Local<Context>,Local<Module>)"
127942,METHOD,module_wrap.cc:<global>,TYPE_DECL,"void ModuleWrap::SetSyntheticExport(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();
  Local<Object> that = args.This();

  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, that);

  CHECK(obj->synthetic_);

  CHECK_EQ(args.Length(), 2);

  CHECK(args[0]->IsString());
  Local<String> export_name = args[0].As<String>();

  Local<Value> export_value = args[1];

  Local<Module> module = obj->module_.Get(isolate);
  USE(module->SetSyntheticModuleExport(isolate, export_name, export_value));
}",1,1,module_wrap.cc,node.loader.ModuleWrap.SetSyntheticExport,,false,712,730,SetSyntheticExport,,,21,void node.loader.ModuleWrap.SetSyntheticExport (FunctionCallbackInfo<Value>)
128028,METHOD,module_wrap.cc:<global>,TYPE_DECL,"void ModuleWrap::CreateCachedData(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();
  Local<Object> that = args.This();

  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, that);

  CHECK(!obj->synthetic_);

  Local<Module> module = obj->module_.Get(isolate);

  CHECK_LT(module->GetStatus(), v8::Module::Status::kEvaluating);

  Local<UnboundModuleScript> unbound_module_script =
      module->GetUnboundModuleScript();
  std::unique_ptr<ScriptCompiler::CachedData> cached_data(
      ScriptCompiler::CreateCodeCache(unbound_module_script));
  Environment* env = Environment::GetCurrent(args);
  if (!cached_data) {
    args.GetReturnValue().Set(Buffer::New(env, 0).ToLocalChecked());
  } else {
    MaybeLocal<Object> buf =
        Buffer::Copy(env,
                     reinterpret_cast<const char*>(cached_data->data),
                     cached_data->length);
    args.GetReturnValue().Set(buf.ToLocalChecked());
  }
}",1,1,module_wrap.cc,node.loader.ModuleWrap.CreateCachedData,,false,732,759,CreateCachedData,,,22,void node.loader.ModuleWrap.CreateCachedData (FunctionCallbackInfo<Value>)
128093,METHOD,module_wrap.cc:<global>,TYPE_DECL,"std::unique_ptr<ScriptCompiler::CachedData> cached_data(
      ScriptCompiler::CreateCodeCache(unbound_module_script));",47,61,module_wrap.cc,node.loader.ModuleWrap.CreateCachedData.cached_data,,false,747,748,cached_data,,,10,ANY node.loader.ModuleWrap.CreateCachedData.cached_data (ANY)
128160,METHOD,module_wrap.cc:<global>,TYPE_DECL,"void ModuleWrap::Initialize(Local<Object> target,
                            Local<Value> unused,
                            Local<Context> context,
                            void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> tpl = NewFunctionTemplate(isolate, New);
  tpl->InstanceTemplate()->SetInternalFieldCount(
      ModuleWrap::kInternalFieldCount);

  SetProtoMethod(isolate, tpl, ""link"", Link);
  SetProtoMethod(isolate, tpl, ""instantiate"", Instantiate);
  SetProtoMethod(isolate, tpl, ""evaluate"", Evaluate);
  SetProtoMethod(isolate, tpl, ""setExport"", SetSyntheticExport);
  SetProtoMethodNoSideEffect(
      isolate, tpl, ""createCachedData"", CreateCachedData);
  SetProtoMethodNoSideEffect(isolate, tpl, ""getNamespace"", GetNamespace);
  SetProtoMethodNoSideEffect(isolate, tpl, ""getStatus"", GetStatus);
  SetProtoMethodNoSideEffect(isolate, tpl, ""getError"", GetError);
  SetProtoMethodNoSideEffect(is...",1,4,module_wrap.cc,node.loader.ModuleWrap.Initialize,,false,761,809,Initialize,,,23,"void node.loader.ModuleWrap.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
128436,METHOD,module_wrap.cc:<global>,TYPE_DECL,"void ModuleWrap::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(New);

  registry->Register(Link);
  registry->Register(Instantiate);
  registry->Register(Evaluate);
  registry->Register(SetSyntheticExport);
  registry->Register(CreateCachedData);
  registry->Register(GetNamespace);
  registry->Register(GetStatus);
  registry->Register(GetError);
  registry->Register(GetStaticDependencySpecifiers);

  registry->Register(SetImportModuleDynamicallyCallback);
  registry->Register(SetInitializeImportMetaObjectCallback);
}",1,1,module_wrap.cc,node.loader.ModuleWrap.RegisterExternalReferences,,false,811,827,RegisterExternalReferences,,,24,void node.loader.ModuleWrap.RegisterExternalReferences (ExternalReferenceRegistry*)
128513,METHOD,module_wrap.hpp:<global>,TYPE_DECL,<global>,1,29,module_wrap.hpp,module_wrap.hpp:<global>,,false,1,118,<global>,,,1,
128516,METHOD,node.cc:<global>,TYPE_DECL,"[](void* data) {
      Environment* env = static_cast<Environment*>(data);
      env->isolate()->SetAtomicsWaitCallback(nullptr, nullptr);
    }",20,5,node.cc,node.Environment.InitializeDiagnostics.<lambda>0,,false,255,258,<lambda>0,,,1,ANY node.Environment.InitializeDiagnostics.<lambda>0 (void*)
128538,METHOD,node.cc:<global>,TYPE_DECL,[&]() { env->set_embedder_entry_point({}); },22,65,node.cc,node.StartExecution.<lambda>1,,false,284,284,<lambda>1,,,1,ANY node.StartExecution.<lambda>1 ()
128549,METHOD,node.cc:<global>,TYPE_DECL,"[&]() {
    TearDownOncePerProcess();

    if (snapshot_data != nullptr &&
        snapshot_data->data_ownership == SnapshotData::DataOwnership::kOwned) {
      delete snapshot_data;
    }
  }",39,3,node.cc,node.StartInternal.<lambda>2,,false,1265,1272,<lambda>2,,,1,ANY node.StartInternal.<lambda>2 ()
128680,METHOD,node.cc:<global>,TYPE_DECL,<global>,1,1,node.cc,node.cc:<global>,,false,1,1314,<global>,,,1,
128700,METHOD,node.cc:<global>,TYPE_DECL,"static void AtomicsWaitCallback(Isolate::AtomicsWaitEvent event,
                                Local<v8::SharedArrayBuffer> array_buffer,
                                size_t offset_in_bytes, int64_t value,
                                double timeout_in_ms,
                                Isolate::AtomicsWaitWakeHandle* stop_handle,
                                void* data) {
  Environment* env = static_cast<Environment*>(data);

  const char* message = ""(unknown event)"";
  switch (event) {
#define V(key, msg)                         \
    case Isolate::AtomicsWaitEvent::key:    \
      message = msg;                        \
      break;
    ATOMIC_WAIT_EVENTS(V)
#undef V
  }

  fprintf(stderr,
          ""(node:%d) [Thread %"" PRIu64 ""] Atomics.wait(%p + %zx, %"" PRId64
          "", %.f) %s\n"",
          static_cast<int>(uv_os_getpid()),
          env->thread_id(),
          array_buffer->Data(),
          offset_in_bytes,
          value,
          timeout_in_ms,
          ...",1,4,node.cc,node.AtomicsWaitCallback,,false,215,243,AtomicsWaitCallback,,,4,"void node.AtomicsWaitCallback (ANY,ANY,size_t,int64_t,double,ANY*,void*)"
128787,METHOD,node.cc:<global>,TYPE_DECL,"void Environment::InitializeDiagnostics() {
  isolate_->GetHeapProfiler()->AddBuildEmbedderGraphCallback(
      Environment::BuildEmbedderGraph, this);
  if (heap_snapshot_near_heap_limit_ > 0) {
    AddHeapSnapshotNearHeapLimitCallback();
  }
  if (options_->trace_uncaught)
    isolate_->SetCaptureStackTraceForUncaughtExceptions(true);
  if (options_->trace_atomics_wait) {
    isolate_->SetAtomicsWaitCallback(AtomicsWaitCallback, this);
    AddCleanupHook([](void* data) {
      Environment* env = static_cast<Environment*>(data);
      env->isolate()->SetAtomicsWaitCallback(nullptr, nullptr);
    }, this);
  }
}",1,1,node.cc,node.Environment.InitializeDiagnostics,,false,245,260,InitializeDiagnostics,,,5,void node.Environment.InitializeDiagnostics ()
128832,METHOD,node.cc:<global>,TYPE_DECL,"static
MaybeLocal<Value> StartExecution(Environment* env, const char* main_script_id) {
  EscapableHandleScope scope(env->isolate());
  CHECK_NOT_NULL(main_script_id);
  Realm* realm = env->principal_realm();

  return scope.EscapeMaybe(realm->ExecuteBootstrapper(main_script_id));
}",1,1,node.cc,node.StartExecution,,false,262,269,StartExecution,,,6,"MaybeLocal<Value> node.StartExecution (Environment*,char*)"
128863,METHOD,node.cc:<global>,TYPE_DECL,"MaybeLocal<Value> StartExecution(Environment* env, StartExecutionCallback cb) {
  InternalCallbackScope callback_scope(
      env,
      Object::New(env->isolate()),
      { 1, 0 },
      InternalCallbackScope::kSkipAsyncHooks);

  if (cb != nullptr) {
    EscapableHandleScope scope(env->isolate());
    // TODO(addaleax): pass the callback to the main script more directly,
    // e.g. by making StartExecution(env, builtin) parametrizable
    env->set_embedder_entry_point(std::move(cb));
    auto reset_entry_point =
        OnScopeLeave([&]() { env->set_embedder_entry_point({}); });

    const char* entry = env->isolate_data()->is_building_snapshot()
                            ? ""internal/main/mksnapshot""
                            : ""internal/main/embedding"";

    return scope.EscapeMaybe(StartExecution(env, entry));
  }

  CHECK(!env->isolate_data()->is_building_snapshot());

  // TODO(joyeecheung): move these conditions into JS land and let the
  // deserialize main function tak...",1,1,node.cc,node.StartExecution,,false,271,350,StartExecution,,,7,"MaybeLocal<Value> node.StartExecution (Environment*,StartExecutionCallback)"
129111,METHOD,node.cc:<global>,TYPE_DECL,"void ResetSignalHandlers() {
#ifdef __POSIX__
  // Restore signal dispositions, the parent process may have changed them.
  struct sigaction act;
  memset(&act, 0, sizeof(act));

  // The hard-coded upper limit is because NSIG is not very reliable; on Linux,
  // it evaluates to 32, 34 or 64, depending on whether RT signals are enabled.
  // Counting up to SIGRTMIN doesn't work for the same reason.
  for (unsigned nr = 1; nr < kMaxSignal; nr += 1) {
    if (nr == SIGKILL || nr == SIGSTOP)
      continue;
    act.sa_handler = (nr == SIGPIPE || nr == SIGXFSZ) ? SIG_IGN : SIG_DFL;
    if (act.sa_handler == SIG_DFL) {
      // The only bad handler value we can inhert from before exec is SIG_IGN
      // (any actual function pointer is reset to SIG_DFL during exec).
      // If that's the case, we want to reset it back to SIG_DFL.
      // However, it's also possible that an embeder (or an LD_PRELOAD-ed
      // library) has set up own signal handler for own purposes
      // (e.g. profi...",1,1,node.cc,node.ResetSignalHandlers,,false,435,462,ResetSignalHandlers,,,8,void node.ResetSignalHandlers ()
129123,METHOD,node.cc:<global>,TYPE_DECL,"static void PlatformInit(ProcessInitializationFlags::Flags flags) {
  // init_process_flags is accessed in ResetStdio(),
  // which can be called from signal handlers.
  CHECK(init_process_flags.is_lock_free());
  init_process_flags.store(flags);

  if (!(flags & ProcessInitializationFlags::kNoStdioInitialization)) {
    atexit(ResetStdio);
  }

#ifdef __POSIX__
  if (!(flags & ProcessInitializationFlags::kNoStdioInitialization)) {
    // Disable stdio buffering, it interacts poorly with printf()
    // calls elsewhere in the program (e.g., any logging from V8.)
    setvbuf(stdout, nullptr, _IONBF, 0);
    setvbuf(stderr, nullptr, _IONBF, 0);

    // Make sure file descriptors 0-2 are valid before we start logging
    // anything.
    for (auto& s : stdio) {
      const int fd = &s - stdio;
      if (fstat(fd, &s.stat) == 0) continue;

      // Anything but EBADF means something is seriously wrong.  We don't
      // have to special-case EINTR, fstat() is not interruptible.
      if...",1,1,node.cc,node.PlatformInit,,false,472,627,PlatformInit,,,12,void node.PlatformInit (ANY)
129147,METHOD,node.cc:<global>,TYPE_DECL,"void ResetStdio() {
  if (init_process_flags.load() &
      ProcessInitializationFlags::kNoStdioInitialization) {
    return;
  }

  uv_tty_reset_mode();
#ifdef __POSIX__
  for (auto& s : stdio) {
    const int fd = &s - stdio;

    struct stat tmp;
    if (-1 == fstat(fd, &tmp)) {
      CHECK_EQ(errno, EBADF);  // Program closed file descriptor.
      continue;
    }

    bool is_same_file =
        (s.stat.st_dev == tmp.st_dev && s.stat.st_ino == tmp.st_ino);
    if (!is_same_file) continue;  // Program reopened file descriptor.

    int flags;
    do
      flags = fcntl(fd, F_GETFL);
    while (flags == -1 && errno == EINTR);  // NOLINT
    CHECK_NE(flags, -1);

    // Restore the O_NONBLOCK flag if it changed.
    if (O_NONBLOCK & (flags ^ s.flags)) {
      flags &= ~O_NONBLOCK;
      flags |= s.flags & O_NONBLOCK;

      int err;
      do
        err = fcntl(fd, F_SETFL, flags);
      while (err == -1 && errno == EINTR);  // NOLINT
      CHECK_NE(err, -1);
    }

    if (s.isat...",1,1,node.cc,node.ResetStdio,,false,630,690,ResetStdio,,,13,void node.ResetStdio ()
129163,METHOD,node.cc:<global>,TYPE_DECL,"static ExitCode ProcessGlobalArgsInternal(std::vector<std::string>* args,
                                          std::vector<std::string>* exec_args,
                                          std::vector<std::string>* errors,
                                          OptionEnvvarSettings settings) {
  // Parse a few arguments which are specific to Node.
  std::vector<std::string> v8_args;

  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  options_parser::Parse(
      args,
      exec_args,
      &v8_args,
      per_process::cli_options.get(),
      settings,
      errors);

  if (!errors->empty()) return ExitCode::kInvalidCommandLineArgument;

  std::string revert_error;
  for (const std::string& cve : per_process::cli_options->security_reverts) {
    Revert(cve.c_str(), &revert_error);
    if (!revert_error.empty()) {
      errors->emplace_back(std::move(revert_error));
      // TODO(joyeecheung): merge into kInvalidCommandLineArgument.
      return ExitCode::kInvalidC...",1,1,node.cc,node.ProcessGlobalArgsInternal,,false,692,769,ProcessGlobalArgsInternal,,,14,"ExitCode node.ProcessGlobalArgsInternal (ANY*,ANY*,ANY*,OptionEnvvarSettings)"
129465,METHOD,node.cc:<global>,TYPE_DECL,"int ProcessGlobalArgs(std::vector<std::string>* args,
                      std::vector<std::string>* exec_args,
                      std::vector<std::string>* errors,
                      OptionEnvvarSettings settings) {
  return static_cast<int>(
      ProcessGlobalArgsInternal(args, exec_args, errors, settings));
}",1,1,node.cc,node.ProcessGlobalArgs,,false,771,777,ProcessGlobalArgs,,,15,"int node.ProcessGlobalArgs (ANY*,ANY*,ANY*,OptionEnvvarSettings)"
129486,METHOD,node.cc:<global>,TYPE_DECL,"static ExitCode InitializeNodeWithArgsInternal(
    std::vector<std::string>* argv,
    std::vector<std::string>* exec_argv,
    std::vector<std::string>* errors,
    ProcessInitializationFlags::Flags flags) {
  // Make sure InitializeNodeWithArgs() is called only once.
  CHECK(!init_called.exchange(true));

  // Initialize node_start_time to get relative uptime.
  per_process::node_start_time = uv_hrtime();

  // Register built-in bindings
  binding::RegisterBuiltinBindings();

  // Make inherited handles noninheritable.
  if (!(flags & ProcessInitializationFlags::kEnableStdioInheritance) &&
      !(flags & ProcessInitializationFlags::kNoStdioInitialization)) {
    uv_disable_stdio_inheritance();
  }

  // Cache the original command line to be
  // used in diagnostic reports.
  per_process::cli_options->cmdline = *argv;

  // Node provides a ""v8.setFlagsFromString"" method to dynamically change flags.
  // Hence do not freeze flags when initializing V8. In a browser setting, this
  ...",1,1,node.cc,node.InitializeNodeWithArgsInternal,,false,783,900,InitializeNodeWithArgsInternal,,,18,"ExitCode node.InitializeNodeWithArgsInternal (ANY*,ANY*,ANY*,ANY)"
129672,METHOD,node.cc:<global>,TYPE_DECL,"int InitializeNodeWithArgs(std::vector<std::string>* argv,
                           std::vector<std::string>* exec_argv,
                           std::vector<std::string>* errors,
                           ProcessInitializationFlags::Flags flags) {
  return static_cast<int>(
      InitializeNodeWithArgsInternal(argv, exec_argv, errors, flags));
}",1,1,node.cc,node.InitializeNodeWithArgs,,false,902,908,InitializeNodeWithArgs,,,19,"int node.InitializeNodeWithArgs (ANY*,ANY*,ANY*,ANY)"
129688,METHOD,node.cc:<global>,TYPE_DECL,"static std::unique_ptr<InitializationResultImpl>
InitializeOncePerProcessInternal(const std::vector<std::string>& args,
                                 ProcessInitializationFlags::Flags flags =
                                     ProcessInitializationFlags::kNoFlags) {
  auto result = std::make_unique<InitializationResultImpl>();
  result->args_ = args;

  if (!(flags & ProcessInitializationFlags::kNoParseGlobalDebugVariables)) {
    // Initialized the enabled list for Debug() calls with system
    // environment variables.
    per_process::enabled_debug_list.Parse();
  }

  PlatformInit(flags);

  // This needs to run *before* V8::Initialize().
  {
    result->exit_code_ = InitializeNodeWithArgsInternal(
        &result->args_, &result->exec_args_, &result->errors_, flags);
    if (result->exit_code_enum() != ExitCode::kNoFailure) {
      result->early_return_ = true;
      return result;
    }
  }

  if (!(flags & ProcessInitializationFlags::kNoUseLargePages) &&
      (per_proce...",1,21,node.cc,node.InitializeOncePerProcessInternal,,false,910,1092,InitializeOncePerProcessInternal,,,20,"unique_ptr<InitializationResultImpl> node.InitializeOncePerProcessInternal (ANY,ANY)"
129973,METHOD,node.cc:<global>,TYPE_DECL,"std::unique_ptr<InitializationResult> InitializeOncePerProcess(
    const std::vector<std::string>& args,
    ProcessInitializationFlags::Flags flags) {
  return InitializeOncePerProcessInternal(args, flags);
}",1,1,node.cc,node.InitializeOncePerProcess,,false,1094,1098,InitializeOncePerProcess,,,21,"unique_ptr<InitializationResult> node.InitializeOncePerProcess (ANY,ANY)"
129983,METHOD,node.cc:<global>,TYPE_DECL,"void TearDownOncePerProcess() {
  const uint32_t flags = init_process_flags.load();
  ResetStdio();
  if (!(flags & ProcessInitializationFlags::kNoDefaultSignalHandling)) {
    ResetSignalHandlers();
  }

  per_process::v8_initialized = false;
  if (!(flags & ProcessInitializationFlags::kNoInitializeV8)) {
    V8::Dispose();
  }

#if NODE_USE_V8_WASM_TRAP_HANDLER && defined(_WIN32)
  if (!(flags & ProcessInitializationFlags::kNoDefaultSignalHandling)) {
    RemoveVectoredExceptionHandler(per_process::old_vectored_exception_handler);
  }
#endif

  if (!(flags & ProcessInitializationFlags::kNoInitializeNodeV8Platform)) {
    V8::DisposePlatform();
    // uv_run cannot be called from the time before the beforeExit callback
    // runs until the program exits unless the event loop has any referenced
    // handles after beforeExit terminates. This prevents unrefed timers
    // that happen to terminate during shutdown from being run unsafely.
    // Since uv_run cannot be called, uv_asy...",1,4,node.cc,node.TearDownOncePerProcess,,false,1100,1128,TearDownOncePerProcess,,,22,void node.TearDownOncePerProcess ()
130039,METHOD,node.cc:<global>,TYPE_DECL,InitializationResult::~InitializationResult() {},1,48,node.cc,node.InitializationResult.~InitializationResult,,false,1130,1130,~InitializationResult,,,23,ANY node.InitializationResult.~InitializationResult ()
130043,METHOD,node.cc:<global>,TYPE_DECL,InitializationResultImpl::~InitializationResultImpl() {},1,56,node.cc,node.InitializationResultImpl.~InitializationResultImpl,,false,1131,1131,~InitializationResultImpl,,,24,ANY node.InitializationResultImpl.~InitializationResultImpl ()
130047,METHOD,node.cc:<global>,TYPE_DECL,"ExitCode GenerateAndWriteSnapshotData(const SnapshotData** snapshot_data_ptr,
                                      const InitializationResultImpl* result) {
  ExitCode exit_code = result->exit_code_enum();
  // nullptr indicates there's no snapshot data.
  DCHECK_NULL(*snapshot_data_ptr);

  // node:embedded_snapshot_main indicates that we are using the
  // embedded snapshot and we are not supposed to clean it up.
  const std::string& main_script = result->args()[1];
  if (main_script == ""node:embedded_snapshot_main"") {
    *snapshot_data_ptr = SnapshotBuilder::GetEmbeddedSnapshotData();
    if (*snapshot_data_ptr == nullptr) {
      // The Node.js binary is built without embedded snapshot
      fprintf(stderr,
              ""node:embedded_snapshot_main was specified as snapshot ""
              ""entry point but Node.js was built without embedded ""
              ""snapshot.\n"");
      exit_code = ExitCode::kInvalidCommandLineArgument;
      return exit_code;
    }
  } else {
    // ...",1,1,node.cc,node.GenerateAndWriteSnapshotData,,false,1133,1199,GenerateAndWriteSnapshotData,,,25,"ExitCode node.GenerateAndWriteSnapshotData (SnapshotData**,InitializationResultImpl*)"
130242,METHOD,node.cc:<global>,TYPE_DECL,"ExitCode LoadSnapshotDataAndRun(const SnapshotData** snapshot_data_ptr,
                                const InitializationResultImpl* result) {
  ExitCode exit_code = result->exit_code_enum();
  // nullptr indicates there's no snapshot data.
  DCHECK_NULL(*snapshot_data_ptr);
  // --snapshot-blob indicates that we are reading a customized snapshot.
  if (!per_process::cli_options->snapshot_blob.empty()) {
    std::string filename = per_process::cli_options->snapshot_blob;
    FILE* fp = fopen(filename.c_str(), ""rb"");
    if (fp == nullptr) {
      fprintf(stderr, ""Cannot open %s"", filename.c_str());
      exit_code = ExitCode::kStartupSnapshotFailure;
      return exit_code;
    }
    std::unique_ptr<SnapshotData> read_data = std::make_unique<SnapshotData>();
    bool ok = SnapshotData::FromFile(read_data.get(), fp);
    fclose(fp);
    if (!ok) {
      // If we fail to read the customized snapshot,
      // simply exit with kStartupSnapshotFailure.
      exit_code = ExitCode::kSt...",1,1,node.cc,node.LoadSnapshotDataAndRun,,false,1201,1244,LoadSnapshotDataAndRun,,,26,"ExitCode node.LoadSnapshotDataAndRun (SnapshotData**,InitializationResultImpl*)"
130401,METHOD,node.cc:<global>,TYPE_DECL,"static ExitCode StartInternal(int argc, char** argv) {
  CHECK_GT(argc, 0);

  // Hack around with the argv pointer. Used for process.title = ""blah"".
  argv = uv_setup_args(argc, argv);

  std::unique_ptr<InitializationResultImpl> result =
      InitializeOncePerProcessInternal(
          std::vector<std::string>(argv, argv + argc));
  for (const std::string& error : result->errors()) {
    FPrintF(stderr, ""%s: %s\n"", result->args().at(0), error);
  }
  if (result->early_return()) {
    return result->exit_code_enum();
  }

  DCHECK_EQ(result->exit_code_enum(), ExitCode::kNoFailure);
  const SnapshotData* snapshot_data = nullptr;

  auto cleanup_process = OnScopeLeave([&]() {
    TearDownOncePerProcess();

    if (snapshot_data != nullptr &&
        snapshot_data->data_ownership == SnapshotData::DataOwnership::kOwned) {
      delete snapshot_data;
    }
  });

  uv_loop_configure(uv_default_loop(), UV_METRICS_IDLE_TIME);

  std::string sea_config = per_process::cli_options->experime...",1,1,node.cc,node.StartInternal,,false,1246,1294,StartInternal,,,27,"ExitCode node.StartInternal (int,char**)"
130546,METHOD,node.cc:<global>,TYPE_DECL,"int Start(int argc, char** argv) {
#ifndef DISABLE_SINGLE_EXECUTABLE_APPLICATION
  std::tie(argc, argv) = sea::FixupArgsForSEA(argc, argv);
#endif
  return static_cast<int>(StartInternal(argc, argv));
}",1,1,node.cc,node.Start,,false,1296,1301,Start,,,28,"int node.Start (int,char**)"
130571,METHOD,node.cc:<global>,TYPE_DECL,"int Stop(Environment* env, StopFlags::Flags flags) {
  env->ExitEnv(flags);
  return 0;
}",1,1,node.cc,node.Stop,,false,1303,1306,Stop,,,29,"int node.Stop (Environment*,ANY)"
130584,METHOD,node.cc:<global>,TYPE_DECL,void Initialize() {},1,20,node.cc,Initialize,,false,1311,1311,Initialize,,,2,void Initialize ()
130590,METHOD,node.hpp:<global>,TYPE_DECL,"[&](const CommonEnvironmentSetup* setup) -> Environment* {
        return CreateEnvironment(
            setup->isolate_data(), setup->context(),
            std::forward<EnvironmentArgs>(env_args)...);
      }",7,7,node.hpp,"new CommonEnvironmentSetup( platform, errors, [&](const CommonEnvironmentSetup* setup) -> Environment* { return CreateEnvironment( setup->isolate_data(), setup->context(), std.forward<EnvironmentArgs>(env_args)...); }).<lambda>0",,false,913,917,<lambda>0,,,1,"Environment new CommonEnvironmentSetup( platform, errors, [&](const CommonEnvironmentSetup* setup) -> Environment* { return CreateEnvironment( setup->isolate_data(), setup->context(), std.forward<EnvironmentArgs>(env_args)...); }).<lambda>0 (CommonEnvironmentSetup*)"
130615,METHOD,node.hpp:<global>,TYPE_DECL,"[&](const CommonEnvironmentSetup* setup) -> Environment* {
        return CreateEnvironment(setup->isolate_data(),
                                 setup->context(),
                                 std::forward<EnvironmentArgs>(env_args)...);
      }",7,7,node.hpp,"new CommonEnvironmentSetup( platform, errors, snapshot_data, Flags.kNoFlags, [&](const CommonEnvironmentSetup* setup) -> Environment* { return CreateEnvironment(setup->isolate_data(), setup->context(), std.forward<EnvironmentArgs>(env_args)...); }).<lambda>1",,false,936,940,<lambda>1,,,1,"Environment new CommonEnvironmentSetup( platform, errors, snapshot_data, Flags.kNoFlags, [&](const CommonEnvironmentSetup* setup) -> Environment* { return CreateEnvironment(setup->isolate_data(), setup->context(), std.forward<EnvironmentArgs>(env_args)...); }).<lambda>1 (CommonEnvironmentSetup*)"
130662,METHOD,node.hpp:<global>,TYPE_DECL,<global>,1,59,node.hpp,node.hpp:<global>,,false,1,1491,<global>,,,1,
130669,METHOD,node.hpp:<global>,TYPE_DECL,"v8::Local<v8::Value> v8::Local<v8::Value> (v8::Isolate *, int, const char *, const char *, const char *);",34,75,node.hpp,node.ErrnoException,,false,139,143,ErrnoException,,,3,"ANY node.ErrnoException (ANY*,int,char*,char*,char*)"
130678,METHOD,node.hpp:<global>,TYPE_DECL,"v8::Local<v8::Value> v8::Local<v8::Value> (v8::Isolate *, int, const char *, const char *, const char *, const char *);",34,72,node.hpp,node.UVException,,false,144,149,UVException,,,4,"ANY node.UVException (ANY*,int,char*,char*,char*,char*)"
130688,METHOD,node.hpp:<global>,TYPE_DECL,"NODE_DEPRECATED(""Use ErrnoException(isolate, ...)"",
                inline v8::Local<v8::Value> ErrnoException(
      int errorno,
      const char* syscall = nullptr,
      const char* message = nullptr,
      const char* path = nullptr) {
  return ErrnoException(v8::Isolate::GetCurrent(),
                        errorno,
                        syscall,
                        message,
                        path);
})",1,2,node.hpp,node.ErrnoException,,false,151,162,ErrnoException,,,5,"Local<v8::Value> node.ErrnoException (int,char*,char*,char*)"
130708,METHOD,node.hpp:<global>,TYPE_DECL,"NODE_DEPRECATED(""Use UVException(isolate, ...)"",
                inline v8::Local<v8::Value> UVException(int errorno,
                                        const char* syscall = nullptr,
                                        const char* message = nullptr,
                                        const char* path = nullptr) {
  return UVException(v8::Isolate::GetCurrent(),
                     errorno,
                     syscall,
                     message,
                     path);
})",1,2,node.hpp,node.UVException,,false,164,174,UVException,,,6,"Local<v8::Value> node.UVException (int,char*,char*,char*)"
130728,METHOD,node.hpp:<global>,TYPE_DECL,"v8::Local<NODE_DEPRECATED(""Use MakeCallback(..., async_context)"",
                NODE_EXTERN v8::Local<v8::Value> MakeCallback(
                    v8::Isolate* isolate,
                    v8::Local<v8::Object> recv,
                    const char* method,
                    int argc,
                    v8::Local<v8::Value>* argv))> v8::Local<NODE_DEPRECATED(""Use MakeCallback(..., async_context)"",
                NODE_EXTERN v8::Local<v8::Value> MakeCallback(
                    v8::Isolate* isolate,
                    v8::Local<v8::Object> recv,
                    const char* method,
                    int argc,
                    v8::Local<v8::Value>* argv))> (v8::Isolate *, v8::Local<NODE_DEPRECATED(""Use MakeCallback(..., async_context)"",
                NODE_EXTERN v8::Local<v8::Value> MakeCallback(
                    v8::Isolate* isolate,
                    v8::Local<v8::Object> recv,
                    const char* method,
                    int argc,
              ...",1,48,node.hpp,node.MakeCallback,,false,183,189,MakeCallback,,,7,"ANY node.MakeCallback (ANY*,ANY,char*,int,ANY*)"
130737,METHOD,node.hpp:<global>,TYPE_DECL,"v8::Local<NODE_DEPRECATED(""Use MakeCallback(..., async_context)"",
                NODE_EXTERN v8::Local<v8::Value> MakeCallback(
                    v8::Isolate* isolate,
                    v8::Local<v8::Object> recv,
                    v8::Local<v8::String> symbol,
                    int argc,
                    v8::Local<v8::Value>* argv))> v8::Local<NODE_DEPRECATED(""Use MakeCallback(..., async_context)"",
                NODE_EXTERN v8::Local<v8::Value> MakeCallback(
                    v8::Isolate* isolate,
                    v8::Local<v8::Object> recv,
                    v8::Local<v8::String> symbol,
                    int argc,
                    v8::Local<v8::Value>* argv))> (v8::Isolate *, v8::Local<NODE_DEPRECATED(""Use MakeCallback(..., async_context)"",
                NODE_EXTERN v8::Local<v8::Value> MakeCallback(
                    v8::Isolate* isolate,
                    v8::Local<v8::Object> recv,
                    v8::Local<v8::String> symbol,
              ...",1,48,node.hpp,node.MakeCallback,,false,190,196,MakeCallback,,,8,"ANY node.MakeCallback (ANY*,ANY,ANY,int,ANY*)"
130768,METHOD,<empty>,<empty>,<empty>,1,,node.hpp,node.ProcessInitializationFlags.Flags:<clinit>,,false,234,,<clinit>,,,16,
130864,METHOD,<empty>,<empty>,<empty>,1,,node.hpp,node.StopFlags.Flags:<clinit>,,false,278,,<clinit>,,,3,
130877,METHOD,node.InitializationResult,TYPE_DECL,virtual ~InitializationResult();,11,33,node.hpp,node.InitializationResult.~InitializationResult,,false,288,288,~InitializationResult,,,1,virtual node.InitializationResult.~InitializationResult ()
130881,METHOD,node.InitializationResult,TYPE_DECL,virtual int exit_code() const = 0;,15,35,node.hpp,node.InitializationResult.exit_code,,false,291,291,exit_code,,,2,int node.InitializationResult.exit_code ()
130885,METHOD,node.InitializationResult,TYPE_DECL,virtual bool early_return() const = 0;,16,39,node.hpp,node.InitializationResult.early_return,,false,294,294,early_return,,,3,bool node.InitializationResult.early_return ()
130889,METHOD,node.InitializationResult,TYPE_DECL,virtual const std::vector<std::string>& args() const = 0;,41,58,node.hpp,node.InitializationResult.args,,false,297,297,args,,,4,ANY node.InitializationResult.args ()
130893,METHOD,node.InitializationResult,TYPE_DECL,virtual const std::vector<std::string>& exec_args() const = 0;,41,63,node.hpp,node.InitializationResult.exec_args,,false,300,300,exec_args,,,5,ANY node.InitializationResult.exec_args ()
130897,METHOD,node.InitializationResult,TYPE_DECL,virtual const std::vector<std::string>& errors() const = 0;,41,60,node.hpp,node.InitializationResult.errors,,false,304,304,errors,,,6,ANY node.InitializationResult.errors ()
130901,METHOD,node.InitializationResult,TYPE_DECL,virtual MultiIsolatePlatform* platform() const = 0;,31,52,node.hpp,node.InitializationResult.platform,,false,308,308,platform,,,7,MultiIsolatePlatform* node.InitializationResult.platform ()
130905,METHOD,node.InitializationResult,TYPE_DECL,InitializationResult() = default;,3,35,node.hpp,node.InitializationResult.InitializationResult,,false,311,311,InitializationResult,,,8,ANY node.InitializationResult.InitializationResult ()
130910,METHOD,node.hpp:<global>,TYPE_DECL,"int int (int, char * []);",17,45,node.hpp,node.Start,,false,317,317,Start,,,9,"int node.Start (int,char[]*)"
130916,METHOD,node.hpp:<global>,TYPE_DECL,"int int (Environment *, StopFlags::Flags);",17,66,node.hpp,node.Stop,,false,321,322,Stop,,,10,"int node.Stop (Environment*,ANY)"
130922,METHOD,node.hpp:<global>,TYPE_DECL,"int int (std::vector<NODE_DEPRECATED(""Use InitializeOncePerProcess() instead"",
                NODE_EXTERN int InitializeNodeWithArgs(
                    std::vector<std::string>* argv,
                    std::vector<std::string>* exec_argv,
                    std::vector<std::string>* errors,
                    ProcessInitializationFlags::Flags flags =
                        ProcessInitializationFlags::kNoFlags))> *, std::vector<NODE_DEPRECATED(""Use InitializeOncePerProcess() instead"",
                NODE_EXTERN int InitializeNodeWithArgs(
                    std::vector<std::string>* argv,
                    std::vector<std::string>* exec_argv,
                    std::vector<std::string>* errors,
                    ProcessInitializationFlags::Flags flags =
                        ProcessInitializationFlags::kNoFlags))> *, std::vector<NODE_DEPRECATED(""Use InitializeOncePerProcess() instead"",
                NODE_EXTERN int InitializeNodeWithArgs(
                    std::v...",1,62,node.hpp,node.InitializeNodeWithArgs,,false,332,338,InitializeNodeWithArgs,,,11,"int node.InitializeNodeWithArgs (ANY*,ANY*,ANY*,ANY)"
130930,METHOD,node.hpp:<global>,TYPE_DECL,"std::unique_ptr<InitializationResult> std::unique_ptr<InitializationResult> (const std::vector<std::string> &, ProcessInitializationFlags::Flags);",51,45,node.hpp,node.InitializeOncePerProcess,,false,345,348,InitializeOncePerProcess,,,12,"ANY node.InitializeOncePerProcess (ANY,ANY)"
130936,METHOD,node.hpp:<global>,TYPE_DECL,void void ();,18,41,node.hpp,node.TearDownOncePerProcess,,false,351,351,TearDownOncePerProcess,,,13,void node.TearDownOncePerProcess ()
130940,METHOD,node.hpp:<global>,TYPE_DECL,"inline std::unique_ptr<InitializationResult> InitializeOncePerProcess(
    const std::vector<std::string>& args,
    std::initializer_list<ProcessInitializationFlags::Flags> list) {
  uint64_t flags_accum = ProcessInitializationFlags::kNoFlags;
  for (const auto flag : list) flags_accum |= static_cast<uint64_t>(flag);
  return InitializeOncePerProcess(
      args, static_cast<ProcessInitializationFlags::Flags>(flags_accum));
}",1,1,node.hpp,node.InitializeOncePerProcess,,false,354,361,InitializeOncePerProcess,,,14,"unique_ptr<InitializationResult> node.InitializeOncePerProcess (ANY,ANY)"
130971,METHOD,<empty>,<empty>,<empty>,1,,node.hpp,node.OptionEnvvarSettings:<clinit>,,false,363,,<clinit>,,,5,
130987,METHOD,node.hpp:<global>,TYPE_DECL,"int int (std::vector<std::string> *, std::vector<std::string> *, std::vector<std::string> *, OptionEnvvarSettings);",17,52,node.hpp,node.ProcessGlobalArgs,,false,383,386,ProcessGlobalArgs,,,16,"int node.ProcessGlobalArgs (ANY*,ANY*,ANY*,OptionEnvvarSettings)"
130997,METHOD,node.ArrayBufferAllocator,TYPE_DECL,"static std::unique_ptr<ArrayBufferAllocator> Create(
      bool always_debug = false);",48,32,node.hpp,node.ArrayBufferAllocator.Create,,false,402,403,Create,,,1,ANY node.ArrayBufferAllocator.Create (bool)
131002,METHOD,node.ArrayBufferAllocator,TYPE_DECL,virtual NodeArrayBufferAllocator* GetImpl() = 0;,35,49,node.hpp,node.ArrayBufferAllocator.GetImpl,,false,406,406,GetImpl,,,2,NodeArrayBufferAllocator* node.ArrayBufferAllocator.GetImpl ()
131007,METHOD,node.hpp:<global>,TYPE_DECL,ArrayBufferAllocator ArrayBufferAllocator *();,33,62,node.hpp,node.CreateArrayBufferAllocator,,false,412,412,CreateArrayBufferAllocator,,,19,ArrayBufferAllocator* node.CreateArrayBufferAllocator ()
131011,METHOD,node.hpp:<global>,TYPE_DECL,void void (ArrayBufferAllocator *);,18,74,node.hpp,node.FreeArrayBufferAllocator,,false,413,413,FreeArrayBufferAllocator,,,20,void node.FreeArrayBufferAllocator (ArrayBufferAllocator*)
131017,METHOD,node.IsolatePlatformDelegate,TYPE_DECL,virtual std::shared_ptr<v8::TaskRunner> GetForegroundTaskRunner() = 0;,43,71,node.hpp,node.IsolatePlatformDelegate.GetForegroundTaskRunner,,false,417,417,GetForegroundTaskRunner,,,1,ANY node.IsolatePlatformDelegate.GetForegroundTaskRunner ()
131021,METHOD,node.IsolatePlatformDelegate,TYPE_DECL,virtual bool IdleTasksEnabled() = 0;,16,37,node.hpp,node.IsolatePlatformDelegate.IdleTasksEnabled,,false,418,418,IdleTasksEnabled,,,2,bool node.IsolatePlatformDelegate.IdleTasksEnabled ()
131026,METHOD,node.MultiIsolatePlatform,TYPE_DECL,~MultiIsolatePlatform() override = default;,3,45,node.hpp,node.MultiIsolatePlatform.~MultiIsolatePlatform,,false,423,423,~MultiIsolatePlatform,,,1,ANY node.MultiIsolatePlatform.~MultiIsolatePlatform ()
131030,METHOD,node.MultiIsolatePlatform,TYPE_DECL,virtual bool FlushForegroundTasks(v8::Isolate* isolate) = 0;,16,61,node.hpp,node.MultiIsolatePlatform.FlushForegroundTasks,,false,427,427,FlushForegroundTasks,,,2,bool node.MultiIsolatePlatform.FlushForegroundTasks (ANY*)
131035,METHOD,node.MultiIsolatePlatform,TYPE_DECL,virtual void DrainTasks(v8::Isolate* isolate) = 0;,16,51,node.hpp,node.MultiIsolatePlatform.DrainTasks,,false,428,428,DrainTasks,,,3,void node.MultiIsolatePlatform.DrainTasks (ANY*)
131040,METHOD,node.MultiIsolatePlatform,TYPE_DECL,"virtual void RegisterIsolate(v8::Isolate* isolate,
                               struct uv_loop_s* loop) = 0;",16,58,node.hpp,node.MultiIsolatePlatform.RegisterIsolate,,false,435,436,RegisterIsolate,,,4,"void node.MultiIsolatePlatform.RegisterIsolate (ANY*,uv_loop_s*)"
131046,METHOD,node.MultiIsolatePlatform,TYPE_DECL,"virtual void RegisterIsolate(v8::Isolate* isolate,
                               IsolatePlatformDelegate* delegate) = 0;",16,69,node.hpp,node.MultiIsolatePlatform.RegisterIsolate,,false,441,442,RegisterIsolate,,,5,"void node.MultiIsolatePlatform.RegisterIsolate (ANY*,IsolatePlatformDelegate*)"
131052,METHOD,node.MultiIsolatePlatform,TYPE_DECL,virtual void UnregisterIsolate(v8::Isolate* isolate) = 0;,16,58,node.hpp,node.MultiIsolatePlatform.UnregisterIsolate,,false,447,447,UnregisterIsolate,,,6,void node.MultiIsolatePlatform.UnregisterIsolate (ANY*)
131057,METHOD,node.MultiIsolatePlatform,TYPE_DECL,"virtual void AddIsolateFinishedCallback(v8::Isolate* isolate,
                                          void (*callback)(void*),
                                          void* data) = 0;",16,57,node.hpp,node.MultiIsolatePlatform.AddIsolateFinishedCallback,,false,452,454,AddIsolateFinishedCallback,,,7,"void node.MultiIsolatePlatform.AddIsolateFinishedCallback (ANY*,void,void*)"
131064,METHOD,node.MultiIsolatePlatform,TYPE_DECL,"static std::unique_ptr<MultiIsolatePlatform> Create(
      int thread_pool_size,
      v8::TracingController* tracing_controller = nullptr,
      v8::PageAllocator* page_allocator = nullptr);",48,50,node.hpp,node.MultiIsolatePlatform.Create,,false,456,459,Create,,,8,"ANY node.MultiIsolatePlatform.Create (int,ANY*,ANY*)"
131077,METHOD,<empty>,<empty>,<empty>,1,,node.hpp,node.IsolateSettingsFlags:<clinit>,,false,462,,<clinit>,,,6,
131113,METHOD,<empty>,<empty>,<empty>,1,,node.hpp,node.IsolateSettings:<clinit>,,false,470,,<clinit>,,,9,
131149,METHOD,node.EmbedderSnapshotData.DeleteSnapshotData,TYPE_DECL,void operator()(const EmbedderSnapshotData*) const;,10,54,node.hpp,node.EmbedderSnapshotData.DeleteSnapshotData.operator (),,false,517,517,operator (),,,1,void node.EmbedderSnapshotData.DeleteSnapshotData.operator () (EmbedderSnapshotData*)
131155,METHOD,node.EmbedderSnapshotData,TYPE_DECL,static Pointer BuiltinSnapshotData();,18,38,node.hpp,node.EmbedderSnapshotData.BuiltinSnapshotData,,false,525,525,BuiltinSnapshotData,,,3,Pointer node.EmbedderSnapshotData.BuiltinSnapshotData ()
131159,METHOD,node.EmbedderSnapshotData,TYPE_DECL,static Pointer FromFile(FILE* in);,18,35,node.hpp,node.EmbedderSnapshotData.FromFile,,false,531,531,FromFile,,,4,Pointer node.EmbedderSnapshotData.FromFile (FILE*)
131164,METHOD,node.EmbedderSnapshotData,TYPE_DECL,static Pointer FromBlob(const std::vector<char>& in);,18,54,node.hpp,node.EmbedderSnapshotData.FromBlob,,false,532,532,FromBlob,,,5,Pointer node.EmbedderSnapshotData.FromBlob (ANY)
131169,METHOD,node.EmbedderSnapshotData,TYPE_DECL,void ToFile(FILE* out) const;,8,30,node.hpp,node.EmbedderSnapshotData.ToFile,,false,537,537,ToFile,,,6,void node.EmbedderSnapshotData.ToFile (FILE*)
131174,METHOD,node.EmbedderSnapshotData,TYPE_DECL,std::vector<char> ToBlob() const;,21,34,node.hpp,node.EmbedderSnapshotData.ToBlob,,false,538,538,ToBlob,,,7,ANY node.EmbedderSnapshotData.ToBlob ()
131178,METHOD,node.EmbedderSnapshotData,TYPE_DECL,static bool CanUseCustomSnapshotPerIsolate();,15,46,node.hpp,node.EmbedderSnapshotData.CanUseCustomSnapshotPerIsolate,,false,542,542,CanUseCustomSnapshotPerIsolate,,,8,bool node.EmbedderSnapshotData.CanUseCustomSnapshotPerIsolate ()
131182,METHOD,node.EmbedderSnapshotData,TYPE_DECL,EmbedderSnapshotData(const EmbedderSnapshotData&) = delete;,3,61,node.hpp,node.EmbedderSnapshotData.EmbedderSnapshotData,,false,544,544,EmbedderSnapshotData,,,9,ANY node.EmbedderSnapshotData.EmbedderSnapshotData (EmbedderSnapshotData)
131187,METHOD,node.EmbedderSnapshotData,TYPE_DECL,EmbedderSnapshotData& operator=(const EmbedderSnapshotData&) = delete;,3,72,node.hpp,node.EmbedderSnapshotData.operator =,,false,545,545,operator =,,,10,EmbedderSnapshotData node.EmbedderSnapshotData.operator = (EmbedderSnapshotData)
131192,METHOD,node.EmbedderSnapshotData,TYPE_DECL,EmbedderSnapshotData(EmbedderSnapshotData&&) = delete;,3,56,node.hpp,node.EmbedderSnapshotData.EmbedderSnapshotData,,false,546,546,EmbedderSnapshotData,,,11,ANY node.EmbedderSnapshotData.EmbedderSnapshotData (EmbedderSnapshotData)
131197,METHOD,node.EmbedderSnapshotData,TYPE_DECL,EmbedderSnapshotData& operator=(EmbedderSnapshotData&&) = delete;,3,67,node.hpp,node.EmbedderSnapshotData.operator =,,false,547,547,operator =,,,12,EmbedderSnapshotData node.EmbedderSnapshotData.operator = (EmbedderSnapshotData)
131202,METHOD,node.EmbedderSnapshotData,TYPE_DECL,"EmbedderSnapshotData(const SnapshotData* impl, bool owns_impl);",3,64,node.hpp,node.EmbedderSnapshotData.EmbedderSnapshotData,,false,550,550,EmbedderSnapshotData,,,13,"ANY node.EmbedderSnapshotData.EmbedderSnapshotData (SnapshotData*,bool)"
131212,METHOD,node.hpp:<global>,TYPE_DECL,"void void (v8::Isolate *, const IsolateSettings &);",18,69,node.hpp,node.SetIsolateUpForNode,,false,561,562,SetIsolateUpForNode,,,26,"void node.SetIsolateUpForNode (ANY*,IsolateSettings)"
131218,METHOD,node.hpp:<global>,TYPE_DECL,void void (v8::Isolate *);,18,58,node.hpp,node.SetIsolateUpForNode,,false,566,566,SetIsolateUpForNode,,,27,void node.SetIsolateUpForNode (ANY*)
131223,METHOD,node.hpp:<global>,TYPE_DECL,"v8::Isolate v8::Isolate *(ArrayBufferAllocator *, uv_loop_s *, MultiIsolatePlatform *, const EmbedderSnapshotData *, const IsolateSettings &);",24,41,node.hpp,node.NewIsolate,,false,572,577,NewIsolate,,,28,"ANY* node.NewIsolate (ArrayBufferAllocator*,uv_loop_s*,MultiIsolatePlatform*,EmbedderSnapshotData*,IsolateSettings)"
131232,METHOD,node.hpp:<global>,TYPE_DECL,"v8::Isolate v8::Isolate *(std::shared_ptr<ArrayBufferAllocator>, uv_loop_s *, MultiIsolatePlatform *, const EmbedderSnapshotData *, const IsolateSettings &);",24,41,node.hpp,node.NewIsolate,,false,578,583,NewIsolate,,,29,"ANY* node.NewIsolate (ANY,uv_loop_s*,MultiIsolatePlatform*,EmbedderSnapshotData*,IsolateSettings)"
131241,METHOD,node.hpp:<global>,TYPE_DECL,"v8::Local<v8::Context> v8::Local<v8::Context> (v8::Isolate *, v8::Local<v8::ObjectTemplate>);",36,40,node.hpp,node.NewContext,,false,586,589,NewContext,,,30,"ANY node.NewContext (ANY*,ANY)"
131247,METHOD,node.hpp:<global>,TYPE_DECL,v8::Maybe<bool> v8::Maybe<bool> (v8::Local<v8::Context>);,29,77,node.hpp,node.InitializeContext,,false,593,593,InitializeContext,,,31,ANY node.InitializeContext (ANY)
131252,METHOD,node.hpp:<global>,TYPE_DECL,"IsolateData IsolateData *(v8::Isolate *, uv_loop_s *, MultiIsolatePlatform *, ArrayBufferAllocator *, const EmbedderSnapshotData *);",24,56,node.hpp,node.CreateIsolateData,,false,598,603,CreateIsolateData,,,32,"IsolateData* node.CreateIsolateData (ANY*,uv_loop_s*,MultiIsolatePlatform*,ArrayBufferAllocator*,EmbedderSnapshotData*)"
131261,METHOD,node.hpp:<global>,TYPE_DECL,void void (IsolateData *);,18,59,node.hpp,node.FreeIsolateData,,false,604,604,FreeIsolateData,,,33,void node.FreeIsolateData (IsolateData*)
131268,METHOD,<empty>,<empty>,<empty>,1,,node.hpp,node.ThreadId:<clinit>,,false,606,,<clinit>,,,2,
131278,METHOD,node.hpp:<global>,TYPE_DECL,ThreadId ThreadId ();,22,50,node.hpp,node.AllocateEnvironmentThreadId,,false,609,609,AllocateEnvironmentThreadId,,,35,ThreadId node.AllocateEnvironmentThreadId ()
131295,METHOD,<empty>,<empty>,<empty>,1,,node.hpp,node.EnvironmentFlags.Flags:<clinit>,,false,612,,<clinit>,,,12,
131353,METHOD,node.InspectorParentHandle,TYPE_DECL,virtual ~InspectorParentHandle();,11,34,node.hpp,node.InspectorParentHandle.~InspectorParentHandle,,false,657,657,~InspectorParentHandle,,,1,virtual node.InspectorParentHandle.~InspectorParentHandle ()
131357,METHOD,node.hpp:<global>,TYPE_DECL,"Environment Environment *(IsolateData *, v8::Local<v8::Context>, const std::vector<std::string> &, const std::vector<std::string> &, EnvironmentFlags::Flags, ThreadId, std::unique_ptr<InspectorParentHandle>);",24,72,node.hpp,node.CreateEnvironment,,false,665,672,CreateEnvironment,,,38,"Environment* node.CreateEnvironment (IsolateData*,ANY,ANY,ANY,ANY,ThreadId,ANY)"
131368,METHOD,node.hpp:<global>,TYPE_DECL,"std::unique_ptr<InspectorParentHandle> std::unique_ptr<InspectorParentHandle> (Environment *, ThreadId, const char *);",52,26,node.hpp,node.GetInspectorParentHandle,,false,681,684,GetInspectorParentHandle,,,39,"ANY node.GetInspectorParentHandle (Environment*,ThreadId,char*)"
131375,METHOD,node.hpp:<global>,TYPE_DECL,"std::unique_ptr<InspectorParentHandle> std::unique_ptr<InspectorParentHandle> (Environment *, ThreadId, const char *, const char *);",52,21,node.hpp,node.GetInspectorParentHandle,,false,686,690,GetInspectorParentHandle,,,40,"ANY node.GetInspectorParentHandle (Environment*,ThreadId,char*,char*)"
131388,METHOD,node.hpp:<global>,TYPE_DECL,"v8::MaybeLocal<v8::Value> v8::MaybeLocal<v8::Value> (Environment *, StartExecutionCallback);",39,30,node.hpp,node.LoadEnvironment,,false,701,703,LoadEnvironment,,,43,"ANY node.LoadEnvironment (Environment*,StartExecutionCallback)"
131394,METHOD,node.hpp:<global>,TYPE_DECL,"v8::MaybeLocal<v8::Value> v8::MaybeLocal<v8::Value> (Environment *, std::string_view);",39,63,node.hpp,node.LoadEnvironment,,false,704,705,LoadEnvironment,,,44,"ANY node.LoadEnvironment (Environment*,ANY)"
131400,METHOD,node.hpp:<global>,TYPE_DECL,void void (Environment *);,18,50,node.hpp,node.FreeEnvironment,,false,706,706,FreeEnvironment,,,45,void node.FreeEnvironment (Environment*)
131405,METHOD,node.hpp:<global>,TYPE_DECL,"void void (Environment *, std::function<void(Environment*, int)> &);",18,53,node.hpp,node.SetProcessExitHandler,,false,715,717,SetProcessExitHandler,,,46,"void node.SetProcessExitHandler (Environment*,ANY)"
131411,METHOD,node.hpp:<global>,TYPE_DECL,"void void (Environment *, int);",18,75,node.hpp,node.DefaultProcessExitHandler,,false,718,718,DefaultProcessExitHandler,,,47,"void node.DefaultProcessExitHandler (Environment*,int)"
131417,METHOD,node.hpp:<global>,TYPE_DECL,Environment Environment *(v8::Local<v8::Context>);,24,78,node.hpp,node.GetCurrentEnvironment,,false,721,721,GetCurrentEnvironment,,,48,Environment* node.GetCurrentEnvironment (ANY)
131422,METHOD,node.hpp:<global>,TYPE_DECL,IsolateData IsolateData *(Environment *);,24,68,node.hpp,node.GetEnvironmentIsolateData,,false,722,722,GetEnvironmentIsolateData,,,49,IsolateData* node.GetEnvironmentIsolateData (Environment*)
131427,METHOD,node.hpp:<global>,TYPE_DECL,ArrayBufferAllocator ArrayBufferAllocator *(IsolateData *);,33,76,node.hpp,node.GetArrayBufferAllocator,,false,723,723,GetArrayBufferAllocator,,,50,ArrayBufferAllocator* node.GetArrayBufferAllocator (IsolateData*)
131432,METHOD,node.hpp:<global>,TYPE_DECL,v8::Local<v8::Context> v8::Local<v8::Context> (Environment *);,36,67,node.hpp,node.GetMainContext,,false,726,726,GetMainContext,,,51,ANY node.GetMainContext (Environment*)
131437,METHOD,node.hpp:<global>,TYPE_DECL,"[[noreturn]] NODE_EXTERN void OnFatalError(const char* location,
                                           const char* message);",31,63,node.hpp,node.OnFatalError,,false,728,729,OnFatalError,,,52,"void node.OnFatalError (char*,char*)"
131443,METHOD,node.hpp:<global>,TYPE_DECL,void void (v8::PromiseRejectMessage);,18,72,node.hpp,node.PromiseRejectCallback,,false,730,730,PromiseRejectCallback,,,53,void node.PromiseRejectCallback (ANY)
131448,METHOD,node.hpp:<global>,TYPE_DECL,"bool bool (v8::Local<v8::Context>, v8::Local<v8::String>);",18,66,node.hpp,node.AllowWasmCodeGenerationCallback,,false,731,732,AllowWasmCodeGenerationCallback,,,54,"bool node.AllowWasmCodeGenerationCallback (ANY,ANY)"
131454,METHOD,node.hpp:<global>,TYPE_DECL,bool bool (v8::Isolate *);,18,69,node.hpp,node.ShouldAbortOnUncaughtException,,false,733,733,ShouldAbortOnUncaughtException,,,55,bool node.ShouldAbortOnUncaughtException (ANY*)
131459,METHOD,node.hpp:<global>,TYPE_DECL,"v8::MaybeLocal<v8::Value> v8::MaybeLocal<v8::Value> (v8::Local<v8::Context>, v8::Local<v8::Value>, v8::Local<v8::Array>);",39,31,node.hpp,node.PrepareStackTraceCallback,,false,734,737,PrepareStackTraceCallback,,,56,"ANY node.PrepareStackTraceCallback (ANY,ANY,ANY)"
131466,METHOD,node.hpp:<global>,TYPE_DECL,"std::string std::string (v8::Isolate *, const char *, const char *, const std::string &, v8::Local<v8::Value>);",25,69,node.hpp,node.TriggerNodeReport,,false,745,749,TriggerNodeReport,,,57,"ANY node.TriggerNodeReport (ANY*,char*,char*,ANY,ANY)"
131475,METHOD,node.hpp:<global>,TYPE_DECL,"std::string std::string (Environment *, const char *, const char *, const std::string &, v8::Local<v8::Value>);",25,69,node.hpp,node.TriggerNodeReport,,false,750,754,TriggerNodeReport,,,58,"ANY node.TriggerNodeReport (Environment*,char*,char*,ANY,ANY)"
131484,METHOD,node.hpp:<global>,TYPE_DECL,"void void (v8::Isolate *, const char *, const char *, v8::Local<v8::Value>, std::ostream &);",18,49,node.hpp,node.GetNodeReport,,false,755,759,GetNodeReport,,,59,"void node.GetNodeReport (ANY*,char*,char*,ANY,ANY)"
131493,METHOD,node.hpp:<global>,TYPE_DECL,"void void (Environment *, const char *, const char *, v8::Local<v8::Value>, std::ostream &);",18,49,node.hpp,node.GetNodeReport,,false,760,764,GetNodeReport,,,60,"void node.GetNodeReport (Environment*,char*,char*,ANY,ANY)"
131502,METHOD,node.hpp:<global>,TYPE_DECL,MultiIsolatePlatform MultiIsolatePlatform *(Environment *);,33,75,node.hpp,node.GetMultiIsolatePlatform,,false,768,768,GetMultiIsolatePlatform,,,61,MultiIsolatePlatform* node.GetMultiIsolatePlatform (Environment*)
131507,METHOD,node.hpp:<global>,TYPE_DECL,MultiIsolatePlatform MultiIsolatePlatform *(IsolateData *);,33,75,node.hpp,node.GetMultiIsolatePlatform,,false,769,769,GetMultiIsolatePlatform,,,62,MultiIsolatePlatform* node.GetMultiIsolatePlatform (IsolateData*)
131512,METHOD,node.hpp:<global>,TYPE_DECL,"MultiIsolatePlatform MultiIsolatePlatform *(int, v8::TracingController *);",1,51,node.hpp,node.CreatePlatform,,false,771,774,CreatePlatform,,,63,"MultiIsolatePlatform* node.CreatePlatform (int,ANY*)"
131518,METHOD,node.hpp:<global>,TYPE_DECL,void void (MultiIsolatePlatform *);,1,66,node.hpp,node.FreePlatform,,false,775,776,FreePlatform,,,64,void node.FreePlatform (MultiIsolatePlatform*)
131523,METHOD,node.hpp:<global>,TYPE_DECL,v8::TracingController v8::TracingController *();,34,57,node.hpp,node.GetTracingController,,false,784,784,GetTracingController,,,65,ANY* node.GetTracingController ()
131527,METHOD,node.hpp:<global>,TYPE_DECL,void void (v8::TracingController *);,18,72,node.hpp,node.SetTracingController,,false,785,785,SetTracingController,,,66,void node.SetTracingController (ANY*)
131532,METHOD,node.hpp:<global>,TYPE_DECL,v8::Maybe<bool> v8::Maybe<bool> (Environment *);,29,67,node.hpp,node.EmitProcessBeforeExit,,false,789,789,EmitProcessBeforeExit,,,67,ANY node.EmitProcessBeforeExit (Environment*)
131537,METHOD,node.hpp:<global>,TYPE_DECL,void void (Environment *);,1,54,node.hpp,node.EmitBeforeExit,,false,790,791,EmitBeforeExit,,,68,void node.EmitBeforeExit (Environment*)
131542,METHOD,node.hpp:<global>,TYPE_DECL,v8::Maybe<int> v8::Maybe<int> (Environment *);,28,60,node.hpp,node.EmitProcessExit,,false,794,794,EmitProcessExit,,,69,ANY node.EmitProcessExit (Environment*)
131547,METHOD,node.hpp:<global>,TYPE_DECL,int int (Environment *);,1,47,node.hpp,node.EmitExit,,false,795,796,EmitExit,,,70,int node.EmitExit (Environment*)
131552,METHOD,node.hpp:<global>,TYPE_DECL,void void (Environment *);,18,44,node.hpp,node.RunAtExit,,false,800,800,RunAtExit,,,71,void node.RunAtExit (Environment*)
131559,METHOD,node.hpp:<global>,TYPE_DECL,v8::Maybe<int> v8::Maybe<int> (Environment *);,28,58,node.hpp,node.SpinEventLoop,,false,817,817,SpinEventLoop,,,74,ANY node.SpinEventLoop (Environment*)
131564,METHOD,node.hpp:<global>,TYPE_DECL,std::string std::string ();,25,46,node.hpp,node.GetAnonymousMainPath,,false,819,819,GetAnonymousMainPath,,,75,ANY node.GetAnonymousMainPath ()
131569,METHOD,node.CommonEnvironmentSetup,TYPE_DECL,~CommonEnvironmentSetup();,3,27,node.hpp,node.CommonEnvironmentSetup.~CommonEnvironmentSetup,,false,823,823,~CommonEnvironmentSetup,,,1,ANY node.CommonEnvironmentSetup.~CommonEnvironmentSetup ()
131573,METHOD,node.CommonEnvironmentSetup,TYPE_DECL,"static std::unique_ptr<CommonEnvironmentSetup> Create(
      MultiIsolatePlatform* platform,
      std::vector<std::string>* errors,
      EnvironmentArgs&&... env_args);",50,36,node.hpp,node.CommonEnvironmentSetup.Create,,false,832,835,Create,,,2,"ANY node.CommonEnvironmentSetup.Create<EnvironmentArgs> (MultiIsolatePlatform*,ANY*,EnvironmentArgs)"
131580,METHOD,node.CommonEnvironmentSetup,TYPE_DECL,"static std::unique_ptr<CommonEnvironmentSetup> CreateFromSnapshot(
      MultiIsolatePlatform* platform,
      std::vector<std::string>* errors,
      const EmbedderSnapshotData* snapshot_data,
      EnvironmentArgs&&... env_args);",50,36,node.hpp,node.CommonEnvironmentSetup.CreateFromSnapshot,,false,837,841,CreateFromSnapshot,,,3,"ANY node.CommonEnvironmentSetup.CreateFromSnapshot<EnvironmentArgs> (MultiIsolatePlatform*,ANY*,EmbedderSnapshotData*,EnvironmentArgs)"
131588,METHOD,node.CommonEnvironmentSetup,TYPE_DECL,"static std::unique_ptr<CommonEnvironmentSetup> CreateForSnapshotting(
      MultiIsolatePlatform* platform,
      std::vector<std::string>* errors,
      const std::vector<std::string>& args = {},
      const std::vector<std::string>& exec_args = {});",50,53,node.hpp,node.CommonEnvironmentSetup.CreateForSnapshotting,,false,863,867,CreateForSnapshotting,,,4,"ANY node.CommonEnvironmentSetup.CreateForSnapshotting (MultiIsolatePlatform*,ANY*,ANY,ANY)"
131596,METHOD,node.CommonEnvironmentSetup,TYPE_DECL,EmbedderSnapshotData::Pointer CreateSnapshot();,33,48,node.hpp,node.CommonEnvironmentSetup.CreateSnapshot,,false,868,868,CreateSnapshot,,,5,ANY node.CommonEnvironmentSetup.CreateSnapshot ()
131602,METHOD,node.CommonEnvironmentSetup,TYPE_DECL,v8::SnapshotCreator* snapshot_creator();,22,41,node.hpp,node.CommonEnvironmentSetup.snapshot_creator,,false,871,871,snapshot_creator,,,8,ANY* node.CommonEnvironmentSetup.snapshot_creator ()
131606,METHOD,node.CommonEnvironmentSetup,TYPE_DECL,std::shared_ptr<ArrayBufferAllocator> array_buffer_allocator() const;,41,70,node.hpp,node.CommonEnvironmentSetup.array_buffer_allocator,,false,873,873,array_buffer_allocator,,,9,ANY node.CommonEnvironmentSetup.array_buffer_allocator ()
131610,METHOD,node.CommonEnvironmentSetup,TYPE_DECL,v8::Isolate* isolate() const;,14,30,node.hpp,node.CommonEnvironmentSetup.isolate,,false,874,874,isolate,,,10,ANY* node.CommonEnvironmentSetup.isolate ()
131614,METHOD,node.CommonEnvironmentSetup,TYPE_DECL,IsolateData* isolate_data() const;,14,35,node.hpp,node.CommonEnvironmentSetup.isolate_data,,false,875,875,isolate_data,,,11,IsolateData* node.CommonEnvironmentSetup.isolate_data ()
131618,METHOD,node.CommonEnvironmentSetup,TYPE_DECL,Environment* env() const;,14,26,node.hpp,node.CommonEnvironmentSetup.env,,false,876,876,env,,,12,Environment* node.CommonEnvironmentSetup.env ()
131622,METHOD,node.CommonEnvironmentSetup,TYPE_DECL,v8::Local<v8::Context> context() const;,26,40,node.hpp,node.CommonEnvironmentSetup.context,,false,877,877,context,,,13,ANY node.CommonEnvironmentSetup.context ()
131626,METHOD,node.CommonEnvironmentSetup,TYPE_DECL,CommonEnvironmentSetup(const CommonEnvironmentSetup&) = delete;,3,65,node.hpp,node.CommonEnvironmentSetup.CommonEnvironmentSetup,,false,879,879,CommonEnvironmentSetup,,,14,ANY node.CommonEnvironmentSetup.CommonEnvironmentSetup (CommonEnvironmentSetup)
131631,METHOD,node.CommonEnvironmentSetup,TYPE_DECL,CommonEnvironmentSetup& operator=(const CommonEnvironmentSetup&) = delete;,3,76,node.hpp,node.CommonEnvironmentSetup.operator =,,false,880,880,operator =,,,15,CommonEnvironmentSetup node.CommonEnvironmentSetup.operator = (CommonEnvironmentSetup)
131636,METHOD,node.CommonEnvironmentSetup,TYPE_DECL,CommonEnvironmentSetup(CommonEnvironmentSetup&&) = delete;,3,60,node.hpp,node.CommonEnvironmentSetup.CommonEnvironmentSetup,,false,881,881,CommonEnvironmentSetup,,,16,ANY node.CommonEnvironmentSetup.CommonEnvironmentSetup (CommonEnvironmentSetup)
131641,METHOD,node.CommonEnvironmentSetup,TYPE_DECL,CommonEnvironmentSetup& operator=(CommonEnvironmentSetup&&) = delete;,3,71,node.hpp,node.CommonEnvironmentSetup.operator =,,false,882,882,operator =,,,17,CommonEnvironmentSetup node.CommonEnvironmentSetup.operator = (CommonEnvironmentSetup)
131649,METHOD,<empty>,<empty>,<empty>,3,,node.hpp,node.CommonEnvironmentSetup.Flags:<clinit>,,false,885,,<clinit>,,,3,
131661,METHOD,node.CommonEnvironmentSetup,TYPE_DECL,"CommonEnvironmentSetup(
      MultiIsolatePlatform*,
      std::vector<std::string>*,
      std::function<Environment*(const CommonEnvironmentSetup*)>);",3,65,node.hpp,node.CommonEnvironmentSetup.CommonEnvironmentSetup,,false,893,896,CommonEnvironmentSetup,,,21,"ANY node.CommonEnvironmentSetup.CommonEnvironmentSetup (MultiIsolatePlatform*,ANY*,ANY)"
131668,METHOD,node.CommonEnvironmentSetup,TYPE_DECL,"CommonEnvironmentSetup(
      MultiIsolatePlatform*,
      std::vector<std::string>*,
      const EmbedderSnapshotData*,
      uint32_t flags,
      std::function<Environment*(const CommonEnvironmentSetup*)>);",3,65,node.hpp,node.CommonEnvironmentSetup.CommonEnvironmentSetup,,false,897,902,CommonEnvironmentSetup,,,22,"ANY node.CommonEnvironmentSetup.CommonEnvironmentSetup (MultiIsolatePlatform*,ANY*,EmbedderSnapshotData*,uint32_t,ANY)"
131677,METHOD,node.hpp:<global>,TYPE_DECL,"std::unique_ptr<CommonEnvironmentSetup> CommonEnvironmentSetup::Create(
    MultiIsolatePlatform* platform,
    std::vector<std::string>* errors,
    EnvironmentArgs&&... env_args) {
  auto ret = std::unique_ptr<CommonEnvironmentSetup>(new CommonEnvironmentSetup(
      platform, errors,
      [&](const CommonEnvironmentSetup* setup) -> Environment* {
        return CreateEnvironment(
            setup->isolate_data(), setup->context(),
            std::forward<EnvironmentArgs>(env_args)...);
      }));
  if (!errors->empty()) ret.reset();
  return ret;
}",1,1,node.hpp,node.CommonEnvironmentSetup.Create,,false,907,920,Create,,,77,"unique_ptr<CommonEnvironmentSetup> node.CommonEnvironmentSetup.Create<EnvironmentArgs> (MultiIsolatePlatform*,ANY*,EnvironmentArgs)"
131710,METHOD,node.hpp:<global>,TYPE_DECL,"std::unique_ptr<CommonEnvironmentSetup>
CommonEnvironmentSetup::CreateFromSnapshot(
    MultiIsolatePlatform* platform,
    std::vector<std::string>* errors,
    const EmbedderSnapshotData* snapshot_data,
    EnvironmentArgs&&... env_args) {
  auto ret = std::unique_ptr<CommonEnvironmentSetup>(new CommonEnvironmentSetup(
      platform,
      errors,
      snapshot_data,
      Flags::kNoFlags,
      [&](const CommonEnvironmentSetup* setup) -> Environment* {
        return CreateEnvironment(setup->isolate_data(),
                                 setup->context(),
                                 std::forward<EnvironmentArgs>(env_args)...);
      }));
  if (!errors->empty()) ret.reset();
  return ret;
}",1,1,node.hpp,node.CommonEnvironmentSetup.CreateFromSnapshot,,false,925,943,CreateFromSnapshot,,,78,"unique_ptr<CommonEnvironmentSetup> node.CommonEnvironmentSetup.CreateFromSnapshot<EnvironmentArgs> (MultiIsolatePlatform*,ANY*,EmbedderSnapshotData*,EnvironmentArgs)"
131748,METHOD,node.hpp:<global>,TYPE_DECL,"NODE_DEPRECATED(""Use v8::Date::New() directly"",
                inline v8::Local<v8::Value> NODE_UNIXTIME_V8(double time) {
                  return v8::Date::New(
                             v8::Isolate::GetCurrent()->GetCurrentContext(),
                             1000 * time)
                      .ToLocalChecked();
                })",1,18,node.hpp,node.NODE_UNIXTIME_V8,,false,946,952,NODE_UNIXTIME_V8,,,79,Local<v8::Value> node.NODE_UNIXTIME_V8 (double)
131775,METHOD,node.hpp:<global>,TYPE_DECL,"NODE_DEPRECATED(""Use v8::Date::ValueOf() directly"",
                inline double NODE_V8_UNIXTIME(v8::Local<v8::Date> date) {
  return date->ValueOf() / 1000;
})",1,2,node.hpp,node.NODE_V8_UNIXTIME,,false,954,957,NODE_V8_UNIXTIME,,,80,double node.NODE_V8_UNIXTIME (ANY)
131787,METHOD,node.hpp:<global>,TYPE_DECL,"inline void NODE_SET_METHOD(v8::Local<v8::Template> recv,
                            const char* name,
                            v8::FunctionCallback callback) {
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate,
                                                                callback);
  v8::Local<v8::String> fn_name = v8::String::NewFromUtf8(isolate, name,
      v8::NewStringType::kInternalized).ToLocalChecked();
  t->SetClassName(fn_name);
  recv->Set(fn_name, t);
}",1,1,node.hpp,node.NODE_SET_METHOD,,false,1000,1011,NODE_SET_METHOD,,,81,"void node.NODE_SET_METHOD (ANY,char*,ANY)"
131861,METHOD,node.hpp:<global>,TYPE_DECL,"inline void NODE_SET_METHOD(v8::Local<v8::Object> recv,
                            const char* name,
                            v8::FunctionCallback callback) {
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> context = isolate->GetCurrentContext();
  v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate,
                                                                callback);
  v8::Local<v8::Function> fn = t->GetFunction(context).ToLocalChecked();
  v8::Local<v8::String> fn_name = v8::String::NewFromUtf8(isolate, name,
      v8::NewStringType::kInternalized).ToLocalChecked();
  fn->SetName(fn_name);
  recv->Set(context, fn_name, fn).Check();
}",1,1,node.hpp,node.NODE_SET_METHOD,,false,1014,1027,NODE_SET_METHOD,,,82,"void node.NODE_SET_METHOD (ANY,char*,ANY)"
131971,METHOD,node.hpp:<global>,TYPE_DECL,"inline void NODE_SET_PROTOTYPE_METHOD(v8::Local<v8::FunctionTemplate> recv,
                                      const char* name,
                                      v8::FunctionCallback callback) {
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Signature> s = v8::Signature::New(isolate, recv);
  v8::Local<v8::FunctionTemplate> t =
      v8::FunctionTemplate::New(isolate, callback, v8::Local<v8::Value>(), s);
  v8::Local<v8::String> fn_name = v8::String::NewFromUtf8(isolate, name,
      v8::NewStringType::kInternalized).ToLocalChecked();
  t->SetClassName(fn_name);
  recv->PrototypeTemplate()->Set(fn_name, t);
}",1,1,node.hpp,node.NODE_SET_PROTOTYPE_METHOD,,false,1032,1044,NODE_SET_PROTOTYPE_METHOD,,,83,"void node.NODE_SET_PROTOTYPE_METHOD (ANY,char*,ANY)"
132081,METHOD,<empty>,<empty>,<empty>,1,,node.hpp,node.encoding:<clinit>,,false,1049,,<clinit>,,,10,
132090,METHOD,node.hpp:<global>,TYPE_DECL,"void void (v8::Isolate *, const v8::TryCatch &);",18,62,node.hpp,node.FatalException,,false,1066,1067,FatalException,,,87,"void node.FatalException (ANY*,ANY)"
132096,METHOD,node.hpp:<global>,TYPE_DECL,"v8::Local<v8::Value> v8::Local<v8::Value> (v8::Isolate *, const char *, size_t, encoding);",34,72,node.hpp,node.Encode,,false,1069,1072,Encode,,,88,"ANY node.Encode (ANY*,char*,size_t,encoding)"
132104,METHOD,node.hpp:<global>,TYPE_DECL,"v8::Local<v8::Value> v8::Local<v8::Value> (v8::Isolate *, const uint16_t *, size_t);",34,51,node.hpp,node.Encode,,false,1076,1078,Encode,,,89,"ANY node.Encode (ANY*,uint16_t*,size_t)"
132111,METHOD,node.hpp:<global>,TYPE_DECL,"ssize_t ssize_t (v8::Isolate *, v8::Local<v8::Value>, encoding);",21,64,node.hpp,node.DecodeBytes,,false,1081,1083,DecodeBytes,,,90,"ssize_t node.DecodeBytes (ANY*,ANY,encoding)"
132118,METHOD,node.hpp:<global>,TYPE_DECL,"ssize_t ssize_t (v8::Isolate *, char *, size_t, v8::Local<v8::Value>, encoding);",21,64,node.hpp,node.DecodeWrite,,false,1085,1089,DecodeWrite,,,91,"ssize_t node.DecodeWrite (ANY*,char*,size_t,ANY,encoding)"
132127,METHOD,node.hpp:<global>,TYPE_DECL,const char* signo_string(int errorno);,11,37,node.hpp,node.signo_string,,false,1099,1099,signo_string,,,92,char* node.signo_string (int)
132132,METHOD,node.hpp:<global>,TYPE_DECL,"typedef void (*addon_register_func)(
    v8::Local<v8::Object> exports,
    v8::Local<v8::Value> module,
    void* priv);",14,15,node.hpp,node.addon_register_func,,false,1102,1105,addon_register_func,,,93,"void node.addon_register_func (ANY,ANY,void*)"
132139,METHOD,node.hpp:<global>,TYPE_DECL,"typedef void (*addon_context_register_func)(
    v8::Local<v8::Object> exports,
    v8::Local<v8::Value> module,
    v8::Local<v8::Context> context,
    void* priv);",14,15,node.hpp,node.addon_context_register_func,,false,1107,1111,addon_context_register_func,,,94,"void node.addon_context_register_func (ANY,ANY,ANY,void*)"
132149,METHOD,<empty>,<empty>,<empty>,1,,node.hpp,node.ModuleFlags:<clinit>,,false,1113,,<clinit>,,,2,
132167,METHOD,node.hpp:<global>,TYPE_DECL,void void (void *);,29,59,node.hpp,node.node_module_register,,false,1129,1129,node_module_register,,,97,void node.node_module_register (void*)
132172,METHOD,node.hpp:<global>,TYPE_DECL,"void void (Environment *, const node_module &);",18,75,node.hpp,node.AddLinkedBinding,,false,1246,1246,AddLinkedBinding,,,98,"void node.AddLinkedBinding (Environment*,node_module)"
132178,METHOD,node.hpp:<global>,TYPE_DECL,"void void (Environment *, const napi_module &);",18,64,node.hpp,node.AddLinkedBinding,,false,1247,1248,AddLinkedBinding,,,99,"void node.AddLinkedBinding (Environment*,napi_module)"
132184,METHOD,node.hpp:<global>,TYPE_DECL,"void void (Environment *, const char *, addon_context_register_func, void *);",18,45,node.hpp,node.AddLinkedBinding,,false,1249,1252,AddLinkedBinding,,,100,"void node.AddLinkedBinding (Environment*,char*,addon_context_register_func,void*)"
132192,METHOD,node.hpp:<global>,TYPE_DECL,"void void (Environment *, const char *, napi_addon_register_func, int32_t);",18,33,node.hpp,node.AddLinkedBinding,,false,1253,1257,AddLinkedBinding,,,101,"void node.AddLinkedBinding (Environment*,char*,napi_addon_register_func,int32_t)"
132200,METHOD,node.hpp:<global>,TYPE_DECL,"void void (Environment *, void  (*)(void *), void *);",18,34,node.hpp,node.AtExit,,false,1263,1265,AtExit,,,102,"void node.AtExit (Environment*,void,void*)"
132211,METHOD,node.hpp:<global>,TYPE_DECL,"void void (v8::Isolate *, void  (*)(void *), void *);",18,53,node.hpp,node.AddEnvironmentCleanupHook,,false,1278,1280,AddEnvironmentCleanupHook,,,105,"void node.AddEnvironmentCleanupHook (ANY*,void,void*)"
132218,METHOD,node.hpp:<global>,TYPE_DECL,"void void (v8::Isolate *, void  (*)(void *), void *);",18,56,node.hpp,node.RemoveEnvironmentCleanupHook,,false,1282,1284,RemoveEnvironmentCleanupHook,,,106,"void node.RemoveEnvironmentCleanupHook (ANY*,void,void*)"
132227,METHOD,node.DeleteACHHandle,TYPE_DECL,void operator()(ACHHandle*) const;,43,70,node.hpp,node.DeleteACHHandle.operator (),,false,1290,1290,operator (),,,1,void node.DeleteACHHandle.operator () (ACHHandle*)
132233,METHOD,node.hpp:<global>,TYPE_DECL,"ACHHandle ACHHandle *(v8::Isolate *, void  (*)(void *, void  (*)(void *), void *), void *);",22,14,node.hpp,node.AddEnvironmentCleanupHookInternal,,false,1295,1298,AddEnvironmentCleanupHookInternal,,,110,"ACHHandle* node.AddEnvironmentCleanupHookInternal (ANY*,void,void*)"
132240,METHOD,node.hpp:<global>,TYPE_DECL,"inline AsyncCleanupHookHandle AddEnvironmentCleanupHook(
    v8::Isolate* isolate,
    void (*fun)(void* arg, void (*cb)(void*), void* cbarg),
    void* arg) {
  return AsyncCleanupHookHandle(AddEnvironmentCleanupHookInternal(isolate, fun,
      arg));
}",1,1,node.hpp,node.AddEnvironmentCleanupHook,,false,1299,1305,AddEnvironmentCleanupHook,,,111,"AsyncCleanupHookHandle node.AddEnvironmentCleanupHook (ANY*,void,void*)"
132253,METHOD,node.hpp:<global>,TYPE_DECL,void void (ACHHandle *);,18,72,node.hpp,node.RemoveEnvironmentCleanupHookInternal,,false,1309,1309,RemoveEnvironmentCleanupHookInternal,,,112,void node.RemoveEnvironmentCleanupHookInternal (ACHHandle*)
132258,METHOD,node.hpp:<global>,TYPE_DECL,"inline void RemoveEnvironmentCleanupHook(AsyncCleanupHookHandle holder) {
  RemoveEnvironmentCleanupHookInternal(holder.get());
}",1,1,node.hpp,node.RemoveEnvironmentCleanupHook,,false,1310,1312,RemoveEnvironmentCleanupHook,,,113,void node.RemoveEnvironmentCleanupHook (AsyncCleanupHookHandle)
132268,METHOD,node.hpp:<global>,TYPE_DECL,"void void (Environment *, void  (*)(void *), void *);",18,44,node.hpp,node.RequestInterrupt,,false,1319,1321,RequestInterrupt,,,114,"void node.RequestInterrupt (Environment*,void,void*)"
132275,METHOD,node.hpp:<global>,TYPE_DECL,async_id async_id (v8::Isolate *);,22,72,node.hpp,node.AsyncHooksGetExecutionAsyncId,,false,1326,1326,AsyncHooksGetExecutionAsyncId,,,115,async_id node.AsyncHooksGetExecutionAsyncId (ANY*)
132280,METHOD,node.hpp:<global>,TYPE_DECL,async_id async_id (v8::Isolate *);,22,70,node.hpp,node.AsyncHooksGetTriggerAsyncId,,false,1329,1329,AsyncHooksGetTriggerAsyncId,,,116,async_id node.AsyncHooksGetTriggerAsyncId (ANY*)
132285,METHOD,node.hpp:<global>,TYPE_DECL,"async_context async_context (v8::Isolate *, v8::Local<v8::Object>, const char *, async_id);",27,71,node.hpp,node.EmitAsyncInit,,false,1338,1341,EmitAsyncInit,,,117,"async_context node.EmitAsyncInit (ANY*,ANY,char*,async_id)"
132293,METHOD,node.hpp:<global>,TYPE_DECL,"async_context async_context (v8::Isolate *, v8::Local<v8::Object>, v8::Local<v8::String>, async_id);",27,71,node.hpp,node.EmitAsyncInit,,false,1343,1346,EmitAsyncInit,,,118,"async_context node.EmitAsyncInit (ANY*,ANY,ANY,async_id)"
132301,METHOD,node.hpp:<global>,TYPE_DECL,"void void (v8::Isolate *, async_context);",18,61,node.hpp,node.EmitAsyncDestroy,,false,1354,1355,EmitAsyncDestroy,,,119,"void node.EmitAsyncDestroy (ANY*,async_context)"
132307,METHOD,node.hpp:<global>,TYPE_DECL,"void void (Environment *, async_context);",18,61,node.hpp,node.EmitAsyncDestroy,,false,1356,1357,EmitAsyncDestroy,,,120,"void node.EmitAsyncDestroy (Environment*,async_context)"
132315,METHOD,node.CallbackScope,TYPE_DECL,"CallbackScope(v8::Isolate* isolate,
                v8::Local<v8::Object> resource,
                async_context asyncContext);",3,43,node.hpp,node.CallbackScope.CallbackScope,,false,1378,1380,CallbackScope,,,1,"ANY node.CallbackScope.CallbackScope (ANY*,ANY,async_context)"
132322,METHOD,node.CallbackScope,TYPE_DECL,"CallbackScope(Environment* env,
                v8::Local<v8::Object> resource,
                async_context asyncContext);",3,43,node.hpp,node.CallbackScope.CallbackScope,,false,1381,1383,CallbackScope,,,2,"ANY node.CallbackScope.CallbackScope (Environment*,ANY,async_context)"
132329,METHOD,node.CallbackScope,TYPE_DECL,~CallbackScope();,3,18,node.hpp,node.CallbackScope.~CallbackScope,,false,1384,1384,~CallbackScope,,,3,ANY node.CallbackScope.~CallbackScope ()
132333,METHOD,node.CallbackScope,TYPE_DECL,void operator=(const CallbackScope&) = delete;,3,48,node.hpp,node.CallbackScope.operator =,,false,1386,1386,operator =,,,4,void node.CallbackScope.operator = (CallbackScope)
132338,METHOD,node.CallbackScope,TYPE_DECL,void operator=(CallbackScope&&) = delete;,3,43,node.hpp,node.CallbackScope.operator =,,false,1387,1387,operator =,,,5,void node.CallbackScope.operator = (CallbackScope)
132343,METHOD,node.CallbackScope,TYPE_DECL,CallbackScope(const CallbackScope&) = delete;,3,47,node.hpp,node.CallbackScope.CallbackScope,,false,1388,1388,CallbackScope,,,6,ANY node.CallbackScope.CallbackScope (CallbackScope)
132348,METHOD,node.CallbackScope,TYPE_DECL,CallbackScope(CallbackScope&&) = delete;,3,42,node.hpp,node.CallbackScope.CallbackScope,,false,1389,1389,CallbackScope,,,7,ANY node.CallbackScope.CallbackScope (CallbackScope)
132355,METHOD,node.hpp:<global>,TYPE_DECL,"v8::MaybeLocal<v8::Value> v8::MaybeLocal<v8::Value> (v8::Isolate *, v8::Local<v8::Object>, v8::Local<v8::Function>, int, v8::Local<v8::Value> *, async_context);",27,66,node.hpp,node.MakeCallback,,false,1407,1412,MakeCallback,,,123,"ANY node.MakeCallback (ANY*,ANY,ANY,int,ANY*,async_context)"
132365,METHOD,node.hpp:<global>,TYPE_DECL,"v8::MaybeLocal<v8::Value> v8::MaybeLocal<v8::Value> (v8::Isolate *, v8::Local<v8::Object>, const char *, int, v8::Local<v8::Value> *, async_context);",27,66,node.hpp,node.MakeCallback,,false,1414,1419,MakeCallback,,,124,"ANY node.MakeCallback (ANY*,ANY,char*,int,ANY*,async_context)"
132376,METHOD,node.AsyncResource,TYPE_DECL,"AsyncResource(v8::Isolate* isolate,
                v8::Local<v8::Object> resource,
                const char* name,
                async_id trigger_async_id = -1);",3,47,node.hpp,node.AsyncResource.AsyncResource,,false,1433,1436,AsyncResource,,,1,"ANY node.AsyncResource.AsyncResource (ANY*,ANY,char*,async_id)"
132384,METHOD,node.AsyncResource,TYPE_DECL,virtual ~AsyncResource();,11,26,node.hpp,node.AsyncResource.~AsyncResource,,false,1438,1438,~AsyncResource,,,2,virtual node.AsyncResource.~AsyncResource ()
132388,METHOD,node.AsyncResource,TYPE_DECL,AsyncResource(const AsyncResource&) = delete;,3,47,node.hpp,node.AsyncResource.AsyncResource,,false,1440,1440,AsyncResource,,,3,ANY node.AsyncResource.AsyncResource (AsyncResource)
132393,METHOD,node.AsyncResource,TYPE_DECL,void operator=(const AsyncResource&) = delete;,3,48,node.hpp,node.AsyncResource.operator =,,false,1441,1441,operator =,,,4,void node.AsyncResource.operator = (AsyncResource)
132398,METHOD,node.AsyncResource,TYPE_DECL,"v8::MaybeLocal<v8::Value> MakeCallback(
      v8::Local<v8::Function> callback,
      int argc,
      v8::Local<v8::Value>* argv);",29,33,node.hpp,node.AsyncResource.MakeCallback,,false,1443,1446,MakeCallback,,,5,"ANY node.AsyncResource.MakeCallback (ANY,int,ANY*)"
132405,METHOD,node.AsyncResource,TYPE_DECL,"v8::MaybeLocal<v8::Value> MakeCallback(
      const char* method,
      int argc,
      v8::Local<v8::Value>* argv);",29,33,node.hpp,node.AsyncResource.MakeCallback,,false,1448,1451,MakeCallback,,,6,"ANY node.AsyncResource.MakeCallback (char*,int,ANY*)"
132412,METHOD,node.AsyncResource,TYPE_DECL,v8::Local<v8::Object> get_resource();,25,38,node.hpp,node.AsyncResource.get_resource,,false,1458,1458,get_resource,,,7,ANY node.AsyncResource.get_resource ()
132416,METHOD,node.AsyncResource,TYPE_DECL,async_id get_async_id() const;,12,31,node.hpp,node.AsyncResource.get_async_id,,false,1459,1459,get_async_id,,,8,async_id node.AsyncResource.get_async_id ()
132420,METHOD,node.AsyncResource,TYPE_DECL,async_id get_trigger_async_id() const;,12,39,node.hpp,node.AsyncResource.get_trigger_async_id,,false,1460,1460,get_trigger_async_id,,,9,async_id node.AsyncResource.get_trigger_async_id ()
132425,METHOD,node.AsyncResource.CallbackScope,TYPE_DECL,explicit CallbackScope(AsyncResource* res);,14,46,node.hpp,node.AsyncResource.CallbackScope.CallbackScope,,false,1465,1465,CallbackScope,,,1,explicit node.AsyncResource.CallbackScope.CallbackScope (AsyncResource*)
132433,METHOD,node.hpp:<global>,TYPE_DECL,"void void (int, void  (*)(int, siginfo_t *, void *), bool);",6,54,node.hpp,node.RegisterSignalHandler,,false,1482,1486,RegisterSignalHandler,,,126,"void node.RegisterSignalHandler (int,void,bool)"
132441,METHOD,node_api.cc:<global>,TYPE_DECL,"[&](napi_env env) { cb(env, data, hint); }",7,48,node_api.cc,node_napi_env__.CallFinalizer.<lambda>0,,false,48,48,<lambda>0,,,1,ANY node_napi_env__.CallFinalizer.<lambda>0 (napi_env)
132454,METHOD,node_api.cc:<global>,TYPE_DECL,"[this](node::Environment* node_env) {
      finalization_scheduled = false;
      Unref();
      DrainFinalizerQueue();
    }",30,5,node_api.cc,node_napi_env__.EnqueueFinalizer.<lambda>1,,false,60,64,<lambda>1,,,1,ANY node_napi_env__.EnqueueFinalizer.<lambda>1 (ANY*)
132465,METHOD,node_api.cc:<global>,TYPE_DECL,"[](napi_env env_, v8::Local<v8::Value> local_err) {
    node_napi_env__* env = static_cast<node_napi_env__*>(env_);
    if (env->terminatedOrTerminating()) {
      return;
    }
    node::Environment* node_env = env->node_env();
    if (!node_env->options()->force_node_api_uncaught_exceptions_policy &&
        !enforceUncaughtExceptionPolicy) {
      ProcessEmitDeprecationWarning(
          node_env,
          ""Uncaught N-API callback exception detected, please run node ""
          ""with option --force-node-api-uncaught-exceptions-policy=true""
          ""to handle those exceptions properly."",
          ""DEP0168"");
      return;
    }
    // If there was an unhandled exception in the complete callback,
    // report it as a fatal exception. (There is no JavaScript on the
    // callstack that can possibly handle it.)
    env->trigger_fatal_exception(local_err);
  }",24,3,node_api.cc,node_napi_env__.CallbackIntoModule.<lambda>2,,false,90,110,<lambda>2,,,1,"ANY node_napi_env__.CallbackIntoModule.<lambda>2 (napi_env,ANY)"
132514,METHOD,node_api.cc:<global>,TYPE_DECL,[](void* arg) { static_cast<napi_env>(arg)->Unref(); },7,60,node_api.cc,v8impl.anonymous_namespace_10.NewEnv.<lambda>3,,false,193,193,<lambda>3,,,1,ANY v8impl.anonymous_namespace_10.NewEnv.<lambda>3 (void*)
132526,METHOD,v8impl.anonymous_namespace_11.ThreadSafeFunction,TYPE_DECL,"[](uv_handle_t* handle) -> void {
            ThreadSafeFunction* ts_fn =
                node::ContainerOf(&ThreadSafeFunction::async,
                                  reinterpret_cast<uv_async_t*>(handle));
            delete ts_fn;
          }",11,11,node_api.cc,v8impl.anonymous_namespace_24.ThreadSafeFunction.Init.<lambda>4,,false,318,323,<lambda>4,,,1,void v8impl.anonymous_namespace_24.ThreadSafeFunction.Init.<lambda>4 (uv_handle_t*)
132549,METHOD,v8impl.anonymous_namespace_11.ThreadSafeFunction,TYPE_DECL,"[&](napi_env env) { call_js_cb(env, js_callback, context, data); }",11,76,node_api.cc,v8impl.anonymous_namespace_34.ThreadSafeFunction.DispatchOne.<lambda>5,,false,416,416,<lambda>5,,,1,ANY v8impl.anonymous_namespace_34.ThreadSafeFunction.DispatchOne.<lambda>5 (napi_env)
132562,METHOD,v8impl.anonymous_namespace_11.ThreadSafeFunction,TYPE_DECL,"[](uv_handle_t* handle) -> void {
          ThreadSafeFunction* ts_fn =
              node::ContainerOf(&ThreadSafeFunction::async,
                                reinterpret_cast<uv_async_t*>(handle));
          ts_fn->Finalize();
        }",9,9,node_api.cc,v8impl.anonymous_namespace_38.ThreadSafeFunction.CloseHandlesAndMaybeDelete.<lambda>6,,false,446,451,<lambda>6,,,1,void v8impl.anonymous_namespace_38.ThreadSafeFunction.CloseHandlesAndMaybeDelete.<lambda>6 (uv_handle_t*)
132586,METHOD,node_api.cc:<global>,TYPE_DECL,"[&](napi_env env) {
    _exports = init(env, v8impl::JsValueFromV8LocalValue(exports));
  }",23,3,node_api.cc,napi_module_register_by_symbol.<lambda>7,,false,726,728,<lambda>7,,,1,ANY napi_module_register_by_symbol.<lambda>7 (napi_env)
132604,METHOD,napi_async_cleanup_hook_handle__,TYPE_DECL,[env = env_](node::Environment*) { env->Unref(); },9,58,node_api.cc,napi_async_cleanup_hook_handle__.~napi_async_cleanup_hook_handle__.<lambda>8,,false,801,801,<lambda>8,,,1,ANY napi_async_cleanup_hook_handle__.~napi_async_cleanup_hook_handle__.<lambda>8 (ANY*)
132615,METHOD,anonymous_namespace_75.uvimpl.Work,TYPE_DECL,"[&](napi_env env) {
      _complete(env, ConvertUVErrorCode(status), _data);
    }",36,5,node_api.cc,anonymous_namespace_82.uvimpl.Work.AfterThreadPoolWork.<lambda>9,,false,1195,1197,<lambda>9,,,1,ANY anonymous_namespace_82.uvimpl.Work.AfterThreadPoolWork.<lambda>9 (napi_env)
132665,METHOD,node_api.cc:<global>,TYPE_DECL,<global>,1,32,async_wrap-inl.hpp,node_api.cc:<global>,,false,1,1414,<global>,,,1,
132667,METHOD,node_api.cc:<global>,TYPE_DECL,"node_napi_env__::node_napi_env__(v8::Local<v8::Context> context,
                                 const std::string& module_filename,
                                 int32_t module_api_version)
    : napi_env__(context, module_api_version), filename(module_filename) {
  CHECK_NOT_NULL(node_env());
}",1,1,node_api.cc,node_napi_env__.node_napi_env__,,false,22,27,node_napi_env__,,,1,"ANY node_napi_env__.node_napi_env__ (ANY,ANY,int32_t)"
132676,METHOD,node_api.cc:<global>,TYPE_DECL,"void node_napi_env__::DeleteMe() {
  destructing = true;
  DrainFinalizerQueue();
  napi_env__::DeleteMe();
}",1,1,node_api.cc,node_napi_env__.DeleteMe,,false,29,33,DeleteMe,,,2,void node_napi_env__.DeleteMe ()
132688,METHOD,node_api.cc:<global>,TYPE_DECL,"bool node_napi_env__::can_call_into_js() const {
  return node_env()->can_call_into_js();
}",1,1,node_api.cc,node_napi_env__.can_call_into_js,,false,35,37,can_call_into_js,,,3,bool node_napi_env__.can_call_into_js ()
132697,METHOD,node_api.cc:<global>,TYPE_DECL,"void node_napi_env__::CallFinalizer(napi_finalize cb, void* data, void* hint) {
  CallFinalizer<true>(cb, data, hint);
}",1,1,node_api.cc,node_napi_env__.CallFinalizer,,false,39,41,CallFinalizer,,,4,"void node_napi_env__.CallFinalizer (napi_finalize,void*,void*)"
132708,METHOD,node_api.cc:<global>,TYPE_DECL,"void node_napi_env__::CallFinalizer(napi_finalize cb, void* data, void* hint) {
  v8::HandleScope handle_scope(isolate);
  v8::Context::Scope context_scope(context());
  CallbackIntoModule<enforceUncaughtExceptionPolicy>(
      [&](napi_env env) { cb(env, data, hint); });
}",1,1,node_api.cc,node_napi_env__.CallFinalizer,,false,44,49,CallFinalizer,,,5,"void node_napi_env__.CallFinalizer<bool> (napi_finalize,void*,void*)"
132721,METHOD,node_api.cc:<global>,TYPE_DECL,"void node_napi_env__::EnqueueFinalizer(v8impl::RefTracker* finalizer) {
  napi_env__::EnqueueFinalizer(finalizer);
  // Schedule a second pass only when it has not been scheduled, and not
  // destructing the env.
  // When the env is being destructed, queued finalizers are drained in the
  // loop of `node_napi_env__::DrainFinalizerQueue`.
  if (!finalization_scheduled && !destructing) {
    finalization_scheduled = true;
    Ref();
    node_env()->SetImmediate([this](node::Environment* node_env) {
      finalization_scheduled = false;
      Unref();
      DrainFinalizerQueue();
    });
  }
}",1,1,node_api.cc,node_napi_env__.EnqueueFinalizer,,false,51,66,EnqueueFinalizer,,,6,void node_napi_env__.EnqueueFinalizer (ANY*)
132747,METHOD,node_api.cc:<global>,TYPE_DECL,"void node_napi_env__::DrainFinalizerQueue() {
  // As userland code can delete additional references in one finalizer,
  // the list of pending finalizers may be mutated as we execute them, so
  // we keep iterating it until it is empty.
  while (!pending_finalizers.empty()) {
    v8impl::RefTracker* ref_tracker = *pending_finalizers.begin();
    pending_finalizers.erase(ref_tracker);
    ref_tracker->Finalize();
  }
}",1,1,node_api.cc,node_napi_env__.DrainFinalizerQueue,,false,68,77,DrainFinalizerQueue,,,7,void node_napi_env__.DrainFinalizerQueue ()
132775,METHOD,node_api.cc:<global>,TYPE_DECL,"void node_napi_env__::trigger_fatal_exception(v8::Local<v8::Value> local_err) {
  v8::Local<v8::Message> local_msg =
      v8::Exception::CreateMessage(isolate, local_err);
  node::errors::TriggerUncaughtException(isolate, local_err, local_msg);
}",1,1,node_api.cc,node_napi_env__.trigger_fatal_exception,,false,79,83,trigger_fatal_exception,,,8,void node_napi_env__.trigger_fatal_exception (ANY)
132807,METHOD,node_api.cc:<global>,TYPE_DECL,"void node_napi_env__::CallbackIntoModule(T&& call) {
  CallIntoModule(call, [](napi_env env_, v8::Local<v8::Value> local_err) {
    node_napi_env__* env = static_cast<node_napi_env__*>(env_);
    if (env->terminatedOrTerminating()) {
      return;
    }
    node::Environment* node_env = env->node_env();
    if (!node_env->options()->force_node_api_uncaught_exceptions_policy &&
        !enforceUncaughtExceptionPolicy) {
      ProcessEmitDeprecationWarning(
          node_env,
          ""Uncaught N-API callback exception detected, please run node ""
          ""with option --force-node-api-uncaught-exceptions-policy=true""
          ""to handle those exceptions properly."",
          ""DEP0168"");
      return;
    }
    // If there was an unhandled exception in the complete callback,
    // report it as a fatal exception. (There is no JavaScript on the
    // callstack that can possibly handle it.)
    env->trigger_fatal_exception(local_err);
  });
}",1,1,node_api.cc,node_napi_env__.CallbackIntoModule,,false,89,111,CallbackIntoModule,,,9,"void node_napi_env__.CallbackIntoModule<bool,T> (T)"
132818,METHOD,v8impl.anonymous_namespace_1.BufferFinalizer,TYPE_DECL,"static BufferFinalizer* New(napi_env env,
                              napi_finalize finalize_callback = nullptr,
                              void* finalize_data = nullptr,
                              void* finalize_hint = nullptr) {
    return new BufferFinalizer(
        env, finalize_callback, finalize_data, finalize_hint);
  }",3,3,node_api.cc,v8impl.anonymous_namespace_2.BufferFinalizer.New,,false,119,125,New,,,1,"BufferFinalizer v8impl.anonymous_namespace_2.BufferFinalizer.New (napi_env,napi_finalize,void*,void*)"
132833,METHOD,v8impl.anonymous_namespace_1.BufferFinalizer,TYPE_DECL,"static void FinalizeBufferCallback(char* data, void* hint) {
    std::unique_ptr<BufferFinalizer, Deleter> finalizer{
        static_cast<BufferFinalizer*>(hint)};
    finalizer->finalize_data_ = data;

    // It is safe to call into JavaScript at this point.
    if (finalizer->finalize_callback_ == nullptr) return;
    finalizer->env_->CallFinalizer(finalizer->finalize_callback_,
                                   finalizer->finalize_data_,
                                   finalizer->finalize_hint_);
  }",3,3,node_api.cc,v8impl.anonymous_namespace_3.BufferFinalizer.FinalizeBufferCallback,,false,127,137,FinalizeBufferCallback,,,2,"void v8impl.anonymous_namespace_3.BufferFinalizer.FinalizeBufferCallback (char*,void*)"
132875,METHOD,v8impl.anonymous_namespace_4.BufferFinalizer.Deleter,TYPE_DECL,void operator()(BufferFinalizer* finalizer) { delete finalizer; },5,69,node_api.cc,v8impl.anonymous_namespace_5.BufferFinalizer.Deleter.operator (),,false,140,140,operator (),,,1,void v8impl.anonymous_namespace_5.BufferFinalizer.Deleter.operator () (BufferFinalizer*)
132882,METHOD,v8impl.anonymous_namespace_1.BufferFinalizer,TYPE_DECL,"BufferFinalizer(napi_env env,
                  napi_finalize finalize_callback,
                  void* finalize_data,
                  void* finalize_hint)
      : Finalizer(env, finalize_callback, finalize_data, finalize_hint) {
    env_->Ref();
  }",3,3,node_api.cc,v8impl.anonymous_namespace_6.BufferFinalizer.BufferFinalizer,,false,144,150,BufferFinalizer,,,4,"ANY v8impl.anonymous_namespace_6.BufferFinalizer.BufferFinalizer (napi_env,napi_finalize,void*,void*)"
132894,METHOD,v8impl.anonymous_namespace_1.BufferFinalizer,TYPE_DECL,~BufferFinalizer() { env_->Unref(); },3,39,node_api.cc,v8impl.anonymous_namespace_7.BufferFinalizer.~BufferFinalizer,,false,152,152,~BufferFinalizer,,,5,ANY v8impl.anonymous_namespace_7.BufferFinalizer.~BufferFinalizer ()
132902,METHOD,node_api.cc:<global>,TYPE_DECL,"void ThrowNodeApiVersionError(node::Environment* node_env,
                              const char* module_name,
                              int32_t module_api_version) {
  std::string error_message;
  error_message += module_name;
  error_message += "" requires Node-API version "";
  error_message += std::to_string(module_api_version);
  error_message += "", but this version of Node.js only supports version "";
  error_message += NODE_STRINGIFY(NAPI_VERSION) "" add-ons."";
  node_env->ThrowError(error_message.c_str());
}",1,19,node_api.cc,v8impl.anonymous_namespace_8.ThrowNodeApiVersionError,,false,155,165,ThrowNodeApiVersionError,,,2,"void v8impl.anonymous_namespace_8.ThrowNodeApiVersionError (ANY*,char*,int32_t)"
132939,METHOD,node_api.cc:<global>,TYPE_DECL,"inline napi_env NewEnv(v8::Local<v8::Context> context,
                       const std::string& module_filename,
                       int32_t module_api_version) {
  node_napi_env result;

  // Validate module_api_version.
  if (module_api_version < NODE_API_DEFAULT_MODULE_API_VERSION) {
    module_api_version = NODE_API_DEFAULT_MODULE_API_VERSION;
  } else if (module_api_version > NAPI_VERSION &&
             module_api_version != NAPI_VERSION_EXPERIMENTAL) {
    node::Environment* node_env = node::Environment::GetCurrent(context);
    CHECK_NOT_NULL(node_env);
    ThrowNodeApiVersionError(
        node_env, module_filename.c_str(), module_api_version);
    return nullptr;
  }

  result = new node_napi_env__(context, module_filename, module_api_version);
  // TODO(addaleax): There was previously code that tried to delete the
  // napi_env when its v8::Context was garbage collected;
  // However, as long as N-API addons using this napi_env are in place,
  // the Context needs to ...",1,27,node_api.cc,v8impl.anonymous_namespace_9.NewEnv,,false,167,197,NewEnv,,,3,"napi_env v8impl.anonymous_namespace_9.NewEnv (ANY,ANY,int32_t)"
133015,METHOD,v8impl.anonymous_namespace_11.ThreadSafeFunction,TYPE_DECL,"ThreadSafeFunction(v8::Local<v8::Function> func,
                     v8::Local<v8::Object> resource,
                     v8::Local<v8::String> name,
                     size_t thread_count_,
                     void* context_,
                     size_t max_queue_size_,
                     node_napi_env env_,
                     void* finalize_data_,
                     napi_finalize finalize_cb_,
                     napi_threadsafe_function_call_js call_js_cb_)
      : AsyncResource(env_->isolate,
                      resource,
                      *v8::String::Utf8Value(env_->isolate, name)),
        thread_count(thread_count_),
        is_closing(false),
        dispatch_state(kDispatchIdle),
        context(context_),
        max_queue_size(max_queue_size_),
        env(env_),
        finalize_data(finalize_data_),
        finalize_cb(finalize_cb_),
        call_js_cb(call_js_cb_ == nullptr ? CallJs : call_js_cb_),
        handles_closing(false) {
    ref.Reset(env->i...",3,3,node_api.cc,v8impl.anonymous_namespace_12.ThreadSafeFunction.ThreadSafeFunction,,false,201,227,ThreadSafeFunction,,,1,"ANY v8impl.anonymous_namespace_12.ThreadSafeFunction.ThreadSafeFunction (ANY,ANY,ANY,size_t,void*,size_t,node_napi_env,void*,napi_finalize,napi_threadsafe_function_call_js)"
133050,METHOD,v8impl.anonymous_namespace_11.ThreadSafeFunction,TYPE_DECL,"~ThreadSafeFunction() override {
    node::RemoveEnvironmentCleanupHook(env->isolate, Cleanup, this);
    env->Unref();
  }",3,3,node_api.cc,v8impl.anonymous_namespace_14.ThreadSafeFunction.~ThreadSafeFunction,,false,229,232,~ThreadSafeFunction,,,2,ANY v8impl.anonymous_namespace_14.ThreadSafeFunction.~ThreadSafeFunction ()
133067,METHOD,v8impl.anonymous_namespace_11.ThreadSafeFunction,TYPE_DECL,"napi_status Push(void* data, napi_threadsafe_function_call_mode mode) {
    node::Mutex::ScopedLock lock(this->mutex);

    while (queue.size() >= max_queue_size && max_queue_size > 0 &&
           !is_closing) {
      if (mode == napi_tsfn_nonblocking) {
        return napi_queue_full;
      }
      cond->Wait(lock);
    }

    if (is_closing) {
      if (thread_count == 0) {
        return napi_invalid_arg;
      } else {
        thread_count--;
        return napi_closing;
      }
    } else {
      queue.push(data);
      Send();
      return napi_ok;
    }
  }",3,3,node_api.cc,v8impl.anonymous_namespace_16.ThreadSafeFunction.Push,,false,236,259,Push,,,3,"napi_status v8impl.anonymous_namespace_16.ThreadSafeFunction.Push (void*,napi_threadsafe_function_call_mode)"
133131,METHOD,v8impl.anonymous_namespace_11.ThreadSafeFunction,TYPE_DECL,"napi_status Acquire() {
    node::Mutex::ScopedLock lock(this->mutex);

    if (is_closing) {
      return napi_closing;
    }

    thread_count++;

    return napi_ok;
  }",3,3,node_api.cc,v8impl.anonymous_namespace_18.ThreadSafeFunction.Acquire,,false,261,271,Acquire,,,4,napi_status v8impl.anonymous_namespace_18.ThreadSafeFunction.Acquire ()
133149,METHOD,v8impl.anonymous_namespace_11.ThreadSafeFunction,TYPE_DECL,"napi_status Release(napi_threadsafe_function_release_mode mode) {
    node::Mutex::ScopedLock lock(this->mutex);

    if (thread_count == 0) {
      return napi_invalid_arg;
    }

    thread_count--;

    if (thread_count == 0 || mode == napi_tsfn_abort) {
      if (!is_closing) {
        is_closing = (mode == napi_tsfn_abort);
        if (is_closing && max_queue_size > 0) {
          cond->Signal(lock);
        }
        Send();
      }
    }

    return napi_ok;
  }",3,3,node_api.cc,v8impl.anonymous_namespace_19.ThreadSafeFunction.Release,,false,273,293,Release,,,5,napi_status v8impl.anonymous_namespace_19.ThreadSafeFunction.Release (napi_threadsafe_function_release_mode)
133201,METHOD,v8impl.anonymous_namespace_11.ThreadSafeFunction,TYPE_DECL,"void EmptyQueueAndDelete() {
    for (; !queue.empty(); queue.pop()) {
      call_js_cb(nullptr, nullptr, context, queue.front());
    }
    delete this;
  }",3,3,node_api.cc,v8impl.anonymous_namespace_21.ThreadSafeFunction.EmptyQueueAndDelete,,false,295,300,EmptyQueueAndDelete,,,6,void v8impl.anonymous_namespace_21.ThreadSafeFunction.EmptyQueueAndDelete ()
133227,METHOD,v8impl.anonymous_namespace_11.ThreadSafeFunction,TYPE_DECL,"napi_status Init() {
    ThreadSafeFunction* ts_fn = this;
    uv_loop_t* loop = env->node_env()->event_loop();

    if (uv_async_init(loop, &async, AsyncCb) == 0) {
      if (max_queue_size > 0) {
        cond = std::make_unique<node::ConditionVariable>();
      }
      if (max_queue_size == 0 || cond) {
        return napi_ok;
      }

      env->node_env()->CloseHandle(
          reinterpret_cast<uv_handle_t*>(&async),
          [](uv_handle_t* handle) -> void {
            ThreadSafeFunction* ts_fn =
                node::ContainerOf(&ThreadSafeFunction::async,
                                  reinterpret_cast<uv_async_t*>(handle));
            delete ts_fn;
          });

      // Prevent the thread-safe function from being deleted here, because
      // the callback above will delete it.
      ts_fn = nullptr;
    }

    delete ts_fn;

    return napi_generic_failure;
  }",3,3,node_api.cc,v8impl.anonymous_namespace_22.ThreadSafeFunction.Init,,false,304,333,Init,,,7,napi_status v8impl.anonymous_namespace_22.ThreadSafeFunction.Init ()
133293,METHOD,v8impl.anonymous_namespace_11.ThreadSafeFunction,TYPE_DECL,"napi_status Unref() {
    uv_unref(reinterpret_cast<uv_handle_t*>(&async));

    return napi_ok;
  }",3,3,node_api.cc,v8impl.anonymous_namespace_25.ThreadSafeFunction.Unref,,false,335,339,Unref,,,8,napi_status v8impl.anonymous_namespace_25.ThreadSafeFunction.Unref ()
133304,METHOD,v8impl.anonymous_namespace_11.ThreadSafeFunction,TYPE_DECL,"napi_status Ref() {
    uv_ref(reinterpret_cast<uv_handle_t*>(&async));

    return napi_ok;
  }",3,3,node_api.cc,v8impl.anonymous_namespace_26.ThreadSafeFunction.Ref,,false,341,345,Ref,,,9,napi_status v8impl.anonymous_namespace_26.ThreadSafeFunction.Ref ()
133315,METHOD,v8impl.anonymous_namespace_11.ThreadSafeFunction,TYPE_DECL,inline void* Context() { return context; },3,44,node_api.cc,v8impl.anonymous_namespace_27.ThreadSafeFunction.Context,,false,347,347,Context,,,10,void* v8impl.anonymous_namespace_27.ThreadSafeFunction.Context ()
133321,METHOD,v8impl.anonymous_namespace_11.ThreadSafeFunction,TYPE_DECL,"void Dispatch() {
    bool has_more = true;

    // Limit maximum synchronous iteration count to prevent event loop
    // starvation. See `src/node_messaging.cc` for an inspiration.
    unsigned int iterations_left = kMaxIterationCount;
    while (has_more && --iterations_left != 0) {
      dispatch_state = kDispatchRunning;
      has_more = DispatchOne();

      // Send() was called while we were executing the JS function
      if (dispatch_state.exchange(kDispatchIdle) != kDispatchRunning) {
        has_more = true;
      }
    }

    if (has_more) {
      Send();
    }
  }",3,3,node_api.cc,v8impl.anonymous_namespace_28.ThreadSafeFunction.Dispatch,,false,350,369,Dispatch,,,11,void v8impl.anonymous_namespace_28.ThreadSafeFunction.Dispatch ()
133363,METHOD,v8impl.anonymous_namespace_11.ThreadSafeFunction,TYPE_DECL,"bool DispatchOne() {
    void* data = nullptr;
    bool popped_value = false;
    bool has_more = false;

    {
      node::Mutex::ScopedLock lock(this->mutex);
      if (is_closing) {
        CloseHandlesAndMaybeDelete();
      } else {
        size_t size = queue.size();
        if (size > 0) {
          data = queue.front();
          queue.pop();
          popped_value = true;
          if (size == max_queue_size && max_queue_size > 0) {
            cond->Signal(lock);
          }
          size--;
        }

        if (size == 0) {
          if (thread_count == 0) {
            is_closing = true;
            if (max_queue_size > 0) {
              cond->Signal(lock);
            }
            CloseHandlesAndMaybeDelete();
          }
        } else {
          has_more = true;
        }
      }
    }

    if (popped_value) {
      v8::HandleScope scope(env->isolate);
      CallbackScope cb_scope(this);
      napi_value js_callback = nullptr;
      if (!ref.IsEmpty()) {
       ...",3,3,node_api.cc,v8impl.anonymous_namespace_31.ThreadSafeFunction.DispatchOne,,false,371,420,DispatchOne,,,12,bool v8impl.anonymous_namespace_31.ThreadSafeFunction.DispatchOne ()
133521,METHOD,v8impl.anonymous_namespace_11.ThreadSafeFunction,TYPE_DECL,"void Finalize() {
    v8::HandleScope scope(env->isolate);
    if (finalize_cb) {
      CallbackScope cb_scope(this);
      env->CallFinalizer<false>(finalize_cb, finalize_data, context);
    }
    EmptyQueueAndDelete();
  }",3,3,node_api.cc,v8impl.anonymous_namespace_35.ThreadSafeFunction.Finalize,,false,422,429,Finalize,,,13,void v8impl.anonymous_namespace_35.ThreadSafeFunction.Finalize ()
133544,METHOD,v8impl.anonymous_namespace_11.ThreadSafeFunction,TYPE_DECL,"void CloseHandlesAndMaybeDelete(bool set_closing = false) {
    v8::HandleScope scope(env->isolate);
    if (set_closing) {
      node::Mutex::ScopedLock lock(this->mutex);
      is_closing = true;
      if (max_queue_size > 0) {
        cond->Signal(lock);
      }
    }
    if (handles_closing) {
      return;
    }
    handles_closing = true;
    env->node_env()->CloseHandle(
        reinterpret_cast<uv_handle_t*>(&async),
        [](uv_handle_t* handle) -> void {
          ThreadSafeFunction* ts_fn =
              node::ContainerOf(&ThreadSafeFunction::async,
                                reinterpret_cast<uv_async_t*>(handle));
          ts_fn->Finalize();
        });
  }",3,3,node_api.cc,v8impl.anonymous_namespace_37.ThreadSafeFunction.CloseHandlesAndMaybeDelete,,false,431,452,CloseHandlesAndMaybeDelete,,,14,void v8impl.anonymous_namespace_37.ThreadSafeFunction.CloseHandlesAndMaybeDelete (bool)
133594,METHOD,v8impl.anonymous_namespace_11.ThreadSafeFunction,TYPE_DECL,"void Send() {
    // Ask currently running Dispatch() to make one more iteration
    unsigned char current_state = dispatch_state.fetch_or(kDispatchPending);
    if ((current_state & kDispatchRunning) == kDispatchRunning) {
      return;
    }

    CHECK_EQ(0, uv_async_send(&async));
  }",3,3,node_api.cc,v8impl.anonymous_namespace_39.ThreadSafeFunction.Send,,false,454,462,Send,,,15,void v8impl.anonymous_namespace_39.ThreadSafeFunction.Send ()
133619,METHOD,v8impl.anonymous_namespace_11.ThreadSafeFunction,TYPE_DECL,"static void CallJs(napi_env env, napi_value cb, void* context, void* data) {
    if (!(env == nullptr || cb == nullptr)) {
      napi_value recv;
      napi_status status;

      status = napi_get_undefined(env, &recv);
      if (status != napi_ok) {
        napi_throw_error(env,
                         ""ERR_NAPI_TSFN_GET_UNDEFINED"",
                         ""Failed to retrieve undefined value"");
        return;
      }

      status = napi_call_function(env, recv, cb, 0, nullptr, nullptr);
      if (status != napi_ok && status != napi_pending_exception) {
        napi_throw_error(
            env, ""ERR_NAPI_TSFN_CALL_JS"", ""Failed to call JS callback"");
        return;
      }
    }
  }",3,3,node_api.cc,v8impl.anonymous_namespace_40.ThreadSafeFunction.CallJs,,false,466,486,CallJs,,,16,"void v8impl.anonymous_namespace_40.ThreadSafeFunction.CallJs (napi_env,napi_value,void*,void*)"
133678,METHOD,v8impl.anonymous_namespace_11.ThreadSafeFunction,TYPE_DECL,"static void AsyncCb(uv_async_t* async) {
    ThreadSafeFunction* ts_fn =
        node::ContainerOf(&ThreadSafeFunction::async, async);
    ts_fn->Dispatch();
  }",3,3,node_api.cc,v8impl.anonymous_namespace_41.ThreadSafeFunction.AsyncCb,,false,488,492,AsyncCb,,,17,void v8impl.anonymous_namespace_41.ThreadSafeFunction.AsyncCb (uv_async_t*)
133699,METHOD,v8impl.anonymous_namespace_11.ThreadSafeFunction,TYPE_DECL,"static void Cleanup(void* data) {
    reinterpret_cast<ThreadSafeFunction*>(data)->CloseHandlesAndMaybeDelete(
        true);
  }",3,3,node_api.cc,v8impl.anonymous_namespace_42.ThreadSafeFunction.Cleanup,,false,494,497,Cleanup,,,18,void v8impl.anonymous_namespace_42.ThreadSafeFunction.Cleanup (void*)
133730,METHOD,<empty>,<empty>,<empty>,1,,node_api.cc,v8impl.anonymous_namespace_11.ThreadSafeFunction:<clinit>,,false,199,,<clinit>,,,38,
133751,METHOD,v8impl.anonymous_namespace_43.AsyncContext,TYPE_DECL,"AsyncContext(node_napi_env env,
               v8::Local<v8::Object> resource_object,
               const v8::Local<v8::String> resource_name,
               bool externally_managed_resource)
      : env_(env) {
    async_id_ = node_env()->new_async_id();
    trigger_async_id_ = node_env()->get_default_trigger_async_id();
    resource_.Reset(node_env()->isolate(), resource_object);
    lost_reference_ = false;
    if (externally_managed_resource) {
      resource_.SetWeak(
          this, AsyncContext::WeakCallback, v8::WeakCallbackType::kParameter);
    }

    node::AsyncWrap::EmitAsyncInit(node_env(),
                                   resource_object,
                                   resource_name,
                                   async_id_,
                                   trigger_async_id_);
  }",3,3,node_api.cc,v8impl.anonymous_namespace_44.AsyncContext.AsyncContext,,false,537,556,AsyncContext,,,1,"ANY v8impl.anonymous_namespace_44.AsyncContext.AsyncContext (node_napi_env,ANY,ANY,bool)"
133810,METHOD,v8impl.anonymous_namespace_43.AsyncContext,TYPE_DECL,"~AsyncContext() {
    resource_.Reset();
    lost_reference_ = true;
    node::AsyncWrap::EmitDestroy(node_env(), async_id_);
  }",3,3,node_api.cc,v8impl.anonymous_namespace_49.AsyncContext.~AsyncContext,,false,558,562,~AsyncContext,,,2,ANY v8impl.anonymous_namespace_49.AsyncContext.~AsyncContext ()
133829,METHOD,v8impl.anonymous_namespace_43.AsyncContext,TYPE_DECL,"inline v8::MaybeLocal<v8::Value> MakeCallback(
      v8::Local<v8::Object> recv,
      const v8::Local<v8::Function> callback,
      int argc,
      v8::Local<v8::Value> argv[]) {
    EnsureReference();
    return node::InternalMakeCallback(node_env(),
                                      resource(),
                                      recv,
                                      callback,
                                      argc,
                                      argv,
                                      {async_id_, trigger_async_id_});
  }",3,3,node_api.cc,v8impl.anonymous_namespace_51.AsyncContext.MakeCallback,,false,564,577,MakeCallback,,,3,"MaybeLocal<v8::Value> v8impl.anonymous_namespace_51.AsyncContext.MakeCallback (ANY,ANY,int,ANY[])"
133852,METHOD,v8impl.anonymous_namespace_43.AsyncContext,TYPE_DECL,"inline napi_callback_scope OpenCallbackScope() {
    EnsureReference();
    napi_callback_scope it =
        reinterpret_cast<napi_callback_scope>(new CallbackScope(this));
    env_->open_callback_scopes++;
    return it;
  }",3,3,node_api.cc,v8impl.anonymous_namespace_55.AsyncContext.OpenCallbackScope,,false,579,585,OpenCallbackScope,,,4,napi_callback_scope v8impl.anonymous_namespace_55.AsyncContext.OpenCallbackScope ()
133871,METHOD,v8impl.anonymous_namespace_43.AsyncContext,TYPE_DECL,"inline void EnsureReference() {
    if (lost_reference_) {
      const v8::HandleScope handle_scope(node_env()->isolate());
      resource_.Reset(node_env()->isolate(),
                      v8::Object::New(node_env()->isolate()));
      lost_reference_ = false;
    }
  }",3,3,node_api.cc,v8impl.anonymous_namespace_57.AsyncContext.EnsureReference,,false,587,594,EnsureReference,,,5,void v8impl.anonymous_namespace_57.AsyncContext.EnsureReference ()
133905,METHOD,v8impl.anonymous_namespace_43.AsyncContext,TYPE_DECL,inline node::Environment* node_env() { return env_->node_env(); },3,67,node_api.cc,v8impl.anonymous_namespace_61.AsyncContext.node_env,,false,596,596,node_env,,,6,Environment v8impl.anonymous_namespace_61.AsyncContext.node_env ()
133914,METHOD,v8impl.anonymous_namespace_43.AsyncContext,TYPE_DECL,"inline v8::Local<v8::Object> resource() {
    return resource_.Get(node_env()->isolate());
  }",3,3,node_api.cc,v8impl.anonymous_namespace_62.AsyncContext.resource,,false,597,599,resource,,,7,Local<v8::Object> v8impl.anonymous_namespace_62.AsyncContext.resource ()
133927,METHOD,v8impl.anonymous_namespace_43.AsyncContext,TYPE_DECL,"inline node::async_context async_context() {
    return {async_id_, trigger_async_id_};
  }",3,3,node_api.cc,v8impl.anonymous_namespace_64.AsyncContext.async_context,,false,600,602,async_context,,,8,async_context v8impl.anonymous_namespace_64.AsyncContext.async_context ()
133932,METHOD,v8impl.anonymous_namespace_43.AsyncContext,TYPE_DECL,"static inline void CloseCallbackScope(node_napi_env env,
                                        napi_callback_scope s) {
    CallbackScope* callback_scope = reinterpret_cast<CallbackScope*>(s);
    delete callback_scope;
    env->open_callback_scopes--;
  }",3,3,node_api.cc,v8impl.anonymous_namespace_65.AsyncContext.CloseCallbackScope,,false,604,609,CloseCallbackScope,,,9,"void v8impl.anonymous_namespace_65.AsyncContext.CloseCallbackScope (node_napi_env,napi_callback_scope)"
133950,METHOD,v8impl.anonymous_namespace_43.AsyncContext,TYPE_DECL,"static void WeakCallback(const v8::WeakCallbackInfo<AsyncContext>& data) {
    AsyncContext* async_context = data.GetParameter();
    async_context->resource_.Reset();
    async_context->lost_reference_ = true;
  }",3,3,node_api.cc,v8impl.anonymous_namespace_66.AsyncContext.WeakCallback,,false,611,615,WeakCallback,,,10,void v8impl.anonymous_namespace_66.AsyncContext.WeakCallback (ANY)
133974,METHOD,v8impl.anonymous_namespace_67.AsyncContext.CallbackScope,TYPE_DECL,"explicit CallbackScope(AsyncContext* async_context)
        : node::CallbackScope(async_context->node_env(),
                              async_context->resource_.Get(
                                  async_context->node_env()->isolate()),
                              async_context->async_context()) {}",5,64,node_api.cc,v8impl.anonymous_namespace_68.AsyncContext.CallbackScope.CallbackScope,,false,620,624,CallbackScope,,,1,ANY v8impl.anonymous_namespace_68.AsyncContext.CallbackScope.CallbackScope (AsyncContext*)
133984,METHOD,node_api.cc:<global>,TYPE_DECL,"static void napi_module_register_cb(v8::Local<v8::Object> exports,
                                    v8::Local<v8::Value> module,
                                    v8::Local<v8::Context> context,
                                    void* priv) {
  napi_module_register_by_symbol(
      exports,
      module,
      context,
      static_cast<const napi_module*>(priv)->nm_register_func);
}",1,1,node_api.cc,napi_module_register_cb,,false,641,650,napi_module_register_cb,,,11,"void napi_module_register_cb (ANY,ANY,ANY,void*)"
134001,METHOD,node_api.cc:<global>,TYPE_DECL,"static void node_api_context_register_func(v8::Local<v8::Object> exports,
                                           v8::Local<v8::Value> module,
                                           v8::Local<v8::Context> context,
                                           void* priv) {
  napi_module_register_by_symbol(
      exports,
      module,
      context,
      reinterpret_cast<napi_addon_register_func>(priv),
      module_api_version);
}",1,1,node_api.cc,node_api_context_register_func,,false,653,663,node_api_context_register_func,,,12,"void node_api_context_register_func<int32_t> (ANY,ANY,ANY,void*)"
134017,METHOD,node_api.cc:<global>,TYPE_DECL,"node::addon_context_register_func get_node_api_context_register_func(
    node::Environment* node_env,
    const char* module_name,
    int32_t module_api_version) {
  static_assert(
      NAPI_VERSION == 9,
      ""New version of Node-API requires adding another else-if statement below ""
      ""for the new version and updating this assert condition."");
  if (module_api_version <= NODE_API_DEFAULT_MODULE_API_VERSION) {
    return node_api_context_register_func<NODE_API_DEFAULT_MODULE_API_VERSION>;
  } else if (module_api_version == 9) {
    return node_api_context_register_func<9>;
  } else if (module_api_version == NAPI_VERSION_EXPERIMENTAL) {
    return node_api_context_register_func<NAPI_VERSION_EXPERIMENTAL>;
  } else {
    v8impl::ThrowNodeApiVersionError(node_env, module_name, module_api_version);
    return nullptr;
  }
}",1,6,node_api.cc,get_node_api_context_register_func,,false,671,689,get_node_api_context_register_func,,,13,"addon_context_register_func get_node_api_context_register_func (ANY*,char*,int32_t)"
134071,METHOD,node_api.cc:<global>,TYPE_DECL,"void napi_module_register_by_symbol(v8::Local<v8::Object> exports,
                                    v8::Local<v8::Value> module,
                                    v8::Local<v8::Context> context,
                                    napi_addon_register_func init,
                                    int32_t module_api_version) {
  node::Environment* node_env = node::Environment::GetCurrent(context);
  std::string module_filename = """";
  if (init == nullptr) {
    CHECK_NOT_NULL(node_env);
    node_env->ThrowError(""Module has no declared entry point."");
    return;
  }

  // We set `env->filename` from `module.filename` here, but we could just as
  // easily add a private property to `exports` in `process.dlopen`, which
  // receives the file name from JS, and retrieve *that* here. Thus, we are not
  // endorsing commonjs here by making use of `module.filename`.
  v8::Local<v8::Value> filename_js;
  v8::Local<v8::Object> modobj;
  if (module->ToObject(context).ToLocal(&modobj) &&
 ...",1,1,node_api.cc,napi_module_register_by_symbol,,false,691,738,napi_module_register_by_symbol,,,14,"void napi_module_register_by_symbol (ANY,ANY,ANY,napi_addon_register_func,int32_t)"
134219,METHOD,node_api.cc:<global>,TYPE_DECL,"node_module napi_module_to_node_module(const napi_module* mod) {
  return {
      -1,
      mod->nm_flags | NM_F_DELETEME,
      nullptr,
      mod->nm_filename,
      nullptr,
      napi_module_register_cb,
      mod->nm_modname,
      const_cast<napi_module*>(mod),  // priv
      nullptr,
  };
}",1,1,node_api.cc,node.napi_module_to_node_module,,false,741,753,napi_module_to_node_module,,,1,node_module node.napi_module_to_node_module (napi_module*)
134225,METHOD,node_api.cc:<global>,TYPE_DECL,"void NAPI_CDECL napi_module_register(napi_module* mod) {
  node::node_module* nm =
      new node::node_module(node::napi_module_to_node_module(mod));
  node::node_module_register(nm);
}",1,5,node_api.cc,napi_module_register,,false,757,761,napi_module_register,,,16,void napi_module_register (napi_module*)
134245,METHOD,node_api.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_add_env_cleanup_hook(napi_env env,
                                                 napi_cleanup_hook fun,
                                                 void* arg) {
  CHECK_ENV(env);
  CHECK_ARG(env, fun);

  node::AddEnvironmentCleanupHook(env->isolate, fun, arg);

  return napi_ok;
}",1,12,node_api.cc,napi_add_env_cleanup_hook,,false,763,772,napi_add_env_cleanup_hook,,,17,"napi_status napi_add_env_cleanup_hook (napi_env,napi_cleanup_hook,void*)"
134293,METHOD,node_api.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_remove_env_cleanup_hook(napi_env env,
                                                    napi_cleanup_hook fun,
                                                    void* arg) {
  CHECK_ENV(env);
  CHECK_ARG(env, fun);

  node::RemoveEnvironmentCleanupHook(env->isolate, fun, arg);

  return napi_ok;
}",1,12,node_api.cc,napi_remove_env_cleanup_hook,,false,774,783,napi_remove_env_cleanup_hook,,,18,"napi_status napi_remove_env_cleanup_hook (napi_env,napi_cleanup_hook,void*)"
134341,METHOD,napi_async_cleanup_hook_handle__,TYPE_DECL,"napi_async_cleanup_hook_handle__(napi_env env,
                                   napi_async_cleanup_hook user_hook,
                                   void* user_data)
      : env_(env), user_hook_(user_hook), user_data_(user_data) {
    handle_ = node::AddEnvironmentCleanupHook(env->isolate, Hook, this);
    env->Ref();
  }",3,3,node_api.cc,napi_async_cleanup_hook_handle__.napi_async_cleanup_hook_handle__,,false,786,792,napi_async_cleanup_hook_handle__,,,1,"ANY napi_async_cleanup_hook_handle__.napi_async_cleanup_hook_handle__ (napi_env,napi_async_cleanup_hook,void*)"
134363,METHOD,napi_async_cleanup_hook_handle__,TYPE_DECL,"~napi_async_cleanup_hook_handle__() {
    node::RemoveEnvironmentCleanupHook(std::move(handle_));
    if (done_cb_ != nullptr) done_cb_(done_data_);

    // Release the `env` handle asynchronously since it would be surprising if
    // a call to a N-API function would destroy `env` synchronously.
    static_cast<node_napi_env>(env_)->node_env()->SetImmediate(
        [env = env_](node::Environment*) { env->Unref(); });
  }",3,3,node_api.cc,napi_async_cleanup_hook_handle__.~napi_async_cleanup_hook_handle__,,false,794,802,~napi_async_cleanup_hook_handle__,,,2,ANY napi_async_cleanup_hook_handle__.~napi_async_cleanup_hook_handle__ ()
134393,METHOD,napi_async_cleanup_hook_handle__,TYPE_DECL,"static void Hook(void* data, void (*done_cb)(void*), void* done_data) {
    napi_async_cleanup_hook_handle__* handle =
        static_cast<napi_async_cleanup_hook_handle__*>(data);
    handle->done_cb_ = done_cb;
    handle->done_data_ = done_data;
    handle->user_hook_(handle, handle->user_data_);
  }",3,3,node_api.cc,napi_async_cleanup_hook_handle__.Hook,,false,804,810,Hook,,,3,"void napi_async_cleanup_hook_handle__.Hook (void*,void,void*)"
134428,METHOD,napi_async_cleanup_hook_handle__,TYPE_DECL,void (*done_cb_)(void*) = nullptr;,8,35,node_api.cc,napi_async_cleanup_hook_handle__.done_cb_,,false,816,816,done_cb_,,,8,void napi_async_cleanup_hook_handle__.done_cb_ (void*)
134434,METHOD,<empty>,<empty>,<empty>,1,,node_api.cc,napi_async_cleanup_hook_handle__:<clinit>,,false,785,,<clinit>,,,10,
134453,METHOD,node_api.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL
napi_add_async_cleanup_hook(napi_env env,
                            napi_async_cleanup_hook hook,
                            void* arg,
                            napi_async_cleanup_hook_handle* remove_handle) {
  CHECK_ENV(env);
  CHECK_ARG(env, hook);

  napi_async_cleanup_hook_handle__* handle =
      new napi_async_cleanup_hook_handle__(env, hook, arg);

  if (remove_handle != nullptr) *remove_handle = handle;

  return napi_clear_last_error(env);
}",1,12,node_api.cc,napi_add_async_cleanup_hook,,false,820,834,napi_add_async_cleanup_hook,,,20,"napi_status napi_add_async_cleanup_hook (napi_env,napi_async_cleanup_hook,void*,napi_async_cleanup_hook_handle*)"
134511,METHOD,node_api.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL
napi_remove_async_cleanup_hook(napi_async_cleanup_hook_handle remove_handle) {
  if (remove_handle == nullptr) return napi_invalid_arg;

  delete remove_handle;

  return napi_ok;
}",1,12,node_api.cc,napi_remove_async_cleanup_hook,,false,836,843,napi_remove_async_cleanup_hook,,,21,napi_status napi_remove_async_cleanup_hook (napi_async_cleanup_hook_handle)
134527,METHOD,node_api.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_fatal_exception(napi_env env, napi_value err) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, err);

  v8::Local<v8::Value> local_err = v8impl::V8LocalValueFromJsValue(err);
  static_cast<node_napi_env>(env)->trigger_fatal_exception(local_err);

  return napi_clear_last_error(env);
}",1,12,node_api.cc,napi_fatal_exception,,false,845,853,napi_fatal_exception,,,22,"napi_status napi_fatal_exception (napi_env,napi_value)"
134630,METHOD,node_api.cc:<global>,TYPE_DECL,"void NAPI_CDECL napi_fatal_error(const char* location,
                                                size_t location_len,
                                                const char* message,
                                                size_t message_len) {
  std::string location_string;
  std::string message_string;

  if (location_len != NAPI_AUTO_LENGTH) {
    location_string.assign(const_cast<char*>(location), location_len);
  } else {
    location_string.assign(const_cast<char*>(location), strlen(location));
  }

  if (message_len != NAPI_AUTO_LENGTH) {
    message_string.assign(const_cast<char*>(message), message_len);
  } else {
    message_string.assign(const_cast<char*>(message), strlen(message));
  }

  node::OnFatalError(location_string.c_str(), message_string.c_str());
}",16,20,node_api.cc,napi_fatal_error,,false,855,875,napi_fatal_error,,,23,"void napi_fatal_error (char*,size_t,char*,size_t)"
134704,METHOD,node_api.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL
napi_open_callback_scope(napi_env env,
                         napi_value /** ignored */,
                         napi_async_context async_context_handle,
                         napi_callback_scope* result) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  v8impl::AsyncContext* node_async_context =
      reinterpret_cast<v8impl::AsyncContext*>(async_context_handle);

  *result = node_async_context->OpenCallbackScope();

  return napi_clear_last_error(env);
}",1,12,node_api.cc,napi_open_callback_scope,,false,877,893,napi_open_callback_scope,,,24,"napi_status napi_open_callback_scope (napi_env,napi_value,napi_async_context,napi_callback_scope*)"
134758,METHOD,node_api.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_close_callback_scope(napi_env env,
                                                 napi_callback_scope scope) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, scope);
  if (env->open_callback_scopes == 0) {
    return napi_callback_scope_mismatch;
  }

  v8impl::AsyncContext::CloseCallbackScope(reinterpret_cast<node_napi_env>(env),
                                           scope);

  return napi_clear_last_error(env);
}",1,12,node_api.cc,napi_close_callback_scope,,false,895,909,napi_close_callback_scope,,,25,"napi_status napi_close_callback_scope (napi_env,napi_callback_scope)"
134816,METHOD,node_api.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_async_init(napi_env env,
                                       napi_value async_resource,
                                       napi_value async_resource_name,
                                       napi_async_context* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, async_resource_name);
  CHECK_ARG(env, result);

  v8::Isolate* isolate = env->isolate;
  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Object> v8_resource;
  bool externally_managed_resource;
  if (async_resource != nullptr) {
    CHECK_TO_OBJECT(env, context, v8_resource, async_resource);
    externally_managed_resource = true;
  } else {
    v8_resource = v8::Object::New(isolate);
    externally_managed_resource = false;
  }

  v8::Local<v8::String> v8_resource_name;
  CHECK_TO_STRING(env, context, v8_resource_name, async_resource_name);

  v8impl::AsyncContext* async_context =
      new v8impl::AsyncContext(reinterpret_cast<node_napi_env>(env),
                          ...",1,12,node_api.cc,napi_async_init,,false,911,944,napi_async_init,,,26,"napi_status napi_async_init (napi_env,napi_value,napi_value,napi_async_context*)"
135064,METHOD,node_api.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_async_destroy(napi_env env,
                                          napi_async_context async_context) {
  CHECK_ENV(env);
  CHECK_ARG(env, async_context);

  v8impl::AsyncContext* node_async_context =
      reinterpret_cast<v8impl::AsyncContext*>(async_context);

  delete node_async_context;

  return napi_clear_last_error(env);
}",1,12,node_api.cc,napi_async_destroy,,false,946,957,napi_async_destroy,,,27,"napi_status napi_async_destroy (napi_env,napi_async_context)"
135111,METHOD,node_api.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_make_callback(napi_env env,
                                          napi_async_context async_context,
                                          napi_value recv,
                                          napi_value func,
                                          size_t argc,
                                          const napi_value* argv,
                                          napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, recv);
  if (argc > 0) {
    CHECK_ARG(env, argv);
  }

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Object> v8recv;
  CHECK_TO_OBJECT(env, context, v8recv, recv);

  v8::Local<v8::Function> v8func;
  CHECK_TO_FUNCTION(env, v8func, func);

  v8::MaybeLocal<v8::Value> callback_result;

  if (async_context == nullptr) {
    callback_result = node::MakeCallback(
        env->isolate,
        v8recv,
        v8func,
        argc,
        reinterpret_cast<v8::Local<v8::Value>*>(const_cast<napi_value*...",1,12,node_api.cc,napi_make_callback,,false,959,1011,napi_make_callback,,,28,"napi_status napi_make_callback (napi_env,napi_async_context,napi_value,napi_value,size_t,napi_value*,napi_value*)"
135478,METHOD,node_api.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_create_buffer(napi_env env,
                                          size_t length,
                                          void** data,
                                          napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::MaybeLocal<v8::Object> maybe = node::Buffer::New(env->isolate, length);

  CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure);

  v8::Local<v8::Object> buffer = maybe.ToLocalChecked();

  *result = v8impl::JsValueFromV8LocalValue(buffer);

  if (data != nullptr) {
    *data = node::Buffer::Data(buffer);
  }

  return GET_RETURN_STATUS(env);
}",1,12,node_api.cc,napi_create_buffer,,false,1013,1033,napi_create_buffer,,,29,"napi_status napi_create_buffer (napi_env,size_t,void**,napi_value*)"
135649,METHOD,node_api.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_create_external_buffer(napi_env env,
                                                   size_t length,
                                                   void* data,
                                                   napi_finalize finalize_cb,
                                                   void* finalize_hint,
                                                   napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

#if defined(V8_ENABLE_SANDBOX)
  return napi_set_last_error(env, napi_no_external_buffers_allowed);
#endif

  v8::Isolate* isolate = env->isolate;

  // The finalizer object will delete itself after invoking the callback.
  v8impl::BufferFinalizer* finalizer =
      v8impl::BufferFinalizer::New(env, finalize_cb, nullptr, finalize_hint);

  v8::MaybeLocal<v8::Object> maybe =
      node::Buffer::New(isolate,
                        static_cast<char*>(data),
                        length,
                        v8impl::BufferF...",1,12,node_api.cc,napi_create_external_buffer,,false,1035,1069,napi_create_external_buffer,,,30,"napi_status napi_create_external_buffer (napi_env,size_t,void*,napi_finalize,void*,napi_value*)"
135822,METHOD,node_api.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_create_buffer_copy(napi_env env,
                                               size_t length,
                                               const void* data,
                                               void** result_data,
                                               napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::MaybeLocal<v8::Object> maybe =
      node::Buffer::Copy(env->isolate, static_cast<const char*>(data), length);

  CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure);

  v8::Local<v8::Object> buffer = maybe.ToLocalChecked();
  *result = v8impl::JsValueFromV8LocalValue(buffer);

  if (result_data != nullptr) {
    *result_data = node::Buffer::Data(buffer);
  }

  return GET_RETURN_STATUS(env);
}",1,12,node_api.cc,napi_create_buffer_copy,,false,1071,1092,napi_create_buffer_copy,,,31,"napi_status napi_create_buffer_copy (napi_env,size_t,void*,void**,napi_value*)"
135997,METHOD,node_api.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_is_buffer(napi_env env,
                                      napi_value value,
                                      bool* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  *result = node::Buffer::HasInstance(v8impl::V8LocalValueFromJsValue(value));
  return napi_clear_last_error(env);
}",1,12,node_api.cc,napi_is_buffer,,false,1094,1103,napi_is_buffer,,,32,"napi_status napi_is_buffer (napi_env,napi_value,bool*)"
136068,METHOD,node_api.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_get_buffer_info(napi_env env,
                                            napi_value value,
                                            void** data,
                                            size_t* length) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);

  v8::Local<v8::Value> buffer = v8impl::V8LocalValueFromJsValue(value);

  if (data != nullptr) {
    *data = node::Buffer::Data(buffer);
  }
  if (length != nullptr) {
    *length = node::Buffer::Length(buffer);
  }

  return napi_clear_last_error(env);
}",1,12,node_api.cc,napi_get_buffer_info,,false,1105,1122,napi_get_buffer_info,,,33,"napi_status napi_get_buffer_info (napi_env,napi_value,void**,size_t*)"
136154,METHOD,node_api.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_get_node_version(napi_env env,
                                             const napi_node_version** result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);
  static const napi_node_version version = {
      NODE_MAJOR_VERSION, NODE_MINOR_VERSION, NODE_PATCH_VERSION, NODE_RELEASE};
  *result = &version;
  return napi_clear_last_error(env);
}",1,12,node_api.cc,napi_get_node_version,,false,1124,1132,napi_get_node_version,,,34,"napi_status napi_get_node_version (napi_env,napi_node_version**)"
136216,METHOD,node_api.cc:<global>,TYPE_DECL,"static napi_status ConvertUVErrorCode(int code) {
  switch (code) {
    case 0:
      return napi_ok;
    case UV_EINVAL:
      return napi_invalid_arg;
    case UV_ECANCELED:
      return napi_cancelled;
    default:
      return napi_generic_failure;
  }
}",1,1,node_api.cc,anonymous_namespace_74.uvimpl.ConvertUVErrorCode,,false,1137,1148,ConvertUVErrorCode,,,1,napi_status anonymous_namespace_74.uvimpl.ConvertUVErrorCode (int)
136239,METHOD,anonymous_namespace_75.uvimpl.Work,TYPE_DECL,"explicit Work(node_napi_env env,
                v8::Local<v8::Object> async_resource,
                v8::Local<v8::String> async_resource_name,
                napi_async_execute_callback execute,
                napi_async_complete_callback complete = nullptr,
                void* data = nullptr)
      : AsyncResource(
            env->isolate,
            async_resource,
            *v8::String::Utf8Value(env->isolate, async_resource_name)),
        ThreadPoolWork(env->node_env(), ""node_api""),
        _env(env),
        _data(data),
        _execute(execute),
        _complete(complete) {}",3,30,node_api.cc,anonymous_namespace_76.uvimpl.Work.Work,,false,1153,1167,Work,,,1,"ANY anonymous_namespace_76.uvimpl.Work.Work (node_napi_env,ANY,ANY,napi_async_execute_callback,napi_async_complete_callback,void*)"
136249,METHOD,anonymous_namespace_75.uvimpl.Work,TYPE_DECL,~Work() override = default;,3,29,node_api.cc,anonymous_namespace_77.uvimpl.Work.~Work,,false,1169,1169,~Work,,,2,ANY anonymous_namespace_77.uvimpl.Work.~Work ()
136253,METHOD,anonymous_namespace_75.uvimpl.Work,TYPE_DECL,"static Work* New(node_napi_env env,
                   v8::Local<v8::Object> async_resource,
                   v8::Local<v8::String> async_resource_name,
                   napi_async_execute_callback execute,
                   napi_async_complete_callback complete,
                   void* data) {
    return new Work(
        env, async_resource, async_resource_name, execute, complete, data);
  }",3,3,node_api.cc,anonymous_namespace_78.uvimpl.Work.New,,false,1172,1180,New,,,3,"Work anonymous_namespace_78.uvimpl.Work.New (node_napi_env,ANY,ANY,napi_async_execute_callback,napi_async_complete_callback,void*)"
136272,METHOD,anonymous_namespace_75.uvimpl.Work,TYPE_DECL,static void Delete(Work* work) { delete work; },3,49,node_api.cc,anonymous_namespace_79.uvimpl.Work.Delete,,false,1182,1182,Delete,,,4,void anonymous_namespace_79.uvimpl.Work.Delete (Work*)
136279,METHOD,anonymous_namespace_75.uvimpl.Work,TYPE_DECL,"void DoThreadPoolWork() override { _execute(_env, _data); }",3,61,node_api.cc,anonymous_namespace_80.uvimpl.Work.DoThreadPoolWork,,false,1184,1184,DoThreadPoolWork,,,5,void anonymous_namespace_80.uvimpl.Work.DoThreadPoolWork ()
136286,METHOD,anonymous_namespace_75.uvimpl.Work,TYPE_DECL,"void AfterThreadPoolWork(int status) override {
    if (_complete == nullptr) return;

    // Establish a handle scope here so that every callback doesn't have to.
    // Also it is needed for the exception-handling below.
    v8::HandleScope scope(_env->isolate);

    CallbackScope callback_scope(this);

    _env->CallbackIntoModule<true>([&](napi_env env) {
      _complete(env, ConvertUVErrorCode(status), _data);
    });

    // Note: Don't access `work` after this point because it was
    // likely deleted by the complete callback.
  }",3,3,node_api.cc,anonymous_namespace_81.uvimpl.Work.AfterThreadPoolWork,,false,1186,1201,AfterThreadPoolWork,,,6,void anonymous_namespace_81.uvimpl.Work.AfterThreadPoolWork (int)
136313,METHOD,node_api.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL
napi_create_async_work(napi_env env,
                       napi_value async_resource,
                       napi_value async_resource_name,
                       napi_async_execute_callback execute,
                       napi_async_complete_callback complete,
                       void* data,
                       napi_async_work* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, execute);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Object> resource;
  if (async_resource != nullptr) {
    CHECK_TO_OBJECT(env, context, resource, async_resource);
  } else {
    resource = v8::Object::New(env->isolate);
  }

  v8::Local<v8::String> resource_name;
  CHECK_TO_STRING(env, context, resource_name, async_resource_name);

  uvimpl::Work* work = uvimpl::Work::New(reinterpret_cast<node_napi_env>(env),
                                         resource,
                                         resource_name,
              ...",1,12,node_api.cc,napi_create_async_work,,false,1222,1256,napi_create_async_work,,,36,"napi_status napi_create_async_work (napi_env,napi_value,napi_value,napi_async_execute_callback,napi_async_complete_callback,void*,napi_async_work*)"
136559,METHOD,node_api.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_delete_async_work(napi_env env,
                                              napi_async_work work) {
  CHECK_ENV(env);
  CHECK_ARG(env, work);

  uvimpl::Work::Delete(reinterpret_cast<uvimpl::Work*>(work));

  return napi_clear_last_error(env);
}",1,12,node_api.cc,napi_delete_async_work,,false,1258,1266,napi_delete_async_work,,,37,"napi_status napi_delete_async_work (napi_env,napi_async_work)"
136607,METHOD,node_api.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_get_uv_event_loop(napi_env env, uv_loop_t** loop) {
  CHECK_ENV(env);
  CHECK_ARG(env, loop);
  *loop = reinterpret_cast<node_napi_env>(env)->node_env()->event_loop();
  return napi_clear_last_error(env);
}",1,12,node_api.cc,napi_get_uv_event_loop,,false,1268,1273,napi_get_uv_event_loop,,,38,"napi_status napi_get_uv_event_loop (napi_env,uv_loop_t**)"
136658,METHOD,node_api.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_queue_async_work(napi_env env,
                                             napi_async_work work) {
  CHECK_ENV(env);
  CHECK_ARG(env, work);

  uv_loop_t* event_loop = nullptr;
  STATUS_CALL(napi_get_uv_event_loop(env, &event_loop));

  uvimpl::Work* w = reinterpret_cast<uvimpl::Work*>(work);

  w->ScheduleWork();

  return napi_clear_last_error(env);
}",1,12,node_api.cc,napi_queue_async_work,,false,1275,1288,napi_queue_async_work,,,39,"napi_status napi_queue_async_work (napi_env,napi_async_work)"
136731,METHOD,node_api.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_cancel_async_work(napi_env env,
                                              napi_async_work work) {
  CHECK_ENV(env);
  CHECK_ARG(env, work);

  uvimpl::Work* w = reinterpret_cast<uvimpl::Work*>(work);

  CALL_UV(env, w->CancelWork());

  return napi_clear_last_error(env);
}",1,12,node_api.cc,napi_cancel_async_work,,false,1290,1300,napi_cancel_async_work,,,40,"napi_status napi_cancel_async_work (napi_env,napi_async_work)"
136813,METHOD,node_api.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL
napi_create_threadsafe_function(napi_env env,
                                napi_value func,
                                napi_value async_resource,
                                napi_value async_resource_name,
                                size_t max_queue_size,
                                size_t initial_thread_count,
                                void* thread_finalize_data,
                                napi_finalize thread_finalize_cb,
                                void* context,
                                napi_threadsafe_function_call_js call_js_cb,
                                napi_threadsafe_function* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, async_resource_name);
  RETURN_STATUS_IF_FALSE(env, initial_thread_count > 0, napi_invalid_arg);
  CHECK_ARG(env, result);

  napi_status status = napi_ok;

  v8::Local<v8::Function> v8_func;
  if (func == nullptr) {
    CHECK_ARG(env, call_js_cb);
  } else {
    CHECK_TO_FUNCTION(env, ...",1,12,node_api.cc,napi_create_threadsafe_function,,false,1302,1363,napi_create_threadsafe_function,,,41,"napi_status napi_create_threadsafe_function (napi_env,napi_value,napi_value,napi_value,size_t,size_t,void*,napi_finalize,void*,napi_threadsafe_function_call_js,napi_threadsafe_function*)"
137195,METHOD,node_api.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_get_threadsafe_function_context(
    napi_threadsafe_function func, void** result) {
  CHECK_NOT_NULL(func);
  CHECK_NOT_NULL(result);

  *result = reinterpret_cast<v8impl::ThreadSafeFunction*>(func)->Context();
  return napi_ok;
}",1,12,node_api.cc,napi_get_threadsafe_function_context,,false,1365,1372,napi_get_threadsafe_function_context,,,42,"napi_status napi_get_threadsafe_function_context (napi_threadsafe_function,void**)"
137216,METHOD,node_api.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL
napi_call_threadsafe_function(napi_threadsafe_function func,
                              void* data,
                              napi_threadsafe_function_call_mode is_blocking) {
  CHECK_NOT_NULL(func);
  return reinterpret_cast<v8impl::ThreadSafeFunction*>(func)->Push(data,
                                                                   is_blocking);
}",1,12,node_api.cc,napi_call_threadsafe_function,,false,1374,1381,napi_call_threadsafe_function,,,43,"napi_status napi_call_threadsafe_function (napi_threadsafe_function,void*,napi_threadsafe_function_call_mode)"
137234,METHOD,node_api.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL
napi_acquire_threadsafe_function(napi_threadsafe_function func) {
  CHECK_NOT_NULL(func);
  return reinterpret_cast<v8impl::ThreadSafeFunction*>(func)->Acquire();
}",1,12,node_api.cc,napi_acquire_threadsafe_function,,false,1383,1387,napi_acquire_threadsafe_function,,,44,napi_status napi_acquire_threadsafe_function (napi_threadsafe_function)
137248,METHOD,node_api.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL napi_release_threadsafe_function(
    napi_threadsafe_function func, napi_threadsafe_function_release_mode mode) {
  CHECK_NOT_NULL(func);
  return reinterpret_cast<v8impl::ThreadSafeFunction*>(func)->Release(mode);
}",1,12,node_api.cc,napi_release_threadsafe_function,,false,1389,1393,napi_release_threadsafe_function,,,45,"napi_status napi_release_threadsafe_function (napi_threadsafe_function,napi_threadsafe_function_release_mode)"
137264,METHOD,node_api.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL
napi_unref_threadsafe_function(napi_env env, napi_threadsafe_function func) {
  CHECK_NOT_NULL(func);
  return reinterpret_cast<v8impl::ThreadSafeFunction*>(func)->Unref();
}",1,12,node_api.cc,napi_unref_threadsafe_function,,false,1395,1399,napi_unref_threadsafe_function,,,46,"napi_status napi_unref_threadsafe_function (napi_env,napi_threadsafe_function)"
137279,METHOD,node_api.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL
napi_ref_threadsafe_function(napi_env env, napi_threadsafe_function func) {
  CHECK_NOT_NULL(func);
  return reinterpret_cast<v8impl::ThreadSafeFunction*>(func)->Ref();
}",1,12,node_api.cc,napi_ref_threadsafe_function,,false,1401,1405,napi_ref_threadsafe_function,,,47,"napi_status napi_ref_threadsafe_function (napi_env,napi_threadsafe_function)"
137294,METHOD,node_api.cc:<global>,TYPE_DECL,"napi_status NAPI_CDECL node_api_get_module_file_name(napi_env env,
                                                     const char** result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = static_cast<node_napi_env>(env)->GetFilename();
  return napi_clear_last_error(env);
}",1,12,node_api.cc,node_api_get_module_file_name,,false,1407,1414,node_api_get_module_file_name,,,48,"napi_status node_api_get_module_file_name (napi_env,char**)"
137349,METHOD,node_api.hpp:<global>,TYPE_DECL,<global>,1,7,node_api.hpp,node_api.hpp:<global>,,false,1,260,<global>,,,1,
137352,METHOD,node_api.hpp:<global>,TYPE_DECL,"typedef napi_value(NAPI_CDECL* napi_addon_register_func)(napi_env env,
                                                         napi_value exports);",19,19,node_api.hpp,napi_addon_register_func,,false,31,32,napi_addon_register_func,,,2,"napi_value napi_addon_register_func (napi_env,napi_value)"
137358,METHOD,node_api.hpp:<global>,TYPE_DECL,typedef int32_t(NAPI_CDECL* node_api_addon_get_api_version_func)();,16,16,node_api.hpp,node_api_addon_get_api_version_func,,false,33,33,node_api_addon_get_api_version_func,,,3,int32_t node_api_addon_get_api_version_func ()
137370,METHOD,<empty>,<empty>,<empty>,1,,node_api.hpp,napi_module:<clinit>,,false,36,,<clinit>,,,8,
137377,METHOD,node_api.hpp:<global>,TYPE_DECL,void void (napi_module *);,1,38,node_api.hpp,napi_module_register,,false,92,92,napi_module_register,,,6,void napi_module_register (napi_module*)
137382,METHOD,node_api.hpp:<global>,TYPE_DECL,"void void (const char *, size_t, const char *, size_t);",1,36,node_api.hpp,napi_fatal_error,,false,95,98,napi_fatal_error,,,7,"void napi_fatal_error (char*,size_t,char*,size_t)"
137390,METHOD,node_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, napi_value, napi_async_context *);",1,43,node_api.hpp,napi_async_init,,false,102,105,napi_async_init,,,8,"napi_status napi_async_init (napi_env,napi_value,napi_value,napi_async_context*)"
137398,METHOD,node_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_async_context);",1,66,node_api.hpp,napi_async_destroy,,false,108,108,napi_async_destroy,,,9,"napi_status napi_async_destroy (napi_env,napi_async_context)"
137404,METHOD,node_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_async_context, napi_value, napi_value, size_t, const napi_value *, napi_value *);",1,38,node_api.hpp,napi_make_callback,,false,111,117,napi_make_callback,,,10,"napi_status napi_make_callback (napi_env,napi_async_context,napi_value,napi_value,size_t,napi_value*,napi_value*)"
137415,METHOD,node_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, size_t, void * *, napi_value *);",36,73,node_api.hpp,napi_create_buffer,,false,120,123,napi_create_buffer,,,11,"napi_status napi_create_buffer (napi_env,size_t,void**,napi_value*)"
137423,METHOD,node_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, size_t, void *, napi_finalize, void *, napi_value *);",1,47,node_api.hpp,napi_create_external_buffer,,false,126,131,napi_create_external_buffer,,,12,"napi_status napi_create_external_buffer (napi_env,size_t,void*,napi_finalize,void*,napi_value*)"
137433,METHOD,node_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, size_t, const void *, void * *, napi_value *);",36,78,node_api.hpp,napi_create_buffer_copy,,false,133,137,napi_create_buffer_copy,,,13,"napi_status napi_create_buffer_copy (napi_env,size_t,void*,void**,napi_value*)"
137442,METHOD,node_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, bool *);",36,63,node_api.hpp,napi_is_buffer,,false,138,140,napi_is_buffer,,,14,"napi_status napi_is_buffer (napi_env,napi_value,bool*)"
137449,METHOD,node_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, void * *, size_t *);",36,71,node_api.hpp,napi_get_buffer_info,,false,141,144,napi_get_buffer_info,,,15,"napi_status napi_get_buffer_info (napi_env,napi_value,void**,size_t*)"
137457,METHOD,node_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, napi_value, napi_async_execute_callback, napi_async_complete_callback, void *, napi_async_work *);",1,47,node_api.hpp,napi_create_async_work,,false,149,155,napi_create_async_work,,,16,"napi_status napi_create_async_work (napi_env,napi_value,napi_value,napi_async_execute_callback,napi_async_complete_callback,void*,napi_async_work*)"
137468,METHOD,node_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_async_work);",36,79,node_api.hpp,napi_delete_async_work,,false,156,157,napi_delete_async_work,,,17,"napi_status napi_delete_async_work (napi_env,napi_async_work)"
137474,METHOD,node_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_async_work);",36,78,node_api.hpp,napi_queue_async_work,,false,158,159,napi_queue_async_work,,,18,"napi_status napi_queue_async_work (napi_env,napi_async_work)"
137480,METHOD,node_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_async_work);",36,79,node_api.hpp,napi_cancel_async_work,,false,160,161,napi_cancel_async_work,,,19,"napi_status napi_cancel_async_work (napi_env,napi_async_work)"
137486,METHOD,node_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, const napi_node_version * *);",1,70,node_api.hpp,napi_get_node_version,,false,166,166,napi_get_node_version,,,20,"napi_status napi_get_node_version (napi_env,napi_node_version**)"
137492,METHOD,node_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, uv_loop_s * *);",1,61,node_api.hpp,napi_get_uv_event_loop,,false,172,172,napi_get_uv_event_loop,,,21,"napi_status napi_get_uv_event_loop (napi_env,uv_loop_s**)"
137498,METHOD,node_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value);",36,71,node_api.hpp,napi_fatal_exception,,false,178,179,napi_fatal_exception,,,22,"napi_status napi_fatal_exception (napi_env,napi_value)"
137504,METHOD,node_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_cleanup_hook, void *);",1,73,node_api.hpp,napi_add_env_cleanup_hook,,false,182,182,napi_add_env_cleanup_hook,,,23,"napi_status napi_add_env_cleanup_hook (napi_env,napi_cleanup_hook,void*)"
137511,METHOD,node_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_cleanup_hook, void *);",1,76,node_api.hpp,napi_remove_env_cleanup_hook,,false,185,185,napi_remove_env_cleanup_hook,,,24,"napi_status napi_remove_env_cleanup_hook (napi_env,napi_cleanup_hook,void*)"
137518,METHOD,node_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, napi_async_context, napi_callback_scope *);",1,53,node_api.hpp,napi_open_callback_scope,,false,188,191,napi_open_callback_scope,,,25,"napi_status napi_open_callback_scope (napi_env,napi_value,napi_async_context,napi_callback_scope*)"
137526,METHOD,node_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_callback_scope);",1,66,node_api.hpp,napi_close_callback_scope,,false,194,194,napi_close_callback_scope,,,26,"napi_status napi_close_callback_scope (napi_env,napi_callback_scope)"
137532,METHOD,node_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_value, napi_value, napi_value, size_t, size_t, void *, napi_finalize, void *, napi_threadsafe_function_call_js, napi_threadsafe_function *);",1,65,node_api.hpp,napi_create_threadsafe_function,,false,203,213,napi_create_threadsafe_function,,,27,"napi_status napi_create_threadsafe_function (napi_env,napi_value,napi_value,napi_value,size_t,size_t,void*,napi_finalize,void*,napi_threadsafe_function_call_js,napi_threadsafe_function*)"
137547,METHOD,node_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_threadsafe_function, void * *);",36,49,node_api.hpp,napi_get_threadsafe_function_context,,false,215,216,napi_get_threadsafe_function_context,,,28,"napi_status napi_get_threadsafe_function_context (napi_threadsafe_function,void**)"
137553,METHOD,node_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_threadsafe_function, void *, napi_threadsafe_function_call_mode);",1,77,node_api.hpp,napi_call_threadsafe_function,,false,219,221,napi_call_threadsafe_function,,,29,"napi_status napi_call_threadsafe_function (napi_threadsafe_function,void*,napi_threadsafe_function_call_mode)"
137560,METHOD,node_api.hpp:<global>,TYPE_DECL,napi_status napi_status (napi_threadsafe_function);,1,63,node_api.hpp,napi_acquire_threadsafe_function,,false,224,224,napi_acquire_threadsafe_function,,,30,napi_status napi_acquire_threadsafe_function (napi_threadsafe_function)
137565,METHOD,node_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_threadsafe_function, napi_threadsafe_function_release_mode);",36,78,node_api.hpp,napi_release_threadsafe_function,,false,226,227,napi_release_threadsafe_function,,,31,"napi_status napi_release_threadsafe_function (napi_threadsafe_function,napi_threadsafe_function_release_mode)"
137571,METHOD,node_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_threadsafe_function);",1,75,node_api.hpp,napi_unref_threadsafe_function,,false,230,230,napi_unref_threadsafe_function,,,32,"napi_status napi_unref_threadsafe_function (napi_env,napi_threadsafe_function)"
137577,METHOD,node_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_threadsafe_function);",1,73,node_api.hpp,napi_ref_threadsafe_function,,false,233,233,napi_ref_threadsafe_function,,,33,"napi_status napi_ref_threadsafe_function (napi_env,napi_threadsafe_function)"
137583,METHOD,node_api.hpp:<global>,TYPE_DECL,"napi_status napi_status (napi_env, napi_async_cleanup_hook, void *, napi_async_cleanup_hook_handle *);",1,74,node_api.hpp,napi_add_async_cleanup_hook,,false,241,244,napi_add_async_cleanup_hook,,,34,"napi_status napi_add_async_cleanup_hook (napi_env,napi_async_cleanup_hook,void*,napi_async_cleanup_hook_handle*)"
137591,METHOD,node_api.hpp:<global>,TYPE_DECL,napi_status napi_status (napi_async_cleanup_hook_handle);,1,76,node_api.hpp,napi_remove_async_cleanup_hook,,false,247,247,napi_remove_async_cleanup_hook,,,35,napi_status napi_remove_async_cleanup_hook (napi_async_cleanup_hook_handle)
137609,METHOD,node_api_internals.hpp:<global>,TYPE_DECL,<global>,1,26,node_api_internals.hpp,node_api_internals.hpp:<global>,,false,1,42,<global>,,,1,
137612,METHOD,node_napi_env__,TYPE_DECL,"node_napi_env__(v8::Local<v8::Context> context,
                  const std::string& module_filename,
                  int32_t module_api_version);",3,45,node_api_internals.hpp,node_napi_env__.node_napi_env__,,false,12,14,node_napi_env__,,,1,"ANY node_napi_env__.node_napi_env__ (ANY,ANY,int32_t)"
137619,METHOD,node_napi_env__,TYPE_DECL,bool can_call_into_js() const override;,8,40,node_api_internals.hpp,node_napi_env__.can_call_into_js,,false,16,16,can_call_into_js,,,2,bool node_napi_env__.can_call_into_js ()
137623,METHOD,node_napi_env__,TYPE_DECL,"void CallFinalizer(napi_finalize cb, void* data, void* hint) override;",8,71,node_api_internals.hpp,node_napi_env__.CallFinalizer,,false,17,17,CallFinalizer,,,3,"void node_napi_env__.CallFinalizer (napi_finalize,void*,void*)"
137630,METHOD,node_napi_env__,TYPE_DECL,"void CallFinalizer(napi_finalize cb, void* data, void* hint);",8,62,node_api_internals.hpp,node_napi_env__.CallFinalizer,,false,19,19,CallFinalizer,,,4,"void node_napi_env__.CallFinalizer<bool> (napi_finalize,void*,void*)"
137637,METHOD,node_napi_env__,TYPE_DECL,void EnqueueFinalizer(v8impl::RefTracker* finalizer) override;,8,63,node_api_internals.hpp,node_napi_env__.EnqueueFinalizer,,false,21,21,EnqueueFinalizer,,,5,void node_napi_env__.EnqueueFinalizer (ANY*)
137642,METHOD,node_napi_env__,TYPE_DECL,void DrainFinalizerQueue();,8,28,node_api_internals.hpp,node_napi_env__.DrainFinalizerQueue,,false,22,22,DrainFinalizerQueue,,,6,void node_napi_env__.DrainFinalizerQueue ()
137646,METHOD,node_napi_env__,TYPE_DECL,void trigger_fatal_exception(v8::Local<v8::Value> local_err);,8,62,node_api_internals.hpp,node_napi_env__.trigger_fatal_exception,,false,24,24,trigger_fatal_exception,,,7,void node_napi_env__.trigger_fatal_exception (ANY)
137651,METHOD,node_napi_env__,TYPE_DECL,void CallbackIntoModule(T&& call);,8,35,node_api_internals.hpp,node_napi_env__.CallbackIntoModule,,false,26,26,CallbackIntoModule,,,8,"void node_napi_env__.CallbackIntoModule<bool,T> (T)"
137656,METHOD,node_napi_env__,TYPE_DECL,void DeleteMe() override;,8,26,node_api_internals.hpp,node_napi_env__.DeleteMe,,false,28,28,DeleteMe,,,9,void node_napi_env__.DeleteMe ()
137660,METHOD,node_napi_env__,TYPE_DECL,"inline node::Environment* node_env() const {
    return node::Environment::GetCurrent(context());
  }",3,3,node_api_internals.hpp,node_napi_env__.node_env,,false,30,32,node_env,,,10,Environment node_napi_env__.node_env ()
137672,METHOD,node_napi_env__,TYPE_DECL,inline const char* GetFilename() const { return filename.c_str(); },3,69,node_api_internals.hpp,node_napi_env__.GetFilename,,false,33,33,GetFilename,,,11,const char* node_napi_env__.GetFilename ()
137684,METHOD,<empty>,<empty>,<empty>,1,,node_api_internals.hpp,node_napi_env__:<clinit>,,false,11,,<clinit>,,,15,
137700,METHOD,node_api_types.hpp:<global>,TYPE_DECL,<global>,1,1,node_api_types.hpp,node_api_types.hpp:<global>,,false,1,52,<global>,,,1,
137708,METHOD,node_api_types.hpp:<global>,TYPE_DECL,"typedef void(NAPI_CDECL* napi_async_execute_callback)(napi_env env, void* data);",13,13,node_api_types.hpp,napi_async_execute_callback,,false,30,30,napi_async_execute_callback,,,7,"void napi_async_execute_callback (napi_env,void*)"
137714,METHOD,node_api_types.hpp:<global>,TYPE_DECL,"typedef void(NAPI_CDECL* napi_async_complete_callback)(napi_env env,
                                                       napi_status status,
                                                       void* data);",13,13,node_api_types.hpp,napi_async_complete_callback,,false,31,33,napi_async_complete_callback,,,8,"void napi_async_complete_callback (napi_env,napi_status,void*)"
137728,METHOD,node_binding.cc:<global>,TYPE_DECL,"[&](DLib* dlib) {
    static Mutex dlib_load_mutex;
    Mutex::ScopedLock lock(dlib_load_mutex);

    const bool is_opened = dlib->Open();

    // Objects containing v14 or later modules will have registered themselves
    // on the pending list.  Activate all of them now.  At present, only one
    // module per object is supported.
    node_module* mp = thread_local_modpending;
    thread_local_modpending = nullptr;

    if (!is_opened) {
      std::string errmsg = dlib->errmsg_.c_str();
      dlib->Close();
#ifdef _WIN32
      // Windows needs to add the filename into the error message
      errmsg += *filename;
#endif  // _WIN32
      THROW_ERR_DLOPEN_FAILED(env, ""%s"", errmsg.c_str());
      return false;
    }

    if (mp != nullptr) {
      if (mp->nm_context_register_func == nullptr) {
        if (env->force_context_aware()) {
          dlib->Close();
          THROW_ERR_NON_CONTEXT_AWARE_DISABLED(env);
          return false;
        }
      }
      mp->nm_dso_handle = dlib->...",39,3,node_binding.cc,node.binding.DLOpen.<lambda>0,,false,456,554,<lambda>0,,,1,ANY node.binding.DLOpen.<lambda>0 (DLib*)
138022,METHOD,node_binding.cc:<global>,TYPE_DECL,<global>,1,30,node_binding.hpp,node_binding.cc:<global>,,false,1,708,<global>,,,1,
138024,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_async_wrap,,false,100,100,_register_async_wrap,,,1,void _register_async_wrap ()
138028,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_blob,,false,100,100,_register_blob,,,2,void _register_blob ()
138032,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_block_list,,false,100,100,_register_block_list,,,3,void _register_block_list ()
138036,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_buffer,,false,100,100,_register_buffer,,,4,void _register_buffer ()
138040,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_builtins,,false,100,100,_register_builtins,,,5,void _register_builtins ()
138044,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_cares_wrap,,false,100,100,_register_cares_wrap,,,6,void _register_cares_wrap ()
138048,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_config,,false,100,100,_register_config,,,7,void _register_config ()
138052,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_constants,,false,100,100,_register_constants,,,8,void _register_constants ()
138056,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_contextify,,false,100,100,_register_contextify,,,9,void _register_contextify ()
138060,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_credentials,,false,100,100,_register_credentials,,,10,void _register_credentials ()
138064,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_encoding_binding,,false,100,100,_register_encoding_binding,,,11,void _register_encoding_binding ()
138068,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_errors,,false,100,100,_register_errors,,,12,void _register_errors ()
138072,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_fs,,false,100,100,_register_fs,,,13,void _register_fs ()
138076,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_fs_dir,,false,100,100,_register_fs_dir,,,14,void _register_fs_dir ()
138080,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_fs_event_wrap,,false,100,100,_register_fs_event_wrap,,,15,void _register_fs_event_wrap ()
138084,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_heap_utils,,false,100,100,_register_heap_utils,,,16,void _register_heap_utils ()
138088,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_http2,,false,100,100,_register_http2,,,17,void _register_http2 ()
138092,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_http_parser,,false,100,100,_register_http_parser,,,18,void _register_http_parser ()
138096,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_inspector,,false,100,100,_register_inspector,,,19,void _register_inspector ()
138100,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_js_stream,,false,100,100,_register_js_stream,,,20,void _register_js_stream ()
138104,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_js_udp_wrap,,false,100,100,_register_js_udp_wrap,,,21,void _register_js_udp_wrap ()
138108,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_messaging,,false,100,100,_register_messaging,,,22,void _register_messaging ()
138112,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_module_wrap,,false,100,100,_register_module_wrap,,,23,void _register_module_wrap ()
138116,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_mksnapshot,,false,100,100,_register_mksnapshot,,,24,void _register_mksnapshot ()
138120,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_options,,false,100,100,_register_options,,,25,void _register_options ()
138124,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_os,,false,100,100,_register_os,,,26,void _register_os ()
138128,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_performance,,false,100,100,_register_performance,,,27,void _register_performance ()
138132,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_permission,,false,100,100,_register_permission,,,28,void _register_permission ()
138136,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_pipe_wrap,,false,100,100,_register_pipe_wrap,,,29,void _register_pipe_wrap ()
138140,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_process_wrap,,false,100,100,_register_process_wrap,,,30,void _register_process_wrap ()
138144,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_process_methods,,false,100,100,_register_process_methods,,,31,void _register_process_methods ()
138148,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_report,,false,100,100,_register_report,,,32,void _register_report ()
138152,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_sea,,false,100,100,_register_sea,,,33,void _register_sea ()
138156,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_serdes,,false,100,100,_register_serdes,,,34,void _register_serdes ()
138160,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_signal_wrap,,false,100,100,_register_signal_wrap,,,35,void _register_signal_wrap ()
138164,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_spawn_sync,,false,100,100,_register_spawn_sync,,,36,void _register_spawn_sync ()
138168,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_stream_pipe,,false,100,100,_register_stream_pipe,,,37,void _register_stream_pipe ()
138172,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_stream_wrap,,false,100,100,_register_stream_wrap,,,38,void _register_stream_wrap ()
138176,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_string_decoder,,false,100,100,_register_string_decoder,,,39,void _register_string_decoder ()
138180,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_symbols,,false,100,100,_register_symbols,,,40,void _register_symbols ()
138184,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_task_queue,,false,100,100,_register_task_queue,,,41,void _register_task_queue ()
138188,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_tcp_wrap,,false,100,100,_register_tcp_wrap,,,42,void _register_tcp_wrap ()
138192,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_timers,,false,100,100,_register_timers,,,43,void _register_timers ()
138196,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_trace_events,,false,100,100,_register_trace_events,,,44,void _register_trace_events ()
138200,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_tty_wrap,,false,100,100,_register_tty_wrap,,,45,void _register_tty_wrap ()
138204,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_types,,false,100,100,_register_types,,,46,void _register_types ()
138208,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_udp_wrap,,false,100,100,_register_udp_wrap,,,47,void _register_udp_wrap ()
138212,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_url,,false,100,100,_register_url,,,48,void _register_url ()
138216,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_util,,false,100,100,_register_util,,,49,void _register_util ()
138220,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_uv,,false,100,100,_register_uv,,,50,void _register_uv ()
138224,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_v8,,false,100,100,_register_v8,,,51,void _register_v8 ()
138228,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_wasi,,false,100,100,_register_wasi,,,52,void _register_wasi ()
138232,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_wasm_web_api,,false,100,100,_register_wasm_web_api,,,53,void _register_wasm_web_api ()
138236,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_watchdog,,false,100,100,_register_watchdog,,,54,void _register_watchdog ()
138240,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_worker,,false,100,100,_register_worker,,,55,void _register_worker ()
138244,METHOD,node_binding.cc:<global>,TYPE_DECL,void void ();,1,24,node_binding.cc,_register_zlib,,false,100,100,_register_zlib,,,56,void _register_zlib ()
138259,METHOD,node_binding.cc:<global>,TYPE_DECL,"void node_module_register(void* m) {
  struct node_module* mp = reinterpret_cast<struct node_module*>(m);

  if (mp->nm_flags & NM_F_INTERNAL) {
    mp->nm_link = modlist_internal;
    modlist_internal = mp;
  } else if (!node_is_initialized) {
    // ""Linked"" modules are included as part of the node project.
    // Like builtins they are registered *before* node::Init runs.
    mp->nm_flags = NM_F_LINKED;
    mp->nm_link = modlist_linked;
    modlist_linked = mp;
  } else {
    thread_local_modpending = mp;
  }
}",12,1,node_binding.cc,node.node_module_register,,false,255,270,node_module_register,,,6,void node.node_module_register (void*)
138311,METHOD,node.binding.global_handle_map_t,TYPE_DECL,"void set(void* handle, node_module* mod) {
    CHECK_NE(handle, nullptr);
    Mutex::ScopedLock lock(mutex_);

    map_[handle].module = mod;
    // We need to store this flag internally to avoid a chicken-and-egg problem
    // during cleanup. By the time we actually use the flag's value,
    // the shared object has been unloaded, and its memory would be gone,
    // making it impossible to access fields of `mod` --
    // unless `mod` *is* dynamically allocated, but we cannot know that
    // without checking the flag.
    map_[handle].wants_delete_module = mod->nm_flags & NM_F_DELETEME;
    map_[handle].refcount++;
  }",3,3,node_binding.cc,node.binding.global_handle_map_t.set,,false,276,289,set,,,1,"void node.binding.global_handle_map_t.set (void*,node_module*)"
138347,METHOD,node.binding.global_handle_map_t,TYPE_DECL,"node_module* get_and_increase_refcount(void* handle) {
    CHECK_NE(handle, nullptr);
    Mutex::ScopedLock lock(mutex_);

    auto it = map_.find(handle);
    if (it == map_.end()) return nullptr;
    it->second.refcount++;
    return it->second.module;
  }",3,3,node_binding.cc,node.binding.global_handle_map_t.get_and_increase_refcount,,false,291,299,get_and_increase_refcount,,,2,node_module node.binding.global_handle_map_t.get_and_increase_refcount (void*)
138388,METHOD,node.binding.global_handle_map_t,TYPE_DECL,"void erase(void* handle) {
    CHECK_NE(handle, nullptr);
    Mutex::ScopedLock lock(mutex_);

    auto it = map_.find(handle);
    if (it == map_.end()) return;
    CHECK_GE(it->second.refcount, 1);
    if (--it->second.refcount == 0) {
      if (it->second.wants_delete_module)
        delete it->second.module;
      map_.erase(handle);
    }
  }",3,3,node_binding.cc,node.binding.global_handle_map_t.erase,,false,301,313,erase,,,3,void node.binding.global_handle_map_t.erase (void*)
138458,METHOD,node_binding.cc:<global>,TYPE_DECL,"DLib::DLib(const char* filename, int flags)
    : filename_(filename), flags_(flags), handle_(nullptr) {}",1,61,node_binding.cc,node.binding.DLib.DLib,,false,325,326,DLib,,,3,"ANY node.binding.DLib.DLib (char*,int)"
138464,METHOD,node_binding.cc:<global>,TYPE_DECL,"bool DLib::Open() {
  int ret = uv_dlopen(filename_.c_str(), &lib_);
  if (ret == 0) {
    handle_ = static_cast<void*>(lib_.handle);
    return true;
  }
  errmsg_ = uv_dlerror(&lib_);
  uv_dlclose(&lib_);
  return false;
}",1,1,node_binding.cc,node.binding.DLib.Open,,false,360,369,Open,,,4,bool node.binding.DLib.Open ()
138500,METHOD,node_binding.cc:<global>,TYPE_DECL,"void DLib::Close() {
  if (handle_ == nullptr) return;
  if (has_entry_in_global_handle_map_)
    global_handle_map.erase(handle_);
  uv_dlclose(&lib_);
  handle_ = nullptr;
}",1,1,node_binding.cc,node.binding.DLib.Close,,false,371,377,Close,,,5,void node.binding.DLib.Close ()
138522,METHOD,node_binding.cc:<global>,TYPE_DECL,"void* DLib::GetSymbolAddress(const char* name) {
  void* address;
  if (0 == uv_dlsym(&lib_, name, &address)) return address;
  return nullptr;
}",1,1,node_binding.cc,node.binding.DLib.GetSymbolAddress,,false,379,383,GetSymbolAddress,,,6,void* node.binding.DLib.GetSymbolAddress (char*)
138542,METHOD,node_binding.cc:<global>,TYPE_DECL,"void DLib::SaveInGlobalHandleMap(node_module* mp) {
  has_entry_in_global_handle_map_ = true;
  global_handle_map.set(handle_, mp);
}",1,1,node_binding.cc,node.binding.DLib.SaveInGlobalHandleMap,,false,386,389,SaveInGlobalHandleMap,,,7,void node.binding.DLib.SaveInGlobalHandleMap (node_module*)
138556,METHOD,node_binding.cc:<global>,TYPE_DECL,"node_module* DLib::GetSavedModuleFromGlobalHandleMap() {
  has_entry_in_global_handle_map_ = true;
  return global_handle_map.get_and_increase_refcount(handle_);
}",1,1,node_binding.cc,node.binding.DLib.GetSavedModuleFromGlobalHandleMap,,false,391,394,GetSavedModuleFromGlobalHandleMap,,,8,node_module node.binding.DLib.GetSavedModuleFromGlobalHandleMap ()
138570,METHOD,node_binding.cc:<global>,TYPE_DECL,"inline InitializerCallback GetInitializerCallback(DLib* dlib) {
  const char* name = ""node_register_module_v"" STRINGIFY(NODE_MODULE_VERSION);
  return reinterpret_cast<InitializerCallback>(dlib->GetSymbolAddress(name));
}",1,1,node_binding.cc,node.binding.GetInitializerCallback,,false,400,403,GetInitializerCallback,,,10,InitializerCallback node.binding.GetInitializerCallback (DLib*)
138589,METHOD,node_binding.cc:<global>,TYPE_DECL,"inline napi_addon_register_func GetNapiInitializerCallback(DLib* dlib) {
  const char* name =
      STRINGIFY(NAPI_MODULE_INITIALIZER_BASE) STRINGIFY(NAPI_MODULE_VERSION);
  return reinterpret_cast<napi_addon_register_func>(
      dlib->GetSymbolAddress(name));
}",1,1,node_binding.cc,node.binding.GetNapiInitializerCallback,,false,405,410,GetNapiInitializerCallback,,,11,napi_addon_register_func node.binding.GetNapiInitializerCallback (DLib*)
138609,METHOD,node_binding.cc:<global>,TYPE_DECL,"inline node_api_addon_get_api_version_func GetNapiAddonGetApiVersionCallback(
    DLib* dlib) {
  return reinterpret_cast<node_api_addon_get_api_version_func>(
      dlib->GetSymbolAddress(STRINGIFY(NODE_API_MODULE_GET_API_VERSION)));
}",1,1,node_binding.cc,node.binding.GetNapiAddonGetApiVersionCallback,,false,412,416,GetNapiAddonGetApiVersionCallback,,,12,node_api_addon_get_api_version_func node.binding.GetNapiAddonGetApiVersionCallback (DLib*)
138623,METHOD,node_binding.cc:<global>,TYPE_DECL,"void DLOpen(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  if (env->no_native_addons()) {
    return THROW_ERR_DLOPEN_DISABLED(
      env, ""Cannot load native addon because loading addons is disabled."");
  }

  auto context = env->context();

  CHECK_NULL(thread_local_modpending);

  if (args.Length() < 2) {
    return THROW_ERR_MISSING_ARGS(
        env, ""process.dlopen needs at least 2 arguments"");
  }

  int32_t flags = DLib::kDefaultFlags;
  if (args.Length() > 2 && !args[2]->Int32Value(context).To(&flags)) {
    return THROW_ERR_INVALID_ARG_TYPE(env, ""flag argument must be an integer."");
  }

  Local<Object> module;
  Local<Object> exports;
  Local<Value> exports_v;
  if (!args[0]->ToObject(context).ToLocal(&module) ||
      !module->Get(context, env->exports_string()).ToLocal(&exports_v) ||
      !exports_v->ToObject(context).ToLocal(&exports)) {
    return;  // Exception pending.
  }

  node::Utf8Value filename(env->isolate()...",1,1,node_binding.cc,node.binding.DLOpen,,false,424,558,DLOpen,,,13,void node.binding.DLOpen (FunctionCallbackInfo<Value>)
138772,METHOD,node_binding.cc:<global>,TYPE_DECL,"inline struct node_module* FindModule(struct node_module* list,
                                      const char* name,
                                      int flag) {
  struct node_module* mp;

  for (mp = list; mp != nullptr; mp = mp->nm_link) {
    if (strcmp(mp->nm_modname, name) == 0) break;
  }

  CHECK(mp == nullptr || (mp->nm_flags & flag) != 0);
  return mp;
}",1,1,node_binding.cc,node.binding.FindModule,,false,560,571,FindModule,,,14,"struct node_module node.binding.FindModule (node_module*,char*,int)"
138818,METHOD,node_binding.cc:<global>,TYPE_DECL,"void CreateInternalBindingTemplates(IsolateData* isolate_data) {
#define V(modname)                                                             \
  do {                                                                         \
    Local<ObjectTemplate> templ =                                              \
        ObjectTemplate::New(isolate_data->isolate());                          \
    templ->SetInternalFieldCount(BaseObject::kInternalFieldCount);             \
    _register_isolate_##modname(isolate_data, templ);                          \
    isolate_data->set_##modname##_binding_template(templ);                     \
  } while (0);
  NODE_BINDINGS_WITH_PER_ISOLATE_INIT(V)
#undef V
}",1,1,node_binding.cc,node.binding.CreateInternalBindingTemplates,,false,573,584,CreateInternalBindingTemplates,,,15,void node.binding.CreateInternalBindingTemplates (IsolateData*)
138825,METHOD,node_binding.cc:<global>,TYPE_DECL,"static Local<Object> GetInternalBindingExportObject(IsolateData* isolate_data,
                                                    const char* mod_name,
                                                    Local<Context> context) {
  Local<ObjectTemplate> templ;

#define V(name)                                                                \
  if (strcmp(mod_name, #name) == 0) {                                          \
    templ = isolate_data->name##_binding_template();                           \
  } else  // NOLINT(readability/braces)
  NODE_BINDINGS_WITH_PER_ISOLATE_INIT(V)
#undef V
  {
    // Default template.
    templ = isolate_data->binding_data_default_template();
  }

  Local<Object> obj = templ->NewInstance(context).ToLocalChecked();
  return obj;
}",1,1,node_binding.cc,node.binding.GetInternalBindingExportObject,,false,586,604,GetInternalBindingExportObject,,,16,"Local<Object> node.binding.GetInternalBindingExportObject (IsolateData*,char*,Local<Context>)"
138863,METHOD,node_binding.cc:<global>,TYPE_DECL,"static Local<Object> InitInternalBinding(Realm* realm, node_module* mod) {
  EscapableHandleScope scope(realm->isolate());
  Local<Context> context = realm->context();
  Local<Object> exports = GetInternalBindingExportObject(
      realm->isolate_data(), mod->nm_modname, context);
  CHECK_NULL(mod->nm_register_func);
  CHECK_NOT_NULL(mod->nm_context_register_func);
  Local<Value> unused = Undefined(realm->isolate());
  // Internal bindings don't have a ""module"" object, only exports.
  mod->nm_context_register_func(exports, unused, context, mod->nm_priv);
  return scope.Escape(exports);
}",1,1,node_binding.cc,node.binding.InitInternalBinding,,false,606,617,InitInternalBinding,,,17,"Local<Object> node.binding.InitInternalBinding (Realm*,node_module*)"
138935,METHOD,node_binding.cc:<global>,TYPE_DECL,"void GetInternalBinding(const FunctionCallbackInfo<Value>& args) {
  Realm* realm = Realm::GetCurrent(args);
  Isolate* isolate = realm->isolate();
  HandleScope scope(isolate);

  CHECK(args[0]->IsString());

  Local<String> module = args[0].As<String>();
  node::Utf8Value module_v(isolate, module);
  Local<Object> exports;

  node_module* mod = FindModule(modlist_internal, *module_v, NM_F_INTERNAL);
  if (mod != nullptr) {
    exports = InitInternalBinding(realm, mod);
    realm->internal_bindings.insert(mod);
  } else {
    return THROW_ERR_INVALID_MODULE(isolate, ""No such binding: %s"", *module_v);
  }

  args.GetReturnValue().Set(exports);
}",1,1,node_binding.cc,node.binding.GetInternalBinding,,false,619,639,GetInternalBinding,,,18,void node.binding.GetInternalBinding (FunctionCallbackInfo<Value>)
139027,METHOD,node_binding.cc:<global>,TYPE_DECL,"void GetLinkedBinding(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsString());

  Local<String> module_name = args[0].As<String>();

  node::Utf8Value module_name_v(env->isolate(), module_name);
  const char* name = *module_name_v;
  node_module* mod = nullptr;

  // Iterate from here to the nearest non-Worker Environment to see if there's
  // a linked binding defined locally rather than through the global list.
  Environment* cur_env = env;
  while (mod == nullptr && cur_env != nullptr) {
    Mutex::ScopedLock lock(cur_env->extra_linked_bindings_mutex());
    mod = FindModule(cur_env->extra_linked_bindings_head(), name, NM_F_LINKED);
    cur_env = cur_env->worker_parent_env();
  }

  if (mod == nullptr)
    mod = FindModule(modlist_linked, name, NM_F_LINKED);

  if (mod == nullptr) {
    return THROW_ERR_INVALID_MODULE(
        env, ""No such binding was linked: %s"", *module_name_v);
  }

  Local<Object> module = ...",1,1,node_binding.cc,node.binding.GetLinkedBinding,,false,641,689,GetLinkedBinding,,,19,void node.binding.GetLinkedBinding (FunctionCallbackInfo<Value>)
139254,METHOD,node_binding.cc:<global>,TYPE_DECL,"void RegisterBuiltinBindings() {
#define V(modname) _register_##modname();
  NODE_BUILTIN_BINDINGS(V)
#undef V
}",1,2,node_binding.cc,node.binding.RegisterBuiltinBindings,,false,693,697,RegisterBuiltinBindings,,,20,void node.binding.RegisterBuiltinBindings ()
139320,METHOD,node_binding.cc:<global>,TYPE_DECL,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(GetLinkedBinding);
  registry->Register(GetInternalBinding);
}",1,1,node_binding.cc,node.binding.RegisterExternalReferences,,false,699,702,RegisterExternalReferences,,,21,void node.binding.RegisterExternalReferences (ExternalReferenceRegistry*)
139347,METHOD,node_binding.hpp:<global>,TYPE_DECL,<global>,1,30,node_binding.hpp,node_binding.hpp:<global>,,false,1,142,<global>,,,1,
139350,METHOD,node_blob.cc:<global>,TYPE_DECL,"[env](v8::Local<v8::ArrayBuffer> buf,
                                            size_t byte_length,
                                            size_t byte_offset = 0) {
      if (buf->IsDetachable()) {
        std::shared_ptr<BackingStore> store = buf->GetBackingStore();
        USE(buf->Detach(Local<Value>()));
        return DataQueue::CreateInMemoryEntryFromBackingStore(
            store, byte_offset, byte_length);
      }

      // If the ArrayBuffer is not detachable, we will copy from it instead.
      std::shared_ptr<BackingStore> store =
          ArrayBuffer::NewBackingStore(env->isolate(), byte_length);
      uint8_t* ptr = static_cast<uint8_t*>(buf->Data()) + byte_offset;
      std::copy(ptr, ptr + byte_length, static_cast<uint8_t*>(store->Data()));
      return DataQueue::CreateInMemoryEntryFromBackingStore(
          store, 0, byte_length);
    }",39,5,node_blob.cc,node.Blob.New.<lambda>0,,false,184,201,<lambda>0,,,1,"ANY node.Blob.New.<lambda>0 (ANY,size_t,size_t)"
139442,METHOD,node_blob.cc:<global>,TYPE_DECL,"[impl](int status,
                     const DataQueue::Vec* vecs,
                     size_t count,
                     bob::Done doneCb) mutable {
    auto dropMe = std::unique_ptr<Impl>(impl);
    Environment* env = impl->env;
    HandleScope handleScope(env->isolate());
    Local<Function> fn = impl->callback.Get(env->isolate());

    if (status == bob::STATUS_EOS) impl->reader->eos_ = true;

    if (count > 0) {
      // Copy the returns vectors into a single ArrayBuffer.
      size_t total = 0;
      for (size_t n = 0; n < count; n++) total += vecs[n].len;

      std::shared_ptr<BackingStore> store =
          v8::ArrayBuffer::NewBackingStore(env->isolate(), total);
      auto ptr = static_cast<uint8_t*>(store->Data());
      for (size_t n = 0; n < count; n++) {
        std::copy(vecs[n].base, vecs[n].base + vecs[n].len, ptr);
        ptr += vecs[n].len;
      }
      // Since we copied the data buffers, signal that we're done with them.
      std::move(doneCb)(0);
      Lo...",15,3,node_blob.cc,node.Blob.Reader.Pull.<lambda>1,,false,340,376,<lambda>1,,,1,"ANY node.Blob.Reader.Pull.<lambda>1 (int,ANY*,size_t,ANY)"
139672,METHOD,node_blob.cc:<global>,TYPE_DECL,<global>,1,27,node_blob.hpp,node_blob.cc:<global>,,false,1,575,<global>,,,1,
139676,METHOD,node_blob.cc:<global>,TYPE_DECL,"void Concat(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsArray());
  Local<Array> array = args[0].As<Array>();

  struct View {
    std::shared_ptr<BackingStore> store;
    size_t length;
    size_t offset = 0;
  };

  std::vector<View> views;
  size_t total = 0;

  for (uint32_t n = 0; n < array->Length(); n++) {
    Local<Value> val;
    if (!array->Get(env->context(), n).ToLocal(&val)) return;
    if (val->IsArrayBuffer()) {
      auto ab = val.As<ArrayBuffer>();
      views.push_back(View{ab->GetBackingStore(), ab->ByteLength(), 0});
      total += ab->ByteLength();
    } else {
      CHECK(val->IsArrayBufferView());
      auto view = val.As<ArrayBufferView>();
      views.push_back(View{view->Buffer()->GetBackingStore(),
                           view->ByteLength(),
                           view->ByteOffset()});
      total += view->ByteLength();
    }
  }

  std::shared_ptr<BackingStore> store =
      Arra...",1,1,node_blob.cc,node.anonymous_namespace_1.Concat,,false,43,85,Concat,,,1,void node.anonymous_namespace_1.Concat (FunctionCallbackInfo<Value>)
139926,METHOD,node_blob.cc:<global>,TYPE_DECL,"void BlobFromFilePath(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, path.ToStringView());
  auto entry = DataQueue::CreateFdEntry(env, args[0]);
  if (entry == nullptr) {
    return THROW_ERR_INVALID_ARG_VALUE(env, ""Unabled to open file as blob"");
  }

  std::vector<std::unique_ptr<DataQueue::Entry>> entries;
  entries.push_back(std::move(entry));

  auto blob =
      Blob::Create(env, DataQueue::CreateIdempotent(std::move(entries)));

  if (blob) {
    auto array = Array::New(env->isolate(), 2);
    USE(array->Set(env->context(), 0, blob->object()));
    USE(array->Set(env->context(),
                   1,
                   Uint32::NewFromUnsigned(env->isolate(), blob->length())));

    args.GetReturnValue().Set(array);
  }
}",1,1,node_blob.cc,node.anonymous_namespace_2.BlobFromFilePath,,false,87,113,BlobFromFilePath,,,2,void node.anonymous_namespace_2.BlobFromFilePath (FunctionCallbackInfo<Value>)
140080,METHOD,node_blob.cc:<global>,TYPE_DECL,"void Blob::CreatePerIsolateProperties(IsolateData* isolate_data,
                                      Local<ObjectTemplate> target) {
  Isolate* isolate = isolate_data->isolate();

  SetMethod(isolate, target, ""createBlob"", New);
  SetMethod(isolate, target, ""storeDataObject"", StoreDataObject);
  SetMethod(isolate, target, ""getDataObject"", GetDataObject);
  SetMethod(isolate, target, ""revokeObjectURL"", RevokeObjectURL);
  SetMethod(isolate, target, ""concat"", Concat);
  SetMethod(isolate, target, ""createBlobFromFilePath"", BlobFromFilePath);
}",1,1,node_blob.cc,node.Blob.CreatePerIsolateProperties,,false,116,126,CreatePerIsolateProperties,,,2,"void node.Blob.CreatePerIsolateProperties (IsolateData*,Local<ObjectTemplate>)"
140123,METHOD,node_blob.cc:<global>,TYPE_DECL,"void Blob::CreatePerContextProperties(Local<Object> target,
                                      Local<Value> unused,
                                      Local<Context> context,
                                      void* priv) {
  Realm* realm = Realm::GetCurrent(context);
  realm->AddBindingData<BlobBindingData>(context, target);
}",1,1,node_blob.cc,node.Blob.CreatePerContextProperties,,false,128,134,CreatePerContextProperties,,,3,"void node.Blob.CreatePerContextProperties (Local<Object>,Local<Value>,Local<Context>,void*)"
140149,METHOD,node_blob.cc:<global>,TYPE_DECL,"Local<FunctionTemplate> Blob::GetConstructorTemplate(Environment* env) {
  Local<FunctionTemplate> tmpl = env->blob_constructor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        BaseObject::kInternalFieldCount);
    tmpl->SetClassName(
        FIXED_ONE_BYTE_STRING(env->isolate(), ""Blob""));
    SetProtoMethod(isolate, tmpl, ""getReader"", GetReader);
    SetProtoMethod(isolate, tmpl, ""slice"", ToSlice);
    env->set_blob_constructor_template(tmpl);
  }
  return tmpl;
}",1,1,node_blob.cc,node.Blob.GetConstructorTemplate,,false,136,150,GetConstructorTemplate,,,4,Local<FunctionTemplate> node.Blob.GetConstructorTemplate (Environment*)
140219,METHOD,node_blob.cc:<global>,TYPE_DECL,"bool Blob::HasInstance(Environment* env, v8::Local<v8::Value> object) {
  return GetConstructorTemplate(env)->HasInstance(object);
}",1,1,node_blob.cc,node.Blob.HasInstance,,false,152,154,HasInstance,,,5,"bool node.Blob.HasInstance (Environment*,ANY)"
140232,METHOD,node_blob.cc:<global>,TYPE_DECL,"BaseObjectPtr<Blob> Blob::Create(Environment* env,
                                 std::shared_ptr<DataQueue> data_queue) {
  HandleScope scope(env->isolate());

  Local<Function> ctor;
  if (!GetConstructorTemplate(env)->GetFunction(env->context()).ToLocal(&ctor))
    return BaseObjectPtr<Blob>();

  Local<Object> obj;
  if (!ctor->NewInstance(env->context()).ToLocal(&obj))
    return BaseObjectPtr<Blob>();

  return MakeBaseObject<Blob>(env, obj, data_queue);
}",1,1,node_blob.cc,node.Blob.Create,,false,156,169,Create,,,6,"BaseObjectPtr<Blob> node.Blob.Create (Environment*,ANY)"
140301,METHOD,node_blob.cc:<global>,TYPE_DECL,"void Blob::New(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsArray());  // sources

  Local<Array> array = args[0].As<Array>();
  std::vector<std::unique_ptr<DataQueue::Entry>> entries(array->Length());

  for (size_t i = 0; i < array->Length(); i++) {
    Local<Value> entry;
    if (!array->Get(env->context(), i).ToLocal(&entry)) {
      return;
    }

    const auto entryFromArrayBuffer = [env](v8::Local<v8::ArrayBuffer> buf,
                                            size_t byte_length,
                                            size_t byte_offset = 0) {
      if (buf->IsDetachable()) {
        std::shared_ptr<BackingStore> store = buf->GetBackingStore();
        USE(buf->Detach(Local<Value>()));
        return DataQueue::CreateInMemoryEntryFromBackingStore(
            store, byte_offset, byte_length);
      }

      // If the ArrayBuffer is not detachable, we will copy from it instead.
      std::shared_ptr<B...",1,1,node_blob.cc,node.Blob.New,,false,171,231,New,,,7,void node.Blob.New (FunctionCallbackInfo<Value>)
140510,METHOD,node_blob.cc:<global>,TYPE_DECL,"void Blob::GetReader(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Blob* blob;
  ASSIGN_OR_RETURN_UNWRAP(&blob, args.Holder());

  BaseObjectPtr<Blob::Reader> reader =
      Blob::Reader::Create(env, BaseObjectPtr<Blob>(blob));
  if (reader) args.GetReturnValue().Set(reader->object());
}",1,1,node_blob.cc,node.Blob.GetReader,,false,233,241,GetReader,,,8,void node.Blob.GetReader (FunctionCallbackInfo<Value>)
140565,METHOD,node_blob.cc:<global>,TYPE_DECL,"void Blob::ToSlice(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Blob* blob;
  ASSIGN_OR_RETURN_UNWRAP(&blob, args.Holder());
  CHECK(args[0]->IsUint32());
  CHECK(args[1]->IsUint32());
  size_t start = args[0].As<Uint32>()->Value();
  size_t end = args[1].As<Uint32>()->Value();
  BaseObjectPtr<Blob> slice = blob->Slice(env, start, end);
  if (slice)
    args.GetReturnValue().Set(slice->object());
}",1,1,node_blob.cc,node.Blob.ToSlice,,false,243,254,ToSlice,,,9,void node.Blob.ToSlice (FunctionCallbackInfo<Value>)
140651,METHOD,node_blob.cc:<global>,TYPE_DECL,"void Blob::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""data_queue_"", data_queue_, ""std::shared_ptr<DataQueue>"");
}",1,1,node_blob.cc,node.Blob.MemoryInfo,,false,256,258,MemoryInfo,,,10,void node.Blob.MemoryInfo (MemoryTracker*)
140663,METHOD,node_blob.cc:<global>,TYPE_DECL,"BaseObjectPtr<Blob> Blob::Slice(Environment* env, size_t start, size_t end) {
  return Create(env,
                this->data_queue_->slice(start, static_cast<uint64_t>(end)));
}",1,1,node_blob.cc,node.Blob.Slice,,false,260,263,Slice,,,11,"BaseObjectPtr<Blob> node.Blob.Slice (Environment*,size_t,size_t)"
140683,METHOD,node_blob.cc:<global>,TYPE_DECL,"Blob::Blob(Environment* env,
           v8::Local<v8::Object> obj,
           std::shared_ptr<DataQueue> data_queue)
    : BaseObject(env, obj), data_queue_(data_queue) {
  MakeWeak();
}",1,1,node_blob.cc,node.Blob.Blob,,false,265,270,Blob,,,12,"ANY node.Blob.Blob (Environment*,ANY,ANY)"
140691,METHOD,node_blob.cc:<global>,TYPE_DECL,"Blob::Reader::Reader(Environment* env,
                     v8::Local<v8::Object> obj,
                     BaseObjectPtr<Blob> strong_ptr)
    : AsyncWrap(env, obj, AsyncWrap::PROVIDER_BLOBREADER),
      inner_(strong_ptr->data_queue_->get_reader()),
      strong_ptr_(std::move(strong_ptr)) {
  MakeWeak();
}",1,1,node_blob.cc,node.Blob.Reader.Reader,,false,272,279,Reader,,,13,"ANY node.Blob.Reader.Reader (Environment*,ANY,BaseObjectPtr<Blob>)"
140699,METHOD,node_blob.cc:<global>,TYPE_DECL,"bool Blob::Reader::HasInstance(Environment* env, v8::Local<v8::Value> value) {
  return GetConstructorTemplate(env)->HasInstance(value);
}",1,1,node_blob.cc,node.Blob.Reader.HasInstance,,false,281,283,HasInstance,,,14,"bool node.Blob.Reader.HasInstance (Environment*,ANY)"
140712,METHOD,node_blob.cc:<global>,TYPE_DECL,"Local<FunctionTemplate> Blob::Reader::GetConstructorTemplate(Environment* env) {
  Local<FunctionTemplate> tmpl = env->blob_reader_constructor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        BaseObject::kInternalFieldCount);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), ""BlobReader""));
    SetProtoMethod(env->isolate(), tmpl, ""pull"", Pull);
    env->set_blob_reader_constructor_template(tmpl);
  }
  return tmpl;
}",1,1,node_blob.cc,node.Blob.Reader.GetConstructorTemplate,,false,285,297,GetConstructorTemplate,,,15,Local<FunctionTemplate> node.Blob.Reader.GetConstructorTemplate (Environment*)
140780,METHOD,node_blob.cc:<global>,TYPE_DECL,"BaseObjectPtr<Blob::Reader> Blob::Reader::Create(Environment* env,
                                                 BaseObjectPtr<Blob> blob) {
  Local<Object> obj;
  if (!GetConstructorTemplate(env)
           ->InstanceTemplate()
           ->NewInstance(env->context())
           .ToLocal(&obj)) {
    return BaseObjectPtr<Blob::Reader>();
  }

  return MakeBaseObject<Blob::Reader>(env, obj, std::move(blob));
}",1,1,node_blob.cc,node.Blob.Reader.Create,,false,299,310,Create,,,16,"BaseObjectPtr<Blob::Reader> node.Blob.Reader.Create (Environment*,BaseObjectPtr<Blob>)"
140830,METHOD,node_blob.cc:<global>,TYPE_DECL,"void Blob::Reader::Pull(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Blob::Reader* reader;
  ASSIGN_OR_RETURN_UNWRAP(&reader, args.Holder());

  CHECK(args[0]->IsFunction());
  Local<Function> fn = args[0].As<Function>();
  CHECK(!fn->IsConstructor());

  if (reader->eos_) {
    Local<Value> arg = Int32::New(env->isolate(), bob::STATUS_EOS);
    reader->MakeCallback(fn, 1, &arg);
    return args.GetReturnValue().Set(bob::STATUS_EOS);
  }

  struct Impl {
    BaseObjectPtr<Blob::Reader> reader;
    Global<Function> callback;
    Environment* env;
  };
  // TODO(@jasnell): A unique_ptr is likely better here but making this a unique
  // pointer that is passed into the lambda causes the std::move(next) below to
  // complain about std::function needing to be copy-constructible.
  Impl* impl = new Impl();
  impl->reader = BaseObjectPtr<Blob::Reader>(reader);
  impl->callback.Reset(env->isolate(), fn);
  impl->env = env;

  auto next = ...",1,1,node_blob.cc,node.Blob.Reader.Pull,,false,312,380,Pull,,,17,void node.Blob.Reader.Pull (FunctionCallbackInfo<Value>)
140977,METHOD,node_blob.cc:<global>,TYPE_DECL,"BaseObjectPtr<BaseObject>
Blob::BlobTransferData::Deserialize(
    Environment* env,
    Local<Context> context,
    std::unique_ptr<worker::TransferData> self) {
  if (context != env->context()) {
    THROW_ERR_MESSAGE_TARGET_CONTEXT_UNAVAILABLE(env);
    return {};
  }
  return Blob::Create(env, data_queue);
}",1,1,node_blob.cc,node.Blob.BlobTransferData.Deserialize,,false,382,392,Deserialize,,,18,"BaseObjectPtr<BaseObject> node.Blob.BlobTransferData.Deserialize (Environment*,Local<Context>,ANY)"
141002,METHOD,node_blob.cc:<global>,TYPE_DECL,"BaseObject::TransferMode Blob::GetTransferMode() const {
  return BaseObject::TransferMode::kCloneable;
}",1,1,node_blob.cc,node.Blob.GetTransferMode,,false,394,396,GetTransferMode,,,19,TransferMode node.Blob.GetTransferMode ()
141012,METHOD,node_blob.cc:<global>,TYPE_DECL,"std::unique_ptr<worker::TransferData> Blob::CloneForMessaging() const {
  return std::make_unique<BlobTransferData>(data_queue_);
}",1,1,node_blob.cc,node.Blob.CloneForMessaging,,false,398,400,CloneForMessaging,,,20,unique_ptr<worker::TransferData> node.Blob.CloneForMessaging ()
141024,METHOD,node_blob.cc:<global>,TYPE_DECL,"void Blob::StoreDataObject(const v8::FunctionCallbackInfo<v8::Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  BlobBindingData* binding_data = Realm::GetBindingData<BlobBindingData>(args);

  CHECK(args[0]->IsString());  // ID key
  CHECK(Blob::HasInstance(env, args[1]));  // Blob
  CHECK(args[2]->IsUint32());  // Length
  CHECK(args[3]->IsString());  // Type

  Utf8Value key(env->isolate(), args[0]);
  Blob* blob;
  ASSIGN_OR_RETURN_UNWRAP(&blob, args[1]);

  size_t length = args[2].As<Uint32>()->Value();
  Utf8Value type(env->isolate(), args[3]);

  binding_data->store_data_object(
      std::string(*key, key.length()),
      BlobBindingData::StoredDataObject(
        BaseObjectPtr<Blob>(blob),
        length,
        std::string(*type, type.length())));
}",1,1,node_blob.cc,node.Blob.StoreDataObject,,false,402,424,StoreDataObject,,,21,void node.Blob.StoreDataObject (ANY)
141148,METHOD,node_blob.cc:<global>,TYPE_DECL,"void Blob::RevokeObjectURL(const FunctionCallbackInfo<Value>& args) {
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());
  BlobBindingData* binding_data = Realm::GetBindingData<BlobBindingData>(args);
  Environment* env = Environment::GetCurrent(args);
  Utf8Value input(env->isolate(), args[0].As<String>());
  auto out = ada::parse<ada::url_aggregator>(input.ToStringView());

  if (!out) {
    return;
  }

  auto pathname = out->get_pathname();
  auto start_index = pathname.find(':');

  if (start_index != std::string_view::npos && start_index != pathname.size()) {
    auto end_index = pathname.find(':', start_index + 1);
    if (end_index == std::string_view::npos) {
      auto id = std::string(pathname.substr(start_index + 1));
      binding_data->revoke_data_object(id);
    }
  }
}",1,1,node_blob.cc,node.Blob.RevokeObjectURL,,false,427,449,RevokeObjectURL,,,22,void node.Blob.RevokeObjectURL (FunctionCallbackInfo<Value>)
141286,METHOD,node_blob.cc:<global>,TYPE_DECL,"void Blob::GetDataObject(const v8::FunctionCallbackInfo<v8::Value>& args) {
  BlobBindingData* binding_data = Realm::GetBindingData<BlobBindingData>(args);

  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsString());

  Utf8Value key(env->isolate(), args[0]);

  BlobBindingData::StoredDataObject stored =
      binding_data->get_data_object(std::string(*key, key.length()));
  if (stored.blob) {
    Local<Value> type;
    if (!String::NewFromUtf8(
            env->isolate(),
            stored.type.c_str(),
            v8::NewStringType::kNormal,
            static_cast<int>(stored.type.length())).ToLocal(&type)) {
      return;
    }

    Local<Value> values[] = {
      stored.blob->object(),
      Uint32::NewFromUnsigned(env->isolate(), stored.length),
      type
    };

    args.GetReturnValue().Set(
        Array::New(
            env->isolate(),
            values,
            arraysize(values)));
  }
}",1,1,node_blob.cc,node.Blob.GetDataObject,,false,451,483,GetDataObject,,,23,void node.Blob.GetDataObject (ANY)
141428,METHOD,node_blob.cc:<global>,TYPE_DECL,"void BlobBindingData::StoredDataObject::MemoryInfo(
    MemoryTracker* tracker) const {
  tracker->TrackField(""blob"", blob, ""BaseObjectPtr<Blob>"");
}",1,1,node_blob.cc,node.BlobBindingData.StoredDataObject.MemoryInfo,,false,485,488,MemoryInfo,,,24,void node.BlobBindingData.StoredDataObject.MemoryInfo (MemoryTracker*)
141440,METHOD,node_blob.cc:<global>,TYPE_DECL,"BlobBindingData::StoredDataObject::StoredDataObject(
    const BaseObjectPtr<Blob>& blob_,
    size_t length_,
    const std::string& type_)
    : blob(blob_),
      length(length_),
      type(type_) {}",1,20,node_blob.cc,node.BlobBindingData.StoredDataObject.StoredDataObject,,false,490,496,StoredDataObject,,,25,"ANY node.BlobBindingData.StoredDataObject.StoredDataObject (BaseObjectPtr<Blob>,size_t,ANY)"
141447,METHOD,node_blob.cc:<global>,TYPE_DECL,"BlobBindingData::BlobBindingData(Realm* realm, Local<Object> wrap)
    : SnapshotableObject(realm, wrap, type_int) {
  MakeWeak();
}",1,1,node_blob.cc,node.BlobBindingData.BlobBindingData,,false,498,501,BlobBindingData,,,26,"ANY node.BlobBindingData.BlobBindingData (Realm*,Local<Object>)"
141454,METHOD,node_blob.cc:<global>,TYPE_DECL,"void BlobBindingData::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""data_objects_"",
                      data_objects_,
                      ""std::unordered_map<std::string, StoredDataObject>"");
}",1,1,node_blob.cc,node.BlobBindingData.MemoryInfo,,false,503,507,MemoryInfo,,,27,void node.BlobBindingData.MemoryInfo (MemoryTracker*)
141466,METHOD,node_blob.cc:<global>,TYPE_DECL,"void BlobBindingData::store_data_object(
    const std::string& uuid,
    const BlobBindingData::StoredDataObject& object) {
  data_objects_[uuid] = object;
}",1,1,node_blob.cc,node.BlobBindingData.store_data_object,,false,509,513,store_data_object,,,28,"void node.BlobBindingData.store_data_object (ANY,ANY)"
141477,METHOD,node_blob.cc:<global>,TYPE_DECL,"void BlobBindingData::revoke_data_object(const std::string& uuid) {
  if (data_objects_.find(uuid) == data_objects_.end()) {
    return;
  }
  data_objects_.erase(uuid);
  CHECK_EQ(data_objects_.find(uuid), data_objects_.end());
}",1,1,node_blob.cc,node.BlobBindingData.revoke_data_object,,false,515,521,revoke_data_object,,,29,void node.BlobBindingData.revoke_data_object (ANY)
141510,METHOD,node_blob.cc:<global>,TYPE_DECL,"BlobBindingData::StoredDataObject BlobBindingData::get_data_object(
    const std::string& uuid) {
  auto entry = data_objects_.find(uuid);
  if (entry == data_objects_.end())
    return BlobBindingData::StoredDataObject {};
  return entry->second;
}",1,1,node_blob.cc,node.BlobBindingData.get_data_object,,false,523,529,get_data_object,,,30,StoredDataObject node.BlobBindingData.get_data_object (ANY)
141538,METHOD,node_blob.cc:<global>,TYPE_DECL,"void BlobBindingData::Deserialize(Local<Context> context,
                                  Local<Object> holder,
                                  int index,
                                  InternalFieldInfoBase* info) {
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  HandleScope scope(context->GetIsolate());
  Realm* realm = Realm::GetCurrent(context);
  BlobBindingData* binding =
      realm->AddBindingData<BlobBindingData>(context, holder);
  CHECK_NOT_NULL(binding);
}",1,1,node_blob.cc,node.BlobBindingData.Deserialize,,false,531,541,Deserialize,,,31,"void node.BlobBindingData.Deserialize (Local<Context>,Local<Object>,int,InternalFieldInfoBase*)"
141580,METHOD,node_blob.cc:<global>,TYPE_DECL,"bool BlobBindingData::PrepareForSerialization(Local<Context> context,
                                              v8::SnapshotCreator* creator) {
  // Stored blob objects are not actually persisted.
  // Return true because we need to maintain the reference to the binding from
  // JS land.
  return true;
}",1,1,node_blob.cc,node.BlobBindingData.PrepareForSerialization,,false,543,549,PrepareForSerialization,,,32,"bool node.BlobBindingData.PrepareForSerialization (Local<Context>,ANY*)"
141588,METHOD,node_blob.cc:<global>,TYPE_DECL,"InternalFieldInfoBase* BlobBindingData::Serialize(int index) {
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info =
      InternalFieldInfoBase::New<InternalFieldInfo>(type());
  return info;
}",1,1,node_blob.cc,node.BlobBindingData.Serialize,,false,551,556,Serialize,,,33,InternalFieldInfoBase node.BlobBindingData.Serialize (int)
141610,METHOD,node_blob.cc:<global>,TYPE_DECL,"void Blob::RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(Blob::New);
  registry->Register(Blob::GetReader);
  registry->Register(Blob::ToSlice);
  registry->Register(Blob::StoreDataObject);
  registry->Register(Blob::GetDataObject);
  registry->Register(Blob::RevokeObjectURL);
  registry->Register(Blob::Reader::Pull);
  registry->Register(Concat);
  registry->Register(BlobFromFilePath);
}",1,1,node_blob.cc,node.Blob.RegisterExternalReferences,,false,558,568,RegisterExternalReferences,,,34,void node.Blob.RegisterExternalReferences (ExternalReferenceRegistry*)
141708,METHOD,node_blob.hpp:<global>,TYPE_DECL,<global>,1,27,node_blob.hpp,node_blob.hpp:<global>,,false,1,159,<global>,,,1,
141711,METHOD,node_bob-inl.hpp:<global>,TYPE_DECL,[](size_t len) {},41,57,node_bob-inl.hpp,node.bob.SourceImpl<T>.Pull.<lambda>0,,false,22,22,<lambda>0,,,1,ANY node.bob.SourceImpl<T>.Pull.<lambda>0 (size_t)
141723,METHOD,node_bob-inl.hpp:<global>,TYPE_DECL,<global>,1,1,node_bob-inl.hpp,node_bob-inl.hpp:<global>,,false,1,36,<global>,,,1,
141727,METHOD,node_bob-inl.hpp:<global>,TYPE_DECL,"int SourceImpl<T>::Pull(
    Next<T> next,
    int options,
    T* data,
    size_t count,
    size_t max_count_hint) {

  int status;
  if (eos_) {
    status = bob::Status::STATUS_EOS;
    std::move(next)(status, nullptr, 0, [](size_t len) {});
    return status;
  }

  status = DoPull(std::move(next), options, data, count, max_count_hint);

  if (status == bob::Status::STATUS_EOS) eos_ = true;

  return status;
}",1,1,node_bob-inl.hpp,node.bob.SourceImpl<T>.Pull,,false,12,31,Pull,,,1,"int node.bob.SourceImpl<T>.Pull<T> (Next<T>,int,T*,size_t,size_t)"
141790,METHOD,node_bob.hpp:<global>,TYPE_DECL,<global>,1,26,node_bob.hpp,node_bob.hpp:<global>,,false,1,107,<global>,,,1,
141803,METHOD,<empty>,<empty>,<empty>,1,,node_bob.hpp,node.bob.Status:<clinit>,,false,12,,<clinit>,,,5,
141823,METHOD,<empty>,<empty>,<empty>,1,,node_bob.hpp,node.bob.Options:<clinit>,,false,33,,<clinit>,,,4,
141839,METHOD,node.bob.Source,TYPE_DECL,virtual ~Source() = default;,3,30,node_bob.hpp,node.bob.Source.~Source,,false,70,70,~Source,,,1,ANY node.bob.Source.~Source ()
141843,METHOD,node.bob.Source,TYPE_DECL,"virtual int Pull(
      Next<T> next,
      int options,
      T* data,
      size_t count,
      size_t max_count_hint = kMaxCountHint) = 0;",15,48,node_bob.hpp,node.bob.Source.Pull,,false,71,76,Pull,,,2,"int node.bob.Source.Pull (Next<T>,int,T*,size_t,size_t)"
141853,METHOD,node.bob.SourceImpl,TYPE_DECL,"int Pull(
      Next<T> next,
      int options,
      T* data,
      size_t count,
      size_t max_count_hint = kMaxCountHint) override;",7,53,node_bob.hpp,node.bob.SourceImpl.Pull,,false,83,88,Pull,,,1,"int node.bob.SourceImpl.Pull (Next<T>,int,T*,size_t,size_t)"
141862,METHOD,node.bob.SourceImpl,TYPE_DECL,bool is_eos() const { return eos_; },3,38,node_bob.hpp,node.bob.SourceImpl.is_eos,,false,90,90,is_eos,,,2,bool node.bob.SourceImpl.is_eos ()
141868,METHOD,node.bob.SourceImpl,TYPE_DECL,"virtual int DoPull(
      Next<T> next,
      int options,
      T* data,
      size_t count,
      size_t max_count_hint) = 0;",15,32,node_bob.hpp,node.bob.SourceImpl.DoPull,,false,93,98,DoPull,,,3,"int node.bob.SourceImpl.DoPull (Next<T>,int,T*,size_t,size_t)"
141878,METHOD,<empty>,<empty>,<empty>,1,,node_bob.hpp,node.bob.SourceImpl:<clinit>,,false,81,,<clinit>,,,5,
141886,METHOD,node_buffer.cc:<global>,TYPE_DECL,"[](void*, size_t, void* arg) {
        static_cast<CallbackInfo*>(arg)->OnBackingStoreFree();
      }",50,7,node_buffer.cc,node.Buffer.anonymous_namespace_10.CallbackInfo.CreateTrackedArrayBuffer.<lambda>0,,false,122,124,<lambda>0,,,1,"ANY node.Buffer.anonymous_namespace_10.CallbackInfo.CreateTrackedArrayBuffer.<lambda>0 (void*,size_t,void*)"
141901,METHOD,node_buffer.cc:<global>,TYPE_DECL,"[self = std::move(self)](Environment* env) {
    CHECK_EQ(self->env_, env);  // Consistency check.

    self->CallAndResetCallback();
  }",32,3,node_buffer.cc,node.Buffer.anonymous_namespace_16.CallbackInfo.OnBackingStoreFree.<lambda>1,,false,198,202,<lambda>1,,,1,ANY node.Buffer.anonymous_namespace_16.CallbackInfo.OnBackingStoreFree.<lambda>1 (Environment*)
141917,METHOD,node_buffer.cc:<global>,TYPE_DECL,"[](void* data, size_t length, void* deleter_data) {
    free(data);
  }",24,3,node_buffer.cc,node.Buffer.New.<lambda>2,,false,509,511,<lambda>2,,,1,"ANY node.Buffer.New.<lambda>2 (void*,size_t,void*)"
141928,METHOD,node_buffer.cc:<global>,TYPE_DECL,"[](void*, size_t, void*) {}",38,64,node_buffer.cc,node.Buffer.anonymous_namespace_43.GetZeroFillToggle.<lambda>3,,false,1179,1179,<lambda>3,,,1,"ANY node.Buffer.anonymous_namespace_43.GetZeroFillToggle.<lambda>3 (void*,size_t,void*)"
141969,METHOD,node_buffer.cc:<global>,TYPE_DECL,<global>,1,1,node_buffer.cc,node_buffer.cc:<global>,,false,1,1374,<global>,,,1,
141975,METHOD,node.Buffer.anonymous_namespace_1.CallbackInfo,TYPE_DECL,"static inline Local<ArrayBuffer> CreateTrackedArrayBuffer(
      Environment* env,
      char* data,
      size_t length,
      FreeCallback callback,
      void* hint);",36,17,node_buffer.cc,node.Buffer.anonymous_namespace_2.CallbackInfo.CreateTrackedArrayBuffer,,false,84,89,CreateTrackedArrayBuffer,,,1,"Local<ArrayBuffer> node.Buffer.anonymous_namespace_2.CallbackInfo.CreateTrackedArrayBuffer (Environment*,char*,size_t,FreeCallback,void*)"
141984,METHOD,node.Buffer.anonymous_namespace_1.CallbackInfo,TYPE_DECL,CallbackInfo(const CallbackInfo&) = delete;,3,45,node_buffer.cc,node.Buffer.anonymous_namespace_3.CallbackInfo.CallbackInfo,,false,91,91,CallbackInfo,,,2,ANY node.Buffer.anonymous_namespace_3.CallbackInfo.CallbackInfo (CallbackInfo)
141989,METHOD,node.Buffer.anonymous_namespace_1.CallbackInfo,TYPE_DECL,CallbackInfo& operator=(const CallbackInfo&) = delete;,3,56,node_buffer.cc,node.Buffer.anonymous_namespace_4.CallbackInfo.operator =,,false,92,92,operator =,,,3,CallbackInfo node.Buffer.anonymous_namespace_4.CallbackInfo.operator = (CallbackInfo)
141994,METHOD,node.Buffer.anonymous_namespace_1.CallbackInfo,TYPE_DECL,static void CleanupHook(void* data);,15,37,node_buffer.cc,node.Buffer.anonymous_namespace_5.CallbackInfo.CleanupHook,,false,95,95,CleanupHook,,,4,void node.Buffer.anonymous_namespace_5.CallbackInfo.CleanupHook (void*)
141999,METHOD,node.Buffer.anonymous_namespace_1.CallbackInfo,TYPE_DECL,inline void OnBackingStoreFree();,15,34,node_buffer.cc,node.Buffer.anonymous_namespace_6.CallbackInfo.OnBackingStoreFree,,false,96,96,OnBackingStoreFree,,,5,void node.Buffer.anonymous_namespace_6.CallbackInfo.OnBackingStoreFree ()
142003,METHOD,node.Buffer.anonymous_namespace_1.CallbackInfo,TYPE_DECL,inline void CallAndResetCallback();,15,36,node_buffer.cc,node.Buffer.anonymous_namespace_7.CallbackInfo.CallAndResetCallback,,false,97,97,CallAndResetCallback,,,6,void node.Buffer.anonymous_namespace_7.CallbackInfo.CallAndResetCallback ()
142007,METHOD,node.Buffer.anonymous_namespace_1.CallbackInfo,TYPE_DECL,"inline CallbackInfo(Environment* env,
                      FreeCallback callback,
                      char* data,
                      void* hint);",10,33,node_buffer.cc,node.Buffer.anonymous_namespace_8.CallbackInfo.CallbackInfo,,false,98,101,CallbackInfo,,,7,"inline node.Buffer.anonymous_namespace_8.CallbackInfo.CallbackInfo (Environment*,FreeCallback,char*,void*)"
142021,METHOD,node_buffer.cc:<global>,TYPE_DECL,"Local<ArrayBuffer> CallbackInfo::CreateTrackedArrayBuffer(
    Environment* env,
    char* data,
    size_t length,
    FreeCallback callback,
    void* hint) {
  CHECK_NOT_NULL(callback);
  CHECK_IMPLIES(data == nullptr, length == 0);

  CallbackInfo* self = new CallbackInfo(env, callback, data, hint);
  std::unique_ptr<BackingStore> bs =
      ArrayBuffer::NewBackingStore(data, length, [](void*, size_t, void* arg) {
        static_cast<CallbackInfo*>(arg)->OnBackingStoreFree();
      }, self);
  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));

  // V8 simply ignores the BackingStore deleter callback if data == nullptr,
  // but our API contract requires it being called.
  if (data == nullptr) {
    ab->Detach(Local<Value>()).Check();
    self->OnBackingStoreFree();  // This calls `callback` asynchronously.
  } else {
    // Store the ArrayBuffer so that we can detach it later.
    self->persistent_.Reset(env->isolate(), ab);
    self->persistent_.SetWeak()...",1,1,node_buffer.cc,node.Buffer.anonymous_namespace_9.CallbackInfo.CreateTrackedArrayBuffer,,false,111,139,CreateTrackedArrayBuffer,,,2,"Local<ArrayBuffer> node.Buffer.anonymous_namespace_9.CallbackInfo.CreateTrackedArrayBuffer (Environment*,char*,size_t,FreeCallback,void*)"
142121,METHOD,node_buffer.cc:<global>,TYPE_DECL,"CallbackInfo::CallbackInfo(Environment* env,
                           FreeCallback callback,
                           char* data,
                           void* hint)
    : callback_(callback),
      data_(data),
      hint_(hint),
      env_(env) {
  env->AddCleanupHook(CleanupHook, this);
  env->isolate()->AdjustAmountOfExternalAllocatedMemory(sizeof(*this));
}",1,1,node_buffer.cc,node.Buffer.anonymous_namespace_11.CallbackInfo.CallbackInfo,,false,142,152,CallbackInfo,,,3,"ANY node.Buffer.anonymous_namespace_11.CallbackInfo.CallbackInfo (Environment*,FreeCallback,char*,void*)"
142145,METHOD,node_buffer.cc:<global>,TYPE_DECL,"void CallbackInfo::CleanupHook(void* data) {
  CallbackInfo* self = static_cast<CallbackInfo*>(data);

  {
    HandleScope handle_scope(self->env_->isolate());
    Local<ArrayBuffer> ab = self->persistent_.Get(self->env_->isolate());
    if (!ab.IsEmpty() && ab->IsDetachable()) {
      ab->Detach(Local<Value>()).Check();
      self->persistent_.Reset();
    }
  }

  // Call the callback in this case, but don't delete `this` yet because the
  // BackingStore deleter callback will do so later.
  self->CallAndResetCallback();
}",1,1,node_buffer.cc,node.Buffer.anonymous_namespace_12.CallbackInfo.CleanupHook,,false,154,169,CleanupHook,,,4,void node.Buffer.anonymous_namespace_12.CallbackInfo.CleanupHook (void*)
142213,METHOD,node_buffer.cc:<global>,TYPE_DECL,"void CallbackInfo::CallAndResetCallback() {
  FreeCallback callback;
  {
    Mutex::ScopedLock lock(mutex_);
    callback = callback_;
    callback_ = nullptr;
  }
  if (callback != nullptr) {
    // Clean up all Environment-related state and run the callback.
    env_->RemoveCleanupHook(CleanupHook, this);
    int64_t change_in_bytes = -static_cast<int64_t>(sizeof(*this));
    env_->isolate()->AdjustAmountOfExternalAllocatedMemory(change_in_bytes);

    callback(data_, hint_);
  }
}",1,1,node_buffer.cc,node.Buffer.anonymous_namespace_13.CallbackInfo.CallAndResetCallback,,false,171,186,CallAndResetCallback,,,5,void node.Buffer.anonymous_namespace_13.CallbackInfo.CallAndResetCallback ()
142259,METHOD,node_buffer.cc:<global>,TYPE_DECL,"void CallbackInfo::OnBackingStoreFree() {
  // This method should always release the memory for `this`.
  std::unique_ptr<CallbackInfo> self { this };
  Mutex::ScopedLock lock(mutex_);
  // If callback_ == nullptr, that means that the callback has already run from
  // the cleanup hook, and there is nothing left to do here besides to clean
  // up the memory involved. In particular, the underlying `Environment` may
  // be gone at this point, so dont attempt to call SetImmediateThreadsafe().
  if (callback_ == nullptr) return;

  env_->SetImmediateThreadsafe([self = std::move(self)](Environment* env) {
    CHECK_EQ(self->env_, env);  // Consistency check.

    self->CallAndResetCallback();
  });
}",1,1,node_buffer.cc,node.Buffer.anonymous_namespace_15.CallbackInfo.OnBackingStoreFree,,false,188,203,OnBackingStoreFree,,,6,void node.Buffer.anonymous_namespace_15.CallbackInfo.OnBackingStoreFree ()
142282,METHOD,node_buffer.cc:<global>,TYPE_DECL,"bool HasInstance(Local<Value> val) {
  return val->IsArrayBufferView();
}",1,1,node_buffer.cc,node.Buffer.HasInstance,,false,237,239,HasInstance,,,2,bool node.Buffer.HasInstance (Local<Value>)
142292,METHOD,node_buffer.cc:<global>,TYPE_DECL,"bool HasInstance(Local<Object> obj) {
  return obj->IsArrayBufferView();
}",1,1,node_buffer.cc,node.Buffer.HasInstance,,false,242,244,HasInstance,,,3,bool node.Buffer.HasInstance (Local<Object>)
142302,METHOD,node_buffer.cc:<global>,TYPE_DECL,"char* Data(Local<Value> val) {
  CHECK(val->IsArrayBufferView());
  Local<ArrayBufferView> ui = val.As<ArrayBufferView>();
  return static_cast<char*>(ui->Buffer()->Data()) + ui->ByteOffset();
}",1,1,node_buffer.cc,node.Buffer.Data,,false,247,251,Data,,,4,char* node.Buffer.Data (Local<Value>)
142337,METHOD,node_buffer.cc:<global>,TYPE_DECL,"char* Data(Local<Object> obj) {
  return Data(obj.As<Value>());
}",1,1,node_buffer.cc,node.Buffer.Data,,false,254,256,Data,,,5,char* node.Buffer.Data (Local<Object>)
142348,METHOD,node_buffer.cc:<global>,TYPE_DECL,"size_t Length(Local<Value> val) {
  CHECK(val->IsArrayBufferView());
  Local<ArrayBufferView> ui = val.As<ArrayBufferView>();
  return ui->ByteLength();
}",1,1,node_buffer.cc,node.Buffer.Length,,false,259,263,Length,,,6,size_t node.Buffer.Length (Local<Value>)
142373,METHOD,node_buffer.cc:<global>,TYPE_DECL,"size_t Length(Local<Object> obj) {
  CHECK(obj->IsArrayBufferView());
  Local<ArrayBufferView> ui = obj.As<ArrayBufferView>();
  return ui->ByteLength();
}",1,1,node_buffer.cc,node.Buffer.Length,,false,266,270,Length,,,7,size_t node.Buffer.Length (Local<Object>)
142398,METHOD,node_buffer.cc:<global>,TYPE_DECL,"MaybeLocal<Uint8Array> New(Environment* env,
                           Local<ArrayBuffer> ab,
                           size_t byte_offset,
                           size_t length) {
  CHECK(!env->buffer_prototype_object().IsEmpty());
  Local<Uint8Array> ui = Uint8Array::New(ab, byte_offset, length);
  Maybe<bool> mb =
      ui->SetPrototype(env->context(), env->buffer_prototype_object());
  if (mb.IsNothing())
    return MaybeLocal<Uint8Array>();
  return ui;
}",1,1,node_buffer.cc,node.Buffer.New,,false,273,284,New,,,8,"MaybeLocal<Uint8Array> node.Buffer.New (Environment*,Local<ArrayBuffer>,size_t,size_t)"
142453,METHOD,node_buffer.cc:<global>,TYPE_DECL,"MaybeLocal<Uint8Array> New(Isolate* isolate,
                           Local<ArrayBuffer> ab,
                           size_t byte_offset,
                           size_t length) {
  Environment* env = Environment::GetCurrent(isolate);
  if (env == nullptr) {
    THROW_ERR_BUFFER_CONTEXT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Uint8Array>();
  }
  return New(env, ab, byte_offset, length);
}",1,1,node_buffer.cc,node.Buffer.New,,false,286,296,New,,,9,"MaybeLocal<Uint8Array> node.Buffer.New (Isolate*,Local<ArrayBuffer>,size_t,size_t)"
142484,METHOD,node_buffer.cc:<global>,TYPE_DECL,"MaybeLocal<Object> New(Isolate* isolate,
                       Local<String> string,
                       enum encoding enc) {
  EscapableHandleScope scope(isolate);

  size_t length;
  if (!StringBytes::Size(isolate, string, enc).To(&length))
    return Local<Object>();
  size_t actual = 0;
  std::unique_ptr<BackingStore> store;

  if (length > 0) {
    store = ArrayBuffer::NewBackingStore(isolate, length);

    if (UNLIKELY(!store)) {
      THROW_ERR_MEMORY_ALLOCATION_FAILED(isolate);
      return Local<Object>();
    }

    actual = StringBytes::Write(
        isolate,
        static_cast<char*>(store->Data()),
        length,
        string,
        enc);
    CHECK(actual <= length);

    if (LIKELY(actual > 0)) {
      if (actual < length)
        store = BackingStore::Reallocate(isolate, std::move(store), actual);
      Local<ArrayBuffer> buf = ArrayBuffer::New(isolate, std::move(store));
      Local<Object> obj;
      if (UNLIKELY(!New(isolate, buf, 0, actual).ToLocal(&obj...",1,1,node_buffer.cc,node.Buffer.New,,false,299,338,New,,,10,"MaybeLocal<Object> node.Buffer.New (Isolate*,Local<String>,encoding)"
142640,METHOD,node_buffer.cc:<global>,TYPE_DECL,"MaybeLocal<Object> New(Isolate* isolate, size_t length) {
  EscapableHandleScope handle_scope(isolate);
  Local<Object> obj;
  Environment* env = Environment::GetCurrent(isolate);
  if (env == nullptr) {
    THROW_ERR_BUFFER_CONTEXT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Object>();
  }
  if (Buffer::New(env, length).ToLocal(&obj))
    return handle_scope.Escape(obj);
  return Local<Object>();
}",1,1,node_buffer.cc,node.Buffer.New,,false,341,352,New,,,11,"MaybeLocal<Object> node.Buffer.New (Isolate*,size_t)"
142692,METHOD,node_buffer.cc:<global>,TYPE_DECL,"MaybeLocal<Object> New(Environment* env, size_t length) {
  Isolate* isolate(env->isolate());
  EscapableHandleScope scope(isolate);

  // V8 currently only allows a maximum Typed Array index of max Smi.
  if (length > kMaxLength) {
    isolate->ThrowException(ERR_BUFFER_TOO_LARGE(isolate));
    return Local<Object>();
  }

  Local<ArrayBuffer> ab;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    std::unique_ptr<BackingStore> bs =
        ArrayBuffer::NewBackingStore(isolate, length);

    CHECK(bs);

    ab = ArrayBuffer::New(isolate, std::move(bs));
  }

  MaybeLocal<Object> obj =
      New(env, ab, 0, ab->ByteLength())
          .FromMaybe(Local<Uint8Array>());

  return scope.EscapeMaybe(obj);
}",1,1,node_buffer.cc,node.Buffer.New,,false,355,381,New,,,12,"MaybeLocal<Object> node.Buffer.New (Environment*,size_t)"
142783,METHOD,node_buffer.cc:<global>,TYPE_DECL,"MaybeLocal<Object> Copy(Isolate* isolate, const char* data, size_t length) {
  EscapableHandleScope handle_scope(isolate);
  Environment* env = Environment::GetCurrent(isolate);
  if (env == nullptr) {
    THROW_ERR_BUFFER_CONTEXT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Object>();
  }
  Local<Object> obj;
  if (Buffer::Copy(env, data, length).ToLocal(&obj))
    return handle_scope.Escape(obj);
  return Local<Object>();
}",1,1,node_buffer.cc,node.Buffer.Copy,,false,384,395,Copy,,,13,"MaybeLocal<Object> node.Buffer.Copy (Isolate*,char*,size_t)"
142837,METHOD,node_buffer.cc:<global>,TYPE_DECL,"MaybeLocal<Object> Copy(Environment* env, const char* data, size_t length) {
  Isolate* isolate(env->isolate());
  EscapableHandleScope scope(isolate);

  // V8 currently only allows a maximum Typed Array index of max Smi.
  if (length > kMaxLength) {
    isolate->ThrowException(ERR_BUFFER_TOO_LARGE(isolate));
    return Local<Object>();
  }

  Local<ArrayBuffer> ab;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    std::unique_ptr<BackingStore> bs =
        ArrayBuffer::NewBackingStore(isolate, length);

    CHECK(bs);

    memcpy(bs->Data(), data, length);

    ab = ArrayBuffer::New(isolate, std::move(bs));
  }

  MaybeLocal<Object> obj =
      New(env, ab, 0, ab->ByteLength())
          .FromMaybe(Local<Uint8Array>());

  return scope.EscapeMaybe(obj);
}",1,1,node_buffer.cc,node.Buffer.Copy,,false,398,426,Copy,,,14,"MaybeLocal<Object> node.Buffer.Copy (Environment*,char*,size_t)"
142936,METHOD,node_buffer.cc:<global>,TYPE_DECL,"MaybeLocal<Object> New(Isolate* isolate,
                       char* data,
                       size_t length,
                       FreeCallback callback,
                       void* hint) {
  EscapableHandleScope handle_scope(isolate);
  Environment* env = Environment::GetCurrent(isolate);
  if (env == nullptr) {
    callback(data, hint);
    THROW_ERR_BUFFER_CONTEXT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Object>();
  }
  return handle_scope.EscapeMaybe(
      Buffer::New(env, data, length, callback, hint));
}",1,1,node_buffer.cc,node.Buffer.New,,false,429,443,New,,,15,"MaybeLocal<Object> node.Buffer.New (Isolate*,char*,size_t,FreeCallback,void*)"
142982,METHOD,node_buffer.cc:<global>,TYPE_DECL,"MaybeLocal<Object> New(Environment* env,
                       char* data,
                       size_t length,
                       FreeCallback callback,
                       void* hint) {
  EscapableHandleScope scope(env->isolate());

  if (length > kMaxLength) {
    env->isolate()->ThrowException(ERR_BUFFER_TOO_LARGE(env->isolate()));
    callback(data, hint);
    return Local<Object>();
  }

  Local<ArrayBuffer> ab =
      CallbackInfo::CreateTrackedArrayBuffer(env, data, length, callback, hint);
  if (ab->SetPrivate(env->context(),
                     env->untransferable_object_private_symbol(),
                     True(env->isolate())).IsNothing()) {
    return Local<Object>();
  }
  MaybeLocal<Uint8Array> maybe_ui = Buffer::New(env, ab, 0, length);

  Local<Uint8Array> ui;
  if (!maybe_ui.ToLocal(&ui))
    return MaybeLocal<Object>();

  return scope.Escape(ui);
}",1,1,node_buffer.cc,node.Buffer.New,,false,446,473,New,,,16,"MaybeLocal<Object> node.Buffer.New (Environment*,char*,size_t,FreeCallback,void*)"
143094,METHOD,node_buffer.cc:<global>,TYPE_DECL,"MaybeLocal<Object> New(Isolate* isolate, char* data, size_t length) {
  EscapableHandleScope handle_scope(isolate);
  Environment* env = Environment::GetCurrent(isolate);
  if (env == nullptr) {
    free(data);
    THROW_ERR_BUFFER_CONTEXT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Object>();
  }
  Local<Object> obj;
  if (Buffer::New(env, data, length).ToLocal(&obj))
    return handle_scope.Escape(obj);
  return Local<Object>();
}",1,1,node_buffer.cc,node.Buffer.New,,false,477,489,New,,,17,"MaybeLocal<Object> node.Buffer.New (Isolate*,char*,size_t)"
143150,METHOD,node_buffer.cc:<global>,TYPE_DECL,"MaybeLocal<Object> New(Environment* env,
                       char* data,
                       size_t length) {
  if (length > 0) {
    CHECK_NOT_NULL(data);
    // V8 currently only allows a maximum Typed Array index of max Smi.
    if (length > kMaxLength) {
      Isolate* isolate(env->isolate());
      isolate->ThrowException(ERR_BUFFER_TOO_LARGE(isolate));
      free(data);
      return Local<Object>();
    }
  }

  EscapableHandleScope handle_scope(env->isolate());

  auto free_callback = [](void* data, size_t length, void* deleter_data) {
    free(data);
  };
  std::unique_ptr<BackingStore> bs =
      v8::ArrayBuffer::NewBackingStore(data, length, free_callback, nullptr);

  Local<ArrayBuffer> ab = v8::ArrayBuffer::New(env->isolate(), std::move(bs));

  Local<Object> obj;
  if (Buffer::New(env, ab, 0, length).ToLocal(&obj))
    return handle_scope.Escape(obj);
  return Local<Object>();
}",1,1,node_buffer.cc,node.Buffer.New,,false,493,521,New,,,18,"MaybeLocal<Object> node.Buffer.New (Environment*,char*,size_t)"
143262,METHOD,node_buffer.cc:<global>,TYPE_DECL,"void CreateFromString(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsString());
  CHECK(args[1]->IsInt32());

  enum encoding enc = static_cast<enum encoding>(args[1].As<Int32>()->Value());
  Local<Object> buf;
  if (New(args.GetIsolate(), args[0].As<String>(), enc).ToLocal(&buf))
    args.GetReturnValue().Set(buf);
}",1,1,node_buffer.cc,node.Buffer.anonymous_namespace_19.CreateFromString,,false,525,533,CreateFromString,,,1,void node.Buffer.anonymous_namespace_19.CreateFromString (FunctionCallbackInfo<Value>)
143327,METHOD,node_buffer.cc:<global>,TYPE_DECL,"void StringSlice(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  THROW_AND_RETURN_UNLESS_BUFFER(env, args.This());
  ArrayBufferViewContents<char> buffer(args.This());

  if (buffer.length() == 0)
    return args.GetReturnValue().SetEmptyString();

  size_t start = 0;
  size_t end = 0;
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[0], 0, &start));
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[1], buffer.length(), &end));
  if (end < start) end = start;
  THROW_AND_RETURN_IF_OOB(Just(end <= buffer.length()));
  size_t length = end - start;

  Local<Value> error;
  MaybeLocal<Value> maybe_ret =
      StringBytes::Encode(isolate,
                          buffer.data() + start,
                          length,
                          encoding,
                          &error);
  Local<Value> ret;
  if (!maybe_ret.ToLocal(&ret)) {
    CHECK(!error.IsEmpty());
    isolate->ThrowExceptio...",1,2,node_buffer.cc,node.Buffer.anonymous_namespace_20.StringSlice,,false,537,569,StringSlice,,,2,void node.Buffer.anonymous_namespace_20.StringSlice<encoding> (FunctionCallbackInfo<Value>)
143581,METHOD,node_buffer.cc:<global>,TYPE_DECL,"void Copy(const FunctionCallbackInfo<Value> &args) {
  Environment* env = Environment::GetCurrent(args);

  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  THROW_AND_RETURN_UNLESS_BUFFER(env, args[1]);
  ArrayBufferViewContents<char> source(args[0]);
  Local<Object> target_obj = args[1].As<Object>();
  SPREAD_BUFFER_ARG(target_obj, target);

  size_t target_start = 0;
  size_t source_start = 0;
  size_t source_end = 0;

  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], 0, &target_start));
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[3], 0, &source_start));
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[4], source.length(),
                                          &source_end));

  // Copy 0 bytes; we're done
  if (target_start >= target_length || source_start >= source_end)
    return args.GetReturnValue().Set(0);

  if (source_start > source.length())
    return THROW_ERR_OUT_OF_RANGE(
        env, ""The value of \""sourceStart\"" is out of range."");

  if (source_e...",1,2,node_buffer.cc,node.Buffer.anonymous_namespace_21.Copy,,false,572,607,Copy,,,3,void node.Buffer.anonymous_namespace_21.Copy (FunctionCallbackInfo<Value>)
143855,METHOD,node_buffer.cc:<global>,TYPE_DECL,"void Fill(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Local<Context> ctx = env->context();

  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  SPREAD_BUFFER_ARG(args[0], ts_obj);

  size_t start = 0;
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], 0, &start));
  size_t end;
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[3], 0, &end));

  size_t fill_length = end - start;
  Local<String> str_obj;
  size_t str_length;
  enum encoding enc;

  // OOB Check. Throw the error in JS.
  if (start > end || fill_length + start > ts_obj_length)
    return args.GetReturnValue().Set(-2);

  // First check if Buffer has been passed.
  if (Buffer::HasInstance(args[1])) {
    SPREAD_BUFFER_ARG(args[1], fill_obj);
    str_length = fill_obj_length;
    memcpy(
        ts_obj_data + start, fill_obj_data, std::min(str_length, fill_length));
    goto start_fill;
  }

  // Then coerce everything that's not a string.
  if (!args[1]->IsString(...",1,2,node_buffer.cc,node.Buffer.anonymous_namespace_22.Fill,,false,610,700,Fill,,,4,void node.Buffer.anonymous_namespace_22.Fill (FunctionCallbackInfo<Value>)
144272,METHOD,node_buffer.cc:<global>,TYPE_DECL,"void StringWrite(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  THROW_AND_RETURN_UNLESS_BUFFER(env, args.This());
  SPREAD_BUFFER_ARG(args.This(), ts_obj);

  THROW_AND_RETURN_IF_NOT_STRING(env, args[0], ""argument"");

  Local<String> str = args[0]->ToString(env->context()).ToLocalChecked();

  size_t offset = 0;
  size_t max_length = 0;

  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[1], 0, &offset));
  if (offset > ts_obj_length) {
    return node::THROW_ERR_BUFFER_OUT_OF_BOUNDS(
        env, ""\""offset\"" is outside of buffer bounds"");
  }

  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], ts_obj_length - offset,
                                          &max_length));

  max_length = std::min(ts_obj_length - offset, max_length);

  if (max_length == 0)
    return args.GetReturnValue().Set(0);

  uint32_t written = StringBytes::Write(
      env->isolate(), ts_obj_data + offset, max_length, str, encoding);
  args.GetReturn...",1,2,node_buffer.cc,node.Buffer.anonymous_namespace_23.StringWrite,,false,704,734,StringWrite,,,5,void node.Buffer.anonymous_namespace_23.StringWrite<encoding> (FunctionCallbackInfo<Value>)
144477,METHOD,node_buffer.cc:<global>,TYPE_DECL,"void SlowByteLengthUtf8(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsString());

  // Fast case: avoid StringBytes on UTF8 string. Jump to v8.
  args.GetReturnValue().Set(args[0].As<String>()->Utf8Length(env->isolate()));
}",1,1,node_buffer.cc,node.Buffer.anonymous_namespace_24.SlowByteLengthUtf8,,false,736,742,SlowByteLengthUtf8,,,6,void node.Buffer.anonymous_namespace_24.SlowByteLengthUtf8 (FunctionCallbackInfo<Value>)
144517,METHOD,node_buffer.cc:<global>,TYPE_DECL,"uint32_t FastByteLengthUtf8(Local<Value> receiver,
                            const v8::FastOneByteString& source) {
  uint32_t result = 0;
  uint32_t length = source.length;
  const uint8_t* data = reinterpret_cast<const uint8_t*>(source.data);
  for (uint32_t i = 0; i < length; ++i) {
    result += (data[i] >> 7);
  }
  result += length;
  return result;
}",1,1,node_buffer.cc,node.Buffer.anonymous_namespace_25.FastByteLengthUtf8,,false,744,754,FastByteLengthUtf8,,,7,"uint32_t node.Buffer.anonymous_namespace_25.FastByteLengthUtf8 (Local<Value>,ANY)"
144565,METHOD,node_buffer.cc:<global>,TYPE_DECL,"static v8::CFunction fast_byte_length_utf8(
    v8::CFunction::Make(FastByteLengthUtf8));",22,44,node_buffer.cc,node.Buffer.anonymous_namespace_26.fast_byte_length_utf8,,false,756,757,fast_byte_length_utf8,,,8,ANY node.Buffer.anonymous_namespace_26.fast_byte_length_utf8 (ANY)
144570,METHOD,node_buffer.cc:<global>,TYPE_DECL,"static int normalizeCompareVal(int val, size_t a_length, size_t b_length) {
  if (val == 0) {
    if (a_length > b_length)
      return 1;
    else if (a_length < b_length)
      return -1;
  } else {
    if (val > 0)
      return 1;
    else
      return -1;
  }
  return val;
}",1,1,node_buffer.cc,node.Buffer.anonymous_namespace_27.normalizeCompareVal,,false,761,774,normalizeCompareVal,,,9,"int node.Buffer.anonymous_namespace_27.normalizeCompareVal (int,size_t,size_t)"
144615,METHOD,node_buffer.cc:<global>,TYPE_DECL,"void CompareOffset(const FunctionCallbackInfo<Value> &args) {
  Environment* env = Environment::GetCurrent(args);

  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  THROW_AND_RETURN_UNLESS_BUFFER(env, args[1]);
  ArrayBufferViewContents<char> source(args[0]);
  ArrayBufferViewContents<char> target(args[1]);

  size_t target_start = 0;
  size_t source_start = 0;
  size_t source_end = 0;
  size_t target_end = 0;

  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], 0, &target_start));
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[3], 0, &source_start));
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[4], target.length(),
                                          &target_end));
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[5], source.length(),
                                          &source_end));

  if (source_start > source.length())
    return THROW_ERR_OUT_OF_RANGE(
        env, ""The value of \""sourceStart\"" is out of range."");
  if (target_start > target.lengt...",1,2,node_buffer.cc,node.Buffer.anonymous_namespace_28.CompareOffset,,false,776,818,CompareOffset,,,10,void node.Buffer.anonymous_namespace_28.CompareOffset (FunctionCallbackInfo<Value>)
144926,METHOD,node_buffer.cc:<global>,TYPE_DECL,"void Compare(const FunctionCallbackInfo<Value> &args) {
  Environment* env = Environment::GetCurrent(args);

  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  THROW_AND_RETURN_UNLESS_BUFFER(env, args[1]);
  ArrayBufferViewContents<char> a(args[0]);
  ArrayBufferViewContents<char> b(args[1]);

  size_t cmp_length = std::min(a.length(), b.length());

  int val = normalizeCompareVal(cmp_length > 0 ?
                                memcmp(a.data(), b.data(), cmp_length) : 0,
                                a.length(), b.length());
  args.GetReturnValue().Set(val);
}",1,2,node_buffer.cc,node.Buffer.anonymous_namespace_29.Compare,,false,820,834,Compare,,,11,void node.Buffer.anonymous_namespace_29.Compare (FunctionCallbackInfo<Value>)
145023,METHOD,node_buffer.cc:<global>,TYPE_DECL,"int64_t IndexOfOffset(size_t length,
                      int64_t offset_i64,
                      int64_t needle_length,
                      bool is_forward) {
  int64_t length_i64 = static_cast<int64_t>(length);
  if (offset_i64 < 0) {
    if (offset_i64 + length_i64 >= 0) {
      // Negative offsets count backwards from the end of the buffer.
      return length_i64 + offset_i64;
    } else if (is_forward || needle_length == 0) {
      // indexOf from before the start of the buffer: search the whole buffer.
      return 0;
    } else {
      // lastIndexOf from before the start of the buffer: no match.
      return -1;
    }
  } else {
    if (offset_i64 + needle_length <= length_i64) {
      // Valid positive offset.
      return offset_i64;
    } else if (needle_length == 0) {
      // Out of buffer bounds, but empty needle: point to end of buffer.
      return length_i64;
    } else if (is_forward) {
      // indexOf from past the end of the buffer: no match.
      return ...",1,1,node_buffer.cc,node.Buffer.anonymous_namespace_30.IndexOfOffset,,false,840,871,IndexOfOffset,,,12,"int64_t node.Buffer.anonymous_namespace_30.IndexOfOffset (size_t,int64_t,int64_t,bool)"
145103,METHOD,node_buffer.cc:<global>,TYPE_DECL,"void IndexOfString(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  CHECK(args[1]->IsString());
  CHECK(args[2]->IsNumber());
  CHECK(args[3]->IsInt32());
  CHECK(args[4]->IsBoolean());

  enum encoding enc = static_cast<enum encoding>(args[3].As<Int32>()->Value());

  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  ArrayBufferViewContents<char> buffer(args[0]);

  Local<String> needle = args[1].As<String>();
  int64_t offset_i64 = args[2].As<Integer>()->Value();
  bool is_forward = args[4]->IsTrue();

  const char* haystack = buffer.data();
  // Round down to the nearest multiple of 2 in case of UCS2.
  const size_t haystack_length = (enc == UCS2) ?
      buffer.length() &~ 1 : buffer.length();  // NOLINT(whitespace/operators)

  size_t needle_length;
  if (!StringBytes::Size(isolate, needle, enc).To(&needle_length)) return;

  int64_t opt_offset = IndexOfOffset(haystack_length,
                  ...",1,2,node_buffer.cc,node.Buffer.anonymous_namespace_31.IndexOfString,,false,873,989,IndexOfString,,,13,void node.Buffer.anonymous_namespace_31.IndexOfString (FunctionCallbackInfo<Value>)
145595,METHOD,node_buffer.cc:<global>,TYPE_DECL,"void IndexOfBuffer(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[1]->IsObject());
  CHECK(args[2]->IsNumber());
  CHECK(args[3]->IsInt32());
  CHECK(args[4]->IsBoolean());

  enum encoding enc = static_cast<enum encoding>(args[3].As<Int32>()->Value());

  THROW_AND_RETURN_UNLESS_BUFFER(Environment::GetCurrent(args), args[0]);
  THROW_AND_RETURN_UNLESS_BUFFER(Environment::GetCurrent(args), args[1]);
  ArrayBufferViewContents<char> haystack_contents(args[0]);
  ArrayBufferViewContents<char> needle_contents(args[1]);
  int64_t offset_i64 = args[2].As<Integer>()->Value();
  bool is_forward = args[4]->IsTrue();

  const char* haystack = haystack_contents.data();
  const size_t haystack_length = haystack_contents.length();
  const char* needle = needle_contents.data();
  const size_t needle_length = needle_contents.length();

  int64_t opt_offset = IndexOfOffset(haystack_length,
                                     offset_i64,
                                     needle_length,
...",1,2,node_buffer.cc,node.Buffer.anonymous_namespace_33.IndexOfBuffer,,false,991,1062,IndexOfBuffer,,,14,void node.Buffer.anonymous_namespace_33.IndexOfBuffer (FunctionCallbackInfo<Value>)
145909,METHOD,node_buffer.cc:<global>,TYPE_DECL,"void IndexOfNumber(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[1]->IsUint32());
  CHECK(args[2]->IsNumber());
  CHECK(args[3]->IsBoolean());

  THROW_AND_RETURN_UNLESS_BUFFER(Environment::GetCurrent(args), args[0]);
  ArrayBufferViewContents<char> buffer(args[0]);

  uint32_t needle = args[1].As<Uint32>()->Value();
  int64_t offset_i64 = args[2].As<Integer>()->Value();
  bool is_forward = args[3]->IsTrue();

  int64_t opt_offset =
      IndexOfOffset(buffer.length(), offset_i64, 1, is_forward);
  if (opt_offset <= -1 || buffer.length() == 0) {
    return args.GetReturnValue().Set(-1);
  }
  size_t offset = static_cast<size_t>(opt_offset);
  CHECK_LT(offset, buffer.length());

  const void* ptr;
  if (is_forward) {
    ptr = memchr(buffer.data() + offset, needle, buffer.length() - offset);
  } else {
    ptr = node::stringsearch::MemrchrFill(buffer.data(), needle, offset + 1);
  }
  const char* ptr_char = static_cast<const char*>(ptr);
  args.GetReturnValue().Set(ptr ? st...",1,2,node_buffer.cc,node.Buffer.anonymous_namespace_35.IndexOfNumber,,false,1064,1093,IndexOfNumber,,,15,void node.Buffer.anonymous_namespace_35.IndexOfNumber (FunctionCallbackInfo<Value>)
146102,METHOD,node_buffer.cc:<global>,TYPE_DECL,"void Swap16(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  SPREAD_BUFFER_ARG(args[0], ts_obj);
  SwapBytes16(ts_obj_data, ts_obj_length);
  args.GetReturnValue().Set(args[0]);
}",1,2,node_buffer.cc,node.Buffer.anonymous_namespace_36.Swap16,,false,1096,1102,Swap16,,,16,void node.Buffer.anonymous_namespace_36.Swap16 (FunctionCallbackInfo<Value>)
146145,METHOD,node_buffer.cc:<global>,TYPE_DECL,"void Swap32(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  SPREAD_BUFFER_ARG(args[0], ts_obj);
  SwapBytes32(ts_obj_data, ts_obj_length);
  args.GetReturnValue().Set(args[0]);
}",1,2,node_buffer.cc,node.Buffer.anonymous_namespace_37.Swap32,,false,1105,1111,Swap32,,,17,void node.Buffer.anonymous_namespace_37.Swap32 (FunctionCallbackInfo<Value>)
146188,METHOD,node_buffer.cc:<global>,TYPE_DECL,"void Swap64(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  SPREAD_BUFFER_ARG(args[0], ts_obj);
  SwapBytes64(ts_obj_data, ts_obj_length);
  args.GetReturnValue().Set(args[0]);
}",1,2,node_buffer.cc,node.Buffer.anonymous_namespace_38.Swap64,,false,1114,1120,Swap64,,,18,void node.Buffer.anonymous_namespace_38.Swap64 (FunctionCallbackInfo<Value>)
146231,METHOD,node_buffer.cc:<global>,TYPE_DECL,"static void IsUtf8(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsTypedArray() || args[0]->IsArrayBuffer() ||
        args[0]->IsSharedArrayBuffer());
  ArrayBufferViewContents<char> abv(args[0]);

  if (abv.WasDetached()) {
    return node::THROW_ERR_INVALID_STATE(
        env, ""Cannot validate on a detached buffer"");
  }

  args.GetReturnValue().Set(simdutf::validate_utf8(abv.data(), abv.length()));
}",1,1,node_buffer.cc,node.Buffer.anonymous_namespace_39.IsUtf8,,false,1122,1135,IsUtf8,,,19,void node.Buffer.anonymous_namespace_39.IsUtf8 (FunctionCallbackInfo<Value>)
146308,METHOD,node_buffer.cc:<global>,TYPE_DECL,"static void IsAscii(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsTypedArray() || args[0]->IsArrayBuffer() ||
        args[0]->IsSharedArrayBuffer());
  ArrayBufferViewContents<char> abv(args[0]);

  if (abv.WasDetached()) {
    return node::THROW_ERR_INVALID_STATE(
        env, ""Cannot validate on a detached buffer"");
  }

  args.GetReturnValue().Set(simdutf::validate_ascii(abv.data(), abv.length()));
}",1,1,node_buffer.cc,node.Buffer.anonymous_namespace_40.IsAscii,,false,1137,1150,IsAscii,,,20,void node.Buffer.anonymous_namespace_40.IsAscii (FunctionCallbackInfo<Value>)
146385,METHOD,node_buffer.cc:<global>,TYPE_DECL,"void SetBufferPrototype(const FunctionCallbackInfo<Value>& args) {
  Realm* realm = Realm::GetCurrent(args);

  // TODO(legendecas): Remove this check once the binding supports sub-realms.
  CHECK_EQ(realm->kind(), Realm::Kind::kPrincipal);

  CHECK(args[0]->IsObject());
  Local<Object> proto = args[0].As<Object>();
  realm->set_buffer_prototype_object(proto);
}",1,1,node_buffer.cc,node.Buffer.anonymous_namespace_41.SetBufferPrototype,,false,1152,1161,SetBufferPrototype,,,21,void node.Buffer.anonymous_namespace_41.SetBufferPrototype (FunctionCallbackInfo<Value>)
146432,METHOD,node_buffer.cc:<global>,TYPE_DECL,"void GetZeroFillToggle(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  NodeArrayBufferAllocator* allocator = env->isolate_data()->node_allocator();
  Local<ArrayBuffer> ab;
  // It can be a nullptr when running inside an isolate where we
  // do not own the ArrayBuffer allocator.
  if (allocator == nullptr) {
    // Create a dummy Uint32Array - the JS land can only toggle the C++ land
    // setting when the allocator uses our toggle. With this the toggle in JS
    // land results in no-ops.
    ab = ArrayBuffer::New(env->isolate(), sizeof(uint32_t));
  } else {
    uint32_t* zero_fill_field = allocator->zero_fill_field();
    std::unique_ptr<BackingStore> backing =
        ArrayBuffer::NewBackingStore(zero_fill_field,
                                     sizeof(*zero_fill_field),
                                     [](void*, size_t, void*) {},
                                     nullptr);
    ab = ArrayBuffer::New(env->isolate(), s...",1,1,node_buffer.cc,node.Buffer.anonymous_namespace_42.GetZeroFillToggle,,false,1163,1190,GetZeroFillToggle,,,22,void node.Buffer.anonymous_namespace_42.GetZeroFillToggle (FunctionCallbackInfo<Value>)
146553,METHOD,node_buffer.cc:<global>,TYPE_DECL,"void DetachArrayBuffer(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  if (args[0]->IsArrayBuffer()) {
    Local<ArrayBuffer> buf = args[0].As<ArrayBuffer>();
    if (buf->IsDetachable()) {
      std::shared_ptr<BackingStore> store = buf->GetBackingStore();
      buf->Detach(Local<Value>()).Check();
      args.GetReturnValue().Set(ArrayBuffer::New(env->isolate(), store));
    }
  }
}",1,1,node_buffer.cc,node.Buffer.anonymous_namespace_44.DetachArrayBuffer,,false,1192,1202,DetachArrayBuffer,,,23,void node.Buffer.anonymous_namespace_44.DetachArrayBuffer (FunctionCallbackInfo<Value>)
146629,METHOD,node_buffer.cc:<global>,TYPE_DECL,"std::pair<void*, size_t> DecomposeBufferToParts(Local<Value> buffer) {
  void* pointer;
  size_t byte_length;
  if (buffer->IsArrayBuffer()) {
    Local<ArrayBuffer> ab = buffer.As<ArrayBuffer>();
    pointer = ab->Data();
    byte_length = ab->ByteLength();
  } else if (buffer->IsSharedArrayBuffer()) {
    Local<SharedArrayBuffer> ab = buffer.As<SharedArrayBuffer>();
    pointer = ab->Data();
    byte_length = ab->ByteLength();
  } else {
    UNREACHABLE();  // Caller must validate.
  }
  return {pointer, byte_length};
}",1,1,node_buffer.cc,node.Buffer.anonymous_namespace_47.anonymous_namespace_48.DecomposeBufferToParts,,false,1206,1221,DecomposeBufferToParts,,,1,"pair<void *,size_t> node.Buffer.anonymous_namespace_47.anonymous_namespace_48.DecomposeBufferToParts (Local<Value>)"
146698,METHOD,node_buffer.cc:<global>,TYPE_DECL,"void CopyArrayBuffer(const FunctionCallbackInfo<Value>& args) {
  // args[0] == Destination ArrayBuffer
  // args[1] == Destination ArrayBuffer Offset
  // args[2] == Source ArrayBuffer
  // args[3] == Source ArrayBuffer Offset
  // args[4] == bytesToCopy

  CHECK(args[0]->IsArrayBuffer() || args[0]->IsSharedArrayBuffer());
  CHECK(args[1]->IsUint32());
  CHECK(args[2]->IsArrayBuffer() || args[2]->IsSharedArrayBuffer());
  CHECK(args[3]->IsUint32());
  CHECK(args[4]->IsUint32());

  void* destination;
  size_t destination_byte_length;
  std::tie(destination, destination_byte_length) =
      DecomposeBufferToParts(args[0]);

  void* source;
  size_t source_byte_length;
  std::tie(source, source_byte_length) = DecomposeBufferToParts(args[2]);

  uint32_t destination_offset = args[1].As<Uint32>()->Value();
  uint32_t source_offset = args[3].As<Uint32>()->Value();
  size_t bytes_to_copy = args[4].As<Uint32>()->Value();

  CHECK_GE(destination_byte_length - destination_offset, bytes_to_c...",1,1,node_buffer.cc,node.Buffer.anonymous_namespace_49.CopyArrayBuffer,,false,1225,1257,CopyArrayBuffer,,,25,void node.Buffer.anonymous_namespace_49.CopyArrayBuffer (FunctionCallbackInfo<Value>)
146844,METHOD,node_buffer.cc:<global>,TYPE_DECL,"void Initialize(Local<Object> target,
                Local<Value> unused,
                Local<Context> context,
                void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  SetMethod(context, target, ""setBufferPrototype"", SetBufferPrototype);
  SetMethodNoSideEffect(context, target, ""createFromString"", CreateFromString);

  SetFastMethodNoSideEffect(context,
                            target,
                            ""byteLengthUtf8"",
                            SlowByteLengthUtf8,
                            &fast_byte_length_utf8);
  SetMethod(context, target, ""copy"", Copy);
  SetMethodNoSideEffect(context, target, ""compare"", Compare);
  SetMethodNoSideEffect(context, target, ""compareOffset"", CompareOffset);
  SetMethod(context, target, ""fill"", Fill);
  SetMethodNoSideEffect(context, target, ""indexOfBuffer"", IndexOfBuffer);
  SetMethodNoSideEffect(context, target, ""indexOfNumber"", IndexOfNumber);
  SetMethodNoS...",1,1,node_buffer.cc,node.Buffer.anonymous_namespace_54.Initialize,,false,1259,1322,Initialize,,,26,"void node.Buffer.anonymous_namespace_54.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
147065,METHOD,node_buffer.cc:<global>,TYPE_DECL,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(SetBufferPrototype);
  registry->Register(CreateFromString);

  registry->Register(SlowByteLengthUtf8);
  registry->Register(fast_byte_length_utf8.GetTypeInfo());
  registry->Register(FastByteLengthUtf8);
  registry->Register(Copy);
  registry->Register(Compare);
  registry->Register(CompareOffset);
  registry->Register(Fill);
  registry->Register(IndexOfBuffer);
  registry->Register(IndexOfNumber);
  registry->Register(IndexOfString);

  registry->Register(Swap16);
  registry->Register(Swap32);
  registry->Register(Swap64);

  registry->Register(IsUtf8);
  registry->Register(IsAscii);

  registry->Register(StringSlice<ASCII>);
  registry->Register(StringSlice<BASE64>);
  registry->Register(StringSlice<BASE64URL>);
  registry->Register(StringSlice<LATIN1>);
  registry->Register(StringSlice<HEX>);
  registry->Register(StringSlice<UCS2>);
  registry->Register(StringSlice<UTF8>);

  registry->Re...",1,1,node_buffer.cc,node.Buffer.RegisterExternalReferences,,false,1326,1367,RegisterExternalReferences,,,20,void node.Buffer.RegisterExternalReferences (ExternalReferenceRegistry*)
147251,METHOD,node_buffer.hpp:<global>,TYPE_DECL,<global>,1,1,node_buffer.hpp,node_buffer.hpp:<global>,,false,1,92,<global>,,,1,
147263,METHOD,node_buffer.hpp:<global>,TYPE_DECL,"typedef void (*FreeCallback)(char* data, void* hint);",14,52,node_buffer.hpp,node.Buffer.FreeCallback,,false,34,34,FreeCallback,,,3,"void node.Buffer.FreeCallback (char*,void*)"
147269,METHOD,node_buffer.hpp:<global>,TYPE_DECL,bool bool (v8::Local<v8::Value>);,18,54,node_buffer.hpp,node.Buffer.HasInstance,,false,36,36,HasInstance,,,4,bool node.Buffer.HasInstance (ANY)
147274,METHOD,node_buffer.hpp:<global>,TYPE_DECL,char char *(v8::Local<v8::Value>);,17,48,node_buffer.hpp,node.Buffer.Data,,false,38,38,Data,,,5,char* node.Buffer.Data (ANY)
147279,METHOD,node_buffer.hpp:<global>,TYPE_DECL,size_t size_t (v8::Local<v8::Value>);,20,51,node_buffer.hpp,node.Buffer.Length,,false,40,40,Length,,,6,size_t node.Buffer.Length (ANY)
147284,METHOD,node_buffer.hpp:<global>,TYPE_DECL,"v8::MaybeLocal<v8::Object> v8::MaybeLocal<v8::Object> (v8::Isolate *, const char *, size_t);",40,55,node_buffer.hpp,node.Buffer.Copy,,false,44,46,Copy,,,7,"ANY node.Buffer.Copy (ANY*,char*,size_t)"
147291,METHOD,node_buffer.hpp:<global>,TYPE_DECL,"v8::MaybeLocal<v8::Object> v8::MaybeLocal<v8::Object> (v8::Isolate *, size_t);",40,79,node_buffer.hpp,node.Buffer.New,,false,49,49,New,,,8,"ANY node.Buffer.New (ANY*,size_t)"
147297,METHOD,node_buffer.hpp:<global>,TYPE_DECL,"v8::MaybeLocal<v8::Object> v8::MaybeLocal<v8::Object> (v8::Isolate *, v8::Local<v8::String>, encoding);",40,68,node_buffer.hpp,node.Buffer.New,,false,52,54,New,,,9,"ANY node.Buffer.New (ANY*,ANY,encoding)"
147304,METHOD,node_buffer.hpp:<global>,TYPE_DECL,"v8::MaybeLocal<v8::Object> v8::MaybeLocal<v8::Object> (v8::Isolate *, char *, size_t, FreeCallback, void *);",40,54,node_buffer.hpp,node.Buffer.New,,false,57,61,New,,,10,"ANY node.Buffer.New (ANY*,char*,size_t,FreeCallback,void*)"
147313,METHOD,node_buffer.hpp:<global>,TYPE_DECL,"v8::MaybeLocal<v8::Object> v8::MaybeLocal<v8::Object> (v8::Isolate *, char *, size_t);",40,54,node_buffer.hpp,node.Buffer.New,,false,64,66,New,,,11,"ANY node.Buffer.New (ANY*,char*,size_t)"
147320,METHOD,node_buffer.hpp:<global>,TYPE_DECL,"v8::MaybeLocal<v8::Uint8Array> v8::MaybeLocal<v8::Uint8Array> (v8::Isolate *, v8::Local<v8::ArrayBuffer>, size_t, size_t);",44,61,node_buffer.hpp,node.Buffer.New,,false,69,72,New,,,12,"ANY node.Buffer.New (ANY*,ANY,size_t,size_t)"
147328,METHOD,node_buffer.hpp:<global>,TYPE_DECL,"static inline bool IsWithinBounds(size_t off, size_t len, size_t max) {
  // Asking to seek too far into the buffer
  // check to avoid wrapping in subsequent subtraction
  if (off > max)
    return false;

  // Asking for more than is left over in the buffer
  if (max - off < len)
    return false;

  // Otherwise we're in bounds
  return true;
}",1,1,node_buffer.hpp,node.Buffer.IsWithinBounds,,false,75,87,IsWithinBounds,,,13,"bool node.Buffer.IsWithinBounds (size_t,size_t,size_t)"
147372,METHOD,node_builtins.cc:<global>,TYPE_DECL,<global>,1,31,node_builtins.hpp,node_builtins.cc:<global>,,false,1,740,<global>,,,1,
147376,METHOD,node_builtins.cc:<global>,TYPE_DECL,"BuiltinLoader::BuiltinLoader()
    : config_(GetConfig()), code_cache_(std::make_shared<BuiltinCodeCache>()) {
  LoadJavaScriptSource();
#ifdef NODE_SHARED_BUILTIN_CJS_MODULE_LEXER_LEXER_PATH
  AddExternalizedBuiltin(
      ""internal/deps/cjs-module-lexer/lexer"",
      STRINGIFY(NODE_SHARED_BUILTIN_CJS_MODULE_LEXER_LEXER_PATH));
#endif  // NODE_SHARED_BUILTIN_CJS_MODULE_LEXER_LEXER_PATH

#ifdef NODE_SHARED_BUILTIN_CJS_MODULE_LEXER_DIST_LEXER_PATH
  AddExternalizedBuiltin(
      ""internal/deps/cjs-module-lexer/dist/lexer"",
      STRINGIFY(NODE_SHARED_BUILTIN_CJS_MODULE_LEXER_DIST_LEXER_PATH));
#endif  // NODE_SHARED_BUILTIN_CJS_MODULE_LEXER_DIST_LEXER_PATH

#ifdef NODE_SHARED_BUILTIN_UNDICI_UNDICI_PATH
  AddExternalizedBuiltin(""internal/deps/undici/undici"",
                         STRINGIFY(NODE_SHARED_BUILTIN_UNDICI_UNDICI_PATH));
#endif  // NODE_SHARED_BUILTIN_UNDICI_UNDICI_PATH
}",1,1,node_builtins.cc,node.builtins.BuiltinLoader.BuiltinLoader,,false,35,54,BuiltinLoader,,,1,ANY node.builtins.BuiltinLoader.BuiltinLoader ()
147381,METHOD,node_builtins.cc:<global>,TYPE_DECL,"bool BuiltinLoader::Exists(const char* id) {
  auto source = source_.read();
  return source->find(id) != source->end();
}",1,1,node_builtins.cc,node.builtins.BuiltinLoader.Exists,,false,56,59,Exists,,,2,bool node.builtins.BuiltinLoader.Exists (char*)
147404,METHOD,node_builtins.cc:<global>,TYPE_DECL,"bool BuiltinLoader::Add(const char* id, const UnionBytes& source) {
  auto result = source_.write()->emplace(id, source);
  return result.second;
}",1,1,node_builtins.cc,node.builtins.BuiltinLoader.Add,,false,61,64,Add,,,3,"bool node.builtins.BuiltinLoader.Add (char*,UnionBytes)"
147426,METHOD,node_builtins.cc:<global>,TYPE_DECL,"void BuiltinLoader::GetNatives(Local<Name> property,
                               const PropertyCallbackInfo<Value>& info) {
  Environment* env = Environment::GetCurrent(info);
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();

  Local<Object> out = Object::New(isolate);
  auto source = env->builtin_loader()->source_.read();
  for (auto const& x : *source) {
    Local<String> key = OneByteString(isolate, x.first.c_str(), x.first.size());
    out->Set(context, key, x.second.ToStringChecked(isolate)).FromJust();
  }
  info.GetReturnValue().Set(out);
}",1,1,node_builtins.cc,node.builtins.BuiltinLoader.GetNatives,,false,66,79,GetNatives,,,4,"void node.builtins.BuiltinLoader.GetNatives (Local<Name>,PropertyCallbackInfo<Value>)"
147529,METHOD,node_builtins.cc:<global>,TYPE_DECL,"Local<String> BuiltinLoader::GetConfigString(Isolate* isolate) {
  return config_.ToStringChecked(isolate);
}",1,1,node_builtins.cc,node.builtins.BuiltinLoader.GetConfigString,,false,81,83,GetConfigString,,,5,Local<String> node.builtins.BuiltinLoader.GetConfigString (Isolate*)
147540,METHOD,node_builtins.cc:<global>,TYPE_DECL,"std::vector<std::string> BuiltinLoader::GetBuiltinIds() const {
  std::vector<std::string> ids;
  auto source = source_.read();
  ids.reserve(source->size());
  for (auto const& x : *source) {
    ids.emplace_back(x.first);
  }
  return ids;
}",1,1,node_builtins.cc,node.builtins.BuiltinLoader.GetBuiltinIds,,false,85,93,GetBuiltinIds,,,6,vector<std::string> node.builtins.BuiltinLoader.GetBuiltinIds ()
147582,METHOD,node_builtins.cc:<global>,TYPE_DECL,"BuiltinLoader::BuiltinCategories BuiltinLoader::GetBuiltinCategories() const {
  BuiltinCategories builtin_categories;

  std::vector<std::string> prefixes = {
#if !HAVE_OPENSSL
    ""internal/crypto/"",
    ""internal/debugger/"",
#endif  // !HAVE_OPENSSL

    ""internal/bootstrap/"",
    ""internal/per_context/"",
    ""internal/deps/"",
    ""internal/main/""
  };

  builtin_categories.can_be_required.emplace(
      ""internal/deps/cjs-module-lexer/lexer"");

  builtin_categories.cannot_be_required = std::set<std::string> {
#if !HAVE_INSPECTOR
    ""inspector"", ""inspector/promises"", ""internal/util/inspector"",
#endif  // !HAVE_INSPECTOR

#if !NODE_USE_V8_PLATFORM || !defined(NODE_HAVE_I18N_SUPPORT)
        ""trace_events"",
#endif  // !NODE_USE_V8_PLATFORM || !defined(NODE_HAVE_I18N_SUPPORT)

#if !HAVE_OPENSSL
        ""crypto"", ""crypto/promises"", ""https"", ""http2"", ""tls"", ""_tls_common"",
        ""_tls_wrap"", ""internal/tls/secure-pair"",
        ""internal/tls/parse-cert-string"", ""internal/tls/secure-c...",1,1,node_builtins.cc,node.builtins.BuiltinLoader.GetBuiltinCategories,,false,95,158,GetBuiltinCategories,,,7,BuiltinCategories node.builtins.BuiltinLoader.GetBuiltinCategories ()
147725,METHOD,node_builtins.cc:<global>,TYPE_DECL,"MaybeLocal<String> BuiltinLoader::LoadBuiltinSource(Isolate* isolate,
                                                    const char* id) const {
  auto source = source_.read();
#ifndef NODE_BUILTIN_MODULES_PATH
  const auto source_it = source->find(id);
  if (UNLIKELY(source_it == source->end())) {
    fprintf(stderr, ""Cannot find native builtin: \""%s\"".\n"", id);
    ABORT();
  }
  return source_it->second.ToStringChecked(isolate);
#else   // !NODE_BUILTIN_MODULES_PATH
  std::string filename = OnDiskFileName(id);

  std::string contents;
  int r = ReadFileSync(&contents, filename.c_str());
  if (r != 0) {
    const std::string buf = SPrintF(""Cannot read local builtin. %s: %s \""%s\"""",
                                    uv_err_name(r),
                                    uv_strerror(r),
                                    filename);
    Local<String> message = OneByteString(isolate, buf.c_str());
    isolate->ThrowException(v8::Exception::Error(message));
    return MaybeLocal<Strin...",1,1,node_builtins.cc,node.builtins.BuiltinLoader.LoadBuiltinSource,,false,177,204,LoadBuiltinSource,,,8,"MaybeLocal<String> node.builtins.BuiltinLoader.LoadBuiltinSource (Isolate*,char*)"
147771,METHOD,node_builtins.cc:<global>,TYPE_DECL,"void BuiltinLoader::AddExternalizedBuiltin(const char* id,
                                           const char* filename) {
  StaticExternalTwoByteResource* resource;
  {
    Mutex::ScopedLock lock(externalized_builtins_mutex);
    auto it = externalized_builtin_sources.find(id);
    if (it == externalized_builtin_sources.end()) {
      std::string source;
      int r = ReadFileSync(&source, filename);
      if (r != 0) {
        fprintf(stderr,
                ""Cannot load externalized builtin: \""%s:%s\"".\n"",
                id,
                filename);
        ABORT();
      }
      size_t expected_u16_length =
          simdutf::utf16_length_from_utf8(source.data(), source.length());
      auto out = std::make_shared<std::vector<uint16_t>>(expected_u16_length);
      size_t u16_length = simdutf::convert_utf8_to_utf16(
          source.data(),
          source.length(),
          reinterpret_cast<char16_t*>(out->data()));
      out->resize(u16_length);

      auto result = ext...",1,1,node_builtins.cc,node.builtins.BuiltinLoader.AddExternalizedBuiltin,,false,212,251,AddExternalizedBuiltin,,,10,"void node.builtins.BuiltinLoader.AddExternalizedBuiltin (char*,char*)"
147918,METHOD,node_builtins.cc:<global>,TYPE_DECL,"MaybeLocal<Function> BuiltinLoader::LookupAndCompileInternal(
    Local<Context> context,
    const char* id,
    std::vector<Local<String>>* parameters,
    BuiltinLoader::Result* result) {
  Isolate* isolate = context->GetIsolate();
  EscapableHandleScope scope(isolate);

  Local<String> source;
  if (!LoadBuiltinSource(isolate, id).ToLocal(&source)) {
    return {};
  }

  std::string filename_s = std::string(""node:"") + id;
  Local<String> filename =
      OneByteString(isolate, filename_s.c_str(), filename_s.size());
  ScriptOrigin origin(isolate, filename, 0, 0, true);

  BuiltinCodeCacheData cached_data{};
  {
    // Note: The lock here should not extend into the
    // `CompileFunction()` call below, because this function may recurse if
    // there is a syntax error during bootstrap (because the fatal exception
    // handler is invoked, which may load built-in modules).
    RwLock::ScopedLock lock(code_cache_->mutex);
    auto cache_it = code_cache_->map.find(id);
    if (c...",1,1,node_builtins.cc,node.builtins.BuiltinLoader.LookupAndCompileInternal,,false,253,355,LookupAndCompileInternal,,,11,"MaybeLocal<Function> node.builtins.BuiltinLoader.LookupAndCompileInternal (Local<Context>,char*,ANY*,ANY*)"
148168,METHOD,node_builtins.cc:<global>,TYPE_DECL,"std::shared_ptr<ScriptCompiler::CachedData> new_cached_data(
        ScriptCompiler::CreateCodeCacheForFunction(fun));",49,56,node_builtins.cc,node.builtins.BuiltinLoader.LookupAndCompileInternal.new_cached_data,,false,343,344,new_cached_data,,,1,ANY node.builtins.BuiltinLoader.LookupAndCompileInternal.new_cached_data (ANY)
148202,METHOD,node_builtins.cc:<global>,TYPE_DECL,"MaybeLocal<Function> BuiltinLoader::LookupAndCompile(Local<Context> context,
                                                     const char* id,
                                                     Realm* optional_realm) {
  Result result;
  std::vector<Local<String>> parameters;
  Isolate* isolate = context->GetIsolate();
  // Detects parameters of the scripts based on module ids.
  // internal/bootstrap/realm: process, getLinkedBinding,
  //                           getInternalBinding, primordials
  if (strcmp(id, ""internal/bootstrap/realm"") == 0) {
    parameters = {
        FIXED_ONE_BYTE_STRING(isolate, ""process""),
        FIXED_ONE_BYTE_STRING(isolate, ""getLinkedBinding""),
        FIXED_ONE_BYTE_STRING(isolate, ""getInternalBinding""),
        FIXED_ONE_BYTE_STRING(isolate, ""primordials""),
    };
  } else if (strncmp(id,
                     ""internal/per_context/"",
                     strlen(""internal/per_context/"")) == 0) {
    // internal/per_context/*: global, exports, pr...",1,1,node_builtins.cc,node.builtins.BuiltinLoader.LookupAndCompile,,false,357,412,LookupAndCompile,,,12,"MaybeLocal<Function> node.builtins.BuiltinLoader.LookupAndCompile (Local<Context>,char*,Realm*)"
148306,METHOD,node_builtins.cc:<global>,TYPE_DECL,"MaybeLocal<Value> BuiltinLoader::CompileAndCall(Local<Context> context,
                                                const char* id,
                                                Realm* realm) {
  Isolate* isolate = context->GetIsolate();
  // Arguments must match the parameters specified in
  // BuiltinLoader::LookupAndCompile().
  std::vector<Local<Value>> arguments;
  // Detects parameters of the scripts based on module ids.
  // internal/bootstrap/realm: process, getLinkedBinding,
  //                           getInternalBinding, primordials
  if (strcmp(id, ""internal/bootstrap/realm"") == 0) {
    Local<Value> get_linked_binding;
    Local<Value> get_internal_binding;
    if (!NewFunctionTemplate(isolate, binding::GetLinkedBinding)
             ->GetFunction(context)
             .ToLocal(&get_linked_binding) ||
        !NewFunctionTemplate(isolate, binding::GetInternalBinding)
             ->GetFunction(context)
             .ToLocal(&get_internal_binding)) {
      return...",1,1,node_builtins.cc,node.builtins.BuiltinLoader.CompileAndCall,,false,414,459,CompileAndCall,,,13,"MaybeLocal<Value> node.builtins.BuiltinLoader.CompileAndCall (Local<Context>,char*,Realm*)"
148420,METHOD,node_builtins.cc:<global>,TYPE_DECL,"MaybeLocal<Value> BuiltinLoader::CompileAndCall(Local<Context> context,
                                                const char* id,
                                                int argc,
                                                Local<Value> argv[],
                                                Realm* optional_realm) {
  // Arguments must match the parameters specified in
  // BuiltinLoader::LookupAndCompile().
  MaybeLocal<Function> maybe_fn = LookupAndCompile(context, id, optional_realm);
  Local<Function> fn;
  if (!maybe_fn.ToLocal(&fn)) {
    return MaybeLocal<Value>();
  }
  Local<Value> undefined = Undefined(context->GetIsolate());
  return fn->Call(context, undefined, argc, argv);
}",1,1,node_builtins.cc,node.builtins.BuiltinLoader.CompileAndCall,,false,461,475,CompileAndCall,,,14,"MaybeLocal<Value> node.builtins.BuiltinLoader.CompileAndCall (Local<Context>,char*,int,Local<Value>[],Realm*)"
148475,METHOD,node_builtins.cc:<global>,TYPE_DECL,"bool BuiltinLoader::CompileAllBuiltins(Local<Context> context) {
  std::vector<std::string> ids = GetBuiltinIds();
  bool all_succeeded = true;
  std::string v8_tools_prefix = ""internal/deps/v8/tools/"";
  for (const auto& id : ids) {
    if (id.compare(0, v8_tools_prefix.size(), v8_tools_prefix) == 0) {
      continue;
    }
    v8::TryCatch bootstrapCatch(context->GetIsolate());
    USE(LookupAndCompile(context, id.c_str(), nullptr));
    if (bootstrapCatch.HasCaught()) {
      per_process::Debug(DebugCategory::CODE_CACHE,
                         ""Failed to compile code cache for %s\n"",
                         id.c_str());
      all_succeeded = false;
      PrintCaughtException(context->GetIsolate(), context, bootstrapCatch);
    }
  }
  return all_succeeded;
}",1,1,node_builtins.cc,node.builtins.BuiltinLoader.CompileAllBuiltins,,false,477,496,CompileAllBuiltins,,,15,bool node.builtins.BuiltinLoader.CompileAllBuiltins (Local<Context>)
148562,METHOD,node_builtins.cc:<global>,TYPE_DECL,"void BuiltinLoader::CopyCodeCache(std::vector<CodeCacheInfo>* out) const {
  RwLock::ScopedReadLock lock(code_cache_->mutex);
  for (auto const& item : code_cache_->map) {
    out->push_back({item.first, item.second});
  }
}",1,1,node_builtins.cc,node.builtins.BuiltinLoader.CopyCodeCache,,false,498,503,CopyCodeCache,,,16,void node.builtins.BuiltinLoader.CopyCodeCache (ANY*)
148589,METHOD,node_builtins.cc:<global>,TYPE_DECL,"void BuiltinLoader::RefreshCodeCache(const std::vector<CodeCacheInfo>& in) {
  RwLock::ScopedLock lock(code_cache_->mutex);
  code_cache_->map.reserve(in.size());
  DCHECK(code_cache_->map.empty());
  for (auto const& item : in) {
    auto result = code_cache_->map.emplace(item.id, item.data);
    USE(result.second);
    DCHECK(result.second);
  }
  code_cache_->has_code_cache = true;
}",1,1,node_builtins.cc,node.builtins.BuiltinLoader.RefreshCodeCache,,false,505,515,RefreshCodeCache,,,17,void node.builtins.BuiltinLoader.RefreshCodeCache (ANY)
148648,METHOD,node_builtins.cc:<global>,TYPE_DECL,"void BuiltinLoader::GetBuiltinCategories(
    Local<Name> property, const PropertyCallbackInfo<Value>& info) {
  Environment* env = Environment::GetCurrent(info);
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();
  Local<Object> result = Object::New(isolate);

  BuiltinCategories builtin_categories =
      env->builtin_loader()->GetBuiltinCategories();

  if (!env->owns_process_state()) {
    builtin_categories.can_be_required.erase(""trace_events"");
    builtin_categories.cannot_be_required.insert(""trace_events"");
  }

  Local<Value> cannot_be_required_js;
  Local<Value> can_be_required_js;

  if (!ToV8Value(context, builtin_categories.cannot_be_required)
           .ToLocal(&cannot_be_required_js))
    return;
  if (result
          ->Set(context,
                OneByteString(isolate, ""cannotBeRequired""),
                cannot_be_required_js)
          .IsNothing())
    return;
  if (!ToV8Value(context, builtin_categories.can_be_required)
           ...",1,1,node_builtins.cc,node.builtins.BuiltinLoader.GetBuiltinCategories,,false,517,555,GetBuiltinCategories,,,18,"void node.builtins.BuiltinLoader.GetBuiltinCategories (Local<Name>,PropertyCallbackInfo<Value>)"
148797,METHOD,node_builtins.cc:<global>,TYPE_DECL,"void BuiltinLoader::GetCacheUsage(const FunctionCallbackInfo<Value>& args) {
  Realm* realm = Realm::GetCurrent(args);
  Isolate* isolate = realm->isolate();
  Local<Context> context = realm->context();
  Local<Object> result = Object::New(isolate);

  Local<Value> builtins_with_cache_js;
  Local<Value> builtins_without_cache_js;
  Local<Value> builtins_in_snapshot_js;
  if (!ToV8Value(context, realm->builtins_with_cache)
           .ToLocal(&builtins_with_cache_js)) {
    return;
  }
  if (result
          ->Set(context,
                OneByteString(isolate, ""compiledWithCache""),
                builtins_with_cache_js)
          .IsNothing()) {
    return;
  }

  if (!ToV8Value(context, realm->builtins_without_cache)
           .ToLocal(&builtins_without_cache_js)) {
    return;
  }
  if (result
          ->Set(context,
                OneByteString(isolate, ""compiledWithoutCache""),
                builtins_without_cache_js)
          .IsNothing()) {
    return;
  }

  if (!ToV8Va...",1,1,node_builtins.cc,node.builtins.BuiltinLoader.GetCacheUsage,,false,557,603,GetCacheUsage,,,19,void node.builtins.BuiltinLoader.GetCacheUsage (FunctionCallbackInfo<Value>)
148948,METHOD,node_builtins.cc:<global>,TYPE_DECL,"void BuiltinLoader::BuiltinIdsGetter(Local<Name> property,
                                     const PropertyCallbackInfo<Value>& info) {
  Environment* env = Environment::GetCurrent(info);
  Isolate* isolate = env->isolate();

  std::vector<std::string> ids = env->builtin_loader()->GetBuiltinIds();
  info.GetReturnValue().Set(
      ToV8Value(isolate->GetCurrentContext(), ids).ToLocalChecked());
}",1,1,node_builtins.cc,node.builtins.BuiltinLoader.BuiltinIdsGetter,,false,605,613,BuiltinIdsGetter,,,20,"void node.builtins.BuiltinLoader.BuiltinIdsGetter (Local<Name>,PropertyCallbackInfo<Value>)"
149002,METHOD,node_builtins.cc:<global>,TYPE_DECL,"void BuiltinLoader::ConfigStringGetter(
    Local<Name> property, const PropertyCallbackInfo<Value>& info) {
  Environment* env = Environment::GetCurrent(info);
  info.GetReturnValue().Set(
      env->builtin_loader()->GetConfigString(info.GetIsolate()));
}",1,1,node_builtins.cc,node.builtins.BuiltinLoader.ConfigStringGetter,,false,615,620,ConfigStringGetter,,,21,"void node.builtins.BuiltinLoader.ConfigStringGetter (Local<Name>,PropertyCallbackInfo<Value>)"
149034,METHOD,node_builtins.cc:<global>,TYPE_DECL,"void BuiltinLoader::RecordResult(const char* id,
                                 BuiltinLoader::Result result,
                                 Realm* realm) {
  if (result == BuiltinLoader::Result::kWithCache) {
    realm->builtins_with_cache.insert(id);
  } else {
    realm->builtins_without_cache.insert(id);
  }
}",1,1,node_builtins.cc,node.builtins.BuiltinLoader.RecordResult,,false,622,630,RecordResult,,,22,"void node.builtins.BuiltinLoader.RecordResult (char*,ANY,Realm*)"
149066,METHOD,node_builtins.cc:<global>,TYPE_DECL,"void BuiltinLoader::CompileFunction(const FunctionCallbackInfo<Value>& args) {
  Realm* realm = Realm::GetCurrent(args);
  CHECK(args[0]->IsString());
  node::Utf8Value id_v(realm->isolate(), args[0].As<String>());
  const char* id = *id_v;
  MaybeLocal<Function> maybe = realm->env()->builtin_loader()->LookupAndCompile(
      realm->context(), id, realm);
  Local<Function> fn;
  if (maybe.ToLocal(&fn)) {
    args.GetReturnValue().Set(fn);
  }
}",1,1,node_builtins.cc,node.builtins.BuiltinLoader.CompileFunction,,false,632,643,CompileFunction,,,23,void node.builtins.BuiltinLoader.CompileFunction (FunctionCallbackInfo<Value>)
149146,METHOD,node_builtins.cc:<global>,TYPE_DECL,"void BuiltinLoader::HasCachedBuiltins(const FunctionCallbackInfo<Value>& args) {
  auto instance = Environment::GetCurrent(args)->builtin_loader();
  RwLock::ScopedReadLock lock(instance->code_cache_->mutex);
  args.GetReturnValue().Set(v8::Boolean::New(
      args.GetIsolate(), instance->code_cache_->has_code_cache));
}",1,1,node_builtins.cc,node.builtins.BuiltinLoader.HasCachedBuiltins,,false,645,650,HasCachedBuiltins,,,24,void node.builtins.BuiltinLoader.HasCachedBuiltins (FunctionCallbackInfo<Value>)
149191,METHOD,node_builtins.cc:<global>,TYPE_DECL,"void SetInternalLoaders(const FunctionCallbackInfo<Value>& args) {
  Realm* realm = Realm::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  CHECK(args[1]->IsFunction());
  DCHECK(realm->internal_binding_loader().IsEmpty());
  DCHECK(realm->builtin_module_require().IsEmpty());
  realm->set_internal_binding_loader(args[0].As<Function>());
  realm->set_builtin_module_require(args[1].As<Function>());
}",1,1,node_builtins.cc,node.builtins.SetInternalLoaders,,false,652,660,SetInternalLoaders,,,25,void node.builtins.SetInternalLoaders (FunctionCallbackInfo<Value>)
149254,METHOD,node_builtins.cc:<global>,TYPE_DECL,"void BuiltinLoader::CopySourceAndCodeCacheReferenceFrom(
    const BuiltinLoader* other) {
  code_cache_ = other->code_cache_;
  source_ = other->source_;
}",1,1,node_builtins.cc,node.builtins.BuiltinLoader.CopySourceAndCodeCacheReferenceFrom,,false,662,666,CopySourceAndCodeCacheReferenceFrom,,,26,void node.builtins.BuiltinLoader.CopySourceAndCodeCacheReferenceFrom (BuiltinLoader*)
149269,METHOD,node_builtins.cc:<global>,TYPE_DECL,"void BuiltinLoader::CreatePerIsolateProperties(IsolateData* isolate_data,
                                               Local<ObjectTemplate> target) {
  Isolate* isolate = isolate_data->isolate();

  target->SetAccessor(isolate_data->config_string(),
                      ConfigStringGetter,
                      nullptr,
                      Local<Value>(),
                      DEFAULT,
                      None,
                      SideEffectType::kHasNoSideEffect);

  target->SetAccessor(FIXED_ONE_BYTE_STRING(isolate, ""builtinIds""),
                      BuiltinIdsGetter,
                      nullptr,
                      Local<Value>(),
                      DEFAULT,
                      None,
                      SideEffectType::kHasNoSideEffect);

  target->SetAccessor(FIXED_ONE_BYTE_STRING(isolate, ""builtinCategories""),
                      GetBuiltinCategories,
                      nullptr,
                      Local<Value>(),
                      DEFAULT,
   ...",1,1,node_builtins.cc,node.builtins.BuiltinLoader.CreatePerIsolateProperties,,false,668,708,CreatePerIsolateProperties,,,27,"void node.builtins.BuiltinLoader.CreatePerIsolateProperties (IsolateData*,Local<ObjectTemplate>)"
149367,METHOD,node_builtins.cc:<global>,TYPE_DECL,"void BuiltinLoader::CreatePerContextProperties(Local<Object> target,
                                               Local<Value> unused,
                                               Local<Context> context,
                                               void* priv) {
  // internalBinding('builtins') should be frozen
  target->SetIntegrityLevel(context, IntegrityLevel::kFrozen).FromJust();
}",1,1,node_builtins.cc,node.builtins.BuiltinLoader.CreatePerContextProperties,,false,710,716,CreatePerContextProperties,,,28,"void node.builtins.BuiltinLoader.CreatePerContextProperties (Local<Object>,Local<Value>,Local<Context>,void*)"
149386,METHOD,node_builtins.cc:<global>,TYPE_DECL,"void BuiltinLoader::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(ConfigStringGetter);
  registry->Register(BuiltinIdsGetter);
  registry->Register(GetBuiltinCategories);
  registry->Register(GetCacheUsage);
  registry->Register(CompileFunction);
  registry->Register(HasCachedBuiltins);
  registry->Register(SetInternalLoaders);
  registry->Register(GetNatives);

  RegisterExternalReferencesForInternalizedBuiltinCode(registry);
}",1,1,node_builtins.cc,node.builtins.BuiltinLoader.RegisterExternalReferences,,false,718,730,RegisterExternalReferences,,,29,void node.builtins.BuiltinLoader.RegisterExternalReferences (ExternalReferenceRegistry*)
149461,METHOD,node_builtins.hpp:<global>,TYPE_DECL,<global>,1,31,node_builtins.hpp,node_builtins.hpp:<global>,,false,1,196,<global>,,,1,
149480,METHOD,node_config.cc:<global>,TYPE_DECL,<global>,1,25,env-inl.hpp,node_config.cc:<global>,,false,1,83,<global>,,,1,
149483,METHOD,node_config.cc:<global>,TYPE_DECL,"static void Initialize(Local<Object> target,
                       Local<Value> unused,
                       Local<Context> context,
                       void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

#if defined(DEBUG) && DEBUG
  READONLY_TRUE_PROPERTY(target, ""isDebugBuild"");
#else
  READONLY_FALSE_PROPERTY(target, ""isDebugBuild"");
#endif  // defined(DEBUG) && DEBUG

#if HAVE_OPENSSL
  READONLY_TRUE_PROPERTY(target, ""hasOpenSSL"");
#else
  READONLY_FALSE_PROPERTY(target, ""hasOpenSSL"");
#endif  // HAVE_OPENSSL

  READONLY_TRUE_PROPERTY(target, ""fipsMode"");

#ifdef NODE_HAVE_I18N_SUPPORT

  READONLY_TRUE_PROPERTY(target, ""hasIntl"");

#ifdef NODE_HAVE_SMALL_ICU
  READONLY_TRUE_PROPERTY(target, ""hasSmallICU"");
#endif  // NODE_HAVE_SMALL_ICU

#if NODE_USE_V8_PLATFORM
  READONLY_TRUE_PROPERTY(target, ""hasTracing"");
#endif

#if !defined(NODE_WITHOUT_NODE_OPTIONS)
  READONLY_TRUE_PROPERTY(target, ""hasNodeOptions"");
#endif

#e...",1,1,node_config.cc,node.Initialize,,false,26,79,Initialize,,,1,"void node.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
149571,METHOD,node_constants.cc:<global>,TYPE_DECL,<global>,1,1,node_constants.cc,node_constants.cc:<global>,,false,1,1368,<global>,,,1,
149575,METHOD,node_constants.cc:<global>,TYPE_DECL,"void DefineErrnoConstants(Local<Object> target) {
#ifdef E2BIG
  NODE_DEFINE_CONSTANT(target, E2BIG);
#endif

#ifdef EACCES
  NODE_DEFINE_CONSTANT(target, EACCES);
#endif

#ifdef EADDRINUSE
  NODE_DEFINE_CONSTANT(target, EADDRINUSE);
#endif

#ifdef EADDRNOTAVAIL
  NODE_DEFINE_CONSTANT(target, EADDRNOTAVAIL);
#endif

#ifdef EAFNOSUPPORT
  NODE_DEFINE_CONSTANT(target, EAFNOSUPPORT);
#endif

#ifdef EAGAIN
  NODE_DEFINE_CONSTANT(target, EAGAIN);
#endif

#ifdef EALREADY
  NODE_DEFINE_CONSTANT(target, EALREADY);
#endif

#ifdef EBADF
  NODE_DEFINE_CONSTANT(target, EBADF);
#endif

#ifdef EBADMSG
  NODE_DEFINE_CONSTANT(target, EBADMSG);
#endif

#ifdef EBUSY
  NODE_DEFINE_CONSTANT(target, EBUSY);
#endif

#ifdef ECANCELED
  NODE_DEFINE_CONSTANT(target, ECANCELED);
#endif

#ifdef ECHILD
  NODE_DEFINE_CONSTANT(target, ECHILD);
#endif

#ifdef ECONNABORTED
  NODE_DEFINE_CONSTANT(target, ECONNABORTED);
#endif

#ifdef ECONNREFUSED
  NODE_DEFINE_CONSTANT(target, ECONNREFUSED);
#endif

#ifdef ECONNRES...",1,1,node_constants.cc,node.constants.DefineErrnoConstants,,false,75,391,DefineErrnoConstants,,,1,void node.constants.DefineErrnoConstants (Local<Object>)
149580,METHOD,node_constants.cc:<global>,TYPE_DECL,"void DefineWindowsErrorConstants(Local<Object> target) {
#ifdef WSAEINTR
  NODE_DEFINE_CONSTANT(target, WSAEINTR);
#endif

#ifdef WSAEBADF
  NODE_DEFINE_CONSTANT(target, WSAEBADF);
#endif

#ifdef WSAEACCES
  NODE_DEFINE_CONSTANT(target, WSAEACCES);
#endif

#ifdef WSAEFAULT
  NODE_DEFINE_CONSTANT(target, WSAEFAULT);
#endif

#ifdef WSAEINVAL
  NODE_DEFINE_CONSTANT(target, WSAEINVAL);
#endif

#ifdef WSAEMFILE
  NODE_DEFINE_CONSTANT(target, WSAEMFILE);
#endif

#ifdef WSAEWOULDBLOCK
  NODE_DEFINE_CONSTANT(target, WSAEWOULDBLOCK);
#endif

#ifdef WSAEINPROGRESS
  NODE_DEFINE_CONSTANT(target, WSAEINPROGRESS);
#endif

#ifdef WSAEALREADY
  NODE_DEFINE_CONSTANT(target, WSAEALREADY);
#endif

#ifdef WSAENOTSOCK
  NODE_DEFINE_CONSTANT(target, WSAENOTSOCK);
#endif

#ifdef WSAEDESTADDRREQ
  NODE_DEFINE_CONSTANT(target, WSAEDESTADDRREQ);
#endif

#ifdef WSAEMSGSIZE
  NODE_DEFINE_CONSTANT(target, WSAEMSGSIZE);
#endif

#ifdef WSAEPROTOTYPE
  NODE_DEFINE_CONSTANT(target, WSAEPROTOTYPE);
#endif

#ifdef W...",1,1,node_constants.cc,node.constants.DefineWindowsErrorConstants,,false,393,625,DefineWindowsErrorConstants,,,2,void node.constants.DefineWindowsErrorConstants (Local<Object>)
149585,METHOD,node_constants.cc:<global>,TYPE_DECL,"void DefineSignalConstants(Local<Object> target) {
#ifdef SIGHUP
  NODE_DEFINE_CONSTANT(target, SIGHUP);
#endif

#ifdef SIGINT
  NODE_DEFINE_CONSTANT(target, SIGINT);
#endif

#ifdef SIGQUIT
  NODE_DEFINE_CONSTANT(target, SIGQUIT);
#endif

#ifdef SIGILL
  NODE_DEFINE_CONSTANT(target, SIGILL);
#endif

#ifdef SIGTRAP
  NODE_DEFINE_CONSTANT(target, SIGTRAP);
#endif

#ifdef SIGABRT
  NODE_DEFINE_CONSTANT(target, SIGABRT);
#endif

#ifdef SIGIOT
  NODE_DEFINE_CONSTANT(target, SIGIOT);
#endif

#ifdef SIGBUS
  NODE_DEFINE_CONSTANT(target, SIGBUS);
#endif

#ifdef SIGFPE
  NODE_DEFINE_CONSTANT(target, SIGFPE);
#endif

#ifdef SIGKILL
  NODE_DEFINE_CONSTANT(target, SIGKILL);
#endif

#ifdef SIGUSR1
  NODE_DEFINE_CONSTANT(target, SIGUSR1);
#endif

#ifdef SIGSEGV
  NODE_DEFINE_CONSTANT(target, SIGSEGV);
#endif

#ifdef SIGUSR2
  NODE_DEFINE_CONSTANT(target, SIGUSR2);
#endif

#ifdef SIGPIPE
  NODE_DEFINE_CONSTANT(target, SIGPIPE);
#endif

#ifdef SIGALRM
  NODE_DEFINE_CONSTANT(target, SIGALRM);
#endif...",1,1,node_constants.cc,node.constants.DefineSignalConstants,,false,627,774,DefineSignalConstants,,,3,void node.constants.DefineSignalConstants (Local<Object>)
149593,METHOD,node_constants.cc:<global>,TYPE_DECL,"void DefinePriorityConstants(Local<Object> target) {
#ifdef UV_PRIORITY_LOW
# define PRIORITY_LOW UV_PRIORITY_LOW
  NODE_DEFINE_CONSTANT(target, PRIORITY_LOW);
# undef PRIORITY_LOW
#endif

#ifdef UV_PRIORITY_BELOW_NORMAL
# define PRIORITY_BELOW_NORMAL UV_PRIORITY_BELOW_NORMAL
  NODE_DEFINE_CONSTANT(target, PRIORITY_BELOW_NORMAL);
# undef PRIORITY_BELOW_NORMAL
#endif

#ifdef UV_PRIORITY_NORMAL
# define PRIORITY_NORMAL UV_PRIORITY_NORMAL
  NODE_DEFINE_CONSTANT(target, PRIORITY_NORMAL);
# undef PRIORITY_NORMAL
#endif

#ifdef UV_PRIORITY_ABOVE_NORMAL
# define PRIORITY_ABOVE_NORMAL UV_PRIORITY_ABOVE_NORMAL
  NODE_DEFINE_CONSTANT(target, PRIORITY_ABOVE_NORMAL);
# undef PRIORITY_ABOVE_NORMAL
#endif

#ifdef UV_PRIORITY_HIGH
# define PRIORITY_HIGH UV_PRIORITY_HIGH
  NODE_DEFINE_CONSTANT(target, PRIORITY_HIGH);
# undef PRIORITY_HIGH
#endif

#ifdef UV_PRIORITY_HIGHEST
# define PRIORITY_HIGHEST UV_PRIORITY_HIGHEST
  NODE_DEFINE_CONSTANT(target, PRIORITY_HIGHEST);
# undef PRIORITY_HIGHEST
#endif
}",1,1,node_constants.cc,node.constants.DefinePriorityConstants,,false,776,812,DefinePriorityConstants,,,4,void node.constants.DefinePriorityConstants (Local<Object>)
149598,METHOD,node_constants.cc:<global>,TYPE_DECL,"void DefineCryptoConstants(Local<Object> target) {
#ifdef OPENSSL_VERSION_NUMBER
    NODE_DEFINE_CONSTANT(target, OPENSSL_VERSION_NUMBER);
#endif

#ifdef SSL_OP_ALL
    NODE_DEFINE_CONSTANT(target, SSL_OP_ALL);
#endif

#ifdef SSL_OP_ALLOW_NO_DHE_KEX
    NODE_DEFINE_CONSTANT(target, SSL_OP_ALLOW_NO_DHE_KEX);
#endif

#ifdef SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION
    NODE_DEFINE_CONSTANT(target, SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION);
#endif

#ifdef SSL_OP_CIPHER_SERVER_PREFERENCE
    NODE_DEFINE_CONSTANT(target, SSL_OP_CIPHER_SERVER_PREFERENCE);
#endif

#ifdef SSL_OP_CISCO_ANYCONNECT
    NODE_DEFINE_CONSTANT(target, SSL_OP_CISCO_ANYCONNECT);
#endif

#ifdef SSL_OP_COOKIE_EXCHANGE
    NODE_DEFINE_CONSTANT(target, SSL_OP_COOKIE_EXCHANGE);
#endif

#ifdef SSL_OP_CRYPTOPRO_TLSEXT_BUG
    NODE_DEFINE_CONSTANT(target, SSL_OP_CRYPTOPRO_TLSEXT_BUG);
#endif

#ifdef SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS
    NODE_DEFINE_CONSTANT(target, SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS);
#endif

#ifdef SSL_OP_...",1,1,node_constants.cc,node.constants.DefineCryptoConstants,,false,814,1041,DefineCryptoConstants,,,5,void node.constants.DefineCryptoConstants (Local<Object>)
149603,METHOD,node_constants.cc:<global>,TYPE_DECL,"void DefineSystemConstants(Local<Object> target) {
  NODE_DEFINE_CONSTANT(target, UV_FS_SYMLINK_DIR);
  NODE_DEFINE_CONSTANT(target, UV_FS_SYMLINK_JUNCTION);
  // file access modes
  NODE_DEFINE_CONSTANT(target, O_RDONLY);
  NODE_DEFINE_CONSTANT(target, O_WRONLY);
  NODE_DEFINE_CONSTANT(target, O_RDWR);

  // file types from readdir
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_UNKNOWN);
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_FILE);
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_DIR);
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_LINK);
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_FIFO);
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_SOCKET);
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_CHAR);
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_BLOCK);

  NODE_DEFINE_CONSTANT(target, S_IFMT);
  NODE_DEFINE_CONSTANT(target, S_IFREG);
  NODE_DEFINE_CONSTANT(target, S_IFDIR);
  NODE_DEFINE_CONSTANT(target, S_IFCHR);
#ifdef S_IFBLK
  NODE_DEFINE_CONSTANT(target, S_IFBLK);
#endif

#ifdef S_IFIFO
  NODE_DEFINE_CONSTANT(target,...",1,1,node_constants.cc,node.constants.DefineSystemConstants,,false,1043,1224,DefineSystemConstants,,,6,void node.constants.DefineSystemConstants (Local<Object>)
149662,METHOD,node_constants.cc:<global>,TYPE_DECL,"void DefineDLOpenConstants(Local<Object> target) {
#ifdef RTLD_LAZY
  NODE_DEFINE_CONSTANT(target, RTLD_LAZY);
#endif

#ifdef RTLD_NOW
  NODE_DEFINE_CONSTANT(target, RTLD_NOW);
#endif

#ifdef RTLD_GLOBAL
  NODE_DEFINE_CONSTANT(target, RTLD_GLOBAL);
#endif

#ifdef RTLD_LOCAL
  NODE_DEFINE_CONSTANT(target, RTLD_LOCAL);
#endif

#ifdef RTLD_DEEPBIND
  NODE_DEFINE_CONSTANT(target, RTLD_DEEPBIND);
#endif
}",1,1,node_constants.cc,node.constants.DefineDLOpenConstants,,false,1226,1246,DefineDLOpenConstants,,,7,void node.constants.DefineDLOpenConstants (Local<Object>)
149667,METHOD,node_constants.cc:<global>,TYPE_DECL,"void DefineTraceConstants(Local<Object> target) {
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_BEGIN);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_END);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_COMPLETE);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_INSTANT);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_ASYNC_BEGIN);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_ASYNC_STEP_INTO);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_ASYNC_STEP_PAST);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_ASYNC_END);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_NESTABLE_ASYNC_END);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_NESTABLE_ASYNC_INSTANT);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_FLOW_BEGIN);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_FLOW_STEP);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_FLOW_END);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_METADATA);...",1,1,node_constants.cc,node.constants.DefineTraceConstants,,false,1248,1275,DefineTraceConstants,,,8,void node.constants.DefineTraceConstants (Local<Object>)
149750,METHOD,node_constants.cc:<global>,TYPE_DECL,"void CreatePerContextProperties(Local<Object> target,
                                Local<Value> unused,
                                Local<Context> context,
                                void* priv) {
  Isolate* isolate = context->GetIsolate();
  Environment* env = Environment::GetCurrent(context);

  CHECK(target->SetPrototype(env->context(), Null(env->isolate())).FromJust());

  Local<Object> os_constants = Object::New(isolate);
  CHECK(os_constants->SetPrototype(env->context(),
                                   Null(env->isolate())).FromJust());

  Local<Object> err_constants = Object::New(isolate);
  CHECK(err_constants->SetPrototype(env->context(),
                                    Null(env->isolate())).FromJust());

  Local<Object> sig_constants = Object::New(isolate);
  CHECK(sig_constants->SetPrototype(env->context(),
                                    Null(env->isolate())).FromJust());

  Local<Object> priority_constants = Object::New(isolate);
  CHECK(priority_...",1,1,node_constants.cc,node.constants.CreatePerContextProperties,,false,1277,1362,CreatePerContextProperties,,,9,"void node.constants.CreatePerContextProperties (Local<Object>,Local<Value>,Local<Context>,void*)"
150198,METHOD,node_constants.hpp:<global>,TYPE_DECL,<global>,1,32,node_constants.hpp,node_constants.hpp:<global>,,false,1,79,<global>,,,1,
150207,METHOD,node_context_data.hpp:<global>,TYPE_DECL,<global>,1,35,node_context_data.hpp,node_context_data.hpp:<global>,,false,1,99,<global>,,,1,
150210,METHOD,node_contextify.cc:<global>,TYPE_DECL,"[&] (PropertyDescriptor* desc_for_sandbox) {
        if (desc.has_enumerable()) {
          desc_for_sandbox->set_enumerable(desc.enumerable());
        }
        if (desc.has_configurable()) {
          desc_for_sandbox->set_configurable(desc.configurable());
        }
        // Set the property on the sandbox.
        USE(sandbox->DefineProperty(context, property, *desc_for_sandbox));
      }",7,7,node_contextify.cc,node.contextify.ContextifyContext.PropertyDefinerCallback.<lambda>0,,false,598,607,<lambda>0,,,1,ANY node.contextify.ContextifyContext.PropertyDefinerCallback.<lambda>0 (PropertyDescriptor*)
150256,METHOD,node_contextify.cc:<global>,TYPE_DECL,"[&]() {
    MaybeLocal<Value> result = script->Run(context);
    if (!result.IsEmpty() && mtask_queue)
      mtask_queue->PerformCheckpoint(env->isolate());
    return result;
  }",14,3,node_contextify.cc,node.contextify.ContextifyScript.EvalMachine.<lambda>1,,false,1053,1058,<lambda>1,,,1,ANY node.contextify.ContextifyScript.EvalMachine.<lambda>1 ()
150317,METHOD,node_contextify.cc:<global>,TYPE_DECL,<global>,1,1,node_contextify.cc,node_contextify.cc:<global>,,false,1,1472,<global>,,,1,
150322,METHOD,node_contextify.cc:<global>,TYPE_DECL,"Local<Name> Uint32ToName(Local<Context> context, uint32_t index) {
  return Uint32::New(context->GetIsolate(), index)->ToString(context)
      .ToLocalChecked();
}",1,1,node_contextify.cc,node.contextify.anonymous_namespace_1.Uint32ToName,,false,105,108,Uint32ToName,,,1,"Local<Name> node.contextify.anonymous_namespace_1.Uint32ToName (Local<Context>,uint32_t)"
150345,METHOD,node_contextify.cc:<global>,TYPE_DECL,"BaseObjectPtr<ContextifyContext> ContextifyContext::New(
    Environment* env,
    Local<Object> sandbox_obj,
    const ContextOptions& options) {
  HandleScope scope(env->isolate());
  Local<ObjectTemplate> object_template = env->contextify_global_template();
  DCHECK(!object_template.IsEmpty());
  const SnapshotData* snapshot_data = env->isolate_data()->snapshot_data();

  MicrotaskQueue* queue =
      options.microtask_queue_wrap
          ? options.microtask_queue_wrap->microtask_queue().get()
          : env->isolate()->GetCurrentContext()->GetMicrotaskQueue();

  Local<Context> v8_context;
  if (!(CreateV8Context(env->isolate(), object_template, snapshot_data, queue)
            .ToLocal(&v8_context))) {
    // Allocation failure, maximum call stack size reached, termination, etc.
    return BaseObjectPtr<ContextifyContext>();
  }
  return New(v8_context, env, sandbox_obj, options);
}",1,1,node_contextify.cc,node.contextify.ContextifyContext.New,,false,112,133,New,,,2,"BaseObjectPtr<ContextifyContext> node.contextify.ContextifyContext.New (Environment*,Local<Object>,ContextOptions)"
150439,METHOD,node_contextify.cc:<global>,TYPE_DECL,"void ContextifyContext::MemoryInfo(MemoryTracker* tracker) const {
  if (microtask_queue_wrap_) {
    tracker->TrackField(""microtask_queue_wrap"",
                        microtask_queue_wrap_->object());
  }
}",1,1,node_contextify.cc,node.contextify.ContextifyContext.MemoryInfo,,false,135,140,MemoryInfo,,,3,void node.contextify.ContextifyContext.MemoryInfo (MemoryTracker*)
150456,METHOD,node_contextify.cc:<global>,TYPE_DECL,"ContextifyContext::ContextifyContext(Environment* env,
                                     Local<Object> wrapper,
                                     Local<Context> v8_context,
                                     const ContextOptions& options)
    : BaseObject(env, wrapper),
      microtask_queue_wrap_(options.microtask_queue_wrap) {
  context_.Reset(env->isolate(), v8_context);
  // This should only be done after the initial initializations of the context
  // global object is finished.
  DCHECK_NULL(v8_context->GetAlignedPointerFromEmbedderData(
      ContextEmbedderIndex::kContextifyContext));
  v8_context->SetAlignedPointerInEmbedderData(
      ContextEmbedderIndex::kContextifyContext, this);
  // It's okay to make this reference weak - V8 would create an internal
  // reference to this context via the constructor of the wrapper.
  // As long as the wrapper is alive, it's constructor is alive, and so
  // is the context.
  context_.SetWeak();
}",1,1,node_contextify.cc,node.contextify.ContextifyContext.ContextifyContext,,false,142,160,ContextifyContext,,,4,"ANY node.contextify.ContextifyContext.ContextifyContext (Environment*,Local<Object>,Local<Context>,ContextOptions)"
150493,METHOD,node_contextify.cc:<global>,TYPE_DECL,"ContextifyContext::~ContextifyContext() {
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);

  env()->UnassignFromContext(PersistentToLocal::Weak(isolate, context_));
  context_.Reset();
}",1,1,node_contextify.cc,node.contextify.ContextifyContext.~ContextifyContext,,false,162,168,~ContextifyContext,,,5,ANY node.contextify.ContextifyContext.~ContextifyContext ()
150521,METHOD,node_contextify.cc:<global>,TYPE_DECL,"void ContextifyContext::InitializeGlobalTemplates(IsolateData* isolate_data) {
  DCHECK(isolate_data->contextify_wrapper_template().IsEmpty());
  Local<FunctionTemplate> global_func_template =
      FunctionTemplate::New(isolate_data->isolate());
  Local<ObjectTemplate> global_object_template =
      global_func_template->InstanceTemplate();

  NamedPropertyHandlerConfiguration config(
      PropertyGetterCallback,
      PropertySetterCallback,
      PropertyDescriptorCallback,
      PropertyDeleterCallback,
      PropertyEnumeratorCallback,
      PropertyDefinerCallback,
      {},
      PropertyHandlerFlags::kHasNoSideEffect);

  IndexedPropertyHandlerConfiguration indexed_config(
      IndexedPropertyGetterCallback,
      IndexedPropertySetterCallback,
      IndexedPropertyDescriptorCallback,
      IndexedPropertyDeleterCallback,
      PropertyEnumeratorCallback,
      IndexedPropertyDefinerCallback,
      {},
      PropertyHandlerFlags::kHasNoSideEffect);

  global_object_templat...",1,1,node_contextify.cc,node.contextify.ContextifyContext.InitializeGlobalTemplates,,false,170,206,InitializeGlobalTemplates,,,6,void node.contextify.ContextifyContext.InitializeGlobalTemplates (IsolateData*)
150623,METHOD,node_contextify.cc:<global>,TYPE_DECL,"MaybeLocal<Context> ContextifyContext::CreateV8Context(
    Isolate* isolate,
    Local<ObjectTemplate> object_template,
    const SnapshotData* snapshot_data,
    MicrotaskQueue* queue) {
  EscapableHandleScope scope(isolate);

  Local<Context> ctx;
  if (snapshot_data == nullptr) {
    ctx = Context::New(isolate,
                       nullptr,  // extensions
                       object_template,
                       {},  // global object
                       {},  // deserialization callback
                       queue);
    if (ctx.IsEmpty() || InitializeBaseContextForSnapshot(ctx).IsNothing()) {
      return MaybeLocal<Context>();
    }
  } else if (!Context::FromSnapshot(isolate,
                                    SnapshotData::kNodeVMContextIndex,
                                    {},       // deserialization callback
                                    nullptr,  // extensions
                                    {},       // global object
                            ...",1,1,node_contextify.cc,node.contextify.ContextifyContext.CreateV8Context,,false,208,237,CreateV8Context,,,7,"MaybeLocal<Context> node.contextify.ContextifyContext.CreateV8Context (Isolate*,Local<ObjectTemplate>,SnapshotData*,MicrotaskQueue*)"
150700,METHOD,node_contextify.cc:<global>,TYPE_DECL,"BaseObjectPtr<ContextifyContext> ContextifyContext::New(
    Local<Context> v8_context,
    Environment* env,
    Local<Object> sandbox_obj,
    const ContextOptions& options) {
  HandleScope scope(env->isolate());
  // This only initializes part of the context. The primordials are
  // only initialized when needed because even deserializing them slows
  // things down significantly and they are only needed in rare occasions
  // in the vm contexts.
  if (InitializeContextRuntime(v8_context).IsNothing()) {
    return BaseObjectPtr<ContextifyContext>();
  }

  Local<Context> main_context = env->context();
  Local<Object> new_context_global = v8_context->Global();
  v8_context->SetSecurityToken(main_context->GetSecurityToken());

  // We need to tie the lifetime of the sandbox object with the lifetime of
  // newly created context. We do this by making them hold references to each
  // other. The context can directly hold a reference to the sandbox as an
  // embedder data field. The ...",1,1,node_contextify.cc,node.contextify.ContextifyContext.New,,false,239,319,New,,,8,"BaseObjectPtr<ContextifyContext> node.contextify.ContextifyContext.New (Local<Context>,Environment*,Local<Object>,ContextOptions)"
150948,METHOD,node_contextify.cc:<global>,TYPE_DECL,"void ContextifyContext::CreatePerIsolateProperties(
    IsolateData* isolate_data, Local<ObjectTemplate> target) {
  Isolate* isolate = isolate_data->isolate();
  SetMethod(isolate, target, ""makeContext"", MakeContext);
  SetMethod(isolate, target, ""isContext"", IsContext);
  SetMethod(isolate, target, ""compileFunction"", CompileFunction);
}",1,1,node_contextify.cc,node.contextify.ContextifyContext.CreatePerIsolateProperties,,false,321,327,CreatePerIsolateProperties,,,9,"void node.contextify.ContextifyContext.CreatePerIsolateProperties (IsolateData*,Local<ObjectTemplate>)"
150976,METHOD,node_contextify.cc:<global>,TYPE_DECL,"void ContextifyContext::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(MakeContext);
  registry->Register(IsContext);
  registry->Register(CompileFunction);
  registry->Register(PropertyGetterCallback);
  registry->Register(PropertySetterCallback);
  registry->Register(PropertyDescriptorCallback);
  registry->Register(PropertyDeleterCallback);
  registry->Register(PropertyEnumeratorCallback);
  registry->Register(PropertyDefinerCallback);
  registry->Register(IndexedPropertyGetterCallback);
  registry->Register(IndexedPropertySetterCallback);
  registry->Register(IndexedPropertyDescriptorCallback);
  registry->Register(IndexedPropertyDeleterCallback);
  registry->Register(IndexedPropertyDefinerCallback);
}",1,1,node_contextify.cc,node.contextify.ContextifyContext.RegisterExternalReferences,,false,329,345,RegisterExternalReferences,,,10,void node.contextify.ContextifyContext.RegisterExternalReferences (ExternalReferenceRegistry*)
151051,METHOD,node_contextify.cc:<global>,TYPE_DECL,"void ContextifyContext::MakeContext(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  CHECK_EQ(args.Length(), 6);
  CHECK(args[0]->IsObject());
  Local<Object> sandbox = args[0].As<Object>();

  // Don't allow contextifying a sandbox multiple times.
  CHECK(
      !sandbox->HasPrivate(
          env->context(),
          env->contextify_context_private_symbol()).FromJust());

  ContextOptions options;

  CHECK(args[1]->IsString());
  options.name = args[1].As<String>();

  CHECK(args[2]->IsString() || args[2]->IsUndefined());
  if (args[2]->IsString()) {
    options.origin = args[2].As<String>();
  }

  CHECK(args[3]->IsBoolean());
  options.allow_code_gen_strings = args[3].As<Boolean>();

  CHECK(args[4]->IsBoolean());
  options.allow_code_gen_wasm = args[4].As<Boolean>();

  if (args[5]->IsObject() &&
      !env->microtask_queue_ctor_template().IsEmpty() &&
      env->microtask_queue_ctor_template()->HasInstance(args[5])) {
    optio...",1,1,node_contextify.cc,node.contextify.ContextifyContext.MakeContext,,false,348,393,MakeContext,,,11,void node.contextify.ContextifyContext.MakeContext (FunctionCallbackInfo<Value>)
151268,METHOD,node_contextify.cc:<global>,TYPE_DECL,"void ContextifyContext::IsContext(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsObject());
  Local<Object> sandbox = args[0].As<Object>();

  Maybe<bool> result =
      sandbox->HasPrivate(env->context(),
                          env->contextify_context_private_symbol());
  args.GetReturnValue().Set(result.FromJust());
}",1,1,node_contextify.cc,node.contextify.ContextifyContext.IsContext,,false,396,406,IsContext,,,12,void node.contextify.ContextifyContext.IsContext (FunctionCallbackInfo<Value>)
151326,METHOD,node_contextify.cc:<global>,TYPE_DECL,"void ContextifyContext::WeakCallback(
    const WeakCallbackInfo<ContextifyContext>& data) {
  ContextifyContext* context = data.GetParameter();
  delete context;
}",1,1,node_contextify.cc,node.contextify.ContextifyContext.WeakCallback,,false,409,413,WeakCallback,,,13,void node.contextify.ContextifyContext.WeakCallback (WeakCallbackInfo<ContextifyContext>)
151340,METHOD,node_contextify.cc:<global>,TYPE_DECL,"ContextifyContext* ContextifyContext::ContextFromContextifiedSandbox(
    Environment* env,
    const Local<Object>& sandbox) {
  Local<Value> context_global;
  if (sandbox
          ->GetPrivate(env->context(), env->contextify_context_private_symbol())
          .ToLocal(&context_global) &&
      context_global->IsObject()) {
    return Unwrap<ContextifyContext>(context_global.As<Object>());
  }
  return nullptr;
}",1,1,node_contextify.cc,node.contextify.ContextifyContext.ContextFromContextifiedSandbox,,false,416,427,ContextFromContextifiedSandbox,,,14,"ContextifyContext node.contextify.ContextifyContext.ContextFromContextifiedSandbox (Environment*,Local<Object>)"
151386,METHOD,node_contextify.cc:<global>,TYPE_DECL,"ContextifyContext* ContextifyContext::Get(const PropertyCallbackInfo<T>& args) {
  return Get(args.This());
}",1,1,node_contextify.cc,node.contextify.ContextifyContext.Get,,false,430,432,Get,,,15,ContextifyContext node.contextify.ContextifyContext.Get<T> (PropertyCallbackInfo<T>)
151397,METHOD,node_contextify.cc:<global>,TYPE_DECL,"ContextifyContext* ContextifyContext::Get(Local<Object> object) {
  Local<Context> context;
  if (!object->GetCreationContext().ToLocal(&context)) {
    return nullptr;
  }
  if (!ContextEmbedderTag::IsNodeContext(context)) {
    return nullptr;
  }
  return static_cast<ContextifyContext*>(
      context->GetAlignedPointerFromEmbedderData(
          ContextEmbedderIndex::kContextifyContext));
}",1,1,node_contextify.cc,node.contextify.ContextifyContext.Get,,false,434,445,Get,,,16,ContextifyContext node.contextify.ContextifyContext.Get (Local<Object>)
151441,METHOD,node_contextify.cc:<global>,TYPE_DECL,"bool ContextifyContext::IsStillInitializing(const ContextifyContext* ctx) {
  return ctx == nullptr || ctx->context_.IsEmpty();
}",1,1,node_contextify.cc,node.contextify.ContextifyContext.IsStillInitializing,,false,447,449,IsStillInitializing,,,17,bool node.contextify.ContextifyContext.IsStillInitializing (ContextifyContext*)
151457,METHOD,node_contextify.cc:<global>,TYPE_DECL,"void ContextifyContext::PropertyGetterCallback(
    Local<Name> property,
    const PropertyCallbackInfo<Value>& args) {
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  Local<Context> context = ctx->context();
  Local<Object> sandbox = ctx->sandbox();
  MaybeLocal<Value> maybe_rv =
      sandbox->GetRealNamedProperty(context, property);
  if (maybe_rv.IsEmpty()) {
    maybe_rv =
        ctx->global_proxy()->GetRealNamedProperty(context, property);
  }

  Local<Value> rv;
  if (maybe_rv.ToLocal(&rv)) {
    if (rv == sandbox)
      rv = ctx->global_proxy();

    args.GetReturnValue().Set(rv);
  }
}",1,1,node_contextify.cc,node.contextify.ContextifyContext.PropertyGetterCallback,,false,452,476,PropertyGetterCallback,,,18,"void node.contextify.ContextifyContext.PropertyGetterCallback (Local<Name>,PropertyCallbackInfo<Value>)"
151557,METHOD,node_contextify.cc:<global>,TYPE_DECL,"void ContextifyContext::PropertySetterCallback(
    Local<Name> property,
    Local<Value> value,
    const PropertyCallbackInfo<Value>& args) {
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  Local<Context> context = ctx->context();
  PropertyAttribute attributes = PropertyAttribute::None;
  bool is_declared_on_global_proxy = ctx->global_proxy()
      ->GetRealNamedPropertyAttributes(context, property)
      .To(&attributes);
  bool read_only =
      static_cast<int>(attributes) &
      static_cast<int>(PropertyAttribute::ReadOnly);

  bool is_declared_on_sandbox = ctx->sandbox()
      ->GetRealNamedPropertyAttributes(context, property)
      .To(&attributes);
  read_only = read_only ||
      (static_cast<int>(attributes) &
      static_cast<int>(PropertyAttribute::ReadOnly));

  if (read_only)
    return;

  // true for x = 5
  // false for this.x = 5
  // false for Object.defineProperty(this, 'foo', ...)...",1,1,node_contextify.cc,node.contextify.ContextifyContext.PropertySetterCallback,,false,479,545,PropertySetterCallback,,,19,"void node.contextify.ContextifyContext.PropertySetterCallback (Local<Name>,Local<Value>,PropertyCallbackInfo<Value>)"
151806,METHOD,node_contextify.cc:<global>,TYPE_DECL,"void ContextifyContext::PropertyDescriptorCallback(
    Local<Name> property,
    const PropertyCallbackInfo<Value>& args) {
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  Local<Context> context = ctx->context();

  Local<Object> sandbox = ctx->sandbox();

  if (sandbox->HasOwnProperty(context, property).FromMaybe(false)) {
    Local<Value> desc;
    if (sandbox->GetOwnPropertyDescriptor(context, property).ToLocal(&desc)) {
      args.GetReturnValue().Set(desc);
    }
  }
}",1,1,node_contextify.cc,node.contextify.ContextifyContext.PropertyDescriptorCallback,,false,548,566,PropertyDescriptorCallback,,,20,"void node.contextify.ContextifyContext.PropertyDescriptorCallback (Local<Name>,PropertyCallbackInfo<Value>)"
151883,METHOD,node_contextify.cc:<global>,TYPE_DECL,"void ContextifyContext::PropertyDefinerCallback(
    Local<Name> property,
    const PropertyDescriptor& desc,
    const PropertyCallbackInfo<Value>& args) {
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  Local<Context> context = ctx->context();
  Isolate* isolate = context->GetIsolate();

  PropertyAttribute attributes = PropertyAttribute::None;
  bool is_declared =
      ctx->global_proxy()->GetRealNamedPropertyAttributes(context,
                                                          property)
          .To(&attributes);
  bool read_only =
      static_cast<int>(attributes) &
          static_cast<int>(PropertyAttribute::ReadOnly);

  // If the property is set on the global as read_only, don't change it on
  // the global or sandbox.
  if (is_declared && read_only)
    return;

  Local<Object> sandbox = ctx->sandbox();

  auto define_prop_on_sandbox =
      [&] (PropertyDescriptor* desc_for_sandbox) ...",1,1,node_contextify.cc,node.contextify.ContextifyContext.PropertyDefinerCallback,,false,569,627,PropertyDefinerCallback,,,21,"void node.contextify.ContextifyContext.PropertyDefinerCallback (Local<Name>,PropertyDescriptor,PropertyCallbackInfo<Value>)"
152063,METHOD,node_contextify.cc:<global>,TYPE_DECL,"void ContextifyContext::PropertyDeleterCallback(
    Local<Name> property,
    const PropertyCallbackInfo<Boolean>& args) {
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  Maybe<bool> success = ctx->sandbox()->Delete(ctx->context(), property);

  if (success.FromMaybe(false))
    return;

  // Delete failed on the sandbox, intercept and do not delete on
  // the global object.
  args.GetReturnValue().Set(false);
}",1,1,node_contextify.cc,node.contextify.ContextifyContext.PropertyDeleterCallback,,false,630,646,PropertyDeleterCallback,,,22,"void node.contextify.ContextifyContext.PropertyDeleterCallback (Local<Name>,PropertyCallbackInfo<Boolean>)"
152113,METHOD,node_contextify.cc:<global>,TYPE_DECL,"void ContextifyContext::PropertyEnumeratorCallback(
    const PropertyCallbackInfo<Array>& args) {
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  Local<Array> properties;

  if (!ctx->sandbox()->GetPropertyNames(ctx->context()).ToLocal(&properties))
    return;

  args.GetReturnValue().Set(properties);
}",1,1,node_contextify.cc,node.contextify.ContextifyContext.PropertyEnumeratorCallback,,false,649,662,PropertyEnumeratorCallback,,,23,void node.contextify.ContextifyContext.PropertyEnumeratorCallback (PropertyCallbackInfo<Array>)
152164,METHOD,node_contextify.cc:<global>,TYPE_DECL,"void ContextifyContext::IndexedPropertyGetterCallback(
    uint32_t index,
    const PropertyCallbackInfo<Value>& args) {
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  ContextifyContext::PropertyGetterCallback(
      Uint32ToName(ctx->context(), index), args);
}",1,1,node_contextify.cc,node.contextify.ContextifyContext.IndexedPropertyGetterCallback,,false,665,675,IndexedPropertyGetterCallback,,,24,"void node.contextify.ContextifyContext.IndexedPropertyGetterCallback (uint32_t,PropertyCallbackInfo<Value>)"
152194,METHOD,node_contextify.cc:<global>,TYPE_DECL,"void ContextifyContext::IndexedPropertySetterCallback(
    uint32_t index,
    Local<Value> value,
    const PropertyCallbackInfo<Value>& args) {
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  ContextifyContext::PropertySetterCallback(
      Uint32ToName(ctx->context(), index), value, args);
}",1,1,node_contextify.cc,node.contextify.ContextifyContext.IndexedPropertySetterCallback,,false,678,689,IndexedPropertySetterCallback,,,25,"void node.contextify.ContextifyContext.IndexedPropertySetterCallback (uint32_t,Local<Value>,PropertyCallbackInfo<Value>)"
152226,METHOD,node_contextify.cc:<global>,TYPE_DECL,"void ContextifyContext::IndexedPropertyDescriptorCallback(
    uint32_t index,
    const PropertyCallbackInfo<Value>& args) {
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  ContextifyContext::PropertyDescriptorCallback(
      Uint32ToName(ctx->context(), index), args);
}",1,1,node_contextify.cc,node.contextify.ContextifyContext.IndexedPropertyDescriptorCallback,,false,692,702,IndexedPropertyDescriptorCallback,,,26,"void node.contextify.ContextifyContext.IndexedPropertyDescriptorCallback (uint32_t,PropertyCallbackInfo<Value>)"
152256,METHOD,node_contextify.cc:<global>,TYPE_DECL,"void ContextifyContext::IndexedPropertyDefinerCallback(
    uint32_t index,
    const PropertyDescriptor& desc,
    const PropertyCallbackInfo<Value>& args) {
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  ContextifyContext::PropertyDefinerCallback(
      Uint32ToName(ctx->context(), index), desc, args);
}",1,1,node_contextify.cc,node.contextify.ContextifyContext.IndexedPropertyDefinerCallback,,false,705,716,IndexedPropertyDefinerCallback,,,27,"void node.contextify.ContextifyContext.IndexedPropertyDefinerCallback (uint32_t,PropertyDescriptor,PropertyCallbackInfo<Value>)"
152288,METHOD,node_contextify.cc:<global>,TYPE_DECL,"void ContextifyContext::IndexedPropertyDeleterCallback(
    uint32_t index,
    const PropertyCallbackInfo<Boolean>& args) {
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  Maybe<bool> success = ctx->sandbox()->Delete(ctx->context(), index);

  if (success.FromMaybe(false))
    return;

  // Delete failed on the sandbox, intercept and do not delete on
  // the global object.
  args.GetReturnValue().Set(false);
}",1,1,node_contextify.cc,node.contextify.ContextifyContext.IndexedPropertyDeleterCallback,,false,719,735,IndexedPropertyDeleterCallback,,,28,"void node.contextify.ContextifyContext.IndexedPropertyDeleterCallback (uint32_t,PropertyCallbackInfo<Boolean>)"
152338,METHOD,node_contextify.cc:<global>,TYPE_DECL,"void ContextifyScript::CreatePerIsolateProperties(
    IsolateData* isolate_data, Local<ObjectTemplate> target) {
  Isolate* isolate = isolate_data->isolate();
  Local<String> class_name = FIXED_ONE_BYTE_STRING(isolate, ""ContextifyScript"");

  Local<FunctionTemplate> script_tmpl = NewFunctionTemplate(isolate, New);
  script_tmpl->InstanceTemplate()->SetInternalFieldCount(
      ContextifyScript::kInternalFieldCount);
  script_tmpl->SetClassName(class_name);
  SetProtoMethod(isolate, script_tmpl, ""createCachedData"", CreateCachedData);
  SetProtoMethod(isolate, script_tmpl, ""runInContext"", RunInContext);

  target->Set(isolate, ""ContextifyScript"", script_tmpl);
  isolate_data->set_script_context_constructor_template(script_tmpl);
}",1,1,node_contextify.cc,node.contextify.ContextifyScript.CreatePerIsolateProperties,,false,737,751,CreatePerIsolateProperties,,,29,"void node.contextify.ContextifyScript.CreatePerIsolateProperties (IsolateData*,Local<ObjectTemplate>)"
152406,METHOD,node_contextify.cc:<global>,TYPE_DECL,"void ContextifyScript::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(New);
  registry->Register(CreateCachedData);
  registry->Register(RunInContext);
}",1,1,node_contextify.cc,node.contextify.ContextifyScript.RegisterExternalReferences,,false,753,758,RegisterExternalReferences,,,30,void node.contextify.ContextifyScript.RegisterExternalReferences (ExternalReferenceRegistry*)
152426,METHOD,node_contextify.cc:<global>,TYPE_DECL,"void ContextifyScript::New(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();

  CHECK(args.IsConstructCall());

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  CHECK(args[0]->IsString());
  Local<String> code = args[0].As<String>();

  CHECK(args[1]->IsString());
  Local<String> filename = args[1].As<String>();

  int line_offset = 0;
  int column_offset = 0;
  Local<ArrayBufferView> cached_data_buf;
  bool produce_cached_data = false;
  Local<Context> parsing_context = context;

  if (argc > 2) {
    // new ContextifyScript(code, filename, lineOffset, columnOffset,
    //                      cachedData, produceCachedData, parsingContext)
    CHECK_EQ(argc, 7);
    CHECK(args[2]->IsNumber());
    line_offset = args[2].As<Int32>()->Value();
    CHECK(args[3]->IsNumber());
    column_offset = args[3].As<Int32>()->Value();
    if (!args[4]->IsUndefined...",1,1,node_contextify.cc,node.contextify.ContextifyScript.New,,false,760,892,New,,,31,void node.contextify.ContextifyScript.New (FunctionCallbackInfo<Value>)
152959,METHOD,node_contextify.cc:<global>,TYPE_DECL,"Maybe<bool> StoreCodeCacheResult(
    Environment* env,
    Local<Object> target,
    ScriptCompiler::CompileOptions compile_options,
    const v8::ScriptCompiler::Source& source,
    bool produce_cached_data,
    std::unique_ptr<ScriptCompiler::CachedData> new_cached_data) {
  Local<Context> context;
  if (!target->GetCreationContext().ToLocal(&context)) {
    return Nothing<bool>();
  }
  if (compile_options == ScriptCompiler::kConsumeCodeCache) {
    if (target
            ->Set(
                context,
                env->cached_data_rejected_string(),
                Boolean::New(env->isolate(), source.GetCachedData()->rejected))
            .IsNothing()) {
      return Nothing<bool>();
    }
  }
  if (produce_cached_data) {
    bool cached_data_produced = new_cached_data != nullptr;
    if (cached_data_produced) {
      MaybeLocal<Object> buf =
          Buffer::Copy(env,
                       reinterpret_cast<const char*>(new_cached_data->data),
                       new_...",1,1,node_contextify.cc,node.contextify.StoreCodeCacheResult,,false,894,936,StoreCodeCacheResult,,,32,"Maybe<bool> node.contextify.StoreCodeCacheResult (Environment*,Local<Object>,ANY,ANY,bool,ANY)"
153104,METHOD,node_contextify.cc:<global>,TYPE_DECL,"bool ContextifyScript::InstanceOf(Environment* env,
                                  const Local<Value>& value) {
  return !value.IsEmpty() &&
         env->script_context_constructor_template()->HasInstance(value);
}",1,1,node_contextify.cc,node.contextify.ContextifyScript.InstanceOf,,false,938,942,InstanceOf,,,33,"bool node.contextify.ContextifyScript.InstanceOf (Environment*,Local<Value>)"
153125,METHOD,node_contextify.cc:<global>,TYPE_DECL,"void ContextifyScript::CreateCachedData(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  ContextifyScript* wrapped_script;
  ASSIGN_OR_RETURN_UNWRAP(&wrapped_script, args.Holder());
  Local<UnboundScript> unbound_script =
      PersistentToLocal::Default(env->isolate(), wrapped_script->script_);
  std::unique_ptr<ScriptCompiler::CachedData> cached_data(
      ScriptCompiler::CreateCodeCache(unbound_script));
  if (!cached_data) {
    args.GetReturnValue().Set(Buffer::New(env, 0).ToLocalChecked());
  } else {
    MaybeLocal<Object> buf = Buffer::Copy(
        env,
        reinterpret_cast<const char*>(cached_data->data),
        cached_data->length);
    args.GetReturnValue().Set(buf.ToLocalChecked());
  }
}",1,1,node_contextify.cc,node.contextify.ContextifyScript.CreateCachedData,,false,944,962,CreateCachedData,,,34,void node.contextify.ContextifyScript.CreateCachedData (FunctionCallbackInfo<Value>)
153161,METHOD,node_contextify.cc:<global>,TYPE_DECL,"std::unique_ptr<ScriptCompiler::CachedData> cached_data(
      ScriptCompiler::CreateCodeCache(unbound_script));",47,54,node_contextify.cc,node.contextify.ContextifyScript.CreateCachedData.cached_data,,false,951,952,cached_data,,,6,ANY node.contextify.ContextifyScript.CreateCachedData.cached_data (ANY)
153220,METHOD,node_contextify.cc:<global>,TYPE_DECL,"void ContextifyScript::RunInContext(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  ContextifyScript* wrapped_script;
  ASSIGN_OR_RETURN_UNWRAP(&wrapped_script, args.Holder());

  CHECK_EQ(args.Length(), 5);
  CHECK(args[0]->IsObject() || args[0]->IsNull());

  Local<Context> context;
  std::shared_ptr<MicrotaskQueue> microtask_queue;

  if (args[0]->IsObject()) {
    Local<Object> sandbox = args[0].As<Object>();
    // Get the context from the sandbox
    ContextifyContext* contextify_context =
        ContextifyContext::ContextFromContextifiedSandbox(env, sandbox);
    CHECK_NOT_NULL(contextify_context);
    CHECK_EQ(contextify_context->env(), env);

    context = contextify_context->context();
    if (context.IsEmpty()) return;

    microtask_queue = contextify_context->microtask_queue();
  } else {
    context = env->context();
  }

  TRACE_EVENT0(TRACING_CATEGORY_NODE2(vm, script), ""RunInContext"");

  CHECK(args[1]->IsNumber());...",1,1,node_contextify.cc,node.contextify.ContextifyScript.RunInContext,,false,964,1015,RunInContext,,,35,void node.contextify.ContextifyScript.RunInContext (FunctionCallbackInfo<Value>)
153422,METHOD,node_contextify.cc:<global>,TYPE_DECL,"bool ContextifyScript::EvalMachine(Local<Context> context,
                                   Environment* env,
                                   const int64_t timeout,
                                   const bool display_errors,
                                   const bool break_on_sigint,
                                   const bool break_on_first_line,
                                   std::shared_ptr<MicrotaskQueue> mtask_queue,
                                   const FunctionCallbackInfo<Value>& args) {
  Context::Scope context_scope(context);

  if (!env->can_call_into_js())
    return false;
  if (!ContextifyScript::InstanceOf(env, args.Holder())) {
    THROW_ERR_INVALID_THIS(
        env,
        ""Script methods can only be called on script instances."");
    return false;
  }

  TryCatchScope try_catch(env);
  Isolate::SafeForTerminationScope safe_for_termination(env->isolate());
  ContextifyScript* wrapped_script;
  ASSIGN_OR_RETURN_UNWRAP(&wrapped_script, args.Holder...",1,1,node_contextify.cc,node.contextify.ContextifyScript.EvalMachine,,false,1017,1107,EvalMachine,,,36,"bool node.contextify.ContextifyScript.EvalMachine (Local<Context>,Environment*,int64_t,bool,bool,bool,ANY,FunctionCallbackInfo<Value>)"
153683,METHOD,node_contextify.cc:<global>,TYPE_DECL,"ContextifyScript::ContextifyScript(Environment* env, Local<Object> object)
    : BaseObject(env, object),
      id_(env->get_next_script_id()) {
  MakeWeak();
  env->id_to_script_map.emplace(id_, this);
}",1,1,node_contextify.cc,node.contextify.ContextifyScript.ContextifyScript,,false,1110,1115,ContextifyScript,,,37,"ANY node.contextify.ContextifyScript.ContextifyScript (Environment*,Local<Object>)"
153698,METHOD,node_contextify.cc:<global>,TYPE_DECL,"ContextifyScript::~ContextifyScript() {
  env()->id_to_script_map.erase(id_);
}",1,1,node_contextify.cc,node.contextify.ContextifyScript.~ContextifyScript,,false,1118,1120,~ContextifyScript,,,38,ANY node.contextify.ContextifyScript.~ContextifyScript ()
153709,METHOD,node_contextify.cc:<global>,TYPE_DECL,"void ContextifyContext::CompileFunction(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();

  // Argument 1: source code
  CHECK(args[0]->IsString());
  Local<String> code = args[0].As<String>();

  // Argument 2: filename
  CHECK(args[1]->IsString());
  Local<String> filename = args[1].As<String>();

  // Argument 3: line offset
  CHECK(args[2]->IsNumber());
  int line_offset = args[2].As<Int32>()->Value();

  // Argument 4: column offset
  CHECK(args[3]->IsNumber());
  int column_offset = args[3].As<Int32>()->Value();

  // Argument 5: cached data (optional)
  Local<ArrayBufferView> cached_data_buf;
  if (!args[4]->IsUndefined()) {
    CHECK(args[4]->IsArrayBufferView());
    cached_data_buf = args[4].As<ArrayBufferView>();
  }

  // Argument 6: produce cache data
  CHECK(args[5]->IsBoolean());
  bool produce_cached_data = args[5]->IsTrue();

  // Argume...",1,1,node_contextify.cc,node.contextify.ContextifyContext.CompileFunction,,false,1123,1304,CompileFunction,,,39,void node.contextify.ContextifyContext.CompileFunction (FunctionCallbackInfo<Value>)
154460,METHOD,node_contextify.cc:<global>,TYPE_DECL,"void CompiledFnEntry::WeakCallback(
    const WeakCallbackInfo<CompiledFnEntry>& data) {
  CompiledFnEntry* entry = data.GetParameter();
  delete entry;
}",1,1,node_contextify.cc,node.contextify.CompiledFnEntry.WeakCallback,,false,1306,1310,WeakCallback,,,40,void node.contextify.CompiledFnEntry.WeakCallback (WeakCallbackInfo<CompiledFnEntry>)
154474,METHOD,node_contextify.cc:<global>,TYPE_DECL,"CompiledFnEntry::CompiledFnEntry(Environment* env,
                                 Local<Object> object,
                                 uint32_t id,
                                 Local<Function> fn)
    : BaseObject(env, object), id_(id), fn_(env->isolate(), fn) {
  fn_.SetWeak(this, WeakCallback, v8::WeakCallbackType::kParameter);
}",1,1,node_contextify.cc,node.contextify.CompiledFnEntry.CompiledFnEntry,,false,1312,1318,CompiledFnEntry,,,41,"ANY node.contextify.CompiledFnEntry.CompiledFnEntry (Environment*,Local<Object>,uint32_t,Local<Function>)"
154493,METHOD,node_contextify.cc:<global>,TYPE_DECL,"CompiledFnEntry::~CompiledFnEntry() {
  env()->id_to_function_map.erase(id_);
  fn_.ClearWeak();
}",1,1,node_contextify.cc,node.contextify.CompiledFnEntry.~CompiledFnEntry,,false,1320,1323,~CompiledFnEntry,,,42,ANY node.contextify.CompiledFnEntry.~CompiledFnEntry ()
154508,METHOD,node_contextify.cc:<global>,TYPE_DECL,"static void StartSigintWatchdog(const FunctionCallbackInfo<Value>& args) {
  int ret = SigintWatchdogHelper::GetInstance()->Start();
  args.GetReturnValue().Set(ret == 0);
}",1,1,node_contextify.cc,node.contextify.StartSigintWatchdog,,false,1325,1328,StartSigintWatchdog,,,43,void node.contextify.StartSigintWatchdog (FunctionCallbackInfo<Value>)
154533,METHOD,node_contextify.cc:<global>,TYPE_DECL,"static void StopSigintWatchdog(const FunctionCallbackInfo<Value>& args) {
  bool had_pending_signals = SigintWatchdogHelper::GetInstance()->Stop();
  args.GetReturnValue().Set(had_pending_signals);
}",1,1,node_contextify.cc,node.contextify.StopSigintWatchdog,,false,1330,1333,StopSigintWatchdog,,,44,void node.contextify.StopSigintWatchdog (FunctionCallbackInfo<Value>)
154556,METHOD,node_contextify.cc:<global>,TYPE_DECL,"static void WatchdogHasPendingSigint(const FunctionCallbackInfo<Value>& args) {
  bool ret = SigintWatchdogHelper::GetInstance()->HasPendingSignal();
  args.GetReturnValue().Set(ret);
}",1,1,node_contextify.cc,node.contextify.WatchdogHasPendingSigint,,false,1335,1338,WatchdogHasPendingSigint,,,45,void node.contextify.WatchdogHasPendingSigint (FunctionCallbackInfo<Value>)
154579,METHOD,node_contextify.cc:<global>,TYPE_DECL,"static void MeasureMemory(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsInt32());
  CHECK(args[1]->IsInt32());
  int32_t mode = args[0].As<v8::Int32>()->Value();
  int32_t execution = args[1].As<v8::Int32>()->Value();
  Isolate* isolate = args.GetIsolate();

  Local<Context> current_context = isolate->GetCurrentContext();
  Local<Promise::Resolver> resolver;
  if (!Promise::Resolver::New(current_context).ToLocal(&resolver)) return;
  std::unique_ptr<v8::MeasureMemoryDelegate> delegate =
      v8::MeasureMemoryDelegate::Default(
          isolate,
          current_context,
          resolver,
          static_cast<v8::MeasureMemoryMode>(mode));
  isolate->MeasureMemory(std::move(delegate),
                         static_cast<v8::MeasureMemoryExecution>(execution));
  Local<Promise> promise = resolver->GetPromise();

  args.GetReturnValue().Set(promise);
}",1,1,node_contextify.cc,node.contextify.MeasureMemory,,false,1340,1361,MeasureMemory,,,46,void node.contextify.MeasureMemory (FunctionCallbackInfo<Value>)
154714,METHOD,node_contextify.cc:<global>,TYPE_DECL,"MicrotaskQueueWrap::MicrotaskQueueWrap(Environment* env, Local<Object> obj)
  : BaseObject(env, obj),
    microtask_queue_(
        MicrotaskQueue::New(env->isolate(), MicrotasksPolicy::kExplicit)) {
  MakeWeak();
}",1,1,node_contextify.cc,node.contextify.MicrotaskQueueWrap.MicrotaskQueueWrap,,false,1363,1368,MicrotaskQueueWrap,,,47,"ANY node.contextify.MicrotaskQueueWrap.MicrotaskQueueWrap (Environment*,Local<Object>)"
154721,METHOD,node_contextify.cc:<global>,TYPE_DECL,"const std::shared_ptr<MicrotaskQueue>&
MicrotaskQueueWrap::microtask_queue() const {
  return microtask_queue_;
}",1,1,node_contextify.cc,node.contextify.MicrotaskQueueWrap.microtask_queue,,false,1370,1373,microtask_queue,,,48,shared_ptr<MicrotaskQueue> node.contextify.MicrotaskQueueWrap.microtask_queue ()
154727,METHOD,node_contextify.cc:<global>,TYPE_DECL,"void MicrotaskQueueWrap::New(const FunctionCallbackInfo<Value>& args) {
  CHECK(args.IsConstructCall());
  new MicrotaskQueueWrap(Environment::GetCurrent(args), args.This());
}",1,1,node_contextify.cc,node.contextify.MicrotaskQueueWrap.New,,false,1375,1378,New,,,49,void node.contextify.MicrotaskQueueWrap.New (FunctionCallbackInfo<Value>)
154748,METHOD,node_contextify.cc:<global>,TYPE_DECL,"void MicrotaskQueueWrap::CreatePerIsolateProperties(
    IsolateData* isolate_data, Local<ObjectTemplate> target) {
  Isolate* isolate = isolate_data->isolate();
  HandleScope scope(isolate);
  Local<FunctionTemplate> tmpl = NewFunctionTemplate(isolate, New);
  tmpl->InstanceTemplate()->SetInternalFieldCount(
      ContextifyScript::kInternalFieldCount);
  isolate_data->set_microtask_queue_ctor_template(tmpl);
  SetConstructorFunction(isolate, target, ""MicrotaskQueue"", tmpl);
}",1,1,node_contextify.cc,node.contextify.MicrotaskQueueWrap.CreatePerIsolateProperties,,false,1380,1389,CreatePerIsolateProperties,,,50,"void node.contextify.MicrotaskQueueWrap.CreatePerIsolateProperties (IsolateData*,Local<ObjectTemplate>)"
154793,METHOD,node_contextify.cc:<global>,TYPE_DECL,"void MicrotaskQueueWrap::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(New);
}",1,1,node_contextify.cc,node.contextify.MicrotaskQueueWrap.RegisterExternalReferences,,false,1391,1394,RegisterExternalReferences,,,51,void node.contextify.MicrotaskQueueWrap.RegisterExternalReferences (ExternalReferenceRegistry*)
154803,METHOD,node_contextify.cc:<global>,TYPE_DECL,"void CreatePerIsolateProperties(IsolateData* isolate_data,
                                Local<ObjectTemplate> target) {
  Isolate* isolate = isolate_data->isolate();

  ContextifyContext::CreatePerIsolateProperties(isolate_data, target);
  ContextifyScript::CreatePerIsolateProperties(isolate_data, target);
  MicrotaskQueueWrap::CreatePerIsolateProperties(isolate_data, target);

  SetMethod(isolate, target, ""startSigintWatchdog"", StartSigintWatchdog);
  SetMethod(isolate, target, ""stopSigintWatchdog"", StopSigintWatchdog);
  // Used in tests.
  SetMethodNoSideEffect(
      isolate, target, ""watchdogHasPendingSigint"", WatchdogHasPendingSigint);

  {
    Local<FunctionTemplate> tpl = FunctionTemplate::New(isolate);
    tpl->SetClassName(FIXED_ONE_BYTE_STRING(isolate, ""CompiledFnEntry""));
    tpl->InstanceTemplate()->SetInternalFieldCount(
        CompiledFnEntry::kInternalFieldCount);

    isolate_data->set_compiled_fn_entry_template(tpl->InstanceTemplate());
  }
  SetMethod(isolate,...",1,1,node_contextify.cc,node.contextify.CreatePerIsolateProperties,,false,1396,1419,CreatePerIsolateProperties,,,52,"void node.contextify.CreatePerIsolateProperties (IsolateData*,Local<ObjectTemplate>)"
154891,METHOD,node_contextify.cc:<global>,TYPE_DECL,"static void CreatePerContextProperties(Local<Object> target,
                                       Local<Value> unused,
                                       Local<Context> context,
                                       void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<Object> constants = Object::New(env->isolate());
  Local<Object> measure_memory = Object::New(env->isolate());
  Local<Object> memory_execution = Object::New(env->isolate());

  {
    Local<Object> memory_mode = Object::New(env->isolate());
    MeasureMemoryMode SUMMARY = MeasureMemoryMode::kSummary;
    MeasureMemoryMode DETAILED = MeasureMemoryMode::kDetailed;
    NODE_DEFINE_CONSTANT(memory_mode, SUMMARY);
    NODE_DEFINE_CONSTANT(memory_mode, DETAILED);
    READONLY_PROPERTY(measure_memory, ""mode"", memory_mode);
  }

  {
    MeasureMemoryExecution DEFAULT = MeasureMemoryExecution::kDefault;
    MeasureMemoryExecution EAGER = MeasureMemoryExecution...",1,1,node_contextify.cc,node.contextify.CreatePerContextProperties,,false,1421,1452,CreatePerContextProperties,,,53,"void node.contextify.CreatePerContextProperties (Local<Object>,Local<Value>,Local<Context>,void*)"
155033,METHOD,node_contextify.cc:<global>,TYPE_DECL,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  ContextifyContext::RegisterExternalReferences(registry);
  ContextifyScript::RegisterExternalReferences(registry);
  MicrotaskQueueWrap::RegisterExternalReferences(registry);

  registry->Register(StartSigintWatchdog);
  registry->Register(StopSigintWatchdog);
  registry->Register(WatchdogHasPendingSigint);
  registry->Register(MeasureMemory);
}",1,1,node_contextify.cc,node.contextify.RegisterExternalReferences,,false,1454,1463,RegisterExternalReferences,,,54,void node.contextify.RegisterExternalReferences (ExternalReferenceRegistry*)
155083,METHOD,node_contextify.hpp:<global>,TYPE_DECL,<global>,1,33,node_contextify.hpp,node_contextify.hpp:<global>,,false,1,218,<global>,,,1,
155108,METHOD,node_credentials.cc:<global>,TYPE_DECL,<global>,1,25,env-inl.hpp,node_credentials.cc:<global>,,false,1,488,<global>,,,1,
155111,METHOD,node_credentials.cc:<global>,TYPE_DECL,"bool linux_at_secure() {
  // This could reasonably be a static variable, but this way
  // we can guarantee that this function is always usable
  // and returns the correct value,  e.g. even in static
  // initialization code in other files.
#ifdef __linux__
  static const bool value = getauxval(AT_SECURE);
  return value;
#else
  return false;
#endif
}",1,1,node_credentials.cc,node.linux_at_secure,,false,35,46,linux_at_secure,,,1,bool node.linux_at_secure ()
155118,METHOD,node_credentials.cc:<global>,TYPE_DECL,"bool SafeGetenv(const char* key,
                std::string* text,
                std::shared_ptr<KVStore> env_vars,
                v8::Isolate* isolate) {
#if !defined(__CloudABI__) && !defined(_WIN32)
#if defined(__linux__)
  if ((!HasOnly(CAP_NET_BIND_SERVICE) && linux_at_secure()) ||
      getuid() != geteuid() || getgid() != getegid())
#else
  if (linux_at_secure() || getuid() != geteuid() || getgid() != getegid())
#endif
    goto fail;
#endif

  if (env_vars != nullptr) {
    DCHECK_NOT_NULL(isolate);
    HandleScope handle_scope(isolate);
    TryCatch ignore_errors(isolate);
    MaybeLocal<String> maybe_value = env_vars->Get(
        isolate, String::NewFromUtf8(isolate, key).ToLocalChecked());
    Local<String> value;
    if (!maybe_value.ToLocal(&value)) goto fail;
    String::Utf8Value utf8_value(isolate, value);
    if (*utf8_value == nullptr) goto fail;
    *text = std::string(*utf8_value, utf8_value.length());
    return true;
  }

  {
    Mutex::ScopedLock lock(per_...",1,1,node_credentials.cc,node.credentials.SafeGetenv,,false,77,128,SafeGetenv,,,1,"bool node.credentials.SafeGetenv (char*,ANY*,ANY,ANY*)"
155269,METHOD,node_credentials.cc:<global>,TYPE_DECL,"static void SafeGetenv(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsString());
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  Utf8Value strenvtag(isolate, args[0]);
  std::string text;
  if (!SafeGetenv(*strenvtag, &text, env->env_vars(), isolate)) return;
  Local<Value> result =
      ToV8Value(isolate->GetCurrentContext(), text).ToLocalChecked();
  args.GetReturnValue().Set(result);
}",1,1,node_credentials.cc,node.credentials.SafeGetenv,,false,130,140,SafeGetenv,,,2,void node.credentials.SafeGetenv (FunctionCallbackInfo<Value>)
155340,METHOD,node_credentials.cc:<global>,TYPE_DECL,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(SafeGetenv);

#ifdef NODE_IMPLEMENTS_POSIX_CREDENTIALS
  registry->Register(GetUid);
  registry->Register(GetEUid);
  registry->Register(GetGid);
  registry->Register(GetEGid);
  registry->Register(GetGroups);

  registry->Register(InitGroups);
  registry->Register(SetEGid);
  registry->Register(SetEUid);
  registry->Register(SetGid);
  registry->Register(SetUid);
  registry->Register(SetGroups);
#endif  // NODE_IMPLEMENTS_POSIX_CREDENTIALS
}",1,1,node_credentials.cc,node.credentials.RegisterExternalReferences,,false,436,453,RegisterExternalReferences,,,3,void node.credentials.RegisterExternalReferences (ExternalReferenceRegistry*)
155350,METHOD,node_credentials.cc:<global>,TYPE_DECL,"static void Initialize(Local<Object> target,
                       Local<Value> unused,
                       Local<Context> context,
                       void* priv) {
  SetMethod(context, target, ""safeGetenv"", SafeGetenv);

#ifdef NODE_IMPLEMENTS_POSIX_CREDENTIALS
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  READONLY_TRUE_PROPERTY(target, ""implementsPosixCredentials"");
  SetMethodNoSideEffect(context, target, ""getuid"", GetUid);
  SetMethodNoSideEffect(context, target, ""geteuid"", GetEUid);
  SetMethodNoSideEffect(context, target, ""getgid"", GetGid);
  SetMethodNoSideEffect(context, target, ""getegid"", GetEGid);
  SetMethodNoSideEffect(context, target, ""getgroups"", GetGroups);

  if (env->owns_process_state()) {
    SetMethod(context, target, ""initgroups"", InitGroups);
    SetMethod(context, target, ""setegid"", SetEGid);
    SetMethod(context, target, ""seteuid"", SetEUid);
    SetMethod(context, target, ""setgid"", SetGid);
    SetMeth...",1,1,node_credentials.cc,node.credentials.Initialize,,false,455,481,Initialize,,,4,"void node.credentials.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
155381,METHOD,node_crypto.cc:<global>,TYPE_DECL,<global>,1,1,node_crypto.cc,node_crypto.cc:<global>,,false,1,97,<global>,,,1,
155385,METHOD,node_crypto.cc:<global>,TYPE_DECL,"void Initialize(Local<Object> target,
                Local<Value> unused,
                Local<Context> context,
                void* priv) {
  Environment* env = Environment::GetCurrent(context);

  if (!InitCryptoOnce(env->isolate())) {
    return;
  }

#define V(Namespace) Namespace::Initialize(env, target);
  CRYPTO_NAMESPACE_LIST(V)
#undef V
}",1,2,node_crypto.cc,node.crypto.Initialize,,false,72,85,Initialize,,,1,"void node.crypto.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
155544,METHOD,node_crypto.cc:<global>,TYPE_DECL,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
#define V(Namespace) Namespace::RegisterExternalReferences(registry);
  CRYPTO_NAMESPACE_LIST(V)
#undef V
}",1,2,node_crypto.cc,node.crypto.RegisterExternalReferences,,false,87,91,RegisterExternalReferences,,,2,void node.crypto.RegisterExternalReferences (ExternalReferenceRegistry*)
155709,METHOD,node_crypto.hpp:<global>,TYPE_DECL,<global>,1,29,node_crypto.hpp,node_crypto.hpp:<global>,,false,1,56,<global>,,,1,
155712,METHOD,node_dir.cc:<global>,TYPE_DECL,"[detail](Environment* env) {
      const char* msg = ""Closing directory handle on garbage collection failed"";
      // This exception will end up being fatal for the process because
      // it is being thrown from within the SetImmediate handler and
      // there is no JS stack to bubble it to. In other words, tearing
      // down the process is the only reasonable thing we can do here.
      HandleScope handle_scope(env->isolate());
      env->ThrowUVException(detail.ret, ""close"", msg);
    }",25,5,node_dir.cc,node.fs_dir.DirHandle.GCClose.<lambda>0,,false,152,160,<lambda>0,,,1,ANY node.fs_dir.DirHandle.GCClose.<lambda>0 (Environment*)
155739,METHOD,node_dir.cc:<global>,TYPE_DECL,"[](Environment* env) {
    ProcessEmitWarning(env,
                       ""Closing directory handle on garbage collection"");
  }",23,3,node_dir.cc,node.fs_dir.DirHandle.GCClose.<lambda>1,,false,168,171,<lambda>1,,,1,ANY node.fs_dir.DirHandle.GCClose.<lambda>1 (Environment*)
155781,METHOD,node_dir.cc:<global>,TYPE_DECL,<global>,1,26,node_dir.hpp,node_dir.cc:<global>,,false,1,433,<global>,,,1,
155785,METHOD,node_dir.cc:<global>,TYPE_DECL,"static const char* get_dir_func_name_by_type(uv_fs_type req_type) {
  switch (req_type) {
#define FS_TYPE_TO_NAME(type, name)                                            \
  case UV_FS_##type:                                                           \
    return name;
    FS_TYPE_TO_NAME(OPENDIR, ""opendir"")
    FS_TYPE_TO_NAME(READDIR, ""readdir"")
    FS_TYPE_TO_NAME(CLOSEDIR, ""closedir"")
#undef FS_TYPE_TO_NAME
    default:
      return ""unknow"";
  }
}",1,4,node_dir.cc,node.fs_dir.get_dir_func_name_by_type,,false,46,58,get_dir_func_name_by_type,,,1,const char* node.fs_dir.get_dir_func_name_by_type (uv_fs_type)
155814,METHOD,node_dir.cc:<global>,TYPE_DECL,"DirHandle::DirHandle(Environment* env, Local<Object> obj, uv_dir_t* dir)
    : AsyncWrap(env, obj, AsyncWrap::PROVIDER_DIRHANDLE),
      dir_(dir) {
  MakeWeak();

  dir_->nentries = 0;
  dir_->dirents = nullptr;
}",1,1,node_dir.cc,node.fs_dir.DirHandle.DirHandle,,false,98,105,DirHandle,,,2,"ANY node.fs_dir.DirHandle.DirHandle (Environment*,Local<Object>,uv_dir_t*)"
155832,METHOD,node_dir.cc:<global>,TYPE_DECL,"DirHandle* DirHandle::New(Environment* env, uv_dir_t* dir) {
  Local<Object> obj;
  if (!env->dir_instance_template()
          ->NewInstance(env->context())
          .ToLocal(&obj)) {
    return nullptr;
  }

  return new DirHandle(env, obj, dir);
}",1,1,node_dir.cc,node.fs_dir.DirHandle.New,,false,107,116,New,,,3,"DirHandle node.fs_dir.DirHandle.New (Environment*,uv_dir_t*)"
155870,METHOD,node_dir.cc:<global>,TYPE_DECL,"void DirHandle::New(const FunctionCallbackInfo<Value>& args) {
  CHECK(args.IsConstructCall());
}",1,1,node_dir.cc,node.fs_dir.DirHandle.New,,false,118,120,New,,,4,void node.fs_dir.DirHandle.New (FunctionCallbackInfo<Value>)
155880,METHOD,node_dir.cc:<global>,TYPE_DECL,"DirHandle::~DirHandle() {
  CHECK(!closing_);  // We should not be deleting while explicitly closing!
  GCClose();         // Close synchronously and emit warning
  CHECK(closed_);    // We have to be closed at the point
}",1,1,node_dir.cc,node.fs_dir.DirHandle.~DirHandle,,false,122,126,~DirHandle,,,5,ANY node.fs_dir.DirHandle.~DirHandle ()
155889,METHOD,node_dir.cc:<global>,TYPE_DECL,"void DirHandle::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackFieldWithSize(""dir"", sizeof(*dir_));
}",1,1,node_dir.cc,node.fs_dir.DirHandle.MemoryInfo,,false,128,130,MemoryInfo,,,6,void node.fs_dir.DirHandle.MemoryInfo (MemoryTracker*)
155902,METHOD,node_dir.cc:<global>,TYPE_DECL,"inline void DirHandle::GCClose() {
  if (closed_) return;
  uv_fs_t req;
  FS_DIR_SYNC_TRACE_BEGIN(closedir);
  int ret = uv_fs_closedir(nullptr, &req, dir_, nullptr);
  FS_DIR_SYNC_TRACE_END(closedir);
  uv_fs_req_cleanup(&req);
  closing_ = false;
  closed_ = true;

  struct err_detail { int ret; };

  err_detail detail { ret };

  if (ret < 0) {
    // Do not unref this
    env()->SetImmediate([detail](Environment* env) {
      const char* msg = ""Closing directory handle on garbage collection failed"";
      // This exception will end up being fatal for the process because
      // it is being thrown from within the SetImmediate handler and
      // there is no JS stack to bubble it to. In other words, tearing
      // down the process is the only reasonable thing we can do here.
      HandleScope handle_scope(env->isolate());
      env->ThrowUVException(detail.ret, ""close"", msg);
    });
    return;
  }

  // If the close was successful, we still want to emit a process warning
  ...",1,2,node_dir.cc,node.fs_dir.DirHandle.GCClose,,false,136,172,GCClose,,,7,void node.fs_dir.DirHandle.GCClose ()
156144,METHOD,node_dir.cc:<global>,TYPE_DECL,"void AfterClose(uv_fs_t* req) {
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (after.Proceed())
    req_wrap->Resolve(Undefined(req_wrap->env()->isolate()));
}",1,2,node_dir.cc,node.fs_dir.AfterClose,,false,174,181,AfterClose,,,8,void node.fs_dir.AfterClose (uv_fs_t*)
156293,METHOD,node_dir.cc:<global>,TYPE_DECL,"void DirHandle::Close(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 1);

  DirHandle* dir;
  ASSIGN_OR_RETURN_UNWRAP(&dir, args.Holder());

  dir->closing_ = false;
  dir->closed_ = true;

  FSReqBase* req_wrap_async = GetReqWrap(args, 0);
  if (req_wrap_async != nullptr) {  // close(req)
    FS_DIR_ASYNC_TRACE_BEGIN0(UV_FS_CLOSEDIR, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""closedir"", UTF8, AfterClose,
              uv_fs_closedir, dir->dir());
  } else {  // close(undefined, ctx)
    CHECK_EQ(argc, 2);
    FSReqWrapSync req_wrap_sync;
    FS_DIR_SYNC_TRACE_BEGIN(closedir);
    SyncCall(env, args[1], &req_wrap_sync, ""closedir"", uv_fs_closedir,
             dir->dir());
    FS_DIR_SYNC_TRACE_END(closedir);
  }
}",1,4,node_dir.cc,node.fs_dir.DirHandle.Close,,false,183,208,Close,,,9,void node.fs_dir.DirHandle.Close (FunctionCallbackInfo<Value>)
156666,METHOD,node_dir.cc:<global>,TYPE_DECL,"static MaybeLocal<Array> DirentListToArray(
    Environment* env,
    uv_dirent_t* ents,
    int num,
    enum encoding encoding,
    Local<Value>* err_out) {
  MaybeStackBuffer<Local<Value>, 64> entries(num * 2);

  // Return an array of all read filenames.
  int j = 0;
  for (int i = 0; i < num; i++) {
    Local<Value> filename;
    Local<Value> error;
    const size_t namelen = strlen(ents[i].name);
    if (!StringBytes::Encode(env->isolate(),
                             ents[i].name,
                             namelen,
                             encoding,
                             &error).ToLocal(&filename)) {
      *err_out = error;
      return MaybeLocal<Array>();
    }

    entries[j++] = filename;
    entries[j++] = Integer::New(env->isolate(), ents[i].type);
  }

  return Array::New(env->isolate(), entries.out(), j);
}",1,1,node_dir.cc,node.fs_dir.DirentListToArray,,false,210,238,DirentListToArray,,,10,"MaybeLocal<Array> node.fs_dir.DirentListToArray (Environment*,uv_dirent_t*,int,encoding,Local<Value>*)"
156784,METHOD,node_dir.cc:<global>,TYPE_DECL,"static void AfterDirRead(uv_fs_t* req) {
  BaseObjectPtr<FSReqBase> req_wrap { FSReqBase::from_req(req) };
  FSReqAfterScope after(req_wrap.get(), req);
  FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (!after.Proceed()) {
    return;
  }

  Environment* env = req_wrap->env();
  Isolate* isolate = env->isolate();

  if (req->result == 0) {
    // Done
    Local<Value> done = Null(isolate);
    after.Clear();
    req_wrap->Resolve(done);
    return;
  }

  uv_dir_t* dir = static_cast<uv_dir_t*>(req->ptr);

  Local<Value> error;
  Local<Array> js_array;
  if (!DirentListToArray(env,
                         dir->dirents,
                         static_cast<int>(req->result),
                         req_wrap->encoding(),
                         &error)
           .ToLocal(&js_array)) {
    // Clear libuv resources *before* delivering results to JS land because
    // that can schedule another operation on the same uv_dir_t. Ditto...",1,2,node_dir.cc,node.fs_dir.AfterDirRead,,false,240,278,AfterDirRead,,,11,void node.fs_dir.AfterDirRead (uv_fs_t*)
157029,METHOD,node_dir.cc:<global>,TYPE_DECL,"void DirHandle::Read(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  const enum encoding encoding = ParseEncoding(isolate, args[0], UTF8);

  DirHandle* dir;
  ASSIGN_OR_RETURN_UNWRAP(&dir, args.Holder());

  CHECK(args[1]->IsNumber());
  uint64_t buffer_size = static_cast<uint64_t>(args[1].As<Number>()->Value());

  if (buffer_size != dir->dirents_.size()) {
    dir->dirents_.resize(buffer_size);
    dir->dir_->nentries = buffer_size;
    dir->dir_->dirents = dir->dirents_.data();
  }

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // dir.read(encoding, bufferSize, req)
    FS_DIR_ASYNC_TRACE_BEGIN0(UV_FS_READDIR, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""readdir"", encoding,
              AfterDirRead, uv_fs_readdir, dir->dir());
  } else {  // dir.read(encoding, bufferSize, undefined, ...",1,4,node_dir.cc,node.fs_dir.DirHandle.Read,,false,281,342,Read,,,12,void node.fs_dir.DirHandle.Read (FunctionCallbackInfo<Value>)
157578,METHOD,node_dir.cc:<global>,TYPE_DECL,"void AfterOpenDir(uv_fs_t* req) {
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (!after.Proceed()) {
    return;
  }

  Environment* env = req_wrap->env();

  uv_dir_t* dir = static_cast<uv_dir_t*>(req->ptr);
  DirHandle* handle = DirHandle::New(env, dir);

  req_wrap->Resolve(handle->object().As<Value>());
}",1,2,node_dir.cc,node.fs_dir.AfterOpenDir,,false,344,359,AfterOpenDir,,,13,void node.fs_dir.AfterOpenDir (uv_fs_t*)
157752,METHOD,node_dir.cc:<global>,TYPE_DECL,"static void OpenDir(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(isolate, args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, path.ToStringView());

  const enum encoding encoding = ParseEncoding(isolate, args[1], UTF8);

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // openDir(path, encoding, req)
    FS_DIR_ASYNC_TRACE_BEGIN1(
        UV_FS_OPENDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""opendir"", encoding, AfterOpenDir,
              uv_fs_opendir, *path);
  } else {  // openDir(path, encoding, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_DIR_SYNC_TRACE_BEGIN(opendir);
    int result = SyncCall(env, args[3], &req_wrap_syn...",1,4,node_dir.cc,node.fs_dir.OpenDir,,false,361,398,OpenDir,,,14,void node.fs_dir.OpenDir (FunctionCallbackInfo<Value>)
158196,METHOD,node_dir.cc:<global>,TYPE_DECL,"void Initialize(Local<Object> target,
                Local<Value> unused,
                Local<Context> context,
                void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  SetMethod(context, target, ""opendir"", OpenDir);

  // Create FunctionTemplate for DirHandle
  Local<FunctionTemplate> dir = NewFunctionTemplate(isolate, DirHandle::New);
  dir->Inherit(AsyncWrap::GetConstructorTemplate(env));
  SetProtoMethod(isolate, dir, ""read"", DirHandle::Read);
  SetProtoMethod(isolate, dir, ""close"", DirHandle::Close);
  Local<ObjectTemplate> dirt = dir->InstanceTemplate();
  dirt->SetInternalFieldCount(DirHandle::kInternalFieldCount);
  SetConstructorFunction(context, target, ""DirHandle"", dir);
  env->set_dir_instance_template(dirt);
}",1,1,node_dir.cc,node.fs_dir.Initialize,,false,400,418,Initialize,,,15,"void node.fs_dir.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
158285,METHOD,node_dir.cc:<global>,TYPE_DECL,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(OpenDir);
  registry->Register(DirHandle::New);
  registry->Register(DirHandle::Read);
  registry->Register(DirHandle::Close);
}",1,1,node_dir.cc,node.fs_dir.RegisterExternalReferences,,false,420,425,RegisterExternalReferences,,,16,void node.fs_dir.RegisterExternalReferences (ExternalReferenceRegistry*)
158322,METHOD,node_dir.hpp:<global>,TYPE_DECL,<global>,1,26,node_dir.hpp,node_dir.hpp:<global>,,false,1,52,<global>,,,1,
158325,METHOD,node_env_var.cc:<global>,TYPE_DECL,"[&]() { uv_os_free_environ(items, count); }",31,73,node_env_var.cc,node.RealEnvStore.Enumerate.<lambda>0,,false,193,193,<lambda>0,,,1,ANY node.RealEnvStore.Enumerate.<lambda>0 ()
158351,METHOD,node_env_var.cc:<global>,TYPE_DECL,<global>,1,33,debug_utils-inl.hpp,node_env_var.cc:<global>,,false,1,490,<global>,,,1,
158355,METHOD,node.RealEnvStore,TYPE_DECL,"MaybeLocal<String> Get(Isolate* isolate, Local<String> key) const override;",22,76,node_env_var.cc,node.RealEnvStore.Get,,false,39,39,Get,,,1,"MaybeLocal<String> node.RealEnvStore.Get (Isolate*,Local<String>)"
158361,METHOD,node.RealEnvStore,TYPE_DECL,Maybe<std::string> Get(const char* key) const override;,22,56,node_env_var.cc,node.RealEnvStore.Get,,false,40,40,Get,,,2,ANY node.RealEnvStore.Get (char*)
158366,METHOD,node.RealEnvStore,TYPE_DECL,"void Set(Isolate* isolate, Local<String> key, Local<String> value) override;",8,77,node_env_var.cc,node.RealEnvStore.Set,,false,41,41,Set,,,3,"void node.RealEnvStore.Set (Isolate*,Local<String>,Local<String>)"
158373,METHOD,node.RealEnvStore,TYPE_DECL,"int32_t Query(Isolate* isolate, Local<String> key) const override;",11,67,node_env_var.cc,node.RealEnvStore.Query,,false,42,42,Query,,,4,"int32_t node.RealEnvStore.Query (Isolate*,Local<String>)"
158379,METHOD,node.RealEnvStore,TYPE_DECL,int32_t Query(const char* key) const override;,11,47,node_env_var.cc,node.RealEnvStore.Query,,false,43,43,Query,,,5,int32_t node.RealEnvStore.Query (char*)
158384,METHOD,node.RealEnvStore,TYPE_DECL,"void Delete(Isolate* isolate, Local<String> key) override;",8,59,node_env_var.cc,node.RealEnvStore.Delete,,false,44,44,Delete,,,6,"void node.RealEnvStore.Delete (Isolate*,Local<String>)"
158390,METHOD,node.RealEnvStore,TYPE_DECL,Local<Array> Enumerate(Isolate* isolate) const override;,16,57,node_env_var.cc,node.RealEnvStore.Enumerate,,false,45,45,Enumerate,,,7,Local<Array> node.RealEnvStore.Enumerate (Isolate*)
158396,METHOD,node.MapKVStore,TYPE_DECL,"MaybeLocal<String> Get(Isolate* isolate, Local<String> key) const override;",22,76,node_env_var.cc,node.MapKVStore.Get,,false,50,50,Get,,,1,"MaybeLocal<String> node.MapKVStore.Get (Isolate*,Local<String>)"
158402,METHOD,node.MapKVStore,TYPE_DECL,Maybe<std::string> Get(const char* key) const override;,22,56,node_env_var.cc,node.MapKVStore.Get,,false,51,51,Get,,,2,ANY node.MapKVStore.Get (char*)
158407,METHOD,node.MapKVStore,TYPE_DECL,"void Set(Isolate* isolate, Local<String> key, Local<String> value) override;",8,77,node_env_var.cc,node.MapKVStore.Set,,false,52,52,Set,,,3,"void node.MapKVStore.Set (Isolate*,Local<String>,Local<String>)"
158414,METHOD,node.MapKVStore,TYPE_DECL,"int32_t Query(Isolate* isolate, Local<String> key) const override;",11,67,node_env_var.cc,node.MapKVStore.Query,,false,53,53,Query,,,4,"int32_t node.MapKVStore.Query (Isolate*,Local<String>)"
158420,METHOD,node.MapKVStore,TYPE_DECL,int32_t Query(const char* key) const override;,11,47,node_env_var.cc,node.MapKVStore.Query,,false,54,54,Query,,,5,int32_t node.MapKVStore.Query (char*)
158425,METHOD,node.MapKVStore,TYPE_DECL,"void Delete(Isolate* isolate, Local<String> key) override;",8,59,node_env_var.cc,node.MapKVStore.Delete,,false,55,55,Delete,,,6,"void node.MapKVStore.Delete (Isolate*,Local<String>)"
158431,METHOD,node.MapKVStore,TYPE_DECL,Local<Array> Enumerate(Isolate* isolate) const override;,16,57,node_env_var.cc,node.MapKVStore.Enumerate,,false,56,56,Enumerate,,,7,Local<Array> node.MapKVStore.Enumerate (Isolate*)
158436,METHOD,node.MapKVStore,TYPE_DECL,std::shared_ptr<KVStore> Clone(Isolate* isolate) const override;,28,65,node_env_var.cc,node.MapKVStore.Clone,,false,58,58,Clone,,,8,ANY node.MapKVStore.Clone (Isolate*)
158441,METHOD,node.MapKVStore,TYPE_DECL,MapKVStore() = default;,3,25,node_env_var.cc,node.MapKVStore.MapKVStore,,false,60,60,MapKVStore,,,9,ANY node.MapKVStore.MapKVStore ()
158445,METHOD,node.MapKVStore,TYPE_DECL,"MapKVStore(const MapKVStore& other) : KVStore(), map_(other.map_) {}",3,70,node_env_var.cc,node.MapKVStore.MapKVStore,,false,61,61,MapKVStore,,,10,ANY node.MapKVStore.MapKVStore (MapKVStore)
158461,METHOD,node_env_var.cc:<global>,TYPE_DECL,"void DateTimeConfigurationChangeNotification(
    Isolate* isolate,
    const T& key,
    const char* val = nullptr) {
  if (key.length() == 2 && key[0] == 'T' && key[1] == 'Z') {
#ifdef __POSIX__
    tzset();
    isolate->DateTimeConfigurationChangeNotification(
        Isolate::TimeZoneDetection::kRedetect);
#else
    _tzset();

# if defined(NODE_HAVE_I18N_SUPPORT)
    isolate->DateTimeConfigurationChangeNotification(
        Isolate::TimeZoneDetection::kSkip);

    // On windows, the TZ environment is not supported out of the box.
    // By default, v8 will only be able to detect the system configured
    // timezone. This supports using the TZ environment variable to set
    // the default timezone instead.
    if (val != nullptr) i18n::SetDefaultTimeZone(val);
# else
    isolate->DateTimeConfigurationChangeNotification(
        Isolate::TimeZoneDetection::kRedetect);
# endif
#endif
  }
}",1,1,node_env_var.cc,node.DateTimeConfigurationChangeNotification,,false,74,101,DateTimeConfigurationChangeNotification,,,4,"void node.DateTimeConfigurationChangeNotification<T> (Isolate*,T,char*)"
158498,METHOD,node_env_var.cc:<global>,TYPE_DECL,"Maybe<std::string> RealEnvStore::Get(const char* key) const {
  Mutex::ScopedLock lock(per_process::env_var_mutex);

  size_t init_sz = 256;
  MaybeStackBuffer<char, 256> val;
  int ret = uv_os_getenv(key, *val, &init_sz);

  if (ret == UV_ENOBUFS) {
    // Buffer is not large enough, reallocate to the updated init_sz
    // and fetch env value again.
    val.AllocateSufficientStorage(init_sz);
    ret = uv_os_getenv(key, *val, &init_sz);
  }

  if (ret >= 0) {  // Env key value fetch success.
    return Just(std::string(*val, init_sz));
  }

  return Nothing<std::string>();
}",1,1,node_env_var.cc,node.RealEnvStore.Get,,false,103,122,Get,,,5,Maybe<std::string> node.RealEnvStore.Get (char*)
158557,METHOD,node_env_var.cc:<global>,TYPE_DECL,"MaybeLocal<String> RealEnvStore::Get(Isolate* isolate,
                                     Local<String> property) const {
  node::Utf8Value key(isolate, property);
  Maybe<std::string> value = Get(*key);

  if (value.IsJust()) {
    std::string val = value.FromJust();
    return String::NewFromUtf8(
        isolate, val.data(), NewStringType::kNormal, val.size());
  }

  return MaybeLocal<String>();
}",1,1,node_env_var.cc,node.RealEnvStore.Get,,false,124,136,Get,,,6,"MaybeLocal<String> node.RealEnvStore.Get (Isolate*,Local<String>)"
158610,METHOD,node_env_var.cc:<global>,TYPE_DECL,"void RealEnvStore::Set(Isolate* isolate,
                       Local<String> property,
                       Local<String> value) {
  Mutex::ScopedLock lock(per_process::env_var_mutex);

  node::Utf8Value key(isolate, property);
  node::Utf8Value val(isolate, value);

#ifdef _WIN32
  if (key.length() > 0 && key[0] == '=') return;
#endif
  uv_os_setenv(*key, *val);
  DateTimeConfigurationChangeNotification(isolate, key, *val);
}",1,1,node_env_var.cc,node.RealEnvStore.Set,,false,138,151,Set,,,7,"void node.RealEnvStore.Set (Isolate*,Local<String>,Local<String>)"
158640,METHOD,node_env_var.cc:<global>,TYPE_DECL,"int32_t RealEnvStore::Query(const char* key) const {
  Mutex::ScopedLock lock(per_process::env_var_mutex);

  char val[2];
  size_t init_sz = sizeof(val);
  int ret = uv_os_getenv(key, val, &init_sz);

  if (ret == UV_ENOENT) {
    return -1;
  }

#ifdef _WIN32
  if (key[0] == '=') {
    return static_cast<int32_t>(ReadOnly) |
           static_cast<int32_t>(DontDelete) |
           static_cast<int32_t>(DontEnum);
  }
#endif

  return 0;
}",1,1,node_env_var.cc,node.RealEnvStore.Query,,false,153,173,Query,,,8,int32_t node.RealEnvStore.Query (char*)
158674,METHOD,node_env_var.cc:<global>,TYPE_DECL,"int32_t RealEnvStore::Query(Isolate* isolate, Local<String> property) const {
  node::Utf8Value key(isolate, property);
  return Query(*key);
}",1,1,node_env_var.cc,node.RealEnvStore.Query,,false,175,178,Query,,,9,"int32_t node.RealEnvStore.Query (Isolate*,Local<String>)"
158688,METHOD,node_env_var.cc:<global>,TYPE_DECL,"void RealEnvStore::Delete(Isolate* isolate, Local<String> property) {
  Mutex::ScopedLock lock(per_process::env_var_mutex);

  node::Utf8Value key(isolate, property);
  uv_os_unsetenv(*key);
  DateTimeConfigurationChangeNotification(isolate, key);
}",1,1,node_env_var.cc,node.RealEnvStore.Delete,,false,180,186,Delete,,,10,"void node.RealEnvStore.Delete (Isolate*,Local<String>)"
158709,METHOD,node_env_var.cc:<global>,TYPE_DECL,"Local<Array> RealEnvStore::Enumerate(Isolate* isolate) const {
  Mutex::ScopedLock lock(per_process::env_var_mutex);
  uv_env_item_t* items;
  int count;

  auto cleanup = OnScopeLeave([&]() { uv_os_free_environ(items, count); });
  CHECK_EQ(uv_os_environ(&items, &count), 0);

  MaybeStackBuffer<Local<Value>, 256> env_v(count);
  int env_v_index = 0;
  for (int i = 0; i < count; i++) {
#ifdef _WIN32
    // If the key starts with '=' it is a hidden environment variable.
    if (items[i].name[0] == '=') continue;
#endif
    MaybeLocal<String> str = String::NewFromUtf8(isolate, items[i].name);
    if (str.IsEmpty()) {
      isolate->ThrowException(ERR_STRING_TOO_LONG(isolate));
      return Local<Array>();
    }
    env_v[env_v_index++] = str.ToLocalChecked();
  }

  return Array::New(isolate, env_v.out(), env_v_index);
}",1,1,node_env_var.cc,node.RealEnvStore.Enumerate,,false,188,212,Enumerate,,,11,Local<Array> node.RealEnvStore.Enumerate (Isolate*)
158800,METHOD,node_env_var.cc:<global>,TYPE_DECL,"std::shared_ptr<KVStore> KVStore::Clone(Isolate* isolate) const {
  HandleScope handle_scope(isolate);
  Local<Context> context = isolate->GetCurrentContext();

  std::shared_ptr<KVStore> copy = KVStore::CreateMapKVStore();
  Local<Array> keys = Enumerate(isolate);
  uint32_t keys_length = keys->Length();
  for (uint32_t i = 0; i < keys_length; i++) {
    Local<Value> key = keys->Get(context, i).ToLocalChecked();
    CHECK(key->IsString());
    copy->Set(isolate,
              key.As<String>(),
              Get(isolate, key.As<String>()).ToLocalChecked());
  }
  return copy;
}",1,1,node_env_var.cc,node.KVStore.Clone,,false,214,229,Clone,,,12,shared_ptr<KVStore> node.KVStore.Clone (Isolate*)
158897,METHOD,node_env_var.cc:<global>,TYPE_DECL,"Maybe<std::string> MapKVStore::Get(const char* key) const {
  Mutex::ScopedLock lock(mutex_);
  auto it = map_.find(key);
  return it == map_.end() ? Nothing<std::string>() : Just(it->second);
}",1,1,node_env_var.cc,node.MapKVStore.Get,,false,231,235,Get,,,13,Maybe<std::string> node.MapKVStore.Get (char*)
158927,METHOD,node_env_var.cc:<global>,TYPE_DECL,"MaybeLocal<String> MapKVStore::Get(Isolate* isolate, Local<String> key) const {
  Utf8Value str(isolate, key);
  Maybe<std::string> value = Get(*str);
  if (value.IsNothing()) return Local<String>();
  std::string val = value.FromJust();
  return String::NewFromUtf8(
      isolate, val.data(), NewStringType::kNormal, val.size());
}",1,1,node_env_var.cc,node.MapKVStore.Get,,false,237,244,Get,,,14,"MaybeLocal<String> node.MapKVStore.Get (Isolate*,Local<String>)"
158980,METHOD,node_env_var.cc:<global>,TYPE_DECL,"void MapKVStore::Set(Isolate* isolate, Local<String> key, Local<String> value) {
  Mutex::ScopedLock lock(mutex_);
  Utf8Value key_str(isolate, key);
  Utf8Value value_str(isolate, value);
  if (*key_str != nullptr && key_str.length() > 0 && *value_str != nullptr) {
    map_[std::string(*key_str, key_str.length())] =
        std::string(*value_str, value_str.length());
  }
}",1,1,node_env_var.cc,node.MapKVStore.Set,,false,246,254,Set,,,15,"void node.MapKVStore.Set (Isolate*,Local<String>,Local<String>)"
159039,METHOD,node_env_var.cc:<global>,TYPE_DECL,"int32_t MapKVStore::Query(const char* key) const {
  Mutex::ScopedLock lock(mutex_);
  return map_.find(key) == map_.end() ? -1 : 0;
}",1,1,node_env_var.cc,node.MapKVStore.Query,,false,256,259,Query,,,16,int32_t node.MapKVStore.Query (char*)
159062,METHOD,node_env_var.cc:<global>,TYPE_DECL,"int32_t MapKVStore::Query(Isolate* isolate, Local<String> key) const {
  Utf8Value str(isolate, key);
  return Query(*str);
}",1,1,node_env_var.cc,node.MapKVStore.Query,,false,261,264,Query,,,17,"int32_t node.MapKVStore.Query (Isolate*,Local<String>)"
159076,METHOD,node_env_var.cc:<global>,TYPE_DECL,"void MapKVStore::Delete(Isolate* isolate, Local<String> key) {
  Mutex::ScopedLock lock(mutex_);
  Utf8Value str(isolate, key);
  map_.erase(std::string(*str, str.length()));
}",1,1,node_env_var.cc,node.MapKVStore.Delete,,false,266,270,Delete,,,18,"void node.MapKVStore.Delete (Isolate*,Local<String>)"
159103,METHOD,node_env_var.cc:<global>,TYPE_DECL,"Local<Array> MapKVStore::Enumerate(Isolate* isolate) const {
  Mutex::ScopedLock lock(mutex_);
  std::vector<Local<Value>> values;
  values.reserve(map_.size());
  for (const auto& pair : map_) {
    values.emplace_back(
        String::NewFromUtf8(isolate, pair.first.data(),
                            NewStringType::kNormal, pair.first.size())
            .ToLocalChecked());
  }
  return Array::New(isolate, values.data(), values.size());
}",1,1,node_env_var.cc,node.MapKVStore.Enumerate,,false,272,283,Enumerate,,,19,Local<Array> node.MapKVStore.Enumerate (Isolate*)
159173,METHOD,node_env_var.cc:<global>,TYPE_DECL,"std::shared_ptr<KVStore> MapKVStore::Clone(Isolate* isolate) const {
  return std::make_shared<MapKVStore>(*this);
}",1,1,node_env_var.cc,node.MapKVStore.Clone,,false,285,287,Clone,,,20,shared_ptr<KVStore> node.MapKVStore.Clone (Isolate*)
159187,METHOD,node_env_var.cc:<global>,TYPE_DECL,"std::shared_ptr<KVStore> KVStore::CreateMapKVStore() {
  return std::make_shared<MapKVStore>();
}",1,1,node_env_var.cc,node.KVStore.CreateMapKVStore,,false,289,291,CreateMapKVStore,,,21,shared_ptr<KVStore> node.KVStore.CreateMapKVStore ()
159196,METHOD,node_env_var.cc:<global>,TYPE_DECL,"Maybe<bool> KVStore::AssignFromObject(Local<Context> context,
                                      Local<Object> entries) {
  Isolate* isolate = context->GetIsolate();
  HandleScope handle_scope(isolate);
  Local<Array> keys;
  if (!entries->GetOwnPropertyNames(context).ToLocal(&keys))
    return Nothing<bool>();
  uint32_t keys_length = keys->Length();
  for (uint32_t i = 0; i < keys_length; i++) {
    Local<Value> key;
    if (!keys->Get(context, i).ToLocal(&key))
      return Nothing<bool>();
    if (!key->IsString()) continue;

    Local<Value> value;
    Local<String> value_string;
    if (!entries->Get(context, key).ToLocal(&value) ||
        !value->ToString(context).ToLocal(&value_string)) {
      return Nothing<bool>();
    }

    Set(isolate, key.As<String>(), value_string);
  }
  return Just(true);
}",1,1,node_env_var.cc,node.KVStore.AssignFromObject,,false,293,317,AssignFromObject,,,22,"Maybe<bool> node.KVStore.AssignFromObject (Local<Context>,Local<Object>)"
159328,METHOD,node_env_var.cc:<global>,TYPE_DECL,"Maybe<bool> KVStore::AssignToObject(v8::Isolate* isolate,
                                    v8::Local<v8::Context> context,
                                    v8::Local<v8::Object> object) {
  HandleScope scope(isolate);
  Local<Array> keys = Enumerate(isolate);
  uint32_t keys_length = keys->Length();
  for (uint32_t i = 0; i < keys_length; i++) {
    Local<Value> key;
    Local<String> value;
    bool ok = keys->Get(context, i).ToLocal(&key);
    ok = ok && key->IsString();
    ok = ok && Get(isolate, key.As<String>()).ToLocal(&value);
    ok = ok && object->Set(context, key, value).To(&ok);
    if (!ok) return Nothing<bool>();
  }
  return Just(true);
}",1,1,node_env_var.cc,node.KVStore.AssignToObject,,false,321,337,AssignToObject,,,23,"Maybe<bool> node.KVStore.AssignToObject (ANY*,ANY,ANY)"
159437,METHOD,node_env_var.cc:<global>,TYPE_DECL,"static void EnvGetter(Local<Name> property,
                      const PropertyCallbackInfo<Value>& info) {
  Environment* env = Environment::GetCurrent(info);
  CHECK(env->has_run_bootstrapping_code());
  if (property->IsSymbol()) {
    return info.GetReturnValue().SetUndefined();
  }
  CHECK(property->IsString());
  MaybeLocal<String> value_string =
      env->env_vars()->Get(env->isolate(), property.As<String>());
  if (!value_string.IsEmpty()) {
    info.GetReturnValue().Set(value_string.ToLocalChecked());
  }
}",1,1,node_env_var.cc,node.EnvGetter,,false,339,352,EnvGetter,,,24,"void node.EnvGetter (Local<Name>,PropertyCallbackInfo<Value>)"
159514,METHOD,node_env_var.cc:<global>,TYPE_DECL,"static void EnvSetter(Local<Name> property,
                      Local<Value> value,
                      const PropertyCallbackInfo<Value>& info) {
  Environment* env = Environment::GetCurrent(info);
  CHECK(env->has_run_bootstrapping_code());
  // calling env->EmitProcessEnvWarning() sets a variable indicating that
  // warnings have been emitted. It should be called last after other
  // conditions leading to a warning have been met.
  if (env->options()->pending_deprecation && !value->IsString() &&
      !value->IsNumber() && !value->IsBoolean() &&
      env->EmitProcessEnvWarning()) {
    if (ProcessEmitDeprecationWarning(
            env,
            ""Assigning any value other than a string, number, or boolean to a ""
            ""process.env property is deprecated. Please make sure to convert ""
            ""the ""
            ""value to a string before setting process.env with it."",
            ""DEP0104"")
            .IsNothing())
      return;
  }

  Local<String> key;
  Loca...",1,1,node_env_var.cc,node.EnvSetter,,false,354,387,EnvSetter,,,25,"void node.EnvSetter (Local<Name>,Local<Value>,PropertyCallbackInfo<Value>)"
159638,METHOD,node_env_var.cc:<global>,TYPE_DECL,"static void EnvQuery(Local<Name> property,
                     const PropertyCallbackInfo<Integer>& info) {
  Environment* env = Environment::GetCurrent(info);
  CHECK(env->has_run_bootstrapping_code());
  if (property->IsString()) {
    int32_t rc = env->env_vars()->Query(env->isolate(), property.As<String>());
    if (rc != -1) info.GetReturnValue().Set(rc);
  }
}",1,1,node_env_var.cc,node.EnvQuery,,false,389,397,EnvQuery,,,26,"void node.EnvQuery (Local<Name>,PropertyCallbackInfo<Integer>)"
159695,METHOD,node_env_var.cc:<global>,TYPE_DECL,"static void EnvDeleter(Local<Name> property,
                       const PropertyCallbackInfo<Boolean>& info) {
  Environment* env = Environment::GetCurrent(info);
  CHECK(env->has_run_bootstrapping_code());
  if (property->IsString()) {
    env->env_vars()->Delete(env->isolate(), property.As<String>());
  }

  // process.env never has non-configurable properties, so always
  // return true like the tc39 delete operator.
  info.GetReturnValue().Set(true);
}",1,1,node_env_var.cc,node.EnvDeleter,,false,399,410,EnvDeleter,,,27,"void node.EnvDeleter (Local<Name>,PropertyCallbackInfo<Boolean>)"
159743,METHOD,node_env_var.cc:<global>,TYPE_DECL,"static void EnvEnumerator(const PropertyCallbackInfo<Array>& info) {
  Environment* env = Environment::GetCurrent(info);
  CHECK(env->has_run_bootstrapping_code());

  info.GetReturnValue().Set(
      env->env_vars()->Enumerate(env->isolate()));
}",1,1,node_env_var.cc,node.EnvEnumerator,,false,412,418,EnvEnumerator,,,28,void node.EnvEnumerator (PropertyCallbackInfo<Array>)
159779,METHOD,node_env_var.cc:<global>,TYPE_DECL,"static void EnvDefiner(Local<Name> property,
                       const PropertyDescriptor& desc,
                       const PropertyCallbackInfo<Value>& info) {
  Environment* env = Environment::GetCurrent(info);
  if (desc.has_value()) {
    if (!desc.has_writable() ||
        !desc.has_enumerable() ||
        !desc.has_configurable()) {
      THROW_ERR_INVALID_OBJECT_DEFINE_PROPERTY(env,
                                               ""'process.env' only accepts a ""
                                               ""configurable, writable,""
                                               "" and enumerable ""
                                               ""data descriptor"");
    } else if (!desc.configurable() ||
               !desc.enumerable() ||
               !desc.writable()) {
      THROW_ERR_INVALID_OBJECT_DEFINE_PROPERTY(env,
                                               ""'process.env' only accepts a ""
                                               ""configurable, writable,""...",1,1,node_env_var.cc,node.EnvDefiner,,false,420,457,EnvDefiner,,,29,"void node.EnvDefiner (Local<Name>,PropertyDescriptor,PropertyCallbackInfo<Value>)"
159877,METHOD,node_env_var.cc:<global>,TYPE_DECL,"void CreateEnvProxyTemplate(Isolate* isolate, IsolateData* isolate_data) {
  HandleScope scope(isolate);
  if (!isolate_data->env_proxy_template().IsEmpty()) return;
  Local<FunctionTemplate> env_proxy_ctor_template =
      FunctionTemplate::New(isolate);
  Local<ObjectTemplate> env_proxy_template =
      ObjectTemplate::New(isolate, env_proxy_ctor_template);
  env_proxy_template->SetHandler(NamedPropertyHandlerConfiguration(
      EnvGetter,
      EnvSetter,
      EnvQuery,
      EnvDeleter,
      EnvEnumerator,
      EnvDefiner,
      nullptr,
      Local<Value>(),
      PropertyHandlerFlags::kHasNoSideEffect));
  isolate_data->set_env_proxy_template(env_proxy_template);
  isolate_data->set_env_proxy_ctor_template(env_proxy_ctor_template);
}",1,1,node_env_var.cc,node.CreateEnvProxyTemplate,,false,459,478,CreateEnvProxyTemplate,,,30,"void node.CreateEnvProxyTemplate (Isolate*,IsolateData*)"
159946,METHOD,node_env_var.cc:<global>,TYPE_DECL,"void RegisterEnvVarExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(EnvGetter);
  registry->Register(EnvSetter);
  registry->Register(EnvQuery);
  registry->Register(EnvDeleter);
  registry->Register(EnvEnumerator);
  registry->Register(EnvDefiner);
}",1,1,node_env_var.cc,node.RegisterEnvVarExternalReferences,,false,480,487,RegisterEnvVarExternalReferences,,,31,void node.RegisterEnvVarExternalReferences (ExternalReferenceRegistry*)
159983,METHOD,node_errors.cc:<global>,TYPE_DECL,"[&]() {
#if HAVE_INSPECTOR
    env->inspector_agent()->ReportUncaughtException(error, message);
#endif
  }",30,3,node_errors.cc,node.ReportFatalException.<lambda>0,,false,376,380,<lambda>0,,,1,ANY node.ReportFatalException.<lambda>0 ()
159989,METHOD,node_errors.cc:<global>,TYPE_DECL,"[&](Local<Function> enhancer) {
      Local<Value> enhanced;
      Local<Value> argv[] = {err_obj};
      if (!enhancer.IsEmpty() &&
          enhancer
              ->Call(env->context(), Undefined(isolate), arraysize(argv), argv)
              .ToLocal(&enhanced)) {
        stack_trace = enhanced;
      }
    }",25,5,node_errors.cc,node.ReportFatalException.<lambda>1,,false,396,405,<lambda>1,,,1,ANY node.ReportFatalException.<lambda>1 (Local<Function>)
160057,METHOD,node_errors.cc:<global>,TYPE_DECL,<global>,1,1,node_errors.cc,node_errors.cc:<global>,,false,1,1231,<global>,,,1,
160060,METHOD,node_errors.cc:<global>,TYPE_DECL,"bool IsExceptionDecorated(Environment* env, Local<Value> er) {
  if (!er.IsEmpty() && er->IsObject()) {
    Local<Object> err_obj = er.As<Object>();
    auto maybe_value =
        err_obj->GetPrivate(env->context(), env->decorated_private_symbol());
    Local<Value> decorated;
    return maybe_value.ToLocal(&decorated) && decorated->IsTrue();
  }
  return false;
}",1,1,node_errors.cc,node.IsExceptionDecorated,,false,37,46,IsExceptionDecorated,,,1,"bool node.IsExceptionDecorated (Environment*,Local<Value>)"
160124,METHOD,node_errors.cc:<global>,TYPE_DECL,"static std::string GetSourceMapErrorSource(Isolate* isolate,
                                           Local<Context> context,
                                           Local<Message> message,
                                           bool* added_exception_line) {
  v8::TryCatch try_catch(isolate);
  HandleScope handle_scope(isolate);
  Environment* env = Environment::GetCurrent(context);

  // The ScriptResourceName of the message may be different from the one we use
  // to compile the script. V8 replaces it when it detects magic comments in
  // the source texts.
  Local<Value> script_resource_name = message->GetScriptResourceName();
  int linenum = message->GetLineNumber(context).FromJust();
  int columnum = message->GetStartColumn(context).FromJust();

  Local<Value> argv[] = {script_resource_name,
                         v8::Int32::New(isolate, linenum),
                         v8::Int32::New(isolate, columnum)};
  MaybeLocal<Value> maybe_ret = env->get_source_map_error_s...",1,1,node_errors.cc,node.GetSourceMapErrorSource,,false,52,84,GetSourceMapErrorSource,,,3,"string node.GetSourceMapErrorSource (Isolate*,Local<Context>,Local<Message>,bool*)"
160268,METHOD,node_errors.cc:<global>,TYPE_DECL,"static std::string GetErrorSource(Isolate* isolate,
                                  Local<Context> context,
                                  Local<Message> message,
                                  bool* added_exception_line) {
  MaybeLocal<String> source_line_maybe = message->GetSourceLine(context);
  node::Utf8Value encoded_source(isolate, source_line_maybe.ToLocalChecked());
  std::string sourceline(*encoded_source, encoded_source.length());
  *added_exception_line = false;

  if (sourceline.find(""node-do-not-add-exception-line"") != std::string::npos) {
    return sourceline;
  }

  // If source maps have been enabled, the exception line will instead be
  // added in the JavaScript context:
  Environment* env = Environment::GetCurrent(isolate);
  const bool has_source_map_url =
      !message->GetScriptOrigin().SourceMapUrl().IsEmpty() &&
      !message->GetScriptOrigin().SourceMapUrl()->IsUndefined();
  if (has_source_map_url && env != nullptr && env->source_maps_enabled()) ...",1,1,node_errors.cc,node.GetErrorSource,,false,86,186,GetErrorSource,,,4,"string node.GetErrorSource (Isolate*,Local<Context>,Local<Message>,bool*)"
160607,METHOD,node_errors.cc:<global>,TYPE_DECL,"static std::string FormatStackTrace(Isolate* isolate, Local<StackTrace> stack) {
  std::string result;
  for (int i = 0; i < stack->GetFrameCount(); i++) {
    Local<StackFrame> stack_frame = stack->GetFrame(isolate, i);
    node::Utf8Value fn_name_s(isolate, stack_frame->GetFunctionName());
    node::Utf8Value script_name(isolate, stack_frame->GetScriptName());
    const int line_number = stack_frame->GetLineNumber();
    const int column = stack_frame->GetColumn();

    if (stack_frame->IsEval()) {
      if (stack_frame->GetScriptId() == Message::kNoScriptIdInfo) {
        result += SPrintF(""    at [eval]:%i:%i\n"", line_number, column);
      } else {
        std::vector<char> buf(script_name.length() + 64);
        snprintf(buf.data(),
                 buf.size(),
                 ""    at [eval] (%s:%i:%i)\n"",
                 *script_name,
                 line_number,
                 column);
        result += std::string(buf.data());
      }
      break;
    }

    if (fn_nam...",1,1,node_errors.cc,node.FormatStackTrace,,false,188,235,FormatStackTrace,,,5,"string node.FormatStackTrace (Isolate*,Local<StackTrace>)"
160809,METHOD,node_errors.cc:<global>,TYPE_DECL,"static void PrintToStderrAndFlush(const std::string& str) {
  FPrintF(stderr, ""%s\n"", str);
  fflush(stderr);
}",1,1,node_errors.cc,node.PrintToStderrAndFlush,,false,237,240,PrintToStderrAndFlush,,,6,void node.PrintToStderrAndFlush (ANY)
160819,METHOD,node_errors.cc:<global>,TYPE_DECL,"void PrintStackTrace(Isolate* isolate, Local<StackTrace> stack) {
  PrintToStderrAndFlush(FormatStackTrace(isolate, stack));
}",1,1,node_errors.cc,node.PrintStackTrace,,false,242,244,PrintStackTrace,,,7,"void node.PrintStackTrace (Isolate*,Local<StackTrace>)"
160829,METHOD,node_errors.cc:<global>,TYPE_DECL,"std::string FormatCaughtException(Isolate* isolate,
                                  Local<Context> context,
                                  Local<Value> err,
                                  Local<Message> message,
                                  bool add_source_line = true) {
  std::string result;
  node::Utf8Value reason(isolate,
                         err->ToDetailString(context)
                             .FromMaybe(Local<String>()));
  if (add_source_line) {
    bool added_exception_line = false;
    std::string source =
        GetErrorSource(isolate, context, message, &added_exception_line);
    result = source + '\n';
  }
  result += reason.ToString() + '\n';

  Local<v8::StackTrace> stack = message->GetStackTrace();
  if (!stack.IsEmpty()) result += FormatStackTrace(isolate, stack);
  return result;
}",1,1,node_errors.cc,node.FormatCaughtException,,false,246,266,FormatCaughtException,,,8,"string node.FormatCaughtException (Isolate*,Local<Context>,Local<Value>,Local<Message>,bool)"
160906,METHOD,node_errors.cc:<global>,TYPE_DECL,"std::string FormatCaughtException(Isolate* isolate,
                                  Local<Context> context,
                                  const v8::TryCatch& try_catch) {
  CHECK(try_catch.HasCaught());
  return FormatCaughtException(
      isolate, context, try_catch.Exception(), try_catch.Message());
}",1,1,node_errors.cc,node.FormatCaughtException,,false,268,274,FormatCaughtException,,,9,"string node.FormatCaughtException (Isolate*,Local<Context>,ANY)"
160930,METHOD,node_errors.cc:<global>,TYPE_DECL,"void PrintCaughtException(Isolate* isolate,
                          Local<Context> context,
                          const v8::TryCatch& try_catch) {
  PrintToStderrAndFlush(FormatCaughtException(isolate, context, try_catch));
}",1,1,node_errors.cc,node.PrintCaughtException,,false,276,280,PrintCaughtException,,,10,"void node.PrintCaughtException (Isolate*,Local<Context>,ANY)"
160942,METHOD,node_errors.cc:<global>,TYPE_DECL,"void AppendExceptionLine(Environment* env,
                         Local<Value> er,
                         Local<Message> message,
                         enum ErrorHandlingMode mode) {
  if (message.IsEmpty()) return;

  HandleScope scope(env->isolate());
  Local<Object> err_obj;
  if (!er.IsEmpty() && er->IsObject()) {
    err_obj = er.As<Object>();
    // If arrow_message is already set, skip.
    auto maybe_value = err_obj->GetPrivate(env->context(),
                                          env->arrow_message_private_symbol());
    Local<Value> lvalue;
    if (!maybe_value.ToLocal(&lvalue) || lvalue->IsString())
      return;
  }

  bool added_exception_line = false;
  std::string source = GetErrorSource(
      env->isolate(), env->context(), message, &added_exception_line);
  if (!added_exception_line) {
    return;
  }
  MaybeLocal<Value> arrow_str = ToV8Value(env->context(), source);

  const bool can_set_arrow = !arrow_str.IsEmpty() && !err_obj.IsEmpty();
  // If alloca...",1,1,node_errors.cc,node.AppendExceptionLine,,false,282,329,AppendExceptionLine,,,11,"void node.AppendExceptionLine (Environment*,Local<Value>,Local<Message>,ErrorHandlingMode)"
161129,METHOD,node_errors.cc:<global>,TYPE_DECL,"[[noreturn]] void Abort() {
  DumpBacktrace(stderr);
  fflush(stderr);
  ABORT_NO_BACKTRACE();
}",1,1,node_errors.cc,node.Abort,,false,331,335,Abort,,,12,void node.Abort ()
161137,METHOD,node_errors.cc:<global>,TYPE_DECL,"[[noreturn]] void Assert(const AssertionInfo& info) {
  std::string name = GetHumanReadableProcessName();

  fprintf(stderr,
          ""%s: %s:%s%s Assertion `%s' failed.\n"",
          name.c_str(),
          info.file_line,
          info.function,
          *info.function ? "":"" : """",
          info.message);
  fflush(stderr);

  Abort();
}",1,1,node_errors.cc,node.Assert,,false,337,350,Assert,,,13,void node.Assert (AssertionInfo)
161174,METHOD,node_errors.cc:<global>,TYPE_DECL,"static void ReportFatalException(Environment* env,
                                 Local<Value> error,
                                 Local<Message> message,
                                 EnhanceFatalException enhance_stack) {
  if (!env->can_call_into_js())
    enhance_stack = EnhanceFatalException::kDontEnhance;

  Isolate* isolate = env->isolate();
  CHECK(!error.IsEmpty());
  CHECK(!message.IsEmpty());
  HandleScope scope(isolate);

  AppendExceptionLine(env, error, message, FATAL_ERROR);

  auto report_to_inspector = [&]() {
#if HAVE_INSPECTOR
    env->inspector_agent()->ReportUncaughtException(error, message);
#endif
  };

  Local<Value> arrow;
  Local<Value> stack_trace;
  bool decorated = IsExceptionDecorated(env, error);

  if (!error->IsObject()) {  // We can only enhance actual errors.
    report_to_inspector();
    stack_trace = Undefined(isolate);
    // If error is not an object, AppendExceptionLine() has already print the
    // source line and the arrow to stde...",1,1,node_errors.cc,node.ReportFatalException,,false,362,505,ReportFatalException,,,15,"void node.ReportFatalException (Environment*,Local<Value>,Local<Message>,EnhanceFatalException)"
161664,METHOD,node_errors.cc:<global>,TYPE_DECL,"[[noreturn]] void OnFatalError(const char* location, const char* message) {
  if (location) {
    FPrintF(stderr, ""FATAL ERROR: %s %s\n"", location, message);
  } else {
    FPrintF(stderr, ""FATAL ERROR: %s\n"", message);
  }

  Isolate* isolate = Isolate::TryGetCurrent();
  bool report_on_fatalerror;
  {
    Mutex::ScopedLock lock(node::per_process::cli_options_mutex);
    report_on_fatalerror = per_process::cli_options->report_on_fatalerror;
  }

  if (report_on_fatalerror) {
    TriggerNodeReport(isolate, message, ""FatalError"", """", Local<Object>());
  }

  fflush(stderr);
  ABORT();
}",1,1,node_errors.cc,node.OnFatalError,,false,507,527,OnFatalError,,,16,"void node.OnFatalError (char*,char*)"
161718,METHOD,node_errors.cc:<global>,TYPE_DECL,"[[noreturn]] void OOMErrorHandler(const char* location,
                                  const v8::OOMDetails& details) {
  const char* message =
      details.is_heap_oom ? ""Allocation failed - JavaScript heap out of memory""
                          : ""Allocation failed - process out of memory"";
  if (location) {
    FPrintF(stderr, ""FATAL ERROR: %s %s\n"", location, message);
  } else {
    FPrintF(stderr, ""FATAL ERROR: %s\n"", message);
  }

  Isolate* isolate = Isolate::TryGetCurrent();
  bool report_on_fatalerror;
  {
    Mutex::ScopedLock lock(node::per_process::cli_options_mutex);
    report_on_fatalerror = per_process::cli_options->report_on_fatalerror;
  }

  if (report_on_fatalerror) {
    // Trigger report with the isolate. Environment::GetCurrent may return
    // nullptr here:
    // - If the OOM is reported by a young generation space allocation,
    //   Isolate::GetCurrentContext returns an empty handle.
    // - Otherwise, Isolate::GetCurrentContext returns a non-em...",1,1,node_errors.cc,node.OOMErrorHandler,,false,529,558,OOMErrorHandler,,,17,"void node.OOMErrorHandler (char*,ANY)"
161781,METHOD,node_errors.cc:<global>,TYPE_DECL,"v8::ModifyCodeGenerationFromStringsResult ModifyCodeGenerationFromStrings(
    v8::Local<v8::Context> context,
    v8::Local<v8::Value> source,
    bool is_code_like) {
  HandleScope scope(context->GetIsolate());

  Environment* env = Environment::GetCurrent(context);
  if (env->source_maps_enabled()) {
    // We do not expect the maybe_cache_generated_source_map to throw any more
    // exceptions. If it does, just ignore it.
    errors::TryCatchScope try_catch(env);
    Local<Function> maybe_cache_source_map =
        env->maybe_cache_generated_source_map();
    Local<Value> argv[1] = {source};

    MaybeLocal<Value> maybe_cached = maybe_cache_source_map->Call(
        context, context->Global(), arraysize(argv), argv);
    if (maybe_cached.IsEmpty()) {
      DCHECK(try_catch.HasCaught());
    }
  }

  Local<Value> allow_code_gen = context->GetEmbedderData(
      ContextEmbedderIndex::kAllowCodeGenerationFromStrings);
  bool codegen_allowed =
      allow_code_gen->IsUndefined() ||...",1,1,node_errors.cc,node.ModifyCodeGenerationFromStrings,,false,560,590,ModifyCodeGenerationFromStrings,,,18,"ModifyCodeGenerationFromStringsResult node.ModifyCodeGenerationFromStrings (ANY,ANY,bool)"
161885,METHOD,node_errors.cc:<global>,TYPE_DECL,"TryCatchScope::~TryCatchScope() {
  if (HasCaught() && !HasTerminated() && mode_ == CatchMode::kFatal) {
    HandleScope scope(env_->isolate());
    Local<v8::Value> exception = Exception();
    Local<v8::Message> message = Message();
    EnhanceFatalException enhance = CanContinue() ?
        EnhanceFatalException::kEnhance : EnhanceFatalException::kDontEnhance;
    if (message.IsEmpty())
      message = Exception::CreateMessage(env_->isolate(), exception);
    ReportFatalException(env_, exception, message, enhance);
    env_->Exit(ExitCode::kExceptionInFatalExceptionHandler);
  }
}",1,1,node_errors.cc,node.errors.TryCatchScope.~TryCatchScope,,false,594,606,~TryCatchScope,,,1,ANY node.errors.TryCatchScope.~TryCatchScope ()
161965,METHOD,node_errors.cc:<global>,TYPE_DECL,"const char* errno_string(int errorno) {
#define ERRNO_CASE(e)                                                          \
  case e:                                                                      \
    return #e;
  switch (errorno) {
#ifdef EACCES
    ERRNO_CASE(EACCES);
#endif

#ifdef EADDRINUSE
    ERRNO_CASE(EADDRINUSE);
#endif

#ifdef EADDRNOTAVAIL
    ERRNO_CASE(EADDRNOTAVAIL);
#endif

#ifdef EAFNOSUPPORT
    ERRNO_CASE(EAFNOSUPPORT);
#endif

#ifdef EAGAIN
    ERRNO_CASE(EAGAIN);
#endif

#ifdef EWOULDBLOCK
#if EAGAIN != EWOULDBLOCK
    ERRNO_CASE(EWOULDBLOCK);
#endif
#endif

#ifdef EALREADY
    ERRNO_CASE(EALREADY);
#endif

#ifdef EBADF
    ERRNO_CASE(EBADF);
#endif

#ifdef EBADMSG
    ERRNO_CASE(EBADMSG);
#endif

#ifdef EBUSY
    ERRNO_CASE(EBUSY);
#endif

#ifdef ECANCELED
    ERRNO_CASE(ECANCELED);
#endif

#ifdef ECHILD
    ERRNO_CASE(ECHILD);
#endif

#ifdef ECONNABORTED
    ERRNO_CASE(ECONNABORTED);
#endif

#ifdef ECONNREFUSED
    ERRNO_CASE(ECONNREFUSED);
#endif

#ifdef...",1,1,node_errors.cc,node.errors.errno_string,,false,608,934,errno_string,,,2,const char* node.errors.errno_string (int)
161976,METHOD,node_errors.cc:<global>,TYPE_DECL,"void PerIsolateMessageListener(Local<Message> message, Local<Value> error) {
  Isolate* isolate = message->GetIsolate();
  switch (message->ErrorLevel()) {
    case Isolate::MessageErrorLevel::kMessageWarning: {
      Environment* env = Environment::GetCurrent(isolate);
      if (!env) {
        break;
      }
      Utf8Value filename(isolate, message->GetScriptOrigin().ResourceName());
      // (filename):(line) (message)
      std::stringstream warning;
      warning << *filename;
      warning << "":"";
      warning << message->GetLineNumber(env->context()).FromMaybe(-1);
      warning << "" "";
      v8::String::Utf8Value msg(isolate, message->Get());
      warning << *msg;
      USE(ProcessEmitWarningGeneric(env, warning.str().c_str(), ""V8""));
      break;
    }
    case Isolate::MessageErrorLevel::kMessageError:
      TriggerUncaughtException(isolate, error, message);
      break;
  }
}",1,1,node_errors.cc,node.errors.PerIsolateMessageListener,,false,936,960,PerIsolateMessageListener,,,3,"void node.errors.PerIsolateMessageListener (Local<Message>,Local<Value>)"
162085,METHOD,node_errors.cc:<global>,TYPE_DECL,"void SetPrepareStackTraceCallback(const FunctionCallbackInfo<Value>& args) {
  Realm* realm = Realm::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  realm->set_prepare_stack_trace_callback(args[0].As<Function>());
}",1,1,node_errors.cc,node.errors.SetPrepareStackTraceCallback,,false,962,966,SetPrepareStackTraceCallback,,,4,void node.errors.SetPrepareStackTraceCallback (FunctionCallbackInfo<Value>)
162115,METHOD,node_errors.cc:<global>,TYPE_DECL,"static void SetSourceMapsEnabled(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsBoolean());
  env->set_source_maps_enabled(args[0].As<Boolean>()->Value());
}",1,1,node_errors.cc,node.errors.SetSourceMapsEnabled,,false,968,972,SetSourceMapsEnabled,,,5,void node.errors.SetSourceMapsEnabled (FunctionCallbackInfo<Value>)
162148,METHOD,node_errors.cc:<global>,TYPE_DECL,"static void SetGetSourceMapErrorSource(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  env->set_get_source_map_error_source(args[0].As<Function>());
}",1,1,node_errors.cc,node.errors.SetGetSourceMapErrorSource,,false,974,979,SetGetSourceMapErrorSource,,,6,void node.errors.SetGetSourceMapErrorSource (FunctionCallbackInfo<Value>)
162178,METHOD,node_errors.cc:<global>,TYPE_DECL,"static void SetMaybeCacheGeneratedSourceMap(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  env->set_maybe_cache_generated_source_map(args[0].As<Function>());
}",1,1,node_errors.cc,node.errors.SetMaybeCacheGeneratedSourceMap,,false,981,986,SetMaybeCacheGeneratedSourceMap,,,7,void node.errors.SetMaybeCacheGeneratedSourceMap (FunctionCallbackInfo<Value>)
162208,METHOD,node_errors.cc:<global>,TYPE_DECL,"static void SetEnhanceStackForFatalException(
    const FunctionCallbackInfo<Value>& args) {
  Realm* realm = Realm::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  CHECK(args[1]->IsFunction());
  realm->set_enhance_fatal_stack_before_inspector(args[0].As<Function>());
  realm->set_enhance_fatal_stack_after_inspector(args[1].As<Function>());
}",1,1,node_errors.cc,node.errors.SetEnhanceStackForFatalException,,false,988,995,SetEnhanceStackForFatalException,,,8,void node.errors.SetEnhanceStackForFatalException (FunctionCallbackInfo<Value>)
162255,METHOD,node_errors.cc:<global>,TYPE_DECL,"static void NoSideEffectsToString(const FunctionCallbackInfo<Value>& args) {
  Local<Context> context = args.GetIsolate()->GetCurrentContext();
  Local<String> detail_string;
  if (args[0]->ToDetailString(context).ToLocal(&detail_string))
    args.GetReturnValue().Set(detail_string);
}",1,1,node_errors.cc,node.errors.NoSideEffectsToString,,false,998,1003,NoSideEffectsToString,,,9,void node.errors.NoSideEffectsToString (FunctionCallbackInfo<Value>)
162300,METHOD,node_errors.cc:<global>,TYPE_DECL,"static void TriggerUncaughtException(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();
  Environment* env = Environment::GetCurrent(isolate);
  Local<Value> exception = args[0];
  Local<Message> message = Exception::CreateMessage(isolate, exception);
  if (env != nullptr && env->abort_on_uncaught_exception()) {
    ReportFatalException(
        env, exception, message, EnhanceFatalException::kEnhance);
    Abort();
  }
  bool from_promise = args[1]->IsTrue();
  errors::TriggerUncaughtException(isolate, exception, message, from_promise);
}",1,1,node_errors.cc,node.errors.TriggerUncaughtException,,false,1005,1017,TriggerUncaughtException,,,10,void node.errors.TriggerUncaughtException (FunctionCallbackInfo<Value>)
162376,METHOD,node_errors.cc:<global>,TYPE_DECL,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(SetPrepareStackTraceCallback);
  registry->Register(SetGetSourceMapErrorSource);
  registry->Register(SetSourceMapsEnabled);
  registry->Register(SetMaybeCacheGeneratedSourceMap);
  registry->Register(SetEnhanceStackForFatalException);
  registry->Register(NoSideEffectsToString);
  registry->Register(TriggerUncaughtException);
}",1,1,node_errors.cc,node.errors.RegisterExternalReferences,,false,1019,1027,RegisterExternalReferences,,,11,void node.errors.RegisterExternalReferences (ExternalReferenceRegistry*)
162416,METHOD,node_errors.cc:<global>,TYPE_DECL,"void Initialize(Local<Object> target,
                Local<Value> unused,
                Local<Context> context,
                void* priv) {
  SetMethod(context,
            target,
            ""setPrepareStackTraceCallback"",
            SetPrepareStackTraceCallback);
  SetMethod(context,
            target,
            ""setGetSourceMapErrorSource"",
            SetGetSourceMapErrorSource);
  SetMethod(context, target, ""setSourceMapsEnabled"", SetSourceMapsEnabled);
  SetMethod(context,
            target,
            ""setMaybeCacheGeneratedSourceMap"",
            SetMaybeCacheGeneratedSourceMap);
  SetMethod(context,
            target,
            ""setEnhanceStackForFatalException"",
            SetEnhanceStackForFatalException);
  SetMethodNoSideEffect(
      context, target, ""noSideEffectsToString"", NoSideEffectsToString);
  SetMethod(
      context, target, ""triggerUncaughtException"", TriggerUncaughtException);

  Isolate* isolate = context->GetIsolate();
  Local<Object> exit_...",1,1,node_errors.cc,node.errors.Initialize,,false,1029,1065,Initialize,,,12,"void node.errors.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
162483,METHOD,node_errors.cc:<global>,TYPE_DECL,"void DecorateErrorStack(Environment* env,
                        const errors::TryCatchScope& try_catch) {
  Local<Value> exception = try_catch.Exception();

  if (!exception->IsObject()) return;

  Local<Object> err_obj = exception.As<Object>();

  if (IsExceptionDecorated(env, err_obj)) return;

  AppendExceptionLine(env, exception, try_catch.Message(), CONTEXTIFY_ERROR);
  TryCatchScope try_catch_scope(env);  // Ignore exceptions below.
  MaybeLocal<Value> stack = err_obj->Get(env->context(), env->stack_string());
  MaybeLocal<Value> maybe_value =
      err_obj->GetPrivate(env->context(), env->arrow_message_private_symbol());

  Local<Value> arrow;
  if (!(maybe_value.ToLocal(&arrow) && arrow->IsString())) {
    return;
  }

  if (stack.IsEmpty() || !stack.ToLocalChecked()->IsString()) {
    return;
  }

  Local<String> decorated_stack = String::Concat(
      env->isolate(),
      String::Concat(env->isolate(),
                     arrow.As<String>(),
                     FIXED_...",1,1,node_errors.cc,node.errors.DecorateErrorStack,,false,1067,1101,DecorateErrorStack,,,13,"void node.errors.DecorateErrorStack (Environment*,ANY)"
162676,METHOD,node_errors.cc:<global>,TYPE_DECL,"void TriggerUncaughtException(Isolate* isolate,
                              Local<Value> error,
                              Local<Message> message,
                              bool from_promise) {
  CHECK(!error.IsEmpty());
  HandleScope scope(isolate);

  if (message.IsEmpty()) message = Exception::CreateMessage(isolate, error);

  CHECK(isolate->InContext());
  Local<Context> context = isolate->GetCurrentContext();
  Environment* env = Environment::GetCurrent(context);
  if (env == nullptr) {
    // This means that the exception happens before Environment is assigned
    // to the context e.g. when there is a SyntaxError in a per-context
    // script - which usually indicates that there is a bug because no JS
    // error is supposed to be thrown at this point.
    // Since we don't have access to Environment here, there is not
    // much we can do, so we just print whatever is useful and crash.
    PrintToStderrAndFlush(
        FormatCaughtException(isolate, context, err...",1,1,node_errors.cc,node.errors.TriggerUncaughtException,,false,1103,1189,TriggerUncaughtException,,,14,"void node.errors.TriggerUncaughtException (Isolate*,Local<Value>,Local<Message>,bool)"
162896,METHOD,node_errors.cc:<global>,TYPE_DECL,"void TriggerUncaughtException(Isolate* isolate, const v8::TryCatch& try_catch) {
  // If the try_catch is verbose, the per-isolate message listener is going to
  // handle it (which is going to call into another overload of
  // TriggerUncaughtException()).
  if (try_catch.IsVerbose()) {
    return;
  }

  // If the user calls TryCatch::TerminateExecution() on this TryCatch
  // they must call CancelTerminateExecution() again before invoking
  // TriggerUncaughtException() because it will invoke
  // process._fatalException() in the JS land.
  CHECK(!try_catch.HasTerminated());
  CHECK(try_catch.HasCaught());
  HandleScope scope(isolate);
  TriggerUncaughtException(isolate,
                           try_catch.Exception(),
                           try_catch.Message(),
                           false /* from_promise */);
}",1,1,node_errors.cc,node.errors.TriggerUncaughtException,,false,1191,1210,TriggerUncaughtException,,,15,"void node.errors.TriggerUncaughtException (Isolate*,ANY)"
162934,METHOD,node_errors.cc:<global>,TYPE_DECL,"PrinterTryCatch::~PrinterTryCatch() {
  if (!HasCaught()) {
    return;
  }
  std::string str =
      FormatCaughtException(isolate_,
                            isolate_->GetCurrentContext(),
                            Exception(),
                            Message(),
                            print_source_line_ == kPrintSourceLine);
  PrintToStderrAndFlush(str);
}",1,1,node_errors.cc,node.errors.PrinterTryCatch.~PrinterTryCatch,,false,1212,1223,~PrinterTryCatch,,,16,ANY node.errors.PrinterTryCatch.~PrinterTryCatch ()
162971,METHOD,node_errors.hpp:<global>,TYPE_DECL,<global>,1,29,node_errors.hpp,node_errors.hpp:<global>,,false,1,313,<global>,,,1,
162976,METHOD,node_exit_code.hpp:<global>,TYPE_DECL,<global>,1,32,node_exit_code.hpp,node_exit_code.hpp:<global>,,false,1,54,<global>,,,1,
162991,METHOD,node_external_reference.cc:<global>,TYPE_DECL,<global>,1,41,node_external_reference.hpp,node_external_reference.cc:<global>,,false,1,27,<global>,,,1,
162994,METHOD,node_external_reference.cc:<global>,TYPE_DECL,"const std::vector<intptr_t>& ExternalReferenceRegistry::external_references() {
  if (!is_finalized_) {
    external_references_.push_back(reinterpret_cast<intptr_t>(nullptr));
    is_finalized_ = true;
  }

  return external_references_;
}",1,1,node_external_reference.cc,node.ExternalReferenceRegistry.external_references,,false,9,16,external_references,,,1,vector<intptr_t> node.ExternalReferenceRegistry.external_references ()
163014,METHOD,node_external_reference.cc:<global>,TYPE_DECL,"ExternalReferenceRegistry::ExternalReferenceRegistry() {
  this->Register(BaseObject::LazilyInitializedJSTemplateConstructor);

#define V(modname) _register_external_reference_##modname(this);
  EXTERNAL_REFERENCE_BINDING_LIST(V)
#undef V
  // TODO(joyeecheung): collect more external references here.
}",1,1,node_external_reference.cc,node.ExternalReferenceRegistry.ExternalReferenceRegistry,,false,18,25,ExternalReferenceRegistry,,,2,ANY node.ExternalReferenceRegistry.ExternalReferenceRegistry ()
163038,METHOD,node_external_reference.hpp:<global>,TYPE_DECL,<global>,1,41,node_external_reference.hpp,node_external_reference.hpp:<global>,,false,1,172,<global>,,,1,
163047,METHOD,node_file-inl.hpp:<global>,TYPE_DECL,<global>,1,31,node_file-inl.hpp,node_file-inl.hpp:<global>,,false,1,356,<global>,,,1,
163050,METHOD,node_file.cc:<global>,TYPE_DECL,"[detail](Environment* env) {
      char msg[70];
      snprintf(msg, arraysize(msg),
              ""Closing file descriptor %d on garbage collection failed"",
              detail.fd);
      // This exception will end up being fatal for the process because
      // it is being thrown from within the SetImmediate handler and
      // there is no JS stack to bubble it to. In other words, tearing
      // down the process is the only reasonable thing we can do here.
      HandleScope handle_scope(env->isolate());
      env->ThrowUVException(detail.ret, ""close"", msg);
    }",25,5,node_file.cc,node.fs.FileHandle.Close.<lambda>0,,false,362,373,<lambda>0,,,1,ANY node.fs.FileHandle.Close.<lambda>0 (Environment*)
163082,METHOD,node_file.cc:<global>,TYPE_DECL,"[detail](Environment* env) {
    ProcessEmitWarning(env,
                       ""Closing file descriptor %d on garbage collection"",
                       detail.fd);
    if (env->filehandle_close_warning()) {
      env->set_filehandle_close_warning(false);
      USE(ProcessEmitDeprecationWarning(
          env,
          ""Closing a FileHandle object on garbage collection is deprecated. ""
          ""Please close FileHandle objects explicitly using ""
          ""FileHandle.prototype.close(). In the future, an error will be ""
          ""thrown if a file descriptor is closed during garbage collection."",
          ""DEP0137""));
    }
  }",23,3,node_file.cc,node.fs.FileHandle.Close.<lambda>1,,false,381,395,<lambda>1,,,1,ANY node.fs.FileHandle.Close.<lambda>1 (Environment*)
163110,METHOD,node_file.cc:<global>,TYPE_DECL,"[](uv_fs_t* req) {
    CloseReq* req_wrap = CloseReq::from_req(req);
    FS_ASYNC_TRACE_END1(
        req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
    BaseObjectPtr<CloseReq> close(req_wrap);
    CHECK(close);
    close->file_handle()->AfterClose();
    if (!close->env()->can_call_into_js()) return;
    Isolate* isolate = close->env()->isolate();
    if (req->result < 0) {
      HandleScope handle_scope(isolate);
      close->Reject(
          UVException(isolate, static_cast<int>(req->result), ""close""));
    } else {
      close->Resolve();
    }
  }",38,4,node_file.cc,node.fs.FileHandle.ClosePromise.<lambda>2,,false,483,499,<lambda>2,,,1,ANY node.fs.FileHandle.ClosePromise.<lambda>2 (uv_fs_t*)
163302,METHOD,node_file.cc:<global>,TYPE_DECL,"[](uv_fs_t* req) {
    FileHandle* handle;
    {
      FileHandleReadWrap* req_wrap = FileHandleReadWrap::from_req(req);
      FS_ASYNC_TRACE_END1(
          req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
      handle = req_wrap->file_handle_;
      CHECK_EQ(handle->current_read_.get(), req_wrap);
    }

    // ReadStart() checks whether current_read_ is set to determine whether
    // a read is in progress. Moving it into a local variable makes sure that
    // the ReadStart() call below doesn't think we're still actively reading.
    BaseObjectPtr<FileHandleReadWrap> read_wrap =
        std::move(handle->current_read_);

    ssize_t result = req->result;
    uv_buf_t buffer = read_wrap->buffer_;

    uv_fs_req_cleanup(req);

    // Push the read wrap back to the freelist, or let it be destroyed
    // once were exiting the current scope.
    constexpr size_t kWantedFreelistFill = 100;
    auto& freelist = handle->binding_data_->file_handle_read_wrap_freelist;
  ...",44,6,node_file.cc,node.fs.FileHandle.ReadStart.<lambda>3,,false,608,663,<lambda>3,,,1,ANY node.fs.FileHandle.ReadStart.<lambda>3 (uv_fs_t*)
163575,METHOD,node_file.cc:<global>,TYPE_DECL,"[](uv_fs_t* req) {
    FileHandleCloseWrap* wrap = static_cast<FileHandleCloseWrap*>(
        FileHandleCloseWrap::from_req(req));
    FS_ASYNC_TRACE_END1(
        req->fs_type, wrap, ""result"", static_cast<int>(req->result))
    FileHandle* handle = static_cast<FileHandle*>(wrap->stream());
    handle->AfterClose();

    int result = static_cast<int>(req->result);
    uv_fs_req_cleanup(req);
    wrap->Done(result);
  }",53,4,node_file.cc,node.fs.FileHandle.DoShutdown.<lambda>4,,false,688,699,<lambda>4,,,1,ANY node.fs.FileHandle.DoShutdown.<lambda>4 (uv_fs_t*)
163733,METHOD,node_file.cc:<global>,TYPE_DECL,"[fd, loop]() {
    uv_fs_t close_req;
    CHECK_EQ(0, uv_fs_close(loop, &close_req, fd, nullptr));
    uv_fs_req_cleanup(&close_req);
  }",35,3,node_file.cc,node.fs.InternalModuleReadJSON.<lambda>5,,false,1050,1054,<lambda>5,,,1,ANY node.fs.InternalModuleReadJSON.<lambda>5 ()
163752,METHOD,node_file.cc:<global>,TYPE_DECL,"[](uv_fs_t* req) {
            FSReqBase* req_wrap = FSReqBase::from_req(req);
            int err = static_cast<int>(req->result);
            if (reinterpret_cast<intptr_t>(req->data) == UV_EEXIST &&
                  req_wrap->continuation_data()->paths().size() > 0) {
              if (err == 0 && S_ISDIR(req->statbuf.st_mode)) {
                Environment* env = req_wrap->env();
                uv_loop_t* loop = env->event_loop();
                std::string path = req->path;
                uv_fs_req_cleanup(req);
                MKDirpAsync(loop, req, path.c_str(),
                            req_wrap->continuation_data()->mode(), nullptr);
                return;
              }
              err = UV_ENOTDIR;
            }
            // verify that the path pointed to is actually a directory.
            if (err == 0 && !S_ISDIR(req->statbuf.st_mode)) err = UV_EEXIST;
            req_wrap->continuation_data()->Done(err);
          }",49,30,node_file.cc,node.fs.MKDirpAsync..<lambda>7,,false,1724,1743,<lambda>7,,,1,ANY node.fs.MKDirpAsync..<lambda>7 (uv_fs_t*)
163894,METHOD,node_file.cc:<global>,TYPE_DECL,"[](uv_fs_t* req) {
    FSReqBase* req_wrap = FSReqBase::from_req(req);
    Environment* env = req_wrap->env();
    uv_loop_t* loop = env->event_loop();
    std::string path = req->path;
    int err = static_cast<int>(req->result);

    while (true) {
      switch (err) {
        // Note: uv_fs_req_cleanup in terminal paths will be called by
        // FSReqAfterScope::~FSReqAfterScope()
        case 0: {
          if (req_wrap->continuation_data()->paths().size() == 0) {
            req_wrap->continuation_data()->MaybeSetFirstPath(path);
            req_wrap->continuation_data()->Done(0);
          } else {
            req_wrap->continuation_data()->MaybeSetFirstPath(path);
            uv_fs_req_cleanup(req);
            MKDirpAsync(loop, req, path.c_str(),
                        req_wrap->continuation_data()->mode(), nullptr);
          }
          break;
        }
        case UV_EACCES:
        case UV_ENOTDIR:
        case UV_EPERM: {
          req_wrap->continuation_data()->Do...",42,30,node_file.cc,node.fs.MKDirpAsync.<lambda>6,,false,1675,1749,<lambda>6,,,1,ANY node.fs.MKDirpAsync.<lambda>6 (uv_fs_t*)
164139,METHOD,node_file.cc:<global>,TYPE_DECL,[&req]() { uv_fs_req_cleanup(&req); },41,77,node_file.cc,node.fs.ReadFileSync.<lambda>8,,false,2012,2012,<lambda>8,,,1,ANY node.fs.ReadFileSync.<lambda>8 ()
164148,METHOD,node_file.cc:<global>,TYPE_DECL,"[file]() {
    uv_fs_t close_req;
    CHECK_EQ(0, uv_fs_close(nullptr, &close_req, file, nullptr));
    uv_fs_req_cleanup(&close_req);
  }",35,3,node_file.cc,node.fs.ReadFileSync.<lambda>9,,false,2027,2031,<lambda>9,,,1,ANY node.fs.ReadFileSync.<lambda>9 ()
164217,METHOD,node_file.cc:<global>,TYPE_DECL,<global>,1,42,node_file.cc,node_file.cc:<global>,,false,1,3376,<global>,,,1,
164224,METHOD,node_file.cc:<global>,TYPE_DECL,"std::string Basename(const std::string& str, const std::string& extension) {
  // Remove everything leading up to and including the final path separator.
  std::string::size_type pos = str.find_last_of(kPathSeparator);

  // Starting index for the resulting string
  std::size_t start_pos = 0;
  // String size to return
  std::size_t str_size = str.size();
  if (pos != std::string::npos) {
    start_pos = pos + 1;
    str_size -= start_pos;
  }

  // Strip away the extension, if any.
  if (str_size >= extension.size() &&
      str.compare(str.size() - extension.size(),
        extension.size(), extension) == 0) {
    str_size -= extension.size();
  }

  return str.substr(start_pos, str_size);
}",1,1,node_file.cc,node.fs.Basename,,false,93,114,Basename,,,3,"string node.fs.Basename (ANY,ANY)"
164308,METHOD,node_file.cc:<global>,TYPE_DECL,"inline int64_t GetOffset(Local<Value> value) {
  return IsSafeJsInt(value) ? value.As<Integer>()->Value() : -1;
}",1,1,node_file.cc,node.fs.GetOffset,,false,116,118,GetOffset,,,4,int64_t node.fs.GetOffset (Local<Value>)
164326,METHOD,node_file.cc:<global>,TYPE_DECL,"static const char* get_fs_func_name_by_type(uv_fs_type req_type) {
  switch (req_type) {
#define FS_TYPE_TO_NAME(type, name)                                            \
  case UV_FS_##type:                                                           \
    return name;
    FS_TYPE_TO_NAME(OPEN, ""open"")
    FS_TYPE_TO_NAME(CLOSE, ""close"")
    FS_TYPE_TO_NAME(READ, ""read"")
    FS_TYPE_TO_NAME(WRITE, ""write"")
    FS_TYPE_TO_NAME(SENDFILE, ""sendfile"")
    FS_TYPE_TO_NAME(STAT, ""stat"")
    FS_TYPE_TO_NAME(LSTAT, ""lstat"")
    FS_TYPE_TO_NAME(FSTAT, ""fstat"")
    FS_TYPE_TO_NAME(FTRUNCATE, ""ftruncate"")
    FS_TYPE_TO_NAME(UTIME, ""utime"")
    FS_TYPE_TO_NAME(FUTIME, ""futime"")
    FS_TYPE_TO_NAME(ACCESS, ""access"")
    FS_TYPE_TO_NAME(CHMOD, ""chmod"")
    FS_TYPE_TO_NAME(FCHMOD, ""fchmod"")
    FS_TYPE_TO_NAME(FSYNC, ""fsync"")
    FS_TYPE_TO_NAME(FDATASYNC, ""fdatasync"")
    FS_TYPE_TO_NAME(UNLINK, ""unlink"")
    FS_TYPE_TO_NAME(RMDIR, ""rmdir"")
    FS_TYPE_TO_NAME(MKDIR, ""mkdir"")
    FS_TYPE_TO_NAME(M...",1,4,node_file.cc,node.fs.get_fs_func_name_by_type,,false,120,162,get_fs_func_name_by_type,,,5,const char* node.fs.get_fs_func_name_by_type (uv_fs_type)
164535,METHOD,node_file.cc:<global>,TYPE_DECL,typedef void(*uv_fs_callback_t)(uv_fs_t*);,13,41,node_file.cc,node.fs.uv_fs_callback_t,,false,222,222,uv_fs_callback_t,,,6,void node.fs.uv_fs_callback_t (uv_fs_t*)
164540,METHOD,node_file.cc:<global>,TYPE_DECL,"void FSContinuationData::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""paths"", paths_);
}",1,1,node_file.cc,node.fs.FSContinuationData.MemoryInfo,,false,225,227,MemoryInfo,,,7,void node.fs.FSContinuationData.MemoryInfo (MemoryTracker*)
164551,METHOD,node_file.cc:<global>,TYPE_DECL,FileHandleReadWrap::~FileHandleReadWrap() = default;,1,52,node_file.cc,node.fs.FileHandleReadWrap.~FileHandleReadWrap,,false,229,229,~FileHandleReadWrap,,,8,ANY node.fs.FileHandleReadWrap.~FileHandleReadWrap ()
164555,METHOD,node_file.cc:<global>,TYPE_DECL,FSReqBase::~FSReqBase() = default;,1,34,node_file.cc,node.fs.FSReqBase.~FSReqBase,,false,231,231,~FSReqBase,,,9,ANY node.fs.FSReqBase.~FSReqBase ()
164559,METHOD,node_file.cc:<global>,TYPE_DECL,"void FSReqBase::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""continuation_data"", continuation_data_);
}",1,1,node_file.cc,node.fs.FSReqBase.MemoryInfo,,false,233,235,MemoryInfo,,,10,void node.fs.FSReqBase.MemoryInfo (MemoryTracker*)
164570,METHOD,node_file.cc:<global>,TYPE_DECL,"FileHandle::FileHandle(BindingData* binding_data,
                       Local<Object> obj, int fd)
    : AsyncWrap(binding_data->env(), obj, AsyncWrap::PROVIDER_FILEHANDLE),
      StreamBase(env()),
      fd_(fd),
      binding_data_(binding_data) {
  MakeWeak();
  StreamBase::AttachToObject(GetObject());
}",1,1,node_file.cc,node.fs.FileHandle.FileHandle,,false,240,248,FileHandle,,,11,"ANY node.fs.FileHandle.FileHandle (BindingData*,Local<Object>,int)"
164579,METHOD,node_file.cc:<global>,TYPE_DECL,"FileHandle* FileHandle::New(BindingData* binding_data,
                            int fd,
                            Local<Object> obj,
                            std::optional<int64_t> maybeOffset,
                            std::optional<int64_t> maybeLength) {
  Environment* env = binding_data->env();
  if (obj.IsEmpty() && !env->fd_constructor_template()
                            ->NewInstance(env->context())
                            .ToLocal(&obj)) {
    return nullptr;
  }
  auto handle = new FileHandle(binding_data, obj, fd);
  if (maybeOffset.has_value()) handle->read_offset_ = maybeOffset.value();
  if (maybeLength.has_value()) handle->read_length_ = maybeLength.value();
  return handle;
}",1,1,node_file.cc,node.fs.FileHandle.New,,false,250,265,New,,,12,"FileHandle node.fs.FileHandle.New (BindingData*,int,Local<Object>,ANY,ANY)"
164659,METHOD,node_file.cc:<global>,TYPE_DECL,"void FileHandle::New(const FunctionCallbackInfo<Value>& args) {
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = binding_data->env();
  CHECK(args.IsConstructCall());
  CHECK(args[0]->IsInt32());

  std::optional<int64_t> maybeOffset = std::nullopt;
  std::optional<int64_t> maybeLength = std::nullopt;
  if (args[1]->IsNumber())
    maybeOffset = args[1]->IntegerValue(env->context()).FromJust();
  if (args[2]->IsNumber())
    maybeLength = args[2]->IntegerValue(env->context()).FromJust();

  FileHandle::New(binding_data,
                  args[0].As<Int32>()->Value(),
                  args.This(),
                  maybeOffset,
                  maybeLength);
}",1,1,node_file.cc,node.fs.FileHandle.New,,false,267,285,New,,,13,void node.fs.FileHandle.New (FunctionCallbackInfo<Value>)
164781,METHOD,node_file.cc:<global>,TYPE_DECL,"FileHandle::~FileHandle() {
  CHECK(!closing_);  // We should not be deleting while explicitly closing!
  Close();           // Close synchronously and emit warning
  CHECK(closed_);    // We have to be closed at the point
}",1,1,node_file.cc,node.fs.FileHandle.~FileHandle,,false,287,291,~FileHandle,,,14,ANY node.fs.FileHandle.~FileHandle ()
164790,METHOD,node_file.cc:<global>,TYPE_DECL,"int FileHandle::DoWrite(WriteWrap* w,
                        uv_buf_t* bufs,
                        size_t count,
                        uv_stream_t* send_handle) {
  return UV_ENOSYS;  // Not implemented (yet).
}",1,1,node_file.cc,node.fs.FileHandle.DoWrite,,false,293,298,DoWrite,,,15,"int node.fs.FileHandle.DoWrite (WriteWrap*,uv_buf_t*,size_t,uv_stream_t*)"
164800,METHOD,node_file.cc:<global>,TYPE_DECL,"void FileHandle::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""current_read"", current_read_);
}",1,1,node_file.cc,node.fs.FileHandle.MemoryInfo,,false,300,302,MemoryInfo,,,16,void node.fs.FileHandle.MemoryInfo (MemoryTracker*)
164811,METHOD,node_file.cc:<global>,TYPE_DECL,"FileHandle::TransferMode FileHandle::GetTransferMode() const {
  return reading_ || closing_ || closed_ ?
      TransferMode::kUntransferable : TransferMode::kTransferable;
}",1,1,node_file.cc,node.fs.FileHandle.GetTransferMode,,false,304,307,GetTransferMode,,,17,TransferMode node.fs.FileHandle.GetTransferMode ()
164828,METHOD,node_file.cc:<global>,TYPE_DECL,"std::unique_ptr<worker::TransferData> FileHandle::TransferForMessaging() {
  CHECK_NE(GetTransferMode(), TransferMode::kUntransferable);
  auto ret = std::make_unique<TransferData>(fd_);
  closed_ = true;
  return ret;
}",1,1,node_file.cc,node.fs.FileHandle.TransferForMessaging,,false,309,314,TransferForMessaging,,,18,unique_ptr<worker::TransferData> node.fs.FileHandle.TransferForMessaging ()
164852,METHOD,node_file.cc:<global>,TYPE_DECL,FileHandle::TransferData::TransferData(int fd) : fd_(fd) {},1,59,node_file.cc,node.fs.FileHandle.TransferData.TransferData,,false,316,316,TransferData,,,19,ANY node.fs.FileHandle.TransferData.TransferData (int)
164857,METHOD,node_file.cc:<global>,TYPE_DECL,"FileHandle::TransferData::~TransferData() {
  if (fd_ > 0) {
    uv_fs_t close_req;
    CHECK_NE(fd_, -1);
    FS_SYNC_TRACE_BEGIN(close);
    CHECK_EQ(0, uv_fs_close(nullptr, &close_req, fd_, nullptr));
    FS_SYNC_TRACE_END(close);
    uv_fs_req_cleanup(&close_req);
  }
}",1,4,node_file.cc,node.fs.FileHandle.TransferData.~TransferData,,false,318,327,~TransferData,,,20,ANY node.fs.FileHandle.TransferData.~TransferData ()
165074,METHOD,node_file.cc:<global>,TYPE_DECL,"BaseObjectPtr<BaseObject> FileHandle::TransferData::Deserialize(
    Environment* env,
    v8::Local<v8::Context> context,
    std::unique_ptr<worker::TransferData> self) {
  BindingData* bd = Realm::GetBindingData<BindingData>(context);
  if (bd == nullptr) return {};

  int fd = fd_;
  fd_ = -1;
  return BaseObjectPtr<BaseObject> { FileHandle::New(bd, fd) };
}",1,1,node_file.cc,node.fs.FileHandle.TransferData.Deserialize,,false,329,339,Deserialize,,,21,"BaseObjectPtr<BaseObject> node.fs.FileHandle.TransferData.Deserialize (Environment*,ANY,ANY)"
165114,METHOD,node_file.cc:<global>,TYPE_DECL,"inline void FileHandle::Close() {
  if (closed_ || closing_) return;
  uv_fs_t req;
  CHECK_NE(fd_, -1);
  FS_SYNC_TRACE_BEGIN(close);
  int ret = uv_fs_close(env()->event_loop(), &req, fd_, nullptr);
  FS_SYNC_TRACE_END(close);
  uv_fs_req_cleanup(&req);

  struct err_detail { int ret; int fd; };

  err_detail detail { ret, fd_ };

  AfterClose();

  if (ret < 0) {
    // Do not unref this
    env()->SetImmediate([detail](Environment* env) {
      char msg[70];
      snprintf(msg, arraysize(msg),
              ""Closing file descriptor %d on garbage collection failed"",
              detail.fd);
      // This exception will end up being fatal for the process because
      // it is being thrown from within the SetImmediate handler and
      // there is no JS stack to bubble it to. In other words, tearing
      // down the process is the only reasonable thing we can do here.
      HandleScope handle_scope(env->isolate());
      env->ThrowUVException(detail.ret, ""close"", msg);
    });
 ...",1,2,node_file.cc,node.fs.FileHandle.Close,,false,345,396,Close,,,22,void node.fs.FileHandle.Close ()
165361,METHOD,node_file.cc:<global>,TYPE_DECL,"void FileHandle::CloseReq::Resolve() {
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Context::Scope context_scope(env()->context());
  InternalCallbackScope callback_scope(this);
  Local<Promise> promise = promise_.Get(isolate);
  Local<Promise::Resolver> resolver = promise.As<Promise::Resolver>();
  resolver->Resolve(env()->context(), Undefined(isolate)).Check();
}",1,1,node_file.cc,node.fs.FileHandle.CloseReq.Resolve,,false,398,406,Resolve,,,23,void node.fs.FileHandle.CloseReq.Resolve ()
165420,METHOD,node_file.cc:<global>,TYPE_DECL,"void FileHandle::CloseReq::Reject(Local<Value> reason) {
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Context::Scope context_scope(env()->context());
  InternalCallbackScope callback_scope(this);
  Local<Promise> promise = promise_.Get(isolate);
  Local<Promise::Resolver> resolver = promise.As<Promise::Resolver>();
  resolver->Reject(env()->context(), reason).Check();
}",1,1,node_file.cc,node.fs.FileHandle.CloseReq.Reject,,false,408,416,Reject,,,24,void node.fs.FileHandle.CloseReq.Reject (Local<Value>)
165479,METHOD,node_file.cc:<global>,TYPE_DECL,"FileHandle* FileHandle::CloseReq::file_handle() {
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Value> val = ref_.Get(isolate);
  Local<Object> obj = val.As<Object>();
  return Unwrap<FileHandle>(obj);
}",1,1,node_file.cc,node.fs.FileHandle.CloseReq.file_handle,,false,418,424,file_handle,,,25,FileHandle node.fs.FileHandle.CloseReq.file_handle ()
165520,METHOD,node_file.cc:<global>,TYPE_DECL,"FileHandle::CloseReq::CloseReq(Environment* env,
                               Local<Object> obj,
                               Local<Promise> promise,
                               Local<Value> ref)
  : ReqWrap(env, obj, AsyncWrap::PROVIDER_FILEHANDLECLOSEREQ) {
  promise_.Reset(env->isolate(), promise);
  ref_.Reset(env->isolate(), ref);
}",1,1,node_file.cc,node.fs.FileHandle.CloseReq.CloseReq,,false,426,433,CloseReq,,,26,"ANY node.fs.FileHandle.CloseReq.CloseReq (Environment*,Local<Object>,Local<Promise>,Local<Value>)"
165546,METHOD,node_file.cc:<global>,TYPE_DECL,"FileHandle::CloseReq::~CloseReq() {
  uv_fs_req_cleanup(req());
  promise_.Reset();
  ref_.Reset();
}",1,1,node_file.cc,node.fs.FileHandle.CloseReq.~CloseReq,,false,435,439,~CloseReq,,,27,ANY node.fs.FileHandle.CloseReq.~CloseReq ()
165559,METHOD,node_file.cc:<global>,TYPE_DECL,"void FileHandle::CloseReq::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""promise"", promise_);
  tracker->TrackField(""ref"", ref_);
}",1,1,node_file.cc,node.fs.FileHandle.CloseReq.MemoryInfo,,false,441,444,MemoryInfo,,,28,void node.fs.FileHandle.CloseReq.MemoryInfo (MemoryTracker*)
165576,METHOD,node_file.cc:<global>,TYPE_DECL,"MaybeLocal<Promise> FileHandle::ClosePromise() {
  Isolate* isolate = env()->isolate();
  EscapableHandleScope scope(isolate);
  Local<Context> context = env()->context();

  Local<Value> close_resolver =
      object()->GetInternalField(FileHandle::kClosingPromiseSlot);
  if (!close_resolver.IsEmpty() && !close_resolver->IsUndefined()) {
    CHECK(close_resolver->IsPromise());
    return close_resolver.As<Promise>();
  }

  CHECK(!closed_);
  CHECK(!closing_);
  CHECK(!reading_);

  auto maybe_resolver = Promise::Resolver::New(context);
  CHECK(!maybe_resolver.IsEmpty());
  Local<Promise::Resolver> resolver = maybe_resolver.ToLocalChecked();
  Local<Promise> promise = resolver.As<Promise>();

  Local<Object> close_req_obj;
  if (!env()->fdclose_constructor_template()
          ->NewInstance(env()->context()).ToLocal(&close_req_obj)) {
    return MaybeLocal<Promise>();
  }
  closing_ = true;
  object()->SetInternalField(FileHandle::kClosingPromiseSlot, promise);

  CloseReq* req = n...",1,4,node_file.cc,node.fs.FileHandle.ClosePromise,,false,453,509,ClosePromise,,,29,MaybeLocal<Promise> node.fs.FileHandle.ClosePromise ()
165867,METHOD,node_file.cc:<global>,TYPE_DECL,"void FileHandle::Close(const FunctionCallbackInfo<Value>& args) {
  FileHandle* fd;
  ASSIGN_OR_RETURN_UNWRAP(&fd, args.Holder());
  Local<Promise> ret;
  if (!fd->ClosePromise().ToLocal(&ret)) return;
  args.GetReturnValue().Set(ret);
}",1,1,node_file.cc,node.fs.FileHandle.Close,,false,511,517,Close,,,30,void node.fs.FileHandle.Close (FunctionCallbackInfo<Value>)
165906,METHOD,node_file.cc:<global>,TYPE_DECL,"void FileHandle::ReleaseFD(const FunctionCallbackInfo<Value>& args) {
  FileHandle* fd;
  ASSIGN_OR_RETURN_UNWRAP(&fd, args.Holder());
  fd->Release();
}",1,1,node_file.cc,node.fs.FileHandle.ReleaseFD,,false,520,524,ReleaseFD,,,31,void node.fs.FileHandle.ReleaseFD (FunctionCallbackInfo<Value>)
165923,METHOD,node_file.cc:<global>,TYPE_DECL,"int FileHandle::Release() {
  int fd = GetFD();
  // Just pretend that Close was called and we're all done.
  AfterClose();
  return fd;
}",1,1,node_file.cc,node.fs.FileHandle.Release,,false,526,531,Release,,,32,int node.fs.FileHandle.Release ()
165934,METHOD,node_file.cc:<global>,TYPE_DECL,"void FileHandle::AfterClose() {
  closing_ = false;
  closed_ = true;
  fd_ = -1;
  if (reading_ && !persistent().IsEmpty())
    EmitRead(UV_EOF);
}",1,1,node_file.cc,node.fs.FileHandle.AfterClose,,false,533,539,AfterClose,,,33,void node.fs.FileHandle.AfterClose ()
165958,METHOD,node_file.cc:<global>,TYPE_DECL,"void FileHandleReadWrap::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""buffer"", buffer_);
  tracker->TrackField(""file_handle"", this->file_handle_);
}",1,1,node_file.cc,node.fs.FileHandleReadWrap.MemoryInfo,,false,541,544,MemoryInfo,,,34,void node.fs.FileHandleReadWrap.MemoryInfo (MemoryTracker*)
165977,METHOD,node_file.cc:<global>,TYPE_DECL,"FileHandleReadWrap::FileHandleReadWrap(FileHandle* handle, Local<Object> obj)
  : ReqWrap(handle->env(), obj, AsyncWrap::PROVIDER_FSREQCALLBACK),
    file_handle_(handle) {}",1,27,node_file.cc,node.fs.FileHandleReadWrap.FileHandleReadWrap,,false,546,548,FileHandleReadWrap,,,35,"ANY node.fs.FileHandleReadWrap.FileHandleReadWrap (FileHandle*,Local<Object>)"
165983,METHOD,node_file.cc:<global>,TYPE_DECL,"int FileHandle::ReadStart() {
  if (!IsAlive() || IsClosing())
    return UV_EOF;

  reading_ = true;

  if (current_read_)
    return 0;

  BaseObjectPtr<FileHandleReadWrap> read_wrap;

  if (read_length_ == 0) {
    EmitRead(UV_EOF);
    return 0;
  }

  {
    // Create a new FileHandleReadWrap or re-use one.
    // Either way, we need these two scopes for AsyncReset() or otherwise
    // for creating the new instance.
    HandleScope handle_scope(env()->isolate());
    AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(this);

    auto& freelist = binding_data_->file_handle_read_wrap_freelist;
    if (freelist.size() > 0) {
      read_wrap = std::move(freelist.back());
      freelist.pop_back();
      // Use a fresh async resource.
      // Lifetime is ensured via AsyncWrap::resource_.
      Local<Object> resource = Object::New(env()->isolate());
      USE(resource->Set(
          env()->context(), env()->handle_string(), read_wrap->object()));
      read_wrap->AsyncReset(resou...",1,2,node_file.cc,node.fs.FileHandle.ReadStart,,false,550,666,ReadStart,,,36,int node.fs.FileHandle.ReadStart ()
166283,METHOD,node_file.cc:<global>,TYPE_DECL,"int FileHandle::ReadStop() {
  reading_ = false;
  return 0;
}",1,1,node_file.cc,node.fs.FileHandle.ReadStop,,false,668,671,ReadStop,,,37,int node.fs.FileHandle.ReadStop ()
166293,METHOD,node_file.cc:<global>,TYPE_DECL,"ShutdownWrap* FileHandle::CreateShutdownWrap(Local<Object> object) {
  return new FileHandleCloseWrap(this, object);
}",1,1,node_file.cc,node.fs.FileHandle.CreateShutdownWrap,,false,675,677,CreateShutdownWrap,,,39,ShutdownWrap node.fs.FileHandle.CreateShutdownWrap (Local<Object>)
166303,METHOD,node_file.cc:<global>,TYPE_DECL,"int FileHandle::DoShutdown(ShutdownWrap* req_wrap) {
  if (closing_ || closed_) {
    req_wrap->Done(0);
    return 1;
  }
  FileHandleCloseWrap* wrap = static_cast<FileHandleCloseWrap*>(req_wrap);
  closing_ = true;
  CHECK_NE(fd_, -1);
  FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, wrap)
  wrap->Dispatch(uv_fs_close, fd_, uv_fs_callback_t{[](uv_fs_t* req) {
    FileHandleCloseWrap* wrap = static_cast<FileHandleCloseWrap*>(
        FileHandleCloseWrap::from_req(req));
    FS_ASYNC_TRACE_END1(
        req->fs_type, wrap, ""result"", static_cast<int>(req->result))
    FileHandle* handle = static_cast<FileHandle*>(wrap->stream());
    handle->AfterClose();

    int result = static_cast<int>(req->result);
    uv_fs_req_cleanup(req);
    wrap->Done(result);
  }});

  return 0;
}",1,2,node_file.cc,node.fs.FileHandle.DoShutdown,,false,679,702,DoShutdown,,,40,int node.fs.FileHandle.DoShutdown (ShutdownWrap*)
166442,METHOD,node_file.cc:<global>,TYPE_DECL,"void FSReqCallback::Reject(Local<Value> reject) {
  MakeCallback(env()->oncomplete_string(), 1, &reject);
}",1,1,node_file.cc,node.fs.FSReqCallback.Reject,,false,705,707,Reject,,,41,void node.fs.FSReqCallback.Reject (Local<Value>)
166455,METHOD,node_file.cc:<global>,TYPE_DECL,"void FSReqCallback::ResolveStat(const uv_stat_t* stat) {
  Resolve(FillGlobalStatsArray(binding_data(), use_bigint(), stat));
}",1,1,node_file.cc,node.fs.FSReqCallback.ResolveStat,,false,709,711,ResolveStat,,,42,void node.fs.FSReqCallback.ResolveStat (uv_stat_t*)
166465,METHOD,node_file.cc:<global>,TYPE_DECL,"void FSReqCallback::ResolveStatFs(const uv_statfs_t* stat) {
  Resolve(FillGlobalStatFsArray(binding_data(), use_bigint(), stat));
}",1,1,node_file.cc,node.fs.FSReqCallback.ResolveStatFs,,false,713,715,ResolveStatFs,,,43,void node.fs.FSReqCallback.ResolveStatFs (uv_statfs_t*)
166475,METHOD,node_file.cc:<global>,TYPE_DECL,"void FSReqCallback::Resolve(Local<Value> value) {
  Local<Value> argv[2] {
    Null(env()->isolate()),
    value
  };
  MakeCallback(env()->oncomplete_string(),
               value->IsUndefined() ? 1 : arraysize(argv),
               argv);
}",1,1,node_file.cc,node.fs.FSReqCallback.Resolve,,false,717,725,Resolve,,,44,void node.fs.FSReqCallback.Resolve (Local<Value>)
166504,METHOD,node_file.cc:<global>,TYPE_DECL,"void FSReqCallback::SetReturnValue(const FunctionCallbackInfo<Value>& args) {
  args.GetReturnValue().SetUndefined();
}",1,1,node_file.cc,node.fs.FSReqCallback.SetReturnValue,,false,727,729,SetReturnValue,,,45,void node.fs.FSReqCallback.SetReturnValue (FunctionCallbackInfo<Value>)
166516,METHOD,node_file.cc:<global>,TYPE_DECL,"void NewFSReqCallback(const FunctionCallbackInfo<Value>& args) {
  CHECK(args.IsConstructCall());
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  new FSReqCallback(binding_data, args.This(), args[0]->IsTrue());
}",1,1,node_file.cc,node.fs.NewFSReqCallback,,false,731,735,NewFSReqCallback,,,46,void node.fs.NewFSReqCallback (FunctionCallbackInfo<Value>)
166549,METHOD,node_file.cc:<global>,TYPE_DECL,"FSReqAfterScope::FSReqAfterScope(FSReqBase* wrap, uv_fs_t* req)
    : wrap_(wrap),
      req_(req),
      handle_scope_(wrap->env()->isolate()),
      context_scope_(wrap->env()->context()) {
  CHECK_EQ(wrap_->req(), req);
}",1,1,node_file.cc,node.fs.FSReqAfterScope.FSReqAfterScope,,false,737,743,FSReqAfterScope,,,47,"ANY node.fs.FSReqAfterScope.FSReqAfterScope (FSReqBase*,uv_fs_t*)"
166561,METHOD,node_file.cc:<global>,TYPE_DECL,"FSReqAfterScope::~FSReqAfterScope() {
  Clear();
}",1,1,node_file.cc,node.fs.FSReqAfterScope.~FSReqAfterScope,,false,745,747,~FSReqAfterScope,,,48,ANY node.fs.FSReqAfterScope.~FSReqAfterScope ()
166566,METHOD,node_file.cc:<global>,TYPE_DECL,"void FSReqAfterScope::Clear() {
  if (!wrap_) return;

  uv_fs_req_cleanup(wrap_->req());
  wrap_->Detach();
  wrap_.reset();
}",1,1,node_file.cc,node.fs.FSReqAfterScope.Clear,,false,749,755,Clear,,,49,void node.fs.FSReqAfterScope.Clear ()
166588,METHOD,node_file.cc:<global>,TYPE_DECL,"void FSReqAfterScope::Reject(uv_fs_t* req) {
  BaseObjectPtr<FSReqBase> wrap { wrap_ };
  Local<Value> exception = UVException(wrap_->env()->isolate(),
                                       static_cast<int>(req->result),
                                       wrap_->syscall(),
                                       nullptr,
                                       req->path,
                                       wrap_->data());
  Clear();
  wrap->Reject(exception);
}",1,1,node_file.cc,node.fs.FSReqAfterScope.Reject,,false,766,776,Reject,,,50,void node.fs.FSReqAfterScope.Reject (uv_fs_t*)
166637,METHOD,node_file.cc:<global>,TYPE_DECL,"bool FSReqAfterScope::Proceed() {
  if (!wrap_->env()->can_call_into_js()) {
    return false;
  }

  if (req_->result < 0) {
    Reject(req_);
    return false;
  }
  return true;
}",1,1,node_file.cc,node.fs.FSReqAfterScope.Proceed,,false,778,788,Proceed,,,51,bool node.fs.FSReqAfterScope.Proceed ()
166665,METHOD,node_file.cc:<global>,TYPE_DECL,"void AfterNoArgs(uv_fs_t* req) {
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (after.Proceed())
    req_wrap->Resolve(Undefined(req_wrap->env()->isolate()));
}",1,2,node_file.cc,node.fs.AfterNoArgs,,false,790,797,AfterNoArgs,,,52,void node.fs.AfterNoArgs (uv_fs_t*)
166814,METHOD,node_file.cc:<global>,TYPE_DECL,"void AfterStat(uv_fs_t* req) {
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (after.Proceed()) {
    req_wrap->ResolveStat(&req->statbuf);
  }
}",1,2,node_file.cc,node.fs.AfterStat,,false,799,807,AfterStat,,,53,void node.fs.AfterStat (uv_fs_t*)
166959,METHOD,node_file.cc:<global>,TYPE_DECL,"void AfterStatFs(uv_fs_t* req) {
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (after.Proceed()) {
    req_wrap->ResolveStatFs(static_cast<uv_statfs_t*>(req->ptr));
  }
}",1,2,node_file.cc,node.fs.AfterStatFs,,false,809,817,AfterStatFs,,,54,void node.fs.AfterStatFs (uv_fs_t*)
167105,METHOD,node_file.cc:<global>,TYPE_DECL,"void AfterInteger(uv_fs_t* req) {
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  int result = static_cast<int>(req->result);
  if (result >= 0 && req_wrap->is_plain_open())
    req_wrap->env()->AddUnmanagedFd(result);

  if (after.Proceed())
    req_wrap->Resolve(Integer::New(req_wrap->env()->isolate(), result));
}",1,2,node_file.cc,node.fs.AfterInteger,,false,819,830,AfterInteger,,,55,void node.fs.AfterInteger (uv_fs_t*)
167284,METHOD,node_file.cc:<global>,TYPE_DECL,"void AfterOpenFileHandle(uv_fs_t* req) {
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (after.Proceed()) {
    FileHandle* fd = FileHandle::New(req_wrap->binding_data(),
                                     static_cast<int>(req->result));
    if (fd == nullptr) return;
    req_wrap->Resolve(fd->object());
  }
}",1,2,node_file.cc,node.fs.AfterOpenFileHandle,,false,832,843,AfterOpenFileHandle,,,56,void node.fs.AfterOpenFileHandle (uv_fs_t*)
167451,METHOD,node_file.cc:<global>,TYPE_DECL,"void FromNamespacedPath(std::string* path) {
#ifdef _WIN32
  if (path->compare(0, 8, ""\\\\?\\UNC\\"", 8) == 0) {
    *path = path->substr(8);
    path->insert(0, ""\\\\"");
  } else if (path->compare(0, 4, ""\\\\?\\"", 4) == 0) {
    *path = path->substr(4);
  }
#endif
}",1,1,node_file.cc,node.fs.FromNamespacedPath,,false,847,856,FromNamespacedPath,,,57,void node.fs.FromNamespacedPath (ANY*)
167456,METHOD,node_file.cc:<global>,TYPE_DECL,"void AfterMkdirp(uv_fs_t* req) {
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (after.Proceed()) {
    std::string first_path(req_wrap->continuation_data()->first_path());
    if (first_path.empty())
      return req_wrap->Resolve(Undefined(req_wrap->env()->isolate()));
    FromNamespacedPath(&first_path);
    Local<Value> path;
    Local<Value> error;
    if (!StringBytes::Encode(req_wrap->env()->isolate(), first_path.c_str(),
                             req_wrap->encoding(),
                             &error).ToLocal(&path)) {
      return req_wrap->Reject(error);
    }
    return req_wrap->Resolve(path);
  }
}",1,2,node_file.cc,node.fs.AfterMkdirp,,false,858,877,AfterMkdirp,,,58,void node.fs.AfterMkdirp (uv_fs_t*)
167675,METHOD,node_file.cc:<global>,TYPE_DECL,"void AfterStringPath(uv_fs_t* req) {
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  MaybeLocal<Value> link;
  Local<Value> error;

  if (after.Proceed()) {
    link = StringBytes::Encode(req_wrap->env()->isolate(),
                               req->path,
                               req_wrap->encoding(),
                               &error);
    if (link.IsEmpty())
      req_wrap->Reject(error);
    else
      req_wrap->Resolve(link.ToLocalChecked());
  }
}",1,2,node_file.cc,node.fs.AfterStringPath,,false,879,897,AfterStringPath,,,59,void node.fs.AfterStringPath (uv_fs_t*)
167865,METHOD,node_file.cc:<global>,TYPE_DECL,"void AfterStringPtr(uv_fs_t* req) {
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  MaybeLocal<Value> link;
  Local<Value> error;

  if (after.Proceed()) {
    link = StringBytes::Encode(req_wrap->env()->isolate(),
                               static_cast<const char*>(req->ptr),
                               req_wrap->encoding(),
                               &error);
    if (link.IsEmpty())
      req_wrap->Reject(error);
    else
      req_wrap->Resolve(link.ToLocalChecked());
  }
}",1,2,node_file.cc,node.fs.AfterStringPtr,,false,899,917,AfterStringPtr,,,60,void node.fs.AfterStringPtr (uv_fs_t*)
168057,METHOD,node_file.cc:<global>,TYPE_DECL,"void AfterScanDir(uv_fs_t* req) {
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (!after.Proceed()) {
    return;
  }

  Environment* env = req_wrap->env();
  Isolate* isolate = env->isolate();
  Local<Value> error;
  int r;

  std::vector<Local<Value>> name_v;
  std::vector<Local<Value>> type_v;

  const bool with_file_types = req_wrap->with_file_types();

  for (;;) {
    uv_dirent_t ent;

    r = uv_fs_scandir_next(req, &ent);
    if (r == UV_EOF)
      break;
    if (r != 0) {
      return req_wrap->Reject(
          UVException(isolate, r, nullptr, req_wrap->syscall(), req->path));
    }

    Local<Value> filename;
    if (!StringBytes::Encode(isolate, ent.name, req_wrap->encoding(), &error)
             .ToLocal(&filename)) {
      return req_wrap->Reject(error);
    }
    name_v.push_back(filename);

    if (with_file_types) type_v.empl...",1,2,node_file.cc,node.fs.AfterScanDir,,false,919,966,AfterScanDir,,,61,void node.fs.AfterScanDir (uv_fs_t*)
168395,METHOD,node_file.cc:<global>,TYPE_DECL,"void Access(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  Isolate* isolate = env->isolate();
  HandleScope scope(isolate);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  CHECK(args[1]->IsInt32());
  int mode = args[1].As<Int32>()->Value();

  BufferValue path(isolate, args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, path.ToStringView());

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // access(path, mode, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_ACCESS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""access"", UTF8, AfterNoArgs,
              uv_fs_access, *path, mode);
  } else {  // access(path, mode, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(access);
    SyncCall(env, args[3], &req_wrap_sync, ""access""...",1,4,node_file.cc,node.fs.Access,,false,968,998,Access,,,62,void node.fs.Access (FunctionCallbackInfo<Value>)
168807,METHOD,node_file.cc:<global>,TYPE_DECL,"void Close(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  CHECK(args[0]->IsInt32());
  int fd = args[0].As<Int32>()->Value();
  env->RemoveUnmanagedFd(fd);

  FSReqBase* req_wrap_async = GetReqWrap(args, 1);
  if (req_wrap_async != nullptr) {  // close(fd, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""close"", UTF8, AfterNoArgs,
              uv_fs_close, fd);
  } else {  // close(fd, undefined, ctx)
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(close);
    SyncCall(env, args[2], &req_wrap_sync, ""close"", uv_fs_close, fd);
    FS_SYNC_TRACE_END(close);
  }
}",1,4,node_file.cc,node.fs.Close,,false,1001,1023,Close,,,63,void node.fs.Close (FunctionCallbackInfo<Value>)
169180,METHOD,node_file.cc:<global>,TYPE_DECL,"static void InternalModuleReadJSON(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  uv_loop_t* loop = env->event_loop();

  CHECK(args[0]->IsString());
  node::Utf8Value path(isolate, args[0]);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, path.ToStringView());

  if (strlen(*path) != path.length()) {
    args.GetReturnValue().Set(Array::New(isolate));
    return;  // Contains a nul byte.
  }
  uv_fs_t open_req;
  const int fd = uv_fs_open(loop, &open_req, *path, O_RDONLY, 0, nullptr);
  uv_fs_req_cleanup(&open_req);

  if (fd < 0) {
    args.GetReturnValue().Set(Array::New(isolate));
    return;
  }

  auto defer_close = OnScopeLeave([fd, loop]() {
    uv_fs_t close_req;
    CHECK_EQ(0, uv_fs_close(loop, &close_req, fd, nullptr));
    uv_fs_req_cleanup(&close_req);
  });

  const size_t kBlockSize = 32 << 10;
  std::vector<char> chars;
  int64_t offse...",1,1,node_file.cc,node.fs.InternalModuleReadJSON,,false,1027,1121,InternalModuleReadJSON,,,64,void node.fs.InternalModuleReadJSON (FunctionCallbackInfo<Value>)
169608,METHOD,node_file.cc:<global>,TYPE_DECL,"static void InternalModuleStat(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsString());
  node::Utf8Value path(env->isolate(), args[0]);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, path.ToStringView());

  uv_fs_t req;
  int rc = uv_fs_stat(env->event_loop(), &req, *path, nullptr);
  if (rc == 0) {
    const uv_stat_t* const s = static_cast<const uv_stat_t*>(req.ptr);
    rc = !!(s->st_mode & S_IFDIR);
  }
  uv_fs_req_cleanup(&req);

  args.GetReturnValue().Set(rc);
}",1,1,node_file.cc,node.fs.InternalModuleStat,,false,1126,1143,InternalModuleStat,,,65,void node.fs.InternalModuleStat (FunctionCallbackInfo<Value>)
169695,METHOD,node_file.cc:<global>,TYPE_DECL,"static void Stat(const FunctionCallbackInfo<Value>& args) {
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = binding_data->env();

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, path.ToStringView());

  bool use_bigint = args[1]->IsTrue();
  FSReqBase* req_wrap_async = GetReqWrap(args, 2, use_bigint);
  if (req_wrap_async != nullptr) {  // stat(path, use_bigint, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""stat"", UTF8, AfterStat,
              uv_fs_stat, *path);
  } else {  // stat(path, use_bigint, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(stat);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""stat"", uv_fs_stat, *p...",1,4,node_file.cc,node.fs.Stat,,false,1145,1178,Stat,,,66,void node.fs.Stat (FunctionCallbackInfo<Value>)
170131,METHOD,node_file.cc:<global>,TYPE_DECL,"static void LStat(const FunctionCallbackInfo<Value>& args) {
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = binding_data->env();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);

  bool use_bigint = args[1]->IsTrue();
  FSReqBase* req_wrap_async = GetReqWrap(args, 2, use_bigint);
  if (req_wrap_async != nullptr) {  // lstat(path, use_bigint, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LSTAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""lstat"", UTF8, AfterStat,
              uv_fs_lstat, *path);
  } else {  // lstat(path, use_bigint, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(lstat);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""lstat"", uv_fs_lstat,
                       *path);
    FS_SYNC_TRACE_END(lstat);
    if (err != 0) {
      return;  // error info...",1,4,node_file.cc,node.fs.LStat,,false,1180,1212,LStat,,,67,void node.fs.LStat (FunctionCallbackInfo<Value>)
170556,METHOD,node_file.cc:<global>,TYPE_DECL,"static void FStat(const FunctionCallbackInfo<Value>& args) {
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = binding_data->env();

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  CHECK(args[0]->IsInt32());
  int fd = args[0].As<Int32>()->Value();

  bool use_bigint = args[1]->IsTrue();
  FSReqBase* req_wrap_async = GetReqWrap(args, 2, use_bigint);
  if (req_wrap_async != nullptr) {  // fstat(fd, use_bigint, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FSTAT, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fstat"", UTF8, AfterStat,
              uv_fs_fstat, fd);
  } else {  // fstat(fd, use_bigint, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fstat);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""fstat"", uv_fs_fstat, fd);
    FS_SYNC_TRACE_END(fstat);
    if (err != 0) {
      return;  // error info is in ctx
    }

    Local<Value> arr = FillGlobalStatsArray(binding_dat...",1,4,node_file.cc,node.fs.FStat,,false,1214,1244,FStat,,,68,void node.fs.FStat (FunctionCallbackInfo<Value>)
170976,METHOD,node_file.cc:<global>,TYPE_DECL,"static void StatFs(const FunctionCallbackInfo<Value>& args) {
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = binding_data->env();

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);

  bool use_bigint = args[1]->IsTrue();
  FSReqBase* req_wrap_async = GetReqWrap(args, 2, use_bigint);
  if (req_wrap_async != nullptr) {  // statfs(path, use_bigint, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STATFS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env,
              req_wrap_async,
              args,
              ""statfs"",
              UTF8,
              AfterStatFs,
              uv_fs_statfs,
              *path);
  } else {  // statfs(path, use_bigint, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(statfs);
    int err =
        SyncCall(env, args[3], &req_wrap_sync, ""statfs"", uv_fs_statfs, *path)...",1,4,node_file.cc,node.fs.StatFs,,false,1246,1286,StatFs,,,69,void node.fs.StatFs (FunctionCallbackInfo<Value>)
171401,METHOD,node_file.cc:<global>,TYPE_DECL,"static void Symlink(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 4);

  BufferValue target(isolate, args[0]);
  CHECK_NOT_NULL(*target);
  auto target_view = target.ToStringView();
  // To avoid bypass the symlink target should be allowed to read and write
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, target_view);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, target_view);

  BufferValue path(isolate, args[1]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  CHECK(args[2]->IsInt32());
  int flags = args[2].As<Int32>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // symlink(target, path, flags, req)
    ...",1,4,node_file.cc,node.fs.Symlink,,false,1288,1330,Symlink,,,70,void node.fs.Symlink (FunctionCallbackInfo<Value>)
171862,METHOD,node_file.cc:<global>,TYPE_DECL,"static void Link(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue src(isolate, args[0]);
  CHECK_NOT_NULL(*src);

  const auto src_view = src.ToStringView();
  // To avoid bypass the link target should be allowed to read and write
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, src_view);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, src_view);

  BufferValue dest(isolate, args[1]);
  CHECK_NOT_NULL(*dest);
  const auto dest_view = dest.ToStringView();
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, dest_view);

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // link(src, dest, req)
    FS_ASYNC_TRACE_BEGIN2(UV_FS_LINK,
                          req_wrap...",1,4,node_file.cc,node.fs.Link,,false,1332,1373,Link,,,71,void node.fs.Link (FunctionCallbackInfo<Value>)
172306,METHOD,node_file.cc:<global>,TYPE_DECL,"static void ReadLink(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(isolate, args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, path.ToStringView());

  const enum encoding encoding = ParseEncoding(isolate, args[1], UTF8);

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // readlink(path, encoding, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_READLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""readlink"", encoding, AfterStringPtr,
              uv_fs_readlink, *path);
  } else {
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(readlink);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""readlink"",
                       uv_fs_rea...",1,4,node_file.cc,node.fs.ReadLink,,false,1375,1420,ReadLink,,,72,void node.fs.ReadLink (FunctionCallbackInfo<Value>)
172788,METHOD,node_file.cc:<global>,TYPE_DECL,"static void Rename(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue old_path(isolate, args[0]);
  CHECK_NOT_NULL(*old_path);
  auto view_old_path = old_path.ToStringView();
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, view_old_path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, view_old_path);

  BufferValue new_path(isolate, args[1]);
  CHECK_NOT_NULL(*new_path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env,
      permission::PermissionScope::kFileSystemWrite,
      new_path.ToStringView());

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {
    FS_ASYNC_TRACE_BEGIN2(UV_FS_RENAME,
                          req_wrap_async,
                          ""old_path"",
                          TRACE_STR_C...",1,4,node_file.cc,node.fs.Rename,,false,1422,1463,Rename,,,73,void node.fs.Rename (FunctionCallbackInfo<Value>)
173228,METHOD,node_file.cc:<global>,TYPE_DECL,"static void FTruncate(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(IsSafeJsInt(args[1]));
  const int64_t len = args[1].As<Integer>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FTRUNCATE, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""ftruncate"", UTF8, AfterNoArgs,
              uv_fs_ftruncate, fd, len);
  } else {
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(ftruncate);
    SyncCall(env, args[3], &req_wrap_sync, ""ftruncate"", uv_fs_ftruncate, fd,
             len);
    FS_SYNC_TRACE_END(ftruncate);
  }
}",1,4,node_file.cc,node.fs.FTruncate,,false,1465,1490,FTruncate,,,74,void node.fs.FTruncate (FunctionCallbackInfo<Value>)
173615,METHOD,node_file.cc:<global>,TYPE_DECL,"static void Fdatasync(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 1);
  if (req_wrap_async != nullptr) {
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FDATASYNC, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fdatasync"", UTF8, AfterNoArgs,
              uv_fs_fdatasync, fd);
  } else {
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fdatasync);
    SyncCall(env, args[2], &req_wrap_sync, ""fdatasync"", uv_fs_fdatasync, fd);
    FS_SYNC_TRACE_END(fdatasync);
  }
}",1,4,node_file.cc,node.fs.Fdatasync,,false,1492,1513,Fdatasync,,,75,void node.fs.Fdatasync (FunctionCallbackInfo<Value>)
173983,METHOD,node_file.cc:<global>,TYPE_DECL,"static void Fsync(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 1);
  if (req_wrap_async != nullptr) {
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FSYNC, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fsync"", UTF8, AfterNoArgs,
              uv_fs_fsync, fd);
  } else {
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fsync);
    SyncCall(env, args[2], &req_wrap_sync, ""fsync"", uv_fs_fsync, fd);
    FS_SYNC_TRACE_END(fsync);
  }
}",1,4,node_file.cc,node.fs.Fsync,,false,1515,1536,Fsync,,,76,void node.fs.Fsync (FunctionCallbackInfo<Value>)
174351,METHOD,node_file.cc:<global>,TYPE_DECL,"static void Unlink(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  FSReqBase* req_wrap_async = GetReqWrap(args, 1);
  if (req_wrap_async != nullptr) {
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UNLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""unlink"", UTF8, AfterNoArgs,
              uv_fs_unlink, *path);
  } else {
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(unlink);
    SyncCall(env, args[2], &req_wrap_sync, ""unlink"", uv_fs_unlink, *path);
    FS_SYNC_TRACE_END(unlink);
  }
}",1,4,node_file.cc,node.fs.Unlink,,false,1538,1562,Unlink,,,77,void node.fs.Unlink (FunctionCallbackInfo<Value>)
174735,METHOD,node_file.cc:<global>,TYPE_DECL,"static void RMDir(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  FSReqBase* req_wrap_async = GetReqWrap(args, 1);  // rmdir(path, req)
  if (req_wrap_async != nullptr) {
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_RMDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""rmdir"", UTF8, AfterNoArgs,
              uv_fs_rmdir, *path);
  } else {  // rmdir(path, undefined, ctx)
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(rmdir);
    SyncCall(env, args[2], &req_wrap_sync, ""rmdir"",
             uv_fs_rmdir, *path);
    FS_SYNC_TRACE_END(rmdir);
  }
}",1,4,node_file.cc,node.fs.RMDir,,false,1564,1589,RMDir,,,78,void node.fs.RMDir (FunctionCallbackInfo<Value>)
175119,METHOD,node_file.cc:<global>,TYPE_DECL,"int MKDirpSync(uv_loop_t* loop,
               uv_fs_t* req,
               const std::string& path,
               int mode,
               uv_fs_cb cb) {
  FSReqWrapSync* req_wrap = ContainerOf(&FSReqWrapSync::req, req);

  // on the first iteration of algorithm, stash state information.
  if (req_wrap->continuation_data() == nullptr) {
    req_wrap->set_continuation_data(
        std::make_unique<FSContinuationData>(req, mode, cb));
    req_wrap->continuation_data()->PushPath(std::move(path));
  }

  while (req_wrap->continuation_data()->paths().size() > 0) {
    std::string next_path = req_wrap->continuation_data()->PopPath();
    int err = uv_fs_mkdir(loop, req, next_path.c_str(), mode, nullptr);
    while (true) {
      switch (err) {
        // Note: uv_fs_req_cleanup in terminal paths will be called by
        // ~FSReqWrapSync():
        case 0:
          req_wrap->continuation_data()->MaybeSetFirstPath(next_path);
          if (req_wrap->continuation_data()->paths().size()...",1,27,node_file.cc,node.fs.MKDirpSync,,false,1591,1657,MKDirpSync,,,79,"int node.fs.MKDirpSync (uv_loop_t*,uv_fs_t*,ANY,int,uv_fs_cb)"
175395,METHOD,node_file.cc:<global>,TYPE_DECL,"int MKDirpAsync(uv_loop_t* loop,
                uv_fs_t* req,
                const char* path,
                int mode,
                uv_fs_cb cb) {
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  // on the first iteration of algorithm, stash state information.
  if (req_wrap->continuation_data() == nullptr) {
    req_wrap->set_continuation_data(
        std::make_unique<FSContinuationData>(req, mode, cb));
    req_wrap->continuation_data()->PushPath(std::move(path));
  }

  // on each iteration of algorithm, mkdir directory on top of stack.
  std::string next_path = req_wrap->continuation_data()->PopPath();
  int err = uv_fs_mkdir(loop, req, next_path.c_str(), mode,
                        uv_fs_callback_t{[](uv_fs_t* req) {
    FSReqBase* req_wrap = FSReqBase::from_req(req);
    Environment* env = req_wrap->env();
    uv_loop_t* loop = env->event_loop();
    std::string path = req->path;
    int err = static_cast<int>(req->result);

    while (true) {
      switch (err) {...",1,30,node_file.cc,node.fs.MKDirpAsync,,false,1659,1752,MKDirpAsync,,,80,"int node.fs.MKDirpAsync (uv_loop_t*,uv_fs_t*,char*,int,uv_fs_cb)"
175472,METHOD,node_file.cc:<global>,TYPE_DECL,"int CallMKDirpSync(Environment* env, const FunctionCallbackInfo<Value>& args,
                   FSReqWrapSync* req_wrap, const char* path, int mode) {
  env->PrintSyncTrace();
  int err = MKDirpSync(env->event_loop(), &req_wrap->req, path, mode,
                       nullptr);
  if (err < 0) {
    v8::Local<v8::Context> context = env->context();
    v8::Local<v8::Object> ctx_obj = args[4].As<v8::Object>();
    v8::Isolate* isolate = env->isolate();
    ctx_obj->Set(context,
                 env->errno_string(),
                 v8::Integer::New(isolate, err)).Check();
    ctx_obj->Set(context,
                 env->syscall_string(),
                 OneByteString(isolate, ""mkdir"")).Check();
  }
  return err;
}",1,1,node_file.cc,node.fs.CallMKDirpSync,,false,1754,1771,CallMKDirpSync,,,81,"int node.fs.CallMKDirpSync (Environment*,FunctionCallbackInfo<Value>,FSReqWrapSync*,char*,int)"
175579,METHOD,node_file.cc:<global>,TYPE_DECL,"static void MKDir(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 4);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  CHECK(args[1]->IsInt32());
  const int mode = args[1].As<Int32>()->Value();

  CHECK(args[2]->IsBoolean());
  bool mkdirp = args[2]->IsTrue();

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // mkdir(path, mode, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UNLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""mkdir"", UTF8,
              mkdirp ? AfterMkdirp : AfterNoArgs,
              mkdirp ? MKDirpAsync : uv_fs_mkdir, *path, mode);
  } else {  // mkdir(path, mode, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SY...",1,4,node_file.cc,node.fs.MKDir,,false,1773,1824,MKDir,,,82,void node.fs.MKDir (FunctionCallbackInfo<Value>)
176123,METHOD,node_file.cc:<global>,TYPE_DECL,"static void RealPath(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(isolate, args[0]);
  CHECK_NOT_NULL(*path);

  const enum encoding encoding = ParseEncoding(isolate, args[1], UTF8);

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // realpath(path, encoding, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_REALPATH, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""realpath"", encoding, AfterStringPtr,
              uv_fs_realpath, *path);
  } else {  // realpath(path, encoding, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(realpath);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""realpath"",
                       uv_fs_realpath, *path);
    FS_SYNC_TRACE_END(realpath);
    if (err < 0) {
    ...",1,4,node_file.cc,node.fs.RealPath,,false,1826,1870,RealPath,,,83,void node.fs.RealPath (FunctionCallbackInfo<Value>)
176594,METHOD,node_file.cc:<global>,TYPE_DECL,"static void ReadDir(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(isolate, args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, path.ToStringView());

  const enum encoding encoding = ParseEncoding(isolate, args[1], UTF8);

  bool with_types = args[2]->IsTrue();

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // readdir(path, encoding, withTypes, req)
    req_wrap_async->set_with_file_types(with_types);
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_SCANDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env,
              req_wrap_async,
              args,
              ""scandir"",
              encoding,
              AfterScanDir,
              uv_fs_scandir,
              *path,
              0 /*f...",1,4,node_file.cc,node.fs.ReadDir,,false,1872,1964,ReadDir,,,84,void node.fs.ReadDir (FunctionCallbackInfo<Value>)
177263,METHOD,node_file.cc:<global>,TYPE_DECL,"static inline Maybe<void> CheckOpenPermissions(Environment* env,
                                               const BufferValue& path,
                                               int flags) {
  // These flags capture the intention of the open() call.
  const int rwflags = flags & (UV_FS_O_RDONLY | UV_FS_O_WRONLY | UV_FS_O_RDWR);

  // These flags have write-like side effects even with O_RDONLY, at least on
  // some operating systems. On Windows, for example, O_RDONLY | O_TEMPORARY
  // can be used to delete a file. Bizarre.
  const int write_as_side_effect = flags & (UV_FS_O_APPEND | UV_FS_O_CREAT |
                                            UV_FS_O_TRUNC | UV_FS_O_TEMPORARY);

  // TODO(rafaelgss): it can be optimized to avoid two permission checks
  auto pathView = path.ToStringView();
  if (rwflags != UV_FS_O_WRONLY) {
    THROW_IF_INSUFFICIENT_PERMISSIONS(
        env,
        permission::PermissionScope::kFileSystemRead,
        pathView,
        Nothing<void>());
  }
  ...",1,1,node_file.cc,node.fs.CheckOpenPermissions,,false,1966,1995,CheckOpenPermissions,,,85,"Maybe<void> node.fs.CheckOpenPermissions (Environment*,BufferValue,int)"
177331,METHOD,node_file.cc:<global>,TYPE_DECL,"static void ReadFileSync(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  auto isolate = env->isolate();

  CHECK_GE(args.Length(), 2);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);

  CHECK(args[1]->IsInt32());
  const int flags = args[1].As<Int32>()->Value();

  if (CheckOpenPermissions(env, path, flags).IsNothing()) return;

  uv_fs_t req;
  auto defer_req_cleanup = OnScopeLeave([&req]() { uv_fs_req_cleanup(&req); });

  FS_SYNC_TRACE_BEGIN(open);
  uv_file file = uv_fs_open(nullptr, &req, *path, flags, 438, nullptr);
  FS_SYNC_TRACE_END(open);
  if (req.result < 0) {
    // req will be cleaned up by scope leave.
    Local<Value> out[] = {
        Integer::New(isolate, req.result),       // errno
        FIXED_ONE_BYTE_STRING(isolate, ""open""),  // syscall
    };
    return args.GetReturnValue().Set(Array::New(isolate, out, arraysize(out)));
  }
  uv_fs_req_cleanup(&req);

  auto defer_close = OnScopeLeave([f...",1,2,node_file.cc,node.fs.ReadFileSync,,false,1997,2063,ReadFileSync,,,86,void node.fs.ReadFileSync (FunctionCallbackInfo<Value>)
178055,METHOD,node_file.cc:<global>,TYPE_DECL,"static void Open(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);

  CHECK(args[1]->IsInt32());
  const int flags = args[1].As<Int32>()->Value();

  CHECK(args[2]->IsInt32());
  const int mode = args[2].As<Int32>()->Value();

  if (CheckOpenPermissions(env, path, flags).IsNothing()) return;

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // open(path, flags, mode, req)
    req_wrap_async->set_is_plain_open(true);
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_OPEN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""open"", UTF8, AfterInteger,
              uv_fs_open, *path, flags, mode);
  } else {  // open(path, flags, mode, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(open);
    int result ...",1,4,node_file.cc,node.fs.Open,,false,2065,2099,Open,,,87,void node.fs.Open (FunctionCallbackInfo<Value>)
178506,METHOD,node_file.cc:<global>,TYPE_DECL,"static void OpenFileHandle(const FunctionCallbackInfo<Value>& args) {
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = binding_data->env();
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(isolate, args[0]);
  CHECK_NOT_NULL(*path);

  CHECK(args[1]->IsInt32());
  const int flags = args[1].As<Int32>()->Value();

  CHECK(args[2]->IsInt32());
  const int mode = args[2].As<Int32>()->Value();

  if (CheckOpenPermissions(env, path, flags).IsNothing()) return;

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // openFileHandle(path, flags, mode, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_OPEN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""open"", UTF8, AfterOpenFileHandle,
              uv_fs_open, *path, flags, mode);
  } else {  // openFileHandle(path, flags, mode, undefined, ctx)
    CHECK_EQ(argc,...",1,4,node_file.cc,node.fs.OpenFileHandle,,false,2101,2140,OpenFileHandle,,,88,void node.fs.OpenFileHandle (FunctionCallbackInfo<Value>)
178979,METHOD,node_file.cc:<global>,TYPE_DECL,"static void CopyFile(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue src(isolate, args[0]);
  CHECK_NOT_NULL(*src);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, src.ToStringView());

  BufferValue dest(isolate, args[1]);
  CHECK_NOT_NULL(*dest);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, dest.ToStringView());

  CHECK(args[2]->IsInt32());
  const int flags = args[2].As<Int32>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // copyFile(src, dest, flags, req)
    FS_ASYNC_TRACE_BEGIN2(UV_FS_COPYFILE,
                          req_wrap_async,
                          ""src"",
                          TRACE_STR_COPY(*src),
                          ""dest"",
                          TR...",1,4,node_file.cc,node.fs.CopyFile,,false,2142,2181,CopyFile,,,89,void node.fs.CopyFile (FunctionCallbackInfo<Value>)
179428,METHOD,node_file.cc:<global>,TYPE_DECL,"static void WriteBuffer(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 4);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(Buffer::HasInstance(args[1]));
  Local<Object> buffer_obj = args[1].As<Object>();
  char* buffer_data = Buffer::Data(buffer_obj);
  size_t buffer_length = Buffer::Length(buffer_obj);

  CHECK(IsSafeJsInt(args[2]));
  const int64_t off_64 = args[2].As<Integer>()->Value();
  CHECK_GE(off_64, 0);
  CHECK_LE(static_cast<uint64_t>(off_64), buffer_length);
  const size_t off = static_cast<size_t>(off_64);

  CHECK(args[3]->IsInt32());
  const size_t len = static_cast<size_t>(args[3].As<Int32>()->Value());
  CHECK(Buffer::IsWithinBounds(off, len, buffer_length));
  CHECK_LE(len, buffer_length);
  CHECK_GE(off + len, off);

  const int64_t pos = GetOffset(args[4]);

  char* buf = buffer_data + off;
  uv_buf_t uvbuf = uv_buf_init(buf, ...",1,4,node_file.cc,node.fs.WriteBuffer,,false,2193,2238,WriteBuffer,,,90,void node.fs.WriteBuffer (FunctionCallbackInfo<Value>)
179940,METHOD,node_file.cc:<global>,TYPE_DECL,"static void WriteBuffers(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(args[1]->IsArray());
  Local<Array> chunks = args[1].As<Array>();

  int64_t pos = GetOffset(args[2]);

  MaybeStackBuffer<uv_buf_t> iovs(chunks->Length());

  for (uint32_t i = 0; i < iovs.length(); i++) {
    Local<Value> chunk = chunks->Get(env->context(), i).ToLocalChecked();
    CHECK(Buffer::HasInstance(chunk));
    iovs[i] = uv_buf_init(Buffer::Data(chunk), Buffer::Length(chunk));
  }

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // writeBuffers(fd, chunks, pos, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""write"", UTF8, AfterInteger,
              uv_fs_write, fd, *iovs, iovs.length(), pos);
  } else {  // writeBuffers(fd...",1,4,node_file.cc,node.fs.WriteBuffers,,false,2248,2284,WriteBuffers,,,91,void node.fs.WriteBuffers (FunctionCallbackInfo<Value>)
180424,METHOD,node_file.cc:<global>,TYPE_DECL,"static void WriteString(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 4);
  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  const int64_t pos = GetOffset(args[2]);

  const auto enc = ParseEncoding(isolate, args[3], UTF8);

  Local<Value> value = args[1];
  char* buf = nullptr;
  size_t len;

  FSReqBase* req_wrap_async = GetReqWrap(args, 4);
  const bool is_async = req_wrap_async != nullptr;

  // Avoid copying the string when it is externalized but only when:
  // 1. The target encoding is compatible with the string's encoding, and
  // 2. The write is synchronous, otherwise the string might get neutered
  //    while the request is in flight, and
  // 3. For UCS2, when the host system is little-endian.  Big-endian systems
  //    need to call StringBytes::Write() to ensure proper byte swapping.
  // The const_casts ...",1,4,node_file.cc,node.fs.WriteString,,false,2295,2383,WriteString,,,92,void node.fs.WriteString (FunctionCallbackInfo<Value>)
181093,METHOD,node_file.cc:<global>,TYPE_DECL,"static void Read(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 5);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(Buffer::HasInstance(args[1]));
  Local<Object> buffer_obj = args[1].As<Object>();
  char* buffer_data = Buffer::Data(buffer_obj);
  size_t buffer_length = Buffer::Length(buffer_obj);

  CHECK(IsSafeJsInt(args[2]));
  const int64_t off_64 = args[2].As<Integer>()->Value();
  CHECK_GE(off_64, 0);
  CHECK_LT(static_cast<uint64_t>(off_64), buffer_length);
  const size_t off = static_cast<size_t>(off_64);

  CHECK(args[3]->IsInt32());
  const size_t len = static_cast<size_t>(args[3].As<Int32>()->Value());
  CHECK(Buffer::IsWithinBounds(off, len, buffer_length));

  CHECK(IsSafeJsInt(args[4]) || args[4]->IsBigInt());
  const int64_t pos = args[4]->IsNumber() ?
                      args[4].As<Integer>()->Value() :
                      args...",1,4,node_file.cc,node.fs.Read,,false,2397,2443,Read,,,93,void node.fs.Read (FunctionCallbackInfo<Value>)
181630,METHOD,node_file.cc:<global>,TYPE_DECL,"static void ReadBuffers(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(args[1]->IsArray());
  Local<Array> buffers = args[1].As<Array>();

  int64_t pos = GetOffset(args[2]);  // -1 if not a valid JS int

  MaybeStackBuffer<uv_buf_t> iovs(buffers->Length());

  // Init uv buffers from ArrayBufferViews
  for (uint32_t i = 0; i < iovs.length(); i++) {
    Local<Value> buffer = buffers->Get(env->context(), i).ToLocalChecked();
    CHECK(Buffer::HasInstance(buffer));
    iovs[i] = uv_buf_init(Buffer::Data(buffer), Buffer::Length(buffer));
  }

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // readBuffers(fd, buffers, pos, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""read"", UTF8, AfterInteger,
             ...",1,4,node_file.cc,node.fs.ReadBuffers,,false,2453,2490,ReadBuffers,,,94,void node.fs.ReadBuffers (FunctionCallbackInfo<Value>)
182114,METHOD,node_file.cc:<global>,TYPE_DECL,"static void Chmod(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  CHECK(args[1]->IsInt32());
  int mode = args[1].As<Int32>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // chmod(path, mode, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHMOD, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""chmod"", UTF8, AfterNoArgs,
              uv_fs_chmod, *path, mode);
  } else {  // chmod(path, mode, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(chmod);
    SyncCall(env, args[3], &req_wrap_sync, ""chmod"",
             uv_fs_chmod, *path, mode);
    FS_SYNC_TRACE_E...",1,4,node_file.cc,node.fs.Chmod,,false,2496,2524,Chmod,,,95,void node.fs.Chmod (FunctionCallbackInfo<Value>)
182519,METHOD,node_file.cc:<global>,TYPE_DECL,"static void FChmod(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(args[1]->IsInt32());
  const int mode = args[1].As<Int32>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // fchmod(fd, mode, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHMOD, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fchmod"", UTF8, AfterNoArgs,
              uv_fs_fchmod, fd, mode);
  } else {  // fchmod(fd, mode, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fchmod);
    SyncCall(env, args[3], &req_wrap_sync, ""fchmod"",
             uv_fs_fchmod, fd, mode);
    FS_SYNC_TRACE_END(fchmod);
  }
}",1,4,node_file.cc,node.fs.FChmod,,false,2530,2555,FChmod,,,96,void node.fs.FChmod (FunctionCallbackInfo<Value>)
182908,METHOD,node_file.cc:<global>,TYPE_DECL,"static void Chown(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  CHECK(IsSafeJsInt(args[1]));
  const uv_uid_t uid = static_cast<uv_uid_t>(args[1].As<Integer>()->Value());

  CHECK(IsSafeJsInt(args[2]));
  const uv_gid_t gid = static_cast<uv_gid_t>(args[2].As<Integer>()->Value());

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // chown(path, uid, gid, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""chown"", UTF8, AfterNoArgs,
              uv_fs_chown, *path, uid, gid);
  } else {  // chown(path, uid, gid, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync...",1,4,node_file.cc,node.fs.Chown,,false,2561,2592,Chown,,,97,void node.fs.Chown (FunctionCallbackInfo<Value>)
183334,METHOD,node_file.cc:<global>,TYPE_DECL,"static void FChown(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(IsSafeJsInt(args[1]));
  const uv_uid_t uid = static_cast<uv_uid_t>(args[1].As<Integer>()->Value());

  CHECK(IsSafeJsInt(args[2]));
  const uv_gid_t gid = static_cast<uv_gid_t>(args[2].As<Integer>()->Value());

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // fchown(fd, uid, gid, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHOWN, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fchown"", UTF8, AfterNoArgs,
              uv_fs_fchown, fd, uid, gid);
  } else {  // fchown(fd, uid, gid, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fchown);
    SyncCall(env, args[4], &req_wrap_sync, ""fchown"",
             uv_fs_fchown, fd, uid, gid);
    FS_S...",1,4,node_file.cc,node.fs.FChown,,false,2598,2626,FChown,,,98,void node.fs.FChown (FunctionCallbackInfo<Value>)
183744,METHOD,node_file.cc:<global>,TYPE_DECL,"static void LChown(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  CHECK(IsSafeJsInt(args[1]));
  const uv_uid_t uid = static_cast<uv_uid_t>(args[1].As<Integer>()->Value());

  CHECK(IsSafeJsInt(args[2]));
  const uv_gid_t gid = static_cast<uv_gid_t>(args[2].As<Integer>()->Value());

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // lchown(path, uid, gid, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LCHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""lchown"", UTF8, AfterNoArgs,
              uv_fs_lchown, *path, uid, gid);
  } else {  // lchown(path, uid, gid, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWr...",1,4,node_file.cc,node.fs.LChown,,false,2629,2660,LChown,,,99,void node.fs.LChown (FunctionCallbackInfo<Value>)
184170,METHOD,node_file.cc:<global>,TYPE_DECL,"static void UTimes(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  CHECK(args[1]->IsNumber());
  const double atime = args[1].As<Number>()->Value();

  CHECK(args[2]->IsNumber());
  const double mtime = args[2].As<Number>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // utimes(path, atime, mtime, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""utime"", UTF8, AfterNoArgs,
              uv_fs_utime, *path, atime, mtime);
  } else {  // utimes(path, atime, mtime, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_B...",1,4,node_file.cc,node.fs.UTimes,,false,2663,2694,UTimes,,,100,void node.fs.UTimes (FunctionCallbackInfo<Value>)
184596,METHOD,node_file.cc:<global>,TYPE_DECL,"static void FUTimes(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(args[1]->IsNumber());
  const double atime = args[1].As<Number>()->Value();

  CHECK(args[2]->IsNumber());
  const double mtime = args[2].As<Number>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // futimes(fd, atime, mtime, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FUTIME, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""futime"", UTF8, AfterNoArgs,
              uv_fs_futime, fd, atime, mtime);
  } else {  // futimes(fd, atime, mtime, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(futimes);
    SyncCall(env, args[4], &req_wrap_sync, ""futime"",
             uv_fs_futime, fd, atime, mtime);
    FS_SYNC_TRACE_END(futimes);
  }
}",1,4,node_file.cc,node.fs.FUTimes,,false,2696,2724,FUTimes,,,101,void node.fs.FUTimes (FunctionCallbackInfo<Value>)
185006,METHOD,node_file.cc:<global>,TYPE_DECL,"static void LUTimes(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  CHECK(args[1]->IsNumber());
  const double atime = args[1].As<Number>()->Value();

  CHECK(args[2]->IsNumber());
  const double mtime = args[2].As<Number>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // lutimes(path, atime, mtime, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LUTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""lutime"", UTF8, AfterNoArgs,
              uv_fs_lutime, *path, atime, mtime);
  } else {  // lutimes(path, atime, mtime, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_T...",1,4,node_file.cc,node.fs.LUTimes,,false,2726,2757,LUTimes,,,102,void node.fs.LUTimes (FunctionCallbackInfo<Value>)
185432,METHOD,node_file.cc:<global>,TYPE_DECL,"static void Mkdtemp(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  BufferValue tmpl(isolate, args[0]);
  CHECK_NOT_NULL(*tmpl);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, tmpl.ToStringView());

  const enum encoding encoding = ParseEncoding(isolate, args[1], UTF8);

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // mkdtemp(tmpl, encoding, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_MKDTEMP, req_wrap_async, ""path"", TRACE_STR_COPY(*tmpl))
    AsyncCall(env, req_wrap_async, args, ""mkdtemp"", encoding, AfterStringPath,
              uv_fs_mkdtemp, *tmpl);
  } else {  // mkdtemp(tmpl, encoding, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(mkdtemp);
    SyncCall(env, args[3], &req_wrap_sync, ""mkdtemp"",
   ...",1,4,node_file.cc,node.fs.Mkdtemp,,false,2759,2798,Mkdtemp,,,103,void node.fs.Mkdtemp (FunctionCallbackInfo<Value>)
185903,METHOD,node_file.cc:<global>,TYPE_DECL,"static bool FileURLToPath(
    Environment* env,
    const ada::url_aggregator& file_url,
    /* The linter can't detect the assign for result_file_path
       So we need to ignore since it suggest to put const */
    // NOLINTNEXTLINE(runtime/references)
    std::string& result_file_path) {
  if (file_url.type != ada::scheme::FILE) {
    env->isolate()->ThrowException(ERR_INVALID_URL_SCHEME(env->isolate()));

    return false;
  }

  std::string_view pathname = file_url.get_pathname();
#ifdef _WIN32
  size_t first_percent = std::string::npos;
  size_t pathname_size = pathname.size();
  std::string pathname_escaped_slash;

  for (size_t i = 0; i < pathname_size; i++) {
    if (pathname[i] == '/') {
      pathname_escaped_slash += '\\';
    } else {
      pathname_escaped_slash += pathname[i];
    }

    if (pathname[i] != '%') continue;

    if (first_percent == std::string::npos) {
      first_percent = i;
    }

    // just safe-guard against access the pathname
    // outside the...",1,1,node_file.cc,node.fs.FileURLToPath,,false,2800,2915,FileURLToPath,,,104,"bool node.fs.FileURLToPath (Environment*,ANY,ANY)"
186084,METHOD,node_file.cc:<global>,TYPE_DECL,"BindingData::FilePathIsFileReturnType BindingData::FilePathIsFile(
    Environment* env, const std::string& file_path) {
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env,
      permission::PermissionScope::kFileSystemRead,
      file_path,
      BindingData::FilePathIsFileReturnType::kThrowInsufficientPermissions);

  uv_fs_t req;

  int rc = uv_fs_stat(env->event_loop(), &req, file_path.c_str(), nullptr);

  if (rc == 0) {
    const uv_stat_t* const s = static_cast<const uv_stat_t*>(req.ptr);
    rc = !!(s->st_mode & S_IFDIR);
  }

  uv_fs_req_cleanup(&req);

  // rc is 0 if the path refers to a file
  if (rc == 0) return BindingData::FilePathIsFileReturnType::kIsFile;

  return BindingData::FilePathIsFileReturnType::kIsNotFile;
}",1,1,node_file.cc,node.fs.BindingData.FilePathIsFile,,false,2917,2940,FilePathIsFile,,,105,"FilePathIsFileReturnType node.fs.BindingData.FilePathIsFile (Environment*,ANY)"
186175,METHOD,node_file.cc:<global>,TYPE_DECL,"void BindingData::LegacyMainResolve(const FunctionCallbackInfo<Value>& args) {
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());

  Environment* env = Environment::GetCurrent(args);

  Utf8Value utf8_package_json_url(env->isolate(), args[0].As<String>());
  auto package_json_url =
      ada::parse<ada::url_aggregator>(utf8_package_json_url.ToStringView());

  if (!package_json_url) {
    env->isolate()->ThrowException(
        ERR_INVALID_URL(env->isolate(), ""Invalid URL""));

    return;
  }

  ada::result<ada::url_aggregator> file_path_url;
  std::string initial_file_path;
  std::string file_path;

  if (args.Length() >= 2 && !args[1]->IsNullOrUndefined() &&
      args[1]->IsString()) {
    std::string package_config_main =
        Utf8Value(env->isolate(), args[1].As<String>()).ToString();

    file_path_url = ada::parse<ada::url_aggregator>(
        std::string(""./"") + package_config_main, &package_json_url.value());

    if (!file_path_url) {
      env->isolate()->Thro...",1,1,node_file.cc,node.fs.BindingData.LegacyMainResolve,,false,2958,3084,LegacyMainResolve,,,108,void node.fs.BindingData.LegacyMainResolve (FunctionCallbackInfo<Value>)
186664,METHOD,node_file.cc:<global>,TYPE_DECL,"void BindingData::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""stats_field_array"", stats_field_array);
  tracker->TrackField(""stats_field_bigint_array"", stats_field_bigint_array);
  tracker->TrackField(""statfs_field_array"", statfs_field_array);
  tracker->TrackField(""statfs_field_bigint_array"", statfs_field_bigint_array);
  tracker->TrackField(""file_handle_read_wrap_freelist"",
                      file_handle_read_wrap_freelist);
}",1,1,node_file.cc,node.fs.BindingData.MemoryInfo,,false,3086,3093,MemoryInfo,,,109,void node.fs.BindingData.MemoryInfo (MemoryTracker*)
186699,METHOD,node_file.cc:<global>,TYPE_DECL,"BindingData::BindingData(Realm* realm,
                         v8::Local<v8::Object> wrap,
                         InternalFieldInfo* info)
    : SnapshotableObject(realm, wrap, type_int),
      stats_field_array(realm->isolate(),
                        kFsStatsBufferLength,
                        MAYBE_FIELD_PTR(info, stats_field_array)),
      stats_field_bigint_array(realm->isolate(),
                               kFsStatsBufferLength,
                               MAYBE_FIELD_PTR(info, stats_field_bigint_array)),
      statfs_field_array(realm->isolate(),
                         kFsStatFsBufferLength,
                         MAYBE_FIELD_PTR(info, statfs_field_array)),
      statfs_field_bigint_array(
          realm->isolate(),
          kFsStatFsBufferLength,
          MAYBE_FIELD_PTR(info, statfs_field_bigint_array)) {
  Isolate* isolate = realm->isolate();
  Local<Context> context = realm->context();

  if (info == nullptr) {
    wrap->Set(context,
              FIXED...",1,1,node_file.cc,node.fs.BindingData.BindingData,,false,3095,3145,BindingData,,,110,"ANY node.fs.BindingData.BindingData (Realm*,ANY,InternalFieldInfo*)"
186838,METHOD,node_file.cc:<global>,TYPE_DECL,"void BindingData::Deserialize(Local<Context> context,
                              Local<Object> holder,
                              int index,
                              InternalFieldInfoBase* info) {
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  HandleScope scope(context->GetIsolate());
  Realm* realm = Realm::GetCurrent(context);
  InternalFieldInfo* casted_info = static_cast<InternalFieldInfo*>(info);
  BindingData* binding =
      realm->AddBindingData<BindingData>(context, holder, casted_info);
  CHECK_NOT_NULL(binding);
}",1,1,node_file.cc,node.fs.BindingData.Deserialize,,false,3147,3158,Deserialize,,,111,"void node.fs.BindingData.Deserialize (Local<Context>,Local<Object>,int,InternalFieldInfoBase*)"
186887,METHOD,node_file.cc:<global>,TYPE_DECL,"bool BindingData::PrepareForSerialization(Local<Context> context,
                                          v8::SnapshotCreator* creator) {
  CHECK(file_handle_read_wrap_freelist.empty());
  DCHECK_NULL(internal_field_info_);
  internal_field_info_ = InternalFieldInfoBase::New<InternalFieldInfo>(type());
  internal_field_info_->stats_field_array =
      stats_field_array.Serialize(context, creator);
  internal_field_info_->stats_field_bigint_array =
      stats_field_bigint_array.Serialize(context, creator);
  internal_field_info_->statfs_field_array =
      statfs_field_array.Serialize(context, creator);
  internal_field_info_->statfs_field_bigint_array =
      statfs_field_bigint_array.Serialize(context, creator);
  // Return true because we need to maintain the reference to the binding from
  // JS land.
  return true;
}",1,1,node_file.cc,node.fs.BindingData.PrepareForSerialization,,false,3160,3176,PrepareForSerialization,,,112,"bool node.fs.BindingData.PrepareForSerialization (Local<Context>,ANY*)"
186950,METHOD,node_file.cc:<global>,TYPE_DECL,"InternalFieldInfoBase* BindingData::Serialize(int index) {
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info = internal_field_info_;
  internal_field_info_ = nullptr;
  return info;
}",1,1,node_file.cc,node.fs.BindingData.Serialize,,false,3178,3183,Serialize,,,113,InternalFieldInfoBase node.fs.BindingData.Serialize (int)
186969,METHOD,node_file.cc:<global>,TYPE_DECL,"void BindingData::CreatePerIsolateProperties(IsolateData* isolate_data,
                                             Local<ObjectTemplate> target) {
  Isolate* isolate = isolate_data->isolate();

  SetMethod(
      isolate, target, ""legacyMainResolve"", BindingData::LegacyMainResolve);
}",1,1,node_file.cc,node.fs.BindingData.CreatePerIsolateProperties,,false,3185,3191,CreatePerIsolateProperties,,,114,"void node.fs.BindingData.CreatePerIsolateProperties (IsolateData*,Local<ObjectTemplate>)"
186989,METHOD,node_file.cc:<global>,TYPE_DECL,"void BindingData::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(BindingData::LegacyMainResolve);
}",1,1,node_file.cc,node.fs.BindingData.RegisterExternalReferences,,false,3193,3196,RegisterExternalReferences,,,115,void node.fs.BindingData.RegisterExternalReferences (ExternalReferenceRegistry*)
187001,METHOD,node_file.cc:<global>,TYPE_DECL,"static void CreatePerIsolateProperties(IsolateData* isolate_data,
                                       Local<ObjectTemplate> target) {
  Isolate* isolate = isolate_data->isolate();

  SetMethod(isolate, target, ""access"", Access);
  SetMethod(isolate, target, ""close"", Close);
  SetMethod(isolate, target, ""open"", Open);
  SetMethod(isolate, target, ""openFileHandle"", OpenFileHandle);
  SetMethod(isolate, target, ""read"", Read);
  SetMethod(isolate, target, ""readBuffers"", ReadBuffers);
  SetMethod(isolate, target, ""fdatasync"", Fdatasync);
  SetMethod(isolate, target, ""fsync"", Fsync);
  SetMethod(isolate, target, ""rename"", Rename);
  SetMethod(isolate, target, ""ftruncate"", FTruncate);
  SetMethod(isolate, target, ""rmdir"", RMDir);
  SetMethod(isolate, target, ""mkdir"", MKDir);
  SetMethod(isolate, target, ""readdir"", ReadDir);
  SetMethod(isolate, target, ""internalModuleReadJSON"", InternalModuleReadJSON);
  SetMethod(isolate, target, ""internalModuleStat"", InternalModuleStat);
  SetMethod(i...",1,1,node_file.cc,node.fs.CreatePerIsolateProperties,,false,3198,3302,CreatePerIsolateProperties,,,116,"void node.fs.CreatePerIsolateProperties (IsolateData*,Local<ObjectTemplate>)"
187500,METHOD,node_file.cc:<global>,TYPE_DECL,"static void CreatePerContextProperties(Local<Object> target,
                                       Local<Value> unused,
                                       Local<Context> context,
                                       void* priv) {
  Realm* realm = Realm::GetCurrent(context);
  realm->AddBindingData<BindingData>(context, target);
}",1,1,node_file.cc,node.fs.CreatePerContextProperties,,false,3304,3310,CreatePerContextProperties,,,117,"void node.fs.CreatePerContextProperties (Local<Object>,Local<Value>,Local<Context>,void*)"
187526,METHOD,node_file.cc:<global>,TYPE_DECL,"BindingData* FSReqBase::binding_data() {
  return binding_data_.get();
}",1,1,node_file.cc,node.fs.FSReqBase.binding_data,,false,3312,3314,binding_data,,,118,BindingData node.fs.FSReqBase.binding_data ()
187535,METHOD,node_file.cc:<global>,TYPE_DECL,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(Access);
  StatWatcher::RegisterExternalReferences(registry);
  BindingData::RegisterExternalReferences(registry);

  registry->Register(Close);
  registry->Register(Open);
  registry->Register(OpenFileHandle);
  registry->Register(Read);
  registry->Register(ReadBuffers);
  registry->Register(Fdatasync);
  registry->Register(Fsync);
  registry->Register(Rename);
  registry->Register(FTruncate);
  registry->Register(RMDir);
  registry->Register(MKDir);
  registry->Register(ReadDir);
  registry->Register(InternalModuleReadJSON);
  registry->Register(InternalModuleStat);
  registry->Register(Stat);
  registry->Register(LStat);
  registry->Register(FStat);
  registry->Register(ReadFileSync);
  registry->Register(StatFs);
  registry->Register(Link);
  registry->Register(Symlink);
  registry->Register(ReadLink);
  registry->Register(Unlink);
  registry->Register(WriteBuffer);
  registry->Register(...",1,1,node_file.cc,node.fs.RegisterExternalReferences,,false,3316,3368,RegisterExternalReferences,,,119,void node.fs.RegisterExternalReferences (ExternalReferenceRegistry*)
187785,METHOD,node_file.hpp:<global>,TYPE_DECL,<global>,1,27,node_file.hpp,node_file.hpp:<global>,,false,1,524,<global>,,,1,
187788,METHOD,node_http2.cc:<global>,TYPE_DECL,"[entry = std::move(entry)](Environment* env) {
    if (HasHttp2Observer(env))
      entry->Notify(env);
  }",23,3,node_http2.cc,node.http2.Http2Stream.EmitStatistics.<lambda>0,,false,646,649,<lambda>0,,,1,ANY node.http2.Http2Stream.EmitStatistics.<lambda>0 (Environment*)
187804,METHOD,node_http2.cc:<global>,TYPE_DECL,"[entry = std::move(entry)](Environment* env) {
    if (HasHttp2Observer(env))
      entry->Notify(env);
  }",23,3,node_http2.cc,node.http2.Http2Session.EmitStatistics.<lambda>1,,false,666,669,<lambda>1,,,1,ANY node.http2.Http2Session.EmitStatistics.<lambda>1 (Environment*)
187819,METHOD,node_http2.cc:<global>,TYPE_DECL,"[ping = std::move(ping)](Environment* env) {
          ping->Done(false);
        }",9,9,node_http2.cc,node.http2.Http2Session.Close.<lambda>2,,false,718,720,<lambda>2,,,1,ANY node.http2.Http2Session.Close.<lambda>2 (Environment*)
187830,METHOD,node_http2.cc:<global>,TYPE_DECL,"[&](const Http2Header& header, size_t i) {
    headers_v[i * 2] = header.GetName(this).ToLocalChecked();
    headers_v[i * 2 + 1] = header.GetValue(this).ToLocalChecked();
    if (header.flags() & NGHTTP2_NV_FLAG_NO_INDEX)
      sensitive_v[sensitive_count++] = headers_v[i * 2];
  }",27,3,node_http2.cc,node.http2.Http2Session.HandleHeadersFrame.<lambda>3,,false,1352,1357,<lambda>3,,,1,"ANY node.http2.Http2Session.HandleHeadersFrame.<lambda>3 (Http2Header,size_t)"
187888,METHOD,node_http2.cc:<global>,TYPE_DECL,"[this, strong_ref](Environment* env) {
      if (!session_ || !is_write_scheduled()) {
        // This can happen e.g. when a stream was reset before this turn
        // of the event loop, in which case SendPendingData() is called early,
        // or the session was destroyed in the meantime.
        return;
      }

      // Sending data may call arbitrary JS code, so keep track of
      // async context.
      if (env->can_call_into_js()) {
        HandleScope handle_scope(env->isolate());
        InternalCallbackScope callback_scope(this);
        SendPendingData();
      }
    }",25,5,node_http2.cc,node.http2.Http2Session.MaybeScheduleWrite.<lambda>4,,false,1628,1643,<lambda>4,,,1,ANY node.http2.Http2Session.MaybeScheduleWrite.<lambda>4 (Environment*)
187918,METHOD,node_http2.cc:<global>,TYPE_DECL,"[this, strong_ref = std::move(strong_ref)](
        Environment* env) {
      // Free any remaining outgoing data chunks here. This should be done
      // here because it's possible for destroy to have been called while
      // we still have queued outbound writes.
      while (!queue_.empty()) {
        NgHttp2StreamWrite& head = queue_.front();
        if (head.req_wrap)
          WriteWrap::FromObject(head.req_wrap)->Done(UV_ECANCELED);
        queue_.pop();
      }

      // We can destroy the stream now if there are no writes for it
      // already on the socket. Otherwise, we'll wait for the garbage collector
      // to take care of cleaning up.
      if (session() == nullptr ||
          !session()->HasWritesOnSocketForStream(this)) {
        // Delete once strong_ref goes out of scope.
        Detach();
      }
    }",25,5,node_http2.cc,node.http2.Http2Stream.Destroy.<lambda>5,,false,2140,2160,<lambda>5,,,1,ANY node.http2.Http2Stream.Destroy.<lambda>5 (Environment*)
187971,METHOD,node_http2.cc:<global>,TYPE_DECL,"[](const uint32_t code) {
    return code == NGHTTP2_CANCEL;
  }",27,3,node_http2.cc,node.http2.Http2Stream.SubmitRstStream.<lambda>6,,false,2275,2277,<lambda>6,,,1,ANY node.http2.Http2Stream.SubmitRstStream.<lambda>6 (uint32_t)
188021,METHOD,node_http2.cc:<global>,TYPE_DECL,<global>,1,28,node_http2.hpp,node_http2.cc:<global>,,false,1,3343,<global>,,,1,
188030,METHOD,node_http2.cc:<global>,TYPE_DECL,"bool HasHttp2Observer(Environment* env) {
  AliasedUint32Array& observers = env->performance_state()->observers;
  return observers[performance::NODE_PERFORMANCE_ENTRY_TYPE_HTTP2] != 0;
}",1,1,node_http2.cc,node.http2.anonymous_namespace_1.HasHttp2Observer,,false,54,57,HasHttp2Observer,,,3,bool node.http2.anonymous_namespace_1.HasHttp2Observer (Environment*)
188060,METHOD,node_http2.cc:<global>,TYPE_DECL,Http2Scope::Http2Scope(Http2Stream* stream) : Http2Scope(stream->session()) {},1,78,node_http2.cc,node.http2.Http2Scope.Http2Scope,,false,79,79,Http2Scope,,,4,ANY node.http2.Http2Scope.Http2Scope (Http2Stream*)
188065,METHOD,node_http2.cc:<global>,TYPE_DECL,"Http2Scope::Http2Scope(Http2Session* session) : session_(session) {
  if (!session_) return;

  // If there is another scope further below on the stack, or
  // a write is already scheduled, there's nothing to do.
  if (session_->is_in_scope() || session_->is_write_scheduled()) {
    session_.reset();
    return;
  }
  session_->set_in_scope();
}",1,1,node_http2.cc,node.http2.Http2Scope.Http2Scope,,false,81,91,Http2Scope,,,5,ANY node.http2.Http2Scope.Http2Scope (Http2Session*)
188095,METHOD,node_http2.cc:<global>,TYPE_DECL,"Http2Scope::~Http2Scope() {
  if (!session_) return;
  session_->set_in_scope(false);
  if (!session_->is_write_scheduled())
    session_->MaybeScheduleWrite();
}",1,1,node_http2.cc,node.http2.Http2Scope.~Http2Scope,,false,93,98,~Http2Scope,,,6,ANY node.http2.Http2Scope.~Http2Scope ()
188120,METHOD,node_http2.cc:<global>,TYPE_DECL,"Http2Options::Http2Options(Http2State* http2_state, SessionType type) {
  nghttp2_option* option;
  CHECK_EQ(nghttp2_option_new(&option), 0);
  CHECK_NOT_NULL(option);
  options_.reset(option);

  // Make sure closed connections aren't kept around, taking up memory.
  // Note that this breaks the priority tree, which we don't use.
  nghttp2_option_set_no_closed_streams(option, 1);

  // We manually handle flow control within a session in order to
  // implement backpressure -- that is, we only send WINDOW_UPDATE
  // frames to the remote peer as data is actually consumed by user
  // code. This ensures that the flow of data over the connection
  // does not move too quickly and limits the amount of data we
  // are required to buffer.
  nghttp2_option_set_no_auto_window_update(option, 1);

  // Enable built in support for receiving ALTSVC and ORIGIN frames (but
  // only on client side sessions
  if (type == NGHTTP2_SESSION_CLIENT) {
    nghttp2_option_set_builtin_recv_extension_typ...",1,1,node_http2.cc,node.http2.Http2Options.Http2Options,,false,104,209,Http2Options,,,7,"ANY node.http2.Http2Options.Http2Options (Http2State*,SessionType)"
188300,METHOD,node_http2.cc:<global>,TYPE_DECL,"size_t Http2Settings::Init(
    Http2State* http2_state,
    nghttp2_settings_entry* entries) {
  AliasedUint32Array& buffer = http2_state->settings_buffer;
  uint32_t flags = buffer[IDX_SETTINGS_COUNT];

  size_t count = 0;

#define V(name) GRABSETTING(entries, count, name);
  HTTP2_SETTINGS(V)
#undef V

  return count;
}",1,1,node_http2.cc,node.http2.Http2Settings.Init,,false,219,232,Init,,,8,"size_t node.http2.Http2Settings.Init (Http2State*,nghttp2_settings_entry*)"
188326,METHOD,node_http2.cc:<global>,TYPE_DECL,"Http2Settings::Http2Settings(Http2Session* session,
                             Local<Object> obj,
                             Local<Function> callback,
                             uint64_t start_time)
    : AsyncWrap(session->env(), obj, PROVIDER_HTTP2SETTINGS),
      session_(session),
      startTime_(start_time) {
  callback_.Reset(env()->isolate(), callback);
  count_ = Init(session->http2_state(), entries_);
}",1,1,node_http2.cc,node.http2.Http2Settings.Http2Settings,,false,238,247,Http2Settings,,,9,"ANY node.http2.Http2Settings.Http2Settings (Http2Session*,Local<Object>,Local<Function>,uint64_t)"
188351,METHOD,node_http2.cc:<global>,TYPE_DECL,"Local<Function> Http2Settings::callback() const {
  return callback_.Get(env()->isolate());
}",1,1,node_http2.cc,node.http2.Http2Settings.callback,,false,249,251,callback,,,10,Local<Function> node.http2.Http2Settings.callback ()
188364,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Settings::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""callback"", callback_);
}",1,1,node_http2.cc,node.http2.Http2Settings.MemoryInfo,,false,253,255,MemoryInfo,,,11,void node.http2.Http2Settings.MemoryInfo (MemoryTracker*)
188375,METHOD,node_http2.cc:<global>,TYPE_DECL,"Local<Value> Http2Settings::Pack() {
  return Pack(session_->env(), count_, entries_);
}",1,1,node_http2.cc,node.http2.Http2Settings.Pack,,false,260,262,Pack,,,12,Local<Value> node.http2.Http2Settings.Pack ()
188387,METHOD,node_http2.cc:<global>,TYPE_DECL,"Local<Value> Http2Settings::Pack(Http2State* state) {
  nghttp2_settings_entry entries[IDX_SETTINGS_COUNT];
  size_t count = Init(state, entries);
  return Pack(state->env(), count, entries);
}",1,1,node_http2.cc,node.http2.Http2Settings.Pack,,false,264,268,Pack,,,13,Local<Value> node.http2.Http2Settings.Pack (Http2State*)
188407,METHOD,node_http2.cc:<global>,TYPE_DECL,"Local<Value> Http2Settings::Pack(
    Environment* env,
    size_t count,
    const nghttp2_settings_entry* entries) {
  EscapableHandleScope scope(env->isolate());
  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), count * 6);
  }
  if (nghttp2_pack_settings_payload(static_cast<uint8_t*>(bs->Data()),
                                    bs->ByteLength(),
                                    entries,
                                    count) < 0) {
    return scope.Escape(Undefined(env->isolate()));
  }
  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  return scope.Escape(Buffer::New(env, ab, 0, ab->ByteLength())
                          .FromMaybe(Local<Value>()));
}",1,1,node_http2.cc,node.http2.Http2Settings.Pack,,false,270,289,Pack,,,14,"Local<Value> node.http2.Http2Settings.Pack (Environment*,size_t,nghttp2_settings_entry*)"
188513,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Settings::Update(Http2Session* session, get_setting fn) {
  AliasedUint32Array& buffer = session->http2_state()->settings_buffer;

#define V(name)                                                                \
  buffer[IDX_SETTINGS_ ## name] =                                              \
      fn(session->session(), NGHTTP2_SETTINGS_ ## name);
  HTTP2_SETTINGS(V)
#undef V
}",1,1,node_http2.cc,node.http2.Http2Settings.Update,,false,293,301,Update,,,15,"void node.http2.Http2Settings.Update (Http2Session*,get_setting)"
188530,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Settings::RefreshDefaults(Http2State* http2_state) {
  AliasedUint32Array& buffer = http2_state->settings_buffer;
  uint32_t flags = 0;

#define V(name)                                                            \
  do {                                                                     \
    buffer[IDX_SETTINGS_ ## name] = DEFAULT_SETTINGS_ ## name;             \
    flags |= 1 << IDX_SETTINGS_ ## name;                                   \
  } while (0);
  HTTP2_SETTINGS(V)
#undef V

  buffer[IDX_SETTINGS_COUNT] = flags;
}",1,1,node_http2.cc,node.http2.Http2Settings.RefreshDefaults,,false,304,317,RefreshDefaults,,,16,void node.http2.Http2Settings.RefreshDefaults (Http2State*)
188552,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Settings::Send() {
  Http2Scope h2scope(session_.get());
  CHECK_EQ(nghttp2_submit_settings(
      session_->session(),
      NGHTTP2_FLAG_NONE,
      &entries_[0],
      count_), 0);
}",1,1,node_http2.cc,node.http2.Http2Settings.Send,,false,320,327,Send,,,17,void node.http2.Http2Settings.Send ()
188575,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Settings::Done(bool ack) {
  uint64_t end = uv_hrtime();
  double duration = (end - startTime_) / 1e6;

  Local<Value> argv[] = {Boolean::New(env()->isolate(), ack),
                         Number::New(env()->isolate(), duration)};
  MakeCallback(callback(), arraysize(argv), argv);
}",1,1,node_http2.cc,node.http2.Http2Settings.Done,,false,329,336,Done,,,18,void node.http2.Http2Settings.Done (bool)
188619,METHOD,node_http2.cc:<global>,TYPE_DECL,"Http2Priority::Http2Priority(Environment* env,
                             Local<Value> parent,
                             Local<Value> weight,
                             Local<Value> exclusive) {
  Local<Context> context = env->context();
  int32_t parent_ = parent->Int32Value(context).ToChecked();
  int32_t weight_ = weight->Int32Value(context).ToChecked();
  bool exclusive_ = exclusive->IsTrue();
  Debug(env, DebugCategory::HTTP2STREAM,
        ""Http2Priority: parent: %d, weight: %d, exclusive: %s\n"",
        parent_, weight_, exclusive_ ? ""yes"" : ""no"");
  nghttp2_priority_spec_init(this, parent_, weight_, exclusive_ ? 1 : 0);
}",1,1,node_http2.cc,node.http2.Http2Priority.Http2Priority,,false,341,353,Http2Priority,,,19,"ANY node.http2.Http2Priority.Http2Priority (Environment*,Local<Value>,Local<Value>,Local<Value>)"
188686,METHOD,node_http2.cc:<global>,TYPE_DECL,"const char* Http2Session::TypeName() const {
  switch (session_type_) {
    case NGHTTP2_SESSION_SERVER: return ""server"";
    case NGHTTP2_SESSION_CLIENT: return ""client"";
    default:
      // This should never happen
      ABORT();
  }
}",1,1,node_http2.cc,node.http2.Http2Session.TypeName,,false,356,364,TypeName,,,20,const char* node.http2.Http2Session.TypeName ()
188703,METHOD,node_http2.cc:<global>,TYPE_DECL,"Origins::Origins(
    Environment* env,
    Local<String> origin_string,
    size_t origin_count)
    : count_(origin_count) {
  int origin_string_len = origin_string->Length();
  if (count_ == 0) {
    CHECK_EQ(origin_string_len, 0);
    return;
  }

  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs_ = ArrayBuffer::NewBackingStore(env->isolate(),
                                       alignof(nghttp2_origin_entry) - 1 +
                                       count_ * sizeof(nghttp2_origin_entry) +
                                       origin_string_len);
  }

  // Make sure the start address is aligned appropriately for an nghttp2_nv*.
  char* start = AlignUp(static_cast<char*>(bs_->Data()),
                        alignof(nghttp2_origin_entry));
  char* origin_contents = start + (count_ * sizeof(nghttp2_origin_entry));
  nghttp2_origin_entry* const nva =
      reinterpret_cast<nghttp2_origin_entry*>(start);

  CHECK_LE(origin_contents + origin_str...",1,1,node_http2.cc,node.http2.Origins.Origins,,false,366,417,Origins,,,21,"ANY node.http2.Origins.Origins (Environment*,Local<String>,size_t)"
188886,METHOD,node_http2.cc:<global>,TYPE_DECL,"Http2Session::Callbacks::Callbacks(bool kHasGetPaddingCallback) {
  nghttp2_session_callbacks* callbacks_;
  CHECK_EQ(nghttp2_session_callbacks_new(&callbacks_), 0);
  callbacks.reset(callbacks_);

  nghttp2_session_callbacks_set_on_begin_headers_callback(
    callbacks_, OnBeginHeadersCallback);
  nghttp2_session_callbacks_set_on_header_callback2(
    callbacks_, OnHeaderCallback);
  nghttp2_session_callbacks_set_on_frame_recv_callback(
    callbacks_, OnFrameReceive);
  nghttp2_session_callbacks_set_on_stream_close_callback(
    callbacks_, OnStreamClose);
  nghttp2_session_callbacks_set_on_data_chunk_recv_callback(
    callbacks_, OnDataChunkReceived);
  nghttp2_session_callbacks_set_on_frame_not_send_callback(
    callbacks_, OnFrameNotSent);
  nghttp2_session_callbacks_set_on_invalid_header_callback2(
    callbacks_, OnInvalidHeader);
  nghttp2_session_callbacks_set_error_callback2(callbacks_, OnNghttpError);
  nghttp2_session_callbacks_set_send_data_callback(
    callbacks_, O...",1,1,node_http2.cc,node.http2.Http2Session.Callbacks.Callbacks,,false,421,452,Callbacks,,,22,ANY node.http2.Http2Session.Callbacks.Callbacks (bool)
188941,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::StopTrackingRcbuf(nghttp2_rcbuf* buf) {
  StopTrackingMemory(buf);
}",1,1,node_http2.cc,node.http2.Http2Session.StopTrackingRcbuf,,false,454,456,StopTrackingRcbuf,,,23,void node.http2.Http2Session.StopTrackingRcbuf (nghttp2_rcbuf*)
188948,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::CheckAllocatedSize(size_t previous_size) const {
  CHECK_GE(current_nghttp2_memory_, previous_size);
}",1,1,node_http2.cc,node.http2.Http2Session.CheckAllocatedSize,,false,458,460,CheckAllocatedSize,,,24,void node.http2.Http2Session.CheckAllocatedSize (size_t)
188956,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::IncreaseAllocatedSize(size_t size) {
  current_nghttp2_memory_ += size;
}",1,1,node_http2.cc,node.http2.Http2Session.IncreaseAllocatedSize,,false,462,464,IncreaseAllocatedSize,,,25,void node.http2.Http2Session.IncreaseAllocatedSize (size_t)
188964,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::DecreaseAllocatedSize(size_t size) {
  current_nghttp2_memory_ -= size;
}",1,1,node_http2.cc,node.http2.Http2Session.DecreaseAllocatedSize,,false,466,468,DecreaseAllocatedSize,,,26,void node.http2.Http2Session.DecreaseAllocatedSize (size_t)
188972,METHOD,node_http2.cc:<global>,TYPE_DECL,"Http2Session::Http2Session(Http2State* http2_state,
                           Local<Object> wrap,
                           SessionType type)
    : AsyncWrap(http2_state->env(), wrap, AsyncWrap::PROVIDER_HTTP2SESSION),
      js_fields_(http2_state->env()->isolate()),
      session_type_(type),
      http2_state_(http2_state) {
  MakeWeak();
  statistics_.session_type = type;
  statistics_.start_time = uv_hrtime();

  // Capture the configuration options for this session
  Http2Options opts(http2_state, type);

  max_session_memory_ = opts.max_session_memory();

  uint32_t maxHeaderPairs = opts.max_header_pairs();
  max_header_pairs_ =
      type == NGHTTP2_SESSION_SERVER
          ? GetServerMaxHeaderPairs(maxHeaderPairs)
          : GetClientMaxHeaderPairs(maxHeaderPairs);

  max_outstanding_pings_ = opts.max_outstanding_pings();
  max_outstanding_settings_ = opts.max_outstanding_settings();

  padding_strategy_ = opts.padding_strategy();

  bool hasGetPaddingCallback =
      pad...",1,1,node_http2.cc,node.http2.Http2Session.Http2Session,,false,470,526,Http2Session,,,27,"ANY node.http2.Http2Session.Http2Session (Http2State*,Local<Object>,SessionType)"
189121,METHOD,node_http2.cc:<global>,TYPE_DECL,"Http2Session::~Http2Session() {
  CHECK(!is_in_scope());
  Debug(this, ""freeing nghttp2 session"");
  // Explicitly reset session_ so the subsequent
  // current_nghttp2_memory_ check passes.
  session_.reset();
  CHECK_EQ(current_nghttp2_memory_, 0);
}",1,1,node_http2.cc,node.http2.Http2Session.~Http2Session,,false,528,535,~Http2Session,,,28,ANY node.http2.Http2Session.~Http2Session ()
189138,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""streams"", streams_);
  tracker->TrackField(""outstanding_pings"", outstanding_pings_);
  tracker->TrackField(""outstanding_settings"", outstanding_settings_);
  tracker->TrackField(""outgoing_buffers"", outgoing_buffers_);
  tracker->TrackFieldWithSize(""stream_buf"", stream_buf_.len);
  tracker->TrackFieldWithSize(""outgoing_storage"", outgoing_storage_.size());
  tracker->TrackFieldWithSize(""pending_rst_streams"",
                              pending_rst_streams_.size() * sizeof(int32_t));
  tracker->TrackFieldWithSize(""nghttp2_memory"", current_nghttp2_memory_);
}",1,1,node_http2.cc,node.http2.Http2Session.MemoryInfo,,false,537,547,MemoryInfo,,,29,void node.http2.Http2Session.MemoryInfo (MemoryTracker*)
189202,METHOD,node_http2.cc:<global>,TYPE_DECL,"std::string Http2Session::diagnostic_name() const {
  return std::string(""Http2Session "") + TypeName() + "" ("" +
      std::to_string(static_cast<int64_t>(get_async_id())) + "")"";
}",1,1,node_http2.cc,node.http2.Http2Session.diagnostic_name,,false,549,552,diagnostic_name,,,30,string node.http2.Http2Session.diagnostic_name ()
189226,METHOD,node_http2.cc:<global>,TYPE_DECL,"MaybeLocal<Object> Http2StreamPerformanceEntryTraits::GetDetails(
    Environment* env,
    const Http2StreamPerformanceEntry& entry) {
  Local<Object> obj = Object::New(env->isolate());

#define SET(name, val)                                                         \
  if (!obj->Set(                                                               \
          env->context(),                                                      \
          env->name(),                                                         \
          Number::New(                                                         \
            env->isolate(),                                                    \
            static_cast<double>(entry.details.val))).IsJust()) {               \
    return MaybeLocal<Object>();                                               \
  }

  SET(bytes_read_string, received_bytes)
  SET(bytes_written_string, sent_bytes)
  SET(id_string, id)
#undef SET

#define SET(name, val)                    ...",1,2,node_http2.cc,node.http2.Http2StreamPerformanceEntryTraits.GetDetails,,false,554,591,GetDetails,,,31,"MaybeLocal<Object> node.http2.Http2StreamPerformanceEntryTraits.GetDetails (Environment*,Http2StreamPerformanceEntry)"
189488,METHOD,node_http2.cc:<global>,TYPE_DECL,"MaybeLocal<Object> Http2SessionPerformanceEntryTraits::GetDetails(
    Environment* env,
    const Http2SessionPerformanceEntry& entry) {
  Local<Object> obj = Object::New(env->isolate());

#define SET(name, val)                                                         \
  if (!obj->Set(                                                               \
          env->context(),                                                      \
          env->name(),                                                         \
          Number::New(                                                         \
            env->isolate(),                                                    \
            static_cast<double>(entry.details.val))).IsJust()) {               \
    return MaybeLocal<Object>();                                               \
  }

  SET(bytes_written_string, data_sent)
  SET(bytes_read_string, data_received)
  SET(frames_received_string, frame_count)
  SET(frames_sent_string, frame_...",1,2,node_http2.cc,node.http2.Http2SessionPerformanceEntryTraits.GetDetails,,false,593,629,GetDetails,,,32,"MaybeLocal<Object> node.http2.Http2SessionPerformanceEntryTraits.GetDetails (Environment*,Http2SessionPerformanceEntry)"
189841,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Stream::EmitStatistics() {
  CHECK_NOT_NULL(session());
  if (LIKELY(!HasHttp2Observer(env())))
    return;

  double start = statistics_.start_time / 1e6;
  double duration = (PERFORMANCE_NOW() / 1e6) - start;

  std::unique_ptr<Http2StreamPerformanceEntry> entry =
      std::make_unique<Http2StreamPerformanceEntry>(
          ""Http2Stream"",
          start - (env()->time_origin() / 1e6),
          duration,
          statistics_);

  env()->SetImmediate([entry = std::move(entry)](Environment* env) {
    if (HasHttp2Observer(env))
      entry->Notify(env);
  });
}",1,1,node_http2.cc,node.http2.Http2Stream.EmitStatistics,,false,631,650,EmitStatistics,,,33,void node.http2.Http2Stream.EmitStatistics ()
189901,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::EmitStatistics() {
  if (LIKELY(!HasHttp2Observer(env())))
    return;

  double start = statistics_.start_time / 1e6;
  double duration = (PERFORMANCE_NOW() / 1e6) - start;

  std::unique_ptr<Http2SessionPerformanceEntry> entry =
      std::make_unique<Http2SessionPerformanceEntry>(
          ""Http2Session"",
          start - (env()->time_origin() / 1e6),
          duration,
          statistics_);

  env()->SetImmediate([entry = std::move(entry)](Environment* env) {
    if (HasHttp2Observer(env))
      entry->Notify(env);
  });
}",1,1,node_http2.cc,node.http2.Http2Session.EmitStatistics,,false,652,670,EmitStatistics,,,34,void node.http2.Http2Session.EmitStatistics ()
189960,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::Close(uint32_t code, bool socket_closed) {
  Debug(this, ""closing session"");

  if (is_closing())
    return;
  set_closing();

  // Stop reading on the i/o stream
  if (stream_ != nullptr) {
    set_reading_stopped();
    stream_->ReadStop();
  }

  // If the socket is not closed, then attempt to send a closing GOAWAY
  // frame. There is no guarantee that this GOAWAY will be received by
  // the peer but the HTTP/2 spec recommends sending it anyway. We'll
  // make a best effort.
  if (!socket_closed) {
    Debug(this, ""terminating session with code %d"", code);
    CHECK_EQ(nghttp2_session_terminate_session(session_.get(), code), 0);
    SendPendingData();
  } else if (stream_ != nullptr) {
    stream_->RemoveStreamListener(this);
  }

  set_destroyed();

  // If we are writing we will get to make the callback in OnStreamAfterWrite.
  if (!is_write_in_progress()) {
    Debug(this, ""make done session callback"");
    HandleScope scope(env()->isolate());
    MakeCa...",1,1,node_http2.cc,node.http2.Http2Session.Close,,false,673,725,Close,,,35,"void node.http2.Http2Session.Close (uint32_t,bool)"
190069,METHOD,node_http2.cc:<global>,TYPE_DECL,"BaseObjectPtr<Http2Stream> Http2Session::FindStream(int32_t id) {
  auto s = streams_.find(id);
  return s != streams_.end() ? s->second : BaseObjectPtr<Http2Stream>();
}",1,1,node_http2.cc,node.http2.Http2Session.FindStream,,false,729,732,FindStream,,,36,BaseObjectPtr<Http2Stream> node.http2.Http2Session.FindStream (int32_t)
190094,METHOD,node_http2.cc:<global>,TYPE_DECL,"bool Http2Session::CanAddStream() {
  uint32_t maxConcurrentStreams =
      nghttp2_session_get_local_settings(
          session_.get(), NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS);
  size_t maxSize =
      std::min(streams_.max_size(), static_cast<size_t>(maxConcurrentStreams));
  // We can add a new stream so long as we are less than the current
  // maximum on concurrent streams and there's enough available memory
  return streams_.size() < maxSize &&
         has_available_session_memory(sizeof(Http2Stream));
}",1,1,node_http2.cc,node.http2.Http2Session.CanAddStream,,false,734,744,CanAddStream,,,37,bool node.http2.Http2Session.CanAddStream ()
190132,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::AddStream(Http2Stream* stream) {
  CHECK_GE(++statistics_.stream_count, 0);
  streams_[stream->id()] = BaseObjectPtr<Http2Stream>(stream);
  size_t size = streams_.size();
  if (size > statistics_.max_concurrent_streams)
    statistics_.max_concurrent_streams = size;
  IncrementCurrentSessionMemory(sizeof(*stream));
}",1,1,node_http2.cc,node.http2.Http2Session.AddStream,,false,746,753,AddStream,,,38,void node.http2.Http2Session.AddStream (Http2Stream*)
190178,METHOD,node_http2.cc:<global>,TYPE_DECL,"BaseObjectPtr<Http2Stream> Http2Session::RemoveStream(int32_t id) {
  BaseObjectPtr<Http2Stream> stream;
  if (streams_.empty())
    return stream;
  stream = FindStream(id);
  if (stream) {
    streams_.erase(id);
    DecrementCurrentSessionMemory(sizeof(*stream));
  }
  return stream;
}",1,1,node_http2.cc,node.http2.Http2Session.RemoveStream,,false,756,766,RemoveStream,,,39,BaseObjectPtr<Http2Stream> node.http2.Http2Session.RemoveStream (int32_t)
190214,METHOD,node_http2.cc:<global>,TYPE_DECL,"ssize_t Http2Session::OnDWordAlignedPadding(size_t frameLen,
                                            size_t maxPayloadLen) {
  size_t r = (frameLen + 9) % 8;
  if (r == 0) return frameLen;  // If already a multiple of 8, return.

  size_t pad = frameLen + (8 - r);

  // If maxPayloadLen happens to be less than the calculated pad length,
  // use the max instead, even tho this means the frame will not be
  // aligned.
  pad = std::min(maxPayloadLen, pad);
  Debug(this, ""using frame size padding: %d"", pad);
  return pad;
}",1,1,node_http2.cc,node.http2.Http2Session.OnDWordAlignedPadding,,false,772,785,OnDWordAlignedPadding,,,40,"ssize_t node.http2.Http2Session.OnDWordAlignedPadding (size_t,size_t)"
190257,METHOD,node_http2.cc:<global>,TYPE_DECL,"ssize_t Http2Session::OnMaxFrameSizePadding(size_t frameLen,
                                            size_t maxPayloadLen) {
  Debug(this, ""using max frame size padding: %d"", maxPayloadLen);
  return maxPayloadLen;
}",1,1,node_http2.cc,node.http2.Http2Session.OnMaxFrameSizePadding,,false,789,793,OnMaxFrameSizePadding,,,41,"ssize_t node.http2.Http2Session.OnMaxFrameSizePadding (size_t,size_t)"
190269,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::ConsumeHTTP2Data() {
  CHECK_NOT_NULL(stream_buf_.base);
  CHECK_LE(stream_buf_offset_, stream_buf_.len);
  size_t read_len = stream_buf_.len - stream_buf_offset_;

  // multiple side effects.
  Debug(this, ""receiving %d bytes [wants data? %d]"",
        read_len,
        nghttp2_session_want_read(session_.get()));
  set_receive_paused(false);
  custom_recv_error_code_ = nullptr;
  ssize_t ret =
    nghttp2_session_mem_recv(session_.get(),
                             reinterpret_cast<uint8_t*>(stream_buf_.base) +
                                 stream_buf_offset_,
                             read_len);
  CHECK_NE(ret, NGHTTP2_ERR_NOMEM);
  CHECK_IMPLIES(custom_recv_error_code_ != nullptr, ret < 0);

  if (is_receive_paused()) {
    CHECK(is_reading_stopped());

    CHECK_GT(ret, 0);
    CHECK_LE(static_cast<size_t>(ret), read_len);

    // Mark the remainder of the data as available for later consumption.
    // Even if all bytes were received, a paused stream m...",1,1,node_http2.cc,node.http2.Http2Session.ConsumeHTTP2Data,,false,800,867,ConsumeHTTP2Data,,,42,void node.http2.Http2Session.ConsumeHTTP2Data ()
190442,METHOD,node_http2.cc:<global>,TYPE_DECL,"int32_t GetFrameID(const nghttp2_frame* frame) {
  // If this is a push promise, we want to grab the id of the promised stream
  return (frame->hd.type == NGHTTP2_PUSH_PROMISE) ?
      frame->push_promise.promised_stream_id :
      frame->hd.stream_id;
}",1,1,node_http2.cc,node.http2.GetFrameID,,false,870,875,GetFrameID,,,43,int32_t node.http2.GetFrameID (nghttp2_frame*)
190466,METHOD,node_http2.cc:<global>,TYPE_DECL,"int Http2Session::OnBeginHeadersCallback(nghttp2_session* handle,
                                         const nghttp2_frame* frame,
                                         void* user_data) {
  Http2Session* session = static_cast<Http2Session*>(user_data);
  int32_t id = GetFrameID(frame);
  Debug(session, ""beginning headers for stream %d"", id);

  BaseObjectPtr<Http2Stream> stream = session->FindStream(id);
  // The common case is that we're creating a new stream. The less likely
  // case is that we're receiving a set of trailers
  if (LIKELY(!stream)) {
    if (UNLIKELY(!session->CanAddStream() ||
                 Http2Stream::New(session, id, frame->headers.cat) ==
                     nullptr)) {
      if (session->rejected_stream_count_++ >
          session->js_fields_->max_rejected_streams)
        return NGHTTP2_ERR_CALLBACK_FAILURE;
      // Too many concurrent streams being opened
      nghttp2_submit_rst_stream(
          session->session(),
          NGHTTP2_FLAG_NON...",1,1,node_http2.cc,node.http2.Http2Session.OnBeginHeadersCallback,,false,882,913,OnBeginHeadersCallback,,,44,"int node.http2.Http2Session.OnBeginHeadersCallback (nghttp2_session*,nghttp2_frame*,void*)"
190575,METHOD,node_http2.cc:<global>,TYPE_DECL,"int Http2Session::OnHeaderCallback(nghttp2_session* handle,
                                   const nghttp2_frame* frame,
                                   nghttp2_rcbuf* name,
                                   nghttp2_rcbuf* value,
                                   uint8_t flags,
                                   void* user_data) {
  Http2Session* session = static_cast<Http2Session*>(user_data);
  int32_t id = GetFrameID(frame);
  BaseObjectPtr<Http2Stream> stream = session->FindStream(id);
  // If stream is null at this point, either something odd has happened
  // or the stream was closed locally while header processing was occurring.
  // either way, do not proceed and close the stream.
  if (UNLIKELY(!stream))
    return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;

  // If the stream has already been destroyed, ignore.
  if (!stream->is_destroyed() && !stream->AddHeader(name, value, flags)) {
    // This will only happen if the connected peer sends us more
    // than the allow...",1,1,node_http2.cc,node.http2.Http2Session.OnHeaderCallback,,false,918,941,OnHeaderCallback,,,45,"int node.http2.Http2Session.OnHeaderCallback (nghttp2_session*,nghttp2_frame*,nghttp2_rcbuf*,nghttp2_rcbuf*,uint8_t,void*)"
190639,METHOD,node_http2.cc:<global>,TYPE_DECL,"int Http2Session::OnFrameReceive(nghttp2_session* handle,
                                 const nghttp2_frame* frame,
                                 void* user_data) {
  Http2Session* session = static_cast<Http2Session*>(user_data);
  session->statistics_.frame_count++;
  Debug(session, ""complete frame received: type: %d"",
        frame->hd.type);
  switch (frame->hd.type) {
    case NGHTTP2_DATA:
      return session->HandleDataFrame(frame);
    case NGHTTP2_PUSH_PROMISE:
      // Intentional fall-through, handled just like headers frames
    case NGHTTP2_HEADERS:
      session->HandleHeadersFrame(frame);
      break;
    case NGHTTP2_SETTINGS:
      session->HandleSettingsFrame(frame);
      break;
    case NGHTTP2_PRIORITY:
      session->HandlePriorityFrame(frame);
      break;
    case NGHTTP2_GOAWAY:
      session->HandleGoawayFrame(frame);
      break;
    case NGHTTP2_PING:
      session->HandlePingFrame(frame);
      break;
    case NGHTTP2_ALTSVC:
      session->HandleA...",1,1,node_http2.cc,node.http2.Http2Session.OnFrameReceive,,false,946,983,OnFrameReceive,,,46,"int node.http2.Http2Session.OnFrameReceive (nghttp2_session*,nghttp2_frame*,void*)"
190743,METHOD,node_http2.cc:<global>,TYPE_DECL,"int Http2Session::OnInvalidFrame(nghttp2_session* handle,
                                 const nghttp2_frame* frame,
                                 int lib_error_code,
                                 void* user_data) {
  Http2Session* session = static_cast<Http2Session*>(user_data);
  const uint32_t max_invalid_frames = session->js_fields_->max_invalid_frames;

  Debug(session,
        ""invalid frame received (%u/%u), code: %d"",
        session->invalid_frame_count_,
        max_invalid_frames,
        lib_error_code);
  if (session->invalid_frame_count_++ > max_invalid_frames) {
    session->custom_recv_error_code_ = ""ERR_HTTP2_TOO_MANY_INVALID_FRAMES"";
    return 1;
  }

  // If the error is fatal or if error code is ERR_STREAM_CLOSED... emit error
  if (nghttp2_is_fatal(lib_error_code) ||
      lib_error_code == NGHTTP2_ERR_STREAM_CLOSED) {
    Environment* env = session->env();
    Isolate* isolate = env->isolate();
    HandleScope scope(isolate);
    Local<Context> context...",1,1,node_http2.cc,node.http2.Http2Session.OnInvalidFrame,,false,985,1014,OnInvalidFrame,,,47,"int node.http2.Http2Session.OnInvalidFrame (nghttp2_session*,nghttp2_frame*,int,void*)"
190851,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::DecrefHeaders(const nghttp2_frame* frame) {
  int32_t id = GetFrameID(frame);
  BaseObjectPtr<Http2Stream> stream = FindStream(id);

  if (stream && !stream->is_destroyed() && stream->headers_count() > 0) {
    Debug(this, ""freeing headers for stream %d"", id);
    stream->ClearHeaders();
    CHECK_EQ(stream->headers_count(), 0);
    DecrementCurrentSessionMemory(stream->current_headers_length_);
    stream->current_headers_length_ = 0;
  }
}",1,1,node_http2.cc,node.http2.Http2Session.DecrefHeaders,,false,1018,1029,DecrefHeaders,,,48,void node.http2.Http2Session.DecrefHeaders (nghttp2_frame*)
190908,METHOD,node_http2.cc:<global>,TYPE_DECL,"uint32_t TranslateNghttp2ErrorCode(const int libErrorCode) {
  switch (libErrorCode) {
  case NGHTTP2_ERR_STREAM_CLOSED:
    return NGHTTP2_STREAM_CLOSED;
  case NGHTTP2_ERR_HEADER_COMP:
    return NGHTTP2_COMPRESSION_ERROR;
  case NGHTTP2_ERR_FRAME_SIZE_ERROR:
    return NGHTTP2_FRAME_SIZE_ERROR;
  case NGHTTP2_ERR_FLOW_CONTROL:
    return NGHTTP2_FLOW_CONTROL_ERROR;
  case NGHTTP2_ERR_REFUSED_STREAM:
    return NGHTTP2_REFUSED_STREAM;
  case NGHTTP2_ERR_PROTO:
  case NGHTTP2_ERR_HTTP_HEADER:
  case NGHTTP2_ERR_HTTP_MESSAGING:
    return NGHTTP2_PROTOCOL_ERROR;
  default:
    return NGHTTP2_INTERNAL_ERROR;
  }
}",1,1,node_http2.cc,node.http2.TranslateNghttp2ErrorCode,,false,1031,1050,TranslateNghttp2ErrorCode,,,49,uint32_t node.http2.TranslateNghttp2ErrorCode (int)
190947,METHOD,node_http2.cc:<global>,TYPE_DECL,"int Http2Session::OnFrameNotSent(nghttp2_session* handle,
                                 const nghttp2_frame* frame,
                                 int error_code,
                                 void* user_data) {
  Http2Session* session = static_cast<Http2Session*>(user_data);
  Environment* env = session->env();
  Debug(session, ""frame type %d was not sent, code: %d"",
        frame->hd.type, error_code);

  // Do not report if the frame was not sent due to the session closing
  if (error_code == NGHTTP2_ERR_SESSION_CLOSING ||
      error_code == NGHTTP2_ERR_STREAM_CLOSED ||
      error_code == NGHTTP2_ERR_STREAM_CLOSING) {
    // Nghttp2 contains header limit of 65536. When this value is exceeded the
    // pipeline is stopped and we should remove the current headers reference
    // to destroy the session completely.
    // Further information see: https://github.com/nodejs/node/issues/35233
    session->DecrefHeaders(frame);
    return 0;
  }

  Isolate* isolate = env->iso...",1,1,node_http2.cc,node.http2.Http2Session.OnFrameNotSent,,false,1058,1093,OnFrameNotSent,,,50,"int node.http2.Http2Session.OnFrameNotSent (nghttp2_session*,nghttp2_frame*,int,void*)"
191041,METHOD,node_http2.cc:<global>,TYPE_DECL,"int Http2Session::OnFrameSent(nghttp2_session* handle,
                              const nghttp2_frame* frame,
                              void* user_data) {
  Http2Session* session = static_cast<Http2Session*>(user_data);
  session->statistics_.frame_sent += 1;
  return 0;
}",1,1,node_http2.cc,node.http2.Http2Session.OnFrameSent,,false,1095,1101,OnFrameSent,,,51,"int node.http2.Http2Session.OnFrameSent (nghttp2_session*,nghttp2_frame*,void*)"
191063,METHOD,node_http2.cc:<global>,TYPE_DECL,"int Http2Session::OnStreamClose(nghttp2_session* handle,
                                int32_t id,
                                uint32_t code,
                                void* user_data) {
  Http2Session* session = static_cast<Http2Session*>(user_data);
  Environment* env = session->env();
  Isolate* isolate = env->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env->context();
  Context::Scope context_scope(context);
  Debug(session, ""stream %d closed with code: %d"", id, code);
  BaseObjectPtr<Http2Stream> stream = session->FindStream(id);
  // Intentionally ignore the callback if the stream does not exist or has
  // already been destroyed
  if (!stream || stream->is_destroyed())
    return 0;

  stream->Close(code);

  // It is possible for the stream close to occur before the stream is
  // ever passed on to the javascript side. If that happens, the callback
  // will return false.
  if (env->can_call_into_js()) {
    Local<Value> arg = Integer::New...",1,1,node_http2.cc,node.http2.Http2Session.OnStreamClose,,false,1104,1136,OnStreamClose,,,52,"int node.http2.Http2Session.OnStreamClose (nghttp2_session*,int32_t,uint32_t,void*)"
191194,METHOD,node_http2.cc:<global>,TYPE_DECL,"int Http2Session::OnInvalidHeader(nghttp2_session* session,
                                  const nghttp2_frame* frame,
                                  nghttp2_rcbuf* name,
                                  nghttp2_rcbuf* value,
                                  uint8_t flags,
                                  void* user_data) {
  // Ignore invalid header fields by default.
  return 0;
}",1,1,node_http2.cc,node.http2.Http2Session.OnInvalidHeader,,false,1142,1150,OnInvalidHeader,,,53,"int node.http2.Http2Session.OnInvalidHeader (nghttp2_session*,nghttp2_frame*,nghttp2_rcbuf*,nghttp2_rcbuf*,uint8_t,void*)"
191206,METHOD,node_http2.cc:<global>,TYPE_DECL,"int Http2Session::OnDataChunkReceived(nghttp2_session* handle,
                                      uint8_t flags,
                                      int32_t id,
                                      const uint8_t* data,
                                      size_t len,
                                      void* user_data) {
  Http2Session* session = static_cast<Http2Session*>(user_data);
  Debug(session, ""buffering data chunk for stream %d, size: ""
        ""%d, flags: %d"", id, len, flags);
  Environment* env = session->env();
  HandleScope scope(env->isolate());

  // We should never actually get a 0-length chunk so this check is
  // only a precaution at this point.
  if (len == 0)
    return 0;

  // Notify nghttp2 that we've consumed a chunk of data on the connection
  // so that it can send a WINDOW_UPDATE frame. This is a critical part of
  // the flow control process in http2
  CHECK_EQ(nghttp2_session_consume_connection(handle, len), 0);
  BaseObjectPtr<Http2Stream> str...",1,1,node_http2.cc,node.http2.Http2Session.OnDataChunkReceived,,false,1156,1234,OnDataChunkReceived,,,54,"int node.http2.Http2Session.OnDataChunkReceived (nghttp2_session*,uint8_t,int32_t,uint8_t*,size_t,void*)"
191406,METHOD,node_http2.cc:<global>,TYPE_DECL,"ssize_t Http2Session::OnSelectPadding(nghttp2_session* handle,
                                      const nghttp2_frame* frame,
                                      size_t maxPayloadLen,
                                      void* user_data) {
  Http2Session* session = static_cast<Http2Session*>(user_data);
  ssize_t padding = frame->hd.length;

  switch (session->padding_strategy_) {
    case PADDING_STRATEGY_NONE:
      // Fall-through
      break;
    case PADDING_STRATEGY_MAX:
      padding = session->OnMaxFrameSizePadding(padding, maxPayloadLen);
      break;
    case PADDING_STRATEGY_ALIGNED:
      padding = session->OnDWordAlignedPadding(padding, maxPayloadLen);
      break;
  }
  return padding;
}",1,1,node_http2.cc,node.http2.Http2Session.OnSelectPadding,,false,1238,1257,OnSelectPadding,,,55,"ssize_t node.http2.Http2Session.OnSelectPadding (nghttp2_session*,nghttp2_frame*,size_t,void*)"
191460,METHOD,node_http2.cc:<global>,TYPE_DECL,"int Http2Session::OnNghttpError(nghttp2_session* handle,
                                int lib_error_code,
                                const char* message,
                                size_t len,
                                void* user_data) {
  // Unfortunately, this is currently the only way for us to know if
  // the session errored because the peer is not an http2 peer.
  Http2Session* session = static_cast<Http2Session*>(user_data);
  Debug(session, ""Error '%s'"", message);
  if (lib_error_code == NGHTTP2_ERR_SETTINGS_EXPECTED) {
    Environment* env = session->env();
    Isolate* isolate = env->isolate();
    HandleScope scope(isolate);
    Local<Context> context = env->context();
    Context::Scope context_scope(context);
    Local<Value> arg = Integer::New(isolate, NGHTTP2_ERR_PROTO);
    session->MakeCallback(env->http2session_on_error_function(), 1, &arg);
  }
  return 0;
}",1,1,node_http2.cc,node.http2.Http2Session.OnNghttpError,,false,1261,1280,OnNghttpError,,,56,"int node.http2.Http2Session.OnNghttpError (nghttp2_session*,int,char*,size_t,void*)"
191539,METHOD,node_http2.cc:<global>,TYPE_DECL,"uv_buf_t Http2StreamListener::OnStreamAlloc(size_t size) {
  // See the comments in Http2Session::OnDataChunkReceived
  // (which is the only possible call site for this method).
  return uv_buf_init(nullptr, size);
}",1,1,node_http2.cc,node.http2.Http2StreamListener.OnStreamAlloc,,false,1282,1286,OnStreamAlloc,,,57,uv_buf_t node.http2.Http2StreamListener.OnStreamAlloc (size_t)
191548,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2StreamListener::OnStreamRead(ssize_t nread, const uv_buf_t& buf) {
  Http2Stream* stream = static_cast<Http2Stream*>(stream_);
  Http2Session* session = stream->session();
  Environment* env = stream->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  if (nread < 0) {
    PassReadErrorToPreviousListener(nread);
    return;
  }

  Local<ArrayBuffer> ab;
  if (session->stream_buf_ab_.IsEmpty()) {
    ab = ArrayBuffer::New(env->isolate(),
                          std::move(session->stream_buf_allocation_));
    session->stream_buf_ab_.Reset(env->isolate(), ab);
  } else {
    ab = PersistentToLocal::Strong(session->stream_buf_ab_);
  }

  // There is a single large array buffer for the entire data read from the
  // network; create a slice of that array buffer and emit it as the
  // received data buffer.
  size_t offset = buf.base - session->stream_buf_.base;

  // Verify that the data offset is inside the current read buff...",1,1,node_http2.cc,node.http2.Http2StreamListener.OnStreamRead,,false,1288,1320,OnStreamRead,,,58,"void node.http2.Http2StreamListener.OnStreamRead (ssize_t,uv_buf_t)"
191688,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::HandleHeadersFrame(const nghttp2_frame* frame) {
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);

  int32_t id = GetFrameID(frame);
  Debug(this, ""handle headers frame for stream %d"", id);
  BaseObjectPtr<Http2Stream> stream = FindStream(id);

  // If the stream has already been destroyed, ignore.
  if (!stream || stream->is_destroyed())
    return;

  // The headers are stored as a vector of Http2Header instances.
  // The following converts that into a JS array with the structure:
  // [name1, value1, name2, value2, name3, value3, name3, value4] and so on.
  // That array is passed up to the JS layer and converted into an Object form
  // like {name1: value1, name2: value2, name3: [value3, value4]}. We do it
  // this way for performance reasons (it's faster to generate and pass an
  // array than it is to generate and pass the object).

  MaybeStackBuffer<...",1,1,node_http2.cc,node.http2.Http2Session.HandleHeadersFrame,,false,1326,1373,HandleHeadersFrame,,,59,void node.http2.Http2Session.HandleHeadersFrame (nghttp2_frame*)
191842,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::HandlePriorityFrame(const nghttp2_frame* frame) {
  if (js_fields_->priority_listener_count == 0) return;
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);

  nghttp2_priority priority_frame = frame->priority;
  int32_t id = GetFrameID(frame);
  Debug(this, ""handle priority frame for stream %d"", id);
  // Priority frame stream ID should never be <= 0. nghttp2 handles this for us
  nghttp2_priority_spec spec = priority_frame.pri_spec;

  Local<Value> argv[4] = {
    Integer::New(isolate, id),
    Integer::New(isolate, spec.stream_id),
    Integer::New(isolate, spec.weight),
    Boolean::New(isolate, spec.exclusive)
  };
  MakeCallback(env()->http2session_on_priority_function(),
               arraysize(argv), argv);
}",1,1,node_http2.cc,node.http2.Http2Session.HandlePriorityFrame,,false,1380,1401,HandlePriorityFrame,,,60,void node.http2.Http2Session.HandlePriorityFrame (nghttp2_frame*)
191915,METHOD,node_http2.cc:<global>,TYPE_DECL,"int Http2Session::HandleDataFrame(const nghttp2_frame* frame) {
  int32_t id = GetFrameID(frame);
  Debug(this, ""handling data frame for stream %d"", id);
  BaseObjectPtr<Http2Stream> stream = FindStream(id);

  if (stream &&
      !stream->is_destroyed() &&
      frame->hd.flags & NGHTTP2_FLAG_END_STREAM) {
    stream->EmitRead(UV_EOF);
  } else if (frame->hd.length == 0) {
    if (invalid_frame_count_++ > js_fields_->max_invalid_frames) {
      custom_recv_error_code_ = ""ERR_HTTP2_TOO_MANY_INVALID_FRAMES"";
      Debug(this, ""rejecting empty-frame-without-END_STREAM flood\n"");
      // Consider a flood of 0-length frames without END_STREAM an error.
      return 1;
    }
  }
  return 0;
}",1,1,node_http2.cc,node.http2.Http2Session.HandleDataFrame,,false,1407,1425,HandleDataFrame,,,61,int node.http2.Http2Session.HandleDataFrame (nghttp2_frame*)
191988,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::HandleGoawayFrame(const nghttp2_frame* frame) {
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);

  nghttp2_goaway goaway_frame = frame->goaway;
  Debug(this, ""handling goaway frame"");

  Local<Value> argv[3] = {
    Integer::NewFromUnsigned(isolate, goaway_frame.error_code),
    Integer::New(isolate, goaway_frame.last_stream_id),
    Undefined(isolate)
  };

  size_t length = goaway_frame.opaque_data_len;
  if (length > 0) {
    // If the copy fails for any reason here, we just ignore it.
    // The additional goaway data is completely optional and we
    // shouldn't fail if we're not able to process it.
    argv[2] = Buffer::Copy(isolate,
                           reinterpret_cast<char*>(goaway_frame.opaque_data),
                           length).ToLocalChecked();
  }

  MakeCallback(env()->http2session_on_goaway_data_function(),
               arraysize...",1,1,node_http2.cc,node.http2.Http2Session.HandleGoawayFrame,,false,1429,1456,HandleGoawayFrame,,,62,void node.http2.Http2Session.HandleGoawayFrame (nghttp2_frame*)
192070,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::HandleAltSvcFrame(const nghttp2_frame* frame) {
  if (!(js_fields_->bitfield & (1 << kSessionHasAltsvcListeners))) return;
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);

  int32_t id = GetFrameID(frame);

  nghttp2_extension ext = frame->ext;
  nghttp2_ext_altsvc* altsvc = static_cast<nghttp2_ext_altsvc*>(ext.payload);
  Debug(this, ""handling altsvc frame"");

  Local<Value> argv[3] = {
    Integer::New(isolate, id),
    OneByteString(isolate, altsvc->origin, altsvc->origin_len),
    OneByteString(isolate, altsvc->field_value, altsvc->field_value_len)
  };

  MakeCallback(env()->http2session_on_altsvc_function(),
               arraysize(argv), argv);
}",1,1,node_http2.cc,node.http2.Http2Session.HandleAltSvcFrame,,false,1459,1480,HandleAltSvcFrame,,,63,void node.http2.Http2Session.HandleAltSvcFrame (nghttp2_frame*)
192147,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::HandleOriginFrame(const nghttp2_frame* frame) {
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);

  Debug(this, ""handling origin frame"");

  nghttp2_extension ext = frame->ext;
  nghttp2_ext_origin* origin = static_cast<nghttp2_ext_origin*>(ext.payload);

  size_t nov = origin->nov;
  std::vector<Local<Value>> origin_v(nov);

  for (size_t i = 0; i < nov; ++i) {
    const nghttp2_origin_entry& entry = origin->ov[i];
    origin_v[i] = OneByteString(isolate, entry.origin, entry.origin_len);
  }
  Local<Value> holder = Array::New(isolate, origin_v.data(), origin_v.size());
  MakeCallback(env()->http2session_on_origin_function(), 1, &holder);
}",1,1,node_http2.cc,node.http2.Http2Session.HandleOriginFrame,,false,1482,1502,HandleOriginFrame,,,64,void node.http2.Http2Session.HandleOriginFrame (nghttp2_frame*)
192267,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::HandlePingFrame(const nghttp2_frame* frame) {
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);
  Local<Value> arg;
  bool ack = frame->hd.flags & NGHTTP2_FLAG_ACK;
  if (ack) {
    BaseObjectPtr<Http2Ping> ping = PopPing();

    if (!ping) {
      // PING Ack is unsolicited. Treat as a connection error. The HTTP/2
      // spec does not require this, but there is no legitimate reason to
      // receive an unsolicited PING ack on a connection. Either the peer
      // is buggy or malicious, and we're not going to tolerate such
      // nonsense.
      arg = Integer::New(isolate, NGHTTP2_ERR_PROTO);
      MakeCallback(env()->http2session_on_error_function(), 1, &arg);
      return;
    }

    ping->Done(true, frame->ping.opaque_data);
    return;
  }

  if (!(js_fields_->bitfield & (1 << kSessionHasPingListeners))) return;
  // Notify the session that a ping oc...",1,1,node_http2.cc,node.http2.Http2Session.HandlePingFrame,,false,1505,1537,HandlePingFrame,,,65,void node.http2.Http2Session.HandlePingFrame (nghttp2_frame*)
192389,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::HandleSettingsFrame(const nghttp2_frame* frame) {
  bool ack = frame->hd.flags & NGHTTP2_FLAG_ACK;
  if (!ack) {
    js_fields_->bitfield &= ~(1 << kSessionRemoteSettingsIsUpToDate);
    if (!(js_fields_->bitfield & (1 << kSessionHasRemoteSettingsListeners)))
      return;
    // This is not a SETTINGS acknowledgement, notify and return
    MakeCallback(env()->http2session_on_settings_function(), 0, nullptr);
    return;
  }

  // If this is an acknowledgement, we should have an Http2Settings
  // object for it.
  BaseObjectPtr<Http2Settings> settings = PopSettings();
  if (settings) {
    settings->Done(true);
    return;
  }
  // SETTINGS Ack is unsolicited. Treat as a connection error. The HTTP/2
  // spec does not require this, but there is no legitimate reason to
  // receive an unsolicited SETTINGS ack on a connection. Either the peer
  // is buggy or malicious, and we're not going to tolerate such
  // nonsense.
  // Note that nghttp2 currently prevents thi...",1,1,node_http2.cc,node.http2.Http2Session.HandleSettingsFrame,,false,1540,1573,HandleSettingsFrame,,,66,void node.http2.Http2Session.HandleSettingsFrame (nghttp2_frame*)
192494,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::OnStreamAfterWrite(WriteWrap* w, int status) {
  Debug(this, ""write finished with status %d"", status);

  CHECK(is_write_in_progress());
  set_write_in_progress(false);

  // Inform all pending writes about their completion.
  ClearOutgoing(status);

  if (is_reading_stopped() &&
      !is_write_in_progress() &&
      nghttp2_session_want_read(session_.get())) {
    set_reading_stopped(false);
    stream_->ReadStart();
  }

  if (is_destroyed()) {
    HandleScope scope(env()->isolate());
    MakeCallback(env()->ondone_string(), 0, nullptr);
    if (stream_ != nullptr) {
      // Start reading again to detect the other end finishing.
      set_reading_stopped(false);
      stream_->ReadStart();
    }
    return;
  }

  // If there is more incoming data queued up, consume it.
  if (stream_buf_offset_ > 0) {
    ConsumeHTTP2Data();
  }

  if (!is_write_scheduled() && !is_destroyed()) {
    // Schedule a new write if nghttp2 wants to send data.
    MaybeScheduleWrite(...",1,1,node_http2.cc,node.http2.Http2Session.OnStreamAfterWrite,,false,1576,1612,OnStreamAfterWrite,,,67,"void node.http2.Http2Session.OnStreamAfterWrite (WriteWrap*,int)"
192569,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::MaybeScheduleWrite() {
  CHECK(!is_write_scheduled());
  if (UNLIKELY(!session_))
    return;

  if (nghttp2_session_want_write(session_.get())) {
    HandleScope handle_scope(env()->isolate());
    Debug(this, ""scheduling write"");
    set_write_scheduled();
    BaseObjectPtr<Http2Session> strong_ref{this};
    env()->SetImmediate([this, strong_ref](Environment* env) {
      if (!session_ || !is_write_scheduled()) {
        // This can happen e.g. when a stream was reset before this turn
        // of the event loop, in which case SendPendingData() is called early,
        // or the session was destroyed in the meantime.
        return;
      }

      // Sending data may call arbitrary JS code, so keep track of
      // async context.
      if (env->can_call_into_js()) {
        HandleScope handle_scope(env->isolate());
        InternalCallbackScope callback_scope(this);
        SendPendingData();
      }
    });
  }
}",1,1,node_http2.cc,node.http2.Http2Session.MaybeScheduleWrite,,false,1618,1645,MaybeScheduleWrite,,,68,void node.http2.Http2Session.MaybeScheduleWrite ()
192611,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::MaybeStopReading() {
  // If the session is already closing we don't want to stop reading as we want
  // to detect when the other peer is actually closed.
  if (is_reading_stopped() || is_closing()) return;
  int want_read = nghttp2_session_want_read(session_.get());
  Debug(this, ""wants read? %d"", want_read);
  if (want_read == 0 || is_write_in_progress()) {
    set_reading_stopped();
    stream_->ReadStop();
  }
}",1,1,node_http2.cc,node.http2.Http2Session.MaybeStopReading,,false,1647,1657,MaybeStopReading,,,69,void node.http2.Http2Session.MaybeStopReading ()
192645,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::ClearOutgoing(int status) {
  CHECK(is_sending());

  set_sending(false);

  if (!outgoing_buffers_.empty()) {
    outgoing_storage_.clear();
    outgoing_length_ = 0;

    std::vector<NgHttp2StreamWrite> current_outgoing_buffers_;
    current_outgoing_buffers_.swap(outgoing_buffers_);
    for (const NgHttp2StreamWrite& wr : current_outgoing_buffers_) {
      BaseObjectPtr<AsyncWrap> wrap = std::move(wr.req_wrap);
      if (wrap) {
        // TODO(addaleax): Pass `status` instead of 0, so that we actually error
        // out with the error from the write to the underlying protocol,
        // if one occurred.
        WriteWrap::FromObject(wrap)->Done(0);
      }
    }
  }

  // Now that we've finished sending queued data, if there are any pending
  // RstStreams we should try sending again and then flush them one by one.
  if (!pending_rst_streams_.empty()) {
    std::vector<int32_t> current_pending_rst_streams;
    pending_rst_streams_.swap(current_pending_rst_s...",1,1,node_http2.cc,node.http2.Http2Session.ClearOutgoing,,false,1661,1697,ClearOutgoing,,,70,void node.http2.Http2Session.ClearOutgoing (int)
192748,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::PushOutgoingBuffer(NgHttp2StreamWrite&& write) {
  outgoing_length_ += write.buf.len;
  outgoing_buffers_.emplace_back(std::move(write));
}",1,1,node_http2.cc,node.http2.Http2Session.PushOutgoingBuffer,,false,1699,1702,PushOutgoingBuffer,,,71,void node.http2.Http2Session.PushOutgoingBuffer (NgHttp2StreamWrite)
192769,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::CopyDataIntoOutgoing(const uint8_t* src, size_t src_length) {
  size_t offset = outgoing_storage_.size();
  outgoing_storage_.resize(offset + src_length);
  memcpy(&outgoing_storage_[offset], src, src_length);

  // Store with a base of `nullptr` initially, since future resizes
  // of the outgoing_buffers_ vector may invalidate the pointer.
  // The correct base pointers will be set later, before writing to the
  // underlying socket.
  PushOutgoingBuffer(NgHttp2StreamWrite {
    uv_buf_init(nullptr, src_length)
  });
}",1,1,node_http2.cc,node.http2.Http2Session.CopyDataIntoOutgoing,,false,1707,1719,CopyDataIntoOutgoing,,,72,"void node.http2.Http2Session.CopyDataIntoOutgoing (uint8_t*,size_t)"
192802,METHOD,node_http2.cc:<global>,TYPE_DECL,"uint8_t Http2Session::SendPendingData() {
  Debug(this, ""sending pending data"");
  // Do not attempt to send data on the socket if the destroying flag has
  // been set. That means everything is shutting down and the socket
  // will not be usable.
  if (is_destroyed())
    return 0;
  set_write_scheduled(false);

  // SendPendingData should not be called recursively.
  if (is_sending())
    return 1;
  // This is cleared by ClearOutgoing().
  set_sending();

  ssize_t src_length;
  const uint8_t* src;

  CHECK(outgoing_buffers_.empty());
  CHECK(outgoing_storage_.empty());

  // Part One: Gather data from nghttp2

  while ((src_length = nghttp2_session_mem_send(session_.get(), &src)) > 0) {
    Debug(this, ""nghttp2 has %d bytes to send"", src_length);
    CopyDataIntoOutgoing(src, src_length);
  }

  CHECK_NE(src_length, NGHTTP2_ERR_NOMEM);

  if (stream_ == nullptr) {
    // It would seem nice to bail out earlier, but `nghttp2_session_mem_send()`
    // does take care of things lik...",1,1,node_http2.cc,node.http2.Http2Session.SendPendingData,,false,1726,1804,SendPendingData,,,73,uint8_t node.http2.Http2Session.SendPendingData ()
192990,METHOD,node_http2.cc:<global>,TYPE_DECL,"int Http2Session::OnSendData(
      nghttp2_session* session_,
      nghttp2_frame* frame,
      const uint8_t* framehd,
      size_t length,
      nghttp2_data_source* source,
      void* user_data) {
  Http2Session* session = static_cast<Http2Session*>(user_data);
  BaseObjectPtr<Http2Stream> stream = session->FindStream(frame->hd.stream_id);
  if (!stream) return 0;

  // Send the frame header + a byte that indicates padding length.
  session->CopyDataIntoOutgoing(framehd, 9);
  if (frame->data.padlen > 0) {
    uint8_t padding_byte = frame->data.padlen - 1;
    CHECK_EQ(padding_byte, frame->data.padlen - 1);
    session->CopyDataIntoOutgoing(&padding_byte, 1);
  }

  Debug(session, ""nghttp2 has %d bytes to send directly"", length);
  while (length > 0) {
    // nghttp2 thinks that there is data available (length > 0), which means
    // we told it so, which means that we *should* have data available.
    CHECK(!stream->queue_.empty());

    NgHttp2StreamWrite& write = stream->que...",1,1,node_http2.cc,node.http2.Http2Session.OnSendData,,false,1811,1862,OnSendData,,,74,"int node.http2.Http2Session.OnSendData (nghttp2_session*,nghttp2_frame*,uint8_t*,size_t,nghttp2_data_source*,void*)"
193182,METHOD,node_http2.cc:<global>,TYPE_DECL,"Http2Stream* Http2Session::SubmitRequest(
    const Http2Priority& priority,
    const Http2Headers& headers,
    int32_t* ret,
    int options) {
  Debug(this, ""submitting request"");
  Http2Scope h2scope(this);
  Http2Stream* stream = nullptr;
  Http2Stream::Provider::Stream prov(options);
  *ret = nghttp2_submit_request(
      session_.get(),
      &priority,
      headers.data(),
      headers.length(),
      *prov,
      nullptr);
  CHECK_NE(*ret, NGHTTP2_ERR_NOMEM);
  if (LIKELY(*ret > 0))
    stream = Http2Stream::New(this, *ret, NGHTTP2_HCAT_HEADERS, options);
  return stream;
}",1,1,node_http2.cc,node.http2.Http2Session.SubmitRequest,,false,1865,1885,SubmitRequest,,,75,"Http2Stream node.http2.Http2Session.SubmitRequest (Http2Priority,Http2Headers,int32_t*,int)"
193248,METHOD,node_http2.cc:<global>,TYPE_DECL,"uv_buf_t Http2Session::OnStreamAlloc(size_t suggested_size) {
  return env()->allocate_managed_buffer(suggested_size);
}",1,1,node_http2.cc,node.http2.Http2Session.OnStreamAlloc,,false,1887,1889,OnStreamAlloc,,,76,uv_buf_t node.http2.Http2Session.OnStreamAlloc (size_t)
193259,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::OnStreamRead(ssize_t nread, const uv_buf_t& buf_) {
  HandleScope handle_scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  Http2Scope h2scope(this);
  CHECK_NOT_NULL(stream_);
  Debug(this, ""receiving %d bytes, offset %d"", nread, stream_buf_offset_);
  std::unique_ptr<BackingStore> bs = env()->release_managed_buffer(buf_);

  // Only pass data on if nread > 0
  if (nread <= 0) {
    if (nread < 0) {
      PassReadErrorToPreviousListener(nread);
    }
    return;
  }

  CHECK_LE(static_cast<size_t>(nread), bs->ByteLength());

  statistics_.data_received += nread;

  if (LIKELY(stream_buf_offset_ == 0)) {
    // Shrink to the actual amount of used data.
    bs = BackingStore::Reallocate(env()->isolate(), std::move(bs), nread);
  } else {
    // This is a very unlikely case, and should only happen if the ReadStart()
    // call in OnStreamAfterWrite() immediately provides data. If that does
    // happen, we concatenate the data we received...",1,1,node_http2.cc,node.http2.Http2Session.OnStreamRead,,false,1892,1959,OnStreamRead,,,77,"void node.http2.Http2Session.OnStreamRead (ssize_t,uv_buf_t)"
193458,METHOD,node_http2.cc:<global>,TYPE_DECL,"bool Http2Session::HasWritesOnSocketForStream(Http2Stream* stream) {
  for (const NgHttp2StreamWrite& wr : outgoing_buffers_) {
    if (wr.req_wrap && WriteWrap::FromObject(wr.req_wrap)->stream() == stream)
      return true;
  }
  return false;
}",1,1,node_http2.cc,node.http2.Http2Session.HasWritesOnSocketForStream,,false,1961,1967,HasWritesOnSocketForStream,,,78,bool node.http2.Http2Session.HasWritesOnSocketForStream (Http2Stream*)
193489,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::Consume(Local<Object> stream_obj) {
  StreamBase* stream = StreamBase::FromObject(stream_obj);
  stream->PushStreamListener(this);
  Debug(this, ""i/o stream consumed"");
}",1,1,node_http2.cc,node.http2.Http2Session.Consume,,false,1973,1977,Consume,,,79,void node.http2.Http2Session.Consume (Local<Object>)
193510,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::Receive(const FunctionCallbackInfo<Value>& args) {
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  CHECK(args[0]->IsObject());

  ArrayBufferViewContents<char> buffer(args[0]);
  const char* data = buffer.data();
  size_t len = buffer.length();
  Debug(session, ""Receiving %zu bytes injected from JS"", len);

  // Copy given buffer
  while (len > 0) {
    uv_buf_t buf = session->OnStreamAlloc(len);
    size_t copy = buf.len > len ? len : buf.len;
    memcpy(buf.base, data, copy);
    buf.len = copy;
    session->OnStreamRead(copy, buf);

    data += copy;
    len -= copy;
  }
}",1,1,node_http2.cc,node.http2.Http2Session.Receive,,false,1983,2004,Receive,,,80,void node.http2.Http2Session.Receive (FunctionCallbackInfo<Value>)
193602,METHOD,node_http2.cc:<global>,TYPE_DECL,"Http2Stream* Http2Stream::New(Http2Session* session,
                              int32_t id,
                              nghttp2_headers_category category,
                              int options) {
  Local<Object> obj;
  if (!session->env()
           ->http2stream_constructor_template()
           ->NewInstance(session->env()->context())
           .ToLocal(&obj)) {
    return nullptr;
  }
  return new Http2Stream(session, obj, id, category, options);
}",1,1,node_http2.cc,node.http2.Http2Stream.New,,false,2006,2018,New,,,81,"Http2Stream node.http2.Http2Stream.New (Http2Session*,int32_t,nghttp2_headers_category,int)"
193650,METHOD,node_http2.cc:<global>,TYPE_DECL,"Http2Stream::Http2Stream(Http2Session* session,
                         Local<Object> obj,
                         int32_t id,
                         nghttp2_headers_category category,
                         int options)
    : AsyncWrap(session->env(), obj, AsyncWrap::PROVIDER_HTTP2STREAM),
      StreamBase(session->env()),
      session_(session),
      id_(id),
      current_headers_category_(category) {
  MakeWeak();
  StreamBase::AttachToObject(GetObject());
  statistics_.id = id;
  statistics_.start_time = uv_hrtime();

  // Limit the number of header pairs
  max_header_pairs_ = session->max_header_pairs();
  if (max_header_pairs_ == 0) {
    max_header_pairs_ = DEFAULT_MAX_HEADER_LIST_PAIRS;
  }
  current_headers_.reserve(std::min(max_header_pairs_, 12u));

  // Limit the number of header octets
  max_header_length_ =
      std::min(
        nghttp2_session_get_local_settings(
          session->session(),
          NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE),
      MAX_MAX_H...",1,1,node_http2.cc,node.http2.Http2Stream.Http2Stream,,false,2020,2058,Http2Stream,,,82,"ANY node.http2.Http2Stream.Http2Stream (Http2Session*,Local<Object>,int32_t,nghttp2_headers_category,int)"
193726,METHOD,node_http2.cc:<global>,TYPE_DECL,"Http2Stream::~Http2Stream() {
  Debug(this, ""tearing down stream"");
}",1,1,node_http2.cc,node.http2.Http2Stream.~Http2Stream,,false,2060,2062,~Http2Stream,,,83,ANY node.http2.Http2Stream.~Http2Stream ()
193733,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Stream::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""current_headers"", current_headers_);
  tracker->TrackField(""queue"", queue_);
}",1,1,node_http2.cc,node.http2.Http2Stream.MemoryInfo,,false,2064,2067,MemoryInfo,,,84,void node.http2.Http2Stream.MemoryInfo (MemoryTracker*)
193750,METHOD,node_http2.cc:<global>,TYPE_DECL,"std::string Http2Stream::diagnostic_name() const {
  const Http2Session* sess = session();
  const std::string sname =
      sess ? sess->diagnostic_name() : ""session already destroyed"";
  return ""HttpStream "" + std::to_string(id()) + "" ("" +
         std::to_string(static_cast<int64_t>(get_async_id())) + "") ["" + sname +
         ""]"";
}",1,1,node_http2.cc,node.http2.Http2Stream.diagnostic_name,,false,2069,2076,diagnostic_name,,,85,string node.http2.Http2Stream.diagnostic_name ()
193792,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Stream::StartHeaders(nghttp2_headers_category category) {
  Debug(this, ""starting headers, category: %d"", category);
  CHECK(!this->is_destroyed());
  session_->DecrementCurrentSessionMemory(current_headers_length_);
  current_headers_length_ = 0;
  current_headers_.clear();
  current_headers_category_ = category;
}",1,1,node_http2.cc,node.http2.Http2Stream.StartHeaders,,false,2079,2086,StartHeaders,,,86,void node.http2.Http2Stream.StartHeaders (nghttp2_headers_category)
193822,METHOD,node_http2.cc:<global>,TYPE_DECL,nghttp2_stream* Http2Stream::operator*() const { return stream(); },1,67,node_http2.cc,node.http2.Http2Stream.operator *,,false,2089,2089,operator *,,,87,nghttp2_stream node.http2.Http2Stream.operator * ()
193828,METHOD,node_http2.cc:<global>,TYPE_DECL,"nghttp2_stream* Http2Stream::stream() const {
  return nghttp2_session_find_stream(session_->session(), id_);
}",1,1,node_http2.cc,node.http2.Http2Stream.stream,,false,2091,2093,stream,,,88,nghttp2_stream node.http2.Http2Stream.stream ()
193839,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Stream::Close(int32_t code) {
  CHECK(!this->is_destroyed());
  set_closed();
  code_ = code;
  Debug(this, ""closed with code %d"", code);
}",1,1,node_http2.cc,node.http2.Http2Stream.Close,,false,2095,2100,Close,,,89,void node.http2.Http2Stream.Close (int32_t)
193858,METHOD,node_http2.cc:<global>,TYPE_DECL,"ShutdownWrap* Http2Stream::CreateShutdownWrap(Local<Object> object) {
  // DoShutdown() always finishes synchronously, so there's no need to create
  // a structure to store asynchronous context.
  return nullptr;
}",1,1,node_http2.cc,node.http2.Http2Stream.CreateShutdownWrap,,false,2102,2106,CreateShutdownWrap,,,90,ShutdownWrap node.http2.Http2Stream.CreateShutdownWrap (Local<Object>)
193865,METHOD,node_http2.cc:<global>,TYPE_DECL,"int Http2Stream::DoShutdown(ShutdownWrap* req_wrap) {
  if (is_destroyed())
    return UV_EPIPE;

  {
    Http2Scope h2scope(this);
    set_not_writable();
    CHECK_NE(nghttp2_session_resume_data(
        session_->session(), id_),
        NGHTTP2_ERR_NOMEM);
    Debug(this, ""writable side shutdown"");
  }
  return 1;
}",1,1,node_http2.cc,node.http2.Http2Stream.DoShutdown,,false,2108,2121,DoShutdown,,,91,int node.http2.Http2Stream.DoShutdown (ShutdownWrap*)
193893,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Stream::Destroy() {
  // Do nothing if this stream instance is already destroyed
  if (is_destroyed())
    return;
  if (session_->has_pending_rststream(id_))
    FlushRstStream();
  set_destroyed();

  Debug(this, ""destroying stream"");

  // Wait until the start of the next loop to delete because there
  // may still be some pending operations queued for this stream.
  BaseObjectPtr<Http2Stream> strong_ref = session_->RemoveStream(id_);
  if (strong_ref) {
    env()->SetImmediate([this, strong_ref = std::move(strong_ref)](
        Environment* env) {
      // Free any remaining outgoing data chunks here. This should be done
      // here because it's possible for destroy to have been called while
      // we still have queued outbound writes.
      while (!queue_.empty()) {
        NgHttp2StreamWrite& head = queue_.front();
        if (head.req_wrap)
          WriteWrap::FromObject(head.req_wrap)->Done(UV_ECANCELED);
        queue_.pop();
      }

      // We can destroy ...",1,1,node_http2.cc,node.http2.Http2Stream.Destroy,,false,2126,2168,Destroy,,,92,void node.http2.Http2Stream.Destroy ()
193959,METHOD,node_http2.cc:<global>,TYPE_DECL,"int Http2Stream::SubmitResponse(const Http2Headers& headers, int options) {
  CHECK(!this->is_destroyed());
  Http2Scope h2scope(this);
  Debug(this, ""submitting response"");
  if (options & STREAM_OPTION_GET_TRAILERS)
    set_has_trailers();

  if (!is_writable())
    options |= STREAM_OPTION_EMPTY_PAYLOAD;

  Http2Stream::Provider::Stream prov(this, options);
  int ret = nghttp2_submit_response(
      session_->session(),
      id_,
      headers.data(),
      headers.length(),
      *prov);
  CHECK_NE(ret, NGHTTP2_ERR_NOMEM);
  return ret;
}",1,1,node_http2.cc,node.http2.Http2Stream.SubmitResponse,,false,2173,2192,SubmitResponse,,,93,"int node.http2.Http2Stream.SubmitResponse (Http2Headers,int)"
194018,METHOD,node_http2.cc:<global>,TYPE_DECL,"int Http2Stream::SubmitInfo(const Http2Headers& headers) {
  CHECK(!this->is_destroyed());
  Http2Scope h2scope(this);
  Debug(this, ""sending %d informational headers"", headers.length());
  int ret = nghttp2_submit_headers(
      session_->session(),
      NGHTTP2_FLAG_NONE,
      id_,
      nullptr,
      headers.data(),
      headers.length(),
      nullptr);
  CHECK_NE(ret, NGHTTP2_ERR_NOMEM);
  return ret;
}",1,1,node_http2.cc,node.http2.Http2Stream.SubmitInfo,,false,2196,2210,SubmitInfo,,,94,int node.http2.Http2Stream.SubmitInfo (Http2Headers)
194064,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Stream::OnTrailers() {
  Debug(this, ""let javascript know we are ready for trailers"");
  CHECK(!this->is_destroyed());
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);
  set_has_trailers(false);
  MakeCallback(env()->http2session_on_stream_trailers_function(), 0, nullptr);
}",1,1,node_http2.cc,node.http2.Http2Stream.OnTrailers,,false,2212,2221,OnTrailers,,,95,void node.http2.Http2Stream.OnTrailers ()
194109,METHOD,node_http2.cc:<global>,TYPE_DECL,"int Http2Stream::SubmitTrailers(const Http2Headers& headers) {
  CHECK(!this->is_destroyed());
  Http2Scope h2scope(this);
  Debug(this, ""sending %d trailers"", headers.length());
  int ret;
  // Sending an empty trailers frame poses problems in Safari, Edge & IE.
  // Instead we can just send an empty data frame with NGHTTP2_FLAG_END_STREAM
  // to indicate that the stream is ready to be closed.
  if (headers.length() == 0) {
    Http2Stream::Provider::Stream prov(this, 0);
    ret = nghttp2_submit_data(
        session_->session(),
        NGHTTP2_FLAG_END_STREAM,
        id_,
        *prov);
  } else {
    ret = nghttp2_submit_trailer(
        session_->session(),
        id_,
        headers.data(),
        headers.length());
  }
  CHECK_NE(ret, NGHTTP2_ERR_NOMEM);
  return ret;
}",1,1,node_http2.cc,node.http2.Http2Stream.SubmitTrailers,,false,2224,2248,SubmitTrailers,,,96,int node.http2.Http2Stream.SubmitTrailers (Http2Headers)
194177,METHOD,node_http2.cc:<global>,TYPE_DECL,"int Http2Stream::SubmitPriority(const Http2Priority& priority,
                                bool silent) {
  CHECK(!this->is_destroyed());
  Http2Scope h2scope(this);
  Debug(this, ""sending priority spec"");
  int ret = silent ?
      nghttp2_session_change_stream_priority(
          session_->session(),
          id_,
          &priority) :
      nghttp2_submit_priority(
          session_->session(),
          NGHTTP2_FLAG_NONE,
          id_, &priority);
  CHECK_NE(ret, NGHTTP2_ERR_NOMEM);
  return ret;
}",1,1,node_http2.cc,node.http2.Http2Stream.SubmitPriority,,false,2251,2267,SubmitPriority,,,97,"int node.http2.Http2Stream.SubmitPriority (Http2Priority,bool)"
194222,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Stream::SubmitRstStream(const uint32_t code) {
  CHECK(!this->is_destroyed());
  code_ = code;

  auto is_stream_cancel = [](const uint32_t code) {
    return code == NGHTTP2_CANCEL;
  };

  // If RST_STREAM frame is received with error code NGHTTP2_CANCEL,
  // add it to the pending list and don't force purge the data. It is
  // to avoids the double free error due to unwanted behavior of nghttp2.

  // Add stream to the pending list only if it is received with scope
  // below in the stack. The pending list may not get processed
  // if RST_STREAM received is not in scope and added to the list
  // causing endpoint to hang.
  if (session_->is_in_scope() && is_stream_cancel(code)) {
      session_->AddPendingRstStream(id_);
      return;
  }


  // If possible, force a purge of any currently pending data here to make sure
  // it is sent before closing the stream. If it returns non-zero then we need
  // to wait until the current write finishes and try again to avoid nght...",1,1,node_http2.cc,node.http2.Http2Stream.SubmitRstStream,,false,2271,2303,SubmitRstStream,,,98,void node.http2.Http2Stream.SubmitRstStream (uint32_t)
194269,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Stream::FlushRstStream() {
  if (is_destroyed())
    return;
  Http2Scope h2scope(this);
  CHECK_EQ(nghttp2_submit_rst_stream(
      session_->session(),
      NGHTTP2_FLAG_NONE,
      id_,
      code_), 0);
}",1,1,node_http2.cc,node.http2.Http2Stream.FlushRstStream,,false,2305,2314,FlushRstStream,,,99,void node.http2.Http2Stream.FlushRstStream ()
194290,METHOD,node_http2.cc:<global>,TYPE_DECL,"Http2Stream* Http2Stream::SubmitPushPromise(const Http2Headers& headers,
                                            int32_t* ret,
                                            int options) {
  CHECK(!this->is_destroyed());
  Http2Scope h2scope(this);
  Debug(this, ""sending push promise"");
  *ret = nghttp2_submit_push_promise(
      session_->session(),
      NGHTTP2_FLAG_NONE,
      id_,
      headers.data(),
      headers.length(),
      nullptr);
  CHECK_NE(*ret, NGHTTP2_ERR_NOMEM);
  Http2Stream* stream = nullptr;
  if (*ret > 0) {
    stream = Http2Stream::New(
        session_.get(), *ret, NGHTTP2_HCAT_HEADERS, options);
  }

  return stream;
}",1,1,node_http2.cc,node.http2.Http2Stream.SubmitPushPromise,,false,2318,2339,SubmitPushPromise,,,100,"Http2Stream node.http2.Http2Stream.SubmitPushPromise (Http2Headers,int32_t*,int)"
194358,METHOD,node_http2.cc:<global>,TYPE_DECL,"int Http2Stream::ReadStart() {
  Http2Scope h2scope(this);
  CHECK(!this->is_destroyed());
  set_reading();

  Debug(this, ""reading starting"");

  // Tell nghttp2 about our consumption of the data that was handed
  // off to JS land.
  nghttp2_session_consume_stream(
      session_->session(),
      id_,
      inbound_consumed_data_while_paused_);
  inbound_consumed_data_while_paused_ = 0;

  return 0;
}",1,1,node_http2.cc,node.http2.Http2Stream.ReadStart,,false,2343,2359,ReadStart,,,101,int node.http2.Http2Stream.ReadStart ()
194387,METHOD,node_http2.cc:<global>,TYPE_DECL,"int Http2Stream::ReadStop() {
  CHECK(!this->is_destroyed());
  if (!is_reading())
    return 0;
  set_paused();
  Debug(this, ""reading stopped"");
  return 0;
}",1,1,node_http2.cc,node.http2.Http2Stream.ReadStop,,false,2362,2369,ReadStop,,,102,int node.http2.Http2Stream.ReadStop ()
194409,METHOD,node_http2.cc:<global>,TYPE_DECL,"int Http2Stream::DoWrite(WriteWrap* req_wrap,
                         uv_buf_t* bufs,
                         size_t nbufs,
                         uv_stream_t* send_handle) {
  CHECK_NULL(send_handle);
  Http2Scope h2scope(this);
  if (!is_writable() || is_destroyed()) {
    return UV_EOF;
  }
  Debug(this, ""queuing %d buffers to send"", nbufs);
  for (size_t i = 0; i < nbufs; ++i) {
    // Store the req_wrap on the last write info in the queue, so that it is
    // only marked as finished once all buffers associated with it are finished.
    queue_.emplace(NgHttp2StreamWrite {
      BaseObjectPtr<AsyncWrap>(
          i == nbufs - 1 ? req_wrap->GetAsyncWrap() : nullptr),
      bufs[i]
    });
    IncrementAvailableOutboundLength(bufs[i].len);
  }
  CHECK_NE(nghttp2_session_resume_data(
      session_->session(),
      id_), NGHTTP2_ERR_NOMEM);
  return 0;
}",1,1,node_http2.cc,node.http2.Http2Stream.DoWrite,,false,2381,2405,DoWrite,,,103,"int node.http2.Http2Stream.DoWrite (WriteWrap*,uv_buf_t*,size_t,uv_stream_t*)"
194486,METHOD,node_http2.cc:<global>,TYPE_DECL,"bool Http2Stream::AddHeader(nghttp2_rcbuf* name,
                            nghttp2_rcbuf* value,
                            uint8_t flags) {
  CHECK(!this->is_destroyed());

  if (Http2RcBufferPointer::IsZeroLength(name))
    return true;  // Ignore empty headers.

  Http2Header header(env(), name, value, flags);
  size_t length = header.length() + 32;
  // A header can only be added if we have not exceeded the maximum number
  // of headers and the session has memory available for it.
  if (!session_->has_available_session_memory(length) ||
      current_headers_.size() == max_header_pairs_ ||
      current_headers_length_ + length > max_header_length_) {
    return false;
  }

  if (statistics_.first_header == 0)
    statistics_.first_header = uv_hrtime();

  current_headers_.push_back(std::move(header));

  current_headers_length_ += length;
  session_->IncrementCurrentSessionMemory(length);
  return true;
}",1,1,node_http2.cc,node.http2.Http2Stream.AddHeader,,false,2412,2438,AddHeader,,,104,"bool node.http2.Http2Stream.AddHeader (nghttp2_rcbuf*,nghttp2_rcbuf*,uint8_t)"
194577,METHOD,node_http2.cc:<global>,TYPE_DECL,"Http2Stream::Provider::Provider(Http2Stream* stream, int options) {
  CHECK(!stream->is_destroyed());
  provider_.source.ptr = stream;
  empty_ = options & STREAM_OPTION_EMPTY_PAYLOAD;
}",1,1,node_http2.cc,node.http2.Http2Stream.Provider.Provider,,false,2441,2445,Provider,,,105,"ANY node.http2.Http2Stream.Provider.Provider (Http2Stream*,int)"
194601,METHOD,node_http2.cc:<global>,TYPE_DECL,"Http2Stream::Provider::Provider(int options) {
  provider_.source.ptr = nullptr;
  empty_ = options & STREAM_OPTION_EMPTY_PAYLOAD;
}",1,1,node_http2.cc,node.http2.Http2Stream.Provider.Provider,,false,2447,2450,Provider,,,106,ANY node.http2.Http2Stream.Provider.Provider (int)
194618,METHOD,node_http2.cc:<global>,TYPE_DECL,"Http2Stream::Provider::~Provider() {
  provider_.source.ptr = nullptr;
}",1,1,node_http2.cc,node.http2.Http2Stream.Provider.~Provider,,false,2452,2454,~Provider,,,107,ANY node.http2.Http2Stream.Provider.~Provider ()
194629,METHOD,node_http2.cc:<global>,TYPE_DECL,"Http2Stream::Provider::Stream::Stream(int options)
    : Http2Stream::Provider(options) {
  provider_.read_callback = Http2Stream::Provider::Stream::OnRead;
}",1,1,node_http2.cc,node.http2.Http2Stream.Provider.Stream.Stream,,false,2458,2461,Stream,,,108,ANY node.http2.Http2Stream.Provider.Stream.Stream (int)
194645,METHOD,node_http2.cc:<global>,TYPE_DECL,"Http2Stream::Provider::Stream::Stream(Http2Stream* stream, int options)
    : Http2Stream::Provider(stream, options) {
  provider_.read_callback = Http2Stream::Provider::Stream::OnRead;
}",1,1,node_http2.cc,node.http2.Http2Stream.Provider.Stream.Stream,,false,2463,2466,Stream,,,109,"ANY node.http2.Http2Stream.Provider.Stream.Stream (Http2Stream*,int)"
194662,METHOD,node_http2.cc:<global>,TYPE_DECL,"ssize_t Http2Stream::Provider::Stream::OnRead(nghttp2_session* handle,
                                              int32_t id,
                                              uint8_t* buf,
                                              size_t length,
                                              uint32_t* flags,
                                              nghttp2_data_source* source,
                                              void* user_data) {
  Http2Session* session = static_cast<Http2Session*>(user_data);
  Debug(session, ""reading outbound data for stream %d"", id);
  BaseObjectPtr<Http2Stream> stream = session->FindStream(id);
  if (!stream) return 0;
  if (stream->statistics_.first_byte_sent == 0)
    stream->statistics_.first_byte_sent = uv_hrtime();
  CHECK_EQ(id, stream->id());

  size_t amount = 0;          // amount of data being sent in this data frame.

  // Remove all empty chunks from the head of the queue.
  // This is done here so that .write('', cb) is still a me...",1,1,node_http2.cc,node.http2.Http2Stream.Provider.Stream.OnRead,,false,2468,2531,OnRead,,,110,"ssize_t node.http2.Http2Stream.Provider.Stream.OnRead (nghttp2_session*,int32_t,uint8_t*,size_t,uint32_t*,nghttp2_data_source*,void*)"
194920,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Stream::IncrementAvailableOutboundLength(size_t amount) {
  available_outbound_length_ += amount;
  session_->IncrementCurrentSessionMemory(amount);
}",1,1,node_http2.cc,node.http2.Http2Stream.IncrementAvailableOutboundLength,,false,2533,2536,IncrementAvailableOutboundLength,,,111,void node.http2.Http2Stream.IncrementAvailableOutboundLength (size_t)
194933,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Stream::DecrementAvailableOutboundLength(size_t amount) {
  available_outbound_length_ -= amount;
  session_->DecrementCurrentSessionMemory(amount);
}",1,1,node_http2.cc,node.http2.Http2Stream.DecrementAvailableOutboundLength,,false,2538,2541,DecrementAvailableOutboundLength,,,112,void node.http2.Http2Stream.DecrementAvailableOutboundLength (size_t)
194946,METHOD,node_http2.cc:<global>,TYPE_DECL,"void HttpErrorString(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  uint32_t val = args[0]->Uint32Value(env->context()).ToChecked();
  args.GetReturnValue().Set(
      OneByteString(
          env->isolate(),
          reinterpret_cast<const uint8_t*>(nghttp2_strerror(val))));
}",1,1,node_http2.cc,node.http2.HttpErrorString,,false,2548,2555,HttpErrorString,,,113,void node.http2.HttpErrorString (FunctionCallbackInfo<Value>)
194991,METHOD,node_http2.cc:<global>,TYPE_DECL,"void PackSettings(const FunctionCallbackInfo<Value>& args) {
  Http2State* state = Realm::GetBindingData<Http2State>(args);
  args.GetReturnValue().Set(Http2Settings::Pack(state));
}",1,1,node_http2.cc,node.http2.PackSettings,,false,2561,2564,PackSettings,,,114,void node.http2.PackSettings (FunctionCallbackInfo<Value>)
195018,METHOD,node_http2.cc:<global>,TYPE_DECL,"void RefreshDefaultSettings(const FunctionCallbackInfo<Value>& args) {
  Http2State* state = Realm::GetBindingData<Http2State>(args);
  Http2Settings::RefreshDefaults(state);
}",1,1,node_http2.cc,node.http2.RefreshDefaultSettings,,false,2569,2572,RefreshDefaultSettings,,,115,void node.http2.RefreshDefaultSettings (FunctionCallbackInfo<Value>)
195038,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::SetNextStreamID(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  int32_t id = args[0]->Int32Value(env->context()).ToChecked();
  if (nghttp2_session_set_next_stream_id(session->session(), id) < 0) {
    Debug(session, ""failed to set next stream id to %d"", id);
    return args.GetReturnValue().Set(false);
  }
  args.GetReturnValue().Set(true);
  Debug(session, ""set next stream id to %d"", id);
}",1,1,node_http2.cc,node.http2.Http2Session.SetNextStreamID,,false,2575,2586,SetNextStreamID,,,116,void node.http2.Http2Session.SetNextStreamID (FunctionCallbackInfo<Value>)
195110,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::SetLocalWindowSize(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());

  int32_t window_size = args[0]->Int32Value(env->context()).ToChecked();

  int result = nghttp2_session_set_local_window_size(
      session->session(), NGHTTP2_FLAG_NONE, 0, window_size);

  args.GetReturnValue().Set(result);

  Debug(session, ""set local window size to %d"", window_size);
}",1,1,node_http2.cc,node.http2.Http2Session.SetLocalWindowSize,,false,2591,2605,SetLocalWindowSize,,,117,void node.http2.Http2Session.SetLocalWindowSize (FunctionCallbackInfo<Value>)
195170,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::RefreshSettings(const FunctionCallbackInfo<Value>& args) {
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  Http2Settings::Update(session, fn);
  Debug(session, ""settings refreshed for session"");
}",1,1,node_http2.cc,node.http2.Http2Session.RefreshSettings,,false,2611,2616,RefreshSettings,,,118,void node.http2.Http2Session.RefreshSettings<get_setting> (FunctionCallbackInfo<Value>)
195192,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::RefreshState(const FunctionCallbackInfo<Value>& args) {
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  Debug(session, ""refreshing state"");

  AliasedFloat64Array& buffer = session->http2_state()->session_state_buffer;

  nghttp2_session* s = session->session();

  buffer[IDX_SESSION_STATE_EFFECTIVE_LOCAL_WINDOW_SIZE] =
      nghttp2_session_get_effective_local_window_size(s);
  buffer[IDX_SESSION_STATE_EFFECTIVE_RECV_DATA_LENGTH] =
      nghttp2_session_get_effective_recv_data_length(s);
  buffer[IDX_SESSION_STATE_NEXT_STREAM_ID] =
      nghttp2_session_get_next_stream_id(s);
  buffer[IDX_SESSION_STATE_LOCAL_WINDOW_SIZE] =
      nghttp2_session_get_local_window_size(s);
  buffer[IDX_SESSION_STATE_LAST_PROC_STREAM_ID] =
      nghttp2_session_get_last_proc_stream_id(s);
  buffer[IDX_SESSION_STATE_REMOTE_WINDOW_SIZE] =
      nghttp2_session_get_remote_window_size(s);
  buffer[IDX_SESSION_STATE_OUTBOUND_QUEUE_SIZE] =
      static_cast<d...",1,1,node_http2.cc,node.http2.Http2Session.RefreshState,,false,2621,2648,RefreshState,,,119,void node.http2.Http2Session.RefreshState (FunctionCallbackInfo<Value>)
195284,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::New(const FunctionCallbackInfo<Value>& args) {
  Http2State* state = Realm::GetBindingData<Http2State>(args);
  Environment* env = state->env();
  CHECK(args.IsConstructCall());
  SessionType type =
      static_cast<SessionType>(
          args[0]->Int32Value(env->context()).ToChecked());
  Http2Session* session = new Http2Session(state, args.This(), type);
  Debug(session, ""session created"");
}",1,1,node_http2.cc,node.http2.Http2Session.New,,false,2652,2661,New,,,120,void node.http2.Http2Session.New (FunctionCallbackInfo<Value>)
195343,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::Consume(const FunctionCallbackInfo<Value>& args) {
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  CHECK(args[0]->IsObject());
  session->Consume(args[0].As<Object>());
}",1,1,node_http2.cc,node.http2.Http2Session.Consume,,false,2665,2670,Consume,,,121,void node.http2.Http2Session.Consume (FunctionCallbackInfo<Value>)
195373,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::Destroy(const FunctionCallbackInfo<Value>& args) {
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  Debug(session, ""destroying session"");
  Environment* env = Environment::GetCurrent(args);
  Local<Context> context = env->context();

  uint32_t code = args[0]->Uint32Value(context).ToChecked();
  session->Close(code, args[1]->IsTrue());
}",1,1,node_http2.cc,node.http2.Http2Session.Destroy,,false,2673,2682,Destroy,,,122,void node.http2.Http2Session.Destroy (FunctionCallbackInfo<Value>)
195431,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::Request(const FunctionCallbackInfo<Value>& args) {
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  Environment* env = session->env();

  Local<Array> headers = args[0].As<Array>();
  int32_t options = args[1]->Int32Value(env->context()).ToChecked();

  Debug(session, ""request submitted"");

  int32_t ret = 0;
  Http2Stream* stream =
      session->Http2Session::SubmitRequest(
          Http2Priority(env, args[2], args[3], args[4]),
          Http2Headers(env, headers),
          &ret,
          static_cast<int>(options));

  if (ret <= 0 || stream == nullptr) {
    Debug(session, ""could not submit request: %s"", nghttp2_strerror(ret));
    return args.GetReturnValue().Set(ret);
  }

  Debug(session, ""request submitted, new stream id %d"", stream->id());
  args.GetReturnValue().Set(stream->object());
}",1,1,node_http2.cc,node.http2.Http2Session.Request,,false,2686,2711,Request,,,123,void node.http2.Http2Session.Request (FunctionCallbackInfo<Value>)
195553,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::Goaway(uint32_t code,
                          int32_t lastStreamID,
                          const uint8_t* data,
                          size_t len) {
  if (is_destroyed())
    return;

  Http2Scope h2scope(this);
  // the last proc stream id is the most recently created Http2Stream.
  if (lastStreamID <= 0)
    lastStreamID = nghttp2_session_get_last_proc_stream_id(session_.get());
  Debug(this, ""submitting goaway"");
  nghttp2_submit_goaway(session_.get(), NGHTTP2_FLAG_NONE,
                        lastStreamID, code, data, len);
}",1,1,node_http2.cc,node.http2.Http2Session.Goaway,,false,2716,2730,Goaway,,,124,"void node.http2.Http2Session.Goaway (uint32_t,int32_t,uint8_t*,size_t)"
195593,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::Goaway(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Local<Context> context = env->context();
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());

  uint32_t code = args[0]->Uint32Value(context).ToChecked();
  int32_t lastStreamID = args[1]->Int32Value(context).ToChecked();
  ArrayBufferViewContents<uint8_t> opaque_data;

  if (args[2]->IsArrayBufferView()) {
    opaque_data.Read(args[2].As<ArrayBufferView>());
  }

  session->Goaway(code, lastStreamID, opaque_data.data(), opaque_data.length());
}",1,1,node_http2.cc,node.http2.Http2Session.Goaway,,false,2735,2750,Goaway,,,125,void node.http2.Http2Session.Goaway (FunctionCallbackInfo<Value>)
195687,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::UpdateChunksSent(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  HandleScope scope(isolate);
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());

  uint32_t length = session->chunks_sent_since_last_write_;

  session->object()->Set(env->context(),
                         env->chunks_sent_since_last_write_string(),
                         Integer::NewFromUnsigned(isolate, length)).Check();

  args.GetReturnValue().Set(length);
}",1,1,node_http2.cc,node.http2.Http2Session.UpdateChunksSent,,false,2754,2768,UpdateChunksSent,,,126,void node.http2.Http2Session.UpdateChunksSent (FunctionCallbackInfo<Value>)
195756,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Stream::RstStream(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Local<Context> context = env->context();
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());
  uint32_t code = args[0]->Uint32Value(context).ToChecked();
  Debug(stream, ""sending rst_stream with code %d"", code);
  stream->SubmitRstStream(code);
}",1,1,node_http2.cc,node.http2.Http2Stream.RstStream,,false,2773,2781,RstStream,,,127,void node.http2.Http2Stream.RstStream (FunctionCallbackInfo<Value>)
195809,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Stream::Respond(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());

  Local<Array> headers = args[0].As<Array>();
  int32_t options = args[1]->Int32Value(env->context()).ToChecked();

  args.GetReturnValue().Set(
      stream->SubmitResponse(
          Http2Headers(env, headers),
          static_cast<int>(options)));
  Debug(stream, ""response submitted"");
}",1,1,node_http2.cc,node.http2.Http2Stream.Respond,,false,2785,2798,Respond,,,128,void node.http2.Http2Stream.Respond (FunctionCallbackInfo<Value>)
195878,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Stream::Info(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());

  Local<Array> headers = args[0].As<Array>();

  args.GetReturnValue().Set(stream->SubmitInfo(Http2Headers(env, headers)));
}",1,1,node_http2.cc,node.http2.Http2Stream.Info,,false,2802,2810,Info,,,129,void node.http2.Http2Stream.Info (FunctionCallbackInfo<Value>)
195925,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Stream::Trailers(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());

  Local<Array> headers = args[0].As<Array>();

  args.GetReturnValue().Set(
      stream->SubmitTrailers(Http2Headers(env, headers)));
}",1,1,node_http2.cc,node.http2.Http2Stream.Trailers,,false,2813,2822,Trailers,,,130,void node.http2.Http2Stream.Trailers (FunctionCallbackInfo<Value>)
195972,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Stream::GetID(const FunctionCallbackInfo<Value>& args) {
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());
  args.GetReturnValue().Set(stream->id());
}",1,1,node_http2.cc,node.http2.Http2Stream.GetID,,false,2825,2829,GetID,,,131,void node.http2.Http2Stream.GetID (FunctionCallbackInfo<Value>)
195996,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Stream::Destroy(const FunctionCallbackInfo<Value>& args) {
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());
  Debug(stream, ""destroying stream"");
  stream->Destroy();
}",1,1,node_http2.cc,node.http2.Http2Stream.Destroy,,false,2832,2837,Destroy,,,132,void node.http2.Http2Stream.Destroy (FunctionCallbackInfo<Value>)
196016,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Stream::PushPromise(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Http2Stream* parent;
  ASSIGN_OR_RETURN_UNWRAP(&parent, args.Holder());

  Local<Array> headers = args[0].As<Array>();
  int32_t options = args[1]->Int32Value(env->context()).ToChecked();

  Debug(parent, ""creating push promise"");

  int32_t ret = 0;
  Http2Stream* stream =
      parent->SubmitPushPromise(
          Http2Headers(env, headers),
          &ret,
          static_cast<int>(options));

  if (ret <= 0 || stream == nullptr) {
    Debug(parent, ""failed to create push stream: %d"", ret);
    return args.GetReturnValue().Set(ret);
  }
  Debug(parent, ""push stream %d created"", stream->id());
  args.GetReturnValue().Set(stream->object());
}",1,1,node_http2.cc,node.http2.Http2Stream.PushPromise,,false,2840,2863,PushPromise,,,133,void node.http2.Http2Stream.PushPromise (FunctionCallbackInfo<Value>)
196127,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Stream::Priority(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());

  CHECK_EQ(stream->SubmitPriority(
      Http2Priority(env, args[0], args[1], args[2]),
      args[3]->IsTrue()), 0);
  Debug(stream, ""priority submitted"");
}",1,1,node_http2.cc,node.http2.Http2Stream.Priority,,false,2866,2875,Priority,,,134,void node.http2.Http2Stream.Priority (FunctionCallbackInfo<Value>)
196174,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Stream::RefreshState(const FunctionCallbackInfo<Value>& args) {
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());

  Debug(stream, ""refreshing state"");

  CHECK_NOT_NULL(stream->session());
  AliasedFloat64Array& buffer =
      stream->session()->http2_state()->stream_state_buffer;

  nghttp2_stream* str = stream->stream();
  nghttp2_session* s = stream->session()->session();

  if (str == nullptr) {
    buffer[IDX_STREAM_STATE] = NGHTTP2_STREAM_STATE_IDLE;
    buffer[IDX_STREAM_STATE_WEIGHT] =
        buffer[IDX_STREAM_STATE_SUM_DEPENDENCY_WEIGHT] =
        buffer[IDX_STREAM_STATE_LOCAL_CLOSE] =
        buffer[IDX_STREAM_STATE_REMOTE_CLOSE] =
        buffer[IDX_STREAM_STATE_LOCAL_WINDOW_SIZE] = 0;
  } else {
    buffer[IDX_STREAM_STATE] =
        nghttp2_stream_get_state(str);
    buffer[IDX_STREAM_STATE_WEIGHT] =
        nghttp2_stream_get_weight(str);
    buffer[IDX_STREAM_STATE_SUM_DEPENDENCY_WEIGHT] =
        nghttp2_stream_get_sum_dependency_w...",1,1,node_http2.cc,node.http2.Http2Stream.RefreshState,,false,2880,2914,RefreshState,,,135,void node.http2.Http2Stream.RefreshState (FunctionCallbackInfo<Value>)
196305,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::AltSvc(int32_t id,
                          uint8_t* origin,
                          size_t origin_len,
                          uint8_t* value,
                          size_t value_len) {
  Http2Scope h2scope(this);
  CHECK_EQ(nghttp2_submit_altsvc(session_.get(), NGHTTP2_FLAG_NONE, id,
                                 origin, origin_len, value, value_len), 0);
}",1,1,node_http2.cc,node.http2.Http2Session.AltSvc,,false,2916,2924,AltSvc,,,136,"void node.http2.Http2Session.AltSvc (int32_t,uint8_t*,size_t,uint8_t*,size_t)"
196330,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::Origin(const Origins& origins) {
  Http2Scope h2scope(this);
  CHECK_EQ(nghttp2_submit_origin(
      session_.get(),
      NGHTTP2_FLAG_NONE,
      *origins,
      origins.length()), 0);
}",1,1,node_http2.cc,node.http2.Http2Session.Origin,,false,2926,2933,Origin,,,137,void node.http2.Http2Session.Origin (Origins)
196352,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::AltSvc(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());

  int32_t id = args[0]->Int32Value(env->context()).ToChecked();

  // origin and value are both required to be ASCII, handle them as such.
  Local<String> origin_str = args[1]->ToString(env->context()).ToLocalChecked();
  Local<String> value_str = args[2]->ToString(env->context()).ToLocalChecked();

  if (origin_str.IsEmpty() || value_str.IsEmpty())
    return;

  size_t origin_len = origin_str->Length();
  size_t value_len = value_str->Length();

  CHECK_LE(origin_len + value_len, 16382);  // Max permitted for ALTSVC
  // Verify that origin len != 0 if stream id == 0, or
  // that origin len == 0 if stream id != 0
  CHECK((origin_len != 0 && id == 0) || (origin_len == 0 && id != 0));

  MaybeStackBuffer<uint8_t> origin(origin_len);
  MaybeStackBuffer<uint8_t> value(value_len);
  origin_...",1,1,node_http2.cc,node.http2.Http2Session.AltSvc,,false,2936,2964,AltSvc,,,138,void node.http2.Http2Session.AltSvc (FunctionCallbackInfo<Value>)
196517,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::Origin(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Local<Context> context = env->context();
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());

  Local<String> origin_string = args[0].As<String>();
  size_t count = args[1]->Int32Value(context).ToChecked();

  session->Origin(Origins(env, origin_string, count));
}",1,1,node_http2.cc,node.http2.Http2Session.Origin,,false,2966,2976,Origin,,,139,void node.http2.Http2Session.Origin (FunctionCallbackInfo<Value>)
196581,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::Ping(const FunctionCallbackInfo<Value>& args) {
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());

  // A PING frame may have exactly 8 bytes of payload data. If not provided,
  // then the current hrtime will be used as the payload.
  ArrayBufferViewContents<uint8_t, 8> payload;
  if (args[0]->IsArrayBufferView()) {
    payload.Read(args[0].As<ArrayBufferView>());
    CHECK_EQ(payload.length(), 8);
  }

  CHECK(args[1]->IsFunction());
  args.GetReturnValue().Set(
      session->AddPing(payload.data(), args[1].As<Function>()));
}",1,1,node_http2.cc,node.http2.Http2Session.Ping,,false,2979,2994,Ping,,,140,void node.http2.Http2Session.Ping (FunctionCallbackInfo<Value>)
196653,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Session::Settings(const FunctionCallbackInfo<Value>& args) {
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  CHECK(args[0]->IsFunction());
  args.GetReturnValue().Set(session->AddSettings(args[0].As<Function>()));
}",1,1,node_http2.cc,node.http2.Http2Session.Settings,,false,2997,3002,Settings,,,141,void node.http2.Http2Session.Settings (FunctionCallbackInfo<Value>)
196690,METHOD,node_http2.cc:<global>,TYPE_DECL,"BaseObjectPtr<Http2Ping> Http2Session::PopPing() {
  BaseObjectPtr<Http2Ping> ping;
  if (!outstanding_pings_.empty()) {
    ping = std::move(outstanding_pings_.front());
    outstanding_pings_.pop();
    DecrementCurrentSessionMemory(sizeof(*ping));
  }
  return ping;
}",1,1,node_http2.cc,node.http2.Http2Session.PopPing,,false,3004,3012,PopPing,,,142,BaseObjectPtr<Http2Ping> node.http2.Http2Session.PopPing ()
196726,METHOD,node_http2.cc:<global>,TYPE_DECL,"bool Http2Session::AddPing(const uint8_t* payload, Local<Function> callback) {
  Local<Object> obj;
  if (!env()->http2ping_constructor_template()
          ->NewInstance(env()->context())
              .ToLocal(&obj)) {
    return false;
  }

  BaseObjectPtr<Http2Ping> ping =
      MakeDetachedBaseObject<Http2Ping>(this, obj, callback);
  if (!ping)
    return false;

  if (outstanding_pings_.size() == max_outstanding_pings_) {
    ping->Done(false);
    return false;
  }

  IncrementCurrentSessionMemory(sizeof(*ping));
  // The Ping itself is an Async resource. When the acknowledgement is received,
  // the callback will be invoked and a notification sent out to JS land. The
  // notification will include the duration of the ping, allowing the round
  // trip to be measured.
  ping->Send(payload);

  outstanding_pings_.emplace(std::move(ping));
  return true;
}",1,1,node_http2.cc,node.http2.Http2Session.AddPing,,false,3014,3041,AddPing,,,143,"bool node.http2.Http2Session.AddPing (uint8_t*,Local<Function>)"
196814,METHOD,node_http2.cc:<global>,TYPE_DECL,"BaseObjectPtr<Http2Settings> Http2Session::PopSettings() {
  BaseObjectPtr<Http2Settings> settings;
  if (!outstanding_settings_.empty()) {
    settings = std::move(outstanding_settings_.front());
    outstanding_settings_.pop();
    DecrementCurrentSessionMemory(sizeof(*settings));
  }
  return settings;
}",1,1,node_http2.cc,node.http2.Http2Session.PopSettings,,false,3043,3051,PopSettings,,,144,BaseObjectPtr<Http2Settings> node.http2.Http2Session.PopSettings ()
196850,METHOD,node_http2.cc:<global>,TYPE_DECL,"bool Http2Session::AddSettings(Local<Function> callback) {
  Local<Object> obj;
  if (!env()->http2settings_constructor_template()
          ->NewInstance(env()->context())
              .ToLocal(&obj)) {
    return false;
  }

  BaseObjectPtr<Http2Settings> settings =
      MakeDetachedBaseObject<Http2Settings>(this, obj, callback, 0);
  if (!settings)
    return false;

  if (outstanding_settings_.size() == max_outstanding_settings_) {
    settings->Done(false);
    return false;
  }

  IncrementCurrentSessionMemory(sizeof(*settings));
  settings->Send();
  outstanding_settings_.emplace(std::move(settings));
  return true;
}",1,1,node_http2.cc,node.http2.Http2Session.AddSettings,,false,3053,3075,AddSettings,,,145,bool node.http2.Http2Session.AddSettings (Local<Function>)
196937,METHOD,node_http2.cc:<global>,TYPE_DECL,"Http2Ping::Http2Ping(
    Http2Session* session,
    Local<Object> obj,
    Local<Function> callback)
    : AsyncWrap(session->env(), obj, AsyncWrap::PROVIDER_HTTP2PING),
      session_(session),
      startTime_(uv_hrtime()) {
  callback_.Reset(env()->isolate(), callback);
}",1,1,node_http2.cc,node.http2.Http2Ping.Http2Ping,,false,3077,3085,Http2Ping,,,146,"ANY node.http2.Http2Ping.Http2Ping (Http2Session*,Local<Object>,Local<Function>)"
196953,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Ping::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""callback"", callback_);
}",1,1,node_http2.cc,node.http2.Http2Ping.MemoryInfo,,false,3087,3089,MemoryInfo,,,147,void node.http2.Http2Ping.MemoryInfo (MemoryTracker*)
196964,METHOD,node_http2.cc:<global>,TYPE_DECL,"Local<Function> Http2Ping::callback() const {
  return callback_.Get(env()->isolate());
}",1,1,node_http2.cc,node.http2.Http2Ping.callback,,false,3091,3093,callback,,,148,Local<Function> node.http2.Http2Ping.callback ()
196977,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Ping::Send(const uint8_t* payload) {
  CHECK(session_);
  uint8_t data[8];
  if (payload == nullptr) {
    memcpy(&data, &startTime_, arraysize(data));
    payload = data;
  }
  Http2Scope h2scope(session_.get());
  CHECK_EQ(nghttp2_submit_ping(
      session_->session(),
      NGHTTP2_FLAG_NONE,
      payload), 0);
}",1,1,node_http2.cc,node.http2.Http2Ping.Send,,false,3095,3107,Send,,,149,void node.http2.Http2Ping.Send (uint8_t*)
197014,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Ping::Done(bool ack, const uint8_t* payload) {
  uint64_t duration_ns = uv_hrtime() - startTime_;
  double duration_ms = duration_ns / 1e6;
  if (session_) session_->statistics_.ping_rtt = duration_ns;

  Isolate* isolate = env()->isolate();
  HandleScope handle_scope(isolate);
  Context::Scope context_scope(env()->context());

  Local<Value> buf = Undefined(isolate);
  if (payload != nullptr) {
    buf = Buffer::Copy(isolate,
                       reinterpret_cast<const char*>(payload),
                       8).ToLocalChecked();
  }

  Local<Value> argv[] = {
      Boolean::New(isolate, ack), Number::New(isolate, duration_ms), buf};
  MakeCallback(callback(), arraysize(argv), argv);
}",1,1,node_http2.cc,node.http2.Http2Ping.Done,,false,3109,3128,Done,,,150,"void node.http2.Http2Ping.Done (bool,uint8_t*)"
197107,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2Ping::DetachFromSession() {
  session_.reset();
}",1,1,node_http2.cc,node.http2.Http2Ping.DetachFromSession,,false,3130,3132,DetachFromSession,,,151,void node.http2.Http2Ping.DetachFromSession ()
197115,METHOD,node_http2.cc:<global>,TYPE_DECL,"void NgHttp2StreamWrite::MemoryInfo(MemoryTracker* tracker) const {
  if (req_wrap)
    tracker->TrackField(""req_wrap"", req_wrap);
  tracker->TrackField(""buf"", buf);
}",1,1,node_http2.cc,node.http2.NgHttp2StreamWrite.MemoryInfo,,false,3134,3138,MemoryInfo,,,152,void node.http2.NgHttp2StreamWrite.MemoryInfo (MemoryTracker*)
197135,METHOD,node_http2.cc:<global>,TYPE_DECL,"void SetCallbackFunctions(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK_EQ(args.Length(), 11);

#define SET_FUNCTION(arg, name)                                               \
  CHECK(args[arg]->IsFunction());                                             \
  env->set_http2session_on_ ## name ## _function(args[arg].As<Function>());

  SET_FUNCTION(0, error)
  SET_FUNCTION(1, priority)
  SET_FUNCTION(2, settings)
  SET_FUNCTION(3, ping)
  SET_FUNCTION(4, headers)
  SET_FUNCTION(5, frame_error)
  SET_FUNCTION(6, goaway_data)
  SET_FUNCTION(7, altsvc)
  SET_FUNCTION(8, origin)
  SET_FUNCTION(9, stream_trailers)
  SET_FUNCTION(10, stream_close)

#undef SET_FUNCTION
}",1,2,node_http2.cc,node.http2.SetCallbackFunctions,,false,3140,3161,SetCallbackFunctions,,,153,void node.http2.SetCallbackFunctions (FunctionCallbackInfo<Value>)
197374,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Http2State::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""root_buffer"", root_buffer);
}",1,1,node_http2.cc,node.http2.Http2State.MemoryInfo,,false,3169,3171,MemoryInfo,,,154,void node.http2.Http2State.MemoryInfo (MemoryTracker*)
197385,METHOD,node_http2.cc:<global>,TYPE_DECL,"void Initialize(Local<Object> target,
                Local<Value> unused,
                Local<Context> context,
                void* priv) {
  Realm* realm = Realm::GetCurrent(context);
  Environment* env = realm->env();
  Isolate* isolate = env->isolate();
  HandleScope handle_scope(isolate);

  Http2State* const state = realm->AddBindingData<Http2State>(context, target);
  if (state == nullptr) return;

#define SET_STATE_TYPEDARRAY(name, field)             \
  target->Set(context,                                \
              FIXED_ONE_BYTE_STRING(isolate, (name)), \
              (field)).FromJust()

  // Initialize the buffer used to store the session state
  SET_STATE_TYPEDARRAY(
    ""sessionState"", state->session_state_buffer.GetJSArray());
  // Initialize the buffer used to store the stream state
  SET_STATE_TYPEDARRAY(
    ""streamState"", state->stream_state_buffer.GetJSArray());
  SET_STATE_TYPEDARRAY(
    ""settingsBuffer"", state->settings_buffer.GetJSArray());
  SET_ST...",1,2,node_http2.cc,node.http2.Initialize,,false,3174,3339,Initialize,,,155,"void node.http2.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
199155,METHOD,node_http2.hpp:<global>,TYPE_DECL,<global>,1,28,node_http2.hpp,node_http2.hpp:<global>,,false,1,1146,<global>,,,1,
199162,METHOD,node_http2_state.hpp:<global>,TYPE_DECL,<global>,1,34,node_http2_state.hpp,node_http2_state.hpp:<global>,,false,1,147,<global>,,,1,
199179,METHOD,node_http_common-inl.hpp:<global>,TYPE_DECL,<global>,1,1,node_http_common-inl.hpp,node_http_common-inl.hpp:<global>,,false,1,201,<global>,,,1,
199182,METHOD,node_http_common-inl.hpp:<global>,TYPE_DECL,"NgHeaders<T>::NgHeaders(Environment* env, v8::Local<v8::Array> headers) {
  v8::Local<v8::Value> header_string =
      headers->Get(env->context(), 0).ToLocalChecked();
  v8::Local<v8::Value> header_count =
      headers->Get(env->context(), 1).ToLocalChecked();
  CHECK(header_count->IsUint32());
  CHECK(header_string->IsString());
  count_ = header_count.As<v8::Uint32>()->Value();
  int header_string_len = header_string.As<v8::String>()->Length();

  if (count_ == 0) {
    CHECK_EQ(header_string_len, 0);
    return;
  }

  buf_.AllocateSufficientStorage((alignof(nv_t) - 1) +
                                 count_ * sizeof(nv_t) +
                                 header_string_len);

  char* start = AlignUp(buf_.out(), alignof(nv_t));
  char* header_contents = start + (count_ * sizeof(nv_t));
  nv_t* const nva = reinterpret_cast<nv_t*>(start);

  CHECK_LE(header_contents + header_string_len, *buf_ + buf_.length());
  CHECK_EQ(header_string.As<v8::String>()->WriteOneByte(
          ...",1,1,node_http_common-inl.hpp,node.NgHeaders<T>.NgHeaders,,false,15,67,NgHeaders,,,1,"ANY node.NgHeaders<T>.NgHeaders<T> (Environment*,ANY)"
199464,METHOD,node_http_common-inl.hpp:<global>,TYPE_DECL,"size_t GetClientMaxHeaderPairs(size_t max_header_pairs) {
  static constexpr size_t min_header_pairs = 1;
  return std::max(max_header_pairs, min_header_pairs);
}",1,1,node_http_common-inl.hpp,node.GetClientMaxHeaderPairs,,false,69,72,GetClientMaxHeaderPairs,,,2,size_t node.GetClientMaxHeaderPairs (size_t)
199480,METHOD,node_http_common-inl.hpp:<global>,TYPE_DECL,"size_t GetServerMaxHeaderPairs(size_t max_header_pairs) {
  static constexpr size_t min_header_pairs = 4;
  return std::max(max_header_pairs, min_header_pairs);
}",1,1,node_http_common-inl.hpp,node.GetServerMaxHeaderPairs,,false,74,77,GetServerMaxHeaderPairs,,,3,size_t node.GetServerMaxHeaderPairs (size_t)
199496,METHOD,node_http_common-inl.hpp:<global>,TYPE_DECL,"std::string NgHeaderBase<allocator_t>::ToString() const {
  std::string ret = name();
  ret += "" = "";
  ret += value();
  return ret;
}",1,1,node_http_common-inl.hpp,node.NgHeaderBase<allocator_t>.ToString,,false,80,85,ToString,,,4,string node.NgHeaderBase<allocator_t>.ToString<allocator_t> ()
199512,METHOD,node_http_common-inl.hpp:<global>,TYPE_DECL,"bool NgHeader<T>::IsZeroLength(
    NgHeader<T>::rcbuf_t* name,
    NgHeader<T>::rcbuf_t* value) {
  return IsZeroLength(-1, name, value);
}",1,1,node_http_common-inl.hpp,node.NgHeader<T>.IsZeroLength,,false,88,92,IsZeroLength,,,5,"bool node.NgHeader<T>.IsZeroLength<T> (ANY*,ANY*)"
199524,METHOD,node_http_common-inl.hpp:<global>,TYPE_DECL,"bool NgHeader<T>::IsZeroLength(
    int32_t token,
    NgHeader<T>::rcbuf_t* name,
    NgHeader<T>::rcbuf_t* value) {

  if (NgHeader<T>::rcbufferpointer_t::IsZeroLength(value))
    return true;

  const char* header_name = T::ToHttpHeaderName(token);
  return header_name != nullptr ||
      NgHeader<T>::rcbufferpointer_t::IsZeroLength(name);
}",1,1,node_http_common-inl.hpp,node.NgHeader<T>.IsZeroLength,,false,95,106,IsZeroLength,,,6,"bool node.NgHeader<T>.IsZeroLength<T> (int32_t,ANY*,ANY*)"
199566,METHOD,node_http_common-inl.hpp:<global>,TYPE_DECL,"NgHeader<T>::NgHeader(
    Environment* env,
    NgHeader<T>::rcbuf_t* name,
    NgHeader<T>::rcbuf_t* value,
    uint8_t flags)
    : NgHeader<T>(env, -1, name, value, flags) {}",1,49,node_http_common-inl.hpp,node.NgHeader<T>.NgHeader,,false,109,114,NgHeader,,,7,"ANY node.NgHeader<T>.NgHeader<T> (Environment*,ANY*,ANY*,uint8_t)"
199574,METHOD,node_http_common-inl.hpp:<global>,TYPE_DECL,"NgHeader<T>::NgHeader(
    Environment* env,
    int32_t token,
    NgHeader<T>::rcbuf_t* name,
    NgHeader<T>::rcbuf_t* value,
    uint8_t flags) : env_(env), token_(token), flags_(flags) {
  if (token == -1) {
    CHECK_NOT_NULL(name);
    name_.reset(name, true);  // Internalizable
  }
  CHECK_NOT_NULL(value);
  name_.reset(name, true);  // Internalizable
  value_.reset(value);
}",1,1,node_http_common-inl.hpp,node.NgHeader<T>.NgHeader,,false,117,130,NgHeader,,,8,"ANY node.NgHeader<T>.NgHeader<T> (Environment*,int32_t,ANY*,ANY*,uint8_t)"
199610,METHOD,node_http_common-inl.hpp:<global>,TYPE_DECL,"NgHeader<T>::NgHeader(NgHeader<T>&& other) noexcept
    : env_(other.env_),
      name_(std::move(other.name_)),
      value_(std::move(other.value_)),
      token_(other.token_),
      flags_(other.flags_) {
  other.token_ = -1;
  other.flags_ = 0;
  other.env_ = nullptr;
}",1,1,node_http_common-inl.hpp,node.NgHeader<T>.NgHeader,,false,133,142,NgHeader,,,9,ANY node.NgHeader<T>.NgHeader<T> (NgHeader<T>)
199631,METHOD,node_http_common-inl.hpp:<global>,TYPE_DECL,"void NgHeader<T>::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""name"", name_);
  tracker->TrackField(""value"", value_);
}",1,1,node_http_common-inl.hpp,node.NgHeader<T>.MemoryInfo,,false,145,148,MemoryInfo,,,10,void node.NgHeader<T>.MemoryInfo<T> (MemoryTracker*)
199648,METHOD,node_http_common-inl.hpp:<global>,TYPE_DECL,"v8::MaybeLocal<v8::String> NgHeader<T>::GetName(
    NgHeader<T>::allocator_t* allocator) const {

  // Not all instances will support using token id's for header names.
  // HTTP/2 specifically does not support it.
  const char* header_name = T::ToHttpHeaderName(token_);

  // If header_name is not nullptr, then it is a known header with
  // a statically defined name. We can safely internalize it here.
  if (header_name != nullptr) {
    auto& static_str_map = env_->isolate_data()->static_str_map;
    v8::Eternal<v8::String> eternal = static_str_map[header_name];
    if (eternal.IsEmpty()) {
      v8::Local<v8::String> str = OneByteString(env_->isolate(), header_name);
      eternal.Set(env_->isolate(), str);
      return str;
    }
    return eternal.Get(env_->isolate());
  }
  return rcbufferpointer_t::External::New(allocator, name_);
}",1,1,node_http_common-inl.hpp,node.NgHeader<T>.GetName,,false,151,171,GetName,,,11,MaybeLocal<v8::String> node.NgHeader<T>.GetName<T> (ANY*)
199739,METHOD,node_http_common-inl.hpp:<global>,TYPE_DECL,"v8::MaybeLocal<v8::String> NgHeader<T>::GetValue(
    NgHeader<T>::allocator_t* allocator) const {
  return rcbufferpointer_t::External::New(allocator, value_);
}",1,1,node_http_common-inl.hpp,node.NgHeader<T>.GetValue,,false,174,177,GetValue,,,12,MaybeLocal<v8::String> node.NgHeader<T>.GetValue<T> (ANY*)
199753,METHOD,node_http_common-inl.hpp:<global>,TYPE_DECL,"std::string NgHeader<T>::name() const {
  return name_.str();
}",1,1,node_http_common-inl.hpp,node.NgHeader<T>.name,,false,180,182,name,,,13,string node.NgHeader<T>.name<T> ()
199762,METHOD,node_http_common-inl.hpp:<global>,TYPE_DECL,"std::string NgHeader<T>::value() const {
  return value_.str();
}",1,1,node_http_common-inl.hpp,node.NgHeader<T>.value,,false,185,187,value,,,14,string node.NgHeader<T>.value<T> ()
199771,METHOD,node_http_common-inl.hpp:<global>,TYPE_DECL,"size_t NgHeader<T>::length() const {
  return name_.len() + value_.len();
}",1,1,node_http_common-inl.hpp,node.NgHeader<T>.length,,false,190,192,length,,,15,size_t node.NgHeader<T>.length<T> ()
199785,METHOD,node_http_common-inl.hpp:<global>,TYPE_DECL,"uint8_t NgHeader<T>::flags() const {
  return flags_;
}",1,1,node_http_common-inl.hpp,node.NgHeader<T>.flags,,false,195,197,flags,,,16,uint8_t node.NgHeader<T>.flags<T> ()
199800,METHOD,node_http_common.hpp:<global>,TYPE_DECL,<global>,1,34,node_http_common.hpp,node_http_common.hpp:<global>,,false,1,532,<global>,,,1,
199803,METHOD,node.anonymous_namespace_49.Parser,TYPE_DECL,"[&]() {
      if (buf.base == binding_data_->parser_buffer.data())
        binding_data_->parser_buffer_in_use = false;
      else
        free(buf.base);
    }",40,5,node_http_parser.cc,node.anonymous_namespace_86.Parser.OnStreamRead.<lambda>0,,false,761,766,<lambda>0,,,1,ANY node.anonymous_namespace_86.Parser.OnStreamRead.<lambda>0 ()
199857,METHOD,node_http_parser.cc:<global>,TYPE_DECL,<global>,1,1,node_http_parser.cc,node_http_parser.cc:<global>,,false,1,1284,<global>,,,1,
199923,METHOD,node_http_parser.cc:<global>,TYPE_DECL,"inline bool IsOWS(char c) {
  return c == ' ' || c == '\t';
}",1,1,node_http_parser.cc,node.anonymous_namespace_21.IsOWS,,false,90,92,IsOWS,,,27,bool node.anonymous_namespace_21.IsOWS (char)
199937,METHOD,node.anonymous_namespace_22.BindingData,TYPE_DECL,"BindingData(Realm* realm, Local<Object> obj) : BaseObject(realm, obj) {}",3,74,node_http_parser.cc,node.anonymous_namespace_23.BindingData.BindingData,,false,96,96,BindingData,,,1,"ANY node.anonymous_namespace_23.BindingData.BindingData (Realm*,Local<Object>)"
199947,METHOD,node.anonymous_namespace_22.BindingData,TYPE_DECL,"void MemoryInfo(MemoryTracker* tracker) const override {
    tracker->TrackField(""parser_buffer"", parser_buffer);
  }",3,3,node_http_parser.cc,node.anonymous_namespace_24.BindingData.MemoryInfo,,false,103,105,MemoryInfo,,,6,void node.anonymous_namespace_24.BindingData.MemoryInfo (MemoryTracker*)
199962,METHOD,<empty>,<empty>,<empty>,1,,node_http_parser.cc,node.anonymous_namespace_22.BindingData:<clinit>,,false,94,,<clinit>,,,11,
199970,METHOD,node.anonymous_namespace_25.StringPtr,TYPE_DECL,"StringPtr() {
    on_heap_ = false;
    Reset();
  }",3,3,node_http_parser.cc,node.anonymous_namespace_26.StringPtr.StringPtr,,false,112,115,StringPtr,,,1,ANY node.anonymous_namespace_26.StringPtr.StringPtr ()
199978,METHOD,node.anonymous_namespace_25.StringPtr,TYPE_DECL,"~StringPtr() {
    Reset();
  }",3,3,node_http_parser.cc,node.anonymous_namespace_28.StringPtr.~StringPtr,,false,118,120,~StringPtr,,,2,ANY node.anonymous_namespace_28.StringPtr.~StringPtr ()
199983,METHOD,node.anonymous_namespace_25.StringPtr,TYPE_DECL,"void Save() {
    if (!on_heap_ && size_ > 0) {
      char* s = new char[size_];
      memcpy(s, str_, size_);
      str_ = s;
      on_heap_ = true;
    }
  }",3,3,node_http_parser.cc,node.anonymous_namespace_30.StringPtr.Save,,false,126,133,Save,,,3,void node.anonymous_namespace_30.StringPtr.Save ()
200010,METHOD,node.anonymous_namespace_25.StringPtr,TYPE_DECL,"void Reset() {
    if (on_heap_) {
      delete[] str_;
      on_heap_ = false;
    }

    str_ = nullptr;
    size_ = 0;
  }",3,3,node_http_parser.cc,node.anonymous_namespace_31.StringPtr.Reset,,false,136,144,Reset,,,4,void node.anonymous_namespace_31.StringPtr.Reset ()
200028,METHOD,node.anonymous_namespace_25.StringPtr,TYPE_DECL,"void Update(const char* str, size_t size) {
    if (str_ == nullptr) {
      str_ = str;
    } else if (on_heap_ || str_ + size_ != str) {
      // Non-consecutive input, make a copy on the heap.
      // TODO(bnoordhuis) Use slab allocation, O(n) allocs is bad.
      char* s = new char[size_ + size];
      memcpy(s, str_, size_);
      memcpy(s + size_, str, size);

      if (on_heap_)
        delete[] str_;
      else
        on_heap_ = true;

      str_ = s;
    }
    size_ += size;
  }",3,3,node_http_parser.cc,node.anonymous_namespace_32.StringPtr.Update,,false,147,165,Update,,,5,"void node.anonymous_namespace_32.StringPtr.Update (char*,size_t)"
200084,METHOD,node.anonymous_namespace_25.StringPtr,TYPE_DECL,"Local<String> ToString(Environment* env) const {
    if (size_ != 0)
      return OneByteString(env->isolate(), str_, size_);
    else
      return String::Empty(env->isolate());
  }",3,3,node_http_parser.cc,node.anonymous_namespace_33.StringPtr.ToString,,false,168,173,ToString,,,6,Local<String> node.anonymous_namespace_33.StringPtr.ToString (Environment*)
200113,METHOD,node.anonymous_namespace_25.StringPtr,TYPE_DECL,"Local<String> ToTrimmedString(Environment* env) {
    while (size_ > 0 && IsOWS(str_[size_ - 1])) {
      size_--;
    }
    return ToString(env);
  }",3,3,node_http_parser.cc,node.anonymous_namespace_34.StringPtr.ToTrimmedString,,false,177,182,ToTrimmedString,,,7,Local<String> node.anonymous_namespace_34.StringPtr.ToTrimmedString (Environment*)
200140,METHOD,node.anonymous_namespace_37.ParserComparator,TYPE_DECL,"bool operator()(const Parser* lhs, const Parser* rhs) const;",8,61,node_http_parser.cc,node.anonymous_namespace_38.ParserComparator.operator (),,false,193,193,operator (),,,1,"bool node.anonymous_namespace_38.ParserComparator.operator () (Parser*,Parser*)"
200147,METHOD,node.anonymous_namespace_39.ConnectionsList,TYPE_DECL,static void New(const FunctionCallbackInfo<Value>& args);,17,60,node_http_parser.cc,node.anonymous_namespace_40.ConnectionsList.New,,false,198,198,New,,,1,void node.anonymous_namespace_40.ConnectionsList.New (FunctionCallbackInfo<Value>)
200152,METHOD,node.anonymous_namespace_39.ConnectionsList,TYPE_DECL,static void All(const FunctionCallbackInfo<Value>& args);,17,60,node_http_parser.cc,node.anonymous_namespace_41.ConnectionsList.All,,false,200,200,All,,,2,void node.anonymous_namespace_41.ConnectionsList.All (FunctionCallbackInfo<Value>)
200157,METHOD,node.anonymous_namespace_39.ConnectionsList,TYPE_DECL,static void Idle(const FunctionCallbackInfo<Value>& args);,17,61,node_http_parser.cc,node.anonymous_namespace_42.ConnectionsList.Idle,,false,202,202,Idle,,,3,void node.anonymous_namespace_42.ConnectionsList.Idle (FunctionCallbackInfo<Value>)
200162,METHOD,node.anonymous_namespace_39.ConnectionsList,TYPE_DECL,static void Active(const FunctionCallbackInfo<Value>& args);,17,63,node_http_parser.cc,node.anonymous_namespace_43.ConnectionsList.Active,,false,204,204,Active,,,4,void node.anonymous_namespace_43.ConnectionsList.Active (FunctionCallbackInfo<Value>)
200167,METHOD,node.anonymous_namespace_39.ConnectionsList,TYPE_DECL,static void Expired(const FunctionCallbackInfo<Value>& args);,17,64,node_http_parser.cc,node.anonymous_namespace_44.ConnectionsList.Expired,,false,206,206,Expired,,,5,void node.anonymous_namespace_44.ConnectionsList.Expired (FunctionCallbackInfo<Value>)
200172,METHOD,node.anonymous_namespace_39.ConnectionsList,TYPE_DECL,"void Push(Parser* parser) {
      all_connections_.insert(parser);
    }",5,5,node_http_parser.cc,node.anonymous_namespace_45.ConnectionsList.Push,,false,208,210,Push,,,6,void node.anonymous_namespace_45.ConnectionsList.Push (Parser*)
200182,METHOD,node.anonymous_namespace_39.ConnectionsList,TYPE_DECL,"void Pop(Parser* parser) {
      all_connections_.erase(parser);
    }",5,5,node_http_parser.cc,node.anonymous_namespace_46.ConnectionsList.Pop,,false,212,214,Pop,,,7,void node.anonymous_namespace_46.ConnectionsList.Pop (Parser*)
200192,METHOD,node.anonymous_namespace_39.ConnectionsList,TYPE_DECL,"void PushActive(Parser* parser) {
      active_connections_.insert(parser);
    }",5,5,node_http_parser.cc,node.anonymous_namespace_47.ConnectionsList.PushActive,,false,216,218,PushActive,,,8,void node.anonymous_namespace_47.ConnectionsList.PushActive (Parser*)
200202,METHOD,node.anonymous_namespace_39.ConnectionsList,TYPE_DECL,"void PopActive(Parser* parser) {
      active_connections_.erase(parser);
    }",5,5,node_http_parser.cc,node.anonymous_namespace_48.ConnectionsList.PopActive,,false,220,222,PopActive,,,9,void node.anonymous_namespace_48.ConnectionsList.PopActive (Parser*)
200217,METHOD,node.anonymous_namespace_49.Parser,TYPE_DECL,"Parser(BindingData* binding_data, Local<Object> wrap)
      : AsyncWrap(binding_data->env(), wrap),
        current_buffer_len_(0),
        current_buffer_data_(nullptr),
        binding_data_(binding_data) {
  }",3,3,node_http_parser.cc,node.anonymous_namespace_52.Parser.Parser,,false,243,248,Parser,,,3,"ANY node.anonymous_namespace_52.Parser.Parser (BindingData*,Local<Object>)"
200224,METHOD,node.anonymous_namespace_49.Parser,TYPE_DECL,"int on_url(const char* at, size_t length) {
    int rv = TrackHeader(length);
    if (rv != 0) {
      return rv;
    }

    url_.Update(at, length);
    return 0;
  }",3,3,node_http_parser.cc,node.anonymous_namespace_53.Parser.on_url,,false,289,297,on_url,,,5,"int node.anonymous_namespace_53.Parser.on_url (char*,size_t)"
200250,METHOD,node.anonymous_namespace_49.Parser,TYPE_DECL,"int on_status(const char* at, size_t length) {
    int rv = TrackHeader(length);
    if (rv != 0) {
      return rv;
    }

    status_message_.Update(at, length);
    return 0;
  }",3,3,node_http_parser.cc,node.anonymous_namespace_55.Parser.on_status,,false,300,308,on_status,,,6,"int node.anonymous_namespace_55.Parser.on_status (char*,size_t)"
200276,METHOD,node.anonymous_namespace_49.Parser,TYPE_DECL,"int on_header_field(const char* at, size_t length) {
    int rv = TrackHeader(length);
    if (rv != 0) {
      return rv;
    }

    if (num_fields_ == num_values_) {
      // start of new field name
      num_fields_++;
      if (num_fields_ == kMaxHeaderFieldsCount) {
        // ran out of space - flush to javascript land
        Flush();
        num_fields_ = 1;
        num_values_ = 0;
      }
      fields_[num_fields_ - 1].Reset();
    }

    CHECK_LT(num_fields_, kMaxHeaderFieldsCount);
    CHECK_EQ(num_fields_, num_values_ + 1);

    fields_[num_fields_ - 1].Update(at, length);

    return 0;
  }",3,3,node_http_parser.cc,node.anonymous_namespace_57.Parser.on_header_field,,false,311,335,on_header_field,,,7,"int node.anonymous_namespace_57.Parser.on_header_field (char*,size_t)"
200341,METHOD,node.anonymous_namespace_49.Parser,TYPE_DECL,"int on_header_value(const char* at, size_t length) {
    int rv = TrackHeader(length);
    if (rv != 0) {
      return rv;
    }

    if (num_values_ != num_fields_) {
      // start of new header value
      num_values_++;
      values_[num_values_ - 1].Reset();
    }

    CHECK_LT(num_values_, arraysize(values_));
    CHECK_EQ(num_values_, num_fields_);

    values_[num_values_ - 1].Update(at, length);

    return 0;
  }",3,3,node_http_parser.cc,node.anonymous_namespace_60.Parser.on_header_value,,false,338,356,on_header_value,,,8,"int node.anonymous_namespace_60.Parser.on_header_value (char*,size_t)"
200393,METHOD,node.anonymous_namespace_49.Parser,TYPE_DECL,"int on_headers_complete() {
    headers_completed_ = true;
    header_nread_ = 0;

    // Arguments for the on-headers-complete javascript callback. This
    // list needs to be kept in sync with the actual argument list for
    // `parserOnHeadersComplete` in lib/_http_common.js.
    enum on_headers_complete_arg_index {
      A_VERSION_MAJOR = 0,
      A_VERSION_MINOR,
      A_HEADERS,
      A_METHOD,
      A_URL,
      A_STATUS_CODE,
      A_STATUS_MESSAGE,
      A_UPGRADE,
      A_SHOULD_KEEP_ALIVE,
      A_MAX
    };

    Local<Value> argv[A_MAX];
    Local<Object> obj = object();
    Local<Value> cb = obj->Get(env()->context(),
                               kOnHeadersComplete).ToLocalChecked();

    if (!cb->IsFunction())
      return 0;

    Local<Value> undefined = Undefined(env()->isolate());
    for (size_t i = 0; i < arraysize(argv); i++)
      argv[i] = undefined;

    if (have_flushed_) {
      // Slow case, flush remaining headers.
      Flush();
    } else {
      // ...",3,3,node_http_parser.cc,node.anonymous_namespace_62.Parser.on_headers_complete,,false,359,448,on_headers_complete,,,9,int node.anonymous_namespace_62.Parser.on_headers_complete ()
200696,METHOD,node.anonymous_namespace_49.Parser,TYPE_DECL,"int on_body(const char* at, size_t length) {
    if (length == 0)
      return 0;

    Environment* env = this->env();
    HandleScope handle_scope(env->isolate());

    Local<Value> cb = object()->Get(env->context(), kOnBody).ToLocalChecked();

    if (!cb->IsFunction())
      return 0;

    Local<Value> buffer = Buffer::Copy(env, at, length).ToLocalChecked();

    MaybeLocal<Value> r = MakeCallback(cb.As<Function>(), 1, &buffer);

    if (r.IsEmpty()) {
      got_exception_ = true;
      llhttp_set_error_reason(&parser_, ""HPE_JS_EXCEPTION:JS Exception"");
      return HPE_USER;
    }

    return 0;
  }",3,3,node_http_parser.cc,node.anonymous_namespace_65.Parser.on_body,,false,451,474,on_body,,,10,"int node.anonymous_namespace_65.Parser.on_body (char*,size_t)"
200796,METHOD,node.anonymous_namespace_49.Parser,TYPE_DECL,"int on_message_complete() {
    HandleScope scope(env()->isolate());

    // Important: Pop from the lists BEFORE resetting the last_message_start_
    // otherwise std::set.erase will fail.
    if (connectionsList_ != nullptr) {
      connectionsList_->Pop(this);
      connectionsList_->PopActive(this);
    }

    last_message_start_ = 0;

    if (connectionsList_ != nullptr) {
      connectionsList_->Push(this);
    }

    if (num_fields_)
      Flush();  // Flush trailing HTTP headers.

    Local<Object> obj = object();
    Local<Value> cb = obj->Get(env()->context(),
                               kOnMessageComplete).ToLocalChecked();

    if (!cb->IsFunction())
      return 0;

    MaybeLocal<Value> r;
    {
      InternalCallbackScope callback_scope(
          this, InternalCallbackScope::kSkipTaskQueues);
      r = cb.As<Function>()->Call(env()->context(), object(), 0, nullptr);
      if (r.IsEmpty()) callback_scope.MarkAsFailed();
    }

    if (r.IsEmpty()) {
      got_exce...",3,3,node_http_parser.cc,node.anonymous_namespace_66.Parser.on_message_complete,,false,477,517,on_message_complete,,,11,int node.anonymous_namespace_66.Parser.on_message_complete ()
200924,METHOD,node.anonymous_namespace_49.Parser,TYPE_DECL,"int on_chunk_header() {
    header_nread_ = 0;
    return 0;
  }",3,3,node_http_parser.cc,node.anonymous_namespace_68.Parser.on_chunk_header,,false,520,523,on_chunk_header,,,12,int node.anonymous_namespace_68.Parser.on_chunk_header ()
200933,METHOD,node.anonymous_namespace_49.Parser,TYPE_DECL,"int on_chunk_complete() {
    header_nread_ = 0;
    return 0;
  }",3,3,node_http_parser.cc,node.anonymous_namespace_69.Parser.on_chunk_complete,,false,527,530,on_chunk_complete,,,13,int node.anonymous_namespace_69.Parser.on_chunk_complete ()
200942,METHOD,node.anonymous_namespace_49.Parser,TYPE_DECL,"static void New(const FunctionCallbackInfo<Value>& args) {
    BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
    new Parser(binding_data, args.This());
  }",3,3,node_http_parser.cc,node.anonymous_namespace_70.Parser.New,,false,532,535,New,,,14,void node.anonymous_namespace_70.Parser.New (FunctionCallbackInfo<Value>)
200964,METHOD,node.anonymous_namespace_49.Parser,TYPE_DECL,"static void Close(const FunctionCallbackInfo<Value>& args) {
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    delete parser;
  }",3,3,node_http_parser.cc,node.anonymous_namespace_71.Parser.Close,,false,538,543,Close,,,15,void node.anonymous_namespace_71.Parser.Close (FunctionCallbackInfo<Value>)
200979,METHOD,node.anonymous_namespace_49.Parser,TYPE_DECL,"static void Free(const FunctionCallbackInfo<Value>& args) {
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    // Since the Parser destructor isn't going to run the destroy() callbacks
    // it needs to be triggered manually.
    parser->EmitTraceEventDestroy();
    parser->EmitDestroy();
  }",3,3,node_http_parser.cc,node.anonymous_namespace_72.Parser.Free,,false,546,554,Free,,,16,void node.anonymous_namespace_72.Parser.Free (FunctionCallbackInfo<Value>)
201000,METHOD,node.anonymous_namespace_49.Parser,TYPE_DECL,"static void Remove(const FunctionCallbackInfo<Value>& args) {
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    if (parser->connectionsList_ != nullptr) {
      parser->connectionsList_->Pop(parser);
      parser->connectionsList_->PopActive(parser);
    }
  }",3,3,node_http_parser.cc,node.anonymous_namespace_73.Parser.Remove,,false,556,564,Remove,,,17,void node.anonymous_namespace_73.Parser.Remove (FunctionCallbackInfo<Value>)
201034,METHOD,node.anonymous_namespace_49.Parser,TYPE_DECL,"void Save() {
    url_.Save();
    status_message_.Save();

    for (size_t i = 0; i < num_fields_; i++) {
      fields_[i].Save();
    }

    for (size_t i = 0; i < num_values_; i++) {
      values_[i].Save();
    }
  }",3,3,node_http_parser.cc,node.anonymous_namespace_74.Parser.Save,,false,566,577,Save,,,18,void node.anonymous_namespace_74.Parser.Save ()
201082,METHOD,node.anonymous_namespace_49.Parser,TYPE_DECL,"static void Execute(const FunctionCallbackInfo<Value>& args) {
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    ArrayBufferViewContents<char> buffer(args[0]);

    Local<Value> ret = parser->Execute(buffer.data(), buffer.length());

    if (!ret.IsEmpty())
      args.GetReturnValue().Set(ret);
  }",3,3,node_http_parser.cc,node.anonymous_namespace_75.Parser.Execute,,false,580,590,Execute,,,19,void node.anonymous_namespace_75.Parser.Execute (FunctionCallbackInfo<Value>)
201133,METHOD,node.anonymous_namespace_49.Parser,TYPE_DECL,"static void Finish(const FunctionCallbackInfo<Value>& args) {
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    Local<Value> ret = parser->Execute(nullptr, 0);

    if (!ret.IsEmpty())
      args.GetReturnValue().Set(ret);
  }",3,3,node_http_parser.cc,node.anonymous_namespace_76.Parser.Finish,,false,593,601,Finish,,,20,void node.anonymous_namespace_76.Parser.Finish (FunctionCallbackInfo<Value>)
201173,METHOD,node.anonymous_namespace_49.Parser,TYPE_DECL,"static void Initialize(const FunctionCallbackInfo<Value>& args) {
    Environment* env = Environment::GetCurrent(args);

    uint64_t max_http_header_size = 0;
    uint32_t lenient_flags = kLenientNone;
    ConnectionsList* connectionsList = nullptr;

    CHECK(args[0]->IsInt32());
    CHECK(args[1]->IsObject());

    if (args.Length() > 2) {
      CHECK(args[2]->IsNumber());
      max_http_header_size =
          static_cast<uint64_t>(args[2].As<Number>()->Value());
    }
    if (max_http_header_size == 0) {
      max_http_header_size = env->options()->max_http_header_size;
    }

    if (args.Length() > 3) {
      CHECK(args[3]->IsInt32());
      lenient_flags = args[3].As<Int32>()->Value();
    }

    if (args.Length() > 4 && !args[4]->IsNullOrUndefined()) {
      CHECK(args[4]->IsObject());
      ASSIGN_OR_RETURN_UNWRAP(&connectionsList, args[4]);
    }

    llhttp_type_t type =
        static_cast<llhttp_type_t>(args[0].As<Int32>()->Value());

    CHECK(type == HTTP_REQUEST || ...",3,3,node_http_parser.cc,node.anonymous_namespace_77.Parser.Initialize,,false,604,666,Initialize,,,21,void node.anonymous_namespace_77.Parser.Initialize (FunctionCallbackInfo<Value>)
201415,METHOD,node.anonymous_namespace_49.Parser,TYPE_DECL,"static void Pause(const FunctionCallbackInfo<Value>& args) {
    Environment* env = Environment::GetCurrent(args);
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());
    // Should always be called from the same context.
    CHECK_EQ(env, parser->env());

    if constexpr (should_pause) {
      llhttp_pause(&parser->parser_);
    } else {
      llhttp_resume(&parser->parser_);
    }
  }",3,3,node_http_parser.cc,node.anonymous_namespace_78.Parser.Pause,,false,669,681,Pause,,,22,void node.anonymous_namespace_78.Parser.Pause<bool> (FunctionCallbackInfo<Value>)
201457,METHOD,node.anonymous_namespace_49.Parser,TYPE_DECL,"static void Consume(const FunctionCallbackInfo<Value>& args) {
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());
    CHECK(args[0]->IsObject());
    StreamBase* stream = StreamBase::FromObject(args[0].As<Object>());
    CHECK_NOT_NULL(stream);
    stream->PushStreamListener(parser);
  }",3,3,node_http_parser.cc,node.anonymous_namespace_79.Parser.Consume,,false,684,691,Consume,,,23,void node.anonymous_namespace_79.Parser.Consume (FunctionCallbackInfo<Value>)
201497,METHOD,node.anonymous_namespace_49.Parser,TYPE_DECL,"static void Unconsume(const FunctionCallbackInfo<Value>& args) {
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    // Already unconsumed
    if (parser->stream_ == nullptr)
      return;

    parser->stream_->RemoveStreamListener(parser);
  }",3,3,node_http_parser.cc,node.anonymous_namespace_80.Parser.Unconsume,,false,694,703,Unconsume,,,24,void node.anonymous_namespace_80.Parser.Unconsume (FunctionCallbackInfo<Value>)
201525,METHOD,node.anonymous_namespace_49.Parser,TYPE_DECL,"static void GetCurrentBuffer(const FunctionCallbackInfo<Value>& args) {
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    Local<Object> ret = Buffer::Copy(
        parser->env(),
        parser->current_buffer_data_,
        parser->current_buffer_len_).ToLocalChecked();

    args.GetReturnValue().Set(ret);
  }",3,3,node_http_parser.cc,node.anonymous_namespace_81.Parser.GetCurrentBuffer,,false,706,716,GetCurrentBuffer,,,25,void node.anonymous_namespace_81.Parser.GetCurrentBuffer (FunctionCallbackInfo<Value>)
201569,METHOD,node.anonymous_namespace_49.Parser,TYPE_DECL,"static void Duration(const FunctionCallbackInfo<Value>& args) {
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    if (parser->last_message_start_ == 0) {
      args.GetReturnValue().Set(0);
      return;
    }

    double duration = (uv_hrtime() - parser->last_message_start_) / 1e6;
    args.GetReturnValue().Set(duration);
  }",3,3,node_http_parser.cc,node.anonymous_namespace_82.Parser.Duration,,false,718,729,Duration,,,26,void node.anonymous_namespace_82.Parser.Duration (FunctionCallbackInfo<Value>)
201616,METHOD,node.anonymous_namespace_49.Parser,TYPE_DECL,"static void HeadersCompleted(const FunctionCallbackInfo<Value>& args) {
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    args.GetReturnValue().Set(parser->headers_completed_);
  }",3,3,node_http_parser.cc,node.anonymous_namespace_83.Parser.HeadersCompleted,,false,731,736,HeadersCompleted,,,27,void node.anonymous_namespace_83.Parser.HeadersCompleted (FunctionCallbackInfo<Value>)
201640,METHOD,node.anonymous_namespace_49.Parser,TYPE_DECL,"uv_buf_t OnStreamAlloc(size_t suggested_size) override {
    // For most types of streams, OnStreamRead will be immediately after
    // OnStreamAlloc, and will consume all data, so using a static buffer for
    // reading is more efficient. For other streams, just use Malloc() directly.
    if (binding_data_->parser_buffer_in_use)
      return uv_buf_init(Malloc(suggested_size), suggested_size);
    binding_data_->parser_buffer_in_use = true;

    if (binding_data_->parser_buffer.empty())
      binding_data_->parser_buffer.resize(kAllocBufferSize);

    return uv_buf_init(binding_data_->parser_buffer.data(), kAllocBufferSize);
  }",3,3,node_http_parser.cc,node.anonymous_namespace_84.Parser.OnStreamAlloc,,false,741,753,OnStreamAlloc,,,29,uv_buf_t node.anonymous_namespace_84.Parser.OnStreamAlloc (size_t)
201684,METHOD,node.anonymous_namespace_49.Parser,TYPE_DECL,"void OnStreamRead(ssize_t nread, const uv_buf_t& buf) override {
    HandleScope scope(env()->isolate());
    // Once were done here, either indicate that the HTTP parser buffer
    // is free for re-use, or free() the data if it didnt come from there
    // in the first place.
    auto on_scope_leave = OnScopeLeave([&]() {
      if (buf.base == binding_data_->parser_buffer.data())
        binding_data_->parser_buffer_in_use = false;
      else
        free(buf.base);
    });

    if (nread < 0) {
      PassReadErrorToPreviousListener(nread);
      return;
    }

    // Ignore, empty reads have special meaning in http parser
    if (nread == 0)
      return;

    Local<Value> ret = Execute(buf.base, nread);

    // Exception
    if (ret.IsEmpty())
      return;

    Local<Value> cb =
        object()->Get(env()->context(), kOnExecute).ToLocalChecked();

    if (!cb->IsFunction())
      return;

    // Hooks for GetCurrentBuffer
    current_buffer_len_ = nread;
    current_buffer_d...",3,3,node_http_parser.cc,node.anonymous_namespace_85.Parser.OnStreamRead,,false,756,797,OnStreamRead,,,30,"void node.anonymous_namespace_85.Parser.OnStreamRead (ssize_t,uv_buf_t)"
201780,METHOD,node.anonymous_namespace_49.Parser,TYPE_DECL,"Local<Value> Execute(const char* data, size_t len) {
    EscapableHandleScope scope(env()->isolate());

    current_buffer_len_ = len;
    current_buffer_data_ = data;
    got_exception_ = false;

    llhttp_errno_t err;

    if (data == nullptr) {
      err = llhttp_finish(&parser_);
    } else {
      err = llhttp_execute(&parser_, data, len);
      Save();
    }

    // Calculate bytes read and resume after Upgrade/CONNECT pause
    size_t nread = len;
    if (err != HPE_OK) {
      nread = llhttp_get_error_pos(&parser_) - data;

      // This isn't a real pause, just a way to stop parsing early.
      if (err == HPE_PAUSED_UPGRADE) {
        err = HPE_OK;
        llhttp_resume_after_upgrade(&parser_);
      }
    }

    // Apply pending pause
    if (pending_pause_) {
      pending_pause_ = false;
      llhttp_pause(&parser_);
    }

    current_buffer_len_ = 0;
    current_buffer_data_ = nullptr;

    // If there was an exception in one of the callbacks
    if (got_exception_)
...",3,3,node_http_parser.cc,node.anonymous_namespace_87.Parser.Execute,,false,800,878,Execute,,,31,"Local<Value> node.anonymous_namespace_87.Parser.Execute (char*,size_t)"
202074,METHOD,node.anonymous_namespace_49.Parser,TYPE_DECL,"Local<Array> CreateHeaders() {
    // There could be extra entries but the max size should be fixed
    Local<Value> headers_v[kMaxHeaderFieldsCount * 2];

    for (size_t i = 0; i < num_values_; ++i) {
      headers_v[i * 2] = fields_[i].ToString(env());
      headers_v[i * 2 + 1] = values_[i].ToTrimmedString(env());
    }

    return Array::New(env()->isolate(), headers_v, num_values_ * 2);
  }",3,3,node_http_parser.cc,node.anonymous_namespace_89.Parser.CreateHeaders,,false,880,890,CreateHeaders,,,32,Local<Array> node.anonymous_namespace_89.Parser.CreateHeaders ()
202140,METHOD,node.anonymous_namespace_49.Parser,TYPE_DECL,"void Flush() {
    HandleScope scope(env()->isolate());

    Local<Object> obj = object();
    Local<Value> cb = obj->Get(env()->context(), kOnHeaders).ToLocalChecked();

    if (!cb->IsFunction())
      return;

    Local<Value> argv[2] = {
      CreateHeaders(),
      url_.ToString(env())
    };

    MaybeLocal<Value> r = MakeCallback(cb.As<Function>(),
                                       arraysize(argv),
                                       argv);

    if (r.IsEmpty())
      got_exception_ = true;

    url_.Reset();
    have_flushed_ = true;
  }",3,3,node_http_parser.cc,node.anonymous_namespace_90.Parser.Flush,,false,894,917,Flush,,,33,void node.anonymous_namespace_90.Parser.Flush ()
202221,METHOD,node.anonymous_namespace_49.Parser,TYPE_DECL,"void Init(llhttp_type_t type, uint64_t max_http_header_size,
            uint32_t lenient_flags) {
    llhttp_init(&parser_, type, &settings);

    if (lenient_flags & kLenientHeaders) {
      llhttp_set_lenient_headers(&parser_, 1);
    }
    if (lenient_flags & kLenientChunkedLength) {
      llhttp_set_lenient_chunked_length(&parser_, 1);
    }
    if (lenient_flags & kLenientKeepAlive) {
      llhttp_set_lenient_keep_alive(&parser_, 1);
    }

    header_nread_ = 0;
    url_.Reset();
    status_message_.Reset();
    num_fields_ = 0;
    num_values_ = 0;
    have_flushed_ = false;
    got_exception_ = false;
    headers_completed_ = false;
    max_http_header_size_ = max_http_header_size;
  }",3,3,node_http_parser.cc,node.anonymous_namespace_91.Parser.Init,,false,920,943,Init,,,34,"void node.anonymous_namespace_91.Parser.Init (llhttp_type_t,uint64_t,uint32_t)"
202290,METHOD,node.anonymous_namespace_49.Parser,TYPE_DECL,"int TrackHeader(size_t len) {
    header_nread_ += len;
    if (header_nread_ >= max_http_header_size_) {
      llhttp_set_error_reason(&parser_, ""HPE_HEADER_OVERFLOW:Header overflow"");
      return HPE_USER;
    }
    return 0;
  }",3,3,node_http_parser.cc,node.anonymous_namespace_92.Parser.TrackHeader,,false,946,953,TrackHeader,,,35,int node.anonymous_namespace_92.Parser.TrackHeader (size_t)
202311,METHOD,node.anonymous_namespace_49.Parser,TYPE_DECL,"int MaybePause() {
    if (!pending_pause_) {
      return 0;
    }

    pending_pause_ = false;
    llhttp_set_error_reason(&parser_, ""Paused in callback"");
    return HPE_PAUSED;
  }",3,3,node_http_parser.cc,node.anonymous_namespace_93.Parser.MaybePause,,false,956,964,MaybePause,,,36,int node.anonymous_namespace_93.Parser.MaybePause ()
202330,METHOD,node.anonymous_namespace_49.Parser,TYPE_DECL,"bool IsNotIndicativeOfMemoryLeakAtExit() const override {
    // HTTP parsers are able to emit events without any GC root referring
    // to them, because they receive events directly from the underlying
    // libuv resource.
    return true;
  }",3,3,node_http_parser.cc,node.anonymous_namespace_94.Parser.IsNotIndicativeOfMemoryLeakAtExit,,false,967,972,IsNotIndicativeOfMemoryLeakAtExit,,,37,bool node.anonymous_namespace_94.Parser.IsNotIndicativeOfMemoryLeakAtExit ()
202356,METHOD,"node.anonymous_namespace_96.Parser.Proxy<int(Parser.*)(Args...),Member>",TYPE_DECL,"static int Raw(llhttp_t* p, Args ... args) {
      Parser* parser = ContainerOf(&Parser::parser_, p);
      int rv = (parser->*Member)(std::forward<Args>(args)...);
      if (rv == 0) {
        rv = parser->MaybePause();
      }
      return rv;
    }",5,5,node_http_parser.cc,"node.anonymous_namespace_97.Parser.Proxy<int (Parser.*)(Args...),Member>.Raw",,false,1000,1007,Raw,,,1,"int node.anonymous_namespace_97.Parser.Proxy<int (Parser.*)(Args...),Member>.Raw (llhttp_t*,Args)"
202398,METHOD,node.anonymous_namespace_49.Parser,TYPE_DECL,typedef int (Parser::*Call)();,15,31,node_http_parser.cc,node.anonymous_namespace_98.Parser.Call,,false,1010,1010,Call,,,58,int node.anonymous_namespace_98.Parser.Call ()
202402,METHOD,node.anonymous_namespace_49.Parser,TYPE_DECL,"typedef int (Parser::*DataCall)(const char* at, size_t length);",15,64,node_http_parser.cc,node.anonymous_namespace_99.Parser.DataCall,,false,1011,1011,DataCall,,,59,"int node.anonymous_namespace_99.Parser.DataCall (char*,size_t)"
202409,METHOD,<empty>,<empty>,<empty>,1,,node_http_parser.cc,node.anonymous_namespace_49.Parser:<clinit>,,false,238,,<clinit>,,,61,
202431,METHOD,node_http_parser.cc:<global>,TYPE_DECL,"bool ParserComparator::operator()(const Parser* lhs, const Parser* rhs) const {
  if (lhs->last_message_start_ == 0 && rhs->last_message_start_ == 0) {
    // When both parsers are idle, guarantee strict order by
    // comparing pointers as ints.
    return lhs < rhs;
  } else if (lhs->last_message_start_ == 0) {
    return true;
  } else if (rhs->last_message_start_ == 0) {
    return false;
  }

  return lhs->last_message_start_ < rhs->last_message_start_;
}",1,1,node_http_parser.cc,node.anonymous_namespace_100.ParserComparator.operator (),,false,1016,1028,operator (),,,34,"bool node.anonymous_namespace_100.ParserComparator.operator () (Parser*,Parser*)"
202484,METHOD,node_http_parser.cc:<global>,TYPE_DECL,"void ConnectionsList::New(const FunctionCallbackInfo<Value>& args) {
  Local<Context> context = args.GetIsolate()->GetCurrentContext();
  Environment* env = Environment::GetCurrent(context);

  new ConnectionsList(env, args.This());
}",1,1,node_http_parser.cc,node.anonymous_namespace_101.ConnectionsList.New,,false,1030,1035,New,,,35,void node.anonymous_namespace_101.ConnectionsList.New (FunctionCallbackInfo<Value>)
202517,METHOD,node_http_parser.cc:<global>,TYPE_DECL,"void ConnectionsList::All(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();

  ConnectionsList* list;

  ASSIGN_OR_RETURN_UNWRAP(&list, args.Holder());

  std::vector<Local<Value>> result;
  result.reserve(list->all_connections_.size());
  for (auto parser : list->all_connections_) {
    result.emplace_back(parser->object());
  }

  return args.GetReturnValue().Set(
      Array::New(isolate, result.data(), result.size()));
}",1,1,node_http_parser.cc,node.anonymous_namespace_102.ConnectionsList.All,,false,1037,1052,All,,,36,void node.anonymous_namespace_102.ConnectionsList.All (FunctionCallbackInfo<Value>)
202591,METHOD,node_http_parser.cc:<global>,TYPE_DECL,"void ConnectionsList::Idle(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();

  ConnectionsList* list;

  ASSIGN_OR_RETURN_UNWRAP(&list, args.Holder());

  std::vector<Local<Value>> result;
  result.reserve(list->all_connections_.size());
  for (auto parser : list->all_connections_) {
    if (parser->last_message_start_ == 0) {
      result.emplace_back(parser->object());
    }
  }

  return args.GetReturnValue().Set(
      Array::New(isolate, result.data(), result.size()));
}",1,1,node_http_parser.cc,node.anonymous_namespace_103.ConnectionsList.Idle,,false,1054,1071,Idle,,,37,void node.anonymous_namespace_103.ConnectionsList.Idle (FunctionCallbackInfo<Value>)
202672,METHOD,node_http_parser.cc:<global>,TYPE_DECL,"void ConnectionsList::Active(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();

  ConnectionsList* list;

  ASSIGN_OR_RETURN_UNWRAP(&list, args.Holder());

  std::vector<Local<Value>> result;
  result.reserve(list->active_connections_.size());
  for (auto parser : list->active_connections_) {
    result.emplace_back(parser->object());
  }

  return args.GetReturnValue().Set(
      Array::New(isolate, result.data(), result.size()));
}",1,1,node_http_parser.cc,node.anonymous_namespace_104.ConnectionsList.Active,,false,1073,1088,Active,,,38,void node.anonymous_namespace_104.ConnectionsList.Active (FunctionCallbackInfo<Value>)
202746,METHOD,node_http_parser.cc:<global>,TYPE_DECL,"void ConnectionsList::Expired(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();

  ConnectionsList* list;

  ASSIGN_OR_RETURN_UNWRAP(&list, args.Holder());
  CHECK(args[0]->IsNumber());
  CHECK(args[1]->IsNumber());
  uint64_t headers_timeout =
    static_cast<uint64_t>(args[0].As<Uint32>()->Value()) * 1000000;
  uint64_t request_timeout =
    static_cast<uint64_t>(args[1].As<Uint32>()->Value()) * 1000000;

  if (headers_timeout == 0 && request_timeout == 0) {
    return args.GetReturnValue().Set(Array::New(isolate, 0));
  } else if (request_timeout > 0 && headers_timeout > request_timeout) {
    std::swap(headers_timeout, request_timeout);
  }

  // On IoT or embedded devices the uv_hrtime() may return the timestamp
  // that is smaller than configured timeout for headers or request
  // to prevent subtracting two unsigned integers
  // that can yield incorrect results we should check
  // if the 'now' is bigger than the timeout for headers or reque...",1,1,node_http_parser.cc,node.anonymous_namespace_105.ConnectionsList.Expired,,false,1090,1151,Expired,,,39,void node.anonymous_namespace_105.ConnectionsList.Expired (FunctionCallbackInfo<Value>)
203067,METHOD,node_http_parser.cc:<global>,TYPE_DECL,"void InitializeHttpParser(Local<Object> target,
                          Local<Value> unused,
                          Local<Context> context,
                          void* priv) {
  Realm* realm = Realm::GetCurrent(context);
  Environment* env = realm->env();
  Isolate* isolate = env->isolate();
  BindingData* const binding_data =
      realm->AddBindingData<BindingData>(context, target);
  if (binding_data == nullptr) return;

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, Parser::New);
  t->InstanceTemplate()->SetInternalFieldCount(Parser::kInternalFieldCount);

  t->Set(FIXED_ONE_BYTE_STRING(env->isolate(), ""REQUEST""),
         Integer::New(env->isolate(), HTTP_REQUEST));
  t->Set(FIXED_ONE_BYTE_STRING(env->isolate(), ""RESPONSE""),
         Integer::New(env->isolate(), HTTP_RESPONSE));
  t->Set(FIXED_ONE_BYTE_STRING(env->isolate(), ""kOnMessageBegin""),
         Integer::NewFromUnsigned(env->isolate(), kOnMessageBegin));
  t->Set(FIXED_ONE_BYTE_STRING(env->isolate()...",1,1,node_http_parser.cc,node.anonymous_namespace_106.InitializeHttpParser,,false,1199,1279,InitializeHttpParser,,,42,"void node.anonymous_namespace_106.InitializeHttpParser (Local<Object>,Local<Value>,Local<Context>,void*)"
203648,METHOD,node_i18n.cc:<global>,TYPE_DECL,<global>,1,1,node_i18n.cc,node_i18n.cc:<global>,,false,1,913,<global>,,,1,
203665,METHOD,node_i18n.hpp:<global>,TYPE_DECL,<global>,1,27,node_i18n.hpp,node_i18n.hpp:<global>,,false,1,145,<global>,,,1,
203694,METHOD,node_internals.hpp:<global>,TYPE_DECL,<global>,1,32,node_internals.hpp,node_internals.hpp:<global>,,false,1,443,<global>,,,1,
203709,METHOD,node_main.cc:<global>,TYPE_DECL,<global>,1,1,node_main.cc,node_main.cc:<global>,,false,1,99,<global>,,,1,
203711,METHOD,node_main.cc:<global>,TYPE_DECL,"int main(int argc, char* argv[]) {
  return node::Start(argc, argv);
}",1,1,node_main.cc,main,,false,96,98,main,,,1,"int main (int,char[]*)"
203759,METHOD,node_main_instance.cc:<global>,TYPE_DECL,<global>,1,36,node_main_instance.hpp,node_main_instance.cc:<global>,,false,1,148,<global>,,,1,
203762,METHOD,node_main_instance.cc:<global>,TYPE_DECL,"NodeMainInstance::NodeMainInstance(const SnapshotData* snapshot_data,
                                   uv_loop_t* event_loop,
                                   MultiIsolatePlatform* platform,
                                   const std::vector<std::string>& args,
                                   const std::vector<std::string>& exec_args)
    : args_(args),
      exec_args_(exec_args),
      array_buffer_allocator_(ArrayBufferAllocator::Create()),
      isolate_(nullptr),
      platform_(platform),
      isolate_data_(),
      isolate_params_(std::make_unique<Isolate::CreateParams>()),
      snapshot_data_(snapshot_data) {
  isolate_params_->array_buffer_allocator = array_buffer_allocator_.get();

  isolate_ =
      NewIsolate(isolate_params_.get(), event_loop, platform, snapshot_data);
  CHECK_NOT_NULL(isolate_);

  // If the indexes are not nullptr, we are not deserializing
  isolate_data_.reset(
      CreateIsolateData(isolate_,
                        event_loop,
          ...",1,1,node_main_instance.cc,node.NodeMainInstance.NodeMainInstance,,false,33,64,NodeMainInstance,,,1,"ANY node.NodeMainInstance.NodeMainInstance (SnapshotData*,uv_loop_t*,MultiIsolatePlatform*,ANY,ANY)"
203830,METHOD,node_main_instance.cc:<global>,TYPE_DECL,"NodeMainInstance::~NodeMainInstance() {
  if (isolate_params_ == nullptr) {
    return;
  }
  // This should only be done on a main instance that owns its isolate.
  platform_->UnregisterIsolate(isolate_);
  isolate_->Dispose();
}",1,1,node_main_instance.cc,node.NodeMainInstance.~NodeMainInstance,,false,66,73,~NodeMainInstance,,,2,ANY node.NodeMainInstance.~NodeMainInstance ()
203849,METHOD,node_main_instance.cc:<global>,TYPE_DECL,"ExitCode NodeMainInstance::Run() {
  Locker locker(isolate_);
  Isolate::Scope isolate_scope(isolate_);
  HandleScope handle_scope(isolate_);

  ExitCode exit_code = ExitCode::kNoFailure;
  DeleteFnPtr<Environment, FreeEnvironment> env =
      CreateMainEnvironment(&exit_code);
  CHECK_NOT_NULL(env);

  Context::Scope context_scope(env->context());
  Run(&exit_code, env.get());
  return exit_code;
}",1,1,node_main_instance.cc,node.NodeMainInstance.Run,,false,75,88,Run,,,3,ExitCode node.NodeMainInstance.Run ()
203895,METHOD,node_main_instance.cc:<global>,TYPE_DECL,"void NodeMainInstance::Run(ExitCode* exit_code, Environment* env) {
  if (*exit_code == ExitCode::kNoFailure) {
    bool runs_sea_code = false;
#ifndef DISABLE_SINGLE_EXECUTABLE_APPLICATION
    if (sea::IsSingleExecutable()) {
      runs_sea_code = true;
      sea::SeaResource sea = sea::FindSingleExecutableResource();
      std::string_view code = sea.code;
      LoadEnvironment(env, code);
    }
#endif
    if (!runs_sea_code) {
      LoadEnvironment(env, StartExecutionCallback{});
    }

    *exit_code =
        SpinEventLoopInternal(env).FromMaybe(ExitCode::kGenericUserError);
  }

#if defined(LEAK_SANITIZER)
  __lsan_do_leak_check();
#endif
}",1,1,node_main_instance.cc,node.NodeMainInstance.Run,,false,90,112,Run,,,4,"void node.NodeMainInstance.Run (ExitCode*,Environment*)"
203957,METHOD,node_main_instance.cc:<global>,TYPE_DECL,"DeleteFnPtr<Environment, FreeEnvironment>
NodeMainInstance::CreateMainEnvironment(ExitCode* exit_code) {
  *exit_code = ExitCode::kNoFailure;  // Reset the exit code to 0

  HandleScope handle_scope(isolate_);

  // TODO(addaleax): This should load a real per-Isolate option, currently
  // this is still effectively per-process.
  if (isolate_data_->options()->track_heap_objects) {
    isolate_->GetHeapProfiler()->StartTrackingHeapObjects(true);
  }

  Local<Context> context;
  DeleteFnPtr<Environment, FreeEnvironment> env;

  if (snapshot_data_ != nullptr) {
    env.reset(CreateEnvironment(isolate_data_.get(),
                                Local<Context>(),  // read from snapshot
                                args_,
                                exec_args_));
#if HAVE_OPENSSL
    crypto::InitCryptoOnce(isolate_);
#endif  // HAVE_OPENSSL
  } else {
    context = NewContext(isolate_);
    CHECK(!context.IsEmpty());
    Context::Scope context_scope(context);
    env.reset(
      ...",1,1,node_main_instance.cc,node.NodeMainInstance.CreateMainEnvironment,,false,114,146,CreateMainEnvironment,,,5,"DeleteFnPtr<Environment,FreeEnvironment> node.NodeMainInstance.CreateMainEnvironment (ExitCode*)"
204062,METHOD,node_main_instance.hpp:<global>,TYPE_DECL,<global>,1,36,node_main_instance.hpp,node_main_instance.hpp:<global>,,false,1,67,<global>,,,1,
204071,METHOD,node_mem-inl.hpp:<global>,TYPE_DECL,<global>,1,30,node_mem-inl.hpp,node_mem-inl.hpp:<global>,,false,1,112,<global>,,,1,
204078,METHOD,node_mem.hpp:<global>,TYPE_DECL,<global>,1,26,node_mem.hpp,node_mem.hpp:<global>,,false,1,45,<global>,,,1,
204081,METHOD,node_messaging.cc:<global>,TYPE_DECL,"[&]() {
    for (BaseObjectPtr<BaseObject> object : host_objects) {
      if (!object) continue;

      // If the function did not finish successfully, host_objects will contain
      // a list of objects that will never be passed to JS. Therefore, we
      // destroy them here.
      object->Detach();
    }
  }",31,3,node_messaging.cc,node.worker.Message.Deserialize.<lambda>0,,false,166,175,<lambda>0,,,1,ANY node.worker.Message.Deserialize.<lambda>0 ()
204100,METHOD,node_messaging.cc:<global>,TYPE_DECL,"[](uv_async_t* handle) {
    // Called when data has been put into the queue.
    MessagePort* channel = ContainerOf(&MessagePort::async_, handle);
    channel->OnMessage(MessageProcessingMode::kNormalOperation);
  }",20,3,node_messaging.cc,node.worker.MessagePort.MessagePort.<lambda>1,,false,641,645,<lambda>1,,,1,ANY node.worker.MessagePort.MessagePort.<lambda>1 (uv_async_t*)
204122,METHOD,node_messaging.cc:<global>,TYPE_DECL,[&]() { if (!succeeded) Close(); },31,64,node_messaging.cc,node.worker.MessagePort.MessagePort.<lambda>2,,false,652,652,<lambda>2,,,1,ANY node.worker.MessagePort.MessagePort.<lambda>2 ()
204154,METHOD,node_messaging.cc:<global>,TYPE_DECL,<global>,1,32,node_messaging.hpp,node_messaging.cc:<global>,,false,1,1580,<global>,,,1,
204165,METHOD,node_messaging.cc:<global>,TYPE_DECL,"BaseObject::TransferMode BaseObject::GetTransferMode() const {
  return BaseObject::TransferMode::kUntransferable;
}",1,1,node_messaging.cc,node.BaseObject.GetTransferMode,,false,50,52,GetTransferMode,,,4,TransferMode node.BaseObject.GetTransferMode ()
204175,METHOD,node_messaging.cc:<global>,TYPE_DECL,"std::unique_ptr<worker::TransferData> BaseObject::TransferForMessaging() {
  return CloneForMessaging();
}",1,1,node_messaging.cc,node.BaseObject.TransferForMessaging,,false,54,56,TransferForMessaging,,,5,unique_ptr<worker::TransferData> node.BaseObject.TransferForMessaging ()
204181,METHOD,node_messaging.cc:<global>,TYPE_DECL,"std::unique_ptr<worker::TransferData> BaseObject::CloneForMessaging() const {
  return {};
}",1,1,node_messaging.cc,node.BaseObject.CloneForMessaging,,false,58,60,CloneForMessaging,,,6,unique_ptr<worker::TransferData> node.BaseObject.CloneForMessaging ()
204186,METHOD,node_messaging.cc:<global>,TYPE_DECL,"Maybe<BaseObjectList> BaseObject::NestedTransferables() const {
  return Just(BaseObjectList {});
}",1,1,node_messaging.cc,node.BaseObject.NestedTransferables,,false,62,64,NestedTransferables,,,7,Maybe<BaseObjectList> node.BaseObject.NestedTransferables ()
204194,METHOD,node_messaging.cc:<global>,TYPE_DECL,"Maybe<bool> BaseObject::FinalizeTransferRead(
    Local<Context> context, ValueDeserializer* deserializer) {
  return Just(true);
}",1,1,node_messaging.cc,node.BaseObject.FinalizeTransferRead,,false,66,69,FinalizeTransferRead,,,8,"Maybe<bool> node.BaseObject.FinalizeTransferRead (Local<Context>,ValueDeserializer*)"
204204,METHOD,node_messaging.cc:<global>,TYPE_DECL,"Maybe<bool> TransferData::FinalizeTransferWrite(
    Local<Context> context, ValueSerializer* serializer) {
  return Just(true);
}",1,1,node_messaging.cc,node.worker.TransferData.FinalizeTransferWrite,,false,73,76,FinalizeTransferWrite,,,1,"Maybe<bool> node.worker.TransferData.FinalizeTransferWrite (Local<Context>,ValueSerializer*)"
204213,METHOD,node_messaging.cc:<global>,TYPE_DECL,"Message::Message(MallocedBuffer<char>&& buffer)
    : main_message_buf_(std::move(buffer)) {}",1,45,node_messaging.cc,node.worker.Message.Message,,false,78,79,Message,,,2,ANY node.worker.Message.Message (MallocedBuffer<char>)
204218,METHOD,node_messaging.cc:<global>,TYPE_DECL,"bool Message::IsCloseMessage() const {
  return main_message_buf_.data == nullptr;
}",1,1,node_messaging.cc,node.worker.Message.IsCloseMessage,,false,81,83,IsCloseMessage,,,3,bool node.worker.Message.IsCloseMessage ()
204230,METHOD,node.worker.anonymous_namespace_1.DeserializerDelegate,TYPE_DECL,"DeserializerDelegate(
      Message* m,
      Environment* env,
      const std::vector<BaseObjectPtr<BaseObject>>& host_objects,
      const std::vector<Local<SharedArrayBuffer>>& shared_array_buffers,
      const std::vector<CompiledWasmModule>& wasm_modules,
      const std::optional<SharedValueConveyor>& shared_value_conveyor)
      : host_objects_(host_objects),
        shared_array_buffers_(shared_array_buffers),
        wasm_modules_(wasm_modules),
        shared_value_conveyor_(shared_value_conveyor) {}",3,56,node_messaging.cc,node.worker.anonymous_namespace_2.DeserializerDelegate.DeserializerDelegate,,false,91,101,DeserializerDelegate,,,1,"ANY node.worker.anonymous_namespace_2.DeserializerDelegate.DeserializerDelegate (Message*,Environment*,ANY,ANY,ANY,ANY)"
204240,METHOD,node.worker.anonymous_namespace_1.DeserializerDelegate,TYPE_DECL,"MaybeLocal<Object> ReadHostObject(Isolate* isolate) override {
    // Identifying the index in the message's BaseObject array is sufficient.
    uint32_t id;
    if (!deserializer->ReadUint32(&id))
      return MaybeLocal<Object>();
    if (id != kNormalObject) {
      CHECK_LT(id, host_objects_.size());
      return host_objects_[id]->object(isolate);
    }
    EscapableHandleScope scope(isolate);
    Local<Context> context = isolate->GetCurrentContext();
    Local<Value> object;
    if (!deserializer->ReadValue(context).ToLocal(&object))
      return MaybeLocal<Object>();
    CHECK(object->IsObject());
    return scope.Escape(object.As<Object>());
  }",3,3,node_messaging.cc,node.worker.anonymous_namespace_3.DeserializerDelegate.ReadHostObject,,false,103,119,ReadHostObject,,,2,MaybeLocal<Object> node.worker.anonymous_namespace_3.DeserializerDelegate.ReadHostObject (Isolate*)
204323,METHOD,node.worker.anonymous_namespace_1.DeserializerDelegate,TYPE_DECL,"MaybeLocal<SharedArrayBuffer> GetSharedArrayBufferFromId(
      Isolate* isolate, uint32_t clone_id) override {
    CHECK_LT(clone_id, shared_array_buffers_.size());
    return shared_array_buffers_[clone_id];
  }",3,3,node_messaging.cc,node.worker.anonymous_namespace_4.DeserializerDelegate.GetSharedArrayBufferFromId,,false,121,125,GetSharedArrayBufferFromId,,,3,"MaybeLocal<SharedArrayBuffer> node.worker.anonymous_namespace_4.DeserializerDelegate.GetSharedArrayBufferFromId (Isolate*,uint32_t)"
204339,METHOD,node.worker.anonymous_namespace_1.DeserializerDelegate,TYPE_DECL,"MaybeLocal<WasmModuleObject> GetWasmModuleFromId(
      Isolate* isolate, uint32_t transfer_id) override {
    CHECK_LT(transfer_id, wasm_modules_.size());
    return WasmModuleObject::FromCompiledModule(
        isolate, wasm_modules_[transfer_id]);
  }",3,3,node_messaging.cc,node.worker.anonymous_namespace_5.DeserializerDelegate.GetWasmModuleFromId,,false,127,132,GetWasmModuleFromId,,,4,"MaybeLocal<WasmModuleObject> node.worker.anonymous_namespace_5.DeserializerDelegate.GetWasmModuleFromId (Isolate*,uint32_t)"
204360,METHOD,node.worker.anonymous_namespace_1.DeserializerDelegate,TYPE_DECL,"const SharedValueConveyor* GetSharedValueConveyor(Isolate* isolate) override {
    CHECK(shared_value_conveyor_.has_value());
    return &shared_value_conveyor_.value();
  }",3,3,node_messaging.cc,node.worker.anonymous_namespace_6.DeserializerDelegate.GetSharedValueConveyor,,false,134,137,GetSharedValueConveyor,,,5,SharedValueConveyor node.worker.anonymous_namespace_6.DeserializerDelegate.GetSharedValueConveyor (Isolate*)
204381,METHOD,<empty>,<empty>,<empty>,1,,node_messaging.cc,node.worker.anonymous_namespace_1.DeserializerDelegate:<clinit>,,false,89,,<clinit>,,,11,
204388,METHOD,node_messaging.cc:<global>,TYPE_DECL,"MaybeLocal<Value> Message::Deserialize(Environment* env,
                                       Local<Context> context,
                                       Local<Value>* port_list) {
  Context::Scope context_scope(context);

  CHECK(!IsCloseMessage());
  if (port_list != nullptr && !transferables_.empty()) {
    // Need to create this outside of the EscapableHandleScope, but inside
    // the Context::Scope.
    *port_list = Array::New(env->isolate());
  }

  EscapableHandleScope handle_scope(env->isolate());

  // Create all necessary objects for transferables, e.g. MessagePort handles.
  std::vector<BaseObjectPtr<BaseObject>> host_objects(transferables_.size());
  auto cleanup = OnScopeLeave([&]() {
    for (BaseObjectPtr<BaseObject> object : host_objects) {
      if (!object) continue;

      // If the function did not finish successfully, host_objects will contain
      // a list of objects that will never be passed to JS. Therefore, we
      // destroy them here.
      objec...",1,1,node_messaging.cc,node.worker.Message.Deserialize,,false,150,243,Deserialize,,,5,"MaybeLocal<Value> node.worker.Message.Deserialize (Environment*,Local<Context>,Local<Value>*)"
204739,METHOD,node_messaging.cc:<global>,TYPE_DECL,"void Message::AddSharedArrayBuffer(
    std::shared_ptr<BackingStore> backing_store) {
  shared_array_buffers_.emplace_back(std::move(backing_store));
}",1,1,node_messaging.cc,node.worker.Message.AddSharedArrayBuffer,,false,245,248,AddSharedArrayBuffer,,,6,void node.worker.Message.AddSharedArrayBuffer (ANY)
204753,METHOD,node_messaging.cc:<global>,TYPE_DECL,"void Message::AddTransferable(std::unique_ptr<TransferData>&& data) {
  transferables_.emplace_back(std::move(data));
}",1,1,node_messaging.cc,node.worker.Message.AddTransferable,,false,250,252,AddTransferable,,,7,void node.worker.Message.AddTransferable (ANY)
204767,METHOD,node_messaging.cc:<global>,TYPE_DECL,"uint32_t Message::AddWASMModule(CompiledWasmModule&& mod) {
  wasm_modules_.emplace_back(std::move(mod));
  return wasm_modules_.size() - 1;
}",1,1,node_messaging.cc,node.worker.Message.AddWASMModule,,false,254,257,AddWASMModule,,,8,uint32_t node.worker.Message.AddWASMModule (CompiledWasmModule)
204788,METHOD,node_messaging.cc:<global>,TYPE_DECL,"void Message::AdoptSharedValueConveyor(SharedValueConveyor&& conveyor) {
  shared_value_conveyor_.emplace(std::move(conveyor));
}",1,1,node_messaging.cc,node.worker.Message.AdoptSharedValueConveyor,,false,259,261,AdoptSharedValueConveyor,,,9,void node.worker.Message.AdoptSharedValueConveyor (SharedValueConveyor)
204803,METHOD,node_messaging.cc:<global>,TYPE_DECL,"MaybeLocal<Function> GetEmitMessageFunction(Local<Context> context) {
  Isolate* isolate = context->GetIsolate();
  Local<Object> per_context_bindings;
  Local<Value> emit_message_val;
  if (!GetPerContextExports(context).ToLocal(&per_context_bindings) ||
      !per_context_bindings->Get(context,
                                FIXED_ONE_BYTE_STRING(isolate, ""emitMessage""))
          .ToLocal(&emit_message_val)) {
    return MaybeLocal<Function>();
  }
  CHECK(emit_message_val->IsFunction());
  return emit_message_val.As<Function>();
}",1,1,node_messaging.cc,node.worker.anonymous_namespace_8.GetEmitMessageFunction,,false,265,277,GetEmitMessageFunction,,,1,MaybeLocal<Function> node.worker.anonymous_namespace_8.GetEmitMessageFunction (Local<Context>)
204862,METHOD,node_messaging.cc:<global>,TYPE_DECL,"MaybeLocal<Function> GetDOMException(Local<Context> context) {
  Isolate* isolate = context->GetIsolate();
  Local<Object> per_context_bindings;
  Local<Value> domexception_ctor_val;
  if (!GetPerContextExports(context).ToLocal(&per_context_bindings) ||
      !per_context_bindings->Get(context,
                                FIXED_ONE_BYTE_STRING(isolate, ""DOMException""))
          .ToLocal(&domexception_ctor_val)) {
    return MaybeLocal<Function>();
  }
  CHECK(domexception_ctor_val->IsFunction());
  Local<Function> domexception_ctor = domexception_ctor_val.As<Function>();
  return domexception_ctor;
}",1,1,node_messaging.cc,node.worker.anonymous_namespace_9.GetDOMException,,false,279,292,GetDOMException,,,2,MaybeLocal<Function> node.worker.anonymous_namespace_9.GetDOMException (Local<Context>)
204928,METHOD,node_messaging.cc:<global>,TYPE_DECL,"void ThrowDataCloneException(Local<Context> context, Local<String> message) {
  Isolate* isolate = context->GetIsolate();
  Local<Value> argv[] = {message,
                         FIXED_ONE_BYTE_STRING(isolate, ""DataCloneError"")};
  Local<Value> exception;
  Local<Function> domexception_ctor;
  if (!GetDOMException(context).ToLocal(&domexception_ctor) ||
      !domexception_ctor->NewInstance(context, arraysize(argv), argv)
           .ToLocal(&exception)) {
    return;
  }
  isolate->ThrowException(exception);
}",1,1,node_messaging.cc,node.worker.anonymous_namespace_10.ThrowDataCloneException,,false,294,306,ThrowDataCloneException,,,3,"void node.worker.anonymous_namespace_10.ThrowDataCloneException (Local<Context>,Local<String>)"
204991,METHOD,node.worker.anonymous_namespace_12.SerializerDelegate,TYPE_DECL,"SerializerDelegate(Environment* env, Local<Context> context, Message* m)
      : env_(env), context_(context), msg_(m) {}",3,48,node_messaging.cc,node.worker.anonymous_namespace_13.SerializerDelegate.SerializerDelegate,,false,313,314,SerializerDelegate,,,1,"ANY node.worker.anonymous_namespace_13.SerializerDelegate.SerializerDelegate (Environment*,Local<Context>,Message*)"
204998,METHOD,node.worker.anonymous_namespace_12.SerializerDelegate,TYPE_DECL,"void ThrowDataCloneError(Local<String> message) override {
    ThrowDataCloneException(context_, message);
  }",3,3,node_messaging.cc,node.worker.anonymous_namespace_14.SerializerDelegate.ThrowDataCloneError,,false,316,318,ThrowDataCloneError,,,2,void node.worker.anonymous_namespace_14.SerializerDelegate.ThrowDataCloneError (Local<String>)
205006,METHOD,node.worker.anonymous_namespace_12.SerializerDelegate,TYPE_DECL,"Maybe<bool> WriteHostObject(Isolate* isolate, Local<Object> object) override {
    if (BaseObject::IsBaseObject(object)) {
      return WriteHostObject(
          BaseObjectPtr<BaseObject> { Unwrap<BaseObject>(object) });
    }

    // Convert process.env to a regular object.
    auto env_proxy_ctor_template = env_->env_proxy_ctor_template();
    if (!env_proxy_ctor_template.IsEmpty() &&
        env_proxy_ctor_template->HasInstance(object)) {
      HandleScope scope(isolate);
      // TODO(bnoordhuis) Prototype-less object in case process.env contains
      // a ""__proto__"" key? process.env has a prototype with concomitant
      // methods like toString(). It's probably confusing if that gets lost
      // in transmission.
      Local<Object> normal_object = Object::New(isolate);
      env_->env_vars()->AssignToObject(isolate, env_->context(), normal_object);
      serializer->WriteUint32(kNormalObject);  // Instead of a BaseObject.
      return serializer->WriteValue(env_->context(...",3,3,node_messaging.cc,node.worker.anonymous_namespace_16.SerializerDelegate.WriteHostObject,,false,320,343,WriteHostObject,,,3,"Maybe<bool> node.worker.anonymous_namespace_16.SerializerDelegate.WriteHostObject (Isolate*,Local<Object>)"
205097,METHOD,node.worker.anonymous_namespace_12.SerializerDelegate,TYPE_DECL,"Maybe<uint32_t> GetSharedArrayBufferId(
      Isolate* isolate,
      Local<SharedArrayBuffer> shared_array_buffer) override {
    uint32_t i;
    for (i = 0; i < seen_shared_array_buffers_.size(); ++i) {
      if (PersistentToLocal::Strong(seen_shared_array_buffers_[i]) ==
          shared_array_buffer) {
        return Just(i);
      }
    }

    seen_shared_array_buffers_.emplace_back(
      Global<SharedArrayBuffer> { isolate, shared_array_buffer });
    msg_->AddSharedArrayBuffer(shared_array_buffer->GetBackingStore());
    return Just(i);
  }",3,3,node_messaging.cc,node.worker.anonymous_namespace_18.SerializerDelegate.GetSharedArrayBufferId,,false,345,360,GetSharedArrayBufferId,,,4,"Maybe<uint32_t> node.worker.anonymous_namespace_18.SerializerDelegate.GetSharedArrayBufferId (Isolate*,Local<SharedArrayBuffer>)"
205151,METHOD,node.worker.anonymous_namespace_12.SerializerDelegate,TYPE_DECL,"Maybe<uint32_t> GetWasmModuleTransferId(
      Isolate* isolate, Local<WasmModuleObject> module) override {
    return Just(msg_->AddWASMModule(module->GetCompiledModule()));
  }",3,3,node_messaging.cc,node.worker.anonymous_namespace_19.SerializerDelegate.GetWasmModuleTransferId,,false,362,365,GetWasmModuleTransferId,,,5,"Maybe<uint32_t> node.worker.anonymous_namespace_19.SerializerDelegate.GetWasmModuleTransferId (Isolate*,Local<WasmModuleObject>)"
205167,METHOD,node.worker.anonymous_namespace_12.SerializerDelegate,TYPE_DECL,"bool AdoptSharedValueConveyor(Isolate* isolate,
                                SharedValueConveyor&& conveyor) override {
    msg_->AdoptSharedValueConveyor(std::move(conveyor));
    return true;
  }",3,3,node_messaging.cc,node.worker.anonymous_namespace_20.SerializerDelegate.AdoptSharedValueConveyor,,false,367,371,AdoptSharedValueConveyor,,,6,"bool node.worker.anonymous_namespace_20.SerializerDelegate.AdoptSharedValueConveyor (Isolate*,SharedValueConveyor)"
205184,METHOD,node.worker.anonymous_namespace_12.SerializerDelegate,TYPE_DECL,"Maybe<bool> Finish(Local<Context> context) {
    for (uint32_t i = 0; i < host_objects_.size(); i++) {
      BaseObjectPtr<BaseObject> host_object = std::move(host_objects_[i]);
      std::unique_ptr<TransferData> data;
      if (i < first_cloned_object_index_)
        data = host_object->TransferForMessaging();
      if (!data)
        data = host_object->CloneForMessaging();
      if (!data) return Nothing<bool>();
      if (data->FinalizeTransferWrite(context, serializer).IsNothing())
        return Nothing<bool>();
      msg_->AddTransferable(std::move(data));
    }
    return Just(true);
  }",3,3,node_messaging.cc,node.worker.anonymous_namespace_21.SerializerDelegate.Finish,,false,373,387,Finish,,,7,Maybe<bool> node.worker.anonymous_namespace_21.SerializerDelegate.Finish (Local<Context>)
205276,METHOD,node.worker.anonymous_namespace_12.SerializerDelegate,TYPE_DECL,"inline void AddHostObject(BaseObjectPtr<BaseObject> host_object) {
    // Make sure we have not started serializing the value itself yet.
    CHECK_EQ(first_cloned_object_index_, SIZE_MAX);
    host_objects_.emplace_back(std::move(host_object));
  }",3,3,node_messaging.cc,node.worker.anonymous_namespace_22.SerializerDelegate.AddHostObject,,false,389,393,AddHostObject,,,8,void node.worker.anonymous_namespace_22.SerializerDelegate.AddHostObject (BaseObjectPtr<BaseObject>)
205293,METHOD,node.worker.anonymous_namespace_12.SerializerDelegate,TYPE_DECL,"inline Maybe<bool> AddNestedHostObjects() {
    for (size_t i = 0; i < host_objects_.size(); i++) {
      std::vector<BaseObjectPtr<BaseObject>> nested_transferables;
      if (!host_objects_[i]->NestedTransferables().To(&nested_transferables))
        return Nothing<bool>();
      for (auto& nested_transferable : nested_transferables) {
        if (std::find(host_objects_.begin(),
                      host_objects_.end(),
                      nested_transferable) == host_objects_.end()) {
          AddHostObject(nested_transferable);
        }
      }
    }
    return Just(true);
  }",3,3,node_messaging.cc,node.worker.anonymous_namespace_23.SerializerDelegate.AddNestedHostObjects,,false,398,412,AddNestedHostObjects,,,9,Maybe<bool> node.worker.anonymous_namespace_23.SerializerDelegate.AddNestedHostObjects ()
205367,METHOD,node.worker.anonymous_namespace_12.SerializerDelegate,TYPE_DECL,"Maybe<bool> WriteHostObject(BaseObjectPtr<BaseObject> host_object) {
    BaseObject::TransferMode mode = host_object->GetTransferMode();
    if (mode == BaseObject::TransferMode::kUntransferable) {
      ThrowDataCloneError(env_->clone_unsupported_type_str());
      return Nothing<bool>();
    }

    for (uint32_t i = 0; i < host_objects_.size(); i++) {
      if (host_objects_[i] == host_object) {
        serializer->WriteUint32(i);
        return Just(true);
      }
    }

    if (mode == BaseObject::TransferMode::kTransferable) {
      THROW_ERR_MISSING_TRANSFERABLE_IN_TRANSFER_LIST(env_);
      return Nothing<bool>();
    }

    CHECK_EQ(mode, BaseObject::TransferMode::kCloneable);
    uint32_t index = host_objects_.size();
    if (first_cloned_object_index_ == SIZE_MAX)
      first_cloned_object_index_ = index;
    serializer->WriteUint32(index);
    host_objects_.push_back(host_object);
    return Just(true);
  }",3,3,node_messaging.cc,node.worker.anonymous_namespace_24.SerializerDelegate.WriteHostObject,,false,417,443,WriteHostObject,,,11,Maybe<bool> node.worker.anonymous_namespace_24.SerializerDelegate.WriteHostObject (BaseObjectPtr<BaseObject>)
205480,METHOD,<empty>,<empty>,<empty>,1,,node_messaging.cc,node.worker.anonymous_namespace_12.SerializerDelegate:<clinit>,,false,311,,<clinit>,,,19,
205490,METHOD,node_messaging.cc:<global>,TYPE_DECL,"Maybe<bool> Message::Serialize(Environment* env,
                               Local<Context> context,
                               Local<Value> input,
                               const TransferList& transfer_list_v,
                               Local<Object> source_port) {
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(context);

  // Verify that we're not silently overwriting an existing message.
  CHECK(main_message_buf_.is_empty());

  SerializerDelegate delegate(env, context, this);
  ValueSerializer serializer(env->isolate(), &delegate);
  delegate.serializer = &serializer;

  std::vector<Local<ArrayBuffer>> array_buffers;
  for (uint32_t i = 0; i < transfer_list_v.length(); ++i) {
    Local<Value> entry = transfer_list_v[i];
    if (entry->IsObject()) {
      // See https://github.com/nodejs/node/pull/30339#issuecomment-552225353
      // for details.
      bool untransferable;
      if (!entry.As<Object>()->HasPrivate(
              contex...",1,1,node_messaging.cc,node.worker.Message.Serialize,,false,457,585,Serialize,,,11,"Maybe<bool> node.worker.Message.Serialize (Environment*,Local<Context>,Local<Value>,TransferList,Local<Object>)"
205929,METHOD,node_messaging.cc:<global>,TYPE_DECL,"void Message::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""array_buffers_"", array_buffers_);
  tracker->TrackField(""shared_array_buffers"", shared_array_buffers_);
  tracker->TrackField(""transferables"", transferables_);
}",1,1,node_messaging.cc,node.worker.Message.MemoryInfo,,false,587,591,MemoryInfo,,,12,void node.worker.Message.MemoryInfo (MemoryTracker*)
205952,METHOD,node_messaging.cc:<global>,TYPE_DECL,"MessagePortData::MessagePortData(MessagePort* owner)
    : owner_(owner) {
}",1,1,node_messaging.cc,node.worker.MessagePortData.MessagePortData,,false,593,595,MessagePortData,,,13,ANY node.worker.MessagePortData.MessagePortData (MessagePort*)
205957,METHOD,node_messaging.cc:<global>,TYPE_DECL,"MessagePortData::~MessagePortData() {
  CHECK_NULL(owner_);
  Disentangle();
}",1,1,node_messaging.cc,node.worker.MessagePortData.~MessagePortData,,false,597,600,~MessagePortData,,,14,ANY node.worker.MessagePortData.~MessagePortData ()
205963,METHOD,node_messaging.cc:<global>,TYPE_DECL,"void MessagePortData::MemoryInfo(MemoryTracker* tracker) const {
  Mutex::ScopedLock lock(mutex_);
  tracker->TrackField(""incoming_messages"", incoming_messages_);
}",1,1,node_messaging.cc,node.worker.MessagePortData.MemoryInfo,,false,602,605,MemoryInfo,,,15,void node.worker.MessagePortData.MemoryInfo (MemoryTracker*)
205977,METHOD,node_messaging.cc:<global>,TYPE_DECL,"void MessagePortData::AddToIncomingQueue(std::shared_ptr<Message> message) {
  // This function will be called by other threads.
  Mutex::ScopedLock lock(mutex_);
  incoming_messages_.emplace_back(std::move(message));

  if (owner_ != nullptr) {
    Debug(owner_, ""Adding message to incoming queue"");
    owner_->TriggerAsync();
  }
}",1,1,node_messaging.cc,node.worker.MessagePortData.AddToIncomingQueue,,false,607,616,AddToIncomingQueue,,,16,void node.worker.MessagePortData.AddToIncomingQueue (ANY)
206006,METHOD,node_messaging.cc:<global>,TYPE_DECL,"void MessagePortData::Entangle(MessagePortData* a, MessagePortData* b) {
  auto group = std::make_shared<SiblingGroup>();
  group->Entangle({a, b});
}",1,1,node_messaging.cc,node.worker.MessagePortData.Entangle,,false,618,621,Entangle,,,17,"void node.worker.MessagePortData.Entangle (MessagePortData*,MessagePortData*)"
206026,METHOD,node_messaging.cc:<global>,TYPE_DECL,"void MessagePortData::Disentangle() {
  if (group_) {
    group_->Disentangle(this);
  }
}",1,1,node_messaging.cc,node.worker.MessagePortData.Disentangle,,false,623,627,Disentangle,,,18,void node.worker.MessagePortData.Disentangle ()
206038,METHOD,node_messaging.cc:<global>,TYPE_DECL,"MessagePort::~MessagePort() {
  if (data_) Detach();
}",1,1,node_messaging.cc,node.worker.MessagePort.~MessagePort,,false,629,631,~MessagePort,,,19,ANY node.worker.MessagePort.~MessagePort ()
206046,METHOD,node_messaging.cc:<global>,TYPE_DECL,"MessagePort::MessagePort(Environment* env,
                         Local<Context> context,
                         Local<Object> wrap)
  : HandleWrap(env,
               wrap,
               reinterpret_cast<uv_handle_t*>(&async_),
               AsyncWrap::PROVIDER_MESSAGEPORT),
    data_(new MessagePortData(this)) {
  auto onmessage = [](uv_async_t* handle) {
    // Called when data has been put into the queue.
    MessagePort* channel = ContainerOf(&MessagePort::async_, handle);
    channel->OnMessage(MessageProcessingMode::kNormalOperation);
  };

  CHECK_EQ(uv_async_init(env->event_loop(),
                         &async_,
                         onmessage), 0);
  // Reset later to indicate success of the constructor.
  bool succeeded = false;
  auto cleanup = OnScopeLeave([&]() { if (!succeeded) Close(); });

  Local<Value> fn;
  if (!wrap->Get(context, env->oninit_symbol()).ToLocal(&fn))
    return;

  if (fn->IsFunction()) {
    Local<Function> init = fn.As<Function>();
 ...",1,1,node_messaging.cc,node.worker.MessagePort.MessagePort,,false,633,671,MessagePort,,,20,"ANY node.worker.MessagePort.MessagePort (Environment*,Local<Context>,Local<Object>)"
206159,METHOD,node_messaging.cc:<global>,TYPE_DECL,"bool MessagePort::IsDetached() const {
  return data_ == nullptr || IsHandleClosing();
}",1,1,node_messaging.cc,node.worker.MessagePort.IsDetached,,false,673,675,IsDetached,,,21,bool node.worker.MessagePort.IsDetached ()
206169,METHOD,node_messaging.cc:<global>,TYPE_DECL,"void MessagePort::TriggerAsync() {
  if (IsHandleClosing()) return;
  CHECK_EQ(uv_async_send(&async_), 0);
}",1,1,node_messaging.cc,node.worker.MessagePort.TriggerAsync,,false,677,680,TriggerAsync,,,22,void node.worker.MessagePort.TriggerAsync ()
206182,METHOD,node_messaging.cc:<global>,TYPE_DECL,"void MessagePort::Close(v8::Local<v8::Value> close_callback) {
  Debug(this, ""Closing message port, data set = %d"", static_cast<int>(!!data_));

  if (data_) {
    // Wrap this call with accessing the mutex, so that TriggerAsync()
    // can check IsHandleClosing() without race conditions.
    Mutex::ScopedLock sibling_lock(data_->mutex_);
    HandleWrap::Close(close_callback);
  } else {
    HandleWrap::Close(close_callback);
  }
}",1,1,node_messaging.cc,node.worker.MessagePort.Close,,false,682,693,Close,,,23,void node.worker.MessagePort.Close (ANY)
206215,METHOD,node_messaging.cc:<global>,TYPE_DECL,"void MessagePort::New(const FunctionCallbackInfo<Value>& args) {
  // This constructor just throws an error. Unfortunately, we cant use V8s
  // ConstructorBehavior::kThrow, as that also removes the prototype from the
  // class (i.e. makes it behave like an arrow function).
  Environment* env = Environment::GetCurrent(args);
  THROW_ERR_CONSTRUCT_CALL_INVALID(env);
}",1,1,node_messaging.cc,node.worker.MessagePort.New,,false,695,701,New,,,24,void node.worker.MessagePort.New (FunctionCallbackInfo<Value>)
206230,METHOD,node_messaging.cc:<global>,TYPE_DECL,"MessagePort* MessagePort::New(
    Environment* env,
    Local<Context> context,
    std::unique_ptr<MessagePortData> data,
    std::shared_ptr<SiblingGroup> sibling_group) {
  Context::Scope context_scope(context);
  Local<FunctionTemplate> ctor_templ = GetMessagePortConstructorTemplate(env);

  // Construct a new instance, then assign the listener instance and possibly
  // the MessagePortData to it.
  Local<Object> instance;
  if (!ctor_templ->InstanceTemplate()->NewInstance(context).ToLocal(&instance))
    return nullptr;
  MessagePort* port = new MessagePort(env, context, instance);
  CHECK_NOT_NULL(port);
  if (port->IsHandleClosing()) {
    // Construction failed with an exception.
    return nullptr;
  }

  if (data) {
    CHECK(!sibling_group);
    port->Detach();
    port->data_ = std::move(data);

    // This lock is here to avoid race conditions with the `owner_` read
    // in AddToIncomingQueue(). (This would likely be unproblematic without it,
    // but it's better t...",1,1,node_messaging.cc,node.worker.MessagePort.New,,false,703,740,New,,,25,"MessagePort node.worker.MessagePort.New (Environment*,Local<Context>,ANY,ANY)"
206344,METHOD,node_messaging.cc:<global>,TYPE_DECL,"MaybeLocal<Value> MessagePort::ReceiveMessage(Local<Context> context,
                                              MessageProcessingMode mode,
                                              Local<Value>* port_list) {
  std::shared_ptr<Message> received;
  {
    // Get the head of the message queue.
    Mutex::ScopedLock lock(data_->mutex_);

    Debug(this, ""MessagePort has message"");

    bool wants_message =
        receiving_messages_ ||
        mode == MessageProcessingMode::kForceReadMessages;
    // We have nothing to do if:
    // - There are no pending messages
    // - We are not intending to receive messages, and the message we would
    //   receive is not the final ""close"" message.
    if (data_->incoming_messages_.empty() ||
        (!wants_message &&
         !data_->incoming_messages_.front()->IsCloseMessage())) {
      return env()->no_message_symbol();
    }

    received = data_->incoming_messages_.front();
    data_->incoming_messages_.pop_front();
  }

  if (rece...",1,1,node_messaging.cc,node.worker.MessagePort.ReceiveMessage,,false,742,777,ReceiveMessage,,,26,"MaybeLocal<Value> node.worker.MessagePort.ReceiveMessage (Local<Context>,MessageProcessingMode,Local<Value>*)"
206447,METHOD,node_messaging.cc:<global>,TYPE_DECL,"void MessagePort::OnMessage(MessageProcessingMode mode) {
  Debug(this, ""Running MessagePort::OnMessage()"");
  HandleScope handle_scope(env()->isolate());
  Local<Context> context =
      object(env()->isolate())->GetCreationContext().ToLocalChecked();

  size_t processing_limit;
  if (mode == MessageProcessingMode::kNormalOperation) {
    Mutex::ScopedLock(data_->mutex_);
    processing_limit = std::max(data_->incoming_messages_.size(),
                                static_cast<size_t>(1000));
  } else {
    processing_limit = std::numeric_limits<size_t>::max();
  }

  // data_ can only ever be modified by the owner thread, so no need to lock.
  // However, the message port may be transferred while it is processing
  // messages, so we need to check that this handle still owns its `data_` field
  // on every iteration.
  while (data_) {
    if (processing_limit-- == 0) {
      // Prevent event loop starvation by only processing those messages without
      // interruption that we...",1,1,node_messaging.cc,node.worker.MessagePort.OnMessage,,false,779,857,OnMessage,,,27,void node.worker.MessagePort.OnMessage (MessageProcessingMode)
206701,METHOD,node_messaging.cc:<global>,TYPE_DECL,"void MessagePort::OnClose() {
  Debug(this, ""MessagePort::OnClose()"");
  if (data_) {
    // Detach() returns move(data_).
    Detach()->Disentangle();
  }
}",1,1,node_messaging.cc,node.worker.MessagePort.OnClose,,false,859,865,OnClose,,,28,void node.worker.MessagePort.OnClose ()
206715,METHOD,node_messaging.cc:<global>,TYPE_DECL,"std::unique_ptr<MessagePortData> MessagePort::Detach() {
  CHECK(data_);
  Mutex::ScopedLock lock(data_->mutex_);
  data_->owner_ = nullptr;
  return std::move(data_);
}",1,1,node_messaging.cc,node.worker.MessagePort.Detach,,false,867,872,Detach,,,29,unique_ptr<MessagePortData> node.worker.MessagePort.Detach ()
206736,METHOD,node_messaging.cc:<global>,TYPE_DECL,"BaseObject::TransferMode MessagePort::GetTransferMode() const {
  if (IsDetached())
    return BaseObject::TransferMode::kUntransferable;
  return BaseObject::TransferMode::kTransferable;
}",1,1,node_messaging.cc,node.worker.MessagePort.GetTransferMode,,false,874,878,GetTransferMode,,,30,TransferMode node.worker.MessagePort.GetTransferMode ()
206755,METHOD,node_messaging.cc:<global>,TYPE_DECL,"std::unique_ptr<TransferData> MessagePort::TransferForMessaging() {
  Close();
  return Detach();
}",1,1,node_messaging.cc,node.worker.MessagePort.TransferForMessaging,,false,880,883,TransferForMessaging,,,31,unique_ptr<TransferData> node.worker.MessagePort.TransferForMessaging ()
206762,METHOD,node_messaging.cc:<global>,TYPE_DECL,"BaseObjectPtr<BaseObject> MessagePortData::Deserialize(
    Environment* env,
    Local<Context> context,
    std::unique_ptr<TransferData> self) {
  return BaseObjectPtr<MessagePort> { MessagePort::New(
      env, context,
      static_unique_pointer_cast<MessagePortData>(std::move(self))) };
}",1,1,node_messaging.cc,node.worker.MessagePortData.Deserialize,,false,885,892,Deserialize,,,32,"BaseObjectPtr<BaseObject> node.worker.MessagePortData.Deserialize (Environment*,Local<Context>,ANY)"
206787,METHOD,node_messaging.cc:<global>,TYPE_DECL,"Maybe<bool> MessagePort::PostMessage(Environment* env,
                                     Local<Context> context,
                                     Local<Value> message_v,
                                     const TransferList& transfer_v) {
  Isolate* isolate = env->isolate();
  Local<Object> obj = object(isolate);

  std::shared_ptr<Message> msg = std::make_shared<Message>();

  // Per spec, we need to both check if transfer list has the source port, and
  // serialize the input message, even if the MessagePort is closed or detached.

  Maybe<bool> serialization_maybe =
      msg->Serialize(env, context, message_v, transfer_v, obj);
  if (data_ == nullptr) {
    return serialization_maybe;
  }
  if (serialization_maybe.IsNothing()) {
    return Nothing<bool>();
  }

  std::string error;
  Maybe<bool> res = data_->Dispatch(msg, &error);
  if (res.IsNothing())
    return res;

  if (!error.empty())
    ProcessEmitWarning(env, error.c_str());

  return res;
}",1,1,node_messaging.cc,node.worker.MessagePort.PostMessage,,false,894,924,PostMessage,,,33,"Maybe<bool> node.worker.MessagePort.PostMessage (Environment*,Local<Context>,Local<Value>,TransferList)"
206883,METHOD,node_messaging.cc:<global>,TYPE_DECL,"Maybe<bool> MessagePortData::Dispatch(
    std::shared_ptr<Message> message,
    std::string* error) {
  if (!group_) {
    if (error != nullptr)
      *error = ""MessagePortData is not entangled."";
    return Nothing<bool>();
  }
  return group_->Dispatch(this, message, error);
}",1,1,node_messaging.cc,node.worker.MessagePortData.Dispatch,,false,926,935,Dispatch,,,34,"Maybe<bool> node.worker.MessagePortData.Dispatch (ANY,ANY*)"
206912,METHOD,node_messaging.cc:<global>,TYPE_DECL,"static Maybe<bool> ReadIterable(Environment* env,
                                Local<Context> context,
                                // NOLINTNEXTLINE(runtime/references)
                                TransferList& transfer_list,
                                Local<Value> object) {
  if (!object->IsObject()) return Just(false);

  if (object->IsArray()) {
    Local<Array> arr = object.As<Array>();
    size_t length = arr->Length();
    transfer_list.AllocateSufficientStorage(length);
    for (size_t i = 0; i < length; i++) {
      if (!arr->Get(context, i).ToLocal(&transfer_list[i]))
        return Nothing<bool>();
    }
    return Just(true);
  }

  Isolate* isolate = env->isolate();
  Local<Value> iterator_method;
  if (!object.As<Object>()->Get(context, Symbol::GetIterator(isolate))
      .ToLocal(&iterator_method)) return Nothing<bool>();
  if (!iterator_method->IsFunction()) return Just(false);

  Local<Value> iterator;
  if (!iterator_method.As<Function>()->Call(conte...",1,1,node_messaging.cc,node.worker.ReadIterable,,false,937,992,ReadIterable,,,35,"Maybe<bool> node.worker.ReadIterable (Environment*,Local<Context>,TransferList,Local<Value>)"
207254,METHOD,node_messaging.cc:<global>,TYPE_DECL,"void MessagePort::PostMessage(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Local<Object> obj = args.This();
  Local<Context> context = obj->GetCreationContext().ToLocalChecked();

  if (args.Length() == 0) {
    return THROW_ERR_MISSING_ARGS(env, ""Not enough arguments to ""
                                       ""MessagePort.postMessage"");
  }

  if (!args[1]->IsNullOrUndefined() && !args[1]->IsObject()) {
    // Browsers ignore null or undefined, and otherwise accept an array or an
    // options object.
    return THROW_ERR_INVALID_ARG_TYPE(env,
        ""Optional transferList argument must be an iterable"");
  }

  TransferList transfer_list;
  if (args[1]->IsObject()) {
    bool was_iterable;
    if (!ReadIterable(env, context, transfer_list, args[1]).To(&was_iterable))
      return;
    if (!was_iterable) {
      Local<Value> transfer_option;
      if (!args[1].As<Object>()->Get(context, env->transfer_string())
          .ToLocal...",1,1,node_messaging.cc,node.worker.MessagePort.PostMessage,,false,994,1044,PostMessage,,,36,void node.worker.MessagePort.PostMessage (FunctionCallbackInfo<Value>)
207475,METHOD,node_messaging.cc:<global>,TYPE_DECL,"void MessagePort::Start() {
  Debug(this, ""Start receiving messages"");
  receiving_messages_ = true;
  Mutex::ScopedLock lock(data_->mutex_);
  if (!data_->incoming_messages_.empty())
    TriggerAsync();
}",1,1,node_messaging.cc,node.worker.MessagePort.Start,,false,1046,1052,Start,,,37,void node.worker.MessagePort.Start ()
207500,METHOD,node_messaging.cc:<global>,TYPE_DECL,"void MessagePort::Stop() {
  Debug(this, ""Stop receiving messages"");
  receiving_messages_ = false;
}",1,1,node_messaging.cc,node.worker.MessagePort.Stop,,false,1054,1057,Stop,,,38,void node.worker.MessagePort.Stop ()
207510,METHOD,node_messaging.cc:<global>,TYPE_DECL,"void MessagePort::Start(const FunctionCallbackInfo<Value>& args) {
  MessagePort* port;
  ASSIGN_OR_RETURN_UNWRAP(&port, args.This());
  if (!port->data_) {
    return;
  }
  port->Start();
}",1,1,node_messaging.cc,node.worker.MessagePort.Start,,false,1059,1066,Start,,,39,void node.worker.MessagePort.Start (FunctionCallbackInfo<Value>)
207534,METHOD,node_messaging.cc:<global>,TYPE_DECL,"void MessagePort::Stop(const FunctionCallbackInfo<Value>& args) {
  MessagePort* port;
  CHECK(args[0]->IsObject());
  ASSIGN_OR_RETURN_UNWRAP(&port, args[0].As<Object>());
  if (!port->data_) {
    return;
  }
  port->Stop();
}",1,1,node_messaging.cc,node.worker.MessagePort.Stop,,false,1068,1076,Stop,,,40,void node.worker.MessagePort.Stop (FunctionCallbackInfo<Value>)
207567,METHOD,node_messaging.cc:<global>,TYPE_DECL,"void MessagePort::CheckType(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  args.GetReturnValue().Set(
      GetMessagePortConstructorTemplate(env)->HasInstance(args[0]));
}",1,1,node_messaging.cc,node.worker.MessagePort.CheckType,,false,1078,1082,CheckType,,,41,void node.worker.MessagePort.CheckType (FunctionCallbackInfo<Value>)
207595,METHOD,node_messaging.cc:<global>,TYPE_DECL,"void MessagePort::Drain(const FunctionCallbackInfo<Value>& args) {
  MessagePort* port;
  ASSIGN_OR_RETURN_UNWRAP(&port, args[0].As<Object>());
  port->OnMessage(MessageProcessingMode::kForceReadMessages);
}",1,1,node_messaging.cc,node.worker.MessagePort.Drain,,false,1084,1088,Drain,,,42,void node.worker.MessagePort.Drain (FunctionCallbackInfo<Value>)
207617,METHOD,node_messaging.cc:<global>,TYPE_DECL,"void MessagePort::ReceiveMessage(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  if (!args[0]->IsObject() ||
      !env->message_port_constructor_template()->HasInstance(args[0])) {
    return THROW_ERR_INVALID_ARG_TYPE(env,
        ""The \""port\"" argument must be a MessagePort instance"");
  }
  MessagePort* port = Unwrap<MessagePort>(args[0].As<Object>());
  if (port == nullptr) {
    // Return 'no messages' for a closed port.
    args.GetReturnValue().Set(
        Environment::GetCurrent(args)->no_message_symbol());
    return;
  }

  MaybeLocal<Value> payload = port->ReceiveMessage(
      port->object()->GetCreationContext().ToLocalChecked(),
      MessageProcessingMode::kForceReadMessages);
  if (!payload.IsEmpty())
    args.GetReturnValue().Set(payload.ToLocalChecked());
}",1,1,node_messaging.cc,node.worker.MessagePort.ReceiveMessage,,false,1090,1110,ReceiveMessage,,,43,void node.worker.MessagePort.ReceiveMessage (FunctionCallbackInfo<Value>)
207730,METHOD,node_messaging.cc:<global>,TYPE_DECL,"void MessagePort::MoveToContext(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  if (!args[0]->IsObject() ||
      !env->message_port_constructor_template()->HasInstance(args[0])) {
    return THROW_ERR_INVALID_ARG_TYPE(env,
        ""The \""port\"" argument must be a MessagePort instance"");
  }
  MessagePort* port = Unwrap<MessagePort>(args[0].As<Object>());
  if (port == nullptr || port->IsHandleClosing()) {
    Isolate* isolate = env->isolate();
    THROW_ERR_CLOSED_MESSAGE_PORT(isolate);
    return;
  }

  Local<Value> context_arg = args[1];
  ContextifyContext* context_wrapper;
  if (!context_arg->IsObject() ||
      (context_wrapper = ContextifyContext::ContextFromContextifiedSandbox(
          env, context_arg.As<Object>())) == nullptr) {
    return THROW_ERR_INVALID_ARG_TYPE(env, ""Invalid context argument"");
  }

  std::unique_ptr<MessagePortData> data;
  if (!port->IsDetached())
    data = port->Detach();

  Context::Scope contex...",1,1,node_messaging.cc,node.worker.MessagePort.MoveToContext,,false,1112,1143,MoveToContext,,,44,void node.worker.MessagePort.MoveToContext (FunctionCallbackInfo<Value>)
207895,METHOD,node_messaging.cc:<global>,TYPE_DECL,"void MessagePort::Entangle(MessagePort* a, MessagePort* b) {
  MessagePortData::Entangle(a->data_.get(), b->data_.get());
}",1,1,node_messaging.cc,node.worker.MessagePort.Entangle,,false,1145,1147,Entangle,,,45,"void node.worker.MessagePort.Entangle (MessagePort*,MessagePort*)"
207917,METHOD,node_messaging.cc:<global>,TYPE_DECL,"void MessagePort::Entangle(MessagePort* a, MessagePortData* b) {
  MessagePortData::Entangle(a->data_.get(), b);
}",1,1,node_messaging.cc,node.worker.MessagePort.Entangle,,false,1149,1151,Entangle,,,46,"void node.worker.MessagePort.Entangle (MessagePort*,MessagePortData*)"
207934,METHOD,node_messaging.cc:<global>,TYPE_DECL,"void MessagePort::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""data"", data_);
  tracker->TrackField(""emit_message_fn"", emit_message_fn_);
}",1,1,node_messaging.cc,node.worker.MessagePort.MemoryInfo,,false,1153,1156,MemoryInfo,,,47,void node.worker.MessagePort.MemoryInfo (MemoryTracker*)
207951,METHOD,node_messaging.cc:<global>,TYPE_DECL,"Local<FunctionTemplate> GetMessagePortConstructorTemplate(Environment* env) {
  // Factor generating the MessagePort JS constructor into its own piece
  // of code, because it is needed early on in the child environment setup.
  Local<FunctionTemplate> templ = env->message_port_constructor_template();
  if (!templ.IsEmpty())
    return templ;

  {
    Isolate* isolate = env->isolate();
    Local<FunctionTemplate> m = NewFunctionTemplate(isolate, MessagePort::New);
    m->SetClassName(env->message_port_constructor_string());
    m->InstanceTemplate()->SetInternalFieldCount(
        MessagePort::kInternalFieldCount);
    m->Inherit(HandleWrap::GetConstructorTemplate(env));

    SetProtoMethod(isolate, m, ""postMessage"", MessagePort::PostMessage);
    SetProtoMethod(isolate, m, ""start"", MessagePort::Start);

    env->set_message_port_constructor_template(m);
  }

  return GetMessagePortConstructorTemplate(env);
}",1,1,node_messaging.cc,node.worker.GetMessagePortConstructorTemplate,,false,1158,1180,GetMessagePortConstructorTemplate,,,48,Local<FunctionTemplate> node.worker.GetMessagePortConstructorTemplate (Environment*)
208043,METHOD,node_messaging.cc:<global>,TYPE_DECL,"JSTransferable::JSTransferable(Environment* env, Local<Object> obj)
    : BaseObject(env, obj) {
  MakeWeak();
}",1,1,node_messaging.cc,node.worker.JSTransferable.JSTransferable,,false,1182,1185,JSTransferable,,,49,"ANY node.worker.JSTransferable.JSTransferable (Environment*,Local<Object>)"
208050,METHOD,node_messaging.cc:<global>,TYPE_DECL,"void JSTransferable::New(const FunctionCallbackInfo<Value>& args) {
  CHECK(args.IsConstructCall());
  new JSTransferable(Environment::GetCurrent(args), args.This());
}",1,1,node_messaging.cc,node.worker.JSTransferable.New,,false,1187,1190,New,,,50,void node.worker.JSTransferable.New (FunctionCallbackInfo<Value>)
208071,METHOD,node_messaging.cc:<global>,TYPE_DECL,"JSTransferable::TransferMode JSTransferable::GetTransferMode() const {
  // Implement `kClone in this ? kCloneable : kTransferable`.
  HandleScope handle_scope(env()->isolate());
  errors::TryCatchScope ignore_exceptions(env());

  bool has_clone;
  if (!object()->Has(env()->context(),
                     env()->messaging_clone_symbol()).To(&has_clone)) {
    return TransferMode::kUntransferable;
  }

  return has_clone ? TransferMode::kCloneable : TransferMode::kTransferable;
}",1,1,node_messaging.cc,node.worker.JSTransferable.GetTransferMode,,false,1192,1204,GetTransferMode,,,51,TransferMode node.worker.JSTransferable.GetTransferMode ()
208118,METHOD,node_messaging.cc:<global>,TYPE_DECL,"std::unique_ptr<TransferData> JSTransferable::TransferForMessaging() {
  return TransferOrClone(TransferMode::kTransferable);
}",1,1,node_messaging.cc,node.worker.JSTransferable.TransferForMessaging,,false,1206,1208,TransferForMessaging,,,52,unique_ptr<TransferData> node.worker.JSTransferable.TransferForMessaging ()
208127,METHOD,node_messaging.cc:<global>,TYPE_DECL,"std::unique_ptr<TransferData> JSTransferable::CloneForMessaging() const {
  return TransferOrClone(TransferMode::kCloneable);
}",1,1,node_messaging.cc,node.worker.JSTransferable.CloneForMessaging,,false,1210,1212,CloneForMessaging,,,53,unique_ptr<TransferData> node.worker.JSTransferable.CloneForMessaging ()
208136,METHOD,node_messaging.cc:<global>,TYPE_DECL,"std::unique_ptr<TransferData> JSTransferable::TransferOrClone(
    TransferMode mode) const {
  // Call `this[symbol]()` where `symbol` is `kClone` or `kTransfer`,
  // which should return an object with `data` and `deserializeInfo` properties;
  // `data` is written to the serializer later, and `deserializeInfo` is stored
  // on the `TransferData` instance as a string.
  HandleScope handle_scope(env()->isolate());
  Local<Context> context = env()->isolate()->GetCurrentContext();
  Local<Symbol> method_name = mode == TransferMode::kCloneable ?
      env()->messaging_clone_symbol() : env()->messaging_transfer_symbol();

  Local<Value> method;
  if (!object()->Get(context, method_name).ToLocal(&method)) {
    return {};
  }
  if (method->IsFunction()) {
    Local<Value> result_v;
    if (!method.As<Function>()->Call(
            context, object(), 0, nullptr).ToLocal(&result_v)) {
      return {};
    }

    if (result_v->IsObject()) {
      Local<Object> result = result_v.As<Object>...",1,1,node_messaging.cc,node.worker.JSTransferable.TransferOrClone,,false,1214,1256,TransferOrClone,,,54,unique_ptr<TransferData> node.worker.JSTransferable.TransferOrClone (TransferMode)
208342,METHOD,node_messaging.cc:<global>,TYPE_DECL,"Maybe<BaseObjectList>
JSTransferable::NestedTransferables() const {
  // Call `this[kTransferList]()` and return the resulting list of BaseObjects.
  HandleScope handle_scope(env()->isolate());
  Local<Context> context = env()->isolate()->GetCurrentContext();
  Local<Symbol> method_name = env()->messaging_transfer_list_symbol();

  Local<Value> method;
  if (!object()->Get(context, method_name).ToLocal(&method)) {
    return Nothing<BaseObjectList>();
  }
  if (!method->IsFunction()) return Just(BaseObjectList {});

  Local<Value> list_v;
  if (!method.As<Function>()->Call(
          context, object(), 0, nullptr).ToLocal(&list_v)) {
    return Nothing<BaseObjectList>();
  }
  if (!list_v->IsArray()) return Just(BaseObjectList {});
  Local<Array> list = list_v.As<Array>();

  BaseObjectList ret;
  for (size_t i = 0; i < list->Length(); i++) {
    Local<Value> value;
    if (!list->Get(context, i).ToLocal(&value))
      return Nothing<BaseObjectList>();
    if (value->IsObject() && B...",1,1,node_messaging.cc,node.worker.JSTransferable.NestedTransferables,,false,1258,1288,NestedTransferables,,,55,Maybe<BaseObjectList> node.worker.JSTransferable.NestedTransferables ()
208518,METHOD,node_messaging.cc:<global>,TYPE_DECL,"Maybe<bool> JSTransferable::FinalizeTransferRead(
    Local<Context> context, ValueDeserializer* deserializer) {
  // Call `this[kDeserialize](data)` where `data` comes from the return value
  // of `this[kTransfer]()` or `this[kClone]()`.
  HandleScope handle_scope(env()->isolate());
  Local<Value> data;
  if (!deserializer->ReadValue(context).ToLocal(&data)) return Nothing<bool>();

  Local<Symbol> method_name = env()->messaging_deserialize_symbol();
  Local<Value> method;
  if (!object()->Get(context, method_name).ToLocal(&method)) {
    return Nothing<bool>();
  }
  if (!method->IsFunction()) return Just(true);

  if (method.As<Function>()->Call(context, object(), 1, &data).IsEmpty()) {
    return Nothing<bool>();
  }
  return Just(true);
}",1,1,node_messaging.cc,node.worker.JSTransferable.FinalizeTransferRead,,false,1290,1309,FinalizeTransferRead,,,56,"Maybe<bool> node.worker.JSTransferable.FinalizeTransferRead (Local<Context>,ValueDeserializer*)"
208613,METHOD,node_messaging.cc:<global>,TYPE_DECL,"JSTransferable::Data::Data(std::string&& deserialize_info,
                           v8::Global<v8::Value>&& data)
    : deserialize_info_(std::move(deserialize_info)),
      data_(std::move(data)) {}",1,31,node_messaging.cc,node.worker.JSTransferable.Data.Data,,false,1311,1314,Data,,,57,"ANY node.worker.JSTransferable.Data.Data (ANY,ANY)"
208619,METHOD,node_messaging.cc:<global>,TYPE_DECL,"BaseObjectPtr<BaseObject> JSTransferable::Data::Deserialize(
    Environment* env,
    Local<Context> context,
    std::unique_ptr<TransferData> self) {
  // Create the JS wrapper object that will later be filled with data passed to
  // the `[kDeserialize]()` method on it. This split is necessary, because here
  // we need to create an object with the right prototype and internal fields,
  // but the actual JS data stored in the serialized data can only be read at
  // the end of the stream, after the main message has been read.

  if (context != env->context()) {
    THROW_ERR_MESSAGE_TARGET_CONTEXT_UNAVAILABLE(env);
    return {};
  }
  HandleScope handle_scope(env->isolate());
  Local<Value> info;
  if (!ToV8Value(context, deserialize_info_).ToLocal(&info)) return {};

  Local<Value> ret;
  CHECK(!env->messaging_deserialize_create_object().IsEmpty());
  if (!env->messaging_deserialize_create_object()
           ->Call(context, Null(env->isolate()), 1, &info)
           .ToLocal(...",1,1,node_messaging.cc,node.worker.JSTransferable.Data.Deserialize,,false,1316,1344,Deserialize,,,58,"BaseObjectPtr<BaseObject> node.worker.JSTransferable.Data.Deserialize (Environment*,Local<Context>,ANY)"
208723,METHOD,node_messaging.cc:<global>,TYPE_DECL,"Maybe<bool> JSTransferable::Data::FinalizeTransferWrite(
    Local<Context> context, ValueSerializer* serializer) {
  HandleScope handle_scope(context->GetIsolate());
  auto ret = serializer->WriteValue(context, PersistentToLocal::Strong(data_));
  data_.Reset();
  return ret;
}",1,1,node_messaging.cc,node.worker.JSTransferable.Data.FinalizeTransferWrite,,false,1346,1352,FinalizeTransferWrite,,,59,"Maybe<bool> node.worker.JSTransferable.Data.FinalizeTransferWrite (Local<Context>,ValueSerializer*)"
208754,METHOD,node_messaging.cc:<global>,TYPE_DECL,"std::shared_ptr<SiblingGroup> SiblingGroup::Get(const std::string& name) {
  Mutex::ScopedLock lock(SiblingGroup::groups_mutex_);
  std::shared_ptr<SiblingGroup> group;
  auto i = groups_.find(name);
  if (i == groups_.end() || i->second.expired()) {
    group = std::make_shared<SiblingGroup>(name);
    groups_[name] = group;
  } else {
    group = i->second.lock();
  }
  return group;
}",1,1,node_messaging.cc,node.worker.SiblingGroup.Get,,false,1354,1365,Get,,,60,shared_ptr<SiblingGroup> node.worker.SiblingGroup.Get (ANY)
208820,METHOD,node_messaging.cc:<global>,TYPE_DECL,"void SiblingGroup::CheckSiblingGroup(const std::string& name) {
  Mutex::ScopedLock lock(SiblingGroup::groups_mutex_);
  auto i = groups_.find(name);
  if (i != groups_.end() && i->second.expired())
    groups_.erase(name);
}",1,1,node_messaging.cc,node.worker.SiblingGroup.CheckSiblingGroup,,false,1367,1372,CheckSiblingGroup,,,61,void node.worker.SiblingGroup.CheckSiblingGroup (ANY)
208858,METHOD,node_messaging.cc:<global>,TYPE_DECL,"SiblingGroup::SiblingGroup(const std::string& name)
    : name_(name) { }",1,21,node_messaging.cc,node.worker.SiblingGroup.SiblingGroup,,false,1374,1375,SiblingGroup,,,62,ANY node.worker.SiblingGroup.SiblingGroup (ANY)
208863,METHOD,node_messaging.cc:<global>,TYPE_DECL,"SiblingGroup::~SiblingGroup() {
  // If this is a named group, check to see if we can remove the group
  if (!name_.empty())
    CheckSiblingGroup(name_);
}",1,1,node_messaging.cc,node.worker.SiblingGroup.~SiblingGroup,,false,1377,1381,~SiblingGroup,,,63,ANY node.worker.SiblingGroup.~SiblingGroup ()
208875,METHOD,node_messaging.cc:<global>,TYPE_DECL,"Maybe<bool> SiblingGroup::Dispatch(
    MessagePortData* source,
    std::shared_ptr<Message> message,
    std::string* error) {

  RwLock::ScopedReadLock lock(group_mutex_);

  // The source MessagePortData is not part of this group.
  if (ports_.find(source) == ports_.end()) {
    if (error != nullptr)
      *error = ""Source MessagePort is not entangled with this group."";
    return Nothing<bool>();
  }

  // There are no destination ports.
  if (size() <= 1)
    return Just(false);

  // Transferables cannot be used when there is more
  // than a single destination.
  if (size() > 2 && message->has_transferables()) {
    if (error != nullptr)
      *error = ""Transferables cannot be used with multiple destinations."";
    return Nothing<bool>();
  }

  for (MessagePortData* port : ports_) {
    if (port == source)
      continue;
    // This loop should only be entered if there's only a single destination
    for (const auto& transferable : message->transferables()) {
      if (por...",1,1,node_messaging.cc,node.worker.SiblingGroup.Dispatch,,false,1383,1426,Dispatch,,,64,"Maybe<bool> node.worker.SiblingGroup.Dispatch (MessagePortData*,ANY,ANY*)"
208982,METHOD,node_messaging.cc:<global>,TYPE_DECL,"void SiblingGroup::Entangle(MessagePortData* port) {
  Entangle({ port });
}",1,1,node_messaging.cc,node.worker.SiblingGroup.Entangle,,false,1428,1430,Entangle,,,65,void node.worker.SiblingGroup.Entangle (MessagePortData*)
208990,METHOD,node_messaging.cc:<global>,TYPE_DECL,"void SiblingGroup::Entangle(std::initializer_list<MessagePortData*> ports) {
  RwLock::ScopedWriteLock lock(group_mutex_);
  for (MessagePortData* data : ports) {
    ports_.insert(data);
    CHECK(!data->group_);
    data->group_ = shared_from_this();
  }
}",1,1,node_messaging.cc,node.worker.SiblingGroup.Entangle,,false,1432,1439,Entangle,,,66,void node.worker.SiblingGroup.Entangle (ANY)
209017,METHOD,node_messaging.cc:<global>,TYPE_DECL,"void SiblingGroup::Disentangle(MessagePortData* data) {
  auto self = shared_from_this();  // Keep alive until end of function.
  RwLock::ScopedWriteLock lock(group_mutex_);
  ports_.erase(data);
  data->group_.reset();

  data->AddToIncomingQueue(std::make_shared<Message>());
  // If this is an anonymous group and there's another port, close it.
  if (size() == 1 && name_.empty())
    (*(ports_.begin()))->AddToIncomingQueue(std::make_shared<Message>());
}",1,1,node_messaging.cc,node.worker.SiblingGroup.Disentangle,,false,1441,1451,Disentangle,,,67,void node.worker.SiblingGroup.Disentangle (MessagePortData*)
209073,METHOD,node_messaging.cc:<global>,TYPE_DECL,"static void SetDeserializerCreateObjectFunction(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  env->set_messaging_deserialize_create_object(args[0].As<Function>());
}",1,1,node_messaging.cc,node.worker.anonymous_namespace_27.SetDeserializerCreateObjectFunction,,false,1458,1463,SetDeserializerCreateObjectFunction,,,1,void node.worker.anonymous_namespace_27.SetDeserializerCreateObjectFunction (FunctionCallbackInfo<Value>)
209103,METHOD,node_messaging.cc:<global>,TYPE_DECL,"static void MessageChannel(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  if (!args.IsConstructCall()) {
    THROW_ERR_CONSTRUCT_CALL_REQUIRED(env);
    return;
  }

  Local<Context> context = args.This()->GetCreationContext().ToLocalChecked();
  Context::Scope context_scope(context);

  MessagePort* port1 = MessagePort::New(env, context);
  if (port1 == nullptr) return;
  MessagePort* port2 = MessagePort::New(env, context);
  if (port2 == nullptr) {
    port1->Close();
    return;
  }

  MessagePort::Entangle(port1, port2);

  args.This()->Set(context, env->port1_string(), port1->object())
      .Check();
  args.This()->Set(context, env->port2_string(), port2->object())
      .Check();
}",1,1,node_messaging.cc,node.worker.anonymous_namespace_28.MessageChannel,,false,1465,1489,MessageChannel,,,2,void node.worker.anonymous_namespace_28.MessageChannel (FunctionCallbackInfo<Value>)
209223,METHOD,node_messaging.cc:<global>,TYPE_DECL,"static void BroadcastChannel(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsString());
  Environment* env = Environment::GetCurrent(args);
  Context::Scope context_scope(env->context());
  Utf8Value name(env->isolate(), args[0]);
  MessagePort* port =
      MessagePort::New(env, env->context(), {}, SiblingGroup::Get(*name));
  if (port != nullptr) {
    args.GetReturnValue().Set(port->object());
  }
}",1,1,node_messaging.cc,node.worker.anonymous_namespace_29.BroadcastChannel,,false,1491,1501,BroadcastChannel,,,3,void node.worker.anonymous_namespace_29.BroadcastChannel (FunctionCallbackInfo<Value>)
209293,METHOD,node_messaging.cc:<global>,TYPE_DECL,"static void InitMessaging(Local<Object> target,
                          Local<Value> unused,
                          Local<Context> context,
                          void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  {
    SetConstructorFunction(context,
                           target,
                           ""MessageChannel"",
                           NewFunctionTemplate(isolate, MessageChannel));
  }

  {
    Local<FunctionTemplate> t =
        NewFunctionTemplate(isolate, JSTransferable::New);
    t->InstanceTemplate()->SetInternalFieldCount(
        JSTransferable::kInternalFieldCount);
    t->SetClassName(OneByteString(isolate, ""JSTransferable""));
    SetConstructorFunction(
        context, target, ""JSTransferable"", t, SetConstructorFunctionFlag::NONE);
  }

  SetConstructorFunction(context,
                         target,
                         env->message_port_constructor_string(),
                    ...",1,1,node_messaging.cc,node.worker.anonymous_namespace_30.InitMessaging,,false,1503,1556,InitMessaging,,,4,"void node.worker.anonymous_namespace_30.InitMessaging (Local<Object>,Local<Value>,Local<Context>,void*)"
209445,METHOD,node_messaging.cc:<global>,TYPE_DECL,"static void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(MessageChannel);
  registry->Register(BroadcastChannel);
  registry->Register(JSTransferable::New);
  registry->Register(MessagePort::New);
  registry->Register(MessagePort::PostMessage);
  registry->Register(MessagePort::Start);
  registry->Register(MessagePort::Stop);
  registry->Register(MessagePort::CheckType);
  registry->Register(MessagePort::Drain);
  registry->Register(MessagePort::ReceiveMessage);
  registry->Register(MessagePort::MoveToContext);
  registry->Register(SetDeserializerCreateObjectFunction);
}",1,1,node_messaging.cc,node.worker.anonymous_namespace_35.RegisterExternalReferences,,false,1558,1571,RegisterExternalReferences,,,5,void node.worker.anonymous_namespace_35.RegisterExternalReferences (ExternalReferenceRegistry*)
209546,METHOD,node_messaging.hpp:<global>,TYPE_DECL,<global>,1,32,node_messaging.hpp,node_messaging.hpp:<global>,,false,1,377,<global>,,,1,
209601,METHOD,node_metadata.cc:<global>,TYPE_DECL,<global>,1,31,node_metadata.hpp,node_metadata.cc:<global>,,false,1,148,<global>,,,1,
209606,METHOD,node_metadata.cc:<global>,TYPE_DECL,"Metadata::Versions::Versions() {
  node = NODE_VERSION_STRING;
  v8 = v8::V8::GetVersion();
  uv = uv_version_string();
  zlib = ZLIB_VERSION;
  ares = ARES_VERSION_STR;
  modules = NODE_STRINGIFY(NODE_MODULE_VERSION);
  nghttp2 = NGHTTP2_VERSION;
  napi = NODE_STRINGIFY(NAPI_VERSION);
  llhttp =
      NODE_STRINGIFY(LLHTTP_VERSION_MAJOR)
      "".""
      NODE_STRINGIFY(LLHTTP_VERSION_MINOR)
      "".""
      NODE_STRINGIFY(LLHTTP_VERSION_PATCH);

  brotli =
    std::to_string(BrotliEncoderVersion() >> 24) +
    ""."" +
    std::to_string((BrotliEncoderVersion() & 0xFFF000) >> 12) +
    ""."" +
    std::to_string(BrotliEncoderVersion() & 0xFFF);
#ifndef NODE_SHARED_BUILTIN_UNDICI_UNDICI_PATH
  undici = UNDICI_VERSION;
#endif

  acorn = ACORN_VERSION;
  cjs_module_lexer = CJS_MODULE_LEXER_VERSION;
  base64 = BASE64_VERSION;
  uvwasi = UVWASI_VERSION_STRING;

#if HAVE_OPENSSL
  openssl = GetOpenSSLVersion();
#endif

#ifdef NODE_HAVE_I18N_SUPPORT
  icu = U_ICU_VERSION;
  unicode = U_UNICODE_V...",1,9,node_metadata.cc,node.Metadata.Versions.Versions,,false,77,124,Versions,,,2,ANY node.Metadata.Versions.Versions ()
209710,METHOD,node_metadata.cc:<global>,TYPE_DECL,"Metadata::Release::Release() : name(NODE_RELEASE) {
#if NODE_VERSION_IS_LTS
  lts = NODE_VERSION_LTS_CODENAME;
#endif  // NODE_VERSION_IS_LTS

#ifdef NODE_HAS_RELEASE_URLS
#define NODE_RELEASE_URLPFX NODE_RELEASE_URLBASE ""v"" NODE_VERSION_STRING ""/""
#define NODE_RELEASE_URLFPFX NODE_RELEASE_URLPFX ""node-v"" NODE_VERSION_STRING

  source_url = NODE_RELEASE_URLFPFX "".tar.gz"";
  headers_url = NODE_RELEASE_URLFPFX ""-headers.tar.gz"";
#ifdef _WIN32
  lib_url = strcmp(NODE_ARCH, ""ia32"") ? NODE_RELEASE_URLPFX ""win-"" NODE_ARCH
                                                           ""/node.lib""
                                     : NODE_RELEASE_URLPFX ""win-x86/node.lib"";
#endif  // _WIN32

#endif  // NODE_HAS_RELEASE_URLS
}",1,36,node_metadata.cc,node.Metadata.Release.Release,,false,126,144,Release,,,3,ANY node.Metadata.Release.Release ()
209714,METHOD,node_metadata.cc:<global>,TYPE_DECL,"Metadata::Metadata() : arch(NODE_ARCH), platform(NODE_PLATFORM) {}",1,66,node_metadata.cc,node.Metadata.Metadata,,false,146,146,Metadata,,,4,ANY node.Metadata.Metadata ()
209729,METHOD,node_metadata.hpp:<global>,TYPE_DECL,<global>,1,31,node_metadata.hpp,node_metadata.hpp:<global>,,false,1,138,<global>,,,1,
209742,METHOD,node_mutex.hpp:<global>,TYPE_DECL,<global>,1,28,node_mutex.hpp,node_mutex.hpp:<global>,,false,1,323,<global>,,,1,
209751,METHOD,node_object_wrap.hpp:<global>,TYPE_DECL,<global>,1,34,node_object_wrap.hpp,node_object_wrap.hpp:<global>,,false,1,132,<global>,,,1,
209755,METHOD,node.ObjectWrap,TYPE_DECL,"ObjectWrap() {
    refs_ = 0;
  }",3,3,node_object_wrap.hpp,node.ObjectWrap.ObjectWrap,,false,33,35,ObjectWrap,,,1,ANY node.ObjectWrap.ObjectWrap ()
209762,METHOD,node.ObjectWrap,TYPE_DECL,"virtual ~ObjectWrap() {
    if (persistent().IsEmpty())
      return;
    persistent().ClearWeak();
    persistent().Reset();
  }",3,3,node_object_wrap.hpp,node.ObjectWrap.~ObjectWrap,,false,38,43,~ObjectWrap,,,2,ANY node.ObjectWrap.~ObjectWrap ()
209781,METHOD,node.ObjectWrap,TYPE_DECL,"static inline T* Unwrap(v8::Local<v8::Object> handle) {
    assert(!handle.IsEmpty());
    assert(handle->InternalFieldCount() > 0);
    // Cast to ObjectWrap before casting to T.  A direct cast from void
    // to T won't work right when T has more than one base class.
    void* ptr = handle->GetAlignedPointerFromInternalField(0);
    ObjectWrap* wrap = static_cast<ObjectWrap*>(ptr);
    return static_cast<T*>(wrap);
  }",3,3,node_object_wrap.hpp,node.ObjectWrap.Unwrap,,false,47,55,Unwrap,,,3,T node.ObjectWrap.Unwrap<T> (ANY)
209817,METHOD,node.ObjectWrap,TYPE_DECL,"inline v8::Local<v8::Object> handle() {
    return handle(v8::Isolate::GetCurrent());
  }",3,3,node_object_wrap.hpp,node.ObjectWrap.handle,,false,58,60,handle,,,4,Local<v8::Object> node.ObjectWrap.handle ()
209829,METHOD,node.ObjectWrap,TYPE_DECL,"inline v8::Local<v8::Object> handle(v8::Isolate* isolate) {
    return v8::Local<v8::Object>::New(isolate, persistent());
  }",3,3,node_object_wrap.hpp,node.ObjectWrap.handle,,false,63,65,handle,,,5,Local<v8::Object> node.ObjectWrap.handle (ANY*)
209849,METHOD,node.ObjectWrap,TYPE_DECL,"inline v8::Persistent<v8::Object>& persistent() {
    return handle_;
  }",3,3,node_object_wrap.hpp,node.ObjectWrap.persistent,,false,69,71,persistent,,,6,Persistent<v8::Object> node.ObjectWrap.persistent ()
209855,METHOD,node.ObjectWrap,TYPE_DECL,"inline void Wrap(v8::Local<v8::Object> handle) {
    assert(persistent().IsEmpty());
    assert(handle->InternalFieldCount() > 0);
    handle->SetAlignedPointerInInternalField(0, this);
    persistent().Reset(v8::Isolate::GetCurrent(), handle);
    MakeWeak();
  }",3,3,node_object_wrap.hpp,node.ObjectWrap.Wrap,,false,75,81,Wrap,,,7,void node.ObjectWrap.Wrap (ANY)
209890,METHOD,node.ObjectWrap,TYPE_DECL,"inline void MakeWeak() {
    persistent().SetWeak(this, WeakCallback, v8::WeakCallbackType::kParameter);
  }",3,3,node_object_wrap.hpp,node.ObjectWrap.MakeWeak,,false,84,86,MakeWeak,,,8,void node.ObjectWrap.MakeWeak ()
209905,METHOD,node.ObjectWrap,TYPE_DECL,"virtual void Ref() {
    assert(!persistent().IsEmpty());
    persistent().ClearWeak();
    refs_++;
  }",3,3,node_object_wrap.hpp,node.ObjectWrap.Ref,,false,92,96,Ref,,,9,void node.ObjectWrap.Ref ()
209921,METHOD,node.ObjectWrap,TYPE_DECL,"virtual void Unref() {
    assert(!persistent().IsEmpty());
    assert(!persistent().IsWeak());
    assert(refs_ > 0);
    if (--refs_ == 0)
      MakeWeak();
  }",3,3,node_object_wrap.hpp,node.ObjectWrap.Unref,,false,107,113,Unref,,,10,void node.ObjectWrap.Unref ()
209949,METHOD,node.ObjectWrap,TYPE_DECL,"static void WeakCallback(
      const v8::WeakCallbackInfo<ObjectWrap>& data) {
    ObjectWrap* wrap = data.GetParameter();
    assert(wrap->refs_ == 0);
    wrap->handle_.Reset();
    delete wrap;
  }",3,3,node_object_wrap.hpp,node.ObjectWrap.WeakCallback,,false,118,124,WeakCallback,,,12,void node.ObjectWrap.WeakCallback (ANY)
209985,METHOD,node_options-inl.hpp:<global>,TYPE_DECL,<global>,1,34,node_options-inl.hpp,node_options-inl.hpp:<global>,,false,1,478,<global>,,,1,
209988,METHOD,node_options.cc:<global>,TYPE_DECL,"[&]() {
    per_process::cli_options->per_isolate->per_env = original_per_env;
    per_process::cli_options->per_isolate = original_per_isolate;
  }",38,3,node_options.cc,node.options_parser.GetCLIOptions.<lambda>0,,false,1104,1107,<lambda>0,,,1,ANY node.options_parser.GetCLIOptions.<lambda>0 ()
210012,METHOD,node_options.cc:<global>,TYPE_DECL,"[](const char* name) {
    std::string text;
    return credentials::SafeGetenv(name, &text) ? text : """";
  }",33,3,node_options.cc,node.HandleEnvOptions.<lambda>1,,false,1293,1296,<lambda>1,,,1,ANY node.HandleEnvOptions.<lambda>1 (char*)
210059,METHOD,node_options.cc:<global>,TYPE_DECL,<global>,1,30,node_options.hpp,node_options.cc:<global>,,false,1,1357,<global>,,,1,
210070,METHOD,node_options.cc:<global>,TYPE_DECL,"void DebugOptions::CheckOptions(std::vector<std::string>* errors,
                                std::vector<std::string>* argv) {
#if !NODE_USE_V8_PLATFORM && !HAVE_INSPECTOR
  if (inspector_enabled) {
    errors->push_back(""Inspector is not available when Node is compiled ""
                      ""--without-v8-platform and --without-inspector."");
  }
#endif

  if (deprecated_debug) {
    errors->push_back(""[DEP0062]: `node --debug` and `node --debug-brk` ""
                      ""are invalid. Please use `node --inspect` and ""
                      ""`node --inspect-brk` instead."");
  }

  using std::string_view_literals::operator""""sv;
  const std::vector<std::string_view> destinations =
      SplitString(inspect_publish_uid_string, "",""sv);
  inspect_publish_uid.console = false;
  inspect_publish_uid.http = false;
  for (const std::string_view destination : destinations) {
    if (destination == ""stderr""sv) {
      inspect_publish_uid.console = true;
    } else if (destination == ""ht...",1,1,node_options.cc,node.DebugOptions.CheckOptions,,false,39,69,CheckOptions,,,2,"void node.DebugOptions.CheckOptions (ANY*,ANY*)"
210141,METHOD,node_options.cc:<global>,TYPE_DECL,"void PerProcessOptions::CheckOptions(std::vector<std::string>* errors,
                                     std::vector<std::string>* argv) {
#if HAVE_OPENSSL
  if (use_openssl_ca && use_bundled_ca) {
    errors->push_back(""either --use-openssl-ca or --use-bundled-ca can be ""
                      ""used, not both"");
  }

  // Any value less than 2 disables use of the secure heap.
  if (secure_heap >= 2) {
    if ((secure_heap & (secure_heap - 1)) != 0)
      errors->push_back(""--secure-heap must be a power of 2"");
    secure_heap_min =
        std::min({
            secure_heap,
            secure_heap_min,
            static_cast<int64_t>(std::numeric_limits<int>::max())});
    secure_heap_min = std::max(static_cast<int64_t>(2), secure_heap_min);
    if ((secure_heap_min & (secure_heap_min - 1)) != 0)
      errors->push_back(""--secure-heap-min must be a power of 2"");
  }
#endif  // HAVE_OPENSSL

  if (use_largepages != ""off"" &&
      use_largepages != ""on"" &&
      use_largepages !...",1,1,node_options.cc,node.PerProcessOptions.CheckOptions,,false,71,100,CheckOptions,,,3,"void node.PerProcessOptions.CheckOptions (ANY*,ANY*)"
210171,METHOD,node_options.cc:<global>,TYPE_DECL,"void PerIsolateOptions::CheckOptions(std::vector<std::string>* errors,
                                     std::vector<std::string>* argv) {
  per_env->CheckOptions(errors, argv);
}",1,1,node_options.cc,node.PerIsolateOptions.CheckOptions,,false,102,105,CheckOptions,,,4,"void node.PerIsolateOptions.CheckOptions (ANY*,ANY*)"
210183,METHOD,node_options.cc:<global>,TYPE_DECL,"void EnvironmentOptions::CheckOptions(std::vector<std::string>* errors,
                                      std::vector<std::string>* argv) {
  if (has_policy_integrity_string && experimental_policy.empty()) {
    errors->push_back(""--policy-integrity requires ""
                      ""--experimental-policy be enabled"");
  }
  if (has_policy_integrity_string && experimental_policy_integrity.empty()) {
    errors->push_back(""--policy-integrity cannot be empty"");
  }

  if (!module_type.empty()) {
    if (module_type != ""commonjs"" && module_type != ""module"") {
      errors->push_back(""--input-type must be \""module\"" or \""commonjs\"""");
    }
  }

  if (syntax_check_only && has_eval_string) {
    errors->push_back(""either --check or --eval can be used, not both"");
  }

  if (!unhandled_rejections.empty() &&
      unhandled_rejections != ""warn-with-error-code"" &&
      unhandled_rejections != ""throw"" &&
      unhandled_rejections != ""strict"" &&
      unhandled_rejections != ""warn"" &&
  ...",1,1,node_options.cc,node.EnvironmentOptions.CheckOptions,,false,107,224,CheckOptions,,,5,"void node.EnvironmentOptions.CheckOptions (ANY*,ANY*)"
210402,METHOD,node.options_parser.DebugOptionsParser,TYPE_DECL,DebugOptionsParser();,3,22,node_options.cc,node.options_parser.DebugOptionsParser.DebugOptionsParser,,false,230,230,DebugOptionsParser,,,1,ANY node.options_parser.DebugOptionsParser.DebugOptionsParser ()
210407,METHOD,node.options_parser.EnvironmentOptionsParser,TYPE_DECL,EnvironmentOptionsParser();,3,28,node_options.cc,node.options_parser.EnvironmentOptionsParser.EnvironmentOptionsParser,,false,235,235,EnvironmentOptionsParser,,,1,ANY node.options_parser.EnvironmentOptionsParser.EnvironmentOptionsParser ()
210411,METHOD,node.options_parser.EnvironmentOptionsParser,TYPE_DECL,"explicit EnvironmentOptionsParser(const DebugOptionsParser& dop)
    : EnvironmentOptionsParser() {
    Insert(dop, &EnvironmentOptions::get_debug_options);
  }",3,3,node_options.cc,node.options_parser.EnvironmentOptionsParser.EnvironmentOptionsParser,,false,236,239,EnvironmentOptionsParser,,,2,ANY node.options_parser.EnvironmentOptionsParser.EnvironmentOptionsParser (DebugOptionsParser)
210423,METHOD,node.options_parser.PerIsolateOptionsParser,TYPE_DECL,PerIsolateOptionsParser() = delete;,3,37,node_options.cc,node.options_parser.PerIsolateOptionsParser.PerIsolateOptionsParser,,false,244,244,PerIsolateOptionsParser,,,1,ANY node.options_parser.PerIsolateOptionsParser.PerIsolateOptionsParser ()
210427,METHOD,node.options_parser.PerIsolateOptionsParser,TYPE_DECL,explicit PerIsolateOptionsParser(const EnvironmentOptionsParser& eop);,12,71,node_options.cc,node.options_parser.PerIsolateOptionsParser.PerIsolateOptionsParser,,false,245,245,PerIsolateOptionsParser,,,2,explicit node.options_parser.PerIsolateOptionsParser.PerIsolateOptionsParser (EnvironmentOptionsParser)
210433,METHOD,node.options_parser.PerProcessOptionsParser,TYPE_DECL,PerProcessOptionsParser() = delete;,3,37,node_options.cc,node.options_parser.PerProcessOptionsParser.PerProcessOptionsParser,,false,250,250,PerProcessOptionsParser,,,1,ANY node.options_parser.PerProcessOptionsParser.PerProcessOptionsParser ()
210437,METHOD,node.options_parser.PerProcessOptionsParser,TYPE_DECL,explicit PerProcessOptionsParser(const PerIsolateOptionsParser& iop);,12,70,node_options.cc,node.options_parser.PerProcessOptionsParser.PerProcessOptionsParser,,false,251,251,PerProcessOptionsParser,,,2,explicit node.options_parser.PerProcessOptionsParser.PerProcessOptionsParser (PerIsolateOptionsParser)
210456,METHOD,node_options.cc:<global>,TYPE_DECL,"void Parse(
  StringVector* const args, StringVector* const exec_args,
  StringVector* const v8_args,
  PerIsolateOptions* const options,
  OptionEnvvarSettings required_env_settings, StringVector* const errors) {
  _piop_instance.Parse(
    args, exec_args, v8_args, options, required_env_settings, errors);
}",1,1,node_options.cc,node.options_parser.Parse,,false,275,282,Parse,,,11,"void node.options_parser.Parse<> (StringVector*,StringVector*,StringVector*,PerIsolateOptions*,OptionEnvvarSettings,StringVector*)"
210476,METHOD,node_options.cc:<global>,TYPE_DECL,"void Parse(
  StringVector* const args, StringVector* const exec_args,
  StringVector* const v8_args,
  PerProcessOptions* const options,
  OptionEnvvarSettings required_env_settings, StringVector* const errors) {
  _ppop_instance.Parse(
    args, exec_args, v8_args, options, required_env_settings, errors);
}",1,1,node_options.cc,node.options_parser.Parse,,false,285,292,Parse,,,12,"void node.options_parser.Parse<> (StringVector*,StringVector*,StringVector*,PerProcessOptions*,OptionEnvvarSettings,StringVector*)"
210496,METHOD,node_options.cc:<global>,TYPE_DECL,"DebugOptionsParser::DebugOptionsParser() {
#ifndef DISABLE_SINGLE_EXECUTABLE_APPLICATION
  if (sea::IsSingleExecutable()) return;
#endif

  AddOption(""--inspect-port"",
            ""set host:port for inspector"",
            &DebugOptions::host_port,
            kAllowedInEnvvar);
  AddAlias(""--debug-port"", ""--inspect-port"");

  AddOption(""--inspect"",
            ""activate inspector on host:port (default: 127.0.0.1:9229)"",
            &DebugOptions::inspector_enabled,
            kAllowedInEnvvar);
  AddAlias(""--inspect="", { ""--inspect-port"", ""--inspect"" });

  AddOption(""--debug"", """", &DebugOptions::deprecated_debug);
  AddAlias(""--debug="", ""--debug"");
  AddOption(""--debug-brk"", """", &DebugOptions::deprecated_debug);
  AddAlias(""--debug-brk="", ""--debug-brk"");

  AddOption(""--inspect-brk"",
            ""activate inspector on host:port and break at start of user script"",
            &DebugOptions::break_first_line,
            kAllowedInEnvvar);
  Implies(""--inspect-brk"", ""--inspect"");
 ...",1,1,node_options.cc,node.options_parser.DebugOptionsParser.DebugOptionsParser,,false,298,336,DebugOptionsParser,,,13,ANY node.options_parser.DebugOptionsParser.DebugOptionsParser ()
210590,METHOD,node_options.cc:<global>,TYPE_DECL,"EnvironmentOptionsParser::EnvironmentOptionsParser() {
  AddOption(""--conditions"",
            ""additional user conditions for conditional exports and imports"",
            &EnvironmentOptions::conditions,
            kAllowedInEnvvar);
  AddAlias(""-C"", ""--conditions"");
  AddOption(""--diagnostic-dir"",
            ""set dir for all output files""
            "" (default: current working directory)"",
            &EnvironmentOptions::diagnostic_dir,
            kAllowedInEnvvar);
  AddOption(""--dns-result-order"",
            ""set default value of verbatim in dns.lookup. Options are ""
            ""'ipv4first' (IPv4 addresses are placed before IPv6 addresses) ""
            ""'verbatim' (addresses are in the order the DNS resolver ""
            ""returned)"",
            &EnvironmentOptions::dns_result_order,
            kAllowedInEnvvar);
  AddOption(""--network-family-autoselection"",
            ""Disable network address family autodetection algorithm"",
            &EnvironmentOptions::network_...",1,1,node_options.cc,node.options_parser.EnvironmentOptionsParser.EnvironmentOptionsParser,,false,338,739,EnvironmentOptionsParser,,,14,ANY node.options_parser.EnvironmentOptionsParser.EnvironmentOptionsParser ()
211319,METHOD,node_options.cc:<global>,TYPE_DECL,"PerIsolateOptionsParser::PerIsolateOptionsParser(
  const EnvironmentOptionsParser& eop) {
  AddOption(""--track-heap-objects"",
            ""track heap object allocations for heap snapshots"",
            &PerIsolateOptions::track_heap_objects,
            kAllowedInEnvvar);

  // Explicitly add some V8 flags to mark them as allowed in NODE_OPTIONS.
  AddOption(""--abort-on-uncaught-exception"",
            ""aborting instead of exiting causes a core file to be generated ""
            ""for analysis"",
            V8Option{},
            kAllowedInEnvvar);
  AddOption(""--interpreted-frames-native-stack"",
            ""help system profilers to translate JavaScript interpreted frames"",
            V8Option{},
            kAllowedInEnvvar);
  AddOption(""--max-old-space-size"", """", V8Option{}, kAllowedInEnvvar);
  AddOption(""--max-semi-space-size"", """", V8Option{}, kAllowedInEnvvar);
  AddOption(""--perf-basic-prof"", """", V8Option{}, kAllowedInEnvvar);
  AddOption(
      ""--perf-basic-prof-only-fun...",1,1,node_options.cc,node.options_parser.PerIsolateOptionsParser.PerIsolateOptionsParser,,false,741,814,PerIsolateOptionsParser,,,15,ANY node.options_parser.PerIsolateOptionsParser.PerIsolateOptionsParser (EnvironmentOptionsParser)
211479,METHOD,node_options.cc:<global>,TYPE_DECL,"PerProcessOptionsParser::PerProcessOptionsParser(
  const PerIsolateOptionsParser& iop) {
  AddOption(""--title"",
            ""the process title to use on startup"",
            &PerProcessOptions::title,
            kAllowedInEnvvar);
  AddOption(""--trace-event-categories"",
            ""comma separated list of trace event categories to record"",
            &PerProcessOptions::trace_event_categories,
            kAllowedInEnvvar);
  AddOption(""--trace-event-file-pattern"",
            ""Template string specifying the filepath for the trace-events ""
            ""data, it supports ${rotation} and ${pid}."",
            &PerProcessOptions::trace_event_file_pattern,
            kAllowedInEnvvar);
  AddAlias(""--trace-events-enabled"", {
    ""--trace-event-categories"", ""v8,node,node.async_hooks"" });
  AddOption(""--v8-pool-size"",
            ""set V8's thread pool size"",
            &PerProcessOptions::v8_thread_pool_size,
            kAllowedInEnvvar);
  AddOption(""--zero-fill-buffers"",
        ...",1,1,node_options.cc,node.options_parser.PerProcessOptionsParser.PerProcessOptionsParser,,false,816,998,PerProcessOptionsParser,,,16,ANY node.options_parser.PerProcessOptionsParser.PerProcessOptionsParser (PerIsolateOptionsParser)
211681,METHOD,node_options.cc:<global>,TYPE_DECL,"inline std::string RemoveBrackets(const std::string& host) {
  if (!host.empty() && host.front() == '[' && host.back() == ']')
    return host.substr(1, host.size() - 2);
  else
    return host;
}",1,1,node_options.cc,node.options_parser.RemoveBrackets,,false,1000,1005,RemoveBrackets,,,17,string node.options_parser.RemoveBrackets (ANY)
211723,METHOD,node_options.cc:<global>,TYPE_DECL,"inline int ParseAndValidatePort(const std::string& port,
                                std::vector<std::string>* errors) {
  char* endptr;
  errno = 0;
  const unsigned long result =                 // NOLINT(runtime/int)
    strtoul(port.c_str(), &endptr, 10);
  if (errno != 0 || *endptr != '\0'||
      (result != 0 && result < 1024) || result > 65535) {
    errors->push_back("" must be 0 or in range 1024 to 65535."");
  }
  return static_cast<int>(result);
}",1,1,node_options.cc,node.options_parser.ParseAndValidatePort,,false,1007,1018,ParseAndValidatePort,,,18,"int node.options_parser.ParseAndValidatePort (ANY,ANY*)"
211775,METHOD,node_options.cc:<global>,TYPE_DECL,"HostPort SplitHostPort(const std::string& arg,
                      std::vector<std::string>* errors) {
  // remove_brackets only works if no port is specified
  // so if it has an effect only an IPv6 address was specified.
  std::string host = RemoveBrackets(arg);
  if (host.length() < arg.length())
    return HostPort{host, DebugOptions::kDefaultInspectorPort};

  size_t colon = arg.rfind(':');
  if (colon == std::string::npos) {
    // Either a port number or a host name.  Assume that
    // if it's not all decimal digits, it's a host name.
    for (char c : arg) {
      if (c < '0' || c > '9') {
        return HostPort{arg, DebugOptions::kDefaultInspectorPort};
      }
    }
    return HostPort { """", ParseAndValidatePort(arg, errors) };
  }
  // Host and port found:
  return HostPort { RemoveBrackets(arg.substr(0, colon)),
                    ParseAndValidatePort(arg.substr(colon + 1), errors) };
}",1,1,node_options.cc,node.options_parser.SplitHostPort,,false,1020,1042,SplitHostPort,,,19,"HostPort node.options_parser.SplitHostPort (ANY,ANY*)"
211867,METHOD,node_options.cc:<global>,TYPE_DECL,"std::string GetBashCompletion() {
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  const auto& parser = _ppop_instance;

  std::ostringstream out;

  out << ""_node_complete() {\n""
         ""  local cur_word options\n""
         ""  cur_word=\""${COMP_WORDS[COMP_CWORD]}\""\n""
         ""  if [[ \""${cur_word}\"" == -* ]] ; then\n""
         ""    COMPREPLY=( $(compgen -W '"";

  for (const auto& item : parser.options_) {
    if (item.first[0] != '[') {
      out << item.first << "" "";
    }
  }
  for (const auto& item : parser.aliases_) {
    if (item.first[0] != '[') {
      out << item.first << "" "";
    }
  }
  if (parser.aliases_.size() > 0) {
    out.seekp(-1, out.cur);  // Strip the trailing space
  }

  out << ""' -- \""${cur_word}\"") )\n""
         ""    return 0\n""
         ""  else\n""
         ""    COMPREPLY=( $(compgen -f \""${cur_word}\"") )\n""
         ""    return 0\n""
         ""  fi\n""
         ""}\n""
         ""complete -o filenames -o nospace -o bashdefault ""
         ""-F _node...",1,1,node_options.cc,node.options_parser.GetBashCompletion,,false,1044,1080,GetBashCompletion,,,20,string node.options_parser.GetBashCompletion ()
211955,METHOD,node_options.cc:<global>,TYPE_DECL,"void GetCLIOptions(const FunctionCallbackInfo<Value>& args) {
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Environment* env = Environment::GetCurrent(args);
  if (!env->has_run_bootstrapping_code()) {
    // No code because this is an assertion.
    return env->ThrowError(
        ""Should not query options before bootstrapping is done"");
  }
  env->set_has_serialized_options(true);

  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();

  // Temporarily act as if the current Environment's/IsolateData's options were
  // the default options, i.e. like they are the ones we'd access for global
  // options parsing, so that all options are available from the main parser.
  auto original_per_isolate = per_process::cli_options->per_isolate;
  per_process::cli_options->per_isolate = env->isolate_data()->options();
  auto original_per_env = per_process::cli_options->per_isolate->per_env;
  per_process::cli_options->per_isolate->per_env = env->options...",1,1,node_options.cc,node.options_parser.GetCLIOptions,,false,1084,1223,GetCLIOptions,,,21,void node.options_parser.GetCLIOptions (FunctionCallbackInfo<Value>)
212600,METHOD,node_options.cc:<global>,TYPE_DECL,"void GetEmbedderOptions(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  if (!env->has_run_bootstrapping_code()) {
    // No code because this is an assertion.
    return env->ThrowError(
        ""Should not query options before bootstrapping is done"");
  }
  Isolate* isolate = args.GetIsolate();
  Local<Context> context = env->context();
  Local<Object> ret = Object::New(isolate);

  if (ret->Set(context,
           FIXED_ONE_BYTE_STRING(env->isolate(), ""shouldNotRegisterESMLoader""),
           Boolean::New(isolate, env->should_not_register_esm_loader()))
      .IsNothing()) return;

  if (ret->Set(context,
           FIXED_ONE_BYTE_STRING(env->isolate(), ""noGlobalSearchPaths""),
           Boolean::New(isolate, env->no_global_search_paths()))
      .IsNothing()) return;

  if (ret->Set(context,
               FIXED_ONE_BYTE_STRING(env->isolate(), ""noBrowserGlobals""),
               Boolean::New(isolate, env->no_browser_globals()))
   ...",1,1,node_options.cc,node.options_parser.GetEmbedderOptions,,false,1225,1253,GetEmbedderOptions,,,22,void node.options_parser.GetEmbedderOptions (FunctionCallbackInfo<Value>)
212740,METHOD,node_options.cc:<global>,TYPE_DECL,"void Initialize(Local<Object> target,
                Local<Value> unused,
                Local<Context> context,
                void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();
  SetMethodNoSideEffect(context, target, ""getCLIOptions"", GetCLIOptions);
  SetMethodNoSideEffect(
      context, target, ""getEmbedderOptions"", GetEmbedderOptions);

  Local<Object> env_settings = Object::New(isolate);
  NODE_DEFINE_CONSTANT(env_settings, kAllowedInEnvvar);
  NODE_DEFINE_CONSTANT(env_settings, kDisallowedInEnvvar);
  target
      ->Set(
          context, FIXED_ONE_BYTE_STRING(isolate, ""envSettings""), env_settings)
      .Check();

  Local<Object> types = Object::New(isolate);
  NODE_DEFINE_CONSTANT(types, kNoOp);
  NODE_DEFINE_CONSTANT(types, kV8Option);
  NODE_DEFINE_CONSTANT(types, kBoolean);
  NODE_DEFINE_CONSTANT(types, kInteger);
  NODE_DEFINE_CONSTANT(types, kUInteger);
  NODE_DEFINE_CONSTANT(types, kString);
  NODE_DEFINE_CON...",1,1,node_options.cc,node.options_parser.Initialize,,false,1255,1284,Initialize,,,23,"void node.options_parser.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
212849,METHOD,node_options.cc:<global>,TYPE_DECL,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(GetCLIOptions);
  registry->Register(GetEmbedderOptions);
}",1,1,node_options.cc,node.options_parser.RegisterExternalReferences,,false,1286,1289,RegisterExternalReferences,,,24,void node.options_parser.RegisterExternalReferences (ExternalReferenceRegistry*)
212864,METHOD,node_options.cc:<global>,TYPE_DECL,"void HandleEnvOptions(std::shared_ptr<EnvironmentOptions> env_options) {
  HandleEnvOptions(env_options, [](const char* name) {
    std::string text;
    return credentials::SafeGetenv(name, &text) ? text : """";
  });
}",1,1,node_options.cc,node.HandleEnvOptions,,false,1292,1297,HandleEnvOptions,,,7,void node.HandleEnvOptions (ANY)
212872,METHOD,node_options.cc:<global>,TYPE_DECL,"void HandleEnvOptions(std::shared_ptr<EnvironmentOptions> env_options,
                      std::function<std::string(const char*)> opt_getter) {
  env_options->pending_deprecation =
      opt_getter(""NODE_PENDING_DEPRECATION"") == ""1"";

  env_options->preserve_symlinks = opt_getter(""NODE_PRESERVE_SYMLINKS"") == ""1"";

  env_options->preserve_symlinks_main =
      opt_getter(""NODE_PRESERVE_SYMLINKS_MAIN"") == ""1"";

  if (env_options->redirect_warnings.empty())
    env_options->redirect_warnings = opt_getter(""NODE_REDIRECT_WARNINGS"");
}",1,1,node_options.cc,node.HandleEnvOptions,,false,1299,1311,HandleEnvOptions,,,8,"void node.HandleEnvOptions (ANY,ANY)"
212916,METHOD,node_options.cc:<global>,TYPE_DECL,"std::vector<std::string> ParseNodeOptionsEnvVar(
    const std::string& node_options, std::vector<std::string>* errors) {
  std::vector<std::string> env_argv;

  bool is_in_string = false;
  bool will_start_new_arg = true;
  for (std::string::size_type index = 0; index < node_options.size(); ++index) {
    char c = node_options.at(index);

    // Backslashes escape the following character
    if (c == '\\' && is_in_string) {
      if (index + 1 == node_options.size()) {
        errors->push_back(""invalid value for NODE_OPTIONS ""
                          ""(invalid escape)\n"");
        return env_argv;
      } else {
        c = node_options.at(++index);
      }
    } else if (c == ' ' && !is_in_string) {
      will_start_new_arg = true;
      continue;
    } else if (c == '""') {
      is_in_string = !is_in_string;
      continue;
    }

    if (will_start_new_arg) {
      env_argv.emplace_back(std::string(1, c));
      will_start_new_arg = false;
    } else {
      env_argv.back() +...",1,1,node_options.cc,node.ParseNodeOptionsEnvVar,,false,1313,1352,ParseNodeOptionsEnvVar,,,9,"vector<std::string> node.ParseNodeOptionsEnvVar (ANY,ANY*)"
213076,METHOD,node_options.hpp:<global>,TYPE_DECL,<global>,1,30,node_options.hpp,node_options.hpp:<global>,,false,1,536,<global>,,,1,
213079,METHOD,node_os.cc:<global>,TYPE_DECL,[&]() { uv_os_free_passwd(&pwd); },35,68,node_os.cc,node.os.GetUserInfo.<lambda>0,,false,299,299,<lambda>0,,,1,ANY node.os.GetUserInfo.<lambda>0 ()
213106,METHOD,node_os.cc:<global>,TYPE_DECL,<global>,1,1,node_os.cc,node_os.cc:<global>,,false,1,434,<global>,,,1,
213110,METHOD,node_os.cc:<global>,TYPE_DECL,"static void GetHostname(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  char buf[UV_MAXHOSTNAMESIZE];
  size_t size = sizeof(buf);
  int r = uv_os_gethostname(buf, &size);

  if (r != 0) {
    CHECK_GE(args.Length(), 1);
    env->CollectUVExceptionInfo(args[args.Length() - 1], r,
                                ""uv_os_gethostname"");
    return args.GetReturnValue().SetUndefined();
  }

  args.GetReturnValue().Set(
      String::NewFromUtf8(env->isolate(), buf).ToLocalChecked());
}",1,1,node_os.cc,node.os.GetHostname,,false,60,75,GetHostname,,,1,void node.os.GetHostname (FunctionCallbackInfo<Value>)
213188,METHOD,node_os.cc:<global>,TYPE_DECL,"static void GetOSInformation(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  uv_utsname_t info;
  int err = uv_os_uname(&info);

  if (err != 0) {
    CHECK_GE(args.Length(), 1);
    env->CollectUVExceptionInfo(args[args.Length() - 1], err, ""uv_os_uname"");
    return args.GetReturnValue().SetUndefined();
  }

  // [sysname, version, release, machine]
  Local<Value> osInformation[] = {
      String::NewFromUtf8(env->isolate(), info.sysname).ToLocalChecked(),
      String::NewFromUtf8(env->isolate(), info.version).ToLocalChecked(),
      String::NewFromUtf8(env->isolate(), info.release).ToLocalChecked(),
      String::NewFromUtf8(env->isolate(), info.machine).ToLocalChecked()};

  args.GetReturnValue().Set(Array::New(env->isolate(),
                                       osInformation,
                                       arraysize(osInformation)));
}",1,1,node_os.cc,node.os.GetOSInformation,,false,77,98,GetOSInformation,,,2,void node.os.GetOSInformation (FunctionCallbackInfo<Value>)
213319,METHOD,node_os.cc:<global>,TYPE_DECL,"static void GetCPUInfo(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  uv_cpu_info_t* cpu_infos;
  int count;

  int err = uv_cpu_info(&cpu_infos, &count);
  if (err)
    return;

  // It's faster to create an array packed with all the data and
  // assemble them into objects in JS than to call Object::Set() repeatedly
  // The array is in the format
  // [model, speed, (5 entries of cpu_times), model2, speed2, ...]
  std::vector<Local<Value>> result;
  result.reserve(count * 7);
  for (int i = 0; i < count; i++) {
    uv_cpu_info_t* ci = cpu_infos + i;
    result.emplace_back(OneByteString(isolate, ci->model));
    result.emplace_back(Number::New(isolate, ci->speed));
    result.emplace_back(
        Number::New(isolate, static_cast<double>(ci->cpu_times.user)));
    result.emplace_back(
        Number::New(isolate, static_cast<double>(ci->cpu_times.nice)));
    result.emplace_back(
        Numbe...",1,1,node_os.cc,node.os.GetCPUInfo,,false,100,135,GetCPUInfo,,,3,void node.os.GetCPUInfo (FunctionCallbackInfo<Value>)
213511,METHOD,node_os.cc:<global>,TYPE_DECL,"static void GetFreeMemory(const FunctionCallbackInfo<Value>& args) {
  double amount = static_cast<double>(uv_get_free_memory());
  args.GetReturnValue().Set(amount);
}",1,1,node_os.cc,node.os.GetFreeMemory,,false,138,141,GetFreeMemory,,,4,void node.os.GetFreeMemory (FunctionCallbackInfo<Value>)
213530,METHOD,node_os.cc:<global>,TYPE_DECL,"static void GetTotalMemory(const FunctionCallbackInfo<Value>& args) {
  double amount = static_cast<double>(uv_get_total_memory());
  args.GetReturnValue().Set(amount);
}",1,1,node_os.cc,node.os.GetTotalMemory,,false,144,147,GetTotalMemory,,,5,void node.os.GetTotalMemory (FunctionCallbackInfo<Value>)
213549,METHOD,node_os.cc:<global>,TYPE_DECL,"static void GetUptime(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  double uptime;
  int err = uv_uptime(&uptime);
  if (err != 0) {
    env->CollectUVExceptionInfo(args[args.Length() - 1], err, ""uv_uptime"");
    return args.GetReturnValue().SetUndefined();
  }

  args.GetReturnValue().Set(uptime);
}",1,1,node_os.cc,node.os.GetUptime,,false,150,160,GetUptime,,,6,void node.os.GetUptime (FunctionCallbackInfo<Value>)
213604,METHOD,node_os.cc:<global>,TYPE_DECL,"static void GetLoadAvg(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsFloat64Array());
  Local<Float64Array> array = args[0].As<Float64Array>();
  CHECK_EQ(array->Length(), 3);
  Local<ArrayBuffer> ab = array->Buffer();
  double* loadavg = static_cast<double*>(ab->Data());
  uv_loadavg(loadavg);
}",1,1,node_os.cc,node.os.GetLoadAvg,,false,163,170,GetLoadAvg,,,7,void node.os.GetLoadAvg (FunctionCallbackInfo<Value>)
213655,METHOD,node_os.cc:<global>,TYPE_DECL,"static void GetInterfaceAddresses(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  uv_interface_address_t* interfaces;
  int count, i;
  char ip[INET6_ADDRSTRLEN];
  char netmask[INET6_ADDRSTRLEN];
  std::array<char, 18> mac;
  Local<String> name, family;

  int err = uv_interface_addresses(&interfaces, &count);

  if (err == UV_ENOSYS)
    return args.GetReturnValue().SetUndefined();

  if (err) {
    CHECK_GE(args.Length(), 1);
    env->CollectUVExceptionInfo(args[args.Length() - 1], errno,
                                ""uv_interface_addresses"");
    return args.GetReturnValue().SetUndefined();
  }

  Local<Value> no_scope_id = Integer::New(isolate, -1);
  std::vector<Local<Value>> result;
  result.reserve(count * 7);
  for (i = 0; i < count; i++) {
    const char* const raw_name = interfaces[i].name;

    // Use UTF-8 on both Windows and Unixes (While it may be true that UNIX
    // systems are...",1,1,node_os.cc,node.os.GetInterfaceAddresses,,false,173,248,GetInterfaceAddresses,,,8,void node.os.GetInterfaceAddresses (FunctionCallbackInfo<Value>)
214071,METHOD,node_os.cc:<global>,TYPE_DECL,"static void GetHomeDirectory(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  char buf[PATH_MAX];

  size_t len = sizeof(buf);
  const int err = uv_os_homedir(buf, &len);

  if (err) {
    CHECK_GE(args.Length(), 1);
    env->CollectUVExceptionInfo(args[args.Length() - 1], err, ""uv_os_homedir"");
    return args.GetReturnValue().SetUndefined();
  }

  Local<String> home = String::NewFromUtf8(env->isolate(),
                                           buf,
                                           NewStringType::kNormal,
                                           len).ToLocalChecked();
  args.GetReturnValue().Set(home);
}",1,1,node_os.cc,node.os.GetHomeDirectory,,false,251,269,GetHomeDirectory,,,9,void node.os.GetHomeDirectory (FunctionCallbackInfo<Value>)
214158,METHOD,node_os.cc:<global>,TYPE_DECL,"static void GetUserInfo(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  uv_passwd_t pwd;
  enum encoding encoding;

  if (args[0]->IsObject()) {
    Local<Object> options = args[0].As<Object>();
    MaybeLocal<Value> maybe_encoding = options->Get(env->context(),
                                                    env->encoding_string());
    Local<Value> encoding_opt;
    if (!maybe_encoding.ToLocal(&encoding_opt))
        return;

    encoding = ParseEncoding(env->isolate(), encoding_opt, UTF8);
  } else {
    encoding = UTF8;
  }

  const int err = uv_os_get_passwd(&pwd);

  if (err) {
    CHECK_GE(args.Length(), 2);
    env->CollectUVExceptionInfo(args[args.Length() - 1], err,
                                ""uv_os_get_passwd"");
    return args.GetReturnValue().SetUndefined();
  }

  auto free_passwd = OnScopeLeave([&]() { uv_os_free_passwd(&pwd); });

  Local<Value> error;

  Local<Value> uid = Number::New(env->isolate(), pwd.uid)...",1,1,node_os.cc,node.os.GetUserInfo,,false,272,341,GetUserInfo,,,10,void node.os.GetUserInfo (FunctionCallbackInfo<Value>)
214539,METHOD,node_os.cc:<global>,TYPE_DECL,"static void SetPriority(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  CHECK_EQ(args.Length(), 3);
  CHECK(args[0]->IsInt32());
  CHECK(args[1]->IsInt32());

  const int pid = args[0].As<Int32>()->Value();
  const int priority = args[1].As<Int32>()->Value();
  const int err = uv_os_setpriority(pid, priority);

  if (err) {
    CHECK(args[2]->IsObject());
    env->CollectUVExceptionInfo(args[2], err, ""uv_os_setpriority"");
  }

  args.GetReturnValue().Set(err);
}",1,1,node_os.cc,node.os.SetPriority,,false,344,361,SetPriority,,,11,void node.os.SetPriority (FunctionCallbackInfo<Value>)
214629,METHOD,node_os.cc:<global>,TYPE_DECL,"static void GetPriority(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  CHECK_EQ(args.Length(), 2);
  CHECK(args[0]->IsInt32());

  const int pid = args[0].As<Int32>()->Value();
  int priority;
  const int err = uv_os_getpriority(pid, &priority);

  if (err) {
    CHECK(args[1]->IsObject());
    env->CollectUVExceptionInfo(args[1], err, ""uv_os_getpriority"");
    return;
  }

  args.GetReturnValue().Set(priority);
}",1,1,node_os.cc,node.os.GetPriority,,false,364,381,GetPriority,,,12,void node.os.GetPriority (FunctionCallbackInfo<Value>)
214703,METHOD,node_os.cc:<global>,TYPE_DECL,"static void GetAvailableParallelism(const FunctionCallbackInfo<Value>& args) {
  unsigned int parallelism = uv_available_parallelism();
  args.GetReturnValue().Set(parallelism);
}",1,1,node_os.cc,node.os.GetAvailableParallelism,,false,383,386,GetAvailableParallelism,,,13,void node.os.GetAvailableParallelism (FunctionCallbackInfo<Value>)
214720,METHOD,node_os.cc:<global>,TYPE_DECL,"void Initialize(Local<Object> target,
                Local<Value> unused,
                Local<Context> context,
                void* priv) {
  Environment* env = Environment::GetCurrent(context);
  SetMethod(context, target, ""getHostname"", GetHostname);
  SetMethod(context, target, ""getLoadAvg"", GetLoadAvg);
  SetMethod(context, target, ""getUptime"", GetUptime);
  SetMethod(context, target, ""getTotalMem"", GetTotalMemory);
  SetMethod(context, target, ""getFreeMem"", GetFreeMemory);
  SetMethod(context, target, ""getCPUs"", GetCPUInfo);
  SetMethod(context, target, ""getInterfaceAddresses"", GetInterfaceAddresses);
  SetMethod(context, target, ""getHomeDirectory"", GetHomeDirectory);
  SetMethod(context, target, ""getUserInfo"", GetUserInfo);
  SetMethod(context, target, ""setPriority"", SetPriority);
  SetMethod(context, target, ""getPriority"", GetPriority);
  SetMethod(
      context, target, ""getAvailableParallelism"", GetAvailableParallelism);
  SetMethod(context, target, ""getOSInformation""...",1,1,node_os.cc,node.os.Initialize,,false,388,412,Initialize,,,14,"void node.os.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
214824,METHOD,node_os.cc:<global>,TYPE_DECL,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(GetHostname);
  registry->Register(GetLoadAvg);
  registry->Register(GetUptime);
  registry->Register(GetTotalMemory);
  registry->Register(GetFreeMemory);
  registry->Register(GetCPUInfo);
  registry->Register(GetInterfaceAddresses);
  registry->Register(GetHomeDirectory);
  registry->Register(GetUserInfo);
  registry->Register(SetPriority);
  registry->Register(GetPriority);
  registry->Register(GetAvailableParallelism);
  registry->Register(GetOSInformation);
}",1,1,node_os.cc,node.os.RegisterExternalReferences,,false,414,428,RegisterExternalReferences,,,15,void node.os.RegisterExternalReferences (ExternalReferenceRegistry*)
214896,METHOD,node_perf.cc:<global>,TYPE_DECL,"[entry = std::move(entry)](Environment* env) {
    entry->Notify(env);
  }",21,3,node_perf.cc,node.performance.MarkGarbageCollectionEnd.<lambda>0,,false,191,193,<lambda>0,,,1,ANY node.performance.MarkGarbageCollectionEnd.<lambda>0 (Environment*)
214909,METHOD,node_perf.cc:<global>,TYPE_DECL,"[](Histogram& histogram) {
        uint64_t delta = histogram.RecordDelta();
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                        ""delay"", delta);
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""min"", histogram.Min());
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""max"", histogram.Max());
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""mean"", histogram.Mean());
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""stddev"", histogram.Stddev());
      }",48,7,node_perf.cc,node.performance.CreateELDHistogram.<lambda>1,,false,262,274,<lambda>1,,,1,ANY node.performance.CreateELDHistogram.<lambda>1 (Histogram)
214987,METHOD,node_perf.cc:<global>,TYPE_DECL,<global>,1,27,node_perf.hpp,node_perf.cc:<global>,,false,1,397,<global>,,,1,
215000,METHOD,node_perf.cc:<global>,TYPE_DECL,"PerformanceState::PerformanceState(Isolate* isolate,
                                   const PerformanceState::SerializeInfo* info)
    : root(isolate,
           sizeof(performance_state_internal),
           MAYBE_FIELD_PTR(info, root)),
      milestones(isolate,
                 offsetof(performance_state_internal, milestones),
                 NODE_PERFORMANCE_MILESTONE_INVALID,
                 root,
                 MAYBE_FIELD_PTR(info, milestones)),
      observers(isolate,
                offsetof(performance_state_internal, observers),
                NODE_PERFORMANCE_ENTRY_TYPE_INVALID,
                root,
                MAYBE_FIELD_PTR(info, observers)) {
  if (info == nullptr) {
    for (size_t i = 0; i < milestones.Length(); i++) milestones[i] = -1.;
  }
}",1,1,node_perf.cc,node.performance.PerformanceState.PerformanceState,,false,45,63,PerformanceState,,,6,"ANY node.performance.PerformanceState.PerformanceState (Isolate*,ANY*)"
215031,METHOD,node_perf.cc:<global>,TYPE_DECL,"PerformanceState::SerializeInfo PerformanceState::Serialize(
    v8::Local<v8::Context> context, v8::SnapshotCreator* creator) {
  SerializeInfo info{root.Serialize(context, creator),
                     milestones.Serialize(context, creator),
                     observers.Serialize(context, creator)};
  return info;
}",1,1,node_perf.cc,node.performance.PerformanceState.Serialize,,false,65,71,Serialize,,,7,"SerializeInfo node.performance.PerformanceState.Serialize (ANY,ANY*)"
215061,METHOD,node_perf.cc:<global>,TYPE_DECL,"void PerformanceState::Deserialize(v8::Local<v8::Context> context) {
  root.Deserialize(context);
  // This is just done to set up the pointers, we will actually reset
  // all the milestones after deserialization.
  milestones.Deserialize(context);
  observers.Deserialize(context);
}",1,1,node_perf.cc,node.performance.PerformanceState.Deserialize,,false,73,79,Deserialize,,,8,void node.performance.PerformanceState.Deserialize (ANY)
215081,METHOD,node_perf.cc:<global>,TYPE_DECL,"std::ostream& operator<<(std::ostream& o,
                         const PerformanceState::SerializeInfo& i) {
  o << ""{\n""
    << ""  "" << i.root << "",  // root\n""
    << ""  "" << i.milestones << "",  // milestones\n""
    << ""  "" << i.observers << "",  // observers\n""
    << ""}"";
  return o;
}",1,1,node_perf.cc,node.performance.operator <<,,false,81,89,operator <<,,,9,"ostream node.performance.operator << (ANY,ANY)"
215118,METHOD,node_perf.cc:<global>,TYPE_DECL,"void PerformanceState::Mark(PerformanceMilestone milestone, uint64_t ts) {
  this->milestones[milestone] = static_cast<double>(ts);
  TRACE_EVENT_INSTANT_WITH_TIMESTAMP0(
      TRACING_CATEGORY_NODE1(bootstrap),
      GetPerformanceMilestoneName(milestone),
      TRACE_EVENT_SCOPE_THREAD, ts / 1000);
}",1,1,node_perf.cc,node.performance.PerformanceState.Mark,,false,91,97,Mark,,,10,"void node.performance.PerformanceState.Mark (PerformanceMilestone,uint64_t)"
215142,METHOD,node_perf.cc:<global>,TYPE_DECL,"void MarkMilestone(const FunctionCallbackInfo<Value>& args) {
  Realm* realm = Realm::GetCurrent(args);
  // TODO(legendecas): Remove this check once the sub-realms are supported.
  CHECK_EQ(realm->kind(), Realm::Kind::kPrincipal);
  Environment* env = realm->env();
  PerformanceMilestone milestone =
      static_cast<PerformanceMilestone>(args[0].As<Int32>()->Value());
  if (milestone != NODE_PERFORMANCE_MILESTONE_INVALID)
    env->performance_state()->Mark(milestone);
}",1,1,node_perf.cc,node.performance.MarkMilestone,,false,100,109,MarkMilestone,,,11,void node.performance.MarkMilestone (FunctionCallbackInfo<Value>)
215199,METHOD,node_perf.cc:<global>,TYPE_DECL,"void SetupPerformanceObservers(const FunctionCallbackInfo<Value>& args) {
  Realm* realm = Realm::GetCurrent(args);
  // TODO(legendecas): Remove this check once the sub-realms are supported.
  CHECK_EQ(realm->kind(), Realm::Kind::kPrincipal);
  CHECK(args[0]->IsFunction());
  realm->set_performance_entry_callback(args[0].As<Function>());
}",1,1,node_perf.cc,node.performance.SetupPerformanceObservers,,false,111,117,SetupPerformanceObservers,,,12,void node.performance.SetupPerformanceObservers (FunctionCallbackInfo<Value>)
215239,METHOD,node_perf.cc:<global>,TYPE_DECL,"void MarkGarbageCollectionStart(
    Isolate* isolate,
    GCType type,
    GCCallbackFlags flags,
    void* data) {
  Environment* env = static_cast<Environment*>(data);
  // Prevent gc callback from reentering with different type
  // See https://github.com/nodejs/node/issues/44046
  if (env->performance_state()->current_gc_type != 0) {
    return;
  }
  env->performance_state()->performance_last_gc_start_mark = PERFORMANCE_NOW();
  env->performance_state()->current_gc_type = type;
}",1,1,node_perf.cc,node.performance.MarkGarbageCollectionStart,,false,120,133,MarkGarbageCollectionStart,,,13,"void node.performance.MarkGarbageCollectionStart (Isolate*,GCType,GCCallbackFlags,void*)"
215280,METHOD,node_perf.cc:<global>,TYPE_DECL,"MaybeLocal<Object> GCPerformanceEntryTraits::GetDetails(
    Environment* env,
    const GCPerformanceEntry& entry) {
  Local<Object> obj = Object::New(env->isolate());

  if (!obj->Set(
          env->context(),
          env->kind_string(),
          Integer::NewFromUnsigned(
              env->isolate(),
              entry.details.kind)).IsJust()) {
    return MaybeLocal<Object>();
  }

  if (!obj->Set(
          env->context(),
          env->flags_string(),
          Integer::NewFromUnsigned(
              env->isolate(),
              entry.details.flags)).IsJust()) {
    return MaybeLocal<Object>();
  }

  return obj;
}",1,1,node_perf.cc,node.performance.GCPerformanceEntryTraits.GetDetails,,false,135,159,GetDetails,,,14,"MaybeLocal<Object> node.performance.GCPerformanceEntryTraits.GetDetails (Environment*,GCPerformanceEntry)"
215368,METHOD,node_perf.cc:<global>,TYPE_DECL,"void MarkGarbageCollectionEnd(
    Isolate* isolate,
    GCType type,
    GCCallbackFlags flags,
    void* data) {
  Environment* env = static_cast<Environment*>(data);
  PerformanceState* state = env->performance_state();
  if (type != state->current_gc_type) {
    return;
  }
  env->performance_state()->current_gc_type = 0;
  // If no one is listening to gc performance entries, do not create them.
  if (LIKELY(!state->observers[NODE_PERFORMANCE_ENTRY_TYPE_GC]))
    return;

  double start_time =
      (state->performance_last_gc_start_mark - env->time_origin()) /
      NANOS_PER_MILLIS;
  double duration = (PERFORMANCE_NOW() / NANOS_PER_MILLIS) -
                    (state->performance_last_gc_start_mark / NANOS_PER_MILLIS);

  std::unique_ptr<GCPerformanceEntry> entry =
      std::make_unique<GCPerformanceEntry>(
          ""gc"",
          start_time,
          duration,
          GCPerformanceEntry::Details(static_cast<PerformanceGCKind>(type),
                                   ...",1,6,node_perf.cc,node.performance.MarkGarbageCollectionEnd,,false,162,194,MarkGarbageCollectionEnd,,,15,"void node.performance.MarkGarbageCollectionEnd (Isolate*,GCType,GCCallbackFlags,void*)"
215482,METHOD,node_perf.cc:<global>,TYPE_DECL,"void GarbageCollectionCleanupHook(void* data) {
  Environment* env = static_cast<Environment*>(data);
  // Reset current_gc_type to 0
  env->performance_state()->current_gc_type = 0;
  env->isolate()->RemoveGCPrologueCallback(MarkGarbageCollectionStart, data);
  env->isolate()->RemoveGCEpilogueCallback(MarkGarbageCollectionEnd, data);
}",1,1,node_perf.cc,node.performance.GarbageCollectionCleanupHook,,false,196,202,GarbageCollectionCleanupHook,,,16,void node.performance.GarbageCollectionCleanupHook (void*)
215519,METHOD,node_perf.cc:<global>,TYPE_DECL,"static void InstallGarbageCollectionTracking(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  // Reset current_gc_type to 0
  env->performance_state()->current_gc_type = 0;
  env->isolate()->AddGCPrologueCallback(MarkGarbageCollectionStart,
                                        static_cast<void*>(env));
  env->isolate()->AddGCEpilogueCallback(MarkGarbageCollectionEnd,
                                        static_cast<void*>(env));
  env->AddCleanupHook(GarbageCollectionCleanupHook, env);
}",1,1,node_perf.cc,node.performance.InstallGarbageCollectionTracking,,false,204,214,InstallGarbageCollectionTracking,,,17,void node.performance.InstallGarbageCollectionTracking (FunctionCallbackInfo<Value>)
215568,METHOD,node_perf.cc:<global>,TYPE_DECL,"static void RemoveGarbageCollectionTracking(
  const FunctionCallbackInfo<Value> &args) {
  Environment* env = Environment::GetCurrent(args);

  env->RemoveCleanupHook(GarbageCollectionCleanupHook, env);
  GarbageCollectionCleanupHook(env);
}",1,1,node_perf.cc,node.performance.RemoveGarbageCollectionTracking,,false,216,222,RemoveGarbageCollectionTracking,,,18,void node.performance.RemoveGarbageCollectionTracking (FunctionCallbackInfo<Value>)
215589,METHOD,node_perf.cc:<global>,TYPE_DECL,"inline Local<Value> GetName(Local<Function> fn) {
  Local<Value> val = fn->GetDebugName();
  if (val.IsEmpty() || val->IsUndefined()) {
    Local<Value> boundFunction = fn->GetBoundFunction();
    if (!boundFunction.IsEmpty() && !boundFunction->IsUndefined()) {
      val = GetName(boundFunction.As<Function>());
    }
  }
  return val;
}",1,1,node_perf.cc,node.performance.GetName,,false,225,234,GetName,,,19,Local<Value> node.performance.GetName (Local<Function>)
215647,METHOD,node_perf.cc:<global>,TYPE_DECL,"void Notify(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Utf8Value type(env->isolate(), args[0]);
  Local<Value> entry = args[1];
  PerformanceEntryType entry_type = ToPerformanceEntryTypeEnum(*type);
  AliasedUint32Array& observers = env->performance_state()->observers;
  if (entry_type != NODE_PERFORMANCE_ENTRY_TYPE_INVALID &&
      observers[entry_type]) {
    USE(env->performance_entry_callback()->
      Call(env->context(), Undefined(env->isolate()), 1, &entry));
  }
}",1,1,node_perf.cc,node.performance.Notify,,false,237,248,Notify,,,20,void node.performance.Notify (FunctionCallbackInfo<Value>)
215722,METHOD,node_perf.cc:<global>,TYPE_DECL,"void LoopIdleTime(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  uint64_t idle_time = uv_metrics_idle_time(env->event_loop());
  args.GetReturnValue().Set(1.0 * idle_time / 1e6);
}",1,1,node_perf.cc,node.performance.LoopIdleTime,,false,251,255,LoopIdleTime,,,21,void node.performance.LoopIdleTime (FunctionCallbackInfo<Value>)
215755,METHOD,node_perf.cc:<global>,TYPE_DECL,"void CreateELDHistogram(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  int64_t interval = args[0].As<Integer>()->Value();
  CHECK_GT(interval, 0);
  BaseObjectPtr<IntervalHistogram> histogram =
      IntervalHistogram::Create(env, interval, [](Histogram& histogram) {
        uint64_t delta = histogram.RecordDelta();
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                        ""delay"", delta);
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""min"", histogram.Min());
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""max"", histogram.Max());
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""mean"", histogram.Mean());
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""stddev"", histogram.Stddev());
      }, Histogram::Options { 1000 });
  args.GetReturnValue().Set(...",1,1,node_perf.cc,node.performance.CreateELDHistogram,,false,257,276,CreateELDHistogram,,,22,void node.performance.CreateELDHistogram (FunctionCallbackInfo<Value>)
215810,METHOD,node_perf.cc:<global>,TYPE_DECL,"void GetTimeOrigin(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  args.GetReturnValue().Set(
      Number::New(args.GetIsolate(), env->time_origin() / NANOS_PER_MILLIS));
}",1,58,node_perf.cc,node.performance.GetTimeOrigin,,false,278,282,GetTimeOrigin,,,23,void node.performance.GetTimeOrigin (FunctionCallbackInfo<Value>)
215846,METHOD,node_perf.cc:<global>,TYPE_DECL,"void GetTimeOriginTimeStamp(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  args.GetReturnValue().Set(Number::New(
      args.GetIsolate(), env->time_origin_timestamp() / MICROS_PER_MILLIS));
}",1,56,node_perf.cc,node.performance.GetTimeOriginTimeStamp,,false,284,288,GetTimeOriginTimeStamp,,,24,void node.performance.GetTimeOriginTimeStamp (FunctionCallbackInfo<Value>)
215882,METHOD,node_perf.cc:<global>,TYPE_DECL,"void MarkBootstrapComplete(const FunctionCallbackInfo<Value>& args) {
  Realm* realm = Realm::GetCurrent(args);
  CHECK_EQ(realm->kind(), Realm::Kind::kPrincipal);
  realm->env()->performance_state()->Mark(
      performance::NODE_PERFORMANCE_MILESTONE_BOOTSTRAP_COMPLETE);
}",1,1,node_perf.cc,node.performance.MarkBootstrapComplete,,false,290,295,MarkBootstrapComplete,,,25,void node.performance.MarkBootstrapComplete (FunctionCallbackInfo<Value>)
215918,METHOD,node_perf.cc:<global>,TYPE_DECL,"static void CreatePerIsolateProperties(IsolateData* isolate_data,
                                       Local<ObjectTemplate> target) {
  Isolate* isolate = isolate_data->isolate();

  HistogramBase::Initialize(isolate_data, target);

  SetMethod(isolate, target, ""markMilestone"", MarkMilestone);
  SetMethod(isolate, target, ""setupObservers"", SetupPerformanceObservers);
  SetMethod(isolate,
            target,
            ""installGarbageCollectionTracking"",
            InstallGarbageCollectionTracking);
  SetMethod(isolate,
            target,
            ""removeGarbageCollectionTracking"",
            RemoveGarbageCollectionTracking);
  SetMethod(isolate, target, ""notify"", Notify);
  SetMethod(isolate, target, ""loopIdleTime"", LoopIdleTime);
  SetMethod(isolate, target, ""getTimeOrigin"", GetTimeOrigin);
  SetMethod(isolate, target, ""getTimeOriginTimestamp"", GetTimeOriginTimeStamp);
  SetMethod(isolate, target, ""createELDHistogram"", CreateELDHistogram);
  SetMethod(isolate, target, ""ma...",1,1,node_perf.cc,node.performance.CreatePerIsolateProperties,,false,297,319,CreatePerIsolateProperties,,,26,"void node.performance.CreatePerIsolateProperties (IsolateData*,Local<ObjectTemplate>)"
215987,METHOD,node_perf.cc:<global>,TYPE_DECL,"void CreatePerContextProperties(Local<Object> target,
                                Local<Value> unused,
                                Local<Context> context,
                                void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();
  PerformanceState* state = env->performance_state();

  target->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""observerCounts""),
              state->observers.GetJSArray()).Check();
  target->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""milestones""),
              state->milestones.GetJSArray()).Check();

  Local<Object> constants = Object::New(isolate);

  NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_MAJOR);
  NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_MINOR);
  NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_INCREMENTAL);
  NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_WEAKCB);

  NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANC...",1,2,node_perf.cc,node.performance.CreatePerContextProperties,,false,321,373,CreatePerContextProperties,,,27,"void node.performance.CreatePerContextProperties (Local<Object>,Local<Value>,Local<Context>,void*)"
217177,METHOD,node_perf.cc:<global>,TYPE_DECL,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(MarkMilestone);
  registry->Register(SetupPerformanceObservers);
  registry->Register(InstallGarbageCollectionTracking);
  registry->Register(RemoveGarbageCollectionTracking);
  registry->Register(Notify);
  registry->Register(LoopIdleTime);
  registry->Register(GetTimeOrigin);
  registry->Register(GetTimeOriginTimeStamp);
  registry->Register(CreateELDHistogram);
  registry->Register(MarkBootstrapComplete);
  HistogramBase::RegisterExternalReferences(registry);
  IntervalHistogram::RegisterExternalReferences(registry);
}",1,1,node_perf.cc,node.performance.RegisterExternalReferences,,false,375,388,RegisterExternalReferences,,,28,void node.performance.RegisterExternalReferences (ExternalReferenceRegistry*)
217262,METHOD,node_perf.hpp:<global>,TYPE_DECL,<global>,1,27,node_perf.hpp,node_perf.hpp:<global>,,false,1,166,<global>,,,1,
217283,METHOD,node_perf_common.hpp:<global>,TYPE_DECL,<global>,1,34,node_perf_common.hpp,node_perf_common.hpp:<global>,,false,1,94,<global>,,,1,
217286,METHOD,node.DelayedTaskScheduler,TYPE_DECL,"[](void* data) {
      static_cast<DelayedTaskScheduler*>(data)->Run();
    }",25,5,node_platform.cc,node.DelayedTaskScheduler.Start.<lambda>0,,false,63,65,<lambda>0,,,1,ANY node.DelayedTaskScheduler.Start.<lambda>0 (void*)
217299,METHOD,node.DelayedTaskScheduler.StopTask,TYPE_DECL,[](uv_handle_t* handle) {},16,41,node_platform.cc,node.DelayedTaskScheduler.StopTask.Run.<lambda>1,,false,117,117,<lambda>1,,,1,ANY node.DelayedTaskScheduler.StopTask.Run.<lambda>1 (uv_handle_t*)
217306,METHOD,node.DelayedTaskScheduler,TYPE_DECL,"[](uv_handle_t* handle) {
      delete reinterpret_cast<uv_timer_t*>(handle);
    }",53,5,node_platform.cc,node.DelayedTaskScheduler.TakeTimerTask.<lambda>2,,false,157,159,<lambda>2,,,1,ANY node.DelayedTaskScheduler.TakeTimerTask.<lambda>2 (uv_handle_t*)
217316,METHOD,node_platform.cc:<global>,TYPE_DECL,"[](uv_handle_t* handle) {
    std::unique_ptr<uv_async_t> flush_tasks {
        reinterpret_cast<uv_async_t*>(handle) };
    PerIsolatePlatformData* platform_data =
        static_cast<PerIsolatePlatformData*>(flush_tasks->data);
    platform_data->DecreaseHandleCount();
    platform_data->self_reference_.reset();
  }",12,3,node_platform.cc,node.PerIsolatePlatformData.Shutdown.<lambda>3,,false,314,321,<lambda>3,,,1,ANY node.PerIsolatePlatformData.Shutdown.<lambda>3 (uv_handle_t*)
217352,METHOD,node_platform.cc:<global>,TYPE_DECL,"[task](const DelayedTaskPointer& delayed) -> bool {
          return delayed.get() == task;
      }",26,7,node_platform.cc,node.PerIsolatePlatformData.DeleteFromScheduledTasks.<lambda>4,,false,437,439,<lambda>4,,,1,bool node.PerIsolatePlatformData.DeleteFromScheduledTasks.<lambda>4 (DelayedTaskPointer)
217366,METHOD,node_platform.cc:<global>,TYPE_DECL,"[](uv_handle_t* handle) {
        std::unique_ptr<DelayedTask> task {
            static_cast<DelayedTask*>(handle->data) };
        task->platform_data->DecreaseHandleCount();
      }",16,7,node_platform.cc,node.PerIsolatePlatformData.FlushForegroundTasksInternal..<lambda>6,,false,479,483,<lambda>6,,,1,ANY node.PerIsolatePlatformData.FlushForegroundTasksInternal..<lambda>6 (uv_handle_t*)
217391,METHOD,node_platform.cc:<global>,TYPE_DECL,"[](DelayedTask* delayed) {
      uv_close(reinterpret_cast<uv_handle_t*>(&delayed->timer),
               [](uv_handle_t* handle) {
        std::unique_ptr<DelayedTask> task {
            static_cast<DelayedTask*>(handle->data) };
        task->platform_data->DecreaseHandleCount();
      });
    }",43,5,node_platform.cc,node.PerIsolatePlatformData.FlushForegroundTasksInternal.<lambda>5,,false,477,484,<lambda>5,,,1,ANY node.PerIsolatePlatformData.FlushForegroundTasksInternal.<lambda>5 (DelayedTask*)
217405,METHOD,node_platform.cc:<global>,TYPE_DECL,"[]() {
    fprintf(stderr, ""\n"");
    DumpBacktrace(stderr);
    fflush(stderr);
  }",10,3,node_platform.cc,node.NodePlatform.GetStackTracePrinter.<lambda>7,,false,561,565,<lambda>7,,,1,ANY node.NodePlatform.GetStackTracePrinter.<lambda>7 ()
217431,METHOD,node_platform.cc:<global>,TYPE_DECL,<global>,1,31,node_platform.hpp,node_platform.cc:<global>,,false,1,641,<global>,,,1,
217441,METHOD,node_platform.cc:<global>,TYPE_DECL,"static void PlatformWorkerThread(void* data) {
  std::unique_ptr<PlatformWorkerData>
      worker_data(static_cast<PlatformWorkerData*>(data));

  TaskQueue<Task>* pending_worker_tasks = worker_data->task_queue;
  TRACE_EVENT_METADATA1(""__metadata"", ""thread_name"", ""name"",
                        ""PlatformWorkerThread"");

  // Notify the main thread that the platform worker is ready.
  {
    Mutex::ScopedLock lock(*worker_data->platform_workers_mutex);
    (*worker_data->pending_platform_workers)--;
    worker_data->platform_workers_ready->Signal(lock);
  }

  while (std::unique_ptr<Task> task = pending_worker_tasks->BlockingPop()) {
    task->Run();
    pending_worker_tasks->NotifyOfCompletion();
  }
}",1,1,node_platform.cc,node.anonymous_namespace_2.PlatformWorkerThread,,false,27,46,PlatformWorkerThread,,,2,void node.anonymous_namespace_2.PlatformWorkerThread (void*)
217507,METHOD,node_platform.cc:<global>,TYPE_DECL,"static int GetActualThreadPoolSize(int thread_pool_size) {
  if (thread_pool_size < 1) {
    thread_pool_size = uv_available_parallelism() - 1;
  }
  return std::max(thread_pool_size, 1);
}",1,1,node_platform.cc,node.anonymous_namespace_3.GetActualThreadPoolSize,,false,48,53,GetActualThreadPoolSize,,,3,int node.anonymous_namespace_3.GetActualThreadPoolSize (int)
217529,METHOD,node.DelayedTaskScheduler,TYPE_DECL,"explicit DelayedTaskScheduler(TaskQueue<Task>* tasks)
    : pending_worker_tasks_(tasks) {}",3,37,node_platform.cc,node.DelayedTaskScheduler.DelayedTaskScheduler,,false,59,60,DelayedTaskScheduler,,,1,ANY node.DelayedTaskScheduler.DelayedTaskScheduler (TaskQueue<Task>*)
217534,METHOD,node.DelayedTaskScheduler,TYPE_DECL,"std::unique_ptr<uv_thread_t> Start() {
    auto start_thread = [](void* data) {
      static_cast<DelayedTaskScheduler*>(data)->Run();
    };
    std::unique_ptr<uv_thread_t> t { new uv_thread_t() };
    uv_sem_init(&ready_, 0);
    CHECK_EQ(0, uv_thread_create(t.get(), start_thread, this));
    uv_sem_wait(&ready_);
    uv_sem_destroy(&ready_);
    return t;
  }",3,3,node_platform.cc,node.DelayedTaskScheduler.Start,,false,62,72,Start,,,2,unique_ptr<uv_thread_t> node.DelayedTaskScheduler.Start ()
217573,METHOD,node.DelayedTaskScheduler,TYPE_DECL,"void PostDelayedTask(std::unique_ptr<Task> task, double delay_in_seconds) {
    tasks_.Push(std::make_unique<ScheduleTask>(this, std::move(task),
                                               delay_in_seconds));
    uv_async_send(&flush_tasks_);
  }",3,3,node_platform.cc,node.DelayedTaskScheduler.PostDelayedTask,,false,74,78,PostDelayedTask,,,3,"void node.DelayedTaskScheduler.PostDelayedTask (ANY,double)"
217601,METHOD,node.DelayedTaskScheduler,TYPE_DECL,"void Stop() {
    tasks_.Push(std::make_unique<StopTask>(this));
    uv_async_send(&flush_tasks_);
  }",3,3,node_platform.cc,node.DelayedTaskScheduler.Stop,,false,80,83,Stop,,,4,void node.DelayedTaskScheduler.Stop ()
217619,METHOD,node.DelayedTaskScheduler,TYPE_DECL,"void Run() {
    TRACE_EVENT_METADATA1(""__metadata"", ""thread_name"", ""name"",
                          ""WorkerThreadsTaskRunner::DelayedTaskScheduler"");
    loop_.data = this;
    CHECK_EQ(0, uv_loop_init(&loop_));
    flush_tasks_.data = this;
    CHECK_EQ(0, uv_async_init(&loop_, &flush_tasks_, FlushTasks));
    uv_sem_post(&ready_);

    uv_run(&loop_, UV_RUN_DEFAULT);
    CheckedUvLoopClose(&loop_);
  }",3,3,node_platform.cc,node.DelayedTaskScheduler.Run,,false,86,97,Run,,,5,void node.DelayedTaskScheduler.Run ()
217661,METHOD,node.DelayedTaskScheduler,TYPE_DECL,"static void FlushTasks(uv_async_t* flush_tasks) {
    DelayedTaskScheduler* scheduler =
        ContainerOf(&DelayedTaskScheduler::loop_, flush_tasks->loop);
    while (std::unique_ptr<Task> task = scheduler->tasks_.Pop())
      task->Run();
  }",3,3,node_platform.cc,node.DelayedTaskScheduler.FlushTasks,,false,99,104,FlushTasks,,,6,void node.DelayedTaskScheduler.FlushTasks (uv_async_t*)
217696,METHOD,node.DelayedTaskScheduler.StopTask,TYPE_DECL,explicit StopTask(DelayedTaskScheduler* scheduler): scheduler_(scheduler) {},5,80,node_platform.cc,node.DelayedTaskScheduler.StopTask.StopTask,,false,108,108,StopTask,,,1,ANY node.DelayedTaskScheduler.StopTask.StopTask (DelayedTaskScheduler*)
217701,METHOD,node.DelayedTaskScheduler.StopTask,TYPE_DECL,"void Run() override {
      std::vector<uv_timer_t*> timers;
      for (uv_timer_t* timer : scheduler_->timers_)
        timers.push_back(timer);
      for (uv_timer_t* timer : timers)
        scheduler_->TakeTimerTask(timer);
      uv_close(reinterpret_cast<uv_handle_t*>(&scheduler_->flush_tasks_),
               [](uv_handle_t* handle) {});
    }",5,5,node_platform.cc,node.DelayedTaskScheduler.StopTask.Run,,false,110,118,Run,,,2,void node.DelayedTaskScheduler.StopTask.Run ()
217734,METHOD,node.DelayedTaskScheduler.ScheduleTask,TYPE_DECL,"ScheduleTask(DelayedTaskScheduler* scheduler,
                 std::unique_ptr<Task> task,
                 double delay_in_seconds)
      : scheduler_(scheduler),
        task_(std::move(task)),
        delay_in_seconds_(delay_in_seconds) {}",5,46,node_platform.cc,node.DelayedTaskScheduler.ScheduleTask.ScheduleTask,,false,126,131,ScheduleTask,,,1,"ANY node.DelayedTaskScheduler.ScheduleTask.ScheduleTask (DelayedTaskScheduler*,ANY,double)"
217741,METHOD,node.DelayedTaskScheduler.ScheduleTask,TYPE_DECL,"void Run() override {
      uint64_t delay_millis = llround(delay_in_seconds_ * 1000);
      std::unique_ptr<uv_timer_t> timer(new uv_timer_t());
      CHECK_EQ(0, uv_timer_init(&scheduler_->loop_, timer.get()));
      timer->data = task_.release();
      CHECK_EQ(0, uv_timer_start(timer.get(), RunTask, delay_millis, 0));
      scheduler_->timers_.insert(timer.release());
    }",5,5,node_platform.cc,node.DelayedTaskScheduler.ScheduleTask.Run,,false,133,140,Run,,,2,void node.DelayedTaskScheduler.ScheduleTask.Run ()
217803,METHOD,node.DelayedTaskScheduler,TYPE_DECL,"static void RunTask(uv_timer_t* timer) {
    DelayedTaskScheduler* scheduler =
        ContainerOf(&DelayedTaskScheduler::loop_, timer->loop);
    scheduler->pending_worker_tasks_->Push(scheduler->TakeTimerTask(timer));
  }",3,3,node_platform.cc,node.DelayedTaskScheduler.RunTask,,false,148,152,RunTask,,,9,void node.DelayedTaskScheduler.RunTask (uv_timer_t*)
217830,METHOD,node.DelayedTaskScheduler,TYPE_DECL,"std::unique_ptr<Task> TakeTimerTask(uv_timer_t* timer) {
    std::unique_ptr<Task> task(static_cast<Task*>(timer->data));
    uv_timer_stop(timer);
    uv_close(reinterpret_cast<uv_handle_t*>(timer), [](uv_handle_t* handle) {
      delete reinterpret_cast<uv_timer_t*>(handle);
    });
    timers_.erase(timer);
    return task;
  }",3,3,node_platform.cc,node.DelayedTaskScheduler.TakeTimerTask,,false,154,162,TakeTimerTask,,,10,unique_ptr<Task> node.DelayedTaskScheduler.TakeTimerTask (uv_timer_t*)
217867,METHOD,node_platform.cc:<global>,TYPE_DECL,"WorkerThreadsTaskRunner::WorkerThreadsTaskRunner(int thread_pool_size) {
  Mutex platform_workers_mutex;
  ConditionVariable platform_workers_ready;

  Mutex::ScopedLock lock(platform_workers_mutex);
  int pending_platform_workers = thread_pool_size;

  delayed_task_scheduler_ = std::make_unique<DelayedTaskScheduler>(
      &pending_worker_tasks_);
  threads_.push_back(delayed_task_scheduler_->Start());

  for (int i = 0; i < thread_pool_size; i++) {
    PlatformWorkerData* worker_data = new PlatformWorkerData{
      &pending_worker_tasks_, &platform_workers_mutex,
      &platform_workers_ready, &pending_platform_workers, i
    };
    std::unique_ptr<uv_thread_t> t { new uv_thread_t() };
    if (uv_thread_create(t.get(), PlatformWorkerThread,
                         worker_data) != 0) {
      break;
    }
    threads_.push_back(std::move(t));
  }

  // Wait for platform workers to initialize before continuing with the
  // bootstrap.
  while (pending_platform_workers > 0) {
    pla...",1,1,node_platform.cc,node.WorkerThreadsTaskRunner.WorkerThreadsTaskRunner,,false,173,202,WorkerThreadsTaskRunner,,,3,ANY node.WorkerThreadsTaskRunner.WorkerThreadsTaskRunner (int)
217957,METHOD,node_platform.cc:<global>,TYPE_DECL,"void WorkerThreadsTaskRunner::PostTask(std::unique_ptr<Task> task) {
  pending_worker_tasks_.Push(std::move(task));
}",1,1,node_platform.cc,node.WorkerThreadsTaskRunner.PostTask,,false,204,206,PostTask,,,4,void node.WorkerThreadsTaskRunner.PostTask (ANY)
217971,METHOD,node_platform.cc:<global>,TYPE_DECL,"void WorkerThreadsTaskRunner::PostDelayedTask(std::unique_ptr<Task> task,
                                              double delay_in_seconds) {
  delayed_task_scheduler_->PostDelayedTask(std::move(task), delay_in_seconds);
}",1,1,node_platform.cc,node.WorkerThreadsTaskRunner.PostDelayedTask,,false,208,211,PostDelayedTask,,,5,"void node.WorkerThreadsTaskRunner.PostDelayedTask (ANY,double)"
217987,METHOD,node_platform.cc:<global>,TYPE_DECL,"void WorkerThreadsTaskRunner::BlockingDrain() {
  pending_worker_tasks_.BlockingDrain();
}",1,1,node_platform.cc,node.WorkerThreadsTaskRunner.BlockingDrain,,false,213,215,BlockingDrain,,,6,void node.WorkerThreadsTaskRunner.BlockingDrain ()
217995,METHOD,node_platform.cc:<global>,TYPE_DECL,"void WorkerThreadsTaskRunner::Shutdown() {
  pending_worker_tasks_.Stop();
  delayed_task_scheduler_->Stop();
  for (size_t i = 0; i < threads_.size(); i++) {
    CHECK_EQ(0, uv_thread_join(threads_[i].get()));
  }
}",1,1,node_platform.cc,node.WorkerThreadsTaskRunner.Shutdown,,false,217,223,Shutdown,,,7,void node.WorkerThreadsTaskRunner.Shutdown ()
218031,METHOD,node_platform.cc:<global>,TYPE_DECL,"int WorkerThreadsTaskRunner::NumberOfWorkerThreads() const {
  return threads_.size();
}",1,1,node_platform.cc,node.WorkerThreadsTaskRunner.NumberOfWorkerThreads,,false,225,227,NumberOfWorkerThreads,,,8,int node.WorkerThreadsTaskRunner.NumberOfWorkerThreads ()
218040,METHOD,node_platform.cc:<global>,TYPE_DECL,"PerIsolatePlatformData::PerIsolatePlatformData(
    Isolate* isolate, uv_loop_t* loop)
  : isolate_(isolate), loop_(loop) {
  flush_tasks_ = new uv_async_t();
  CHECK_EQ(0, uv_async_init(loop, flush_tasks_, FlushTasks));
  flush_tasks_->data = static_cast<void*>(this);
  uv_unref(reinterpret_cast<uv_handle_t*>(flush_tasks_));
}",1,1,node_platform.cc,node.PerIsolatePlatformData.PerIsolatePlatformData,,false,229,236,PerIsolatePlatformData,,,9,"ANY node.PerIsolatePlatformData.PerIsolatePlatformData (Isolate*,uv_loop_t*)"
218067,METHOD,node_platform.cc:<global>,TYPE_DECL,"std::shared_ptr<v8::TaskRunner>
PerIsolatePlatformData::GetForegroundTaskRunner() {
  return shared_from_this();
}",1,1,node_platform.cc,node.PerIsolatePlatformData.GetForegroundTaskRunner,,false,238,241,GetForegroundTaskRunner,,,10,shared_ptr<v8::TaskRunner> node.PerIsolatePlatformData.GetForegroundTaskRunner ()
218073,METHOD,node_platform.cc:<global>,TYPE_DECL,"void PerIsolatePlatformData::FlushTasks(uv_async_t* handle) {
  auto platform_data = static_cast<PerIsolatePlatformData*>(handle->data);
  platform_data->FlushForegroundTasksInternal();
}",1,1,node_platform.cc,node.PerIsolatePlatformData.FlushTasks,,false,243,246,FlushTasks,,,11,void node.PerIsolatePlatformData.FlushTasks (uv_async_t*)
218090,METHOD,node_platform.cc:<global>,TYPE_DECL,"void PerIsolatePlatformData::PostIdleTask(std::unique_ptr<v8::IdleTask> task) {
  UNREACHABLE();
}",1,1,node_platform.cc,node.PerIsolatePlatformData.PostIdleTask,,false,248,250,PostIdleTask,,,12,void node.PerIsolatePlatformData.PostIdleTask (ANY)
218096,METHOD,node_platform.cc:<global>,TYPE_DECL,"void PerIsolatePlatformData::PostTask(std::unique_ptr<Task> task) {
  if (flush_tasks_ == nullptr) {
    // V8 may post tasks during Isolate disposal. In that case, the only
    // sensible path forward is to discard the task.
    return;
  }
  foreground_tasks_.Push(std::move(task));
  uv_async_send(flush_tasks_);
}",1,1,node_platform.cc,node.PerIsolatePlatformData.PostTask,,false,252,260,PostTask,,,13,void node.PerIsolatePlatformData.PostTask (ANY)
218117,METHOD,node_platform.cc:<global>,TYPE_DECL,"void PerIsolatePlatformData::PostDelayedTask(
    std::unique_ptr<Task> task, double delay_in_seconds) {
  if (flush_tasks_ == nullptr) {
    // V8 may post tasks during Isolate disposal. In that case, the only
    // sensible path forward is to discard the task.
    return;
  }
  std::unique_ptr<DelayedTask> delayed(new DelayedTask());
  delayed->task = std::move(task);
  delayed->platform_data = shared_from_this();
  delayed->timeout = delay_in_seconds;
  foreground_delayed_tasks_.Push(std::move(delayed));
  uv_async_send(flush_tasks_);
}",1,1,node_platform.cc,node.PerIsolatePlatformData.PostDelayedTask,,false,262,275,PostDelayedTask,,,14,"void node.PerIsolatePlatformData.PostDelayedTask (ANY,double)"
218167,METHOD,node_platform.cc:<global>,TYPE_DECL,"void PerIsolatePlatformData::PostNonNestableTask(std::unique_ptr<Task> task) {
  PostTask(std::move(task));
}",1,1,node_platform.cc,node.PerIsolatePlatformData.PostNonNestableTask,,false,277,279,PostNonNestableTask,,,15,void node.PerIsolatePlatformData.PostNonNestableTask (ANY)
218178,METHOD,node_platform.cc:<global>,TYPE_DECL,"void PerIsolatePlatformData::PostNonNestableDelayedTask(
    std::unique_ptr<Task> task,
    double delay_in_seconds) {
  PostDelayedTask(std::move(task), delay_in_seconds);
}",1,1,node_platform.cc,node.PerIsolatePlatformData.PostNonNestableDelayedTask,,false,281,285,PostNonNestableDelayedTask,,,16,"void node.PerIsolatePlatformData.PostNonNestableDelayedTask (ANY,double)"
218191,METHOD,node_platform.cc:<global>,TYPE_DECL,"PerIsolatePlatformData::~PerIsolatePlatformData() {
  CHECK(!flush_tasks_);
}",1,1,node_platform.cc,node.PerIsolatePlatformData.~PerIsolatePlatformData,,false,287,289,~PerIsolatePlatformData,,,17,ANY node.PerIsolatePlatformData.~PerIsolatePlatformData ()
218198,METHOD,node_platform.cc:<global>,TYPE_DECL,"void PerIsolatePlatformData::AddShutdownCallback(void (*callback)(void*),
                                                 void* data) {
  shutdown_callbacks_.emplace_back(ShutdownCallback { callback, data });
}",1,1,node_platform.cc,node.PerIsolatePlatformData.AddShutdownCallback,,false,291,294,AddShutdownCallback,,,18,"void node.PerIsolatePlatformData.AddShutdownCallback (void,void*)"
218212,METHOD,node_platform.cc:<global>,TYPE_DECL,"void PerIsolatePlatformData::Shutdown() {
  if (flush_tasks_ == nullptr)
    return;

  // While there should be no V8 tasks in the queues at this point, it is
  // possible that Node.js-internal tasks from e.g. the inspector are still
  // lying around. We clear these queues and ignore the return value,
  // effectively deleting the tasks instead of running them.
  foreground_delayed_tasks_.PopAll();
  foreground_tasks_.PopAll();
  scheduled_delayed_tasks_.clear();

  // Both destroying the scheduled_delayed_tasks_ lists and closing
  // flush_tasks_ handle add tasks to the event loop. We keep a count of all
  // non-closed handles, and when that reaches zero, we inform any shutdown
  // callbacks that the platform is done as far as this Isolate is concerned.
  self_reference_ = shared_from_this();
  uv_close(reinterpret_cast<uv_handle_t*>(flush_tasks_),
           [](uv_handle_t* handle) {
    std::unique_ptr<uv_async_t> flush_tasks {
        reinterpret_cast<uv_async_t*>(handle) ...",1,1,node_platform.cc,node.PerIsolatePlatformData.Shutdown,,false,296,323,Shutdown,,,19,void node.PerIsolatePlatformData.Shutdown ()
218245,METHOD,node_platform.cc:<global>,TYPE_DECL,"void PerIsolatePlatformData::DecreaseHandleCount() {
  CHECK_GE(uv_handle_count_, 1);
  if (--uv_handle_count_ == 0) {
    for (const auto& callback : shutdown_callbacks_)
      callback.cb(callback.data);
  }
}",1,1,node_platform.cc,node.PerIsolatePlatformData.DecreaseHandleCount,,false,325,331,DecreaseHandleCount,,,20,void node.PerIsolatePlatformData.DecreaseHandleCount ()
218268,METHOD,node_platform.cc:<global>,TYPE_DECL,"NodePlatform::NodePlatform(int thread_pool_size,
                           v8::TracingController* tracing_controller,
                           v8::PageAllocator* page_allocator) {
  if (tracing_controller != nullptr) {
    tracing_controller_ = tracing_controller;
  } else {
    tracing_controller_ = new v8::TracingController();
  }

  // V8 will default to its built in allocator if none is provided.
  page_allocator_ = page_allocator;

  // TODO(addaleax): It's a bit icky that we use global state here, but we can't
  // really do anything about it unless V8 starts exposing a way to access the
  // current v8::Platform instance.
  SetTracingController(tracing_controller_);
  DCHECK_EQ(GetTracingController(), tracing_controller_);

  thread_pool_size = GetActualThreadPoolSize(thread_pool_size);
  worker_thread_task_runner_ =
      std::make_shared<WorkerThreadsTaskRunner>(thread_pool_size);
}",1,1,node_platform.cc,node.NodePlatform.NodePlatform,,false,333,354,NodePlatform,,,21,"ANY node.NodePlatform.NodePlatform (int,ANY*,ANY*)"
218309,METHOD,node_platform.cc:<global>,TYPE_DECL,"NodePlatform::~NodePlatform() {
  Shutdown();
}",1,1,node_platform.cc,node.NodePlatform.~NodePlatform,,false,356,358,~NodePlatform,,,22,ANY node.NodePlatform.~NodePlatform ()
218314,METHOD,node_platform.cc:<global>,TYPE_DECL,"void NodePlatform::RegisterIsolate(Isolate* isolate, uv_loop_t* loop) {
  Mutex::ScopedLock lock(per_isolate_mutex_);
  auto delegate = std::make_shared<PerIsolatePlatformData>(isolate, loop);
  IsolatePlatformDelegate* ptr = delegate.get();
  auto insertion = per_isolate_.emplace(
    isolate,
    std::make_pair(ptr, std::move(delegate)));
  CHECK(insertion.second);
}",1,1,node_platform.cc,node.NodePlatform.RegisterIsolate,,false,360,368,RegisterIsolate,,,23,"void node.NodePlatform.RegisterIsolate (Isolate*,uv_loop_t*)"
218365,METHOD,node_platform.cc:<global>,TYPE_DECL,"void NodePlatform::RegisterIsolate(Isolate* isolate,
                                   IsolatePlatformDelegate* delegate) {
  Mutex::ScopedLock lock(per_isolate_mutex_);
  auto insertion = per_isolate_.emplace(
    isolate,
    std::make_pair(delegate, std::shared_ptr<PerIsolatePlatformData>{}));
  CHECK(insertion.second);
}",1,1,node_platform.cc,node.NodePlatform.RegisterIsolate,,false,370,377,RegisterIsolate,,,24,"void node.NodePlatform.RegisterIsolate (Isolate*,IsolatePlatformDelegate*)"
218393,METHOD,node_platform.cc:<global>,TYPE_DECL,"void NodePlatform::UnregisterIsolate(Isolate* isolate) {
  Mutex::ScopedLock lock(per_isolate_mutex_);
  auto existing_it = per_isolate_.find(isolate);
  CHECK_NE(existing_it, per_isolate_.end());
  auto& existing = existing_it->second;
  if (existing.second) {
    existing.second->Shutdown();
  }
  per_isolate_.erase(existing_it);
}",1,1,node_platform.cc,node.NodePlatform.UnregisterIsolate,,false,379,388,UnregisterIsolate,,,25,void node.NodePlatform.UnregisterIsolate (Isolate*)
218437,METHOD,node_platform.cc:<global>,TYPE_DECL,"void NodePlatform::AddIsolateFinishedCallback(Isolate* isolate,
                                              void (*cb)(void*), void* data) {
  Mutex::ScopedLock lock(per_isolate_mutex_);
  auto it = per_isolate_.find(isolate);
  if (it == per_isolate_.end()) {
    cb(data);
    return;
  }
  CHECK(it->second.second);
  it->second.second->AddShutdownCallback(cb, data);
}",1,1,node_platform.cc,node.NodePlatform.AddIsolateFinishedCallback,,false,390,400,AddIsolateFinishedCallback,,,26,"void node.NodePlatform.AddIsolateFinishedCallback (Isolate*,void,void*)"
218482,METHOD,node_platform.cc:<global>,TYPE_DECL,"void NodePlatform::Shutdown() {
  if (has_shut_down_) return;
  has_shut_down_ = true;
  worker_thread_task_runner_->Shutdown();

  {
    Mutex::ScopedLock lock(per_isolate_mutex_);
    per_isolate_.clear();
  }
}",1,1,node_platform.cc,node.NodePlatform.Shutdown,,false,402,411,Shutdown,,,27,void node.NodePlatform.Shutdown ()
218505,METHOD,node_platform.cc:<global>,TYPE_DECL,"int NodePlatform::NumberOfWorkerThreads() {
  return worker_thread_task_runner_->NumberOfWorkerThreads();
}",1,1,node_platform.cc,node.NodePlatform.NumberOfWorkerThreads,,false,413,415,NumberOfWorkerThreads,,,28,int node.NodePlatform.NumberOfWorkerThreads ()
218514,METHOD,node_platform.cc:<global>,TYPE_DECL,"void PerIsolatePlatformData::RunForegroundTask(std::unique_ptr<Task> task) {
  if (isolate_->IsExecutionTerminating()) return;
  DebugSealHandleScope scope(isolate_);
  Environment* env = Environment::GetCurrent(isolate_);
  if (env != nullptr) {
    v8::HandleScope scope(isolate_);
    InternalCallbackScope cb_scope(env, Object::New(isolate_), { 0, 0 },
                                   InternalCallbackScope::kNoFlags);
    task->Run();
  } else {
    // The task is moved out of InternalCallbackScope if env is not available.
    // This is a required else block, and should not be removed.
    // See comment: https://github.com/nodejs/node/pull/34688#pullrequestreview-463867489
    task->Run();
  }
}",1,1,node_platform.cc,node.PerIsolatePlatformData.RunForegroundTask,,false,417,432,RunForegroundTask,,,29,void node.PerIsolatePlatformData.RunForegroundTask (ANY)
218569,METHOD,node_platform.cc:<global>,TYPE_DECL,"void PerIsolatePlatformData::DeleteFromScheduledTasks(DelayedTask* task) {
  auto it = std::find_if(scheduled_delayed_tasks_.begin(),
                         scheduled_delayed_tasks_.end(),
                         [task](const DelayedTaskPointer& delayed) -> bool {
          return delayed.get() == task;
      });
  CHECK_NE(it, scheduled_delayed_tasks_.end());
  scheduled_delayed_tasks_.erase(it);
}",1,1,node_platform.cc,node.PerIsolatePlatformData.DeleteFromScheduledTasks,,false,434,442,DeleteFromScheduledTasks,,,30,void node.PerIsolatePlatformData.DeleteFromScheduledTasks (DelayedTask*)
218600,METHOD,node_platform.cc:<global>,TYPE_DECL,"void PerIsolatePlatformData::RunForegroundTask(uv_timer_t* handle) {
  DelayedTask* delayed = ContainerOf(&DelayedTask::timer, handle);
  delayed->platform_data->RunForegroundTask(std::move(delayed->task));
  delayed->platform_data->DeleteFromScheduledTasks(delayed);
}",1,1,node_platform.cc,node.PerIsolatePlatformData.RunForegroundTask,,false,444,448,RunForegroundTask,,,31,void node.PerIsolatePlatformData.RunForegroundTask (uv_timer_t*)
218634,METHOD,node_platform.cc:<global>,TYPE_DECL,"void NodePlatform::DrainTasks(Isolate* isolate) {
  std::shared_ptr<PerIsolatePlatformData> per_isolate = ForNodeIsolate(isolate);
  if (!per_isolate) return;

  do {
    // Worker tasks aren't associated with an Isolate.
    worker_thread_task_runner_->BlockingDrain();
  } while (per_isolate->FlushForegroundTasksInternal());
}",1,1,node_platform.cc,node.NodePlatform.DrainTasks,,false,450,458,DrainTasks,,,32,void node.NodePlatform.DrainTasks (Isolate*)
218664,METHOD,node_platform.cc:<global>,TYPE_DECL,"bool PerIsolatePlatformData::FlushForegroundTasksInternal() {
  bool did_work = false;

  while (std::unique_ptr<DelayedTask> delayed =
      foreground_delayed_tasks_.Pop()) {
    did_work = true;
    uint64_t delay_millis = llround(delayed->timeout * 1000);

    delayed->timer.data = static_cast<void*>(delayed.get());
    uv_timer_init(loop_, &delayed->timer);
    // Timers may not guarantee queue ordering of events with the same delay if
    // the delay is non-zero. This should not be a problem in practice.
    uv_timer_start(&delayed->timer, RunForegroundTask, delay_millis, 0);
    uv_unref(reinterpret_cast<uv_handle_t*>(&delayed->timer));
    uv_handle_count_++;

    scheduled_delayed_tasks_.emplace_back(delayed.release(),
                                          [](DelayedTask* delayed) {
      uv_close(reinterpret_cast<uv_handle_t*>(&delayed->timer),
               [](uv_handle_t* handle) {
        std::unique_ptr<DelayedTask> task {
            static_cast<DelayedTask*>(ha...",1,1,node_platform.cc,node.PerIsolatePlatformData.FlushForegroundTasksInternal,,false,460,497,FlushForegroundTasksInternal,,,33,bool node.PerIsolatePlatformData.FlushForegroundTasksInternal ()
218796,METHOD,node_platform.cc:<global>,TYPE_DECL,"void NodePlatform::CallOnWorkerThread(std::unique_ptr<Task> task) {
  worker_thread_task_runner_->PostTask(std::move(task));
}",1,1,node_platform.cc,node.NodePlatform.CallOnWorkerThread,,false,499,501,CallOnWorkerThread,,,34,void node.NodePlatform.CallOnWorkerThread (ANY)
218810,METHOD,node_platform.cc:<global>,TYPE_DECL,"void NodePlatform::CallDelayedOnWorkerThread(std::unique_ptr<Task> task,
                                             double delay_in_seconds) {
  worker_thread_task_runner_->PostDelayedTask(std::move(task),
                                              delay_in_seconds);
}",1,1,node_platform.cc,node.NodePlatform.CallDelayedOnWorkerThread,,false,503,507,CallDelayedOnWorkerThread,,,35,"void node.NodePlatform.CallDelayedOnWorkerThread (ANY,double)"
218826,METHOD,node_platform.cc:<global>,TYPE_DECL,"IsolatePlatformDelegate* NodePlatform::ForIsolate(Isolate* isolate) {
  Mutex::ScopedLock lock(per_isolate_mutex_);
  auto data = per_isolate_[isolate];
  CHECK_NOT_NULL(data.first);
  return data.first;
}",1,1,node_platform.cc,node.NodePlatform.ForIsolate,,false,510,515,ForIsolate,,,36,IsolatePlatformDelegate node.NodePlatform.ForIsolate (Isolate*)
218848,METHOD,node_platform.cc:<global>,TYPE_DECL,"std::shared_ptr<PerIsolatePlatformData>
NodePlatform::ForNodeIsolate(Isolate* isolate) {
  Mutex::ScopedLock lock(per_isolate_mutex_);
  auto data = per_isolate_[isolate];
  CHECK_NOT_NULL(data.first);
  return data.second;
}",1,1,node_platform.cc,node.NodePlatform.ForNodeIsolate,,false,517,523,ForNodeIsolate,,,37,shared_ptr<PerIsolatePlatformData> node.NodePlatform.ForNodeIsolate (Isolate*)
218870,METHOD,node_platform.cc:<global>,TYPE_DECL,"bool NodePlatform::FlushForegroundTasks(Isolate* isolate) {
  std::shared_ptr<PerIsolatePlatformData> per_isolate = ForNodeIsolate(isolate);
  if (!per_isolate) return false;
  return per_isolate->FlushForegroundTasksInternal();
}",1,1,node_platform.cc,node.NodePlatform.FlushForegroundTasks,,false,525,529,FlushForegroundTasks,,,38,bool node.NodePlatform.FlushForegroundTasks (Isolate*)
218896,METHOD,node_platform.cc:<global>,TYPE_DECL,"std::unique_ptr<v8::JobHandle> NodePlatform::CreateJob(
    v8::TaskPriority priority, std::unique_ptr<v8::JobTask> job_task) {
  return v8::platform::NewDefaultJobHandle(
      this, priority, std::move(job_task), NumberOfWorkerThreads());
}",1,1,node_platform.cc,node.NodePlatform.CreateJob,,false,531,535,CreateJob,,,39,"unique_ptr<v8::JobHandle> node.NodePlatform.CreateJob (ANY,ANY)"
218917,METHOD,node_platform.cc:<global>,TYPE_DECL,"bool NodePlatform::IdleTasksEnabled(Isolate* isolate) {
  return ForIsolate(isolate)->IdleTasksEnabled();
}",1,1,node_platform.cc,node.NodePlatform.IdleTasksEnabled,,false,537,539,IdleTasksEnabled,,,40,bool node.NodePlatform.IdleTasksEnabled (Isolate*)
218928,METHOD,node_platform.cc:<global>,TYPE_DECL,"std::shared_ptr<v8::TaskRunner>
NodePlatform::GetForegroundTaskRunner(Isolate* isolate) {
  return ForIsolate(isolate)->GetForegroundTaskRunner();
}",1,1,node_platform.cc,node.NodePlatform.GetForegroundTaskRunner,,false,541,544,GetForegroundTaskRunner,,,41,shared_ptr<v8::TaskRunner> node.NodePlatform.GetForegroundTaskRunner (Isolate*)
218939,METHOD,node_platform.cc:<global>,TYPE_DECL,"double NodePlatform::MonotonicallyIncreasingTime() {
  // Convert nanos to seconds.
  return uv_hrtime() / 1e9;
}",1,1,node_platform.cc,node.NodePlatform.MonotonicallyIncreasingTime,,false,546,549,MonotonicallyIncreasingTime,,,42,double node.NodePlatform.MonotonicallyIncreasingTime ()
218947,METHOD,node_platform.cc:<global>,TYPE_DECL,"double NodePlatform::CurrentClockTimeMillis() {
  return SystemClockTimeMillis();
}",1,1,node_platform.cc,node.NodePlatform.CurrentClockTimeMillis,,false,551,553,CurrentClockTimeMillis,,,43,double node.NodePlatform.CurrentClockTimeMillis ()
218953,METHOD,node_platform.cc:<global>,TYPE_DECL,"v8::TracingController* NodePlatform::GetTracingController() {
  CHECK_NOT_NULL(tracing_controller_);
  return tracing_controller_;
}",1,1,node_platform.cc,node.NodePlatform.GetTracingController,,false,555,558,GetTracingController,,,44,TracingController node.NodePlatform.GetTracingController ()
218960,METHOD,node_platform.cc:<global>,TYPE_DECL,"Platform::StackTracePrinter NodePlatform::GetStackTracePrinter() {
  return []() {
    fprintf(stderr, ""\n"");
    DumpBacktrace(stderr);
    fflush(stderr);
  };
}",1,1,node_platform.cc,node.NodePlatform.GetStackTracePrinter,,false,560,566,GetStackTracePrinter,,,45,StackTracePrinter node.NodePlatform.GetStackTracePrinter ()
218966,METHOD,node_platform.cc:<global>,TYPE_DECL,"v8::PageAllocator* NodePlatform::GetPageAllocator() {
  return page_allocator_;
}",1,1,node_platform.cc,node.NodePlatform.GetPageAllocator,,false,568,570,GetPageAllocator,,,46,PageAllocator node.NodePlatform.GetPageAllocator ()
218972,METHOD,node_platform.cc:<global>,TYPE_DECL,"TaskQueue<T>::TaskQueue()
    : lock_(), tasks_available_(), tasks_drained_(),
      outstanding_tasks_(0), stopped_(false), task_queue_() { }",1,63,node_platform.cc,node.TaskQueue<T>.TaskQueue,,false,573,575,TaskQueue,,,47,ANY node.TaskQueue<T>.TaskQueue<T> ()
218976,METHOD,node_platform.cc:<global>,TYPE_DECL,"void TaskQueue<T>::Push(std::unique_ptr<T> task) {
  Mutex::ScopedLock scoped_lock(lock_);
  outstanding_tasks_++;
  task_queue_.push(std::move(task));
  tasks_available_.Signal(scoped_lock);
}",1,1,node_platform.cc,node.TaskQueue<T>.Push,,false,578,583,Push,,,48,void node.TaskQueue<T>.Push<T> (ANY)
219000,METHOD,node_platform.cc:<global>,TYPE_DECL,"std::unique_ptr<T> TaskQueue<T>::Pop() {
  Mutex::ScopedLock scoped_lock(lock_);
  if (task_queue_.empty()) {
    return std::unique_ptr<T>(nullptr);
  }
  std::unique_ptr<T> result = std::move(task_queue_.front());
  task_queue_.pop();
  return result;
}",1,1,node_platform.cc,node.TaskQueue<T>.Pop,,false,586,594,Pop,,,49,unique_ptr<T> node.TaskQueue<T>.Pop<T> ()
219043,METHOD,node_platform.cc:<global>,TYPE_DECL,"std::unique_ptr<T> TaskQueue<T>::BlockingPop() {
  Mutex::ScopedLock scoped_lock(lock_);
  while (task_queue_.empty() && !stopped_) {
    tasks_available_.Wait(scoped_lock);
  }
  if (stopped_) {
    return std::unique_ptr<T>(nullptr);
  }
  std::unique_ptr<T> result = std::move(task_queue_.front());
  task_queue_.pop();
  return result;
}",1,1,node_platform.cc,node.TaskQueue<T>.BlockingPop,,false,597,608,BlockingPop,,,50,unique_ptr<T> node.TaskQueue<T>.BlockingPop<T> ()
219097,METHOD,node_platform.cc:<global>,TYPE_DECL,"void TaskQueue<T>::NotifyOfCompletion() {
  Mutex::ScopedLock scoped_lock(lock_);
  if (--outstanding_tasks_ == 0) {
    tasks_drained_.Broadcast(scoped_lock);
  }
}",1,1,node_platform.cc,node.TaskQueue<T>.NotifyOfCompletion,,false,611,616,NotifyOfCompletion,,,51,void node.TaskQueue<T>.NotifyOfCompletion<T> ()
219115,METHOD,node_platform.cc:<global>,TYPE_DECL,"void TaskQueue<T>::BlockingDrain() {
  Mutex::ScopedLock scoped_lock(lock_);
  while (outstanding_tasks_ > 0) {
    tasks_drained_.Wait(scoped_lock);
  }
}",1,1,node_platform.cc,node.TaskQueue<T>.BlockingDrain,,false,619,624,BlockingDrain,,,52,void node.TaskQueue<T>.BlockingDrain<T> ()
219132,METHOD,node_platform.cc:<global>,TYPE_DECL,"void TaskQueue<T>::Stop() {
  Mutex::ScopedLock scoped_lock(lock_);
  stopped_ = true;
  tasks_available_.Broadcast(scoped_lock);
}",1,1,node_platform.cc,node.TaskQueue<T>.Stop,,false,627,631,Stop,,,53,void node.TaskQueue<T>.Stop<T> ()
219147,METHOD,node_platform.cc:<global>,TYPE_DECL,"std::queue<std::unique_ptr<T>> TaskQueue<T>::PopAll() {
  Mutex::ScopedLock scoped_lock(lock_);
  std::queue<std::unique_ptr<T>> result;
  result.swap(task_queue_);
  return result;
}",1,1,node_platform.cc,node.TaskQueue<T>.PopAll,,false,634,639,PopAll,,,54,queue<std::unique_ptr<T>> node.TaskQueue<T>.PopAll<T> ()
219191,METHOD,node_platform.hpp:<global>,TYPE_DECL,<global>,1,31,node_platform.hpp,node_platform.hpp:<global>,,false,1,195,<global>,,,1,
219208,METHOD,node_postmortem_metadata.cc:<global>,TYPE_DECL,<global>,1,33,base_object-inl.hpp,node_postmortem_metadata.cc:<global>,,false,1,73,<global>,,,1,
219235,METHOD,node_postmortem_metadata.cc:<global>,TYPE_DECL,"int GenDebugSymbols() {
  nodedbg_const_ContextEmbedderIndex__kEnvironment__int =
      ContextEmbedderIndex::kEnvironment;
  nodedbg_const_BaseObject__kInternalFieldCount__int =
      BaseObject::kInternalFieldCount;

  nodedbg_offset_ExternalString__data__uintptr_t = NODE_OFF_EXTSTR_DATA;
  nodedbg_offset_ReqWrap__req_wrap_queue___ListNode_ReqWrapQueue =
      OffsetOf<ListNode<ReqWrapBase>, ReqWrap<uv_req_t>>(
          &ReqWrap<uv_req_t>::req_wrap_queue_);

  #define V(Class, Member, Type, Accessor)                                    \
    NODEDBG_OFFSET(Class, Member, Type) = OffsetOf(&Accessor);
    NODE_OFFSET_POSTMORTEM_METADATA(V)
  #undef V

  return 1;
}",1,51,node_postmortem_metadata.cc,node.GenDebugSymbols,,false,52,69,GenDebugSymbols,,,1,int node.GenDebugSymbols ()
219373,METHOD,node_process-inl.hpp:<global>,TYPE_DECL,<global>,1,34,node_process-inl.hpp,node_process-inl.hpp:<global>,,false,1,26,<global>,,,1,
219384,METHOD,node_process.hpp:<global>,TYPE_DECL,<global>,1,30,node_process.hpp,node_process.hpp:<global>,,false,1,99,<global>,,,1,
219397,METHOD,node_process_events.cc:<global>,TYPE_DECL,<global>,1,1,node_process_events.cc,node_process_events.cc:<global>,,false,1,106,<global>,,,1,
219400,METHOD,node_process_events.cc:<global>,TYPE_DECL,"MaybeLocal<Value> ProcessEmit(Environment* env,
                              const char* event,
                              Local<Value> message) {
  Isolate* isolate = env->isolate();

  Local<String> event_string;
  if (!String::NewFromOneByte(isolate, reinterpret_cast<const uint8_t*>(event))
      .ToLocal(&event_string)) return MaybeLocal<Value>();

  Local<Object> process = env->process_object();
  Local<Value> argv[] = {event_string, message};
  return MakeCallback(isolate, process, ""emit"", arraysize(argv), argv, {0, 0});
}",1,1,node_process_events.cc,node.ProcessEmit,,false,21,33,ProcessEmit,,,1,"MaybeLocal<Value> node.ProcessEmit (Environment*,char*,Local<Value>)"
219464,METHOD,node_process_events.cc:<global>,TYPE_DECL,"Maybe<bool> ProcessEmitWarningGeneric(Environment* env,
                                      const char* warning,
                                      const char* type,
                                      const char* code) {
  if (!env->can_call_into_js()) return Just(false);

  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Object> process = env->process_object();
  Local<Value> emit_warning;
  if (!process->Get(env->context(), env->emit_warning_string())
           .ToLocal(&emit_warning)) {
    return Nothing<bool>();
  }

  if (!emit_warning->IsFunction()) return Just(false);

  int argc = 0;
  Local<Value> args[3];  // warning, type, code

  // The caller has to be able to handle a failure anyway, so we might as well
  // do proper error checking for string creation.
  if (!String::NewFromUtf8(env->isolate(), warning).ToLocal(&args[argc++]))
    return Nothing<bool>();

  if (type != nullptr) {
    if (!String::NewFromOneB...",1,1,node_process_events.cc,node.ProcessEmitWarningGeneric,,false,35,83,ProcessEmitWarningGeneric,,,2,"Maybe<bool> node.ProcessEmitWarningGeneric (Environment*,char*,char*,char*)"
219656,METHOD,node_process_events.cc:<global>,TYPE_DECL,"Maybe<bool> ProcessEmitExperimentalWarning(Environment* env,
                                          const char* warning) {
  if (experimental_warnings.find(warning) != experimental_warnings.end())
    return Nothing<bool>();

  experimental_warnings.insert(warning);
  std::string message(warning);
  message.append("" is an experimental feature and might change at any time"");
  return ProcessEmitWarningGeneric(env, message.c_str(), ""ExperimentalWarning"");
}",1,1,node_process_events.cc,node.ProcessEmitExperimentalWarning,,false,88,97,ProcessEmitExperimentalWarning,,,4,"Maybe<bool> node.ProcessEmitExperimentalWarning (Environment*,char*)"
219697,METHOD,node_process_events.cc:<global>,TYPE_DECL,"Maybe<bool> ProcessEmitDeprecationWarning(Environment* env,
                                          const char* warning,
                                          const char* deprecation_code) {
  return ProcessEmitWarningGeneric(
      env, warning, ""DeprecationWarning"", deprecation_code);
}",1,1,node_process_events.cc,node.ProcessEmitDeprecationWarning,,false,99,104,ProcessEmitDeprecationWarning,,,5,"Maybe<bool> node.ProcessEmitDeprecationWarning (Environment*,char*,char*)"
219759,METHOD,node_process_methods.cc:<global>,TYPE_DECL,<global>,1,32,async_wrap-inl.hpp,node_process_methods.cc:<global>,,false,1,650,<global>,,,1,
219764,METHOD,node_process_methods.cc:<global>,TYPE_DECL,"static void Abort(const FunctionCallbackInfo<Value>& args) {
  Abort();
}",1,1,node_process_methods.cc,node.Abort,,false,66,68,Abort,,,2,void node.Abort (FunctionCallbackInfo<Value>)
219770,METHOD,node_process_methods.cc:<global>,TYPE_DECL,"static void CauseSegfault(const FunctionCallbackInfo<Value>& args) {
  // This should crash hard all platforms.
  volatile void** d = static_cast<volatile void**>(nullptr);
  *d = nullptr;
}",1,1,node_process_methods.cc,node.CauseSegfault,,false,71,75,CauseSegfault,,,3,void node.CauseSegfault (FunctionCallbackInfo<Value>)
219785,METHOD,node_process_methods.cc:<global>,TYPE_DECL,"static void Chdir(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(env->owns_process_state());

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());
  Utf8Value path(env->isolate(), args[0]);
  int err = uv_chdir(*path);
  if (err) {
    // Also include the original working directory, since that will usually
    // be helpful information when debugging a `chdir()` failure.
    char buf[PATH_MAX_BYTES];
    size_t cwd_len = sizeof(buf);
    uv_cwd(buf, &cwd_len);
    return env->ThrowUVException(err, ""chdir"", nullptr, buf, *path);
  }
}",1,1,node_process_methods.cc,node.Chdir,,false,77,93,Chdir,,,4,void node.Chdir (FunctionCallbackInfo<Value>)
219855,METHOD,node_process_methods.cc:<global>,TYPE_DECL,"inline Local<ArrayBuffer> get_fields_array_buffer(
    const FunctionCallbackInfo<Value>& args,
    size_t index,
    size_t array_length) {
  CHECK(args[index]->IsFloat64Array());
  Local<Float64Array> arr = args[index].As<Float64Array>();
  CHECK_EQ(arr->Length(), array_length);
  return arr->Buffer();
}",1,1,node_process_methods.cc,node.get_fields_array_buffer,,false,95,103,get_fields_array_buffer,,,5,"Local<ArrayBuffer> node.get_fields_array_buffer (FunctionCallbackInfo<Value>,size_t,size_t)"
219892,METHOD,node_process_methods.cc:<global>,TYPE_DECL,"static void CPUUsage(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  uv_rusage_t rusage;

  // Call libuv to get the values we'll return.
  int err = uv_getrusage(&rusage);
  if (err)
    return env->ThrowUVException(err, ""uv_getrusage"");

  // Get the double array pointer from the Float64Array argument.
  Local<ArrayBuffer> ab = get_fields_array_buffer(args, 0, 2);
  double* fields = static_cast<double*>(ab->Data());

  // Set the Float64Array elements to be user / system values in microseconds.
  fields[0] = MICROS_PER_SEC * rusage.ru_utime.tv_sec + rusage.ru_utime.tv_usec;
  fields[1] = MICROS_PER_SEC * rusage.ru_stime.tv_sec + rusage.ru_stime.tv_usec;
}",1,14,node_process_methods.cc,node.CPUUsage,,false,110,126,CPUUsage,,,6,void node.CPUUsage (FunctionCallbackInfo<Value>)
219979,METHOD,node_process_methods.cc:<global>,TYPE_DECL,"static void Cwd(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(env->has_run_bootstrapping_code());
  char buf[PATH_MAX_BYTES];
  size_t cwd_len = sizeof(buf);
  int err = uv_cwd(buf, &cwd_len);
  if (err)
    return env->ThrowUVException(err, ""uv_cwd"");

  Local<String> cwd = String::NewFromUtf8(env->isolate(),
                                          buf,
                                          NewStringType::kNormal,
                                          cwd_len).ToLocalChecked();
  args.GetReturnValue().Set(cwd);
}",1,1,node_process_methods.cc,node.Cwd,,false,128,142,Cwd,,,7,void node.Cwd (FunctionCallbackInfo<Value>)
220050,METHOD,node_process_methods.cc:<global>,TYPE_DECL,"static void Kill(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Local<Context> context = env->context();

  if (args.Length() < 2) {
    THROW_ERR_MISSING_ARGS(env, ""Bad argument."");
  }

  int pid;
  if (!args[0]->Int32Value(context).To(&pid)) return;
  int sig;
  if (!args[1]->Int32Value(context).To(&sig)) return;

  uv_pid_t own_pid = uv_os_getpid();
  if (sig > 0 &&
      (pid == 0 || pid == -1 || pid == own_pid || pid == -own_pid) &&
      !HasSignalJSHandler(sig)) {
    // This is most likely going to terminate this process.
    // It's not an exact method but it might be close enough.
    RunAtExit(env);
  }

  int err = uv_kill(pid, sig);
  args.GetReturnValue().Set(err);
}",1,1,node_process_methods.cc,node.Kill,,false,144,168,Kill,,,8,void node.Kill (FunctionCallbackInfo<Value>)
220165,METHOD,node_process_methods.cc:<global>,TYPE_DECL,"static void Rss(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  size_t rss;
  int err = uv_resident_set_memory(&rss);
  if (err)
    return env->ThrowUVException(err, ""uv_resident_set_memory"");

  args.GetReturnValue().Set(static_cast<double>(rss));
}",1,1,node_process_methods.cc,node.Rss,,false,170,179,Rss,,,9,void node.Rss (FunctionCallbackInfo<Value>)
220205,METHOD,node_process_methods.cc:<global>,TYPE_DECL,"static void MemoryUsage(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  Isolate* isolate = env->isolate();
  // V8 memory usage
  HeapStatistics v8_heap_stats;
  isolate->GetHeapStatistics(&v8_heap_stats);

  NodeArrayBufferAllocator* array_buffer_allocator =
      env->isolate_data()->node_allocator();

  // Get the double array pointer from the Float64Array argument.
  Local<ArrayBuffer> ab = get_fields_array_buffer(args, 0, 5);
  double* fields = static_cast<double*>(ab->Data());

  size_t rss;
  int err = uv_resident_set_memory(&rss);
  if (err)
    return env->ThrowUVException(err, ""uv_resident_set_memory"");

  fields[0] = static_cast<double>(rss);
  fields[1] = static_cast<double>(v8_heap_stats.total_heap_size());
  fields[2] = static_cast<double>(v8_heap_stats.used_heap_size());
  fields[3] = static_cast<double>(v8_heap_stats.external_memory());
  fields[4] =
      array_buffer_allocator == nullptr
          ? 0
          : st...",1,1,node_process_methods.cc,node.MemoryUsage,,false,181,209,MemoryUsage,,,10,void node.MemoryUsage (FunctionCallbackInfo<Value>)
220330,METHOD,node_process_methods.cc:<global>,TYPE_DECL,"static void GetConstrainedMemory(const FunctionCallbackInfo<Value>& args) {
  uint64_t value = uv_get_constrained_memory();
  if (value != 0) {
    args.GetReturnValue().Set(static_cast<double>(value));
  }
}",1,1,node_process_methods.cc,node.GetConstrainedMemory,,false,211,216,GetConstrainedMemory,,,11,void node.GetConstrainedMemory (FunctionCallbackInfo<Value>)
220354,METHOD,node_process_methods.cc:<global>,TYPE_DECL,"void RawDebug(const FunctionCallbackInfo<Value>& args) {
  CHECK(args.Length() == 1 && args[0]->IsString() &&
        ""must be called with a single string"");
  Utf8Value message(args.GetIsolate(), args[0]);
  FPrintF(stderr, ""%s\n"", message);
  fflush(stderr);
}",1,1,node_process_methods.cc,node.RawDebug,,false,218,224,RawDebug,,,12,void node.RawDebug (FunctionCallbackInfo<Value>)
220389,METHOD,node_process_methods.cc:<global>,TYPE_DECL,"static void Umask(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(env->has_run_bootstrapping_code());
  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsUndefined() || args[0]->IsUint32());
  Mutex::ScopedLock scoped_lock(per_process::umask_mutex);

  uint32_t old;
  if (args[0]->IsUndefined()) {
    old = umask(0);
    umask(static_cast<mode_t>(old));
  } else {
    int oct = args[0].As<Uint32>()->Value();
    old = umask(static_cast<mode_t>(oct));
  }

  args.GetReturnValue().Set(old);
}",1,1,node_process_methods.cc,node.Umask,,false,226,243,Umask,,,13,void node.Umask (FunctionCallbackInfo<Value>)
220477,METHOD,node_process_methods.cc:<global>,TYPE_DECL,"static void Uptime(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  uv_update_time(env->event_loop());
  double uptime =
      static_cast<double>(uv_hrtime() - per_process::node_start_time);
  Local<Number> result = Number::New(env->isolate(), uptime / NANOS_PER_SEC);
  args.GetReturnValue().Set(result);
}",1,62,node_process_methods.cc,node.Uptime,,false,245,253,Uptime,,,14,void node.Uptime (FunctionCallbackInfo<Value>)
220532,METHOD,node_process_methods.cc:<global>,TYPE_DECL,"static void GetActiveRequests(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  std::vector<Local<Value>> request_v;
  for (ReqWrapBase* req_wrap : *env->req_wrap_queue()) {
    AsyncWrap* w = req_wrap->GetAsyncWrap();
    if (w->persistent().IsEmpty())
      continue;
    request_v.emplace_back(w->GetOwner());
  }

  args.GetReturnValue().Set(
      Array::New(env->isolate(), request_v.data(), request_v.size()));
}",1,1,node_process_methods.cc,node.GetActiveRequests,,false,255,268,GetActiveRequests,,,15,void node.GetActiveRequests (FunctionCallbackInfo<Value>)
220610,METHOD,node_process_methods.cc:<global>,TYPE_DECL,"void GetActiveHandles(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  std::vector<Local<Value>> handle_v;
  for (auto w : *env->handle_wrap_queue()) {
    if (!HandleWrap::HasRef(w))
      continue;
    handle_v.emplace_back(w->GetOwner());
  }
  args.GetReturnValue().Set(
      Array::New(env->isolate(), handle_v.data(), handle_v.size()));
}",1,1,node_process_methods.cc,node.GetActiveHandles,,false,272,283,GetActiveHandles,,,16,void node.GetActiveHandles (FunctionCallbackInfo<Value>)
220680,METHOD,node_process_methods.cc:<global>,TYPE_DECL,"static void GetActiveResourcesInfo(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  std::vector<Local<Value>> resources_info;

  // Active requests
  for (ReqWrapBase* req_wrap : *env->req_wrap_queue()) {
    AsyncWrap* w = req_wrap->GetAsyncWrap();
    if (w->persistent().IsEmpty()) continue;
    resources_info.emplace_back(
        OneByteString(env->isolate(), w->MemoryInfoName()));
  }

  // Active handles
  for (HandleWrap* w : *env->handle_wrap_queue()) {
    if (w->persistent().IsEmpty() || !HandleWrap::HasRef(w)) continue;
    resources_info.emplace_back(
        OneByteString(env->isolate(), w->MemoryInfoName()));
  }

  // Active timeouts
  resources_info.insert(resources_info.end(),
                        env->timeout_info()[0],
                        OneByteString(env->isolate(), ""Timeout""));

  // Active immediates
  resources_info.insert(resources_info.end(),
                        env->immediate_info()->ref_count(),
 ...",1,1,node_process_methods.cc,node.GetActiveResourcesInfo,,false,285,316,GetActiveResourcesInfo,,,17,void node.GetActiveResourcesInfo (FunctionCallbackInfo<Value>)
220842,METHOD,node_process_methods.cc:<global>,TYPE_DECL,"static void ResourceUsage(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  uv_rusage_t rusage;
  int err = uv_getrusage(&rusage);
  if (err)
    return env->ThrowUVException(err, ""uv_getrusage"");

  Local<ArrayBuffer> ab = get_fields_array_buffer(args, 0, 16);
  double* fields = static_cast<double*>(ab->Data());

  fields[0] = MICROS_PER_SEC * rusage.ru_utime.tv_sec + rusage.ru_utime.tv_usec;
  fields[1] = MICROS_PER_SEC * rusage.ru_stime.tv_sec + rusage.ru_stime.tv_usec;
  fields[2] = static_cast<double>(rusage.ru_maxrss);
  fields[3] = static_cast<double>(rusage.ru_ixrss);
  fields[4] = static_cast<double>(rusage.ru_idrss);
  fields[5] = static_cast<double>(rusage.ru_isrss);
  fields[6] = static_cast<double>(rusage.ru_minflt);
  fields[7] = static_cast<double>(rusage.ru_majflt);
  fields[8] = static_cast<double>(rusage.ru_nswap);
  fields[9] = static_cast<double>(rusage.ru_inblock);
  fields[10] = static_cast<double>(rusage.ru_oublo...",1,14,node_process_methods.cc,node.ResourceUsage,,false,318,345,ResourceUsage,,,18,void node.ResourceUsage (FunctionCallbackInfo<Value>)
221055,METHOD,node_process_methods.cc:<global>,TYPE_DECL,"static void DebugEnd(const FunctionCallbackInfo<Value>& args) {
#if HAVE_INSPECTOR
  Environment* env = Environment::GetCurrent(args);
  if (env->inspector_agent()->IsListening()) {
    env->inspector_agent()->Stop();
  }
#endif
}",1,1,node_process_methods.cc,node.DebugEnd,,false,446,453,DebugEnd,,,19,void node.DebugEnd (FunctionCallbackInfo<Value>)
221060,METHOD,node_process_methods.cc:<global>,TYPE_DECL,"static void ReallyExit(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  RunAtExit(env);
  ExitCode code = ExitCode::kNoFailure;
  Maybe<int32_t> code_int = args[0]->Int32Value(env->context());
  if (!code_int.IsNothing()) {
    code = static_cast<ExitCode>(code_int.FromJust());
  }
  env->Exit(code);
}",1,1,node_process_methods.cc,node.ReallyExit,,false,455,464,ReallyExit,,,20,void node.ReallyExit (FunctionCallbackInfo<Value>)
221118,METHOD,node_process_methods.cc:<global>,TYPE_DECL,"BindingData::BindingData(Realm* realm, v8::Local<v8::Object> object)
    : SnapshotableObject(realm, object, type_int) {
  Isolate* isolate = realm->isolate();
  Local<Context> context = realm->context();
  Local<ArrayBuffer> ab = ArrayBuffer::New(isolate, kBufferSize);
  array_buffer_.Reset(isolate, ab);
  object->Set(context, FIXED_ONE_BYTE_STRING(isolate, ""hrtimeBuffer""), ab)
      .ToChecked();
  backing_store_ = ab->GetBackingStore();
}",1,1,node_process_methods.cc,node.process.BindingData.BindingData,,false,468,477,BindingData,,,1,"ANY node.process.BindingData.BindingData (Realm*,ANY)"
221177,METHOD,node_process_methods.cc:<global>,TYPE_DECL,v8::CFunction BindingData::fast_number_(v8::CFunction::Make(FastNumber));,15,72,node_process_methods.cc,node.process.fast_number_,,false,479,479,fast_number_,,,2,ANY node.process.fast_number_ (ANY)
221182,METHOD,node_process_methods.cc:<global>,TYPE_DECL,v8::CFunction BindingData::fast_bigint_(v8::CFunction::Make(FastBigInt));,15,72,node_process_methods.cc,node.process.fast_bigint_,,false,480,480,fast_bigint_,,,3,ANY node.process.fast_bigint_ (ANY)
221187,METHOD,node_process_methods.cc:<global>,TYPE_DECL,"void BindingData::AddMethods(Isolate* isolate, Local<ObjectTemplate> target) {
  SetFastMethodNoSideEffect(
      isolate, target, ""hrtime"", SlowNumber, &fast_number_);
  SetFastMethodNoSideEffect(
      isolate, target, ""hrtimeBigInt"", SlowBigInt, &fast_bigint_);
}",1,1,node_process_methods.cc,node.process.BindingData.AddMethods,,false,482,487,AddMethods,,,4,"void node.process.BindingData.AddMethods (Isolate*,Local<ObjectTemplate>)"
221207,METHOD,node_process_methods.cc:<global>,TYPE_DECL,"void BindingData::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(SlowNumber);
  registry->Register(SlowBigInt);
  registry->Register(FastNumber);
  registry->Register(FastBigInt);
  registry->Register(fast_number_.GetTypeInfo());
  registry->Register(fast_bigint_.GetTypeInfo());
}",1,1,node_process_methods.cc,node.process.BindingData.RegisterExternalReferences,,false,489,497,RegisterExternalReferences,,,5,void node.process.BindingData.RegisterExternalReferences (ExternalReferenceRegistry*)
221248,METHOD,node_process_methods.cc:<global>,TYPE_DECL,"BindingData* BindingData::FromV8Value(Local<Value> value) {
  Local<Object> v8_object = value.As<Object>();
  return static_cast<BindingData*>(
      v8_object->GetAlignedPointerFromInternalField(BaseObject::kSlot));
}",1,1,node_process_methods.cc,node.process.BindingData.FromV8Value,,false,499,503,FromV8Value,,,6,BindingData node.process.BindingData.FromV8Value (Local<Value>)
221273,METHOD,node_process_methods.cc:<global>,TYPE_DECL,"void BindingData::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""array_buffer"", array_buffer_);
}",1,1,node_process_methods.cc,node.process.BindingData.MemoryInfo,,false,505,507,MemoryInfo,,,7,void node.process.BindingData.MemoryInfo (MemoryTracker*)
221284,METHOD,node_process_methods.cc:<global>,TYPE_DECL,"void BindingData::NumberImpl(BindingData* receiver) {
  // Make sure we don't accidentally access buffers wiped for snapshot.
  CHECK(!receiver->array_buffer_.IsEmpty());
  uint64_t t = uv_hrtime();
  uint32_t* fields = static_cast<uint32_t*>(receiver->backing_store_->Data());
  fields[0] = (t / NANOS_PER_SEC) >> 32;
  fields[1] = (t / NANOS_PER_SEC) & 0xffffffff;
  fields[2] = t % NANOS_PER_SEC;
}",1,19,node_process_methods.cc,node.process.BindingData.NumberImpl,,false,518,526,NumberImpl,,,8,void node.process.BindingData.NumberImpl (BindingData*)
221343,METHOD,node_process_methods.cc:<global>,TYPE_DECL,"void BindingData::BigIntImpl(BindingData* receiver) {
  // Make sure we don't accidentally access buffers wiped for snapshot.
  CHECK(!receiver->array_buffer_.IsEmpty());
  uint64_t t = uv_hrtime();
  uint64_t* fields = static_cast<uint64_t*>(receiver->backing_store_->Data());
  fields[0] = t;
}",1,1,node_process_methods.cc,node.process.BindingData.BigIntImpl,,false,528,534,BigIntImpl,,,9,void node.process.BindingData.BigIntImpl (BindingData*)
221376,METHOD,node_process_methods.cc:<global>,TYPE_DECL,"void BindingData::SlowBigInt(const FunctionCallbackInfo<Value>& args) {
  BigIntImpl(FromJSObject<BindingData>(args.Holder()));
}",1,1,node_process_methods.cc,node.process.BindingData.SlowBigInt,,false,536,538,SlowBigInt,,,10,void node.process.BindingData.SlowBigInt (FunctionCallbackInfo<Value>)
221390,METHOD,node_process_methods.cc:<global>,TYPE_DECL,"void BindingData::SlowNumber(const v8::FunctionCallbackInfo<v8::Value>& args) {
  NumberImpl(FromJSObject<BindingData>(args.Holder()));
}",1,1,node_process_methods.cc,node.process.BindingData.SlowNumber,,false,540,542,SlowNumber,,,11,void node.process.BindingData.SlowNumber (ANY)
221404,METHOD,node_process_methods.cc:<global>,TYPE_DECL,"bool BindingData::PrepareForSerialization(Local<Context> context,
                                          v8::SnapshotCreator* creator) {
  // It's not worth keeping.
  // Release it, we will recreate it when the instance is dehydrated.
  array_buffer_.Reset();
  // Return true because we need to maintain the reference to the binding from
  // JS land.
  return true;
}",1,1,node_process_methods.cc,node.process.BindingData.PrepareForSerialization,,false,544,552,PrepareForSerialization,,,12,"bool node.process.BindingData.PrepareForSerialization (Local<Context>,ANY*)"
221416,METHOD,node_process_methods.cc:<global>,TYPE_DECL,"InternalFieldInfoBase* BindingData::Serialize(int index) {
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info =
      InternalFieldInfoBase::New<InternalFieldInfo>(type());
  return info;
}",1,1,node_process_methods.cc,node.process.BindingData.Serialize,,false,554,559,Serialize,,,13,InternalFieldInfoBase node.process.BindingData.Serialize (int)
221438,METHOD,node_process_methods.cc:<global>,TYPE_DECL,"void BindingData::Deserialize(Local<Context> context,
                              Local<Object> holder,
                              int index,
                              InternalFieldInfoBase* info) {
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  v8::HandleScope scope(context->GetIsolate());
  Realm* realm = Realm::GetCurrent(context);
  // Recreate the buffer in the constructor.
  BindingData* binding = realm->AddBindingData<BindingData>(context, holder);
  CHECK_NOT_NULL(binding);
}",1,1,node_process_methods.cc,node.process.BindingData.Deserialize,,false,561,571,Deserialize,,,14,"void node.process.BindingData.Deserialize (Local<Context>,Local<Object>,int,InternalFieldInfoBase*)"
221480,METHOD,node_process_methods.cc:<global>,TYPE_DECL,"static void CreatePerIsolateProperties(IsolateData* isolate_data,
                                       Local<ObjectTemplate> target) {
  Isolate* isolate = isolate_data->isolate();

  BindingData::AddMethods(isolate, target);
  // define various internal methods
  SetMethod(isolate, target, ""_debugProcess"", DebugProcess);
  SetMethod(isolate, target, ""abort"", Abort);
  SetMethod(isolate, target, ""causeSegfault"", CauseSegfault);
  SetMethod(isolate, target, ""chdir"", Chdir);

  SetMethod(isolate, target, ""umask"", Umask);
  SetMethod(isolate, target, ""memoryUsage"", MemoryUsage);
  SetMethod(isolate, target, ""constrainedMemory"", GetConstrainedMemory);
  SetMethod(isolate, target, ""rss"", Rss);
  SetMethod(isolate, target, ""cpuUsage"", CPUUsage);
  SetMethod(isolate, target, ""resourceUsage"", ResourceUsage);

  SetMethod(isolate, target, ""_debugEnd"", DebugEnd);
  SetMethod(isolate, target, ""_getActiveRequests"", GetActiveRequests);
  SetMethod(isolate, target, ""_getActiveHandles"", GetActiv...",1,1,node_process_methods.cc,node.process.CreatePerIsolateProperties,,false,573,603,CreatePerIsolateProperties,,,15,"void node.process.CreatePerIsolateProperties (IsolateData*,Local<ObjectTemplate>)"
221606,METHOD,node_process_methods.cc:<global>,TYPE_DECL,"static void CreatePerContextProperties(Local<Object> target,
                                       Local<Value> unused,
                                       Local<Context> context,
                                       void* priv) {
  Realm* realm = Realm::GetCurrent(context);
  realm->AddBindingData<BindingData>(context, target);
}",1,1,node_process_methods.cc,node.process.CreatePerContextProperties,,false,605,611,CreatePerContextProperties,,,16,"void node.process.CreatePerContextProperties (Local<Object>,Local<Value>,Local<Context>,void*)"
221632,METHOD,node_process_methods.cc:<global>,TYPE_DECL,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  BindingData::RegisterExternalReferences(registry);

  registry->Register(DebugProcess);
  registry->Register(DebugEnd);
  registry->Register(Abort);
  registry->Register(CauseSegfault);
  registry->Register(Chdir);

  registry->Register(Umask);
  registry->Register(RawDebug);
  registry->Register(MemoryUsage);
  registry->Register(GetConstrainedMemory);
  registry->Register(Rss);
  registry->Register(CPUUsage);
  registry->Register(ResourceUsage);

  registry->Register(GetActiveRequests);
  registry->Register(GetActiveHandles);
  registry->Register(GetActiveResourcesInfo);
  registry->Register(Kill);

  registry->Register(Cwd);
  registry->Register(binding::DLOpen);
  registry->Register(ReallyExit);
  registry->Register(Uptime);
  registry->Register(PatchProcessObject);
}",1,1,node_process_methods.cc,node.process.RegisterExternalReferences,,false,613,640,RegisterExternalReferences,,,17,void node.process.RegisterExternalReferences (ExternalReferenceRegistry*)
221751,METHOD,node_process_object.cc:<global>,TYPE_DECL,"[](auto& a, auto& b) { return a.first < b.first; }",13,62,node_process_object.cc,node.CreateProcessObject.<lambda>0,,false,129,129,<lambda>0,,,1,"ANY node.CreateProcessObject.<lambda>0 (auto,auto)"
221790,METHOD,node_process_object.cc:<global>,TYPE_DECL,<global>,1,25,env-inl.hpp,node_process_object.cc:<global>,,false,1,258,<global>,,,1,
221793,METHOD,node_process_object.cc:<global>,TYPE_DECL,"static void ProcessTitleGetter(Local<Name> property,
                               const PropertyCallbackInfo<Value>& info) {
  std::string title = GetProcessTitle(""node"");
  info.GetReturnValue().Set(
      String::NewFromUtf8(info.GetIsolate(), title.data(),
                          NewStringType::kNormal, title.size())
      .ToLocalChecked());
}",1,1,node_process_object.cc,node.ProcessTitleGetter,,false,34,41,ProcessTitleGetter,,,1,"void node.ProcessTitleGetter (Local<Name>,PropertyCallbackInfo<Value>)"
221833,METHOD,node_process_object.cc:<global>,TYPE_DECL,"static void ProcessTitleSetter(Local<Name> property,
                               Local<Value> value,
                               const PropertyCallbackInfo<void>& info) {
  node::Utf8Value title(info.GetIsolate(), value);
  TRACE_EVENT_METADATA1(
      ""__metadata"", ""process_name"", ""name"", TRACE_STR_COPY(*title));
  uv_set_process_title(*title);
}",1,1,node_process_object.cc,node.ProcessTitleSetter,,false,43,50,ProcessTitleSetter,,,2,"void node.ProcessTitleSetter (Local<Name>,Local<Value>,PropertyCallbackInfo<void>)"
221857,METHOD,node_process_object.cc:<global>,TYPE_DECL,"static void DebugPortGetter(Local<Name> property,
                            const PropertyCallbackInfo<Value>& info) {
  Environment* env = Environment::GetCurrent(info);
  ExclusiveAccess<HostPort>::Scoped host_port(env->inspector_host_port());
  int port = host_port->port();
  info.GetReturnValue().Set(port);
}",1,1,node_process_object.cc,node.DebugPortGetter,,false,52,58,DebugPortGetter,,,3,"void node.DebugPortGetter (Local<Name>,PropertyCallbackInfo<Value>)"
221892,METHOD,node_process_object.cc:<global>,TYPE_DECL,"static void DebugPortSetter(Local<Name> property,
                            Local<Value> value,
                            const PropertyCallbackInfo<void>& info) {
  Environment* env = Environment::GetCurrent(info);
  int32_t port = value->Int32Value(env->context()).FromMaybe(0);

  if ((port != 0 && port < 1024) || port > 65535) {
    return THROW_ERR_OUT_OF_RANGE(
      env,
      ""process.debugPort must be 0 or in range 1024 to 65535"");
  }

  ExclusiveAccess<HostPort>::Scoped host_port(env->inspector_host_port());
  host_port->set_port(static_cast<int>(port));
}",1,1,node_process_object.cc,node.DebugPortSetter,,false,60,74,DebugPortSetter,,,4,"void node.DebugPortSetter (Local<Name>,Local<Value>,PropertyCallbackInfo<void>)"
221952,METHOD,node_process_object.cc:<global>,TYPE_DECL,"static void GetParentProcessId(Local<Name> property,
                               const PropertyCallbackInfo<Value>& info) {
  info.GetReturnValue().Set(uv_os_getppid());
}",1,1,node_process_object.cc,node.GetParentProcessId,,false,76,79,GetParentProcessId,,,5,"void node.GetParentProcessId (Local<Name>,PropertyCallbackInfo<Value>)"
221966,METHOD,node_process_object.cc:<global>,TYPE_DECL,"MaybeLocal<Object> CreateProcessObject(Realm* realm) {
  Isolate* isolate = realm->isolate();
  EscapableHandleScope scope(isolate);
  Local<Context> context = realm->context();

  Local<FunctionTemplate> process_template = FunctionTemplate::New(isolate);
  process_template->SetClassName(realm->env()->process_string());
  Local<Function> process_ctor;
  Local<Object> process;
  if (!process_template->GetFunction(context).ToLocal(&process_ctor) ||
      !process_ctor->NewInstance(context).ToLocal(&process)) {
    return MaybeLocal<Object>();
  }

  // process[exit_info_private_symbol]
  if (process
          ->SetPrivate(context,
                       realm->env()->exit_info_private_symbol(),
                       realm->env()->exit_info().GetJSArray())
          .IsNothing()) {
    return {};
  }

  // process.version
  READONLY_PROPERTY(
      process, ""version"", FIXED_ONE_BYTE_STRING(isolate, NODE_VERSION));

  Local<Object> versions = Object::New(isolate);
  // Node.js version ...",1,1,node_process_object.cc,node.CreateProcessObject,,false,81,175,CreateProcessObject,,,6,MaybeLocal<Object> node.CreateProcessObject (Realm*)
222243,METHOD,node_process_object.cc:<global>,TYPE_DECL,"void PatchProcessObject(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();
  Local<Context> context = isolate->GetCurrentContext();
  Environment* env = Environment::GetCurrent(context);
  CHECK(args[0]->IsObject());
  Local<Object> process = args[0].As<Object>();

  // process.title
  CHECK(process
            ->SetAccessor(
                context,
                FIXED_ONE_BYTE_STRING(isolate, ""title""),
                ProcessTitleGetter,
                env->owns_process_state() ? ProcessTitleSetter : nullptr,
                Local<Value>(),
                DEFAULT,
                None,
                SideEffectType::kHasNoSideEffect)
            .FromJust());

  // process.argv
  process->Set(context,
               FIXED_ONE_BYTE_STRING(isolate, ""argv""),
               ToV8Value(context, env->argv()).ToLocalChecked()).Check();

  // process.execArgv
  process->Set(context,
               FIXED_ONE_BYTE_STRING(isolate, ""execArgv""),
            ...",1,1,node_process_object.cc,node.PatchProcessObject,,false,177,244,PatchProcessObject,,,7,void node.PatchProcessObject (FunctionCallbackInfo<Value>)
222439,METHOD,node_process_object.cc:<global>,TYPE_DECL,"void RegisterProcessExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(RawDebug);
  registry->Register(GetParentProcessId);
  registry->Register(DebugPortSetter);
  registry->Register(DebugPortGetter);
  registry->Register(ProcessTitleSetter);
  registry->Register(ProcessTitleGetter);
}",1,1,node_process_object.cc,node.RegisterProcessExternalReferences,,false,246,253,RegisterProcessExternalReferences,,,8,void node.RegisterProcessExternalReferences (ExternalReferenceRegistry*)
222482,METHOD,node_realm-inl.hpp:<global>,TYPE_DECL,<global>,1,32,node_realm-inl.hpp,node_realm-inl.hpp:<global>,,false,1,145,<global>,,,1,
222485,METHOD,node_realm.cc:<global>,TYPE_DECL,"[&](BaseObject* obj) {
    std::cout << ""#"" << i++ << "" "" << obj << "": "" << obj->MemoryInfoName()
              << ""\n"";
  }",21,3,node_realm.cc,node.Realm.PrintInfoForSnapshot.<lambda>0,,false,225,228,<lambda>0,,,1,ANY node.Realm.PrintInfoForSnapshot.<lambda>0 (BaseObject*)
222514,METHOD,node_realm.cc:<global>,TYPE_DECL,"[](BaseObject* obj) {
    if (obj->IsNotIndicativeOfMemoryLeakAtExit()) return;
    fprintf(stderr,
            ""Found bad BaseObject during clean exit: %s\n"",
            obj->MemoryInfoName());
    fflush(stderr);
    ABORT();
  }",21,3,node_realm.cc,node.Realm.VerifyNoStrongBaseObjects.<lambda>1,,false,268,275,<lambda>1,,,1,ANY node.Realm.VerifyNoStrongBaseObjects.<lambda>1 (BaseObject*)
222549,METHOD,node_realm.cc:<global>,TYPE_DECL,<global>,1,28,node_realm.hpp,node_realm.cc:<global>,,false,1,358,<global>,,,1,
222552,METHOD,node_realm.cc:<global>,TYPE_DECL,"Realm::Realm(Environment* env, v8::Local<v8::Context> context, Kind kind)
    : env_(env), isolate_(context->GetIsolate()), kind_(kind) {
  context_.Reset(isolate_, context);
  env->AssignToContext(context, this, ContextInfo(""""));
}",1,1,node_realm.cc,node.Realm.Realm,,false,21,25,Realm,,,1,"ANY node.Realm.Realm (Environment*,ANY,Kind)"
222573,METHOD,node_realm.cc:<global>,TYPE_DECL,"Realm::~Realm() {
  CHECK_EQ(base_object_count_, 0);
}",1,1,node_realm.cc,node.Realm.~Realm,,false,27,29,~Realm,,,2,ANY node.Realm.~Realm ()
222580,METHOD,node_realm.cc:<global>,TYPE_DECL,"void Realm::MemoryInfo(MemoryTracker* tracker) const {
#define V(PropertyName, TypeName)                                              \
  tracker->TrackField(#PropertyName, PropertyName());
  PER_REALM_STRONG_PERSISTENT_VALUES(V)
#undef V

  tracker->TrackField(""cleanup_queue"", cleanup_queue_);
  tracker->TrackField(""builtins_with_cache"", builtins_with_cache);
  tracker->TrackField(""builtins_without_cache"", builtins_without_cache);
}",1,1,node_realm.cc,node.Realm.MemoryInfo,,false,31,40,MemoryInfo,,,3,void node.Realm.MemoryInfo (MemoryTracker*)
222605,METHOD,node_realm.cc:<global>,TYPE_DECL,"void Realm::CreateProperties() {
  HandleScope handle_scope(isolate_);
  Local<Context> ctx = context();

  // Store primordials setup by the per-context script in the environment.
  Local<Object> per_context_bindings =
      GetPerContextExports(ctx).ToLocalChecked();
  Local<Value> primordials =
      per_context_bindings->Get(ctx, env_->primordials_string())
          .ToLocalChecked();
  CHECK(primordials->IsObject());
  set_primordials(primordials.As<Object>());

  Local<String> prototype_string =
      FIXED_ONE_BYTE_STRING(isolate(), ""prototype"");

#define V(EnvPropertyName, PrimordialsPropertyName)                            \
  {                                                                            \
    Local<Value> ctor =                                                        \
        primordials.As<Object>()                                               \
            ->Get(ctx,                                                         \
                  FIXED_ONE_BY...",1,2,node_realm.cc,node.Realm.CreateProperties,,false,42,84,CreateProperties,,,4,void node.Realm.CreateProperties ()
222907,METHOD,node_realm.cc:<global>,TYPE_DECL,"RealmSerializeInfo Realm::Serialize(SnapshotCreator* creator) {
  RealmSerializeInfo info;
  Local<Context> ctx = context();

  // Currently all modules are compiled without cache in builtin snapshot
  // builder.
  info.builtins = std::vector<std::string>(builtins_without_cache.begin(),
                                           builtins_without_cache.end());

  uint32_t id = 0;
#define V(PropertyName, TypeName)                                              \
  do {                                                                         \
    Local<TypeName> field = PropertyName();                                    \
    if (!field.IsEmpty()) {                                                    \
      size_t index = creator->AddData(ctx, field);                             \
      info.persistent_values.push_back({#PropertyName, id, index});            \
    }                                                                          \
    id++;                                      ...",1,1,node_realm.cc,node.Realm.Serialize,,false,86,114,Serialize,,,5,RealmSerializeInfo node.Realm.Serialize (SnapshotCreator*)
222965,METHOD,node_realm.cc:<global>,TYPE_DECL,"void Realm::DeserializeProperties(const RealmSerializeInfo* info) {
  Local<Context> ctx = context();

  builtins_in_snapshot = info->builtins;

  const std::vector<PropInfo>& values = info->persistent_values;
  size_t i = 0;  // index to the array
  uint32_t id = 0;
#define V(PropertyName, TypeName)                                              \
  do {                                                                         \
    if (values.size() > i && id == values[i].id) {                             \
      const PropInfo& d = values[i];                                           \
      DCHECK_EQ(d.name, #PropertyName);                                        \
      MaybeLocal<TypeName> maybe_field =                                       \
          ctx->GetDataFromSnapshotOnce<TypeName>(d.index);                     \
      Local<TypeName> field;                                                   \
      if (!maybe_field.ToLocal(&field)) {                                      \
...",1,1,node_realm.cc,node.Realm.DeserializeProperties,,false,116,155,DeserializeProperties,,,6,void node.Realm.DeserializeProperties (RealmSerializeInfo*)
223033,METHOD,node_realm.cc:<global>,TYPE_DECL,"MaybeLocal<Value> Realm::ExecuteBootstrapper(const char* id) {
  EscapableHandleScope scope(isolate());
  Local<Context> ctx = context();
  MaybeLocal<Value> result =
      env()->builtin_loader()->CompileAndCall(ctx, id, this);

  // If there was an error during bootstrap, it must be unrecoverable
  // (e.g. max call stack exceeded). Clear the stack so that the
  // AsyncCallbackScope destructor doesn't fail on the id check.
  // There are only two ways to have a stack size > 1: 1) the user manually
  // called MakeCallback or 2) user awaited during bootstrap, which triggered
  // _tickCallback().
  if (result.IsEmpty()) {
    env()->async_hooks()->clear_async_id_stack();
  }

  return scope.EscapeMaybe(result);
}",1,1,node_realm.cc,node.Realm.ExecuteBootstrapper,,false,157,174,ExecuteBootstrapper,,,7,MaybeLocal<Value> node.Realm.ExecuteBootstrapper (char*)
223083,METHOD,node_realm.cc:<global>,TYPE_DECL,"MaybeLocal<Value> Realm::RunBootstrapping() {
  EscapableHandleScope scope(isolate_);

  CHECK(!has_run_bootstrapping_code());

  Local<Value> result;
  if (!ExecuteBootstrapper(""internal/bootstrap/realm"").ToLocal(&result) ||
      !BootstrapRealm().ToLocal(&result)) {
    return MaybeLocal<Value>();
  }

  DoneBootstrapping();

  return scope.Escape(result);
}",1,1,node_realm.cc,node.Realm.RunBootstrapping,,false,176,190,RunBootstrapping,,,8,MaybeLocal<Value> node.Realm.RunBootstrapping ()
223125,METHOD,node_realm.cc:<global>,TYPE_DECL,"void Realm::DoneBootstrapping() {
  // Make sure that no request or handle is created during bootstrap -
  // if necessary those should be done in pre-execution.
  // Usually, doing so would trigger the checks present in the ReqWrap and
  // HandleWrap classes, so this is only a consistency check.

  // TODO(legendecas): track req_wrap and handle_wrap by realms instead of
  // environments.
  if (kind_ == kPrincipal) {
    CHECK(env_->req_wrap_queue()->IsEmpty());
    CHECK(env_->handle_wrap_queue()->IsEmpty());
  }

  has_run_bootstrapping_code_ = true;

  // This adjusts the return value of base_object_created_after_bootstrap() so
  // that tests that check the count do not have to account for internally
  // created BaseObjects.
  base_object_created_by_bootstrap_ = base_object_count_;
}",1,1,node_realm.cc,node.Realm.DoneBootstrapping,,false,192,211,DoneBootstrapping,,,9,void node.Realm.DoneBootstrapping ()
223156,METHOD,node_realm.cc:<global>,TYPE_DECL,"void Realm::RunCleanup() {
  TRACE_EVENT0(TRACING_CATEGORY_NODE1(realm), ""RunCleanup"");
  for (size_t i = 0; i < binding_data_store_.size(); ++i) {
    binding_data_store_[i].reset();
  }
  cleanup_queue_.Drain();
}",1,1,node_realm.cc,node.Realm.RunCleanup,,false,213,219,RunCleanup,,,10,void node.Realm.RunCleanup ()
223189,METHOD,node_realm.cc:<global>,TYPE_DECL,"void Realm::PrintInfoForSnapshot() {
  fprintf(stderr, ""Realm = %p\n"", this);
  fprintf(stderr, ""BaseObjects of the Realm:\n"");
  size_t i = 0;
  ForEachBaseObject([&](BaseObject* obj) {
    std::cout << ""#"" << i++ << "" "" << obj << "": "" << obj->MemoryInfoName()
              << ""\n"";
  });

  fprintf(stderr, ""\nBuiltins without cache:\n"");
  for (const auto& s : builtins_without_cache) {
    fprintf(stderr, ""%s\n"", s.c_str());
  }
  fprintf(stderr, ""\nBuiltins with cache:\n"");
  for (const auto& s : builtins_with_cache) {
    fprintf(stderr, ""%s\n"", s.c_str());
  }
  fprintf(stderr, ""\nStatic bindings (need to be registered):\n"");
  for (const auto mod : internal_bindings) {
    fprintf(stderr, ""%s:%s\n"", mod->nm_filename, mod->nm_modname);
  }

  fprintf(stderr, ""End of the Realm.\n"");
}",1,1,node_realm.cc,node.Realm.PrintInfoForSnapshot,,false,221,244,PrintInfoForSnapshot,,,11,void node.Realm.PrintInfoForSnapshot ()
223252,METHOD,node_realm.cc:<global>,TYPE_DECL,"void Realm::VerifyNoStrongBaseObjects() {
  // When a process exits cleanly, i.e. because the event loop ends up without
  // things to wait for, the Node.js objects that are left on the heap should
  // be:
  //
  //   1. weak, i.e. ready for garbage collection once no longer referenced, or
  //   2. detached, i.e. scheduled for destruction once no longer referenced, or
  //   3. an unrefed libuv handle, i.e. does not keep the event loop alive, or
  //   4. an inactive libuv handle (essentially the same here)
  //
  // There are a few exceptions to this rule, but generally, if there are
  // C++-backed Node.js objects on the heap that do not fall into the above
  // categories, we may be looking at a potential memory leak. Most likely,
  // the cause is a missing MakeWeak() call on the corresponding object.
  //
  // In order to avoid this kind of problem, we check the list of BaseObjects
  // for these criteria. Currently, we only do so when explicitly instructed to
  // or when i...",1,1,node_realm.cc,node.Realm.VerifyNoStrongBaseObjects,,false,246,276,VerifyNoStrongBaseObjects,,,12,void node.Realm.VerifyNoStrongBaseObjects ()
223268,METHOD,node_realm.cc:<global>,TYPE_DECL,"v8::Local<v8::Context> Realm::context() const {
  return PersistentToLocal::Strong(context_);
}",1,1,node_realm.cc,node.Realm.context,,false,278,280,context,,,13,Local<v8::Context> node.Realm.context ()
223280,METHOD,node_realm.cc:<global>,TYPE_DECL,"PrincipalRealm::PrincipalRealm(Environment* env,
                               v8::Local<v8::Context> context,
                               const RealmSerializeInfo* realm_info)
    : Realm(env, context, kPrincipal) {
  // Create properties if not deserializing from snapshot.
  // Or the properties are deserialized with DeserializeProperties() when the
  // env drained the deserialize requests.
  if (realm_info == nullptr) {
    CreateProperties();
  }
}",1,1,node_realm.cc,node.PrincipalRealm.PrincipalRealm,,false,296,306,PrincipalRealm,,,16,"ANY node.PrincipalRealm.PrincipalRealm (Environment*,ANY,RealmSerializeInfo*)"
223293,METHOD,node_realm.cc:<global>,TYPE_DECL,"PrincipalRealm::~PrincipalRealm() {
  DCHECK(!context_.IsEmpty());

  HandleScope handle_scope(isolate());
  env_->UnassignFromContext(context());
}",1,1,node_realm.cc,node.PrincipalRealm.~PrincipalRealm,,false,308,313,~PrincipalRealm,,,17,ANY node.PrincipalRealm.~PrincipalRealm ()
223311,METHOD,node_realm.cc:<global>,TYPE_DECL,"MaybeLocal<Value> PrincipalRealm::BootstrapRealm() {
  HandleScope scope(isolate_);

  if (ExecuteBootstrapper(""internal/bootstrap/node"").IsEmpty()) {
    return MaybeLocal<Value>();
  }

  if (!env_->no_browser_globals()) {
    if (ExecuteBootstrapper(""internal/bootstrap/web/exposed-wildcard"")
            .IsEmpty() ||
        ExecuteBootstrapper(""internal/bootstrap/web/exposed-window-or-worker"")
            .IsEmpty()) {
      return MaybeLocal<Value>();
    }
  }

  // TODO(joyeecheung): skip these in the snapshot building for workers.
  auto thread_switch_id =
      env_->is_main_thread() ? ""internal/bootstrap/switches/is_main_thread""
                             : ""internal/bootstrap/switches/is_not_main_thread"";
  if (ExecuteBootstrapper(thread_switch_id).IsEmpty()) {
    return MaybeLocal<Value>();
  }

  auto process_state_switch_id =
      env_->owns_process_state()
          ? ""internal/bootstrap/switches/does_own_process_state""
          : ""internal/bootstrap/switches/doe...",1,1,node_realm.cc,node.PrincipalRealm.BootstrapRealm,,false,315,356,BootstrapRealm,,,18,MaybeLocal<Value> node.PrincipalRealm.BootstrapRealm ()
223457,METHOD,node_realm.hpp:<global>,TYPE_DECL,<global>,1,28,node_realm.hpp,node_realm.hpp:<global>,,false,1,184,<global>,,,1,
223460,METHOD,node_report.cc:<global>,TYPE_DECL,"[&](Environment* env) {
        std::ostringstream os;

        GetNodeReport(
            env, ""Worker thread subreport"", trigger, Local<Value>(), os);

        Mutex::ScopedLock lock(workers_mutex);
        worker_infos.emplace_back(os.str());
        notify.Signal(lock);
      }",47,7,node_report.cc,node.report.WriteNodeReport..<lambda>1,,false,228,237,<lambda>1,,,1,ANY node.report.WriteNodeReport..<lambda>1 (Environment*)
223494,METHOD,node_report.cc:<global>,TYPE_DECL,"[&](Worker* w) {
      expected_results += w->RequestInterrupt([&](Environment* env) {
        std::ostringstream os;

        GetNodeReport(
            env, ""Worker thread subreport"", trigger, Local<Value>(), os);

        Mutex::ScopedLock lock(workers_mutex);
        worker_infos.emplace_back(os.str());
        notify.Signal(lock);
      });
    }",24,5,node_report.cc,node.report.WriteNodeReport.<lambda>0,,false,227,238,<lambda>0,,,1,ANY node.report.WriteNodeReport.<lambda>0 (Worker*)
223508,METHOD,node_report.cc:<global>,TYPE_DECL,"[](int ch) {
                return !std::iswspace(ch);
              }",59,15,node_report.cc,node.report.PrintJavaScriptErrorStack.<lambda>2,,false,539,541,<lambda>2,,,1,ANY node.report.PrintJavaScriptErrorStack.<lambda>2 (int)
223521,METHOD,node_report.cc:<global>,TYPE_DECL,"[](auto& a, auto& b) { return a.first < b.first; }",13,62,node_report.cc,node.report.PrintComponentVersions.<lambda>3,,false,818,818,<lambda>3,,,1,"ANY node.report.PrintComponentVersions.<lambda>3 (auto,auto)"
223577,METHOD,node_report.cc:<global>,TYPE_DECL,<global>,1,29,node_report.hpp,node_report.cc:<global>,,false,1,999,<global>,,,1,
223601,METHOD,node_report.cc:<global>,TYPE_DECL,"static void WriteNodeReport(Isolate* isolate,
                            Environment* env,
                            const char* message,
                            const char* trigger,
                            const std::string& filename,
                            std::ostream& out,
                            Local<Value> error,
                            bool compact);",13,41,node_report.cc,node.report.WriteNodeReport,,false,57,64,WriteNodeReport,,,1,"void node.report.WriteNodeReport (Isolate*,Environment*,char*,char*,ANY,ANY,Local<Value>,bool)"
223613,METHOD,node_report.cc:<global>,TYPE_DECL,static void PrintVersionInformation(JSONWriter* writer);,13,55,node_report.cc,node.report.PrintVersionInformation,,false,65,65,PrintVersionInformation,,,2,void node.report.PrintVersionInformation (JSONWriter*)
223618,METHOD,node_report.cc:<global>,TYPE_DECL,"static void PrintJavaScriptErrorStack(JSONWriter* writer,
                                      Isolate* isolate,
                                      Local<Value> error,
                                      const char* trigger);",13,58,node_report.cc,node.report.PrintJavaScriptErrorStack,,false,66,69,PrintJavaScriptErrorStack,,,3,"void node.report.PrintJavaScriptErrorStack (JSONWriter*,Isolate*,Local<Value>,char*)"
223626,METHOD,node_report.cc:<global>,TYPE_DECL,static void PrintEmptyJavaScriptStack(JSONWriter* writer);,13,57,node_report.cc,node.report.PrintEmptyJavaScriptStack,,false,70,70,PrintEmptyJavaScriptStack,,,4,void node.report.PrintEmptyJavaScriptStack (JSONWriter*)
223631,METHOD,node_report.cc:<global>,TYPE_DECL,"static void PrintJavaScriptStack(JSONWriter* writer,
                                 Isolate* isolate,
                                 const char* trigger);",13,53,node_report.cc,node.report.PrintJavaScriptStack,,false,71,73,PrintJavaScriptStack,,,5,"void node.report.PrintJavaScriptStack (JSONWriter*,Isolate*,char*)"
223638,METHOD,node_report.cc:<global>,TYPE_DECL,"static void PrintJavaScriptErrorProperties(JSONWriter* writer,
                                           Isolate* isolate,
                                           Local<Value> error);",13,62,node_report.cc,node.report.PrintJavaScriptErrorProperties,,false,74,76,PrintJavaScriptErrorProperties,,,6,"void node.report.PrintJavaScriptErrorProperties (JSONWriter*,Isolate*,Local<Value>)"
223645,METHOD,node_report.cc:<global>,TYPE_DECL,static void PrintNativeStack(JSONWriter* writer);,13,48,node_report.cc,node.report.PrintNativeStack,,false,77,77,PrintNativeStack,,,7,void node.report.PrintNativeStack (JSONWriter*)
223650,METHOD,node_report.cc:<global>,TYPE_DECL,static void PrintResourceUsage(JSONWriter* writer);,13,50,node_report.cc,node.report.PrintResourceUsage,,false,78,78,PrintResourceUsage,,,8,void node.report.PrintResourceUsage (JSONWriter*)
223655,METHOD,node_report.cc:<global>,TYPE_DECL,"static void PrintGCStatistics(JSONWriter* writer, Isolate* isolate);",13,67,node_report.cc,node.report.PrintGCStatistics,,false,79,79,PrintGCStatistics,,,9,"void node.report.PrintGCStatistics (JSONWriter*,Isolate*)"
223661,METHOD,node_report.cc:<global>,TYPE_DECL,static void PrintSystemInformation(JSONWriter* writer);,13,54,node_report.cc,node.report.PrintSystemInformation,,false,80,80,PrintSystemInformation,,,10,void node.report.PrintSystemInformation (JSONWriter*)
223666,METHOD,node_report.cc:<global>,TYPE_DECL,static void PrintLoadedLibraries(JSONWriter* writer);,13,52,node_report.cc,node.report.PrintLoadedLibraries,,false,81,81,PrintLoadedLibraries,,,11,void node.report.PrintLoadedLibraries (JSONWriter*)
223671,METHOD,node_report.cc:<global>,TYPE_DECL,static void PrintComponentVersions(JSONWriter* writer);,13,54,node_report.cc,node.report.PrintComponentVersions,,false,82,82,PrintComponentVersions,,,12,void node.report.PrintComponentVersions (JSONWriter*)
223676,METHOD,node_report.cc:<global>,TYPE_DECL,static void PrintRelease(JSONWriter* writer);,13,44,node_report.cc,node.report.PrintRelease,,false,83,83,PrintRelease,,,13,void node.report.PrintRelease (JSONWriter*)
223681,METHOD,node_report.cc:<global>,TYPE_DECL,static void PrintCpuInfo(JSONWriter* writer);,13,44,node_report.cc,node.report.PrintCpuInfo,,false,84,84,PrintCpuInfo,,,14,void node.report.PrintCpuInfo (JSONWriter*)
223686,METHOD,node_report.cc:<global>,TYPE_DECL,static void PrintNetworkInterfaceInfo(JSONWriter* writer);,13,57,node_report.cc,node.report.PrintNetworkInterfaceInfo,,false,85,85,PrintNetworkInterfaceInfo,,,15,void node.report.PrintNetworkInterfaceInfo (JSONWriter*)
223691,METHOD,node_report.cc:<global>,TYPE_DECL,"static void WriteNodeReport(Isolate* isolate,
                            Environment* env,
                            const char* message,
                            const char* trigger,
                            const std::string& filename,
                            std::ostream& out,
                            Local<Value> error,
                            bool compact) {
  // Obtain the current time and the pid.
  TIME_TYPE tm_struct;
  DiagnosticFilename::LocalTime(&tm_struct);
  uv_pid_t pid = uv_os_getpid();

  // Save formatting for output stream.
  std::ios old_state(nullptr);
  old_state.copyfmt(out);

  // File stream opened OK, now start printing the report content:
  // the title and header information (event, filename, timestamp and pid)

  JSONWriter writer(out, compact);
  writer.json_start();
  writer.json_objectstart(""header"");
  writer.json_keyvalue(""reportVersion"", NODE_REPORT_VERSION);
  writer.json_keyvalue(""event"", message);
  writer.json_keyvalue(""tri...",1,1,node_report.cc,node.report.WriteNodeReport,,false,89,256,WriteNodeReport,,,16,"void node.report.WriteNodeReport (Isolate*,Environment*,char*,char*,ANY,ANY,Local<Value>,bool)"
224122,METHOD,node_report.cc:<global>,TYPE_DECL,"static void PrintVersionInformation(JSONWriter* writer) {
  std::ostringstream buf;
  // Report Node version
  buf << ""v"" << NODE_VERSION_STRING;
  writer->json_keyvalue(""nodejsVersion"", buf.str());
  buf.str("""");

#ifndef _WIN32
  // Report compiler and runtime glibc versions where possible.
  const char* (*libc_version)();
  *(reinterpret_cast<void**>(&libc_version)) =
      dlsym(RTLD_DEFAULT, ""gnu_get_libc_version"");
  if (libc_version != nullptr)
    writer->json_keyvalue(""glibcVersionRuntime"", (*libc_version)());
#endif /* _WIN32 */

#ifdef __GLIBC__
  buf << __GLIBC__ << ""."" << __GLIBC_MINOR__;
  writer->json_keyvalue(""glibcVersionCompiler"", buf.str());
  buf.str("""");
#endif

  // Report Process word size
  writer->json_keyvalue(""wordSize"", sizeof(void*) * 8);
  writer->json_keyvalue(""arch"", per_process::metadata.arch);
  writer->json_keyvalue(""platform"", per_process::metadata.platform);

  // Report deps component versions
  PrintComponentVersions(writer);

  // Report relea...",1,1,node_report.cc,node.report.PrintVersionInformation,,false,259,310,PrintVersionInformation,,,17,void node.report.PrintVersionInformation (JSONWriter*)
224145,METHOD,node_report.cc:<global>,TYPE_DECL,const char* (*libc_version)();,13,31,node_report.cc,node.report.PrintVersionInformation.libc_version,,false,268,268,libc_version,,,5,char* node.report.PrintVersionInformation.libc_version ()
224270,METHOD,node_report.cc:<global>,TYPE_DECL,"static void PrintCpuInfo(JSONWriter* writer) {
  uv_cpu_info_t* cpu_info;
  int count;
  if (uv_cpu_info(&cpu_info, &count) == 0) {
    writer->json_arraystart(""cpus"");
    for (int i = 0; i < count; i++) {
      writer->json_start();
      writer->json_keyvalue(""model"", cpu_info[i].model);
      writer->json_keyvalue(""speed"", cpu_info[i].speed);
      writer->json_keyvalue(""user"", cpu_info[i].cpu_times.user);
      writer->json_keyvalue(""nice"", cpu_info[i].cpu_times.nice);
      writer->json_keyvalue(""sys"", cpu_info[i].cpu_times.sys);
      writer->json_keyvalue(""idle"", cpu_info[i].cpu_times.idle);
      writer->json_keyvalue(""irq"", cpu_info[i].cpu_times.irq);
      writer->json_end();
    }
    writer->json_arrayend();
    uv_free_cpu_info(cpu_info, count);
  }
}",1,1,node_report.cc,node.report.PrintCpuInfo,,false,313,332,PrintCpuInfo,,,18,void node.report.PrintCpuInfo (JSONWriter*)
224398,METHOD,node_report.cc:<global>,TYPE_DECL,"static void PrintNetworkInterfaceInfo(JSONWriter* writer) {
  uv_interface_address_t* interfaces;
  char ip[INET6_ADDRSTRLEN];
  char netmask[INET6_ADDRSTRLEN];
  char mac[18];
  int count;

  if (uv_interface_addresses(&interfaces, &count) == 0) {
    writer->json_arraystart(""networkInterfaces"");

    for (int i = 0; i < count; i++) {
      writer->json_start();
      writer->json_keyvalue(""name"", interfaces[i].name);
      writer->json_keyvalue(""internal"", !!interfaces[i].is_internal);
      snprintf(mac,
               sizeof(mac),
               ""%02x:%02x:%02x:%02x:%02x:%02x"",
               static_cast<unsigned char>(interfaces[i].phys_addr[0]),
               static_cast<unsigned char>(interfaces[i].phys_addr[1]),
               static_cast<unsigned char>(interfaces[i].phys_addr[2]),
               static_cast<unsigned char>(interfaces[i].phys_addr[3]),
               static_cast<unsigned char>(interfaces[i].phys_addr[4]),
               static_cast<unsigned char>(interfaces[...",1,1,node_report.cc,node.report.PrintNetworkInterfaceInfo,,false,334,383,PrintNetworkInterfaceInfo,,,19,void node.report.PrintNetworkInterfaceInfo (JSONWriter*)
224670,METHOD,node_report.cc:<global>,TYPE_DECL,"static void PrintJavaScriptErrorProperties(JSONWriter* writer,
                                           Isolate* isolate,
                                           Local<Value> error) {
  writer->json_objectstart(""errorProperties"");
  if (!error.IsEmpty() && error->IsObject()) {
    TryCatch try_catch(isolate);
    Local<Object> error_obj = error.As<Object>();
    Local<Context> context = error_obj->GetIsolate()->GetCurrentContext();
    Local<Array> keys;
    if (!error_obj->GetOwnPropertyNames(context).ToLocal(&keys)) {
      return writer->json_objectend();  // the end of 'errorProperties'
    }
    uint32_t keys_length = keys->Length();
    for (uint32_t i = 0; i < keys_length; i++) {
      Local<Value> key;
      if (!keys->Get(context, i).ToLocal(&key) || !key->IsString()) {
        continue;
      }
      Local<Value> value;
      Local<String> value_string;
      if (!error_obj->Get(context, key).ToLocal(&value) ||
          !value->ToString(context).ToLocal(&value_string...",1,1,node_report.cc,node.report.PrintJavaScriptErrorProperties,,false,385,416,PrintJavaScriptErrorProperties,,,20,"void node.report.PrintJavaScriptErrorProperties (JSONWriter*,Isolate*,Local<Value>)"
224859,METHOD,node_report.cc:<global>,TYPE_DECL,"static Maybe<std::string> ErrorToString(Isolate* isolate,
                                        Local<Context> context,
                                        Local<Value> error) {
  if (error.IsEmpty()) {
    return Nothing<std::string>();
  }

  MaybeLocal<String> maybe_str;
  // `ToString` is not available to Symbols.
  if (error->IsSymbol()) {
    maybe_str = error.As<v8::Symbol>()->ToDetailString(context);
  } else if (!error->IsObject()) {
    maybe_str = error->ToString(context);
  } else if (error->IsObject()) {
    MaybeLocal<Value> stack = error.As<Object>()->Get(
        context, FIXED_ONE_BYTE_STRING(isolate, ""stack""));
    if (!stack.IsEmpty() && stack.ToLocalChecked()->IsString()) {
      maybe_str = stack.ToLocalChecked().As<String>();
    }
  }

  Local<String> js_str;
  if (!maybe_str.ToLocal(&js_str)) {
    return Nothing<std::string>();
  }
  String::Utf8Value sv(isolate, js_str);
  return Just<>(std::string(*sv, sv.length()));
}",1,1,node_report.cc,node.report.ErrorToString,,false,418,445,ErrorToString,,,21,"Maybe<std::string> node.report.ErrorToString (Isolate*,Local<Context>,Local<Value>)"
224994,METHOD,node_report.cc:<global>,TYPE_DECL,"static void PrintEmptyJavaScriptStack(JSONWriter* writer) {
  writer->json_keyvalue(""message"", ""No stack."");
  writer->json_arraystart(""stack"");
  writer->json_element(""Unavailable."");
  writer->json_arrayend();

  writer->json_objectstart(""errorProperties"");
  writer->json_objectend();
}",1,1,node_report.cc,node.report.PrintEmptyJavaScriptStack,,false,447,455,PrintEmptyJavaScriptStack,,,22,void node.report.PrintEmptyJavaScriptStack (JSONWriter*)
225028,METHOD,node_report.cc:<global>,TYPE_DECL,"static void PrintJavaScriptStack(JSONWriter* writer,
                                 Isolate* isolate,
                                 const char* trigger) {
  // Can not capture the stacktrace when the isolate is in a OOM state or no
  // context is entered.
  if (!strcmp(trigger, ""OOMError"") || !isolate->InContext()) {
    PrintEmptyJavaScriptStack(writer);
    return;
  }

  HandleScope scope(isolate);
  RegisterState state;
  state.pc = nullptr;
  state.fp = &state;
  state.sp = &state;

  // in-out params
  SampleInfo info;
  void* samples[MAX_FRAME_COUNT];
  isolate->GetStackSample(state, samples, MAX_FRAME_COUNT, &info);

  constexpr StackTrace::StackTraceOptions stack_trace_options =
      static_cast<StackTrace::StackTraceOptions>(
          StackTrace::kDetailed |
          StackTrace::kExposeFramesAcrossSecurityOrigins);
  Local<StackTrace> stack = StackTrace::CurrentStackTrace(
      isolate, MAX_FRAME_COUNT, stack_trace_options);

  if (stack->GetFrameCount() == 0) {
...",1,1,node_report.cc,node.report.PrintJavaScriptStack,,false,458,508,PrintJavaScriptStack,,,23,"void node.report.PrintJavaScriptStack (JSONWriter*,Isolate*,char*)"
225213,METHOD,node_report.cc:<global>,TYPE_DECL,"static void PrintJavaScriptErrorStack(JSONWriter* writer,
                                      Isolate* isolate,
                                      Local<Value> error,
                                      const char* trigger) {
  if (error.IsEmpty()) {
    return PrintJavaScriptStack(writer, isolate, trigger);
  }

  TryCatch try_catch(isolate);
  HandleScope scope(isolate);
  Local<Context> context = isolate->GetCurrentContext();
  std::string ss = """";
  if (!ErrorToString(isolate, context, error).To(&ss)) {
    PrintEmptyJavaScriptStack(writer);
    return;
  }

  int line = ss.find('\n');
  if (line == -1) {
    writer->json_keyvalue(""message"", ss);
  } else {
    std::string l = ss.substr(0, line);
    writer->json_keyvalue(""message"", l);
    writer->json_arraystart(""stack"");
    ss = ss.substr(line + 1);
    line = ss.find('\n');
    while (line != -1) {
      l = ss.substr(0, line);
      l.erase(l.begin(), std::find_if(l.begin(), l.end(), [](int ch) {
                ret...",1,1,node_report.cc,node.report.PrintJavaScriptErrorStack,,false,511,551,PrintJavaScriptErrorStack,,,24,"void node.report.PrintJavaScriptErrorStack (JSONWriter*,Isolate*,Local<Value>,char*)"
225389,METHOD,node_report.cc:<global>,TYPE_DECL,"static void PrintNativeStack(JSONWriter* writer) {
  auto sym_ctx = NativeSymbolDebuggingContext::New();
  void* frames[256];
  const int size = sym_ctx->GetStackTrace(frames, arraysize(frames));
  writer->json_arraystart(""nativeStack"");
  int i;
  for (i = 1; i < size; i++) {
    void* frame = frames[i];
    writer->json_start();
    writer->json_keyvalue(""pc"",
                          ValueToHexString(reinterpret_cast<uintptr_t>(frame)));
    writer->json_keyvalue(""symbol"", sym_ctx->LookupSymbol(frame).Display());
    writer->json_end();
  }
  writer->json_arrayend();
}",1,1,node_report.cc,node.report.PrintNativeStack,,false,554,569,PrintNativeStack,,,25,void node.report.PrintNativeStack (JSONWriter*)
225469,METHOD,node_report.cc:<global>,TYPE_DECL,"static void PrintGCStatistics(JSONWriter* writer, Isolate* isolate) {
  HeapStatistics v8_heap_stats;
  isolate->GetHeapStatistics(&v8_heap_stats);
  HeapSpaceStatistics v8_heap_space_stats;

  writer->json_objectstart(""javascriptHeap"");
  writer->json_keyvalue(""totalMemory"", v8_heap_stats.total_heap_size());
  writer->json_keyvalue(""executableMemory"",
                        v8_heap_stats.total_heap_size_executable());
  writer->json_keyvalue(""totalCommittedMemory"",
                        v8_heap_stats.total_physical_size());
  writer->json_keyvalue(""availableMemory"",
                        v8_heap_stats.total_available_size());
  writer->json_keyvalue(""totalGlobalHandlesMemory"",
                        v8_heap_stats.total_global_handles_size());
  writer->json_keyvalue(""usedGlobalHandlesMemory"",
                        v8_heap_stats.used_global_handles_size());
  writer->json_keyvalue(""usedMemory"", v8_heap_stats.used_heap_size());
  writer->json_keyvalue(""memoryLimit"", v8_heap_s...",1,1,node_report.cc,node.report.PrintGCStatistics,,false,575,625,PrintGCStatistics,,,26,"void node.report.PrintGCStatistics (JSONWriter*,Isolate*)"
225711,METHOD,node_report.cc:<global>,TYPE_DECL,"static void PrintResourceUsage(JSONWriter* writer) {
  // Get process uptime in seconds
  uint64_t uptime =
      (uv_hrtime() - per_process::node_start_time) / (NANOS_PER_SEC);
  if (uptime == 0) uptime = 1;  // avoid division by zero.

  // Process and current thread usage statistics
  uv_rusage_t rusage;
  writer->json_objectstart(""resourceUsage"");

  uint64_t free_memory = uv_get_free_memory();
  uint64_t total_memory = uv_get_total_memory();

  writer->json_keyvalue(""free_memory"", free_memory);
  writer->json_keyvalue(""total_memory"", total_memory);

  size_t rss;
  int err = uv_resident_set_memory(&rss);
  if (!err) {
    writer->json_keyvalue(""rss"", rss);
  }

  uint64_t constrained_memory = uv_get_constrained_memory();
  if (constrained_memory) {
    writer->json_keyvalue(""constrained_memory"", constrained_memory);
  }

  // See GuessMemoryAvailableToTheProcess
  if (!err && constrained_memory && constrained_memory >= rss) {
    uint64_t available_memory = constrained_memory -...",1,1,node_report.cc,node.report.PrintResourceUsage,,false,627,711,PrintResourceUsage,,,27,void node.report.PrintResourceUsage (JSONWriter*)
225983,METHOD,node_report.cc:<global>,TYPE_DECL,"static void PrintSystemInformation(JSONWriter* writer) {
  uv_env_item_t* envitems;
  int envcount;
  int r;

  writer->json_objectstart(""environmentVariables"");

  {
    Mutex::ScopedLock lock(per_process::env_var_mutex);
    r = uv_os_environ(&envitems, &envcount);
  }

  if (r == 0) {
    for (int i = 0; i < envcount; i++)
      writer->json_keyvalue(envitems[i].name, envitems[i].value);

    uv_os_free_environ(envitems, envcount);
  }

  writer->json_objectend();

#ifndef _WIN32
  static struct {
    const char* description;
    int id;
  } rlimit_strings[] = {
    {""core_file_size_blocks"", RLIMIT_CORE},
    {""data_seg_size_kbytes"", RLIMIT_DATA},
    {""file_size_blocks"", RLIMIT_FSIZE},
#if !(defined(_AIX) || defined(__sun))
    {""max_locked_memory_bytes"", RLIMIT_MEMLOCK},
#endif
#ifndef __sun
    {""max_memory_size_kbytes"", RLIMIT_RSS},
#endif
    {""open_files"", RLIMIT_NOFILE},
    {""stack_size_bytes"", RLIMIT_STACK},
    {""cpu_time_seconds"", RLIMIT_CPU},
#ifndef __sun
    {""max_u...",1,1,node_report.cc,node.report.PrintSystemInformation,,false,714,785,PrintSystemInformation,,,28,void node.report.PrintSystemInformation (JSONWriter*)
226178,METHOD,node_report.cc:<global>,TYPE_DECL,"static void PrintLoadedLibraries(JSONWriter* writer) {
  writer->json_arraystart(""sharedObjects"");
  std::vector<std::string> modules =
      NativeSymbolDebuggingContext::GetLoadedLibraries();
  for (auto const& module_name : modules) writer->json_element(module_name);
  writer->json_arrayend();
}",1,1,node_report.cc,node.report.PrintLoadedLibraries,,false,788,794,PrintLoadedLibraries,,,29,void node.report.PrintLoadedLibraries (JSONWriter*)
226214,METHOD,node_report.cc:<global>,TYPE_DECL,"static void PrintComponentVersions(JSONWriter* writer) {
  std::stringstream buf;

  writer->json_objectstart(""componentVersions"");

#define V(key) +1
  std::pair<std::string_view, std::string_view>
      versions_array[NODE_VERSIONS_KEYS(V)];
#undef V
  auto* slot = &versions_array[0];

#define V(key)                                                                 \
  do {                                                                         \
    *slot++ = std::pair<std::string_view, std::string_view>(                   \
        #key, per_process::metadata.versions.key);                             \
  } while (0);
  NODE_VERSIONS_KEYS(V)
#undef V

  std::sort(&versions_array[0],
            &versions_array[arraysize(versions_array)],
            [](auto& a, auto& b) { return a.first < b.first; });

  for (const auto& version : versions_array) {
    writer->json_keyvalue(version.first, version.second);
  }

  writer->json_objectend();
}",1,1,node_report.cc,node.report.PrintComponentVersions,,false,797,825,PrintComponentVersions,,,30,void node.report.PrintComponentVersions (JSONWriter*)
226282,METHOD,node_report.cc:<global>,TYPE_DECL,"static void PrintRelease(JSONWriter* writer) {
  writer->json_objectstart(""release"");
  writer->json_keyvalue(""name"", per_process::metadata.release.name);
#if NODE_VERSION_IS_LTS
  writer->json_keyvalue(""lts"", per_process::metadata.release.lts);
#endif

#ifdef NODE_HAS_RELEASE_URLS
  writer->json_keyvalue(""headersUrl"",
                        per_process::metadata.release.headers_url);
  writer->json_keyvalue(""sourceUrl"", per_process::metadata.release.source_url);
#ifdef _WIN32
  writer->json_keyvalue(""libUrl"", per_process::metadata.release.lib_url);
#endif  // _WIN32
#endif  // NODE_HAS_RELEASE_URLS

  writer->json_objectend();
}",1,1,node_report.cc,node.report.PrintRelease,,false,828,845,PrintRelease,,,31,void node.report.PrintRelease (JSONWriter*)
226308,METHOD,node_report.cc:<global>,TYPE_DECL,"std::string TriggerNodeReport(Isolate* isolate,
                              Environment* env,
                              const char* message,
                              const char* trigger,
                              const std::string& name,
                              Local<Value> error) {
  std::string filename;

  // Determine the required report filename. In order of priority:
  //   1) supplied on API 2) configured on startup 3) default generated
  if (!name.empty()) {
    THROW_IF_INSUFFICIENT_PERMISSIONS(
        env, permission::PermissionScope::kFileSystemWrite, name, name);
    // Filename was specified as API parameter.
    filename = name;
  } else {
    std::string report_filename;
    {
      Mutex::ScopedLock lock(per_process::cli_options_mutex);
      report_filename = per_process::cli_options->report_filename;
    }
    if (report_filename.length() > 0) {
      // File name was supplied via start-up option.
      filename = report_filename;
    } else {...",1,1,node_report.cc,node.TriggerNodeReport,,false,849,942,TriggerNodeReport,,,2,"string node.TriggerNodeReport (Isolate*,Environment*,char*,char*,ANY,Local<Value>)"
226605,METHOD,node_report.cc:<global>,TYPE_DECL,"std::string TriggerNodeReport(Isolate* isolate,
                              const char* message,
                              const char* trigger,
                              const std::string& name,
                              Local<Value> error) {
  Environment* env = nullptr;
  if (isolate != nullptr) {
    env = Environment::GetCurrent(isolate);
  }
  return TriggerNodeReport(isolate, env, message, trigger, name, error);
}",1,1,node_report.cc,node.TriggerNodeReport,,false,945,955,TriggerNodeReport,,,3,"string node.TriggerNodeReport (Isolate*,char*,char*,ANY,Local<Value>)"
226638,METHOD,node_report.cc:<global>,TYPE_DECL,"std::string TriggerNodeReport(Environment* env,
                              const char* message,
                              const char* trigger,
                              const std::string& name,
                              Local<Value> error) {
  return TriggerNodeReport(env != nullptr ? env->isolate() : nullptr,
                           env,
                           message,
                           trigger,
                           name,
                           error);
}",1,1,node_report.cc,node.TriggerNodeReport,,false,958,969,TriggerNodeReport,,,4,"string node.TriggerNodeReport (Environment*,char*,char*,ANY,Local<Value>)"
226663,METHOD,node_report.cc:<global>,TYPE_DECL,"void GetNodeReport(Isolate* isolate,
                   const char* message,
                   const char* trigger,
                   Local<Value> error,
                   std::ostream& out) {
  Environment* env = nullptr;
  if (isolate != nullptr) {
    env = Environment::GetCurrent(isolate);
  }
  report::WriteNodeReport(
      isolate, env, message, trigger, """", out, error, false);
}",1,1,node_report.cc,node.GetNodeReport,,false,972,983,GetNodeReport,,,5,"void node.GetNodeReport (Isolate*,char*,char*,Local<Value>,ANY)"
226700,METHOD,node_report.cc:<global>,TYPE_DECL,"void GetNodeReport(Environment* env,
                   const char* message,
                   const char* trigger,
                   Local<Value> error,
                   std::ostream& out) {
  Isolate* isolate = nullptr;
  if (env != nullptr) {
    isolate = env->isolate();
  }
  report::WriteNodeReport(
      isolate, env, message, trigger, """", out, error, false);
}",1,1,node_report.cc,node.GetNodeReport,,false,986,997,GetNodeReport,,,6,"void node.GetNodeReport (Environment*,char*,char*,Local<Value>,ANY)"
226755,METHOD,node_report.hpp:<global>,TYPE_DECL,<global>,1,29,node_report.hpp,node_report.hpp:<global>,,false,1,42,<global>,,,1,
226788,METHOD,node_report_module.cc:<global>,TYPE_DECL,<global>,1,21,env.hpp,node_report_module.cc:<global>,,false,1,222,<global>,,,1,
226792,METHOD,node_report_module.cc:<global>,TYPE_DECL,"void WriteReport(const FunctionCallbackInfo<Value>& info) {
  Environment* env = Environment::GetCurrent(info);
  Isolate* isolate = env->isolate();
  HandleScope scope(isolate);
  std::string filename;
  Local<Value> error;

  CHECK_EQ(info.Length(), 4);
  String::Utf8Value message(isolate, info[0].As<String>());
  String::Utf8Value trigger(isolate, info[1].As<String>());

  if (info[2]->IsString())
    filename = *String::Utf8Value(isolate, info[2]);
  if (!info[3].IsEmpty())
    error = info[3];
  else
    error = Local<Value>();

  filename = TriggerNodeReport(env, *message, *trigger, filename, error);
  // Return value is the report filename
  info.GetReturnValue().Set(
      String::NewFromUtf8(isolate, filename.c_str()).ToLocalChecked());
}",1,1,node_report_module.cc,node.report.WriteReport,,false,29,51,WriteReport,,,1,void node.report.WriteReport (FunctionCallbackInfo<Value>)
226912,METHOD,node_report_module.cc:<global>,TYPE_DECL,"void GetReport(const FunctionCallbackInfo<Value>& info) {
  Environment* env = Environment::GetCurrent(info);
  Isolate* isolate = env->isolate();
  HandleScope scope(isolate);
  Local<Object> error;
  std::ostringstream out;

  CHECK_EQ(info.Length(), 1);
  if (!info[0].IsEmpty() && info[0]->IsObject())
    error = info[0].As<Object>();
  else
    error = Local<Object>();

  GetNodeReport(env, ""JavaScript API"", __func__, error, out);

  // Return value is the contents of a report as a string.
  info.GetReturnValue().Set(
      String::NewFromUtf8(isolate, out.str().c_str()).ToLocalChecked());
}",1,1,node_report_module.cc,node.report.GetReport,,false,54,72,GetReport,,,2,void node.report.GetReport (FunctionCallbackInfo<Value>)
227004,METHOD,node_report_module.cc:<global>,TYPE_DECL,"static void GetCompact(const FunctionCallbackInfo<Value>& info) {
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  info.GetReturnValue().Set(per_process::cli_options->report_compact);
}",1,1,node_report_module.cc,node.report.GetCompact,,false,74,77,GetCompact,,,3,void node.report.GetCompact (FunctionCallbackInfo<Value>)
227026,METHOD,node_report_module.cc:<global>,TYPE_DECL,"static void SetCompact(const FunctionCallbackInfo<Value>& info) {
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Environment* env = Environment::GetCurrent(info);
  Isolate* isolate = env->isolate();
  bool compact = info[0]->ToBoolean(isolate)->Value();
  per_process::cli_options->report_compact = compact;
}",1,1,node_report_module.cc,node.report.SetCompact,,false,79,85,SetCompact,,,4,void node.report.SetCompact (FunctionCallbackInfo<Value>)
227071,METHOD,node_report_module.cc:<global>,TYPE_DECL,"static void GetDirectory(const FunctionCallbackInfo<Value>& info) {
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Environment* env = Environment::GetCurrent(info);
  std::string directory = per_process::cli_options->report_directory;
  auto result = String::NewFromUtf8(env->isolate(), directory.c_str());
  info.GetReturnValue().Set(result.ToLocalChecked());
}",1,1,node_report_module.cc,node.report.GetDirectory,,false,87,93,GetDirectory,,,5,void node.report.GetDirectory (FunctionCallbackInfo<Value>)
227123,METHOD,node_report_module.cc:<global>,TYPE_DECL,"static void SetDirectory(const FunctionCallbackInfo<Value>& info) {
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Environment* env = Environment::GetCurrent(info);
  CHECK(info[0]->IsString());
  Utf8Value dir(env->isolate(), info[0].As<String>());
  per_process::cli_options->report_directory = *dir;
}",1,1,node_report_module.cc,node.report.SetDirectory,,false,95,101,SetDirectory,,,6,void node.report.SetDirectory (FunctionCallbackInfo<Value>)
227168,METHOD,node_report_module.cc:<global>,TYPE_DECL,"static void GetFilename(const FunctionCallbackInfo<Value>& info) {
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Environment* env = Environment::GetCurrent(info);
  std::string filename = per_process::cli_options->report_filename;
  auto result = String::NewFromUtf8(env->isolate(), filename.c_str());
  info.GetReturnValue().Set(result.ToLocalChecked());
}",1,1,node_report_module.cc,node.report.GetFilename,,false,103,109,GetFilename,,,7,void node.report.GetFilename (FunctionCallbackInfo<Value>)
227220,METHOD,node_report_module.cc:<global>,TYPE_DECL,"static void SetFilename(const FunctionCallbackInfo<Value>& info) {
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Environment* env = Environment::GetCurrent(info);
  CHECK(info[0]->IsString());
  Utf8Value name(env->isolate(), info[0].As<String>());
  per_process::cli_options->report_filename = *name;
}",1,1,node_report_module.cc,node.report.SetFilename,,false,111,117,SetFilename,,,8,void node.report.SetFilename (FunctionCallbackInfo<Value>)
227265,METHOD,node_report_module.cc:<global>,TYPE_DECL,"static void GetSignal(const FunctionCallbackInfo<Value>& info) {
  Environment* env = Environment::GetCurrent(info);
  std::string signal = env->isolate_data()->options()->report_signal;
  auto result = String::NewFromUtf8(env->isolate(), signal.c_str());
  info.GetReturnValue().Set(result.ToLocalChecked());
}",1,1,node_report_module.cc,node.report.GetSignal,,false,119,124,GetSignal,,,9,void node.report.GetSignal (FunctionCallbackInfo<Value>)
227316,METHOD,node_report_module.cc:<global>,TYPE_DECL,"static void SetSignal(const FunctionCallbackInfo<Value>& info) {
  Environment* env = Environment::GetCurrent(info);
  CHECK(info[0]->IsString());
  Utf8Value signal(env->isolate(), info[0].As<String>());
  env->isolate_data()->options()->report_signal = *signal;
}",1,1,node_report_module.cc,node.report.SetSignal,,false,126,131,SetSignal,,,10,void node.report.SetSignal (FunctionCallbackInfo<Value>)
227360,METHOD,node_report_module.cc:<global>,TYPE_DECL,"static void ShouldReportOnFatalError(const FunctionCallbackInfo<Value>& info) {
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  info.GetReturnValue().Set(per_process::cli_options->report_on_fatalerror);
}",1,1,node_report_module.cc,node.report.ShouldReportOnFatalError,,false,133,136,ShouldReportOnFatalError,,,11,void node.report.ShouldReportOnFatalError (FunctionCallbackInfo<Value>)
227382,METHOD,node_report_module.cc:<global>,TYPE_DECL,"static void SetReportOnFatalError(const FunctionCallbackInfo<Value>& info) {
  CHECK(info[0]->IsBoolean());
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  per_process::cli_options->report_on_fatalerror = info[0]->IsTrue();
}",1,1,node_report_module.cc,node.report.SetReportOnFatalError,,false,138,142,SetReportOnFatalError,,,12,void node.report.SetReportOnFatalError (FunctionCallbackInfo<Value>)
227411,METHOD,node_report_module.cc:<global>,TYPE_DECL,"static void ShouldReportOnSignal(const FunctionCallbackInfo<Value>& info) {
  Environment* env = Environment::GetCurrent(info);
  info.GetReturnValue().Set(env->isolate_data()->options()->report_on_signal);
}",1,1,node_report_module.cc,node.report.ShouldReportOnSignal,,false,144,147,ShouldReportOnSignal,,,13,void node.report.ShouldReportOnSignal (FunctionCallbackInfo<Value>)
227440,METHOD,node_report_module.cc:<global>,TYPE_DECL,"static void SetReportOnSignal(const FunctionCallbackInfo<Value>& info) {
  Environment* env = Environment::GetCurrent(info);
  CHECK(info[0]->IsBoolean());
  env->isolate_data()->options()->report_on_signal = info[0]->IsTrue();
}",1,1,node_report_module.cc,node.report.SetReportOnSignal,,false,149,153,SetReportOnSignal,,,14,void node.report.SetReportOnSignal (FunctionCallbackInfo<Value>)
227476,METHOD,node_report_module.cc:<global>,TYPE_DECL,"static void ShouldReportOnUncaughtException(
    const FunctionCallbackInfo<Value>& info) {
  Environment* env = Environment::GetCurrent(info);
  info.GetReturnValue().Set(
      env->isolate_data()->options()->report_uncaught_exception);
}",1,1,node_report_module.cc,node.report.ShouldReportOnUncaughtException,,false,155,160,ShouldReportOnUncaughtException,,,15,void node.report.ShouldReportOnUncaughtException (FunctionCallbackInfo<Value>)
227505,METHOD,node_report_module.cc:<global>,TYPE_DECL,"static void SetReportOnUncaughtException(
    const FunctionCallbackInfo<Value>& info) {
  Environment* env = Environment::GetCurrent(info);
  CHECK(info[0]->IsBoolean());
  env->isolate_data()->options()->report_uncaught_exception = info[0]->IsTrue();
}",1,1,node_report_module.cc,node.report.SetReportOnUncaughtException,,false,162,167,SetReportOnUncaughtException,,,16,void node.report.SetReportOnUncaughtException (FunctionCallbackInfo<Value>)
227541,METHOD,node_report_module.cc:<global>,TYPE_DECL,"static void Initialize(Local<Object> exports,
                       Local<Value> unused,
                       Local<Context> context,
                       void* priv) {
  SetMethod(context, exports, ""writeReport"", WriteReport);
  SetMethod(context, exports, ""getReport"", GetReport);
  SetMethod(context, exports, ""getCompact"", GetCompact);
  SetMethod(context, exports, ""setCompact"", SetCompact);
  SetMethod(context, exports, ""getDirectory"", GetDirectory);
  SetMethod(context, exports, ""setDirectory"", SetDirectory);
  SetMethod(context, exports, ""getFilename"", GetFilename);
  SetMethod(context, exports, ""setFilename"", SetFilename);
  SetMethod(context, exports, ""getSignal"", GetSignal);
  SetMethod(context, exports, ""setSignal"", SetSignal);
  SetMethod(
      context, exports, ""shouldReportOnFatalError"", ShouldReportOnFatalError);
  SetMethod(context, exports, ""setReportOnFatalError"", SetReportOnFatalError);
  SetMethod(context, exports, ""shouldReportOnSignal"", ShouldReportOnSignal...",1,1,node_report_module.cc,node.report.Initialize,,false,169,196,Initialize,,,17,"void node.report.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
227629,METHOD,node_report_module.cc:<global>,TYPE_DECL,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(WriteReport);
  registry->Register(GetReport);
  registry->Register(GetCompact);
  registry->Register(SetCompact);
  registry->Register(GetDirectory);
  registry->Register(SetDirectory);
  registry->Register(GetFilename);
  registry->Register(SetFilename);
  registry->Register(GetSignal);
  registry->Register(SetSignal);
  registry->Register(ShouldReportOnFatalError);
  registry->Register(SetReportOnFatalError);
  registry->Register(ShouldReportOnSignal);
  registry->Register(SetReportOnSignal);
  registry->Register(ShouldReportOnUncaughtException);
  registry->Register(SetReportOnUncaughtException);
}",1,1,node_report_module.cc,node.report.RegisterExternalReferences,,false,198,215,RegisterExternalReferences,,,18,void node.report.RegisterExternalReferences (ExternalReferenceRegistry*)
227726,METHOD,node_report_utils.cc:<global>,TYPE_DECL,<global>,1,28,json_utils.hpp,node_report_utils.cc:<global>,,false,1,272,<global>,,,1,
227735,METHOD,node_report_utils.cc:<global>,TYPE_DECL,"static void ReportEndpoint(uv_handle_t* h,
                           struct sockaddr* addr,
                           const char* name,
                           JSONWriter* writer) {
  if (addr == nullptr) {
    writer->json_keyvalue(name, null);
    return;
  }

  uv_getnameinfo_t endpoint;
  char* host = nullptr;
  char hostbuf[INET6_ADDRSTRLEN];
  const int family = addr->sa_family;
  const int port = ntohs(family == AF_INET ?
                         reinterpret_cast<sockaddr_in*>(addr)->sin_port :
                         reinterpret_cast<sockaddr_in6*>(addr)->sin6_port);

  if (uv_getnameinfo(h->loop, &endpoint, nullptr, addr, NI_NUMERICSERV) == 0) {
    host = endpoint.host;
    DCHECK_EQ(port, std::stoi(endpoint.service));
  } else {
    const void* src = family == AF_INET ?
                      static_cast<void*>(
                        &(reinterpret_cast<sockaddr_in*>(addr)->sin_addr)) :
                      static_cast<void*>(
                        &(reinterpret_...",1,1,node_report_utils.cc,node.report.ReportEndpoint,,false,12,48,ReportEndpoint,,,3,"void node.report.ReportEndpoint (uv_handle_t*,sockaddr*,char*,JSONWriter*)"
227876,METHOD,node_report_utils.cc:<global>,TYPE_DECL,"static void ReportEndpoints(uv_handle_t* h, JSONWriter* writer) {
  struct sockaddr_storage addr_storage;
  struct sockaddr* addr = reinterpret_cast<sockaddr*>(&addr_storage);
  uv_any_handle* handle = reinterpret_cast<uv_any_handle*>(h);
  int addr_size = sizeof(addr_storage);
  int rc = -1;

  switch (h->type) {
    case UV_UDP:
      rc = uv_udp_getsockname(&handle->udp, addr, &addr_size);
      break;
    case UV_TCP:
      rc = uv_tcp_getsockname(&handle->tcp, addr, &addr_size);
      break;
    default:
      break;
  }
  ReportEndpoint(h, rc == 0 ? addr : nullptr,  ""localEndpoint"", writer);

  switch (h->type) {
    case UV_UDP:
      rc = uv_udp_getpeername(&handle->udp, addr, &addr_size);
      break;
    case UV_TCP:
      rc = uv_tcp_getpeername(&handle->tcp, addr, &addr_size);
      break;
    default:
      break;
  }
  ReportEndpoint(h, rc == 0 ? addr : nullptr, ""remoteEndpoint"", writer);
}",1,1,node_report_utils.cc,node.report.ReportEndpoints,,false,51,81,ReportEndpoints,,,4,"void node.report.ReportEndpoints (uv_handle_t*,JSONWriter*)"
227992,METHOD,node_report_utils.cc:<global>,TYPE_DECL,"static void ReportPipeEndpoints(uv_handle_t* h, JSONWriter* writer) {
  uv_any_handle* handle = reinterpret_cast<uv_any_handle*>(h);
  MaybeStackBuffer<char> buffer;
  size_t buffer_size = buffer.capacity();
  int rc = -1;

  // First call to get required buffer size.
  rc = uv_pipe_getsockname(&handle->pipe, buffer.out(), &buffer_size);
  if (rc == UV_ENOBUFS) {
    buffer.AllocateSufficientStorage(buffer_size);
    rc = uv_pipe_getsockname(&handle->pipe, buffer.out(), &buffer_size);
  }
  if (rc == 0 && buffer_size != 0) {
    buffer.SetLength(buffer_size);
    writer->json_keyvalue(""localEndpoint"", buffer.ToStringView());
  } else {
    writer->json_keyvalue(""localEndpoint"", null);
  }

  // First call to get required buffer size.
  buffer_size = buffer.capacity();
  rc = uv_pipe_getpeername(&handle->pipe, buffer.out(), &buffer_size);
  if (rc == UV_ENOBUFS) {
    buffer.AllocateSufficientStorage(buffer_size);
    rc = uv_pipe_getpeername(&handle->pipe, buffer.out(), &buffer_size...",1,1,node_report_utils.cc,node.report.ReportPipeEndpoints,,false,84,116,ReportPipeEndpoints,,,5,"void node.report.ReportPipeEndpoints (uv_handle_t*,JSONWriter*)"
228157,METHOD,node_report_utils.cc:<global>,TYPE_DECL,"static void ReportPath(uv_handle_t* h, JSONWriter* writer) {
  MaybeStackBuffer<char> buffer;
  int rc = -1;
  size_t size = buffer.capacity();
  uv_any_handle* handle = reinterpret_cast<uv_any_handle*>(h);
  // First call to get required buffer size.
  switch (h->type) {
    case UV_FS_EVENT:
      rc = uv_fs_event_getpath(&(handle->fs_event), buffer.out(), &size);
      break;
    case UV_FS_POLL:
      rc = uv_fs_poll_getpath(&(handle->fs_poll), buffer.out(), &size);
      break;
    default:
      break;
  }
  if (rc == UV_ENOBUFS) {
    buffer.AllocateSufficientStorage(size);
    switch (h->type) {
      case UV_FS_EVENT:
        rc = uv_fs_event_getpath(&(handle->fs_event), buffer.out(), &size);
        break;
      case UV_FS_POLL:
        rc = uv_fs_poll_getpath(&(handle->fs_poll), buffer.out(), &size);
        break;
      default:
        break;
    }
  }

  if (rc == 0 && size > 0) {
    buffer.SetLength(size);
    writer->json_keyvalue(""filename"", buffer.ToStringView());...",1,1,node_report_utils.cc,node.report.ReportPath,,false,119,155,ReportPath,,,6,"void node.report.ReportPath (uv_handle_t*,JSONWriter*)"
228301,METHOD,node_report_utils.cc:<global>,TYPE_DECL,"void WalkHandle(uv_handle_t* h, void* arg) {
  const char* type = uv_handle_type_name(h->type);
  JSONWriter* writer = static_cast<JSONWriter*>(arg);
  uv_any_handle* handle = reinterpret_cast<uv_any_handle*>(h);

  writer->json_start();
  writer->json_keyvalue(""type"", type);
  writer->json_keyvalue(""is_active"", static_cast<bool>(uv_is_active(h)));
  writer->json_keyvalue(""is_referenced"", static_cast<bool>(uv_has_ref(h)));
  writer->json_keyvalue(""address"",
                        ValueToHexString(reinterpret_cast<uint64_t>(h)));

  switch (h->type) {
    case UV_FS_EVENT:
    case UV_FS_POLL:
      ReportPath(h, writer);
      break;
    case UV_PROCESS:
      writer->json_keyvalue(""pid"", handle->process.pid);
      break;
    case UV_TCP:
    case UV_UDP:
      ReportEndpoints(h, writer);
      break;
    case UV_NAMED_PIPE:
      ReportPipeEndpoints(h, writer);
      break;
    case UV_TIMER: {
      uint64_t due = handle->timer.timeout;
      uint64_t now = uv_now(handle->timer....",1,1,node_report_utils.cc,node.report.WalkHandle,,false,158,269,WalkHandle,,,7,"void node.report.WalkHandle (uv_handle_t*,void*)"
228731,METHOD,node_revert.hpp:<global>,TYPE_DECL,<global>,1,29,node_revert.hpp,node_revert.hpp:<global>,,false,1,82,<global>,,,1,
228736,METHOD,node_root_certs.hpp:<global>,TYPE_DECL,<global>,1,62,node_root_certs.hpp,node_root_certs.hpp:<global>,,false,1,3411,<global>,,,1,
228739,METHOD,node_sea.cc:<global>,TYPE_DECL,"[]() -> std::string_view {
    size_t size;
#ifdef __APPLE__
    postject_options options;
    postject_options_init(&options);
    options.macho_segment_name = ""NODE_SEA"";
    const char* blob = static_cast<const char*>(
        postject_find_resource(""NODE_SEA_BLOB"", &size, &options));
#else
    const char* blob = static_cast<const char*>(
        postject_find_resource(""NODE_SEA_BLOB"", &size, nullptr));
#endif
    return {blob, size};
  }",42,3,node_sea.cc,node.sea.anonymous_namespace_13.FindSingleExecutableBlob.<lambda>0,,false,113,126,<lambda>0,,,1,string_view node.sea.anonymous_namespace_13.FindSingleExecutableBlob.<lambda>0 ()
228757,METHOD,node_sea.cc:<global>,TYPE_DECL,"[]() -> SeaResource {
    std::string_view blob = FindSingleExecutableBlob();
    per_process::Debug(DebugCategory::SEA,
                       ""Found SEA resource %p, size=%zu\n"",
                       blob.data(),
                       blob.size());
    SeaDeserializer deserializer(blob);
    return deserializer.Read<SeaResource>();
  }",43,3,node_sea.cc,node.sea.FindSingleExecutableResource.<lambda>1,,false,137,145,<lambda>1,,,1,SeaResource node.sea.FindSingleExecutableResource.<lambda>1 ()
228817,METHOD,node_sea.cc:<global>,TYPE_DECL,<global>,1,26,node_sea.hpp,node_sea.cc:<global>,,false,1,303,<global>,,,1,
228822,METHOD,node_sea.cc:<global>,TYPE_DECL,"SeaFlags operator|(SeaFlags x, SeaFlags y) {
  return static_cast<SeaFlags>(static_cast<uint32_t>(x) |
                               static_cast<uint32_t>(y));
}",1,1,node_sea.cc,node.sea.anonymous_namespace_1.operator |,,false,39,42,operator |,,,1,"SeaFlags node.sea.anonymous_namespace_1.operator | (SeaFlags,SeaFlags)"
228838,METHOD,node_sea.cc:<global>,TYPE_DECL,"SeaFlags operator&(SeaFlags x, SeaFlags y) {
  return static_cast<SeaFlags>(static_cast<uint32_t>(x) &
                               static_cast<uint32_t>(y));
}",1,1,node_sea.cc,node.sea.anonymous_namespace_2.operator &,,false,44,47,operator &,,,2,"SeaFlags node.sea.anonymous_namespace_2.operator & (SeaFlags,SeaFlags)"
228854,METHOD,node_sea.cc:<global>,TYPE_DECL,"SeaFlags operator|=(/* NOLINT (runtime/references) */ SeaFlags& x, SeaFlags y) {
  return x = x | y;
}",1,1,node_sea.cc,node.sea.anonymous_namespace_3.operator |=,,false,49,51,operator |=,,,3,"SeaFlags node.sea.anonymous_namespace_3.operator |= (SeaFlags,SeaFlags)"
228867,METHOD,node.sea.anonymous_namespace_4.SeaSerializer,TYPE_DECL,"SeaSerializer()
      : BlobSerializer<SeaSerializer>(
            per_process::enabled_debug_list.enabled(DebugCategory::SEA)) {}",3,75,node_sea.cc,node.sea.anonymous_namespace_5.SeaSerializer.SeaSerializer,,false,55,57,SeaSerializer,,,1,ANY node.sea.anonymous_namespace_5.SeaSerializer.SeaSerializer ()
228871,METHOD,node.sea.anonymous_namespace_4.SeaSerializer,TYPE_DECL,size_t Write(const T& data);,10,29,node_sea.cc,node.sea.anonymous_namespace_6.SeaSerializer.Write,,false,62,62,Write,,,2,"size_t node.sea.anonymous_namespace_6.SeaSerializer.Write<T,std::enable_if_t<!std::is_same<T,std::string>::value>*=nullptr,std::enable_if_t<!std::is_arithmetic<T>::value>*=nullptr> (T)"
228876,METHOD,node_sea.cc:<global>,TYPE_DECL,"size_t SeaSerializer::Write(const SeaResource& sea) {
  sink.reserve(SeaResource::kHeaderSize + sea.code.size());

  Debug(""Write SEA magic %x\n"", kMagic);
  size_t written_total = WriteArithmetic<uint32_t>(kMagic);

  uint32_t flags = static_cast<uint32_t>(sea.flags);
  Debug(""Write SEA flags %x\n"", flags);
  written_total += WriteArithmetic<uint32_t>(flags);
  DCHECK_EQ(written_total, SeaResource::kHeaderSize);

  Debug(""Write SEA resource code %p, size=%zu\n"",
        sea.code.data(),
        sea.code.size());
  written_total += WriteStringView(sea.code, StringLogMode::kAddressAndContent);
  return written_total;
}",1,1,node_sea.cc,node.sea.anonymous_namespace_7.SeaSerializer.Write,,false,66,82,Write,,,5,size_t node.sea.anonymous_namespace_7.SeaSerializer.Write<> (SeaResource)
228955,METHOD,node.sea.anonymous_namespace_8.SeaDeserializer,TYPE_DECL,"explicit SeaDeserializer(std::string_view v)
      : BlobDeserializer<SeaDeserializer>(
            per_process::enabled_debug_list.enabled(DebugCategory::SEA), v) {}",3,78,node_sea.cc,node.sea.anonymous_namespace_9.SeaDeserializer.SeaDeserializer,,false,86,88,SeaDeserializer,,,1,ANY node.sea.anonymous_namespace_9.SeaDeserializer.SeaDeserializer (ANY)
228960,METHOD,node.sea.anonymous_namespace_8.SeaDeserializer,TYPE_DECL,T Read();,5,10,node_sea.cc,node.sea.anonymous_namespace_10.SeaDeserializer.Read,,false,93,93,Read,,,2,"T node.sea.anonymous_namespace_10.SeaDeserializer.Read<T,std::enable_if_t<!std::is_same<T,std::string>::value>*=nullptr,std::enable_if_t<!std::is_arithmetic<T>::value>*=nullptr> ()"
228964,METHOD,node_sea.cc:<global>,TYPE_DECL,"SeaResource SeaDeserializer::Read() {
  uint32_t magic = ReadArithmetic<uint32_t>();
  Debug(""Read SEA magic %x\n"", magic);

  CHECK_EQ(magic, kMagic);
  SeaFlags flags(static_cast<SeaFlags>(ReadArithmetic<uint32_t>()));
  Debug(""Read SEA flags %x\n"", static_cast<uint32_t>(flags));
  CHECK_EQ(read_total, SeaResource::kHeaderSize);

  std::string_view code = ReadStringView(StringLogMode::kAddressAndContent);
  Debug(""Read SEA resource code %p, size=%zu\n"", code.data(), code.size());
  return {flags, code};
}",1,1,node_sea.cc,node.sea.anonymous_namespace_11.SeaDeserializer.Read,,false,97,109,Read,,,7,SeaResource node.sea.anonymous_namespace_11.SeaDeserializer.Read<> ()
229011,METHOD,node_sea.cc:<global>,TYPE_DECL,"std::string_view FindSingleExecutableBlob() {
  CHECK(IsSingleExecutable());
  static const std::string_view result = []() -> std::string_view {
    size_t size;
#ifdef __APPLE__
    postject_options options;
    postject_options_init(&options);
    options.macho_segment_name = ""NODE_SEA"";
    const char* blob = static_cast<const char*>(
        postject_find_resource(""NODE_SEA_BLOB"", &size, &options));
#else
    const char* blob = static_cast<const char*>(
        postject_find_resource(""NODE_SEA_BLOB"", &size, nullptr));
#endif
    return {blob, size};
  }();
  per_process::Debug(DebugCategory::SEA,
                     ""Found SEA blob %p, size=%zu\n"",
                     result.data(),
                     result.size());
  return result;
}",1,1,node_sea.cc,node.sea.anonymous_namespace_12.FindSingleExecutableBlob,,false,111,132,FindSingleExecutableBlob,,,8,string_view node.sea.anonymous_namespace_12.FindSingleExecutableBlob ()
229039,METHOD,node_sea.cc:<global>,TYPE_DECL,"SeaResource FindSingleExecutableResource() {
  static const SeaResource sea_resource = []() -> SeaResource {
    std::string_view blob = FindSingleExecutableBlob();
    per_process::Debug(DebugCategory::SEA,
                       ""Found SEA resource %p, size=%zu\n"",
                       blob.data(),
                       blob.size());
    SeaDeserializer deserializer(blob);
    return deserializer.Read<SeaResource>();
  }();
  return sea_resource;
}",1,1,node_sea.cc,node.sea.FindSingleExecutableResource,,false,136,147,FindSingleExecutableResource,,,2,SeaResource node.sea.FindSingleExecutableResource ()
229050,METHOD,node_sea.cc:<global>,TYPE_DECL,"bool IsSingleExecutable() {
  return postject_has_resource();
}",1,1,node_sea.cc,node.sea.IsSingleExecutable,,false,149,151,IsSingleExecutable,,,3,bool node.sea.IsSingleExecutable ()
229056,METHOD,node_sea.cc:<global>,TYPE_DECL,"void IsExperimentalSeaWarningNeeded(const FunctionCallbackInfo<Value>& args) {
  if (!IsSingleExecutable()) {
    args.GetReturnValue().Set(false);
    return;
  }

  SeaResource sea_resource = FindSingleExecutableResource();
  args.GetReturnValue().Set(!static_cast<bool>(
      sea_resource.flags & SeaFlags::kDisableExperimentalSeaWarning));
}",1,1,node_sea.cc,node.sea.IsExperimentalSeaWarningNeeded,,false,153,162,IsExperimentalSeaWarningNeeded,,,4,void node.sea.IsExperimentalSeaWarningNeeded (FunctionCallbackInfo<Value>)
229095,METHOD,node_sea.cc:<global>,TYPE_DECL,"std::tuple<int, char**> FixupArgsForSEA(int argc, char** argv) {
  // Repeats argv[0] at position 1 on argv as a replacement for the missing
  // entry point file path.
  if (IsSingleExecutable()) {
    static std::vector<char*> new_argv;
    new_argv.reserve(argc + 2);
    new_argv.emplace_back(argv[0]);
    new_argv.insert(new_argv.end(), argv, argv + argc);
    new_argv.emplace_back(nullptr);
    argc = new_argv.size() - 1;
    argv = new_argv.data();
  }

  return {argc, argv};
}",1,1,node_sea.cc,node.sea.FixupArgsForSEA,,false,164,178,FixupArgsForSEA,,,5,"tuple<int,char **> node.sea.FixupArgsForSEA (int,char**)"
229156,METHOD,<empty>,<empty>,<empty>,1,,node_sea.cc,node.sea.anonymous_namespace_16.SeaConfig:<clinit>,,false,182,,<clinit>,,,4,
229165,METHOD,node_sea.cc:<global>,TYPE_DECL,"std::optional<SeaConfig> ParseSingleExecutableConfig(
    const std::string& config_path) {
  std::string config;
  int r = ReadFileSync(&config, config_path.c_str());
  if (r != 0) {
    const char* err = uv_strerror(r);
    FPrintF(stderr,
            ""Cannot read single executable configuration from %s: %s\n"",
            config_path,
            err);
    return std::nullopt;
  }

  SeaConfig result;
  JSONParser parser;
  if (!parser.Parse(config)) {
    FPrintF(stderr, ""Cannot parse JSON from %s\n"", config_path);
    return std::nullopt;
  }

  result.main_path =
      parser.GetTopLevelStringField(""main"").value_or(std::string());
  if (result.main_path.empty()) {
    FPrintF(stderr,
            ""\""main\"" field of %s is not a non-empty string\n"",
            config_path);
    return std::nullopt;
  }

  result.output_path =
      parser.GetTopLevelStringField(""output"").value_or(std::string());
  if (result.output_path.empty()) {
    FPrintF(stderr,
            ""\""output\"" fiel...",1,1,node_sea.cc,node.sea.anonymous_namespace_17.ParseSingleExecutableConfig,,false,188,239,ParseSingleExecutableConfig,,,2,optional<SeaConfig> node.sea.anonymous_namespace_17.ParseSingleExecutableConfig (ANY)
229320,METHOD,node_sea.cc:<global>,TYPE_DECL,"ExitCode GenerateSingleExecutableBlob(const SeaConfig& config) {
  std::string main_script;
  // TODO(joyeecheung): unify the file utils.
  int r = ReadFileSync(&main_script, config.main_path.c_str());
  if (r != 0) {
    const char* err = uv_strerror(r);
    FPrintF(stderr, ""Cannot read main script %s:%s\n"", config.main_path, err);
    return ExitCode::kGenericUserError;
  }

  SeaResource sea{config.flags, main_script};

  SeaSerializer serializer;
  serializer.Write(sea);

  uv_buf_t buf = uv_buf_init(serializer.sink.data(), serializer.sink.size());
  r = WriteFileSync(config.output_path.c_str(), buf);
  if (r != 0) {
    const char* err = uv_strerror(r);
    FPrintF(stderr, ""Cannot write output to %s:%s\n"", config.output_path, err);
    return ExitCode::kGenericUserError;
  }

  FPrintF(stderr,
          ""Wrote single executable preparation blob to %s\n"",
          config.output_path);
  return ExitCode::kNoFailure;
}",1,1,node_sea.cc,node.sea.anonymous_namespace_18.GenerateSingleExecutableBlob,,false,241,268,GenerateSingleExecutableBlob,,,3,ExitCode node.sea.anonymous_namespace_18.GenerateSingleExecutableBlob (SeaConfig)
229430,METHOD,node_sea.cc:<global>,TYPE_DECL,"ExitCode BuildSingleExecutableBlob(const std::string& config_path) {
  std::optional<SeaConfig> config_opt =
      ParseSingleExecutableConfig(config_path);
  if (config_opt.has_value()) {
    ExitCode code = GenerateSingleExecutableBlob(config_opt.value());
    return code;
  }

  return ExitCode::kGenericUserError;
}",1,1,node_sea.cc,node.sea.BuildSingleExecutableBlob,,false,272,281,BuildSingleExecutableBlob,,,7,ExitCode node.sea.BuildSingleExecutableBlob (ANY)
229460,METHOD,node_sea.cc:<global>,TYPE_DECL,"void Initialize(Local<Object> target,
                Local<Value> unused,
                Local<Context> context,
                void* priv) {
  SetMethod(context,
            target,
            ""isExperimentalSeaWarningNeeded"",
            IsExperimentalSeaWarningNeeded);
}",1,1,node_sea.cc,node.sea.Initialize,,false,283,291,Initialize,,,8,"void node.sea.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
229473,METHOD,node_sea.cc:<global>,TYPE_DECL,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(IsExperimentalSeaWarningNeeded);
}",1,1,node_sea.cc,node.sea.RegisterExternalReferences,,false,293,295,RegisterExternalReferences,,,9,void node.sea.RegisterExternalReferences (ExternalReferenceRegistry*)
229495,METHOD,node_sea.hpp:<global>,TYPE_DECL,<global>,1,26,node_sea.hpp,node_sea.hpp:<global>,,false,1,44,<global>,,,1,
229512,METHOD,node_serdes.cc:<global>,TYPE_DECL,<global>,1,33,base_object-inl.hpp,node_serdes.cc:<global>,,false,1,543,<global>,,,1,
229517,METHOD,node.serdes.SerializerContext,TYPE_DECL,"SerializerContext(Environment* env,
                    Local<Object> wrap);",3,39,node_serdes.cc,node.serdes.SerializerContext.SerializerContext,,false,35,36,SerializerContext,,,1,"ANY node.serdes.SerializerContext.SerializerContext (Environment*,Local<Object>)"
229523,METHOD,node.serdes.SerializerContext,TYPE_DECL,~SerializerContext() override = default;,3,42,node_serdes.cc,node.serdes.SerializerContext.~SerializerContext,,false,38,38,~SerializerContext,,,2,ANY node.serdes.SerializerContext.~SerializerContext ()
229527,METHOD,node.serdes.SerializerContext,TYPE_DECL,void ThrowDataCloneError(Local<String> message) override;,8,58,node_serdes.cc,node.serdes.SerializerContext.ThrowDataCloneError,,false,40,40,ThrowDataCloneError,,,3,void node.serdes.SerializerContext.ThrowDataCloneError (Local<String>)
229532,METHOD,node.serdes.SerializerContext,TYPE_DECL,"Maybe<bool> WriteHostObject(Isolate* isolate, Local<Object> object) override;",15,78,node_serdes.cc,node.serdes.SerializerContext.WriteHostObject,,false,41,41,WriteHostObject,,,4,"Maybe<bool> node.serdes.SerializerContext.WriteHostObject (Isolate*,Local<Object>)"
229538,METHOD,node.serdes.SerializerContext,TYPE_DECL,"Maybe<uint32_t> GetSharedArrayBufferId(
      Isolate* isolate, Local<SharedArrayBuffer> shared_array_buffer) override;",19,78,node_serdes.cc,node.serdes.SerializerContext.GetSharedArrayBufferId,,false,42,43,GetSharedArrayBufferId,,,5,"Maybe<uint32_t> node.serdes.SerializerContext.GetSharedArrayBufferId (Isolate*,Local<SharedArrayBuffer>)"
229544,METHOD,node.serdes.SerializerContext,TYPE_DECL,"static void SetTreatArrayBufferViewsAsHostObjects(
      const FunctionCallbackInfo<Value>& args);",15,46,node_serdes.cc,node.serdes.SerializerContext.SetTreatArrayBufferViewsAsHostObjects,,false,45,46,SetTreatArrayBufferViewsAsHostObjects,,,6,void node.serdes.SerializerContext.SetTreatArrayBufferViewsAsHostObjects (FunctionCallbackInfo<Value>)
229549,METHOD,node.serdes.SerializerContext,TYPE_DECL,static void New(const FunctionCallbackInfo<Value>& args);,15,58,node_serdes.cc,node.serdes.SerializerContext.New,,false,48,48,New,,,7,void node.serdes.SerializerContext.New (FunctionCallbackInfo<Value>)
229554,METHOD,node.serdes.SerializerContext,TYPE_DECL,static void WriteHeader(const FunctionCallbackInfo<Value>& args);,15,66,node_serdes.cc,node.serdes.SerializerContext.WriteHeader,,false,49,49,WriteHeader,,,8,void node.serdes.SerializerContext.WriteHeader (FunctionCallbackInfo<Value>)
229559,METHOD,node.serdes.SerializerContext,TYPE_DECL,static void WriteValue(const FunctionCallbackInfo<Value>& args);,15,65,node_serdes.cc,node.serdes.SerializerContext.WriteValue,,false,50,50,WriteValue,,,9,void node.serdes.SerializerContext.WriteValue (FunctionCallbackInfo<Value>)
229564,METHOD,node.serdes.SerializerContext,TYPE_DECL,static void ReleaseBuffer(const FunctionCallbackInfo<Value>& args);,15,68,node_serdes.cc,node.serdes.SerializerContext.ReleaseBuffer,,false,51,51,ReleaseBuffer,,,10,void node.serdes.SerializerContext.ReleaseBuffer (FunctionCallbackInfo<Value>)
229569,METHOD,node.serdes.SerializerContext,TYPE_DECL,static void TransferArrayBuffer(const FunctionCallbackInfo<Value>& args);,15,74,node_serdes.cc,node.serdes.SerializerContext.TransferArrayBuffer,,false,52,52,TransferArrayBuffer,,,11,void node.serdes.SerializerContext.TransferArrayBuffer (FunctionCallbackInfo<Value>)
229574,METHOD,node.serdes.SerializerContext,TYPE_DECL,static void WriteUint32(const FunctionCallbackInfo<Value>& args);,15,66,node_serdes.cc,node.serdes.SerializerContext.WriteUint32,,false,53,53,WriteUint32,,,12,void node.serdes.SerializerContext.WriteUint32 (FunctionCallbackInfo<Value>)
229579,METHOD,node.serdes.SerializerContext,TYPE_DECL,static void WriteUint64(const FunctionCallbackInfo<Value>& args);,15,66,node_serdes.cc,node.serdes.SerializerContext.WriteUint64,,false,54,54,WriteUint64,,,13,void node.serdes.SerializerContext.WriteUint64 (FunctionCallbackInfo<Value>)
229584,METHOD,node.serdes.SerializerContext,TYPE_DECL,static void WriteDouble(const FunctionCallbackInfo<Value>& args);,15,66,node_serdes.cc,node.serdes.SerializerContext.WriteDouble,,false,55,55,WriteDouble,,,14,void node.serdes.SerializerContext.WriteDouble (FunctionCallbackInfo<Value>)
229589,METHOD,node.serdes.SerializerContext,TYPE_DECL,static void WriteRawBytes(const FunctionCallbackInfo<Value>& args);,15,68,node_serdes.cc,node.serdes.SerializerContext.WriteRawBytes,,false,56,56,WriteRawBytes,,,15,void node.serdes.SerializerContext.WriteRawBytes (FunctionCallbackInfo<Value>)
229596,METHOD,node.serdes.DeserializerContext,TYPE_DECL,"DeserializerContext(Environment* env,
                      Local<Object> wrap,
                      Local<Value> buffer);",3,42,node_serdes.cc,node.serdes.DeserializerContext.DeserializerContext,,false,69,71,DeserializerContext,,,1,"ANY node.serdes.DeserializerContext.DeserializerContext (Environment*,Local<Object>,Local<Value>)"
229603,METHOD,node.serdes.DeserializerContext,TYPE_DECL,~DeserializerContext() override = default;,3,44,node_serdes.cc,node.serdes.DeserializerContext.~DeserializerContext,,false,73,73,~DeserializerContext,,,2,ANY node.serdes.DeserializerContext.~DeserializerContext ()
229607,METHOD,node.serdes.DeserializerContext,TYPE_DECL,MaybeLocal<Object> ReadHostObject(Isolate* isolate) override;,22,62,node_serdes.cc,node.serdes.DeserializerContext.ReadHostObject,,false,75,75,ReadHostObject,,,3,MaybeLocal<Object> node.serdes.DeserializerContext.ReadHostObject (Isolate*)
229612,METHOD,node.serdes.DeserializerContext,TYPE_DECL,static void New(const FunctionCallbackInfo<Value>& args);,15,58,node_serdes.cc,node.serdes.DeserializerContext.New,,false,77,77,New,,,4,void node.serdes.DeserializerContext.New (FunctionCallbackInfo<Value>)
229617,METHOD,node.serdes.DeserializerContext,TYPE_DECL,static void ReadHeader(const FunctionCallbackInfo<Value>& args);,15,65,node_serdes.cc,node.serdes.DeserializerContext.ReadHeader,,false,78,78,ReadHeader,,,5,void node.serdes.DeserializerContext.ReadHeader (FunctionCallbackInfo<Value>)
229622,METHOD,node.serdes.DeserializerContext,TYPE_DECL,static void ReadValue(const FunctionCallbackInfo<Value>& args);,15,64,node_serdes.cc,node.serdes.DeserializerContext.ReadValue,,false,79,79,ReadValue,,,6,void node.serdes.DeserializerContext.ReadValue (FunctionCallbackInfo<Value>)
229627,METHOD,node.serdes.DeserializerContext,TYPE_DECL,static void TransferArrayBuffer(const FunctionCallbackInfo<Value>& args);,15,74,node_serdes.cc,node.serdes.DeserializerContext.TransferArrayBuffer,,false,80,80,TransferArrayBuffer,,,7,void node.serdes.DeserializerContext.TransferArrayBuffer (FunctionCallbackInfo<Value>)
229632,METHOD,node.serdes.DeserializerContext,TYPE_DECL,static void GetWireFormatVersion(const FunctionCallbackInfo<Value>& args);,15,75,node_serdes.cc,node.serdes.DeserializerContext.GetWireFormatVersion,,false,81,81,GetWireFormatVersion,,,8,void node.serdes.DeserializerContext.GetWireFormatVersion (FunctionCallbackInfo<Value>)
229637,METHOD,node.serdes.DeserializerContext,TYPE_DECL,static void ReadUint32(const FunctionCallbackInfo<Value>& args);,15,65,node_serdes.cc,node.serdes.DeserializerContext.ReadUint32,,false,82,82,ReadUint32,,,9,void node.serdes.DeserializerContext.ReadUint32 (FunctionCallbackInfo<Value>)
229642,METHOD,node.serdes.DeserializerContext,TYPE_DECL,static void ReadUint64(const FunctionCallbackInfo<Value>& args);,15,65,node_serdes.cc,node.serdes.DeserializerContext.ReadUint64,,false,83,83,ReadUint64,,,10,void node.serdes.DeserializerContext.ReadUint64 (FunctionCallbackInfo<Value>)
229647,METHOD,node.serdes.DeserializerContext,TYPE_DECL,static void ReadDouble(const FunctionCallbackInfo<Value>& args);,15,65,node_serdes.cc,node.serdes.DeserializerContext.ReadDouble,,false,84,84,ReadDouble,,,11,void node.serdes.DeserializerContext.ReadDouble (FunctionCallbackInfo<Value>)
229652,METHOD,node.serdes.DeserializerContext,TYPE_DECL,static void ReadRawBytes(const FunctionCallbackInfo<Value>& args);,15,67,node_serdes.cc,node.serdes.DeserializerContext.ReadRawBytes,,false,85,85,ReadRawBytes,,,12,void node.serdes.DeserializerContext.ReadRawBytes (FunctionCallbackInfo<Value>)
229660,METHOD,node_serdes.cc:<global>,TYPE_DECL,"SerializerContext::SerializerContext(Environment* env, Local<Object> wrap)
  : BaseObject(env, wrap),
    serializer_(env->isolate(), this) {
  MakeWeak();
}",1,1,node_serdes.cc,node.serdes.SerializerContext.SerializerContext,,false,98,102,SerializerContext,,,3,"ANY node.serdes.SerializerContext.SerializerContext (Environment*,Local<Object>)"
229667,METHOD,node_serdes.cc:<global>,TYPE_DECL,"void SerializerContext::ThrowDataCloneError(Local<String> message) {
  Local<Value> args[1] = { message };
  Local<Value> get_data_clone_error =
      object()->Get(env()->context(),
                    env()->get_data_clone_error_string())
                      .ToLocalChecked();

  CHECK(get_data_clone_error->IsFunction());
  MaybeLocal<Value> error =
      get_data_clone_error.As<Function>()->Call(env()->context(),
                                                object(),
                                                arraysize(args),
                                                args);

  if (error.IsEmpty()) return;

  env()->isolate()->ThrowException(error.ToLocalChecked());
}",1,1,node_serdes.cc,node.serdes.SerializerContext.ThrowDataCloneError,,false,104,121,ThrowDataCloneError,,,4,void node.serdes.SerializerContext.ThrowDataCloneError (Local<String>)
229745,METHOD,node_serdes.cc:<global>,TYPE_DECL,"Maybe<uint32_t> SerializerContext::GetSharedArrayBufferId(
    Isolate* isolate, Local<SharedArrayBuffer> shared_array_buffer) {
  Local<Value> args[1] = { shared_array_buffer };
  Local<Value> get_shared_array_buffer_id =
      object()->Get(env()->context(),
                    env()->get_shared_array_buffer_id_string())
                      .ToLocalChecked();

  if (!get_shared_array_buffer_id->IsFunction()) {
    return ValueSerializer::Delegate::GetSharedArrayBufferId(
        isolate, shared_array_buffer);
  }

  MaybeLocal<Value> id =
      get_shared_array_buffer_id.As<Function>()->Call(env()->context(),
                                                      object(),
                                                      arraysize(args),
                                                      args);

  if (id.IsEmpty()) return Nothing<uint32_t>();

  return id.ToLocalChecked()->Uint32Value(env()->context());
}",1,1,node_serdes.cc,node.serdes.SerializerContext.GetSharedArrayBufferId,,false,123,145,GetSharedArrayBufferId,,,5,"Maybe<uint32_t> node.serdes.SerializerContext.GetSharedArrayBufferId (Isolate*,Local<SharedArrayBuffer>)"
229837,METHOD,node_serdes.cc:<global>,TYPE_DECL,"Maybe<bool> SerializerContext::WriteHostObject(Isolate* isolate,
                                               Local<Object> input) {
  MaybeLocal<Value> ret;
  Local<Value> args[1] = { input };

  Local<Value> write_host_object =
      object()->Get(env()->context(),
                    env()->write_host_object_string()).ToLocalChecked();

  if (!write_host_object->IsFunction()) {
    return ValueSerializer::Delegate::WriteHostObject(isolate, input);
  }

  ret = write_host_object.As<Function>()->Call(env()->context(),
                                               object(),
                                               arraysize(args),
                                               args);

  if (ret.IsEmpty())
    return Nothing<bool>();

  return Just(true);
}",1,1,node_serdes.cc,node.serdes.SerializerContext.WriteHostObject,,false,147,169,WriteHostObject,,,6,"Maybe<bool> node.serdes.SerializerContext.WriteHostObject (Isolate*,Local<Object>)"
229921,METHOD,node_serdes.cc:<global>,TYPE_DECL,"void SerializerContext::New(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  if (!args.IsConstructCall()) {
    return THROW_ERR_CONSTRUCT_CALL_REQUIRED(
        env, ""Class constructor Serializer cannot be invoked without 'new'"");
  }

  new SerializerContext(env, args.This());
}",1,1,node_serdes.cc,node.serdes.SerializerContext.New,,false,171,179,New,,,7,void node.serdes.SerializerContext.New (FunctionCallbackInfo<Value>)
229952,METHOD,node_serdes.cc:<global>,TYPE_DECL,"void SerializerContext::WriteHeader(const FunctionCallbackInfo<Value>& args) {
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());
  ctx->serializer_.WriteHeader();
}",1,1,node_serdes.cc,node.serdes.SerializerContext.WriteHeader,,false,181,185,WriteHeader,,,8,void node.serdes.SerializerContext.WriteHeader (FunctionCallbackInfo<Value>)
229971,METHOD,node_serdes.cc:<global>,TYPE_DECL,"void SerializerContext::WriteValue(const FunctionCallbackInfo<Value>& args) {
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());
  Maybe<bool> ret =
      ctx->serializer_.WriteValue(ctx->env()->context(), args[0]);

  if (ret.IsJust()) args.GetReturnValue().Set(ret.FromJust());
}",1,1,node_serdes.cc,node.serdes.SerializerContext.WriteValue,,false,187,194,WriteValue,,,9,void node.serdes.SerializerContext.WriteValue (FunctionCallbackInfo<Value>)
230020,METHOD,node_serdes.cc:<global>,TYPE_DECL,"void SerializerContext::SetTreatArrayBufferViewsAsHostObjects(
    const FunctionCallbackInfo<Value>& args) {
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  bool value = args[0]->BooleanValue(ctx->env()->isolate());
  ctx->serializer_.SetTreatArrayBufferViewsAsHostObjects(value);
}",1,1,node_serdes.cc,node.serdes.SerializerContext.SetTreatArrayBufferViewsAsHostObjects,,false,196,203,SetTreatArrayBufferViewsAsHostObjects,,,10,void node.serdes.SerializerContext.SetTreatArrayBufferViewsAsHostObjects (FunctionCallbackInfo<Value>)
230056,METHOD,node_serdes.cc:<global>,TYPE_DECL,"void SerializerContext::ReleaseBuffer(const FunctionCallbackInfo<Value>& args) {
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  // Note: Both ValueSerializer and this Buffer::New() variant use malloc()
  // as the underlying allocator.
  std::pair<uint8_t*, size_t> ret = ctx->serializer_.Release();
  auto buf = Buffer::New(ctx->env(),
                         reinterpret_cast<char*>(ret.first),
                         ret.second);

  if (!buf.IsEmpty()) {
    args.GetReturnValue().Set(buf.ToLocalChecked());
  }
}",1,1,node_serdes.cc,node.serdes.SerializerContext.ReleaseBuffer,,false,205,219,ReleaseBuffer,,,11,void node.serdes.SerializerContext.ReleaseBuffer (FunctionCallbackInfo<Value>)
230115,METHOD,node_serdes.cc:<global>,TYPE_DECL,"void SerializerContext::TransferArrayBuffer(
    const FunctionCallbackInfo<Value>& args) {
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  Maybe<uint32_t> id = args[0]->Uint32Value(ctx->env()->context());
  if (id.IsNothing()) return;

  if (!args[1]->IsArrayBuffer())
    return node::THROW_ERR_INVALID_ARG_TYPE(
        ctx->env(), ""arrayBuffer must be an ArrayBuffer"");

  Local<ArrayBuffer> ab = args[1].As<ArrayBuffer>();
  ctx->serializer_.TransferArrayBuffer(id.FromJust(), ab);
  return;
}",1,1,node_serdes.cc,node.serdes.SerializerContext.TransferArrayBuffer,,false,221,236,TransferArrayBuffer,,,12,void node.serdes.SerializerContext.TransferArrayBuffer (FunctionCallbackInfo<Value>)
230197,METHOD,node_serdes.cc:<global>,TYPE_DECL,"void SerializerContext::WriteUint32(const FunctionCallbackInfo<Value>& args) {
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  Maybe<uint32_t> value = args[0]->Uint32Value(ctx->env()->context());
  if (value.IsNothing()) return;

  ctx->serializer_.WriteUint32(value.FromJust());
}",1,1,node_serdes.cc,node.serdes.SerializerContext.WriteUint32,,false,238,246,WriteUint32,,,13,void node.serdes.SerializerContext.WriteUint32 (FunctionCallbackInfo<Value>)
230246,METHOD,node_serdes.cc:<global>,TYPE_DECL,"void SerializerContext::WriteUint64(const FunctionCallbackInfo<Value>& args) {
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  Maybe<uint32_t> arg0 = args[0]->Uint32Value(ctx->env()->context());
  Maybe<uint32_t> arg1 = args[1]->Uint32Value(ctx->env()->context());
  if (arg0.IsNothing() || arg1.IsNothing())
    return;

  uint64_t hi = arg0.FromJust();
  uint64_t lo = arg1.FromJust();
  ctx->serializer_.WriteUint64((hi << 32) | lo);
}",1,1,node_serdes.cc,node.serdes.SerializerContext.WriteUint64,,false,248,260,WriteUint64,,,14,void node.serdes.SerializerContext.WriteUint64 (FunctionCallbackInfo<Value>)
230334,METHOD,node_serdes.cc:<global>,TYPE_DECL,"void SerializerContext::WriteDouble(const FunctionCallbackInfo<Value>& args) {
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  Maybe<double> value = args[0]->NumberValue(ctx->env()->context());
  if (value.IsNothing()) return;

  ctx->serializer_.WriteDouble(value.FromJust());
}",1,1,node_serdes.cc,node.serdes.SerializerContext.WriteDouble,,false,262,270,WriteDouble,,,15,void node.serdes.SerializerContext.WriteDouble (FunctionCallbackInfo<Value>)
230380,METHOD,node_serdes.cc:<global>,TYPE_DECL,"void SerializerContext::WriteRawBytes(const FunctionCallbackInfo<Value>& args) {
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  if (!args[0]->IsArrayBufferView()) {
    return node::THROW_ERR_INVALID_ARG_TYPE(
        ctx->env(), ""source must be a TypedArray or a DataView"");
  }

  ArrayBufferViewContents<char> bytes(args[0]);
  ctx->serializer_.WriteRawBytes(bytes.data(), bytes.length());
}",1,1,node_serdes.cc,node.serdes.SerializerContext.WriteRawBytes,,false,272,283,WriteRawBytes,,,16,void node.serdes.SerializerContext.WriteRawBytes (FunctionCallbackInfo<Value>)
230431,METHOD,node_serdes.cc:<global>,TYPE_DECL,"DeserializerContext::DeserializerContext(Environment* env,
                                         Local<Object> wrap,
                                         Local<Value> buffer)
  : BaseObject(env, wrap),
    data_(reinterpret_cast<const uint8_t*>(Buffer::Data(buffer))),
    length_(Buffer::Length(buffer)),
    deserializer_(env->isolate(), data_, length_, this) {
  object()->Set(env->context(), env->buffer_string(), buffer).Check();

  MakeWeak();
}",1,1,node_serdes.cc,node.serdes.DeserializerContext.DeserializerContext,,false,285,295,DeserializerContext,,,17,"ANY node.serdes.DeserializerContext.DeserializerContext (Environment*,Local<Object>,Local<Value>)"
230455,METHOD,node_serdes.cc:<global>,TYPE_DECL,"MaybeLocal<Object> DeserializerContext::ReadHostObject(Isolate* isolate) {
  Local<Value> read_host_object =
      object()->Get(env()->context(),
                    env()->read_host_object_string()).ToLocalChecked();

  if (!read_host_object->IsFunction()) {
    return ValueDeserializer::Delegate::ReadHostObject(isolate);
  }

  Isolate::AllowJavascriptExecutionScope allow_js(isolate);
  MaybeLocal<Value> ret =
      read_host_object.As<Function>()->Call(env()->context(),
                                            object(),
                                            0,
                                            nullptr);

  if (ret.IsEmpty())
    return MaybeLocal<Object>();

  Local<Value> return_value = ret.ToLocalChecked();
  if (!return_value->IsObject()) {
    env()->ThrowTypeError(""readHostObject must return an object"");
    return MaybeLocal<Object>();
  }

  return return_value.As<Object>();
}",1,1,node_serdes.cc,node.serdes.DeserializerContext.ReadHostObject,,false,297,323,ReadHostObject,,,18,MaybeLocal<Object> node.serdes.DeserializerContext.ReadHostObject (Isolate*)
230556,METHOD,node_serdes.cc:<global>,TYPE_DECL,"void DeserializerContext::New(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  if (!args.IsConstructCall()) {
    return THROW_ERR_CONSTRUCT_CALL_REQUIRED(
        env, ""Class constructor Deserializer cannot be invoked without 'new'"");
  }

  if (!args[0]->IsArrayBufferView()) {
    return node::THROW_ERR_INVALID_ARG_TYPE(
        env, ""buffer must be a TypedArray or a DataView"");
  }

  new DeserializerContext(env, args.This(), args[0]);
}",1,1,node_serdes.cc,node.serdes.DeserializerContext.New,,false,325,338,New,,,19,void node.serdes.DeserializerContext.New (FunctionCallbackInfo<Value>)
230606,METHOD,node_serdes.cc:<global>,TYPE_DECL,"void DeserializerContext::ReadHeader(const FunctionCallbackInfo<Value>& args) {
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  Maybe<bool> ret = ctx->deserializer_.ReadHeader(ctx->env()->context());

  if (ret.IsJust()) args.GetReturnValue().Set(ret.FromJust());
}",1,1,node_serdes.cc,node.serdes.DeserializerContext.ReadHeader,,false,340,347,ReadHeader,,,20,void node.serdes.DeserializerContext.ReadHeader (FunctionCallbackInfo<Value>)
230652,METHOD,node_serdes.cc:<global>,TYPE_DECL,"void DeserializerContext::ReadValue(const FunctionCallbackInfo<Value>& args) {
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  MaybeLocal<Value> ret = ctx->deserializer_.ReadValue(ctx->env()->context());

  if (!ret.IsEmpty()) args.GetReturnValue().Set(ret.ToLocalChecked());
}",1,1,node_serdes.cc,node.serdes.DeserializerContext.ReadValue,,false,349,356,ReadValue,,,21,void node.serdes.DeserializerContext.ReadValue (FunctionCallbackInfo<Value>)
230702,METHOD,node_serdes.cc:<global>,TYPE_DECL,"void DeserializerContext::TransferArrayBuffer(
    const FunctionCallbackInfo<Value>& args) {
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  Maybe<uint32_t> id = args[0]->Uint32Value(ctx->env()->context());
  if (id.IsNothing()) return;

  if (args[1]->IsArrayBuffer()) {
    Local<ArrayBuffer> ab = args[1].As<ArrayBuffer>();
    ctx->deserializer_.TransferArrayBuffer(id.FromJust(), ab);
    return;
  }

  if (args[1]->IsSharedArrayBuffer()) {
    Local<SharedArrayBuffer> sab = args[1].As<SharedArrayBuffer>();
    ctx->deserializer_.TransferSharedArrayBuffer(id.FromJust(), sab);
    return;
  }

  return node::THROW_ERR_INVALID_ARG_TYPE(
      ctx->env(), ""arrayBuffer must be an ArrayBuffer or SharedArrayBuffer"");
}",1,1,node_serdes.cc,node.serdes.DeserializerContext.TransferArrayBuffer,,false,358,380,TransferArrayBuffer,,,22,void node.serdes.DeserializerContext.TransferArrayBuffer (FunctionCallbackInfo<Value>)
230815,METHOD,node_serdes.cc:<global>,TYPE_DECL,"void DeserializerContext::GetWireFormatVersion(
    const FunctionCallbackInfo<Value>& args) {
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  args.GetReturnValue().Set(ctx->deserializer_.GetWireFormatVersion());
}",1,1,node_serdes.cc,node.serdes.DeserializerContext.GetWireFormatVersion,,false,382,388,GetWireFormatVersion,,,23,void node.serdes.DeserializerContext.GetWireFormatVersion (FunctionCallbackInfo<Value>)
230841,METHOD,node_serdes.cc:<global>,TYPE_DECL,"void DeserializerContext::ReadUint32(const FunctionCallbackInfo<Value>& args) {
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  uint32_t value;
  bool ok = ctx->deserializer_.ReadUint32(&value);
  if (!ok) return ctx->env()->ThrowError(""ReadUint32() failed"");
  return args.GetReturnValue().Set(value);
}",1,1,node_serdes.cc,node.serdes.DeserializerContext.ReadUint32,,false,390,398,ReadUint32,,,24,void node.serdes.DeserializerContext.ReadUint32 (FunctionCallbackInfo<Value>)
230888,METHOD,node_serdes.cc:<global>,TYPE_DECL,"void DeserializerContext::ReadUint64(const FunctionCallbackInfo<Value>& args) {
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  uint64_t value;
  bool ok = ctx->deserializer_.ReadUint64(&value);
  if (!ok) return ctx->env()->ThrowError(""ReadUint64() failed"");

  uint32_t hi = static_cast<uint32_t>(value >> 32);
  uint32_t lo = static_cast<uint32_t>(value);

  Isolate* isolate = ctx->env()->isolate();

  Local<Value> ret[] = {
    Integer::NewFromUnsigned(isolate, hi),
    Integer::NewFromUnsigned(isolate, lo)
  };
  return args.GetReturnValue().Set(Array::New(isolate, ret, arraysize(ret)));
}",1,1,node_serdes.cc,node.serdes.DeserializerContext.ReadUint64,,false,400,418,ReadUint64,,,25,void node.serdes.DeserializerContext.ReadUint64 (FunctionCallbackInfo<Value>)
230982,METHOD,node_serdes.cc:<global>,TYPE_DECL,"void DeserializerContext::ReadDouble(const FunctionCallbackInfo<Value>& args) {
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  double value;
  bool ok = ctx->deserializer_.ReadDouble(&value);
  if (!ok) return ctx->env()->ThrowError(""ReadDouble() failed"");
  return args.GetReturnValue().Set(value);
}",1,1,node_serdes.cc,node.serdes.DeserializerContext.ReadDouble,,false,420,428,ReadDouble,,,26,void node.serdes.DeserializerContext.ReadDouble (FunctionCallbackInfo<Value>)
231029,METHOD,node_serdes.cc:<global>,TYPE_DECL,"void DeserializerContext::ReadRawBytes(
    const FunctionCallbackInfo<Value>& args) {
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  Maybe<int64_t> length_arg = args[0]->IntegerValue(ctx->env()->context());
  if (length_arg.IsNothing()) return;
  size_t length = length_arg.FromJust();

  const void* data;
  bool ok = ctx->deserializer_.ReadRawBytes(length, &data);
  if (!ok) return ctx->env()->ThrowError(""ReadRawBytes() failed"");

  const uint8_t* position = reinterpret_cast<const uint8_t*>(data);
  CHECK_GE(position, ctx->data_);
  CHECK_LE(position + length, ctx->data_ + ctx->length_);

  const uint32_t offset = static_cast<uint32_t>(position - ctx->data_);
  CHECK_EQ(ctx->data_ + offset, position);

  args.GetReturnValue().Set(offset);
}",1,1,node_serdes.cc,node.serdes.DeserializerContext.ReadRawBytes,,false,430,451,ReadRawBytes,,,27,void node.serdes.DeserializerContext.ReadRawBytes (FunctionCallbackInfo<Value>)
231148,METHOD,node_serdes.cc:<global>,TYPE_DECL,"void Initialize(Local<Object> target,
                Local<Value> unused,
                Local<Context> context,
                void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> ser =
      NewFunctionTemplate(isolate, SerializerContext::New);

  ser->InstanceTemplate()->SetInternalFieldCount(
      SerializerContext::kInternalFieldCount);

  SetProtoMethod(isolate, ser, ""writeHeader"", SerializerContext::WriteHeader);
  SetProtoMethod(isolate, ser, ""writeValue"", SerializerContext::WriteValue);
  SetProtoMethod(
      isolate, ser, ""releaseBuffer"", SerializerContext::ReleaseBuffer);
  SetProtoMethod(isolate,
                 ser,
                 ""transferArrayBuffer"",
                 SerializerContext::TransferArrayBuffer);
  SetProtoMethod(isolate, ser, ""writeUint32"", SerializerContext::WriteUint32);
  SetProtoMethod(isolate, ser, ""writeUint64"", SerializerContext::WriteUint64);
  SetProtoMethod(i...",1,1,node_serdes.cc,node.serdes.Initialize,,false,453,512,Initialize,,,28,"void node.serdes.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
231355,METHOD,node_serdes.cc:<global>,TYPE_DECL,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(SerializerContext::New);

  registry->Register(SerializerContext::WriteHeader);
  registry->Register(SerializerContext::WriteValue);
  registry->Register(SerializerContext::ReleaseBuffer);
  registry->Register(SerializerContext::TransferArrayBuffer);
  registry->Register(SerializerContext::WriteUint32);
  registry->Register(SerializerContext::WriteUint64);
  registry->Register(SerializerContext::WriteDouble);
  registry->Register(SerializerContext::WriteRawBytes);
  registry->Register(SerializerContext::SetTreatArrayBufferViewsAsHostObjects);

  registry->Register(DeserializerContext::New);
  registry->Register(DeserializerContext::ReadHeader);
  registry->Register(DeserializerContext::ReadValue);
  registry->Register(DeserializerContext::GetWireFormatVersion);
  registry->Register(DeserializerContext::TransferArrayBuffer);
  registry->Register(DeserializerContext::ReadUint32);
  registry->Re...",1,1,node_serdes.cc,node.serdes.RegisterExternalReferences,,false,514,536,RegisterExternalReferences,,,29,void node.serdes.RegisterExternalReferences (ExternalReferenceRegistry*)
231495,METHOD,node_shadow_realm.cc:<global>,TYPE_DECL,[realm](Environment* env) { delete realm; },30,72,node_shadow_realm.cc,node.shadow_realm.ShadowRealm.WeakCallback.<lambda>0,,false,51,51,<lambda>0,,,1,ANY node.shadow_realm.ShadowRealm.WeakCallback.<lambda>0 (Environment*)
231512,METHOD,node_shadow_realm.cc:<global>,TYPE_DECL,<global>,1,35,node_shadow_realm.hpp,node_shadow_realm.cc:<global>,,false,1,144,<global>,,,1,
231517,METHOD,node_shadow_realm.cc:<global>,TYPE_DECL,"ShadowRealm* ShadowRealm::New(Environment* env) {
  ShadowRealm* realm = new ShadowRealm(env);

  // We do not expect the realm bootstrapping to throw any
  // exceptions. If it does, exit the current Node.js instance.
  TryCatchScope try_catch(env, TryCatchScope::CatchMode::kFatal);
  if (realm->RunBootstrapping().IsEmpty()) {
    delete realm;
    return nullptr;
  }
  return realm;
}",1,1,node_shadow_realm.cc,node.shadow_realm.ShadowRealm.New,,false,17,28,New,,,2,ShadowRealm node.shadow_realm.ShadowRealm.New (Environment*)
231551,METHOD,node_shadow_realm.cc:<global>,TYPE_DECL,"MaybeLocal<Context> HostCreateShadowRealmContextCallback(
    Local<Context> initiator_context) {
  Environment* env = Environment::GetCurrent(initiator_context);
  EscapableHandleScope scope(env->isolate());
  ShadowRealm* realm = ShadowRealm::New(env);
  if (realm != nullptr) {
    return scope.Escape(realm->context());
  }
  return MaybeLocal<Context>();
}",1,1,node_shadow_realm.cc,node.shadow_realm.HostCreateShadowRealmContextCallback,,false,31,40,HostCreateShadowRealmContextCallback,,,3,MaybeLocal<Context> node.shadow_realm.HostCreateShadowRealmContextCallback (Local<Context>)
231594,METHOD,node_shadow_realm.cc:<global>,TYPE_DECL,"void ShadowRealm::WeakCallback(const v8::WeakCallbackInfo<ShadowRealm>& data) {
  ShadowRealm* realm = data.GetParameter();
  realm->context_.Reset();

  // Yield to pending weak callbacks before deleting the realm.
  // This is necessary to avoid cleaning up base objects before their scheduled
  // weak callbacks are invoked, which can lead to accessing to v8 apis during
  // the first pass of the weak callback.
  realm->env()->SetImmediate([realm](Environment* env) { delete realm; });
  // Remove the cleanup hook to avoid deleting the realm again.
  realm->env()->RemoveCleanupHook(DeleteMe, realm);
}",1,1,node_shadow_realm.cc,node.shadow_realm.ShadowRealm.WeakCallback,,false,43,54,WeakCallback,,,4,void node.shadow_realm.ShadowRealm.WeakCallback (ANY)
231628,METHOD,node_shadow_realm.cc:<global>,TYPE_DECL,"void ShadowRealm::DeleteMe(void* data) {
  ShadowRealm* realm = static_cast<ShadowRealm*>(data);
  // Clear the context handle to avoid invoking the weak callback again.
  // Also, the context internal slots are cleared and the context is no longer
  // reference to the realm.
  delete realm;
}",1,1,node_shadow_realm.cc,node.shadow_realm.ShadowRealm.DeleteMe,,false,57,63,DeleteMe,,,5,void node.shadow_realm.ShadowRealm.DeleteMe (void*)
231641,METHOD,node_shadow_realm.cc:<global>,TYPE_DECL,"ShadowRealm::ShadowRealm(Environment* env)
    : Realm(env, NewContext(env->isolate()), kShadowRealm) {
  context_.SetWeak(this, WeakCallback, v8::WeakCallbackType::kParameter);
  CreateProperties();

  env->TrackShadowRealm(this);
  env->AddCleanupHook(DeleteMe, this);
}",1,1,node_shadow_realm.cc,node.shadow_realm.ShadowRealm.ShadowRealm,,false,65,72,ShadowRealm,,,6,ANY node.shadow_realm.ShadowRealm.ShadowRealm (Environment*)
231669,METHOD,node_shadow_realm.cc:<global>,TYPE_DECL,"ShadowRealm::~ShadowRealm() {
  while (HasCleanupHooks()) {
    RunCleanup();
  }

  env_->UntrackShadowRealm(this);

  if (context_.IsEmpty()) {
    // This most likely happened because the weak callback cleared it.
    return;
  }

  {
    HandleScope handle_scope(isolate());
    env_->UnassignFromContext(context());
  }
}",1,1,node_shadow_realm.cc,node.shadow_realm.ShadowRealm.~ShadowRealm,,false,74,90,~ShadowRealm,,,7,ANY node.shadow_realm.ShadowRealm.~ShadowRealm ()
231698,METHOD,node_shadow_realm.cc:<global>,TYPE_DECL,"v8::Local<v8::Context> ShadowRealm::context() const {
  Local<Context> ctx = PersistentToLocal::Default(isolate_, context_);
  DCHECK(!ctx.IsEmpty());
  return ctx;
}",1,1,node_shadow_realm.cc,node.shadow_realm.ShadowRealm.context,,false,92,96,context,,,8,Local<v8::Context> node.shadow_realm.ShadowRealm.context ()
231724,METHOD,node_shadow_realm.cc:<global>,TYPE_DECL,"v8::MaybeLocal<v8::Value> ShadowRealm::BootstrapRealm() {
  HandleScope scope(isolate_);

  // Skip ""internal/bootstrap/node"" as it installs node globals and per-isolate
  // callbacks.

  if (!env_->no_browser_globals()) {
    if (ExecuteBootstrapper(""internal/bootstrap/web/exposed-wildcard"")
            .IsEmpty()) {
      return MaybeLocal<Value>();
    }
  }

  return v8::True(isolate_);
}",1,1,node_shadow_realm.cc,node.shadow_realm.ShadowRealm.BootstrapRealm,,false,127,141,BootstrapRealm,,,11,MaybeLocal<v8::Value> node.shadow_realm.ShadowRealm.BootstrapRealm ()
231760,METHOD,node_shadow_realm.hpp:<global>,TYPE_DECL,<global>,1,35,node_shadow_realm.hpp,node_shadow_realm.hpp:<global>,,false,1,46,<global>,,,1,
231777,METHOD,node_snapshot_builder.hpp:<global>,TYPE_DECL,<global>,1,39,node_snapshot_builder.hpp,node_snapshot_builder.hpp:<global>,,false,1,52,<global>,,,1,
231784,METHOD,node_snapshot_stub.cc:<global>,TYPE_DECL,<global>,1,1,node_snapshot_stub.cc,node_snapshot_stub.cc:<global>,,false,1,13,<global>,,,1,
231787,METHOD,node_snapshot_stub.cc:<global>,TYPE_DECL,"const SnapshotData* SnapshotBuilder::GetEmbeddedSnapshotData() {
  return nullptr;
}",1,1,node_snapshot_stub.cc,node.SnapshotBuilder.GetEmbeddedSnapshotData,,false,9,11,GetEmbeddedSnapshotData,,,1,SnapshotData node.SnapshotBuilder.GetEmbeddedSnapshotData ()
231794,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"[&]() {
      if (bootstrapCatch.HasCaught()) {
        PrintCaughtException(
            isolate, isolate->GetCurrentContext(), bootstrapCatch);
      }
    }",41,5,node_snapshotable.cc,node.SnapshotBuilder.Generate.<lambda>0,,false,928,933,<lambda>0,,,1,ANY node.SnapshotBuilder.Generate.<lambda>0 ()
231815,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,[](Realm* realm) { realm->PrintInfoForSnapshot(); },27,77,node_snapshotable.cc,node.SnapshotBuilder.CreateSnapshot.<lambda>1,,false,1002,1002,<lambda>1,,,1,ANY node.SnapshotBuilder.CreateSnapshot.<lambda>1 (Realm*)
231825,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"[&](BaseObject* obj) {
    // If there are any BaseObjects that are not snapshotable left
    // during context serialization, V8 would crash due to unregistered
    // global handles and print detailed information about them.
    if (!obj->is_snapshotable()) {
      return;
    }
    SnapshotableObject* ptr = static_cast<SnapshotableObject*>(obj);

    std::string type_name = ptr->GetTypeName();
    per_process::Debug(DebugCategory::MKSNAPSHOT,
                       ""Serialize snapshotable object %i (%p), ""
                       ""object=%p, type=%s\n"",
                       static_cast<int>(i),
                       ptr,
                       *(ptr->object()),
                       type_name);

    if (ptr->PrepareForSerialization(context, creator)) {
      SnapshotIndex index = creator->AddData(context, obj->object());
      per_process::Debug(DebugCategory::MKSNAPSHOT,
                         ""Serialized with index=%d\n"",
                         static_cast<int>(index));
...",28,3,node_snapshotable.cc,node.SerializeSnapshotableObjects.<lambda>2,,false,1203,1229,<lambda>2,,,1,ANY node.SerializeSnapshotableObjects.<lambda>2 (BaseObject*)
231971,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,<global>,1,1,node_snapshotable.cc,node_snapshotable.cc:<global>,,false,1,1410,<global>,,,1,
231975,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"std::ostream& operator<<(std::ostream& output,
                         const builtins::CodeCacheInfo& info) {
  output << ""<builtins::CodeCacheInfo id="" << info.id
         << "", length="" << info.data.length << "">\n"";
  return output;
}",1,1,node_snapshotable.cc,node.operator <<,,false,54,59,operator <<,,,2,"ostream node.operator << (ANY,ANY)"
232000,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"std::ostream& operator<<(std::ostream& output,
                         const std::vector<builtins::CodeCacheInfo>& vec) {
  output << ""{\n"";
  for (const auto& info : vec) {
    output << info;
  }
  output << ""}\n"";
  return output;
}",1,1,node_snapshotable.cc,node.operator <<,,false,61,69,operator <<,,,3,"ostream node.operator << (ANY,ANY)"
232021,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"std::ostream& operator<<(std::ostream& output,
                         const std::vector<uint8_t>& vec) {
  output << ""{\n"";
  for (const auto& i : vec) {
    output << i << "","";
  }
  output << ""}"";
  return output;
}",1,1,node_snapshotable.cc,node.operator <<,,false,71,79,operator <<,,,4,"ostream node.operator << (ANY,ANY)"
232044,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"std::ostream& operator<<(std::ostream& output,
                         const std::vector<PropInfo>& vec) {
  output << ""{\n"";
  for (const auto& info : vec) {
    output << ""  "" << info << "",\n"";
  }
  output << ""}"";
  return output;
}",1,1,node_snapshotable.cc,node.operator <<,,false,81,89,operator <<,,,5,"ostream node.operator << (ANY,ANY)"
232069,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"std::ostream& operator<<(std::ostream& output, const PropInfo& info) {
  output << ""{ \"""" << info.name << ""\"", "" << std::to_string(info.id) << "", ""
         << std::to_string(info.index) << "" }"";
  return output;
}",1,1,node_snapshotable.cc,node.operator <<,,false,91,95,operator <<,,,6,"ostream node.operator << (ANY,PropInfo)"
232106,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"std::ostream& operator<<(std::ostream& output,
                         const std::vector<std::string>& vec) {
  output << ""{\n"";
  for (const auto& info : vec) {
    output << ""  \"""" << info << ""\"",\n"";
  }
  output << ""}"";
  return output;
}",1,1,node_snapshotable.cc,node.operator <<,,false,97,105,operator <<,,,7,"ostream node.operator << (ANY,ANY)"
232131,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"std::ostream& operator<<(std::ostream& output, const RealmSerializeInfo& i) {
  output << ""{\n""
         << ""// -- builtins begins --\n""
         << i.builtins << "",\n""
         << ""// -- builtins ends --\n""
         << ""// -- persistent_values begins --\n""
         << i.persistent_values << "",\n""
         << ""// -- persistent_values ends --\n""
         << ""// -- native_objects begins --\n""
         << i.native_objects << "",\n""
         << ""// -- native_objects ends --\n""
         << i.context << "",  // context\n""
         << ""}"";
  return output;
}",1,1,node_snapshotable.cc,node.operator <<,,false,107,121,operator <<,,,8,"ostream node.operator << (ANY,RealmSerializeInfo)"
232180,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"std::ostream& operator<<(std::ostream& output, const EnvSerializeInfo& i) {
  output << ""{\n""
         << ""// -- async_hooks begins --\n""
         << i.async_hooks << "",\n""
         << ""// -- async_hooks ends --\n""
         << i.tick_info << "",  // tick_info\n""
         << i.immediate_info << "",  // immediate_info\n""
         << i.timeout_info << "",  // timeout_info\n""
         << ""// -- performance_state begins --\n""
         << i.performance_state << "",\n""
         << ""// -- performance_state ends --\n""
         << i.exit_info << "",  // exit_info\n""
         << i.stream_base_state << "",  // stream_base_state\n""
         << i.should_abort_on_uncaught_toggle
         << "",  // should_abort_on_uncaught_toggle\n""
         << ""// -- principal_realm begins --\n""
         << i.principal_realm << "",\n""
         << ""// -- principal_realm ends --\n""
         << ""}"";
  return output;
}",1,1,node_snapshotable.cc,node.operator <<,,false,123,143,operator <<,,,9,"ostream node.operator << (ANY,EnvSerializeInfo)"
232260,METHOD,node.SnapshotDeserializer,TYPE_DECL,"explicit SnapshotDeserializer(std::string_view v)
      : BlobDeserializer<SnapshotDeserializer>(
            per_process::enabled_debug_list.enabled(DebugCategory::MKSNAPSHOT),
            v) {}",3,17,node_snapshotable.cc,node.SnapshotDeserializer.SnapshotDeserializer,,false,147,150,SnapshotDeserializer,,,1,ANY node.SnapshotDeserializer.SnapshotDeserializer (ANY)
232265,METHOD,node.SnapshotDeserializer,TYPE_DECL,T Read();,5,10,node_snapshotable.cc,node.SnapshotDeserializer.Read,,false,155,155,Read,,,2,"T node.SnapshotDeserializer.Read<T,std::enable_if_t<!std::is_same<T,std::string>::value>*=nullptr,std::enable_if_t<!std::is_arithmetic<T>::value>*=nullptr> ()"
232270,METHOD,node.SnapshotSerializer,TYPE_DECL,"SnapshotSerializer()
      : BlobSerializer<SnapshotSerializer>(
            per_process::enabled_debug_list.enabled(
                DebugCategory::MKSNAPSHOT)) {
    // Currently the snapshot blob built with an empty script is around 4MB.
    // So use that as the default sink size.
    sink.reserve(4 * 1024 * 1024);
  }",3,3,node_snapshotable.cc,node.SnapshotSerializer.SnapshotSerializer,,false,160,167,SnapshotSerializer,,,1,ANY node.SnapshotSerializer.SnapshotSerializer ()
232283,METHOD,node.SnapshotSerializer,TYPE_DECL,size_t Write(const T& data);,10,29,node_snapshotable.cc,node.SnapshotSerializer.Write,,false,172,172,Write,,,2,"size_t node.SnapshotSerializer.Write<T,std::enable_if_t<!std::is_same<T,std::string>::value>*=nullptr,std::enable_if_t<!std::is_arithmetic<T>::value>*=nullptr> (T)"
232288,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"v8::StartupData SnapshotDeserializer::Read() {
  Debug(""Read<v8::StartupData>()\n"");

  int raw_size = ReadArithmetic<int>();
  Debug(""size=%d\n"", raw_size);

  CHECK_GT(raw_size, 0);  // There should be no startup data of size 0.
  // The data pointer of v8::StartupData would be deleted so it must be new'ed.
  std::unique_ptr<char> buf = std::unique_ptr<char>(new char[raw_size]);
  ReadArithmetic<char>(buf.get(), raw_size);

  return v8::StartupData{buf.release(), raw_size};
}",1,1,node_snapshotable.cc,node.SnapshotDeserializer.Read,,false,179,191,Read,,,12,StartupData node.SnapshotDeserializer.Read<> ()
232327,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"size_t SnapshotSerializer::Write(const v8::StartupData& data) {
  Debug(""\nWrite<v8::StartupData>() size=%d\n"", data.raw_size);

  CHECK_GT(data.raw_size, 0);  // There should be no startup data of size 0.
  size_t written_total = WriteArithmetic<int>(data.raw_size);
  written_total +=
      WriteArithmetic<char>(data.data, static_cast<size_t>(data.raw_size));

  Debug(""Write<v8::StartupData>() wrote %d bytes\n\n"", written_total);
  return written_total;
}",1,1,node_snapshotable.cc,node.SnapshotSerializer.Write,,false,194,204,Write,,,13,size_t node.SnapshotSerializer.Write<> (ANY)
232365,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"builtins::CodeCacheInfo SnapshotDeserializer::Read() {
  Debug(""Read<builtins::CodeCacheInfo>()\n"");

  std::string id = ReadString();
  auto owning_ptr =
      std::make_shared<std::vector<uint8_t>>(ReadVector<uint8_t>());
  builtins::BuiltinCodeCacheData code_cache_data{std::move(owning_ptr)};
  builtins::CodeCacheInfo result{id, code_cache_data};

  if (is_debug) {
    std::string str = ToStr(result);
    Debug(""Read<builtins::CodeCacheInfo>() %s\n"", str.c_str());
  }
  return result;
}",1,1,node_snapshotable.cc,node.SnapshotDeserializer.Read,,false,212,226,Read,,,14,CodeCacheInfo node.SnapshotDeserializer.Read<> ()
232420,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"size_t SnapshotSerializer::Write(const builtins::CodeCacheInfo& info) {
  Debug(""\nWrite<builtins::CodeCacheInfo>() id = %s""
        "", length=%d\n"",
        info.id.c_str(),
        info.data.length);

  size_t written_total = WriteString(info.id);

  written_total += WriteArithmetic<size_t>(info.data.length);
  written_total += WriteArithmetic(info.data.data, info.data.length);

  Debug(""Write<builtins::CodeCacheInfo>() wrote %d bytes\n"", written_total);
  return written_total;
}",1,1,node_snapshotable.cc,node.SnapshotSerializer.Write,,false,229,242,Write,,,15,size_t node.SnapshotSerializer.Write<> (ANY)
232474,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"PropInfo SnapshotDeserializer::Read() {
  Debug(""Read<PropInfo>()\n"");

  PropInfo result;
  result.name = ReadString();
  result.id = ReadArithmetic<uint32_t>();
  result.index = ReadArithmetic<SnapshotIndex>();

  if (is_debug) {
    std::string str = ToStr(result);
    Debug(""Read<PropInfo>() %s\n"", str.c_str());
  }

  return result;
}",1,1,node_snapshotable.cc,node.SnapshotDeserializer.Read,,false,251,265,Read,,,16,PropInfo node.SnapshotDeserializer.Read<> ()
232512,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"size_t SnapshotSerializer::Write(const PropInfo& data) {
  if (is_debug) {
    std::string str = ToStr(data);
    Debug(""Write<PropInfo>() %s\n"", str.c_str());
  }

  size_t written_total = WriteString(data.name);
  written_total += WriteArithmetic<uint32_t>(data.id);
  written_total += WriteArithmetic<SnapshotIndex>(data.index);

  Debug(""Write<PropInfo>() wrote %d bytes\n"", written_total);
  return written_total;
}",1,1,node_snapshotable.cc,node.SnapshotSerializer.Write,,false,268,280,Write,,,17,size_t node.SnapshotSerializer.Write<> (PropInfo)
232561,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"AsyncHooks::SerializeInfo SnapshotDeserializer::Read() {
  Debug(""Read<AsyncHooks::SerializeInfo>()\n"");

  AsyncHooks::SerializeInfo result;
  result.async_ids_stack = ReadArithmetic<AliasedBufferIndex>();
  result.fields = ReadArithmetic<AliasedBufferIndex>();
  result.async_id_fields = ReadArithmetic<AliasedBufferIndex>();
  result.js_execution_async_resources = ReadArithmetic<SnapshotIndex>();
  result.native_execution_async_resources = ReadVector<SnapshotIndex>();

  if (is_debug) {
    std::string str = ToStr(result);
    Debug(""Read<AsyncHooks::SerializeInfo>() %s\n"", str.c_str());
  }

  return result;
}",1,1,node_snapshotable.cc,node.SnapshotDeserializer.Read,,false,291,307,Read,,,18,SerializeInfo node.SnapshotDeserializer.Read<> ()
232609,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"size_t SnapshotSerializer::Write(const AsyncHooks::SerializeInfo& data) {
  if (is_debug) {
    std::string str = ToStr(data);
    Debug(""Write<AsyncHooks::SerializeInfo>() %s\n"", str.c_str());
  }

  size_t written_total =
      WriteArithmetic<AliasedBufferIndex>(data.async_ids_stack);
  written_total += WriteArithmetic<AliasedBufferIndex>(data.fields);
  written_total += WriteArithmetic<AliasedBufferIndex>(data.async_id_fields);
  written_total +=
      WriteArithmetic<SnapshotIndex>(data.js_execution_async_resources);
  written_total +=
      WriteVector<SnapshotIndex>(data.native_execution_async_resources);

  Debug(""Write<AsyncHooks::SerializeInfo>() wrote %d bytes\n"", written_total);
  return written_total;
}",1,1,node_snapshotable.cc,node.SnapshotSerializer.Write,,false,309,326,Write,,,19,size_t node.SnapshotSerializer.Write<> (ANY)
232679,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"TickInfo::SerializeInfo SnapshotDeserializer::Read() {
  Debug(""Read<TickInfo::SerializeInfo>()\n"");

  TickInfo::SerializeInfo result;
  result.fields = ReadArithmetic<AliasedBufferIndex>();

  if (is_debug) {
    std::string str = ToStr(result);
    Debug(""Read<TickInfo::SerializeInfo>() %s\n"", str.c_str());
  }

  return result;
}",1,1,node_snapshotable.cc,node.SnapshotDeserializer.Read,,false,331,343,Read,,,20,SerializeInfo node.SnapshotDeserializer.Read<> ()
232707,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"size_t SnapshotSerializer::Write(const TickInfo::SerializeInfo& data) {
  if (is_debug) {
    std::string str = ToStr(data);
    Debug(""Write<TickInfo::SerializeInfo>() %s\n"", str.c_str());
  }

  size_t written_total = WriteArithmetic<AliasedBufferIndex>(data.fields);

  Debug(""Write<TickInfo::SerializeInfo>() wrote %d bytes\n"", written_total);
  return written_total;
}",1,1,node_snapshotable.cc,node.SnapshotSerializer.Write,,false,346,356,Write,,,21,size_t node.SnapshotSerializer.Write<> (ANY)
232741,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"ImmediateInfo::SerializeInfo SnapshotDeserializer::Read() {
  Debug(""Read<ImmediateInfo::SerializeInfo>()\n"");

  ImmediateInfo::SerializeInfo result;
  result.fields = ReadArithmetic<AliasedBufferIndex>();
  if (is_debug) {
    std::string str = ToStr(result);
    Debug(""Read<ImmediateInfo::SerializeInfo>() %s\n"", str.c_str());
  }
  return result;
}",1,1,node_snapshotable.cc,node.SnapshotDeserializer.Read,,false,361,371,Read,,,22,SerializeInfo node.SnapshotDeserializer.Read<> ()
232769,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"size_t SnapshotSerializer::Write(const ImmediateInfo::SerializeInfo& data) {
  if (is_debug) {
    std::string str = ToStr(data);
    Debug(""Write<ImmediateInfo::SerializeInfo>() %s\n"", str.c_str());
  }

  size_t written_total = WriteArithmetic<AliasedBufferIndex>(data.fields);

  Debug(""Write<ImmediateInfo::SerializeInfo>() wrote %d bytes\n"",
        written_total);
  return written_total;
}",1,1,node_snapshotable.cc,node.SnapshotSerializer.Write,,false,374,385,Write,,,23,size_t node.SnapshotSerializer.Write<> (ANY)
232803,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"performance::PerformanceState::SerializeInfo SnapshotDeserializer::Read() {
  Debug(""Read<PerformanceState::SerializeInfo>()\n"");

  performance::PerformanceState::SerializeInfo result;
  result.root = ReadArithmetic<AliasedBufferIndex>();
  result.milestones = ReadArithmetic<AliasedBufferIndex>();
  result.observers = ReadArithmetic<AliasedBufferIndex>();
  if (is_debug) {
    std::string str = ToStr(result);
    Debug(""Read<PerformanceState::SerializeInfo>() %s\n"", str.c_str());
  }
  return result;
}",1,1,node_snapshotable.cc,node.SnapshotDeserializer.Read,,false,392,404,Read,,,24,SerializeInfo node.SnapshotDeserializer.Read<> ()
232841,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"size_t SnapshotSerializer::Write(
    const performance::PerformanceState::SerializeInfo& data) {
  if (is_debug) {
    std::string str = ToStr(data);
    Debug(""Write<PerformanceState::SerializeInfo>() %s\n"", str.c_str());
  }

  size_t written_total = WriteArithmetic<AliasedBufferIndex>(data.root);
  written_total += WriteArithmetic<AliasedBufferIndex>(data.milestones);
  written_total += WriteArithmetic<AliasedBufferIndex>(data.observers);

  Debug(""Write<PerformanceState::SerializeInfo>() wrote %d bytes\n"",
        written_total);
  return written_total;
}",1,1,node_snapshotable.cc,node.SnapshotSerializer.Write,,false,407,421,Write,,,25,size_t node.SnapshotSerializer.Write<> (ANY)
232893,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"IsolateDataSerializeInfo SnapshotDeserializer::Read() {
  Debug(""Read<IsolateDataSerializeInfo>()\n"");

  IsolateDataSerializeInfo result;
  result.primitive_values = ReadVector<SnapshotIndex>();
  result.template_values = ReadVector<PropInfo>();
  if (is_debug) {
    std::string str = ToStr(result);
    Debug(""Read<IsolateDataSerializeInfo>() %s\n"", str.c_str());
  }
  return result;
}",1,1,node_snapshotable.cc,node.SnapshotDeserializer.Read,,false,429,440,Read,,,26,IsolateDataSerializeInfo node.SnapshotDeserializer.Read<> ()
232926,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"size_t SnapshotSerializer::Write(const IsolateDataSerializeInfo& data) {
  if (is_debug) {
    std::string str = ToStr(data);
    Debug(""Write<IsolateDataSerializeInfo>() %s\n"", str.c_str());
  }

  size_t written_total = WriteVector<SnapshotIndex>(data.primitive_values);
  written_total += WriteVector<PropInfo>(data.template_values);

  Debug(""Write<IsolateDataSerializeInfo>() wrote %d bytes\n"", written_total);
  return written_total;
}",1,1,node_snapshotable.cc,node.SnapshotSerializer.Write,,false,443,454,Write,,,27,size_t node.SnapshotSerializer.Write<> (IsolateDataSerializeInfo)
232969,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"RealmSerializeInfo SnapshotDeserializer::Read() {
  Debug(""Read<RealmSerializeInfo>()\n"");
  RealmSerializeInfo result;
  result.builtins = ReadVector<std::string>();
  result.persistent_values = ReadVector<PropInfo>();
  result.native_objects = ReadVector<PropInfo>();
  result.context = ReadArithmetic<SnapshotIndex>();
  return result;
}",1,1,node_snapshotable.cc,node.SnapshotDeserializer.Read,,false,457,465,Read,,,28,RealmSerializeInfo node.SnapshotDeserializer.Read<> ()
232999,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"size_t SnapshotSerializer::Write(const RealmSerializeInfo& data) {
  if (is_debug) {
    std::string str = ToStr(data);
    Debug(""\nWrite<RealmSerializeInfo>() %s\n"", str.c_str());
  }

  // Use += here to ensure order of evaluation.
  size_t written_total = WriteVector<std::string>(data.builtins);
  written_total += WriteVector<PropInfo>(data.persistent_values);
  written_total += WriteVector<PropInfo>(data.native_objects);
  written_total += WriteArithmetic<SnapshotIndex>(data.context);

  Debug(""Write<RealmSerializeInfo>() wrote %d bytes\n"", written_total);
  return written_total;
}",1,1,node_snapshotable.cc,node.SnapshotSerializer.Write,,false,468,482,Write,,,29,size_t node.SnapshotSerializer.Write<> (RealmSerializeInfo)
233062,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"EnvSerializeInfo SnapshotDeserializer::Read() {
  Debug(""Read<EnvSerializeInfo>()\n"");
  EnvSerializeInfo result;
  result.async_hooks = Read<AsyncHooks::SerializeInfo>();
  result.tick_info = Read<TickInfo::SerializeInfo>();
  result.immediate_info = Read<ImmediateInfo::SerializeInfo>();
  result.timeout_info = ReadArithmetic<AliasedBufferIndex>();
  result.performance_state =
      Read<performance::PerformanceState::SerializeInfo>();
  result.exit_info = ReadArithmetic<AliasedBufferIndex>();
  result.stream_base_state = ReadArithmetic<AliasedBufferIndex>();
  result.should_abort_on_uncaught_toggle = ReadArithmetic<AliasedBufferIndex>();
  result.principal_realm = Read<RealmSerializeInfo>();
  return result;
}",1,1,node_snapshotable.cc,node.SnapshotDeserializer.Read,,false,485,499,Read,,,30,EnvSerializeInfo node.SnapshotDeserializer.Read<> ()
233120,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"size_t SnapshotSerializer::Write(const EnvSerializeInfo& data) {
  if (is_debug) {
    std::string str = ToStr(data);
    Debug(""\nWrite<EnvSerializeInfo>() %s\n"", str.c_str());
  }

  // Use += here to ensure order of evaluation.
  size_t written_total = Write<AsyncHooks::SerializeInfo>(data.async_hooks);
  written_total += Write<TickInfo::SerializeInfo>(data.tick_info);
  written_total += Write<ImmediateInfo::SerializeInfo>(data.immediate_info);
  written_total += WriteArithmetic<AliasedBufferIndex>(data.timeout_info);
  written_total += Write<performance::PerformanceState::SerializeInfo>(
      data.performance_state);
  written_total += WriteArithmetic<AliasedBufferIndex>(data.exit_info);
  written_total += WriteArithmetic<AliasedBufferIndex>(data.stream_base_state);
  written_total +=
      WriteArithmetic<AliasedBufferIndex>(data.should_abort_on_uncaught_toggle);
  written_total += Write<RealmSerializeInfo>(data.principal_realm);

  Debug(""Write<EnvSerializeInfo>() wrote %d by...",1,1,node_snapshotable.cc,node.SnapshotSerializer.Write,,false,502,523,Write,,,31,size_t node.SnapshotSerializer.Write<> (EnvSerializeInfo)
233215,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"SnapshotMetadata SnapshotDeserializer::Read() {
  Debug(""Read<SnapshotMetadata>()\n"");

  SnapshotMetadata result;
  result.type = static_cast<SnapshotMetadata::Type>(ReadArithmetic<uint8_t>());
  result.node_version = ReadString();
  result.node_arch = ReadString();
  result.node_platform = ReadString();
  result.v8_cache_version_tag = ReadArithmetic<uint32_t>();

  if (is_debug) {
    std::string str = ToStr(result);
    Debug(""Read<SnapshotMetadata>() %s\n"", str.c_str());
  }
  return result;
}",1,1,node_snapshotable.cc,node.SnapshotDeserializer.Read,,false,535,550,Read,,,32,SnapshotMetadata node.SnapshotDeserializer.Read<> ()
233265,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"size_t SnapshotSerializer::Write(const SnapshotMetadata& data) {
  if (is_debug) {
    std::string str = ToStr(data);
    Debug(""\nWrite<SnapshotMetadata>() %s\n"", str.c_str());
  }
  size_t written_total = 0;
  // We need the Node.js version, platform and arch to match because
  // Node.js may perform synchronizations that are platform-specific and they
  // can be changed in semver-patches.
  Debug(""Write snapshot type %d\n"", static_cast<uint8_t>(data.type));
  written_total += WriteArithmetic<uint8_t>(static_cast<uint8_t>(data.type));
  Debug(""Write Node.js version %s\n"", data.node_version.c_str());
  written_total += WriteString(data.node_version);
  Debug(""Write Node.js arch %s\n"", data.node_arch);
  written_total += WriteString(data.node_arch);
  Debug(""Write Node.js platform %s\n"", data.node_platform);
  written_total += WriteString(data.node_platform);
  Debug(""Write V8 cached data version tag %"" PRIx32 ""\n"",
        data.v8_cache_version_tag);
  written_total += WriteArithm...",1,1,node_snapshotable.cc,node.SnapshotSerializer.Write,,false,553,574,Write,,,33,size_t node.SnapshotSerializer.Write<> (SnapshotMetadata)
233354,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"std::vector<char> SnapshotData::ToBlob() const {
  SnapshotSerializer w;
  w.Debug(""SnapshotData::ToBlob()\n"");

  size_t written_total = 0;

  // Metadata
  w.Debug(""Write magic %"" PRIx32 ""\n"", kMagic);
  written_total += w.WriteArithmetic<uint32_t>(kMagic);
  w.Debug(""Write metadata\n"");
  written_total += w.Write<SnapshotMetadata>(metadata);

  written_total += w.Write<v8::StartupData>(v8_snapshot_blob_data);
  w.Debug(""Write isolate_data_indices\n"");
  written_total += w.Write<IsolateDataSerializeInfo>(isolate_data_info);
  written_total += w.Write<EnvSerializeInfo>(env_info);
  w.Debug(""Write code_cache\n"");
  written_total += w.WriteVector<builtins::CodeCacheInfo>(code_cache);
  w.Debug(""SnapshotData::ToBlob() Wrote %d bytes\n"", written_total);
  return w.sink;
}",1,1,node_snapshotable.cc,node.SnapshotData.ToBlob,,false,587,607,ToBlob,,,34,vector<char> node.SnapshotData.ToBlob ()
233452,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"void SnapshotData::ToFile(FILE* out) const {
  const std::vector<char> sink = ToBlob();
  size_t num_written = fwrite(sink.data(), sink.size(), 1, out);
  CHECK_EQ(num_written, 1);
  CHECK_EQ(fflush(out), 0);
}",1,1,node_snapshotable.cc,node.SnapshotData.ToFile,,false,609,614,ToFile,,,35,void node.SnapshotData.ToFile (FILE*)
233482,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"const SnapshotData* SnapshotData::FromEmbedderWrapper(
    const EmbedderSnapshotData* data) {
  return data != nullptr ? data->impl_ : nullptr;
}",1,1,node_snapshotable.cc,node.SnapshotData.FromEmbedderWrapper,,false,616,619,FromEmbedderWrapper,,,36,SnapshotData node.SnapshotData.FromEmbedderWrapper (EmbedderSnapshotData*)
233496,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"EmbedderSnapshotData::Pointer SnapshotData::AsEmbedderWrapper() const {
  return EmbedderSnapshotData::Pointer{new EmbedderSnapshotData(this, false)};
}",1,1,node_snapshotable.cc,node.SnapshotData.AsEmbedderWrapper,,false,621,623,AsEmbedderWrapper,,,37,Pointer node.SnapshotData.AsEmbedderWrapper ()
233507,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"bool SnapshotData::FromFile(SnapshotData* out, FILE* in) {
  return FromBlob(out, ReadFileSync(in));
}",1,1,node_snapshotable.cc,node.SnapshotData.FromFile,,false,625,627,FromFile,,,38,"bool node.SnapshotData.FromFile (SnapshotData*,FILE*)"
233518,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"bool SnapshotData::FromBlob(SnapshotData* out, const std::vector<char>& in) {
  return FromBlob(out, std::string_view(in.data(), in.size()));
}",1,1,node_snapshotable.cc,node.SnapshotData.FromBlob,,false,629,631,FromBlob,,,39,"bool node.SnapshotData.FromBlob (SnapshotData*,ANY)"
233539,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"bool SnapshotData::FromBlob(SnapshotData* out, std::string_view in) {
  SnapshotDeserializer r(in);
  r.Debug(""SnapshotData::FromBlob()\n"");

  DCHECK_EQ(out->data_ownership, SnapshotData::DataOwnership::kOwned);

  // Metadata
  uint32_t magic = r.ReadArithmetic<uint32_t>();
  r.Debug(""Read magic %"" PRIx32 ""\n"", magic);
  CHECK_EQ(magic, kMagic);
  out->metadata = r.Read<SnapshotMetadata>();
  r.Debug(""Read metadata\n"");
  if (!out->Check()) {
    return false;
  }

  out->v8_snapshot_blob_data = r.Read<v8::StartupData>();
  r.Debug(""Read isolate_data_info\n"");
  out->isolate_data_info = r.Read<IsolateDataSerializeInfo>();
  out->env_info = r.Read<EnvSerializeInfo>();
  r.Debug(""Read code_cache\n"");
  out->code_cache = r.ReadVector<builtins::CodeCacheInfo>();

  r.Debug(""SnapshotData::FromBlob() read %d bytes\n"", r.read_total);
  return true;
}",1,1,node_snapshotable.cc,node.SnapshotData.FromBlob,,false,633,658,FromBlob,,,40,"bool node.SnapshotData.FromBlob (SnapshotData*,ANY)"
233647,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"bool SnapshotData::Check() const {
  if (metadata.node_version != per_process::metadata.versions.node) {
    fprintf(stderr,
            ""Failed to load the startup snapshot because it was built with""
            ""Node.js version %s and the current Node.js version is %s.\n"",
            metadata.node_version.c_str(),
            NODE_VERSION);
    return false;
  }

  if (metadata.node_arch != per_process::metadata.arch) {
    fprintf(stderr,
            ""Failed to load the startup snapshot because it was built with""
            ""architecture %s and the architecture is %s.\n"",
            metadata.node_arch.c_str(),
            NODE_ARCH);
    return false;
  }

  if (metadata.node_platform != per_process::metadata.platform) {
    fprintf(stderr,
            ""Failed to load the startup snapshot because it was built with""
            ""platform %s and the current platform is %s.\n"",
            metadata.node_platform.c_str(),
            NODE_PLATFORM);
    return false;
  }

  uint32...",1,1,node_snapshotable.cc,node.SnapshotData.Check,,false,660,705,Check,,,41,bool node.SnapshotData.Check ()
233753,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"SnapshotData::~SnapshotData() {
  if (data_ownership == DataOwnership::kOwned &&
      v8_snapshot_blob_data.data != nullptr) {
    delete[] v8_snapshot_blob_data.data;
  }
}",1,1,node_snapshotable.cc,node.SnapshotData.~SnapshotData,,false,707,712,~SnapshotData,,,42,ANY node.SnapshotData.~SnapshotData ()
233774,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"void WriteVector(std::ostream* ss, const T* vec, size_t size) {
  for (size_t i = 0; i < size; i++) {
    *ss << std::to_string(vec[i]) << (i == size - 1 ? '\n' : ',');
  }
}",1,1,node_snapshotable.cc,node.WriteVector,,false,715,719,WriteVector,,,43,"void node.WriteVector<T> (ANY*,T*,size_t)"
233812,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"static std::string GetCodeCacheDefName(const std::string& id) {
  char buf[64] = {0};
  size_t size = id.size();
  CHECK_LT(size, sizeof(buf));
  for (size_t i = 0; i < size; ++i) {
    char ch = id[i];
    buf[i] = (ch == '-' || ch == '/') ? '_' : ch;
  }
  return std::string(buf) + std::string(""_cache_data"");
}",1,1,node_snapshotable.cc,node.GetCodeCacheDefName,,false,721,730,GetCodeCacheDefName,,,44,string node.GetCodeCacheDefName (ANY)
233877,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"static std::string FormatSize(size_t size) {
  char buf[64] = {0};
  if (size < 1024) {
    snprintf(buf, sizeof(buf), ""%.2fB"", static_cast<double>(size));
  } else if (size < 1024 * 1024) {
    snprintf(buf, sizeof(buf), ""%.2fKB"", static_cast<double>(size / 1024));
  } else {
    snprintf(
        buf, sizeof(buf), ""%.2fMB"", static_cast<double>(size / 1024 / 1024));
  }
  return buf;
}",1,1,node_snapshotable.cc,node.FormatSize,,false,732,743,FormatSize,,,45,string node.FormatSize (size_t)
233935,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"static void WriteStaticCodeCacheDataAsArray(
    std::ostream* ss, const builtins::CodeCacheInfo& info) {
  *ss << ""static const uint8_t "" << GetCodeCacheDefName(info.id) << ""[] = {\n"";
  WriteVector(ss, info.data.data, info.data.length);
  *ss << ""};\n"";
}",1,1,node_snapshotable.cc,node.WriteStaticCodeCacheDataAsArray,,false,780,785,WriteStaticCodeCacheDataAsArray,,,46,"void node.WriteStaticCodeCacheDataAsArray (ANY*,ANY)"
233968,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"static void WriteCodeCacheInitializer(std::ostream* ss,
                                      const std::string& id,
                                      size_t size) {
  std::string def_name = GetCodeCacheDefName(id);
  *ss << ""    { \"""" << id << ""\"",\n"";
  *ss << ""      {"" << def_name << "",\n"";
  *ss << ""       "" << size << "",\n"";
  *ss << ""      }\n"";
  *ss << ""    },\n"";
}",1,1,node_snapshotable.cc,node.WriteCodeCacheInitializer,,false,788,797,WriteCodeCacheInitializer,,,47,"void node.WriteCodeCacheInitializer (ANY*,ANY,size_t)"
234012,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"void FormatBlob(std::ostream& ss, const SnapshotData* data) {
  ss << R""(#include <cstddef>
#include ""env.hpp""
#include ""node_snapshot_builder.hpp""
#include ""v8.hpp""

// This file is generated by tools/snapshot. Do not edit.

namespace node {
)"";

#ifdef NODE_MKSNAPSHOT_USE_STRING_LITERALS
  ss << R""(static const char *v8_snapshot_blob_data = "")"";
  WriteDataAsCharString(
      &ss,
      reinterpret_cast<const uint8_t*>(data->v8_snapshot_blob_data.data),
      data->v8_snapshot_blob_data.raw_size);
  ss << R""("";)"";
#else
  ss << R""(static const char v8_snapshot_blob_data[] = {)"";
  WriteVector(&ss,
              data->v8_snapshot_blob_data.data,
              data->v8_snapshot_blob_data.raw_size);
  ss << R""(};)"";
#endif

  ss << R""(static const int v8_snapshot_blob_size = )""
     << data->v8_snapshot_blob_data.raw_size << "";"";

  for (const auto& item : data->code_cache) {
#ifdef NODE_MKSNAPSHOT_USE_STRING_LITERALS
    WriteStaticCodeCacheDataAsStringLiteral(&ss, item);
#else
    ...",1,1,node_snapshotable.cc,node.FormatBlob,,false,799,874,FormatBlob,,,48,"void node.FormatBlob (ANY,SnapshotData*)"
234102,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"static void ResetContextSettingsBeforeSnapshot(Local<Context> context) {
  // Reset the AllowCodeGenerationFromStrings flag to true (default value) so
  // that it can be re-initialized with v8 flag
  // --disallow-code-generation-from-strings and recognized in
  // node::InitializeContextRuntime.
  context->AllowCodeGenerationFromStrings(true);
}",1,1,node_snapshotable.cc,node.ResetContextSettingsBeforeSnapshot,,false,878,884,ResetContextSettingsBeforeSnapshot,,,49,void node.ResetContextSettingsBeforeSnapshot (Local<Context>)
234112,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"const std::vector<intptr_t>& SnapshotBuilder::CollectExternalReferences() {
  static auto registry = std::make_unique<ExternalReferenceRegistry>();
  return registry->external_references();
}",1,1,node_snapshotable.cc,node.SnapshotBuilder.CollectExternalReferences,,false,886,889,CollectExternalReferences,,,50,vector<intptr_t> node.SnapshotBuilder.CollectExternalReferences ()
234128,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"void SnapshotBuilder::InitializeIsolateParams(const SnapshotData* data,
                                              Isolate::CreateParams* params) {
  CHECK_NULL(params->external_references);
  CHECK_NULL(params->snapshot_blob);
  params->external_references = CollectExternalReferences().data();
  params->snapshot_blob =
      const_cast<v8::StartupData*>(&(data->v8_snapshot_blob_data));
}",1,1,node_snapshotable.cc,node.SnapshotBuilder.InitializeIsolateParams,,false,891,898,InitializeIsolateParams,,,51,"void node.SnapshotBuilder.InitializeIsolateParams (SnapshotData*,ANY*)"
234160,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"ExitCode SnapshotBuilder::Generate(
    SnapshotData* out,
    const std::vector<std::string>& args,
    const std::vector<std::string>& exec_args,
    std::optional<std::string_view> main_script) {
  // The default snapshot is meant to be runtime-independent and has more
  // restrictions. We do not enable the inspector and do not run the event
  // loop when building the default snapshot to avoid inconsistencies, but
  // we do for the fully customized one, and they are expected to fixup the
  // inconsistencies using v8.startupSnapshot callbacks.
  SnapshotMetadata::Type snapshot_type =
      main_script.has_value() ? SnapshotMetadata::Type::kFullyCustomized
                              : SnapshotMetadata::Type::kDefault;

  std::vector<std::string> errors;
  auto setup = CommonEnvironmentSetup::CreateForSnapshotting(
      per_process::v8_platform.Platform(), &errors, args, exec_args);
  if (!setup) {
    for (const std::string& err : errors)
      fprintf(stderr, ""%s: %s\n"", a...",1,1,node_snapshotable.cc,node.SnapshotBuilder.Generate,,false,900,958,Generate,,,52,"ExitCode node.SnapshotBuilder.Generate (SnapshotData*,ANY,ANY,ANY)"
234320,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"ExitCode SnapshotBuilder::CreateSnapshot(SnapshotData* out,
                                         CommonEnvironmentSetup* setup,
                                         uint8_t snapshot_type_u8) {
  SnapshotMetadata::Type snapshot_type =
      static_cast<SnapshotMetadata::Type>(snapshot_type_u8);
  Isolate* isolate = setup->isolate();
  Environment* env = setup->env();
  SnapshotCreator* creator = setup->snapshot_creator();

  {
    HandleScope scope(isolate);
    Local<Context> main_context = setup->context();

    // The default context with only things created by V8.
    Local<Context> default_context = Context::New(isolate);

    // The context used by the vm module.
    Local<Context> vm_context;
    {
      Local<ObjectTemplate> global_template =
          setup->isolate_data()->contextify_global_template();
      CHECK(!global_template.IsEmpty());
      if (!contextify::ContextifyContext::CreateV8Context(
               isolate, global_template, nullptr, nullptr)
       ...",1,1,node_snapshotable.cc,node.SnapshotBuilder.CreateSnapshot,,false,960,1070,CreateSnapshot,,,53,"ExitCode node.SnapshotBuilder.CreateSnapshot (SnapshotData*,CommonEnvironmentSetup*,uint8_t)"
234641,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"ExitCode SnapshotBuilder::Generate(
    std::ostream& out,
    const std::vector<std::string>& args,
    const std::vector<std::string>& exec_args,
    std::optional<std::string_view> main_script) {
  SnapshotData data;
  ExitCode exit_code = Generate(&data, args, exec_args, main_script);
  if (exit_code != ExitCode::kNoFailure) {
    return exit_code;
  }
  FormatBlob(out, &data);
  return exit_code;
}",1,1,node_snapshotable.cc,node.SnapshotBuilder.Generate,,false,1072,1084,Generate,,,54,"ExitCode node.SnapshotBuilder.Generate (ANY,ANY,ANY,ANY)"
234674,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"SnapshotableObject::SnapshotableObject(Realm* realm,
                                       Local<Object> wrap,
                                       EmbedderObjectType type)
    : BaseObject(realm, wrap), type_(type) {}",1,45,node_snapshotable.cc,node.SnapshotableObject.SnapshotableObject,,false,1086,1089,SnapshotableObject,,,55,"ANY node.SnapshotableObject.SnapshotableObject (Realm*,Local<Object>,EmbedderObjectType)"
234681,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"std::string SnapshotableObject::GetTypeName() const {
  switch (type_) {
#define V(PropertyName, NativeTypeName)                                        \
  case EmbedderObjectType::k_##PropertyName: {                                 \
    return #NativeTypeName;                                                    \
  }
    SERIALIZABLE_OBJECT_TYPES(V)
#undef V
    default: { UNREACHABLE(); }
  }
}",1,1,node_snapshotable.cc,node.SnapshotableObject.GetTypeName,,false,1091,1101,GetTypeName,,,56,string node.SnapshotableObject.GetTypeName ()
234693,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"void DeserializeNodeInternalFields(Local<Object> holder,
                                   int index,
                                   StartupData payload,
                                   void* env) {
  if (payload.raw_size == 0) {
    holder->SetAlignedPointerInInternalField(index, nullptr);
    return;
  }
  per_process::Debug(DebugCategory::MKSNAPSHOT,
                     ""Deserialize internal field %d of %p, size=%d\n"",
                     static_cast<int>(index),
                     (*holder),
                     static_cast<int>(payload.raw_size));

  if (payload.raw_size == 0) {
    holder->SetAlignedPointerInInternalField(index, nullptr);
    return;
  }

  DCHECK_EQ(index, BaseObject::kEmbedderType);

  Environment* env_ptr = static_cast<Environment*>(env);
  const InternalFieldInfoBase* info =
      reinterpret_cast<const InternalFieldInfoBase*>(payload.data);
  // TODO(joyeecheung): we can add a constant kNodeEmbedderId to the
  // beginning of every InternalFie...",1,1,node_snapshotable.cc,node.DeserializeNodeInternalFields,,false,1103,1158,DeserializeNodeInternalFields,,,57,"void node.DeserializeNodeInternalFields (Local<Object>,int,StartupData,void*)"
234777,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"StartupData SerializeNodeContextInternalFields(Local<Object> holder,
                                               int index,
                                               void* env) {
  // We only do one serialization for the kEmbedderType slot, the result
  // contains everything necessary for deserializing the entire object,
  // including the fields whose index is bigger than kEmbedderType
  // (most importantly, BaseObject::kSlot).
  // For Node.js this design is enough for all the native binding that are
  // serializable.
  if (index != BaseObject::kEmbedderType || !BaseObject::IsBaseObject(holder)) {
    return StartupData{nullptr, 0};
  }

  per_process::Debug(DebugCategory::MKSNAPSHOT,
                     ""Serialize internal field, index=%d, holder=%p\n"",
                     static_cast<int>(index),
                     *holder);

  void* native_ptr =
      holder->GetAlignedPointerFromInternalField(BaseObject::kSlot);
  per_process::Debug(DebugCategory::MKSNAPSHOT, ""n...",1,1,node_snapshotable.cc,node.SerializeNodeContextInternalFields,,false,1160,1195,SerializeNodeContextInternalFields,,,58,"StartupData node.SerializeNodeContextInternalFields (Local<Object>,int,void*)"
234894,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"void SerializeSnapshotableObjects(Realm* realm,
                                  SnapshotCreator* creator,
                                  RealmSerializeInfo* info) {
  HandleScope scope(realm->isolate());
  Local<Context> context = realm->context();
  uint32_t i = 0;
  realm->ForEachBaseObject([&](BaseObject* obj) {
    // If there are any BaseObjects that are not snapshotable left
    // during context serialization, V8 would crash due to unregistered
    // global handles and print detailed information about them.
    if (!obj->is_snapshotable()) {
      return;
    }
    SnapshotableObject* ptr = static_cast<SnapshotableObject*>(obj);

    std::string type_name = ptr->GetTypeName();
    per_process::Debug(DebugCategory::MKSNAPSHOT,
                       ""Serialize snapshotable object %i (%p), ""
                       ""object=%p, type=%s\n"",
                       static_cast<int>(i),
                       ptr,
                       *(ptr->object()),
                       ...",1,1,node_snapshotable.cc,node.SerializeSnapshotableObjects,,false,1197,1230,SerializeSnapshotableObjects,,,59,"void node.SerializeSnapshotableObjects (Realm*,SnapshotCreator*,RealmSerializeInfo*)"
234923,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"static void RunEmbedderEntryPoint(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Local<Value> process_obj = args[0];
  Local<Value> require_fn = args[1];
  Local<Value> runcjs_fn = args[2];
  CHECK(process_obj->IsObject());
  CHECK(require_fn->IsFunction());
  CHECK(runcjs_fn->IsFunction());

  const node::StartExecutionCallback& callback = env->embedder_entry_point();
  node::StartExecutionCallbackInfo info{process_obj.As<Object>(),
                                        require_fn.As<Function>(),
                                        runcjs_fn.As<Function>()};
  MaybeLocal<Value> retval = callback(info);
  if (!retval.IsEmpty()) {
    args.GetReturnValue().Set(retval.ToLocalChecked());
  }
}",1,1,node_snapshotable.cc,node.RunEmbedderEntryPoint,,false,1232,1249,RunEmbedderEntryPoint,,,60,void node.RunEmbedderEntryPoint (FunctionCallbackInfo<Value>)
235027,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"void CompileSerializeMain(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsString());
  Local<String> filename = args[0].As<String>();
  Local<String> source = args[1].As<String>();
  Isolate* isolate = args.GetIsolate();
  Local<Context> context = isolate->GetCurrentContext();
  ScriptOrigin origin(isolate, filename, 0, 0, true);
  // TODO(joyeecheung): do we need all of these? Maybe we would want a less
  // internal version of them.
  std::vector<Local<String>> parameters = {
      FIXED_ONE_BYTE_STRING(isolate, ""require""),
      FIXED_ONE_BYTE_STRING(isolate, ""__filename""),
      FIXED_ONE_BYTE_STRING(isolate, ""__dirname""),
  };
  ScriptCompiler::Source script_source(source, origin);
  Local<Function> fn;
  if (ScriptCompiler::CompileFunction(context,
                                      &script_source,
                                      parameters.size(),
                                      parameters.data(),
                                      0,
         ...",1,1,node_snapshotable.cc,node.CompileSerializeMain,,false,1251,1277,CompileSerializeMain,,,61,void node.CompileSerializeMain (FunctionCallbackInfo<Value>)
235141,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"void SetSerializeCallback(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(env->snapshot_serialize_callback().IsEmpty());
  CHECK(args[0]->IsFunction());
  env->set_snapshot_serialize_callback(args[0].As<Function>());
}",1,1,node_snapshotable.cc,node.SetSerializeCallback,,false,1279,1284,SetSerializeCallback,,,62,void node.SetSerializeCallback (FunctionCallbackInfo<Value>)
235179,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"void SetDeserializeCallback(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(env->snapshot_deserialize_callback().IsEmpty());
  CHECK(args[0]->IsFunction());
  env->set_snapshot_deserialize_callback(args[0].As<Function>());
}",1,1,node_snapshotable.cc,node.SetDeserializeCallback,,false,1286,1291,SetDeserializeCallback,,,63,void node.SetDeserializeCallback (FunctionCallbackInfo<Value>)
235217,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"void SetDeserializeMainFunction(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(env->snapshot_deserialize_main().IsEmpty());
  CHECK(args[0]->IsFunction());
  env->set_snapshot_deserialize_main(args[0].As<Function>());
}",1,1,node_snapshotable.cc,node.SetDeserializeMainFunction,,false,1293,1298,SetDeserializeMainFunction,,,64,void node.SetDeserializeMainFunction (FunctionCallbackInfo<Value>)
235259,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"std::string GetAnonymousMainPath() {
  return kAnonymousMainPath;
}",1,1,node_snapshotable.cc,node.GetAnonymousMainPath,,false,1302,1304,GetAnonymousMainPath,,,67,string node.GetAnonymousMainPath ()
235266,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"BindingData::BindingData(Realm* realm,
                         v8::Local<v8::Object> object,
                         InternalFieldInfo* info)
    : SnapshotableObject(realm, object, type_int),
      is_building_snapshot_buffer_(
          realm->isolate(),
          1,
          MAYBE_FIELD_PTR(info, is_building_snapshot_buffer)) {
  if (info == nullptr) {
    object
        ->Set(
            realm->context(),
            FIXED_ONE_BYTE_STRING(realm->isolate(), ""isBuildingSnapshotBuffer""),
            is_building_snapshot_buffer_.GetJSArray())
        .Check();
  } else {
    is_building_snapshot_buffer_.Deserialize(realm->context());
  }
  // Reset the status according to the current state of the realm.
  bool is_building_snapshot = realm->isolate_data()->is_building_snapshot();
  DCHECK_IMPLIES(is_building_snapshot,
                 realm->isolate_data()->snapshot_data() == nullptr);
  is_building_snapshot_buffer_[0] = is_building_snapshot ? 1 : 0;
  is_building_snapshot_buffer...",1,1,node_snapshotable.cc,node.mksnapshot.BindingData.BindingData,,false,1308,1332,BindingData,,,1,"ANY node.mksnapshot.BindingData.BindingData (Realm*,ANY,InternalFieldInfo*)"
235342,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"bool BindingData::PrepareForSerialization(Local<Context> context,
                                          v8::SnapshotCreator* creator) {
  DCHECK_NULL(internal_field_info_);
  internal_field_info_ = InternalFieldInfoBase::New<InternalFieldInfo>(type());
  internal_field_info_->is_building_snapshot_buffer =
      is_building_snapshot_buffer_.Serialize(context, creator);
  // Return true because we need to maintain the reference to the binding from
  // JS land.
  return true;
}",1,1,node_snapshotable.cc,node.mksnapshot.BindingData.PrepareForSerialization,,false,1334,1343,PrepareForSerialization,,,2,"bool node.mksnapshot.BindingData.PrepareForSerialization (Local<Context>,ANY*)"
235370,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"InternalFieldInfoBase* BindingData::Serialize(int index) {
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info = internal_field_info_;
  internal_field_info_ = nullptr;
  return info;
}",1,1,node_snapshotable.cc,node.mksnapshot.BindingData.Serialize,,false,1345,1350,Serialize,,,3,InternalFieldInfoBase node.mksnapshot.BindingData.Serialize (int)
235389,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"void BindingData::Deserialize(Local<Context> context,
                              Local<Object> holder,
                              int index,
                              InternalFieldInfoBase* info) {
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  v8::HandleScope scope(context->GetIsolate());
  Realm* realm = Realm::GetCurrent(context);
  // Recreate the buffer in the constructor.
  InternalFieldInfo* casted_info = static_cast<InternalFieldInfo*>(info);
  BindingData* binding =
      realm->AddBindingData<BindingData>(context, holder, casted_info);
  CHECK_NOT_NULL(binding);
}",1,1,node_snapshotable.cc,node.mksnapshot.BindingData.Deserialize,,false,1352,1364,Deserialize,,,4,"void node.mksnapshot.BindingData.Deserialize (Local<Context>,Local<Object>,int,InternalFieldInfoBase*)"
235438,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"void BindingData::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""is_building_snapshot_buffer"",
                      is_building_snapshot_buffer_);
}",1,1,node_snapshotable.cc,node.mksnapshot.BindingData.MemoryInfo,,false,1366,1369,MemoryInfo,,,5,void node.mksnapshot.BindingData.MemoryInfo (MemoryTracker*)
235449,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"void CreatePerContextProperties(Local<Object> target,
                                Local<Value> unused,
                                Local<Context> context,
                                void* priv) {
  Realm* realm = Realm::GetCurrent(context);
  realm->AddBindingData<BindingData>(context, target);
}",1,1,node_snapshotable.cc,node.mksnapshot.CreatePerContextProperties,,false,1371,1377,CreatePerContextProperties,,,6,"void node.mksnapshot.CreatePerContextProperties (Local<Object>,Local<Value>,Local<Context>,void*)"
235475,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"void CreatePerIsolateProperties(IsolateData* isolate_data,
                                Local<ObjectTemplate> target) {
  Isolate* isolate = isolate_data->isolate();
  SetMethod(isolate, target, ""runEmbedderEntryPoint"", RunEmbedderEntryPoint);
  SetMethod(isolate, target, ""compileSerializeMain"", CompileSerializeMain);
  SetMethod(isolate, target, ""setSerializeCallback"", SetSerializeCallback);
  SetMethod(isolate, target, ""setDeserializeCallback"", SetDeserializeCallback);
  SetMethod(isolate,
            target,
            ""setDeserializeMainFunction"",
            SetDeserializeMainFunction);
  target->Set(FIXED_ONE_BYTE_STRING(isolate, ""anonymousMainPath""),
              OneByteString(isolate, kAnonymousMainPath));
}",1,1,node_snapshotable.cc,node.mksnapshot.CreatePerIsolateProperties,,false,1379,1392,CreatePerIsolateProperties,,,7,"void node.mksnapshot.CreatePerIsolateProperties (IsolateData*,Local<ObjectTemplate>)"
235523,METHOD,node_snapshotable.cc:<global>,TYPE_DECL,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(RunEmbedderEntryPoint);
  registry->Register(CompileSerializeMain);
  registry->Register(SetSerializeCallback);
  registry->Register(SetDeserializeCallback);
  registry->Register(SetDeserializeMainFunction);
}",1,1,node_snapshotable.cc,node.mksnapshot.RegisterExternalReferences,,false,1394,1400,RegisterExternalReferences,,,8,void node.mksnapshot.RegisterExternalReferences (ExternalReferenceRegistry*)
235563,METHOD,node_snapshotable.hpp:<global>,TYPE_DECL,<global>,1,35,node_snapshotable.hpp,node_snapshotable.hpp:<global>,,false,1,154,<global>,,,1,
235582,METHOD,node_sockaddr-inl.hpp:<global>,TYPE_DECL,<global>,1,35,node_sockaddr-inl.hpp,node_sockaddr-inl.hpp:<global>,,false,1,266,<global>,,,1,
235607,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,<global>,1,35,node_sockaddr-inl.hpp,node_sockaddr.cc:<global>,,false,1,888,<global>,,,1,
235611,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"SocketAddress FromUVHandle(F fn, const T& handle) {
  SocketAddress addr;
  int len = sizeof(sockaddr_storage);
  if (fn(&handle, addr.storage(), &len) == 0)
    CHECK_EQ(static_cast<size_t>(len), addr.length());
  else
    addr.storage()->sa_family = 0;
  return addr;
}",1,1,node_sockaddr.cc,node.anonymous_namespace_1.FromUVHandle,,false,29,37,FromUVHandle,,,1,"SocketAddress node.anonymous_namespace_1.FromUVHandle<T,F> (F,T)"
235656,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"bool SocketAddress::ToSockAddr(
    int32_t family,
    const char* host,
    uint32_t port,
    sockaddr_storage* addr) {
  switch (family) {
    case AF_INET:
      return uv_ip4_addr(
          host,
          port,
          reinterpret_cast<sockaddr_in*>(addr)) == 0;
    case AF_INET6:
      return uv_ip6_addr(
          host,
          port,
          reinterpret_cast<sockaddr_in6*>(addr)) == 0;
    default:
      UNREACHABLE();
  }
}",1,1,node_sockaddr.cc,node.SocketAddress.ToSockAddr,,false,40,59,ToSockAddr,,,2,"bool node.SocketAddress.ToSockAddr (int32_t,char*,uint32_t,sockaddr_storage*)"
235691,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"bool SocketAddress::New(
    const char* host,
    uint32_t port,
    SocketAddress* addr) {
  return New(AF_INET, host, port, addr) || New(AF_INET6, host, port, addr);
}",1,1,node_sockaddr.cc,node.SocketAddress.New,,false,61,66,New,,,3,"bool node.SocketAddress.New (char*,uint32_t,SocketAddress*)"
235710,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"bool SocketAddress::New(
    int32_t family,
    const char* host,
    uint32_t port,
    SocketAddress* addr) {
  return ToSockAddr(family, host, port,
                    reinterpret_cast<sockaddr_storage*>(addr->storage()));
}",1,1,node_sockaddr.cc,node.SocketAddress.New,,false,68,75,New,,,4,"bool node.SocketAddress.New (int32_t,char*,uint32_t,SocketAddress*)"
235729,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"size_t SocketAddress::Hash::operator()(const SocketAddress& addr) const {
  size_t hash = 0;
  switch (addr.family()) {
    case AF_INET: {
      const sockaddr_in* ipv4 =
          reinterpret_cast<const sockaddr_in*>(addr.raw());
      hash_combine(&hash, ipv4->sin_port, ipv4->sin_addr.s_addr);
      break;
    }
    case AF_INET6: {
      const sockaddr_in6* ipv6 =
          reinterpret_cast<const sockaddr_in6*>(addr.raw());
      const uint64_t* a =
          reinterpret_cast<const uint64_t*>(&ipv6->sin6_addr);
      hash_combine(&hash, ipv6->sin6_port, a[0], a[1]);
      break;
    }
    default:
      UNREACHABLE();
  }
  return hash;
}",1,1,node_sockaddr.cc,node.SocketAddress.Hash.operator (),,false,77,98,operator (),,,5,size_t node.SocketAddress.Hash.operator () (SocketAddress)
235806,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"SocketAddress SocketAddress::FromSockName(const uv_tcp_t& handle) {
  return FromUVHandle(uv_tcp_getsockname, handle);
}",1,1,node_sockaddr.cc,node.SocketAddress.FromSockName,,false,100,102,FromSockName,,,6,SocketAddress node.SocketAddress.FromSockName (uv_tcp_t)
235815,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"SocketAddress SocketAddress::FromSockName(const uv_udp_t& handle) {
  return FromUVHandle(uv_udp_getsockname, handle);
}",1,1,node_sockaddr.cc,node.SocketAddress.FromSockName,,false,104,106,FromSockName,,,7,SocketAddress node.SocketAddress.FromSockName (uv_udp_t)
235824,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"SocketAddress SocketAddress::FromPeerName(const uv_tcp_t& handle) {
  return FromUVHandle(uv_tcp_getpeername, handle);
}",1,1,node_sockaddr.cc,node.SocketAddress.FromPeerName,,false,108,110,FromPeerName,,,8,SocketAddress node.SocketAddress.FromPeerName (uv_tcp_t)
235833,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"SocketAddress SocketAddress::FromPeerName(const uv_udp_t& handle) {
  return FromUVHandle(uv_udp_getpeername, handle);
}",1,1,node_sockaddr.cc,node.SocketAddress.FromPeerName,,false,112,114,FromPeerName,,,9,SocketAddress node.SocketAddress.FromPeerName (uv_udp_t)
235859,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"bool is_match_ipv4(
    const SocketAddress& one,
    const SocketAddress& two) {
  const sockaddr_in* one_in =
      reinterpret_cast<const sockaddr_in*>(one.data());
  const sockaddr_in* two_in =
      reinterpret_cast<const sockaddr_in*>(two.data());
  return memcmp(&one_in->sin_addr, &two_in->sin_addr, sizeof(uint32_t)) == 0;
}",1,1,node_sockaddr.cc,node.anonymous_namespace_3.is_match_ipv4,,false,119,127,is_match_ipv4,,,3,"bool node.anonymous_namespace_3.is_match_ipv4 (SocketAddress,SocketAddress)"
235897,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"bool is_match_ipv6(
    const SocketAddress& one,
    const SocketAddress& two) {
  const sockaddr_in6* one_in =
      reinterpret_cast<const sockaddr_in6*>(one.data());
  const sockaddr_in6* two_in =
      reinterpret_cast<const sockaddr_in6*>(two.data());
  return memcmp(&one_in->sin6_addr, &two_in->sin6_addr, 16) == 0;
}",1,1,node_sockaddr.cc,node.anonymous_namespace_4.is_match_ipv6,,false,129,137,is_match_ipv6,,,4,"bool node.anonymous_namespace_4.is_match_ipv6 (SocketAddress,SocketAddress)"
235934,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"bool is_match_ipv4_ipv6(
    const SocketAddress& ipv4,
    const SocketAddress& ipv6) {
  const sockaddr_in* check_ipv4 =
      reinterpret_cast<const sockaddr_in*>(ipv4.data());
  const sockaddr_in6* check_ipv6 =
      reinterpret_cast<const sockaddr_in6*>(ipv6.data());

  const uint8_t* ptr =
      reinterpret_cast<const uint8_t*>(&check_ipv6->sin6_addr);

  return memcmp(ptr, mask, sizeof(mask)) == 0 &&
         memcmp(ptr + sizeof(mask),
                &check_ipv4->sin_addr,
                sizeof(uint32_t)) == 0;
}",1,1,node_sockaddr.cc,node.anonymous_namespace_5.is_match_ipv4_ipv6,,false,139,154,is_match_ipv4_ipv6,,,5,"bool node.anonymous_namespace_5.is_match_ipv4_ipv6 (SocketAddress,SocketAddress)"
235989,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"SocketAddress::CompareResult compare_ipv4(
    const SocketAddress& one,
    const SocketAddress& two) {
  const sockaddr_in* one_in =
      reinterpret_cast<const sockaddr_in*>(one.data());
  const sockaddr_in* two_in =
      reinterpret_cast<const sockaddr_in*>(two.data());
  const uint32_t s_addr_one = ntohl(one_in->sin_addr.s_addr);
  const uint32_t s_addr_two = ntohl(two_in->sin_addr.s_addr);

  if (s_addr_one < s_addr_two)
    return SocketAddress::CompareResult::LESS_THAN;
  else if (s_addr_one == s_addr_two)
    return SocketAddress::CompareResult::SAME;
  else
    return SocketAddress::CompareResult::GREATER_THAN;
}",1,1,node_sockaddr.cc,node.anonymous_namespace_6.compare_ipv4,,false,156,172,compare_ipv4,,,6,"CompareResult node.anonymous_namespace_6.compare_ipv4 (SocketAddress,SocketAddress)"
236063,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"SocketAddress::CompareResult compare_ipv6(
    const SocketAddress& one,
    const SocketAddress& two) {
  const sockaddr_in6* one_in =
      reinterpret_cast<const sockaddr_in6*>(one.data());
  const sockaddr_in6* two_in =
      reinterpret_cast<const sockaddr_in6*>(two.data());
  int ret = memcmp(&one_in->sin6_addr, &two_in->sin6_addr, 16);
  if (ret < 0)
    return SocketAddress::CompareResult::LESS_THAN;
  else if (ret > 0)
    return SocketAddress::CompareResult::GREATER_THAN;
  return SocketAddress::CompareResult::SAME;
}",1,1,node_sockaddr.cc,node.anonymous_namespace_7.compare_ipv6,,false,174,187,compare_ipv6,,,7,"CompareResult node.anonymous_namespace_7.compare_ipv6 (SocketAddress,SocketAddress)"
236130,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"SocketAddress::CompareResult compare_ipv4_ipv6(
    const SocketAddress& ipv4,
    const SocketAddress& ipv6) {
  const sockaddr_in* ipv4_in =
      reinterpret_cast<const sockaddr_in*>(ipv4.data());
  const sockaddr_in6 * ipv6_in =
      reinterpret_cast<const sockaddr_in6*>(ipv6.data());

  const uint8_t* ptr =
      reinterpret_cast<const uint8_t*>(&ipv6_in->sin6_addr);

  if (memcmp(ptr, mask, sizeof(mask)) != 0)
    return SocketAddress::CompareResult::NOT_COMPARABLE;

  int ret = memcmp(
      &ipv4_in->sin_addr,
      ptr + sizeof(mask),
      sizeof(uint32_t));

  if (ret < 0)
    return SocketAddress::CompareResult::LESS_THAN;
  else if (ret > 0)
    return SocketAddress::CompareResult::GREATER_THAN;
  return SocketAddress::CompareResult::SAME;
}",1,1,node_sockaddr.cc,node.anonymous_namespace_8.compare_ipv4_ipv6,,false,189,213,compare_ipv4_ipv6,,,8,"CompareResult node.anonymous_namespace_8.compare_ipv4_ipv6 (SocketAddress,SocketAddress)"
236222,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"bool in_network_ipv4(
    const SocketAddress& ip,
    const SocketAddress& net,
    int prefix) {
  uint32_t mask = ((1ull << prefix) - 1) << (32 - prefix);

  const sockaddr_in* ip_in =
      reinterpret_cast<const sockaddr_in*>(ip.data());
  const sockaddr_in* net_in =
      reinterpret_cast<const sockaddr_in*>(net.data());

  return (htonl(ip_in->sin_addr.s_addr) & mask) ==
         (htonl(net_in->sin_addr.s_addr) & mask);
}",1,1,node_sockaddr.cc,node.anonymous_namespace_9.in_network_ipv4,,false,215,228,in_network_ipv4,,,9,"bool node.anonymous_namespace_9.in_network_ipv4 (SocketAddress,SocketAddress,int)"
236277,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"bool in_network_ipv6(
    const SocketAddress& ip,
    const SocketAddress& net,
    int prefix) {
  // Special case, if prefix == 128, then just do a
  // straight comparison.
  if (prefix == 128)
    return compare_ipv6(ip, net) == SocketAddress::CompareResult::SAME;

  uint8_t r = prefix % 8;
  int len = (prefix - r) / 8;
  uint8_t mask = ((1 << r) - 1) << (8 - r);

  const sockaddr_in6* ip_in =
      reinterpret_cast<const sockaddr_in6*>(ip.data());
  const sockaddr_in6* net_in =
      reinterpret_cast<const sockaddr_in6*>(net.data());

  if (memcmp(&ip_in->sin6_addr, &net_in->sin6_addr, len) != 0)
    return false;

  const uint8_t* p1 = reinterpret_cast<const uint8_t*>(
      ip_in->sin6_addr.s6_addr);
  const uint8_t* p2 = reinterpret_cast<const uint8_t*>(
      net_in->sin6_addr.s6_addr);

  return (p1[len] & mask) == (p2[len] & mask);
}",1,1,node_sockaddr.cc,node.anonymous_namespace_10.in_network_ipv6,,false,230,257,in_network_ipv6,,,10,"bool node.anonymous_namespace_10.in_network_ipv6 (SocketAddress,SocketAddress,int)"
236391,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"bool in_network_ipv4_ipv6(
    const SocketAddress& ip,
    const SocketAddress& net,
    int prefix) {

  if (prefix == 128)
    return compare_ipv4_ipv6(ip, net) == SocketAddress::CompareResult::SAME;

  uint8_t r = prefix % 8;
  int len = (prefix - r) / 8;
  uint8_t mask = ((1 << r) - 1) << (8 - r);

  const sockaddr_in* ip_in =
      reinterpret_cast<const sockaddr_in*>(ip.data());
  const sockaddr_in6* net_in =
      reinterpret_cast<const sockaddr_in6*>(net.data());

  uint8_t ip_mask[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff, 0, 0, 0, 0};
  uint8_t* ptr = ip_mask;
  memcpy(ptr + 12, &ip_in->sin_addr, 4);

  if (memcmp(ptr, &net_in->sin6_addr, len) != 0)
    return false;

  ptr += len;
  const uint8_t* p2 = reinterpret_cast<const uint8_t*>(
      net_in->sin6_addr.s6_addr);

  return (ptr[0] & mask) == (p2[len] & mask);
}",1,1,node_sockaddr.cc,node.anonymous_namespace_12.in_network_ipv4_ipv6,,false,259,288,in_network_ipv4_ipv6,,,11,"bool node.anonymous_namespace_12.in_network_ipv4_ipv6 (SocketAddress,SocketAddress,int)"
236528,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"bool in_network_ipv6_ipv4(
    const SocketAddress& ip,
    const SocketAddress& net,
    int prefix) {
  if (prefix == 32)
    return compare_ipv4_ipv6(net, ip) == SocketAddress::CompareResult::SAME;

  uint32_t m = ((1ull << prefix) - 1) << (32 - prefix);

  const sockaddr_in6* ip_in =
      reinterpret_cast<const sockaddr_in6*>(ip.data());
  const sockaddr_in* net_in =
      reinterpret_cast<const sockaddr_in*>(net.data());

  const uint8_t* ptr =
      reinterpret_cast<const uint8_t*>(&ip_in->sin6_addr);

  if (memcmp(ptr, mask, sizeof(mask)) != 0)
    return false;

  ptr += sizeof(mask);
  uint32_t check = ReadUint32BE(ptr);

  return (check & m) == (htonl(net_in->sin_addr.s_addr) & m);
}",1,1,node_sockaddr.cc,node.anonymous_namespace_14.in_network_ipv6_ipv4,,false,290,314,in_network_ipv6_ipv4,,,12,"bool node.anonymous_namespace_14.in_network_ipv6_ipv4 (SocketAddress,SocketAddress,int)"
236622,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"bool SocketAddress::is_match(const SocketAddress& other) const {
  switch (family()) {
    case AF_INET:
      switch (other.family()) {
        case AF_INET: return is_match_ipv4(*this, other);
        case AF_INET6: return is_match_ipv4_ipv6(*this, other);
      }
      break;
    case AF_INET6:
      switch (other.family()) {
        case AF_INET: return is_match_ipv4_ipv6(other, *this);
        case AF_INET6: return is_match_ipv6(*this, other);
      }
      break;
  }
  return false;
}",1,1,node_sockaddr.cc,node.SocketAddress.is_match,,false,321,337,is_match,,,11,bool node.SocketAddress.is_match (SocketAddress)
236678,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"SocketAddress::CompareResult SocketAddress::compare(
    const SocketAddress& other) const {
  switch (family()) {
    case AF_INET:
      switch (other.family()) {
        case AF_INET: return compare_ipv4(*this, other);
        case AF_INET6: return compare_ipv4_ipv6(*this, other);
      }
      break;
    case AF_INET6:
      switch (other.family()) {
        case AF_INET: {
          CompareResult c = compare_ipv4_ipv6(other, *this);
          switch (c) {
            case SocketAddress::CompareResult::NOT_COMPARABLE:
              // Fall through
            case SocketAddress::CompareResult::SAME:
              return c;
            case SocketAddress::CompareResult::GREATER_THAN:
              return SocketAddress::CompareResult::LESS_THAN;
            case SocketAddress::CompareResult::LESS_THAN:
              return SocketAddress::CompareResult::GREATER_THAN;
          }
          break;
        }
        case AF_INET6: return compare_ipv6(*this, other);
      }
      break...",1,1,node_sockaddr.cc,node.SocketAddress.compare,,false,339,369,compare,,,12,CompareResult node.SocketAddress.compare (SocketAddress)
236783,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"bool SocketAddress::is_in_network(
    const SocketAddress& other,
    int prefix) const {

  switch (family()) {
    case AF_INET:
      switch (other.family()) {
        case AF_INET: return in_network_ipv4(*this, other, prefix);
        case AF_INET6: return in_network_ipv4_ipv6(*this, other, prefix);
      }
      break;
    case AF_INET6:
      switch (other.family()) {
        case AF_INET: return in_network_ipv6_ipv4(*this, other, prefix);
        case AF_INET6: return in_network_ipv6(*this, other, prefix);
      }
      break;
  }

  return false;
}",1,1,node_sockaddr.cc,node.SocketAddress.is_in_network,,false,371,391,is_in_network,,,13,"bool node.SocketAddress.is_in_network (SocketAddress,int)"
236844,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"SocketAddressBlockList::SocketAddressBlockList(
    std::shared_ptr<SocketAddressBlockList> parent)
    : parent_(parent) {}",1,24,node_sockaddr.cc,node.SocketAddressBlockList.SocketAddressBlockList,,false,393,395,SocketAddressBlockList,,,14,ANY node.SocketAddressBlockList.SocketAddressBlockList (ANY)
236849,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"void SocketAddressBlockList::AddSocketAddress(
    const std::shared_ptr<SocketAddress>& address) {
  Mutex::ScopedLock lock(mutex_);
  std::unique_ptr<Rule> rule =
      std::make_unique<SocketAddressRule>(address);
  rules_.emplace_front(std::move(rule));
  address_rules_[*address.get()] = rules_.begin();
}",1,1,node_sockaddr.cc,node.SocketAddressBlockList.AddSocketAddress,,false,397,404,AddSocketAddress,,,15,void node.SocketAddressBlockList.AddSocketAddress (ANY)
236893,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"void SocketAddressBlockList::RemoveSocketAddress(
    const std::shared_ptr<SocketAddress>& address) {
  Mutex::ScopedLock lock(mutex_);
  auto it = address_rules_.find(*address.get());
  if (it != std::end(address_rules_)) {
    rules_.erase(it->second);
    address_rules_.erase(it);
  }
}",1,1,node_sockaddr.cc,node.SocketAddressBlockList.RemoveSocketAddress,,false,406,414,RemoveSocketAddress,,,16,void node.SocketAddressBlockList.RemoveSocketAddress (ANY)
236934,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"void SocketAddressBlockList::AddSocketAddressRange(
    const std::shared_ptr<SocketAddress>& start,
    const std::shared_ptr<SocketAddress>& end) {
  Mutex::ScopedLock lock(mutex_);
  std::unique_ptr<Rule> rule =
      std::make_unique<SocketAddressRangeRule>(start, end);
  rules_.emplace_front(std::move(rule));
}",1,1,node_sockaddr.cc,node.SocketAddressBlockList.AddSocketAddressRange,,false,416,423,AddSocketAddressRange,,,17,"void node.SocketAddressBlockList.AddSocketAddressRange (ANY,ANY)"
236970,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"void SocketAddressBlockList::AddSocketAddressMask(
    const std::shared_ptr<SocketAddress>& network,
    int prefix) {
  Mutex::ScopedLock lock(mutex_);
  std::unique_ptr<Rule> rule =
      std::make_unique<SocketAddressMaskRule>(network, prefix);
  rules_.emplace_front(std::move(rule));
}",1,1,node_sockaddr.cc,node.SocketAddressBlockList.AddSocketAddressMask,,false,425,432,AddSocketAddressMask,,,18,"void node.SocketAddressBlockList.AddSocketAddressMask (ANY,int)"
237006,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"bool SocketAddressBlockList::Apply(
    const std::shared_ptr<SocketAddress>& address) {
  Mutex::ScopedLock lock(mutex_);
  for (const auto& rule : rules_) {
    if (rule->Apply(address))
      return true;
  }
  return parent_ ? parent_->Apply(address) : false;
}",1,1,node_sockaddr.cc,node.SocketAddressBlockList.Apply,,false,434,442,Apply,,,19,bool node.SocketAddressBlockList.Apply (ANY)
237036,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"SocketAddressBlockList::SocketAddressRule::SocketAddressRule(
    const std::shared_ptr<SocketAddress>& address_)
    : address(address_) {}",1,26,node_sockaddr.cc,node.SocketAddressBlockList.SocketAddressRule.SocketAddressRule,,false,444,446,SocketAddressRule,,,20,ANY node.SocketAddressBlockList.SocketAddressRule.SocketAddressRule (ANY)
237041,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"SocketAddressBlockList::SocketAddressRangeRule::SocketAddressRangeRule(
    const std::shared_ptr<SocketAddress>& start_,
    const std::shared_ptr<SocketAddress>& end_)
    : start(start_),
      end(end_) {}",1,18,node_sockaddr.cc,node.SocketAddressBlockList.SocketAddressRangeRule.SocketAddressRangeRule,,false,448,452,SocketAddressRangeRule,,,21,"ANY node.SocketAddressBlockList.SocketAddressRangeRule.SocketAddressRangeRule (ANY,ANY)"
237047,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"SocketAddressBlockList::SocketAddressMaskRule::SocketAddressMaskRule(
    const std::shared_ptr<SocketAddress>& network_,
    int prefix_)
    : network(network_),
      prefix(prefix_) {}",1,24,node_sockaddr.cc,node.SocketAddressBlockList.SocketAddressMaskRule.SocketAddressMaskRule,,false,454,458,SocketAddressMaskRule,,,22,"ANY node.SocketAddressBlockList.SocketAddressMaskRule.SocketAddressMaskRule (ANY,int)"
237053,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"bool SocketAddressBlockList::SocketAddressRule::Apply(
    const std::shared_ptr<SocketAddress>& address) {
  return this->address->is_match(*address.get());
}",1,1,node_sockaddr.cc,node.SocketAddressBlockList.SocketAddressRule.Apply,,false,460,463,Apply,,,23,bool node.SocketAddressBlockList.SocketAddressRule.Apply (ANY)
237070,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"std::string SocketAddressBlockList::SocketAddressRule::ToString() {
  std::string ret = ""Address: "";
  ret += address->family() == AF_INET ? ""IPv4"" : ""IPv6"";
  ret += "" "";
  ret += address->address();
  return ret;
}",1,1,node_sockaddr.cc,node.SocketAddressBlockList.SocketAddressRule.ToString,,false,465,471,ToString,,,24,string node.SocketAddressBlockList.SocketAddressRule.ToString ()
237100,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"bool SocketAddressBlockList::SocketAddressRangeRule::Apply(
    const std::shared_ptr<SocketAddress>& address) {
  return *address.get() >= *start.get() &&
         *address.get() <= *end.get();
}",1,1,node_sockaddr.cc,node.SocketAddressBlockList.SocketAddressRangeRule.Apply,,false,473,477,Apply,,,25,bool node.SocketAddressBlockList.SocketAddressRangeRule.Apply (ANY)
237129,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"std::string SocketAddressBlockList::SocketAddressRangeRule::ToString() {
  std::string ret = ""Range: "";
  ret += start->family() == AF_INET ? ""IPv4"" : ""IPv6"";
  ret += "" "";
  ret += start->address();
  ret += ""-"";
  ret += end->address();
  return ret;
}",1,1,node_sockaddr.cc,node.SocketAddressBlockList.SocketAddressRangeRule.ToString,,false,479,487,ToString,,,26,string node.SocketAddressBlockList.SocketAddressRangeRule.ToString ()
237168,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"bool SocketAddressBlockList::SocketAddressMaskRule::Apply(
    const std::shared_ptr<SocketAddress>& address) {
  return address->is_in_network(*network.get(), prefix);
}",1,1,node_sockaddr.cc,node.SocketAddressBlockList.SocketAddressMaskRule.Apply,,false,489,492,Apply,,,27,bool node.SocketAddressBlockList.SocketAddressMaskRule.Apply (ANY)
237184,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"std::string SocketAddressBlockList::SocketAddressMaskRule::ToString() {
  std::string ret = ""Subnet: "";
  ret += network->family() == AF_INET ? ""IPv4"" : ""IPv6"";
  ret += "" "";
  ret += network->address();
  ret += ""/"" + std::to_string(prefix);
  return ret;
}",1,1,node_sockaddr.cc,node.SocketAddressBlockList.SocketAddressMaskRule.ToString,,false,494,501,ToString,,,28,string node.SocketAddressBlockList.SocketAddressMaskRule.ToString ()
237223,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"MaybeLocal<Array> SocketAddressBlockList::ListRules(Environment* env) {
  Mutex::ScopedLock lock(mutex_);
  std::vector<Local<Value>> rules;
  if (!ListRules(env, &rules))
    return MaybeLocal<Array>();
  return Array::New(env->isolate(), rules.data(), rules.size());
}",1,1,node_sockaddr.cc,node.SocketAddressBlockList.ListRules,,false,503,509,ListRules,,,29,MaybeLocal<Array> node.SocketAddressBlockList.ListRules (Environment*)
237266,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"bool SocketAddressBlockList::ListRules(
    Environment* env,
    std::vector<v8::Local<v8::Value>>* rules) {
  if (parent_ && !parent_->ListRules(env, rules))
    return false;
  for (const auto& rule : rules_) {
    Local<Value> str;
    if (!rule->ToV8String(env).ToLocal(&str))
      return false;
    rules->push_back(str);
  }
  return true;
}",1,1,node_sockaddr.cc,node.SocketAddressBlockList.ListRules,,false,511,523,ListRules,,,30,"bool node.SocketAddressBlockList.ListRules (Environment*,ANY*)"
237316,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"void SocketAddressBlockList::MemoryInfo(node::MemoryTracker* tracker) const {
  tracker->TrackField(""rules"", rules_);
}",1,1,node_sockaddr.cc,node.SocketAddressBlockList.MemoryInfo,,false,525,527,MemoryInfo,,,31,void node.SocketAddressBlockList.MemoryInfo (ANY*)
237327,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"void SocketAddressBlockList::SocketAddressRule::MemoryInfo(
    node::MemoryTracker* tracker) const {
  tracker->TrackField(""address"", address);
}",1,1,node_sockaddr.cc,node.SocketAddressBlockList.SocketAddressRule.MemoryInfo,,false,529,532,MemoryInfo,,,32,void node.SocketAddressBlockList.SocketAddressRule.MemoryInfo (ANY*)
237338,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"void SocketAddressBlockList::SocketAddressRangeRule::MemoryInfo(
    node::MemoryTracker* tracker) const {
  tracker->TrackField(""start"", start);
  tracker->TrackField(""end"", end);
}",1,1,node_sockaddr.cc,node.SocketAddressBlockList.SocketAddressRangeRule.MemoryInfo,,false,534,538,MemoryInfo,,,33,void node.SocketAddressBlockList.SocketAddressRangeRule.MemoryInfo (ANY*)
237355,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"void SocketAddressBlockList::SocketAddressMaskRule::MemoryInfo(
    node::MemoryTracker* tracker) const {
  tracker->TrackField(""network"", network);
}",1,1,node_sockaddr.cc,node.SocketAddressBlockList.SocketAddressMaskRule.MemoryInfo,,false,540,543,MemoryInfo,,,34,void node.SocketAddressBlockList.SocketAddressMaskRule.MemoryInfo (ANY*)
237366,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"SocketAddressBlockListWrap::SocketAddressBlockListWrap(
    Environment* env,
    Local<Object> wrap,
    std::shared_ptr<SocketAddressBlockList> blocklist)
    : BaseObject(env, wrap),
      blocklist_(std::move(blocklist)) {
  MakeWeak();
}",1,1,node_sockaddr.cc,node.SocketAddressBlockListWrap.SocketAddressBlockListWrap,,false,545,552,SocketAddressBlockListWrap,,,35,"ANY node.SocketAddressBlockListWrap.SocketAddressBlockListWrap (Environment*,Local<Object>,ANY)"
237374,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"BaseObjectPtr<SocketAddressBlockListWrap> SocketAddressBlockListWrap::New(
    Environment* env) {
  Local<Object> obj;
  if (!env->blocklist_constructor_template()
          ->InstanceTemplate()
          ->NewInstance(env->context()).ToLocal(&obj)) {
    return BaseObjectPtr<SocketAddressBlockListWrap>();
  }
  BaseObjectPtr<SocketAddressBlockListWrap> wrap =
      MakeBaseObject<SocketAddressBlockListWrap>(env, obj);
  CHECK(wrap);
  return wrap;
}",1,1,node_sockaddr.cc,node.SocketAddressBlockListWrap.New,,false,554,566,New,,,36,BaseObjectPtr<SocketAddressBlockListWrap> node.SocketAddressBlockListWrap.New (Environment*)
237425,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"BaseObjectPtr<SocketAddressBlockListWrap> SocketAddressBlockListWrap::New(
    Environment* env,
    std::shared_ptr<SocketAddressBlockList> blocklist) {
  Local<Object> obj;
  if (!env->blocklist_constructor_template()
          ->InstanceTemplate()
          ->NewInstance(env->context()).ToLocal(&obj)) {
    return BaseObjectPtr<SocketAddressBlockListWrap>();
  }
  BaseObjectPtr<SocketAddressBlockListWrap> wrap =
      MakeBaseObject<SocketAddressBlockListWrap>(
          env,
          obj,
          std::move(blocklist));
  CHECK(wrap);
  return wrap;
}",1,1,node_sockaddr.cc,node.SocketAddressBlockListWrap.New,,false,568,584,New,,,37,"BaseObjectPtr<SocketAddressBlockListWrap> node.SocketAddressBlockListWrap.New (Environment*,ANY)"
237482,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"void SocketAddressBlockListWrap::New(
    const FunctionCallbackInfo<Value>& args) {
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new SocketAddressBlockListWrap(env, args.This());
}",1,1,node_sockaddr.cc,node.SocketAddressBlockListWrap.New,,false,586,591,New,,,38,void node.SocketAddressBlockListWrap.New (FunctionCallbackInfo<Value>)
237507,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"void SocketAddressBlockListWrap::AddAddress(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  SocketAddressBlockListWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK(SocketAddressBase::HasInstance(env, args[0]));
  SocketAddressBase* addr;
  ASSIGN_OR_RETURN_UNWRAP(&addr, args[0]);

  wrap->blocklist_->AddSocketAddress(addr->address());

  args.GetReturnValue().Set(true);
}",1,1,node_sockaddr.cc,node.SocketAddressBlockListWrap.AddAddress,,false,593,606,AddAddress,,,39,void node.SocketAddressBlockListWrap.AddAddress (FunctionCallbackInfo<Value>)
237562,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"void SocketAddressBlockListWrap::AddRange(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  SocketAddressBlockListWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK(SocketAddressBase::HasInstance(env, args[0]));
  CHECK(SocketAddressBase::HasInstance(env, args[1]));

  SocketAddressBase* start_addr;
  SocketAddressBase* end_addr;
  ASSIGN_OR_RETURN_UNWRAP(&start_addr, args[0]);
  ASSIGN_OR_RETURN_UNWRAP(&end_addr, args[1]);

  // Starting address must come before the end address
  if (*start_addr->address().get() > *end_addr->address().get())
    return args.GetReturnValue().Set(false);

  wrap->blocklist_->AddSocketAddressRange(
      start_addr->address(),
      end_addr->address());

  args.GetReturnValue().Set(true);
}",1,1,node_sockaddr.cc,node.SocketAddressBlockListWrap.AddRange,,false,608,631,AddRange,,,40,void node.SocketAddressBlockListWrap.AddRange (FunctionCallbackInfo<Value>)
237665,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"void SocketAddressBlockListWrap::AddSubnet(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  SocketAddressBlockListWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK(SocketAddressBase::HasInstance(env, args[0]));
  CHECK(args[1]->IsInt32());

  SocketAddressBase* addr;
  ASSIGN_OR_RETURN_UNWRAP(&addr, args[0]);

  int32_t prefix;
  if (!args[1]->Int32Value(env->context()).To(&prefix)) {
    return;
  }

  CHECK_IMPLIES(addr->address()->family() == AF_INET, prefix <= 32);
  CHECK_IMPLIES(addr->address()->family() == AF_INET6, prefix <= 128);
  CHECK_GE(prefix, 0);

  wrap->blocklist_->AddSocketAddressMask(addr->address(), prefix);

  args.GetReturnValue().Set(true);
}",1,1,node_sockaddr.cc,node.SocketAddressBlockListWrap.AddSubnet,,false,633,657,AddSubnet,,,41,void node.SocketAddressBlockListWrap.AddSubnet (FunctionCallbackInfo<Value>)
237777,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"void SocketAddressBlockListWrap::Check(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  SocketAddressBlockListWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK(SocketAddressBase::HasInstance(env, args[0]));
  SocketAddressBase* addr;
  ASSIGN_OR_RETURN_UNWRAP(&addr, args[0]);

  args.GetReturnValue().Set(wrap->blocklist_->Apply(addr->address()));
}",1,1,node_sockaddr.cc,node.SocketAddressBlockListWrap.Check,,false,659,670,Check,,,42,void node.SocketAddressBlockListWrap.Check (FunctionCallbackInfo<Value>)
237831,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"void SocketAddressBlockListWrap::GetRules(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  SocketAddressBlockListWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  Local<Array> rules;
  if (wrap->blocklist_->ListRules(env).ToLocal(&rules))
    args.GetReturnValue().Set(rules);
}",1,1,node_sockaddr.cc,node.SocketAddressBlockListWrap.GetRules,,false,672,680,GetRules,,,43,void node.SocketAddressBlockListWrap.GetRules (FunctionCallbackInfo<Value>)
237879,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"void SocketAddressBlockListWrap::MemoryInfo(MemoryTracker* tracker) const {
  blocklist_->MemoryInfo(tracker);
}",1,1,node_sockaddr.cc,node.SocketAddressBlockListWrap.MemoryInfo,,false,682,684,MemoryInfo,,,44,void node.SocketAddressBlockListWrap.MemoryInfo (MemoryTracker*)
237889,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"std::unique_ptr<worker::TransferData>
SocketAddressBlockListWrap::CloneForMessaging() const {
  return std::make_unique<TransferData>(this);
}",1,1,node_sockaddr.cc,node.SocketAddressBlockListWrap.CloneForMessaging,,false,686,689,CloneForMessaging,,,45,unique_ptr<worker::TransferData> node.SocketAddressBlockListWrap.CloneForMessaging ()
237901,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"bool SocketAddressBlockListWrap::HasInstance(
    Environment* env,
    Local<Value> value) {
  return GetConstructorTemplate(env)->HasInstance(value);
}",1,1,node_sockaddr.cc,node.SocketAddressBlockListWrap.HasInstance,,false,691,695,HasInstance,,,46,"bool node.SocketAddressBlockListWrap.HasInstance (Environment*,Local<Value>)"
237914,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"Local<FunctionTemplate> SocketAddressBlockListWrap::GetConstructorTemplate(
    Environment* env) {
  Local<FunctionTemplate> tmpl = env->blocklist_constructor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, SocketAddressBlockListWrap::New);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), ""BlockList""));
    tmpl->InstanceTemplate()->SetInternalFieldCount(kInternalFieldCount);
    SetProtoMethod(isolate, tmpl, ""addAddress"", AddAddress);
    SetProtoMethod(isolate, tmpl, ""addRange"", AddRange);
    SetProtoMethod(isolate, tmpl, ""addSubnet"", AddSubnet);
    SetProtoMethod(isolate, tmpl, ""check"", Check);
    SetProtoMethod(isolate, tmpl, ""getRules"", GetRules);
    env->set_blocklist_constructor_template(tmpl);
  }
  return tmpl;
}",1,1,node_sockaddr.cc,node.SocketAddressBlockListWrap.GetConstructorTemplate,,false,697,713,GetConstructorTemplate,,,47,Local<FunctionTemplate> node.SocketAddressBlockListWrap.GetConstructorTemplate (Environment*)
237999,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"void SocketAddressBlockListWrap::Initialize(
    Local<Object> target,
    Local<Value> unused,
    Local<Context> context,
    void* priv) {
  Environment* env = Environment::GetCurrent(context);

  SetConstructorFunction(context,
                         target,
                         ""BlockList"",
                         GetConstructorTemplate(env),
                         SetConstructorFunctionFlag::NONE);

  SocketAddressBase::Initialize(env, target);

  NODE_DEFINE_CONSTANT(target, AF_INET);
  NODE_DEFINE_CONSTANT(target, AF_INET6);
}",1,1,node_sockaddr.cc,node.SocketAddressBlockListWrap.Initialize,,false,715,732,Initialize,,,48,"void node.SocketAddressBlockListWrap.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
238036,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"BaseObjectPtr<BaseObject> SocketAddressBlockListWrap::TransferData::Deserialize(
    Environment* env,
    Local<Context> context,
    std::unique_ptr<worker::TransferData> self) {
  return New(env, std::move(blocklist_));
}",1,1,node_sockaddr.cc,node.SocketAddressBlockListWrap.TransferData.Deserialize,,false,734,739,Deserialize,,,49,"BaseObjectPtr<BaseObject> node.SocketAddressBlockListWrap.TransferData.Deserialize (Environment*,Local<Context>,ANY)"
238051,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"void SocketAddressBlockListWrap::TransferData::MemoryInfo(
    MemoryTracker* tracker) const {
  blocklist_->MemoryInfo(tracker);
}",1,1,node_sockaddr.cc,node.SocketAddressBlockListWrap.TransferData.MemoryInfo,,false,741,744,MemoryInfo,,,50,void node.SocketAddressBlockListWrap.TransferData.MemoryInfo (MemoryTracker*)
238061,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"bool SocketAddressBase::HasInstance(Environment* env, Local<Value> value) {
  return GetConstructorTemplate(env)->HasInstance(value);
}",1,1,node_sockaddr.cc,node.SocketAddressBase.HasInstance,,false,746,748,HasInstance,,,51,"bool node.SocketAddressBase.HasInstance (Environment*,Local<Value>)"
238074,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"Local<FunctionTemplate> SocketAddressBase::GetConstructorTemplate(
    Environment* env) {
  Local<FunctionTemplate> tmpl = env->socketaddress_constructor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, New);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), ""SocketAddress""));
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        SocketAddressBase::kInternalFieldCount);
    SetProtoMethod(isolate, tmpl, ""detail"", Detail);
    SetProtoMethod(isolate, tmpl, ""legacyDetail"", LegacyDetail);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""flowlabel"", GetFlowLabel);
    env->set_socketaddress_constructor_template(tmpl);
  }
  return tmpl;
}",1,1,node_sockaddr.cc,node.SocketAddressBase.GetConstructorTemplate,,false,750,765,GetConstructorTemplate,,,52,Local<FunctionTemplate> node.SocketAddressBase.GetConstructorTemplate (Environment*)
238149,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"void SocketAddressBase::Initialize(Environment* env, Local<Object> target) {
  SetConstructorFunction(env->context(),
                         target,
                         ""SocketAddress"",
                         GetConstructorTemplate(env),
                         SetConstructorFunctionFlag::NONE);
}",1,1,node_sockaddr.cc,node.SocketAddressBase.Initialize,,false,767,773,Initialize,,,53,"void node.SocketAddressBase.Initialize (Environment*,Local<Object>)"
238167,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"BaseObjectPtr<SocketAddressBase> SocketAddressBase::Create(
    Environment* env,
    std::shared_ptr<SocketAddress> address) {
  Local<Object> obj;
  if (!GetConstructorTemplate(env)
          ->InstanceTemplate()
          ->NewInstance(env->context()).ToLocal(&obj)) {
    return BaseObjectPtr<SocketAddressBase>();
  }

  return MakeBaseObject<SocketAddressBase>(env, obj, std::move(address));
}",1,1,node_sockaddr.cc,node.SocketAddressBase.Create,,false,775,786,Create,,,54,"BaseObjectPtr<SocketAddressBase> node.SocketAddressBase.Create (Environment*,ANY)"
238214,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"void SocketAddressBase::New(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(args.IsConstructCall());
  CHECK(args[0]->IsString());  // address
  CHECK(args[1]->IsInt32());  // port
  CHECK(args[2]->IsInt32());  // family
  CHECK(args[3]->IsUint32());  // flow label

  Utf8Value address(env->isolate(), args[0]);
  int32_t port = args[1].As<Int32>()->Value();
  int32_t family = args[2].As<Int32>()->Value();
  uint32_t flow_label = args[3].As<Uint32>()->Value();

  std::shared_ptr<SocketAddress> addr = std::make_shared<SocketAddress>();

  if (!SocketAddress::New(family, *address, port, addr.get()))
    return THROW_ERR_INVALID_ADDRESS(env);

  addr->set_flow_label(flow_label);

  new SocketAddressBase(env, args.This(), std::move(addr));
}",1,1,node_sockaddr.cc,node.SocketAddressBase.New,,false,788,809,New,,,55,void node.SocketAddressBase.New (FunctionCallbackInfo<Value>)
238352,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"void SocketAddressBase::Detail(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsObject());
  Local<Object> detail = args[0].As<Object>();

  SocketAddressBase* base;
  ASSIGN_OR_RETURN_UNWRAP(&base, args.Holder());

  Local<Value> address;
  if (!ToV8Value(env->context(), base->address_->address()).ToLocal(&address))
    return;

  if (detail->Set(env->context(), env->address_string(), address).IsJust() &&
      detail->Set(
          env->context(),
          env->port_string(),
          Int32::New(env->isolate(), base->address_->port())).IsJust() &&
      detail->Set(
          env->context(),
          env->family_string(),
          Int32::New(env->isolate(), base->address_->family())).IsJust() &&
      detail->Set(
          env->context(),
          env->flowlabel_string(),
          Uint32::New(env->isolate(), base->address_->flow_label()))
              .IsJust()) {
    args.GetReturnValue().Set(detail);
  }
}",1,1,node_sockaddr.cc,node.SocketAddressBase.Detail,,false,811,839,Detail,,,56,void node.SocketAddressBase.Detail (FunctionCallbackInfo<Value>)
238533,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"void SocketAddressBase::GetFlowLabel(const FunctionCallbackInfo<Value>& args) {
  SocketAddressBase* base;
  ASSIGN_OR_RETURN_UNWRAP(&base, args.Holder());
  args.GetReturnValue().Set(base->address_->flow_label());
}",1,1,node_sockaddr.cc,node.SocketAddressBase.GetFlowLabel,,false,841,845,GetFlowLabel,,,57,void node.SocketAddressBase.GetFlowLabel (FunctionCallbackInfo<Value>)
238559,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"void SocketAddressBase::LegacyDetail(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  SocketAddressBase* base;
  ASSIGN_OR_RETURN_UNWRAP(&base, args.Holder());
  Local<Object> address;
  if (!base->address_->ToJS(env).ToLocal(&address)) return;
  args.GetReturnValue().Set(address);
}",1,1,node_sockaddr.cc,node.SocketAddressBase.LegacyDetail,,false,847,854,LegacyDetail,,,58,void node.SocketAddressBase.LegacyDetail (FunctionCallbackInfo<Value>)
238609,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"SocketAddressBase::SocketAddressBase(
    Environment* env,
    Local<Object> wrap,
    std::shared_ptr<SocketAddress> address)
    : BaseObject(env, wrap),
      address_(std::move(address)) {
  MakeWeak();
}",1,1,node_sockaddr.cc,node.SocketAddressBase.SocketAddressBase,,false,856,863,SocketAddressBase,,,59,"ANY node.SocketAddressBase.SocketAddressBase (Environment*,Local<Object>,ANY)"
238617,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"void SocketAddressBase::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""address"", address_);
}",1,1,node_sockaddr.cc,node.SocketAddressBase.MemoryInfo,,false,865,867,MemoryInfo,,,60,void node.SocketAddressBase.MemoryInfo (MemoryTracker*)
238628,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"std::unique_ptr<worker::TransferData>
SocketAddressBase::CloneForMessaging() const {
  return std::make_unique<TransferData>(this);
}",1,1,node_sockaddr.cc,node.SocketAddressBase.CloneForMessaging,,false,869,872,CloneForMessaging,,,61,unique_ptr<worker::TransferData> node.SocketAddressBase.CloneForMessaging ()
238640,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"void SocketAddressBase::TransferData::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""address"", address_);
}",1,1,node_sockaddr.cc,node.SocketAddressBase.TransferData.MemoryInfo,,false,874,876,MemoryInfo,,,62,void node.SocketAddressBase.TransferData.MemoryInfo (MemoryTracker*)
238651,METHOD,node_sockaddr.cc:<global>,TYPE_DECL,"BaseObjectPtr<BaseObject> SocketAddressBase::TransferData::Deserialize(
    Environment* env,
    v8::Local<v8::Context> context,
    std::unique_ptr<worker::TransferData> self) {
  return SocketAddressBase::Create(env, std::move(address_));
}",1,1,node_sockaddr.cc,node.SocketAddressBase.TransferData.Deserialize,,false,878,883,Deserialize,,,63,"BaseObjectPtr<BaseObject> node.SocketAddressBase.TransferData.Deserialize (Environment*,ANY,ANY)"
238695,METHOD,node_sockaddr.hpp:<global>,TYPE_DECL,<global>,1,31,node_sockaddr.hpp,node_sockaddr.hpp:<global>,,false,1,405,<global>,,,1,
238720,METHOD,node_stat_watcher.cc:<global>,TYPE_DECL,<global>,1,1,node_stat_watcher.cc,node_stat_watcher.cc:<global>,,false,1,131,<global>,,,1,
238723,METHOD,node_stat_watcher.cc:<global>,TYPE_DECL,"void StatWatcher::CreatePerIsolateProperties(IsolateData* isolate_data,
                                             Local<ObjectTemplate> target) {
  Isolate* isolate = isolate_data->isolate();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, StatWatcher::New);
  t->InstanceTemplate()->SetInternalFieldCount(
      StatWatcher::kInternalFieldCount);
  t->Inherit(HandleWrap::GetConstructorTemplate(isolate_data));
  SetProtoMethod(isolate, t, ""start"", StatWatcher::Start);

  SetConstructorFunction(isolate, target, ""StatWatcher"", t);
}",1,1,node_stat_watcher.cc,node.StatWatcher.CreatePerIsolateProperties,,false,48,59,CreatePerIsolateProperties,,,1,"void node.StatWatcher.CreatePerIsolateProperties (IsolateData*,Local<ObjectTemplate>)"
238778,METHOD,node_stat_watcher.cc:<global>,TYPE_DECL,"void StatWatcher::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(StatWatcher::New);
  registry->Register(StatWatcher::Start);
}",1,1,node_stat_watcher.cc,node.StatWatcher.RegisterExternalReferences,,false,61,65,RegisterExternalReferences,,,2,void node.StatWatcher.RegisterExternalReferences (ExternalReferenceRegistry*)
238797,METHOD,node_stat_watcher.cc:<global>,TYPE_DECL,"StatWatcher::StatWatcher(fs::BindingData* binding_data,
                         Local<Object> wrap,
                         bool use_bigint)
    : HandleWrap(binding_data->env(),
                 wrap,
                 reinterpret_cast<uv_handle_t*>(&watcher_),
                 AsyncWrap::PROVIDER_STATWATCHER),
      use_bigint_(use_bigint),
      binding_data_(binding_data) {
  CHECK_EQ(0, uv_fs_poll_init(env()->event_loop(), &watcher_));
}",1,1,node_stat_watcher.cc,node.StatWatcher.StatWatcher,,false,67,77,StatWatcher,,,3,"ANY node.StatWatcher.StatWatcher (ANY*,Local<Object>,bool)"
238813,METHOD,node_stat_watcher.cc:<global>,TYPE_DECL,"void StatWatcher::Callback(uv_fs_poll_t* handle,
                           int status,
                           const uv_stat_t* prev,
                           const uv_stat_t* curr) {
  StatWatcher* wrap = ContainerOf(&StatWatcher::watcher_, handle);
  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Value> arr = fs::FillGlobalStatsArray(
      wrap->binding_data_.get(), wrap->use_bigint_, curr);
  USE(fs::FillGlobalStatsArray(
      wrap->binding_data_.get(), wrap->use_bigint_, prev, true));

  Local<Value> argv[2] = { Integer::New(env->isolate(), status), arr };
  wrap->MakeCallback(env->onchange_string(), arraysize(argv), argv);
}",1,1,node_stat_watcher.cc,node.StatWatcher.Callback,,false,80,96,Callback,,,4,"void node.StatWatcher.Callback (uv_fs_poll_t*,int,uv_stat_t*,uv_stat_t*)"
238904,METHOD,node_stat_watcher.cc:<global>,TYPE_DECL,"void StatWatcher::New(const FunctionCallbackInfo<Value>& args) {
  CHECK(args.IsConstructCall());
  fs::BindingData* binding_data = Realm::GetBindingData<fs::BindingData>(args);
  new StatWatcher(binding_data, args.This(), args[0]->IsTrue());
}",1,1,node_stat_watcher.cc,node.StatWatcher.New,,false,99,103,New,,,5,void node.StatWatcher.New (FunctionCallbackInfo<Value>)
238939,METHOD,node_stat_watcher.cc:<global>,TYPE_DECL,"void StatWatcher::Start(const FunctionCallbackInfo<Value>& args) {
  CHECK_EQ(args.Length(), 2);

  StatWatcher* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  CHECK(!uv_is_active(wrap->GetHandle()));

  node::Utf8Value path(args.GetIsolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      wrap->env(),
      permission::PermissionScope::kFileSystemRead,
      path.ToStringView());

  CHECK(args[1]->IsUint32());
  const uint32_t interval = args[1].As<Uint32>()->Value();

  // Note that uv_fs_poll_start does not return ENOENT, we are handling
  // mostly memory errors here.
  const int err = uv_fs_poll_start(&wrap->watcher_, Callback, *path, interval);
  if (err != 0) {
    args.GetReturnValue().Set(err);
  }
}",1,1,node_stat_watcher.cc,node.StatWatcher.Start,,false,106,129,Start,,,6,void node.StatWatcher.Start (FunctionCallbackInfo<Value>)
239046,METHOD,node_stat_watcher.hpp:<global>,TYPE_DECL,<global>,1,35,node_stat_watcher.hpp,node_stat_watcher.hpp:<global>,,false,1,73,<global>,,,1,
239057,METHOD,node_symbols.cc:<global>,TYPE_DECL,<global>,1,25,env-inl.hpp,node_symbols.cc:<global>,,false,1,32,<global>,,,1,
239061,METHOD,node_symbols.cc:<global>,TYPE_DECL,"static void Initialize(Local<Object> target,
                       Local<Value> unused,
                       Local<Context> context,
                       void* priv) {
  Environment* env = Environment::GetCurrent(context);
#define V(PropertyName, StringValue)                                           \
  target                                                                       \
      ->Set(env->context(),                                                    \
            env->PropertyName()->Description(env->isolate()),                  \
            env->PropertyName())                                               \
      .Check();
  PER_ISOLATE_SYMBOL_PROPERTIES(V)
#undef V
}",1,1,node_symbols.cc,node.symbols.Initialize,,false,14,27,Initialize,,,1,"void node.symbols.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
239103,METHOD,node_task_queue.cc:<global>,TYPE_DECL,<global>,1,28,async_wrap.hpp,node_task_queue.cc:<global>,,false,1,231,<global>,,,1,
239106,METHOD,node_task_queue.cc:<global>,TYPE_DECL,"static Maybe<double> GetAssignedPromiseAsyncId(Environment* env,
                                               Local<Promise> promise,
                                               Local<Value> id_symbol) {
  Local<Value> maybe_async_id;
  if (!promise->Get(env->context(), id_symbol).ToLocal(&maybe_async_id)) {
    return v8::Just(AsyncWrap::kInvalidAsyncId);
  }
  return maybe_async_id->IsNumber()
      ? maybe_async_id->NumberValue(env->context())
      : v8::Just(AsyncWrap::kInvalidAsyncId);
}",1,1,node_task_queue.cc,node.GetAssignedPromiseAsyncId,,false,34,44,GetAssignedPromiseAsyncId,,,1,"Maybe<double> node.GetAssignedPromiseAsyncId (Environment*,Local<Promise>,Local<Value>)"
239164,METHOD,node_task_queue.cc:<global>,TYPE_DECL,"static Maybe<double> GetAssignedPromiseWrapAsyncId(Environment* env,
                                                   Local<Promise> promise,
                                                   Local<Value> id_symbol) {
  // This check is imperfect. If the internal field is set, it should
  // be an object. If it's not, we just ignore it. Ideally v8 would
  // have had GetInternalField returning a MaybeLocal but this works
  // for now.
  Local<Value> promiseWrap = promise->GetInternalField(0);
  if (promiseWrap->IsObject()) {
        Local<Value> maybe_async_id;
    if (!promiseWrap.As<Object>()->Get(env->context(), id_symbol)
        .ToLocal(&maybe_async_id)) {
      return v8::Just(AsyncWrap::kInvalidAsyncId);
    }
    return maybe_async_id->IsNumber()
        ? maybe_async_id->NumberValue(env->context())
        : v8::Just(AsyncWrap::kInvalidAsyncId);
  } else {
      return v8::Just(AsyncWrap::kInvalidAsyncId);
  }
}",1,1,node_task_queue.cc,node.GetAssignedPromiseWrapAsyncId,,false,46,66,GetAssignedPromiseWrapAsyncId,,,2,"Maybe<double> node.GetAssignedPromiseWrapAsyncId (Environment*,Local<Promise>,Local<Value>)"
239252,METHOD,node_task_queue.cc:<global>,TYPE_DECL,"void PromiseRejectCallback(PromiseRejectMessage message) {
  static std::atomic<uint64_t> unhandledRejections{0};
  static std::atomic<uint64_t> rejectionsHandledAfter{0};

  Local<Promise> promise = message.GetPromise();
  Isolate* isolate = promise->GetIsolate();
  PromiseRejectEvent event = message.GetEvent();

  Environment* env = Environment::GetCurrent(isolate);

  if (env == nullptr || !env->can_call_into_js()) return;

  Local<Function> callback = env->promise_reject_callback();
  // The promise is rejected before JS land calls SetPromiseRejectCallback
  // to initializes the promise reject callback during bootstrap.
  CHECK(!callback.IsEmpty());

  Local<Value> value;
  Local<Value> type = Number::New(env->isolate(), event);

  if (event == kPromiseRejectWithNoHandler) {
    value = message.GetValue();
    unhandledRejections++;
    TRACE_COUNTER2(TRACING_CATEGORY_NODE2(promises, rejections),
                  ""rejections"",
                  ""unhandled"", unhandledRejections...",1,1,node_task_queue.cc,node.PromiseRejectCallback,,false,68,160,PromiseRejectCallback,,,3,void node.PromiseRejectCallback (PromiseRejectMessage)
239617,METHOD,node_task_queue.cc:<global>,TYPE_DECL,"static void EnqueueMicrotask(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  CHECK(args[0]->IsFunction());

  isolate->GetCurrentContext()->GetMicrotaskQueue()
      ->EnqueueMicrotask(isolate, args[0].As<Function>());
}",1,1,node_task_queue.cc,node.task_queue.EnqueueMicrotask,,false,163,171,EnqueueMicrotask,,,1,void node.task_queue.EnqueueMicrotask (FunctionCallbackInfo<Value>)
239661,METHOD,node_task_queue.cc:<global>,TYPE_DECL,"static void RunMicrotasks(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  env->context()->GetMicrotaskQueue()->PerformCheckpoint(env->isolate());
}",1,1,node_task_queue.cc,node.task_queue.RunMicrotasks,,false,173,176,RunMicrotasks,,,2,void node.task_queue.RunMicrotasks (FunctionCallbackInfo<Value>)
239688,METHOD,node_task_queue.cc:<global>,TYPE_DECL,"static void SetTickCallback(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  env->set_tick_callback_function(args[0].As<Function>());
}",1,1,node_task_queue.cc,node.task_queue.SetTickCallback,,false,178,182,SetTickCallback,,,3,void node.task_queue.SetTickCallback (FunctionCallbackInfo<Value>)
239718,METHOD,node_task_queue.cc:<global>,TYPE_DECL,"static void SetPromiseRejectCallback(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsFunction());
  env->set_promise_reject_callback(args[0].As<Function>());
}",1,1,node_task_queue.cc,node.task_queue.SetPromiseRejectCallback,,false,184,190,SetPromiseRejectCallback,,,4,void node.task_queue.SetPromiseRejectCallback (FunctionCallbackInfo<Value>)
239748,METHOD,node_task_queue.cc:<global>,TYPE_DECL,"static void Initialize(Local<Object> target,
                       Local<Value> unused,
                       Local<Context> context,
                       void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  SetMethod(context, target, ""enqueueMicrotask"", EnqueueMicrotask);
  SetMethod(context, target, ""setTickCallback"", SetTickCallback);
  SetMethod(context, target, ""runMicrotasks"", RunMicrotasks);
  target->Set(env->context(),
              FIXED_ONE_BYTE_STRING(isolate, ""tickInfo""),
              env->tick_info()->fields().GetJSArray()).Check();

  Local<Object> events = Object::New(isolate);
  NODE_DEFINE_CONSTANT(events, kPromiseRejectWithNoHandler);
  NODE_DEFINE_CONSTANT(events, kPromiseHandlerAddedAfterReject);
  NODE_DEFINE_CONSTANT(events, kPromiseResolveAfterResolved);
  NODE_DEFINE_CONSTANT(events, kPromiseRejectAfterResolved);

  target->Set(env->context(),
              FIXED_ONE_BYTE_STRING(isolate, ""promiseRe...",1,2,node_task_queue.cc,node.task_queue.Initialize,,false,192,217,Initialize,,,5,"void node.task_queue.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
240237,METHOD,node_task_queue.cc:<global>,TYPE_DECL,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(EnqueueMicrotask);
  registry->Register(SetTickCallback);
  registry->Register(RunMicrotasks);
  registry->Register(SetPromiseRejectCallback);
}",1,1,node_task_queue.cc,node.task_queue.RegisterExternalReferences,,false,219,224,RegisterExternalReferences,,,6,void node.task_queue.RegisterExternalReferences (ExternalReferenceRegistry*)
240266,METHOD,node_threadsafe_cow-inl.hpp:<global>,TYPE_DECL,<global>,1,41,node_threadsafe_cow-inl.hpp,node_threadsafe_cow-inl.hpp:<global>,,false,1,54,<global>,,,1,
240279,METHOD,node_threadsafe_cow.hpp:<global>,TYPE_DECL,<global>,1,37,node_threadsafe_cow.hpp,node_threadsafe_cow.hpp:<global>,,false,1,105,<global>,,,1,
240306,METHOD,node_trace_events.cc:<global>,TYPE_DECL,<global>,1,33,base_object-inl.hpp,node_trace_events.cc:<global>,,false,1,173,<global>,,,1,
240311,METHOD,node.NodeCategorySet,TYPE_DECL,"static void Initialize(Local<Object> target,
                  Local<Value> unused,
                  Local<Context> context,
                  void* priv);",15,29,node_trace_events.cc,node.NodeCategorySet.Initialize,,false,32,35,Initialize,,,1,"void node.NodeCategorySet.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
240319,METHOD,node.NodeCategorySet,TYPE_DECL,static void RegisterExternalReferences(ExternalReferenceRegistry* registry);,15,77,node_trace_events.cc,node.NodeCategorySet.RegisterExternalReferences,,false,36,36,RegisterExternalReferences,,,2,void node.NodeCategorySet.RegisterExternalReferences (ExternalReferenceRegistry*)
240324,METHOD,node.NodeCategorySet,TYPE_DECL,static void New(const FunctionCallbackInfo<Value>& args);,15,58,node_trace_events.cc,node.NodeCategorySet.New,,false,37,37,New,,,3,void node.NodeCategorySet.New (FunctionCallbackInfo<Value>)
240329,METHOD,node.NodeCategorySet,TYPE_DECL,static void Enable(const FunctionCallbackInfo<Value>& args);,15,61,node_trace_events.cc,node.NodeCategorySet.Enable,,false,38,38,Enable,,,4,void node.NodeCategorySet.Enable (FunctionCallbackInfo<Value>)
240334,METHOD,node.NodeCategorySet,TYPE_DECL,static void Disable(const FunctionCallbackInfo<Value>& args);,15,62,node_trace_events.cc,node.NodeCategorySet.Disable,,false,39,39,Disable,,,5,void node.NodeCategorySet.Disable (FunctionCallbackInfo<Value>)
240339,METHOD,node.NodeCategorySet,TYPE_DECL,const std::set<std::string>& GetCategories() const { return categories_; },3,76,node_trace_events.cc,node.NodeCategorySet.GetCategories,,false,41,41,GetCategories,,,6,set<std::string> node.NodeCategorySet.GetCategories ()
240345,METHOD,node.NodeCategorySet,TYPE_DECL,"void MemoryInfo(MemoryTracker* tracker) const override {
    tracker->TrackField(""categories"", categories_);
  }",3,3,node_trace_events.cc,node.NodeCategorySet.MemoryInfo,,false,43,45,MemoryInfo,,,7,void node.NodeCategorySet.MemoryInfo (MemoryTracker*)
240360,METHOD,node.NodeCategorySet,TYPE_DECL,"NodeCategorySet(Environment* env,
                  Local<Object> wrap,
                  std::set<std::string>&& categories) :
        BaseObject(env, wrap), categories_(std::move(categories)) {
    MakeWeak();
  }",3,3,node_trace_events.cc,node.NodeCategorySet.NodeCategorySet,,false,51,56,NodeCategorySet,,,12,"ANY node.NodeCategorySet.NodeCategorySet (Environment*,Local<Object>,ANY)"
240370,METHOD,<empty>,<empty>,<empty>,1,,node_trace_events.cc,node.NodeCategorySet:<clinit>,,false,30,,<clinit>,,,15,
240377,METHOD,node_trace_events.cc:<global>,TYPE_DECL,"void NodeCategorySet::New(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  std::set<std::string> categories;
  CHECK(args[0]->IsArray());
  Local<Array> cats = args[0].As<Array>();
  for (size_t n = 0; n < cats->Length(); n++) {
    Local<Value> category;
    if (!cats->Get(env->context(), n).ToLocal(&category)) return;
    Utf8Value val(env->isolate(), category);
    if (!*val) return;
    categories.emplace(*val);
  }
  CHECK_NOT_NULL(GetTracingAgentWriter());
  new NodeCategorySet(env, args.This(), std::move(categories));
}",1,1,node_trace_events.cc,node.NodeCategorySet.New,,false,62,76,New,,,3,void node.NodeCategorySet.New (FunctionCallbackInfo<Value>)
240488,METHOD,node_trace_events.cc:<global>,TYPE_DECL,"void NodeCategorySet::Enable(const FunctionCallbackInfo<Value>& args) {
  NodeCategorySet* category_set;
  ASSIGN_OR_RETURN_UNWRAP(&category_set, args.Holder());
  CHECK_NOT_NULL(category_set);
  const auto& categories = category_set->GetCategories();
  if (!category_set->enabled_ && !categories.empty()) {
    // Starts the Tracing Agent if it wasn't started already (e.g. through
    // a command line flag.)
    StartTracingAgent();
    GetTracingAgentWriter()->Enable(categories);
    category_set->enabled_ = true;
  }
}",1,1,node_trace_events.cc,node.NodeCategorySet.Enable,,false,78,90,Enable,,,4,void node.NodeCategorySet.Enable (FunctionCallbackInfo<Value>)
240533,METHOD,node_trace_events.cc:<global>,TYPE_DECL,"void NodeCategorySet::Disable(const FunctionCallbackInfo<Value>& args) {
  NodeCategorySet* category_set;
  ASSIGN_OR_RETURN_UNWRAP(&category_set, args.Holder());
  CHECK_NOT_NULL(category_set);
  const auto& categories = category_set->GetCategories();
  if (category_set->enabled_ && !categories.empty()) {
    GetTracingAgentWriter()->Disable(categories);
    category_set->enabled_ = false;
  }
}",1,1,node_trace_events.cc,node.NodeCategorySet.Disable,,false,92,101,Disable,,,5,void node.NodeCategorySet.Disable (FunctionCallbackInfo<Value>)
240576,METHOD,node_trace_events.cc:<global>,TYPE_DECL,"void GetEnabledCategories(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  std::string categories =
      GetTracingAgentWriter()->agent()->GetEnabledCategories();
  if (!categories.empty()) {
    args.GetReturnValue().Set(
      String::NewFromUtf8(env->isolate(),
                          categories.c_str(),
                          NewStringType::kNormal,
                          categories.size()).ToLocalChecked());
  }
}",1,1,node_trace_events.cc,node.GetEnabledCategories,,false,103,114,GetEnabledCategories,,,6,void node.GetEnabledCategories (FunctionCallbackInfo<Value>)
240635,METHOD,node_trace_events.cc:<global>,TYPE_DECL,"static void SetTraceCategoryStateUpdateHandler(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  env->set_trace_category_state_function(args[0].As<Function>());
}",1,1,node_trace_events.cc,node.SetTraceCategoryStateUpdateHandler,,false,116,121,SetTraceCategoryStateUpdateHandler,,,7,void node.SetTraceCategoryStateUpdateHandler (FunctionCallbackInfo<Value>)
240665,METHOD,node_trace_events.cc:<global>,TYPE_DECL,"void NodeCategorySet::Initialize(Local<Object> target,
                Local<Value> unused,
                Local<Context> context,
                void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  SetMethod(context, target, ""getEnabledCategories"", GetEnabledCategories);
  SetMethod(context,
            target,
            ""setTraceCategoryStateUpdateHandler"",
            SetTraceCategoryStateUpdateHandler);

  Local<FunctionTemplate> category_set =
      NewFunctionTemplate(isolate, NodeCategorySet::New);
  category_set->InstanceTemplate()->SetInternalFieldCount(
      NodeCategorySet::kInternalFieldCount);
  SetProtoMethod(isolate, category_set, ""enable"", NodeCategorySet::Enable);
  SetProtoMethod(isolate, category_set, ""disable"", NodeCategorySet::Disable);

  SetConstructorFunction(context, target, ""CategorySet"", category_set);

  Local<String> isTraceCategoryEnabled =
      FIXED_ONE_BYTE_STRING(env->isolate(), ""isTraceC...",1,1,node_trace_events.cc,node.NodeCategorySet.Initialize,,false,123,157,Initialize,,,8,"void node.NodeCategorySet.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
240808,METHOD,node_trace_events.cc:<global>,TYPE_DECL,"void NodeCategorySet::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(GetEnabledCategories);
  registry->Register(SetTraceCategoryStateUpdateHandler);
  registry->Register(NodeCategorySet::New);
  registry->Register(NodeCategorySet::Enable);
  registry->Register(NodeCategorySet::Disable);
}",1,1,node_trace_events.cc,node.NodeCategorySet.RegisterExternalReferences,,false,159,166,RegisterExternalReferences,,,9,void node.NodeCategorySet.RegisterExternalReferences (ExternalReferenceRegistry*)
240854,METHOD,node_types.cc:<global>,TYPE_DECL,<global>,1,25,env-inl.hpp,node_types.cc:<global>,,false,1,89,<global>,,,1,
240858,METHOD,node_types.cc:<global>,TYPE_DECL,VALUE_METHOD_MAP(V),3,21,node_types.cc,node.anonymous_namespace_1.IsExternal,,false,47,47,IsExternal,,,1,void node.anonymous_namespace_1.IsExternal (FunctionCallbackInfo<Value>)
240876,METHOD,node_types.cc:<global>,TYPE_DECL,VALUE_METHOD_MAP(V),3,21,node_types.cc,node.anonymous_namespace_2.IsDate,,false,47,47,IsDate,,,2,void node.anonymous_namespace_2.IsDate (FunctionCallbackInfo<Value>)
240894,METHOD,node_types.cc:<global>,TYPE_DECL,VALUE_METHOD_MAP(V),3,21,node_types.cc,node.anonymous_namespace_3.IsArgumentsObject,,false,47,47,IsArgumentsObject,,,3,void node.anonymous_namespace_3.IsArgumentsObject (FunctionCallbackInfo<Value>)
240912,METHOD,node_types.cc:<global>,TYPE_DECL,VALUE_METHOD_MAP(V),3,21,node_types.cc,node.anonymous_namespace_4.IsBigIntObject,,false,47,47,IsBigIntObject,,,4,void node.anonymous_namespace_4.IsBigIntObject (FunctionCallbackInfo<Value>)
240930,METHOD,node_types.cc:<global>,TYPE_DECL,VALUE_METHOD_MAP(V),3,21,node_types.cc,node.anonymous_namespace_5.IsBooleanObject,,false,47,47,IsBooleanObject,,,5,void node.anonymous_namespace_5.IsBooleanObject (FunctionCallbackInfo<Value>)
240948,METHOD,node_types.cc:<global>,TYPE_DECL,VALUE_METHOD_MAP(V),3,21,node_types.cc,node.anonymous_namespace_6.IsNumberObject,,false,47,47,IsNumberObject,,,6,void node.anonymous_namespace_6.IsNumberObject (FunctionCallbackInfo<Value>)
240966,METHOD,node_types.cc:<global>,TYPE_DECL,VALUE_METHOD_MAP(V),3,21,node_types.cc,node.anonymous_namespace_7.IsStringObject,,false,47,47,IsStringObject,,,7,void node.anonymous_namespace_7.IsStringObject (FunctionCallbackInfo<Value>)
240984,METHOD,node_types.cc:<global>,TYPE_DECL,VALUE_METHOD_MAP(V),3,21,node_types.cc,node.anonymous_namespace_8.IsSymbolObject,,false,47,47,IsSymbolObject,,,8,void node.anonymous_namespace_8.IsSymbolObject (FunctionCallbackInfo<Value>)
241002,METHOD,node_types.cc:<global>,TYPE_DECL,VALUE_METHOD_MAP(V),3,21,node_types.cc,node.anonymous_namespace_9.IsNativeError,,false,47,47,IsNativeError,,,9,void node.anonymous_namespace_9.IsNativeError (FunctionCallbackInfo<Value>)
241020,METHOD,node_types.cc:<global>,TYPE_DECL,VALUE_METHOD_MAP(V),3,21,node_types.cc,node.anonymous_namespace_10.IsRegExp,,false,47,47,IsRegExp,,,10,void node.anonymous_namespace_10.IsRegExp (FunctionCallbackInfo<Value>)
241038,METHOD,node_types.cc:<global>,TYPE_DECL,VALUE_METHOD_MAP(V),3,21,node_types.cc,node.anonymous_namespace_11.IsAsyncFunction,,false,47,47,IsAsyncFunction,,,11,void node.anonymous_namespace_11.IsAsyncFunction (FunctionCallbackInfo<Value>)
241056,METHOD,node_types.cc:<global>,TYPE_DECL,VALUE_METHOD_MAP(V),3,21,node_types.cc,node.anonymous_namespace_12.IsGeneratorFunction,,false,47,47,IsGeneratorFunction,,,12,void node.anonymous_namespace_12.IsGeneratorFunction (FunctionCallbackInfo<Value>)
241074,METHOD,node_types.cc:<global>,TYPE_DECL,VALUE_METHOD_MAP(V),3,21,node_types.cc,node.anonymous_namespace_13.IsGeneratorObject,,false,47,47,IsGeneratorObject,,,13,void node.anonymous_namespace_13.IsGeneratorObject (FunctionCallbackInfo<Value>)
241092,METHOD,node_types.cc:<global>,TYPE_DECL,VALUE_METHOD_MAP(V),3,21,node_types.cc,node.anonymous_namespace_14.IsPromise,,false,47,47,IsPromise,,,14,void node.anonymous_namespace_14.IsPromise (FunctionCallbackInfo<Value>)
241110,METHOD,node_types.cc:<global>,TYPE_DECL,VALUE_METHOD_MAP(V),3,21,node_types.cc,node.anonymous_namespace_15.IsMap,,false,47,47,IsMap,,,15,void node.anonymous_namespace_15.IsMap (FunctionCallbackInfo<Value>)
241128,METHOD,node_types.cc:<global>,TYPE_DECL,VALUE_METHOD_MAP(V),3,21,node_types.cc,node.anonymous_namespace_16.IsSet,,false,47,47,IsSet,,,16,void node.anonymous_namespace_16.IsSet (FunctionCallbackInfo<Value>)
241146,METHOD,node_types.cc:<global>,TYPE_DECL,VALUE_METHOD_MAP(V),3,21,node_types.cc,node.anonymous_namespace_17.IsMapIterator,,false,47,47,IsMapIterator,,,17,void node.anonymous_namespace_17.IsMapIterator (FunctionCallbackInfo<Value>)
241164,METHOD,node_types.cc:<global>,TYPE_DECL,VALUE_METHOD_MAP(V),3,21,node_types.cc,node.anonymous_namespace_18.IsSetIterator,,false,47,47,IsSetIterator,,,18,void node.anonymous_namespace_18.IsSetIterator (FunctionCallbackInfo<Value>)
241182,METHOD,node_types.cc:<global>,TYPE_DECL,VALUE_METHOD_MAP(V),3,21,node_types.cc,node.anonymous_namespace_19.IsWeakMap,,false,47,47,IsWeakMap,,,19,void node.anonymous_namespace_19.IsWeakMap (FunctionCallbackInfo<Value>)
241200,METHOD,node_types.cc:<global>,TYPE_DECL,VALUE_METHOD_MAP(V),3,21,node_types.cc,node.anonymous_namespace_20.IsWeakSet,,false,47,47,IsWeakSet,,,20,void node.anonymous_namespace_20.IsWeakSet (FunctionCallbackInfo<Value>)
241218,METHOD,node_types.cc:<global>,TYPE_DECL,VALUE_METHOD_MAP(V),3,21,node_types.cc,node.anonymous_namespace_21.IsArrayBuffer,,false,47,47,IsArrayBuffer,,,21,void node.anonymous_namespace_21.IsArrayBuffer (FunctionCallbackInfo<Value>)
241236,METHOD,node_types.cc:<global>,TYPE_DECL,VALUE_METHOD_MAP(V),3,21,node_types.cc,node.anonymous_namespace_22.IsDataView,,false,47,47,IsDataView,,,22,void node.anonymous_namespace_22.IsDataView (FunctionCallbackInfo<Value>)
241254,METHOD,node_types.cc:<global>,TYPE_DECL,VALUE_METHOD_MAP(V),3,21,node_types.cc,node.anonymous_namespace_23.IsSharedArrayBuffer,,false,47,47,IsSharedArrayBuffer,,,23,void node.anonymous_namespace_23.IsSharedArrayBuffer (FunctionCallbackInfo<Value>)
241272,METHOD,node_types.cc:<global>,TYPE_DECL,VALUE_METHOD_MAP(V),3,21,node_types.cc,node.anonymous_namespace_24.IsProxy,,false,47,47,IsProxy,,,24,void node.anonymous_namespace_24.IsProxy (FunctionCallbackInfo<Value>)
241290,METHOD,node_types.cc:<global>,TYPE_DECL,VALUE_METHOD_MAP(V),3,21,node_types.cc,node.anonymous_namespace_25.IsModuleNamespaceObject,,false,47,47,IsModuleNamespaceObject,,,25,void node.anonymous_namespace_25.IsModuleNamespaceObject (FunctionCallbackInfo<Value>)
241308,METHOD,node_types.cc:<global>,TYPE_DECL,"static void IsAnyArrayBuffer(const FunctionCallbackInfo<Value>& args) {
  args.GetReturnValue().Set(
    args[0]->IsArrayBuffer() || args[0]->IsSharedArrayBuffer());
}",1,1,node_types.cc,node.anonymous_namespace_26.IsAnyArrayBuffer,,false,50,53,IsAnyArrayBuffer,,,26,void node.anonymous_namespace_26.IsAnyArrayBuffer (FunctionCallbackInfo<Value>)
241333,METHOD,node_types.cc:<global>,TYPE_DECL,"static void IsBoxedPrimitive(const FunctionCallbackInfo<Value>& args) {
  args.GetReturnValue().Set(
    args[0]->IsNumberObject() ||
    args[0]->IsStringObject() ||
    args[0]->IsBooleanObject() ||
    args[0]->IsBigIntObject() ||
    args[0]->IsSymbolObject());
}",1,1,node_types.cc,node.anonymous_namespace_27.IsBoxedPrimitive,,false,55,62,IsBoxedPrimitive,,,27,void node.anonymous_namespace_27.IsBoxedPrimitive (FunctionCallbackInfo<Value>)
241379,METHOD,node_types.cc:<global>,TYPE_DECL,"void InitializeTypes(Local<Object> target,
                     Local<Value> unused,
                     Local<Context> context,
                     void* priv) {
#define V(type) SetMethodNoSideEffect(context, target, ""is"" #type, Is##type);
  VALUE_METHOD_MAP(V)
#undef V

  SetMethodNoSideEffect(context, target, ""isAnyArrayBuffer"", IsAnyArrayBuffer);
  SetMethodNoSideEffect(context, target, ""isBoxedPrimitive"", IsBoxedPrimitive);
}",1,2,node_types.cc,node.anonymous_namespace_28.InitializeTypes,,false,64,74,InitializeTypes,,,28,"void node.anonymous_namespace_28.InitializeTypes (Local<Object>,Local<Value>,Local<Context>,void*)"
241526,METHOD,node_types.cc:<global>,TYPE_DECL,"void RegisterTypesExternalReferences(ExternalReferenceRegistry* registry) {
#define V(type) registry->Register(Is##type);
  VALUE_METHOD_MAP(V)
#undef V

  registry->Register(IsAnyArrayBuffer);
  registry->Register(IsBoxedPrimitive);
}",1,2,node_types.cc,node.RegisterTypesExternalReferences,,false,78,85,RegisterTypesExternalReferences,,,2,void node.RegisterTypesExternalReferences (ExternalReferenceRegistry*)
241674,METHOD,node_union_bytes.hpp:<global>,TYPE_DECL,<global>,1,34,node_union_bytes.hpp,node_union_bytes.hpp:<global>,,false,1,81,<global>,,,1,
241703,METHOD,node_url.cc:<global>,TYPE_DECL,<global>,1,26,node_url.hpp,node_url.cc:<global>,,false,1,413,<global>,,,1,
241707,METHOD,node_url.cc:<global>,TYPE_DECL,"void BindingData::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""url_components_buffer"", url_components_buffer_);
}",1,1,node_url.cc,node.url.BindingData.MemoryInfo,,false,31,33,MemoryInfo,,,1,void node.url.BindingData.MemoryInfo (MemoryTracker*)
241718,METHOD,node_url.cc:<global>,TYPE_DECL,"BindingData::BindingData(Realm* realm, v8::Local<v8::Object> object)
    : SnapshotableObject(realm, object, type_int),
      url_components_buffer_(realm->isolate(), kURLComponentsLength) {
  object
      ->Set(realm->context(),
            FIXED_ONE_BYTE_STRING(realm->isolate(), ""urlComponents""),
            url_components_buffer_.GetJSArray())
      .Check();
  url_components_buffer_.MakeWeak();
}",1,1,node_url.cc,node.url.BindingData.BindingData,,false,35,44,BindingData,,,2,"ANY node.url.BindingData.BindingData (Realm*,ANY)"
241749,METHOD,node_url.cc:<global>,TYPE_DECL,"bool BindingData::PrepareForSerialization(v8::Local<v8::Context> context,
                                          v8::SnapshotCreator* creator) {
  // We'll just re-initialize the buffers in the constructor since their
  // contents can be thrown away once consumed in the previous call.
  url_components_buffer_.Release();
  // Return true because we need to maintain the reference to the binding from
  // JS land.
  return true;
}",1,1,node_url.cc,node.url.BindingData.PrepareForSerialization,,false,46,54,PrepareForSerialization,,,3,"bool node.url.BindingData.PrepareForSerialization (ANY,ANY*)"
241761,METHOD,node_url.cc:<global>,TYPE_DECL,"InternalFieldInfoBase* BindingData::Serialize(int index) {
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info =
      InternalFieldInfoBase::New<InternalFieldInfo>(type());
  return info;
}",1,1,node_url.cc,node.url.BindingData.Serialize,,false,56,61,Serialize,,,4,InternalFieldInfoBase node.url.BindingData.Serialize (int)
241783,METHOD,node_url.cc:<global>,TYPE_DECL,"void BindingData::Deserialize(v8::Local<v8::Context> context,
                              v8::Local<v8::Object> holder,
                              int index,
                              InternalFieldInfoBase* info) {
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  v8::HandleScope scope(context->GetIsolate());
  Realm* realm = Realm::GetCurrent(context);
  BindingData* binding = realm->AddBindingData<BindingData>(context, holder);
  CHECK_NOT_NULL(binding);
}",1,1,node_url.cc,node.url.BindingData.Deserialize,,false,63,72,Deserialize,,,5,"void node.url.BindingData.Deserialize (ANY,ANY,int,InternalFieldInfoBase*)"
241825,METHOD,node_url.cc:<global>,TYPE_DECL,"void BindingData::DomainToASCII(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());

  std::string input = Utf8Value(env->isolate(), args[0]).ToString();
  if (input.empty()) {
    return args.GetReturnValue().Set(FIXED_ONE_BYTE_STRING(env->isolate(), """"));
  }

  // It is important to have an initial value that contains a special scheme.
  // Since it will change the implementation of `set_hostname` according to URL
  // spec.
  auto out = ada::parse<ada::url>(""ws://x"");
  DCHECK(out);
  if (!out->set_hostname(input)) {
    return args.GetReturnValue().Set(FIXED_ONE_BYTE_STRING(env->isolate(), """"));
  }
  std::string host = out->get_hostname();
  args.GetReturnValue().Set(
      String::NewFromUtf8(env->isolate(), host.c_str()).ToLocalChecked());
}",1,1,node_url.cc,node.url.BindingData.DomainToASCII,,false,74,95,DomainToASCII,,,6,void node.url.BindingData.DomainToASCII (FunctionCallbackInfo<Value>)
241950,METHOD,node_url.cc:<global>,TYPE_DECL,"void BindingData::DomainToUnicode(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());

  std::string input = Utf8Value(env->isolate(), args[0]).ToString();
  // It is important to have an initial value that contains a special scheme.
  // Since it will change the implementation of `set_hostname` according to URL
  // spec.
  auto out = ada::parse<ada::url>(""ws://x"");
  DCHECK(out);
  if (!out->set_hostname(input)) {
    return args.GetReturnValue().Set(
        String::NewFromUtf8(env->isolate(), """").ToLocalChecked());
  }
  std::string result = ada::unicode::to_unicode(out->get_hostname());

  args.GetReturnValue().Set(String::NewFromUtf8(env->isolate(),
                                                result.c_str(),
                                                NewStringType::kNormal,
                                                result.length())
                             ...",1,1,node_url.cc,node.url.BindingData.DomainToUnicode,,false,97,119,DomainToUnicode,,,7,void node.url.BindingData.DomainToUnicode (FunctionCallbackInfo<Value>)
242074,METHOD,node_url.cc:<global>,TYPE_DECL,"void BindingData::GetOrigin(const v8::FunctionCallbackInfo<Value>& args) {
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());  // input

  Environment* env = Environment::GetCurrent(args);
  HandleScope handle_scope(env->isolate());

  Utf8Value input(env->isolate(), args[0]);
  std::string_view input_view = input.ToStringView();
  auto out = ada::parse<ada::url_aggregator>(input_view);

  if (!out) {
    THROW_ERR_INVALID_URL(env, ""Invalid URL"");
    return;
  }

  std::string origin = out->get_origin();
  args.GetReturnValue().Set(String::NewFromUtf8(env->isolate(),
                                                origin.data(),
                                                NewStringType::kNormal,
                                                origin.length())
                                .ToLocalChecked());
}",1,1,node_url.cc,node.url.BindingData.GetOrigin,,false,121,143,GetOrigin,,,8,void node.url.BindingData.GetOrigin (ANY)
242178,METHOD,node_url.cc:<global>,TYPE_DECL,"void BindingData::CanParse(const FunctionCallbackInfo<Value>& args) {
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());  // input
  // args[1] // base url

  Environment* env = Environment::GetCurrent(args);
  HandleScope handle_scope(env->isolate());

  Utf8Value input(env->isolate(), args[0]);
  std::string_view input_view = input.ToStringView();

  bool can_parse{};
  if (args[1]->IsString()) {
    Utf8Value base(env->isolate(), args[1]);
    std::string_view base_view = base.ToStringView();
    can_parse = ada::can_parse(input_view, &base_view);
  } else {
    can_parse = ada::can_parse(input_view);
  }

  args.GetReturnValue().Set(can_parse);
}",1,1,node_url.cc,node.url.BindingData.CanParse,,false,145,166,CanParse,,,9,void node.url.BindingData.CanParse (FunctionCallbackInfo<Value>)
242280,METHOD,node_url.cc:<global>,TYPE_DECL,"bool BindingData::FastCanParse(Local<Value> receiver,
                               const FastOneByteString& input) {
  return ada::can_parse(std::string_view(input.data, input.length));
}",1,1,node_url.cc,node.url.BindingData.FastCanParse,,false,168,171,FastCanParse,,,10,"bool node.url.BindingData.FastCanParse (Local<Value>,FastOneByteString)"
242301,METHOD,node_url.cc:<global>,TYPE_DECL,CFunction BindingData::fast_can_parse_(CFunction::Make(FastCanParse));,11,69,node_url.cc,node.url.fast_can_parse_,,false,173,173,fast_can_parse_,,,11,CFunction node.url.fast_can_parse_ (ANY)
242306,METHOD,node_url.cc:<global>,TYPE_DECL,"bool BindingData::FastCanParseWithBase(Local<Value> receiver,
                                       const FastOneByteString& input,
                                       const FastOneByteString& base) {
  auto base_view = std::string_view(base.data, base.length);
  return ada::can_parse(std::string_view(input.data, input.length), &base_view);
}",1,1,node_url.cc,node.url.BindingData.FastCanParseWithBase,,false,175,180,FastCanParseWithBase,,,12,"bool node.url.BindingData.FastCanParseWithBase (Local<Value>,FastOneByteString,FastOneByteString)"
242343,METHOD,node_url.cc:<global>,TYPE_DECL,"CFunction BindingData::fast_can_parse_with_base_(
    CFunction::Make(FastCanParseWithBase));",11,42,node_url.cc,node.url.fast_can_parse_with_base_,,false,182,183,fast_can_parse_with_base_,,,13,CFunction node.url.fast_can_parse_with_base_ (ANY)
242348,METHOD,node_url.cc:<global>,TYPE_DECL,"void BindingData::Format(const FunctionCallbackInfo<Value>& args) {
  CHECK_GT(args.Length(), 4);
  CHECK(args[0]->IsString());  // url href

  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  Utf8Value href(isolate, args[0].As<String>());
  const bool hash = args[1]->IsTrue();
  const bool unicode = args[2]->IsTrue();
  const bool search = args[3]->IsTrue();
  const bool auth = args[4]->IsTrue();

  // ada::url provides a faster alternative to ada::url_aggregator if we
  // directly want to manipulate the url components without using the respective
  // setters. therefore we are using ada::url here.
  auto out = ada::parse<ada::url>(href.ToStringView());
  CHECK(out);

  if (!hash) {
    out->hash = std::nullopt;
  }

  if (unicode) {
    out->host = ada::idna::to_unicode(out->get_hostname());
  }

  if (!search) {
    out->query = std::nullopt;
  }

  if (!auth) {
    out->username = """";
    out->password = """";
  }

  std::string result = o...",1,1,node_url.cc,node.url.BindingData.Format,,false,185,227,Format,,,14,void node.url.BindingData.Format (FunctionCallbackInfo<Value>)
242532,METHOD,node_url.cc:<global>,TYPE_DECL,"void BindingData::Parse(const FunctionCallbackInfo<Value>& args) {
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());  // input
  // args[1] // base url

  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = Environment::GetCurrent(args);
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Utf8Value input(env->isolate(), args[0]);
  ada::result<ada::url_aggregator> base;
  ada::url_aggregator* base_pointer = nullptr;
  if (args[1]->IsString()) {
    base = ada::parse<ada::url_aggregator>(
        Utf8Value(env->isolate(), args[1]).ToString());
    if (!base) {
      return args.GetReturnValue().Set(false);
    }
    base_pointer = &base.value();
  }
  auto out =
      ada::parse<ada::url_aggregator>(input.ToStringView(), base_pointer);

  if (!out) {
    return args.GetReturnValue().Set(false);
  }

  binding_data->UpdateComponents(out->get_components(), out->type);

  args.GetReturnValue().Se...",1,1,node_url.cc,node.url.BindingData.Parse,,false,229,262,Parse,,,15,void node.url.BindingData.Parse (FunctionCallbackInfo<Value>)
242716,METHOD,node_url.cc:<global>,TYPE_DECL,"void BindingData::Update(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsString());    // href
  CHECK(args[1]->IsNumber());    // action type
  CHECK(args[2]->IsString());    // new value

  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  enum url_update_action action = static_cast<enum url_update_action>(
      args[1]->Uint32Value(env->context()).FromJust());
  Utf8Value input(isolate, args[0].As<String>());
  Utf8Value new_value(isolate, args[2].As<String>());

  std::string_view new_value_view = new_value.ToStringView();
  auto out = ada::parse<ada::url_aggregator>(input.ToStringView());
  CHECK(out);

  bool result{true};

  switch (action) {
    case kPathname: {
      result = out->set_pathname(new_value_view);
      break;
    }
    case kHash: {
      out->set_hash(new_value_view);
      break;
    }
    case kHost: {
      result = out->set_host(...",1,1,node_url.cc,node.url.BindingData.Update,,false,264,337,Update,,,16,void node.url.BindingData.Update (FunctionCallbackInfo<Value>)
242991,METHOD,node_url.cc:<global>,TYPE_DECL,"void BindingData::UpdateComponents(const ada::url_components& components,
                                   const ada::scheme::type type) {
  url_components_buffer_[0] = components.protocol_end;
  url_components_buffer_[1] = components.username_end;
  url_components_buffer_[2] = components.host_start;
  url_components_buffer_[3] = components.host_end;
  url_components_buffer_[4] = components.port;
  url_components_buffer_[5] = components.pathname_start;
  url_components_buffer_[6] = components.search_start;
  url_components_buffer_[7] = components.hash_start;
  url_components_buffer_[8] = type;
  static_assert(kURLComponentsLength == 9,
                ""kURLComponentsLength should be up-to-date"");
}",1,1,node_url.cc,node.url.BindingData.UpdateComponents,,false,339,352,UpdateComponents,,,17,"void node.url.BindingData.UpdateComponents (ANY,ANY)"
243063,METHOD,node_url.cc:<global>,TYPE_DECL,"void BindingData::CreatePerIsolateProperties(IsolateData* isolate_data,
                                             Local<ObjectTemplate> target) {
  Isolate* isolate = isolate_data->isolate();
  SetMethodNoSideEffect(isolate, target, ""domainToASCII"", DomainToASCII);
  SetMethodNoSideEffect(isolate, target, ""domainToUnicode"", DomainToUnicode);
  SetMethodNoSideEffect(isolate, target, ""format"", Format);
  SetMethodNoSideEffect(isolate, target, ""getOrigin"", GetOrigin);
  SetMethod(isolate, target, ""parse"", Parse);
  SetMethod(isolate, target, ""update"", Update);
  SetFastMethodNoSideEffect(
      isolate, target, ""canParse"", CanParse, &fast_can_parse_);
  SetFastMethodNoSideEffect(isolate,
                            target,
                            ""canParseWithBase"",
                            CanParse,
                            &fast_can_parse_with_base_);
}",1,1,node_url.cc,node.url.BindingData.CreatePerIsolateProperties,,false,354,370,CreatePerIsolateProperties,,,18,"void node.url.BindingData.CreatePerIsolateProperties (IsolateData*,Local<ObjectTemplate>)"
243120,METHOD,node_url.cc:<global>,TYPE_DECL,"void BindingData::CreatePerContextProperties(Local<Object> target,
                                             Local<Value> unused,
                                             Local<Context> context,
                                             void* priv) {
  Realm* realm = Realm::GetCurrent(context);
  realm->AddBindingData<BindingData>(context, target);
}",1,1,node_url.cc,node.url.BindingData.CreatePerContextProperties,,false,372,378,CreatePerContextProperties,,,19,"void node.url.BindingData.CreatePerContextProperties (Local<Object>,Local<Value>,Local<Context>,void*)"
243146,METHOD,node_url.cc:<global>,TYPE_DECL,"void BindingData::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(DomainToASCII);
  registry->Register(DomainToUnicode);
  registry->Register(Format);
  registry->Register(GetOrigin);
  registry->Register(Parse);
  registry->Register(Update);
  registry->Register(CanParse);
  registry->Register(FastCanParse);
  registry->Register(fast_can_parse_.GetTypeInfo());
  registry->Register(FastCanParseWithBase);
  registry->Register(fast_can_parse_with_base_.GetTypeInfo());
}",1,1,node_url.cc,node.url.BindingData.RegisterExternalReferences,,false,380,393,RegisterExternalReferences,,,20,void node.url.BindingData.RegisterExternalReferences (ExternalReferenceRegistry*)
243212,METHOD,node_url.cc:<global>,TYPE_DECL,"std::string FromFilePath(const std::string_view file_path) {
  std::string escaped_file_path;
  for (size_t i = 0; i < file_path.length(); ++i) {
    escaped_file_path += file_path[i];
    if (file_path[i] == '%') escaped_file_path += ""25"";
  }
  return ada::href_from_file(escaped_file_path);
}",1,1,node_url.cc,node.url.FromFilePath,,false,395,402,FromFilePath,,,21,string node.url.FromFilePath (ANY)
243276,METHOD,node_url.hpp:<global>,TYPE_DECL,<global>,1,26,node_url.hpp,node_url.hpp:<global>,,false,1,90,<global>,,,1,
243293,METHOD,node_util.cc:<global>,TYPE_DECL,<global>,1,27,node_util.hpp,node_util.cc:<global>,,false,1,526,<global>,,,1,
243302,METHOD,node_util.cc:<global>,TYPE_DECL,"static void GetConstructorName(
    const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsObject());

  Local<Object> object = args[0].As<Object>();
  Local<String> name = object->GetConstructorName();

  args.GetReturnValue().Set(name);
}",1,1,node_util.cc,node.util.GetConstructorName,,false,78,86,GetConstructorName,,,4,void node.util.GetConstructorName (FunctionCallbackInfo<Value>)
243344,METHOD,node_util.cc:<global>,TYPE_DECL,"static void GetExternalValue(
    const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsExternal());
  Isolate* isolate = args.GetIsolate();
  Local<External> external = args[0].As<External>();

  void* ptr = external->Value();
  uint64_t value = reinterpret_cast<uint64_t>(ptr);
  Local<BigInt> ret = BigInt::NewFromUnsigned(isolate, value);
  args.GetReturnValue().Set(ret);
}",1,1,node_util.cc,node.util.GetExternalValue,,false,88,98,GetExternalValue,,,5,void node.util.GetExternalValue (FunctionCallbackInfo<Value>)
243408,METHOD,node_util.cc:<global>,TYPE_DECL,"static void GetPromiseDetails(const FunctionCallbackInfo<Value>& args) {
  // Return undefined if it's not a Promise.
  if (!args[0]->IsPromise())
    return;

  auto isolate = args.GetIsolate();

  Local<Promise> promise = args[0].As<Promise>();

  int state = promise->State();
  Local<Value> values[2] = { Integer::New(isolate, state) };
  size_t number_of_values = 1;
  if (state != Promise::PromiseState::kPending)
    values[number_of_values++] = promise->Result();
  Local<Array> ret = Array::New(isolate, values, number_of_values);
  args.GetReturnValue().Set(ret);
}",1,1,node_util.cc,node.util.GetPromiseDetails,,false,100,116,GetPromiseDetails,,,6,void node.util.GetPromiseDetails (FunctionCallbackInfo<Value>)
243500,METHOD,node_util.cc:<global>,TYPE_DECL,"static void GetProxyDetails(const FunctionCallbackInfo<Value>& args) {
  // Return undefined if it's not a proxy.
  if (!args[0]->IsProxy())
    return;

  Local<Proxy> proxy = args[0].As<Proxy>();

  // TODO(BridgeAR): Remove the length check as soon as we prohibit access to
  // the util binding layer. It's accessed in the wild and `esm` would break in
  // case the check is removed.
  if (args.Length() == 1 || args[1]->IsTrue()) {
    Local<Value> ret[] = {
      proxy->GetTarget(),
      proxy->GetHandler()
    };

    args.GetReturnValue().Set(
        Array::New(args.GetIsolate(), ret, arraysize(ret)));
  } else {
    Local<Value> ret = proxy->GetTarget();

    args.GetReturnValue().Set(ret);
  }
}",1,1,node_util.cc,node.util.GetProxyDetails,,false,118,141,GetProxyDetails,,,7,void node.util.GetProxyDetails (FunctionCallbackInfo<Value>)
243592,METHOD,node_util.cc:<global>,TYPE_DECL,"static void IsArrayBufferDetached(const FunctionCallbackInfo<Value>& args) {
  if (args[0]->IsArrayBuffer()) {
    auto buffer = args[0].As<v8::ArrayBuffer>();
    args.GetReturnValue().Set(buffer->WasDetached());
    return;
  }
  args.GetReturnValue().Set(false);
}",1,1,node_util.cc,node.util.IsArrayBufferDetached,,false,143,150,IsArrayBufferDetached,,,8,void node.util.IsArrayBufferDetached (FunctionCallbackInfo<Value>)
243634,METHOD,node_util.cc:<global>,TYPE_DECL,"static void PreviewEntries(const FunctionCallbackInfo<Value>& args) {
  if (!args[0]->IsObject())
    return;

  Environment* env = Environment::GetCurrent(args);
  bool is_key_value;
  Local<Array> entries;
  if (!args[0].As<Object>()->PreviewEntries(&is_key_value).ToLocal(&entries))
    return;
  // Fast path for WeakMap and WeakSet.
  if (args.Length() == 1)
    return args.GetReturnValue().Set(entries);

  Local<Value> ret[] = {
    entries,
    Boolean::New(env->isolate(), is_key_value)
  };
  return args.GetReturnValue().Set(
      Array::New(env->isolate(), ret, arraysize(ret)));
}",1,1,node_util.cc,node.util.PreviewEntries,,false,152,171,PreviewEntries,,,9,void node.util.PreviewEntries (FunctionCallbackInfo<Value>)
243733,METHOD,node_util.cc:<global>,TYPE_DECL,"static void Sleep(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsUint32());
  uint32_t msec = args[0].As<Uint32>()->Value();
  uv_sleep(msec);
}",1,1,node_util.cc,node.util.Sleep,,false,173,177,Sleep,,,10,void node.util.Sleep (FunctionCallbackInfo<Value>)
243759,METHOD,node_util.cc:<global>,TYPE_DECL,"void ArrayBufferViewHasBuffer(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsArrayBufferView());
  args.GetReturnValue().Set(args[0].As<ArrayBufferView>()->HasBuffer());
}",1,1,node_util.cc,node.util.ArrayBufferViewHasBuffer,,false,179,182,ArrayBufferViewHasBuffer,,,11,void node.util.ArrayBufferViewHasBuffer (FunctionCallbackInfo<Value>)
243787,METHOD,node_util.cc:<global>,TYPE_DECL,"WeakReference::WeakReference(Realm* realm,
                             Local<Object> object,
                             Local<Object> target)
    : WeakReference(realm, object, target, 0) {}",1,48,node_util.cc,node.util.WeakReference.WeakReference,,false,184,187,WeakReference,,,12,"ANY node.util.WeakReference.WeakReference (Realm*,Local<Object>,Local<Object>)"
243794,METHOD,node_util.cc:<global>,TYPE_DECL,"WeakReference::WeakReference(Realm* realm,
                             Local<Object> object,
                             Local<Object> target,
                             uint64_t reference_count)
    : SnapshotableObject(realm, object, type_int),
      reference_count_(reference_count) {
  MakeWeak();
  if (!target.IsEmpty()) {
    target_.Reset(realm->isolate(), target);
    if (reference_count_ == 0) {
      target_.SetWeak();
    }
  }
}",1,1,node_util.cc,node.util.WeakReference.WeakReference,,false,189,202,WeakReference,,,13,"ANY node.util.WeakReference.WeakReference (Realm*,Local<Object>,Local<Object>,uint64_t)"
243828,METHOD,node_util.cc:<global>,TYPE_DECL,"bool WeakReference::PrepareForSerialization(Local<Context> context,
                                            v8::SnapshotCreator* creator) {
  if (target_.IsEmpty()) {
    target_index_ = 0;
    return true;
  }

  // Users can still hold strong references to target in addition to the
  // reference that we manage here, and they could expect that the referenced
  // object remains the same as long as that external strong reference
  // is alive. Since we have no way to know if there is any other reference
  // keeping the target alive, the best we can do to maintain consistency is to
  // simply save a reference to the target in the snapshot (effectively making
  // it strong) during serialization, and restore it during deserialization.
  // If there's no known counted reference from our side, we'll make the
  // reference here weak upon deserialization so that it can be GC'ed if users
  // do not hold additional references to it.
  Local<Object> target = target_.Get(context->Get...",1,1,node_util.cc,node.util.WeakReference.PrepareForSerialization,,false,204,226,PrepareForSerialization,,,14,"bool node.util.WeakReference.PrepareForSerialization (Local<Context>,ANY*)"
243876,METHOD,node_util.cc:<global>,TYPE_DECL,"InternalFieldInfoBase* WeakReference::Serialize(int index) {
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info =
      InternalFieldInfoBase::New<InternalFieldInfo>(type());
  info->target = target_index_;
  info->reference_count = reference_count_;
  return info;
}",1,1,node_util.cc,node.util.WeakReference.Serialize,,false,228,235,Serialize,,,15,InternalFieldInfoBase node.util.WeakReference.Serialize (int)
243908,METHOD,node_util.cc:<global>,TYPE_DECL,"void WeakReference::Deserialize(Local<Context> context,
                                Local<Object> holder,
                                int index,
                                InternalFieldInfoBase* info) {
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  HandleScope scope(context->GetIsolate());

  InternalFieldInfo* weak_info = reinterpret_cast<InternalFieldInfo*>(info);
  Local<Object> target;
  if (weak_info->target != 0) {
    target = context->GetDataFromSnapshotOnce<Object>(weak_info->target)
                 .ToLocalChecked();
  }
  new WeakReference(
      Realm::GetCurrent(context), holder, target, weak_info->reference_count);
}",1,1,node_util.cc,node.util.WeakReference.Deserialize,,false,237,252,Deserialize,,,16,"void node.util.WeakReference.Deserialize (Local<Context>,Local<Object>,int,InternalFieldInfoBase*)"
243971,METHOD,node_util.cc:<global>,TYPE_DECL,"void WeakReference::New(const FunctionCallbackInfo<Value>& args) {
  Realm* realm = Realm::GetCurrent(args);
  CHECK(args.IsConstructCall());
  CHECK(args[0]->IsObject());
  new WeakReference(realm, args.This(), args[0].As<Object>());
}",1,1,node_util.cc,node.util.WeakReference.New,,false,254,259,New,,,17,void node.util.WeakReference.New (FunctionCallbackInfo<Value>)
244009,METHOD,node_util.cc:<global>,TYPE_DECL,"void WeakReference::Get(const FunctionCallbackInfo<Value>& args) {
  WeakReference* weak_ref = Unwrap<WeakReference>(args.Holder());
  Isolate* isolate = args.GetIsolate();
  if (!weak_ref->target_.IsEmpty())
    args.GetReturnValue().Set(weak_ref->target_.Get(isolate));
}",1,1,node_util.cc,node.util.WeakReference.Get,,false,261,266,Get,,,18,void node.util.WeakReference.Get (FunctionCallbackInfo<Value>)
244055,METHOD,node_util.cc:<global>,TYPE_DECL,"void WeakReference::IncRef(const FunctionCallbackInfo<Value>& args) {
  WeakReference* weak_ref = Unwrap<WeakReference>(args.Holder());
  weak_ref->reference_count_++;
  if (weak_ref->target_.IsEmpty()) return;
  if (weak_ref->reference_count_ == 1) weak_ref->target_.ClearWeak();
  args.GetReturnValue().Set(
      v8::Number::New(args.GetIsolate(), weak_ref->reference_count_));
}",1,1,node_util.cc,node.util.WeakReference.IncRef,,false,268,275,IncRef,,,19,void node.util.WeakReference.IncRef (FunctionCallbackInfo<Value>)
244117,METHOD,node_util.cc:<global>,TYPE_DECL,"void WeakReference::DecRef(const FunctionCallbackInfo<Value>& args) {
  WeakReference* weak_ref = Unwrap<WeakReference>(args.Holder());
  CHECK_GE(weak_ref->reference_count_, 1);
  weak_ref->reference_count_--;
  if (weak_ref->target_.IsEmpty()) return;
  if (weak_ref->reference_count_ == 0) weak_ref->target_.SetWeak();
  args.GetReturnValue().Set(
      v8::Number::New(args.GetIsolate(), weak_ref->reference_count_));
}",1,1,node_util.cc,node.util.WeakReference.DecRef,,false,277,285,DecRef,,,20,void node.util.WeakReference.DecRef (FunctionCallbackInfo<Value>)
244184,METHOD,node_util.cc:<global>,TYPE_DECL,"static void GuessHandleType(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  int fd;
  if (!args[0]->Int32Value(env->context()).To(&fd)) return;
  CHECK_GE(fd, 0);

  uv_handle_type t = uv_guess_handle(fd);
  // TODO(anonrig): We can use an enum here and then create the array in the
  // binding, which will remove the hard-coding in C++ and JS land.
  uint32_t type{0};

  // Currently, the return type of this function corresponds to the index of the
  // array defined in the JS land. This is done as an optimization to reduce the
  // string serialization overhead.
  switch (t) {
    case UV_TCP:
      type = 0;
      break;
    case UV_TTY:
      type = 1;
      break;
    case UV_UDP:
      type = 2;
      break;
    case UV_FILE:
      type = 3;
      break;
    case UV_NAMED_PIPE:
      type = 4;
      break;
    case UV_UNKNOWN_HANDLE:
      type = 5;
      break;
    default:
      ABORT();
  }

  args.GetReturnValue().Set(type);
}",1,1,node_util.cc,node.util.GuessHandleType,,false,287,325,GuessHandleType,,,21,void node.util.GuessHandleType (FunctionCallbackInfo<Value>)
244279,METHOD,node_util.cc:<global>,TYPE_DECL,"static uint32_t FastGuessHandleType(Local<Value> receiver, const uint32_t fd) {
  uv_handle_type t = uv_guess_handle(fd);
  uint32_t type{0};

  switch (t) {
    case UV_TCP:
      type = 0;
      break;
    case UV_TTY:
      type = 1;
      break;
    case UV_UDP:
      type = 2;
      break;
    case UV_FILE:
      type = 3;
      break;
    case UV_NAMED_PIPE:
      type = 4;
      break;
    case UV_UNKNOWN_HANDLE:
      type = 5;
      break;
    default:
      ABORT();
  }

  return type;
}",1,1,node_util.cc,node.util.FastGuessHandleType,,false,327,355,FastGuessHandleType,,,22,"uint32_t node.util.FastGuessHandleType (Local<Value>,uint32_t)"
244338,METHOD,node_util.cc:<global>,TYPE_DECL,CFunction fast_guess_handle_type_(CFunction::Make(FastGuessHandleType));,11,71,node_util.cc,node.util.fast_guess_handle_type_,,false,357,357,fast_guess_handle_type_,,,23,CFunction node.util.fast_guess_handle_type_ (ANY)
244343,METHOD,node_util.cc:<global>,TYPE_DECL,"static void ToUSVString(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK_GE(args.Length(), 2);
  CHECK(args[0]->IsString());
  CHECK(args[1]->IsNumber());

  TwoByteValue value(env->isolate(), args[0]);

  int64_t start = args[1]->IntegerValue(env->context()).FromJust();
  CHECK_GE(start, 0);

  for (size_t i = start; i < value.length(); i++) {
    char16_t c = value[i];
    if (!IsUnicodeSurrogate(c)) {
      continue;
    } else if (IsUnicodeSurrogateTrail(c) || i == value.length() - 1) {
      value[i] = kUnicodeReplacementCharacter;
    } else {
      char16_t d = value[i + 1];
      if (IsUnicodeTrail(d)) {
        i++;
      } else {
        value[i] = kUnicodeReplacementCharacter;
      }
    }
  }

  args.GetReturnValue().Set(
      String::NewFromTwoByte(env->isolate(),
                             *value,
                             v8::NewStringType::kNormal,
                             value.length()).ToLocalChecked...",1,1,node_util.cc,node.util.ToUSVString,,false,359,391,ToUSVString,,,24,void node.util.ToUSVString (FunctionCallbackInfo<Value>)
244503,METHOD,node_util.cc:<global>,TYPE_DECL,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(GetPromiseDetails);
  registry->Register(GetProxyDetails);
  registry->Register(IsArrayBufferDetached);
  registry->Register(PreviewEntries);
  registry->Register(GetOwnNonIndexProperties);
  registry->Register(GetConstructorName);
  registry->Register(GetExternalValue);
  registry->Register(Sleep);
  registry->Register(ArrayBufferViewHasBuffer);
  registry->Register(WeakReference::New);
  registry->Register(WeakReference::Get);
  registry->Register(WeakReference::IncRef);
  registry->Register(WeakReference::DecRef);
  registry->Register(GuessHandleType);
  registry->Register(FastGuessHandleType);
  registry->Register(fast_guess_handle_type_.GetTypeInfo());
  registry->Register(ToUSVString);
}",1,1,node_util.cc,node.util.RegisterExternalReferences,,false,393,411,RegisterExternalReferences,,,25,void node.util.RegisterExternalReferences (ExternalReferenceRegistry*)
244604,METHOD,node_util.cc:<global>,TYPE_DECL,"void Initialize(Local<Object> target,
                Local<Value> unused,
                Local<Context> context,
                void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  {
    Local<ObjectTemplate> tmpl = ObjectTemplate::New(isolate);
#define V(PropertyName, _)                                                     \
  tmpl->Set(FIXED_ONE_BYTE_STRING(env->isolate(), #PropertyName),              \
            env->PropertyName());

    PER_ISOLATE_PRIVATE_SYMBOL_PROPERTIES(V)
#undef V

    target
        ->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""privateSymbols""),
              tmpl->NewInstance(context).ToLocalChecked())
        .Check();
  }

  {
    Local<Object> constants = Object::New(isolate);
#define V(name)                                                                \
  constants                                                                    \
      ->Set(context,                      ...",1,4,node_util.cc,node.util.Initialize,,false,413,520,Initialize,,,26,"void node.util.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
245092,METHOD,node_util.hpp:<global>,TYPE_DECL,<global>,1,27,node_util.hpp,node_util.hpp:<global>,,false,1,52,<global>,,,1,
245115,METHOD,node_v8.cc:<global>,TYPE_DECL,<global>,1,1,node_v8.cc,node_v8.cc:<global>,,false,1,508,<global>,,,1,
245178,METHOD,node_v8.cc:<global>,TYPE_DECL,"BindingData::BindingData(Realm* realm,
                         Local<Object> obj,
                         InternalFieldInfo* info)
    : SnapshotableObject(realm, obj, type_int),
      heap_statistics_buffer(realm->isolate(),
                             kHeapStatisticsPropertiesCount,
                             MAYBE_FIELD_PTR(info, heap_statistics_buffer)),
      heap_space_statistics_buffer(
          realm->isolate(),
          kHeapSpaceStatisticsPropertiesCount,
          MAYBE_FIELD_PTR(info, heap_space_statistics_buffer)),
      heap_code_statistics_buffer(
          realm->isolate(),
          kHeapCodeStatisticsPropertiesCount,
          MAYBE_FIELD_PTR(info, heap_code_statistics_buffer)) {
  Local<Context> context = realm->context();
  if (info == nullptr) {
    obj->Set(context,
             FIXED_ONE_BYTE_STRING(realm->isolate(), ""heapStatisticsBuffer""),
             heap_statistics_buffer.GetJSArray())
        .Check();
    obj->Set(
           context,
           ...",1,1,node_v8.cc,node.v8_utils.BindingData.BindingData,,false,95,134,BindingData,,,7,"ANY node.v8_utils.BindingData.BindingData (Realm*,Local<Object>,InternalFieldInfo*)"
245292,METHOD,node_v8.cc:<global>,TYPE_DECL,"bool BindingData::PrepareForSerialization(Local<Context> context,
                                          v8::SnapshotCreator* creator) {
  DCHECK_NULL(internal_field_info_);
  internal_field_info_ = InternalFieldInfoBase::New<InternalFieldInfo>(type());
  internal_field_info_->heap_statistics_buffer =
      heap_statistics_buffer.Serialize(context, creator);
  internal_field_info_->heap_space_statistics_buffer =
      heap_space_statistics_buffer.Serialize(context, creator);
  internal_field_info_->heap_code_statistics_buffer =
      heap_code_statistics_buffer.Serialize(context, creator);
  // Return true because we need to maintain the reference to the binding from
  // JS land.
  return true;
}",1,1,node_v8.cc,node.v8_utils.BindingData.PrepareForSerialization,,false,136,149,PrepareForSerialization,,,8,"bool node.v8_utils.BindingData.PrepareForSerialization (Local<Context>,ANY*)"
245340,METHOD,node_v8.cc:<global>,TYPE_DECL,"void BindingData::Deserialize(Local<Context> context,
                              Local<Object> holder,
                              int index,
                              InternalFieldInfoBase* info) {
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  HandleScope scope(context->GetIsolate());
  Realm* realm = Realm::GetCurrent(context);
  // Recreate the buffer in the constructor.
  InternalFieldInfo* casted_info = static_cast<InternalFieldInfo*>(info);
  BindingData* binding =
      realm->AddBindingData<BindingData>(context, holder, casted_info);
  CHECK_NOT_NULL(binding);
}",1,1,node_v8.cc,node.v8_utils.BindingData.Deserialize,,false,151,163,Deserialize,,,9,"void node.v8_utils.BindingData.Deserialize (Local<Context>,Local<Object>,int,InternalFieldInfoBase*)"
245389,METHOD,node_v8.cc:<global>,TYPE_DECL,"InternalFieldInfoBase* BindingData::Serialize(int index) {
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info = internal_field_info_;
  internal_field_info_ = nullptr;
  return info;
}",1,1,node_v8.cc,node.v8_utils.BindingData.Serialize,,false,165,170,Serialize,,,10,InternalFieldInfoBase node.v8_utils.BindingData.Serialize (int)
245408,METHOD,node_v8.cc:<global>,TYPE_DECL,"void BindingData::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""heap_statistics_buffer"", heap_statistics_buffer);
  tracker->TrackField(""heap_space_statistics_buffer"",
                      heap_space_statistics_buffer);
  tracker->TrackField(""heap_code_statistics_buffer"",
                      heap_code_statistics_buffer);
}",1,1,node_v8.cc,node.v8_utils.BindingData.MemoryInfo,,false,172,178,MemoryInfo,,,11,void node.v8_utils.BindingData.MemoryInfo (MemoryTracker*)
245431,METHOD,node_v8.cc:<global>,TYPE_DECL,"void CachedDataVersionTag(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Local<Integer> result =
      Integer::NewFromUnsigned(env->isolate(),
                               ScriptCompiler::CachedDataVersionTag());
  args.GetReturnValue().Set(result);
}",1,1,node_v8.cc,node.v8_utils.CachedDataVersionTag,,false,180,186,CachedDataVersionTag,,,12,void node.v8_utils.CachedDataVersionTag (FunctionCallbackInfo<Value>)
245470,METHOD,node_v8.cc:<global>,TYPE_DECL,"void SetHeapSnapshotNearHeapLimit(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsUint32());
  Environment* env = Environment::GetCurrent(args);
  uint32_t limit = args[0].As<v8::Uint32>()->Value();
  CHECK_GT(limit, 0);
  env->AddHeapSnapshotNearHeapLimitCallback();
  env->set_heap_snapshot_near_heap_limit(limit);
}",1,1,node_v8.cc,node.v8_utils.SetHeapSnapshotNearHeapLimit,,false,188,195,SetHeapSnapshotNearHeapLimit,,,13,void node.v8_utils.SetHeapSnapshotNearHeapLimit (FunctionCallbackInfo<Value>)
245514,METHOD,node_v8.cc:<global>,TYPE_DECL,"void UpdateHeapStatisticsBuffer(const FunctionCallbackInfo<Value>& args) {
  BindingData* data = Realm::GetBindingData<BindingData>(args);
  HeapStatistics s;
  args.GetIsolate()->GetHeapStatistics(&s);
  AliasedFloat64Array& buffer = data->heap_statistics_buffer;
#define V(index, name, _) buffer[index] = static_cast<double>(s.name());
  HEAP_STATISTICS_PROPERTIES(V)
#undef V
}",1,2,node_v8.cc,node.v8_utils.UpdateHeapStatisticsBuffer,,false,197,205,UpdateHeapStatisticsBuffer,,,14,void node.v8_utils.UpdateHeapStatisticsBuffer (FunctionCallbackInfo<Value>)
245687,METHOD,node_v8.cc:<global>,TYPE_DECL,"void UpdateHeapSpaceStatisticsBuffer(const FunctionCallbackInfo<Value>& args) {
  BindingData* data = Realm::GetBindingData<BindingData>(args);
  HeapSpaceStatistics s;
  Isolate* const isolate = args.GetIsolate();
  CHECK(args[0]->IsUint32());
  size_t space_index = static_cast<size_t>(args[0].As<v8::Uint32>()->Value());
  isolate->GetHeapSpaceStatistics(&s, space_index);

  AliasedFloat64Array& buffer = data->heap_space_statistics_buffer;

#define V(index, name, _) buffer[index] = static_cast<double>(s.name());
  HEAP_SPACE_STATISTICS_PROPERTIES(V)
#undef V
}",1,2,node_v8.cc,node.v8_utils.UpdateHeapSpaceStatisticsBuffer,,false,208,221,UpdateHeapSpaceStatisticsBuffer,,,15,void node.v8_utils.UpdateHeapSpaceStatisticsBuffer (FunctionCallbackInfo<Value>)
245786,METHOD,node_v8.cc:<global>,TYPE_DECL,"void UpdateHeapCodeStatisticsBuffer(const FunctionCallbackInfo<Value>& args) {
  BindingData* data = Realm::GetBindingData<BindingData>(args);
  HeapCodeStatistics s;
  args.GetIsolate()->GetHeapCodeAndMetadataStatistics(&s);
  AliasedFloat64Array& buffer = data->heap_code_statistics_buffer;

#define V(index, name, _) buffer[index] = static_cast<double>(s.name());
  HEAP_CODE_STATISTICS_PROPERTIES(V)
#undef V
}",1,2,node_v8.cc,node.v8_utils.UpdateHeapCodeStatisticsBuffer,,false,223,232,UpdateHeapCodeStatisticsBuffer,,,16,void node.v8_utils.UpdateHeapCodeStatisticsBuffer (FunctionCallbackInfo<Value>)
245859,METHOD,node_v8.cc:<global>,TYPE_DECL,"void SetFlagsFromString(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsString());
  String::Utf8Value flags(args.GetIsolate(), args[0]);
  V8::SetFlagsFromString(*flags, static_cast<size_t>(flags.length()));
}",1,1,node_v8.cc,node.v8_utils.SetFlagsFromString,,false,235,239,SetFlagsFromString,,,17,void node.v8_utils.SetFlagsFromString (FunctionCallbackInfo<Value>)
245892,METHOD,node_v8.cc:<global>,TYPE_DECL,"static const char* GetGCTypeName(v8::GCType gc_type) {
  switch (gc_type) {
    case v8::GCType::kGCTypeScavenge:
      return ""Scavenge"";
    case v8::GCType::kGCTypeMarkSweepCompact:
      return ""MarkSweepCompact"";
    case v8::GCType::kGCTypeIncrementalMarking:
      return ""IncrementalMarking"";
    case v8::GCType::kGCTypeProcessWeakCallbacks:
      return ""ProcessWeakCallbacks"";
    default:
      return ""Unknown"";
  }
}",1,1,node_v8.cc,node.v8_utils.GetGCTypeName,,false,241,254,GetGCTypeName,,,18,const char* node.v8_utils.GetGCTypeName (ANY)
245935,METHOD,node_v8.cc:<global>,TYPE_DECL,"static void SetHeapStatistics(JSONWriter* writer, Isolate* isolate) {
  HeapStatistics heap_statistics;
  isolate->GetHeapStatistics(&heap_statistics);
  writer->json_objectstart(""heapStatistics"");
  writer->json_keyvalue(""totalHeapSize"", heap_statistics.total_heap_size());
  writer->json_keyvalue(""totalHeapSizeExecutable"",
                        heap_statistics.total_heap_size_executable());
  writer->json_keyvalue(""totalPhysicalSize"",
                        heap_statistics.total_physical_size());
  writer->json_keyvalue(""totalAvailableSize"",
                        heap_statistics.total_available_size());
  writer->json_keyvalue(""totalGlobalHandlesSize"",
                        heap_statistics.total_global_handles_size());
  writer->json_keyvalue(""usedGlobalHandlesSize"",
                        heap_statistics.used_global_handles_size());
  writer->json_keyvalue(""usedHeapSize"", heap_statistics.used_heap_size());
  writer->json_keyvalue(""heapSizeLimit"", heap_statistics.heap_size_...",1,1,node_v8.cc,node.v8_utils.SetHeapStatistics,,false,256,296,SetHeapStatistics,,,19,"void node.v8_utils.SetHeapStatistics (JSONWriter*,Isolate*)"
246145,METHOD,node_v8.cc:<global>,TYPE_DECL,"static void BeforeGCCallback(Isolate* isolate,
                             v8::GCType gc_type,
                             v8::GCCallbackFlags flags,
                             void* data) {
  GCProfiler* profiler = static_cast<GCProfiler*>(data);
  if (profiler->current_gc_type != 0) {
    return;
  }
  JSONWriter* writer = profiler->writer();
  writer->json_start();
  writer->json_keyvalue(""gcType"", GetGCTypeName(gc_type));
  writer->json_objectstart(""beforeGC"");
  SetHeapStatistics(writer, isolate);
  writer->json_objectend();
  profiler->current_gc_type = gc_type;
  profiler->start_time = uv_hrtime();
}",1,1,node_v8.cc,node.v8_utils.BeforeGCCallback,,false,298,314,BeforeGCCallback,,,20,"void node.v8_utils.BeforeGCCallback (Isolate*,ANY,ANY,void*)"
246207,METHOD,node_v8.cc:<global>,TYPE_DECL,"static void AfterGCCallback(Isolate* isolate,
                            v8::GCType gc_type,
                            v8::GCCallbackFlags flags,
                            void* data) {
  GCProfiler* profiler = static_cast<GCProfiler*>(data);
  if (profiler->current_gc_type != gc_type) {
    return;
  }
  JSONWriter* writer = profiler->writer();
  profiler->current_gc_type = 0;
  writer->json_keyvalue(""cost"", (uv_hrtime() - profiler->start_time) / 1e3);
  profiler->start_time = 0;
  writer->json_objectstart(""afterGC"");
  SetHeapStatistics(writer, isolate);
  writer->json_objectend();
  writer->json_end();
}",1,1,node_v8.cc,node.v8_utils.AfterGCCallback,,false,316,332,AfterGCCallback,,,21,"void node.v8_utils.AfterGCCallback (Isolate*,ANY,ANY,void*)"
246274,METHOD,node_v8.cc:<global>,TYPE_DECL,"GCProfiler::GCProfiler(Environment* env, Local<Object> object)
    : BaseObject(env, object),
      start_time(0),
      current_gc_type(0),
      state(GCProfilerState::kInitialized),
      writer_(out_stream_, false) {
  MakeWeak();
}",1,1,node_v8.cc,node.v8_utils.GCProfiler.GCProfiler,,false,334,341,GCProfiler,,,22,"ANY node.v8_utils.GCProfiler.GCProfiler (Environment*,Local<Object>)"
246281,METHOD,node_v8.cc:<global>,TYPE_DECL,"GCProfiler::~GCProfiler() {
  if (state != GCProfiler::GCProfilerState::kInitialized) {
    env()->isolate()->RemoveGCPrologueCallback(BeforeGCCallback, this);
    env()->isolate()->RemoveGCEpilogueCallback(AfterGCCallback, this);
  }
}",1,1,node_v8.cc,node.v8_utils.GCProfiler.~GCProfiler,,false,348,353,~GCProfiler,,,23,ANY node.v8_utils.GCProfiler.~GCProfiler ()
246312,METHOD,node_v8.cc:<global>,TYPE_DECL,"JSONWriter* GCProfiler::writer() {
  return &writer_;
}",1,1,node_v8.cc,node.v8_utils.GCProfiler.writer,,false,355,357,writer,,,24,JSONWriter node.v8_utils.GCProfiler.writer ()
246319,METHOD,node_v8.cc:<global>,TYPE_DECL,"std::ostringstream* GCProfiler::out_stream() {
  return &out_stream_;
}",1,1,node_v8.cc,node.v8_utils.GCProfiler.out_stream,,false,359,361,out_stream,,,25,ostringstream node.v8_utils.GCProfiler.out_stream ()
246326,METHOD,node_v8.cc:<global>,TYPE_DECL,"void GCProfiler::New(const FunctionCallbackInfo<Value>& args) {
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new GCProfiler(env, args.This());
}",1,1,node_v8.cc,node.v8_utils.GCProfiler.New,,false,363,367,New,,,26,void node.v8_utils.GCProfiler.New (FunctionCallbackInfo<Value>)
246351,METHOD,node_v8.cc:<global>,TYPE_DECL,"void GCProfiler::Start(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  GCProfiler* profiler;
  ASSIGN_OR_RETURN_UNWRAP(&profiler, args.Holder());
  if (profiler->state != GCProfiler::GCProfilerState::kInitialized) {
    return;
  }
  profiler->writer()->json_start();
  profiler->writer()->json_keyvalue(""version"", 1);

  uv_timeval64_t ts;
  if (uv_gettimeofday(&ts) == 0) {
    profiler->writer()->json_keyvalue(""startTime"",
                                      ts.tv_sec * 1000 + ts.tv_usec / 1000);
  } else {
    profiler->writer()->json_keyvalue(""startTime"", 0);
  }
  profiler->writer()->json_arraystart(""statistics"");
  env->isolate()->AddGCPrologueCallback(BeforeGCCallback,
                                        static_cast<void*>(profiler));
  env->isolate()->AddGCEpilogueCallback(AfterGCCallback,
                                        static_cast<void*>(profiler));
  profiler->state = GCProfiler::GCProfilerState::kStarted;
}",1,1,node_v8.cc,node.v8_utils.GCProfiler.Start,,false,369,392,Start,,,27,void node.v8_utils.GCProfiler.Start (FunctionCallbackInfo<Value>)
246477,METHOD,node_v8.cc:<global>,TYPE_DECL,"void GCProfiler::Stop(const FunctionCallbackInfo<v8::Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  GCProfiler* profiler;
  ASSIGN_OR_RETURN_UNWRAP(&profiler, args.Holder());
  if (profiler->state != GCProfiler::GCProfilerState::kStarted) {
    return;
  }
  profiler->writer()->json_arrayend();
  uv_timeval64_t ts;
  if (uv_gettimeofday(&ts) == 0) {
    profiler->writer()->json_keyvalue(""endTime"",
                                      ts.tv_sec * 1000 + ts.tv_usec / 1000);
  } else {
    profiler->writer()->json_keyvalue(""endTime"", 0);
  }
  profiler->writer()->json_end();
  profiler->state = GCProfiler::GCProfilerState::kStopped;
  auto string = profiler->out_stream()->str();
  args.GetReturnValue().Set(String::NewFromUtf8(env->isolate(),
                                                string.data(),
                                                v8::NewStringType::kNormal,
                                                string.size())
                      ...",1,1,node_v8.cc,node.v8_utils.GCProfiler.Stop,,false,394,417,Stop,,,28,void node.v8_utils.GCProfiler.Stop (ANY)
246612,METHOD,node_v8.cc:<global>,TYPE_DECL,"void Initialize(Local<Object> target,
                Local<Value> unused,
                Local<Context> context,
                void* priv) {
  Realm* realm = Realm::GetCurrent(context);
  Environment* env = realm->env();
  BindingData* const binding_data =
      realm->AddBindingData<BindingData>(context, target);
  if (binding_data == nullptr) return;

  SetMethodNoSideEffect(
      context, target, ""cachedDataVersionTag"", CachedDataVersionTag);
  SetMethodNoSideEffect(context,
                        target,
                        ""setHeapSnapshotNearHeapLimit"",
                        SetHeapSnapshotNearHeapLimit);
  SetMethod(context,
            target,
            ""updateHeapStatisticsBuffer"",
            UpdateHeapStatisticsBuffer);

  SetMethod(context,
            target,
            ""updateHeapCodeStatisticsBuffer"",
            UpdateHeapCodeStatisticsBuffer);

  size_t number_of_heap_spaces = env->isolate()->NumberOfHeapSpaces();

  // Heap space names are extracted ...",1,2,node_v8.cc,node.v8_utils.Initialize,,false,419,490,Initialize,,,29,"void node.v8_utils.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
247327,METHOD,node_v8.cc:<global>,TYPE_DECL,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(CachedDataVersionTag);
  registry->Register(UpdateHeapStatisticsBuffer);
  registry->Register(UpdateHeapCodeStatisticsBuffer);
  registry->Register(UpdateHeapSpaceStatisticsBuffer);
  registry->Register(SetFlagsFromString);
  registry->Register(SetHeapSnapshotNearHeapLimit);
  registry->Register(GCProfiler::New);
  registry->Register(GCProfiler::Start);
  registry->Register(GCProfiler::Stop);
}",1,1,node_v8.cc,node.v8_utils.RegisterExternalReferences,,false,492,502,RegisterExternalReferences,,,30,void node.v8_utils.RegisterExternalReferences (ExternalReferenceRegistry*)
247401,METHOD,node_v8.hpp:<global>,TYPE_DECL,<global>,1,25,node_v8.hpp,node_v8.hpp:<global>,,false,1,77,<global>,,,1,
247428,METHOD,node_v8_platform-inl.hpp:<global>,TYPE_DECL,<global>,1,38,node_v8_platform-inl.hpp,node_v8_platform-inl.hpp:<global>,,false,1,205,<global>,,,1,
247433,METHOD,node_version.hpp:<global>,TYPE_DECL,<global>,1,5,node_version.hpp,node_version.hpp:<global>,,false,1,102,<global>,,,1,
247460,METHOD,node_wasi.cc:<global>,TYPE_DECL,<global>,1,25,env-inl.hpp,node_wasi.cc:<global>,,false,1,1334,<global>,,,1,
247464,METHOD,node_wasi.cc:<global>,TYPE_DECL,"inline void Debug(const WASI& wasi, Args&&... args) {
  Debug(wasi.env(), DebugCategory::WASI, std::forward<Args>(args)...);
}",1,1,node_wasi.cc,node.wasi.Debug,,false,17,19,Debug,,,1,"void node.wasi.Debug<Args> (WASI,Args)"
247485,METHOD,node_wasi.cc:<global>,TYPE_DECL,"static MaybeLocal<Value> WASIException(Local<Context> context,
                                       int errorno,
                                       const char* syscall) {
  Isolate* isolate = context->GetIsolate();
  Environment* env = Environment::GetCurrent(context);
  CHECK_NOT_NULL(env);
  const char* err_name = uvwasi_embedder_err_code_to_string(errorno);
  Local<String> js_code = OneByteString(isolate, err_name);
  Local<String> js_syscall = OneByteString(isolate, syscall);
  Local<String> js_msg = js_code;
  js_msg =
      String::Concat(isolate, js_msg, FIXED_ONE_BYTE_STRING(isolate, "", ""));
  js_msg = String::Concat(isolate, js_msg, js_syscall);
  Local<Object> e;
  if (!Exception::Error(js_msg)->ToObject(context).ToLocal(&e))
    return MaybeLocal<Value>();

  if (e->Set(context,
             env->errno_string(),
             Integer::New(isolate, errorno)).IsNothing() ||
      e->Set(context, env->code_string(), js_code).IsNothing() ||
      e->Set(context, env->sys...",1,1,node_wasi.cc,node.wasi.WASIException,,false,48,74,WASIException,,,2,"MaybeLocal<Value> node.wasi.WASIException (Local<Context>,int,char*)"
247635,METHOD,node_wasi.cc:<global>,TYPE_DECL,"WASI::WASI(Environment* env,
           Local<Object> object,
           uvwasi_options_t* options) : BaseObject(env, object) {
  MakeWeak();
  alloc_info_ = MakeAllocator();
  options->allocator = &alloc_info_;
  int err = uvwasi_init(&uvw_, options);
  if (err != UVWASI_ESUCCESS) {
    Local<Value> exception;
    if (!WASIException(env->context(), err, ""uvwasi_init"").ToLocal(&exception))
      return;

    env->isolate()->ThrowException(exception);
  }
}",1,1,node_wasi.cc,node.wasi.WASI.WASI,,false,77,91,WASI,,,3,"ANY node.wasi.WASI.WASI (Environment*,Local<Object>,uvwasi_options_t*)"
247693,METHOD,node_wasi.cc:<global>,TYPE_DECL,"WASI::~WASI() {
  uvwasi_destroy(&uvw_);
  CHECK_EQ(current_uvwasi_memory_, 0);
}",1,1,node_wasi.cc,node.wasi.WASI.~WASI,,false,94,97,~WASI,,,4,ANY node.wasi.WASI.~WASI ()
247701,METHOD,node_wasi.cc:<global>,TYPE_DECL,"void WASI::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""memory"", memory_);
  tracker->TrackFieldWithSize(""uvwasi_memory"", current_uvwasi_memory_);
}",1,1,node_wasi.cc,node.wasi.WASI.MemoryInfo,,false,99,102,MemoryInfo,,,5,void node.wasi.WASI.MemoryInfo (MemoryTracker*)
247718,METHOD,node_wasi.cc:<global>,TYPE_DECL,"void WASI::CheckAllocatedSize(size_t previous_size) const {
  CHECK_GE(current_uvwasi_memory_, previous_size);
}",1,1,node_wasi.cc,node.wasi.WASI.CheckAllocatedSize,,false,104,106,CheckAllocatedSize,,,6,void node.wasi.WASI.CheckAllocatedSize (size_t)
247726,METHOD,node_wasi.cc:<global>,TYPE_DECL,"void WASI::IncreaseAllocatedSize(size_t size) {
  current_uvwasi_memory_ += size;
}",1,1,node_wasi.cc,node.wasi.WASI.IncreaseAllocatedSize,,false,108,110,IncreaseAllocatedSize,,,7,void node.wasi.WASI.IncreaseAllocatedSize (size_t)
247734,METHOD,node_wasi.cc:<global>,TYPE_DECL,"void WASI::DecreaseAllocatedSize(size_t size) {
  current_uvwasi_memory_ -= size;
}",1,1,node_wasi.cc,node.wasi.WASI.DecreaseAllocatedSize,,false,112,114,DecreaseAllocatedSize,,,8,void node.wasi.WASI.DecreaseAllocatedSize (size_t)
247742,METHOD,node_wasi.cc:<global>,TYPE_DECL,"void WASI::New(const FunctionCallbackInfo<Value>& args) {
  CHECK(args.IsConstructCall());
  CHECK_EQ(args.Length(), 4);
  CHECK(args[0]->IsArray());
  CHECK(args[1]->IsArray());
  CHECK(args[2]->IsArray());
  CHECK(args[3]->IsArray());

  Environment* env = Environment::GetCurrent(args);
  Local<Context> context = env->context();
  Local<Array> argv = args[0].As<Array>();
  const uint32_t argc = argv->Length();
  uvwasi_options_t options;

  uvwasi_options_init(&options);

  Local<Array> stdio = args[3].As<Array>();
  CHECK_EQ(stdio->Length(), 3);
  options.in = stdio->Get(context, 0).ToLocalChecked()->
    Int32Value(context).FromJust();
  options.out = stdio->Get(context, 1).ToLocalChecked()->
    Int32Value(context).FromJust();
  options.err = stdio->Get(context, 2).ToLocalChecked()->
    Int32Value(context).FromJust();

  options.fd_table_size = 3;
  options.argc = argc;
  options.argv =
    const_cast<const char**>(argc == 0 ? nullptr : new char*[argc]);

  for (uint32_t i = 0...",1,1,node_wasi.cc,node.wasi.WASI.New,,false,116,205,New,,,9,void node.wasi.WASI.New (FunctionCallbackInfo<Value>)
248324,METHOD,node_wasi.cc:<global>,TYPE_DECL,"void WASI::WasiFunction<FT, F, R, Args...>::SetFunction(
    Environment* env, const char* name, Local<FunctionTemplate> tmpl) {
  auto c_function = CFunction::Make(FastCallback);
  Local<FunctionTemplate> t =
      FunctionTemplate::New(env->isolate(),
                            SlowCallback,
                            Local<Value>(),
                            Local<Signature>(),
                            sizeof...(Args),
                            v8::ConstructorBehavior::kThrow,
                            v8::SideEffectType::kHasSideEffect,
                            &c_function);
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<String> name_string =
      String::NewFromUtf8(env->isolate(), name, type).ToLocalChecked();
  tmpl->PrototypeTemplate()->Set(name_string, t);
  t->SetClassName(name_string);
}",1,1,node_wasi.cc,"node.wasi.WASI.WasiFunction<FT,F,R,Args...>.SetFunction",,false,208,225,SetFunction,,,10,"void node.wasi.WASI.WasiFunction<FT,F,R,Args...>.SetFunction<FT,FT,R,Args> (Environment*,char*,Local<FunctionTemplate>)"
248412,METHOD,node_wasi.cc:<global>,TYPE_DECL,inline R EinvalError();,10,22,node_wasi.cc,node.wasi.anonymous_namespace_1.EinvalError,,false,229,229,EinvalError,,,1,R node.wasi.anonymous_namespace_1.EinvalError<R> ()
248416,METHOD,node_wasi.cc:<global>,TYPE_DECL,"inline uint32_t EinvalError() {
  return UVWASI_EINVAL;
}",1,1,node_wasi.cc,node.wasi.anonymous_namespace_2.EinvalError,,false,232,234,EinvalError,,,2,uint32_t node.wasi.anonymous_namespace_2.EinvalError<> ()
248422,METHOD,node_wasi.cc:<global>,TYPE_DECL,inline void EinvalError() {},1,28,node_wasi.cc,node.wasi.anonymous_namespace_3.EinvalError,,false,237,237,EinvalError,,,3,void node.wasi.anonymous_namespace_3.EinvalError<> ()
248426,METHOD,node_wasi.cc:<global>,TYPE_DECL,"R WASI::WasiFunction<FT, F, R, Args...>::FastCallback(
    Local<Object> receiver,
    Args... args,
    // NOLINTNEXTLINE(runtime/references) This is V8 api.
    FastApiCallbackOptions& options) {
  WASI* wasi = reinterpret_cast<WASI*>(BaseObject::FromJSObject(receiver));
  if (UNLIKELY(wasi == nullptr)) return EinvalError<R>();

  if (UNLIKELY(options.wasm_memory == nullptr || wasi->memory_.IsEmpty())) {
    // fallback to slow path which to throw an error about missing memory.
    options.fallback = true;
    return EinvalError<R>();
  }
  uint8_t* memory = nullptr;
  CHECK(LIKELY(options.wasm_memory->getStorageIfAligned(&memory)));

  return F(*wasi,
           {reinterpret_cast<char*>(memory), options.wasm_memory->length()},
           args...);
}",1,1,node_wasi.cc,"node.wasi.WASI.WasiFunction<FT,F,R,Args...>.FastCallback",,false,241,260,FastCallback,,,12,"R node.wasi.WASI.WasiFunction<FT,F,R,Args...>.FastCallback<FT,FT,R,Args> (Local<Object>,Args,FastApiCallbackOptions)"
248503,METHOD,node_wasi.cc:<global>,TYPE_DECL,static bool CheckType(Local<Value> v);,13,37,node_wasi.cc,node.wasi.anonymous_namespace_5.CheckType,,false,264,264,CheckType,,,1,bool node.wasi.anonymous_namespace_5.CheckType<VT> (Local<Value>)
248508,METHOD,node_wasi.cc:<global>,TYPE_DECL,static VT ConvertType(Local<Value> V);,11,37,node_wasi.cc,node.wasi.anonymous_namespace_6.ConvertType,,false,267,267,ConvertType,,,2,VT node.wasi.anonymous_namespace_6.ConvertType<VT> (Local<Value>)
248513,METHOD,node_wasi.cc:<global>,TYPE_DECL,"bool CheckType<uint32_t>(Local<Value> value) {
  return value->IsUint32();
}",1,1,node_wasi.cc,node.wasi.anonymous_namespace_7.CheckType<uint32_t>,,false,270,272,CheckType,,,3,bool node.wasi.anonymous_namespace_7.CheckType<uint32_t><> (Local<Value>)
248523,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t ConvertType(Local<Value> value) {
  return value.As<Uint32>()->Value();
}",1,1,node_wasi.cc,node.wasi.anonymous_namespace_8.ConvertType,,false,275,277,ConvertType,,,4,uint32_t node.wasi.anonymous_namespace_8.ConvertType<> (Local<Value>)
248536,METHOD,node_wasi.cc:<global>,TYPE_DECL,"bool CheckType<uint64_t>(Local<Value> value) {
  return value->IsBigInt();
}",1,1,node_wasi.cc,node.wasi.anonymous_namespace_9.CheckType<uint64_t>,,false,280,282,CheckType,,,5,bool node.wasi.anonymous_namespace_9.CheckType<uint64_t><> (Local<Value>)
248546,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint64_t ConvertType(Local<Value> value) {
  Local<BigInt> js_value = value.As<BigInt>();
  bool lossless;
  return js_value->Uint64Value(&lossless);
}",1,1,node_wasi.cc,node.wasi.anonymous_namespace_10.ConvertType,,false,285,289,ConvertType,,,6,uint64_t node.wasi.anonymous_namespace_10.ConvertType<> (Local<Value>)
248569,METHOD,node_wasi.cc:<global>,TYPE_DECL,"bool CheckType<int64_t>(Local<Value> value) {
  return value->IsBigInt();
}",1,1,node_wasi.cc,node.wasi.anonymous_namespace_11.CheckType<int64_t>,,false,292,294,CheckType,,,7,bool node.wasi.anonymous_namespace_11.CheckType<int64_t><> (Local<Value>)
248579,METHOD,node_wasi.cc:<global>,TYPE_DECL,"int64_t ConvertType(Local<Value> value) {
  Local<BigInt> js_value = value.As<BigInt>();
  bool lossless;
  return js_value->Int64Value(&lossless);
}",1,1,node_wasi.cc,node.wasi.anonymous_namespace_12.ConvertType,,false,297,301,ConvertType,,,8,int64_t node.wasi.anonymous_namespace_12.ConvertType<> (Local<Value>)
248602,METHOD,node_wasi.cc:<global>,TYPE_DECL,"bool CheckTypes(const FunctionCallbackInfo<Value>& info, int i, T) {
  return CheckType<T>(info[i]);
}",1,1,node_wasi.cc,node.wasi.anonymous_namespace_13.CheckTypes,,false,304,306,CheckTypes,,,9,"bool node.wasi.anonymous_namespace_13.CheckTypes<T> (FunctionCallbackInfo<Value>,int,T)"
248614,METHOD,node_wasi.cc:<global>,TYPE_DECL,"bool CheckTypes(const FunctionCallbackInfo<Value>& info,
                int i,
                T arg,
                Ts... args) {
  if (!CheckTypes<T>(info, i, arg)) return false;
  return CheckTypes<Ts...>(info, i + 1, args...);
}",1,1,node_wasi.cc,node.wasi.anonymous_namespace_14.CheckTypes,,false,309,315,CheckTypes,,,10,"bool node.wasi.anonymous_namespace_14.CheckTypes<T,Ts> (FunctionCallbackInfo<Value>,int,T,Ts)"
248638,METHOD,node_wasi.cc:<global>,TYPE_DECL,"bool CheckTypes(const FunctionCallbackInfo<Value>& info) {
  return CheckTypes<Args...>(info, 0, Args()...);
}",1,1,node_wasi.cc,node.wasi.anonymous_namespace_15.CheckTypes,,false,318,320,CheckTypes,,,11,bool node.wasi.anonymous_namespace_15.CheckTypes<Args> (FunctionCallbackInfo<Value>)
248648,METHOD,node_wasi.cc:<global>,TYPE_DECL,"bool CheckTypes(const FunctionCallbackInfo<Value>& info) {
  return true;
}",1,1,node_wasi.cc,node.wasi.anonymous_namespace_16.CheckTypes,,false,323,325,CheckTypes,,,12,bool node.wasi.anonymous_namespace_16.CheckTypes<> (FunctionCallbackInfo<Value>)
248655,METHOD,node_wasi.cc:<global>,TYPE_DECL,"inline void CallAndSetReturn(std::index_sequence<Indices...>,
                             const FunctionCallbackInfo<Value>& args,
                             WASI* wasi,
                             WasmMemory memory) {
  args.GetReturnValue().Set(
      F(*wasi, memory, ConvertType<Args>(args[Indices])...));
}",1,1,node_wasi.cc,node.wasi.anonymous_namespace_17.CallAndSetReturn,,false,333,339,CallAndSetReturn,,,13,"void node.wasi.anonymous_namespace_17.CallAndSetReturn<FT,FT,R,Args,std::size_t...,std::enable_if_t<!std::is_void<R>::value,bool>=true> (ANY,FunctionCallbackInfo<Value>,WASI*,WasmMemory)"
248678,METHOD,node_wasi.cc:<global>,TYPE_DECL,"inline void CallAndSetReturn(std::index_sequence<Indices...>,
                             const FunctionCallbackInfo<Value>& args,
                             WASI* wasi,
                             WasmMemory memory) {
  F(*wasi, memory, ConvertType<Args>(args[Indices])...);
}",1,1,node_wasi.cc,node.wasi.anonymous_namespace_18.CallAndSetReturn,,false,347,352,CallAndSetReturn,,,14,"void node.wasi.anonymous_namespace_18.CallAndSetReturn<FT,FT,R,Args,std::size_t...,std::enable_if_t<std::is_void<R>::value,bool>=true> (ANY,FunctionCallbackInfo<Value>,WASI*,WasmMemory)"
248694,METHOD,node_wasi.cc:<global>,TYPE_DECL,"void WASI::WasiFunction<FT, F, R, Args...>::SlowCallback(
    const FunctionCallbackInfo<Value>& args) {
  if (args.Length() != sizeof...(Args)) {
    args.GetReturnValue().Set(UVWASI_EINVAL);
    return;
  }
  if (!CheckTypes<Args...>(args)) {
    args.GetReturnValue().Set(UVWASI_EINVAL);
    return;
  }

  WASI* wasi;
  ASSIGN_OR_RETURN_UNWRAP(&wasi, args.This());
  if (wasi->memory_.IsEmpty()) {
    THROW_ERR_WASI_NOT_STARTED(Environment::GetCurrent(args));
    return;
  }

  Local<WasmMemoryObject> memory = PersistentToLocal::Strong(wasi->memory_);
  Local<ArrayBuffer> ab = memory->Buffer();
  size_t mem_size = ab->ByteLength();
  char* mem_data = static_cast<char*>(ab->Data());
  CHECK_NOT_NULL(mem_data);

  CallAndSetReturn<FT, F, R, Args...>(
      std::make_index_sequence<sizeof...(Args)>{},
      args,
      wasi,
      {mem_data, mem_size});
}",1,1,node_wasi.cc,"node.wasi.WASI.WasiFunction<FT,F,R,Args...>.SlowCallback",,false,357,386,SlowCallback,,,14,"void node.wasi.WASI.WasiFunction<FT,F,R,Args...>.SlowCallback<FT,FT,R,Args> (FunctionCallbackInfo<Value>)"
248803,METHOD,node_wasi.cc:<global>,TYPE_DECL,"static void SetFunction(R (*f)(WASI&, WasmMemory, Args...),
                        Environment* env,
                        const char* name,
                        Local<FunctionTemplate> tmpl) {
  WASI::WasiFunction<FT, F, R, Args...>::SetFunction(env, name, tmpl);
}",1,1,node_wasi.cc,node.wasi.SetFunction,,false,389,394,SetFunction,,,15,"void node.wasi.SetFunction<FT,FT,R,Args> (R,Environment*,char*,Local<FunctionTemplate>)"
248820,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::ArgsGet(WASI& wasi,
                       WasmMemory memory,
                       uint32_t argv_offset,
                       uint32_t argv_buf_offset) {
  Debug(wasi, ""args_get(%d, %d)\n"", argv_offset, argv_buf_offset);

  CHECK_BOUNDS_OR_RETURN(memory.size, argv_buf_offset, wasi.uvw_.argv_buf_size);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, argv_offset, wasi.uvw_.argc * UVWASI_SERDES_SIZE_uint32_t);
  std::vector<char*> argv(wasi.uvw_.argc);
  char* argv_buf = &memory.data[argv_buf_offset];
  uvwasi_errno_t err = uvwasi_args_get(&wasi.uvw_, argv.data(), argv_buf);

  if (err == UVWASI_ESUCCESS) {
    for (size_t i = 0; i < wasi.uvw_.argc; i++) {
      uint32_t offset =
          static_cast<uint32_t>(argv_buf_offset + (argv[i] - argv[0]));
      uvwasi_serdes_write_uint32_t(
          memory.data, argv_offset + (i * UVWASI_SERDES_SIZE_uint32_t), offset);
    }
  }

  return err;
}",1,2,node_wasi.cc,node.wasi.WASI.ArgsGet,,false,396,419,ArgsGet,,,16,"uint32_t node.wasi.WASI.ArgsGet (WASI,WasmMemory,uint32_t,uint32_t)"
248964,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::ArgsSizesGet(WASI& wasi,
                            WasmMemory memory,
                            uint32_t argc_offset,
                            uint32_t argv_buf_offset) {
  Debug(wasi, ""args_sizes_get(%d, %d)\n"", argc_offset, argv_buf_offset);
  CHECK_BOUNDS_OR_RETURN(memory.size, argc_offset, UVWASI_SERDES_SIZE_size_t);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, argv_buf_offset, UVWASI_SERDES_SIZE_size_t);
  uvwasi_size_t argc;
  uvwasi_size_t argv_buf_size;
  uvwasi_errno_t err = uvwasi_args_sizes_get(&wasi.uvw_, &argc, &argv_buf_size);
  if (err == UVWASI_ESUCCESS) {
    uvwasi_serdes_write_size_t(memory.data, argc_offset, argc);
    uvwasi_serdes_write_size_t(memory.data, argv_buf_offset, argv_buf_size);
  }

  return err;
}",1,2,node_wasi.cc,node.wasi.WASI.ArgsSizesGet,,false,421,438,ArgsSizesGet,,,17,"uint32_t node.wasi.WASI.ArgsSizesGet (WASI,WasmMemory,uint32_t,uint32_t)"
249052,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::ClockResGet(WASI& wasi,
                           WasmMemory memory,
                           uint32_t clock_id,
                           uint32_t resolution_ptr) {
  Debug(wasi, ""clock_res_get(%d, %d)\n"", clock_id, resolution_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, resolution_ptr, UVWASI_SERDES_SIZE_timestamp_t);
  uvwasi_timestamp_t resolution;
  uvwasi_errno_t err = uvwasi_clock_res_get(&wasi.uvw_, clock_id, &resolution);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_timestamp_t(memory.data, resolution_ptr, resolution);

  return err;
}",1,2,node_wasi.cc,node.wasi.WASI.ClockResGet,,false,440,453,ClockResGet,,,18,"uint32_t node.wasi.WASI.ClockResGet (WASI,WasmMemory,uint32_t,uint32_t)"
249111,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::ClockTimeGet(WASI& wasi,
                            WasmMemory memory,
                            uint32_t clock_id,
                            uint64_t precision,
                            uint32_t time_ptr) {
  Debug(wasi, ""clock_time_get(%d, %d, %d)\n"", clock_id, precision, time_ptr);
  CHECK_BOUNDS_OR_RETURN(memory.size, time_ptr, UVWASI_SERDES_SIZE_timestamp_t);
  uvwasi_timestamp_t time;
  uvwasi_errno_t err =
      uvwasi_clock_time_get(&wasi.uvw_, clock_id, precision, &time);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_timestamp_t(memory.data, time_ptr, time);

  return err;
}",1,2,node_wasi.cc,node.wasi.WASI.ClockTimeGet,,false,455,469,ClockTimeGet,,,19,"uint32_t node.wasi.WASI.ClockTimeGet (WASI,WasmMemory,uint32_t,uint64_t,uint32_t)"
249173,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::EnvironGet(WASI& wasi,
                          WasmMemory memory,
                          uint32_t environ_offset,
                          uint32_t environ_buf_offset) {
  Debug(wasi, ""environ_get(%d, %d)\n"", environ_offset, environ_buf_offset);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, environ_buf_offset, wasi.uvw_.env_buf_size);
  CHECK_BOUNDS_OR_RETURN(memory.size,
                         environ_offset,
                         wasi.uvw_.envc * UVWASI_SERDES_SIZE_uint32_t);
  std::vector<char*> environment(wasi.uvw_.envc);
  char* environ_buf = &memory.data[environ_buf_offset];
  uvwasi_errno_t err =
      uvwasi_environ_get(&wasi.uvw_, environment.data(), environ_buf);

  if (err == UVWASI_ESUCCESS) {
    for (size_t i = 0; i < wasi.uvw_.envc; i++) {
      uint32_t offset = static_cast<uint32_t>(
          environ_buf_offset + (environment[i] - environment[0]));

      uvwasi_serdes_write_uint32_t(
          memory.data,
          environ_offset + (i * ...",1,2,node_wasi.cc,node.wasi.WASI.EnvironGet,,false,471,499,EnvironGet,,,20,"uint32_t node.wasi.WASI.EnvironGet (WASI,WasmMemory,uint32_t,uint32_t)"
249317,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::EnvironSizesGet(WASI& wasi,
                               WasmMemory memory,
                               uint32_t envc_offset,
                               uint32_t env_buf_offset) {
  Debug(wasi, ""environ_sizes_get(%d, %d)\n"", envc_offset, env_buf_offset);
  CHECK_BOUNDS_OR_RETURN(memory.size, envc_offset, UVWASI_SERDES_SIZE_size_t);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, env_buf_offset, UVWASI_SERDES_SIZE_size_t);
  uvwasi_size_t envc;
  uvwasi_size_t env_buf_size;
  uvwasi_errno_t err =
      uvwasi_environ_sizes_get(&wasi.uvw_, &envc, &env_buf_size);
  if (err == UVWASI_ESUCCESS) {
    uvwasi_serdes_write_size_t(memory.data, envc_offset, envc);
    uvwasi_serdes_write_size_t(memory.data, env_buf_offset, env_buf_size);
  }

  return err;
}",1,2,node_wasi.cc,node.wasi.WASI.EnvironSizesGet,,false,501,519,EnvironSizesGet,,,21,"uint32_t node.wasi.WASI.EnvironSizesGet (WASI,WasmMemory,uint32_t,uint32_t)"
249405,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::FdAdvise(WASI& wasi,
                        WasmMemory,
                        uint32_t fd,
                        uint64_t offset,
                        uint64_t len,
                        uint32_t advice) {
  Debug(wasi, ""fd_advise(%d, %d, %d, %d)\n"", fd, offset, len, advice);
  return uvwasi_fd_advise(&wasi.uvw_, fd, offset, len, advice);
}",1,1,node_wasi.cc,node.wasi.WASI.FdAdvise,,false,521,529,FdAdvise,,,22,"uint32_t node.wasi.WASI.FdAdvise (WASI,WasmMemory,uint32_t,uint64_t,uint64_t,uint32_t)"
249432,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::FdAllocate(
    WASI& wasi, WasmMemory, uint32_t fd, uint64_t offset, uint64_t len) {
  Debug(wasi, ""fd_allocate(%d, %d, %d)\n"", fd, offset, len);
  return uvwasi_fd_allocate(&wasi.uvw_, fd, offset, len);
}",1,1,node_wasi.cc,node.wasi.WASI.FdAllocate,,false,531,535,FdAllocate,,,23,"uint32_t node.wasi.WASI.FdAllocate (WASI,WasmMemory,uint32_t,uint64_t,uint64_t)"
249456,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::FdClose(WASI& wasi, WasmMemory, uint32_t fd) {
  Debug(wasi, ""fd_close(%d)\n"", fd);
  return uvwasi_fd_close(&wasi.uvw_, fd);
}",1,1,node_wasi.cc,node.wasi.WASI.FdClose,,false,537,540,FdClose,,,24,"uint32_t node.wasi.WASI.FdClose (WASI,WasmMemory,uint32_t)"
249474,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::FdDatasync(WASI& wasi, WasmMemory, uint32_t fd) {
  Debug(wasi, ""fd_datasync(%d)\n"", fd);
  return uvwasi_fd_datasync(&wasi.uvw_, fd);
}",1,1,node_wasi.cc,node.wasi.WASI.FdDatasync,,false,542,545,FdDatasync,,,25,"uint32_t node.wasi.WASI.FdDatasync (WASI,WasmMemory,uint32_t)"
249492,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::FdFdstatGet(WASI& wasi,
                           WasmMemory memory,
                           uint32_t fd,
                           uint32_t buf) {
  Debug(wasi, ""fd_fdstat_get(%d, %d)\n"", fd, buf);
  CHECK_BOUNDS_OR_RETURN(memory.size, buf, UVWASI_SERDES_SIZE_fdstat_t);
  uvwasi_fdstat_t stats;
  uvwasi_errno_t err = uvwasi_fd_fdstat_get(&wasi.uvw_, fd, &stats);

  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_fdstat_t(memory.data, buf, &stats);

  return err;
}",1,2,node_wasi.cc,node.wasi.WASI.FdFdstatGet,,false,547,560,FdFdstatGet,,,26,"uint32_t node.wasi.WASI.FdFdstatGet (WASI,WasmMemory,uint32_t,uint32_t)"
249552,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::FdFdstatSetFlags(WASI& wasi,
                                WasmMemory,
                                uint32_t fd,
                                uint32_t flags) {
  Debug(wasi, ""fd_fdstat_set_flags(%d, %d)\n"", fd, flags);
  return uvwasi_fd_fdstat_set_flags(&wasi.uvw_, fd, flags);
}",1,1,node_wasi.cc,node.wasi.WASI.FdFdstatSetFlags,,false,562,568,FdFdstatSetFlags,,,27,"uint32_t node.wasi.WASI.FdFdstatSetFlags (WASI,WasmMemory,uint32_t,uint32_t)"
249573,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::FdFdstatSetRights(WASI& wasi,
                                 WasmMemory,
                                 uint32_t fd,
                                 uint64_t fs_rights_base,
                                 uint64_t fs_rights_inheriting) {
  Debug(wasi,
        ""fd_fdstat_set_rights(%d, %d, %d)\n"",
        fd,
        fs_rights_base,
        fs_rights_inheriting);
  return uvwasi_fd_fdstat_set_rights(
      &wasi.uvw_, fd, fs_rights_base, fs_rights_inheriting);
}",1,1,node_wasi.cc,node.wasi.WASI.FdFdstatSetRights,,false,570,582,FdFdstatSetRights,,,28,"uint32_t node.wasi.WASI.FdFdstatSetRights (WASI,WasmMemory,uint32_t,uint64_t,uint64_t)"
249597,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::FdFilestatGet(WASI& wasi,
                             WasmMemory memory,
                             uint32_t fd,
                             uint32_t buf) {
  Debug(wasi, ""fd_filestat_get(%d, %d)\n"", fd, buf);
  CHECK_BOUNDS_OR_RETURN(memory.size, buf, UVWASI_SERDES_SIZE_filestat_t);
  uvwasi_filestat_t stats;
  uvwasi_errno_t err = uvwasi_fd_filestat_get(&wasi.uvw_, fd, &stats);

  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_filestat_t(memory.data, buf, &stats);

  return err;
}",1,2,node_wasi.cc,node.wasi.WASI.FdFilestatGet,,false,584,597,FdFilestatGet,,,29,"uint32_t node.wasi.WASI.FdFilestatGet (WASI,WasmMemory,uint32_t,uint32_t)"
249657,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::FdFilestatSetSize(WASI& wasi,
                                 WasmMemory,
                                 uint32_t fd,
                                 uint64_t st_size) {
  Debug(wasi, ""fd_filestat_set_size(%d, %d)\n"", fd, st_size);
  return uvwasi_fd_filestat_set_size(&wasi.uvw_, fd, st_size);
}",1,1,node_wasi.cc,node.wasi.WASI.FdFilestatSetSize,,false,599,605,FdFilestatSetSize,,,30,"uint32_t node.wasi.WASI.FdFilestatSetSize (WASI,WasmMemory,uint32_t,uint64_t)"
249678,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::FdFilestatSetTimes(WASI& wasi,
                                  WasmMemory,
                                  uint32_t fd,
                                  uint64_t st_atim,
                                  uint64_t st_mtim,
                                  uint32_t fst_flags) {
  Debug(wasi,
        ""fd_filestat_set_times(%d, %d, %d, %d)\n"",
        fd,
        st_atim,
        st_mtim,
        fst_flags);
  return uvwasi_fd_filestat_set_times(
      &wasi.uvw_, fd, st_atim, st_mtim, fst_flags);
}",1,1,node_wasi.cc,node.wasi.WASI.FdFilestatSetTimes,,false,607,621,FdFilestatSetTimes,,,31,"uint32_t node.wasi.WASI.FdFilestatSetTimes (WASI,WasmMemory,uint32_t,uint64_t,uint64_t,uint32_t)"
249705,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::FdPread(WASI& wasi,
                       WasmMemory memory,
                       uint32_t fd,
                       uint32_t iovs_ptr,
                       uint32_t iovs_len,
                       uint64_t offset,
                       uint32_t nread_ptr) {
  Debug(wasi,
        ""uvwasi_fd_pread(%d, %d, %d, %d, %d)\n"",
        fd,
        iovs_ptr,
        iovs_len,
        offset,
        nread_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_iovec_t);
  CHECK_BOUNDS_OR_RETURN(memory.size, nread_ptr, UVWASI_SERDES_SIZE_size_t);
  std::vector<uvwasi_iovec_t> iovs(iovs_len);
  uvwasi_errno_t err;

  err = uvwasi_serdes_readv_iovec_t(
      memory.data, memory.size, iovs_ptr, iovs.data(), iovs_len);
  if (err != UVWASI_ESUCCESS) {
    return err;
  }

  uvwasi_size_t nread;
  err = uvwasi_fd_pread(&wasi.uvw_, fd, iovs.data(), iovs_len, offset, &nread);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_size_t(memory....",1,2,node_wasi.cc,node.wasi.WASI.FdPread,,false,623,655,FdPread,,,32,"uint32_t node.wasi.WASI.FdPread (WASI,WasmMemory,uint32_t,uint32_t,uint32_t,uint64_t,uint32_t)"
249828,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::FdPrestatGet(WASI& wasi,
                            WasmMemory memory,
                            uint32_t fd,
                            uint32_t buf) {
  Debug(wasi, ""fd_prestat_get(%d, %d)\n"", fd, buf);
  CHECK_BOUNDS_OR_RETURN(memory.size, buf, UVWASI_SERDES_SIZE_prestat_t);
  uvwasi_prestat_t prestat;
  uvwasi_errno_t err = uvwasi_fd_prestat_get(&wasi.uvw_, fd, &prestat);

  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_prestat_t(memory.data, buf, &prestat);

  return err;
}",1,2,node_wasi.cc,node.wasi.WASI.FdPrestatGet,,false,657,670,FdPrestatGet,,,33,"uint32_t node.wasi.WASI.FdPrestatGet (WASI,WasmMemory,uint32_t,uint32_t)"
249888,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::FdPrestatDirName(WASI& wasi,
                                WasmMemory memory,
                                uint32_t fd,
                                uint32_t path_ptr,
                                uint32_t path_len) {
  Debug(wasi, ""fd_prestat_dir_name(%d, %d, %d)\n"", fd, path_ptr, path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  return uvwasi_fd_prestat_dir_name(
      &wasi.uvw_, fd, &memory.data[path_ptr], path_len);
}",1,2,node_wasi.cc,node.wasi.WASI.FdPrestatDirName,,false,672,681,FdPrestatDirName,,,34,"uint32_t node.wasi.WASI.FdPrestatDirName (WASI,WasmMemory,uint32_t,uint32_t,uint32_t)"
249938,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::FdPwrite(WASI& wasi,
                        WasmMemory memory,
                        uint32_t fd,
                        uint32_t iovs_ptr,
                        uint32_t iovs_len,
                        uint64_t offset,
                        uint32_t nwritten_ptr) {
  Debug(wasi,
        ""uvwasi_fd_pwrite(%d, %d, %d, %d, %d)\n"",
        fd,
        iovs_ptr,
        iovs_len,
        offset,
        nwritten_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_ciovec_t);
  CHECK_BOUNDS_OR_RETURN(memory.size, nwritten_ptr, UVWASI_SERDES_SIZE_size_t);
  std::vector<uvwasi_ciovec_t> iovs(iovs_len);
  uvwasi_errno_t err;

  err = uvwasi_serdes_readv_ciovec_t(
      memory.data, memory.size, iovs_ptr, iovs.data(), iovs_len);
  if (err != UVWASI_ESUCCESS) {
    return err;
  }

  uvwasi_size_t nwritten;
  err = uvwasi_fd_pwrite(
      &wasi.uvw_, fd, iovs.data(), iovs_len, offset, &nwritten);
  if (err == UVWASI_ESUCCESS)
    ...",1,2,node_wasi.cc,node.wasi.WASI.FdPwrite,,false,683,716,FdPwrite,,,35,"uint32_t node.wasi.WASI.FdPwrite (WASI,WasmMemory,uint32_t,uint32_t,uint32_t,uint64_t,uint32_t)"
250061,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::FdRead(WASI& wasi,
                      WasmMemory memory,
                      uint32_t fd,
                      uint32_t iovs_ptr,
                      uint32_t iovs_len,
                      uint32_t nread_ptr) {
  Debug(wasi, ""fd_read(%d, %d, %d, %d)\n"", fd, iovs_ptr, iovs_len, nread_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_iovec_t);
  CHECK_BOUNDS_OR_RETURN(memory.size, nread_ptr, UVWASI_SERDES_SIZE_size_t);
  std::vector<uvwasi_iovec_t> iovs(iovs_len);
  uvwasi_errno_t err;

  err = uvwasi_serdes_readv_iovec_t(
      memory.data, memory.size, iovs_ptr, iovs.data(), iovs_len);
  if (err != UVWASI_ESUCCESS) {
    return err;
  }

  uvwasi_size_t nread;
  err = uvwasi_fd_read(&wasi.uvw_, fd, iovs.data(), iovs_len, &nread);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_size_t(memory.data, nread_ptr, nread);

  return err;
}",1,2,node_wasi.cc,node.wasi.WASI.FdRead,,false,718,743,FdRead,,,36,"uint32_t node.wasi.WASI.FdRead (WASI,WasmMemory,uint32_t,uint32_t,uint32_t,uint32_t)"
250181,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::FdReaddir(WASI& wasi,
                         WasmMemory memory,
                         uint32_t fd,
                         uint32_t buf_ptr,
                         uint32_t buf_len,
                         uint64_t cookie,
                         uint32_t bufused_ptr) {
  Debug(wasi,
        ""uvwasi_fd_readdir(%d, %d, %d, %d, %d)\n"",
        fd,
        buf_ptr,
        buf_len,
        cookie,
        bufused_ptr);
  CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, buf_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, bufused_ptr, UVWASI_SERDES_SIZE_size_t);
  uvwasi_size_t bufused;
  uvwasi_errno_t err = uvwasi_fd_readdir(
      &wasi.uvw_, fd, &memory.data[buf_ptr], buf_len, cookie, &bufused);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_size_t(memory.data, bufused_ptr, bufused);

  return err;
}",1,2,node_wasi.cc,node.wasi.WASI.FdReaddir,,false,745,768,FdReaddir,,,37,"uint32_t node.wasi.WASI.FdReaddir (WASI,WasmMemory,uint32_t,uint32_t,uint32_t,uint64_t,uint32_t)"
250275,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::FdRenumber(WASI& wasi, WasmMemory, uint32_t from, uint32_t to) {
  Debug(wasi, ""fd_renumber(%d, %d)\n"", from, to);
  return uvwasi_fd_renumber(&wasi.uvw_, from, to);
}",1,1,node_wasi.cc,node.wasi.WASI.FdRenumber,,false,770,773,FdRenumber,,,38,"uint32_t node.wasi.WASI.FdRenumber (WASI,WasmMemory,uint32_t,uint32_t)"
250296,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::FdSeek(WASI& wasi,
                      WasmMemory memory,
                      uint32_t fd,
                      int64_t offset,
                      uint32_t whence,
                      uint32_t newoffset_ptr) {
  Debug(wasi, ""fd_seek(%d, %d, %d, %d)\n"", fd, offset, whence, newoffset_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, newoffset_ptr, UVWASI_SERDES_SIZE_filesize_t);
  uvwasi_filesize_t newoffset;
  uvwasi_errno_t err =
      uvwasi_fd_seek(&wasi.uvw_, fd, offset, whence, &newoffset);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_filesize_t(memory.data, newoffset_ptr, newoffset);

  return err;
}",1,2,node_wasi.cc,node.wasi.WASI.FdSeek,,false,775,791,FdSeek,,,39,"uint32_t node.wasi.WASI.FdSeek (WASI,WasmMemory,uint32_t,int64_t,uint32_t,uint32_t)"
250361,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::FdSync(WASI& wasi, WasmMemory, uint32_t fd) {
  Debug(wasi, ""fd_sync(%d)\n"", fd);
  return uvwasi_fd_sync(&wasi.uvw_, fd);
}",1,1,node_wasi.cc,node.wasi.WASI.FdSync,,false,793,796,FdSync,,,40,"uint32_t node.wasi.WASI.FdSync (WASI,WasmMemory,uint32_t)"
250379,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::FdTell(WASI& wasi,
                      WasmMemory memory,
                      uint32_t fd,
                      uint32_t offset_ptr) {
  Debug(wasi, ""fd_tell(%d, %d)\n"", fd, offset_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, offset_ptr, UVWASI_SERDES_SIZE_filesize_t);
  uvwasi_filesize_t offset;
  uvwasi_errno_t err = uvwasi_fd_tell(&wasi.uvw_, fd, &offset);

  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_filesize_t(memory.data, offset_ptr, offset);

  return err;
}",1,2,node_wasi.cc,node.wasi.WASI.FdTell,,false,798,812,FdTell,,,41,"uint32_t node.wasi.WASI.FdTell (WASI,WasmMemory,uint32_t,uint32_t)"
250438,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::FdWrite(WASI& wasi,
                       WasmMemory memory,
                       uint32_t fd,
                       uint32_t iovs_ptr,
                       uint32_t iovs_len,
                       uint32_t nwritten_ptr) {
  Debug(wasi,
        ""fd_write(%d, %d, %d, %d)\n"",
        fd,
        iovs_ptr,
        iovs_len,
        nwritten_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_ciovec_t);
  CHECK_BOUNDS_OR_RETURN(memory.size, nwritten_ptr, UVWASI_SERDES_SIZE_size_t);
  std::vector<uvwasi_ciovec_t> iovs(iovs_len);
  uvwasi_errno_t err;

  err = uvwasi_serdes_readv_ciovec_t(
      memory.data, memory.size, iovs_ptr, iovs.data(), iovs_len);
  if (err != UVWASI_ESUCCESS) {
    return err;
  }

  uvwasi_size_t nwritten;
  err = uvwasi_fd_write(&wasi.uvw_, fd, iovs.data(), iovs_len, &nwritten);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_size_t(memory.data, nwritten_ptr, nwritten);

  return err;
}",1,2,node_wasi.cc,node.wasi.WASI.FdWrite,,false,814,844,FdWrite,,,42,"uint32_t node.wasi.WASI.FdWrite (WASI,WasmMemory,uint32_t,uint32_t,uint32_t,uint32_t)"
250558,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::PathCreateDirectory(WASI& wasi,
                                   WasmMemory memory,
                                   uint32_t fd,
                                   uint32_t path_ptr,
                                   uint32_t path_len) {
  Debug(wasi, ""path_create_directory(%d, %d, %d)\n"", fd, path_ptr, path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  uvwasi_errno_t err = uvwasi_path_create_directory(
      &wasi.uvw_, fd, &memory.data[path_ptr], path_len);
  return err;
}",1,2,node_wasi.cc,node.wasi.WASI.PathCreateDirectory,,false,846,856,PathCreateDirectory,,,43,"uint32_t node.wasi.WASI.PathCreateDirectory (WASI,WasmMemory,uint32_t,uint32_t,uint32_t)"
250612,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::PathFilestatGet(WASI& wasi,
                               WasmMemory memory,
                               uint32_t fd,
                               uint32_t flags,
                               uint32_t path_ptr,
                               uint32_t path_len,
                               uint32_t buf_ptr) {
  Debug(wasi,
        ""path_filestat_get(%d, %d, %d)\n"",
        fd,
        path_ptr,
        path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, UVWASI_SERDES_SIZE_filestat_t);
  uvwasi_filestat_t stats;
  uvwasi_errno_t err = uvwasi_path_filestat_get(
      &wasi.uvw_, fd, flags, &memory.data[path_ptr], path_len, &stats);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_filestat_t(memory.data, buf_ptr, &stats);

  return err;
}",1,2,node_wasi.cc,node.wasi.WASI.PathFilestatGet,,false,858,879,PathFilestatGet,,,44,"uint32_t node.wasi.WASI.PathFilestatGet (WASI,WasmMemory,uint32_t,uint32_t,uint32_t,uint32_t,uint32_t)"
250705,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::PathFilestatSetTimes(WASI& wasi,
                                    WasmMemory memory,
                                    uint32_t fd,
                                    uint32_t flags,
                                    uint32_t path_ptr,
                                    uint32_t path_len,
                                    uint64_t st_atim,
                                    uint64_t st_mtim,
                                    uint32_t fst_flags) {
  Debug(wasi,
        ""path_filestat_set_times(%d, %d, %d, %d, %d, %d, %d)\n"",
        fd,
        flags,
        path_ptr,
        path_len,
        st_atim,
        st_mtim,
        fst_flags);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  return uvwasi_path_filestat_set_times(&wasi.uvw_,
                                        fd,
                                        flags,
                                        &memory.data[path_ptr],
                                        path_len,
     ...",1,2,node_wasi.cc,node.wasi.WASI.PathFilestatSetTimes,,false,881,908,PathFilestatSetTimes,,,45,"uint32_t node.wasi.WASI.PathFilestatSetTimes (WASI,WasmMemory,uint32_t,uint32_t,uint32_t,uint32_t,uint64_t,uint64_t,uint32_t)"
250767,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::PathLink(WASI& wasi,
                        WasmMemory memory,
                        uint32_t old_fd,
                        uint32_t old_flags,
                        uint32_t old_path_ptr,
                        uint32_t old_path_len,
                        uint32_t new_fd,
                        uint32_t new_path_ptr,
                        uint32_t new_path_len) {
  Debug(wasi,
        ""path_link(%d, %d, %d, %d, %d, %d, %d)\n"",
        old_fd,
        old_flags,
        old_path_ptr,
        old_path_len,
        new_fd,
        new_path_ptr,
        new_path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, old_path_ptr, old_path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, new_path_ptr, new_path_len);
  return uvwasi_path_link(&wasi.uvw_,
                          old_fd,
                          old_flags,
                          &memory.data[old_path_ptr],
                          old_path_len,
                          new_fd,
                          ...",1,2,node_wasi.cc,node.wasi.WASI.PathLink,,false,910,938,PathLink,,,46,"uint32_t node.wasi.WASI.PathLink (WASI,WasmMemory,uint32_t,uint32_t,uint32_t,uint32_t,uint32_t,uint32_t,uint32_t)"
250855,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::PathOpen(WASI& wasi,
                        WasmMemory memory,
                        uint32_t dirfd,
                        uint32_t dirflags,
                        uint32_t path_ptr,
                        uint32_t path_len,
                        uint32_t o_flags,
                        uint64_t fs_rights_base,
                        uint64_t fs_rights_inheriting,
                        uint32_t fs_flags,
                        uint32_t fd_ptr) {
  Debug(wasi,
        ""path_open(%d, %d, %d, %d, %d, %d, %d, %d, %d)\n"",
        dirfd,
        dirflags,
        path_ptr,
        path_len,
        o_flags,
        fs_rights_base,
        fs_rights_inheriting,
        fs_flags,
        fd_ptr);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, fd_ptr, UVWASI_SERDES_SIZE_fd_t);
  uvwasi_fd_t fd;
  uvwasi_errno_t err = uvwasi_path_open(&wasi.uvw_,
                                        dirfd,
                     ...",1,2,node_wasi.cc,node.wasi.WASI.PathOpen,,false,940,979,PathOpen,,,47,"uint32_t node.wasi.WASI.PathOpen (WASI,WasmMemory,uint32_t,uint32_t,uint32_t,uint32_t,uint32_t,uint64_t,uint64_t,uint32_t,uint32_t)"
250965,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::PathReadlink(WASI& wasi,
                            WasmMemory memory,
                            uint32_t fd,
                            uint32_t path_ptr,
                            uint32_t path_len,
                            uint32_t buf_ptr,
                            uint32_t buf_len,
                            uint32_t bufused_ptr) {
  Debug(wasi,
        ""path_readlink(%d, %d, %d, %d, %d, %d)\n"",
        fd,
        path_ptr,
        path_len,
        buf_ptr,
        buf_len,
        bufused_ptr);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, buf_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, bufused_ptr, UVWASI_SERDES_SIZE_size_t);
  uvwasi_size_t bufused;
  uvwasi_errno_t err = uvwasi_path_readlink(&wasi.uvw_,
                                            fd,
                                            &memory.data[path_ptr],
                                            path_len,
                ...",1,2,node_wasi.cc,node.wasi.WASI.PathReadlink,,false,981,1012,PathReadlink,,,48,"uint32_t node.wasi.WASI.PathReadlink (WASI,WasmMemory,uint32_t,uint32_t,uint32_t,uint32_t,uint32_t,uint32_t)"
251088,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::PathRemoveDirectory(WASI& wasi,
                                   WasmMemory memory,
                                   uint32_t fd,
                                   uint32_t path_ptr,
                                   uint32_t path_len) {
  Debug(wasi, ""path_remove_directory(%d, %d, %d)\n"", fd, path_ptr, path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  return uvwasi_path_remove_directory(
      &wasi.uvw_, fd, &memory.data[path_ptr], path_len);
}",1,2,node_wasi.cc,node.wasi.WASI.PathRemoveDirectory,,false,1014,1023,PathRemoveDirectory,,,49,"uint32_t node.wasi.WASI.PathRemoveDirectory (WASI,WasmMemory,uint32_t,uint32_t,uint32_t)"
251138,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::PathRename(WASI& wasi,
                          WasmMemory memory,
                          uint32_t old_fd,
                          uint32_t old_path_ptr,
                          uint32_t old_path_len,
                          uint32_t new_fd,
                          uint32_t new_path_ptr,
                          uint32_t new_path_len) {
  Debug(wasi,
        ""path_rename(%d, %d, %d, %d, %d, %d)\n"",
        old_fd,
        old_path_ptr,
        old_path_len,
        new_fd,
        new_path_ptr,
        new_path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, old_path_ptr, old_path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, new_path_ptr, new_path_len);
  return uvwasi_path_rename(&wasi.uvw_,
                            old_fd,
                            &memory.data[old_path_ptr],
                            old_path_len,
                            new_fd,
                            &memory.data[new_path_ptr],
                            new_path_len);
}",1,2,node_wasi.cc,node.wasi.WASI.PathRename,,false,1025,1050,PathRename,,,50,"uint32_t node.wasi.WASI.PathRename (WASI,WasmMemory,uint32_t,uint32_t,uint32_t,uint32_t,uint32_t,uint32_t)"
251223,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::PathSymlink(WASI& wasi,
                           WasmMemory memory,
                           uint32_t old_path_ptr,
                           uint32_t old_path_len,
                           uint32_t fd,
                           uint32_t new_path_ptr,
                           uint32_t new_path_len) {
  Debug(wasi,
        ""path_symlink(%d, %d, %d, %d, %d)\n"",
        old_path_ptr,
        old_path_len,
        fd,
        new_path_ptr,
        new_path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, old_path_ptr, old_path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, new_path_ptr, new_path_len);
  return uvwasi_path_symlink(&wasi.uvw_,
                             &memory.data[old_path_ptr],
                             old_path_len,
                             fd,
                             &memory.data[new_path_ptr],
                             new_path_len);
}",1,2,node_wasi.cc,node.wasi.WASI.PathSymlink,,false,1052,1074,PathSymlink,,,51,"uint32_t node.wasi.WASI.PathSymlink (WASI,WasmMemory,uint32_t,uint32_t,uint32_t,uint32_t,uint32_t)"
251305,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::PathUnlinkFile(WASI& wasi,
                              WasmMemory memory,
                              uint32_t fd,
                              uint32_t path_ptr,
                              uint32_t path_len) {
  Debug(wasi, ""path_unlink_file(%d, %d, %d)\n"", fd, path_ptr, path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  return uvwasi_path_unlink_file(
      &wasi.uvw_, fd, &memory.data[path_ptr], path_len);
}",1,2,node_wasi.cc,node.wasi.WASI.PathUnlinkFile,,false,1076,1085,PathUnlinkFile,,,52,"uint32_t node.wasi.WASI.PathUnlinkFile (WASI,WasmMemory,uint32_t,uint32_t,uint32_t)"
251355,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::PollOneoff(WASI& wasi,
                          WasmMemory memory,
                          uint32_t in_ptr,
                          uint32_t out_ptr,
                          uint32_t nsubscriptions,
                          uint32_t nevents_ptr) {
  Debug(wasi,
        ""poll_oneoff(%d, %d, %d, %d)\n"",
        in_ptr,
        out_ptr,
        nsubscriptions,
        nevents_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, in_ptr, nsubscriptions * UVWASI_SERDES_SIZE_subscription_t);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, out_ptr, nsubscriptions * UVWASI_SERDES_SIZE_event_t);
  CHECK_BOUNDS_OR_RETURN(memory.size, nevents_ptr, UVWASI_SERDES_SIZE_size_t);
  std::vector<uvwasi_subscription_t> in(nsubscriptions);
  std::vector<uvwasi_event_t> out(nsubscriptions);

  for (uint32_t i = 0; i < nsubscriptions; ++i) {
    uvwasi_serdes_read_subscription_t(memory.data, in_ptr, &in[i]);
    in_ptr += UVWASI_SERDES_SIZE_subscription_t;
  }

  uvwasi_size_t nevents;
 ...",1,2,node_wasi.cc,node.wasi.WASI.PollOneoff,,false,1087,1125,PollOneoff,,,53,"uint32_t node.wasi.WASI.PollOneoff (WASI,WasmMemory,uint32_t,uint32_t,uint32_t,uint32_t)"
251534,METHOD,node_wasi.cc:<global>,TYPE_DECL,"void WASI::ProcExit(WASI& wasi, WasmMemory, uint32_t code) {
  Debug(wasi, ""proc_exit(%d)\n"", code);
  uvwasi_proc_exit(&wasi.uvw_, code);
}",1,1,node_wasi.cc,node.wasi.WASI.ProcExit,,false,1127,1130,ProcExit,,,54,"void node.wasi.WASI.ProcExit (WASI,WasmMemory,uint32_t)"
251551,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::ProcRaise(WASI& wasi, WasmMemory, uint32_t sig) {
  Debug(wasi, ""proc_raise(%d)\n"", sig);
  return uvwasi_proc_raise(&wasi.uvw_, sig);
}",1,1,node_wasi.cc,node.wasi.WASI.ProcRaise,,false,1132,1135,ProcRaise,,,55,"uint32_t node.wasi.WASI.ProcRaise (WASI,WasmMemory,uint32_t)"
251569,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::RandomGet(WASI& wasi,
                         WasmMemory memory,
                         uint32_t buf_ptr,
                         uint32_t buf_len) {
  Debug(wasi, ""random_get(%d, %d)\n"", buf_ptr, buf_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, buf_len);
  return uvwasi_random_get(&wasi.uvw_, &memory.data[buf_ptr], buf_len);
}",1,2,node_wasi.cc,node.wasi.WASI.RandomGet,,false,1137,1144,RandomGet,,,56,"uint32_t node.wasi.WASI.RandomGet (WASI,WasmMemory,uint32_t,uint32_t)"
251616,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::SchedYield(WASI& wasi, WasmMemory) {
  Debug(wasi, ""sched_yield()\n"");
  return uvwasi_sched_yield(&wasi.uvw_);
}",1,1,node_wasi.cc,node.wasi.WASI.SchedYield,,false,1146,1149,SchedYield,,,57,"uint32_t node.wasi.WASI.SchedYield (WASI,WasmMemory)"
251631,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::SockAccept(WASI& wasi,
                          WasmMemory memory,
                          uint32_t sock,
                          uint32_t flags,
                          uint32_t fd_ptr) {
  Debug(wasi, ""sock_accept(%d, %d, %d)\n"", sock, flags, fd_ptr);
  uvwasi_fd_t fd;
  uvwasi_errno_t err = uvwasi_sock_accept(&wasi.uvw_, sock, flags, &fd);

  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_size_t(memory.data, fd_ptr, fd);

  return err;
}",1,1,node_wasi.cc,node.wasi.WASI.SockAccept,,false,1151,1164,SockAccept,,,58,"uint32_t node.wasi.WASI.SockAccept (WASI,WasmMemory,uint32_t,uint32_t,uint32_t)"
251672,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::SockRecv(WASI& wasi,
                        WasmMemory memory,
                        uint32_t sock,
                        uint32_t ri_data_ptr,
                        uint32_t ri_data_len,
                        uint32_t ri_flags,
                        uint32_t ro_datalen_ptr,
                        uint32_t ro_flags_ptr) {
  Debug(wasi,
        ""sock_recv(%d, %d, %d, %d, %d, %d)\n"",
        sock,
        ri_data_ptr,
        ri_data_len,
        ri_flags,
        ro_datalen_ptr,
        ro_flags_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, ri_data_ptr, ri_data_len * UVWASI_SERDES_SIZE_iovec_t);
  CHECK_BOUNDS_OR_RETURN(memory.size, ro_datalen_ptr, 4);
  CHECK_BOUNDS_OR_RETURN(memory.size, ro_flags_ptr, 4);
  std::vector<uvwasi_iovec_t> ri_data(ri_data_len);
  uvwasi_errno_t err = uvwasi_serdes_readv_iovec_t(
      memory.data, memory.size, ri_data_ptr, ri_data.data(), ri_data_len);
  if (err != UVWASI_ESUCCESS) {
    return err;
  }

  uvwasi_size_t r...",1,2,node_wasi.cc,node.wasi.WASI.SockRecv,,false,1166,1208,SockRecv,,,59,"uint32_t node.wasi.WASI.SockRecv (WASI,WasmMemory,uint32_t,uint32_t,uint32_t,uint32_t,uint32_t,uint32_t)"
251827,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::SockSend(WASI& wasi,
                        WasmMemory memory,
                        uint32_t sock,
                        uint32_t si_data_ptr,
                        uint32_t si_data_len,
                        uint32_t si_flags,
                        uint32_t so_datalen_ptr) {
  Debug(wasi,
        ""sock_send(%d, %d, %d, %d, %d)\n"",
        sock,
        si_data_ptr,
        si_data_len,
        si_flags,
        so_datalen_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, si_data_ptr, si_data_len * UVWASI_SERDES_SIZE_ciovec_t);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, so_datalen_ptr, UVWASI_SERDES_SIZE_size_t);
  std::vector<uvwasi_ciovec_t> si_data(si_data_len);
  uvwasi_errno_t err = uvwasi_serdes_readv_ciovec_t(
      memory.data, memory.size, si_data_ptr, si_data.data(), si_data_len);
  if (err != UVWASI_ESUCCESS) {
    return err;
  }

  uvwasi_size_t so_datalen;
  err = uvwasi_sock_send(
      &wasi.uvw_, sock, si_data.data(), si_data_len, si_fl...",1,2,node_wasi.cc,node.wasi.WASI.SockSend,,false,1210,1242,SockSend,,,60,"uint32_t node.wasi.WASI.SockSend (WASI,WasmMemory,uint32_t,uint32_t,uint32_t,uint32_t,uint32_t)"
251950,METHOD,node_wasi.cc:<global>,TYPE_DECL,"uint32_t WASI::SockShutdown(WASI& wasi,
                            WasmMemory,
                            uint32_t sock,
                            uint32_t how) {
  Debug(wasi, ""sock_shutdown(%d, %d)\n"", sock, how);
  return uvwasi_sock_shutdown(&wasi.uvw_, sock, how);
}",1,1,node_wasi.cc,node.wasi.WASI.SockShutdown,,false,1244,1250,SockShutdown,,,61,"uint32_t node.wasi.WASI.SockShutdown (WASI,WasmMemory,uint32_t,uint32_t)"
251971,METHOD,node_wasi.cc:<global>,TYPE_DECL,"void WASI::_SetMemory(const FunctionCallbackInfo<Value>& args) {
  WASI* wasi;
  ASSIGN_OR_RETURN_UNWRAP(&wasi, args.This());
  CHECK_EQ(args.Length(), 1);
  if (!args[0]->IsWasmMemoryObject()) {
    return node::THROW_ERR_INVALID_ARG_TYPE(
        wasi->env(),
        ""\""instance.exports.memory\"" property must be a WebAssembly.Memory ""
        ""object"");
  }
  wasi->memory_.Reset(wasi->env()->isolate(), args[0].As<WasmMemoryObject>());
}",1,1,node_wasi.cc,node.wasi.WASI._SetMemory,,false,1252,1263,_SetMemory,,,62,void node.wasi.WASI._SetMemory (FunctionCallbackInfo<Value>)
252028,METHOD,node_wasi.cc:<global>,TYPE_DECL,"static void InitializePreview1(Local<Object> target,
                               Local<Value> unused,
                               Local<Context> context,
                               void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> tmpl = NewFunctionTemplate(isolate, WASI::New);
  tmpl->InstanceTemplate()->SetInternalFieldCount(WASI::kInternalFieldCount);

#define V(F, name)                                                             \
  SetFunction<decltype(&WASI::F), WASI::F>(WASI::F, env, name, tmpl);

  V(ArgsGet, ""args_get"")
  V(ArgsSizesGet, ""args_sizes_get"")
  V(ClockResGet, ""clock_res_get"")
  V(ClockTimeGet, ""clock_time_get"")
  V(EnvironGet, ""environ_get"")
  V(EnvironSizesGet, ""environ_sizes_get"")
  V(FdAdvise, ""fd_advise"")
  V(FdAllocate, ""fd_allocate"")
  V(FdClose, ""fd_close"")
  V(FdDatasync, ""fd_datasync"")
  V(FdFdstatGet, ""fd_fdstat_get"")
  V(FdFdstatSetFlags, ""fd_fdstat_set_flags...",1,2,node_wasi.cc,node.wasi.InitializePreview1,,false,1265,1329,InitializePreview1,,,63,"void node.wasi.InitializePreview1 (Local<Object>,Local<Value>,Local<Context>,void*)"
252602,METHOD,node_wasi.hpp:<global>,TYPE_DECL,<global>,1,27,node_wasi.hpp,node_wasi.hpp:<global>,,false,1,184,<global>,,,1,
252615,METHOD,node_wasm_web_api.cc:<global>,TYPE_DECL,<global>,1,35,node_wasm_web_api.hpp,node_wasm_web_api.cc:<global>,,false,1,213,<global>,,,1,
252619,METHOD,node_wasm_web_api.cc:<global>,TYPE_DECL,"Local<Function> WasmStreamingObject::Initialize(Environment* env) {
  Local<Function> templ = env->wasm_streaming_object_constructor();
  if (!templ.IsEmpty()) {
    return templ;
  }

  Isolate* isolate = env->isolate();
  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->InstanceTemplate()->SetInternalFieldCount(
      WasmStreamingObject::kInternalFieldCount);

  SetProtoMethod(isolate, t, ""setURL"", SetURL);
  SetProtoMethod(isolate, t, ""push"", Push);
  SetProtoMethod(isolate, t, ""finish"", Finish);
  SetProtoMethod(isolate, t, ""abort"", Abort);

  auto function = t->GetFunction(env->context()).ToLocalChecked();
  env->set_wasm_streaming_object_constructor(function);
  return function;
}",1,1,node_wasm_web_api.cc,node.wasm_web_api.WasmStreamingObject.Initialize,,false,23,42,Initialize,,,1,Local<Function> node.wasm_web_api.WasmStreamingObject.Initialize (Environment*)
252710,METHOD,node_wasm_web_api.cc:<global>,TYPE_DECL,"void WasmStreamingObject::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(New);
  registry->Register(Push);
  registry->Register(Finish);
  registry->Register(Abort);
}",1,1,node_wasm_web_api.cc,node.wasm_web_api.WasmStreamingObject.RegisterExternalReferences,,false,44,50,RegisterExternalReferences,,,2,void node.wasm_web_api.WasmStreamingObject.RegisterExternalReferences (ExternalReferenceRegistry*)
252735,METHOD,node_wasm_web_api.cc:<global>,TYPE_DECL,"void WasmStreamingObject::MemoryInfo(MemoryTracker* tracker) const {
  // v8::WasmStreaming is opaque. We assume that the size of the WebAssembly
  // module that is being compiled is roughly what V8 allocates (as in, off by
  // only a small factor).
  tracker->TrackFieldWithSize(""streaming"", wasm_size_);
}",1,1,node_wasm_web_api.cc,node.wasm_web_api.WasmStreamingObject.MemoryInfo,,false,52,57,MemoryInfo,,,3,void node.wasm_web_api.WasmStreamingObject.MemoryInfo (MemoryTracker*)
252746,METHOD,node_wasm_web_api.cc:<global>,TYPE_DECL,"MaybeLocal<Object> WasmStreamingObject::Create(
    Environment* env, std::shared_ptr<WasmStreaming> streaming) {
  Local<Function> ctor = Initialize(env);
  Local<Object> obj;
  if (!ctor->NewInstance(env->context(), 0, nullptr).ToLocal(&obj)) {
    return MaybeLocal<Object>();
  }

  CHECK(streaming);

  WasmStreamingObject* ptr = Unwrap<WasmStreamingObject>(obj);
  CHECK_NOT_NULL(ptr);
  ptr->streaming_ = streaming;
  ptr->wasm_size_ = 0;
  return obj;
}",1,1,node_wasm_web_api.cc,node.wasm_web_api.WasmStreamingObject.Create,,false,59,74,Create,,,4,"MaybeLocal<Object> node.wasm_web_api.WasmStreamingObject.Create (Environment*,ANY)"
252809,METHOD,node_wasm_web_api.cc:<global>,TYPE_DECL,"void WasmStreamingObject::New(const FunctionCallbackInfo<Value>& args) {
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new WasmStreamingObject(env, args.This());
}",1,1,node_wasm_web_api.cc,node.wasm_web_api.WasmStreamingObject.New,,false,76,80,New,,,5,void node.wasm_web_api.WasmStreamingObject.New (FunctionCallbackInfo<Value>)
252834,METHOD,node_wasm_web_api.cc:<global>,TYPE_DECL,"void WasmStreamingObject::SetURL(const FunctionCallbackInfo<Value>& args) {
  WasmStreamingObject* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.Holder());
  CHECK(obj->streaming_);

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());
  Utf8Value url(Environment::GetCurrent(args)->isolate(), args[0]);
  obj->streaming_->SetUrl(url.out(), url.length());
}",1,1,node_wasm_web_api.cc,node.wasm_web_api.WasmStreamingObject.SetURL,,false,82,91,SetURL,,,6,void node.wasm_web_api.WasmStreamingObject.SetURL (FunctionCallbackInfo<Value>)
252891,METHOD,node_wasm_web_api.cc:<global>,TYPE_DECL,"void WasmStreamingObject::Push(const FunctionCallbackInfo<Value>& args) {
  WasmStreamingObject* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.Holder());
  CHECK(obj->streaming_);

  CHECK_EQ(args.Length(), 1);
  Local<Value> chunk = args[0];

  // The start of the memory section backing the ArrayBuffer(View), the offset
  // of the ArrayBuffer(View) within the memory section, and its size in bytes.
  const void* bytes;
  size_t offset;
  size_t size;

  if (LIKELY(chunk->IsArrayBufferView())) {
    Local<ArrayBufferView> view = chunk.As<ArrayBufferView>();
    bytes = view->Buffer()->Data();
    offset = view->ByteOffset();
    size = view->ByteLength();
  } else if (LIKELY(chunk->IsArrayBuffer())) {
    Local<ArrayBuffer> buffer = chunk.As<ArrayBuffer>();
    bytes = buffer->Data();
    offset = 0;
    size = buffer->ByteLength();
  } else {
    return node::THROW_ERR_INVALID_ARG_TYPE(
        Environment::GetCurrent(args),
        ""chunk must be an ArrayBufferView or an ArrayBuffer"")...",1,1,node_wasm_web_api.cc,node.wasm_web_api.WasmStreamingObject.Push,,false,93,127,Push,,,7,void node.wasm_web_api.WasmStreamingObject.Push (FunctionCallbackInfo<Value>)
253028,METHOD,node_wasm_web_api.cc:<global>,TYPE_DECL,"void WasmStreamingObject::Finish(const FunctionCallbackInfo<Value>& args) {
  WasmStreamingObject* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.Holder());
  CHECK(obj->streaming_);

  CHECK_EQ(args.Length(), 0);
  obj->streaming_->Finish();
}",1,1,node_wasm_web_api.cc,node.wasm_web_api.WasmStreamingObject.Finish,,false,129,136,Finish,,,8,void node.wasm_web_api.WasmStreamingObject.Finish (FunctionCallbackInfo<Value>)
253057,METHOD,node_wasm_web_api.cc:<global>,TYPE_DECL,"void WasmStreamingObject::Abort(const FunctionCallbackInfo<Value>& args) {
  WasmStreamingObject* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.Holder());
  CHECK(obj->streaming_);

  CHECK_EQ(args.Length(), 1);
  obj->streaming_->Abort(args[0]);
}",1,1,node_wasm_web_api.cc,node.wasm_web_api.WasmStreamingObject.Abort,,false,138,145,Abort,,,9,void node.wasm_web_api.WasmStreamingObject.Abort (FunctionCallbackInfo<Value>)
253089,METHOD,node_wasm_web_api.cc:<global>,TYPE_DECL,"void StartStreamingCompilation(const FunctionCallbackInfo<Value>& info) {
  // V8 passes an instance of v8::WasmStreaming to this callback, which we can
  // use to pass the WebAssembly module bytes to V8 as we receive them.
  // Unfortunately, our fetch() implementation is a JavaScript dependency, so it
  // is difficult to implement the required logic here. Instead, we create a
  // a WasmStreamingObject that encapsulates v8::WasmStreaming and that we can
  // pass to the JavaScript implementation. The JavaScript implementation can
  // then push() bytes from the Response and eventually either finish() or
  // abort() the operation.

  // Create the wrapper object.
  std::shared_ptr<WasmStreaming> streaming =
      WasmStreaming::Unpack(info.GetIsolate(), info.Data());
  Environment* env = Environment::GetCurrent(info);
  Local<Object> obj;
  if (!WasmStreamingObject::Create(env, streaming).ToLocal(&obj)) {
    // A JavaScript exception is pending. Let V8 deal with it.
    return;...",1,1,node_wasm_web_api.cc,node.wasm_web_api.StartStreamingCompilation,,false,147,186,StartStreamingCompilation,,,10,void node.wasm_web_api.StartStreamingCompilation (FunctionCallbackInfo<Value>)
253208,METHOD,node_wasm_web_api.cc:<global>,TYPE_DECL,"void SetImplementation(const FunctionCallbackInfo<Value>& info) {
  Environment* env = Environment::GetCurrent(info);
  env->set_wasm_streaming_compilation_impl(info[0].As<Function>());
}",1,1,node_wasm_web_api.cc,node.wasm_web_api.SetImplementation,,false,189,192,SetImplementation,,,11,void node.wasm_web_api.SetImplementation (FunctionCallbackInfo<Value>)
253231,METHOD,node_wasm_web_api.cc:<global>,TYPE_DECL,"void Initialize(Local<Object> target,
                Local<Value>,
                Local<Context> context,
                void*) {
  SetMethod(context, target, ""setImplementation"", SetImplementation);
}",1,1,node_wasm_web_api.cc,node.wasm_web_api.Initialize,,false,194,199,Initialize,,,12,"void node.wasm_web_api.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
253244,METHOD,node_wasm_web_api.cc:<global>,TYPE_DECL,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(SetImplementation);
  registry->Register(StartStreamingCompilation);
  WasmStreamingObject::RegisterExternalReferences(registry);
}",1,1,node_wasm_web_api.cc,node.wasm_web_api.RegisterExternalReferences,,false,201,205,RegisterExternalReferences,,,13,void node.wasm_web_api.RegisterExternalReferences (ExternalReferenceRegistry*)
253272,METHOD,node_wasm_web_api.hpp:<global>,TYPE_DECL,<global>,1,35,node_wasm_web_api.hpp,node_wasm_web_api.hpp:<global>,,false,1,55,<global>,,,1,
253275,METHOD,node_watchdog.cc:<global>,TYPE_DECL,"[](uv_async_t* signal) {
    Watchdog* w = ContainerOf(&Watchdog::async_, signal);
    uv_stop(&w->loop_);
  }",39,3,node_watchdog.cc,node.Watchdog.Watchdog.<lambda>0,,false,51,54,<lambda>0,,,1,ANY node.Watchdog.Watchdog.<lambda>0 (uv_async_t*)
253296,METHOD,node_watchdog.cc:<global>,TYPE_DECL,"[](uv_async_t* handle) {
    TraceSigintWatchdog* watchdog =
        ContainerOf(&TraceSigintWatchdog::handle_, handle);
    watchdog->signal_flag_ = SignalFlags::FromIdle;
    watchdog->HandleInterrupt();
  }",54,3,node_watchdog.cc,node.TraceSigintWatchdog.TraceSigintWatchdog.<lambda>1,,false,172,177,<lambda>1,,,1,ANY node.TraceSigintWatchdog.TraceSigintWatchdog.<lambda>1 (uv_async_t*)
253322,METHOD,node_watchdog.cc:<global>,TYPE_DECL,"[](v8::Isolate* isolate, void* data) {
        TraceSigintWatchdog* self = static_cast<TraceSigintWatchdog*>(data);
        if (self->signal_flag_ == SignalFlags::None) {
          self->signal_flag_ = SignalFlags::FromInterrupt;
        }
        self->HandleInterrupt();
      }",7,7,node_watchdog.cc,node.TraceSigintWatchdog.HandleSigint.<lambda>2,,false,189,195,<lambda>2,,,1,"ANY node.TraceSigintWatchdog.HandleSigint.<lambda>2 (ANY*,void*)"
253372,METHOD,node_watchdog.cc:<global>,TYPE_DECL,<global>,1,1,node_watchdog.cc,node_watchdog.cc:<global>,,false,1,437,<global>,,,1,
253375,METHOD,node_watchdog.cc:<global>,TYPE_DECL,"Watchdog::Watchdog(v8::Isolate* isolate, uint64_t ms, bool* timed_out)
    : isolate_(isolate), timed_out_(timed_out) {

  int rc;
  rc = uv_loop_init(&loop_);
  if (rc != 0) {
    OnFatalError(""node::Watchdog::Watchdog()"", ""Failed to initialize uv loop."");
  }

  rc = uv_async_init(&loop_, &async_, [](uv_async_t* signal) {
    Watchdog* w = ContainerOf(&Watchdog::async_, signal);
    uv_stop(&w->loop_);
  });

  CHECK_EQ(0, rc);

  rc = uv_timer_init(&loop_, &timer_);
  CHECK_EQ(0, rc);

  rc = uv_timer_start(&timer_, &Watchdog::Timer, ms, 0);
  CHECK_EQ(0, rc);

  rc = uv_thread_create(&thread_, &Watchdog::Run, this);
  CHECK_EQ(0, rc);
}",1,1,node_watchdog.cc,node.Watchdog.Watchdog,,false,42,66,Watchdog,,,1,"ANY node.Watchdog.Watchdog (ANY*,uint64_t,bool*)"
253444,METHOD,node_watchdog.cc:<global>,TYPE_DECL,"Watchdog::~Watchdog() {
  uv_async_send(&async_);
  uv_thread_join(&thread_);

  uv_close(reinterpret_cast<uv_handle_t*>(&async_), nullptr);

  // UV_RUN_DEFAULT so that libuv has a chance to clean up.
  uv_run(&loop_, UV_RUN_DEFAULT);

  CheckedUvLoopClose(&loop_);
}",1,1,node_watchdog.cc,node.Watchdog.~Watchdog,,false,69,79,~Watchdog,,,2,ANY node.Watchdog.~Watchdog ()
253461,METHOD,node_watchdog.cc:<global>,TYPE_DECL,"void Watchdog::Run(void* arg) {
  Watchdog* wd = static_cast<Watchdog*>(arg);

  // UV_RUN_DEFAULT the loop will be stopped either by the async or the
  // timer handle.
  uv_run(&wd->loop_, UV_RUN_DEFAULT);

  // Loop ref count reaches zero when both handles are closed.
  // Close the timer handle on this side and let ~Watchdog() close async_
  uv_close(reinterpret_cast<uv_handle_t*>(&wd->timer_), nullptr);
}",1,1,node_watchdog.cc,node.Watchdog.Run,,false,82,92,Run,,,3,void node.Watchdog.Run (void*)
253486,METHOD,node_watchdog.cc:<global>,TYPE_DECL,"void Watchdog::Timer(uv_timer_t* timer) {
  Watchdog* w = ContainerOf(&Watchdog::timer_, timer);
  *w->timed_out_ = true;
  w->isolate()->TerminateExecution();
  uv_stop(&w->loop_);
}",1,1,node_watchdog.cc,node.Watchdog.Timer,,false,94,99,Timer,,,4,void node.Watchdog.Timer (uv_timer_t*)
253518,METHOD,node_watchdog.cc:<global>,TYPE_DECL,"SigintWatchdog::SigintWatchdog(
  v8::Isolate* isolate, bool* received_signal)
    : isolate_(isolate), received_signal_(received_signal) {
  Mutex::ScopedLock lock(SigintWatchdogHelper::GetInstanceActionMutex());
  // Register this watchdog with the global SIGINT/Ctrl+C listener.
  SigintWatchdogHelper::GetInstance()->Register(this);
  // Start the helper thread, if that has not already happened.
  SigintWatchdogHelper::GetInstance()->Start();
}",1,1,node_watchdog.cc,node.SigintWatchdog.SigintWatchdog,,false,102,110,SigintWatchdog,,,5,"ANY node.SigintWatchdog.SigintWatchdog (ANY*,bool*)"
253545,METHOD,node_watchdog.cc:<global>,TYPE_DECL,"SigintWatchdog::~SigintWatchdog() {
  Mutex::ScopedLock lock(SigintWatchdogHelper::GetInstanceActionMutex());
  SigintWatchdogHelper::GetInstance()->Unregister(this);
  SigintWatchdogHelper::GetInstance()->Stop();
}",1,1,node_watchdog.cc,node.SigintWatchdog.~SigintWatchdog,,false,113,117,~SigintWatchdog,,,6,ANY node.SigintWatchdog.~SigintWatchdog ()
253570,METHOD,node_watchdog.cc:<global>,TYPE_DECL,"SignalPropagation SigintWatchdog::HandleSigint() {
  *received_signal_ = true;
  isolate_->TerminateExecution();
  return SignalPropagation::kStopPropagation;
}",1,1,node_watchdog.cc,node.SigintWatchdog.HandleSigint,,false,119,123,HandleSigint,,,7,SignalPropagation node.SigintWatchdog.HandleSigint ()
253586,METHOD,node_watchdog.cc:<global>,TYPE_DECL,"void TraceSigintWatchdog::Init(Environment* env, Local<Object> target) {
  Isolate* isolate = env->isolate();
  Local<FunctionTemplate> constructor = NewFunctionTemplate(isolate, New);
  constructor->InstanceTemplate()->SetInternalFieldCount(
      TraceSigintWatchdog::kInternalFieldCount);
  constructor->Inherit(HandleWrap::GetConstructorTemplate(env));

  SetProtoMethod(isolate, constructor, ""start"", Start);
  SetProtoMethod(isolate, constructor, ""stop"", Stop);

  SetConstructorFunction(
      env->context(), target, ""TraceSigintWatchdog"", constructor);
}",1,1,node_watchdog.cc,node.TraceSigintWatchdog.Init,,false,125,137,Init,,,8,"void node.TraceSigintWatchdog.Init (Environment*,Local<Object>)"
253645,METHOD,node_watchdog.cc:<global>,TYPE_DECL,"void TraceSigintWatchdog::New(const FunctionCallbackInfo<Value>& args) {
  // This constructor should not be exposed to public javascript.
  // Therefore we assert that we are not trying to call this as a
  // normal function.
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new TraceSigintWatchdog(env, args.This());
}",1,1,node_watchdog.cc,node.TraceSigintWatchdog.New,,false,139,146,New,,,9,void node.TraceSigintWatchdog.New (FunctionCallbackInfo<Value>)
253670,METHOD,node_watchdog.cc:<global>,TYPE_DECL,"void TraceSigintWatchdog::Start(const FunctionCallbackInfo<Value>& args) {
  TraceSigintWatchdog* watchdog;
  ASSIGN_OR_RETURN_UNWRAP(&watchdog, args.Holder());
  Mutex::ScopedLock lock(SigintWatchdogHelper::GetInstanceActionMutex());
  // Register this watchdog with the global SIGINT/Ctrl+C listener.
  SigintWatchdogHelper::GetInstance()->Register(watchdog);
  // Start the helper thread, if that has not already happened.
  int r = SigintWatchdogHelper::GetInstance()->Start();
  CHECK_EQ(r, 0);
}",1,1,node_watchdog.cc,node.TraceSigintWatchdog.Start,,false,148,157,Start,,,10,void node.TraceSigintWatchdog.Start (FunctionCallbackInfo<Value>)
253710,METHOD,node_watchdog.cc:<global>,TYPE_DECL,"void TraceSigintWatchdog::Stop(const FunctionCallbackInfo<Value>& args) {
  TraceSigintWatchdog* watchdog;
  ASSIGN_OR_RETURN_UNWRAP(&watchdog, args.Holder());
  Mutex::ScopedLock lock(SigintWatchdogHelper::GetInstanceActionMutex());
  SigintWatchdogHelper::GetInstance()->Unregister(watchdog);
  SigintWatchdogHelper::GetInstance()->Stop();
}",1,1,node_watchdog.cc,node.TraceSigintWatchdog.Stop,,false,159,165,Stop,,,11,void node.TraceSigintWatchdog.Stop (FunctionCallbackInfo<Value>)
253744,METHOD,node_watchdog.cc:<global>,TYPE_DECL,"TraceSigintWatchdog::TraceSigintWatchdog(Environment* env, Local<Object> object)
    : HandleWrap(env,
                 object,
                 reinterpret_cast<uv_handle_t*>(&handle_),
                 AsyncWrap::PROVIDER_SIGINTWATCHDOG) {
  int r = uv_async_init(env->event_loop(), &handle_, [](uv_async_t* handle) {
    TraceSigintWatchdog* watchdog =
        ContainerOf(&TraceSigintWatchdog::handle_, handle);
    watchdog->signal_flag_ = SignalFlags::FromIdle;
    watchdog->HandleInterrupt();
  });
  CHECK_EQ(r, 0);
  uv_unref(reinterpret_cast<uv_handle_t*>(&handle_));
}",1,1,node_watchdog.cc,node.TraceSigintWatchdog.TraceSigintWatchdog,,false,167,180,TraceSigintWatchdog,,,12,"ANY node.TraceSigintWatchdog.TraceSigintWatchdog (Environment*,Local<Object>)"
253769,METHOD,node_watchdog.cc:<global>,TYPE_DECL,"SignalPropagation TraceSigintWatchdog::HandleSigint() {
  /**
   * In case of uv loop polling, i.e. no JS currently running, activate the
   * loop to run a piece of JS code to trigger interruption.
   */
  CHECK_EQ(uv_async_send(&handle_), 0);
  env()->isolate()->RequestInterrupt(
      [](v8::Isolate* isolate, void* data) {
        TraceSigintWatchdog* self = static_cast<TraceSigintWatchdog*>(data);
        if (self->signal_flag_ == SignalFlags::None) {
          self->signal_flag_ = SignalFlags::FromInterrupt;
        }
        self->HandleInterrupt();
      },
      this);
  return SignalPropagation::kContinuePropagation;
}",1,1,node_watchdog.cc,node.TraceSigintWatchdog.HandleSigint,,false,182,198,HandleSigint,,,13,SignalPropagation node.TraceSigintWatchdog.HandleSigint ()
253791,METHOD,node_watchdog.cc:<global>,TYPE_DECL,"void TraceSigintWatchdog::HandleInterrupt() {
  // Do not nest interrupts.
  if (interrupting) {
    return;
  }
  interrupting = true;
  if (signal_flag_ == SignalFlags::None) {
    return;
  }
  Environment* env_ = env();
  // FIXME: Before
  // https://github.com/nodejs/node/pull/29207#issuecomment-527667993 get
  // fixed, additional JavaScript code evaluation shall be prevented from
  // running during interruption.
  FPrintF(stderr,
      ""KEYBOARD_INTERRUPT: Script execution was interrupted by `SIGINT`\n"");
  if (signal_flag_ == SignalFlags::FromInterrupt) {
    PrintStackTrace(env_->isolate(),
                    v8::StackTrace::CurrentStackTrace(
                        env_->isolate(), 10, v8::StackTrace::kDetailed));
  }
  signal_flag_ = SignalFlags::None;
  interrupting = false;

  Mutex::ScopedLock lock(SigintWatchdogHelper::GetInstanceActionMutex());
  SigintWatchdogHelper::GetInstance()->Unregister(this);
  SigintWatchdogHelper::GetInstance()->Stop();
  raise(SIGINT);
}",1,1,node_watchdog.cc,node.TraceSigintWatchdog.HandleInterrupt,,false,200,228,HandleInterrupt,,,14,void node.TraceSigintWatchdog.HandleInterrupt ()
253876,METHOD,node_watchdog.cc:<global>,TYPE_DECL,"WINAPI SigintWatchdogHelper::WinCtrlCHandlerRoutine(DWORD dwCtrlType) {
  if (!instance.watchdog_disabled_ &&
      (dwCtrlType == CTRL_C_EVENT || dwCtrlType == CTRL_BREAK_EVENT)) {
    InformWatchdogsAboutSignal();

    // Return true because the signal has been handled.
    return TRUE;
  } else {
    return FALSE;
  }
}",6,1,node_watchdog.cc,node.SigintWatchdogHelper.WinCtrlCHandlerRoutine,,false,253,263,WinCtrlCHandlerRoutine,,,16,WINAPI node.SigintWatchdogHelper.WinCtrlCHandlerRoutine (DWORD)
253902,METHOD,node_watchdog.cc:<global>,TYPE_DECL,"bool SigintWatchdogHelper::InformWatchdogsAboutSignal() {
  Mutex::ScopedLock list_lock(instance.list_mutex_);

  bool is_stopping = false;
#ifdef __POSIX__
  is_stopping = instance.stopping_;
#endif

  // If there are no listeners and the helper thread has been awoken by a signal
  // (= not when stopping it), indicate that by setting has_pending_signal_.
  if (instance.watchdogs_.empty() && !is_stopping) {
    instance.has_pending_signal_ = true;
  }

  for (auto it = instance.watchdogs_.rbegin(); it != instance.watchdogs_.rend();
       it++) {
    SignalPropagation wp = (*it)->HandleSigint();
    if (wp == SignalPropagation::kStopPropagation) {
      break;
    }
  }

  return is_stopping;
}",1,1,node_watchdog.cc,node.SigintWatchdogHelper.InformWatchdogsAboutSignal,,false,267,290,InformWatchdogsAboutSignal,,,17,bool node.SigintWatchdogHelper.InformWatchdogsAboutSignal ()
253971,METHOD,node_watchdog.cc:<global>,TYPE_DECL,"int SigintWatchdogHelper::Start() {
  Mutex::ScopedLock lock(mutex_);

  if (start_stop_count_++ > 0) {
    return 0;
  }

#ifdef __POSIX__
  CHECK_EQ(has_running_thread_, false);
  has_pending_signal_ = false;
  stopping_ = false;

  sigset_t sigmask;
  sigfillset(&sigmask);
  sigset_t savemask;
  CHECK_EQ(0, pthread_sigmask(SIG_SETMASK, &sigmask, &savemask));
  sigmask = savemask;
  int ret = pthread_create(&thread_, nullptr, RunSigintWatchdog, nullptr);
  CHECK_EQ(0, pthread_sigmask(SIG_SETMASK, &sigmask, nullptr));
  if (ret != 0) {
    return ret;
  }
  has_running_thread_ = true;

  RegisterSignalHandler(SIGINT, HandleSignal);
#else
  if (watchdog_disabled_) {
    watchdog_disabled_ = false;
  } else {
    SetConsoleCtrlHandler(WinCtrlCHandlerRoutine, TRUE);
  }
#endif

  return 0;
}",1,1,node_watchdog.cc,node.SigintWatchdogHelper.Start,,false,293,327,Start,,,18,int node.SigintWatchdogHelper.Start ()
253999,METHOD,node_watchdog.cc:<global>,TYPE_DECL,"bool SigintWatchdogHelper::Stop() {
  bool had_pending_signal;
  Mutex::ScopedLock lock(mutex_);

  {
    Mutex::ScopedLock list_lock(list_mutex_);

    had_pending_signal = has_pending_signal_;

    if (--start_stop_count_ > 0) {
      has_pending_signal_ = false;
      return had_pending_signal;
    }

#ifdef __POSIX__
    // Set stopping now because it's only protected by list_mutex_.
    stopping_ = true;
#endif

    watchdogs_.clear();
  }

#ifdef __POSIX__
  if (!has_running_thread_) {
    has_pending_signal_ = false;
    return had_pending_signal;
  }

  // Wake up the helper thread.
  uv_sem_post(&sem_);

  // Wait for the helper thread to finish.
  CHECK_EQ(0, pthread_join(thread_, nullptr));
  has_running_thread_ = false;

  RegisterSignalHandler(SIGINT, SignalExit, true);
#else
  watchdog_disabled_ = true;
#endif

  had_pending_signal = has_pending_signal_;
  has_pending_signal_ = false;

  return had_pending_signal;
}",1,1,node_watchdog.cc,node.SigintWatchdogHelper.Stop,,false,330,374,Stop,,,19,bool node.SigintWatchdogHelper.Stop ()
254040,METHOD,node_watchdog.cc:<global>,TYPE_DECL,"bool SigintWatchdogHelper::HasPendingSignal() {
  Mutex::ScopedLock lock(list_mutex_);

  return has_pending_signal_;
}",1,1,node_watchdog.cc,node.SigintWatchdogHelper.HasPendingSignal,,false,377,381,HasPendingSignal,,,20,bool node.SigintWatchdogHelper.HasPendingSignal ()
254049,METHOD,node_watchdog.cc:<global>,TYPE_DECL,"void SigintWatchdogHelper::Register(SigintWatchdogBase* wd) {
  Mutex::ScopedLock lock(list_mutex_);

  watchdogs_.push_back(wd);
}",1,1,node_watchdog.cc,node.SigintWatchdogHelper.Register,,false,383,387,Register,,,21,void node.SigintWatchdogHelper.Register (SigintWatchdogBase*)
254062,METHOD,node_watchdog.cc:<global>,TYPE_DECL,"void SigintWatchdogHelper::Unregister(SigintWatchdogBase* wd) {
  Mutex::ScopedLock lock(list_mutex_);

  auto it = std::find(watchdogs_.begin(), watchdogs_.end(), wd);

  CHECK_NE(it, watchdogs_.end());
  watchdogs_.erase(it);
}",1,1,node_watchdog.cc,node.SigintWatchdogHelper.Unregister,,false,389,396,Unregister,,,22,void node.SigintWatchdogHelper.Unregister (SigintWatchdogBase*)
254097,METHOD,node_watchdog.cc:<global>,TYPE_DECL,"SigintWatchdogHelper::SigintWatchdogHelper()
    : start_stop_count_(0),
      has_pending_signal_(false) {
#ifdef __POSIX__
  has_running_thread_ = false;
  stopping_ = false;
  CHECK_EQ(0, uv_sem_init(&sem_, 0));
#else
  watchdog_disabled_ = false;
#endif
}",1,1,node_watchdog.cc,node.SigintWatchdogHelper.SigintWatchdogHelper,,false,399,409,SigintWatchdogHelper,,,23,ANY node.SigintWatchdogHelper.SigintWatchdogHelper ()
254104,METHOD,node_watchdog.cc:<global>,TYPE_DECL,"SigintWatchdogHelper::~SigintWatchdogHelper() {
  start_stop_count_ = 0;
  Stop();

#ifdef __POSIX__
  CHECK_EQ(has_running_thread_, false);
  uv_sem_destroy(&sem_);
#endif
}",1,1,node_watchdog.cc,node.SigintWatchdogHelper.~SigintWatchdogHelper,,false,412,420,~SigintWatchdogHelper,,,24,ANY node.SigintWatchdogHelper.~SigintWatchdogHelper ()
254115,METHOD,node_watchdog.cc:<global>,TYPE_DECL,"static void Initialize(Local<Object> target,
                       Local<Value> unused,
                       Local<Context> context,
                       void* priv) {
  Environment* env = Environment::GetCurrent(context);
  TraceSigintWatchdog::Init(env, target);
}",1,1,node_watchdog.cc,node.watchdog.Initialize,,false,426,432,Initialize,,,1,"void node.watchdog.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
254155,METHOD,node_watchdog.hpp:<global>,TYPE_DECL,<global>,1,31,node_watchdog.hpp,node_watchdog.hpp:<global>,,false,1,154,<global>,,,1,
254158,METHOD,node.worker.WorkerThreadData,TYPE_DECL,"[](void* data) {
        *static_cast<bool*>(data) = true;
      }",58,7,node_worker.cc,node.worker.WorkerThreadData.~WorkerThreadData.<lambda>0,,false,221,223,<lambda>0,,,1,ANY node.worker.WorkerThreadData.~WorkerThreadData.<lambda>0 (void*)
254171,METHOD,node_worker.cc:<global>,TYPE_DECL,"[&]() {
      // TODO(addaleax): This call is harmless but should not be necessary.
      // Figure out why V8 is raising a DCHECK() here without it
      // (in test/parallel/test-async-hooks-worker-asyncfn-terminate-4.js).
      isolate_->CancelTerminateExecution();

      if (!env_) return;
      env_->set_can_call_into_js(false);

      {
        Mutex::ScopedLock lock(mutex_);
        stopped_ = true;
        this->env_ = nullptr;
      }

      env_.reset();
    }",37,5,node_worker.cc,node.worker.Worker.Run.<lambda>1,,false,297,313,<lambda>1,,,1,ANY node.worker.Worker.Run.<lambda>1 ()
254207,METHOD,node_worker.cc:<global>,TYPE_DECL,"[this](Environment*, int exit_code) {
          Exit(static_cast<ExitCode>(exit_code));
        }",43,9,node_worker.cc,node.worker.Worker.Run.<lambda>2,,false,366,368,<lambda>2,,,1,"ANY node.worker.Worker.Run.<lambda>2 (Environment*,int)"
254218,METHOD,node_worker.cc:<global>,TYPE_DECL,"[&env_vars](const char* name) {
      return env_vars->Get(name).FromMaybe("""");
    }",49,5,node_worker.cc,node.worker.Worker.New.<lambda>3,,false,528,530,<lambda>3,,,1,ANY node.worker.Worker.New.<lambda>3 (char*)
254235,METHOD,node_worker.cc:<global>,TYPE_DECL,"[w = std::unique_ptr<Worker>(w)](Environment* env) {
          if (w->has_ref_)
            env->add_refs(-1);
          w->JoinThread();
          // implicitly delete w
        }",9,9,node_worker.cc,node.worker.Worker.StartThread..<lambda>5,,false,686,691,<lambda>5,,,1,ANY node.worker.Worker.StartThread..<lambda>5 (Environment*)
254257,METHOD,node_worker.cc:<global>,TYPE_DECL,"[](void* arg) {
    // XXX: This could become a std::unique_ptr, but that makes at least
    // gcc 6.3 detect undefined behaviour when there shouldn't be any.
    // gcc 7+ handles this well.
    Worker* w = static_cast<Worker*>(arg);
    const uintptr_t stack_top = reinterpret_cast<uintptr_t>(&arg);

    // Leave a few kilobytes just to make sure we're within limits and have
    // some space to do work in C++ land.
    w->stack_base_ = stack_top - (w->stack_size_ - kStackBufferSize);

    w->Run();

    Mutex::ScopedLock lock(w->mutex_);
    w->env()->SetImmediateThreadsafe(
        [w = std::unique_ptr<Worker>(w)](Environment* env) {
          if (w->has_ref_)
            env->add_refs(-1);
          w->JoinThread();
          // implicitly delete w
        });
  }",55,3,node_worker.cc,node.worker.Worker.StartThread.<lambda>4,,false,671,692,<lambda>4,,,1,ANY node.worker.Worker.StartThread.<lambda>4 (void*)
254303,METHOD,node_worker.cc:<global>,TYPE_DECL,"[taker = std::move(taker),
         snapshot = std::move(snapshot)](Environment* env) mutable {
          HandleScope handle_scope(env->isolate());
          Context::Scope context_scope(env->context());

          AsyncHooks::DefaultTriggerAsyncIdScope trigger_id_scope(taker->get());
          BaseObjectPtr<AsyncWrap> stream =
              heap::CreateHeapSnapshotStream(env, std::move(snapshot));
          Local<Value> args[] = {stream->object()};
          taker->get()->MakeCallback(
              env->ondone_string(), arraysize(args), args);
          // implicitly delete `taker`
        }",9,9,node_worker.cc,node.worker.Worker.TakeHeapSnapshot..<lambda>7,,false,836,848,<lambda>7,,,1,ANY node.worker.Worker.TakeHeapSnapshot..<lambda>7 (Environment*)
254367,METHOD,node_worker.cc:<global>,TYPE_DECL,"[taker = std::move(taker), env, options](
                                           Environment* worker_env) mutable {
    heap::HeapSnapshotPointer snapshot{
        worker_env->isolate()->GetHeapProfiler()->TakeHeapSnapshot(options)};
    CHECK(snapshot);

    // Here, the worker thread temporarily owns the WorkerHeapSnapshotTaker
    // object.

    env->SetImmediateThreadsafe(
        [taker = std::move(taker),
         snapshot = std::move(snapshot)](Environment* env) mutable {
          HandleScope handle_scope(env->isolate());
          Context::Scope context_scope(env->context());

          AsyncHooks::DefaultTriggerAsyncIdScope trigger_id_scope(taker->get());
          BaseObjectPtr<AsyncWrap> stream =
              heap::CreateHeapSnapshotStream(env, std::move(snapshot));
          Local<Value> args[] = {stream->object()};
          taker->get()->MakeCallback(
              env->ondone_string(), arraysize(args), args);
          // implicitly delete `taker`
        },
  ...",40,3,node_worker.cc,node.worker.Worker.TakeHeapSnapshot.<lambda>6,,false,826,853,<lambda>6,,,1,ANY node.worker.Worker.TakeHeapSnapshot.<lambda>6 (Environment*)
254431,METHOD,node_worker.cc:<global>,TYPE_DECL,<global>,1,29,node_worker.hpp,node_worker.cc:<global>,,false,1,1013,<global>,,,1,
254441,METHOD,node_worker.cc:<global>,TYPE_DECL,"Worker::Worker(Environment* env,
               Local<Object> wrap,
               const std::string& url,
               const std::string& name,
               std::shared_ptr<PerIsolateOptions> per_isolate_opts,
               std::vector<std::string>&& exec_argv,
               std::shared_ptr<KVStore> env_vars,
               const SnapshotData* snapshot_data)
    : AsyncWrap(env, wrap, AsyncWrap::PROVIDER_WORKER),
      per_isolate_opts_(per_isolate_opts),
      exec_argv_(exec_argv),
      platform_(env->isolate_data()->platform()),
      thread_id_(AllocateEnvironmentThreadId()),
      name_(name),
      env_vars_(env_vars),
      snapshot_data_(snapshot_data) {
  Debug(this, ""Creating new worker instance with thread id %llu"",
        thread_id_.id);

  // Set up everything that needs to be set up in the parent environment.
  MessagePort* parent_port = MessagePort::New(env, env->context());
  if (parent_port == nullptr) {
    // This can happen e.g. because execution is term...",1,1,node_worker.cc,node.worker.Worker.Worker,,false,50,101,Worker,,,3,"ANY node.worker.Worker.Worker (Environment*,Local<Object>,ANY,ANY,ANY,ANY,ANY,SnapshotData*)"
254588,METHOD,node_worker.cc:<global>,TYPE_DECL,"bool Worker::is_stopped() const {
  Mutex::ScopedLock lock(mutex_);
  if (env_ != nullptr)
    return env_->is_stopping();
  return stopped_;
}",1,1,node_worker.cc,node.worker.Worker.is_stopped,,false,103,108,is_stopped,,,4,bool node.worker.Worker.is_stopped ()
254607,METHOD,node_worker.cc:<global>,TYPE_DECL,"void Worker::UpdateResourceConstraints(ResourceConstraints* constraints) {
  constraints->set_stack_limit(reinterpret_cast<uint32_t*>(stack_base_));

  if (resource_limits_[kMaxYoungGenerationSizeMb] > 0) {
    constraints->set_max_young_generation_size_in_bytes(
        static_cast<size_t>(resource_limits_[kMaxYoungGenerationSizeMb] * kMB));
  } else {
    resource_limits_[kMaxYoungGenerationSizeMb] =
        constraints->max_young_generation_size_in_bytes() / kMB;
  }

  if (resource_limits_[kMaxOldGenerationSizeMb] > 0) {
    constraints->set_max_old_generation_size_in_bytes(
        static_cast<size_t>(resource_limits_[kMaxOldGenerationSizeMb] * kMB));
  } else {
    resource_limits_[kMaxOldGenerationSizeMb] =
        constraints->max_old_generation_size_in_bytes() / kMB;
  }

  if (resource_limits_[kCodeRangeSizeMb] > 0) {
    constraints->set_code_range_size_in_bytes(
        static_cast<size_t>(resource_limits_[kCodeRangeSizeMb] * kMB));
  } else {
    resource_limits_[kCodeR...",1,1,node_worker.cc,node.worker.Worker.UpdateResourceConstraints,,false,110,136,UpdateResourceConstraints,,,5,void node.worker.Worker.UpdateResourceConstraints (ResourceConstraints*)
254709,METHOD,node.worker.WorkerThreadData,TYPE_DECL,"explicit WorkerThreadData(Worker* w)
    : w_(w) {
    int ret = uv_loop_init(&loop_);
    if (ret != 0) {
      char err_buf[128];
      uv_err_name_r(ret, err_buf, sizeof(err_buf));
      // TODO(joyeecheung): maybe this should be kBootstrapFailure instead?
      w->Exit(ExitCode::kGenericUserError, ""ERR_WORKER_INIT_FAILED"", err_buf);
      return;
    }
    loop_init_failed_ = false;
    uv_loop_configure(&loop_, UV_METRICS_IDLE_TIME);

    std::shared_ptr<ArrayBufferAllocator> allocator =
        ArrayBufferAllocator::Create();
    Isolate::CreateParams params;
    SetIsolateCreateParamsForNode(&params);
    w->UpdateResourceConstraints(&params.constraints);
    params.array_buffer_allocator_shared = allocator;
    Isolate* isolate =
        NewIsolate(&params, &loop_, w->platform_, w->snapshot_data());
    if (isolate == nullptr) {
      // TODO(joyeecheung): maybe this should be kBootstrapFailure instead?
      w->Exit(ExitCode::kGenericUserError,
              ""ERR_WORKER_INI...",3,3,node_worker.cc,node.worker.WorkerThreadData.WorkerThreadData,,false,143,204,WorkerThreadData,,,1,ANY node.worker.WorkerThreadData.WorkerThreadData (Worker*)
254903,METHOD,node.worker.WorkerThreadData,TYPE_DECL,"~WorkerThreadData() {
    Debug(w_, ""Worker %llu dispose isolate"", w_->thread_id_.id);
    Isolate* isolate;
    {
      Mutex::ScopedLock lock(w_->mutex_);
      isolate = w_->isolate_;
      w_->isolate_ = nullptr;
    }

    if (isolate != nullptr) {
      CHECK(!loop_init_failed_);
      bool platform_finished = false;

      isolate_data_.reset();

      w_->platform_->AddIsolateFinishedCallback(isolate, [](void* data) {
        *static_cast<bool*>(data) = true;
      }, &platform_finished);

      // The order of these calls is important; if the Isolate is first disposed
      // and then unregistered, there is a race condition window in which no
      // new Isolate at the same address can successfully be registered with
      // the platform.
      // (Refs: https://github.com/nodejs/node/issues/30846)
      w_->platform_->UnregisterIsolate(isolate);
      isolate->Dispose();

      // Wait until the platform has cleaned up all relevant resources.
      while (!platform_fini...",3,3,node_worker.cc,node.worker.WorkerThreadData.~WorkerThreadData,,false,206,241,~WorkerThreadData,,,2,ANY node.worker.WorkerThreadData.~WorkerThreadData ()
254984,METHOD,node.worker.WorkerThreadData,TYPE_DECL,bool loop_is_usable() const { return !loop_init_failed_; },3,60,node_worker.cc,node.worker.WorkerThreadData.loop_is_usable,,false,243,243,loop_is_usable,,,3,bool node.worker.WorkerThreadData.loop_is_usable ()
254997,METHOD,<empty>,<empty>,<empty>,1,,node_worker.cc,node.worker.WorkerThreadData:<clinit>,,false,141,,<clinit>,,,10,
255007,METHOD,node_worker.cc:<global>,TYPE_DECL,"size_t Worker::NearHeapLimit(void* data, size_t current_heap_limit,
                             size_t initial_heap_limit) {
  Worker* worker = static_cast<Worker*>(data);
  // Give the current GC some extra leeway to let it finish rather than
  // crash hard. We are not going to perform further allocations anyway.
  constexpr size_t kExtraHeapAllowance = 16 * 1024 * 1024;
  size_t new_limit = current_heap_limit + kExtraHeapAllowance;
  Environment* env = worker->env();
  if (env != nullptr) {
    DCHECK(!env->is_in_heapsnapshot_heap_limit_callback());
    Debug(env,
          DebugCategory::DIAGNOSTICS,
          ""Throwing ERR_WORKER_OUT_OF_MEMORY, ""
          ""new_limit=%"" PRIu64 ""\n"",
          static_cast<uint64_t>(new_limit));
  }
  // TODO(joyeecheung): maybe this should be kV8FatalError instead?
  worker->Exit(ExitCode::kGenericUserError,
               ""ERR_WORKER_OUT_OF_MEMORY"",
               ""JS heap out of memory"");
  return new_limit;
}",1,1,node_worker.cc,node.worker.Worker.NearHeapLimit,,false,254,275,NearHeapLimit,,,7,"size_t node.worker.Worker.NearHeapLimit (void*,size_t,size_t)"
255064,METHOD,node_worker.cc:<global>,TYPE_DECL,"void Worker::Run() {
  std::string trace_name = ""[worker "" + std::to_string(thread_id_.id) + ""]"" +
                           (name_ == """" ? """" : "" "" + name_);
  TRACE_EVENT_METADATA1(
      ""__metadata"", ""thread_name"", ""name"", TRACE_STR_COPY(trace_name.c_str()));
  CHECK_NOT_NULL(platform_);

  Debug(this, ""Creating isolate for worker with id %llu"", thread_id_.id);

  WorkerThreadData data(this);
  if (isolate_ == nullptr) return;
  CHECK(data.loop_is_usable());

  Debug(this, ""Starting worker with id %llu"", thread_id_.id);
  {
    Locker locker(isolate_);
    Isolate::Scope isolate_scope(isolate_);
    SealHandleScope outer_seal(isolate_);

    DeleteFnPtr<Environment, FreeEnvironment> env_;
    auto cleanup_env = OnScopeLeave([&]() {
      // TODO(addaleax): This call is harmless but should not be necessary.
      // Figure out why V8 is raising a DCHECK() here without it
      // (in test/parallel/test-async-hooks-worker-asyncfn-terminate-4.js).
      isolate_->CancelTerminateEx...",1,1,node_worker.cc,node.worker.Worker.Run,,false,277,405,Run,,,8,void node.worker.Worker.Run ()
255411,METHOD,node_worker.cc:<global>,TYPE_DECL,"bool Worker::CreateEnvMessagePort(Environment* env) {
  HandleScope handle_scope(isolate_);
  std::unique_ptr<MessagePortData> data;
  {
    Mutex::ScopedLock lock(mutex_);
    data = std::move(child_port_data_);
  }

  // Set up the message channel for receiving messages in the child.
  MessagePort* child_port = MessagePort::New(env,
                                             env->context(),
                                             std::move(data));
  // MessagePort::New() may return nullptr if execution is terminated
  // within it.
  if (child_port != nullptr)
    env->set_message_port(child_port->object(isolate_));

  return child_port;
}",1,1,node_worker.cc,node.worker.Worker.CreateEnvMessagePort,,false,407,425,CreateEnvMessagePort,,,9,bool node.worker.Worker.CreateEnvMessagePort (Environment*)
255470,METHOD,node_worker.cc:<global>,TYPE_DECL,"void Worker::JoinThread() {
  if (!tid_.has_value())
    return;
  CHECK_EQ(uv_thread_join(&tid_.value()), 0);
  tid_.reset();

  env()->remove_sub_worker_context(this);

  {
    HandleScope handle_scope(env()->isolate());
    Context::Scope context_scope(env()->context());

    // Reset the parent port as we're closing it now anyway.
    object()->Set(env()->context(),
                  env()->message_port_string(),
                  Undefined(env()->isolate())).Check();

    Local<Value> args[] = {
        Integer::New(env()->isolate(), static_cast<int>(exit_code_)),
        custom_error_ != nullptr
            ? OneByteString(env()->isolate(), custom_error_).As<Value>()
            : Null(env()->isolate()).As<Value>(),
        !custom_error_str_.empty()
            ? OneByteString(env()->isolate(), custom_error_str_.c_str())
                  .As<Value>()
            : Null(env()->isolate()).As<Value>(),
    };

    MakeCallback(env()->onexit_string(), arraysize(args), args);
  }...",1,1,node_worker.cc,node.worker.Worker.JoinThread,,false,427,462,JoinThread,,,10,void node.worker.Worker.JoinThread ()
255602,METHOD,node_worker.cc:<global>,TYPE_DECL,"Worker::~Worker() {
  Mutex::ScopedLock lock(mutex_);

  CHECK(stopped_);
  CHECK_NULL(env_);
  CHECK(!tid_.has_value());

  Debug(this, ""Worker %llu destroyed"", thread_id_.id);
}",1,1,node_worker.cc,node.worker.Worker.~Worker,,false,464,472,~Worker,,,11,ANY node.worker.Worker.~Worker ()
255623,METHOD,node_worker.cc:<global>,TYPE_DECL,"void Worker::New(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  auto is_internal = args[5];
  CHECK(is_internal->IsBoolean());
  if (is_internal->IsFalse()) {
    THROW_IF_INSUFFICIENT_PERMISSIONS(
        env, permission::PermissionScope::kWorkerThreads, """");
  }
  Isolate* isolate = args.GetIsolate();

  CHECK(args.IsConstructCall());

  if (env->isolate_data()->platform() == nullptr) {
    THROW_ERR_MISSING_PLATFORM_FOR_WORKER(env);
    return;
  }
  CHECK(!env->isolate_data()->is_building_snapshot());

  std::string url;
  std::string name;
  std::shared_ptr<PerIsolateOptions> per_isolate_opts = nullptr;
  std::shared_ptr<KVStore> env_vars = nullptr;

  std::vector<std::string> exec_argv_out;

  // Argument might be a string or URL
  if (!args[0]->IsNullOrUndefined()) {
    Utf8Value value(
        isolate, args[0]->ToString(env->context()).FromMaybe(Local<String>()));
    url.append(value.out(), value.length());
  }

  if (!args...",1,1,node_worker.cc,node.worker.Worker.New,,false,474,645,New,,,12,void node.worker.Worker.New (FunctionCallbackInfo<Value>)
256422,METHOD,node_worker.cc:<global>,TYPE_DECL,"void Worker::StartThread(const FunctionCallbackInfo<Value>& args) {
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
  Mutex::ScopedLock lock(w->mutex_);

  w->stopped_ = false;

  if (w->resource_limits_[kStackSizeMb] > 0) {
    if (w->resource_limits_[kStackSizeMb] * kMB < kStackBufferSize) {
      w->resource_limits_[kStackSizeMb] = kStackBufferSize / kMB;
      w->stack_size_ = kStackBufferSize;
    } else {
      w->stack_size_ =
          static_cast<size_t>(w->resource_limits_[kStackSizeMb] * kMB);
    }
  } else {
    w->resource_limits_[kStackSizeMb] = w->stack_size_ / kMB;
  }

  uv_thread_options_t thread_options;
  thread_options.flags = UV_THREAD_HAS_STACK_SIZE;
  thread_options.stack_size = w->stack_size_;

  uv_thread_t* tid = &w->tid_.emplace();  // Create uv_thread_t instance
  int ret = uv_thread_create_ex(tid, &thread_options, [](void* arg) {
    // XXX: This could become a std::unique_ptr, but that makes at least
    // gcc 6.3 detect undefined behaviour ...",1,1,node_worker.cc,node.worker.Worker.StartThread,,false,647,715,StartThread,,,13,void node.worker.Worker.StartThread (FunctionCallbackInfo<Value>)
256607,METHOD,node_worker.cc:<global>,TYPE_DECL,"void Worker::StopThread(const FunctionCallbackInfo<Value>& args) {
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());

  Debug(w, ""Worker %llu is getting stopped by parent"", w->thread_id_.id);
  w->Exit(ExitCode::kGenericUserError);
}",1,1,node_worker.cc,node.worker.Worker.StopThread,,false,717,723,StopThread,,,14,void node.worker.Worker.StopThread (FunctionCallbackInfo<Value>)
256635,METHOD,node_worker.cc:<global>,TYPE_DECL,"void Worker::Ref(const FunctionCallbackInfo<Value>& args) {
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
  if (!w->has_ref_ && w->tid_.has_value()) {
    w->has_ref_ = true;
    w->env()->add_refs(1);
  }
}",1,1,node_worker.cc,node.worker.Worker.Ref,,false,725,732,Ref,,,15,void node.worker.Worker.Ref (FunctionCallbackInfo<Value>)
256674,METHOD,node_worker.cc:<global>,TYPE_DECL,"void Worker::HasRef(const FunctionCallbackInfo<Value>& args) {
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
  args.GetReturnValue().Set(w->has_ref_);
}",1,1,node_worker.cc,node.worker.Worker.HasRef,,false,734,738,HasRef,,,16,void node.worker.Worker.HasRef (FunctionCallbackInfo<Value>)
256697,METHOD,node_worker.cc:<global>,TYPE_DECL,"void Worker::Unref(const FunctionCallbackInfo<Value>& args) {
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
  if (w->has_ref_ && w->tid_.has_value()) {
    w->has_ref_ = false;
    w->env()->add_refs(-1);
  }
}",1,1,node_worker.cc,node.worker.Worker.Unref,,false,740,747,Unref,,,17,void node.worker.Worker.Unref (FunctionCallbackInfo<Value>)
256736,METHOD,node_worker.cc:<global>,TYPE_DECL,"void Worker::GetResourceLimits(const FunctionCallbackInfo<Value>& args) {
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
  args.GetReturnValue().Set(w->GetResourceLimits(args.GetIsolate()));
}",1,1,node_worker.cc,node.worker.Worker.GetResourceLimits,,false,749,753,GetResourceLimits,,,18,void node.worker.Worker.GetResourceLimits (FunctionCallbackInfo<Value>)
256764,METHOD,node_worker.cc:<global>,TYPE_DECL,"Local<Float64Array> Worker::GetResourceLimits(Isolate* isolate) const {
  Local<ArrayBuffer> ab = ArrayBuffer::New(isolate, sizeof(resource_limits_));

  memcpy(ab->Data(), resource_limits_, sizeof(resource_limits_));
  return Float64Array::New(ab, 0, kTotalResourceLimitCount);
}",1,1,node_worker.cc,node.worker.Worker.GetResourceLimits,,false,755,760,GetResourceLimits,,,19,Local<Float64Array> node.worker.Worker.GetResourceLimits (Isolate*)
256798,METHOD,node_worker.cc:<global>,TYPE_DECL,"void Worker::Exit(ExitCode code,
                  const char* error_code,
                  const char* error_message) {
  Mutex::ScopedLock lock(mutex_);
  Debug(this,
        ""Worker %llu called Exit(%d, %s, %s)"",
        thread_id_.id,
        static_cast<int>(code),
        error_code,
        error_message);

  if (error_code != nullptr) {
    custom_error_ = error_code;
    custom_error_str_ = error_message;
  }

  if (env_ != nullptr) {
    exit_code_ = code;
    Stop(env_);
  } else {
    stopped_ = true;
  }
}",1,1,node_worker.cc,node.worker.Worker.Exit,,false,762,784,Exit,,,20,"void node.worker.Worker.Exit (ExitCode,char*,char*)"
256844,METHOD,node_worker.cc:<global>,TYPE_DECL,"bool Worker::IsNotIndicativeOfMemoryLeakAtExit() const {
  // Worker objects always stay alive as long as the child thread, regardless
  // of whether they are being referenced in the parent thread.
  return true;
}",1,1,node_worker.cc,node.worker.Worker.IsNotIndicativeOfMemoryLeakAtExit,,false,786,790,IsNotIndicativeOfMemoryLeakAtExit,,,21,bool node.worker.Worker.IsNotIndicativeOfMemoryLeakAtExit ()
256851,METHOD,node.worker.WorkerHeapSnapshotTaker,TYPE_DECL,"WorkerHeapSnapshotTaker(Environment* env, Local<Object> obj)
    : AsyncWrap(env, obj, AsyncWrap::PROVIDER_WORKERHEAPSNAPSHOT) {}",3,68,node_worker.cc,node.worker.WorkerHeapSnapshotTaker.WorkerHeapSnapshotTaker,,false,794,795,WorkerHeapSnapshotTaker,,,1,"ANY node.worker.WorkerHeapSnapshotTaker.WorkerHeapSnapshotTaker (Environment*,Local<Object>)"
256858,METHOD,node_worker.cc:<global>,TYPE_DECL,"void Worker::TakeHeapSnapshot(const FunctionCallbackInfo<Value>& args) {
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
  CHECK_EQ(args.Length(), 1);
  auto options = heap::GetHeapSnapshotOptions(args[0]);

  Debug(w, ""Worker %llu taking heap snapshot"", w->thread_id_.id);

  Environment* env = w->env();
  AsyncHooks::DefaultTriggerAsyncIdScope trigger_id_scope(w);
  Local<Object> wrap;
  if (!env->worker_heap_snapshot_taker_template()
      ->NewInstance(env->context()).ToLocal(&wrap)) {
    return;
  }

  // The created WorkerHeapSnapshotTaker is an object owned by main
  // thread's Isolate, it can not be accessed by worker thread
  std::unique_ptr<BaseObjectPtr<WorkerHeapSnapshotTaker>> taker =
      std::make_unique<BaseObjectPtr<WorkerHeapSnapshotTaker>>(
          MakeDetachedBaseObject<WorkerHeapSnapshotTaker>(env, wrap));

  // Interrupt the worker thread and take a snapshot, then schedule a call
  // on the parent thread that turns that snapshot into a readable st...",1,1,node_worker.cc,node.worker.Worker.TakeHeapSnapshot,,false,802,860,TakeHeapSnapshot,,,23,void node.worker.Worker.TakeHeapSnapshot (FunctionCallbackInfo<Value>)
256983,METHOD,node_worker.cc:<global>,TYPE_DECL,"void Worker::LoopIdleTime(const FunctionCallbackInfo<Value>& args) {
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());

  Mutex::ScopedLock lock(w->mutex_);
  // Using w->is_stopped() here leads to a deadlock, and checking is_stopped()
  // before locking the mutex is a race condition. So manually do the same
  // check.
  if (w->stopped_ || w->env_ == nullptr)
    return args.GetReturnValue().Set(-1);

  uint64_t idle_time = uv_metrics_idle_time(w->env_->event_loop());
  args.GetReturnValue().Set(1.0 * idle_time / 1e6);
}",1,1,node_worker.cc,node.worker.Worker.LoopIdleTime,,false,862,875,LoopIdleTime,,,24,void node.worker.Worker.LoopIdleTime (FunctionCallbackInfo<Value>)
257044,METHOD,node_worker.cc:<global>,TYPE_DECL,"void Worker::LoopStartTime(const FunctionCallbackInfo<Value>& args) {
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());

  Mutex::ScopedLock lock(w->mutex_);
  // Using w->is_stopped() here leads to a deadlock, and checking is_stopped()
  // before locking the mutex is a race condition. So manually do the same
  // check.
  if (w->stopped_ || w->env_ == nullptr)
    return args.GetReturnValue().Set(-1);

  double loop_start_time = w->env_->performance_state()->milestones[
      node::performance::NODE_PERFORMANCE_MILESTONE_LOOP_START];
  CHECK_GE(loop_start_time, 0);
  args.GetReturnValue().Set(loop_start_time / 1e6);
}",1,1,node_worker.cc,node.worker.Worker.LoopStartTime,,false,877,892,LoopStartTime,,,25,void node.worker.Worker.LoopStartTime (FunctionCallbackInfo<Value>)
257114,METHOD,node_worker.cc:<global>,TYPE_DECL,"void GetEnvMessagePort(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Local<Object> port = env->message_port();
  CHECK_IMPLIES(!env->is_main_thread(), !port.IsEmpty());
  if (!port.IsEmpty()) {
    CHECK_EQ(port->GetCreationContext().ToLocalChecked()->GetIsolate(),
             args.GetIsolate());
    args.GetReturnValue().Set(port);
  }
}",1,1,node_worker.cc,node.worker.anonymous_namespace_1.GetEnvMessagePort,,false,898,907,GetEnvMessagePort,,,1,void node.worker.anonymous_namespace_1.GetEnvMessagePort (FunctionCallbackInfo<Value>)
257178,METHOD,node_worker.cc:<global>,TYPE_DECL,"void CreateWorkerPerIsolateProperties(IsolateData* isolate_data,
                                      Local<ObjectTemplate> target) {
  Isolate* isolate = isolate_data->isolate();

  {
    Local<FunctionTemplate> w = NewFunctionTemplate(isolate, Worker::New);

    w->InstanceTemplate()->SetInternalFieldCount(
        Worker::kInternalFieldCount);
    w->Inherit(AsyncWrap::GetConstructorTemplate(isolate_data));

    SetProtoMethod(isolate, w, ""startThread"", Worker::StartThread);
    SetProtoMethod(isolate, w, ""stopThread"", Worker::StopThread);
    SetProtoMethod(isolate, w, ""hasRef"", Worker::HasRef);
    SetProtoMethod(isolate, w, ""ref"", Worker::Ref);
    SetProtoMethod(isolate, w, ""unref"", Worker::Unref);
    SetProtoMethod(isolate, w, ""getResourceLimits"", Worker::GetResourceLimits);
    SetProtoMethod(isolate, w, ""takeHeapSnapshot"", Worker::TakeHeapSnapshot);
    SetProtoMethod(isolate, w, ""loopIdleTime"", Worker::LoopIdleTime);
    SetProtoMethod(isolate, w, ""loopStartTime"", Worke...",1,1,node_worker.cc,node.worker.anonymous_namespace_2.CreateWorkerPerIsolateProperties,,false,909,948,CreateWorkerPerIsolateProperties,,,2,"void node.worker.anonymous_namespace_2.CreateWorkerPerIsolateProperties (IsolateData*,Local<ObjectTemplate>)"
257346,METHOD,node_worker.cc:<global>,TYPE_DECL,"void CreateWorkerPerContextProperties(Local<Object> target,
                                      Local<Value> unused,
                                      Local<Context> context,
                                      void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  target
      ->Set(env->context(),
            env->thread_id_string(),
            Number::New(isolate, static_cast<double>(env->thread_id())))
      .Check();

  target
      ->Set(env->context(),
            FIXED_ONE_BYTE_STRING(isolate, ""isMainThread""),
            Boolean::New(isolate, env->is_main_thread()))
      .Check();

  target
      ->Set(env->context(),
            FIXED_ONE_BYTE_STRING(isolate, ""ownsProcessState""),
            Boolean::New(isolate, env->owns_process_state()))
      .Check();

  if (!env->is_main_thread()) {
    target
        ->Set(env->context(),
              FIXED_ONE_BYTE_STRING(isolate, ""resourceLimits""),
              env-...",1,2,node_worker.cc,node.worker.anonymous_namespace_4.CreateWorkerPerContextProperties,,false,950,988,CreateWorkerPerContextProperties,,,3,"void node.worker.anonymous_namespace_4.CreateWorkerPerContextProperties (Local<Object>,Local<Value>,Local<Context>,void*)"
257965,METHOD,node_worker.cc:<global>,TYPE_DECL,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(GetEnvMessagePort);
  registry->Register(Worker::New);
  registry->Register(Worker::StartThread);
  registry->Register(Worker::StopThread);
  registry->Register(Worker::HasRef);
  registry->Register(Worker::Ref);
  registry->Register(Worker::Unref);
  registry->Register(Worker::GetResourceLimits);
  registry->Register(Worker::TakeHeapSnapshot);
  registry->Register(Worker::LoopIdleTime);
  registry->Register(Worker::LoopStartTime);
}",1,1,node_worker.cc,node.worker.anonymous_namespace_5.RegisterExternalReferences,,false,990,1002,RegisterExternalReferences,,,4,void node.worker.anonymous_namespace_5.RegisterExternalReferences (ExternalReferenceRegistry*)
258059,METHOD,node_worker.hpp:<global>,TYPE_DECL,<global>,1,29,node_worker.hpp,node_worker.hpp:<global>,,false,1,151,<global>,,,1,
258062,METHOD,node.anonymous_namespace_48.CompressionStream,TYPE_DECL,[&]() { Unref(); },40,57,node_zlib.cc,node.anonymous_namespace_73.CompressionStream.AfterThreadPoolWork.<lambda>0,,false,405,405,<lambda>0,,,1,ANY node.anonymous_namespace_73.CompressionStream.AfterThreadPoolWork.<lambda>0 ()
258105,METHOD,node_zlib.cc:<global>,TYPE_DECL,<global>,1,1,node_zlib.cc,node_zlib.cc:<global>,,false,1,1434,<global>,,,1,
258109,METHOD,node_zlib.cc:<global>,TYPE_DECL,"inline const char* ZlibStrerror(int err) {
#define V(code) if (err == code) return #code;
  ZLIB_ERROR_CODES(V)
#undef V
  return ""Z_UNKNOWN_ERROR"";
}",1,2,node_zlib.cc,node.anonymous_namespace_1.ZlibStrerror,,false,90,95,ZlibStrerror,,,1,const char* node.anonymous_namespace_1.ZlibStrerror (int)
258201,METHOD,node.anonymous_namespace_3.CompressionError,TYPE_DECL,"CompressionError(const char* message, const char* code, int err)
      : message(message),
        code(code),
        err(err) {
    CHECK_NOT_NULL(message);
  }",3,3,node_zlib.cc,node.anonymous_namespace_4.CompressionError.CompressionError,,false,114,119,CompressionError,,,1,"ANY node.anonymous_namespace_4.CompressionError.CompressionError (char*,char*,int)"
258210,METHOD,node.anonymous_namespace_3.CompressionError,TYPE_DECL,CompressionError() = default;,3,31,node_zlib.cc,node.anonymous_namespace_5.CompressionError.CompressionError,,false,121,121,CompressionError,,,2,ANY node.anonymous_namespace_5.CompressionError.CompressionError ()
258217,METHOD,node.anonymous_namespace_3.CompressionError,TYPE_DECL,inline bool IsError() const { return code != nullptr; },3,57,node_zlib.cc,node.anonymous_namespace_6.CompressionError.IsError,,false,127,127,IsError,,,6,bool node.anonymous_namespace_6.CompressionError.IsError ()
258225,METHOD,<empty>,<empty>,<empty>,1,,node_zlib.cc,node.anonymous_namespace_3.CompressionError:<clinit>,,false,113,,<clinit>,,,7,
258239,METHOD,node.anonymous_namespace_7.ZlibContext,TYPE_DECL,ZlibContext() = default;,3,26,node_zlib.cc,node.anonymous_namespace_8.ZlibContext.ZlibContext,,false,132,132,ZlibContext,,,1,ANY node.anonymous_namespace_8.ZlibContext.ZlibContext ()
258243,METHOD,node.anonymous_namespace_7.ZlibContext,TYPE_DECL,void Close();,8,14,node_zlib.cc,node.anonymous_namespace_9.ZlibContext.Close,,false,135,135,Close,,,2,void node.anonymous_namespace_9.ZlibContext.Close ()
258247,METHOD,node.anonymous_namespace_7.ZlibContext,TYPE_DECL,void DoThreadPoolWork();,8,25,node_zlib.cc,node.anonymous_namespace_10.ZlibContext.DoThreadPoolWork,,false,136,136,DoThreadPoolWork,,,3,void node.anonymous_namespace_10.ZlibContext.DoThreadPoolWork ()
258251,METHOD,node.anonymous_namespace_7.ZlibContext,TYPE_DECL,"void SetBuffers(const char* in, uint32_t in_len, char* out, uint32_t out_len);",8,79,node_zlib.cc,node.anonymous_namespace_11.ZlibContext.SetBuffers,,false,137,137,SetBuffers,,,4,"void node.anonymous_namespace_11.ZlibContext.SetBuffers (char*,uint32_t,char*,uint32_t)"
258259,METHOD,node.anonymous_namespace_7.ZlibContext,TYPE_DECL,void SetFlush(int flush);,8,26,node_zlib.cc,node.anonymous_namespace_12.ZlibContext.SetFlush,,false,138,138,SetFlush,,,5,void node.anonymous_namespace_12.ZlibContext.SetFlush (int)
258264,METHOD,node.anonymous_namespace_7.ZlibContext,TYPE_DECL,"void GetAfterWriteOffsets(uint32_t* avail_in, uint32_t* avail_out) const;",8,74,node_zlib.cc,node.anonymous_namespace_13.ZlibContext.GetAfterWriteOffsets,,false,139,139,GetAfterWriteOffsets,,,6,"void node.anonymous_namespace_13.ZlibContext.GetAfterWriteOffsets (uint32_t*,uint32_t*)"
258270,METHOD,node.anonymous_namespace_7.ZlibContext,TYPE_DECL,CompressionError GetErrorInfo() const;,20,39,node_zlib.cc,node.anonymous_namespace_14.ZlibContext.GetErrorInfo,,false,140,140,GetErrorInfo,,,7,CompressionError node.anonymous_namespace_14.ZlibContext.GetErrorInfo ()
258274,METHOD,node.anonymous_namespace_7.ZlibContext,TYPE_DECL,inline void SetMode(node_zlib_mode mode) { mode_ = mode; },3,60,node_zlib.cc,node.anonymous_namespace_15.ZlibContext.SetMode,,false,141,141,SetMode,,,8,void node.anonymous_namespace_15.ZlibContext.SetMode (node_zlib_mode)
258282,METHOD,node.anonymous_namespace_7.ZlibContext,TYPE_DECL,CompressionError ResetStream();,20,32,node_zlib.cc,node.anonymous_namespace_16.ZlibContext.ResetStream,,false,142,142,ResetStream,,,9,CompressionError node.anonymous_namespace_16.ZlibContext.ResetStream ()
258286,METHOD,node.anonymous_namespace_7.ZlibContext,TYPE_DECL,"void Init(int level, int window_bits, int mem_level, int strategy,
            std::vector<unsigned char>&& dictionary);",8,52,node_zlib.cc,node.anonymous_namespace_17.ZlibContext.Init,,false,145,146,Init,,,10,"void node.anonymous_namespace_17.ZlibContext.Init (int,int,int,int,ANY)"
258295,METHOD,node.anonymous_namespace_7.ZlibContext,TYPE_DECL,"void SetAllocationFunctions(alloc_func alloc, free_func free, void* opaque);",8,77,node_zlib.cc,node.anonymous_namespace_18.ZlibContext.SetAllocationFunctions,,false,147,147,SetAllocationFunctions,,,11,"void node.anonymous_namespace_18.ZlibContext.SetAllocationFunctions (alloc_func,free_func,void*)"
258302,METHOD,node.anonymous_namespace_7.ZlibContext,TYPE_DECL,"CompressionError SetParams(int level, int strategy);",20,53,node_zlib.cc,node.anonymous_namespace_19.ZlibContext.SetParams,,false,148,148,SetParams,,,12,"CompressionError node.anonymous_namespace_19.ZlibContext.SetParams (int,int)"
258312,METHOD,node.anonymous_namespace_7.ZlibContext,TYPE_DECL,"void MemoryInfo(MemoryTracker* tracker) const override {
    tracker->TrackField(""dictionary"", dictionary_);
  }",3,3,node_zlib.cc,node.anonymous_namespace_20.ZlibContext.MemoryInfo,,false,153,155,MemoryInfo,,,17,void node.anonymous_namespace_20.ZlibContext.MemoryInfo (MemoryTracker*)
258323,METHOD,node.anonymous_namespace_7.ZlibContext,TYPE_DECL,ZlibContext(const ZlibContext&) = delete;,3,43,node_zlib.cc,node.anonymous_namespace_21.ZlibContext.ZlibContext,,false,157,157,ZlibContext,,,18,ANY node.anonymous_namespace_21.ZlibContext.ZlibContext (ZlibContext)
258328,METHOD,node.anonymous_namespace_7.ZlibContext,TYPE_DECL,ZlibContext& operator=(const ZlibContext&) = delete;,3,54,node_zlib.cc,node.anonymous_namespace_22.ZlibContext.operator =,,false,158,158,operator =,,,19,ZlibContext node.anonymous_namespace_22.ZlibContext.operator = (ZlibContext)
258333,METHOD,node.anonymous_namespace_7.ZlibContext,TYPE_DECL,CompressionError ErrorForMessage(const char* message) const;,20,61,node_zlib.cc,node.anonymous_namespace_23.ZlibContext.ErrorForMessage,,false,161,161,ErrorForMessage,,,20,CompressionError node.anonymous_namespace_23.ZlibContext.ErrorForMessage (char*)
258338,METHOD,node.anonymous_namespace_7.ZlibContext,TYPE_DECL,CompressionError SetDictionary();,20,34,node_zlib.cc,node.anonymous_namespace_24.ZlibContext.SetDictionary,,false,162,162,SetDictionary,,,21,CompressionError node.anonymous_namespace_24.ZlibContext.SetDictionary ()
258342,METHOD,node.anonymous_namespace_7.ZlibContext,TYPE_DECL,bool InitZlib();,8,17,node_zlib.cc,node.anonymous_namespace_25.ZlibContext.InitZlib,,false,163,163,InitZlib,,,22,bool node.anonymous_namespace_25.ZlibContext.InitZlib ()
258358,METHOD,<empty>,<empty>,<empty>,1,,node_zlib.cc,node.anonymous_namespace_7.ZlibContext:<clinit>,,false,130,,<clinit>,,,35,
258390,METHOD,node.anonymous_namespace_26.BrotliContext,TYPE_DECL,BrotliContext() = default;,3,28,node_zlib.cc,node.anonymous_namespace_27.BrotliContext.BrotliContext,,false,184,184,BrotliContext,,,1,ANY node.anonymous_namespace_27.BrotliContext.BrotliContext ()
258394,METHOD,node.anonymous_namespace_26.BrotliContext,TYPE_DECL,"void SetBuffers(const char* in, uint32_t in_len, char* out, uint32_t out_len);",8,79,node_zlib.cc,node.anonymous_namespace_28.BrotliContext.SetBuffers,,false,186,186,SetBuffers,,,2,"void node.anonymous_namespace_28.BrotliContext.SetBuffers (char*,uint32_t,char*,uint32_t)"
258402,METHOD,node.anonymous_namespace_26.BrotliContext,TYPE_DECL,void SetFlush(int flush);,8,26,node_zlib.cc,node.anonymous_namespace_29.BrotliContext.SetFlush,,false,187,187,SetFlush,,,3,void node.anonymous_namespace_29.BrotliContext.SetFlush (int)
258407,METHOD,node.anonymous_namespace_26.BrotliContext,TYPE_DECL,"void GetAfterWriteOffsets(uint32_t* avail_in, uint32_t* avail_out) const;",8,74,node_zlib.cc,node.anonymous_namespace_30.BrotliContext.GetAfterWriteOffsets,,false,188,188,GetAfterWriteOffsets,,,4,"void node.anonymous_namespace_30.BrotliContext.GetAfterWriteOffsets (uint32_t*,uint32_t*)"
258413,METHOD,node.anonymous_namespace_26.BrotliContext,TYPE_DECL,inline void SetMode(node_zlib_mode mode) { mode_ = mode; },3,60,node_zlib.cc,node.anonymous_namespace_31.BrotliContext.SetMode,,false,189,189,SetMode,,,5,void node.anonymous_namespace_31.BrotliContext.SetMode (node_zlib_mode)
258421,METHOD,node.anonymous_namespace_26.BrotliContext,TYPE_DECL,BrotliContext(const BrotliContext&) = delete;,3,47,node_zlib.cc,node.anonymous_namespace_32.BrotliContext.BrotliContext,,false,191,191,BrotliContext,,,6,ANY node.anonymous_namespace_32.BrotliContext.BrotliContext (BrotliContext)
258426,METHOD,node.anonymous_namespace_26.BrotliContext,TYPE_DECL,BrotliContext& operator=(const BrotliContext&) = delete;,3,58,node_zlib.cc,node.anonymous_namespace_33.BrotliContext.operator =,,false,192,192,operator =,,,7,BrotliContext node.anonymous_namespace_33.BrotliContext.operator = (BrotliContext)
258440,METHOD,<empty>,<empty>,<empty>,1,,node_zlib.cc,node.anonymous_namespace_26.BrotliContext:<clinit>,,false,182,,<clinit>,,,17,
258472,METHOD,node.anonymous_namespace_34.BrotliEncoderContext,TYPE_DECL,void Close();,8,14,node_zlib.cc,node.anonymous_namespace_35.BrotliEncoderContext.Close,,false,211,211,Close,,,1,void node.anonymous_namespace_35.BrotliEncoderContext.Close ()
258476,METHOD,node.anonymous_namespace_34.BrotliEncoderContext,TYPE_DECL,void DoThreadPoolWork();,8,25,node_zlib.cc,node.anonymous_namespace_36.BrotliEncoderContext.DoThreadPoolWork,,false,212,212,DoThreadPoolWork,,,2,void node.anonymous_namespace_36.BrotliEncoderContext.DoThreadPoolWork ()
258480,METHOD,node.anonymous_namespace_34.BrotliEncoderContext,TYPE_DECL,"CompressionError Init(brotli_alloc_func alloc,
                        brotli_free_func free,
                        void* opaque);",20,37,node_zlib.cc,node.anonymous_namespace_37.BrotliEncoderContext.Init,,false,213,215,Init,,,3,"CompressionError node.anonymous_namespace_37.BrotliEncoderContext.Init (brotli_alloc_func,brotli_free_func,void*)"
258487,METHOD,node.anonymous_namespace_34.BrotliEncoderContext,TYPE_DECL,CompressionError ResetStream();,20,32,node_zlib.cc,node.anonymous_namespace_38.BrotliEncoderContext.ResetStream,,false,216,216,ResetStream,,,4,CompressionError node.anonymous_namespace_38.BrotliEncoderContext.ResetStream ()
258491,METHOD,node.anonymous_namespace_34.BrotliEncoderContext,TYPE_DECL,"CompressionError SetParams(int key, uint32_t value);",20,53,node_zlib.cc,node.anonymous_namespace_39.BrotliEncoderContext.SetParams,,false,217,217,SetParams,,,5,"CompressionError node.anonymous_namespace_39.BrotliEncoderContext.SetParams (int,uint32_t)"
258497,METHOD,node.anonymous_namespace_34.BrotliEncoderContext,TYPE_DECL,CompressionError GetErrorInfo() const;,20,39,node_zlib.cc,node.anonymous_namespace_40.BrotliEncoderContext.GetErrorInfo,,false,218,218,GetErrorInfo,,,6,CompressionError node.anonymous_namespace_40.BrotliEncoderContext.GetErrorInfo ()
258508,METHOD,node.anonymous_namespace_41.BrotliDecoderContext,TYPE_DECL,void Close();,8,14,node_zlib.cc,node.anonymous_namespace_42.BrotliDecoderContext.Close,,false,231,231,Close,,,1,void node.anonymous_namespace_42.BrotliDecoderContext.Close ()
258512,METHOD,node.anonymous_namespace_41.BrotliDecoderContext,TYPE_DECL,void DoThreadPoolWork();,8,25,node_zlib.cc,node.anonymous_namespace_43.BrotliDecoderContext.DoThreadPoolWork,,false,232,232,DoThreadPoolWork,,,2,void node.anonymous_namespace_43.BrotliDecoderContext.DoThreadPoolWork ()
258516,METHOD,node.anonymous_namespace_41.BrotliDecoderContext,TYPE_DECL,"CompressionError Init(brotli_alloc_func alloc,
                        brotli_free_func free,
                        void* opaque);",20,37,node_zlib.cc,node.anonymous_namespace_44.BrotliDecoderContext.Init,,false,233,235,Init,,,3,"CompressionError node.anonymous_namespace_44.BrotliDecoderContext.Init (brotli_alloc_func,brotli_free_func,void*)"
258523,METHOD,node.anonymous_namespace_41.BrotliDecoderContext,TYPE_DECL,CompressionError ResetStream();,20,32,node_zlib.cc,node.anonymous_namespace_45.BrotliDecoderContext.ResetStream,,false,236,236,ResetStream,,,4,CompressionError node.anonymous_namespace_45.BrotliDecoderContext.ResetStream ()
258527,METHOD,node.anonymous_namespace_41.BrotliDecoderContext,TYPE_DECL,"CompressionError SetParams(int key, uint32_t value);",20,53,node_zlib.cc,node.anonymous_namespace_46.BrotliDecoderContext.SetParams,,false,237,237,SetParams,,,5,"CompressionError node.anonymous_namespace_46.BrotliDecoderContext.SetParams (int,uint32_t)"
258533,METHOD,node.anonymous_namespace_41.BrotliDecoderContext,TYPE_DECL,CompressionError GetErrorInfo() const;,20,39,node_zlib.cc,node.anonymous_namespace_47.BrotliDecoderContext.GetErrorInfo,,false,238,238,GetErrorInfo,,,6,CompressionError node.anonymous_namespace_47.BrotliDecoderContext.GetErrorInfo ()
258545,METHOD,<empty>,<empty>,<empty>,1,,node_zlib.cc,node.anonymous_namespace_41.BrotliDecoderContext:<clinit>,,false,229,,<clinit>,,,15,
258556,METHOD,<empty>,<empty>,<empty>,3,,node_zlib.cc,node.anonymous_namespace_49.CompressionStream.InternalFields:<clinit>,,false,254,,<clinit>,,,4,
258565,METHOD,node.anonymous_namespace_48.CompressionStream,TYPE_DECL,"CompressionStream(Environment* env, Local<Object> wrap)
      : AsyncWrap(env, wrap, AsyncWrap::PROVIDER_ZLIB),
        ThreadPoolWork(env, ""zlib""),
        write_result_(nullptr) {
    MakeWeak();
  }",3,3,node_zlib.cc,node.anonymous_namespace_50.CompressionStream.CompressionStream,,false,260,265,CompressionStream,,,2,"ANY node.anonymous_namespace_50.CompressionStream.CompressionStream (Environment*,Local<Object>)"
258572,METHOD,node.anonymous_namespace_48.CompressionStream,TYPE_DECL,"~CompressionStream() override {
    CHECK(!write_in_progress_);
    Close();
    CHECK_EQ(zlib_memory_, 0);
    CHECK_EQ(unreported_allocations_, 0);
  }",3,3,node_zlib.cc,node.anonymous_namespace_51.CompressionStream.~CompressionStream,,false,267,272,~CompressionStream,,,3,ANY node.anonymous_namespace_51.CompressionStream.~CompressionStream ()
258586,METHOD,node.anonymous_namespace_48.CompressionStream,TYPE_DECL,"void Close() {
    if (write_in_progress_) {
      pending_close_ = true;
      return;
    }

    pending_close_ = false;
    closed_ = true;
    CHECK(init_done_ && ""close before init"");

    AllocScope alloc_scope(this);
    ctx_.Close();
  }",3,3,node_zlib.cc,node.anonymous_namespace_53.CompressionStream.Close,,false,274,286,Close,,,4,void node.anonymous_namespace_53.CompressionStream.Close ()
258614,METHOD,node.anonymous_namespace_48.CompressionStream,TYPE_DECL,"static void Close(const FunctionCallbackInfo<Value>& args) {
    CompressionStream* ctx;
    ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());
    ctx->Close();
  }",3,3,node_zlib.cc,node.anonymous_namespace_54.CompressionStream.Close,,false,289,293,Close,,,5,void node.anonymous_namespace_54.CompressionStream.Close (FunctionCallbackInfo<Value>)
258631,METHOD,node.anonymous_namespace_48.CompressionStream,TYPE_DECL,"static void Write(const FunctionCallbackInfo<Value>& args) {
    Environment* env = Environment::GetCurrent(args);
    Local<Context> context = env->context();
    CHECK_EQ(args.Length(), 7);

    uint32_t in_off, in_len, out_off, out_len, flush;
    const char* in;
    char* out;

    CHECK_EQ(false, args[0]->IsUndefined() && ""must provide flush value"");
    if (!args[0]->Uint32Value(context).To(&flush)) return;

    if (flush != Z_NO_FLUSH &&
        flush != Z_PARTIAL_FLUSH &&
        flush != Z_SYNC_FLUSH &&
        flush != Z_FULL_FLUSH &&
        flush != Z_FINISH &&
        flush != Z_BLOCK) {
      UNREACHABLE(""Invalid flush value"");
    }

    if (args[1]->IsNull()) {
      // just a flush
      in = nullptr;
      in_len = 0;
      in_off = 0;
    } else {
      CHECK(Buffer::HasInstance(args[1]));
      Local<Object> in_buf = args[1].As<Object>();
      if (!args[2]->Uint32Value(context).To(&in_off)) return;
      if (!args[3]->Uint32Value(context).To(&in_len)) return;

 ...",3,3,node_zlib.cc,node.anonymous_namespace_55.CompressionStream.Write,,false,298,345,Write,,,6,void node.anonymous_namespace_55.CompressionStream.Write<bool> (FunctionCallbackInfo<Value>)
258902,METHOD,node.anonymous_namespace_48.CompressionStream,TYPE_DECL,"void Write(uint32_t flush,
             const char* in, uint32_t in_len,
             char* out, uint32_t out_len) {
    AllocScope alloc_scope(this);

    CHECK(init_done_ && ""write before init"");
    CHECK(!closed_ && ""already finalized"");

    CHECK_EQ(false, write_in_progress_);
    CHECK_EQ(false, pending_close_);
    write_in_progress_ = true;
    Ref();

    ctx_.SetBuffers(in, in_len, out, out_len);
    ctx_.SetFlush(flush);

    if constexpr (!async) {
      // sync version
      AsyncWrap::env()->PrintSyncTrace();
      DoThreadPoolWork();
      if (CheckError()) {
        UpdateWriteResult();
        write_in_progress_ = false;
      }
      Unref();
      return;
    }

    // async version
    ScheduleWork();
  }",3,3,node_zlib.cc,node.anonymous_namespace_62.CompressionStream.Write,,false,348,378,Write,,,7,"void node.anonymous_namespace_62.CompressionStream.Write<bool> (uint32_t,char*,uint32_t,char*,uint32_t)"
258968,METHOD,node.anonymous_namespace_48.CompressionStream,TYPE_DECL,"void UpdateWriteResult() {
    ctx_.GetAfterWriteOffsets(&write_result_[1], &write_result_[0]);
  }",3,3,node_zlib.cc,node.anonymous_namespace_68.CompressionStream.UpdateWriteResult,,false,380,382,UpdateWriteResult,,,8,void node.anonymous_namespace_68.CompressionStream.UpdateWriteResult ()
258984,METHOD,node.anonymous_namespace_48.CompressionStream,TYPE_DECL,"void DoThreadPoolWork() override {
    ctx_.DoThreadPoolWork();
  }",3,3,node_zlib.cc,node.anonymous_namespace_69.CompressionStream.DoThreadPoolWork,,false,388,390,DoThreadPoolWork,,,9,void node.anonymous_namespace_69.CompressionStream.DoThreadPoolWork ()
258992,METHOD,node.anonymous_namespace_48.CompressionStream,TYPE_DECL,"bool CheckError() {
    const CompressionError err = ctx_.GetErrorInfo();
    if (!err.IsError()) return true;
    EmitError(err);
    return false;
  }",3,3,node_zlib.cc,node.anonymous_namespace_70.CompressionStream.CheckError,,false,393,398,CheckError,,,10,bool node.anonymous_namespace_70.CompressionStream.CheckError ()
259016,METHOD,node.anonymous_namespace_48.CompressionStream,TYPE_DECL,"void AfterThreadPoolWork(int status) override {
    DCHECK(init_done_);
    AllocScope alloc_scope(this);
    auto on_scope_leave = OnScopeLeave([&]() { Unref(); });

    write_in_progress_ = false;

    if (status == UV_ECANCELED) {
      Close();
      return;
    }

    CHECK_EQ(status, 0);

    Environment* env = AsyncWrap::env();
    HandleScope handle_scope(env->isolate());
    Context::Scope context_scope(env->context());

    if (!CheckError())
      return;

    UpdateWriteResult();

    // call the write() cb
    Local<Value> cb = object()->GetInternalField(kWriteJSCallback);
    MakeCallback(cb.As<Function>(), 0, nullptr);

    if (pending_close_)
      Close();
  }",3,3,node_zlib.cc,node.anonymous_namespace_72.CompressionStream.AfterThreadPoolWork,,false,402,431,AfterThreadPoolWork,,,11,void node.anonymous_namespace_72.CompressionStream.AfterThreadPoolWork (int)
259091,METHOD,node.anonymous_namespace_48.CompressionStream,TYPE_DECL,"void EmitError(const CompressionError& err) {
    Environment* env = AsyncWrap::env();
    // If you hit this assertion, you forgot to enter the v8::Context first.
    CHECK_EQ(env->context(), env->isolate()->GetCurrentContext());

    HandleScope scope(env->isolate());
    Local<Value> args[] = {
      OneByteString(env->isolate(), err.message),
      Integer::New(env->isolate(), err.err),
      OneByteString(env->isolate(), err.code)
    };
    MakeCallback(env->onerror_string(), arraysize(args), args);

    // no hope of rescue.
    write_in_progress_ = false;
    if (pending_close_)
      Close();
  }",3,3,node_zlib.cc,node.anonymous_namespace_79.CompressionStream.EmitError,,false,434,451,EmitError,,,12,void node.anonymous_namespace_79.CompressionStream.EmitError (CompressionError)
259167,METHOD,node.anonymous_namespace_48.CompressionStream,TYPE_DECL,"static void Reset(const FunctionCallbackInfo<Value> &args) {
    CompressionStream* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

    AllocScope alloc_scope(wrap);
    const CompressionError err = wrap->context()->ResetStream();
    if (err.IsError())
      wrap->EmitError(err);
  }",3,3,node_zlib.cc,node.anonymous_namespace_81.CompressionStream.Reset,,false,453,461,Reset,,,13,void node.anonymous_namespace_81.CompressionStream.Reset (FunctionCallbackInfo<Value>)
259204,METHOD,node.anonymous_namespace_48.CompressionStream,TYPE_DECL,"void MemoryInfo(MemoryTracker* tracker) const override {
    tracker->TrackField(""compression context"", ctx_);
    tracker->TrackFieldWithSize(""zlib_memory"",
                                zlib_memory_ + unreported_allocations_);
  }",3,3,node_zlib.cc,node.anonymous_namespace_82.CompressionStream.MemoryInfo,,false,463,467,MemoryInfo,,,14,void node.anonymous_namespace_82.CompressionStream.MemoryInfo (MemoryTracker*)
259223,METHOD,node.anonymous_namespace_48.CompressionStream,TYPE_DECL,CompressionContext* context() { return &ctx_; },3,49,node_zlib.cc,node.anonymous_namespace_83.CompressionStream.context,,false,470,470,context,,,15,CompressionContext node.anonymous_namespace_83.CompressionStream.context ()
259230,METHOD,node.anonymous_namespace_48.CompressionStream,TYPE_DECL,"void InitStream(uint32_t* write_result, Local<Function> write_js_callback) {
    write_result_ = write_result;
    object()->SetInternalField(kWriteJSCallback, write_js_callback);
    init_done_ = true;
  }",3,3,node_zlib.cc,node.anonymous_namespace_84.CompressionStream.InitStream,,false,472,476,InitStream,,,16,"void node.anonymous_namespace_84.CompressionStream.InitStream (uint32_t*,Local<Function>)"
259248,METHOD,node.anonymous_namespace_48.CompressionStream,TYPE_DECL,"static void* AllocForZlib(void* data, uInt items, uInt size) {
    size_t real_size =
        MultiplyWithOverflowCheck(static_cast<size_t>(items),
                                  static_cast<size_t>(size));
    return AllocForBrotli(data, real_size);
  }",3,3,node_zlib.cc,node.anonymous_namespace_85.CompressionStream.AllocForZlib,,false,484,489,AllocForZlib,,,17,"void* node.anonymous_namespace_85.CompressionStream.AllocForZlib (void*,uInt,uInt)"
259269,METHOD,node.anonymous_namespace_48.CompressionStream,TYPE_DECL,"static void* AllocForBrotli(void* data, size_t size) {
    size += sizeof(size_t);
    CompressionStream* ctx = static_cast<CompressionStream*>(data);
    char* memory = UncheckedMalloc(size);
    if (UNLIKELY(memory == nullptr)) return nullptr;
    *reinterpret_cast<size_t*>(memory) = size;
    ctx->unreported_allocations_.fetch_add(size,
                                           std::memory_order_relaxed);
    return memory + sizeof(size_t);
  }",3,3,node_zlib.cc,node.anonymous_namespace_88.CompressionStream.AllocForBrotli,,false,491,500,AllocForBrotli,,,18,"void* node.anonymous_namespace_88.CompressionStream.AllocForBrotli (void*,size_t)"
259319,METHOD,node.anonymous_namespace_48.CompressionStream,TYPE_DECL,"static void FreeForZlib(void* data, void* pointer) {
    if (UNLIKELY(pointer == nullptr)) return;
    CompressionStream* ctx = static_cast<CompressionStream*>(data);
    char* real_pointer = static_cast<char*>(pointer) - sizeof(size_t);
    size_t real_size = *reinterpret_cast<size_t*>(real_pointer);
    ctx->unreported_allocations_.fetch_sub(real_size,
                                           std::memory_order_relaxed);
    free(real_pointer);
  }",3,3,node_zlib.cc,node.anonymous_namespace_89.CompressionStream.FreeForZlib,,false,502,510,FreeForZlib,,,19,"void node.anonymous_namespace_89.CompressionStream.FreeForZlib (void*,void*)"
259366,METHOD,node.anonymous_namespace_48.CompressionStream,TYPE_DECL,"void AdjustAmountOfExternalAllocatedMemory() {
    ssize_t report =
        unreported_allocations_.exchange(0, std::memory_order_relaxed);
    if (report == 0) return;
    CHECK_IMPLIES(report < 0, zlib_memory_ >= static_cast<size_t>(-report));
    zlib_memory_ += report;
    AsyncWrap::env()->isolate()->AdjustAmountOfExternalAllocatedMemory(report);
  }",3,3,node_zlib.cc,node.anonymous_namespace_90.CompressionStream.AdjustAmountOfExternalAllocatedMemory,,false,514,521,AdjustAmountOfExternalAllocatedMemory,,,20,void node.anonymous_namespace_90.CompressionStream.AdjustAmountOfExternalAllocatedMemory ()
259412,METHOD,node.anonymous_namespace_91.CompressionStream.AllocScope,TYPE_DECL,explicit AllocScope(CompressionStream* stream) : stream(stream) {},5,70,node_zlib.cc,node.anonymous_namespace_92.CompressionStream.AllocScope.AllocScope,,false,524,524,AllocScope,,,1,ANY node.anonymous_namespace_92.CompressionStream.AllocScope.AllocScope (CompressionStream*)
259417,METHOD,node.anonymous_namespace_91.CompressionStream.AllocScope,TYPE_DECL,~AllocScope() { stream->AdjustAmountOfExternalAllocatedMemory(); },5,70,node_zlib.cc,node.anonymous_namespace_93.CompressionStream.AllocScope.~AllocScope,,false,525,525,~AllocScope,,,2,ANY node.anonymous_namespace_93.CompressionStream.AllocScope.~AllocScope ()
259426,METHOD,node.anonymous_namespace_48.CompressionStream,TYPE_DECL,"void Ref() {
    if (++refs_ == 1) {
      ClearWeak();
    }
  }",3,3,node_zlib.cc,node.anonymous_namespace_94.CompressionStream.Ref,,false,530,534,Ref,,,22,void node.anonymous_namespace_94.CompressionStream.Ref ()
259437,METHOD,node.anonymous_namespace_48.CompressionStream,TYPE_DECL,"void Unref() {
    CHECK_GT(refs_, 0);
    if (--refs_ == 0) {
      MakeWeak();
    }
  }",3,3,node_zlib.cc,node.anonymous_namespace_95.CompressionStream.Unref,,false,536,541,Unref,,,23,void node.anonymous_namespace_95.CompressionStream.Unref ()
259460,METHOD,<empty>,<empty>,<empty>,1,,node_zlib.cc,node.anonymous_namespace_48.CompressionStream:<clinit>,,false,252,,<clinit>,,,33,
259490,METHOD,node.anonymous_namespace_96.ZlibStream,TYPE_DECL,"ZlibStream(Environment* env, Local<Object> wrap, node_zlib_mode mode)
    : CompressionStream(env, wrap) {
    context()->SetMode(mode);
  }",3,3,node_zlib.cc,node.anonymous_namespace_97.ZlibStream.ZlibStream,,false,557,560,ZlibStream,,,1,"ANY node.anonymous_namespace_97.ZlibStream.ZlibStream (Environment*,Local<Object>,node_zlib_mode)"
259502,METHOD,node.anonymous_namespace_96.ZlibStream,TYPE_DECL,"static void New(const FunctionCallbackInfo<Value>& args) {
    Environment* env = Environment::GetCurrent(args);
    CHECK(args[0]->IsInt32());
    node_zlib_mode mode =
        static_cast<node_zlib_mode>(args[0].As<Int32>()->Value());
    new ZlibStream(env, args.This(), mode);
  }",3,3,node_zlib.cc,node.anonymous_namespace_98.ZlibStream.New,,false,562,568,New,,,2,void node.anonymous_namespace_98.ZlibStream.New (FunctionCallbackInfo<Value>)
259544,METHOD,node.anonymous_namespace_96.ZlibStream,TYPE_DECL,"static void Init(const FunctionCallbackInfo<Value>& args) {
    // Refs: https://github.com/nodejs/node/issues/16649
    // Refs: https://github.com/nodejs/node/issues/14161
    if (args.Length() == 5) {
      fprintf(stderr,
          ""WARNING: You are likely using a version of node-tar or npm that ""
          ""is incompatible with this version of Node.js.\nPlease use ""
          ""either the version of npm that is bundled with Node.js, or ""
          ""a version of npm (> 5.5.1 or < 5.4.0) or node-tar (> 4.0.1) ""
          ""that is compatible with Node.js 9 and above.\n"");
    }
    CHECK(args.Length() == 7 &&
      ""init(windowBits, level, memLevel, strategy, writeResult, writeCallback,""
      "" dictionary)"");

    ZlibStream* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

    Local<Context> context = args.GetIsolate()->GetCurrentContext();

    // windowBits is special. On the compression side, 0 is an invalid value.
    // But on the decompression side, a value of 0 fo...",3,3,node_zlib.cc,node.anonymous_namespace_99.ZlibStream.Init,,false,571,630,Init,,,3,void node.anonymous_namespace_99.ZlibStream.Init (FunctionCallbackInfo<Value>)
259790,METHOD,node.anonymous_namespace_96.ZlibStream,TYPE_DECL,"static void Params(const FunctionCallbackInfo<Value>& args) {
    CHECK(args.Length() == 2 && ""params(level, strategy)"");
    ZlibStream* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
    Local<Context> context = args.GetIsolate()->GetCurrentContext();
    int level;
    if (!args[0]->Int32Value(context).To(&level)) return;
    int strategy;
    if (!args[1]->Int32Value(context).To(&strategy)) return;

    AllocScope alloc_scope(wrap);
    const CompressionError err = wrap->context()->SetParams(level, strategy);
    if (err.IsError())
      wrap->EmitError(err);
  }",3,3,node_zlib.cc,node.anonymous_namespace_100.ZlibStream.Params,,false,632,646,Params,,,4,void node.anonymous_namespace_100.ZlibStream.Params (FunctionCallbackInfo<Value>)
259890,METHOD,node.anonymous_namespace_101.BrotliCompressionStream,TYPE_DECL,"BrotliCompressionStream(Environment* env,
                          Local<Object> wrap,
                          node_zlib_mode mode)
    : CompressionStream<CompressionContext>(env, wrap) {
    context()->SetMode(mode);
  }",3,3,node_zlib.cc,node.anonymous_namespace_102.BrotliCompressionStream.BrotliCompressionStream,,false,656,661,BrotliCompressionStream,,,1,"ANY node.anonymous_namespace_102.BrotliCompressionStream.BrotliCompressionStream (Environment*,Local<Object>,node_zlib_mode)"
259902,METHOD,node.anonymous_namespace_101.BrotliCompressionStream,TYPE_DECL,"inline CompressionContext* context() {
    return this->CompressionStream<CompressionContext>::context();
  }",3,3,node_zlib.cc,node.anonymous_namespace_104.BrotliCompressionStream.context,,false,663,665,context,,,2,CompressionContext node.anonymous_namespace_104.BrotliCompressionStream.context ()
259912,METHOD,node.anonymous_namespace_101.BrotliCompressionStream,TYPE_DECL,"static void New(const FunctionCallbackInfo<Value>& args) {
    Environment* env = Environment::GetCurrent(args);
    CHECK(args[0]->IsInt32());
    node_zlib_mode mode =
        static_cast<node_zlib_mode>(args[0].As<Int32>()->Value());
    new BrotliCompressionStream(env, args.This(), mode);
  }",3,3,node_zlib.cc,node.anonymous_namespace_105.BrotliCompressionStream.New,,false,668,674,New,,,4,void node.anonymous_namespace_105.BrotliCompressionStream.New (FunctionCallbackInfo<Value>)
259954,METHOD,node.anonymous_namespace_101.BrotliCompressionStream,TYPE_DECL,"static void Init(const FunctionCallbackInfo<Value>& args) {
    BrotliCompressionStream* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
    CHECK(args.Length() == 3 && ""init(params, writeResult, writeCallback)"");

    CHECK(args[1]->IsUint32Array());
    uint32_t* write_result = reinterpret_cast<uint32_t*>(Buffer::Data(args[1]));

    CHECK(args[2]->IsFunction());
    Local<Function> write_js_callback = args[2].As<Function>();
    wrap->InitStream(write_result, write_js_callback);

    AllocScope alloc_scope(wrap);
    CompressionError err =
        wrap->context()->Init(
          CompressionStream<CompressionContext>::AllocForBrotli,
          CompressionStream<CompressionContext>::FreeForZlib,
          static_cast<CompressionStream<CompressionContext>*>(wrap));
    if (err.IsError()) {
      wrap->EmitError(err);
      args.GetReturnValue().Set(false);
      return;
    }

    CHECK(args[0]->IsUint32Array());
    const uint32_t* data = reinterpret_cast<uint32_t*>(Buffe...",3,3,node_zlib.cc,node.anonymous_namespace_106.BrotliCompressionStream.Init,,false,676,716,Init,,,5,void node.anonymous_namespace_106.BrotliCompressionStream.Init (FunctionCallbackInfo<Value>)
260161,METHOD,node.anonymous_namespace_101.BrotliCompressionStream,TYPE_DECL,"static void Params(const FunctionCallbackInfo<Value>& args) {
    // Currently a no-op, and not accessed from JS land.
    // At some point Brotli may support changing parameters on the fly,
    // in which case we can implement this and a JS equivalent similar to
    // the zlib Params() function.
  }",3,3,node_zlib.cc,node.anonymous_namespace_107.BrotliCompressionStream.Params,,false,718,723,Params,,,6,void node.anonymous_namespace_107.BrotliCompressionStream.Params (FunctionCallbackInfo<Value>)
260172,METHOD,node_zlib.cc:<global>,TYPE_DECL,"void ZlibContext::Close() {
  {
    Mutex::ScopedLock lock(mutex_);
    if (!zlib_init_done_) {
      dictionary_.clear();
      mode_ = NONE;
      return;
    }
  }

  CHECK_LE(mode_, UNZIP);

  int status = Z_OK;
  if (mode_ == DEFLATE || mode_ == GZIP || mode_ == DEFLATERAW) {
    status = deflateEnd(&strm_);
  } else if (mode_ == INFLATE || mode_ == GUNZIP || mode_ == INFLATERAW ||
             mode_ == UNZIP) {
    status = inflateEnd(&strm_);
  }

  CHECK(status == Z_OK || status == Z_DATA_ERROR);
  mode_ = NONE;

  dictionary_.clear();
}",1,1,node_zlib.cc,node.anonymous_namespace_108.ZlibContext.Close,,false,732,756,Close,,,17,void node.anonymous_namespace_108.ZlibContext.Close ()
260256,METHOD,node_zlib.cc:<global>,TYPE_DECL,"void ZlibContext::DoThreadPoolWork() {
  bool first_init_call = InitZlib();
  if (first_init_call && err_ != Z_OK) {
    return;
  }

  const Bytef* next_expected_header_byte = nullptr;

  // If the avail_out is left at 0, then it means that it ran out
  // of room.  If there was avail_out left over, then it means
  // that all of the input was consumed.
  switch (mode_) {
    case DEFLATE:
    case GZIP:
    case DEFLATERAW:
      err_ = deflate(&strm_, flush_);
      break;
    case UNZIP:
      if (strm_.avail_in > 0) {
        next_expected_header_byte = strm_.next_in;
      }

      switch (gzip_id_bytes_read_) {
        case 0:
          if (next_expected_header_byte == nullptr) {
            break;
          }

          if (*next_expected_header_byte == GZIP_HEADER_ID1) {
            gzip_id_bytes_read_ = 1;
            next_expected_header_byte++;

            if (strm_.avail_in == 1) {
              // The only available byte was already read.
              break;
        ...",1,1,node_zlib.cc,node.anonymous_namespace_109.ZlibContext.DoThreadPoolWork,,false,759,862,DoThreadPoolWork,,,18,void node.anonymous_namespace_109.ZlibContext.DoThreadPoolWork ()
260465,METHOD,node_zlib.cc:<global>,TYPE_DECL,"void ZlibContext::SetBuffers(const char* in, uint32_t in_len,
                             char* out, uint32_t out_len) {
  strm_.avail_in = in_len;
  strm_.next_in = const_cast<Bytef*>(reinterpret_cast<const Bytef*>(in));
  strm_.avail_out = out_len;
  strm_.next_out = reinterpret_cast<Bytef*>(out);
}",1,1,node_zlib.cc,node.anonymous_namespace_110.ZlibContext.SetBuffers,,false,865,871,SetBuffers,,,19,"void node.anonymous_namespace_110.ZlibContext.SetBuffers (char*,uint32_t,char*,uint32_t)"
260499,METHOD,node_zlib.cc:<global>,TYPE_DECL,"void ZlibContext::SetFlush(int flush) {
  flush_ = flush;
}",1,1,node_zlib.cc,node.anonymous_namespace_111.ZlibContext.SetFlush,,false,874,876,SetFlush,,,20,void node.anonymous_namespace_111.ZlibContext.SetFlush (int)
260507,METHOD,node_zlib.cc:<global>,TYPE_DECL,"void ZlibContext::GetAfterWriteOffsets(uint32_t* avail_in,
                                       uint32_t* avail_out) const {
  *avail_in = strm_.avail_in;
  *avail_out = strm_.avail_out;
}",1,1,node_zlib.cc,node.anonymous_namespace_112.ZlibContext.GetAfterWriteOffsets,,false,879,883,GetAfterWriteOffsets,,,21,"void node.anonymous_namespace_112.ZlibContext.GetAfterWriteOffsets (uint32_t*,uint32_t*)"
260525,METHOD,node_zlib.cc:<global>,TYPE_DECL,"CompressionError ZlibContext::ErrorForMessage(const char* message) const {
  if (strm_.msg != nullptr)
    message = strm_.msg;

  return CompressionError { message, ZlibStrerror(err_), err_ };
}",1,1,node_zlib.cc,node.anonymous_namespace_113.ZlibContext.ErrorForMessage,,false,886,891,ErrorForMessage,,,22,CompressionError node.anonymous_namespace_113.ZlibContext.ErrorForMessage (char*)
260549,METHOD,node_zlib.cc:<global>,TYPE_DECL,"CompressionError ZlibContext::GetErrorInfo() const {
  // Acceptable error states depend on the type of zlib stream.
  switch (err_) {
  case Z_OK:
  case Z_BUF_ERROR:
    if (strm_.avail_out != 0 && flush_ == Z_FINISH) {
      return ErrorForMessage(""unexpected end of file"");
    }
  case Z_STREAM_END:
    // normal statuses, not fatal
    break;
  case Z_NEED_DICT:
    if (dictionary_.empty())
      return ErrorForMessage(""Missing dictionary"");
    else
      return ErrorForMessage(""Bad dictionary"");
  default:
    // something else.
    return ErrorForMessage(""Zlib error"");
  }

  return CompressionError {};
}",1,1,node_zlib.cc,node.anonymous_namespace_115.ZlibContext.GetErrorInfo,,false,894,916,GetErrorInfo,,,23,CompressionError node.anonymous_namespace_115.ZlibContext.GetErrorInfo ()
260600,METHOD,node_zlib.cc:<global>,TYPE_DECL,"CompressionError ZlibContext::ResetStream() {
  bool first_init_call = InitZlib();
  if (first_init_call && err_ != Z_OK) {
    return ErrorForMessage(""Failed to init stream before reset"");
  }

  err_ = Z_OK;

  switch (mode_) {
    case DEFLATE:
    case DEFLATERAW:
    case GZIP:
      err_ = deflateReset(&strm_);
      break;
    case INFLATE:
    case INFLATERAW:
    case GUNZIP:
      err_ = inflateReset(&strm_);
      break;
    default:
      break;
  }

  if (err_ != Z_OK)
    return ErrorForMessage(""Failed to reset stream"");

  return SetDictionary();
}",1,1,node_zlib.cc,node.anonymous_namespace_120.ZlibContext.ResetStream,,false,919,946,ResetStream,,,24,CompressionError node.anonymous_namespace_120.ZlibContext.ResetStream ()
260660,METHOD,node_zlib.cc:<global>,TYPE_DECL,"void ZlibContext::SetAllocationFunctions(alloc_func alloc,
                                         free_func free,
                                         void* opaque) {
  strm_.zalloc = alloc;
  strm_.zfree = free;
  strm_.opaque = opaque;
}",1,1,node_zlib.cc,node.anonymous_namespace_123.ZlibContext.SetAllocationFunctions,,false,949,955,SetAllocationFunctions,,,25,"void node.anonymous_namespace_123.ZlibContext.SetAllocationFunctions (alloc_func,free_func,void*)"
260682,METHOD,node_zlib.cc:<global>,TYPE_DECL,"void ZlibContext::Init(
    int level, int window_bits, int mem_level, int strategy,
    std::vector<unsigned char>&& dictionary) {
  if (!((window_bits == 0) &&
        (mode_ == INFLATE ||
         mode_ == GUNZIP ||
         mode_ == UNZIP))) {
    CHECK(
        (window_bits >= Z_MIN_WINDOWBITS && window_bits <= Z_MAX_WINDOWBITS) &&
        ""invalid windowBits"");
  }

  CHECK((level >= Z_MIN_LEVEL && level <= Z_MAX_LEVEL) &&
    ""invalid compression level"");

  CHECK((mem_level >= Z_MIN_MEMLEVEL && mem_level <= Z_MAX_MEMLEVEL) &&
        ""invalid memlevel"");

  CHECK((strategy == Z_FILTERED || strategy == Z_HUFFMAN_ONLY ||
         strategy == Z_RLE || strategy == Z_FIXED ||
         strategy == Z_DEFAULT_STRATEGY) &&
        ""invalid strategy"");

  level_ = level;
  window_bits_ = window_bits;
  mem_level_ = mem_level;
  strategy_ = strategy;

  flush_ = Z_NO_FLUSH;

  err_ = Z_OK;

  if (mode_ == GZIP || mode_ == GUNZIP) {
    window_bits_ += 16;
  }

  if (mode_ == UNZIP) {
 ...",1,24,node_zlib.cc,node.anonymous_namespace_124.ZlibContext.Init,,false,958,1003,Init,,,26,"void node.anonymous_namespace_124.ZlibContext.Init (int,int,int,int,ANY)"
260832,METHOD,node_zlib.cc:<global>,TYPE_DECL,"bool ZlibContext::InitZlib() {
  Mutex::ScopedLock lock(mutex_);
  if (zlib_init_done_) {
    return false;
  }

  switch (mode_) {
    case DEFLATE:
    case GZIP:
    case DEFLATERAW:
      err_ = deflateInit2(&strm_,
                          level_,
                          Z_DEFLATED,
                          window_bits_,
                          mem_level_,
                          strategy_);
      break;
    case INFLATE:
    case GUNZIP:
    case INFLATERAW:
    case UNZIP:
      err_ = inflateInit2(&strm_, window_bits_);
      break;
    default:
      UNREACHABLE();
  }

  if (err_ != Z_OK) {
    dictionary_.clear();
    mode_ = NONE;
    return true;
  }

  SetDictionary();
  zlib_init_done_ = true;
  return true;
}",1,1,node_zlib.cc,node.anonymous_namespace_125.ZlibContext.InitZlib,,false,1005,1041,InitZlib,,,27,bool node.anonymous_namespace_125.ZlibContext.InitZlib ()
260901,METHOD,node_zlib.cc:<global>,TYPE_DECL,"CompressionError ZlibContext::SetDictionary() {
  if (dictionary_.empty())
    return CompressionError {};

  err_ = Z_OK;

  switch (mode_) {
    case DEFLATE:
    case DEFLATERAW:
      err_ = deflateSetDictionary(&strm_,
                                  dictionary_.data(),
                                  dictionary_.size());
      break;
    case INFLATERAW:
      // The other inflate cases will have the dictionary set when inflate()
      // returns Z_NEED_DICT in Process()
      err_ = inflateSetDictionary(&strm_,
                                  dictionary_.data(),
                                  dictionary_.size());
      break;
    default:
      break;
  }

  if (err_ != Z_OK) {
    return ErrorForMessage(""Failed to set dictionary"");
  }

  return CompressionError {};
}",1,1,node_zlib.cc,node.anonymous_namespace_126.ZlibContext.SetDictionary,,false,1044,1073,SetDictionary,,,28,CompressionError node.anonymous_namespace_126.ZlibContext.SetDictionary ()
260967,METHOD,node_zlib.cc:<global>,TYPE_DECL,"CompressionError ZlibContext::SetParams(int level, int strategy) {
  bool first_init_call = InitZlib();
  if (first_init_call && err_ != Z_OK) {
    return ErrorForMessage(""Failed to init stream before set parameters"");
  }

  err_ = Z_OK;

  switch (mode_) {
    case DEFLATE:
    case DEFLATERAW:
      err_ = deflateParams(&strm_, level, strategy);
      break;
    default:
      break;
  }

  if (err_ != Z_OK && err_ != Z_BUF_ERROR) {
    return ErrorForMessage(""Failed to set parameters"");
  }

  return CompressionError {};
}",1,1,node_zlib.cc,node.anonymous_namespace_128.ZlibContext.SetParams,,false,1076,1098,SetParams,,,29,"CompressionError node.anonymous_namespace_128.ZlibContext.SetParams (int,int)"
261022,METHOD,node_zlib.cc:<global>,TYPE_DECL,"void BrotliContext::SetBuffers(const char* in, uint32_t in_len,
                               char* out, uint32_t out_len) {
  next_in_ = reinterpret_cast<const uint8_t*>(in);
  next_out_ = reinterpret_cast<uint8_t*>(out);
  avail_in_ = in_len;
  avail_out_ = out_len;
}",1,1,node_zlib.cc,node.anonymous_namespace_132.BrotliContext.SetBuffers,,false,1101,1107,SetBuffers,,,30,"void node.anonymous_namespace_132.BrotliContext.SetBuffers (char*,uint32_t,char*,uint32_t)"
261046,METHOD,node_zlib.cc:<global>,TYPE_DECL,"void BrotliContext::SetFlush(int flush) {
  flush_ = static_cast<BrotliEncoderOperation>(flush);
}",1,1,node_zlib.cc,node.anonymous_namespace_133.BrotliContext.SetFlush,,false,1110,1112,SetFlush,,,31,void node.anonymous_namespace_133.BrotliContext.SetFlush (int)
261056,METHOD,node_zlib.cc:<global>,TYPE_DECL,"void BrotliContext::GetAfterWriteOffsets(uint32_t* avail_in,
                                         uint32_t* avail_out) const {
  *avail_in = avail_in_;
  *avail_out = avail_out_;
}",1,1,node_zlib.cc,node.anonymous_namespace_134.BrotliContext.GetAfterWriteOffsets,,false,1115,1119,GetAfterWriteOffsets,,,32,"void node.anonymous_namespace_134.BrotliContext.GetAfterWriteOffsets (uint32_t*,uint32_t*)"
261070,METHOD,node_zlib.cc:<global>,TYPE_DECL,"void BrotliEncoderContext::DoThreadPoolWork() {
  CHECK_EQ(mode_, BROTLI_ENCODE);
  CHECK(state_);
  const uint8_t* next_in = next_in_;
  last_result_ = BrotliEncoderCompressStream(state_.get(),
                                             flush_,
                                             &avail_in_,
                                             &next_in,
                                             &avail_out_,
                                             &next_out_,
                                             nullptr);
  next_in_ += next_in - next_in_;
}",1,1,node_zlib.cc,node.anonymous_namespace_135.BrotliEncoderContext.DoThreadPoolWork,,false,1122,1134,DoThreadPoolWork,,,33,void node.anonymous_namespace_135.BrotliEncoderContext.DoThreadPoolWork ()
261105,METHOD,node_zlib.cc:<global>,TYPE_DECL,"void BrotliEncoderContext::Close() {
  state_.reset();
  mode_ = NONE;
}",1,1,node_zlib.cc,node.anonymous_namespace_136.BrotliEncoderContext.Close,,false,1137,1140,Close,,,34,void node.anonymous_namespace_136.BrotliEncoderContext.Close ()
261116,METHOD,node_zlib.cc:<global>,TYPE_DECL,"CompressionError BrotliEncoderContext::Init(brotli_alloc_func alloc,
                                            brotli_free_func free,
                                            void* opaque) {
  alloc_ = alloc;
  free_ = free;
  alloc_opaque_ = opaque;
  state_.reset(BrotliEncoderCreateInstance(alloc, free, opaque));
  if (!state_) {
    return CompressionError(""Could not initialize Brotli instance"",
                            ""ERR_ZLIB_INITIALIZATION_FAILED"",
                            -1);
  } else {
    return CompressionError {};
  }
}",1,1,node_zlib.cc,node.anonymous_namespace_137.BrotliEncoderContext.Init,,false,1142,1156,Init,,,35,"CompressionError node.anonymous_namespace_137.BrotliEncoderContext.Init (brotli_alloc_func,brotli_free_func,void*)"
261155,METHOD,node_zlib.cc:<global>,TYPE_DECL,"CompressionError BrotliEncoderContext::ResetStream() {
  return Init(alloc_, free_, alloc_opaque_);
}",1,1,node_zlib.cc,node.anonymous_namespace_138.BrotliEncoderContext.ResetStream,,false,1158,1160,ResetStream,,,36,CompressionError node.anonymous_namespace_138.BrotliEncoderContext.ResetStream ()
261164,METHOD,node_zlib.cc:<global>,TYPE_DECL,"CompressionError BrotliEncoderContext::SetParams(int key, uint32_t value) {
  if (!BrotliEncoderSetParameter(state_.get(),
                                 static_cast<BrotliEncoderParameter>(key),
                                 value)) {
    return CompressionError(""Setting parameter failed"",
                            ""ERR_BROTLI_PARAM_SET_FAILED"",
                            -1);
  } else {
    return CompressionError {};
  }
}",1,1,node_zlib.cc,node.anonymous_namespace_140.BrotliEncoderContext.SetParams,,false,1162,1172,SetParams,,,37,"CompressionError node.anonymous_namespace_140.BrotliEncoderContext.SetParams (int,uint32_t)"
261193,METHOD,node_zlib.cc:<global>,TYPE_DECL,"CompressionError BrotliEncoderContext::GetErrorInfo() const {
  if (!last_result_) {
    return CompressionError(""Compression failed"",
                            ""ERR_BROTLI_COMPRESSION_FAILED"",
                            -1);
  } else {
    return CompressionError {};
  }
}",1,1,node_zlib.cc,node.anonymous_namespace_141.BrotliEncoderContext.GetErrorInfo,,false,1174,1182,GetErrorInfo,,,38,CompressionError node.anonymous_namespace_141.BrotliEncoderContext.GetErrorInfo ()
261212,METHOD,node_zlib.cc:<global>,TYPE_DECL,"void BrotliDecoderContext::Close() {
  state_.reset();
  mode_ = NONE;
}",1,1,node_zlib.cc,node.anonymous_namespace_142.BrotliDecoderContext.Close,,false,1185,1188,Close,,,39,void node.anonymous_namespace_142.BrotliDecoderContext.Close ()
261223,METHOD,node_zlib.cc:<global>,TYPE_DECL,"void BrotliDecoderContext::DoThreadPoolWork() {
  CHECK_EQ(mode_, BROTLI_DECODE);
  CHECK(state_);
  const uint8_t* next_in = next_in_;
  last_result_ = BrotliDecoderDecompressStream(state_.get(),
                                               &avail_in_,
                                               &next_in,
                                               &avail_out_,
                                               &next_out_,
                                               nullptr);
  next_in_ += next_in - next_in_;
  if (last_result_ == BROTLI_DECODER_RESULT_ERROR) {
    error_ = BrotliDecoderGetErrorCode(state_.get());
    error_string_ = std::string(""ERR_"") + BrotliDecoderErrorString(error_);
  }
}",1,1,node_zlib.cc,node.anonymous_namespace_143.BrotliDecoderContext.DoThreadPoolWork,,false,1190,1205,DoThreadPoolWork,,,40,void node.anonymous_namespace_143.BrotliDecoderContext.DoThreadPoolWork ()
261279,METHOD,node_zlib.cc:<global>,TYPE_DECL,"CompressionError BrotliDecoderContext::Init(brotli_alloc_func alloc,
                                            brotli_free_func free,
                                            void* opaque) {
  alloc_ = alloc;
  free_ = free;
  alloc_opaque_ = opaque;
  state_.reset(BrotliDecoderCreateInstance(alloc, free, opaque));
  if (!state_) {
    return CompressionError(""Could not initialize Brotli instance"",
                            ""ERR_ZLIB_INITIALIZATION_FAILED"",
                            -1);
  } else {
    return CompressionError {};
  }
}",1,1,node_zlib.cc,node.anonymous_namespace_144.BrotliDecoderContext.Init,,false,1207,1221,Init,,,41,"CompressionError node.anonymous_namespace_144.BrotliDecoderContext.Init (brotli_alloc_func,brotli_free_func,void*)"
261318,METHOD,node_zlib.cc:<global>,TYPE_DECL,"CompressionError BrotliDecoderContext::ResetStream() {
  return Init(alloc_, free_, alloc_opaque_);
}",1,1,node_zlib.cc,node.anonymous_namespace_145.BrotliDecoderContext.ResetStream,,false,1223,1225,ResetStream,,,42,CompressionError node.anonymous_namespace_145.BrotliDecoderContext.ResetStream ()
261327,METHOD,node_zlib.cc:<global>,TYPE_DECL,"CompressionError BrotliDecoderContext::SetParams(int key, uint32_t value) {
  if (!BrotliDecoderSetParameter(state_.get(),
                                 static_cast<BrotliDecoderParameter>(key),
                                 value)) {
    return CompressionError(""Setting parameter failed"",
                            ""ERR_BROTLI_PARAM_SET_FAILED"",
                            -1);
  } else {
    return CompressionError {};
  }
}",1,1,node_zlib.cc,node.anonymous_namespace_147.BrotliDecoderContext.SetParams,,false,1227,1237,SetParams,,,43,"CompressionError node.anonymous_namespace_147.BrotliDecoderContext.SetParams (int,uint32_t)"
261356,METHOD,node_zlib.cc:<global>,TYPE_DECL,"CompressionError BrotliDecoderContext::GetErrorInfo() const {
  if (error_ != BROTLI_DECODER_NO_ERROR) {
    return CompressionError(""Decompression failed"",
                            error_string_.c_str(),
                            static_cast<int>(error_));
  } else if (flush_ == BROTLI_OPERATION_FINISH &&
             last_result_ == BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT) {
    // Match zlib's behaviour, as brotli doesn't have its own code for this.
    return CompressionError(""unexpected end of file"",
                            ""Z_BUF_ERROR"",
                            Z_BUF_ERROR);
  } else {
    return CompressionError {};
  }
}",1,1,node_zlib.cc,node.anonymous_namespace_148.BrotliDecoderContext.GetErrorInfo,,false,1239,1253,GetErrorInfo,,,44,CompressionError node.anonymous_namespace_148.BrotliDecoderContext.GetErrorInfo ()
261397,METHOD,node.anonymous_namespace_149.MakeClass,TYPE_DECL,"static void Make(Environment* env, Local<Object> target, const char* name) {
    Isolate* isolate = env->isolate();
    Local<FunctionTemplate> z = NewFunctionTemplate(isolate, Stream::New);

    z->InstanceTemplate()->SetInternalFieldCount(
        Stream::kInternalFieldCount);
    z->Inherit(AsyncWrap::GetConstructorTemplate(env));

    SetProtoMethod(isolate, z, ""write"", Stream::template Write<true>);
    SetProtoMethod(isolate, z, ""writeSync"", Stream::template Write<false>);
    SetProtoMethod(isolate, z, ""close"", Stream::Close);

    SetProtoMethod(isolate, z, ""init"", Stream::Init);
    SetProtoMethod(isolate, z, ""params"", Stream::Params);
    SetProtoMethod(isolate, z, ""reset"", Stream::Reset);

    SetConstructorFunction(env->context(), target, name, z);
  }",3,3,node_zlib.cc,node.anonymous_namespace_150.MakeClass.Make,,false,1258,1275,Make,,,1,"void node.anonymous_namespace_150.MakeClass.Make (Environment*,Local<Object>,char*)"
261491,METHOD,node.anonymous_namespace_149.MakeClass,TYPE_DECL,"static void Make(ExternalReferenceRegistry* registry) {
    registry->Register(Stream::New);
    registry->Register(Stream::template Write<true>);
    registry->Register(Stream::template Write<false>);
    registry->Register(Stream::Close);
    registry->Register(Stream::Init);
    registry->Register(Stream::Params);
    registry->Register(Stream::Reset);
  }",3,3,node_zlib.cc,node.anonymous_namespace_151.MakeClass.Make,,false,1277,1285,Make,,,2,void node.anonymous_namespace_151.MakeClass.Make (ExternalReferenceRegistry*)
261545,METHOD,node_zlib.cc:<global>,TYPE_DECL,"void Initialize(Local<Object> target,
                Local<Value> unused,
                Local<Context> context,
                void* priv) {
  Environment* env = Environment::GetCurrent(context);

  MakeClass<ZlibStream>::Make(env, target, ""Zlib"");
  MakeClass<BrotliEncoderStream>::Make(env, target, ""BrotliEncoder"");
  MakeClass<BrotliDecoderStream>::Make(env, target, ""BrotliDecoder"");

  target->Set(env->context(),
              FIXED_ONE_BYTE_STRING(env->isolate(), ""ZLIB_VERSION""),
              FIXED_ONE_BYTE_STRING(env->isolate(), ZLIB_VERSION)).Check();
}",1,1,node_zlib.cc,node.anonymous_namespace_152.Initialize,,false,1288,1301,Initialize,,,46,"void node.anonymous_namespace_152.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
261605,METHOD,node_zlib.cc:<global>,TYPE_DECL,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  MakeClass<ZlibStream>::Make(registry);
  MakeClass<BrotliEncoderStream>::Make(registry);
  MakeClass<BrotliDecoderStream>::Make(registry);
}",1,1,node_zlib.cc,node.anonymous_namespace_153.RegisterExternalReferences,,false,1303,1307,RegisterExternalReferences,,,47,void node.anonymous_namespace_153.RegisterExternalReferences (ExternalReferenceRegistry*)
261625,METHOD,node_zlib.cc:<global>,TYPE_DECL,"void DefineZlibConstants(Local<Object> target) {
  NODE_DEFINE_CONSTANT(target, Z_NO_FLUSH);
  NODE_DEFINE_CONSTANT(target, Z_PARTIAL_FLUSH);
  NODE_DEFINE_CONSTANT(target, Z_SYNC_FLUSH);
  NODE_DEFINE_CONSTANT(target, Z_FULL_FLUSH);
  NODE_DEFINE_CONSTANT(target, Z_FINISH);
  NODE_DEFINE_CONSTANT(target, Z_BLOCK);

  // return/error codes
  NODE_DEFINE_CONSTANT(target, Z_OK);
  NODE_DEFINE_CONSTANT(target, Z_STREAM_END);
  NODE_DEFINE_CONSTANT(target, Z_NEED_DICT);
  NODE_DEFINE_CONSTANT(target, Z_ERRNO);
  NODE_DEFINE_CONSTANT(target, Z_STREAM_ERROR);
  NODE_DEFINE_CONSTANT(target, Z_DATA_ERROR);
  NODE_DEFINE_CONSTANT(target, Z_MEM_ERROR);
  NODE_DEFINE_CONSTANT(target, Z_BUF_ERROR);
  NODE_DEFINE_CONSTANT(target, Z_VERSION_ERROR);

  NODE_DEFINE_CONSTANT(target, Z_NO_COMPRESSION);
  NODE_DEFINE_CONSTANT(target, Z_BEST_SPEED);
  NODE_DEFINE_CONSTANT(target, Z_BEST_COMPRESSION);
  NODE_DEFINE_CONSTANT(target, Z_DEFAULT_COMPRESSION);
  NODE_DEFINE_CONSTANT(target, Z_FILTERED);
  NO...",1,2,node_zlib.cc,node.DefineZlibConstants,,false,1311,1429,DefineZlibConstants,,,2,void node.DefineZlibConstants (Local<Object>)
272229,METHOD,permission\child_process_permission.cc:<global>,TYPE_DECL,<global>,1,53,permission\child_process_permission.hpp,permission\child_process_permission.cc:<global>,,false,1,23,<global>,,,1,
272233,METHOD,permission\child_process_permission.cc:<global>,TYPE_DECL,"void ChildProcessPermission::Apply(const std::string& allow,
                                   PermissionScope scope) {
  deny_all_ = true;
}",1,1,permission\child_process_permission.cc,node.permission.ChildProcessPermission.Apply,,false,12,15,Apply,,,1,"void node.permission.ChildProcessPermission.Apply (ANY,PermissionScope)"
272242,METHOD,permission\child_process_permission.cc:<global>,TYPE_DECL,"bool ChildProcessPermission::is_granted(PermissionScope perm,
                                        const std::string_view& param) {
  return deny_all_ == false;
}",1,1,permission\child_process_permission.cc,node.permission.ChildProcessPermission.is_granted,,false,17,20,is_granted,,,2,"bool node.permission.ChildProcessPermission.is_granted (PermissionScope,ANY)"
272259,METHOD,permission\child_process_permission.hpp:<global>,TYPE_DECL,<global>,1,53,permission\child_process_permission.hpp,permission\child_process_permission.hpp:<global>,,false,1,28,<global>,,,1,
272290,METHOD,permission\fs_permission.cc:<global>,TYPE_DECL,<global>,1,42,permission\fs_permission.hpp,permission\fs_permission.cc:<global>,,false,1,228,<global>,,,1,
272293,METHOD,permission\fs_permission.cc:<global>,TYPE_DECL,"std::string WildcardIfDir(const std::string& res) noexcept {
  uv_fs_t req;
  int rc = uv_fs_stat(nullptr, &req, res.c_str(), nullptr);
  if (rc == 0) {
    const uv_stat_t* const s = static_cast<const uv_stat_t*>(req.ptr);
    if (s->st_mode & S_IFDIR) {
      // add wildcard when directory
      if (res.back() == node::kPathSeparator) {
        return res + ""*"";
      }
      return res + node::kPathSeparator + ""*"";
    }
  }
  uv_fs_req_cleanup(&req);
  return res;
}",1,1,permission\fs_permission.cc,anonymous_namespace_1.WildcardIfDir,,false,18,33,WildcardIfDir,,,1,string anonymous_namespace_1.WildcardIfDir (ANY)
272358,METHOD,permission\fs_permission.cc:<global>,TYPE_DECL,"void FreeRecursivelyNode(
    node::permission::FSPermission::RadixTree::Node* node) {
  if (node == nullptr) {
    return;
  }

  if (node->children.size()) {
    for (auto& c : node->children) {
      FreeRecursivelyNode(c.second);
    }
  }

  if (node->wildcard_child != nullptr) {
    delete node->wildcard_child;
  }
  delete node;
}",1,1,permission\fs_permission.cc,anonymous_namespace_2.FreeRecursivelyNode,,false,35,51,FreeRecursivelyNode,,,2,void anonymous_namespace_2.FreeRecursivelyNode (ANY*)
272400,METHOD,permission\fs_permission.cc:<global>,TYPE_DECL,"bool is_tree_granted(node::permission::FSPermission::RadixTree* granted_tree,
                     const std::string_view& param) {
#ifdef _WIN32
  // is UNC file path
  if (param.rfind(""\\\\"", 0) == 0) {
    // return lookup with normalized param
    int starting_pos = 4;  // ""\\?\""
    if (param.rfind(""\\\\?\\UNC\\"") == 0) {
      starting_pos += 4;  // ""UNC\""
    }
    auto normalized = param.substr(starting_pos);
    return granted_tree->Lookup(normalized, true);
  }
#endif
  return granted_tree->Lookup(param, true);
}",1,1,permission\fs_permission.cc,anonymous_namespace_3.is_tree_granted,,false,53,68,is_tree_granted,,,3,"bool anonymous_namespace_3.is_tree_granted (ANY*,ANY)"
272415,METHOD,permission\fs_permission.cc:<global>,TYPE_DECL,"void PrintTree(FSPermission::RadixTree::Node* node, int spaces = 0) {
  std::string whitespace(spaces, ' ');

  if (node == nullptr) {
    return;
  }
  if (node->wildcard_child != nullptr) {
    per_process::Debug(DebugCategory::PERMISSION_MODEL,
                       ""%s Wildcard: %s\n"",
                       whitespace,
                       node->prefix);
  } else {
    per_process::Debug(DebugCategory::PERMISSION_MODEL,
                       ""%s Prefix: %s\n"",
                       whitespace,
                       node->prefix);
    if (node->children.size()) {
      int child = 0;
      for (const auto pair : node->children) {
        ++child;
        per_process::Debug(DebugCategory::PERMISSION_MODEL,
                           ""%s Child(%s): %s\n"",
                           whitespace,
                           child,
                           std::string(1, pair.first));
        PrintTree(pair.second, spaces + 2);
      }
      per_process::Debug(DebugCategory::PE...",1,1,permission\fs_permission.cc,node.permission.PrintTree,,false,76,114,PrintTree,,,1,"void node.permission.PrintTree (ANY*,int)"
272533,METHOD,permission\fs_permission.cc:<global>,TYPE_DECL,"void FSPermission::Apply(const std::string& allow, PermissionScope scope) {
  using std::string_view_literals::operator""""sv;
  for (const std::string_view res : SplitString(allow, "",""sv)) {
    if (res == ""*""sv) {
      if (scope == PermissionScope::kFileSystemRead) {
        deny_all_in_ = false;
        allow_all_in_ = true;
      } else {
        deny_all_out_ = false;
        allow_all_out_ = true;
      }
      return;
    }
    GrantAccess(scope, std::string(res.data(), res.size()));
  }
}",1,1,permission\fs_permission.cc,node.permission.FSPermission.Apply,,false,118,133,Apply,,,2,"void node.permission.FSPermission.Apply (ANY,PermissionScope)"
272586,METHOD,permission\fs_permission.cc:<global>,TYPE_DECL,"void FSPermission::GrantAccess(PermissionScope perm, const std::string& res) {
  const std::string path = WildcardIfDir(res);
  if (perm == PermissionScope::kFileSystemRead) {
    granted_in_fs_.Insert(path);
    deny_all_in_ = false;
  } else if (perm == PermissionScope::kFileSystemWrite) {
    granted_out_fs_.Insert(path);
    deny_all_out_ = false;
  }
}",1,1,permission\fs_permission.cc,node.permission.FSPermission.GrantAccess,,false,135,144,GrantAccess,,,3,"void node.permission.FSPermission.GrantAccess (PermissionScope,ANY)"
272629,METHOD,permission\fs_permission.cc:<global>,TYPE_DECL,"bool FSPermission::is_granted(PermissionScope perm,
                              const std::string_view& param = """") {
  switch (perm) {
    case PermissionScope::kFileSystem:
      return allow_all_in_ && allow_all_out_;
    case PermissionScope::kFileSystemRead:
      return !deny_all_in_ &&
             ((param.empty() && allow_all_in_) || allow_all_in_ ||
              is_tree_granted(&granted_in_fs_, param));
    case PermissionScope::kFileSystemWrite:
      return !deny_all_out_ &&
             ((param.empty() && allow_all_out_) || allow_all_out_ ||
              is_tree_granted(&granted_out_fs_, param));
    default:
      return false;
  }
}",1,1,permission\fs_permission.cc,node.permission.FSPermission.is_granted,,false,146,162,is_granted,,,4,"bool node.permission.FSPermission.is_granted (PermissionScope,ANY)"
272691,METHOD,permission\fs_permission.cc:<global>,TYPE_DECL,"FSPermission::RadixTree::RadixTree() : root_node_(new Node("""")) {}",1,66,permission\fs_permission.cc,node.permission.FSPermission.RadixTree.RadixTree,,false,164,164,RadixTree,,,5,ANY node.permission.FSPermission.RadixTree.RadixTree ()
272695,METHOD,permission\fs_permission.cc:<global>,TYPE_DECL,"FSPermission::RadixTree::~RadixTree() {
  FreeRecursivelyNode(root_node_);
}",1,1,permission\fs_permission.cc,node.permission.FSPermission.RadixTree.~RadixTree,,false,166,168,~RadixTree,,,6,ANY node.permission.FSPermission.RadixTree.~RadixTree ()
272700,METHOD,permission\fs_permission.cc:<global>,TYPE_DECL,"bool FSPermission::RadixTree::Lookup(const std::string_view& s,
                                     bool when_empty_return = false) {
  FSPermission::RadixTree::Node* current_node = root_node_;
  if (current_node->children.size() == 0) {
    return when_empty_return;
  }
  unsigned int parent_node_prefix_len = current_node->prefix.length();
  const std::string path(s);
  auto path_len = path.length();

  while (true) {
    if (parent_node_prefix_len == path_len && current_node->IsEndNode()) {
      return true;
    }

    auto node = current_node->NextNode(path, parent_node_prefix_len);
    if (node == nullptr) {
      return false;
    }

    current_node = node;
    parent_node_prefix_len += current_node->prefix.length();
    if (current_node->wildcard_child != nullptr &&
        path_len >= (parent_node_prefix_len - 2 /* slash* */)) {
      return true;
    }
  }
}",1,1,permission\fs_permission.cc,node.permission.FSPermission.RadixTree.Lookup,,false,170,197,Lookup,,,7,"bool node.permission.FSPermission.RadixTree.Lookup (ANY,bool)"
272798,METHOD,permission\fs_permission.cc:<global>,TYPE_DECL,"void FSPermission::RadixTree::Insert(const std::string& path) {
  FSPermission::RadixTree::Node* current_node = root_node_;

  unsigned int parent_node_prefix_len = current_node->prefix.length();
  int path_len = path.length();

  for (int i = 1; i <= path_len; ++i) {
    bool is_wildcard_node = path[i - 1] == '*';
    bool is_last_char = i == path_len;

    if (is_wildcard_node || is_last_char) {
      std::string node_path = path.substr(parent_node_prefix_len, i);
      current_node = current_node->CreateChild(node_path);
    }

    if (is_wildcard_node) {
      current_node = current_node->CreateWildcardChild();
      parent_node_prefix_len = i;
    }
  }

  if (UNLIKELY(per_process::enabled_debug_list.enabled(
          DebugCategory::PERMISSION_MODEL))) {
    per_process::Debug(DebugCategory::PERMISSION_MODEL, ""Inserting %s\n"", path);
    PrintTree(root_node_);
  }
}",1,1,permission\fs_permission.cc,node.permission.FSPermission.RadixTree.Insert,,false,199,225,Insert,,,8,void node.permission.FSPermission.RadixTree.Insert (ANY)
272917,METHOD,permission\fs_permission.hpp:<global>,TYPE_DECL,<global>,1,42,permission\fs_permission.hpp,permission\fs_permission.hpp:<global>,,false,1,153,<global>,,,1,
272926,METHOD,permission\inspector_permission.cc:<global>,TYPE_DECL,<global>,1,49,permission\inspector_permission.hpp,permission\inspector_permission.cc:<global>,,false,1,22,<global>,,,1,
272930,METHOD,permission\inspector_permission.cc:<global>,TYPE_DECL,"void InspectorPermission::Apply(const std::string& allow,
                                PermissionScope scope) {
  deny_all_ = true;
}",1,1,permission\inspector_permission.cc,node.permission.InspectorPermission.Apply,,false,11,14,Apply,,,1,"void node.permission.InspectorPermission.Apply (ANY,PermissionScope)"
272939,METHOD,permission\inspector_permission.cc:<global>,TYPE_DECL,"bool InspectorPermission::is_granted(PermissionScope perm,
                                     const std::string_view& param) {
  return deny_all_ == false;
}",1,1,permission\inspector_permission.cc,node.permission.InspectorPermission.is_granted,,false,16,19,is_granted,,,2,"bool node.permission.InspectorPermission.is_granted (PermissionScope,ANY)"
272956,METHOD,permission\inspector_permission.hpp:<global>,TYPE_DECL,<global>,1,49,permission\inspector_permission.hpp,permission\inspector_permission.hpp:<global>,,false,1,28,<global>,,,1,
272983,METHOD,permission\permission.cc:<global>,TYPE_DECL,<global>,1,39,permission\permission.hpp,permission\permission.cc:<global>,,false,1,158,<global>,,,1,
272988,METHOD,permission\permission.cc:<global>,TYPE_DECL,"static void Has(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  v8::Isolate* isolate = env->isolate();
  CHECK(args[0]->IsString());

  String::Utf8Value utf8_deny_scope(isolate, args[0]);
  if (*utf8_deny_scope == nullptr) {
    return;
  }

  const std::string deny_scope = *utf8_deny_scope;
  PermissionScope scope = Permission::StringToPermission(deny_scope);
  if (scope == PermissionScope::kPermissionsRoot) {
    return args.GetReturnValue().Set(false);
  }

  if (args.Length() > 1 && !args[1]->IsUndefined()) {
    String::Utf8Value utf8_arg(isolate, args[1]);
    if (*utf8_arg == nullptr) {
      return;
    }
    return args.GetReturnValue().Set(
        env->permission()->is_granted(scope, *utf8_arg));
  }

  return args.GetReturnValue().Set(env->permission()->is_granted(scope));
}",1,1,permission\permission.cc,node.permission.anonymous_namespace_1.Has,,false,30,56,Has,,,1,void node.permission.anonymous_namespace_1.Has (FunctionCallbackInfo<Value>)
273120,METHOD,permission\permission.cc:<global>,TYPE_DECL,"const char* Permission::PermissionToString(const PermissionScope perm) {
  PERMISSIONS(V)
  return nullptr;
}",1,1,permission\permission.cc,node.permission.Permission.PermissionToString,,false,62,65,PermissionToString,,,2,const char* node.permission.Permission.PermissionToString (PermissionScope)
273129,METHOD,permission\permission.cc:<global>,TYPE_DECL,"PermissionScope Permission::StringToPermission(const std::string& perm) {
  PERMISSIONS(V)
  return PermissionScope::kPermissionsRoot;
}",1,1,permission\permission.cc,node.permission.Permission.StringToPermission,,false,70,73,StringToPermission,,,3,PermissionScope node.permission.Permission.StringToPermission (ANY)
273140,METHOD,permission\permission.cc:<global>,TYPE_DECL,"Permission::Permission() : enabled_(false) {
  std::shared_ptr<PermissionBase> fs = std::make_shared<FSPermission>();
  std::shared_ptr<PermissionBase> child_p =
      std::make_shared<ChildProcessPermission>();
  std::shared_ptr<PermissionBase> worker_t =
      std::make_shared<WorkerPermission>();
  std::shared_ptr<PermissionBase> inspector =
      std::make_shared<InspectorPermission>();
#define V(Name, _, __)                                                         \
  nodes_.insert(std::make_pair(PermissionScope::k##Name, fs));
  FILESYSTEM_PERMISSIONS(V)
#undef V
#define V(Name, _, __)                                                         \
  nodes_.insert(std::make_pair(PermissionScope::k##Name, child_p));
  CHILD_PROCESS_PERMISSIONS(V)
#undef V
#define V(Name, _, __)                                                         \
  nodes_.insert(std::make_pair(PermissionScope::k##Name, worker_t));
  WORKER_THREADS_PERMISSIONS(V)
#undef V
#define V(Name, _, __)                    ...",1,1,permission\permission.cc,node.permission.Permission.Permission,,false,76,100,Permission,,,4,ANY node.permission.Permission.Permission ()
273200,METHOD,permission\permission.cc:<global>,TYPE_DECL,"void Permission::ThrowAccessDenied(Environment* env,
                                   PermissionScope perm,
                                   const std::string_view& res) {
  Local<Value> err = ERR_ACCESS_DENIED(env->isolate());
  CHECK(err->IsObject());
  if (err.As<Object>()
          ->Set(env->context(),
                env->permission_string(),
                v8::String::NewFromUtf8(env->isolate(),
                                        PermissionToString(perm),
                                        v8::NewStringType::kNormal)
                    .ToLocalChecked())
          .IsNothing() ||
      err.As<Object>()
          ->Set(env->context(),
                env->resource_string(),
                v8::String::NewFromUtf8(env->isolate(),
                                        std::string(res).c_str(),
                                        v8::NewStringType::kNormal)
                    .ToLocalChecked())
          .IsNothing())
    return;
  env->isolate()->ThrowExce...",1,1,permission\permission.cc,node.permission.Permission.ThrowAccessDenied,,false,102,125,ThrowAccessDenied,,,5,"void node.permission.Permission.ThrowAccessDenied (Environment*,PermissionScope,ANY)"
273317,METHOD,permission\permission.cc:<global>,TYPE_DECL,"void Permission::EnablePermissions() {
  if (!enabled_) {
    enabled_ = true;
  }
}",1,1,permission\permission.cc,node.permission.Permission.EnablePermissions,,false,127,131,EnablePermissions,,,6,void node.permission.Permission.EnablePermissions ()
273328,METHOD,permission\permission.cc:<global>,TYPE_DECL,"void Permission::Apply(const std::string& allow, PermissionScope scope) {
  auto permission = nodes_.find(scope);
  if (permission != nodes_.end()) {
    permission->second->Apply(allow, scope);
  }
}",1,1,permission\permission.cc,node.permission.Permission.Apply,,false,133,138,Apply,,,7,"void node.permission.Permission.Apply (ANY,PermissionScope)"
273358,METHOD,permission\permission.cc:<global>,TYPE_DECL,"void Initialize(Local<Object> target,
                Local<Value> unused,
                Local<Context> context,
                void* priv) {
  SetMethodNoSideEffect(context, target, ""has"", Has);

  target->SetIntegrityLevel(context, v8::IntegrityLevel::kFrozen).FromJust();
}",1,1,permission\permission.cc,node.permission.Initialize,,false,140,147,Initialize,,,8,"void node.permission.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
273384,METHOD,permission\permission.cc:<global>,TYPE_DECL,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(Has);
}",1,1,permission\permission.cc,node.permission.RegisterExternalReferences,,false,149,151,RegisterExternalReferences,,,9,void node.permission.RegisterExternalReferences (ExternalReferenceRegistry*)
273418,METHOD,permission\permission.hpp:<global>,TYPE_DECL,<global>,1,39,permission\permission.hpp,permission\permission.hpp:<global>,,false,1,74,<global>,,,1,
273431,METHOD,permission\permission_base.hpp:<global>,TYPE_DECL,<global>,1,44,permission\permission_base.hpp,permission\permission_base.hpp:<global>,,false,1,52,<global>,,,1,
273442,METHOD,permission\worker_permission.cc:<global>,TYPE_DECL,<global>,1,46,permission\worker_permission.hpp,permission\worker_permission.cc:<global>,,false,1,22,<global>,,,1,
273446,METHOD,permission\worker_permission.cc:<global>,TYPE_DECL,"void WorkerPermission::Apply(const std::string& allow, PermissionScope scope) {
  deny_all_ = true;
}",1,1,permission\worker_permission.cc,node.permission.WorkerPermission.Apply,,false,12,14,Apply,,,1,"void node.permission.WorkerPermission.Apply (ANY,PermissionScope)"
273455,METHOD,permission\worker_permission.cc:<global>,TYPE_DECL,"bool WorkerPermission::is_granted(PermissionScope perm,
                                  const std::string_view& param) {
  return deny_all_ == false;
}",1,1,permission\worker_permission.cc,node.permission.WorkerPermission.is_granted,,false,16,19,is_granted,,,2,"bool node.permission.WorkerPermission.is_granted (PermissionScope,ANY)"
273472,METHOD,permission\worker_permission.hpp:<global>,TYPE_DECL,<global>,1,46,permission\worker_permission.hpp,permission\worker_permission.hpp:<global>,,false,1,28,<global>,,,1,
273501,METHOD,pipe_wrap.cc:<global>,TYPE_DECL,<global>,1,1,pipe_wrap.cc,pipe_wrap.cc:<global>,,false,1,259,<global>,,,1,
273504,METHOD,pipe_wrap.cc:<global>,TYPE_DECL,"MaybeLocal<Object> PipeWrap::Instantiate(Environment* env,
                                         AsyncWrap* parent,
                                         PipeWrap::SocketType type) {
  EscapableHandleScope handle_scope(env->isolate());
  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(parent);
  CHECK_EQ(false, env->pipe_constructor_template().IsEmpty());
  Local<Function> constructor = env->pipe_constructor_template()
                                    ->GetFunction(env->context())
                                    .ToLocalChecked();
  CHECK_EQ(false, constructor.IsEmpty());
  Local<Value> type_value = Int32::New(env->isolate(), type);
  return handle_scope.EscapeMaybe(
      constructor->NewInstance(env->context(), 1, &type_value));
}",1,1,pipe_wrap.cc,node.PipeWrap.Instantiate,,false,50,63,Instantiate,,,1,"MaybeLocal<Object> node.PipeWrap.Instantiate (Environment*,AsyncWrap*,ANY)"
273586,METHOD,pipe_wrap.cc:<global>,TYPE_DECL,"void PipeWrap::Initialize(Local<Object> target,
                          Local<Value> unused,
                          Local<Context> context,
                          void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->InstanceTemplate()
    ->SetInternalFieldCount(StreamBase::kInternalFieldCount);

  t->Inherit(LibuvStreamWrap::GetConstructorTemplate(env));

  SetProtoMethod(isolate, t, ""bind"", Bind);
  SetProtoMethod(isolate, t, ""listen"", Listen);
  SetProtoMethod(isolate, t, ""connect"", Connect);
  SetProtoMethod(isolate, t, ""open"", Open);

#ifdef _WIN32
  SetProtoMethod(isolate, t, ""setPendingInstances"", SetPendingInstances);
#endif

  SetProtoMethod(isolate, t, ""fchmod"", Fchmod);

  SetConstructorFunction(context, target, ""Pipe"", t);
  env->set_pipe_constructor_template(t);

  // Create FunctionTemplate for PipeConnectWrap.
  auto cwt = BaseObject::Mak...",1,2,pipe_wrap.cc,node.PipeWrap.Initialize,,false,66,108,Initialize,,,2,"void node.PipeWrap.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
274216,METHOD,pipe_wrap.cc:<global>,TYPE_DECL,"void PipeWrap::RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(New);
  registry->Register(Bind);
  registry->Register(Listen);
  registry->Register(Connect);
  registry->Register(Open);
#ifdef _WIN32
  registry->Register(SetPendingInstances);
#endif
  registry->Register(Fchmod);
}",1,1,pipe_wrap.cc,node.PipeWrap.RegisterExternalReferences,,false,110,120,RegisterExternalReferences,,,3,void node.PipeWrap.RegisterExternalReferences (ExternalReferenceRegistry*)
274251,METHOD,pipe_wrap.cc:<global>,TYPE_DECL,"void PipeWrap::New(const FunctionCallbackInfo<Value>& args) {
  // This constructor should not be exposed to public javascript.
  // Therefore we assert that we are not trying to call this as a
  // normal function.
  CHECK(args.IsConstructCall());
  CHECK(args[0]->IsInt32());
  Environment* env = Environment::GetCurrent(args);

  int type_value = args[0].As<Int32>()->Value();
  PipeWrap::SocketType type = static_cast<PipeWrap::SocketType>(type_value);

  bool ipc;
  ProviderType provider;
  switch (type) {
    case SOCKET:
      provider = PROVIDER_PIPEWRAP;
      ipc = false;
      break;
    case SERVER:
      provider = PROVIDER_PIPESERVERWRAP;
      ipc = false;
      break;
    case IPC:
      provider = PROVIDER_PIPEWRAP;
      ipc = true;
      break;
    default:
      UNREACHABLE();
  }

  new PipeWrap(env, args.This(), provider, ipc);
}",1,1,pipe_wrap.cc,node.PipeWrap.New,,false,122,153,New,,,4,void node.PipeWrap.New (FunctionCallbackInfo<Value>)
274337,METHOD,pipe_wrap.cc:<global>,TYPE_DECL,"PipeWrap::PipeWrap(Environment* env,
                   Local<Object> object,
                   ProviderType provider,
                   bool ipc)
    : ConnectionWrap(env, object, provider) {
  int r = uv_pipe_init(env->event_loop(), &handle_, ipc);
  CHECK_EQ(r, 0);  // How do we proxy this error up to javascript?
                   // Suggestion: uv_pipe_init() returns void.
}",1,1,pipe_wrap.cc,node.PipeWrap.PipeWrap,,false,156,164,PipeWrap,,,5,"ANY node.PipeWrap.PipeWrap (Environment*,Local<Object>,ProviderType,bool)"
274359,METHOD,pipe_wrap.cc:<global>,TYPE_DECL,"void PipeWrap::Bind(const FunctionCallbackInfo<Value>& args) {
  PipeWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  node::Utf8Value name(args.GetIsolate(), args[0]);
  int err = uv_pipe_bind(&wrap->handle_, *name);
  args.GetReturnValue().Set(err);
}",1,1,pipe_wrap.cc,node.PipeWrap.Bind,,false,167,173,Bind,,,6,void node.PipeWrap.Bind (FunctionCallbackInfo<Value>)
274399,METHOD,pipe_wrap.cc:<global>,TYPE_DECL,"void PipeWrap::Fchmod(const v8::FunctionCallbackInfo<v8::Value>& args) {
  PipeWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  CHECK(args[0]->IsInt32());
  int mode = args[0].As<Int32>()->Value();
  int err = uv_pipe_chmod(&wrap->handle_, mode);
  args.GetReturnValue().Set(err);
}",1,1,pipe_wrap.cc,node.PipeWrap.Fchmod,,false,187,194,Fchmod,,,7,void node.PipeWrap.Fchmod (ANY)
274448,METHOD,pipe_wrap.cc:<global>,TYPE_DECL,"void PipeWrap::Listen(const FunctionCallbackInfo<Value>& args) {
  PipeWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  Environment* env = wrap->env();
  int backlog;
  if (!args[0]->Int32Value(env->context()).To(&backlog)) return;
  int err = uv_listen(reinterpret_cast<uv_stream_t*>(&wrap->handle_),
                      backlog,
                      OnConnection);
  args.GetReturnValue().Set(err);
}",1,1,pipe_wrap.cc,node.PipeWrap.Listen,,false,197,207,Listen,,,8,void node.PipeWrap.Listen (FunctionCallbackInfo<Value>)
274508,METHOD,pipe_wrap.cc:<global>,TYPE_DECL,"void PipeWrap::Open(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  PipeWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  int fd;
  if (!args[0]->Int32Value(env->context()).To(&fd)) return;

  int err = uv_pipe_open(&wrap->handle_, fd);
  if (err == 0) wrap->set_fd(fd);

  args.GetReturnValue().Set(err);
}",1,1,pipe_wrap.cc,node.PipeWrap.Open,,false,210,223,Open,,,9,void node.PipeWrap.Open (FunctionCallbackInfo<Value>)
274576,METHOD,pipe_wrap.cc:<global>,TYPE_DECL,"void PipeWrap::Connect(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  PipeWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsString());

  Local<Object> req_wrap_obj = args[0].As<Object>();
  node::Utf8Value name(env->isolate(), args[1]);

  ConnectWrap* req_wrap =
      new ConnectWrap(env, req_wrap_obj, AsyncWrap::PROVIDER_PIPECONNECTWRAP);
  req_wrap->Dispatch(uv_pipe_connect,
                     &wrap->handle_,
                     *name,
                     AfterConnect);

  TRACE_EVENT_NESTABLE_ASYNC_BEGIN1(TRACING_CATEGORY_NODE2(net, native),
                                    ""connect"",
                                    req_wrap,
                                    ""pipe_path"",
                                    TRACE_STR_COPY(*name));

  args.GetReturnValue().Set(0);  // uv_pipe_connect() doesn't return errors.
}",1,1,pipe_wrap.cc,node.PipeWrap.Connect,,false,226,252,Connect,,,10,void node.PipeWrap.Connect (FunctionCallbackInfo<Value>)
274680,METHOD,pipe_wrap.hpp:<global>,TYPE_DECL,<global>,1,27,pipe_wrap.hpp,pipe_wrap.hpp:<global>,,false,1,80,<global>,,,1,
274701,METHOD,process_wrap.cc:<global>,TYPE_DECL,<global>,1,1,process_wrap.cc,process_wrap.cc:<global>,,false,1,327,<global>,,,1,
274706,METHOD,node.anonymous_namespace_1.ProcessWrap,TYPE_DECL,"static void Initialize(Local<Object> target,
                         Local<Value> unused,
                         Local<Context> context,
                         void* priv) {
    Environment* env = Environment::GetCurrent(context);
    Isolate* isolate = env->isolate();
    Local<FunctionTemplate> constructor = NewFunctionTemplate(isolate, New);
    constructor->InstanceTemplate()->SetInternalFieldCount(
        ProcessWrap::kInternalFieldCount);

    constructor->Inherit(HandleWrap::GetConstructorTemplate(env));

    SetProtoMethod(isolate, constructor, ""spawn"", Spawn);
    SetProtoMethod(isolate, constructor, ""kill"", Kill);

    SetConstructorFunction(context, target, ""Process"", constructor);
  }",3,3,process_wrap.cc,node.anonymous_namespace_2.ProcessWrap.Initialize,,false,52,68,Initialize,,,1,"void node.anonymous_namespace_2.ProcessWrap.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
274773,METHOD,node.anonymous_namespace_1.ProcessWrap,TYPE_DECL,"ProcessWrap(Environment* env, Local<Object> object)
      : HandleWrap(env,
                   object,
                   reinterpret_cast<uv_handle_t*>(&process_),
                   AsyncWrap::PROVIDER_PROCESSWRAP) {
    MarkAsUninitialized();
  }",3,3,process_wrap.cc,node.anonymous_namespace_5.ProcessWrap.ProcessWrap,,false,84,90,ProcessWrap,,,3,"ANY node.anonymous_namespace_5.ProcessWrap.ProcessWrap (Environment*,Local<Object>)"
274780,METHOD,node.anonymous_namespace_1.ProcessWrap,TYPE_DECL,"static uv_stream_t* StreamForWrap(Environment* env, Local<Object> stdio) {
    Local<String> handle_key = env->handle_string();
    // This property has always been set by JS land if we are in this code path.
    Local<Object> handle =
        stdio->Get(env->context(), handle_key).ToLocalChecked().As<Object>();

    uv_stream_t* stream = LibuvStreamWrap::From(env, handle)->stream();
    CHECK_NOT_NULL(stream);
    return stream;
  }",3,3,process_wrap.cc,node.anonymous_namespace_6.ProcessWrap.StreamForWrap,,false,92,101,StreamForWrap,,,4,"uv_stream_t node.anonymous_namespace_6.ProcessWrap.StreamForWrap (Environment*,Local<Object>)"
274833,METHOD,node.anonymous_namespace_1.ProcessWrap,TYPE_DECL,"static void ParseStdioOptions(Environment* env,
                                Local<Object> js_options,
                                uv_process_options_t* options) {
    Local<Context> context = env->context();
    Local<String> stdio_key = env->stdio_string();
    Local<Array> stdios =
        js_options->Get(context, stdio_key).ToLocalChecked().As<Array>();

    uint32_t len = stdios->Length();
    options->stdio = new uv_stdio_container_t[len];
    options->stdio_count = len;

    for (uint32_t i = 0; i < len; i++) {
      Local<Object> stdio =
          stdios->Get(context, i).ToLocalChecked().As<Object>();
      Local<Value> type =
          stdio->Get(context, env->type_string()).ToLocalChecked();

      if (type->StrictEquals(env->ignore_string())) {
        options->stdio[i].flags = UV_IGNORE;
      } else if (type->StrictEquals(env->pipe_string())) {
        options->stdio[i].flags = static_cast<uv_stdio_flags>(
            UV_CREATE_PIPE | UV_READABLE_PIPE | UV_WRITAB...",3,3,process_wrap.cc,node.anonymous_namespace_7.ProcessWrap.ParseStdioOptions,,false,103,144,ParseStdioOptions,,,5,"void node.anonymous_namespace_7.ProcessWrap.ParseStdioOptions (Environment*,Local<Object>,uv_process_options_t*)"
275143,METHOD,node.anonymous_namespace_1.ProcessWrap,TYPE_DECL,"static void Spawn(const FunctionCallbackInfo<Value>& args) {
    Environment* env = Environment::GetCurrent(args);
    Local<Context> context = env->context();
    ProcessWrap* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
    THROW_IF_INSUFFICIENT_PERMISSIONS(
        env, permission::PermissionScope::kChildProcess, """");

    Local<Object> js_options =
        args[0]->ToObject(env->context()).ToLocalChecked();

    uv_process_options_t options;
    memset(&options, 0, sizeof(uv_process_options_t));

    options.exit_cb = OnExit;

    // options.uid
    Local<Value> uid_v =
        js_options->Get(context, env->uid_string()).ToLocalChecked();
    if (!uid_v->IsUndefined() && !uid_v->IsNull()) {
      CHECK(uid_v->IsInt32());
      const int32_t uid = uid_v.As<Int32>()->Value();
      options.flags |= UV_PROCESS_SETUID;
      options.uid = static_cast<uv_uid_t>(uid);
    }

    // options.gid
    Local<Value> gid_v =
        js_options->Get(context, env->gid_string()).ToL...",3,3,process_wrap.cc,node.anonymous_namespace_8.ProcessWrap.Spawn,,false,146,291,Spawn,,,6,void node.anonymous_namespace_8.ProcessWrap.Spawn (FunctionCallbackInfo<Value>)
275849,METHOD,node.anonymous_namespace_1.ProcessWrap,TYPE_DECL,"static void Kill(const FunctionCallbackInfo<Value>& args) {
    Environment* env = Environment::GetCurrent(args);
    ProcessWrap* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
    int signal = args[0]->Int32Value(env->context()).FromJust();
    int err = uv_process_kill(&wrap->process_, signal);
    args.GetReturnValue().Set(err);
  }",3,3,process_wrap.cc,node.anonymous_namespace_10.ProcessWrap.Kill,,false,293,300,Kill,,,7,void node.anonymous_namespace_10.ProcessWrap.Kill (FunctionCallbackInfo<Value>)
275903,METHOD,node.anonymous_namespace_1.ProcessWrap,TYPE_DECL,"static void OnExit(uv_process_t* handle,
                     int64_t exit_status,
                     int term_signal) {
    ProcessWrap* wrap = ContainerOf(&ProcessWrap::process_, handle);
    CHECK_EQ(&wrap->process_, handle);

    Environment* env = wrap->env();
    HandleScope handle_scope(env->isolate());
    Context::Scope context_scope(env->context());

    Local<Value> argv[] = {
      Number::New(env->isolate(), static_cast<double>(exit_status)),
      OneByteString(env->isolate(), signo_string(term_signal))
    };

    wrap->MakeCallback(env->onexit_string(), arraysize(argv), argv);
  }",3,3,process_wrap.cc,node.anonymous_namespace_11.ProcessWrap.OnExit,,false,302,318,OnExit,,,8,"void node.anonymous_namespace_11.ProcessWrap.OnExit (uv_process_t*,int64_t,int)"
276006,METHOD,quic\bindingdata.cc:<global>,TYPE_DECL,<global>,1,48,quic\bindingdata.cc,quic\bindingdata.cc:<global>,,false,1,209,<global>,,,1,
276031,METHOD,quic\bindingdata.hpp:<global>,TYPE_DECL,<global>,1,62,quic\bindingdata.hpp,quic\bindingdata.hpp:<global>,,false,1,210,<global>,,,1,
276046,METHOD,quic\cid.cc:<global>,TYPE_DECL,<global>,1,48,quic\cid.cc,quic\cid.cc:<global>,,false,1,148,<global>,,,1,
276057,METHOD,quic\cid.hpp:<global>,TYPE_DECL,<global>,1,62,quic\cid.hpp,quic\cid.hpp:<global>,,false,1,126,<global>,,,1,
276076,METHOD,quic\data.cc:<global>,TYPE_DECL,<global>,1,48,quic\data.cc,quic\data.cc:<global>,,false,1,268,<global>,,,1,
276095,METHOD,quic\data.hpp:<global>,TYPE_DECL,<global>,1,62,quic\data.hpp,quic\data.hpp:<global>,,false,1,140,<global>,,,1,
276110,METHOD,quic\defs.hpp:<global>,TYPE_DECL,<global>,1,20,quic\defs.hpp,quic\defs.hpp:<global>,,false,1,102,<global>,,,1,
276114,METHOD,quic\defs.hpp:<global>,TYPE_DECL,"bool SetOption(Environment* env,
               Opt* options,
               const v8::Local<v8::Object>& object,
               const v8::Local<v8::String>& name) {
  v8::Local<v8::Value> value;
  if (!object->Get(env->context(), name).ToLocal(&value)) return false;
  if (!value->IsUndefined()) {
    Utf8Value utf8(env->isolate(), value);
    options->*member = *utf8;
  }
  return true;
}",1,1,quic\defs.hpp,node.quic.SetOption,,false,13,24,SetOption,,,1,"bool node.quic.SetOption<Opt,std::stringOpt::*> (Environment*,Opt*,ANY,ANY)"
276172,METHOD,quic\defs.hpp:<global>,TYPE_DECL,"bool SetOption(Environment* env,
               Opt* options,
               const v8::Local<v8::Object>& object,
               const v8::Local<v8::String>& name) {
  v8::Local<v8::Value> value;
  if (!object->Get(env->context(), name).ToLocal(&value)) return false;
  if (!value->IsUndefined()) {
    CHECK(value->IsBoolean());
    options->*member = value->IsTrue();
  }
  return true;
}",1,1,quic\defs.hpp,node.quic.SetOption,,false,27,38,SetOption,,,2,"bool node.quic.SetOption<Opt,boolOpt::*> (Environment*,Opt*,ANY,ANY)"
276230,METHOD,quic\defs.hpp:<global>,TYPE_DECL,"bool SetOption(Environment* env,
               Opt* options,
               const v8::Local<v8::Object>& object,
               const v8::Local<v8::String>& name) {
  v8::Local<v8::Value> value;
  if (!object->Get(env->context(), name).ToLocal(&value)) return false;

  if (!value->IsUndefined()) {
    CHECK_IMPLIES(!value->IsBigInt(), value->IsNumber());

    uint64_t val = 0;
    if (value->IsBigInt()) {
      bool lossless = true;
      val = value.As<v8::BigInt>()->Uint64Value(&lossless);
      if (!lossless) {
        Utf8Value label(env->isolate(), name);
        THROW_ERR_OUT_OF_RANGE(
            env, (""options."" + label.ToString() + "" is out of range"").c_str());
        return false;
      }
    } else {
      val = static_cast<int64_t>(value.As<v8::Number>()->Value());
    }
    options->*member = val;
  }
  return true;
}",1,1,quic\defs.hpp,node.quic.SetOption,,false,41,67,SetOption,,,3,"bool node.quic.SetOption<Opt,uint64_tOpt::*> (Environment*,Opt*,ANY,ANY)"
276354,METHOD,quic\defs.hpp:<global>,TYPE_DECL,"void IncrementStat(Stats* stats, uint64_t amt = 1) {
  stats->*member += amt;
}",1,1,quic\defs.hpp,node.quic.IncrementStat,,false,74,76,IncrementStat,,,4,"void node.quic.IncrementStat<Stats,uint64_tStats::*> (Stats*,uint64_t)"
276365,METHOD,quic\defs.hpp:<global>,TYPE_DECL,"void RecordTimestampStat(Stats* stats) {
  stats->*member = uv_hrtime();
}",1,1,quic\defs.hpp,node.quic.RecordTimestampStat,,false,79,81,RecordTimestampStat,,,5,"void node.quic.RecordTimestampStat<Stats,uint64_tStats::*> (Stats*)"
276375,METHOD,quic\defs.hpp:<global>,TYPE_DECL,"void SetStat(Stats* stats, uint64_t val) {
  stats->*member = val;
}",1,1,quic\defs.hpp,node.quic.SetStat,,false,84,86,SetStat,,,6,"void node.quic.SetStat<Stats,uint64_tStats::*> (Stats*,uint64_t)"
276386,METHOD,quic\defs.hpp:<global>,TYPE_DECL,"uint64_t GetStat(Stats* stats) {
  return stats->*member;
}",1,1,quic\defs.hpp,node.quic.GetStat,,false,89,91,GetStat,,,7,"uint64_t node.quic.GetStat<Stats,uint64_tStats::*> (Stats*)"
276418,METHOD,quic\logstream.cc:<global>,TYPE_DECL,<global>,1,48,quic\logstream.cc,quic\logstream.cc:<global>,,false,1,152,<global>,,,1,
276433,METHOD,quic\logstream.hpp:<global>,TYPE_DECL,<global>,1,62,quic\logstream.hpp,quic\logstream.hpp:<global>,,false,1,83,<global>,,,1,
276466,METHOD,quic\packet.cc:<global>,TYPE_DECL,<global>,1,48,quic\packet.cc,quic\packet.cc:<global>,,false,1,406,<global>,,,1,
276497,METHOD,quic\packet.hpp:<global>,TYPE_DECL,<global>,1,62,quic\packet.hpp,quic\packet.hpp:<global>,,false,1,168,<global>,,,1,
276518,METHOD,quic\preferredaddress.cc:<global>,TYPE_DECL,<global>,1,48,quic\preferredaddress.cc,quic\preferredaddress.cc:<global>,,false,1,159,<global>,,,1,
276533,METHOD,quic\preferredaddress.hpp:<global>,TYPE_DECL,<global>,1,62,quic\preferredaddress.hpp,quic\preferredaddress.hpp:<global>,,false,1,72,<global>,,,1,
276550,METHOD,quic\sessionticket.cc:<global>,TYPE_DECL,<global>,1,48,quic\sessionticket.cc,quic\sessionticket.cc:<global>,,false,1,177,<global>,,,1,
276567,METHOD,quic\sessionticket.hpp:<global>,TYPE_DECL,<global>,1,62,quic\sessionticket.hpp,quic\sessionticket.hpp:<global>,,false,1,112,<global>,,,1,
276596,METHOD,quic\tlscontext.cc:<global>,TYPE_DECL,<global>,1,48,quic\tlscontext.cc,quic\tlscontext.cc:<global>,,false,1,589,<global>,,,1,
276617,METHOD,quic\tlscontext.hpp:<global>,TYPE_DECL,<global>,1,62,quic\tlscontext.hpp,quic\tlscontext.hpp:<global>,,false,1,176,<global>,,,1,
276636,METHOD,quic\tokens.cc:<global>,TYPE_DECL,<global>,1,48,quic\tokens.cc,quic\tokens.cc:<global>,,false,1,255,<global>,,,1,
276651,METHOD,quic\tokens.hpp:<global>,TYPE_DECL,<global>,1,62,quic\tokens.hpp,quic\tokens.hpp:<global>,,false,1,245,<global>,,,1,
276674,METHOD,quic\transportparams.cc:<global>,TYPE_DECL,<global>,1,48,quic\transportparams.cc,quic\transportparams.cc:<global>,,false,1,218,<global>,,,1,
276695,METHOD,quic\transportparams.hpp:<global>,TYPE_DECL,<global>,1,62,quic\transportparams.hpp,quic\transportparams.hpp:<global>,,false,1,162,<global>,,,1,
276706,METHOD,req_wrap-inl.hpp:<global>,TYPE_DECL,<global>,1,30,req_wrap-inl.hpp,req_wrap-inl.hpp:<global>,,false,1,171,<global>,,,1,
276717,METHOD,req_wrap.hpp:<global>,TYPE_DECL,<global>,1,26,req_wrap.hpp,req_wrap.hpp:<global>,,false,1,77,<global>,,,1,
276720,METHOD,node.anonymous_namespace_1.SignalWrap,TYPE_DECL,"[](uv_signal_t* handle, int signum) {
          SignalWrap* wrap = ContainerOf(&SignalWrap::handle_, handle);
          Environment* env = wrap->env();
          HandleScope handle_scope(env->isolate());
          Context::Scope context_scope(env->context());
          Local<Value> arg = Integer::New(env->isolate(), signum);
          wrap->MakeCallback(env->onsignal_string(), 1, &arg);
        }",9,9,signal_wrap.cc,node.anonymous_namespace_11.SignalWrap.Start.<lambda>0,,false,123,130,<lambda>0,,,1,"ANY node.anonymous_namespace_11.SignalWrap.Start.<lambda>0 (uv_signal_t*,int)"
276799,METHOD,signal_wrap.cc:<global>,TYPE_DECL,<global>,1,1,signal_wrap.cc,signal_wrap.cc:<global>,,false,1,179,<global>,,,1,
276802,METHOD,signal_wrap.cc:<global>,TYPE_DECL,void DecreaseSignalHandlerCount(int signum);,6,43,signal_wrap.cc,node.DecreaseSignalHandlerCount,,false,42,42,DecreaseSignalHandlerCount,,,1,void node.DecreaseSignalHandlerCount (int)
276810,METHOD,node.anonymous_namespace_1.SignalWrap,TYPE_DECL,"static void Initialize(Local<Object> target,
                         Local<Value> unused,
                         Local<Context> context,
                         void* priv) {
    Environment* env = Environment::GetCurrent(context);
    Isolate* isolate = env->isolate();
    Local<FunctionTemplate> constructor = NewFunctionTemplate(isolate, New);
    constructor->InstanceTemplate()->SetInternalFieldCount(
        SignalWrap::kInternalFieldCount);
    constructor->Inherit(HandleWrap::GetConstructorTemplate(env));

    SetProtoMethod(isolate, constructor, ""start"", Start);
    SetProtoMethod(isolate, constructor, ""stop"", Stop);

    SetConstructorFunction(context, target, ""Signal"", constructor);
  }",3,3,signal_wrap.cc,node.anonymous_namespace_2.SignalWrap.Initialize,,false,51,66,Initialize,,,1,"void node.anonymous_namespace_2.SignalWrap.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
276876,METHOD,node.anonymous_namespace_1.SignalWrap,TYPE_DECL,"static void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
    registry->Register(New);
    registry->Register(Start);
    registry->Register(Stop);
  }",3,3,signal_wrap.cc,node.anonymous_namespace_5.SignalWrap.RegisterExternalReferences,,false,68,72,RegisterExternalReferences,,,2,void node.anonymous_namespace_5.SignalWrap.RegisterExternalReferences (ExternalReferenceRegistry*)
276897,METHOD,node.anonymous_namespace_1.SignalWrap,TYPE_DECL,"SignalWrap(Environment* env, Local<Object> object)
      : HandleWrap(env,
                   object,
                   reinterpret_cast<uv_handle_t*>(&handle_),
                   AsyncWrap::PROVIDER_SIGNALWRAP) {
    int r = uv_signal_init(env->event_loop(), &handle_);
    CHECK_EQ(r, 0);
  }",3,3,signal_wrap.cc,node.anonymous_namespace_8.SignalWrap.SignalWrap,,false,88,95,SignalWrap,,,4,"ANY node.anonymous_namespace_8.SignalWrap.SignalWrap (Environment*,Local<Object>)"
276916,METHOD,node.anonymous_namespace_1.SignalWrap,TYPE_DECL,"void Close(v8::Local<v8::Value> close_callback) override {
    if (active_) {
      DecreaseSignalHandlerCount(handle_.signum);
      active_ = false;
    }
    HandleWrap::Close(close_callback);
  }",3,3,signal_wrap.cc,node.anonymous_namespace_9.SignalWrap.Close,,false,97,103,Close,,,5,void node.anonymous_namespace_9.SignalWrap.Close (ANY)
276936,METHOD,node.anonymous_namespace_1.SignalWrap,TYPE_DECL,"static void Start(const FunctionCallbackInfo<Value>& args) {
    SignalWrap* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
    Environment* env = wrap->env();
    int signum;
    if (!args[0]->Int32Value(env->context()).To(&signum)) return;
#if defined(__POSIX__) && HAVE_INSPECTOR
    if (signum == SIGPROF) {
      Environment* env = Environment::GetCurrent(args);
      if (env->inspector_agent()->IsListening()) {
        ProcessEmitWarning(env,
                           ""process.on(SIGPROF) is reserved while debugging"");
        return;
      }
    }
#endif
    int err = uv_signal_start(
        &wrap->handle_,
        [](uv_signal_t* handle, int signum) {
          SignalWrap* wrap = ContainerOf(&SignalWrap::handle_, handle);
          Environment* env = wrap->env();
          HandleScope handle_scope(env->isolate());
          Context::Scope context_scope(env->context());
          Local<Value> arg = Integer::New(env->isolate(), signum);
          wrap->MakeCallback(e...",3,3,signal_wrap.cc,node.anonymous_namespace_10.SignalWrap.Start,,false,105,141,Start,,,6,void node.anonymous_namespace_10.SignalWrap.Start (FunctionCallbackInfo<Value>)
277015,METHOD,node.anonymous_namespace_1.SignalWrap,TYPE_DECL,"static void Stop(const FunctionCallbackInfo<Value>& args) {
    SignalWrap* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

    if (wrap->active_)  {
      wrap->active_ = false;
      DecreaseSignalHandlerCount(wrap->handle_.signum);
    }

    int err = uv_signal_stop(&wrap->handle_);
    args.GetReturnValue().Set(err);
  }",3,3,signal_wrap.cc,node.anonymous_namespace_12.SignalWrap.Stop,,false,143,154,Stop,,,7,void node.anonymous_namespace_12.SignalWrap.Stop (FunctionCallbackInfo<Value>)
277062,METHOD,<empty>,<empty>,<empty>,1,,signal_wrap.cc,node.anonymous_namespace_1.SignalWrap:<clinit>,,false,49,,<clinit>,,,10,
277069,METHOD,signal_wrap.cc:<global>,TYPE_DECL,"void DecreaseSignalHandlerCount(int signum) {
  Mutex::ScopedLock lock(handled_signals_mutex);
  int64_t new_handler_count = --handled_signals[signum];
  CHECK_GE(new_handler_count, 0);
  if (new_handler_count == 0)
    handled_signals.erase(signum);
}",1,1,signal_wrap.cc,node.DecreaseSignalHandlerCount,,false,163,169,DecreaseSignalHandlerCount,,,3,void node.DecreaseSignalHandlerCount (int)
277097,METHOD,signal_wrap.cc:<global>,TYPE_DECL,"bool HasSignalJSHandler(int signum) {
  Mutex::ScopedLock lock(handled_signals_mutex);
  return handled_signals.find(signum) != handled_signals.end();
}",1,1,signal_wrap.cc,node.HasSignalJSHandler,,false,171,174,HasSignalJSHandler,,,4,bool node.HasSignalJSHandler (int)
277134,METHOD,spawn_sync.cc:<global>,TYPE_DECL,<global>,1,1,spawn_sync.cc,spawn_sync.cc:<global>,,false,1,1109,<global>,,,1,
277137,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"void SyncProcessOutputBuffer::OnAlloc(size_t suggested_size,
                                      uv_buf_t* buf) const {
  if (used() == kBufferSize)
    *buf = uv_buf_init(nullptr, 0);
  else
    *buf = uv_buf_init(data_ + used(), available());
}",1,1,spawn_sync.cc,node.SyncProcessOutputBuffer.OnAlloc,,false,53,59,OnAlloc,,,1,"void node.SyncProcessOutputBuffer.OnAlloc (size_t,uv_buf_t*)"
277164,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"void SyncProcessOutputBuffer::OnRead(const uv_buf_t* buf, size_t nread) {
  // If we hand out the same chunk twice, this should catch it.
  CHECK_EQ(buf->base, data_ + used());
  used_ += static_cast<unsigned int>(nread);
}",1,1,spawn_sync.cc,node.SyncProcessOutputBuffer.OnRead,,false,62,66,OnRead,,,2,"void node.SyncProcessOutputBuffer.OnRead (uv_buf_t*,size_t)"
277182,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"size_t SyncProcessOutputBuffer::Copy(char* dest) const {
  memcpy(dest, data_, used());
  return used();
}",1,1,spawn_sync.cc,node.SyncProcessOutputBuffer.Copy,,false,69,72,Copy,,,3,size_t node.SyncProcessOutputBuffer.Copy (char*)
277193,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"unsigned int SyncProcessOutputBuffer::available() const {
  return sizeof data_ - used();
}",1,1,spawn_sync.cc,node.SyncProcessOutputBuffer.available,,false,75,77,available,,,4,unsigned int node.SyncProcessOutputBuffer.available ()
277202,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"unsigned int SyncProcessOutputBuffer::used() const {
  return used_;
}",1,1,spawn_sync.cc,node.SyncProcessOutputBuffer.used,,false,80,82,used,,,5,unsigned int node.SyncProcessOutputBuffer.used ()
277208,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"SyncProcessOutputBuffer* SyncProcessOutputBuffer::next() const {
  return next_;
}",1,1,spawn_sync.cc,node.SyncProcessOutputBuffer.next,,false,85,87,next,,,6,SyncProcessOutputBuffer node.SyncProcessOutputBuffer.next ()
277214,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"void SyncProcessOutputBuffer::set_next(SyncProcessOutputBuffer* next) {
  next_ = next;
}",1,1,spawn_sync.cc,node.SyncProcessOutputBuffer.set_next,,false,90,92,set_next,,,7,void node.SyncProcessOutputBuffer.set_next (SyncProcessOutputBuffer*)
277222,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"SyncProcessStdioPipe::SyncProcessStdioPipe(SyncProcessRunner* process_handler,
                                           bool readable,
                                           bool writable,
                                           uv_buf_t input_buffer)
    : process_handler_(process_handler),
      readable_(readable),
      writable_(writable),
      input_buffer_(input_buffer),

      first_output_buffer_(nullptr),
      last_output_buffer_(nullptr),

      uv_pipe_(),
      write_req_(),
      shutdown_req_(),

      lifecycle_(kUninitialized) {
  CHECK(readable || writable);
}",1,1,spawn_sync.cc,node.SyncProcessStdioPipe.SyncProcessStdioPipe,,false,95,113,SyncProcessStdioPipe,,,8,"ANY node.SyncProcessStdioPipe.SyncProcessStdioPipe (SyncProcessRunner*,bool,bool,uv_buf_t)"
277234,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"SyncProcessStdioPipe::~SyncProcessStdioPipe() {
  CHECK(lifecycle_ == kUninitialized || lifecycle_ == kClosed);

  SyncProcessOutputBuffer* buf;
  SyncProcessOutputBuffer* next;

  for (buf = first_output_buffer_; buf != nullptr; buf = next) {
    next = buf->next();
    delete buf;
  }
}",1,1,spawn_sync.cc,node.SyncProcessStdioPipe.~SyncProcessStdioPipe,,false,116,126,~SyncProcessStdioPipe,,,9,ANY node.SyncProcessStdioPipe.~SyncProcessStdioPipe ()
277268,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"int SyncProcessStdioPipe::Initialize(uv_loop_t* loop) {
  CHECK_EQ(lifecycle_, kUninitialized);

  int r = uv_pipe_init(loop, uv_pipe(), 0);
  if (r < 0)
    return r;

  uv_pipe()->data = this;

  lifecycle_ = kInitialized;
  return 0;
}",1,1,spawn_sync.cc,node.SyncProcessStdioPipe.Initialize,,false,129,140,Initialize,,,10,int node.SyncProcessStdioPipe.Initialize (uv_loop_t*)
277300,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"int SyncProcessStdioPipe::Start() {
  CHECK_EQ(lifecycle_, kInitialized);

  // Set the busy flag already. If this function fails no recovery is
  // possible.
  lifecycle_ = kStarted;

  if (readable()) {
    if (input_buffer_.len > 0) {
      CHECK_NOT_NULL(input_buffer_.base);

      int r = uv_write(&write_req_,
                       uv_stream(),
                       &input_buffer_,
                       1,
                       WriteCallback);
      if (r < 0)
        return r;
    }

    int r = uv_shutdown(&shutdown_req_, uv_stream(), ShutdownCallback);
    if (r < 0)
      return r;
  }

  if (writable()) {
    int r = uv_read_start(uv_stream(), AllocCallback, ReadCallback);
    if (r < 0)
      return r;
  }

  return 0;
}",1,1,spawn_sync.cc,node.SyncProcessStdioPipe.Start,,false,143,175,Start,,,11,int node.SyncProcessStdioPipe.Start ()
277376,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"void SyncProcessStdioPipe::Close() {
  CHECK(lifecycle_ == kInitialized || lifecycle_ == kStarted);

  uv_close(uv_handle(), CloseCallback);

  lifecycle_ = kClosing;
}",1,1,spawn_sync.cc,node.SyncProcessStdioPipe.Close,,false,178,184,Close,,,12,void node.SyncProcessStdioPipe.Close ()
277394,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"Local<Object> SyncProcessStdioPipe::GetOutputAsBuffer(Environment* env) const {
  size_t length = OutputLength();
  Local<Object> js_buffer = Buffer::New(env, length).ToLocalChecked();
  CopyOutput(Buffer::Data(js_buffer));
  return js_buffer;
}",1,1,spawn_sync.cc,node.SyncProcessStdioPipe.GetOutputAsBuffer,,false,187,192,GetOutputAsBuffer,,,13,Local<Object> node.SyncProcessStdioPipe.GetOutputAsBuffer (Environment*)
277426,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"bool SyncProcessStdioPipe::readable() const {
  return readable_;
}",1,1,spawn_sync.cc,node.SyncProcessStdioPipe.readable,,false,195,197,readable,,,14,bool node.SyncProcessStdioPipe.readable ()
277432,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"bool SyncProcessStdioPipe::writable() const {
  return writable_;
}",1,1,spawn_sync.cc,node.SyncProcessStdioPipe.writable,,false,200,202,writable,,,15,bool node.SyncProcessStdioPipe.writable ()
277438,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"uv_stdio_flags SyncProcessStdioPipe::uv_flags() const {
  unsigned int flags;

  flags = UV_CREATE_PIPE;
  if (readable())
    flags |= UV_READABLE_PIPE;
  if (writable())
    flags |= UV_WRITABLE_PIPE;

  return static_cast<uv_stdio_flags>(flags);
}",1,1,spawn_sync.cc,node.SyncProcessStdioPipe.uv_flags,,false,205,215,uv_flags,,,16,uv_stdio_flags node.SyncProcessStdioPipe.uv_flags ()
277462,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"uv_pipe_t* SyncProcessStdioPipe::uv_pipe() const {
  CHECK_LT(lifecycle_, kClosing);
  return &uv_pipe_;
}",1,1,spawn_sync.cc,node.SyncProcessStdioPipe.uv_pipe,,false,218,221,uv_pipe,,,17,uv_pipe_t node.SyncProcessStdioPipe.uv_pipe ()
277472,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"uv_stream_t* SyncProcessStdioPipe::uv_stream() const {
  return reinterpret_cast<uv_stream_t*>(uv_pipe());
}",1,1,spawn_sync.cc,node.SyncProcessStdioPipe.uv_stream,,false,224,226,uv_stream,,,18,uv_stream_t node.SyncProcessStdioPipe.uv_stream ()
277480,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"uv_handle_t* SyncProcessStdioPipe::uv_handle() const {
  return reinterpret_cast<uv_handle_t*>(uv_pipe());
}",1,1,spawn_sync.cc,node.SyncProcessStdioPipe.uv_handle,,false,229,231,uv_handle,,,19,uv_handle_t node.SyncProcessStdioPipe.uv_handle ()
277488,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"size_t SyncProcessStdioPipe::OutputLength() const {
  SyncProcessOutputBuffer* buf;
  size_t size = 0;

  for (buf = first_output_buffer_; buf != nullptr; buf = buf->next())
    size += buf->used();

  return size;
}",1,1,spawn_sync.cc,node.SyncProcessStdioPipe.OutputLength,,false,234,242,OutputLength,,,20,size_t node.SyncProcessStdioPipe.OutputLength ()
277519,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"void SyncProcessStdioPipe::CopyOutput(char* dest) const {
  SyncProcessOutputBuffer* buf;
  size_t offset = 0;

  for (buf = first_output_buffer_; buf != nullptr; buf = buf->next())
    offset += buf->Copy(dest + offset);
}",1,1,spawn_sync.cc,node.SyncProcessStdioPipe.CopyOutput,,false,245,251,CopyOutput,,,21,void node.SyncProcessStdioPipe.CopyOutput (char*)
277552,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"void SyncProcessStdioPipe::OnAlloc(size_t suggested_size, uv_buf_t* buf) {
  // This function assumes that libuv will never allocate two buffers for the
  // same stream at the same time. There's an assert in
  // SyncProcessOutputBuffer::OnRead that would fail if this assumption was
  // ever violated.

  if (last_output_buffer_ == nullptr) {
    // Allocate the first capture buffer.
    first_output_buffer_ = new SyncProcessOutputBuffer();
    last_output_buffer_ = first_output_buffer_;

  } else if (last_output_buffer_->available() == 0) {
    // The current capture buffer is full so get us a new one.
    SyncProcessOutputBuffer* buf = new SyncProcessOutputBuffer();
    last_output_buffer_->set_next(buf);
    last_output_buffer_ = buf;
  }

  last_output_buffer_->OnAlloc(suggested_size, buf);
}",1,1,spawn_sync.cc,node.SyncProcessStdioPipe.OnAlloc,,false,254,273,OnAlloc,,,22,"void node.SyncProcessStdioPipe.OnAlloc (size_t,uv_buf_t*)"
277599,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"void SyncProcessStdioPipe::OnRead(const uv_buf_t* buf, ssize_t nread) {
  if (nread == UV_EOF) {
    // Libuv implicitly stops reading on EOF.

  } else if (nread < 0) {
    SetError(static_cast<int>(nread));
    // At some point libuv should really implicitly stop reading on error.
    uv_read_stop(uv_stream());

  } else {
    last_output_buffer_->OnRead(buf, nread);
    process_handler_->IncrementBufferSizeAndCheckOverflow(nread);
  }
}",1,1,spawn_sync.cc,node.SyncProcessStdioPipe.OnRead,,false,276,289,OnRead,,,23,"void node.SyncProcessStdioPipe.OnRead (uv_buf_t*,ssize_t)"
277635,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"void SyncProcessStdioPipe::OnWriteDone(int result) {
  if (result < 0)
    SetError(result);
}",1,1,spawn_sync.cc,node.SyncProcessStdioPipe.OnWriteDone,,false,292,295,OnWriteDone,,,24,void node.SyncProcessStdioPipe.OnWriteDone (int)
277647,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"void SyncProcessStdioPipe::OnShutdownDone(int result) {
  if (result < 0)
    SetError(result);
}",1,1,spawn_sync.cc,node.SyncProcessStdioPipe.OnShutdownDone,,false,298,301,OnShutdownDone,,,25,void node.SyncProcessStdioPipe.OnShutdownDone (int)
277659,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"void SyncProcessStdioPipe::OnClose() {
  lifecycle_ = kClosed;
}",1,1,spawn_sync.cc,node.SyncProcessStdioPipe.OnClose,,false,304,306,OnClose,,,26,void node.SyncProcessStdioPipe.OnClose ()
277666,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"void SyncProcessStdioPipe::SetError(int error) {
  CHECK_NE(error, 0);
  process_handler_->SetPipeError(error);
}",1,1,spawn_sync.cc,node.SyncProcessStdioPipe.SetError,,false,309,312,SetError,,,27,void node.SyncProcessStdioPipe.SetError (int)
277679,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"void SyncProcessStdioPipe::AllocCallback(uv_handle_t* handle,
                                         size_t suggested_size,
                                         uv_buf_t* buf) {
  SyncProcessStdioPipe* self =
      reinterpret_cast<SyncProcessStdioPipe*>(handle->data);
  self->OnAlloc(suggested_size, buf);
}",1,1,spawn_sync.cc,node.SyncProcessStdioPipe.AllocCallback,,false,315,321,AllocCallback,,,28,"void node.SyncProcessStdioPipe.AllocCallback (uv_handle_t*,size_t,uv_buf_t*)"
277700,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"void SyncProcessStdioPipe::ReadCallback(uv_stream_t* stream,
                                        ssize_t nread,
                                        const uv_buf_t* buf) {
  SyncProcessStdioPipe* self =
        reinterpret_cast<SyncProcessStdioPipe*>(stream->data);
  self->OnRead(buf, nread);
}",1,1,spawn_sync.cc,node.SyncProcessStdioPipe.ReadCallback,,false,324,330,ReadCallback,,,29,"void node.SyncProcessStdioPipe.ReadCallback (uv_stream_t*,ssize_t,uv_buf_t*)"
277721,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"void SyncProcessStdioPipe::WriteCallback(uv_write_t* req, int result) {
  SyncProcessStdioPipe* self =
      reinterpret_cast<SyncProcessStdioPipe*>(req->handle->data);
  self->OnWriteDone(result);
}",1,1,spawn_sync.cc,node.SyncProcessStdioPipe.WriteCallback,,false,333,337,WriteCallback,,,30,"void node.SyncProcessStdioPipe.WriteCallback (uv_write_t*,int)"
277742,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"void SyncProcessStdioPipe::ShutdownCallback(uv_shutdown_t* req, int result) {
  SyncProcessStdioPipe* self =
      reinterpret_cast<SyncProcessStdioPipe*>(req->handle->data);

  // On AIX, OS X and the BSDs, calling shutdown() on one end of a pipe
  // when the other end has closed the connection fails with ENOTCONN.
  // Libuv is not the right place to handle that because it can't tell
  // if the error is genuine but we here can.
  if (result == UV_ENOTCONN)
    result = 0;

  self->OnShutdownDone(result);
}",1,1,spawn_sync.cc,node.SyncProcessStdioPipe.ShutdownCallback,,false,340,352,ShutdownCallback,,,31,"void node.SyncProcessStdioPipe.ShutdownCallback (uv_shutdown_t*,int)"
277771,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"void SyncProcessStdioPipe::CloseCallback(uv_handle_t* handle) {
  SyncProcessStdioPipe* self =
      reinterpret_cast<SyncProcessStdioPipe*>(handle->data);
  self->OnClose();
}",1,1,spawn_sync.cc,node.SyncProcessStdioPipe.CloseCallback,,false,355,359,CloseCallback,,,32,void node.SyncProcessStdioPipe.CloseCallback (uv_handle_t*)
277788,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"void SyncProcessRunner::Initialize(Local<Object> target,
                                   Local<Value> unused,
                                   Local<Context> context,
                                   void* priv) {
  SetMethod(context, target, ""spawn"", Spawn);
}",1,1,spawn_sync.cc,node.SyncProcessRunner.Initialize,,false,362,367,Initialize,,,33,"void node.SyncProcessRunner.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
277801,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"void SyncProcessRunner::Spawn(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kChildProcess, """");
  env->PrintSyncTrace();
  SyncProcessRunner p(env);
  Local<Value> result;
  if (!p.Run(args[0]).ToLocal(&result)) return;
  args.GetReturnValue().Set(result);
}",1,1,spawn_sync.cc,node.SyncProcessRunner.Spawn,,false,370,379,Spawn,,,34,void node.SyncProcessRunner.Spawn (FunctionCallbackInfo<Value>)
277858,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"SyncProcessRunner::SyncProcessRunner(Environment* env)
    : max_buffer_(0),
      timeout_(0),
      kill_signal_(SIGTERM),

      uv_loop_(nullptr),

      stdio_count_(0),
      uv_stdio_containers_(nullptr),
      stdio_pipes_initialized_(false),

      uv_process_options_(),
      file_buffer_(nullptr),
      args_buffer_(nullptr),
      env_buffer_(nullptr),
      cwd_buffer_(nullptr),

      uv_process_(),
      killed_(false),

      buffered_output_size_(0),
      exit_status_(-1),
      term_signal_(-1),

      uv_timer_(),
      kill_timer_initialized_(false),

      error_(0),
      pipe_error_(0),

      lifecycle_(kUninitialized),

      env_(env) {
}",1,1,spawn_sync.cc,node.SyncProcessRunner.SyncProcessRunner,,false,382,415,SyncProcessRunner,,,35,ANY node.SyncProcessRunner.SyncProcessRunner (Environment*)
277863,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"SyncProcessRunner::~SyncProcessRunner() {
  CHECK_EQ(lifecycle_, kHandlesClosed);

  stdio_pipes_.clear();
  delete[] file_buffer_;
  delete[] args_buffer_;
  delete[] cwd_buffer_;
  delete[] env_buffer_;
  delete[] uv_stdio_containers_;
}",1,1,spawn_sync.cc,node.SyncProcessRunner.~SyncProcessRunner,,false,418,427,~SyncProcessRunner,,,36,ANY node.SyncProcessRunner.~SyncProcessRunner ()
277884,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"Environment* SyncProcessRunner::env() const {
  return env_;
}",1,1,spawn_sync.cc,node.SyncProcessRunner.env,,false,430,432,env,,,37,Environment node.SyncProcessRunner.env ()
277890,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"MaybeLocal<Object> SyncProcessRunner::Run(Local<Value> options) {
  EscapableHandleScope scope(env()->isolate());

  CHECK_EQ(lifecycle_, kUninitialized);

  Maybe<bool> r = TryInitializeAndRunLoop(options);
  CloseHandlesAndDeleteLoop();
  if (r.IsNothing()) return MaybeLocal<Object>();

  Local<Object> result = BuildResultObject();

  return scope.Escape(result);
}",1,1,spawn_sync.cc,node.SyncProcessRunner.Run,,false,434,446,Run,,,38,MaybeLocal<Object> node.SyncProcessRunner.Run (Local<Value>)
277931,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"Maybe<bool> SyncProcessRunner::TryInitializeAndRunLoop(Local<Value> options) {
  int r;

  // There is no recovery from failure inside TryInitializeAndRunLoop - the
  // only option we'd have is to close all handles and destroy the loop.
  CHECK_EQ(lifecycle_, kUninitialized);
  lifecycle_ = kInitialized;

  uv_loop_ = new uv_loop_t;
  if (uv_loop_ == nullptr) {
    SetError(UV_ENOMEM);
    return Just(false);
  }

  r = uv_loop_init(uv_loop_);
  if (r < 0) {
    delete uv_loop_;
    uv_loop_ = nullptr;
    SetError(r);
    return Just(false);
  }

  if (!ParseOptions(options).To(&r)) return Nothing<bool>();

  if (r < 0) {
    SetError(r);
    return Just(false);
  }

  if (timeout_ > 0) {
    r = uv_timer_init(uv_loop_, &uv_timer_);
    if (r < 0) {
      SetError(r);
      return Just(false);
    }

    uv_unref(reinterpret_cast<uv_handle_t*>(&uv_timer_));

    uv_timer_.data = this;
    kill_timer_initialized_ = true;

    // Start the timer immediately. If uv_spawn fails then
 ...",1,1,spawn_sync.cc,node.SyncProcessRunner.TryInitializeAndRunLoop,,false,448,526,TryInitializeAndRunLoop,,,39,Maybe<bool> node.SyncProcessRunner.TryInitializeAndRunLoop (Local<Value>)
278119,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"void SyncProcessRunner::CloseHandlesAndDeleteLoop() {
  CHECK_LT(lifecycle_, kHandlesClosed);

  if (uv_loop_ != nullptr) {
    CloseStdioPipes();
    CloseKillTimer();
    // Close the process handle when ExitCallback was not called.
    uv_handle_t* uv_process_handle =
        reinterpret_cast<uv_handle_t*>(&uv_process_);

    // Close the process handle if it is still open. The handle type also
    // needs to be checked because TryInitializeAndRunLoop() won't spawn a
    // process if input validation fails.
    if (uv_process_handle->type == UV_PROCESS &&
        !uv_is_closing(uv_process_handle))
      uv_close(uv_process_handle, nullptr);

    // Give closing watchers a chance to finish closing and get their close
    // callbacks called.
    int r = uv_run(uv_loop_, UV_RUN_DEFAULT);
    if (r < 0)
      ABORT();

    CheckedUvLoopClose(uv_loop_);
    delete uv_loop_;
    uv_loop_ = nullptr;

  } else {
    // If the loop doesn't exist, neither should any pipes or timers.
   ...",1,1,spawn_sync.cc,node.SyncProcessRunner.CloseHandlesAndDeleteLoop,,false,529,563,CloseHandlesAndDeleteLoop,,,40,void node.SyncProcessRunner.CloseHandlesAndDeleteLoop ()
278183,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"void SyncProcessRunner::CloseStdioPipes() {
  CHECK_LT(lifecycle_, kHandlesClosed);

  if (stdio_pipes_initialized_) {
    CHECK(!stdio_pipes_.empty());
    CHECK_NOT_NULL(uv_loop_);

    for (const auto& pipe : stdio_pipes_) {
      if (pipe)
        pipe->Close();
    }

    stdio_pipes_initialized_ = false;
  }
}",1,1,spawn_sync.cc,node.SyncProcessRunner.CloseStdioPipes,,false,566,580,CloseStdioPipes,,,41,void node.SyncProcessRunner.CloseStdioPipes ()
278214,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"void SyncProcessRunner::CloseKillTimer() {
  CHECK_LT(lifecycle_, kHandlesClosed);

  if (kill_timer_initialized_) {
    CHECK_GT(timeout_, 0);
    CHECK_NOT_NULL(uv_loop_);

    uv_handle_t* uv_timer_handle = reinterpret_cast<uv_handle_t*>(&uv_timer_);
    uv_ref(uv_timer_handle);
    uv_close(uv_timer_handle, KillTimerCloseCallback);

    kill_timer_initialized_ = false;
  }
}",1,1,spawn_sync.cc,node.SyncProcessRunner.CloseKillTimer,,false,583,596,CloseKillTimer,,,42,void node.SyncProcessRunner.CloseKillTimer ()
278243,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"void SyncProcessRunner::Kill() {
  // Only attempt to kill once.
  if (killed_)
    return;
  killed_ = true;

  // We might get here even if the process we spawned has already exited. This
  // could happen when our child process spawned another process which
  // inherited (one of) the stdio pipes. In this case we won't attempt to send
  // a signal to the process, however we will still close our end of the stdio
  // pipes so this situation won't make us hang.
  if (exit_status_ < 0) {
    int r = uv_process_kill(&uv_process_, kill_signal_);

    // If uv_kill failed with an error that isn't ESRCH, the user probably
    // specified an invalid or unsupported signal. Signal this to the user as
    // and error and kill the process with SIGKILL instead.
    if (r < 0 && r != UV_ESRCH) {
      SetError(r);

      // Deliberately ignore the return value, we might not have
      // sufficient privileges to signal the child process.
      USE(uv_process_kill(&uv_process_, SIGKILL));
  ...",1,1,spawn_sync.cc,node.SyncProcessRunner.Kill,,false,599,630,Kill,,,43,void node.SyncProcessRunner.Kill ()
278284,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"void SyncProcessRunner::IncrementBufferSizeAndCheckOverflow(ssize_t length) {
  buffered_output_size_ += length;

  if (max_buffer_ > 0 && buffered_output_size_ > max_buffer_) {
    SetError(UV_ENOBUFS);
    Kill();
  }
}",1,1,spawn_sync.cc,node.SyncProcessRunner.IncrementBufferSizeAndCheckOverflow,,false,633,640,IncrementBufferSizeAndCheckOverflow,,,44,void node.SyncProcessRunner.IncrementBufferSizeAndCheckOverflow (ssize_t)
278303,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"void SyncProcessRunner::OnExit(int64_t exit_status, int term_signal) {
  if (exit_status < 0)
    return SetError(static_cast<int>(exit_status));

  exit_status_ = exit_status;
  term_signal_ = term_signal;
}",1,1,spawn_sync.cc,node.SyncProcessRunner.OnExit,,false,643,649,OnExit,,,45,"void node.SyncProcessRunner.OnExit (int64_t,int)"
278325,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"void SyncProcessRunner::OnKillTimerTimeout() {
  SetError(UV_ETIMEDOUT);
  Kill();
}",1,1,spawn_sync.cc,node.SyncProcessRunner.OnKillTimerTimeout,,false,652,655,OnKillTimerTimeout,,,46,void node.SyncProcessRunner.OnKillTimerTimeout ()
278331,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"int SyncProcessRunner::GetError() {
  if (error_ != 0)
    return error_;
  else
    return pipe_error_;
}",1,1,spawn_sync.cc,node.SyncProcessRunner.GetError,,false,658,663,GetError,,,47,int node.SyncProcessRunner.GetError ()
278346,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"void SyncProcessRunner::SetError(int error) {
  if (error_ == 0)
    error_ = error;
}",1,1,spawn_sync.cc,node.SyncProcessRunner.SetError,,false,666,669,SetError,,,48,void node.SyncProcessRunner.SetError (int)
278359,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"void SyncProcessRunner::SetPipeError(int pipe_error) {
  if (pipe_error_ == 0)
    pipe_error_ = pipe_error;
}",1,1,spawn_sync.cc,node.SyncProcessRunner.SetPipeError,,false,672,675,SetPipeError,,,49,void node.SyncProcessRunner.SetPipeError (int)
278372,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"Local<Object> SyncProcessRunner::BuildResultObject() {
  EscapableHandleScope scope(env()->isolate());
  Local<Context> context = env()->context();

  Local<Object> js_result = Object::New(env()->isolate());

  if (GetError() != 0) {
    js_result->Set(context, env()->error_string(),
                   Integer::New(env()->isolate(), GetError())).Check();
  }

  if (exit_status_ >= 0) {
    if (term_signal_ > 0) {
      js_result->Set(context, env()->status_string(),
                     Null(env()->isolate())).Check();
    } else {
      js_result->Set(context, env()->status_string(),
                     Number::New(env()->isolate(),
                                 static_cast<double>(exit_status_))).Check();
    }
  } else {
    // If exit_status_ < 0 the process was never started because of some error.
    js_result->Set(context, env()->status_string(),
                   Null(env()->isolate())).Check();
  }

  if (term_signal_ > 0)
    js_result->Set(context, env()->signal_stri...",1,1,spawn_sync.cc,node.SyncProcessRunner.BuildResultObject,,false,678,725,BuildResultObject,,,50,Local<Object> node.SyncProcessRunner.BuildResultObject ()
278618,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"Local<Array> SyncProcessRunner::BuildOutputArray() {
  CHECK_GE(lifecycle_, kInitialized);
  CHECK(!stdio_pipes_.empty());

  EscapableHandleScope scope(env()->isolate());
  MaybeStackBuffer<Local<Value>, 8> js_output(stdio_pipes_.size());

  for (uint32_t i = 0; i < stdio_pipes_.size(); i++) {
    SyncProcessStdioPipe* h = stdio_pipes_[i].get();
    if (h != nullptr && h->writable())
      js_output[i] = h->GetOutputAsBuffer(env());
    else
      js_output[i] = Null(env()->isolate());
  }

  return scope.Escape(
      Array::New(env()->isolate(), js_output.out(), js_output.length()));
}",1,1,spawn_sync.cc,node.SyncProcessRunner.BuildOutputArray,,false,728,745,BuildOutputArray,,,51,Local<Array> node.SyncProcessRunner.BuildOutputArray ()
278718,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"Maybe<int> SyncProcessRunner::ParseOptions(Local<Value> js_value) {
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  int r;

  if (!js_value->IsObject()) return Just<int>(UV_EINVAL);

  Local<Context> context = env()->context();
  Local<Object> js_options = js_value.As<Object>();

  Local<Value> js_file =
      js_options->Get(context, env()->file_string()).ToLocalChecked();
  if (!CopyJsString(js_file, &file_buffer_).To(&r)) return Nothing<int>();
  if (r < 0) return Just(r);
  uv_process_options_.file = file_buffer_;

  Local<Value> js_args =
      js_options->Get(context, env()->args_string()).ToLocalChecked();
  if (!CopyJsStringArray(js_args, &args_buffer_).To(&r)) return Nothing<int>();
  if (r < 0) return Just(r);
  uv_process_options_.args = reinterpret_cast<char**>(args_buffer_);

  Local<Value> js_cwd =
      js_options->Get(context, env()->cwd_string()).ToLocalChecked();
  if (IsSet(js_cwd)) {
    if (!CopyJsString(js_cwd, &cwd_buffer_).To(&r)) retur...",1,1,spawn_sync.cc,node.SyncProcessRunner.ParseOptions,,false,747,852,ParseOptions,,,52,Maybe<int> node.SyncProcessRunner.ParseOptions (Local<Value>)
279304,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"int SyncProcessRunner::ParseStdioOptions(Local<Value> js_value) {
  HandleScope scope(env()->isolate());
  Local<Array> js_stdio_options;

  if (!js_value->IsArray())
    return UV_EINVAL;

  Local<Context> context = env()->context();
  js_stdio_options = js_value.As<Array>();

  stdio_count_ = js_stdio_options->Length();
  uv_stdio_containers_ = new uv_stdio_container_t[stdio_count_];

  stdio_pipes_.clear();
  stdio_pipes_.resize(stdio_count_);
  stdio_pipes_initialized_ = true;

  for (uint32_t i = 0; i < stdio_count_; i++) {
    Local<Value> js_stdio_option =
        js_stdio_options->Get(context, i).ToLocalChecked();

    if (!js_stdio_option->IsObject())
      return UV_EINVAL;

    int r = ParseStdioOption(i, js_stdio_option.As<Object>());
    if (r < 0)
      return r;
  }

  uv_process_options_.stdio = uv_stdio_containers_;
  uv_process_options_.stdio_count = stdio_count_;

  return 0;
}",1,1,spawn_sync.cc,node.SyncProcessRunner.ParseStdioOptions,,false,855,888,ParseStdioOptions,,,53,int node.SyncProcessRunner.ParseStdioOptions (Local<Value>)
279431,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"int SyncProcessRunner::ParseStdioOption(int child_fd,
                                        Local<Object> js_stdio_option) {
  Local<Context> context = env()->context();
  Local<Value> js_type =
      js_stdio_option->Get(context, env()->type_string()).ToLocalChecked();

  if (js_type->StrictEquals(env()->ignore_string())) {
    return AddStdioIgnore(child_fd);

  } else if (js_type->StrictEquals(env()->pipe_string())) {
    Isolate* isolate = env()->isolate();
    Local<String> rs = env()->readable_string();
    Local<String> ws = env()->writable_string();

    bool readable = js_stdio_option->Get(context, rs)
        .ToLocalChecked()->BooleanValue(isolate);
    bool writable =
        js_stdio_option->Get(context, ws)
        .ToLocalChecked()->BooleanValue(isolate);

    uv_buf_t buf = uv_buf_init(nullptr, 0);

    if (readable) {
      Local<Value> input =
          js_stdio_option->Get(context, env()->input_string()).ToLocalChecked();
      if (Buffer::HasInstance(input)) {
...",1,1,spawn_sync.cc,node.SyncProcessRunner.ParseStdioOption,,false,891,938,ParseStdioOption,,,54,"int node.SyncProcessRunner.ParseStdioOption (int,Local<Object>)"
279669,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"int SyncProcessRunner::AddStdioIgnore(uint32_t child_fd) {
  CHECK_LT(child_fd, stdio_count_);
  CHECK(!stdio_pipes_[child_fd]);

  uv_stdio_containers_[child_fd].flags = UV_IGNORE;

  return 0;
}",1,1,spawn_sync.cc,node.SyncProcessRunner.AddStdioIgnore,,false,941,948,AddStdioIgnore,,,55,int node.SyncProcessRunner.AddStdioIgnore (uint32_t)
279691,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"int SyncProcessRunner::AddStdioPipe(uint32_t child_fd,
                                    bool readable,
                                    bool writable,
                                    uv_buf_t input_buffer) {
  CHECK_LT(child_fd, stdio_count_);
  CHECK(!stdio_pipes_[child_fd]);

  std::unique_ptr<SyncProcessStdioPipe> h(
      new SyncProcessStdioPipe(this, readable, writable, input_buffer));

  int r = h->Initialize(uv_loop_);
  if (r < 0) {
    h.reset();
    return r;
  }

  uv_stdio_containers_[child_fd].flags = h->uv_flags();
  uv_stdio_containers_[child_fd].data.stream = h->uv_stream();

  stdio_pipes_[child_fd] = std::move(h);

  return 0;
}",1,1,spawn_sync.cc,node.SyncProcessRunner.AddStdioPipe,,false,951,973,AddStdioPipe,,,56,"int node.SyncProcessRunner.AddStdioPipe (uint32_t,bool,bool,uv_buf_t)"
279772,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"int SyncProcessRunner::AddStdioInheritFD(uint32_t child_fd, int inherit_fd) {
  CHECK_LT(child_fd, stdio_count_);
  CHECK(!stdio_pipes_[child_fd]);

  uv_stdio_containers_[child_fd].flags = UV_INHERIT_FD;
  uv_stdio_containers_[child_fd].data.fd = inherit_fd;

  return 0;
}",1,1,spawn_sync.cc,node.SyncProcessRunner.AddStdioInheritFD,,false,976,984,AddStdioInheritFD,,,57,"int node.SyncProcessRunner.AddStdioInheritFD (uint32_t,int)"
279804,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"bool SyncProcessRunner::IsSet(Local<Value> value) {
  return !value->IsUndefined() && !value->IsNull();
}",1,1,spawn_sync.cc,node.SyncProcessRunner.IsSet,,false,987,989,IsSet,,,58,bool node.SyncProcessRunner.IsSet (Local<Value>)
279821,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"Maybe<int> SyncProcessRunner::CopyJsString(Local<Value> js_value,
                                           const char** target) {
  Isolate* isolate = env()->isolate();
  Local<String> js_string;
  size_t size, written;
  char* buffer;

  if (js_value->IsString())
    js_string = js_value.As<String>();
  else if (!js_value->ToString(env()->isolate()->GetCurrentContext())
                .ToLocal(&js_string))
    return Nothing<int>();

  // Include space for null terminator byte.
  if (!StringBytes::StorageSize(isolate, js_string, UTF8).To(&size))
    return Nothing<int>();
  size += 1;

  buffer = new char[size];

  written = StringBytes::Write(isolate, buffer, -1, js_string, UTF8);
  buffer[written] = '\0';

  *target = buffer;
  return Just(0);
}",1,1,spawn_sync.cc,node.SyncProcessRunner.CopyJsString,,false,991,1016,CopyJsString,,,59,"Maybe<int> node.SyncProcessRunner.CopyJsString (Local<Value>,char**)"
279925,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"Maybe<int> SyncProcessRunner::CopyJsStringArray(Local<Value> js_value,
                                                char** target) {
  Isolate* isolate = env()->isolate();
  Local<Array> js_array;
  uint32_t length;
  size_t list_size, data_size, data_offset;
  char** list;
  char* buffer;

  if (!js_value->IsArray()) return Just<int>(UV_EINVAL);

  Local<Context> context = env()->context();
  js_array = js_value.As<Array>()->Clone().As<Array>();
  length = js_array->Length();
  data_size = 0;

  // Index has a pointer to every string element, plus one more for a final
  // null pointer.
  list_size = (length + 1) * sizeof *list;

  // Convert all array elements to string. Modify the js object itself if
  // needed - it's okay since we cloned the original object. Also compute the
  // length of all strings, including room for a null terminator after every
  // string. Align strings to cache lines.
  for (uint32_t i = 0; i < length; i++) {
    auto value = js_array->Get(context, i...",1,1,spawn_sync.cc,node.SyncProcessRunner.CopyJsStringArray,,false,1018,1084,CopyJsStringArray,,,60,"Maybe<int> node.SyncProcessRunner.CopyJsStringArray (Local<Value>,char**)"
280182,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"void SyncProcessRunner::ExitCallback(uv_process_t* handle,
                                     int64_t exit_status,
                                     int term_signal) {
  SyncProcessRunner* self = reinterpret_cast<SyncProcessRunner*>(handle->data);
  uv_close(reinterpret_cast<uv_handle_t*>(handle), nullptr);
  self->OnExit(exit_status, term_signal);
}",1,1,spawn_sync.cc,node.SyncProcessRunner.ExitCallback,,false,1087,1093,ExitCallback,,,61,"void node.SyncProcessRunner.ExitCallback (uv_process_t*,int64_t,int)"
280208,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"void SyncProcessRunner::KillTimerCallback(uv_timer_t* handle) {
  SyncProcessRunner* self = reinterpret_cast<SyncProcessRunner*>(handle->data);
  self->OnKillTimerTimeout();
}",1,1,spawn_sync.cc,node.SyncProcessRunner.KillTimerCallback,,false,1096,1099,KillTimerCallback,,,62,void node.SyncProcessRunner.KillTimerCallback (uv_timer_t*)
280225,METHOD,spawn_sync.cc:<global>,TYPE_DECL,"void SyncProcessRunner::KillTimerCloseCallback(uv_handle_t* handle) {
  // No-op.
}",1,1,spawn_sync.cc,node.SyncProcessRunner.KillTimerCloseCallback,,false,1102,1104,KillTimerCloseCallback,,,63,void node.SyncProcessRunner.KillTimerCloseCallback (uv_handle_t*)
280240,METHOD,spawn_sync.hpp:<global>,TYPE_DECL,<global>,1,28,spawn_sync.hpp,spawn_sync.hpp:<global>,,false,1,242,<global>,,,1,
280255,METHOD,stream_base-inl.hpp:<global>,TYPE_DECL,<global>,1,33,stream_base-inl.hpp,stream_base-inl.hpp:<global>,,false,1,173,<global>,,,1,
280286,METHOD,stream_base.cc:<global>,TYPE_DECL,<global>,1,29,stream_base.hpp,stream_base.cc:<global>,,false,1,852,<global>,,,1,
280289,METHOD,stream_base.cc:<global>,TYPE_DECL,"int StreamBase::Shutdown(v8::Local<v8::Object> req_wrap_obj) {
  Environment* env = stream_env();

  v8::HandleScope handle_scope(env->isolate());

  if (req_wrap_obj.IsEmpty()) {
    if (!env->shutdown_wrap_template()
             ->NewInstance(env->context())
             .ToLocal(&req_wrap_obj)) {
      return UV_EBUSY;
    }
    StreamReq::ResetObject(req_wrap_obj);
  }

  BaseObjectPtr<AsyncWrap> req_wrap_ptr;
  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(GetAsyncWrap());
  ShutdownWrap* req_wrap = CreateShutdownWrap(req_wrap_obj);
  if (req_wrap != nullptr) req_wrap_ptr.reset(req_wrap->GetAsyncWrap());
  int err = DoShutdown(req_wrap);

  if (err != 0 && req_wrap != nullptr) {
    req_wrap->Dispose();
  }

  const char* msg = Error();
  if (msg != nullptr) {
    if (req_wrap_obj
            ->Set(env->context(),
                  env->error_string(),
                  OneByteString(env->isolate(), msg))
            .IsNothing()) {
      return UV_EBUSY;
    }
    Clea...",1,1,stream_base.cc,node.StreamBase.Shutdown,,false,43,80,Shutdown,,,1,int node.StreamBase.Shutdown (ANY)
280417,METHOD,stream_base.cc:<global>,TYPE_DECL,"StreamWriteResult StreamBase::Write(uv_buf_t* bufs,
                                    size_t count,
                                    uv_stream_t* send_handle,
                                    v8::Local<v8::Object> req_wrap_obj,
                                    bool skip_try_write) {
  Environment* env = stream_env();
  int err;

  size_t total_bytes = 0;
  for (size_t i = 0; i < count; ++i) total_bytes += bufs[i].len;
  bytes_written_ += total_bytes;

  if (send_handle == nullptr && !skip_try_write) {
    err = DoTryWrite(&bufs, &count);
    if (err != 0 || count == 0) {
      return StreamWriteResult{false, err, nullptr, total_bytes, {}};
    }
  }

  v8::HandleScope handle_scope(env->isolate());

  if (req_wrap_obj.IsEmpty()) {
    if (!env->write_wrap_template()
             ->NewInstance(env->context())
             .ToLocal(&req_wrap_obj)) {
      return StreamWriteResult{false, UV_EBUSY, nullptr, 0, {}};
    }
    StreamReq::ResetObject(req_wrap_obj);
  }

  AsyncHo...",1,1,stream_base.cc,node.StreamBase.Write,,false,82,138,Write,,,2,"StreamWriteResult node.StreamBase.Write (uv_buf_t*,size_t,uv_stream_t*,ANY,bool)"
280626,METHOD,stream_base.cc:<global>,TYPE_DECL,"int StreamBase::ReadStartJS(const FunctionCallbackInfo<Value>& args) {
  return ReadStart();
}",1,1,stream_base.cc,node.StreamBase.ReadStartJS,,false,150,152,ReadStartJS,,,3,int node.StreamBase.ReadStartJS (FunctionCallbackInfo<Value>)
280633,METHOD,stream_base.cc:<global>,TYPE_DECL,"int StreamBase::ReadStopJS(const FunctionCallbackInfo<Value>& args) {
  return ReadStop();
}",1,1,stream_base.cc,node.StreamBase.ReadStopJS,,false,155,157,ReadStopJS,,,4,int node.StreamBase.ReadStopJS (FunctionCallbackInfo<Value>)
280640,METHOD,stream_base.cc:<global>,TYPE_DECL,"int StreamBase::UseUserBuffer(const FunctionCallbackInfo<Value>& args) {
  CHECK(Buffer::HasInstance(args[0]));

  uv_buf_t buf = uv_buf_init(Buffer::Data(args[0]), Buffer::Length(args[0]));
  PushStreamListener(new CustomBufferJSListener(buf));
  return 0;
}",1,1,stream_base.cc,node.StreamBase.UseUserBuffer,,false,159,165,UseUserBuffer,,,5,int node.StreamBase.UseUserBuffer (FunctionCallbackInfo<Value>)
280677,METHOD,stream_base.cc:<global>,TYPE_DECL,"int StreamBase::Shutdown(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsObject());
  Local<Object> req_wrap_obj = args[0].As<Object>();

  return Shutdown(req_wrap_obj);
}",1,1,stream_base.cc,node.StreamBase.Shutdown,,false,167,172,Shutdown,,,6,int node.StreamBase.Shutdown (FunctionCallbackInfo<Value>)
280704,METHOD,stream_base.cc:<global>,TYPE_DECL,"void StreamBase::SetWriteResult(const StreamWriteResult& res) {
  env_->stream_base_state()[kBytesWritten] = res.bytes;
  env_->stream_base_state()[kLastWriteWasAsync] = res.async;
}",1,1,stream_base.cc,node.StreamBase.SetWriteResult,,false,174,177,SetWriteResult,,,7,void node.StreamBase.SetWriteResult (StreamWriteResult)
280729,METHOD,stream_base.cc:<global>,TYPE_DECL,"int StreamBase::Writev(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();

  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsArray());

  Local<Object> req_wrap_obj = args[0].As<Object>();
  Local<Array> chunks = args[1].As<Array>();
  bool all_buffers = args[2]->IsTrue();

  size_t count;
  if (all_buffers)
    count = chunks->Length();
  else
    count = chunks->Length() >> 1;

  MaybeStackBuffer<uv_buf_t, 16> bufs(count);

  size_t storage_size = 0;
  size_t offset;

  if (!all_buffers) {
    // Determine storage size first
    for (size_t i = 0; i < count; i++) {
      Local<Value> chunk;
      if (!chunks->Get(context, i * 2).ToLocal(&chunk))
        return -1;

      if (Buffer::HasInstance(chunk))
        continue;
        // Buffer chunk, no additional storage required

      // String chunk
      Local<String> string;
      if (!chunk->ToString(context)...",1,1,stream_base.cc,node.StreamBase.Writev,,false,179,293,Writev,,,8,int node.StreamBase.Writev (FunctionCallbackInfo<Value>)
281292,METHOD,stream_base.cc:<global>,TYPE_DECL,"int StreamBase::WriteBuffer(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsObject());

  Environment* env = Environment::GetCurrent(args);

  if (!args[1]->IsUint8Array()) {
    node::THROW_ERR_INVALID_ARG_TYPE(env, ""Second argument must be a buffer"");
    return 0;
  }

  Local<Object> req_wrap_obj = args[0].As<Object>();
  uv_buf_t buf;
  buf.base = Buffer::Data(args[1]);
  buf.len = Buffer::Length(args[1]);

  uv_stream_t* send_handle = nullptr;

  if (args[2]->IsObject() && IsIPCPipe()) {
    Local<Object> send_handle_obj = args[2].As<Object>();

    HandleWrap* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, send_handle_obj, UV_EINVAL);
    send_handle = reinterpret_cast<uv_stream_t*>(wrap->GetHandle());
    // Reference LibuvStreamWrap instance to prevent it from being garbage
    // collected before `AfterWrite` is called.
    if (req_wrap_obj->Set(env->context(),
                          env->handle_string(),
                          send_handle_obj).IsNothing()) {...",1,1,stream_base.cc,node.StreamBase.WriteBuffer,,false,296,332,WriteBuffer,,,9,int node.StreamBase.WriteBuffer (FunctionCallbackInfo<Value>)
281440,METHOD,stream_base.cc:<global>,TYPE_DECL,"int StreamBase::WriteString(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsString());

  Local<Object> req_wrap_obj = args[0].As<Object>();
  Local<String> string = args[1].As<String>();
  Local<Object> send_handle_obj;
  if (args[2]->IsObject())
    send_handle_obj = args[2].As<Object>();

  // Compute the size of the storage that the string will be flattened into.
  // For UTF8 strings that are very long, go ahead and take the hit for
  // computing their actual size, rather than tripling the storage.
  size_t storage_size;
  if ((enc == UTF8 &&
         string->Length() > 65535 &&
         !StringBytes::Size(isolate, string, enc).To(&storage_size)) ||
          !StringBytes::StorageSize(isolate, string, enc).To(&storage_size)) {
    return -1;
  }

  if (storage_size > INT_MAX)
    return UV_ENOBUFS;

  // Try writing immediately if write size isn'...",1,1,stream_base.cc,node.StreamBase.WriteString,,false,336,443,WriteString,,,10,int node.StreamBase.WriteString<enum encoding> (FunctionCallbackInfo<Value>)
281841,METHOD,stream_base.cc:<global>,TYPE_DECL,"MaybeLocal<Value> StreamBase::CallJSOnreadMethod(ssize_t nread,
                                                 Local<ArrayBuffer> ab,
                                                 size_t offset,
                                                 StreamBaseJSChecks checks) {
  Environment* env = env_;

  DCHECK_EQ(static_cast<int32_t>(nread), nread);
  DCHECK_LE(offset, INT32_MAX);

  if (checks == DONT_SKIP_NREAD_CHECKS) {
    if (ab.IsEmpty()) {
      DCHECK_EQ(offset, 0);
      DCHECK_LE(nread, 0);
    } else {
      DCHECK_GE(nread, 0);
    }
  }

  env->stream_base_state()[kReadBytesOrError] = static_cast<int32_t>(nread);
  env->stream_base_state()[kArrayBufferOffset] = offset;

  Local<Value> argv[] = {
    ab.IsEmpty() ? Undefined(env->isolate()).As<Value>() : ab.As<Value>()
  };

  AsyncWrap* wrap = GetAsyncWrap();
  CHECK_NOT_NULL(wrap);
  Local<Value> onread = wrap->object()->GetInternalField(
      StreamBase::kOnReadFunctionField);
  CHECK(onread->IsFunction());
  retu...",1,1,stream_base.cc,node.StreamBase.CallJSOnreadMethod,,false,446,477,CallJSOnreadMethod,,,11,"MaybeLocal<Value> node.StreamBase.CallJSOnreadMethod (ssize_t,Local<ArrayBuffer>,size_t,StreamBaseJSChecks)"
281961,METHOD,stream_base.cc:<global>,TYPE_DECL,"bool StreamBase::IsIPCPipe() {
  return false;
}",1,1,stream_base.cc,node.StreamBase.IsIPCPipe,,false,480,482,IsIPCPipe,,,12,bool node.StreamBase.IsIPCPipe ()
281967,METHOD,stream_base.cc:<global>,TYPE_DECL,"int StreamBase::GetFD() {
  return -1;
}",1,1,stream_base.cc,node.StreamBase.GetFD,,false,485,487,GetFD,,,13,int node.StreamBase.GetFD ()
281974,METHOD,stream_base.cc:<global>,TYPE_DECL,"Local<Object> StreamBase::GetObject() {
  return GetAsyncWrap()->object();
}",1,1,stream_base.cc,node.StreamBase.GetObject,,false,490,492,GetObject,,,14,Local<Object> node.StreamBase.GetObject ()
281983,METHOD,stream_base.cc:<global>,TYPE_DECL,"void StreamBase::AddMethod(Isolate* isolate,
                           Local<Signature> signature,
                           enum PropertyAttribute attributes,
                           Local<FunctionTemplate> t,
                           JSMethodFunction* stream_method,
                           Local<String> string) {
  Local<FunctionTemplate> templ =
      NewFunctionTemplate(isolate,
                          stream_method,
                          signature,
                          ConstructorBehavior::kThrow,
                          SideEffectType::kHasNoSideEffect);
  t->PrototypeTemplate()->SetAccessorProperty(
      string, templ, Local<FunctionTemplate>(), attributes);
}",1,1,stream_base.cc,node.StreamBase.AddMethod,,false,494,508,AddMethod,,,15,"void node.StreamBase.AddMethod (Isolate*,Local<Signature>,PropertyAttribute,Local<FunctionTemplate>,JSMethodFunction*,Local<String>)"
282020,METHOD,stream_base.cc:<global>,TYPE_DECL,"void StreamBase::AddMethods(Environment* env, Local<FunctionTemplate> t) {
  AddMethods(env->isolate_data(), t);
}",1,1,stream_base.cc,node.StreamBase.AddMethods,,false,510,512,AddMethods,,,16,"void node.StreamBase.AddMethods (Environment*,Local<FunctionTemplate>)"
282032,METHOD,stream_base.cc:<global>,TYPE_DECL,"void StreamBase::AddMethods(IsolateData* isolate_data,
                            Local<FunctionTemplate> t) {
  Isolate* isolate = isolate_data->isolate();
  HandleScope scope(isolate);

  enum PropertyAttribute attributes =
      static_cast<PropertyAttribute>(ReadOnly | DontDelete | DontEnum);
  Local<Signature> sig = Signature::New(isolate, t);

  AddMethod(isolate, sig, attributes, t, GetFD, isolate_data->fd_string());
  AddMethod(isolate,
            sig,
            attributes,
            t,
            GetExternal,
            isolate_data->external_stream_string());
  AddMethod(isolate,
            sig,
            attributes,
            t,
            GetBytesRead,
            isolate_data->bytes_read_string());
  AddMethod(isolate,
            sig,
            attributes,
            t,
            GetBytesWritten,
            isolate_data->bytes_written_string());
  SetProtoMethod(isolate, t, ""readStart"", JSMethod<&StreamBase::ReadStartJS>);
  SetProtoMethod(isolate, ...",1,1,stream_base.cc,node.StreamBase.AddMethods,,false,514,568,AddMethods,,,17,"void node.StreamBase.AddMethods (IsolateData*,Local<FunctionTemplate>)"
282188,METHOD,stream_base.cc:<global>,TYPE_DECL,"void StreamBase::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  // This function is called by a single thread during start up, so it is safe
  // to use a local static variable here.
  static bool is_registered = false;
  if (is_registered) return;
  registry->Register(GetFD);
  registry->Register(GetExternal);
  registry->Register(GetBytesRead);
  registry->Register(GetBytesWritten);
  registry->Register(JSMethod<&StreamBase::ReadStartJS>);
  registry->Register(JSMethod<&StreamBase::ReadStopJS>);
  registry->Register(JSMethod<&StreamBase::Shutdown>);
  registry->Register(JSMethod<&StreamBase::UseUserBuffer>);
  registry->Register(JSMethod<&StreamBase::Writev>);
  registry->Register(JSMethod<&StreamBase::WriteBuffer>);
  registry->Register(JSMethod<&StreamBase::WriteString<ASCII>>);
  registry->Register(JSMethod<&StreamBase::WriteString<UTF8>>);
  registry->Register(JSMethod<&StreamBase::WriteString<UCS2>>);
  registry->Register(JSMethod<&StreamBase::WriteS...",1,1,stream_base.cc,node.StreamBase.RegisterExternalReferences,,false,570,596,RegisterExternalReferences,,,18,void node.StreamBase.RegisterExternalReferences (ExternalReferenceRegistry*)
282288,METHOD,stream_base.cc:<global>,TYPE_DECL,"void StreamBase::GetFD(const FunctionCallbackInfo<Value>& args) {
  // Mimic implementation of StreamBase::GetFD() and UDPWrap::GetFD().
  StreamBase* wrap = StreamBase::FromObject(args.This().As<Object>());
  if (wrap == nullptr) return args.GetReturnValue().Set(UV_EINVAL);

  if (!wrap->IsAlive()) return args.GetReturnValue().Set(UV_EINVAL);

  args.GetReturnValue().Set(wrap->GetFD());
}",1,1,stream_base.cc,node.StreamBase.GetFD,,false,598,606,GetFD,,,19,void node.StreamBase.GetFD (FunctionCallbackInfo<Value>)
282348,METHOD,stream_base.cc:<global>,TYPE_DECL,"void StreamBase::GetBytesRead(const FunctionCallbackInfo<Value>& args) {
  StreamBase* wrap = StreamBase::FromObject(args.This().As<Object>());
  if (wrap == nullptr) return args.GetReturnValue().Set(0);

  // uint64_t -> double. 53bits is enough for all real cases.
  args.GetReturnValue().Set(static_cast<double>(wrap->bytes_read_));
}",1,1,stream_base.cc,node.StreamBase.GetBytesRead,,false,608,614,GetBytesRead,,,20,void node.StreamBase.GetBytesRead (FunctionCallbackInfo<Value>)
282393,METHOD,stream_base.cc:<global>,TYPE_DECL,"void StreamBase::GetBytesWritten(const FunctionCallbackInfo<Value>& args) {
  StreamBase* wrap = StreamBase::FromObject(args.This().As<Object>());
  if (wrap == nullptr) return args.GetReturnValue().Set(0);

  // uint64_t -> double. 53bits is enough for all real cases.
  args.GetReturnValue().Set(static_cast<double>(wrap->bytes_written_));
}",1,1,stream_base.cc,node.StreamBase.GetBytesWritten,,false,616,622,GetBytesWritten,,,21,void node.StreamBase.GetBytesWritten (FunctionCallbackInfo<Value>)
282438,METHOD,stream_base.cc:<global>,TYPE_DECL,"void StreamBase::GetExternal(const FunctionCallbackInfo<Value>& args) {
  StreamBase* wrap = StreamBase::FromObject(args.This().As<Object>());
  if (wrap == nullptr) return;

  Local<External> ext = External::New(args.GetIsolate(), wrap);
  args.GetReturnValue().Set(ext);
}",1,1,stream_base.cc,node.StreamBase.GetExternal,,false,624,630,GetExternal,,,22,void node.StreamBase.GetExternal (FunctionCallbackInfo<Value>)
282486,METHOD,stream_base.cc:<global>,TYPE_DECL,"void StreamBase::JSMethod(const FunctionCallbackInfo<Value>& args) {
  StreamBase* wrap = StreamBase::FromObject(args.Holder().As<Object>());
  if (wrap == nullptr) return;

  if (!wrap->IsAlive()) return args.GetReturnValue().Set(UV_EINVAL);

  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(wrap->GetAsyncWrap());
  args.GetReturnValue().Set((wrap->*Method)(args));
}",1,1,stream_base.cc,node.StreamBase.JSMethod,,false,633,641,JSMethod,,,23,void node.StreamBase.JSMethod<int(StreamBase::*)(const FunctionCallbackInfo<Value>&)> (FunctionCallbackInfo<Value>)
282545,METHOD,stream_base.cc:<global>,TYPE_DECL,"int StreamResource::DoTryWrite(uv_buf_t** bufs, size_t* count) {
  // No TryWrite by default
  return 0;
}",1,1,stream_base.cc,node.StreamResource.DoTryWrite,,false,643,646,DoTryWrite,,,24,"int node.StreamResource.DoTryWrite (uv_buf_t**,size_t*)"
282553,METHOD,stream_base.cc:<global>,TYPE_DECL,"const char* StreamResource::Error() const {
  return nullptr;
}",1,1,stream_base.cc,node.StreamResource.Error,,false,649,651,Error,,,25,const char* node.StreamResource.Error ()
282559,METHOD,stream_base.cc:<global>,TYPE_DECL,"void StreamResource::ClearError() {
  // No-op
}",1,1,stream_base.cc,node.StreamResource.ClearError,,false,654,656,ClearError,,,26,void node.StreamResource.ClearError ()
282563,METHOD,stream_base.cc:<global>,TYPE_DECL,"uv_buf_t EmitToJSStreamListener::OnStreamAlloc(size_t suggested_size) {
  CHECK_NOT_NULL(stream_);
  Environment* env = static_cast<StreamBase*>(stream_)->stream_env();
  return env->allocate_managed_buffer(suggested_size);
}",1,1,stream_base.cc,node.EmitToJSStreamListener.OnStreamAlloc,,false,659,663,OnStreamAlloc,,,27,uv_buf_t node.EmitToJSStreamListener.OnStreamAlloc (size_t)
282584,METHOD,stream_base.cc:<global>,TYPE_DECL,"void EmitToJSStreamListener::OnStreamRead(ssize_t nread, const uv_buf_t& buf_) {
  CHECK_NOT_NULL(stream_);
  StreamBase* stream = static_cast<StreamBase*>(stream_);
  Environment* env = stream->stream_env();
  Isolate* isolate = env->isolate();
  HandleScope handle_scope(isolate);
  Context::Scope context_scope(env->context());
  std::unique_ptr<BackingStore> bs = env->release_managed_buffer(buf_);

  if (nread <= 0)  {
    if (nread < 0)
      stream->CallJSOnreadMethod(nread, Local<ArrayBuffer>());
    return;
  }

  CHECK_LE(static_cast<size_t>(nread), bs->ByteLength());
  bs = BackingStore::Reallocate(isolate, std::move(bs), nread);

  stream->CallJSOnreadMethod(nread, ArrayBuffer::New(isolate, std::move(bs)));
}",1,1,stream_base.cc,node.EmitToJSStreamListener.OnStreamRead,,false,665,684,OnStreamRead,,,28,"void node.EmitToJSStreamListener.OnStreamRead (ssize_t,uv_buf_t)"
282686,METHOD,stream_base.cc:<global>,TYPE_DECL,"uv_buf_t CustomBufferJSListener::OnStreamAlloc(size_t suggested_size) {
  return buffer_;
}",1,1,stream_base.cc,node.CustomBufferJSListener.OnStreamAlloc,,false,687,689,OnStreamAlloc,,,29,uv_buf_t node.CustomBufferJSListener.OnStreamAlloc (size_t)
282693,METHOD,stream_base.cc:<global>,TYPE_DECL,"void CustomBufferJSListener::OnStreamRead(ssize_t nread, const uv_buf_t& buf) {
  CHECK_NOT_NULL(stream_);

  StreamBase* stream = static_cast<StreamBase*>(stream_);
  Environment* env = stream->stream_env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  // In the case that there's an error and buf is null, return immediately.
  // This can happen on unices when POLLHUP is received and UV_EOF is returned
  // or when getting an error while performing a UV_HANDLE_ZERO_READ on Windows.
  if (buf.base == nullptr && nread < 0) {
    stream->CallJSOnreadMethod(nread, Local<ArrayBuffer>());
    return;
  }

  CHECK_EQ(buf.base, buffer_.base);

  MaybeLocal<Value> ret = stream->CallJSOnreadMethod(nread,
                             Local<ArrayBuffer>(),
                             0,
                             StreamBase::SKIP_NREAD_CHECKS);
  Local<Value> next_buf_v;
  if (ret.ToLocal(&next_buf_v) && !next_buf_v->IsUndefined()) {
    buf...",1,1,stream_base.cc,node.CustomBufferJSListener.OnStreamRead,,false,692,719,OnStreamRead,,,30,"void node.CustomBufferJSListener.OnStreamRead (ssize_t,uv_buf_t)"
282803,METHOD,stream_base.cc:<global>,TYPE_DECL,"void ReportWritesToJSStreamListener::OnStreamAfterReqFinished(
    StreamReq* req_wrap, int status) {
  StreamBase* stream = static_cast<StreamBase*>(stream_);
  Environment* env = stream->stream_env();
  if (!env->can_call_into_js()) return;
  AsyncWrap* async_wrap = req_wrap->GetAsyncWrap();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());
  CHECK(!async_wrap->persistent().IsEmpty());
  Local<Object> req_wrap_obj = async_wrap->object();

  Local<Value> argv[] = {
    Integer::New(env->isolate(), status),
    stream->GetObject(),
    Undefined(env->isolate())
  };

  const char* msg = stream->Error();
  if (msg != nullptr) {
    argv[2] = OneByteString(env->isolate(), msg);
    stream->ClearError();
  }

  if (req_wrap_obj->Has(env->context(), env->oncomplete_string()).FromJust())
    async_wrap->MakeCallback(env->oncomplete_string(), arraysize(argv), argv);
}",1,1,stream_base.cc,node.ReportWritesToJSStreamListener.OnStreamAfterReqFinished,,false,722,747,OnStreamAfterReqFinished,,,31,"void node.ReportWritesToJSStreamListener.OnStreamAfterReqFinished (StreamReq*,int)"
282944,METHOD,stream_base.cc:<global>,TYPE_DECL,"void ReportWritesToJSStreamListener::OnStreamAfterWrite(
    WriteWrap* req_wrap, int status) {
  OnStreamAfterReqFinished(req_wrap, status);
}",1,1,stream_base.cc,node.ReportWritesToJSStreamListener.OnStreamAfterWrite,,false,749,752,OnStreamAfterWrite,,,32,"void node.ReportWritesToJSStreamListener.OnStreamAfterWrite (WriteWrap*,int)"
282953,METHOD,stream_base.cc:<global>,TYPE_DECL,"void ReportWritesToJSStreamListener::OnStreamAfterShutdown(
    ShutdownWrap* req_wrap, int status) {
  OnStreamAfterReqFinished(req_wrap, status);
}",1,1,stream_base.cc,node.ReportWritesToJSStreamListener.OnStreamAfterShutdown,,false,754,757,OnStreamAfterShutdown,,,33,"void node.ReportWritesToJSStreamListener.OnStreamAfterShutdown (ShutdownWrap*,int)"
282962,METHOD,stream_base.cc:<global>,TYPE_DECL,"void ShutdownWrap::OnDone(int status) {
  stream()->EmitAfterShutdown(this, status);
  Dispose();
}",1,1,stream_base.cc,node.ShutdownWrap.OnDone,,false,759,762,OnDone,,,34,void node.ShutdownWrap.OnDone (int)
282974,METHOD,stream_base.cc:<global>,TYPE_DECL,"void WriteWrap::OnDone(int status) {
  stream()->EmitAfterWrite(this, status);
  Dispose();
}",1,1,stream_base.cc,node.WriteWrap.OnDone,,false,764,767,OnDone,,,35,void node.WriteWrap.OnDone (int)
282986,METHOD,stream_base.cc:<global>,TYPE_DECL,"StreamListener::~StreamListener() {
  if (stream_ != nullptr)
    stream_->RemoveStreamListener(this);
}",1,1,stream_base.cc,node.StreamListener.~StreamListener,,false,769,772,~StreamListener,,,36,ANY node.StreamListener.~StreamListener ()
283000,METHOD,stream_base.cc:<global>,TYPE_DECL,"void StreamListener::OnStreamAfterShutdown(ShutdownWrap* w, int status) {
  CHECK_NOT_NULL(previous_listener_);
  previous_listener_->OnStreamAfterShutdown(w, status);
}",1,1,stream_base.cc,node.StreamListener.OnStreamAfterShutdown,,false,774,777,OnStreamAfterShutdown,,,37,"void node.StreamListener.OnStreamAfterShutdown (ShutdownWrap*,int)"
283013,METHOD,stream_base.cc:<global>,TYPE_DECL,"void StreamListener::OnStreamAfterWrite(WriteWrap* w, int status) {
  CHECK_NOT_NULL(previous_listener_);
  previous_listener_->OnStreamAfterWrite(w, status);
}",1,1,stream_base.cc,node.StreamListener.OnStreamAfterWrite,,false,779,782,OnStreamAfterWrite,,,38,"void node.StreamListener.OnStreamAfterWrite (WriteWrap*,int)"
283026,METHOD,stream_base.cc:<global>,TYPE_DECL,"StreamResource::~StreamResource() {
  while (listener_ != nullptr) {
    StreamListener* listener = listener_;
    listener->OnStreamDestroy();
    // Remove the listener if it didnt remove itself. This makes the logic
    // in `OnStreamDestroy()` implementations easier, because they
    // may call generic cleanup functions which can just remove the
    // listener unconditionally.
    if (listener == listener_)
      RemoveStreamListener(listener_);
  }
}",1,1,stream_base.cc,node.StreamResource.~StreamResource,,false,784,795,~StreamResource,,,39,ANY node.StreamResource.~StreamResource ()
283049,METHOD,stream_base.cc:<global>,TYPE_DECL,"void StreamResource::RemoveStreamListener(StreamListener* listener) {
  CHECK_NOT_NULL(listener);

  StreamListener* previous;
  StreamListener* current;

  // Remove from the linked list.
  // No loop condition because we want a crash if listener is not found.
  for (current = listener_, previous = nullptr;;
       previous = current, current = current->previous_listener_) {
    CHECK_NOT_NULL(current);
    if (current == listener) {
      if (previous != nullptr)
        previous->previous_listener_ = current->previous_listener_;
      else
        listener_ = listener->previous_listener_;
      break;
    }
  }

  listener->stream_ = nullptr;
  listener->previous_listener_ = nullptr;
}",1,1,stream_base.cc,node.StreamResource.RemoveStreamListener,,false,797,819,RemoveStreamListener,,,40,void node.StreamResource.RemoveStreamListener (StreamListener*)
283114,METHOD,stream_base.cc:<global>,TYPE_DECL,"ShutdownWrap* StreamBase::CreateShutdownWrap(
    Local<Object> object) {
  auto* wrap = new SimpleShutdownWrap<AsyncWrap>(this, object);
  wrap->MakeWeak();
  return wrap;
}",1,1,stream_base.cc,node.StreamBase.CreateShutdownWrap,,false,821,826,CreateShutdownWrap,,,41,ShutdownWrap node.StreamBase.CreateShutdownWrap (Local<Object>)
283132,METHOD,stream_base.cc:<global>,TYPE_DECL,"WriteWrap* StreamBase::CreateWriteWrap(
    Local<Object> object) {
  auto* wrap = new SimpleWriteWrap<AsyncWrap>(this, object);
  wrap->MakeWeak();
  return wrap;
}",1,1,stream_base.cc,node.StreamBase.CreateWriteWrap,,false,828,833,CreateWriteWrap,,,42,WriteWrap node.StreamBase.CreateWriteWrap (Local<Object>)
283150,METHOD,stream_base.cc:<global>,TYPE_DECL,"void StreamReq::Done(int status, const char* error_str) {
  AsyncWrap* async_wrap = GetAsyncWrap();
  Environment* env = async_wrap->env();
  if (error_str != nullptr) {
    v8::HandleScope handle_scope(env->isolate());
    if (async_wrap->object()
            ->Set(env->context(),
                  env->error_string(),
                  OneByteString(env->isolate(), error_str))
            .IsNothing()) {
      return;
    }
  }

  OnDone(status);
}",1,1,stream_base.cc,node.StreamReq.Done,,false,835,850,Done,,,43,"void node.StreamReq.Done (int,char*)"
283220,METHOD,stream_base.hpp:<global>,TYPE_DECL,<global>,1,29,stream_base.hpp,stream_base.hpp:<global>,,false,1,469,<global>,,,1,
283223,METHOD,stream_pipe.cc:<global>,TYPE_DECL,"[this, strong_ref](Environment* env) {
    HandleScope handle_scope(env->isolate());
    Context::Scope context_scope(env->context());
    Local<Object> object = this->object();

    Local<Value> onunpipe;
    if (!object->Get(env->context(), env->onunpipe_string()).ToLocal(&onunpipe))
      return;
    if (onunpipe->IsFunction() &&
        MakeCallback(onunpipe.As<Function>(), 0, nullptr).IsEmpty()) {
      return;
    }

    // Set all the links established in the constructor to `null`.
    Local<Value> null = Null(env->isolate());

    Local<Value> source_v;
    Local<Value> sink_v;
    if (!object->Get(env->context(), env->source_string()).ToLocal(&source_v) ||
        !object->Get(env->context(), env->sink_string()).ToLocal(&sink_v) ||
        !source_v->IsObject() || !sink_v->IsObject()) {
      return;
    }

    if (object->Set(env->context(), env->source_string(), null).IsNothing() ||
        object->Set(env->context(), env->sink_string(), null).IsNothing() ||
        sourc...",23,3,stream_pipe.cc,node.StreamPipe.Unpipe.<lambda>0,,false,71,105,<lambda>0,,,1,ANY node.StreamPipe.Unpipe.<lambda>0 (Environment*)
283454,METHOD,stream_pipe.cc:<global>,TYPE_DECL,<global>,1,29,stream_pipe.hpp,stream_pipe.cc:<global>,,false,1,335,<global>,,,1,
283457,METHOD,stream_pipe.cc:<global>,TYPE_DECL,"StreamPipe::StreamPipe(StreamBase* source,
                       StreamBase* sink,
                       Local<Object> obj)
    : AsyncWrap(source->stream_env(), obj, AsyncWrap::PROVIDER_STREAMPIPE) {
  MakeWeak();

  CHECK_NOT_NULL(sink);
  CHECK_NOT_NULL(source);

  source->PushStreamListener(&readable_listener_);
  sink->PushStreamListener(&writable_listener_);

  uses_wants_write_ = sink->HasWantsWrite();
}",1,1,stream_pipe.cc,node.StreamPipe.StreamPipe,,false,22,35,StreamPipe,,,1,"ANY node.StreamPipe.StreamPipe (StreamBase*,StreamBase*,Local<Object>)"
283487,METHOD,stream_pipe.cc:<global>,TYPE_DECL,"StreamPipe::~StreamPipe() {
  Unpipe(true);
}",1,1,stream_pipe.cc,node.StreamPipe.~StreamPipe,,false,37,39,~StreamPipe,,,2,ANY node.StreamPipe.~StreamPipe ()
283493,METHOD,stream_pipe.cc:<global>,TYPE_DECL,"StreamBase* StreamPipe::source() {
  return static_cast<StreamBase*>(readable_listener_.stream());
}",1,1,stream_pipe.cc,node.StreamPipe.source,,false,41,43,source,,,3,StreamBase node.StreamPipe.source ()
283504,METHOD,stream_pipe.cc:<global>,TYPE_DECL,"StreamBase* StreamPipe::sink() {
  return static_cast<StreamBase*>(writable_listener_.stream());
}",1,1,stream_pipe.cc,node.StreamPipe.sink,,false,45,47,sink,,,4,StreamBase node.StreamPipe.sink ()
283515,METHOD,stream_pipe.cc:<global>,TYPE_DECL,"void StreamPipe::Unpipe(bool is_in_deletion) {
  if (is_closed_)
    return;

  // Note that we possibly cannot use virtual methods on `source` and `sink`
  // here, because this function can be called from their destructors via
  // `OnStreamDestroy()`.
  if (!source_destroyed_)
    source()->ReadStop();

  is_closed_ = true;
  is_reading_ = false;
  source()->RemoveStreamListener(&readable_listener_);
  if (pending_writes_ == 0)
    sink()->RemoveStreamListener(&writable_listener_);

  if (is_in_deletion) return;

  // Delay the JS-facing part with SetImmediate, because this might be from
  // inside the garbage collector, so we cant run JS here.
  HandleScope handle_scope(env()->isolate());
  BaseObjectPtr<StreamPipe> strong_ref{this};
  env()->SetImmediate([this, strong_ref](Environment* env) {
    HandleScope handle_scope(env->isolate());
    Context::Scope context_scope(env->context());
    Local<Object> object = this->object();

    Local<Value> onunpipe;
    if (!object->Ge...",1,1,stream_pipe.cc,node.StreamPipe.Unpipe,,false,49,106,Unpipe,,,5,void node.StreamPipe.Unpipe (bool)
283577,METHOD,stream_pipe.cc:<global>,TYPE_DECL,"uv_buf_t StreamPipe::ReadableListener::OnStreamAlloc(size_t suggested_size) {
  StreamPipe* pipe = ContainerOf(&StreamPipe::readable_listener_, this);
  size_t size = std::min(suggested_size, pipe->wanted_data_);
  CHECK_GT(size, 0);
  return pipe->env()->allocate_managed_buffer(size);
}",1,1,stream_pipe.cc,node.StreamPipe.ReadableListener.OnStreamAlloc,,false,108,113,OnStreamAlloc,,,6,uv_buf_t node.StreamPipe.ReadableListener.OnStreamAlloc (size_t)
283614,METHOD,stream_pipe.cc:<global>,TYPE_DECL,"void StreamPipe::ReadableListener::OnStreamRead(ssize_t nread,
                                                const uv_buf_t& buf_) {
  StreamPipe* pipe = ContainerOf(&StreamPipe::readable_listener_, this);
  std::unique_ptr<BackingStore> bs = pipe->env()->release_managed_buffer(buf_);
  if (nread < 0) {
    // EOF or error; stop reading and pass the error to the previous listener
    // (which might end up in JS).
    pipe->is_eof_ = true;
    // Cache `sink()` here because the previous listener might do things
    // that eventually lead to an `Unpipe()` call.
    StreamBase* sink = pipe->sink();
    stream()->ReadStop();
    CHECK_NOT_NULL(previous_listener_);
    previous_listener_->OnStreamRead(nread, uv_buf_init(nullptr, 0));
    // If were not writing, close now. Otherwise, well do that in
    // `OnStreamAfterWrite()`.
    if (pipe->pending_writes_ == 0) {
      sink->Shutdown();
      pipe->Unpipe();
    }
    return;
  }

  pipe->ProcessData(nread, std::move(bs));
}",1,1,stream_pipe.cc,node.StreamPipe.ReadableListener.OnStreamRead,,false,115,139,OnStreamRead,,,7,"void node.StreamPipe.ReadableListener.OnStreamRead (ssize_t,uv_buf_t)"
283701,METHOD,stream_pipe.cc:<global>,TYPE_DECL,"void StreamPipe::ProcessData(size_t nread,
                             std::unique_ptr<BackingStore> bs) {
  CHECK(uses_wants_write_ || pending_writes_ == 0);
  uv_buf_t buffer = uv_buf_init(static_cast<char*>(bs->Data()), nread);
  StreamWriteResult res = sink()->Write(&buffer, 1);
  pending_writes_++;
  if (!res.async) {
    writable_listener_.OnStreamAfterWrite(nullptr, res.err);
  } else {
    is_reading_ = false;
    res.wrap->SetBackingStore(std::move(bs));
    if (source() != nullptr)
      source()->ReadStop();
  }
}",1,1,stream_pipe.cc,node.StreamPipe.ProcessData,,false,141,155,ProcessData,,,8,"void node.StreamPipe.ProcessData (size_t,ANY)"
283775,METHOD,stream_pipe.cc:<global>,TYPE_DECL,"void StreamPipe::WritableListener::OnStreamAfterWrite(WriteWrap* w,
                                                      int status) {
  StreamPipe* pipe = ContainerOf(&StreamPipe::writable_listener_, this);
  pipe->pending_writes_--;
  if (pipe->is_closed_) {
    if (pipe->pending_writes_ == 0) {
      Environment* env = pipe->env();
      HandleScope handle_scope(env->isolate());
      Context::Scope context_scope(env->context());
      if (pipe->MakeCallback(env->oncomplete_string(), 0, nullptr).IsEmpty())
        return;
      stream()->RemoveStreamListener(this);
    }
    return;
  }

  if (pipe->is_eof_) {
    HandleScope handle_scope(pipe->env()->isolate());
    InternalCallbackScope callback_scope(pipe,
        InternalCallbackScope::kSkipTaskQueues);
    pipe->sink()->Shutdown();
    pipe->Unpipe();
    return;
  }

  if (status != 0) {
    CHECK_NOT_NULL(previous_listener_);
    StreamListener* prev = previous_listener_;
    pipe->Unpipe();
    prev->OnStreamAfterWrite(w...",1,1,stream_pipe.cc,node.StreamPipe.WritableListener.OnStreamAfterWrite,,false,157,193,OnStreamAfterWrite,,,9,"void node.StreamPipe.WritableListener.OnStreamAfterWrite (WriteWrap*,int)"
283908,METHOD,stream_pipe.cc:<global>,TYPE_DECL,"void StreamPipe::WritableListener::OnStreamAfterShutdown(ShutdownWrap* w,
                                                         int status) {
  StreamPipe* pipe = ContainerOf(&StreamPipe::writable_listener_, this);
  CHECK_NOT_NULL(previous_listener_);
  StreamListener* prev = previous_listener_;
  pipe->Unpipe();
  prev->OnStreamAfterShutdown(w, status);
}",1,1,stream_pipe.cc,node.StreamPipe.WritableListener.OnStreamAfterShutdown,,false,195,202,OnStreamAfterShutdown,,,10,"void node.StreamPipe.WritableListener.OnStreamAfterShutdown (ShutdownWrap*,int)"
283938,METHOD,stream_pipe.cc:<global>,TYPE_DECL,"void StreamPipe::ReadableListener::OnStreamDestroy() {
  StreamPipe* pipe = ContainerOf(&StreamPipe::readable_listener_, this);
  pipe->source_destroyed_ = true;
  if (!pipe->is_eof_) {
    OnStreamRead(UV_EPIPE, uv_buf_init(nullptr, 0));
  }
}",1,1,stream_pipe.cc,node.StreamPipe.ReadableListener.OnStreamDestroy,,false,204,210,OnStreamDestroy,,,11,void node.StreamPipe.ReadableListener.OnStreamDestroy ()
283967,METHOD,stream_pipe.cc:<global>,TYPE_DECL,"void StreamPipe::WritableListener::OnStreamDestroy() {
  StreamPipe* pipe = ContainerOf(&StreamPipe::writable_listener_, this);
  pipe->sink_destroyed_ = true;
  pipe->is_eof_ = true;
  pipe->pending_writes_ = 0;
  pipe->Unpipe();
}",1,1,stream_pipe.cc,node.StreamPipe.WritableListener.OnStreamDestroy,,false,212,218,OnStreamDestroy,,,12,void node.StreamPipe.WritableListener.OnStreamDestroy ()
283999,METHOD,stream_pipe.cc:<global>,TYPE_DECL,"void StreamPipe::WritableListener::OnStreamWantsWrite(size_t suggested_size) {
  StreamPipe* pipe = ContainerOf(&StreamPipe::writable_listener_, this);
  pipe->wanted_data_ = suggested_size;
  if (pipe->is_reading_ || pipe->is_closed_)
    return;
  HandleScope handle_scope(pipe->env()->isolate());
  InternalCallbackScope callback_scope(pipe,
      InternalCallbackScope::kSkipTaskQueues);
  pipe->is_reading_ = true;
  pipe->source()->ReadStart();
}",1,1,stream_pipe.cc,node.StreamPipe.WritableListener.OnStreamWantsWrite,,false,220,230,OnStreamWantsWrite,,,13,void node.StreamPipe.WritableListener.OnStreamWantsWrite (size_t)
284055,METHOD,stream_pipe.cc:<global>,TYPE_DECL,"uv_buf_t StreamPipe::WritableListener::OnStreamAlloc(size_t suggested_size) {
  CHECK_NOT_NULL(previous_listener_);
  return previous_listener_->OnStreamAlloc(suggested_size);
}",1,1,stream_pipe.cc,node.StreamPipe.WritableListener.OnStreamAlloc,,false,232,235,OnStreamAlloc,,,14,uv_buf_t node.StreamPipe.WritableListener.OnStreamAlloc (size_t)
284067,METHOD,stream_pipe.cc:<global>,TYPE_DECL,"void StreamPipe::WritableListener::OnStreamRead(ssize_t nread,
                                                const uv_buf_t& buf) {
  CHECK_NOT_NULL(previous_listener_);
  return previous_listener_->OnStreamRead(nread, buf);
}",1,1,stream_pipe.cc,node.StreamPipe.WritableListener.OnStreamRead,,false,237,241,OnStreamRead,,,15,"void node.StreamPipe.WritableListener.OnStreamRead (ssize_t,uv_buf_t)"
284081,METHOD,stream_pipe.cc:<global>,TYPE_DECL,"Maybe<StreamPipe*> StreamPipe::New(StreamBase* source,
                                   StreamBase* sink,
                                   Local<Object> obj) {
  std::unique_ptr<StreamPipe> stream_pipe(new StreamPipe(source, sink, obj));

  // Set up links between this object and the source/sink objects.
  // In particular, this makes sure that they are garbage collected as a group,
  // if that applies to the given streams (for example, Http2Streams use
  // weak references).
  Environment* env = source->stream_env();
  if (obj->Set(env->context(), env->source_string(), source->GetObject())
          .IsNothing()) {
    return Nothing<StreamPipe*>();
  }
  if (source->GetObject()
          ->Set(env->context(), env->pipe_target_string(), obj)
          .IsNothing()) {
    return Nothing<StreamPipe*>();
  }
  if (obj->Set(env->context(), env->sink_string(), sink->GetObject())
          .IsNothing()) {
    return Nothing<StreamPipe*>();
  }
  if (sink->GetObject()
          ->Set...",1,1,stream_pipe.cc,node.StreamPipe.New,,false,243,273,New,,,16,"Maybe<StreamPipe*> node.StreamPipe.New (StreamBase*,StreamBase*,Local<Object>)"
284205,METHOD,stream_pipe.cc:<global>,TYPE_DECL,"void StreamPipe::New(const FunctionCallbackInfo<Value>& args) {
  CHECK(args.IsConstructCall());
  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsObject());
  StreamBase* source = StreamBase::FromObject(args[0].As<Object>());
  StreamBase* sink = StreamBase::FromObject(args[1].As<Object>());

  if (StreamPipe::New(source, sink, args.This()).IsNothing()) return;
}",1,1,stream_pipe.cc,node.StreamPipe.New,,false,275,283,New,,,17,void node.StreamPipe.New (FunctionCallbackInfo<Value>)
284271,METHOD,stream_pipe.cc:<global>,TYPE_DECL,"void StreamPipe::Start(const FunctionCallbackInfo<Value>& args) {
  StreamPipe* pipe;
  ASSIGN_OR_RETURN_UNWRAP(&pipe, args.Holder());
  pipe->is_closed_ = false;
  pipe->writable_listener_.OnStreamWantsWrite(65536);
}",1,1,stream_pipe.cc,node.StreamPipe.Start,,false,285,290,Start,,,18,void node.StreamPipe.Start (FunctionCallbackInfo<Value>)
284296,METHOD,stream_pipe.cc:<global>,TYPE_DECL,"void StreamPipe::Unpipe(const FunctionCallbackInfo<Value>& args) {
  StreamPipe* pipe;
  ASSIGN_OR_RETURN_UNWRAP(&pipe, args.Holder());
  pipe->Unpipe();
}",1,1,stream_pipe.cc,node.StreamPipe.Unpipe,,false,292,296,Unpipe,,,19,void node.StreamPipe.Unpipe (FunctionCallbackInfo<Value>)
284313,METHOD,stream_pipe.cc:<global>,TYPE_DECL,"void StreamPipe::IsClosed(const FunctionCallbackInfo<Value>& args) {
  StreamPipe* pipe;
  ASSIGN_OR_RETURN_UNWRAP(&pipe, args.Holder());
  args.GetReturnValue().Set(pipe->is_closed_);
}",1,1,stream_pipe.cc,node.StreamPipe.IsClosed,,false,298,302,IsClosed,,,20,void node.StreamPipe.IsClosed (FunctionCallbackInfo<Value>)
284336,METHOD,stream_pipe.cc:<global>,TYPE_DECL,"void StreamPipe::PendingWrites(const FunctionCallbackInfo<Value>& args) {
  StreamPipe* pipe;
  ASSIGN_OR_RETURN_UNWRAP(&pipe, args.Holder());
  args.GetReturnValue().Set(pipe->pending_writes_);
}",1,1,stream_pipe.cc,node.StreamPipe.PendingWrites,,false,304,308,PendingWrites,,,21,void node.StreamPipe.PendingWrites (FunctionCallbackInfo<Value>)
284360,METHOD,stream_pipe.cc:<global>,TYPE_DECL,"void InitializeStreamPipe(Local<Object> target,
                          Local<Value> unused,
                          Local<Context> context,
                          void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  // Create FunctionTemplate for FileHandle::CloseReq
  Local<FunctionTemplate> pipe = NewFunctionTemplate(isolate, StreamPipe::New);
  SetProtoMethod(isolate, pipe, ""unpipe"", StreamPipe::Unpipe);
  SetProtoMethod(isolate, pipe, ""start"", StreamPipe::Start);
  SetProtoMethod(isolate, pipe, ""isClosed"", StreamPipe::IsClosed);
  SetProtoMethod(isolate, pipe, ""pendingWrites"", StreamPipe::PendingWrites);
  pipe->Inherit(AsyncWrap::GetConstructorTemplate(env));
  pipe->InstanceTemplate()->SetInternalFieldCount(
      StreamPipe::kInternalFieldCount);
  SetConstructorFunction(context, target, ""StreamPipe"", pipe);
}",1,1,stream_pipe.cc,node.anonymous_namespace_1.InitializeStreamPipe,,false,312,329,InitializeStreamPipe,,,1,"void node.anonymous_namespace_1.InitializeStreamPipe (Local<Object>,Local<Value>,Local<Context>,void*)"
284452,METHOD,stream_pipe.hpp:<global>,TYPE_DECL,<global>,1,29,stream_pipe.hpp,stream_pipe.hpp:<global>,,false,1,76,<global>,,,1,
284455,METHOD,stream_wrap.cc:<global>,TYPE_DECL,"[](uv_handle_t* handle, size_t suggested_size, uv_buf_t* buf) {
        static_cast<LibuvStreamWrap*>(handle->data)
            ->OnUvAlloc(suggested_size, buf);
      }",7,7,stream_wrap.cc,node.LibuvStreamWrap.ReadStart.<lambda>0,,false,205,208,<lambda>0,,,1,"ANY node.LibuvStreamWrap.ReadStart.<lambda>0 (uv_handle_t*,size_t,uv_buf_t*)"
284474,METHOD,stream_wrap.cc:<global>,TYPE_DECL,"[](uv_stream_t* stream, ssize_t nread, const uv_buf_t* buf) {
        LibuvStreamWrap* wrap = static_cast<LibuvStreamWrap*>(stream->data);
        TryCatchScope try_catch(wrap->env());
        try_catch.SetVerbose(true);
        wrap->OnUvRead(nread, buf);
      }",7,7,stream_wrap.cc,node.LibuvStreamWrap.ReadStart.<lambda>1,,false,209,214,<lambda>1,,,1,"ANY node.LibuvStreamWrap.ReadStart.<lambda>1 (uv_stream_t*,ssize_t,uv_buf_t*)"
284536,METHOD,stream_wrap.cc:<global>,TYPE_DECL,<global>,1,1,stream_wrap.cc,stream_wrap.cc:<global>,,false,1,421,<global>,,,1,
284539,METHOD,stream_wrap.cc:<global>,TYPE_DECL,"void IsConstructCallCallback(const FunctionCallbackInfo<Value>& args) {
  CHECK(args.IsConstructCall());
  StreamReq::ResetObject(args.This());
}",1,1,stream_wrap.cc,node.IsConstructCallCallback,,false,61,64,IsConstructCallCallback,,,1,void node.IsConstructCallCallback (FunctionCallbackInfo<Value>)
284557,METHOD,stream_wrap.cc:<global>,TYPE_DECL,"void LibuvStreamWrap::Initialize(Local<Object> target,
                                 Local<Value> unused,
                                 Local<Context> context,
                                 void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> sw =
      NewFunctionTemplate(isolate, IsConstructCallCallback);
  sw->InstanceTemplate()->SetInternalFieldCount(StreamReq::kInternalFieldCount);

  // we need to set handle and callback to null,
  // so that those fields are created and functions
  // do not become megamorphic
  // Fields:
  // - oncomplete
  // - callback
  // - handle
  sw->InstanceTemplate()->Set(env->oncomplete_string(), v8::Null(isolate));
  sw->InstanceTemplate()->Set(FIXED_ONE_BYTE_STRING(isolate, ""callback""),
                              v8::Null(isolate));
  sw->InstanceTemplate()->Set(FIXED_ONE_BYTE_STRING(isolate, ""handle""),
                              v8::Null(isolate));

 ...",1,2,stream_wrap.cc,node.LibuvStreamWrap.Initialize,,false,66,112,Initialize,,,2,"void node.LibuvStreamWrap.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
285125,METHOD,stream_wrap.cc:<global>,TYPE_DECL,"void LibuvStreamWrap::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(IsConstructCallCallback);
  registry->Register(GetWriteQueueSize);
  registry->Register(SetBlocking);
  StreamBase::RegisterExternalReferences(registry);
}",1,1,stream_wrap.cc,node.LibuvStreamWrap.RegisterExternalReferences,,false,114,120,RegisterExternalReferences,,,3,void node.LibuvStreamWrap.RegisterExternalReferences (ExternalReferenceRegistry*)
285150,METHOD,stream_wrap.cc:<global>,TYPE_DECL,"LibuvStreamWrap::LibuvStreamWrap(Environment* env,
                                 Local<Object> object,
                                 uv_stream_t* stream,
                                 AsyncWrap::ProviderType provider)
    : HandleWrap(env,
                 object,
                 reinterpret_cast<uv_handle_t*>(stream),
                 provider),
      StreamBase(env),
      stream_(stream) {
  StreamBase::AttachToObject(object);
}",1,1,stream_wrap.cc,node.LibuvStreamWrap.LibuvStreamWrap,,false,122,133,LibuvStreamWrap,,,4,"ANY node.LibuvStreamWrap.LibuvStreamWrap (Environment*,Local<Object>,uv_stream_t*,ANY)"
285163,METHOD,stream_wrap.cc:<global>,TYPE_DECL,"Local<FunctionTemplate> LibuvStreamWrap::GetConstructorTemplate(
    Environment* env) {
  Local<FunctionTemplate> tmpl = env->libuv_stream_wrap_ctor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(isolate, ""LibuvStreamWrap""));
    tmpl->Inherit(HandleWrap::GetConstructorTemplate(env));
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        StreamBase::kInternalFieldCount);
    Local<FunctionTemplate> get_write_queue_size =
        FunctionTemplate::New(isolate,
                              GetWriteQueueSize,
                              Local<Value>(),
                              Signature::New(isolate, tmpl));
    tmpl->PrototypeTemplate()->SetAccessorProperty(
        env->write_queue_size_string(),
        get_write_queue_size,
        Local<FunctionTemplate>(),
        static_cast<PropertyAttribute>(ReadOnly | DontDelete));
    SetProtoMethod(isola...",1,1,stream_wrap.cc,node.LibuvStreamWrap.GetConstructorTemplate,,false,136,161,GetConstructorTemplate,,,5,Local<FunctionTemplate> node.LibuvStreamWrap.GetConstructorTemplate (Environment*)
285277,METHOD,stream_wrap.cc:<global>,TYPE_DECL,"LibuvStreamWrap* LibuvStreamWrap::From(Environment* env, Local<Object> object) {
  Local<FunctionTemplate> sw = env->libuv_stream_wrap_ctor_template();
  CHECK(!sw.IsEmpty() && sw->HasInstance(object));
  return Unwrap<LibuvStreamWrap>(object);
}",1,1,stream_wrap.cc,node.LibuvStreamWrap.From,,false,164,168,From,,,6,"LibuvStreamWrap node.LibuvStreamWrap.From (Environment*,Local<Object>)"
285311,METHOD,stream_wrap.cc:<global>,TYPE_DECL,"int LibuvStreamWrap::GetFD() {
#ifdef _WIN32
  return fd_;
#else
  int fd = -1;
  if (stream() != nullptr)
    uv_fileno(reinterpret_cast<uv_handle_t*>(stream()), &fd);
  return fd;
#endif
}",1,1,stream_wrap.cc,node.LibuvStreamWrap.GetFD,,false,171,180,GetFD,,,7,int node.LibuvStreamWrap.GetFD ()
285333,METHOD,stream_wrap.cc:<global>,TYPE_DECL,"bool LibuvStreamWrap::IsAlive() {
  return HandleWrap::IsAlive(this);
}",1,1,stream_wrap.cc,node.LibuvStreamWrap.IsAlive,,false,183,185,IsAlive,,,8,bool node.LibuvStreamWrap.IsAlive ()
285343,METHOD,stream_wrap.cc:<global>,TYPE_DECL,"bool LibuvStreamWrap::IsClosing() {
  return uv_is_closing(reinterpret_cast<uv_handle_t*>(stream()));
}",1,1,stream_wrap.cc,node.LibuvStreamWrap.IsClosing,,false,188,190,IsClosing,,,9,bool node.LibuvStreamWrap.IsClosing ()
285352,METHOD,stream_wrap.cc:<global>,TYPE_DECL,"AsyncWrap* LibuvStreamWrap::GetAsyncWrap() {
  return static_cast<AsyncWrap*>(this);
}",1,1,stream_wrap.cc,node.LibuvStreamWrap.GetAsyncWrap,,false,193,195,GetAsyncWrap,,,10,AsyncWrap node.LibuvStreamWrap.GetAsyncWrap ()
285360,METHOD,stream_wrap.cc:<global>,TYPE_DECL,"bool LibuvStreamWrap::IsIPCPipe() {
  return is_named_pipe_ipc();
}",1,1,stream_wrap.cc,node.LibuvStreamWrap.IsIPCPipe,,false,198,200,IsIPCPipe,,,11,bool node.LibuvStreamWrap.IsIPCPipe ()
285366,METHOD,stream_wrap.cc:<global>,TYPE_DECL,"int LibuvStreamWrap::ReadStart() {
  return uv_read_start(
      stream(),
      [](uv_handle_t* handle, size_t suggested_size, uv_buf_t* buf) {
        static_cast<LibuvStreamWrap*>(handle->data)
            ->OnUvAlloc(suggested_size, buf);
      },
      [](uv_stream_t* stream, ssize_t nread, const uv_buf_t* buf) {
        LibuvStreamWrap* wrap = static_cast<LibuvStreamWrap*>(stream->data);
        TryCatchScope try_catch(wrap->env());
        try_catch.SetVerbose(true);
        wrap->OnUvRead(nread, buf);
      });
}",1,1,stream_wrap.cc,node.LibuvStreamWrap.ReadStart,,false,202,215,ReadStart,,,12,int node.LibuvStreamWrap.ReadStart ()
285375,METHOD,stream_wrap.cc:<global>,TYPE_DECL,"int LibuvStreamWrap::ReadStop() {
  return uv_read_stop(stream());
}",1,1,stream_wrap.cc,node.LibuvStreamWrap.ReadStop,,false,218,220,ReadStop,,,13,int node.LibuvStreamWrap.ReadStop ()
285382,METHOD,stream_wrap.cc:<global>,TYPE_DECL,"void LibuvStreamWrap::OnUvAlloc(size_t suggested_size, uv_buf_t* buf) {
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());

  *buf = EmitAlloc(suggested_size);
}",1,1,stream_wrap.cc,node.LibuvStreamWrap.OnUvAlloc,,false,223,228,OnUvAlloc,,,14,"void node.LibuvStreamWrap.OnUvAlloc (size_t,uv_buf_t*)"
285405,METHOD,stream_wrap.cc:<global>,TYPE_DECL,"static MaybeLocal<Object> AcceptHandle(Environment* env,
                                       LibuvStreamWrap* parent) {
  static_assert(std::is_base_of<LibuvStreamWrap, WrapType>::value ||
                std::is_base_of<UDPWrap, WrapType>::value,
                ""Can only accept stream handles"");

  EscapableHandleScope scope(env->isolate());
  Local<Object> wrap_obj;

  if (!WrapType::Instantiate(env, parent, WrapType::SOCKET).ToLocal(&wrap_obj))
    return Local<Object>();

  HandleWrap* wrap = Unwrap<HandleWrap>(wrap_obj);
  CHECK_NOT_NULL(wrap);
  uv_stream_t* stream = reinterpret_cast<uv_stream_t*>(wrap->GetHandle());
  CHECK_NOT_NULL(stream);

  if (uv_accept(parent->stream(), stream))
    ABORT();

  return scope.Escape(wrap_obj);
}",1,1,stream_wrap.cc,node.AcceptHandle,,false,231,252,AcceptHandle,,,15,"MaybeLocal<Object> node.AcceptHandle<WrapType> (Environment*,LibuvStreamWrap*)"
285490,METHOD,stream_wrap.cc:<global>,TYPE_DECL,"Maybe<void> LibuvStreamWrap::OnUvRead(ssize_t nread, const uv_buf_t* buf) {
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  uv_handle_type type = UV_UNKNOWN_HANDLE;

  if (is_named_pipe_ipc() &&
      uv_pipe_pending_count(reinterpret_cast<uv_pipe_t*>(stream())) > 0) {
    type = uv_pipe_pending_type(reinterpret_cast<uv_pipe_t*>(stream()));
  }

  // We should not be getting this callback if someone has already called
  // uv_close() on the handle.
  CHECK_EQ(persistent().IsEmpty(), false);

  if (nread > 0) {
    MaybeLocal<Object> pending_obj;

    if (type == UV_TCP) {
      pending_obj = AcceptHandle<TCPWrap>(env(), this);
    } else if (type == UV_NAMED_PIPE) {
      pending_obj = AcceptHandle<PipeWrap>(env(), this);
    } else if (type == UV_UDP) {
      pending_obj = AcceptHandle<UDPWrap>(env(), this);
    } else {
      CHECK_EQ(type, UV_UNKNOWN_HANDLE);
    }

    Local<Object> local_pending_obj;
    if (type != UV_UNKNOWN_HANDLE &...",1,1,stream_wrap.cc,node.LibuvStreamWrap.OnUvRead,,false,254,295,OnUvRead,,,16,"Maybe<void> node.LibuvStreamWrap.OnUvRead (ssize_t,uv_buf_t*)"
285641,METHOD,stream_wrap.cc:<global>,TYPE_DECL,"void LibuvStreamWrap::GetWriteQueueSize(
    const FunctionCallbackInfo<Value>& info) {
  LibuvStreamWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, info.This());

  if (wrap->stream() == nullptr) {
    info.GetReturnValue().Set(0);
    return;
  }

  uint32_t write_queue_size = wrap->stream()->write_queue_size;
  info.GetReturnValue().Set(write_queue_size);
}",1,1,stream_wrap.cc,node.LibuvStreamWrap.GetWriteQueueSize,,false,297,309,GetWriteQueueSize,,,17,void node.LibuvStreamWrap.GetWriteQueueSize (FunctionCallbackInfo<Value>)
285688,METHOD,stream_wrap.cc:<global>,TYPE_DECL,"void LibuvStreamWrap::SetBlocking(const FunctionCallbackInfo<Value>& args) {
  LibuvStreamWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK_GT(args.Length(), 0);
  if (!wrap->IsAlive())
    return args.GetReturnValue().Set(UV_EINVAL);

  bool enable = args[0]->IsTrue();
  args.GetReturnValue().Set(uv_stream_set_blocking(wrap->stream(), enable));
}",1,1,stream_wrap.cc,node.LibuvStreamWrap.SetBlocking,,false,312,322,SetBlocking,,,18,void node.LibuvStreamWrap.SetBlocking (FunctionCallbackInfo<Value>)
285747,METHOD,stream_wrap.cc:<global>,TYPE_DECL,"ShutdownWrap* LibuvStreamWrap::CreateShutdownWrap(Local<Object> object) {
  return new LibuvShutdownWrap(this, object);
}",1,1,stream_wrap.cc,node.LibuvStreamWrap.CreateShutdownWrap,,false,327,329,CreateShutdownWrap,,,21,ShutdownWrap node.LibuvStreamWrap.CreateShutdownWrap (Local<Object>)
285757,METHOD,stream_wrap.cc:<global>,TYPE_DECL,"WriteWrap* LibuvStreamWrap::CreateWriteWrap(Local<Object> object) {
  return new LibuvWriteWrap(this, object);
}",1,1,stream_wrap.cc,node.LibuvStreamWrap.CreateWriteWrap,,false,331,333,CreateWriteWrap,,,22,WriteWrap node.LibuvStreamWrap.CreateWriteWrap (Local<Object>)
285767,METHOD,stream_wrap.cc:<global>,TYPE_DECL,"int LibuvStreamWrap::DoShutdown(ShutdownWrap* req_wrap_) {
  LibuvShutdownWrap* req_wrap = static_cast<LibuvShutdownWrap*>(req_wrap_);
  return req_wrap->Dispatch(uv_shutdown, stream(), AfterUvShutdown);
}",1,1,stream_wrap.cc,node.LibuvStreamWrap.DoShutdown,,false,336,339,DoShutdown,,,23,int node.LibuvStreamWrap.DoShutdown (ShutdownWrap*)
285786,METHOD,stream_wrap.cc:<global>,TYPE_DECL,"void LibuvStreamWrap::AfterUvShutdown(uv_shutdown_t* req, int status) {
  LibuvShutdownWrap* req_wrap = static_cast<LibuvShutdownWrap*>(
      LibuvShutdownWrap::from_req(req));
  CHECK_NOT_NULL(req_wrap);
  HandleScope scope(req_wrap->env()->isolate());
  Context::Scope context_scope(req_wrap->env()->context());
  req_wrap->Done(status);
}",1,1,stream_wrap.cc,node.LibuvStreamWrap.AfterUvShutdown,,false,342,349,AfterUvShutdown,,,24,"void node.LibuvStreamWrap.AfterUvShutdown (uv_shutdown_t*,int)"
285827,METHOD,stream_wrap.cc:<global>,TYPE_DECL,"int LibuvStreamWrap::DoTryWrite(uv_buf_t** bufs, size_t* count) {
  int err;
  size_t written;
  uv_buf_t* vbufs = *bufs;
  size_t vcount = *count;

  err = uv_try_write(stream(), vbufs, vcount);
  if (err == UV_ENOSYS || err == UV_EAGAIN)
    return 0;
  if (err < 0)
    return err;

  // Slice off the buffers: skip all written buffers and slice the one that
  // was partially written.
  written = err;
  for (; vcount > 0; vbufs++, vcount--) {
    // Slice
    if (vbufs[0].len > written) {
      vbufs[0].base += written;
      vbufs[0].len -= written;
      written = 0;
      break;

    // Discard
    } else {
      written -= vbufs[0].len;
    }
  }

  *bufs = vbufs;
  *count = vcount;

  return 0;
}",1,1,stream_wrap.cc,node.LibuvStreamWrap.DoTryWrite,,false,356,389,DoTryWrite,,,25,"int node.LibuvStreamWrap.DoTryWrite (uv_buf_t**,size_t*)"
285929,METHOD,stream_wrap.cc:<global>,TYPE_DECL,"int LibuvStreamWrap::DoWrite(WriteWrap* req_wrap,
                             uv_buf_t* bufs,
                             size_t count,
                             uv_stream_t* send_handle) {
  LibuvWriteWrap* w = static_cast<LibuvWriteWrap*>(req_wrap);
  return w->Dispatch(uv_write2,
                     stream(),
                     bufs,
                     count,
                     send_handle,
                     AfterUvWrite);
}",1,1,stream_wrap.cc,node.LibuvStreamWrap.DoWrite,,false,392,403,DoWrite,,,26,"int node.LibuvStreamWrap.DoWrite (WriteWrap*,uv_buf_t*,size_t,uv_stream_t*)"
285954,METHOD,stream_wrap.cc:<global>,TYPE_DECL,"void LibuvStreamWrap::AfterUvWrite(uv_write_t* req, int status) {
  LibuvWriteWrap* req_wrap = static_cast<LibuvWriteWrap*>(
      LibuvWriteWrap::from_req(req));
  CHECK_NOT_NULL(req_wrap);
  HandleScope scope(req_wrap->env()->isolate());
  Context::Scope context_scope(req_wrap->env()->context());
  req_wrap->Done(status);
}",1,1,stream_wrap.cc,node.LibuvStreamWrap.AfterUvWrite,,false,407,414,AfterUvWrite,,,27,"void node.LibuvStreamWrap.AfterUvWrite (uv_write_t*,int)"
286005,METHOD,stream_wrap.hpp:<global>,TYPE_DECL,<global>,1,29,stream_wrap.hpp,stream_wrap.hpp:<global>,,false,1,131,<global>,,,1,
286030,METHOD,string_bytes.cc:<global>,TYPE_DECL,<global>,1,1,string_bytes.cc,string_bytes.cc:<global>,,false,1,724,<global>,,,1,
286035,METHOD,node.anonymous_namespace_1.ExternString,TYPE_DECL,"~ExternString() override {
    free(const_cast<TypeName*>(data_));
    isolate()->AdjustAmountOfExternalAllocatedMemory(-byte_length());
  }",3,3,string_bytes.cc,node.anonymous_namespace_2.ExternString.~ExternString,,false,58,61,~ExternString,,,1,ANY node.anonymous_namespace_2.ExternString.~ExternString ()
286049,METHOD,node.anonymous_namespace_1.ExternString,TYPE_DECL,"const TypeName* data() const override {
    return data_;
  }",3,3,string_bytes.cc,node.anonymous_namespace_5.ExternString.data,,false,63,65,data,,,2,TypeName node.anonymous_namespace_5.ExternString.data ()
286055,METHOD,node.anonymous_namespace_1.ExternString,TYPE_DECL,"size_t length() const override {
    return length_;
  }",3,3,string_bytes.cc,node.anonymous_namespace_6.ExternString.length,,false,67,69,length,,,3,size_t node.anonymous_namespace_6.ExternString.length ()
286061,METHOD,node.anonymous_namespace_1.ExternString,TYPE_DECL,"int64_t byte_length() const {
    return length() * sizeof(*data());
  }",3,3,string_bytes.cc,node.anonymous_namespace_7.ExternString.byte_length,,false,71,73,byte_length,,,4,int64_t node.anonymous_namespace_7.ExternString.byte_length ()
286071,METHOD,node.anonymous_namespace_1.ExternString,TYPE_DECL,"static MaybeLocal<Value> NewFromCopy(Isolate* isolate,
                                       const TypeName* data,
                                       size_t length,
                                       Local<Value>* error) {
    if (length == 0)
      return String::Empty(isolate);

    if (length < EXTERN_APEX)
      return NewSimpleFromCopy(isolate, data, length, error);

    TypeName* new_data = node::UncheckedMalloc<TypeName>(length);
    if (new_data == nullptr) {
      *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
      return MaybeLocal<Value>();
    }
    memcpy(new_data, data, length * sizeof(*new_data));

    return ExternString<ResourceType, TypeName>::New(isolate,
                                                     new_data,
                                                     length,
                                                     error);
  }",3,17,string_bytes.cc,node.anonymous_namespace_10.ExternString.NewFromCopy,,false,75,96,NewFromCopy,,,5,"MaybeLocal<Value> node.anonymous_namespace_10.ExternString.NewFromCopy (Isolate*,TypeName*,size_t,Local<Value>*)"
286145,METHOD,node.anonymous_namespace_1.ExternString,TYPE_DECL,"static MaybeLocal<Value> New(Isolate* isolate,
                               TypeName* data,
                               size_t length,
                               Local<Value>* error) {
    if (length == 0)
      return String::Empty(isolate);

    if (length < EXTERN_APEX) {
      MaybeLocal<Value> str = NewSimpleFromCopy(isolate, data, length, error);
      free(data);
      return str;
    }

    ExternString* h_str = new ExternString<ResourceType, TypeName>(isolate,
                                                                   data,
                                                                   length);
    MaybeLocal<Value> str = NewExternal(isolate, h_str);
    isolate->AdjustAmountOfExternalAllocatedMemory(h_str->byte_length());

    if (str.IsEmpty()) {
      delete h_str;
      *error = node::ERR_STRING_TOO_LONG(isolate);
      return MaybeLocal<Value>();
    }

    return str.ToLocalChecked();
  }",3,17,string_bytes.cc,node.anonymous_namespace_11.ExternString.New,,false,99,125,New,,,6,"MaybeLocal<Value> node.anonymous_namespace_11.ExternString.New (Isolate*,TypeName*,size_t,Local<Value>*)"
286234,METHOD,node.anonymous_namespace_1.ExternString,TYPE_DECL,inline Isolate* isolate() const { return isolate_; },3,54,string_bytes.cc,node.anonymous_namespace_12.ExternString.isolate,,false,127,127,isolate,,,7,Isolate node.anonymous_namespace_12.ExternString.isolate ()
286240,METHOD,node.anonymous_namespace_1.ExternString,TYPE_DECL,"ExternString(Isolate* isolate, const TypeName* data, size_t length)
    : isolate_(isolate), data_(data), length_(length) { }",3,57,string_bytes.cc,node.anonymous_namespace_13.ExternString.ExternString,,false,130,131,ExternString,,,8,"ANY node.anonymous_namespace_13.ExternString.ExternString (Isolate*,TypeName*,size_t)"
286247,METHOD,node.anonymous_namespace_1.ExternString,TYPE_DECL,"static MaybeLocal<Value> NewExternal(Isolate* isolate,
                                       ExternString* h_str);",28,59,string_bytes.cc,node.anonymous_namespace_14.ExternString.NewExternal,,false,132,133,NewExternal,,,9,"MaybeLocal<Value> node.anonymous_namespace_14.ExternString.NewExternal (Isolate*,ExternString*)"
286253,METHOD,node.anonymous_namespace_1.ExternString,TYPE_DECL,"static MaybeLocal<Value> NewSimpleFromCopy(Isolate* isolate,
                                             const TypeName* data,
                                             size_t length,
                                             Local<Value>* error);",28,65,string_bytes.cc,node.anonymous_namespace_15.ExternString.NewSimpleFromCopy,,false,136,139,NewSimpleFromCopy,,,10,"MaybeLocal<Value> node.anonymous_namespace_15.ExternString.NewSimpleFromCopy (Isolate*,TypeName*,size_t,Local<Value>*)"
286266,METHOD,string_bytes.cc:<global>,TYPE_DECL,"MaybeLocal<Value> ExternOneByteString::NewExternal(
    Isolate* isolate, ExternOneByteString* h_str) {
  return String::NewExternalOneByte(isolate, h_str).FromMaybe(Local<Value>());
}",1,1,string_bytes.cc,node.anonymous_namespace_16.ExternOneByteString.NewExternal,,false,154,157,NewExternal,,,4,"MaybeLocal<Value> node.anonymous_namespace_16.ExternOneByteString.NewExternal<> (Isolate*,ExternOneByteString*)"
286283,METHOD,string_bytes.cc:<global>,TYPE_DECL,"MaybeLocal<Value> ExternTwoByteString::NewExternal(
    Isolate* isolate, ExternTwoByteString* h_str) {
  return String::NewExternalTwoByte(isolate, h_str).FromMaybe(Local<Value>());
}",1,1,string_bytes.cc,node.anonymous_namespace_17.ExternTwoByteString.NewExternal,,false,161,164,NewExternal,,,5,"MaybeLocal<Value> node.anonymous_namespace_17.ExternTwoByteString.NewExternal<> (Isolate*,ExternTwoByteString*)"
286300,METHOD,string_bytes.cc:<global>,TYPE_DECL,"MaybeLocal<Value> ExternOneByteString::NewSimpleFromCopy(Isolate* isolate,
                                                         const char* data,
                                                         size_t length,
                                                         Local<Value>* error) {
  MaybeLocal<String> str =
      String::NewFromOneByte(isolate,
                             reinterpret_cast<const uint8_t*>(data),
                             v8::NewStringType::kNormal,
                             length);
  if (str.IsEmpty()) {
    *error = node::ERR_STRING_TOO_LONG(isolate);
    return MaybeLocal<Value>();
  }
  return str.ToLocalChecked();
}",1,1,string_bytes.cc,node.anonymous_namespace_18.ExternOneByteString.NewSimpleFromCopy,,false,167,181,NewSimpleFromCopy,,,6,"MaybeLocal<Value> node.anonymous_namespace_18.ExternOneByteString.NewSimpleFromCopy<> (Isolate*,char*,size_t,Local<Value>*)"
286349,METHOD,string_bytes.cc:<global>,TYPE_DECL,"MaybeLocal<Value> ExternTwoByteString::NewSimpleFromCopy(Isolate* isolate,
                                                         const uint16_t* data,
                                                         size_t length,
                                                         Local<Value>* error) {
  MaybeLocal<String> str =
      String::NewFromTwoByte(isolate,
                             data,
                             v8::NewStringType::kNormal,
                             length);
  if (str.IsEmpty()) {
    *error = node::ERR_STRING_TOO_LONG(isolate);
    return MaybeLocal<Value>();
  }
  return str.ToLocalChecked();
}",1,1,string_bytes.cc,node.anonymous_namespace_19.ExternTwoByteString.NewSimpleFromCopy,,false,185,199,NewSimpleFromCopy,,,7,"MaybeLocal<Value> node.anonymous_namespace_19.ExternTwoByteString.NewSimpleFromCopy<> (Isolate*,uint16_t*,size_t,Local<Value>*)"
287340,METHOD,string_bytes.cc:<global>,TYPE_DECL,"static inline unsigned unhex(uint8_t x) {
  return unhex_table[x];
}",1,1,string_bytes.cc,node.unhex,,false,243,245,unhex,,,6,unsigned node.unhex (uint8_t)
287349,METHOD,string_bytes.cc:<global>,TYPE_DECL,"static size_t hex_decode(char* buf,
                         size_t len,
                         const TypeName* src,
                         const size_t srcLen) {
  size_t i;
  for (i = 0; i < len && i * 2 + 1 < srcLen; ++i) {
    unsigned a = unhex(static_cast<uint8_t>(src[i * 2 + 0]));
    unsigned b = unhex(static_cast<uint8_t>(src[i * 2 + 1]));
    if (!~a || !~b)
      return i;
    buf[i] = (a << 4) | b;
  }

  return i;
}",1,1,string_bytes.cc,node.hex_decode,,false,248,262,hex_decode,,,7,"size_t node.hex_decode<TypeName> (char*,size_t,TypeName*,size_t)"
287425,METHOD,string_bytes.cc:<global>,TYPE_DECL,"size_t StringBytes::WriteUCS2(
    Isolate* isolate, char* buf, size_t buflen, Local<String> str, int flags) {
  uint16_t* const dst = reinterpret_cast<uint16_t*>(buf);

  size_t max_chars = buflen / sizeof(*dst);
  if (max_chars == 0) {
    return 0;
  }

  uint16_t* const aligned_dst = AlignUp(dst, sizeof(*dst));
  size_t nchars;
  if (aligned_dst == dst) {
    nchars = str->Write(isolate, dst, 0, max_chars, flags);
    return nchars * sizeof(*dst);
  }

  CHECK_EQ(reinterpret_cast<uintptr_t>(aligned_dst) % sizeof(*dst), 0);

  // Write all but the last char
  max_chars = std::min(max_chars, static_cast<size_t>(str->Length()));
  if (max_chars == 0) {
    return 0;
  }
  nchars = str->Write(isolate, aligned_dst, 0, max_chars - 1, flags);
  CHECK_EQ(nchars, max_chars - 1);

  // Shift everything to unaligned-left
  memmove(dst, aligned_dst, nchars * sizeof(*dst));

  // One more char to be written
  uint16_t last;
  CHECK_EQ(str->Write(isolate, &last, nchars, 1, flags), 1);
  memcp...",1,1,string_bytes.cc,node.StringBytes.WriteUCS2,,false,264,300,WriteUCS2,,,8,"size_t node.StringBytes.WriteUCS2 (Isolate*,char*,size_t,Local<String>,int)"
287574,METHOD,string_bytes.cc:<global>,TYPE_DECL,"size_t StringBytes::Write(Isolate* isolate,
                          char* buf,
                          size_t buflen,
                          Local<Value> val,
                          enum encoding encoding) {
  HandleScope scope(isolate);
  size_t nbytes;

  CHECK(val->IsString() == true);
  Local<String> str = val.As<String>();

  int flags = String::HINT_MANY_WRITES_EXPECTED |
              String::NO_NULL_TERMINATION |
              String::REPLACE_INVALID_UTF8;

  switch (encoding) {
    case ASCII:
    case LATIN1:
      if (str->IsExternalOneByte()) {
        auto ext = str->GetExternalOneByteStringResource();
        nbytes = std::min(buflen, ext->length());
        memcpy(buf, ext->data(), nbytes);
      } else {
        uint8_t* const dst = reinterpret_cast<uint8_t*>(buf);
        nbytes = str->WriteOneByte(isolate, dst, 0, buflen, flags);
      }
      break;

    case BUFFER:
    case UTF8:
      nbytes = str->WriteUtf8(isolate, buf, buflen, nullptr, flags);
    ...",1,1,string_bytes.cc,node.StringBytes.Write,,false,302,375,Write,,,9,"size_t node.StringBytes.Write (Isolate*,char*,size_t,Local<Value>,encoding)"
287809,METHOD,string_bytes.cc:<global>,TYPE_DECL,"Maybe<size_t> StringBytes::StorageSize(Isolate* isolate,
                                       Local<Value> val,
                                       enum encoding encoding) {
  HandleScope scope(isolate);
  size_t data_size = 0;
  bool is_buffer = Buffer::HasInstance(val);

  if (is_buffer && (encoding == BUFFER || encoding == LATIN1)) {
    return Just(Buffer::Length(val));
  }

  Local<String> str;
  if (!val->ToString(isolate->GetCurrentContext()).ToLocal(&str))
    return Nothing<size_t>();

  switch (encoding) {
    case ASCII:
    case LATIN1:
      data_size = str->Length();
      break;

    case BUFFER:
    case UTF8:
      // A single UCS2 codepoint never takes up more than 3 utf8 bytes.
      // It is an exercise for the caller to decide when a string is
      // long enough to justify calling Size() instead of StorageSize()
      data_size = 3 * str->Length();
      break;

    case UCS2:
      data_size = str->Length() * sizeof(uint16_t);
      break;

    case BASE...",1,1,string_bytes.cc,node.StringBytes.StorageSize,,false,380,429,StorageSize,,,10,"Maybe<size_t> node.StringBytes.StorageSize (Isolate*,Local<Value>,encoding)"
287951,METHOD,string_bytes.cc:<global>,TYPE_DECL,"Maybe<size_t> StringBytes::Size(Isolate* isolate,
                                Local<Value> val,
                                enum encoding encoding) {
  HandleScope scope(isolate);

  if (Buffer::HasInstance(val) && (encoding == BUFFER || encoding == LATIN1))
    return Just(Buffer::Length(val));

  Local<String> str;
  if (!val->ToString(isolate->GetCurrentContext()).ToLocal(&str))
    return Nothing<size_t>();

  switch (encoding) {
    case ASCII:
    case LATIN1:
      return Just<size_t>(str->Length());

    case BUFFER:
    case UTF8:
      return Just<size_t>(str->Utf8Length(isolate));

    case UCS2:
      return Just(str->Length() * sizeof(uint16_t));

    case BASE64URL:
      // Fall through
    case BASE64: {
      String::Value value(isolate, str);
      return Just(base64_decoded_size(*value, value.length()));
    }

    case HEX:
      return Just<size_t>(str->Length() / 2);
  }

  UNREACHABLE();
}",1,1,string_bytes.cc,node.StringBytes.Size,,false,431,467,Size,,,11,"Maybe<size_t> node.StringBytes.Size (Isolate*,Local<Value>,encoding)"
288079,METHOD,string_bytes.cc:<global>,TYPE_DECL,"static void force_ascii_slow(const char* src, char* dst, size_t len) {
  for (size_t i = 0; i < len; ++i) {
    dst[i] = src[i] & 0x7f;
  }
}",1,1,string_bytes.cc,node.force_ascii_slow,,false,469,473,force_ascii_slow,,,12,"void node.force_ascii_slow (char*,char*,size_t)"
288107,METHOD,string_bytes.cc:<global>,TYPE_DECL,"static void force_ascii(const char* src, char* dst, size_t len) {
  if (len < 16) {
    force_ascii_slow(src, dst, len);
    return;
  }

  const unsigned bytes_per_word = sizeof(uintptr_t);
  const unsigned align_mask = bytes_per_word - 1;
  const unsigned src_unalign = reinterpret_cast<uintptr_t>(src) & align_mask;
  const unsigned dst_unalign = reinterpret_cast<uintptr_t>(dst) & align_mask;

  if (src_unalign > 0) {
    if (src_unalign == dst_unalign) {
      const unsigned unalign = bytes_per_word - src_unalign;
      force_ascii_slow(src, dst, unalign);
      src += unalign;
      dst += unalign;
      len -= src_unalign;
    } else {
      force_ascii_slow(src, dst, len);
      return;
    }
  }

#if defined(_WIN64) || defined(_LP64)
  const uintptr_t mask = ~0x8080808080808080ll;
#else
  const uintptr_t mask = ~0x80808080l;
#endif

  const uintptr_t* srcw = reinterpret_cast<const uintptr_t*>(src);
  uintptr_t* dstw = reinterpret_cast<uintptr_t*>(dst);

  for (size_t i = 0, n ...",1,1,string_bytes.cc,node.force_ascii,,false,476,518,force_ascii,,,13,"void node.force_ascii (char*,char*,size_t)"
288256,METHOD,string_bytes.cc:<global>,TYPE_DECL,"size_t StringBytes::hex_encode(
    const char* src,
    size_t slen,
    char* dst,
    size_t dlen) {
  // We know how much we'll write, just make sure that there's space.
  CHECK(dlen >= slen * 2 &&
      ""not enough space provided for hex encode"");

  dlen = slen * 2;
  for (uint32_t i = 0, k = 0; k < dlen; i += 1, k += 2) {
    static const char hex[] = ""0123456789abcdef"";
    uint8_t val = static_cast<uint8_t>(src[i]);
    dst[k + 0] = hex[val >> 4];
    dst[k + 1] = hex[val & 15];
  }

  return dlen;
}",1,1,string_bytes.cc,node.StringBytes.hex_encode,,false,521,539,hex_encode,,,14,"size_t node.StringBytes.hex_encode (char*,size_t,char*,size_t)"
288334,METHOD,string_bytes.cc:<global>,TYPE_DECL,"std::string StringBytes::hex_encode(const char* src, size_t slen) {
  size_t dlen = slen * 2;
  std::string dst(dlen, '\0');
  hex_encode(src, slen, dst.data(), dlen);
  return dst;
}",1,1,string_bytes.cc,node.StringBytes.hex_encode,,false,541,546,hex_encode,,,15,"string node.StringBytes.hex_encode (char*,size_t)"
288360,METHOD,string_bytes.cc:<global>,TYPE_DECL,"MaybeLocal<Value> StringBytes::Encode(Isolate* isolate,
                                      const char* buf,
                                      size_t buflen,
                                      enum encoding encoding,
                                      Local<Value>* error) {
  CHECK_BUFLEN_IN_RANGE(buflen);

  if (!buflen && encoding != BUFFER) {
    return String::Empty(isolate);
  }

  MaybeLocal<String> val;

  switch (encoding) {
    case BUFFER:
      {
        auto maybe_buf = Buffer::Copy(isolate, buf, buflen);
        Local<v8::Object> buf;
        if (!maybe_buf.ToLocal(&buf)) {
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
        }
        return buf;
      }

    case ASCII:
      if (simdutf::validate_ascii_with_errors(buf, buflen).error) {
        // The input contains non-ASCII bytes.
        char* out = node::UncheckedMalloc(buflen);
        if (out == nullptr) {
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
          re...",1,2,string_bytes.cc,node.StringBytes.Encode,,false,557,687,Encode,,,16,"MaybeLocal<Value> node.StringBytes.Encode (Isolate*,char*,size_t,encoding,Local<Value>*)"
288887,METHOD,string_bytes.cc:<global>,TYPE_DECL,"MaybeLocal<Value> StringBytes::Encode(Isolate* isolate,
                                      const uint16_t* buf,
                                      size_t buflen,
                                      Local<Value>* error) {
  if (buflen == 0) return String::Empty(isolate);
  CHECK_BUFLEN_IN_RANGE(buflen);

  // Node's ""ucs2"" encoding expects LE character data inside a
  // Buffer, so we need to reorder on BE platforms.  See
  // https://nodejs.org/api/buffer.html regarding Node's ""ucs2""
  // encoding specification
  if (IsBigEndian()) {
    uint16_t* dst = node::UncheckedMalloc<uint16_t>(buflen);
    if (dst == nullptr) {
      *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
      return MaybeLocal<Value>();
    }
    size_t nbytes = buflen * sizeof(uint16_t);
    memcpy(dst, buf, nbytes);
    SwapBytes16(reinterpret_cast<char*>(dst), nbytes);
    return ExternTwoByteString::New(isolate, dst, buflen, error);
  } else {
    return ExternTwoByteString::NewFromCopy(isolate, ...",1,2,string_bytes.cc,node.StringBytes.Encode,,false,690,714,Encode,,,17,"MaybeLocal<Value> node.StringBytes.Encode (Isolate*,uint16_t*,size_t,Local<Value>*)"
288993,METHOD,string_bytes.cc:<global>,TYPE_DECL,"MaybeLocal<Value> StringBytes::Encode(Isolate* isolate,
                                      const char* buf,
                                      enum encoding encoding,
                                      Local<Value>* error) {
  const size_t len = strlen(buf);
  return Encode(isolate, buf, len, encoding, error);
}",1,1,string_bytes.cc,node.StringBytes.Encode,,false,716,722,Encode,,,18,"MaybeLocal<Value> node.StringBytes.Encode (Isolate*,char*,encoding,Local<Value>*)"
289022,METHOD,string_bytes.hpp:<global>,TYPE_DECL,<global>,1,30,string_bytes.hpp,string_bytes.hpp:<global>,,false,1,120,<global>,,,1,
289029,METHOD,string_decoder-inl.hpp:<global>,TYPE_DECL,<global>,1,37,string_decoder-inl.hpp,string_decoder-inl.hpp:<global>,,false,1,37,<global>,,,1,
289050,METHOD,string_decoder.cc:<global>,TYPE_DECL,<global>,1,33,string_decoder.hpp,string_decoder.cc:<global>,,false,1,348,<global>,,,1,
289054,METHOD,string_decoder.cc:<global>,TYPE_DECL,"MaybeLocal<String> MakeString(Isolate* isolate,
                              const char* data,
                              size_t length,
                              enum encoding encoding) {
  Local<Value> error;
  MaybeLocal<Value> ret;
  if (encoding == UTF8) {
    MaybeLocal<String> utf8_string = String::NewFromUtf8(
        isolate,
        data,
        v8::NewStringType::kNormal,
        length);
    if (utf8_string.IsEmpty()) {
      isolate->ThrowException(node::ERR_STRING_TOO_LONG(isolate));
      return MaybeLocal<String>();
    } else {
      return utf8_string;
    }
  } else {
    ret = StringBytes::Encode(
        isolate,
        data,
        length,
        encoding,
        &error);
  }

  if (ret.IsEmpty()) {
    CHECK(!error.IsEmpty());
    isolate->ThrowException(error);
  }

  DCHECK(ret.IsEmpty() || ret.ToLocalChecked()->IsString());
  return ret.FromMaybe(Local<Value>()).As<String>();
}",1,1,string_decoder.cc,node.anonymous_namespace_1.MakeString,,false,27,61,MakeString,,,1,"MaybeLocal<String> node.anonymous_namespace_1.MakeString (Isolate*,char*,size_t,encoding)"
289169,METHOD,string_decoder.cc:<global>,TYPE_DECL,"MaybeLocal<String> StringDecoder::DecodeData(Isolate* isolate,
                                             const char* data,
                                             size_t* nread_ptr) {
  Local<String> prepend, body;

  size_t nread = *nread_ptr;

  if (Encoding() == UTF8 ||
      Encoding() == UCS2 ||
      Encoding() == BASE64 ||
      Encoding() == BASE64URL) {
    // See if we want bytes to finish a character from the previous
    // chunk; if so, copy the new bytes to the missing bytes buffer
    // and create a small string from it that is to be prepended to the
    // main body.
    if (MissingBytes() > 0) {
      // There are never more bytes missing than the pre-calculated maximum.
      CHECK_LE(MissingBytes() + BufferedBytes(),
               kIncompleteCharactersEnd);
      if (Encoding() == UTF8) {
        // For UTF-8, we need special treatment to align with the V8 decoder:
        // If an incomplete character is found at a chunk boundary, we use
        // its ...",1,1,string_decoder.cc,node.StringDecoder.DecodeData,,false,66,235,DecodeData,,,2,"MaybeLocal<String> node.StringDecoder.DecodeData (Isolate*,char*,size_t*)"
289657,METHOD,string_decoder.cc:<global>,TYPE_DECL,"MaybeLocal<String> StringDecoder::FlushData(Isolate* isolate) {
  if (Encoding() == ASCII || Encoding() == HEX || Encoding() == LATIN1) {
    CHECK_EQ(MissingBytes(), 0);
    CHECK_EQ(BufferedBytes(), 0);
  }

  if (Encoding() == UCS2 && BufferedBytes() % 2 == 1) {
    // Ignore a single trailing byte, like the JS decoder does.
    state_[kMissingBytes]--;
    state_[kBufferedBytes]--;
  }

  if (BufferedBytes() == 0)
    return String::Empty(isolate);

  MaybeLocal<String> ret =
      MakeString(isolate,
                 IncompleteCharacterBuffer(),
                 BufferedBytes(),
                 Encoding());

  state_[kMissingBytes] = 0;
  state_[kBufferedBytes] = 0;

  return ret;
}",1,1,string_decoder.cc,node.StringDecoder.FlushData,,false,237,262,FlushData,,,3,MaybeLocal<String> node.StringDecoder.FlushData (Isolate*)
289735,METHOD,string_decoder.cc:<global>,TYPE_DECL,"void DecodeData(const FunctionCallbackInfo<Value>& args) {
  StringDecoder* decoder =
      reinterpret_cast<StringDecoder*>(Buffer::Data(args[0]));
  CHECK_NOT_NULL(decoder);

  CHECK(args[1]->IsArrayBufferView());
  ArrayBufferViewContents<char> content(args[1].As<ArrayBufferView>());
  size_t length = content.length();

  MaybeLocal<String> ret =
      decoder->DecodeData(args.GetIsolate(), content.data(), &length);
  if (!ret.IsEmpty())
    args.GetReturnValue().Set(ret.ToLocalChecked());
}",1,1,string_decoder.cc,node.anonymous_namespace_3.DecodeData,,false,266,279,DecodeData,,,1,void node.anonymous_namespace_3.DecodeData (FunctionCallbackInfo<Value>)
289814,METHOD,string_decoder.cc:<global>,TYPE_DECL,"void FlushData(const FunctionCallbackInfo<Value>& args) {
  StringDecoder* decoder =
      reinterpret_cast<StringDecoder*>(Buffer::Data(args[0]));
  CHECK_NOT_NULL(decoder);
  MaybeLocal<String> ret = decoder->FlushData(args.GetIsolate());
  if (!ret.IsEmpty())
    args.GetReturnValue().Set(ret.ToLocalChecked());
}",1,1,string_decoder.cc,node.anonymous_namespace_4.FlushData,,false,281,288,FlushData,,,2,void node.anonymous_namespace_4.FlushData (FunctionCallbackInfo<Value>)
289865,METHOD,string_decoder.cc:<global>,TYPE_DECL,"void InitializeStringDecoder(Local<Object> target,
                             Local<Value> unused,
                             Local<Context> context,
                             void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

#define SET_DECODER_CONSTANT(name)                                            \
  target->Set(context,                                                        \
              FIXED_ONE_BYTE_STRING(isolate, #name),                          \
              Integer::New(isolate, StringDecoder::name)).FromJust()

  SET_DECODER_CONSTANT(kIncompleteCharactersStart);
  SET_DECODER_CONSTANT(kIncompleteCharactersEnd);
  SET_DECODER_CONSTANT(kMissingBytes);
  SET_DECODER_CONSTANT(kBufferedBytes);
  SET_DECODER_CONSTANT(kEncodingField);
  SET_DECODER_CONSTANT(kNumFields);

  Local<Array> encodings = Array::New(isolate);
#define ADD_TO_ENCODINGS_ARRAY(cname, jsname)                                 \
  encodings...",1,2,string_decoder.cc,node.anonymous_namespace_5.InitializeStringDecoder,,false,290,333,InitializeStringDecoder,,,3,"void node.anonymous_namespace_5.InitializeStringDecoder (Local<Object>,Local<Value>,Local<Context>,void*)"
290209,METHOD,string_decoder.cc:<global>,TYPE_DECL,"void RegisterStringDecoderExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(DecodeData);
  registry->Register(FlushData);
}",1,1,string_decoder.cc,node.RegisterStringDecoderExternalReferences,,false,337,341,RegisterStringDecoderExternalReferences,,,5,void node.RegisterStringDecoderExternalReferences (ExternalReferenceRegistry*)
290230,METHOD,string_decoder.hpp:<global>,TYPE_DECL,<global>,1,33,string_decoder.hpp,string_decoder.hpp:<global>,,false,1,50,<global>,,,1,
290241,METHOD,string_search.hpp:<global>,TYPE_DECL,<global>,1,31,string_search.hpp,string_search.hpp:<global>,,false,1,638,<global>,,,1,
290244,METHOD,tcp_wrap.cc:<global>,TYPE_DECL,"[port](const char* ip_address, sockaddr_in* addr) {
      return uv_ip4_addr(ip_address, port, addr);
  }",24,3,tcp_wrap.cc,"args, [port](const char* ip_address, sockaddr_in* addr) { return uv_ip4_addr(ip_address, port, addr); }.<lambda>0",,false,300,302,<lambda>0,,,1,"ANY args, [port](const char* ip_address, sockaddr_in* addr) { return uv_ip4_addr(ip_address, port, addr); }.<lambda>0 (char*,sockaddr_in*)"
290258,METHOD,tcp_wrap.cc:<global>,TYPE_DECL,"[port](const char* ip_address, sockaddr_in6* addr) {
      return uv_ip6_addr(ip_address, port, addr);
  }",25,3,tcp_wrap.cc,"args, [port](const char* ip_address, sockaddr_in6* addr) { return uv_ip6_addr(ip_address, port, addr); }.<lambda>1",,false,312,314,<lambda>1,,,1,"ANY args, [port](const char* ip_address, sockaddr_in6* addr) { return uv_ip6_addr(ip_address, port, addr); }.<lambda>1 (char*,sockaddr_in6*)"
290296,METHOD,tcp_wrap.cc:<global>,TYPE_DECL,<global>,1,1,tcp_wrap.cc,tcp_wrap.cc:<global>,,false,1,455,<global>,,,1,
290299,METHOD,tcp_wrap.cc:<global>,TYPE_DECL,"MaybeLocal<Object> TCPWrap::Instantiate(Environment* env,
                                        AsyncWrap* parent,
                                        TCPWrap::SocketType type) {
  EscapableHandleScope handle_scope(env->isolate());
  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(parent);
  CHECK_EQ(env->tcp_constructor_template().IsEmpty(), false);
  Local<Function> constructor = env->tcp_constructor_template()
                                    ->GetFunction(env->context())
                                    .ToLocalChecked();
  CHECK_EQ(constructor.IsEmpty(), false);
  Local<Value> type_value = Int32::New(env->isolate(), type);
  return handle_scope.EscapeMaybe(
      constructor->NewInstance(env->context(), 1, &type_value));
}",1,1,tcp_wrap.cc,node.TCPWrap.Instantiate,,false,56,69,Instantiate,,,1,"MaybeLocal<Object> node.TCPWrap.Instantiate (Environment*,AsyncWrap*,ANY)"
290381,METHOD,tcp_wrap.cc:<global>,TYPE_DECL,"void TCPWrap::Initialize(Local<Object> target,
                         Local<Value> unused,
                         Local<Context> context,
                         void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->InstanceTemplate()->SetInternalFieldCount(StreamBase::kInternalFieldCount);

  // Init properties
  t->InstanceTemplate()->Set(FIXED_ONE_BYTE_STRING(env->isolate(), ""reading""),
                             Boolean::New(env->isolate(), false));
  t->InstanceTemplate()->Set(env->owner_symbol(), Null(env->isolate()));
  t->InstanceTemplate()->Set(env->onconnection_string(), Null(env->isolate()));

  t->Inherit(LibuvStreamWrap::GetConstructorTemplate(env));

  SetProtoMethod(isolate, t, ""open"", Open);
  SetProtoMethod(isolate, t, ""bind"", Bind);
  SetProtoMethod(isolate, t, ""listen"", Listen);
  SetProtoMethod(isolate, t, ""connect"", Connect);
  SetPro...",1,2,tcp_wrap.cc,node.TCPWrap.Initialize,,false,72,129,Initialize,,,2,"void node.TCPWrap.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
290900,METHOD,tcp_wrap.cc:<global>,TYPE_DECL,"void TCPWrap::RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(New);
  registry->Register(Open);
  registry->Register(Bind);
  registry->Register(Listen);
  registry->Register(Connect);
  registry->Register(Bind6);
  registry->Register(Connect6);

  registry->Register(GetSockOrPeerName<TCPWrap, uv_tcp_getsockname>);
  registry->Register(GetSockOrPeerName<TCPWrap, uv_tcp_getpeername>);
  registry->Register(SetNoDelay);
  registry->Register(SetKeepAlive);
  registry->Register(Reset);
#ifdef _WIN32
  registry->Register(SetSimultaneousAccepts);
#endif
}",1,1,tcp_wrap.cc,node.TCPWrap.RegisterExternalReferences,,false,131,148,RegisterExternalReferences,,,3,void node.TCPWrap.RegisterExternalReferences (ExternalReferenceRegistry*)
290965,METHOD,tcp_wrap.cc:<global>,TYPE_DECL,"void TCPWrap::New(const FunctionCallbackInfo<Value>& args) {
  // This constructor should not be exposed to public javascript.
  // Therefore we assert that we are not trying to call this as a
  // normal function.
  CHECK(args.IsConstructCall());
  CHECK(args[0]->IsInt32());
  Environment* env = Environment::GetCurrent(args);

  int type_value = args[0].As<Int32>()->Value();
  TCPWrap::SocketType type = static_cast<TCPWrap::SocketType>(type_value);

  ProviderType provider;
  switch (type) {
    case SOCKET:
      provider = PROVIDER_TCPWRAP;
      break;
    case SERVER:
      provider = PROVIDER_TCPSERVERWRAP;
      break;
    default:
      UNREACHABLE();
  }

  new TCPWrap(env, args.This(), provider);
}",1,1,tcp_wrap.cc,node.TCPWrap.New,,false,150,174,New,,,4,void node.TCPWrap.New (FunctionCallbackInfo<Value>)
291034,METHOD,tcp_wrap.cc:<global>,TYPE_DECL,"TCPWrap::TCPWrap(Environment* env, Local<Object> object, ProviderType provider)
    : ConnectionWrap(env, object, provider) {
  int r = uv_tcp_init(env->event_loop(), &handle_);
  CHECK_EQ(r, 0);  // How do we proxy this error up to javascript?
                   // Suggestion: uv_tcp_init() returns void.
}",1,1,tcp_wrap.cc,node.TCPWrap.TCPWrap,,false,177,182,TCPWrap,,,5,"ANY node.TCPWrap.TCPWrap (Environment*,Local<Object>,ProviderType)"
291054,METHOD,tcp_wrap.cc:<global>,TYPE_DECL,"void TCPWrap::SetNoDelay(const FunctionCallbackInfo<Value>& args) {
  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  int enable = static_cast<int>(args[0]->IsTrue());
  int err = uv_tcp_nodelay(&wrap->handle_, enable);
  args.GetReturnValue().Set(err);
}",1,1,tcp_wrap.cc,node.TCPWrap.SetNoDelay,,false,185,193,SetNoDelay,,,6,void node.TCPWrap.SetNoDelay (FunctionCallbackInfo<Value>)
291103,METHOD,tcp_wrap.cc:<global>,TYPE_DECL,"void TCPWrap::SetKeepAlive(const FunctionCallbackInfo<Value>& args) {
  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  Environment* env = wrap->env();
  int enable;
  if (!args[0]->Int32Value(env->context()).To(&enable)) return;
  unsigned int delay = static_cast<unsigned int>(args[1].As<Uint32>()->Value());
  int err = uv_tcp_keepalive(&wrap->handle_, enable, delay);
  args.GetReturnValue().Set(err);
}",1,1,tcp_wrap.cc,node.TCPWrap.SetKeepAlive,,false,196,207,SetKeepAlive,,,7,void node.TCPWrap.SetKeepAlive (FunctionCallbackInfo<Value>)
291183,METHOD,tcp_wrap.cc:<global>,TYPE_DECL,"void TCPWrap::Open(const FunctionCallbackInfo<Value>& args) {
  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  int64_t val;
  if (!args[0]->IntegerValue(args.GetIsolate()->GetCurrentContext()).To(&val))
    return;
  int fd = static_cast<int>(val);
  int err = uv_tcp_open(&wrap->handle_, fd);

  if (err == 0)
    wrap->set_fd(fd);

  args.GetReturnValue().Set(err);
}",1,1,tcp_wrap.cc,node.TCPWrap.Open,,false,223,238,Open,,,8,void node.TCPWrap.Open (FunctionCallbackInfo<Value>)
291260,METHOD,tcp_wrap.cc:<global>,TYPE_DECL,"void TCPWrap::Bind(
    const FunctionCallbackInfo<Value>& args,
    int family,
    std::function<int(const char* ip_address, int port, T* addr)> uv_ip_addr) {
  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  Environment* env = wrap->env();
  node::Utf8Value ip_address(env->isolate(), args[0]);
  int port;
  unsigned int flags = 0;
  if (!args[1]->Int32Value(env->context()).To(&port)) return;
  if (family == AF_INET6 &&
      !args[2]->Uint32Value(env->context()).To(&flags)) {
    return;
  }

  T addr;
  int err = uv_ip_addr(*ip_address, port, &addr);

  if (err == 0) {
    err = uv_tcp_bind(&wrap->handle_,
                      reinterpret_cast<const sockaddr*>(&addr),
                      flags);
  }
  args.GetReturnValue().Set(err);
}",1,1,tcp_wrap.cc,node.TCPWrap.Bind,,false,241,268,Bind,,,9,"void node.TCPWrap.Bind<T> (FunctionCallbackInfo<Value>,int,ANY)"
291381,METHOD,tcp_wrap.cc:<global>,TYPE_DECL,"void TCPWrap::Bind(const FunctionCallbackInfo<Value>& args) {
  Bind<sockaddr_in>(args, AF_INET, uv_ip4_addr);
}",1,1,tcp_wrap.cc,node.TCPWrap.Bind,,false,270,272,Bind,,,10,void node.TCPWrap.Bind (FunctionCallbackInfo<Value>)
291395,METHOD,tcp_wrap.cc:<global>,TYPE_DECL,"void TCPWrap::Bind6(const FunctionCallbackInfo<Value>& args) {
  Bind<sockaddr_in6>(args, AF_INET6, uv_ip6_addr);
}",1,1,tcp_wrap.cc,node.TCPWrap.Bind6,,false,275,277,Bind6,,,11,void node.TCPWrap.Bind6 (FunctionCallbackInfo<Value>)
291409,METHOD,tcp_wrap.cc:<global>,TYPE_DECL,"void TCPWrap::Listen(const FunctionCallbackInfo<Value>& args) {
  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  Environment* env = wrap->env();
  int backlog;
  if (!args[0]->Int32Value(env->context()).To(&backlog)) return;
  int err = uv_listen(reinterpret_cast<uv_stream_t*>(&wrap->handle_),
                      backlog,
                      OnConnection);
  args.GetReturnValue().Set(err);
}",1,1,tcp_wrap.cc,node.TCPWrap.Listen,,false,280,292,Listen,,,12,void node.TCPWrap.Listen (FunctionCallbackInfo<Value>)
291477,METHOD,tcp_wrap.cc:<global>,TYPE_DECL,"void TCPWrap::Connect(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[2]->IsUint32());
  // explicit cast to fit to libuv's type expectation
  int port = static_cast<int>(args[2].As<Uint32>()->Value());
  Connect<sockaddr_in>(args,
                       [port](const char* ip_address, sockaddr_in* addr) {
      return uv_ip4_addr(ip_address, port, addr);
  });
}",1,1,tcp_wrap.cc,node.TCPWrap.Connect,,false,295,303,Connect,,,13,void node.TCPWrap.Connect (FunctionCallbackInfo<Value>)
291510,METHOD,tcp_wrap.cc:<global>,TYPE_DECL,"void TCPWrap::Connect6(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[2]->IsUint32());
  int port;
  if (!args[2]->Int32Value(env->context()).To(&port)) return;
  Connect<sockaddr_in6>(args,
                        [port](const char* ip_address, sockaddr_in6* addr) {
      return uv_ip6_addr(ip_address, port, addr);
  });
}",1,1,tcp_wrap.cc,node.TCPWrap.Connect6,,false,306,315,Connect6,,,14,void node.TCPWrap.Connect6 (FunctionCallbackInfo<Value>)
291557,METHOD,tcp_wrap.cc:<global>,TYPE_DECL,"void TCPWrap::Connect(const FunctionCallbackInfo<Value>& args,
    std::function<int(const char* ip_address, T* addr)> uv_ip_addr) {
  Environment* env = Environment::GetCurrent(args);

  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsString());

  Local<Object> req_wrap_obj = args[0].As<Object>();
  node::Utf8Value ip_address(env->isolate(), args[1]);

  T addr;
  int err = uv_ip_addr(*ip_address, &addr);

  if (err == 0) {
    AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(wrap);
    ConnectWrap* req_wrap =
        new ConnectWrap(env, req_wrap_obj, AsyncWrap::PROVIDER_TCPCONNECTWRAP);
    err = req_wrap->Dispatch(uv_tcp_connect,
                             &wrap->handle_,
                             reinterpret_cast<const sockaddr*>(&addr),
                             AfterConnect);
    if (err) {
      delete req_wra...",1,1,tcp_wrap.cc,node.TCPWrap.Connect,,false,318,360,Connect,,,15,"void node.TCPWrap.Connect<T> (FunctionCallbackInfo<Value>,ANY)"
291722,METHOD,tcp_wrap.cc:<global>,TYPE_DECL,"void TCPWrap::Reset(const FunctionCallbackInfo<Value>& args) {
  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(
      &wrap, args.Holder(), args.GetReturnValue().Set(UV_EBADF));

  int err = wrap->Reset(args[0]);

  args.GetReturnValue().Set(err);
}",1,1,tcp_wrap.cc,node.TCPWrap.Reset,,false,361,369,Reset,,,16,void node.TCPWrap.Reset (FunctionCallbackInfo<Value>)
291761,METHOD,tcp_wrap.cc:<global>,TYPE_DECL,"int TCPWrap::Reset(Local<Value> close_callback) {
  if (state_ != kInitialized) return 0;

  int err = uv_tcp_close_reset(&handle_, OnClose);
  state_ = kClosing;
  if (!err & !close_callback.IsEmpty() && close_callback->IsFunction() &&
      !persistent().IsEmpty()) {
    object()
        ->Set(env()->context(), env()->handle_onclose_symbol(), close_callback)
        .Check();
  }
  return err;
}",1,1,tcp_wrap.cc,node.TCPWrap.Reset,,false,371,383,Reset,,,17,int node.TCPWrap.Reset (Local<Value>)
291822,METHOD,tcp_wrap.cc:<global>,TYPE_DECL,"MaybeLocal<Object> AddressToJS(Environment* env,
                               const sockaddr* addr,
                               Local<Object> info) {
  EscapableHandleScope scope(env->isolate());
  char ip[INET6_ADDRSTRLEN + UV_IF_NAMESIZE];
  const sockaddr_in* a4;
  const sockaddr_in6* a6;

  int port;

  if (info.IsEmpty())
    info = Object::New(env->isolate());

  switch (addr->sa_family) {
  case AF_INET6:
    a6 = reinterpret_cast<const sockaddr_in6*>(addr);
    uv_inet_ntop(AF_INET6, &a6->sin6_addr, ip, sizeof ip);
    // Add an interface identifier to a link local address.
    if (IN6_IS_ADDR_LINKLOCAL(&a6->sin6_addr) && a6->sin6_scope_id > 0) {
      const size_t addrlen = strlen(ip);
      CHECK_LT(addrlen, sizeof(ip));
      ip[addrlen] = '%';
      size_t scopeidlen = sizeof(ip) - addrlen - 1;
      CHECK_GE(scopeidlen, UV_IF_NAMESIZE);
      const int r = uv_if_indextoiid(a6->sin6_scope_id,
                                     ip + addrlen + 1,
                   ...",1,1,tcp_wrap.cc,node.AddressToJS,,false,386,448,AddressToJS,,,18,"MaybeLocal<Object> node.AddressToJS (Environment*,sockaddr*,Local<Object>)"
292135,METHOD,tcp_wrap.hpp:<global>,TYPE_DECL,<global>,1,26,tcp_wrap.hpp,tcp_wrap.hpp:<global>,,false,1,105,<global>,,,1,
292146,METHOD,threadpoolwork-inl.hpp:<global>,TYPE_DECL,<global>,1,36,threadpoolwork-inl.hpp,threadpoolwork-inl.hpp:<global>,,false,1,70,<global>,,,1,
292159,METHOD,timer_wrap-inl.hpp:<global>,TYPE_DECL,<global>,1,32,timer_wrap-inl.hpp,timer_wrap-inl.hpp:<global>,,false,1,32,<global>,,,1,
292174,METHOD,timer_wrap.cc:<global>,TYPE_DECL,<global>,1,28,timer_wrap.hpp,timer_wrap.cc:<global>,,false,1,83,<global>,,,1,
292177,METHOD,timer_wrap.cc:<global>,TYPE_DECL,"void TimerWrap::Stop() {
  if (timer_.data == nullptr) return;
  uv_timer_stop(&timer_);
}",1,1,timer_wrap.cc,node.TimerWrap.Stop,,false,10,13,Stop,,,1,void node.TimerWrap.Stop ()
292190,METHOD,timer_wrap.cc:<global>,TYPE_DECL,"void TimerWrap::Close() {
  timer_.data = nullptr;
  env_->CloseHandle(reinterpret_cast<uv_handle_t*>(&timer_), TimerClosedCb);
}",1,1,timer_wrap.cc,node.TimerWrap.Close,,false,15,18,Close,,,2,void node.TimerWrap.Close ()
292208,METHOD,timer_wrap.cc:<global>,TYPE_DECL,"void TimerWrap::TimerClosedCb(uv_handle_t* handle) {
  std::unique_ptr<TimerWrap> ptr(
      ContainerOf(&TimerWrap::timer_,
                  reinterpret_cast<uv_timer_t*>(handle)));
}",1,1,timer_wrap.cc,node.TimerWrap.TimerClosedCb,,false,20,24,TimerClosedCb,,,3,void node.TimerWrap.TimerClosedCb (uv_handle_t*)
292228,METHOD,timer_wrap.cc:<global>,TYPE_DECL,"void TimerWrap::Update(uint64_t interval, uint64_t repeat) {
  if (timer_.data == nullptr) return;
  uv_timer_start(&timer_, OnTimeout, interval, repeat);
}",1,1,timer_wrap.cc,node.TimerWrap.Update,,false,26,29,Update,,,4,"void node.TimerWrap.Update (uint64_t,uint64_t)"
292248,METHOD,timer_wrap.cc:<global>,TYPE_DECL,"void TimerWrap::Ref() {
  if (timer_.data == nullptr) return;
  uv_ref(reinterpret_cast<uv_handle_t*>(&timer_));
}",1,1,timer_wrap.cc,node.TimerWrap.Ref,,false,31,34,Ref,,,5,void node.TimerWrap.Ref ()
292265,METHOD,timer_wrap.cc:<global>,TYPE_DECL,"void TimerWrap::Unref() {
  if (timer_.data == nullptr) return;
  uv_unref(reinterpret_cast<uv_handle_t*>(&timer_));
}",1,1,timer_wrap.cc,node.TimerWrap.Unref,,false,36,39,Unref,,,6,void node.TimerWrap.Unref ()
292282,METHOD,timer_wrap.cc:<global>,TYPE_DECL,"void TimerWrap::OnTimeout(uv_timer_t* timer) {
  TimerWrap* t = ContainerOf(&TimerWrap::timer_, timer);
  t->fn_();
}",1,1,timer_wrap.cc,node.TimerWrap.OnTimeout,,false,41,44,OnTimeout,,,7,void node.TimerWrap.OnTimeout (uv_timer_t*)
292300,METHOD,timer_wrap.cc:<global>,TYPE_DECL,"void TimerWrapHandle::Stop() {
  if (timer_ != nullptr)
    return timer_->Stop();
}",1,1,timer_wrap.cc,node.TimerWrapHandle.Stop,,false,46,49,Stop,,,8,void node.TimerWrapHandle.Stop ()
292314,METHOD,timer_wrap.cc:<global>,TYPE_DECL,"void TimerWrapHandle::Close() {
  if (timer_ != nullptr) {
    timer_->env()->RemoveCleanupHook(CleanupHook, this);
    timer_->Close();
  }
  timer_ = nullptr;
}",1,1,timer_wrap.cc,node.TimerWrapHandle.Close,,false,51,57,Close,,,9,void node.TimerWrapHandle.Close ()
292339,METHOD,timer_wrap.cc:<global>,TYPE_DECL,"void TimerWrapHandle::Ref() {
  if (timer_ != nullptr)
    timer_->Ref();
}",1,1,timer_wrap.cc,node.TimerWrapHandle.Ref,,false,59,62,Ref,,,10,void node.TimerWrapHandle.Ref ()
292352,METHOD,timer_wrap.cc:<global>,TYPE_DECL,"void TimerWrapHandle::Unref() {
  if (timer_ != nullptr)
    timer_->Unref();
}",1,1,timer_wrap.cc,node.TimerWrapHandle.Unref,,false,64,67,Unref,,,11,void node.TimerWrapHandle.Unref ()
292365,METHOD,timer_wrap.cc:<global>,TYPE_DECL,"void TimerWrapHandle::Update(uint64_t interval, uint64_t repeat) {
  if (timer_ != nullptr)
    timer_->Update(interval, repeat);
}",1,1,timer_wrap.cc,node.TimerWrapHandle.Update,,false,69,72,Update,,,12,"void node.TimerWrapHandle.Update (uint64_t,uint64_t)"
292382,METHOD,timer_wrap.cc:<global>,TYPE_DECL,"void TimerWrapHandle::MemoryInfo(MemoryTracker* tracker) const {
  if (timer_ != nullptr)
    tracker->TrackField(""timer"", *timer_);
}",1,1,timer_wrap.cc,node.TimerWrapHandle.MemoryInfo,,false,74,77,MemoryInfo,,,13,void node.TimerWrapHandle.MemoryInfo (MemoryTracker*)
292399,METHOD,timer_wrap.cc:<global>,TYPE_DECL,"void TimerWrapHandle::CleanupHook(void* data) {
  static_cast<TimerWrapHandle*>(data)->Close();
}",1,1,timer_wrap.cc,node.TimerWrapHandle.CleanupHook,,false,79,81,CleanupHook,,,14,void node.TimerWrapHandle.CleanupHook (void*)
292421,METHOD,timer_wrap.hpp:<global>,TYPE_DECL,<global>,1,28,timer_wrap.hpp,timer_wrap.hpp:<global>,,false,1,85,<global>,,,1,
292438,METHOD,timers.cc:<global>,TYPE_DECL,<global>,1,24,timers.hpp,timers.cc:<global>,,false,1,202,<global>,,,1,
292442,METHOD,timers.cc:<global>,TYPE_DECL,"void BindingData::SetupTimers(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsFunction());
  CHECK(args[1]->IsFunction());
  auto env = Environment::GetCurrent(args);

  env->set_immediate_callback_function(args[0].As<Function>());
  env->set_timers_callback_function(args[1].As<Function>());
}",1,1,timers.cc,node.timers.BindingData.SetupTimers,,false,22,29,SetupTimers,,,1,void node.timers.BindingData.SetupTimers (FunctionCallbackInfo<Value>)
292489,METHOD,timers.cc:<global>,TYPE_DECL,"void BindingData::SlowGetLibuvNow(const FunctionCallbackInfo<Value>& args) {
  double now = GetLibuvNowImpl(Realm::GetBindingData<BindingData>(args));
  args.GetReturnValue().Set(Number::New(args.GetIsolate(), now));
}",1,1,timers.cc,node.timers.BindingData.SlowGetLibuvNow,,false,31,34,SlowGetLibuvNow,,,2,void node.timers.BindingData.SlowGetLibuvNow (FunctionCallbackInfo<Value>)
292521,METHOD,timers.cc:<global>,TYPE_DECL,"double BindingData::FastGetLibuvNow(Local<Object> receiver) {
  return GetLibuvNowImpl(FromJSObject<BindingData>(receiver));
}",1,1,timers.cc,node.timers.BindingData.FastGetLibuvNow,,false,36,38,FastGetLibuvNow,,,3,double node.timers.BindingData.FastGetLibuvNow (Local<Object>)
292533,METHOD,timers.cc:<global>,TYPE_DECL,"double BindingData::GetLibuvNowImpl(BindingData* data) {
  return static_cast<double>(data->env()->GetNowUint64());
}",1,1,timers.cc,node.timers.BindingData.GetLibuvNowImpl,,false,40,42,GetLibuvNowImpl,,,4,double node.timers.BindingData.GetLibuvNowImpl (BindingData*)
292548,METHOD,timers.cc:<global>,TYPE_DECL,"void BindingData::SlowScheduleTimer(const FunctionCallbackInfo<Value>& args) {
  int64_t duration =
      args[0]->IntegerValue(args.GetIsolate()->GetCurrentContext()).FromJust();
  ScheduleTimerImpl(Realm::GetBindingData<BindingData>(args), duration);
}",1,1,timers.cc,node.timers.BindingData.SlowScheduleTimer,,false,44,48,SlowScheduleTimer,,,5,void node.timers.BindingData.SlowScheduleTimer (FunctionCallbackInfo<Value>)
292581,METHOD,timers.cc:<global>,TYPE_DECL,"void BindingData::FastScheduleTimer(Local<Object> receiver, int64_t duration) {
  ScheduleTimerImpl(FromJSObject<BindingData>(receiver), duration);
}",1,1,timers.cc,node.timers.BindingData.FastScheduleTimer,,false,50,52,FastScheduleTimer,,,6,"void node.timers.BindingData.FastScheduleTimer (Local<Object>,int64_t)"
292594,METHOD,timers.cc:<global>,TYPE_DECL,"void BindingData::ScheduleTimerImpl(BindingData* data, int64_t duration) {
  data->env()->ScheduleTimer(duration);
}",1,1,timers.cc,node.timers.BindingData.ScheduleTimerImpl,,false,54,56,ScheduleTimerImpl,,,7,"void node.timers.BindingData.ScheduleTimerImpl (BindingData*,int64_t)"
292608,METHOD,timers.cc:<global>,TYPE_DECL,"void BindingData::SlowToggleTimerRef(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  ToggleTimerRefImpl(Realm::GetBindingData<BindingData>(args),
                     args[0]->IsTrue());
}",1,1,timers.cc,node.timers.BindingData.SlowToggleTimerRef,,false,58,62,SlowToggleTimerRef,,,8,void node.timers.BindingData.SlowToggleTimerRef (ANY)
292627,METHOD,timers.cc:<global>,TYPE_DECL,"void BindingData::FastToggleTimerRef(Local<Object> receiver, bool ref) {
  ToggleTimerRefImpl(FromJSObject<BindingData>(receiver), ref);
}",1,1,timers.cc,node.timers.BindingData.FastToggleTimerRef,,false,64,66,FastToggleTimerRef,,,9,"void node.timers.BindingData.FastToggleTimerRef (Local<Object>,bool)"
292640,METHOD,timers.cc:<global>,TYPE_DECL,"void BindingData::ToggleTimerRefImpl(BindingData* data, bool ref) {
  data->env()->ToggleTimerRef(ref);
}",1,1,timers.cc,node.timers.BindingData.ToggleTimerRefImpl,,false,68,70,ToggleTimerRefImpl,,,10,"void node.timers.BindingData.ToggleTimerRefImpl (BindingData*,bool)"
292654,METHOD,timers.cc:<global>,TYPE_DECL,"void BindingData::SlowToggleImmediateRef(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  ToggleImmediateRefImpl(Realm::GetBindingData<BindingData>(args),
                         args[0]->IsTrue());
}",1,1,timers.cc,node.timers.BindingData.SlowToggleImmediateRef,,false,72,76,SlowToggleImmediateRef,,,11,void node.timers.BindingData.SlowToggleImmediateRef (ANY)
292673,METHOD,timers.cc:<global>,TYPE_DECL,"void BindingData::FastToggleImmediateRef(Local<Object> receiver, bool ref) {
  ToggleImmediateRefImpl(FromJSObject<BindingData>(receiver), ref);
}",1,1,timers.cc,node.timers.BindingData.FastToggleImmediateRef,,false,78,80,FastToggleImmediateRef,,,12,"void node.timers.BindingData.FastToggleImmediateRef (Local<Object>,bool)"
292686,METHOD,timers.cc:<global>,TYPE_DECL,"void BindingData::ToggleImmediateRefImpl(BindingData* data, bool ref) {
  data->env()->ToggleImmediateRef(ref);
}",1,1,timers.cc,node.timers.BindingData.ToggleImmediateRefImpl,,false,82,84,ToggleImmediateRefImpl,,,13,"void node.timers.BindingData.ToggleImmediateRefImpl (BindingData*,bool)"
292700,METHOD,timers.cc:<global>,TYPE_DECL,"BindingData::BindingData(Realm* realm, Local<Object> object)
    : SnapshotableObject(realm, object, type_int) {}",1,52,timers.cc,node.timers.BindingData.BindingData,,false,86,87,BindingData,,,14,"ANY node.timers.BindingData.BindingData (Realm*,Local<Object>)"
292706,METHOD,timers.cc:<global>,TYPE_DECL,"bool BindingData::PrepareForSerialization(Local<Context> context,
                                          v8::SnapshotCreator* creator) {
  // Return true because we need to maintain the reference to the binding from
  // JS land.
  return true;
}",1,1,timers.cc,node.timers.BindingData.PrepareForSerialization,,false,89,94,PrepareForSerialization,,,15,"bool node.timers.BindingData.PrepareForSerialization (Local<Context>,ANY*)"
292714,METHOD,timers.cc:<global>,TYPE_DECL,"InternalFieldInfoBase* BindingData::Serialize(int index) {
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info =
      InternalFieldInfoBase::New<InternalFieldInfo>(type());
  return info;
}",1,1,timers.cc,node.timers.BindingData.Serialize,,false,96,101,Serialize,,,16,InternalFieldInfoBase node.timers.BindingData.Serialize (int)
292736,METHOD,timers.cc:<global>,TYPE_DECL,"void BindingData::Deserialize(Local<Context> context,
                              Local<Object> holder,
                              int index,
                              InternalFieldInfoBase* info) {
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  v8::HandleScope scope(context->GetIsolate());
  Realm* realm = Realm::GetCurrent(context);
  // Recreate the buffer in the constructor.
  BindingData* binding = realm->AddBindingData<BindingData>(context, holder);
  CHECK_NOT_NULL(binding);
}",1,1,timers.cc,node.timers.BindingData.Deserialize,,false,103,113,Deserialize,,,17,"void node.timers.BindingData.Deserialize (Local<Context>,Local<Object>,int,InternalFieldInfoBase*)"
292778,METHOD,timers.cc:<global>,TYPE_DECL,"v8::CFunction BindingData::fast_get_libuv_now_(
    v8::CFunction::Make(FastGetLibuvNow));",15,41,timers.cc,node.timers.fast_get_libuv_now_,,false,115,116,fast_get_libuv_now_,,,18,ANY node.timers.fast_get_libuv_now_ (ANY)
292783,METHOD,timers.cc:<global>,TYPE_DECL,"v8::CFunction BindingData::fast_schedule_timers_(
    v8::CFunction::Make(FastScheduleTimer));",15,43,timers.cc,node.timers.fast_schedule_timers_,,false,117,118,fast_schedule_timers_,,,19,ANY node.timers.fast_schedule_timers_ (ANY)
292788,METHOD,timers.cc:<global>,TYPE_DECL,"v8::CFunction BindingData::fast_toggle_timer_ref_(
    v8::CFunction::Make(FastToggleTimerRef));",15,44,timers.cc,node.timers.fast_toggle_timer_ref_,,false,119,120,fast_toggle_timer_ref_,,,20,ANY node.timers.fast_toggle_timer_ref_ (ANY)
292793,METHOD,timers.cc:<global>,TYPE_DECL,"v8::CFunction BindingData::fast_toggle_immediate_ref_(
    v8::CFunction::Make(FastToggleImmediateRef));",15,48,timers.cc,node.timers.fast_toggle_immediate_ref_,,false,121,122,fast_toggle_immediate_ref_,,,21,ANY node.timers.fast_toggle_immediate_ref_ (ANY)
292798,METHOD,timers.cc:<global>,TYPE_DECL,"void BindingData::CreatePerIsolateProperties(IsolateData* isolate_data,
                                             Local<ObjectTemplate> target) {
  Isolate* isolate = isolate_data->isolate();

  SetMethod(isolate, target, ""setupTimers"", SetupTimers);
  SetFastMethod(
      isolate, target, ""getLibuvNow"", SlowGetLibuvNow, &fast_get_libuv_now_);
  SetFastMethod(isolate,
                target,
                ""scheduleTimer"",
                SlowScheduleTimer,
                &fast_schedule_timers_);
  SetFastMethod(isolate,
                target,
                ""toggleTimerRef"",
                SlowToggleTimerRef,
                &fast_toggle_timer_ref_);
  SetFastMethod(isolate,
                target,
                ""toggleImmediateRef"",
                SlowToggleImmediateRef,
                &fast_toggle_immediate_ref_);
}",1,1,timers.cc,node.timers.BindingData.CreatePerIsolateProperties,,false,124,146,CreatePerIsolateProperties,,,22,"void node.timers.BindingData.CreatePerIsolateProperties (IsolateData*,Local<ObjectTemplate>)"
292844,METHOD,timers.cc:<global>,TYPE_DECL,"void BindingData::CreatePerContextProperties(Local<Object> target,
                                             Local<Value> unused,
                                             Local<Context> context,
                                             void* priv) {
  Realm* realm = Realm::GetCurrent(context);
  Environment* env = realm->env();
  BindingData* const binding_data =
      realm->AddBindingData<BindingData>(context, target);
  if (binding_data == nullptr) return;

  // TODO(joyeecheung): move these into BindingData.
  target
      ->Set(context,
            FIXED_ONE_BYTE_STRING(realm->isolate(), ""immediateInfo""),
            env->immediate_info()->fields().GetJSArray())
      .Check();

  target
      ->Set(context,
            FIXED_ONE_BYTE_STRING(realm->isolate(), ""timeoutInfo""),
            env->timeout_info().GetJSArray())
      .Check();
}",1,1,timers.cc,node.timers.BindingData.CreatePerContextProperties,,false,148,170,CreatePerContextProperties,,,23,"void node.timers.BindingData.CreatePerContextProperties (Local<Object>,Local<Value>,Local<Context>,void*)"
292931,METHOD,timers.cc:<global>,TYPE_DECL,"void BindingData::RegisterTimerExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(SetupTimers);

  registry->Register(SlowGetLibuvNow);
  registry->Register(FastGetLibuvNow);
  registry->Register(fast_get_libuv_now_.GetTypeInfo());

  registry->Register(SlowScheduleTimer);
  registry->Register(FastScheduleTimer);
  registry->Register(fast_schedule_timers_.GetTypeInfo());

  registry->Register(SlowToggleTimerRef);
  registry->Register(FastToggleTimerRef);
  registry->Register(fast_toggle_timer_ref_.GetTypeInfo());

  registry->Register(SlowToggleImmediateRef);
  registry->Register(FastToggleImmediateRef);
  registry->Register(fast_toggle_immediate_ref_.GetTypeInfo());
}",1,1,timers.cc,node.timers.BindingData.RegisterTimerExternalReferences,,false,172,191,RegisterTimerExternalReferences,,,24,void node.timers.BindingData.RegisterTimerExternalReferences (ExternalReferenceRegistry*)
293021,METHOD,timers.hpp:<global>,TYPE_DECL,<global>,1,24,timers.hpp,timers.hpp:<global>,,false,1,70,<global>,,,1,
293024,METHOD,tracing\agent.cc:<global>,TYPE_DECL,"[](uv_async_t* async) {
    Agent* agent = ContainerOf(&Agent::initialize_writer_async_, async);
    agent->InitializeWritersOnThread();
  }",26,3,tracing\agent.cc,node.tracing.Agent.Agent.<lambda>0,,false,58,61,<lambda>0,,,1,ANY node.tracing.Agent.Agent.<lambda>0 (uv_async_t*)
293044,METHOD,tracing\agent.cc:<global>,TYPE_DECL,"[](void* arg) {
    Agent* agent = static_cast<Agent*>(arg);
    uv_run(&agent->tracing_loop_, UV_RUN_DEFAULT);
  }",42,3,tracing\agent.cc,node.tracing.Agent.Start.<lambda>1,,false,97,100,<lambda>1,,,1,ANY node.tracing.Agent.Start.<lambda>1 (void*)
293075,METHOD,tracing\agent.cc:<global>,TYPE_DECL,<global>,1,18,tracing\agent.hpp,tracing\agent.cc:<global>,,false,1,251,<global>,,,1,
293080,METHOD,node.tracing.ScopedSuspendTracing,TYPE_DECL,"ScopedSuspendTracing(TracingController* controller, Agent* agent,
                       bool do_suspend = true)
    : controller_(controller), agent_(do_suspend ? agent : nullptr) {
    if (do_suspend) {
      CHECK(agent_->started_);
      controller->StopTracing();
    }
  }",3,3,tracing\agent.cc,node.tracing.ScopedSuspendTracing.ScopedSuspendTracing,,false,14,21,ScopedSuspendTracing,,,1,"ANY node.tracing.ScopedSuspendTracing.ScopedSuspendTracing (TracingController*,Agent*,bool)"
293098,METHOD,node.tracing.ScopedSuspendTracing,TYPE_DECL,"~ScopedSuspendTracing() {
    if (agent_ == nullptr) return;
    TraceConfig* config = agent_->CreateTraceConfig();
    if (config != nullptr) {
      controller_->StartTracing(config);
    }
  }",3,3,tracing\agent.cc,node.tracing.ScopedSuspendTracing.~ScopedSuspendTracing,,false,23,29,~ScopedSuspendTracing,,,2,ANY node.tracing.ScopedSuspendTracing.~ScopedSuspendTracing ()
293128,METHOD,tracing\agent.cc:<global>,TYPE_DECL,"std::set<std::string> flatten(
    const std::unordered_map<int, std::multiset<std::string>>& map) {
  std::set<std::string> result;
  for (const auto& id_value : map)
    result.insert(id_value.second.begin(), id_value.second.end());
  return result;
}",1,1,tracing\agent.cc,node.tracing.anonymous_namespace_1.flatten,,false,38,44,flatten,,,1,set<std::string> node.tracing.anonymous_namespace_1.flatten (ANY)
293163,METHOD,tracing\agent.cc:<global>,TYPE_DECL,"Agent::Agent() : tracing_controller_(new TracingController()) {
  tracing_controller_->Initialize(nullptr);

  CHECK_EQ(uv_loop_init(&tracing_loop_), 0);
  CHECK_EQ(uv_async_init(&tracing_loop_,
                         &initialize_writer_async_,
                         [](uv_async_t* async) {
    Agent* agent = ContainerOf(&Agent::initialize_writer_async_, async);
    agent->InitializeWritersOnThread();
  }), 0);
  uv_unref(reinterpret_cast<uv_handle_t*>(&initialize_writer_async_));
}",1,1,tracing\agent.cc,node.tracing.Agent.Agent,,false,52,63,Agent,,,3,ANY node.tracing.Agent.Agent ()
293190,METHOD,tracing\agent.cc:<global>,TYPE_DECL,"void Agent::InitializeWritersOnThread() {
  Mutex::ScopedLock lock(initialize_writer_mutex_);
  while (!to_be_initialized_.empty()) {
    AsyncTraceWriter* head = *to_be_initialized_.begin();
    head->InitializeOnThread(&tracing_loop_);
    to_be_initialized_.erase(head);
  }
  initialize_writer_condvar_.Broadcast(lock);
}",1,1,tracing\agent.cc,node.tracing.Agent.InitializeWritersOnThread,,false,65,73,InitializeWritersOnThread,,,4,void node.tracing.Agent.InitializeWritersOnThread ()
293228,METHOD,tracing\agent.cc:<global>,TYPE_DECL,"Agent::~Agent() {
  categories_.clear();
  writers_.clear();

  StopTracing();

  uv_close(reinterpret_cast<uv_handle_t*>(&initialize_writer_async_), nullptr);
  uv_run(&tracing_loop_, UV_RUN_ONCE);
  CheckedUvLoopClose(&tracing_loop_);
}",1,1,tracing\agent.cc,node.tracing.Agent.~Agent,,false,75,84,~Agent,,,5,ANY node.tracing.Agent.~Agent ()
293254,METHOD,tracing\agent.cc:<global>,TYPE_DECL,"void Agent::Start() {
  if (started_)
    return;

  NodeTraceBuffer* trace_buffer_ = new NodeTraceBuffer(
      NodeTraceBuffer::kBufferChunks, this, &tracing_loop_);
  tracing_controller_->Initialize(trace_buffer_);

  // This thread should be created *after* async handles are created
  // (within NodeTraceWriter and NodeTraceBuffer constructors).
  // Otherwise the thread could shut down prematurely.
  CHECK_EQ(0, uv_thread_create(&thread_, [](void* arg) {
    Agent* agent = static_cast<Agent*>(arg);
    uv_run(&agent->tracing_loop_, UV_RUN_DEFAULT);
  }, this));
  started_ = true;
}",1,1,tracing\agent.cc,node.tracing.Agent.Start,,false,86,102,Start,,,6,void node.tracing.Agent.Start ()
293288,METHOD,tracing\agent.cc:<global>,TYPE_DECL,"AgentWriterHandle Agent::AddClient(
    const std::set<std::string>& categories,
    std::unique_ptr<AsyncTraceWriter> writer,
    enum UseDefaultCategoryMode mode) {
  Start();

  const std::set<std::string>* use_categories = &categories;

  std::set<std::string> categories_with_default;
  if (mode == kUseDefaultCategories) {
    categories_with_default.insert(categories.begin(), categories.end());
    categories_with_default.insert(categories_[kDefaultHandleId].begin(),
                                   categories_[kDefaultHandleId].end());
    use_categories = &categories_with_default;
  }

  ScopedSuspendTracing suspend(tracing_controller_.get(), this);
  int id = next_writer_id_++;
  AsyncTraceWriter* raw = writer.get();
  writers_[id] = std::move(writer);
  categories_[id] = { use_categories->begin(), use_categories->end() };

  {
    Mutex::ScopedLock lock(initialize_writer_mutex_);
    to_be_initialized_.insert(raw);
    uv_async_send(&initialize_writer_async_);
    while (...",1,1,tracing\agent.cc,node.tracing.Agent.AddClient,,false,104,135,AddClient,,,7,"AgentWriterHandle node.tracing.Agent.AddClient (ANY,ANY,UseDefaultCategoryMode)"
293408,METHOD,tracing\agent.cc:<global>,TYPE_DECL,"AgentWriterHandle Agent::DefaultHandle() {
  return AgentWriterHandle(this, kDefaultHandleId);
}",1,1,tracing\agent.cc,node.tracing.Agent.DefaultHandle,,false,137,139,DefaultHandle,,,8,AgentWriterHandle node.tracing.Agent.DefaultHandle ()
293416,METHOD,tracing\agent.cc:<global>,TYPE_DECL,"void Agent::StopTracing() {
  if (!started_)
    return;
  // Perform final Flush on TraceBuffer. We don't want the tracing controller
  // to flush the buffer again on destruction of the V8::Platform.
  tracing_controller_->StopTracing();
  tracing_controller_->Initialize(nullptr);
  started_ = false;

  // Thread should finish when the tracing loop is stopped.
  uv_thread_join(&thread_);
}",1,1,tracing\agent.cc,node.tracing.Agent.StopTracing,,false,141,152,StopTracing,,,9,void node.tracing.Agent.StopTracing ()
293440,METHOD,tracing\agent.cc:<global>,TYPE_DECL,"void Agent::Disconnect(int client) {
  if (client == kDefaultHandleId) return;
  {
    Mutex::ScopedLock lock(initialize_writer_mutex_);
    to_be_initialized_.erase(writers_[client].get());
  }
  ScopedSuspendTracing suspend(tracing_controller_.get(), this);
  writers_.erase(client);
  categories_.erase(client);
}",1,1,tracing\agent.cc,node.tracing.Agent.Disconnect,,false,154,163,Disconnect,,,10,void node.tracing.Agent.Disconnect (int)
293482,METHOD,tracing\agent.cc:<global>,TYPE_DECL,"void Agent::Enable(int id, const std::set<std::string>& categories) {
  if (categories.empty())
    return;

  ScopedSuspendTracing suspend(tracing_controller_.get(), this,
                               id != kDefaultHandleId);
  categories_[id].insert(categories.begin(), categories.end());
}",1,1,tracing\agent.cc,node.tracing.Agent.Enable,,false,165,172,Enable,,,11,"void node.tracing.Agent.Enable (int,ANY)"
293519,METHOD,tracing\agent.cc:<global>,TYPE_DECL,"void Agent::Disable(int id, const std::set<std::string>& categories) {
  ScopedSuspendTracing suspend(tracing_controller_.get(), this,
                               id != kDefaultHandleId);
  std::multiset<std::string>& writer_categories = categories_[id];
  for (const std::string& category : categories) {
    auto it = writer_categories.find(category);
    if (it != writer_categories.end())
      writer_categories.erase(it);
  }
}",1,1,tracing\agent.cc,node.tracing.Agent.Disable,,false,174,183,Disable,,,12,"void node.tracing.Agent.Disable (int,ANY)"
293574,METHOD,tracing\agent.cc:<global>,TYPE_DECL,"TraceConfig* Agent::CreateTraceConfig() const {
  if (categories_.empty())
    return nullptr;
  TraceConfig* trace_config = new TraceConfig();
  for (const auto& category : flatten(categories_)) {
    trace_config->AddIncludedCategory(category.c_str());
  }
  return trace_config;
}",1,1,tracing\agent.cc,node.tracing.Agent.CreateTraceConfig,,false,185,193,CreateTraceConfig,,,13,TraceConfig node.tracing.Agent.CreateTraceConfig ()
293606,METHOD,tracing\agent.cc:<global>,TYPE_DECL,"std::string Agent::GetEnabledCategories() const {
  std::string categories;
  for (const std::string& category : flatten(categories_)) {
    if (!categories.empty())
      categories += ',';
    categories += category;
  }
  return categories;
}",1,1,tracing\agent.cc,node.tracing.Agent.GetEnabledCategories,,false,195,203,GetEnabledCategories,,,14,string node.tracing.Agent.GetEnabledCategories ()
293631,METHOD,tracing\agent.cc:<global>,TYPE_DECL,"void Agent::AppendTraceEvent(TraceObject* trace_event) {
  for (const auto& id_writer : writers_)
    id_writer.second->AppendTraceEvent(trace_event);
}",1,1,tracing\agent.cc,node.tracing.Agent.AppendTraceEvent,,false,205,208,AppendTraceEvent,,,15,void node.tracing.Agent.AppendTraceEvent (TraceObject*)
293646,METHOD,tracing\agent.cc:<global>,TYPE_DECL,"void Agent::AddMetadataEvent(std::unique_ptr<TraceObject> event) {
  Mutex::ScopedLock lock(metadata_events_mutex_);
  metadata_events_.push_back(std::move(event));
}",1,1,tracing\agent.cc,node.tracing.Agent.AddMetadataEvent,,false,210,213,AddMetadataEvent,,,16,void node.tracing.Agent.AddMetadataEvent (ANY)
293663,METHOD,tracing\agent.cc:<global>,TYPE_DECL,"void Agent::Flush(bool blocking) {
  {
    Mutex::ScopedLock lock(metadata_events_mutex_);
    for (const auto& event : metadata_events_)
      AppendTraceEvent(event.get());
  }

  for (const auto& id_writer : writers_)
    id_writer.second->Flush(blocking);
}",1,1,tracing\agent.cc,node.tracing.Agent.Flush,,false,215,224,Flush,,,17,void node.tracing.Agent.Flush (bool)
293690,METHOD,tracing\agent.cc:<global>,TYPE_DECL,"void TracingController::AddMetadataEvent(
    const unsigned char* category_group_enabled,
    const char* name,
    int num_args,
    const char** arg_names,
    const unsigned char* arg_types,
    const uint64_t* arg_values,
    std::unique_ptr<v8::ConvertableToTraceFormat>* convertable_values,
    unsigned int flags) {
  std::unique_ptr<TraceObject> trace_event(new TraceObject);
  trace_event->Initialize(
      TRACE_EVENT_PHASE_METADATA, category_group_enabled, name,
      node::tracing::kGlobalScope,  // scope
      node::tracing::kNoId,         // id
      node::tracing::kNoId,         // bind_id
      num_args, arg_names, arg_types, arg_values, convertable_values,
      TRACE_EVENT_FLAG_NONE,
      CurrentTimestampMicroseconds(),
      CurrentCpuTimestampMicroseconds());
  Agent* node_agent = node::tracing::TraceEventHelper::GetAgent();
  if (node_agent != nullptr)
    node_agent->AddMetadataEvent(std::move(trace_event));
}",1,6,tracing\agent.cc,node.tracing.TracingController.AddMetadataEvent,,false,226,248,AddMetadataEvent,,,18,"void node.tracing.TracingController.AddMetadataEvent (unsigned char*,char*,int,char**,unsigned char*,uint64_t*,ANY*,unsigned int)"
293791,METHOD,tracing\agent.hpp:<global>,TYPE_DECL,<global>,1,18,tracing\agent.hpp,tracing\agent.hpp:<global>,,false,1,195,<global>,,,1,
293800,METHOD,node.tracing.AsyncTraceWriter,TYPE_DECL,virtual ~AsyncTraceWriter() = default;,3,40,tracing\agent.hpp,node.tracing.AsyncTraceWriter.~AsyncTraceWriter,,false,29,29,~AsyncTraceWriter,,,1,ANY node.tracing.AsyncTraceWriter.~AsyncTraceWriter ()
293804,METHOD,node.tracing.AsyncTraceWriter,TYPE_DECL,virtual void AppendTraceEvent(TraceObject* trace_event) = 0;,16,61,tracing\agent.hpp,node.tracing.AsyncTraceWriter.AppendTraceEvent,,false,30,30,AppendTraceEvent,,,2,void node.tracing.AsyncTraceWriter.AppendTraceEvent (TraceObject*)
293809,METHOD,node.tracing.AsyncTraceWriter,TYPE_DECL,virtual void Flush(bool blocking) = 0;,16,39,tracing\agent.hpp,node.tracing.AsyncTraceWriter.Flush,,false,31,31,Flush,,,3,void node.tracing.AsyncTraceWriter.Flush (bool)
293814,METHOD,node.tracing.AsyncTraceWriter,TYPE_DECL,virtual void InitializeOnThread(uv_loop_t* loop) {},3,53,tracing\agent.hpp,node.tracing.AsyncTraceWriter.InitializeOnThread,,false,32,32,InitializeOnThread,,,4,void node.tracing.AsyncTraceWriter.InitializeOnThread (uv_loop_t*)
293820,METHOD,node.tracing.TracingController,TYPE_DECL,TracingController() : v8::platform::tracing::TracingController() {},3,69,tracing\agent.hpp,node.tracing.TracingController.TracingController,,false,37,37,TracingController,,,1,ANY node.tracing.TracingController.TracingController ()
293824,METHOD,node.tracing.TracingController,TYPE_DECL,"int64_t CurrentTimestampMicroseconds() override {
    return uv_hrtime() / 1000;
  }",3,3,tracing\agent.hpp,node.tracing.TracingController.CurrentTimestampMicroseconds,,false,39,41,CurrentTimestampMicroseconds,,,2,int64_t node.tracing.TracingController.CurrentTimestampMicroseconds ()
293832,METHOD,node.tracing.TracingController,TYPE_DECL,"void AddMetadataEvent(
      const unsigned char* category_group_enabled,
      const char* name,
      int num_args,
      const char** arg_names,
      const unsigned char* arg_types,
      const uint64_t* arg_values,
      std::unique_ptr<v8::ConvertableToTraceFormat>* convertable_values,
      unsigned int flags);",8,25,tracing\agent.hpp,node.tracing.TracingController.AddMetadataEvent,,false,42,50,AddMetadataEvent,,,3,"void node.tracing.TracingController.AddMetadataEvent (unsigned char*,char*,int,char**,unsigned char*,uint64_t*,ANY*,unsigned int)"
293845,METHOD,node.tracing.AgentWriterHandle,TYPE_DECL,inline AgentWriterHandle() = default;,3,39,tracing\agent.hpp,node.tracing.AgentWriterHandle.AgentWriterHandle,,false,55,55,AgentWriterHandle,,,1,ANY node.tracing.AgentWriterHandle.AgentWriterHandle ()
293849,METHOD,node.tracing.AgentWriterHandle,TYPE_DECL,inline ~AgentWriterHandle() { reset(); },3,42,tracing\agent.hpp,node.tracing.AgentWriterHandle.~AgentWriterHandle,,false,56,56,~AgentWriterHandle,,,2,ANY node.tracing.AgentWriterHandle.~AgentWriterHandle ()
293854,METHOD,node.tracing.AgentWriterHandle,TYPE_DECL,inline AgentWriterHandle(AgentWriterHandle&& other);,10,53,tracing\agent.hpp,node.tracing.AgentWriterHandle.AgentWriterHandle,,false,58,58,AgentWriterHandle,,,3,inline node.tracing.AgentWriterHandle.AgentWriterHandle (AgentWriterHandle)
293859,METHOD,node.tracing.AgentWriterHandle,TYPE_DECL,inline AgentWriterHandle& operator=(AgentWriterHandle&& other);,27,64,tracing\agent.hpp,node.tracing.AgentWriterHandle.operator =,,false,59,59,operator =,,,4,AgentWriterHandle node.tracing.AgentWriterHandle.operator = (AgentWriterHandle)
293864,METHOD,node.tracing.AgentWriterHandle,TYPE_DECL,inline bool empty() const { return agent_ == nullptr; },3,57,tracing\agent.hpp,node.tracing.AgentWriterHandle.empty,,false,60,60,empty,,,5,bool node.tracing.AgentWriterHandle.empty ()
293872,METHOD,node.tracing.AgentWriterHandle,TYPE_DECL,inline void reset();,15,21,tracing\agent.hpp,node.tracing.AgentWriterHandle.reset,,false,61,61,reset,,,6,void node.tracing.AgentWriterHandle.reset ()
293876,METHOD,node.tracing.AgentWriterHandle,TYPE_DECL,inline void Enable(const std::set<std::string>& categories);,15,61,tracing\agent.hpp,node.tracing.AgentWriterHandle.Enable,,false,63,63,Enable,,,7,void node.tracing.AgentWriterHandle.Enable (ANY)
293881,METHOD,node.tracing.AgentWriterHandle,TYPE_DECL,inline void Disable(const std::set<std::string>& categories);,15,62,tracing\agent.hpp,node.tracing.AgentWriterHandle.Disable,,false,64,64,Disable,,,8,void node.tracing.AgentWriterHandle.Disable (ANY)
293886,METHOD,node.tracing.AgentWriterHandle,TYPE_DECL,inline bool IsDefaultHandle();,15,31,tracing\agent.hpp,node.tracing.AgentWriterHandle.IsDefaultHandle,,false,66,66,IsDefaultHandle,,,9,bool node.tracing.AgentWriterHandle.IsDefaultHandle ()
293890,METHOD,node.tracing.AgentWriterHandle,TYPE_DECL,inline Agent* agent() { return agent_; },3,42,tracing\agent.hpp,node.tracing.AgentWriterHandle.agent,,false,68,68,agent,,,10,Agent node.tracing.AgentWriterHandle.agent ()
293896,METHOD,node.tracing.AgentWriterHandle,TYPE_DECL,inline v8::TracingController* GetTracingController();,31,54,tracing\agent.hpp,node.tracing.AgentWriterHandle.GetTracingController,,false,70,70,GetTracingController,,,11,ANY* node.tracing.AgentWriterHandle.GetTracingController ()
293900,METHOD,node.tracing.AgentWriterHandle,TYPE_DECL,AgentWriterHandle(const AgentWriterHandle& other) = delete;,3,61,tracing\agent.hpp,node.tracing.AgentWriterHandle.AgentWriterHandle,,false,72,72,AgentWriterHandle,,,12,ANY node.tracing.AgentWriterHandle.AgentWriterHandle (AgentWriterHandle)
293905,METHOD,node.tracing.AgentWriterHandle,TYPE_DECL,AgentWriterHandle& operator=(const AgentWriterHandle& other) = delete;,3,72,tracing\agent.hpp,node.tracing.AgentWriterHandle.operator =,,false,73,73,operator =,,,13,AgentWriterHandle node.tracing.AgentWriterHandle.operator = (AgentWriterHandle)
293910,METHOD,node.tracing.AgentWriterHandle,TYPE_DECL,"inline AgentWriterHandle(Agent* agent, int id) : agent_(agent), id_(id) {}",3,76,tracing\agent.hpp,node.tracing.AgentWriterHandle.AgentWriterHandle,,false,76,76,AgentWriterHandle,,,14,"ANY node.tracing.AgentWriterHandle.AgentWriterHandle (Agent*,int)"
293919,METHOD,<empty>,<empty>,<empty>,1,,tracing\agent.hpp,node.tracing.AgentWriterHandle:<clinit>,,false,53,,<clinit>,,,18,
293930,METHOD,node.tracing.Agent,TYPE_DECL,Agent();,3,9,tracing\agent.hpp,node.tracing.Agent.Agent,,false,86,86,Agent,,,1,ANY node.tracing.Agent.Agent ()
293934,METHOD,node.tracing.Agent,TYPE_DECL,~Agent();,3,10,tracing\agent.hpp,node.tracing.Agent.~Agent,,false,87,87,~Agent,,,2,ANY node.tracing.Agent.~Agent ()
293938,METHOD,node.tracing.Agent,TYPE_DECL,"TracingController* GetTracingController() {
    TracingController* controller = tracing_controller_.get();
    CHECK_NOT_NULL(controller);
    return controller;
  }",3,3,tracing\agent.hpp,node.tracing.Agent.GetTracingController,,false,89,93,GetTracingController,,,3,TracingController node.tracing.Agent.GetTracingController ()
293956,METHOD,node.tracing.Agent,TYPE_DECL,"AgentWriterHandle AddClient(const std::set<std::string>& categories,
                              std::unique_ptr<AsyncTraceWriter> writer,
                              enum UseDefaultCategoryMode mode);",21,63,tracing\agent.hpp,node.tracing.Agent.AddClient,,false,101,103,AddClient,,,5,"AgentWriterHandle node.tracing.Agent.AddClient (ANY,ANY,UseDefaultCategoryMode)"
293963,METHOD,node.tracing.Agent,TYPE_DECL,AgentWriterHandle DefaultHandle();,21,35,tracing\agent.hpp,node.tracing.Agent.DefaultHandle,,false,107,107,DefaultHandle,,,6,AgentWriterHandle node.tracing.Agent.DefaultHandle ()
293967,METHOD,node.tracing.Agent,TYPE_DECL,std::string GetEnabledCategories() const;,15,42,tracing\agent.hpp,node.tracing.Agent.GetEnabledCategories,,false,110,110,GetEnabledCategories,,,7,ANY node.tracing.Agent.GetEnabledCategories ()
293971,METHOD,node.tracing.Agent,TYPE_DECL,void AppendTraceEvent(TraceObject* trace_event);,8,49,tracing\agent.hpp,node.tracing.Agent.AppendTraceEvent,,false,113,113,AppendTraceEvent,,,8,void node.tracing.Agent.AppendTraceEvent (TraceObject*)
293976,METHOD,node.tracing.Agent,TYPE_DECL,void AddMetadataEvent(std::unique_ptr<TraceObject> event);,8,59,tracing\agent.hpp,node.tracing.Agent.AddMetadataEvent,,false,115,115,AddMetadataEvent,,,9,void node.tracing.Agent.AddMetadataEvent (ANY)
293981,METHOD,node.tracing.Agent,TYPE_DECL,void Flush(bool blocking);,8,27,tracing\agent.hpp,node.tracing.Agent.Flush,,false,117,117,Flush,,,10,void node.tracing.Agent.Flush (bool)
293986,METHOD,node.tracing.Agent,TYPE_DECL,TraceConfig* CreateTraceConfig() const;,14,40,tracing\agent.hpp,node.tracing.Agent.CreateTraceConfig,,false,119,119,CreateTraceConfig,,,11,TraceConfig* node.tracing.Agent.CreateTraceConfig ()
293991,METHOD,node.tracing.Agent,TYPE_DECL,void InitializeWritersOnThread();,8,34,tracing\agent.hpp,node.tracing.Agent.InitializeWritersOnThread,,false,124,124,InitializeWritersOnThread,,,13,void node.tracing.Agent.InitializeWritersOnThread ()
293995,METHOD,node.tracing.Agent,TYPE_DECL,void Start();,8,14,tracing\agent.hpp,node.tracing.Agent.Start,,false,126,126,Start,,,14,void node.tracing.Agent.Start ()
293999,METHOD,node.tracing.Agent,TYPE_DECL,void StopTracing();,8,20,tracing\agent.hpp,node.tracing.Agent.StopTracing,,false,127,127,StopTracing,,,15,void node.tracing.Agent.StopTracing ()
294003,METHOD,node.tracing.Agent,TYPE_DECL,void Disconnect(int client);,8,29,tracing\agent.hpp,node.tracing.Agent.Disconnect,,false,128,128,Disconnect,,,16,void node.tracing.Agent.Disconnect (int)
294008,METHOD,node.tracing.Agent,TYPE_DECL,"void Enable(int id, const std::set<std::string>& categories);",8,62,tracing\agent.hpp,node.tracing.Agent.Enable,,false,130,130,Enable,,,17,"void node.tracing.Agent.Enable (int,ANY)"
294014,METHOD,node.tracing.Agent,TYPE_DECL,"void Disable(int id, const std::set<std::string>& categories);",8,63,tracing\agent.hpp,node.tracing.Agent.Disable,,false,131,131,Disable,,,18,"void node.tracing.Agent.Disable (int,ANY)"
294027,METHOD,<empty>,<empty>,<empty>,3,,tracing\agent.hpp,node.tracing.Agent.anonymous_enum_0:<clinit>,,false,141,,<clinit>,,,2,
294044,METHOD,<empty>,<empty>,<empty>,1,,tracing\agent.hpp,node.tracing.Agent:<clinit>,,false,84,,<clinit>,,,34,
294054,METHOD,tracing\agent.hpp:<global>,TYPE_DECL,"void AgentWriterHandle::reset() {
  if (agent_ != nullptr)
    agent_->Disconnect(id_);
  agent_ = nullptr;
}",1,1,tracing\agent.hpp,node.tracing.AgentWriterHandle.reset,,false,158,162,reset,,,6,void node.tracing.AgentWriterHandle.reset ()
294071,METHOD,tracing\agent.hpp:<global>,TYPE_DECL,"AgentWriterHandle& AgentWriterHandle::operator=(AgentWriterHandle&& other) {
  reset();
  agent_ = other.agent_;
  id_ = other.id_;
  other.agent_ = nullptr;
  return *this;
}",1,1,tracing\agent.hpp,node.tracing.AgentWriterHandle.operator =,,false,164,170,operator =,,,7,AgentWriterHandle node.tracing.AgentWriterHandle.operator = (AgentWriterHandle)
294095,METHOD,tracing\agent.hpp:<global>,TYPE_DECL,"AgentWriterHandle::AgentWriterHandle(AgentWriterHandle&& other) {
  *this = std::move(other);
}",1,1,tracing\agent.hpp,node.tracing.AgentWriterHandle.AgentWriterHandle,,false,172,174,AgentWriterHandle,,,8,ANY node.tracing.AgentWriterHandle.AgentWriterHandle (AgentWriterHandle)
294108,METHOD,tracing\agent.hpp:<global>,TYPE_DECL,"void AgentWriterHandle::Enable(const std::set<std::string>& categories) {
  if (agent_ != nullptr) agent_->Enable(id_, categories);
}",1,1,tracing\agent.hpp,node.tracing.AgentWriterHandle.Enable,,false,176,178,Enable,,,9,void node.tracing.AgentWriterHandle.Enable (ANY)
294124,METHOD,tracing\agent.hpp:<global>,TYPE_DECL,"void AgentWriterHandle::Disable(const std::set<std::string>& categories) {
  if (agent_ != nullptr) agent_->Disable(id_, categories);
}",1,1,tracing\agent.hpp,node.tracing.AgentWriterHandle.Disable,,false,180,182,Disable,,,10,void node.tracing.AgentWriterHandle.Disable (ANY)
294140,METHOD,tracing\agent.hpp:<global>,TYPE_DECL,"bool AgentWriterHandle::IsDefaultHandle() {
  return agent_ != nullptr && id_ == Agent::kDefaultHandleId;
}",1,1,tracing\agent.hpp,node.tracing.AgentWriterHandle.IsDefaultHandle,,false,184,186,IsDefaultHandle,,,11,bool node.tracing.AgentWriterHandle.IsDefaultHandle ()
294154,METHOD,tracing\agent.hpp:<global>,TYPE_DECL,"inline v8::TracingController* AgentWriterHandle::GetTracingController() {
  return agent_ != nullptr ? agent_->GetTracingController() : nullptr;
}",1,1,tracing\agent.hpp,node.tracing.AgentWriterHandle.GetTracingController,,false,188,190,GetTracingController,,,12,TracingController node.tracing.AgentWriterHandle.GetTracingController ()
294169,METHOD,tracing\node_trace_buffer.cc:<global>,TYPE_DECL,"[](uv_handle_t* signal) {
      NodeTraceBuffer* buffer =
          ContainerOf(&NodeTraceBuffer::exit_signal_,
                      reinterpret_cast<uv_async_t*>(signal));
        Mutex::ScopedLock scoped_lock(buffer->exit_mutex_);
        buffer->exited_ = true;
        buffer->exit_cond_.Signal(scoped_lock);
    }",14,5,tracing\node_trace_buffer.cc,node.tracing.NodeTraceBuffer.ExitSignalCb..<lambda>1,,false,187,194,<lambda>1,,,1,ANY node.tracing.NodeTraceBuffer.ExitSignalCb..<lambda>1 (uv_handle_t*)
294205,METHOD,tracing\node_trace_buffer.cc:<global>,TYPE_DECL,"[](uv_handle_t* signal) {
    NodeTraceBuffer* buffer =
        ContainerOf(&NodeTraceBuffer::flush_signal_,
                    reinterpret_cast<uv_async_t*>(signal));

    uv_close(reinterpret_cast<uv_handle_t*>(&buffer->exit_signal_),
             [](uv_handle_t* signal) {
      NodeTraceBuffer* buffer =
          ContainerOf(&NodeTraceBuffer::exit_signal_,
                      reinterpret_cast<uv_async_t*>(signal));
        Mutex::ScopedLock scoped_lock(buffer->exit_mutex_);
        buffer->exited_ = true;
        buffer->exit_cond_.Signal(scoped_lock);
    });
  }",12,3,tracing\node_trace_buffer.cc,node.tracing.NodeTraceBuffer.ExitSignalCb.<lambda>0,,false,181,195,<lambda>0,,,1,ANY node.tracing.NodeTraceBuffer.ExitSignalCb.<lambda>0 (uv_handle_t*)
294237,METHOD,tracing\node_trace_buffer.cc:<global>,TYPE_DECL,<global>,1,1,tracing\node_trace_buffer.hpp,tracing\node_trace_buffer.cc:<global>,,false,1,199,<global>,,,1,
294241,METHOD,tracing\node_trace_buffer.cc:<global>,TYPE_DECL,"InternalTraceBuffer::InternalTraceBuffer(size_t max_chunks, uint32_t id,
                                         Agent* agent)
    : flushing_(false), max_chunks_(max_chunks),
      agent_(agent), id_(id) {
  chunks_.resize(max_chunks);
}",1,1,tracing\node_trace_buffer.cc,node.tracing.InternalTraceBuffer.InternalTraceBuffer,,false,9,14,InternalTraceBuffer,,,1,"ANY node.tracing.InternalTraceBuffer.InternalTraceBuffer (size_t,uint32_t,Agent*)"
294253,METHOD,tracing\node_trace_buffer.cc:<global>,TYPE_DECL,"TraceObject* InternalTraceBuffer::AddTraceEvent(uint64_t* handle) {
  Mutex::ScopedLock scoped_lock(mutex_);
  // Create new chunk if last chunk is full or there is no chunk.
  if (total_chunks_ == 0 || chunks_[total_chunks_ - 1]->IsFull()) {
    auto& chunk = chunks_[total_chunks_++];
    if (chunk) {
      chunk->Reset(current_chunk_seq_++);
    } else {
      chunk = std::make_unique<TraceBufferChunk>(current_chunk_seq_++);
    }
  }
  auto& chunk = chunks_[total_chunks_ - 1];
  size_t event_index;
  TraceObject* trace_object = chunk->AddTraceEvent(&event_index);
  *handle = MakeHandle(total_chunks_ - 1, chunk->seq(), event_index);
  return trace_object;
}",1,1,tracing\node_trace_buffer.cc,node.tracing.InternalTraceBuffer.AddTraceEvent,,false,16,32,AddTraceEvent,,,2,TraceObject node.tracing.InternalTraceBuffer.AddTraceEvent (uint64_t*)
294335,METHOD,tracing\node_trace_buffer.cc:<global>,TYPE_DECL,"TraceObject* InternalTraceBuffer::GetEventByHandle(uint64_t handle) {
  Mutex::ScopedLock scoped_lock(mutex_);
  if (handle == 0) {
    // A handle value of zero never has a trace event associated with it.
    return nullptr;
  }
  size_t chunk_index, event_index;
  uint32_t buffer_id, chunk_seq;
  ExtractHandle(handle, &buffer_id, &chunk_index, &chunk_seq, &event_index);
  if (buffer_id != id_ || chunk_index >= total_chunks_) {
    // Either the chunk belongs to the other buffer, or is outside the current
    // range of chunks loaded in memory (the latter being true suggests that
    // the chunk has already been flushed and is no longer in memory.)
    return nullptr;
  }
  auto& chunk = chunks_[chunk_index];
  if (chunk->seq() != chunk_seq) {
    // Chunk is no longer in memory.
    return nullptr;
  }
  return chunk->GetEventAt(event_index);
}",1,1,tracing\node_trace_buffer.cc,node.tracing.InternalTraceBuffer.GetEventByHandle,,false,34,55,GetEventByHandle,,,3,TraceObject node.tracing.InternalTraceBuffer.GetEventByHandle (uint64_t)
294397,METHOD,tracing\node_trace_buffer.cc:<global>,TYPE_DECL,"void InternalTraceBuffer::Flush(bool blocking) {
  {
    Mutex::ScopedLock scoped_lock(mutex_);
    if (total_chunks_ > 0) {
      flushing_ = true;
      for (size_t i = 0; i < total_chunks_; ++i) {
        auto& chunk = chunks_[i];
        for (size_t j = 0; j < chunk->size(); ++j) {
          TraceObject* trace_event = chunk->GetEventAt(j);
          // Another thread may have added a trace that is yet to be
          // initialized. Skip such traces.
          // https://github.com/nodejs/node/issues/21038.
          if (trace_event->name()) {
            agent_->AppendTraceEvent(trace_event);
          }
        }
      }
      total_chunks_ = 0;
      flushing_ = false;
    }
  }
  agent_->Flush(blocking);
}",1,1,tracing\node_trace_buffer.cc,node.tracing.InternalTraceBuffer.Flush,,false,57,79,Flush,,,4,void node.tracing.InternalTraceBuffer.Flush (bool)
294477,METHOD,tracing\node_trace_buffer.cc:<global>,TYPE_DECL,"uint64_t InternalTraceBuffer::MakeHandle(
    size_t chunk_index, uint32_t chunk_seq, size_t event_index) const {
  return ((static_cast<uint64_t>(chunk_seq) * Capacity() +
          chunk_index * TraceBufferChunk::kChunkSize + event_index) << 1) + id_;
}",1,1,tracing\node_trace_buffer.cc,node.tracing.InternalTraceBuffer.MakeHandle,,false,81,85,MakeHandle,,,5,"uint64_t node.tracing.InternalTraceBuffer.MakeHandle (size_t,uint32_t,size_t)"
294502,METHOD,tracing\node_trace_buffer.cc:<global>,TYPE_DECL,"void InternalTraceBuffer::ExtractHandle(
    uint64_t handle, uint32_t* buffer_id, size_t* chunk_index,
    uint32_t* chunk_seq, size_t* event_index) const {
  *buffer_id = static_cast<uint32_t>(handle & 0x1);
  handle >>= 1;
  *chunk_seq = static_cast<uint32_t>(handle / Capacity());
  size_t indices = handle % Capacity();
  *chunk_index = indices / TraceBufferChunk::kChunkSize;
  *event_index = indices % TraceBufferChunk::kChunkSize;
}",1,1,tracing\node_trace_buffer.cc,node.tracing.InternalTraceBuffer.ExtractHandle,,false,87,96,ExtractHandle,,,6,"void node.tracing.InternalTraceBuffer.ExtractHandle (uint64_t,uint32_t*,size_t*,uint32_t*,size_t*)"
294552,METHOD,tracing\node_trace_buffer.cc:<global>,TYPE_DECL,"NodeTraceBuffer::NodeTraceBuffer(size_t max_chunks,
    Agent* agent, uv_loop_t* tracing_loop)
    : tracing_loop_(tracing_loop),
      buffer1_(max_chunks, 0, agent),
      buffer2_(max_chunks, 1, agent) {
  current_buf_.store(&buffer1_);

  flush_signal_.data = this;
  int err = uv_async_init(tracing_loop_, &flush_signal_,
                          NonBlockingFlushSignalCb);
  CHECK_EQ(err, 0);

  exit_signal_.data = this;
  err = uv_async_init(tracing_loop_, &exit_signal_, ExitSignalCb);
  CHECK_EQ(err, 0);
}",1,1,tracing\node_trace_buffer.cc,node.tracing.NodeTraceBuffer.NodeTraceBuffer,,false,98,113,NodeTraceBuffer,,,7,"ANY node.tracing.NodeTraceBuffer.NodeTraceBuffer (size_t,Agent*,uv_loop_t*)"
294596,METHOD,tracing\node_trace_buffer.cc:<global>,TYPE_DECL,"NodeTraceBuffer::~NodeTraceBuffer() {
  uv_async_send(&exit_signal_);
  Mutex::ScopedLock scoped_lock(exit_mutex_);
  while (!exited_) {
    exit_cond_.Wait(scoped_lock);
  }
}",1,1,tracing\node_trace_buffer.cc,node.tracing.NodeTraceBuffer.~NodeTraceBuffer,,false,115,121,~NodeTraceBuffer,,,8,ANY node.tracing.NodeTraceBuffer.~NodeTraceBuffer ()
294615,METHOD,tracing\node_trace_buffer.cc:<global>,TYPE_DECL,"TraceObject* NodeTraceBuffer::AddTraceEvent(uint64_t* handle) {
  // If the buffer is full, attempt to perform a flush.
  if (!TryLoadAvailableBuffer()) {
    // Assign a value of zero as the trace event handle.
    // This is equivalent to calling InternalTraceBuffer::MakeHandle(0, 0, 0),
    // and will cause GetEventByHandle to return NULL if passed as an argument.
    *handle = 0;
    return nullptr;
  }
  return current_buf_.load()->AddTraceEvent(handle);
}",1,1,tracing\node_trace_buffer.cc,node.tracing.NodeTraceBuffer.AddTraceEvent,,false,123,133,AddTraceEvent,,,9,TraceObject node.tracing.NodeTraceBuffer.AddTraceEvent (uint64_t*)
294639,METHOD,tracing\node_trace_buffer.cc:<global>,TYPE_DECL,"TraceObject* NodeTraceBuffer::GetEventByHandle(uint64_t handle) {
  return current_buf_.load()->GetEventByHandle(handle);
}",1,1,tracing\node_trace_buffer.cc,node.tracing.NodeTraceBuffer.GetEventByHandle,,false,135,137,GetEventByHandle,,,10,TraceObject node.tracing.NodeTraceBuffer.GetEventByHandle (uint64_t)
294653,METHOD,tracing\node_trace_buffer.cc:<global>,TYPE_DECL,"bool NodeTraceBuffer::Flush() {
  buffer1_.Flush(true);
  buffer2_.Flush(true);
  return true;
}",1,1,tracing\node_trace_buffer.cc,node.tracing.NodeTraceBuffer.Flush,,false,139,143,Flush,,,11,bool node.tracing.NodeTraceBuffer.Flush ()
294669,METHOD,tracing\node_trace_buffer.cc:<global>,TYPE_DECL,"bool NodeTraceBuffer::TryLoadAvailableBuffer() {
  InternalTraceBuffer* prev_buf = current_buf_.load();
  if (prev_buf->IsFull()) {
    uv_async_send(&flush_signal_);  // trigger flush on a separate thread
    InternalTraceBuffer* other_buf = prev_buf == &buffer1_ ?
      &buffer2_ : &buffer1_;
    if (!other_buf->IsFull()) {
      current_buf_.store(other_buf);
    } else {
      return false;
    }
  }
  return true;
}",1,1,tracing\node_trace_buffer.cc,node.tracing.NodeTraceBuffer.TryLoadAvailableBuffer,,false,148,161,TryLoadAvailableBuffer,,,12,bool node.tracing.NodeTraceBuffer.TryLoadAvailableBuffer ()
294719,METHOD,tracing\node_trace_buffer.cc:<global>,TYPE_DECL,"void NodeTraceBuffer::NonBlockingFlushSignalCb(uv_async_t* signal) {
  NodeTraceBuffer* buffer = static_cast<NodeTraceBuffer*>(signal->data);
  if (buffer->buffer1_.IsFull() && !buffer->buffer1_.IsFlushing()) {
    buffer->buffer1_.Flush(false);
  }
  if (buffer->buffer2_.IsFull() && !buffer->buffer2_.IsFlushing()) {
    buffer->buffer2_.Flush(false);
  }
}",1,1,tracing\node_trace_buffer.cc,node.tracing.NodeTraceBuffer.NonBlockingFlushSignalCb,,false,164,172,NonBlockingFlushSignalCb,,,13,void node.tracing.NodeTraceBuffer.NonBlockingFlushSignalCb (uv_async_t*)
294778,METHOD,tracing\node_trace_buffer.cc:<global>,TYPE_DECL,"void NodeTraceBuffer::ExitSignalCb(uv_async_t* signal) {
  NodeTraceBuffer* buffer =
      ContainerOf(&NodeTraceBuffer::exit_signal_, signal);

  // Close both flush_signal_ and exit_signal_.
  uv_close(reinterpret_cast<uv_handle_t*>(&buffer->flush_signal_),
           [](uv_handle_t* signal) {
    NodeTraceBuffer* buffer =
        ContainerOf(&NodeTraceBuffer::flush_signal_,
                    reinterpret_cast<uv_async_t*>(signal));

    uv_close(reinterpret_cast<uv_handle_t*>(&buffer->exit_signal_),
             [](uv_handle_t* signal) {
      NodeTraceBuffer* buffer =
          ContainerOf(&NodeTraceBuffer::exit_signal_,
                      reinterpret_cast<uv_async_t*>(signal));
        Mutex::ScopedLock scoped_lock(buffer->exit_mutex_);
        buffer->exited_ = true;
        buffer->exit_cond_.Signal(scoped_lock);
    });
  });
}",1,1,tracing\node_trace_buffer.cc,node.tracing.NodeTraceBuffer.ExitSignalCb,,false,175,196,ExitSignalCb,,,14,void node.tracing.NodeTraceBuffer.ExitSignalCb (uv_async_t*)
294810,METHOD,tracing\node_trace_buffer.hpp:<global>,TYPE_DECL,<global>,1,1,tracing\node_trace_buffer.hpp,tracing\node_trace_buffer.hpp:<global>,,false,1,83,<global>,,,1,
294816,METHOD,node.tracing.InternalTraceBuffer,TYPE_DECL,"InternalTraceBuffer(size_t max_chunks, uint32_t id, Agent* agent);",3,67,tracing\node_trace_buffer.hpp,node.tracing.InternalTraceBuffer.InternalTraceBuffer,,false,22,22,InternalTraceBuffer,,,1,"ANY node.tracing.InternalTraceBuffer.InternalTraceBuffer (size_t,uint32_t,Agent*)"
294823,METHOD,node.tracing.InternalTraceBuffer,TYPE_DECL,TraceObject* AddTraceEvent(uint64_t* handle);,14,46,tracing\node_trace_buffer.hpp,node.tracing.InternalTraceBuffer.AddTraceEvent,,false,24,24,AddTraceEvent,,,2,TraceObject* node.tracing.InternalTraceBuffer.AddTraceEvent (uint64_t*)
294828,METHOD,node.tracing.InternalTraceBuffer,TYPE_DECL,TraceObject* GetEventByHandle(uint64_t handle);,14,48,tracing\node_trace_buffer.hpp,node.tracing.InternalTraceBuffer.GetEventByHandle,,false,25,25,GetEventByHandle,,,3,TraceObject* node.tracing.InternalTraceBuffer.GetEventByHandle (uint64_t)
294833,METHOD,node.tracing.InternalTraceBuffer,TYPE_DECL,void Flush(bool blocking);,8,27,tracing\node_trace_buffer.hpp,node.tracing.InternalTraceBuffer.Flush,,false,26,26,Flush,,,4,void node.tracing.InternalTraceBuffer.Flush (bool)
294838,METHOD,node.tracing.InternalTraceBuffer,TYPE_DECL,"bool IsFull() const {
    return total_chunks_ == max_chunks_ && chunks_[total_chunks_ - 1]->IsFull();
  }",3,3,tracing\node_trace_buffer.hpp,node.tracing.InternalTraceBuffer.IsFull,,false,27,29,IsFull,,,5,bool node.tracing.InternalTraceBuffer.IsFull ()
294855,METHOD,node.tracing.InternalTraceBuffer,TYPE_DECL,"bool IsFlushing() const {
    return flushing_;
  }",3,3,tracing\node_trace_buffer.hpp,node.tracing.InternalTraceBuffer.IsFlushing,,false,30,32,IsFlushing,,,6,bool node.tracing.InternalTraceBuffer.IsFlushing ()
294861,METHOD,node.tracing.InternalTraceBuffer,TYPE_DECL,"uint64_t MakeHandle(size_t chunk_index, uint32_t chunk_seq,
                      size_t event_index) const;",12,47,tracing\node_trace_buffer.hpp,node.tracing.InternalTraceBuffer.MakeHandle,,false,35,36,MakeHandle,,,7,"uint64_t node.tracing.InternalTraceBuffer.MakeHandle (size_t,uint32_t,size_t)"
294868,METHOD,node.tracing.InternalTraceBuffer,TYPE_DECL,"void ExtractHandle(uint64_t handle, uint32_t* buffer_id, size_t* chunk_index,
                     uint32_t* chunk_seq, size_t* event_index) const;",8,68,tracing\node_trace_buffer.hpp,node.tracing.InternalTraceBuffer.ExtractHandle,,false,37,38,ExtractHandle,,,8,"void node.tracing.InternalTraceBuffer.ExtractHandle (uint64_t,uint32_t*,size_t*,uint32_t*,size_t*)"
294877,METHOD,node.tracing.InternalTraceBuffer,TYPE_DECL,size_t Capacity() const { return max_chunks_ * TraceBufferChunk::kChunkSize; },3,80,tracing\node_trace_buffer.hpp,node.tracing.InternalTraceBuffer.Capacity,,false,39,39,Capacity,,,9,size_t node.tracing.InternalTraceBuffer.Capacity ()
294895,METHOD,<empty>,<empty>,<empty>,1,,tracing\node_trace_buffer.hpp,node.tracing.InternalTraceBuffer:<clinit>,,false,20,,<clinit>,,,18,
294906,METHOD,node.tracing.NodeTraceBuffer,TYPE_DECL,"NodeTraceBuffer(size_t max_chunks, Agent* agent, uv_loop_t* tracing_loop);",3,75,tracing\node_trace_buffer.hpp,node.tracing.NodeTraceBuffer.NodeTraceBuffer,,false,53,53,NodeTraceBuffer,,,1,"ANY node.tracing.NodeTraceBuffer.NodeTraceBuffer (size_t,Agent*,uv_loop_t*)"
294913,METHOD,node.tracing.NodeTraceBuffer,TYPE_DECL,~NodeTraceBuffer() override;,3,29,tracing\node_trace_buffer.hpp,node.tracing.NodeTraceBuffer.~NodeTraceBuffer,,false,54,54,~NodeTraceBuffer,,,2,ANY node.tracing.NodeTraceBuffer.~NodeTraceBuffer ()
294917,METHOD,node.tracing.NodeTraceBuffer,TYPE_DECL,TraceObject* AddTraceEvent(uint64_t* handle) override;,14,55,tracing\node_trace_buffer.hpp,node.tracing.NodeTraceBuffer.AddTraceEvent,,false,56,56,AddTraceEvent,,,3,TraceObject* node.tracing.NodeTraceBuffer.AddTraceEvent (uint64_t*)
294922,METHOD,node.tracing.NodeTraceBuffer,TYPE_DECL,TraceObject* GetEventByHandle(uint64_t handle) override;,14,57,tracing\node_trace_buffer.hpp,node.tracing.NodeTraceBuffer.GetEventByHandle,,false,57,57,GetEventByHandle,,,4,TraceObject* node.tracing.NodeTraceBuffer.GetEventByHandle (uint64_t)
294927,METHOD,node.tracing.NodeTraceBuffer,TYPE_DECL,bool Flush() override;,8,23,tracing\node_trace_buffer.hpp,node.tracing.NodeTraceBuffer.Flush,,false,58,58,Flush,,,5,bool node.tracing.NodeTraceBuffer.Flush ()
294932,METHOD,node.tracing.NodeTraceBuffer,TYPE_DECL,bool TryLoadAvailableBuffer();,8,31,tracing\node_trace_buffer.hpp,node.tracing.NodeTraceBuffer.TryLoadAvailableBuffer,,false,63,63,TryLoadAvailableBuffer,,,7,bool node.tracing.NodeTraceBuffer.TryLoadAvailableBuffer ()
294936,METHOD,node.tracing.NodeTraceBuffer,TYPE_DECL,static void NonBlockingFlushSignalCb(uv_async_t* signal);,15,58,tracing\node_trace_buffer.hpp,node.tracing.NodeTraceBuffer.NonBlockingFlushSignalCb,,false,64,64,NonBlockingFlushSignalCb,,,8,void node.tracing.NodeTraceBuffer.NonBlockingFlushSignalCb (uv_async_t*)
294941,METHOD,node.tracing.NodeTraceBuffer,TYPE_DECL,static void ExitSignalCb(uv_async_t* signal);,15,46,tracing\node_trace_buffer.hpp,node.tracing.NodeTraceBuffer.ExitSignalCb,,false,65,65,ExitSignalCb,,,9,void node.tracing.NodeTraceBuffer.ExitSignalCb (uv_async_t*)
294955,METHOD,<empty>,<empty>,<empty>,1,,tracing\node_trace_buffer.hpp,node.tracing.NodeTraceBuffer:<clinit>,,false,51,,<clinit>,,,19,
294966,METHOD,tracing\node_trace_writer.cc:<global>,TYPE_DECL,"[](uv_async_t* signal) {
    NodeTraceWriter* trace_writer =
        ContainerOf(&NodeTraceWriter::flush_signal_, signal);
    trace_writer->FlushPrivate();
  }",27,3,tracing\node_trace_writer.cc,node.tracing.NodeTraceWriter.InitializeOnThread.<lambda>0,,false,20,24,<lambda>0,,,1,ANY node.tracing.NodeTraceWriter.InitializeOnThread.<lambda>0 (uv_async_t*)
294986,METHOD,tracing\node_trace_writer.cc:<global>,TYPE_DECL,"[](uv_fs_t* req) {
        NodeTraceWriter* writer =
            ContainerOf(&NodeTraceWriter::write_req_, req);
        writer->AfterWrite();
      }",7,7,tracing\node_trace_writer.cc,node.tracing.NodeTraceWriter.StartWrite.<lambda>1,,false,187,191,<lambda>1,,,1,ANY node.tracing.NodeTraceWriter.StartWrite.<lambda>1 (uv_fs_t*)
295005,METHOD,tracing\node_trace_writer.cc:<global>,TYPE_DECL,"[](uv_handle_t* signal) {
                   NodeTraceWriter* trace_writer =
                       ContainerOf(&NodeTraceWriter::exit_signal_,
                                   reinterpret_cast<uv_async_t*>(signal));
                   Mutex::ScopedLock scoped_lock(trace_writer->request_mutex_);
                   trace_writer->exited_ = true;
                   trace_writer->exit_cond_.Signal(scoped_lock);
                 }",18,18,tracing\node_trace_writer.cc,node.tracing.NodeTraceWriter.ExitSignalCb..<lambda>3,,false,229,236,<lambda>3,,,1,ANY node.tracing.NodeTraceWriter.ExitSignalCb..<lambda>3 (uv_handle_t*)
295040,METHOD,tracing\node_trace_writer.cc:<global>,TYPE_DECL,"[](uv_handle_t* signal) {
             NodeTraceWriter* trace_writer =
                 ContainerOf(&NodeTraceWriter::flush_signal_,
                             reinterpret_cast<uv_async_t*>(signal));
             uv_close(
                 reinterpret_cast<uv_handle_t*>(&trace_writer->exit_signal_),
                 [](uv_handle_t* signal) {
                   NodeTraceWriter* trace_writer =
                       ContainerOf(&NodeTraceWriter::exit_signal_,
                                   reinterpret_cast<uv_async_t*>(signal));
                   Mutex::ScopedLock scoped_lock(trace_writer->request_mutex_);
                   trace_writer->exited_ = true;
                   trace_writer->exit_cond_.Signal(scoped_lock);
                 });
           }",12,12,tracing\node_trace_writer.cc,node.tracing.NodeTraceWriter.ExitSignalCb.<lambda>2,,false,223,237,<lambda>2,,,1,ANY node.tracing.NodeTraceWriter.ExitSignalCb.<lambda>2 (uv_handle_t*)
295074,METHOD,tracing\node_trace_writer.cc:<global>,TYPE_DECL,<global>,1,38,tracing\node_trace_writer.hpp,tracing\node_trace_writer.cc:<global>,,false,1,240,<global>,,,1,
295078,METHOD,tracing\node_trace_writer.cc:<global>,TYPE_DECL,"NodeTraceWriter::NodeTraceWriter(const std::string& log_file_pattern)
    : log_file_pattern_(log_file_pattern) {}",1,44,tracing\node_trace_writer.cc,node.tracing.NodeTraceWriter.NodeTraceWriter,,false,11,12,NodeTraceWriter,,,1,ANY node.tracing.NodeTraceWriter.NodeTraceWriter (ANY)
295083,METHOD,tracing\node_trace_writer.cc:<global>,TYPE_DECL,"void NodeTraceWriter::InitializeOnThread(uv_loop_t* loop) {
  CHECK_NULL(tracing_loop_);
  tracing_loop_ = loop;

  flush_signal_.data = this;
  int err = uv_async_init(tracing_loop_, &flush_signal_,
                          [](uv_async_t* signal) {
    NodeTraceWriter* trace_writer =
        ContainerOf(&NodeTraceWriter::flush_signal_, signal);
    trace_writer->FlushPrivate();
  });
  CHECK_EQ(err, 0);

  exit_signal_.data = this;
  err = uv_async_init(tracing_loop_, &exit_signal_, ExitSignalCb);
  CHECK_EQ(err, 0);
}",1,1,tracing\node_trace_writer.cc,node.tracing.NodeTraceWriter.InitializeOnThread,,false,14,30,InitializeOnThread,,,2,void node.tracing.NodeTraceWriter.InitializeOnThread (uv_loop_t*)
295124,METHOD,tracing\node_trace_writer.cc:<global>,TYPE_DECL,"void NodeTraceWriter::WriteSuffix() {
  // If our final log file has traces, then end the file appropriately.
  // This means that if no trace events are recorded, then no trace file is
  // produced.
  bool should_flush = false;
  {
    Mutex::ScopedLock scoped_lock(stream_mutex_);
    if (total_traces_ > 0) {
      total_traces_ = kTracesPerFile;  // Act as if we reached the file limit.
      should_flush = true;
    }
  }
  if (should_flush) {
    Flush(true);
  }
}",1,1,tracing\node_trace_writer.cc,node.tracing.NodeTraceWriter.WriteSuffix,,false,32,47,WriteSuffix,,,3,void node.tracing.NodeTraceWriter.WriteSuffix ()
295152,METHOD,tracing\node_trace_writer.cc:<global>,TYPE_DECL,"NodeTraceWriter::~NodeTraceWriter() {
  WriteSuffix();
  uv_fs_t req;
  if (fd_ != -1) {
    CHECK_EQ(0, uv_fs_close(nullptr, &req, fd_, nullptr));
    uv_fs_req_cleanup(&req);
  }
  uv_async_send(&exit_signal_);
  Mutex::ScopedLock scoped_lock(request_mutex_);
  while (!exited_) {
    exit_cond_.Wait(scoped_lock);
  }
}",1,1,tracing\node_trace_writer.cc,node.tracing.NodeTraceWriter.~NodeTraceWriter,,false,49,61,~NodeTraceWriter,,,4,ANY node.tracing.NodeTraceWriter.~NodeTraceWriter ()
295190,METHOD,tracing\node_trace_writer.cc:<global>,TYPE_DECL,"void replace_substring(std::string* target,
                       const std::string& search,
                       const std::string& insert) {
  size_t pos = target->find(search);
  for (; pos != std::string::npos; pos = target->find(search, pos)) {
    target->replace(pos, search.size(), insert);
    pos += insert.size();
  }
}",1,1,tracing\node_trace_writer.cc,node.tracing.replace_substring,,false,63,71,replace_substring,,,5,"void node.tracing.replace_substring (ANY*,ANY,ANY)"
295239,METHOD,tracing\node_trace_writer.cc:<global>,TYPE_DECL,"void NodeTraceWriter::OpenNewFileForStreaming() {
  ++file_num_;
  uv_fs_t req;

  // Evaluate a JS-style template string, it accepts the values ${pid} and
  // ${rotation}
  std::string filepath(log_file_pattern_);
  replace_substring(&filepath, ""${pid}"", std::to_string(uv_os_getpid()));
  replace_substring(&filepath, ""${rotation}"", std::to_string(file_num_));

  if (fd_ != -1) {
    CHECK_EQ(uv_fs_close(nullptr, &req, fd_, nullptr), 0);
    uv_fs_req_cleanup(&req);
  }

  fd_ = uv_fs_open(nullptr, &req, filepath.c_str(),
      O_CREAT | O_WRONLY | O_TRUNC, 0644, nullptr);
  uv_fs_req_cleanup(&req);
  if (fd_ < 0) {
    fprintf(stderr, ""Could not open trace file %s: %s\n"",
                    filepath.c_str(),
                    uv_strerror(fd_));
    fd_ = -1;
  }
}",1,1,tracing\node_trace_writer.cc,node.tracing.NodeTraceWriter.OpenNewFileForStreaming,,false,73,97,OpenNewFileForStreaming,,,6,void node.tracing.NodeTraceWriter.OpenNewFileForStreaming ()
295322,METHOD,tracing\node_trace_writer.cc:<global>,TYPE_DECL,"void NodeTraceWriter::AppendTraceEvent(TraceObject* trace_event) {
  Mutex::ScopedLock scoped_lock(stream_mutex_);
  // If this is the first trace event, open a new file for streaming.
  if (total_traces_ == 0) {
    OpenNewFileForStreaming();
    // Constructing a new JSONTraceWriter object appends ""{\""traceEvents\"":[""
    // to stream_.
    // In other words, the constructor initializes the serialization stream
    // to a state where we can start writing trace events to it.
    // Repeatedly constructing and destroying json_trace_writer_ allows
    // us to use V8's JSON writer instead of implementing our own.
    json_trace_writer_.reset(TraceWriter::CreateJSONTraceWriter(stream_));
  }
  ++total_traces_;
  json_trace_writer_->AppendTraceEvent(trace_event);
}",1,1,tracing\node_trace_writer.cc,node.tracing.NodeTraceWriter.AppendTraceEvent,,false,99,114,AppendTraceEvent,,,7,void node.tracing.NodeTraceWriter.AppendTraceEvent (TraceObject*)
295352,METHOD,tracing\node_trace_writer.cc:<global>,TYPE_DECL,"void NodeTraceWriter::FlushPrivate() {
  std::string str;
  int highest_request_id;
  {
    Mutex::ScopedLock stream_scoped_lock(stream_mutex_);
    if (total_traces_ >= kTracesPerFile) {
      total_traces_ = 0;
      // Destroying the member JSONTraceWriter object appends ""]}"" to
      // stream_ - in other words, ending a JSON file.
      json_trace_writer_.reset();
    }
    // str() makes a copy of the contents of the stream.
    str = stream_.str();
    stream_.str("""");
    stream_.clear();
  }
  {
    Mutex::ScopedLock request_scoped_lock(request_mutex_);
    highest_request_id = num_write_requests_;
  }
  WriteToFile(std::move(str), highest_request_id);
}",1,1,tracing\node_trace_writer.cc,node.tracing.NodeTraceWriter.FlushPrivate,,false,116,137,FlushPrivate,,,8,void node.tracing.NodeTraceWriter.FlushPrivate ()
295403,METHOD,tracing\node_trace_writer.cc:<global>,TYPE_DECL,"void NodeTraceWriter::Flush(bool blocking) {
  Mutex::ScopedLock scoped_lock(request_mutex_);
  {
    // We need to lock the mutexes here in a nested fashion; stream_mutex_
    // protects json_trace_writer_, and without request_mutex_ there might be
    // a time window in which the stream state changes?
    Mutex::ScopedLock stream_mutex_lock(stream_mutex_);
    if (!json_trace_writer_)
      return;
  }
  int request_id = ++num_write_requests_;
  int err = uv_async_send(&flush_signal_);
  CHECK_EQ(err, 0);
  if (blocking) {
    // Wait until data associated with this request id has been written to disk.
    // This guarantees that data from all earlier requests have also been
    // written.
    while (request_id > highest_request_id_completed_) {
      request_cond_.Wait(scoped_lock);
    }
  }
}",1,1,tracing\node_trace_writer.cc,node.tracing.NodeTraceWriter.Flush,,false,139,160,Flush,,,9,void node.tracing.NodeTraceWriter.Flush (bool)
295447,METHOD,tracing\node_trace_writer.cc:<global>,TYPE_DECL,"void NodeTraceWriter::WriteToFile(std::string&& str, int highest_request_id) {
  if (fd_ == -1) return;

  uv_buf_t buf = uv_buf_init(nullptr, 0);
  {
    Mutex::ScopedLock lock(request_mutex_);
    write_req_queue_.emplace(WriteRequest {
      std::move(str), highest_request_id
    });
    if (write_req_queue_.size() == 1) {
      buf = uv_buf_init(
          const_cast<char*>(write_req_queue_.front().str.c_str()),
          write_req_queue_.front().str.length());
    }
  }
  // Only one write request for the same file descriptor should be active at
  // a time.
  if (buf.base != nullptr && fd_ != -1) {
    StartWrite(buf);
  }
}",1,1,tracing\node_trace_writer.cc,node.tracing.NodeTraceWriter.WriteToFile,,false,162,182,WriteToFile,,,10,"void node.tracing.NodeTraceWriter.WriteToFile (ANY,int)"
295527,METHOD,tracing\node_trace_writer.cc:<global>,TYPE_DECL,"void NodeTraceWriter::StartWrite(uv_buf_t buf) {
  int err = uv_fs_write(
      tracing_loop_, &write_req_, fd_, &buf, 1, -1,
      [](uv_fs_t* req) {
        NodeTraceWriter* writer =
            ContainerOf(&NodeTraceWriter::write_req_, req);
        writer->AfterWrite();
      });
  CHECK_EQ(err, 0);
}",1,1,tracing\node_trace_writer.cc,node.tracing.NodeTraceWriter.StartWrite,,false,184,193,StartWrite,,,11,void node.tracing.NodeTraceWriter.StartWrite (uv_buf_t)
295549,METHOD,tracing\node_trace_writer.cc:<global>,TYPE_DECL,"void NodeTraceWriter::AfterWrite() {
  CHECK_GE(write_req_.result, 0);
  uv_fs_req_cleanup(&write_req_);

  uv_buf_t buf = uv_buf_init(nullptr, 0);
  {
    Mutex::ScopedLock scoped_lock(request_mutex_);
    int highest_request_id = write_req_queue_.front().highest_request_id;
    write_req_queue_.pop();
    highest_request_id_completed_ = highest_request_id;
    request_cond_.Broadcast(scoped_lock);
    if (!write_req_queue_.empty()) {
      buf = uv_buf_init(
          const_cast<char*>(write_req_queue_.front().str.c_str()),
          write_req_queue_.front().str.length());
    }
  }
  if (buf.base != nullptr && fd_ != -1) {
    StartWrite(buf);
  }
}",1,1,tracing\node_trace_writer.cc,node.tracing.NodeTraceWriter.AfterWrite,,false,195,215,AfterWrite,,,12,void node.tracing.NodeTraceWriter.AfterWrite ()
295636,METHOD,tracing\node_trace_writer.cc:<global>,TYPE_DECL,"void NodeTraceWriter::ExitSignalCb(uv_async_t* signal) {
  NodeTraceWriter* trace_writer =
      ContainerOf(&NodeTraceWriter::exit_signal_, signal);
  // Close both flush_signal_ and exit_signal_.
  uv_close(reinterpret_cast<uv_handle_t*>(&trace_writer->flush_signal_),
           [](uv_handle_t* signal) {
             NodeTraceWriter* trace_writer =
                 ContainerOf(&NodeTraceWriter::flush_signal_,
                             reinterpret_cast<uv_async_t*>(signal));
             uv_close(
                 reinterpret_cast<uv_handle_t*>(&trace_writer->exit_signal_),
                 [](uv_handle_t* signal) {
                   NodeTraceWriter* trace_writer =
                       ContainerOf(&NodeTraceWriter::exit_signal_,
                                   reinterpret_cast<uv_async_t*>(signal));
                   Mutex::ScopedLock scoped_lock(trace_writer->request_mutex_);
                   trace_writer->exited_ = true;
                   trace_writer->exit_cond_.Sig...",1,1,tracing\node_trace_writer.cc,node.tracing.NodeTraceWriter.ExitSignalCb,,false,218,238,ExitSignalCb,,,13,void node.tracing.NodeTraceWriter.ExitSignalCb (uv_async_t*)
295670,METHOD,tracing\node_trace_writer.hpp:<global>,TYPE_DECL,<global>,1,38,tracing\node_trace_writer.hpp,tracing\node_trace_writer.hpp:<global>,,false,1,75,<global>,,,1,
295675,METHOD,node.tracing.NodeTraceWriter,TYPE_DECL,explicit NodeTraceWriter(const std::string& log_file_pattern);,12,63,tracing\node_trace_writer.hpp,node.tracing.NodeTraceWriter.NodeTraceWriter,,false,19,19,NodeTraceWriter,,,1,explicit node.tracing.NodeTraceWriter.NodeTraceWriter (ANY)
295680,METHOD,node.tracing.NodeTraceWriter,TYPE_DECL,~NodeTraceWriter() override;,3,29,tracing\node_trace_writer.hpp,node.tracing.NodeTraceWriter.~NodeTraceWriter,,false,20,20,~NodeTraceWriter,,,2,ANY node.tracing.NodeTraceWriter.~NodeTraceWriter ()
295684,METHOD,node.tracing.NodeTraceWriter,TYPE_DECL,void InitializeOnThread(uv_loop_t* loop) override;,8,51,tracing\node_trace_writer.hpp,node.tracing.NodeTraceWriter.InitializeOnThread,,false,22,22,InitializeOnThread,,,3,void node.tracing.NodeTraceWriter.InitializeOnThread (uv_loop_t*)
295689,METHOD,node.tracing.NodeTraceWriter,TYPE_DECL,void AppendTraceEvent(TraceObject* trace_event) override;,8,58,tracing\node_trace_writer.hpp,node.tracing.NodeTraceWriter.AppendTraceEvent,,false,23,23,AppendTraceEvent,,,4,void node.tracing.NodeTraceWriter.AppendTraceEvent (TraceObject*)
295694,METHOD,node.tracing.NodeTraceWriter,TYPE_DECL,void Flush(bool blocking) override;,8,36,tracing\node_trace_writer.hpp,node.tracing.NodeTraceWriter.Flush,,false,24,24,Flush,,,5,void node.tracing.NodeTraceWriter.Flush (bool)
295703,METHOD,node.tracing.NodeTraceWriter,TYPE_DECL,void AfterWrite();,8,19,tracing\node_trace_writer.hpp,node.tracing.NodeTraceWriter.AfterWrite,,false,34,34,AfterWrite,,,8,void node.tracing.NodeTraceWriter.AfterWrite ()
295707,METHOD,node.tracing.NodeTraceWriter,TYPE_DECL,void StartWrite(uv_buf_t buf);,8,31,tracing\node_trace_writer.hpp,node.tracing.NodeTraceWriter.StartWrite,,false,35,35,StartWrite,,,9,void node.tracing.NodeTraceWriter.StartWrite (uv_buf_t)
295712,METHOD,node.tracing.NodeTraceWriter,TYPE_DECL,void OpenNewFileForStreaming();,8,32,tracing\node_trace_writer.hpp,node.tracing.NodeTraceWriter.OpenNewFileForStreaming,,false,36,36,OpenNewFileForStreaming,,,10,void node.tracing.NodeTraceWriter.OpenNewFileForStreaming ()
295716,METHOD,node.tracing.NodeTraceWriter,TYPE_DECL,"void WriteToFile(std::string&& str, int highest_request_id);",8,61,tracing\node_trace_writer.hpp,node.tracing.NodeTraceWriter.WriteToFile,,false,37,37,WriteToFile,,,11,"void node.tracing.NodeTraceWriter.WriteToFile (ANY,int)"
295722,METHOD,node.tracing.NodeTraceWriter,TYPE_DECL,void WriteSuffix();,8,20,tracing\node_trace_writer.hpp,node.tracing.NodeTraceWriter.WriteSuffix,,false,38,38,WriteSuffix,,,12,void node.tracing.NodeTraceWriter.WriteSuffix ()
295726,METHOD,node.tracing.NodeTraceWriter,TYPE_DECL,void FlushPrivate();,8,21,tracing\node_trace_writer.hpp,node.tracing.NodeTraceWriter.FlushPrivate,,false,39,39,FlushPrivate,,,13,void node.tracing.NodeTraceWriter.FlushPrivate ()
295730,METHOD,node.tracing.NodeTraceWriter,TYPE_DECL,static void ExitSignalCb(uv_async_t* signal);,15,46,tracing\node_trace_writer.hpp,node.tracing.NodeTraceWriter.ExitSignalCb,,false,40,40,ExitSignalCb,,,14,void node.tracing.NodeTraceWriter.ExitSignalCb (uv_async_t*)
295753,METHOD,<empty>,<empty>,<empty>,1,,tracing\node_trace_writer.hpp,node.tracing.NodeTraceWriter:<clinit>,,false,17,,<clinit>,,,33,
295791,METHOD,tracing\trace_event.cc:<global>,TYPE_DECL,<global>,1,27,tracing\trace_event.hpp,tracing\trace_event.cc:<global>,,false,1,42,<global>,,,1,
295803,METHOD,tracing\trace_event.cc:<global>,TYPE_DECL,"void TraceEventHelper::SetAgent(Agent* agent) {
  if (agent) {
    g_agent = agent;
    g_controller = agent->GetTracingController();
  } else {
    g_agent = nullptr;
    g_controller = nullptr;
  }
}",1,1,tracing\trace_event.cc,node.tracing.TraceEventHelper.SetAgent,,false,10,18,SetAgent,,,5,void node.tracing.TraceEventHelper.SetAgent (Agent*)
295828,METHOD,tracing\trace_event.cc:<global>,TYPE_DECL,"Agent* TraceEventHelper::GetAgent() {
  return g_agent;
}",1,1,tracing\trace_event.cc,node.tracing.TraceEventHelper.GetAgent,,false,20,22,GetAgent,,,6,Agent node.tracing.TraceEventHelper.GetAgent ()
295834,METHOD,tracing\trace_event.cc:<global>,TYPE_DECL,"v8::TracingController* TraceEventHelper::GetTracingController() {
  return g_controller;
}",1,1,tracing\trace_event.cc,node.tracing.TraceEventHelper.GetTracingController,,false,24,26,GetTracingController,,,7,TracingController node.tracing.TraceEventHelper.GetTracingController ()
295840,METHOD,tracing\trace_event.cc:<global>,TYPE_DECL,"void TraceEventHelper::SetTracingController(v8::TracingController* controller) {
  g_controller = controller;
}",1,1,tracing\trace_event.cc,node.tracing.TraceEventHelper.SetTracingController,,false,28,30,SetTracingController,,,8,void node.tracing.TraceEventHelper.SetTracingController (ANY*)
295848,METHOD,tracing\trace_event.cc:<global>,TYPE_DECL,"v8::TracingController* GetTracingController() {
  return tracing::TraceEventHelper::GetTracingController();
}",1,1,tracing\trace_event.cc,node.GetTracingController,,false,34,36,GetTracingController,,,2,TracingController node.GetTracingController ()
295859,METHOD,tracing\trace_event.cc:<global>,TYPE_DECL,"void SetTracingController(v8::TracingController* controller) {
  tracing::TraceEventHelper::SetTracingController(controller);
}",1,1,tracing\trace_event.cc,node.SetTracingController,,false,38,40,SetTracingController,,,3,void node.SetTracingController (ANY*)
295882,METHOD,tracing\trace_event.hpp:<global>,TYPE_DECL,<global>,1,27,tracing\trace_event.hpp,tracing\trace_event.hpp:<global>,,false,1,720,<global>,,,1,
295888,METHOD,<empty>,<empty>,<empty>,1,,tracing\trace_event.hpp,CategoryGroupEnabledFlags:<clinit>,,false,23,,<clinit>,,,4,
295922,METHOD,node.tracing.TraceEventHelper,TYPE_DECL,static v8::TracingController* GetTracingController();,31,54,tracing\trace_event.hpp,node.tracing.TraceEventHelper.GetTracingController,,false,315,315,GetTracingController,,,1,ANY* node.tracing.TraceEventHelper.GetTracingController ()
295926,METHOD,node.tracing.TraceEventHelper,TYPE_DECL,static void SetTracingController(v8::TracingController* controller);,15,69,tracing\trace_event.hpp,node.tracing.TraceEventHelper.SetTracingController,,false,316,316,SetTracingController,,,2,void node.tracing.TraceEventHelper.SetTracingController (ANY*)
295931,METHOD,node.tracing.TraceEventHelper,TYPE_DECL,static Agent* GetAgent();,15,26,tracing\trace_event.hpp,node.tracing.TraceEventHelper.GetAgent,,false,318,318,GetAgent,,,3,Agent* node.tracing.TraceEventHelper.GetAgent ()
295935,METHOD,node.tracing.TraceEventHelper,TYPE_DECL,static void SetAgent(Agent* agent);,15,36,tracing\trace_event.hpp,node.tracing.TraceEventHelper.SetAgent,,false,319,319,SetAgent,,,4,void node.tracing.TraceEventHelper.SetAgent (Agent*)
295940,METHOD,node.tracing.TraceEventHelper,TYPE_DECL,"static inline const uint8_t* GetCategoryGroupEnabled(const char* group) {
    v8::TracingController* controller = GetTracingController();
    static const uint8_t disabled = 0;
    if (UNLIKELY(controller == nullptr)) return &disabled;
    return controller->GetCategoryGroupEnabled(group);
  }",3,3,tracing\trace_event.hpp,node.tracing.TraceEventHelper.GetCategoryGroupEnabled,,false,321,326,GetCategoryGroupEnabled,,,5,uint8_t node.tracing.TraceEventHelper.GetCategoryGroupEnabled (char*)
295970,METHOD,node.tracing.TraceID.WithScope,TYPE_DECL,"WithScope(const char* scope, uint64_t raw_id)
        : scope_(scope), raw_id_(raw_id) {}",5,43,tracing\trace_event.hpp,node.tracing.TraceID.WithScope.WithScope,,false,336,337,WithScope,,,1,"ANY node.tracing.TraceID.WithScope.WithScope (char*,uint64_t)"
295976,METHOD,node.tracing.TraceID.WithScope,TYPE_DECL,uint64_t raw_id() const { return raw_id_; },5,47,tracing\trace_event.hpp,node.tracing.TraceID.WithScope.raw_id,,false,338,338,raw_id,,,2,uint64_t node.tracing.TraceID.WithScope.raw_id ()
295982,METHOD,node.tracing.TraceID.WithScope,TYPE_DECL,const char* scope() const { return scope_; },5,48,tracing\trace_event.hpp,node.tracing.TraceID.WithScope.scope,,false,339,339,scope,,,3,const char* node.tracing.TraceID.WithScope.scope ()
295990,METHOD,<empty>,<empty>,<empty>,3,,tracing\trace_event.hpp,node.tracing.TraceID.WithScope:<clinit>,,false,334,,<clinit>,,,6,
295998,METHOD,node.tracing.TraceID.DontMangle,TYPE_DECL,"explicit DontMangle(const void* raw_id)
        : raw_id_(static_cast<uint64_t>(reinterpret_cast<uintptr_t>(raw_id))) {}",5,80,tracing\trace_event.hpp,node.tracing.TraceID.DontMangle.DontMangle,,false,348,349,DontMangle,,,1,ANY node.tracing.TraceID.DontMangle.DontMangle (void*)
296003,METHOD,node.tracing.TraceID.DontMangle,TYPE_DECL,explicit DontMangle(uint64_t raw_id) : raw_id_(raw_id) {},5,61,tracing\trace_event.hpp,node.tracing.TraceID.DontMangle.DontMangle,,false,350,350,DontMangle,,,2,ANY node.tracing.TraceID.DontMangle.DontMangle (uint64_t)
296008,METHOD,node.tracing.TraceID.DontMangle,TYPE_DECL,explicit DontMangle(unsigned int raw_id) : raw_id_(raw_id) {},5,65,tracing\trace_event.hpp,node.tracing.TraceID.DontMangle.DontMangle,,false,351,351,DontMangle,,,3,ANY node.tracing.TraceID.DontMangle.DontMangle (unsigned int)
296013,METHOD,node.tracing.TraceID.DontMangle,TYPE_DECL,explicit DontMangle(uint16_t raw_id) : raw_id_(raw_id) {},5,61,tracing\trace_event.hpp,node.tracing.TraceID.DontMangle.DontMangle,,false,352,352,DontMangle,,,4,ANY node.tracing.TraceID.DontMangle.DontMangle (uint16_t)
296018,METHOD,node.tracing.TraceID.DontMangle,TYPE_DECL,explicit DontMangle(unsigned char raw_id) : raw_id_(raw_id) {},5,66,tracing\trace_event.hpp,node.tracing.TraceID.DontMangle.DontMangle,,false,353,353,DontMangle,,,5,ANY node.tracing.TraceID.DontMangle.DontMangle (unsigned char)
296023,METHOD,node.tracing.TraceID.DontMangle,TYPE_DECL,"explicit DontMangle(int64_t raw_id)
        : raw_id_(static_cast<uint64_t>(raw_id)) {}",5,51,tracing\trace_event.hpp,node.tracing.TraceID.DontMangle.DontMangle,,false,354,355,DontMangle,,,6,ANY node.tracing.TraceID.DontMangle.DontMangle (int64_t)
296028,METHOD,node.tracing.TraceID.DontMangle,TYPE_DECL,explicit DontMangle(int raw_id) : raw_id_(static_cast<uint64_t>(raw_id)) {},5,79,tracing\trace_event.hpp,node.tracing.TraceID.DontMangle.DontMangle,,false,356,356,DontMangle,,,7,ANY node.tracing.TraceID.DontMangle.DontMangle (int)
296033,METHOD,node.tracing.TraceID.DontMangle,TYPE_DECL,"explicit DontMangle(int16_t raw_id)
        : raw_id_(static_cast<uint64_t>(raw_id)) {}",5,51,tracing\trace_event.hpp,node.tracing.TraceID.DontMangle.DontMangle,,false,357,358,DontMangle,,,8,ANY node.tracing.TraceID.DontMangle.DontMangle (int16_t)
296038,METHOD,node.tracing.TraceID.DontMangle,TYPE_DECL,"explicit DontMangle(signed char raw_id)
        : raw_id_(static_cast<uint64_t>(raw_id)) {}",5,51,tracing\trace_event.hpp,node.tracing.TraceID.DontMangle.DontMangle,,false,359,360,DontMangle,,,9,ANY node.tracing.TraceID.DontMangle.DontMangle (signed char)
296043,METHOD,node.tracing.TraceID.DontMangle,TYPE_DECL,"explicit DontMangle(WithScope scoped_id)
        : scope_(scoped_id.scope()), raw_id_(scoped_id.raw_id()) {}",5,67,tracing\trace_event.hpp,node.tracing.TraceID.DontMangle.DontMangle,,false,361,362,DontMangle,,,10,ANY node.tracing.TraceID.DontMangle.DontMangle (WithScope)
296048,METHOD,node.tracing.TraceID.DontMangle,TYPE_DECL,const char* scope() const { return scope_; },5,48,tracing\trace_event.hpp,node.tracing.TraceID.DontMangle.scope,,false,363,363,scope,,,11,const char* node.tracing.TraceID.DontMangle.scope ()
296054,METHOD,node.tracing.TraceID.DontMangle,TYPE_DECL,uint64_t raw_id() const { return raw_id_; },5,47,tracing\trace_event.hpp,node.tracing.TraceID.DontMangle.raw_id,,false,364,364,raw_id,,,12,uint64_t node.tracing.TraceID.DontMangle.raw_id ()
296062,METHOD,<empty>,<empty>,<empty>,3,,tracing\trace_event.hpp,node.tracing.TraceID.DontMangle:<clinit>,,false,346,,<clinit>,,,15,
296070,METHOD,node.tracing.TraceID.ForceMangle,TYPE_DECL,explicit ForceMangle(uint64_t raw_id) : raw_id_(raw_id) {},5,62,tracing\trace_event.hpp,node.tracing.TraceID.ForceMangle.ForceMangle,,false,373,373,ForceMangle,,,1,ANY node.tracing.TraceID.ForceMangle.ForceMangle (uint64_t)
296075,METHOD,node.tracing.TraceID.ForceMangle,TYPE_DECL,explicit ForceMangle(unsigned int raw_id) : raw_id_(raw_id) {},5,66,tracing\trace_event.hpp,node.tracing.TraceID.ForceMangle.ForceMangle,,false,374,374,ForceMangle,,,2,ANY node.tracing.TraceID.ForceMangle.ForceMangle (unsigned int)
296080,METHOD,node.tracing.TraceID.ForceMangle,TYPE_DECL,explicit ForceMangle(uint16_t raw_id) : raw_id_(raw_id) {},5,62,tracing\trace_event.hpp,node.tracing.TraceID.ForceMangle.ForceMangle,,false,375,375,ForceMangle,,,3,ANY node.tracing.TraceID.ForceMangle.ForceMangle (uint16_t)
296085,METHOD,node.tracing.TraceID.ForceMangle,TYPE_DECL,explicit ForceMangle(unsigned char raw_id) : raw_id_(raw_id) {},5,67,tracing\trace_event.hpp,node.tracing.TraceID.ForceMangle.ForceMangle,,false,376,376,ForceMangle,,,4,ANY node.tracing.TraceID.ForceMangle.ForceMangle (unsigned char)
296090,METHOD,node.tracing.TraceID.ForceMangle,TYPE_DECL,"explicit ForceMangle(int64_t raw_id)
        : raw_id_(static_cast<uint64_t>(raw_id)) {}",5,51,tracing\trace_event.hpp,node.tracing.TraceID.ForceMangle.ForceMangle,,false,377,378,ForceMangle,,,5,ANY node.tracing.TraceID.ForceMangle.ForceMangle (int64_t)
296095,METHOD,node.tracing.TraceID.ForceMangle,TYPE_DECL,explicit ForceMangle(int raw_id) : raw_id_(static_cast<uint64_t>(raw_id)) {},5,80,tracing\trace_event.hpp,node.tracing.TraceID.ForceMangle.ForceMangle,,false,379,379,ForceMangle,,,6,ANY node.tracing.TraceID.ForceMangle.ForceMangle (int)
296100,METHOD,node.tracing.TraceID.ForceMangle,TYPE_DECL,"explicit ForceMangle(int16_t raw_id)
        : raw_id_(static_cast<uint64_t>(raw_id)) {}",5,51,tracing\trace_event.hpp,node.tracing.TraceID.ForceMangle.ForceMangle,,false,380,381,ForceMangle,,,7,ANY node.tracing.TraceID.ForceMangle.ForceMangle (int16_t)
296105,METHOD,node.tracing.TraceID.ForceMangle,TYPE_DECL,"explicit ForceMangle(signed char raw_id)
        : raw_id_(static_cast<uint64_t>(raw_id)) {}",5,51,tracing\trace_event.hpp,node.tracing.TraceID.ForceMangle.ForceMangle,,false,382,383,ForceMangle,,,8,ANY node.tracing.TraceID.ForceMangle.ForceMangle (signed char)
296110,METHOD,node.tracing.TraceID.ForceMangle,TYPE_DECL,uint64_t raw_id() const { return raw_id_; },5,47,tracing\trace_event.hpp,node.tracing.TraceID.ForceMangle.raw_id,,false,384,384,raw_id,,,9,uint64_t node.tracing.TraceID.ForceMangle.raw_id ()
296117,METHOD,node.tracing.TraceID,TYPE_DECL,"TraceID(const void* raw_id, unsigned int* flags)
      : raw_id_(static_cast<uint64_t>(reinterpret_cast<uintptr_t>(raw_id))) {
    *flags |= TRACE_EVENT_FLAG_MANGLE_ID;
  }",3,14,tracing\trace_event.hpp,node.tracing.TraceID.TraceID,,false,390,393,TraceID,,,4,"ANY node.tracing.TraceID.TraceID (void*,unsigned int*)"
296133,METHOD,node.tracing.TraceID,TYPE_DECL,"TraceID(ForceMangle raw_id, unsigned int* flags) : raw_id_(raw_id.raw_id()) {
    *flags |= TRACE_EVENT_FLAG_MANGLE_ID;
  }",3,14,tracing\trace_event.hpp,node.tracing.TraceID.TraceID,,false,394,396,TraceID,,,5,"ANY node.tracing.TraceID.TraceID (ForceMangle,unsigned int*)"
296149,METHOD,node.tracing.TraceID,TYPE_DECL,"TraceID(DontMangle maybe_scoped_id, unsigned int* flags)
      : scope_(maybe_scoped_id.scope()), raw_id_(maybe_scoped_id.raw_id()) {}",3,77,tracing\trace_event.hpp,node.tracing.TraceID.TraceID,,false,397,398,TraceID,,,6,"ANY node.tracing.TraceID.TraceID (DontMangle,unsigned int*)"
296155,METHOD,node.tracing.TraceID,TYPE_DECL,"TraceID(uint64_t raw_id, unsigned int* flags) : raw_id_(raw_id) {
    (void)flags;
  }",3,3,tracing\trace_event.hpp,node.tracing.TraceID.TraceID,,false,399,401,TraceID,,,7,"ANY node.tracing.TraceID.TraceID (uint64_t,unsigned int*)"
296164,METHOD,node.tracing.TraceID,TYPE_DECL,"TraceID(unsigned int raw_id, unsigned int* flags) : raw_id_(raw_id) {
    (void)flags;
  }",3,3,tracing\trace_event.hpp,node.tracing.TraceID.TraceID,,false,402,404,TraceID,,,8,"ANY node.tracing.TraceID.TraceID (unsigned int,unsigned int*)"
296173,METHOD,node.tracing.TraceID,TYPE_DECL,"TraceID(uint16_t raw_id, unsigned int* flags) : raw_id_(raw_id) {
    (void)flags;
  }",3,3,tracing\trace_event.hpp,node.tracing.TraceID.TraceID,,false,405,407,TraceID,,,9,"ANY node.tracing.TraceID.TraceID (uint16_t,unsigned int*)"
296182,METHOD,node.tracing.TraceID,TYPE_DECL,"TraceID(unsigned char raw_id, unsigned int* flags) : raw_id_(raw_id) {
    (void)flags;
  }",3,3,tracing\trace_event.hpp,node.tracing.TraceID.TraceID,,false,408,410,TraceID,,,10,"ANY node.tracing.TraceID.TraceID (unsigned char,unsigned int*)"
296191,METHOD,node.tracing.TraceID,TYPE_DECL,"TraceID(int64_t raw_id, unsigned int* flags)
      : raw_id_(static_cast<uint64_t>(raw_id)) {
    (void)flags;
  }",3,3,tracing\trace_event.hpp,node.tracing.TraceID.TraceID,,false,411,414,TraceID,,,11,"ANY node.tracing.TraceID.TraceID (int64_t,unsigned int*)"
296200,METHOD,node.tracing.TraceID,TYPE_DECL,"TraceID(int raw_id, unsigned int* flags)
      : raw_id_(static_cast<uint64_t>(raw_id)) {
    (void)flags;
  }",3,3,tracing\trace_event.hpp,node.tracing.TraceID.TraceID,,false,415,418,TraceID,,,12,"ANY node.tracing.TraceID.TraceID (int,unsigned int*)"
296209,METHOD,node.tracing.TraceID,TYPE_DECL,"TraceID(int16_t raw_id, unsigned int* flags)
      : raw_id_(static_cast<uint64_t>(raw_id)) {
    (void)flags;
  }",3,3,tracing\trace_event.hpp,node.tracing.TraceID.TraceID,,false,419,422,TraceID,,,13,"ANY node.tracing.TraceID.TraceID (int16_t,unsigned int*)"
296218,METHOD,node.tracing.TraceID,TYPE_DECL,"TraceID(signed char raw_id, unsigned int* flags)
      : raw_id_(static_cast<uint64_t>(raw_id)) {
    (void)flags;
  }",3,3,tracing\trace_event.hpp,node.tracing.TraceID.TraceID,,false,423,426,TraceID,,,14,"ANY node.tracing.TraceID.TraceID (signed char,unsigned int*)"
296227,METHOD,node.tracing.TraceID,TYPE_DECL,"TraceID(WithScope scoped_id, unsigned int* flags)
      : scope_(scoped_id.scope()), raw_id_(scoped_id.raw_id()) {}",3,65,tracing\trace_event.hpp,node.tracing.TraceID.TraceID,,false,427,428,TraceID,,,15,"ANY node.tracing.TraceID.TraceID (WithScope,unsigned int*)"
296233,METHOD,node.tracing.TraceID,TYPE_DECL,uint64_t raw_id() const { return raw_id_; },3,45,tracing\trace_event.hpp,node.tracing.TraceID.raw_id,,false,430,430,raw_id,,,16,uint64_t node.tracing.TraceID.raw_id ()
296239,METHOD,node.tracing.TraceID,TYPE_DECL,const char* scope() const { return scope_; },3,46,tracing\trace_event.hpp,node.tracing.TraceID.scope,,false,431,431,scope,,,17,const char* node.tracing.TraceID.scope ()
296247,METHOD,<empty>,<empty>,<empty>,1,,tracing\trace_event.hpp,node.tracing.TraceID:<clinit>,,false,332,,<clinit>,,,20,
296262,METHOD,node.tracing.TraceStringWithCopy,TYPE_DECL,explicit TraceStringWithCopy(const char* str) : str_(str) {},3,62,tracing\trace_event.hpp,node.tracing.TraceStringWithCopy.TraceStringWithCopy,,false,451,451,TraceStringWithCopy,,,1,ANY node.tracing.TraceStringWithCopy.TraceStringWithCopy (char*)
296267,METHOD,node.tracing.TraceStringWithCopy,TYPE_DECL,operator const char*() const { return str_; },3,47,tracing\trace_event.hpp,node.tracing.TraceStringWithCopy.operator const char *,,false,452,452,operator const char *,,,2,ANY node.tracing.TraceStringWithCopy.operator const char * ()
296274,METHOD,tracing\trace_event.hpp:<global>,TYPE_DECL,"static inline uint64_t AddTraceEventImpl(
    char phase, const uint8_t* category_group_enabled, const char* name,
    const char* scope, uint64_t id, uint64_t bind_id, int32_t num_args,
    const char** arg_names, const uint8_t* arg_types,
    const uint64_t* arg_values, unsigned int flags) {
  std::unique_ptr<v8::ConvertableToTraceFormat> arg_convertibles[2];
  if (num_args > 0 && arg_types[0] == TRACE_VALUE_TYPE_CONVERTABLE) {
    arg_convertibles[0].reset(reinterpret_cast<v8::ConvertableToTraceFormat*>(
        static_cast<intptr_t>(arg_values[0])));
  }
  if (num_args > 1 && arg_types[1] == TRACE_VALUE_TYPE_CONVERTABLE) {
    arg_convertibles[1].reset(reinterpret_cast<v8::ConvertableToTraceFormat*>(
        static_cast<intptr_t>(arg_values[1])));
  }
  // DCHECK(num_args, 2);
  v8::TracingController* controller =
      node::tracing::TraceEventHelper::GetTracingController();
  if (controller == nullptr) return 0;
  return controller->AddTraceEvent(phase, category_group_enabled,...",1,38,tracing\trace_event.hpp,node.tracing.AddTraceEventImpl,,false,458,479,AddTraceEventImpl,,,11,"uint64_t node.tracing.AddTraceEventImpl (char,uint8_t*,char*,char*,uint64_t,uint64_t,int32_t,char**,uint8_t*,uint64_t*,unsigned int)"
296383,METHOD,tracing\trace_event.hpp:<global>,TYPE_DECL,"INTERNAL_DECLARE_SET_TRACE_VALUE_INT(uint64_t, TRACE_VALUE_TYPE_UINT)",1,69,tracing\trace_event.hpp,node.tracing.SetTraceValue,,false,545,545,SetTraceValue,,,14,"void node.tracing.SetTraceValue (uint64_t,unsigned char*,uint64_t*)"
296402,METHOD,tracing\trace_event.hpp:<global>,TYPE_DECL,"INTERNAL_DECLARE_SET_TRACE_VALUE_INT(unsigned int, TRACE_VALUE_TYPE_UINT)",1,73,tracing\trace_event.hpp,node.tracing.SetTraceValue,,false,546,546,SetTraceValue,,,15,"void node.tracing.SetTraceValue (unsigned int,unsigned char*,uint64_t*)"
296421,METHOD,tracing\trace_event.hpp:<global>,TYPE_DECL,"INTERNAL_DECLARE_SET_TRACE_VALUE_INT(uint16_t, TRACE_VALUE_TYPE_UINT)",1,69,tracing\trace_event.hpp,node.tracing.SetTraceValue,,false,547,547,SetTraceValue,,,16,"void node.tracing.SetTraceValue (uint16_t,unsigned char*,uint64_t*)"
296440,METHOD,tracing\trace_event.hpp:<global>,TYPE_DECL,"INTERNAL_DECLARE_SET_TRACE_VALUE_INT(unsigned char, TRACE_VALUE_TYPE_UINT)",1,74,tracing\trace_event.hpp,node.tracing.SetTraceValue,,false,548,548,SetTraceValue,,,17,"void node.tracing.SetTraceValue (unsigned char,unsigned char*,uint64_t*)"
296459,METHOD,tracing\trace_event.hpp:<global>,TYPE_DECL,"INTERNAL_DECLARE_SET_TRACE_VALUE_INT(int64_t, TRACE_VALUE_TYPE_INT)",1,67,tracing\trace_event.hpp,node.tracing.SetTraceValue,,false,549,549,SetTraceValue,,,18,"void node.tracing.SetTraceValue (int64_t,unsigned char*,uint64_t*)"
296478,METHOD,tracing\trace_event.hpp:<global>,TYPE_DECL,"INTERNAL_DECLARE_SET_TRACE_VALUE_INT(int, TRACE_VALUE_TYPE_INT)",1,63,tracing\trace_event.hpp,node.tracing.SetTraceValue,,false,550,550,SetTraceValue,,,19,"void node.tracing.SetTraceValue (int,unsigned char*,uint64_t*)"
296497,METHOD,tracing\trace_event.hpp:<global>,TYPE_DECL,"INTERNAL_DECLARE_SET_TRACE_VALUE_INT(int16_t, TRACE_VALUE_TYPE_INT)",1,67,tracing\trace_event.hpp,node.tracing.SetTraceValue,,false,551,551,SetTraceValue,,,20,"void node.tracing.SetTraceValue (int16_t,unsigned char*,uint64_t*)"
296516,METHOD,tracing\trace_event.hpp:<global>,TYPE_DECL,"INTERNAL_DECLARE_SET_TRACE_VALUE_INT(signed char, TRACE_VALUE_TYPE_INT)",1,71,tracing\trace_event.hpp,node.tracing.SetTraceValue,,false,552,552,SetTraceValue,,,21,"void node.tracing.SetTraceValue (signed char,unsigned char*,uint64_t*)"
296535,METHOD,tracing\trace_event.hpp:<global>,TYPE_DECL,"INTERNAL_DECLARE_SET_TRACE_VALUE(bool, as_bool, TRACE_VALUE_TYPE_BOOL)",1,70,tracing\trace_event.hpp,node.tracing.SetTraceValue,,false,553,553,SetTraceValue,,,22,"void node.tracing.SetTraceValue (bool,unsigned char*,uint64_t*)"
296560,METHOD,tracing\trace_event.hpp:<global>,TYPE_DECL,"INTERNAL_DECLARE_SET_TRACE_VALUE(double, as_double, TRACE_VALUE_TYPE_DOUBLE)",1,76,tracing\trace_event.hpp,node.tracing.SetTraceValue,,false,554,554,SetTraceValue,,,23,"void node.tracing.SetTraceValue (double,unsigned char*,uint64_t*)"
296585,METHOD,tracing\trace_event.hpp:<global>,TYPE_DECL,"INTERNAL_DECLARE_SET_TRACE_VALUE(const void*, as_pointer,
                                 TRACE_VALUE_TYPE_POINTER)",1,58,tracing\trace_event.hpp,node.tracing.SetTraceValue,,false,555,556,SetTraceValue,,,24,"void node.tracing.SetTraceValue (void*,unsigned char*,uint64_t*)"
296610,METHOD,tracing\trace_event.hpp:<global>,TYPE_DECL,"INTERNAL_DECLARE_SET_TRACE_VALUE(const char*, as_string,
                                 TRACE_VALUE_TYPE_STRING)",1,57,tracing\trace_event.hpp,node.tracing.SetTraceValue,,false,557,558,SetTraceValue,,,25,"void node.tracing.SetTraceValue (char*,unsigned char*,uint64_t*)"
296635,METHOD,tracing\trace_event.hpp:<global>,TYPE_DECL,"INTERNAL_DECLARE_SET_TRACE_VALUE(const TraceStringWithCopy&, as_string,
                                 TRACE_VALUE_TYPE_COPY_STRING)",1,62,tracing\trace_event.hpp,node.tracing.SetTraceValue,,false,559,560,SetTraceValue,,,26,"void node.tracing.SetTraceValue (TraceStringWithCopy,unsigned char*,uint64_t*)"
296660,METHOD,tracing\trace_event.hpp:<global>,TYPE_DECL,"static inline void SetTraceValue(v8::ConvertableToTraceFormat* convertable_value,
                                    unsigned char* type, uint64_t* value) {
  *type = TRACE_VALUE_TYPE_CONVERTABLE;
  *value = static_cast<uint64_t>(reinterpret_cast<intptr_t>(convertable_value));
}",1,10,tracing\trace_event.hpp,node.tracing.SetTraceValue,,false,565,569,SetTraceValue,,,27,"void node.tracing.SetTraceValue (ANY*,unsigned char*,uint64_t*)"
296683,METHOD,tracing\trace_event.hpp:<global>,TYPE_DECL,"static inline typename std::enable_if<
    std::is_convertible<T*, v8::ConvertableToTraceFormat*>::value>::type
SetTraceValue(std::unique_ptr<T> ptr, unsigned char* type, uint64_t* value) {
  SetTraceValue(ptr.release(), type, value);
}",1,1,tracing\trace_event.hpp,node.tracing.SetTraceValue,,false,572,576,SetTraceValue,,,28,"type node.tracing.SetTraceValue<T> (ANY,unsigned char*,uint64_t*)"
296697,METHOD,tracing\trace_event.hpp:<global>,TYPE_DECL,"static inline uint64_t AddTraceEvent(char phase,
                                        const uint8_t* category_group_enabled,
                                        const char* name, const char* scope,
                                        uint64_t id, uint64_t bind_id,
                                        unsigned int flags) {
  return TRACE_EVENT_API_ADD_TRACE_EVENT(phase, category_group_enabled, name,
                                         scope, id, bind_id, kZeroNumArgs,
                                         nullptr, nullptr, nullptr, flags);
}",1,9,tracing\trace_event.hpp,node.tracing.AddTraceEvent,,false,584,592,AddTraceEvent,,,29,"uint64_t node.tracing.AddTraceEvent (char,uint8_t*,char*,char*,uint64_t,uint64_t,unsigned int)"
296728,METHOD,tracing\trace_event.hpp:<global>,TYPE_DECL,"static inline uint64_t AddTraceEvent(
    char phase, const uint8_t* category_group_enabled, const char* name,
    const char* scope, uint64_t id, uint64_t bind_id, unsigned int flags,
    const char* arg1_name, ARG1_TYPE&& arg1_val) {
  const int num_args = 1;
  uint8_t arg_type;
  uint64_t arg_value;
  SetTraceValue(std::forward<ARG1_TYPE>(arg1_val), &arg_type, &arg_value);
  return TRACE_EVENT_API_ADD_TRACE_EVENT(
      phase, category_group_enabled, name, scope, id, bind_id, num_args,
      &arg1_name, &arg_type, &arg_value, flags);
}",1,9,tracing\trace_event.hpp,node.tracing.AddTraceEvent,,false,595,606,AddTraceEvent,,,30,"uint64_t node.tracing.AddTraceEvent<ARG1_TYPE> (char,uint8_t*,char*,char*,uint64_t,uint64_t,unsigned int,char*,ARG1_TYPE)"
296782,METHOD,tracing\trace_event.hpp:<global>,TYPE_DECL,"static inline uint64_t AddTraceEvent(
    char phase, const uint8_t* category_group_enabled, const char* name,
    const char* scope, uint64_t id, uint64_t bind_id, unsigned int flags,
    const char* arg1_name, ARG1_TYPE&& arg1_val, const char* arg2_name,
    ARG2_TYPE&& arg2_val) {
  const int num_args = 2;
  const char* arg_names[2] = {arg1_name, arg2_name};
  unsigned char arg_types[2];
  uint64_t arg_values[2];
  SetTraceValue(std::forward<ARG1_TYPE>(arg1_val), &arg_types[0],
                &arg_values[0]);
  SetTraceValue(std::forward<ARG2_TYPE>(arg2_val), &arg_types[1],
                &arg_values[1]);
  return TRACE_EVENT_API_ADD_TRACE_EVENT(
      phase, category_group_enabled, name, scope, id, bind_id, num_args,
      arg_names, arg_types, arg_values, flags);
}",1,9,tracing\trace_event.hpp,node.tracing.AddTraceEvent,,false,609,625,AddTraceEvent,,,31,"uint64_t node.tracing.AddTraceEvent<ARG1_TYPE,ARG2_TYPE> (char,uint8_t*,char*,char*,uint64_t,uint64_t,unsigned int,char*,ARG1_TYPE,char*,ARG2_TYPE)"
296866,METHOD,node.tracing.ScopedTracer,TYPE_DECL,ScopedTracer() : p_data_(nullptr) {},3,38,tracing\trace_event.hpp,node.tracing.ScopedTracer.ScopedTracer,,false,686,686,ScopedTracer,,,1,ANY node.tracing.ScopedTracer.ScopedTracer ()
296870,METHOD,node.tracing.ScopedTracer,TYPE_DECL,"~ScopedTracer() {
    if (p_data_ && *data_.category_group_enabled)
      TRACE_EVENT_API_UPDATE_TRACE_EVENT_DURATION(
          data_.category_group_enabled, data_.name, data_.event_handle);
  }",3,6,tracing\trace_event.hpp,node.tracing.ScopedTracer.~ScopedTracer,,false,688,692,~ScopedTracer,,,2,ANY node.tracing.ScopedTracer.~ScopedTracer ()
296911,METHOD,node.tracing.ScopedTracer,TYPE_DECL,"void Initialize(const uint8_t* category_group_enabled, const char* name,
                  uint64_t event_handle) {
    data_.category_group_enabled = category_group_enabled;
    data_.name = name;
    data_.event_handle = event_handle;
    p_data_ = &data_;
  }",3,3,tracing\trace_event.hpp,node.tracing.ScopedTracer.Initialize,,false,694,700,Initialize,,,3,"void node.tracing.ScopedTracer.Initialize (uint8_t*,char*,uint64_t)"
296946,METHOD,tracing\trace_event_common.hpp:<global>,TYPE_DECL,<global>,1,34,tracing\trace_event_common.hpp,tracing\trace_event_common.hpp:<global>,,false,1,1109,<global>,,,1,
296965,METHOD,tracing\traced_value.cc:<global>,TYPE_DECL,<global>,1,1,tracing\traced_value.cc,tracing\traced_value.cc:<global>,,false,1,222,<global>,,,1,
296970,METHOD,tracing\traced_value.cc:<global>,TYPE_DECL,"std::string EscapeString(const char* value) {
  std::string result;
  result += '""';
  char number_buffer[10];
#if defined(NODE_HAVE_I18N_SUPPORT)
  int32_t len = strlen(value);
  int32_t p = 0;
  int32_t i = 0;
  for (; i < len; p = i) {
    UChar32 c;
    U8_NEXT_OR_FFFD(value, i, len, c);
    switch (c) {
      case '\b': result += ""\\b""; break;
      case '\f': result += ""\\f""; break;
      case '\n': result += ""\\n""; break;
      case '\r': result += ""\\r""; break;
      case '\t': result += ""\\t""; break;
      case '\\': result += ""\\\\""; break;
      case '""': result += ""\\\""""; break;
      default:
        if (c < 32 || c > 126) {
          snprintf(
              number_buffer, arraysize(number_buffer), ""\\u%04X"",
              static_cast<uint16_t>(static_cast<uint16_t>(c)));
          result += number_buffer;
        } else {
          result.append(value + p, i - p);
        }
    }
  }
#else
  // If we do not have ICU, use a modified version of the non-UTF8 aware
  // co...",1,1,tracing\traced_value.cc,node.tracing.anonymous_namespace_1.EscapeString,,false,29,87,EscapeString,,,1,string node.tracing.anonymous_namespace_1.EscapeString (char*)
297064,METHOD,tracing\traced_value.cc:<global>,TYPE_DECL,"std::string DoubleToCString(double v) {
  switch (FPCLASSIFY_NAMESPACE::fpclassify(v)) {
    case FP_NAN: return ""\""NaN\"""";
    case FP_INFINITE: return (v < 0.0 ? ""\""-Infinity\"""" : ""\""Infinity\"""");
    case FP_ZERO: return ""0"";
    default:
      // This is a far less sophisticated version than the one used inside v8.
      std::ostringstream stream;
      stream.imbue(std::locale::classic());  // Ignore current locale
      stream << v;
      return stream.str();
  }
}",1,10,tracing\traced_value.cc,node.tracing.anonymous_namespace_2.DoubleToCString,,false,89,101,DoubleToCString,,,2,string node.tracing.anonymous_namespace_2.DoubleToCString (double)
297115,METHOD,tracing\traced_value.cc:<global>,TYPE_DECL,"std::unique_ptr<TracedValue> TracedValue::Create() {
  return std::unique_ptr<TracedValue>(new TracedValue(false));
}",1,1,tracing\traced_value.cc,node.tracing.TracedValue.Create,,false,105,107,Create,,,2,unique_ptr<TracedValue> node.tracing.TracedValue.Create ()
297129,METHOD,tracing\traced_value.cc:<global>,TYPE_DECL,"std::unique_ptr<TracedValue> TracedValue::CreateArray() {
  return std::unique_ptr<TracedValue>(new TracedValue(true));
}",1,1,tracing\traced_value.cc,node.tracing.TracedValue.CreateArray,,false,109,111,CreateArray,,,3,unique_ptr<TracedValue> node.tracing.TracedValue.CreateArray ()
297143,METHOD,tracing\traced_value.cc:<global>,TYPE_DECL,"TracedValue::TracedValue(bool root_is_array) :
    first_item_(true), root_is_array_(root_is_array) {}",1,55,tracing\traced_value.cc,node.tracing.TracedValue.TracedValue,,false,113,114,TracedValue,,,4,ANY node.tracing.TracedValue.TracedValue (bool)
297148,METHOD,tracing\traced_value.cc:<global>,TYPE_DECL,"void TracedValue::SetInteger(const char* name, int value) {
  WriteName(name);
  data_ += std::to_string(value);
}",1,1,tracing\traced_value.cc,node.tracing.TracedValue.SetInteger,,false,116,119,SetInteger,,,5,"void node.tracing.TracedValue.SetInteger (char*,int)"
297163,METHOD,tracing\traced_value.cc:<global>,TYPE_DECL,"void TracedValue::SetDouble(const char* name, double value) {
  WriteName(name);
  data_ += DoubleToCString(value);
}",1,1,tracing\traced_value.cc,node.tracing.TracedValue.SetDouble,,false,121,124,SetDouble,,,6,"void node.tracing.TracedValue.SetDouble (char*,double)"
297175,METHOD,tracing\traced_value.cc:<global>,TYPE_DECL,"void TracedValue::SetBoolean(const char* name, bool value) {
  WriteName(name);
  data_ += value ? ""true"" : ""false"";
}",1,1,tracing\traced_value.cc,node.tracing.TracedValue.SetBoolean,,false,126,129,SetBoolean,,,7,"void node.tracing.TracedValue.SetBoolean (char*,bool)"
297189,METHOD,tracing\traced_value.cc:<global>,TYPE_DECL,"void TracedValue::SetNull(const char* name) {
  WriteName(name);
  data_ += ""null"";
}",1,1,tracing\traced_value.cc,node.tracing.TracedValue.SetNull,,false,131,134,SetNull,,,8,void node.tracing.TracedValue.SetNull (char*)
297199,METHOD,tracing\traced_value.cc:<global>,TYPE_DECL,"void TracedValue::SetString(const char* name, const char* value) {
  WriteName(name);
  data_ += EscapeString(value);
}",1,1,tracing\traced_value.cc,node.tracing.TracedValue.SetString,,false,136,139,SetString,,,9,"void node.tracing.TracedValue.SetString (char*,char*)"
297211,METHOD,tracing\traced_value.cc:<global>,TYPE_DECL,"void TracedValue::BeginDictionary(const char* name) {
  WriteName(name);
  data_ += '{';
  first_item_ = true;
}",1,1,tracing\traced_value.cc,node.tracing.TracedValue.BeginDictionary,,false,141,145,BeginDictionary,,,10,void node.tracing.TracedValue.BeginDictionary (char*)
297224,METHOD,tracing\traced_value.cc:<global>,TYPE_DECL,"void TracedValue::BeginArray(const char* name) {
  WriteName(name);
  data_ += '[';
  first_item_ = true;
}",1,1,tracing\traced_value.cc,node.tracing.TracedValue.BeginArray,,false,147,151,BeginArray,,,11,void node.tracing.TracedValue.BeginArray (char*)
297237,METHOD,tracing\traced_value.cc:<global>,TYPE_DECL,"void TracedValue::AppendInteger(int value) {
  WriteComma();
  data_ += std::to_string(value);
}",1,1,tracing\traced_value.cc,node.tracing.TracedValue.AppendInteger,,false,153,156,AppendInteger,,,12,void node.tracing.TracedValue.AppendInteger (int)
297250,METHOD,tracing\traced_value.cc:<global>,TYPE_DECL,"void TracedValue::AppendDouble(double value) {
  WriteComma();
  data_ += DoubleToCString(value);
}",1,1,tracing\traced_value.cc,node.tracing.TracedValue.AppendDouble,,false,158,161,AppendDouble,,,13,void node.tracing.TracedValue.AppendDouble (double)
297260,METHOD,tracing\traced_value.cc:<global>,TYPE_DECL,"void TracedValue::AppendBoolean(bool value) {
  WriteComma();
  data_ += value ? ""true"" : ""false"";
}",1,1,tracing\traced_value.cc,node.tracing.TracedValue.AppendBoolean,,false,163,166,AppendBoolean,,,14,void node.tracing.TracedValue.AppendBoolean (bool)
297272,METHOD,tracing\traced_value.cc:<global>,TYPE_DECL,"void TracedValue::AppendNull() {
  WriteComma();
  data_ += ""null"";
}",1,1,tracing\traced_value.cc,node.tracing.TracedValue.AppendNull,,false,168,171,AppendNull,,,15,void node.tracing.TracedValue.AppendNull ()
297280,METHOD,tracing\traced_value.cc:<global>,TYPE_DECL,"void TracedValue::AppendString(const char* value) {
  WriteComma();
  data_ += EscapeString(value);
}",1,1,tracing\traced_value.cc,node.tracing.TracedValue.AppendString,,false,173,176,AppendString,,,16,void node.tracing.TracedValue.AppendString (char*)
297290,METHOD,tracing\traced_value.cc:<global>,TYPE_DECL,"void TracedValue::BeginDictionary() {
  WriteComma();
  data_ += '{';
  first_item_ = true;
}",1,1,tracing\traced_value.cc,node.tracing.TracedValue.BeginDictionary,,false,178,182,BeginDictionary,,,17,void node.tracing.TracedValue.BeginDictionary ()
297301,METHOD,tracing\traced_value.cc:<global>,TYPE_DECL,"void TracedValue::BeginArray() {
  WriteComma();
  data_ += '[';
  first_item_ = true;
}",1,1,tracing\traced_value.cc,node.tracing.TracedValue.BeginArray,,false,184,188,BeginArray,,,18,void node.tracing.TracedValue.BeginArray ()
297312,METHOD,tracing\traced_value.cc:<global>,TYPE_DECL,"void TracedValue::EndDictionary() {
  data_ += '}';
  first_item_ = false;
}",1,1,tracing\traced_value.cc,node.tracing.TracedValue.EndDictionary,,false,190,193,EndDictionary,,,19,void node.tracing.TracedValue.EndDictionary ()
297322,METHOD,tracing\traced_value.cc:<global>,TYPE_DECL,"void TracedValue::EndArray() {
  data_ += ']';
  first_item_ = false;
}",1,1,tracing\traced_value.cc,node.tracing.TracedValue.EndArray,,false,195,198,EndArray,,,20,void node.tracing.TracedValue.EndArray ()
297332,METHOD,tracing\traced_value.cc:<global>,TYPE_DECL,"void TracedValue::WriteComma() {
  if (first_item_) {
    first_item_ = false;
  } else {
    data_ += ',';
  }
}",1,1,tracing\traced_value.cc,node.tracing.TracedValue.WriteComma,,false,200,206,WriteComma,,,21,void node.tracing.TracedValue.WriteComma ()
297347,METHOD,tracing\traced_value.cc:<global>,TYPE_DECL,"void TracedValue::WriteName(const char* name) {
  WriteComma();
  data_ += '""';
  data_ += name;
  data_ += ""\"":"";
}",1,1,tracing\traced_value.cc,node.tracing.TracedValue.WriteName,,false,208,213,WriteName,,,22,void node.tracing.TracedValue.WriteName (char*)
297362,METHOD,tracing\traced_value.cc:<global>,TYPE_DECL,"void TracedValue::AppendAsTraceFormat(std::string* out) const {
  *out += root_is_array_ ? '[' : '{';
  *out += data_;
  *out += root_is_array_ ? ']' : '}';
}",1,1,tracing\traced_value.cc,node.tracing.TracedValue.AppendAsTraceFormat,,false,215,219,AppendAsTraceFormat,,,23,void node.tracing.TracedValue.AppendAsTraceFormat (ANY*)
297400,METHOD,tracing\traced_value.hpp:<global>,TYPE_DECL,<global>,1,1,tracing\traced_value.hpp,tracing\traced_value.hpp:<global>,,false,1,70,<global>,,,1,
297405,METHOD,node.tracing.TracedValue,TYPE_DECL,~TracedValue() override = default;,3,36,tracing\traced_value.hpp,node.tracing.TracedValue.~TracedValue,,false,21,21,~TracedValue,,,1,ANY node.tracing.TracedValue.~TracedValue ()
297409,METHOD,node.tracing.TracedValue,TYPE_DECL,static std::unique_ptr<TracedValue> Create();,39,46,tracing\traced_value.hpp,node.tracing.TracedValue.Create,,false,23,23,Create,,,2,ANY node.tracing.TracedValue.Create ()
297413,METHOD,node.tracing.TracedValue,TYPE_DECL,static std::unique_ptr<TracedValue> CreateArray();,39,51,tracing\traced_value.hpp,node.tracing.TracedValue.CreateArray,,false,24,24,CreateArray,,,3,ANY node.tracing.TracedValue.CreateArray ()
297417,METHOD,node.tracing.TracedValue,TYPE_DECL,void EndDictionary();,8,22,tracing\traced_value.hpp,node.tracing.TracedValue.EndDictionary,,false,26,26,EndDictionary,,,4,void node.tracing.TracedValue.EndDictionary ()
297421,METHOD,node.tracing.TracedValue,TYPE_DECL,void EndArray();,8,17,tracing\traced_value.hpp,node.tracing.TracedValue.EndArray,,false,27,27,EndArray,,,5,void node.tracing.TracedValue.EndArray ()
297425,METHOD,node.tracing.TracedValue,TYPE_DECL,"void SetInteger(const char* name, int value);",8,46,tracing\traced_value.hpp,node.tracing.TracedValue.SetInteger,,false,30,30,SetInteger,,,6,"void node.tracing.TracedValue.SetInteger (char*,int)"
297431,METHOD,node.tracing.TracedValue,TYPE_DECL,"void SetDouble(const char* name, double value);",8,48,tracing\traced_value.hpp,node.tracing.TracedValue.SetDouble,,false,31,31,SetDouble,,,7,"void node.tracing.TracedValue.SetDouble (char*,double)"
297437,METHOD,node.tracing.TracedValue,TYPE_DECL,"void SetBoolean(const char* name, bool value);",8,47,tracing\traced_value.hpp,node.tracing.TracedValue.SetBoolean,,false,32,32,SetBoolean,,,8,"void node.tracing.TracedValue.SetBoolean (char*,bool)"
297443,METHOD,node.tracing.TracedValue,TYPE_DECL,void SetNull(const char* name);,8,32,tracing\traced_value.hpp,node.tracing.TracedValue.SetNull,,false,33,33,SetNull,,,9,void node.tracing.TracedValue.SetNull (char*)
297448,METHOD,node.tracing.TracedValue,TYPE_DECL,"void SetString(const char* name, const char* value);",8,53,tracing\traced_value.hpp,node.tracing.TracedValue.SetString,,false,34,34,SetString,,,10,"void node.tracing.TracedValue.SetString (char*,char*)"
297454,METHOD,node.tracing.TracedValue,TYPE_DECL,"void SetString(const char* name, const std::string& value) {
    SetString(name, value.c_str());
  }",3,3,tracing\traced_value.hpp,node.tracing.TracedValue.SetString,,false,35,37,SetString,,,11,"void node.tracing.TracedValue.SetString (char*,ANY)"
297466,METHOD,node.tracing.TracedValue,TYPE_DECL,void BeginDictionary(const char* name);,8,40,tracing\traced_value.hpp,node.tracing.TracedValue.BeginDictionary,,false,38,38,BeginDictionary,,,12,void node.tracing.TracedValue.BeginDictionary (char*)
297471,METHOD,node.tracing.TracedValue,TYPE_DECL,void BeginArray(const char* name);,8,35,tracing\traced_value.hpp,node.tracing.TracedValue.BeginArray,,false,39,39,BeginArray,,,13,void node.tracing.TracedValue.BeginArray (char*)
297476,METHOD,node.tracing.TracedValue,TYPE_DECL,void AppendInteger(int);,8,25,tracing\traced_value.hpp,node.tracing.TracedValue.AppendInteger,,false,41,41,AppendInteger,,,14,void node.tracing.TracedValue.AppendInteger (int)
297481,METHOD,node.tracing.TracedValue,TYPE_DECL,void AppendDouble(double);,8,27,tracing\traced_value.hpp,node.tracing.TracedValue.AppendDouble,,false,42,42,AppendDouble,,,15,void node.tracing.TracedValue.AppendDouble (double)
297486,METHOD,node.tracing.TracedValue,TYPE_DECL,void AppendBoolean(bool);,8,26,tracing\traced_value.hpp,node.tracing.TracedValue.AppendBoolean,,false,43,43,AppendBoolean,,,16,void node.tracing.TracedValue.AppendBoolean (bool)
297491,METHOD,node.tracing.TracedValue,TYPE_DECL,void AppendNull();,8,19,tracing\traced_value.hpp,node.tracing.TracedValue.AppendNull,,false,44,44,AppendNull,,,17,void node.tracing.TracedValue.AppendNull ()
297495,METHOD,node.tracing.TracedValue,TYPE_DECL,void AppendString(const char*);,8,32,tracing\traced_value.hpp,node.tracing.TracedValue.AppendString,,false,45,45,AppendString,,,18,void node.tracing.TracedValue.AppendString (char*)
297500,METHOD,node.tracing.TracedValue,TYPE_DECL,void AppendString(const std::string& value) { AppendString(value.c_str()); },3,78,tracing\traced_value.hpp,node.tracing.TracedValue.AppendString,,false,46,46,AppendString,,,19,void node.tracing.TracedValue.AppendString (ANY)
297510,METHOD,node.tracing.TracedValue,TYPE_DECL,void BeginArray();,8,19,tracing\traced_value.hpp,node.tracing.TracedValue.BeginArray,,false,47,47,BeginArray,,,20,void node.tracing.TracedValue.BeginArray ()
297514,METHOD,node.tracing.TracedValue,TYPE_DECL,void BeginDictionary();,8,24,tracing\traced_value.hpp,node.tracing.TracedValue.BeginDictionary,,false,48,48,BeginDictionary,,,21,void node.tracing.TracedValue.BeginDictionary ()
297518,METHOD,node.tracing.TracedValue,TYPE_DECL,void AppendAsTraceFormat(std::string* out) const override;,8,59,tracing\traced_value.hpp,node.tracing.TracedValue.AppendAsTraceFormat,,false,51,51,AppendAsTraceFormat,,,22,void node.tracing.TracedValue.AppendAsTraceFormat (ANY*)
297523,METHOD,node.tracing.TracedValue,TYPE_DECL,TracedValue(const TracedValue&) = delete;,3,43,tracing\traced_value.hpp,node.tracing.TracedValue.TracedValue,,false,53,53,TracedValue,,,23,ANY node.tracing.TracedValue.TracedValue (TracedValue)
297528,METHOD,node.tracing.TracedValue,TYPE_DECL,TracedValue& operator=(const TracedValue&) = delete;,3,54,tracing\traced_value.hpp,node.tracing.TracedValue.operator =,,false,54,54,operator =,,,24,TracedValue node.tracing.TracedValue.operator = (TracedValue)
297533,METHOD,node.tracing.TracedValue,TYPE_DECL,explicit TracedValue(bool root_is_array = false);,12,50,tracing\traced_value.hpp,node.tracing.TracedValue.TracedValue,,false,57,57,TracedValue,,,25,explicit node.tracing.TracedValue.TracedValue (bool)
297538,METHOD,node.tracing.TracedValue,TYPE_DECL,void WriteComma();,8,19,tracing\traced_value.hpp,node.tracing.TracedValue.WriteComma,,false,59,59,WriteComma,,,26,void node.tracing.TracedValue.WriteComma ()
297542,METHOD,node.tracing.TracedValue,TYPE_DECL,void WriteName(const char* name);,8,34,tracing\traced_value.hpp,node.tracing.TracedValue.WriteName,,false,60,60,WriteName,,,27,void node.tracing.TracedValue.WriteName (char*)
297569,METHOD,tty_wrap.cc:<global>,TYPE_DECL,<global>,1,1,tty_wrap.cc,tty_wrap.cc:<global>,,false,1,161,<global>,,,1,
297572,METHOD,tty_wrap.cc:<global>,TYPE_DECL,"void TTYWrap::RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(New);
  registry->Register(GetWindowSize);
  registry->Register(SetRawMode);
  registry->Register(IsTTY);
}",1,1,tty_wrap.cc,node.TTYWrap.RegisterExternalReferences,,false,45,50,RegisterExternalReferences,,,1,void node.TTYWrap.RegisterExternalReferences (ExternalReferenceRegistry*)
297597,METHOD,tty_wrap.cc:<global>,TYPE_DECL,"void TTYWrap::Initialize(Local<Object> target,
                         Local<Value> unused,
                         Local<Context> context,
                         void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<String> ttyString = FIXED_ONE_BYTE_STRING(env->isolate(), ""TTY"");

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->SetClassName(ttyString);
  t->InstanceTemplate()->SetInternalFieldCount(StreamBase::kInternalFieldCount);
  t->Inherit(LibuvStreamWrap::GetConstructorTemplate(env));

  SetProtoMethodNoSideEffect(
      isolate, t, ""getWindowSize"", TTYWrap::GetWindowSize);
  SetProtoMethod(isolate, t, ""setRawMode"", SetRawMode);

  SetMethodNoSideEffect(context, target, ""isTTY"", IsTTY);

  Local<Value> func;
  if (t->GetFunction(context).ToLocal(&func) &&
      target->Set(context, ttyString, func).IsJust()) {
    env->set_tty_constructor_template(t);
  }
}",1,1,tty_wrap.cc,node.TTYWrap.Initialize,,false,52,77,Initialize,,,2,"void node.TTYWrap.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
297715,METHOD,tty_wrap.cc:<global>,TYPE_DECL,"void TTYWrap::IsTTY(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  int fd;
  if (!args[0]->Int32Value(env->context()).To(&fd)) return;
  CHECK_GE(fd, 0);
  bool rc = uv_guess_handle(fd) == UV_TTY;
  args.GetReturnValue().Set(rc);
}",1,1,tty_wrap.cc,node.TTYWrap.IsTTY,,false,80,87,IsTTY,,,3,void node.TTYWrap.IsTTY (FunctionCallbackInfo<Value>)
297766,METHOD,tty_wrap.cc:<global>,TYPE_DECL,"void TTYWrap::GetWindowSize(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  TTYWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  CHECK(args[0]->IsArray());

  int width, height;
  int err = uv_tty_get_winsize(&wrap->handle_, &width, &height);

  if (err == 0) {
    Local<Array> a = args[0].As<Array>();
    a->Set(env->context(), 0, Integer::New(env->isolate(), width)).Check();
    a->Set(env->context(), 1, Integer::New(env->isolate(), height)).Check();
  }

  args.GetReturnValue().Set(err);
}",1,1,tty_wrap.cc,node.TTYWrap.GetWindowSize,,false,90,109,GetWindowSize,,,4,void node.TTYWrap.GetWindowSize (FunctionCallbackInfo<Value>)
297883,METHOD,tty_wrap.cc:<global>,TYPE_DECL,"void TTYWrap::SetRawMode(const FunctionCallbackInfo<Value>& args) {
  TTYWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  int err = uv_tty_set_mode(&wrap->handle_, args[0]->IsTrue());
  args.GetReturnValue().Set(err);
}",1,1,tty_wrap.cc,node.TTYWrap.SetRawMode,,false,112,119,SetRawMode,,,5,void node.TTYWrap.SetRawMode (FunctionCallbackInfo<Value>)
297926,METHOD,tty_wrap.cc:<global>,TYPE_DECL,"void TTYWrap::New(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  // This constructor should not be exposed to public javascript.
  // Therefore we assert that we are not trying to call this as a
  // normal function.
  CHECK(args.IsConstructCall());

  int fd;
  if (!args[0]->Int32Value(env->context()).To(&fd)) return;
  CHECK_GE(fd, 0);

  int err = 0;
  new TTYWrap(env, args.This(), fd, &err);
  if (err != 0) {
    env->CollectUVExceptionInfo(args[1], err, ""uv_tty_init"");
    args.GetReturnValue().SetUndefined();
  }
}",1,1,tty_wrap.cc,node.TTYWrap.New,,false,122,140,New,,,6,void node.TTYWrap.New (FunctionCallbackInfo<Value>)
298002,METHOD,tty_wrap.cc:<global>,TYPE_DECL,"TTYWrap::TTYWrap(Environment* env,
                 Local<Object> object,
                 int fd,
                 int* init_err)
    : LibuvStreamWrap(env,
                      object,
                      reinterpret_cast<uv_stream_t*>(&handle_),
                      AsyncWrap::PROVIDER_TTYWRAP) {
  *init_err = uv_tty_init(env->event_loop(), &handle_, fd, 0);
  set_fd(fd);
  if (*init_err != 0)
    MarkAsUninitialized();
}",1,1,tty_wrap.cc,node.TTYWrap.TTYWrap,,false,143,155,TTYWrap,,,7,"ANY node.TTYWrap.TTYWrap (Environment*,Local<Object>,int,int*)"
298039,METHOD,tty_wrap.hpp:<global>,TYPE_DECL,<global>,1,26,tty_wrap.hpp,tty_wrap.hpp:<global>,,false,1,65,<global>,,,1,
298042,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"[](uv_udp_send_t* req, int status) {
          UDPWrap* self = ContainerOf(&UDPWrap::handle_, req->handle);
          self->listener()->OnSendDone(
              ReqWrap<uv_udp_send_t>::from_req(req), status);
        }",24,9,udp_wrap.cc,node.UDPWrap.Send.<lambda>0,,false,601,605,<lambda>0,,,1,"ANY node.UDPWrap.Send.<lambda>0 (uv_udp_send_t*,int)"
298095,METHOD,udp_wrap.cc:<global>,TYPE_DECL,<global>,1,1,udp_wrap.cc,udp_wrap.cc:<global>,,false,1,809,<global>,,,1,
298099,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"void SetLibuvInt32(const FunctionCallbackInfo<Value>& args) {
  UDPWrap* wrap = Unwrap<UDPWrap>(args.Holder());
  if (wrap == nullptr) {
    args.GetReturnValue().Set(UV_EBADF);
    return;
  }
  Environment* env = wrap->env();
  CHECK_EQ(args.Length(), 1);
  int flag;
  if (!args[0]->Int32Value(env->context()).To(&flag)) {
    return;
  }
  int err = fn(wrap->GetLibuvHandle(), flag);
  args.GetReturnValue().Set(err);
}",1,1,udp_wrap.cc,node.anonymous_namespace_1.SetLibuvInt32,,false,57,71,SetLibuvInt32,,,1,"void node.anonymous_namespace_1.SetLibuvInt32<int(*)(uv_udp_t*, int)> (FunctionCallbackInfo<Value>)"
298180,METHOD,node.SendWrap,TYPE_DECL,"SendWrap(Environment* env, Local<Object> req_wrap_obj, bool have_callback);",3,76,udp_wrap.cc,node.SendWrap.SendWrap,,false,76,76,SendWrap,,,1,"ANY node.SendWrap.SendWrap (Environment*,Local<Object>,bool)"
298187,METHOD,node.SendWrap,TYPE_DECL,inline bool have_callback() const;,15,35,udp_wrap.cc,node.SendWrap.have_callback,,false,77,77,have_callback,,,2,bool node.SendWrap.have_callback ()
298193,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"SendWrap::SendWrap(Environment* env,
                   Local<Object> req_wrap_obj,
                   bool have_callback)
    : ReqWrap(env, req_wrap_obj, AsyncWrap::PROVIDER_UDPSENDWRAP),
      have_callback_(have_callback) {
}",1,1,udp_wrap.cc,node.SendWrap.SendWrap,,false,89,94,SendWrap,,,3,"ANY node.SendWrap.SendWrap (Environment*,Local<Object>,bool)"
298200,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"bool SendWrap::have_callback() const {
  return have_callback_;
}",1,1,udp_wrap.cc,node.SendWrap.have_callback,,false,97,99,have_callback,,,4,bool node.SendWrap.have_callback ()
298206,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"UDPListener::~UDPListener() {
  if (wrap_ != nullptr)
    wrap_->set_listener(nullptr);
}",1,1,udp_wrap.cc,node.UDPListener.~UDPListener,,false,101,104,~UDPListener,,,5,ANY node.UDPListener.~UDPListener ()
298220,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"UDPWrapBase::~UDPWrapBase() {
  set_listener(nullptr);
}",1,1,udp_wrap.cc,node.UDPWrapBase.~UDPWrapBase,,false,106,108,~UDPWrapBase,,,6,ANY node.UDPWrapBase.~UDPWrapBase ()
298226,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"UDPListener* UDPWrapBase::listener() const {
  CHECK_NOT_NULL(listener_);
  return listener_;
}",1,1,udp_wrap.cc,node.UDPWrapBase.listener,,false,110,113,listener,,,7,UDPListener node.UDPWrapBase.listener ()
298233,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"void UDPWrapBase::set_listener(UDPListener* listener) {
  if (listener_ != nullptr)
    listener_->wrap_ = nullptr;
  listener_ = listener;
  if (listener_ != nullptr) {
    CHECK_NULL(listener_->wrap_);
    listener_->wrap_ = this;
  }
}",1,1,udp_wrap.cc,node.UDPWrapBase.set_listener,,false,115,123,set_listener,,,8,void node.UDPWrapBase.set_listener (UDPListener*)
298265,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"UDPWrapBase* UDPWrapBase::FromObject(Local<Object> obj) {
  CHECK_GT(obj->InternalFieldCount(), UDPWrapBase::kUDPWrapBaseField);
  return static_cast<UDPWrapBase*>(
      obj->GetAlignedPointerFromInternalField(UDPWrapBase::kUDPWrapBaseField));
}",1,1,udp_wrap.cc,node.UDPWrapBase.FromObject,,false,125,129,FromObject,,,9,UDPWrapBase node.UDPWrapBase.FromObject (Local<Object>)
298288,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"void UDPWrapBase::AddMethods(Environment* env, Local<FunctionTemplate> t) {
  SetProtoMethod(env->isolate(), t, ""recvStart"", RecvStart);
  SetProtoMethod(env->isolate(), t, ""recvStop"", RecvStop);
}",1,1,udp_wrap.cc,node.UDPWrapBase.AddMethods,,false,131,134,AddMethods,,,10,"void node.UDPWrapBase.AddMethods (Environment*,Local<FunctionTemplate>)"
298310,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"UDPWrap::UDPWrap(Environment* env, Local<Object> object)
    : HandleWrap(env,
                 object,
                 reinterpret_cast<uv_handle_t*>(&handle_),
                 AsyncWrap::PROVIDER_UDPWRAP) {
  object->SetAlignedPointerInInternalField(
      UDPWrapBase::kUDPWrapBaseField, static_cast<UDPWrapBase*>(this));

  int r = uv_udp_init(env->event_loop(), &handle_);
  CHECK_EQ(r, 0);  // can't fail anyway

  set_listener(this);
}",1,1,udp_wrap.cc,node.UDPWrap.UDPWrap,,false,136,148,UDPWrap,,,11,"ANY node.UDPWrap.UDPWrap (Environment*,Local<Object>)"
298341,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"void UDPWrap::Initialize(Local<Object> target,
                         Local<Value> unused,
                         Local<Context> context,
                         void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->InstanceTemplate()->SetInternalFieldCount(
      UDPWrapBase::kInternalFieldCount);

  enum PropertyAttribute attributes =
      static_cast<PropertyAttribute>(ReadOnly | DontDelete);

  Local<Signature> signature = Signature::New(isolate, t);

  Local<FunctionTemplate> get_fd_templ =
      FunctionTemplate::New(isolate, UDPWrap::GetFD, Local<Value>(), signature);

  t->PrototypeTemplate()->SetAccessorProperty(env->fd_string(),
                                              get_fd_templ,
                                              Local<FunctionTemplate>(),
                                              attributes);

  UDPWrapBase::AddMethods(en...",1,2,udp_wrap.cc,node.UDPWrap.Initialize,,false,151,230,Initialize,,,12,"void node.UDPWrap.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
298822,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"void UDPWrap::New(const FunctionCallbackInfo<Value>& args) {
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new UDPWrap(env, args.This());
}",1,1,udp_wrap.cc,node.UDPWrap.New,,false,233,237,New,,,13,void node.UDPWrap.New (FunctionCallbackInfo<Value>)
298847,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"void UDPWrap::GetFD(const FunctionCallbackInfo<Value>& args) {
  int fd = UV_EBADF;
#if !defined(_WIN32)
  UDPWrap* wrap = Unwrap<UDPWrap>(args.This());
  if (wrap != nullptr)
    uv_fileno(reinterpret_cast<uv_handle_t*>(&wrap->handle_), &fd);
#endif
  args.GetReturnValue().Set(fd);
}",1,1,udp_wrap.cc,node.UDPWrap.GetFD,,false,240,248,GetFD,,,14,void node.UDPWrap.GetFD (FunctionCallbackInfo<Value>)
298889,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"int sockaddr_for_family(int address_family,
                        const char* address,
                        const unsigned short port,
                        struct sockaddr_storage* addr) {
  switch (address_family) {
    case AF_INET:
      return uv_ip4_addr(address, port, reinterpret_cast<sockaddr_in*>(addr));
    case AF_INET6:
      return uv_ip6_addr(address, port, reinterpret_cast<sockaddr_in6*>(addr));
    default:
      UNREACHABLE(""unexpected address family"");
  }
}",1,1,udp_wrap.cc,node.sockaddr_for_family,,false,250,262,sockaddr_for_family,,,15,"int node.sockaddr_for_family (int,char*,short unsigned,sockaddr_storage*)"
298921,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"void UDPWrap::DoBind(const FunctionCallbackInfo<Value>& args, int family) {
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  // bind(ip, port, flags)
  CHECK_EQ(args.Length(), 3);

  node::Utf8Value address(args.GetIsolate(), args[0]);
  Local<Context> ctx = args.GetIsolate()->GetCurrentContext();
  uint32_t port, flags;
  if (!args[1]->Uint32Value(ctx).To(&port) ||
      !args[2]->Uint32Value(ctx).To(&flags))
    return;
  struct sockaddr_storage addr_storage;
  int err = sockaddr_for_family(family, address.out(), port, &addr_storage);
  if (err == 0) {
    err = uv_udp_bind(&wrap->handle_,
                      reinterpret_cast<const sockaddr*>(&addr_storage),
                      flags);
  }

  if (err == 0)
    wrap->listener()->OnAfterBind();

  args.GetReturnValue().Set(err);
}",1,1,udp_wrap.cc,node.UDPWrap.DoBind,,false,264,291,DoBind,,,16,"void node.UDPWrap.DoBind (FunctionCallbackInfo<Value>,int)"
299053,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"void UDPWrap::DoConnect(const FunctionCallbackInfo<Value>& args, int family) {
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK_EQ(args.Length(), 2);

  node::Utf8Value address(args.GetIsolate(), args[0]);
  Local<Context> ctx = args.GetIsolate()->GetCurrentContext();
  uint32_t port;
  if (!args[1]->Uint32Value(ctx).To(&port))
    return;
  struct sockaddr_storage addr_storage;
  int err = sockaddr_for_family(family, address.out(), port, &addr_storage);
  if (err == 0) {
    err = uv_udp_connect(&wrap->handle_,
                         reinterpret_cast<const sockaddr*>(&addr_storage));
  }

  args.GetReturnValue().Set(err);
}",1,1,udp_wrap.cc,node.UDPWrap.DoConnect,,false,294,315,DoConnect,,,17,"void node.UDPWrap.DoConnect (FunctionCallbackInfo<Value>,int)"
299157,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"void UDPWrap::Open(const FunctionCallbackInfo<Value>& args) {
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  CHECK(args[0]->IsNumber());
  int fd = static_cast<int>(args[0].As<Integer>()->Value());
  int err = uv_udp_open(&wrap->handle_, fd);

  args.GetReturnValue().Set(err);
}",1,1,udp_wrap.cc,node.UDPWrap.Open,,false,318,328,Open,,,18,void node.UDPWrap.Open (FunctionCallbackInfo<Value>)
299216,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"void UDPWrap::Bind(const FunctionCallbackInfo<Value>& args) {
  DoBind(args, AF_INET);
}",1,1,udp_wrap.cc,node.UDPWrap.Bind,,false,331,333,Bind,,,19,void node.UDPWrap.Bind (FunctionCallbackInfo<Value>)
299224,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"void UDPWrap::Bind6(const FunctionCallbackInfo<Value>& args) {
  DoBind(args, AF_INET6);
}",1,1,udp_wrap.cc,node.UDPWrap.Bind6,,false,336,338,Bind6,,,20,void node.UDPWrap.Bind6 (FunctionCallbackInfo<Value>)
299232,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"void UDPWrap::BufferSize(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK(args[0]->IsUint32());
  CHECK(args[1]->IsBoolean());
  bool is_recv = args[1].As<Boolean>()->Value();
  const char* uv_func_name = is_recv ? ""uv_recv_buffer_size"" :
                                       ""uv_send_buffer_size"";

  if (!args[0]->IsInt32()) {
    env->CollectUVExceptionInfo(args[2], UV_EINVAL, uv_func_name);
    return args.GetReturnValue().SetUndefined();
  }

  uv_handle_t* handle = reinterpret_cast<uv_handle_t*>(&wrap->handle_);
  int size = static_cast<int>(args[0].As<Uint32>()->Value());
  int err;

  if (is_recv)
    err = uv_recv_buffer_size(handle, &size);
  else
    err = uv_send_buffer_size(handle, &size);

  if (err != 0) {
    env->CollectUVExceptionInfo(args[2], err, uv_func_na...",1,1,udp_wrap.cc,node.UDPWrap.BufferSize,,false,341,374,BufferSize,,,21,void node.UDPWrap.BufferSize (FunctionCallbackInfo<Value>)
299391,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"void UDPWrap::Connect(const FunctionCallbackInfo<Value>& args) {
  DoConnect(args, AF_INET);
}",1,1,udp_wrap.cc,node.UDPWrap.Connect,,false,377,379,Connect,,,22,void node.UDPWrap.Connect (FunctionCallbackInfo<Value>)
299399,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"void UDPWrap::Connect6(const FunctionCallbackInfo<Value>& args) {
  DoConnect(args, AF_INET6);
}",1,1,udp_wrap.cc,node.UDPWrap.Connect6,,false,382,384,Connect6,,,23,void node.UDPWrap.Connect6 (FunctionCallbackInfo<Value>)
299407,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"void UDPWrap::Disconnect(const FunctionCallbackInfo<Value>& args) {
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK_EQ(args.Length(), 0);

  int err = uv_udp_connect(&wrap->handle_, nullptr);

  args.GetReturnValue().Set(err);
}",1,1,udp_wrap.cc,node.UDPWrap.Disconnect,,false,387,398,Disconnect,,,24,void node.UDPWrap.Disconnect (FunctionCallbackInfo<Value>)
299451,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"void UDPWrap::SetMulticastInterface(const FunctionCallbackInfo<Value>& args) {
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());

  Utf8Value iface(args.GetIsolate(), args[0]);

  const char* iface_cstr = *iface;

  int err = uv_udp_set_multicast_interface(&wrap->handle_, iface_cstr);
  args.GetReturnValue().Set(err);
}",1,1,udp_wrap.cc,node.UDPWrap.SetMulticastInterface,,false,400,415,SetMulticastInterface,,,25,void node.UDPWrap.SetMulticastInterface (FunctionCallbackInfo<Value>)
299516,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"void UDPWrap::SetMembership(const FunctionCallbackInfo<Value>& args,
                            uv_membership membership) {
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK_EQ(args.Length(), 2);

  node::Utf8Value address(args.GetIsolate(), args[0]);
  node::Utf8Value iface(args.GetIsolate(), args[1]);

  const char* iface_cstr = *iface;
  if (args[1]->IsUndefined() || args[1]->IsNull()) {
      iface_cstr = nullptr;
  }

  int err = uv_udp_set_membership(&wrap->handle_,
                                  *address,
                                  iface_cstr,
                                  membership);
  args.GetReturnValue().Set(err);
}",1,1,udp_wrap.cc,node.UDPWrap.SetMembership,,false,417,439,SetMembership,,,26,"void node.UDPWrap.SetMembership (FunctionCallbackInfo<Value>,uv_membership)"
299605,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"void UDPWrap::AddMembership(const FunctionCallbackInfo<Value>& args) {
  SetMembership(args, UV_JOIN_GROUP);
}",1,1,udp_wrap.cc,node.UDPWrap.AddMembership,,false,442,444,AddMembership,,,27,void node.UDPWrap.AddMembership (FunctionCallbackInfo<Value>)
299613,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"void UDPWrap::DropMembership(const FunctionCallbackInfo<Value>& args) {
  SetMembership(args, UV_LEAVE_GROUP);
}",1,1,udp_wrap.cc,node.UDPWrap.DropMembership,,false,447,449,DropMembership,,,28,void node.UDPWrap.DropMembership (FunctionCallbackInfo<Value>)
299621,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"void UDPWrap::SetSourceMembership(const FunctionCallbackInfo<Value>& args,
                                  uv_membership membership) {
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK_EQ(args.Length(), 3);

  node::Utf8Value source_address(args.GetIsolate(), args[0]);
  node::Utf8Value group_address(args.GetIsolate(), args[1]);
  node::Utf8Value iface(args.GetIsolate(), args[2]);

  if (*iface == nullptr) return;
  const char* iface_cstr = *iface;
  if (args[2]->IsUndefined() || args[2]->IsNull()) {
    iface_cstr = nullptr;
  }

  int err = uv_udp_set_source_membership(&wrap->handle_,
                                         *group_address,
                                         iface_cstr,
                                         *source_address,
                                         membership);
  args.GetReturnValue().Set(err);
}",1,1,udp_wrap.cc,node.UDPWrap.SetSourceMembership,,false,451,476,SetSourceMembership,,,29,"void node.UDPWrap.SetSourceMembership (FunctionCallbackInfo<Value>,uv_membership)"
299728,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"void UDPWrap::AddSourceSpecificMembership(
  const FunctionCallbackInfo<Value>& args) {
  SetSourceMembership(args, UV_JOIN_GROUP);
}",1,1,udp_wrap.cc,node.UDPWrap.AddSourceSpecificMembership,,false,478,481,AddSourceSpecificMembership,,,30,void node.UDPWrap.AddSourceSpecificMembership (FunctionCallbackInfo<Value>)
299736,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"void UDPWrap::DropSourceSpecificMembership(
  const FunctionCallbackInfo<Value>& args) {
  SetSourceMembership(args, UV_LEAVE_GROUP);
}",1,1,udp_wrap.cc,node.UDPWrap.DropSourceSpecificMembership,,false,484,487,DropSourceSpecificMembership,,,31,void node.UDPWrap.DropSourceSpecificMembership (FunctionCallbackInfo<Value>)
299744,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"void UDPWrap::DoSend(const FunctionCallbackInfo<Value>& args, int family) {
  Environment* env = Environment::GetCurrent(args);

  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK(args.Length() == 4 || args.Length() == 6);
  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsArray());
  CHECK(args[2]->IsUint32());

  bool sendto = args.Length() == 6;
  if (sendto) {
    // send(req, list, list.length, port, address, hasCallback)
    CHECK(args[3]->IsUint32());
    CHECK(args[4]->IsString());
    CHECK(args[5]->IsBoolean());
  } else {
    // send(req, list, list.length, hasCallback)
    CHECK(args[3]->IsBoolean());
  }

  Local<Array> chunks = args[1].As<Array>();
  // it is faster to fetch the length of the
  // array in js-land
  size_t count = args[2].As<Uint32>()->Value();

  MaybeStackBuffer<uv_buf_t, 16> bufs(count);

  // construct uv_buf_t array
  for (size_t i = 0; i...",1,1,udp_wrap.cc,node.UDPWrap.DoSend,,false,490,554,DoSend,,,32,"void node.UDPWrap.DoSend (FunctionCallbackInfo<Value>,int)"
300056,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"ssize_t UDPWrap::Send(uv_buf_t* bufs_ptr,
                      size_t count,
                      const sockaddr* addr) {
  if (IsHandleClosing()) return UV_EBADF;

  size_t msg_size = 0;
  for (size_t i = 0; i < count; i++)
    msg_size += bufs_ptr[i].len;

  int err = 0;
  if (!UNLIKELY(env()->options()->test_udp_no_try_send)) {
    err = uv_udp_try_send(&handle_, bufs_ptr, count, addr);
    if (err == UV_ENOSYS || err == UV_EAGAIN) {
      err = 0;
    } else if (err >= 0) {
      size_t sent = err;
      while (count > 0 && bufs_ptr->len <= sent) {
        sent -= bufs_ptr->len;
        bufs_ptr++;
        count--;
      }
      if (count > 0) {
        CHECK_LT(sent, bufs_ptr->len);
        bufs_ptr->base += sent;
        bufs_ptr->len -= sent;
      } else {
        CHECK_EQ(static_cast<size_t>(err), msg_size);
        // + 1 so that the JS side can distinguish 0-length async sends from
        // 0-length sync sends.
        return msg_size + 1;
      }
    }
  }

  if (err...",1,1,udp_wrap.cc,node.UDPWrap.Send,,false,556,611,Send,,,33,"ssize_t node.UDPWrap.Send (uv_buf_t*,size_t,sockaddr*)"
300235,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"ReqWrap<uv_udp_send_t>* UDPWrap::CreateSendWrap(size_t msg_size) {
  SendWrap* req_wrap = new SendWrap(env(),
                                    current_send_req_wrap_,
                                    current_send_has_callback_);
  req_wrap->msg_size = msg_size;
  return req_wrap;
}",1,1,udp_wrap.cc,node.UDPWrap.CreateSendWrap,,false,614,620,CreateSendWrap,,,34,ReqWrap<uv_udp_send_t> node.UDPWrap.CreateSendWrap (size_t)
300255,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"void UDPWrap::Send(const FunctionCallbackInfo<Value>& args) {
  DoSend(args, AF_INET);
}",1,1,udp_wrap.cc,node.UDPWrap.Send,,false,623,625,Send,,,35,void node.UDPWrap.Send (FunctionCallbackInfo<Value>)
300263,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"void UDPWrap::Send6(const FunctionCallbackInfo<Value>& args) {
  DoSend(args, AF_INET6);
}",1,1,udp_wrap.cc,node.UDPWrap.Send6,,false,628,630,Send6,,,36,void node.UDPWrap.Send6 (FunctionCallbackInfo<Value>)
300271,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"AsyncWrap* UDPWrap::GetAsyncWrap() {
  return this;
}",1,1,udp_wrap.cc,node.UDPWrap.GetAsyncWrap,,false,633,635,GetAsyncWrap,,,37,AsyncWrap node.UDPWrap.GetAsyncWrap ()
300277,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"SocketAddress UDPWrap::GetPeerName() {
  return SocketAddress::FromPeerName(handle_);
}",1,1,udp_wrap.cc,node.UDPWrap.GetPeerName,,false,637,639,GetPeerName,,,38,SocketAddress node.UDPWrap.GetPeerName ()
300287,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"SocketAddress UDPWrap::GetSockName() {
  return SocketAddress::FromSockName(handle_);
}",1,1,udp_wrap.cc,node.UDPWrap.GetSockName,,false,641,643,GetSockName,,,39,SocketAddress node.UDPWrap.GetSockName ()
300297,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"void UDPWrapBase::RecvStart(const FunctionCallbackInfo<Value>& args) {
  UDPWrapBase* wrap = UDPWrapBase::FromObject(args.Holder());
  args.GetReturnValue().Set(wrap == nullptr ? UV_EBADF : wrap->RecvStart());
}",1,1,udp_wrap.cc,node.UDPWrapBase.RecvStart,,false,645,648,RecvStart,,,40,void node.UDPWrapBase.RecvStart (FunctionCallbackInfo<Value>)
300329,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"int UDPWrap::RecvStart() {
  if (IsHandleClosing()) return UV_EBADF;
  int err = uv_udp_recv_start(&handle_, OnAlloc, OnRecv);
  // UV_EALREADY means that the socket is already bound but that's okay
  if (err == UV_EALREADY)
    err = 0;
  return err;
}",1,1,udp_wrap.cc,node.UDPWrap.RecvStart,,false,650,657,RecvStart,,,41,int node.UDPWrap.RecvStart ()
300356,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"void UDPWrapBase::RecvStop(const FunctionCallbackInfo<Value>& args) {
  UDPWrapBase* wrap = UDPWrapBase::FromObject(args.Holder());
  args.GetReturnValue().Set(wrap == nullptr ? UV_EBADF : wrap->RecvStop());
}",1,1,udp_wrap.cc,node.UDPWrapBase.RecvStop,,false,660,663,RecvStop,,,42,void node.UDPWrapBase.RecvStop (FunctionCallbackInfo<Value>)
300388,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"int UDPWrap::RecvStop() {
  if (IsHandleClosing()) return UV_EBADF;
  return uv_udp_recv_stop(&handle_);
}",1,1,udp_wrap.cc,node.UDPWrap.RecvStop,,false,665,668,RecvStop,,,43,int node.UDPWrap.RecvStop ()
300401,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"void UDPWrap::OnSendDone(ReqWrap<uv_udp_send_t>* req, int status) {
  BaseObjectPtr<SendWrap> req_wrap{static_cast<SendWrap*>(req)};
  if (req_wrap->have_callback()) {
    Environment* env = req_wrap->env();
    HandleScope handle_scope(env->isolate());
    Context::Scope context_scope(env->context());
    Local<Value> arg[] = {
      Integer::New(env->isolate(), status),
      Integer::New(env->isolate(), req_wrap->msg_size),
    };
    req_wrap->MakeCallback(env->oncomplete_string(), 2, arg);
  }
}",1,1,udp_wrap.cc,node.UDPWrap.OnSendDone,,false,671,683,OnSendDone,,,44,"void node.UDPWrap.OnSendDone (ReqWrap<uv_udp_send_t>*,int)"
300475,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"void UDPWrap::OnAlloc(uv_handle_t* handle,
                      size_t suggested_size,
                      uv_buf_t* buf) {
  UDPWrap* wrap = ContainerOf(&UDPWrap::handle_,
                              reinterpret_cast<uv_udp_t*>(handle));
  *buf = wrap->listener()->OnAlloc(suggested_size);
}",1,1,udp_wrap.cc,node.UDPWrap.OnAlloc,,false,686,692,OnAlloc,,,45,"void node.UDPWrap.OnAlloc (uv_handle_t*,size_t,uv_buf_t*)"
300504,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"uv_buf_t UDPWrap::OnAlloc(size_t suggested_size) {
  return env()->allocate_managed_buffer(suggested_size);
}",1,1,udp_wrap.cc,node.UDPWrap.OnAlloc,,false,694,696,OnAlloc,,,46,uv_buf_t node.UDPWrap.OnAlloc (size_t)
300515,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"void UDPWrap::OnRecv(uv_udp_t* handle,
                     ssize_t nread,
                     const uv_buf_t* buf,
                     const sockaddr* addr,
                     unsigned int flags) {
  UDPWrap* wrap = ContainerOf(&UDPWrap::handle_, handle);
  wrap->listener()->OnRecv(nread, *buf, addr, flags);
}",1,1,udp_wrap.cc,node.UDPWrap.OnRecv,,false,698,705,OnRecv,,,47,"void node.UDPWrap.OnRecv (uv_udp_t*,ssize_t,uv_buf_t*,sockaddr*,unsigned int)"
300545,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"void UDPWrap::OnRecv(ssize_t nread,
                     const uv_buf_t& buf_,
                     const sockaddr* addr,
                     unsigned int flags) {
  Environment* env = this->env();
  Isolate* isolate = env->isolate();
  std::unique_ptr<BackingStore> bs = env->release_managed_buffer(buf_);
  if (nread == 0 && addr == nullptr) {
    return;
  }

  HandleScope handle_scope(isolate);
  Context::Scope context_scope(env->context());

  Local<Value> argv[] = {
      Integer::New(isolate, static_cast<int32_t>(nread)),
      object(),
      Undefined(isolate),
      Undefined(isolate)};

  if (nread < 0) {
    MakeCallback(env->onmessage_string(), arraysize(argv), argv);
    return;
  } else if (nread == 0) {
    bs = ArrayBuffer::NewBackingStore(isolate, 0);
  } else {
    CHECK_LE(static_cast<size_t>(nread), bs->ByteLength());
    bs = BackingStore::Reallocate(isolate, std::move(bs), nread);
  }

  Local<Object> address;
  {
    bool has_caught = false;
    {
      TryCat...",1,1,udp_wrap.cc,node.UDPWrap.OnRecv,,false,707,777,OnRecv,,,48,"void node.UDPWrap.OnRecv (ssize_t,uv_buf_t,sockaddr*,unsigned int)"
300852,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"MaybeLocal<Object> UDPWrap::Instantiate(Environment* env,
                                        AsyncWrap* parent,
                                        UDPWrap::SocketType type) {
  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(parent);

  // If this assert fires then Initialize hasn't been called yet.
  CHECK_EQ(env->udp_constructor_function().IsEmpty(), false);
  return env->udp_constructor_function()->NewInstance(env->context());
}",1,1,udp_wrap.cc,node.UDPWrap.Instantiate,,false,779,787,Instantiate,,,49,"MaybeLocal<Object> node.UDPWrap.Instantiate (Environment*,AsyncWrap*,ANY)"
300883,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"void UDPWrap::GetSendQueueSize(const FunctionCallbackInfo<Value>& args) {
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(
      &wrap, args.Holder(), args.GetReturnValue().Set(UV_EBADF));

  size_t size = uv_udp_get_send_queue_size(&wrap->handle_);
  args.GetReturnValue().Set(static_cast<double>(size));
}",1,1,udp_wrap.cc,node.UDPWrap.GetSendQueueSize,,false,789,796,GetSendQueueSize,,,50,void node.UDPWrap.GetSendQueueSize (FunctionCallbackInfo<Value>)
300922,METHOD,udp_wrap.cc:<global>,TYPE_DECL,"void UDPWrap::GetSendQueueCount(const FunctionCallbackInfo<Value>& args) {
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(
      &wrap, args.Holder(), args.GetReturnValue().Set(UV_EBADF));

  size_t count = uv_udp_get_send_queue_count(&wrap->handle_);
  args.GetReturnValue().Set(static_cast<double>(count));
}",1,1,udp_wrap.cc,node.UDPWrap.GetSendQueueCount,,false,798,805,GetSendQueueCount,,,51,void node.UDPWrap.GetSendQueueCount (FunctionCallbackInfo<Value>)
300975,METHOD,udp_wrap.hpp:<global>,TYPE_DECL,<global>,1,26,udp_wrap.hpp,udp_wrap.hpp:<global>,,false,1,227,<global>,,,1,
300980,METHOD,undici_version.hpp:<global>,TYPE_DECL,<global>,1,32,undici_version.hpp,undici_version.hpp:<global>,,false,1,6,<global>,,,1,
300995,METHOD,util-inl.hpp:<global>,TYPE_DECL,<global>,1,26,util-inl.hpp,util-inl.hpp:<global>,,false,1,623,<global>,,,1,
300998,METHOD,util.cc:<global>,TYPE_DECL,"[&req]() {
    uv_fs_req_cleanup(&req);
  }",41,3,util.cc,node.ReadFileSync.<lambda>0,,false,235,237,<lambda>0,,,1,ANY node.ReadFileSync.<lambda>0 ()
301008,METHOD,util.cc:<global>,TYPE_DECL,"[file]() {
    uv_fs_t close_req;
    CHECK_EQ(0, uv_fs_close(nullptr, &close_req, file, nullptr));
    uv_fs_req_cleanup(&close_req);
  }",35,3,util.cc,node.ReadFileSync.<lambda>1,,false,246,250,<lambda>1,,,1,ANY node.ReadFileSync.<lambda>1 ()
301065,METHOD,util.cc:<global>,TYPE_DECL,<global>,1,1,util.cc,util.cc:<global>,,false,1,621,<global>,,,1,
301073,METHOD,util.cc:<global>,TYPE_DECL,"static void MakeUtf8String(Isolate* isolate,
                           Local<Value> value,
                           MaybeStackBuffer<T>* target) {
  Local<String> string;
  if (!value->ToString(isolate->GetCurrentContext()).ToLocal(&string)) return;

  size_t storage;
  if (!StringBytes::StorageSize(isolate, string, UTF8).To(&storage)) return;
  storage += 1;
  target->AllocateSufficientStorage(storage);
  const int flags =
      String::NO_NULL_TERMINATION | String::REPLACE_INVALID_UTF8;
  const int length =
      string->WriteUtf8(isolate, target->out(), storage, nullptr, flags);
  target->SetLengthAndZeroTerminate(length);
}",1,1,util.cc,node.MakeUtf8String,,false,69,84,MakeUtf8String,,,1,"void node.MakeUtf8String<T> (Isolate*,Local<Value>,MaybeStackBuffer<T>*)"
301157,METHOD,util.cc:<global>,TYPE_DECL,"Utf8Value::Utf8Value(Isolate* isolate, Local<Value> value) {
  if (value.IsEmpty())
    return;

  MakeUtf8String(isolate, value, this);
}",1,1,util.cc,node.Utf8Value.Utf8Value,,false,86,91,Utf8Value,,,2,"ANY node.Utf8Value.Utf8Value (Isolate*,Local<Value>)"
301174,METHOD,util.cc:<global>,TYPE_DECL,"TwoByteValue::TwoByteValue(Isolate* isolate, Local<Value> value) {
  if (value.IsEmpty()) {
    return;
  }

  Local<String> string;
  if (!value->ToString(isolate->GetCurrentContext()).ToLocal(&string)) return;

  // Allocate enough space to include the null terminator
  const size_t storage = string->Length() + 1;
  AllocateSufficientStorage(storage);

  const int flags = String::NO_NULL_TERMINATION;
  const int length = string->Write(isolate, out(), 0, storage, flags);
  SetLengthAndZeroTerminate(length);
}",1,1,util.cc,node.TwoByteValue.TwoByteValue,,false,94,109,TwoByteValue,,,3,"ANY node.TwoByteValue.TwoByteValue (Isolate*,Local<Value>)"
301240,METHOD,util.cc:<global>,TYPE_DECL,"BufferValue::BufferValue(Isolate* isolate, Local<Value> value) {
  // Slightly different take on Utf8Value. If value is a String,
  // it will return a Utf8 encoded string. If value is a Buffer,
  // it will copy the data out of the Buffer as is.
  if (value.IsEmpty()) {
    // Dereferencing this object will return nullptr.
    Invalidate();
    return;
  }

  if (value->IsString()) {
    MakeUtf8String(isolate, value, this);
  } else if (value->IsArrayBufferView()) {
    const size_t len = value.As<ArrayBufferView>()->ByteLength();
    // Leave place for the terminating '\0' byte.
    AllocateSufficientStorage(len + 1);
    value.As<ArrayBufferView>()->CopyContents(out(), len);
    SetLengthAndZeroTerminate(len);
  } else {
    Invalidate();
  }
}",1,1,util.cc,node.BufferValue.BufferValue,,false,111,132,BufferValue,,,4,"ANY node.BufferValue.BufferValue (Isolate*,Local<Value>)"
301300,METHOD,util.cc:<global>,TYPE_DECL,"void LowMemoryNotification() {
  if (per_process::v8_initialized) {
    auto isolate = Isolate::TryGetCurrent();
    if (isolate != nullptr) {
      isolate->LowMemoryNotification();
    }
  }
}",1,1,util.cc,node.LowMemoryNotification,,false,134,141,LowMemoryNotification,,,5,void node.LowMemoryNotification ()
301325,METHOD,util.cc:<global>,TYPE_DECL,"std::string GetProcessTitle(const char* default_title) {
  std::string buf(16, '\0');

  for (;;) {
    const int rc = uv_get_process_title(buf.data(), buf.size());

    if (rc == 0)
      break;

    // If uv_setup_args() was not called, `uv_get_process_title()` will always
    // return `UV_ENOBUFS`, no matter the input size. Guard against a possible
    // infinite loop by limiting the buffer size.
    if (rc != UV_ENOBUFS || buf.size() >= 1024 * 1024)
      return default_title;

    buf.resize(2 * buf.size());
  }

  // Strip excess trailing nul bytes. Using strlen() here is safe,
  // uv_get_process_title() always zero-terminates the result.
  buf.resize(strlen(buf.data()));

  return buf;
}",1,1,util.cc,node.GetProcessTitle,,false,143,166,GetProcessTitle,,,6,string node.GetProcessTitle (char*)
301392,METHOD,util.cc:<global>,TYPE_DECL,"std::string GetHumanReadableProcessName() {
  return SPrintF(""%s[%d]"", GetProcessTitle(""Node.js""), uv_os_getpid());
}",1,1,util.cc,node.GetHumanReadableProcessName,,false,168,170,GetHumanReadableProcessName,,,7,string node.GetHumanReadableProcessName ()
301402,METHOD,util.cc:<global>,TYPE_DECL,"std::vector<std::string_view> SplitString(const std::string_view in,
                                          const std::string_view delim) {
  std::vector<std::string_view> out;

  for (auto first = in.data(), second = in.data(), last = first + in.size();
       second != last && first != last;
       first = second + 1) {
    second =
        std::find_first_of(first, last, std::cbegin(delim), std::cend(delim));

    if (first != second) {
      out.emplace_back(first, second - first);
    }
  }

  return out;
}",1,1,util.cc,node.SplitString,,false,172,188,SplitString,,,8,"vector<std::string_view> node.SplitString (ANY,ANY)"
301488,METHOD,util.cc:<global>,TYPE_DECL,"void ThrowErrStringTooLong(Isolate* isolate) {
  isolate->ThrowException(ERR_STRING_TOO_LONG(isolate));
}",1,1,util.cc,node.ThrowErrStringTooLong,,false,190,192,ThrowErrStringTooLong,,,9,void node.ThrowErrStringTooLong (Isolate*)
301499,METHOD,util.cc:<global>,TYPE_DECL,"double GetCurrentTimeInMicroseconds() {
  constexpr double kMicrosecondsPerSecond = 1e6;
  uv_timeval64_t tv;
  CHECK_EQ(0, uv_gettimeofday(&tv));
  return kMicrosecondsPerSecond * tv.tv_sec + tv.tv_usec;
}",1,1,util.cc,node.GetCurrentTimeInMicroseconds,,false,194,199,GetCurrentTimeInMicroseconds,,,10,double node.GetCurrentTimeInMicroseconds ()
301523,METHOD,util.cc:<global>,TYPE_DECL,"int WriteFileSync(const char* path, uv_buf_t buf) {
  uv_fs_t req;
  int fd = uv_fs_open(nullptr,
                      &req,
                      path,
                      O_WRONLY | O_CREAT | O_TRUNC,
                      S_IWUSR | S_IRUSR,
                      nullptr);
  uv_fs_req_cleanup(&req);
  if (fd < 0) {
    return fd;
  }

  int err = uv_fs_write(nullptr, &req, fd, &buf, 1, 0, nullptr);
  uv_fs_req_cleanup(&req);
  if (err < 0) {
    return err;
  }

  err = uv_fs_close(nullptr, &req, fd, nullptr);
  uv_fs_req_cleanup(&req);
  return err;
}",1,1,util.cc,node.WriteFileSync,,false,201,223,WriteFileSync,,,11,"int node.WriteFileSync (char*,uv_buf_t)"
301593,METHOD,util.cc:<global>,TYPE_DECL,"int WriteFileSync(v8::Isolate* isolate,
                  const char* path,
                  v8::Local<v8::String> string) {
  node::Utf8Value utf8(isolate, string);
  uv_buf_t buf = uv_buf_init(utf8.out(), utf8.length());
  return WriteFileSync(path, buf);
}",1,1,util.cc,node.WriteFileSync,,false,225,231,WriteFileSync,,,12,"int node.WriteFileSync (ANY*,char*,ANY)"
301620,METHOD,util.cc:<global>,TYPE_DECL,"int ReadFileSync(std::string* result, const char* path) {
  uv_fs_t req;
  auto defer_req_cleanup = OnScopeLeave([&req]() {
    uv_fs_req_cleanup(&req);
  });

  uv_file file = uv_fs_open(nullptr, &req, path, O_RDONLY, 0, nullptr);
  if (req.result < 0) {
    // req will be cleaned up by scope leave.
    return req.result;
  }
  uv_fs_req_cleanup(&req);

  auto defer_close = OnScopeLeave([file]() {
    uv_fs_t close_req;
    CHECK_EQ(0, uv_fs_close(nullptr, &close_req, file, nullptr));
    uv_fs_req_cleanup(&close_req);
  });

  *result = std::string("""");
  char buffer[4096];
  uv_buf_t buf = uv_buf_init(buffer, sizeof(buffer));

  while (true) {
    const int r =
        uv_fs_read(nullptr, &req, file, &buf, 1, result->length(), nullptr);
    if (req.result < 0) {
      // req will be cleaned up by scope leave.
      return req.result;
    }
    uv_fs_req_cleanup(&req);
    if (r <= 0) {
      break;
    }
    result->append(buf.base, r);
  }
  return 0;
}",1,1,util.cc,node.ReadFileSync,,false,233,270,ReadFileSync,,,13,"int node.ReadFileSync (ANY*,char*)"
301725,METHOD,util.cc:<global>,TYPE_DECL,"std::vector<char> ReadFileSync(FILE* fp) {
  CHECK_EQ(ftell(fp), 0);
  int err = fseek(fp, 0, SEEK_END);
  CHECK_EQ(err, 0);
  size_t size = ftell(fp);
  CHECK_NE(size, static_cast<size_t>(-1L));
  err = fseek(fp, 0, SEEK_SET);
  CHECK_EQ(err, 0);

  std::vector<char> contents(size);
  size_t num_read = fread(contents.data(), size, 1, fp);
  CHECK_EQ(num_read, 1);
  return contents;
}",1,1,util.cc,node.ReadFileSync,,false,272,285,ReadFileSync,,,14,vector<char> node.ReadFileSync (FILE*)
301783,METHOD,util.cc:<global>,TYPE_DECL,"void DiagnosticFilename::LocalTime(TIME_TYPE* tm_struct) {
#ifdef _WIN32
  GetLocalTime(tm_struct);
#else  // UNIX, OSX
  struct timeval time_val;
  gettimeofday(&time_val, nullptr);
  localtime_r(&time_val.tv_sec, tm_struct);
#endif
}",1,1,util.cc,node.DiagnosticFilename.LocalTime,,false,287,295,LocalTime,,,15,void node.DiagnosticFilename.LocalTime (TIME_TYPE*)
301799,METHOD,util.cc:<global>,TYPE_DECL,"std::string DiagnosticFilename::MakeFilename(
    uint64_t thread_id,
    const char* prefix,
    const char* ext) {
  std::ostringstream oss;
  TIME_TYPE tm_struct;
  LocalTime(&tm_struct);
  oss << prefix;
#ifdef _WIN32
  oss << ""."" << std::setfill('0') << std::setw(4) << tm_struct.wYear;
  oss << std::setfill('0') << std::setw(2) << tm_struct.wMonth;
  oss << std::setfill('0') << std::setw(2) << tm_struct.wDay;
  oss << ""."" << std::setfill('0') << std::setw(2) << tm_struct.wHour;
  oss << std::setfill('0') << std::setw(2) << tm_struct.wMinute;
  oss << std::setfill('0') << std::setw(2) << tm_struct.wSecond;
#else  // UNIX, OSX
  oss << "".""
            << std::setfill('0')
            << std::setw(4)
            << tm_struct.tm_year + 1900;
  oss << std::setfill('0')
            << std::setw(2)
            << tm_struct.tm_mon + 1;
  oss << std::setfill('0')
            << std::setw(2)
            << tm_struct.tm_mday;
  oss << "".""
            << std::setfill('0')
            << st...",1,1,util.cc,node.DiagnosticFilename.MakeFilename,,false,298,340,MakeFilename,,,16,"string node.DiagnosticFilename.MakeFilename (uint64_t,char*,char*)"
301962,METHOD,util.cc:<global>,TYPE_DECL,"Local<v8::FunctionTemplate> NewFunctionTemplate(
    v8::Isolate* isolate,
    v8::FunctionCallback callback,
    Local<v8::Signature> signature,
    v8::ConstructorBehavior behavior,
    v8::SideEffectType side_effect_type,
    const v8::CFunction* c_function) {
  return v8::FunctionTemplate::New(isolate,
                                   callback,
                                   Local<v8::Value>(),
                                   signature,
                                   0,
                                   behavior,
                                   side_effect_type,
                                   c_function);
}",1,1,util.cc,node.NewFunctionTemplate,,false,342,357,NewFunctionTemplate,,,17,"Local<v8::FunctionTemplate> node.NewFunctionTemplate (ANY*,ANY,ANY,ANY,ANY,ANY*)"
301988,METHOD,util.cc:<global>,TYPE_DECL,"void SetMethod(Local<v8::Context> context,
               Local<v8::Object> that,
               const char* name,
               v8::FunctionCallback callback) {
  Isolate* isolate = context->GetIsolate();
  Local<v8::Function> function =
      NewFunctionTemplate(isolate,
                          callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasSideEffect)
          ->GetFunction(context)
          .ToLocalChecked();
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->Set(context, name_string, function).Check();
  function->SetName(name_string);  // NODE_SET_METHOD() compatibility.
}",1,1,util.cc,node.SetMethod,,false,359,378,SetMethod,,,18,"void node.SetMethod (ANY,ANY,char*,ANY)"
302076,METHOD,util.cc:<global>,TYPE_DECL,"void SetMethod(v8::Isolate* isolate,
               v8::Local<v8::Template> that,
               const char* name,
               v8::FunctionCallback callback) {
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasSideEffect);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->Set(name_string, t);
}",1,1,util.cc,node.SetMethod,,false,380,395,SetMethod,,,19,"void node.SetMethod (ANY*,ANY,char*,ANY)"
302141,METHOD,util.cc:<global>,TYPE_DECL,"void SetFastMethod(Isolate* isolate,
                   Local<Template> that,
                   const char* name,
                   v8::FunctionCallback slow_callback,
                   const v8::CFunction* c_function) {
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          slow_callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasSideEffect,
                          c_function);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->Set(name_string, t);
}",1,1,util.cc,node.SetFastMethod,,false,397,414,SetFastMethod,,,20,"void node.SetFastMethod (Isolate*,Local<Template>,char*,ANY,ANY*)"
302208,METHOD,util.cc:<global>,TYPE_DECL,"void SetFastMethod(Local<v8::Context> context,
                   Local<v8::Object> that,
                   const char* name,
                   v8::FunctionCallback slow_callback,
                   const v8::CFunction* c_function) {
  Isolate* isolate = context->GetIsolate();
  Local<v8::Function> function =
      NewFunctionTemplate(isolate,
                          slow_callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasSideEffect,
                          c_function)
          ->GetFunction(context)
          .ToLocalChecked();
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->Set(context, name_string, function).Check();
}",1,1,util.cc,node.SetFastMethod,,false,416,435,SetFastMethod,,,21,"void node.SetFastMethod (ANY,ANY,char*,ANY,ANY*)"
302293,METHOD,util.cc:<global>,TYPE_DECL,"void SetFastMethodNoSideEffect(Local<v8::Context> context,
                               Local<v8::Object> that,
                               const char* name,
                               v8::FunctionCallback slow_callback,
                               const v8::CFunction* c_function) {
  Isolate* isolate = context->GetIsolate();
  Local<v8::Function> function =
      NewFunctionTemplate(isolate,
                          slow_callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasNoSideEffect,
                          c_function)
          ->GetFunction(context)
          .ToLocalChecked();
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->Set(context, name_string, function).Check();
}",1,1,util.cc,node.SetFastMethodNoSideEffect,,false,437,456,SetFastMethodNoSideEffect,,,22,"void node.SetFastMethodNoSideEffect (ANY,ANY,char*,ANY,ANY*)"
302378,METHOD,util.cc:<global>,TYPE_DECL,"void SetFastMethodNoSideEffect(Isolate* isolate,
                               Local<Template> that,
                               const char* name,
                               v8::FunctionCallback slow_callback,
                               const v8::CFunction* c_function) {
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          slow_callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasNoSideEffect,
                          c_function);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->Set(name_string, t);
}",1,1,util.cc,node.SetFastMethodNoSideEffect,,false,458,475,SetFastMethodNoSideEffect,,,23,"void node.SetFastMethodNoSideEffect (Isolate*,Local<Template>,char*,ANY,ANY*)"
302445,METHOD,util.cc:<global>,TYPE_DECL,"void SetMethodNoSideEffect(Local<v8::Context> context,
                           Local<v8::Object> that,
                           const char* name,
                           v8::FunctionCallback callback) {
  Isolate* isolate = context->GetIsolate();
  Local<v8::Function> function =
      NewFunctionTemplate(isolate,
                          callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasNoSideEffect)
          ->GetFunction(context)
          .ToLocalChecked();
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->Set(context, name_string, function).Check();
  function->SetName(name_string);  // NODE_SET_METHOD() compatibility.
}",1,1,util.cc,node.SetMethodNoSideEffect,,false,477,496,SetMethodNoSideEffect,,,24,"void node.SetMethodNoSideEffect (ANY,ANY,char*,ANY)"
302533,METHOD,util.cc:<global>,TYPE_DECL,"void SetMethodNoSideEffect(Isolate* isolate,
                           Local<v8::Template> that,
                           const char* name,
                           v8::FunctionCallback callback) {
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasNoSideEffect);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->Set(name_string, t);
}",1,1,util.cc,node.SetMethodNoSideEffect,,false,498,513,SetMethodNoSideEffect,,,25,"void node.SetMethodNoSideEffect (Isolate*,ANY,char*,ANY)"
302598,METHOD,util.cc:<global>,TYPE_DECL,"void SetProtoMethod(v8::Isolate* isolate,
                    Local<v8::FunctionTemplate> that,
                    const char* name,
                    v8::FunctionCallback callback) {
  Local<v8::Signature> signature = v8::Signature::New(isolate, that);
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          callback,
                          signature,
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasSideEffect);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->PrototypeTemplate()->Set(name_string, t);
  t->SetClassName(name_string);  // NODE_SET_PROTOTYPE_METHOD() compatibility.
}",1,1,util.cc,node.SetProtoMethod,,false,515,532,SetProtoMethod,,,26,"void node.SetProtoMethod (ANY*,ANY,char*,ANY)"
302686,METHOD,util.cc:<global>,TYPE_DECL,"void SetProtoMethodNoSideEffect(v8::Isolate* isolate,
                                Local<v8::FunctionTemplate> that,
                                const char* name,
                                v8::FunctionCallback callback) {
  Local<v8::Signature> signature = v8::Signature::New(isolate, that);
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          callback,
                          signature,
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasNoSideEffect);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->PrototypeTemplate()->Set(name_string, t);
  t->SetClassName(name_string);  // NODE_SET_PROTOTYPE_METHOD() compatibility.
}",1,1,util.cc,node.SetProtoMethodNoSideEffect,,false,534,551,SetProtoMethodNoSideEffect,,,27,"void node.SetProtoMethodNoSideEffect (ANY*,ANY,char*,ANY)"
302774,METHOD,util.cc:<global>,TYPE_DECL,"void SetInstanceMethod(v8::Isolate* isolate,
                       Local<v8::FunctionTemplate> that,
                       const char* name,
                       v8::FunctionCallback callback) {
  Local<v8::Signature> signature = v8::Signature::New(isolate, that);
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          callback,
                          signature,
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasSideEffect);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->InstanceTemplate()->Set(name_string, t);
  t->SetClassName(name_string);
}",1,1,util.cc,node.SetInstanceMethod,,false,553,570,SetInstanceMethod,,,28,"void node.SetInstanceMethod (ANY*,ANY,char*,ANY)"
302862,METHOD,util.cc:<global>,TYPE_DECL,"void SetConstructorFunction(Local<v8::Context> context,
                            Local<v8::Object> that,
                            const char* name,
                            Local<v8::FunctionTemplate> tmpl,
                            SetConstructorFunctionFlag flag) {
  Isolate* isolate = context->GetIsolate();
  SetConstructorFunction(
      context, that, OneByteString(isolate, name), tmpl, flag);
}",1,1,util.cc,node.SetConstructorFunction,,false,572,580,SetConstructorFunction,,,29,"void node.SetConstructorFunction (ANY,ANY,char*,ANY,SetConstructorFunctionFlag)"
302886,METHOD,util.cc:<global>,TYPE_DECL,"void SetConstructorFunction(Local<Context> context,
                            Local<Object> that,
                            Local<String> name,
                            Local<FunctionTemplate> tmpl,
                            SetConstructorFunctionFlag flag) {
  if (LIKELY(flag == SetConstructorFunctionFlag::SET_CLASS_NAME))
    tmpl->SetClassName(name);
  that->Set(context, name, tmpl->GetFunction(context).ToLocalChecked()).Check();
}",1,1,util.cc,node.SetConstructorFunction,,false,582,590,SetConstructorFunction,,,30,"void node.SetConstructorFunction (Local<Context>,Local<Object>,Local<String>,Local<FunctionTemplate>,SetConstructorFunctionFlag)"
302925,METHOD,util.cc:<global>,TYPE_DECL,"void SetConstructorFunction(Isolate* isolate,
                            Local<Template> that,
                            const char* name,
                            Local<FunctionTemplate> tmpl,
                            SetConstructorFunctionFlag flag) {
  SetConstructorFunction(
      isolate, that, OneByteString(isolate, name), tmpl, flag);
}",1,1,util.cc,node.SetConstructorFunction,,false,592,599,SetConstructorFunction,,,31,"void node.SetConstructorFunction (Isolate*,Local<Template>,char*,Local<FunctionTemplate>,SetConstructorFunctionFlag)"
302942,METHOD,util.cc:<global>,TYPE_DECL,"void SetConstructorFunction(Isolate* isolate,
                            Local<Template> that,
                            Local<String> name,
                            Local<FunctionTemplate> tmpl,
                            SetConstructorFunctionFlag flag) {
  if (LIKELY(flag == SetConstructorFunctionFlag::SET_CLASS_NAME))
    tmpl->SetClassName(name);
  that->Set(name, tmpl);
}",1,1,util.cc,node.SetConstructorFunction,,false,601,609,SetConstructorFunction,,,32,"void node.SetConstructorFunction (Isolate*,Local<Template>,Local<String>,Local<FunctionTemplate>,SetConstructorFunctionFlag)"
302970,METHOD,util.cc:<global>,TYPE_DECL,"Local<String> UnionBytes::ToStringChecked(Isolate* isolate) const {
  if (is_one_byte()) {
    return String::NewExternalOneByte(isolate, one_byte_resource_)
        .ToLocalChecked();
  } else {
    return String::NewExternalTwoByte(isolate, two_byte_resource_)
        .ToLocalChecked();
  }
}",1,1,util.cc,node.UnionBytes.ToStringChecked,,false,611,619,ToStringChecked,,,33,Local<String> node.UnionBytes.ToStringChecked (Isolate*)
303039,METHOD,util.hpp:<global>,TYPE_DECL,<global>,1,22,util.hpp,util.hpp:<global>,,false,1,971,<global>,,,1,
303054,METHOD,uv.cc:<global>,TYPE_DECL,<global>,1,18,uv.cc,uv.cc:<global>,,false,1,141,<global>,,,1,
303070,METHOD,uv.cc:<global>,TYPE_DECL,"void ErrName(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  if (env->options()->pending_deprecation && env->EmitErrNameWarning()) {
    if (ProcessEmitDeprecationWarning(
        env,
        ""Directly calling process.binding('uv').errname(<val>) is being""
        "" deprecated. ""
        ""Please make sure to use util.getSystemErrorName() instead."",
        ""DEP0119"").IsNothing())
    return;
  }
  int err;
  if (!args[0]->Int32Value(env->context()).To(&err)) return;
  CHECK_LT(err, 0);
  char name[50];
  uv_err_name_r(err, name, sizeof(name));
  args.GetReturnValue().Set(OneByteString(env->isolate(), name));
}",1,1,uv.cc,node.uv.ErrName,,false,62,79,ErrName,,,1,void node.uv.ErrName (FunctionCallbackInfo<Value>)
303148,METHOD,uv.cc:<global>,TYPE_DECL,"void GetErrMap(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();

  // This can't return a SafeMap, because the uv binding can be referenced
  // by user code by using `process.binding('uv').getErrorMap()`:
  Local<Map> err_map = Map::New(isolate);

  size_t errors_len = arraysize(per_process::uv_errors_map);
  for (size_t i = 0; i < errors_len; ++i) {
    const auto& error = per_process::uv_errors_map[i];
    Local<Value> arr[] = {OneByteString(isolate, error.name),
                          OneByteString(isolate, error.message)};
    if (err_map
            ->Set(context,
                  Integer::New(isolate, error.value),
                  Array::New(isolate, arr, arraysize(arr)))
            .IsEmpty()) {
      return;
    }
  }

  args.GetReturnValue().Set(err_map);
}",1,1,uv.cc,node.uv.GetErrMap,,false,81,105,GetErrMap,,,2,void node.uv.GetErrMap (FunctionCallbackInfo<Value>)
303265,METHOD,uv.cc:<global>,TYPE_DECL,"void Initialize(Local<Object> target,
                Local<Value> unused,
                Local<Context> context,
                void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();
  SetConstructorFunction(
      context, target, ""errname"", NewFunctionTemplate(isolate, ErrName));

  // TODO(joyeecheung): This should be deprecated in user land in favor of
  // `util.getSystemErrorName(err)`.
  PropertyAttribute attributes =
      static_cast<PropertyAttribute>(ReadOnly | DontDelete);
  size_t errors_len = arraysize(per_process::uv_errors_map);
  const std::string prefix = ""UV_"";
  for (size_t i = 0; i < errors_len; ++i) {
    const auto& error = per_process::uv_errors_map[i];
    const std::string prefixed_name = prefix + error.name;
    Local<String> name = OneByteString(isolate, prefixed_name.c_str());
    Local<Integer> value = Integer::New(isolate, error.value);
    target->DefineOwnProperty(context, name, value, attributes)...",1,1,uv.cc,node.uv.Initialize,,false,107,131,Initialize,,,3,"void node.uv.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)"
303384,METHOD,uv.cc:<global>,TYPE_DECL,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(ErrName);
  registry->Register(GetErrMap);
}",1,1,uv.cc,node.uv.RegisterExternalReferences,,false,133,136,RegisterExternalReferences,,,4,void node.uv.RegisterExternalReferences (ExternalReferenceRegistry*)
307192,METHOD,<includes>:<global>,NAMESPACE_BLOCK,<global>,,,<includes>,<includes>:<global>,,false,1,,<global>,,,1,
307606,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CHECK_NOT_NULL,,true,,,CHECK_NOT_NULL,,,0,
307610,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.assignment,,true,,,<operator>.assignment,,,0,
307615,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EmitAsyncInit,,true,,,EmitAsyncInit,,,0,
307623,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EmitAsyncDestroy,,true,,,EmitAsyncDestroy,,,0,
307628,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.fieldAccess,,true,,,<operator>.fieldAccess,,,0,
307633,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isolate,,true,,,isolate,,,0,
307637,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.indirectFieldAccess,,true,,,<operator>.indirectFieldAccess,,,0,
307642,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AsyncResource.get_resource,,true,,,get_resource,,,0,
307645,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Get,,true,,,Get,,,0,
307651,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_stopping,,true,,,is_stopping,,,0,
307655,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MarkAsFailed,,true,,,MarkAsFailed,,,0,
307659,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,clear_async_id_stack,,true,,,clear_async_id_stack,,,0,
307663,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,async_hooks,,true,,,async_hooks,,,0,
307667,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetIdle,,true,,,SetIdle,,,0,
307672,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RunWeakRefCleanup,,true,,,RunWeakRefCleanup,,,0,
307676,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetVerbose,,true,,,SetVerbose,,,0,
307681,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HasCaught,,true,,,HasCaught,,,0,
307685,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.delete,,true,,,<operator>.delete,,,0,
307689,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PushAsyncCallbackScope,,true,,,PushAsyncCallbackScope,,,0,
307693,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.logicalNot,,true,,,<operator>.logicalNot,,,0,
307697,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,can_call_into_js,,true,,,can_call_into_js,,,0,
307701,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,handle_scope,,true,,,handle_scope,,,0,
307705,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.greaterThan,,true,,,<operator>.greaterThan,,,0,
307710,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.lessThan,,true,,,<operator>.lessThan,,,0,
307715,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetCurrentContext,,true,,,GetCurrentContext,,,0,
307719,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,UNLIKELY,,true,,,UNLIKELY,,,0,
307723,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.notEquals,,true,,,<operator>.notEquals,,,0,
307728,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,context,,true,,,context,,,0,
307732,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CHECK_EQ,,true,,,CHECK_EQ,,,0,
307737,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Environment.GetCurrent,,true,,,Environment.GetCurrent,,,0,
307742,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,push_async_context,,true,,,push_async_context,,,0,
307749,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.logicalAnd,,true,,,<operator>.logicalAnd,,,0,
307754,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AsyncWrap.EmitBefore,,true,,,AsyncWrap.EmitBefore,,,0,
307760,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Close,,true,,,Close,,,0,
307764,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PopAsyncCallbackScope,,true,,,PopAsyncCallbackScope,,,0,
307768,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,perform_stopping_check,,true,,,perform_stopping_check,,,0,
307771,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OnScopeLeave,,true,,,OnScopeLeave,,,0,
307775,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AsyncWrap.EmitAfter,,true,,,AsyncWrap.EmitAfter,,,0,
307781,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pop_async_context,,true,,,pop_async_context,,,0,
307786,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.logicalOr,,true,,,<operator>.logicalOr,,,0,
307791,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,async_callback_scope_depth,,true,,,async_callback_scope_depth,,,0,
307795,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tick_info,,true,,,tick_info,,,0,
307799,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,has_tick_scheduled,,true,,,has_tick_scheduled,,,0,
307803,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PerformCheckpoint,,true,,,PerformCheckpoint,,,0,
307808,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetMicrotaskQueue,,true,,,GetMicrotaskQueue,,,0,
307812,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.indirectIndexAccess,,true,,,<operator>.indirectIndexAccess,,,0,
307817,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fields,,true,,,fields,,,0,
307821,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,execution_async_id,,true,,,execution_async_id,,,0,
307825,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,trigger_async_id,,true,,,trigger_async_id,,,0,
307829,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,has_rejection_to_warn,,true,,,has_rejection_to_warn,,,0,
307833,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,process_object,,true,,,process_object,,,0,
307836,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tick_callback_function,,true,,,tick_callback_function,,,0,
307840,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CHECK,,true,,,CHECK,,,0,
307844,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsEmpty,,true,,,IsEmpty,,,0,
307848,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Call,,true,,,Call,,,0,
307856,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,async_hooks_callback_trampoline,,true,,,async_hooks_callback_trampoline,,,0,
307860,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.addition,,true,,,<operator>.addition,,,0,
307865,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,scope,,true,,,scope,,,0,
307869,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InternalCallbackScope.Failed,,true,,,Failed,,,0,
307873,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MaybeLocal<Value>,,true,,,MaybeLocal<Value>,,,0,
307876,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,args,,true,,,args,,,0,
307880,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.Number.New,,true,,,v8.Number.New,,,0,
307886,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.postIncrement,,true,,,<operator>.postIncrement,,,0,
307890,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,length,,true,,,length,,,0,
307894,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.addressOf,,true,,,<operator>.addressOf,,,0,
307898,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InternalCallbackScope.MarkAsFailed,,true,,,MarkAsFailed,,,0,
307902,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InternalCallbackScope.Close,,true,,,Close,,,0,
307906,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ToLocalChecked,,true,,,ToLocalChecked,,,0,
307910,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,String.NewFromUtf8,,true,,,String.NewFromUtf8,,,0,
307918,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MakeCallback,,true,,,MakeCallback,,,0,
307924,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetCreationContext,,true,,,GetCreationContext,,,0,
307928,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Local<Value>,,true,,,Local<Value>,,,0,
307931,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ToLocal,,true,,,ToLocal,,,0,
307936,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsFunction,,true,,,IsFunction,,,0,
307940,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Undefined,,true,,,Undefined,,,0,
307944,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<Function>,,true,,,As<Function>,,,0,
307948,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,context_scope,,true,,,context_scope,,,0,
307952,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InternalMakeCallback,,true,,,InternalMakeCallback,,,0,
307962,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.equals,,true,,,<operator>.equals,,,0,
307967,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,async_context,,true,,,async_context,,,0,
307971,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.arrayInitializer,,true,,,<operator>.arrayInitializer,,,0,
307976,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Escape,,true,,,Escape,,,0,
307981,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FromMaybe,,true,,,FromMaybe,,,0,
307986,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VerifyNoStrongBaseObjects,,true,,,VerifyNoStrongBaseObjects,,,0,
307990,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,push_back,,true,,,push_back,,,0,
307995,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FormatCaughtException,,true,,,FormatCaughtException,,,0,
308003,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CreateEnvironment,,true,,,CreateEnvironment,,,0,
308013,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isolate_data,,true,,,isolate_data,,,0,
308017,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.cast,,true,,,<operator>.cast,,,0,
308022,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.indirection,,true,,,<operator>.indirection,,,0,
308026,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetMultiIsolatePlatform,,true,,,GetMultiIsolatePlatform,,,0,
308030,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,seal,,true,,,seal,,,0,
308034,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Nothing<ExitCode>,,true,,,Nothing<ExitCode>,,,0,
308037,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_trace_sync_io,,true,,,set_trace_sync_io,,,0,
308042,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,options,,true,,,options,,,0,
308046,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Mark,,true,,,Mark,,,0,
308051,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,performance_state,,true,,,performance_state,,,0,
308055,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_run,,true,,,uv_run,,,0,
308060,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,event_loop,,true,,,event_loop,,,0,
308064,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DrainTasks,,true,,,DrainTasks,,,0,
308069,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_loop_alive,,true,,,uv_loop_alive,,,0,
308073,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsNothing,,true,,,IsNothing,,,0,
308077,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EmitProcessBeforeExit,,true,,,EmitProcessBeforeExit,,,0,
308081,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RunSnapshotSerializeCallback,,true,,,RunSnapshotSerializeCallback,,,0,
308085,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_snapshot_serialize_callback,,true,,,set_snapshot_serialize_callback,,,0,
308090,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Local<Function>,,true,,,Local<Function>,,,0,
308093,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PrintInfoForSnapshotIfDebug,,true,,,PrintInfoForSnapshotIfDebug,,,0,
308097,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ForEachRealm,,true,,,ForEachRealm,,,0,
308102,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EmitProcessExitInternal,,true,,,EmitProcessExitInternal,,,0,
308106,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_loop_init,,true,,,uv_loop_init,,,0,
308110,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SPrintF,,true,,,SPrintF,,,0,
308116,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_err_name,,true,,,uv_err_name,,,0,
308120,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.multiplication,,true,,,<operator>.multiplication,,,0,
308125,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.and,,true,,,<operator>.and,,,0,
308130,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SnapshotBuilder.CollectExternalReferences,,true,,,SnapshotBuilder.CollectExternalReferences,,,0,
308134,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Isolate.Allocate,,true,,,Isolate.Allocate,,,0,
308138,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RegisterIsolate,,true,,,RegisterIsolate,,,0,
308144,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,emplace,,true,,,emplace,,,0,
308149,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,data,,true,,,data,,,0,
308153,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetCaptureStackTraceForUncaughtExceptions,,true,,,SetCaptureStackTraceForUncaughtExceptions,,,0,
308158,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetIsolateMiscHandlers,,true,,,SetIsolateMiscHandlers,,,0,
308163,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ArrayBufferAllocator.Create,,true,,,ArrayBufferAllocator.Create,,,0,
308167,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NewIsolate,,true,,,NewIsolate,,,0,
308174,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,locker,,true,,,locker,,,0,
308178,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isolate_scope,,true,,,isolate_scope,,,0,
308182,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,bootstrapCatch,,true,,,bootstrapCatch,,,0,
308186,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,reset,,true,,,reset,,,0,
308191,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CreateIsolateData,,true,,,CreateIsolateData,,,0,
308199,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,get,,true,,,get,,,0,
308203,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_is_building_snapshot,,true,,,set_is_building_snapshot,,,0,
308208,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,has_value,,true,,,has_value,,,0,
308212,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,make_env,,true,,,make_env,,,0,
308216,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Reset,,true,,,Reset,,,0,
308221,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NewContext,,true,,,NewContext,,,0,
308225,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.or,,true,,,<operator>.or,,,0,
308230,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.new,,true,,,<operator>.new,,,0,
308237,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,empty,,true,,,empty,,,0,
308241,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddIsolateFinishedCallback,,true,,,AddIsolateFinishedCallback,,,0,
308248,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,UnregisterIsolate,,true,,,UnregisterIsolate,,,0,
308253,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Dispose,,true,,,Dispose,,,0,
308256,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckedUvLoopClose,,true,,,CheckedUvLoopClose,,,0,
308260,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CommonEnvironmentSetup.snapshot_creator,,true,,,snapshot_creator,,,0,
308263,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SnapshotBuilder.CreateSnapshot,,true,,,SnapshotBuilder.CreateSnapshot,,,0,
308270,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SpinEventLoopInternal,,true,,,SpinEventLoopInternal,,,0,
308274,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Nothing<int>,,true,,,Nothing<int>,,,0,
308277,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Just,,true,,,Just,,,0,
308281,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FromJust,,true,,,FromJust,,,0,
308285,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.conditional,,true,,,<operator>.conditional,,,0,
308291,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,value,,true,,,value,,,0,
308296,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CHECK_IMPLIES,,true,,,CHECK_IMPLIES,,,0,
308301,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EmbedderSnapshotData::Pointer,,true,,,EmbedderSnapshotData::Pointer,,,0,
308305,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SnapshotBuilder.GetEmbeddedSnapshotData,,true,,,SnapshotBuilder.GetEmbeddedSnapshotData,,,0,
308309,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SnapshotData.FromBlob,,true,,,SnapshotData.FromBlob,,,0,
308315,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FromBlob,,true,,,FromBlob,,,0,
308320,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReadFileSync,,true,,,ReadFileSync,,,0,
308324,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ToBlob,,true,,,ToBlob,,,0,
308327,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ToFile,,true,,,ToFile,,,0,
308332,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strncmp,,true,,,strncmp,,,0,
308338,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StringEqualNoCase,,true,,,StringEqualNoCase,,,0,
308343,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsString,,true,,,IsString,,,0,
308347,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,encoding,,true,,,encoding,,,0,
308351,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ParseEncoding,,true,,,ParseEncoding,,,0,
308356,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CHECK_NE,,true,,,CHECK_NE,,,0,
308361,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StringBytes.Encode,,true,,,StringBytes.Encode,,,0,
308370,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StringBytes.Size,,true,,,StringBytes.Size,,,0,
308377,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.minus,,true,,,<operator>.minus,,,0,
308381,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StringBytes.Write,,true,,,StringBytes.Write,,,0,
308390,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ToV8Value,,true,,,ToV8Value,,,0,
308395,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Null,,true,,,Null,,,0,
308399,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,movedHandler,,true,,,movedHandler,,,0,
308404,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetEmbedderData,,true,,,GetEmbedderData,,,0,
308409,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsUndefined,,true,,,IsUndefined,,,0,
308413,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsTrue,,true,,,IsTrue,,,0,
308417,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_main_thread,,true,,,is_main_thread,,,0,
308421,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,abort_on_uncaught_exception,,true,,,abort_on_uncaught_exception,,,0,
308425,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,should_abort_on_uncaught_toggle,,true,,,should_abort_on_uncaught_toggle,,,0,
308429,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,inside_should_not_abort_on_uncaught_scope,,true,,,inside_should_not_abort_on_uncaught_scope,,,0,
308433,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ToString,,true,,,ToString,,,0,
308438,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Realm.GetCurrent,,true,,,Realm.GetCurrent,,,0,
308443,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,prepare_stack_trace_callback,,true,,,prepare_stack_trace_callback,,,0,
308447,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,principal_realm,,true,,,principal_realm,,,0,
308451,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Global,,true,,,Global,,,0,
308455,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,try_catch,,true,,,try_catch,,,0,
308459,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,arraysize,,true,,,arraysize,,,0,
308463,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HasTerminated,,true,,,HasTerminated,,,0,
308467,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReThrow,,true,,,ReThrow,,,0,
308471,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Allocate,,true,,,Allocate,,,0,
308476,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AllocateUninitialized,,true,,,AllocateUninitialized,,,0,
308481,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LIKELY,,true,,,LIKELY,,,0,
308485,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fetch_add,,true,,,fetch_add,,,0,
308491,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Reallocate,,true,,,Reallocate,,,0,
308498,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.subtraction,,true,,,<operator>.subtraction,,,0,
308503,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fetch_sub,,true,,,fetch_sub,,,0,
308509,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Free,,true,,,Free,,,0,
308515,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lock,,true,,,lock,,,0,
308519,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NodeArrayBufferAllocator.Allocate,,true,,,NodeArrayBufferAllocator.Allocate,,,0,
308524,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RegisterPointerInternal,,true,,,RegisterPointerInternal,,,0,
308529,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NodeArrayBufferAllocator.AllocateUninitialized,,true,,,NodeArrayBufferAllocator.AllocateUninitialized,,,0,
308534,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,UnregisterPointerInternal,,true,,,UnregisterPointerInternal,,,0,
308539,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NodeArrayBufferAllocator.Free,,true,,,NodeArrayBufferAllocator.Free,,,0,
308545,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NodeArrayBufferAllocator.Reallocate,,true,,,NodeArrayBufferAllocator.Reallocate,,,0,
308552,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,find,,true,,,find,,,0,
308558,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,end,,true,,,end,,,0,
308562,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,erase,,true,,,erase,,,0,
308567,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NodeArrayBufferAllocator.RegisterPointer,,true,,,NodeArrayBufferAllocator.RegisterPointer,,,0,
308573,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NodeArrayBufferAllocator.UnregisterPointer,,true,,,NodeArrayBufferAllocator.UnregisterPointer,,,0,
308579,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,count,,true,,,count,,,0,
308584,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.make_unique<DebuggingArrayBufferAllocator>,,true,,,std.make_unique<DebuggingArrayBufferAllocator>,,,0,
308588,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.make_unique<NodeArrayBufferAllocator>,,true,,,std.make_unique<NodeArrayBufferAllocator>,,,0,
308592,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,release,,true,,,release,,,0,
308596,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_get_constrained_memory,,true,,,uv_get_constrained_memory,,,0,
308599,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.min,,true,,,std.min,,,0,
308605,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_get_total_memory,,true,,,uv_get_total_memory,,,0,
308608,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,max_old_generation_size_in_bytes,,true,,,max_old_generation_size_in_bytes,,,0,
308612,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ConfigureDefaults,,true,,,ConfigureDefaults,,,0,
308618,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.numeric_limits<int>.max,,true,,,std.numeric_limits<int>.max,,,0,
308622,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddMessageListenerWithErrorLevel,,true,,,AddMessageListenerWithErrorLevel,,,0,
308628,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetAbortOnUncaughtExceptionCallback,,true,,,SetAbortOnUncaughtExceptionCallback,,,0,
308633,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetFatalErrorHandler,,true,,,SetFatalErrorHandler,,,0,
308638,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetOOMErrorHandler,,true,,,SetOOMErrorHandler,,,0,
308643,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetPrepareStackTraceCallback,,true,,,SetPrepareStackTraceCallback,,,0,
308648,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetMicrotasksPolicy,,true,,,SetMicrotasksPolicy,,,0,
308653,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetAllowWasmCodeGenerationCallback,,true,,,SetAllowWasmCodeGenerationCallback,,,0,
308658,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetModifyCodeGenerationFromStringsCallback,,true,,,SetModifyCodeGenerationFromStringsCallback,,,0,
308663,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,get_per_env_options,,true,,,get_per_env_options,,,0,
308667,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,get_per_isolate_options,,true,,,get_per_isolate_options,,,0,
308671,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetWasmStreamingCallback,,true,,,SetWasmStreamingCallback,,,0,
308676,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetHostCreateShadowRealmContextCallback,,true,,,SetHostCreateShadowRealmContextCallback,,,0,
308681,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetPromiseRejectCallback,,true,,,SetPromiseRejectCallback,,,0,
308686,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.CpuProfiler.UseDetailedSourcePositionsForProfiling,,true,,,v8.CpuProfiler.UseDetailedSourcePositionsForProfiling,,,0,
308691,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetIsolateErrorHandlers,,true,,,SetIsolateErrorHandlers,,,0,
308696,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetIsolateUpForNode,,true,,,SetIsolateUpForNode,,,0,
308700,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SnapshotBuilder.InitializeIsolateParams,,true,,,SnapshotBuilder.InitializeIsolateParams,,,0,
308706,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetIsolateCreateParamsForNode,,true,,,SetIsolateCreateParamsForNode,,,0,
308710,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Isolate.Initialize,,true,,,Isolate.Initialize,,,0,
308716,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SnapshotData.FromEmbedderWrapper,,true,,,SnapshotData.FromEmbedderWrapper,,,0,
308721,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,snapshot_data,,true,,,snapshot_data,,,0,
308725,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Context.FromSnapshot,,true,,,Context.FromSnapshot,,,0,
308731,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InitializeContextRuntime,,true,,,InitializeContextRuntime,,,0,
308735,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FreeEnvironment,,true,,,FreeEnvironment,,,0,
308739,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InitializeMainContext,,true,,,InitializeMainContext,,,0,
308745,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RunBootstrapping,,true,,,RunBootstrapping,,,0,
308749,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,disallow_js,,true,,,disallow_js,,,0,
308754,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,seal_handle_scope,,true,,,seal_handle_scope,,,0,
308758,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_can_call_into_js,,true,,,set_can_call_into_js,,,0,
308763,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_stopping,,true,,,set_stopping,,,0,
308767,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,stop_sub_worker_contexts,,true,,,stop_sub_worker_contexts,,,0,
308771,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RunCleanup,,true,,,RunCleanup,,,0,
308774,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RunAtExit,,true,,,RunAtExit,,,0,
308778,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,platform,,true,,,platform,,,0,
308782,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetInspectorParentHandle,,true,,,GetInspectorParentHandle,,,0,
308789,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,should_create_inspector,,true,,,should_create_inspector,,,0,
308793,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InitializeLibuv,,true,,,InitializeLibuv,,,0,
308797,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InitializeDiagnostics,,true,,,InitializeDiagnostics,,,0,
308801,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StartExecution,,true,,,StartExecution,,,0,
308806,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LoadEnvironment,,true,,,LoadEnvironment,,,0,
308811,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node_allocator,,true,,,node_allocator,,,0,
308815,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CreatePlatform,,true,,,CreatePlatform,,,0,
308820,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.bracketedPrimary,,true,,,<operator>.bracketedPrimary,,,0,
308824,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.expressionList,,true,,,<operator>.expressionList,,,0,
308829,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetIsolate,,true,,,GetIsolate,,,0,
308833,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Private.ForApi,,true,,,Private.ForApi,,,0,
308839,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FIXED_ONE_BYTE_STRING,,true,,,FIXED_ONE_BYTE_STRING,,,0,
308844,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetPrivate,,true,,,GetPrivate,,,0,
308850,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MaybeLocal<Object>,,true,,,MaybeLocal<Object>,,,0,
308853,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsObject,,true,,,IsObject,,,0,
308857,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<Object>,,true,,,As<Object>,,,0,
308861,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Object.New,,true,,,Object.New,,,0,
308866,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetPrivate,,true,,,SetPrivate,,,0,
308873,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InitializePrimordials,,true,,,InitializePrimordials,,,0,
308877,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Context.New,,true,,,Context.New,,,0,
308882,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InitializeContext,,true,,,InitializeContext,,,0,
308886,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Local<Context>,,true,,,Local<Context>,,,0,
308889,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_PROTO_ACCESS,,true,,,THROW_ERR_PROTO_ACCESS,,,0,
308893,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsCodeGenerationFromStringsAllowed,,true,,,IsCodeGenerationFromStringsAllowed,,,0,
308897,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AllowCodeGenerationFromStrings,,true,,,AllowCodeGenerationFromStrings,,,0,
308902,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetEmbedderData,,true,,,SetEmbedderData,,,0,
308908,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Boolean.New,,true,,,Boolean.New,,,0,
308914,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Nothing<bool>,,true,,,Nothing<bool>,,,0,
308917,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Delete,,true,,,Delete,,,0,
308923,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.New,,true,,,Function.New,,,0,
308929,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,descriptor,,true,,,descriptor,,,0,
308934,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_enumerable,,true,,,set_enumerable,,,0,
308939,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_configurable,,true,,,set_configurable,,,0,
308944,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DefineProperty,,true,,,DefineProperty,,,0,
308951,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OnFatalError,,true,,,OnFatalError,,,0,
308956,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,True,,true,,,True,,,0,
308960,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InitializeBaseContextForSnapshot,,true,,,InitializeBaseContextForSnapshot,,,0,
308964,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetPrototype,,true,,,SetPrototype,,,0,
308970,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetPerContextExports,,true,,,GetPerContextExports,,,0,
308974,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Set,,true,,,Set,,,0,
308979,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CompileAndCall,,true,,,CompileAndCall,,,0,
308986,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InitializeMainContextForSnapshot,,true,,,InitializeMainContextForSnapshot,,,0,
308990,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,extra_linked_bindings_mutex,,true,,,extra_linked_bindings_mutex,,,0,
308994,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,extra_linked_bindings_tail,,true,,,extra_linked_bindings_tail,,,0,
308998,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,extra_linked_bindings,,true,,,extra_linked_bindings,,,0,
309002,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,back,,true,,,back,,,0,
309006,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,napi_module_to_node_module,,true,,,napi_module_to_node_module,,,0,
309010,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddLinkedBinding,,true,,,AddLinkedBinding,,,0,
309015,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_version.hpp,node_version.hpp:92:92:NODE_MODULE_VERSION:0,,true,92,92,NODE_MODULE_VERSION,,,0,
309018,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ThreadId,,true,,,ThreadId,,,0,
309022,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,exit,,true,,,exit,,,0,
309026,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DumpAndResetStats,,true,,,DumpAndResetStats,,,0,
309030,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StopTracingAgent,,true,,,StopTracingAgent,,,0,
309034,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_library_shutdown,,true,,,uv_library_shutdown,,,0,
309037,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DisposePlatform,,true,,,DisposePlatform,,,0,
309040,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Exit,,true,,,Exit,,,0,
309045,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DefaultProcessExitHandlerInternal,,true,,,DefaultProcessExitHandlerInternal,,,0,
309050,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_process_exit_handler,,true,,,set_process_exit_handler,,,0,
309055,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.move,,true,,,std.move,,,0,
309060,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OneByteString,,true,,,OneByteString,,,0,
309065,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,errors.errno_string,,true,,,errors.errno_string,,,0,
309070,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strerror,,true,,,strerror,,,0,
309074,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,String.Concat,,true,,,String.Concat,,,0,
309081,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Exception.Error,,true,,,Exception.Error,,,0,
309086,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Check,,true,,,Check,,,0,
309090,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,errno_string,,true,,,errno_string,,,0,
309094,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Integer.New,,true,,,Integer.New,,,0,
309100,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,code_string,,true,,,code_string,,,0,
309104,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,path_string,,true,,,path_string,,,0,
309108,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,syscall_string,,true,,,syscall_string,,,0,
309112,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_strerror,,true,,,uv_strerror,,,0,
309116,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StringFromPath,,true,,,StringFromPath,,,0,
309121,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ToObject,,true,,,ToObject,,,0,
309126,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dest_string,,true,,,dest_string,,,0,
309130,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,errors.TriggerUncaughtException,,true,,,errors.TriggerUncaughtException,,,0,
309138,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fun,,true,,,fun,,,0,
309145,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RunAtExitCallbacks,,true,,,RunAtExitCallbacks,,,0,
309149,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AtExit,,true,,,AtExit,,,0,
309155,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,USE,,true,,,USE,,,0,
309159,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TRACE_EVENT0,,true,,,TRACE_EVENT0,,,0,
309164,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TRACING_CATEGORY_NODE1,,true,,,TRACING_CATEGORY_NODE1,,,0,
309168,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,destroy_async_id_list,,true,,,destroy_async_id_list,,,0,
309172,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AsyncWrap.DestroyAsyncIdsCallback,,true,,,AsyncWrap.DestroyAsyncIdsCallback,,,0,
309177,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,exit_code,,true,,,exit_code,,,0,
309182,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProcessEmit,,true,,,ProcessEmit,,,0,
309188,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EmitExitInternal,,true,,,EmitExitInternal,,,0,
309192,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_exiting,,true,,,set_exiting,,,0,
309196,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddCleanupHook,,true,,,AddCleanupHook,,,0,
309202,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RemoveCleanupHook,,true,,,RemoveCleanupHook,,,0,
309208,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DecreaseWaitingRequestCounter,,true,,,DecreaseWaitingRequestCounter,,,0,
309212,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IncreaseWaitingRequestCounter,,true,,,IncreaseWaitingRequestCounter,,,0,
309216,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.make_shared<AsyncCleanupHookInfo>,,true,,,std.make_shared<AsyncCleanupHookInfo>,,,0,
309220,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RequestInterrupt,,true,,,RequestInterrupt,,,0,
309225,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,get_default_trigger_async_id,,true,,,get_default_trigger_async_id,,,0,
309229,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,new_async_id,,true,,,new_async_id,,,0,
309233,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AsyncWrap.EmitAsyncInit,,true,,,AsyncWrap.EmitAsyncInit,,,0,
309242,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AsyncWrap.EmitDestroy,,true,,,AsyncWrap.EmitDestroy,,,0,
309248,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,api\utils.cc,api\utils.cc:8:10:SIGNO_CASE:1,,true,8,10,SIGNO_CASE,,,0,
309251,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DestroyAsyncIdsCallback,,true,,,DestroyAsyncIdsCallback,,,0,
309255,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EnqueueMicrotask,,true,,,EnqueueMicrotask,,,0,
309261,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NODE_ASYNC_PROVIDER_TYPES,,true,,,NODE_ASYNC_PROVIDER_TYPES,,,0,
309265,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,async_hooks_destroy_function,,true,,,async_hooks_destroy_function,,,0,
309269,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,swap,,true,,,swap,,,0,
309274,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Number.New,,true,,,Number.New,,,0,
309280,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Emit,,true,,,Emit,,,0,
309287,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,async_hooks_promise_resolve_function,,true,,,async_hooks_promise_resolve_function,,,0,
309291,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,provider_type,,true,,,provider_type,,,0,
309294,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,UNREACHABLE,,true,,,UNREACHABLE,,,0,
309298,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,async_hooks_before_function,,true,,,async_hooks_before_function,,,0,
309302,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,async_hooks_after_function,,true,,,async_hooks_after_function,,,0,
309306,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,async_hooks_init_function,,true,,,async_hooks_init_function,,,0,
309310,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,async_wrap.cc,async_wrap.cc:168:176:SET_HOOK_FN:1,,true,168,176,SET_HOOK_FN,,,0,
309313,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SET_HOOK_FN(init),,true,,,SET_HOOK_FN(init),,,0,
309317,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SET_HOOK_FN(before),,true,,,SET_HOOK_FN(before),,,0,
309321,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SET_HOOK_FN(after),,true,,,SET_HOOK_FN(after),,,0,
309325,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SET_HOOK_FN(destroy),,true,,,SET_HOOK_FN(destroy),,,0,
309329,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SET_HOOK_FN(promise_resolve),,true,,,SET_HOOK_FN(promise_resolve),,,0,
309333,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ResetPromiseHooks,,true,,,ResetPromiseHooks,,,0,
309341,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,p,,true,,,p,,,0,
309345,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetParameter,,true,,,GetParameter,,,0,
309349,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PersistentToLocal.Default,,true,,,PersistentToLocal.Default,,,0,
309355,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,destroyed_string,,true,,,destroyed_string,,,0,
309359,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsFalse,,true,,,IsFalse,,,0,
309363,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsNumber,,true,,,IsNumber,,,0,
309367,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Length,,true,,,Length,,,0,
309371,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Value,,true,,,Value,,,0,
309375,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<Number>,,true,,,As<Number>,,,0,
309379,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetWeak,,true,,,SetWeak,,,0,
309383,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetReturnValue,,true,,,GetReturnValue,,,0,
309387,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSIGN_OR_RETURN_UNWRAP,,true,,,ASSIGN_OR_RETURN_UNWRAP,,,0,
309393,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Holder,,true,,,Holder,,,0,
309397,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,get_async_id,,true,,,get_async_id,,,0,
309400,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NumberValue,,true,,,NumberValue,,,0,
309405,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,To,,true,,,To,,,0,
309410,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Uint32Value,,true,,,Uint32Value,,,0,
309415,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,native_execution_async_resource,,true,,,native_execution_async_resource,,,0,
309420,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AsyncReset,,true,,,AsyncReset,,,0,
309425,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,env,,true,,,env,,,0,
309429,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,persistent,,true,,,persistent,,,0,
309432,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_async_hooks_callback_trampoline,,true,,,set_async_hooks_callback_trampoline,,,0,
309437,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,async_wrap_ctor_template,,true,,,async_wrap_ctor_template,,,0,
309441,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NewFunctionTemplate,,true,,,NewFunctionTemplate,,,0,
309446,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetClassName,,true,,,SetClassName,,,0,
309451,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetProtoMethod,,true,,,SetProtoMethod,,,0,
309458,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_async_wrap_ctor_template,,true,,,set_async_wrap_ctor_template,,,0,
309463,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetMethod,,true,,,SetMethod,,,0,
309470,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AsyncWrap.GetConstructorTemplate,,true,,,AsyncWrap.GetConstructorTemplate,,,0,
309475,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,async_wrap.cc,async_wrap.cc:382:386:FORCE_SET_TARGET_FIELD:3,,true,382,386,FORCE_SET_TARGET_FIELD,,,0,
309479,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FORCE_SET_TARGET_FIELD(target,
                         ""async_hook_fields"",
                         env->async_hooks()->fields().GetJSArray())",,true,,,"FORCE_SET_TARGET_FIELD(target,
                         ""async_hook_fields"",
                         env->async_hooks()->fields().GetJSArray())",,,0,
309483,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FORCE_SET_TARGET_FIELD(target,
                         ""async_id_fields"",
                         env->async_hooks()->async_id_fields().GetJSArray())",,true,,,"FORCE_SET_TARGET_FIELD(target,
                         ""async_id_fields"",
                         env->async_hooks()->async_id_fields().GetJSArray())",,,0,
309487,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FORCE_SET_TARGET_FIELD(target,
                         ""execution_async_resources"",
                         env->async_hooks()->js_execution_async_resources())",,true,,,"FORCE_SET_TARGET_FIELD(target,
                         ""execution_async_resources"",
                         env->async_hooks()->js_execution_async_resources())",,,0,
309491,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,async_ids_stack_string,,true,,,async_ids_stack_string,,,0,
309495,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetJSArray,,true,,,GetJSArray,,,0,
309499,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,async_ids_stack,,true,,,async_ids_stack,,,0,
309503,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,async_wrap.cc,async_wrap.cc:419:421:SET_HOOKS_CONSTANT:1,,true,419,421,SET_HOOKS_CONSTANT,,,0,
309506,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SET_HOOKS_CONSTANT(kInit),,true,,,SET_HOOKS_CONSTANT(kInit),,,0,
309512,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SET_HOOKS_CONSTANT(kBefore),,true,,,SET_HOOKS_CONSTANT(kBefore),,,0,
309518,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SET_HOOKS_CONSTANT(kAfter),,true,,,SET_HOOKS_CONSTANT(kAfter),,,0,
309524,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SET_HOOKS_CONSTANT(kDestroy),,true,,,SET_HOOKS_CONSTANT(kDestroy),,,0,
309530,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SET_HOOKS_CONSTANT(kPromiseResolve),,true,,,SET_HOOKS_CONSTANT(kPromiseResolve),,,0,
309536,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SET_HOOKS_CONSTANT(kTotals),,true,,,SET_HOOKS_CONSTANT(kTotals),,,0,
309542,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SET_HOOKS_CONSTANT(kCheck),,true,,,SET_HOOKS_CONSTANT(kCheck),,,0,
309548,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SET_HOOKS_CONSTANT(kExecutionAsyncId),,true,,,SET_HOOKS_CONSTANT(kExecutionAsyncId),,,0,
309554,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SET_HOOKS_CONSTANT(kTriggerAsyncId),,true,,,SET_HOOKS_CONSTANT(kTriggerAsyncId),,,0,
309560,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SET_HOOKS_CONSTANT(kAsyncIdCounter),,true,,,SET_HOOKS_CONSTANT(kAsyncIdCounter),,,0,
309566,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SET_HOOKS_CONSTANT(kDefaultTriggerAsyncId),,true,,,SET_HOOKS_CONSTANT(kDefaultTriggerAsyncId),,,0,
309572,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SET_HOOKS_CONSTANT(kUsesExecutionAsyncResource),,true,,,SET_HOOKS_CONSTANT(kUsesExecutionAsyncResource),,,0,
309578,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SET_HOOKS_CONSTANT(kStackLength),,true,,,SET_HOOKS_CONSTANT(kStackLength),,,0,
309584,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FORCE_SET_TARGET_FIELD(target, ""constants"", constants)",,true,,,"FORCE_SET_TARGET_FIELD(target, ""constants"", constants)",,,0,
309592,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FORCE_SET_TARGET_FIELD(target, ""Providers"", async_providers)",,true,,,"FORCE_SET_TARGET_FIELD(target, ""Providers"", async_providers)",,,0,
309600,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NODE_ASYNC_PROVIDER_TYPES(V),,true,,,NODE_ASYNC_PROVIDER_TYPES(V),,,0,
309605,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_async_hooks_init_function,,true,,,set_async_hooks_init_function,,,0,
309610,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_async_hooks_before_function,,true,,,set_async_hooks_before_function,,,0,
309615,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_async_hooks_after_function,,true,,,set_async_hooks_after_function,,,0,
309620,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_async_hooks_destroy_function,,true,,,set_async_hooks_destroy_function,,,0,
309625,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_async_hooks_promise_resolve_function,,true,,,set_async_hooks_promise_resolve_function,,,0,
309630,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_async_hooks_binding,,true,,,set_async_hooks_binding,,,0,
309635,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Register,,true,,,Register,,,0,
309640,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EmitTraceEventDestroy,,true,,,EmitTraceEventDestroy,,,0,
309644,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EmitDestroy,,true,,,EmitDestroy,,,0,
309648,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetImmediate,,true,,,SetImmediate,,,0,
309653,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,size,,true,,,size,,,0,
309657,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,object,,true,,,object,,,0,
309660,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,resource_symbol,,true,,,resource_symbol,,,0,
309664,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,provider_string,,true,,,provider_string,,,0,
309669,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EmitTraceEventBefore,,true,,,EmitTraceEventBefore,,,0,
309672,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,get_trigger_async_id,,true,,,get_trigger_async_id,,,0,
309675,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EmitTraceEventAfter,,true,,,EmitTraceEventAfter,,,0,
309680,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetOwner,,true,,,GetOwner,,,0,
309684,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ignore_exceptions,,true,,,ignore_exceptions,,,0,
309688,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,owner_symbol,,true,,,owner_symbol,,,0,
309692,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,has_pointer_data,,true,,,has_pointer_data,,,0,
309696,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pointer_data,,true,,,pointer_data,,,0,
309700,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OnGCCollect,,true,,,OnGCCollect,,,0,
309703,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CHECK_GE,,true,,,CHECK_GE,,,0,
309708,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InternalFieldCount,,true,,,InternalFieldCount,,,0,
309712,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetInternalFields,,true,,,SetInternalFields,,,0,
309717,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,modify_base_object_count,,true,,,modify_base_object_count,,,0,
309722,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,realm,,true,,,realm,,,0,
309725,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetAlignedPointerInInternalField,,true,,,SetAlignedPointerInInternalField,,,0,
309731,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DCHECK,,true,,,DCHECK,,,0,
309735,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsConstructCall,,true,,,IsConstructCall,,,0,
309739,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,This,,true,,,This,,,0,
309743,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MakeLazilyInitializedJSTemplate,,true,,,MakeLazilyInitializedJSTemplate,,,0,
309747,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetInternalFieldCount,,true,,,SetInternalFieldCount,,,0,
309752,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InstanceTemplate,,true,,,InstanceTemplate,,,0,
309756,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsWeak,,true,,,IsWeak,,,0,
309760,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CHECK_GT,,true,,,CHECK_GT,,,0,
309765,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.preDecrement,,true,,,<operator>.preDecrement,,,0,
309769,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MakeWeak,,true,,,MakeWeak,,,0,
309772,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ClearWeak,,true,,,ClearWeak,,,0,
309775,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Detach,,true,,,Detach,,,0,
309779,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsWeakOrDetached,,true,,,IsWeakOrDetached,,,0,
309782,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_freeaddrinfo,,true,,,uv_freeaddrinfo,,,0,
309786,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_inet_ntop,,true,,,uv_inet_ntop,,,0,
309793,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.sizeOf,,true,,,<operator>.sizeOf,,,0,
309797,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ares_free_data,,true,,,ares_free_data,,,0,
309801,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.shiftLeft,,true,,,<operator>.shiftLeft,,,0,
309806,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ContainerOf,,true,,,ContainerOf,,,0,
309811,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_timer_again,,true,,,uv_timer_again,,,0,
309815,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,timer_handle,,true,,,timer_handle,,,0,
309818,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ares_process_fd,,true,,,ares_process_fd,,,0,
309824,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,cares_channel,,true,,,cares_channel,,,0,
309828,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,free_me,,true,,,free_me,,,0,
309832,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,task_list,,true,,,task_list,,,0,
309836,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StartTimer,,true,,,StartTimer,,,0,
309840,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NodeAresTask.Create,,true,,,NodeAresTask.Create,,,0,
309846,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,insert,,true,,,insert,,,0,
309852,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_poll_start,,true,,,uv_poll_start,,,0,
309858,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CloseHandle,,true,,,CloseHandle,,,0,
309864,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CloseTimer,,true,,,CloseTimer,,,0,
309867,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.arithmeticShiftRight,,true,,,<operator>.arithmeticShiftRight,,,0,
309872,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.preIncrement,,true,,,<operator>.preIncrement,,,0,
309876,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,emplace_back,,true,,,emplace_back,,,0,
309882,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Array.New,,true,,,Array.New,,,0,
309889,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ttls,,true,,,ttls,,,0,
309893,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Integer.NewFromUnsigned,,true,,,Integer.NewFromUnsigned,,,0,
309899,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,out,,true,,,out,,,0,
309903,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ares_parse_a_reply,,true,,,ares_parse_a_reply,,,0,
309911,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ares_parse_aaaa_reply,,true,,,ares_parse_aaaa_reply,,,0,
309919,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ares_parse_ns_reply,,true,,,ares_parse_ns_reply,,,0,
309925,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ares_parse_ptr_reply,,true,,,ares_parse_ptr_reply,,,0,
309934,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ptr,,true,,,ptr,,,0,
309938,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HostentToNames,,true,,,HostentToNames,,,0,
309943,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ares_parse_mx_reply,,true,,,ares_parse_mx_reply,,,0,
309949,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,exchange_string,,true,,,exchange_string,,,0,
309953,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,priority_string,,true,,,priority_string,,,0,
309957,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,type_string,,true,,,type_string,,,0,
309961,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dns_mx_string,,true,,,dns_mx_string,,,0,
309965,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ares_parse_caa_reply,,true,,,ares_parse_caa_reply,,,0,
309971,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dns_critical_string,,true,,,dns_critical_string,,,0,
309975,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dns_caa_string,,true,,,dns_caa_string,,,0,
309979,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ares_parse_txt_reply_ext,,true,,,ares_parse_txt_reply_ext,,,0,
309985,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,entries_string,,true,,,entries_string,,,0,
309989,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dns_txt_string,,true,,,dns_txt_string,,,0,
309993,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ares_parse_srv_reply,,true,,,ares_parse_srv_reply,,,0,
309999,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,name_string,,true,,,name_string,,,0,
310004,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,port_string,,true,,,port_string,,,0,
310008,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,weight_string,,true,,,weight_string,,,0,
310012,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dns_srv_string,,true,,,dns_srv_string,,,0,
310016,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ares_parse_naptr_reply,,true,,,ares_parse_naptr_reply,,,0,
310022,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,flags_string,,true,,,flags_string,,,0,
310026,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,service_string,,true,,,service_string,,,0,
310030,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,regexp_string,,true,,,regexp_string,,,0,
310034,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,replacement_string,,true,,,replacement_string,,,0,
310038,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,order_string,,true,,,order_string,,,0,
310042,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,preference_string,,true,,,preference_string,,,0,
310046,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dns_naptr_string,,true,,,dns_naptr_string,,,0,
310050,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,cares_get_16bit,,true,,,cares_get_16bit,,,0,
310054,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ares_expand_name,,true,,,ares_expand_name,,,0,
310062,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,name,,true,,,name,,,0,
310066,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.assignmentPlus,,true,,,<operator>.assignmentPlus,,,0,
310071,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,rr_name,,true,,,rr_name,,,0,
310075,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nsname,,true,,,nsname,,,0,
310079,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,hostmaster,,true,,,hostmaster,,,0,
310083,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReadUint32BE,,true,,,ReadUint32BE,,,0,
310087,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nsname_string,,true,,,nsname_string,,,0,
310091,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,hostmaster_string,,true,,,hostmaster_string,,,0,
310095,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,serial_string,,true,,,serial_string,,,0,
310099,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,refresh_string,,true,,,refresh_string,,,0,
310103,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,retry_string,,true,,,retry_string,,,0,
310107,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,expire_string,,true,,,expire_string,,,0,
310111,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,minttl_string,,true,,,minttl_string,,,0,
310115,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dns_soa_string,,true,,,dns_soa_string,,,0,
310119,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Setup,,true,,,Setup,,,0,
310122,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TrackField,,true,,,TrackField,,,0,
310128,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsInt32,,true,,,IsInt32,,,0,
310132,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<Int32>,,true,,,As<Int32>,,,0,
310136,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_poll_init_socket,,true,,,uv_poll_init_socket,,,0,
310142,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,memset,,true,,,memset,,,0,
310148,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ares_library_init,,true,,,ares_library_init,,,0,
310152,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ThrowError,,true,,,ThrowError,,,0,
310157,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ToErrorCodeString,,true,,,ToErrorCodeString,,,0,
310161,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ares_init_options,,true,,,ares_init_options,,,0,
310167,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ares_library_cleanup,,true,,,ares_library_cleanup,,,0,
310170,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_timer_init,,true,,,uv_timer_init,,,0,
310175,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_is_active,,true,,,uv_is_active,,,0,
310179,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_timer_start,,true,,,uv_timer_start,,,0,
310186,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ares_get_servers_ports,,true,,,ares_get_servers_ports,,,0,
310191,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,htonl,,true,,,htonl,,,0,
310195,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AresQuery,,true,,,AresQuery,,,0,
310202,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cares_wrap.cc,cares_wrap.cc:44:44:T_CAA:0,,true,44,44,T_CAA,,,0,
310205,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ParseGeneralReply,,true,,,ParseGeneralReply,,,0,
310213,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,address_string,,true,,,address_string,,,0,
310217,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ttl_string,,true,,,ttl_string,,,0,
310221,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dns_a_string,,true,,,dns_a_string,,,0,
310225,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,value_string,,true,,,value_string,,,0,
310229,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dns_cname_string,,true,,,dns_cname_string,,,0,
310233,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dns_aaaa_string,,true,,,dns_aaaa_string,,,0,
310237,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ParseMxReply,,true,,,ParseMxReply,,,0,
310244,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dns_ns_string,,true,,,dns_ns_string,,,0,
310248,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ParseTxtReply,,true,,,ParseTxtReply,,,0,
310255,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ParseSrvReply,,true,,,ParseSrvReply,,,0,
310262,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dns_ptr_string,,true,,,dns_ptr_string,,,0,
310266,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ParseNaptrReply,,true,,,ParseNaptrReply,,,0,
310273,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Local<Object>,,true,,,Local<Object>,,,0,
310276,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ParseSoaReply,,true,,,ParseSoaReply,,,0,
310283,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ParseCaaReply,,true,,,ParseCaaReply,,,0,
310290,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CallOnComplete,,true,,,CallOnComplete,,,0,
310295,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ares_parse_soa_reply,,true,,,ares_parse_soa_reply,,,0,
310301,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_inet_pton,,true,,,uv_inet_pton,,,0,
310307,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TRACE_EVENT_NESTABLE_ASYNC_BEGIN2,,true,,,TRACE_EVENT_NESTABLE_ASYNC_BEGIN2,,,0,
310317,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TRACING_CATEGORY_NODE2,,true,,,TRACING_CATEGORY_NODE2,,,0,
310322,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TRACE_STR_COPY,,true,,,TRACE_STR_COPY,,,0,
310326,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ares_gethostbyaddr,,true,,,ares_gethostbyaddr,,,0,
310335,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,channel,,true,,,channel,,,0,
310339,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MakeCallbackPointer,,true,,,MakeCallbackPointer,,,0,
310343,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<String>,,true,,,As<String>,,,0,
310347,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,utf8name,,true,,,utf8name,,,0,
310352,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ToStringView,,true,,,ToStringView,,,0,
310356,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ada.idna.to_ascii,,true,,,ada.idna.to_ascii,,,0,
310361,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ModifyActivityQueryCount,,true,,,ModifyActivityQueryCount,,,0,
310366,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Send,,true,,,Send,,,0,
310373,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,c_str,,true,,,c_str,,,0,
310377,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,req_wrap,,true,,,req_wrap,,,0,
310381,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,verbatim,,true,,,verbatim,,,0,
310385,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,add,,true,,,add,,,0,
310389,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TRACE_EVENT_NESTABLE_ASYNC_END2,,true,,,TRACE_EVENT_NESTABLE_ASYNC_END2,,,0,
310399,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,oncomplete_string,,true,,,oncomplete_string,,,0,
310403,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ip,,true,,,ip,,,0,
310408,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsBoolean,,true,,,IsBoolean,,,0,
310412,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,hostname,,true,,,hostname,,,0,
310417,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Dispatch,,true,,,Dispatch,,,0,
310427,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsUint32,,true,,,IsUint32,,,0,
310431,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_ip4_addr,,true,,,uv_ip4_addr,,,0,
310437,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_ip6_addr,,true,,,uv_ip6_addr,,,0,
310443,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,active_query_count,,true,,,active_query_count,,,0,
310447,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsArray,,true,,,IsArray,,,0,
310451,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<Array>,,true,,,As<Array>,,,0,
310455,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ares_set_servers,,true,,,ares_set_servers,,,0,
310460,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,servers,,true,,,servers,,,0,
310464,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Int32Value,,true,,,Int32Value,,,0,
310469,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ares_set_servers_ports,,true,,,ares_set_servers_ports,,,0,
310474,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_is_servers_default,,true,,,set_is_servers_default,,,0,
310479,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ip0,,true,,,ip0,,,0,
310484,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ares_set_local_ip4,,true,,,ares_set_local_ip4,,,0,
310489,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ares_set_local_ip6,,true,,,ares_set_local_ip6,,,0,
310494,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_INVALID_ARG_VALUE,,true,,,THROW_ERR_INVALID_ARG_VALUE,,,0,
310499,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ip1,,true,,,ip1,,,0,
310504,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TRACE_EVENT_INSTANT0,,true,,,TRACE_EVENT_INSTANT0,,,0,
310510,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ares_cancel,,true,,,ares_cancel,,,0,
310514,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ares_strerror,,true,,,ares_strerror,,,0,
310518,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,free,,true,,,free,,,0,
310522,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetMethodNoSideEffect,,true,,,SetMethodNoSideEffect,,,0,
310529,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cares_wrap.cc,cares_wrap.cc:49:49:AI_ALL:0,,true,49,49,AI_ALL,,,0,
310532,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cares_wrap.cc,cares_wrap.cc:52:52:AI_V4MAPPED:0,,true,52,52,AI_V4MAPPED,,,0,
310535,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BaseObject.MakeLazilyInitializedJSTemplate,,true,,,BaseObject.MakeLazilyInitializedJSTemplate,,,0,
310540,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Inherit,,true,,,Inherit,,,0,
310545,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetConstructorFunction,,true,,,SetConstructorFunction,,,0,
310552,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetProtoMethodNoSideEffect,,true,,,SetProtoMethodNoSideEffect,,,0,
310559,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,callbacks,,true,,,callbacks,,,0,
310564,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,begin,,true,,,begin,,,0,
310568,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.sort,,true,,,std.sort,,,0,
310575,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetOrdered,,true,,,GetOrdered,,,0,
310578,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fn_,,true,,,fn_,,,0,
310582,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.hash<void*>(),,true,,,std.hash<void*>(),,,0,
310587,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.hash<void*>,,true,,,std.hash<void*>,,,0,
310591,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WrapType.Instantiate,,true,,,WrapType.Instantiate,,,0,
310598,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_accept,,true,,,uv_accept,,,0,
310603,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,onconnection_string,,true,,,onconnection_string,,,0,
310607,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_is_readable,,true,,,uv_is_readable,,,0,
310611,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_is_writable,,true,,,uv_is_writable,,,0,
310615,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TRACE_EVENT_NESTABLE_ASYNC_END1,,true,,,TRACE_EVENT_NESTABLE_ASYNC_END1,,,0,
310623,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetKeyType,,true,,,GetKeyType,,,0,
310627,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_CIPHER_mode,,true,,,EVP_CIPHER_mode,,,0,
310631,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ctx,,true,,,ctx,,,0,
310635,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_CIPHER_CTX_new,,true,,,EVP_CIPHER_CTX_new,,,0,
310638,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_CIPHER_CTX_init,,true,,,EVP_CIPHER_CTX_init,,,0,
310642,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_CIPHER_CTX_set_flags,,true,,,EVP_CIPHER_CTX_set_flags,,,0,
310647,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_CipherInit_ex,,true,,,EVP_CipherInit_ex,,,0,
310656,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_CIPHER_CTX_ctrl,,true,,,EVP_CIPHER_CTX_ctrl,,,0,
310663,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_CIPHER_CTX_set_key_length,,true,,,EVP_CIPHER_CTX_set_key_length,,,0,
310668,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetSymmetricKeySize,,true,,,GetSymmetricKeySize,,,0,
310672,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetSymmetricKey,,true,,,GetSymmetricKey,,,0,
310676,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,data<unsigned char>,,true,,,data<unsigned char>,,,0,
310680,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,data<char>,,true,,,data<char>,,,0,
310684,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_CIPHER_CTX_block_size,,true,,,EVP_CIPHER_CTX_block_size,,,0,
310688,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_CipherUpdate,,true,,,EVP_CipherUpdate,,,0,
310696,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,buf,,true,,,buf,,,0,
310701,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CHECK_LE,,true,,,CHECK_LE,,,0,
310706,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_CipherFinal_ex,,true,,,EVP_CipherFinal_ex,,,0,
310712,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.division,,true,,,<operator>.division,,,0,
310717,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.modulo,,true,,,<operator>.modulo,,,0,
310722,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BignumPointer,,true,,,BignumPointer,,,0,
310726,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BN_bin2bn,,true,,,BN_bin2bn,,,0,
310732,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CeilDiv,,true,,,CeilDiv,,,0,
310737,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,counter,,true,,,counter,,,0,
310742,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operators>.assignmentAnd,,true,,,<operators>.assignmentAnd,,,0,
310747,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.not,,true,,,<operator>.not,,,0,
310751,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,new_counter_block,,true,,,new_counter_block,,,0,
310756,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,front,,true,,,front,,,0,
310760,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,num_counters,,true,,,num_counters,,,0,
310764,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BN_new,,true,,,BN_new,,,0,
310767,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BN_lshift,,true,,,BN_lshift,,,0,
310773,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BN_value_one,,true,,,BN_value_one,,,0,
310776,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetCounter,,true,,,GetCounter,,,0,
310780,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,num_output,,true,,,num_output,,,0,
310784,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BN_set_word,,true,,,BN_set_word,,,0,
310789,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BN_cmp,,true,,,BN_cmp,,,0,
310794,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,remaining_until_reset,,true,,,remaining_until_reset,,,0,
310798,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BN_sub,,true,,,BN_sub,,,0,
310804,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.greaterEqualsThan,,true,,,<operator>.greaterEqualsThan,,,0,
310809,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AES_CTR_Cipher2,,true,,,AES_CTR_Cipher2,,,0,
310818,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BN_get_word,,true,,,BN_get_word,,,0,
310822,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ByteSource.Foreign,,true,,,ByteSource.Foreign,,,0,
310828,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BlockWithZeroedCounter,,true,,,BlockWithZeroedCounter,,,0,
310832,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,iv,,true,,,iv,,,0,
310836,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckSizeInt32,,true,,,CheckSizeInt32,,,0,
310840,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_OUT_OF_RANGE,,true,,,THROW_ERR_OUT_OF_RANGE,,,0,
310845,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ToCopy,,true,,,ToCopy,,,0,
310849,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ToByteSource,,true,,,ToByteSource,,,0,
310853,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<Uint32>,,true,,,As<Uint32>,,,0,
310857,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_CRYPTO_INVALID_COUNTER,,true,,,THROW_ERR_CRYPTO_INVALID_COUNTER,,,0,
310861,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsAnyByteSource,,true,,,IsAnyByteSource,,,0,
310865,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_CRYPTO_INVALID_TAG_LENGTH,,true,,,THROW_ERR_CRYPTO_INVALID_TAG_LENGTH,,,0,
310869,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tag_contents,,true,,,tag_contents,,,0,
310873,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,additional,,true,,,additional,,,0,
310877,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strlen,,true,,,strlen,,,0,
310881,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,~AESCipherConfig,,true,,,~AESCipherConfig,,,0,
310885,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TrackFieldWithSize,,true,,,TrackFieldWithSize,,,0,
310891,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValidateIV,,true,,,ValidateIV,,,0,
310898,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValidateCounter,,true,,,ValidateCounter,,,0,
310904,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,UseDefaultIV,,true,,,UseDefaultIV,,,0,
310908,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValidateAuthTag,,true,,,ValidateAuthTag,,,0,
310916,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValidateAdditionalData,,true,,,ValidateAdditionalData,,,0,
310923,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_get_cipherbynid,,true,,,EVP_get_cipherbynid,,,0,
310927,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_CRYPTO_UNKNOWN_CIPHER,,true,,,THROW_ERR_CRYPTO_UNKNOWN_CIPHER,,,0,
310931,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_CIPHER_iv_length,,true,,,EVP_CIPHER_iv_length,,,0,
310935,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_CRYPTO_INVALID_IV,,true,,,THROW_ERR_CRYPTO_INVALID_IV,,,0,
310939,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AESCryptoJob.Initialize,,true,,,AESCryptoJob.Initialize,,,0,
310945,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AESCryptoJob.RegisterExternalReferences,,true,,,AESCryptoJob.RegisterExternalReferences,,,0,
310950,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIO_meth_new,,true,,,BIO_meth_new,,,0,
310955,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIO_meth_set_write,,true,,,BIO_meth_set_write,,,0,
310960,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIO_meth_set_read,,true,,,BIO_meth_set_read,,,0,
310965,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIO_meth_set_puts,,true,,,BIO_meth_set_puts,,,0,
310970,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIO_meth_set_gets,,true,,,BIO_meth_set_gets,,,0,
310975,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIO_meth_set_ctrl,,true,,,BIO_meth_set_ctrl,,,0,
310980,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIO_meth_set_create,,true,,,BIO_meth_set_create,,,0,
310985,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIO_meth_set_destroy,,true,,,BIO_meth_set_destroy,,,0,
310990,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NodeBIO.FromBIO,,true,,,NodeBIO.FromBIO,,,0,
310995,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,New,,true,,,New,,,0,
311000,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIO_write,,true,,,BIO_write,,,0,
311006,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIO_set_mem_eof_return,,true,,,BIO_set_mem_eof_return,,,0,
311011,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIOPointer,,true,,,BIOPointer,,,0,
311014,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIO_set_data,,true,,,BIO_set_data,,,0,
311019,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIO_set_init,,true,,,BIO_set_init,,,0,
311024,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIO_get_shutdown,,true,,,BIO_get_shutdown,,,0,
311028,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIO_get_init,,true,,,BIO_get_init,,,0,
311032,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIO_get_data,,true,,,BIO_get_data,,,0,
311036,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FromBIO,,true,,,FromBIO,,,0,
311040,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIO_clear_retry_flags,,true,,,BIO_clear_retry_flags,,,0,
311044,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Read,,true,,,Read,,,0,
311049,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,eof_return,,true,,,eof_return,,,0,
311053,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIO_set_retry_read,,true,,,BIO_set_retry_read,,,0,
311057,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Write,,true,,,Write,,,0,
311066,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IndexOf,,true,,,IndexOf,,,0,
311072,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.postDecrement,,true,,,<operator>.postDecrement,,,0,
311076,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_eof_return,,true,,,set_eof_return,,,0,
311081,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIO_set_shutdown,,true,,,BIO_set_shutdown,,,0,
311086,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,memcpy,,true,,,memcpy,,,0,
311092,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.assignmentMinus,,true,,,<operator>.assignmentMinus,,,0,
311097,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TryMoveReadHead,,true,,,TryMoveReadHead,,,0,
311100,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FreeEmpty,,true,,,FreeEmpty,,,0,
311103,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TryAllocateForWrite,,true,,,TryAllocateForWrite,,,0,
311107,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.lessEqualsThan,,true,,,<operator>.lessEqualsThan,,,0,
311112,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Update,,true,,,Update,,,0,
311118,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ThrowCryptoError,,true,,,ThrowCryptoError,,,0,
311123,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ERR_get_error,,true,,,ERR_get_error,,,0,
311126,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ArrayBuffer.New,,true,,,ArrayBuffer.New,,,0,
311132,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Buffer.New,,true,,,Buffer.New,,,0,
311140,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ByteLength,,true,,,ByteLength,,,0,
311144,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_CIPHER_nid,,true,,,EVP_CIPHER_nid,,,0,
311148,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_CIPHER_CTX_cipher,,true,,,EVP_CIPHER_CTX_cipher,,,0,
311152,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsSupportedAuthenticatedMode,,true,,,IsSupportedAuthenticatedMode,,,0,
311156,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_get_cipherbyname,,true,,,EVP_get_cipherbyname,,,0,
311160,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_CIPHER_key_length,,true,,,EVP_CIPHER_key_length,,,0,
311164,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_CIPHER_block_size,,true,,,EVP_CIPHER_block_size,,,0,
311168,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OBJ_nid2sn,,true,,,OBJ_nid2sn,,,0,
311172,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Int32.New,,true,,,Int32.New,,,0,
311178,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ssl,,true,,,ssl,,,0,
311182,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_new,,true,,,SSL_new,,,0,
311186,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,STACK_OF,,true,,,STACK_OF,,,0,
311190,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_get_ciphers,,true,,,SSL_get_ciphers,,,0,
311194,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sk_SSL_CIPHER_num,,true,,,sk_SSL_CIPHER_num,,,0,
311198,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,arr,,true,,,arr,,,0,
311202,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sk_SSL_CIPHER_value,,true,,,sk_SSL_CIPHER_value,,,0,
311207,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CIPHER_get_name,,true,,,SSL_CIPHER_get_name,,,0,
311211,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_CIPHER_do_all_sorted,,true,,,EVP_CIPHER_do_all_sorted,,,0,
311216,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ToJSArray,,true,,,ToJSArray,,,0,
311220,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node.hpp,node.hpp:960:976:NODE_DEFINE_CONSTANT:2,,true,960,976,NODE_DEFINE_CONSTANT,,,0,
311225,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, kWebCryptoCipherEncrypt)",,true,,,"NODE_DEFINE_CONSTANT(target, kWebCryptoCipherEncrypt)",,,0,
311233,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, kWebCryptoCipherDecrypt)",,true,,,"NODE_DEFINE_CONSTANT(target, kWebCryptoCipherDecrypt)",,,0,
311241,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InitAuthenticated,,true,,,InitAuthenticated,,,0,
311247,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_CRYPTO_INVALID_KEYLEN,,true,,,THROW_ERR_CRYPTO_INVALID_KEYLEN,,,0,
311251,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FIPS_mode,,true,,,FIPS_mode,,,0,
311254,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_CRYPTO_UNSUPPORTED_OPERATION,,true,,,THROW_ERR_CRYPTO_UNSUPPORTED_OPERATION,,,0,
311258,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_BytesToKey,,true,,,EVP_BytesToKey,,,0,
311269,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_md5,,true,,,EVP_md5,,,0,
311272,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProcessEmitWarning,,true,,,ProcessEmitWarning,,,0,
311277,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CommonInit,,true,,,CommonInit,,,0,
311287,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,cipher_type,,true,,,cipher_type,,,0,
311292,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,key_buf,,true,,,key_buf,,,0,
311296,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Init,,true,,,Init,,,0,
311303,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ByteSource.FromSecretKeyBytes,,true,,,ByteSource.FromSecretKeyBytes,,,0,
311309,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,iv_buf,,true,,,iv_buf,,,0,
311313,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsNull,,true,,,IsNull,,,0,
311317,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InitIv,,true,,,InitIv,,,0,
311325,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_CIPHER_CTX_mode,,true,,,EVP_CIPHER_CTX_mode,,,0,
311329,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsValidGCMTagLength,,true,,,IsValidGCMTagLength,,,0,
311333,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_CRYPTO_INVALID_AUTH_TAG,,true,,,THROW_ERR_CRYPTO_INVALID_AUTH_TAG,,,0,
311339,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_CIPHER_CTX_nid,,true,,,EVP_CIPHER_CTX_nid,,,0,
311343,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Buffer.Copy,,true,,,Buffer.Copy,,,0,
311350,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsAuthenticatedMode,,true,,,IsAuthenticatedMode,,,0,
311354,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,auth_tag,,true,,,auth_tag,,,0,
311358,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CopyTo,,true,,,CopyTo,,,0,
311364,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_MISSING_ARGS,,true,,,THROW_ERR_MISSING_ARGS,,,0,
311369,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckCCMMessageLength,,true,,,CheckCCMMessageLength,,,0,
311373,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MaybePassAuthTagToOpenSSL,,true,,,MaybePassAuthTagToOpenSSL,,,0,
311376,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetAAD,,true,,,SetAAD,,,0,
311382,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,no_zero_fill_scope,,true,,,no_zero_fill_scope,,,0,
311386,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ArrayBuffer.NewBackingStore,,true,,,ArrayBuffer.NewBackingStore,,,0,
311392,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Data,,true,,,Data,,,0,
311396,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BackingStore.Reallocate,,true,,,BackingStore.Reallocate,,,0,
311403,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_CIPHER_CTX_set_padding,,true,,,EVP_CIPHER_CTX_set_padding,,,0,
311408,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetAutoPadding,,true,,,SetAutoPadding,,,0,
311413,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_CRYPTO_INVALID_STATE,,true,,,THROW_ERR_CRYPTO_INVALID_STATE,,,0,
311418,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Final,,true,,,Final,,,0,
311423,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_CTX_new,,true,,,EVP_PKEY_CTX_new,,,0,
311428,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_cipher_init,,true,,,EVP_PKEY_cipher_init,,,0,
311432,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_CTX_set_rsa_padding,,true,,,EVP_PKEY_CTX_set_rsa_padding,,,0,
311437,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_CTX_set_rsa_oaep_md,,true,,,EVP_PKEY_CTX_set_rsa_oaep_md,,,0,
311442,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetRsaOaepLabel,,true,,,SetRsaOaepLabel,,,0,
311447,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_cipher,,true,,,EVP_PKEY_cipher,,,0,
311455,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ManagedEVPPKey.GetPublicOrPrivateKeyFromJs,,true,,,ManagedEVPPKey.GetPublicOrPrivateKeyFromJs,,,0,
311461,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,oaep_str,,true,,,oaep_str,,,0,
311466,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_get_digestbyname,,true,,,EVP_get_digestbyname,,,0,
311470,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_OSSL_EVP_INVALID_DIGEST,,true,,,THROW_ERR_OSSL_EVP_INVALID_DIGEST,,,0,
311474,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,oaep_label,,true,,,oaep_label,,,0,
311478,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Cipher<operation,EVP_PKEY_cipher_init,EVP_PKEY_cipher>",,true,,,"Cipher<operation,EVP_PKEY_cipher_init,EVP_PKEY_cipher>",,,0,
311488,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ParseRecordHeader,,true,,,ParseRecordHeader,,,0,
311493,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ParseHeader,,true,,,ParseHeader,,,0,
311498,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,End,,true,,,End,,,0,
311502,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ParseTLSClientHello,,true,,,ParseTLSClientHello,,,0,
311507,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,onhello_cb_,,true,,,onhello_cb_,,,0,
311512,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ParseExtension,,true,,,ParseExtension,,,0,
311518,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OPENSSL_free,,true,,,OPENSSL_free,,,0,
311522,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_get_cert_store,,true,,,SSL_CTX_get_cert_store,,,0,
311526,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,store_ctx,,true,,,store_ctx,,,0,
311530,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_STORE_CTX_new,,true,,,X509_STORE_CTX_new,,,0,
311533,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_STORE_CTX_init,,true,,,X509_STORE_CTX_init,,,0,
311540,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_STORE_CTX_get1_issuer,,true,,,X509_STORE_CTX_get1_issuer,,,0,
311546,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_get_keylog_callback,,true,,,SSL_CTX_get_keylog_callback,,,0,
311550,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_get_SSL_CTX,,true,,,SSL_get_SSL_CTX,,,0,
311554,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_get_client_random,,true,,,SSL_get_client_random,,,0,
311560,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StringBytes.hex_encode,,true,,,StringBytes.hex_encode,,,0,
311566,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,keylog_cb,,true,,,keylog_cb,,,0,
311571,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_get_tlsext_status_ocsp_resp,,true,,,SSL_get_tlsext_status_ocsp_resp,,,0,
311576,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_set_session,,true,,,SSL_set_session,,,0,
311581,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSLSessionPointer,,true,,,SSLSessionPointer,,,0,
311585,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,d2i_SSL_SESSION,,true,,,d2i_SSL_SESSION,,,0,
311591,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_get_peer_certificate,,true,,,SSL_get_peer_certificate,,,0,
311595,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_free,,true,,,X509_free,,,0,
311599,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_get_verify_result,,true,,,SSL_get_verify_result,,,0,
311603,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_get_current_cipher,,true,,,SSL_get_current_cipher,,,0,
311607,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_get_session,,true,,,SSL_get_session,,,0,
311611,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CIPHER_get_auth_nid,,true,,,SSL_CIPHER_get_auth_nid,,,0,
311615,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_SESSION_get_protocol_version,,true,,,SSL_SESSION_get_protocol_version,,,0,
311619,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_session_reused,,true,,,SSL_session_reused,,,0,
311623,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_get0_certificate,,true,,,SSL_CTX_get0_certificate,,,0,
311627,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_get0_privatekey,,true,,,SSL_CTX_get0_privatekey,,,0,
311631,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_get0_chain_certs,,true,,,SSL_CTX_get0_chain_certs,,,0,
311636,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_use_certificate,,true,,,SSL_use_certificate,,,0,
311641,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_use_PrivateKey,,true,,,SSL_use_PrivateKey,,,0,
311646,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_set1_chain,,true,,,SSL_set1_chain,,,0,
311651,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_client_hello_get0_ext,,true,,,SSL_client_hello_get0_ext,,,0,
311658,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_get_servername,,true,,,SSL_get_servername,,,0,
311663,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_set1_groups_list,,true,,,SSL_CTX_set1_groups_list,,,0,
311668,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,crypto\crypto_common.cc,crypto\crypto_common.cc:214:214:CASE_X509_ERR:1,,true,214,214,CASE_X509_ERR,,,0,
311671,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_verify_cert_error_string,,true,,,X509_verify_cert_error_string,,,0,
311675,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509ErrorCode,,true,,,X509ErrorCode,,,0,
311679,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_get_certificate,,true,,,SSL_get_certificate,,,0,
311683,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509ToObject,,true,,,X509ToObject,,,0,
311688,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIO_get_mem_ptr,,true,,,BIO_get_mem_ptr,,,0,
311693,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIO_reset,,true,,,BIO_reset,,,0,
311697,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getstr,,true,,,getstr,,,0,
311701,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sk_X509_delete,,true,,,sk_X509_delete,,,0,
311706,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sk_X509_num,,true,,,sk_X509_num,,,0,
311710,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sk_X509_value,,true,,,sk_X509_value,,,0,
311715,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_check_issued,,true,,,X509_check_issued,,,0,
311720,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Set<Object>,,true,,,Set<Object>,,,0,
311727,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,issuercert_string,,true,,,issuercert_string,,,0,
311731,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_get_issuer,,true,,,SSL_CTX_get_issuer,,,0,
311736,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DCHECK_GT,,true,,,DCHECK_GT,,,0,
311741,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nid2string,,true,,,nid2string,,,0,
311745,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EC_KEY_get0_public_key,,true,,,EC_KEY_get0_public_key,,,0,
311749,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ECPointToBuffer,,true,,,ECPointToBuffer,,,0,
311757,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EC_KEY_get_conv_form,,true,,,EC_KEY_get_conv_form,,,0,
311761,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EC_GROUP_order_bits,,true,,,EC_GROUP_order_bits,,,0,
311765,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,i2d_RSA_PUBKEY,,true,,,i2d_RSA_PUBKEY,,,0,
311770,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BN_num_bits,,true,,,BN_num_bits,,,0,
311774,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BN_print,,true,,,BN_print,,,0,
311779,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,i2d_X509,,true,,,i2d_X509,,,0,
311784,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_get_serialNumber,,true,,,X509_get_serialNumber,,,0,
311788,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,bn,,true,,,bn,,,0,
311792,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASN1_INTEGER_to_BN,,true,,,ASN1_INTEGER_to_BN,,,0,
311797,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BN_bn2hex,,true,,,BN_bn2hex,,,0,
311801,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ByteSource.Allocated,,true,,,ByteSource.Allocated,,,0,
311807,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sk_ASN1_OBJECT_num,,true,,,sk_ASN1_OBJECT_num,,,0,
311811,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ext_key_usage,,true,,,ext_key_usage,,,0,
311815,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OBJ_obj2txt,,true,,,OBJ_obj2txt,,,0,
311822,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sk_ASN1_OBJECT_value,,true,,,sk_ASN1_OBJECT_value,,,0,
311827,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetCipherName,,true,,,GetCipherName,,,0,
311832,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetCipherVersion,,true,,,GetCipherVersion,,,0,
311837,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_digest,,true,,,X509_digest,,,0,
311844,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddFingerprintDigest,,true,,,AddFingerprintDigest,,,0,
311850,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASN1_TIME_print,,true,,,ASN1_TIME_print,,,0,
311855,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_get0_notAfter,,true,,,X509_get0_notAfter,,,0,
311859,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_get0_notBefore,,true,,,X509_get0_notBefore,,,0,
311863,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsSafeAltName,,true,,,IsSafeAltName,,,0,
311869,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIO_printf,,true,,,BIO_printf,,,0,
311875,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PrintAltName,,true,,,PrintAltName,,,0,
311883,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PrintLatin1AltName,,true,,,PrintLatin1AltName,,,0,
311889,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_NAME_print_ex,,true,,,X509_NAME_print_ex,,,0,
311896,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIO_get_mem_data,,true,,,BIO_get_mem_data,,,0,
311901,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PrintUtf8AltName,,true,,,PrintUtf8AltName,,,0,
311907,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509V3_EXT_get,,true,,,X509V3_EXT_get,,,0,
311911,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509V3_EXT_get_nid,,true,,,X509V3_EXT_get_nid,,,0,
311915,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509V3_EXT_d2i,,true,,,X509V3_EXT_d2i,,,0,
311919,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sk_GENERAL_NAME_num,,true,,,sk_GENERAL_NAME_num,,,0,
311923,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sk_GENERAL_NAME_value,,true,,,sk_GENERAL_NAME_value,,,0,
311928,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PrintGeneralName,,true,,,PrintGeneralName,,,0,
311933,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sk_GENERAL_NAME_pop_free,,true,,,sk_GENERAL_NAME_pop_free,,,0,
311938,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sk_ACCESS_DESCRIPTION_num,,true,,,sk_ACCESS_DESCRIPTION_num,,,0,
311942,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sk_ACCESS_DESCRIPTION_value,,true,,,sk_ACCESS_DESCRIPTION_value,,,0,
311947,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,i2t_ASN1_OBJECT,,true,,,i2t_ASN1_OBJECT,,,0,
311953,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sk_ACCESS_DESCRIPTION_pop_free,,true,,,sk_ACCESS_DESCRIPTION_pop_free,,,0,
311958,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_get_ext_by_NID,,true,,,X509_get_ext_by_NID,,,0,
311964,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_get_ext,,true,,,X509_get_ext,,,0,
311969,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SafeX509SubjectAltNamePrint,,true,,,SafeX509SubjectAltNamePrint,,,0,
311974,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.Null,,true,,,v8.Null,,,0,
311979,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SafeX509InfoAccessPrint,,true,,,SafeX509InfoAccessPrint,,,0,
311984,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_get_issuer_name,,true,,,X509_get_issuer_name,,,0,
311988,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_get_subject_name,,true,,,X509_get_subject_name,,,0,
311992,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,get_name,,true,,,get_name,,,0,
311996,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_NAME_entry_count,,true,,,X509_NAME_entry_count,,,0,
312000,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_NAME_get_entry,,true,,,X509_NAME_get_entry,,,0,
312005,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_NAME_ENTRY_get_object,,true,,,X509_NAME_ENTRY_get_object,,,0,
312009,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_NAME_ENTRY_get_data,,true,,,X509_NAME_ENTRY_get_data,,,0,
312013,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OBJ_obj2nid,,true,,,OBJ_obj2nid,,,0,
312017,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASN1_STRING_to_UTF8,,true,,,ASN1_STRING_to_UTF8,,,0,
312022,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HasOwnProperty,,true,,,HasOwnProperty,,,0,
312028,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_client_hello_get0_ciphers,,true,,,SSL_client_hello_get0_ciphers,,,0,
312033,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ciphers,,true,,,ciphers,,,0,
312038,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CIPHER_find,,true,,,SSL_CIPHER_find,,,0,
312043,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,standard_name_string,,true,,,standard_name_string,,,0,
312047,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetCipherStandardName,,true,,,GetCipherStandardName,,,0,
312052,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,version_string,,true,,,version_string,,,0,
312056,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MaybeLocal<Array>,,true,,,MaybeLocal<Array>,,,0,
312059,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Set<Value>,,true,,,Set<Value>,,,0,
312066,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetCurrentCipherValue<GetCipherName>,,true,,,GetCurrentCipherValue<GetCipherName>,,,0,
312071,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetCurrentCipherValue<GetCipherStandardName>,,true,,,GetCurrentCipherValue<GetCipherStandardName>,,,0,
312076,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetCurrentCipherValue<GetCipherVersion>,,true,,,GetCurrentCipherValue<GetCipherVersion>,,,0,
312081,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_is_server,,true,,,SSL_is_server,,,0,
312085,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_get_server_tmp_key,,true,,,SSL_get_server_tmp_key,,,0,
312090,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,key,,true,,,key,,,0,
312095,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_id,,true,,,EVP_PKEY_id,,,0,
312099,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_bits,,true,,,EVP_PKEY_bits,,,0,
312103,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Set<String>,,true,,,Set<String>,,,0,
312110,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dh_string,,true,,,dh_string,,,0,
312114,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Set<Integer>,,true,,,Set<Integer>,,,0,
312121,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,size_string,,true,,,size_string,,,0,
312125,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ec,,true,,,ec,,,0,
312129,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_get1_EC_KEY,,true,,,EVP_PKEY_get1_EC_KEY,,,0,
312133,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EC_GROUP_get_curve_name,,true,,,EC_GROUP_get_curve_name,,,0,
312137,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EC_KEY_get0_group,,true,,,EC_KEY_get0_group,,,0,
312141,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ecdh_string,,true,,,ecdh_string,,,0,
312145,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EC_POINT_point2oct,,true,,,EC_POINT_point2oct,,,0,
312154,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,cert,,true,,,cert,,,0,
312158,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_get_peer_cert_chain,,true,,,SSL_get_peer_cert_chain,,,0,
312162,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CloneSSLCerts,,true,,,CloneSSLCerts,,,0,
312167,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,first_cert,,true,,,first_cert,,,0,
312171,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddIssuerChainToObject,,true,,,AddIssuerChainToObject,,,0,
312178,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetLastIssuedCert,,true,,,GetLastIssuedCert,,,0,
312185,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Clear,,true,,,Clear,,,0,
312189,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_check_ca,,true,,,X509_check_ca,,,0,
312193,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,subject_string,,true,,,subject_string,,,0,
312197,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetX509NameObject<X509_get_subject_name>,,true,,,GetX509NameObject<X509_get_subject_name>,,,0,
312202,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,issuer_string,,true,,,issuer_string,,,0,
312206,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetX509NameObject<X509_get_issuer_name>,,true,,,GetX509NameObject<X509_get_issuer_name>,,,0,
312211,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,subjectaltname_string,,true,,,subjectaltname_string,,,0,
312215,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetSubjectAltNameString,,true,,,GetSubjectAltNameString,,,0,
312221,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,infoaccess_string,,true,,,infoaccess_string,,,0,
312225,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetInfoAccessString,,true,,,GetInfoAccessString,,,0,
312231,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Set<Boolean>,,true,,,Set<Boolean>,,,0,
312238,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ca_string,,true,,,ca_string,,,0,
312242,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pkey,,true,,,pkey,,,0,
312246,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_get_pubkey,,true,,,X509_get_pubkey,,,0,
312250,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_get1_RSA,,true,,,EVP_PKEY_get1_RSA,,,0,
312254,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RSA_get0_key,,true,,,RSA_get0_key,,,0,
312261,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,modulus_string,,true,,,modulus_string,,,0,
312265,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetModulusString,,true,,,GetModulusString,,,0,
312271,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,bits_string,,true,,,bits_string,,,0,
312275,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetBits,,true,,,GetBits,,,0,
312280,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,exponent_string,,true,,,exponent_string,,,0,
312284,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetExponentString,,true,,,GetExponentString,,,0,
312290,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pubkey_string,,true,,,pubkey_string,,,0,
312294,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetPubKey,,true,,,GetPubKey,,,0,
312299,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetECGroup,,true,,,GetECGroup,,,0,
312305,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetECPubKey,,true,,,GetECPubKey,,,0,
312311,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,asn1curve_string,,true,,,asn1curve_string,,,0,
312315,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetCurveName<OBJ_nid2sn>,,true,,,GetCurveName<OBJ_nid2sn>,,,0,
312320,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nistcurve_string,,true,,,nistcurve_string,,,0,
312324,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetCurveName<EC_curve_nid2nist>,,true,,,GetCurveName<EC_curve_nid2nist>,,,0,
312329,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,valid_from_string,,true,,,valid_from_string,,,0,
312333,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetValidFrom,,true,,,GetValidFrom,,,0,
312339,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,valid_to_string,,true,,,valid_to_string,,,0,
312343,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetValidTo,,true,,,GetValidTo,,,0,
312349,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fingerprint_string,,true,,,fingerprint_string,,,0,
312353,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetFingerprintDigest,,true,,,GetFingerprintDigest,,,0,
312359,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_sha1,,true,,,EVP_sha1,,,0,
312362,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fingerprint256_string,,true,,,fingerprint256_string,,,0,
312366,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_sha256,,true,,,EVP_sha256,,,0,
312369,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fingerprint512_string,,true,,,fingerprint512_string,,,0,
312373,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_sha512,,true,,,EVP_sha512,,,0,
312376,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ext_key_usage_string,,true,,,ext_key_usage_string,,,0,
312380,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetKeyUsage,,true,,,GetKeyUsage,,,0,
312385,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,serial_number_string,,true,,,serial_number_string,,,0,
312389,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetSerialNumber,,true,,,GetSerialNumber,,,0,
312394,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,raw_string,,true,,,raw_string,,,0,
312398,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetRawDERCertificate,,true,,,GetRawDERCertificate,,,0,
312403,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NewRootCertStore,,true,,,NewRootCertStore,,,0,
312406,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsArrayBufferView,,true,,,IsArrayBufferView,,,0,
312410,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ByteSource.FromStringOrBuffer,,true,,,ByteSource.FromStringOrBuffer,,,0,
312416,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ERR_clear_error,,true,,,ERR_clear_error,,,0,
312419,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,x,,true,,,x,,,0,
312423,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PEM_read_bio_X509_AUX,,true,,,PEM_read_bio_X509_AUX,,,0,
312430,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,extra_certs,,true,,,extra_certs,,,0,
312434,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sk_X509_new_null,,true,,,sk_X509_new_null,,,0,
312437,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sk_X509_push,,true,,,sk_X509_push,,,0,
312442,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ERR_peek_last_error,,true,,,ERR_peek_last_error,,,0,
312445,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ERR_GET_LIB,,true,,,ERR_GET_LIB,,,0,
312449,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ERR_GET_REASON,,true,,,ERR_GET_REASON,,,0,
312453,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_use_certificate_chain,,true,,,SSL_CTX_use_certificate_chain,,,0,
312461,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PEM_read_bio_X509,,true,,,PEM_read_bio_X509,,,0,
312468,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NodeBIO.NewFixed,,true,,,NodeBIO.NewFixed,,,0,
312474,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_STORE_new,,true,,,X509_STORE_new,,,0,
312477,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ERR_set_mark,,true,,,ERR_set_mark,,,0,
312480,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_STORE_load_locations,,true,,,X509_STORE_load_locations,,,0,
312486,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ERR_pop_to_mark,,true,,,ERR_pop_to_mark,,,0,
312489,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,cli_lock,,true,,,cli_lock,,,0,
312493,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_STORE_set_default_paths,,true,,,X509_STORE_set_default_paths,,,0,
312497,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_up_ref,,true,,,X509_up_ref,,,0,
312501,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_STORE_add_cert,,true,,,X509_STORE_add_cert,,,0,
312506,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,String.NewFromOneByte,,true,,,String.NewFromOneByte,,,0,
312514,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HasInstance,,true,,,HasInstance,,,0,
312519,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetConstructorTemplate,,true,,,GetConstructorTemplate,,,0,
312523,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,secure_context_constructor_template,,true,,,secure_context_constructor_template,,,0,
312527,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,crypto\crypto_context.cc,crypto\crypto_context.cc:307:309:SET_INTEGER_CONSTANTS:2,,true,307,309,SET_INTEGER_CONSTANTS,,,0,
312532,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SET_INTEGER_CONSTANTS(""kTicketKeyReturnIndex"", kTicketKeyReturnIndex)",,true,,,"SET_INTEGER_CONSTANTS(""kTicketKeyReturnIndex"", kTicketKeyReturnIndex)",,,0,
312538,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SET_INTEGER_CONSTANTS(""kTicketKeyHMACIndex"", kTicketKeyHMACIndex)",,true,,,"SET_INTEGER_CONSTANTS(""kTicketKeyHMACIndex"", kTicketKeyHMACIndex)",,,0,
312544,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SET_INTEGER_CONSTANTS(""kTicketKeyAESIndex"", kTicketKeyAESIndex)",,true,,,"SET_INTEGER_CONSTANTS(""kTicketKeyAESIndex"", kTicketKeyAESIndex)",,,0,
312550,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SET_INTEGER_CONSTANTS(""kTicketKeyNameIndex"", kTicketKeyNameIndex)",,true,,,"SET_INTEGER_CONSTANTS(""kTicketKeyNameIndex"", kTicketKeyNameIndex)",,,0,
312556,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SET_INTEGER_CONSTANTS(""kTicketKeyIVIndex"", kTicketKeyIVIndex)",,true,,,"SET_INTEGER_CONSTANTS(""kTicketKeyIVIndex"", kTicketKeyIVIndex)",,,0,
312562,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FunctionTemplate.New,,true,,,FunctionTemplate.New,,,0,
312570,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Signature.New,,true,,,Signature.New,,,0,
312576,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetAccessorProperty,,true,,,SetAccessorProperty,,,0,
312584,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PrototypeTemplate,,true,,,PrototypeTemplate,,,0,
312588,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Local<FunctionTemplate>,,true,,,Local<FunctionTemplate>,,,0,
312591,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_secure_context_constructor_template,,true,,,set_secure_context_constructor_template,,,0,
312596,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NewInstance,,true,,,NewInstance,,,0,
312601,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AdjustAmountOfExternalAllocatedMemory,,true,,,AdjustAmountOfExternalAllocatedMemory,,,0,
312606,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TLS_method,,true,,,TLS_method,,,0,
312609,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sslmethod,,true,,,sslmethod,,,0,
312614,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_TLS_INVALID_PROTOCOL_METHOD,,true,,,THROW_ERR_TLS_INVALID_PROTOCOL_METHOD,,,0,
312620,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TLS_server_method,,true,,,TLS_server_method,,,0,
312623,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TLS_client_method,,true,,,TLS_client_method,,,0,
312626,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_new,,true,,,SSL_CTX_new,,,0,
312630,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_set_app_data,,true,,,SSL_CTX_set_app_data,,,0,
312635,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_set_options,,true,,,SSL_CTX_set_options,,,0,
312640,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_clear_mode,,true,,,SSL_CTX_clear_mode,,,0,
312645,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_set_session_cache_mode,,true,,,SSL_CTX_set_session_cache_mode,,,0,
312650,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_set_min_proto_version,,true,,,SSL_CTX_set_min_proto_version,,,0,
312655,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_set_max_proto_version,,true,,,SSL_CTX_set_max_proto_version,,,0,
312660,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_err,,true,,,is_err,,,0,
312664,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CSPRNG,,true,,,CSPRNG,,,0,
312669,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_CRYPTO_OPERATION_FAILED,,true,,,THROW_ERR_CRYPTO_OPERATION_FAILED,,,0,
312673,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_set_tlsext_ticket_key_cb,,true,,,SSL_CTX_set_tlsext_ticket_key_cb,,,0,
312678,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSLPointer,,true,,,SSLPointer,,,0,
312682,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_sess_set_new_cb,,true,,,SSL_CTX_sess_set_new_cb,,,0,
312687,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_sess_set_get_cb,,true,,,SSL_CTX_sess_set_get_cb,,,0,
312692,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_set_tlsext_servername_callback,,true,,,SSL_CTX_set_tlsext_servername_callback,,,0,
312697,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_set_keylog_callback,,true,,,SSL_CTX_set_keylog_callback,,,0,
312702,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_CRYPTO_INVALID_KEYTYPE,,true,,,THROW_ERR_CRYPTO_INVALID_KEYTYPE,,,0,
312706,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_use_PrivateKey,,true,,,SSL_CTX_use_PrivateKey,,,0,
312711,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetAsymmetricKey,,true,,,GetAsymmetricKey,,,0,
312715,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,bio,,true,,,bio,,,0,
312719,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LoadBIO,,true,,,LoadBIO,,,0,
312724,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ByteSource.FromString,,true,,,ByteSource.FromString,,,0,
312730,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PEM_read_bio_PrivateKey,,true,,,PEM_read_bio_PrivateKey,,,0,
312737,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sigalgs,,true,,,sigalgs,,,0,
312742,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_set1_sigalgs_list,,true,,,SSL_CTX_set1_sigalgs_list,,,0,
312747,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,enabled,,true,,,enabled,,,0,
312752,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,permission,,true,,,permission,,,0,
312756,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED,,true,,,THROW_ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED,,,0,
312761,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,engine_id,,true,,,engine_id,,,0,
312766,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LoadEngineById,,true,,,LoadEngineById,,,0,
312771,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ToException,,true,,,ToException,,,0,
312777,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ThrowException,,true,,,ThrowException,,,0,
312782,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ENGINE_init,,true,,,ENGINE_init,,,0,
312786,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,key_name,,true,,,key_name,,,0,
312791,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ENGINE_load_private_key,,true,,,ENGINE_load_private_key,,,0,
312798,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddCert,,true,,,AddCert,,,0,
312804,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetOrCreateRootCertStore,,true,,,GetOrCreateRootCertStore,,,0,
312807,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_set_cert_store,,true,,,SSL_CTX_set_cert_store,,,0,
312812,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_add_client_CA,,true,,,SSL_CTX_add_client_CA,,,0,
312817,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetCACert,,true,,,SetCACert,,,0,
312822,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,crl,,true,,,crl,,,0,
312826,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PEM_read_bio_X509_CRL,,true,,,PEM_read_bio_X509_CRL,,,0,
312833,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_STORE_add_crl,,true,,,X509_STORE_add_crl,,,0,
312838,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_STORE_set_flags,,true,,,X509_STORE_set_flags,,,0,
312843,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetCRL,,true,,,SetCRL,,,0,
312849,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_STORE_up_ref,,true,,,X509_STORE_up_ref,,,0,
312853,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetRootCerts,,true,,,SetRootCerts,,,0,
312857,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_set_ciphersuites,,true,,,SSL_CTX_set_ciphersuites,,,0,
312862,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_set_cipher_list,,true,,,SSL_CTX_set_cipher_list,,,0,
312867,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,curve,,true,,,curve,,,0,
312872,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_set1_curves_list,,true,,,SSL_CTX_set1_curves_list,,,0,
312877,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_set_dh_auto,,true,,,SSL_CTX_set_dh_auto,,,0,
312882,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PEM_read_bio_DHparams,,true,,,PEM_read_bio_DHparams,,,0,
312889,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DH_get0_pqg,,true,,,DH_get0_pqg,,,0,
312896,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_set_tmp_dh,,true,,,SSL_CTX_set_tmp_dh,,,0,
312901,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_get_min_proto_version,,true,,,SSL_CTX_get_min_proto_version,,,0,
312905,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_get_max_proto_version,,true,,,SSL_CTX_get_max_proto_version,,,0,
312909,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IntegerValue,,true,,,IntegerValue,,,0,
312914,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sessionIdContext,,true,,,sessionIdContext,,,0,
312919,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_set_session_id_context,,true,,,SSL_CTX_set_session_id_context,,,0,
312925,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ERR_print_errors,,true,,,ERR_print_errors,,,0,
312929,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Exception.TypeError,,true,,,Exception.TypeError,,,0,
312934,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_set_timeout,,true,,,SSL_CTX_set_timeout,,,0,
312939,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,in,,true,,,in,,,0,
312943,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_AND_RETURN_IF_NOT_BUFFER,,true,,,THROW_AND_RETURN_IF_NOT_BUFFER,,,0,
312949,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<ArrayBufferView>,,true,,,As<ArrayBufferView>,,,0,
312953,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,resize,,true,,,resize,,,0,
312958,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CopyContents,,true,,,CopyContents,,,0,
312964,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,d2i_PKCS12_bio,,true,,,d2i_PKCS12_bio,,,0,
312969,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PKCS12_parse,,true,,,PKCS12_parse,,,0,
312977,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ERR_reason_error_string,,true,,,ERR_reason_error_string,,,0,
312981,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_set_client_cert_engine,,true,,,SSL_CTX_set_client_cert_engine,,,0,
312986,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Buffer.Data,,true,,,Buffer.Data,,,0,
312991,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_get_app_data,,true,,,SSL_CTX_get_app_data,,,0,
312995,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ticketkeycallback_string,,true,,,ticketkeycallback_string,,,0,
312999,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Buffer.Length,,true,,,Buffer.Length,,,0,
313004,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,hmac_buf,,true,,,hmac_buf,,,0,
313008,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HMAC_Init_ex,,true,,,HMAC_Init_ex,,,0,
313016,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,aes_key,,true,,,aes_key,,,0,
313020,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_EncryptInit_ex,,true,,,EVP_EncryptInit_ex,,,0,
313028,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_aes_128_cbc,,true,,,EVP_aes_128_cbc,,,0,
313031,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_DecryptInit_ex,,true,,,EVP_DecryptInit_ex,,,0,
313039,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,memcmp,,true,,,memcmp,,,0,
313045,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,External.New,,true,,,External.New,,,0,
313051,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetNull,,true,,,SetNull,,,0,
313055,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIO_new_file,,true,,,BIO_new_file,,,0,
313060,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ERR_peek_error,,true,,,ERR_peek_error,,,0,
313063,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddCertsFromFile,,true,,,AddCertsFromFile,,,0,
313068,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ERR_error_string_n,,true,,,ERR_error_string_n,,,0,
313074,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fprintf,,true,,,fprintf,,,0,
313081,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,verify_error_string,,true,,,verify_error_string,,,0,
313085,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DH_get0_key,,true,,,DH_get0_key,,,0,
313091,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DH_set0_key,,true,,,DH_set0_key,,,0,
313097,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CHECK_LT,,true,,,CHECK_LT,,,0,
313102,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,memmove,,true,,,memmove,,,0,
313108,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,make,,true,,,make,,,0,
313113,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DHKeyPairGenJob.Initialize,,true,,,DHKeyPairGenJob.Initialize,,,0,
313119,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DHKeyExportJob.Initialize,,true,,,DHKeyExportJob.Initialize,,,0,
313125,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DHBitsJob.Initialize,,true,,,DHBitsJob.Initialize,,,0,
313131,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DHKeyPairGenJob.RegisterExternalReferences,,true,,,DHKeyPairGenJob.RegisterExternalReferences,,,0,
313136,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DHKeyExportJob.RegisterExternalReferences,,true,,,DHKeyExportJob.RegisterExternalReferences,,,0,
313141,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DHBitsJob.RegisterExternalReferences,,true,,,DHBitsJob.RegisterExternalReferences,,,0,
313146,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DH_new,,true,,,DH_new,,,0,
313149,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DH_generate_parameters_ex,,true,,,DH_generate_parameters_ex,,,0,
313156,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VerifyContext,,true,,,VerifyContext,,,0,
313159,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,bn_g,,true,,,bn_g,,,0,
313163,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DH_set0_pqg,,true,,,DH_set0_pqg,,,0,
313170,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ERR_put_error,,true,,,ERR_put_error,,,0,
313178,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,crypto\crypto_dh.cc,crypto\crypto_dh.cc:-1:-1:__FILE__:0,,true,-1,-1,__FILE__,,,0,
313181,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,crypto\crypto_dh.cc,crypto\crypto_dh.cc:-1:-1:__LINE__:0,,true,-1,-1,__LINE__,,,0,
313184,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BN_free,,true,,,BN_free,,,0,
313188,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BN_is_zero,,true,,,BN_is_zero,,,0,
313192,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BN_is_one,,true,,,BN_is_one,,,0,
313196,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,crypto\crypto_dh.cc,crypto\crypto_dh.cc:219:220:V:2,,true,219,220,V,,,0,
313200,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_AND_RETURN_IF_NOT_STRING,,true,,,THROW_AND_RETURN_IF_NOT_STRING,,,0,
313206,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,group_name,,true,,,group_name,,,0,
313211,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FindDiffieHellmanGroup,,true,,,FindDiffieHellmanGroup,,,0,
313215,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_CRYPTO_UNKNOWN_DH_GROUP,,true,,,THROW_ERR_CRYPTO_UNKNOWN_DH_GROUP,,,0,
313219,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,group,,true,,,group,,,0,
313223,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_CRYPTO_INITIALIZATION_FAILED,,true,,,THROW_ERR_CRYPTO_INITIALIZATION_FAILED,,,0,
313227,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,arg0,,true,,,arg0,,,0,
313231,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,arg1,,true,,,arg1,,,0,
313235,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DH_generate_key,,true,,,DH_generate_key,,,0,
313239,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BN_num_bytes,,true,,,BN_num_bytes,,,0,
313243,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BN_bn2binpad,,true,,,BN_bn2binpad,,,0,
313249,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,get_field,,true,,,get_field,,,0,
313253,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetField,,true,,,GetField,,,0,
313259,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DH_size,,true,,,DH_size,,,0,
313263,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DH_compute_key,,true,,,DH_compute_key,,,0,
313269,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DH_check_pub_key,,true,,,DH_check_pub_key,,,0,
313275,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ZeroPadDiffieHellmanSecret,,true,,,ZeroPadDiffieHellmanSecret,,,0,
313281,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_field,,true,,,set_field,,,0,
313286,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetKey,,true,,,SetKey,,,0,
313292,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DH_check,,true,,,DH_check,,,0,
313297,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,input,,true,,,input,,,0,
313302,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dh,,true,,,dh,,,0,
313306,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVPKeyCtxPointer,,true,,,EVPKeyCtxPointer,,,0,
313309,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVPKeyPointer,,true,,,EVPKeyPointer,,,0,
313313,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_new,,true,,,EVP_PKEY_new,,,0,
313316,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_assign_DH,,true,,,EVP_PKEY_assign_DH,,,0,
313321,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.get_if<int>,,true,,,std.get_if<int>,,,0,
313326,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,param_ctx,,true,,,param_ctx,,,0,
313330,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_CTX_new_id,,true,,,EVP_PKEY_CTX_new_id,,,0,
313335,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_paramgen_init,,true,,,EVP_PKEY_paramgen_init,,,0,
313339,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_CTX_set_dh_paramgen_prime_len,,true,,,EVP_PKEY_CTX_set_dh_paramgen_prime_len,,,0,
313344,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_CTX_set_dh_paramgen_generator,,true,,,EVP_PKEY_CTX_set_dh_paramgen_generator,,,0,
313349,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_paramgen,,true,,,EVP_PKEY_paramgen,,,0,
313354,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_keygen_init,,true,,,EVP_PKEY_keygen_init,,,0,
313358,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PKEY_PKCS8_Export,,true,,,PKEY_PKCS8_Export,,,0,
313363,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PKEY_SPKI_Export,,true,,,PKEY_SPKI_Export,,,0,
313368,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_derive_init,,true,,,EVP_PKEY_derive_init,,,0,
313372,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_derive_set_peer,,true,,,EVP_PKEY_derive_set_peer,,,0,
313377,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_derive,,true,,,EVP_PKEY_derive,,,0,
313383,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ByteSource,,true,,,ByteSource,,,0,
313389,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ToBuffer,,true,,,ToBuffer,,,0,
313394,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StatelessDiffieHellmanThreadsafe,,true,,,StatelessDiffieHellmanThreadsafe,,,0,
313399,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ToArrayBuffer,,true,,,ToArrayBuffer,,,0,
313403,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_CTX_set_dsa_paramgen_bits,,true,,,EVP_PKEY_CTX_set_dsa_paramgen_bits,,,0,
313408,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,crypto\crypto_dsa.cc,crypto\crypto_dsa.cc:17:23:EVP_PKEY_CTX_set_dsa_paramgen_q_bits:2,,true,17,23,EVP_PKEY_CTX_set_dsa_paramgen_q_bits,,,0,
313413,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"EVP_PKEY_CTX_set_dsa_paramgen_q_bits(
            param_ctx.get(), params->params.divisor_bits)",,true,,,"EVP_PKEY_CTX_set_dsa_paramgen_q_bits(
            param_ctx.get(), params->params.divisor_bits)",,,0,
313417,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_CTX_ctrl,,true,,,EVP_PKEY_CTX_ctrl,,,0,
313426,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,key_params,,true,,,key_params,,,0,
313430,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,key_ctx,,true,,,key_ctx,,,0,
313434,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,mutex,,true,,,mutex,,,0,
313438,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_get0_DSA,,true,,,EVP_PKEY_get0_DSA,,,0,
313442,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DSA_get0_pqg,,true,,,DSA_get0_pqg,,,0,
313449,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,modulus_length_string,,true,,,modulus_length_string,,,0,
313453,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,divisor_length_string,,true,,,divisor_length_string,,,0,
313457,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DsaKeyPairGenJob.Initialize,,true,,,DsaKeyPairGenJob.Initialize,,,0,
313463,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DSAKeyExportJob.Initialize,,true,,,DSAKeyExportJob.Initialize,,,0,
313469,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DsaKeyPairGenJob.RegisterExternalReferences,,true,,,DsaKeyPairGenJob.RegisterExternalReferences,,,0,
313474,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DSAKeyExportJob.RegisterExternalReferences,,true,,,DSAKeyExportJob.RegisterExternalReferences,,,0,
313479,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EC_curve_nist2nid,,true,,,EC_curve_nist2nid,,,0,
313483,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OBJ_sn2nid,,true,,,OBJ_sn2nid,,,0,
313487,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strcmp,,true,,,strcmp,,,0,
313492,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ECDHBitsJob.Initialize,,true,,,ECDHBitsJob.Initialize,,,0,
313498,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ECKeyPairGenJob.Initialize,,true,,,ECKeyPairGenJob.Initialize,,,0,
313504,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ECKeyExportJob.Initialize,,true,,,ECKeyExportJob.Initialize,,,0,
313510,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, OPENSSL_EC_NAMED_CURVE)",,true,,,"NODE_DEFINE_CONSTANT(target, OPENSSL_EC_NAMED_CURVE)",,,0,
313518,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, OPENSSL_EC_EXPLICIT_CURVE)",,true,,,"NODE_DEFINE_CONSTANT(target, OPENSSL_EC_EXPLICIT_CURVE)",,,0,
313526,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ECDHBitsJob.RegisterExternalReferences,,true,,,ECDHBitsJob.RegisterExternalReferences,,,0,
313531,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ECKeyPairGenJob.RegisterExternalReferences,,true,,,ECKeyPairGenJob.RegisterExternalReferences,,,0,
313536,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ECKeyExportJob.RegisterExternalReferences,,true,,,ECKeyExportJob.RegisterExternalReferences,,,0,
313541,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EC_get_builtin_curves,,true,,,EC_get_builtin_curves,,,0,
313546,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,curves,,true,,,curves,,,0,
313550,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.transform,,true,,,std.transform,,,0,
313558,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_CRYPTO_INVALID_CURVE,,true,,,THROW_ERR_CRYPTO_INVALID_CURVE,,,0,
313562,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EC_KEY_new_by_curve_name,,true,,,EC_KEY_new_by_curve_name,,,0,
313566,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EC_KEY_generate_key,,true,,,EC_KEY_generate_key,,,0,
313570,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pub,,true,,,pub,,,0,
313574,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EC_POINT_new,,true,,,EC_POINT_new,,,0,
313578,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ECPointPointer,,true,,,ECPointPointer,,,0,
313581,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EC_POINT_oct2point,,true,,,EC_POINT_oct2point,,,0,
313589,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsKeyPairValid,,true,,,IsKeyPairValid,,,0,
313593,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_CRYPTO_INVALID_KEYPAIR,,true,,,THROW_ERR_CRYPTO_INVALID_KEYPAIR,,,0,
313597,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ECDH.BufferToPoint,,true,,,ECDH.BufferToPoint,,,0,
313604,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EC_GROUP_get_degree,,true,,,EC_GROUP_get_degree,,,0,
313608,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ECDH_compute_key,,true,,,ECDH_compute_key,,,0,
313616,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EC_KEY_get0_private_key,,true,,,EC_KEY_get0_private_key,,,0,
313620,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,priv_buffer,,true,,,priv_buffer,,,0,
313624,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,priv,,true,,,priv,,,0,
313628,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsKeyValidForCurve,,true,,,IsKeyValidForCurve,,,0,
313633,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,new_key,,true,,,new_key,,,0,
313637,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EC_KEY_dup,,true,,,EC_KEY_dup,,,0,
313641,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EC_KEY_set_private_key,,true,,,EC_KEY_set_private_key,,,0,
313646,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EC_POINT_mul,,true,,,EC_POINT_mul,,,0,
313655,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EC_KEY_set_public_key,,true,,,EC_KEY_set_public_key,,,0,
313660,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,order,,true,,,order,,,0,
313664,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EC_GROUP_get_order,,true,,,EC_GROUP_get_order,,,0,
313670,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EC_KEY_check_key,,true,,,EC_KEY_check_key,,,0,
313674,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,args0,,true,,,args0,,,0,
313678,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetEmptyString,,true,,,SetEmptyString,,,0,
313682,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EC_GROUP_new_by_curve_name,,true,,,EC_GROUP_new_by_curve_name,,,0,
313686,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetOKPCurveFromName,,true,,,GetOKPCurveFromName,,,0,
313690,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pub_lock,,true,,,pub_lock,,,0,
313694,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,priv_lock,,true,,,priv_lock,,,0,
313698,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_get0_EC_KEY,,true,,,EVP_PKEY_get0_EC_KEY,,,0,
313702,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_CTX_set_ec_paramgen_curve_nid,,true,,,EVP_PKEY_CTX_set_ec_paramgen_curve_nid,,,0,
313707,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_CTX_set_ec_param_enc,,true,,,EVP_PKEY_CTX_set_ec_param_enc,,,0,
313712,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,curve_name,,true,,,curve_name,,,0,
313717,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetCurveFromName,,true,,,GetCurveFromName,,,0,
313721,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fn,,true,,,fn,,,0,
313726,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EC_Raw_Export,,true,,,EC_Raw_Export,,,0,
313732,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EC_KEY_new,,true,,,EC_KEY_new,,,0,
313735,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EC_KEY_set_group,,true,,,EC_KEY_set_group,,,0,
313740,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uncompressed,,true,,,uncompressed,,,0,
313744,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_set1_EC_KEY,,true,,,EVP_PKEY_set1_EC_KEY,,,0,
313749,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,i2d_PUBKEY_bio,,true,,,i2d_PUBKEY_bio,,,0,
313754,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ByteSource.FromBIO,,true,,,ByteSource.FromBIO,,,0,
313759,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,y,,true,,,y,,,0,
313763,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EC_POINT_get_affine_coordinates,,true,,,EC_POINT_get_affine_coordinates,,,0,
313771,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Nothing<void>,,true,,,Nothing<void>,,,0,
313774,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,jwk_kty_string,,true,,,jwk_kty_string,,,0,
313778,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,jwk_ec_string,,true,,,jwk_ec_string,,,0,
313782,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetEncodedValue,,true,,,SetEncodedValue,,,0,
313789,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,jwk_x_string,,true,,,jwk_x_string,,,0,
313793,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,jwk_y_string,,true,,,jwk_y_string,,,0,
313797,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_CRYPTO_JWK_UNSUPPORTED_CURVE,,true,,,THROW_ERR_CRYPTO_JWK_UNSUPPORTED_CURVE,,,0,
313803,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,jwk_crv_string,,true,,,jwk_crv_string,,,0,
313807,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsJust,,true,,,IsJust,,,0,
313811,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,jwk_d_string,,true,,,jwk_d_string,,,0,
313815,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,JustVoid,,true,,,JustVoid,,,0,
313818,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_get_raw_public_key,,true,,,EVP_PKEY_get_raw_public_key,,,0,
313824,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_get_raw_private_key,,true,,,EVP_PKEY_get_raw_private_key,,,0,
313830,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,data<const char>,,true,,,data<const char>,,,0,
313834,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,jwk_okp_string,,true,,,jwk_okp_string,,,0,
313838,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.shared_ptr<KeyObjectData>,,true,,,std.shared_ptr<KeyObjectData>,,,0,
313842,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_CRYPTO_INVALID_JWK,,true,,,THROW_ERR_CRYPTO_INVALID_JWK,,,0,
313847,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ByteSource.FromEncodedString,,true,,,ByteSource.FromEncodedString,,,0,
313853,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EC_KEY_set_public_key_affine_coordinates,,true,,,EC_KEY_set_public_key_affine_coordinates,,,0,
313859,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ToBN,,true,,,ToBN,,,0,
313863,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,KeyObjectData.CreateAsymmetric,,true,,,KeyObjectData.CreateAsymmetric,,,0,
313869,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ManagedEVPPKey,,true,,,ManagedEVPPKey,,,0,
313873,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,named_curve_string,,true,,,named_curve_string,,,0,
313877,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HashUpdate,,true,,,HashUpdate,,,0,
313883,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_MD_do_all_sorted,,true,,,EVP_MD_do_all_sorted,,,0,
313888,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HashJob.Initialize,,true,,,HashJob.Initialize,,,0,
313894,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HashJob.RegisterExternalReferences,,true,,,HashJob.RegisterExternalReferences,,,0,
313899,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_MD_CTX_md,,true,,,EVP_MD_CTX_md,,,0,
313903,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,hash_type,,true,,,hash_type,,,0,
313908,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Nothing<unsigned int>,,true,,,Nothing<unsigned int>,,,0,
313911,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Just<unsigned int>,,true,,,Just<unsigned int>,,,0,
313915,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HashInit,,true,,,HashInit,,,0,
313921,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_MD_CTX_copy,,true,,,EVP_MD_CTX_copy,,,0,
313926,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_MD_CTX_new,,true,,,EVP_MD_CTX_new,,,0,
313929,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_DigestInit_ex,,true,,,EVP_DigestInit_ex,,,0,
313935,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_MD_size,,true,,,EVP_MD_size,,,0,
313939,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_MD_flags,,true,,,EVP_MD_flags,,,0,
313943,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVPerr,,true,,,EVPerr,,,0,
313948,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_DigestUpdate,,true,,,EVP_DigestUpdate,,,0,
313954,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,digest,,true,,,digest,,,0,
313959,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_MD_CTX_size,,true,,,EVP_MD_CTX_size,,,0,
313963,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_DigestFinal_ex,,true,,,EVP_DigestFinal_ex,,,0,
313969,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_DigestFinalXOF,,true,,,EVP_DigestFinalXOF,,,0,
313975,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,~HashConfig,,true,,,~HashConfig,,,0,
313979,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_CRYPTO_INVALID_DIGEST,,true,,,THROW_ERR_CRYPTO_INVALID_DIGEST,,,0,
313985,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,~HKDFConfig,,true,,,~HKDFConfig,,,0,
313989,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,hash,,true,,,hash,,,0,
313994,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,salt,,true,,,salt,,,0,
313998,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,info,,true,,,info,,,0,
314002,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_CTX_set_hkdf_md,,true,,,EVP_PKEY_CTX_set_hkdf_md,,,0,
314007,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_CTX_add1_hkdf_info,,true,,,EVP_PKEY_CTX_add1_hkdf_info,,,0,
314013,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HMAC,,true,,,HMAC,,,0,
314023,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_CTX_hkdf_mode,,true,,,EVP_PKEY_CTX_hkdf_mode,,,0,
314028,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_CTX_set1_hkdf_key,,true,,,EVP_PKEY_CTX_set1_hkdf_key,,,0,
314034,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HmacUpdate,,true,,,HmacUpdate,,,0,
314040,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HmacJob.Initialize,,true,,,HmacJob.Initialize,,,0,
314046,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HmacJob.RegisterExternalReferences,,true,,,HmacJob.RegisterExternalReferences,,,0,
314051,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HMAC_CTX_new,,true,,,HMAC_CTX_new,,,0,
314054,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HmacInit,,true,,,HmacInit,,,0,
314061,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HMAC_Update,,true,,,HMAC_Update,,,0,
314067,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HMAC_Final,,true,,,HMAC_Final,,,0,
314073,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,~HmacConfig,,true,,,~HmacConfig,,,0,
314077,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,signature,,true,,,signature,,,0,
314081,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,bytes,,true,,,bytes,,,0,
314085,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,KeyObjectData.CreateSecret,,true,,,KeyObjectData.CreateSecret,,,0,
314090,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,KeyObjectHandle.Create,,true,,,KeyObjectHandle.Create,,,0,
314096,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NidKeyPairGenJob.Initialize,,true,,,NidKeyPairGenJob.Initialize,,,0,
314102,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SecretKeyGenJob.Initialize,,true,,,SecretKeyGenJob.Initialize,,,0,
314108,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NidKeyPairGenJob.RegisterExternalReferences,,true,,,NidKeyPairGenJob.RegisterExternalReferences,,,0,
314113,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SecretKeyGenJob.RegisterExternalReferences,,true,,,SecretKeyGenJob.RegisterExternalReferences,,,0,
314118,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,d2i_PUBKEY,,true,,,d2i_PUBKEY,,,0,
314124,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,d2i_PublicKey,,true,,,d2i_PublicKey,,,0,
314131,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,x509,,true,,,x509,,,0,
314135,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,d2i_X509,,true,,,d2i_X509,,,0,
314141,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsNullOrUndefined,,true,,,IsNullOrUndefined,,,0,
314145,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Nothing<PKEncodingType>,,true,,,Nothing<PKEncodingType>,,,0,
314148,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PEM_bytes_read_bio,,true,,,PEM_bytes_read_bio,,,0,
314158,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,parse,,true,,,parse,,,0,
314163,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OPENSSL_clear_free,,true,,,OPENSSL_clear_free,,,0,
314168,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,bp,,true,,,bp,,,0,
314172,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIO_new_mem_buf,,true,,,BIO_new_mem_buf,,,0,
314177,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TryParsePublicKey,,true,,,TryParsePublicKey,,,0,
314184,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ParsePublicKeyPEM,,true,,,ParsePublicKeyPEM,,,0,
314190,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ToChecked,,true,,,ToChecked,,,0,
314194,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsASN1Sequence,,true,,,IsASN1Sequence,,,0,
314201,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,d2i_PrivateKey,,true,,,d2i_PrivateKey,,,0,
314208,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsEncryptedPrivateKeyInfo,,true,,,IsEncryptedPrivateKeyInfo,,,0,
314213,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,d2i_PKCS8PrivateKey_bio,,true,,,d2i_PKCS8PrivateKey_bio,,,0,
314220,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,p8inf,,true,,,p8inf,,,0,
314224,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,d2i_PKCS8_PRIV_KEY_INFO_bio,,true,,,d2i_PKCS8_PRIV_KEY_INFO_bio,,,0,
314229,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKCS82PKEY,,true,,,EVP_PKCS82PKEY,,,0,
314233,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,rsa,,true,,,rsa,,,0,
314237,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PEM_write_bio_RSAPrivateKey,,true,,,PEM_write_bio_RSAPrivateKey,,,0,
314247,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CHECK_NULL,,true,,,CHECK_NULL,,,0,
314251,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,i2d_RSAPrivateKey_bio,,true,,,i2d_RSAPrivateKey_bio,,,0,
314256,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PEM_write_bio_PKCS8PrivateKey,,true,,,PEM_write_bio_PKCS8PrivateKey,,,0,
314266,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,i2d_PKCS8PrivateKey_bio,,true,,,i2d_PKCS8PrivateKey_bio,,,0,
314276,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ec_key,,true,,,ec_key,,,0,
314280,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PEM_write_bio_ECPrivateKey,,true,,,PEM_write_bio_ECPrivateKey,,,0,
314290,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,i2d_ECPrivateKey_bio,,true,,,i2d_ECPrivateKey_bio,,,0,
314295,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIOToStringOrBuffer,,true,,,BIOToStringOrBuffer,,,0,
314301,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PEM_write_bio_RSAPublicKey,,true,,,PEM_write_bio_RSAPublicKey,,,0,
314306,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,i2d_RSAPublicKey_bio,,true,,,i2d_RSAPublicKey_bio,,,0,
314311,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PEM_write_bio_PUBKEY,,true,,,PEM_write_bio_PUBKEY,,,0,
314316,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WritePublicKeyInner,,true,,,WritePublicKeyInner,,,0,
314322,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,jwk_oct_string,,true,,,jwk_oct_string,,,0,
314326,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,jwk_k_string,,true,,,jwk_k_string,,,0,
314330,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,static_assert,,true,,,static_assert,,,0,
314335,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ExportJWKRsaKey,,true,,,ExportJWKRsaKey,,,0,
314341,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ExportJWKEcKey,,true,,,ExportJWKEcKey,,,0,
314347,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ExportJWKEdKey,,true,,,ExportJWKEdKey,,,0,
314353,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_CRYPTO_JWK_UNSUPPORTED_KEY_TYPE,,true,,,THROW_ERR_CRYPTO_JWK_UNSUPPORTED_KEY_TYPE,,,0,
314357,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ImportJWKRsaKey,,true,,,ImportJWKRsaKey,,,0,
314364,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ImportJWKEcKey,,true,,,ImportJWKEcKey,,,0,
314371,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,length_string,,true,,,length_string,,,0,
314375,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetRsaKeyDetail,,true,,,GetRsaKeyDetail,,,0,
314381,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetDsaKeyDetail,,true,,,GetDsaKeyDetail,,,0,
314387,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetEcKeyDetail,,true,,,GetEcKeyDetail,,,0,
314393,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetDhKeyDetail,,true,,,GetDhKeyDetail,,,0,
314399,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_up_ref,,true,,,EVP_PKEY_up_ref,,,0,
314403,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,size_of_private_key,,true,,,size_of_private_key,,,0,
314406,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,size_of_public_key,,true,,,size_of_public_key,,,0,
314409,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ExportJWKSecretKey,,true,,,ExportJWKSecretKey,,,0,
314415,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ExportJWKAsymmetricKey,,true,,,ExportJWKAsymmetricKey,,,0,
314422,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Tristate,,true,,,Tristate,,,0,
314426,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ExportJWKInner,,true,,,ExportJWKInner,,,0,
314433,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WritePublicKey,,true,,,WritePublicKey,,,0,
314439,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WritePrivateKey,,true,,,WritePrivateKey,,,0,
314445,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetKeyFormatAndTypeFromJs,,true,,,GetKeyFormatAndTypeFromJs,,,0,
314452,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,cipher_name,,true,,,cipher_name,,,0,
314457,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NonCopyableMaybe<PrivateKeyEncodingConfig>,,true,,,NonCopyableMaybe<PrivateKeyEncodingConfig>,,,0,
314460,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,passphrase,,true,,,passphrase,,,0,
314464,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ToNullTerminatedCopy,,true,,,ToNullTerminatedCopy,,,0,
314468,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetPrivateKeyEncodingFromJs,,true,,,GetPrivateKeyEncodingFromJs,,,0,
314474,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ParsePrivateKey,,true,,,ParsePrivateKey,,,0,
314481,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Release,,true,,,Release,,,0,
314485,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetParsedKey,,true,,,GetParsedKey,,,0,
314492,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsRSAPrivateKey,,true,,,IsRSAPrivateKey,,,0,
314497,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ParsePublicKey,,true,,,ParsePublicKey,,,0,
314504,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ManagedEVPPKey.GetParsedKey,,true,,,ManagedEVPPKey.GetParsedKey,,,0,
314512,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_MISSING_PASSPHRASE,,true,,,THROW_ERR_MISSING_PASSPHRASE,,,0,
314517,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,crypto_key_object_handle_constructor,,true,,,crypto_key_object_handle_constructor,,,0,
314521,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_crypto_key_object_handle_constructor,,true,,,set_crypto_key_object_handle_constructor,,,0,
314526,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetFunction,,true,,,GetFunction,,,0,
314531,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,KeyObjectHandle.Initialize,,true,,,KeyObjectHandle.Initialize,,,0,
314536,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ManagedEVPPKey.GetPrivateKeyFromJs,,true,,,ManagedEVPPKey.GetPrivateKeyFromJs,,,0,
314543,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,kty_string,,true,,,kty_string,,,0,
314548,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ImportJWKSecretKey,,true,,,ImportJWKSecretKey,,,0,
314553,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ImportJWKAsymmetricKey,,true,,,ImportJWKAsymmetricKey,,,0,
314561,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OBJ_txt2nid,,true,,,OBJ_txt2nid,,,0,
314565,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,eckey,,true,,,eckey,,,0,
314569,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_assign_EC_KEY,,true,,,EVP_PKEY_assign_EC_KEY,,,0,
314574,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,key_data,,true,,,key_data,,,0,
314578,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CRYPTO_memcmp,,true,,,CRYPTO_memcmp,,,0,
314584,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_cmp,,true,,,EVP_PKEY_cmp,,,0,
314589,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetSecretKeyDetail,,true,,,GetSecretKeyDetail,,,0,
314595,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetAsymmetricKeyDetail,,true,,,GetAsymmetricKeyDetail,,,0,
314601,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,crypto_rsa_string,,true,,,crypto_rsa_string,,,0,
314605,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,crypto_rsa_pss_string,,true,,,crypto_rsa_pss_string,,,0,
314609,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,crypto_dsa_string,,true,,,crypto_dsa_string,,,0,
314613,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,crypto_dh_string,,true,,,crypto_dh_string,,,0,
314617,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,crypto_ec_string,,true,,,crypto_ec_string,,,0,
314621,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,crypto_ed25519_string,,true,,,crypto_ed25519_string,,,0,
314625,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,crypto_ed448_string,,true,,,crypto_ed448_string,,,0,
314629,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,crypto_x25519_string,,true,,,crypto_x25519_string,,,0,
314633,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,crypto_x448_string,,true,,,crypto_x448_string,,,0,
314637,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetAsymmetricKeyType,,true,,,GetAsymmetricKeyType,,,0,
314641,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ExportSecretKey,,true,,,ExportSecretKey,,,0,
314645,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ManagedEVPPKey.GetPublicKeyEncodingFromJs,,true,,,ManagedEVPPKey.GetPublicKeyEncodingFromJs,,,0,
314652,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ExportPublicKey,,true,,,ExportPublicKey,,,0,
314657,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ManagedEVPPKey.GetPrivateKeyEncodingFromJs,,true,,,ManagedEVPPKey.GetPrivateKeyEncodingFromJs,,,0,
314664,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ExportPrivateKey,,true,,,ExportPrivateKey,,,0,
314669,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_crypto_key_object_secret_constructor,,true,,,set_crypto_key_object_secret_constructor,,,0,
314674,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_crypto_key_object_public_constructor,,true,,,set_crypto_key_object_public_constructor,,,0,
314679,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_crypto_key_object_private_constructor,,true,,,set_crypto_key_object_private_constructor,,,0,
314684,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_MESSAGE_TARGET_CONTEXT_UNAVAILABLE,,true,,,THROW_ERR_MESSAGE_TARGET_CONTEXT_UNAVAILABLE,,,0,
314688,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,builtin_module_require,,true,,,builtin_module_require,,,0,
314692,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,crypto_key_object_secret_constructor,,true,,,crypto_key_object_secret_constructor,,,0,
314696,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,crypto_key_object_public_constructor,,true,,,crypto_key_object_public_constructor,,,0,
314700,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,crypto_key_object_private_constructor,,true,,,crypto_key_object_private_constructor,,,0,
314704,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY2PKCS8,,true,,,EVP_PKEY2PKCS8,,,0,
314708,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,i2d_PKCS8_PRIV_KEY_INFO_bio,,true,,,i2d_PKCS8_PRIV_KEY_INFO_bio,,,0,
314713,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatRaw)",,true,,,"NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatRaw)",,,0,
314721,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatPKCS8)",,true,,,"NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatPKCS8)",,,0,
314729,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatSPKI)",,true,,,"NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatSPKI)",,,0,
314737,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatJWK)",,true,,,"NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatJWK)",,,0,
314745,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, EVP_PKEY_ED25519)",,true,,,"NODE_DEFINE_CONSTANT(target, EVP_PKEY_ED25519)",,,0,
314753,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, EVP_PKEY_ED448)",,true,,,"NODE_DEFINE_CONSTANT(target, EVP_PKEY_ED448)",,,0,
314761,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, EVP_PKEY_X25519)",,true,,,"NODE_DEFINE_CONSTANT(target, EVP_PKEY_X25519)",,,0,
314769,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, EVP_PKEY_X448)",,true,,,"NODE_DEFINE_CONSTANT(target, EVP_PKEY_X448)",,,0,
314777,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, kKeyEncodingPKCS1)",,true,,,"NODE_DEFINE_CONSTANT(target, kKeyEncodingPKCS1)",,,0,
314785,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, kKeyEncodingPKCS8)",,true,,,"NODE_DEFINE_CONSTANT(target, kKeyEncodingPKCS8)",,,0,
314793,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, kKeyEncodingSPKI)",,true,,,"NODE_DEFINE_CONSTANT(target, kKeyEncodingSPKI)",,,0,
314801,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, kKeyEncodingSEC1)",,true,,,"NODE_DEFINE_CONSTANT(target, kKeyEncodingSEC1)",,,0,
314809,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, kKeyFormatDER)",,true,,,"NODE_DEFINE_CONSTANT(target, kKeyFormatDER)",,,0,
314817,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, kKeyFormatPEM)",,true,,,"NODE_DEFINE_CONSTANT(target, kKeyFormatPEM)",,,0,
314825,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, kKeyFormatJWK)",,true,,,"NODE_DEFINE_CONSTANT(target, kKeyFormatJWK)",,,0,
314833,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, kKeyTypeSecret)",,true,,,"NODE_DEFINE_CONSTANT(target, kKeyTypeSecret)",,,0,
314841,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, kKeyTypePublic)",,true,,,"NODE_DEFINE_CONSTANT(target, kKeyTypePublic)",,,0,
314849,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, kKeyTypePrivate)",,true,,,"NODE_DEFINE_CONSTANT(target, kKeyTypePrivate)",,,0,
314857,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, kSigEncDER)",,true,,,"NODE_DEFINE_CONSTANT(target, kSigEncDER)",,,0,
314865,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, kSigEncP1363)",,true,,,"NODE_DEFINE_CONSTANT(target, kSigEncP1363)",,,0,
314873,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,KeyObjectHandle.RegisterExternalReferences,,true,,,KeyObjectHandle.RegisterExternalReferences,,,0,
314878,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,~PBKDF2Config,,true,,,~PBKDF2Config,,,0,
314882,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pass,,true,,,pass,,,0,
314886,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PKCS5_PBKDF2_HMAC,,true,,,PKCS5_PBKDF2_HMAC,,,0,
314897,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.Undefined,,true,,,v8.Undefined,,,0,
314902,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_ok,,true,,,is_ok,,,0,
314906,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,rem,,true,,,rem,,,0,
314910,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BN_secure_new,,true,,,BN_secure_new,,,0,
314913,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BN_generate_prime_ex,,true,,,BN_generate_prime_ex,,,0,
314922,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,candidate,,true,,,candidate,,,0,
314926,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BN_CTX_new,,true,,,BN_CTX_new,,,0,
314929,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BN_is_prime_ex,,true,,,BN_is_prime_ex,,,0,
314936,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RandomBytesJob.Initialize,,true,,,RandomBytesJob.Initialize,,,0,
314942,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RandomPrimeJob.Initialize,,true,,,RandomPrimeJob.Initialize,,,0,
314948,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckPrimeJob.Initialize,,true,,,CheckPrimeJob.Initialize,,,0,
314954,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RandomBytesJob.RegisterExternalReferences,,true,,,RandomBytesJob.RegisterExternalReferences,,,0,
314959,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RandomPrimeJob.RegisterExternalReferences,,true,,,RandomPrimeJob.RegisterExternalReferences,,,0,
314964,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckPrimeJob.RegisterExternalReferences,,true,,,CheckPrimeJob.RegisterExternalReferences,,,0,
314969,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_CTX_set_rsa_keygen_bits,,true,,,EVP_PKEY_CTX_set_rsa_keygen_bits,,,0,
314974,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_CTX_set_rsa_keygen_pubexp,,true,,,EVP_PKEY_CTX_set_rsa_keygen_pubexp,,,0,
314979,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_CTX_set_rsa_pss_keygen_md,,true,,,EVP_PKEY_CTX_set_rsa_pss_keygen_md,,,0,
314984,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_CTX_set_rsa_pss_keygen_mgf1_md,,true,,,EVP_PKEY_CTX_set_rsa_pss_keygen_mgf1_md,,,0,
314989,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_CTX_set_rsa_pss_keygen_saltlen,,true,,,EVP_PKEY_CTX_set_rsa_pss_keygen_saltlen,,,0,
314994,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,init,,true,,,init,,,0,
314999,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_CTX_set_rsa_mgf1_md,,true,,,EVP_PKEY_CTX_set_rsa_mgf1_md,,,0,
315004,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,cipher,,true,,,cipher,,,0,
315012,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RSA_JWK_Export,,true,,,RSA_JWK_Export,,,0,
315018,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,label,,true,,,label,,,0,
315023,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"RSA_Cipher<EVP_PKEY_encrypt_init,EVP_PKEY_encrypt>",,true,,,"RSA_Cipher<EVP_PKEY_encrypt_init,EVP_PKEY_encrypt>",,,0,
315031,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"RSA_Cipher<EVP_PKEY_decrypt_init,EVP_PKEY_decrypt>",,true,,,"RSA_Cipher<EVP_PKEY_decrypt_init,EVP_PKEY_decrypt>",,,0,
315039,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OpenSSL_version_num,,true,,,OpenSSL_version_num,,,0,
315042,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_get0_RSA,,true,,,EVP_PKEY_get0_RSA,,,0,
315046,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_get0,,true,,,EVP_PKEY_get0,,,0,
315050,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,jwk_rsa_string,,true,,,jwk_rsa_string,,,0,
315054,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,jwk_n_string,,true,,,jwk_n_string,,,0,
315058,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,jwk_e_string,,true,,,jwk_e_string,,,0,
315062,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RSA_get0_factors,,true,,,RSA_get0_factors,,,0,
315068,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RSA_get0_crt_params,,true,,,RSA_get0_crt_params,,,0,
315075,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,jwk_p_string,,true,,,jwk_p_string,,,0,
315079,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,jwk_q_string,,true,,,jwk_q_string,,,0,
315083,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,jwk_dp_string,,true,,,jwk_dp_string,,,0,
315087,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,jwk_dq_string,,true,,,jwk_dq_string,,,0,
315091,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,jwk_qi_string,,true,,,jwk_qi_string,,,0,
315095,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RSA_new,,true,,,RSA_new,,,0,
315098,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RSA_set0_key,,true,,,RSA_set0_key,,,0,
315105,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RSA_set0_factors,,true,,,RSA_set0_factors,,,0,
315111,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RSA_set0_crt_params,,true,,,RSA_set0_crt_params,,,0,
315118,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_set1_RSA,,true,,,EVP_PKEY_set1_RSA,,,0,
315123,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,public_exponent_string,,true,,,public_exponent_string,,,0,
315127,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RSA_get0_pss_params,,true,,,RSA_get0_pss_params,,,0,
315131,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,hash_algorithm_string,,true,,,hash_algorithm_string,,,0,
315135,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OBJ_nid2ln,,true,,,OBJ_nid2ln,,,0,
315139,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,mgf1_hash_algorithm_string,,true,,,mgf1_hash_algorithm_string,,,0,
315143,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASN1_INTEGER_get_int64,,true,,,ASN1_INTEGER_get_int64,,,0,
315148,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,salt_length_string,,true,,,salt_length_string,,,0,
315152,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Just<bool>,,true,,,Just<bool>,,,0,
315156,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RSAKeyPairGenJob.Initialize,,true,,,RSAKeyPairGenJob.Initialize,,,0,
315162,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RSAKeyExportJob.Initialize,,true,,,RSAKeyExportJob.Initialize,,,0,
315168,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RSACipherJob.Initialize,,true,,,RSACipherJob.Initialize,,,0,
315174,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NODE_DEFINE_CONSTANT,,true,,,NODE_DEFINE_CONSTANT,,,0,
315179,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RSAKeyPairGenJob.RegisterExternalReferences,,true,,,RSAKeyPairGenJob.RegisterExternalReferences,,,0,
315184,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RSAKeyExportJob.RegisterExternalReferences,,true,,,RSAKeyExportJob.RegisterExternalReferences,,,0,
315189,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RSACipherJob.RegisterExternalReferences,,true,,,RSACipherJob.RegisterExternalReferences,,,0,
315194,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,~ScryptConfig,,true,,,~ScryptConfig,,,0,
315198,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PBE_scrypt,,true,,,EVP_PBE_scrypt,,,0,
315211,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_CRYPTO_INVALID_SCRYPT_PARAMS,,true,,,THROW_ERR_CRYPTO_INVALID_SCRYPT_PARAMS,,,0,
315215,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,crypto.CheckThrow,,true,,,crypto.CheckThrow,,,0,
315221,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_base_id,,true,,,EVP_PKEY_base_id,,,0,
315225,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_CTX_set_rsa_pss_saltlen,,true,,,EVP_PKEY_CTX_set_rsa_pss_saltlen,,,0,
315230,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_size,,true,,,EVP_PKEY_size,,,0,
315234,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pkctx,,true,,,pkctx,,,0,
315238,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_sign_init,,true,,,EVP_PKEY_sign_init,,,0,
315242,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ApplyRSAOptions,,true,,,ApplyRSAOptions,,,0,
315249,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_CTX_set_signature_md,,true,,,EVP_PKEY_CTX_set_signature_md,,,0,
315254,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_sign,,true,,,EVP_PKEY_sign,,,0,
315262,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DSA_get0_q,,true,,,DSA_get0_q,,,0,
315266,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,asn1_sig,,true,,,asn1_sig,,,0,
315270,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,d2i_ECDSA_SIG,,true,,,d2i_ECDSA_SIG,,,0,
315276,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ECDSA_SIG_get0_r,,true,,,ECDSA_SIG_get0_r,,,0,
315280,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ECDSA_SIG_get0_s,,true,,,ECDSA_SIG_get0_s,,,0,
315284,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetBytesOfRS,,true,,,GetBytesOfRS,,,0,
315288,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ExtractP1363,,true,,,ExtractP1363,,,0,
315295,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,data<void>,,true,,,data<void>,,,0,
315299,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ECDSA_SIG_new,,true,,,ECDSA_SIG_new,,,0,
315302,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ECDSA_SIG_set0,,true,,,ECDSA_SIG_set0,,,0,
315308,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,i2d_ECDSA_SIG,,true,,,i2d_ECDSA_SIG,,,0,
315313,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ABORT,,true,,,ABORT,,,0,
315316,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SignJob.Initialize,,true,,,SignJob.Initialize,,,0,
315322,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SignJob.RegisterExternalReferences,,true,,,SignJob.RegisterExternalReferences,,,0,
315327,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sign_type,,true,,,sign_type,,,0,
315332,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SignResult,,true,,,SignResult,,,0,
315337,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValidateDSAParameters,,true,,,ValidateDSAParameters,,,0,
315341,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Node_SignFinal,,true,,,Node_SignFinal,,,0,
315349,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ConvertSignatureToP1363,,true,,,ConvertSignatureToP1363,,,0,
315355,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetDefaultSignPadding,,true,,,GetDefaultSignPadding,,,0,
315359,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Just<int>,,true,,,Just<int>,,,0,
315363,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SignFinal,,true,,,SignFinal,,,0,
315371,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,verify_type,,true,,,verify_type,,,0,
315376,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_verify_init,,true,,,EVP_PKEY_verify_init,,,0,
315380,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_verify,,true,,,EVP_PKEY_verify,,,0,
315388,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,hbuf,,true,,,hbuf,,,0,
315392,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ConvertSignatureToDER,,true,,,ConvertSignatureToDER,,,0,
315397,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VerifyFinal,,true,,,VerifyFinal,,,0,
315406,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,~SignConfiguration,,true,,,~SignConfiguration,,,0,
315410,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operators>.assignmentOr,,true,,,<operators>.assignmentOr,,,0,
315415,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,UseP1363Encoding,,true,,,UseP1363Encoding,,,0,
315420,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_DigestSignInit,,true,,,EVP_DigestSignInit,,,0,
315428,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_DigestVerifyInit,,true,,,EVP_DigestVerifyInit,,,0,
315436,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsOneShot,,true,,,IsOneShot,,,0,
315440,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_DigestSign,,true,,,EVP_DigestSign,,,0,
315448,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_DigestSignUpdate,,true,,,EVP_DigestSignUpdate,,,0,
315454,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_DigestSignFinal,,true,,,EVP_DigestSignFinal,,,0,
315460,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_DigestVerify,,true,,,EVP_DigestVerify,,,0,
315468,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,spki,,true,,,spki,,,0,
315472,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NETSCAPE_SPKI_b64_decode,,true,,,NETSCAPE_SPKI_b64_decode,,,0,
315477,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_PUBKEY_get,,true,,,X509_PUBKEY_get,,,0,
315481,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NETSCAPE_SPKI_verify,,true,,,NETSCAPE_SPKI_verify,,,0,
315486,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VerifySpkac,,true,,,VerifySpkac,,,0,
315490,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NETSCAPE_SPKI_get_pubkey,,true,,,NETSCAPE_SPKI_get_pubkey,,,0,
315494,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sp,,true,,,sp,,,0,
315498,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ExportChallenge,,true,,,ExportChallenge,,,0,
315502,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Encode,,true,,,Encode,,,0,
315510,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_INVALID_ARG_TYPE,,true,,,THROW_ERR_INVALID_ARG_TYPE,,,0,
315515,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,buf1,,true,,,buf1,,,0,
315519,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,buf2,,true,,,buf2,,,0,
315523,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_CRYPTO_TIMING_SAFE_EQUAL_LENGTH,,true,,,THROW_ERR_CRYPTO_TIMING_SAFE_EQUAL_LENGTH,,,0,
315527,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,assign,,true,,,assign,,,0,
315533,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InvokeQueued,,true,,,InvokeQueued,,,0,
315538,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OnStreamAfterWrite,,true,,,OnStreamAfterWrite,,,0,
315544,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ToUpper,,true,,,ToUpper,,,0,
315548,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteWrap.FromObject,,true,,,WriteWrap.FromObject,,,0,
315553,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_trace,,true,,,SSL_trace,,,0,
315563,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_get_app_data,,true,,,SSL_get_app_data,,,0,
315567,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReleaseSession,,true,,,ReleaseSession,,,0,
315571,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,servername,,true,,,servername,,,0,
315576,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,String.Empty,,true,,,String.Empty,,,0,
315581,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,servername_size,,true,,,servername_size,,,0,
315585,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,session_id,,true,,,session_id,,,0,
315589,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,session_size,,true,,,session_size,,,0,
315593,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,session_id_string,,true,,,session_id_string,,,0,
315597,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,servername_string,,true,,,servername_string,,,0,
315601,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tls_ticket_string,,true,,,tls_ticket_string,,,0,
315605,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,has_ticket,,true,,,has_ticket,,,0,
315609,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,onclienthello_string,,true,,,onclienthello_string,,,0,
315613,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,onkeylog_string,,true,,,onkeylog_string,,,0,
315617,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,has_session_callbacks,,true,,,has_session_callbacks,,,0,
315621,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,i2d_SSL_SESSION,,true,,,i2d_SSL_SESSION,,,0,
315626,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_SESSION_get_id,,true,,,SSL_SESSION_get_id,,,0,
315631,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_server,,true,,,is_server,,,0,
315635,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_awaiting_new_session,,true,,,set_awaiting_new_session,,,0,
315640,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,onnewsession_string,,true,,,onnewsession_string,,,0,
315644,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_waiting_cert_cb,,true,,,is_waiting_cert_cb,,,0,
315648,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_cert_cb_running,,true,,,is_cert_cb_running,,,0,
315652,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_cert_cb_running,,true,,,set_cert_cb_running,,,0,
315656,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetServerName,,true,,,GetServerName,,,0,
315660,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_get_tlsext_status_type,,true,,,SSL_get_tlsext_status_type,,,0,
315664,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ocsp_request_string,,true,,,ocsp_request_string,,,0,
315668,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,oncertcb_string,,true,,,oncertcb_string,,,0,
315672,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,alpn_callback_string,,true,,,alpn_callback_string,,,0,
315676,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<v8.Number>,,true,,,As<v8.Number>,,,0,
315680,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_select_next_proto,,true,,,SSL_select_next_proto,,,0,
315689,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_client,,true,,,is_client,,,0,
315693,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetSSLOCSPResponse,,true,,,GetSSLOCSPResponse,,,0,
315699,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,onocspresponse_string,,true,,,onocspresponse_string,,,0,
315703,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ocsp_response,,true,,,ocsp_response,,,0,
315707,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Local<ArrayBufferView>,,true,,,Local<ArrayBufferView>,,,0,
315710,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MallocOpenSSL<unsigned char>,,true,,,MallocOpenSSL<unsigned char>,,,0,
315714,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_set_tlsext_status_ocsp_resp,,true,,,SSL_set_tlsext_status_ocsp_resp,,,0,
315720,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ClearOcspResponse,,true,,,ClearOcspResponse,,,0,
315724,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_set_tlsext_status_cb,,true,,,SSL_CTX_set_tlsext_status_cb,,,0,
315729,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_set_tlsext_status_arg,,true,,,SSL_CTX_set_tlsext_status_arg,,,0,
315734,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ERR_print_errors_cb,,true,,,ERR_print_errors_cb,,,0,
315739,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CreateSSL,,true,,,CreateSSL,,,0,
315743,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetGetSessionCallback,,true,,,SetGetSessionCallback,,,0,
315748,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetNewSessionCallback,,true,,,SetNewSessionCallback,,,0,
315753,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PushStreamListener,,true,,,PushStreamListener,,,0,
315758,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InitSSL,,true,,,InitSSL,,,0,
315761,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Debug,,true,,,Debug,,,0,
315767,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Destroy,,true,,,Destroy,,,0,
315771,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MaybeLocal<ArrayBufferView>,,true,,,MaybeLocal<ArrayBufferView>,,,0,
315774,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Done,,true,,,Done,,,0,
315779,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Cycle,,true,,,Cycle,,,0,
315783,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NodeBIO.New,,true,,,NodeBIO.New,,,0,
315788,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_set_bio,,true,,,SSL_set_bio,,,0,
315794,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_set_verify,,true,,,SSL_set_verify,,,0,
315800,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_set_mode,,true,,,SSL_set_mode,,,0,
315805,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_set_app_data,,true,,,SSL_set_app_data,,,0,
315810,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_set_info_callback,,true,,,SSL_set_info_callback,,,0,
315815,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetSelectSNIContextCallback,,true,,,SetSelectSNIContextCallback,,,0,
315820,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ConfigureSecureContext,,true,,,ConfigureSecureContext,,,0,
315824,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_set_cert_cb,,true,,,SSL_set_cert_cb,,,0,
315830,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_set_accept_state,,true,,,SSL_set_accept_state,,,0,
315834,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_initial,,true,,,set_initial,,,0,
315839,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_set_connect_state,,true,,,SSL_set_connect_state,,,0,
315843,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StreamBase.FromObject,,true,,,StreamBase.FromObject,,,0,
315848,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tls_wrap_constructor_function,,true,,,tls_wrap_constructor_function,,,0,
315852,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,buffer,,true,,,buffer,,,0,
315856,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsAlive,,true,,,IsAlive,,,0,
315860,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsClosing,,true,,,IsClosing,,,0,
315863,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OnStreamAlloc,,true,,,OnStreamAlloc,,,0,
315868,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OnStreamRead,,true,,,OnStreamRead,,,0,
315874,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ClearOut,,true,,,ClearOut,,,0,
315877,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EncOut,,true,,,EncOut,,,0,
315880,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,onhandshakestart_string,,true,,,onhandshakestart_string,,,0,
315884,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetNow,,true,,,GetNow,,,0,
315888,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_renegotiate_pending,,true,,,SSL_renegotiate_pending,,,0,
315892,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,onhandshakedone_string,,true,,,onhandshakedone_string,,,0,
315896,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsEnded,,true,,,IsEnded,,,0,
315900,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_awaiting_new_session,,true,,,is_awaiting_new_session,,,0,
315903,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIO_pending,,true,,,BIO_pending,,,0,
315907,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strong_ref,,true,,,strong_ref,,,0,
315911,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PeekMultiple,,true,,,PeekMultiple,,,0,
315918,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_buf_init,,true,,,uv_buf_init,,,0,
315923,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,underlying_stream,,true,,,underlying_stream,,,0,
315926,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ClearIn,,true,,,ClearIn,,,0,
315929,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_read,,true,,,SSL_read,,,0,
315935,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EmitAlloc,,true,,,EmitAlloc,,,0,
315939,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EmitRead,,true,,,EmitRead,,,0,
315944,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_get_error,,true,,,SSL_get_error,,,0,
315949,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetBIOError,,true,,,GetBIOError,,,0,
315952,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ERR_lib_error_string,,true,,,ERR_lib_error_string,,,0,
315956,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ERR_func_error_string,,true,,,ERR_func_error_string,,,0,
315960,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,library_string,,true,,,library_string,,,0,
315964,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,function_string,,true,,,function_string,,,0,
315968,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,reason_string,,true,,,reason_string,,,0,
315972,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,code,,true,,,code,,,0,
315976,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,onerror_string,,true,,,onerror_string,,,0,
315980,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_allocate_tls_hint,,true,,,set_allocate_tls_hint,,,0,
315985,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_write,,true,,,SSL_write,,,0,
315991,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.to_string,,true,,,std.to_string,,,0,
315996,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsIPCPipe,,true,,,IsIPCPipe,,,0,
315999,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetFD,,true,,,GetFD,,,0,
316003,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReadStart,,true,,,ReadStart,,,0,
316007,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReadStop,,true,,,ReadStop,,,0,
316011,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,clear,,true,,,clear,,,0,
316015,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ClearError,,true,,,ClearError,,,0,
316019,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetAsyncWrap,,true,,,GetAsyncWrap,,,0,
316022,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PeekWritable,,true,,,PeekWritable,,,0,
316027,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Commit,,true,,,Commit,,,0,
316032,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Peek,,true,,,Peek,,,0,
316037,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Parse,,true,,,Parse,,,0,
316042,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CreateShutdownWrap,,true,,,CreateShutdownWrap,,,0,
316046,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_shutdown,,true,,,SSL_shutdown,,,0,
316050,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DoShutdown,,true,,,DoShutdown,,,0,
316054,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,enable_session_callbacks,,true,,,enable_session_callbacks,,,0,
316058,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Start,,true,,,Start,,,0,
316062,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetKeylogCallback,,true,,,SetKeylogCallback,,,0,
316067,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIO_new_fp,,true,,,BIO_new_fp,,,0,
316072,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_set_msg_callback,,true,,,SSL_set_msg_callback,,,0,
316077,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_set_msg_callback_arg,,true,,,SSL_set_msg_callback_arg,,,0,
316082,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RemoveStreamListener,,true,,,RemoveStreamListener,,,0,
316087,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WaitForCertCb,,true,,,WaitForCertCb,,,0,
316093,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_set_alpn_select_cb,,true,,,SSL_CTX_set_alpn_select_cb,,,0,
316099,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_set_tlsext_host_name,,true,,,SSL_set_tlsext_host_name,,,0,
316104,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sni_context_string,,true,,,sni_context_string,,,0,
316108,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sni_context_err_string,,true,,,sni_context_err_string,,,0,
316112,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_set_SSL_CTX,,true,,,SSL_set_SSL_CTX,,,0,
316117,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetCACerts,,true,,,SetCACerts,,,0,
316122,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_set1_verify_cert_store,,true,,,SSL_set1_verify_cert_store,,,0,
316127,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_dup_CA_list,,true,,,SSL_dup_CA_list,,,0,
316131,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_get_client_CA_list,,true,,,SSL_CTX_get_client_CA_list,,,0,
316135,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_set_client_CA_list,,true,,,SSL_set_client_CA_list,,,0,
316140,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,hint,,true,,,hint,,,0,
316145,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_use_psk_identity_hint,,true,,,SSL_use_psk_identity_hint,,,0,
316150,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node.ERR_TLS_PSK_SET_IDENTIY_HINT_FAILED,,true,,,node.ERR_TLS_PSK_SET_IDENTIY_HINT_FAILED,,,0,
316155,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_set_psk_server_callback,,true,,,SSL_set_psk_server_callback,,,0,
316160,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_set_psk_client_callback,,true,,,SSL_set_psk_client_callback,,,0,
316165,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Local<String>,,true,,,Local<String>,,,0,
316168,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,identity_utf8,,true,,,identity_utf8,,,0,
316173,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,onpskexchange_symbol,,true,,,onpskexchange_symbol,,,0,
316177,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,psk_buf,,true,,,psk_buf,,,0,
316181,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,psk_string,,true,,,psk_string,,,0,
316185,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,identity_string,,true,,,identity_string,,,0,
316189,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,identity_buf,,true,,,identity_buf,,,0,
316194,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,UseSNIContext,,true,,,UseSNIContext,,,0,
316199,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,cb,,true,,,cb,,,0,
316203,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Buffer.HasInstance,,true,,,Buffer.HasInstance,,,0,
316208,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ThrowTypeError,,true,,,ThrowTypeError,,,0,
316213,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,protos,,true,,,protos,,,0,
316217,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_set_alpn_protos,,true,,,SSL_set_alpn_protos,,,0,
316223,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.vector<unsigned char>,,true,,,std.vector<unsigned char>,,,0,
316229,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetPeerCert,,true,,,GetPeerCert,,,0,
316236,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509Certificate.GetPeerCert,,true,,,X509Certificate.GetPeerCert,,,0,
316243,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetCert,,true,,,GetCert,,,0,
316248,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509Certificate.GetCert,,true,,,X509Certificate.GetCert,,,0,
316254,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_get_finished,,true,,,SSL_get_finished,,,0,
316260,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_get_peer_finished,,true,,,SSL_get_peer_finished,,,0,
316266,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sbuf,,true,,,sbuf,,,0,
316270,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetTLSSession,,true,,,GetTLSSession,,,0,
316275,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetTLSSession,,true,,,SetTLSSession,,,0,
316280,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VerifyPeerCertificate,,true,,,VerifyPeerCertificate,,,0,
316285,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetCipherInfo,,true,,,GetCipherInfo,,,0,
316290,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_get_shared_sigalgs,,true,,,SSL_get_shared_sigalgs,,,0,
316300,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ret_arr,,true,,,ret_arr,,,0,
316304,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.string,,true,,,std.string,,,0,
316309,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ByteSource.FromBuffer,,true,,,ByteSource.FromBuffer,,,0,
316314,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_export_keying_material,,true,,,SSL_export_keying_material,,,0,
316325,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_renegotiate,,true,,,SSL_renegotiate,,,0,
316329,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_SESSION_get0_ticket,,true,,,SSL_SESSION_get0_ticket,,,0,
316335,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NewSessionDoneCb,,true,,,NewSessionDoneCb,,,0,
316339,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_set_tlsext_status_type,,true,,,SSL_set_tlsext_status_type,,,0,
316344,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetEphemeralKey,,true,,,GetEphemeralKey,,,0,
316349,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_get_version,,true,,,SSL_get_version,,,0,
316353,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_get0_alpn_selected,,true,,,SSL_get0_alpn_selected,,,0,
316359,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,False,,true,,,False,,,0,
316363,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,h2_string,,true,,,h2_string,,,0,
316367,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,http_1_1_string,,true,,,http_1_1_string,,,0,
316371,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, HAVE_SSL_TRACE)",,true,,,"NODE_DEFINE_CONSTANT(target, HAVE_SSL_TRACE)",,,0,
316379,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,write_queue_size_string,,true,,,write_queue_size_string,,,0,
316383,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StreamBase.AddMethods,,true,,,StreamBase.AddMethods,,,0,
316389,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_tls_wrap_constructor_function,,true,,,set_tls_wrap_constructor_function,,,0,
316394,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OPENSSL_secure_clear_free,,true,,,OPENSSL_secure_clear_free,,,0,
316399,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RAND_status,,true,,,RAND_status,,,0,
316402,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RAND_bytes,,true,,,RAND_bytes,,,0,
316407,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RAND_poll,,true,,,RAND_poll,,,0,
316410,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FIPS_mode_set,,true,,,FIPS_mode_set,,,0,
316414,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_once,,true,,,uv_once,,,0,
316419,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fips_lock,,true,,,fips_lock,,,0,
316423,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OPENSSL_INIT_new,,true,,,OPENSSL_INIT_new,,,0,
316426,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OPENSSL_INIT_set_config_filename,,true,,,OPENSSL_INIT_set_config_filename,,,0,
316431,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OPENSSL_init_ssl,,true,,,OPENSSL_init_ssl,,,0,
316436,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OPENSSL_INIT_free,,true,,,OPENSSL_INIT_free,,,0,
316440,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CRYPTO_secure_malloc_init,,true,,,CRYPTO_secure_malloc_init,,,0,
316445,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ERR_load_ENGINE_strings,,true,,,ERR_load_ENGINE_strings,,,0,
316448,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ENGINE_load_builtin_engines,,true,,,ENGINE_load_builtin_engines,,,0,
316451,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,owns_process_state,,true,,,owns_process_state,,,0,
316455,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BooleanValue,,true,,,BooleanValue,,,0,
316460,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.reverse,,true,,,std.reverse,,,0,
316466,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.begin,,true,,,std.begin,,,0,
316471,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.end,,true,,,std.end,,,0,
316476,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,copy,,true,,,copy,,,0,
316480,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Empty,,true,,,Empty,,,0,
316484,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Insert,,true,,,Insert,,,0,
316489,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pop_back,,true,,,pop_back,,,0,
316493,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,openssl_error_stack,,true,,,openssl_error_stack,,,0,
316497,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReleaseToBackingStore,,true,,,ReleaseToBackingStore,,,0,
316500,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FromBuffer,,true,,,FromBuffer,,,0,
316505,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FromString,,true,,,FromString,,,0,
316511,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Utf8Length,,true,,,Utf8Length,,,0,
316516,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteUtf8,,true,,,WriteUtf8,,,0,
316525,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ByteSource.FromSymmetricKeyObjectHandle,,true,,,ByteSource.FromSymmetricKeyObjectHandle,,,0,
316530,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Foreign,,true,,,Foreign,,,0,
316535,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,reason,,true,,,reason,,,0,
316540,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,crypto\crypto_util.cc,crypto\crypto_util.cc:501:538:OSSL_ERROR_CODES_MAP:1,,true,501,538,OSSL_ERROR_CODES_MAP,,,0,
316543,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,snprintf,,true,,,snprintf,,,0,
316550,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Capture,,true,,,Capture,,,0,
316554,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,error.Decorate,,true,,,error.Decorate,,,0,
316561,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,engine,,true,,,engine,,,0,
316565,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ENGINE_by_id,,true,,,ENGINE_by_id,,,0,
316569,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EnginePointer,,true,,,EnginePointer,,,0,
316573,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ENGINE_ctrl_cmd_string,,true,,,ENGINE_ctrl_cmd_string,,,0,
316580,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ENGINE_set_default,,true,,,ENGINE_set_default,,,0,
316585,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetEngine,,true,,,SetEngine,,,0,
316590,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EncodeBignum,,true,,,EncodeBignum,,,0,
316597,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OPENSSL_memdup,,true,,,OPENSSL_memdup,,,0,
316602,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_CTX_set0_rsa_oaep_label,,true,,,EVP_PKEY_CTX_set0_rsa_oaep_label,,,0,
316608,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<v8.Uint32>,,true,,,As<v8.Uint32>,,,0,
316612,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OPENSSL_secure_zalloc,,true,,,OPENSSL_secure_zalloc,,,0,
316616,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Uint8Array.New,,true,,,Uint8Array.New,,,0,
316623,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CRYPTO_secure_malloc_initialized,,true,,,CRYPTO_secure_malloc_initialized,,,0,
316626,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BigInt.New,,true,,,BigInt.New,,,0,
316632,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CRYPTO_secure_used,,true,,,CRYPTO_secure_used,,,0,
316635,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, kCryptoJobAsync)",,true,,,"NODE_DEFINE_CONSTANT(target, kCryptoJobAsync)",,,0,
316643,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, kCryptoJobSync)",,true,,,"NODE_DEFINE_CONSTANT(target, kCryptoJobSync)",,,0,
316651,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,algo,,true,,,algo,,,0,
316654,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,x509_constructor_template,,true,,,x509_constructor_template,,,0,
316658,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_x509_constructor_template,,true,,,set_x509_constructor_template,,,0,
316663,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_dup,,true,,,X509_dup,,,0,
316667,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pem,,true,,,pem,,,0,
316671,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,der,,true,,,der,,,0,
316675,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509Certificate.New,,true,,,X509Certificate.New,,,0,
316681,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIO_new,,true,,,BIO_new,,,0,
316685,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIO_s_mem,,true,,,BIO_s_mem,,,0,
316688,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Property,,true,,,Property,,,0,
316693,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,epkey,,true,,,epkey,,,0,
316697,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PEM_write_bio_X509,,true,,,PEM_write_bio_X509,,,0,
316702,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_check_host,,true,,,X509_check_host,,,0,
316710,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_check_email,,true,,,X509_check_email,,,0,
316717,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_check_ip_asc,,true,,,X509_check_ip_asc,,,0,
316723,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509Certificate.HasInstance,,true,,,X509Certificate.HasInstance,,,0,
316729,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_check_private_key,,true,,,X509_check_private_key,,,0,
316734,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_verify,,true,,,X509_verify,,,0,
316739,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.move(next),,true,,,std.move(next),,,0,
316747,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.make_unique<EmptyEntry>,,true,,,std.make_unique<EmptyEntry>,,,0,
316751,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_fs_req_cleanup,,true,,,uv_fs_req_cleanup,,,0,
316755,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pop_front,,true,,,pop_front,,,0,
316759,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,org.eclipse.cdt.internal.core.dom.parser.cpp.CPPImplicitTemplateTypeParameter@253451a0.is_idempotent,,true,,,is_idempotent,,,0,
316763,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,anonymous_type_1488133035node::DataQueue::CreateIdempotent::::operator()00size00.has_value,,true,,,has_value,,,0,
316767,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,org.eclipse.cdt.internal.core.dom.parser.cpp.CPPImplicitTemplateTypeParameter@253451a0.size,,true,,,size,,,0,
316771,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,anonymous_type_1498133035node::DataQueue::CreateIdempotent::::operator()00size00.value,,true,,,value,,,0,
316775,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.max,,true,,,std.max,,,0,
316781,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,value_or,,true,,,value_or,,,0,
316786,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DCHECK_LE,,true,,,DCHECK_LE,,,0,
316791,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,slice,,true,,,slice,,,0,
316797,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DataQueueImpl.is_idempotent,,true,,,is_idempotent,,,0,
316800,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_idempotent,,true,,,is_idempotent,,,0,
316804,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,shared_from_this,,true,,,shared_from_this,,,0,
316807,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IdempotentDataQueueReader.getCurrentReader,,true,,,getCurrentReader,,,0,
316810,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Pull,,true,,,Pull,,,0,
316818,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,get_reader,,true,,,get_reader,,,0,
316822,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_capped,,true,,,is_capped,,,0,
316826,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NonIdempotentDataQueueReader.getCurrentReader,,true,,,getCurrentReader,,,0,
316829,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.make_shared<EmptyReader>,,true,,,std.make_shared<EmptyReader>,,,0,
316833,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InMemoryFunctor,,true,,,InMemoryFunctor,,,0,
316837,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,makeEntry,,true,,,makeEntry,,,0,
316842,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_fs_t,,true,,,uv_fs_t,,,0,
316845,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_fs_stat,,true,,,uv_fs_stat,,,0,
316852,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node.anonymous_namespace_110.FdEntry.ReaderImpl.Create,,true,,,ReaderImpl.Create,,,0,
316857,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_fs_fstat,,true,,,uv_fs_fstat,,,0,
316864,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_modified,,true,,,is_modified,,,0,
316869,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_fs_open,,true,,,uv_fs_open,,,0,
316878,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node.anonymous_namespace_121.FdEntry.CheckModified,,true,,,FdEntry.CheckModified,,,0,
316884,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_fs_close,,true,,,uv_fs_close,,,0,
316891,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fs.FileHandle.New,,true,,,fs.FileHandle.New,,,0,
316900,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReaderImpl.DrainAndClose,,true,,,DrainAndClose,,,0,
316903,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,allocate_managed_buffer,,true,,,allocate_managed_buffer,,,0,
316908,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,release_managed_buffer,,true,,,release_managed_buffer,,,0,
316913,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReaderImpl.DequeuePendingPull,,true,,,DequeuePendingPull,,,0,
316916,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckModified,,true,,,CheckModified,,,0,
316921,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.move(pending.next),,true,,,std.move(pending.next),,,0,
316929,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FdEntry.CheckModified,,true,,,FdEntry.CheckModified,,,0,
316935,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DrainAndClose,,true,,,DrainAndClose,,,0,
316939,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.any_of,,true,,,std.any_of,,,0,
316946,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsDetachable,,true,,,IsDetachable,,,0,
316950,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Buffer,,true,,,Buffer,,,0,
316954,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetBackingStore,,true,,,GetBackingStore,,,0,
316958,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ByteOffset,,true,,,ByteOffset,,,0,
316962,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CreateInMemoryEntryFromBackingStore,,true,,,CreateInMemoryEntryFromBackingStore,,,0,
316968,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FdEntry.Create,,true,,,FdEntry.Create,,,0,
316974,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_handle_type_name,,true,,,uv_handle_type_name,,,0,
316978,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Display,,true,,,Display,,,0,
316982,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LookupSymbol,,true,,,LookupSymbol,,,0,
316987,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsMapped,,true,,,IsMapped,,,0,
316992,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fwrite,,true,,,fwrite,,,0,
316999,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,credentials.SafeGetenv,,true,,,credentials.SafeGetenv,,,0,
317005,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ToLower,,true,,,ToLower,,,0,
317009,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,substr,,true,,,substr,,,0,
317015,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetCurrentProcess,,true,,,GetCurrentProcess,,,0,
317018,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SymInitialize,,true,,,SymInitialize,,,0,
317024,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SymCleanup,,true,,,SymCleanup,,,0,
317028,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SymFromAddr,,true,,,SymFromAddr,,,0,
317035,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NameAndDisplacement,,true,,,NameAndDisplacement,,,0,
317038,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetLastError,,true,,,GetLastError,,,0,
317041,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SymGetLineFromAddr64,,true,,,SymGetLineFromAddr64,,,0,
317048,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,UnDecorateSymbolName,,true,,,UnDecorateSymbolName,,,0,
317055,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Win32SymbolDebuggingContext.WrappedGetLine,,true,,,WrappedGetLine,,,0,
317059,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.tie,,true,,,std.tie,,,0,
317065,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Win32SymbolDebuggingContext.WrappedSymFromAddr,,true,,,WrappedSymFromAddr,,,0,
317069,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WrappedUnDecorateSymbolName,,true,,,WrappedUnDecorateSymbolName,,,0,
317073,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VirtualQuery,,true,,,VirtualQuery,,,0,
317079,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CaptureStackBackTrace,,true,,,CaptureStackBackTrace,,,0,
317086,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,str,,true,,,str,,,0,
317090,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NativeSymbolDebuggingContext.New,,true,,,NativeSymbolDebuggingContext.New,,,0,
317094,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetStackTrace,,true,,,GetStackTrace,,,0,
317100,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_loop_close,,true,,,uv_loop_close,,,0,
317104,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PrintLibuvHandleInformation,,true,,,PrintLibuvHandleInformation,,,0,
317109,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_walk,,true,,,uv_walk,,,0,
317115,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simple_fwrite,,true,,,simple_fwrite,,,0,
317118,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Deserialize,,true,,,Deserialize,,,0,
317123,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,type,,true,,,type,,,0,
317126,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Serialize,,true,,,Serialize,,,0,
317132,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DCHECK_EQ,,true,,,DCHECK_EQ,,,0,
317137,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsUint8Array,,true,,,IsUint8Array,,,0,
317141,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<Uint8Array>,,true,,,As<Uint8Array>,,,0,
317145,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsArrayBuffer,,true,,,IsArrayBuffer,,,0,
317149,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsSharedArrayBuffer,,true,,,IsSharedArrayBuffer,,,0,
317153,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node.THROW_ERR_INVALID_ARG_TYPE,,true,,,node.THROW_ERR_INVALID_ARG_TYPE,,,0,
317159,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simdutf.validate_utf8_with_errors,,true,,,simdutf.validate_utf8_with_errors,,,0,
317165,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node.THROW_ERR_ENCODING_INVALID_ENCODED_DATA,,true,,,node.THROW_ERR_ENCODING_INVALID_ENCODED_DATA,,,0,
317171,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ada.idna.to_unicode,,true,,,ada.idna.to_unicode,,,0,
317176,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,org.eclipse.cdt.internal.core.dom.parser.cpp.CPPImplicitTemplateTypeParameter@1dc30ae7.IsEmpty,,true,,,IsEmpty,,,0,
317180,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RunAndClearNativeImmediates,,true,,,RunAndClearNativeImmediates,,,0,
317184,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_stop,,true,,,uv_stop,,,0,
317188,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RegisterHandleCleanup,,true,,,RegisterHandleCleanup,,,0,
317194,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,flags,,true,,,flags,,,0,
317199,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,store,,true,,,store,,,0,
317204,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RunAndClearInterrupts,,true,,,RunAndClearInterrupts,,,0,
317208,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetPromiseHooks,,true,,,SetPromiseHooks,,,0,
317216,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PersistentToLocal.Weak,,true,,,PersistentToLocal.Weak,,,0,
317222,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,grow_async_ids_stack,,true,,,grow_async_ids_stack,,,0,
317225,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FailWithCorruptedAsyncStack,,true,,,FailWithCorruptedAsyncStack,,,0,
317229,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,capacity,,true,,,capacity,,,0,
317233,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,shrink_to_fit,,true,,,shrink_to_fit,,,0,
317237,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,js_execution_async_resources,,true,,,js_execution_async_resources,,,0,
317240,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PersistentToLocal.Strong,,true,,,PersistentToLocal.Strong,,,0,
317245,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.remove_if,,true,,,std.remove_if,,,0,
317252,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,async_id_fields,,true,,,async_id_fields,,,0,
317256,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddData,,true,,,AddData,,,0,
317262,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,async_wrap_provider,,true,,,async_wrap_provider,,,0,
317266,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ObjectTemplate.New,,true,,,ObjectTemplate.New,,,0,
317271,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,binding.CreateInternalBindingTemplates,,true,,,binding.CreateInternalBindingTemplates,,,0,
317276,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,contextify.ContextifyContext.InitializeGlobalTemplates,,true,,,contextify.ContextifyContext.InitializeGlobalTemplates,,,0,
317281,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CreateProperties,,true,,,CreateProperties,,,0,
317284,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DeserializeProperties,,true,,,DeserializeProperties,,,0,
317289,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED,,true,,,TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED,,,0,
317293,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,trace_category_state_function,,true,,,trace_category_state_function,,,0,
317297,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetAlignedPointerInEmbedderData,,true,,,SetAlignedPointerInEmbedderData,,,0,
317303,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,binding_data_store,,true,,,binding_data_store,,,0,
317307,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ContextEmbedderTag.TagNodeContext,,true,,,ContextEmbedderTag.TagNodeContext,,,0,
317312,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InstallPromiseHooks,,true,,,InstallPromiseHooks,,,0,
317317,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TrackContext,,true,,,TrackContext,,,0,
317321,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,UntrackContext,,true,,,UntrackContext,,,0,
317325,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,was_loaded,,true,,,was_loaded,,,0,
317329,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_cwd,,true,,,uv_cwd,,,0,
317334,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,find_last_of,,true,,,find_last_of,,,0,
317339,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_unref,,true,,,uv_unref,,,0,
317343,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_ref,,true,,,uv_ref,,,0,
317347,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.ArrayBuffer.NewBackingStore,,true,,,v8.ArrayBuffer.NewBackingStore,,,0,
317355,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_exepath,,true,,,uv_exepath,,,0,
317360,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,worker_context,,true,,,worker_context,,,0,
317364,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CopySourceAndCodeCacheReferenceFrom,,true,,,CopySourceAndCodeCacheReferenceFrom,,,0,
317369,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,builtin_loader,,true,,,builtin_loader,,,0,
317373,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RefreshCodeCache,,true,,,RefreshCodeCache,,,0,
317378,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_env_vars,,true,,,set_env_vars,,,0,
317383,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,env_vars,,true,,,env_vars,,,0,
317387,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,debug_options,,true,,,debug_options,,,0,
317391,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_abort_on_uncaught_exception,,true,,,set_abort_on_uncaught_exception,,,0,
317395,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetTracingAgentWriter,,true,,,GetTracingAgentWriter,,,0,
317398,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetTracingController,,true,,,GetTracingController,,,0,
317401,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddTraceStateObserver,,true,,,AddTraceStateObserver,,,0,
317406,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,reserve,,true,,,reserve,,,0,
317411,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MAYBE_FIELD_PTR,,true,,,MAYBE_FIELD_PTR,,,0,
317416,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tracing.TracedValue.Create,,true,,,tracing.TracedValue.Create,,,0,
317420,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BeginArray,,true,,,BeginArray,,,0,
317425,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AppendString,,true,,,AppendString,,,0,
317429,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EndArray,,true,,,EndArray,,,0,
317433,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TRACE_EVENT_NESTABLE_ASYNC_BEGIN1,,true,,,TRACE_EVENT_NESTABLE_ASYNC_BEGIN1,,,0,
317441,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EnablePermissions,,true,,,EnablePermissions,,,0,
317445,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Apply,,true,,,Apply,,,0,
317451,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,no_force_checks,,true,,,no_force_checks,,,0,
317455,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,load,,true,,,load,,,0,
317459,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,allow_js_here,,true,,,allow_js_here,,,0,
317463,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Script.Compile,,true,,,Script.Compile,,,0,
317469,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Run,,true,,,Run,,,0,
317474,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RemoveHeapSnapshotNearHeapLimitCallback,,true,,,RemoveHeapSnapshotNearHeapLimitCallback,,,0,
317479,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RemoveBuildEmbedderGraphCallback,,true,,,RemoveBuildEmbedderGraphCallback,,,0,
317485,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetHeapProfiler,,true,,,GetHeapProfiler,,,0,
317489,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RemoveTraceStateObserver,,true,,,RemoveTraceStateObserver,,,0,
317494,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TRACE_EVENT_NESTABLE_ASYNC_END0,,true,,,TRACE_EVENT_NESTABLE_ASYNC_END0,,,0,
317500,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_check_init,,true,,,uv_check_init,,,0,
317505,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,immediate_check_handle,,true,,,immediate_check_handle,,,0,
317508,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_idle_init,,true,,,uv_idle_init,,,0,
317513,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,immediate_idle_handle,,true,,,immediate_idle_handle,,,0,
317516,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_check_start,,true,,,uv_check_start,,,0,
317521,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_prepare_init,,true,,,uv_prepare_init,,,0,
317526,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_async_init,,true,,,uv_async_init,,,0,
317532,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RegisterHandleCleanups,,true,,,RegisterHandleCleanups,,,0,
317535,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StartProfilerIdleNotifier,,true,,,StartProfilerIdleNotifier,,,0,
317538,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TerminateExecution,,true,,,TerminateExecution,,,0,
317542,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetImmediateThreadsafe,,true,,,SetImmediateThreadsafe,,,0,
317548,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,register_handle,,true,,,register_handle,,,0,
317552,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Cancel,,true,,,Cancel,,,0,
317556,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,cb_,,true,,,cb_,,,0,
317561,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_prepare_start,,true,,,uv_prepare_start,,,0,
317566,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_os_getpid,,true,,,uv_os_getpid,,,0,
317569,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PrintStackTrace,,true,,,PrintStackTrace,,,0,
317574,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StackTrace.CurrentStackTrace,,true,,,StackTrace.CurrentStackTrace,,,0,
317581,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,stack_trace_limit,,true,,,stack_trace_limit,,,0,
317584,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,snapshot_serialize_callback,,true,,,snapshot_serialize_callback,,,0,
317588,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EscapeMaybe,,true,,,EscapeMaybe,,,0,
317593,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,snapshot_deserialize_main,,true,,,snapshot_deserialize_main,,,0,
317597,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CleanupHandles,,true,,,CleanupHandles,,,0,
317600,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HasCleanupHooks,,true,,,HasCleanupHooks,,,0,
317603,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Drain,,true,,,Drain,,,0,
317607,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,push_front,,true,,,push_front,,,0,
317612,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ExitCallback,,true,,,ExitCallback,,,0,
317616,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ConcatMove,,true,,,ConcatMove,,,0,
317621,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,cb_scope,,true,,,cb_scope,,,0,
317628,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,drain_list,,true,,,drain_list,,,0,
317632,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ref_count_dec,,true,,,ref_count_dec,,,0,
317637,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,immediate_info,,true,,,immediate_info,,,0,
317641,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ref_count,,true,,,ref_count,,,0,
317645,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ToggleImmediateRef,,true,,,ToggleImmediateRef,,,0,
317650,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,compare_exchange_strong,,true,,,compare_exchange_strong,,,0,
317656,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Environment.from_timer_handle,,true,,,Environment.from_timer_handle,,,0,
317661,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,timers_callback_function,,true,,,timers_callback_function,,,0,
317665,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,llabs,,true,,,llabs,,,0,
317669,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_now,,true,,,uv_now,,,0,
317673,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,timer_base,,true,,,timer_base,,,0,
317676,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ScheduleTimer,,true,,,ScheduleTimer,,,0,
317681,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Environment.from_immediate_check_handle,,true,,,Environment.from_immediate_check_handle,,,0,
317686,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,immediate_callback_function,,true,,,immediate_callback_function,,,0,
317690,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,has_outstanding,,true,,,has_outstanding,,,0,
317694,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_idle_start,,true,,,uv_idle_start,,,0,
317699,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetNowUint64,,true,,,GetNowUint64,,,0,
317703,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,message_string,,true,,,message_string,,,0,
317707,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,async_hooks_binding,,true,,,async_hooks_binding,,,0,
317711,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetValue,,true,,,GetValue,,,0,
317715,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fflush,,true,,,fflush,,,0,
317719,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ABORT_NO_BACKTRACE,,true,,,ABORT_NO_BACKTRACE,,,0,
317722,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,process_exit_handler_,,true,,,process_exit_handler_,,,0,
317727,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Isolate.GetCurrent,,true,,,Isolate.GetCurrent,,,0,
317731,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,remove_sub_worker_context,,true,,,remove_sub_worker_context,,,0,
317736,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,JoinThread,,true,,,JoinThread,,,0,
317740,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tracks_unmanaged_fds,,true,,,tracks_unmanaged_fds,,,0,
317744,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,enabled_debug_list,,true,,,enabled_debug_list,,,0,
317747,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PrintInfoForSnapshot,,true,,,PrintInfoForSnapshot,,,0,
317751,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,request,,true,,,request,,,0,
317755,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RunDeserializeRequests,,true,,,RunDeserializeRequests,,,0,
317758,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_get_free_memory,,true,,,uv_get_free_memory,,,0,
317761,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_resident_set_memory,,true,,,uv_resident_set_memory,,,0,
317765,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tracker,,true,,,tracker,,,0,
317770,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Track,,true,,,Track,,,0,
317775,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NumberOfHeapSpaces,,true,,,NumberOfHeapSpaces,,,0,
317779,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetHeapSpaceStatistics,,true,,,GetHeapSpaceStatistics,,,0,
317785,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,space_name,,true,,,space_name,,,0,
317789,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,space_used_size,,true,,,space_used_size,,,0,
317793,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GuessMemoryAvailableToTheProcess,,true,,,GuessMemoryAvailableToTheProcess,,,0,
317796,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetCwd,,true,,,GetCwd,,,0,
317800,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,heap.WriteSnapshot,,true,,,heap.WriteSnapshot,,,0,
317807,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FPrintF,,true,,,FPrintF,,,0,
317812,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AutomaticallyRestoreInitialHeapLimit,,true,,,AutomaticallyRestoreInitialHeapLimit,,,0,
317817,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ClearKeptObjects,,true,,,ClearKeptObjects,,,0,
317821,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MarkAsUninitialized,,true,,,MarkAsUninitialized,,,0,
317824,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsHandleClosing,,true,,,IsHandleClosing,,,0,
317827,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HandleWrap.GetConstructorTemplate,,true,,,HandleWrap.GetConstructorTemplate,,,0,
317832,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,path,,true,,,path,,,0,
317836,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_IF_INSUFFICIENT_PERMISSIONS,,true,,,THROW_IF_INSUFFICIENT_PERMISSIONS,,,0,
317842,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_fs_event_init,,true,,,uv_fs_event_init,,,0,
317847,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_fs_event_start,,true,,,uv_fs_event_start,,,0,
317854,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MarkAsInitialized,,true,,,MarkAsInitialized,,,0,
317858,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FSEventWrap.Close,,true,,,FSEventWrap.Close,,,0,
317863,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,rename_string,,true,,,rename_string,,,0,
317867,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,change_string,,true,,,change_string,,,0,
317871,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,onchange_string,,true,,,onchange_string,,,0,
317875,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetHandle,,true,,,GetHandle,,,0,
317879,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HasRef,,true,,,HasRef,,,0,
317883,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_close,,true,,,uv_close,,,0,
317888,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,handle_onclose_symbol,,true,,,handle_onclose_symbol,,,0,
317892,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BaseObject.OnGCCollect,,true,,,BaseObject.OnGCCollect,,,0,
317896,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HandleWrap.HasRef,,true,,,HandleWrap.HasRef,,,0,
317901,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PushBack,,true,,,PushBack,,,0,
317906,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,handle_wrap_queue,,true,,,handle_wrap_queue,,,0,
317910,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Remove,,true,,,Remove,,,0,
317914,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,has_run_bootstrapping_code,,true,,,has_run_bootstrapping_code,,,0,
317917,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,wrap,,true,,,wrap,,,0,
317921,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OnClose,,true,,,OnClose,,,0,
317925,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Has,,true,,,Has,,,0,
317931,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,handle_wrap_ctor_template,,true,,,handle_wrap_ctor_template,,,0,
317935,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_handle_wrap_ctor_template,,true,,,set_handle_wrap_ctor_template,,,0,
317940,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,JSGraphJSNode.JSValue,,true,,,JSValue,,,0,
317943,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetIdentityHash,,true,,,GetIdentityHash,,,0,
317947,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsName,,true,,,IsName,,,0,
317951,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<v8.Name>,,true,,,As<v8.Name>,,,0,
317955,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<v8.Int32>,,true,,,As<v8.Int32>,,,0,
317959,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IdentityHash,,true,,,IdentityHash,,,0,
317963,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SameValue,,true,,,SameValue,,,0,
317968,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,JSValue,,true,,,JSValue,,,0,
317972,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddNode,,true,,,AddNode,,,0,
317976,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.make_pair,,true,,,std.make_pair,,,0,
317982,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NamePrefix,,true,,,NamePrefix,,,0,
317986,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Name,,true,,,Name,,,0,
317990,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsRootNode,,true,,,IsRootNode,,,0,
317994,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SizeInBytes,,true,,,SizeInBytes,,,0,
317998,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsEmbedderNode,,true,,,IsEmbedderNode,,,0,
318002,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WrapperNode,,true,,,WrapperNode,,,0,
318006,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,graph,,true,,,graph,,,0,
318010,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Environment.BuildEmbedderGraph,,true,,,Environment.BuildEmbedderGraph,,,0,
318017,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,JSGraph.CreateObject,,true,,,CreateObject,,,0,
318021,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_fs_write,,true,,,uv_fs_write,,,0,
318031,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TakeHeapSnapshot,,true,,,TakeHeapSnapshot,,,0,
318036,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ThrowUVException,,true,,,ThrowUVException,,,0,
318042,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,stream,,true,,,stream,,,0,
318045,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TakeSnapshot,,true,,,TakeSnapshot,,,0,
318051,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FileOutputStream.status,,true,,,status,,,0,
318055,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,streambaseoutputstream_constructor_template,,true,,,streambaseoutputstream_constructor_template,,,0,
318059,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_streambaseoutputstream_constructor_template,,true,,,set_streambaseoutputstream_constructor_template,,,0,
318064,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetHeapSnapshotOptions,,true,,,GetHeapSnapshotOptions,,,0,
318068,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CreateHeapSnapshotStream,,true,,,CreateHeapSnapshotStream,,,0,
318073,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteSnapshot,,true,,,WriteSnapshot,,,0,
318079,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,hdr_init,,true,,,hdr_init,,,0,
318086,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetMemorySize,,true,,,GetMemorySize,,,0,
318089,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,histogram,,true,,,histogram,,,0,
318092,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Count,,true,,,Count,,,0,
318096,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BigInt.NewFromUnsigned,,true,,,BigInt.NewFromUnsigned,,,0,
318102,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Min,,true,,,Min,,,0,
318106,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Max,,true,,,Max,,,0,
318110,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Mean,,true,,,Mean,,,0,
318114,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Exceeds,,true,,,Exceeds,,,0,
318118,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Stddev,,true,,,Stddev,,,0,
318122,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Percentile,,true,,,Percentile,,,0,
318127,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsMap,,true,,,IsMap,,,0,
318131,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<Map>,,true,,,As<Map>,,,0,
318135,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Percentiles,,true,,,Percentiles,,,0,
318140,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RecordDelta,,true,,,RecordDelta,,,0,
318144,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsBigInt,,true,,,IsBigInt,,,0,
318148,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Int64Value,,true,,,Int64Value,,,0,
318153,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<BigInt>,,true,,,As<BigInt>,,,0,
318157,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Record,,true,,,Record,,,0,
318162,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Add,,true,,,Add,,,0,
318167,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BaseObjectPtr<HistogramBase>,,true,,,BaseObjectPtr<HistogramBase>,,,0,
318170,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,max,,true,,,max,,,0,
318174,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<Integer>,,true,,,As<Integer>,,,0,
318178,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Histogram::Options,,true,,,Histogram::Options,,,0,
318182,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,histogram_ctor_template,,true,,,histogram_ctor_template,,,0,
318186,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_histogram_ctor_template,,true,,,set_histogram_ctor_template,,,0,
318191,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Create,,true,,,Create,,,0,
318196,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,intervalhistogram_constructor_template,,true,,,intervalhistogram_constructor_template,,,0,
318200,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_intervalhistogram_constructor_template,,true,,,set_intervalhistogram_constructor_template,,,0,
318205,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BaseObjectPtr<IntervalHistogram>,,true,,,BaseObjectPtr<IntervalHistogram>,,,0,
318208,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,on_interval_,,true,,,on_interval_,,,0,
318213,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OnStart,,true,,,OnStart,,,0,
318218,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OnStop,,true,,,OnStop,,,0,
318222,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SendMessageToFrontend,,true,,,SendMessageToFrontend,,,0,
318227,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,string,,true,,,string,,,0,
318231,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DispatchMessages,,true,,,DispatchMessages,,,0,
318235,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetObject,,true,,,GetObject,,,0,
318239,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddObject,,true,,,AddObject,,,0,
318245,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WrapInDeletable,,true,,,WrapInDeletable,,,0,
318249,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,factory_,,true,,,factory_,,,0,
318253,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RemoveObject,,true,,,RemoveObject,,,0,
318258,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DeletableWrapper<Target>.get,,true,,,DeletableWrapper<Target>.get,,,0,
318264,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Post,,true,,,Post,,,0,
318271,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NewCreateRequest,,true,,,NewCreateRequest,,,0,
318276,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.bind,,true,,,std.bind,,,0,
318284,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,target->*fn,,true,,,target->*fn,,,0,
318289,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,inspector_agent,,true,,,inspector_agent,,,0,
318293,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Connect,,true,,,Connect,,,0,
318299,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StringBuffer.create,,true,,,StringBuffer.create,,,0,
318304,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,scoped_lock,,true,,,scoped_lock,,,0,
318308,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Broadcast,,true,,,Broadcast,,,0,
318313,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Wait,,true,,,Wait,,,0,
318318,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.swap,,true,,,std.swap,,,0,
318324,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MainThreadInterface.GetObjectIfExists,,true,,,GetObjectIfExists,,,0,
318328,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simdutf.utf16_length_from_utf8,,true,,,simdutf.utf16_length_from_utf8,,,0,
318334,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simdutf.convert_utf8_to_utf16,,true,,,simdutf.convert_utf8_to_utf16,,,0,
318341,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,view,,true,,,view,,,0,
318346,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MainThreadHandle.newObjectId,,true,,,newObjectId,,,0,
318349,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node.inspector.protocol.StringBuilder.put,,true,,,put,,,0,
318354,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,escapeWideStringForJSON,,true,,,escapeWideStringForJSON,,,0,
318360,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,parseJSONCharacters,,true,,,parseJSONCharacters,,,0,
318365,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is8Bit,,true,,,is8Bit,,,0,
318369,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,characters8,,true,,,characters8,,,0,
318373,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,characters16,,true,,,characters16,,,0,
318377,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simdutf.utf8_length_from_utf16,,true,,,simdutf.utf8_length_from_utf16,,,0,
318383,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simdutf.convert_utf16_to_utf8,,true,,,simdutf.convert_utf16_to_utf8,,,0,
318390,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,String,,true,,,String,,,0,
318395,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,imbue,,true,,,imbue,,,0,
318400,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.locale.classic,,true,,,std.locale.classic,,,0,
318404,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fail,,true,,,fail,,,0,
318408,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Value.parseBinary,,true,,,Value.parseBinary,,,0,
318414,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,parseJSON,,true,,,parseJSON,,,0,
318418,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simdutf.utf32_length_from_utf8,,true,,,simdutf.utf32_length_from_utf8,,,0,
318424,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node.inspector.protocol.StringBuilder.write,,true,,,write,,,0,
318430,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,builderAppend,,true,,,builderAppend,,,0,
318436,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.strlen,,true,,,std.strlen,,,0,
318441,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NodeRuntime.Dispatcher.wire,,true,,,NodeRuntime.Dispatcher.wire,,,0,
318447,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DispatchResponse.OK,,true,,,DispatchResponse.OK,,,0,
318451,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,waitingForDisconnect,,true,,,waitingForDisconnect,,,0,
318455,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetObjectIfExists,,true,,,GetObjectIfExists,,,0,
318460,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sendRawJSONNotification,,true,,,sendRawJSONNotification,,,0,
318465,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TraceWriter.CreateJSONTraceWriter,,true,,,TraceWriter.CreateJSONTraceWriter,,,0,
318470,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AppendTraceEvent,,true,,,AppendTraceEvent,,,0,
318475,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,result,,true,,,result,,,0,
318480,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,newObjectId,,true,,,newObjectId,,,0,
318484,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NodeTracing.Dispatcher.wire,,true,,,NodeTracing.Dispatcher.wire,,,0,
318490,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DispatchResponse.Error,,true,,,DispatchResponse.Error,,,0,
318495,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getIncludedCategories,,true,,,getIncludedCategories,,,0,
318499,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddClient,,true,,,AddClient,,,0,
318506,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,agent,,true,,,agent,,,0,
318510,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tracingComplete,,true,,,tracingComplete,,,0,
318514,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,create,,true,,,create,,,0,
318518,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,addItem,,true,,,addItem,,,0,
318523,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WorkerCreated,,true,,,WorkerCreated,,,0,
318531,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Detached,,true,,,Detached,,,0,
318536,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,protocol.StringUtil.StringViewToUtf8,,true,,,protocol.StringUtil.StringViewToUtf8,,,0,
318541,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,build,,true,,,build,,,0,
318545,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,setType,,true,,,setType,,,0,
318550,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,setUrl,,true,,,setUrl,,,0,
318555,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,setTitle,,true,,,setTitle,,,0,
318560,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,setWorkerId,,true,,,setWorkerId,,,0,
318565,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NodeWorker.WorkerInfo.create,,true,,,NodeWorker.WorkerInfo.create,,,0,
318569,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NodeWorker.Dispatcher.wire,,true,,,NodeWorker.Dispatcher.wire,,,0,
318575,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MainThread,,true,,,MainThread,,,0,
318579,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Receive,,true,,,Receive,,,0,
318585,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,delegate,,true,,,delegate,,,0,
318591,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetAutoAttach,,true,,,SetAutoAttach,,,0,
318596,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetWaitOnStart,,true,,,SetWaitOnStart,,,0,
318601,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MakeDelegateThreadSafe,,true,,,MakeDelegateThreadSafe,,,0,
318606,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,attachedToWorker,,true,,,attachedToWorker,,,0,
318613,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WorkerInfo,,true,,,WorkerInfo,,,0,
318619,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,receivedMessageFromWorker,,true,,,receivedMessageFromWorker,,,0,
318625,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Utf8ToStringView,,true,,,Utf8ToStringView,,,0,
318629,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,detachedFromWorker,,true,,,detachedFromWorker,,,0,
318634,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetWorkerManager,,true,,,GetWorkerManager,,,0,
318638,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WorkerStarted,,true,,,WorkerStarted,,,0,
318644,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WorkerFinished,,true,,,WorkerFinished,,,0,
318649,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Expired,,true,,,Expired,,,0,
318653,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Report,,true,,,Report,,,0,
318659,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetWaitOnStartForDelegate,,true,,,SetWaitOnStartForDelegate,,,0,
318665,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RemoveAttachDelegate,,true,,,RemoveAttachDelegate,,,0,
318670,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,callback,,true,,,callback,,,0,
318674,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,exchange,,true,,,exchange,,,0,
318680,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsActive,,true,,,IsActive,,,0,
318684,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WaitForDisconnect,,true,,,WaitForDisconnect,,,0,
318687,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StartIoThread,,true,,,StartIoThread,,,0,
318691,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StringView,,true,,,StringView,,,0,
318696,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,thread_id,,true,,,thread_id,,,0,
318700,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,connect,,true,,,connect,,,0,
318708,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Wire,,true,,,Wire,,,0,
318713,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.make_unique<protocol.RuntimeAgent>,,true,,,std.make_unique<protocol.RuntimeAgent>,,,0,
318717,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,disable,,true,,,disable,,,0,
318721,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,per_process.Debug,,true,,,per_process.Debug,,,0,
318728,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,protocol.DictionaryValue.cast,,true,,,protocol.DictionaryValue.cast,,,0,
318733,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,protocol.StringUtil.parseMessage,,true,,,protocol.StringUtil.parseMessage,,,0,
318739,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,parseCommand,,true,,,parseCommand,,,0,
318746,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8_inspector.V8InspectorSession.canDispatchMethod,,true,,,v8_inspector.V8InspectorSession.canDispatchMethod,,,0,
318751,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dispatchProtocolMessage,,true,,,dispatchProtocolMessage,,,0,
318756,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dispatch,,true,,,dispatch,,,0,
318764,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,schedulePauseOnNextStatement,,true,,,schedulePauseOnNextStatement,,,0,
318769,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,notifyWaitingForDisconnect,,true,,,notifyWaitingForDisconnect,,,0,
318773,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sendMessageToFrontend,,true,,,sendMessageToFrontend,,,0,
318777,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,serializeToJSON,,true,,,serializeToJSON,,,0,
318781,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.String.NewFromUtf8,,true,,,v8.String.NewFromUtf8,,,0,
318788,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,V8Inspector.create,,true,,,V8Inspector.create,,,0,
318794,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetHumanReadableProcessName,,true,,,GetHumanReadableProcessName,,,0,
318797,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetWorkerLabel,,true,,,GetWorkerLabel,,,0,
318801,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,contextCreated,,true,,,contextCreated,,,0,
318807,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NodeInspectorClient.runMessageLoop,,true,,,runMessageLoop,,,0,
318810,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DisableAsyncHook,,true,,,DisableAsyncHook,,,0,
318813,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EnableAsyncHook,,true,,,EnableAsyncHook,,,0,
318816,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8info,,true,,,v8info,,,0,
318822,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,contextDestroyed,,true,,,contextDestroyed,,,0,
318827,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NodeInspectorClient.getWorkerManager,,true,,,getWorkerManager,,,0,
318830,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NodeInspectorClient.getThreadHandle,,true,,,getThreadHandle,,,0,
318833,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,retainingContext,,true,,,retainingContext,,,0,
318837,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,inspector_console_extension_installer,,true,,,inspector_console_extension_installer,,,0,
318841,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ScriptId,,true,,,ScriptId,,,0,
318845,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetScriptOrigin,,true,,,GetScriptOrigin,,,0,
318849,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetFrameCount,,true,,,GetFrameCount,,,0,
318853,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetScriptId,,true,,,GetScriptId,,,0,
318857,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetFrame,,true,,,GetFrame,,,0,
318863,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,exceptionThrown,,true,,,exceptionThrown,,,0,
318876,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ToProtocolString,,true,,,ToProtocolString,,,0,
318881,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetScriptResourceName,,true,,,GetScriptResourceName,,,0,
318885,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetLineNumber,,true,,,GetLineNumber,,,0,
318889,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetStartColumn,,true,,,GetStartColumn,,,0,
318894,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,createStackTrace,,true,,,createStackTrace,,,0,
318899,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.make_tuple,,true,,,std.make_tuple,,,0,
318905,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,asyncTaskScheduled,,true,,,asyncTaskScheduled,,,0,
318912,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,asyncTaskCanceled,,true,,,asyncTaskCanceled,,,0,
318917,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,asyncTaskStarted,,true,,,asyncTaskStarted,,,0,
318922,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,asyncTaskFinished,,true,,,asyncTaskFinished,,,0,
318927,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,allAsyncTasksCanceled,,true,,,allAsyncTasksCanceled,,,0,
318931,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,preventShutdown,,true,,,preventShutdown,,,0,
318935,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NodeInspectorClient.hasConnectedSessions,,true,,,hasConnectedSessions,,,0,
318938,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NodeInspectorClient.shouldRunMessageLoop,,true,,,shouldRunMessageLoop,,,0,
318941,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WaitForFrontendEvent,,true,,,WaitForFrontendEvent,,,0,
318945,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CurrentClockTimeMillis,,true,,,CurrentClockTimeMillis,,,0,
318949,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsFilePath,,true,,,IsFilePath,,,0,
318953,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,owns_inspector,,true,,,owns_inspector,,,0,
318957,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StartDebugSignalHandler,,true,,,StartDebugSignalHandler,,,0,
318960,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,wait_for_connect,,true,,,wait_for_connect,,,0,
318964,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WaitForConnect,,true,,,WaitForConnect,,,0,
318968,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getThreadHandle,,true,,,getThreadHandle,,,0,
318972,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,has_serialized_options,,true,,,has_serialized_options,,,0,
318976,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EnableBreakFirstLine,,true,,,EnableBreakFirstLine,,,0,
318980,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,get_debug_options,,true,,,get_debug_options,,,0,
318984,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,waitForFrontend,,true,,,waitForFrontend,,,0,
318988,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InspectorIo.Start,,true,,,InspectorIo.Start,,,0,
318996,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std::unique_ptr<InspectorSession>,,true,,,std::unique_ptr<InspectorSession>,,,0,
319000,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,connectFrontend,,true,,,connectFrontend,,,0,
319006,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,hasConnectedSessions,,true,,,hasConnectedSessions,,,0,
319010,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,waitForSessionsDisconnect,,true,,,waitForSessionsDisconnect,,,0,
319014,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StopAcceptingNewConnections,,true,,,StopAcceptingNewConnections,,,0,
319018,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsListening,,true,,,IsListening,,,0,
319022,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReportUncaughtException,,true,,,ReportUncaughtException,,,0,
319028,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_inspector_enable_async_hooks,,true,,,set_inspector_enable_async_hooks,,,0,
319033,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_inspector_disable_async_hooks,,true,,,set_inspector_disable_async_hooks,,,0,
319038,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,inspector_enable_async_hooks,,true,,,inspector_enable_async_hooks,,,0,
319042,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ToggleAsyncHook,,true,,,ToggleAsyncHook,,,0,
319047,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PrintCaughtException,,true,,,PrintCaughtException,,,0,
319053,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AsyncTaskScheduled,,true,,,AsyncTaskScheduled,,,0,
319060,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AsyncTaskCanceled,,true,,,AsyncTaskCanceled,,,0,
319065,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AsyncTaskStarted,,true,,,AsyncTaskStarted,,,0,
319070,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AsyncTaskFinished,,true,,,AsyncTaskFinished,,,0,
319075,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AllAsyncTasksCanceled,,true,,,AllAsyncTasksCanceled,,,0,
319079,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_async_send,,true,,,uv_async_send,,,0,
319083,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std::unique_ptr<ParentInspectorHandle>,,true,,,std::unique_ptr<ParentInspectorHandle>,,,0,
319087,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NewParentHandle,,true,,,NewParentHandle,,,0,
319094,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getWorkerManager,,true,,,getWorkerManager,,,0,
319098,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NewParentInspectorHandle,,true,,,NewParentInspectorHandle,,,0,
319105,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std::unique_ptr<WorkerManager>,,true,,,std::unique_ptr<WorkerManager>,,,0,
319109,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetWsUrl,,true,,,GetWsUrl,,,0,
319113,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,disconnectFrontend,,true,,,disconnectFrontend,,,0,
319118,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dispatchMessageFromFrontend,,true,,,dispatchMessageFromFrontend,,,0,
319124,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node.ContainerOf,,true,,,node.ContainerOf,,,0,
319130,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DoDispatch,,true,,,DoDispatch,,,0,
319134,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_fs_realpath,,true,,,uv_fs_realpath,,,0,
319141,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,crypto.CSPRNG,,true,,,crypto.CSPRNG,,,0,
319147,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TerminateConnections,,true,,,TerminateConnections,,,0,
319151,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Stop,,true,,,Stop,,,0,
319155,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RequestQueueData.GetMessages,,true,,,GetMessages,,,0,
319158,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetServer,,true,,,SetServer,,,0,
319163,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_thread_create,,true,,,uv_thread_create,,,0,
319169,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_thread_join,,true,,,uv_thread_join,,,0,
319173,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ThreadMain,,true,,,ThreadMain,,,0,
319177,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,queue,,true,,,queue,,,0,
319182,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ScriptPath,,true,,,ScriptPath,,,0,
319187,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,host_port,,true,,,host_port,,,0,
319191,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,host,,true,,,host,,,0,
319195,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,port,,true,,,port,,,0,
319199,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,server,,true,,,server,,,0,
319207,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,handle,,true,,,handle,,,0,
319211,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_port,,true,,,set_port,,,0,
319216,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Port,,true,,,Port,,,0,
319220,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FormatWsAddress,,true,,,FormatWsAddress,,,0,
319227,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ConnectToMainThread,,true,,,ConnectToMainThread,,,0,
319233,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,String.NewFromTwoByte,,true,,,String.NewFromTwoByte,,,0,
319241,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OnMessage,,true,,,OnMessage,,,0,
319246,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ConnectionType.Connect,,true,,,ConnectionType.Connect,,,0,
319252,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,14 env 0.isolate,,true,,,isolate,,,0,
319256,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ConnectionType.GetClassName,,true,,,ConnectionType.GetClassName,,,0,
319261,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Disconnect,,true,,,Disconnect,,,0,
319266,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_inspector_console_extension_installer,,true,,,set_inspector_console_extension_installer,,,0,
319271,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,call_args,,true,,,call_args,,,0,
319276,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PauseOnNextJavascriptStatement,,true,,,PauseOnNextJavascriptStatement,,,0,
319281,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<v8.Function>,,true,,,As<v8.Function>,,,0,
319285,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InspectorEnabled,,true,,,InspectorEnabled,,,0,
319289,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_in_inspector_console_call,,true,,,is_in_inspector_console_call,,,0,
319293,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_is_in_inspector_console_call,,true,,,set_is_in_inspector_console_call,,,0,
319298,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,env->inspector_agent()->*asyncTaskFn,,true,,,env->inspector_agent()->*asyncTaskFn,,,0,
319303,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetAsyncTask,,true,,,GetAsyncTask,,,0,
319307,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,task_name_value,,true,,,task_name_value,,,0,
319312,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,task_name_view,,true,,,task_name_view,,,0,
319317,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RegisterAsyncHook,,true,,,RegisterAsyncHook,,,0,
319324,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_host,,true,,,set_host,,,0,
319329,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.Local<v8.Signature>,,true,,,v8.Local<v8.Signature>,,,0,
319333,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetName,,true,,,SetName,,,0,
319338,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetExtrasBindingObject,,true,,,GetExtrasBindingObject,,,0,
319342,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,JSBindingsConnection<LocalConnection>.Bind,,true,,,JSBindingsConnection<LocalConnection>.Bind,,,0,
319348,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,JSBindingsConnection<MainThreadConnection>.Bind,,true,,,JSBindingsConnection<MainThreadConnection>.Bind,,,0,
319354,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EndStartedProfilers,,true,,,EndStartedProfilers,,,0,
319358,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,next_id,,true,,,next_id,,,0,
319361,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteFileSync,,true,,,WriteFileSync,,,0,
319366,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_err_name_r,,true,,,uv_err_name_r,,,0,
319372,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.JSON.Parse,,true,,,v8.JSON.Parse,,,0,
319378,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HasProfileId,,true,,,HasProfileId,,,0,
319383,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteProfile,,true,,,WriteProfile,,,0,
319388,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RemoveProfileId,,true,,,RemoveProfileId,,,0,
319393,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fs.MKDirpSync,,true,,,fs.MKDirpSync,,,0,
319402,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetCurrentTimeInMicroseconds,,true,,,GetCurrentTimeInMicroseconds,,,0,
319405,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetProfile,,true,,,GetProfile,,,0,
319409,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.JSON.Stringify,,true,,,v8.JSON.Stringify,,,0,
319415,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetDirectory,,true,,,GetDirectory,,,0,
319418,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EnsureDirectory,,true,,,EnsureDirectory,,,0,
319423,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetFilename,,true,,,GetFilename,,,0,
319426,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteResult,,true,,,WriteResult,,,0,
319432,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,source_map_cache_getter,,true,,,source_map_cache_getter,,,0,
319436,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,coverage_directory,,true,,,coverage_directory,,,0,
319440,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DispatchMessage,,true,,,DispatchMessage,,,0,
319446,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TakeCoverage,,true,,,TakeCoverage,,,0,
319450,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,cpu_prof_dir,,true,,,cpu_prof_dir,,,0,
319454,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,cpu_prof_name,,true,,,cpu_prof_name,,,0,
319458,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,cpu_prof_interval,,true,,,cpu_prof_interval,,,0,
319462,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,heap_prof_dir,,true,,,heap_prof_dir,,,0,
319466,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,heap_prof_name,,true,,,heap_prof_name,,,0,
319470,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,heap_prof_interval,,true,,,heap_prof_interval,,,0,
319474,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,cpu_profiler_connection,,true,,,cpu_profiler_connection,,,0,
319478,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,heap_profiler_connection,,true,,,heap_profiler_connection,,,0,
319482,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,coverage_connection,,true,,,coverage_connection,,,0,
319486,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_coverage_connection,,true,,,set_coverage_connection,,,0,
319491,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_cpu_prof_interval,,true,,,set_cpu_prof_interval,,,0,
319496,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_cpu_prof_dir,,true,,,set_cpu_prof_dir,,,0,
319501,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,filename,,true,,,filename,,,0,
319506,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_cpu_prof_name,,true,,,set_cpu_prof_name,,,0,
319511,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_cpu_profiler_connection,,true,,,set_cpu_profiler_connection,,,0,
319516,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_heap_prof_interval,,true,,,set_heap_prof_interval,,,0,
319521,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_heap_prof_dir,,true,,,set_heap_prof_dir,,,0,
319526,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_heap_prof_name,,true,,,set_heap_prof_name,,,0,
319531,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_heap_profiler_connection,,true,,,set_heap_profiler_connection,,,0,
319536,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,directory,,true,,,directory,,,0,
319541,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_coverage_directory,,true,,,set_coverage_directory,,,0,
319546,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_source_map_cache_getter,,true,,,set_source_map_cache_getter,,,0,
319551,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StopCoverage,,true,,,StopCoverage,,,0,
319555,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node.inspector.anonymous_namespace_5.WriteRequest.from_write_req,,true,,,WriteRequest.from_write_req,,,0,
319560,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SHA1,,true,,,SHA1,,,0,
319566,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node.base64_encode,,true,,,node.base64_encode,,,0,
319574,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,rfind,,true,,,rfind,,,0,
319579,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.copy,,true,,,std.copy,,,0,
319586,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.all_of,,true,,,std.all_of,,,0,
319593,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operators>.assignmentArithmeticShiftRight,,true,,,<operators>.assignmentArithmeticShiftRight,,,0,
319598,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operators>.assignmentShiftLeft,,true,,,<operators>.assignmentShiftLeft,,,0,
319603,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.xor,,true,,,<operator>.xor,,,0,
319608,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WsHandler.ParseWsFrames,,true,,,ParseWsFrames,,,0,
319612,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,remove_from_beginning,,true,,,remove_from_beginning,,,0,
319617,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,encode_frame_hybi17,,true,,,encode_frame_hybi17,,,0,
319621,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteRaw,,true,,,WriteRaw,,,0,
319627,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WsHandler.SendClose,,true,,,SendClose,,,0,
319630,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node.inspector.anonymous_namespace_27.WriteRequest.from_write_req,,true,,,WriteRequest.from_write_req,,,0,
319635,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,handler->*cb,,true,,,handler->*cb,,,0,
319639,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.vector<char>,,true,,,std.vector<char>,,,0,
319645,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,decode_frame_hybi17,,true,,,decode_frame_hybi17,,,0,
319653,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WsHandler.OnEof,,true,,,OnEof,,,0,
319656,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,this->*OnCloseReceived,,true,,,this->*OnCloseReceived,,,0,
319660,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OnWsFrame,,true,,,OnWsFrame,,,0,
319665,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WsHandler.delegate,,true,,,delegate,,,0,
319668,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,llhttp_init,,true,,,llhttp_init,,,0,
319674,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,llhttp_settings_init,,true,,,llhttp_settings_init,,,0,
319678,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,generate_accept_string,,true,,,generate_accept_string,,,0,
319683,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,reply,,true,,,reply,,,0,
319688,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SwitchProtocol,,true,,,SwitchProtocol,,,0,
319693,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,llhttp_execute,,true,,,llhttp_execute,,,0,
319699,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,llhttp_resume_after_upgrade,,true,,,llhttp_resume_after_upgrade,,,0,
319703,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HttpHandler.CancelHandshake,,true,,,CancelHandshake,,,0,
319706,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HttpHandler.IsAllowedHost,,true,,,IsAllowedHost,,,0,
319710,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OnHttpGet,,true,,,OnHttpGet,,,0,
319716,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HttpHandler.delegate,,true,,,delegate,,,0,
319719,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OnSocketUpgrade,,true,,,OnSocketUpgrade,,,0,
319726,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node.inspector.anonymous_namespace_57.WriteRequest.from_write_req,,true,,,WriteRequest.from_write_req,,,0,
319731,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node.inspector.anonymous_namespace_58.WriteRequest.Cleanup,,true,,,WriteRequest.Cleanup,,,0,
319737,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,inspector,,true,,,inspector,,,0,
319741,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node.inspector.anonymous_namespace_61.HttpHandler.From,,true,,,From,,,0,
319745,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,append,,true,,,append,,,0,
319751,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node.inspector.anonymous_namespace_64.HttpHandler.From,,true,,,From,,,0,
319755,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node.inspector.anonymous_namespace_67.HttpHandler.From,,true,,,From,,,0,
319759,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node.inspector.anonymous_namespace_71.HttpHandler.From,,true,,,From,,,0,
319763,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HeaderValue,,true,,,HeaderValue,,,0,
319768,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node.StringEqualNoCaseN,,true,,,node.StringEqualNoCaseN,,,0,
319775,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TrimPort,,true,,,TrimPort,,,0,
319779,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsIPAddress,,true,,,IsIPAddress,,,0,
319783,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node.StringEqualNoCase,,true,,,node.StringEqualNoCase,,,0,
319789,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetHandler,,true,,,SetHandler,,,0,
319794,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_tcp_getsockname,,true,,,uv_tcp_getsockname,,,0,
319800,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tcp,,true,,,tcp,,,0,
319804,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_ip6_name,,true,,,uv_ip6_name,,,0,
319810,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_ip4_name,,true,,,uv_ip4_name,,,0,
319816,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_tcp_init,,true,,,uv_tcp_init,,,0,
319821,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_read_start,,true,,,uv_read_start,,,0,
319827,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TcpHolder.Pointer,,true,,,TcpHolder.Pointer,,,0,
319832,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_write,,true,,,uv_write,,,0,
319840,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReclaimUvBuf,,true,,,ReclaimUvBuf,,,0,
319846,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OnEof,,true,,,OnEof,,,0,
319850,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OnData,,true,,,OnData,,,0,
319855,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Shutdown,,true,,,Shutdown,,,0,
319859,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TcpHolder.Accept,,true,,,TcpHolder.Accept,,,0,
319865,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InspectorSocket.Pointer,,true,,,InspectorSocket.Pointer,,,0,
319870,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AcceptUpgrade,,true,,,AcceptUpgrade,,,0,
319875,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CancelHandshake,,true,,,CancelHandshake,,,0,
319879,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetHost,,true,,,GetHost,,,0,
319883,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MapToString,,true,,,MapToString,,,0,
319887,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StringEqualNoCaseN,,true,,,StringEqualNoCaseN,,,0,
319893,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SendHttpResponse,,true,,,SendHttpResponse,,,0,
319899,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,inflateInit,,true,,,inflateInit,,,0,
319903,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,inflate,,true,,,inflate,,,0,
319908,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,inflateEnd,,true,,,inflateEnd,,,0,
319912,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FormatAddress,,true,,,FormatAddress,,,0,
319918,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FormatHostPort,,true,,,FormatHostPort,,,0,
319923,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SessionTerminated,,true,,,SessionTerminated,,,0,
319928,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Session,,true,,,Session,,,0,
319932,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FromTcpSocket,,true,,,FromTcpSocket,,,0,
319936,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AssignServer,,true,,,AssignServer,,,0,
319941,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TargetExists,,true,,,TargetExists,,,0,
319945,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Decline,,true,,,Decline,,,0,
319949,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Accept,,true,,,Accept,,,0,
319955,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StartSession,,true,,,StartSession,,,0,
319961,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EndSession,,true,,,EndSession,,,0,
319966,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PrintDebuggerReadyMessage,,true,,,PrintDebuggerReadyMessage,,,0,
319975,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetTargetIds,,true,,,GetTargetIds,,,0,
319979,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ws_socket,,true,,,ws_socket,,,0,
319983,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SendHttpNotFound,,true,,,SendHttpNotFound,,,0,
319987,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MatchPathSegment,,true,,,MatchPathSegment,,,0,
319992,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SendListResponse,,true,,,SendListResponse,,,0,
319998,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SendProtocolJson,,true,,,SendProtocolJson,,,0,
320002,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SendVersionResponse,,true,,,SendVersionResponse,,,0,
320006,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"std.map<std.string, std.string>",,true,,,"std.map<std.string, std.string>",,,0,
320010,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetTargetTitle,,true,,,GetTargetTitle,,,0,
320015,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetTargetUrl,,true,,,GetTargetUrl,,,0,
320020,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,server_port,,true,,,server_port,,,0,
320024,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetFrontendURL,,true,,,GetFrontendURL,,,0,
320029,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MapsToString,,true,,,MapsToString,,,0,
320033,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_getaddrinfo,,true,,,uv_getaddrinfo,,,0,
320042,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ServerSocketPtr,,true,,,ServerSocketPtr,,,0,
320046,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Listen,,true,,,Listen,,,0,
320052,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,done,,true,,,done,,,0,
320055,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.find,,true,,,std.find,,,0,
320062,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,session,,true,,,session,,,0,
320066,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InspectorSocket.DelegatePointer,,true,,,InspectorSocket.DelegatePointer,,,0,
320071,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,id,,true,,,id,,,0,
320075,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InspectorSocket.Accept,,true,,,InspectorSocket.Accept,,,0,
320081,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Own,,true,,,Own,,,0,
320086,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HandleGetRequest,,true,,,HandleGetRequest,,,0,
320093,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Delegate.Session,,true,,,Session,,,0,
320096,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SessionStarted,,true,,,SessionStarted,,,0,
320103,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MessageReceived,,true,,,MessageReceived,,,0,
320109,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ntohs,,true,,,ntohs,,,0,
320113,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_tcp_bind,,true,,,uv_tcp_bind,,,0,
320119,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_listen,,true,,,uv_listen,,,0,
320125,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ServerSocket.DetectPort,,true,,,DetectPort,,,0,
320128,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ServerSocket.FromTcpSocket,,true,,,ServerSocket.FromTcpSocket,,,0,
320133,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,napi_env.terminatedOrTerminating,,true,,,terminatedOrTerminating,,,0,
320137,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.String.NewFromOneByte,,true,,,v8.String.NewFromOneByte,,,0,
320145,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.String.NewFromTwoByte,,true,,,v8.String.NewFromTwoByte,,,0,
320153,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,js_native_api.hpp,js_native_api.hpp:40:40:NAPI_AUTO_LENGTH:0,,true,40,40,NAPI_AUTO_LENGTH,,,0,
320156,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.string_view,,true,,,std.string_view,,,0,
320162,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.String.NewExternalOneByte,,true,,,v8.String.NewExternalOneByte,,,0,
320168,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.u16string_view,,true,,,std.u16string_view,,,0,
320173,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.String.NewExternalTwoByte,,true,,,v8.String.NewExternalTwoByte,,,0,
320179,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,js_native_api_v8.hpp,js_native_api_v8.hpp:191:196:CHECK_ENV:1,,true,191,196,CHECK_ENV,,,0,
320183,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,js_native_api_v8.hpp,js_native_api_v8.hpp:198:199:CHECK_ARG:2,,true,198,199,CHECK_ARG,,,0,
320188,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,js_native_api_v8.hpp,js_native_api_v8.hpp:176:181:RETURN_STATUS_IF_FALSE:3,,true,176,181,RETURN_STATUS_IF_FALSE,,,0,
320193,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,string_maker,,true,,,string_maker,,,0,
320197,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,js_native_api_v8.hpp,js_native_api_v8.hpp:205:206:CHECK_MAYBE_EMPTY:3,,true,205,206,CHECK_MAYBE_EMPTY,,,0,
320203,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"15 11 3 str_maybe 0 0.CHECK_MAYBE_EMPTY(env, str_maybe, napi_generic_failure)",,true,,,"CHECK_MAYBE_EMPTY(env, str_maybe, napi_generic_failure)",,,0,
320207,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NewString,,true,,,NewString,,,0,
320215,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TrackedStringResource.Link,,true,,,Link,,,0,
320219,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TrackedStringResource.Unlink,,true,,,Unlink,,,0,
320222,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TrackedStringResource.finalize_callback_,,true,,,finalize_callback_,,,0,
320228,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,js_native_api_v8.cc,js_native_api_v8.cc:38:39:CHECK_NEW_FROM_UTF8:3,,true,38,39,CHECK_NEW_FROM_UTF8,,,0,
320234,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CHECK_NEW_FROM_UTF8(env, *result, p->utf8name)",,true,,,"CHECK_NEW_FROM_UTF8(env, *result, p->utf8name)",,,0,
320238,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"RETURN_STATUS_IF_FALSE(env, property_value->IsName(), napi_name_expected)",,true,,,"RETURN_STATUS_IF_FALSE(env, property_value->IsName(), napi_name_expected)",,,0,
320242,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,js_native_api_v8.hpp,js_native_api_v8.hpp:212:222:NAPI_PREAMBLE:1,,true,212,222,NAPI_PREAMBLE,,,0,
320246,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NAPI_PREAMBLE(env),,true,,,NAPI_PREAMBLE(env),,,0,
320250,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,napi_env__.NAPI_PREAMBLE(env),,true,,,NAPI_PREAMBLE(env),,,0,
320254,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,napi_env.context,,true,,,context,,,0,
320258,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NodePersistentFromJsDeferred,,true,,,NodePersistentFromJsDeferred,,,0,
320262,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<v8.Promise.Resolver>,,true,,,As<v8.Promise.Resolver>,,,0,
320266,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Resolve,,true,,,Resolve,,,0,
320271,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Reject,,true,,,Reject,,,0,
320276,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"RETURN_STATUS_IF_FALSE(env, success.FromMaybe(false), napi_generic_failure)",,true,,,"RETURN_STATUS_IF_FALSE(env, success.FromMaybe(false), napi_generic_failure)",,,0,
320281,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,js_native_api_v8.hpp,js_native_api_v8.hpp:258:261:GET_RETURN_STATUS:1,,true,258,261,GET_RETURN_STATUS,,,0,
320285,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TryCatch.GET_RETURN_STATUS(env),,true,,,GET_RETURN_STATUS(env),,,0,
320289,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"RETURN_STATUS_IF_FALSE(env, value->IsObject(), napi_invalid_arg)",,true,,,"RETURN_STATUS_IF_FALSE(env, value->IsObject(), napi_invalid_arg)",,,0,
320293,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<v8.Object>,,true,,,As<v8.Object>,,,0,
320297,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,js_native_api_v8_internals.hpp,js_native_api_v8_internals.hpp:27:28:NAPI_PRIVATE_KEY:2,,true,27,28,NAPI_PRIVATE_KEY,,,0,
320301,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NAPI_PRIVATE_KEY(context, wrapper)",,true,,,"NAPI_PRIVATE_KEY(context, wrapper)",,,0,
320306,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"RETURN_STATUS_IF_FALSE(env, val->IsExternal(), napi_invalid_arg)",,true,,,"RETURN_STATUS_IF_FALSE(env, val->IsExternal(), napi_invalid_arg)",,,0,
320310,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<v8.External>,,true,,,As<v8.External>,,,0,
320314,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DeletePrivate,,true,,,DeletePrivate,,,0,
320320,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ownership,,true,,,ownership,,,0,
320324,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ResetFinalizer,,true,,,ResetFinalizer,,,0,
320328,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.External.New,,true,,,v8.External.New,,,0,
320334,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Reference.New,,true,,,Reference.New,,,0,
320345,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,napi_env.CallIntoModule,,true,,,CallIntoModule,,,0,
320350,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetReturnValue,,true,,,SetReturnValue,,,0,
320355,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,cbwrapper,,true,,,cbwrapper,,,0,
320359,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FunctionCallbackWrapper.InvokeCallback,,true,,,InvokeCallback,,,0,
320363,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8impl.anonymous_namespace_53.CallbackBundle.New.v8impl.CallbackBundle.New,,true,,,v8impl.CallbackBundle.New,,,0,
320370,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"RETURN_STATUS_IF_FALSE(env, !cbdata.IsEmpty(), napi_generic_failure)",,true,,,"RETURN_STATUS_IF_FALSE(env, !cbdata.IsEmpty(), napi_generic_failure)",,,0,
320374,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.Function.New,,true,,,v8.Function.New,,,0,
320381,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CHECK_MAYBE_EMPTY(env, maybe_function, napi_generic_failure)",,true,,,"CHECK_MAYBE_EMPTY(env, maybe_function, napi_generic_failure)",,,0,
320385,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8impl.anonymous_namespace_56.CallbackBundle.New.v8impl.CallbackBundle.New,,true,,,v8impl.CallbackBundle.New,,,0,
320392,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.FunctionTemplate.New,,true,,,v8.FunctionTemplate.New,,,0,
320404,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NewTarget,,true,,,NewTarget,,,0,
320408,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"RETURN_STATUS_IF_FALSE(
      env,
      !obj->HasPrivate(context, NAPI_PRIVATE_KEY(context, wrapper)).FromJust(),
      napi_invalid_arg)",,true,,,"RETURN_STATUS_IF_FALSE(
      env,
      !obj->HasPrivate(context, NAPI_PRIVATE_KEY(context, wrapper)).FromJust(),
      napi_invalid_arg)",,,0,
320413,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsSymbol,,true,,,IsSymbol,,,0,
320417,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RefBase.Link,,true,,,Link,,,0,
320421,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RefBase.Unlink,,true,,,Unlink,,,0,
320424,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RefBase.ResetFinalizer,,true,,,ResetFinalizer,,,0,
320427,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Reference.RefCount,,true,,,RefCount,,,0,
320430,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Reference.SetWeak,,true,,,SetWeak,,,0,
320433,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Reference.RefBase.Ref,,true,,,RefBase.Ref,,,0,
320437,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Reference.RefBase.Unref,,true,,,RefBase.Unref,,,0,
320441,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.Local<v8.Value>,,true,,,v8.Local<v8.Value>,,,0,
320445,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Reference.RefBase.Finalize,,true,,,RefBase.Finalize,,,0,
320449,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,js_native_api_v8_internals.hpp,js_native_api_v8_internals.hpp:22:22:NAPI_ARRAYSIZE:1,,true,22,22,NAPI_ARRAYSIZE,,,0,
320453,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NAPI_ARRAYSIZE(error_messages),,true,,,NAPI_ARRAYSIZE(error_messages),,,0,
320458,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,js_native_api_v8.hpp,js_native_api_v8.hpp:282:286:STATUS_CALL:1,,true,282,286,STATUS_CALL,,,0,
320461,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"STATUS_CALL(v8impl.FunctionCallbackWrapper.NewFunction(
      env, cb, callback_data, &fn))",,true,,,"STATUS_CALL(v8impl.FunctionCallbackWrapper.NewFunction(
      env, cb, callback_data, &fn))",,,0,
320469,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,js_native_api_v8.cc,js_native_api_v8.cc:23:36:CHECK_NEW_FROM_UTF8_LEN:4,,true,23,36,CHECK_NEW_FROM_UTF8_LEN,,,0,
320476,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",,true,,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",,,0,
320480,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"STATUS_CALL(v8impl.FunctionCallbackWrapper.NewTemplate(
      env, constructor, callback_data, &tpl))",,true,,,"STATUS_CALL(v8impl.FunctionCallbackWrapper.NewTemplate(
      env, constructor, callback_data, &tpl))",,,0,
320488,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"STATUS_CALL(v8impl.V8NameFromPropertyDescriptor(env, p, &property_name))",,true,,,"STATUS_CALL(v8impl.V8NameFromPropertyDescriptor(env, p, &property_name))",,,0,
320495,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8impl.V8PropertyAttributesFromDescriptor,,true,,,v8impl.V8PropertyAttributesFromDescriptor,,,0,
320500,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"STATUS_CALL(v8impl.FunctionCallbackWrapper.NewTemplate(
            env, p->getter, p->data, &getter_tpl))",,true,,,"STATUS_CALL(v8impl.FunctionCallbackWrapper.NewTemplate(
            env, p->getter, p->data, &getter_tpl))",,,0,
320508,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"STATUS_CALL(v8impl.FunctionCallbackWrapper.NewTemplate(
            env, p->setter, p->data, &setter_tpl))",,true,,,"STATUS_CALL(v8impl.FunctionCallbackWrapper.NewTemplate(
            env, p->setter, p->data, &setter_tpl))",,,0,
320516,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"STATUS_CALL(v8impl.FunctionCallbackWrapper.NewTemplate(
          env, p->method, p->data, &t, v8.Signature.New(isolate, tpl)))",,true,,,"STATUS_CALL(v8impl.FunctionCallbackWrapper.NewTemplate(
          env, p->method, p->data, &t, v8.Signature.New(isolate, tpl)))",,,0,
320522,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"STATUS_CALL(napi_define_properties(
        env, *result, static_descriptors.size(), static_descriptors.data()))",,true,,,"STATUS_CALL(napi_define_properties(
        env, *result, static_descriptors.size(), static_descriptors.data()))",,,0,
320526,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,js_native_api_v8.hpp,js_native_api_v8.hpp:248:249:CHECK_TO_OBJECT:4,,true,248,249,CHECK_TO_OBJECT,,,0,
320533,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CHECK_TO_OBJECT(env, context, obj, object)",,true,,,"CHECK_TO_OBJECT(env, context, obj, object)",,,0,
320537,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetPropertyNames,,true,,,GetPropertyNames,,,0,
320542,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,js_native_api_v8.hpp,js_native_api_v8.hpp:279:280:CHECK_MAYBE_EMPTY_WITH_PREAMBLE:3,,true,279,280,CHECK_MAYBE_EMPTY_WITH_PREAMBLE,,,0,
320548,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CHECK_MAYBE_EMPTY_WITH_PREAMBLE(
      env, maybe_all_propertynames, napi_generic_failure)",,true,,,"CHECK_MAYBE_EMPTY_WITH_PREAMBLE(
      env, maybe_all_propertynames, napi_generic_failure)",,,0,
320552,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TryCatch.CHECK_MAYBE_EMPTY_WITH_PREAMBLE(
      env, maybe_all_propertynames, napi_generic_failure)",,true,,,"CHECK_MAYBE_EMPTY_WITH_PREAMBLE(
      env, maybe_all_propertynames, napi_generic_failure)",,,0,
320556,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure)",,true,,,"RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure)",,,0,
320561,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,js_native_api_v8.cc,js_native_api_v8.cc:10:11:CHECK_MAYBE_NOTHING:3,,true,10,11,CHECK_MAYBE_NOTHING,,,0,
320567,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure)",,true,,,"CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure)",,,0,
320571,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CHECK_MAYBE_EMPTY(env, get_maybe, napi_generic_failure)",,true,,,"CHECK_MAYBE_EMPTY(env, get_maybe, napi_generic_failure)",,,0,
320575,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CHECK_MAYBE_NOTHING(env, delete_maybe, napi_generic_failure)",,true,,,"CHECK_MAYBE_NOTHING(env, delete_maybe, napi_generic_failure)",,,0,
320579,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"RETURN_STATUS_IF_FALSE(env, k->IsName(), napi_name_expected)",,true,,,"RETURN_STATUS_IF_FALSE(env, k->IsName(), napi_name_expected)",,,0,
320583,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",,true,,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",,,0,
320587,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"STATUS_CALL(v8impl.FunctionCallbackWrapper.NewFunction(
            env, p->getter, p->data, &local_getter))",,true,,,"STATUS_CALL(v8impl.FunctionCallbackWrapper.NewFunction(
            env, p->getter, p->data, &local_getter))",,,0,
320595,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"STATUS_CALL(v8impl.FunctionCallbackWrapper.NewFunction(
            env, p->setter, p->data, &local_setter))",,true,,,"STATUS_CALL(v8impl.FunctionCallbackWrapper.NewFunction(
            env, p->setter, p->data, &local_setter))",,,0,
320603,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"STATUS_CALL(v8impl.FunctionCallbackWrapper.NewFunction(
          env, p->method, p->data, &method))",,true,,,"STATUS_CALL(v8impl.FunctionCallbackWrapper.NewFunction(
          env, p->method, p->data, &method))",,,0,
320611,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CreateDataProperty,,true,,,CreateDataProperty,,,0,
320618,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetIntegrityLevel,,true,,,SetIntegrityLevel,,,0,
320624,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,js_native_api_v8.hpp,js_native_api_v8.hpp:271:277:RETURN_STATUS_IF_FALSE_WITH_PREAMBLE:3,,true,271,277,RETURN_STATUS_IF_FALSE_WITH_PREAMBLE,,,0,
320630,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, set_frozen.FromMaybe(false), napi_generic_failure)",,true,,,"RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, set_frozen.FromMaybe(false), napi_generic_failure)",,,0,
320635,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TryCatch.RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, set_frozen.FromMaybe(false), napi_generic_failure)",,true,,,"RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, set_frozen.FromMaybe(false), napi_generic_failure)",,,0,
320639,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, set_sealed.FromMaybe(false), napi_generic_failure)",,true,,,"RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, set_sealed.FromMaybe(false), napi_generic_failure)",,,0,
320644,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TryCatch.RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, set_sealed.FromMaybe(false), napi_generic_failure)",,true,,,"RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, set_sealed.FromMaybe(false), napi_generic_failure)",,,0,
320648,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"RETURN_STATUS_IF_FALSE(env, val->IsArray(), napi_array_expected)",,true,,,"RETURN_STATUS_IF_FALSE(env, val->IsArray(), napi_array_expected)",,,0,
320652,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<v8.Array>,,true,,,As<v8.Array>,,,0,
320656,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StrictEquals,,true,,,StrictEquals,,,0,
320661,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetPrototype,,true,,,GetPrototype,,,0,
320665,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.Object.New,,true,,,v8.Object.New,,,0,
320670,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.Array.New,,true,,,v8.Array.New,,,0,
320676,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8impl.NewString,,true,,,v8impl.NewString,,,0,
320685,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8impl.NewExternalString,,true,,,v8impl.NewExternalString,,,0,
320698,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.Integer.New,,true,,,v8.Integer.New,,,0,
320704,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.Integer.NewFromUnsigned,,true,,,v8.Integer.NewFromUnsigned,,,0,
320710,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.BigInt.New,,true,,,v8.BigInt.New,,,0,
320716,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.BigInt.NewFromUnsigned,,true,,,v8.BigInt.NewFromUnsigned,,,0,
320722,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.BigInt.NewFromWords,,true,,,v8.BigInt.NewFromWords,,,0,
320730,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, b, napi_generic_failure)",,true,,,"CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, b, napi_generic_failure)",,,0,
320734,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TryCatch.CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, b, napi_generic_failure)",,true,,,"CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, b, napi_generic_failure)",,,0,
320738,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.True,,true,,,v8.True,,,0,
320743,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.False,,true,,,v8.False,,,0,
320748,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.Symbol.New,,true,,,v8.Symbol.New,,,0,
320754,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"RETURN_STATUS_IF_FALSE(env, desc->IsString(), napi_string_expected)",,true,,,"RETURN_STATUS_IF_FALSE(env, desc->IsString(), napi_string_expected)",,,0,
320758,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<v8.String>,,true,,,As<v8.String>,,,0,
320762,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.Symbol.For,,true,,,v8.Symbol.For,,,0,
320768,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"RETURN_STATUS_IF_FALSE(env, code_value->IsString(), napi_string_expected)",,true,,,"RETURN_STATUS_IF_FALSE(env, code_value->IsString(), napi_string_expected)",,,0,
320772,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CHECK_NEW_FROM_UTF8(env, code_value, code_cstring)",,true,,,"CHECK_NEW_FROM_UTF8(env, code_value, code_cstring)",,,0,
320776,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CHECK_NEW_FROM_UTF8(env, code_key, ""code"")",,true,,,"CHECK_NEW_FROM_UTF8(env, code_key, ""code"")",,,0,
320780,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"RETURN_STATUS_IF_FALSE(
        env, set_maybe.FromMaybe(false), napi_generic_failure)",,true,,,"RETURN_STATUS_IF_FALSE(
        env, set_maybe.FromMaybe(false), napi_generic_failure)",,,0,
320785,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected)",,true,,,"RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected)",,,0,
320789,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.Exception.Error,,true,,,v8.Exception.Error,,,0,
320794,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.Exception.TypeError,,true,,,v8.Exception.TypeError,,,0,
320799,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.Exception.RangeError,,true,,,v8.Exception.RangeError,,,0,
320804,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.Exception.SyntaxError,,true,,,v8.Exception.SyntaxError,,,0,
320809,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsExternal,,true,,,IsExternal,,,0,
320813,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Args,,true,,,Args,,,0,
320816,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ArgsLength,,true,,,ArgsLength,,,0,
320820,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetNewTarget,,true,,,GetNewTarget,,,0,
320824,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,js_native_api_v8.hpp,js_native_api_v8.hpp:240:246:CHECK_TO_FUNCTION:3,,true,240,246,CHECK_TO_FUNCTION,,,0,
320830,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CHECK_TO_FUNCTION(env, v8func, func)",,true,,,"CHECK_TO_FUNCTION(env, v8func, func)",,,0,
320834,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TryCatch.HasCaught,,true,,,HasCaught,,,0,
320838,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure)",,true,,,"CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure)",,,0,
320842,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CHECK_NEW_FROM_UTF8(env, str, msg)",,true,,,"CHECK_NEW_FROM_UTF8(env, str, msg)",,,0,
320846,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsNativeError,,true,,,IsNativeError,,,0,
320850,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected)",,true,,,"RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected)",,,0,
320854,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.isfinite,,true,,,std.isfinite,,,0,
320859,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"RETURN_STATUS_IF_FALSE(env, val->IsBigInt(), napi_bigint_expected)",,true,,,"RETURN_STATUS_IF_FALSE(env, val->IsBigInt(), napi_bigint_expected)",,,0,
320863,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<v8.BigInt>,,true,,,As<v8.BigInt>,,,0,
320867,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Uint64Value,,true,,,Uint64Value,,,0,
320872,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WordCount,,true,,,WordCount,,,0,
320876,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ToWordsArray,,true,,,ToWordsArray,,,0,
320883,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"RETURN_STATUS_IF_FALSE(env, val->IsBoolean(), napi_boolean_expected)",,true,,,"RETURN_STATUS_IF_FALSE(env, val->IsBoolean(), napi_boolean_expected)",,,0,
320887,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<v8.Boolean>,,true,,,As<v8.Boolean>,,,0,
320891,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected)",,true,,,"RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected)",,,0,
320895,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteOneByte,,true,,,WriteOneByte,,,0,
320904,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ToBoolean,,true,,,ToBoolean,,,0,
320909,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",,true,,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",,,0,
320914,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"napi_env__.GEN_COERCE_FUNCTION(NUMBER, Number, number)",,true,,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",,,0,
320918,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"napi_env.GEN_COERCE_FUNCTION(NUMBER, Number, number)",,true,,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",,,0,
320922,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TryCatch.GEN_COERCE_FUNCTION(NUMBER, Number, number)",,true,,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",,,0,
320926,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",,true,,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",,,0,
320931,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"napi_env__.GEN_COERCE_FUNCTION(OBJECT, Object, object)",,true,,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",,,0,
320935,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"napi_env.GEN_COERCE_FUNCTION(OBJECT, Object, object)",,true,,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",,,0,
320939,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TryCatch.GEN_COERCE_FUNCTION(OBJECT, Object, object)",,true,,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",,,0,
320943,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"GEN_COERCE_FUNCTION(STRING, String, string)",,true,,,"GEN_COERCE_FUNCTION(STRING, String, string)",,,0,
320948,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"napi_env__.GEN_COERCE_FUNCTION(STRING, String, string)",,true,,,"GEN_COERCE_FUNCTION(STRING, String, string)",,,0,
320952,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"napi_env.GEN_COERCE_FUNCTION(STRING, String, string)",,true,,,"GEN_COERCE_FUNCTION(STRING, String, string)",,,0,
320956,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TryCatch.GEN_COERCE_FUNCTION(STRING, String, string)",,true,,,"GEN_COERCE_FUNCTION(STRING, String, string)",,,0,
320960,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8impl.Wrap,,true,,,v8impl.Wrap,,,0,
320970,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8impl.Unwrap,,true,,,v8impl.Unwrap,,,0,
320978,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,js_native_api_v8.hpp,js_native_api_v8.hpp:251:253:CHECK_TO_OBJECT_WITH_PREAMBLE:4,,true,251,253,CHECK_TO_OBJECT_WITH_PREAMBLE,,,0,
320985,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TryCatch.CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object)",,true,,,"CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object)",,,0,
320989,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object)",,true,,,"CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object)",,,0,
320993,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,js_native_api_v8.hpp,js_native_api_v8.hpp:201:203:CHECK_ARG_WITH_PREAMBLE:2,,true,201,203,CHECK_ARG_WITH_PREAMBLE,,,0,
320998,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TryCatch.CHECK_ARG_WITH_PREAMBLE(env, type_tag)",,true,,,"CHECK_ARG_WITH_PREAMBLE(env, type_tag)",,,0,
321002,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NAPI_PRIVATE_KEY(context, type_tag)",,true,,,"NAPI_PRIVATE_KEY(context, type_tag)",,,0,
321007,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HasPrivate,,true,,,HasPrivate,,,0,
321013,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,js_native_api_v8.cc,js_native_api_v8.cc:13:14:CHECK_MAYBE_NOTHING_WITH_PREAMBLE:3,,true,13,14,CHECK_MAYBE_NOTHING_WITH_PREAMBLE,,,0,
321019,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CHECK_MAYBE_NOTHING_WITH_PREAMBLE(env, maybe_has, napi_generic_failure)",,true,,,"CHECK_MAYBE_NOTHING_WITH_PREAMBLE(env, maybe_has, napi_generic_failure)",,,0,
321023,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TryCatch.CHECK_MAYBE_NOTHING_WITH_PREAMBLE(env, maybe_has, napi_generic_failure)",,true,,,"CHECK_MAYBE_NOTHING_WITH_PREAMBLE(env, maybe_has, napi_generic_failure)",,,0,
321027,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, !maybe_has.FromJust(), napi_invalid_arg)",,true,,,"RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, !maybe_has.FromJust(), napi_invalid_arg)",,,0,
321031,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TryCatch.RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, !maybe_has.FromJust(), napi_invalid_arg)",,true,,,"RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, !maybe_has.FromJust(), napi_invalid_arg)",,,0,
321035,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, tag, napi_generic_failure)",,true,,,"CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, tag, napi_generic_failure)",,,0,
321039,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TryCatch.CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, tag, napi_generic_failure)",,true,,,"CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, tag, napi_generic_failure)",,,0,
321043,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CHECK_MAYBE_NOTHING_WITH_PREAMBLE(env, maybe_set, napi_generic_failure)",,true,,,"CHECK_MAYBE_NOTHING_WITH_PREAMBLE(env, maybe_set, napi_generic_failure)",,,0,
321047,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TryCatch.CHECK_MAYBE_NOTHING_WITH_PREAMBLE(env, maybe_set, napi_generic_failure)",,true,,,"CHECK_MAYBE_NOTHING_WITH_PREAMBLE(env, maybe_set, napi_generic_failure)",,,0,
321051,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, maybe_set.FromJust(), napi_generic_failure)",,true,,,"RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, maybe_set.FromJust(), napi_generic_failure)",,,0,
321055,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TryCatch.RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, maybe_set.FromJust(), napi_generic_failure)",,true,,,"RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, maybe_set.FromJust(), napi_generic_failure)",,,0,
321059,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TryCatch.CHECK_ARG_WITH_PREAMBLE(env, result)",,true,,,"CHECK_ARG_WITH_PREAMBLE(env, result)",,,0,
321063,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, maybe_value, napi_generic_failure)",,true,,,"CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, maybe_value, napi_generic_failure)",,,0,
321067,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TryCatch.CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, maybe_value, napi_generic_failure)",,true,,,"CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, maybe_value, napi_generic_failure)",,,0,
321071,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,js_native_api.hpp,js_native_api.hpp:9:9:NAPI_VERSION_EXPERIMENTAL:0,,true,9,9,NAPI_VERSION_EXPERIMENTAL,,,0,
321074,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Ref,,true,,,Ref,,,0,
321078,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RefCount,,true,,,RefCount,,,0,
321082,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Unref,,true,,,Unref,,,0,
321086,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8impl.JsHandleScopeFromV8HandleScope,,true,,,v8impl.JsHandleScopeFromV8HandleScope,,,0,
321091,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8impl.V8HandleScopeFromJsHandleScope,,true,,,v8impl.V8HandleScopeFromJsHandleScope,,,0,
321096,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8impl.JsEscapableHandleScopeFromV8EscapableHandleScope,,true,,,v8impl.JsEscapableHandleScopeFromV8EscapableHandleScope,,,0,
321101,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8impl.V8EscapableHandleScopeFromJsEscapableHandleScope,,true,,,v8impl.V8EscapableHandleScopeFromJsEscapableHandleScope,,,0,
321106,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,escape_called,,true,,,escape_called,,,0,
321110,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CHECK_TO_FUNCTION(env, ctor, constructor)",,true,,,"CHECK_TO_FUNCTION(env, ctor, constructor)",,,0,
321114,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CHECK_MAYBE_EMPTY(env, maybe, napi_pending_exception)",,true,,,"CHECK_MAYBE_EMPTY(env, maybe, napi_pending_exception)",,,0,
321118,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CHECK_TO_OBJECT(env, context, ctor, constructor)",,true,,,"CHECK_TO_OBJECT(env, context, ctor, constructor)",,,0,
321122,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InstanceOf,,true,,,InstanceOf,,,0,
321128,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CHECK_MAYBE_NOTHING(env, maybe_result, status)",,true,,,"CHECK_MAYBE_NOTHING(env, maybe_result, status)",,,0,
321132,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.ArrayBuffer.New,,true,,,v8.ArrayBuffer.New,,,0,
321138,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"RETURN_STATUS_IF_FALSE(env, value->IsArrayBuffer(), napi_invalid_arg)",,true,,,"RETURN_STATUS_IF_FALSE(env, value->IsArrayBuffer(), napi_invalid_arg)",,,0,
321142,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<v8.ArrayBuffer>,,true,,,As<v8.ArrayBuffer>,,,0,
321146,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsTypedArray,,true,,,IsTypedArray,,,0,
321150,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,js_native_api_v8.cc,js_native_api_v8.cc:41:58:CREATE_TYPED_ARRAY:7,,true,41,58,CREATE_TYPED_ARRAY,,,0,
321159,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CREATE_TYPED_ARRAY(
          env, Int8Array, 1, buffer, byte_offset, length, typedArray)",,true,,,"CREATE_TYPED_ARRAY(
          env, Int8Array, 1, buffer, byte_offset, length, typedArray)",,,0,
321166,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CREATE_TYPED_ARRAY(
          env, Uint8Array, 1, buffer, byte_offset, length, typedArray)",,true,,,"CREATE_TYPED_ARRAY(
          env, Uint8Array, 1, buffer, byte_offset, length, typedArray)",,,0,
321173,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CREATE_TYPED_ARRAY(
          env, Uint8ClampedArray, 1, buffer, byte_offset, length, typedArray)",,true,,,"CREATE_TYPED_ARRAY(
          env, Uint8ClampedArray, 1, buffer, byte_offset, length, typedArray)",,,0,
321180,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CREATE_TYPED_ARRAY(
          env, Int16Array, 2, buffer, byte_offset, length, typedArray)",,true,,,"CREATE_TYPED_ARRAY(
          env, Int16Array, 2, buffer, byte_offset, length, typedArray)",,,0,
321187,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CREATE_TYPED_ARRAY(
          env, Uint16Array, 2, buffer, byte_offset, length, typedArray)",,true,,,"CREATE_TYPED_ARRAY(
          env, Uint16Array, 2, buffer, byte_offset, length, typedArray)",,,0,
321194,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CREATE_TYPED_ARRAY(
          env, Int32Array, 4, buffer, byte_offset, length, typedArray)",,true,,,"CREATE_TYPED_ARRAY(
          env, Int32Array, 4, buffer, byte_offset, length, typedArray)",,,0,
321201,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CREATE_TYPED_ARRAY(
          env, Uint32Array, 4, buffer, byte_offset, length, typedArray)",,true,,,"CREATE_TYPED_ARRAY(
          env, Uint32Array, 4, buffer, byte_offset, length, typedArray)",,,0,
321208,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CREATE_TYPED_ARRAY(
          env, Float32Array, 4, buffer, byte_offset, length, typedArray)",,true,,,"CREATE_TYPED_ARRAY(
          env, Float32Array, 4, buffer, byte_offset, length, typedArray)",,,0,
321215,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CREATE_TYPED_ARRAY(
          env, Float64Array, 8, buffer, byte_offset, length, typedArray)",,true,,,"CREATE_TYPED_ARRAY(
          env, Float64Array, 8, buffer, byte_offset, length, typedArray)",,,0,
321222,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CREATE_TYPED_ARRAY(
          env, BigInt64Array, 8, buffer, byte_offset, length, typedArray)",,true,,,"CREATE_TYPED_ARRAY(
          env, BigInt64Array, 8, buffer, byte_offset, length, typedArray)",,,0,
321229,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CREATE_TYPED_ARRAY(
          env, BigUint64Array, 8, buffer, byte_offset, length, typedArray)",,true,,,"CREATE_TYPED_ARRAY(
          env, BigUint64Array, 8, buffer, byte_offset, length, typedArray)",,,0,
321236,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"RETURN_STATUS_IF_FALSE(env, value->IsTypedArray(), napi_invalid_arg)",,true,,,"RETURN_STATUS_IF_FALSE(env, value->IsTypedArray(), napi_invalid_arg)",,,0,
321240,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<v8.TypedArray>,,true,,,As<v8.TypedArray>,,,0,
321244,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsInt8Array,,true,,,IsInt8Array,,,0,
321248,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsUint8ClampedArray,,true,,,IsUint8ClampedArray,,,0,
321252,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsInt16Array,,true,,,IsInt16Array,,,0,
321256,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsUint16Array,,true,,,IsUint16Array,,,0,
321260,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsInt32Array,,true,,,IsInt32Array,,,0,
321264,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsUint32Array,,true,,,IsUint32Array,,,0,
321268,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsFloat32Array,,true,,,IsFloat32Array,,,0,
321272,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsFloat64Array,,true,,,IsFloat64Array,,,0,
321276,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsBigInt64Array,,true,,,IsBigInt64Array,,,0,
321280,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsBigUint64Array,,true,,,IsBigUint64Array,,,0,
321284,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.DataView.New,,true,,,v8.DataView.New,,,0,
321291,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsDataView,,true,,,IsDataView,,,0,
321295,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"RETURN_STATUS_IF_FALSE(env, value->IsDataView(), napi_invalid_arg)",,true,,,"RETURN_STATUS_IF_FALSE(env, value->IsDataView(), napi_invalid_arg)",,,0,
321299,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<v8.DataView>,,true,,,As<v8.DataView>,,,0,
321303,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_version.hpp,node_version.hpp:96:96:NAPI_VERSION:0,,true,96,96,NAPI_VERSION,,,0,
321306,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.Promise.Resolver.New,,true,,,v8.Promise.Resolver.New,,,0,
321311,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8impl.JsDeferredFromNodePersistent,,true,,,v8impl.JsDeferredFromNodePersistent,,,0,
321316,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetPromise,,true,,,GetPromise,,,0,
321320,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8impl.ConcludeDeferred,,true,,,v8impl.ConcludeDeferred,,,0,
321328,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsPromise,,true,,,IsPromise,,,0,
321332,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.Date.New,,true,,,v8.Date.New,,,0,
321338,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CHECK_MAYBE_EMPTY(env, maybe_date, napi_generic_failure)",,true,,,"CHECK_MAYBE_EMPTY(env, maybe_date, napi_generic_failure)",,,0,
321342,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsDate,,true,,,IsDate,,,0,
321346,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"RETURN_STATUS_IF_FALSE(env, val->IsDate(), napi_date_expected)",,true,,,"RETURN_STATUS_IF_FALSE(env, val->IsDate(), napi_date_expected)",,,0,
321350,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<v8.Date>,,true,,,As<v8.Date>,,,0,
321354,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueOf,,true,,,ValueOf,,,0,
321358,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.Script.Compile,,true,,,v8.Script.Compile,,,0,
321364,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CHECK_MAYBE_EMPTY(env, maybe_script, napi_generic_failure)",,true,,,"CHECK_MAYBE_EMPTY(env, maybe_script, napi_generic_failure)",,,0,
321368,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CHECK_MAYBE_EMPTY(env, script_result, napi_generic_failure)",,true,,,"CHECK_MAYBE_EMPTY(env, script_result, napi_generic_failure)",,,0,
321372,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"RETURN_STATUS_IF_FALSE(env, v8_value->IsObject(), napi_invalid_arg)",,true,,,"RETURN_STATUS_IF_FALSE(env, v8_value->IsObject(), napi_invalid_arg)",,,0,
321376,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"RETURN_STATUS_IF_FALSE(
      env, value->IsArrayBuffer(), napi_arraybuffer_expected)",,true,,,"RETURN_STATUS_IF_FALSE(
      env, value->IsArrayBuffer(), napi_arraybuffer_expected)",,,0,
321380,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"RETURN_STATUS_IF_FALSE(
      env, it->IsDetachable(), napi_detachable_arraybuffer_expected)",,true,,,"RETURN_STATUS_IF_FALSE(
      env, it->IsDetachable(), napi_detachable_arraybuffer_expected)",,,0,
321384,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WasDetached,,true,,,WasDetached,,,0,
321388,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Finalize,,true,,,Finalize,,,0,
321392,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8impl.PersistentToLocal.Strong,,true,,,v8impl.PersistentToLocal.Strong,,,0,
321397,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsExecutionTerminating,,true,,,IsExecutionTerminating,,,0,
321401,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,call,,true,,,call,,,0,
321405,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,handle_exception,,true,,,handle_exception,,,0,
321410,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CallIntoModule,,true,,,CallIntoModule,,,0,
321415,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_version.hpp,node_version.hpp:100:100:NODE_API_DEFAULT_MODULE_API_VERSION:0,,true,100,100,NODE_API_DEFAULT_MODULE_API_VERSION,,,0,
321418,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Exception,,true,,,Exception,,,0,
321422,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StreamBase.AttachToObject,,true,,,StreamBase.AttachToObject,,,0,
321427,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isclosing_string,,true,,,isclosing_string,,,0,
321431,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,onreadstart_string,,true,,,onreadstart_string,,,0,
321435,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,onreadstop_string,,true,,,onreadstop_string,,,0,
321439,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,onshutdown_string,,true,,,onshutdown_string,,,0,
321443,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,bufs_arr,,true,,,bufs_arr,,,0,
321447,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,onwrite_string,,true,,,onwrite_string,,,0,
321451,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StreamReq.FromObject,,true,,,StreamReq.FromObject,,,0,
321456,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,js_udp_wrap.cc,js_udp_wrap.cc:9:9:JS_EXCEPTION_PENDING:0,,true,9,9,JS_EXCEPTION_PENDING,,,0,
321459,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,buffers,,true,,,buffers,,,0,
321463,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddressToJS,,true,,,AddressToJS,,,0,
321468,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CreateSendWrap,,true,,,CreateSendWrap,,,0,
321473,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,listener,,true,,,listener,,,0,
321477,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SocketAddress.New,,true,,,SocketAddress.New,,,0,
321485,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,address,,true,,,address,,,0,
321490,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sockaddr_for_family,,true,,,sockaddr_for_family,,,0,
321497,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OnAlloc,,true,,,OnAlloc,,,0,
321502,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OnRecv,,true,,,OnRecv,,,0,
321510,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OnSendDone,,true,,,OnSendDone,,,0,
321516,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OnAfterBind,,true,,,OnAfterBind,,,0,
321520,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,UDPWrapBase.AddMethods,,true,,,UDPWrapBase.AddMethods,,,0,
321526,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Platform,,true,,,Platform,,,0,
321530,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_default_loop,,true,,,uv_default_loop,,,0,
321533,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,utf8_value,,true,,,utf8_value,,,0,
321538,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,indent,,true,,,indent,,,0,
321543,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Evaluate,,true,,,Evaluate,,,0,
321548,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetInternalField,,true,,,SetInternalField,,,0,
321554,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,equal_range,,true,,,equal_range,,,0,
321559,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetInternalField,,true,,,GetInternalField,,,0,
321564,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ContextifyContext.ContextFromContextifiedSandbox,,true,,,ContextifyContext.ContextFromContextifiedSandbox,,,0,
321570,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PrimitiveArray.New,,true,,,PrimitiveArray.New,,,0,
321576,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,no_abort_scope,,true,,,no_abort_scope,,,0,
321580,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,export_names,,true,,,export_names,,,0,
321584,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Module.CreateSyntheticModule,,true,,,Module.CreateSyntheticModule,,,0,
321592,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,origin,,true,,,origin,,,0,
321600,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,source,,true,,,source,,,0,
321604,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetCachedData,,true,,,GetCachedData,,,0,
321608,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ScriptCompiler.CompileModule,,true,,,ScriptCompiler.CompileModule,,,0,
321615,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Message,,true,,,Message,,,0,
321618,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AppendExceptionLine,,true,,,AppendExceptionLine,,,0,
321625,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_VM_MODULE_CACHED_DATA_REJECTED,,true,,,THROW_ERR_VM_MODULE_CACHED_DATA_REJECTED,,,0,
321630,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,url_string,,true,,,url_string,,,0,
321634,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<Value>,,true,,,As<Value>,,,0,
321638,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetModuleRequests,,true,,,GetModuleRequests,,,0,
321642,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,promises,,true,,,promises,,,0,
321646,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<ModuleRequest>,,true,,,As<ModuleRequest>,,,0,
321650,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetSpecifier,,true,,,GetSpecifier,,,0,
321654,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,specifier_utf8,,true,,,specifier_utf8,,,0,
321659,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,specifier_std,,true,,,specifier_std,,,0,
321664,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetImportAssertions,,true,,,GetImportAssertions,,,0,
321668,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,createImportAssertionContainer,,true,,,createImportAssertionContainer,,,0,
321674,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_VM_MODULE_LINK_FAILURE,,true,,,THROW_ERR_VM_MODULE_LINK_FAILURE,,,0,
321680,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<Promise>,,true,,,As<Promise>,,,0,
321684,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InstantiateModule,,true,,,InstantiateModule,,,0,
321690,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,microtask_queue,,true,,,microtask_queue,,,0,
321694,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,safe_for_termination,,true,,,safe_for_termination,,,0,
321698,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,wd,,true,,,wd,,,0,
321704,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,swd,,true,,,swd,,,0,
321709,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,run,,true,,,run,,,0,
321712,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CancelTerminateExecution,,true,,,CancelTerminateExecution,,,0,
321716,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_SCRIPT_EXECUTION_TIMEOUT,,true,,,THROW_ERR_SCRIPT_EXECUTION_TIMEOUT,,,0,
321721,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_SCRIPT_EXECUTION_INTERRUPTED,,true,,,THROW_ERR_SCRIPT_EXECUTION_INTERRUPTED,,,0,
321725,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetStatus,,true,,,GetStatus,,,0,
321729,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetModuleNamespace,,true,,,GetModuleNamespace,,,0,
321733,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,specifiers,,true,,,specifiers,,,0,
321737,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetException,,true,,,GetException,,,0,
321741,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_EXECUTION_ENVIRONMENT_NOT_AVAILABLE,,true,,,THROW_ERR_EXECUTION_ENVIRONMENT_NOT_AVAILABLE,,,0,
321745,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MaybeLocal<Module>,,true,,,MaybeLocal<Module>,,,0,
321748,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetFromModule,,true,,,GetFromModule,,,0,
321753,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,State,,true,,,State,,,0,
321757,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Result,,true,,,Result,,,0,
321761,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MaybeLocal<Promise>,,true,,,MaybeLocal<Promise>,,,0,
321764,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,host_import_module_dynamically_callback,,true,,,host_import_module_dynamically_callback,,,0,
321768,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<FixedArray>,,true,,,As<FixedArray>,,,0,
321772,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Promise.Resolver.New,,true,,,Promise.Resolver.New,,,0,
321777,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ModuleWrap.GetFromID,,true,,,ModuleWrap.GetFromID,,,0,
321783,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_host_import_module_dynamically_callback,,true,,,set_host_import_module_dynamically_callback,,,0,
321788,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetHostImportModuleDynamicallyCallback,,true,,,SetHostImportModuleDynamicallyCallback,,,0,
321793,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,host_initialize_import_meta_object_callback,,true,,,host_initialize_import_meta_object_callback,,,0,
321797,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_host_initialize_import_meta_object_callback,,true,,,set_host_initialize_import_meta_object_callback,,,0,
321802,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetHostInitializeImportMetaObjectCallback,,true,,,SetHostInitializeImportMetaObjectCallback,,,0,
321807,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetSyntheticModuleExport,,true,,,SetSyntheticModuleExport,,,0,
321814,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetUnboundModuleScript,,true,,,GetUnboundModuleScript,,,0,
321818,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module_wrap.cc,module_wrap.cc:797:801:V:1,,true,797,801,V,,,0,
321821,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,V(kUninstantiated),,true,,,V(kUninstantiated),,,0,
321825,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,V(kInstantiating),,true,,,V(kInstantiating),,,0,
321829,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,V(kInstantiated),,true,,,V(kInstantiated),,,0,
321833,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,V(kEvaluating),,true,,,V(kEvaluating),,,0,
321837,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,V(kEvaluated),,true,,,V(kEvaluated),,,0,
321841,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,V(kErrored),,true,,,V(kErrored),,,0,
321845,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetAtomicsWaitCallback,,true,,,SetAtomicsWaitCallback,,,0,
321851,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_embedder_entry_point,,true,,,set_embedder_entry_point,,,0,
321856,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TearDownOncePerProcess,,true,,,TearDownOncePerProcess,,,0,
321859,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,STRINGIFY,,true,,,STRINGIFY,,,0,
321863,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node.cc,node.cc:207:213:ATOMIC_WAIT_EVENTS:1,,true,207,213,ATOMIC_WAIT_EVENTS,,,0,
321866,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddBuildEmbedderGraphCallback,,true,,,AddBuildEmbedderGraphCallback,,,0,
321872,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddHeapSnapshotNearHeapLimitCallback,,true,,,AddHeapSnapshotNearHeapLimitCallback,,,0,
321876,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ExecuteBootstrapper,,true,,,ExecuteBootstrapper,,,0,
321880,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,callback_scope,,true,,,callback_scope,,,0,
321885,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_building_snapshot,,true,,,is_building_snapshot,,,0,
321889,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RunSnapshotDeserializeMain,,true,,,RunSnapshotDeserializeMain,,,0,
321893,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,argv,,true,,,argv,,,0,
321897,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_guess_handle,,true,,,uv_guess_handle,,,0,
321901,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_lock_free,,true,,,is_lock_free,,,0,
321905,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_tty_reset_mode,,true,,,uv_tty_reset_mode,,,0,
321908,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,options_parser.Parse,,true,,,options_parser.Parse,,,0,
321918,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Revert,,true,,,Revert,,,0,
321923,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8_args_as_char_ptr,,true,,,v8_args_as_char_ptr,,,0,
321927,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,V8.SetFlagsFromCommandLine,,true,,,V8.SetFlagsFromCommandLine,,,0,
321934,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProcessGlobalArgsInternal,,true,,,ProcessGlobalArgsInternal,,,0,
321941,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_hrtime,,true,,,uv_hrtime,,,0,
321944,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,binding.RegisterBuiltinBindings,,true,,,binding.RegisterBuiltinBindings,,,0,
321948,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_disable_stdio_inheritance,,true,,,uv_disable_stdio_inheritance,,,0,
321951,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,V8.SetFlagsFromString,,true,,,V8.SetFlagsFromString,,,0,
321957,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HandleEnvOptions,,true,,,HandleEnvOptions,,,0,
321962,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ParseNodeOptionsEnvVar,,true,,,ParseNodeOptionsEnvVar,,,0,
321967,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,at,,true,,,at,,,0,
321972,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_set_process_title,,true,,,uv_set_process_title,,,0,
321976,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InitializeNodeWithArgsInternal,,true,,,InitializeNodeWithArgsInternal,,,0,
321983,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.make_unique<InitializationResultImpl>,,true,,,std.make_unique<InitializationResultImpl>,,,0,
321987,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PlatformInit,,true,,,PlatformInit,,,0,
321991,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,exit_code_enum,,true,,,exit_code_enum,,,0,
321995,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,printf,,true,,,printf,,,0,
322000,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_version.hpp,node_version.hpp:65:65:NODE_VERSION:0,,true,65,65,NODE_VERSION,,,0,
322003,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,options_parser.GetBashCompletion,,true,,,options_parser.GetBashCompletion,,,0,
322007,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,V8Platform.Initialize,,true,,,Initialize,,,0,
322012,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,V8Platform.Platform,,true,,,Platform,,,0,
322016,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,V8.Initialize,,true,,,V8.Initialize,,,0,
322020,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PERFORMANCE_NOW,,true,,,PERFORMANCE_NOW,,,0,
322023,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InitializeOncePerProcessInternal,,true,,,InitializeOncePerProcessInternal,,,0,
322027,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ResetStdio,,true,,,ResetStdio,,,0,
322030,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ResetSignalHandlers,,true,,,ResetSignalHandlers,,,0,
322033,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,V8.Dispose,,true,,,V8.Dispose,,,0,
322037,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,V8.DisposePlatform,,true,,,V8.DisposePlatform,,,0,
322041,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,V8Platform.Dispose,,true,,,Dispose,,,0,
322045,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DCHECK_NULL,,true,,,DCHECK_NULL,,,0,
322049,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.make_unique<SnapshotData>,,true,,,std.make_unique<SnapshotData>,,,0,
322053,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,exec_args,,true,,,exec_args,,,0,
322057,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fopen,,true,,,fopen,,,0,
322062,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fclose,,true,,,fclose,,,0,
322066,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SnapshotData.FromFile,,true,,,SnapshotData.FromFile,,,0,
322072,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,main_instance,,true,,,main_instance,,,0,
322080,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_setup_args,,true,,,uv_setup_args,,,0,
322085,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,errors,,true,,,errors,,,0,
322089,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,early_return,,true,,,early_return,,,0,
322093,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_loop_configure,,true,,,uv_loop_configure,,,0,
322098,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sea.BuildSingleExecutableBlob,,true,,,sea.BuildSingleExecutableBlob,,,0,
322103,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GenerateAndWriteSnapshotData,,true,,,GenerateAndWriteSnapshotData,,,0,
322108,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LoadSnapshotDataAndRun,,true,,,LoadSnapshotDataAndRun,,,0,
322113,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sea.FixupArgsForSEA,,true,,,sea.FixupArgsForSEA,,,0,
322119,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StartInternal,,true,,,StartInternal,,,0,
322124,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ExitEnv,,true,,,ExitEnv,,,0,
322129,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ErrnoException,,true,,,ErrnoException,,,0,
322137,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEPRECATED(""Use ErrnoException(isolate, ...)"",
                inline v8.Local<v8.Value> ErrnoException(
      int errorno,
      const char* syscall = nullptr,
      const char* message = nullptr,
      const char* path = nullptr) {
  return ErrnoException(v8.Isolate.GetCurrent(),
                        errorno,
                        syscall,
                        message,
                        path);
})",,true,,,"NODE_DEPRECATED(""Use ErrnoException(isolate, ...)"",
                inline v8.Local<v8.Value> ErrnoException(
      int errorno,
      const char* syscall = nullptr,
      const char* message = nullptr,
      const char* path = nullptr) {
  return ErrnoException(v8.Isolate.GetCurrent(),
                        errorno,
                        syscall,
                        message,
                        path);
})",,,0,
322141,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,UVException,,true,,,UVException,,,0,
322149,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEPRECATED(""Use UVException(isolate, ...)"",
                inline v8.Local<v8.Value> UVException(int errorno,
                                        const char* syscall = nullptr,
                                        const char* message = nullptr,
                                        const char* path = nullptr) {
  return UVException(v8.Isolate.GetCurrent(),
                     errorno,
                     syscall,
                     message,
                     path);
})",,true,,,"NODE_DEPRECATED(""Use UVException(isolate, ...)"",
                inline v8.Local<v8.Value> UVException(int errorno,
                                        const char* syscall = nullptr,
                                        const char* message = nullptr,
                                        const char* path = nullptr) {
  return UVException(v8.Isolate.GetCurrent(),
                     errorno,
                     syscall,
                     message,
                     path);
})",,,0,
322153,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InitializeOncePerProcess,,true,,,InitializeOncePerProcess,,,0,
322158,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,anonymous_type_019181039100049710391000497151146node::CommonEnvironmentSetup335node::CommonEnvironmentSetup::Create0035node::CommonEnvironmentSetup::Create1071::{D:\_Codes\gm-network\lab\Node.js\.src\node.hpp:38575}0.reset,,true,,,reset,,,0,
322162,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,anonymous_type_119181039100049710391000497151146node::CommonEnvironmentSetup535node::CommonEnvironmentSetup::CreateFromSnapshot0035node::CommonEnvironmentSetup::CreateFromSnapshot1035node::CommonEnvironmentSetup::CreateFromSnapshot203node::CommonEnvironmentSetup::Flags::kNoFlags071::{D:\_Codes\gm-network\lab\Node.js\.src\node.hpp:39421}0.reset,,true,,,reset,,,0,
322166,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEPRECATED(""Use v8.Date.New() directly"",
                inline v8.Local<v8.Value> NODE_UNIXTIME_V8(double time) {
                  return v8.Date.New(
                             v8.Isolate.GetCurrent()->GetCurrentContext(),
                             1000 * time)
                      .ToLocalChecked();
                })",,true,,,"NODE_DEPRECATED(""Use v8.Date.New() directly"",
                inline v8.Local<v8.Value> NODE_UNIXTIME_V8(double time) {
                  return v8.Date.New(
                             v8.Isolate.GetCurrent()->GetCurrentContext(),
                             1000 * time)
                      .ToLocalChecked();
                })",,,0,
322170,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEPRECATED(""Use v8.Date.ValueOf() directly"",
                inline double NODE_V8_UNIXTIME(v8.Local<v8.Date> date) {
  return date->ValueOf() / 1000;
})",,true,,,"NODE_DEPRECATED(""Use v8.Date.ValueOf() directly"",
                inline double NODE_V8_UNIXTIME(v8.Local<v8.Date> date) {
  return date->ValueOf() / 1000;
})",,,0,
322174,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.Isolate.GetCurrent,,true,,,v8.Isolate.GetCurrent,,,0,
322178,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.Signature.New,,true,,,v8.Signature.New,,,0,
322184,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AsyncCleanupHookHandle,,true,,,AsyncCleanupHookHandle,,,0,
322188,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddEnvironmentCleanupHookInternal,,true,,,AddEnvironmentCleanupHookInternal,,,0,
322194,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RemoveEnvironmentCleanupHookInternal,,true,,,RemoveEnvironmentCleanupHookInternal,,,0,
322198,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node.AsyncCleanupHookHandle.get,,true,,,get,,,0,
322202,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node_napi_env__.Unref,,true,,,Unref,,,0,
322206,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node_napi_env__.terminatedOrTerminating,,true,,,terminatedOrTerminating,,,0,
322210,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProcessEmitDeprecationWarning,,true,,,ProcessEmitDeprecationWarning,,,0,
322216,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ThreadSafeFunction.call_js_cb,,true,,,call_js_cb,,,0,
322223,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Work._complete,,true,,,_complete,,,0,
322229,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ConvertUVErrorCode,,true,,,ConvertUVErrorCode,,,0,
322233,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node_napi_env__.napi_env__.DeleteMe,,true,,,napi_env__.DeleteMe,,,0,
322237,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node_napi_env__.CallFinalizer<true>,,true,,,CallFinalizer<true>,,,0,
322243,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node_napi_env__.context,,true,,,context,,,0,
322246,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CallbackIntoModule<enforceUncaughtExceptionPolicy>,,true,,,CallbackIntoModule<enforceUncaughtExceptionPolicy>,,,0,
322250,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node_napi_env__.napi_env__.EnqueueFinalizer,,true,,,napi_env__.EnqueueFinalizer,,,0,
322255,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node_napi_env__.Ref,,true,,,Ref,,,0,
322259,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.Exception.CreateMessage,,true,,,v8.Exception.CreateMessage,,,0,
322265,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CallFinalizer,,true,,,CallFinalizer,,,0,
322272,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_version.hpp,node_version.hpp:35:35:NODE_STRINGIFY:1,,true,35,35,NODE_STRINGIFY,,,0,
322275,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node.Environment.GetCurrent,,true,,,node.Environment.GetCurrent,,,0,
322280,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ThrowNodeApiVersionError,,true,,,ThrowNodeApiVersionError,,,0,
322286,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node_napi_env.node_env,,true,,,node_env,,,0,
322290,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,push,,true,,,push,,,0,
322295,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ThreadSafeFunction.Send,,true,,,Send,,,0,
322298,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Signal,,true,,,Signal,,,0,
322303,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pop,,true,,,pop,,,0,
322307,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.make_unique<node.ConditionVariable>,,true,,,std.make_unique<node.ConditionVariable>,,,0,
322311,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ThreadSafeFunction.DispatchOne,,true,,,DispatchOne,,,0,
322314,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ThreadSafeFunction.CloseHandlesAndMaybeDelete,,true,,,CloseHandlesAndMaybeDelete,,,0,
322317,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node_napi_env__.CallbackIntoModule<false>,,true,,,CallbackIntoModule<false>,,,0,
322322,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node_napi_env__.CallFinalizer<false>,,true,,,CallFinalizer<false>,,,0,
322329,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ThreadSafeFunction.EmptyQueueAndDelete,,true,,,EmptyQueueAndDelete,,,0,
322332,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fetch_or,,true,,,fetch_or,,,0,
322337,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CloseHandlesAndMaybeDelete,,true,,,CloseHandlesAndMaybeDelete,,,0,
322342,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AsyncContext.node_env,,true,,,node_env,,,0,
322345,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AsyncContext.EnsureReference,,true,,,EnsureReference,,,0,
322348,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AsyncContext.resource,,true,,,resource,,,0,
322351,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8impl.ThrowNodeApiVersionError,,true,,,v8impl.ThrowNodeApiVersionError,,,0,
322358,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,filename_string,,true,,,filename_string,,,0,
322362,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8impl.NewEnv,,true,,,v8impl.NewEnv,,,0,
322369,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,napi_env.Ref,,true,,,Ref,,,0,
322373,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,napi_async_cleanup_hook_handle__.user_hook_,,true,,,user_hook_,,,0,
322379,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OpenCallbackScope,,true,,,OpenCallbackScope,,,0,
322383,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8impl.anonymous_namespace_70.AsyncContext.CloseCallbackScope.v8impl.AsyncContext.CloseCallbackScope,,true,,,v8impl.AsyncContext.CloseCallbackScope,,,0,
322389,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CHECK_TO_OBJECT(env, context, v8_resource, async_resource)",,true,,,"CHECK_TO_OBJECT(env, context, v8_resource, async_resource)",,,0,
322393,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,js_native_api_v8.hpp,js_native_api_v8.hpp:255:256:CHECK_TO_STRING:4,,true,255,256,CHECK_TO_STRING,,,0,
322400,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CHECK_TO_STRING(env, context, v8_resource_name, async_resource_name)",,true,,,"CHECK_TO_STRING(env, context, v8_resource_name, async_resource_name)",,,0,
322404,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CHECK_TO_OBJECT(env, context, v8recv, recv)",,true,,,"CHECK_TO_OBJECT(env, context, v8recv, recv)",,,0,
322408,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CHECK_MAYBE_EMPTY(env, callback_result, napi_generic_failure)",,true,,,"CHECK_MAYBE_EMPTY(env, callback_result, napi_generic_failure)",,,0,
322412,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8impl.anonymous_namespace_71.BufferFinalizer.New.v8impl.BufferFinalizer.New,,true,,,v8impl.BufferFinalizer.New,,,0,
322420,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_version.hpp,node_version.hpp:25:25:NODE_MAJOR_VERSION:0,,true,25,25,NODE_MAJOR_VERSION,,,0,
322423,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_version.hpp,node_version.hpp:26:26:NODE_MINOR_VERSION:0,,true,26,26,NODE_MINOR_VERSION,,,0,
322426,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_version.hpp,node_version.hpp:27:27:NODE_PATCH_VERSION:0,,true,27,27,NODE_PATCH_VERSION,,,0,
322429,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_version.hpp,node_version.hpp:40:40:NODE_RELEASE:0,,true,40,40,NODE_RELEASE,,,0,
322432,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Work._execute,,true,,,_execute,,,0,
322437,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node_napi_env__.CallbackIntoModule<true>,,true,,,CallbackIntoModule<true>,,,0,
322442,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CHECK_TO_OBJECT(env, context, resource, async_resource)",,true,,,"CHECK_TO_OBJECT(env, context, resource, async_resource)",,,0,
322446,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CHECK_TO_STRING(env, context, resource_name, async_resource_name)",,true,,,"CHECK_TO_STRING(env, context, resource_name, async_resource_name)",,,0,
322450,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvimpl.Work.New,,true,,,uvimpl.Work.New,,,0,
322460,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,anonymous_namespace_84.uvimpl.Work.Delete,,true,,,uvimpl.Work.Delete,,,0,
322465,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ScheduleWork,,true,,,ScheduleWork,,,0,
322468,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_api.cc,node_api.cc:1213:1220:CALL_UV:2,,true,1213,1220,CALL_UV,,,0,
322473,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CALL_UV(env, w->CancelWork())",,true,,,"CALL_UV(env, w->CancelWork())",,,0,
322478,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CHECK_TO_FUNCTION(env, v8_func, func)",,true,,,"CHECK_TO_FUNCTION(env, v8_func, func)",,,0,
322482,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CHECK_TO_OBJECT(env, v8_context, v8_resource, async_resource)",,true,,,"CHECK_TO_OBJECT(env, v8_context, v8_resource, async_resource)",,,0,
322486,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CHECK_TO_STRING(env, v8_context, v8_name, async_resource_name)",,true,,,"CHECK_TO_STRING(env, v8_context, v8_name, async_resource_name)",,,0,
322490,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Context,,true,,,Context,,,0,
322494,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Push,,true,,,Push,,,0,
322499,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Acquire,,true,,,Acquire,,,0,
322503,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Open,,true,,,Open,,,0,
322507,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_DLOPEN_FAILED,,true,,,THROW_ERR_DLOPEN_FAILED,,,0,
322512,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,force_context_aware,,true,,,force_context_aware,,,0,
322516,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_NON_CONTEXT_AWARE_DISABLED,,true,,,THROW_ERR_NON_CONTEXT_AWARE_DISABLED,,,0,
322520,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SaveInGlobalHandleMap,,true,,,SaveInGlobalHandleMap,,,0,
322525,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetInitializerCallback,,true,,,GetInitializerCallback,,,0,
322529,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetNapiInitializerCallback,,true,,,GetNapiInitializerCallback,,,0,
322533,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetNapiAddonGetApiVersionCallback,,true,,,GetNapiAddonGetApiVersionCallback,,,0,
322537,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,get_version,,true,,,get_version,,,0,
322540,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetSavedModuleFromGlobalHandleMap,,true,,,GetSavedModuleFromGlobalHandleMap,,,0,
322544,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,unlock,,true,,,unlock,,,0,
322548,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nm_context_register_func,,true,,,nm_context_register_func,,,0,
322556,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nm_register_func,,true,,,nm_register_func,,,0,
322563,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_dlopen,,true,,,uv_dlopen,,,0,
322568,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_dlerror,,true,,,uv_dlerror,,,0,
322572,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_dlsym,,true,,,uv_dlsym,,,0,
322578,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set,,true,,,set,,,0,
322582,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,get_and_increase_refcount,,true,,,get_and_increase_refcount,,,0,
322587,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetSymbolAddress,,true,,,GetSymbolAddress,,,0,
322592,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,no_native_addons,,true,,,no_native_addons,,,0,
322596,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_DLOPEN_DISABLED,,true,,,THROW_ERR_DLOPEN_DISABLED,,,0,
322601,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,exports_string,,true,,,exports_string,,,0,
322605,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TryLoadAddon,,true,,,TryLoadAddon,,,0,
322612,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NODE_BINDINGS_WITH_PER_ISOLATE_INIT,,true,,,NODE_BINDINGS_WITH_PER_ISOLATE_INIT,,,0,
322616,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,binding_data_default_template,,true,,,binding_data_default_template,,,0,
322620,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetInternalBindingExportObject,,true,,,GetInternalBindingExportObject,,,0,
322626,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,module_v,,true,,,module_v,,,0,
322631,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FindModule,,true,,,FindModule,,,0,
322637,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InitInternalBinding,,true,,,InitInternalBinding,,,0,
322642,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_INVALID_MODULE,,true,,,THROW_ERR_INVALID_MODULE,,,0,
322647,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,module_name_v,,true,,,module_name_v,,,0,
322652,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,extra_linked_bindings_head,,true,,,extra_linked_bindings_head,,,0,
322656,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,worker_parent_env,,true,,,worker_parent_env,,,0,
322660,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,String.NewFromUtf8Literal,,true,,,String.NewFromUtf8Literal,,,0,
322666,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_binding.cc,node_binding.cc:87:91:NODE_BUILTIN_BINDINGS:1,,true,87,91,NODE_BUILTIN_BINDINGS,,,0,
322669,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DataQueue.CreateInMemoryEntryFromBackingStore,,true,,,DataQueue.CreateInMemoryEntryFromBackingStore,,,0,
322676,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,handleScope,,true,,,handleScope,,,0,
322680,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.move(doneCb),,true,,,std.move(doneCb),,,0,
322685,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<ArrayBuffer>,,true,,,As<ArrayBuffer>,,,0,
322689,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,View,,true,,,View,,,0,
322693,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DataQueue.CreateFdEntry,,true,,,DataQueue.CreateFdEntry,,,0,
322699,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Blob.Create,,true,,,Blob.Create,,,0,
322705,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DataQueue.CreateIdempotent,,true,,,DataQueue.CreateIdempotent,,,0,
322710,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Uint32.NewFromUnsigned,,true,,,Uint32.NewFromUnsigned,,,0,
322716,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,blob_constructor_template,,true,,,blob_constructor_template,,,0,
322720,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_blob_constructor_template,,true,,,set_blob_constructor_template,,,0,
322725,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BaseObjectPtr<Blob>,,true,,,BaseObjectPtr<Blob>,,,0,
322728,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,entries,,true,,,entries,,,0,
322732,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,entryFromArrayBuffer,,true,,,entryFromArrayBuffer,,,0,
322738,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Blob.HasInstance,,true,,,Blob.HasInstance,,,0,
322744,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DataQueue.CreateDataQueueEntry,,true,,,DataQueue.CreateDataQueueEntry,,,0,
322749,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Blob.Reader.Create,,true,,,Blob.Reader.Create,,,0,
322755,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Slice,,true,,,Slice,,,0,
322762,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,blob_reader_constructor_template,,true,,,blob_reader_constructor_template,,,0,
322766,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_blob_reader_constructor_template,,true,,,set_blob_reader_constructor_template,,,0,
322771,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BaseObjectPtr<Blob.Reader>,,true,,,BaseObjectPtr<Blob.Reader>,,,0,
322775,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsConstructor,,true,,,IsConstructor,,,0,
322779,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,store_data_object,,true,,,store_data_object,,,0,
322785,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BlobBindingData.StoredDataObject,,true,,,BlobBindingData.StoredDataObject,,,0,
322792,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,get_pathname,,true,,,get_pathname,,,0,
322796,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,revoke_data_object,,true,,,revoke_data_object,,,0,
322801,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,get_data_object,,true,,,get_data_object,,,0,
322806,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BlobBindingData::StoredDataObject,,true,,,BlobBindingData::StoredDataObject,,,0,
322810,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DoPull,,true,,,DoPull,,,0,
322818,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OnBackingStoreFree,,true,,,OnBackingStoreFree,,,0,
322822,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CallAndResetCallback,,true,,,CallAndResetCallback,,,0,
322826,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,buffer_prototype_object,,true,,,buffer_prototype_object,,,0,
322830,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MaybeLocal<Uint8Array>,,true,,,MaybeLocal<Uint8Array>,,,0,
322833,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_BUFFER_CONTEXT_NOT_AVAILABLE,,true,,,THROW_ERR_BUFFER_CONTEXT_NOT_AVAILABLE,,,0,
322837,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_MEMORY_ALLOCATION_FAILED,,true,,,THROW_ERR_MEMORY_ALLOCATION_FAILED,,,0,
322841,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ERR_BUFFER_TOO_LARGE,,true,,,ERR_BUFFER_TOO_LARGE,,,0,
322845,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Local<Uint8Array>,,true,,,Local<Uint8Array>,,,0,
322848,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node.Buffer.anonymous_namespace_17.CallbackInfo.CreateTrackedArrayBuffer,,true,,,CallbackInfo.CreateTrackedArrayBuffer,,,0,
322857,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,untransferable_object_private_symbol,,true,,,untransferable_object_private_symbol,,,0,
322861,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_buffer.cc,node_buffer.cc:41:42:THROW_AND_RETURN_UNLESS_BUFFER:2,,true,41,42,THROW_AND_RETURN_UNLESS_BUFFER,,,0,
322866,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"THROW_AND_RETURN_UNLESS_BUFFER(env, args.This())",,true,,,"THROW_AND_RETURN_UNLESS_BUFFER(env, args.This())",,,0,
322870,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_buffer.cc,node_buffer.cc:44:50:THROW_AND_RETURN_IF_OOB:1,,true,44,50,THROW_AND_RETURN_IF_OOB,,,0,
322873,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ParseArrayIndex,,true,,,ParseArrayIndex,,,0,
322880,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[0], 0, &start))",,true,,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[0], 0, &start))",,,0,
322886,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[1], buffer.length(), &end))",,true,,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[1], buffer.length(), &end))",,,0,
322892,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_AND_RETURN_IF_OOB(Just(end <= buffer.length())),,true,,,THROW_AND_RETURN_IF_OOB(Just(end <= buffer.length())),,,0,
322898,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SPREAD_BUFFER_ARG,,true,,,SPREAD_BUFFER_ARG,,,0,
322903,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], 0, &target_start))",,true,,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], 0, &target_start))",,,0,
322909,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[3], 0, &source_start))",,true,,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[3], 0, &source_start))",,,0,
322915,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[4], source.length(),
                                          &source_end))",,true,,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[4], source.length(),
                                          &source_end))",,,0,
322921,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], 0, &start))",,true,,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], 0, &start))",,,0,
322927,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[3], 0, &end))",,true,,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[3], 0, &end))",,,0,
322933,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsBigEndian,,true,,,IsBigEndian,,,0,
322936,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SwapBytes16,,true,,,SwapBytes16,,,0,
322941,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.assignmentMultiplication,,true,,,<operator>.assignmentMultiplication,,,0,
322946,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[1], 0, &offset))",,true,,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[1], 0, &offset))",,,0,
322952,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node.THROW_ERR_BUFFER_OUT_OF_BOUNDS,,true,,,node.THROW_ERR_BUFFER_OUT_OF_BOUNDS,,,0,
322958,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], ts_obj_length - offset,
                                          &max_length))",,true,,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], ts_obj_length - offset,
                                          &max_length))",,,0,
322964,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,target,,true,,,target,,,0,
322969,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[4], target.length(),
                                          &target_end))",,true,,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[4], target.length(),
                                          &target_end))",,,0,
322975,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[5], source.length(),
                                          &source_end))",,true,,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[5], source.length(),
                                          &source_end))",,,0,
322981,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,normalizeCompareVal,,true,,,normalizeCompareVal,,,0,
322987,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,a,,true,,,a,,,0,
322991,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,b,,true,,,b,,,0,
322995,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IndexOfOffset,,true,,,IndexOfOffset,,,0,
323002,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,needle_value,,true,,,needle_value,,,0,
323007,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Decode,,true,,,Decode,,,0,
323014,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SearchString,,true,,,SearchString,,,0,
323023,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"THROW_AND_RETURN_UNLESS_BUFFER(Environment.GetCurrent(args), args[0])",,true,,,"THROW_AND_RETURN_UNLESS_BUFFER(Environment.GetCurrent(args), args[0])",,,0,
323028,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"THROW_AND_RETURN_UNLESS_BUFFER(Environment.GetCurrent(args), args[1])",,true,,,"THROW_AND_RETURN_UNLESS_BUFFER(Environment.GetCurrent(args), args[1])",,,0,
323033,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,haystack_contents,,true,,,haystack_contents,,,0,
323037,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,needle_contents,,true,,,needle_contents,,,0,
323041,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,memchr,,true,,,memchr,,,0,
323047,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node.stringsearch.MemrchrFill,,true,,,node.stringsearch.MemrchrFill,,,0,
323054,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SwapBytes32,,true,,,SwapBytes32,,,0,
323059,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SwapBytes64,,true,,,SwapBytes64,,,0,
323064,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,abv,,true,,,abv,,,0,
323068,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node.THROW_ERR_INVALID_STATE,,true,,,node.THROW_ERR_INVALID_STATE,,,0,
323074,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simdutf.validate_utf8,,true,,,simdutf.validate_utf8,,,0,
323080,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simdutf.validate_ascii,,true,,,simdutf.validate_ascii,,,0,
323086,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,kind,,true,,,kind,,,0,
323090,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_buffer_prototype_object,,true,,,set_buffer_prototype_object,,,0,
323095,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,zero_fill_field,,true,,,zero_fill_field,,,0,
323099,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Uint32Array.New,,true,,,Uint32Array.New,,,0,
323106,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<SharedArrayBuffer>,,true,,,As<SharedArrayBuffer>,,,0,
323110,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DecomposeBufferToParts,,true,,,DecomposeBufferToParts,,,0,
323114,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetFastMethodNoSideEffect,,true,,,SetFastMethodNoSideEffect,,,0,
323122,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetTypeInfo,,true,,,GetTypeInfo,,,0,
323126,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LoadJavaScriptSource,,true,,,LoadJavaScriptSource,,,0,
323129,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,read,,true,,,read,,,0,
323133,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,write,,true,,,write,,,0,
323137,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ToStringChecked,,true,,,ToStringChecked,,,0,
323142,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std::set<std::string>,,true,,,std::set<std::string>,,,0,
323146,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,UnionBytes,,true,,,UnionBytes,,,0,
323150,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LoadBuiltinSource,,true,,,LoadBuiltinSource,,,0,
323155,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,script_source,,true,,,script_source,,,0,
323160,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AsCachedData,,true,,,AsCachedData,,,0,
323164,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ScriptCompiler.CompileFunction,,true,,,ScriptCompiler.CompileFunction,,,0,
323175,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MaybeLocal<Function>,,true,,,MaybeLocal<Function>,,,0,
323178,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,insert_or_assign,,true,,,insert_or_assign,,,0,
323184,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BuiltinCodeCacheData,,true,,,BuiltinCodeCacheData,,,0,
323188,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LookupAndCompileInternal,,true,,,LookupAndCompileInternal,,,0,
323195,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RecordResult,,true,,,RecordResult,,,0,
323201,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LookupAndCompile,,true,,,LookupAndCompile,,,0,
323208,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetBuiltinIds,,true,,,GetBuiltinIds,,,0,
323212,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,compare,,true,,,compare,,,0,
323219,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetBuiltinCategories,,true,,,GetBuiltinCategories,,,0,
323223,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetConfigString,,true,,,GetConfigString,,,0,
323228,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,id_v,,true,,,id_v,,,0,
323233,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.Boolean.New,,true,,,v8.Boolean.New,,,0,
323239,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,internal_binding_loader,,true,,,internal_binding_loader,,,0,
323243,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_internal_binding_loader,,true,,,set_internal_binding_loader,,,0,
323248,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_builtin_module_require,,true,,,set_builtin_module_require,,,0,
323253,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetAccessor,,true,,,SetAccessor,,,0,
323260,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,config_string,,true,,,config_string,,,0,
323264,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RegisterExternalReferencesForInternalizedBuiltinCode,,true,,,RegisterExternalReferencesForInternalizedBuiltinCode,,,0,
323268,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,READONLY_FALSE_PROPERTY,,true,,,READONLY_FALSE_PROPERTY,,,0,
323273,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,READONLY_TRUE_PROPERTY,,true,,,READONLY_TRUE_PROPERTY,,,0,
323278,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,READONLY_PROPERTY,,true,,,READONLY_PROPERTY,,,0,
323284,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DefineWindowsErrorConstants,,true,,,DefineWindowsErrorConstants,,,0,
323288,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,has_enumerable,,true,,,has_enumerable,,,0,
323292,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,enumerable,,true,,,enumerable,,,0,
323296,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,has_configurable,,true,,,has_configurable,,,0,
323300,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,configurable,,true,,,configurable,,,0,
323304,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Uint32.New,,true,,,Uint32.New,,,0,
323310,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,contextify_global_template,,true,,,contextify_global_template,,,0,
323314,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CreateV8Context,,true,,,CreateV8Context,,,0,
323321,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BaseObjectPtr<ContextifyContext>,,true,,,BaseObjectPtr<ContextifyContext>,,,0,
323324,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetAlignedPointerFromEmbedderData,,true,,,GetAlignedPointerFromEmbedderData,,,0,
323329,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,UnassignFromContext,,true,,,UnassignFromContext,,,0,
323334,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,contextify_wrapper_template,,true,,,contextify_wrapper_template,,,0,
323338,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,config,,true,,,config,,,0,
323349,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,indexed_config,,true,,,indexed_config,,,0,
323360,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_contextify_global_template,,true,,,set_contextify_global_template,,,0,
323365,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_contextify_wrapper_template,,true,,,set_contextify_wrapper_template,,,0,
323370,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MaybeLocal<Context>,,true,,,MaybeLocal<Context>,,,0,
323373,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetSecurityToken,,true,,,SetSecurityToken,,,0,
323378,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetSecurityToken,,true,,,GetSecurityToken,,,0,
323382,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,name_val,,true,,,name_val,,,0,
323387,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,origin_val,,true,,,origin_val,,,0,
323392,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetConstructorName,,true,,,GetConstructorName,,,0,
323396,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Equals,,true,,,Equals,,,0,
323402,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,object_string,,true,,,object_string,,,0,
323406,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DefineOwnProperty,,true,,,DefineOwnProperty,,,0,
323414,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.Symbol.GetToStringTag,,true,,,v8.Symbol.GetToStringTag,,,0,
323419,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AssignToContext,,true,,,AssignToContext,,,0,
323426,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,contextify_context_private_symbol,,true,,,contextify_context_private_symbol,,,0,
323430,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<Boolean>,,true,,,As<Boolean>,,,0,
323434,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,microtask_queue_ctor_template,,true,,,microtask_queue_ctor_template,,,0,
323438,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ContextifyContext.New,,true,,,ContextifyContext.New,,,0,
323445,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ContextEmbedderTag.IsNodeContext,,true,,,ContextEmbedderTag.IsNodeContext,,,0,
323450,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ContextifyContext.Get,,true,,,ContextifyContext.Get,,,0,
323455,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsStillInitializing,,true,,,IsStillInitializing,,,0,
323459,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sandbox,,true,,,sandbox,,,0,
323463,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetRealNamedProperty,,true,,,GetRealNamedProperty,,,0,
323469,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,global_proxy,,true,,,global_proxy,,,0,
323473,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetRealNamedPropertyAttributes,,true,,,GetRealNamedPropertyAttributes,,,0,
323479,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ShouldThrowOnError,,true,,,ShouldThrowOnError,,,0,
323483,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetOwnPropertyDescriptor,,true,,,GetOwnPropertyDescriptor,,,0,
323489,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,get_string,,true,,,get_string,,,0,
323493,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_string,,true,,,set_string,,,0,
323497,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,has_get,,true,,,has_get,,,0,
323501,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,has_set,,true,,,has_set,,,0,
323505,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,desc_for_sandbox,,true,,,desc_for_sandbox,,,0,
323509,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,define_prop_on_sandbox,,true,,,define_prop_on_sandbox,,,0,
323513,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,has_writable,,true,,,has_writable,,,0,
323517,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,writable,,true,,,writable,,,0,
323521,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ContextifyContext.PropertyGetterCallback,,true,,,ContextifyContext.PropertyGetterCallback,,,0,
323527,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Uint32ToName,,true,,,Uint32ToName,,,0,
323532,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ContextifyContext.PropertySetterCallback,,true,,,ContextifyContext.PropertySetterCallback,,,0,
323539,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ContextifyContext.PropertyDescriptorCallback,,true,,,ContextifyContext.PropertyDescriptorCallback,,,0,
323545,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ContextifyContext.PropertyDefinerCallback,,true,,,ContextifyContext.PropertyDefinerCallback,,,0,
323552,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_script_context_constructor_template,,true,,,set_script_context_constructor_template,,,0,
323557,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TRACE_EVENT_BEGIN1,,true,,,TRACE_EVENT_BEGIN1,,,0,
323564,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ScriptCompiler.CompileUnboundScript,,true,,,ScriptCompiler.CompileUnboundScript,,,0,
323571,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,errors.DecorateErrorStack,,true,,,errors.DecorateErrorStack,,,0,
323577,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TRACE_EVENT_END0,,true,,,TRACE_EVENT_END0,,,0,
323582,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ScriptCompiler.CreateCodeCache,,true,,,ScriptCompiler.CreateCodeCache,,,0,
323587,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StoreCodeCacheResult,,true,,,StoreCodeCacheResult,,,0,
323596,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,source_map_url_string,,true,,,source_map_url_string,,,0,
323600,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetSourceMappingURL,,true,,,GetSourceMappingURL,,,0,
323604,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,cached_data_rejected_string,,true,,,cached_data_rejected_string,,,0,
323608,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,cached_data_string,,true,,,cached_data_string,,,0,
323612,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,cached_data_produced_string,,true,,,cached_data_produced_string,,,0,
323616,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,script_context_constructor_template,,true,,,script_context_constructor_template,,,0,
323620,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EvalMachine,,true,,,EvalMachine,,,0,
323631,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ContextifyScript.InstanceOf,,true,,,ContextifyScript.InstanceOf,,,0,
323637,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_INVALID_THIS,,true,,,THROW_ERR_INVALID_THIS,,,0,
323642,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BindToCurrentContext,,true,,,BindToCurrentContext,,,0,
323646,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node.THROW_ERR_SCRIPT_EXECUTION_TIMEOUT,,true,,,node.THROW_ERR_SCRIPT_EXECUTION_TIMEOUT,,,0,
323652,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node.THROW_ERR_SCRIPT_EXECUTION_INTERRUPTED,,true,,,node.THROW_ERR_SCRIPT_EXECUTION_INTERRUPTED,,,0,
323657,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,get_next_function_id,,true,,,get_next_function_id,,,0,
323661,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,compiled_fn_entry_template,,true,,,compiled_fn_entry_template,,,0,
323665,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,cache_key_string,,true,,,cache_key_string,,,0,
323669,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SourceMapUrl,,true,,,SourceMapUrl,,,0,
323673,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ScriptCompiler.CreateCodeCacheForFunction,,true,,,ScriptCompiler.CreateCodeCacheForFunction,,,0,
323678,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SigintWatchdogHelper.GetInstance,,true,,,SigintWatchdogHelper.GetInstance,,,0,
323682,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HasPendingSignal,,true,,,HasPendingSignal,,,0,
323686,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.MeasureMemoryDelegate.Default,,true,,,v8.MeasureMemoryDelegate.Default,,,0,
323694,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MeasureMemory,,true,,,MeasureMemory,,,0,
323700,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_microtask_queue_ctor_template,,true,,,set_microtask_queue_ctor_template,,,0,
323705,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ContextifyContext.CreatePerIsolateProperties,,true,,,ContextifyContext.CreatePerIsolateProperties,,,0,
323711,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ContextifyScript.CreatePerIsolateProperties,,true,,,ContextifyScript.CreatePerIsolateProperties,,,0,
323717,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MicrotaskQueueWrap.CreatePerIsolateProperties,,true,,,MicrotaskQueueWrap.CreatePerIsolateProperties,,,0,
323723,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_compiled_fn_entry_template,,true,,,set_compiled_fn_entry_template,,,0,
323728,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,constants_string,,true,,,constants_string,,,0,
323732,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ContextifyContext.RegisterExternalReferences,,true,,,ContextifyContext.RegisterExternalReferences,,,0,
323737,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ContextifyScript.RegisterExternalReferences,,true,,,ContextifyScript.RegisterExternalReferences,,,0,
323742,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MicrotaskQueueWrap.RegisterExternalReferences,,true,,,MicrotaskQueueWrap.RegisterExternalReferences,,,0,
323747,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,linux_at_secure,,true,,,linux_at_secure,,,0,
323750,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getuid,,true,,,getuid,,,0,
323753,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,geteuid,,true,,,geteuid,,,0,
323756,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getgid,,true,,,getgid,,,0,
323759,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getegid,,true,,,getegid,,,0,
323762,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DCHECK_NOT_NULL,,true,,,DCHECK_NOT_NULL,,,0,
323766,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ignore_errors,,true,,,ignore_errors,,,0,
323770,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_os_getenv,,true,,,uv_os_getenv,,,0,
323776,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AllocateSufficientStorage,,true,,,AllocateSufficientStorage,,,0,
323780,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strenvtag,,true,,,strenvtag,,,0,
323785,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SafeGetenv,,true,,,SafeGetenv,,,0,
323792,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InitCryptoOnce,,true,,,InitCryptoOnce,,,0,
323796,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_crypto.cc,node_crypto.cc:68:70:CRYPTO_NAMESPACE_LIST:1,,true,68,70,CRYPTO_NAMESPACE_LIST,,,0,
323799,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CRYPTO_NAMESPACE_LIST(V),,true,,,CRYPTO_NAMESPACE_LIST(V),,,0,
323804,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_dir.cc,node_dir.cc:48:50:FS_TYPE_TO_NAME:2,,true,48,50,FS_TYPE_TO_NAME,,,0,
323807,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dir_instance_template,,true,,,dir_instance_template,,,0,
323811,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GCClose,,true,,,GCClose,,,0,
323814,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_dir.cc,node_dir.cc:64:68:FS_DIR_SYNC_TRACE_BEGIN:2,,true,64,68,FS_DIR_SYNC_TRACE_BEGIN,,,0,
323817,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_DIR_SYNC_TRACE_BEGIN(closedir),,true,,,FS_DIR_SYNC_TRACE_BEGIN(closedir),,,0,
323828,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_fs_closedir,,true,,,uv_fs_closedir,,,0,
323835,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_dir.cc,node_dir.cc:69:73:FS_DIR_SYNC_TRACE_END:2,,true,69,73,FS_DIR_SYNC_TRACE_END,,,0,
323838,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_DIR_SYNC_TRACE_END(closedir),,true,,,FS_DIR_SYNC_TRACE_END(closedir),,,0,
323849,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FSReqBase.from_req,,true,,,FSReqBase.from_req,,,0,
323854,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,after,,true,,,after,,,0,
323859,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_dir.cc,node_dir.cc:91:96:FS_DIR_ASYNC_TRACE_END1:4,,true,91,96,FS_DIR_ASYNC_TRACE_END1,,,0,
323866,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",,true,,,"FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",,,0,
323879,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,trace_event_trace_id,,true,,,trace_event_trace_id,,,0,
323884,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,get_dir_func_name_by_type,,true,,,get_dir_func_name_by_type,,,0,
323888,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TraceID.FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",,true,,,"FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",,,0,
323892,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Proceed,,true,,,Proceed,,,0,
323896,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetReqWrap,,true,,,GetReqWrap,,,0,
323901,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_dir.cc,node_dir.cc:75:78:FS_DIR_ASYNC_TRACE_BEGIN0:2,,true,75,78,FS_DIR_ASYNC_TRACE_BEGIN0,,,0,
323906,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_DIR_ASYNC_TRACE_BEGIN0(UV_FS_CLOSEDIR, req_wrap_async)",,true,,,"FS_DIR_ASYNC_TRACE_BEGIN0(UV_FS_CLOSEDIR, req_wrap_async)",,,0,
323910,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AsyncCall,,true,,,AsyncCall,,,0,
323921,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dir,,true,,,dir,,,0,
323926,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SyncCall,,true,,,SyncCall,,,0,
323935,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DirentListToArray,,true,,,DirentListToArray,,,0,
323943,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_DIR_ASYNC_TRACE_BEGIN0(UV_FS_READDIR, req_wrap_async)",,true,,,"FS_DIR_ASYNC_TRACE_BEGIN0(UV_FS_READDIR, req_wrap_async)",,,0,
323947,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_DIR_SYNC_TRACE_BEGIN(readdir),,true,,,FS_DIR_SYNC_TRACE_BEGIN(readdir),,,0,
323958,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_DIR_SYNC_TRACE_END(readdir),,true,,,FS_DIR_SYNC_TRACE_END(readdir),,,0,
323969,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,error_string,,true,,,error_string,,,0,
323973,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DirHandle.New,,true,,,DirHandle.New,,,0,
323979,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_dir.cc,node_dir.cc:84:89:FS_DIR_ASYNC_TRACE_BEGIN1:4,,true,84,89,FS_DIR_ASYNC_TRACE_BEGIN1,,,0,
323985,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_DIR_ASYNC_TRACE_BEGIN1(
        UV_FS_OPENDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,true,,,"FS_DIR_ASYNC_TRACE_BEGIN1(
        UV_FS_OPENDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,,0,
323990,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TraceID.FS_DIR_ASYNC_TRACE_BEGIN1(
        UV_FS_OPENDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,true,,,"FS_DIR_ASYNC_TRACE_BEGIN1(
        UV_FS_OPENDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,,0,
323994,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_DIR_SYNC_TRACE_BEGIN(opendir),,true,,,FS_DIR_SYNC_TRACE_BEGIN(opendir),,,0,
324005,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_DIR_SYNC_TRACE_END(opendir),,true,,,FS_DIR_SYNC_TRACE_END(opendir),,,0,
324016,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_dir_instance_template,,true,,,set_dir_instance_template,,,0,
324021,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_os_free_environ,,true,,,uv_os_free_environ,,,0,
324026,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.make_shared<RealEnvStore>,,true,,,std.make_shared<RealEnvStore>,,,0,
324030,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_tzset,,true,,,_tzset,,,0,
324033,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DateTimeConfigurationChangeNotification,,true,,,DateTimeConfigurationChangeNotification,,,0,
324038,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Nothing<std.string>,,true,,,Nothing<std.string>,,,0,
324042,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MaybeLocal<String>,,true,,,MaybeLocal<String>,,,0,
324045,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,val,,true,,,val,,,0,
324050,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_os_setenv,,true,,,uv_os_setenv,,,0,
324055,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Query,,true,,,Query,,,0,
324061,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_os_unsetenv,,true,,,uv_os_unsetenv,,,0,
324065,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_os_environ,,true,,,uv_os_environ,,,0,
324070,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,env_v,,true,,,env_v,,,0,
324074,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ERR_STRING_TOO_LONG,,true,,,ERR_STRING_TOO_LONG,,,0,
324078,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Local<Array>,,true,,,Local<Array>,,,0,
324081,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,KVStore.CreateMapKVStore,,true,,,KVStore.CreateMapKVStore,,,0,
324085,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Enumerate,,true,,,Enumerate,,,0,
324090,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,key_str,,true,,,key_str,,,0,
324095,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,value_str,,true,,,value_str,,,0,
324100,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.make_shared<MapKVStore>,,true,,,std.make_shared<MapKVStore>,,,0,
324104,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetOwnPropertyNames,,true,,,GetOwnPropertyNames,,,0,
324109,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetUndefined,,true,,,SetUndefined,,,0,
324113,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EmitProcessEnvWarning,,true,,,EmitProcessEnvWarning,,,0,
324117,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_INVALID_OBJECT_DEFINE_PROPERTY,,true,,,THROW_ERR_INVALID_OBJECT_DEFINE_PROPERTY,,,0,
324122,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EnvSetter,,true,,,EnvSetter,,,0,
324128,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,env_proxy_template,,true,,,env_proxy_template,,,0,
324132,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NamedPropertyHandlerConfiguration,,true,,,NamedPropertyHandlerConfiguration,,,0,
324144,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_env_proxy_template,,true,,,set_env_proxy_template,,,0,
324149,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_env_proxy_ctor_template,,true,,,set_env_proxy_ctor_template,,,0,
324154,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,decorated_private_symbol,,true,,,decorated_private_symbol,,,0,
324158,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.Int32.New,,true,,,v8.Int32.New,,,0,
324164,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,get_source_map_error_source,,true,,,get_source_map_error_source,,,0,
324168,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,error_source_utf8,,true,,,error_source_utf8,,,0,
324173,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetSourceLine,,true,,,GetSourceLine,,,0,
324178,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,encoded_source,,true,,,encoded_source,,,0,
324183,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sourceline,,true,,,sourceline,,,0,
324188,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,source_maps_enabled,,true,,,source_maps_enabled,,,0,
324192,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetSourceMapErrorSource,,true,,,GetSourceMapErrorSource,,,0,
324199,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LineOffset,,true,,,LineOffset,,,0,
324203,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ColumnOffset,,true,,,ColumnOffset,,,0,
324207,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetEndColumn,,true,,,GetEndColumn,,,0,
324212,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fn_name_s,,true,,,fn_name_s,,,0,
324217,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetFunctionName,,true,,,GetFunctionName,,,0,
324221,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,script_name,,true,,,script_name,,,0,
324226,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetScriptName,,true,,,GetScriptName,,,0,
324230,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetColumn,,true,,,GetColumn,,,0,
324234,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsEval,,true,,,IsEval,,,0,
324238,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PrintToStderrAndFlush,,true,,,PrintToStderrAndFlush,,,0,
324242,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FormatStackTrace,,true,,,FormatStackTrace,,,0,
324247,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ToDetailString,,true,,,ToDetailString,,,0,
324252,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetErrorSource,,true,,,GetErrorSource,,,0,
324259,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,arrow_message_private_symbol,,true,,,arrow_message_private_symbol,,,0,
324263,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,printed_error,,true,,,printed_error,,,0,
324267,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_printed_error,,true,,,set_printed_error,,,0,
324272,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Abort,,true,,,Abort,,,0,
324277,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsExceptionDecorated,,true,,,IsExceptionDecorated,,,0,
324282,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,report_to_inspector,,true,,,report_to_inspector,,,0,
324285,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,enhance_with,,true,,,enhance_with,,,0,
324289,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,enhance_fatal_stack_before_inspector,,true,,,enhance_fatal_stack_before_inspector,,,0,
324293,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,enhance_fatal_stack_after_inspector,,true,,,enhance_fatal_stack_after_inspector,,,0,
324297,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,stack_string,,true,,,stack_string,,,0,
324301,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,trace,,true,,,trace,,,0,
324306,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,arrow_string,,true,,,arrow_string,,,0,
324311,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,message,,true,,,message,,,0,
324316,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fs.Basename,,true,,,fs.Basename,,,0,
324322,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TriggerNodeReport,,true,,,TriggerNodeReport,,,0,
324330,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Isolate.TryGetCurrent,,true,,,Isolate.TryGetCurrent,,,0,
324334,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,maybe_cache_generated_source_map,,true,,,maybe_cache_generated_source_map,,,0,
324338,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CanContinue,,true,,,CanContinue,,,0,
324341,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Exception.CreateMessage,,true,,,Exception.CreateMessage,,,0,
324347,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReportFatalException,,true,,,ReportFatalException,,,0,
324354,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ErrorLevel,,true,,,ErrorLevel,,,0,
324358,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ResourceName,,true,,,ResourceName,,,0,
324362,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,msg,,true,,,msg,,,0,
324367,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProcessEmitWarningGeneric,,true,,,ProcessEmitWarningGeneric,,,0,
324374,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TriggerUncaughtException,,true,,,TriggerUncaughtException,,,0,
324381,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_prepare_stack_trace_callback,,true,,,set_prepare_stack_trace_callback,,,0,
324386,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_source_maps_enabled,,true,,,set_source_maps_enabled,,,0,
324391,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_get_source_map_error_source,,true,,,set_get_source_map_error_source,,,0,
324396,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_maybe_cache_generated_source_map,,true,,,set_maybe_cache_generated_source_map,,,0,
324401,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_enhance_fatal_stack_before_inspector,,true,,,set_enhance_fatal_stack_before_inspector,,,0,
324406,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_enhance_fatal_stack_after_inspector,,true,,,set_enhance_fatal_stack_after_inspector,,,0,
324411,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,try_catch_scope,,true,,,try_catch_scope,,,0,
324415,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InContext,,true,,,InContext,,,0,
324419,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fatal_exception_string,,true,,,fatal_exception_string,,,0,
324423,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsVerbose,,true,,,IsVerbose,,,0,
324427,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,filehandle_close_warning,,true,,,filehandle_close_warning,,,0,
324431,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_filehandle_close_warning,,true,,,set_filehandle_close_warning,,,0,
324436,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CloseReq.from_req,,true,,,CloseReq.from_req,,,0,
324441,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_file.cc,node_file.cc:194:199:FS_ASYNC_TRACE_END1:4,,true,194,199,FS_ASYNC_TRACE_END1,,,0,
324448,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_ASYNC_TRACE_END1(
        req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",,true,,,"FS_ASYNC_TRACE_END1(
        req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",,,0,
324452,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,get_fs_func_name_by_type,,true,,,get_fs_func_name_by_type,,,0,
324456,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,close,,true,,,close,,,0,
324460,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AfterClose,,true,,,AfterClose,,,0,
324463,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,file_handle,,true,,,file_handle,,,0,
324467,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FileHandleReadWrap.from_req,,true,,,FileHandleReadWrap.from_req,,,0,
324472,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_ASYNC_TRACE_END1(
          req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",,true,,,"FS_ASYNC_TRACE_END1(
          req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",,,0,
324476,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FileHandleCloseWrap.from_req,,true,,,FileHandleCloseWrap.from_req,,,0,
324481,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_ASYNC_TRACE_END1(
        req->fs_type, wrap, ""result"", static_cast<int>(req->result))",,true,,,"FS_ASYNC_TRACE_END1(
        req->fs_type, wrap, ""result"", static_cast<int>(req->result))",,,0,
324485,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,paths,,true,,,paths,,,0,
324489,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,continuation_data,,true,,,continuation_data,,,0,
324493,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_file.cc,node_file.cc:84:84:S_ISDIR:1,,true,84,84,S_ISDIR,,,0,
324497,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MKDirpAsync,,true,,,MKDirpAsync,,,0,
324505,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,mode,,true,,,mode,,,0,
324509,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MaybeSetFirstPath,,true,,,MaybeSetFirstPath,,,0,
324514,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PushPath,,true,,,PushPath,,,0,
324519,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_fs_callback_t,,true,,,uv_fs_callback_t,,,0,
324523,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsSafeJsInt,,true,,,IsSafeJsInt,,,0,
324527,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_file.cc,node_file.cc:122:124:FS_TYPE_TO_NAME:2,,true,122,124,FS_TYPE_TO_NAME,,,0,
324530,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fd_constructor_template,,true,,,fd_constructor_template,,,0,
324534,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FileHandle.New,,true,,,FileHandle.New,,,0,
324540,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetTransferMode,,true,,,GetTransferMode,,,0,
324544,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_file.cc,node_file.cc:168:171:FS_SYNC_TRACE_BEGIN:2,,true,168,171,FS_SYNC_TRACE_BEGIN,,,0,
324547,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_BEGIN(close),,true,,,FS_SYNC_TRACE_BEGIN(close),,,0,
324558,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_file.cc,node_file.cc:172:175:FS_SYNC_TRACE_END:2,,true,172,175,FS_SYNC_TRACE_END,,,0,
324561,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_END(close),,true,,,FS_SYNC_TRACE_END(close),,,0,
324572,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BaseObjectPtr<BaseObject>,,true,,,BaseObjectPtr<BaseObject>,,,0,
324576,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<Promise.Resolver>,,true,,,As<Promise.Resolver>,,,0,
324580,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fdclose_constructor_template,,true,,,fdclose_constructor_template,,,0,
324584,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_file.cc,node_file.cc:177:180:FS_ASYNC_TRACE_BEGIN0:2,,true,177,180,FS_ASYNC_TRACE_BEGIN0,,,0,
324589,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, req)",,true,,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, req)",,,0,
324593,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ClosePromise,,true,,,ClosePromise,,,0,
324597,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,trigger_scope,,true,,,trigger_scope,,,0,
324601,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,handle_string,,true,,,handle_string,,,0,
324605,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,filehandlereadwrap_template,,true,,,filehandlereadwrap_template,,,0,
324609,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, current_read_.get())",,true,,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, current_read_.get())",,,0,
324613,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, wrap)",,true,,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, wrap)",,,0,
324617,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FillGlobalStatsArray,,true,,,FillGlobalStatsArray,,,0,
324623,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,binding_data,,true,,,binding_data,,,0,
324627,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,use_bigint,,true,,,use_bigint,,,0,
324630,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FillGlobalStatFsArray,,true,,,FillGlobalStatFsArray,,,0,
324636,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,req,,true,,,req,,,0,
324640,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,syscall,,true,,,syscall,,,0,
324644,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",,true,,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",,,0,
324657,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TraceID.FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",,true,,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",,,0,
324661,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ResolveStat,,true,,,ResolveStat,,,0,
324666,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ResolveStatFs,,true,,,ResolveStatFs,,,0,
324671,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_plain_open,,true,,,is_plain_open,,,0,
324675,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddUnmanagedFd,,true,,,AddUnmanagedFd,,,0,
324680,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,first_path,,true,,,first_path,,,0,
324684,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FromNamespacedPath,,true,,,FromNamespacedPath,,,0,
324688,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,with_file_types,,true,,,with_file_types,,,0,
324692,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_fs_scandir_next,,true,,,uv_fs_scandir_next,,,0,
324697,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_file.cc,node_file.cc:187:192:FS_ASYNC_TRACE_BEGIN1:4,,true,187,192,FS_ASYNC_TRACE_BEGIN1,,,0,
324703,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_ACCESS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,true,,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_ACCESS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,,0,
324708,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TraceID.FS_ASYNC_TRACE_BEGIN1(
        UV_FS_ACCESS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,true,,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_ACCESS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,,0,
324712,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_BEGIN(access),,true,,,FS_SYNC_TRACE_BEGIN(access),,,0,
324723,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_END(access),,true,,,FS_SYNC_TRACE_END(access),,,0,
324734,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RemoveUnmanagedFd,,true,,,RemoveUnmanagedFd,,,0,
324739,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, req_wrap_async)",,true,,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, req_wrap_async)",,,0,
324750,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TraceID.FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, req_wrap_async)",,true,,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, req_wrap_async)",,,0,
324754,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_fs_read,,true,,,uv_fs_read,,,0,
324764,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,true,,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,,0,
324769,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TraceID.FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,true,,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,,0,
324773,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_BEGIN(stat),,true,,,FS_SYNC_TRACE_BEGIN(stat),,,0,
324784,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_END(stat),,true,,,FS_SYNC_TRACE_END(stat),,,0,
324795,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LSTAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,true,,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LSTAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,,0,
324800,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TraceID.FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LSTAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,true,,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LSTAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,,0,
324804,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_BEGIN(lstat),,true,,,FS_SYNC_TRACE_BEGIN(lstat),,,0,
324815,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_END(lstat),,true,,,FS_SYNC_TRACE_END(lstat),,,0,
324826,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FSTAT, req_wrap_async)",,true,,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FSTAT, req_wrap_async)",,,0,
324837,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TraceID.FS_ASYNC_TRACE_BEGIN0(UV_FS_FSTAT, req_wrap_async)",,true,,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FSTAT, req_wrap_async)",,,0,
324841,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_BEGIN(fstat),,true,,,FS_SYNC_TRACE_BEGIN(fstat),,,0,
324852,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_END(fstat),,true,,,FS_SYNC_TRACE_END(fstat),,,0,
324863,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STATFS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,true,,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STATFS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,,0,
324868,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TraceID.FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STATFS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,true,,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STATFS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,,0,
324872,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_BEGIN(statfs),,true,,,FS_SYNC_TRACE_BEGIN(statfs),,,0,
324883,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_END(statfs),,true,,,FS_SYNC_TRACE_END(statfs),,,0,
324894,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_file.cc,node_file.cc:201:208:FS_ASYNC_TRACE_BEGIN2:6,,true,201,208,FS_ASYNC_TRACE_BEGIN2,,,0,
324901,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_ASYNC_TRACE_BEGIN2(UV_FS_SYMLINK,
                          req_wrap_async,
                          ""target"",
                          TRACE_STR_COPY(*target),
                          ""path"",
                          TRACE_STR_COPY(*path))",,true,,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_SYMLINK,
                          req_wrap_async,
                          ""target"",
                          TRACE_STR_COPY(*target),
                          ""path"",
                          TRACE_STR_COPY(*path))",,,0,
324906,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TraceID.FS_ASYNC_TRACE_BEGIN2(UV_FS_SYMLINK,
                          req_wrap_async,
                          ""target"",
                          TRACE_STR_COPY(*target),
                          ""path"",
                          TRACE_STR_COPY(*path))",,true,,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_SYMLINK,
                          req_wrap_async,
                          ""target"",
                          TRACE_STR_COPY(*target),
                          ""path"",
                          TRACE_STR_COPY(*path))",,,0,
324910,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AsyncDestCall,,true,,,AsyncDestCall,,,0,
324925,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_BEGIN(symlink),,true,,,FS_SYNC_TRACE_BEGIN(symlink),,,0,
324936,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_END(symlink),,true,,,FS_SYNC_TRACE_END(symlink),,,0,
324947,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,src,,true,,,src,,,0,
324952,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dest,,true,,,dest,,,0,
324957,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_ASYNC_TRACE_BEGIN2(UV_FS_LINK,
                          req_wrap_async,
                          ""src"",
                          TRACE_STR_COPY(*src),
                          ""dest"",
                          TRACE_STR_COPY(*dest))",,true,,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_LINK,
                          req_wrap_async,
                          ""src"",
                          TRACE_STR_COPY(*src),
                          ""dest"",
                          TRACE_STR_COPY(*dest))",,,0,
324962,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TraceID.FS_ASYNC_TRACE_BEGIN2(UV_FS_LINK,
                          req_wrap_async,
                          ""src"",
                          TRACE_STR_COPY(*src),
                          ""dest"",
                          TRACE_STR_COPY(*dest))",,true,,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_LINK,
                          req_wrap_async,
                          ""src"",
                          TRACE_STR_COPY(*src),
                          ""dest"",
                          TRACE_STR_COPY(*dest))",,,0,
324966,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_BEGIN(link),,true,,,FS_SYNC_TRACE_BEGIN(link),,,0,
324977,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_END(link),,true,,,FS_SYNC_TRACE_END(link),,,0,
324988,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_READLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,true,,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_READLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,,0,
324993,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TraceID.FS_ASYNC_TRACE_BEGIN1(
        UV_FS_READLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,true,,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_READLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,,0,
324997,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_BEGIN(readlink),,true,,,FS_SYNC_TRACE_BEGIN(readlink),,,0,
325008,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_END(readlink),,true,,,FS_SYNC_TRACE_END(readlink),,,0,
325019,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,old_path,,true,,,old_path,,,0,
325024,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,new_path,,true,,,new_path,,,0,
325029,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_ASYNC_TRACE_BEGIN2(UV_FS_RENAME,
                          req_wrap_async,
                          ""old_path"",
                          TRACE_STR_COPY(*old_path),
                          ""new_path"",
                          TRACE_STR_COPY(*new_path))",,true,,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_RENAME,
                          req_wrap_async,
                          ""old_path"",
                          TRACE_STR_COPY(*old_path),
                          ""new_path"",
                          TRACE_STR_COPY(*new_path))",,,0,
325034,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TraceID.FS_ASYNC_TRACE_BEGIN2(UV_FS_RENAME,
                          req_wrap_async,
                          ""old_path"",
                          TRACE_STR_COPY(*old_path),
                          ""new_path"",
                          TRACE_STR_COPY(*new_path))",,true,,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_RENAME,
                          req_wrap_async,
                          ""old_path"",
                          TRACE_STR_COPY(*old_path),
                          ""new_path"",
                          TRACE_STR_COPY(*new_path))",,,0,
325038,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_BEGIN(rename),,true,,,FS_SYNC_TRACE_BEGIN(rename),,,0,
325049,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_END(rename),,true,,,FS_SYNC_TRACE_END(rename),,,0,
325060,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FTRUNCATE, req_wrap_async)",,true,,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FTRUNCATE, req_wrap_async)",,,0,
325071,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TraceID.FS_ASYNC_TRACE_BEGIN0(UV_FS_FTRUNCATE, req_wrap_async)",,true,,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FTRUNCATE, req_wrap_async)",,,0,
325075,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_BEGIN(ftruncate),,true,,,FS_SYNC_TRACE_BEGIN(ftruncate),,,0,
325086,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_END(ftruncate),,true,,,FS_SYNC_TRACE_END(ftruncate),,,0,
325097,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FDATASYNC, req_wrap_async)",,true,,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FDATASYNC, req_wrap_async)",,,0,
325108,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TraceID.FS_ASYNC_TRACE_BEGIN0(UV_FS_FDATASYNC, req_wrap_async)",,true,,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FDATASYNC, req_wrap_async)",,,0,
325112,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_BEGIN(fdatasync),,true,,,FS_SYNC_TRACE_BEGIN(fdatasync),,,0,
325123,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_END(fdatasync),,true,,,FS_SYNC_TRACE_END(fdatasync),,,0,
325134,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FSYNC, req_wrap_async)",,true,,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FSYNC, req_wrap_async)",,,0,
325145,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TraceID.FS_ASYNC_TRACE_BEGIN0(UV_FS_FSYNC, req_wrap_async)",,true,,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FSYNC, req_wrap_async)",,,0,
325149,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_BEGIN(fsync),,true,,,FS_SYNC_TRACE_BEGIN(fsync),,,0,
325160,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_END(fsync),,true,,,FS_SYNC_TRACE_END(fsync),,,0,
325171,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UNLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,true,,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UNLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,,0,
325176,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TraceID.FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UNLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,true,,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UNLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,,0,
325180,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_BEGIN(unlink),,true,,,FS_SYNC_TRACE_BEGIN(unlink),,,0,
325191,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_END(unlink),,true,,,FS_SYNC_TRACE_END(unlink),,,0,
325202,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_RMDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,true,,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_RMDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,,0,
325207,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TraceID.FS_ASYNC_TRACE_BEGIN1(
        UV_FS_RMDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,true,,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_RMDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,,0,
325211,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_BEGIN(rmdir),,true,,,FS_SYNC_TRACE_BEGIN(rmdir),,,0,
325222,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_END(rmdir),,true,,,FS_SYNC_TRACE_END(rmdir),,,0,
325233,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_continuation_data,,true,,,set_continuation_data,,,0,
325238,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PopPath,,true,,,PopPath,,,0,
325242,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_fs_mkdir,,true,,,uv_fs_mkdir,,,0,
325250,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PrintSyncTrace,,true,,,PrintSyncTrace,,,0,
325254,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MKDirpSync,,true,,,MKDirpSync,,,0,
325262,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_BEGIN(mkdir),,true,,,FS_SYNC_TRACE_BEGIN(mkdir),,,0,
325273,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CallMKDirpSync,,true,,,CallMKDirpSync,,,0,
325281,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_END(mkdir),,true,,,FS_SYNC_TRACE_END(mkdir),,,0,
325292,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_REALPATH, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,true,,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_REALPATH, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,,0,
325297,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TraceID.FS_ASYNC_TRACE_BEGIN1(
        UV_FS_REALPATH, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,true,,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_REALPATH, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,,0,
325301,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_BEGIN(realpath),,true,,,FS_SYNC_TRACE_BEGIN(realpath),,,0,
325312,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_END(realpath),,true,,,FS_SYNC_TRACE_END(realpath),,,0,
325323,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_with_file_types,,true,,,set_with_file_types,,,0,
325328,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_SCANDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,true,,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_SCANDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,,0,
325333,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TraceID.FS_ASYNC_TRACE_BEGIN1(
        UV_FS_SCANDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,true,,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_SCANDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,,0,
325337,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_BEGIN(readdir),,true,,,FS_SYNC_TRACE_BEGIN(readdir),,,0,
325348,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_END(readdir),,true,,,FS_SYNC_TRACE_END(readdir),,,0,
325359,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckOpenPermissions,,true,,,CheckOpenPermissions,,,0,
325365,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_BEGIN(open),,true,,,FS_SYNC_TRACE_BEGIN(open),,,0,
325376,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_END(open),,true,,,FS_SYNC_TRACE_END(open),,,0,
325387,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_BEGIN(read),,true,,,FS_SYNC_TRACE_BEGIN(read),,,0,
325398,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_END(read),,true,,,FS_SYNC_TRACE_END(read),,,0,
325409,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_is_plain_open,,true,,,set_is_plain_open,,,0,
325414,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_OPEN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,true,,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_OPEN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,,0,
325419,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TraceID.FS_ASYNC_TRACE_BEGIN1(
        UV_FS_OPEN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,true,,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_OPEN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,,0,
325423,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_ASYNC_TRACE_BEGIN2(UV_FS_COPYFILE,
                          req_wrap_async,
                          ""src"",
                          TRACE_STR_COPY(*src),
                          ""dest"",
                          TRACE_STR_COPY(*dest))",,true,,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_COPYFILE,
                          req_wrap_async,
                          ""src"",
                          TRACE_STR_COPY(*src),
                          ""dest"",
                          TRACE_STR_COPY(*dest))",,,0,
325428,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TraceID.FS_ASYNC_TRACE_BEGIN2(UV_FS_COPYFILE,
                          req_wrap_async,
                          ""src"",
                          TRACE_STR_COPY(*src),
                          ""dest"",
                          TRACE_STR_COPY(*dest))",,true,,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_COPYFILE,
                          req_wrap_async,
                          ""src"",
                          TRACE_STR_COPY(*src),
                          ""dest"",
                          TRACE_STR_COPY(*dest))",,,0,
325432,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_BEGIN(copyfile),,true,,,FS_SYNC_TRACE_BEGIN(copyfile),,,0,
325443,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_END(copyfile),,true,,,FS_SYNC_TRACE_END(copyfile),,,0,
325454,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Buffer.IsWithinBounds,,true,,,Buffer.IsWithinBounds,,,0,
325461,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetOffset,,true,,,GetOffset,,,0,
325465,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)",,true,,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)",,,0,
325476,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TraceID.FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)",,true,,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)",,,0,
325480,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_BEGIN(write),,true,,,FS_SYNC_TRACE_BEGIN(write),,,0,
325491,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_SYNC_TRACE_END(write, ""bytesWritten"", bytesWritten)",,true,,,"FS_SYNC_TRACE_END(write, ""bytesWritten"", bytesWritten)",,,0,
325504,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,iovs,,true,,,iovs,,,0,
325508,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsExternalOneByte,,true,,,IsExternalOneByte,,,0,
325512,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetExternalOneByteStringResource,,true,,,GetExternalOneByteStringResource,,,0,
325516,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsLittleEndian,,true,,,IsLittleEndian,,,0,
325519,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsExternalTwoByte,,true,,,IsExternalTwoByte,,,0,
325523,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetExternalStringResource,,true,,,GetExternalStringResource,,,0,
325527,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StringBytes.StorageSize,,true,,,StringBytes.StorageSize,,,0,
325534,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetLengthAndZeroTerminate,,true,,,SetLengthAndZeroTerminate,,,0,
325538,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AfterInteger,,true,,,AfterInteger,,,0,
325542,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, req_wrap_async)",,true,,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, req_wrap_async)",,,0,
325553,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TraceID.FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, req_wrap_async)",,true,,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, req_wrap_async)",,,0,
325557,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_SYNC_TRACE_END(read, ""bytesRead"", bytesRead)",,true,,,"FS_SYNC_TRACE_END(read, ""bytesRead"", bytesRead)",,,0,
325570,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHMOD, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,true,,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHMOD, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,,0,
325575,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TraceID.FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHMOD, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,true,,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHMOD, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,,0,
325579,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_BEGIN(chmod),,true,,,FS_SYNC_TRACE_BEGIN(chmod),,,0,
325590,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_END(chmod),,true,,,FS_SYNC_TRACE_END(chmod),,,0,
325601,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHMOD, req_wrap_async)",,true,,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHMOD, req_wrap_async)",,,0,
325612,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TraceID.FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHMOD, req_wrap_async)",,true,,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHMOD, req_wrap_async)",,,0,
325616,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_BEGIN(fchmod),,true,,,FS_SYNC_TRACE_BEGIN(fchmod),,,0,
325627,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_END(fchmod),,true,,,FS_SYNC_TRACE_END(fchmod),,,0,
325638,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,true,,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,,0,
325643,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TraceID.FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,true,,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,,0,
325647,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_BEGIN(chown),,true,,,FS_SYNC_TRACE_BEGIN(chown),,,0,
325658,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_END(chown),,true,,,FS_SYNC_TRACE_END(chown),,,0,
325669,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHOWN, req_wrap_async)",,true,,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHOWN, req_wrap_async)",,,0,
325680,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TraceID.FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHOWN, req_wrap_async)",,true,,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHOWN, req_wrap_async)",,,0,
325684,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_BEGIN(fchown),,true,,,FS_SYNC_TRACE_BEGIN(fchown),,,0,
325695,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_END(fchown),,true,,,FS_SYNC_TRACE_END(fchown),,,0,
325706,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LCHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,true,,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LCHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,,0,
325711,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TraceID.FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LCHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,true,,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LCHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,,0,
325715,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_BEGIN(lchown),,true,,,FS_SYNC_TRACE_BEGIN(lchown),,,0,
325726,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_END(lchown),,true,,,FS_SYNC_TRACE_END(lchown),,,0,
325737,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,true,,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,,0,
325742,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TraceID.FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,true,,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,,0,
325746,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_BEGIN(utimes),,true,,,FS_SYNC_TRACE_BEGIN(utimes),,,0,
325757,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_END(utimes),,true,,,FS_SYNC_TRACE_END(utimes),,,0,
325768,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FUTIME, req_wrap_async)",,true,,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FUTIME, req_wrap_async)",,,0,
325779,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TraceID.FS_ASYNC_TRACE_BEGIN0(UV_FS_FUTIME, req_wrap_async)",,true,,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FUTIME, req_wrap_async)",,,0,
325783,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_BEGIN(futimes),,true,,,FS_SYNC_TRACE_BEGIN(futimes),,,0,
325794,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_END(futimes),,true,,,FS_SYNC_TRACE_END(futimes),,,0,
325805,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LUTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,true,,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LUTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,,0,
325810,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TraceID.FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LUTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,true,,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LUTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",,,0,
325814,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_BEGIN(lutimes),,true,,,FS_SYNC_TRACE_BEGIN(lutimes),,,0,
325825,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_END(lutimes),,true,,,FS_SYNC_TRACE_END(lutimes),,,0,
325836,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tmpl,,true,,,tmpl,,,0,
325841,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_MKDTEMP, req_wrap_async, ""path"", TRACE_STR_COPY(*tmpl))",,true,,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_MKDTEMP, req_wrap_async, ""path"", TRACE_STR_COPY(*tmpl))",,,0,
325846,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TraceID.FS_ASYNC_TRACE_BEGIN1(
        UV_FS_MKDTEMP, req_wrap_async, ""path"", TRACE_STR_COPY(*tmpl))",,true,,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_MKDTEMP, req_wrap_async, ""path"", TRACE_STR_COPY(*tmpl))",,,0,
325850,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_BEGIN(mkdtemp),,true,,,FS_SYNC_TRACE_BEGIN(mkdtemp),,,0,
325861,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FS_SYNC_TRACE_END(mkdtemp),,true,,,FS_SYNC_TRACE_END(mkdtemp),,,0,
325872,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ERR_INVALID_URL_SCHEME,,true,,,ERR_INVALID_URL_SCHEME,,,0,
325876,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,get_hostname,,true,,,get_hostname,,,0,
325880,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ERR_INVALID_FILE_URL_HOST,,true,,,ERR_INVALID_FILE_URL_HOST,,,0,
325885,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ERR_INVALID_FILE_URL_PATH,,true,,,ERR_INVALID_FILE_URL_PATH,,,0,
325890,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ada.unicode.percent_decode,,true,,,ada.unicode.percent_decode,,,0,
325896,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,utf8_package_json_url,,true,,,utf8_package_json_url,,,0,
325901,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ERR_INVALID_URL,,true,,,ERR_INVALID_URL,,,0,
325906,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Utf8Value,,true,,,Utf8Value,,,0,
325911,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FileURLToPath,,true,,,FileURLToPath,,,0,
325917,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FilePathIsFile,,true,,,FilePathIsFile,,,0,
325922,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,utf8_base_path,,true,,,utf8_base_path,,,0,
325927,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ERR_INVALID_ARG_TYPE,,true,,,ERR_INVALID_ARG_TYPE,,,0,
325932,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ERR_MODULE_NOT_FOUND,,true,,,ERR_MODULE_NOT_FOUND,,,0,
325937,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StatWatcher.CreatePerIsolateProperties,,true,,,StatWatcher.CreatePerIsolateProperties,,,0,
325943,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BindingData.CreatePerIsolateProperties,,true,,,BindingData.CreatePerIsolateProperties,,,0,
325949,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_filehandlereadwrap_template,,true,,,set_filehandlereadwrap_template,,,0,
325954,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_fsreqpromise_constructor_template,,true,,,set_fsreqpromise_constructor_template,,,0,
325959,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_fd_constructor_template,,true,,,set_fd_constructor_template,,,0,
325964,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_fdclose_constructor_template,,true,,,set_fdclose_constructor_template,,,0,
325969,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fs_use_promises_symbol,,true,,,fs_use_promises_symbol,,,0,
325973,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StatWatcher.RegisterExternalReferences,,true,,,StatWatcher.RegisterExternalReferences,,,0,
325978,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BindingData.RegisterExternalReferences,,true,,,BindingData.RegisterExternalReferences,,,0,
325983,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StreamBase.RegisterExternalReferences,,true,,,StreamBase.RegisterExternalReferences,,,0,
325988,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HasHttp2Observer,,true,,,HasHttp2Observer,,,0,
325992,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Notify,,true,,,Notify,,,0,
325997,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetName,,true,,,GetName,,,0,
326001,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_write_scheduled,,true,,,is_write_scheduled,,,0,
326004,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SendPendingData,,true,,,SendPendingData,,,0,
326008,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HasWritesOnSocketForStream,,true,,,HasWritesOnSocketForStream,,,0,
326013,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Callbacks,,true,,,Callbacks,,,0,
326017,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_in_scope,,true,,,is_in_scope,,,0,
326021,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_in_scope,,true,,,set_in_scope,,,0,
326026,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MaybeScheduleWrite,,true,,,MaybeScheduleWrite,,,0,
326029,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_option_new,,true,,,nghttp2_option_new,,,0,
326033,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_option_set_no_closed_streams,,true,,,nghttp2_option_set_no_closed_streams,,,0,
326038,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_option_set_no_auto_window_update,,true,,,nghttp2_option_set_no_auto_window_update,,,0,
326043,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_option_set_builtin_recv_extension_type,,true,,,nghttp2_option_set_builtin_recv_extension_type,,,0,
326048,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_option_set_max_deflate_dynamic_table_size,,true,,,nghttp2_option_set_max_deflate_dynamic_table_size,,,0,
326053,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_option_set_max_reserved_remote_streams,,true,,,nghttp2_option_set_max_reserved_remote_streams,,,0,
326058,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_option_set_max_send_header_block_length,,true,,,nghttp2_option_set_max_send_header_block_length,,,0,
326063,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_option_set_peer_max_concurrent_streams,,true,,,nghttp2_option_set_peer_max_concurrent_streams,,,0,
326068,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_padding_strategy,,true,,,set_padding_strategy,,,0,
326072,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_max_header_pairs,,true,,,set_max_header_pairs,,,0,
326076,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_max_outstanding_pings,,true,,,set_max_outstanding_pings,,,0,
326080,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_max_outstanding_settings,,true,,,set_max_outstanding_settings,,,0,
326084,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_max_session_memory,,true,,,set_max_session_memory,,,0,
326088,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_option_set_max_settings,,true,,,nghttp2_option_set_max_settings,,,0,
326093,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,http2_state,,true,,,http2_state,,,0,
326097,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Pack,,true,,,Pack,,,0,
326103,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_pack_settings_payload,,true,,,nghttp2_pack_settings_payload,,,0,
326110,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,h2scope,,true,,,h2scope,,,0,
326114,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_submit_settings,,true,,,nghttp2_submit_settings,,,0,
326121,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_priority_spec_init,,true,,,nghttp2_priority_spec_init,,,0,
326128,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AlignUp,,true,,,AlignUp,,,0,
326133,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_session_callbacks_new,,true,,,nghttp2_session_callbacks_new,,,0,
326137,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_session_callbacks_set_on_begin_headers_callback,,true,,,nghttp2_session_callbacks_set_on_begin_headers_callback,,,0,
326142,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_session_callbacks_set_on_header_callback2,,true,,,nghttp2_session_callbacks_set_on_header_callback2,,,0,
326147,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_session_callbacks_set_on_frame_recv_callback,,true,,,nghttp2_session_callbacks_set_on_frame_recv_callback,,,0,
326152,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_session_callbacks_set_on_stream_close_callback,,true,,,nghttp2_session_callbacks_set_on_stream_close_callback,,,0,
326157,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_session_callbacks_set_on_data_chunk_recv_callback,,true,,,nghttp2_session_callbacks_set_on_data_chunk_recv_callback,,,0,
326162,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_session_callbacks_set_on_frame_not_send_callback,,true,,,nghttp2_session_callbacks_set_on_frame_not_send_callback,,,0,
326167,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_session_callbacks_set_on_invalid_header_callback2,,true,,,nghttp2_session_callbacks_set_on_invalid_header_callback2,,,0,
326172,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_session_callbacks_set_error_callback2,,true,,,nghttp2_session_callbacks_set_error_callback2,,,0,
326177,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_session_callbacks_set_send_data_callback,,true,,,nghttp2_session_callbacks_set_send_data_callback,,,0,
326182,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_session_callbacks_set_on_invalid_frame_recv_callback,,true,,,nghttp2_session_callbacks_set_on_invalid_frame_recv_callback,,,0,
326187,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_session_callbacks_set_on_frame_send_callback,,true,,,nghttp2_session_callbacks_set_on_frame_send_callback,,,0,
326192,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_session_callbacks_set_select_padding_callback,,true,,,nghttp2_session_callbacks_set_select_padding_callback,,,0,
326197,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StopTrackingMemory,,true,,,StopTrackingMemory,,,0,
326201,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,opts,,true,,,opts,,,0,
326206,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,max_session_memory,,true,,,max_session_memory,,,0,
326210,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,max_header_pairs,,true,,,max_header_pairs,,,0,
326214,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetServerMaxHeaderPairs,,true,,,GetServerMaxHeaderPairs,,,0,
326218,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetClientMaxHeaderPairs,,true,,,GetClientMaxHeaderPairs,,,0,
326222,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,max_outstanding_pings,,true,,,max_outstanding_pings,,,0,
326226,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,max_outstanding_settings,,true,,,max_outstanding_settings,,,0,
326230,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,padding_strategy,,true,,,padding_strategy,,,0,
326234,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MakeAllocator,,true,,,MakeAllocator,,,0,
326237,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetArrayBuffer,,true,,,GetArrayBuffer,,,0,
326241,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fields_string,,true,,,fields_string,,,0,
326245,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TypeName,,true,,,TypeName,,,0,
326248,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_http2.cc,node_http2.cc:559:567:SET:2,,true,559,567,SET,,,0,
326251,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SET(bytes_read_string, received_bytes)",,true,,,"SET(bytes_read_string, received_bytes)",,,0,
326255,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SET(bytes_written_string, sent_bytes)",,true,,,"SET(bytes_written_string, sent_bytes)",,,0,
326259,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SET(id_string, id)",,true,,,"SET(id_string, id)",,,0,
326263,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_http2.cc,node_http2.cc:574:583:SET:2,,true,574,583,SET,,,0,
326266,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SET(time_to_first_byte_string, first_byte)",,true,,,"SET(time_to_first_byte_string, first_byte)",,,0,
326270,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SET(time_to_first_byte_sent_string, first_byte_sent)",,true,,,"SET(time_to_first_byte_sent_string, first_byte_sent)",,,0,
326274,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SET(time_to_first_header_string, first_header)",,true,,,"SET(time_to_first_header_string, first_header)",,,0,
326278,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_http2.cc,node_http2.cc:598:606:SET:2,,true,598,606,SET,,,0,
326281,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SET(bytes_written_string, data_sent)",,true,,,"SET(bytes_written_string, data_sent)",,,0,
326285,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SET(bytes_read_string, data_received)",,true,,,"SET(bytes_read_string, data_received)",,,0,
326289,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SET(frames_received_string, frame_count)",,true,,,"SET(frames_received_string, frame_count)",,,0,
326293,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SET(frames_sent_string, frame_sent)",,true,,,"SET(frames_sent_string, frame_sent)",,,0,
326297,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SET(max_concurrent_streams_string, max_concurrent_streams)",,true,,,"SET(max_concurrent_streams_string, max_concurrent_streams)",,,0,
326301,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SET(ping_rtt_string, ping_rtt)",,true,,,"SET(ping_rtt_string, ping_rtt)",,,0,
326305,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SET(stream_average_duration_string, stream_average_duration)",,true,,,"SET(stream_average_duration_string, stream_average_duration)",,,0,
326309,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SET(stream_count_string, stream_count)",,true,,,"SET(stream_count_string, stream_count)",,,0,
326313,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,time_origin,,true,,,time_origin,,,0,
326317,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_closing,,true,,,is_closing,,,0,
326320,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_closing,,true,,,set_closing,,,0,
326323,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_reading_stopped,,true,,,set_reading_stopped,,,0,
326326,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_session_terminate_session,,true,,,nghttp2_session_terminate_session,,,0,
326331,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_destroyed,,true,,,set_destroyed,,,0,
326334,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_write_in_progress,,true,,,is_write_in_progress,,,0,
326337,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ondone_string,,true,,,ondone_string,,,0,
326341,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PopPing,,true,,,PopPing,,,0,
326344,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DetachFromSession,,true,,,DetachFromSession,,,0,
326348,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EmitStatistics,,true,,,EmitStatistics,,,0,
326351,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BaseObjectPtr<Http2Stream>,,true,,,BaseObjectPtr<Http2Stream>,,,0,
326354,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_session_get_local_settings,,true,,,nghttp2_session_get_local_settings,,,0,
326359,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,max_size,,true,,,max_size,,,0,
326363,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,has_available_session_memory,,true,,,has_available_session_memory,,,0,
326368,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IncrementCurrentSessionMemory,,true,,,IncrementCurrentSessionMemory,,,0,
326372,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FindStream,,true,,,FindStream,,,0,
326377,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DecrementCurrentSessionMemory,,true,,,DecrementCurrentSessionMemory,,,0,
326381,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_session_want_read,,true,,,nghttp2_session_want_read,,,0,
326385,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_receive_paused,,true,,,set_receive_paused,,,0,
326389,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_session_mem_recv,,true,,,nghttp2_session_mem_recv,,,0,
326395,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_receive_paused,,true,,,is_receive_paused,,,0,
326398,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_destroyed,,true,,,is_destroyed,,,0,
326401,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,http2session_on_error_function,,true,,,http2session_on_error_function,,,0,
326405,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetFrameID,,true,,,GetFrameID,,,0,
326409,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CanAddStream,,true,,,CanAddStream,,,0,
326413,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Http2Stream.New,,true,,,Http2Stream.New,,,0,
326421,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_submit_rst_stream,,true,,,nghttp2_submit_rst_stream,,,0,
326428,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StartHeaders,,true,,,StartHeaders,,,0,
326433,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddHeader,,true,,,AddHeader,,,0,
326440,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SubmitRstStream,,true,,,SubmitRstStream,,,0,
326445,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HandleDataFrame,,true,,,HandleDataFrame,,,0,
326450,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HandleHeadersFrame,,true,,,HandleHeadersFrame,,,0,
326455,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HandleSettingsFrame,,true,,,HandleSettingsFrame,,,0,
326460,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HandlePriorityFrame,,true,,,HandlePriorityFrame,,,0,
326465,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HandleGoawayFrame,,true,,,HandleGoawayFrame,,,0,
326470,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HandlePingFrame,,true,,,HandlePingFrame,,,0,
326475,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HandleAltSvcFrame,,true,,,HandleAltSvcFrame,,,0,
326480,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HandleOriginFrame,,true,,,HandleOriginFrame,,,0,
326485,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_is_fatal,,true,,,nghttp2_is_fatal,,,0,
326489,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,headers_count,,true,,,headers_count,,,0,
326493,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ClearHeaders,,true,,,ClearHeaders,,,0,
326497,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DecrefHeaders,,true,,,DecrefHeaders,,,0,
326502,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,http2session_on_frame_error_function,,true,,,http2session_on_frame_error_function,,,0,
326506,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,http2session_on_stream_close_function,,true,,,http2session_on_stream_close_function,,,0,
326510,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_session_consume_connection,,true,,,nghttp2_session_consume_connection,,,0,
326515,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_reading,,true,,,is_reading,,,0,
326518,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_session_consume_stream,,true,,,nghttp2_session_consume_stream,,,0,
326524,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_reading_stopped,,true,,,is_reading_stopped,,,0,
326527,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OnMaxFrameSizePadding,,true,,,OnMaxFrameSizePadding,,,0,
326533,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OnDWordAlignedPadding,,true,,,OnDWordAlignedPadding,,,0,
326539,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PassReadErrorToPreviousListener,,true,,,PassReadErrorToPreviousListener,,,0,
326543,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CallJSOnreadMethod,,true,,,CallJSOnreadMethod,,,0,
326551,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,headers_v,,true,,,headers_v,,,0,
326555,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sensitive_v,,true,,,sensitive_v,,,0,
326559,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TransferHeaders,,true,,,TransferHeaders,,,0,
326564,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,headers_category,,true,,,headers_category,,,0,
326568,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,http2session_on_headers_function,,true,,,http2session_on_headers_function,,,0,
326572,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,http2session_on_priority_function,,true,,,http2session_on_priority_function,,,0,
326576,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,http2session_on_goaway_data_function,,true,,,http2session_on_goaway_data_function,,,0,
326580,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,http2session_on_altsvc_function,,true,,,http2session_on_altsvc_function,,,0,
326584,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,origin_v,,true,,,origin_v,,,0,
326588,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,http2session_on_origin_function,,true,,,http2session_on_origin_function,,,0,
326592,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,http2session_on_ping_function,,true,,,http2session_on_ping_function,,,0,
326596,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,http2session_on_settings_function,,true,,,http2session_on_settings_function,,,0,
326600,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PopSettings,,true,,,PopSettings,,,0,
326603,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_write_in_progress,,true,,,set_write_in_progress,,,0,
326607,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ClearOutgoing,,true,,,ClearOutgoing,,,0,
326611,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ConsumeHTTP2Data,,true,,,ConsumeHTTP2Data,,,0,
326614,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_session_want_write,,true,,,nghttp2_session_want_write,,,0,
326618,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_write_scheduled,,true,,,set_write_scheduled,,,0,
326622,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_sending,,true,,,set_sending,,,0,
326625,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FlushRstStream,,true,,,FlushRstStream,,,0,
326628,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PushOutgoingBuffer,,true,,,PushOutgoingBuffer,,,0,
326633,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NgHttp2StreamWrite,,true,,,NgHttp2StreamWrite,,,0,
326637,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_sending,,true,,,is_sending,,,0,
326640,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_session_mem_send,,true,,,nghttp2_session_mem_send,,,0,
326645,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CopyDataIntoOutgoing,,true,,,CopyDataIntoOutgoing,,,0,
326651,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MaybeStopReading,,true,,,MaybeStopReading,,,0,
326654,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,prov,,true,,,prov,,,0,
326659,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_submit_request,,true,,,nghttp2_submit_request,,,0,
326668,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,http2stream_constructor_template,,true,,,http2stream_constructor_template,,,0,
326672,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_has_trailers,,true,,,set_has_trailers,,,0,
326676,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddStream,,true,,,AddStream,,,0,
326681,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,diagnostic_name,,true,,,diagnostic_name,,,0,
326685,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_session_find_stream,,true,,,nghttp2_session_find_stream,,,0,
326690,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_closed,,true,,,set_closed,,,0,
326693,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_not_writable,,true,,,set_not_writable,,,0,
326696,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_session_resume_data,,true,,,nghttp2_session_resume_data,,,0,
326701,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,has_pending_rststream,,true,,,has_pending_rststream,,,0,
326706,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RemoveStream,,true,,,RemoveStream,,,0,
326711,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_writable,,true,,,is_writable,,,0,
326715,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_submit_response,,true,,,nghttp2_submit_response,,,0,
326723,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_submit_headers,,true,,,nghttp2_submit_headers,,,0,
326733,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,http2session_on_stream_trailers_function,,true,,,http2session_on_stream_trailers_function,,,0,
326737,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_submit_data,,true,,,nghttp2_submit_data,,,0,
326744,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_submit_trailer,,true,,,nghttp2_submit_trailer,,,0,
326751,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_session_change_stream_priority,,true,,,nghttp2_session_change_stream_priority,,,0,
326757,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_submit_priority,,true,,,nghttp2_submit_priority,,,0,
326764,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_stream_cancel,,true,,,is_stream_cancel,,,0,
326768,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddPendingRstStream,,true,,,AddPendingRstStream,,,0,
326773,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_submit_push_promise,,true,,,nghttp2_submit_push_promise,,,0,
326782,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_reading,,true,,,set_reading,,,0,
326785,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_paused,,true,,,set_paused,,,0,
326788,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IncrementAvailableOutboundLength,,true,,,IncrementAvailableOutboundLength,,,0,
326792,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Http2RcBufferPointer.IsZeroLength,,true,,,Http2RcBufferPointer.IsZeroLength,,,0,
326797,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,header,,true,,,header,,,0,
326804,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DecrementAvailableOutboundLength,,true,,,DecrementAvailableOutboundLength,,,0,
326809,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EmitWantsWrite,,true,,,EmitWantsWrite,,,0,
326814,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OnRead,,true,,,OnRead,,,0,
326820,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,has_trailers,,true,,,has_trailers,,,0,
326824,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OnTrailers,,true,,,OnTrailers,,,0,
326828,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_strerror,,true,,,nghttp2_strerror,,,0,
326832,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Http2Settings.Pack,,true,,,Http2Settings.Pack,,,0,
326837,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Http2Settings.RefreshDefaults,,true,,,Http2Settings.RefreshDefaults,,,0,
326842,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_session_set_next_stream_id,,true,,,nghttp2_session_set_next_stream_id,,,0,
326847,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_session_set_local_window_size,,true,,,nghttp2_session_set_local_window_size,,,0,
326854,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Http2Settings.Update,,true,,,Http2Settings.Update,,,0,
326860,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_session_get_effective_local_window_size,,true,,,nghttp2_session_get_effective_local_window_size,,,0,
326864,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_session_get_effective_recv_data_length,,true,,,nghttp2_session_get_effective_recv_data_length,,,0,
326868,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_session_get_next_stream_id,,true,,,nghttp2_session_get_next_stream_id,,,0,
326872,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_session_get_local_window_size,,true,,,nghttp2_session_get_local_window_size,,,0,
326876,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_session_get_last_proc_stream_id,,true,,,nghttp2_session_get_last_proc_stream_id,,,0,
326880,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_session_get_remote_window_size,,true,,,nghttp2_session_get_remote_window_size,,,0,
326884,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_session_get_outbound_queue_size,,true,,,nghttp2_session_get_outbound_queue_size,,,0,
326888,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_session_get_hd_deflate_dynamic_table_size,,true,,,nghttp2_session_get_hd_deflate_dynamic_table_size,,,0,
326892,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_session_get_hd_inflate_dynamic_table_size,,true,,,nghttp2_session_get_hd_inflate_dynamic_table_size,,,0,
326896,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Consume,,true,,,Consume,,,0,
326901,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Http2Session.SubmitRequest,,true,,,Http2Session.SubmitRequest,,,0,
326909,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Http2Priority,,true,,,Http2Priority,,,0,
326916,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Http2Headers,,true,,,Http2Headers,,,0,
326921,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_submit_goaway,,true,,,nghttp2_submit_goaway,,,0,
326930,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Goaway,,true,,,Goaway,,,0,
326938,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,chunks_sent_since_last_write_string,,true,,,chunks_sent_since_last_write_string,,,0,
326942,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SubmitResponse,,true,,,SubmitResponse,,,0,
326948,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SubmitInfo,,true,,,SubmitInfo,,,0,
326953,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SubmitTrailers,,true,,,SubmitTrailers,,,0,
326958,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SubmitPushPromise,,true,,,SubmitPushPromise,,,0,
326965,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SubmitPriority,,true,,,SubmitPriority,,,0,
326971,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_stream_get_state,,true,,,nghttp2_stream_get_state,,,0,
326975,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_stream_get_weight,,true,,,nghttp2_stream_get_weight,,,0,
326979,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_stream_get_sum_dependency_weight,,true,,,nghttp2_stream_get_sum_dependency_weight,,,0,
326983,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_session_get_stream_local_close,,true,,,nghttp2_session_get_stream_local_close,,,0,
326988,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_session_get_stream_remote_close,,true,,,nghttp2_session_get_stream_remote_close,,,0,
326993,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_session_get_stream_local_window_size,,true,,,nghttp2_session_get_stream_local_window_size,,,0,
326998,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_submit_altsvc,,true,,,nghttp2_submit_altsvc,,,0,
327008,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_submit_origin,,true,,,nghttp2_submit_origin,,,0,
327015,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AltSvc,,true,,,AltSvc,,,0,
327024,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Origin,,true,,,Origin,,,0,
327029,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Origins,,true,,,Origins,,,0,
327035,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddPing,,true,,,AddPing,,,0,
327041,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddSettings,,true,,,AddSettings,,,0,
327046,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,http2ping_constructor_template,,true,,,http2ping_constructor_template,,,0,
327050,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,http2settings_constructor_template,,true,,,http2settings_constructor_template,,,0,
327054,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nghttp2_submit_ping,,true,,,nghttp2_submit_ping,,,0,
327060,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_http2.cc,node_http2.cc:3144:3146:SET_FUNCTION:2,,true,3144,3146,SET_FUNCTION,,,0,
327064,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SET_FUNCTION(0, error)",,true,,,"SET_FUNCTION(0, error)",,,0,
327068,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SET_FUNCTION(1, priority)",,true,,,"SET_FUNCTION(1, priority)",,,0,
327072,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SET_FUNCTION(2, settings)",,true,,,"SET_FUNCTION(2, settings)",,,0,
327076,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SET_FUNCTION(3, ping)",,true,,,"SET_FUNCTION(3, ping)",,,0,
327080,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SET_FUNCTION(4, headers)",,true,,,"SET_FUNCTION(4, headers)",,,0,
327084,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SET_FUNCTION(5, frame_error)",,true,,,"SET_FUNCTION(5, frame_error)",,,0,
327088,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SET_FUNCTION(6, goaway_data)",,true,,,"SET_FUNCTION(6, goaway_data)",,,0,
327092,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SET_FUNCTION(7, altsvc)",,true,,,"SET_FUNCTION(7, altsvc)",,,0,
327096,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SET_FUNCTION(8, origin)",,true,,,"SET_FUNCTION(8, origin)",,,0,
327100,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SET_FUNCTION(9, stream_trailers)",,true,,,"SET_FUNCTION(9, stream_trailers)",,,0,
327104,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SET_FUNCTION(10, stream_close)",,true,,,"SET_FUNCTION(10, stream_close)",,,0,
327108,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_http2.cc,node_http2.cc:3186:3189:SET_STATE_TYPEDARRAY:2,,true,3186,3189,SET_STATE_TYPEDARRAY,,,0,
327113,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SET_STATE_TYPEDARRAY(
    ""sessionState"", state->session_state_buffer.GetJSArray())",,true,,,"SET_STATE_TYPEDARRAY(
    ""sessionState"", state->session_state_buffer.GetJSArray())",,,0,
327117,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SET_STATE_TYPEDARRAY(
    ""streamState"", state->stream_state_buffer.GetJSArray())",,true,,,"SET_STATE_TYPEDARRAY(
    ""streamState"", state->stream_state_buffer.GetJSArray())",,,0,
327121,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SET_STATE_TYPEDARRAY(
    ""settingsBuffer"", state->settings_buffer.GetJSArray())",,true,,,"SET_STATE_TYPEDARRAY(
    ""settingsBuffer"", state->settings_buffer.GetJSArray())",,,0,
327125,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SET_STATE_TYPEDARRAY(
    ""optionsBuffer"", state->options_buffer.GetJSArray())",,true,,,"SET_STATE_TYPEDARRAY(
    ""optionsBuffer"", state->options_buffer.GetJSArray())",,,0,
327129,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SET_STATE_TYPEDARRAY(
    ""streamStats"", state->stream_stats_buffer.GetJSArray())",,true,,,"SET_STATE_TYPEDARRAY(
    ""streamStats"", state->stream_stats_buffer.GetJSArray())",,,0,
327133,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SET_STATE_TYPEDARRAY(
    ""sessionStats"", state->session_stats_buffer.GetJSArray())",,true,,,"SET_STATE_TYPEDARRAY(
    ""sessionStats"", state->session_stats_buffer.GetJSArray())",,,0,
327137,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, kBitfield)",,true,,,"NODE_DEFINE_CONSTANT(target, kBitfield)",,,0,
327145,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, kSessionPriorityListenerCount)",,true,,,"NODE_DEFINE_CONSTANT(target, kSessionPriorityListenerCount)",,,0,
327153,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, kSessionFrameErrorListenerCount)",,true,,,"NODE_DEFINE_CONSTANT(target, kSessionFrameErrorListenerCount)",,,0,
327161,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, kSessionMaxInvalidFrames)",,true,,,"NODE_DEFINE_CONSTANT(target, kSessionMaxInvalidFrames)",,,0,
327169,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, kSessionMaxRejectedStreams)",,true,,,"NODE_DEFINE_CONSTANT(target, kSessionMaxRejectedStreams)",,,0,
327177,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, kSessionUint8FieldCount)",,true,,,"NODE_DEFINE_CONSTANT(target, kSessionUint8FieldCount)",,,0,
327185,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, kSessionHasRemoteSettingsListeners)",,true,,,"NODE_DEFINE_CONSTANT(target, kSessionHasRemoteSettingsListeners)",,,0,
327193,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, kSessionRemoteSettingsIsUpToDate)",,true,,,"NODE_DEFINE_CONSTANT(target, kSessionRemoteSettingsIsUpToDate)",,,0,
327201,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, kSessionHasPingListeners)",,true,,,"NODE_DEFINE_CONSTANT(target, kSessionHasPingListeners)",,,0,
327209,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, kSessionHasAltsvcListeners)",,true,,,"NODE_DEFINE_CONSTANT(target, kSessionHasAltsvcListeners)",,,0,
327217,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_http2ping_constructor_template,,true,,,set_http2ping_constructor_template,,,0,
327222,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_http2settings_constructor_template,,true,,,set_http2settings_constructor_template,,,0,
327227,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_http2stream_constructor_template,,true,,,set_http2stream_constructor_template,,,0,
327232,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HTTP2_ERROR_CODES,,true,,,HTTP2_ERROR_CODES,,,0,
327236,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(constants, NGHTTP2_DEFAULT_WEIGHT)",,true,,,"NODE_DEFINE_CONSTANT(constants, NGHTTP2_DEFAULT_WEIGHT)",,,0,
327244,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsZeroLength,,true,,,IsZeroLength,,,0,
327250,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,rcbufferpointer_t.IsZeroLength,,true,,,rcbufferpointer_t.IsZeroLength,,,0,
327255,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,T.ToHttpHeaderName,,true,,,T.ToHttpHeaderName,,,0,
327260,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,rcbufferpointer_t.External.New,,true,,,rcbufferpointer_t.External.New,,,0,
327266,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,len,,true,,,len,,,0,
327270,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StringPtr.Reset,,true,,,Reset,,,0,
327273,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsOWS,,true,,,IsOWS,,,0,
327277,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StringPtr.ToString,,true,,,ToString,,,0,
327281,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Parser.TrackHeader,,true,,,TrackHeader,,,0,
327285,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Parser.Flush,,true,,,Flush,,,0,
327288,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Parser.CreateHeaders,,true,,,CreateHeaders,,,0,
327291,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,llhttp_should_keep_alive,,true,,,llhttp_should_keep_alive,,,0,
327295,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,llhttp_set_error_reason,,true,,,llhttp_set_error_reason,,,0,
327300,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Pop,,true,,,Pop,,,0,
327304,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PopActive,,true,,,PopActive,,,0,
327309,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Save,,true,,,Save,,,0,
327313,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Execute,,true,,,Execute,,,0,
327318,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_provider_type,,true,,,set_provider_type,,,0,
327323,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PushActive,,true,,,PushActive,,,0,
327328,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,llhttp_pause,,true,,,llhttp_pause,,,0,
327332,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,llhttp_resume,,true,,,llhttp_resume,,,0,
327336,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Malloc,,true,,,Malloc,,,0,
327340,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,llhttp_finish,,true,,,llhttp_finish,,,0,
327344,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Parser.Save,,true,,,Save,,,0,
327347,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,llhttp_get_error_pos,,true,,,llhttp_get_error_pos,,,0,
327351,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,parse_error_string,,true,,,parse_error_string,,,0,
327355,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,bytes_parsed_string,,true,,,bytes_parsed_string,,,0,
327359,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,llhttp_get_error_reason,,true,,,llhttp_get_error_reason,,,0,
327363,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strchr,,true,,,strchr,,,0,
327368,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,llhttp_errno_name,,true,,,llhttp_errno_name,,,0,
327372,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ToTrimmedString,,true,,,ToTrimmedString,,,0,
327377,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,llhttp_set_lenient_headers,,true,,,llhttp_set_lenient_headers,,,0,
327382,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,llhttp_set_lenient_chunked_length,,true,,,llhttp_set_lenient_chunked_length,,,0,
327387,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,llhttp_set_lenient_keep_alive,,true,,,llhttp_set_lenient_keep_alive,,,0,
327392,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,parser->*Member,,true,,,parser->*Member,,,0,
327397,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MaybePause,,true,,,MaybePause,,,0,
327401,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AsEmbedderWrapper,,true,,,AsEmbedderWrapper,,,0,
327405,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,max_young_generation_size_in_bytes,,true,,,max_young_generation_size_in_bytes,,,0,
327409,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CreateMainEnvironment,,true,,,CreateMainEnvironment,,,0,
327413,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sea.IsSingleExecutable,,true,,,sea.IsSingleExecutable,,,0,
327417,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sea.FindSingleExecutableResource,,true,,,sea.FindSingleExecutableResource,,,0,
327421,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StartExecutionCallback,,true,,,StartExecutionCallback,,,0,
327425,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StartTrackingHeapObjects,,true,,,StartTrackingHeapObjects,,,0,
327430,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CloneForMessaging,,true,,,CloneForMessaging,,,0,
327434,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BaseObjectList,,true,,,BaseObjectList,,,0,
327438,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReadUint32,,true,,,ReadUint32,,,0,
327443,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReadValue,,true,,,ReadValue,,,0,
327448,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WasmModuleObject.FromCompiledModule,,true,,,WasmModuleObject.FromCompiledModule,,,0,
327454,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsCloseMessage,,true,,,IsCloseMessage,,,0,
327458,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,host_objects,,true,,,host_objects,,,0,
327462,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,message_port_constructor_template,,true,,,message_port_constructor_template,,,0,
327466,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SharedArrayBuffer.New,,true,,,SharedArrayBuffer.New,,,0,
327472,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,deserializer,,true,,,deserializer,,,0,
327476,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TransferArrayBuffer,,true,,,TransferArrayBuffer,,,0,
327482,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReadHeader,,true,,,ReadHeader,,,0,
327487,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FinalizeTransferRead,,true,,,FinalizeTransferRead,,,0,
327493,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetDOMException,,true,,,GetDOMException,,,0,
327497,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ThrowDataCloneException,,true,,,ThrowDataCloneException,,,0,
327502,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BaseObject.IsBaseObject,,true,,,BaseObject.IsBaseObject,,,0,
327507,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SerializerDelegate.WriteHostObject,,true,,,WriteHostObject,,,0,
327511,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,env_proxy_ctor_template,,true,,,env_proxy_ctor_template,,,0,
327515,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AssignToObject,,true,,,AssignToObject,,,0,
327522,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteUint32,,true,,,WriteUint32,,,0,
327527,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteValue,,true,,,WriteValue,,,0,
327533,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ThrowDataCloneError,,true,,,ThrowDataCloneError,,,0,
327537,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,clone_unsupported_type_str,,true,,,clone_unsupported_type_str,,,0,
327541,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Global<SharedArrayBuffer>,,true,,,Global<SharedArrayBuffer>,,,0,
327545,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddSharedArrayBuffer,,true,,,AddSharedArrayBuffer,,,0,
327550,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddWASMModule,,true,,,AddWASMModule,,,0,
327555,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetCompiledModule,,true,,,GetCompiledModule,,,0,
327559,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AdoptSharedValueConveyor,,true,,,AdoptSharedValueConveyor,,,0,
327564,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TransferForMessaging,,true,,,TransferForMessaging,,,0,
327568,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FinalizeTransferWrite,,true,,,FinalizeTransferWrite,,,0,
327574,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddTransferable,,true,,,AddTransferable,,,0,
327579,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NestedTransferables,,true,,,NestedTransferables,,,0,
327583,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddHostObject,,true,,,AddHostObject,,,0,
327588,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_MISSING_TRANSFERABLE_IN_TRANSFER_LIST,,true,,,THROW_ERR_MISSING_TRANSFERABLE_IN_TRANSFER_LIST,,,0,
327592,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_empty,,true,,,is_empty,,,0,
327596,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,serializer,,true,,,serializer,,,0,
327601,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,host_object,,true,,,host_object,,,0,
327605,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsDetached,,true,,,IsDetached,,,0,
327609,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_INVALID_TRANSFER_OBJECT,,true,,,THROW_ERR_INVALID_TRANSFER_OBJECT,,,0,
327613,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddNestedHostObjects,,true,,,AddNestedHostObjects,,,0,
327617,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteHeader,,true,,,WriteHeader,,,0,
327621,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Finish,,true,,,Finish,,,0,
327625,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MallocedBuffer<char>,,true,,,MallocedBuffer<char>,,,0,
327630,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Disentangle,,true,,,Disentangle,,,0,
327634,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TriggerAsync,,true,,,TriggerAsync,,,0,
327637,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.make_shared<SiblingGroup>,,true,,,std.make_shared<SiblingGroup>,,,0,
327641,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Entangle,,true,,,Entangle,,,0,
327645,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,oninit_symbol,,true,,,oninit_symbol,,,0,
327649,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetEmitMessageFunction,,true,,,GetEmitMessageFunction,,,0,
327653,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sibling_lock,,true,,,sibling_lock,,,0,
327657,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HandleWrap.Close,,true,,,HandleWrap.Close,,,0,
327662,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_CONSTRUCT_CALL_INVALID,,true,,,THROW_ERR_CONSTRUCT_CALL_INVALID,,,0,
327666,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetMessagePortConstructorTemplate,,true,,,GetMessagePortConstructorTemplate,,,0,
327670,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,no_message_symbol,,true,,,no_message_symbol,,,0,
327674,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Mutex.ScopedLock,,true,,,Mutex.ScopedLock,,,0,
327679,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReceiveMessage,,true,,,ReceiveMessage,,,0,
327685,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,messageerror_string,,true,,,messageerror_string,,,0,
327689,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BaseObjectPtr<MessagePort>,,true,,,BaseObjectPtr<MessagePort>,,,0,
327693,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MessagePort.New,,true,,,MessagePort.New,,,0,
327700,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.make_shared<Message>,,true,,,std.make_shared<Message>,,,0,
327704,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Symbol.GetIterator,,true,,,Symbol.GetIterator,,,0,
327709,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,next_string,,true,,,next_string,,,0,
327713,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,done_string,,true,,,done_string,,,0,
327717,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReadIterable,,true,,,ReadIterable,,,0,
327724,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,transfer_string,,true,,,transfer_string,,,0,
327728,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PostMessage,,true,,,PostMessage,,,0,
327736,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_CLOSED_MESSAGE_PORT,,true,,,THROW_ERR_CLOSED_MESSAGE_PORT,,,0,
327740,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MessagePortData.Entangle,,true,,,MessagePortData.Entangle,,,0,
327746,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,message_port_constructor_string,,true,,,message_port_constructor_string,,,0,
327750,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_message_port_constructor_template,,true,,,set_message_port_constructor_template,,,0,
327755,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,messaging_clone_symbol,,true,,,messaging_clone_symbol,,,0,
327759,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TransferOrClone,,true,,,TransferOrClone,,,0,
327763,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,messaging_transfer_symbol,,true,,,messaging_transfer_symbol,,,0,
327767,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,data_string,,true,,,data_string,,,0,
327771,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,deserialize_info_string,,true,,,deserialize_info_string,,,0,
327775,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,deserialize_info_str,,true,,,deserialize_info_str,,,0,
327780,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,messaging_transfer_list_symbol,,true,,,messaging_transfer_list_symbol,,,0,
327784,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Nothing<BaseObjectList>,,true,,,Nothing<BaseObjectList>,,,0,
327787,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,messaging_deserialize_symbol,,true,,,messaging_deserialize_symbol,,,0,
327791,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,messaging_deserialize_create_object,,true,,,messaging_deserialize_create_object,,,0,
327795,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,expired,,true,,,expired,,,0,
327799,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,has_transferables,,true,,,has_transferables,,,0,
327803,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,transferables,,true,,,transferables,,,0,
327807,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddToIncomingQueue,,true,,,AddToIncomingQueue,,,0,
327812,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_messaging_deserialize_create_object,,true,,,set_messaging_deserialize_create_object,,,0,
327817,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_CONSTRUCT_CALL_REQUIRED,,true,,,THROW_ERR_CONSTRUCT_CALL_REQUIRED,,,0,
327822,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MessagePort.Entangle,,true,,,MessagePort.Entangle,,,0,
327828,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,port1_string,,true,,,port1_string,,,0,
327832,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,port2_string,,true,,,port2_string,,,0,
327836,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SiblingGroup.Get,,true,,,SiblingGroup.Get,,,0,
327841,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_version.hpp,node_version.hpp:57:60:NODE_VERSION_STRING:0,,true,57,60,NODE_VERSION_STRING,,,0,
327844,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.V8.GetVersion,,true,,,v8.V8.GetVersion,,,0,
327848,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_version_string,,true,,,uv_version_string,,,0,
327851,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BrotliEncoderVersion,,true,,,BrotliEncoderVersion,,,0,
327854,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,undici_version.hpp,undici_version.hpp:5:5:UNDICI_VERSION:0,,true,5,5,UNDICI_VERSION,,,0,
327857,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,acorn_version.hpp,acorn_version.hpp:5:5:ACORN_VERSION:0,,true,5,5,ACORN_VERSION,,,0,
327860,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cjs_module_lexer_version.hpp,cjs_module_lexer_version.hpp:5:5:CJS_MODULE_LEXER_VERSION:0,,true,5,5,CJS_MODULE_LEXER_VERSION,,,0,
327863,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,base64_version.hpp,base64_version.hpp:5:5:BASE64_VERSION:0,,true,5,5,BASE64_VERSION,,,0,
327866,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ObjectWrap.persistent,,true,,,persistent,,,0,
327869,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,assert,,true,,,assert,,,0,
327873,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetAlignedPointerFromInternalField,,true,,,GetAlignedPointerFromInternalField,,,0,
327878,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ObjectWrap.MakeWeak,,true,,,MakeWeak,,,0,
327881,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SplitString,,true,,,SplitString,,,0,
327886,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckOptions,,true,,,CheckOptions,,,0,
327892,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddOption,,true,,,AddOption,,,0,
327898,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddAlias,,true,,,AddAlias,,,0,
327903,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Implies,,true,,,Implies,,,0,
327908,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NoOp,,true,,,NoOp,,,0,
327912,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,V8Option,,true,,,V8Option,,,0,
327916,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ImpliesNot,,true,,,ImpliesNot,,,0,
327921,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strtoul,,true,,,strtoul,,,0,
327927,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RemoveBrackets,,true,,,RemoveBrackets,,,0,
327931,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HostPort,,true,,,HostPort,,,0,
327935,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ParseAndValidatePort,,true,,,ParseAndValidatePort,,,0,
327940,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,seekp,,true,,,seekp,,,0,
327946,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_has_serialized_options,,true,,,set_has_serialized_options,,,0,
327951,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Map.New,,true,,,Map.New,,,0,
327956,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,primordials_safe_map_prototype_object,,true,,,primordials_safe_map_prototype_object,,,0,
327960,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Lookup<bool>,,true,,,Lookup<bool>,,,0,
327966,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,host_string,,true,,,host_string,,,0,
327970,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,help_text_string,,true,,,help_text_string,,,0,
327974,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,env_var_settings_string,,true,,,env_var_settings_string,,,0,
327978,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,default_is_true_string,,true,,,default_is_true_string,,,0,
327982,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,options_string,,true,,,options_string,,,0,
327986,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,aliases_string,,true,,,aliases_string,,,0,
327990,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,should_not_register_esm_loader,,true,,,should_not_register_esm_loader,,,0,
327994,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,no_global_search_paths,,true,,,no_global_search_paths,,,0,
327998,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,no_browser_globals,,true,,,no_browser_globals,,,0,
328002,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,opt_getter,,true,,,opt_getter,,,0,
328006,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_os_free_passwd,,true,,,uv_os_free_passwd,,,0,
328010,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_os_gethostname,,true,,,uv_os_gethostname,,,0,
328015,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CollectUVExceptionInfo,,true,,,CollectUVExceptionInfo,,,0,
328022,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_os_uname,,true,,,uv_os_uname,,,0,
328026,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_cpu_info,,true,,,uv_cpu_info,,,0,
328031,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_free_cpu_info,,true,,,uv_free_cpu_info,,,0,
328036,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_uptime,,true,,,uv_uptime,,,0,
328040,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<Float64Array>,,true,,,As<Float64Array>,,,0,
328044,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_loadavg,,true,,,uv_loadavg,,,0,
328048,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_interface_addresses,,true,,,uv_interface_addresses,,,0,
328053,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ipv4_string,,true,,,ipv4_string,,,0,
328057,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ipv6_string,,true,,,ipv6_string,,,0,
328061,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strncpy,,true,,,strncpy,,,0,
328067,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,unknown_string,,true,,,unknown_string,,,0,
328071,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_free_interface_addresses,,true,,,uv_free_interface_addresses,,,0,
328076,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_os_homedir,,true,,,uv_os_homedir,,,0,
328081,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,encoding_string,,true,,,encoding_string,,,0,
328085,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_os_get_passwd,,true,,,uv_os_get_passwd,,,0,
328089,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uid_string,,true,,,uid_string,,,0,
328093,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gid_string,,true,,,gid_string,,,0,
328097,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,username_string,,true,,,username_string,,,0,
328101,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,homedir_string,,true,,,homedir_string,,,0,
328105,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,shell_string,,true,,,shell_string,,,0,
328109,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_os_setpriority,,true,,,uv_os_setpriority,,,0,
328114,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_os_getpriority,,true,,,uv_os_getpriority,,,0,
328119,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_available_parallelism,,true,,,uv_available_parallelism,,,0,
328122,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TRACE_COUNTER1,,true,,,TRACE_COUNTER1,,,0,
328128,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TRACE_EVENT_INSTANT_WITH_TIMESTAMP0,,true,,,TRACE_EVENT_INSTANT_WITH_TIMESTAMP0,,,0,
328135,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetPerformanceMilestoneName,,true,,,GetPerformanceMilestoneName,,,0,
328139,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_performance_entry_callback,,true,,,set_performance_entry_callback,,,0,
328144,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,kind_string,,true,,,kind_string,,,0,
328148,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_perf.cc,node_perf.cc:38:38:NANOS_PER_MILLIS:0,,true,38,38,NANOS_PER_MILLIS,,,0,
328151,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GCPerformanceEntry.Details,,true,,,GCPerformanceEntry.Details,,,0,
328157,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RemoveGCPrologueCallback,,true,,,RemoveGCPrologueCallback,,,0,
328163,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RemoveGCEpilogueCallback,,true,,,RemoveGCEpilogueCallback,,,0,
328169,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddGCPrologueCallback,,true,,,AddGCPrologueCallback,,,0,
328175,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddGCEpilogueCallback,,true,,,AddGCEpilogueCallback,,,0,
328181,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GarbageCollectionCleanupHook,,true,,,GarbageCollectionCleanupHook,,,0,
328185,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetDebugName,,true,,,GetDebugName,,,0,
328189,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetBoundFunction,,true,,,GetBoundFunction,,,0,
328193,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ToPerformanceEntryTypeEnum,,true,,,ToPerformanceEntryTypeEnum,,,0,
328197,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,performance_entry_callback,,true,,,performance_entry_callback,,,0,
328201,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_metrics_idle_time,,true,,,uv_metrics_idle_time,,,0,
328205,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IntervalHistogram.Create,,true,,,IntervalHistogram.Create,,,0,
328213,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,time_origin_timestamp,,true,,,time_origin_timestamp,,,0,
328217,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_perf.cc,node_perf.cc:36:36:MICROS_PER_MILLIS:0,,true,36,36,MICROS_PER_MILLIS,,,0,
328220,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HistogramBase.Initialize,,true,,,HistogramBase.Initialize,,,0,
328226,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_MAJOR)",,true,,,"NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_MAJOR)",,,0,
328234,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_MINOR)",,true,,,"NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_MINOR)",,,0,
328242,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_INCREMENTAL)",,true,,,"NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_INCREMENTAL)",,,0,
328250,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_WEAKCB)",,true,,,"NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_WEAKCB)",,,0,
328258,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_NO)",,true,,,"NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_NO)",,,0,
328266,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_CONSTRUCT_RETAINED)",,true,,,"NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_CONSTRUCT_RETAINED)",,,0,
328274,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_FORCED)",,true,,,"NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_FORCED)",,,0,
328282,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_SYNCHRONOUS_PHANTOM_PROCESSING)",,true,,,"NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_SYNCHRONOUS_PHANTOM_PROCESSING)",,,0,
328290,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_ALL_AVAILABLE_GARBAGE)",,true,,,"NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_ALL_AVAILABLE_GARBAGE)",,,0,
328298,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_ALL_EXTERNAL_MEMORY)",,true,,,"NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_ALL_EXTERNAL_MEMORY)",,,0,
328306,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_SCHEDULE_IDLE)",,true,,,"NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_SCHEDULE_IDLE)",,,0,
328314,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HistogramBase.RegisterExternalReferences,,true,,,HistogramBase.RegisterExternalReferences,,,0,
328319,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IntervalHistogram.RegisterExternalReferences,,true,,,IntervalHistogram.RegisterExternalReferences,,,0,
328324,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,flush_tasks,,true,,,flush_tasks,,,0,
328328,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DecreaseHandleCount,,true,,,DecreaseHandleCount,,,0,
328332,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,task,,true,,,task,,,0,
328336,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,worker_data,,true,,,worker_data,,,0,
328340,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TRACE_EVENT_METADATA1,,true,,,TRACE_EVENT_METADATA1,,,0,
328347,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BlockingPop,,true,,,BlockingPop,,,0,
328351,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NotifyOfCompletion,,true,,,NotifyOfCompletion,,,0,
328355,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,t,,true,,,t,,,0,
328359,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_sem_init,,true,,,uv_sem_init,,,0,
328364,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_sem_wait,,true,,,uv_sem_wait,,,0,
328368,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_sem_destroy,,true,,,uv_sem_destroy,,,0,
328372,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_sem_post,,true,,,uv_sem_post,,,0,
328376,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TakeTimerTask,,true,,,TakeTimerTask,,,0,
328381,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,llround,,true,,,llround,,,0,
328385,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,timer,,true,,,timer,,,0,
328389,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_timer_stop,,true,,,uv_timer_stop,,,0,
328393,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PostDelayedTask,,true,,,PostDelayedTask,,,0,
328399,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BlockingDrain,,true,,,BlockingDrain,,,0,
328403,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FlushForegroundTasksInternal,,true,,,FlushForegroundTasksInternal,,,0,
328407,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,delayed,,true,,,delayed,,,0,
328411,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PostTask,,true,,,PostTask,,,0,
328416,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ShutdownCallback,,true,,,ShutdownCallback,,,0,
328420,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PopAll,,true,,,PopAll,,,0,
328424,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetActualThreadPoolSize,,true,,,GetActualThreadPoolSize,,,0,
328428,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std::shared_ptr<PerIsolatePlatformData>,,true,,,std::shared_ptr<PerIsolatePlatformData>,,,0,
328432,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddShutdownCallback,,true,,,AddShutdownCallback,,,0,
328438,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NumberOfWorkerThreads,,true,,,NumberOfWorkerThreads,,,0,
328441,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.find_if,,true,,,std.find_if,,,0,
328448,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RunForegroundTask,,true,,,RunForegroundTask,,,0,
328452,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DeleteFromScheduledTasks,,true,,,DeleteFromScheduledTasks,,,0,
328457,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ForNodeIsolate,,true,,,ForNodeIsolate,,,0,
328461,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.platform.NewDefaultJobHandle,,true,,,v8.platform.NewDefaultJobHandle,,,0,
328469,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IdleTasksEnabled,,true,,,IdleTasksEnabled,,,0,
328473,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ForIsolate,,true,,,ForIsolate,,,0,
328477,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetForegroundTaskRunner,,true,,,GetForegroundTaskRunner,,,0,
328481,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SystemClockTimeMillis,,true,,,SystemClockTimeMillis,,,0,
328484,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_postmortem_metadata.cc,node_postmortem_metadata.cc:8:8:NODE_OFF_EXTSTR_DATA:0,,true,8,8,NODE_OFF_EXTSTR_DATA,,,0,
328487,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"OffsetOf<ListNode<ReqWrapBase>,ReqWrap<uv_req_t>>",,true,,,"OffsetOf<ListNode<ReqWrapBase>,ReqWrap<uv_req_t>>",,,0,
328491,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_postmortem_metadata.cc,node_postmortem_metadata.cc:20:36:NODE_OFFSET_POSTMORTEM_METADATA:1,,true,20,36,NODE_OFFSET_POSTMORTEM_METADATA,,,0,
328494,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OffsetOf,,true,,,OffsetOf,,,0,
328498,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GenDebugSymbols,,true,,,GenDebugSymbols,,,0,
328501,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,emit_warning_string,,true,,,emit_warning_string,,,0,
328505,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_chdir,,true,,,uv_chdir,,,0,
328509,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_getrusage,,true,,,uv_getrusage,,,0,
328513,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,get_fields_array_buffer,,true,,,get_fields_array_buffer,,,0,
328519,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_process_methods.cc,node_process_methods.cc:62:62:MICROS_PER_SEC:0,,true,62,62,MICROS_PER_SEC,,,0,
328522,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HasSignalJSHandler,,true,,,HasSignalJSHandler,,,0,
328526,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_kill,,true,,,uv_kill,,,0,
328531,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetHeapStatistics,,true,,,GetHeapStatistics,,,0,
328536,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,total_heap_size,,true,,,total_heap_size,,,0,
328540,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,used_heap_size,,true,,,used_heap_size,,,0,
328544,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,external_memory,,true,,,external_memory,,,0,
328548,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,total_mem_usage,,true,,,total_mem_usage,,,0,
328552,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,umask,,true,,,umask,,,0,
328556,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_update_time,,true,,,uv_update_time,,,0,
328560,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_process_methods.cc,node_process_methods.cc:64:64:NANOS_PER_SEC:0,,true,64,64,NANOS_PER_SEC,,,0,
328563,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,req_wrap_queue,,true,,,req_wrap_queue,,,0,
328567,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MemoryInfoName,,true,,,MemoryInfoName,,,0,
328571,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,timeout_info,,true,,,timeout_info,,,0,
328575,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BigIntImpl,,true,,,BigIntImpl,,,0,
328579,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NumberImpl,,true,,,NumberImpl,,,0,
328583,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BindingData.AddMethods,,true,,,BindingData.AddMethods,,,0,
328589,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetProcessTitle,,true,,,GetProcessTitle,,,0,
328593,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,title,,true,,,title,,,0,
328598,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,inspector_host_port,,true,,,inspector_host_port,,,0,
328602,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_os_getppid,,true,,,uv_os_getppid,,,0,
328605,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,process_string,,true,,,process_string,,,0,
328609,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,exit_info_private_symbol,,true,,,exit_info_private_symbol,,,0,
328613,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,exit_info,,true,,,exit_info,,,0,
328617,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,READONLY_STRING_PROPERTY,,true,,,READONLY_STRING_PROPERTY,,,0,
328623,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NODE_VERSIONS_KEYS,,true,,,NODE_VERSIONS_KEYS,,,0,
328627,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,exec_argv,,true,,,exec_argv,,,0,
328631,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,exec_path,,true,,,exec_path,,,0,
328635,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsNotIndicativeOfMemoryLeakAtExit,,true,,,IsNotIndicativeOfMemoryLeakAtExit,,,0,
328639,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ContextInfo,,true,,,ContextInfo,,,0,
328643,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,primordials_string,,true,,,primordials_string,,,0,
328647,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_primordials,,true,,,set_primordials,,,0,
328651,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_realm.cc,node_realm.cc:58:70:V:2,,true,58,70,V,,,0,
328655,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"V(primordials_safe_map_prototype_object, ""SafeMap"")",,true,,,"V(primordials_safe_map_prototype_object, ""SafeMap"")",,,0,
328659,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_primordials_safe_map_prototype_object,,true,,,set_primordials_safe_map_prototype_object,,,0,
328663,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"V(primordials_safe_set_prototype_object, ""SafeSet"")",,true,,,"V(primordials_safe_set_prototype_object, ""SafeSet"")",,,0,
328667,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_primordials_safe_set_prototype_object,,true,,,set_primordials_safe_set_prototype_object,,,0,
328671,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"V(primordials_safe_weak_map_prototype_object, ""SafeWeakMap"")",,true,,,"V(primordials_safe_weak_map_prototype_object, ""SafeWeakMap"")",,,0,
328675,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_primordials_safe_weak_map_prototype_object,,true,,,set_primordials_safe_weak_map_prototype_object,,,0,
328679,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"V(primordials_safe_weak_set_prototype_object, ""SafeWeakSet"")",,true,,,"V(primordials_safe_weak_set_prototype_object, ""SafeWeakSet"")",,,0,
328683,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_primordials_safe_weak_set_prototype_object,,true,,,set_primordials_safe_weak_set_prototype_object,,,0,
328687,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SerializeSnapshotableObjects,,true,,,SerializeSnapshotableObjects,,,0,
328693,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DoneBootstrapping,,true,,,DoneBootstrapping,,,0,
328696,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BootstrapRealm,,true,,,BootstrapRealm,,,0,
328699,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ForEachBaseObject,,true,,,ForEachBaseObject,,,0,
328704,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CreateEnvProxyTemplate,,true,,,CreateEnvProxyTemplate,,,0,
328709,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetNodeReport,,true,,,GetNodeReport,,,0,
328717,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.iswspace,,true,,,std.iswspace,,,0,
328722,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DiagnosticFilename.LocalTime,,true,,,DiagnosticFilename.LocalTime,,,0,
328727,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,old_state,,true,,,old_state,,,0,
328731,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,copyfmt,,true,,,copyfmt,,,0,
328736,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,writer,,true,,,writer,,,0,
328740,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,json_start,,true,,,json_start,,,0,
328744,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,json_objectstart,,true,,,json_objectstart,,,0,
328749,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,json_keyvalue,,true,,,json_keyvalue,,,0,
328755,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,JSONWriter::Null,,true,,,JSONWriter::Null,,,0,
328759,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_gettimeofday,,true,,,uv_gettimeofday,,,0,
328763,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,json_arraystart,,true,,,json_arraystart,,,0,
328768,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,json_element,,true,,,json_element,,,0,
328773,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,json_arrayend,,true,,,json_arrayend,,,0,
328777,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PrintVersionInformation,,true,,,PrintVersionInformation,,,0,
328781,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,json_objectend,,true,,,json_objectend,,,0,
328785,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PrintJavaScriptErrorStack,,true,,,PrintJavaScriptErrorStack,,,0,
328792,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PrintGCStatistics,,true,,,PrintGCStatistics,,,0,
328797,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PrintEmptyJavaScriptStack,,true,,,PrintEmptyJavaScriptStack,,,0,
328801,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PrintNativeStack,,true,,,PrintNativeStack,,,0,
328805,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PrintResourceUsage,,true,,,PrintResourceUsage,,,0,
328809,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueToHexString,,true,,,ValueToHexString,,,0,
328813,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,json_end,,true,,,json_end,,,0,
328817,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ForEachWorker,,true,,,ForEachWorker,,,0,
328822,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,JSONWriter::ForeignJSON,,true,,,JSONWriter::ForeignJSON,,,0,
328826,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PrintSystemInformation,,true,,,PrintSystemInformation,,,0,
328830,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dlsym,,true,,,dlsym,,,0,
328835,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,*libc_version,,true,,,*libc_version,,,0,
328839,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PrintComponentVersions,,true,,,PrintComponentVersions,,,0,
328843,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PrintRelease,,true,,,PrintRelease,,,0,
328847,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PrintCpuInfo,,true,,,PrintCpuInfo,,,0,
328851,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PrintNetworkInterfaceInfo,,true,,,PrintNetworkInterfaceInfo,,,0,
328855,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,k,,true,,,k,,,0,
328860,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v,,true,,,v,,,0,
328865,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<v8.Symbol>,,true,,,As<v8.Symbol>,,,0,
328869,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sv,,true,,,sv,,,0,
328874,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Just<>,,true,,,Just<>,,,0,
328878,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetStackSample,,true,,,GetStackSample,,,0,
328886,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,function_name,,true,,,function_name,,,0,
328891,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PrintJavaScriptStack,,true,,,PrintJavaScriptStack,,,0,
328897,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ErrorToString,,true,,,ErrorToString,,,0,
328903,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PrintJavaScriptErrorProperties,,true,,,PrintJavaScriptErrorProperties,,,0,
328909,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,total_heap_size_executable,,true,,,total_heap_size_executable,,,0,
328913,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,total_physical_size,,true,,,total_physical_size,,,0,
328917,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,total_available_size,,true,,,total_available_size,,,0,
328921,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,total_global_handles_size,,true,,,total_global_handles_size,,,0,
328925,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,used_global_handles_size,,true,,,used_global_handles_size,,,0,
328929,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,heap_size_limit,,true,,,heap_size_limit,,,0,
328933,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,malloced_memory,,true,,,malloced_memory,,,0,
328937,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,peak_malloced_memory,,true,,,peak_malloced_memory,,,0,
328941,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,number_of_native_contexts,,true,,,number_of_native_contexts,,,0,
328945,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,number_of_detached_contexts,,true,,,number_of_detached_contexts,,,0,
328949,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,does_zap_garbage,,true,,,does_zap_garbage,,,0,
328953,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,space_size,,true,,,space_size,,,0,
328957,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,physical_space_size,,true,,,physical_space_size,,,0,
328961,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,space_available_size,,true,,,space_available_size,,,0,
328965,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getrlimit,,true,,,getrlimit,,,0,
328970,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PrintLoadedLibraries,,true,,,PrintLoadedLibraries,,,0,
328974,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NativeSymbolDebuggingContext.GetLoadedLibraries,,true,,,NativeSymbolDebuggingContext.GetLoadedLibraries,,,0,
328978,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DiagnosticFilename,,true,,,DiagnosticFilename,,,0,
328984,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,open,,true,,,open,,,0,
328990,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_open,,true,,,is_open,,,0,
328994,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,report.WriteNodeReport,,true,,,report.WriteNodeReport,,,0,
329006,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,trigger,,true,,,trigger,,,0,
329011,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,String.Utf8Value,,true,,,String.Utf8Value,,,0,
329017,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,signal,,true,,,signal,,,0,
329022,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_getnameinfo,,true,,,uv_getnameinfo,,,0,
329030,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.stoi,,true,,,std.stoi,,,0,
329035,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_udp_getsockname,,true,,,uv_udp_getsockname,,,0,
329041,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReportEndpoint,,true,,,ReportEndpoint,,,0,
329048,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_udp_getpeername,,true,,,uv_udp_getpeername,,,0,
329054,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_tcp_getpeername,,true,,,uv_tcp_getpeername,,,0,
329060,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_pipe_getsockname,,true,,,uv_pipe_getsockname,,,0,
329066,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetLength,,true,,,SetLength,,,0,
329071,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_pipe_getpeername,,true,,,uv_pipe_getpeername,,,0,
329077,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_fs_event_getpath,,true,,,uv_fs_event_getpath,,,0,
329083,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_fs_poll_getpath,,true,,,uv_fs_poll_getpath,,,0,
329089,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_has_ref,,true,,,uv_has_ref,,,0,
329093,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReportPath,,true,,,ReportPath,,,0,
329098,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReportEndpoints,,true,,,ReportEndpoints,,,0,
329103,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReportPipeEndpoints,,true,,,ReportPipeEndpoints,,,0,
329108,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_timer_get_repeat,,true,,,uv_timer_get_repeat,,,0,
329112,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_tty_get_winsize,,true,,,uv_tty_get_winsize,,,0,
329118,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,signo_string,,true,,,signo_string,,,0,
329122,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_send_buffer_size,,true,,,uv_send_buffer_size,,,0,
329127,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_recv_buffer_size,,true,,,uv_recv_buffer_size,,,0,
329132,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_fileno,,true,,,uv_fileno,,,0,
329137,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_udp_get_send_queue_size,,true,,,uv_udp_get_send_queue_size,,,0,
329141,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_udp_get_send_queue_count,,true,,,uv_udp_get_send_queue_count,,,0,
329145,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,postject_find_resource,,true,,,postject_find_resource,,,0,
329151,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FindSingleExecutableBlob,,true,,,FindSingleExecutableBlob,,,0,
329154,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SeaDeserializer.Read<SeaResource>,,true,,,Read<SeaResource>,,,0,
329158,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteStringView,,true,,,WriteStringView,,,0,
329163,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReadArithmetic<uint32_t>,,true,,,ReadArithmetic<uint32_t>,,,0,
329167,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReadStringView,,true,,,ReadStringView,,,0,
329171,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,postject_has_resource,,true,,,postject_has_resource,,,0,
329174,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsSingleExecutable,,true,,,IsSingleExecutable,,,0,
329177,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FindSingleExecutableResource,,true,,,FindSingleExecutableResource,,,0,
329180,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetTopLevelStringField,,true,,,GetTopLevelStringField,,,0,
329185,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetTopLevelBoolField,,true,,,GetTopLevelBoolField,,,0,
329190,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SeaSerializer.Write,,true,,,Write,,,0,
329195,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ParseSingleExecutableConfig,,true,,,ParseSingleExecutableConfig,,,0,
329199,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GenerateSingleExecutableBlob,,true,,,GenerateSingleExecutableBlob,,,0,
329203,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,get_data_clone_error_string,,true,,,get_data_clone_error_string,,,0,
329207,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,get_shared_array_buffer_id_string,,true,,,get_shared_array_buffer_id_string,,,0,
329211,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueSerializer.Delegate.GetSharedArrayBufferId,,true,,,ValueSerializer.Delegate.GetSharedArrayBufferId,,,0,
329217,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Nothing<uint32_t>,,true,,,Nothing<uint32_t>,,,0,
329220,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,write_host_object_string,,true,,,write_host_object_string,,,0,
329224,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueSerializer.Delegate.WriteHostObject,,true,,,ValueSerializer.Delegate.WriteHostObject,,,0,
329230,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetTreatArrayBufferViewsAsHostObjects,,true,,,SetTreatArrayBufferViewsAsHostObjects,,,0,
329235,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteUint64,,true,,,WriteUint64,,,0,
329240,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteDouble,,true,,,WriteDouble,,,0,
329245,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteRawBytes,,true,,,WriteRawBytes,,,0,
329251,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,buffer_string,,true,,,buffer_string,,,0,
329255,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,read_host_object_string,,true,,,read_host_object_string,,,0,
329259,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueDeserializer.Delegate.ReadHostObject,,true,,,ValueDeserializer.Delegate.ReadHostObject,,,0,
329264,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,allow_js,,true,,,allow_js,,,0,
329268,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TransferSharedArrayBuffer,,true,,,TransferSharedArrayBuffer,,,0,
329274,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetWireFormatVersion,,true,,,GetWireFormatVersion,,,0,
329278,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReadUint64,,true,,,ReadUint64,,,0,
329283,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReadDouble,,true,,,ReadDouble,,,0,
329288,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReadRawBytes,,true,,,ReadRawBytes,,,0,
329294,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReadOnlyPrototype,,true,,,ReadOnlyPrototype,,,0,
329298,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ShadowRealm.New,,true,,,ShadowRealm.New,,,0,
329303,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TrackShadowRealm,,true,,,TrackShadowRealm,,,0,
329308,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,UntrackShadowRealm,,true,,,UntrackShadowRealm,,,0,
329313,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_snapshotable,,true,,,is_snapshotable,,,0,
329317,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetTypeName,,true,,,GetTypeName,,,0,
329321,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PrepareForSerialization,,true,,,PrepareForSerialization,,,0,
329327,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReadArithmetic<int>,,true,,,ReadArithmetic<int>,,,0,
329330,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.unique_ptr<char>,,true,,,std.unique_ptr<char>,,,0,
329335,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReadArithmetic<char>,,true,,,ReadArithmetic<char>,,,0,
329340,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8::StartupData,,true,,,v8::StartupData,,,0,
329344,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteArithmetic<int>,,true,,,WriteArithmetic<int>,,,0,
329348,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteArithmetic<char>,,true,,,WriteArithmetic<char>,,,0,
329353,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReadString,,true,,,ReadString,,,0,
329356,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReadVector<uint8_t>,,true,,,ReadVector<uint8_t>,,,0,
329359,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ToStr,,true,,,ToStr,,,0,
329363,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteString,,true,,,WriteString,,,0,
329367,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteArithmetic,,true,,,WriteArithmetic,,,0,
329372,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReadArithmetic<SnapshotIndex>,,true,,,ReadArithmetic<SnapshotIndex>,,,0,
329375,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReadArithmetic<AliasedBufferIndex>,,true,,,ReadArithmetic<AliasedBufferIndex>,,,0,
329378,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReadVector<SnapshotIndex>,,true,,,ReadVector<SnapshotIndex>,,,0,
329381,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReadVector<PropInfo>,,true,,,ReadVector<PropInfo>,,,0,
329384,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReadVector<std.string>,,true,,,ReadVector<std.string>,,,0,
329388,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Read<AsyncHooks.SerializeInfo>,,true,,,Read<AsyncHooks.SerializeInfo>,,,0,
329392,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Read<TickInfo.SerializeInfo>,,true,,,Read<TickInfo.SerializeInfo>,,,0,
329396,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Read<ImmediateInfo.SerializeInfo>,,true,,,Read<ImmediateInfo.SerializeInfo>,,,0,
329400,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Read<performance.PerformanceState.SerializeInfo>,,true,,,Read<performance.PerformanceState.SerializeInfo>,,,0,
329404,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Read<RealmSerializeInfo>,,true,,,Read<RealmSerializeInfo>,,,0,
329407,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Write<AsyncHooks.SerializeInfo>,,true,,,Write<AsyncHooks.SerializeInfo>,,,0,
329412,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Write<TickInfo.SerializeInfo>,,true,,,Write<TickInfo.SerializeInfo>,,,0,
329417,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Write<ImmediateInfo.SerializeInfo>,,true,,,Write<ImmediateInfo.SerializeInfo>,,,0,
329422,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Write<performance.PerformanceState.SerializeInfo>,,true,,,Write<performance.PerformanceState.SerializeInfo>,,,0,
329427,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Write<RealmSerializeInfo>,,true,,,Write<RealmSerializeInfo>,,,0,
329431,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReadArithmetic<uint8_t>,,true,,,ReadArithmetic<uint8_t>,,,0,
329434,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,r,,true,,,r,,,0,
329438,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Read<SnapshotMetadata>,,true,,,Read<SnapshotMetadata>,,,0,
329442,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Read<v8.StartupData>,,true,,,Read<v8.StartupData>,,,0,
329446,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Read<IsolateDataSerializeInfo>,,true,,,Read<IsolateDataSerializeInfo>,,,0,
329450,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Read<EnvSerializeInfo>,,true,,,Read<EnvSerializeInfo>,,,0,
329454,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReadVector<builtins.CodeCacheInfo>,,true,,,ReadVector<builtins.CodeCacheInfo>,,,0,
329458,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.ScriptCompiler.CachedDataVersionTag,,true,,,v8.ScriptCompiler.CachedDataVersionTag,,,0,
329462,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetCodeCacheDefName,,true,,,GetCodeCacheDefName,,,0,
329466,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteVector,,true,,,WriteVector,,,0,
329472,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteStaticCodeCacheDataAsArray,,true,,,WriteStaticCodeCacheDataAsArray,,,0,
329477,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteCodeCacheInitializer,,true,,,WriteCodeCacheInitializer,,,0,
329483,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.make_unique<ExternalReferenceRegistry>,,true,,,std.make_unique<ExternalReferenceRegistry>,,,0,
329487,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,external_references,,true,,,external_references,,,0,
329491,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CollectExternalReferences,,true,,,CollectExternalReferences,,,0,
329494,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CommonEnvironmentSetup.CreateForSnapshotting,,true,,,CommonEnvironmentSetup.CreateForSnapshotting,,,0,
329502,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CreateSnapshot,,true,,,CreateSnapshot,,,0,
329508,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,snapshot_creator,,true,,,snapshot_creator,,,0,
329512,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,contextify.ContextifyContext.CreateV8Context,,true,,,contextify.ContextifyContext.CreateV8Context,,,0,
329520,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetDefaultContext,,true,,,SetDefaultContext,,,0,
329525,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddContext,,true,,,AddContext,,,0,
329531,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CreateBlob,,true,,,CreateBlob,,,0,
329536,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CanBeRehashed,,true,,,CanBeRehashed,,,0,
329540,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SnapshotMetadata,,true,,,SnapshotMetadata,,,0,
329544,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Generate,,true,,,Generate,,,0,
329551,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FormatBlob,,true,,,FormatBlob,,,0,
329556,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StartupData,,true,,,StartupData,,,0,
329560,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,embedder_entry_point,,true,,,embedder_entry_point,,,0,
329564,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,snapshot_deserialize_callback,,true,,,snapshot_deserialize_callback,,,0,
329568,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_snapshot_deserialize_callback,,true,,,set_snapshot_deserialize_callback,,,0,
329573,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_snapshot_deserialize_main,,true,,,set_snapshot_deserialize_main,,,0,
329578,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DCHECK_IMPLIES,,true,,,DCHECK_IMPLIES,,,0,
329583,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,storage,,true,,,storage,,,0,
329587,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ToSockAddr,,true,,,ToSockAddr,,,0,
329594,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,family,,true,,,family,,,0,
329598,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,raw,,true,,,raw,,,0,
329602,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,hash_combine,,true,,,hash_combine,,,0,
329609,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FromUVHandle,,true,,,FromUVHandle,,,0,
329614,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ntohl,,true,,,ntohl,,,0,
329618,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,compare_ipv6,,true,,,compare_ipv6,,,0,
329623,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,compare_ipv4_ipv6,,true,,,compare_ipv4_ipv6,,,0,
329628,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_match_ipv4,,true,,,is_match_ipv4,,,0,
329633,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_match_ipv4_ipv6,,true,,,is_match_ipv4_ipv6,,,0,
329638,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_match_ipv6,,true,,,is_match_ipv6,,,0,
329643,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,compare_ipv4,,true,,,compare_ipv4,,,0,
329648,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,in_network_ipv4,,true,,,in_network_ipv4,,,0,
329654,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,in_network_ipv4_ipv6,,true,,,in_network_ipv4_ipv6,,,0,
329660,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,in_network_ipv6_ipv4,,true,,,in_network_ipv6_ipv4,,,0,
329666,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,in_network_ipv6,,true,,,in_network_ipv6,,,0,
329672,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,emplace_front,,true,,,emplace_front,,,0,
329677,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_match,,true,,,is_match,,,0,
329682,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_in_network,,true,,,is_in_network,,,0,
329688,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ListRules,,true,,,ListRules,,,0,
329693,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ToV8String,,true,,,ToV8String,,,0,
329698,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,blocklist_constructor_template,,true,,,blocklist_constructor_template,,,0,
329702,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BaseObjectPtr<SocketAddressBlockListWrap>,,true,,,BaseObjectPtr<SocketAddressBlockListWrap>,,,0,
329705,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SocketAddressBase.HasInstance,,true,,,SocketAddressBase.HasInstance,,,0,
329711,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddSocketAddress,,true,,,AddSocketAddress,,,0,
329716,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddSocketAddressRange,,true,,,AddSocketAddressRange,,,0,
329722,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddSocketAddressMask,,true,,,AddSocketAddressMask,,,0,
329728,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MemoryInfo,,true,,,MemoryInfo,,,0,
329733,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_blocklist_constructor_template,,true,,,set_blocklist_constructor_template,,,0,
329738,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SocketAddressBase.Initialize,,true,,,SocketAddressBase.Initialize,,,0,
329744,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,socketaddress_constructor_template,,true,,,socketaddress_constructor_template,,,0,
329748,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_socketaddress_constructor_template,,true,,,set_socketaddress_constructor_template,,,0,
329753,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BaseObjectPtr<SocketAddressBase>,,true,,,BaseObjectPtr<SocketAddressBase>,,,0,
329756,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.make_shared<SocketAddress>,,true,,,std.make_shared<SocketAddress>,,,0,
329760,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_INVALID_ADDRESS,,true,,,THROW_ERR_INVALID_ADDRESS,,,0,
329764,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_flow_label,,true,,,set_flow_label,,,0,
329769,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,family_string,,true,,,family_string,,,0,
329773,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,flowlabel_string,,true,,,flowlabel_string,,,0,
329777,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,flow_label,,true,,,flow_label,,,0,
329781,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ToJS,,true,,,ToJS,,,0,
329786,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SocketAddressBase.Create,,true,,,SocketAddressBase.Create,,,0,
329792,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_fs_poll_init,,true,,,uv_fs_poll_init,,,0,
329797,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fs.FillGlobalStatsArray,,true,,,fs.FillGlobalStatsArray,,,0,
329805,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_fs_poll_start,,true,,,uv_fs_poll_start,,,0,
329812,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.Just,,true,,,v8.Just,,,0,
329817,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetEvent,,true,,,GetEvent,,,0,
329821,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,promise_reject_callback,,true,,,promise_reject_callback,,,0,
329825,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TRACE_COUNTER2,,true,,,TRACE_COUNTER2,,,0,
329834,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetAssignedPromiseAsyncId,,true,,,GetAssignedPromiseAsyncId,,,0,
329840,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,async_id_symbol,,true,,,async_id_symbol,,,0,
329844,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,trigger_async_id_symbol,,true,,,trigger_async_id_symbol,,,0,
329848,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetAssignedPromiseWrapAsyncId,,true,,,GetAssignedPromiseWrapAsyncId,,,0,
329854,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_tick_callback_function,,true,,,set_tick_callback_function,,,0,
329859,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_promise_reject_callback,,true,,,set_promise_reject_callback,,,0,
329864,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(events, kPromiseRejectWithNoHandler)",,true,,,"NODE_DEFINE_CONSTANT(events, kPromiseRejectWithNoHandler)",,,0,
329872,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(events, kPromiseHandlerAddedAfterReject)",,true,,,"NODE_DEFINE_CONSTANT(events, kPromiseHandlerAddedAfterReject)",,,0,
329880,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(events, kPromiseResolveAfterResolved)",,true,,,"NODE_DEFINE_CONSTANT(events, kPromiseResolveAfterResolved)",,,0,
329888,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(events, kPromiseRejectAfterResolved)",,true,,,"NODE_DEFINE_CONSTANT(events, kPromiseRejectAfterResolved)",,,0,
329896,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetCategories,,true,,,GetCategories,,,0,
329900,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StartTracingAgent,,true,,,StartTracingAgent,,,0,
329903,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Enable,,true,,,Enable,,,0,
329909,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Disable,,true,,,Disable,,,0,
329915,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetEnabledCategories,,true,,,GetEnabledCategories,,,0,
329919,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_trace_category_state_function,,true,,,set_trace_category_state_function,,,0,
329924,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VALUE_METHOD_MAP(V),,true,,,VALUE_METHOD_MAP(V),,,0,
329929,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsNumberObject,,true,,,IsNumberObject,,,0,
329933,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsStringObject,,true,,,IsStringObject,,,0,
329937,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsBooleanObject,,true,,,IsBooleanObject,,,0,
329941,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsBigIntObject,,true,,,IsBigIntObject,,,0,
329945,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsSymbolObject,,true,,,IsSymbolObject,,,0,
329949,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_types.cc,node_types.cc:14:39:VALUE_METHOD_MAP:1,,true,14,39,VALUE_METHOD_MAP,,,0,
329952,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_hostname,,true,,,set_hostname,,,0,
329957,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ada.unicode.to_unicode,,true,,,ada.unicode.to_unicode,,,0,
329962,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_INVALID_URL,,true,,,THROW_ERR_INVALID_URL,,,0,
329967,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,get_origin,,true,,,get_origin,,,0,
329971,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,base,,true,,,base,,,0,
329976,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ada.can_parse,,true,,,ada.can_parse,,,0,
329982,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,href,,true,,,href,,,0,
329987,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,get_href,,true,,,get_href,,,0,
329991,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,UpdateComponents,,true,,,UpdateComponents,,,0,
329997,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,get_components,,true,,,get_components,,,0,
330001,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,new_value,,true,,,new_value,,,0,
330006,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_pathname,,true,,,set_pathname,,,0,
330011,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_hash,,true,,,set_hash,,,0,
330016,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_href,,true,,,set_href,,,0,
330021,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_password,,true,,,set_password,,,0,
330026,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_protocol,,true,,,set_protocol,,,0,
330031,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_search,,true,,,set_search,,,0,
330036,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_username,,true,,,set_username,,,0,
330041,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ada.href_from_file,,true,,,ada.href_from_file,,,0,
330046,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<External>,,true,,,As<External>,,,0,
330050,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsProxy,,true,,,IsProxy,,,0,
330054,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<Proxy>,,true,,,As<Proxy>,,,0,
330058,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetTarget,,true,,,GetTarget,,,0,
330062,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetHandler,,true,,,GetHandler,,,0,
330066,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PreviewEntries,,true,,,PreviewEntries,,,0,
330071,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_sleep,,true,,,uv_sleep,,,0,
330075,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HasBuffer,,true,,,HasBuffer,,,0,
330079,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DCHECK_NE,,true,,,DCHECK_NE,,,0,
330084,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsUnicodeSurrogate,,true,,,IsUnicodeSurrogate,,,0,
330088,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsUnicodeSurrogateTrail,,true,,,IsUnicodeSurrogateTrail,,,0,
330092,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsUnicodeTrail,,true,,,IsUnicodeTrail,,,0,
330096,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_util.cc,node_util.cc:438:443:V:1,,true,438,443,V,,,0,
330099,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,V(kPending),,true,,,V(kPending),,,0,
330105,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,V(kFulfilled),,true,,,V(kFulfilled),,,0,
330111,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,V(kRejected),,true,,,V(kRejected),,,0,
330117,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_util.cc,node_util.cc:450:455:V:1,,true,450,455,V,,,0,
330120,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,V(kExiting),,true,,,V(kExiting),,,0,
330126,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,V(kExitCode),,true,,,V(kExitCode),,,0,
330132,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,V(kHasExitCode),,true,,,V(kHasExitCode),,,0,
330138,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_util.cc,node_util.cc:462:467:V:1,,true,462,467,V,,,0,
330141,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,V(ALL_PROPERTIES),,true,,,V(ALL_PROPERTIES),,,0,
330147,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,V(ONLY_WRITABLE),,true,,,V(ONLY_WRITABLE),,,0,
330153,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,V(ONLY_ENUMERABLE),,true,,,V(ONLY_ENUMERABLE),,,0,
330159,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,V(ONLY_CONFIGURABLE),,true,,,V(ONLY_CONFIGURABLE),,,0,
330165,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,V(SKIP_STRINGS),,true,,,V(SKIP_STRINGS),,,0,
330171,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,V(SKIP_SYMBOLS),,true,,,V(SKIP_SYMBOLS),,,0,
330177,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_v8.cc,node_v8.cc:52:66:HEAP_STATISTICS_PROPERTIES:1,,true,52,66,HEAP_STATISTICS_PROPERTIES,,,0,
330180,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.plus,,true,,,<operator>.plus,,,0,
330184,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_v8.cc,node_v8.cc:73:77:HEAP_SPACE_STATISTICS_PROPERTIES:1,,true,73,77,HEAP_SPACE_STATISTICS_PROPERTIES,,,0,
330187,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_v8.cc,node_v8.cc:84:88:HEAP_CODE_STATISTICS_PROPERTIES:1,,true,84,88,HEAP_CODE_STATISTICS_PROPERTIES,,,0,
330190,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ScriptCompiler.CachedDataVersionTag,,true,,,ScriptCompiler.CachedDataVersionTag,,,0,
330194,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_heap_snapshot_near_heap_limit,,true,,,set_heap_snapshot_near_heap_limit,,,0,
330199,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HEAP_STATISTICS_PROPERTIES(V),,true,,,HEAP_STATISTICS_PROPERTIES(V),,,0,
330203,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HEAP_SPACE_STATISTICS_PROPERTIES(V),,true,,,HEAP_SPACE_STATISTICS_PROPERTIES(V),,,0,
330207,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetHeapCodeAndMetadataStatistics,,true,,,GetHeapCodeAndMetadataStatistics,,,0,
330212,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HEAP_CODE_STATISTICS_PROPERTIES(V),,true,,,HEAP_CODE_STATISTICS_PROPERTIES(V),,,0,
330216,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetGCTypeName,,true,,,GetGCTypeName,,,0,
330220,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetHeapStatistics,,true,,,SetHeapStatistics,,,0,
330225,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,out_stream,,true,,,out_stream,,,0,
330229,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,heap_spaces,,true,,,heap_spaces,,,0,
330233,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_embedder_err_code_to_string,,true,,,uvwasi_embedder_err_code_to_string,,,0,
330237,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_init,,true,,,uvwasi_init,,,0,
330242,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WASIException,,true,,,WASIException,,,0,
330248,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_options_init,,true,,,uvwasi_options_init,,,0,
330252,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strdup,,true,,,strdup,,,0,
330256,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,mapped_path,,true,,,mapped_path,,,0,
330261,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,real_path,,true,,,real_path,,,0,
330266,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CFunction.Make,,true,,,CFunction.Make,,,0,
330271,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Local<Signature>,,true,,,Local<Signature>,,,0,
330274,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BaseObject.FromJSObject,,true,,,BaseObject.FromJSObject,,,0,
330279,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EinvalError<R>,,true,,,EinvalError<R>,,,0,
330282,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getStorageIfAligned,,true,,,getStorageIfAligned,,,0,
330287,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,F,,true,,,F,,,0,
330293,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckType<T>,,true,,,CheckType<T>,,,0,
330297,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckTypes<T>,,true,,,CheckTypes<T>,,,0,
330303,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckTypes<Ts...>,,true,,,CheckTypes<Ts...>,,,0,
330309,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckTypes<Args...>,,true,,,CheckTypes<Args...>,,,0,
330313,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ConvertType<Args>,,true,,,ConvertType<Args>,,,0,
330317,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_WASI_NOT_STARTED,,true,,,THROW_ERR_WASI_NOT_STARTED,,,0,
330321,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CallAndSetReturn<FT,F,R,Args...>",,true,,,"CallAndSetReturn<FT,F,R,Args...>",,,0,
330328,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std::make_index_sequence<(Args)>,,true,,,std::make_index_sequence<(Args)>,,,0,
330332,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"WASI.WasiFunction<FT, F, R, Args...>.SetFunction",,true,,,"WASI.WasiFunction<FT, F, R, Args...>.SetFunction",,,0,
330339,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_wasi.cc,node_wasi.cc:21:26:CHECK_BOUNDS_OR_RETURN:3,,true,21,26,CHECK_BOUNDS_OR_RETURN,,,0,
330345,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_serdes_check_bounds,,true,,,uvwasi_serdes_check_bounds,,,0,
330351,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_args_get,,true,,,uvwasi_args_get,,,0,
330357,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_serdes_write_uint32_t,,true,,,uvwasi_serdes_write_uint32_t,,,0,
330363,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_args_sizes_get,,true,,,uvwasi_args_sizes_get,,,0,
330369,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_serdes_write_size_t,,true,,,uvwasi_serdes_write_size_t,,,0,
330375,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_clock_res_get,,true,,,uvwasi_clock_res_get,,,0,
330381,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_serdes_write_timestamp_t,,true,,,uvwasi_serdes_write_timestamp_t,,,0,
330387,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_clock_time_get,,true,,,uvwasi_clock_time_get,,,0,
330394,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,environment,,true,,,environment,,,0,
330398,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_environ_get,,true,,,uvwasi_environ_get,,,0,
330404,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_environ_sizes_get,,true,,,uvwasi_environ_sizes_get,,,0,
330410,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_fd_advise,,true,,,uvwasi_fd_advise,,,0,
330418,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_fd_allocate,,true,,,uvwasi_fd_allocate,,,0,
330425,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_fd_close,,true,,,uvwasi_fd_close,,,0,
330430,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_fd_datasync,,true,,,uvwasi_fd_datasync,,,0,
330435,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_fd_fdstat_get,,true,,,uvwasi_fd_fdstat_get,,,0,
330441,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_serdes_write_fdstat_t,,true,,,uvwasi_serdes_write_fdstat_t,,,0,
330447,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_fd_fdstat_set_flags,,true,,,uvwasi_fd_fdstat_set_flags,,,0,
330453,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_fd_fdstat_set_rights,,true,,,uvwasi_fd_fdstat_set_rights,,,0,
330460,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_fd_filestat_get,,true,,,uvwasi_fd_filestat_get,,,0,
330466,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_serdes_write_filestat_t,,true,,,uvwasi_serdes_write_filestat_t,,,0,
330472,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_fd_filestat_set_size,,true,,,uvwasi_fd_filestat_set_size,,,0,
330478,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_fd_filestat_set_times,,true,,,uvwasi_fd_filestat_set_times,,,0,
330486,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_serdes_readv_iovec_t,,true,,,uvwasi_serdes_readv_iovec_t,,,0,
330494,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_fd_pread,,true,,,uvwasi_fd_pread,,,0,
330503,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_fd_prestat_get,,true,,,uvwasi_fd_prestat_get,,,0,
330509,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_serdes_write_prestat_t,,true,,,uvwasi_serdes_write_prestat_t,,,0,
330515,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_fd_prestat_dir_name,,true,,,uvwasi_fd_prestat_dir_name,,,0,
330522,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_serdes_readv_ciovec_t,,true,,,uvwasi_serdes_readv_ciovec_t,,,0,
330530,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_fd_pwrite,,true,,,uvwasi_fd_pwrite,,,0,
330539,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_fd_read,,true,,,uvwasi_fd_read,,,0,
330547,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_fd_readdir,,true,,,uvwasi_fd_readdir,,,0,
330556,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_fd_renumber,,true,,,uvwasi_fd_renumber,,,0,
330562,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_fd_seek,,true,,,uvwasi_fd_seek,,,0,
330570,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_serdes_write_filesize_t,,true,,,uvwasi_serdes_write_filesize_t,,,0,
330576,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_fd_sync,,true,,,uvwasi_fd_sync,,,0,
330581,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_fd_tell,,true,,,uvwasi_fd_tell,,,0,
330587,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_fd_write,,true,,,uvwasi_fd_write,,,0,
330595,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_path_create_directory,,true,,,uvwasi_path_create_directory,,,0,
330602,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_path_filestat_get,,true,,,uvwasi_path_filestat_get,,,0,
330611,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_path_filestat_set_times,,true,,,uvwasi_path_filestat_set_times,,,0,
330622,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_path_link,,true,,,uvwasi_path_link,,,0,
330633,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_path_open,,true,,,uvwasi_path_open,,,0,
330646,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_path_readlink,,true,,,uvwasi_path_readlink,,,0,
330656,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_path_remove_directory,,true,,,uvwasi_path_remove_directory,,,0,
330663,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_path_rename,,true,,,uvwasi_path_rename,,,0,
330673,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_path_symlink,,true,,,uvwasi_path_symlink,,,0,
330682,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_path_unlink_file,,true,,,uvwasi_path_unlink_file,,,0,
330689,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_serdes_read_subscription_t,,true,,,uvwasi_serdes_read_subscription_t,,,0,
330695,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_poll_oneoff,,true,,,uvwasi_poll_oneoff,,,0,
330703,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_serdes_write_event_t,,true,,,uvwasi_serdes_write_event_t,,,0,
330709,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_proc_exit,,true,,,uvwasi_proc_exit,,,0,
330714,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_proc_raise,,true,,,uvwasi_proc_raise,,,0,
330719,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_random_get,,true,,,uvwasi_random_get,,,0,
330725,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_sched_yield,,true,,,uvwasi_sched_yield,,,0,
330729,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_sock_accept,,true,,,uvwasi_sock_accept,,,0,
330736,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ri_data,,true,,,ri_data,,,0,
330740,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_sock_recv,,true,,,uvwasi_sock_recv,,,0,
330750,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_serdes_write_roflags_t,,true,,,uvwasi_serdes_write_roflags_t,,,0,
330756,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,si_data,,true,,,si_data,,,0,
330760,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_sock_send,,true,,,uvwasi_sock_send,,,0,
330769,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uvwasi_sock_shutdown,,true,,,uvwasi_sock_shutdown,,,0,
330775,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsWasmMemoryObject,,true,,,IsWasmMemoryObject,,,0,
330779,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<WasmMemoryObject>,,true,,,As<WasmMemoryObject>,,,0,
330783,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_wasi.cc,node_wasi.cc:1275:1276:V:2,,true,1275,1276,V,,,0,
330787,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.ArgsGet>",,true,,,"SetFunction<,WASI.ArgsGet>",,,0,
330795,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.ArgsSizesGet>",,true,,,"SetFunction<,WASI.ArgsSizesGet>",,,0,
330803,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.ClockResGet>",,true,,,"SetFunction<,WASI.ClockResGet>",,,0,
330811,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.ClockTimeGet>",,true,,,"SetFunction<,WASI.ClockTimeGet>",,,0,
330819,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.EnvironGet>",,true,,,"SetFunction<,WASI.EnvironGet>",,,0,
330827,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.EnvironSizesGet>",,true,,,"SetFunction<,WASI.EnvironSizesGet>",,,0,
330835,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.FdAdvise>",,true,,,"SetFunction<,WASI.FdAdvise>",,,0,
330843,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.FdAllocate>",,true,,,"SetFunction<,WASI.FdAllocate>",,,0,
330851,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.FdClose>",,true,,,"SetFunction<,WASI.FdClose>",,,0,
330859,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.FdDatasync>",,true,,,"SetFunction<,WASI.FdDatasync>",,,0,
330867,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.FdFdstatGet>",,true,,,"SetFunction<,WASI.FdFdstatGet>",,,0,
330875,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.FdFdstatSetFlags>",,true,,,"SetFunction<,WASI.FdFdstatSetFlags>",,,0,
330883,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.FdFdstatSetRights>",,true,,,"SetFunction<,WASI.FdFdstatSetRights>",,,0,
330891,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.FdFilestatGet>",,true,,,"SetFunction<,WASI.FdFilestatGet>",,,0,
330899,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.FdFilestatSetSize>",,true,,,"SetFunction<,WASI.FdFilestatSetSize>",,,0,
330907,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.FdFilestatSetTimes>",,true,,,"SetFunction<,WASI.FdFilestatSetTimes>",,,0,
330915,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.FdPread>",,true,,,"SetFunction<,WASI.FdPread>",,,0,
330923,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.FdPrestatGet>",,true,,,"SetFunction<,WASI.FdPrestatGet>",,,0,
330931,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.FdPrestatDirName>",,true,,,"SetFunction<,WASI.FdPrestatDirName>",,,0,
330939,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.FdPwrite>",,true,,,"SetFunction<,WASI.FdPwrite>",,,0,
330947,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.FdRead>",,true,,,"SetFunction<,WASI.FdRead>",,,0,
330955,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.FdReaddir>",,true,,,"SetFunction<,WASI.FdReaddir>",,,0,
330963,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.FdRenumber>",,true,,,"SetFunction<,WASI.FdRenumber>",,,0,
330971,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.FdSeek>",,true,,,"SetFunction<,WASI.FdSeek>",,,0,
330979,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.FdSync>",,true,,,"SetFunction<,WASI.FdSync>",,,0,
330987,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.FdTell>",,true,,,"SetFunction<,WASI.FdTell>",,,0,
330995,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.FdWrite>",,true,,,"SetFunction<,WASI.FdWrite>",,,0,
331003,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.PathCreateDirectory>",,true,,,"SetFunction<,WASI.PathCreateDirectory>",,,0,
331011,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.PathFilestatGet>",,true,,,"SetFunction<,WASI.PathFilestatGet>",,,0,
331019,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.PathFilestatSetTimes>",,true,,,"SetFunction<,WASI.PathFilestatSetTimes>",,,0,
331027,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.PathLink>",,true,,,"SetFunction<,WASI.PathLink>",,,0,
331035,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.PathOpen>",,true,,,"SetFunction<,WASI.PathOpen>",,,0,
331043,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.PathReadlink>",,true,,,"SetFunction<,WASI.PathReadlink>",,,0,
331051,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.PathRemoveDirectory>",,true,,,"SetFunction<,WASI.PathRemoveDirectory>",,,0,
331059,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.PathRename>",,true,,,"SetFunction<,WASI.PathRename>",,,0,
331067,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.PathSymlink>",,true,,,"SetFunction<,WASI.PathSymlink>",,,0,
331075,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.PathUnlinkFile>",,true,,,"SetFunction<,WASI.PathUnlinkFile>",,,0,
331083,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.PollOneoff>",,true,,,"SetFunction<,WASI.PollOneoff>",,,0,
331091,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.ProcExit>",,true,,,"SetFunction<,WASI.ProcExit>",,,0,
331099,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.ProcRaise>",,true,,,"SetFunction<,WASI.ProcRaise>",,,0,
331107,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.RandomGet>",,true,,,"SetFunction<,WASI.RandomGet>",,,0,
331115,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.SchedYield>",,true,,,"SetFunction<,WASI.SchedYield>",,,0,
331123,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.SockAccept>",,true,,,"SetFunction<,WASI.SockAccept>",,,0,
331131,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.SockRecv>",,true,,,"SetFunction<,WASI.SockRecv>",,,0,
331139,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.SockSend>",,true,,,"SetFunction<,WASI.SockSend>",,,0,
331147,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SetFunction<,WASI.SockShutdown>",,true,,,"SetFunction<,WASI.SockShutdown>",,,0,
331155,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetInstanceMethod,,true,,,SetInstanceMethod,,,0,
331162,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,wasm_streaming_object_constructor,,true,,,wasm_streaming_object_constructor,,,0,
331166,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_wasm_streaming_object_constructor,,true,,,set_wasm_streaming_object_constructor,,,0,
331171,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,url,,true,,,url,,,0,
331176,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetUrl,,true,,,SetUrl,,,0,
331182,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OnBytesReceived,,true,,,OnBytesReceived,,,0,
331188,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WasmStreaming.Unpack,,true,,,WasmStreaming.Unpack,,,0,
331194,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WasmStreamingObject.Create,,true,,,WasmStreamingObject.Create,,,0,
331200,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,wasm_streaming_compilation_impl,,true,,,wasm_streaming_compilation_impl,,,0,
331204,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_wasm_streaming_compilation_impl,,true,,,set_wasm_streaming_compilation_impl,,,0,
331209,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WasmStreamingObject.RegisterExternalReferences,,true,,,WasmStreamingObject.RegisterExternalReferences,,,0,
331214,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HandleInterrupt,,true,,,HandleInterrupt,,,0,
331218,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SigintWatchdogHelper.GetInstanceActionMutex,,true,,,SigintWatchdogHelper.GetInstanceActionMutex,,,0,
331222,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Unregister,,true,,,Unregister,,,0,
331227,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,v8.StackTrace.CurrentStackTrace,,true,,,v8.StackTrace.CurrentStackTrace,,,0,
331234,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InformWatchdogsAboutSignal,,true,,,InformWatchdogsAboutSignal,,,0,
331237,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,list_lock,,true,,,list_lock,,,0,
331241,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,rbegin,,true,,,rbegin,,,0,
331245,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,rend,,true,,,rend,,,0,
331249,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HandleSigint,,true,,,HandleSigint,,,0,
331253,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetConsoleCtrlHandler,,true,,,SetConsoleCtrlHandler,,,0,
331258,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TraceSigintWatchdog.Init,,true,,,TraceSigintWatchdog.Init,,,0,
331264,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,add_refs,,true,,,add_refs,,,0,
331269,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,trigger_id_scope,,true,,,trigger_id_scope,,,0,
331273,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,heap.CreateHeapSnapshotStream,,true,,,heap.CreateHeapSnapshotStream,,,0,
331279,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,message_port_string,,true,,,message_port_string,,,0,
331283,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,thread_id_string,,true,,,thread_id_string,,,0,
331287,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_granted,,true,,,is_granted,,,0,
331292,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std::vector<std::string>,,true,,,std::vector<std::string>,,,0,
331296,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_stack_limit,,true,,,set_stack_limit,,,0,
331301,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_max_young_generation_size_in_bytes,,true,,,set_max_young_generation_size_in_bytes,,,0,
331306,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_max_old_generation_size_in_bytes,,true,,,set_max_old_generation_size_in_bytes,,,0,
331311,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_code_range_size_in_bytes,,true,,,set_code_range_size_in_bytes,,,0,
331316,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,code_range_size_in_bytes,,true,,,code_range_size_in_bytes,,,0,
331320,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,UpdateResourceConstraints,,true,,,UpdateResourceConstraints,,,0,
331325,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddNearHeapLimitCallback,,true,,,AddNearHeapLimitCallback,,,0,
331331,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetStackLimit,,true,,,SetStackLimit,,,0,
331336,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_options,,true,,,set_options,,,0,
331341,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_worker_context,,true,,,set_worker_context,,,0,
331346,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_in_heapsnapshot_heap_limit_callback,,true,,,is_in_heapsnapshot_heap_limit_callback,,,0,
331350,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,loop_is_usable,,true,,,loop_is_usable,,,0,
331354,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,outer_seal,,true,,,outer_seal,,,0,
331358,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_stopped,,true,,,is_stopped,,,0,
331361,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetProcessExitHandler,,true,,,SetProcessExitHandler,,,0,
331366,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CreateEnvMessagePort,,true,,,CreateEnvMessagePort,,,0,
331370,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_message_port,,true,,,set_message_port,,,0,
331375,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,onexit_string,,true,,,onexit_string,,,0,
331379,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_MISSING_PLATFORM_FOR_WORKER,,true,,,THROW_ERR_MISSING_PLATFORM_FOR_WORKER,,,0,
331383,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Clone,,true,,,Clone,,,0,
331387,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AssignFromObject,,true,,,AssignFromObject,,,0,
331393,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node_options,,true,,,node_options,,,0,
331397,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,invalid_args,,true,,,invalid_args,,,0,
331401,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,arg_utf8_value,,true,,,arg_utf8_value,,,0,
331406,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,arg_string,,true,,,arg_string,,,0,
331411,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,hide_console_windows,,true,,,hide_console_windows,,,0,
331415,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_thread_create_ex,,true,,,uv_thread_create_ex,,,0,
331422,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,add_sub_worker_context,,true,,,add_sub_worker_context,,,0,
331427,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,THROW_ERR_WORKER_INIT_FAILED,,true,,,THROW_ERR_WORKER_INIT_FAILED,,,0,
331432,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetResourceLimits,,true,,,GetResourceLimits,,,0,
331437,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Float64Array.New,,true,,,Float64Array.New,,,0,
331444,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,heap.GetHeapSnapshotOptions,,true,,,heap.GetHeapSnapshotOptions,,,0,
331449,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,worker_heap_snapshot_taker_template,,true,,,worker_heap_snapshot_taker_template,,,0,
331453,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,message_port,,true,,,message_port,,,0,
331457,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_worker_heap_snapshot_taker_template,,true,,,set_worker_heap_snapshot_taker_template,,,0,
331462,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, kMaxYoungGenerationSizeMb)",,true,,,"NODE_DEFINE_CONSTANT(target, kMaxYoungGenerationSizeMb)",,,0,
331470,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, kMaxOldGenerationSizeMb)",,true,,,"NODE_DEFINE_CONSTANT(target, kMaxOldGenerationSizeMb)",,,0,
331478,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, kCodeRangeSizeMb)",,true,,,"NODE_DEFINE_CONSTANT(target, kCodeRangeSizeMb)",,,0,
331486,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, kStackSizeMb)",,true,,,"NODE_DEFINE_CONSTANT(target, kStackSizeMb)",,,0,
331494,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, kTotalResourceLimitCount)",,true,,,"NODE_DEFINE_CONSTANT(target, kTotalResourceLimitCount)",,,0,
331502,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_zlib.cc,node_zlib.cc:79:88:ZLIB_ERROR_CODES:1,,true,79,88,ZLIB_ERROR_CODES,,,0,
331505,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,alloc_scope,,true,,,alloc_scope,,,0,
331509,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Write<async>,,true,,,Write<async>,,,0,
331518,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetBuffers,,true,,,SetBuffers,,,0,
331526,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetFlush,,true,,,SetFlush,,,0,
331531,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,14 env 0.PrintSyncTrace,,true,,,PrintSyncTrace,,,0,
331535,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AsyncWrap.env,,true,,,AsyncWrap.env,,,0,
331539,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DoThreadPoolWork,,true,,,DoThreadPoolWork,,,0,
331543,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckError,,true,,,CheckError,,,0,
331546,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,UpdateWriteResult,,true,,,UpdateWriteResult,,,0,
331549,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetAfterWriteOffsets,,true,,,GetAfterWriteOffsets,,,0,
331555,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetErrorInfo,,true,,,GetErrorInfo,,,0,
331559,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsError,,true,,,IsError,,,0,
331563,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EmitError,,true,,,EmitError,,,0,
331568,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,14 object 0.GetInternalField,,true,,,GetInternalField,,,0,
331573,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,8 1 330 3 wrap 0 context 0 0.ResetStream,,true,,,ResetStream,,,0,
331577,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,14 object 0.SetInternalField,,true,,,SetInternalField,,,0,
331583,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MultiplyWithOverflowCheck,,true,,,MultiplyWithOverflowCheck,,,0,
331588,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node.anonymous_namespace_87.CompressionStream.AllocForBrotli,,true,,,AllocForBrotli,,,0,
331593,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,UncheckedMalloc,,true,,,UncheckedMalloc,,,0,
331597,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,330 3 ctx 0 unreported_allocations_ 0.fetch_add,,true,,,fetch_add,,,0,
331603,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,330 3 ctx 0 unreported_allocations_ 0.fetch_sub,,true,,,fetch_sub,,,0,
331609,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,8 1 330 14 env 0 isolate 0 0.AdjustAmountOfExternalAllocatedMemory,,true,,,AdjustAmountOfExternalAllocatedMemory,,,0,
331614,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetMode,,true,,,SetMode,,,0,
331619,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ZlibStream.context,,true,,,context,,,0,
331622,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,As<Uint32Array>,,true,,,As<Uint32Array>,,,0,
331626,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InitStream,,true,,,InitStream,,,0,
331632,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetAllocationFunctions,,true,,,SetAllocationFunctions,,,0,
331639,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetParams,,true,,,SetParams,,,0,
331645,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CompressionStream<CompressionContext>.context,,true,,,CompressionStream<CompressionContext>.context,,,0,
331649,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CompressionError.IsError,,true,,,IsError,,,0,
331653,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,deflateEnd,,true,,,deflateEnd,,,0,
331657,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ZlibContext.InitZlib,,true,,,InitZlib,,,0,
331660,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,deflate,,true,,,deflate,,,0,
331665,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,inflateSetDictionary,,true,,,inflateSetDictionary,,,0,
331671,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ZlibContext.ResetStream,,true,,,ResetStream,,,0,
331674,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CompressionError,,true,,,CompressionError,,,0,
331678,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ZlibStrerror,,true,,,ZlibStrerror,,,0,
331682,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ErrorForMessage,,true,,,ErrorForMessage,,,0,
331686,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ZlibContext.ErrorForMessage,,true,,,ErrorForMessage,,,0,
331690,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,deflateReset,,true,,,deflateReset,,,0,
331694,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,inflateReset,,true,,,inflateReset,,,0,
331698,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ZlibContext.SetDictionary,,true,,,SetDictionary,,,0,
331701,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_zlib.cc,node_zlib.cc:75:75:Z_MIN_WINDOWBITS:0,,true,75,75,Z_MIN_WINDOWBITS,,,0,
331704,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_zlib.cc,node_zlib.cc:76:76:Z_MAX_WINDOWBITS:0,,true,76,76,Z_MAX_WINDOWBITS,,,0,
331707,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_zlib.cc,node_zlib.cc:72:72:Z_MIN_LEVEL:0,,true,72,72,Z_MIN_LEVEL,,,0,
331710,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_zlib.cc,node_zlib.cc:73:73:Z_MAX_LEVEL:0,,true,73,73,Z_MAX_LEVEL,,,0,
331713,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_zlib.cc,node_zlib.cc:69:69:Z_MIN_MEMLEVEL:0,,true,69,69,Z_MIN_MEMLEVEL,,,0,
331716,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,node_zlib.cc,node_zlib.cc:70:70:Z_MAX_MEMLEVEL:0,,true,70,70,Z_MAX_MEMLEVEL,,,0,
331719,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,deflateInit2,,true,,,deflateInit2,,,0,
331728,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,inflateInit2,,true,,,inflateInit2,,,0,
331733,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,deflateSetDictionary,,true,,,deflateSetDictionary,,,0,
331739,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,deflateParams,,true,,,deflateParams,,,0,
331745,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BrotliEncoderCompressStream,,true,,,BrotliEncoderCompressStream,,,0,
331755,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BrotliEncoderCreateInstance,,true,,,BrotliEncoderCreateInstance,,,0,
331761,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BrotliEncoderContext.Init,,true,,,Init,,,0,
331767,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BrotliEncoderSetParameter,,true,,,BrotliEncoderSetParameter,,,0,
331773,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BrotliDecoderDecompressStream,,true,,,BrotliDecoderDecompressStream,,,0,
331782,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BrotliDecoderGetErrorCode,,true,,,BrotliDecoderGetErrorCode,,,0,
331786,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BrotliDecoderErrorString,,true,,,BrotliDecoderErrorString,,,0,
331790,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BrotliDecoderCreateInstance,,true,,,BrotliDecoderCreateInstance,,,0,
331796,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BrotliDecoderContext.Init,,true,,,Init,,,0,
331802,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BrotliDecoderSetParameter,,true,,,BrotliDecoderSetParameter,,,0,
331808,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MakeClass<ZlibStream>.Make,,true,,,MakeClass<ZlibStream>.Make,,,0,
331813,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MakeClass<BrotliEncoderStream>.Make,,true,,,MakeClass<BrotliEncoderStream>.Make,,,0,
331818,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MakeClass<BrotliDecoderStream>.Make,,true,,,MakeClass<BrotliDecoderStream>.Make,,,0,
331823,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, Z_NO_FLUSH)",,true,,,"NODE_DEFINE_CONSTANT(target, Z_NO_FLUSH)",,,0,
331831,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, Z_PARTIAL_FLUSH)",,true,,,"NODE_DEFINE_CONSTANT(target, Z_PARTIAL_FLUSH)",,,0,
331839,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, Z_SYNC_FLUSH)",,true,,,"NODE_DEFINE_CONSTANT(target, Z_SYNC_FLUSH)",,,0,
331847,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, Z_FULL_FLUSH)",,true,,,"NODE_DEFINE_CONSTANT(target, Z_FULL_FLUSH)",,,0,
331855,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, Z_FINISH)",,true,,,"NODE_DEFINE_CONSTANT(target, Z_FINISH)",,,0,
331863,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, Z_BLOCK)",,true,,,"NODE_DEFINE_CONSTANT(target, Z_BLOCK)",,,0,
331871,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, Z_OK)",,true,,,"NODE_DEFINE_CONSTANT(target, Z_OK)",,,0,
331879,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, Z_STREAM_END)",,true,,,"NODE_DEFINE_CONSTANT(target, Z_STREAM_END)",,,0,
331887,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, Z_NEED_DICT)",,true,,,"NODE_DEFINE_CONSTANT(target, Z_NEED_DICT)",,,0,
331895,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, Z_ERRNO)",,true,,,"NODE_DEFINE_CONSTANT(target, Z_ERRNO)",,,0,
331903,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, Z_STREAM_ERROR)",,true,,,"NODE_DEFINE_CONSTANT(target, Z_STREAM_ERROR)",,,0,
331911,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, Z_DATA_ERROR)",,true,,,"NODE_DEFINE_CONSTANT(target, Z_DATA_ERROR)",,,0,
331919,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, Z_MEM_ERROR)",,true,,,"NODE_DEFINE_CONSTANT(target, Z_MEM_ERROR)",,,0,
331927,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, Z_BUF_ERROR)",,true,,,"NODE_DEFINE_CONSTANT(target, Z_BUF_ERROR)",,,0,
331935,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, Z_VERSION_ERROR)",,true,,,"NODE_DEFINE_CONSTANT(target, Z_VERSION_ERROR)",,,0,
331943,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, Z_NO_COMPRESSION)",,true,,,"NODE_DEFINE_CONSTANT(target, Z_NO_COMPRESSION)",,,0,
331951,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, Z_BEST_SPEED)",,true,,,"NODE_DEFINE_CONSTANT(target, Z_BEST_SPEED)",,,0,
331959,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, Z_BEST_COMPRESSION)",,true,,,"NODE_DEFINE_CONSTANT(target, Z_BEST_COMPRESSION)",,,0,
331967,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, Z_DEFAULT_COMPRESSION)",,true,,,"NODE_DEFINE_CONSTANT(target, Z_DEFAULT_COMPRESSION)",,,0,
331975,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, Z_FILTERED)",,true,,,"NODE_DEFINE_CONSTANT(target, Z_FILTERED)",,,0,
331983,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, Z_HUFFMAN_ONLY)",,true,,,"NODE_DEFINE_CONSTANT(target, Z_HUFFMAN_ONLY)",,,0,
331991,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, Z_RLE)",,true,,,"NODE_DEFINE_CONSTANT(target, Z_RLE)",,,0,
331999,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, Z_FIXED)",,true,,,"NODE_DEFINE_CONSTANT(target, Z_FIXED)",,,0,
332007,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, Z_DEFAULT_STRATEGY)",,true,,,"NODE_DEFINE_CONSTANT(target, Z_DEFAULT_STRATEGY)",,,0,
332015,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, ZLIB_VERNUM)",,true,,,"NODE_DEFINE_CONSTANT(target, ZLIB_VERNUM)",,,0,
332023,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, DEFLATE)",,true,,,"NODE_DEFINE_CONSTANT(target, DEFLATE)",,,0,
332031,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, INFLATE)",,true,,,"NODE_DEFINE_CONSTANT(target, INFLATE)",,,0,
332039,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, GZIP)",,true,,,"NODE_DEFINE_CONSTANT(target, GZIP)",,,0,
332047,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, GUNZIP)",,true,,,"NODE_DEFINE_CONSTANT(target, GUNZIP)",,,0,
332055,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, DEFLATERAW)",,true,,,"NODE_DEFINE_CONSTANT(target, DEFLATERAW)",,,0,
332063,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, INFLATERAW)",,true,,,"NODE_DEFINE_CONSTANT(target, INFLATERAW)",,,0,
332071,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, UNZIP)",,true,,,"NODE_DEFINE_CONSTANT(target, UNZIP)",,,0,
332079,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODE)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODE)",,,0,
332087,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_ENCODE)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_ENCODE)",,,0,
332095,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, Z_MIN_WINDOWBITS)",,true,,,"NODE_DEFINE_CONSTANT(target, Z_MIN_WINDOWBITS)",,,0,
332103,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, Z_MAX_WINDOWBITS)",,true,,,"NODE_DEFINE_CONSTANT(target, Z_MAX_WINDOWBITS)",,,0,
332111,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, Z_DEFAULT_WINDOWBITS)",,true,,,"NODE_DEFINE_CONSTANT(target, Z_DEFAULT_WINDOWBITS)",,,0,
332119,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, Z_MIN_CHUNK)",,true,,,"NODE_DEFINE_CONSTANT(target, Z_MIN_CHUNK)",,,0,
332127,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, Z_MAX_CHUNK)",,true,,,"NODE_DEFINE_CONSTANT(target, Z_MAX_CHUNK)",,,0,
332135,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, Z_DEFAULT_CHUNK)",,true,,,"NODE_DEFINE_CONSTANT(target, Z_DEFAULT_CHUNK)",,,0,
332143,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, Z_MIN_MEMLEVEL)",,true,,,"NODE_DEFINE_CONSTANT(target, Z_MIN_MEMLEVEL)",,,0,
332151,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, Z_MAX_MEMLEVEL)",,true,,,"NODE_DEFINE_CONSTANT(target, Z_MAX_MEMLEVEL)",,,0,
332159,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, Z_DEFAULT_MEMLEVEL)",,true,,,"NODE_DEFINE_CONSTANT(target, Z_DEFAULT_MEMLEVEL)",,,0,
332167,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, Z_MIN_LEVEL)",,true,,,"NODE_DEFINE_CONSTANT(target, Z_MIN_LEVEL)",,,0,
332175,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, Z_MAX_LEVEL)",,true,,,"NODE_DEFINE_CONSTANT(target, Z_MAX_LEVEL)",,,0,
332183,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, Z_DEFAULT_LEVEL)",,true,,,"NODE_DEFINE_CONSTANT(target, Z_DEFAULT_LEVEL)",,,0,
332191,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_OPERATION_PROCESS)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_OPERATION_PROCESS)",,,0,
332199,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_OPERATION_FLUSH)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_OPERATION_FLUSH)",,,0,
332207,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_OPERATION_FINISH)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_OPERATION_FINISH)",,,0,
332215,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_OPERATION_EMIT_METADATA)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_OPERATION_EMIT_METADATA)",,,0,
332223,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_MODE)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_MODE)",,,0,
332231,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_MODE_GENERIC)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_MODE_GENERIC)",,,0,
332239,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_MODE_TEXT)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_MODE_TEXT)",,,0,
332247,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_MODE_FONT)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_MODE_FONT)",,,0,
332255,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_DEFAULT_MODE)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_DEFAULT_MODE)",,,0,
332263,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_QUALITY)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_QUALITY)",,,0,
332271,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_MIN_QUALITY)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_MIN_QUALITY)",,,0,
332279,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_MAX_QUALITY)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_MAX_QUALITY)",,,0,
332287,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_DEFAULT_QUALITY)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_DEFAULT_QUALITY)",,,0,
332295,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_LGWIN)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_LGWIN)",,,0,
332303,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_MIN_WINDOW_BITS)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_MIN_WINDOW_BITS)",,,0,
332311,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_MAX_WINDOW_BITS)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_MAX_WINDOW_BITS)",,,0,
332319,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_LARGE_MAX_WINDOW_BITS)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_LARGE_MAX_WINDOW_BITS)",,,0,
332327,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_DEFAULT_WINDOW)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_DEFAULT_WINDOW)",,,0,
332335,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_LGBLOCK)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_LGBLOCK)",,,0,
332343,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_MIN_INPUT_BLOCK_BITS)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_MIN_INPUT_BLOCK_BITS)",,,0,
332351,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_MAX_INPUT_BLOCK_BITS)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_MAX_INPUT_BLOCK_BITS)",,,0,
332359,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING)",,,0,
332367,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_SIZE_HINT)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_SIZE_HINT)",,,0,
332375,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_LARGE_WINDOW)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_LARGE_WINDOW)",,,0,
332383,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_NPOSTFIX)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_NPOSTFIX)",,,0,
332391,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_NDIRECT)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_NDIRECT)",,,0,
332399,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_RESULT_ERROR)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_RESULT_ERROR)",,,0,
332407,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_RESULT_SUCCESS)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_RESULT_SUCCESS)",,,0,
332415,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT)",,,0,
332423,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT)",,,0,
332431,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target,
      BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION)",,true,,,"NODE_DEFINE_CONSTANT(target,
      BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION)",,,0,
332439,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_PARAM_LARGE_WINDOW)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_PARAM_LARGE_WINDOW)",,,0,
332447,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_NO_ERROR)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_NO_ERROR)",,,0,
332455,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_SUCCESS)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_SUCCESS)",,,0,
332463,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_NEEDS_MORE_INPUT)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_NEEDS_MORE_INPUT)",,,0,
332471,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_NEEDS_MORE_OUTPUT)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_NEEDS_MORE_OUTPUT)",,,0,
332479,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE)",,,0,
332487,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_RESERVED)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_RESERVED)",,,0,
332495,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target,
      BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE)",,true,,,"NODE_DEFINE_CONSTANT(target,
      BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE)",,,0,
332503,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target,
      BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET)",,true,,,"NODE_DEFINE_CONSTANT(target,
      BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET)",,,0,
332511,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME)",,,0,
332519,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_CL_SPACE)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_CL_SPACE)",,,0,
332527,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE)",,,0,
332535,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT)",,,0,
332543,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1)",,,0,
332551,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2)",,,0,
332559,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_TRANSFORM)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_TRANSFORM)",,,0,
332567,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_DICTIONARY)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_DICTIONARY)",,,0,
332575,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS)",,,0,
332583,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_PADDING_1)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_PADDING_1)",,,0,
332591,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_PADDING_2)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_PADDING_2)",,,0,
332599,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_DISTANCE)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_DISTANCE)",,,0,
332607,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET)",,,0,
332615,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_INVALID_ARGUMENTS)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_INVALID_ARGUMENTS)",,,0,
332623,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES)",,,0,
332631,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS)",,,0,
332639,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP)",,,0,
332647,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1)",,,0,
332655,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2)",,,0,
332663,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES)",,,0,
332671,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_UNREACHABLE)",,true,,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_UNREACHABLE)",,,0,
332679,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FreeRecursivelyNode,,true,,,FreeRecursivelyNode,,,0,
332683,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Lookup,,true,,,Lookup,,,0,
332689,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,whitespace,,true,,,whitespace,,,0,
332694,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PrintTree,,true,,,PrintTree,,,0,
332699,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GrantAccess,,true,,,GrantAccess,,,0,
332704,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WildcardIfDir,,true,,,WildcardIfDir,,,0,
332708,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_tree_granted,,true,,,is_tree_granted,,,0,
332713,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsEndNode,,true,,,IsEndNode,,,0,
332717,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NextNode,,true,,,NextNode,,,0,
332723,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CreateChild,,true,,,CreateChild,,,0,
332728,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CreateWildcardChild,,true,,,CreateWildcardChild,,,0,
332732,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,utf8_deny_scope,,true,,,utf8_deny_scope,,,0,
332737,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Permission.StringToPermission,,true,,,Permission.StringToPermission,,,0,
332742,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,utf8_arg,,true,,,utf8_arg,,,0,
332747,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.make_shared<FSPermission>,,true,,,std.make_shared<FSPermission>,,,0,
332751,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.make_shared<ChildProcessPermission>,,true,,,std.make_shared<ChildProcessPermission>,,,0,
332755,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.make_shared<WorkerPermission>,,true,,,std.make_shared<WorkerPermission>,,,0,
332759,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.make_shared<InspectorPermission>,,true,,,std.make_shared<InspectorPermission>,,,0,
332763,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ERR_ACCESS_DENIED,,true,,,ERR_ACCESS_DENIED,,,0,
332767,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,permission_string,,true,,,permission_string,,,0,
332771,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PermissionToString,,true,,,PermissionToString,,,0,
332775,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,resource_string,,true,,,resource_string,,,0,
332779,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pipe_constructor_template,,true,,,pipe_constructor_template,,,0,
332783,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LibuvStreamWrap.GetConstructorTemplate,,true,,,LibuvStreamWrap.GetConstructorTemplate,,,0,
332788,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_pipe_constructor_template,,true,,,set_pipe_constructor_template,,,0,
332793,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(constants, SOCKET)",,true,,,"NODE_DEFINE_CONSTANT(constants, SOCKET)",,,0,
332801,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(constants, SERVER)",,true,,,"NODE_DEFINE_CONSTANT(constants, SERVER)",,,0,
332809,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(constants, IPC)",,true,,,"NODE_DEFINE_CONSTANT(constants, IPC)",,,0,
332817,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(constants, UV_READABLE)",,true,,,"NODE_DEFINE_CONSTANT(constants, UV_READABLE)",,,0,
332825,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(constants, UV_WRITABLE)",,true,,,"NODE_DEFINE_CONSTANT(constants, UV_WRITABLE)",,,0,
332833,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_pipe_init,,true,,,uv_pipe_init,,,0,
332839,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_pipe_bind,,true,,,uv_pipe_bind,,,0,
332844,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_pipe_chmod,,true,,,uv_pipe_chmod,,,0,
332849,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_pipe_open,,true,,,uv_pipe_open,,,0,
332854,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_fd,,true,,,set_fd,,,0,
332858,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LibuvStreamWrap.From,,true,,,LibuvStreamWrap.From,,,0,
332864,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,stdio_string,,true,,,stdio_string,,,0,
332868,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ignore_string,,true,,,ignore_string,,,0,
332872,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pipe_string,,true,,,pipe_string,,,0,
332876,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StreamForWrap,,true,,,StreamForWrap,,,0,
332881,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,overlapped_string,,true,,,overlapped_string,,,0,
332885,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,wrap_string,,true,,,wrap_string,,,0,
332889,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fd_string,,true,,,fd_string,,,0,
332893,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,file_string,,true,,,file_string,,,0,
332897,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,file,,true,,,file,,,0,
332902,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,args_string,,true,,,args_string,,,0,
332906,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,arg,,true,,,arg,,,0,
332911,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,cwd_string,,true,,,cwd_string,,,0,
332915,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,cwd,,true,,,cwd,,,0,
332920,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,env_pairs_string,,true,,,env_pairs_string,,,0,
332924,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pair,,true,,,pair,,,0,
332929,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ParseStdioOptions,,true,,,ParseStdioOptions,,,0,
332933,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,windows_hide_string,,true,,,windows_hide_string,,,0,
332937,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,windows_verbatim_arguments_string,,true,,,windows_verbatim_arguments_string,,,0,
332941,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,detached_string,,true,,,detached_string,,,0,
332945,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_spawn,,true,,,uv_spawn,,,0,
332951,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pid_string,,true,,,pid_string,,,0,
332955,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_process_kill,,true,,,uv_process_kill,,,0,
332960,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,utf8,,true,,,utf8,,,0,
332965,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,onsignal_string,,true,,,onsignal_string,,,0,
332969,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_signal_init,,true,,,uv_signal_init,,,0,
332974,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DecreaseSignalHandlerCount,,true,,,DecreaseSignalHandlerCount,,,0,
332978,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_signal_start,,true,,,uv_signal_start,,,0,
332984,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_signal_stop,,true,,,uv_signal_stop,,,0,
332988,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,used,,true,,,used,,,0,
332992,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,available,,true,,,available,,,0,
332996,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,next,,true,,,next,,,0,
333000,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_pipe,,true,,,uv_pipe,,,0,
333003,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,readable,,true,,,readable,,,0,
333006,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_stream,,true,,,uv_stream,,,0,
333010,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_shutdown,,true,,,uv_shutdown,,,0,
333016,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_handle,,true,,,uv_handle,,,0,
333019,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OutputLength,,true,,,OutputLength,,,0,
333022,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CopyOutput,,true,,,CopyOutput,,,0,
333026,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Copy,,true,,,Copy,,,0,
333031,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_next,,true,,,set_next,,,0,
333036,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetError,,true,,,SetError,,,0,
333040,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IncrementBufferSizeAndCheckOverflow,,true,,,IncrementBufferSizeAndCheckOverflow,,,0,
333045,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetPipeError,,true,,,SetPipeError,,,0,
333049,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OnWriteDone,,true,,,OnWriteDone,,,0,
333054,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OnShutdownDone,,true,,,OnShutdownDone,,,0,
333059,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TryInitializeAndRunLoop,,true,,,TryInitializeAndRunLoop,,,0,
333063,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CloseHandlesAndDeleteLoop,,true,,,CloseHandlesAndDeleteLoop,,,0,
333066,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BuildResultObject,,true,,,BuildResultObject,,,0,
333069,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ParseOptions,,true,,,ParseOptions,,,0,
333073,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CloseStdioPipes,,true,,,CloseStdioPipes,,,0,
333076,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CloseKillTimer,,true,,,CloseKillTimer,,,0,
333079,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_is_closing,,true,,,uv_is_closing,,,0,
333083,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Kill,,true,,,Kill,,,0,
333086,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetError,,true,,,GetError,,,0,
333089,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,status_string,,true,,,status_string,,,0,
333093,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,signal_string,,true,,,signal_string,,,0,
333097,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,output_string,,true,,,output_string,,,0,
333101,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BuildOutputArray,,true,,,BuildOutputArray,,,0,
333104,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,js_output,,true,,,js_output,,,0,
333108,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetOutputAsBuffer,,true,,,GetOutputAsBuffer,,,0,
333113,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CopyJsString,,true,,,CopyJsString,,,0,
333118,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CopyJsStringArray,,true,,,CopyJsStringArray,,,0,
333123,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,timeout_string,,true,,,timeout_string,,,0,
333127,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,max_buffer_string,,true,,,max_buffer_string,,,0,
333131,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,kill_signal_string,,true,,,kill_signal_string,,,0,
333135,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ParseStdioOption,,true,,,ParseStdioOption,,,0,
333140,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddStdioIgnore,,true,,,AddStdioIgnore,,,0,
333144,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,readable_string,,true,,,readable_string,,,0,
333148,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,writable_string,,true,,,writable_string,,,0,
333152,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,input_string,,true,,,input_string,,,0,
333156,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddStdioPipe,,true,,,AddStdioPipe,,,0,
333163,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,inherit_string,,true,,,inherit_string,,,0,
333167,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddStdioInheritFD,,true,,,AddStdioInheritFD,,,0,
333172,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,h,,true,,,h,,,0,
333176,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_flags,,true,,,uv_flags,,,0,
333180,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RoundUp,,true,,,RoundUp,,,0,
333185,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OnExit,,true,,,OnExit,,,0,
333191,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OnKillTimerTimeout,,true,,,OnKillTimerTimeout,,,0,
333195,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,stream_env,,true,,,stream_env,,,0,
333199,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,shutdown_wrap_template,,true,,,shutdown_wrap_template,,,0,
333203,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StreamReq.ResetObject,,true,,,StreamReq.ResetObject,,,0,
333208,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Error,,true,,,Error,,,0,
333212,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DoTryWrite,,true,,,DoTryWrite,,,0,
333217,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StreamWriteResult,,true,,,StreamWriteResult,,,0,
333221,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,write_wrap_template,,true,,,write_wrap_template,,,0,
333225,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CreateWriteWrap,,true,,,CreateWriteWrap,,,0,
333229,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,req_wrap_ptr,,true,,,req_wrap_ptr,,,0,
333233,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DoWrite,,true,,,DoWrite,,,0,
333240,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,stream_base_state,,true,,,stream_base_state,,,0,
333244,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,bufs,,true,,,bufs,,,0,
333248,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetWriteResult,,true,,,SetWriteResult,,,0,
333252,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetBackingStore,,true,,,SetBackingStore,,,0,
333257,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DCHECK_GE,,true,,,DCHECK_GE,,,0,
333262,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddMethods,,true,,,AddMethods,,,0,
333267,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddMethod,,true,,,AddMethod,,,0,
333276,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,external_stream_string,,true,,,external_stream_string,,,0,
333280,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,bytes_read_string,,true,,,bytes_read_string,,,0,
333284,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,bytes_written_string,,true,,,bytes_written_string,,,0,
333288,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,wrap->*Method,,true,,,wrap->*Method,,,0,
333293,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Local<ArrayBuffer>,,true,,,Local<ArrayBuffer>,,,0,
333296,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OnStreamAfterReqFinished,,true,,,OnStreamAfterReqFinished,,,0,
333301,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EmitAfterShutdown,,true,,,EmitAfterShutdown,,,0,
333307,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EmitAfterWrite,,true,,,EmitAfterWrite,,,0,
333313,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OnStreamAfterShutdown,,true,,,OnStreamAfterShutdown,,,0,
333319,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OnStreamDestroy,,true,,,OnStreamDestroy,,,0,
333323,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OnDone,,true,,,OnDone,,,0,
333327,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,onunpipe_string,,true,,,onunpipe_string,,,0,
333331,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,source_string,,true,,,source_string,,,0,
333335,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sink_string,,true,,,sink_string,,,0,
333339,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pipe_target_string,,true,,,pipe_target_string,,,0,
333343,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pipe_source_string,,true,,,pipe_source_string,,,0,
333347,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HasWantsWrite,,true,,,HasWantsWrite,,,0,
333351,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Unpipe,,true,,,Unpipe,,,0,
333355,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sink,,true,,,sink,,,0,
333359,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProcessData,,true,,,ProcessData,,,0,
333365,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OnStreamWantsWrite,,true,,,OnStreamWantsWrite,,,0,
333370,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,stream_pipe,,true,,,stream_pipe,,,0,
333374,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Nothing<StreamPipe*>,,true,,,Nothing<StreamPipe*>,,,0,
333377,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StreamPipe.New,,true,,,StreamPipe.New,,,0,
333384,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OnUvAlloc,,true,,,OnUvAlloc,,,0,
333390,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OnUvRead,,true,,,OnUvRead,,,0,
333396,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_shutdown_wrap_template,,true,,,set_shutdown_wrap_template,,,0,
333401,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_write_wrap_template,,true,,,set_write_wrap_template,,,0,
333406,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, kReadBytesOrError)",,true,,,"NODE_DEFINE_CONSTANT(target, kReadBytesOrError)",,,0,
333414,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, kArrayBufferOffset)",,true,,,"NODE_DEFINE_CONSTANT(target, kArrayBufferOffset)",,,0,
333422,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, kBytesWritten)",,true,,,"NODE_DEFINE_CONSTANT(target, kBytesWritten)",,,0,
333430,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(target, kLastWriteWasAsync)",,true,,,"NODE_DEFINE_CONSTANT(target, kLastWriteWasAsync)",,,0,
333438,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,libuv_stream_wrap_ctor_template,,true,,,libuv_stream_wrap_ctor_template,,,0,
333442,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_libuv_stream_wrap_ctor_template,,true,,,set_libuv_stream_wrap_ctor_template,,,0,
333447,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HandleWrap.IsAlive,,true,,,HandleWrap.IsAlive,,,0,
333452,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_named_pipe_ipc,,true,,,is_named_pipe_ipc,,,0,
333455,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_read_stop,,true,,,uv_read_stop,,,0,
333459,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_pipe_pending_count,,true,,,uv_pipe_pending_count,,,0,
333463,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_pipe_pending_type,,true,,,uv_pipe_pending_type,,,0,
333467,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pending_handle_string,,true,,,pending_handle_string,,,0,
333471,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_stream_set_blocking,,true,,,uv_stream_set_blocking,,,0,
333476,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LibuvShutdownWrap.from_req,,true,,,LibuvShutdownWrap.from_req,,,0,
333481,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_try_write,,true,,,uv_try_write,,,0,
333487,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LibuvWriteWrap.from_req,,true,,,LibuvWriteWrap.from_req,,,0,
333492,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,byte_length,,true,,,byte_length,,,0,
333496,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,string_bytes.cc,string_bytes.cc:39:39:EXTERN_APEX:0,,true,39,39,EXTERN_APEX,,,0,
333499,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NewSimpleFromCopy,,true,,,NewSimpleFromCopy,,,0,
333506,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node.ERR_MEMORY_ALLOCATION_FAILED,,true,,,node.ERR_MEMORY_ALLOCATION_FAILED,,,0,
333511,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ExternString<ResourceType, TypeName>.New",,true,,,"ExternString<ResourceType, TypeName>.New",,,0,
333519,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NewExternal,,true,,,NewExternal,,,0,
333524,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node.ERR_STRING_TOO_LONG,,true,,,node.ERR_STRING_TOO_LONG,,,0,
333529,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,String.NewExternalOneByte,,true,,,String.NewExternalOneByte,,,0,
333535,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,String.NewExternalTwoByte,,true,,,String.NewExternalTwoByte,,,0,
333541,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,unhex,,true,,,unhex,,,0,
333545,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteUCS2,,true,,,WriteUCS2,,,0,
333553,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,base64_decode,,true,,,base64_decode,,,0,
333560,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,hex_decode,,true,,,hex_decode,,,0,
333567,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Nothing<size_t>,,true,,,Nothing<size_t>,,,0,
333570,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,base64_decoded_size_fast,,true,,,base64_decoded_size_fast,,,0,
333574,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,base64_decoded_size,,true,,,base64_decoded_size,,,0,
333579,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,force_ascii_slow,,true,,,force_ascii_slow,,,0,
333585,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dst,,true,,,dst,,,0,
333590,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,hex_encode,,true,,,hex_encode,,,0,
333597,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,string_bytes.cc,string_bytes.cc:548:554:CHECK_BUFLEN_IN_RANGE:1,,true,548,554,CHECK_BUFLEN_IN_RANGE,,,0,
333601,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CHECK_BUFLEN_IN_RANGE(buflen),,true,,,CHECK_BUFLEN_IN_RANGE(buflen),,,0,
333606,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simdutf.validate_ascii_with_errors,,true,,,simdutf.validate_ascii_with_errors,,,0,
333612,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,node.UncheckedMalloc,,true,,,node.UncheckedMalloc,,,0,
333617,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,force_ascii,,true,,,force_ascii,,,0,
333623,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ExternOneByteString.New,,true,,,ExternOneByteString.New,,,0,
333631,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ExternOneByteString.NewFromCopy,,true,,,ExternOneByteString.NewFromCopy,,,0,
333639,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,base64_encoded_size,,true,,,base64_encoded_size,,,0,
333644,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,base64_encode,,true,,,base64_encode,,,0,
333652,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ExternTwoByteString.New,,true,,,ExternTwoByteString.New,,,0,
333660,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ExternTwoByteString.NewFromCopy,,true,,,ExternTwoByteString.NewFromCopy,,,0,
333668,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Encoding,,true,,,Encoding,,,0,
333671,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MissingBytes,,true,,,MissingBytes,,,0,
333674,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BufferedBytes,,true,,,BufferedBytes,,,0,
333677,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IncompleteCharacterBuffer,,true,,,IncompleteCharacterBuffer,,,0,
333680,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MakeString,,true,,,MakeString,,,0,
333687,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DCHECK_LT,,true,,,DCHECK_LT,,,0,
333692,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,content,,true,,,content,,,0,
333696,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DecodeData,,true,,,DecodeData,,,0,
333703,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FlushData,,true,,,FlushData,,,0,
333708,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,string_decoder.cc,string_decoder.cc:297:300:SET_DECODER_CONSTANT:1,,true,297,300,SET_DECODER_CONSTANT,,,0,
333711,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SET_DECODER_CONSTANT(kIncompleteCharactersStart),,true,,,SET_DECODER_CONSTANT(kIncompleteCharactersStart),,,0,
333717,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SET_DECODER_CONSTANT(kIncompleteCharactersEnd),,true,,,SET_DECODER_CONSTANT(kIncompleteCharactersEnd),,,0,
333723,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SET_DECODER_CONSTANT(kMissingBytes),,true,,,SET_DECODER_CONSTANT(kMissingBytes),,,0,
333729,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SET_DECODER_CONSTANT(kBufferedBytes),,true,,,SET_DECODER_CONSTANT(kBufferedBytes),,,0,
333735,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SET_DECODER_CONSTANT(kEncodingField),,true,,,SET_DECODER_CONSTANT(kEncodingField),,,0,
333741,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SET_DECODER_CONSTANT(kNumFields),,true,,,SET_DECODER_CONSTANT(kNumFields),,,0,
333747,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,string_decoder.cc,string_decoder.cc:310:313:ADD_TO_ENCODINGS_ARRAY:2,,true,310,313,ADD_TO_ENCODINGS_ARRAY,,,0,
333752,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ADD_TO_ENCODINGS_ARRAY(ASCII, ""ascii"")",,true,,,"ADD_TO_ENCODINGS_ARRAY(ASCII, ""ascii"")",,,0,
333759,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ADD_TO_ENCODINGS_ARRAY(UTF8, ""utf8"")",,true,,,"ADD_TO_ENCODINGS_ARRAY(UTF8, ""utf8"")",,,0,
333766,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ADD_TO_ENCODINGS_ARRAY(BASE64, ""base64"")",,true,,,"ADD_TO_ENCODINGS_ARRAY(BASE64, ""base64"")",,,0,
333773,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ADD_TO_ENCODINGS_ARRAY(BASE64URL, ""base64url"")",,true,,,"ADD_TO_ENCODINGS_ARRAY(BASE64URL, ""base64url"")",,,0,
333780,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ADD_TO_ENCODINGS_ARRAY(UCS2, ""utf16le"")",,true,,,"ADD_TO_ENCODINGS_ARRAY(UCS2, ""utf16le"")",,,0,
333787,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ADD_TO_ENCODINGS_ARRAY(HEX, ""hex"")",,true,,,"ADD_TO_ENCODINGS_ARRAY(HEX, ""hex"")",,,0,
333794,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ADD_TO_ENCODINGS_ARRAY(BUFFER, ""buffer"")",,true,,,"ADD_TO_ENCODINGS_ARRAY(BUFFER, ""buffer"")",,,0,
333801,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ADD_TO_ENCODINGS_ARRAY(LATIN1, ""latin1"")",,true,,,"ADD_TO_ENCODINGS_ARRAY(LATIN1, ""latin1"")",,,0,
333808,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tcp_constructor_template,,true,,,tcp_constructor_template,,,0,
333812,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_tcp_constructor_template,,true,,,set_tcp_constructor_template,,,0,
333817,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(constants, UV_TCP_IPV6ONLY)",,true,,,"NODE_DEFINE_CONSTANT(constants, UV_TCP_IPV6ONLY)",,,0,
333825,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_tcp_nodelay,,true,,,uv_tcp_nodelay,,,0,
333830,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_tcp_keepalive,,true,,,uv_tcp_keepalive,,,0,
333836,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_tcp_open,,true,,,uv_tcp_open,,,0,
333841,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ip_address,,true,,,ip_address,,,0,
333846,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_ip_addr,,true,,,uv_ip_addr,,,0,
333851,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_tcp_close_reset,,true,,,uv_tcp_close_reset,,,0,
333856,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IN6_IS_ADDR_LINKLOCAL,,true,,,IN6_IS_ADDR_LINKLOCAL,,,0,
333860,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_if_indextoiid,,true,,,uv_if_indextoiid,,,0,
333866,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_immediate_callback_function,,true,,,set_immediate_callback_function,,,0,
333871,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_timers_callback_function,,true,,,set_timers_callback_function,,,0,
333876,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetLibuvNowImpl,,true,,,GetLibuvNowImpl,,,0,
333880,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ScheduleTimerImpl,,true,,,ScheduleTimerImpl,,,0,
333885,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ToggleTimerRefImpl,,true,,,ToggleTimerRefImpl,,,0,
333890,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ToggleTimerRef,,true,,,ToggleTimerRef,,,0,
333895,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ToggleImmediateRefImpl,,true,,,ToggleImmediateRefImpl,,,0,
333900,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetFastMethod,,true,,,SetFastMethod,,,0,
333908,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InitializeWritersOnThread,,true,,,InitializeWritersOnThread,,,0,
333912,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StopTracing,,true,,,StopTracing,,,0,
333916,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CreateTraceConfig,,true,,,CreateTraceConfig,,,0,
333920,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StartTracing,,true,,,StartTracing,,,0,
333925,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InitializeOnThread,,true,,,InitializeOnThread,,,0,
333930,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Agent.StopTracing,,true,,,StopTracing,,,0,
333933,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Agent.Start,,true,,,Start,,,0,
333936,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,suspend,,true,,,suspend,,,0,
333942,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AgentWriterHandle,,true,,,AgentWriterHandle,,,0,
333947,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,flatten,,true,,,flatten,,,0,
333951,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddIncludedCategory,,true,,,AddIncludedCategory,,,0,
333956,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Flush,,true,,,Flush,,,0,
333961,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,trace_event,,true,,,trace_event,,,0,
333965,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,tracing\trace_event_common.hpp,tracing\trace_event_common.hpp:1054:1054:TRACE_EVENT_PHASE_METADATA:0,,true,1054,1054,TRACE_EVENT_PHASE_METADATA,,,0,
333968,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,tracing\trace_event_common.hpp,tracing\trace_event_common.hpp:1068:1068:TRACE_EVENT_FLAG_NONE:0,,true,1068,1068,TRACE_EVENT_FLAG_NONE,,,0,
333971,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TracingController.CurrentTimestampMicroseconds,,true,,,CurrentTimestampMicroseconds,,,0,
333974,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CurrentCpuTimestampMicroseconds,,true,,,CurrentCpuTimestampMicroseconds,,,0,
333977,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddMetadataEvent,,true,,,AddMetadataEvent,,,0,
333982,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AgentWriterHandle.reset,,true,,,reset,,,0,
333985,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsFull,,true,,,IsFull,,,0,
333989,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddTraceEvent,,true,,,AddTraceEvent,,,0,
334005,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MakeHandle,,true,,,MakeHandle,,,0,
334011,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,seq,,true,,,seq,,,0,
334015,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InternalTraceBuffer.ExtractHandle,,true,,,ExtractHandle,,,0,
334023,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetEventAt,,true,,,GetEventAt,,,0,
334028,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Capacity,,true,,,Capacity,,,0,
334031,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NodeTraceBuffer.TryLoadAvailableBuffer,,true,,,TryLoadAvailableBuffer,,,0,
334034,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetEventByHandle,,true,,,GetEventByHandle,,,0,
334039,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsFlushing,,true,,,IsFlushing,,,0,
334043,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FlushPrivate,,true,,,FlushPrivate,,,0,
334047,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AfterWrite,,true,,,AfterWrite,,,0,
334051,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NodeTraceWriter.Flush,,true,,,Flush,,,0,
334055,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NodeTraceWriter.WriteSuffix,,true,,,WriteSuffix,,,0,
334058,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,replace,,true,,,replace,,,0,
334065,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,filepath,,true,,,filepath,,,0,
334069,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,replace_substring,,true,,,replace_substring,,,0,
334075,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NodeTraceWriter.OpenNewFileForStreaming,,true,,,OpenNewFileForStreaming,,,0,
334078,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,stream_scoped_lock,,true,,,stream_scoped_lock,,,0,
334082,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,request_scoped_lock,,true,,,request_scoped_lock,,,0,
334086,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteToFile,,true,,,WriteToFile,,,0,
334091,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,stream_mutex_lock,,true,,,stream_mutex_lock,,,0,
334095,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteRequest,,true,,,WriteRequest,,,0,
334099,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NodeTraceWriter.StartWrite,,true,,,StartWrite,,,0,
334103,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tracing.TraceEventHelper.GetTracingController,,true,,,tracing.TraceEventHelper.GetTracingController,,,0,
334107,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetCategoryGroupEnabled,,true,,,GetCategoryGroupEnabled,,,0,
334112,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,tracing\trace_event_common.hpp,tracing\trace_event_common.hpp:1072:1072:TRACE_EVENT_FLAG_MANGLE_ID:0,,true,1072,1072,TRACE_EVENT_FLAG_MANGLE_ID,,,0,
334115,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,tracing\trace_event_common.hpp,tracing\trace_event_common.hpp:1097:1097:TRACE_VALUE_TYPE_CONVERTABLE:0,,true,1097,1097,TRACE_VALUE_TYPE_CONVERTABLE,,,0,
334118,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetTraceValue,,true,,,SetTraceValue,,,0,
334124,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,tracing\trace_event.hpp,tracing\trace_event.hpp:93:93:TRACE_EVENT_API_ADD_TRACE_EVENT:0,,true,93,93,TRACE_EVENT_API_ADD_TRACE_EVENT,,,0,
334127,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TRACE_EVENT_API_ADD_TRACE_EVENT,,true,,,TRACE_EVENT_API_ADD_TRACE_EVENT,,,0,
334142,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,tracing\trace_event.hpp,tracing\trace_event.hpp:117:120:TRACE_EVENT_API_UPDATE_TRACE_EVENT_DURATION:0,,true,117,120,TRACE_EVENT_API_UPDATE_TRACE_EVENT_DURATION,,,0,
334145,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TRACE_EVENT_API_UPDATE_TRACE_EVENT_DURATION,,true,,,TRACE_EVENT_API_UPDATE_TRACE_EVENT_DURATION,,,0,
334152,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,tracing\traced_value.cc,tracing\traced_value.cc:21:21:FPCLASSIFY_NAMESPACE:0,,true,21,21,FPCLASSIFY_NAMESPACE,,,0,
334155,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FPCLASSIFY_NAMESPACE.fpclassify,,true,,,FPCLASSIFY_NAMESPACE.fpclassify,,,0,
334160,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TracedValue.WriteName,,true,,,WriteName,,,0,
334164,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DoubleToCString,,true,,,DoubleToCString,,,0,
334168,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EscapeString,,true,,,EscapeString,,,0,
334172,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TracedValue.WriteComma,,true,,,WriteComma,,,0,
334175,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetString,,true,,,SetString,,,0,
334180,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_tty_constructor_template,,true,,,set_tty_constructor_template,,,0,
334185,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_tty_set_mode,,true,,,uv_tty_set_mode,,,0,
334190,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_tty_init,,true,,,uv_tty_init,,,0,
334197,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,from_req,,true,,,from_req,,,0,
334202,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetLibuvHandle,,true,,,GetLibuvHandle,,,0,
334206,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_listener,,true,,,set_listener,,,0,
334210,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_udp_init,,true,,,uv_udp_init,,,0,
334215,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_udp_constructor_function,,true,,,set_udp_constructor_function,,,0,
334220,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(constants, UV_UDP_IPV6ONLY)",,true,,,"NODE_DEFINE_CONSTANT(constants, UV_UDP_IPV6ONLY)",,,0,
334228,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"NODE_DEFINE_CONSTANT(constants, UV_UDP_REUSEADDR)",,true,,,"NODE_DEFINE_CONSTANT(constants, UV_UDP_REUSEADDR)",,,0,
334236,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_udp_bind,,true,,,uv_udp_bind,,,0,
334242,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_udp_connect,,true,,,uv_udp_connect,,,0,
334247,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_udp_open,,true,,,uv_udp_open,,,0,
334252,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DoBind,,true,,,DoBind,,,0,
334257,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DoConnect,,true,,,DoConnect,,,0,
334262,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,iface,,true,,,iface,,,0,
334267,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_udp_set_multicast_interface,,true,,,uv_udp_set_multicast_interface,,,0,
334272,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_udp_set_membership,,true,,,uv_udp_set_membership,,,0,
334279,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetMembership,,true,,,SetMembership,,,0,
334284,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,source_address,,true,,,source_address,,,0,
334289,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,group_address,,true,,,group_address,,,0,
334294,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_udp_set_source_membership,,true,,,uv_udp_set_source_membership,,,0,
334302,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetSourceMembership,,true,,,SetSourceMembership,,,0,
334307,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_udp_try_send,,true,,,uv_udp_try_send,,,0,
334314,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_udp_send_cb,,true,,,uv_udp_send_cb,,,0,
334318,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DoSend,,true,,,DoSend,,,0,
334323,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SocketAddress.FromPeerName,,true,,,SocketAddress.FromPeerName,,,0,
334328,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SocketAddress.FromSockName,,true,,,SocketAddress.FromSockName,,,0,
334333,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,UDPWrapBase.FromObject,,true,,,UDPWrapBase.FromObject,,,0,
334338,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RecvStart,,true,,,RecvStart,,,0,
334342,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_udp_recv_start,,true,,,uv_udp_recv_start,,,0,
334348,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RecvStop,,true,,,RecvStop,,,0,
334352,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_udp_recv_stop,,true,,,uv_udp_recv_stop,,,0,
334356,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,have_callback,,true,,,have_callback,,,0,
334360,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,onmessage_string,,true,,,onmessage_string,,,0,
334364,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,udp_constructor_function,,true,,,udp_constructor_function,,,0,
334368,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MakeUtf8String,,true,,,MakeUtf8String,,,0,
334374,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Invalidate,,true,,,Invalidate,,,0,
334377,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LowMemoryNotification,,true,,,LowMemoryNotification,,,0,
334381,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uv_get_process_title,,true,,,uv_get_process_title,,,0,
334386,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.find_first_of,,true,,,std.find_first_of,,,0,
334394,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.cbegin,,true,,,std.cbegin,,,0,
334399,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.cend,,true,,,std.cend,,,0,
334404,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ftell,,true,,,ftell,,,0,
334408,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fseek,,true,,,fseek,,,0,
334414,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,contents,,true,,,contents,,,0,
334418,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fread,,true,,,fread,,,0,
334425,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gettimeofday,,true,,,gettimeofday,,,0,
334430,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,localtime_r,,true,,,localtime_r,,,0,
334435,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LocalTime,,true,,,LocalTime,,,0,
334439,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.setfill,,true,,,std.setfill,,,0,
334444,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.setw,,true,,,std.setw,,,0,
334449,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Local<v8.Value>,,true,,,Local<v8.Value>,,,0,
334453,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Local<v8.Signature>,,true,,,Local<v8.Signature>,,,0,
334457,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,is_one_byte,,true,,,is_one_byte,,,0,
334460,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,UV_ERRNO_MAP,,true,,,UV_ERRNO_MAP,,,0,
334464,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EmitErrNameWarning,,true,,,EmitErrNameWarning,,,0,
