11,METHOD,core\nginx.c:<global>,TYPE_DECL,<global>,1,6,core\nginx.c,core\nginx.c:<global>,,false,1,1590,<global>,,,1,
13,METHOD,core\nginx.c:<global>,TYPE_DECL,static void ngx_show_version_info(void);,13,39,core\nginx.c,ngx_show_version_info,,false,13,13,ngx_show_version_info,,,1,void ngx_show_version_info (void)
18,METHOD,core\nginx.c:<global>,TYPE_DECL,static ngx_int_t ngx_add_inherited_sockets(ngx_cycle_t *cycle);,18,62,core\nginx.c,ngx_add_inherited_sockets,,false,14,14,ngx_add_inherited_sockets,,,2,ngx_int_t ngx_add_inherited_sockets (ngx_cycle_t*)
23,METHOD,core\nginx.c:<global>,TYPE_DECL,static void ngx_cleanup_environment(void *data);,13,47,core\nginx.c,ngx_cleanup_environment,,false,15,15,ngx_cleanup_environment,,,3,void ngx_cleanup_environment (void*)
28,METHOD,core\nginx.c:<global>,TYPE_DECL,"static ngx_int_t ngx_get_options(int argc, char *const *argv);",18,61,core\nginx.c,ngx_get_options,,false,16,16,ngx_get_options,,,4,"ngx_int_t ngx_get_options (int,char**)"
34,METHOD,core\nginx.c:<global>,TYPE_DECL,static ngx_int_t ngx_process_options(ngx_cycle_t *cycle);,18,56,core\nginx.c,ngx_process_options,,false,17,17,ngx_process_options,,,5,ngx_int_t ngx_process_options (ngx_cycle_t*)
39,METHOD,core\nginx.c:<global>,TYPE_DECL,"static ngx_int_t ngx_save_argv(ngx_cycle_t *cycle, int argc, char *const *argv);",18,79,core\nginx.c,ngx_save_argv,,false,18,18,ngx_save_argv,,,6,"ngx_int_t ngx_save_argv (ngx_cycle_t*,int,char**)"
46,METHOD,core\nginx.c:<global>,TYPE_DECL,static void *ngx_core_module_create_conf(ngx_cycle_t *cycle);,13,60,core\nginx.c,ngx_core_module_create_conf,,false,19,19,ngx_core_module_create_conf,,,7,void* ngx_core_module_create_conf (ngx_cycle_t*)
51,METHOD,core\nginx.c:<global>,TYPE_DECL,"static char *ngx_core_module_init_conf(ngx_cycle_t *cycle, void *conf);",13,70,core\nginx.c,ngx_core_module_init_conf,,false,20,20,ngx_core_module_init_conf,,,8,"char* ngx_core_module_init_conf (ngx_cycle_t*,void*)"
57,METHOD,core\nginx.c:<global>,TYPE_DECL,"static char *ngx_set_user(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",13,73,core\nginx.c,ngx_set_user,,false,21,21,ngx_set_user,,,9,"char* ngx_set_user (ngx_conf_t*,ngx_command_t*,void*)"
64,METHOD,core\nginx.c:<global>,TYPE_DECL,"static char *ngx_set_env(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",13,72,core\nginx.c,ngx_set_env,,false,22,22,ngx_set_env,,,10,"char* ngx_set_env (ngx_conf_t*,ngx_command_t*,void*)"
71,METHOD,core\nginx.c:<global>,TYPE_DECL,"static char *ngx_set_priority(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",13,77,core\nginx.c,ngx_set_priority,,false,23,23,ngx_set_priority,,,11,"char* ngx_set_priority (ngx_conf_t*,ngx_command_t*,void*)"
78,METHOD,core\nginx.c:<global>,TYPE_DECL,"static char *ngx_set_cpu_affinity(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,core\nginx.c,ngx_set_cpu_affinity,,false,24,25,ngx_set_cpu_affinity,,,12,"char* ngx_set_cpu_affinity (ngx_conf_t*,ngx_command_t*,void*)"
85,METHOD,core\nginx.c:<global>,TYPE_DECL,"static char *ngx_set_worker_processes(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,core\nginx.c,ngx_set_worker_processes,,false,26,27,ngx_set_worker_processes,,,13,"char* ngx_set_worker_processes (ngx_conf_t*,ngx_command_t*,void*)"
92,METHOD,core\nginx.c:<global>,TYPE_DECL,"static char *ngx_load_module(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",13,76,core\nginx.c,ngx_load_module,,false,28,28,ngx_load_module,,,14,"char* ngx_load_module (ngx_conf_t*,ngx_command_t*,void*)"
367,METHOD,core\nginx.c:<global>,TYPE_DECL,"main(int argc, char *const *argv)
{
    ngx_buf_t        *b;
    ngx_log_t        *log;
    ngx_uint_t        i;
    ngx_cycle_t      *cycle, init_cycle;
    ngx_conf_dump_t  *cd;
    ngx_core_conf_t  *ccf;

    ngx_debug_init();

    if (ngx_strerror_init() != NGX_OK) {
        return 1;
    }

    if (ngx_get_options(argc, argv) != NGX_OK) {
        return 1;
    }

    if (ngx_show_version) {
        ngx_show_version_info();

        if (!ngx_test_config) {
            return 0;
        }
    }

    /* TODO */ ngx_max_sockets = -1;

    ngx_time_init();

#if (NGX_PCRE)
    ngx_regex_init();
#endif

    ngx_pid = ngx_getpid();
    ngx_parent = ngx_getppid();

    log = ngx_log_init(ngx_prefix);
    if (log == NULL) {
        return 1;
    }

    /* STUB */
#if (NGX_OPENSSL)
    ngx_ssl_init(log);
#endif

    /*
     * init_cycle->log is required for signal handlers and
     * ngx_process_options()
     */

    ngx_memzero(&init_cycle, sizeof(ngx_cycle_t));
    init_cycle.log = log...",1,1,core\nginx.c,main,,false,195,386,main,,,33,"ANY main (int,char**)"
750,METHOD,core\nginx.c:<global>,TYPE_DECL,"static void
ngx_show_version_info(void)
{
    ngx_write_stderr(""nginx version: "" NGINX_VER_BUILD NGX_LINEFEED);

    if (ngx_show_help) {
        ngx_write_stderr(
            ""Usage: nginx [-?hvVtTq] [-s signal] [-c filename] ""
                         ""[-p prefix] [-g directives]"" NGX_LINEFEED
                         NGX_LINEFEED
            ""Options:"" NGX_LINEFEED
            ""  -?,-h         : this help"" NGX_LINEFEED
            ""  -v            : show version and exit"" NGX_LINEFEED
            ""  -V            : show version and configure options then exit""
                               NGX_LINEFEED
            ""  -t            : test configuration and exit"" NGX_LINEFEED
            ""  -T            : test configuration, dump it and exit""
                               NGX_LINEFEED
            ""  -q            : suppress non-error messages ""
                               ""during configuration testing"" NGX_LINEFEED
            ""  -s signal     : send signal to a master proces...",1,1,core\nginx.c,ngx_show_version_info,,false,389,448,ngx_show_version_info,,,34,void ngx_show_version_info (void)
764,METHOD,core\nginx.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_add_inherited_sockets(ngx_cycle_t *cycle)
{
    u_char           *p, *v, *inherited;
    ngx_int_t         s;
    ngx_listening_t  *ls;

    inherited = (u_char *) getenv(NGINX_VAR);

    if (inherited == NULL) {
        return NGX_OK;
    }

    ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0,
                  ""using inherited sockets from \""%s\"""", inherited);

    if (ngx_array_init(&cycle->listening, cycle->pool, 10,
                       sizeof(ngx_listening_t))
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    for (p = inherited, v = p; *p; p++) {
        if (*p == ':' || *p == ';') {
            s = ngx_atoi(v, p - v);
            if (s == NGX_ERROR) {
                ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
                              ""invalid socket number \""%s\"" in "" NGINX_VAR
                              "" environment variable, ignoring the rest""
                              "" of the variable"", v);
                break;
            }
...",1,1,core\nginx.c,ngx_add_inherited_sockets,,false,451,507,ngx_add_inherited_sockets,,,35,ngx_int_t ngx_add_inherited_sockets (ngx_cycle_t*)
893,METHOD,core\nginx.c:<global>,TYPE_DECL,"char **
ngx_set_environment(ngx_cycle_t *cycle, ngx_uint_t *last)
{
    char                **p, **env;
    ngx_str_t            *var;
    ngx_uint_t            i, n;
    ngx_core_conf_t      *ccf;
    ngx_pool_cleanup_t   *cln;

    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);

    if (last == NULL && ccf->environment) {
        return ccf->environment;
    }

    var = ccf->env.elts;

    for (i = 0; i < ccf->env.nelts; i++) {
        if (ngx_strcmp(var[i].data, ""TZ"") == 0
            || ngx_strncmp(var[i].data, ""TZ="", 3) == 0)
        {
            goto tz_found;
        }
    }

    var = ngx_array_push(&ccf->env);
    if (var == NULL) {
        return NULL;
    }

    var->len = 2;
    var->data = (u_char *) ""TZ"";

    var = ccf->env.elts;

tz_found:

    n = 0;

    for (i = 0; i < ccf->env.nelts; i++) {

        if (var[i].data[var[i].len] == '=') {
            n++;
            continue;
        }

        for (p = ngx_os_environ; *p; p++) {

    ...",1,1,core\nginx.c,ngx_set_environment,,false,510,618,ngx_set_environment,,,36,"char** ngx_set_environment (ngx_cycle_t*,ngx_uint_t*)"
1270,METHOD,core\nginx.c:<global>,TYPE_DECL,"static void
ngx_cleanup_environment(void *data)
{
    char  **env = data;

    if (environ == env) {

        /*
         * if the environment is still used, as it happens on exit,
         * the only option is to leak it
         */

        return;
    }

    ngx_free(env);
}",1,1,core\nginx.c,ngx_cleanup_environment,,false,621,637,ngx_cleanup_environment,,,37,void ngx_cleanup_environment (void*)
1287,METHOD,core\nginx.c:<global>,TYPE_DECL,"ngx_pid_t
ngx_exec_new_binary(ngx_cycle_t *cycle, char *const *argv)
{
    char             **env, *var;
    u_char            *p;
    ngx_uint_t         i, n;
    ngx_pid_t          pid;
    ngx_exec_ctx_t     ctx;
    ngx_core_conf_t   *ccf;
    ngx_listening_t   *ls;

    ngx_memzero(&ctx, sizeof(ngx_exec_ctx_t));

    ctx.path = argv[0];
    ctx.name = ""new binary process"";
    ctx.argv = argv;

    n = 2;
    env = ngx_set_environment(cycle, &n);
    if (env == NULL) {
        return NGX_INVALID_PID;
    }

    var = ngx_alloc(sizeof(NGINX_VAR)
                    + cycle->listening.nelts * (NGX_INT32_LEN + 1) + 2,
                    cycle->log);
    if (var == NULL) {
        ngx_free(env);
        return NGX_INVALID_PID;
    }

    p = ngx_cpymem(var, NGINX_VAR ""="", sizeof(NGINX_VAR));

    ls = cycle->listening.elts;
    for (i = 0; i < cycle->listening.nelts; i++) {
        p = ngx_sprintf(p, ""%ud;"", ls[i].fd);
    }

    *p = '\0';

    env[n++] = var;

#if (NGX_SETPROCTI...",1,1,core\nginx.c,ngx_exec_new_binary,,false,640,738,ngx_exec_new_binary,,,38,"ngx_pid_t ngx_exec_new_binary (ngx_cycle_t*,char**)"
1488,METHOD,core\nginx.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_get_options(int argc, char *const *argv)
{
    u_char     *p;
    ngx_int_t   i;

    for (i = 1; i < argc; i++) {

        p = (u_char *) argv[i];

        if (*p++ != '-') {
            ngx_log_stderr(0, ""invalid option: \""%s\"""", argv[i]);
            return NGX_ERROR;
        }

        while (*p) {

            switch (*p++) {

            case '?':
            case 'h':
                ngx_show_version = 1;
                ngx_show_help = 1;
                break;

            case 'v':
                ngx_show_version = 1;
                break;

            case 'V':
                ngx_show_version = 1;
                ngx_show_configure = 1;
                break;

            case 't':
                ngx_test_config = 1;
                break;

            case 'T':
                ngx_test_config = 1;
                ngx_dump_config = 1;
                break;

            case 'q':
                ngx_quiet_mode = 1;
                break;

        ...",1,1,core\nginx.c,ngx_get_options,,false,741,866,ngx_get_options,,,39,"ngx_int_t ngx_get_options (int,char**)"
1752,METHOD,core\nginx.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_save_argv(ngx_cycle_t *cycle, int argc, char *const *argv)
{
#if (NGX_FREEBSD)

    ngx_os_argv = (char **) argv;
    ngx_argc = argc;
    ngx_argv = (char **) argv;

#else
    size_t     len;
    ngx_int_t  i;

    ngx_os_argv = (char **) argv;
    ngx_argc = argc;

    ngx_argv = ngx_alloc((argc + 1) * sizeof(char *), cycle->log);
    if (ngx_argv == NULL) {
        return NGX_ERROR;
    }

    for (i = 0; i < argc; i++) {
        len = ngx_strlen(argv[i]) + 1;

        ngx_argv[i] = ngx_alloc(len, cycle->log);
        if (ngx_argv[i] == NULL) {
            return NGX_ERROR;
        }

        (void) ngx_cpystrn((u_char *) ngx_argv[i], (u_char *) argv[i], len);
    }

    ngx_argv[i] = NULL;

#endif

    ngx_os_environ = environ;

    return NGX_OK;
}",1,1,core\nginx.c,ngx_save_argv,,false,869,908,ngx_save_argv,,,40,"ngx_int_t ngx_save_argv (ngx_cycle_t*,int,char**)"
1849,METHOD,core\nginx.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_process_options(ngx_cycle_t *cycle)
{
    u_char  *p;
    size_t   len;

    if (ngx_prefix) {
        len = ngx_strlen(ngx_prefix);
        p = ngx_prefix;

        if (len && !ngx_path_separator(p[len - 1])) {
            p = ngx_pnalloc(cycle->pool, len + 1);
            if (p == NULL) {
                return NGX_ERROR;
            }

            ngx_memcpy(p, ngx_prefix, len);
            p[len++] = '/';
        }

        cycle->conf_prefix.len = len;
        cycle->conf_prefix.data = p;
        cycle->prefix.len = len;
        cycle->prefix.data = p;

    } else {

#ifndef NGX_PREFIX

        p = ngx_pnalloc(cycle->pool, NGX_MAX_PATH);
        if (p == NULL) {
            return NGX_ERROR;
        }

        if (ngx_getcwd(p, NGX_MAX_PATH) == 0) {
            ngx_log_stderr(ngx_errno, ""[emerg]: "" ngx_getcwd_n "" failed"");
            return NGX_ERROR;
        }

        len = ngx_strlen(p);

        p[len++] = '/';

        cycle->conf_prefix.len = len;
  ...",1,1,core\nginx.c,ngx_process_options,,false,911,1004,ngx_process_options,,,41,ngx_int_t ngx_process_options (ngx_cycle_t*)
2123,METHOD,core\nginx.c:<global>,TYPE_DECL,"static void *
ngx_core_module_create_conf(ngx_cycle_t *cycle)
{
    ngx_core_conf_t  *ccf;

    ccf = ngx_pcalloc(cycle->pool, sizeof(ngx_core_conf_t));
    if (ccf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc()
     *
     *     ccf->pid = NULL;
     *     ccf->oldpid = NULL;
     *     ccf->priority = 0;
     *     ccf->cpu_affinity_auto = 0;
     *     ccf->cpu_affinity_n = 0;
     *     ccf->cpu_affinity = NULL;
     */

    ccf->daemon = NGX_CONF_UNSET;
    ccf->master = NGX_CONF_UNSET;
    ccf->timer_resolution = NGX_CONF_UNSET_MSEC;
    ccf->shutdown_timeout = NGX_CONF_UNSET_MSEC;

    ccf->worker_processes = NGX_CONF_UNSET;
    ccf->debug_points = NGX_CONF_UNSET;

    ccf->rlimit_nofile = NGX_CONF_UNSET;
    ccf->rlimit_core = NGX_CONF_UNSET;

    ccf->user = (ngx_uid_t) NGX_CONF_UNSET_UINT;
    ccf->group = (ngx_gid_t) NGX_CONF_UNSET_UINT;

    if (ngx_array_init(&ccf->env, cycle->pool, 1, sizeof(ngx_str_t))
        != NGX_OK)
    {
        return...",1,1,core\nginx.c,ngx_core_module_create_conf,,false,1007,1049,ngx_core_module_create_conf,,,42,void* ngx_core_module_create_conf (ngx_cycle_t*)
2217,METHOD,core\nginx.c:<global>,TYPE_DECL,"static char *
ngx_core_module_init_conf(ngx_cycle_t *cycle, void *conf)
{
    ngx_core_conf_t  *ccf = conf;

    ngx_conf_init_value(ccf->daemon, 1);
    ngx_conf_init_value(ccf->master, 1);
    ngx_conf_init_msec_value(ccf->timer_resolution, 0);
    ngx_conf_init_msec_value(ccf->shutdown_timeout, 0);

    ngx_conf_init_value(ccf->worker_processes, 1);
    ngx_conf_init_value(ccf->debug_points, 0);

#if (NGX_HAVE_CPU_AFFINITY)

    if (!ccf->cpu_affinity_auto
        && ccf->cpu_affinity_n
        && ccf->cpu_affinity_n != 1
        && ccf->cpu_affinity_n != (ngx_uint_t) ccf->worker_processes)
    {
        ngx_log_error(NGX_LOG_WARN, cycle->log, 0,
                      ""the number of \""worker_processes\"" is not equal to ""
                      ""the number of \""worker_cpu_affinity\"" masks, ""
                      ""using last mask for remaining worker processes"");
    }

#endif


    if (ccf->pid.len == 0) {
        ngx_str_set(&ccf->pid, NGX_PID_PATH);
    }

    if (ngx_conf_full_...",1,1,core\nginx.c,ngx_core_module_init_conf,,false,1052,1178,ngx_core_module_init_conf,,,43,"char* ngx_core_module_init_conf (ngx_cycle_t*,void*)"
2592,METHOD,core\nginx.c:<global>,TYPE_DECL,"static char *
ngx_set_user(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
#if (NGX_WIN32)

    ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
                       ""\""user\"" is not supported, ignored"");

    return NGX_CONF_OK;

#else

    ngx_core_conf_t  *ccf = conf;

    char             *group;
    struct passwd    *pwd;
    struct group     *grp;
    ngx_str_t        *value;

    if (ccf->user != (uid_t) NGX_CONF_UNSET_UINT) {
        return ""is duplicate"";
    }

    if (geteuid() != 0) {
        ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
                           ""the \""user\"" directive makes sense only ""
                           ""if the master process runs ""
                           ""with super-user privileges, ignored"");
        return NGX_CONF_OK;
    }

    value = cf->args->elts;

    ccf->username = (char *) value[1].data;

    ngx_set_errno(0);
    pwd = getpwnam((const char *) value[1].data);
    if (pwd == NULL) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, ngx_errn...",1,1,core\nginx.c,ngx_set_user,,false,1181,1241,ngx_set_user,,,44,"char* ngx_set_user (ngx_conf_t*,ngx_command_t*,void*)"
2734,METHOD,core\nginx.c:<global>,TYPE_DECL,"static char *
ngx_set_env(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_core_conf_t  *ccf = conf;

    ngx_str_t   *value, *var;
    ngx_uint_t   i;

    var = ngx_array_push(&ccf->env);
    if (var == NULL) {
        return NGX_CONF_ERROR;
    }

    value = cf->args->elts;
    *var = value[1];

    for (i = 0; i < value[1].len; i++) {

        if (value[1].data[i] == '=') {

            var->len = i;

            return NGX_CONF_OK;
        }
    }

    return NGX_CONF_OK;
}",1,1,core\nginx.c,ngx_set_env,,false,1244,1271,ngx_set_env,,,45,"char* ngx_set_env (ngx_conf_t*,ngx_command_t*,void*)"
2810,METHOD,core\nginx.c:<global>,TYPE_DECL,"static char *
ngx_set_priority(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_core_conf_t  *ccf = conf;

    ngx_str_t        *value;
    ngx_uint_t        n, minus;

    if (ccf->priority != 0) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    if (value[1].data[0] == '-') {
        n = 1;
        minus = 1;

    } else if (value[1].data[0] == '+') {
        n = 1;
        minus = 0;

    } else {
        n = 0;
        minus = 0;
    }

    ccf->priority = ngx_atoi(&value[1].data[n], value[1].len - n);
    if (ccf->priority == NGX_ERROR) {
        return ""invalid number"";
    }

    if (minus) {
        ccf->priority = -ccf->priority;
    }

    return NGX_CONF_OK;
}",1,1,core\nginx.c,ngx_set_priority,,false,1274,1311,ngx_set_priority,,,46,"char* ngx_set_priority (ngx_conf_t*,ngx_command_t*,void*)"
2926,METHOD,core\nginx.c:<global>,TYPE_DECL,"static char *
ngx_set_cpu_affinity(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
#if (NGX_HAVE_CPU_AFFINITY)
    ngx_core_conf_t  *ccf = conf;

    u_char            ch, *p;
    ngx_str_t        *value;
    ngx_uint_t        i, n;
    ngx_cpuset_t     *mask;

    if (ccf->cpu_affinity) {
        return ""is duplicate"";
    }

    mask = ngx_palloc(cf->pool, (cf->args->nelts - 1) * sizeof(ngx_cpuset_t));
    if (mask == NULL) {
        return NGX_CONF_ERROR;
    }

    ccf->cpu_affinity_n = cf->args->nelts - 1;
    ccf->cpu_affinity = mask;

    value = cf->args->elts;

    if (ngx_strcmp(value[1].data, ""auto"") == 0) {

        if (cf->args->nelts > 3) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               ""invalid number of arguments in ""
                               ""\""worker_cpu_affinity\"" directive"");
            return NGX_CONF_ERROR;
        }

        ccf->cpu_affinity_auto = 1;

        CPU_ZERO(&mask[0]);
        for (i = 0; i < (ngx_uint_...",1,1,core\nginx.c,ngx_set_cpu_affinity,,false,1314,1409,ngx_set_cpu_affinity,,,47,"char* ngx_set_cpu_affinity (ngx_conf_t*,ngx_command_t*,void*)"
2940,METHOD,core\nginx.c:<global>,TYPE_DECL,"ngx_cpuset_t *
ngx_get_cpu_affinity(ngx_uint_t n)
{
#if (NGX_HAVE_CPU_AFFINITY)
    ngx_uint_t        i, j;
    ngx_cpuset_t     *mask;
    ngx_core_conf_t  *ccf;

    static ngx_cpuset_t  result;

    ccf = (ngx_core_conf_t *) ngx_get_conf(ngx_cycle->conf_ctx,
                                           ngx_core_module);

    if (ccf->cpu_affinity == NULL) {
        return NULL;
    }

    if (ccf->cpu_affinity_auto) {
        mask = &ccf->cpu_affinity[ccf->cpu_affinity_n - 1];

        for (i = 0, j = n; /* void */ ; i++) {

            if (CPU_ISSET(i % CPU_SETSIZE, mask) && j-- == 0) {
                break;
            }

            if (i == CPU_SETSIZE && j == n) {
                /* empty mask */
                return NULL;
            }

            /* void */
        }

        CPU_ZERO(&result);
        CPU_SET(i % CPU_SETSIZE, &result);

        return &result;
    }

    if (ccf->cpu_affinity_n > n) {
        return &ccf->cpu_affinity[n];
    }

    return &ccf->cpu_aff...",1,1,core\nginx.c,ngx_get_cpu_affinity,,false,1412,1463,ngx_get_cpu_affinity,,,48,ngx_cpuset_t ngx_get_cpu_affinity (ngx_uint_t)
2947,METHOD,core\nginx.c:<global>,TYPE_DECL,"static char *
ngx_set_worker_processes(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_str_t        *value;
    ngx_core_conf_t  *ccf;

    ccf = (ngx_core_conf_t *) conf;

    if (ccf->worker_processes != NGX_CONF_UNSET) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    if (ngx_strcmp(value[1].data, ""auto"") == 0) {
        ccf->worker_processes = ngx_ncpu;
        return NGX_CONF_OK;
    }

    ccf->worker_processes = ngx_atoi(value[1].data, value[1].len);

    if (ccf->worker_processes == NGX_ERROR) {
        return ""invalid value"";
    }

    return NGX_CONF_OK;
}",1,1,core\nginx.c,ngx_set_worker_processes,,false,1466,1492,ngx_set_worker_processes,,,49,"char* ngx_set_worker_processes (ngx_conf_t*,ngx_command_t*,void*)"
3021,METHOD,core\nginx.c:<global>,TYPE_DECL,"static char *
ngx_load_module(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
#if (NGX_HAVE_DLOPEN)
    void                *handle;
    char               **names, **order;
    ngx_str_t           *value, file;
    ngx_uint_t           i;
    ngx_module_t        *module, **modules;
    ngx_pool_cleanup_t  *cln;

    if (cf->cycle->modules_used) {
        return ""is specified too late"";
    }

    value = cf->args->elts;

    file = value[1];

    if (ngx_conf_full_name(cf->cycle, &file, 0) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    cln = ngx_pool_cleanup_add(cf->cycle->pool, 0);
    if (cln == NULL) {
        return NGX_CONF_ERROR;
    }

    handle = ngx_dlopen(file.data);
    if (handle == NULL) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ngx_dlopen_n "" \""%s\"" failed (%s)"",
                           file.data, ngx_dlerror());
        return NGX_CONF_ERROR;
    }

    cln->handler = ngx_unload_module;
    cln->data = handle;

    mo...",1,1,core\nginx.c,ngx_load_module,,false,1495,1574,ngx_load_module,,,50,"char* ngx_load_module (ngx_conf_t*,ngx_command_t*,void*)"
3038,METHOD,core\nginx.h:<global>,TYPE_DECL,<global>,1,31,core\nginx.h,core\nginx.h:<global>,,false,1,26,<global>,,,1,
3047,METHOD,core\ngx_array.c:<global>,TYPE_DECL,<global>,1,1,core\ngx_array.c,core\ngx_array.c:<global>,,false,1,141,<global>,,,1,
3049,METHOD,core\ngx_array.c:<global>,TYPE_DECL,"ngx_array_t *
ngx_array_create(ngx_pool_t *p, ngx_uint_t n, size_t size)
{
    ngx_array_t *a;

    a = ngx_palloc(p, sizeof(ngx_array_t));
    if (a == NULL) {
        return NULL;
    }

    if (ngx_array_init(a, p, n, size) != NGX_OK) {
        return NULL;
    }

    return a;
}",1,1,core\ngx_array.c,ngx_array_create,,false,12,27,ngx_array_create,,,1,"ngx_array_t ngx_array_create (ngx_pool_t*,ngx_uint_t,size_t)"
3083,METHOD,core\ngx_array.c:<global>,TYPE_DECL,"void
ngx_array_destroy(ngx_array_t *a)
{
    ngx_pool_t  *p;

    p = a->pool;

    if ((u_char *) a->elts + a->size * a->nalloc == p->d.last) {
        p->d.last -= a->size * a->nalloc;
    }

    if ((u_char *) a + sizeof(ngx_array_t) == p->d.last) {
        p->d.last = (u_char *) a;
    }
}",1,1,core\ngx_array.c,ngx_array_destroy,,false,30,44,ngx_array_destroy,,,2,void ngx_array_destroy (ngx_array_t*)
3151,METHOD,core\ngx_array.c:<global>,TYPE_DECL,"void *
ngx_array_push(ngx_array_t *a)
{
    void        *elt, *new;
    size_t       size;
    ngx_pool_t  *p;

    if (a->nelts == a->nalloc) {

        /* the array is full */

        size = a->size * a->nalloc;

        p = a->pool;

        if ((u_char *) a->elts + size == p->d.last
            && p->d.last + a->size <= p->d.end)
        {
            /*
             * the array allocation is the last in the pool
             * and there is space for new allocation
             */

            p->d.last += a->size;
            a->nalloc++;

        } else {
            /* allocate a new array */

            new = ngx_palloc(p, 2 * size);
            if (new == NULL) {
                return NULL;
            }

            ngx_memcpy(new, a->elts, size);
            a->elts = new;
            a->nalloc *= 2;
        }
    }

    elt = (u_char *) a->elts + a->size * a->nelts;
    a->nelts++;

    return elt;
}",1,1,core\ngx_array.c,ngx_array_push,,false,47,91,ngx_array_push,,,3,void* ngx_array_push (ngx_array_t*)
3280,METHOD,core\ngx_array.c:<global>,TYPE_DECL,"void *
ngx_array_push_n(ngx_array_t *a, ngx_uint_t n)
{
    void        *elt, *new;
    size_t       size;
    ngx_uint_t   nalloc;
    ngx_pool_t  *p;

    size = n * a->size;

    if (a->nelts + n > a->nalloc) {

        /* the array is full */

        p = a->pool;

        if ((u_char *) a->elts + a->size * a->nalloc == p->d.last
            && p->d.last + size <= p->d.end)
        {
            /*
             * the array allocation is the last in the pool
             * and there is space for new allocation
             */

            p->d.last += size;
            a->nalloc += n;

        } else {
            /* allocate a new array */

            nalloc = 2 * ((n >= a->nalloc) ? n : a->nalloc);

            new = ngx_palloc(p, nalloc * a->size);
            if (new == NULL) {
                return NULL;
            }

            ngx_memcpy(new, a->elts, a->nelts * a->size);
            a->elts = new;
            a->nalloc = nalloc;
        }
    }

    elt = (u_char *) a...",1,1,core\ngx_array.c,ngx_array_push_n,,false,94,141,ngx_array_push_n,,,4,"void* ngx_array_push_n (ngx_array_t*,ngx_uint_t)"
3444,METHOD,core\ngx_array.h:<global>,TYPE_DECL,<global>,1,35,core\ngx_array.h,core\ngx_array.h:<global>,,false,1,53,<global>,,,1,
3453,METHOD,core\ngx_array.h:<global>,TYPE_DECL,"ngx_array_t *ngx_array_create(ngx_pool_t *p, ngx_uint_t n, size_t size);",13,71,core\ngx_array.h,ngx_array_create,,false,25,25,ngx_array_create,,,3,"ngx_array_t* ngx_array_create (ngx_pool_t*,ngx_uint_t,size_t)"
3460,METHOD,core\ngx_array.h:<global>,TYPE_DECL,void ngx_array_destroy(ngx_array_t *a);,6,38,core\ngx_array.h,ngx_array_destroy,,false,26,26,ngx_array_destroy,,,4,void ngx_array_destroy (ngx_array_t*)
3465,METHOD,core\ngx_array.h:<global>,TYPE_DECL,void *ngx_array_push(ngx_array_t *a);,6,36,core\ngx_array.h,ngx_array_push,,false,27,27,ngx_array_push,,,5,void* ngx_array_push (ngx_array_t*)
3470,METHOD,core\ngx_array.h:<global>,TYPE_DECL,"void *ngx_array_push_n(ngx_array_t *a, ngx_uint_t n);",6,52,core\ngx_array.h,ngx_array_push_n,,false,28,28,ngx_array_push_n,,,6,"void* ngx_array_push_n (ngx_array_t*,ngx_uint_t)"
3478,METHOD,core\ngx_array.h:<global>,TYPE_DECL,"ngx_array_init(ngx_array_t *array, ngx_pool_t *pool, ngx_uint_t n, size_t size)
{
    /*
     * set ""array->nelts"" before ""array->elts"", otherwise MSVC thinks
     * that ""array->nelts"" may be used without having been initialized
     */

    array->nelts = 0;
    array->size = size;
    array->nalloc = n;
    array->pool = pool;

    array->elts = ngx_palloc(pool, n * size);
    if (array->elts == NULL) {
        return NGX_ERROR;
    }

    return NGX_OK;
}",1,1,core\ngx_array.h,ngx_array_init,,false,32,50,ngx_array_init,,,9,"ANY ngx_array_init (ngx_array_t*,ngx_pool_t*,ngx_uint_t,size_t)"
3533,METHOD,core\ngx_buf.c:<global>,TYPE_DECL,<global>,1,1,core\ngx_buf.c,core\ngx_buf.c:<global>,,false,1,314,<global>,,,1,
3535,METHOD,core\ngx_buf.c:<global>,TYPE_DECL,"ngx_buf_t *
ngx_create_temp_buf(ngx_pool_t *pool, size_t size)
{
    ngx_buf_t *b;

    b = ngx_calloc_buf(pool);
    if (b == NULL) {
        return NULL;
    }

    b->start = ngx_palloc(pool, size);
    if (b->start == NULL) {
        return NULL;
    }

    /*
     * set by ngx_calloc_buf():
     *
     *     b->file_pos = 0;
     *     b->file_last = 0;
     *     b->file = NULL;
     *     b->shadow = NULL;
     *     b->tag = 0;
     *     and flags
     */

    b->pos = b->start;
    b->last = b->start;
    b->end = b->last + size;
    b->temporary = 1;

    return b;
}",1,1,core\ngx_buf.c,ngx_create_temp_buf,,false,12,44,ngx_create_temp_buf,,,1,"ngx_buf_t ngx_create_temp_buf (ngx_pool_t*,size_t)"
3599,METHOD,core\ngx_buf.c:<global>,TYPE_DECL,"ngx_chain_t *
ngx_alloc_chain_link(ngx_pool_t *pool)
{
    ngx_chain_t  *cl;

    cl = pool->chain;

    if (cl) {
        pool->chain = cl->next;
        return cl;
    }

    cl = ngx_palloc(pool, sizeof(ngx_chain_t));
    if (cl == NULL) {
        return NULL;
    }

    return cl;
}",1,1,core\ngx_buf.c,ngx_alloc_chain_link,,false,47,65,ngx_alloc_chain_link,,,2,ngx_chain_t ngx_alloc_chain_link (ngx_pool_t*)
3637,METHOD,core\ngx_buf.c:<global>,TYPE_DECL,"ngx_chain_t *
ngx_create_chain_of_bufs(ngx_pool_t *pool, ngx_bufs_t *bufs)
{
    u_char       *p;
    ngx_int_t     i;
    ngx_buf_t    *b;
    ngx_chain_t  *chain, *cl, **ll;

    p = ngx_palloc(pool, bufs->num * bufs->size);
    if (p == NULL) {
        return NULL;
    }

    ll = &chain;

    for (i = 0; i < bufs->num; i++) {

        b = ngx_calloc_buf(pool);
        if (b == NULL) {
            return NULL;
        }

        /*
         * set by ngx_calloc_buf():
         *
         *     b->file_pos = 0;
         *     b->file_last = 0;
         *     b->file = NULL;
         *     b->shadow = NULL;
         *     b->tag = 0;
         *     and flags
         *
         */

        b->pos = p;
        b->last = p;
        b->temporary = 1;

        b->start = p;
        p += bufs->size;
        b->end = p;

        cl = ngx_alloc_chain_link(pool);
        if (cl == NULL) {
            return NULL;
        }

        cl->buf = b;
        *ll = cl;
        ll = &cl->next;
    ...",1,1,core\ngx_buf.c,ngx_create_chain_of_bufs,,false,68,123,ngx_create_chain_of_bufs,,,3,"ngx_chain_t ngx_create_chain_of_bufs (ngx_pool_t*,ngx_bufs_t*)"
3757,METHOD,core\ngx_buf.c:<global>,TYPE_DECL,"ngx_int_t
ngx_chain_add_copy(ngx_pool_t *pool, ngx_chain_t **chain, ngx_chain_t *in)
{
    ngx_chain_t  *cl, **ll;

    ll = chain;

    for (cl = *chain; cl; cl = cl->next) {
        ll = &cl->next;
    }

    while (in) {
        cl = ngx_alloc_chain_link(pool);
        if (cl == NULL) {
            *ll = NULL;
            return NGX_ERROR;
        }

        cl->buf = in->buf;
        *ll = cl;
        ll = &cl->next;
        in = in->next;
    }

    *ll = NULL;

    return NGX_OK;
}",1,1,core\ngx_buf.c,ngx_chain_add_copy,,false,126,153,ngx_chain_add_copy,,,4,"ngx_int_t ngx_chain_add_copy (ngx_pool_t*,ngx_chain_t**,ngx_chain_t*)"
3834,METHOD,core\ngx_buf.c:<global>,TYPE_DECL,"ngx_chain_t *
ngx_chain_get_free_buf(ngx_pool_t *p, ngx_chain_t **free)
{
    ngx_chain_t  *cl;

    if (*free) {
        cl = *free;
        *free = cl->next;
        cl->next = NULL;
        return cl;
    }

    cl = ngx_alloc_chain_link(p);
    if (cl == NULL) {
        return NULL;
    }

    cl->buf = ngx_calloc_buf(p);
    if (cl->buf == NULL) {
        return NULL;
    }

    cl->next = NULL;

    return cl;
}",1,1,core\ngx_buf.c,ngx_chain_get_free_buf,,false,156,181,ngx_chain_get_free_buf,,,5,"ngx_chain_t ngx_chain_get_free_buf (ngx_pool_t*,ngx_chain_t**)"
3895,METHOD,core\ngx_buf.c:<global>,TYPE_DECL,"void
ngx_chain_update_chains(ngx_pool_t *p, ngx_chain_t **free, ngx_chain_t **busy,
    ngx_chain_t **out, ngx_buf_tag_t tag)
{
    ngx_chain_t  *cl;

    if (*out) {
        if (*busy == NULL) {
            *busy = *out;

        } else {
            for (cl = *busy; cl->next; cl = cl->next) { /* void */ }

            cl->next = *out;
        }

        *out = NULL;
    }

    while (*busy) {
        cl = *busy;

        if (ngx_buf_size(cl->buf) != 0) {
            break;
        }

        if (cl->buf->tag != tag) {
            *busy = cl->next;
            ngx_free_chain(p, cl);
            continue;
        }

        cl->buf->pos = cl->buf->start;
        cl->buf->last = cl->buf->start;

        *busy = cl->next;
        cl->next = *free;
        *free = cl;
    }
}",1,1,core\ngx_buf.c,ngx_chain_update_chains,,false,184,223,ngx_chain_update_chains,,,6,"void ngx_chain_update_chains (ngx_pool_t*,ngx_chain_t**,ngx_chain_t**,ngx_chain_t**,ngx_buf_tag_t)"
4021,METHOD,core\ngx_buf.c:<global>,TYPE_DECL,"off_t
ngx_chain_coalesce_file(ngx_chain_t **in, off_t limit)
{
    off_t         total, size, aligned, fprev;
    ngx_fd_t      fd;
    ngx_chain_t  *cl;

    total = 0;

    cl = *in;
    fd = cl->buf->file->fd;

    do {
        size = cl->buf->file_last - cl->buf->file_pos;

        if (size > limit - total) {
            size = limit - total;

            aligned = (cl->buf->file_pos + size + ngx_pagesize - 1)
                       & ~((off_t) ngx_pagesize - 1);

            if (aligned <= cl->buf->file_last) {
                size = aligned - cl->buf->file_pos;
            }

            total += size;
            break;
        }

        total += size;
        fprev = cl->buf->file_pos + size;
        cl = cl->next;

    } while (cl
             && cl->buf->in_file
             && total < limit
             && fd == cl->buf->file->fd
             && fprev == cl->buf->file_pos);

    *in = cl;

    return total;
}",1,1,core\ngx_buf.c,ngx_chain_coalesce_file,,false,226,268,ngx_chain_coalesce_file,,,7,"off_t ngx_chain_coalesce_file (ngx_chain_t**,off_t)"
4170,METHOD,core\ngx_buf.c:<global>,TYPE_DECL,"ngx_chain_t *
ngx_chain_update_sent(ngx_chain_t *in, off_t sent)
{
    off_t  size;

    for ( /* void */ ; in; in = in->next) {

        if (ngx_buf_special(in->buf)) {
            continue;
        }

        if (sent == 0) {
            break;
        }

        size = ngx_buf_size(in->buf);

        if (sent >= size) {
            sent -= size;

            if (ngx_buf_in_memory(in->buf)) {
                in->buf->pos = in->buf->last;
            }

            if (in->buf->in_file) {
                in->buf->file_pos = in->buf->file_last;
            }

            continue;
        }

        if (ngx_buf_in_memory(in->buf)) {
            in->buf->pos += (size_t) sent;
        }

        if (in->buf->in_file) {
            in->buf->file_pos += sent;
        }

        break;
    }

    return in;
}",1,1,core\ngx_buf.c,ngx_chain_update_sent,,false,271,314,ngx_chain_update_sent,,,8,"ngx_chain_t ngx_chain_update_sent (ngx_chain_t*,off_t)"
4288,METHOD,core\ngx_buf.h:<global>,TYPE_DECL,<global>,1,33,core\ngx_buf.h,core\ngx_buf.h:<global>,,false,1,170,<global>,,,1,
4324,METHOD,core\ngx_buf.h:<global>,TYPE_DECL,"typedef ngx_int_t (*ngx_output_chain_filter_pt)(void *ctx, ngx_chain_t *in);",19,75,core\ngx_buf.h,ngx_output_chain_filter_pt,,false,73,73,ngx_output_chain_filter_pt,,,10,"ngx_int_t ngx_output_chain_filter_pt (void*,ngx_chain_t*)"
4330,METHOD,core\ngx_buf.h:<global>,TYPE_DECL,"typedef void (*ngx_output_chain_aio_pt)(ngx_output_chain_ctx_t *ctx,
    ngx_file_t *file);",14,21,core\ngx_buf.h,ngx_output_chain_aio_pt,,false,75,76,ngx_output_chain_aio_pt,,,11,"void ngx_output_chain_aio_pt (ngx_output_chain_ctx_t*,ngx_file_t*)"
4348,METHOD,ngx_output_chain_ctx_s,TYPE_DECL,ssize_t                    (*aio_preload)(ngx_buf_t *file);,32,62,core\ngx_buf.h,ngx_output_chain_ctx_s.aio_preload,,false,94,94,aio_preload,,,12,ssize_t ngx_output_chain_ctx_s.aio_preload (ngx_buf_t*)
4353,METHOD,ngx_output_chain_ctx_s,TYPE_DECL,"ngx_int_t                  (*thread_handler)(ngx_thread_task_t *task,
                                                 ngx_file_t *file);",32,66,core\ngx_buf.h,ngx_output_chain_ctx_s.thread_handler,,false,99,100,thread_handler,,,13,"ngx_int_t ngx_output_chain_ctx_s.thread_handler (ngx_thread_task_t*,ngx_file_t*)"
4374,METHOD,core\ngx_buf.h:<global>,TYPE_DECL,"ngx_buf_t *ngx_create_temp_buf(ngx_pool_t *pool, size_t size);",11,61,core\ngx_buf.h,ngx_create_temp_buf,,false,143,143,ngx_create_temp_buf,,,15,"ngx_buf_t* ngx_create_temp_buf (ngx_pool_t*,size_t)"
4380,METHOD,core\ngx_buf.h:<global>,TYPE_DECL,"ngx_chain_t *ngx_create_chain_of_bufs(ngx_pool_t *pool, ngx_bufs_t *bufs);",13,73,core\ngx_buf.h,ngx_create_chain_of_bufs,,false,144,144,ngx_create_chain_of_bufs,,,16,"ngx_chain_t* ngx_create_chain_of_bufs (ngx_pool_t*,ngx_bufs_t*)"
4386,METHOD,core\ngx_buf.h:<global>,TYPE_DECL,ngx_chain_t *ngx_alloc_chain_link(ngx_pool_t *pool);,13,51,core\ngx_buf.h,ngx_alloc_chain_link,,false,150,150,ngx_alloc_chain_link,,,17,ngx_chain_t* ngx_alloc_chain_link (ngx_pool_t*)
4391,METHOD,core\ngx_buf.h:<global>,TYPE_DECL,"ngx_int_t ngx_output_chain(ngx_output_chain_ctx_t *ctx, ngx_chain_t *in);",11,72,core\ngx_buf.h,ngx_output_chain,,false,157,157,ngx_output_chain,,,18,"ngx_int_t ngx_output_chain (ngx_output_chain_ctx_t*,ngx_chain_t*)"
4397,METHOD,core\ngx_buf.h:<global>,TYPE_DECL,"ngx_int_t ngx_chain_writer(void *ctx, ngx_chain_t *in);",11,54,core\ngx_buf.h,ngx_chain_writer,,false,158,158,ngx_chain_writer,,,19,"ngx_int_t ngx_chain_writer (void*,ngx_chain_t*)"
4403,METHOD,core\ngx_buf.h:<global>,TYPE_DECL,"ngx_int_t ngx_chain_add_copy(ngx_pool_t *pool, ngx_chain_t **chain,
    ngx_chain_t *in);",11,20,core\ngx_buf.h,ngx_chain_add_copy,,false,160,161,ngx_chain_add_copy,,,20,"ngx_int_t ngx_chain_add_copy (ngx_pool_t*,ngx_chain_t**,ngx_chain_t*)"
4410,METHOD,core\ngx_buf.h:<global>,TYPE_DECL,"ngx_chain_t *ngx_chain_get_free_buf(ngx_pool_t *p, ngx_chain_t **free);",13,70,core\ngx_buf.h,ngx_chain_get_free_buf,,false,162,162,ngx_chain_get_free_buf,,,21,"ngx_chain_t* ngx_chain_get_free_buf (ngx_pool_t*,ngx_chain_t**)"
4416,METHOD,core\ngx_buf.h:<global>,TYPE_DECL,"void ngx_chain_update_chains(ngx_pool_t *p, ngx_chain_t **free,
    ngx_chain_t **busy, ngx_chain_t **out, ngx_buf_tag_t tag);",6,61,core\ngx_buf.h,ngx_chain_update_chains,,false,163,164,ngx_chain_update_chains,,,22,"void ngx_chain_update_chains (ngx_pool_t*,ngx_chain_t**,ngx_chain_t**,ngx_chain_t**,ngx_buf_tag_t)"
4425,METHOD,core\ngx_buf.h:<global>,TYPE_DECL,"off_t ngx_chain_coalesce_file(ngx_chain_t **in, off_t limit);",7,60,core\ngx_buf.h,ngx_chain_coalesce_file,,false,166,166,ngx_chain_coalesce_file,,,23,"off_t ngx_chain_coalesce_file (ngx_chain_t**,off_t)"
4431,METHOD,core\ngx_buf.h:<global>,TYPE_DECL,"ngx_chain_t *ngx_chain_update_sent(ngx_chain_t *in, off_t sent);",13,63,core\ngx_buf.h,ngx_chain_update_sent,,false,168,168,ngx_chain_update_sent,,,24,"ngx_chain_t* ngx_chain_update_sent (ngx_chain_t*,off_t)"
4444,METHOD,core\ngx_conf_file.c:<global>,TYPE_DECL,<global>,1,30,core\ngx_conf_file.c,core\ngx_conf_file.c:<global>,,false,1,1486,<global>,,,1,
4446,METHOD,core\ngx_conf_file.c:<global>,TYPE_DECL,"static ngx_int_t ngx_conf_add_dump(ngx_conf_t *cf, ngx_str_t *filename);",18,71,core\ngx_conf_file.c,ngx_conf_add_dump,,false,13,13,ngx_conf_add_dump,,,1,"ngx_int_t ngx_conf_add_dump (ngx_conf_t*,ngx_str_t*)"
4452,METHOD,core\ngx_conf_file.c:<global>,TYPE_DECL,"static ngx_int_t ngx_conf_handler(ngx_conf_t *cf, ngx_int_t last);",18,65,core\ngx_conf_file.c,ngx_conf_handler,,false,14,14,ngx_conf_handler,,,2,"ngx_int_t ngx_conf_handler (ngx_conf_t*,ngx_int_t)"
4458,METHOD,core\ngx_conf_file.c:<global>,TYPE_DECL,static ngx_int_t ngx_conf_read_token(ngx_conf_t *cf);,18,52,core\ngx_conf_file.c,ngx_conf_read_token,,false,15,15,ngx_conf_read_token,,,3,ngx_int_t ngx_conf_read_token (ngx_conf_t*)
4463,METHOD,core\ngx_conf_file.c:<global>,TYPE_DECL,static void ngx_conf_flush_files(ngx_cycle_t *cycle);,13,52,core\ngx_conf_file.c,ngx_conf_flush_files,,false,16,16,ngx_conf_flush_files,,,4,void ngx_conf_flush_files (ngx_cycle_t*)
4511,METHOD,core\ngx_conf_file.c:<global>,TYPE_DECL,"char *
ngx_conf_param(ngx_conf_t *cf)
{
    char             *rv;
    ngx_str_t        *param;
    ngx_buf_t         b;
    ngx_conf_file_t   conf_file;

    param = &cf->cycle->conf_param;

    if (param->len == 0) {
        return NGX_CONF_OK;
    }

    ngx_memzero(&conf_file, sizeof(ngx_conf_file_t));

    ngx_memzero(&b, sizeof(ngx_buf_t));

    b.start = param->data;
    b.pos = param->data;
    b.last = param->data + param->len;
    b.end = b.last;
    b.temporary = 1;

    conf_file.file.fd = NGX_INVALID_FILE;
    conf_file.file.name.data = NULL;
    conf_file.line = 0;

    cf->conf_file = &conf_file;
    cf->conf_file->buffer = &b;

    rv = ngx_conf_parse(cf, NULL);

    cf->conf_file = NULL;

    return rv;
}",1,1,core\ngx_conf_file.c,ngx_conf_param,,false,62,98,ngx_conf_param,,,11,char* ngx_conf_param (ngx_conf_t*)
4631,METHOD,core\ngx_conf_file.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_conf_add_dump(ngx_conf_t *cf, ngx_str_t *filename)
{
    off_t             size;
    u_char           *p;
    uint32_t          hash;
    ngx_buf_t        *buf;
    ngx_str_node_t   *sn;
    ngx_conf_dump_t  *cd;

    hash = ngx_crc32_long(filename->data, filename->len);

    sn = ngx_str_rbtree_lookup(&cf->cycle->config_dump_rbtree, filename, hash);

    if (sn) {
        cf->conf_file->dump = NULL;
        return NGX_OK;
    }

    p = ngx_pstrdup(cf->cycle->pool, filename);
    if (p == NULL) {
        return NGX_ERROR;
    }

    cd = ngx_array_push(&cf->cycle->config_dump);
    if (cd == NULL) {
        return NGX_ERROR;
    }

    size = ngx_file_size(&cf->conf_file->file.info);

    buf = ngx_create_temp_buf(cf->cycle->pool, (size_t) size);
    if (buf == NULL) {
        return NGX_ERROR;
    }

    cd->name.data = p;
    cd->name.len = filename->len;
    cd->buffer = buf;

    cf->conf_file->dump = buf;

    sn = ngx_palloc(cf->temp_pool, sizeof(ngx_str_...",1,1,core\ngx_conf_file.c,ngx_conf_add_dump,,false,101,154,ngx_conf_add_dump,,,12,"ngx_int_t ngx_conf_add_dump (ngx_conf_t*,ngx_str_t*)"
4806,METHOD,core\ngx_conf_file.c:<global>,TYPE_DECL,"char *
ngx_conf_parse(ngx_conf_t *cf, ngx_str_t *filename)
{
    char             *rv;
    ngx_fd_t          fd;
    ngx_int_t         rc;
    ngx_buf_t         buf;
    ngx_conf_file_t  *prev, conf_file;
    enum {
        parse_file = 0,
        parse_block,
        parse_param
    } type;

#if (NGX_SUPPRESS_WARN)
    fd = NGX_INVALID_FILE;
    prev = NULL;
#endif

    if (filename) {

        /* open configuration file */

        fd = ngx_open_file(filename->data, NGX_FILE_RDONLY, NGX_FILE_OPEN, 0);

        if (fd == NGX_INVALID_FILE) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, ngx_errno,
                               ngx_open_file_n "" \""%s\"" failed"",
                               filename->data);
            return NGX_CONF_ERROR;
        }

        prev = cf->conf_file;

        cf->conf_file = &conf_file;

        if (ngx_fd_info(fd, &cf->conf_file->file.info) == NGX_FILE_ERROR) {
            ngx_log_error(NGX_LOG_EMERG, cf->log, ngx_errno,
                        ...",1,30,core\ngx_conf_file.c,ngx_conf_parse,,false,157,352,ngx_conf_parse,,,13,"char* ngx_conf_parse (ngx_conf_t*,ngx_str_t*)"
5198,METHOD,core\ngx_conf_file.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_conf_handler(ngx_conf_t *cf, ngx_int_t last)
{
    char           *rv;
    void           *conf, **confp;
    ngx_uint_t      i, found;
    ngx_str_t      *name;
    ngx_command_t  *cmd;

    name = cf->args->elts;

    found = 0;

    for (i = 0; cf->cycle->modules[i]; i++) {

        cmd = cf->cycle->modules[i]->commands;
        if (cmd == NULL) {
            continue;
        }

        for ( /* void */ ; cmd->name.len; cmd++) {

            if (name->len != cmd->name.len) {
                continue;
            }

            if (ngx_strcmp(name->data, cmd->name.data) != 0) {
                continue;
            }

            found = 1;

            if (cf->cycle->modules[i]->type != NGX_CONF_MODULE
                && cf->cycle->modules[i]->type != cf->module_type)
            {
                continue;
            }

            /* is the directive's location right ? */

            if (!(cmd->type & cf->cmd_type)) {
                continue;
          ...",1,1,core\ngx_conf_file.c,ngx_conf_handler,,false,355,499,ngx_conf_handler,,,14,"ngx_int_t ngx_conf_handler (ngx_conf_t*,ngx_int_t)"
5627,METHOD,core\ngx_conf_file.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_conf_read_token(ngx_conf_t *cf)
{
    u_char      *start, ch, *src, *dst;
    off_t        file_size;
    size_t       len;
    ssize_t      n, size;
    ngx_uint_t   found, need_space, last_space, sharp_comment, variable;
    ngx_uint_t   quoted, s_quoted, d_quoted, start_line;
    ngx_str_t   *word;
    ngx_buf_t   *b, *dump;

    found = 0;
    need_space = 0;
    last_space = 1;
    sharp_comment = 0;
    variable = 0;
    quoted = 0;
    s_quoted = 0;
    d_quoted = 0;

    cf->args->nelts = 0;
    b = cf->conf_file->buffer;
    dump = cf->conf_file->dump;
    start = b->pos;
    start_line = cf->conf_file->line;

    file_size = ngx_file_size(&cf->conf_file->file.info);

    for ( ;; ) {

        if (b->pos >= b->last) {

            if (cf->conf_file->file.offset >= file_size) {

                if (cf->args->nelts > 0 || !last_space) {

                    if (cf->conf_file->file.fd == NGX_INVALID_FILE) {
                        ngx_conf_log_error(NGX_LO...",1,23,core\ngx_conf_file.c,ngx_conf_read_token,,false,502,817,ngx_conf_read_token,,,15,ngx_int_t ngx_conf_read_token (ngx_conf_t*)
6443,METHOD,core\ngx_conf_file.c:<global>,TYPE_DECL,"char *
ngx_conf_include(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char        *rv;
    ngx_int_t    n;
    ngx_str_t   *value, file, name;
    ngx_glob_t   gl;

    value = cf->args->elts;
    file = value[1];

    ngx_log_debug1(NGX_LOG_DEBUG_CORE, cf->log, 0, ""include %s"", file.data);

    if (ngx_conf_full_name(cf->cycle, &file, 1) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    if (strpbrk((char *) file.data, ""*?["") == NULL) {

        ngx_log_debug1(NGX_LOG_DEBUG_CORE, cf->log, 0, ""include %s"", file.data);

        return ngx_conf_parse(cf, &file);
    }

    ngx_memzero(&gl, sizeof(ngx_glob_t));

    gl.pattern = file.data;
    gl.log = cf->log;
    gl.test = 1;

    if (ngx_open_glob(&gl) != NGX_OK) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, ngx_errno,
                           ngx_open_glob_n "" \""%s\"" failed"", file.data);
        return NGX_CONF_ERROR;
    }

    rv = NGX_CONF_OK;

    for ( ;; ) {
        n = ngx_read_glob(&gl, &name);

        if (...",1,1,core\ngx_conf_file.c,ngx_conf_include,,false,820,883,ngx_conf_include,,,16,"char* ngx_conf_include (ngx_conf_t*,ngx_command_t*,void*)"
6624,METHOD,core\ngx_conf_file.c:<global>,TYPE_DECL,"ngx_int_t
ngx_conf_full_name(ngx_cycle_t *cycle, ngx_str_t *name, ngx_uint_t conf_prefix)
{
    ngx_str_t  *prefix;

    prefix = conf_prefix ? &cycle->conf_prefix : &cycle->prefix;

    return ngx_get_full_name(cycle->pool, prefix, name);
}",1,1,core\ngx_conf_file.c,ngx_conf_full_name,,false,886,894,ngx_conf_full_name,,,17,"ngx_int_t ngx_conf_full_name (ngx_cycle_t*,ngx_str_t*,ngx_uint_t)"
6651,METHOD,core\ngx_conf_file.c:<global>,TYPE_DECL,"ngx_open_file_t *
ngx_conf_open_file(ngx_cycle_t *cycle, ngx_str_t *name)
{
    ngx_str_t         full;
    ngx_uint_t        i;
    ngx_list_part_t  *part;
    ngx_open_file_t  *file;

#if (NGX_SUPPRESS_WARN)
    ngx_str_null(&full);
#endif

    if (name->len) {
        full = *name;

        if (ngx_conf_full_name(cycle, &full, 0) != NGX_OK) {
            return NULL;
        }

        part = &cycle->open_files.part;
        file = part->elts;

        for (i = 0; /* void */ ; i++) {

            if (i >= part->nelts) {
                if (part->next == NULL) {
                    break;
                }
                part = part->next;
                file = part->elts;
                i = 0;
            }

            if (full.len != file[i].name.len) {
                continue;
            }

            if (ngx_strcmp(full.data, file[i].name.data) == 0) {
                return &file[i];
            }
        }
    }

    file = ngx_list_push(&cycle->open_files);
    if (f...",1,1,core\ngx_conf_file.c,ngx_conf_open_file,,false,897,958,ngx_conf_open_file,,,18,"ngx_open_file_t ngx_conf_open_file (ngx_cycle_t*,ngx_str_t*)"
6818,METHOD,core\ngx_conf_file.c:<global>,TYPE_DECL,"static void
ngx_conf_flush_files(ngx_cycle_t *cycle)
{
    ngx_uint_t        i;
    ngx_list_part_t  *part;
    ngx_open_file_t  *file;

    ngx_log_debug0(NGX_LOG_DEBUG_CORE, cycle->log, 0, ""flush files"");

    part = &cycle->open_files.part;
    file = part->elts;

    for (i = 0; /* void */ ; i++) {

        if (i >= part->nelts) {
            if (part->next == NULL) {
                break;
            }
            part = part->next;
            file = part->elts;
            i = 0;
        }

        if (file[i].flush) {
            file[i].flush(&file[i], cycle->log);
        }
    }
}",1,1,core\ngx_conf_file.c,ngx_conf_flush_files,,false,961,988,ngx_conf_flush_files,,,19,void ngx_conf_flush_files (ngx_cycle_t*)
6904,METHOD,core\ngx_conf_file.c:<global>,TYPE_DECL,"ngx_conf_log_error(ngx_uint_t level, ngx_conf_t *cf, ngx_err_t err,
    const char *fmt, ...)
{
    u_char   errstr[NGX_MAX_CONF_ERRSTR], *p, *last;
    va_list  args;

    last = errstr + NGX_MAX_CONF_ERRSTR;

    va_start(args, fmt);
    p = ngx_vslprintf(errstr, last, fmt, args);
    va_end(args);

    if (err) {
        p = ngx_log_errno(p, last, err);
    }

    if (cf->conf_file == NULL) {
        ngx_log_error(level, cf->log, 0, ""%*s"", p - errstr, errstr);
        return;
    }

    if (cf->conf_file->file.fd == NGX_INVALID_FILE) {
        ngx_log_error(level, cf->log, 0, ""%*s in command line"",
                      p - errstr, errstr);
        return;
    }

    ngx_log_error(level, cf->log, 0, ""%*s in %s:%ui"",
                  p - errstr, errstr,
                  cf->conf_file->file.name.data, cf->conf_file->line);
}",1,1,core\ngx_conf_file.c,ngx_conf_log_error,,false,992,1022,ngx_conf_log_error,,,22,"ANY ngx_conf_log_error (ngx_uint_t,ngx_conf_t*,ngx_err_t,char*...)"
7009,METHOD,core\ngx_conf_file.c:<global>,TYPE_DECL,"char *
ngx_conf_set_flag_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char  *p = conf;

    ngx_str_t        *value;
    ngx_flag_t       *fp;
    ngx_conf_post_t  *post;

    fp = (ngx_flag_t *) (p + cmd->offset);

    if (*fp != NGX_CONF_UNSET) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    if (ngx_strcasecmp(value[1].data, (u_char *) ""on"") == 0) {
        *fp = 1;

    } else if (ngx_strcasecmp(value[1].data, (u_char *) ""off"") == 0) {
        *fp = 0;

    } else {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                     ""invalid value \""%s\"" in \""%s\"" directive, ""
                     ""it must be \""on\"" or \""off\"""",
                     value[1].data, cmd->name.data);
        return NGX_CONF_ERROR;
    }

    if (cmd->post) {
        post = cmd->post;
        return post->post_handler(cf, post, fp);
    }

    return NGX_CONF_OK;
}",1,1,core\ngx_conf_file.c,ngx_conf_set_flag_slot,,false,1025,1062,ngx_conf_set_flag_slot,,,23,"char* ngx_conf_set_flag_slot (ngx_conf_t*,ngx_command_t*,void*)"
7122,METHOD,core\ngx_conf_file.c:<global>,TYPE_DECL,"char *
ngx_conf_set_str_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char  *p = conf;

    ngx_str_t        *field, *value;
    ngx_conf_post_t  *post;

    field = (ngx_str_t *) (p + cmd->offset);

    if (field->data) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    *field = value[1];

    if (cmd->post) {
        post = cmd->post;
        return post->post_handler(cf, post, field);
    }

    return NGX_CONF_OK;
}",1,1,core\ngx_conf_file.c,ngx_conf_set_str_slot,,false,1065,1089,ngx_conf_set_str_slot,,,24,"char* ngx_conf_set_str_slot (ngx_conf_t*,ngx_command_t*,void*)"
7185,METHOD,core\ngx_conf_file.c:<global>,TYPE_DECL,"char *
ngx_conf_set_str_array_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char  *p = conf;

    ngx_str_t         *value, *s;
    ngx_array_t      **a;
    ngx_conf_post_t   *post;

    a = (ngx_array_t **) (p + cmd->offset);

    if (*a == NGX_CONF_UNSET_PTR) {
        *a = ngx_array_create(cf->pool, 4, sizeof(ngx_str_t));
        if (*a == NULL) {
            return NGX_CONF_ERROR;
        }
    }

    s = ngx_array_push(*a);
    if (s == NULL) {
        return NGX_CONF_ERROR;
    }

    value = cf->args->elts;

    *s = value[1];

    if (cmd->post) {
        post = cmd->post;
        return post->post_handler(cf, post, s);
    }

    return NGX_CONF_OK;
}",1,1,core\ngx_conf_file.c,ngx_conf_set_str_array_slot,,false,1092,1125,ngx_conf_set_str_array_slot,,,25,"char* ngx_conf_set_str_array_slot (ngx_conf_t*,ngx_command_t*,void*)"
7278,METHOD,core\ngx_conf_file.c:<global>,TYPE_DECL,"char *
ngx_conf_set_keyval_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char  *p = conf;

    ngx_str_t         *value;
    ngx_array_t      **a;
    ngx_keyval_t      *kv;
    ngx_conf_post_t   *post;

    a = (ngx_array_t **) (p + cmd->offset);

    if (*a == NULL) {
        *a = ngx_array_create(cf->pool, 4, sizeof(ngx_keyval_t));
        if (*a == NULL) {
            return NGX_CONF_ERROR;
        }
    }

    kv = ngx_array_push(*a);
    if (kv == NULL) {
        return NGX_CONF_ERROR;
    }

    value = cf->args->elts;

    kv->key = value[1];
    kv->value = value[2];

    if (cmd->post) {
        post = cmd->post;
        return post->post_handler(cf, post, kv);
    }

    return NGX_CONF_OK;
}",1,1,core\ngx_conf_file.c,ngx_conf_set_keyval_slot,,false,1128,1163,ngx_conf_set_keyval_slot,,,26,"char* ngx_conf_set_keyval_slot (ngx_conf_t*,ngx_command_t*,void*)"
7379,METHOD,core\ngx_conf_file.c:<global>,TYPE_DECL,"char *
ngx_conf_set_num_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char  *p = conf;

    ngx_int_t        *np;
    ngx_str_t        *value;
    ngx_conf_post_t  *post;


    np = (ngx_int_t *) (p + cmd->offset);

    if (*np != NGX_CONF_UNSET) {
        return ""is duplicate"";
    }

    value = cf->args->elts;
    *np = ngx_atoi(value[1].data, value[1].len);
    if (*np == NGX_ERROR) {
        return ""invalid number"";
    }

    if (cmd->post) {
        post = cmd->post;
        return post->post_handler(cf, post, np);
    }

    return NGX_CONF_OK;
}",1,1,core\ngx_conf_file.c,ngx_conf_set_num_slot,,false,1166,1194,ngx_conf_set_num_slot,,,27,"char* ngx_conf_set_num_slot (ngx_conf_t*,ngx_command_t*,void*)"
7459,METHOD,core\ngx_conf_file.c:<global>,TYPE_DECL,"char *
ngx_conf_set_size_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char  *p = conf;

    size_t           *sp;
    ngx_str_t        *value;
    ngx_conf_post_t  *post;


    sp = (size_t *) (p + cmd->offset);
    if (*sp != NGX_CONF_UNSET_SIZE) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    *sp = ngx_parse_size(&value[1]);
    if (*sp == (size_t) NGX_ERROR) {
        return ""invalid value"";
    }

    if (cmd->post) {
        post = cmd->post;
        return post->post_handler(cf, post, sp);
    }

    return NGX_CONF_OK;
}",1,1,core\ngx_conf_file.c,ngx_conf_set_size_slot,,false,1197,1225,ngx_conf_set_size_slot,,,28,"char* ngx_conf_set_size_slot (ngx_conf_t*,ngx_command_t*,void*)"
7535,METHOD,core\ngx_conf_file.c:<global>,TYPE_DECL,"char *
ngx_conf_set_off_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char  *p = conf;

    off_t            *op;
    ngx_str_t        *value;
    ngx_conf_post_t  *post;


    op = (off_t *) (p + cmd->offset);
    if (*op != NGX_CONF_UNSET) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    *op = ngx_parse_offset(&value[1]);
    if (*op == (off_t) NGX_ERROR) {
        return ""invalid value"";
    }

    if (cmd->post) {
        post = cmd->post;
        return post->post_handler(cf, post, op);
    }

    return NGX_CONF_OK;
}",1,1,core\ngx_conf_file.c,ngx_conf_set_off_slot,,false,1228,1256,ngx_conf_set_off_slot,,,29,"char* ngx_conf_set_off_slot (ngx_conf_t*,ngx_command_t*,void*)"
7611,METHOD,core\ngx_conf_file.c:<global>,TYPE_DECL,"char *
ngx_conf_set_msec_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char  *p = conf;

    ngx_msec_t       *msp;
    ngx_str_t        *value;
    ngx_conf_post_t  *post;


    msp = (ngx_msec_t *) (p + cmd->offset);
    if (*msp != NGX_CONF_UNSET_MSEC) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    *msp = ngx_parse_time(&value[1], 0);
    if (*msp == (ngx_msec_t) NGX_ERROR) {
        return ""invalid value"";
    }

    if (cmd->post) {
        post = cmd->post;
        return post->post_handler(cf, post, msp);
    }

    return NGX_CONF_OK;
}",1,1,core\ngx_conf_file.c,ngx_conf_set_msec_slot,,false,1259,1287,ngx_conf_set_msec_slot,,,30,"char* ngx_conf_set_msec_slot (ngx_conf_t*,ngx_command_t*,void*)"
7688,METHOD,core\ngx_conf_file.c:<global>,TYPE_DECL,"char *
ngx_conf_set_sec_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char  *p = conf;

    time_t           *sp;
    ngx_str_t        *value;
    ngx_conf_post_t  *post;


    sp = (time_t *) (p + cmd->offset);
    if (*sp != NGX_CONF_UNSET) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    *sp = ngx_parse_time(&value[1], 1);
    if (*sp == (time_t) NGX_ERROR) {
        return ""invalid value"";
    }

    if (cmd->post) {
        post = cmd->post;
        return post->post_handler(cf, post, sp);
    }

    return NGX_CONF_OK;
}",1,1,core\ngx_conf_file.c,ngx_conf_set_sec_slot,,false,1290,1318,ngx_conf_set_sec_slot,,,31,"char* ngx_conf_set_sec_slot (ngx_conf_t*,ngx_command_t*,void*)"
7765,METHOD,core\ngx_conf_file.c:<global>,TYPE_DECL,"char *
ngx_conf_set_bufs_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char *p = conf;

    ngx_str_t   *value;
    ngx_bufs_t  *bufs;


    bufs = (ngx_bufs_t *) (p + cmd->offset);
    if (bufs->num) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    bufs->num = ngx_atoi(value[1].data, value[1].len);
    if (bufs->num == NGX_ERROR || bufs->num == 0) {
        return ""invalid value"";
    }

    bufs->size = ngx_parse_size(&value[2]);
    if (bufs->size == (size_t) NGX_ERROR || bufs->size == 0) {
        return ""invalid value"";
    }

    return NGX_CONF_OK;
}",1,1,core\ngx_conf_file.c,ngx_conf_set_bufs_slot,,false,1321,1348,ngx_conf_set_bufs_slot,,,32,"char* ngx_conf_set_bufs_slot (ngx_conf_t*,ngx_command_t*,void*)"
7859,METHOD,core\ngx_conf_file.c:<global>,TYPE_DECL,"char *
ngx_conf_set_enum_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char  *p = conf;

    ngx_uint_t       *np, i;
    ngx_str_t        *value;
    ngx_conf_enum_t  *e;

    np = (ngx_uint_t *) (p + cmd->offset);

    if (*np != NGX_CONF_UNSET_UINT) {
        return ""is duplicate"";
    }

    value = cf->args->elts;
    e = cmd->post;

    for (i = 0; e[i].name.len != 0; i++) {
        if (e[i].name.len != value[1].len
            || ngx_strcasecmp(e[i].name.data, value[1].data) != 0)
        {
            continue;
        }

        *np = e[i].value;

        return NGX_CONF_OK;
    }

    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                       ""invalid value \""%s\"""", value[1].data);

    return NGX_CONF_ERROR;
}",1,1,core\ngx_conf_file.c,ngx_conf_set_enum_slot,,false,1351,1385,ngx_conf_set_enum_slot,,,33,"char* ngx_conf_set_enum_slot (ngx_conf_t*,ngx_command_t*,void*)"
7974,METHOD,core\ngx_conf_file.c:<global>,TYPE_DECL,"char *
ngx_conf_set_bitmask_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char  *p = conf;

    ngx_uint_t          *np, i, m;
    ngx_str_t           *value;
    ngx_conf_bitmask_t  *mask;


    np = (ngx_uint_t *) (p + cmd->offset);
    value = cf->args->elts;
    mask = cmd->post;

    for (i = 1; i < cf->args->nelts; i++) {
        for (m = 0; mask[m].name.len != 0; m++) {

            if (mask[m].name.len != value[i].len
                || ngx_strcasecmp(mask[m].name.data, value[i].data) != 0)
            {
                continue;
            }

            if (*np & mask[m].mask) {
                ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
                                   ""duplicate value \""%s\"""", value[i].data);

            } else {
                *np |= mask[m].mask;
            }

            break;
        }

        if (mask[m].name.len == 0) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               ""invalid value \""%s\"""", value...",1,1,core\ngx_conf_file.c,ngx_conf_set_bitmask_slot,,false,1388,1431,ngx_conf_set_bitmask_slot,,,34,"char* ngx_conf_set_bitmask_slot (ngx_conf_t*,ngx_command_t*,void*)"
8131,METHOD,core\ngx_conf_file.c:<global>,TYPE_DECL,"char *
ngx_conf_deprecated(ngx_conf_t *cf, void *post, void *data)
{
    ngx_conf_deprecated_t  *d = post;

    ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
                       ""the \""%s\"" directive is deprecated, ""
                       ""use the \""%s\"" directive instead"",
                       d->old_name, d->new_name);

    return NGX_CONF_OK;
}",1,1,core\ngx_conf_file.c,ngx_conf_deprecated,,false,1445,1456,ngx_conf_deprecated,,,35,"char* ngx_conf_deprecated (ngx_conf_t*,void*,void*)"
8155,METHOD,core\ngx_conf_file.c:<global>,TYPE_DECL,"char *
ngx_conf_check_num_bounds(ngx_conf_t *cf, void *post, void *data)
{
    ngx_conf_num_bounds_t  *bounds = post;
    ngx_int_t  *np = data;

    if (bounds->high == -1) {
        if (*np >= bounds->low) {
            return NGX_CONF_OK;
        }

        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""value must be equal to or greater than %i"",
                           bounds->low);

        return NGX_CONF_ERROR;
    }

    if (*np >= bounds->low && *np <= bounds->high) {
        return NGX_CONF_OK;
    }

    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                       ""value must be between %i and %i"",
                       bounds->low, bounds->high);

    return NGX_CONF_ERROR;
}",1,1,core\ngx_conf_file.c,ngx_conf_check_num_bounds,,false,1459,1486,ngx_conf_check_num_bounds,,,36,"char* ngx_conf_check_num_bounds (ngx_conf_t*,void*,void*)"
8235,METHOD,core\ngx_conf_file.h:<global>,TYPE_DECL,<global>,1,39,core\ngx_conf_file.h,core\ngx_conf_file.h:<global>,,false,1,295,<global>,,,1,
8240,METHOD,ngx_command_s,TYPE_DECL,"char               *(*set)(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",24,78,core\ngx_conf_file.h,ngx_command_s.set,,false,80,80,set,,,3,"char* ngx_command_s.set (ngx_conf_t*,ngx_command_t*,void*)"
8253,METHOD,ngx_open_file_s,TYPE_DECL,"void                (*flush)(ngx_open_file_t *file, ngx_log_t *log);",25,71,core\ngx_conf_file.h,ngx_open_file_s.flush,,false,93,93,flush,,,3,"void ngx_open_file_s.flush (ngx_open_file_t*,ngx_log_t*)"
8270,METHOD,core\ngx_conf_file.h:<global>,TYPE_DECL,"typedef char *(*ngx_conf_handler_pt)(ngx_conf_t *cf,
    ngx_command_t *dummy, void *conf);",14,37,core\ngx_conf_file.h,ngx_conf_handler_pt,,false,112,113,ngx_conf_handler_pt,,,7,"char* ngx_conf_handler_pt (ngx_conf_t*,ngx_command_t*,void*)"
8290,METHOD,core\ngx_conf_file.h:<global>,TYPE_DECL,"typedef char *(*ngx_conf_post_handler_pt) (ngx_conf_t *cf,
    void *data, void *conf);",14,27,core\ngx_conf_file.h,ngx_conf_post_handler_pt,,false,135,136,ngx_conf_post_handler_pt,,,9,"char* ngx_conf_post_handler_pt (ngx_conf_t*,void*,void*)"
8318,METHOD,core\ngx_conf_file.h:<global>,TYPE_DECL,"char * ngx_conf_deprecated(ngx_conf_t *cf, void *post, void *data);",6,66,core\ngx_conf_file.h,ngx_conf_deprecated,,false,172,172,ngx_conf_deprecated,,,20,"char* ngx_conf_deprecated (ngx_conf_t*,void*,void*)"
8325,METHOD,core\ngx_conf_file.h:<global>,TYPE_DECL,"char *ngx_conf_check_num_bounds(ngx_conf_t *cf, void *post, void *data);",6,71,core\ngx_conf_file.h,ngx_conf_check_num_bounds,,false,173,173,ngx_conf_check_num_bounds,,,21,"char* ngx_conf_check_num_bounds (ngx_conf_t*,void*,void*)"
8332,METHOD,core\ngx_conf_file.h:<global>,TYPE_DECL,char *ngx_conf_param(ngx_conf_t *cf);,6,36,core\ngx_conf_file.h,ngx_conf_param,,false,268,268,ngx_conf_param,,,22,char* ngx_conf_param (ngx_conf_t*)
8337,METHOD,core\ngx_conf_file.h:<global>,TYPE_DECL,"char *ngx_conf_parse(ngx_conf_t *cf, ngx_str_t *filename);",6,57,core\ngx_conf_file.h,ngx_conf_parse,,false,269,269,ngx_conf_parse,,,23,"char* ngx_conf_parse (ngx_conf_t*,ngx_str_t*)"
8343,METHOD,core\ngx_conf_file.h:<global>,TYPE_DECL,"char *ngx_conf_include(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",6,70,core\ngx_conf_file.h,ngx_conf_include,,false,270,270,ngx_conf_include,,,24,"char* ngx_conf_include (ngx_conf_t*,ngx_command_t*,void*)"
8350,METHOD,core\ngx_conf_file.h:<global>,TYPE_DECL,"ngx_int_t ngx_conf_full_name(ngx_cycle_t *cycle, ngx_str_t *name,
    ngx_uint_t conf_prefix);",11,27,core\ngx_conf_file.h,ngx_conf_full_name,,false,273,274,ngx_conf_full_name,,,25,"ngx_int_t ngx_conf_full_name (ngx_cycle_t*,ngx_str_t*,ngx_uint_t)"
8357,METHOD,core\ngx_conf_file.h:<global>,TYPE_DECL,"ngx_open_file_t *ngx_conf_open_file(ngx_cycle_t *cycle, ngx_str_t *name);",17,72,core\ngx_conf_file.h,ngx_conf_open_file,,false,275,275,ngx_conf_open_file,,,26,"ngx_open_file_t* ngx_conf_open_file (ngx_cycle_t*,ngx_str_t*)"
8364,METHOD,core\ngx_conf_file.h:<global>,TYPE_DECL,"char *ngx_conf_set_flag_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",6,76,core\ngx_conf_file.h,ngx_conf_set_flag_slot,,false,280,280,ngx_conf_set_flag_slot,,,28,"char* ngx_conf_set_flag_slot (ngx_conf_t*,ngx_command_t*,void*)"
8371,METHOD,core\ngx_conf_file.h:<global>,TYPE_DECL,"char *ngx_conf_set_str_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",6,75,core\ngx_conf_file.h,ngx_conf_set_str_slot,,false,281,281,ngx_conf_set_str_slot,,,29,"char* ngx_conf_set_str_slot (ngx_conf_t*,ngx_command_t*,void*)"
8378,METHOD,core\ngx_conf_file.h:<global>,TYPE_DECL,"char *ngx_conf_set_str_array_slot(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",6,15,core\ngx_conf_file.h,ngx_conf_set_str_array_slot,,false,282,283,ngx_conf_set_str_array_slot,,,30,"char* ngx_conf_set_str_array_slot (ngx_conf_t*,ngx_command_t*,void*)"
8385,METHOD,core\ngx_conf_file.h:<global>,TYPE_DECL,"char *ngx_conf_set_keyval_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",6,78,core\ngx_conf_file.h,ngx_conf_set_keyval_slot,,false,284,284,ngx_conf_set_keyval_slot,,,31,"char* ngx_conf_set_keyval_slot (ngx_conf_t*,ngx_command_t*,void*)"
8392,METHOD,core\ngx_conf_file.h:<global>,TYPE_DECL,"char *ngx_conf_set_num_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",6,75,core\ngx_conf_file.h,ngx_conf_set_num_slot,,false,285,285,ngx_conf_set_num_slot,,,32,"char* ngx_conf_set_num_slot (ngx_conf_t*,ngx_command_t*,void*)"
8399,METHOD,core\ngx_conf_file.h:<global>,TYPE_DECL,"char *ngx_conf_set_size_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",6,76,core\ngx_conf_file.h,ngx_conf_set_size_slot,,false,286,286,ngx_conf_set_size_slot,,,33,"char* ngx_conf_set_size_slot (ngx_conf_t*,ngx_command_t*,void*)"
8406,METHOD,core\ngx_conf_file.h:<global>,TYPE_DECL,"char *ngx_conf_set_off_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",6,75,core\ngx_conf_file.h,ngx_conf_set_off_slot,,false,287,287,ngx_conf_set_off_slot,,,34,"char* ngx_conf_set_off_slot (ngx_conf_t*,ngx_command_t*,void*)"
8413,METHOD,core\ngx_conf_file.h:<global>,TYPE_DECL,"char *ngx_conf_set_msec_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",6,76,core\ngx_conf_file.h,ngx_conf_set_msec_slot,,false,288,288,ngx_conf_set_msec_slot,,,35,"char* ngx_conf_set_msec_slot (ngx_conf_t*,ngx_command_t*,void*)"
8420,METHOD,core\ngx_conf_file.h:<global>,TYPE_DECL,"char *ngx_conf_set_sec_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",6,75,core\ngx_conf_file.h,ngx_conf_set_sec_slot,,false,289,289,ngx_conf_set_sec_slot,,,36,"char* ngx_conf_set_sec_slot (ngx_conf_t*,ngx_command_t*,void*)"
8427,METHOD,core\ngx_conf_file.h:<global>,TYPE_DECL,"char *ngx_conf_set_bufs_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",6,76,core\ngx_conf_file.h,ngx_conf_set_bufs_slot,,false,290,290,ngx_conf_set_bufs_slot,,,37,"char* ngx_conf_set_bufs_slot (ngx_conf_t*,ngx_command_t*,void*)"
8434,METHOD,core\ngx_conf_file.h:<global>,TYPE_DECL,"char *ngx_conf_set_enum_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",6,76,core\ngx_conf_file.h,ngx_conf_set_enum_slot,,false,291,291,ngx_conf_set_enum_slot,,,38,"char* ngx_conf_set_enum_slot (ngx_conf_t*,ngx_command_t*,void*)"
8441,METHOD,core\ngx_conf_file.h:<global>,TYPE_DECL,"char *ngx_conf_set_bitmask_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",6,79,core\ngx_conf_file.h,ngx_conf_set_bitmask_slot,,false,292,292,ngx_conf_set_bitmask_slot,,,39,"char* ngx_conf_set_bitmask_slot (ngx_conf_t*,ngx_command_t*,void*)"
8465,METHOD,core\ngx_config.h:<global>,TYPE_DECL,<global>,1,36,core\ngx_config.h,core\ngx_config.h:<global>,,false,1,145,<global>,,,1,
8479,METHOD,core\ngx_connection.c:<global>,TYPE_DECL,<global>,1,1,core\ngx_connection.c,core\ngx_connection.c:<global>,,false,1,1510,<global>,,,1,
8482,METHOD,core\ngx_connection.c:<global>,TYPE_DECL,static void ngx_drain_connections(ngx_cycle_t *cycle);,13,53,core\ngx_connection.c,ngx_drain_connections,,false,16,16,ngx_drain_connections,,,2,void ngx_drain_connections (ngx_cycle_t*)
8487,METHOD,core\ngx_connection.c:<global>,TYPE_DECL,"ngx_listening_t *
ngx_create_listening(ngx_conf_t *cf, struct sockaddr *sockaddr,
    socklen_t socklen)
{
    size_t            len;
    ngx_listening_t  *ls;
    struct sockaddr  *sa;
    u_char            text[NGX_SOCKADDR_STRLEN];

    ls = ngx_array_push(&cf->cycle->listening);
    if (ls == NULL) {
        return NULL;
    }

    ngx_memzero(ls, sizeof(ngx_listening_t));

    sa = ngx_palloc(cf->pool, socklen);
    if (sa == NULL) {
        return NULL;
    }

    ngx_memcpy(sa, sockaddr, socklen);

    ls->sockaddr = sa;
    ls->socklen = socklen;

    len = ngx_sock_ntop(sa, socklen, text, NGX_SOCKADDR_STRLEN, 1);
    ls->addr_text.len = len;

    switch (ls->sockaddr->sa_family) {
#if (NGX_HAVE_INET6)
    case AF_INET6:
        ls->addr_text_max_len = NGX_INET6_ADDRSTRLEN;
        break;
#endif
#if (NGX_HAVE_UNIX_DOMAIN)
    case AF_UNIX:
        ls->addr_text_max_len = NGX_UNIX_ADDRSTRLEN;
        len++;
        break;
#endif
    case AF_INET:
        ls->addr_text_max_len...",1,1,core\ngx_connection.c,ngx_create_listening,,false,19,95,ngx_create_listening,,,3,"ngx_listening_t ngx_create_listening (ngx_conf_t*,sockaddr*,socklen_t)"
8654,METHOD,core\ngx_connection.c:<global>,TYPE_DECL,"ngx_int_t
ngx_clone_listening(ngx_cycle_t *cycle, ngx_listening_t *ls)
{
#if (NGX_HAVE_REUSEPORT)

    ngx_int_t         n;
    ngx_core_conf_t  *ccf;
    ngx_listening_t   ols;

    if (!ls->reuseport || ls->worker != 0) {
        return NGX_OK;
    }

    ols = *ls;

    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);

    for (n = 1; n < ccf->worker_processes; n++) {

        /* create a socket for each worker process */

        ls = ngx_array_push(&cycle->listening);
        if (ls == NULL) {
            return NGX_ERROR;
        }

        *ls = ols;
        ls->worker = n;
    }

#endif

    return NGX_OK;
}",1,1,core\ngx_connection.c,ngx_clone_listening,,false,98,131,ngx_clone_listening,,,4,"ngx_int_t ngx_clone_listening (ngx_cycle_t*,ngx_listening_t*)"
8662,METHOD,core\ngx_connection.c:<global>,TYPE_DECL,"ngx_int_t
ngx_set_inherited_sockets(ngx_cycle_t *cycle)
{
    size_t                     len;
    ngx_uint_t                 i;
    ngx_listening_t           *ls;
    socklen_t                  olen;
#if (NGX_HAVE_DEFERRED_ACCEPT || NGX_HAVE_TCP_FASTOPEN)
    ngx_err_t                  err;
#endif
#if (NGX_HAVE_DEFERRED_ACCEPT && defined SO_ACCEPTFILTER)
    struct accept_filter_arg   af;
#endif
#if (NGX_HAVE_DEFERRED_ACCEPT && defined TCP_DEFER_ACCEPT)
    int                        timeout;
#endif
#if (NGX_HAVE_REUSEPORT)
    int                        reuseport;
#endif

    ls = cycle->listening.elts;
    for (i = 0; i < cycle->listening.nelts; i++) {

        ls[i].sockaddr = ngx_palloc(cycle->pool, sizeof(ngx_sockaddr_t));
        if (ls[i].sockaddr == NULL) {
            return NGX_ERROR;
        }

        ls[i].socklen = sizeof(ngx_sockaddr_t);
        if (getsockname(ls[i].fd, ls[i].sockaddr, &ls[i].socklen) == -1) {
            ngx_log_error(NGX_LOG_CRIT, cycle->log, ngx_s...",1,1,core\ngx_connection.c,ngx_set_inherited_sockets,,false,134,403,ngx_set_inherited_sockets,,,5,ngx_int_t ngx_set_inherited_sockets (ngx_cycle_t*)
9061,METHOD,core\ngx_connection.c:<global>,TYPE_DECL,"ngx_int_t
ngx_open_listening_sockets(ngx_cycle_t *cycle)
{
    int               reuseaddr;
    ngx_uint_t        i, tries, failed;
    ngx_err_t         err;
    ngx_log_t        *log;
    ngx_socket_t      s;
    ngx_listening_t  *ls;

    reuseaddr = 1;
#if (NGX_SUPPRESS_WARN)
    failed = 0;
#endif

    log = cycle->log;

    /* TODO: configurable try number */

    for (tries = 5; tries; tries--) {
        failed = 0;

        /* for each listening socket */

        ls = cycle->listening.elts;
        for (i = 0; i < cycle->listening.nelts; i++) {

            if (ls[i].ignore) {
                continue;
            }

#if (NGX_HAVE_REUSEPORT)

            if (ls[i].add_reuseport) {

                /*
                 * to allow transition from a socket without SO_REUSEPORT
                 * to multiple sockets with SO_REUSEPORT, we have to set
                 * SO_REUSEPORT on the old socket before opening new ones
                 */

                int  reuseport = 1;
...",1,1,core\ngx_connection.c,ngx_open_listening_sockets,,false,406,709,ngx_open_listening_sockets,,,6,ngx_int_t ngx_open_listening_sockets (ngx_cycle_t*)
9421,METHOD,core\ngx_connection.c:<global>,TYPE_DECL,"void
ngx_configure_listening_sockets(ngx_cycle_t *cycle)
{
    int                        value;
    ngx_uint_t                 i;
    ngx_listening_t           *ls;

#if (NGX_HAVE_DEFERRED_ACCEPT && defined SO_ACCEPTFILTER)
    struct accept_filter_arg   af;
#endif

    ls = cycle->listening.elts;
    for (i = 0; i < cycle->listening.nelts; i++) {

        ls[i].log = *ls[i].logp;

        if (ls[i].rcvbuf != -1) {
            if (setsockopt(ls[i].fd, SOL_SOCKET, SO_RCVBUF,
                           (const void *) &ls[i].rcvbuf, sizeof(int))
                == -1)
            {
                ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_socket_errno,
                              ""setsockopt(SO_RCVBUF, %d) %V failed, ignored"",
                              ls[i].rcvbuf, &ls[i].addr_text);
            }
        }

        if (ls[i].sndbuf != -1) {
            if (setsockopt(ls[i].fd, SOL_SOCKET, SO_SNDBUF,
                           (const void *) &ls[i].sndbuf, sizeof(int))
     ...",1,1,core\ngx_connection.c,ngx_configure_listening_sockets,,false,712,1017,ngx_configure_listening_sockets,,,7,void ngx_configure_listening_sockets (ngx_cycle_t*)
9659,METHOD,core\ngx_connection.c:<global>,TYPE_DECL,"void
ngx_close_listening_sockets(ngx_cycle_t *cycle)
{
    ngx_uint_t         i;
    ngx_listening_t   *ls;
    ngx_connection_t  *c;

    if (ngx_event_flags & NGX_USE_IOCP_EVENT) {
        return;
    }

    ngx_accept_mutex_held = 0;
    ngx_use_accept_mutex = 0;

    ls = cycle->listening.elts;
    for (i = 0; i < cycle->listening.nelts; i++) {

        c = ls[i].connection;

        if (c) {
            if (c->read->active) {
                if (ngx_event_flags & NGX_USE_EPOLL_EVENT) {

                    /*
                     * it seems that Linux-2.6.x OpenVZ sends events
                     * for closed shared listening sockets unless
                     * the events was explicitly deleted
                     */

                    ngx_del_event(c->read, NGX_READ_EVENT, 0);

                } else {
                    ngx_del_event(c->read, NGX_READ_EVENT, NGX_CLOSE_EVENT);
                }
            }

            ngx_free_connection(c);

            c->fd = (ngx...",1,1,core\ngx_connection.c,ngx_close_listening_sockets,,false,1020,1089,ngx_close_listening_sockets,,,8,void ngx_close_listening_sockets (ngx_cycle_t*)
9792,METHOD,core\ngx_connection.c:<global>,TYPE_DECL,"ngx_connection_t *
ngx_get_connection(ngx_socket_t s, ngx_log_t *log)
{
    ngx_uint_t         instance;
    ngx_event_t       *rev, *wev;
    ngx_connection_t  *c;

    /* disable warning: Win32 SOCKET is u_int while UNIX socket is int */

    if (ngx_cycle->files && (ngx_uint_t) s >= ngx_cycle->files_n) {
        ngx_log_error(NGX_LOG_ALERT, log, 0,
                      ""the new socket has number %d, ""
                      ""but only %ui files are available"",
                      s, ngx_cycle->files_n);
        return NULL;
    }

    c = ngx_cycle->free_connections;

    if (c == NULL) {
        ngx_drain_connections((ngx_cycle_t *) ngx_cycle);
        c = ngx_cycle->free_connections;
    }

    if (c == NULL) {
        ngx_log_error(NGX_LOG_ALERT, log, 0,
                      ""%ui worker_connections are not enough"",
                      ngx_cycle->connection_n);

        return NULL;
    }

    ngx_cycle->free_connections = c->data;
    ngx_cycle->free_connection_n--;

    i...",1,1,core\ngx_connection.c,ngx_get_connection,,false,1092,1158,ngx_get_connection,,,9,"ngx_connection_t ngx_get_connection (ngx_socket_t,ngx_log_t*)"
9977,METHOD,core\ngx_connection.c:<global>,TYPE_DECL,"void
ngx_free_connection(ngx_connection_t *c)
{
    c->data = ngx_cycle->free_connections;
    ngx_cycle->free_connections = c;
    ngx_cycle->free_connection_n++;

    if (ngx_cycle->files && ngx_cycle->files[c->fd] == c) {
        ngx_cycle->files[c->fd] = NULL;
    }
}",1,1,core\ngx_connection.c,ngx_free_connection,,false,1161,1171,ngx_free_connection,,,10,void ngx_free_connection (ngx_connection_t*)
10022,METHOD,core\ngx_connection.c:<global>,TYPE_DECL,"void
ngx_close_connection(ngx_connection_t *c)
{
    ngx_err_t     err;
    ngx_uint_t    log_error, level;
    ngx_socket_t  fd;

    if (c->fd == (ngx_socket_t) -1) {
        ngx_log_error(NGX_LOG_ALERT, c->log, 0, ""connection already closed"");
        return;
    }

    if (c->read->timer_set) {
        ngx_del_timer(c->read);
    }

    if (c->write->timer_set) {
        ngx_del_timer(c->write);
    }

    if (!c->shared) {
        if (ngx_del_conn) {
            ngx_del_conn(c, NGX_CLOSE_EVENT);

        } else {
            if (c->read->active || c->read->disabled) {
                ngx_del_event(c->read, NGX_READ_EVENT, NGX_CLOSE_EVENT);
            }

            if (c->write->active || c->write->disabled) {
                ngx_del_event(c->write, NGX_WRITE_EVENT, NGX_CLOSE_EVENT);
            }
        }
    }

    if (c->read->posted) {
        ngx_delete_posted_event(c->read);
    }

    if (c->write->posted) {
        ngx_delete_posted_event(c->write);
    }

    c->read...",1,1,core\ngx_connection.c,ngx_close_connection,,false,1174,1259,ngx_close_connection,,,11,void ngx_close_connection (ngx_connection_t*)
10230,METHOD,core\ngx_connection.c:<global>,TYPE_DECL,"void
ngx_reusable_connection(ngx_connection_t *c, ngx_uint_t reusable)
{
    ngx_log_debug1(NGX_LOG_DEBUG_CORE, c->log, 0,
                   ""reusable connection: %ui"", reusable);

    if (c->reusable) {
        ngx_queue_remove(&c->queue);
        ngx_cycle->reusable_connections_n--;

#if (NGX_STAT_STUB)
        (void) ngx_atomic_fetch_add(ngx_stat_waiting, -1);
#endif
    }

    c->reusable = reusable;

    if (reusable) {
        /* need cast as ngx_cycle is volatile */

        ngx_queue_insert_head(
            (ngx_queue_t *) &ngx_cycle->reusable_connections_queue, &c->queue);
        ngx_cycle->reusable_connections_n++;

#if (NGX_STAT_STUB)
        (void) ngx_atomic_fetch_add(ngx_stat_waiting, 1);
#endif
    }
}",1,1,core\ngx_connection.c,ngx_reusable_connection,,false,1262,1290,ngx_reusable_connection,,,12,"void ngx_reusable_connection (ngx_connection_t*,ngx_uint_t)"
10281,METHOD,core\ngx_connection.c:<global>,TYPE_DECL,"static void
ngx_drain_connections(ngx_cycle_t *cycle)
{
    ngx_uint_t         i, n;
    ngx_queue_t       *q;
    ngx_connection_t  *c;

    n = ngx_max(ngx_min(32, cycle->reusable_connections_n / 8), 1);

    for (i = 0; i < n; i++) {
        if (ngx_queue_empty(&cycle->reusable_connections_queue)) {
            break;
        }

        q = ngx_queue_last(&cycle->reusable_connections_queue);
        c = ngx_queue_data(q, ngx_connection_t, queue);

        ngx_log_debug0(NGX_LOG_DEBUG_CORE, c->log, 0,
                       ""reusing connection"");

        c->close = 1;
        c->read->handler(c->read);
    }
}",1,1,core\ngx_connection.c,ngx_drain_connections,,false,1293,1316,ngx_drain_connections,,,13,void ngx_drain_connections (ngx_cycle_t*)
10354,METHOD,core\ngx_connection.c:<global>,TYPE_DECL,"void
ngx_close_idle_connections(ngx_cycle_t *cycle)
{
    ngx_uint_t         i;
    ngx_connection_t  *c;

    c = cycle->connections;

    for (i = 0; i < cycle->connection_n; i++) {

        /* THREAD: lock */

        if (c[i].fd != (ngx_socket_t) -1 && c[i].idle) {
            c[i].close = 1;
            c[i].read->handler(c[i].read);
        }
    }
}",1,1,core\ngx_connection.c,ngx_close_idle_connections,,false,1319,1336,ngx_close_idle_connections,,,14,void ngx_close_idle_connections (ngx_cycle_t*)
10416,METHOD,core\ngx_connection.c:<global>,TYPE_DECL,"ngx_int_t
ngx_connection_local_sockaddr(ngx_connection_t *c, ngx_str_t *s,
    ngx_uint_t port)
{
    socklen_t             len;
    ngx_uint_t            addr;
    ngx_sockaddr_t        sa;
    struct sockaddr_in   *sin;
#if (NGX_HAVE_INET6)
    ngx_uint_t            i;
    struct sockaddr_in6  *sin6;
#endif

    addr = 0;

    if (c->local_socklen) {
        switch (c->local_sockaddr->sa_family) {

#if (NGX_HAVE_INET6)
        case AF_INET6:
            sin6 = (struct sockaddr_in6 *) c->local_sockaddr;

            for (i = 0; addr == 0 && i < 16; i++) {
                addr |= sin6->sin6_addr.s6_addr[i];
            }

            break;
#endif

#if (NGX_HAVE_UNIX_DOMAIN)
        case AF_UNIX:
            addr = 1;
            break;
#endif

        default: /* AF_INET */
            sin = (struct sockaddr_in *) c->local_sockaddr;
            addr = sin->sin_addr.s_addr;
            break;
        }
    }

    if (addr == 0) {

        len = sizeof(ngx_sockaddr_t);

        if (g...",1,1,core\ngx_connection.c,ngx_connection_local_sockaddr,,false,1339,1408,ngx_connection_local_sockaddr,,,15,"ngx_int_t ngx_connection_local_sockaddr (ngx_connection_t*,ngx_str_t*,ngx_uint_t)"
10545,METHOD,core\ngx_connection.c:<global>,TYPE_DECL,"ngx_int_t
ngx_tcp_nodelay(ngx_connection_t *c)
{
    int  tcp_nodelay;

    if (c->tcp_nodelay != NGX_TCP_NODELAY_UNSET) {
        return NGX_OK;
    }

    ngx_log_debug0(NGX_LOG_DEBUG_CORE, c->log, 0, ""tcp_nodelay"");

    tcp_nodelay = 1;

    if (setsockopt(c->fd, IPPROTO_TCP, TCP_NODELAY,
                   (const void *) &tcp_nodelay, sizeof(int))
        == -1)
    {
#if (NGX_SOLARIS)
        if (c->log_error == NGX_ERROR_INFO) {

            /* Solaris returns EINVAL if a socket has been shut down */
            c->log_error = NGX_ERROR_IGNORE_EINVAL;

            ngx_connection_error(c, ngx_socket_errno,
                                 ""setsockopt(TCP_NODELAY) failed"");

            c->log_error = NGX_ERROR_INFO;

            return NGX_ERROR;
        }
#endif

        ngx_connection_error(c, ngx_socket_errno,
                             ""setsockopt(TCP_NODELAY) failed"");
        return NGX_ERROR;
    }

    c->tcp_nodelay = NGX_TCP_NODELAY_SET;

    return NGX_OK;
}",1,1,core\ngx_connection.c,ngx_tcp_nodelay,,false,1411,1451,ngx_tcp_nodelay,,,16,ngx_int_t ngx_tcp_nodelay (ngx_connection_t*)
10600,METHOD,core\ngx_connection.c:<global>,TYPE_DECL,"ngx_int_t
ngx_connection_error(ngx_connection_t *c, ngx_err_t err, char *text)
{
    ngx_uint_t  level;

    /* Winsock may return NGX_ECONNABORTED instead of NGX_ECONNRESET */

    if ((err == NGX_ECONNRESET
#if (NGX_WIN32)
         || err == NGX_ECONNABORTED
#endif
        ) && c->log_error == NGX_ERROR_IGNORE_ECONNRESET)
    {
        return 0;
    }

#if (NGX_SOLARIS)
    if (err == NGX_EINVAL && c->log_error == NGX_ERROR_IGNORE_EINVAL) {
        return 0;
    }
#endif

    if (err == 0
        || err == NGX_ECONNRESET
#if (NGX_WIN32)
        || err == NGX_ECONNABORTED
#else
        || err == NGX_EPIPE
#endif
        || err == NGX_ENOTCONN
        || err == NGX_ETIMEDOUT
        || err == NGX_ECONNREFUSED
        || err == NGX_ENETDOWN
        || err == NGX_ENETUNREACH
        || err == NGX_EHOSTDOWN
        || err == NGX_EHOSTUNREACH)
    {
        switch (c->log_error) {

        case NGX_ERROR_IGNORE_EINVAL:
        case NGX_ERROR_IGNORE_ECONNRESET:
        case NGX_ERROR_INF...",1,1,core\ngx_connection.c,ngx_connection_error,,false,1454,1510,ngx_connection_error,,,17,"ngx_int_t ngx_connection_error (ngx_connection_t*,ngx_err_t,char*)"
10702,METHOD,core\ngx_connection.h:<global>,TYPE_DECL,<global>,1,40,core\ngx_connection.h,core\ngx_connection.h:<global>,,false,1,229,<global>,,,1,
10759,METHOD,<empty>,<empty>,<empty>,1,,core\ngx_connection.h,ngx_connection_log_error_e:<clinit>,,false,96,,<clinit>,,,6,
10771,METHOD,<empty>,<empty>,<empty>,1,,core\ngx_connection.h,ngx_connection_tcp_nodelay_e:<clinit>,,false,105,,<clinit>,,,4,
10783,METHOD,<empty>,<empty>,<empty>,1,,core\ngx_connection.h,ngx_connection_tcp_nopush_e:<clinit>,,false,112,,<clinit>,,,4,
10835,METHOD,core\ngx_connection.h:<global>,TYPE_DECL,"ngx_listening_t *ngx_create_listening(ngx_conf_t *cf, struct sockaddr *sockaddr,
    socklen_t socklen);",17,22,core\ngx_connection.h,ngx_create_listening,,false,210,211,ngx_create_listening,,,11,"ngx_listening_t* ngx_create_listening (ngx_conf_t*,sockaddr*,socklen_t)"
10842,METHOD,core\ngx_connection.h:<global>,TYPE_DECL,"ngx_int_t ngx_clone_listening(ngx_cycle_t *cycle, ngx_listening_t *ls);",11,70,core\ngx_connection.h,ngx_clone_listening,,false,212,212,ngx_clone_listening,,,12,"ngx_int_t ngx_clone_listening (ngx_cycle_t*,ngx_listening_t*)"
10848,METHOD,core\ngx_connection.h:<global>,TYPE_DECL,ngx_int_t ngx_set_inherited_sockets(ngx_cycle_t *cycle);,11,55,core\ngx_connection.h,ngx_set_inherited_sockets,,false,213,213,ngx_set_inherited_sockets,,,13,ngx_int_t ngx_set_inherited_sockets (ngx_cycle_t*)
10853,METHOD,core\ngx_connection.h:<global>,TYPE_DECL,ngx_int_t ngx_open_listening_sockets(ngx_cycle_t *cycle);,11,56,core\ngx_connection.h,ngx_open_listening_sockets,,false,214,214,ngx_open_listening_sockets,,,14,ngx_int_t ngx_open_listening_sockets (ngx_cycle_t*)
10858,METHOD,core\ngx_connection.h:<global>,TYPE_DECL,void ngx_configure_listening_sockets(ngx_cycle_t *cycle);,6,56,core\ngx_connection.h,ngx_configure_listening_sockets,,false,215,215,ngx_configure_listening_sockets,,,15,void ngx_configure_listening_sockets (ngx_cycle_t*)
10863,METHOD,core\ngx_connection.h:<global>,TYPE_DECL,void ngx_close_listening_sockets(ngx_cycle_t *cycle);,6,52,core\ngx_connection.h,ngx_close_listening_sockets,,false,216,216,ngx_close_listening_sockets,,,16,void ngx_close_listening_sockets (ngx_cycle_t*)
10868,METHOD,core\ngx_connection.h:<global>,TYPE_DECL,void ngx_close_connection(ngx_connection_t *c);,6,46,core\ngx_connection.h,ngx_close_connection,,false,217,217,ngx_close_connection,,,17,void ngx_close_connection (ngx_connection_t*)
10873,METHOD,core\ngx_connection.h:<global>,TYPE_DECL,void ngx_close_idle_connections(ngx_cycle_t *cycle);,6,51,core\ngx_connection.h,ngx_close_idle_connections,,false,218,218,ngx_close_idle_connections,,,18,void ngx_close_idle_connections (ngx_cycle_t*)
10878,METHOD,core\ngx_connection.h:<global>,TYPE_DECL,"ngx_int_t ngx_connection_local_sockaddr(ngx_connection_t *c, ngx_str_t *s,
    ngx_uint_t port);",11,20,core\ngx_connection.h,ngx_connection_local_sockaddr,,false,219,220,ngx_connection_local_sockaddr,,,19,"ngx_int_t ngx_connection_local_sockaddr (ngx_connection_t*,ngx_str_t*,ngx_uint_t)"
10885,METHOD,core\ngx_connection.h:<global>,TYPE_DECL,ngx_int_t ngx_tcp_nodelay(ngx_connection_t *c);,11,46,core\ngx_connection.h,ngx_tcp_nodelay,,false,221,221,ngx_tcp_nodelay,,,20,ngx_int_t ngx_tcp_nodelay (ngx_connection_t*)
10890,METHOD,core\ngx_connection.h:<global>,TYPE_DECL,"ngx_int_t ngx_connection_error(ngx_connection_t *c, ngx_err_t err, char *text);",11,78,core\ngx_connection.h,ngx_connection_error,,false,222,222,ngx_connection_error,,,21,"ngx_int_t ngx_connection_error (ngx_connection_t*,ngx_err_t,char*)"
10897,METHOD,core\ngx_connection.h:<global>,TYPE_DECL,"ngx_connection_t *ngx_get_connection(ngx_socket_t s, ngx_log_t *log);",18,68,core\ngx_connection.h,ngx_get_connection,,false,224,224,ngx_get_connection,,,22,"ngx_connection_t* ngx_get_connection (ngx_socket_t,ngx_log_t*)"
10903,METHOD,core\ngx_connection.h:<global>,TYPE_DECL,void ngx_free_connection(ngx_connection_t *c);,6,45,core\ngx_connection.h,ngx_free_connection,,false,225,225,ngx_free_connection,,,23,void ngx_free_connection (ngx_connection_t*)
10908,METHOD,core\ngx_connection.h:<global>,TYPE_DECL,"void ngx_reusable_connection(ngx_connection_t *c, ngx_uint_t reusable);",6,70,core\ngx_connection.h,ngx_reusable_connection,,false,227,227,ngx_reusable_connection,,,24,"void ngx_reusable_connection (ngx_connection_t*,ngx_uint_t)"
11007,METHOD,core\ngx_core.h:<global>,TYPE_DECL,<global>,1,34,core\ngx_core.h,core\ngx_core.h:<global>,,false,1,113,<global>,,,1,
11043,METHOD,core\ngx_core.h:<global>,TYPE_DECL,typedef void (*ngx_event_handler_pt)(ngx_event_t *ev);,14,53,core\ngx_core.h,ngx_event_handler_pt,,false,33,33,ngx_event_handler_pt,,,35,void ngx_event_handler_pt (ngx_event_t*)
11048,METHOD,core\ngx_core.h:<global>,TYPE_DECL,typedef void (*ngx_connection_handler_pt)(ngx_connection_t *c);,14,62,core\ngx_core.h,ngx_connection_handler_pt,,false,34,34,ngx_connection_handler_pt,,,36,void ngx_connection_handler_pt (ngx_connection_t*)
11053,METHOD,core\ngx_core.h:<global>,TYPE_DECL,void ngx_cpuinfo(void);,6,22,core\ngx_core.h,ngx_cpuinfo,,false,105,105,ngx_cpuinfo,,,37,void ngx_cpuinfo (void)
11065,METHOD,core\ngx_cpuinfo.c:<global>,TYPE_DECL,<global>,1,6,core\ngx_cpuinfo.c,core\ngx_cpuinfo.c:<global>,,false,1,139,<global>,,,1,
11067,METHOD,core\ngx_cpuinfo.c:<global>,TYPE_DECL,"void
ngx_cpuinfo(void)
{
}",1,1,core\ngx_cpuinfo.c,ngx_cpuinfo,,false,133,136,ngx_cpuinfo,,,1,void ngx_cpuinfo (void)
11079,METHOD,core\ngx_crc.h:<global>,TYPE_DECL,<global>,1,33,core\ngx_crc.h,core\ngx_crc.h:<global>,,false,1,39,<global>,,,1,
11083,METHOD,core\ngx_crc.h:<global>,TYPE_DECL,"ngx_crc(u_char *data, size_t len)
{
    uint32_t  sum;

    for (sum = 0; len; len--) {

        /*
         * gcc 2.95.2 x86 and icc 7.1.006 compile
         * that operator into the single ""rol"" opcode,
         * msvc 6.0sp2 compiles it into four opcodes.
         */
        sum = sum >> 1 | sum << 31;

        sum += *data++;
    }

    return sum;
}",1,1,core\ngx_crc.h,ngx_crc,,false,19,36,ngx_crc,,,3,"ANY ngx_crc (u_char*,size_t)"
11122,METHOD,core\ngx_crc32.c:<global>,TYPE_DECL,<global>,1,1,core\ngx_crc32.c,core\ngx_crc32.c:<global>,,false,1,129,<global>,,,1,
11408,METHOD,core\ngx_crc32.c:<global>,TYPE_DECL,"ngx_int_t
ngx_crc32_table_init(void)
{
    void  *p;

    if (((uintptr_t) ngx_crc32_table_short
          & ~((uintptr_t) ngx_cacheline_size - 1))
        == (uintptr_t) ngx_crc32_table_short)
    {
        return NGX_OK;
    }

    p = ngx_alloc(16 * sizeof(uint32_t) + ngx_cacheline_size, ngx_cycle->log);
    if (p == NULL) {
        return NGX_ERROR;
    }

    p = ngx_align_ptr(p, ngx_cacheline_size);

    ngx_memcpy(p, ngx_crc32_table16, 16 * sizeof(uint32_t));

    ngx_crc32_table_short = p;

    return NGX_OK;
}",1,1,core\ngx_crc32.c,ngx_crc32_table_init,,false,105,129,ngx_crc32_table_init,,,7,ngx_int_t ngx_crc32_table_init (void)
11475,METHOD,core\ngx_crc32.h:<global>,TYPE_DECL,<global>,1,35,core\ngx_crc32.h,core\ngx_crc32.h:<global>,,false,1,79,<global>,,,1,
11482,METHOD,core\ngx_crc32.h:<global>,TYPE_DECL,"ngx_crc32_short(u_char *p, size_t len)
{
    u_char    c;
    uint32_t  crc;

    crc = 0xffffffff;

    while (len--) {
        c = *p++;
        crc = ngx_crc32_table_short[(crc ^ (c & 0xf)) & 0xf] ^ (crc >> 4);
        crc = ngx_crc32_table_short[(crc ^ (c >> 4)) & 0xf] ^ (crc >> 4);
    }

    return crc ^ 0xffffffff;
}",1,1,core\ngx_crc32.h,ngx_crc32_short,,false,21,35,ngx_crc32_short,,,6,"ANY ngx_crc32_short (u_char*,size_t)"
11538,METHOD,core\ngx_crc32.h:<global>,TYPE_DECL,"ngx_crc32_long(u_char *p, size_t len)
{
    uint32_t  crc;

    crc = 0xffffffff;

    while (len--) {
        crc = ngx_crc32_table256[(crc ^ *p++) & 0xff] ^ (crc >> 8);
    }

    return crc ^ 0xffffffff;
}",1,1,core\ngx_crc32.h,ngx_crc32_long,,false,39,50,ngx_crc32_long,,,9,"ANY ngx_crc32_long (u_char*,size_t)"
11572,METHOD,core\ngx_crc32.h:<global>,TYPE_DECL,ngx_int_t ngx_crc32_table_init(void);,11,36,core\ngx_crc32.h,ngx_crc32_table_init,,false,76,76,ngx_crc32_table_init,,,11,ngx_int_t ngx_crc32_table_init (void)
11590,METHOD,core\ngx_crypt.c:<global>,TYPE_DECL,<global>,1,22,core\ngx_crypt.c,core\ngx_crypt.c:<global>,,false,1,270,<global>,,,1,
11599,METHOD,core\ngx_crypt.h:<global>,TYPE_DECL,<global>,1,35,core\ngx_crypt.h,core\ngx_crypt.h:<global>,,false,1,20,<global>,,,1,
11601,METHOD,core\ngx_crypt.h:<global>,TYPE_DECL,"ngx_int_t ngx_crypt(ngx_pool_t *pool, u_char *key, u_char *salt,
    u_char **encrypted);",11,23,core\ngx_crypt.h,ngx_crypt,,false,16,17,ngx_crypt,,,1,"ngx_int_t ngx_crypt (ngx_pool_t*,u_char*,u_char*,u_char**)"
11618,METHOD,core\ngx_cycle.c:<global>,TYPE_DECL,<global>,1,1,core\ngx_cycle.c,core\ngx_cycle.c:<global>,,false,1,1457,<global>,,,1,
11620,METHOD,core\ngx_cycle.c:<global>,TYPE_DECL,static void ngx_destroy_cycle_pools(ngx_conf_t *conf);,13,53,core\ngx_cycle.c,ngx_destroy_cycle_pools,,false,13,13,ngx_destroy_cycle_pools,,,1,void ngx_destroy_cycle_pools (ngx_conf_t*)
11625,METHOD,core\ngx_cycle.c:<global>,TYPE_DECL,"static ngx_int_t ngx_init_zone_pool(ngx_cycle_t *cycle,
    ngx_shm_zone_t *shm_zone);",18,29,core\ngx_cycle.c,ngx_init_zone_pool,,false,14,15,ngx_init_zone_pool,,,2,"ngx_int_t ngx_init_zone_pool (ngx_cycle_t*,ngx_shm_zone_t*)"
11631,METHOD,core\ngx_cycle.c:<global>,TYPE_DECL,"static ngx_int_t ngx_test_lockfile(u_char *file, ngx_log_t *log);",18,64,core\ngx_cycle.c,ngx_test_lockfile,,false,16,16,ngx_test_lockfile,,,3,"ngx_int_t ngx_test_lockfile (u_char*,ngx_log_t*)"
11637,METHOD,core\ngx_cycle.c:<global>,TYPE_DECL,static void ngx_clean_old_cycles(ngx_event_t *ev);,13,49,core\ngx_cycle.c,ngx_clean_old_cycles,,false,17,17,ngx_clean_old_cycles,,,4,void ngx_clean_old_cycles (ngx_event_t*)
11642,METHOD,core\ngx_cycle.c:<global>,TYPE_DECL,static void ngx_shutdown_timer_handler(ngx_event_t *ev);,13,55,core\ngx_cycle.c,ngx_shutdown_timer_handler,,false,18,18,ngx_shutdown_timer_handler,,,5,void ngx_shutdown_timer_handler (ngx_event_t*)
11656,METHOD,core\ngx_cycle.c:<global>,TYPE_DECL,"ngx_cycle_t *
ngx_init_cycle(ngx_cycle_t *old_cycle)
{
    void                *rv;
    char               **senv;
    ngx_uint_t           i, n;
    ngx_log_t           *log;
    ngx_time_t          *tp;
    ngx_conf_t           conf;
    ngx_pool_t          *pool;
    ngx_cycle_t         *cycle, **old;
    ngx_shm_zone_t      *shm_zone, *oshm_zone;
    ngx_list_part_t     *part, *opart;
    ngx_open_file_t     *file;
    ngx_listening_t     *ls, *nls;
    ngx_core_conf_t     *ccf, *old_ccf;
    ngx_core_module_t   *module;
    char                 hostname[NGX_MAXHOSTNAMELEN];

    ngx_timezone_update();

    /* force localtime update with a new timezone */

    tp = ngx_timeofday();
    tp->sec = 0;

    ngx_time_update();


    log = old_cycle->log;

    pool = ngx_create_pool(NGX_CYCLE_POOL_SIZE, log);
    if (pool == NULL) {
        return NULL;
    }
    pool->log = log;

    cycle = ngx_pcalloc(pool, sizeof(ngx_cycle_t));
    if (cycle == NULL) {
        ngx_destroy_pool(poo...",1,1,core\ngx_cycle.c,ngx_init_cycle,,false,38,930,ngx_init_cycle,,,15,ngx_cycle_t ngx_init_cycle (ngx_cycle_t*)
14196,METHOD,core\ngx_cycle.c:<global>,TYPE_DECL,"static void
ngx_destroy_cycle_pools(ngx_conf_t *conf)
{
    ngx_destroy_pool(conf->temp_pool);
    ngx_destroy_pool(conf->pool);
}",1,1,core\ngx_cycle.c,ngx_destroy_cycle_pools,,false,933,938,ngx_destroy_cycle_pools,,,16,void ngx_destroy_cycle_pools (ngx_conf_t*)
14209,METHOD,core\ngx_cycle.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_init_zone_pool(ngx_cycle_t *cycle, ngx_shm_zone_t *zn)
{
    u_char           *file;
    ngx_slab_pool_t  *sp;

    sp = (ngx_slab_pool_t *) zn->shm.addr;

    if (zn->shm.exists) {

        if (sp == sp->addr) {
            return NGX_OK;
        }

#if (NGX_WIN32)

        /* remap at the required address */

        if (ngx_shm_remap(&zn->shm, sp->addr) != NGX_OK) {
            return NGX_ERROR;
        }

        sp = (ngx_slab_pool_t *) zn->shm.addr;

        if (sp == sp->addr) {
            return NGX_OK;
        }

#endif

        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
                      ""shared zone \""%V\"" has no equal addresses: %p vs %p"",
                      &zn->shm.name, sp->addr, sp);
        return NGX_ERROR;
    }

    sp->end = zn->shm.addr + zn->shm.size;
    sp->min_shift = 3;
    sp->addr = zn->shm.addr;

#if (NGX_HAVE_ATOMIC_OPS)

    file = NULL;

#else

    file = ngx_pnalloc(cycle->pool,
                       cycle->lock_file.l...",1,1,core\ngx_cycle.c,ngx_init_zone_pool,,false,941,1004,ngx_init_zone_pool,,,17,"ngx_int_t ngx_init_zone_pool (ngx_cycle_t*,ngx_shm_zone_t*)"
14353,METHOD,core\ngx_cycle.c:<global>,TYPE_DECL,"ngx_int_t
ngx_create_pidfile(ngx_str_t *name, ngx_log_t *log)
{
    size_t      len;
    ngx_uint_t  create;
    ngx_file_t  file;
    u_char      pid[NGX_INT64_LEN + 2];

    if (ngx_process > NGX_PROCESS_MASTER) {
        return NGX_OK;
    }

    ngx_memzero(&file, sizeof(ngx_file_t));

    file.name = *name;
    file.log = log;

    create = ngx_test_config ? NGX_FILE_CREATE_OR_OPEN : NGX_FILE_TRUNCATE;

    file.fd = ngx_open_file(file.name.data, NGX_FILE_RDWR,
                            create, NGX_FILE_DEFAULT_ACCESS);

    if (file.fd == NGX_INVALID_FILE) {
        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,
                      ngx_open_file_n "" \""%s\"" failed"", file.name.data);
        return NGX_ERROR;
    }

    if (!ngx_test_config) {
        len = ngx_snprintf(pid, NGX_INT64_LEN + 2, ""%P%N"", ngx_pid) - pid;

        if (ngx_write_file(&file, pid, len, 0) == NGX_ERROR) {
            return NGX_ERROR;
        }
    }

    if (ngx_close_file(file.fd) == NGX_FILE_ERROR) ...",1,1,core\ngx_cycle.c,ngx_create_pidfile,,false,1007,1049,ngx_create_pidfile,,,18,"ngx_int_t ngx_create_pidfile (ngx_str_t*,ngx_log_t*)"
14453,METHOD,core\ngx_cycle.c:<global>,TYPE_DECL,"void
ngx_delete_pidfile(ngx_cycle_t *cycle)
{
    u_char           *name;
    ngx_core_conf_t  *ccf;

    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);

    name = ngx_new_binary ? ccf->oldpid.data : ccf->pid.data;

    if (ngx_delete_file(name) == NGX_FILE_ERROR) {
        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                      ngx_delete_file_n "" \""%s\"" failed"", name);
    }
}",1,1,core\ngx_cycle.c,ngx_delete_pidfile,,false,1052,1066,ngx_delete_pidfile,,,19,void ngx_delete_pidfile (ngx_cycle_t*)
14490,METHOD,core\ngx_cycle.c:<global>,TYPE_DECL,"ngx_int_t
ngx_signal_process(ngx_cycle_t *cycle, char *sig)
{
    ssize_t           n;
    ngx_pid_t         pid;
    ngx_file_t        file;
    ngx_core_conf_t  *ccf;
    u_char            buf[NGX_INT64_LEN + 2];

    ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, ""signal process started"");

    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);

    ngx_memzero(&file, sizeof(ngx_file_t));

    file.name = ccf->pid;
    file.log = cycle->log;

    file.fd = ngx_open_file(file.name.data, NGX_FILE_RDONLY,
                            NGX_FILE_OPEN, NGX_FILE_DEFAULT_ACCESS);

    if (file.fd == NGX_INVALID_FILE) {
        ngx_log_error(NGX_LOG_ERR, cycle->log, ngx_errno,
                      ngx_open_file_n "" \""%s\"" failed"", file.name.data);
        return 1;
    }

    n = ngx_read_file(&file, buf, NGX_INT64_LEN + 2, 0);

    if (ngx_close_file(file.fd) == NGX_FILE_ERROR) {
        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                      ngx_clo...",1,1,core\ngx_cycle.c,ngx_signal_process,,false,1069,1120,ngx_signal_process,,,20,"ngx_int_t ngx_signal_process (ngx_cycle_t*,char*)"
14635,METHOD,core\ngx_cycle.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_test_lockfile(u_char *file, ngx_log_t *log)
{
#if !(NGX_HAVE_ATOMIC_OPS)
    ngx_fd_t  fd;

    fd = ngx_open_file(file, NGX_FILE_RDWR, NGX_FILE_CREATE_OR_OPEN,
                       NGX_FILE_DEFAULT_ACCESS);

    if (fd == NGX_INVALID_FILE) {
        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,
                      ngx_open_file_n "" \""%s\"" failed"", file);
        return NGX_ERROR;
    }

    if (ngx_close_file(fd) == NGX_FILE_ERROR) {
        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,
                      ngx_close_file_n "" \""%s\"" failed"", file);
    }

    if (ngx_delete_file(file) == NGX_FILE_ERROR) {
        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,
                      ngx_delete_file_n "" \""%s\"" failed"", file);
    }

#endif

    return NGX_OK;
}",1,1,core\ngx_cycle.c,ngx_test_lockfile,,false,1123,1151,ngx_test_lockfile,,,21,"ngx_int_t ngx_test_lockfile (u_char*,ngx_log_t*)"
14673,METHOD,core\ngx_cycle.c:<global>,TYPE_DECL,"void
ngx_reopen_files(ngx_cycle_t *cycle, ngx_uid_t user)
{
    ngx_fd_t          fd;
    ngx_uint_t        i;
    ngx_list_part_t  *part;
    ngx_open_file_t  *file;

    part = &cycle->open_files.part;
    file = part->elts;

    for (i = 0; /* void */ ; i++) {

        if (i >= part->nelts) {
            if (part->next == NULL) {
                break;
            }
            part = part->next;
            file = part->elts;
            i = 0;
        }

        if (file[i].name.len == 0) {
            continue;
        }

        if (file[i].flush) {
            file[i].flush(&file[i], cycle->log);
        }

        fd = ngx_open_file(file[i].name.data, NGX_FILE_APPEND,
                           NGX_FILE_CREATE_OR_OPEN, NGX_FILE_DEFAULT_ACCESS);

        ngx_log_debug3(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
                       ""reopen file \""%s\"", old:%d new:%d"",
                       file[i].name.data, file[i].fd, fd);

        if (fd == NGX_INVALID_FILE) {
            ngx...",1,1,core\ngx_cycle.c,ngx_reopen_files,,false,1154,1275,ngx_reopen_files,,,22,"void ngx_reopen_files (ngx_cycle_t*,ngx_uid_t)"
14996,METHOD,core\ngx_cycle.c:<global>,TYPE_DECL,"ngx_shm_zone_t *
ngx_shared_memory_add(ngx_conf_t *cf, ngx_str_t *name, size_t size, void *tag)
{
    ngx_uint_t        i;
    ngx_shm_zone_t   *shm_zone;
    ngx_list_part_t  *part;

    part = &cf->cycle->shared_memory.part;
    shm_zone = part->elts;

    for (i = 0; /* void */ ; i++) {

        if (i >= part->nelts) {
            if (part->next == NULL) {
                break;
            }
            part = part->next;
            shm_zone = part->elts;
            i = 0;
        }

        if (name->len != shm_zone[i].shm.name.len) {
            continue;
        }

        if (ngx_strncmp(name->data, shm_zone[i].shm.name.data, name->len)
            != 0)
        {
            continue;
        }

        if (tag != shm_zone[i].tag) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                            ""the shared memory zone \""%V\"" is ""
                            ""already declared for a different use"",
                            &shm_zone[i].shm.name);
      ...",1,1,core\ngx_cycle.c,ngx_shared_memory_add,,false,1278,1349,ngx_shared_memory_add,,,23,"ngx_shm_zone_t ngx_shared_memory_add (ngx_conf_t*,ngx_str_t*,size_t,void*)"
15258,METHOD,core\ngx_cycle.c:<global>,TYPE_DECL,"static void
ngx_clean_old_cycles(ngx_event_t *ev)
{
    ngx_uint_t     i, n, found, live;
    ngx_log_t     *log;
    ngx_cycle_t  **cycle;

    log = ngx_cycle->log;
    ngx_temp_pool->log = log;

    ngx_log_debug0(NGX_LOG_DEBUG_CORE, log, 0, ""clean old cycles"");

    live = 0;

    cycle = ngx_old_cycles.elts;
    for (i = 0; i < ngx_old_cycles.nelts; i++) {

        if (cycle[i] == NULL) {
            continue;
        }

        found = 0;

        for (n = 0; n < cycle[i]->connection_n; n++) {
            if (cycle[i]->connections[n].fd != (ngx_socket_t) -1) {
                found = 1;

                ngx_log_debug1(NGX_LOG_DEBUG_CORE, log, 0, ""live fd:%ui"", n);

                break;
            }
        }

        if (found) {
            live = 1;
            continue;
        }

        ngx_log_debug1(NGX_LOG_DEBUG_CORE, log, 0, ""clean old cycle: %ui"", i);

        ngx_destroy_pool(cycle[i]->pool);
        cycle[i] = NULL;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_CORE, ...",1,1,core\ngx_cycle.c,ngx_clean_old_cycles,,false,1352,1406,ngx_clean_old_cycles,,,24,void ngx_clean_old_cycles (ngx_event_t*)
15404,METHOD,core\ngx_cycle.c:<global>,TYPE_DECL,"void
ngx_set_shutdown_timer(ngx_cycle_t *cycle)
{
    ngx_core_conf_t  *ccf;

    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);

    if (ccf->shutdown_timeout) {
        ngx_shutdown_event.handler = ngx_shutdown_timer_handler;
        ngx_shutdown_event.data = cycle;
        ngx_shutdown_event.log = cycle->log;
        ngx_shutdown_event.cancelable = 1;

        ngx_add_timer(&ngx_shutdown_event, ccf->shutdown_timeout);
    }
}",1,1,core\ngx_cycle.c,ngx_set_shutdown_timer,,false,1409,1424,ngx_set_shutdown_timer,,,25,void ngx_set_shutdown_timer (ngx_cycle_t*)
15452,METHOD,core\ngx_cycle.c:<global>,TYPE_DECL,"static void
ngx_shutdown_timer_handler(ngx_event_t *ev)
{
    ngx_uint_t         i;
    ngx_cycle_t       *cycle;
    ngx_connection_t  *c;

    cycle = ev->data;

    c = cycle->connections;

    for (i = 0; i < cycle->connection_n; i++) {

        if (c[i].fd == (ngx_socket_t) -1
            || c[i].read == NULL
            || c[i].read->accept
            || c[i].read->channel
            || c[i].read->resolver)
        {
            continue;
        }

        ngx_log_debug1(NGX_LOG_DEBUG_CORE, ev->log, 0,
                       ""*%uA shutdown timeout"", c[i].number);

        c[i].close = 1;
        c[i].error = 1;

        c[i].read->handler(c[i].read);
    }
}",1,1,core\ngx_cycle.c,ngx_shutdown_timer_handler,,false,1427,1457,ngx_shutdown_timer_handler,,,26,void ngx_shutdown_timer_handler (ngx_event_t*)
15573,METHOD,core\ngx_cycle.h:<global>,TYPE_DECL,<global>,1,35,core\ngx_cycle.h,core\ngx_cycle.h:<global>,,false,1,147,<global>,,,1,
15577,METHOD,core\ngx_cycle.h:<global>,TYPE_DECL,"typedef ngx_int_t (*ngx_shm_zone_init_pt) (ngx_shm_zone_t *zone, void *data);",19,76,core\ngx_cycle.h,ngx_shm_zone_init_pt,,false,27,27,ngx_shm_zone_init_pt,,,3,"ngx_int_t ngx_shm_zone_init_pt (ngx_shm_zone_t*,void*)"
15647,METHOD,core\ngx_cycle.h:<global>,TYPE_DECL,ngx_cycle_t *ngx_init_cycle(ngx_cycle_t *old_cycle);,13,51,core\ngx_cycle.h,ngx_init_cycle,,false,126,126,ngx_init_cycle,,,8,ngx_cycle_t* ngx_init_cycle (ngx_cycle_t*)
15652,METHOD,core\ngx_cycle.h:<global>,TYPE_DECL,"ngx_int_t ngx_create_pidfile(ngx_str_t *name, ngx_log_t *log);",11,61,core\ngx_cycle.h,ngx_create_pidfile,,false,127,127,ngx_create_pidfile,,,9,"ngx_int_t ngx_create_pidfile (ngx_str_t*,ngx_log_t*)"
15658,METHOD,core\ngx_cycle.h:<global>,TYPE_DECL,void ngx_delete_pidfile(ngx_cycle_t *cycle);,6,43,core\ngx_cycle.h,ngx_delete_pidfile,,false,128,128,ngx_delete_pidfile,,,10,void ngx_delete_pidfile (ngx_cycle_t*)
15663,METHOD,core\ngx_cycle.h:<global>,TYPE_DECL,"ngx_int_t ngx_signal_process(ngx_cycle_t *cycle, char *sig);",11,59,core\ngx_cycle.h,ngx_signal_process,,false,129,129,ngx_signal_process,,,11,"ngx_int_t ngx_signal_process (ngx_cycle_t*,char*)"
15669,METHOD,core\ngx_cycle.h:<global>,TYPE_DECL,"void ngx_reopen_files(ngx_cycle_t *cycle, ngx_uid_t user);",6,57,core\ngx_cycle.h,ngx_reopen_files,,false,130,130,ngx_reopen_files,,,12,"void ngx_reopen_files (ngx_cycle_t*,ngx_uid_t)"
15675,METHOD,core\ngx_cycle.h:<global>,TYPE_DECL,"char **ngx_set_environment(ngx_cycle_t *cycle, ngx_uint_t *last);",6,64,core\ngx_cycle.h,ngx_set_environment,,false,131,131,ngx_set_environment,,,13,"char** ngx_set_environment (ngx_cycle_t*,ngx_uint_t*)"
15681,METHOD,core\ngx_cycle.h:<global>,TYPE_DECL,"ngx_pid_t ngx_exec_new_binary(ngx_cycle_t *cycle, char *const *argv);",11,68,core\ngx_cycle.h,ngx_exec_new_binary,,false,132,132,ngx_exec_new_binary,,,14,"ngx_pid_t ngx_exec_new_binary (ngx_cycle_t*,char**)"
15687,METHOD,core\ngx_cycle.h:<global>,TYPE_DECL,ngx_cpuset_t *ngx_get_cpu_affinity(ngx_uint_t n);,14,48,core\ngx_cycle.h,ngx_get_cpu_affinity,,false,133,133,ngx_get_cpu_affinity,,,15,ngx_cpuset_t* ngx_get_cpu_affinity (ngx_uint_t)
15692,METHOD,core\ngx_cycle.h:<global>,TYPE_DECL,"ngx_shm_zone_t *ngx_shared_memory_add(ngx_conf_t *cf, ngx_str_t *name,
    size_t size, void *tag);",16,27,core\ngx_cycle.h,ngx_shared_memory_add,,false,134,135,ngx_shared_memory_add,,,16,"ngx_shm_zone_t* ngx_shared_memory_add (ngx_conf_t*,ngx_str_t*,size_t,void*)"
15700,METHOD,core\ngx_cycle.h:<global>,TYPE_DECL,void ngx_set_shutdown_timer(ngx_cycle_t *cycle);,6,47,core\ngx_cycle.h,ngx_set_shutdown_timer,,false,136,136,ngx_set_shutdown_timer,,,17,void ngx_set_shutdown_timer (ngx_cycle_t*)
15718,METHOD,core\ngx_file.c:<global>,TYPE_DECL,<global>,1,1,core\ngx_file.c,core\ngx_file.c:<global>,,false,1,1128,<global>,,,1,
15720,METHOD,core\ngx_file.c:<global>,TYPE_DECL,static ngx_int_t ngx_test_full_name(ngx_str_t *name);,18,52,core\ngx_file.c,ngx_test_full_name,,false,12,12,ngx_test_full_name,,,1,ngx_int_t ngx_test_full_name (ngx_str_t*)
15738,METHOD,core\ngx_file.c:<global>,TYPE_DECL,"ngx_int_t
ngx_get_full_name(ngx_pool_t *pool, ngx_str_t *prefix, ngx_str_t *name)
{
    size_t      len;
    u_char     *p, *n;
    ngx_int_t   rc;

    rc = ngx_test_full_name(name);

    if (rc == NGX_OK) {
        return rc;
    }

    len = prefix->len;

#if (NGX_WIN32)

    if (rc == 2) {
        len = rc;
    }

#endif

    n = ngx_pnalloc(pool, len + name->len + 1);
    if (n == NULL) {
        return NGX_ERROR;
    }

    p = ngx_cpymem(n, prefix->data, len);
    ngx_cpystrn(p, name->data, name->len + 1);

    name->len += len;
    name->data = n;

    return NGX_OK;
}",1,1,core\ngx_file.c,ngx_get_full_name,,false,20,55,ngx_get_full_name,,,8,"ngx_int_t ngx_get_full_name (ngx_pool_t*,ngx_str_t*,ngx_str_t*)"
15813,METHOD,core\ngx_file.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_test_full_name(ngx_str_t *name)
{
#if (NGX_WIN32)
    u_char  c0, c1;

    c0 = name->data[0];

    if (name->len < 2) {
        if (c0 == '/') {
            return 2;
        }

        return NGX_DECLINED;
    }

    c1 = name->data[1];

    if (c1 == ':') {
        c0 |= 0x20;

        if ((c0 >= 'a' && c0 <= 'z')) {
            return NGX_OK;
        }

        return NGX_DECLINED;
    }

    if (c1 == '/') {
        return NGX_OK;
    }

    if (c0 == '/') {
        return 2;
    }

    return NGX_DECLINED;

#else

    if (name->data[0] == '/') {
        return NGX_OK;
    }

    return NGX_DECLINED;

#endif
}",1,1,core\ngx_file.c,ngx_test_full_name,,false,58,105,ngx_test_full_name,,,9,ngx_int_t ngx_test_full_name (ngx_str_t*)
15831,METHOD,core\ngx_file.c:<global>,TYPE_DECL,"ssize_t
ngx_write_chain_to_temp_file(ngx_temp_file_t *tf, ngx_chain_t *chain)
{
    ngx_int_t  rc;

    if (tf->file.fd == NGX_INVALID_FILE) {
        rc = ngx_create_temp_file(&tf->file, tf->path, tf->pool,
                                  tf->persistent, tf->clean, tf->access);

        if (rc != NGX_OK) {
            return rc;
        }

        if (tf->log_level) {
            ngx_log_error(tf->log_level, tf->file.log, 0, ""%s %V"",
                          tf->warn, &tf->file.name);
        }
    }

#if (NGX_THREADS && NGX_HAVE_PWRITEV)

    if (tf->thread_write) {
        return ngx_thread_write_chain_to_file(&tf->file, chain, tf->offset,
                                              tf->pool);
    }

#endif

    return ngx_write_chain_to_file(&tf->file, chain, tf->offset, tf->pool);
}",1,1,core\ngx_file.c,ngx_write_chain_to_temp_file,,false,108,137,ngx_write_chain_to_temp_file,,,10,"ssize_t ngx_write_chain_to_temp_file (ngx_temp_file_t*,ngx_chain_t*)"
15914,METHOD,core\ngx_file.c:<global>,TYPE_DECL,"ngx_int_t
ngx_create_temp_file(ngx_file_t *file, ngx_path_t *path, ngx_pool_t *pool,
    ngx_uint_t persistent, ngx_uint_t clean, ngx_uint_t access)
{
    size_t                    levels;
    u_char                   *p;
    uint32_t                  n;
    ngx_err_t                 err;
    ngx_str_t                 name;
    ngx_uint_t                prefix;
    ngx_pool_cleanup_t       *cln;
    ngx_pool_cleanup_file_t  *clnf;

    if (file->name.len) {
        name = file->name;
        levels = 0;
        prefix = 1;

    } else {
        name = path->name;
        levels = path->len;
        prefix = 0;
    }

    file->name.len = name.len + 1 + levels + 10;

    file->name.data = ngx_pnalloc(pool, file->name.len + 1);
    if (file->name.data == NULL) {
        return NGX_ERROR;
    }

#if 0
    for (i = 0; i < file->name.len; i++) {
        file->name.data[i] = 'X';
    }
#endif

    p = ngx_cpymem(file->name.data, name.data, name.len);

    if (prefix) {
        *p = '.';
 ...",1,1,core\ngx_file.c,ngx_create_temp_file,,false,140,237,ngx_create_temp_file,,,11,"ngx_int_t ngx_create_temp_file (ngx_file_t*,ngx_path_t*,ngx_pool_t*,ngx_uint_t,ngx_uint_t,ngx_uint_t)"
16195,METHOD,core\ngx_file.c:<global>,TYPE_DECL,"void
ngx_create_hashed_filename(ngx_path_t *path, u_char *file, size_t len)
{
    size_t      i, level;
    ngx_uint_t  n;

    i = path->name.len + 1;

    file[path->name.len + path->len]  = '/';

    for (n = 0; n < NGX_MAX_PATH_LEVEL; n++) {
        level = path->level[n];

        if (level == 0) {
            break;
        }

        len -= level;
        file[i - 1] = '/';
        ngx_memcpy(&file[i], &file[len], level);
        i += level + 1;
    }
}",1,1,core\ngx_file.c,ngx_create_hashed_filename,,false,240,262,ngx_create_hashed_filename,,,12,"void ngx_create_hashed_filename (ngx_path_t*,u_char*,size_t)"
16276,METHOD,core\ngx_file.c:<global>,TYPE_DECL,"ngx_int_t
ngx_create_path(ngx_file_t *file, ngx_path_t *path)
{
    size_t      pos;
    ngx_err_t   err;
    ngx_uint_t  i;

    pos = path->name.len;

    for (i = 0; i < NGX_MAX_PATH_LEVEL; i++) {
        if (path->level[i] == 0) {
            break;
        }

        pos += path->level[i] + 1;

        file->name.data[pos] = '\0';

        ngx_log_debug1(NGX_LOG_DEBUG_CORE, file->log, 0,
                       ""temp file: \""%s\"""", file->name.data);

        if (ngx_create_dir(file->name.data, 0700) == NGX_FILE_ERROR) {
            err = ngx_errno;
            if (err != NGX_EEXIST) {
                ngx_log_error(NGX_LOG_CRIT, file->log, err,
                              ngx_create_dir_n "" \""%s\"" failed"",
                              file->name.data);
                return NGX_ERROR;
            }
        }

        file->name.data[pos] = '/';
    }

    return NGX_OK;
}",1,1,core\ngx_file.c,ngx_create_path,,false,265,300,ngx_create_path,,,13,"ngx_int_t ngx_create_path (ngx_file_t*,ngx_path_t*)"
16376,METHOD,core\ngx_file.c:<global>,TYPE_DECL,"ngx_err_t
ngx_create_full_path(u_char *dir, ngx_uint_t access)
{
    u_char     *p, ch;
    ngx_err_t   err;

    err = 0;

#if (NGX_WIN32)
    p = dir + 3;
#else
    p = dir + 1;
#endif

    for ( /* void */ ; *p; p++) {
        ch = *p;

        if (ch != '/') {
            continue;
        }

        *p = '\0';

        if (ngx_create_dir(dir, access) == NGX_FILE_ERROR) {
            err = ngx_errno;

            switch (err) {
            case NGX_EEXIST:
                err = 0;
            case NGX_EACCES:
                break;

            default:
                return err;
            }
        }

        *p = '/';
    }

    return err;
}",1,1,core\ngx_file.c,ngx_create_full_path,,false,303,344,ngx_create_full_path,,,14,"ngx_err_t ngx_create_full_path (u_char*,ngx_uint_t)"
16444,METHOD,core\ngx_file.c:<global>,TYPE_DECL,"ngx_atomic_uint_t
ngx_next_temp_number(ngx_uint_t collision)
{
    ngx_atomic_uint_t  n, add;

    add = collision ? ngx_random_number : 1;

    n = ngx_atomic_fetch_add(ngx_temp_number, add);

    return n + add;
}",1,1,core\ngx_file.c,ngx_next_temp_number,,false,347,357,ngx_next_temp_number,,,15,ngx_atomic_uint_t ngx_next_temp_number (ngx_uint_t)
16466,METHOD,core\ngx_file.c:<global>,TYPE_DECL,"char *
ngx_conf_set_path_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char  *p = conf;

    ssize_t      level;
    ngx_str_t   *value;
    ngx_uint_t   i, n;
    ngx_path_t  *path, **slot;

    slot = (ngx_path_t **) (p + cmd->offset);

    if (*slot) {
        return ""is duplicate"";
    }

    path = ngx_pcalloc(cf->pool, sizeof(ngx_path_t));
    if (path == NULL) {
        return NGX_CONF_ERROR;
    }

    value = cf->args->elts;

    path->name = value[1];

    if (path->name.data[path->name.len - 1] == '/') {
        path->name.len--;
    }

    if (ngx_conf_full_name(cf->cycle, &path->name, 0) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    path->conf_file = cf->conf_file->file.name.data;
    path->line = cf->conf_file->line;

    for (i = 0, n = 2; n < cf->args->nelts; i++, n++) {
        level = ngx_atoi(value[n].data, value[n].len);
        if (level == NGX_ERROR || level == 0) {
            return ""invalid value"";
        }

        path->level[i] = le...",1,1,core\ngx_file.c,ngx_conf_set_path_slot,,false,360,417,ngx_conf_set_path_slot,,,16,"char* ngx_conf_set_path_slot (ngx_conf_t*,ngx_command_t*,void*)"
16673,METHOD,core\ngx_file.c:<global>,TYPE_DECL,"char *
ngx_conf_merge_path_value(ngx_conf_t *cf, ngx_path_t **path, ngx_path_t *prev,
    ngx_path_init_t *init)
{
    ngx_uint_t  i;

    if (*path) {
        return NGX_CONF_OK;
    }

    if (prev) {
        *path = prev;
        return NGX_CONF_OK;
    }

    *path = ngx_pcalloc(cf->pool, sizeof(ngx_path_t));
    if (*path == NULL) {
        return NGX_CONF_ERROR;
    }

    (*path)->name = init->name;

    if (ngx_conf_full_name(cf->cycle, &(*path)->name, 0) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    for (i = 0; i < NGX_MAX_PATH_LEVEL; i++) {
        (*path)->level[i] = init->level[i];
        (*path)->len += init->level[i] + (init->level[i] ? 1 : 0);
    }

    if (ngx_add_path(cf, path) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    return NGX_CONF_OK;
}",1,1,core\ngx_file.c,ngx_conf_merge_path_value,,false,420,456,ngx_conf_merge_path_value,,,17,"char* ngx_conf_merge_path_value (ngx_conf_t*,ngx_path_t**,ngx_path_t*,ngx_path_init_t*)"
16791,METHOD,core\ngx_file.c:<global>,TYPE_DECL,"char *
ngx_conf_set_access_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char  *confp = conf;

    u_char      *p;
    ngx_str_t   *value;
    ngx_uint_t   i, right, shift, *access, user;

    access = (ngx_uint_t *) (confp + cmd->offset);

    if (*access != NGX_CONF_UNSET_UINT) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    *access = 0;
    user = 0600;

    for (i = 1; i < cf->args->nelts; i++) {

        p = value[i].data;

        if (ngx_strncmp(p, ""user:"", sizeof(""user:"") - 1) == 0) {
            shift = 6;
            p += sizeof(""user:"") - 1;
            user = 0;

        } else if (ngx_strncmp(p, ""group:"", sizeof(""group:"") - 1) == 0) {
            shift = 3;
            p += sizeof(""group:"") - 1;

        } else if (ngx_strncmp(p, ""all:"", sizeof(""all:"") - 1) == 0) {
            shift = 0;
            p += sizeof(""all:"") - 1;

        } else {
            goto invalid;
        }

        if (ngx_strcmp(p, ""rw"") == 0) {
            rig...",1,1,core\ngx_file.c,ngx_conf_set_access_slot,,false,459,522,ngx_conf_set_access_slot,,,18,"char* ngx_conf_set_access_slot (ngx_conf_t*,ngx_command_t*,void*)"
16981,METHOD,core\ngx_file.c:<global>,TYPE_DECL,"ngx_int_t
ngx_add_path(ngx_conf_t *cf, ngx_path_t **slot)
{
    ngx_uint_t   i, n;
    ngx_path_t  *path, **p;

    path = *slot;

    p = cf->cycle->paths.elts;
    for (i = 0; i < cf->cycle->paths.nelts; i++) {
        if (p[i]->name.len == path->name.len
            && ngx_strcmp(p[i]->name.data, path->name.data) == 0)
        {
            if (p[i]->data != path->data) {
                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                                   ""the same path name \""%V\"" ""
                                   ""used in %s:%ui and"",
                                   &p[i]->name, p[i]->conf_file, p[i]->line);
                return NGX_ERROR;
            }

            for (n = 0; n < NGX_MAX_PATH_LEVEL; n++) {
                if (p[i]->level[n] != path->level[n]) {
                    if (path->conf_file == NULL) {
                        if (p[i]->conf_file == NULL) {
                            ngx_log_error(NGX_LOG_EMERG, cf->log, 0,
                            ...",1,1,core\ngx_file.c,ngx_add_path,,false,525,594,ngx_add_path,,,19,"ngx_int_t ngx_add_path (ngx_conf_t*,ngx_path_t**)"
17233,METHOD,core\ngx_file.c:<global>,TYPE_DECL,"ngx_int_t
ngx_create_paths(ngx_cycle_t *cycle, ngx_uid_t user)
{
    ngx_err_t         err;
    ngx_uint_t        i;
    ngx_path_t      **path;

    path = cycle->paths.elts;
    for (i = 0; i < cycle->paths.nelts; i++) {

        if (ngx_create_dir(path[i]->name.data, 0700) == NGX_FILE_ERROR) {
            err = ngx_errno;
            if (err != NGX_EEXIST) {
                ngx_log_error(NGX_LOG_EMERG, cycle->log, err,
                              ngx_create_dir_n "" \""%s\"" failed"",
                              path[i]->name.data);
                return NGX_ERROR;
            }
        }

        if (user == (ngx_uid_t) NGX_CONF_UNSET_UINT) {
            continue;
        }

#if !(NGX_WIN32)
        {
        ngx_file_info_t   fi;

        if (ngx_file_info(path[i]->name.data, &fi) == NGX_FILE_ERROR) {
            ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,
                          ngx_file_info_n "" \""%s\"" failed"", path[i]->name.data);
            return NGX_ERROR;
   ...",1,1,core\ngx_file.c,ngx_create_paths,,false,597,656,ngx_create_paths,,,20,"ngx_int_t ngx_create_paths (ngx_cycle_t*,ngx_uid_t)"
17419,METHOD,core\ngx_file.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ext_rename_file(ngx_str_t *src, ngx_str_t *to, ngx_ext_rename_file_t *ext)
{
    u_char           *name;
    ngx_err_t         err;
    ngx_copy_file_t   cf;

#if !(NGX_WIN32)

    if (ext->access) {
        if (ngx_change_file_access(src->data, ext->access) == NGX_FILE_ERROR) {
            ngx_log_error(NGX_LOG_CRIT, ext->log, ngx_errno,
                          ngx_change_file_access_n "" \""%s\"" failed"", src->data);
            err = 0;
            goto failed;
        }
    }

#endif

    if (ext->time != -1) {
        if (ngx_set_file_time(src->data, ext->fd, ext->time) != NGX_OK) {
            ngx_log_error(NGX_LOG_CRIT, ext->log, ngx_errno,
                          ngx_set_file_time_n "" \""%s\"" failed"", src->data);
            err = 0;
            goto failed;
        }
    }

    if (ngx_rename_file(src->data, to->data) != NGX_FILE_ERROR) {
        return NGX_OK;
    }

    err = ngx_errno;

    if (err == NGX_ENOPATH) {

        if (!ext->create_path) {
       ...",1,1,core\ngx_file.c,ngx_ext_rename_file,,false,659,791,ngx_ext_rename_file,,,21,"ngx_int_t ngx_ext_rename_file (ngx_str_t*,ngx_str_t*,ngx_ext_rename_file_t*)"
17682,METHOD,core\ngx_file.c:<global>,TYPE_DECL,"ngx_int_t
ngx_copy_file(u_char *from, u_char *to, ngx_copy_file_t *cf)
{
    char             *buf;
    off_t             size;
    time_t            time;
    size_t            len;
    ssize_t           n;
    ngx_fd_t          fd, nfd;
    ngx_int_t         rc;
    ngx_uint_t        access;
    ngx_file_info_t   fi;

    rc = NGX_ERROR;
    buf = NULL;
    nfd = NGX_INVALID_FILE;

    fd = ngx_open_file(from, NGX_FILE_RDONLY, NGX_FILE_OPEN, 0);

    if (fd == NGX_INVALID_FILE) {
        ngx_log_error(NGX_LOG_CRIT, cf->log, ngx_errno,
                      ngx_open_file_n "" \""%s\"" failed"", from);
        goto failed;
    }

    if (cf->size != -1 && cf->access != 0 && cf->time != -1) {
        size = cf->size;
        access = cf->access;
        time = cf->time;

    } else {
        if (ngx_fd_info(fd, &fi) == NGX_FILE_ERROR) {
            ngx_log_error(NGX_LOG_ALERT, cf->log, ngx_errno,
                          ngx_fd_info_n "" \""%s\"" failed"", from);

            goto failed;
 ...",1,1,core\ngx_file.c,ngx_copy_file,,false,794,924,ngx_copy_file,,,22,"ngx_int_t ngx_copy_file (u_char*,u_char*,ngx_copy_file_t*)"
17972,METHOD,core\ngx_file.c:<global>,TYPE_DECL,"ngx_int_t
ngx_walk_tree(ngx_tree_ctx_t *ctx, ngx_str_t *tree)
{
    void       *data, *prev;
    u_char     *p, *name;
    size_t      len;
    ngx_int_t   rc;
    ngx_err_t   err;
    ngx_str_t   file, buf;
    ngx_dir_t   dir;

    ngx_str_null(&buf);

    ngx_log_debug1(NGX_LOG_DEBUG_CORE, ctx->log, 0,
                   ""walk tree \""%V\"""", tree);

    if (ngx_open_dir(tree, &dir) == NGX_ERROR) {
        ngx_log_error(NGX_LOG_CRIT, ctx->log, ngx_errno,
                      ngx_open_dir_n "" \""%s\"" failed"", tree->data);
        return NGX_ERROR;
    }

    prev = ctx->data;

    if (ctx->alloc) {
        data = ngx_alloc(ctx->alloc, ctx->log);
        if (data == NULL) {
            goto failed;
        }

        if (ctx->init_handler(data, prev) == NGX_ABORT) {
            goto failed;
        }

        ctx->data = data;

    } else {
        data = NULL;
    }

    for ( ;; ) {

        ngx_set_errno(0);

        if (ngx_read_dir(&dir) == NGX_ERROR) {
            err = ngx_err...",1,1,core\ngx_file.c,ngx_walk_tree,,false,945,1128,ngx_walk_tree,,,23,"ngx_int_t ngx_walk_tree (ngx_tree_ctx_t*,ngx_str_t*)"
18471,METHOD,core\ngx_file.h:<global>,TYPE_DECL,<global>,1,37,core\ngx_file.h,core\ngx_file.h:<global>,,false,1,164,<global>,,,1,
18480,METHOD,ngx_file_s,TYPE_DECL,"ngx_int_t                (*thread_handler)(ngx_thread_task_t *task,
                                               ngx_file_t *file);",30,64,core\ngx_file.h,ngx_file_s.thread_handler,,false,27,28,thread_handler,,,7,"ngx_int_t ngx_file_s.thread_handler (ngx_thread_task_t*,ngx_file_t*)"
18491,METHOD,core\ngx_file.h:<global>,TYPE_DECL,typedef ngx_msec_t (*ngx_path_manager_pt) (void *data);,20,54,core\ngx_file.h,ngx_path_manager_pt,,false,45,45,ngx_path_manager_pt,,,2,ngx_msec_t ngx_path_manager_pt (void*)
18496,METHOD,core\ngx_file.h:<global>,TYPE_DECL,typedef ngx_msec_t (*ngx_path_purger_pt) (void *data);,20,53,core\ngx_file.h,ngx_path_purger_pt,,false,46,46,ngx_path_purger_pt,,,3,ngx_msec_t ngx_path_purger_pt (void*)
18501,METHOD,core\ngx_file.h:<global>,TYPE_DECL,typedef void (*ngx_path_loader_pt) (void *data);,14,47,core\ngx_file.h,ngx_path_loader_pt,,false,47,47,ngx_path_loader_pt,,,4,void ngx_path_loader_pt (void*)
18516,METHOD,<empty>,<empty>,<empty>,1,,core\ngx_file.h,ngx_path_t:<clinit>,,false,50,,<clinit>,,,10,
18528,METHOD,<empty>,<empty>,<empty>,1,,core\ngx_file.h,ngx_path_init_t:<clinit>,,false,65,,<clinit>,,,3,
18567,METHOD,core\ngx_file.h:<global>,TYPE_DECL,"typedef ngx_int_t (*ngx_tree_init_handler_pt) (void *ctx, void *prev);",19,69,core\ngx_file.h,ngx_tree_init_handler_pt,,false,113,113,ngx_tree_init_handler_pt,,,17,"ngx_int_t ngx_tree_init_handler_pt (void*,void*)"
18573,METHOD,core\ngx_file.h:<global>,TYPE_DECL,"typedef ngx_int_t (*ngx_tree_handler_pt) (ngx_tree_ctx_t *ctx, ngx_str_t *name);",19,79,core\ngx_file.h,ngx_tree_handler_pt,,false,114,114,ngx_tree_handler_pt,,,18,"ngx_int_t ngx_tree_handler_pt (ngx_tree_ctx_t*,ngx_str_t*)"
18592,METHOD,core\ngx_file.h:<global>,TYPE_DECL,"ngx_int_t ngx_get_full_name(ngx_pool_t *pool, ngx_str_t *prefix,
    ngx_str_t *name);",11,20,core\ngx_file.h,ngx_get_full_name,,false,135,136,ngx_get_full_name,,,20,"ngx_int_t ngx_get_full_name (ngx_pool_t*,ngx_str_t*,ngx_str_t*)"
18599,METHOD,core\ngx_file.h:<global>,TYPE_DECL,"ssize_t ngx_write_chain_to_temp_file(ngx_temp_file_t *tf, ngx_chain_t *chain);",9,77,core\ngx_file.h,ngx_write_chain_to_temp_file,,false,138,138,ngx_write_chain_to_temp_file,,,21,"ssize_t ngx_write_chain_to_temp_file (ngx_temp_file_t*,ngx_chain_t*)"
18605,METHOD,core\ngx_file.h:<global>,TYPE_DECL,"ngx_int_t ngx_create_temp_file(ngx_file_t *file, ngx_path_t *path,
    ngx_pool_t *pool, ngx_uint_t persistent, ngx_uint_t clean,
    ngx_uint_t access);",11,22,core\ngx_file.h,ngx_create_temp_file,,false,139,141,ngx_create_temp_file,,,22,"ngx_int_t ngx_create_temp_file (ngx_file_t*,ngx_path_t*,ngx_pool_t*,ngx_uint_t,ngx_uint_t,ngx_uint_t)"
18615,METHOD,core\ngx_file.h:<global>,TYPE_DECL,"void ngx_create_hashed_filename(ngx_path_t *path, u_char *file, size_t len);",6,75,core\ngx_file.h,ngx_create_hashed_filename,,false,142,142,ngx_create_hashed_filename,,,23,"void ngx_create_hashed_filename (ngx_path_t*,u_char*,size_t)"
18622,METHOD,core\ngx_file.h:<global>,TYPE_DECL,"ngx_int_t ngx_create_path(ngx_file_t *file, ngx_path_t *path);",11,61,core\ngx_file.h,ngx_create_path,,false,143,143,ngx_create_path,,,24,"ngx_int_t ngx_create_path (ngx_file_t*,ngx_path_t*)"
18628,METHOD,core\ngx_file.h:<global>,TYPE_DECL,"ngx_err_t ngx_create_full_path(u_char *dir, ngx_uint_t access);",11,62,core\ngx_file.h,ngx_create_full_path,,false,144,144,ngx_create_full_path,,,25,"ngx_err_t ngx_create_full_path (u_char*,ngx_uint_t)"
18634,METHOD,core\ngx_file.h:<global>,TYPE_DECL,"ngx_int_t ngx_add_path(ngx_conf_t *cf, ngx_path_t **slot);",11,57,core\ngx_file.h,ngx_add_path,,false,145,145,ngx_add_path,,,26,"ngx_int_t ngx_add_path (ngx_conf_t*,ngx_path_t**)"
18640,METHOD,core\ngx_file.h:<global>,TYPE_DECL,"ngx_int_t ngx_create_paths(ngx_cycle_t *cycle, ngx_uid_t user);",11,62,core\ngx_file.h,ngx_create_paths,,false,146,146,ngx_create_paths,,,27,"ngx_int_t ngx_create_paths (ngx_cycle_t*,ngx_uid_t)"
18646,METHOD,core\ngx_file.h:<global>,TYPE_DECL,"ngx_int_t ngx_ext_rename_file(ngx_str_t *src, ngx_str_t *to,
    ngx_ext_rename_file_t *ext);",11,31,core\ngx_file.h,ngx_ext_rename_file,,false,147,148,ngx_ext_rename_file,,,28,"ngx_int_t ngx_ext_rename_file (ngx_str_t*,ngx_str_t*,ngx_ext_rename_file_t*)"
18653,METHOD,core\ngx_file.h:<global>,TYPE_DECL,"ngx_int_t ngx_copy_file(u_char *from, u_char *to, ngx_copy_file_t *cf);",11,70,core\ngx_file.h,ngx_copy_file,,false,149,149,ngx_copy_file,,,29,"ngx_int_t ngx_copy_file (u_char*,u_char*,ngx_copy_file_t*)"
18660,METHOD,core\ngx_file.h:<global>,TYPE_DECL,"ngx_int_t ngx_walk_tree(ngx_tree_ctx_t *ctx, ngx_str_t *tree);",11,61,core\ngx_file.h,ngx_walk_tree,,false,150,150,ngx_walk_tree,,,30,"ngx_int_t ngx_walk_tree (ngx_tree_ctx_t*,ngx_str_t*)"
18666,METHOD,core\ngx_file.h:<global>,TYPE_DECL,ngx_atomic_uint_t ngx_next_temp_number(ngx_uint_t collision);,19,60,core\ngx_file.h,ngx_next_temp_number,,false,152,152,ngx_next_temp_number,,,31,ngx_atomic_uint_t ngx_next_temp_number (ngx_uint_t)
18671,METHOD,core\ngx_file.h:<global>,TYPE_DECL,"char *ngx_conf_set_path_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",6,76,core\ngx_file.h,ngx_conf_set_path_slot,,false,154,154,ngx_conf_set_path_slot,,,32,"char* ngx_conf_set_path_slot (ngx_conf_t*,ngx_command_t*,void*)"
18678,METHOD,core\ngx_file.h:<global>,TYPE_DECL,"char *ngx_conf_merge_path_value(ngx_conf_t *cf, ngx_path_t **path,
    ngx_path_t *prev, ngx_path_init_t *init);",6,44,core\ngx_file.h,ngx_conf_merge_path_value,,false,155,156,ngx_conf_merge_path_value,,,33,"char* ngx_conf_merge_path_value (ngx_conf_t*,ngx_path_t**,ngx_path_t*,ngx_path_init_t*)"
18686,METHOD,core\ngx_file.h:<global>,TYPE_DECL,"char *ngx_conf_set_access_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",6,78,core\ngx_file.h,ngx_conf_set_access_slot,,false,157,157,ngx_conf_set_access_slot,,,34,"char* ngx_conf_set_access_slot (ngx_conf_t*,ngx_command_t*,void*)"
18702,METHOD,core\ngx_hash.c:<global>,TYPE_DECL,<global>,1,33,core\ngx_hash.c,core\ngx_hash.c:<global>,,false,1,1009,<global>,,,1,
18704,METHOD,core\ngx_hash.c:<global>,TYPE_DECL,"void *
ngx_hash_find(ngx_hash_t *hash, ngx_uint_t key, u_char *name, size_t len)
{
    ngx_uint_t       i;
    ngx_hash_elt_t  *elt;

#if 0
    ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, 0, ""hf:\""%*s\"""", len, name);
#endif

    elt = hash->buckets[key % hash->size];

    if (elt == NULL) {
        return NULL;
    }

    while (elt->value) {
        if (len != (size_t) elt->len) {
            goto next;
        }

        for (i = 0; i < len; i++) {
            if (name[i] != elt->name[i]) {
                goto next;
            }
        }

        return elt->value;

    next:

        elt = (ngx_hash_elt_t *) ngx_align_ptr(&elt->name[0] + elt->len,
                                               sizeof(void *));
        continue;
    }

    return NULL;
}",1,1,core\ngx_hash.c,ngx_hash_find,,false,12,49,ngx_hash_find,,,1,"void* ngx_hash_find (ngx_hash_t*,ngx_uint_t,u_char*,size_t)"
18795,METHOD,core\ngx_hash.c:<global>,TYPE_DECL,"void *
ngx_hash_find_wc_head(ngx_hash_wildcard_t *hwc, u_char *name, size_t len)
{
    void        *value;
    ngx_uint_t   i, n, key;

#if 0
    ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, 0, ""wch:\""%*s\"""", len, name);
#endif

    n = len;

    while (n) {
        if (name[n - 1] == '.') {
            break;
        }

        n--;
    }

    key = 0;

    for (i = n; i < len; i++) {
        key = ngx_hash(key, name[i]);
    }

#if 0
    ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, 0, ""key:\""%ui\"""", key);
#endif

    value = ngx_hash_find(&hwc->hash, key, &name[n], len - n);

#if 0
    ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, 0, ""value:\""%p\"""", value);
#endif

    if (value) {

        /*
         * the 2 low bits of value have the special meaning:
         *     00 - value is data pointer for both ""example.com""
         *          and ""*.example.com"";
         *     01 - value is data pointer for ""*.example.com"" only;
         *     10 - value is pointer to wildcard hash allo...",1,1,core\ngx_hash.c,ngx_hash_find_wc_head,,false,52,143,ngx_hash_find_wc_head,,,2,"void* ngx_hash_find_wc_head (ngx_hash_wildcard_t*,u_char*,size_t)"
18960,METHOD,core\ngx_hash.c:<global>,TYPE_DECL,"void *
ngx_hash_find_wc_tail(ngx_hash_wildcard_t *hwc, u_char *name, size_t len)
{
    void        *value;
    ngx_uint_t   i, key;

#if 0
    ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, 0, ""wct:\""%*s\"""", len, name);
#endif

    key = 0;

    for (i = 0; i < len; i++) {
        if (name[i] == '.') {
            break;
        }

        key = ngx_hash(key, name[i]);
    }

    if (i == len) {
        return NULL;
    }

#if 0
    ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, 0, ""key:\""%ui\"""", key);
#endif

    value = ngx_hash_find(&hwc->hash, key, name, i);

#if 0
    ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, 0, ""value:\""%p\"""", value);
#endif

    if (value) {

        /*
         * the 2 low bits of value have the special meaning:
         *     00 - value is data pointer;
         *     11 - value is pointer to wildcard hash allowing ""example.*"".
         */

        if ((uintptr_t) value & 2) {

            i++;

            hwc = (ngx_hash_wildcard_t *) ((uintptr_t) value & ...",1,1,core\ngx_hash.c,ngx_hash_find_wc_tail,,false,146,207,ngx_hash_find_wc_tail,,,3,"void* ngx_hash_find_wc_tail (ngx_hash_wildcard_t*,u_char*,size_t)"
19066,METHOD,core\ngx_hash.c:<global>,TYPE_DECL,"void *
ngx_hash_find_combined(ngx_hash_combined_t *hash, ngx_uint_t key, u_char *name,
    size_t len)
{
    void  *value;

    if (hash->hash.buckets) {
        value = ngx_hash_find(&hash->hash, key, name, len);

        if (value) {
            return value;
        }
    }

    if (len == 0) {
        return NULL;
    }

    if (hash->wc_head && hash->wc_head->hash.buckets) {
        value = ngx_hash_find_wc_head(hash->wc_head, name, len);

        if (value) {
            return value;
        }
    }

    if (hash->wc_tail && hash->wc_tail->hash.buckets) {
        value = ngx_hash_find_wc_tail(hash->wc_tail, name, len);

        if (value) {
            return value;
        }
    }

    return NULL;
}",1,1,core\ngx_hash.c,ngx_hash_find_combined,,false,210,245,ngx_hash_find_combined,,,4,"void* ngx_hash_find_combined (ngx_hash_combined_t*,ngx_uint_t,u_char*,size_t)"
19158,METHOD,core\ngx_hash.c:<global>,TYPE_DECL,"ngx_int_t
ngx_hash_init(ngx_hash_init_t *hinit, ngx_hash_key_t *names, ngx_uint_t nelts)
{
    u_char          *elts;
    size_t           len;
    u_short         *test;
    ngx_uint_t       i, n, key, size, start, bucket_size;
    ngx_hash_elt_t  *elt, **buckets;

    if (hinit->max_size == 0) {
        ngx_log_error(NGX_LOG_EMERG, hinit->pool->log, 0,
                      ""could not build %s, you should ""
                      ""increase %s_max_size: %i"",
                      hinit->name, hinit->name, hinit->max_size);
        return NGX_ERROR;
    }

    if (hinit->bucket_size > 65536 - ngx_cacheline_size) {
        ngx_log_error(NGX_LOG_EMERG, hinit->pool->log, 0,
                      ""could not build %s, too large ""
                      ""%s_bucket_size: %i"",
                      hinit->name, hinit->name, hinit->bucket_size);
        return NGX_ERROR;
    }

    for (n = 0; n < nelts; n++) {
        if (hinit->bucket_size < NGX_HASH_ELT_SIZE(&names[n]) + sizeof(void *))
   ...",1,33,core\ngx_hash.c,ngx_hash_init,,false,251,482,ngx_hash_init,,,5,"ngx_int_t ngx_hash_init (ngx_hash_init_t*,ngx_hash_key_t*,ngx_uint_t)"
19950,METHOD,core\ngx_hash.c:<global>,TYPE_DECL,"ngx_int_t
ngx_hash_wildcard_init(ngx_hash_init_t *hinit, ngx_hash_key_t *names,
    ngx_uint_t nelts)
{
    size_t                len, dot_len;
    ngx_uint_t            i, n, dot;
    ngx_array_t           curr_names, next_names;
    ngx_hash_key_t       *name, *next_name;
    ngx_hash_init_t       h;
    ngx_hash_wildcard_t  *wdc;

    if (ngx_array_init(&curr_names, hinit->temp_pool, nelts,
                       sizeof(ngx_hash_key_t))
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    if (ngx_array_init(&next_names, hinit->temp_pool, nelts,
                       sizeof(ngx_hash_key_t))
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    for (n = 0; n < nelts; n = i) {

#if 0
        ngx_log_error(NGX_LOG_ALERT, hinit->pool->log, 0,
                      ""wc0: \""%V\"""", &names[n].key);
#endif

        dot = 0;

        for (len = 0; len < names[n].key.len; len++) {
            if (names[n].key.data[len] == '.') {
                dot = 1;
                brea...",1,1,core\ngx_hash.c,ngx_hash_wildcard_init,,false,485,627,ngx_hash_wildcard_init,,,6,"ngx_int_t ngx_hash_wildcard_init (ngx_hash_init_t*,ngx_hash_key_t*,ngx_uint_t)"
20413,METHOD,core\ngx_hash.c:<global>,TYPE_DECL,"ngx_uint_t
ngx_hash_key(u_char *data, size_t len)
{
    ngx_uint_t  i, key;

    key = 0;

    for (i = 0; i < len; i++) {
        key = ngx_hash(key, data[i]);
    }

    return key;
}",1,1,core\ngx_hash.c,ngx_hash_key,,false,630,642,ngx_hash_key,,,7,"ngx_uint_t ngx_hash_key (u_char*,size_t)"
20444,METHOD,core\ngx_hash.c:<global>,TYPE_DECL,"ngx_uint_t
ngx_hash_key_lc(u_char *data, size_t len)
{
    ngx_uint_t  i, key;

    key = 0;

    for (i = 0; i < len; i++) {
        key = ngx_hash(key, ngx_tolower(data[i]));
    }

    return key;
}",1,1,core\ngx_hash.c,ngx_hash_key_lc,,false,645,657,ngx_hash_key_lc,,,8,"ngx_uint_t ngx_hash_key_lc (u_char*,size_t)"
20476,METHOD,core\ngx_hash.c:<global>,TYPE_DECL,"ngx_uint_t
ngx_hash_strlow(u_char *dst, u_char *src, size_t n)
{
    ngx_uint_t  key;

    key = 0;

    while (n--) {
        *dst = ngx_tolower(*src);
        key = ngx_hash(key, *dst);
        dst++;
        src++;
    }

    return key;
}",1,1,core\ngx_hash.c,ngx_hash_strlow,,false,660,675,ngx_hash_strlow,,,9,"ngx_uint_t ngx_hash_strlow (u_char*,u_char*,size_t)"
20509,METHOD,core\ngx_hash.c:<global>,TYPE_DECL,"ngx_int_t
ngx_hash_keys_array_init(ngx_hash_keys_arrays_t *ha, ngx_uint_t type)
{
    ngx_uint_t  asize;

    if (type == NGX_HASH_SMALL) {
        asize = 4;
        ha->hsize = 107;

    } else {
        asize = NGX_HASH_LARGE_ASIZE;
        ha->hsize = NGX_HASH_LARGE_HSIZE;
    }

    if (ngx_array_init(&ha->keys, ha->temp_pool, asize, sizeof(ngx_hash_key_t))
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    if (ngx_array_init(&ha->dns_wc_head, ha->temp_pool, asize,
                       sizeof(ngx_hash_key_t))
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    if (ngx_array_init(&ha->dns_wc_tail, ha->temp_pool, asize,
                       sizeof(ngx_hash_key_t))
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    ha->keys_hash = ngx_pcalloc(ha->temp_pool, sizeof(ngx_array_t) * ha->hsize);
    if (ha->keys_hash == NULL) {
        return NGX_ERROR;
    }

    ha->dns_wc_head_hash = ngx_pcalloc(ha->temp_pool,
                                     ...",1,1,core\ngx_hash.c,ngx_hash_keys_array_init,,false,678,730,ngx_hash_keys_array_init,,,10,"ngx_int_t ngx_hash_keys_array_init (ngx_hash_keys_arrays_t*,ngx_uint_t)"
20661,METHOD,core\ngx_hash.c:<global>,TYPE_DECL,"ngx_int_t
ngx_hash_add_key(ngx_hash_keys_arrays_t *ha, ngx_str_t *key, void *value,
    ngx_uint_t flags)
{
    size_t           len;
    u_char          *p;
    ngx_str_t       *name;
    ngx_uint_t       i, k, n, skip, last;
    ngx_array_t     *keys, *hwc;
    ngx_hash_key_t  *hk;

    last = key->len;

    if (flags & NGX_HASH_WILDCARD_KEY) {

        /*
         * supported wildcards:
         *     ""*.example.com"", "".example.com"", and ""www.example.*""
         */

        n = 0;

        for (i = 0; i < key->len; i++) {

            if (key->data[i] == '*') {
                if (++n > 1) {
                    return NGX_DECLINED;
                }
            }

            if (key->data[i] == '.' && key->data[i + 1] == '.') {
                return NGX_DECLINED;
            }

            if (key->data[i] == '\0') {
                return NGX_DECLINED;
            }
        }

        if (key->len > 1 && key->data[0] == '.') {
            skip = 1;
            goto wildcard;
 ...",1,1,core\ngx_hash.c,ngx_hash_add_key,,false,733,1009,ngx_hash_add_key,,,11,"ngx_int_t ngx_hash_add_key (ngx_hash_keys_arrays_t*,ngx_str_t*,void*,ngx_uint_t)"
21496,METHOD,core\ngx_hash.h:<global>,TYPE_DECL,<global>,1,34,core\ngx_hash.h,core\ngx_hash.h:<global>,,false,1,122,<global>,,,1,
21502,METHOD,<empty>,<empty>,<empty>,1,,core\ngx_hash.h,ngx_hash_elt_t:<clinit>,,false,16,,<clinit>,,,4,
21522,METHOD,core\ngx_hash.h:<global>,TYPE_DECL,"typedef ngx_uint_t (*ngx_hash_key_pt) (u_char *data, size_t len);",20,64,core\ngx_hash.h,ngx_hash_key_pt,,false,42,42,ngx_hash_key_pt,,,9,"ngx_uint_t ngx_hash_key_pt (u_char*,size_t)"
21559,METHOD,core\ngx_hash.h:<global>,TYPE_DECL,"void *ngx_hash_find(ngx_hash_t *hash, ngx_uint_t key, u_char *name, size_t len);",6,79,core\ngx_hash.h,ngx_hash_find,,false,100,100,ngx_hash_find,,,18,"void* ngx_hash_find (ngx_hash_t*,ngx_uint_t,u_char*,size_t)"
21567,METHOD,core\ngx_hash.h:<global>,TYPE_DECL,"void *ngx_hash_find_wc_head(ngx_hash_wildcard_t *hwc, u_char *name, size_t len);",6,79,core\ngx_hash.h,ngx_hash_find_wc_head,,false,101,101,ngx_hash_find_wc_head,,,19,"void* ngx_hash_find_wc_head (ngx_hash_wildcard_t*,u_char*,size_t)"
21574,METHOD,core\ngx_hash.h:<global>,TYPE_DECL,"void *ngx_hash_find_wc_tail(ngx_hash_wildcard_t *hwc, u_char *name, size_t len);",6,79,core\ngx_hash.h,ngx_hash_find_wc_tail,,false,102,102,ngx_hash_find_wc_tail,,,20,"void* ngx_hash_find_wc_tail (ngx_hash_wildcard_t*,u_char*,size_t)"
21581,METHOD,core\ngx_hash.h:<global>,TYPE_DECL,"void *ngx_hash_find_combined(ngx_hash_combined_t *hash, ngx_uint_t key,
    u_char *name, size_t len);",6,29,core\ngx_hash.h,ngx_hash_find_combined,,false,103,104,ngx_hash_find_combined,,,21,"void* ngx_hash_find_combined (ngx_hash_combined_t*,ngx_uint_t,u_char*,size_t)"
21589,METHOD,core\ngx_hash.h:<global>,TYPE_DECL,"ngx_int_t ngx_hash_init(ngx_hash_init_t *hinit, ngx_hash_key_t *names,
    ngx_uint_t nelts);",11,21,core\ngx_hash.h,ngx_hash_init,,false,106,107,ngx_hash_init,,,22,"ngx_int_t ngx_hash_init (ngx_hash_init_t*,ngx_hash_key_t*,ngx_uint_t)"
21596,METHOD,core\ngx_hash.h:<global>,TYPE_DECL,"ngx_int_t ngx_hash_wildcard_init(ngx_hash_init_t *hinit, ngx_hash_key_t *names,
    ngx_uint_t nelts);",11,21,core\ngx_hash.h,ngx_hash_wildcard_init,,false,108,109,ngx_hash_wildcard_init,,,23,"ngx_int_t ngx_hash_wildcard_init (ngx_hash_init_t*,ngx_hash_key_t*,ngx_uint_t)"
21603,METHOD,core\ngx_hash.h:<global>,TYPE_DECL,"ngx_uint_t ngx_hash_key(u_char *data, size_t len);",12,49,core\ngx_hash.h,ngx_hash_key,,false,112,112,ngx_hash_key,,,24,"ngx_uint_t ngx_hash_key (u_char*,size_t)"
21609,METHOD,core\ngx_hash.h:<global>,TYPE_DECL,"ngx_uint_t ngx_hash_key_lc(u_char *data, size_t len);",12,52,core\ngx_hash.h,ngx_hash_key_lc,,false,113,113,ngx_hash_key_lc,,,25,"ngx_uint_t ngx_hash_key_lc (u_char*,size_t)"
21615,METHOD,core\ngx_hash.h:<global>,TYPE_DECL,"ngx_uint_t ngx_hash_strlow(u_char *dst, u_char *src, size_t n);",12,62,core\ngx_hash.h,ngx_hash_strlow,,false,114,114,ngx_hash_strlow,,,26,"ngx_uint_t ngx_hash_strlow (u_char*,u_char*,size_t)"
21622,METHOD,core\ngx_hash.h:<global>,TYPE_DECL,"ngx_int_t ngx_hash_keys_array_init(ngx_hash_keys_arrays_t *ha, ngx_uint_t type);",11,79,core\ngx_hash.h,ngx_hash_keys_array_init,,false,117,117,ngx_hash_keys_array_init,,,27,"ngx_int_t ngx_hash_keys_array_init (ngx_hash_keys_arrays_t*,ngx_uint_t)"
21628,METHOD,core\ngx_hash.h:<global>,TYPE_DECL,"ngx_int_t ngx_hash_add_key(ngx_hash_keys_arrays_t *ha, ngx_str_t *key,
    void *value, ngx_uint_t flags);",11,34,core\ngx_hash.h,ngx_hash_add_key,,false,118,119,ngx_hash_add_key,,,28,"ngx_int_t ngx_hash_add_key (ngx_hash_keys_arrays_t*,ngx_str_t*,void*,ngx_uint_t)"
21643,METHOD,core\ngx_inet.c:<global>,TYPE_DECL,<global>,1,1,core\ngx_inet.c,core\ngx_inet.c:<global>,,false,1,1495,<global>,,,1,
21645,METHOD,core\ngx_inet.c:<global>,TYPE_DECL,"static ngx_int_t ngx_parse_unix_domain_url(ngx_pool_t *pool, ngx_url_t *u);",18,74,core\ngx_inet.c,ngx_parse_unix_domain_url,,false,12,12,ngx_parse_unix_domain_url,,,1,"ngx_int_t ngx_parse_unix_domain_url (ngx_pool_t*,ngx_url_t*)"
21651,METHOD,core\ngx_inet.c:<global>,TYPE_DECL,"static ngx_int_t ngx_parse_inet_url(ngx_pool_t *pool, ngx_url_t *u);",18,67,core\ngx_inet.c,ngx_parse_inet_url,,false,13,13,ngx_parse_inet_url,,,2,"ngx_int_t ngx_parse_inet_url (ngx_pool_t*,ngx_url_t*)"
21657,METHOD,core\ngx_inet.c:<global>,TYPE_DECL,"static ngx_int_t ngx_parse_inet6_url(ngx_pool_t *pool, ngx_url_t *u);",18,68,core\ngx_inet.c,ngx_parse_inet6_url,,false,14,14,ngx_parse_inet6_url,,,3,"ngx_int_t ngx_parse_inet6_url (ngx_pool_t*,ngx_url_t*)"
21663,METHOD,core\ngx_inet.c:<global>,TYPE_DECL,"static ngx_int_t ngx_inet_add_addr(ngx_pool_t *pool, ngx_url_t *u,
    struct sockaddr *sockaddr, socklen_t socklen, ngx_uint_t total);",18,67,core\ngx_inet.c,ngx_inet_add_addr,,false,15,16,ngx_inet_add_addr,,,4,"ngx_int_t ngx_inet_add_addr (ngx_pool_t*,ngx_url_t*,sockaddr*,socklen_t,ngx_uint_t)"
21672,METHOD,core\ngx_inet.c:<global>,TYPE_DECL,"in_addr_t
ngx_inet_addr(u_char *text, size_t len)
{
    u_char      *p, c;
    in_addr_t    addr;
    ngx_uint_t   octet, n;

    addr = 0;
    octet = 0;
    n = 0;

    for (p = text; p < text + len; p++) {
        c = *p;

        if (c >= '0' && c <= '9') {
            octet = octet * 10 + (c - '0');

            if (octet > 255) {
                return INADDR_NONE;
            }

            continue;
        }

        if (c == '.') {
            addr = (addr << 8) + octet;
            octet = 0;
            n++;
            continue;
        }

        return INADDR_NONE;
    }

    if (n == 3) {
        addr = (addr << 8) + octet;
        return htonl(addr);
    }

    return INADDR_NONE;
}",1,1,core\ngx_inet.c,ngx_inet_addr,,false,19,59,ngx_inet_addr,,,5,"in_addr_t ngx_inet_addr (u_char*,size_t)"
21772,METHOD,core\ngx_inet.c:<global>,TYPE_DECL,"size_t
ngx_sock_ntop(struct sockaddr *sa, socklen_t socklen, u_char *text, size_t len,
    ngx_uint_t port)
{
    u_char               *p;
#if (NGX_HAVE_INET6 || NGX_HAVE_UNIX_DOMAIN)
    size_t                n;
#endif
    struct sockaddr_in   *sin;
#if (NGX_HAVE_INET6)
    struct sockaddr_in6  *sin6;
#endif
#if (NGX_HAVE_UNIX_DOMAIN)
    struct sockaddr_un   *saun;
#endif

    switch (sa->sa_family) {

    case AF_INET:

        sin = (struct sockaddr_in *) sa;
        p = (u_char *) &sin->sin_addr;

        if (port) {
            p = ngx_snprintf(text, len, ""%ud.%ud.%ud.%ud:%d"",
                             p[0], p[1], p[2], p[3], ntohs(sin->sin_port));
        } else {
            p = ngx_snprintf(text, len, ""%ud.%ud.%ud.%ud"",
                             p[0], p[1], p[2], p[3]);
        }

        return (p - text);

#if (NGX_HAVE_INET6)

    case AF_INET6:

        sin6 = (struct sockaddr_in6 *) sa;

        n = 0;

        if (port) {
            text[n++] = '[';
        }

...",1,1,core\ngx_inet.c,ngx_sock_ntop,,false,182,262,ngx_sock_ntop,,,6,"size_t ngx_sock_ntop (sockaddr*,socklen_t,u_char*,size_t,ngx_uint_t)"
21855,METHOD,core\ngx_inet.c:<global>,TYPE_DECL,"size_t
ngx_inet_ntop(int family, void *addr, u_char *text, size_t len)
{
    u_char  *p;

    switch (family) {

    case AF_INET:

        p = addr;

        return ngx_snprintf(text, len, ""%ud.%ud.%ud.%ud"",
                            p[0], p[1], p[2], p[3])
               - text;

#if (NGX_HAVE_INET6)

    case AF_INET6:
        return ngx_inet6_ntop(addr, text, len);

#endif

    default:
        return 0;
    }
}",1,1,core\ngx_inet.c,ngx_inet_ntop,,false,265,290,ngx_inet_ntop,,,7,"size_t ngx_inet_ntop (int,void*,u_char*,size_t)"
21894,METHOD,core\ngx_inet.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ptocidr(ngx_str_t *text, ngx_cidr_t *cidr)
{
    u_char      *addr, *mask, *last;
    size_t       len;
    ngx_int_t    shift;
#if (NGX_HAVE_INET6)
    ngx_int_t    rc;
    ngx_uint_t   s, i;
#endif

    addr = text->data;
    last = addr + text->len;

    mask = ngx_strlchr(addr, last, '/');
    len = (mask ? mask : last) - addr;

    cidr->u.in.addr = ngx_inet_addr(addr, len);

    if (cidr->u.in.addr != INADDR_NONE) {
        cidr->family = AF_INET;

        if (mask == NULL) {
            cidr->u.in.mask = 0xffffffff;
            return NGX_OK;
        }

#if (NGX_HAVE_INET6)
    } else if (ngx_inet6_addr(addr, len, cidr->u.in6.addr.s6_addr) == NGX_OK) {
        cidr->family = AF_INET6;

        if (mask == NULL) {
            ngx_memset(cidr->u.in6.mask.s6_addr, 0xff, 16);
            return NGX_OK;
        }

#endif
    } else {
        return NGX_ERROR;
    }

    mask++;

    shift = ngx_atoi(mask, last - mask);
    if (shift == NGX_ERROR) {
        return NGX...",1,1,core\ngx_inet.c,ngx_ptocidr,,false,374,471,ngx_ptocidr,,,8,"ngx_int_t ngx_ptocidr (ngx_str_t*,ngx_cidr_t*)"
22080,METHOD,core\ngx_inet.c:<global>,TYPE_DECL,"ngx_int_t
ngx_cidr_match(struct sockaddr *sa, ngx_array_t *cidrs)
{
#if (NGX_HAVE_INET6)
    u_char           *p;
#endif
    in_addr_t         inaddr;
    ngx_cidr_t       *cidr;
    ngx_uint_t        family, i;
#if (NGX_HAVE_INET6)
    ngx_uint_t        n;
    struct in6_addr  *inaddr6;
#endif

#if (NGX_SUPPRESS_WARN)
    inaddr = 0;
#if (NGX_HAVE_INET6)
    inaddr6 = NULL;
#endif
#endif

    family = sa->sa_family;

    if (family == AF_INET) {
        inaddr = ((struct sockaddr_in *) sa)->sin_addr.s_addr;
    }

#if (NGX_HAVE_INET6)
    else if (family == AF_INET6) {
        inaddr6 = &((struct sockaddr_in6 *) sa)->sin6_addr;

        if (IN6_IS_ADDR_V4MAPPED(inaddr6)) {
            family = AF_INET;

            p = inaddr6->s6_addr;

            inaddr = p[12] << 24;
            inaddr += p[13] << 16;
            inaddr += p[14] << 8;
            inaddr += p[15];

            inaddr = htonl(inaddr);
        }
    }
#endif

    for (cidr = cidrs->elts, i = 0; i < cidrs->nelts; i...",1,1,core\ngx_inet.c,ngx_cidr_match,,false,474,558,ngx_cidr_match,,,9,"ngx_int_t ngx_cidr_match (sockaddr*,ngx_array_t*)"
22173,METHOD,core\ngx_inet.c:<global>,TYPE_DECL,"ngx_int_t
ngx_parse_addr(ngx_pool_t *pool, ngx_addr_t *addr, u_char *text, size_t len)
{
    in_addr_t             inaddr;
    ngx_uint_t            family;
    struct sockaddr_in   *sin;
#if (NGX_HAVE_INET6)
    struct in6_addr       inaddr6;
    struct sockaddr_in6  *sin6;

    /*
     * prevent MSVC8 warning:
     *    potentially uninitialized local variable 'inaddr6' used
     */
    ngx_memzero(&inaddr6, sizeof(struct in6_addr));
#endif

    inaddr = ngx_inet_addr(text, len);

    if (inaddr != INADDR_NONE) {
        family = AF_INET;
        len = sizeof(struct sockaddr_in);

#if (NGX_HAVE_INET6)
    } else if (ngx_inet6_addr(text, len, inaddr6.s6_addr) == NGX_OK) {
        family = AF_INET6;
        len = sizeof(struct sockaddr_in6);

#endif
    } else {
        return NGX_DECLINED;
    }

    addr->sockaddr = ngx_pcalloc(pool, len);
    if (addr->sockaddr == NULL) {
        return NGX_ERROR;
    }

    addr->sockaddr->sa_family = (u_char) family;
    addr->socklen = len;

 ...",1,1,core\ngx_inet.c,ngx_parse_addr,,false,561,618,ngx_parse_addr,,,10,"ngx_int_t ngx_parse_addr (ngx_pool_t*,ngx_addr_t*,u_char*,size_t)"
22256,METHOD,core\ngx_inet.c:<global>,TYPE_DECL,"ngx_int_t
ngx_parse_addr_port(ngx_pool_t *pool, ngx_addr_t *addr, u_char *text,
    size_t len)
{
    u_char     *p, *last;
    size_t      plen;
    ngx_int_t   rc, port;

    rc = ngx_parse_addr(pool, addr, text, len);

    if (rc != NGX_DECLINED) {
        return rc;
    }

    last = text + len;

#if (NGX_HAVE_INET6)
    if (len && text[0] == '[') {

        p = ngx_strlchr(text, last, ']');

        if (p == NULL || p == last - 1 || *++p != ':') {
            return NGX_DECLINED;
        }

        text++;
        len -= 2;

    } else
#endif

    {
        p = ngx_strlchr(text, last, ':');

        if (p == NULL) {
            return NGX_DECLINED;
        }
    }

    p++;
    plen = last - p;

    port = ngx_atoi(p, plen);

    if (port < 1 || port > 65535) {
        return NGX_DECLINED;
    }

    len -= plen + 1;

    rc = ngx_parse_addr(pool, addr, text, len);

    if (rc != NGX_OK) {
        return rc;
    }

    ngx_inet_set_port(addr->sockaddr, (in_port_t) port);

    r...",1,1,core\ngx_inet.c,ngx_parse_addr_port,,false,621,680,ngx_parse_addr_port,,,11,"ngx_int_t ngx_parse_addr_port (ngx_pool_t*,ngx_addr_t*,u_char*,size_t)"
22353,METHOD,core\ngx_inet.c:<global>,TYPE_DECL,"ngx_int_t
ngx_parse_url(ngx_pool_t *pool, ngx_url_t *u)
{
    u_char  *p;
    size_t   len;

    p = u->url.data;
    len = u->url.len;

    if (len >= 5 && ngx_strncasecmp(p, (u_char *) ""unix:"", 5) == 0) {
        return ngx_parse_unix_domain_url(pool, u);
    }

    if (len && p[0] == '[') {
        return ngx_parse_inet6_url(pool, u);
    }

    return ngx_parse_inet_url(pool, u);
}",1,1,core\ngx_inet.c,ngx_parse_url,,false,683,701,ngx_parse_url,,,12,"ngx_int_t ngx_parse_url (ngx_pool_t*,ngx_url_t*)"
22410,METHOD,core\ngx_inet.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_parse_unix_domain_url(ngx_pool_t *pool, ngx_url_t *u)
{
#if (NGX_HAVE_UNIX_DOMAIN)
    u_char              *path, *uri, *last;
    size_t               len;
    struct sockaddr_un  *saun;

    len = u->url.len;
    path = u->url.data;

    path += 5;
    len -= 5;

    if (u->uri_part) {

        last = path + len;
        uri = ngx_strlchr(path, last, ':');

        if (uri) {
            len = uri - path;
            uri++;
            u->uri.len = last - uri;
            u->uri.data = uri;
        }
    }

    if (len == 0) {
        u->err = ""no path in the unix domain socket"";
        return NGX_ERROR;
    }

    u->host.len = len++;
    u->host.data = path;

    if (len > sizeof(saun->sun_path)) {
        u->err = ""too long path in the unix domain socket"";
        return NGX_ERROR;
    }

    u->socklen = sizeof(struct sockaddr_un);
    saun = (struct sockaddr_un *) &u->sockaddr;
    saun->sun_family = AF_UNIX;
    (void) ngx_cpystrn((u_char *) saun->sun_p...",1,1,core\ngx_inet.c,ngx_parse_unix_domain_url,,false,704,779,ngx_parse_unix_domain_url,,,13,"ngx_int_t ngx_parse_unix_domain_url (ngx_pool_t*,ngx_url_t*)"
22423,METHOD,core\ngx_inet.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_parse_inet_url(ngx_pool_t *pool, ngx_url_t *u)
{
    u_char              *host, *port, *last, *uri, *args, *dash;
    size_t               len;
    ngx_int_t            n;
    struct sockaddr_in  *sin;

    u->socklen = sizeof(struct sockaddr_in);
    sin = (struct sockaddr_in *) &u->sockaddr;
    sin->sin_family = AF_INET;

    u->family = AF_INET;

    host = u->url.data;

    last = host + u->url.len;

    port = ngx_strlchr(host, last, ':');

    uri = ngx_strlchr(host, last, '/');

    args = ngx_strlchr(host, last, '?');

    if (args) {
        if (uri == NULL || args < uri) {
            uri = args;
        }
    }

    if (uri) {
        if (u->listen || !u->uri_part) {
            u->err = ""invalid host"";
            return NGX_ERROR;
        }

        u->uri.len = last - uri;
        u->uri.data = uri;

        last = uri;

        if (uri < port) {
            port = NULL;
        }
    }

    if (port) {
        port++;

        len = last - port;
...",1,1,core\ngx_inet.c,ngx_parse_inet_url,,false,782,985,ngx_parse_inet_url,,,14,"ngx_int_t ngx_parse_inet_url (ngx_pool_t*,ngx_url_t*)"
23095,METHOD,core\ngx_inet.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_parse_inet6_url(ngx_pool_t *pool, ngx_url_t *u)
{
#if (NGX_HAVE_INET6)
    u_char               *p, *host, *port, *last, *uri, *dash;
    size_t                len;
    ngx_int_t             n;
    struct sockaddr_in6  *sin6;

    u->socklen = sizeof(struct sockaddr_in6);
    sin6 = (struct sockaddr_in6 *) &u->sockaddr;
    sin6->sin6_family = AF_INET6;

    host = u->url.data + 1;

    last = u->url.data + u->url.len;

    p = ngx_strlchr(host, last, ']');

    if (p == NULL) {
        u->err = ""invalid host"";
        return NGX_ERROR;
    }

    port = p + 1;

    uri = ngx_strlchr(port, last, '/');

    if (uri) {
        if (u->listen || !u->uri_part) {
            u->err = ""invalid host"";
            return NGX_ERROR;
        }

        u->uri.len = last - uri;
        u->uri.data = uri;

        last = uri;
    }

    if (port < last) {
        if (*port != ':') {
            u->err = ""invalid host"";
            return NGX_ERROR;
        }

        port++;...",1,1,core\ngx_inet.c,ngx_parse_inet6_url,,false,988,1111,ngx_parse_inet6_url,,,15,"ngx_int_t ngx_parse_inet6_url (ngx_pool_t*,ngx_url_t*)"
23108,METHOD,core\ngx_inet.c:<global>,TYPE_DECL,"ngx_int_t
ngx_inet_resolve_host(ngx_pool_t *pool, ngx_url_t *u)
{
    u_char              *host;
    ngx_uint_t           i, n;
    struct hostent      *h;
    struct sockaddr_in   sin;

    /* AF_INET only */

    ngx_memzero(&sin, sizeof(struct sockaddr_in));

    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = ngx_inet_addr(u->host.data, u->host.len);

    if (sin.sin_addr.s_addr == INADDR_NONE) {
        host = ngx_alloc(u->host.len + 1, pool->log);
        if (host == NULL) {
            return NGX_ERROR;
        }

        (void) ngx_cpystrn(host, u->host.data, u->host.len + 1);

        h = gethostbyname((char *) host);

        ngx_free(host);

        if (h == NULL || h->h_addr_list[0] == NULL) {
            u->err = ""host not found"";
            return NGX_ERROR;
        }

        for (n = 0; h->h_addr_list[n] != NULL; n++) { /* void */ }

        /* MP: ngx_shared_palloc() */

        for (i = 0; i < n; i++) {
            sin.sin_addr.s_addr = *(in_addr_t *) (h->h_ad...",1,1,core\ngx_inet.c,ngx_inet_resolve_host,,false,1197,1257,ngx_inet_resolve_host,,,16,"ngx_int_t ngx_inet_resolve_host (ngx_pool_t*,ngx_url_t*)"
23295,METHOD,core\ngx_inet.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_inet_add_addr(ngx_pool_t *pool, ngx_url_t *u, struct sockaddr *sockaddr,
    socklen_t socklen, ngx_uint_t total)
{
    u_char           *p;
    size_t            len;
    ngx_uint_t        i, nports;
    ngx_addr_t       *addr;
    struct sockaddr  *sa;

    nports = u->last_port ? u->last_port - u->port + 1 : 1;

    if (u->addrs == NULL) {
        u->addrs = ngx_palloc(pool, total * nports * sizeof(ngx_addr_t));
        if (u->addrs == NULL) {
            return NGX_ERROR;
        }
    }

    for (i = 0; i < nports; i++) {
        sa = ngx_pcalloc(pool, socklen);
        if (sa == NULL) {
            return NGX_ERROR;
        }

        ngx_memcpy(sa, sockaddr, socklen);

        ngx_inet_set_port(sa, u->port + i);

        switch (sa->sa_family) {

#if (NGX_HAVE_INET6)
        case AF_INET6:
            len = NGX_INET6_ADDRSTRLEN + sizeof(""[]:65536"") - 1;
            break;
#endif

        default: /* AF_INET */
            len = NGX_INET_ADDRSTRLEN + sizeo...",1,1,core\ngx_inet.c,ngx_inet_add_addr,,false,1262,1320,ngx_inet_add_addr,,,17,"ngx_int_t ngx_inet_add_addr (ngx_pool_t*,ngx_url_t*,sockaddr*,socklen_t,ngx_uint_t)"
23459,METHOD,core\ngx_inet.c:<global>,TYPE_DECL,"ngx_int_t
ngx_cmp_sockaddr(struct sockaddr *sa1, socklen_t slen1,
    struct sockaddr *sa2, socklen_t slen2, ngx_uint_t cmp_port)
{
    struct sockaddr_in   *sin1, *sin2;
#if (NGX_HAVE_INET6)
    struct sockaddr_in6  *sin61, *sin62;
#endif
#if (NGX_HAVE_UNIX_DOMAIN)
    size_t                len;
    struct sockaddr_un   *saun1, *saun2;
#endif

    if (sa1->sa_family != sa2->sa_family) {
        return NGX_DECLINED;
    }

    switch (sa1->sa_family) {

#if (NGX_HAVE_INET6)
    case AF_INET6:

        sin61 = (struct sockaddr_in6 *) sa1;
        sin62 = (struct sockaddr_in6 *) sa2;

        if (cmp_port && sin61->sin6_port != sin62->sin6_port) {
            return NGX_DECLINED;
        }

        if (ngx_memcmp(&sin61->sin6_addr, &sin62->sin6_addr, 16) != 0) {
            return NGX_DECLINED;
        }

        break;
#endif

#if (NGX_HAVE_UNIX_DOMAIN)
    case AF_UNIX:

        saun1 = (struct sockaddr_un *) sa1;
        saun2 = (struct sockaddr_un *) sa2;

        if (slen1 < slen...",1,1,core\ngx_inet.c,ngx_cmp_sockaddr,,false,1323,1400,ngx_cmp_sockaddr,,,18,"ngx_int_t ngx_cmp_sockaddr (sockaddr*,socklen_t,sockaddr*,socklen_t,ngx_uint_t)"
23528,METHOD,core\ngx_inet.c:<global>,TYPE_DECL,"in_port_t
ngx_inet_get_port(struct sockaddr *sa)
{
    struct sockaddr_in   *sin;
#if (NGX_HAVE_INET6)
    struct sockaddr_in6  *sin6;
#endif

    switch (sa->sa_family) {

#if (NGX_HAVE_INET6)
    case AF_INET6:
        sin6 = (struct sockaddr_in6 *) sa;
        return ntohs(sin6->sin6_port);
#endif

#if (NGX_HAVE_UNIX_DOMAIN)
    case AF_UNIX:
        return 0;
#endif

    default: /* AF_INET */
        sin = (struct sockaddr_in *) sa;
        return ntohs(sin->sin_port);
    }
}",1,1,core\ngx_inet.c,ngx_inet_get_port,,false,1403,1428,ngx_inet_get_port,,,19,in_port_t ngx_inet_get_port (sockaddr*)
23550,METHOD,core\ngx_inet.c:<global>,TYPE_DECL,"void
ngx_inet_set_port(struct sockaddr *sa, in_port_t port)
{
    struct sockaddr_in   *sin;
#if (NGX_HAVE_INET6)
    struct sockaddr_in6  *sin6;
#endif

    switch (sa->sa_family) {

#if (NGX_HAVE_INET6)
    case AF_INET6:
        sin6 = (struct sockaddr_in6 *) sa;
        sin6->sin6_port = htons(port);
        break;
#endif

#if (NGX_HAVE_UNIX_DOMAIN)
    case AF_UNIX:
        break;
#endif

    default: /* AF_INET */
        sin = (struct sockaddr_in *) sa;
        sin->sin_port = htons(port);
        break;
    }
}",1,1,core\ngx_inet.c,ngx_inet_set_port,,false,1431,1458,ngx_inet_set_port,,,20,"void ngx_inet_set_port (sockaddr*,in_port_t)"
23575,METHOD,core\ngx_inet.c:<global>,TYPE_DECL,"ngx_uint_t
ngx_inet_wildcard(struct sockaddr *sa)
{
    struct sockaddr_in   *sin;
#if (NGX_HAVE_INET6)
    struct sockaddr_in6  *sin6;
#endif

    switch (sa->sa_family) {

    case AF_INET:
        sin = (struct sockaddr_in *) sa;

        if (sin->sin_addr.s_addr == INADDR_ANY) {
            return 1;
        }

        break;

#if (NGX_HAVE_INET6)

    case AF_INET6:
        sin6 = (struct sockaddr_in6 *) sa;

        if (IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr)) {
            return 1;
        }

        break;

#endif
    }

    return 0;
}",1,1,core\ngx_inet.c,ngx_inet_wildcard,,false,1461,1495,ngx_inet_wildcard,,,21,ngx_uint_t ngx_inet_wildcard (sockaddr*)
23614,METHOD,core\ngx_inet.h:<global>,TYPE_DECL,<global>,1,34,core\ngx_inet.h,core\ngx_inet.h:<global>,,false,1,132,<global>,,,1,
23663,METHOD,core\ngx_inet.h:<global>,TYPE_DECL,"in_addr_t ngx_inet_addr(u_char *text, size_t len);",11,49,core\ngx_inet.h,ngx_inet_addr,,false,109,109,ngx_inet_addr,,,11,"in_addr_t ngx_inet_addr (u_char*,size_t)"
23669,METHOD,core\ngx_inet.h:<global>,TYPE_DECL,"size_t ngx_sock_ntop(struct sockaddr *sa, socklen_t socklen, u_char *text,
    size_t len, ngx_uint_t port);",8,32,core\ngx_inet.h,ngx_sock_ntop,,false,114,115,ngx_sock_ntop,,,12,"size_t ngx_sock_ntop (sockaddr*,socklen_t,u_char*,size_t,ngx_uint_t)"
23678,METHOD,core\ngx_inet.h:<global>,TYPE_DECL,"size_t ngx_inet_ntop(int family, void *addr, u_char *text, size_t len);",8,70,core\ngx_inet.h,ngx_inet_ntop,,false,116,116,ngx_inet_ntop,,,13,"size_t ngx_inet_ntop (int,void*,u_char*,size_t)"
23686,METHOD,core\ngx_inet.h:<global>,TYPE_DECL,"ngx_int_t ngx_ptocidr(ngx_str_t *text, ngx_cidr_t *cidr);",11,56,core\ngx_inet.h,ngx_ptocidr,,false,117,117,ngx_ptocidr,,,14,"ngx_int_t ngx_ptocidr (ngx_str_t*,ngx_cidr_t*)"
23692,METHOD,core\ngx_inet.h:<global>,TYPE_DECL,"ngx_int_t ngx_cidr_match(struct sockaddr *sa, ngx_array_t *cidrs);",11,65,core\ngx_inet.h,ngx_cidr_match,,false,118,118,ngx_cidr_match,,,15,"ngx_int_t ngx_cidr_match (sockaddr*,ngx_array_t*)"
23698,METHOD,core\ngx_inet.h:<global>,TYPE_DECL,"ngx_int_t ngx_parse_addr(ngx_pool_t *pool, ngx_addr_t *addr, u_char *text,
    size_t len);",11,15,core\ngx_inet.h,ngx_parse_addr,,false,119,120,ngx_parse_addr,,,16,"ngx_int_t ngx_parse_addr (ngx_pool_t*,ngx_addr_t*,u_char*,size_t)"
23706,METHOD,core\ngx_inet.h:<global>,TYPE_DECL,"ngx_int_t ngx_parse_addr_port(ngx_pool_t *pool, ngx_addr_t *addr,
    u_char *text, size_t len);",11,29,core\ngx_inet.h,ngx_parse_addr_port,,false,121,122,ngx_parse_addr_port,,,17,"ngx_int_t ngx_parse_addr_port (ngx_pool_t*,ngx_addr_t*,u_char*,size_t)"
23714,METHOD,core\ngx_inet.h:<global>,TYPE_DECL,"ngx_int_t ngx_parse_url(ngx_pool_t *pool, ngx_url_t *u);",11,55,core\ngx_inet.h,ngx_parse_url,,false,123,123,ngx_parse_url,,,18,"ngx_int_t ngx_parse_url (ngx_pool_t*,ngx_url_t*)"
23720,METHOD,core\ngx_inet.h:<global>,TYPE_DECL,"ngx_int_t ngx_inet_resolve_host(ngx_pool_t *pool, ngx_url_t *u);",11,63,core\ngx_inet.h,ngx_inet_resolve_host,,false,124,124,ngx_inet_resolve_host,,,19,"ngx_int_t ngx_inet_resolve_host (ngx_pool_t*,ngx_url_t*)"
23726,METHOD,core\ngx_inet.h:<global>,TYPE_DECL,"ngx_int_t ngx_cmp_sockaddr(struct sockaddr *sa1, socklen_t slen1,
    struct sockaddr *sa2, socklen_t slen2, ngx_uint_t cmp_port);",11,63,core\ngx_inet.h,ngx_cmp_sockaddr,,false,125,126,ngx_cmp_sockaddr,,,20,"ngx_int_t ngx_cmp_sockaddr (sockaddr*,socklen_t,sockaddr*,socklen_t,ngx_uint_t)"
23735,METHOD,core\ngx_inet.h:<global>,TYPE_DECL,in_port_t ngx_inet_get_port(struct sockaddr *sa);,11,48,core\ngx_inet.h,ngx_inet_get_port,,false,127,127,ngx_inet_get_port,,,21,in_port_t ngx_inet_get_port (sockaddr*)
23740,METHOD,core\ngx_inet.h:<global>,TYPE_DECL,"void ngx_inet_set_port(struct sockaddr *sa, in_port_t port);",6,59,core\ngx_inet.h,ngx_inet_set_port,,false,128,128,ngx_inet_set_port,,,22,"void ngx_inet_set_port (sockaddr*,in_port_t)"
23746,METHOD,core\ngx_inet.h:<global>,TYPE_DECL,ngx_uint_t ngx_inet_wildcard(struct sockaddr *sa);,12,49,core\ngx_inet.h,ngx_inet_wildcard,,false,129,129,ngx_inet_wildcard,,,23,ngx_uint_t ngx_inet_wildcard (sockaddr*)
23758,METHOD,core\ngx_list.c:<global>,TYPE_DECL,<global>,1,1,core\ngx_list.c,core\ngx_list.c:<global>,,false,1,63,<global>,,,1,
23760,METHOD,core\ngx_list.c:<global>,TYPE_DECL,"ngx_list_t *
ngx_list_create(ngx_pool_t *pool, ngx_uint_t n, size_t size)
{
    ngx_list_t  *list;

    list = ngx_palloc(pool, sizeof(ngx_list_t));
    if (list == NULL) {
        return NULL;
    }

    if (ngx_list_init(list, pool, n, size) != NGX_OK) {
        return NULL;
    }

    return list;
}",1,1,core\ngx_list.c,ngx_list_create,,false,12,27,ngx_list_create,,,1,"ngx_list_t ngx_list_create (ngx_pool_t*,ngx_uint_t,size_t)"
23794,METHOD,core\ngx_list.c:<global>,TYPE_DECL,"void *
ngx_list_push(ngx_list_t *l)
{
    void             *elt;
    ngx_list_part_t  *last;

    last = l->last;

    if (last->nelts == l->nalloc) {

        /* the last part is full, allocate a new list part */

        last = ngx_palloc(l->pool, sizeof(ngx_list_part_t));
        if (last == NULL) {
            return NULL;
        }

        last->elts = ngx_palloc(l->pool, l->nalloc * l->size);
        if (last->elts == NULL) {
            return NULL;
        }

        last->nelts = 0;
        last->next = NULL;

        l->last->next = last;
        l->last = last;
    }

    elt = (char *) last->elts + l->size * last->nelts;
    last->nelts++;

    return elt;
}",1,1,core\ngx_list.c,ngx_list_push,,false,30,63,ngx_list_push,,,2,void* ngx_list_push (ngx_list_t*)
23904,METHOD,core\ngx_list.h:<global>,TYPE_DECL,<global>,1,34,core\ngx_list.h,core\ngx_list.h:<global>,,false,1,83,<global>,,,1,
23919,METHOD,core\ngx_list.h:<global>,TYPE_DECL,"ngx_list_t *ngx_list_create(ngx_pool_t *pool, ngx_uint_t n, size_t size);",12,72,core\ngx_list.h,ngx_list_create,,false,34,34,ngx_list_create,,,6,"ngx_list_t* ngx_list_create (ngx_pool_t*,ngx_uint_t,size_t)"
23928,METHOD,core\ngx_list.h:<global>,TYPE_DECL,"ngx_list_init(ngx_list_t *list, ngx_pool_t *pool, ngx_uint_t n, size_t size)
{
    list->part.elts = ngx_palloc(pool, n * size);
    if (list->part.elts == NULL) {
        return NGX_ERROR;
    }

    list->part.nelts = 0;
    list->part.next = NULL;
    list->last = &list->part;
    list->size = size;
    list->nalloc = n;
    list->pool = pool;

    return NGX_OK;
}",1,1,core\ngx_list.h,ngx_list_init,,false,37,52,ngx_list_init,,,9,"ANY ngx_list_init (ngx_list_t*,ngx_pool_t*,ngx_uint_t,size_t)"
23997,METHOD,core\ngx_list.h:<global>,TYPE_DECL,void *ngx_list_push(ngx_list_t *list);,6,37,core\ngx_list.h,ngx_list_push,,false,80,80,ngx_list_push,,,10,void* ngx_list_push (ngx_list_t*)
24009,METHOD,core\ngx_log.c:<global>,TYPE_DECL,<global>,1,6,core\ngx_log.c,core\ngx_log.c:<global>,,false,1,755,<global>,,,1,
24011,METHOD,core\ngx_log.c:<global>,TYPE_DECL,"static char *ngx_error_log(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",13,74,core\ngx_log.c,ngx_error_log,,false,12,12,ngx_error_log,,,1,"char* ngx_error_log (ngx_conf_t*,ngx_command_t*,void*)"
24018,METHOD,core\ngx_log.c:<global>,TYPE_DECL,"static char *ngx_log_set_levels(ngx_conf_t *cf, ngx_log_t *log);",13,63,core\ngx_log.c,ngx_log_set_levels,,false,13,13,ngx_log_set_levels,,,2,"char* ngx_log_set_levels (ngx_conf_t*,ngx_log_t*)"
24024,METHOD,core\ngx_log.c:<global>,TYPE_DECL,"static void ngx_log_insert(ngx_log_t *log, ngx_log_t *new_log);",13,62,core\ngx_log.c,ngx_log_insert,,false,14,14,ngx_log_insert,,,3,"void ngx_log_insert (ngx_log_t*,ngx_log_t*)"
24108,METHOD,core\ngx_log.c:<global>,TYPE_DECL,"void
ngx_log_error_core(ngx_uint_t level, ngx_log_t *log, ngx_err_t err,
    const char *fmt, va_list args)

#endif
{
#if (NGX_HAVE_VARIADIC_MACROS)
    va_list      args;
#endif
    u_char      *p, *last, *msg;
    ssize_t      n;
    ngx_uint_t   wrote_stderr, debug_connection;
    u_char       errstr[NGX_MAX_ERROR_STR];

    last = errstr + NGX_MAX_ERROR_STR;

    p = ngx_cpymem(errstr, ngx_cached_err_log_time.data,
                   ngx_cached_err_log_time.len);

    p = ngx_slprintf(p, last, "" [%V] "", &err_levels[level]);

    /* pid#tid */
    p = ngx_slprintf(p, last, ""%P#"" NGX_TID_T_FMT "": "",
                    ngx_log_pid, ngx_log_tid);

    if (log->connection) {
        p = ngx_slprintf(p, last, ""*%uA "", log->connection);
    }

    msg = p;

#if (NGX_HAVE_VARIADIC_MACROS)

    va_start(args, fmt);
    p = ngx_vslprintf(p, last, fmt, args);
    va_end(args);

#else

    p = ngx_vslprintf(p, last, fmt, args);

#endif

    if (err) {
        p = ngx_log_errno(p, last, err...",1,1,core\ngx_log.c,ngx_log_error_core,,false,101,210,ngx_log_error_core,,,18,"void ngx_log_error_core (ngx_uint_t,ngx_log_t*,ngx_err_t,char*,va_list)"
24353,METHOD,core\ngx_log.c:<global>,TYPE_DECL,"ngx_log_error(ngx_uint_t level, ngx_log_t *log, ngx_err_t err,
    const char *fmt, ...)
{
    va_list  args;

    if (log->log_level >= level) {
        va_start(args, fmt);
        ngx_log_error_core(level, log, err, fmt, args);
        va_end(args);
    }
}",1,1,core\ngx_log.c,ngx_log_error,,false,216,226,ngx_log_error,,,21,"ANY ngx_log_error (ngx_uint_t,ngx_log_t*,ngx_err_t,char*...)"
24382,METHOD,core\ngx_log.c:<global>,TYPE_DECL,"ngx_log_debug_core(ngx_log_t *log, ngx_err_t err, const char *fmt, ...)
{
    va_list  args;

    va_start(args, fmt);
    ngx_log_error_core(NGX_LOG_DEBUG, log, err, fmt, args);
    va_end(args);
}",1,1,core\ngx_log.c,ngx_log_debug_core,,false,230,237,ngx_log_debug_core,,,24,"ANY ngx_log_debug_core (ngx_log_t*,ngx_err_t,char*...)"
24403,METHOD,core\ngx_log.c:<global>,TYPE_DECL,"ngx_log_abort(ngx_err_t err, const char *fmt, ...)
{
    u_char   *p;
    va_list   args;
    u_char    errstr[NGX_MAX_CONF_ERRSTR];

    va_start(args, fmt);
    p = ngx_vsnprintf(errstr, sizeof(errstr) - 1, fmt, args);
    va_end(args);

    ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, err,
                  ""%*s"", p - errstr, errstr);
}",1,1,core\ngx_log.c,ngx_log_abort,,false,243,255,ngx_log_abort,,,27,"ANY ngx_log_abort (ngx_err_t,char*...)"
24440,METHOD,core\ngx_log.c:<global>,TYPE_DECL,"ngx_log_stderr(ngx_err_t err, const char *fmt, ...)
{
    u_char   *p, *last;
    va_list   args;
    u_char    errstr[NGX_MAX_ERROR_STR];

    last = errstr + NGX_MAX_ERROR_STR;

    p = ngx_cpymem(errstr, ""nginx: "", 7);

    va_start(args, fmt);
    p = ngx_vslprintf(p, last, fmt, args);
    va_end(args);

    if (err) {
        p = ngx_log_errno(p, last, err);
    }

    if (p > last - NGX_LINEFEED_SIZE) {
        p = last - NGX_LINEFEED_SIZE;
    }

    ngx_linefeed(p);

    (void) ngx_write_console(ngx_stderr, errstr, p - errstr);
}",1,1,core\ngx_log.c,ngx_log_stderr,,false,259,284,ngx_log_stderr,,,30,"ANY ngx_log_stderr (ngx_err_t,char*...)"
24504,METHOD,core\ngx_log.c:<global>,TYPE_DECL,"u_char *
ngx_log_errno(u_char *buf, u_char *last, ngx_err_t err)
{
    if (buf > last - 50) {

        /* leave a space for an error code */

        buf = last - 50;
        *buf++ = '.';
        *buf++ = '.';
        *buf++ = '.';
    }

#if (NGX_WIN32)
    buf = ngx_slprintf(buf, last, ((unsigned) err < 0x80000000)
                                       ? "" (%d: "" : "" (%Xd: "", err);
#else
    buf = ngx_slprintf(buf, last, "" (%d: "", err);
#endif

    buf = ngx_strerror(err, buf, last - buf);

    if (buf < last) {
        *buf++ = ')';
    }

    return buf;
}",1,1,core\ngx_log.c,ngx_log_errno,,false,287,314,ngx_log_errno,,,31,"u_char ngx_log_errno (u_char*,u_char*,ngx_err_t)"
24565,METHOD,core\ngx_log.c:<global>,TYPE_DECL,"ngx_log_t *
ngx_log_init(u_char *prefix)
{
    u_char  *p, *name;
    size_t   nlen, plen;

    ngx_log.file = &ngx_log_file;
    ngx_log.log_level = NGX_LOG_NOTICE;

    name = (u_char *) NGX_ERROR_LOG_PATH;

    /*
     * we use ngx_strlen() here since BCC warns about
     * condition is always false and unreachable code
     */

    nlen = ngx_strlen(name);

    if (nlen == 0) {
        ngx_log_file.fd = ngx_stderr;
        return &ngx_log;
    }

    p = NULL;

#if (NGX_WIN32)
    if (name[1] != ':') {
#else
    if (name[0] != '/') {
#endif

        if (prefix) {
            plen = ngx_strlen(prefix);

        } else {
#ifdef NGX_PREFIX
            prefix = (u_char *) NGX_PREFIX;
            plen = ngx_strlen(prefix);
#else
            plen = 0;
#endif
        }

        if (plen) {
            name = malloc(plen + nlen + 2);
            if (name == NULL) {
                return NULL;
            }

            p = ngx_cpymem(name, prefix, plen);

            if (!ngx_path_sepa...",1,1,core\ngx_log.c,ngx_log_init,,false,317,400,ngx_log_init,,,32,ngx_log_t ngx_log_init (u_char*)
24707,METHOD,core\ngx_log.c:<global>,TYPE_DECL,"ngx_int_t
ngx_log_open_default(ngx_cycle_t *cycle)
{
    ngx_log_t         *log;
    static ngx_str_t   error_log = ngx_string(NGX_ERROR_LOG_PATH);

    if (ngx_log_get_file_log(&cycle->new_log) != NULL) {
        return NGX_OK;
    }

    if (cycle->new_log.log_level != 0) {
        /* there are some error logs, but no files */

        log = ngx_pcalloc(cycle->pool, sizeof(ngx_log_t));
        if (log == NULL) {
            return NGX_ERROR;
        }

    } else {
        /* no error logs at all */
        log = &cycle->new_log;
    }

    log->log_level = NGX_LOG_ERR;

    log->file = ngx_conf_open_file(cycle, &error_log);
    if (log->file == NULL) {
        return NGX_ERROR;
    }

    if (log != &cycle->new_log) {
        ngx_log_insert(&cycle->new_log, log);
    }

    return NGX_OK;
}",1,1,core\ngx_log.c,ngx_log_open_default,,false,403,438,ngx_log_open_default,,,33,ngx_int_t ngx_log_open_default (ngx_cycle_t*)
24799,METHOD,core\ngx_log.c:<global>,TYPE_DECL,"ngx_int_t
ngx_log_redirect_stderr(ngx_cycle_t *cycle)
{
    ngx_fd_t  fd;

    if (cycle->log_use_stderr) {
        return NGX_OK;
    }

    /* file log always exists when we are called */
    fd = ngx_log_get_file_log(cycle->log)->file->fd;

    if (fd != ngx_stderr) {
        if (ngx_set_stderr(fd) == NGX_FILE_ERROR) {
            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                          ngx_set_stderr_n "" failed"");

            return NGX_ERROR;
        }
    }

    return NGX_OK;
}",1,1,core\ngx_log.c,ngx_log_redirect_stderr,,false,441,463,ngx_log_redirect_stderr,,,34,ngx_int_t ngx_log_redirect_stderr (ngx_cycle_t*)
24838,METHOD,core\ngx_log.c:<global>,TYPE_DECL,"ngx_log_t *
ngx_log_get_file_log(ngx_log_t *head)
{
    ngx_log_t  *log;

    for (log = head; log; log = log->next) {
        if (log->file != NULL) {
            return log;
        }
    }

    return NULL;
}",1,1,core\ngx_log.c,ngx_log_get_file_log,,false,466,478,ngx_log_get_file_log,,,35,ngx_log_t ngx_log_get_file_log (ngx_log_t*)
24867,METHOD,core\ngx_log.c:<global>,TYPE_DECL,"static char *
ngx_log_set_levels(ngx_conf_t *cf, ngx_log_t *log)
{
    ngx_uint_t   i, n, d, found;
    ngx_str_t   *value;

    if (cf->args->nelts == 2) {
        log->log_level = NGX_LOG_ERR;
        return NGX_CONF_OK;
    }

    value = cf->args->elts;

    for (i = 2; i < cf->args->nelts; i++) {
        found = 0;

        for (n = 1; n <= NGX_LOG_DEBUG; n++) {
            if (ngx_strcmp(value[i].data, err_levels[n].data) == 0) {

                if (log->log_level != 0) {
                    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                                       ""duplicate log level \""%V\"""",
                                       &value[i]);
                    return NGX_CONF_ERROR;
                }

                log->log_level = n;
                found = 1;
                break;
            }
        }

        for (n = 0, d = NGX_LOG_DEBUG_FIRST; d <= NGX_LOG_DEBUG_LAST; d <<= 1) {
            if (ngx_strcmp(value[i].data, debug_levels[n++]) == 0) {
         ...",1,1,core\ngx_log.c,ngx_log_set_levels,,false,481,541,ngx_log_set_levels,,,36,"char* ngx_log_set_levels (ngx_conf_t*,ngx_log_t*)"
25059,METHOD,core\ngx_log.c:<global>,TYPE_DECL,"static char *
ngx_error_log(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_log_t  *dummy;

    dummy = &cf->cycle->new_log;

    return ngx_log_set_log(cf, &dummy);
}",1,1,core\ngx_log.c,ngx_error_log,,false,544,552,ngx_error_log,,,37,"char* ngx_error_log (ngx_conf_t*,ngx_command_t*,void*)"
25080,METHOD,core\ngx_log.c:<global>,TYPE_DECL,"char *
ngx_log_set_log(ngx_conf_t *cf, ngx_log_t **head)
{
    ngx_log_t          *new_log;
    ngx_str_t          *value, name;
    ngx_syslog_peer_t  *peer;

    if (*head != NULL && (*head)->log_level == 0) {
        new_log = *head;

    } else {

        new_log = ngx_pcalloc(cf->pool, sizeof(ngx_log_t));
        if (new_log == NULL) {
            return NGX_CONF_ERROR;
        }

        if (*head == NULL) {
            *head = new_log;
        }
    }

    value = cf->args->elts;

    if (ngx_strcmp(value[1].data, ""stderr"") == 0) {
        ngx_str_null(&name);
        cf->cycle->log_use_stderr = 1;

        new_log->file = ngx_conf_open_file(cf->cycle, &name);
        if (new_log->file == NULL) {
            return NGX_CONF_ERROR;
        }

    } else if (ngx_strncmp(value[1].data, ""memory:"", 7) == 0) {

#if (NGX_DEBUG)
        size_t                 size, needed;
        ngx_pool_cleanup_t    *cln;
        ngx_log_memory_buf_t  *buf;

        value[1].len -= 7;
        valu...",1,1,core\ngx_log.c,ngx_log_set_log,,false,555,676,ngx_log_set_log,,,38,"char* ngx_log_set_log (ngx_conf_t*,ngx_log_t**)"
25294,METHOD,core\ngx_log.c:<global>,TYPE_DECL,"static void
ngx_log_insert(ngx_log_t *log, ngx_log_t *new_log)
{
    ngx_log_t  tmp;

    if (new_log->log_level > log->log_level) {

        /*
         * list head address is permanent, insert new log after
         * head and swap its contents with head
         */

        tmp = *log;
        *log = *new_log;
        *new_log = tmp;

        log->next = new_log;
        return;
    }

    while (log->next) {
        if (new_log->log_level > log->next->log_level) {
            new_log->next = log->next;
            log->next = new_log;
            return;
        }

        log = log->next;
    }

    log->next = new_log;
}",1,1,core\ngx_log.c,ngx_log_insert,,false,679,710,ngx_log_insert,,,39,"void ngx_log_insert (ngx_log_t*,ngx_log_t*)"
25375,METHOD,core\ngx_log.h:<global>,TYPE_DECL,<global>,1,33,core\ngx_log.h,core\ngx_log.h:<global>,,false,1,268,<global>,,,1,
25377,METHOD,core\ngx_log.h:<global>,TYPE_DECL,"typedef u_char *(*ngx_log_handler_pt) (ngx_log_t *log, u_char *buf, size_t len);",16,79,core\ngx_log.h,ngx_log_handler_pt,,false,45,45,ngx_log_handler_pt,,,1,"u_char* ngx_log_handler_pt (ngx_log_t*,u_char*,size_t)"
25384,METHOD,core\ngx_log.h:<global>,TYPE_DECL,"typedef void (*ngx_log_writer_pt) (ngx_log_t *log, ngx_uint_t level,
    u_char *buf, size_t len);",14,28,core\ngx_log.h,ngx_log_writer_pt,,false,46,47,ngx_log_writer_pt,,,2,"void ngx_log_writer_pt (ngx_log_t*,ngx_uint_t,u_char*,size_t)"
25404,METHOD,core\ngx_log.h:<global>,TYPE_DECL,"void ngx_log_error_core(ngx_uint_t level, ngx_log_t *log, ngx_err_t err,
    const char *fmt, va_list args);",6,34,core\ngx_log.h,ngx_log_error_core,,false,119,120,ngx_log_error_core,,,5,"void ngx_log_error_core (ngx_uint_t,ngx_log_t*,ngx_err_t,char*,va_list)"
25414,METHOD,core\ngx_log.h:<global>,TYPE_DECL,ngx_log_t *ngx_log_init(u_char *prefix);,11,39,core\ngx_log.h,ngx_log_init,,false,231,231,ngx_log_init,,,7,ngx_log_t* ngx_log_init (u_char*)
25421,METHOD,core\ngx_log.h:<global>,TYPE_DECL,"u_char *ngx_log_errno(u_char *buf, u_char *last, ngx_err_t err);",8,63,core\ngx_log.h,ngx_log_errno,,false,234,234,ngx_log_errno,,,10,"u_char* ngx_log_errno (u_char*,u_char*,ngx_err_t)"
25428,METHOD,core\ngx_log.h:<global>,TYPE_DECL,ngx_int_t ngx_log_open_default(ngx_cycle_t *cycle);,11,50,core\ngx_log.h,ngx_log_open_default,,false,235,235,ngx_log_open_default,,,11,ngx_int_t ngx_log_open_default (ngx_cycle_t*)
25433,METHOD,core\ngx_log.h:<global>,TYPE_DECL,ngx_int_t ngx_log_redirect_stderr(ngx_cycle_t *cycle);,11,53,core\ngx_log.h,ngx_log_redirect_stderr,,false,236,236,ngx_log_redirect_stderr,,,12,ngx_int_t ngx_log_redirect_stderr (ngx_cycle_t*)
25438,METHOD,core\ngx_log.h:<global>,TYPE_DECL,ngx_log_t *ngx_log_get_file_log(ngx_log_t *head);,11,48,core\ngx_log.h,ngx_log_get_file_log,,false,237,237,ngx_log_get_file_log,,,13,ngx_log_t* ngx_log_get_file_log (ngx_log_t*)
25443,METHOD,core\ngx_log.h:<global>,TYPE_DECL,"char *ngx_log_set_log(ngx_conf_t *cf, ngx_log_t **head);",6,55,core\ngx_log.h,ngx_log_set_log,,false,238,238,ngx_log_set_log,,,14,"char* ngx_log_set_log (ngx_conf_t*,ngx_log_t**)"
25462,METHOD,core\ngx_md5.c:<global>,TYPE_DECL,<global>,1,8,core\ngx_md5.c,core\ngx_md5.c:<global>,,false,1,283,<global>,,,1,
25464,METHOD,core\ngx_md5.c:<global>,TYPE_DECL,"static const u_char *ngx_md5_body(ngx_md5_t *ctx, const u_char *data,
    size_t size);",21,16,core\ngx_md5.c,ngx_md5_body,,false,14,15,ngx_md5_body,,,1,"u_char* ngx_md5_body (ngx_md5_t*,u_char*,size_t)"
25471,METHOD,core\ngx_md5.c:<global>,TYPE_DECL,"void
ngx_md5_init(ngx_md5_t *ctx)
{
    ctx->a = 0x67452301;
    ctx->b = 0xefcdab89;
    ctx->c = 0x98badcfe;
    ctx->d = 0x10325476;

    ctx->bytes = 0;
}",1,1,core\ngx_md5.c,ngx_md5_init,,false,18,27,ngx_md5_init,,,2,void ngx_md5_init (ngx_md5_t*)
25501,METHOD,core\ngx_md5.c:<global>,TYPE_DECL,"void
ngx_md5_update(ngx_md5_t *ctx, const void *data, size_t size)
{
    size_t  used, free;

    used = (size_t) (ctx->bytes & 0x3f);
    ctx->bytes += size;

    if (used) {
        free = 64 - used;

        if (size < free) {
            ngx_memcpy(&ctx->buffer[used], data, size);
            return;
        }

        ngx_memcpy(&ctx->buffer[used], data, free);
        data = (u_char *) data + free;
        size -= free;
        (void) ngx_md5_body(ctx, ctx->buffer, 64);
    }

    if (size >= 64) {
        data = ngx_md5_body(ctx, data, size & ~(size_t) 0x3f);
        size &= 0x3f;
    }

    ngx_memcpy(ctx->buffer, data, size);
}",1,1,core\ngx_md5.c,ngx_md5_update,,false,30,58,ngx_md5_update,,,3,"void ngx_md5_update (ngx_md5_t*,void*,size_t)"
25598,METHOD,core\ngx_md5.c:<global>,TYPE_DECL,"void
ngx_md5_final(u_char result[16], ngx_md5_t *ctx)
{
    size_t  used, free;

    used = (size_t) (ctx->bytes & 0x3f);

    ctx->buffer[used++] = 0x80;

    free = 64 - used;

    if (free < 8) {
        ngx_memzero(&ctx->buffer[used], free);
        (void) ngx_md5_body(ctx, ctx->buffer, 64);
        used = 0;
        free = 64;
    }

    ngx_memzero(&ctx->buffer[used], free - 8);

    ctx->bytes <<= 3;
    ctx->buffer[56] = (u_char) ctx->bytes;
    ctx->buffer[57] = (u_char) (ctx->bytes >> 8);
    ctx->buffer[58] = (u_char) (ctx->bytes >> 16);
    ctx->buffer[59] = (u_char) (ctx->bytes >> 24);
    ctx->buffer[60] = (u_char) (ctx->bytes >> 32);
    ctx->buffer[61] = (u_char) (ctx->bytes >> 40);
    ctx->buffer[62] = (u_char) (ctx->bytes >> 48);
    ctx->buffer[63] = (u_char) (ctx->bytes >> 56);

    (void) ngx_md5_body(ctx, ctx->buffer, 64);

    result[0] = (u_char) ctx->a;
    result[1] = (u_char) (ctx->a >> 8);
    result[2] = (u_char) (ctx->a >> 16);
    result[3] = (u_char)...",1,1,core\ngx_md5.c,ngx_md5_final,,false,61,111,ngx_md5_final,,,4,"void ngx_md5_final (u_char[16],ngx_md5_t*)"
25933,METHOD,core\ngx_md5.c:<global>,TYPE_DECL,"static const u_char *
ngx_md5_body(ngx_md5_t *ctx, const u_char *data, size_t size)
{
    uint32_t       a, b, c, d;
    uint32_t       saved_a, saved_b, saved_c, saved_d;
    const u_char  *p;
#if !(NGX_HAVE_LITTLE_ENDIAN && NGX_HAVE_NONALIGNED)
    uint32_t       block[16];
#endif

    p = data;

    a = ctx->a;
    b = ctx->b;
    c = ctx->c;
    d = ctx->d;

    do {
        saved_a = a;
        saved_b = b;
        saved_c = c;
        saved_d = d;

        /* Round 1 */

        STEP(F, a, b, c, d, SET(0),  0xd76aa478, 7);
        STEP(F, d, a, b, c, SET(1),  0xe8c7b756, 12);
        STEP(F, c, d, a, b, SET(2),  0x242070db, 17);
        STEP(F, b, c, d, a, SET(3),  0xc1bdceee, 22);
        STEP(F, a, b, c, d, SET(4),  0xf57c0faf, 7);
        STEP(F, d, a, b, c, SET(5),  0x4787c62a, 12);
        STEP(F, c, d, a, b, SET(6),  0xa8304613, 17);
        STEP(F, b, c, d, a, SET(7),  0xfd469501, 22);
        STEP(F, a, b, c, d, SET(8),  0x698098d8, 7);
        STEP(F, d, a, b, c, SET(...",1,8,core\ngx_md5.c,ngx_md5_body,,false,169,283,ngx_md5_body,,,5,"u_char ngx_md5_body (ngx_md5_t*,u_char*,size_t)"
29123,METHOD,core\ngx_md5.h:<global>,TYPE_DECL,<global>,1,33,core\ngx_md5.h,core\ngx_md5.h:<global>,,false,1,28,<global>,,,1,
29132,METHOD,<empty>,<empty>,<empty>,1,,core\ngx_md5.h,ngx_md5_t:<clinit>,,false,16,,<clinit>,,,7,
29139,METHOD,core\ngx_md5.h:<global>,TYPE_DECL,void ngx_md5_init(ngx_md5_t *ctx);,6,33,core\ngx_md5.h,ngx_md5_init,,false,23,23,ngx_md5_init,,,3,void ngx_md5_init (ngx_md5_t*)
29144,METHOD,core\ngx_md5.h:<global>,TYPE_DECL,"void ngx_md5_update(ngx_md5_t *ctx, const void *data, size_t size);",6,66,core\ngx_md5.h,ngx_md5_update,,false,24,24,ngx_md5_update,,,4,"void ngx_md5_update (ngx_md5_t*,void*,size_t)"
29151,METHOD,core\ngx_md5.h:<global>,TYPE_DECL,"void ngx_md5_final(u_char result[16], ngx_md5_t *ctx);",6,53,core\ngx_md5.h,ngx_md5_final,,false,25,25,ngx_md5_final,,,5,"void ngx_md5_final (u_char[16],ngx_md5_t*)"
29164,METHOD,core\ngx_module.c:<global>,TYPE_DECL,<global>,1,37,core\ngx_module.c,core\ngx_module.c:<global>,,false,1,360,<global>,,,1,
29166,METHOD,core\ngx_module.c:<global>,TYPE_DECL,static ngx_uint_t ngx_module_index(ngx_cycle_t *cycle);,19,54,core\ngx_module.c,ngx_module_index,,false,16,16,ngx_module_index,,,1,ngx_uint_t ngx_module_index (ngx_cycle_t*)
29171,METHOD,core\ngx_module.c:<global>,TYPE_DECL,"static ngx_uint_t ngx_module_ctx_index(ngx_cycle_t *cycle, ngx_uint_t type,
    ngx_uint_t index);",19,21,core\ngx_module.c,ngx_module_ctx_index,,false,17,18,ngx_module_ctx_index,,,2,"ngx_uint_t ngx_module_ctx_index (ngx_cycle_t*,ngx_uint_t,ngx_uint_t)"
29180,METHOD,core\ngx_module.c:<global>,TYPE_DECL,"ngx_int_t
ngx_preinit_modules(void)
{
    ngx_uint_t  i;

    for (i = 0; ngx_modules[i]; i++) {
        ngx_modules[i]->index = i;
        ngx_modules[i]->name = ngx_module_names[i];
    }

    ngx_modules_n = i;
    ngx_max_module = ngx_modules_n + NGX_MAX_DYNAMIC_MODULES;

    return NGX_OK;
}",1,37,core\ngx_module.c,ngx_preinit_modules,,false,25,39,ngx_preinit_modules,,,5,ngx_int_t ngx_preinit_modules (void)
29225,METHOD,core\ngx_module.c:<global>,TYPE_DECL,"ngx_int_t
ngx_cycle_modules(ngx_cycle_t *cycle)
{
    /*
     * create a list of modules to be used for this cycle,
     * copy static modules to it
     */

    cycle->modules = ngx_pcalloc(cycle->pool, (ngx_max_module + 1)
                                              * sizeof(ngx_module_t *));
    if (cycle->modules == NULL) {
        return NGX_ERROR;
    }

    ngx_memcpy(cycle->modules, ngx_modules,
               ngx_modules_n * sizeof(ngx_module_t *));

    cycle->modules_n = ngx_modules_n;

    return NGX_OK;
}",1,1,core\ngx_module.c,ngx_cycle_modules,,false,42,62,ngx_cycle_modules,,,6,ngx_int_t ngx_cycle_modules (ngx_cycle_t*)
29269,METHOD,core\ngx_module.c:<global>,TYPE_DECL,"ngx_int_t
ngx_init_modules(ngx_cycle_t *cycle)
{
    ngx_uint_t  i;

    for (i = 0; cycle->modules[i]; i++) {
        if (cycle->modules[i]->init_module) {
            if (cycle->modules[i]->init_module(cycle) != NGX_OK) {
                return NGX_ERROR;
            }
        }
    }

    return NGX_OK;
}",1,1,core\ngx_module.c,ngx_init_modules,,false,65,79,ngx_init_modules,,,7,ngx_int_t ngx_init_modules (ngx_cycle_t*)
29314,METHOD,core\ngx_module.c:<global>,TYPE_DECL,"ngx_int_t
ngx_count_modules(ngx_cycle_t *cycle, ngx_uint_t type)
{
    ngx_uint_t     i, next, max;
    ngx_module_t  *module;

    next = 0;
    max = 0;

    /* count appropriate modules, set up their indices */

    for (i = 0; cycle->modules[i]; i++) {
        module = cycle->modules[i];

        if (module->type != type) {
            continue;
        }

        if (module->ctx_index != NGX_MODULE_UNSET_INDEX) {

            /* if ctx_index was assigned, preserve it */

            if (module->ctx_index > max) {
                max = module->ctx_index;
            }

            if (module->ctx_index == next) {
                next++;
            }

            continue;
        }

        /* search for some free index */

        module->ctx_index = ngx_module_ctx_index(cycle, type, next);

        if (module->ctx_index > max) {
            max = module->ctx_index;
        }

        next = module->ctx_index + 1;
    }

    /*
     * make sure the number returned is big enoug...",1,1,core\ngx_module.c,ngx_count_modules,,false,82,153,ngx_count_modules,,,8,"ngx_int_t ngx_count_modules (ngx_cycle_t*,ngx_uint_t)"
29478,METHOD,core\ngx_module.c:<global>,TYPE_DECL,"ngx_int_t
ngx_add_module(ngx_conf_t *cf, ngx_str_t *file, ngx_module_t *module,
    char **order)
{
    void               *rv;
    ngx_uint_t          i, m, before;
    ngx_core_module_t  *core_module;

    if (cf->cycle->modules_n >= ngx_max_module) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""too many modules loaded"");
        return NGX_ERROR;
    }

    if (module->version != nginx_version) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""module \""%V\"" version %ui instead of %ui"",
                           file, module->version, (ngx_uint_t) nginx_version);
        return NGX_ERROR;
    }

    if (ngx_strcmp(module->signature, NGX_MODULE_SIGNATURE) != 0) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""module \""%V\"" is not binary compatible"",
                           file);
        return NGX_ERROR;
    }

    for (m = 0; cf->cycle->modules[m]; m++) {
        if (ngx_strcmp(cf->cycl...",1,1,core\ngx_module.c,ngx_add_module,,false,156,276,ngx_add_module,,,9,"ngx_int_t ngx_add_module (ngx_conf_t*,ngx_str_t*,ngx_module_t*,char**)"
29804,METHOD,core\ngx_module.c:<global>,TYPE_DECL,"static ngx_uint_t
ngx_module_index(ngx_cycle_t *cycle)
{
    ngx_uint_t     i, index;
    ngx_module_t  *module;

    index = 0;

again:

    /* find an unused index */

    for (i = 0; cycle->modules[i]; i++) {
        module = cycle->modules[i];

        if (module->index == index) {
            index++;
            goto again;
        }
    }

    /* check previous cycle */

    if (cycle->old_cycle && cycle->old_cycle->modules) {

        for (i = 0; cycle->old_cycle->modules[i]; i++) {
            module = cycle->old_cycle->modules[i];

            if (module->index == index) {
                index++;
                goto again;
            }
        }
    }

    return index;
}",1,1,core\ngx_module.c,ngx_module_index,,false,279,315,ngx_module_index,,,10,ngx_uint_t ngx_module_index (ngx_cycle_t*)
29893,METHOD,core\ngx_module.c:<global>,TYPE_DECL,"static ngx_uint_t
ngx_module_ctx_index(ngx_cycle_t *cycle, ngx_uint_t type, ngx_uint_t index)
{
    ngx_uint_t     i;
    ngx_module_t  *module;

again:

    /* find an unused ctx_index */

    for (i = 0; cycle->modules[i]; i++) {
        module = cycle->modules[i];

        if (module->type != type) {
            continue;
        }

        if (module->ctx_index == index) {
            index++;
            goto again;
        }
    }

    /* check previous cycle */

    if (cycle->old_cycle && cycle->old_cycle->modules) {

        for (i = 0; cycle->old_cycle->modules[i]; i++) {
            module = cycle->old_cycle->modules[i];

            if (module->type != type) {
                continue;
            }

            if (module->ctx_index == index) {
                index++;
                goto again;
            }
        }
    }

    return index;
}",1,1,core\ngx_module.c,ngx_module_ctx_index,,false,318,360,ngx_module_ctx_index,,,11,"ngx_uint_t ngx_module_ctx_index (ngx_cycle_t*,ngx_uint_t,ngx_uint_t)"
30005,METHOD,core\ngx_module.h:<global>,TYPE_DECL,<global>,1,36,core\ngx_module.h,core\ngx_module.h:<global>,,false,1,283,<global>,,,1,
30018,METHOD,ngx_module_s,TYPE_DECL,ngx_int_t           (*init_master)(ngx_log_t *log);,25,54,core\ngx_module.h,ngx_module_s.init_master,,false,238,238,init_master,,,11,ngx_int_t ngx_module_s.init_master (ngx_log_t*)
30023,METHOD,ngx_module_s,TYPE_DECL,ngx_int_t           (*init_module)(ngx_cycle_t *cycle);,25,58,core\ngx_module.h,ngx_module_s.init_module,,false,240,240,init_module,,,12,ngx_int_t ngx_module_s.init_module (ngx_cycle_t*)
30028,METHOD,ngx_module_s,TYPE_DECL,ngx_int_t           (*init_process)(ngx_cycle_t *cycle);,25,59,core\ngx_module.h,ngx_module_s.init_process,,false,242,242,init_process,,,13,ngx_int_t ngx_module_s.init_process (ngx_cycle_t*)
30033,METHOD,ngx_module_s,TYPE_DECL,ngx_int_t           (*init_thread)(ngx_cycle_t *cycle);,25,58,core\ngx_module.h,ngx_module_s.init_thread,,false,243,243,init_thread,,,14,ngx_int_t ngx_module_s.init_thread (ngx_cycle_t*)
30038,METHOD,ngx_module_s,TYPE_DECL,void                (*exit_thread)(ngx_cycle_t *cycle);,25,58,core\ngx_module.h,ngx_module_s.exit_thread,,false,244,244,exit_thread,,,15,void ngx_module_s.exit_thread (ngx_cycle_t*)
30043,METHOD,ngx_module_s,TYPE_DECL,void                (*exit_process)(ngx_cycle_t *cycle);,25,59,core\ngx_module.h,ngx_module_s.exit_process,,false,245,245,exit_process,,,16,void ngx_module_s.exit_process (ngx_cycle_t*)
30048,METHOD,ngx_module_s,TYPE_DECL,void                (*exit_master)(ngx_cycle_t *cycle);,25,58,core\ngx_module.h,ngx_module_s.exit_master,,false,247,247,exit_master,,,17,void ngx_module_s.exit_master (ngx_cycle_t*)
30063,METHOD,ngx_core_module_t,TYPE_DECL,void               *(*create_conf)(ngx_cycle_t *cycle);,24,58,core\ngx_module.h,ngx_core_module_t.create_conf,,false,262,262,create_conf,,,2,void* ngx_core_module_t.create_conf (ngx_cycle_t*)
30068,METHOD,ngx_core_module_t,TYPE_DECL,"char               *(*init_conf)(ngx_cycle_t *cycle, void *conf);",24,68,core\ngx_module.h,ngx_core_module_t.init_conf,,false,263,263,init_conf,,,3,"char* ngx_core_module_t.init_conf (ngx_cycle_t*,void*)"
30075,METHOD,core\ngx_module.h:<global>,TYPE_DECL,ngx_int_t ngx_preinit_modules(void);,11,35,core\ngx_module.h,ngx_preinit_modules,,false,267,267,ngx_preinit_modules,,,4,ngx_int_t ngx_preinit_modules (void)
30080,METHOD,core\ngx_module.h:<global>,TYPE_DECL,ngx_int_t ngx_cycle_modules(ngx_cycle_t *cycle);,11,47,core\ngx_module.h,ngx_cycle_modules,,false,268,268,ngx_cycle_modules,,,5,ngx_int_t ngx_cycle_modules (ngx_cycle_t*)
30085,METHOD,core\ngx_module.h:<global>,TYPE_DECL,ngx_int_t ngx_init_modules(ngx_cycle_t *cycle);,11,46,core\ngx_module.h,ngx_init_modules,,false,269,269,ngx_init_modules,,,6,ngx_int_t ngx_init_modules (ngx_cycle_t*)
30090,METHOD,core\ngx_module.h:<global>,TYPE_DECL,"ngx_int_t ngx_count_modules(ngx_cycle_t *cycle, ngx_uint_t type);",11,64,core\ngx_module.h,ngx_count_modules,,false,270,270,ngx_count_modules,,,7,"ngx_int_t ngx_count_modules (ngx_cycle_t*,ngx_uint_t)"
30096,METHOD,core\ngx_module.h:<global>,TYPE_DECL,"ngx_int_t ngx_add_module(ngx_conf_t *cf, ngx_str_t *file,
    ngx_module_t *module, char **order);",11,39,core\ngx_module.h,ngx_add_module,,false,273,274,ngx_add_module,,,8,"ngx_int_t ngx_add_module (ngx_conf_t*,ngx_str_t*,ngx_module_t*,char**)"
30116,METHOD,core\ngx_murmurhash.c:<global>,TYPE_DECL,<global>,1,1,core\ngx_murmurhash.c,core\ngx_murmurhash.c:<global>,,false,1,52,<global>,,,1,
30118,METHOD,core\ngx_murmurhash.c:<global>,TYPE_DECL,"uint32_t
ngx_murmur_hash2(u_char *data, size_t len)
{
    uint32_t  h, k;

    h = 0 ^ len;

    while (len >= 4) {
        k  = data[0];
        k |= data[1] << 8;
        k |= data[2] << 16;
        k |= data[3] << 24;

        k *= 0x5bd1e995;
        k ^= k >> 24;
        k *= 0x5bd1e995;

        h *= 0x5bd1e995;
        h ^= k;

        data += 4;
        len -= 4;
    }

    switch (len) {
    case 3:
        h ^= data[2] << 16;
        /* fall through */
    case 2:
        h ^= data[1] << 8;
        /* fall through */
    case 1:
        h ^= data[0];
        h *= 0x5bd1e995;
    }

    h ^= h >> 13;
    h *= 0x5bd1e995;
    h ^= h >> 15;

    return h;
}",1,1,core\ngx_murmurhash.c,ngx_murmur_hash2,,false,11,52,ngx_murmur_hash2,,,1,"uint32_t ngx_murmur_hash2 (u_char*,size_t)"
30238,METHOD,core\ngx_murmurhash.h:<global>,TYPE_DECL,<global>,1,40,core\ngx_murmurhash.h,core\ngx_murmurhash.h:<global>,,false,1,19,<global>,,,1,
30240,METHOD,core\ngx_murmurhash.h:<global>,TYPE_DECL,"uint32_t ngx_murmur_hash2(u_char *data, size_t len);",10,51,core\ngx_murmurhash.h,ngx_murmur_hash2,,false,16,16,ngx_murmur_hash2,,,1,"uint32_t ngx_murmur_hash2 (u_char*,size_t)"
30255,METHOD,core\ngx_open_file_cache.c:<global>,TYPE_DECL,<global>,1,51,core\ngx_open_file_cache.c,core\ngx_open_file_cache.c:<global>,,false,1,1253,<global>,,,1,
30257,METHOD,core\ngx_open_file_cache.c:<global>,TYPE_DECL,static void ngx_open_file_cache_cleanup(void *data);,13,51,core\ngx_open_file_cache.c,ngx_open_file_cache_cleanup,,false,24,24,ngx_open_file_cache_cleanup,,,1,void ngx_open_file_cache_cleanup (void*)
30262,METHOD,core\ngx_open_file_cache.c:<global>,TYPE_DECL,"static ngx_fd_t ngx_open_file_wrapper(ngx_str_t *name,
    ngx_open_file_info_t *of, ngx_int_t mode, ngx_int_t create,
    ngx_int_t access, ngx_log_t *log);",17,37,core\ngx_open_file_cache.c,ngx_open_file_wrapper,,false,33,35,ngx_open_file_wrapper,,,2,"ngx_fd_t ngx_open_file_wrapper (ngx_str_t*,ngx_open_file_info_t*,ngx_int_t,ngx_int_t,ngx_int_t,ngx_log_t*)"
30272,METHOD,core\ngx_open_file_cache.c:<global>,TYPE_DECL,"static ngx_int_t ngx_file_info_wrapper(ngx_str_t *name,
    ngx_open_file_info_t *of, ngx_file_info_t *fi, ngx_log_t *log);",18,66,core\ngx_open_file_cache.c,ngx_file_info_wrapper,,false,36,37,ngx_file_info_wrapper,,,3,"ngx_int_t ngx_file_info_wrapper (ngx_str_t*,ngx_open_file_info_t*,ngx_file_info_t*,ngx_log_t*)"
30280,METHOD,core\ngx_open_file_cache.c:<global>,TYPE_DECL,"static ngx_int_t ngx_open_and_stat_file(ngx_str_t *name,
    ngx_open_file_info_t *of, ngx_log_t *log);",18,45,core\ngx_open_file_cache.c,ngx_open_and_stat_file,,false,38,39,ngx_open_and_stat_file,,,4,"ngx_int_t ngx_open_and_stat_file (ngx_str_t*,ngx_open_file_info_t*,ngx_log_t*)"
30287,METHOD,core\ngx_open_file_cache.c:<global>,TYPE_DECL,"static void ngx_open_file_add_event(ngx_open_file_cache_t *cache,
    ngx_cached_open_file_t *file, ngx_open_file_info_t *of, ngx_log_t *log);",13,75,core\ngx_open_file_cache.c,ngx_open_file_add_event,,false,40,41,ngx_open_file_add_event,,,5,"void ngx_open_file_add_event (ngx_open_file_cache_t*,ngx_cached_open_file_t*,ngx_open_file_info_t*,ngx_log_t*)"
30295,METHOD,core\ngx_open_file_cache.c:<global>,TYPE_DECL,static void ngx_open_file_cleanup(void *data);,13,45,core\ngx_open_file_cache.c,ngx_open_file_cleanup,,false,42,42,ngx_open_file_cleanup,,,6,void ngx_open_file_cleanup (void*)
30300,METHOD,core\ngx_open_file_cache.c:<global>,TYPE_DECL,"static void ngx_close_cached_file(ngx_open_file_cache_t *cache,
    ngx_cached_open_file_t *file, ngx_uint_t min_uses, ngx_log_t *log);",13,70,core\ngx_open_file_cache.c,ngx_close_cached_file,,false,43,44,ngx_close_cached_file,,,7,"void ngx_close_cached_file (ngx_open_file_cache_t*,ngx_cached_open_file_t*,ngx_uint_t,ngx_log_t*)"
30308,METHOD,core\ngx_open_file_cache.c:<global>,TYPE_DECL,static void ngx_open_file_del_event(ngx_cached_open_file_t *file);,13,65,core\ngx_open_file_cache.c,ngx_open_file_del_event,,false,45,45,ngx_open_file_del_event,,,8,void ngx_open_file_del_event (ngx_cached_open_file_t*)
30313,METHOD,core\ngx_open_file_cache.c:<global>,TYPE_DECL,"static void ngx_expire_old_cached_files(ngx_open_file_cache_t *cache,
    ngx_uint_t n, ngx_log_t *log);",13,33,core\ngx_open_file_cache.c,ngx_expire_old_cached_files,,false,46,47,ngx_expire_old_cached_files,,,9,"void ngx_expire_old_cached_files (ngx_open_file_cache_t*,ngx_uint_t,ngx_log_t*)"
30320,METHOD,core\ngx_open_file_cache.c:<global>,TYPE_DECL,"static void ngx_open_file_cache_rbtree_insert_value(ngx_rbtree_node_t *temp,
    ngx_rbtree_node_t *node, ngx_rbtree_node_t *sentinel);",13,57,core\ngx_open_file_cache.c,ngx_open_file_cache_rbtree_insert_value,,false,48,49,ngx_open_file_cache_rbtree_insert_value,,,10,"void ngx_open_file_cache_rbtree_insert_value (ngx_rbtree_node_t*,ngx_rbtree_node_t*,ngx_rbtree_node_t*)"
30327,METHOD,core\ngx_open_file_cache.c:<global>,TYPE_DECL,"static ngx_cached_open_file_t *
    ngx_open_file_lookup(ngx_open_file_cache_t *cache, ngx_str_t *name,
    uint32_t hash);",31,18,core\ngx_open_file_cache.c,ngx_open_file_lookup,,false,50,52,ngx_open_file_lookup,,,11,"ngx_cached_open_file_t* ngx_open_file_lookup (ngx_open_file_cache_t*,ngx_str_t*,uint32_t)"
30334,METHOD,core\ngx_open_file_cache.c:<global>,TYPE_DECL,static void ngx_open_file_cache_remove(ngx_event_t *ev);,13,55,core\ngx_open_file_cache.c,ngx_open_file_cache_remove,,false,53,53,ngx_open_file_cache_remove,,,12,void ngx_open_file_cache_remove (ngx_event_t*)
30339,METHOD,core\ngx_open_file_cache.c:<global>,TYPE_DECL,"ngx_open_file_cache_t *
ngx_open_file_cache_init(ngx_pool_t *pool, ngx_uint_t max, time_t inactive)
{
    ngx_pool_cleanup_t     *cln;
    ngx_open_file_cache_t  *cache;

    cache = ngx_palloc(pool, sizeof(ngx_open_file_cache_t));
    if (cache == NULL) {
        return NULL;
    }

    ngx_rbtree_init(&cache->rbtree, &cache->sentinel,
                    ngx_open_file_cache_rbtree_insert_value);

    ngx_queue_init(&cache->expire_queue);

    cache->current = 0;
    cache->max = max;
    cache->inactive = inactive;

    cln = ngx_pool_cleanup_add(pool, 0);
    if (cln == NULL) {
        return NULL;
    }

    cln->handler = ngx_open_file_cache_cleanup;
    cln->data = cache;

    return cache;
}",1,1,core\ngx_open_file_cache.c,ngx_open_file_cache_init,,false,56,85,ngx_open_file_cache_init,,,13,"ngx_open_file_cache_t ngx_open_file_cache_init (ngx_pool_t*,ngx_uint_t,time_t)"
30415,METHOD,core\ngx_open_file_cache.c:<global>,TYPE_DECL,"static void
ngx_open_file_cache_cleanup(void *data)
{
    ngx_open_file_cache_t  *cache = data;

    ngx_queue_t             *q;
    ngx_cached_open_file_t  *file;

    ngx_log_debug0(NGX_LOG_DEBUG_CORE, ngx_cycle->log, 0,
                   ""open file cache cleanup"");

    for ( ;; ) {

        if (ngx_queue_empty(&cache->expire_queue)) {
            break;
        }

        q = ngx_queue_last(&cache->expire_queue);

        file = ngx_queue_data(q, ngx_cached_open_file_t, queue);

        ngx_queue_remove(q);

        ngx_rbtree_delete(&cache->rbtree, &file->node);

        cache->current--;

        ngx_log_debug1(NGX_LOG_DEBUG_CORE, ngx_cycle->log, 0,
                       ""delete cached open file: %s"", file->name);

        if (!file->err && !file->is_dir) {
            file->close = 1;
            file->count = 0;
            ngx_close_cached_file(cache, file, 0, ngx_cycle->log);

        } else {
            ngx_free(file->name);
            ngx_free(file);
        }
    }
...",1,1,core\ngx_open_file_cache.c,ngx_open_file_cache_cleanup,,false,88,140,ngx_open_file_cache_cleanup,,,14,void ngx_open_file_cache_cleanup (void*)
30553,METHOD,core\ngx_open_file_cache.c:<global>,TYPE_DECL,"ngx_int_t
ngx_open_cached_file(ngx_open_file_cache_t *cache, ngx_str_t *name,
    ngx_open_file_info_t *of, ngx_pool_t *pool)
{
    time_t                          now;
    uint32_t                        hash;
    ngx_int_t                       rc;
    ngx_file_info_t                 fi;
    ngx_pool_cleanup_t             *cln;
    ngx_cached_open_file_t         *file;
    ngx_pool_cleanup_file_t        *clnf;
    ngx_open_file_cache_cleanup_t  *ofcln;

    of->fd = NGX_INVALID_FILE;
    of->err = 0;

    if (cache == NULL) {

        if (of->test_only) {

            if (ngx_file_info_wrapper(name, of, &fi, pool->log)
                == NGX_FILE_ERROR)
            {
                return NGX_ERROR;
            }

            of->uniq = ngx_file_uniq(&fi);
            of->mtime = ngx_file_mtime(&fi);
            of->size = ngx_file_size(&fi);
            of->fs_size = ngx_file_fs_size(&fi);
            of->is_dir = ngx_is_dir(&fi);
            of->is_file = ngx_is_file(&fi);
    ...",1,1,core\ngx_open_file_cache.c,ngx_open_cached_file,,false,143,486,ngx_open_cached_file,,,15,"ngx_int_t ngx_open_cached_file (ngx_open_file_cache_t*,ngx_str_t*,ngx_open_file_info_t*,ngx_pool_t*)"
31526,METHOD,core\ngx_open_file_cache.c:<global>,TYPE_DECL,"static ngx_fd_t
ngx_open_file_wrapper(ngx_str_t *name, ngx_open_file_info_t *of,
    ngx_int_t mode, ngx_int_t create, ngx_int_t access, ngx_log_t *log)
{
    ngx_fd_t  fd;

#if !(NGX_HAVE_OPENAT)

    fd = ngx_open_file(name->data, mode, create, access);

    if (fd == NGX_INVALID_FILE) {
        of->err = ngx_errno;
        of->failed = ngx_open_file_n;
        return NGX_INVALID_FILE;
    }

    return fd;

#else

    u_char           *p, *cp, *end;
    ngx_fd_t          at_fd;
    ngx_str_t         at_name;

    if (of->disable_symlinks == NGX_DISABLE_SYMLINKS_OFF) {
        fd = ngx_open_file(name->data, mode, create, access);

        if (fd == NGX_INVALID_FILE) {
            of->err = ngx_errno;
            of->failed = ngx_open_file_n;
            return NGX_INVALID_FILE;
        }

        return fd;
    }

    p = name->data;
    end = p + name->len;

    at_name = *name;

    if (of->disable_symlinks_from) {

        cp = p + of->disable_symlinks_from;

        *cp = '\0'...",1,1,core\ngx_open_file_cache.c,ngx_open_file_wrapper,,false,613,777,ngx_open_file_wrapper,,,16,"ngx_fd_t ngx_open_file_wrapper (ngx_str_t*,ngx_open_file_info_t*,ngx_int_t,ngx_int_t,ngx_int_t,ngx_log_t*)"
31565,METHOD,core\ngx_open_file_cache.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_file_info_wrapper(ngx_str_t *name, ngx_open_file_info_t *of,
    ngx_file_info_t *fi, ngx_log_t *log)
{
    ngx_int_t  rc;

#if !(NGX_HAVE_OPENAT)

    rc = ngx_file_info(name->data, fi);

    if (rc == NGX_FILE_ERROR) {
        of->err = ngx_errno;
        of->failed = ngx_file_info_n;
        return NGX_FILE_ERROR;
    }

    return rc;

#else

    ngx_fd_t  fd;

    if (of->disable_symlinks == NGX_DISABLE_SYMLINKS_OFF) {

        rc = ngx_file_info(name->data, fi);

        if (rc == NGX_FILE_ERROR) {
            of->err = ngx_errno;
            of->failed = ngx_file_info_n;
            return NGX_FILE_ERROR;
        }

        return rc;
    }

    fd = ngx_open_file_wrapper(name, of, NGX_FILE_RDONLY|NGX_FILE_NONBLOCK,
                               NGX_FILE_OPEN, 0, log);

    if (fd == NGX_INVALID_FILE) {
        return NGX_FILE_ERROR;
    }

    rc = ngx_fd_info(fd, fi);

    if (rc == NGX_FILE_ERROR) {
        of->err = ngx_errno;
        of->failed = ng...",1,1,core\ngx_open_file_cache.c,ngx_file_info_wrapper,,false,780,836,ngx_file_info_wrapper,,,17,"ngx_int_t ngx_file_info_wrapper (ngx_str_t*,ngx_open_file_info_t*,ngx_file_info_t*,ngx_log_t*)"
31600,METHOD,core\ngx_open_file_cache.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_open_and_stat_file(ngx_str_t *name, ngx_open_file_info_t *of,
    ngx_log_t *log)
{
    ngx_fd_t         fd;
    ngx_file_info_t  fi;

    if (of->fd != NGX_INVALID_FILE) {

        if (ngx_file_info_wrapper(name, of, &fi, log) == NGX_FILE_ERROR) {
            of->fd = NGX_INVALID_FILE;
            return NGX_ERROR;
        }

        if (of->uniq == ngx_file_uniq(&fi)) {
            goto done;
        }

    } else if (of->test_dir) {

        if (ngx_file_info_wrapper(name, of, &fi, log) == NGX_FILE_ERROR) {
            of->fd = NGX_INVALID_FILE;
            return NGX_ERROR;
        }

        if (ngx_is_dir(&fi)) {
            goto done;
        }
    }

    if (!of->log) {

        /*
         * Use non-blocking open() not to hang on FIFO files, etc.
         * This flag has no effect on a regular files.
         */

        fd = ngx_open_file_wrapper(name, of, NGX_FILE_RDONLY|NGX_FILE_NONBLOCK,
                                   NGX_FILE_OPEN, 0, log);

  ...",1,51,core\ngx_open_file_cache.c,ngx_open_and_stat_file,,false,839,945,ngx_open_and_stat_file,,,18,"ngx_int_t ngx_open_and_stat_file (ngx_str_t*,ngx_open_file_info_t*,ngx_log_t*)"
31867,METHOD,core\ngx_open_file_cache.c:<global>,TYPE_DECL,"static void
ngx_open_file_add_event(ngx_open_file_cache_t *cache,
    ngx_cached_open_file_t *file, ngx_open_file_info_t *of, ngx_log_t *log)
{
    ngx_open_file_cache_event_t  *fev;

    if (!(ngx_event_flags & NGX_USE_VNODE_EVENT)
        || !of->events
        || file->event
        || of->fd == NGX_INVALID_FILE
        || file->uses < of->min_uses)
    {
        return;
    }

    file->use_event = 0;

    file->event = ngx_calloc(sizeof(ngx_event_t), log);
    if (file->event== NULL) {
        return;
    }

    fev = ngx_alloc(sizeof(ngx_open_file_cache_event_t), log);
    if (fev == NULL) {
        ngx_free(file->event);
        file->event = NULL;
        return;
    }

    fev->fd = of->fd;
    fev->file = file;
    fev->cache = cache;

    file->event->handler = ngx_open_file_cache_remove;
    file->event->data = fev;

    /*
     * although vnode event may be called while ngx_cycle->poll
     * destruction, however, cleanup procedures are run before any
     * memory free...",1,1,core\ngx_open_file_cache.c,ngx_open_file_add_event,,false,953,1014,ngx_open_file_add_event,,,19,"void ngx_open_file_add_event (ngx_open_file_cache_t*,ngx_cached_open_file_t*,ngx_open_file_info_t*,ngx_log_t*)"
32015,METHOD,core\ngx_open_file_cache.c:<global>,TYPE_DECL,"static void
ngx_open_file_cleanup(void *data)
{
    ngx_open_file_cache_cleanup_t  *c = data;

    c->file->count--;

    ngx_close_cached_file(c->cache, c->file, c->min_uses, c->log);

    /* drop one or two expired open files */
    ngx_expire_old_cached_files(c->cache, 1, c->log);
}",1,1,core\ngx_open_file_cache.c,ngx_open_file_cleanup,,false,1017,1028,ngx_open_file_cleanup,,,20,void ngx_open_file_cleanup (void*)
32051,METHOD,core\ngx_open_file_cache.c:<global>,TYPE_DECL,"static void
ngx_close_cached_file(ngx_open_file_cache_t *cache,
    ngx_cached_open_file_t *file, ngx_uint_t min_uses, ngx_log_t *log)
{
    ngx_log_debug5(NGX_LOG_DEBUG_CORE, log, 0,
                   ""close cached open file: %s, fd:%d, c:%d, u:%d, %d"",
                   file->name, file->fd, file->count, file->uses, file->close);

    if (!file->close) {

        file->accessed = ngx_time();

        ngx_queue_remove(&file->queue);

        ngx_queue_insert_head(&cache->expire_queue, &file->queue);

        if (file->uses >= min_uses || file->count) {
            return;
        }
    }

    ngx_open_file_del_event(file);

    if (file->count) {
        return;
    }

    if (file->fd != NGX_INVALID_FILE) {

        if (ngx_close_file(file->fd) == NGX_FILE_ERROR) {
            ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,
                          ngx_close_file_n "" \""%s\"" failed"", file->name);
        }

        file->fd = NGX_INVALID_FILE;
    }

    if (!file->close) {
       ...",1,1,core\ngx_open_file_cache.c,ngx_close_cached_file,,false,1031,1074,ngx_close_cached_file,,,21,"void ngx_close_cached_file (ngx_open_file_cache_t*,ngx_cached_open_file_t*,ngx_uint_t,ngx_log_t*)"
32158,METHOD,core\ngx_open_file_cache.c:<global>,TYPE_DECL,"static void
ngx_open_file_del_event(ngx_cached_open_file_t *file)
{
    if (file->event == NULL) {
        return;
    }

    (void) ngx_del_event(file->event, NGX_VNODE_EVENT,
                         file->count ? NGX_FLUSH_EVENT : NGX_CLOSE_EVENT);

    ngx_free(file->event->data);
    ngx_free(file->event);
    file->event = NULL;
    file->use_event = 0;
}",1,1,core\ngx_open_file_cache.c,ngx_open_file_del_event,,false,1077,1091,ngx_open_file_del_event,,,22,void ngx_open_file_del_event (ngx_cached_open_file_t*)
32204,METHOD,core\ngx_open_file_cache.c:<global>,TYPE_DECL,"static void
ngx_expire_old_cached_files(ngx_open_file_cache_t *cache, ngx_uint_t n,
    ngx_log_t *log)
{
    time_t                   now;
    ngx_queue_t             *q;
    ngx_cached_open_file_t  *file;

    now = ngx_time();

    /*
     * n == 1 deletes one or two inactive files
     * n == 0 deletes least recently used file by force
     *        and one or two inactive files
     */

    while (n < 3) {

        if (ngx_queue_empty(&cache->expire_queue)) {
            return;
        }

        q = ngx_queue_last(&cache->expire_queue);

        file = ngx_queue_data(q, ngx_cached_open_file_t, queue);

        if (n++ != 0 && now - file->accessed <= cache->inactive) {
            return;
        }

        ngx_queue_remove(q);

        ngx_rbtree_delete(&cache->rbtree, &file->node);

        cache->current--;

        ngx_log_debug1(NGX_LOG_DEBUG_CORE, log, 0,
                       ""expire cached open file: %s"", file->name);

        if (!file->err && !file->is_dir) {
      ...",1,1,core\ngx_open_file_cache.c,ngx_expire_old_cached_files,,false,1094,1142,ngx_expire_old_cached_files,,,23,"void ngx_expire_old_cached_files (ngx_open_file_cache_t*,ngx_uint_t,ngx_log_t*)"
32312,METHOD,core\ngx_open_file_cache.c:<global>,TYPE_DECL,"static void
ngx_open_file_cache_rbtree_insert_value(ngx_rbtree_node_t *temp,
    ngx_rbtree_node_t *node, ngx_rbtree_node_t *sentinel)
{
    ngx_rbtree_node_t       **p;
    ngx_cached_open_file_t    *file, *file_temp;

    for ( ;; ) {

        if (node->key < temp->key) {

            p = &temp->left;

        } else if (node->key > temp->key) {

            p = &temp->right;

        } else { /* node->key == temp->key */

            file = (ngx_cached_open_file_t *) node;
            file_temp = (ngx_cached_open_file_t *) temp;

            p = (ngx_strcmp(file->name, file_temp->name) < 0)
                    ? &temp->left : &temp->right;
        }

        if (*p == sentinel) {
            break;
        }

        temp = *p;
    }

    *p = node;
    node->parent = temp;
    node->left = sentinel;
    node->right = sentinel;
    ngx_rbt_red(node);
}",1,1,core\ngx_open_file_cache.c,ngx_open_file_cache_rbtree_insert_value,,false,1145,1183,ngx_open_file_cache_rbtree_insert_value,,,24,"void ngx_open_file_cache_rbtree_insert_value (ngx_rbtree_node_t*,ngx_rbtree_node_t*,ngx_rbtree_node_t*)"
32421,METHOD,core\ngx_open_file_cache.c:<global>,TYPE_DECL,"static ngx_cached_open_file_t *
ngx_open_file_lookup(ngx_open_file_cache_t *cache, ngx_str_t *name,
    uint32_t hash)
{
    ngx_int_t                rc;
    ngx_rbtree_node_t       *node, *sentinel;
    ngx_cached_open_file_t  *file;

    node = cache->rbtree.root;
    sentinel = cache->rbtree.sentinel;

    while (node != sentinel) {

        if (hash < node->key) {
            node = node->left;
            continue;
        }

        if (hash > node->key) {
            node = node->right;
            continue;
        }

        /* hash == node->key */

        file = (ngx_cached_open_file_t *) node;

        rc = ngx_strcmp(name->data, file->name);

        if (rc == 0) {
            return file;
        }

        node = (rc < 0) ? node->left : node->right;
    }

    return NULL;
}",1,1,core\ngx_open_file_cache.c,ngx_open_file_lookup,,false,1186,1223,ngx_open_file_lookup,,,25,"ngx_cached_open_file_t ngx_open_file_lookup (ngx_open_file_cache_t*,ngx_str_t*,uint32_t)"
32512,METHOD,core\ngx_open_file_cache.c:<global>,TYPE_DECL,"static void
ngx_open_file_cache_remove(ngx_event_t *ev)
{
    ngx_cached_open_file_t       *file;
    ngx_open_file_cache_event_t  *fev;

    fev = ev->data;
    file = fev->file;

    ngx_queue_remove(&file->queue);

    ngx_rbtree_delete(&fev->cache->rbtree, &file->node);

    fev->cache->current--;

    /* NGX_ONESHOT_EVENT was already deleted */
    file->event = NULL;
    file->use_event = 0;

    file->close = 1;

    ngx_close_cached_file(fev->cache, file, 0, ev->log);

    /* free memory only when fev->cache and fev->file are already not needed */

    ngx_free(ev->data);
    ngx_free(ev);
}",1,1,core\ngx_open_file_cache.c,ngx_open_file_cache_remove,,false,1226,1253,ngx_open_file_cache_remove,,,26,void ngx_open_file_cache_remove (ngx_event_t*)
32588,METHOD,core\ngx_open_file_cache.h:<global>,TYPE_DECL,<global>,1,45,core\ngx_open_file_cache.h,core\ngx_open_file_cache.h:<global>,,false,1,129,<global>,,,1,
32662,METHOD,core\ngx_open_file_cache.h:<global>,TYPE_DECL,"ngx_open_file_cache_t *ngx_open_file_cache_init(ngx_pool_t *pool,
    ngx_uint_t max, time_t inactive);",23,36,core\ngx_open_file_cache.h,ngx_open_file_cache_init,,false,123,124,ngx_open_file_cache_init,,,12,"ngx_open_file_cache_t* ngx_open_file_cache_init (ngx_pool_t*,ngx_uint_t,time_t)"
32669,METHOD,core\ngx_open_file_cache.h:<global>,TYPE_DECL,"ngx_int_t ngx_open_cached_file(ngx_open_file_cache_t *cache, ngx_str_t *name,
    ngx_open_file_info_t *of, ngx_pool_t *pool);",11,47,core\ngx_open_file_cache.h,ngx_open_cached_file,,false,125,126,ngx_open_cached_file,,,13,"ngx_int_t ngx_open_cached_file (ngx_open_file_cache_t*,ngx_str_t*,ngx_open_file_info_t*,ngx_pool_t*)"
32686,METHOD,core\ngx_output_chain.c:<global>,TYPE_DECL,<global>,1,11,core\ngx_output_chain.c,core\ngx_output_chain.c:<global>,,false,1,823,<global>,,,1,
32690,METHOD,core\ngx_output_chain.c:<global>,TYPE_DECL,"ngx_output_chain_as_is(ngx_output_chain_ctx_t *ctx, ngx_buf_t *buf);",5,71,core\ngx_output_chain.c,ngx_output_chain_as_is,,false,31,31,ngx_output_chain_as_is,,,3,"ANY ngx_output_chain_as_is (ngx_output_chain_ctx_t*,ngx_buf_t*)"
32696,METHOD,core\ngx_output_chain.c:<global>,TYPE_DECL,"static ngx_int_t ngx_output_chain_add_copy(ngx_pool_t *pool,
    ngx_chain_t **chain, ngx_chain_t *in);",18,41,core\ngx_output_chain.c,ngx_output_chain_add_copy,,false,36,37,ngx_output_chain_add_copy,,,4,"ngx_int_t ngx_output_chain_add_copy (ngx_pool_t*,ngx_chain_t**,ngx_chain_t*)"
32703,METHOD,core\ngx_output_chain.c:<global>,TYPE_DECL,"static ngx_int_t ngx_output_chain_align_file_buf(ngx_output_chain_ctx_t *ctx,
    off_t bsize);",18,16,core\ngx_output_chain.c,ngx_output_chain_align_file_buf,,false,38,39,ngx_output_chain_align_file_buf,,,5,"ngx_int_t ngx_output_chain_align_file_buf (ngx_output_chain_ctx_t*,off_t)"
32709,METHOD,core\ngx_output_chain.c:<global>,TYPE_DECL,"static ngx_int_t ngx_output_chain_get_buf(ngx_output_chain_ctx_t *ctx,
    off_t bsize);",18,16,core\ngx_output_chain.c,ngx_output_chain_get_buf,,false,40,41,ngx_output_chain_get_buf,,,6,"ngx_int_t ngx_output_chain_get_buf (ngx_output_chain_ctx_t*,off_t)"
32715,METHOD,core\ngx_output_chain.c:<global>,TYPE_DECL,static ngx_int_t ngx_output_chain_copy_buf(ngx_output_chain_ctx_t *ctx);,18,71,core\ngx_output_chain.c,ngx_output_chain_copy_buf,,false,42,42,ngx_output_chain_copy_buf,,,7,ngx_int_t ngx_output_chain_copy_buf (ngx_output_chain_ctx_t*)
32720,METHOD,core\ngx_output_chain.c:<global>,TYPE_DECL,"ngx_int_t
ngx_output_chain(ngx_output_chain_ctx_t *ctx, ngx_chain_t *in)
{
    off_t         bsize;
    ngx_int_t     rc, last;
    ngx_chain_t  *cl, *out, **last_out;

    if (ctx->in == NULL && ctx->busy == NULL
#if (NGX_HAVE_FILE_AIO || NGX_THREADS)
        && !ctx->aio
#endif
       )
    {
        /*
         * the short path for the case when the ctx->in and ctx->busy chains
         * are empty, the incoming chain is empty too or has the single buf
         * that does not require the copy
         */

        if (in == NULL) {
            return ctx->output_filter(ctx->filter_ctx, in);
        }

        if (in->next == NULL
#if (NGX_SENDFILE_LIMIT)
            && !(in->buf->in_file && in->buf->file_last > NGX_SENDFILE_LIMIT)
#endif
            && ngx_output_chain_as_is(ctx, in->buf))
        {
            return ctx->output_filter(ctx->filter_ctx, in);
        }
    }

    /* add the incoming buf to the chain ctx->in */

    if (in) {
        if (ngx_output_chain_add_copy(c...",1,11,core\ngx_output_chain.c,ngx_output_chain,,false,45,244,ngx_output_chain,,,8,"ngx_int_t ngx_output_chain (ngx_output_chain_ctx_t*,ngx_chain_t*)"
33265,METHOD,core\ngx_output_chain.c:<global>,TYPE_DECL,"ngx_output_chain_as_is(ngx_output_chain_ctx_t *ctx, ngx_buf_t *buf)
{
    ngx_uint_t  sendfile;

    if (ngx_buf_special(buf)) {
        return 1;
    }

#if (NGX_THREADS)
    if (buf->in_file) {
        buf->file->thread_handler = ctx->thread_handler;
        buf->file->thread_ctx = ctx->filter_ctx;
    }
#endif

    if (buf->in_file && buf->file->directio) {
        return 0;
    }

    sendfile = ctx->sendfile;

#if (NGX_SENDFILE_LIMIT)

    if (buf->in_file && buf->file_pos >= NGX_SENDFILE_LIMIT) {
        sendfile = 0;
    }

#endif

    if (!sendfile) {

        if (!ngx_buf_in_memory(buf)) {
            return 0;
        }

        buf->in_file = 0;
    }

#if (NGX_HAVE_AIO_SENDFILE)
    if (ctx->aio_preload && buf->in_file) {
        (void) ngx_output_chain_aio_setup(ctx, buf->file);
    }
#endif

    if (ctx->need_in_memory && !ngx_buf_in_memory(buf)) {
        return 0;
    }

    if (ctx->need_in_temp && (buf->memory || buf->mmap)) {
        return 0;
    }

    return 1;
}",1,1,core\ngx_output_chain.c,ngx_output_chain_as_is,,false,248,301,ngx_output_chain_as_is,,,11,"ANY ngx_output_chain_as_is (ngx_output_chain_ctx_t*,ngx_buf_t*)"
33340,METHOD,core\ngx_output_chain.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_output_chain_add_copy(ngx_pool_t *pool, ngx_chain_t **chain,
    ngx_chain_t *in)
{
    ngx_chain_t  *cl, **ll;
#if (NGX_SENDFILE_LIMIT)
    ngx_buf_t    *b, *buf;
#endif

    ll = chain;

    for (cl = *chain; cl; cl = cl->next) {
        ll = &cl->next;
    }

    while (in) {

        cl = ngx_alloc_chain_link(pool);
        if (cl == NULL) {
            return NGX_ERROR;
        }

#if (NGX_SENDFILE_LIMIT)

        buf = in->buf;

        if (buf->in_file
            && buf->file_pos < NGX_SENDFILE_LIMIT
            && buf->file_last > NGX_SENDFILE_LIMIT)
        {
            /* split a file buf on two bufs by the sendfile limit */

            b = ngx_calloc_buf(pool);
            if (b == NULL) {
                return NGX_ERROR;
            }

            ngx_memcpy(b, buf, sizeof(ngx_buf_t));

            if (ngx_buf_in_memory(buf)) {
                buf->pos += (ssize_t) (NGX_SENDFILE_LIMIT - buf->file_pos);
                b->last = buf->pos;
        ...",1,1,core\ngx_output_chain.c,ngx_output_chain_add_copy,,false,326,392,ngx_output_chain_add_copy,,,12,"ngx_int_t ngx_output_chain_add_copy (ngx_pool_t*,ngx_chain_t**,ngx_chain_t*)"
33414,METHOD,core\ngx_output_chain.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_output_chain_align_file_buf(ngx_output_chain_ctx_t *ctx, off_t bsize)
{
    size_t      size;
    ngx_buf_t  *in;

    in = ctx->in->buf;

    if (in->file == NULL || !in->file->directio) {
        return NGX_DECLINED;
    }

    ctx->directio = 1;

    size = (size_t) (in->file_pos - (in->file_pos & ~(ctx->alignment - 1)));

    if (size == 0) {

        if (bsize >= (off_t) ctx->bufs.size) {
            return NGX_DECLINED;
        }

        size = (size_t) bsize;

    } else {
        size = (size_t) ctx->alignment - size;

        if ((off_t) size > bsize) {
            size = (size_t) bsize;
        }
    }

    ctx->buf = ngx_create_temp_buf(ctx->pool, size);
    if (ctx->buf == NULL) {
        return NGX_ERROR;
    }

    /*
     * we do not set ctx->buf->tag, because we do not want
     * to reuse the buf via ctx->free list
     */

#if (NGX_HAVE_ALIGNED_DIRECTIO)
    ctx->unaligned = 1;
#endif

    return NGX_OK;
}",1,1,core\ngx_output_chain.c,ngx_output_chain_align_file_buf,,false,395,442,ngx_output_chain_align_file_buf,,,13,"ngx_int_t ngx_output_chain_align_file_buf (ngx_output_chain_ctx_t*,off_t)"
33533,METHOD,core\ngx_output_chain.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_output_chain_get_buf(ngx_output_chain_ctx_t *ctx, off_t bsize)
{
    size_t       size;
    ngx_buf_t   *b, *in;
    ngx_uint_t   recycled;

    in = ctx->in->buf;
    size = ctx->bufs.size;
    recycled = 1;

    if (in->last_in_chain) {

        if (bsize < (off_t) size) {

            /*
             * allocate a small temp buf for a small last buf
             * or its small last part
             */

            size = (size_t) bsize;
            recycled = 0;

        } else if (!ctx->directio
                   && ctx->bufs.num == 1
                   && (bsize < (off_t) (size + size / 4)))
        {
            /*
             * allocate a temp buf that equals to a last buf,
             * if there is no directio, the last buf size is lesser
             * than 1.25 of bufs.size and the temp buf is single
             */

            size = (size_t) bsize;
            recycled = 0;
        }
    }

    b = ngx_calloc_buf(ctx->pool);
    if (b == NULL) {
...",1,1,core\ngx_output_chain.c,ngx_output_chain_get_buf,,false,445,518,ngx_output_chain_get_buf,,,14,"ngx_int_t ngx_output_chain_get_buf (ngx_output_chain_ctx_t*,off_t)"
33725,METHOD,core\ngx_output_chain.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_output_chain_copy_buf(ngx_output_chain_ctx_t *ctx)
{
    off_t        size;
    ssize_t      n;
    ngx_buf_t   *src, *dst;
    ngx_uint_t   sendfile;

    src = ctx->in->buf;
    dst = ctx->buf;

    size = ngx_buf_size(src);
    size = ngx_min(size, dst->end - dst->pos);

    sendfile = ctx->sendfile && !ctx->directio;

#if (NGX_SENDFILE_LIMIT)

    if (src->in_file && src->file_pos >= NGX_SENDFILE_LIMIT) {
        sendfile = 0;
    }

#endif

    if (ngx_buf_in_memory(src)) {
        ngx_memcpy(dst->pos, src->pos, (size_t) size);
        src->pos += (size_t) size;
        dst->last += (size_t) size;

        if (src->in_file) {

            if (sendfile) {
                dst->in_file = 1;
                dst->file = src->file;
                dst->file_pos = src->file_pos;
                dst->file_last = src->file_pos + size;

            } else {
                dst->in_file = 0;
            }

            src->file_pos += size;

        } else {
         ...",1,1,core\ngx_output_chain.c,ngx_output_chain_copy_buf,,false,521,672,ngx_output_chain_copy_buf,,,15,ngx_int_t ngx_output_chain_copy_buf (ngx_output_chain_ctx_t*)
34000,METHOD,core\ngx_output_chain.c:<global>,TYPE_DECL,"ngx_int_t
ngx_chain_writer(void *data, ngx_chain_t *in)
{
    ngx_chain_writer_ctx_t *ctx = data;

    off_t              size;
    ngx_chain_t       *cl, *ln, *chain;
    ngx_connection_t  *c;

    c = ctx->connection;

    for (size = 0; in; in = in->next) {

        if (ngx_buf_size(in->buf) == 0 && !ngx_buf_special(in->buf)) {

            ngx_log_error(NGX_LOG_ALERT, ctx->pool->log, 0,
                          ""zero size buf in chain writer ""
                          ""t:%d r:%d f:%d %p %p-%p %p %O-%O"",
                          in->buf->temporary,
                          in->buf->recycled,
                          in->buf->in_file,
                          in->buf->start,
                          in->buf->pos,
                          in->buf->last,
                          in->buf->file,
                          in->buf->file_pos,
                          in->buf->file_last);

            ngx_debug_point();

            continue;
        }

        if (ngx_buf_size(...",1,1,core\ngx_output_chain.c,ngx_chain_writer,,false,675,823,ngx_chain_writer,,,16,"ngx_int_t ngx_chain_writer (void*,ngx_chain_t*)"
34496,METHOD,core\ngx_palloc.c:<global>,TYPE_DECL,<global>,1,6,core\ngx_palloc.c,core\ngx_palloc.c:<global>,,false,1,430,<global>,,,1,
34499,METHOD,core\ngx_palloc.c:<global>,TYPE_DECL,"static void *ngx_palloc_block(ngx_pool_t *pool, size_t size);",13,60,core\ngx_palloc.c,ngx_palloc_block,,false,14,14,ngx_palloc_block,,,2,"void* ngx_palloc_block (ngx_pool_t*,size_t)"
34505,METHOD,core\ngx_palloc.c:<global>,TYPE_DECL,"static void *ngx_palloc_large(ngx_pool_t *pool, size_t size);",13,60,core\ngx_palloc.c,ngx_palloc_large,,false,15,15,ngx_palloc_large,,,3,"void* ngx_palloc_large (ngx_pool_t*,size_t)"
34511,METHOD,core\ngx_palloc.c:<global>,TYPE_DECL,"ngx_pool_t *
ngx_create_pool(size_t size, ngx_log_t *log)
{
    ngx_pool_t  *p;

    p = ngx_memalign(NGX_POOL_ALIGNMENT, size, log);
    if (p == NULL) {
        return NULL;
    }

    p->d.last = (u_char *) p + sizeof(ngx_pool_t);
    p->d.end = (u_char *) p + size;
    p->d.next = NULL;
    p->d.failed = 0;

    size = size - sizeof(ngx_pool_t);
    p->max = (size < NGX_MAX_ALLOC_FROM_POOL) ? size : NGX_MAX_ALLOC_FROM_POOL;

    p->current = p;
    p->chain = NULL;
    p->large = NULL;
    p->cleanup = NULL;
    p->log = log;

    return p;
}",1,1,core\ngx_palloc.c,ngx_create_pool,,false,18,43,ngx_create_pool,,,4,"ngx_pool_t ngx_create_pool (size_t,ngx_log_t*)"
34611,METHOD,core\ngx_palloc.c:<global>,TYPE_DECL,"void
ngx_destroy_pool(ngx_pool_t *pool)
{
    ngx_pool_t          *p, *n;
    ngx_pool_large_t    *l;
    ngx_pool_cleanup_t  *c;

    for (c = pool->cleanup; c; c = c->next) {
        if (c->handler) {
            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool->log, 0,
                           ""run cleanup: %p"", c);
            c->handler(c->data);
        }
    }

#if (NGX_DEBUG)

    /*
     * we could allocate the pool->log from this pool
     * so we cannot use this log while free()ing the pool
     */

    for (l = pool->large; l; l = l->next) {
        ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool->log, 0, ""free: %p"", l->alloc);
    }

    for (p = pool, n = pool->d.next; /* void */; p = n, n = n->d.next) {
        ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, pool->log, 0,
                       ""free: %p, unused: %uz"", p, p->d.end - p->d.last);

        if (n == NULL) {
            break;
        }
    }

#endif

    for (l = pool->large; l; l = l->next) {
        if (l->alloc) {
            ...",1,1,core\ngx_palloc.c,ngx_destroy_pool,,false,46,96,ngx_destroy_pool,,,5,void ngx_destroy_pool (ngx_pool_t*)
34710,METHOD,core\ngx_palloc.c:<global>,TYPE_DECL,"void
ngx_reset_pool(ngx_pool_t *pool)
{
    ngx_pool_t        *p;
    ngx_pool_large_t  *l;

    for (l = pool->large; l; l = l->next) {
        if (l->alloc) {
            ngx_free(l->alloc);
        }
    }

    for (p = pool; p; p = p->d.next) {
        p->d.last = (u_char *) p + sizeof(ngx_pool_t);
        p->d.failed = 0;
    }

    pool->current = pool;
    pool->chain = NULL;
    pool->large = NULL;
}",1,1,core\ngx_palloc.c,ngx_reset_pool,,false,99,119,ngx_reset_pool,,,6,void ngx_reset_pool (ngx_pool_t*)
34788,METHOD,core\ngx_palloc.c:<global>,TYPE_DECL,"void *
ngx_palloc(ngx_pool_t *pool, size_t size)
{
#if !(NGX_DEBUG_PALLOC)
    if (size <= pool->max) {
        return ngx_palloc_small(pool, size, 1);
    }
#endif

    return ngx_palloc_large(pool, size);
}",1,1,core\ngx_palloc.c,ngx_palloc,,false,122,132,ngx_palloc,,,7,"void* ngx_palloc (ngx_pool_t*,size_t)"
34810,METHOD,core\ngx_palloc.c:<global>,TYPE_DECL,"void *
ngx_pnalloc(ngx_pool_t *pool, size_t size)
{
#if !(NGX_DEBUG_PALLOC)
    if (size <= pool->max) {
        return ngx_palloc_small(pool, size, 0);
    }
#endif

    return ngx_palloc_large(pool, size);
}",1,1,core\ngx_palloc.c,ngx_pnalloc,,false,135,145,ngx_pnalloc,,,8,"void* ngx_pnalloc (ngx_pool_t*,size_t)"
34833,METHOD,core\ngx_palloc.c:<global>,TYPE_DECL,"static void *
ngx_palloc_block(ngx_pool_t *pool, size_t size)
{
    u_char      *m;
    size_t       psize;
    ngx_pool_t  *p, *new;

    psize = (size_t) (pool->d.end - (u_char *) pool);

    m = ngx_memalign(NGX_POOL_ALIGNMENT, psize, pool->log);
    if (m == NULL) {
        return NULL;
    }

    new = (ngx_pool_t *) m;

    new->d.end = m + psize;
    new->d.next = NULL;
    new->d.failed = 0;

    m += sizeof(ngx_pool_data_t);
    m = ngx_align_ptr(m, NGX_ALIGNMENT);
    new->d.last = m + size;

    for (p = pool->current; p->d.next; p = p->d.next) {
        if (p->d.failed++ > 4) {
            pool->current = p->d.next;
        }
    }

    p->d.next = new;

    return m;
}",1,1,core\ngx_palloc.c,ngx_palloc_block,,false,177,210,ngx_palloc_block,,,10,"void* ngx_palloc_block (ngx_pool_t*,size_t)"
34964,METHOD,core\ngx_palloc.c:<global>,TYPE_DECL,"static void *
ngx_palloc_large(ngx_pool_t *pool, size_t size)
{
    void              *p;
    ngx_uint_t         n;
    ngx_pool_large_t  *large;

    p = ngx_alloc(size, pool->log);
    if (p == NULL) {
        return NULL;
    }

    n = 0;

    for (large = pool->large; large; large = large->next) {
        if (large->alloc == NULL) {
            large->alloc = p;
            return p;
        }

        if (n++ > 3) {
            break;
        }
    }

    large = ngx_palloc_small(pool, sizeof(ngx_pool_large_t), 1);
    if (large == NULL) {
        ngx_free(p);
        return NULL;
    }

    large->alloc = p;
    large->next = pool->large;
    pool->large = large;

    return p;
}",1,1,core\ngx_palloc.c,ngx_palloc_large,,false,213,249,ngx_palloc_large,,,11,"void* ngx_palloc_large (ngx_pool_t*,size_t)"
35060,METHOD,core\ngx_palloc.c:<global>,TYPE_DECL,"void *
ngx_pmemalign(ngx_pool_t *pool, size_t size, size_t alignment)
{
    void              *p;
    ngx_pool_large_t  *large;

    p = ngx_memalign(alignment, size, pool->log);
    if (p == NULL) {
        return NULL;
    }

    large = ngx_palloc_small(pool, sizeof(ngx_pool_large_t), 1);
    if (large == NULL) {
        ngx_free(p);
        return NULL;
    }

    large->alloc = p;
    large->next = pool->large;
    pool->large = large;

    return p;
}",1,1,core\ngx_palloc.c,ngx_pmemalign,,false,252,274,ngx_pmemalign,,,12,"void* ngx_pmemalign (ngx_pool_t*,size_t,size_t)"
35119,METHOD,core\ngx_palloc.c:<global>,TYPE_DECL,"ngx_int_t
ngx_pfree(ngx_pool_t *pool, void *p)
{
    ngx_pool_large_t  *l;

    for (l = pool->large; l; l = l->next) {
        if (p == l->alloc) {
            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool->log, 0,
                           ""free: %p"", l->alloc);
            ngx_free(l->alloc);
            l->alloc = NULL;

            return NGX_OK;
        }
    }

    return NGX_DECLINED;
}",1,1,core\ngx_palloc.c,ngx_pfree,,false,277,294,ngx_pfree,,,13,"ngx_int_t ngx_pfree (ngx_pool_t*,void*)"
35170,METHOD,core\ngx_palloc.c:<global>,TYPE_DECL,"void *
ngx_pcalloc(ngx_pool_t *pool, size_t size)
{
    void *p;

    p = ngx_palloc(pool, size);
    if (p) {
        ngx_memzero(p, size);
    }

    return p;
}",1,1,core\ngx_palloc.c,ngx_pcalloc,,false,297,308,ngx_pcalloc,,,14,"void* ngx_pcalloc (ngx_pool_t*,size_t)"
35190,METHOD,core\ngx_palloc.c:<global>,TYPE_DECL,"ngx_pool_cleanup_t *
ngx_pool_cleanup_add(ngx_pool_t *p, size_t size)
{
    ngx_pool_cleanup_t  *c;

    c = ngx_palloc(p, sizeof(ngx_pool_cleanup_t));
    if (c == NULL) {
        return NULL;
    }

    if (size) {
        c->data = ngx_palloc(p, size);
        if (c->data == NULL) {
            return NULL;
        }

    } else {
        c->data = NULL;
    }

    c->handler = NULL;
    c->next = p->cleanup;

    p->cleanup = c;

    ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, p->log, 0, ""add cleanup: %p"", c);

    return c;
}",1,1,core\ngx_palloc.c,ngx_pool_cleanup_add,,false,311,339,ngx_pool_cleanup_add,,,15,"ngx_pool_cleanup_t ngx_pool_cleanup_add (ngx_pool_t*,size_t)"
35263,METHOD,core\ngx_palloc.c:<global>,TYPE_DECL,"void
ngx_pool_run_cleanup_file(ngx_pool_t *p, ngx_fd_t fd)
{
    ngx_pool_cleanup_t       *c;
    ngx_pool_cleanup_file_t  *cf;

    for (c = p->cleanup; c; c = c->next) {
        if (c->handler == ngx_pool_cleanup_file) {

            cf = c->data;

            if (cf->fd == fd) {
                c->handler(cf);
                c->handler = NULL;
                return;
            }
        }
    }
}",1,1,core\ngx_palloc.c,ngx_pool_run_cleanup_file,,false,342,360,ngx_pool_run_cleanup_file,,,16,"void ngx_pool_run_cleanup_file (ngx_pool_t*,ngx_fd_t)"
35315,METHOD,core\ngx_palloc.c:<global>,TYPE_DECL,"void
ngx_pool_cleanup_file(void *data)
{
    ngx_pool_cleanup_file_t  *c = data;

    ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, c->log, 0, ""file cleanup: fd:%d"",
                   c->fd);

    if (ngx_close_file(c->fd) == NGX_FILE_ERROR) {
        ngx_log_error(NGX_LOG_ALERT, c->log, ngx_errno,
                      ngx_close_file_n "" \""%s\"" failed"", c->name);
    }
}",1,1,core\ngx_palloc.c,ngx_pool_cleanup_file,,false,363,375,ngx_pool_cleanup_file,,,17,void ngx_pool_cleanup_file (void*)
35343,METHOD,core\ngx_palloc.c:<global>,TYPE_DECL,"void
ngx_pool_delete_file(void *data)
{
    ngx_pool_cleanup_file_t  *c = data;

    ngx_err_t  err;

    ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, c->log, 0, ""file cleanup: fd:%d %s"",
                   c->fd, c->name);

    if (ngx_delete_file(c->name) == NGX_FILE_ERROR) {
        err = ngx_errno;

        if (err != NGX_ENOENT) {
            ngx_log_error(NGX_LOG_CRIT, c->log, err,
                          ngx_delete_file_n "" \""%s\"" failed"", c->name);
        }
    }

    if (ngx_close_file(c->fd) == NGX_FILE_ERROR) {
        ngx_log_error(NGX_LOG_ALERT, c->log, ngx_errno,
                      ngx_close_file_n "" \""%s\"" failed"", c->name);
    }
}",1,1,core\ngx_palloc.c,ngx_pool_delete_file,,false,378,401,ngx_pool_delete_file,,,18,void ngx_pool_delete_file (void*)
35399,METHOD,core\ngx_palloc.h:<global>,TYPE_DECL,<global>,1,36,core\ngx_palloc.h,core\ngx_palloc.h:<global>,,false,1,92,<global>,,,1,
35401,METHOD,core\ngx_palloc.h:<global>,TYPE_DECL,typedef void (*ngx_pool_cleanup_pt)(void *data);,14,47,core\ngx_palloc.h,ngx_pool_cleanup_pt,,false,30,30,ngx_pool_cleanup_pt,,,1,void ngx_pool_cleanup_pt (void*)
35436,METHOD,core\ngx_palloc.h:<global>,TYPE_DECL,"ngx_pool_t *ngx_create_pool(size_t size, ngx_log_t *log);",12,56,core\ngx_palloc.h,ngx_create_pool,,false,75,75,ngx_create_pool,,,13,"ngx_pool_t* ngx_create_pool (size_t,ngx_log_t*)"
35442,METHOD,core\ngx_palloc.h:<global>,TYPE_DECL,void ngx_destroy_pool(ngx_pool_t *pool);,6,39,core\ngx_palloc.h,ngx_destroy_pool,,false,76,76,ngx_destroy_pool,,,14,void ngx_destroy_pool (ngx_pool_t*)
35447,METHOD,core\ngx_palloc.h:<global>,TYPE_DECL,void ngx_reset_pool(ngx_pool_t *pool);,6,37,core\ngx_palloc.h,ngx_reset_pool,,false,77,77,ngx_reset_pool,,,15,void ngx_reset_pool (ngx_pool_t*)
35452,METHOD,core\ngx_palloc.h:<global>,TYPE_DECL,"void *ngx_palloc(ngx_pool_t *pool, size_t size);",6,47,core\ngx_palloc.h,ngx_palloc,,false,79,79,ngx_palloc,,,16,"void* ngx_palloc (ngx_pool_t*,size_t)"
35458,METHOD,core\ngx_palloc.h:<global>,TYPE_DECL,"void *ngx_pnalloc(ngx_pool_t *pool, size_t size);",6,48,core\ngx_palloc.h,ngx_pnalloc,,false,80,80,ngx_pnalloc,,,17,"void* ngx_pnalloc (ngx_pool_t*,size_t)"
35464,METHOD,core\ngx_palloc.h:<global>,TYPE_DECL,"void *ngx_pcalloc(ngx_pool_t *pool, size_t size);",6,48,core\ngx_palloc.h,ngx_pcalloc,,false,81,81,ngx_pcalloc,,,18,"void* ngx_pcalloc (ngx_pool_t*,size_t)"
35470,METHOD,core\ngx_palloc.h:<global>,TYPE_DECL,"void *ngx_pmemalign(ngx_pool_t *pool, size_t size, size_t alignment);",6,68,core\ngx_palloc.h,ngx_pmemalign,,false,82,82,ngx_pmemalign,,,19,"void* ngx_pmemalign (ngx_pool_t*,size_t,size_t)"
35477,METHOD,core\ngx_palloc.h:<global>,TYPE_DECL,"ngx_int_t ngx_pfree(ngx_pool_t *pool, void *p);",11,46,core\ngx_palloc.h,ngx_pfree,,false,83,83,ngx_pfree,,,20,"ngx_int_t ngx_pfree (ngx_pool_t*,void*)"
35483,METHOD,core\ngx_palloc.h:<global>,TYPE_DECL,"ngx_pool_cleanup_t *ngx_pool_cleanup_add(ngx_pool_t *p, size_t size);",20,68,core\ngx_palloc.h,ngx_pool_cleanup_add,,false,86,86,ngx_pool_cleanup_add,,,21,"ngx_pool_cleanup_t* ngx_pool_cleanup_add (ngx_pool_t*,size_t)"
35489,METHOD,core\ngx_palloc.h:<global>,TYPE_DECL,"void ngx_pool_run_cleanup_file(ngx_pool_t *p, ngx_fd_t fd);",6,58,core\ngx_palloc.h,ngx_pool_run_cleanup_file,,false,87,87,ngx_pool_run_cleanup_file,,,22,"void ngx_pool_run_cleanup_file (ngx_pool_t*,ngx_fd_t)"
35495,METHOD,core\ngx_palloc.h:<global>,TYPE_DECL,void ngx_pool_cleanup_file(void *data);,6,38,core\ngx_palloc.h,ngx_pool_cleanup_file,,false,88,88,ngx_pool_cleanup_file,,,23,void ngx_pool_cleanup_file (void*)
35500,METHOD,core\ngx_palloc.h:<global>,TYPE_DECL,void ngx_pool_delete_file(void *data);,6,37,core\ngx_palloc.h,ngx_pool_delete_file,,false,89,89,ngx_pool_delete_file,,,24,void ngx_pool_delete_file (void*)
35512,METHOD,core\ngx_parse.c:<global>,TYPE_DECL,<global>,1,1,core\ngx_parse.c,core\ngx_parse.c:<global>,,false,1,283,<global>,,,1,
35514,METHOD,core\ngx_parse.c:<global>,TYPE_DECL,"ssize_t
ngx_parse_size(ngx_str_t *line)
{
    u_char   unit;
    size_t   len;
    ssize_t  size, scale, max;

    len = line->len;

    if (len == 0) {
        return NGX_ERROR;
    }

    unit = line->data[len - 1];

    switch (unit) {
    case 'K':
    case 'k':
        len--;
        max = NGX_MAX_SIZE_T_VALUE / 1024;
        scale = 1024;
        break;

    case 'M':
    case 'm':
        len--;
        max = NGX_MAX_SIZE_T_VALUE / (1024 * 1024);
        scale = 1024 * 1024;
        break;

    default:
        max = NGX_MAX_SIZE_T_VALUE;
        scale = 1;
    }

    size = ngx_atosz(line->data, len);
    if (size == NGX_ERROR || size > max) {
        return NGX_ERROR;
    }

    size *= scale;

    return size;
}",1,1,core\ngx_parse.c,ngx_parse_size,,false,12,55,ngx_parse_size,,,1,ssize_t ngx_parse_size (ngx_str_t*)
35612,METHOD,core\ngx_parse.c:<global>,TYPE_DECL,"off_t
ngx_parse_offset(ngx_str_t *line)
{
    u_char  unit;
    off_t   offset, scale, max;
    size_t  len;

    len = line->len;

    if (len == 0) {
        return NGX_ERROR;
    }

    unit = line->data[len - 1];

    switch (unit) {
    case 'K':
    case 'k':
        len--;
        max = NGX_MAX_OFF_T_VALUE / 1024;
        scale = 1024;
        break;

    case 'M':
    case 'm':
        len--;
        max = NGX_MAX_OFF_T_VALUE / (1024 * 1024);
        scale = 1024 * 1024;
        break;

    case 'G':
    case 'g':
        len--;
        max = NGX_MAX_OFF_T_VALUE / (1024 * 1024 * 1024);
        scale = 1024 * 1024 * 1024;
        break;

    default:
        max = NGX_MAX_OFF_T_VALUE;
        scale = 1;
    }

    offset = ngx_atoof(line->data, len);
    if (offset == NGX_ERROR || offset > max) {
        return NGX_ERROR;
    }

    offset *= scale;

    return offset;
}",1,1,core\ngx_parse.c,ngx_parse_offset,,false,58,108,ngx_parse_offset,,,2,off_t ngx_parse_offset (ngx_str_t*)
35733,METHOD,core\ngx_parse.c:<global>,TYPE_DECL,"ngx_int_t
ngx_parse_time(ngx_str_t *line, ngx_uint_t is_sec)
{
    u_char      *p, *last;
    ngx_int_t    value, total, scale;
    ngx_int_t    max, cutoff, cutlim;
    ngx_uint_t   valid;
    enum {
        st_start = 0,
        st_year,
        st_month,
        st_week,
        st_day,
        st_hour,
        st_min,
        st_sec,
        st_msec,
        st_last
    } step;

    valid = 0;
    value = 0;
    total = 0;
    cutoff = NGX_MAX_INT_T_VALUE / 10;
    cutlim = NGX_MAX_INT_T_VALUE % 10;
    step = is_sec ? st_start : st_month;

    p = line->data;
    last = p + line->len;

    while (p < last) {

        if (*p >= '0' && *p <= '9') {
            if (value >= cutoff && (value > cutoff || *p - '0' > cutlim)) {
                return NGX_ERROR;
            }

            value = value * 10 + (*p++ - '0');
            valid = 1;
            continue;
        }

        switch (*p++) {

        case 'y':
            if (step > st_start) {
                return NGX_ERRO...",1,1,core\ngx_parse.c,ngx_parse_time,,false,111,283,ngx_parse_time,,,3,"ngx_int_t ngx_parse_time (ngx_str_t*,ngx_uint_t)"
36179,METHOD,core\ngx_parse.h:<global>,TYPE_DECL,<global>,1,35,core\ngx_parse.h,core\ngx_parse.h:<global>,,false,1,21,<global>,,,1,
36181,METHOD,core\ngx_parse.h:<global>,TYPE_DECL,ssize_t ngx_parse_size(ngx_str_t *line);,9,39,core\ngx_parse.h,ngx_parse_size,,false,16,16,ngx_parse_size,,,1,ssize_t ngx_parse_size (ngx_str_t*)
36186,METHOD,core\ngx_parse.h:<global>,TYPE_DECL,off_t ngx_parse_offset(ngx_str_t *line);,7,39,core\ngx_parse.h,ngx_parse_offset,,false,17,17,ngx_parse_offset,,,2,off_t ngx_parse_offset (ngx_str_t*)
36191,METHOD,core\ngx_parse.h:<global>,TYPE_DECL,"ngx_int_t ngx_parse_time(ngx_str_t *line, ngx_uint_t is_sec);",11,60,core\ngx_parse.h,ngx_parse_time,,false,18,18,ngx_parse_time,,,3,"ngx_int_t ngx_parse_time (ngx_str_t*,ngx_uint_t)"
36204,METHOD,core\ngx_parse_time.c:<global>,TYPE_DECL,<global>,1,1,core\ngx_parse_time.c,core\ngx_parse_time.c:<global>,,false,1,277,<global>,,,1,
36222,METHOD,core\ngx_parse_time.c:<global>,TYPE_DECL,"time_t
ngx_parse_http_time(u_char *value, size_t len)
{
    u_char      *p, *end;
    ngx_int_t    month;
    ngx_uint_t   day, year, hour, min, sec;
    uint64_t     time;
    enum {
        no = 0,
        rfc822,   /* Tue, 10 Nov 2002 23:50:13   */
        rfc850,   /* Tuesday, 10-Dec-02 23:50:13 */
        isoc      /* Tue Dec 10 23:50:13 2002    */
    } fmt;

    fmt = 0;
    end = value + len;

#if (NGX_SUPPRESS_WARN)
    day = 32;
    year = 2038;
#endif

    for (p = value; p < end; p++) {
        if (*p == ',') {
            break;
        }

        if (*p == ' ') {
            fmt = isoc;
            break;
        }
    }

    for (p++; p < end; p++) {
        if (*p != ' ') {
            break;
        }
    }

    if (end - p < 18) {
        return NGX_ERROR;
    }

    if (fmt != isoc) {
        if (*p < '0' || *p > '9' || *(p + 1) < '0' || *(p + 1) > '9') {
            return NGX_ERROR;
        }

        day = (*p - '0') * 10 + (*(p + 1) - '0');
        p += 2;

  ...",1,1,core\ngx_parse_time.c,ngx_parse_http_time,,false,14,277,ngx_parse_http_time,,,3,"time_t ngx_parse_http_time (u_char*,size_t)"
37122,METHOD,core\ngx_parse_time.h:<global>,TYPE_DECL,<global>,1,40,core\ngx_parse_time.h,core\ngx_parse_time.h:<global>,,false,1,22,<global>,,,1,
37124,METHOD,core\ngx_parse_time.h:<global>,TYPE_DECL,"time_t ngx_parse_http_time(u_char *value, size_t len);",8,53,core\ngx_parse_time.h,ngx_parse_http_time,,false,16,16,ngx_parse_http_time,,,1,"time_t ngx_parse_http_time (u_char*,size_t)"
37137,METHOD,core\ngx_proxy_protocol.c:<global>,TYPE_DECL,<global>,1,10,core\ngx_proxy_protocol.c,core\ngx_proxy_protocol.c:<global>,,false,1,422,<global>,,,1,
37144,METHOD,<empty>,<empty>,<empty>,1,,core\ngx_proxy_protocol.c,ngx_proxy_protocol_header_t:<clinit>,,false,19,,<clinit>,,,5,
37158,METHOD,<empty>,<empty>,<empty>,1,,core\ngx_proxy_protocol.c,ngx_proxy_protocol_inet_addrs_t:<clinit>,,false,27,,<clinit>,,,5,
37176,METHOD,<empty>,<empty>,<empty>,1,,core\ngx_proxy_protocol.c,ngx_proxy_protocol_inet6_addrs_t:<clinit>,,false,35,,<clinit>,,,5,
37189,METHOD,core\ngx_proxy_protocol.c:<global>,TYPE_DECL,"static u_char *ngx_proxy_protocol_read_addr(ngx_connection_t *c, u_char *p,
    u_char *last, ngx_str_t *addr);",15,34,core\ngx_proxy_protocol.c,ngx_proxy_protocol_read_addr,,false,43,44,ngx_proxy_protocol_read_addr,,,7,"u_char* ngx_proxy_protocol_read_addr (ngx_connection_t*,u_char*,u_char*,ngx_str_t*)"
37197,METHOD,core\ngx_proxy_protocol.c:<global>,TYPE_DECL,"static u_char *ngx_proxy_protocol_read_port(u_char *p, u_char *last,
    in_port_t *port, u_char sep);",15,32,core\ngx_proxy_protocol.c,ngx_proxy_protocol_read_port,,false,45,46,ngx_proxy_protocol_read_port,,,8,"u_char* ngx_proxy_protocol_read_port (u_char*,u_char*,in_port_t*,u_char)"
37205,METHOD,core\ngx_proxy_protocol.c:<global>,TYPE_DECL,"static u_char *ngx_proxy_protocol_v2_read(ngx_connection_t *c, u_char *buf,
    u_char *last);",15,17,core\ngx_proxy_protocol.c,ngx_proxy_protocol_v2_read,,false,47,48,ngx_proxy_protocol_v2_read,,,9,"u_char* ngx_proxy_protocol_v2_read (ngx_connection_t*,u_char*,u_char*)"
37212,METHOD,core\ngx_proxy_protocol.c:<global>,TYPE_DECL,"u_char *
ngx_proxy_protocol_read(ngx_connection_t *c, u_char *buf, u_char *last)
{
    size_t                 len;
    u_char                *p;
    ngx_proxy_protocol_t  *pp;

    static const u_char signature[] = ""\r\n\r\n\0\r\nQUIT\n"";

    p = buf;
    len = last - buf;

    if (len >= sizeof(ngx_proxy_protocol_header_t)
        && memcmp(p, signature, sizeof(signature) - 1) == 0)
    {
        return ngx_proxy_protocol_v2_read(c, buf, last);
    }

    if (len < 8 || ngx_strncmp(p, ""PROXY "", 6) != 0) {
        goto invalid;
    }

    p += 6;
    len -= 6;

    if (len >= 7 && ngx_strncmp(p, ""UNKNOWN"", 7) == 0) {
        ngx_log_debug0(NGX_LOG_DEBUG_CORE, c->log, 0,
                       ""PROXY protocol unknown protocol"");
        p += 7;
        goto skip;
    }

    if (len < 5 || ngx_strncmp(p, ""TCP"", 3) != 0
        || (p[3] != '4' && p[3] != '6') || p[4] != ' ')
    {
        goto invalid;
    }

    p += 5;

    pp = ngx_pcalloc(c->pool, sizeof(ngx_proxy_protocol_t));
  ...",1,1,core\ngx_proxy_protocol.c,ngx_proxy_protocol_read,,false,51,146,ngx_proxy_protocol_read,,,10,"u_char ngx_proxy_protocol_read (ngx_connection_t*,u_char*,u_char*)"
37495,METHOD,core\ngx_proxy_protocol.c:<global>,TYPE_DECL,"static u_char *
ngx_proxy_protocol_read_addr(ngx_connection_t *c, u_char *p, u_char *last,
    ngx_str_t *addr)
{
    size_t  len;
    u_char  ch, *pos;

    pos = p;

    for ( ;; ) {
        if (p == last) {
            return NULL;
        }

        ch = *p++;

        if (ch == ' ') {
            break;
        }

        if (ch != ':' && ch != '.'
            && (ch < 'a' || ch > 'f')
            && (ch < 'A' || ch > 'F')
            && (ch < '0' || ch > '9'))
        {
            return NULL;
        }
    }

    len = p - pos - 1;

    addr->data = ngx_pnalloc(c->pool, len);
    if (addr->data == NULL) {
        return NULL;
    }

    ngx_memcpy(addr->data, pos, len);
    addr->len = len;

    return p;
}",1,1,core\ngx_proxy_protocol.c,ngx_proxy_protocol_read_addr,,false,149,189,ngx_proxy_protocol_read_addr,,,11,"u_char ngx_proxy_protocol_read_addr (ngx_connection_t*,u_char*,u_char*,ngx_str_t*)"
37603,METHOD,core\ngx_proxy_protocol.c:<global>,TYPE_DECL,"static u_char *
ngx_proxy_protocol_read_port(u_char *p, u_char *last, in_port_t *port,
    u_char sep)
{
    size_t      len;
    u_char     *pos;
    ngx_int_t   n;

    pos = p;

    for ( ;; ) {
        if (p == last) {
            return NULL;
        }

        if (*p++ == sep) {
            break;
        }
    }

    len = p - pos - 1;

    n = ngx_atoi(pos, len);
    if (n < 0 || n > 65535) {
        return NULL;
    }

    *port = (in_port_t) n;

    return p;
}",1,1,core\ngx_proxy_protocol.c,ngx_proxy_protocol_read_port,,false,192,222,ngx_proxy_protocol_read_port,,,12,"u_char ngx_proxy_protocol_read_port (u_char*,u_char*,in_port_t*,u_char)"
37666,METHOD,core\ngx_proxy_protocol.c:<global>,TYPE_DECL,"u_char *
ngx_proxy_protocol_write(ngx_connection_t *c, u_char *buf, u_char *last)
{
    ngx_uint_t  port, lport;

    if (last - buf < NGX_PROXY_PROTOCOL_MAX_HEADER) {
        return NULL;
    }

    if (ngx_connection_local_sockaddr(c, NULL, 0) != NGX_OK) {
        return NULL;
    }

    switch (c->sockaddr->sa_family) {

    case AF_INET:
        buf = ngx_cpymem(buf, ""PROXY TCP4 "", sizeof(""PROXY TCP4 "") - 1);
        break;

#if (NGX_HAVE_INET6)
    case AF_INET6:
        buf = ngx_cpymem(buf, ""PROXY TCP6 "", sizeof(""PROXY TCP6 "") - 1);
        break;
#endif

    default:
        return ngx_cpymem(buf, ""PROXY UNKNOWN"" CRLF,
                          sizeof(""PROXY UNKNOWN"" CRLF) - 1);
    }

    buf += ngx_sock_ntop(c->sockaddr, c->socklen, buf, last - buf, 0);

    *buf++ = ' ';

    buf += ngx_sock_ntop(c->local_sockaddr, c->local_socklen, buf, last - buf,
                         0);

    port = ngx_inet_get_port(c->sockaddr);
    lport = ngx_inet_get_port(c->local_sockaddr);

...",1,1,core\ngx_proxy_protocol.c,ngx_proxy_protocol_write,,false,225,266,ngx_proxy_protocol_write,,,13,"u_char ngx_proxy_protocol_write (ngx_connection_t*,u_char*,u_char*)"
37761,METHOD,core\ngx_proxy_protocol.c:<global>,TYPE_DECL,"static u_char *
ngx_proxy_protocol_v2_read(ngx_connection_t *c, u_char *buf, u_char *last)
{
    u_char                             *end;
    size_t                              len;
    socklen_t                           socklen;
    ngx_uint_t                          version, command, family, transport;
    ngx_sockaddr_t                      src_sockaddr, dst_sockaddr;
    ngx_proxy_protocol_t               *pp;
    ngx_proxy_protocol_header_t        *header;
    ngx_proxy_protocol_inet_addrs_t    *in;
#if (NGX_HAVE_INET6)
    ngx_proxy_protocol_inet6_addrs_t   *in6;
#endif

    header = (ngx_proxy_protocol_header_t *) buf;

    buf += sizeof(ngx_proxy_protocol_header_t);

    version = header->version_command >> 4;

    if (version != 2) {
        ngx_log_error(NGX_LOG_ERR, c->log, 0,
                      ""unknown PROXY protocol version: %ui"", version);
        return NULL;
    }

    len = ngx_proxy_protocol_parse_uint16(header->len);

    if ((size_t) (last - buf) < len) {
...",1,10,core\ngx_proxy_protocol.c,ngx_proxy_protocol_v2_read,,false,269,422,ngx_proxy_protocol_v2_read,,,14,"u_char ngx_proxy_protocol_v2_read (ngx_connection_t*,u_char*,u_char*)"
38188,METHOD,core\ngx_proxy_protocol.h:<global>,TYPE_DECL,<global>,1,44,core\ngx_proxy_protocol.h,core\ngx_proxy_protocol.h:<global>,,false,1,33,<global>,,,1,
38195,METHOD,core\ngx_proxy_protocol.h:<global>,TYPE_DECL,"u_char *ngx_proxy_protocol_read(ngx_connection_t *c, u_char *buf,
    u_char *last);",8,17,core\ngx_proxy_protocol.h,ngx_proxy_protocol_read,,false,27,28,ngx_proxy_protocol_read,,,2,"u_char* ngx_proxy_protocol_read (ngx_connection_t*,u_char*,u_char*)"
38202,METHOD,core\ngx_proxy_protocol.h:<global>,TYPE_DECL,"u_char *ngx_proxy_protocol_write(ngx_connection_t *c, u_char *buf,
    u_char *last);",8,17,core\ngx_proxy_protocol.h,ngx_proxy_protocol_write,,false,29,30,ngx_proxy_protocol_write,,,3,"u_char* ngx_proxy_protocol_write (ngx_connection_t*,u_char*,u_char*)"
38216,METHOD,core\ngx_queue.c:<global>,TYPE_DECL,<global>,1,1,core\ngx_queue.c,core\ngx_queue.c:<global>,,false,1,80,<global>,,,1,
38218,METHOD,core\ngx_queue.c:<global>,TYPE_DECL,"ngx_queue_t *
ngx_queue_middle(ngx_queue_t *queue)
{
    ngx_queue_t  *middle, *next;

    middle = ngx_queue_head(queue);

    if (middle == ngx_queue_last(queue)) {
        return middle;
    }

    next = ngx_queue_head(queue);

    for ( ;; ) {
        middle = ngx_queue_next(middle);

        next = ngx_queue_next(next);

        if (next == ngx_queue_last(queue)) {
            return middle;
        }

        next = ngx_queue_next(next);

        if (next == ngx_queue_last(queue)) {
            return middle;
        }
    }
}",1,1,core\ngx_queue.c,ngx_queue_middle,,false,17,45,ngx_queue_middle,,,1,ngx_queue_t ngx_queue_middle (ngx_queue_t*)
38272,METHOD,core\ngx_queue.c:<global>,TYPE_DECL,"void
ngx_queue_sort(ngx_queue_t *queue,
    ngx_int_t (*cmp)(const ngx_queue_t *, const ngx_queue_t *))
{
    ngx_queue_t  *q, *prev, *next;

    q = ngx_queue_head(queue);

    if (q == ngx_queue_last(queue)) {
        return;
    }

    for (q = ngx_queue_next(q); q != ngx_queue_sentinel(queue); q = next) {

        prev = ngx_queue_prev(q);
        next = ngx_queue_next(q);

        ngx_queue_remove(q);

        do {
            if (cmp(prev, q) <= 0) {
                break;
            }

            prev = ngx_queue_prev(prev);

        } while (prev != ngx_queue_sentinel(queue));

        ngx_queue_insert_after(prev, q);
    }
}",1,1,core\ngx_queue.c,ngx_queue_sort,,false,50,80,ngx_queue_sort,,,2,"void ngx_queue_sort (ngx_queue_t*,ngx_int_t)"
38344,METHOD,core\ngx_queue.h:<global>,TYPE_DECL,<global>,1,35,core\ngx_queue.h,core\ngx_queue.h:<global>,,false,1,112,<global>,,,1,
38351,METHOD,core\ngx_queue.h:<global>,TYPE_DECL,ngx_queue_t *ngx_queue_middle(ngx_queue_t *queue);,13,49,core\ngx_queue.h,ngx_queue_middle,,false,107,107,ngx_queue_middle,,,4,ngx_queue_t* ngx_queue_middle (ngx_queue_t*)
38356,METHOD,core\ngx_queue.h:<global>,TYPE_DECL,"void ngx_queue_sort(ngx_queue_t *queue,
    ngx_int_t (*cmp)(const ngx_queue_t *, const ngx_queue_t *));",6,63,core\ngx_queue.h,ngx_queue_sort,,false,108,109,ngx_queue_sort,,,5,"void ngx_queue_sort (ngx_queue_t*,ngx_int_t)"
38369,METHOD,core\ngx_radix_tree.c:<global>,TYPE_DECL,<global>,1,1,core\ngx_radix_tree.c,core\ngx_radix_tree.c:<global>,,false,1,488,<global>,,,1,
38371,METHOD,core\ngx_radix_tree.c:<global>,TYPE_DECL,static ngx_radix_node_t *ngx_radix_alloc(ngx_radix_tree_t *tree);,25,64,core\ngx_radix_tree.c,ngx_radix_alloc,,false,12,12,ngx_radix_alloc,,,1,ngx_radix_node_t* ngx_radix_alloc (ngx_radix_tree_t*)
38376,METHOD,core\ngx_radix_tree.c:<global>,TYPE_DECL,"ngx_radix_tree_t *
ngx_radix_tree_create(ngx_pool_t *pool, ngx_int_t preallocate)
{
    uint32_t           key, mask, inc;
    ngx_radix_tree_t  *tree;

    tree = ngx_palloc(pool, sizeof(ngx_radix_tree_t));
    if (tree == NULL) {
        return NULL;
    }

    tree->pool = pool;
    tree->free = NULL;
    tree->start = NULL;
    tree->size = 0;

    tree->root = ngx_radix_alloc(tree);
    if (tree->root == NULL) {
        return NULL;
    }

    tree->root->right = NULL;
    tree->root->left = NULL;
    tree->root->parent = NULL;
    tree->root->value = NGX_RADIX_NO_VALUE;

    if (preallocate == 0) {
        return tree;
    }

    /*
     * Preallocation of first nodes : 0, 1, 00, 01, 10, 11, 000, 001, etc.
     * increases TLB hits even if for first lookup iterations.
     * On 32-bit platforms the 7 preallocated bits takes continuous 4K,
     * 8 - 8K, 9 - 16K, etc.  On 64-bit platforms the 6 preallocated bits
     * takes continuous 4K, 7 - 8K, 8 - 16K, etc.  There is no sen...",1,1,core\ngx_radix_tree.c,ngx_radix_tree_create,,false,15,105,ngx_radix_tree_create,,,2,"ngx_radix_tree_t ngx_radix_tree_create (ngx_pool_t*,ngx_int_t)"
38538,METHOD,core\ngx_radix_tree.c:<global>,TYPE_DECL,"ngx_int_t
ngx_radix32tree_insert(ngx_radix_tree_t *tree, uint32_t key, uint32_t mask,
    uintptr_t value)
{
    uint32_t           bit;
    ngx_radix_node_t  *node, *next;

    bit = 0x80000000;

    node = tree->root;
    next = tree->root;

    while (bit & mask) {
        if (key & bit) {
            next = node->right;

        } else {
            next = node->left;
        }

        if (next == NULL) {
            break;
        }

        bit >>= 1;
        node = next;
    }

    if (next) {
        if (node->value != NGX_RADIX_NO_VALUE) {
            return NGX_BUSY;
        }

        node->value = value;
        return NGX_OK;
    }

    while (bit & mask) {
        next = ngx_radix_alloc(tree);
        if (next == NULL) {
            return NGX_ERROR;
        }

        next->right = NULL;
        next->left = NULL;
        next->parent = node;
        next->value = NGX_RADIX_NO_VALUE;

        if (key & bit) {
            node->right = next;

        } else {
        ...",1,1,core\ngx_radix_tree.c,ngx_radix32tree_insert,,false,108,170,ngx_radix32tree_insert,,,3,"ngx_int_t ngx_radix32tree_insert (ngx_radix_tree_t*,uint32_t,uint32_t,uintptr_t)"
38681,METHOD,core\ngx_radix_tree.c:<global>,TYPE_DECL,"ngx_int_t
ngx_radix32tree_delete(ngx_radix_tree_t *tree, uint32_t key, uint32_t mask)
{
    uint32_t           bit;
    ngx_radix_node_t  *node;

    bit = 0x80000000;
    node = tree->root;

    while (node && (bit & mask)) {
        if (key & bit) {
            node = node->right;

        } else {
            node = node->left;
        }

        bit >>= 1;
    }

    if (node == NULL) {
        return NGX_ERROR;
    }

    if (node->right || node->left) {
        if (node->value != NGX_RADIX_NO_VALUE) {
            node->value = NGX_RADIX_NO_VALUE;
            return NGX_OK;
        }

        return NGX_ERROR;
    }

    for ( ;; ) {
        if (node->parent->right == node) {
            node->parent->right = NULL;

        } else {
            node->parent->left = NULL;
        }

        node->right = tree->free;
        tree->free = node;

        node = node->parent;

        if (node->right || node->left) {
            break;
        }

        if (node->value != NGX_RADIX...",1,1,core\ngx_radix_tree.c,ngx_radix32tree_delete,,false,173,233,ngx_radix32tree_delete,,,4,"ngx_int_t ngx_radix32tree_delete (ngx_radix_tree_t*,uint32_t,uint32_t)"
38830,METHOD,core\ngx_radix_tree.c:<global>,TYPE_DECL,"uintptr_t
ngx_radix32tree_find(ngx_radix_tree_t *tree, uint32_t key)
{
    uint32_t           bit;
    uintptr_t          value;
    ngx_radix_node_t  *node;

    bit = 0x80000000;
    value = NGX_RADIX_NO_VALUE;
    node = tree->root;

    while (node) {
        if (node->value != NGX_RADIX_NO_VALUE) {
            value = node->value;
        }

        if (key & bit) {
            node = node->right;

        } else {
            node = node->left;
        }

        bit >>= 1;
    }

    return value;
}",1,1,core\ngx_radix_tree.c,ngx_radix32tree_find,,false,236,263,ngx_radix32tree_find,,,5,"uintptr_t ngx_radix32tree_find (ngx_radix_tree_t*,uint32_t)"
38887,METHOD,core\ngx_radix_tree.c:<global>,TYPE_DECL,"static ngx_radix_node_t *
ngx_radix_alloc(ngx_radix_tree_t *tree)
{
    ngx_radix_node_t  *p;

    if (tree->free) {
        p = tree->free;
        tree->free = tree->free->right;
        return p;
    }

    if (tree->size < sizeof(ngx_radix_node_t)) {
        tree->start = ngx_pmemalign(tree->pool, ngx_pagesize, ngx_pagesize);
        if (tree->start == NULL) {
            return NULL;
        }

        tree->size = ngx_pagesize;
    }

    p = (ngx_radix_node_t *) tree->start;
    tree->start += sizeof(ngx_radix_node_t);
    tree->size -= sizeof(ngx_radix_node_t);

    return p;
}",1,1,core\ngx_radix_tree.c,ngx_radix_alloc,,false,463,488,ngx_radix_alloc,,,6,ngx_radix_node_t ngx_radix_alloc (ngx_radix_tree_t*)
38974,METHOD,core\ngx_radix_tree.h:<global>,TYPE_DECL,<global>,1,40,core\ngx_radix_tree.h,core\ngx_radix_tree.h:<global>,,false,1,55,<global>,,,1,
38990,METHOD,core\ngx_radix_tree.h:<global>,TYPE_DECL,"ngx_radix_tree_t *ngx_radix_tree_create(ngx_pool_t *pool,
    ngx_int_t preallocate);",18,26,core\ngx_radix_tree.h,ngx_radix_tree_create,,false,37,38,ngx_radix_tree_create,,,6,"ngx_radix_tree_t* ngx_radix_tree_create (ngx_pool_t*,ngx_int_t)"
38996,METHOD,core\ngx_radix_tree.h:<global>,TYPE_DECL,"ngx_int_t ngx_radix32tree_insert(ngx_radix_tree_t *tree,
    uint32_t key, uint32_t mask, uintptr_t value);",11,49,core\ngx_radix_tree.h,ngx_radix32tree_insert,,false,40,41,ngx_radix32tree_insert,,,7,"ngx_int_t ngx_radix32tree_insert (ngx_radix_tree_t*,uint32_t,uint32_t,uintptr_t)"
39004,METHOD,core\ngx_radix_tree.h:<global>,TYPE_DECL,"ngx_int_t ngx_radix32tree_delete(ngx_radix_tree_t *tree,
    uint32_t key, uint32_t mask);",11,32,core\ngx_radix_tree.h,ngx_radix32tree_delete,,false,42,43,ngx_radix32tree_delete,,,8,"ngx_int_t ngx_radix32tree_delete (ngx_radix_tree_t*,uint32_t,uint32_t)"
39011,METHOD,core\ngx_radix_tree.h:<global>,TYPE_DECL,"uintptr_t ngx_radix32tree_find(ngx_radix_tree_t *tree, uint32_t key);",11,68,core\ngx_radix_tree.h,ngx_radix32tree_find,,false,44,44,ngx_radix32tree_find,,,9,"uintptr_t ngx_radix32tree_find (ngx_radix_tree_t*,uint32_t)"
39024,METHOD,core\ngx_rbtree.c:<global>,TYPE_DECL,<global>,1,1,core\ngx_rbtree.c,core\ngx_rbtree.c:<global>,,false,1,404,<global>,,,1,
39028,METHOD,core\ngx_rbtree.c:<global>,TYPE_DECL,"void
ngx_rbtree_insert(ngx_rbtree_t *tree, ngx_rbtree_node_t *node)
{
    ngx_rbtree_node_t  **root, *temp, *sentinel;

    /* a binary tree insert */

    root = &tree->root;
    sentinel = tree->sentinel;

    if (*root == sentinel) {
        node->parent = NULL;
        node->left = sentinel;
        node->right = sentinel;
        ngx_rbt_black(node);
        *root = node;

        return;
    }

    tree->insert(*root, node, sentinel);

    /* re-balance tree */

    while (node != *root && ngx_rbt_is_red(node->parent)) {

        if (node->parent == node->parent->parent->left) {
            temp = node->parent->parent->right;

            if (ngx_rbt_is_red(temp)) {
                ngx_rbt_black(node->parent);
                ngx_rbt_black(temp);
                ngx_rbt_red(node->parent->parent);
                node = node->parent->parent;

            } else {
                if (node == node->parent->right) {
                    node = node->parent;
                    ngx_...",1,1,core\ngx_rbtree.c,ngx_rbtree_insert,,false,24,93,ngx_rbtree_insert,,,3,"void ngx_rbtree_insert (ngx_rbtree_t*,ngx_rbtree_node_t*)"
39253,METHOD,core\ngx_rbtree.c:<global>,TYPE_DECL,"void
ngx_rbtree_insert_value(ngx_rbtree_node_t *temp, ngx_rbtree_node_t *node,
    ngx_rbtree_node_t *sentinel)
{
    ngx_rbtree_node_t  **p;

    for ( ;; ) {

        p = (node->key < temp->key) ? &temp->left : &temp->right;

        if (*p == sentinel) {
            break;
        }

        temp = *p;
    }

    *p = node;
    node->parent = temp;
    node->left = sentinel;
    node->right = sentinel;
    ngx_rbt_red(node);
}",1,1,core\ngx_rbtree.c,ngx_rbtree_insert_value,,false,96,118,ngx_rbtree_insert_value,,,4,"void ngx_rbtree_insert_value (ngx_rbtree_node_t*,ngx_rbtree_node_t*,ngx_rbtree_node_t*)"
39314,METHOD,core\ngx_rbtree.c:<global>,TYPE_DECL,"void
ngx_rbtree_insert_timer_value(ngx_rbtree_node_t *temp, ngx_rbtree_node_t *node,
    ngx_rbtree_node_t *sentinel)
{
    ngx_rbtree_node_t  **p;

    for ( ;; ) {

        /*
         * Timer values
         * 1) are spread in small range, usually several minutes,
         * 2) and overflow each 49 days, if milliseconds are stored in 32 bits.
         * The comparison takes into account that overflow.
         */

        /*  node->key < temp->key */

        p = ((ngx_rbtree_key_int_t) (node->key - temp->key) < 0)
            ? &temp->left : &temp->right;

        if (*p == sentinel) {
            break;
        }

        temp = *p;
    }

    *p = node;
    node->parent = temp;
    node->left = sentinel;
    node->right = sentinel;
    ngx_rbt_red(node);
}",1,1,core\ngx_rbtree.c,ngx_rbtree_insert_timer_value,,false,121,153,ngx_rbtree_insert_timer_value,,,5,"void ngx_rbtree_insert_timer_value (ngx_rbtree_node_t*,ngx_rbtree_node_t*,ngx_rbtree_node_t*)"
39378,METHOD,core\ngx_rbtree.c:<global>,TYPE_DECL,"void
ngx_rbtree_delete(ngx_rbtree_t *tree, ngx_rbtree_node_t *node)
{
    ngx_uint_t           red;
    ngx_rbtree_node_t  **root, *sentinel, *subst, *temp, *w;

    /* a binary tree delete */

    root = &tree->root;
    sentinel = tree->sentinel;

    if (node->left == sentinel) {
        temp = node->right;
        subst = node;

    } else if (node->right == sentinel) {
        temp = node->left;
        subst = node;

    } else {
        subst = ngx_rbtree_min(node->right, sentinel);
        temp = subst->right;
    }

    if (subst == *root) {
        *root = temp;
        ngx_rbt_black(temp);

        /* DEBUG stuff */
        node->left = NULL;
        node->right = NULL;
        node->parent = NULL;
        node->key = 0;

        return;
    }

    red = ngx_rbt_is_red(subst);

    if (subst == subst->parent->left) {
        subst->parent->left = temp;

    } else {
        subst->parent->right = temp;
    }

    if (subst == node) {

        temp->parent = subst->parent;...",1,1,core\ngx_rbtree.c,ngx_rbtree_delete,,false,156,315,ngx_rbtree_delete,,,6,"void ngx_rbtree_delete (ngx_rbtree_t*,ngx_rbtree_node_t*)"
39873,METHOD,core\ngx_rbtree.c:<global>,TYPE_DECL,"ngx_rbtree_node_t *
ngx_rbtree_next(ngx_rbtree_t *tree, ngx_rbtree_node_t *node)
{
    ngx_rbtree_node_t  *root, *sentinel, *parent;

    sentinel = tree->sentinel;

    if (node->right != sentinel) {
        return ngx_rbtree_min(node->right, sentinel);
    }

    root = tree->root;

    for ( ;; ) {
        parent = node->parent;

        if (node == root) {
            return NULL;
        }

        if (node == parent->left) {
            return parent;
        }

        node = parent;
    }
}",1,1,core\ngx_rbtree.c,ngx_rbtree_next,,false,378,404,ngx_rbtree_next,,,9,"ngx_rbtree_node_t ngx_rbtree_next (ngx_rbtree_t*,ngx_rbtree_node_t*)"
39939,METHOD,core\ngx_rbtree.h:<global>,TYPE_DECL,<global>,1,36,core\ngx_rbtree.h,core\ngx_rbtree.h:<global>,,false,1,84,<global>,,,1,
39954,METHOD,core\ngx_rbtree.h:<global>,TYPE_DECL,"typedef void (*ngx_rbtree_insert_pt) (ngx_rbtree_node_t *root,
    ngx_rbtree_node_t *node, ngx_rbtree_node_t *sentinel);",14,57,core\ngx_rbtree.h,ngx_rbtree_insert_pt,,false,34,35,ngx_rbtree_insert_pt,,,8,"void ngx_rbtree_insert_pt (ngx_rbtree_node_t*,ngx_rbtree_node_t*,ngx_rbtree_node_t*)"
39965,METHOD,core\ngx_rbtree.h:<global>,TYPE_DECL,"void ngx_rbtree_insert(ngx_rbtree_t *tree, ngx_rbtree_node_t *node);",6,67,core\ngx_rbtree.h,ngx_rbtree_insert,,false,51,51,ngx_rbtree_insert,,,10,"void ngx_rbtree_insert (ngx_rbtree_t*,ngx_rbtree_node_t*)"
39971,METHOD,core\ngx_rbtree.h:<global>,TYPE_DECL,"void ngx_rbtree_delete(ngx_rbtree_t *tree, ngx_rbtree_node_t *node);",6,67,core\ngx_rbtree.h,ngx_rbtree_delete,,false,52,52,ngx_rbtree_delete,,,11,"void ngx_rbtree_delete (ngx_rbtree_t*,ngx_rbtree_node_t*)"
39977,METHOD,core\ngx_rbtree.h:<global>,TYPE_DECL,"void ngx_rbtree_insert_value(ngx_rbtree_node_t *root, ngx_rbtree_node_t *node,
    ngx_rbtree_node_t *sentinel);",6,32,core\ngx_rbtree.h,ngx_rbtree_insert_value,,false,53,54,ngx_rbtree_insert_value,,,12,"void ngx_rbtree_insert_value (ngx_rbtree_node_t*,ngx_rbtree_node_t*,ngx_rbtree_node_t*)"
39984,METHOD,core\ngx_rbtree.h:<global>,TYPE_DECL,"void ngx_rbtree_insert_timer_value(ngx_rbtree_node_t *root,
    ngx_rbtree_node_t *node, ngx_rbtree_node_t *sentinel);",6,57,core\ngx_rbtree.h,ngx_rbtree_insert_timer_value,,false,55,56,ngx_rbtree_insert_timer_value,,,13,"void ngx_rbtree_insert_timer_value (ngx_rbtree_node_t*,ngx_rbtree_node_t*,ngx_rbtree_node_t*)"
39991,METHOD,core\ngx_rbtree.h:<global>,TYPE_DECL,"ngx_rbtree_node_t *ngx_rbtree_next(ngx_rbtree_t *tree,
    ngx_rbtree_node_t *node);",19,28,core\ngx_rbtree.h,ngx_rbtree_next,,false,57,58,ngx_rbtree_next,,,14,"ngx_rbtree_node_t* ngx_rbtree_next (ngx_rbtree_t*,ngx_rbtree_node_t*)"
40005,METHOD,core\ngx_regex.c:<global>,TYPE_DECL,<global>,1,1,core\ngx_regex.c,core\ngx_regex.c:<global>,,false,1,435,<global>,,,1,
40012,METHOD,core\ngx_regex.c:<global>,TYPE_DECL,static ngx_int_t ngx_regex_module_init(ngx_cycle_t *cycle);,18,58,core\ngx_regex.c,ngx_regex_module_init,,false,23,23,ngx_regex_module_init,,,5,ngx_int_t ngx_regex_module_init (ngx_cycle_t*)
40017,METHOD,core\ngx_regex.c:<global>,TYPE_DECL,static void *ngx_regex_create_conf(ngx_cycle_t *cycle);,13,54,core\ngx_regex.c,ngx_regex_create_conf,,false,25,25,ngx_regex_create_conf,,,6,void* ngx_regex_create_conf (ngx_cycle_t*)
40022,METHOD,core\ngx_regex.c:<global>,TYPE_DECL,"static char *ngx_regex_init_conf(ngx_cycle_t *cycle, void *conf);",13,64,core\ngx_regex.c,ngx_regex_init_conf,,false,26,26,ngx_regex_init_conf,,,7,"char* ngx_regex_init_conf (ngx_cycle_t*,void*)"
40028,METHOD,core\ngx_regex.c:<global>,TYPE_DECL,"static char *ngx_regex_pcre_jit(ngx_conf_t *cf, void *post, void *data);",13,71,core\ngx_regex.c,ngx_regex_pcre_jit,,false,28,28,ngx_regex_pcre_jit,,,8,"char* ngx_regex_pcre_jit (ngx_conf_t*,void*,void*)"
40087,METHOD,core\ngx_regex.c:<global>,TYPE_DECL,"void
ngx_regex_init(void)
{
    pcre_malloc = ngx_regex_malloc;
    pcre_free = ngx_regex_free;
}",1,1,core\ngx_regex.c,ngx_regex_init,,false,72,77,ngx_regex_init,,,19,void ngx_regex_init (void)
40100,METHOD,core\ngx_regex.c:<global>,TYPE_DECL,"ngx_int_t
ngx_regex_compile(ngx_regex_compile_t *rc)
{
    int               n, erroff;
    char             *p;
    pcre             *re;
    const char       *errstr;
    ngx_regex_elt_t  *elt;

    ngx_regex_malloc_init(rc->pool);

    re = pcre_compile((const char *) rc->pattern.data, (int) rc->options,
                      &errstr, &erroff, NULL);

    /* ensure that there is no current pool */
    ngx_regex_malloc_done();

    if (re == NULL) {
        if ((size_t) erroff == rc->pattern.len) {
           rc->err.len = ngx_snprintf(rc->err.data, rc->err.len,
                              ""pcre_compile() failed: %s in \""%V\"""",
                               errstr, &rc->pattern)
                      - rc->err.data;

        } else {
           rc->err.len = ngx_snprintf(rc->err.data, rc->err.len,
                              ""pcre_compile() failed: %s in \""%V\"" at \""%s\"""",
                               errstr, &rc->pattern, rc->pattern.data + erroff)
                      - ...",1,1,core\ngx_regex.c,ngx_regex_compile,,false,94,194,ngx_regex_compile,,,22,ngx_int_t ngx_regex_compile (ngx_regex_compile_t*)
40436,METHOD,core\ngx_regex.c:<global>,TYPE_DECL,"ngx_int_t
ngx_regex_exec_array(ngx_array_t *a, ngx_str_t *s, ngx_log_t *log)
{
    ngx_int_t         n;
    ngx_uint_t        i;
    ngx_regex_elt_t  *re;

    re = a->elts;

    for (i = 0; i < a->nelts; i++) {

        n = ngx_regex_exec(re[i].regex, s, NULL, 0);

        if (n == NGX_REGEX_NO_MATCHED) {
            continue;
        }

        if (n < 0) {
            ngx_log_error(NGX_LOG_ALERT, log, 0,
                          ngx_regex_exec_n "" failed: %i on \""%V\"" using \""%s\"""",
                          n, s, re[i].name);
            return NGX_ERROR;
        }

        /* match */

        return NGX_OK;
    }

    return NGX_DECLINED;
}",1,1,core\ngx_regex.c,ngx_regex_exec_array,,false,197,227,ngx_regex_exec_array,,,23,"ngx_int_t ngx_regex_exec_array (ngx_array_t*,ngx_str_t*,ngx_log_t*)"
40495,METHOD,core\ngx_regex.c:<global>,TYPE_DECL,"ngx_regex_malloc(size_t size)
{
    ngx_pool_t      *pool;
    pool = ngx_pcre_pool;

    if (pool) {
        return ngx_palloc(pool, size);
    }

    return NULL;
}",1,1,core\ngx_regex.c,ngx_regex_malloc,,false,231,241,ngx_regex_malloc,,,26,ANY ngx_regex_malloc (size_t)
40515,METHOD,core\ngx_regex.c:<global>,TYPE_DECL,"ngx_regex_free(void *p)
{
    return;
}",1,1,core\ngx_regex.c,ngx_regex_free,,false,245,248,ngx_regex_free,,,29,ANY ngx_regex_free (void*)
40521,METHOD,core\ngx_regex.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_regex_module_init(ngx_cycle_t *cycle)
{
    int               opt;
    const char       *errstr;
    ngx_uint_t        i;
    ngx_list_part_t  *part;
    ngx_regex_elt_t  *elts;

    opt = 0;

#if (NGX_HAVE_PCRE_JIT)
    {
    ngx_regex_conf_t    *rcf;
    ngx_pool_cleanup_t  *cln;

    rcf = (ngx_regex_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_regex_module);

    if (rcf->pcre_jit) {
        opt = PCRE_STUDY_JIT_COMPILE;

        /*
         * The PCRE JIT compiler uses mmap for its executable codes, so we
         * have to explicitly call the pcre_free_study() function to free
         * this memory.
         */

        cln = ngx_pool_cleanup_add(cycle->pool, 0);
        if (cln == NULL) {
            return NGX_ERROR;
        }

        cln->handler = ngx_pcre_free_studies;
        cln->data = ngx_pcre_studies;
    }
    }
#endif

    ngx_regex_malloc_init(cycle->pool);

    part = &ngx_pcre_studies->part;
    elts = part->elts;

    for (i = 0; /* void *...",1,1,core\ngx_regex.c,ngx_regex_module_init,,false,286,371,ngx_regex_module_init,,,30,ngx_int_t ngx_regex_module_init (ngx_cycle_t*)
40628,METHOD,core\ngx_regex.c:<global>,TYPE_DECL,"static void *
ngx_regex_create_conf(ngx_cycle_t *cycle)
{
    ngx_regex_conf_t  *rcf;

    rcf = ngx_pcalloc(cycle->pool, sizeof(ngx_regex_conf_t));
    if (rcf == NULL) {
        return NULL;
    }

    rcf->pcre_jit = NGX_CONF_UNSET;

    ngx_pcre_studies = ngx_list_create(cycle->pool, 8, sizeof(ngx_regex_elt_t));
    if (ngx_pcre_studies == NULL) {
        return NULL;
    }

    return rcf;
}",1,1,core\ngx_regex.c,ngx_regex_create_conf,,false,374,392,ngx_regex_create_conf,,,31,void* ngx_regex_create_conf (ngx_cycle_t*)
40672,METHOD,core\ngx_regex.c:<global>,TYPE_DECL,"static char *
ngx_regex_init_conf(ngx_cycle_t *cycle, void *conf)
{
    ngx_regex_conf_t *rcf = conf;

    ngx_conf_init_value(rcf->pcre_jit, 0);

    return NGX_CONF_OK;
}",1,1,core\ngx_regex.c,ngx_regex_init_conf,,false,395,403,ngx_regex_init_conf,,,32,"char* ngx_regex_init_conf (ngx_cycle_t*,void*)"
40689,METHOD,core\ngx_regex.c:<global>,TYPE_DECL,"static char *
ngx_regex_pcre_jit(ngx_conf_t *cf, void *post, void *data)
{
    ngx_flag_t  *fp = data;

    if (*fp == 0) {
        return NGX_CONF_OK;
    }

#if (NGX_HAVE_PCRE_JIT)
    {
    int  jit, r;

    jit = 0;
    r = pcre_config(PCRE_CONFIG_JIT, &jit);

    if (r != 0 || jit != 1) {
        ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
                           ""PCRE library does not support JIT"");
        *fp = 0;
    }
    }
#else
    ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
                       ""nginx was built without PCRE JIT support"");
    *fp = 0;
#endif

    return NGX_CONF_OK;
}",1,1,core\ngx_regex.c,ngx_regex_pcre_jit,,false,406,435,ngx_regex_pcre_jit,,,33,"char* ngx_regex_pcre_jit (ngx_conf_t*,void*,void*)"
40728,METHOD,core\ngx_regex.h:<global>,TYPE_DECL,<global>,1,35,core\ngx_regex.h,core\ngx_regex.h:<global>,,false,1,60,<global>,,,1,
40749,METHOD,core\ngx_regex.h:<global>,TYPE_DECL,void ngx_regex_init(void);,6,25,core\ngx_regex.h,ngx_regex_init,,false,49,49,ngx_regex_init,,,7,void ngx_regex_init (void)
40754,METHOD,core\ngx_regex.h:<global>,TYPE_DECL,ngx_int_t ngx_regex_compile(ngx_regex_compile_t *rc);,11,52,core\ngx_regex.h,ngx_regex_compile,,false,50,50,ngx_regex_compile,,,8,ngx_int_t ngx_regex_compile (ngx_regex_compile_t*)
40759,METHOD,core\ngx_regex.h:<global>,TYPE_DECL,"ngx_int_t ngx_regex_exec_array(ngx_array_t *a, ngx_str_t *s, ngx_log_t *log);",11,76,core\ngx_regex.h,ngx_regex_exec_array,,false,57,57,ngx_regex_exec_array,,,9,"ngx_int_t ngx_regex_exec_array (ngx_array_t*,ngx_str_t*,ngx_log_t*)"
40775,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,<global>,1,13,core\ngx_resolver.c,core\ngx_resolver.c:<global>,,false,1,4680,<global>,,,1,
40805,METHOD,<empty>,<empty>,<empty>,1,,core\ngx_resolver.c,ngx_resolver_an_t:<clinit>,,false,43,,<clinit>,,,8,
40812,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,static ngx_int_t ngx_udp_connect(ngx_resolver_connection_t *rec);,18,64,core\ngx_resolver.c,ngx_udp_connect,,false,59,59,ngx_udp_connect,,,7,ngx_int_t ngx_udp_connect (ngx_resolver_connection_t*)
40817,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,static ngx_int_t ngx_tcp_connect(ngx_resolver_connection_t *rec);,18,64,core\ngx_resolver.c,ngx_tcp_connect,,false,60,60,ngx_tcp_connect,,,8,ngx_int_t ngx_tcp_connect (ngx_resolver_connection_t*)
40822,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,static void ngx_resolver_cleanup(void *data);,13,44,core\ngx_resolver.c,ngx_resolver_cleanup,,false,63,63,ngx_resolver_cleanup,,,9,void ngx_resolver_cleanup (void*)
40827,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static void ngx_resolver_cleanup_tree(ngx_resolver_t *r, ngx_rbtree_t *tree);",13,76,core\ngx_resolver.c,ngx_resolver_cleanup_tree,,false,64,64,ngx_resolver_cleanup_tree,,,10,"void ngx_resolver_cleanup_tree (ngx_resolver_t*,ngx_rbtree_t*)"
40833,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static ngx_int_t ngx_resolve_name_locked(ngx_resolver_t *r,
    ngx_resolver_ctx_t *ctx, ngx_str_t *name);",18,45,core\ngx_resolver.c,ngx_resolve_name_locked,,false,65,66,ngx_resolve_name_locked,,,11,"ngx_int_t ngx_resolve_name_locked (ngx_resolver_t*,ngx_resolver_ctx_t*,ngx_str_t*)"
40840,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static void ngx_resolver_expire(ngx_resolver_t *r, ngx_rbtree_t *tree,
    ngx_queue_t *queue);",13,23,core\ngx_resolver.c,ngx_resolver_expire,,false,67,68,ngx_resolver_expire,,,12,"void ngx_resolver_expire (ngx_resolver_t*,ngx_rbtree_t*,ngx_queue_t*)"
40847,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static ngx_int_t ngx_resolver_send_query(ngx_resolver_t *r,
    ngx_resolver_node_t *rn);",18,28,core\ngx_resolver.c,ngx_resolver_send_query,,false,69,70,ngx_resolver_send_query,,,13,"ngx_int_t ngx_resolver_send_query (ngx_resolver_t*,ngx_resolver_node_t*)"
40853,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static ngx_int_t ngx_resolver_send_udp_query(ngx_resolver_t *r,
    ngx_resolver_connection_t *rec, u_char *query, u_short qlen);",18,64,core\ngx_resolver.c,ngx_resolver_send_udp_query,,false,71,72,ngx_resolver_send_udp_query,,,14,"ngx_int_t ngx_resolver_send_udp_query (ngx_resolver_t*,ngx_resolver_connection_t*,u_char*,u_short)"
40861,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static ngx_int_t ngx_resolver_send_tcp_query(ngx_resolver_t *r,
    ngx_resolver_connection_t *rec, u_char *query, u_short qlen);",18,64,core\ngx_resolver.c,ngx_resolver_send_tcp_query,,false,73,74,ngx_resolver_send_tcp_query,,,15,"ngx_int_t ngx_resolver_send_tcp_query (ngx_resolver_t*,ngx_resolver_connection_t*,u_char*,u_short)"
40869,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static ngx_int_t ngx_resolver_create_name_query(ngx_resolver_t *r,
    ngx_resolver_node_t *rn, ngx_str_t *name);",18,45,core\ngx_resolver.c,ngx_resolver_create_name_query,,false,75,76,ngx_resolver_create_name_query,,,16,"ngx_int_t ngx_resolver_create_name_query (ngx_resolver_t*,ngx_resolver_node_t*,ngx_str_t*)"
40876,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static ngx_int_t ngx_resolver_create_srv_query(ngx_resolver_t *r,
    ngx_resolver_node_t *rn, ngx_str_t *name);",18,45,core\ngx_resolver.c,ngx_resolver_create_srv_query,,false,77,78,ngx_resolver_create_srv_query,,,17,"ngx_int_t ngx_resolver_create_srv_query (ngx_resolver_t*,ngx_resolver_node_t*,ngx_str_t*)"
40883,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static ngx_int_t ngx_resolver_create_addr_query(ngx_resolver_t *r,
    ngx_resolver_node_t *rn, ngx_resolver_addr_t *addr);",18,55,core\ngx_resolver.c,ngx_resolver_create_addr_query,,false,79,80,ngx_resolver_create_addr_query,,,18,"ngx_int_t ngx_resolver_create_addr_query (ngx_resolver_t*,ngx_resolver_node_t*,ngx_resolver_addr_t*)"
40890,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,static void ngx_resolver_resend_handler(ngx_event_t *ev);,13,56,core\ngx_resolver.c,ngx_resolver_resend_handler,,false,81,81,ngx_resolver_resend_handler,,,19,void ngx_resolver_resend_handler (ngx_event_t*)
40895,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static time_t ngx_resolver_resend(ngx_resolver_t *r, ngx_rbtree_t *tree,
    ngx_queue_t *queue);",15,23,core\ngx_resolver.c,ngx_resolver_resend,,false,82,83,ngx_resolver_resend,,,20,"time_t ngx_resolver_resend (ngx_resolver_t*,ngx_rbtree_t*,ngx_queue_t*)"
40902,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,static ngx_uint_t ngx_resolver_resend_empty(ngx_resolver_t *r);,19,62,core\ngx_resolver.c,ngx_resolver_resend_empty,,false,84,84,ngx_resolver_resend_empty,,,21,ngx_uint_t ngx_resolver_resend_empty (ngx_resolver_t*)
40907,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,static void ngx_resolver_udp_read(ngx_event_t *rev);,13,51,core\ngx_resolver.c,ngx_resolver_udp_read,,false,85,85,ngx_resolver_udp_read,,,22,void ngx_resolver_udp_read (ngx_event_t*)
40912,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,static void ngx_resolver_tcp_write(ngx_event_t *wev);,13,52,core\ngx_resolver.c,ngx_resolver_tcp_write,,false,86,86,ngx_resolver_tcp_write,,,23,void ngx_resolver_tcp_write (ngx_event_t*)
40917,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,static void ngx_resolver_tcp_read(ngx_event_t *rev);,13,51,core\ngx_resolver.c,ngx_resolver_tcp_read,,false,87,87,ngx_resolver_tcp_read,,,24,void ngx_resolver_tcp_read (ngx_event_t*)
40922,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static void ngx_resolver_process_response(ngx_resolver_t *r, u_char *buf,
    size_t n, ngx_uint_t tcp);",13,29,core\ngx_resolver.c,ngx_resolver_process_response,,false,88,89,ngx_resolver_process_response,,,25,"void ngx_resolver_process_response (ngx_resolver_t*,u_char*,size_t,ngx_uint_t)"
40930,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static void ngx_resolver_process_a(ngx_resolver_t *r, u_char *buf, size_t n,
    ngx_uint_t ident, ngx_uint_t code, ngx_uint_t qtype,
    ngx_uint_t nan, ngx_uint_t trunc, ngx_uint_t ans);",13,53,core\ngx_resolver.c,ngx_resolver_process_a,,false,90,92,ngx_resolver_process_a,,,26,"void ngx_resolver_process_a (ngx_resolver_t*,u_char*,size_t,ngx_uint_t,ngx_uint_t,ngx_uint_t,ngx_uint_t,ngx_uint_t,ngx_uint_t)"
40943,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static void ngx_resolver_process_srv(ngx_resolver_t *r, u_char *buf, size_t n,
    ngx_uint_t ident, ngx_uint_t code, ngx_uint_t nan,
    ngx_uint_t trunc, ngx_uint_t ans);",13,37,core\ngx_resolver.c,ngx_resolver_process_srv,,false,93,95,ngx_resolver_process_srv,,,27,"void ngx_resolver_process_srv (ngx_resolver_t*,u_char*,size_t,ngx_uint_t,ngx_uint_t,ngx_uint_t,ngx_uint_t,ngx_uint_t)"
40955,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static void ngx_resolver_process_ptr(ngx_resolver_t *r, u_char *buf, size_t n,
    ngx_uint_t ident, ngx_uint_t code, ngx_uint_t nan);",13,54,core\ngx_resolver.c,ngx_resolver_process_ptr,,false,96,97,ngx_resolver_process_ptr,,,28,"void ngx_resolver_process_ptr (ngx_resolver_t*,u_char*,size_t,ngx_uint_t,ngx_uint_t,ngx_uint_t)"
40965,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static ngx_resolver_node_t *ngx_resolver_lookup_name(ngx_resolver_t *r,
    ngx_str_t *name, uint32_t hash);",28,35,core\ngx_resolver.c,ngx_resolver_lookup_name,,false,98,99,ngx_resolver_lookup_name,,,29,"ngx_resolver_node_t* ngx_resolver_lookup_name (ngx_resolver_t*,ngx_str_t*,uint32_t)"
40972,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static ngx_resolver_node_t *ngx_resolver_lookup_srv(ngx_resolver_t *r,
    ngx_str_t *name, uint32_t hash);",28,35,core\ngx_resolver.c,ngx_resolver_lookup_srv,,false,100,101,ngx_resolver_lookup_srv,,,30,"ngx_resolver_node_t* ngx_resolver_lookup_srv (ngx_resolver_t*,ngx_str_t*,uint32_t)"
40979,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static ngx_resolver_node_t *ngx_resolver_lookup_addr(ngx_resolver_t *r,
    in_addr_t addr);",28,19,core\ngx_resolver.c,ngx_resolver_lookup_addr,,false,102,103,ngx_resolver_lookup_addr,,,31,"ngx_resolver_node_t* ngx_resolver_lookup_addr (ngx_resolver_t*,in_addr_t)"
40985,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static void ngx_resolver_rbtree_insert_value(ngx_rbtree_node_t *temp,
    ngx_rbtree_node_t *node, ngx_rbtree_node_t *sentinel);",13,57,core\ngx_resolver.c,ngx_resolver_rbtree_insert_value,,false,104,105,ngx_resolver_rbtree_insert_value,,,32,"void ngx_resolver_rbtree_insert_value (ngx_rbtree_node_t*,ngx_rbtree_node_t*,ngx_rbtree_node_t*)"
40992,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static ngx_int_t ngx_resolver_copy(ngx_resolver_t *r, ngx_str_t *name,
    u_char *buf, u_char *src, u_char *last);",18,43,core\ngx_resolver.c,ngx_resolver_copy,,false,106,107,ngx_resolver_copy,,,33,"ngx_int_t ngx_resolver_copy (ngx_resolver_t*,ngx_str_t*,u_char*,u_char*,u_char*)"
41001,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static ngx_int_t ngx_resolver_set_timeout(ngx_resolver_t *r,
    ngx_resolver_ctx_t *ctx);",18,28,core\ngx_resolver.c,ngx_resolver_set_timeout,,false,108,109,ngx_resolver_set_timeout,,,34,"ngx_int_t ngx_resolver_set_timeout (ngx_resolver_t*,ngx_resolver_ctx_t*)"
41007,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,static void ngx_resolver_timeout_handler(ngx_event_t *ev);,13,57,core\ngx_resolver.c,ngx_resolver_timeout_handler,,false,110,110,ngx_resolver_timeout_handler,,,35,void ngx_resolver_timeout_handler (ngx_event_t*)
41012,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static void ngx_resolver_free_node(ngx_resolver_t *r, ngx_resolver_node_t *rn);",13,78,core\ngx_resolver.c,ngx_resolver_free_node,,false,111,111,ngx_resolver_free_node,,,36,"void ngx_resolver_free_node (ngx_resolver_t*,ngx_resolver_node_t*)"
41018,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static void *ngx_resolver_alloc(ngx_resolver_t *r, size_t size);",13,63,core\ngx_resolver.c,ngx_resolver_alloc,,false,112,112,ngx_resolver_alloc,,,37,"void* ngx_resolver_alloc (ngx_resolver_t*,size_t)"
41024,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static void *ngx_resolver_calloc(ngx_resolver_t *r, size_t size);",13,64,core\ngx_resolver.c,ngx_resolver_calloc,,false,113,113,ngx_resolver_calloc,,,38,"void* ngx_resolver_calloc (ngx_resolver_t*,size_t)"
41030,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static void ngx_resolver_free(ngx_resolver_t *r, void *p);",13,57,core\ngx_resolver.c,ngx_resolver_free,,false,114,114,ngx_resolver_free,,,39,"void ngx_resolver_free (ngx_resolver_t*,void*)"
41036,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static void ngx_resolver_free_locked(ngx_resolver_t *r, void *p);",13,64,core\ngx_resolver.c,ngx_resolver_free_locked,,false,115,115,ngx_resolver_free_locked,,,40,"void ngx_resolver_free_locked (ngx_resolver_t*,void*)"
41042,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static void *ngx_resolver_dup(ngx_resolver_t *r, void *src, size_t size);",13,72,core\ngx_resolver.c,ngx_resolver_dup,,false,116,116,ngx_resolver_dup,,,41,"void* ngx_resolver_dup (ngx_resolver_t*,void*,size_t)"
41049,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static ngx_resolver_addr_t *ngx_resolver_export(ngx_resolver_t *r,
    ngx_resolver_node_t *rn, ngx_uint_t rotate);",28,47,core\ngx_resolver.c,ngx_resolver_export,,false,117,118,ngx_resolver_export,,,42,"ngx_resolver_addr_t* ngx_resolver_export (ngx_resolver_t*,ngx_resolver_node_t*,ngx_uint_t)"
41056,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static void ngx_resolver_report_srv(ngx_resolver_t *r, ngx_resolver_ctx_t *ctx);",13,79,core\ngx_resolver.c,ngx_resolver_report_srv,,false,119,119,ngx_resolver_report_srv,,,43,"void ngx_resolver_report_srv (ngx_resolver_t*,ngx_resolver_ctx_t*)"
41062,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static u_char *ngx_resolver_log_error(ngx_log_t *log, u_char *buf, size_t len);",15,78,core\ngx_resolver.c,ngx_resolver_log_error,,false,120,120,ngx_resolver_log_error,,,44,"u_char* ngx_resolver_log_error (ngx_log_t*,u_char*,size_t)"
41069,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static void ngx_resolver_resolve_srv_names(ngx_resolver_ctx_t *ctx,
    ngx_resolver_node_t *rn);",13,28,core\ngx_resolver.c,ngx_resolver_resolve_srv_names,,false,121,122,ngx_resolver_resolve_srv_names,,,45,"void ngx_resolver_resolve_srv_names (ngx_resolver_ctx_t*,ngx_resolver_node_t*)"
41075,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,static void ngx_resolver_srv_names_handler(ngx_resolver_ctx_t *ctx);,13,67,core\ngx_resolver.c,ngx_resolver_srv_names_handler,,false,123,123,ngx_resolver_srv_names_handler,,,46,void ngx_resolver_srv_names_handler (ngx_resolver_ctx_t*)
41080,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static ngx_int_t ngx_resolver_cmp_srvs(const void *one, const void *two);",18,72,core\ngx_resolver.c,ngx_resolver_cmp_srvs,,false,124,124,ngx_resolver_cmp_srvs,,,47,"ngx_int_t ngx_resolver_cmp_srvs (void*,void*)"
41086,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"ngx_resolver_t *
ngx_resolver_create(ngx_conf_t *cf, ngx_str_t *names, ngx_uint_t n)
{
    ngx_str_t                   s;
    ngx_url_t                   u;
    ngx_uint_t                  i, j;
    ngx_resolver_t             *r;
    ngx_pool_cleanup_t         *cln;
    ngx_resolver_connection_t  *rec;

    r = ngx_pcalloc(cf->pool, sizeof(ngx_resolver_t));
    if (r == NULL) {
        return NULL;
    }

    r->event = ngx_pcalloc(cf->pool, sizeof(ngx_event_t));
    if (r->event == NULL) {
        return NULL;
    }

    cln = ngx_pool_cleanup_add(cf->pool, 0);
    if (cln == NULL) {
        return NULL;
    }

    cln->handler = ngx_resolver_cleanup;
    cln->data = r;

    ngx_rbtree_init(&r->name_rbtree, &r->name_sentinel,
                    ngx_resolver_rbtree_insert_value);

    ngx_rbtree_init(&r->srv_rbtree, &r->srv_sentinel,
                    ngx_resolver_rbtree_insert_value);

    ngx_rbtree_init(&r->addr_rbtree, &r->addr_sentinel,
                    ngx_rbtree_insert_...",1,1,core\ngx_resolver.c,ngx_resolver_create,,false,134,284,ngx_resolver_create,,,48,"ngx_resolver_t ngx_resolver_create (ngx_conf_t*,ngx_str_t*,ngx_uint_t)"
41536,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static void
ngx_resolver_cleanup(void *data)
{
    ngx_resolver_t  *r = data;

    ngx_uint_t                  i;
    ngx_resolver_connection_t  *rec;

    ngx_log_debug0(NGX_LOG_DEBUG_CORE, ngx_cycle->log, 0, ""cleanup resolver"");

    ngx_resolver_cleanup_tree(r, &r->name_rbtree);

    ngx_resolver_cleanup_tree(r, &r->srv_rbtree);

    ngx_resolver_cleanup_tree(r, &r->addr_rbtree);

#if (NGX_HAVE_INET6)
    ngx_resolver_cleanup_tree(r, &r->addr6_rbtree);
#endif

    if (r->event->timer_set) {
        ngx_del_timer(r->event);
    }

    rec = r->connections.elts;

    for (i = 0; i < r->connections.nelts; i++) {
        if (rec[i].udp) {
            ngx_close_connection(rec[i].udp);
        }

        if (rec[i].tcp) {
            ngx_close_connection(rec[i].tcp);
        }

        if (rec[i].read_buf) {
            ngx_resolver_free(r, rec[i].read_buf->start);
            ngx_resolver_free(r, rec[i].read_buf);
        }

        if (rec[i].write_buf) {
            ngx_resolver_fre...",1,1,core\ngx_resolver.c,ngx_resolver_cleanup,,false,287,332,ngx_resolver_cleanup,,,49,void ngx_resolver_cleanup (void*)
41677,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static void
ngx_resolver_cleanup_tree(ngx_resolver_t *r, ngx_rbtree_t *tree)
{
    ngx_resolver_ctx_t   *ctx, *next;
    ngx_resolver_node_t  *rn;

    while (tree->root != tree->sentinel) {

        rn = ngx_resolver_node(ngx_rbtree_min(tree->root, tree->sentinel));

        ngx_queue_remove(&rn->queue);

        for (ctx = rn->waiting; ctx; ctx = next) {
            next = ctx->next;

            if (ctx->event) {
                if (ctx->event->timer_set) {
                    ngx_del_timer(ctx->event);
                }

                ngx_resolver_free(r, ctx->event);
            }

            ngx_resolver_free(r, ctx);
        }

        ngx_rbtree_delete(tree, &rn->node);

        ngx_resolver_free_node(r, rn);
    }
}",1,13,core\ngx_resolver.c,ngx_resolver_cleanup_tree,,false,335,365,ngx_resolver_cleanup_tree,,,50,"void ngx_resolver_cleanup_tree (ngx_resolver_t*,ngx_rbtree_t*)"
41769,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"ngx_resolver_ctx_t *
ngx_resolve_start(ngx_resolver_t *r, ngx_resolver_ctx_t *temp)
{
    in_addr_t            addr;
    ngx_resolver_ctx_t  *ctx;

    if (temp) {
        addr = ngx_inet_addr(temp->name.data, temp->name.len);

        if (addr != INADDR_NONE) {
            temp->resolver = r;
            temp->state = NGX_OK;
            temp->naddrs = 1;
            temp->addrs = &temp->addr;
            temp->addr.sockaddr = (struct sockaddr *) &temp->sin;
            temp->addr.socklen = sizeof(struct sockaddr_in);
            ngx_memzero(&temp->sin, sizeof(struct sockaddr_in));
            temp->sin.sin_family = AF_INET;
            temp->sin.sin_addr.s_addr = addr;
            temp->quick = 1;

            return temp;
        }
    }

    if (r->connections.nelts == 0) {
        return NGX_NO_RESOLVER;
    }

    ctx = ngx_resolver_calloc(r, sizeof(ngx_resolver_ctx_t));

    if (ctx) {
        ctx->resolver = r;
    }

    return ctx;
}",1,1,core\ngx_resolver.c,ngx_resolve_start,,false,368,404,ngx_resolve_start,,,51,"ngx_resolver_ctx_t ngx_resolve_start (ngx_resolver_t*,ngx_resolver_ctx_t*)"
41898,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"ngx_int_t
ngx_resolve_name(ngx_resolver_ctx_t *ctx)
{
    size_t           slen;
    ngx_int_t        rc;
    ngx_str_t        name;
    ngx_resolver_t  *r;

    r = ctx->resolver;

    if (ctx->name.len > 0 && ctx->name.data[ctx->name.len - 1] == '.') {
        ctx->name.len--;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_CORE, r->log, 0,
                   ""resolve: \""%V\"""", &ctx->name);

    if (ctx->quick) {
        ctx->handler(ctx);
        return NGX_OK;
    }

    if (ctx->service.len) {
        slen = ctx->service.len;

        if (ngx_strlchr(ctx->service.data,
                        ctx->service.data + ctx->service.len, '.')
            == NULL)
        {
            slen += sizeof(""_._tcp"") - 1;
        }

        name.len = slen + 1 + ctx->name.len;

        name.data = ngx_resolver_alloc(r, name.len);
        if (name.data == NULL) {
            goto failed;
        }

        if (slen == ctx->service.len) {
            ngx_sprintf(name.data, ""%V.%V"", &ctx->service, &ctx->...",1,1,core\ngx_resolver.c,ngx_resolve_name,,false,407,486,ngx_resolve_name,,,52,ngx_int_t ngx_resolve_name (ngx_resolver_ctx_t*)
42128,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"void
ngx_resolve_name_done(ngx_resolver_ctx_t *ctx)
{
    ngx_uint_t            i;
    ngx_resolver_t       *r;
    ngx_resolver_ctx_t   *w, **p;
    ngx_resolver_node_t  *rn;

    r = ctx->resolver;

    ngx_log_debug1(NGX_LOG_DEBUG_CORE, r->log, 0,
                   ""resolve name done: %i"", ctx->state);

    if (ctx->quick) {
        return;
    }

    if (ctx->event && ctx->event->timer_set) {
        ngx_del_timer(ctx->event);
    }

    /* lock name mutex */

    if (ctx->nsrvs) {
        for (i = 0; i < ctx->nsrvs; i++) {
            if (ctx->srvs[i].ctx) {
                ngx_resolve_name_done(ctx->srvs[i].ctx);
            }

            if (ctx->srvs[i].addrs) {
                ngx_resolver_free(r, ctx->srvs[i].addrs->sockaddr);
                ngx_resolver_free(r, ctx->srvs[i].addrs);
            }

            ngx_resolver_free(r, ctx->srvs[i].name.data);
        }

        ngx_resolver_free(r, ctx->srvs);
    }

    if (ctx->state == NGX_AGAIN || ctx->state == NGX_RESOL...",1,1,core\ngx_resolver.c,ngx_resolve_name_done,,false,489,577,ngx_resolve_name_done,,,53,void ngx_resolve_name_done (ngx_resolver_ctx_t*)
42380,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_resolve_name_locked(ngx_resolver_t *r, ngx_resolver_ctx_t *ctx,
    ngx_str_t *name)
{
    uint32_t              hash;
    ngx_int_t             rc;
    ngx_str_t             cname;
    ngx_uint_t            i, naddrs;
    ngx_queue_t          *resend_queue, *expire_queue;
    ngx_rbtree_t         *tree;
    ngx_resolver_ctx_t   *next, *last;
    ngx_resolver_addr_t  *addrs;
    ngx_resolver_node_t  *rn;

    ngx_strlow(name->data, name->data, name->len);

    hash = ngx_crc32_short(name->data, name->len);

    if (ctx->service.len) {
        rn = ngx_resolver_lookup_srv(r, name, hash);

        tree = &r->srv_rbtree;
        resend_queue = &r->srv_resend_queue;
        expire_queue = &r->srv_expire_queue;

    } else {
        rn = ngx_resolver_lookup_name(r, name, hash);

        tree = &r->name_rbtree;
        resend_queue = &r->name_resend_queue;
        expire_queue = &r->name_expire_queue;
    }

    if (rn) {

        /* ctx can be a list after NGX_RESOLV...",1,1,core\ngx_resolver.c,ngx_resolve_name_locked,,false,580,902,ngx_resolve_name_locked,,,54,"ngx_int_t ngx_resolve_name_locked (ngx_resolver_t*,ngx_resolver_ctx_t*,ngx_str_t*)"
43295,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"ngx_int_t
ngx_resolve_addr(ngx_resolver_ctx_t *ctx)
{
    u_char               *name;
    in_addr_t             addr;
    ngx_queue_t          *resend_queue, *expire_queue;
    ngx_rbtree_t         *tree;
    ngx_resolver_t       *r;
    struct sockaddr_in   *sin;
    ngx_resolver_node_t  *rn;
#if (NGX_HAVE_INET6)
    uint32_t              hash;
    struct sockaddr_in6  *sin6;
#endif

#if (NGX_SUPPRESS_WARN)
    addr = 0;
#if (NGX_HAVE_INET6)
    hash = 0;
    sin6 = NULL;
#endif
#endif

    r = ctx->resolver;

    switch (ctx->addr.sockaddr->sa_family) {

#if (NGX_HAVE_INET6)
    case AF_INET6:
        sin6 = (struct sockaddr_in6 *) ctx->addr.sockaddr;
        hash = ngx_crc32_short(sin6->sin6_addr.s6_addr, 16);

        /* lock addr mutex */

        rn = ngx_resolver_lookup_addr6(r, &sin6->sin6_addr, hash);

        tree = &r->addr6_rbtree;
        resend_queue = &r->addr6_resend_queue;
        expire_queue = &r->addr6_expire_queue;

        break;
#endif

    default: /* AF_INET...",1,1,core\ngx_resolver.c,ngx_resolve_addr,,false,905,1123,ngx_resolve_addr,,,55,ngx_int_t ngx_resolve_addr (ngx_resolver_ctx_t*)
43770,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"void
ngx_resolve_addr_done(ngx_resolver_ctx_t *ctx)
{
    ngx_queue_t          *expire_queue;
    ngx_rbtree_t         *tree;
    ngx_resolver_t       *r;
    ngx_resolver_ctx_t   *w, **p;
    ngx_resolver_node_t  *rn;

    r = ctx->resolver;

    switch (ctx->addr.sockaddr->sa_family) {

#if (NGX_HAVE_INET6)
    case AF_INET6:
        tree = &r->addr6_rbtree;
        expire_queue = &r->addr6_expire_queue;
        break;
#endif

    default: /* AF_INET */
        tree = &r->addr_rbtree;
        expire_queue = &r->addr_expire_queue;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_CORE, r->log, 0,
                   ""resolve addr done: %i"", ctx->state);

    if (ctx->event && ctx->event->timer_set) {
        ngx_del_timer(ctx->event);
    }

    /* lock addr mutex */

    if (ctx->state == NGX_AGAIN || ctx->state == NGX_RESOLVE_TIMEDOUT) {

        rn = ctx->node;

        if (rn) {
            p = &rn->waiting;
            w = rn->waiting;

            while (w) {
                if (w == ct...",1,1,core\ngx_resolver.c,ngx_resolve_addr_done,,false,1126,1212,ngx_resolve_addr_done,,,56,void ngx_resolve_addr_done (ngx_resolver_ctx_t*)
43958,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static void
ngx_resolver_expire(ngx_resolver_t *r, ngx_rbtree_t *tree, ngx_queue_t *queue)
{
    time_t                now;
    ngx_uint_t            i;
    ngx_queue_t          *q;
    ngx_resolver_node_t  *rn;

    ngx_log_debug0(NGX_LOG_DEBUG_CORE, r->log, 0, ""resolver expire"");

    now = ngx_time();

    for (i = 0; i < 2; i++) {
        if (ngx_queue_empty(queue)) {
            return;
        }

        q = ngx_queue_last(queue);

        rn = ngx_queue_data(q, ngx_resolver_node_t, queue);

        if (now <= rn->expire) {
            return;
        }

        ngx_log_debug2(NGX_LOG_DEBUG_CORE, r->log, 0,
                       ""resolver expire \""%*s\"""", (size_t) rn->nlen, rn->name);

        ngx_queue_remove(q);

        ngx_rbtree_delete(tree, &rn->node);

        ngx_resolver_free_node(r, rn);
    }
}",1,1,core\ngx_resolver.c,ngx_resolver_expire,,false,1215,1249,ngx_resolver_expire,,,57,"void ngx_resolver_expire (ngx_resolver_t*,ngx_rbtree_t*,ngx_queue_t*)"
44039,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_resolver_send_query(ngx_resolver_t *r, ngx_resolver_node_t *rn)
{
    ngx_int_t                   rc;
    ngx_resolver_connection_t  *rec;

    rec = r->connections.elts;
    rec = &rec[rn->last_connection];

    if (rec->log.handler == NULL) {
        rec->log = *r->log;
        rec->log.handler = ngx_resolver_log_error;
        rec->log.data = rec;
        rec->log.action = ""resolving"";
    }

    if (rn->naddrs == (u_short) -1) {
        rc = rn->tcp ? ngx_resolver_send_tcp_query(r, rec, rn->query, rn->qlen)
                     : ngx_resolver_send_udp_query(r, rec, rn->query, rn->qlen);

        if (rc != NGX_OK) {
            return rc;
        }
    }

#if (NGX_HAVE_INET6)

    if (rn->query6 && rn->naddrs6 == (u_short) -1) {
        rc = rn->tcp6
                    ? ngx_resolver_send_tcp_query(r, rec, rn->query6, rn->qlen)
                    : ngx_resolver_send_udp_query(r, rec, rn->query6, rn->qlen);

        if (rc != NGX_OK) {
            return rc;...",1,1,core\ngx_resolver.c,ngx_resolver_send_query,,false,1252,1292,ngx_resolver_send_query,,,58,"ngx_int_t ngx_resolver_send_query (ngx_resolver_t*,ngx_resolver_node_t*)"
44142,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_resolver_send_udp_query(ngx_resolver_t *r, ngx_resolver_connection_t  *rec,
    u_char *query, u_short qlen)
{
    ssize_t  n;

    if (rec->udp == NULL) {
        if (ngx_udp_connect(rec) != NGX_OK) {
            return NGX_ERROR;
        }

        rec->udp->data = rec;
        rec->udp->read->handler = ngx_resolver_udp_read;
        rec->udp->read->resolver = 1;
    }

    n = ngx_send(rec->udp, query, qlen);

    if (n == NGX_ERROR) {
        goto failed;
    }

    if ((size_t) n != (size_t) qlen) {
        ngx_log_error(NGX_LOG_CRIT, &rec->log, 0, ""send() incomplete"");
        goto failed;
    }

    return NGX_OK;

failed:

    ngx_close_connection(rec->udp);
    rec->udp = NULL;

    return NGX_ERROR;
}",1,1,core\ngx_resolver.c,ngx_resolver_send_udp_query,,false,1295,1330,ngx_resolver_send_udp_query,,,59,"ngx_int_t ngx_resolver_send_udp_query (ngx_resolver_t*,ngx_resolver_connection_t*,u_char*,u_short)"
44237,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_resolver_send_tcp_query(ngx_resolver_t *r, ngx_resolver_connection_t *rec,
    u_char *query, u_short qlen)
{
    ngx_buf_t  *b;
    ngx_int_t   rc;

    rc = NGX_OK;

    if (rec->tcp == NULL) {
        b = rec->read_buf;

        if (b == NULL) {
            b = ngx_resolver_calloc(r, sizeof(ngx_buf_t));
            if (b == NULL) {
                return NGX_ERROR;
            }

            b->start = ngx_resolver_alloc(r, NGX_RESOLVER_TCP_RSIZE);
            if (b->start == NULL) {
                ngx_resolver_free(r, b);
                return NGX_ERROR;
            }

            b->end = b->start + NGX_RESOLVER_TCP_RSIZE;

            rec->read_buf = b;
        }

        b->pos = b->start;
        b->last = b->start;

        b = rec->write_buf;

        if (b == NULL) {
            b = ngx_resolver_calloc(r, sizeof(ngx_buf_t));
            if (b == NULL) {
                return NGX_ERROR;
            }

            b->start = ngx_resolver_alloc(r, NGX...",1,45,core\ngx_resolver.c,ngx_resolver_send_tcp_query,,false,1333,1416,ngx_resolver_send_tcp_query,,,60,"ngx_int_t ngx_resolver_send_tcp_query (ngx_resolver_t*,ngx_resolver_connection_t*,u_char*,u_short)"
44536,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static void
ngx_resolver_resend_handler(ngx_event_t *ev)
{
    time_t           timer, atimer, stimer, ntimer;
#if (NGX_HAVE_INET6)
    time_t           a6timer;
#endif
    ngx_resolver_t  *r;

    r = ev->data;

    ngx_log_debug0(NGX_LOG_DEBUG_CORE, r->log, 0,
                   ""resolver resend handler"");

    /* lock name mutex */

    ntimer = ngx_resolver_resend(r, &r->name_rbtree, &r->name_resend_queue);

    stimer = ngx_resolver_resend(r, &r->srv_rbtree, &r->srv_resend_queue);

    /* unlock name mutex */

    /* lock addr mutex */

    atimer = ngx_resolver_resend(r, &r->addr_rbtree, &r->addr_resend_queue);

    /* unlock addr mutex */

#if (NGX_HAVE_INET6)

    /* lock addr6 mutex */

    a6timer = ngx_resolver_resend(r, &r->addr6_rbtree, &r->addr6_resend_queue);

    /* unlock addr6 mutex */

#endif

    timer = ntimer;

    if (timer == 0) {
        timer = atimer;

    } else if (atimer) {
        timer = ngx_min(timer, atimer);
    }

    if (timer == 0) {
        tim...",1,1,core\ngx_resolver.c,ngx_resolver_resend_handler,,false,1419,1487,ngx_resolver_resend_handler,,,61,void ngx_resolver_resend_handler (ngx_event_t*)
44644,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static time_t
ngx_resolver_resend(ngx_resolver_t *r, ngx_rbtree_t *tree, ngx_queue_t *queue)
{
    time_t                now;
    ngx_queue_t          *q;
    ngx_resolver_node_t  *rn;

    now = ngx_time();

    for ( ;; ) {
        if (ngx_queue_empty(queue)) {
            return 0;
        }

        q = ngx_queue_last(queue);

        rn = ngx_queue_data(q, ngx_resolver_node_t, queue);

        if (now < rn->expire) {
            return rn->expire - now;
        }

        ngx_log_debug3(NGX_LOG_DEBUG_CORE, r->log, 0,
                       ""resolver resend \""%*s\"" %p"",
                       (size_t) rn->nlen, rn->name, rn->waiting);

        ngx_queue_remove(q);

        if (rn->waiting) {

            if (++rn->last_connection == r->connections.nelts) {
                rn->last_connection = 0;
            }

            (void) ngx_resolver_send_query(r, rn);

            rn->expire = now + r->resend_timeout;

            ngx_queue_insert_head(queue, q);

            continue;...",1,1,core\ngx_resolver.c,ngx_resolver_resend,,false,1490,1537,ngx_resolver_resend,,,62,"time_t ngx_resolver_resend (ngx_resolver_t*,ngx_rbtree_t*,ngx_queue_t*)"
44758,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static ngx_uint_t
ngx_resolver_resend_empty(ngx_resolver_t *r)
{
    return ngx_queue_empty(&r->name_resend_queue)
           && ngx_queue_empty(&r->srv_resend_queue)
#if (NGX_HAVE_INET6)
           && ngx_queue_empty(&r->addr6_resend_queue)
#endif
           && ngx_queue_empty(&r->addr_resend_queue);
}",1,1,core\ngx_resolver.c,ngx_resolver_resend_empty,,false,1540,1549,ngx_resolver_resend_empty,,,63,ngx_uint_t ngx_resolver_resend_empty (ngx_resolver_t*)
44781,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static void
ngx_resolver_udp_read(ngx_event_t *rev)
{
    ssize_t                     n;
    ngx_connection_t           *c;
    ngx_resolver_connection_t  *rec;
    u_char                      buf[NGX_RESOLVER_UDP_SIZE];

    c = rev->data;
    rec = c->data;

    do {
        n = ngx_udp_recv(c, buf, NGX_RESOLVER_UDP_SIZE);

        if (n < 0) {
            return;
        }

        ngx_resolver_process_response(rec->resolver, buf, n, 0);

    } while (rev->ready);
}",1,36,core\ngx_resolver.c,ngx_resolver_udp_read,,false,1552,1573,ngx_resolver_udp_read,,,64,void ngx_resolver_udp_read (ngx_event_t*)
44826,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static void
ngx_resolver_tcp_write(ngx_event_t *wev)
{
    off_t                       sent;
    ssize_t                     n;
    ngx_buf_t                  *b;
    ngx_resolver_t             *r;
    ngx_connection_t           *c;
    ngx_resolver_connection_t  *rec;

    c = wev->data;
    rec = c->data;
    b = rec->write_buf;
    r = rec->resolver;

    if (wev->timedout) {
        goto failed;
    }

    sent = c->sent;

    while (wev->ready && b->pos < b->last) {
        n = ngx_send(c, b->pos, b->last - b->pos);

        if (n == NGX_AGAIN) {
            break;
        }

        if (n == NGX_ERROR) {
            goto failed;
        }

        b->pos += n;
    }

    if (b->pos != b->start) {
        b->last = ngx_movemem(b->start, b->pos, b->last - b->pos);
        b->pos = b->start;
    }

    if (c->sent != sent) {
        ngx_add_timer(wev, (ngx_msec_t) (r->tcp_timeout * 1000));
    }

    if (ngx_handle_write_event(wev, 0) != NGX_OK) {
        goto failed;
    }

    ...",1,1,core\ngx_resolver.c,ngx_resolver_tcp_write,,false,1576,1630,ngx_resolver_tcp_write,,,65,void ngx_resolver_tcp_write (ngx_event_t*)
44978,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static void
ngx_resolver_tcp_read(ngx_event_t *rev)
{
    u_char                     *p;
    size_t                      size;
    ssize_t                     n;
    u_short                     qlen;
    ngx_buf_t                  *b;
    ngx_resolver_t             *r;
    ngx_connection_t           *c;
    ngx_resolver_connection_t  *rec;

    c = rev->data;
    rec = c->data;
    b = rec->read_buf;
    r = rec->resolver;

    while (rev->ready) {
        n = ngx_recv(c, b->last, b->end - b->last);

        if (n == NGX_AGAIN) {
            break;
        }

        if (n == NGX_ERROR || n == 0) {
            goto failed;
        }

        b->last += n;

        for ( ;; ) {
            p = b->pos;
            size = b->last - p;

            if (size < 2) {
                break;
            }

            qlen = (u_short) *p++ << 8;
            qlen += *p++;

            if (size < (size_t) (2 + qlen)) {
                break;
            }

            ngx_resolver_process_resp...",1,1,core\ngx_resolver.c,ngx_resolver_tcp_read,,false,1633,1699,ngx_resolver_tcp_read,,,66,void ngx_resolver_tcp_read (ngx_event_t*)
45157,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static void
ngx_resolver_process_response(ngx_resolver_t *r, u_char *buf, size_t n,
    ngx_uint_t tcp)
{
    char                 *err;
    ngx_uint_t            i, times, ident, qident, flags, code, nqs, nan, trunc,
                          qtype, qclass;
#if (NGX_HAVE_INET6)
    ngx_uint_t            qident6;
#endif
    ngx_queue_t          *q;
    ngx_resolver_qs_t    *qs;
    ngx_resolver_hdr_t   *response;
    ngx_resolver_node_t  *rn;

    if (n < sizeof(ngx_resolver_hdr_t)) {
        goto short_response;
    }

    response = (ngx_resolver_hdr_t *) buf;

    ident = (response->ident_hi << 8) + response->ident_lo;
    flags = (response->flags_hi << 8) + response->flags_lo;
    nqs = (response->nqs_hi << 8) + response->nqs_lo;
    nan = (response->nan_hi << 8) + response->nan_lo;
    trunc = flags & 0x0200;

    ngx_log_debug6(NGX_LOG_DEBUG_CORE, r->log, 0,
                   ""resolver DNS response %ui fl:%04Xi %ui/%ui/%ud/%ud"",
                   ident, flags, nqs, nan,
    ...",1,1,core\ngx_resolver.c,ngx_resolver_process_response,,false,1702,1879,ngx_resolver_process_response,,,67,"void ngx_resolver_process_response (ngx_resolver_t*,u_char*,size_t,ngx_uint_t)"
45602,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static void
ngx_resolver_process_a(ngx_resolver_t *r, u_char *buf, size_t n,
    ngx_uint_t ident, ngx_uint_t code, ngx_uint_t qtype,
    ngx_uint_t nan, ngx_uint_t trunc, ngx_uint_t ans)
{
    char                       *err;
    u_char                     *cname;
    size_t                      len;
    int32_t                     ttl;
    uint32_t                    hash;
    in_addr_t                  *addr;
    ngx_str_t                   name;
    ngx_uint_t                  type, class, qident, naddrs, a, i, j, start;
#if (NGX_HAVE_INET6)
    struct in6_addr            *addr6;
#endif
    ngx_resolver_an_t          *an;
    ngx_resolver_ctx_t         *ctx, *next;
    ngx_resolver_node_t        *rn;
    ngx_resolver_addr_t        *addrs;
    ngx_resolver_connection_t  *rec;

    if (ngx_resolver_copy(r, &name, buf,
                          buf + sizeof(ngx_resolver_hdr_t), buf + n)
        != NGX_OK)
    {
        return;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_CORE, r->log, 0...",1,1,core\ngx_resolver.c,ngx_resolver_process_a,,false,1882,2534,ngx_resolver_process_a,,,68,"void ngx_resolver_process_a (ngx_resolver_t*,u_char*,size_t,ngx_uint_t,ngx_uint_t,ngx_uint_t,ngx_uint_t,ngx_uint_t,ngx_uint_t)"
46855,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static void
ngx_resolver_process_srv(ngx_resolver_t *r, u_char *buf, size_t n,
    ngx_uint_t ident, ngx_uint_t code, ngx_uint_t nan,
    ngx_uint_t trunc, ngx_uint_t ans)
{
    char                       *err;
    u_char                     *cname;
    size_t                      len;
    int32_t                     ttl;
    uint32_t                    hash;
    ngx_str_t                   name;
    ngx_uint_t                  type, qident, class, start, nsrvs, a, i, j;
    ngx_resolver_an_t          *an;
    ngx_resolver_ctx_t         *ctx, *next;
    ngx_resolver_srv_t         *srvs;
    ngx_resolver_node_t        *rn;
    ngx_resolver_connection_t  *rec;

    if (ngx_resolver_copy(r, &name, buf,
                          buf + sizeof(ngx_resolver_hdr_t), buf + n)
        != NGX_OK)
    {
        return;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_CORE, r->log, 0, ""resolver qs:%V"", &name);

    hash = ngx_crc32_short(name.data, name.len);

    rn = ngx_resolver_lookup_srv(r, &name, h...",1,1,core\ngx_resolver.c,ngx_resolver_process_srv,,false,2537,2917,ngx_resolver_process_srv,,,69,"void ngx_resolver_process_srv (ngx_resolver_t*,u_char*,size_t,ngx_uint_t,ngx_uint_t,ngx_uint_t,ngx_uint_t,ngx_uint_t)"
47940,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static void
ngx_resolver_resolve_srv_names(ngx_resolver_ctx_t *ctx, ngx_resolver_node_t *rn)
{
    ngx_uint_t                i;
    ngx_resolver_t           *r;
    ngx_resolver_ctx_t       *cctx;
    ngx_resolver_srv_name_t  *srvs;

    r = ctx->resolver;

    ctx->node = NULL;
    ctx->state = NGX_OK;
    ctx->valid = rn->valid;
    ctx->count = rn->nsrvs;

    srvs = ngx_resolver_calloc(r, rn->nsrvs * sizeof(ngx_resolver_srv_name_t));
    if (srvs == NULL) {
        goto failed;
    }

    ctx->srvs = srvs;
    ctx->nsrvs = rn->nsrvs;

    if (ctx->event && ctx->event->timer_set) {
        ngx_del_timer(ctx->event);
    }

    for (i = 0; i < (ngx_uint_t) rn->nsrvs; i++) {
        srvs[i].name.data = ngx_resolver_alloc(r, rn->u.srvs[i].name.len);
        if (srvs[i].name.data == NULL) {
            goto failed;
        }

        srvs[i].name.len = rn->u.srvs[i].name.len;
        ngx_memcpy(srvs[i].name.data, rn->u.srvs[i].name.data,
                   srvs[i].name.len);

       ...",1,1,core\ngx_resolver.c,ngx_resolver_resolve_srv_names,,false,2920,2987,ngx_resolver_resolve_srv_names,,,70,"void ngx_resolver_resolve_srv_names (ngx_resolver_ctx_t*,ngx_resolver_node_t*)"
48252,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static void
ngx_resolver_srv_names_handler(ngx_resolver_ctx_t *cctx)
{
    ngx_uint_t                i;
    ngx_addr_t               *addrs;
    ngx_resolver_t           *r;
    ngx_sockaddr_t           *sockaddr;
    ngx_resolver_ctx_t       *ctx;
    ngx_resolver_srv_name_t  *srv;

    r = cctx->resolver;
    ctx = cctx->data;
    srv = cctx->srvs;

    ctx->count--;
    ctx->async |= cctx->async;

    srv->ctx = NULL;
    srv->state = cctx->state;

    if (cctx->naddrs) {

        ctx->valid = ngx_min(ctx->valid, cctx->valid);

        addrs = ngx_resolver_calloc(r, cctx->naddrs * sizeof(ngx_addr_t));
        if (addrs == NULL) {
            srv->state = NGX_ERROR;
            goto done;
        }

        sockaddr = ngx_resolver_alloc(r, cctx->naddrs * sizeof(ngx_sockaddr_t));
        if (sockaddr == NULL) {
            ngx_resolver_free(r, addrs);
            srv->state = NGX_ERROR;
            goto done;
        }

        for (i = 0; i < cctx->naddrs; i++) {
            addrs...",1,1,core\ngx_resolver.c,ngx_resolver_srv_names_handler,,false,2990,3048,ngx_resolver_srv_names_handler,,,71,void ngx_resolver_srv_names_handler (ngx_resolver_ctx_t*)
48451,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static void
ngx_resolver_process_ptr(ngx_resolver_t *r, u_char *buf, size_t n,
    ngx_uint_t ident, ngx_uint_t code, ngx_uint_t nan)
{
    char                 *err;
    size_t                len;
    in_addr_t             addr;
    int32_t               ttl;
    ngx_int_t             octet;
    ngx_str_t             name;
    ngx_uint_t            mask, type, class, qident, a, i, start;
    ngx_queue_t          *expire_queue;
    ngx_rbtree_t         *tree;
    ngx_resolver_an_t    *an;
    ngx_resolver_ctx_t   *ctx, *next;
    ngx_resolver_node_t  *rn;
#if (NGX_HAVE_INET6)
    uint32_t              hash;
    ngx_int_t             digit;
    struct in6_addr       addr6;
#endif

    if (ngx_resolver_copy(r, &name, buf,
                          buf + sizeof(ngx_resolver_hdr_t), buf + n)
        != NGX_OK)
    {
        return;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_CORE, r->log, 0, ""resolver qs:%V"", &name);

    /* AF_INET */

    addr = 0;
    i = sizeof(ngx_resolver_hdr_t);

   ...",1,1,core\ngx_resolver.c,ngx_resolver_process_ptr,,false,3051,3365,ngx_resolver_process_ptr,,,72,"void ngx_resolver_process_ptr (ngx_resolver_t*,u_char*,size_t,ngx_uint_t,ngx_uint_t,ngx_uint_t)"
49168,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static ngx_resolver_node_t *
ngx_resolver_lookup_name(ngx_resolver_t *r, ngx_str_t *name, uint32_t hash)
{
    ngx_int_t             rc;
    ngx_rbtree_node_t    *node, *sentinel;
    ngx_resolver_node_t  *rn;

    node = r->name_rbtree.root;
    sentinel = r->name_rbtree.sentinel;

    while (node != sentinel) {

        if (hash < node->key) {
            node = node->left;
            continue;
        }

        if (hash > node->key) {
            node = node->right;
            continue;
        }

        /* hash == node->key */

        rn = ngx_resolver_node(node);

        rc = ngx_memn2cmp(name->data, rn->name, name->len, rn->nlen);

        if (rc == 0) {
            return rn;
        }

        node = (rc < 0) ? node->left : node->right;
    }

    /* not found */

    return NULL;
}",1,13,core\ngx_resolver.c,ngx_resolver_lookup_name,,false,3368,3406,ngx_resolver_lookup_name,,,73,"ngx_resolver_node_t ngx_resolver_lookup_name (ngx_resolver_t*,ngx_str_t*,uint32_t)"
49274,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static ngx_resolver_node_t *
ngx_resolver_lookup_srv(ngx_resolver_t *r, ngx_str_t *name, uint32_t hash)
{
    ngx_int_t             rc;
    ngx_rbtree_node_t    *node, *sentinel;
    ngx_resolver_node_t  *rn;

    node = r->srv_rbtree.root;
    sentinel = r->srv_rbtree.sentinel;

    while (node != sentinel) {

        if (hash < node->key) {
            node = node->left;
            continue;
        }

        if (hash > node->key) {
            node = node->right;
            continue;
        }

        /* hash == node->key */

        rn = ngx_resolver_node(node);

        rc = ngx_memn2cmp(name->data, rn->name, name->len, rn->nlen);

        if (rc == 0) {
            return rn;
        }

        node = (rc < 0) ? node->left : node->right;
    }

    /* not found */

    return NULL;
}",1,13,core\ngx_resolver.c,ngx_resolver_lookup_srv,,false,3409,3447,ngx_resolver_lookup_srv,,,74,"ngx_resolver_node_t ngx_resolver_lookup_srv (ngx_resolver_t*,ngx_str_t*,uint32_t)"
49380,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static ngx_resolver_node_t *
ngx_resolver_lookup_addr(ngx_resolver_t *r, in_addr_t addr)
{
    ngx_rbtree_node_t  *node, *sentinel;

    node = r->addr_rbtree.root;
    sentinel = r->addr_rbtree.sentinel;

    while (node != sentinel) {

        if (addr < node->key) {
            node = node->left;
            continue;
        }

        if (addr > node->key) {
            node = node->right;
            continue;
        }

        /* addr == node->key */

        return ngx_resolver_node(node);
    }

    /* not found */

    return NULL;
}",1,15,core\ngx_resolver.c,ngx_resolver_lookup_addr,,false,3450,3478,ngx_resolver_lookup_addr,,,75,"ngx_resolver_node_t ngx_resolver_lookup_addr (ngx_resolver_t*,in_addr_t)"
49448,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static void
ngx_resolver_rbtree_insert_value(ngx_rbtree_node_t *temp,
    ngx_rbtree_node_t *node, ngx_rbtree_node_t *sentinel)
{
    ngx_rbtree_node_t    **p;
    ngx_resolver_node_t   *rn, *rn_temp;

    for ( ;; ) {

        if (node->key < temp->key) {

            p = &temp->left;

        } else if (node->key > temp->key) {

            p = &temp->right;

        } else { /* node->key == temp->key */

            rn = ngx_resolver_node(node);
            rn_temp = ngx_resolver_node(temp);

            p = (ngx_memn2cmp(rn->name, rn_temp->name, rn->nlen, rn_temp->nlen)
                 < 0) ? &temp->left : &temp->right;
        }

        if (*p == sentinel) {
            break;
        }

        temp = *p;
    }

    *p = node;
    node->parent = temp;
    node->left = sentinel;
    node->right = sentinel;
    ngx_rbt_red(node);
}",1,17,core\ngx_resolver.c,ngx_resolver_rbtree_insert_value,,false,3527,3565,ngx_resolver_rbtree_insert_value,,,76,"void ngx_resolver_rbtree_insert_value (ngx_rbtree_node_t*,ngx_rbtree_node_t*,ngx_rbtree_node_t*)"
49581,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_resolver_create_name_query(ngx_resolver_t *r, ngx_resolver_node_t *rn,
    ngx_str_t *name)
{
    u_char              *p, *s;
    size_t               len, nlen;
    ngx_uint_t           ident;
    ngx_resolver_qs_t   *qs;
    ngx_resolver_hdr_t  *query;

    nlen = name->len ? (1 + name->len + 1) : 1;

    len = sizeof(ngx_resolver_hdr_t) + nlen + sizeof(ngx_resolver_qs_t);

#if (NGX_HAVE_INET6)
    p = ngx_resolver_alloc(r, r->ipv6 ? len * 2 : len);
#else
    p = ngx_resolver_alloc(r, len);
#endif
    if (p == NULL) {
        return NGX_ERROR;
    }

    rn->qlen = (u_short) len;
    rn->query = p;

#if (NGX_HAVE_INET6)
    if (r->ipv6) {
        rn->query6 = p + len;
    }
#endif

    query = (ngx_resolver_hdr_t *) p;

    ident = ngx_random();

    ngx_log_debug2(NGX_LOG_DEBUG_CORE, r->log, 0,
                   ""resolve: \""%V\"" A %i"", name, ident & 0xffff);

    query->ident_hi = (u_char) ((ident >> 8) & 0xff);
    query->ident_lo = (u_char) (ident & 0xff);...",1,1,core\ngx_resolver.c,ngx_resolver_create_name_query,,false,3613,3734,ngx_resolver_create_name_query,,,77,"ngx_int_t ngx_resolver_create_name_query (ngx_resolver_t*,ngx_resolver_node_t*,ngx_str_t*)"
49856,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_resolver_create_srv_query(ngx_resolver_t *r, ngx_resolver_node_t *rn,
    ngx_str_t *name)
{
    u_char              *p, *s;
    size_t               len, nlen;
    ngx_uint_t           ident;
    ngx_resolver_qs_t   *qs;
    ngx_resolver_hdr_t  *query;

    nlen = name->len ? (1 + name->len + 1) : 1;

    len = sizeof(ngx_resolver_hdr_t) + nlen + sizeof(ngx_resolver_qs_t);

    p = ngx_resolver_alloc(r, len);
    if (p == NULL) {
        return NGX_ERROR;
    }

    rn->qlen = (u_short) len;
    rn->query = p;

    query = (ngx_resolver_hdr_t *) p;

    ident = ngx_random();

    ngx_log_debug2(NGX_LOG_DEBUG_CORE, r->log, 0,
                   ""resolve: \""%V\"" SRV %i"", name, ident & 0xffff);

    query->ident_hi = (u_char) ((ident >> 8) & 0xff);
    query->ident_lo = (u_char) (ident & 0xff);

    /* recursion query */
    query->flags_hi = 1; query->flags_lo = 0;

    /* one question */
    query->nqs_hi = 0; query->nqs_lo = 1;
    query->nan_hi = 0; query->nan...",1,1,core\ngx_resolver.c,ngx_resolver_create_srv_query,,false,3737,3822,ngx_resolver_create_srv_query,,,78,"ngx_int_t ngx_resolver_create_srv_query (ngx_resolver_t*,ngx_resolver_node_t*,ngx_str_t*)"
50131,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_resolver_create_addr_query(ngx_resolver_t *r, ngx_resolver_node_t *rn,
    ngx_resolver_addr_t *addr)
{
    u_char               *p, *d;
    size_t                len;
    in_addr_t             inaddr;
    ngx_int_t             n;
    ngx_uint_t            ident;
    ngx_resolver_hdr_t   *query;
    struct sockaddr_in   *sin;
#if (NGX_HAVE_INET6)
    struct sockaddr_in6  *sin6;
#endif

    switch (addr->sockaddr->sa_family) {

#if (NGX_HAVE_INET6)
    case AF_INET6:
        len = sizeof(ngx_resolver_hdr_t)
              + 64 + sizeof("".ip6.arpa."") - 1
              + sizeof(ngx_resolver_qs_t);

        break;
#endif

    default: /* AF_INET */
        len = sizeof(ngx_resolver_hdr_t)
              + sizeof("".255.255.255.255.in-addr.arpa."") - 1
              + sizeof(ngx_resolver_qs_t);
    }

    p = ngx_resolver_alloc(r, len);
    if (p == NULL) {
        return NGX_ERROR;
    }

    rn->query = p;
    query = (ngx_resolver_hdr_t *) p;

    ident = ngx_random()...",1,1,core\ngx_resolver.c,ngx_resolver_create_addr_query,,false,3825,3918,ngx_resolver_create_addr_query,,,79,"ngx_int_t ngx_resolver_create_addr_query (ngx_resolver_t*,ngx_resolver_node_t*,ngx_resolver_addr_t*)"
50348,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_resolver_copy(ngx_resolver_t *r, ngx_str_t *name, u_char *buf, u_char *src,
    u_char *last)
{
    char        *err;
    u_char      *p, *dst;
    ssize_t      len;
    ngx_uint_t   i, n;

    p = src;
    len = -1;

    /*
     * compression pointers allow to create endless loop, so we set limit;
     * 128 pointers should be enough to store 255-byte name
     */

    for (i = 0; i < 128; i++) {
        n = *p++;

        if (n == 0) {
            goto done;
        }

        if (n & 0xc0) {
            n = ((n & 0x3f) << 8) + *p;
            p = &buf[n];

        } else {
            len += 1 + n;
            p = &p[n];
        }

        if (p >= last) {
            err = ""name is out of response"";
            goto invalid;
        }
    }

    err = ""compression pointers loop"";

invalid:

    ngx_log_error(r->log_level, r->log, 0, err);

    return NGX_ERROR;

done:

    if (name == NULL) {
        return NGX_OK;
    }

    if (len == -1) {
        ngx_str...",1,1,core\ngx_resolver.c,ngx_resolver_copy,,false,3921,4012,ngx_resolver_copy,,,80,"ngx_int_t ngx_resolver_copy (ngx_resolver_t*,ngx_str_t*,u_char*,u_char*,u_char*)"
50562,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_resolver_set_timeout(ngx_resolver_t *r, ngx_resolver_ctx_t *ctx)
{
    if (ctx->event || ctx->timeout == 0) {
        return NGX_OK;
    }

    ctx->event = ngx_resolver_calloc(r, sizeof(ngx_event_t));
    if (ctx->event == NULL) {
        return NGX_ERROR;
    }

    ctx->event->handler = ngx_resolver_timeout_handler;
    ctx->event->data = ctx;
    ctx->event->log = r->log;
    ctx->event->cancelable = ctx->cancelable;
    ctx->ident = -1;

    ngx_add_timer(ctx->event, ctx->timeout);

    return NGX_OK;
}",1,1,core\ngx_resolver.c,ngx_resolver_set_timeout,,false,4015,4036,ngx_resolver_set_timeout,,,81,"ngx_int_t ngx_resolver_set_timeout (ngx_resolver_t*,ngx_resolver_ctx_t*)"
50645,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static void
ngx_resolver_timeout_handler(ngx_event_t *ev)
{
    ngx_resolver_ctx_t  *ctx;

    ctx = ev->data;

    ctx->state = NGX_RESOLVE_TIMEDOUT;

    ctx->handler(ctx);
}",1,1,core\ngx_resolver.c,ngx_resolver_timeout_handler,,false,4039,4049,ngx_resolver_timeout_handler,,,82,void ngx_resolver_timeout_handler (ngx_event_t*)
50666,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static void
ngx_resolver_free_node(ngx_resolver_t *r, ngx_resolver_node_t *rn)
{
    ngx_uint_t  i;

    /* lock alloc mutex */

    if (rn->query) {
        ngx_resolver_free_locked(r, rn->query);
    }

    if (rn->name) {
        ngx_resolver_free_locked(r, rn->name);
    }

    if (rn->cnlen) {
        ngx_resolver_free_locked(r, rn->u.cname);
    }

    if (rn->naddrs > 1 && rn->naddrs != (u_short) -1) {
        ngx_resolver_free_locked(r, rn->u.addrs);
    }

#if (NGX_HAVE_INET6)
    if (rn->naddrs6 > 1 && rn->naddrs6 != (u_short) -1) {
        ngx_resolver_free_locked(r, rn->u6.addrs6);
    }
#endif

    if (rn->nsrvs) {
        for (i = 0; i < (ngx_uint_t) rn->nsrvs; i++) {
            if (rn->u.srvs[i].name.data) {
                ngx_resolver_free_locked(r, rn->u.srvs[i].name.data);
            }
        }

        ngx_resolver_free_locked(r, rn->u.srvs);
    }

    ngx_resolver_free_locked(r, rn);

    /* unlock alloc mutex */
}",1,1,core\ngx_resolver.c,ngx_resolver_free_node,,false,4052,4094,ngx_resolver_free_node,,,83,"void ngx_resolver_free_node (ngx_resolver_t*,ngx_resolver_node_t*)"
50783,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static void *
ngx_resolver_alloc(ngx_resolver_t *r, size_t size)
{
    u_char  *p;

    /* lock alloc mutex */

    p = ngx_alloc(size, r->log);

    /* unlock alloc mutex */

    return p;
}",1,1,core\ngx_resolver.c,ngx_resolver_alloc,,false,4097,4109,ngx_resolver_alloc,,,84,"void* ngx_resolver_alloc (ngx_resolver_t*,size_t)"
50799,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static void *
ngx_resolver_calloc(ngx_resolver_t *r, size_t size)
{
    u_char  *p;

    p = ngx_resolver_alloc(r, size);

    if (p) {
        ngx_memzero(p, size);
    }

    return p;
}",1,1,core\ngx_resolver.c,ngx_resolver_calloc,,false,4112,4124,ngx_resolver_calloc,,,85,"void* ngx_resolver_calloc (ngx_resolver_t*,size_t)"
50819,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static void
ngx_resolver_free(ngx_resolver_t *r, void *p)
{
    /* lock alloc mutex */

    ngx_free(p);

    /* unlock alloc mutex */
}",1,1,core\ngx_resolver.c,ngx_resolver_free,,false,4127,4135,ngx_resolver_free,,,86,"void ngx_resolver_free (ngx_resolver_t*,void*)"
50827,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static void
ngx_resolver_free_locked(ngx_resolver_t *r, void *p)
{
    ngx_free(p);
}",1,1,core\ngx_resolver.c,ngx_resolver_free_locked,,false,4138,4142,ngx_resolver_free_locked,,,87,"void ngx_resolver_free_locked (ngx_resolver_t*,void*)"
50835,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static void *
ngx_resolver_dup(ngx_resolver_t *r, void *src, size_t size)
{
    void  *dst;

    dst = ngx_resolver_alloc(r, size);

    if (dst == NULL) {
        return dst;
    }

    ngx_memcpy(dst, src, size);

    return dst;
}",1,1,core\ngx_resolver.c,ngx_resolver_dup,,false,4145,4159,ngx_resolver_dup,,,88,"void* ngx_resolver_dup (ngx_resolver_t*,void*,size_t)"
50861,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static ngx_resolver_addr_t *
ngx_resolver_export(ngx_resolver_t *r, ngx_resolver_node_t *rn,
    ngx_uint_t rotate)
{
    ngx_uint_t            d, i, j, n;
    in_addr_t            *addr;
    ngx_sockaddr_t       *sockaddr;
    struct sockaddr_in   *sin;
    ngx_resolver_addr_t  *dst;
#if (NGX_HAVE_INET6)
    struct in6_addr      *addr6;
    struct sockaddr_in6  *sin6;
#endif

    n = rn->naddrs;
#if (NGX_HAVE_INET6)
    n += rn->naddrs6;
#endif

    dst = ngx_resolver_calloc(r, n * sizeof(ngx_resolver_addr_t));
    if (dst == NULL) {
        return NULL;
    }

    sockaddr = ngx_resolver_calloc(r, n * sizeof(ngx_sockaddr_t));
    if (sockaddr == NULL) {
        ngx_resolver_free(r, dst);
        return NULL;
    }

    i = 0;
    d = rotate ? ngx_random() % n : 0;

    if (rn->naddrs) {
        j = rotate ? ngx_random() % rn->naddrs : 0;

        addr = (rn->naddrs == 1) ? &rn->u.addr : rn->u.addrs;

        do {
            sin = &sockaddr[d].sockaddr_in;
            sin->sin_fam...",1,1,core\ngx_resolver.c,ngx_resolver_export,,false,4162,4242,ngx_resolver_export,,,89,"ngx_resolver_addr_t ngx_resolver_export (ngx_resolver_t*,ngx_resolver_node_t*,ngx_uint_t)"
51032,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static void
ngx_resolver_report_srv(ngx_resolver_t *r, ngx_resolver_ctx_t *ctx)
{
    ngx_uint_t                naddrs, nsrvs, nw, i, j, k, l, m, n, w;
    ngx_resolver_addr_t      *addrs;
    ngx_resolver_srv_name_t  *srvs;

    srvs = ctx->srvs;
    nsrvs = ctx->nsrvs;

    naddrs = 0;

    for (i = 0; i < nsrvs; i++) {
        if (srvs[i].state == NGX_ERROR) {
            ctx->state = NGX_ERROR;
            ctx->valid = ngx_time() + (r->valid ? r->valid : 10);

            ctx->handler(ctx);
            return;
        }

        naddrs += srvs[i].naddrs;
    }

    if (naddrs == 0) {
        ctx->state = srvs[0].state;

        for (i = 0; i < nsrvs; i++) {
            if (srvs[i].state == NGX_RESOLVE_NXDOMAIN) {
                ctx->state = NGX_RESOLVE_NXDOMAIN;
                break;
            }
        }

        ctx->valid = ngx_time() + (r->valid ? r->valid : 10);

        ctx->handler(ctx);
        return;
    }

    addrs = ngx_resolver_calloc(r, naddrs * sizeof(ngx_res...",1,1,core\ngx_resolver.c,ngx_resolver_report_srv,,false,4245,4351,ngx_resolver_report_srv,,,90,"void ngx_resolver_report_srv (ngx_resolver_t*,ngx_resolver_ctx_t*)"
51445,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"char *
ngx_resolver_strerror(ngx_int_t err)
{
    static char *errors[] = {
        ""Format error"",     /* FORMERR */
        ""Server failure"",   /* SERVFAIL */
        ""Host not found"",   /* NXDOMAIN */
        ""Unimplemented"",    /* NOTIMP */
        ""Operation refused"" /* REFUSED */
    };

    if (err > 0 && err < 6) {
        return errors[err - 1];
    }

    if (err == NGX_RESOLVE_TIMEDOUT) {
        return ""Operation timed out"";
    }

    return ""Unknown error"";
}",1,1,core\ngx_resolver.c,ngx_resolver_strerror,,false,4354,4374,ngx_resolver_strerror,,,91,char* ngx_resolver_strerror (ngx_int_t)
51483,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static u_char *
ngx_resolver_log_error(ngx_log_t *log, u_char *buf, size_t len)
{
    u_char                     *p;
    ngx_resolver_connection_t  *rec;

    p = buf;

    if (log->action) {
        p = ngx_snprintf(buf, len, "" while %s"", log->action);
        len -= p - buf;
    }

    rec = log->data;

    if (rec) {
        p = ngx_snprintf(p, len, "", resolver: %V"", &rec->server);
    }

    return p;
}",1,1,core\ngx_resolver.c,ngx_resolver_log_error,,false,4377,4397,ngx_resolver_log_error,,,92,"u_char ngx_resolver_log_error (ngx_log_t*,u_char*,size_t)"
51534,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_udp_connect(ngx_resolver_connection_t *rec)
{
    int                rc;
    ngx_int_t          event;
    ngx_event_t       *rev, *wev;
    ngx_socket_t       s;
    ngx_connection_t  *c;

    s = ngx_socket(rec->sockaddr->sa_family, SOCK_DGRAM, 0);

    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, &rec->log, 0, ""UDP socket %d"", s);

    if (s == (ngx_socket_t) -1) {
        ngx_log_error(NGX_LOG_ALERT, &rec->log, ngx_socket_errno,
                      ngx_socket_n "" failed"");
        return NGX_ERROR;
    }

    c = ngx_get_connection(s, &rec->log);

    if (c == NULL) {
        if (ngx_close_socket(s) == -1) {
            ngx_log_error(NGX_LOG_ALERT, &rec->log, ngx_socket_errno,
                          ngx_close_socket_n "" failed"");
        }

        return NGX_ERROR;
    }

    if (ngx_nonblocking(s) == -1) {
        ngx_log_error(NGX_LOG_ALERT, &rec->log, ngx_socket_errno,
                      ngx_nonblocking_n "" failed"");

        goto failed;
    }

    rev =...",1,1,core\ngx_resolver.c,ngx_udp_connect,,false,4400,4481,ngx_udp_connect,,,93,ngx_int_t ngx_udp_connect (ngx_resolver_connection_t*)
51719,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_tcp_connect(ngx_resolver_connection_t *rec)
{
    int                rc;
    ngx_int_t          event;
    ngx_err_t          err;
    ngx_uint_t         level;
    ngx_socket_t       s;
    ngx_event_t       *rev, *wev;
    ngx_connection_t  *c;

    s = ngx_socket(rec->sockaddr->sa_family, SOCK_STREAM, 0);

    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, &rec->log, 0, ""TCP socket %d"", s);

    if (s == (ngx_socket_t) -1) {
        ngx_log_error(NGX_LOG_ALERT, &rec->log, ngx_socket_errno,
                      ngx_socket_n "" failed"");
        return NGX_ERROR;
    }

    c = ngx_get_connection(s, &rec->log);

    if (c == NULL) {
        if (ngx_close_socket(s) == -1) {
            ngx_log_error(NGX_LOG_ALERT, &rec->log, ngx_socket_errno,
                          ngx_close_socket_n "" failed"");
        }

        return NGX_ERROR;
    }

    if (ngx_nonblocking(s) == -1) {
        ngx_log_error(NGX_LOG_ALERT, &rec->log, ngx_socket_errno,
                      ngx_nonbl...",1,1,core\ngx_resolver.c,ngx_tcp_connect,,false,4484,4664,ngx_tcp_connect,,,94,ngx_int_t ngx_tcp_connect (ngx_resolver_connection_t*)
52060,METHOD,core\ngx_resolver.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_resolver_cmp_srvs(const void *one, const void *two)
{
    ngx_int_t            p1, p2;
    ngx_resolver_srv_t  *first, *second;

    first = (ngx_resolver_srv_t *) one;
    second = (ngx_resolver_srv_t *) two;

    p1 = first->priority;
    p2 = second->priority;

    return p1 - p2;
}",1,1,core\ngx_resolver.c,ngx_resolver_cmp_srvs,,false,4667,4680,ngx_resolver_cmp_srvs,,,95,"ngx_int_t ngx_resolver_cmp_srvs (void*,void*)"
52101,METHOD,core\ngx_resolver.h:<global>,TYPE_DECL,<global>,1,38,core\ngx_resolver.h,core\ngx_resolver.h:<global>,,false,1,240,<global>,,,1,
52119,METHOD,core\ngx_resolver.h:<global>,TYPE_DECL,typedef void (*ngx_resolver_handler_pt)(ngx_resolver_ctx_t *ctx);,14,64,core\ngx_resolver.h,ngx_resolver_handler_pt,,false,58,58,ngx_resolver_handler_pt,,,7,void ngx_resolver_handler_pt (ngx_resolver_ctx_t*)
52237,METHOD,core\ngx_resolver.h:<global>,TYPE_DECL,"ngx_resolver_t *ngx_resolver_create(ngx_conf_t *cf, ngx_str_t *names,
    ngx_uint_t n);",16,17,core\ngx_resolver.h,ngx_resolver_create,,false,229,230,ngx_resolver_create,,,18,"ngx_resolver_t* ngx_resolver_create (ngx_conf_t*,ngx_str_t*,ngx_uint_t)"
52244,METHOD,core\ngx_resolver.h:<global>,TYPE_DECL,"ngx_resolver_ctx_t *ngx_resolve_start(ngx_resolver_t *r,
    ngx_resolver_ctx_t *temp);",20,29,core\ngx_resolver.h,ngx_resolve_start,,false,231,232,ngx_resolve_start,,,19,"ngx_resolver_ctx_t* ngx_resolve_start (ngx_resolver_t*,ngx_resolver_ctx_t*)"
52250,METHOD,core\ngx_resolver.h:<global>,TYPE_DECL,ngx_int_t ngx_resolve_name(ngx_resolver_ctx_t *ctx);,11,51,core\ngx_resolver.h,ngx_resolve_name,,false,233,233,ngx_resolve_name,,,20,ngx_int_t ngx_resolve_name (ngx_resolver_ctx_t*)
52255,METHOD,core\ngx_resolver.h:<global>,TYPE_DECL,void ngx_resolve_name_done(ngx_resolver_ctx_t *ctx);,6,51,core\ngx_resolver.h,ngx_resolve_name_done,,false,234,234,ngx_resolve_name_done,,,21,void ngx_resolve_name_done (ngx_resolver_ctx_t*)
52260,METHOD,core\ngx_resolver.h:<global>,TYPE_DECL,ngx_int_t ngx_resolve_addr(ngx_resolver_ctx_t *ctx);,11,51,core\ngx_resolver.h,ngx_resolve_addr,,false,235,235,ngx_resolve_addr,,,22,ngx_int_t ngx_resolve_addr (ngx_resolver_ctx_t*)
52265,METHOD,core\ngx_resolver.h:<global>,TYPE_DECL,void ngx_resolve_addr_done(ngx_resolver_ctx_t *ctx);,6,51,core\ngx_resolver.h,ngx_resolve_addr_done,,false,236,236,ngx_resolve_addr_done,,,23,void ngx_resolve_addr_done (ngx_resolver_ctx_t*)
52270,METHOD,core\ngx_resolver.h:<global>,TYPE_DECL,char *ngx_resolver_strerror(ngx_int_t err);,6,42,core\ngx_resolver.h,ngx_resolver_strerror,,false,237,237,ngx_resolver_strerror,,,24,char* ngx_resolver_strerror (ngx_int_t)
52282,METHOD,core\ngx_rwlock.c:<global>,TYPE_DECL,<global>,1,6,core\ngx_rwlock.c,core\ngx_rwlock.c:<global>,,false,1,129,<global>,,,1,
52291,METHOD,core\ngx_rwlock.h:<global>,TYPE_DECL,<global>,1,36,core\ngx_rwlock.h,core\ngx_rwlock.h:<global>,,false,1,22,<global>,,,1,
52293,METHOD,core\ngx_rwlock.h:<global>,TYPE_DECL,void ngx_rwlock_wlock(ngx_atomic_t *lock);,6,41,core\ngx_rwlock.h,ngx_rwlock_wlock,,false,16,16,ngx_rwlock_wlock,,,1,void ngx_rwlock_wlock (ngx_atomic_t*)
52298,METHOD,core\ngx_rwlock.h:<global>,TYPE_DECL,void ngx_rwlock_rlock(ngx_atomic_t *lock);,6,41,core\ngx_rwlock.h,ngx_rwlock_rlock,,false,17,17,ngx_rwlock_rlock,,,2,void ngx_rwlock_rlock (ngx_atomic_t*)
52303,METHOD,core\ngx_rwlock.h:<global>,TYPE_DECL,void ngx_rwlock_unlock(ngx_atomic_t *lock);,6,42,core\ngx_rwlock.h,ngx_rwlock_unlock,,false,18,18,ngx_rwlock_unlock,,,3,void ngx_rwlock_unlock (ngx_atomic_t*)
52308,METHOD,core\ngx_rwlock.h:<global>,TYPE_DECL,void ngx_rwlock_downgrade(ngx_atomic_t *lock);,6,45,core\ngx_rwlock.h,ngx_rwlock_downgrade,,false,19,19,ngx_rwlock_downgrade,,,4,void ngx_rwlock_downgrade (ngx_atomic_t*)
52322,METHOD,core\ngx_sha1.c:<global>,TYPE_DECL,<global>,1,23,core\ngx_sha1.c,core\ngx_sha1.c:<global>,,false,1,294,<global>,,,1,
52324,METHOD,core\ngx_sha1.c:<global>,TYPE_DECL,"static const u_char *ngx_sha1_body(ngx_sha1_t *ctx, const u_char *data,
    size_t size);",21,16,core\ngx_sha1.c,ngx_sha1_body,,false,15,16,ngx_sha1_body,,,1,"u_char* ngx_sha1_body (ngx_sha1_t*,u_char*,size_t)"
52331,METHOD,core\ngx_sha1.c:<global>,TYPE_DECL,"void
ngx_sha1_init(ngx_sha1_t *ctx)
{
    ctx->a = 0x67452301;
    ctx->b = 0xefcdab89;
    ctx->c = 0x98badcfe;
    ctx->d = 0x10325476;
    ctx->e = 0xc3d2e1f0;

    ctx->bytes = 0;
}",1,1,core\ngx_sha1.c,ngx_sha1_init,,false,19,29,ngx_sha1_init,,,2,void ngx_sha1_init (ngx_sha1_t*)
52366,METHOD,core\ngx_sha1.c:<global>,TYPE_DECL,"void
ngx_sha1_update(ngx_sha1_t *ctx, const void *data, size_t size)
{
    size_t  used, free;

    used = (size_t) (ctx->bytes & 0x3f);
    ctx->bytes += size;

    if (used) {
        free = 64 - used;

        if (size < free) {
            ngx_memcpy(&ctx->buffer[used], data, size);
            return;
        }

        ngx_memcpy(&ctx->buffer[used], data, free);
        data = (u_char *) data + free;
        size -= free;
        (void) ngx_sha1_body(ctx, ctx->buffer, 64);
    }

    if (size >= 64) {
        data = ngx_sha1_body(ctx, data, size & ~(size_t) 0x3f);
        size &= 0x3f;
    }

    ngx_memcpy(ctx->buffer, data, size);
}",1,1,core\ngx_sha1.c,ngx_sha1_update,,false,32,60,ngx_sha1_update,,,3,"void ngx_sha1_update (ngx_sha1_t*,void*,size_t)"
52463,METHOD,core\ngx_sha1.c:<global>,TYPE_DECL,"void
ngx_sha1_final(u_char result[20], ngx_sha1_t *ctx)
{
    size_t  used, free;

    used = (size_t) (ctx->bytes & 0x3f);

    ctx->buffer[used++] = 0x80;

    free = 64 - used;

    if (free < 8) {
        ngx_memzero(&ctx->buffer[used], free);
        (void) ngx_sha1_body(ctx, ctx->buffer, 64);
        used = 0;
        free = 64;
    }

    ngx_memzero(&ctx->buffer[used], free - 8);

    ctx->bytes <<= 3;
    ctx->buffer[56] = (u_char) (ctx->bytes >> 56);
    ctx->buffer[57] = (u_char) (ctx->bytes >> 48);
    ctx->buffer[58] = (u_char) (ctx->bytes >> 40);
    ctx->buffer[59] = (u_char) (ctx->bytes >> 32);
    ctx->buffer[60] = (u_char) (ctx->bytes >> 24);
    ctx->buffer[61] = (u_char) (ctx->bytes >> 16);
    ctx->buffer[62] = (u_char) (ctx->bytes >> 8);
    ctx->buffer[63] = (u_char) ctx->bytes;

    (void) ngx_sha1_body(ctx, ctx->buffer, 64);

    result[0] = (u_char) (ctx->a >> 24);
    result[1] = (u_char) (ctx->a >> 16);
    result[2] = (u_char) (ctx->a >> 8);
    result[3...",1,1,core\ngx_sha1.c,ngx_sha1_final,,false,63,117,ngx_sha1_final,,,4,"void ngx_sha1_final (u_char[20],ngx_sha1_t*)"
52837,METHOD,core\ngx_sha1.c:<global>,TYPE_DECL,"static const u_char *
ngx_sha1_body(ngx_sha1_t *ctx, const u_char *data, size_t size)
{
    uint32_t       a, b, c, d, e, temp;
    uint32_t       saved_a, saved_b, saved_c, saved_d, saved_e;
    uint32_t       words[80];
    ngx_uint_t     i;
    const u_char  *p;

    p = data;

    a = ctx->a;
    b = ctx->b;
    c = ctx->c;
    d = ctx->d;
    e = ctx->e;

    do {
        saved_a = a;
        saved_b = b;
        saved_c = c;
        saved_d = d;
        saved_e = e;

        /* Load data block into the words array */

        for (i = 0; i < 16; i++) {
            words[i] = GET(i);
        }

        for (i = 16; i < 80; i++) {
            words[i] = ROTATE(1, words[i - 3] ^ words[i - 8] ^ words[i - 14]
                                 ^ words[i - 16]);
        }

        /* Transformations */

        STEP(F1, a, b, c, d, e, words[0],  0x5a827999);
        STEP(F1, a, b, c, d, e, words[1],  0x5a827999);
        STEP(F1, a, b, c, d, e, words[2],  0x5a827999);
        STEP(F1,...",1,23,core\ngx_sha1.c,ngx_sha1_body,,false,156,294,ngx_sha1_body,,,5,"u_char ngx_sha1_body (ngx_sha1_t*,u_char*,size_t)"
57990,METHOD,core\ngx_sha1.h:<global>,TYPE_DECL,<global>,1,34,core\ngx_sha1.h,core\ngx_sha1.h:<global>,,false,1,28,<global>,,,1,
58001,METHOD,<empty>,<empty>,<empty>,1,,core\ngx_sha1.h,ngx_sha1_t:<clinit>,,false,16,,<clinit>,,,9,
58008,METHOD,core\ngx_sha1.h:<global>,TYPE_DECL,void ngx_sha1_init(ngx_sha1_t *ctx);,6,35,core\ngx_sha1.h,ngx_sha1_init,,false,23,23,ngx_sha1_init,,,3,void ngx_sha1_init (ngx_sha1_t*)
58013,METHOD,core\ngx_sha1.h:<global>,TYPE_DECL,"void ngx_sha1_update(ngx_sha1_t *ctx, const void *data, size_t size);",6,68,core\ngx_sha1.h,ngx_sha1_update,,false,24,24,ngx_sha1_update,,,4,"void ngx_sha1_update (ngx_sha1_t*,void*,size_t)"
58020,METHOD,core\ngx_sha1.h:<global>,TYPE_DECL,"void ngx_sha1_final(u_char result[20], ngx_sha1_t *ctx);",6,55,core\ngx_sha1.h,ngx_sha1_final,,false,25,25,ngx_sha1_final,,,5,"void ngx_sha1_final (u_char[20],ngx_sha1_t*)"
58033,METHOD,core\ngx_shmtx.c:<global>,TYPE_DECL,<global>,1,6,core\ngx_shmtx.c,core\ngx_shmtx.c:<global>,,false,1,310,<global>,,,1,
58035,METHOD,core\ngx_shmtx.c:<global>,TYPE_DECL,"ngx_int_t
ngx_shmtx_create(ngx_shmtx_t *mtx, ngx_shmtx_sh_t *addr, u_char *name)
{
    if (mtx->name) {

        if (ngx_strcmp(name, mtx->name) == 0) {
            mtx->name = name;
            return NGX_OK;
        }

        ngx_shmtx_destroy(mtx);
    }

    mtx->fd = ngx_open_file(name, NGX_FILE_RDWR, NGX_FILE_CREATE_OR_OPEN,
                            NGX_FILE_DEFAULT_ACCESS);

    if (mtx->fd == NGX_INVALID_FILE) {
        ngx_log_error(NGX_LOG_EMERG, ngx_cycle->log, ngx_errno,
                      ngx_open_file_n "" \""%s\"" failed"", name);
        return NGX_ERROR;
    }

    if (ngx_delete_file(name) == NGX_FILE_ERROR) {
        ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, ngx_errno,
                      ngx_delete_file_n "" \""%s\"" failed"", name);
    }

    mtx->name = name;

    return NGX_OK;
}",1,1,core\ngx_shmtx.c,ngx_shmtx_create,,false,202,232,ngx_shmtx_create,,,1,"ngx_int_t ngx_shmtx_create (ngx_shmtx_t*,ngx_shmtx_sh_t*,u_char*)"
58098,METHOD,core\ngx_shmtx.c:<global>,TYPE_DECL,"void
ngx_shmtx_destroy(ngx_shmtx_t *mtx)
{
    if (ngx_close_file(mtx->fd) == NGX_FILE_ERROR) {
        ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, ngx_errno,
                      ngx_close_file_n "" \""%s\"" failed"", mtx->name);
    }
}",1,1,core\ngx_shmtx.c,ngx_shmtx_destroy,,false,235,242,ngx_shmtx_destroy,,,2,void ngx_shmtx_destroy (ngx_shmtx_t*)
58112,METHOD,core\ngx_shmtx.c:<global>,TYPE_DECL,"ngx_uint_t
ngx_shmtx_trylock(ngx_shmtx_t *mtx)
{
    ngx_err_t  err;

    err = ngx_trylock_fd(mtx->fd);

    if (err == 0) {
        return 1;
    }

    if (err == NGX_EAGAIN) {
        return 0;
    }

#if __osf__ /* Tru64 UNIX */

    if (err == NGX_EACCES) {
        return 0;
    }

#endif

    ngx_log_abort(err, ngx_trylock_fd_n "" %s failed"", mtx->name);

    return 0;
}",1,1,core\ngx_shmtx.c,ngx_shmtx_trylock,,false,245,271,ngx_shmtx_trylock,,,3,ngx_uint_t ngx_shmtx_trylock (ngx_shmtx_t*)
58141,METHOD,core\ngx_shmtx.c:<global>,TYPE_DECL,"void
ngx_shmtx_lock(ngx_shmtx_t *mtx)
{
    ngx_err_t  err;

    err = ngx_lock_fd(mtx->fd);

    if (err == 0) {
        return;
    }

    ngx_log_abort(err, ngx_lock_fd_n "" %s failed"", mtx->name);
}",1,1,core\ngx_shmtx.c,ngx_shmtx_lock,,false,274,286,ngx_shmtx_lock,,,4,void ngx_shmtx_lock (ngx_shmtx_t*)
58160,METHOD,core\ngx_shmtx.c:<global>,TYPE_DECL,"void
ngx_shmtx_unlock(ngx_shmtx_t *mtx)
{
    ngx_err_t  err;

    err = ngx_unlock_fd(mtx->fd);

    if (err == 0) {
        return;
    }

    ngx_log_abort(err, ngx_unlock_fd_n "" %s failed"", mtx->name);
}",1,1,core\ngx_shmtx.c,ngx_shmtx_unlock,,false,289,301,ngx_shmtx_unlock,,,5,void ngx_shmtx_unlock (ngx_shmtx_t*)
58179,METHOD,core\ngx_shmtx.c:<global>,TYPE_DECL,"ngx_uint_t
ngx_shmtx_force_unlock(ngx_shmtx_t *mtx, ngx_pid_t pid)
{
    return 0;
}",1,1,core\ngx_shmtx.c,ngx_shmtx_force_unlock,,false,304,308,ngx_shmtx_force_unlock,,,6,"ngx_uint_t ngx_shmtx_force_unlock (ngx_shmtx_t*,ngx_pid_t)"
58194,METHOD,core\ngx_shmtx.h:<global>,TYPE_DECL,<global>,1,35,core\ngx_shmtx.h,core\ngx_shmtx.h:<global>,,false,1,49,<global>,,,1,
58209,METHOD,core\ngx_shmtx.h:<global>,TYPE_DECL,"ngx_int_t ngx_shmtx_create(ngx_shmtx_t *mtx, ngx_shmtx_sh_t *addr,
    u_char *name);",11,17,core\ngx_shmtx.h,ngx_shmtx_create,,false,40,41,ngx_shmtx_create,,,5,"ngx_int_t ngx_shmtx_create (ngx_shmtx_t*,ngx_shmtx_sh_t*,u_char*)"
58216,METHOD,core\ngx_shmtx.h:<global>,TYPE_DECL,void ngx_shmtx_destroy(ngx_shmtx_t *mtx);,6,40,core\ngx_shmtx.h,ngx_shmtx_destroy,,false,42,42,ngx_shmtx_destroy,,,6,void ngx_shmtx_destroy (ngx_shmtx_t*)
58221,METHOD,core\ngx_shmtx.h:<global>,TYPE_DECL,ngx_uint_t ngx_shmtx_trylock(ngx_shmtx_t *mtx);,12,46,core\ngx_shmtx.h,ngx_shmtx_trylock,,false,43,43,ngx_shmtx_trylock,,,7,ngx_uint_t ngx_shmtx_trylock (ngx_shmtx_t*)
58226,METHOD,core\ngx_shmtx.h:<global>,TYPE_DECL,void ngx_shmtx_lock(ngx_shmtx_t *mtx);,6,37,core\ngx_shmtx.h,ngx_shmtx_lock,,false,44,44,ngx_shmtx_lock,,,8,void ngx_shmtx_lock (ngx_shmtx_t*)
58231,METHOD,core\ngx_shmtx.h:<global>,TYPE_DECL,void ngx_shmtx_unlock(ngx_shmtx_t *mtx);,6,39,core\ngx_shmtx.h,ngx_shmtx_unlock,,false,45,45,ngx_shmtx_unlock,,,9,void ngx_shmtx_unlock (ngx_shmtx_t*)
58236,METHOD,core\ngx_shmtx.h:<global>,TYPE_DECL,"ngx_uint_t ngx_shmtx_force_unlock(ngx_shmtx_t *mtx, ngx_pid_t pid);",12,66,core\ngx_shmtx.h,ngx_shmtx_force_unlock,,false,46,46,ngx_shmtx_force_unlock,,,10,"ngx_uint_t ngx_shmtx_force_unlock (ngx_shmtx_t*,ngx_pid_t)"
58249,METHOD,core\ngx_slab.c:<global>,TYPE_DECL,<global>,1,12,core\ngx_slab.c,core\ngx_slab.c:<global>,,false,1,817,<global>,,,1,
58251,METHOD,core\ngx_slab.c:<global>,TYPE_DECL,"static ngx_slab_page_t *ngx_slab_alloc_pages(ngx_slab_pool_t *pool,
    ngx_uint_t pages);",24,21,core\ngx_slab.c,ngx_slab_alloc_pages,,false,72,73,ngx_slab_alloc_pages,,,1,"ngx_slab_page_t* ngx_slab_alloc_pages (ngx_slab_pool_t*,ngx_uint_t)"
58257,METHOD,core\ngx_slab.c:<global>,TYPE_DECL,"static void ngx_slab_free_pages(ngx_slab_pool_t *pool, ngx_slab_page_t *page,
    ngx_uint_t pages);",13,21,core\ngx_slab.c,ngx_slab_free_pages,,false,74,75,ngx_slab_free_pages,,,2,"void ngx_slab_free_pages (ngx_slab_pool_t*,ngx_slab_page_t*,ngx_uint_t)"
58264,METHOD,core\ngx_slab.c:<global>,TYPE_DECL,"static void ngx_slab_error(ngx_slab_pool_t *pool, ngx_uint_t level,
    char *text);",13,15,core\ngx_slab.c,ngx_slab_error,,false,76,77,ngx_slab_error,,,3,"void ngx_slab_error (ngx_slab_pool_t*,ngx_uint_t,char*)"
58274,METHOD,core\ngx_slab.c:<global>,TYPE_DECL,"void
ngx_slab_sizes_init(void)
{
    ngx_uint_t  n;

    ngx_slab_max_size = ngx_pagesize / 2;
    ngx_slab_exact_size = ngx_pagesize / (8 * sizeof(uintptr_t));
    for (n = ngx_slab_exact_size; n >>= 1; ngx_slab_exact_shift++) {
        /* void */
    }
}",1,1,core\ngx_slab.c,ngx_slab_sizes_init,,false,85,95,ngx_slab_sizes_init,,,7,void ngx_slab_sizes_init (void)
58304,METHOD,core\ngx_slab.c:<global>,TYPE_DECL,"void
ngx_slab_init(ngx_slab_pool_t *pool)
{
    u_char           *p;
    size_t            size;
    ngx_int_t         m;
    ngx_uint_t        i, n, pages;
    ngx_slab_page_t  *slots, *page;

    pool->min_size = (size_t) 1 << pool->min_shift;

    slots = ngx_slab_slots(pool);

    p = (u_char *) slots;
    size = pool->end - p;

    ngx_slab_junk(p, size);

    n = ngx_pagesize_shift - pool->min_shift;

    for (i = 0; i < n; i++) {
        /* only ""next"" is used in list head */
        slots[i].slab = 0;
        slots[i].next = &slots[i];
        slots[i].prev = 0;
    }

    p += n * sizeof(ngx_slab_page_t);

    pool->stats = (ngx_slab_stat_t *) p;
    ngx_memzero(pool->stats, n * sizeof(ngx_slab_stat_t));

    p += n * sizeof(ngx_slab_stat_t);

    size -= n * (sizeof(ngx_slab_page_t) + sizeof(ngx_slab_stat_t));

    pages = (ngx_uint_t) (size / (ngx_pagesize + sizeof(ngx_slab_page_t)));

    pool->pages = (ngx_slab_page_t *) p;
    ngx_memzero(pool->pages, pages * sizeof(ng...",1,12,core\ngx_slab.c,ngx_slab_init,,false,98,165,ngx_slab_init,,,8,void ngx_slab_init (ngx_slab_pool_t*)
58573,METHOD,core\ngx_slab.c:<global>,TYPE_DECL,"void *
ngx_slab_alloc(ngx_slab_pool_t *pool, size_t size)
{
    void  *p;

    ngx_shmtx_lock(&pool->mutex);

    p = ngx_slab_alloc_locked(pool, size);

    ngx_shmtx_unlock(&pool->mutex);

    return p;
}",1,1,core\ngx_slab.c,ngx_slab_alloc,,false,168,180,ngx_slab_alloc,,,9,"void* ngx_slab_alloc (ngx_slab_pool_t*,size_t)"
58597,METHOD,core\ngx_slab.c:<global>,TYPE_DECL,"void *
ngx_slab_alloc_locked(ngx_slab_pool_t *pool, size_t size)
{
    size_t            s;
    uintptr_t         p, m, mask, *bitmap;
    ngx_uint_t        i, n, slot, shift, map;
    ngx_slab_page_t  *page, *prev, *slots;

    if (size > ngx_slab_max_size) {

        ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, ngx_cycle->log, 0,
                       ""slab alloc: %uz"", size);

        page = ngx_slab_alloc_pages(pool, (size >> ngx_pagesize_shift)
                                          + ((size % ngx_pagesize) ? 1 : 0));
        if (page) {
            p = ngx_slab_page_addr(pool, page);

        } else {
            p = 0;
        }

        goto done;
    }

    if (size > pool->min_size) {
        shift = 1;
        for (s = size - 1; s >>= 1; shift++) { /* void */ }
        slot = shift - pool->min_shift;

    } else {
        shift = pool->min_shift;
        slot = 0;
    }

    pool->stats[slot].reqs++;

    ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, ngx_cycle->log, 0,
                 ...",1,16,core\ngx_slab.c,ngx_slab_alloc_locked,,false,183,417,ngx_slab_alloc_locked,,,10,"void* ngx_slab_alloc_locked (ngx_slab_pool_t*,size_t)"
59591,METHOD,core\ngx_slab.c:<global>,TYPE_DECL,"void *
ngx_slab_calloc(ngx_slab_pool_t *pool, size_t size)
{
    void  *p;

    ngx_shmtx_lock(&pool->mutex);

    p = ngx_slab_calloc_locked(pool, size);

    ngx_shmtx_unlock(&pool->mutex);

    return p;
}",1,1,core\ngx_slab.c,ngx_slab_calloc,,false,420,432,ngx_slab_calloc,,,11,"void* ngx_slab_calloc (ngx_slab_pool_t*,size_t)"
59615,METHOD,core\ngx_slab.c:<global>,TYPE_DECL,"void *
ngx_slab_calloc_locked(ngx_slab_pool_t *pool, size_t size)
{
    void  *p;

    p = ngx_slab_alloc_locked(pool, size);
    if (p) {
        ngx_memzero(p, size);
    }

    return p;
}",1,1,core\ngx_slab.c,ngx_slab_calloc_locked,,false,435,446,ngx_slab_calloc_locked,,,12,"void* ngx_slab_calloc_locked (ngx_slab_pool_t*,size_t)"
59635,METHOD,core\ngx_slab.c:<global>,TYPE_DECL,"void
ngx_slab_free(ngx_slab_pool_t *pool, void *p)
{
    ngx_shmtx_lock(&pool->mutex);

    ngx_slab_free_locked(pool, p);

    ngx_shmtx_unlock(&pool->mutex);
}",1,1,core\ngx_slab.c,ngx_slab_free,,false,449,457,ngx_slab_free,,,13,"void ngx_slab_free (ngx_slab_pool_t*,void*)"
59654,METHOD,core\ngx_slab.c:<global>,TYPE_DECL,"void
ngx_slab_free_locked(ngx_slab_pool_t *pool, void *p)
{
    size_t            size;
    uintptr_t         slab, m, *bitmap;
    ngx_uint_t        i, n, type, slot, shift, map;
    ngx_slab_page_t  *slots, *page;

    ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, ngx_cycle->log, 0, ""slab free: %p"", p);

    if ((u_char *) p < pool->start || (u_char *) p > pool->end) {
        ngx_slab_error(pool, NGX_LOG_ALERT, ""ngx_slab_free(): outside of pool"");
        goto fail;
    }

    n = ((u_char *) p - pool->start) >> ngx_pagesize_shift;
    page = &pool->pages[n];
    slab = page->slab;
    type = ngx_slab_page_type(page);

    switch (type) {

    case NGX_SLAB_SMALL:

        shift = slab & NGX_SLAB_SHIFT_MASK;
        size = (size_t) 1 << shift;

        if ((uintptr_t) p & (size - 1)) {
            goto wrong_chunk;
        }

        n = ((uintptr_t) p & (ngx_pagesize - 1)) >> shift;
        m = (uintptr_t) 1 << (n % (8 * sizeof(uintptr_t)));
        n /= 8 * sizeof(uintptr_t);
        bit...",1,11,core\ngx_slab.c,ngx_slab_free_locked,,false,460,674,ngx_slab_free_locked,,,14,"void ngx_slab_free_locked (ngx_slab_pool_t*,void*)"
60356,METHOD,core\ngx_slab.c:<global>,TYPE_DECL,"static ngx_slab_page_t *
ngx_slab_alloc_pages(ngx_slab_pool_t *pool, ngx_uint_t pages)
{
    ngx_slab_page_t  *page, *p;

    for (page = pool->free.next; page != &pool->free; page = page->next) {

        if (page->slab >= pages) {

            if (page->slab > pages) {
                page[page->slab - 1].prev = (uintptr_t) &page[pages];

                page[pages].slab = page->slab - pages;
                page[pages].next = page->next;
                page[pages].prev = page->prev;

                p = (ngx_slab_page_t *) page->prev;
                p->next = &page[pages];
                page->next->prev = (uintptr_t) &page[pages];

            } else {
                p = (ngx_slab_page_t *) page->prev;
                p->next = page->next;
                page->next->prev = page->prev;
            }

            page->slab = pages | NGX_SLAB_PAGE_START;
            page->next = NULL;
            page->prev = NGX_SLAB_PAGE;

            pool->pfree -= pages;

            if (...",1,33,core\ngx_slab.c,ngx_slab_alloc_pages,,false,677,730,ngx_slab_alloc_pages,,,15,"ngx_slab_page_t ngx_slab_alloc_pages (ngx_slab_pool_t*,ngx_uint_t)"
60573,METHOD,core\ngx_slab.c:<global>,TYPE_DECL,"static void
ngx_slab_free_pages(ngx_slab_pool_t *pool, ngx_slab_page_t *page,
    ngx_uint_t pages)
{
    ngx_slab_page_t  *prev, *join;

    pool->pfree += pages;

    page->slab = pages--;

    if (pages) {
        ngx_memzero(&page[1], pages * sizeof(ngx_slab_page_t));
    }

    if (page->next) {
        prev = ngx_slab_page_prev(page);
        prev->next = page->next;
        page->next->prev = page->prev;
    }

    join = page + page->slab;

    if (join < pool->last) {

        if (ngx_slab_page_type(join) == NGX_SLAB_PAGE) {

            if (join->next != NULL) {
                pages += join->slab;
                page->slab += join->slab;

                prev = ngx_slab_page_prev(join);
                prev->next = join->next;
                join->next->prev = join->prev;

                join->slab = NGX_SLAB_PAGE_FREE;
                join->next = NULL;
                join->prev = NGX_SLAB_PAGE;
            }
        }
    }

    if (page > pool->pages) {
        joi...",1,15,core\ngx_slab.c,ngx_slab_free_pages,,false,733,810,ngx_slab_free_pages,,,16,"void ngx_slab_free_pages (ngx_slab_pool_t*,ngx_slab_page_t*,ngx_uint_t)"
60898,METHOD,core\ngx_slab.c:<global>,TYPE_DECL,"static void
ngx_slab_error(ngx_slab_pool_t *pool, ngx_uint_t level, char *text)
{
    ngx_log_error(level, ngx_cycle->log, 0, ""%s%s"", text, pool->log_ctx);
}",1,1,core\ngx_slab.c,ngx_slab_error,,false,813,817,ngx_slab_error,,,17,"void ngx_slab_error (ngx_slab_pool_t*,ngx_uint_t,char*)"
60923,METHOD,core\ngx_slab.h:<global>,TYPE_DECL,<global>,1,34,core\ngx_slab.h,core\ngx_slab.h:<global>,,false,1,72,<global>,,,1,
60955,METHOD,core\ngx_slab.h:<global>,TYPE_DECL,void ngx_slab_sizes_init(void);,6,30,core\ngx_slab.h,ngx_slab_sizes_init,,false,62,62,ngx_slab_sizes_init,,,8,void ngx_slab_sizes_init (void)
60960,METHOD,core\ngx_slab.h:<global>,TYPE_DECL,void ngx_slab_init(ngx_slab_pool_t *pool);,6,41,core\ngx_slab.h,ngx_slab_init,,false,63,63,ngx_slab_init,,,9,void ngx_slab_init (ngx_slab_pool_t*)
60965,METHOD,core\ngx_slab.h:<global>,TYPE_DECL,"void *ngx_slab_alloc(ngx_slab_pool_t *pool, size_t size);",6,56,core\ngx_slab.h,ngx_slab_alloc,,false,64,64,ngx_slab_alloc,,,10,"void* ngx_slab_alloc (ngx_slab_pool_t*,size_t)"
60971,METHOD,core\ngx_slab.h:<global>,TYPE_DECL,"void *ngx_slab_alloc_locked(ngx_slab_pool_t *pool, size_t size);",6,63,core\ngx_slab.h,ngx_slab_alloc_locked,,false,65,65,ngx_slab_alloc_locked,,,11,"void* ngx_slab_alloc_locked (ngx_slab_pool_t*,size_t)"
60977,METHOD,core\ngx_slab.h:<global>,TYPE_DECL,"void *ngx_slab_calloc(ngx_slab_pool_t *pool, size_t size);",6,57,core\ngx_slab.h,ngx_slab_calloc,,false,66,66,ngx_slab_calloc,,,12,"void* ngx_slab_calloc (ngx_slab_pool_t*,size_t)"
60983,METHOD,core\ngx_slab.h:<global>,TYPE_DECL,"void *ngx_slab_calloc_locked(ngx_slab_pool_t *pool, size_t size);",6,64,core\ngx_slab.h,ngx_slab_calloc_locked,,false,67,67,ngx_slab_calloc_locked,,,13,"void* ngx_slab_calloc_locked (ngx_slab_pool_t*,size_t)"
60989,METHOD,core\ngx_slab.h:<global>,TYPE_DECL,"void ngx_slab_free(ngx_slab_pool_t *pool, void *p);",6,50,core\ngx_slab.h,ngx_slab_free,,false,68,68,ngx_slab_free,,,14,"void ngx_slab_free (ngx_slab_pool_t*,void*)"
60995,METHOD,core\ngx_slab.h:<global>,TYPE_DECL,"void ngx_slab_free_locked(ngx_slab_pool_t *pool, void *p);",6,57,core\ngx_slab.h,ngx_slab_free_locked,,false,69,69,ngx_slab_free_locked,,,15,"void ngx_slab_free_locked (ngx_slab_pool_t*,void*)"
61008,METHOD,core\ngx_spinlock.c:<global>,TYPE_DECL,<global>,1,1,core\ngx_spinlock.c,core\ngx_spinlock.c:<global>,,false,1,53,<global>,,,1,
61010,METHOD,core\ngx_spinlock.c:<global>,TYPE_DECL,"void
ngx_spinlock(ngx_atomic_t *lock, ngx_atomic_int_t value, ngx_uint_t spin)
{

#if (NGX_HAVE_ATOMIC_OPS)

    ngx_uint_t  i, n;

    for ( ;; ) {

        if (*lock == 0 && ngx_atomic_cmp_set(lock, 0, value)) {
            return;
        }

        if (ngx_ncpu > 1) {

            for (n = 1; n < spin; n <<= 1) {

                for (i = 0; i < n; i++) {
                    ngx_cpu_pause();
                }

                if (*lock == 0 && ngx_atomic_cmp_set(lock, 0, value)) {
                    return;
                }
            }
        }

        ngx_sched_yield();
    }

#else

#if (NGX_THREADS)

#error ngx_spinlock() or ngx_atomic_cmp_set() are not defined !

#endif

#endif

}",1,1,core\ngx_spinlock.c,ngx_spinlock,,false,12,53,ngx_spinlock,,,1,"void ngx_spinlock (ngx_atomic_t*,ngx_atomic_int_t,ngx_uint_t)"
61024,METHOD,core\ngx_string.c:<global>,TYPE_DECL,<global>,1,6,core\ngx_string.c,core\ngx_string.c:<global>,,false,1,2037,<global>,,,1,
61026,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"static u_char *ngx_sprintf_num(u_char *buf, u_char *last, uint64_t ui64,
    u_char zero, ngx_uint_t hexadecimal, ngx_uint_t width);",15,58,core\ngx_string.c,ngx_sprintf_num,,false,12,13,ngx_sprintf_num,,,1,"u_char* ngx_sprintf_num (u_char*,u_char*,uint64_t,u_char,ngx_uint_t,ngx_uint_t)"
61036,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"static void ngx_encode_base64_internal(ngx_str_t *dst, ngx_str_t *src,
    const u_char *basis, ngx_uint_t padding);",13,44,core\ngx_string.c,ngx_encode_base64_internal,,false,14,15,ngx_encode_base64_internal,,,2,"void ngx_encode_base64_internal (ngx_str_t*,ngx_str_t*,u_char*,ngx_uint_t)"
61044,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"static ngx_int_t ngx_decode_base64_internal(ngx_str_t *dst, ngx_str_t *src,
    const u_char *basis);",18,24,core\ngx_string.c,ngx_decode_base64_internal,,false,16,17,ngx_decode_base64_internal,,,3,"ngx_int_t ngx_decode_base64_internal (ngx_str_t*,ngx_str_t*,u_char*)"
61051,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"void
ngx_strlow(u_char *dst, u_char *src, size_t n)
{
    while (n) {
        *dst = ngx_tolower(*src);
        dst++;
        src++;
        n--;
    }
}",1,1,core\ngx_string.c,ngx_strlow,,false,20,29,ngx_strlow,,,4,"void ngx_strlow (u_char*,u_char*,size_t)"
61073,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"size_t
ngx_strnlen(u_char *p, size_t n)
{
    size_t  i;

    for (i = 0; i < n; i++) {

        if (p[i] == '\0') {
            return i;
        }
    }

    return n;
}",1,1,core\ngx_string.c,ngx_strnlen,,false,32,45,ngx_strnlen,,,5,"size_t ngx_strnlen (u_char*,size_t)"
61102,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"u_char *
ngx_cpystrn(u_char *dst, u_char *src, size_t n)
{
    if (n == 0) {
        return dst;
    }

    while (--n) {
        *dst = *src;

        if (*dst == '\0') {
            return dst;
        }

        dst++;
        src++;
    }

    *dst = '\0';

    return dst;
}",1,1,core\ngx_string.c,ngx_cpystrn,,false,48,69,ngx_cpystrn,,,6,"u_char ngx_cpystrn (u_char*,u_char*,size_t)"
61143,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"u_char *
ngx_pstrdup(ngx_pool_t *pool, ngx_str_t *src)
{
    u_char  *dst;

    dst = ngx_pnalloc(pool, src->len);
    if (dst == NULL) {
        return NULL;
    }

    ngx_memcpy(dst, src->data, src->len);

    return dst;
}",1,1,core\ngx_string.c,ngx_pstrdup,,false,72,85,ngx_pstrdup,,,7,"u_char ngx_pstrdup (ngx_pool_t*,ngx_str_t*)"
61176,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"ngx_sprintf(u_char *buf, const char *fmt, ...)
{
    u_char   *p;
    va_list   args;

    va_start(args, fmt);
    p = ngx_vslprintf(buf, (void *) -1, fmt, args);
    va_end(args);

    return p;
}",1,1,core\ngx_string.c,ngx_sprintf,,false,121,131,ngx_sprintf,,,10,"ANY ngx_sprintf (u_char*,char*...)"
61203,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"ngx_snprintf(u_char *buf, size_t max, const char *fmt, ...)
{
    u_char   *p;
    va_list   args;

    va_start(args, fmt);
    p = ngx_vslprintf(buf, buf + max, fmt, args);
    va_end(args);

    return p;
}",1,1,core\ngx_string.c,ngx_snprintf,,false,135,145,ngx_snprintf,,,13,"ANY ngx_snprintf (u_char*,size_t,char*...)"
61230,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"ngx_slprintf(u_char *buf, u_char *last, const char *fmt, ...)
{
    u_char   *p;
    va_list   args;

    va_start(args, fmt);
    p = ngx_vslprintf(buf, last, fmt, args);
    va_end(args);

    return p;
}",1,1,core\ngx_string.c,ngx_slprintf,,false,149,159,ngx_slprintf,,,16,"ANY ngx_slprintf (u_char*,u_char*,char*...)"
61253,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"u_char *
ngx_vslprintf(u_char *buf, u_char *last, const char *fmt, va_list args)
{
    u_char                *p, zero;
    int                    d;
    double                 f;
    size_t                 len, slen;
    int64_t                i64;
    uint64_t               ui64, frac;
    ngx_msec_t             ms;
    ngx_uint_t             width, sign, hex, max_width, frac_width, scale, n;
    ngx_str_t             *v;
    ngx_variable_value_t  *vv;

    while (*fmt && buf < last) {

        /*
         * ""buf < last"" means that we could copy at least one character:
         * the plain character, ""%%"", ""%c"", and minus without the checking
         */

        if (*fmt == '%') {

            i64 = 0;
            ui64 = 0;

            zero = (u_char) ((*++fmt == '0') ? '0' : ' ');
            width = 0;
            sign = 1;
            hex = 0;
            max_width = 0;
            frac_width = 0;
            slen = (size_t) -1;

            while (*fmt >= '0' && *fmt <= '9') ...",1,1,core\ngx_string.c,ngx_vslprintf,,false,162,490,ngx_vslprintf,,,17,"u_char ngx_vslprintf (u_char*,u_char*,char*,va_list)"
62001,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"static u_char *
ngx_sprintf_num(u_char *buf, u_char *last, uint64_t ui64, u_char zero,
    ngx_uint_t hexadecimal, ngx_uint_t width)
{
    u_char         *p, temp[NGX_INT64_LEN + 1];
                       /*
                        * we need temp[NGX_INT64_LEN] only,
                        * but icc issues the warning
                        */
    size_t          len;
    uint32_t        ui32;
    static u_char   hex[] = ""0123456789abcdef"";
    static u_char   HEX[] = ""0123456789ABCDEF"";

    p = temp + NGX_INT64_LEN;

    if (hexadecimal == 0) {

        if (ui64 <= (uint64_t) NGX_MAX_UINT32_VALUE) {

            /*
             * To divide 64-bit numbers and to find remainders
             * on the x86 platform gcc and icc call the libc functions
             * [u]divdi3() and [u]moddi3(), they call another function
             * in its turn.  On FreeBSD it is the qdivrem() function,
             * its source code is about 170 lines of the code.
             * The glibc counte...",1,1,core\ngx_string.c,ngx_sprintf_num,,false,493,576,ngx_sprintf_num,,,18,"u_char ngx_sprintf_num (u_char*,u_char*,uint64_t,u_char,ngx_uint_t,ngx_uint_t)"
62162,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"ngx_int_t
ngx_strcasecmp(u_char *s1, u_char *s2)
{
    ngx_uint_t  c1, c2;

    for ( ;; ) {
        c1 = (ngx_uint_t) *s1++;
        c2 = (ngx_uint_t) *s2++;

        c1 = (c1 >= 'A' && c1 <= 'Z') ? (c1 | 0x20) : c1;
        c2 = (c2 >= 'A' && c2 <= 'Z') ? (c2 | 0x20) : c2;

        if (c1 == c2) {

            if (c1) {
                continue;
            }

            return 0;
        }

        return c1 - c2;
    }
}",1,1,core\ngx_string.c,ngx_strcasecmp,,false,586,609,ngx_strcasecmp,,,19,"ngx_int_t ngx_strcasecmp (u_char*,u_char*)"
62228,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"ngx_int_t
ngx_strncasecmp(u_char *s1, u_char *s2, size_t n)
{
    ngx_uint_t  c1, c2;

    while (n) {
        c1 = (ngx_uint_t) *s1++;
        c2 = (ngx_uint_t) *s2++;

        c1 = (c1 >= 'A' && c1 <= 'Z') ? (c1 | 0x20) : c1;
        c2 = (c2 >= 'A' && c2 <= 'Z') ? (c2 | 0x20) : c2;

        if (c1 == c2) {

            if (c1) {
                n--;
                continue;
            }

            return 0;
        }

        return c1 - c2;
    }

    return 0;
}",1,1,core\ngx_string.c,ngx_strncasecmp,,false,612,638,ngx_strncasecmp,,,20,"ngx_int_t ngx_strncasecmp (u_char*,u_char*,size_t)"
62299,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"u_char *
ngx_strnstr(u_char *s1, char *s2, size_t len)
{
    u_char  c1, c2;
    size_t  n;

    c2 = *(u_char *) s2++;

    n = ngx_strlen(s2);

    do {
        do {
            if (len-- == 0) {
                return NULL;
            }

            c1 = *s1++;

            if (c1 == 0) {
                return NULL;
            }

        } while (c1 != c2);

        if (n > len) {
            return NULL;
        }

    } while (ngx_strncmp(s1, (u_char *) s2, n) != 0);

    return --s1;
}",1,1,core\ngx_string.c,ngx_strnstr,,false,641,672,ngx_strnstr,,,21,"u_char ngx_strnstr (u_char*,char*,size_t)"
62365,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"u_char *
ngx_strstrn(u_char *s1, char *s2, size_t n)
{
    u_char  c1, c2;

    c2 = *(u_char *) s2++;

    do {
        do {
            c1 = *s1++;

            if (c1 == 0) {
                return NULL;
            }

        } while (c1 != c2);

    } while (ngx_strncmp(s1, (u_char *) s2, n) != 0);

    return --s1;
}",1,1,core\ngx_string.c,ngx_strstrn,,false,681,701,ngx_strstrn,,,22,"u_char ngx_strstrn (u_char*,char*,size_t)"
62411,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"u_char *
ngx_strcasestrn(u_char *s1, char *s2, size_t n)
{
    ngx_uint_t  c1, c2;

    c2 = (ngx_uint_t) *s2++;
    c2 = (c2 >= 'A' && c2 <= 'Z') ? (c2 | 0x20) : c2;

    do {
        do {
            c1 = (ngx_uint_t) *s1++;

            if (c1 == 0) {
                return NULL;
            }

            c1 = (c1 >= 'A' && c1 <= 'Z') ? (c1 | 0x20) : c1;

        } while (c1 != c2);

    } while (ngx_strncasecmp(s1, (u_char *) s2, n) != 0);

    return --s1;
}",1,1,core\ngx_string.c,ngx_strcasestrn,,false,704,727,ngx_strcasestrn,,,23,"u_char ngx_strcasestrn (u_char*,char*,size_t)"
62485,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"u_char *
ngx_strlcasestrn(u_char *s1, u_char *last, u_char *s2, size_t n)
{
    ngx_uint_t  c1, c2;

    c2 = (ngx_uint_t) *s2++;
    c2 = (c2 >= 'A' && c2 <= 'Z') ? (c2 | 0x20) : c2;
    last -= n;

    do {
        do {
            if (s1 >= last) {
                return NULL;
            }

            c1 = (ngx_uint_t) *s1++;

            c1 = (c1 >= 'A' && c1 <= 'Z') ? (c1 | 0x20) : c1;

        } while (c1 != c2);

    } while (ngx_strncasecmp(s1, s2, n) != 0);

    return --s1;
}",1,1,core\ngx_string.c,ngx_strlcasestrn,,false,736,760,ngx_strlcasestrn,,,24,"u_char ngx_strlcasestrn (u_char*,u_char*,u_char*,size_t)"
62561,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"ngx_int_t
ngx_rstrncmp(u_char *s1, u_char *s2, size_t n)
{
    if (n == 0) {
        return 0;
    }

    n--;

    for ( ;; ) {
        if (s1[n] != s2[n]) {
            return s1[n] - s2[n];
        }

        if (n == 0) {
            return 0;
        }

        n--;
    }
}",1,1,core\ngx_string.c,ngx_rstrncmp,,false,763,783,ngx_rstrncmp,,,25,"ngx_int_t ngx_rstrncmp (u_char*,u_char*,size_t)"
62606,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"ngx_int_t
ngx_rstrncasecmp(u_char *s1, u_char *s2, size_t n)
{
    u_char  c1, c2;

    if (n == 0) {
        return 0;
    }

    n--;

    for ( ;; ) {
        c1 = s1[n];
        if (c1 >= 'a' && c1 <= 'z') {
            c1 -= 'a' - 'A';
        }

        c2 = s2[n];
        if (c2 >= 'a' && c2 <= 'z') {
            c2 -= 'a' - 'A';
        }

        if (c1 != c2) {
            return c1 - c2;
        }

        if (n == 0) {
            return 0;
        }

        n--;
    }
}",1,1,core\ngx_string.c,ngx_rstrncasecmp,,false,786,818,ngx_rstrncasecmp,,,26,"ngx_int_t ngx_rstrncasecmp (u_char*,u_char*,size_t)"
62683,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"ngx_int_t
ngx_memn2cmp(u_char *s1, u_char *s2, size_t n1, size_t n2)
{
    size_t     n;
    ngx_int_t  m, z;

    if (n1 <= n2) {
        n = n1;
        z = -1;

    } else {
        n = n2;
        z = 1;
    }

    m = ngx_memcmp(s1, s2, n);

    if (m || n1 == n2) {
        return m;
    }

    return z;
}",1,1,core\ngx_string.c,ngx_memn2cmp,,false,821,843,ngx_memn2cmp,,,27,"ngx_int_t ngx_memn2cmp (u_char*,u_char*,size_t,size_t)"
62731,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"ngx_int_t
ngx_dns_strcmp(u_char *s1, u_char *s2)
{
    ngx_uint_t  c1, c2;

    for ( ;; ) {
        c1 = (ngx_uint_t) *s1++;
        c2 = (ngx_uint_t) *s2++;

        c1 = (c1 >= 'A' && c1 <= 'Z') ? (c1 | 0x20) : c1;
        c2 = (c2 >= 'A' && c2 <= 'Z') ? (c2 | 0x20) : c2;

        if (c1 == c2) {

            if (c1) {
                continue;
            }

            return 0;
        }

        /* in ASCII '.' > '-', but we need '.' to be the lowest character */

        c1 = (c1 == '.') ? ' ' : c1;
        c2 = (c2 == '.') ? ' ' : c2;

        return c1 - c2;
    }
}",1,1,core\ngx_string.c,ngx_dns_strcmp,,false,846,874,ngx_dns_strcmp,,,28,"ngx_int_t ngx_dns_strcmp (u_char*,u_char*)"
62813,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"ngx_int_t
ngx_filename_cmp(u_char *s1, u_char *s2, size_t n)
{
    ngx_uint_t  c1, c2;

    while (n) {
        c1 = (ngx_uint_t) *s1++;
        c2 = (ngx_uint_t) *s2++;

#if (NGX_HAVE_CASELESS_FILESYSTEM)
        c1 = tolower(c1);
        c2 = tolower(c2);
#endif

        if (c1 == c2) {

            if (c1) {
                n--;
                continue;
            }

            return 0;
        }

        /* we need '/' to be the lowest character */

        if (c1 == 0 || c2 == 0) {
            return c1 - c2;
        }

        c1 = (c1 == '/') ? 0 : c1;
        c2 = (c2 == '/') ? 0 : c2;

        return c1 - c2;
    }

    return 0;
}",1,1,core\ngx_string.c,ngx_filename_cmp,,false,877,914,ngx_filename_cmp,,,29,"ngx_int_t ngx_filename_cmp (u_char*,u_char*,size_t)"
62885,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"ngx_int_t
ngx_atoi(u_char *line, size_t n)
{
    ngx_int_t  value, cutoff, cutlim;

    if (n == 0) {
        return NGX_ERROR;
    }

    cutoff = NGX_MAX_INT_T_VALUE / 10;
    cutlim = NGX_MAX_INT_T_VALUE % 10;

    for (value = 0; n--; line++) {
        if (*line < '0' || *line > '9') {
            return NGX_ERROR;
        }

        if (value >= cutoff && (value > cutoff || *line - '0' > cutlim)) {
            return NGX_ERROR;
        }

        value = value * 10 + (*line - '0');
    }

    return value;
}",1,1,core\ngx_string.c,ngx_atoi,,false,917,942,ngx_atoi,,,30,"ngx_int_t ngx_atoi (u_char*,size_t)"
62964,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"ngx_int_t
ngx_atofp(u_char *line, size_t n, size_t point)
{
    ngx_int_t   value, cutoff, cutlim;
    ngx_uint_t  dot;

    if (n == 0) {
        return NGX_ERROR;
    }

    cutoff = NGX_MAX_INT_T_VALUE / 10;
    cutlim = NGX_MAX_INT_T_VALUE % 10;

    dot = 0;

    for (value = 0; n--; line++) {

        if (point == 0) {
            return NGX_ERROR;
        }

        if (*line == '.') {
            if (dot) {
                return NGX_ERROR;
            }

            dot = 1;
            continue;
        }

        if (*line < '0' || *line > '9') {
            return NGX_ERROR;
        }

        if (value >= cutoff && (value > cutoff || *line - '0' > cutlim)) {
            return NGX_ERROR;
        }

        value = value * 10 + (*line - '0');
        point -= dot;
    }

    while (point--) {
        if (value > cutoff) {
            return NGX_ERROR;
        }

        value = value * 10;
    }

    return value;
}",1,1,core\ngx_string.c,ngx_atofp,,false,947,998,ngx_atofp,,,31,"ngx_int_t ngx_atofp (u_char*,size_t,size_t)"
63089,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"ssize_t
ngx_atosz(u_char *line, size_t n)
{
    ssize_t  value, cutoff, cutlim;

    if (n == 0) {
        return NGX_ERROR;
    }

    cutoff = NGX_MAX_SIZE_T_VALUE / 10;
    cutlim = NGX_MAX_SIZE_T_VALUE % 10;

    for (value = 0; n--; line++) {
        if (*line < '0' || *line > '9') {
            return NGX_ERROR;
        }

        if (value >= cutoff && (value > cutoff || *line - '0' > cutlim)) {
            return NGX_ERROR;
        }

        value = value * 10 + (*line - '0');
    }

    return value;
}",1,1,core\ngx_string.c,ngx_atosz,,false,1001,1026,ngx_atosz,,,32,"ssize_t ngx_atosz (u_char*,size_t)"
63168,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"off_t
ngx_atoof(u_char *line, size_t n)
{
    off_t  value, cutoff, cutlim;

    if (n == 0) {
        return NGX_ERROR;
    }

    cutoff = NGX_MAX_OFF_T_VALUE / 10;
    cutlim = NGX_MAX_OFF_T_VALUE % 10;

    for (value = 0; n--; line++) {
        if (*line < '0' || *line > '9') {
            return NGX_ERROR;
        }

        if (value >= cutoff && (value > cutoff || *line - '0' > cutlim)) {
            return NGX_ERROR;
        }

        value = value * 10 + (*line - '0');
    }

    return value;
}",1,1,core\ngx_string.c,ngx_atoof,,false,1029,1054,ngx_atoof,,,33,"off_t ngx_atoof (u_char*,size_t)"
63247,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"time_t
ngx_atotm(u_char *line, size_t n)
{
    time_t  value, cutoff, cutlim;

    if (n == 0) {
        return NGX_ERROR;
    }

    cutoff = NGX_MAX_TIME_T_VALUE / 10;
    cutlim = NGX_MAX_TIME_T_VALUE % 10;

    for (value = 0; n--; line++) {
        if (*line < '0' || *line > '9') {
            return NGX_ERROR;
        }

        if (value >= cutoff && (value > cutoff || *line - '0' > cutlim)) {
            return NGX_ERROR;
        }

        value = value * 10 + (*line - '0');
    }

    return value;
}",1,1,core\ngx_string.c,ngx_atotm,,false,1057,1082,ngx_atotm,,,34,"time_t ngx_atotm (u_char*,size_t)"
63326,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"ngx_int_t
ngx_hextoi(u_char *line, size_t n)
{
    u_char     c, ch;
    ngx_int_t  value, cutoff;

    if (n == 0) {
        return NGX_ERROR;
    }

    cutoff = NGX_MAX_INT_T_VALUE / 16;

    for (value = 0; n--; line++) {
        if (value > cutoff) {
            return NGX_ERROR;
        }

        ch = *line;

        if (ch >= '0' && ch <= '9') {
            value = value * 16 + (ch - '0');
            continue;
        }

        c = (u_char) (ch | 0x20);

        if (c >= 'a' && c <= 'f') {
            value = value * 16 + (c - 'a' + 10);
            continue;
        }

        return NGX_ERROR;
    }

    return value;
}",1,1,core\ngx_string.c,ngx_hextoi,,false,1085,1120,ngx_hextoi,,,35,"ngx_int_t ngx_hextoi (u_char*,size_t)"
63419,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"u_char *
ngx_hex_dump(u_char *dst, u_char *src, size_t len)
{
    static u_char  hex[] = ""0123456789abcdef"";

    while (len--) {
        *dst++ = hex[*src >> 4];
        *dst++ = hex[*src++ & 0xf];
    }

    return dst;
}",1,1,core\ngx_string.c,ngx_hex_dump,,false,1123,1134,ngx_hex_dump,,,36,"u_char ngx_hex_dump (u_char*,u_char*,size_t)"
63457,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"void
ngx_encode_base64(ngx_str_t *dst, ngx_str_t *src)
{
    static u_char   basis64[] =
            ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"";

    ngx_encode_base64_internal(dst, src, basis64, 1);
}",1,1,core\ngx_string.c,ngx_encode_base64,,false,1137,1144,ngx_encode_base64,,,37,"void ngx_encode_base64 (ngx_str_t*,ngx_str_t*)"
63472,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"void
ngx_encode_base64url(ngx_str_t *dst, ngx_str_t *src)
{
    static u_char   basis64[] =
            ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"";

    ngx_encode_base64_internal(dst, src, basis64, 0);
}",1,1,core\ngx_string.c,ngx_encode_base64url,,false,1147,1154,ngx_encode_base64url,,,38,"void ngx_encode_base64url (ngx_str_t*,ngx_str_t*)"
63487,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"static void
ngx_encode_base64_internal(ngx_str_t *dst, ngx_str_t *src, const u_char *basis,
    ngx_uint_t padding)
{
    u_char         *d, *s;
    size_t          len;

    len = src->len;
    s = src->data;
    d = dst->data;

    while (len > 2) {
        *d++ = basis[(s[0] >> 2) & 0x3f];
        *d++ = basis[((s[0] & 3) << 4) | (s[1] >> 4)];
        *d++ = basis[((s[1] & 0x0f) << 2) | (s[2] >> 6)];
        *d++ = basis[s[2] & 0x3f];

        s += 3;
        len -= 3;
    }

    if (len) {
        *d++ = basis[(s[0] >> 2) & 0x3f];

        if (len == 1) {
            *d++ = basis[(s[0] & 3) << 4];
            if (padding) {
                *d++ = '=';
            }

        } else {
            *d++ = basis[((s[0] & 3) << 4) | (s[1] >> 4)];
            *d++ = basis[(s[1] & 0x0f) << 2];
        }

        if (padding) {
            *d++ = '=';
        }
    }

    dst->len = d - dst->data;
}",1,1,core\ngx_string.c,ngx_encode_base64_internal,,false,1157,1198,ngx_encode_base64_internal,,,39,"void ngx_encode_base64_internal (ngx_str_t*,ngx_str_t*,u_char*,ngx_uint_t)"
63679,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"ngx_int_t
ngx_decode_base64(ngx_str_t *dst, ngx_str_t *src)
{
    static u_char   basis64[] = {
        77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,
        77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,
        77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 62, 77, 77, 77, 63,
        52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 77, 77, 77, 77, 77, 77,
        77,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
        15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 77, 77, 77, 77, 77,
        77, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
        41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 77, 77, 77, 77, 77,

        77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,
        77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,
        77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,
        77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,
        77, 77, 77, 77, 77, 77, 77, ...",1,1,core\ngx_string.c,ngx_decode_base64,,false,1201,1225,ngx_decode_base64,,,40,"ngx_int_t ngx_decode_base64 (ngx_str_t*,ngx_str_t*)"
63950,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"ngx_int_t
ngx_decode_base64url(ngx_str_t *dst, ngx_str_t *src)
{
    static u_char   basis64[] = {
        77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,
        77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,
        77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 62, 77, 77,
        52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 77, 77, 77, 77, 77, 77,
        77,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
        15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 77, 77, 77, 77, 63,
        77, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
        41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 77, 77, 77, 77, 77,

        77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,
        77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,
        77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,
        77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,
        77, 77, 77, 77, 77, 77, 7...",1,1,core\ngx_string.c,ngx_decode_base64url,,false,1228,1252,ngx_decode_base64url,,,41,"ngx_int_t ngx_decode_base64url (ngx_str_t*,ngx_str_t*)"
64221,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_decode_base64_internal(ngx_str_t *dst, ngx_str_t *src, const u_char *basis)
{
    size_t          len;
    u_char         *d, *s;

    for (len = 0; len < src->len; len++) {
        if (src->data[len] == '=') {
            break;
        }

        if (basis[src->data[len]] == 77) {
            return NGX_ERROR;
        }
    }

    if (len % 4 == 1) {
        return NGX_ERROR;
    }

    s = src->data;
    d = dst->data;

    while (len > 3) {
        *d++ = (u_char) (basis[s[0]] << 2 | basis[s[1]] >> 4);
        *d++ = (u_char) (basis[s[1]] << 4 | basis[s[2]] >> 2);
        *d++ = (u_char) (basis[s[2]] << 6 | basis[s[3]]);

        s += 4;
        len -= 4;
    }

    if (len > 1) {
        *d++ = (u_char) (basis[s[0]] << 2 | basis[s[1]] >> 4);
    }

    if (len > 2) {
        *d++ = (u_char) (basis[s[1]] << 4 | basis[s[2]] >> 2);
    }

    dst->len = d - dst->data;

    return NGX_OK;
}",1,1,core\ngx_string.c,ngx_decode_base64_internal,,false,1255,1298,ngx_decode_base64_internal,,,42,"ngx_int_t ngx_decode_base64_internal (ngx_str_t*,ngx_str_t*,u_char*)"
64416,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"uint32_t
ngx_utf8_decode(u_char **p, size_t n)
{
    size_t    len;
    uint32_t  u, i, valid;

    u = **p;

    if (u >= 0xf0) {

        u &= 0x07;
        valid = 0xffff;
        len = 3;

    } else if (u >= 0xe0) {

        u &= 0x0f;
        valid = 0x7ff;
        len = 2;

    } else if (u >= 0xc2) {

        u &= 0x1f;
        valid = 0x7f;
        len = 1;

    } else {
        (*p)++;
        return 0xffffffff;
    }

    if (n - 1 < len) {
        return 0xfffffffe;
    }

    (*p)++;

    while (len) {
        i = *(*p)++;

        if (i < 0x80) {
            return 0xffffffff;
        }

        u = (u << 6) | (i & 0x3f);

        len--;
    }

    if (u > valid) {
        return u;
    }

    return 0xffffffff;
}",1,1,core\ngx_string.c,ngx_utf8_decode,,false,1310,1364,ngx_utf8_decode,,,43,"uint32_t ngx_utf8_decode (u_char**,size_t)"
64532,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"size_t
ngx_utf8_length(u_char *p, size_t n)
{
    u_char  c, *last;
    size_t  len;

    last = p + n;

    for (len = 0; p < last; len++) {

        c = *p;

        if (c < 0x80) {
            p++;
            continue;
        }

        if (ngx_utf8_decode(&p, last - p) > 0x10ffff) {
            /* invalid UTF-8 */
            return n;
        }
    }

    return len;
}",1,1,core\ngx_string.c,ngx_utf8_length,,false,1367,1391,ngx_utf8_length,,,44,"size_t ngx_utf8_length (u_char*,size_t)"
64583,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"u_char *
ngx_utf8_cpystrn(u_char *dst, u_char *src, size_t n, size_t len)
{
    u_char  c, *next;

    if (n == 0) {
        return dst;
    }

    while (--n) {

        c = *src;
        *dst = c;

        if (c < 0x80) {

            if (c != '\0') {
                dst++;
                src++;
                len--;

                continue;
            }

            return dst;
        }

        next = src;

        if (ngx_utf8_decode(&next, len) > 0x10ffff) {
            /* invalid UTF-8 */
            break;
        }

        while (src < next) {
            *dst++ = *src++;
            len--;
        }
    }

    *dst = '\0';

    return dst;
}",1,1,core\ngx_string.c,ngx_utf8_cpystrn,,false,1394,1437,ngx_utf8_cpystrn,,,45,"u_char ngx_utf8_cpystrn (u_char*,u_char*,size_t,size_t)"
64663,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"uintptr_t
ngx_escape_uri(u_char *dst, u_char *src, size_t size, ngx_uint_t type)
{
    ngx_uint_t      n;
    uint32_t       *escape;
    static u_char   hex[] = ""0123456789ABCDEF"";

                    /* "" "", ""#"", ""%"", ""?"", %00-%1F, %7F-%FF */

    static uint32_t   uri[] = {
        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */

                    /* ?>=< ;:98 7654 3210  /.-, +*)( '&%$ #""!  */
        0x80000029, /* 1000 0000 0000 0000  0000 0000 0010 1001 */

                    /* _^]\ [ZYX WVUT SRQP  ONML KJIH GFED CBA@ */
        0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */

                    /*  ~}| {zyx wvut srqp  onml kjih gfed cba` */
        0x80000000, /* 1000 0000 0000 0000  0000 0000 0000 0000 */

        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */
        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */
        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */
        0xffffffff  /* 1111 1111 1111 1111  ...",1,1,core\ngx_string.c,ngx_escape_uri,,false,1440,1606,ngx_escape_uri,,,46,"uintptr_t ngx_escape_uri (u_char*,u_char*,size_t,ngx_uint_t)"
64861,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"void
ngx_unescape_uri(u_char **dst, u_char **src, size_t size, ngx_uint_t type)
{
    u_char  *d, *s, ch, c, decoded;
    enum {
        sw_usual = 0,
        sw_quoted,
        sw_quoted_second
    } state;

    d = *dst;
    s = *src;

    state = 0;
    decoded = 0;

    while (size--) {

        ch = *s++;

        switch (state) {
        case sw_usual:
            if (ch == '?'
                && (type & (NGX_UNESCAPE_URI|NGX_UNESCAPE_REDIRECT)))
            {
                *d++ = ch;
                goto done;
            }

            if (ch == '%') {
                state = sw_quoted;
                break;
            }

            *d++ = ch;
            break;

        case sw_quoted:

            if (ch >= '0' && ch <= '9') {
                decoded = (u_char) (ch - '0');
                state = sw_quoted_second;
                break;
            }

            c = (u_char) (ch | 0x20);
            if (c >= 'a' && c <= 'f') {
                decoded = (u_char) (c - ...",1,1,core\ngx_string.c,ngx_unescape_uri,,false,1609,1736,ngx_unescape_uri,,,47,"void ngx_unescape_uri (u_char**,u_char**,size_t,ngx_uint_t)"
65182,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"uintptr_t
ngx_escape_html(u_char *dst, u_char *src, size_t size)
{
    u_char      ch;
    ngx_uint_t  len;

    if (dst == NULL) {

        len = 0;

        while (size) {
            switch (*src++) {

            case '<':
                len += sizeof(""&lt;"") - 2;
                break;

            case '>':
                len += sizeof(""&gt;"") - 2;
                break;

            case '&':
                len += sizeof(""&amp;"") - 2;
                break;

            case '""':
                len += sizeof(""&quot;"") - 2;
                break;

            default:
                break;
            }
            size--;
        }

        return (uintptr_t) len;
    }

    while (size) {
        ch = *src++;

        switch (ch) {

        case '<':
            *dst++ = '&'; *dst++ = 'l'; *dst++ = 't'; *dst++ = ';';
            break;

        case '>':
            *dst++ = '&'; *dst++ = 'g'; *dst++ = 't'; *dst++ = ';';
            break;

        case '&':
           ...",1,1,core\ngx_string.c,ngx_escape_html,,false,1739,1808,ngx_escape_html,,,48,"uintptr_t ngx_escape_html (u_char*,u_char*,size_t)"
65382,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"uintptr_t
ngx_escape_json(u_char *dst, u_char *src, size_t size)
{
    u_char      ch;
    ngx_uint_t  len;

    if (dst == NULL) {
        len = 0;

        while (size) {
            ch = *src++;

            if (ch == '\\' || ch == '""') {
                len++;

            } else if (ch <= 0x1f) {

                switch (ch) {
                case '\n':
                case '\r':
                case '\t':
                case '\b':
                case '\f':
                    len++;
                    break;

                default:
                    len += sizeof(""\\u001F"") - 2;
                }
            }

            size--;
        }

        return (uintptr_t) len;
    }

    while (size) {
        ch = *src++;

        if (ch > 0x1f) {

            if (ch == '\\' || ch == '""') {
                *dst++ = '\\';
            }

            *dst++ = ch;

        } else {
            *dst++ = '\\';

            switch (ch) {
            case '\n':
                *ds...",1,1,core\ngx_string.c,ngx_escape_json,,false,1811,1897,ngx_escape_json,,,49,"uintptr_t ngx_escape_json (u_char*,u_char*,size_t)"
65586,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"void
ngx_str_rbtree_insert_value(ngx_rbtree_node_t *temp,
    ngx_rbtree_node_t *node, ngx_rbtree_node_t *sentinel)
{
    ngx_str_node_t      *n, *t;
    ngx_rbtree_node_t  **p;

    for ( ;; ) {

        n = (ngx_str_node_t *) node;
        t = (ngx_str_node_t *) temp;

        if (node->key != temp->key) {

            p = (node->key < temp->key) ? &temp->left : &temp->right;

        } else if (n->str.len != t->str.len) {

            p = (n->str.len < t->str.len) ? &temp->left : &temp->right;

        } else {
            p = (ngx_memcmp(n->str.data, t->str.data, n->str.len) < 0)
                 ? &temp->left : &temp->right;
        }

        if (*p == sentinel) {
            break;
        }

        temp = *p;
    }

    *p = node;
    node->parent = temp;
    node->left = sentinel;
    node->right = sentinel;
    ngx_rbt_red(node);
}",1,1,core\ngx_string.c,ngx_str_rbtree_insert_value,,false,1900,1937,ngx_str_rbtree_insert_value,,,50,"void ngx_str_rbtree_insert_value (ngx_rbtree_node_t*,ngx_rbtree_node_t*,ngx_rbtree_node_t*)"
65736,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"ngx_str_node_t *
ngx_str_rbtree_lookup(ngx_rbtree_t *rbtree, ngx_str_t *val, uint32_t hash)
{
    ngx_int_t           rc;
    ngx_str_node_t     *n;
    ngx_rbtree_node_t  *node, *sentinel;

    node = rbtree->root;
    sentinel = rbtree->sentinel;

    while (node != sentinel) {

        n = (ngx_str_node_t *) node;

        if (hash != node->key) {
            node = (hash < node->key) ? node->left : node->right;
            continue;
        }

        if (val->len != n->str.len) {
            node = (val->len < n->str.len) ? node->left : node->right;
            continue;
        }

        rc = ngx_memcmp(val->data, n->str.data, val->len);

        if (rc < 0) {
            node = node->left;
            continue;
        }

        if (rc > 0) {
            node = node->right;
            continue;
        }

        return n;
    }

    return NULL;
}",1,1,core\ngx_string.c,ngx_str_rbtree_lookup,,false,1940,1980,ngx_str_rbtree_lookup,,,51,"ngx_str_node_t ngx_str_rbtree_lookup (ngx_rbtree_t*,ngx_str_t*,uint32_t)"
65859,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"void
ngx_sort(void *base, size_t n, size_t size,
    ngx_int_t (*cmp)(const void *, const void *))
{
    u_char  *p1, *p2, *p;

    p = ngx_alloc(size, ngx_cycle->log);
    if (p == NULL) {
        return;
    }

    for (p1 = (u_char *) base + size;
         p1 < (u_char *) base + n * size;
         p1 += size)
    {
        ngx_memcpy(p, p1, size);

        for (p2 = p1;
             p2 > (u_char *) base && cmp(p2 - size, p) > 0;
             p2 -= size)
        {
            ngx_memcpy(p2, p2 - size, size);
        }

        ngx_memcpy(p2, p, size);
    }

    ngx_free(p);
}",1,1,core\ngx_string.c,ngx_sort,,false,1985,2013,ngx_sort,,,52,"void ngx_sort (void*,size_t,size_t,ngx_int_t)"
65943,METHOD,core\ngx_string.c:<global>,TYPE_DECL,"void
ngx_explicit_memzero(void *buf, size_t n)
{
    ngx_memzero(buf, n);
    ngx_memory_barrier();
}",1,1,core\ngx_string.c,ngx_explicit_memzero,,false,2016,2021,ngx_explicit_memzero,,,53,"void ngx_explicit_memzero (void*,size_t)"
65960,METHOD,core\ngx_string.h:<global>,TYPE_DECL,<global>,1,15,core\ngx_string.h,core\ngx_string.h:<global>,,false,1,238,<global>,,,1,
65978,METHOD,core\ngx_string.h:<global>,TYPE_DECL,"void ngx_strlow(u_char *dst, u_char *src, size_t n);",6,51,core\ngx_string.h,ngx_strlow,,false,50,50,ngx_strlow,,,7,"void ngx_strlow (u_char*,u_char*,size_t)"
65985,METHOD,core\ngx_string.h:<global>,TYPE_DECL,"size_t ngx_strnlen(u_char *p, size_t n);",8,39,core\ngx_string.h,ngx_strnlen,,false,63,63,ngx_strnlen,,,8,"size_t ngx_strnlen (u_char*,size_t)"
65992,METHOD,core\ngx_string.h:<global>,TYPE_DECL,"void ngx_explicit_memzero(void *buf, size_t n);",6,46,core\ngx_string.h,ngx_explicit_memzero,,false,91,91,ngx_explicit_memzero,,,10,"void ngx_explicit_memzero (void*,size_t)"
65998,METHOD,core\ngx_string.h:<global>,TYPE_DECL,"u_char *ngx_cpystrn(u_char *dst, u_char *src, size_t n);",8,55,core\ngx_string.h,ngx_cpystrn,,false,151,151,ngx_cpystrn,,,11,"u_char* ngx_cpystrn (u_char*,u_char*,size_t)"
66005,METHOD,core\ngx_string.h:<global>,TYPE_DECL,"u_char *ngx_pstrdup(ngx_pool_t *pool, ngx_str_t *src);",8,53,core\ngx_string.h,ngx_pstrdup,,false,152,152,ngx_pstrdup,,,12,"u_char* ngx_pstrdup (ngx_pool_t*,ngx_str_t*)"
66014,METHOD,core\ngx_string.h:<global>,TYPE_DECL,"u_char *ngx_vslprintf(u_char *buf, u_char *last, const char *fmt, va_list args);",8,79,core\ngx_string.h,ngx_vslprintf,,false,157,157,ngx_vslprintf,,,16,"u_char* ngx_vslprintf (u_char*,u_char*,char*,va_list)"
66022,METHOD,core\ngx_string.h:<global>,TYPE_DECL,"ngx_int_t ngx_strcasecmp(u_char *s1, u_char *s2);",11,48,core\ngx_string.h,ngx_strcasecmp,,false,161,161,ngx_strcasecmp,,,17,"ngx_int_t ngx_strcasecmp (u_char*,u_char*)"
66028,METHOD,core\ngx_string.h:<global>,TYPE_DECL,"ngx_int_t ngx_strncasecmp(u_char *s1, u_char *s2, size_t n);",11,59,core\ngx_string.h,ngx_strncasecmp,,false,162,162,ngx_strncasecmp,,,18,"ngx_int_t ngx_strncasecmp (u_char*,u_char*,size_t)"
66035,METHOD,core\ngx_string.h:<global>,TYPE_DECL,"u_char *ngx_strnstr(u_char *s1, char *s2, size_t n);",8,51,core\ngx_string.h,ngx_strnstr,,false,164,164,ngx_strnstr,,,19,"u_char* ngx_strnstr (u_char*,char*,size_t)"
66042,METHOD,core\ngx_string.h:<global>,TYPE_DECL,"u_char *ngx_strstrn(u_char *s1, char *s2, size_t n);",8,51,core\ngx_string.h,ngx_strstrn,,false,166,166,ngx_strstrn,,,20,"u_char* ngx_strstrn (u_char*,char*,size_t)"
66049,METHOD,core\ngx_string.h:<global>,TYPE_DECL,"u_char *ngx_strcasestrn(u_char *s1, char *s2, size_t n);",8,55,core\ngx_string.h,ngx_strcasestrn,,false,167,167,ngx_strcasestrn,,,21,"u_char* ngx_strcasestrn (u_char*,char*,size_t)"
66056,METHOD,core\ngx_string.h:<global>,TYPE_DECL,"u_char *ngx_strlcasestrn(u_char *s1, u_char *last, u_char *s2, size_t n);",8,72,core\ngx_string.h,ngx_strlcasestrn,,false,168,168,ngx_strlcasestrn,,,22,"u_char* ngx_strlcasestrn (u_char*,u_char*,u_char*,size_t)"
66064,METHOD,core\ngx_string.h:<global>,TYPE_DECL,"ngx_int_t ngx_rstrncmp(u_char *s1, u_char *s2, size_t n);",11,56,core\ngx_string.h,ngx_rstrncmp,,false,170,170,ngx_rstrncmp,,,23,"ngx_int_t ngx_rstrncmp (u_char*,u_char*,size_t)"
66071,METHOD,core\ngx_string.h:<global>,TYPE_DECL,"ngx_int_t ngx_rstrncasecmp(u_char *s1, u_char *s2, size_t n);",11,60,core\ngx_string.h,ngx_rstrncasecmp,,false,171,171,ngx_rstrncasecmp,,,24,"ngx_int_t ngx_rstrncasecmp (u_char*,u_char*,size_t)"
66078,METHOD,core\ngx_string.h:<global>,TYPE_DECL,"ngx_int_t ngx_memn2cmp(u_char *s1, u_char *s2, size_t n1, size_t n2);",11,68,core\ngx_string.h,ngx_memn2cmp,,false,172,172,ngx_memn2cmp,,,25,"ngx_int_t ngx_memn2cmp (u_char*,u_char*,size_t,size_t)"
66086,METHOD,core\ngx_string.h:<global>,TYPE_DECL,"ngx_int_t ngx_dns_strcmp(u_char *s1, u_char *s2);",11,48,core\ngx_string.h,ngx_dns_strcmp,,false,173,173,ngx_dns_strcmp,,,26,"ngx_int_t ngx_dns_strcmp (u_char*,u_char*)"
66092,METHOD,core\ngx_string.h:<global>,TYPE_DECL,"ngx_int_t ngx_filename_cmp(u_char *s1, u_char *s2, size_t n);",11,60,core\ngx_string.h,ngx_filename_cmp,,false,174,174,ngx_filename_cmp,,,27,"ngx_int_t ngx_filename_cmp (u_char*,u_char*,size_t)"
66099,METHOD,core\ngx_string.h:<global>,TYPE_DECL,"ngx_int_t ngx_atoi(u_char *line, size_t n);",11,42,core\ngx_string.h,ngx_atoi,,false,176,176,ngx_atoi,,,28,"ngx_int_t ngx_atoi (u_char*,size_t)"
66105,METHOD,core\ngx_string.h:<global>,TYPE_DECL,"ngx_int_t ngx_atofp(u_char *line, size_t n, size_t point);",11,57,core\ngx_string.h,ngx_atofp,,false,177,177,ngx_atofp,,,29,"ngx_int_t ngx_atofp (u_char*,size_t,size_t)"
66112,METHOD,core\ngx_string.h:<global>,TYPE_DECL,"ssize_t ngx_atosz(u_char *line, size_t n);",9,41,core\ngx_string.h,ngx_atosz,,false,178,178,ngx_atosz,,,30,"ssize_t ngx_atosz (u_char*,size_t)"
66118,METHOD,core\ngx_string.h:<global>,TYPE_DECL,"off_t ngx_atoof(u_char *line, size_t n);",7,39,core\ngx_string.h,ngx_atoof,,false,179,179,ngx_atoof,,,31,"off_t ngx_atoof (u_char*,size_t)"
66124,METHOD,core\ngx_string.h:<global>,TYPE_DECL,"time_t ngx_atotm(u_char *line, size_t n);",8,40,core\ngx_string.h,ngx_atotm,,false,180,180,ngx_atotm,,,32,"time_t ngx_atotm (u_char*,size_t)"
66130,METHOD,core\ngx_string.h:<global>,TYPE_DECL,"ngx_int_t ngx_hextoi(u_char *line, size_t n);",11,44,core\ngx_string.h,ngx_hextoi,,false,181,181,ngx_hextoi,,,33,"ngx_int_t ngx_hextoi (u_char*,size_t)"
66136,METHOD,core\ngx_string.h:<global>,TYPE_DECL,"u_char *ngx_hex_dump(u_char *dst, u_char *src, size_t len);",8,58,core\ngx_string.h,ngx_hex_dump,,false,183,183,ngx_hex_dump,,,34,"u_char* ngx_hex_dump (u_char*,u_char*,size_t)"
66143,METHOD,core\ngx_string.h:<global>,TYPE_DECL,"void ngx_encode_base64(ngx_str_t *dst, ngx_str_t *src);",6,54,core\ngx_string.h,ngx_encode_base64,,false,189,189,ngx_encode_base64,,,35,"void ngx_encode_base64 (ngx_str_t*,ngx_str_t*)"
66149,METHOD,core\ngx_string.h:<global>,TYPE_DECL,"void ngx_encode_base64url(ngx_str_t *dst, ngx_str_t *src);",6,57,core\ngx_string.h,ngx_encode_base64url,,false,190,190,ngx_encode_base64url,,,36,"void ngx_encode_base64url (ngx_str_t*,ngx_str_t*)"
66155,METHOD,core\ngx_string.h:<global>,TYPE_DECL,"ngx_int_t ngx_decode_base64(ngx_str_t *dst, ngx_str_t *src);",11,59,core\ngx_string.h,ngx_decode_base64,,false,191,191,ngx_decode_base64,,,37,"ngx_int_t ngx_decode_base64 (ngx_str_t*,ngx_str_t*)"
66161,METHOD,core\ngx_string.h:<global>,TYPE_DECL,"ngx_int_t ngx_decode_base64url(ngx_str_t *dst, ngx_str_t *src);",11,62,core\ngx_string.h,ngx_decode_base64url,,false,192,192,ngx_decode_base64url,,,38,"ngx_int_t ngx_decode_base64url (ngx_str_t*,ngx_str_t*)"
66167,METHOD,core\ngx_string.h:<global>,TYPE_DECL,"uint32_t ngx_utf8_decode(u_char **p, size_t n);",10,46,core\ngx_string.h,ngx_utf8_decode,,false,194,194,ngx_utf8_decode,,,39,"uint32_t ngx_utf8_decode (u_char**,size_t)"
66173,METHOD,core\ngx_string.h:<global>,TYPE_DECL,"size_t ngx_utf8_length(u_char *p, size_t n);",8,43,core\ngx_string.h,ngx_utf8_length,,false,195,195,ngx_utf8_length,,,40,"size_t ngx_utf8_length (u_char*,size_t)"
66179,METHOD,core\ngx_string.h:<global>,TYPE_DECL,"u_char *ngx_utf8_cpystrn(u_char *dst, u_char *src, size_t n, size_t len);",8,72,core\ngx_string.h,ngx_utf8_cpystrn,,false,196,196,ngx_utf8_cpystrn,,,41,"u_char* ngx_utf8_cpystrn (u_char*,u_char*,size_t,size_t)"
66187,METHOD,core\ngx_string.h:<global>,TYPE_DECL,"uintptr_t ngx_escape_uri(u_char *dst, u_char *src, size_t size,
    ngx_uint_t type);",11,20,core\ngx_string.h,ngx_escape_uri,,false,210,211,ngx_escape_uri,,,42,"uintptr_t ngx_escape_uri (u_char*,u_char*,size_t,ngx_uint_t)"
66195,METHOD,core\ngx_string.h:<global>,TYPE_DECL,"void ngx_unescape_uri(u_char **dst, u_char **src, size_t size, ngx_uint_t type);",6,79,core\ngx_string.h,ngx_unescape_uri,,false,212,212,ngx_unescape_uri,,,43,"void ngx_unescape_uri (u_char**,u_char**,size_t,ngx_uint_t)"
66203,METHOD,core\ngx_string.h:<global>,TYPE_DECL,"uintptr_t ngx_escape_html(u_char *dst, u_char *src, size_t size);",11,64,core\ngx_string.h,ngx_escape_html,,false,213,213,ngx_escape_html,,,44,"uintptr_t ngx_escape_html (u_char*,u_char*,size_t)"
66210,METHOD,core\ngx_string.h:<global>,TYPE_DECL,"uintptr_t ngx_escape_json(u_char *dst, u_char *src, size_t size);",11,64,core\ngx_string.h,ngx_escape_json,,false,214,214,ngx_escape_json,,,45,"uintptr_t ngx_escape_json (u_char*,u_char*,size_t)"
66221,METHOD,core\ngx_string.h:<global>,TYPE_DECL,"void ngx_str_rbtree_insert_value(ngx_rbtree_node_t *temp,
    ngx_rbtree_node_t *node, ngx_rbtree_node_t *sentinel);",6,57,core\ngx_string.h,ngx_str_rbtree_insert_value,,false,223,224,ngx_str_rbtree_insert_value,,,48,"void ngx_str_rbtree_insert_value (ngx_rbtree_node_t*,ngx_rbtree_node_t*,ngx_rbtree_node_t*)"
66228,METHOD,core\ngx_string.h:<global>,TYPE_DECL,"ngx_str_node_t *ngx_str_rbtree_lookup(ngx_rbtree_t *rbtree, ngx_str_t *name,
    uint32_t hash);",16,18,core\ngx_string.h,ngx_str_rbtree_lookup,,false,225,226,ngx_str_rbtree_lookup,,,49,"ngx_str_node_t* ngx_str_rbtree_lookup (ngx_rbtree_t*,ngx_str_t*,uint32_t)"
66235,METHOD,core\ngx_string.h:<global>,TYPE_DECL,"void ngx_sort(void *base, size_t n, size_t size,
    ngx_int_t (*cmp)(const void *, const void *));",6,49,core\ngx_string.h,ngx_sort,,false,229,230,ngx_sort,,,50,"void ngx_sort (void*,size_t,size_t,ngx_int_t)"
66252,METHOD,core\ngx_syslog.c:<global>,TYPE_DECL,<global>,1,31,core\ngx_syslog.c,core\ngx_syslog.c:<global>,,false,1,378,<global>,,,1,
66254,METHOD,core\ngx_syslog.c:<global>,TYPE_DECL,"static char *ngx_syslog_parse_args(ngx_conf_t *cf, ngx_syslog_peer_t *peer);",13,75,core\ngx_syslog.c,ngx_syslog_parse_args,,false,18,18,ngx_syslog_parse_args,,,1,"char* ngx_syslog_parse_args (ngx_conf_t*,ngx_syslog_peer_t*)"
66260,METHOD,core\ngx_syslog.c:<global>,TYPE_DECL,static ngx_int_t ngx_syslog_init_peer(ngx_syslog_peer_t *peer);,18,62,core\ngx_syslog.c,ngx_syslog_init_peer,,false,19,19,ngx_syslog_init_peer,,,2,ngx_int_t ngx_syslog_init_peer (ngx_syslog_peer_t*)
66265,METHOD,core\ngx_syslog.c:<global>,TYPE_DECL,static void ngx_syslog_cleanup(void *data);,13,42,core\ngx_syslog.c,ngx_syslog_cleanup,,false,20,20,ngx_syslog_cleanup,,,3,void ngx_syslog_cleanup (void*)
66314,METHOD,core\ngx_syslog.c:<global>,TYPE_DECL,"char *
ngx_syslog_process_conf(ngx_conf_t *cf, ngx_syslog_peer_t *peer)
{
    ngx_pool_cleanup_t  *cln;

    peer->facility = NGX_CONF_UNSET_UINT;
    peer->severity = NGX_CONF_UNSET_UINT;

    if (ngx_syslog_parse_args(cf, peer) != NGX_CONF_OK) {
        return NGX_CONF_ERROR;
    }

    if (peer->server.sockaddr == NULL) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""no syslog server specified"");
        return NGX_CONF_ERROR;
    }

    if (peer->facility == NGX_CONF_UNSET_UINT) {
        peer->facility = 23; /* local7 */
    }

    if (peer->severity == NGX_CONF_UNSET_UINT) {
        peer->severity = 6; /* info */
    }

    if (peer->tag.data == NULL) {
        ngx_str_set(&peer->tag, ""nginx"");
    }

    peer->conn.fd = (ngx_socket_t) -1;

    peer->conn.read = &ngx_syslog_dummy_event;
    peer->conn.write = &ngx_syslog_dummy_event;

    ngx_syslog_dummy_event.log = &ngx_syslog_dummy_log;

    cln = ngx_pool_cleanup_add(cf->pool, 0);
    if (cln...",1,1,core\ngx_syslog.c,ngx_syslog_process_conf,,false,39,85,ngx_syslog_process_conf,,,10,"char* ngx_syslog_process_conf (ngx_conf_t*,ngx_syslog_peer_t*)"
66452,METHOD,core\ngx_syslog.c:<global>,TYPE_DECL,"static char *
ngx_syslog_parse_args(ngx_conf_t *cf, ngx_syslog_peer_t *peer)
{
    u_char      *p, *comma, c;
    size_t       len;
    ngx_str_t   *value;
    ngx_url_t    u;
    ngx_uint_t   i;

    value = cf->args->elts;

    p = value[1].data + sizeof(""syslog:"") - 1;

    for ( ;; ) {
        comma = (u_char *) ngx_strchr(p, ',');

        if (comma != NULL) {
            len = comma - p;
            *comma = '\0';

        } else {
            len = value[1].data + value[1].len - p;
        }

        if (ngx_strncmp(p, ""server="", 7) == 0) {

            if (peer->server.sockaddr != NULL) {
                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                                   ""duplicate syslog \""server\"""");
                return NGX_CONF_ERROR;
            }

            ngx_memzero(&u, sizeof(ngx_url_t));

            u.url.data = p + 7;
            u.url.len = len - 7;
            u.default_port = 514;

            if (ngx_parse_url(cf->pool, &u) != NGX_OK) {
         ...",1,1,core\ngx_syslog.c,ngx_syslog_parse_args,,false,88,230,ngx_syslog_parse_args,,,11,"char* ngx_syslog_parse_args (ngx_conf_t*,ngx_syslog_peer_t*)"
66889,METHOD,core\ngx_syslog.c:<global>,TYPE_DECL,"u_char *
ngx_syslog_add_header(ngx_syslog_peer_t *peer, u_char *buf)
{
    ngx_uint_t  pri;

    pri = peer->facility * 8 + peer->severity;

    if (peer->nohostname) {
        return ngx_sprintf(buf, ""<%ui>%V %V: "", pri, &ngx_cached_syslog_time,
                           &peer->tag);
    }

    return ngx_sprintf(buf, ""<%ui>%V %V %V: "", pri, &ngx_cached_syslog_time,
                       &ngx_cycle->hostname, &peer->tag);
}",1,1,core\ngx_syslog.c,ngx_syslog_add_header,,false,233,247,ngx_syslog_add_header,,,12,"u_char ngx_syslog_add_header (ngx_syslog_peer_t*,u_char*)"
66938,METHOD,core\ngx_syslog.c:<global>,TYPE_DECL,"void
ngx_syslog_writer(ngx_log_t *log, ngx_uint_t level, u_char *buf,
    size_t len)
{
    u_char             *p, msg[NGX_SYSLOG_MAX_STR];
    ngx_uint_t          head_len;
    ngx_syslog_peer_t  *peer;

    peer = log->wdata;

    if (peer->busy) {
        return;
    }

    peer->busy = 1;
    peer->severity = level - 1;

    p = ngx_syslog_add_header(peer, msg);
    head_len = p - msg;

    len -= NGX_LINEFEED_SIZE;

    if (len > NGX_SYSLOG_MAX_STR - head_len) {
        len = NGX_SYSLOG_MAX_STR - head_len;
    }

    p = ngx_snprintf(p, len, ""%s"", buf);

    (void) ngx_syslog_send(peer, msg, p - msg);

    peer->busy = 0;
}",1,31,core\ngx_syslog.c,ngx_syslog_writer,,false,250,281,ngx_syslog_writer,,,13,"void ngx_syslog_writer (ngx_log_t*,ngx_uint_t,u_char*,size_t)"
67052,METHOD,core\ngx_syslog.c:<global>,TYPE_DECL,"ssize_t
ngx_syslog_send(ngx_syslog_peer_t *peer, u_char *buf, size_t len)
{
    ssize_t  n;

    if (peer->conn.fd == (ngx_socket_t) -1) {
        if (ngx_syslog_init_peer(peer) != NGX_OK) {
            return NGX_ERROR;
        }
    }

    /* log syslog socket events with valid log */
    peer->conn.log = ngx_cycle->log;

    if (ngx_send) {
        n = ngx_send(&peer->conn, buf, len);

    } else {
        /* event module has not yet set ngx_io */
        n = ngx_os_io.send(&peer->conn, buf, len);
    }

    if (n == NGX_ERROR) {

        if (ngx_close_socket(peer->conn.fd) == -1) {
            ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, ngx_socket_errno,
                          ngx_close_socket_n "" failed"");
        }

        peer->conn.fd = (ngx_socket_t) -1;
    }

    return n;
}",1,1,core\ngx_syslog.c,ngx_syslog_send,,false,284,317,ngx_syslog_send,,,14,"ssize_t ngx_syslog_send (ngx_syslog_peer_t*,u_char*,size_t)"
67142,METHOD,core\ngx_syslog.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_syslog_init_peer(ngx_syslog_peer_t *peer)
{
    ngx_socket_t  fd;

    fd = ngx_socket(peer->server.sockaddr->sa_family, SOCK_DGRAM, 0);
    if (fd == (ngx_socket_t) -1) {
        ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, ngx_socket_errno,
                      ngx_socket_n "" failed"");
        return NGX_ERROR;
    }

    if (ngx_nonblocking(fd) == -1) {
        ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, ngx_socket_errno,
                      ngx_nonblocking_n "" failed"");
        goto failed;
    }

    if (connect(fd, peer->server.sockaddr, peer->server.socklen) == -1) {
        ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, ngx_socket_errno,
                      ""connect() failed"");
        goto failed;
    }

    peer->conn.fd = fd;

    /* UDP sockets are always ready to write */
    peer->conn.write->ready = 1;

    return NGX_OK;

failed:

    if (ngx_close_socket(fd) == -1) {
        ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, ngx_socket_errno,
    ...",1,1,core\ngx_syslog.c,ngx_syslog_init_peer,,false,320,359,ngx_syslog_init_peer,,,15,ngx_int_t ngx_syslog_init_peer (ngx_syslog_peer_t*)
67233,METHOD,core\ngx_syslog.c:<global>,TYPE_DECL,"static void
ngx_syslog_cleanup(void *data)
{
    ngx_syslog_peer_t  *peer = data;

    /* prevents further use of this peer */
    peer->busy = 1;

    if (peer->conn.fd == (ngx_socket_t) -1) {
        return;
    }

    if (ngx_close_socket(peer->conn.fd) == -1) {
        ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, ngx_socket_errno,
                      ngx_close_socket_n "" failed"");
    }
}",1,1,core\ngx_syslog.c,ngx_syslog_cleanup,,false,362,378,ngx_syslog_cleanup,,,16,void ngx_syslog_cleanup (void*)
67274,METHOD,core\ngx_syslog.h:<global>,TYPE_DECL,<global>,1,36,core\ngx_syslog.h,core\ngx_syslog.h:<global>,,false,1,30,<global>,,,1,
67285,METHOD,core\ngx_syslog.h:<global>,TYPE_DECL,"char *ngx_syslog_process_conf(ngx_conf_t *cf, ngx_syslog_peer_t *peer);",6,70,core\ngx_syslog.h,ngx_syslog_process_conf,,false,23,23,ngx_syslog_process_conf,,,3,"char* ngx_syslog_process_conf (ngx_conf_t*,ngx_syslog_peer_t*)"
67291,METHOD,core\ngx_syslog.h:<global>,TYPE_DECL,"u_char *ngx_syslog_add_header(ngx_syslog_peer_t *peer, u_char *buf);",8,67,core\ngx_syslog.h,ngx_syslog_add_header,,false,24,24,ngx_syslog_add_header,,,4,"u_char* ngx_syslog_add_header (ngx_syslog_peer_t*,u_char*)"
67297,METHOD,core\ngx_syslog.h:<global>,TYPE_DECL,"void ngx_syslog_writer(ngx_log_t *log, ngx_uint_t level, u_char *buf,
    size_t len);",6,15,core\ngx_syslog.h,ngx_syslog_writer,,false,25,26,ngx_syslog_writer,,,5,"void ngx_syslog_writer (ngx_log_t*,ngx_uint_t,u_char*,size_t)"
67305,METHOD,core\ngx_syslog.h:<global>,TYPE_DECL,"ssize_t ngx_syslog_send(ngx_syslog_peer_t *peer, u_char *buf, size_t len);",9,73,core\ngx_syslog.h,ngx_syslog_send,,false,27,27,ngx_syslog_send,,,6,"ssize_t ngx_syslog_send (ngx_syslog_peer_t*,u_char*,size_t)"
67321,METHOD,core\ngx_thread_pool.c:<global>,TYPE_DECL,<global>,1,4,core\ngx_thread_pool.c,core\ngx_thread_pool.c:<global>,,false,1,641,<global>,,,1,
67341,METHOD,core\ngx_thread_pool.c:<global>,TYPE_DECL,"static ngx_int_t ngx_thread_pool_init(ngx_thread_pool_t *tp, ngx_log_t *log,
    ngx_pool_t *pool);",18,21,core\ngx_thread_pool.c,ngx_thread_pool_init,,false,46,47,ngx_thread_pool_init,,,6,"ngx_int_t ngx_thread_pool_init (ngx_thread_pool_t*,ngx_log_t*,ngx_pool_t*)"
67348,METHOD,core\ngx_thread_pool.c:<global>,TYPE_DECL,static void ngx_thread_pool_destroy(ngx_thread_pool_t *tp);,13,58,core\ngx_thread_pool.c,ngx_thread_pool_destroy,,false,48,48,ngx_thread_pool_destroy,,,7,void ngx_thread_pool_destroy (ngx_thread_pool_t*)
67353,METHOD,core\ngx_thread_pool.c:<global>,TYPE_DECL,"static void ngx_thread_pool_exit_handler(void *data, ngx_log_t *log);",13,68,core\ngx_thread_pool.c,ngx_thread_pool_exit_handler,,false,49,49,ngx_thread_pool_exit_handler,,,8,"void ngx_thread_pool_exit_handler (void*,ngx_log_t*)"
67359,METHOD,core\ngx_thread_pool.c:<global>,TYPE_DECL,static void *ngx_thread_pool_cycle(void *data);,13,46,core\ngx_thread_pool.c,ngx_thread_pool_cycle,,false,51,51,ngx_thread_pool_cycle,,,9,void* ngx_thread_pool_cycle (void*)
67364,METHOD,core\ngx_thread_pool.c:<global>,TYPE_DECL,static void ngx_thread_pool_handler(ngx_event_t *ev);,13,52,core\ngx_thread_pool.c,ngx_thread_pool_handler,,false,52,52,ngx_thread_pool_handler,,,10,void ngx_thread_pool_handler (ngx_event_t*)
67369,METHOD,core\ngx_thread_pool.c:<global>,TYPE_DECL,"static char *ngx_thread_pool(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",13,76,core\ngx_thread_pool.c,ngx_thread_pool,,false,54,54,ngx_thread_pool,,,11,"char* ngx_thread_pool (ngx_conf_t*,ngx_command_t*,void*)"
67376,METHOD,core\ngx_thread_pool.c:<global>,TYPE_DECL,static void *ngx_thread_pool_create_conf(ngx_cycle_t *cycle);,13,60,core\ngx_thread_pool.c,ngx_thread_pool_create_conf,,false,56,56,ngx_thread_pool_create_conf,,,12,void* ngx_thread_pool_create_conf (ngx_cycle_t*)
67381,METHOD,core\ngx_thread_pool.c:<global>,TYPE_DECL,"static char *ngx_thread_pool_init_conf(ngx_cycle_t *cycle, void *conf);",13,70,core\ngx_thread_pool.c,ngx_thread_pool_init_conf,,false,57,57,ngx_thread_pool_init_conf,,,13,"char* ngx_thread_pool_init_conf (ngx_cycle_t*,void*)"
67387,METHOD,core\ngx_thread_pool.c:<global>,TYPE_DECL,static ngx_int_t ngx_thread_pool_init_worker(ngx_cycle_t *cycle);,18,64,core\ngx_thread_pool.c,ngx_thread_pool_init_worker,,false,59,59,ngx_thread_pool_init_worker,,,14,ngx_int_t ngx_thread_pool_init_worker (ngx_cycle_t*)
67392,METHOD,core\ngx_thread_pool.c:<global>,TYPE_DECL,static void ngx_thread_pool_exit_worker(ngx_cycle_t *cycle);,13,59,core\ngx_thread_pool.c,ngx_thread_pool_exit_worker,,false,60,60,ngx_thread_pool_exit_worker,,,15,void ngx_thread_pool_exit_worker (ngx_cycle_t*)
67447,METHOD,core\ngx_thread_pool.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_thread_pool_init(ngx_thread_pool_t *tp, ngx_log_t *log, ngx_pool_t *pool)
{
    int             err;
    pthread_t       tid;
    ngx_uint_t      n;
    pthread_attr_t  attr;

    if (ngx_notify == NULL) {
        ngx_log_error(NGX_LOG_ALERT, log, 0,
               ""the configured event method cannot be used with thread pools"");
        return NGX_ERROR;
    }

    ngx_thread_pool_queue_init(&tp->queue);

    if (ngx_thread_mutex_create(&tp->mtx, log) != NGX_OK) {
        return NGX_ERROR;
    }

    if (ngx_thread_cond_create(&tp->cond, log) != NGX_OK) {
        (void) ngx_thread_mutex_destroy(&tp->mtx, log);
        return NGX_ERROR;
    }

    tp->log = log;

    err = pthread_attr_init(&attr);
    if (err) {
        ngx_log_error(NGX_LOG_ALERT, log, err,
                      ""pthread_attr_init() failed"");
        return NGX_ERROR;
    }

    err = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    if (err) {
        ngx_log_error(NGX_LOG_ALERT...",1,4,core\ngx_thread_pool.c,ngx_thread_pool_init,,false,106,168,ngx_thread_pool_init,,,27,"ngx_int_t ngx_thread_pool_init (ngx_thread_pool_t*,ngx_log_t*,ngx_pool_t*)"
67605,METHOD,core\ngx_thread_pool.c:<global>,TYPE_DECL,"static void
ngx_thread_pool_destroy(ngx_thread_pool_t *tp)
{
    ngx_uint_t           n;
    ngx_thread_task_t    task;
    volatile ngx_uint_t  lock;

    ngx_memzero(&task, sizeof(ngx_thread_task_t));

    task.handler = ngx_thread_pool_exit_handler;
    task.ctx = (void *) &lock;

    for (n = 0; n < tp->threads; n++) {
        lock = 1;

        if (ngx_thread_task_post(tp, &task) != NGX_OK) {
            return;
        }

        while (lock) {
            ngx_sched_yield();
        }

        task.event.active = 0;
    }

    (void) ngx_thread_cond_destroy(&tp->cond, tp->log);

    (void) ngx_thread_mutex_destroy(&tp->mtx, tp->log);
}",1,1,core\ngx_thread_pool.c,ngx_thread_pool_destroy,,false,171,200,ngx_thread_pool_destroy,,,28,void ngx_thread_pool_destroy (ngx_thread_pool_t*)
67687,METHOD,core\ngx_thread_pool.c:<global>,TYPE_DECL,"static void
ngx_thread_pool_exit_handler(void *data, ngx_log_t *log)
{
    ngx_uint_t *lock = data;

    *lock = 0;

    pthread_exit(0);
}",1,1,core\ngx_thread_pool.c,ngx_thread_pool_exit_handler,,false,203,211,ngx_thread_pool_exit_handler,,,29,"void ngx_thread_pool_exit_handler (void*,ngx_log_t*)"
67703,METHOD,core\ngx_thread_pool.c:<global>,TYPE_DECL,"ngx_thread_task_t *
ngx_thread_task_alloc(ngx_pool_t *pool, size_t size)
{
    ngx_thread_task_t  *task;

    task = ngx_pcalloc(pool, sizeof(ngx_thread_task_t) + size);
    if (task == NULL) {
        return NULL;
    }

    task->ctx = task + 1;

    return task;
}",1,1,core\ngx_thread_pool.c,ngx_thread_task_alloc,,false,214,227,ngx_thread_task_alloc,,,30,"ngx_thread_task_t ngx_thread_task_alloc (ngx_pool_t*,size_t)"
67734,METHOD,core\ngx_thread_pool.c:<global>,TYPE_DECL,"ngx_int_t
ngx_thread_task_post(ngx_thread_pool_t *tp, ngx_thread_task_t *task)
{
    if (task->event.active) {
        ngx_log_error(NGX_LOG_ALERT, tp->log, 0,
                      ""task #%ui already active"", task->id);
        return NGX_ERROR;
    }

    if (ngx_thread_mutex_lock(&tp->mtx, tp->log) != NGX_OK) {
        return NGX_ERROR;
    }

    if (tp->waiting >= tp->max_queue) {
        (void) ngx_thread_mutex_unlock(&tp->mtx, tp->log);

        ngx_log_error(NGX_LOG_ERR, tp->log, 0,
                      ""thread pool \""%V\"" queue overflow: %i tasks waiting"",
                      &tp->name, tp->waiting);
        return NGX_ERROR;
    }

    task->event.active = 1;

    task->id = ngx_thread_pool_task_id++;
    task->next = NULL;

    if (ngx_thread_cond_signal(&tp->cond, tp->log) != NGX_OK) {
        (void) ngx_thread_mutex_unlock(&tp->mtx, tp->log);
        return NGX_ERROR;
    }

    *tp->queue.last = task;
    tp->queue.last = &task->next;

    tp->waiting++;

    (void)...",1,1,core\ngx_thread_pool.c,ngx_thread_task_post,,false,230,274,ngx_thread_task_post,,,31,"ngx_int_t ngx_thread_task_post (ngx_thread_pool_t*,ngx_thread_task_t*)"
67898,METHOD,core\ngx_thread_pool.c:<global>,TYPE_DECL,"static void *
ngx_thread_pool_cycle(void *data)
{
    ngx_thread_pool_t *tp = data;

    int                 err;
    sigset_t            set;
    ngx_thread_task_t  *task;

#if 0
    ngx_time_update();
#endif

    ngx_log_debug1(NGX_LOG_DEBUG_CORE, tp->log, 0,
                   ""thread in pool \""%V\"" started"", &tp->name);

    sigfillset(&set);

    sigdelset(&set, SIGILL);
    sigdelset(&set, SIGFPE);
    sigdelset(&set, SIGSEGV);
    sigdelset(&set, SIGBUS);

    err = pthread_sigmask(SIG_BLOCK, &set, NULL);
    if (err) {
        ngx_log_error(NGX_LOG_ALERT, tp->log, err, ""pthread_sigmask() failed"");
        return NULL;
    }

    for ( ;; ) {
        if (ngx_thread_mutex_lock(&tp->mtx, tp->log) != NGX_OK) {
            return NULL;
        }

        /* the number may become negative */
        tp->waiting--;

        while (tp->queue.first == NULL) {
            if (ngx_thread_cond_wait(&tp->cond, &tp->mtx, tp->log)
                != NGX_OK)
            {
                (v...",1,1,core\ngx_thread_pool.c,ngx_thread_pool_cycle,,false,277,361,ngx_thread_pool_cycle,,,32,void* ngx_thread_pool_cycle (void*)
68138,METHOD,core\ngx_thread_pool.c:<global>,TYPE_DECL,"static void
ngx_thread_pool_handler(ngx_event_t *ev)
{
    ngx_event_t        *event;
    ngx_thread_task_t  *task;

    ngx_log_debug0(NGX_LOG_DEBUG_CORE, ev->log, 0, ""thread pool handler"");

    ngx_spinlock(&ngx_thread_pool_done_lock, 1, 2048);

    task = ngx_thread_pool_done.first;
    ngx_thread_pool_done.first = NULL;
    ngx_thread_pool_done.last = &ngx_thread_pool_done.first;

    ngx_memory_barrier();

    ngx_unlock(&ngx_thread_pool_done_lock);

    while (task) {
        ngx_log_debug1(NGX_LOG_DEBUG_CORE, ev->log, 0,
                       ""run completion handler for task #%ui"", task->id);

        event = &task->event;
        task = task->next;

        event->complete = 1;
        event->active = 0;

        event->handler(event);
    }
}",1,1,core\ngx_thread_pool.c,ngx_thread_pool_handler,,false,364,394,ngx_thread_pool_handler,,,33,void ngx_thread_pool_handler (ngx_event_t*)
68218,METHOD,core\ngx_thread_pool.c:<global>,TYPE_DECL,"static void *
ngx_thread_pool_create_conf(ngx_cycle_t *cycle)
{
    ngx_thread_pool_conf_t  *tcf;

    tcf = ngx_pcalloc(cycle->pool, sizeof(ngx_thread_pool_conf_t));
    if (tcf == NULL) {
        return NULL;
    }

    if (ngx_array_init(&tcf->pools, cycle->pool, 4,
                       sizeof(ngx_thread_pool_t *))
        != NGX_OK)
    {
        return NULL;
    }

    return tcf;
}",1,1,core\ngx_thread_pool.c,ngx_thread_pool_create_conf,,false,397,415,ngx_thread_pool_create_conf,,,34,void* ngx_thread_pool_create_conf (ngx_cycle_t*)
68258,METHOD,core\ngx_thread_pool.c:<global>,TYPE_DECL,"static char *
ngx_thread_pool_init_conf(ngx_cycle_t *cycle, void *conf)
{
    ngx_thread_pool_conf_t *tcf = conf;

    ngx_uint_t           i;
    ngx_thread_pool_t  **tpp;

    tpp = tcf->pools.elts;

    for (i = 0; i < tcf->pools.nelts; i++) {

        if (tpp[i]->threads) {
            continue;
        }

        if (tpp[i]->name.len == ngx_thread_pool_default.len
            && ngx_strncmp(tpp[i]->name.data, ngx_thread_pool_default.data,
                           ngx_thread_pool_default.len)
               == 0)
        {
            tpp[i]->threads = 32;
            tpp[i]->max_queue = 65536;
            continue;
        }

        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
                      ""unknown thread pool \""%V\"" in %s:%ui"",
                      &tpp[i]->name, tpp[i]->file, tpp[i]->line);

        return NGX_CONF_ERROR;
    }

    return NGX_CONF_OK;
}",1,1,core\ngx_thread_pool.c,ngx_thread_pool_init_conf,,false,418,452,ngx_thread_pool_init_conf,,,35,"char* ngx_thread_pool_init_conf (ngx_cycle_t*,void*)"
68372,METHOD,core\ngx_thread_pool.c:<global>,TYPE_DECL,"static char *
ngx_thread_pool(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_str_t          *value;
    ngx_uint_t          i;
    ngx_thread_pool_t  *tp;

    value = cf->args->elts;

    tp = ngx_thread_pool_add(cf, &value[1]);

    if (tp == NULL) {
        return NGX_CONF_ERROR;
    }

    if (tp->threads) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""duplicate thread pool \""%V\"""", &tp->name);
        return NGX_CONF_ERROR;
    }

    tp->max_queue = 65536;

    for (i = 2; i < cf->args->nelts; i++) {

        if (ngx_strncmp(value[i].data, ""threads="", 8) == 0) {

            tp->threads = ngx_atoi(value[i].data + 8, value[i].len - 8);

            if (tp->threads == (ngx_uint_t) NGX_ERROR || tp->threads == 0) {
                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                                   ""invalid threads value \""%V\"""", &value[i]);
                return NGX_CONF_ERROR;
            }

            continue;
        }

    ...",1,1,core\ngx_thread_pool.c,ngx_thread_pool,,false,455,515,ngx_thread_pool,,,36,"char* ngx_thread_pool (ngx_conf_t*,ngx_command_t*,void*)"
68568,METHOD,core\ngx_thread_pool.c:<global>,TYPE_DECL,"ngx_thread_pool_t *
ngx_thread_pool_add(ngx_conf_t *cf, ngx_str_t *name)
{
    ngx_thread_pool_t       *tp, **tpp;
    ngx_thread_pool_conf_t  *tcf;

    if (name == NULL) {
        name = &ngx_thread_pool_default;
    }

    tp = ngx_thread_pool_get(cf->cycle, name);

    if (tp) {
        return tp;
    }

    tp = ngx_pcalloc(cf->pool, sizeof(ngx_thread_pool_t));
    if (tp == NULL) {
        return NULL;
    }

    tp->name = *name;
    tp->file = cf->conf_file->file.name.data;
    tp->line = cf->conf_file->line;

    tcf = (ngx_thread_pool_conf_t *) ngx_get_conf(cf->cycle->conf_ctx,
                                                  ngx_thread_pool_module);

    tpp = ngx_array_push(&tcf->pools);
    if (tpp == NULL) {
        return NULL;
    }

    *tpp = tp;

    return tp;
}",1,1,core\ngx_thread_pool.c,ngx_thread_pool_add,,false,518,554,ngx_thread_pool_add,,,37,"ngx_thread_pool_t ngx_thread_pool_add (ngx_conf_t*,ngx_str_t*)"
68672,METHOD,core\ngx_thread_pool.c:<global>,TYPE_DECL,"ngx_thread_pool_t *
ngx_thread_pool_get(ngx_cycle_t *cycle, ngx_str_t *name)
{
    ngx_uint_t                i;
    ngx_thread_pool_t       **tpp;
    ngx_thread_pool_conf_t   *tcf;

    tcf = (ngx_thread_pool_conf_t *) ngx_get_conf(cycle->conf_ctx,
                                                  ngx_thread_pool_module);

    tpp = tcf->pools.elts;

    for (i = 0; i < tcf->pools.nelts; i++) {

        if (tpp[i]->name.len == name->len
            && ngx_strncmp(tpp[i]->name.data, name->data, name->len) == 0)
        {
            return tpp[i];
        }
    }

    return NULL;
}",1,1,core\ngx_thread_pool.c,ngx_thread_pool_get,,false,557,579,ngx_thread_pool_get,,,38,"ngx_thread_pool_t ngx_thread_pool_get (ngx_cycle_t*,ngx_str_t*)"
68748,METHOD,core\ngx_thread_pool.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_thread_pool_init_worker(ngx_cycle_t *cycle)
{
    ngx_uint_t                i;
    ngx_thread_pool_t       **tpp;
    ngx_thread_pool_conf_t   *tcf;

    if (ngx_process != NGX_PROCESS_WORKER
        && ngx_process != NGX_PROCESS_SINGLE)
    {
        return NGX_OK;
    }

    tcf = (ngx_thread_pool_conf_t *) ngx_get_conf(cycle->conf_ctx,
                                                  ngx_thread_pool_module);

    if (tcf == NULL) {
        return NGX_OK;
    }

    ngx_thread_pool_queue_init(&ngx_thread_pool_done);

    tpp = tcf->pools.elts;

    for (i = 0; i < tcf->pools.nelts; i++) {
        if (ngx_thread_pool_init(tpp[i], cycle->log, cycle->pool) != NGX_OK) {
            return NGX_ERROR;
        }
    }

    return NGX_OK;
}",1,4,core\ngx_thread_pool.c,ngx_thread_pool_init_worker,,false,582,613,ngx_thread_pool_init_worker,,,39,ngx_int_t ngx_thread_pool_init_worker (ngx_cycle_t*)
68843,METHOD,core\ngx_thread_pool.c:<global>,TYPE_DECL,"static void
ngx_thread_pool_exit_worker(ngx_cycle_t *cycle)
{
    ngx_uint_t                i;
    ngx_thread_pool_t       **tpp;
    ngx_thread_pool_conf_t   *tcf;

    if (ngx_process != NGX_PROCESS_WORKER
        && ngx_process != NGX_PROCESS_SINGLE)
    {
        return;
    }

    tcf = (ngx_thread_pool_conf_t *) ngx_get_conf(cycle->conf_ctx,
                                                  ngx_thread_pool_module);

    if (tcf == NULL) {
        return;
    }

    tpp = tcf->pools.elts;

    for (i = 0; i < tcf->pools.nelts; i++) {
        ngx_thread_pool_destroy(tpp[i]);
    }
}",1,1,core\ngx_thread_pool.c,ngx_thread_pool_exit_worker,,false,616,641,ngx_thread_pool_exit_worker,,,40,void ngx_thread_pool_exit_worker (ngx_cycle_t*)
68911,METHOD,core\ngx_thread_pool.h:<global>,TYPE_DECL,<global>,1,41,core\ngx_thread_pool.h,core\ngx_thread_pool.h:<global>,,false,1,36,<global>,,,1,
68917,METHOD,ngx_thread_task_s,TYPE_DECL,"void               (*handler)(void *data, ngx_log_t *log);",24,61,core\ngx_thread_pool.h,ngx_thread_task_s.handler,,false,21,21,handler,,,4,"void ngx_thread_task_s.handler (void*,ngx_log_t*)"
68926,METHOD,core\ngx_thread_pool.h:<global>,TYPE_DECL,"ngx_thread_pool_t *ngx_thread_pool_add(ngx_conf_t *cf, ngx_str_t *name);",19,71,core\ngx_thread_pool.h,ngx_thread_pool_add,,false,29,29,ngx_thread_pool_add,,,4,"ngx_thread_pool_t* ngx_thread_pool_add (ngx_conf_t*,ngx_str_t*)"
68932,METHOD,core\ngx_thread_pool.h:<global>,TYPE_DECL,"ngx_thread_pool_t *ngx_thread_pool_get(ngx_cycle_t *cycle, ngx_str_t *name);",19,75,core\ngx_thread_pool.h,ngx_thread_pool_get,,false,30,30,ngx_thread_pool_get,,,5,"ngx_thread_pool_t* ngx_thread_pool_get (ngx_cycle_t*,ngx_str_t*)"
68938,METHOD,core\ngx_thread_pool.h:<global>,TYPE_DECL,"ngx_thread_task_t *ngx_thread_task_alloc(ngx_pool_t *pool, size_t size);",19,71,core\ngx_thread_pool.h,ngx_thread_task_alloc,,false,32,32,ngx_thread_task_alloc,,,6,"ngx_thread_task_t* ngx_thread_task_alloc (ngx_pool_t*,size_t)"
68944,METHOD,core\ngx_thread_pool.h:<global>,TYPE_DECL,"ngx_int_t ngx_thread_task_post(ngx_thread_pool_t *tp, ngx_thread_task_t *task);",11,78,core\ngx_thread_pool.h,ngx_thread_task_post,,false,33,33,ngx_thread_task_post,,,7,"ngx_int_t ngx_thread_task_post (ngx_thread_pool_t*,ngx_thread_task_t*)"
68957,METHOD,core\ngx_times.c:<global>,TYPE_DECL,<global>,1,37,core\ngx_times.c,core\ngx_times.c:<global>,,false,1,468,<global>,,,1,
68959,METHOD,core\ngx_times.c:<global>,TYPE_DECL,"static ngx_msec_t ngx_monotonic_time(time_t sec, ngx_uint_t msec);",19,65,core\ngx_times.c,ngx_monotonic_time,,false,12,12,ngx_monotonic_time,,,1,"ngx_msec_t ngx_monotonic_time (time_t,ngx_uint_t)"
69042,METHOD,core\ngx_times.c:<global>,TYPE_DECL,"void
ngx_time_init(void)
{
    ngx_cached_err_log_time.len = sizeof(""1970/09/28 12:00:00"") - 1;
    ngx_cached_http_time.len = sizeof(""Mon, 28 Sep 1970 06:00:00 GMT"") - 1;
    ngx_cached_http_log_time.len = sizeof(""28/Sep/1970:12:00:00 +0600"") - 1;
    ngx_cached_http_log_iso8601.len = sizeof(""1970-09-28T12:00:00+06:00"") - 1;
    ngx_cached_syslog_time.len = sizeof(""Sep 28 12:00:00"") - 1;

    ngx_cached_time = &cached_time[0];

    ngx_time_update();
}",1,1,core\ngx_times.c,ngx_time_init,,false,65,77,ngx_time_init,,,28,void ngx_time_init (void)
69094,METHOD,core\ngx_times.c:<global>,TYPE_DECL,"void
ngx_time_update(void)
{
    u_char          *p0, *p1, *p2, *p3, *p4;
    ngx_tm_t         tm, gmt;
    time_t           sec;
    ngx_uint_t       msec;
    ngx_time_t      *tp;
    struct timeval   tv;

    if (!ngx_trylock(&ngx_time_lock)) {
        return;
    }

    ngx_gettimeofday(&tv);

    sec = tv.tv_sec;
    msec = tv.tv_usec / 1000;

    ngx_current_msec = ngx_monotonic_time(sec, msec);

    tp = &cached_time[slot];

    if (tp->sec == sec) {
        tp->msec = msec;
        ngx_unlock(&ngx_time_lock);
        return;
    }

    if (slot == NGX_TIME_SLOTS - 1) {
        slot = 0;
    } else {
        slot++;
    }

    tp = &cached_time[slot];

    tp->sec = sec;
    tp->msec = msec;

    ngx_gmtime(sec, &gmt);


    p0 = &cached_http_time[slot][0];

    (void) ngx_sprintf(p0, ""%s, %02d %s %4d %02d:%02d:%02d GMT"",
                       week[gmt.ngx_tm_wday], gmt.ngx_tm_mday,
                       months[gmt.ngx_tm_mon - 1], gmt.ngx_tm_year,
                       gm...",1,16,core\ngx_times.c,ngx_time_update,,false,80,192,ngx_time_update,,,29,void ngx_time_update (void)
69451,METHOD,core\ngx_times.c:<global>,TYPE_DECL,"static ngx_msec_t
ngx_monotonic_time(time_t sec, ngx_uint_t msec)
{
#if (NGX_HAVE_CLOCK_MONOTONIC)
    struct timespec  ts;

#if defined(CLOCK_MONOTONIC_FAST)
    clock_gettime(CLOCK_MONOTONIC_FAST, &ts);

#elif defined(CLOCK_MONOTONIC_COARSE)
    clock_gettime(CLOCK_MONOTONIC_COARSE, &ts);

#else
    clock_gettime(CLOCK_MONOTONIC, &ts);
#endif

    sec = ts.tv_sec;
    msec = ts.tv_nsec / 1000000;

#endif

    return (ngx_msec_t) sec * 1000 + msec;
}",1,1,core\ngx_times.c,ngx_monotonic_time,,false,195,217,ngx_monotonic_time,,,30,"ngx_msec_t ngx_monotonic_time (time_t,ngx_uint_t)"
69465,METHOD,core\ngx_times.c:<global>,TYPE_DECL,"void
ngx_time_sigsafe_update(void)
{
    u_char          *p, *p2;
    ngx_tm_t         tm;
    time_t           sec;
    ngx_time_t      *tp;
    struct timeval   tv;

    if (!ngx_trylock(&ngx_time_lock)) {
        return;
    }

    ngx_gettimeofday(&tv);

    sec = tv.tv_sec;

    tp = &cached_time[slot];

    if (tp->sec == sec) {
        ngx_unlock(&ngx_time_lock);
        return;
    }

    if (slot == NGX_TIME_SLOTS - 1) {
        slot = 0;
    } else {
        slot++;
    }

    tp = &cached_time[slot];

    tp->sec = 0;

    ngx_gmtime(sec + cached_gmtoff * 60, &tm);

    p = &cached_err_log_time[slot][0];

    (void) ngx_sprintf(p, ""%4d/%02d/%02d %02d:%02d:%02d"",
                       tm.ngx_tm_year, tm.ngx_tm_mon,
                       tm.ngx_tm_mday, tm.ngx_tm_hour,
                       tm.ngx_tm_min, tm.ngx_tm_sec);

    p2 = &cached_syslog_time[slot][0];

    (void) ngx_sprintf(p2, ""%s %2d %02d:%02d:%02d"",
                       months[tm.ngx_tm_mon - 1], tm.ngx_tm...",1,16,core\ngx_times.c,ngx_time_sigsafe_update,,false,222,277,ngx_time_sigsafe_update,,,31,void ngx_time_sigsafe_update (void)
69620,METHOD,core\ngx_times.c:<global>,TYPE_DECL,"u_char *
ngx_http_time(u_char *buf, time_t t)
{
    ngx_tm_t  tm;

    ngx_gmtime(t, &tm);

    return ngx_sprintf(buf, ""%s, %02d %s %4d %02d:%02d:%02d GMT"",
                       week[tm.ngx_tm_wday],
                       tm.ngx_tm_mday,
                       months[tm.ngx_tm_mon - 1],
                       tm.ngx_tm_year,
                       tm.ngx_tm_hour,
                       tm.ngx_tm_min,
                       tm.ngx_tm_sec);
}",1,1,core\ngx_times.c,ngx_http_time,,false,282,297,ngx_http_time,,,32,"u_char ngx_http_time (u_char*,time_t)"
69662,METHOD,core\ngx_times.c:<global>,TYPE_DECL,"u_char *
ngx_http_cookie_time(u_char *buf, time_t t)
{
    ngx_tm_t  tm;

    ngx_gmtime(t, &tm);

    /*
     * Netscape 3.x does not understand 4-digit years at all and
     * 2-digit years more than ""37""
     */

    return ngx_sprintf(buf,
                       (tm.ngx_tm_year > 2037) ?
                                         ""%s, %02d-%s-%d %02d:%02d:%02d GMT"":
                                         ""%s, %02d-%s-%02d %02d:%02d:%02d GMT"",
                       week[tm.ngx_tm_wday],
                       tm.ngx_tm_mday,
                       months[tm.ngx_tm_mon - 1],
                       (tm.ngx_tm_year > 2037) ? tm.ngx_tm_year:
                                                 tm.ngx_tm_year % 100,
                       tm.ngx_tm_hour,
                       tm.ngx_tm_min,
                       tm.ngx_tm_sec);
}",1,1,core\ngx_times.c,ngx_http_cookie_time,,false,300,324,ngx_http_cookie_time,,,33,"u_char ngx_http_cookie_time (u_char*,time_t)"
69722,METHOD,core\ngx_times.c:<global>,TYPE_DECL,"void
ngx_gmtime(time_t t, ngx_tm_t *tp)
{
    ngx_int_t   yday;
    ngx_uint_t  sec, min, hour, mday, mon, year, wday, days, leap;

    /* the calculation is valid for positive time_t only */

    if (t < 0) {
        t = 0;
    }

    days = t / 86400;
    sec = t % 86400;

    /*
     * no more than 4 year digits supported,
     * truncate to December 31, 9999, 23:59:59
     */

    if (days > 2932896) {
        days = 2932896;
        sec = 86399;
    }

    /* January 1, 1970 was Thursday */

    wday = (4 + days) % 7;

    hour = sec / 3600;
    sec %= 3600;
    min = sec / 60;
    sec %= 60;

    /*
     * the algorithm based on Gauss' formula,
     * see src/core/ngx_parse_time.c
     */

    /* days since March 1, 1 BC */
    days = days - (31 + 28) + 719527;

    /*
     * The ""days"" should be adjusted to 1 only, however, some March 1st's go
     * to previous year, so we adjust them to 2.  This causes also shift of the
     * last February days to next year, but we catch t...",1,1,core\ngx_times.c,ngx_gmtime,,false,327,429,ngx_gmtime,,,34,"void ngx_gmtime (time_t,ngx_tm_t*)"
69952,METHOD,core\ngx_times.c:<global>,TYPE_DECL,"time_t
ngx_next_time(time_t when)
{
    time_t     now, next;
    struct tm  tm;

    now = ngx_time();

    ngx_libc_localtime(now, &tm);

    tm.tm_hour = (int) (when / 3600);
    when %= 3600;
    tm.tm_min = (int) (when / 60);
    tm.tm_sec = (int) (when % 60);

    next = mktime(&tm);

    if (next == -1) {
        return -1;
    }

    if (next - now > 0) {
        return next;
    }

    tm.tm_mday++;

    /* mktime() should normalize a date (Jan 32, etc) */

    next = mktime(&tm);

    if (next != -1) {
        return next;
    }

    return -1;
}",1,1,core\ngx_times.c,ngx_next_time,,false,432,468,ngx_next_time,,,35,time_t ngx_next_time (time_t)
70047,METHOD,core\ngx_times.h:<global>,TYPE_DECL,<global>,1,35,core\ngx_times.h,core\ngx_times.h:<global>,,false,1,52,<global>,,,1,
70054,METHOD,core\ngx_times.h:<global>,TYPE_DECL,void ngx_time_init(void);,6,24,core\ngx_times.h,ngx_time_init,,false,23,23,ngx_time_init,,,3,void ngx_time_init (void)
70059,METHOD,core\ngx_times.h:<global>,TYPE_DECL,void ngx_time_update(void);,6,26,core\ngx_times.h,ngx_time_update,,false,24,24,ngx_time_update,,,4,void ngx_time_update (void)
70064,METHOD,core\ngx_times.h:<global>,TYPE_DECL,void ngx_time_sigsafe_update(void);,6,34,core\ngx_times.h,ngx_time_sigsafe_update,,false,25,25,ngx_time_sigsafe_update,,,5,void ngx_time_sigsafe_update (void)
70069,METHOD,core\ngx_times.h:<global>,TYPE_DECL,"u_char *ngx_http_time(u_char *buf, time_t t);",8,44,core\ngx_times.h,ngx_http_time,,false,26,26,ngx_http_time,,,6,"u_char* ngx_http_time (u_char*,time_t)"
70075,METHOD,core\ngx_times.h:<global>,TYPE_DECL,"u_char *ngx_http_cookie_time(u_char *buf, time_t t);",8,51,core\ngx_times.h,ngx_http_cookie_time,,false,27,27,ngx_http_cookie_time,,,7,"u_char* ngx_http_cookie_time (u_char*,time_t)"
70081,METHOD,core\ngx_times.h:<global>,TYPE_DECL,"void ngx_gmtime(time_t t, ngx_tm_t *tp);",6,39,core\ngx_times.h,ngx_gmtime,,false,28,28,ngx_gmtime,,,8,"void ngx_gmtime (time_t,ngx_tm_t*)"
70087,METHOD,core\ngx_times.h:<global>,TYPE_DECL,time_t ngx_next_time(time_t when);,8,33,core\ngx_times.h,ngx_next_time,,false,30,30,ngx_next_time,,,9,time_t ngx_next_time (time_t)
70108,METHOD,event\modules\ngx_devpoll_module.c:<global>,TYPE_DECL,<global>,1,1,event\modules\ngx_devpoll_module.c,event\modules\ngx_devpoll_module.c:<global>,,false,1,561,<global>,,,1,
70114,METHOD,event\modules\ngx_devpoll_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_devpoll_init(ngx_cycle_t *cycle, ngx_msec_t timer);",18,71,event\modules\ngx_devpoll_module.c,ngx_devpoll_init,,false,38,38,ngx_devpoll_init,,,3,"ngx_int_t ngx_devpoll_init (ngx_cycle_t*,ngx_msec_t)"
70120,METHOD,event\modules\ngx_devpoll_module.c:<global>,TYPE_DECL,static void ngx_devpoll_done(ngx_cycle_t *cycle);,13,48,event\modules\ngx_devpoll_module.c,ngx_devpoll_done,,false,39,39,ngx_devpoll_done,,,4,void ngx_devpoll_done (ngx_cycle_t*)
70125,METHOD,event\modules\ngx_devpoll_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_devpoll_add_event(ngx_event_t *ev, ngx_int_t event,
    ngx_uint_t flags);",18,21,event\modules\ngx_devpoll_module.c,ngx_devpoll_add_event,,false,40,41,ngx_devpoll_add_event,,,5,"ngx_int_t ngx_devpoll_add_event (ngx_event_t*,ngx_int_t,ngx_uint_t)"
70132,METHOD,event\modules\ngx_devpoll_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_devpoll_del_event(ngx_event_t *ev, ngx_int_t event,
    ngx_uint_t flags);",18,21,event\modules\ngx_devpoll_module.c,ngx_devpoll_del_event,,false,42,43,ngx_devpoll_del_event,,,6,"ngx_int_t ngx_devpoll_del_event (ngx_event_t*,ngx_int_t,ngx_uint_t)"
70139,METHOD,event\modules\ngx_devpoll_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_devpoll_set_event(ngx_event_t *ev, ngx_int_t event,
    ngx_uint_t flags);",18,21,event\modules\ngx_devpoll_module.c,ngx_devpoll_set_event,,false,44,45,ngx_devpoll_set_event,,,7,"ngx_int_t ngx_devpoll_set_event (ngx_event_t*,ngx_int_t,ngx_uint_t)"
70146,METHOD,event\modules\ngx_devpoll_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_devpoll_process_events(ngx_cycle_t *cycle,
    ngx_msec_t timer, ngx_uint_t flags);",18,39,event\modules\ngx_devpoll_module.c,ngx_devpoll_process_events,,false,46,47,ngx_devpoll_process_events,,,8,"ngx_int_t ngx_devpoll_process_events (ngx_cycle_t*,ngx_msec_t,ngx_uint_t)"
70153,METHOD,event\modules\ngx_devpoll_module.c:<global>,TYPE_DECL,static void *ngx_devpoll_create_conf(ngx_cycle_t *cycle);,13,56,event\modules\ngx_devpoll_module.c,ngx_devpoll_create_conf,,false,49,49,ngx_devpoll_create_conf,,,9,void* ngx_devpoll_create_conf (ngx_cycle_t*)
70158,METHOD,event\modules\ngx_devpoll_module.c:<global>,TYPE_DECL,"static char *ngx_devpoll_init_conf(ngx_cycle_t *cycle, void *conf);",13,66,event\modules\ngx_devpoll_module.c,ngx_devpoll_init_conf,,false,50,50,ngx_devpoll_init_conf,,,10,"char* ngx_devpoll_init_conf (ngx_cycle_t*,void*)"
70246,METHOD,event\modules\ngx_devpoll_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_devpoll_init(ngx_cycle_t *cycle, ngx_msec_t timer)
{
    size_t               n;
    ngx_devpoll_conf_t  *dpcf;

    dpcf = ngx_event_get_conf(cycle->conf_ctx, ngx_devpoll_module);

    if (dp == -1) {
        dp = open(""/dev/poll"", O_RDWR);

        if (dp == -1) {
            ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,
                          ""open(/dev/poll) failed"");
            return NGX_ERROR;
        }
    }

    if (max_changes < dpcf->changes) {
        if (nchanges) {
            n = nchanges * sizeof(struct pollfd);
            if (write(dp, change_list, n) != (ssize_t) n) {
                ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                              ""write(/dev/poll) failed"");
                return NGX_ERROR;
            }

            nchanges = 0;
        }

        if (change_list) {
            ngx_free(change_list);
        }

        change_list = ngx_alloc(sizeof(struct pollfd) * dpcf->changes,
                ...",1,1,event\modules\ngx_devpoll_module.c,ngx_devpoll_init,,false,117,191,ngx_devpoll_init,,,28,"ngx_int_t ngx_devpoll_init (ngx_cycle_t*,ngx_msec_t)"
70429,METHOD,event\modules\ngx_devpoll_module.c:<global>,TYPE_DECL,"static void
ngx_devpoll_done(ngx_cycle_t *cycle)
{
    if (close(dp) == -1) {
        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                      ""close(/dev/poll) failed"");
    }

    dp = -1;

    ngx_free(change_list);
    ngx_free(event_list);
    ngx_free(change_index);

    change_list = NULL;
    event_list = NULL;
    change_index = NULL;
    max_changes = 0;
    nchanges = 0;
    nevents = 0;
}",1,1,event\modules\ngx_devpoll_module.c,ngx_devpoll_done,,false,194,214,ngx_devpoll_done,,,29,void ngx_devpoll_done (ngx_cycle_t*)
70476,METHOD,event\modules\ngx_devpoll_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_devpoll_add_event(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags)
{
#if (NGX_DEBUG)
    ngx_connection_t *c;
#endif

#if (NGX_READ_EVENT != POLLIN)
    event = (event == NGX_READ_EVENT) ? POLLIN : POLLOUT;
#endif

#if (NGX_DEBUG)
    c = ev->data;
    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ev->log, 0,
                   ""devpoll add event: fd:%d ev:%04Xi"", c->fd, event);
#endif

    ev->active = 1;

    return ngx_devpoll_set_event(ev, event, 0);
}",1,1,event\modules\ngx_devpoll_module.c,ngx_devpoll_add_event,,false,217,237,ngx_devpoll_add_event,,,30,"ngx_int_t ngx_devpoll_add_event (ngx_event_t*,ngx_int_t,ngx_uint_t)"
70493,METHOD,event\modules\ngx_devpoll_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_devpoll_del_event(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags)
{
    ngx_event_t       *e;
    ngx_connection_t  *c;

    c = ev->data;

#if (NGX_READ_EVENT != POLLIN)
    event = (event == NGX_READ_EVENT) ? POLLIN : POLLOUT;
#endif

    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ev->log, 0,
                   ""devpoll del event: fd:%d ev:%04Xi"", c->fd, event);

    if (ngx_devpoll_set_event(ev, POLLREMOVE, flags) == NGX_ERROR) {
        return NGX_ERROR;
    }

    ev->active = 0;

    if (flags & NGX_CLOSE_EVENT) {
        e = (event == POLLIN) ? c->write : c->read;

        if (e) {
            e->active = 0;
        }

        return NGX_OK;
    }

    /* restore the pair event if it exists */

    if (event == POLLIN) {
        e = c->write;
        event = POLLOUT;

    } else {
        e = c->read;
        event = POLLIN;
    }

    if (e && e->active) {
        return ngx_devpoll_set_event(e, event, 0);
    }

    return NGX_OK;
}",1,1,event\modules\ngx_devpoll_module.c,ngx_devpoll_del_event,,false,240,287,ngx_devpoll_del_event,,,31,"ngx_int_t ngx_devpoll_del_event (ngx_event_t*,ngx_int_t,ngx_uint_t)"
70597,METHOD,event\modules\ngx_devpoll_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_devpoll_set_event(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags)
{
    size_t             n;
    ngx_connection_t  *c;

    c = ev->data;

    ngx_log_debug3(NGX_LOG_DEBUG_EVENT, ev->log, 0,
                   ""devpoll fd:%d ev:%04Xi fl:%04Xi"", c->fd, event, flags);

    if (nchanges >= max_changes) {
        ngx_log_error(NGX_LOG_WARN, ev->log, 0,
                      ""/dev/pool change list is filled up"");

        n = nchanges * sizeof(struct pollfd);
        if (write(dp, change_list, n) != (ssize_t) n) {
            ngx_log_error(NGX_LOG_ALERT, ev->log, ngx_errno,
                          ""write(/dev/poll) failed"");
            return NGX_ERROR;
        }

        nchanges = 0;
    }

    change_list[nchanges].fd = c->fd;
    change_list[nchanges].events = (short) event;
    change_list[nchanges].revents = 0;

    change_index[nchanges] = ev;
    ev->index = nchanges;

    nchanges++;

    if (flags & NGX_CLOSE_EVENT) {
        n = nchanges * sizeof(s...",1,1,event\modules\ngx_devpoll_module.c,ngx_devpoll_set_event,,false,290,336,ngx_devpoll_set_event,,,32,"ngx_int_t ngx_devpoll_set_event (ngx_event_t*,ngx_int_t,ngx_uint_t)"
70735,METHOD,event\modules\ngx_devpoll_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_devpoll_process_events(ngx_cycle_t *cycle, ngx_msec_t timer,
    ngx_uint_t flags)
{
    int                 events, revents, rc;
    size_t              n;
    ngx_fd_t            fd;
    ngx_err_t           err;
    ngx_int_t           i;
    ngx_uint_t          level, instance;
    ngx_event_t        *rev, *wev;
    ngx_queue_t        *queue;
    ngx_connection_t   *c;
    struct pollfd       pfd;
    struct dvpoll       dvp;

    /* NGX_TIMER_INFINITE == INFTIM */

    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
                   ""devpoll timer: %M"", timer);

    if (nchanges) {
        n = nchanges * sizeof(struct pollfd);
        if (write(dp, change_list, n) != (ssize_t) n) {
            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                          ""write(/dev/poll) failed"");
            return NGX_ERROR;
        }

        nchanges = 0;
    }

    dvp.dp_fds = event_list;
    dvp.dp_nfds = (int) nevents;
    dvp.dp_timeout = timer...",1,1,event\modules\ngx_devpoll_module.c,ngx_devpoll_process_events,,false,339,532,ngx_devpoll_process_events,,,33,"ngx_int_t ngx_devpoll_process_events (ngx_cycle_t*,ngx_msec_t,ngx_uint_t)"
71241,METHOD,event\modules\ngx_devpoll_module.c:<global>,TYPE_DECL,"static void *
ngx_devpoll_create_conf(ngx_cycle_t *cycle)
{
    ngx_devpoll_conf_t  *dpcf;

    dpcf = ngx_palloc(cycle->pool, sizeof(ngx_devpoll_conf_t));
    if (dpcf == NULL) {
        return NULL;
    }

    dpcf->changes = NGX_CONF_UNSET;
    dpcf->events = NGX_CONF_UNSET;

    return dpcf;
}",1,1,event\modules\ngx_devpoll_module.c,ngx_devpoll_create_conf,,false,535,549,ngx_devpoll_create_conf,,,34,void* ngx_devpoll_create_conf (ngx_cycle_t*)
71274,METHOD,event\modules\ngx_devpoll_module.c:<global>,TYPE_DECL,"static char *
ngx_devpoll_init_conf(ngx_cycle_t *cycle, void *conf)
{
    ngx_devpoll_conf_t *dpcf = conf;

    ngx_conf_init_uint_value(dpcf->changes, 32);
    ngx_conf_init_uint_value(dpcf->events, 32);

    return NGX_CONF_OK;
}",1,1,event\modules\ngx_devpoll_module.c,ngx_devpoll_init_conf,,false,552,561,ngx_devpoll_init_conf,,,35,"char* ngx_devpoll_init_conf (ngx_cycle_t*,void*)"
71305,METHOD,event\modules\ngx_epoll_module.c:<global>,TYPE_DECL,<global>,1,1,event\modules\ngx_epoll_module.c,event\modules\ngx_epoll_module.c:<global>,,false,1,1051,<global>,,,1,
71311,METHOD,event\modules\ngx_epoll_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_epoll_init(ngx_cycle_t *cycle, ngx_msec_t timer);",18,69,event\modules\ngx_epoll_module.c,ngx_epoll_init,,false,104,104,ngx_epoll_init,,,3,"ngx_int_t ngx_epoll_init (ngx_cycle_t*,ngx_msec_t)"
71317,METHOD,event\modules\ngx_epoll_module.c:<global>,TYPE_DECL,static void ngx_epoll_done(ngx_cycle_t *cycle);,13,46,event\modules\ngx_epoll_module.c,ngx_epoll_done,,false,112,112,ngx_epoll_done,,,4,void ngx_epoll_done (ngx_cycle_t*)
71322,METHOD,event\modules\ngx_epoll_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_epoll_add_event(ngx_event_t *ev, ngx_int_t event,
    ngx_uint_t flags);",18,21,event\modules\ngx_epoll_module.c,ngx_epoll_add_event,,false,113,114,ngx_epoll_add_event,,,5,"ngx_int_t ngx_epoll_add_event (ngx_event_t*,ngx_int_t,ngx_uint_t)"
71329,METHOD,event\modules\ngx_epoll_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_epoll_del_event(ngx_event_t *ev, ngx_int_t event,
    ngx_uint_t flags);",18,21,event\modules\ngx_epoll_module.c,ngx_epoll_del_event,,false,115,116,ngx_epoll_del_event,,,6,"ngx_int_t ngx_epoll_del_event (ngx_event_t*,ngx_int_t,ngx_uint_t)"
71336,METHOD,event\modules\ngx_epoll_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_epoll_add_connection(ngx_connection_t *c);,18,62,event\modules\ngx_epoll_module.c,ngx_epoll_add_connection,,false,117,117,ngx_epoll_add_connection,,,7,ngx_int_t ngx_epoll_add_connection (ngx_connection_t*)
71341,METHOD,event\modules\ngx_epoll_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_epoll_del_connection(ngx_connection_t *c,
    ngx_uint_t flags);",18,21,event\modules\ngx_epoll_module.c,ngx_epoll_del_connection,,false,118,119,ngx_epoll_del_connection,,,8,"ngx_int_t ngx_epoll_del_connection (ngx_connection_t*,ngx_uint_t)"
71347,METHOD,event\modules\ngx_epoll_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_epoll_process_events(ngx_cycle_t *cycle, ngx_msec_t timer,
    ngx_uint_t flags);",18,21,event\modules\ngx_epoll_module.c,ngx_epoll_process_events,,false,123,124,ngx_epoll_process_events,,,9,"ngx_int_t ngx_epoll_process_events (ngx_cycle_t*,ngx_msec_t,ngx_uint_t)"
71354,METHOD,event\modules\ngx_epoll_module.c:<global>,TYPE_DECL,static void *ngx_epoll_create_conf(ngx_cycle_t *cycle);,13,54,event\modules\ngx_epoll_module.c,ngx_epoll_create_conf,,false,130,130,ngx_epoll_create_conf,,,10,void* ngx_epoll_create_conf (ngx_cycle_t*)
71359,METHOD,event\modules\ngx_epoll_module.c:<global>,TYPE_DECL,"static char *ngx_epoll_init_conf(ngx_cycle_t *cycle, void *conf);",13,64,event\modules\ngx_epoll_module.c,ngx_epoll_init_conf,,false,131,131,ngx_epoll_init_conf,,,11,"char* ngx_epoll_init_conf (ngx_cycle_t*,void*)"
71443,METHOD,event\modules\ngx_epoll_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_epoll_init(ngx_cycle_t *cycle, ngx_msec_t timer)
{
    ngx_epoll_conf_t  *epcf;

    epcf = ngx_event_get_conf(cycle->conf_ctx, ngx_epoll_module);

    if (ep == -1) {
        ep = epoll_create(cycle->connection_n / 2);

        if (ep == -1) {
            ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,
                          ""epoll_create() failed"");
            return NGX_ERROR;
        }

#if (NGX_HAVE_EVENTFD)
        if (ngx_epoll_notify_init(cycle->log) != NGX_OK) {
            ngx_epoll_module_ctx.actions.notify = NULL;
        }
#endif

#if (NGX_HAVE_FILE_AIO)
        ngx_epoll_aio_init(cycle, epcf);
#endif

#if (NGX_HAVE_EPOLLRDHUP)
        ngx_epoll_test_rdhup(cycle);
#endif
    }

    if (nevents < epcf->events) {
        if (event_list) {
            ngx_free(event_list);
        }

        event_list = ngx_alloc(sizeof(struct epoll_event) * epcf->events,
                               cycle->log);
        if (event_list == NULL) {
           ...",1,1,event\modules\ngx_epoll_module.c,ngx_epoll_init,,false,322,380,ngx_epoll_init,,,25,"ngx_int_t ngx_epoll_init (ngx_cycle_t*,ngx_msec_t)"
71539,METHOD,event\modules\ngx_epoll_module.c:<global>,TYPE_DECL,"static void
ngx_epoll_done(ngx_cycle_t *cycle)
{
    if (close(ep) == -1) {
        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                      ""epoll close() failed"");
    }

    ep = -1;

#if (NGX_HAVE_EVENTFD)

    if (close(notify_fd) == -1) {
        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                      ""eventfd close() failed"");
    }

    notify_fd = -1;

#endif

#if (NGX_HAVE_FILE_AIO)

    if (ngx_eventfd != -1) {

        if (io_destroy(ngx_aio_ctx) == -1) {
            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                          ""io_destroy() failed"");
        }

        if (close(ngx_eventfd) == -1) {
            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                          ""eventfd close() failed"");
        }

        ngx_eventfd = -1;
    }

    ngx_aio_ctx = 0;

#endif

    ngx_free(event_list);

    event_list = NULL;
    nevents = 0;
}",1,1,event\modules\ngx_epoll_module.c,ngx_epoll_done,,false,529,575,ngx_epoll_done,,,26,void ngx_epoll_done (ngx_cycle_t*)
71570,METHOD,event\modules\ngx_epoll_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_epoll_add_event(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags)
{
    int                  op;
    uint32_t             events, prev;
    ngx_event_t         *e;
    ngx_connection_t    *c;
    struct epoll_event   ee;

    c = ev->data;

    events = (uint32_t) event;

    if (event == NGX_READ_EVENT) {
        e = c->write;
        prev = EPOLLOUT;
#if (NGX_READ_EVENT != EPOLLIN|EPOLLRDHUP)
        events = EPOLLIN|EPOLLRDHUP;
#endif

    } else {
        e = c->read;
        prev = EPOLLIN|EPOLLRDHUP;
#if (NGX_WRITE_EVENT != EPOLLOUT)
        events = EPOLLOUT;
#endif
    }

    if (e->active) {
        op = EPOLL_CTL_MOD;
        events |= prev;

    } else {
        op = EPOLL_CTL_ADD;
    }

#if (NGX_HAVE_EPOLLEXCLUSIVE && NGX_HAVE_EPOLLRDHUP)
    if (flags & NGX_EXCLUSIVE_EVENT) {
        events &= ~EPOLLRDHUP;
    }
#endif

    ee.events = events | (uint32_t) flags;
    ee.data.ptr = (void *) ((uintptr_t) c | ev->instance);

    ngx_log_debug3(NGX_LO...",1,1,event\modules\ngx_epoll_module.c,ngx_epoll_add_event,,false,578,639,ngx_epoll_add_event,,,27,"ngx_int_t ngx_epoll_add_event (ngx_event_t*,ngx_int_t,ngx_uint_t)"
71705,METHOD,event\modules\ngx_epoll_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_epoll_del_event(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags)
{
    int                  op;
    uint32_t             prev;
    ngx_event_t         *e;
    ngx_connection_t    *c;
    struct epoll_event   ee;

    /*
     * when the file descriptor is closed, the epoll automatically deletes
     * it from its queue, so we do not need to delete explicitly the event
     * before the closing the file descriptor
     */

    if (flags & NGX_CLOSE_EVENT) {
        ev->active = 0;
        return NGX_OK;
    }

    c = ev->data;

    if (event == NGX_READ_EVENT) {
        e = c->write;
        prev = EPOLLOUT;

    } else {
        e = c->read;
        prev = EPOLLIN|EPOLLRDHUP;
    }

    if (e->active) {
        op = EPOLL_CTL_MOD;
        ee.events = prev | (uint32_t) flags;
        ee.data.ptr = (void *) ((uintptr_t) c | ev->instance);

    } else {
        op = EPOLL_CTL_DEL;
        ee.events = 0;
        ee.data.ptr = NULL;
    }

    ngx_log_debug3(NGX_L...",1,1,event\modules\ngx_epoll_module.c,ngx_epoll_del_event,,false,642,697,ngx_epoll_del_event,,,28,"ngx_int_t ngx_epoll_del_event (ngx_event_t*,ngx_int_t,ngx_uint_t)"
71855,METHOD,event\modules\ngx_epoll_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_epoll_add_connection(ngx_connection_t *c)
{
    struct epoll_event  ee;

    ee.events = EPOLLIN|EPOLLOUT|EPOLLET|EPOLLRDHUP;
    ee.data.ptr = (void *) ((uintptr_t) c | c->read->instance);

    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,
                   ""epoll add connection: fd:%d ev:%08XD"", c->fd, ee.events);

    if (epoll_ctl(ep, EPOLL_CTL_ADD, c->fd, &ee) == -1) {
        ngx_log_error(NGX_LOG_ALERT, c->log, ngx_errno,
                      ""epoll_ctl(EPOLL_CTL_ADD, %d) failed"", c->fd);
        return NGX_ERROR;
    }

    c->read->active = 1;
    c->write->active = 1;

    return NGX_OK;
}",1,1,event\modules\ngx_epoll_module.c,ngx_epoll_add_connection,,false,700,721,ngx_epoll_add_connection,,,29,ngx_int_t ngx_epoll_add_connection (ngx_connection_t*)
71943,METHOD,event\modules\ngx_epoll_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_epoll_del_connection(ngx_connection_t *c, ngx_uint_t flags)
{
    int                 op;
    struct epoll_event  ee;

    /*
     * when the file descriptor is closed the epoll automatically deletes
     * it from its queue so we do not need to delete explicitly the event
     * before the closing the file descriptor
     */

    if (flags & NGX_CLOSE_EVENT) {
        c->read->active = 0;
        c->write->active = 0;
        return NGX_OK;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,
                   ""epoll del connection: fd:%d"", c->fd);

    op = EPOLL_CTL_DEL;
    ee.events = 0;
    ee.data.ptr = NULL;

    if (epoll_ctl(ep, op, c->fd, &ee) == -1) {
        ngx_log_error(NGX_LOG_ALERT, c->log, ngx_errno,
                      ""epoll_ctl(%d, %d) failed"", op, c->fd);
        return NGX_ERROR;
    }

    c->read->active = 0;
    c->write->active = 0;

    return NGX_OK;
}",1,1,event\modules\ngx_epoll_module.c,ngx_epoll_del_connection,,false,724,759,ngx_epoll_del_connection,,,30,"ngx_int_t ngx_epoll_del_connection (ngx_connection_t*,ngx_uint_t)"
72039,METHOD,event\modules\ngx_epoll_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_epoll_process_events(ngx_cycle_t *cycle, ngx_msec_t timer, ngx_uint_t flags)
{
    int                events;
    uint32_t           revents;
    ngx_int_t          instance, i;
    ngx_uint_t         level;
    ngx_err_t          err;
    ngx_event_t       *rev, *wev;
    ngx_queue_t       *queue;
    ngx_connection_t  *c;

    /* NGX_TIMER_INFINITE == INFTIM */

    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
                   ""epoll timer: %M"", timer);

    events = epoll_wait(ep, event_list, (int) nevents, timer);

    err = (events == -1) ? ngx_errno : 0;

    if (flags & NGX_UPDATE_TIME || ngx_event_timer_alarm) {
        ngx_time_update();
    }

    if (err) {
        if (err == NGX_EINTR) {

            if (ngx_event_timer_alarm) {
                ngx_event_timer_alarm = 0;
                return NGX_OK;
            }

            level = NGX_LOG_INFO;

        } else {
            level = NGX_LOG_ALERT;
        }

        ngx_log_error(level, c...",1,1,event\modules\ngx_epoll_module.c,ngx_epoll_process_events,,false,783,936,ngx_epoll_process_events,,,31,"ngx_int_t ngx_epoll_process_events (ngx_cycle_t*,ngx_msec_t,ngx_uint_t)"
72364,METHOD,event\modules\ngx_epoll_module.c:<global>,TYPE_DECL,"static void *
ngx_epoll_create_conf(ngx_cycle_t *cycle)
{
    ngx_epoll_conf_t  *epcf;

    epcf = ngx_palloc(cycle->pool, sizeof(ngx_epoll_conf_t));
    if (epcf == NULL) {
        return NULL;
    }

    epcf->events = NGX_CONF_UNSET;
    epcf->aio_requests = NGX_CONF_UNSET;

    return epcf;
}",1,1,event\modules\ngx_epoll_module.c,ngx_epoll_create_conf,,false,1025,1039,ngx_epoll_create_conf,,,32,void* ngx_epoll_create_conf (ngx_cycle_t*)
72397,METHOD,event\modules\ngx_epoll_module.c:<global>,TYPE_DECL,"static char *
ngx_epoll_init_conf(ngx_cycle_t *cycle, void *conf)
{
    ngx_epoll_conf_t *epcf = conf;

    ngx_conf_init_uint_value(epcf->events, 512);
    ngx_conf_init_uint_value(epcf->aio_requests, 32);

    return NGX_CONF_OK;
}",1,1,event\modules\ngx_epoll_module.c,ngx_epoll_init_conf,,false,1042,1051,ngx_epoll_init_conf,,,33,"char* ngx_epoll_init_conf (ngx_cycle_t*,void*)"
72428,METHOD,event\modules\ngx_eventport_module.c:<global>,TYPE_DECL,<global>,1,1,event\modules\ngx_eventport_module.c,event\modules\ngx_eventport_module.c:<global>,,false,1,650,<global>,,,1,
72433,METHOD,event\modules\ngx_eventport_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_eventport_init(ngx_cycle_t *cycle, ngx_msec_t timer);",18,73,event\modules\ngx_eventport_module.c,ngx_eventport_init,,false,139,139,ngx_eventport_init,,,3,"ngx_int_t ngx_eventport_init (ngx_cycle_t*,ngx_msec_t)"
72439,METHOD,event\modules\ngx_eventport_module.c:<global>,TYPE_DECL,static void ngx_eventport_done(ngx_cycle_t *cycle);,13,50,event\modules\ngx_eventport_module.c,ngx_eventport_done,,false,140,140,ngx_eventport_done,,,4,void ngx_eventport_done (ngx_cycle_t*)
72444,METHOD,event\modules\ngx_eventport_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_eventport_add_event(ngx_event_t *ev, ngx_int_t event,
    ngx_uint_t flags);",18,21,event\modules\ngx_eventport_module.c,ngx_eventport_add_event,,false,141,142,ngx_eventport_add_event,,,5,"ngx_int_t ngx_eventport_add_event (ngx_event_t*,ngx_int_t,ngx_uint_t)"
72451,METHOD,event\modules\ngx_eventport_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_eventport_del_event(ngx_event_t *ev, ngx_int_t event,
    ngx_uint_t flags);",18,21,event\modules\ngx_eventport_module.c,ngx_eventport_del_event,,false,143,144,ngx_eventport_del_event,,,6,"ngx_int_t ngx_eventport_del_event (ngx_event_t*,ngx_int_t,ngx_uint_t)"
72458,METHOD,event\modules\ngx_eventport_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_eventport_notify(ngx_event_handler_pt handler);,18,67,event\modules\ngx_eventport_module.c,ngx_eventport_notify,,false,145,145,ngx_eventport_notify,,,7,ngx_int_t ngx_eventport_notify (ngx_event_handler_pt)
72463,METHOD,event\modules\ngx_eventport_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_eventport_process_events(ngx_cycle_t *cycle,
    ngx_msec_t timer, ngx_uint_t flags);",18,39,event\modules\ngx_eventport_module.c,ngx_eventport_process_events,,false,146,147,ngx_eventport_process_events,,,8,"ngx_int_t ngx_eventport_process_events (ngx_cycle_t*,ngx_msec_t,ngx_uint_t)"
72470,METHOD,event\modules\ngx_eventport_module.c:<global>,TYPE_DECL,static void *ngx_eventport_create_conf(ngx_cycle_t *cycle);,13,58,event\modules\ngx_eventport_module.c,ngx_eventport_create_conf,,false,149,149,ngx_eventport_create_conf,,,9,void* ngx_eventport_create_conf (ngx_cycle_t*)
72475,METHOD,event\modules\ngx_eventport_module.c:<global>,TYPE_DECL,"static char *ngx_eventport_init_conf(ngx_cycle_t *cycle, void *conf);",13,68,event\modules\ngx_eventport_module.c,ngx_eventport_init_conf,,false,150,150,ngx_eventport_init_conf,,,10,"char* ngx_eventport_init_conf (ngx_cycle_t*,void*)"
72553,METHOD,event\modules\ngx_eventport_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_eventport_init(ngx_cycle_t *cycle, ngx_msec_t timer)
{
    port_notify_t          pn;
    struct itimerspec      its;
    struct sigevent        sev;
    ngx_eventport_conf_t  *epcf;

    epcf = ngx_event_get_conf(cycle->conf_ctx, ngx_eventport_module);

    if (ep == -1) {
        ep = port_create();

        if (ep == -1) {
            ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,
                          ""port_create() failed"");
            return NGX_ERROR;
        }

        notify_event.active = 1;
        notify_event.log = cycle->log;
    }

    if (nevents < epcf->events) {
        if (event_list) {
            ngx_free(event_list);
        }

        event_list = ngx_alloc(sizeof(port_event_t) * epcf->events,
                               cycle->log);
        if (event_list == NULL) {
            return NGX_ERROR;
        }
    }

    ngx_event_flags = NGX_USE_EVENTPORT_EVENT;

    if (timer) {
        ngx_memzero(&pn, sizeof(port_notify_t));
 ...",1,1,event\modules\ngx_eventport_module.c,ngx_eventport_init,,false,210,282,ngx_eventport_init,,,26,"ngx_int_t ngx_eventport_init (ngx_cycle_t*,ngx_msec_t)"
72769,METHOD,event\modules\ngx_eventport_module.c:<global>,TYPE_DECL,"static void
ngx_eventport_done(ngx_cycle_t *cycle)
{
    if (event_timer != (timer_t) -1) {
        if (timer_delete(event_timer) == -1) {
            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                          ""timer_delete() failed"");
        }

        event_timer = (timer_t) -1;
    }

    if (close(ep) == -1) {
        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                      ""close() event port failed"");
    }

    ep = -1;

    ngx_free(event_list);

    event_list = NULL;
    nevents = 0;
}",1,1,event\modules\ngx_eventport_module.c,ngx_eventport_done,,false,285,308,ngx_eventport_done,,,27,void ngx_eventport_done (ngx_cycle_t*)
72826,METHOD,event\modules\ngx_eventport_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_eventport_add_event(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags)
{
    ngx_int_t          events, prev;
    ngx_event_t       *e;
    ngx_connection_t  *c;

    c = ev->data;

    events = event;

    if (event == NGX_READ_EVENT) {
        e = c->write;
        prev = POLLOUT;
#if (NGX_READ_EVENT != POLLIN)
        events = POLLIN;
#endif

    } else {
        e = c->read;
        prev = POLLIN;
#if (NGX_WRITE_EVENT != POLLOUT)
        events = POLLOUT;
#endif
    }

    if (e->oneshot) {
        events |= prev;
    }

    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ev->log, 0,
                   ""eventport add event: fd:%d ev:%04Xi"", c->fd, events);

    if (port_associate(ep, PORT_SOURCE_FD, c->fd, events,
                       (void *) ((uintptr_t) ev | ev->instance))
        == -1)
    {
        ngx_log_error(NGX_LOG_ALERT, ev->log, ngx_errno,
                      ""port_associate() failed"");
        return NGX_ERROR;
    }

    ev->active = 1;
    ev->onesh...",1,1,event\modules\ngx_eventport_module.c,ngx_eventport_add_event,,false,311,357,ngx_eventport_add_event,,,28,"ngx_int_t ngx_eventport_add_event (ngx_event_t*,ngx_int_t,ngx_uint_t)"
72929,METHOD,event\modules\ngx_eventport_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_eventport_del_event(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags)
{
    ngx_event_t       *e;
    ngx_connection_t  *c;

    /*
     * when the file descriptor is closed, the event port automatically
     * dissociates it from the port, so we do not need to dissociate explicitly
     * the event before the closing the file descriptor
     */

    if (flags & NGX_CLOSE_EVENT) {
        ev->active = 0;
        ev->oneshot = 0;
        return NGX_OK;
    }

    c = ev->data;

    if (event == NGX_READ_EVENT) {
        e = c->write;
        event = POLLOUT;

    } else {
        e = c->read;
        event = POLLIN;
    }

    if (e->oneshot) {
        ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ev->log, 0,
                       ""eventport change event: fd:%d ev:%04Xi"", c->fd, event);

        if (port_associate(ep, PORT_SOURCE_FD, c->fd, event,
                           (void *) ((uintptr_t) ev | ev->instance))
            == -1)
        {
            ngx_log_error(...",1,1,event\modules\ngx_eventport_module.c,ngx_eventport_del_event,,false,360,417,ngx_eventport_del_event,,,29,"ngx_int_t ngx_eventport_del_event (ngx_event_t*,ngx_int_t,ngx_uint_t)"
73073,METHOD,event\modules\ngx_eventport_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_eventport_notify(ngx_event_handler_pt handler)
{
    notify_event.handler = handler;

    if (port_send(ep, 0, &notify_event) != 0) {
        ngx_log_error(NGX_LOG_ALERT, notify_event.log, ngx_errno,
                      ""port_send() failed"");
        return NGX_ERROR;
    }

    return NGX_OK;
}",1,1,event\modules\ngx_eventport_module.c,ngx_eventport_notify,,false,420,432,ngx_eventport_notify,,,30,ngx_int_t ngx_eventport_notify (ngx_event_handler_pt)
73103,METHOD,event\modules\ngx_eventport_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_eventport_process_events(ngx_cycle_t *cycle, ngx_msec_t timer,
    ngx_uint_t flags)
{
    int                 n, revents;
    u_int               events;
    ngx_err_t           err;
    ngx_int_t           instance;
    ngx_uint_t          i, level;
    ngx_event_t        *ev, *rev, *wev;
    ngx_queue_t        *queue;
    ngx_connection_t   *c;
    struct timespec     ts, *tp;

    if (timer == NGX_TIMER_INFINITE) {
        tp = NULL;

    } else {
        ts.tv_sec = timer / 1000;
        ts.tv_nsec = (timer % 1000) * 1000000;
        tp = &ts;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
                   ""eventport timer: %M"", timer);

    events = 1;

    n = port_getn(ep, event_list, (u_int) nevents, &events, tp);

    err = ngx_errno;

    if (flags & NGX_UPDATE_TIME) {
        ngx_time_update();
    }

    if (n == -1) {
        if (err == ETIME) {
            if (timer != NGX_TIMER_INFINITE) {
                return NGX_OK;
         ...",1,1,event\modules\ngx_eventport_module.c,ngx_eventport_process_events,,false,435,623,ngx_eventport_process_events,,,31,"ngx_int_t ngx_eventport_process_events (ngx_cycle_t*,ngx_msec_t,ngx_uint_t)"
73589,METHOD,event\modules\ngx_eventport_module.c:<global>,TYPE_DECL,"static void *
ngx_eventport_create_conf(ngx_cycle_t *cycle)
{
    ngx_eventport_conf_t  *epcf;

    epcf = ngx_palloc(cycle->pool, sizeof(ngx_eventport_conf_t));
    if (epcf == NULL) {
        return NULL;
    }

    epcf->events = NGX_CONF_UNSET;

    return epcf;
}",1,1,event\modules\ngx_eventport_module.c,ngx_eventport_create_conf,,false,626,639,ngx_eventport_create_conf,,,32,void* ngx_eventport_create_conf (ngx_cycle_t*)
73617,METHOD,event\modules\ngx_eventport_module.c:<global>,TYPE_DECL,"static char *
ngx_eventport_init_conf(ngx_cycle_t *cycle, void *conf)
{
    ngx_eventport_conf_t *epcf = conf;

    ngx_conf_init_uint_value(epcf->events, 32);

    return NGX_CONF_OK;
}",1,1,event\modules\ngx_eventport_module.c,ngx_eventport_init_conf,,false,642,650,ngx_eventport_init_conf,,,33,"char* ngx_eventport_init_conf (ngx_cycle_t*,void*)"
73645,METHOD,event\modules\ngx_iocp_module.c:<global>,TYPE_DECL,<global>,1,26,event\modules\ngx_iocp_module.c,event\modules\ngx_iocp_module.c:<global>,,false,1,380,<global>,,,1,
73647,METHOD,event\modules\ngx_iocp_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_iocp_init(ngx_cycle_t *cycle, ngx_msec_t timer);",18,68,event\modules\ngx_iocp_module.c,ngx_iocp_init,,false,14,14,ngx_iocp_init,,,1,"ngx_int_t ngx_iocp_init (ngx_cycle_t*,ngx_msec_t)"
73653,METHOD,event\modules\ngx_iocp_module.c:<global>,TYPE_DECL,static ngx_thread_value_t __stdcall ngx_iocp_timer(void *data);,37,62,event\modules\ngx_iocp_module.c,ngx_iocp_timer,,false,15,15,ngx_iocp_timer,,,2,ngx_thread_value_t ngx_iocp_timer (void*)
73658,METHOD,event\modules\ngx_iocp_module.c:<global>,TYPE_DECL,static void ngx_iocp_done(ngx_cycle_t *cycle);,13,45,event\modules\ngx_iocp_module.c,ngx_iocp_done,,false,16,16,ngx_iocp_done,,,3,void ngx_iocp_done (ngx_cycle_t*)
73663,METHOD,event\modules\ngx_iocp_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_iocp_add_event(ngx_event_t *ev, ngx_int_t event,
    ngx_uint_t key);",18,19,event\modules\ngx_iocp_module.c,ngx_iocp_add_event,,false,17,18,ngx_iocp_add_event,,,4,"ngx_int_t ngx_iocp_add_event (ngx_event_t*,ngx_int_t,ngx_uint_t)"
73670,METHOD,event\modules\ngx_iocp_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_iocp_del_connection(ngx_connection_t *c, ngx_uint_t flags);",18,79,event\modules\ngx_iocp_module.c,ngx_iocp_del_connection,,false,19,19,ngx_iocp_del_connection,,,5,"ngx_int_t ngx_iocp_del_connection (ngx_connection_t*,ngx_uint_t)"
73676,METHOD,event\modules\ngx_iocp_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_iocp_process_events(ngx_cycle_t *cycle, ngx_msec_t timer,
    ngx_uint_t flags);",18,21,event\modules\ngx_iocp_module.c,ngx_iocp_process_events,,false,20,21,ngx_iocp_process_events,,,6,"ngx_int_t ngx_iocp_process_events (ngx_cycle_t*,ngx_msec_t,ngx_uint_t)"
73683,METHOD,event\modules\ngx_iocp_module.c:<global>,TYPE_DECL,static void *ngx_iocp_create_conf(ngx_cycle_t *cycle);,13,53,event\modules\ngx_iocp_module.c,ngx_iocp_create_conf,,false,22,22,ngx_iocp_create_conf,,,7,void* ngx_iocp_create_conf (ngx_cycle_t*)
73688,METHOD,event\modules\ngx_iocp_module.c:<global>,TYPE_DECL,"static char *ngx_iocp_init_conf(ngx_cycle_t *cycle, void *conf);",13,63,event\modules\ngx_iocp_module.c,ngx_iocp_init_conf,,false,23,23,ngx_iocp_init_conf,,,8,"char* ngx_iocp_init_conf (ngx_cycle_t*,void*)"
73791,METHOD,event\modules\ngx_iocp_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_iocp_init(ngx_cycle_t *cycle, ngx_msec_t timer)
{
    ngx_iocp_conf_t  *cf;

    cf = ngx_event_get_conf(cycle->conf_ctx, ngx_iocp_module);

    if (iocp == NULL) {
        iocp = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0,
                                      cf->threads);
    }

    if (iocp == NULL) {
        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                      ""CreateIoCompletionPort() failed"");
        return NGX_ERROR;
    }

    ngx_io = ngx_iocp_io;

    ngx_event_actions = ngx_iocp_module_ctx.actions;

    ngx_event_flags = NGX_USE_IOCP_EVENT;

    if (timer == 0) {
        return NGX_OK;
    }

    /*
     * The waitable timer could not be used, because
     * GetQueuedCompletionStatus() does not set a thread to alertable state
     */

    if (timer_thread == NULL) {

        msec = timer;

        if (ngx_create_thread(&timer_thread, ngx_iocp_timer, &msec, cycle->log)
            != 0)
        {
            return NGX_...",1,1,event\modules\ngx_iocp_module.c,ngx_iocp_init,,false,108,155,ngx_iocp_init,,,22,"ngx_int_t ngx_iocp_init (ngx_cycle_t*,ngx_msec_t)"
73879,METHOD,event\modules\ngx_iocp_module.c:<global>,TYPE_DECL,"static ngx_thread_value_t __stdcall
ngx_iocp_timer(void *data)
{
    ngx_msec_t  timer = *(ngx_msec_t *) data;

    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ngx_cycle->log, 0,
                   ""THREAD %p %p"", &msec, data);

    for ( ;; ) {
        Sleep(timer);

        ngx_time_update();
#if 1
        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, ngx_cycle->log, 0, ""timer"");
#endif
    }

#if defined(__WATCOMC__) || defined(__GNUC__)
    return 0;
#endif
}",1,26,event\modules\ngx_iocp_module.c,ngx_iocp_timer,,false,158,178,ngx_iocp_timer,,,23,ngx_thread_value_t ngx_iocp_timer (void*)
73914,METHOD,event\modules\ngx_iocp_module.c:<global>,TYPE_DECL,"static void
ngx_iocp_done(ngx_cycle_t *cycle)
{
    if (CloseHandle(iocp) == -1) {
        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                      ""iocp CloseHandle() failed"");
    }

    iocp = NULL;
}",1,1,event\modules\ngx_iocp_module.c,ngx_iocp_done,,false,181,190,ngx_iocp_done,,,24,void ngx_iocp_done (ngx_cycle_t*)
73936,METHOD,event\modules\ngx_iocp_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_iocp_add_event(ngx_event_t *ev, ngx_int_t event, ngx_uint_t key)
{
    ngx_connection_t  *c;

    c = (ngx_connection_t *) ev->data;

    c->read->active = 1;
    c->write->active = 1;

    ngx_log_debug3(NGX_LOG_DEBUG_EVENT, ev->log, 0,
                   ""iocp add: fd:%d k:%ui ov:%p"", c->fd, key, &ev->ovlp);

    if (CreateIoCompletionPort((HANDLE) c->fd, iocp, key, 0) == NULL) {
        ngx_log_error(NGX_LOG_ALERT, c->log, ngx_errno,
                      ""CreateIoCompletionPort() failed"");
        return NGX_ERROR;
    }

    return NGX_OK;
}",1,1,event\modules\ngx_iocp_module.c,ngx_iocp_add_event,,false,193,213,ngx_iocp_add_event,,,25,"ngx_int_t ngx_iocp_add_event (ngx_event_t*,ngx_int_t,ngx_uint_t)"
74004,METHOD,event\modules\ngx_iocp_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_iocp_del_connection(ngx_connection_t *c, ngx_uint_t flags)
{
#if 0
    if (flags & NGX_CLOSE_EVENT) {
        return NGX_OK;
    }

    if (CancelIo((HANDLE) c->fd) == 0) {
        ngx_log_error(NGX_LOG_ALERT, c->log, ngx_errno, ""CancelIo() failed"");
        return NGX_ERROR;
    }
#endif

    return NGX_OK;
}",1,1,event\modules\ngx_iocp_module.c,ngx_iocp_del_connection,,false,216,231,ngx_iocp_del_connection,,,26,"ngx_int_t ngx_iocp_del_connection (ngx_connection_t*,ngx_uint_t)"
74012,METHOD,event\modules\ngx_iocp_module.c:<global>,TYPE_DECL,"static
ngx_int_t ngx_iocp_process_events(ngx_cycle_t *cycle, ngx_msec_t timer,
    ngx_uint_t flags)
{
    int                rc;
    u_int              key;
    u_long             bytes;
    ngx_err_t          err;
    ngx_msec_t         delta;
    ngx_event_t       *ev;
    ngx_event_ovlp_t  *ovlp;

    if (timer == NGX_TIMER_INFINITE) {
        timer = INFINITE;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle->log, 0, ""iocp timer: %M"", timer);

    rc = GetQueuedCompletionStatus(iocp, &bytes, (PULONG_PTR) &key,
                                   (LPOVERLAPPED *) &ovlp, (u_long) timer);

    if (rc == 0) {
        err = ngx_errno;
    } else {
        err = 0;
    }

    delta = ngx_current_msec;

    if (flags & NGX_UPDATE_TIME) {
        ngx_time_update();
    }

    ngx_log_debug4(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
                   ""iocp: %d b:%d k:%d ov:%p"", rc, bytes, key, ovlp);

    if (timer != INFINITE) {
        delta = ngx_current_msec - delta;

        ngx_log_...",1,1,event\modules\ngx_iocp_module.c,ngx_iocp_process_events,,false,234,349,ngx_iocp_process_events,,,27,"ngx_int_t ngx_iocp_process_events (ngx_cycle_t*,ngx_msec_t,ngx_uint_t)"
74251,METHOD,event\modules\ngx_iocp_module.c:<global>,TYPE_DECL,"static void *
ngx_iocp_create_conf(ngx_cycle_t *cycle)
{
    ngx_iocp_conf_t  *cf;

    cf = ngx_palloc(cycle->pool, sizeof(ngx_iocp_conf_t));
    if (cf == NULL) {
        return NGX_CONF_ERROR;
    }

    cf->threads = NGX_CONF_UNSET;
    cf->post_acceptex = NGX_CONF_UNSET;
    cf->acceptex_read = NGX_CONF_UNSET;

    return cf;
}",1,1,event\modules\ngx_iocp_module.c,ngx_iocp_create_conf,,false,352,367,ngx_iocp_create_conf,,,28,void* ngx_iocp_create_conf (ngx_cycle_t*)
74289,METHOD,event\modules\ngx_iocp_module.c:<global>,TYPE_DECL,"static char *
ngx_iocp_init_conf(ngx_cycle_t *cycle, void *conf)
{
    ngx_iocp_conf_t *cf = conf;

    ngx_conf_init_value(cf->threads, 0);
    ngx_conf_init_value(cf->post_acceptex, 10);
    ngx_conf_init_value(cf->acceptex_read, 1);

    return NGX_CONF_OK;
}",1,1,event\modules\ngx_iocp_module.c,ngx_iocp_init_conf,,false,370,380,ngx_iocp_init_conf,,,29,"char* ngx_iocp_init_conf (ngx_cycle_t*,void*)"
74319,METHOD,event\modules\ngx_iocp_module.h:<global>,TYPE_DECL,<global>,1,41,event\modules\ngx_iocp_module.h,event\modules\ngx_iocp_module.h:<global>,,false,1,22,<global>,,,1,
74336,METHOD,event\modules\ngx_kqueue_module.c:<global>,TYPE_DECL,<global>,1,1,event\modules\ngx_kqueue_module.c,event\modules\ngx_kqueue_module.c:<global>,,false,1,722,<global>,,,1,
74342,METHOD,event\modules\ngx_kqueue_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_kqueue_init(ngx_cycle_t *cycle, ngx_msec_t timer);",18,70,event\modules\ngx_kqueue_module.c,ngx_kqueue_init,,false,19,19,ngx_kqueue_init,,,3,"ngx_int_t ngx_kqueue_init (ngx_cycle_t*,ngx_msec_t)"
74348,METHOD,event\modules\ngx_kqueue_module.c:<global>,TYPE_DECL,static void ngx_kqueue_done(ngx_cycle_t *cycle);,13,47,event\modules\ngx_kqueue_module.c,ngx_kqueue_done,,false,23,23,ngx_kqueue_done,,,4,void ngx_kqueue_done (ngx_cycle_t*)
74353,METHOD,event\modules\ngx_kqueue_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_kqueue_add_event(ngx_event_t *ev, ngx_int_t event,
    ngx_uint_t flags);",18,21,event\modules\ngx_kqueue_module.c,ngx_kqueue_add_event,,false,24,25,ngx_kqueue_add_event,,,5,"ngx_int_t ngx_kqueue_add_event (ngx_event_t*,ngx_int_t,ngx_uint_t)"
74360,METHOD,event\modules\ngx_kqueue_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_kqueue_del_event(ngx_event_t *ev, ngx_int_t event,
    ngx_uint_t flags);",18,21,event\modules\ngx_kqueue_module.c,ngx_kqueue_del_event,,false,26,27,ngx_kqueue_del_event,,,6,"ngx_int_t ngx_kqueue_del_event (ngx_event_t*,ngx_int_t,ngx_uint_t)"
74367,METHOD,event\modules\ngx_kqueue_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_kqueue_set_event(ngx_event_t *ev, ngx_int_t filter,
    ngx_uint_t flags);",18,21,event\modules\ngx_kqueue_module.c,ngx_kqueue_set_event,,false,28,29,ngx_kqueue_set_event,,,7,"ngx_int_t ngx_kqueue_set_event (ngx_event_t*,ngx_int_t,ngx_uint_t)"
74374,METHOD,event\modules\ngx_kqueue_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_kqueue_process_events(ngx_cycle_t *cycle, ngx_msec_t timer,
    ngx_uint_t flags);",18,21,event\modules\ngx_kqueue_module.c,ngx_kqueue_process_events,,false,33,34,ngx_kqueue_process_events,,,8,"ngx_int_t ngx_kqueue_process_events (ngx_cycle_t*,ngx_msec_t,ngx_uint_t)"
74382,METHOD,event\modules\ngx_kqueue_module.c:<global>,TYPE_DECL,static void *ngx_kqueue_create_conf(ngx_cycle_t *cycle);,13,55,event\modules\ngx_kqueue_module.c,ngx_kqueue_create_conf,,false,38,38,ngx_kqueue_create_conf,,,10,void* ngx_kqueue_create_conf (ngx_cycle_t*)
74387,METHOD,event\modules\ngx_kqueue_module.c:<global>,TYPE_DECL,"static char *ngx_kqueue_init_conf(ngx_cycle_t *cycle, void *conf);",13,65,event\modules\ngx_kqueue_module.c,ngx_kqueue_init_conf,,false,39,39,ngx_kqueue_init_conf,,,11,"char* ngx_kqueue_init_conf (ngx_cycle_t*,void*)"
74475,METHOD,event\modules\ngx_kqueue_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_kqueue_init(ngx_cycle_t *cycle, ngx_msec_t timer)
{
    ngx_kqueue_conf_t  *kcf;
    struct timespec     ts;
#if (NGX_HAVE_TIMER_EVENT)
    struct kevent       kev;
#endif

    kcf = ngx_event_get_conf(cycle->conf_ctx, ngx_kqueue_module);

    if (ngx_kqueue == -1) {
        ngx_kqueue = kqueue();

        if (ngx_kqueue == -1) {
            ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,
                          ""kqueue() failed"");
            return NGX_ERROR;
        }

#ifdef EVFILT_USER
        if (ngx_kqueue_notify_init(cycle->log) != NGX_OK) {
            return NGX_ERROR;
        }
#endif
    }

    if (max_changes < kcf->changes) {
        if (nchanges) {
            ts.tv_sec = 0;
            ts.tv_nsec = 0;

            if (kevent(ngx_kqueue, change_list, (int) nchanges, NULL, 0, &ts)
                == -1)
            {
                ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                              ""kevent() failed"");
         ...",1,1,event\modules\ngx_kqueue_module.c,ngx_kqueue_init,,false,116,227,ngx_kqueue_init,,,29,"ngx_int_t ngx_kqueue_init (ngx_cycle_t*,ngx_msec_t)"
74646,METHOD,event\modules\ngx_kqueue_module.c:<global>,TYPE_DECL,"static void
ngx_kqueue_done(ngx_cycle_t *cycle)
{
    if (close(ngx_kqueue) == -1) {
        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                      ""kqueue close() failed"");
    }

    ngx_kqueue = -1;

    ngx_free(change_list);
    ngx_free(event_list);

    change_list = NULL;
    event_list = NULL;
    max_changes = 0;
    nchanges = 0;
    nevents = 0;
}",1,1,event\modules\ngx_kqueue_module.c,ngx_kqueue_done,,false,261,279,ngx_kqueue_done,,,30,void ngx_kqueue_done (ngx_cycle_t*)
74688,METHOD,event\modules\ngx_kqueue_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_kqueue_add_event(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags)
{
    ngx_int_t          rc;
#if 0
    ngx_event_t       *e;
    ngx_connection_t  *c;
#endif

    ev->active = 1;
    ev->disabled = 0;
    ev->oneshot = (flags & NGX_ONESHOT_EVENT) ? 1 : 0;

#if 0

    if (ev->index < nchanges
        && ((uintptr_t) change_list[ev->index].udata & (uintptr_t) ~1)
            == (uintptr_t) ev)
    {
        if (change_list[ev->index].flags == EV_DISABLE) {

            /*
             * if the EV_DISABLE is still not passed to a kernel
             * we will not pass it
             */

            ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ev->log, 0,
                           ""kevent activated: %d: ft:%i"",
                           ngx_event_ident(ev->data), event);

            if (ev->index < --nchanges) {
                e = (ngx_event_t *)
                    ((uintptr_t) change_list[nchanges].udata & (uintptr_t) ~1);
                change_list[ev->index] =...",1,1,event\modules\ngx_kqueue_module.c,ngx_kqueue_add_event,,false,282,335,ngx_kqueue_add_event,,,31,"ngx_int_t ngx_kqueue_add_event (ngx_event_t*,ngx_int_t,ngx_uint_t)"
74728,METHOD,event\modules\ngx_kqueue_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_kqueue_del_event(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags)
{
    ngx_int_t     rc;
    ngx_event_t  *e;

    ev->active = 0;
    ev->disabled = 0;

    if (ev->index < nchanges
        && ((uintptr_t) change_list[ev->index].udata & (uintptr_t) ~1)
            == (uintptr_t) ev)
    {
        ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ev->log, 0,
                       ""kevent deleted: %d: ft:%i"",
                       ngx_event_ident(ev->data), event);

        /* if the event is still not passed to a kernel we will not pass it */

        nchanges--;

        if (ev->index < nchanges) {
            e = (ngx_event_t *)
                    ((uintptr_t) change_list[nchanges].udata & (uintptr_t) ~1);
            change_list[ev->index] = change_list[nchanges];
            e->index = ev->index;
        }

        return NGX_OK;
    }

    /*
     * when the file descriptor is closed the kqueue automatically deletes
     * its filters so we do not need to delete e...",1,1,event\modules\ngx_kqueue_module.c,ngx_kqueue_del_event,,false,338,389,ngx_kqueue_del_event,,,32,"ngx_int_t ngx_kqueue_del_event (ngx_event_t*,ngx_int_t,ngx_uint_t)"
74858,METHOD,event\modules\ngx_kqueue_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_kqueue_set_event(ngx_event_t *ev, ngx_int_t filter, ngx_uint_t flags)
{
    struct kevent     *kev;
    struct timespec    ts;
    ngx_connection_t  *c;

    c = ev->data;

    ngx_log_debug3(NGX_LOG_DEBUG_EVENT, ev->log, 0,
                   ""kevent set event: %d: ft:%i fl:%04Xi"",
                   c->fd, filter, flags);

    if (nchanges >= max_changes) {
        ngx_log_error(NGX_LOG_WARN, ev->log, 0,
                      ""kqueue change list is filled up"");

        ts.tv_sec = 0;
        ts.tv_nsec = 0;

        if (kevent(ngx_kqueue, change_list, (int) nchanges, NULL, 0, &ts)
            == -1)
        {
            ngx_log_error(NGX_LOG_ALERT, ev->log, ngx_errno, ""kevent() failed"");
            return NGX_ERROR;
        }

        nchanges = 0;
    }

    kev = &change_list[nchanges];

    kev->ident = c->fd;
    kev->filter = (short) filter;
    kev->flags = (u_short) flags;
    kev->udata = NGX_KQUEUE_UDATA_T ((uintptr_t) ev | ev->instance);

    if (...",1,1,event\modules\ngx_kqueue_module.c,ngx_kqueue_set_event,,false,392,475,ngx_kqueue_set_event,,,33,"ngx_int_t ngx_kqueue_set_event (ngx_event_t*,ngx_int_t,ngx_uint_t)"
75066,METHOD,event\modules\ngx_kqueue_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_kqueue_process_events(ngx_cycle_t *cycle, ngx_msec_t timer,
    ngx_uint_t flags)
{
    int               events, n;
    ngx_int_t         i, instance;
    ngx_uint_t        level;
    ngx_err_t         err;
    ngx_event_t      *ev;
    ngx_queue_t      *queue;
    struct timespec   ts, *tp;

    n = (int) nchanges;
    nchanges = 0;

    if (timer == NGX_TIMER_INFINITE) {
        tp = NULL;

    } else {

        ts.tv_sec = timer / 1000;
        ts.tv_nsec = (timer % 1000) * 1000000;

        /*
         * 64-bit Darwin kernel has the bug: kernel level ts.tv_nsec is
         * the int32_t while user level ts.tv_nsec is the long (64-bit),
         * so on the big endian PowerPC all nanoseconds are lost.
         */

#if (NGX_DARWIN_KEVENT_BUG)
        ts.tv_nsec <<= 32;
#endif

        tp = &ts;
    }

    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
                   ""kevent timer: %M, changes: %d"", timer, n);

    events = kevent(ngx_kqueue, change_li...",1,1,event\modules\ngx_kqueue_module.c,ngx_kqueue_process_events,,false,497,673,ngx_kqueue_process_events,,,34,"ngx_int_t ngx_kqueue_process_events (ngx_cycle_t*,ngx_msec_t,ngx_uint_t)"
75467,METHOD,event\modules\ngx_kqueue_module.c:<global>,TYPE_DECL,"static void *
ngx_kqueue_create_conf(ngx_cycle_t *cycle)
{
    ngx_kqueue_conf_t  *kcf;

    kcf = ngx_palloc(cycle->pool, sizeof(ngx_kqueue_conf_t));
    if (kcf == NULL) {
        return NULL;
    }

    kcf->changes = NGX_CONF_UNSET;
    kcf->events = NGX_CONF_UNSET;

    return kcf;
}",1,1,event\modules\ngx_kqueue_module.c,ngx_kqueue_create_conf,,false,696,710,ngx_kqueue_create_conf,,,36,void* ngx_kqueue_create_conf (ngx_cycle_t*)
75500,METHOD,event\modules\ngx_kqueue_module.c:<global>,TYPE_DECL,"static char *
ngx_kqueue_init_conf(ngx_cycle_t *cycle, void *conf)
{
    ngx_kqueue_conf_t *kcf = conf;

    ngx_conf_init_uint_value(kcf->changes, 512);
    ngx_conf_init_uint_value(kcf->events, 512);

    return NGX_CONF_OK;
}",1,1,event\modules\ngx_kqueue_module.c,ngx_kqueue_init_conf,,false,713,722,ngx_kqueue_init_conf,,,37,"char* ngx_kqueue_init_conf (ngx_cycle_t*,void*)"
75531,METHOD,event\modules\ngx_poll_module.c:<global>,TYPE_DECL,<global>,1,1,event\modules\ngx_poll_module.c,event\modules\ngx_poll_module.c:<global>,,false,1,416,<global>,,,1,
75533,METHOD,event\modules\ngx_poll_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_poll_init(ngx_cycle_t *cycle, ngx_msec_t timer);",18,68,event\modules\ngx_poll_module.c,ngx_poll_init,,false,13,13,ngx_poll_init,,,1,"ngx_int_t ngx_poll_init (ngx_cycle_t*,ngx_msec_t)"
75539,METHOD,event\modules\ngx_poll_module.c:<global>,TYPE_DECL,static void ngx_poll_done(ngx_cycle_t *cycle);,13,45,event\modules\ngx_poll_module.c,ngx_poll_done,,false,14,14,ngx_poll_done,,,2,void ngx_poll_done (ngx_cycle_t*)
75544,METHOD,event\modules\ngx_poll_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_poll_add_event(ngx_event_t *ev, ngx_int_t event,
    ngx_uint_t flags);",18,21,event\modules\ngx_poll_module.c,ngx_poll_add_event,,false,15,16,ngx_poll_add_event,,,3,"ngx_int_t ngx_poll_add_event (ngx_event_t*,ngx_int_t,ngx_uint_t)"
75551,METHOD,event\modules\ngx_poll_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_poll_del_event(ngx_event_t *ev, ngx_int_t event,
    ngx_uint_t flags);",18,21,event\modules\ngx_poll_module.c,ngx_poll_del_event,,false,17,18,ngx_poll_del_event,,,4,"ngx_int_t ngx_poll_del_event (ngx_event_t*,ngx_int_t,ngx_uint_t)"
75558,METHOD,event\modules\ngx_poll_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_poll_process_events(ngx_cycle_t *cycle, ngx_msec_t timer,
    ngx_uint_t flags);",18,21,event\modules\ngx_poll_module.c,ngx_poll_process_events,,false,19,20,ngx_poll_process_events,,,5,"ngx_int_t ngx_poll_process_events (ngx_cycle_t*,ngx_msec_t,ngx_uint_t)"
75565,METHOD,event\modules\ngx_poll_module.c:<global>,TYPE_DECL,"static char *ngx_poll_init_conf(ngx_cycle_t *cycle, void *conf);",13,63,event\modules\ngx_poll_module.c,ngx_poll_init_conf,,false,21,21,ngx_poll_init_conf,,,6,"char* ngx_poll_init_conf (ngx_cycle_t*,void*)"
75615,METHOD,event\modules\ngx_poll_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_poll_init(ngx_cycle_t *cycle, ngx_msec_t timer)
{
    struct pollfd   *list;

    if (event_list == NULL) {
        nevents = 0;
    }

    if (ngx_process >= NGX_PROCESS_WORKER
        || cycle->old_cycle == NULL
        || cycle->old_cycle->connection_n < cycle->connection_n)
    {
        list = ngx_alloc(sizeof(struct pollfd) * cycle->connection_n,
                         cycle->log);
        if (list == NULL) {
            return NGX_ERROR;
        }

        if (event_list) {
            ngx_memcpy(list, event_list, sizeof(struct pollfd) * nevents);
            ngx_free(event_list);
        }

        event_list = list;
    }

    ngx_io = ngx_os_io;

    ngx_event_actions = ngx_poll_module_ctx.actions;

    ngx_event_flags = NGX_USE_LEVEL_EVENT|NGX_USE_FD_EVENT;

    return NGX_OK;
}",1,1,event\modules\ngx_poll_module.c,ngx_poll_init,,false,67,101,ngx_poll_init,,,16,"ngx_int_t ngx_poll_init (ngx_cycle_t*,ngx_msec_t)"
75700,METHOD,event\modules\ngx_poll_module.c:<global>,TYPE_DECL,"static void
ngx_poll_done(ngx_cycle_t *cycle)
{
    ngx_free(event_list);

    event_list = NULL;
}",1,1,event\modules\ngx_poll_module.c,ngx_poll_done,,false,104,110,ngx_poll_done,,,17,void ngx_poll_done (ngx_cycle_t*)
75710,METHOD,event\modules\ngx_poll_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_poll_add_event(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags)
{
    ngx_event_t       *e;
    ngx_connection_t  *c;

    c = ev->data;

    ev->active = 1;

    if (ev->index != NGX_INVALID_INDEX) {
        ngx_log_error(NGX_LOG_ALERT, ev->log, 0,
                      ""poll event fd:%d ev:%i is already set"", c->fd, event);
        return NGX_OK;
    }

    if (event == NGX_READ_EVENT) {
        e = c->write;
#if (NGX_READ_EVENT != POLLIN)
        event = POLLIN;
#endif

    } else {
        e = c->read;
#if (NGX_WRITE_EVENT != POLLOUT)
        event = POLLOUT;
#endif
    }

    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ev->log, 0,
                   ""poll add event: fd:%d ev:%i"", c->fd, event);

    if (e == NULL || e->index == NGX_INVALID_INDEX) {
        event_list[nevents].fd = c->fd;
        event_list[nevents].events = (short) event;
        event_list[nevents].revents = 0;

        ev->index = nevents;
        nevents++;

    } else {
        ngx_log_debug...",1,1,event\modules\ngx_poll_module.c,ngx_poll_add_event,,false,113,162,ngx_poll_add_event,,,18,"ngx_int_t ngx_poll_add_event (ngx_event_t*,ngx_int_t,ngx_uint_t)"
75852,METHOD,event\modules\ngx_poll_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_poll_del_event(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags)
{
    ngx_event_t       *e;
    ngx_connection_t  *c;

    c = ev->data;

    ev->active = 0;

    if (ev->index == NGX_INVALID_INDEX) {
        ngx_log_error(NGX_LOG_ALERT, ev->log, 0,
                      ""poll event fd:%d ev:%i is already deleted"",
                      c->fd, event);
        return NGX_OK;
    }

    if (event == NGX_READ_EVENT) {
        e = c->write;
#if (NGX_READ_EVENT != POLLIN)
        event = POLLIN;
#endif

    } else {
        e = c->read;
#if (NGX_WRITE_EVENT != POLLOUT)
        event = POLLOUT;
#endif
    }

    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ev->log, 0,
                   ""poll del event: fd:%d ev:%i"", c->fd, event);

    if (e == NULL || e->index == NGX_INVALID_INDEX) {
        nevents--;

        if (ev->index < nevents) {

            ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ev->log, 0,
                           ""index: copy event %ui to %i"", nevents, ev->inde...",1,1,event\modules\ngx_poll_module.c,ngx_poll_del_event,,false,165,235,ngx_poll_del_event,,,19,"ngx_int_t ngx_poll_del_event (ngx_event_t*,ngx_int_t,ngx_uint_t)"
76054,METHOD,event\modules\ngx_poll_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_poll_process_events(ngx_cycle_t *cycle, ngx_msec_t timer, ngx_uint_t flags)
{
    int                 ready, revents;
    ngx_err_t           err;
    ngx_uint_t          i, found, level;
    ngx_event_t        *ev;
    ngx_queue_t        *queue;
    ngx_connection_t   *c;

    /* NGX_TIMER_INFINITE == INFTIM */

#if (NGX_DEBUG0)
    if (cycle->log->log_level & NGX_LOG_DEBUG_ALL) {
        for (i = 0; i < nevents; i++) {
            ngx_log_debug3(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
                           ""poll: %ui: fd:%d ev:%04Xd"",
                           i, event_list[i].fd, event_list[i].events);
        }
    }
#endif

    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle->log, 0, ""poll timer: %M"", timer);

    ready = poll(event_list, (u_int) nevents, (int) timer);

    err = (ready == -1) ? ngx_errno : 0;

    if (flags & NGX_UPDATE_TIME || ngx_event_timer_alarm) {
        ngx_time_update();
    }

    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
   ...",1,1,event\modules\ngx_poll_module.c,ngx_poll_process_events,,false,238,401,ngx_poll_process_events,,,20,"ngx_int_t ngx_poll_process_events (ngx_cycle_t*,ngx_msec_t,ngx_uint_t)"
76427,METHOD,event\modules\ngx_poll_module.c:<global>,TYPE_DECL,"static char *
ngx_poll_init_conf(ngx_cycle_t *cycle, void *conf)
{
    ngx_event_conf_t  *ecf;

    ecf = ngx_event_get_conf(cycle->conf_ctx, ngx_event_core_module);

    if (ecf->use != ngx_poll_module.ctx_index) {
        return NGX_CONF_OK;
    }

    return NGX_CONF_OK;
}",1,1,event\modules\ngx_poll_module.c,ngx_poll_init_conf,,false,404,416,ngx_poll_init_conf,,,21,"char* ngx_poll_init_conf (ngx_cycle_t*,void*)"
76463,METHOD,event\modules\ngx_select_module.c:<global>,TYPE_DECL,<global>,1,1,event\modules\ngx_select_module.c,event\modules\ngx_select_module.c:<global>,,false,1,424,<global>,,,1,
76465,METHOD,event\modules\ngx_select_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_select_init(ngx_cycle_t *cycle, ngx_msec_t timer);",18,70,event\modules\ngx_select_module.c,ngx_select_init,,false,13,13,ngx_select_init,,,1,"ngx_int_t ngx_select_init (ngx_cycle_t*,ngx_msec_t)"
76471,METHOD,event\modules\ngx_select_module.c:<global>,TYPE_DECL,static void ngx_select_done(ngx_cycle_t *cycle);,13,47,event\modules\ngx_select_module.c,ngx_select_done,,false,14,14,ngx_select_done,,,2,void ngx_select_done (ngx_cycle_t*)
76476,METHOD,event\modules\ngx_select_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_select_add_event(ngx_event_t *ev, ngx_int_t event,
    ngx_uint_t flags);",18,21,event\modules\ngx_select_module.c,ngx_select_add_event,,false,15,16,ngx_select_add_event,,,3,"ngx_int_t ngx_select_add_event (ngx_event_t*,ngx_int_t,ngx_uint_t)"
76483,METHOD,event\modules\ngx_select_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_select_del_event(ngx_event_t *ev, ngx_int_t event,
    ngx_uint_t flags);",18,21,event\modules\ngx_select_module.c,ngx_select_del_event,,false,17,18,ngx_select_del_event,,,4,"ngx_int_t ngx_select_del_event (ngx_event_t*,ngx_int_t,ngx_uint_t)"
76490,METHOD,event\modules\ngx_select_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_select_process_events(ngx_cycle_t *cycle, ngx_msec_t timer,
    ngx_uint_t flags);",18,21,event\modules\ngx_select_module.c,ngx_select_process_events,,false,19,20,ngx_select_process_events,,,5,"ngx_int_t ngx_select_process_events (ngx_cycle_t*,ngx_msec_t,ngx_uint_t)"
76497,METHOD,event\modules\ngx_select_module.c:<global>,TYPE_DECL,static void ngx_select_repair_fd_sets(ngx_cycle_t *cycle);,13,57,event\modules\ngx_select_module.c,ngx_select_repair_fd_sets,,false,21,21,ngx_select_repair_fd_sets,,,6,void ngx_select_repair_fd_sets (ngx_cycle_t*)
76502,METHOD,event\modules\ngx_select_module.c:<global>,TYPE_DECL,"static char *ngx_select_init_conf(ngx_cycle_t *cycle, void *conf);",13,65,event\modules\ngx_select_module.c,ngx_select_init_conf,,false,22,22,ngx_select_init_conf,,,7,"char* ngx_select_init_conf (ngx_cycle_t*,void*)"
76556,METHOD,event\modules\ngx_select_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_select_init(ngx_cycle_t *cycle, ngx_msec_t timer)
{
    ngx_event_t  **index;

    if (event_index == NULL) {
        FD_ZERO(&master_read_fd_set);
        FD_ZERO(&master_write_fd_set);
        nevents = 0;
    }

    if (ngx_process >= NGX_PROCESS_WORKER
        || cycle->old_cycle == NULL
        || cycle->old_cycle->connection_n < cycle->connection_n)
    {
        index = ngx_alloc(sizeof(ngx_event_t *) * 2 * cycle->connection_n,
                          cycle->log);
        if (index == NULL) {
            return NGX_ERROR;
        }

        if (event_index) {
            ngx_memcpy(index, event_index, sizeof(ngx_event_t *) * nevents);
            ngx_free(event_index);
        }

        event_index = index;
    }

    ngx_io = ngx_os_io;

    ngx_event_actions = ngx_select_module_ctx.actions;

    ngx_event_flags = NGX_USE_LEVEL_EVENT;

    max_fd = -1;

    return NGX_OK;
}",1,1,event\modules\ngx_select_module.c,ngx_select_init,,false,74,112,ngx_select_init,,,21,"ngx_int_t ngx_select_init (ngx_cycle_t*,ngx_msec_t)"
76651,METHOD,event\modules\ngx_select_module.c:<global>,TYPE_DECL,"static void
ngx_select_done(ngx_cycle_t *cycle)
{
    ngx_free(event_index);

    event_index = NULL;
}",1,1,event\modules\ngx_select_module.c,ngx_select_done,,false,115,121,ngx_select_done,,,22,void ngx_select_done (ngx_cycle_t*)
76661,METHOD,event\modules\ngx_select_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_select_add_event(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags)
{
    ngx_connection_t  *c;

    c = ev->data;

    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ev->log, 0,
                   ""select add event fd:%d ev:%i"", c->fd, event);

    if (ev->index != NGX_INVALID_INDEX) {
        ngx_log_error(NGX_LOG_ALERT, ev->log, 0,
                      ""select event fd:%d ev:%i is already set"", c->fd, event);
        return NGX_OK;
    }

    if ((event == NGX_READ_EVENT && ev->write)
        || (event == NGX_WRITE_EVENT && !ev->write))
    {
        ngx_log_error(NGX_LOG_ALERT, ev->log, 0,
                      ""invalid select %s event fd:%d ev:%i"",
                      ev->write ? ""write"" : ""read"", c->fd, event);
        return NGX_ERROR;
    }

    if (event == NGX_READ_EVENT) {
        FD_SET(c->fd, &master_read_fd_set);

    } else if (event == NGX_WRITE_EVENT) {
        FD_SET(c->fd, &master_write_fd_set);
    }

    if (max_fd != -1 && max_fd < c->fd) {
      ...",1,1,event\modules\ngx_select_module.c,ngx_select_add_event,,false,124,167,ngx_select_add_event,,,23,"ngx_int_t ngx_select_add_event (ngx_event_t*,ngx_int_t,ngx_uint_t)"
76802,METHOD,event\modules\ngx_select_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_select_del_event(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags)
{
    ngx_event_t       *e;
    ngx_connection_t  *c;

    c = ev->data;

    ev->active = 0;

    if (ev->index == NGX_INVALID_INDEX) {
        return NGX_OK;
    }

    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ev->log, 0,
                   ""select del event fd:%d ev:%i"", c->fd, event);

    if (event == NGX_READ_EVENT) {
        FD_CLR(c->fd, &master_read_fd_set);

    } else if (event == NGX_WRITE_EVENT) {
        FD_CLR(c->fd, &master_write_fd_set);
    }

    if (max_fd == c->fd) {
        max_fd = -1;
    }

    if (ev->index < --nevents) {
        e = event_index[nevents];
        event_index[ev->index] = e;
        e->index = ev->index;
    }

    ev->index = NGX_INVALID_INDEX;

    return NGX_OK;
}",1,1,event\modules\ngx_select_module.c,ngx_select_del_event,,false,170,207,ngx_select_del_event,,,24,"ngx_int_t ngx_select_del_event (ngx_event_t*,ngx_int_t,ngx_uint_t)"
76910,METHOD,event\modules\ngx_select_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_select_process_events(ngx_cycle_t *cycle, ngx_msec_t timer,
    ngx_uint_t flags)
{
    int                ready, nready;
    ngx_err_t          err;
    ngx_uint_t         i, found;
    ngx_event_t       *ev;
    ngx_queue_t       *queue;
    struct timeval     tv, *tp;
    ngx_connection_t  *c;

    if (max_fd == -1) {
        for (i = 0; i < nevents; i++) {
            c = event_index[i]->data;
            if (max_fd < c->fd) {
                max_fd = c->fd;
            }
        }

        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
                       ""change max_fd: %i"", max_fd);
    }

#if (NGX_DEBUG)
    if (cycle->log->log_level & NGX_LOG_DEBUG_ALL) {
        for (i = 0; i < nevents; i++) {
            ev = event_index[i];
            c = ev->data;
            ngx_log_debug2(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
                           ""select event: fd:%d wr:%d"", c->fd, ev->write);
        }

        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycl...",1,1,event\modules\ngx_select_module.c,ngx_select_process_events,,false,210,352,ngx_select_process_events,,,25,"ngx_int_t ngx_select_process_events (ngx_cycle_t*,ngx_msec_t,ngx_uint_t)"
77241,METHOD,event\modules\ngx_select_module.c:<global>,TYPE_DECL,"static void
ngx_select_repair_fd_sets(ngx_cycle_t *cycle)
{
    int           n;
    socklen_t     len;
    ngx_err_t     err;
    ngx_socket_t  s;

    for (s = 0; s <= max_fd; s++) {

        if (FD_ISSET(s, &master_read_fd_set) == 0) {
            continue;
        }

        len = sizeof(int);

        if (getsockopt(s, SOL_SOCKET, SO_TYPE, &n, &len) == -1) {
            err = ngx_socket_errno;

            ngx_log_error(NGX_LOG_ALERT, cycle->log, err,
                          ""invalid descriptor #%d in read fd_set"", s);

            FD_CLR(s, &master_read_fd_set);
        }
    }

    for (s = 0; s <= max_fd; s++) {

        if (FD_ISSET(s, &master_write_fd_set) == 0) {
            continue;
        }

        len = sizeof(int);

        if (getsockopt(s, SOL_SOCKET, SO_TYPE, &n, &len) == -1) {
            err = ngx_socket_errno;

            ngx_log_error(NGX_LOG_ALERT, cycle->log, err,
                          ""invalid descriptor #%d in write fd_set"", s);

            FD_CL...",1,1,event\modules\ngx_select_module.c,ngx_select_repair_fd_sets,,false,355,400,ngx_select_repair_fd_sets,,,26,void ngx_select_repair_fd_sets (ngx_cycle_t*)
77358,METHOD,event\modules\ngx_select_module.c:<global>,TYPE_DECL,"static char *
ngx_select_init_conf(ngx_cycle_t *cycle, void *conf)
{
    ngx_event_conf_t  *ecf;

    ecf = ngx_event_get_conf(cycle->conf_ctx, ngx_event_core_module);

    if (ecf->use != ngx_select_module.ctx_index) {
        return NGX_CONF_OK;
    }

    /* disable warning: the default FD_SETSIZE is 1024U in FreeBSD 5.x */

    if (cycle->connection_n > FD_SETSIZE) {
        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
                      ""the maximum number of files ""
                      ""supported by select() is %ud"", FD_SETSIZE);
        return NGX_CONF_ERROR;
    }

    return NGX_CONF_OK;
}",1,1,event\modules\ngx_select_module.c,ngx_select_init_conf,,false,403,424,ngx_select_init_conf,,,27,"char* ngx_select_init_conf (ngx_cycle_t*,void*)"
77411,METHOD,event\modules\ngx_win32_poll_module.c:<global>,TYPE_DECL,<global>,1,1,event\modules\ngx_win32_poll_module.c,event\modules\ngx_win32_poll_module.c:<global>,,false,1,436,<global>,,,1,
77413,METHOD,event\modules\ngx_win32_poll_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_poll_init(ngx_cycle_t *cycle, ngx_msec_t timer);",18,68,event\modules\ngx_win32_poll_module.c,ngx_poll_init,,false,14,14,ngx_poll_init,,,1,"ngx_int_t ngx_poll_init (ngx_cycle_t*,ngx_msec_t)"
77419,METHOD,event\modules\ngx_win32_poll_module.c:<global>,TYPE_DECL,static void ngx_poll_done(ngx_cycle_t *cycle);,13,45,event\modules\ngx_win32_poll_module.c,ngx_poll_done,,false,15,15,ngx_poll_done,,,2,void ngx_poll_done (ngx_cycle_t*)
77424,METHOD,event\modules\ngx_win32_poll_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_poll_add_event(ngx_event_t *ev, ngx_int_t event,
    ngx_uint_t flags);",18,21,event\modules\ngx_win32_poll_module.c,ngx_poll_add_event,,false,16,17,ngx_poll_add_event,,,3,"ngx_int_t ngx_poll_add_event (ngx_event_t*,ngx_int_t,ngx_uint_t)"
77431,METHOD,event\modules\ngx_win32_poll_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_poll_del_event(ngx_event_t *ev, ngx_int_t event,
    ngx_uint_t flags);",18,21,event\modules\ngx_win32_poll_module.c,ngx_poll_del_event,,false,18,19,ngx_poll_del_event,,,4,"ngx_int_t ngx_poll_del_event (ngx_event_t*,ngx_int_t,ngx_uint_t)"
77438,METHOD,event\modules\ngx_win32_poll_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_poll_process_events(ngx_cycle_t *cycle, ngx_msec_t timer,
    ngx_uint_t flags);",18,21,event\modules\ngx_win32_poll_module.c,ngx_poll_process_events,,false,20,21,ngx_poll_process_events,,,5,"ngx_int_t ngx_poll_process_events (ngx_cycle_t*,ngx_msec_t,ngx_uint_t)"
77445,METHOD,event\modules\ngx_win32_poll_module.c:<global>,TYPE_DECL,"static char *ngx_poll_init_conf(ngx_cycle_t *cycle, void *conf);",13,63,event\modules\ngx_win32_poll_module.c,ngx_poll_init_conf,,false,22,22,ngx_poll_init_conf,,,6,"char* ngx_poll_init_conf (ngx_cycle_t*,void*)"
77496,METHOD,event\modules\ngx_win32_poll_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_poll_init(ngx_cycle_t *cycle, ngx_msec_t timer)
{
    struct pollfd      *list;
    ngx_connection_t  **index;

    if (event_list == NULL) {
        nevents = 0;
    }

    if (ngx_process >= NGX_PROCESS_WORKER
        || cycle->old_cycle == NULL
        || cycle->old_cycle->connection_n < cycle->connection_n)
    {
        list = ngx_alloc(sizeof(struct pollfd) * cycle->connection_n,
                         cycle->log);
        if (list == NULL) {
            return NGX_ERROR;
        }

        if (event_list) {
            ngx_memcpy(list, event_list, sizeof(struct pollfd) * nevents);
            ngx_free(event_list);
        }

        event_list = list;

        index = ngx_alloc(sizeof(ngx_connection_t *) * cycle->connection_n,
                          cycle->log);
        if (index == NULL) {
            return NGX_ERROR;
        }

        if (event_index) {
            ngx_memcpy(index, event_index,
                       sizeof(ngx_connection_t *) *...",1,1,event\modules\ngx_win32_poll_module.c,ngx_poll_init,,false,69,118,ngx_poll_init,,,17,"ngx_int_t ngx_poll_init (ngx_cycle_t*,ngx_msec_t)"
77614,METHOD,event\modules\ngx_win32_poll_module.c:<global>,TYPE_DECL,"static void
ngx_poll_done(ngx_cycle_t *cycle)
{
    ngx_free(event_list);
    ngx_free(event_index);

    event_list = NULL;
    event_index = NULL;
}",1,1,event\modules\ngx_win32_poll_module.c,ngx_poll_done,,false,121,129,ngx_poll_done,,,18,void ngx_poll_done (ngx_cycle_t*)
77629,METHOD,event\modules\ngx_win32_poll_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_poll_add_event(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags)
{
    ngx_event_t       *e;
    ngx_connection_t  *c;

    c = ev->data;

    ev->active = 1;

    if (ev->index != NGX_INVALID_INDEX) {
        ngx_log_error(NGX_LOG_ALERT, ev->log, 0,
                      ""poll event fd:%d ev:%i is already set"", c->fd, event);
        return NGX_OK;
    }

    if (event == NGX_READ_EVENT) {
        e = c->write;
#if (NGX_READ_EVENT != POLLIN)
        event = POLLIN;
#endif

    } else {
        e = c->read;
#if (NGX_WRITE_EVENT != POLLOUT)
        event = POLLOUT;
#endif
    }

    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ev->log, 0,
                   ""poll add event: fd:%d ev:%i"", c->fd, event);

    if (e == NULL || e->index == NGX_INVALID_INDEX) {

        event_list[nevents].fd = c->fd;
        event_list[nevents].events = (short) event;
        event_list[nevents].revents = 0;

        event_index[nevents] = c;

        ev->index = nevents;
        nevents++;...",1,1,event\modules\ngx_win32_poll_module.c,ngx_poll_add_event,,false,132,184,ngx_poll_add_event,,,19,"ngx_int_t ngx_poll_add_event (ngx_event_t*,ngx_int_t,ngx_uint_t)"
77776,METHOD,event\modules\ngx_win32_poll_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_poll_del_event(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags)
{
    ngx_event_t       *e;
    ngx_connection_t  *c;

    c = ev->data;

    ev->active = 0;

    if (ev->index == NGX_INVALID_INDEX) {
        ngx_log_error(NGX_LOG_ALERT, ev->log, 0,
                      ""poll event fd:%d ev:%i is already deleted"",
                      c->fd, event);
        return NGX_OK;
    }

    if (event == NGX_READ_EVENT) {
        e = c->write;
#if (NGX_READ_EVENT != POLLIN)
        event = POLLIN;
#endif

    } else {
        e = c->read;
#if (NGX_WRITE_EVENT != POLLOUT)
        event = POLLOUT;
#endif
    }

    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ev->log, 0,
                   ""poll del event: fd:%d ev:%i"", c->fd, event);

    if (e == NULL || e->index == NGX_INVALID_INDEX) {
        nevents--;

        if (ev->index < nevents) {

            ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ev->log, 0,
                           ""index: copy event %ui to %i"", nevents, ev->inde...",1,1,event\modules\ngx_win32_poll_module.c,ngx_poll_del_event,,false,187,258,ngx_poll_del_event,,,20,"ngx_int_t ngx_poll_del_event (ngx_event_t*,ngx_int_t,ngx_uint_t)"
77984,METHOD,event\modules\ngx_win32_poll_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_poll_process_events(ngx_cycle_t *cycle, ngx_msec_t timer, ngx_uint_t flags)
{
    int                 ready, revents;
    ngx_err_t           err;
    ngx_uint_t          i, found;
    ngx_event_t        *ev;
    ngx_queue_t        *queue;
    ngx_connection_t   *c;

    /* NGX_TIMER_INFINITE == INFTIM */

#if (NGX_DEBUG0)
    if (cycle->log->log_level & NGX_LOG_DEBUG_ALL) {
        for (i = 0; i < nevents; i++) {
            ngx_log_debug3(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
                           ""poll: %ui: fd:%d ev:%04Xd"",
                           i, event_list[i].fd, event_list[i].events);
        }
    }
#endif

    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle->log, 0, ""poll timer: %M"", timer);

    ready = WSAPoll(event_list, (u_int) nevents, (int) timer);

    err = (ready == -1) ? ngx_errno : 0;

    if (flags & NGX_UPDATE_TIME || ngx_event_timer_alarm) {
        ngx_time_update();
    }

    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
       ...",1,1,event\modules\ngx_win32_poll_module.c,ngx_poll_process_events,,false,261,411,ngx_poll_process_events,,,21,"ngx_int_t ngx_poll_process_events (ngx_cycle_t*,ngx_msec_t,ngx_uint_t)"
78332,METHOD,event\modules\ngx_win32_poll_module.c:<global>,TYPE_DECL,"static char *
ngx_poll_init_conf(ngx_cycle_t *cycle, void *conf)
{
    ngx_event_conf_t  *ecf;

    ecf = ngx_event_get_conf(cycle->conf_ctx, ngx_event_core_module);

    if (ecf->use != ngx_poll_module.ctx_index) {
        return NGX_CONF_OK;
    }

#if (NGX_LOAD_WSAPOLL)

    if (!ngx_have_wsapoll) {
        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
                      ""poll is not available on this platform"");
        return NGX_CONF_ERROR;
    }

#endif

    return NGX_CONF_OK;
}",1,1,event\modules\ngx_win32_poll_module.c,ngx_poll_init_conf,,false,414,436,ngx_poll_init_conf,,,22,"char* ngx_poll_init_conf (ngx_cycle_t*,void*)"
78368,METHOD,event\modules\ngx_win32_select_module.c:<global>,TYPE_DECL,<global>,1,1,event\modules\ngx_win32_select_module.c,event\modules\ngx_win32_select_module.c:<global>,,false,1,408,<global>,,,1,
78370,METHOD,event\modules\ngx_win32_select_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_select_init(ngx_cycle_t *cycle, ngx_msec_t timer);",18,70,event\modules\ngx_win32_select_module.c,ngx_select_init,,false,13,13,ngx_select_init,,,1,"ngx_int_t ngx_select_init (ngx_cycle_t*,ngx_msec_t)"
78376,METHOD,event\modules\ngx_win32_select_module.c:<global>,TYPE_DECL,static void ngx_select_done(ngx_cycle_t *cycle);,13,47,event\modules\ngx_win32_select_module.c,ngx_select_done,,false,14,14,ngx_select_done,,,2,void ngx_select_done (ngx_cycle_t*)
78381,METHOD,event\modules\ngx_win32_select_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_select_add_event(ngx_event_t *ev, ngx_int_t event,
    ngx_uint_t flags);",18,21,event\modules\ngx_win32_select_module.c,ngx_select_add_event,,false,15,16,ngx_select_add_event,,,3,"ngx_int_t ngx_select_add_event (ngx_event_t*,ngx_int_t,ngx_uint_t)"
78388,METHOD,event\modules\ngx_win32_select_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_select_del_event(ngx_event_t *ev, ngx_int_t event,
    ngx_uint_t flags);",18,21,event\modules\ngx_win32_select_module.c,ngx_select_del_event,,false,17,18,ngx_select_del_event,,,4,"ngx_int_t ngx_select_del_event (ngx_event_t*,ngx_int_t,ngx_uint_t)"
78395,METHOD,event\modules\ngx_win32_select_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_select_process_events(ngx_cycle_t *cycle, ngx_msec_t timer,
    ngx_uint_t flags);",18,21,event\modules\ngx_win32_select_module.c,ngx_select_process_events,,false,19,20,ngx_select_process_events,,,5,"ngx_int_t ngx_select_process_events (ngx_cycle_t*,ngx_msec_t,ngx_uint_t)"
78402,METHOD,event\modules\ngx_win32_select_module.c:<global>,TYPE_DECL,static void ngx_select_repair_fd_sets(ngx_cycle_t *cycle);,13,57,event\modules\ngx_win32_select_module.c,ngx_select_repair_fd_sets,,false,21,21,ngx_select_repair_fd_sets,,,6,void ngx_select_repair_fd_sets (ngx_cycle_t*)
78407,METHOD,event\modules\ngx_win32_select_module.c:<global>,TYPE_DECL,"static char *ngx_select_init_conf(ngx_cycle_t *cycle, void *conf);",13,65,event\modules\ngx_win32_select_module.c,ngx_select_init_conf,,false,22,22,ngx_select_init_conf,,,7,"char* ngx_select_init_conf (ngx_cycle_t*,void*)"
78463,METHOD,event\modules\ngx_win32_select_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_select_init(ngx_cycle_t *cycle, ngx_msec_t timer)
{
    ngx_event_t  **index;

    if (event_index == NULL) {
        FD_ZERO(&master_read_fd_set);
        FD_ZERO(&master_write_fd_set);
        nevents = 0;
    }

    if (ngx_process >= NGX_PROCESS_WORKER
        || cycle->old_cycle == NULL
        || cycle->old_cycle->connection_n < cycle->connection_n)
    {
        index = ngx_alloc(sizeof(ngx_event_t *) * 2 * cycle->connection_n,
                          cycle->log);
        if (index == NULL) {
            return NGX_ERROR;
        }

        if (event_index) {
            ngx_memcpy(index, event_index, sizeof(ngx_event_t *) * nevents);
            ngx_free(event_index);
        }

        event_index = index;
    }

    ngx_io = ngx_os_io;

    ngx_event_actions = ngx_select_module_ctx.actions;

    ngx_event_flags = NGX_USE_LEVEL_EVENT;

    max_read = 0;
    max_write = 0;

    return NGX_OK;
}",1,1,event\modules\ngx_win32_select_module.c,ngx_select_init,,false,76,115,ngx_select_init,,,23,"ngx_int_t ngx_select_init (ngx_cycle_t*,ngx_msec_t)"
78560,METHOD,event\modules\ngx_win32_select_module.c:<global>,TYPE_DECL,"static void
ngx_select_done(ngx_cycle_t *cycle)
{
    ngx_free(event_index);

    event_index = NULL;
}",1,1,event\modules\ngx_win32_select_module.c,ngx_select_done,,false,118,124,ngx_select_done,,,24,void ngx_select_done (ngx_cycle_t*)
78570,METHOD,event\modules\ngx_win32_select_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_select_add_event(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags)
{
    ngx_connection_t  *c;

    c = ev->data;

    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ev->log, 0,
                   ""select add event fd:%d ev:%i"", c->fd, event);

    if (ev->index != NGX_INVALID_INDEX) {
        ngx_log_error(NGX_LOG_ALERT, ev->log, 0,
                      ""select event fd:%d ev:%i is already set"", c->fd, event);
        return NGX_OK;
    }

    if ((event == NGX_READ_EVENT && ev->write)
        || (event == NGX_WRITE_EVENT && !ev->write))
    {
        ngx_log_error(NGX_LOG_ALERT, ev->log, 0,
                      ""invalid select %s event fd:%d ev:%i"",
                      ev->write ? ""write"" : ""read"", c->fd, event);
        return NGX_ERROR;
    }

    if ((event == NGX_READ_EVENT && max_read >= FD_SETSIZE)
        || (event == NGX_WRITE_EVENT && max_write >= FD_SETSIZE))
    {
        ngx_log_error(NGX_LOG_ERR, ev->log, 0,
                      ""maximum number of des...",1,1,event\modules\ngx_win32_select_module.c,ngx_select_add_event,,false,127,177,ngx_select_add_event,,,25,"ngx_int_t ngx_select_add_event (ngx_event_t*,ngx_int_t,ngx_uint_t)"
78725,METHOD,event\modules\ngx_win32_select_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_select_del_event(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags)
{
    ngx_event_t       *e;
    ngx_connection_t  *c;

    c = ev->data;

    ev->active = 0;

    if (ev->index == NGX_INVALID_INDEX) {
        return NGX_OK;
    }

    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ev->log, 0,
                   ""select del event fd:%d ev:%i"", c->fd, event);

    if (event == NGX_READ_EVENT) {
        FD_CLR(c->fd, &master_read_fd_set);
        max_read--;

    } else if (event == NGX_WRITE_EVENT) {
        FD_CLR(c->fd, &master_write_fd_set);
        max_write--;
    }

    if (ev->index < --nevents) {
        e = event_index[nevents];
        event_index[ev->index] = e;
        e->index = ev->index;
    }

    ev->index = NGX_INVALID_INDEX;

    return NGX_OK;
}",1,1,event\modules\ngx_win32_select_module.c,ngx_select_del_event,,false,180,215,ngx_select_del_event,,,26,"ngx_int_t ngx_select_del_event (ngx_event_t*,ngx_int_t,ngx_uint_t)"
78826,METHOD,event\modules\ngx_win32_select_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_select_process_events(ngx_cycle_t *cycle, ngx_msec_t timer,
    ngx_uint_t flags)
{
    int                ready, nready;
    ngx_err_t          err;
    ngx_uint_t         i, found;
    ngx_event_t       *ev;
    ngx_queue_t       *queue;
    struct timeval     tv, *tp;
    ngx_connection_t  *c;

#if (NGX_DEBUG)
    if (cycle->log->log_level & NGX_LOG_DEBUG_ALL) {
        for (i = 0; i < nevents; i++) {
            ev = event_index[i];
            c = ev->data;
            ngx_log_debug2(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
                           ""select event: fd:%d wr:%d"", c->fd, ev->write);
        }
    }
#endif

    if (timer == NGX_TIMER_INFINITE) {
        tp = NULL;

    } else {
        tv.tv_sec = (long) (timer / 1000);
        tv.tv_usec = (long) ((timer % 1000) * 1000);
        tp = &tv;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
                   ""select timer: %M"", timer);

    work_read_fd_set = master_read_fd_set;
    work...",1,1,event\modules\ngx_win32_select_module.c,ngx_select_process_events,,false,218,352,ngx_select_process_events,,,27,"ngx_int_t ngx_select_process_events (ngx_cycle_t*,ngx_msec_t,ngx_uint_t)"
79122,METHOD,event\modules\ngx_win32_select_module.c:<global>,TYPE_DECL,"static void
ngx_select_repair_fd_sets(ngx_cycle_t *cycle)
{
    int           n;
    u_int         i;
    socklen_t     len;
    ngx_err_t     err;
    ngx_socket_t  s;

    for (i = 0; i < master_read_fd_set.fd_count; i++) {

        s = master_read_fd_set.fd_array[i];
        len = sizeof(int);

        if (getsockopt(s, SOL_SOCKET, SO_TYPE, (char *) &n, &len) == -1) {
            err = ngx_socket_errno;

            ngx_log_error(NGX_LOG_ALERT, cycle->log, err,
                          ""invalid descriptor #%d in read fd_set"", s);

            FD_CLR(s, &master_read_fd_set);
        }
    }

    for (i = 0; i < master_write_fd_set.fd_count; i++) {

        s = master_write_fd_set.fd_array[i];
        len = sizeof(int);

        if (getsockopt(s, SOL_SOCKET, SO_TYPE, (char *) &n, &len) == -1) {
            err = ngx_socket_errno;

            ngx_log_error(NGX_LOG_ALERT, cycle->log, err,
                          ""invalid descriptor #%d in write fd_set"", s);

            FD_CLR(s,...",1,1,event\modules\ngx_win32_select_module.c,ngx_select_repair_fd_sets,,false,355,393,ngx_select_repair_fd_sets,,,28,void ngx_select_repair_fd_sets (ngx_cycle_t*)
79240,METHOD,event\modules\ngx_win32_select_module.c:<global>,TYPE_DECL,"static char *
ngx_select_init_conf(ngx_cycle_t *cycle, void *conf)
{
    ngx_event_conf_t  *ecf;

    ecf = ngx_event_get_conf(cycle->conf_ctx, ngx_event_core_module);

    if (ecf->use != ngx_select_module.ctx_index) {
        return NGX_CONF_OK;
    }

    return NGX_CONF_OK;
}",1,1,event\modules\ngx_win32_select_module.c,ngx_select_init_conf,,false,396,408,ngx_select_init_conf,,,29,"char* ngx_select_init_conf (ngx_cycle_t*,void*)"
79276,METHOD,event\ngx_event.c:<global>,TYPE_DECL,<global>,1,47,event\ngx_event.c,event\ngx_event.c:<global>,,false,1,1336,<global>,,,1,
79283,METHOD,event\ngx_event.c:<global>,TYPE_DECL,"static char *ngx_event_init_conf(ngx_cycle_t *cycle, void *conf);",13,64,event\ngx_event.c,ngx_event_init_conf,,false,23,23,ngx_event_init_conf,,,6,"char* ngx_event_init_conf (ngx_cycle_t*,void*)"
79289,METHOD,event\ngx_event.c:<global>,TYPE_DECL,static ngx_int_t ngx_event_module_init(ngx_cycle_t *cycle);,18,58,event\ngx_event.c,ngx_event_module_init,,false,24,24,ngx_event_module_init,,,7,ngx_int_t ngx_event_module_init (ngx_cycle_t*)
79294,METHOD,event\ngx_event.c:<global>,TYPE_DECL,static ngx_int_t ngx_event_process_init(ngx_cycle_t *cycle);,18,59,event\ngx_event.c,ngx_event_process_init,,false,25,25,ngx_event_process_init,,,8,ngx_int_t ngx_event_process_init (ngx_cycle_t*)
79299,METHOD,event\ngx_event.c:<global>,TYPE_DECL,"static char *ngx_events_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",13,77,event\ngx_event.c,ngx_events_block,,false,26,26,ngx_events_block,,,9,"char* ngx_events_block (ngx_conf_t*,ngx_command_t*,void*)"
79306,METHOD,event\ngx_event.c:<global>,TYPE_DECL,"static char *ngx_event_connections(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,event\ngx_event.c,ngx_event_connections,,false,28,29,ngx_event_connections,,,10,"char* ngx_event_connections (ngx_conf_t*,ngx_command_t*,void*)"
79313,METHOD,event\ngx_event.c:<global>,TYPE_DECL,"static char *ngx_event_use(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",13,74,event\ngx_event.c,ngx_event_use,,false,30,30,ngx_event_use,,,11,"char* ngx_event_use (ngx_conf_t*,ngx_command_t*,void*)"
79320,METHOD,event\ngx_event.c:<global>,TYPE_DECL,"static char *ngx_event_debug_connection(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,event\ngx_event.c,ngx_event_debug_connection,,false,31,32,ngx_event_debug_connection,,,12,"char* ngx_event_debug_connection (ngx_conf_t*,ngx_command_t*,void*)"
79327,METHOD,event\ngx_event.c:<global>,TYPE_DECL,static void *ngx_event_core_create_conf(ngx_cycle_t *cycle);,13,59,event\ngx_event.c,ngx_event_core_create_conf,,false,34,34,ngx_event_core_create_conf,,,13,void* ngx_event_core_create_conf (ngx_cycle_t*)
79332,METHOD,event\ngx_event.c:<global>,TYPE_DECL,"static char *ngx_event_core_init_conf(ngx_cycle_t *cycle, void *conf);",13,69,event\ngx_event.c,ngx_event_core_init_conf,,false,35,35,ngx_event_core_init_conf,,,14,"char* ngx_event_core_init_conf (ngx_cycle_t*,void*)"
79513,METHOD,event\ngx_event.c:<global>,TYPE_DECL,"void
ngx_process_events_and_timers(ngx_cycle_t *cycle)
{
    ngx_uint_t  flags;
    ngx_msec_t  timer, delta;

    if (ngx_timer_resolution) {
        timer = NGX_TIMER_INFINITE;
        flags = 0;

    } else {
        timer = ngx_event_find_timer();
        flags = NGX_UPDATE_TIME;

#if (NGX_WIN32)

        /* handle signals from master in case of network inactivity */

        if (timer == NGX_TIMER_INFINITE || timer > 500) {
            timer = 500;
        }

#endif
    }

    if (ngx_use_accept_mutex) {
        if (ngx_accept_disabled > 0) {
            ngx_accept_disabled--;

        } else {
            if (ngx_trylock_accept_mutex(cycle) == NGX_ERROR) {
                return;
            }

            if (ngx_accept_mutex_held) {
                flags |= NGX_POST_EVENTS;

            } else {
                if (timer == NGX_TIMER_INFINITE
                    || timer > ngx_accept_mutex_delay)
                {
                    timer = ngx_accept_mutex_delay;
         ...",1,1,event\ngx_event.c,ngx_process_events_and_timers,,false,193,265,ngx_process_events_and_timers,,,45,void ngx_process_events_and_timers (ngx_cycle_t*)
79628,METHOD,event\ngx_event.c:<global>,TYPE_DECL,"ngx_int_t
ngx_handle_read_event(ngx_event_t *rev, ngx_uint_t flags)
{
    if (ngx_event_flags & NGX_USE_CLEAR_EVENT) {

        /* kqueue, epoll */

        if (!rev->active && !rev->ready) {
            if (ngx_add_event(rev, NGX_READ_EVENT, NGX_CLEAR_EVENT)
                == NGX_ERROR)
            {
                return NGX_ERROR;
            }
        }

        return NGX_OK;

    } else if (ngx_event_flags & NGX_USE_LEVEL_EVENT) {

        /* select, poll, /dev/poll */

        if (!rev->active && !rev->ready) {
            if (ngx_add_event(rev, NGX_READ_EVENT, NGX_LEVEL_EVENT)
                == NGX_ERROR)
            {
                return NGX_ERROR;
            }

            return NGX_OK;
        }

        if (rev->active && (rev->ready || (flags & NGX_CLOSE_EVENT))) {
            if (ngx_del_event(rev, NGX_READ_EVENT, NGX_LEVEL_EVENT | flags)
                == NGX_ERROR)
            {
                return NGX_ERROR;
            }

            return NGX_OK;
    ...",1,1,event\ngx_event.c,ngx_handle_read_event,,false,268,333,ngx_handle_read_event,,,46,"ngx_int_t ngx_handle_read_event (ngx_event_t*,ngx_uint_t)"
79773,METHOD,event\ngx_event.c:<global>,TYPE_DECL,"ngx_int_t
ngx_handle_write_event(ngx_event_t *wev, size_t lowat)
{
    ngx_connection_t  *c;

    if (lowat) {
        c = wev->data;

        if (ngx_send_lowat(c, lowat) == NGX_ERROR) {
            return NGX_ERROR;
        }
    }

    if (ngx_event_flags & NGX_USE_CLEAR_EVENT) {

        /* kqueue, epoll */

        if (!wev->active && !wev->ready) {
            if (ngx_add_event(wev, NGX_WRITE_EVENT,
                              NGX_CLEAR_EVENT | (lowat ? NGX_LOWAT_EVENT : 0))
                == NGX_ERROR)
            {
                return NGX_ERROR;
            }
        }

        return NGX_OK;

    } else if (ngx_event_flags & NGX_USE_LEVEL_EVENT) {

        /* select, poll, /dev/poll */

        if (!wev->active && !wev->ready) {
            if (ngx_add_event(wev, NGX_WRITE_EVENT, NGX_LEVEL_EVENT)
                == NGX_ERROR)
            {
                return NGX_ERROR;
            }

            return NGX_OK;
        }

        if (wev->active && wev->ready) {
  ...",1,1,event\ngx_event.c,ngx_handle_write_event,,false,336,412,ngx_handle_write_event,,,47,"ngx_int_t ngx_handle_write_event (ngx_event_t*,size_t)"
79934,METHOD,event\ngx_event.c:<global>,TYPE_DECL,"static char *
ngx_event_init_conf(ngx_cycle_t *cycle, void *conf)
{
#if (NGX_HAVE_REUSEPORT)
    ngx_uint_t        i;
    ngx_listening_t  *ls;
#endif

    if (ngx_get_conf(cycle->conf_ctx, ngx_events_module) == NULL) {
        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
                      ""no \""events\"" section in configuration"");
        return NGX_CONF_ERROR;
    }

    if (cycle->connection_n < cycle->listening.nelts + 1) {

        /*
         * there should be at least one connection for each listening
         * socket, plus an additional connection for channel
         */

        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
                      ""%ui worker_connections are not enough ""
                      ""for %ui listening sockets"",
                      cycle->connection_n, cycle->listening.nelts);

        return NGX_CONF_ERROR;
    }

#if (NGX_HAVE_REUSEPORT)

    ls = cycle->listening.elts;
    for (i = 0; i < cycle->listening.nelts; i++) {

        if (!ls[i].reus...",1,1,event\ngx_event.c,ngx_event_init_conf,,false,415,465,ngx_event_init_conf,,,48,"char* ngx_event_init_conf (ngx_cycle_t*,void*)"
79990,METHOD,event\ngx_event.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_event_module_init(ngx_cycle_t *cycle)
{
    void              ***cf;
    u_char              *shared;
    size_t               size, cl;
    ngx_shm_t            shm;
    ngx_time_t          *tp;
    ngx_core_conf_t     *ccf;
    ngx_event_conf_t    *ecf;

    cf = ngx_get_conf(cycle->conf_ctx, ngx_events_module);
    ecf = (*cf)[ngx_event_core_module.ctx_index];

    if (!ngx_test_config && ngx_process <= NGX_PROCESS_MASTER) {
        ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0,
                      ""using the \""%s\"" event method"", ecf->name);
    }

    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);

    ngx_timer_resolution = ccf->timer_resolution;

#if !(NGX_WIN32)
    {
    ngx_int_t      limit;
    struct rlimit  rlmt;

    if (getrlimit(RLIMIT_NOFILE, &rlmt) == -1) {
        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                      ""getrlimit(RLIMIT_NOFILE) failed, ignored"");

    } else {
        if (ecf->conne...",1,1,event\ngx_event.c,ngx_event_module_init,,false,468,594,ngx_event_module_init,,,49,ngx_int_t ngx_event_module_init (ngx_cycle_t*)
80258,METHOD,event\ngx_event.c:<global>,TYPE_DECL,"static void
ngx_timer_signal_handler(int signo)
{
    ngx_event_timer_alarm = 1;

#if 1
    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, ngx_cycle->log, 0, ""timer signal"");
#endif
}",1,1,event\ngx_event.c,ngx_timer_signal_handler,,false,599,607,ngx_timer_signal_handler,,,50,void ngx_timer_signal_handler (int)
80273,METHOD,event\ngx_event.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_event_process_init(ngx_cycle_t *cycle)
{
    ngx_uint_t           m, i;
    ngx_event_t         *rev, *wev;
    ngx_listening_t     *ls;
    ngx_connection_t    *c, *next, *old;
    ngx_core_conf_t     *ccf;
    ngx_event_conf_t    *ecf;
    ngx_event_module_t  *module;

    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);
    ecf = ngx_event_get_conf(cycle->conf_ctx, ngx_event_core_module);

    if (ccf->master && ccf->worker_processes > 1 && ecf->accept_mutex) {
        ngx_use_accept_mutex = 1;
        ngx_accept_mutex_held = 0;
        ngx_accept_mutex_delay = ecf->accept_mutex_delay;

    } else {
        ngx_use_accept_mutex = 0;
    }

#if (NGX_WIN32)

    /*
     * disable accept mutex on win32 as it may cause deadlock if
     * grabbed by a process which can't accept connections
     */

    ngx_use_accept_mutex = 0;

#endif

    ngx_queue_init(&ngx_posted_accept_events);
    ngx_queue_init(&ngx_posted_next_events);
    ngx_queu...",1,1,event\ngx_event.c,ngx_event_process_init,,false,612,911,ngx_event_process_init,,,51,ngx_int_t ngx_event_process_init (ngx_cycle_t*)
80937,METHOD,event\ngx_event.c:<global>,TYPE_DECL,"ngx_int_t
ngx_send_lowat(ngx_connection_t *c, size_t lowat)
{
    int  sndlowat;

#if (NGX_HAVE_LOWAT_EVENT)

    if (ngx_event_flags & NGX_USE_KQUEUE_EVENT) {
        c->write->available = lowat;
        return NGX_OK;
    }

#endif

    if (lowat == 0 || c->sndlowat) {
        return NGX_OK;
    }

    sndlowat = (int) lowat;

    if (setsockopt(c->fd, SOL_SOCKET, SO_SNDLOWAT,
                   (const void *) &sndlowat, sizeof(int))
        == -1)
    {
        ngx_connection_error(c, ngx_socket_errno,
                             ""setsockopt(SO_SNDLOWAT) failed"");
        return NGX_ERROR;
    }

    c->sndlowat = 1;

    return NGX_OK;
}",1,1,event\ngx_event.c,ngx_send_lowat,,false,914,946,ngx_send_lowat,,,52,"ngx_int_t ngx_send_lowat (ngx_connection_t*,size_t)"
80990,METHOD,event\ngx_event.c:<global>,TYPE_DECL,"static char *
ngx_events_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char                 *rv;
    void               ***ctx;
    ngx_uint_t            i;
    ngx_conf_t            pcf;
    ngx_event_module_t   *m;

    if (*(void **) conf) {
        return ""is duplicate"";
    }

    /* count the number of the event modules and set up their indices */

    ngx_event_max_module = ngx_count_modules(cf->cycle, NGX_EVENT_MODULE);

    ctx = ngx_pcalloc(cf->pool, sizeof(void *));
    if (ctx == NULL) {
        return NGX_CONF_ERROR;
    }

    *ctx = ngx_pcalloc(cf->pool, ngx_event_max_module * sizeof(void *));
    if (*ctx == NULL) {
        return NGX_CONF_ERROR;
    }

    *(void **) conf = ctx;

    for (i = 0; cf->cycle->modules[i]; i++) {
        if (cf->cycle->modules[i]->type != NGX_EVENT_MODULE) {
            continue;
        }

        m = cf->cycle->modules[i]->ctx;

        if (m->create_conf) {
            (*ctx)[cf->cycle->modules[i]->ctx_index] =
         ...",1,1,event\ngx_event.c,ngx_events_block,,false,949,1024,ngx_events_block,,,53,"char* ngx_events_block (ngx_conf_t*,ngx_command_t*,void*)"
81250,METHOD,event\ngx_event.c:<global>,TYPE_DECL,"static char *
ngx_event_connections(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_event_conf_t  *ecf = conf;

    ngx_str_t  *value;

    if (ecf->connections != NGX_CONF_UNSET_UINT) {
        return ""is duplicate"";
    }

    value = cf->args->elts;
    ecf->connections = ngx_atoi(value[1].data, value[1].len);
    if (ecf->connections == (ngx_uint_t) NGX_ERROR) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""invalid number \""%V\"""", &value[1]);

        return NGX_CONF_ERROR;
    }

    cf->cycle->connection_n = ecf->connections;

    return NGX_CONF_OK;
}",1,1,event\ngx_event.c,ngx_event_connections,,false,1027,1050,ngx_event_connections,,,54,"char* ngx_event_connections (ngx_conf_t*,ngx_command_t*,void*)"
81324,METHOD,event\ngx_event.c:<global>,TYPE_DECL,"static char *
ngx_event_use(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_event_conf_t  *ecf = conf;

    ngx_int_t             m;
    ngx_str_t            *value;
    ngx_event_conf_t     *old_ecf;
    ngx_event_module_t   *module;

    if (ecf->use != NGX_CONF_UNSET_UINT) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    if (cf->cycle->old_cycle->conf_ctx) {
        old_ecf = ngx_event_get_conf(cf->cycle->old_cycle->conf_ctx,
                                     ngx_event_core_module);
    } else {
        old_ecf = NULL;
    }


    for (m = 0; cf->cycle->modules[m]; m++) {
        if (cf->cycle->modules[m]->type != NGX_EVENT_MODULE) {
            continue;
        }

        module = cf->cycle->modules[m]->ctx;
        if (module->name->len == value[1].len) {
            if (ngx_strcmp(module->name->data, value[1].data) == 0) {
                ecf->use = cf->cycle->modules[m]->ctx_index;
                ecf->name = module->name->data;

        ...",1,1,event\ngx_event.c,ngx_event_use,,false,1053,1113,ngx_event_use,,,55,"char* ngx_event_use (ngx_conf_t*,ngx_command_t*,void*)"
81512,METHOD,event\ngx_event.c:<global>,TYPE_DECL,"static char *
ngx_event_debug_connection(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
#if (NGX_DEBUG)
    ngx_event_conf_t  *ecf = conf;

    ngx_int_t             rc;
    ngx_str_t            *value;
    ngx_url_t             u;
    ngx_cidr_t            c, *cidr;
    ngx_uint_t            i;
    struct sockaddr_in   *sin;
#if (NGX_HAVE_INET6)
    struct sockaddr_in6  *sin6;
#endif

    value = cf->args->elts;

#if (NGX_HAVE_UNIX_DOMAIN)

    if (ngx_strcmp(value[1].data, ""unix:"") == 0) {
        cidr = ngx_array_push(&ecf->debug_connection);
        if (cidr == NULL) {
            return NGX_CONF_ERROR;
        }

        cidr->family = AF_UNIX;
        return NGX_CONF_OK;
    }

#endif

    rc = ngx_ptocidr(&value[1], &c);

    if (rc != NGX_ERROR) {
        if (rc == NGX_DONE) {
            ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
                               ""low address bits of %V are meaningless"",
                               &value[1]);
        }

        cidr = ngx_...",1,1,event\ngx_event.c,ngx_event_debug_connection,,false,1116,1217,ngx_event_debug_connection,,,56,"char* ngx_event_debug_connection (ngx_conf_t*,ngx_command_t*,void*)"
81526,METHOD,event\ngx_event.c:<global>,TYPE_DECL,"static void *
ngx_event_core_create_conf(ngx_cycle_t *cycle)
{
    ngx_event_conf_t  *ecf;

    ecf = ngx_palloc(cycle->pool, sizeof(ngx_event_conf_t));
    if (ecf == NULL) {
        return NULL;
    }

    ecf->connections = NGX_CONF_UNSET_UINT;
    ecf->use = NGX_CONF_UNSET_UINT;
    ecf->multi_accept = NGX_CONF_UNSET;
    ecf->accept_mutex = NGX_CONF_UNSET;
    ecf->accept_mutex_delay = NGX_CONF_UNSET_MSEC;
    ecf->name = (void *) NGX_CONF_UNSET;

#if (NGX_DEBUG)

    if (ngx_array_init(&ecf->debug_connection, cycle->pool, 4,
                       sizeof(ngx_cidr_t)) == NGX_ERROR)
    {
        return NULL;
    }

#endif

    return ecf;
}",1,1,event\ngx_event.c,ngx_event_core_create_conf,,false,1220,1248,ngx_event_core_create_conf,,,57,void* ngx_event_core_create_conf (ngx_cycle_t*)
81581,METHOD,event\ngx_event.c:<global>,TYPE_DECL,"static char *
ngx_event_core_init_conf(ngx_cycle_t *cycle, void *conf)
{
    ngx_event_conf_t  *ecf = conf;

#if (NGX_HAVE_EPOLL) && !(NGX_TEST_BUILD_EPOLL)
    int                  fd;
#endif
    ngx_int_t            i;
    ngx_module_t        *module;
    ngx_event_module_t  *event_module;

    module = NULL;

#if (NGX_HAVE_EPOLL) && !(NGX_TEST_BUILD_EPOLL)

    fd = epoll_create(100);

    if (fd != -1) {
        (void) close(fd);
        module = &ngx_epoll_module;

    } else if (ngx_errno != NGX_ENOSYS) {
        module = &ngx_epoll_module;
    }

#endif

#if (NGX_HAVE_DEVPOLL) && !(NGX_TEST_BUILD_DEVPOLL)

    module = &ngx_devpoll_module;

#endif

#if (NGX_HAVE_KQUEUE)

    module = &ngx_kqueue_module;

#endif

#if (NGX_HAVE_SELECT)

    if (module == NULL) {
        module = &ngx_select_module;
    }

#endif

    if (module == NULL) {
        for (i = 0; cycle->modules[i]; i++) {

            if (cycle->modules[i]->type != NGX_EVENT_MODULE) {
                continue;
     ...",1,47,event\ngx_event.c,ngx_event_core_init_conf,,false,1251,1336,ngx_event_core_init_conf,,,58,"char* ngx_event_core_init_conf (ngx_cycle_t*,void*)"
81737,METHOD,event\ngx_event.h:<global>,TYPE_DECL,<global>,1,35,event\ngx_event.h,event\ngx_event.h:<global>,,false,1,541,<global>,,,1,
81772,METHOD,<empty>,<empty>,<empty>,1,,event\ngx_event.h,ngx_event_s:<clinit>,,false,30,,<clinit>,,,33,
81779,METHOD,ngx_event_actions_t,TYPE_DECL,"ngx_int_t  (*add)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);",16,73,event\ngx_event.h,ngx_event_actions_t.add,,false,171,171,add,,,1,"ngx_int_t ngx_event_actions_t.add (ngx_event_t*,ngx_int_t,ngx_uint_t)"
81786,METHOD,ngx_event_actions_t,TYPE_DECL,"ngx_int_t  (*del)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);",16,73,event\ngx_event.h,ngx_event_actions_t.del,,false,172,172,del,,,2,"ngx_int_t ngx_event_actions_t.del (ngx_event_t*,ngx_int_t,ngx_uint_t)"
81793,METHOD,ngx_event_actions_t,TYPE_DECL,"ngx_int_t  (*enable)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);",16,76,event\ngx_event.h,ngx_event_actions_t.enable,,false,174,174,enable,,,3,"ngx_int_t ngx_event_actions_t.enable (ngx_event_t*,ngx_int_t,ngx_uint_t)"
81800,METHOD,ngx_event_actions_t,TYPE_DECL,"ngx_int_t  (*disable)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);",16,77,event\ngx_event.h,ngx_event_actions_t.disable,,false,175,175,disable,,,4,"ngx_int_t ngx_event_actions_t.disable (ngx_event_t*,ngx_int_t,ngx_uint_t)"
81807,METHOD,ngx_event_actions_t,TYPE_DECL,ngx_int_t  (*add_conn)(ngx_connection_t *c);,16,47,event\ngx_event.h,ngx_event_actions_t.add_conn,,false,177,177,add_conn,,,5,ngx_int_t ngx_event_actions_t.add_conn (ngx_connection_t*)
81812,METHOD,ngx_event_actions_t,TYPE_DECL,"ngx_int_t  (*del_conn)(ngx_connection_t *c, ngx_uint_t flags);",16,65,event\ngx_event.h,ngx_event_actions_t.del_conn,,false,178,178,del_conn,,,6,"ngx_int_t ngx_event_actions_t.del_conn (ngx_connection_t*,ngx_uint_t)"
81818,METHOD,ngx_event_actions_t,TYPE_DECL,ngx_int_t  (*notify)(ngx_event_handler_pt handler);,16,54,event\ngx_event.h,ngx_event_actions_t.notify,,false,180,180,notify,,,7,ngx_int_t ngx_event_actions_t.notify (ngx_event_handler_pt)
81823,METHOD,ngx_event_actions_t,TYPE_DECL,"ngx_int_t  (*process_events)(ngx_cycle_t *cycle, ngx_msec_t timer,
                                 ngx_uint_t flags);",16,50,event\ngx_event.h,ngx_event_actions_t.process_events,,false,182,183,process_events,,,8,"ngx_int_t ngx_event_actions_t.process_events (ngx_cycle_t*,ngx_msec_t,ngx_uint_t)"
81830,METHOD,ngx_event_actions_t,TYPE_DECL,"ngx_int_t  (*init)(ngx_cycle_t *cycle, ngx_msec_t timer);",16,60,event\ngx_event.h,ngx_event_actions_t.init,,false,185,185,init,,,9,"ngx_int_t ngx_event_actions_t.init (ngx_cycle_t*,ngx_msec_t)"
81836,METHOD,ngx_event_actions_t,TYPE_DECL,void       (*done)(ngx_cycle_t *cycle);,16,42,event\ngx_event.h,ngx_event_actions_t.done,,false,186,186,done,,,10,void ngx_event_actions_t.done (ngx_cycle_t*)
81855,METHOD,ngx_event_module_t,TYPE_DECL,void                 *(*create_conf)(ngx_cycle_t *cycle);,26,60,event\ngx_event.h,ngx_event_module_t.create_conf,,false,453,453,create_conf,,,2,void* ngx_event_module_t.create_conf (ngx_cycle_t*)
81860,METHOD,ngx_event_module_t,TYPE_DECL,"char                 *(*init_conf)(ngx_cycle_t *cycle, void *conf);",26,70,event\ngx_event.h,ngx_event_module_t.init_conf,,false,454,454,init_conf,,,3,"char* ngx_event_module_t.init_conf (ngx_cycle_t*,void*)"
81880,METHOD,event\ngx_event.h:<global>,TYPE_DECL,void ngx_event_accept(ngx_event_t *ev);,6,38,event\ngx_event.h,ngx_event_accept,,false,499,499,ngx_event_accept,,,22,void ngx_event_accept (ngx_event_t*)
81885,METHOD,event\ngx_event.h:<global>,TYPE_DECL,void ngx_event_recvmsg(ngx_event_t *ev);,6,39,event\ngx_event.h,ngx_event_recvmsg,,false,501,501,ngx_event_recvmsg,,,23,void ngx_event_recvmsg (ngx_event_t*)
81890,METHOD,event\ngx_event.h:<global>,TYPE_DECL,"void ngx_udp_rbtree_insert_value(ngx_rbtree_node_t *temp,
    ngx_rbtree_node_t *node, ngx_rbtree_node_t *sentinel);",6,57,event\ngx_event.h,ngx_udp_rbtree_insert_value,,false,502,503,ngx_udp_rbtree_insert_value,,,24,"void ngx_udp_rbtree_insert_value (ngx_rbtree_node_t*,ngx_rbtree_node_t*,ngx_rbtree_node_t*)"
81897,METHOD,event\ngx_event.h:<global>,TYPE_DECL,void ngx_delete_udp_connection(void *data);,6,42,event\ngx_event.h,ngx_delete_udp_connection,,false,505,505,ngx_delete_udp_connection,,,25,void ngx_delete_udp_connection (void*)
81902,METHOD,event\ngx_event.h:<global>,TYPE_DECL,ngx_int_t ngx_trylock_accept_mutex(ngx_cycle_t *cycle);,11,54,event\ngx_event.h,ngx_trylock_accept_mutex,,false,506,506,ngx_trylock_accept_mutex,,,26,ngx_int_t ngx_trylock_accept_mutex (ngx_cycle_t*)
81907,METHOD,event\ngx_event.h:<global>,TYPE_DECL,ngx_int_t ngx_enable_accept_events(ngx_cycle_t *cycle);,11,54,event\ngx_event.h,ngx_enable_accept_events,,false,507,507,ngx_enable_accept_events,,,27,ngx_int_t ngx_enable_accept_events (ngx_cycle_t*)
81912,METHOD,event\ngx_event.h:<global>,TYPE_DECL,"u_char *ngx_accept_log_error(ngx_log_t *log, u_char *buf, size_t len);",8,69,event\ngx_event.h,ngx_accept_log_error,,false,508,508,ngx_accept_log_error,,,28,"u_char* ngx_accept_log_error (ngx_log_t*,u_char*,size_t)"
81919,METHOD,event\ngx_event.h:<global>,TYPE_DECL,void ngx_process_events_and_timers(ngx_cycle_t *cycle);,6,54,event\ngx_event.h,ngx_process_events_and_timers,,false,514,514,ngx_process_events_and_timers,,,29,void ngx_process_events_and_timers (ngx_cycle_t*)
81924,METHOD,event\ngx_event.h:<global>,TYPE_DECL,"ngx_int_t ngx_handle_read_event(ngx_event_t *rev, ngx_uint_t flags);",11,67,event\ngx_event.h,ngx_handle_read_event,,false,515,515,ngx_handle_read_event,,,30,"ngx_int_t ngx_handle_read_event (ngx_event_t*,ngx_uint_t)"
81930,METHOD,event\ngx_event.h:<global>,TYPE_DECL,"ngx_int_t ngx_handle_write_event(ngx_event_t *wev, size_t lowat);",11,64,event\ngx_event.h,ngx_handle_write_event,,false,516,516,ngx_handle_write_event,,,31,"ngx_int_t ngx_handle_write_event (ngx_event_t*,size_t)"
81936,METHOD,event\ngx_event.h:<global>,TYPE_DECL,"ngx_int_t ngx_send_lowat(ngx_connection_t *c, size_t lowat);",11,59,event\ngx_event.h,ngx_send_lowat,,false,526,526,ngx_send_lowat,,,32,"ngx_int_t ngx_send_lowat (ngx_connection_t*,size_t)"
81951,METHOD,event\ngx_event_accept.c:<global>,TYPE_DECL,<global>,1,6,event\ngx_event_accept.c,event\ngx_event_accept.c:<global>,,false,1,512,<global>,,,1,
81953,METHOD,event\ngx_event_accept.c:<global>,TYPE_DECL,"static ngx_int_t ngx_disable_accept_events(ngx_cycle_t *cycle, ngx_uint_t all);",18,78,event\ngx_event_accept.c,ngx_disable_accept_events,,false,13,13,ngx_disable_accept_events,,,1,"ngx_int_t ngx_disable_accept_events (ngx_cycle_t*,ngx_uint_t)"
81959,METHOD,event\ngx_event_accept.c:<global>,TYPE_DECL,static void ngx_close_accepted_connection(ngx_connection_t *c);,13,62,event\ngx_event_accept.c,ngx_close_accepted_connection,,false,14,14,ngx_close_accepted_connection,,,2,void ngx_close_accepted_connection (ngx_connection_t*)
81964,METHOD,event\ngx_event_accept.c:<global>,TYPE_DECL,"void
ngx_event_accept(ngx_event_t *ev)
{
    socklen_t          socklen;
    ngx_err_t          err;
    ngx_log_t         *log;
    ngx_uint_t         level;
    ngx_socket_t       s;
    ngx_event_t       *rev, *wev;
    ngx_sockaddr_t     sa;
    ngx_listening_t   *ls;
    ngx_connection_t  *c, *lc;
    ngx_event_conf_t  *ecf;
#if (NGX_HAVE_ACCEPT4)
    static ngx_uint_t  use_accept4 = 1;
#endif

    if (ev->timedout) {
        if (ngx_enable_accept_events((ngx_cycle_t *) ngx_cycle) != NGX_OK) {
            return;
        }

        ev->timedout = 0;
    }

    ecf = ngx_event_get_conf(ngx_cycle->conf_ctx, ngx_event_core_module);

    if (!(ngx_event_flags & NGX_USE_KQUEUE_EVENT)) {
        ev->available = ecf->multi_accept;
    }

    lc = ev->data;
    ls = lc->listening;
    ev->ready = 0;

    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ev->log, 0,
                   ""accept on %V, ready: %d"", &ls->addr_text, ev->available);

    do {
        socklen = sizeof(ngx_sockaddr_t);

#if (...",1,1,event\ngx_event_accept.c,ngx_event_accept,,false,17,315,ngx_event_accept,,,3,void ngx_event_accept (ngx_event_t*)
82557,METHOD,event\ngx_event_accept.c:<global>,TYPE_DECL,"ngx_int_t
ngx_trylock_accept_mutex(ngx_cycle_t *cycle)
{
    if (ngx_shmtx_trylock(&ngx_accept_mutex)) {

        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
                       ""accept mutex locked"");

        if (ngx_accept_mutex_held && ngx_accept_events == 0) {
            return NGX_OK;
        }

        if (ngx_enable_accept_events(cycle) == NGX_ERROR) {
            ngx_shmtx_unlock(&ngx_accept_mutex);
            return NGX_ERROR;
        }

        ngx_accept_events = 0;
        ngx_accept_mutex_held = 1;

        return NGX_OK;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
                   ""accept mutex lock failed: %ui"", ngx_accept_mutex_held);

    if (ngx_accept_mutex_held) {
        if (ngx_disable_accept_events(cycle, 0) == NGX_ERROR) {
            return NGX_ERROR;
        }

        ngx_accept_mutex_held = 0;
    }

    return NGX_OK;
}",1,1,event\ngx_event_accept.c,ngx_trylock_accept_mutex,,false,318,353,ngx_trylock_accept_mutex,,,4,ngx_int_t ngx_trylock_accept_mutex (ngx_cycle_t*)
82627,METHOD,event\ngx_event_accept.c:<global>,TYPE_DECL,"ngx_int_t
ngx_enable_accept_events(ngx_cycle_t *cycle)
{
    ngx_uint_t         i;
    ngx_listening_t   *ls;
    ngx_connection_t  *c;

    ls = cycle->listening.elts;
    for (i = 0; i < cycle->listening.nelts; i++) {

        c = ls[i].connection;

        if (c == NULL || c->read->active) {
            continue;
        }

        if (ngx_add_event(c->read, NGX_READ_EVENT, 0) == NGX_ERROR) {
            return NGX_ERROR;
        }
    }

    return NGX_OK;
}",1,1,event\ngx_event_accept.c,ngx_enable_accept_events,,false,356,378,ngx_enable_accept_events,,,5,ngx_int_t ngx_enable_accept_events (ngx_cycle_t*)
82690,METHOD,event\ngx_event_accept.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_disable_accept_events(ngx_cycle_t *cycle, ngx_uint_t all)
{
    ngx_uint_t         i;
    ngx_listening_t   *ls;
    ngx_connection_t  *c;

    ls = cycle->listening.elts;
    for (i = 0; i < cycle->listening.nelts; i++) {

        c = ls[i].connection;

        if (c == NULL || !c->read->active) {
            continue;
        }

#if (NGX_HAVE_REUSEPORT)

        /*
         * do not disable accept on worker's own sockets
         * when disabling accept events due to accept mutex
         */

        if (ls[i].reuseport && !all) {
            continue;
        }

#endif

        if (ngx_del_event(c->read, NGX_READ_EVENT, NGX_DISABLE_EVENT)
            == NGX_ERROR)
        {
            return NGX_ERROR;
        }
    }

    return NGX_OK;
}",1,1,event\ngx_event_accept.c,ngx_disable_accept_events,,false,381,418,ngx_disable_accept_events,,,6,"ngx_int_t ngx_disable_accept_events (ngx_cycle_t*,ngx_uint_t)"
82755,METHOD,event\ngx_event_accept.c:<global>,TYPE_DECL,"static void
ngx_close_accepted_connection(ngx_connection_t *c)
{
    ngx_socket_t  fd;

    ngx_free_connection(c);

    fd = c->fd;
    c->fd = (ngx_socket_t) -1;

    if (ngx_close_socket(fd) == -1) {
        ngx_log_error(NGX_LOG_ALERT, c->log, ngx_socket_errno,
                      ngx_close_socket_n "" failed"");
    }

    if (c->pool) {
        ngx_destroy_pool(c->pool);
    }

#if (NGX_STAT_STUB)
    (void) ngx_atomic_fetch_add(ngx_stat_active, -1);
#endif
}",1,1,event\ngx_event_accept.c,ngx_close_accepted_connection,,false,421,443,ngx_close_accepted_connection,,,7,void ngx_close_accepted_connection (ngx_connection_t*)
82792,METHOD,event\ngx_event_accept.c:<global>,TYPE_DECL,"u_char *
ngx_accept_log_error(ngx_log_t *log, u_char *buf, size_t len)
{
    return ngx_snprintf(buf, len, "" while accepting new connection on %V"",
                        log->data);
}",1,1,event\ngx_event_accept.c,ngx_accept_log_error,,false,446,451,ngx_accept_log_error,,,8,"u_char ngx_accept_log_error (ngx_log_t*,u_char*,size_t)"
82816,METHOD,event\ngx_event_acceptex.c:<global>,TYPE_DECL,<global>,1,1,event\ngx_event_acceptex.c,event\ngx_event_acceptex.c:<global>,,false,1,227,<global>,,,1,
82818,METHOD,event\ngx_event_acceptex.c:<global>,TYPE_DECL,static void ngx_close_posted_connection(ngx_connection_t *c);,13,60,event\ngx_event_acceptex.c,ngx_close_posted_connection,,false,13,13,ngx_close_posted_connection,,,1,void ngx_close_posted_connection (ngx_connection_t*)
82823,METHOD,event\ngx_event_acceptex.c:<global>,TYPE_DECL,"void
ngx_event_acceptex(ngx_event_t *rev)
{
    ngx_listening_t   *ls;
    ngx_connection_t  *c;

    c = rev->data;
    ls = c->listening;

    c->log->handler = ngx_accept_log_error;

    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, ""AcceptEx: %d"", c->fd);

    if (rev->ovlp.error) {
        ngx_log_error(NGX_LOG_CRIT, c->log, rev->ovlp.error,
                      ""AcceptEx() %V failed"", &ls->addr_text);
        return;
    }

    /* SO_UPDATE_ACCEPT_CONTEXT is required for shutdown() to work */

    if (setsockopt(c->fd, SOL_SOCKET, SO_UPDATE_ACCEPT_CONTEXT,
                   (char *) &ls->fd, sizeof(ngx_socket_t))
        == -1)
    {
        ngx_log_error(NGX_LOG_CRIT, c->log, ngx_socket_errno,
                      ""setsockopt(SO_UPDATE_ACCEPT_CONTEXT) failed for %V"",
                      &c->addr_text);
        /* TODO: close socket */
        return;
    }

    ngx_getacceptexsockaddrs(c->buffer->pos,
                             ls->post_accept_buffer_size,
           ...",1,1,event\ngx_event_acceptex.c,ngx_event_acceptex,,false,16,87,ngx_event_acceptex,,,2,void ngx_event_acceptex (ngx_event_t*)
83058,METHOD,event\ngx_event_acceptex.c:<global>,TYPE_DECL,"ngx_int_t
ngx_event_post_acceptex(ngx_listening_t *ls, ngx_uint_t n)
{
    u_long             rcvd;
    ngx_err_t          err;
    ngx_log_t         *log;
    ngx_uint_t         i;
    ngx_event_t       *rev, *wev;
    ngx_socket_t       s;
    ngx_connection_t  *c;

    for (i = 0; i < n; i++) {

        /* TODO: look up reused sockets */

        s = ngx_socket(ls->sockaddr->sa_family, ls->type, 0);

        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, &ls->log, 0,
                       ngx_socket_n "" s:%d"", s);

        if (s == (ngx_socket_t) -1) {
            ngx_log_error(NGX_LOG_ALERT, &ls->log, ngx_socket_errno,
                          ngx_socket_n "" failed"");

            return NGX_ERROR;
        }

        c = ngx_get_connection(s, &ls->log);

        if (c == NULL) {
            return NGX_ERROR;
        }

        c->pool = ngx_create_pool(ls->pool_size, &ls->log);
        if (c->pool == NULL) {
            ngx_close_posted_connection(c);
            return NGX_ERROR;
      ...",1,1,event\ngx_event_acceptex.c,ngx_event_post_acceptex,,false,90,199,ngx_event_post_acceptex,,,3,"ngx_int_t ngx_event_post_acceptex (ngx_listening_t*,ngx_uint_t)"
83396,METHOD,event\ngx_event_acceptex.c:<global>,TYPE_DECL,"static void
ngx_close_posted_connection(ngx_connection_t *c)
{
    ngx_socket_t  fd;

    ngx_free_connection(c);

    fd = c->fd;
    c->fd = (ngx_socket_t) -1;

    if (ngx_close_socket(fd) == -1) {
        ngx_log_error(NGX_LOG_ALERT, c->log, ngx_socket_errno,
                      ngx_close_socket_n "" failed"");
    }

    if (c->pool) {
        ngx_destroy_pool(c->pool);
    }
}",1,1,event\ngx_event_acceptex.c,ngx_close_posted_connection,,false,202,220,ngx_close_posted_connection,,,4,void ngx_close_posted_connection (ngx_connection_t*)
83433,METHOD,event\ngx_event_acceptex.c:<global>,TYPE_DECL,"u_char *
ngx_acceptex_log_error(ngx_log_t *log, u_char *buf, size_t len)
{
    return ngx_snprintf(buf, len, "" while posting AcceptEx() on %V"", log->data);
}",1,1,event\ngx_event_acceptex.c,ngx_acceptex_log_error,,false,223,227,ngx_acceptex_log_error,,,5,"u_char ngx_acceptex_log_error (ngx_log_t*,u_char*,size_t)"
83459,METHOD,event\ngx_event_connect.c:<global>,TYPE_DECL,<global>,1,1,event\ngx_event_connect.c,event\ngx_event_connect.c:<global>,,false,1,431,<global>,,,1,
83461,METHOD,event\ngx_event_connect.c:<global>,TYPE_DECL,"ngx_int_t
ngx_event_connect_peer(ngx_peer_connection_t *pc)
{
    int                rc, type, value;
#if (NGX_HAVE_IP_BIND_ADDRESS_NO_PORT || NGX_LINUX)
    in_port_t          port;
#endif
    ngx_int_t          event;
    ngx_err_t          err;
    ngx_uint_t         level;
    ngx_socket_t       s;
    ngx_event_t       *rev, *wev;
    ngx_connection_t  *c;

    rc = pc->get(pc, pc->data);
    if (rc != NGX_OK) {
        return rc;
    }

    type = (pc->type ? pc->type : SOCK_STREAM);

    s = ngx_socket(pc->sockaddr->sa_family, type, 0);

    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, pc->log, 0, ""%s socket %d"",
                   (type == SOCK_STREAM) ? ""stream"" : ""dgram"", s);

    if (s == (ngx_socket_t) -1) {
        ngx_log_error(NGX_LOG_ALERT, pc->log, ngx_socket_errno,
                      ngx_socket_n "" failed"");
        return NGX_ERROR;
    }


    c = ngx_get_connection(s, pc->log);

    if (c == NULL) {
        if (ngx_close_socket(s) == -1) {
            ngx_log_error(NG...",1,1,event\ngx_event_connect.c,ngx_event_connect_peer,,false,20,327,ngx_event_connect_peer,,,1,ngx_int_t ngx_event_connect_peer (ngx_peer_connection_t*)
84000,METHOD,event\ngx_event_connect.c:<global>,TYPE_DECL,"ngx_int_t
ngx_event_get_peer(ngx_peer_connection_t *pc, void *data)
{
    return NGX_OK;
}",1,1,event\ngx_event_connect.c,ngx_event_get_peer,,false,427,431,ngx_event_get_peer,,,2,"ngx_int_t ngx_event_get_peer (ngx_peer_connection_t*,void*)"
84017,METHOD,event\ngx_event_connect.h:<global>,TYPE_DECL,<global>,1,43,event\ngx_event_connect.h,event\ngx_event_connect.h:<global>,,false,1,80,<global>,,,1,
84021,METHOD,event\ngx_event_connect.h:<global>,TYPE_DECL,"typedef ngx_int_t (*ngx_event_get_peer_pt)(ngx_peer_connection_t *pc,
    void *data);",19,15,event\ngx_event_connect.h,ngx_event_get_peer_pt,,false,24,25,ngx_event_get_peer_pt,,,3,"ngx_int_t ngx_event_get_peer_pt (ngx_peer_connection_t*,void*)"
84027,METHOD,event\ngx_event_connect.h:<global>,TYPE_DECL,"typedef void (*ngx_event_free_peer_pt)(ngx_peer_connection_t *pc, void *data,
    ngx_uint_t state);",14,21,event\ngx_event_connect.h,ngx_event_free_peer_pt,,false,26,27,ngx_event_free_peer_pt,,,4,"void ngx_event_free_peer_pt (ngx_peer_connection_t*,void*,ngx_uint_t)"
84034,METHOD,event\ngx_event_connect.h:<global>,TYPE_DECL,"typedef void (*ngx_event_notify_peer_pt)(ngx_peer_connection_t *pc,
    void *data, ngx_uint_t type);",14,32,event\ngx_event_connect.h,ngx_event_notify_peer_pt,,false,28,29,ngx_event_notify_peer_pt,,,5,"void ngx_event_notify_peer_pt (ngx_peer_connection_t*,void*,ngx_uint_t)"
84041,METHOD,event\ngx_event_connect.h:<global>,TYPE_DECL,"typedef ngx_int_t (*ngx_event_set_peer_session_pt)(ngx_peer_connection_t *pc,
    void *data);",19,15,event\ngx_event_connect.h,ngx_event_set_peer_session_pt,,false,30,31,ngx_event_set_peer_session_pt,,,6,"ngx_int_t ngx_event_set_peer_session_pt (ngx_peer_connection_t*,void*)"
84047,METHOD,event\ngx_event_connect.h:<global>,TYPE_DECL,"typedef void (*ngx_event_save_peer_session_pt)(ngx_peer_connection_t *pc,
    void *data);",14,15,event\ngx_event_connect.h,ngx_event_save_peer_session_pt,,false,32,33,ngx_event_save_peer_session_pt,,,7,"void ngx_event_save_peer_session_pt (ngx_peer_connection_t*,void*)"
84077,METHOD,event\ngx_event_connect.h:<global>,TYPE_DECL,ngx_int_t ngx_event_connect_peer(ngx_peer_connection_t *pc);,11,59,event\ngx_event_connect.h,ngx_event_connect_peer,,false,76,76,ngx_event_connect_peer,,,9,ngx_int_t ngx_event_connect_peer (ngx_peer_connection_t*)
84082,METHOD,event\ngx_event_connect.h:<global>,TYPE_DECL,"ngx_int_t ngx_event_get_peer(ngx_peer_connection_t *pc, void *data);",11,67,event\ngx_event_connect.h,ngx_event_get_peer,,false,77,77,ngx_event_get_peer,,,10,"ngx_int_t ngx_event_get_peer (ngx_peer_connection_t*,void*)"
84097,METHOD,event\ngx_event_connectex.c:<global>,TYPE_DECL,<global>,1,42,event\ngx_event_connectex.c,event\ngx_event_connectex.c:<global>,,false,1,206,<global>,,,1,
84121,METHOD,event\ngx_event_connectex.c:<global>,TYPE_DECL,"int ngx_iocp_wait_connect(ngx_connection_t *c)
{
    for ( ;; ) {
        EnterCriticalSection(&connect_lock);

        if (nconnects < NGX_MAX_PENDING_CONN) {
            pending_connects[--nconnects] = c;
            LeaveCriticalSection(&connect_lock);

            if (SetEvent(pending_connect_event) == 0) {
                ngx_log_error(NGX_LOG_ALERT, c->log, ngx_errno,
                              ""SetEvent() failed"");
                return NGX_ERROR;

            break;
        }

        LeaveCriticalSection(&connect_lock);
        ngx_log_error(NGX_LOG_NOTICE, c->log, 0,
                      ""max number of pending connect()s is %d"",
                      NGX_MAX_PENDING_CONN);
        msleep(100);
    }

    if (!started) {
        if (ngx_iocp_new_thread(1) == NGX_ERROR) {
            return NGX_ERROR;
        }
        started = 1;
    }

    return NGX_OK;
}


int ngx_iocp_new_thread(int main)
{
    u_int  id;

    if (main) {
        pending_connect_event = CreateEven...",1,24,event\ngx_event_connectex.c,ngx_iocp_wait_connect,,false,28,118,ngx_iocp_wait_connect,,,12,int ngx_iocp_wait_connect (ngx_connection_t*)
84194,METHOD,event\ngx_event_connectex.c:<global>,TYPE_DECL,"int ngx_iocp_new_thread(int main)
{
    u_int  id;

    if (main) {
        pending_connect_event = CreateEvent(NULL, 0, 1, NULL);
        if (pending_connect_event == INVALID_HANDLE_VALUE) {
            ngx_log_error(NGX_LOG_ALERT, c->log, ngx_errno,
                          ""CreateThread() failed"");
            return NGX_ERROR;
        }
    }

    if (CreateThread(NULL, 0, ngx_iocp_wait_events, main, 0, &id)
                                                       == INVALID_HANDLE_VALUE)
    {
        ngx_log_error(NGX_LOG_ALERT, c->log, ngx_errno,
                      ""CreateThread() failed"");
        return NGX_ERROR;
    }

    SetEvent(event) {
        ngx_log_error(NGX_LOG_ALERT, c->log, ngx_errno,
                      ""SetEvent() failed"");
        return NGX_ERROR;
    }

    return NGX_OK;
}",1,1,event\ngx_event_connectex.c,ngx_iocp_wait_connect.ngx_iocp_new_thread,,false,63,91,ngx_iocp_new_thread,,,2,int ngx_iocp_wait_connect.ngx_iocp_new_thread (int)
84260,METHOD,event\ngx_event_connectex.c:<global>,TYPE_DECL,"int ngx_iocp_new_connect()
{
    EnterCriticalSection(&connect_lock);
    c = pending_connects[--nconnects];
    LeaveCriticalSection(&connect_lock);

    conn[nevents] = c;

    events[nevents] = WSACreateEvent();
    if (events[nevents] == INVALID_HANDLE_VALUE) {
        ngx_log_error(NGX_LOG_ALERT, c->log, ngx_socket_errno,
                      ""WSACreateEvent() failed"");
        return NGX_ERROR;
    }

    if (WSAEventSelect(c->fd, events[nevents], FD_CONNECT) == -1)
        ngx_log_error(NGX_LOG_ALERT, c->log, ngx_socket_errno,
                      ""WSAEventSelect() failed"");
        return NGX_ERROR;
    }",1,5,event\ngx_event_connectex.c,ngx_iocp_wait_connect.ngx_iocp_new_connect,,false,94,113,ngx_iocp_new_connect,,,3,int ngx_iocp_wait_connect.ngx_iocp_new_connect ()
84330,METHOD,event\ngx_event_connectex.c:<global>,TYPE_DECL,"void ngx_iocp_wait_events(int main)
{
    WSANETWORKEVENTS  ne;

    nevents = 1;
    events[0] = pending_connect_event;
    conn[0] = NULL;

    for ( ;; ) {
        offset = (nevents == WSA_MAXIMUM_WAIT_EVENTS + 1) ? 1: 0;
        timeout = (nevents == 1 && !first) ? 60000: INFINITE;

        n = WSAWaitForMultipleEvents(nevents - offset, events[offset],
                                     0, timeout, 0);
        if (n == WAIT_FAILED) {
            ngx_log_error(NGX_LOG_ALERT, log, ngx_socket_errno,
                          ""WSAWaitForMultipleEvents() failed"");
            continue;
        }

        if (n == WAIT_TIMEOUT) {
            if (nevents == 2 && !main) {
                ExitThread(0);
            }

            ngx_log_error(NGX_LOG_ALERT, log, 0,
                          ""WSAWaitForMultipleEvents() ""
                          ""returned unexpected WAIT_TIMEOUT"");
            continue;
        }

        n -= WSA_WAIT_EVENT_0;

        if (events[n] == NULL) {

     ...",1,1,event\ngx_event_connectex.c,ngx_iocp_wait_events,,false,121,206,ngx_iocp_wait_events,,,13,void ngx_iocp_wait_events (int)
84562,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,<global>,1,29,event\ngx_event_openssl.c,event\ngx_event_openssl.c:<global>,,false,1,5209,<global>,,,1,
84568,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static EVP_PKEY *ngx_ssl_load_certificate_key(ngx_pool_t *pool, char **err,
    ngx_str_t *key, ngx_array_t *passwords);",17,43,event\ngx_event_openssl.c,ngx_ssl_load_certificate_key,,false,23,24,ngx_ssl_load_certificate_key,,,4,"EVP_PKEY* ngx_ssl_load_certificate_key (ngx_pool_t*,char**,ngx_str_t*,ngx_array_t*)"
84576,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static int ngx_ssl_password_callback(char *buf, int size, int rwflag,
    void *userdata);",12,19,event\ngx_event_openssl.c,ngx_ssl_password_callback,,false,25,26,ngx_ssl_password_callback,,,5,"int ngx_ssl_password_callback (char*,int,int,void*)"
84584,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static int ngx_ssl_verify_callback(int ok, X509_STORE_CTX *x509_store);",12,70,event\ngx_event_openssl.c,ngx_ssl_verify_callback,,false,27,27,ngx_ssl_verify_callback,,,6,"int ngx_ssl_verify_callback (int,X509_STORE_CTX*)"
84590,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static void ngx_ssl_info_callback(const ngx_ssl_conn_t *ssl_conn, int where,
    int ret);",13,12,event\ngx_event_openssl.c,ngx_ssl_info_callback,,false,28,29,ngx_ssl_info_callback,,,7,"void ngx_ssl_info_callback (ngx_ssl_conn_t*,int,int)"
84597,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,static void ngx_ssl_passwords_cleanup(void *data);,13,49,event\ngx_event_openssl.c,ngx_ssl_passwords_cleanup,,false,30,30,ngx_ssl_passwords_cleanup,,,8,void ngx_ssl_passwords_cleanup (void*)
84602,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static int ngx_ssl_new_client_session(ngx_ssl_conn_t *ssl_conn,
    ngx_ssl_session_t *sess);",12,28,event\ngx_event_openssl.c,ngx_ssl_new_client_session,,false,31,32,ngx_ssl_new_client_session,,,9,"int ngx_ssl_new_client_session (ngx_ssl_conn_t*,ngx_ssl_session_t*)"
84608,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,static void ngx_ssl_handshake_handler(ngx_event_t *ev);,13,54,event\ngx_event_openssl.c,ngx_ssl_handshake_handler,,false,39,39,ngx_ssl_handshake_handler,,,10,void ngx_ssl_handshake_handler (ngx_event_t*)
84613,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static ngx_int_t ngx_ssl_handle_recv(ngx_connection_t *c, int n);",18,64,event\ngx_event_openssl.c,ngx_ssl_handle_recv,,false,44,44,ngx_ssl_handle_recv,,,11,"ngx_int_t ngx_ssl_handle_recv (ngx_connection_t*,int)"
84619,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,static void ngx_ssl_write_handler(ngx_event_t *wev);,13,51,event\ngx_event_openssl.c,ngx_ssl_write_handler,,false,45,45,ngx_ssl_write_handler,,,12,void ngx_ssl_write_handler (ngx_event_t*)
84624,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,static void ngx_ssl_read_handler(ngx_event_t *rev);,13,50,event\ngx_event_openssl.c,ngx_ssl_read_handler,,false,50,50,ngx_ssl_read_handler,,,13,void ngx_ssl_read_handler (ngx_event_t*)
84629,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,static void ngx_ssl_shutdown_handler(ngx_event_t *ev);,13,53,event\ngx_event_openssl.c,ngx_ssl_shutdown_handler,,false,51,51,ngx_ssl_shutdown_handler,,,14,void ngx_ssl_shutdown_handler (ngx_event_t*)
84634,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static void ngx_ssl_connection_error(ngx_connection_t *c, int sslerr,
    ngx_err_t err, char *text);",13,30,event\ngx_event_openssl.c,ngx_ssl_connection_error,,false,52,53,ngx_ssl_connection_error,,,15,"void ngx_ssl_connection_error (ngx_connection_t*,int,ngx_err_t,char*)"
84642,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,static void ngx_ssl_clear_error(ngx_log_t *log);,13,47,event\ngx_event_openssl.c,ngx_ssl_clear_error,,false,54,54,ngx_ssl_clear_error,,,16,void ngx_ssl_clear_error (ngx_log_t*)
84647,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static ngx_int_t ngx_ssl_session_id_context(ngx_ssl_t *ssl,
    ngx_str_t *sess_ctx, ngx_array_t *certificates);",18,51,event\ngx_event_openssl.c,ngx_ssl_session_id_context,,false,56,57,ngx_ssl_session_id_context,,,17,"ngx_int_t ngx_ssl_session_id_context (ngx_ssl_t*,ngx_str_t*,ngx_array_t*)"
84654,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static int ngx_ssl_new_session(ngx_ssl_conn_t *ssl_conn,
    ngx_ssl_session_t *sess);",12,28,event\ngx_event_openssl.c,ngx_ssl_new_session,,false,58,59,ngx_ssl_new_session,,,18,"int ngx_ssl_new_session (ngx_ssl_conn_t*,ngx_ssl_session_t*)"
84660,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static ngx_ssl_session_t *ngx_ssl_get_cached_session(ngx_ssl_conn_t *ssl_conn,
#if OPENSSL_VERSION_NUMBER >= 0x10100003L
    const
#endif
    u_char *id, int len, int *copy);",26,35,event\ngx_event_openssl.c,ngx_ssl_get_cached_session,,false,60,64,ngx_ssl_get_cached_session,,,19,"ngx_ssl_session_t* ngx_ssl_get_cached_session (ngx_ssl_conn_t*,u_char*,int,int*)"
84668,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static void ngx_ssl_remove_session(SSL_CTX *ssl, ngx_ssl_session_t *sess);",13,73,event\ngx_event_openssl.c,ngx_ssl_remove_session,,false,65,65,ngx_ssl_remove_session,,,20,"void ngx_ssl_remove_session (SSL_CTX*,ngx_ssl_session_t*)"
84674,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static void ngx_ssl_expire_sessions(ngx_ssl_session_cache_t *cache,
    ngx_slab_pool_t *shpool, ngx_uint_t n);",13,42,event\ngx_event_openssl.c,ngx_ssl_expire_sessions,,false,66,67,ngx_ssl_expire_sessions,,,21,"void ngx_ssl_expire_sessions (ngx_ssl_session_cache_t*,ngx_slab_pool_t*,ngx_uint_t)"
84681,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static void ngx_ssl_session_rbtree_insert_value(ngx_rbtree_node_t *temp,
    ngx_rbtree_node_t *node, ngx_rbtree_node_t *sentinel);",13,57,event\ngx_event_openssl.c,ngx_ssl_session_rbtree_insert_value,,false,68,69,ngx_ssl_session_rbtree_insert_value,,,22,"void ngx_ssl_session_rbtree_insert_value (ngx_rbtree_node_t*,ngx_rbtree_node_t*,ngx_rbtree_node_t*)"
84688,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static ngx_int_t ngx_ssl_check_name(ngx_str_t *name, ASN1_STRING *str);",18,70,event\ngx_event_openssl.c,ngx_ssl_check_name,,false,79,79,ngx_ssl_check_name,,,23,"ngx_int_t ngx_ssl_check_name (ngx_str_t*,ASN1_STRING*)"
84694,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static time_t ngx_ssl_parse_time(
#if OPENSSL_VERSION_NUMBER > 0x10100000L
    const
#endif
    ASN1_TIME *asn1time);",15,24,event\ngx_event_openssl.c,ngx_ssl_parse_time,,false,82,86,ngx_ssl_parse_time,,,24,time_t ngx_ssl_parse_time (ASN1_TIME*)
84699,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,static void *ngx_openssl_create_conf(ngx_cycle_t *cycle);,13,56,event\ngx_event_openssl.c,ngx_openssl_create_conf,,false,88,88,ngx_openssl_create_conf,,,25,void* ngx_openssl_create_conf (ngx_cycle_t*)
84704,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static char *ngx_openssl_engine(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",13,79,event\ngx_event_openssl.c,ngx_openssl_engine,,false,89,89,ngx_openssl_engine,,,26,"char* ngx_openssl_engine (ngx_conf_t*,ngx_command_t*,void*)"
84711,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,static void ngx_openssl_exit(ngx_cycle_t *cycle);,13,48,event\ngx_event_openssl.c,ngx_openssl_exit,,false,90,90,ngx_openssl_exit,,,27,void ngx_openssl_exit (ngx_cycle_t*)
84767,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_init(ngx_log_t *log)
{
#if OPENSSL_VERSION_NUMBER >= 0x10100003L

    if (OPENSSL_init_ssl(OPENSSL_INIT_LOAD_CONFIG, NULL) == 0) {
        ngx_ssl_error(NGX_LOG_ALERT, log, 0, ""OPENSSL_init_ssl() failed"");
        return NGX_ERROR;
    }

    /*
     * OPENSSL_init_ssl() may leave errors in the error queue
     * while returning success
     */

    ERR_clear_error();

#else

    OPENSSL_config(NULL);

    SSL_library_init();
    SSL_load_error_strings();

    OpenSSL_add_all_algorithms();

#endif

#ifndef SSL_OP_NO_COMPRESSION
    {
    /*
     * Disable gzip compression in OpenSSL prior to 1.0.0 version,
     * this saves about 522K per connection.
     */
    int                  n;
    STACK_OF(SSL_COMP)  *ssl_comp_methods;

    ssl_comp_methods = SSL_COMP_get_compression_methods();
    n = sk_SSL_COMP_num(ssl_comp_methods);

    while (n--) {
        (void) sk_SSL_COMP_pop(ssl_comp_methods);
    }
    }
#endif

    ngx_ssl_connection_index = SSL_get_ex_new_ind...",1,1,event\ngx_event_openssl.c,ngx_ssl_init,,false,140,255,ngx_ssl_init,,,43,ngx_int_t ngx_ssl_init (ngx_log_t*)
84989,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_create(ngx_ssl_t *ssl, ngx_uint_t protocols, void *data)
{
    ssl->ctx = SSL_CTX_new(SSLv23_method());

    if (ssl->ctx == NULL) {
        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0, ""SSL_CTX_new() failed"");
        return NGX_ERROR;
    }

    if (SSL_CTX_set_ex_data(ssl->ctx, ngx_ssl_server_conf_index, data) == 0) {
        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
                      ""SSL_CTX_set_ex_data() failed"");
        return NGX_ERROR;
    }

    if (SSL_CTX_set_ex_data(ssl->ctx, ngx_ssl_certificate_index, NULL) == 0) {
        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
                      ""SSL_CTX_set_ex_data() failed"");
        return NGX_ERROR;
    }

    ssl->buffer_size = NGX_SSL_BUFSIZE;

    /* client side options */

#ifdef SSL_OP_MICROSOFT_SESS_ID_BUG
    SSL_CTX_set_options(ssl->ctx, SSL_OP_MICROSOFT_SESS_ID_BUG);
#endif

#ifdef SSL_OP_NETSCAPE_CHALLENGE_BUG
    SSL_CTX_set_options(ssl->ctx, SSL_OP_NETSCAPE_CHALLENGE_BUG);
#endif

    /* serve...",1,1,event\ngx_event_openssl.c,ngx_ssl_create,,false,258,394,ngx_ssl_create,,,44,"ngx_int_t ngx_ssl_create (ngx_ssl_t*,ngx_uint_t,void*)"
85111,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_certificates(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_array_t *certs,
    ngx_array_t *keys, ngx_array_t *passwords)
{
    ngx_str_t   *cert, *key;
    ngx_uint_t   i;

    cert = certs->elts;
    key = keys->elts;

    for (i = 0; i < certs->nelts; i++) {

        if (ngx_ssl_certificate(cf, ssl, &cert[i], &key[i], passwords)
            != NGX_OK)
        {
            return NGX_ERROR;
        }
    }

    return NGX_OK;
}",1,1,event\ngx_event_openssl.c,ngx_ssl_certificates,,false,397,417,ngx_ssl_certificates,,,45,"ngx_int_t ngx_ssl_certificates (ngx_conf_t*,ngx_ssl_t*,ngx_array_t*,ngx_array_t*,ngx_array_t*)"
85166,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *cert,
    ngx_str_t *key, ngx_array_t *passwords)
{
    char            *err;
    X509            *x509;
    EVP_PKEY        *pkey;
    STACK_OF(X509)  *chain;

    x509 = ngx_ssl_load_certificate(cf->pool, &err, cert, &chain);
    if (x509 == NULL) {
        if (err != NULL) {
            ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
                          ""cannot load certificate \""%s\"": %s"",
                          cert->data, err);
        }

        return NGX_ERROR;
    }

    if (SSL_CTX_use_certificate(ssl->ctx, x509) == 0) {
        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
                      ""SSL_CTX_use_certificate(\""%s\"") failed"", cert->data);
        X509_free(x509);
        sk_X509_pop_free(chain, X509_free);
        return NGX_ERROR;
    }

    if (X509_set_ex_data(x509, ngx_ssl_certificate_name_index, cert->data)
        == 0)
    {
        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0, ""X509_set...",1,1,event\ngx_event_openssl.c,ngx_ssl_certificate,,false,420,538,ngx_ssl_certificate,,,46,"ngx_int_t ngx_ssl_certificate (ngx_conf_t*,ngx_ssl_t*,ngx_str_t*,ngx_str_t*,ngx_array_t*)"
85416,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_connection_certificate(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *cert, ngx_str_t *key, ngx_array_t *passwords)
{
    char            *err;
    X509            *x509;
    EVP_PKEY        *pkey;
    STACK_OF(X509)  *chain;

    x509 = ngx_ssl_load_certificate(pool, &err, cert, &chain);
    if (x509 == NULL) {
        if (err != NULL) {
            ngx_ssl_error(NGX_LOG_ERR, c->log, 0,
                          ""cannot load certificate \""%s\"": %s"",
                          cert->data, err);
        }

        return NGX_ERROR;
    }

    if (SSL_use_certificate(c->ssl->connection, x509) == 0) {
        ngx_ssl_error(NGX_LOG_ERR, c->log, 0,
                      ""SSL_use_certificate(\""%s\"") failed"", cert->data);
        X509_free(x509);
        sk_X509_pop_free(chain, X509_free);
        return NGX_ERROR;
    }

    X509_free(x509);

#ifdef SSL_set0_chain

    /*
     * SSL_set0_chain() is only available in OpenSSL 1.0.2+,
     * but this function is only ...",1,1,event\ngx_event_openssl.c,ngx_ssl_connection_certificate,,false,541,609,ngx_ssl_connection_certificate,,,47,"ngx_int_t ngx_ssl_connection_certificate (ngx_connection_t*,ngx_pool_t*,ngx_str_t*,ngx_str_t*,ngx_array_t*)"
85555,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static EVP_PKEY *
ngx_ssl_load_certificate_key(ngx_pool_t *pool, char **err,
    ngx_str_t *key, ngx_array_t *passwords)
{
    BIO              *bio;
    EVP_PKEY         *pkey;
    ngx_str_t        *pwd;
    ngx_uint_t        tries;
    pem_password_cb  *cb;

    if (ngx_strncmp(key->data, ""engine:"", sizeof(""engine:"") - 1) == 0) {

#ifndef OPENSSL_NO_ENGINE

        u_char  *p, *last;
        ENGINE  *engine;

        p = key->data + sizeof(""engine:"") - 1;
        last = (u_char *) ngx_strchr(p, ':');

        if (last == NULL) {
            *err = ""invalid syntax"";
            return NULL;
        }

        *last = '\0';

        engine = ENGINE_by_id((char *) p);

        if (engine == NULL) {
            *err = ""ENGINE_by_id() failed"";
            return NULL;
        }

        *last++ = ':';

        pkey = ENGINE_load_private_key(engine, (char *) last, 0, 0);

        if (pkey == NULL) {
            *err = ""ENGINE_load_private_key() failed"";
            ENGINE_free(engine);
...",1,1,event\ngx_event_openssl.c,ngx_ssl_load_certificate_key,,false,702,816,ngx_ssl_load_certificate_key,,,49,"EVP_PKEY ngx_ssl_load_certificate_key (ngx_pool_t*,char**,ngx_str_t*,ngx_array_t*)"
85817,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static int
ngx_ssl_password_callback(char *buf, int size, int rwflag, void *userdata)
{
    ngx_str_t *pwd = userdata;

    if (rwflag) {
        ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, 0,
                      ""ngx_ssl_password_callback() is called for encryption"");
        return 0;
    }

    if (pwd == NULL) {
        return 0;
    }

    if (pwd->len > (size_t) size) {
        ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0,
                      ""password is truncated to %d bytes"", size);
    } else {
        size = pwd->len;
    }

    ngx_memcpy(buf, pwd->data, size);

    return size;
}",1,1,event\ngx_event_openssl.c,ngx_ssl_password_callback,,false,819,844,ngx_ssl_password_callback,,,50,"int ngx_ssl_password_callback (char*,int,int,void*)"
85880,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_ciphers(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *ciphers,
    ngx_uint_t prefer_server_ciphers)
{
    if (SSL_CTX_set_cipher_list(ssl->ctx, (char *) ciphers->data) == 0) {
        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
                      ""SSL_CTX_set_cipher_list(\""%V\"") failed"",
                      ciphers);
        return NGX_ERROR;
    }

    if (prefer_server_ciphers) {
        SSL_CTX_set_options(ssl->ctx, SSL_OP_CIPHER_SERVER_PREFERENCE);
    }

#if (OPENSSL_VERSION_NUMBER < 0x10100001L && !defined LIBRESSL_VERSION_NUMBER)
    /* a temporary 512-bit RSA key is required for export versions of MSIE */
    SSL_CTX_set_tmp_rsa_callback(ssl->ctx, ngx_ssl_rsa512_key_callback);
#endif

    return NGX_OK;
}",1,1,event\ngx_event_openssl.c,ngx_ssl_ciphers,,false,847,868,ngx_ssl_ciphers,,,51,"ngx_int_t ngx_ssl_ciphers (ngx_conf_t*,ngx_ssl_t*,ngx_str_t*,ngx_uint_t)"
85926,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_client_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *cert,
    ngx_int_t depth)
{
    STACK_OF(X509_NAME)  *list;

    SSL_CTX_set_verify(ssl->ctx, SSL_VERIFY_PEER, ngx_ssl_verify_callback);

    SSL_CTX_set_verify_depth(ssl->ctx, depth);

    if (cert->len == 0) {
        return NGX_OK;
    }

    if (ngx_conf_full_name(cf->cycle, cert, 1) != NGX_OK) {
        return NGX_ERROR;
    }

    if (SSL_CTX_load_verify_locations(ssl->ctx, (char *) cert->data, NULL)
        == 0)
    {
        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
                      ""SSL_CTX_load_verify_locations(\""%s\"") failed"",
                      cert->data);
        return NGX_ERROR;
    }

    /*
     * SSL_CTX_load_verify_locations() may leave errors in the error queue
     * while returning success
     */

    ERR_clear_error();

    list = SSL_load_client_CA_file((char *) cert->data);

    if (list == NULL) {
        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
                    ...",1,1,event\ngx_event_openssl.c,ngx_ssl_client_certificate,,false,871,916,ngx_ssl_client_certificate,,,52,"ngx_int_t ngx_ssl_client_certificate (ngx_conf_t*,ngx_ssl_t*,ngx_str_t*,ngx_int_t)"
86029,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_trusted_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *cert,
    ngx_int_t depth)
{
    SSL_CTX_set_verify_depth(ssl->ctx, depth);

    if (cert->len == 0) {
        return NGX_OK;
    }

    if (ngx_conf_full_name(cf->cycle, cert, 1) != NGX_OK) {
        return NGX_ERROR;
    }

    if (SSL_CTX_load_verify_locations(ssl->ctx, (char *) cert->data, NULL)
        == 0)
    {
        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
                      ""SSL_CTX_load_verify_locations(\""%s\"") failed"",
                      cert->data);
        return NGX_ERROR;
    }

    /*
     * SSL_CTX_load_verify_locations() may leave errors in the error queue
     * while returning success
     */

    ERR_clear_error();

    return NGX_OK;
}",1,1,event\ngx_event_openssl.c,ngx_ssl_trusted_certificate,,false,919,950,ngx_ssl_trusted_certificate,,,53,"ngx_int_t ngx_ssl_trusted_certificate (ngx_conf_t*,ngx_ssl_t*,ngx_str_t*,ngx_int_t)"
86092,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_crl(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *crl)
{
    X509_STORE   *store;
    X509_LOOKUP  *lookup;

    if (crl->len == 0) {
        return NGX_OK;
    }

    if (ngx_conf_full_name(cf->cycle, crl, 1) != NGX_OK) {
        return NGX_ERROR;
    }

    store = SSL_CTX_get_cert_store(ssl->ctx);

    if (store == NULL) {
        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
                      ""SSL_CTX_get_cert_store() failed"");
        return NGX_ERROR;
    }

    lookup = X509_STORE_add_lookup(store, X509_LOOKUP_file());

    if (lookup == NULL) {
        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
                      ""X509_STORE_add_lookup() failed"");
        return NGX_ERROR;
    }

    if (X509_LOOKUP_load_file(lookup, (char *) crl->data, X509_FILETYPE_PEM)
        == 0)
    {
        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
                      ""X509_LOOKUP_load_file(\""%s\"") failed"", crl->data);
        return NGX_ERROR;
    }

    X509_STORE_set_flags(stor...",1,1,event\ngx_event_openssl.c,ngx_ssl_crl,,false,953,995,ngx_ssl_crl,,,54,"ngx_int_t ngx_ssl_crl (ngx_conf_t*,ngx_ssl_t*,ngx_str_t*)"
86192,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static int
ngx_ssl_verify_callback(int ok, X509_STORE_CTX *x509_store)
{
#if (NGX_DEBUG)
    char              *subject, *issuer;
    int                err, depth;
    X509              *cert;
    X509_NAME         *sname, *iname;
    ngx_connection_t  *c;
    ngx_ssl_conn_t    *ssl_conn;

    ssl_conn = X509_STORE_CTX_get_ex_data(x509_store,
                                          SSL_get_ex_data_X509_STORE_CTX_idx());

    c = ngx_ssl_get_connection(ssl_conn);

    cert = X509_STORE_CTX_get_current_cert(x509_store);
    err = X509_STORE_CTX_get_error(x509_store);
    depth = X509_STORE_CTX_get_error_depth(x509_store);

    sname = X509_get_subject_name(cert);
    subject = sname ? X509_NAME_oneline(sname, NULL, 0) : ""(none)"";

    iname = X509_get_issuer_name(cert);
    issuer = iname ? X509_NAME_oneline(iname, NULL, 0) : ""(none)"";

    ngx_log_debug5(NGX_LOG_DEBUG_EVENT, c->log, 0,
                   ""verify:%d, error:%d, depth:%d, ""
                   ""subject:\""%s\"", issuer:...",1,1,event\ngx_event_openssl.c,ngx_ssl_verify_callback,,false,998,1039,ngx_ssl_verify_callback,,,55,"int ngx_ssl_verify_callback (int,X509_STORE_CTX*)"
86200,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static void
ngx_ssl_info_callback(const ngx_ssl_conn_t *ssl_conn, int where, int ret)
{
    BIO               *rbio, *wbio;
    ngx_connection_t  *c;

#ifndef SSL_OP_NO_RENEGOTIATION

    if ((where & SSL_CB_HANDSHAKE_START)
        && SSL_is_server((ngx_ssl_conn_t *) ssl_conn))
    {
        c = ngx_ssl_get_connection((ngx_ssl_conn_t *) ssl_conn);

        if (c->ssl->handshaked) {
            c->ssl->renegotiation = 1;
            ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0, ""SSL renegotiation"");
        }
    }

#endif

    if ((where & SSL_CB_ACCEPT_LOOP) == SSL_CB_ACCEPT_LOOP) {
        c = ngx_ssl_get_connection((ngx_ssl_conn_t *) ssl_conn);

        if (!c->ssl->handshake_buffer_set) {
            /*
             * By default OpenSSL uses 4k buffer during a handshake,
             * which is too low for long certificate chains and might
             * result in extra round-trips.
             *
             * To adjust a buffer size we detect that buffering was added
      ...",1,1,event\ngx_event_openssl.c,ngx_ssl_info_callback,,false,1042,1087,ngx_ssl_info_callback,,,56,"void ngx_ssl_info_callback (ngx_ssl_conn_t*,int,int)"
86293,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"RSA *
ngx_ssl_rsa512_key_callback(ngx_ssl_conn_t *ssl_conn, int is_export,
    int key_length)
{
    static RSA  *key;

    if (key_length != 512) {
        return NULL;
    }

#if (OPENSSL_VERSION_NUMBER < 0x10100003L && !defined OPENSSL_NO_DEPRECATED)

    if (key == NULL) {
        key = RSA_generate_key(512, RSA_F4, NULL, NULL);
    }

#endif

    return key;
}",1,1,event\ngx_event_openssl.c,ngx_ssl_rsa512_key_callback,,false,1090,1109,ngx_ssl_rsa512_key_callback,,,57,"RSA ngx_ssl_rsa512_key_callback (ngx_ssl_conn_t*,int,int)"
86322,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_array_t *
ngx_ssl_read_password_file(ngx_conf_t *cf, ngx_str_t *file)
{
    u_char              *p, *last, *end;
    size_t               len;
    ssize_t              n;
    ngx_fd_t             fd;
    ngx_str_t           *pwd;
    ngx_array_t         *passwords;
    ngx_pool_cleanup_t  *cln;
    u_char               buf[NGX_SSL_PASSWORD_BUFFER_SIZE];

    if (ngx_conf_full_name(cf->cycle, file, 1) != NGX_OK) {
        return NULL;
    }

    passwords = ngx_array_create(cf->temp_pool, 4, sizeof(ngx_str_t));
    if (passwords == NULL) {
        return NULL;
    }

    cln = ngx_pool_cleanup_add(cf->temp_pool, 0);
    if (cln == NULL) {
        return NULL;
    }

    cln->handler = ngx_ssl_passwords_cleanup;
    cln->data = passwords;

    fd = ngx_open_file(file->data, NGX_FILE_RDONLY, NGX_FILE_OPEN, 0);

    if (fd == NGX_INVALID_FILE) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, ngx_errno,
                           ngx_open_file_n "" \""%s\"" failed"", file->data);
        ...",1,29,event\ngx_event_openssl.c,ngx_ssl_read_password_file,,false,1112,1239,ngx_ssl_read_password_file,,,58,"ngx_array_t ngx_ssl_read_password_file (ngx_conf_t*,ngx_str_t*)"
86619,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_array_t *
ngx_ssl_preserve_passwords(ngx_conf_t *cf, ngx_array_t *passwords)
{
    ngx_str_t           *opwd, *pwd;
    ngx_uint_t           i;
    ngx_array_t         *pwds;
    ngx_pool_cleanup_t  *cln;
    static ngx_array_t   empty_passwords;

    if (passwords == NULL) {

        /*
         * If there are no passwords, an empty array is used
         * to make sure OpenSSL's default password callback
         * won't block on reading from stdin.
         */

        return &empty_passwords;
    }

    /*
     * Passwords are normally allocated from the temporary pool
     * and cleared after parsing configuration.  To be used at
     * runtime they have to be copied to the configuration pool.
     */

    pwds = ngx_array_create(cf->pool, passwords->nelts, sizeof(ngx_str_t));
    if (pwds == NULL) {
        return NULL;
    }

    cln = ngx_pool_cleanup_add(cf->pool, 0);
    if (cln == NULL) {
        return NULL;
    }

    cln->handler = ngx_ssl_passwords_cleanup;
    cl...",1,1,event\ngx_event_openssl.c,ngx_ssl_preserve_passwords,,false,1242,1302,ngx_ssl_preserve_passwords,,,59,"ngx_array_t ngx_ssl_preserve_passwords (ngx_conf_t*,ngx_array_t*)"
86759,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static void
ngx_ssl_passwords_cleanup(void *data)
{
    ngx_array_t *passwords = data;

    ngx_str_t   *pwd;
    ngx_uint_t   i;

    pwd = passwords->elts;

    for (i = 0; i < passwords->nelts; i++) {
        ngx_explicit_memzero(pwd[i].data, pwd[i].len);
    }
}",1,1,event\ngx_event_openssl.c,ngx_ssl_passwords_cleanup,,false,1305,1318,ngx_ssl_passwords_cleanup,,,60,void ngx_ssl_passwords_cleanup (void*)
86799,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_dhparam(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *file)
{
    DH   *dh;
    BIO  *bio;

    if (file->len == 0) {
        return NGX_OK;
    }

    if (ngx_conf_full_name(cf->cycle, file, 1) != NGX_OK) {
        return NGX_ERROR;
    }

    bio = BIO_new_file((char *) file->data, ""r"");
    if (bio == NULL) {
        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
                      ""BIO_new_file(\""%s\"") failed"", file->data);
        return NGX_ERROR;
    }

    dh = PEM_read_bio_DHparams(bio, NULL, NULL, NULL);
    if (dh == NULL) {
        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
                      ""PEM_read_bio_DHparams(\""%s\"") failed"", file->data);
        BIO_free(bio);
        return NGX_ERROR;
    }

    SSL_CTX_set_tmp_dh(ssl->ctx, dh);

    DH_free(dh);
    BIO_free(bio);

    return NGX_OK;
}",1,1,event\ngx_event_openssl.c,ngx_ssl_dhparam,,false,1321,1356,ngx_ssl_dhparam,,,61,"ngx_int_t ngx_ssl_dhparam (ngx_conf_t*,ngx_ssl_t*,ngx_str_t*)"
86892,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_ecdh_curve(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *name)
{
#ifndef OPENSSL_NO_ECDH

    /*
     * Elliptic-Curve Diffie-Hellman parameters are either ""named curves""
     * from RFC 4492 section 5.1.1, or explicitly described curves over
     * binary fields.  OpenSSL only supports the ""named curves"", which provide
     * maximum interoperability.
     */

#if (defined SSL_CTX_set1_curves_list || defined SSL_CTRL_SET_CURVES_LIST)

    /*
     * OpenSSL 1.0.2+ allows configuring a curve list instead of a single
     * curve previously supported.  By default an internal list is used,
     * with prime256v1 being preferred by server in OpenSSL 1.0.2b+
     * and X25519 in OpenSSL 1.1.0+.
     *
     * By default a curve preferred by the client will be used for
     * key exchange.  The SSL_OP_CIPHER_SERVER_PREFERENCE option can
     * be used to prefer server curves instead, similar to what it
     * does for ciphers.
     */

    SSL_CTX_set_options(ssl->ctx, SSL_O...",1,1,event\ngx_event_openssl.c,ngx_ssl_ecdh_curve,,false,1359,1438,ngx_ssl_ecdh_curve,,,62,"ngx_int_t ngx_ssl_ecdh_curve (ngx_conf_t*,ngx_ssl_t*,ngx_str_t*)"
86975,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_early_data(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_uint_t enable)
{
    if (!enable) {
        return NGX_OK;
    }

#ifdef SSL_ERROR_EARLY_DATA_REJECTED

    /* BoringSSL */

    SSL_CTX_set_early_data_enabled(ssl->ctx, 1);

#elif defined SSL_READ_EARLY_DATA_SUCCESS

    /* OpenSSL */

    SSL_CTX_set_max_early_data(ssl->ctx, NGX_SSL_BUFSIZE);

#else
    ngx_log_error(NGX_LOG_WARN, ssl->log, 0,
                  ""\""ssl_early_data\"" is not supported on this platform, ""
                  ""ignored"");
#endif

    return NGX_OK;
}",1,1,event\ngx_event_openssl.c,ngx_ssl_early_data,,false,1441,1467,ngx_ssl_early_data,,,63,"ngx_int_t ngx_ssl_early_data (ngx_conf_t*,ngx_ssl_t*,ngx_uint_t)"
86997,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_client_session_cache(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_uint_t enable)
{
    if (!enable) {
        return NGX_OK;
    }

    SSL_CTX_set_session_cache_mode(ssl->ctx,
                                   SSL_SESS_CACHE_CLIENT
                                   |SSL_SESS_CACHE_NO_INTERNAL);

    SSL_CTX_sess_set_new_cb(ssl->ctx, ngx_ssl_new_client_session);

    return NGX_OK;
}",1,1,event\ngx_event_openssl.c,ngx_ssl_client_session_cache,,false,1470,1484,ngx_ssl_client_session_cache,,,64,"ngx_int_t ngx_ssl_client_session_cache (ngx_conf_t*,ngx_ssl_t*,ngx_uint_t)"
87024,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static int
ngx_ssl_new_client_session(ngx_ssl_conn_t *ssl_conn, ngx_ssl_session_t *sess)
{
    ngx_connection_t  *c;

    c = ngx_ssl_get_connection(ssl_conn);

    if (c->ssl->save_session) {
        c->ssl->session = sess;

        c->ssl->save_session(c);

        c->ssl->session = NULL;
    }

    return 0;
}",1,1,event\ngx_event_openssl.c,ngx_ssl_new_client_session,,false,1487,1503,ngx_ssl_new_client_session,,,65,"int ngx_ssl_new_client_session (ngx_ssl_conn_t*,ngx_ssl_session_t*)"
87065,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_create_connection(ngx_ssl_t *ssl, ngx_connection_t *c, ngx_uint_t flags)
{
    ngx_ssl_connection_t  *sc;

    sc = ngx_pcalloc(c->pool, sizeof(ngx_ssl_connection_t));
    if (sc == NULL) {
        return NGX_ERROR;
    }

    sc->buffer = ((flags & NGX_SSL_BUFFER) != 0);
    sc->buffer_size = ssl->buffer_size;

    sc->session_ctx = ssl->ctx;

#ifdef SSL_READ_EARLY_DATA_SUCCESS
    if (SSL_CTX_get_max_early_data(ssl->ctx)) {
        sc->try_early_data = 1;
    }
#endif

    sc->connection = SSL_new(ssl->ctx);

    if (sc->connection == NULL) {
        ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, ""SSL_new() failed"");
        return NGX_ERROR;
    }

    if (SSL_set_fd(sc->connection, c->fd) == 0) {
        ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, ""SSL_set_fd() failed"");
        return NGX_ERROR;
    }

    if (flags & NGX_SSL_CLIENT) {
        SSL_set_connect_state(sc->connection);

    } else {
        SSL_set_accept_state(sc->connection);

#ifdef SSL_OP_NO_RENEGOTIATIO...",1,1,event\ngx_event_openssl.c,ngx_ssl_create_connection,,false,1506,1558,ngx_ssl_create_connection,,,66,"ngx_int_t ngx_ssl_create_connection (ngx_ssl_t*,ngx_connection_t*,ngx_uint_t)"
87196,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_ssl_session_t *
ngx_ssl_get_session(ngx_connection_t *c)
{
#ifdef TLS1_3_VERSION
    if (c->ssl->session) {
        SSL_SESSION_up_ref(c->ssl->session);
        return c->ssl->session;
    }
#endif

    return SSL_get1_session(c->ssl->connection);
}",1,1,event\ngx_event_openssl.c,ngx_ssl_get_session,,false,1561,1572,ngx_ssl_get_session,,,67,ngx_ssl_session_t ngx_ssl_get_session (ngx_connection_t*)
87208,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_ssl_session_t *
ngx_ssl_get0_session(ngx_connection_t *c)
{
    if (c->ssl->session) {
        return c->ssl->session;
    }

    return SSL_get0_session(c->ssl->connection);
}",1,1,event\ngx_event_openssl.c,ngx_ssl_get0_session,,false,1575,1583,ngx_ssl_get0_session,,,68,ngx_ssl_session_t ngx_ssl_get0_session (ngx_connection_t*)
87233,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_set_session(ngx_connection_t *c, ngx_ssl_session_t *session)
{
    if (session) {
        if (SSL_set_session(c->ssl->connection, session) == 0) {
            ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, ""SSL_set_session() failed"");
            return NGX_ERROR;
        }
    }

    return NGX_OK;
}",1,1,event\ngx_event_openssl.c,ngx_ssl_set_session,,false,1586,1597,ngx_ssl_set_session,,,69,"ngx_int_t ngx_ssl_set_session (ngx_connection_t*,ngx_ssl_session_t*)"
87264,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_handshake(ngx_connection_t *c)
{
    int        n, sslerr;
    ngx_err_t  err;
    ngx_int_t  rc;

#ifdef SSL_READ_EARLY_DATA_SUCCESS
    if (c->ssl->try_early_data) {
        return ngx_ssl_try_early_data(c);
    }
#endif

    if (c->ssl->in_ocsp) {
        return ngx_ssl_ocsp_validate(c);
    }

    ngx_ssl_clear_error(c->log);

    n = SSL_do_handshake(c->ssl->connection);

    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, ""SSL_do_handshake: %d"", n);

    if (n == 1) {

        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
            return NGX_ERROR;
        }

        if (ngx_handle_write_event(c->write, 0) != NGX_OK) {
            return NGX_ERROR;
        }

#if (NGX_DEBUG)
        ngx_ssl_handshake_log(c);
#endif

        c->recv = ngx_ssl_recv;
        c->send = ngx_ssl_write;
        c->recv_chain = ngx_ssl_recv_chain;
        c->send_chain = ngx_ssl_send_chain;

#ifndef SSL_OP_NO_RENEGOTIATION
#if OPENSSL_VERSION_NUMBER < 0x10100000L
#ifdef SSL3_F...",1,1,event\ngx_event_openssl.c,ngx_ssl_handshake,,false,1600,1726,ngx_ssl_handshake,,,70,ngx_int_t ngx_ssl_handshake (ngx_connection_t*)
87566,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static void
ngx_ssl_handshake_handler(ngx_event_t *ev)
{
    ngx_connection_t  *c;

    c = ev->data;

    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,
                   ""SSL handshake handler: %d"", ev->write);

    if (ev->timedout) {
        c->ssl->handler(c);
        return;
    }

    if (ngx_ssl_handshake(c) == NGX_AGAIN) {
        return;
    }

    c->ssl->handler(c);
}",1,1,event\ngx_event_openssl.c,ngx_ssl_handshake_handler,,false,1910,1930,ngx_ssl_handshake_handler,,,71,void ngx_ssl_handshake_handler (ngx_event_t*)
87614,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ssize_t
ngx_ssl_recv_chain(ngx_connection_t *c, ngx_chain_t *cl, off_t limit)
{
    u_char     *last;
    ssize_t     n, bytes, size;
    ngx_buf_t  *b;

    bytes = 0;

    b = cl->buf;
    last = b->last;

    for ( ;; ) {
        size = b->end - last;

        if (limit) {
            if (bytes >= limit) {
                return bytes;
            }

            if (bytes + size > limit) {
                size = (ssize_t) (limit - bytes);
            }
        }

        n = ngx_ssl_recv(c, last, size);

        if (n > 0) {
            last += n;
            bytes += n;

            if (!c->read->ready) {
                return bytes;
            }

            if (last == b->end) {
                cl = cl->next;

                if (cl == NULL) {
                    return bytes;
                }

                b = cl->buf;
                last = b->last;
            }

            continue;
        }

        if (bytes) {

            if (n == 0 || n == NGX_ERROR) {
       ...",1,1,event\ngx_event_openssl.c,ngx_ssl_recv_chain,,false,1933,1993,ngx_ssl_recv_chain,,,72,"ssize_t ngx_ssl_recv_chain (ngx_connection_t*,ngx_chain_t*,off_t)"
87752,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ssize_t
ngx_ssl_recv(ngx_connection_t *c, u_char *buf, size_t size)
{
    int  n, bytes;

#ifdef SSL_READ_EARLY_DATA_SUCCESS
    if (c->ssl->in_early) {
        return ngx_ssl_recv_early(c, buf, size);
    }
#endif

    if (c->ssl->last == NGX_ERROR) {
        c->read->error = 1;
        return NGX_ERROR;
    }

    if (c->ssl->last == NGX_DONE) {
        c->read->ready = 0;
        c->read->eof = 1;
        return 0;
    }

    bytes = 0;

    ngx_ssl_clear_error(c->log);

    /*
     * SSL_read() may return data in parts, so try to read
     * until SSL_read() would return no data
     */

    for ( ;; ) {

        n = SSL_read(c->ssl->connection, buf, size);

        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, ""SSL_read: %d"", n);

        if (n > 0) {
            bytes += n;
        }

        c->ssl->last = ngx_ssl_handle_recv(c, n);

        if (c->ssl->last == NGX_OK) {

            size -= n;

            if (size == 0) {
                c->read->ready = 1;

              ...",1,1,event\ngx_event_openssl.c,ngx_ssl_recv,,false,1996,2118,ngx_ssl_recv,,,73,"ssize_t ngx_ssl_recv (ngx_connection_t*,u_char*,size_t)"
88012,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_ssl_handle_recv(ngx_connection_t *c, int n)
{
    int        sslerr;
    ngx_err_t  err;

#ifndef SSL_OP_NO_RENEGOTIATION

    if (c->ssl->renegotiation) {
        /*
         * disable renegotiation (CVE-2009-3555):
         * OpenSSL (at least up to 0.9.8l) does not handle disabled
         * renegotiation gracefully, so drop connection here
         */

        ngx_log_error(NGX_LOG_NOTICE, c->log, 0, ""SSL renegotiation disabled"");

        while (ERR_peek_error()) {
            ngx_ssl_error(NGX_LOG_DEBUG, c->log, 0,
                          ""ignoring stale global SSL error"");
        }

        ERR_clear_error();

        c->ssl->no_wait_shutdown = 1;
        c->ssl->no_send_shutdown = 1;

        return NGX_ERROR;
    }

#endif

    if (n > 0) {

        if (c->ssl->saved_write_handler) {

            c->write->handler = c->ssl->saved_write_handler;
            c->ssl->saved_write_handler = NULL;
            c->write->ready = 1;

            if (ngx_handl...",1,1,event\ngx_event_openssl.c,ngx_ssl_handle_recv,,false,2242,2352,ngx_ssl_handle_recv,,,74,"ngx_int_t ngx_ssl_handle_recv (ngx_connection_t*,int)"
88303,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static void
ngx_ssl_write_handler(ngx_event_t *wev)
{
    ngx_connection_t  *c;

    c = wev->data;

    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0, ""SSL write handler"");

    c->read->handler(c->read);
}",1,1,event\ngx_event_openssl.c,ngx_ssl_write_handler,,false,2355,2365,ngx_ssl_write_handler,,,75,void ngx_ssl_write_handler (ngx_event_t*)
88330,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_chain_t *
ngx_ssl_send_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)
{
    int          n;
    ngx_uint_t   flush;
    ssize_t      send, size;
    ngx_buf_t   *buf;

    if (!c->ssl->buffer) {

        while (in) {
            if (ngx_buf_special(in->buf)) {
                in = in->next;
                continue;
            }

            n = ngx_ssl_write(c, in->buf->pos, in->buf->last - in->buf->pos);

            if (n == NGX_ERROR) {
                return NGX_CHAIN_ERROR;
            }

            if (n == NGX_AGAIN) {
                return in;
            }

            in->buf->pos += n;

            if (in->buf->pos == in->buf->last) {
                in = in->next;
            }
        }

        return in;
    }


    /* the maximum limit size is the maximum int32_t value - the page size */

    if (limit == 0 || limit > (off_t) (NGX_MAX_INT32_VALUE - ngx_pagesize)) {
        limit = NGX_MAX_INT32_VALUE - ngx_pagesize;
    }

    buf = c->ssl->buf;

  ...",1,1,event\ngx_event_openssl.c,ngx_ssl_send_chain,,false,2376,2528,ngx_ssl_send_chain,,,76,"ngx_chain_t ngx_ssl_send_chain (ngx_connection_t*,ngx_chain_t*,off_t)"
88830,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ssize_t
ngx_ssl_write(ngx_connection_t *c, u_char *data, size_t size)
{
    int        n, sslerr;
    ngx_err_t  err;

#ifdef SSL_READ_EARLY_DATA_SUCCESS
    if (c->ssl->in_early) {
        return ngx_ssl_write_early(c, data, size);
    }
#endif

    ngx_ssl_clear_error(c->log);

    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, ""SSL to write: %uz"", size);

    n = SSL_write(c->ssl->connection, data, size);

    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, ""SSL_write: %d"", n);

    if (n > 0) {

        if (c->ssl->saved_read_handler) {

            c->read->handler = c->ssl->saved_read_handler;
            c->ssl->saved_read_handler = NULL;
            c->read->ready = 1;

            if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
                return NGX_ERROR;
            }

            ngx_post_event(c->read, &ngx_posted_events);
        }

        c->sent += n;

        return n;
    }

    sslerr = SSL_get_error(c->ssl->connection, n);

    err = (sslerr == SSL_ERROR_...",1,1,event\ngx_event_openssl.c,ngx_ssl_write,,false,2531,2627,ngx_ssl_write,,,77,"ssize_t ngx_ssl_write (ngx_connection_t*,u_char*,size_t)"
89106,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static void
ngx_ssl_read_handler(ngx_event_t *rev)
{
    ngx_connection_t  *c;

    c = rev->data;

    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0, ""SSL read handler"");

    c->write->handler(c->write);
}",1,1,event\ngx_event_openssl.c,ngx_ssl_read_handler,,false,2747,2757,ngx_ssl_read_handler,,,78,void ngx_ssl_read_handler (ngx_event_t*)
89133,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"void
ngx_ssl_free_buffer(ngx_connection_t *c)
{
    if (c->ssl->buf && c->ssl->buf->start) {
        if (ngx_pfree(c->pool, c->ssl->buf->start) == NGX_OK) {
            c->ssl->buf->start = NULL;
        }
    }
}",1,1,event\ngx_event_openssl.c,ngx_ssl_free_buffer,,false,2760,2768,ngx_ssl_free_buffer,,,79,void ngx_ssl_free_buffer (ngx_connection_t*)
89177,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_shutdown(ngx_connection_t *c)
{
    int        n, sslerr, mode;
    ngx_err_t  err;

    ngx_ssl_ocsp_cleanup(c);

    if (SSL_in_init(c->ssl->connection)) {
        /*
         * OpenSSL 1.0.2f complains if SSL_shutdown() is called during
         * an SSL handshake, while previous versions always return 0.
         * Avoid calling SSL_shutdown() if handshake wasn't completed.
         */

        SSL_free(c->ssl->connection);
        c->ssl = NULL;

        return NGX_OK;
    }

    if (c->timedout) {
        mode = SSL_RECEIVED_SHUTDOWN|SSL_SENT_SHUTDOWN;
        SSL_set_quiet_shutdown(c->ssl->connection, 1);

    } else {
        mode = SSL_get_shutdown(c->ssl->connection);

        if (c->ssl->no_wait_shutdown) {
            mode |= SSL_RECEIVED_SHUTDOWN;
        }

        if (c->ssl->no_send_shutdown) {
            mode |= SSL_SENT_SHUTDOWN;
        }

        if (c->ssl->no_wait_shutdown && c->ssl->no_send_shutdown) {
            SSL_set_quiet_shutdown(c->s...",1,1,event\ngx_event_openssl.c,ngx_ssl_shutdown,,false,2771,2865,ngx_ssl_shutdown,,,80,ngx_int_t ngx_ssl_shutdown (ngx_connection_t*)
89439,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static void
ngx_ssl_shutdown_handler(ngx_event_t *ev)
{
    ngx_connection_t           *c;
    ngx_connection_handler_pt   handler;

    c = ev->data;
    handler = c->ssl->handler;

    if (ev->timedout) {
        c->timedout = 1;
    }

    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, ev->log, 0, ""SSL shutdown handler"");

    if (ngx_ssl_shutdown(c) == NGX_AGAIN) {
        return;
    }

    handler(c);
}",1,1,event\ngx_event_openssl.c,ngx_ssl_shutdown_handler,,false,2868,2888,ngx_ssl_shutdown_handler,,,81,void ngx_ssl_shutdown_handler (ngx_event_t*)
89484,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static void
ngx_ssl_connection_error(ngx_connection_t *c, int sslerr, ngx_err_t err,
    char *text)
{
    int         n;
    ngx_uint_t  level;

    level = NGX_LOG_CRIT;

    if (sslerr == SSL_ERROR_SYSCALL) {

        if (err == NGX_ECONNRESET
#if (NGX_WIN32)
            || err == NGX_ECONNABORTED
#endif
            || err == NGX_EPIPE
            || err == NGX_ENOTCONN
            || err == NGX_ETIMEDOUT
            || err == NGX_ECONNREFUSED
            || err == NGX_ENETDOWN
            || err == NGX_ENETUNREACH
            || err == NGX_EHOSTDOWN
            || err == NGX_EHOSTUNREACH)
        {
            switch (c->log_error) {

            case NGX_ERROR_IGNORE_ECONNRESET:
            case NGX_ERROR_INFO:
                level = NGX_LOG_INFO;
                break;

            case NGX_ERROR_ERR:
                level = NGX_LOG_ERR;
                break;

            default:
                break;
            }
        }

    } else if (sslerr == SSL_ERROR_SSL) {

    ...",1,1,event\ngx_event_openssl.c,ngx_ssl_connection_error,,false,2891,3045,ngx_ssl_connection_error,,,82,"void ngx_ssl_connection_error (ngx_connection_t*,int,ngx_err_t,char*)"
89680,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static void
ngx_ssl_clear_error(ngx_log_t *log)
{
    while (ERR_peek_error()) {
        ngx_ssl_error(NGX_LOG_ALERT, log, 0, ""ignoring stale global SSL error"");
    }

    ERR_clear_error();
}",1,1,event\ngx_event_openssl.c,ngx_ssl_clear_error,,false,3048,3056,ngx_ssl_clear_error,,,83,void ngx_ssl_clear_error (ngx_log_t*)
89696,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_ssl_error(ngx_uint_t level, ngx_log_t *log, ngx_err_t err, char *fmt, ...)
{
    int          flags;
    u_long       n;
    va_list      args;
    u_char      *p, *last;
    u_char       errstr[NGX_MAX_CONF_ERRSTR];
    const char  *data;

    last = errstr + NGX_MAX_CONF_ERRSTR;

    va_start(args, fmt);
    p = ngx_vslprintf(errstr, last - 1, fmt, args);
    va_end(args);

    if (ERR_peek_error()) {
        p = ngx_cpystrn(p, (u_char *) "" (SSL:"", last - p);

        for ( ;; ) {

            n = ERR_peek_error_line_data(NULL, NULL, &data, &flags);

            if (n == 0) {
                break;
            }

            /* ERR_error_string_n() requires at least one byte */

            if (p >= last - 1) {
                goto next;
            }

            *p++ = ' ';

            ERR_error_string_n(n, (char *) p, last - p);

            while (p < last && *p) {
                p++;
            }

            if (p < last && *data && (flags & ERR_TXT_STRING)) {
       ...",1,1,event\ngx_event_openssl.c,ngx_ssl_error,,false,3060,3116,ngx_ssl_error,,,86,"ANY ngx_ssl_error (ngx_uint_t,ngx_log_t*,ngx_err_t,char*...)"
89842,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_session_cache(ngx_ssl_t *ssl, ngx_str_t *sess_ctx,
    ngx_array_t *certificates, ssize_t builtin_session_cache,
    ngx_shm_zone_t *shm_zone, time_t timeout)
{
    long  cache_mode;

    SSL_CTX_set_timeout(ssl->ctx, (long) timeout);

    if (ngx_ssl_session_id_context(ssl, sess_ctx, certificates) != NGX_OK) {
        return NGX_ERROR;
    }

    if (builtin_session_cache == NGX_SSL_NO_SCACHE) {
        SSL_CTX_set_session_cache_mode(ssl->ctx, SSL_SESS_CACHE_OFF);
        return NGX_OK;
    }

    if (builtin_session_cache == NGX_SSL_NONE_SCACHE) {

        /*
         * If the server explicitly says that it does not support
         * session reuse (see SSL_SESS_CACHE_OFF above), then
         * Outlook Express fails to upload a sent email to
         * the Sent Items folder on the IMAP server via a separate IMAP
         * connection in the background.  Therefore we have a special
         * mode (SSL_SESS_CACHE_SERVER|SSL_SESS_CACHE_NO_INTERNAL_STORE)
         ...",1,1,event\ngx_event_openssl.c,ngx_ssl_session_cache,,false,3119,3190,ngx_ssl_session_cache,,,87,"ngx_int_t ngx_ssl_session_cache (ngx_ssl_t*,ngx_str_t*,ngx_array_t*,ssize_t,ngx_shm_zone_t*,time_t)"
89975,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_ssl_session_id_context(ngx_ssl_t *ssl, ngx_str_t *sess_ctx,
    ngx_array_t *certificates)
{
    int                   n, i;
    X509                 *cert;
    X509_NAME            *name;
    ngx_str_t            *certs;
    ngx_uint_t            k;
    EVP_MD_CTX           *md;
    unsigned int          len;
    STACK_OF(X509_NAME)  *list;
    u_char                buf[EVP_MAX_MD_SIZE];

    /*
     * Session ID context is set based on the string provided,
     * the server certificates, and the client CA list.
     */

    md = EVP_MD_CTX_create();
    if (md == NULL) {
        return NGX_ERROR;
    }

    if (EVP_DigestInit_ex(md, EVP_sha1(), NULL) == 0) {
        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
                      ""EVP_DigestInit_ex() failed"");
        goto failed;
    }

    if (EVP_DigestUpdate(md, sess_ctx->data, sess_ctx->len) == 0) {
        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
                      ""EVP_DigestUpdate() failed"");
      ...",1,1,event\ngx_event_openssl.c,ngx_ssl_session_id_context,,false,3193,3307,ngx_ssl_session_id_context,,,88,"ngx_int_t ngx_ssl_session_id_context (ngx_ssl_t*,ngx_str_t*,ngx_array_t*)"
90252,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_session_cache_init(ngx_shm_zone_t *shm_zone, void *data)
{
    size_t                    len;
    ngx_slab_pool_t          *shpool;
    ngx_ssl_session_cache_t  *cache;

    if (data) {
        shm_zone->data = data;
        return NGX_OK;
    }

    shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;

    if (shm_zone->shm.exists) {
        shm_zone->data = shpool->data;
        return NGX_OK;
    }

    cache = ngx_slab_alloc(shpool, sizeof(ngx_ssl_session_cache_t));
    if (cache == NULL) {
        return NGX_ERROR;
    }

    shpool->data = cache;
    shm_zone->data = cache;

    ngx_rbtree_init(&cache->session_rbtree, &cache->sentinel,
                    ngx_ssl_session_rbtree_insert_value);

    ngx_queue_init(&cache->expire_queue);

    len = sizeof("" in SSL session shared cache \""\"""") + shm_zone->shm.name.len;

    shpool->log_ctx = ngx_slab_alloc(shpool, len);
    if (shpool->log_ctx == NULL) {
        return NGX_ERROR;
    }

    ngx_sprintf(shpool->log_ctx...",1,1,event\ngx_event_openssl.c,ngx_ssl_session_cache_init,,false,3310,3355,ngx_ssl_session_cache_init,,,89,"ngx_int_t ngx_ssl_session_cache_init (ngx_shm_zone_t*,void*)"
90380,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static int
ngx_ssl_new_session(ngx_ssl_conn_t *ssl_conn, ngx_ssl_session_t *sess)
{
    int                       len;
    u_char                   *p, *id, *cached_sess, *session_id;
    uint32_t                  hash;
    SSL_CTX                  *ssl_ctx;
    unsigned int              session_id_length;
    ngx_shm_zone_t           *shm_zone;
    ngx_connection_t         *c;
    ngx_slab_pool_t          *shpool;
    ngx_ssl_sess_id_t        *sess_id;
    ngx_ssl_session_cache_t  *cache;
    u_char                    buf[NGX_SSL_MAX_SESSION_SIZE];

    len = i2d_SSL_SESSION(sess, NULL);

    /* do not cache too big session */

    if (len > (int) NGX_SSL_MAX_SESSION_SIZE) {
        return 0;
    }

    p = buf;
    i2d_SSL_SESSION(sess, &p);

    c = ngx_ssl_get_connection(ssl_conn);

    ssl_ctx = c->ssl->session_ctx;
    shm_zone = SSL_CTX_get_ex_data(ssl_ctx, ngx_ssl_session_cache_index);

    cache = shm_zone->data;
    shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;

    ngx...",1,1,event\ngx_event_openssl.c,ngx_ssl_new_session,,false,3375,3512,ngx_ssl_new_session,,,90,"int ngx_ssl_new_session (ngx_ssl_conn_t*,ngx_ssl_session_t*)"
90665,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static ngx_ssl_session_t *
ngx_ssl_get_cached_session(ngx_ssl_conn_t *ssl_conn,
#if OPENSSL_VERSION_NUMBER >= 0x10100003L
    const
#endif
    u_char *id, int len, int *copy)
{
    size_t                    slen;
    uint32_t                  hash;
    ngx_int_t                 rc;
    const u_char             *p;
    ngx_shm_zone_t           *shm_zone;
    ngx_slab_pool_t          *shpool;
    ngx_rbtree_node_t        *node, *sentinel;
    ngx_ssl_session_t        *sess;
    ngx_ssl_sess_id_t        *sess_id;
    ngx_ssl_session_cache_t  *cache;
    u_char                    buf[NGX_SSL_MAX_SESSION_SIZE];
    ngx_connection_t         *c;

    hash = ngx_crc32_short((u_char *) (uintptr_t) id, (size_t) len);
    *copy = 0;

    c = ngx_ssl_get_connection(ssl_conn);

    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,
                   ""ssl get session: %08XD:%d"", hash, len);

    shm_zone = SSL_CTX_get_ex_data(c->ssl->session_ctx,
                                   ngx_ssl_session_ca...",1,1,event\ngx_event_openssl.c,ngx_ssl_get_cached_session,,false,3515,3614,ngx_ssl_get_cached_session,,,91,"ngx_ssl_session_t ngx_ssl_get_cached_session (ngx_ssl_conn_t*,u_char*,int,int*)"
90897,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"void
ngx_ssl_remove_cached_session(SSL_CTX *ssl, ngx_ssl_session_t *sess)
{
    SSL_CTX_remove_session(ssl, sess);

    ngx_ssl_remove_session(ssl, sess);
}",1,1,event\ngx_event_openssl.c,ngx_ssl_remove_cached_session,,false,3617,3623,ngx_ssl_remove_cached_session,,,92,"void ngx_ssl_remove_cached_session (SSL_CTX*,ngx_ssl_session_t*)"
90909,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static void
ngx_ssl_remove_session(SSL_CTX *ssl, ngx_ssl_session_t *sess)
{
    u_char                   *id;
    uint32_t                  hash;
    ngx_int_t                 rc;
    unsigned int              len;
    ngx_shm_zone_t           *shm_zone;
    ngx_slab_pool_t          *shpool;
    ngx_rbtree_node_t        *node, *sentinel;
    ngx_ssl_sess_id_t        *sess_id;
    ngx_ssl_session_cache_t  *cache;

    shm_zone = SSL_CTX_get_ex_data(ssl, ngx_ssl_session_cache_index);

    if (shm_zone == NULL) {
        return;
    }

    cache = shm_zone->data;

    id = (u_char *) SSL_SESSION_get_id(sess, &len);

    hash = ngx_crc32_short(id, len);

    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ngx_cycle->log, 0,
                   ""ssl remove session: %08XD:%ud"", hash, len);

    shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;

    ngx_shmtx_lock(&shpool->mutex);

    node = cache->session_rbtree.root;
    sentinel = cache->session_rbtree.sentinel;

    while (node != sentinel) {

    ...",1,1,event\ngx_event_openssl.c,ngx_ssl_remove_session,,false,3626,3700,ngx_ssl_remove_session,,,93,"void ngx_ssl_remove_session (SSL_CTX*,ngx_ssl_session_t*)"
91083,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static void
ngx_ssl_expire_sessions(ngx_ssl_session_cache_t *cache,
    ngx_slab_pool_t *shpool, ngx_uint_t n)
{
    time_t              now;
    ngx_queue_t        *q;
    ngx_ssl_sess_id_t  *sess_id;

    now = ngx_time();

    while (n < 3) {

        if (ngx_queue_empty(&cache->expire_queue)) {
            return;
        }

        q = ngx_queue_last(&cache->expire_queue);

        sess_id = ngx_queue_data(q, ngx_ssl_sess_id_t, queue);

        if (n++ != 0 && sess_id->expire > now) {
            return;
        }

        ngx_queue_remove(q);

        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, ngx_cycle->log, 0,
                       ""expire session: %08Xi"", sess_id->node.key);

        ngx_rbtree_delete(&cache->session_rbtree, &sess_id->node);

        ngx_slab_free_locked(shpool, sess_id->session);
#if (NGX_PTR_SIZE == 4)
        ngx_slab_free_locked(shpool, sess_id->id);
#endif
        ngx_slab_free_locked(shpool, sess_id);
    }
}",1,1,event\ngx_event_openssl.c,ngx_ssl_expire_sessions,,false,3703,3740,ngx_ssl_expire_sessions,,,94,"void ngx_ssl_expire_sessions (ngx_ssl_session_cache_t*,ngx_slab_pool_t*,ngx_uint_t)"
91166,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static void
ngx_ssl_session_rbtree_insert_value(ngx_rbtree_node_t *temp,
    ngx_rbtree_node_t *node, ngx_rbtree_node_t *sentinel)
{
    ngx_rbtree_node_t  **p;
    ngx_ssl_sess_id_t   *sess_id, *sess_id_temp;

    for ( ;; ) {

        if (node->key < temp->key) {

            p = &temp->left;

        } else if (node->key > temp->key) {

            p = &temp->right;

        } else { /* node->key == temp->key */

            sess_id = (ngx_ssl_sess_id_t *) node;
            sess_id_temp = (ngx_ssl_sess_id_t *) temp;

            p = (ngx_memn2cmp(sess_id->id, sess_id_temp->id,
                              (size_t) node->data, (size_t) temp->data)
                 < 0) ? &temp->left : &temp->right;
        }

        if (*p == sentinel) {
            break;
        }

        temp = *p;
    }

    *p = node;
    node->parent = temp;
    node->left = sentinel;
    node->right = sentinel;
    ngx_rbt_red(node);
}",1,1,event\ngx_event_openssl.c,ngx_ssl_session_rbtree_insert_value,,false,3743,3782,ngx_ssl_session_rbtree_insert_value,,,95,"void ngx_ssl_session_rbtree_insert_value (ngx_rbtree_node_t*,ngx_rbtree_node_t*,ngx_rbtree_node_t*)"
91285,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_session_ticket_keys(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_array_t *paths)
{
    if (paths) {
        ngx_log_error(NGX_LOG_WARN, ssl->log, 0,
                      ""\""ssl_session_ticket_key\"" ignored, not supported"");
    }

    return NGX_OK;
}",1,1,event\ngx_event_openssl.c,ngx_ssl_session_ticket_keys,,false,4064,4073,ngx_ssl_session_ticket_keys,,,96,"ngx_int_t ngx_ssl_session_ticket_keys (ngx_conf_t*,ngx_ssl_t*,ngx_array_t*)"
91304,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"void
ngx_ssl_cleanup_ctx(void *data)
{
    ngx_ssl_t  *ssl = data;

    X509  *cert, *next;

    cert = SSL_CTX_get_ex_data(ssl->ctx, ngx_ssl_certificate_index);

    while (cert) {
        next = X509_get_ex_data(cert, ngx_ssl_next_certificate_index);
        X509_free(cert);
        cert = next;
    }

    SSL_CTX_free(ssl->ctx);
}",1,1,event\ngx_event_openssl.c,ngx_ssl_cleanup_ctx,,false,4078,4094,ngx_ssl_cleanup_ctx,,,97,void ngx_ssl_cleanup_ctx (void*)
91339,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_check_host(ngx_connection_t *c, ngx_str_t *name)
{
    X509   *cert;

    cert = SSL_get_peer_certificate(c->ssl->connection);
    if (cert == NULL) {
        return NGX_ERROR;
    }

#ifdef X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT

    /* X509_check_host() is only available in OpenSSL 1.0.2+ */

    if (name->len == 0) {
        goto failed;
    }

    if (X509_check_host(cert, (char *) name->data, name->len, 0, NULL) != 1) {
        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0,
                       ""X509_check_host(): no match"");
        goto failed;
    }

    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0,
                   ""X509_check_host(): match"");

    goto found;

#else
    {
    int                      n, i;
    X509_NAME               *sname;
    ASN1_STRING             *str;
    X509_NAME_ENTRY         *entry;
    GENERAL_NAME            *altname;
    STACK_OF(GENERAL_NAME)  *altnames;

    /*
     * As per RFC6125 and RFC2818, we check subjectAltName ...",1,1,event\ngx_event_openssl.c,ngx_ssl_check_host,,false,4097,4221,ngx_ssl_check_host,,,98,"ngx_int_t ngx_ssl_check_host (ngx_connection_t*,ngx_str_t*)"
91536,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_ssl_check_name(ngx_str_t *name, ASN1_STRING *pattern)
{
    u_char  *s, *p, *end;
    size_t   slen, plen;

    s = name->data;
    slen = name->len;

    p = ASN1_STRING_data(pattern);
    plen = ASN1_STRING_length(pattern);

    if (slen == plen && ngx_strncasecmp(s, p, plen) == 0) {
        return NGX_OK;
    }

    if (plen > 2 && p[0] == '*' && p[1] == '.') {
        plen -= 1;
        p += 1;

        end = s + slen;
        s = ngx_strlchr(s, end, '.');

        if (s == NULL) {
            return NGX_ERROR;
        }

        slen = end - s;

        if (plen == slen && ngx_strncasecmp(s, p, plen) == 0) {
            return NGX_OK;
        }
    }

    return NGX_ERROR;
}",1,1,event\ngx_event_openssl.c,ngx_ssl_check_name,,false,4226,4261,ngx_ssl_check_name,,,99,"ngx_int_t ngx_ssl_check_name (ngx_str_t*,ASN1_STRING*)"
91641,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_get_protocol(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
{
    s->data = (u_char *) SSL_get_version(c->ssl->connection);
    return NGX_OK;
}",1,1,event\ngx_event_openssl.c,ngx_ssl_get_protocol,,false,4266,4271,ngx_ssl_get_protocol,,,100,"ngx_int_t ngx_ssl_get_protocol (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
91662,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_get_cipher_name(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
{
    s->data = (u_char *) SSL_get_cipher_name(c->ssl->connection);
    return NGX_OK;
}",1,1,event\ngx_event_openssl.c,ngx_ssl_get_cipher_name,,false,4274,4279,ngx_ssl_get_cipher_name,,,101,"ngx_int_t ngx_ssl_get_cipher_name (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
91683,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_get_ciphers(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
{
#ifdef SSL_CTRL_GET_RAW_CIPHERLIST

    int                n, i, bytes;
    size_t             len;
    u_char            *ciphers, *p;
    const SSL_CIPHER  *cipher;

    bytes = SSL_get0_raw_cipherlist(c->ssl->connection, NULL);
    n = SSL_get0_raw_cipherlist(c->ssl->connection, &ciphers);

    if (n <= 0) {
        s->len = 0;
        return NGX_OK;
    }

    len = 0;
    n /= bytes;

    for (i = 0; i < n; i++) {
        cipher = SSL_CIPHER_find(c->ssl->connection, ciphers + i * bytes);

        if (cipher) {
            len += ngx_strlen(SSL_CIPHER_get_name(cipher));

        } else {
            len += sizeof(""0x"") - 1 + bytes * (sizeof(""00"") - 1);
        }

        len += sizeof("":"") - 1;
    }

    s->data = ngx_pnalloc(pool, len);
    if (s->data == NULL) {
        return NGX_ERROR;
    }

    p = s->data;

    for (i = 0; i < n; i++) {
        cipher = SSL_CIPHER_find(c->ssl->connection...",1,1,event\ngx_event_openssl.c,ngx_ssl_get_ciphers,,false,4282,4363,ngx_ssl_get_ciphers,,,102,"ngx_int_t ngx_ssl_get_ciphers (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
91746,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_get_curves(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
{
#ifdef SSL_CTRL_GET_CURVES

    int         *curves, n, i, nid;
    u_char      *p;
    size_t       len;

    n = SSL_get1_curves(c->ssl->connection, NULL);

    if (n <= 0) {
        s->len = 0;
        return NGX_OK;
    }

    curves = ngx_palloc(pool, n * sizeof(int));

    n = SSL_get1_curves(c->ssl->connection, curves);
    len = 0;

    for (i = 0; i < n; i++) {
        nid = curves[i];

        if (nid & TLSEXT_nid_unknown) {
            len += sizeof(""0x0000"") - 1;

        } else {
            len += ngx_strlen(OBJ_nid2sn(nid));
        }

        len += sizeof("":"") - 1;
    }

    s->data = ngx_pnalloc(pool, len);
    if (s->data == NULL) {
        return NGX_ERROR;
    }

    p = s->data;

    for (i = 0; i < n; i++) {
        nid = curves[i];

        if (nid & TLSEXT_nid_unknown) {
            p = ngx_sprintf(p, ""0x%04xd"", nid & 0xffff);

        } else {
            p = ngx_sprintf(p,...",1,1,event\ngx_event_openssl.c,ngx_ssl_get_curves,,false,4366,4431,ngx_ssl_get_curves,,,103,"ngx_int_t ngx_ssl_get_curves (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
91760,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_get_session_id(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
{
    u_char        *buf;
    SSL_SESSION   *sess;
    unsigned int   len;

    sess = SSL_get0_session(c->ssl->connection);
    if (sess == NULL) {
        s->len = 0;
        return NGX_OK;
    }

    buf = (u_char *) SSL_SESSION_get_id(sess, &len);

    s->len = 2 * len;
    s->data = ngx_pnalloc(pool, 2 * len);
    if (s->data == NULL) {
        return NGX_ERROR;
    }

    ngx_hex_dump(s->data, buf, len);

    return NGX_OK;
}",1,1,event\ngx_event_openssl.c,ngx_ssl_get_session_id,,false,4434,4458,ngx_ssl_get_session_id,,,104,"ngx_int_t ngx_ssl_get_session_id (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
91831,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_get_session_reused(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
{
    if (SSL_session_reused(c->ssl->connection)) {
        ngx_str_set(s, ""r"");

    } else {
        ngx_str_set(s, ""."");
    }

    return NGX_OK;
}",1,1,event\ngx_event_openssl.c,ngx_ssl_get_session_reused,,false,4461,4472,ngx_ssl_get_session_reused,,,105,"ngx_int_t ngx_ssl_get_session_reused (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
91856,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_get_early_data(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
{
    s->len = 0;

#ifdef SSL_ERROR_EARLY_DATA_REJECTED

    /* BoringSSL */

    if (SSL_in_early_data(c->ssl->connection)) {
        ngx_str_set(s, ""1"");
    }

#elif defined SSL_READ_EARLY_DATA_SUCCESS

    /* OpenSSL */

    if (!SSL_is_init_finished(c->ssl->connection)) {
        ngx_str_set(s, ""1"");
    }

#endif

    return NGX_OK;
}",1,1,event\ngx_event_openssl.c,ngx_ssl_get_early_data,,false,4475,4499,ngx_ssl_get_early_data,,,106,"ngx_int_t ngx_ssl_get_early_data (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
91870,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_get_server_name(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
{
#ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME

    size_t       len;
    const char  *name;

    name = SSL_get_servername(c->ssl->connection, TLSEXT_NAMETYPE_host_name);

    if (name) {
        len = ngx_strlen(name);

        s->len = len;
        s->data = ngx_pnalloc(pool, len);
        if (s->data == NULL) {
            return NGX_ERROR;
        }

        ngx_memcpy(s->data, name, len);

        return NGX_OK;
    }

#endif

    s->len = 0;
    return NGX_OK;
}",1,1,event\ngx_event_openssl.c,ngx_ssl_get_server_name,,false,4502,4530,ngx_ssl_get_server_name,,,107,"ngx_int_t ngx_ssl_get_server_name (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
91884,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_get_raw_certificate(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
{
    size_t   len;
    BIO     *bio;
    X509    *cert;

    s->len = 0;

    cert = SSL_get_peer_certificate(c->ssl->connection);
    if (cert == NULL) {
        return NGX_OK;
    }

    bio = BIO_new(BIO_s_mem());
    if (bio == NULL) {
        ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, ""BIO_new() failed"");
        X509_free(cert);
        return NGX_ERROR;
    }

    if (PEM_write_bio_X509(bio, cert) == 0) {
        ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, ""PEM_write_bio_X509() failed"");
        goto failed;
    }

    len = BIO_pending(bio);
    s->len = len;

    s->data = ngx_pnalloc(pool, len);
    if (s->data == NULL) {
        goto failed;
    }

    BIO_read(bio, s->data, len);

    BIO_free(bio);
    X509_free(cert);

    return NGX_OK;

failed:

    BIO_free(bio);
    X509_free(cert);

    return NGX_ERROR;
}",1,1,event\ngx_event_openssl.c,ngx_ssl_get_raw_certificate,,false,4533,4580,ngx_ssl_get_raw_certificate,,,108,"ngx_int_t ngx_ssl_get_raw_certificate (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
91992,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_get_certificate(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
{
    u_char      *p;
    size_t       len;
    ngx_uint_t   i;
    ngx_str_t    cert;

    if (ngx_ssl_get_raw_certificate(c, pool, &cert) != NGX_OK) {
        return NGX_ERROR;
    }

    if (cert.len == 0) {
        s->len = 0;
        return NGX_OK;
    }

    len = cert.len - 1;

    for (i = 0; i < cert.len - 1; i++) {
        if (cert.data[i] == LF) {
            len++;
        }
    }

    s->len = len;
    s->data = ngx_pnalloc(pool, len);
    if (s->data == NULL) {
        return NGX_ERROR;
    }

    p = s->data;

    for (i = 0; i < cert.len - 1; i++) {
        *p++ = cert.data[i];
        if (cert.data[i] == LF) {
            *p++ = '\t';
        }
    }

    return NGX_OK;
}",1,1,event\ngx_event_openssl.c,ngx_ssl_get_certificate,,false,4583,4624,ngx_ssl_get_certificate,,,109,"ngx_int_t ngx_ssl_get_certificate (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
92127,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_get_escaped_certificate(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s)
{
    ngx_str_t  cert;
    uintptr_t  n;

    if (ngx_ssl_get_raw_certificate(c, pool, &cert) != NGX_OK) {
        return NGX_ERROR;
    }

    if (cert.len == 0) {
        s->len = 0;
        return NGX_OK;
    }

    n = ngx_escape_uri(NULL, cert.data, cert.len, NGX_ESCAPE_URI_COMPONENT);

    s->len = cert.len + n * 2;
    s->data = ngx_pnalloc(pool, s->len);
    if (s->data == NULL) {
        return NGX_ERROR;
    }

    ngx_escape_uri(s->data, cert.data, cert.len, NGX_ESCAPE_URI_COMPONENT);

    return NGX_OK;
}",1,1,event\ngx_event_openssl.c,ngx_ssl_get_escaped_certificate,,false,4627,4654,ngx_ssl_get_escaped_certificate,,,110,"ngx_int_t ngx_ssl_get_escaped_certificate (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
92214,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_get_subject_dn(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
{
    BIO        *bio;
    X509       *cert;
    X509_NAME  *name;

    s->len = 0;

    cert = SSL_get_peer_certificate(c->ssl->connection);
    if (cert == NULL) {
        return NGX_OK;
    }

    name = X509_get_subject_name(cert);
    if (name == NULL) {
        X509_free(cert);
        return NGX_ERROR;
    }

    bio = BIO_new(BIO_s_mem());
    if (bio == NULL) {
        X509_free(cert);
        return NGX_ERROR;
    }

    if (X509_NAME_print_ex(bio, name, 0, XN_FLAG_RFC2253) < 0) {
        goto failed;
    }

    s->len = BIO_pending(bio);
    s->data = ngx_pnalloc(pool, s->len);
    if (s->data == NULL) {
        goto failed;
    }

    BIO_read(bio, s->data, s->len);

    BIO_free(bio);
    X509_free(cert);

    return NGX_OK;

failed:

    BIO_free(bio);
    X509_free(cert);

    return NGX_ERROR;
}",1,1,event\ngx_event_openssl.c,ngx_ssl_get_subject_dn,,false,4657,4706,ngx_ssl_get_subject_dn,,,111,"ngx_int_t ngx_ssl_get_subject_dn (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
92324,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_get_issuer_dn(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
{
    BIO        *bio;
    X509       *cert;
    X509_NAME  *name;

    s->len = 0;

    cert = SSL_get_peer_certificate(c->ssl->connection);
    if (cert == NULL) {
        return NGX_OK;
    }

    name = X509_get_issuer_name(cert);
    if (name == NULL) {
        X509_free(cert);
        return NGX_ERROR;
    }

    bio = BIO_new(BIO_s_mem());
    if (bio == NULL) {
        X509_free(cert);
        return NGX_ERROR;
    }

    if (X509_NAME_print_ex(bio, name, 0, XN_FLAG_RFC2253) < 0) {
        goto failed;
    }

    s->len = BIO_pending(bio);
    s->data = ngx_pnalloc(pool, s->len);
    if (s->data == NULL) {
        goto failed;
    }

    BIO_read(bio, s->data, s->len);

    BIO_free(bio);
    X509_free(cert);

    return NGX_OK;

failed:

    BIO_free(bio);
    X509_free(cert);

    return NGX_ERROR;
}",1,1,event\ngx_event_openssl.c,ngx_ssl_get_issuer_dn,,false,4709,4758,ngx_ssl_get_issuer_dn,,,112,"ngx_int_t ngx_ssl_get_issuer_dn (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
92434,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_get_subject_dn_legacy(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s)
{
    char       *p;
    size_t      len;
    X509       *cert;
    X509_NAME  *name;

    s->len = 0;

    cert = SSL_get_peer_certificate(c->ssl->connection);
    if (cert == NULL) {
        return NGX_OK;
    }

    name = X509_get_subject_name(cert);
    if (name == NULL) {
        X509_free(cert);
        return NGX_ERROR;
    }

    p = X509_NAME_oneline(name, NULL, 0);

    for (len = 0; p[len]; len++) { /* void */ }

    s->len = len;
    s->data = ngx_pnalloc(pool, len);
    if (s->data == NULL) {
        OPENSSL_free(p);
        X509_free(cert);
        return NGX_ERROR;
    }

    ngx_memcpy(s->data, p, len);

    OPENSSL_free(p);
    X509_free(cert);

    return NGX_OK;
}",1,1,event\ngx_event_openssl.c,ngx_ssl_get_subject_dn_legacy,,false,4761,4801,ngx_ssl_get_subject_dn_legacy,,,113,"ngx_int_t ngx_ssl_get_subject_dn_legacy (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
92532,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_get_issuer_dn_legacy(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s)
{
    char       *p;
    size_t      len;
    X509       *cert;
    X509_NAME  *name;

    s->len = 0;

    cert = SSL_get_peer_certificate(c->ssl->connection);
    if (cert == NULL) {
        return NGX_OK;
    }

    name = X509_get_issuer_name(cert);
    if (name == NULL) {
        X509_free(cert);
        return NGX_ERROR;
    }

    p = X509_NAME_oneline(name, NULL, 0);

    for (len = 0; p[len]; len++) { /* void */ }

    s->len = len;
    s->data = ngx_pnalloc(pool, len);
    if (s->data == NULL) {
        OPENSSL_free(p);
        X509_free(cert);
        return NGX_ERROR;
    }

    ngx_memcpy(s->data, p, len);

    OPENSSL_free(p);
    X509_free(cert);

    return NGX_OK;
}",1,1,event\ngx_event_openssl.c,ngx_ssl_get_issuer_dn_legacy,,false,4804,4844,ngx_ssl_get_issuer_dn_legacy,,,114,"ngx_int_t ngx_ssl_get_issuer_dn_legacy (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
92630,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_get_serial_number(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
{
    size_t   len;
    X509    *cert;
    BIO     *bio;

    s->len = 0;

    cert = SSL_get_peer_certificate(c->ssl->connection);
    if (cert == NULL) {
        return NGX_OK;
    }

    bio = BIO_new(BIO_s_mem());
    if (bio == NULL) {
        X509_free(cert);
        return NGX_ERROR;
    }

    i2a_ASN1_INTEGER(bio, X509_get_serialNumber(cert));
    len = BIO_pending(bio);

    s->len = len;
    s->data = ngx_pnalloc(pool, len);
    if (s->data == NULL) {
        BIO_free(bio);
        X509_free(cert);
        return NGX_ERROR;
    }

    BIO_read(bio, s->data, len);
    BIO_free(bio);
    X509_free(cert);

    return NGX_OK;
}",1,1,event\ngx_event_openssl.c,ngx_ssl_get_serial_number,,false,4847,4883,ngx_ssl_get_serial_number,,,115,"ngx_int_t ngx_ssl_get_serial_number (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
92718,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_get_fingerprint(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
{
    X509          *cert;
    unsigned int   len;
    u_char         buf[EVP_MAX_MD_SIZE];

    s->len = 0;

    cert = SSL_get_peer_certificate(c->ssl->connection);
    if (cert == NULL) {
        return NGX_OK;
    }

    if (!X509_digest(cert, EVP_sha1(), buf, &len)) {
        X509_free(cert);
        return NGX_ERROR;
    }

    s->len = 2 * len;
    s->data = ngx_pnalloc(pool, 2 * len);
    if (s->data == NULL) {
        X509_free(cert);
        return NGX_ERROR;
    }

    ngx_hex_dump(s->data, buf, len);

    X509_free(cert);

    return NGX_OK;
}",1,1,event\ngx_event_openssl.c,ngx_ssl_get_fingerprint,,false,4886,4917,ngx_ssl_get_fingerprint,,,116,"ngx_int_t ngx_ssl_get_fingerprint (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
92798,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_get_client_verify(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
{
    X509        *cert;
    long         rc;
    const char  *str;

    cert = SSL_get_peer_certificate(c->ssl->connection);
    if (cert == NULL) {
        ngx_str_set(s, ""NONE"");
        return NGX_OK;
    }

    X509_free(cert);

    rc = SSL_get_verify_result(c->ssl->connection);

    if (rc == X509_V_OK) {
        if (ngx_ssl_ocsp_get_status(c, &str) == NGX_OK) {
            ngx_str_set(s, ""SUCCESS"");
            return NGX_OK;
        }

    } else {
        str = X509_verify_cert_error_string(rc);
    }

    s->data = ngx_pnalloc(pool, sizeof(""FAILED:"") - 1 + ngx_strlen(str));
    if (s->data == NULL) {
        return NGX_ERROR;
    }

    s->len = ngx_sprintf(s->data, ""FAILED:%s"", str) - s->data;

    return NGX_OK;
}",1,1,event\ngx_event_openssl.c,ngx_ssl_get_client_verify,,false,4920,4955,ngx_ssl_get_client_verify,,,117,"ngx_int_t ngx_ssl_get_client_verify (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
92898,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_get_client_v_start(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
{
    BIO     *bio;
    X509    *cert;
    size_t   len;

    s->len = 0;

    cert = SSL_get_peer_certificate(c->ssl->connection);
    if (cert == NULL) {
        return NGX_OK;
    }

    bio = BIO_new(BIO_s_mem());
    if (bio == NULL) {
        X509_free(cert);
        return NGX_ERROR;
    }

#if OPENSSL_VERSION_NUMBER > 0x10100000L
    ASN1_TIME_print(bio, X509_get0_notBefore(cert));
#else
    ASN1_TIME_print(bio, X509_get_notBefore(cert));
#endif

    len = BIO_pending(bio);

    s->len = len;
    s->data = ngx_pnalloc(pool, len);
    if (s->data == NULL) {
        BIO_free(bio);
        X509_free(cert);
        return NGX_ERROR;
    }

    BIO_read(bio, s->data, len);
    BIO_free(bio);
    X509_free(cert);

    return NGX_OK;
}",1,1,event\ngx_event_openssl.c,ngx_ssl_get_client_v_start,,false,4958,4999,ngx_ssl_get_client_v_start,,,118,"ngx_int_t ngx_ssl_get_client_v_start (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
92986,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_get_client_v_end(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
{
    BIO     *bio;
    X509    *cert;
    size_t   len;

    s->len = 0;

    cert = SSL_get_peer_certificate(c->ssl->connection);
    if (cert == NULL) {
        return NGX_OK;
    }

    bio = BIO_new(BIO_s_mem());
    if (bio == NULL) {
        X509_free(cert);
        return NGX_ERROR;
    }

#if OPENSSL_VERSION_NUMBER > 0x10100000L
    ASN1_TIME_print(bio, X509_get0_notAfter(cert));
#else
    ASN1_TIME_print(bio, X509_get_notAfter(cert));
#endif

    len = BIO_pending(bio);

    s->len = len;
    s->data = ngx_pnalloc(pool, len);
    if (s->data == NULL) {
        BIO_free(bio);
        X509_free(cert);
        return NGX_ERROR;
    }

    BIO_read(bio, s->data, len);
    BIO_free(bio);
    X509_free(cert);

    return NGX_OK;
}",1,1,event\ngx_event_openssl.c,ngx_ssl_get_client_v_end,,false,5002,5043,ngx_ssl_get_client_v_end,,,119,"ngx_int_t ngx_ssl_get_client_v_end (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
93074,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_get_client_v_remain(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
{
    X509    *cert;
    time_t   now, end;

    s->len = 0;

    cert = SSL_get_peer_certificate(c->ssl->connection);
    if (cert == NULL) {
        return NGX_OK;
    }

#if OPENSSL_VERSION_NUMBER > 0x10100000L
    end = ngx_ssl_parse_time(X509_get0_notAfter(cert));
#else
    end = ngx_ssl_parse_time(X509_get_notAfter(cert));
#endif

    if (end == (time_t) NGX_ERROR) {
        X509_free(cert);
        return NGX_OK;
    }

    now = ngx_time();

    if (end < now + 86400) {
        ngx_str_set(s, ""0"");
        X509_free(cert);
        return NGX_OK;
    }

    s->data = ngx_pnalloc(pool, NGX_TIME_T_LEN);
    if (s->data == NULL) {
        X509_free(cert);
        return NGX_ERROR;
    }

    s->len = ngx_sprintf(s->data, ""%T"", (end - now) / 86400) - s->data;

    X509_free(cert);

    return NGX_OK;
}",1,1,event\ngx_event_openssl.c,ngx_ssl_get_client_v_remain,,false,5046,5089,ngx_ssl_get_client_v_remain,,,120,"ngx_int_t ngx_ssl_get_client_v_remain (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
93177,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static time_t
ngx_ssl_parse_time(
#if OPENSSL_VERSION_NUMBER > 0x10100000L
    const
#endif
    ASN1_TIME *asn1time)
{
    BIO     *bio;
    char    *value;
    size_t   len;
    time_t   time;

    /*
     * OpenSSL doesn't provide a way to convert ASN1_TIME
     * into time_t.  To do this, we use ASN1_TIME_print(),
     * which uses the ""MMM DD HH:MM:SS YYYY [GMT]"" format (e.g.,
     * ""Feb  3 00:55:52 2015 GMT""), and parse the result.
     */

    bio = BIO_new(BIO_s_mem());
    if (bio == NULL) {
        return NGX_ERROR;
    }

    /* fake weekday prepended to match C asctime() format */

    BIO_write(bio, ""Tue "", sizeof(""Tue "") - 1);
    ASN1_TIME_print(bio, asn1time);
    len = BIO_get_mem_data(bio, &value);

    time = ngx_parse_http_time((u_char *) value, len);

    BIO_free(bio);

    return time;
}",1,1,event\ngx_event_openssl.c,ngx_ssl_parse_time,,false,5092,5127,ngx_ssl_parse_time,,,121,time_t ngx_ssl_parse_time (ASN1_TIME*)
93224,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static void *
ngx_openssl_create_conf(ngx_cycle_t *cycle)
{
    ngx_openssl_conf_t  *oscf;

    oscf = ngx_pcalloc(cycle->pool, sizeof(ngx_openssl_conf_t));
    if (oscf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     oscf->engine = 0;
     */

    return oscf;
}",1,1,event\ngx_event_openssl.c,ngx_openssl_create_conf,,false,5130,5147,ngx_openssl_create_conf,,,122,void* ngx_openssl_create_conf (ngx_cycle_t*)
93247,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static char *
ngx_openssl_engine(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
#ifndef OPENSSL_NO_ENGINE

    ngx_openssl_conf_t *oscf = conf;

    ENGINE     *engine;
    ngx_str_t  *value;

    if (oscf->engine) {
        return ""is duplicate"";
    }

    oscf->engine = 1;

    value = cf->args->elts;

    engine = ENGINE_by_id((char *) value[1].data);

    if (engine == NULL) {
        ngx_ssl_error(NGX_LOG_EMERG, cf->log, 0,
                      ""ENGINE_by_id(\""%V\"") failed"", &value[1]);
        return NGX_CONF_ERROR;
    }

    if (ENGINE_set_default(engine, ENGINE_METHOD_ALL) == 0) {
        ngx_ssl_error(NGX_LOG_EMERG, cf->log, 0,
                      ""ENGINE_set_default(\""%V\"", ENGINE_METHOD_ALL) failed"",
                      &value[1]);

        ENGINE_free(engine);

        return NGX_CONF_ERROR;
    }

    ENGINE_free(engine);

    return NGX_CONF_OK;

#else

    return ""is not supported"";

#endif
}",1,1,event\ngx_event_openssl.c,ngx_openssl_engine,,false,5150,5195,ngx_openssl_engine,,,123,"char* ngx_openssl_engine (ngx_conf_t*,ngx_command_t*,void*)"
93333,METHOD,event\ngx_event_openssl.c:<global>,TYPE_DECL,"static void
ngx_openssl_exit(ngx_cycle_t *cycle)
{
#if OPENSSL_VERSION_NUMBER < 0x10100003L

    EVP_cleanup();
#ifndef OPENSSL_NO_ENGINE
    ENGINE_cleanup();
#endif

#endif
}",1,1,event\ngx_event_openssl.c,ngx_openssl_exit,,false,5198,5209,ngx_openssl_exit,,,124,void ngx_openssl_exit (ngx_cycle_t*)
93375,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,<global>,1,4,event\ngx_event_openssl.h,event\ngx_event_openssl.h:<global>,,false,1,305,<global>,,,1,
93418,METHOD,<empty>,<empty>,<empty>,1,,event\ngx_event_openssl.h,ngx_ssl_sess_id_s:<clinit>,,false,121,,<clinit>,,,9,
93429,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,ngx_int_t ngx_ssl_init(ngx_log_t *log);,11,38,event\ngx_event_openssl.h,ngx_ssl_init,,false,168,168,ngx_ssl_init,,,10,ngx_int_t ngx_ssl_init (ngx_log_t*)
93434,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_create(ngx_ssl_t *ssl, ngx_uint_t protocols, void *data);",11,74,event\ngx_event_openssl.h,ngx_ssl_create,,false,169,169,ngx_ssl_create,,,11,"ngx_int_t ngx_ssl_create (ngx_ssl_t*,ngx_uint_t,void*)"
93441,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_certificates(ngx_conf_t *cf, ngx_ssl_t *ssl,
    ngx_array_t *certs, ngx_array_t *keys, ngx_array_t *passwords);",11,66,event\ngx_event_openssl.h,ngx_ssl_certificates,,false,171,172,ngx_ssl_certificates,,,12,"ngx_int_t ngx_ssl_certificates (ngx_conf_t*,ngx_ssl_t*,ngx_array_t*,ngx_array_t*,ngx_array_t*)"
93450,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl,
    ngx_str_t *cert, ngx_str_t *key, ngx_array_t *passwords);",11,60,event\ngx_event_openssl.h,ngx_ssl_certificate,,false,173,174,ngx_ssl_certificate,,,13,"ngx_int_t ngx_ssl_certificate (ngx_conf_t*,ngx_ssl_t*,ngx_str_t*,ngx_str_t*,ngx_array_t*)"
93459,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_connection_certificate(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *cert, ngx_str_t *key, ngx_array_t *passwords);",11,60,event\ngx_event_openssl.h,ngx_ssl_connection_certificate,,false,175,176,ngx_ssl_connection_certificate,,,14,"ngx_int_t ngx_ssl_connection_certificate (ngx_connection_t*,ngx_pool_t*,ngx_str_t*,ngx_str_t*,ngx_array_t*)"
93468,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_ciphers(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *ciphers,
    ngx_uint_t prefer_server_ciphers);",11,37,event\ngx_event_openssl.h,ngx_ssl_ciphers,,false,178,179,ngx_ssl_ciphers,,,15,"ngx_int_t ngx_ssl_ciphers (ngx_conf_t*,ngx_ssl_t*,ngx_str_t*,ngx_uint_t)"
93476,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_client_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl,
    ngx_str_t *cert, ngx_int_t depth);",11,37,event\ngx_event_openssl.h,ngx_ssl_client_certificate,,false,180,181,ngx_ssl_client_certificate,,,16,"ngx_int_t ngx_ssl_client_certificate (ngx_conf_t*,ngx_ssl_t*,ngx_str_t*,ngx_int_t)"
93484,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_trusted_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl,
    ngx_str_t *cert, ngx_int_t depth);",11,37,event\ngx_event_openssl.h,ngx_ssl_trusted_certificate,,false,182,183,ngx_ssl_trusted_certificate,,,17,"ngx_int_t ngx_ssl_trusted_certificate (ngx_conf_t*,ngx_ssl_t*,ngx_str_t*,ngx_int_t)"
93492,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_crl(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *crl);",11,69,event\ngx_event_openssl.h,ngx_ssl_crl,,false,184,184,ngx_ssl_crl,,,18,"ngx_int_t ngx_ssl_crl (ngx_conf_t*,ngx_ssl_t*,ngx_str_t*)"
93499,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_stapling(ngx_conf_t *cf, ngx_ssl_t *ssl,
    ngx_str_t *file, ngx_str_t *responder, ngx_uint_t verify);",11,61,event\ngx_event_openssl.h,ngx_ssl_stapling,,false,185,186,ngx_ssl_stapling,,,19,"ngx_int_t ngx_ssl_stapling (ngx_conf_t*,ngx_ssl_t*,ngx_str_t*,ngx_str_t*,ngx_uint_t)"
93508,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_stapling_resolver(ngx_conf_t *cf, ngx_ssl_t *ssl,
    ngx_resolver_t *resolver, ngx_msec_t resolver_timeout);",11,58,event\ngx_event_openssl.h,ngx_ssl_stapling_resolver,,false,187,188,ngx_ssl_stapling_resolver,,,20,"ngx_int_t ngx_ssl_stapling_resolver (ngx_conf_t*,ngx_ssl_t*,ngx_resolver_t*,ngx_msec_t)"
93516,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_ocsp(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *responder,
    ngx_uint_t depth, ngx_shm_zone_t *shm_zone);",11,47,event\ngx_event_openssl.h,ngx_ssl_ocsp,,false,189,190,ngx_ssl_ocsp,,,21,"ngx_int_t ngx_ssl_ocsp (ngx_conf_t*,ngx_ssl_t*,ngx_str_t*,ngx_uint_t,ngx_shm_zone_t*)"
93525,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_ocsp_resolver(ngx_conf_t *cf, ngx_ssl_t *ssl,
    ngx_resolver_t *resolver, ngx_msec_t resolver_timeout);",11,58,event\ngx_event_openssl.h,ngx_ssl_ocsp_resolver,,false,191,192,ngx_ssl_ocsp_resolver,,,22,"ngx_int_t ngx_ssl_ocsp_resolver (ngx_conf_t*,ngx_ssl_t*,ngx_resolver_t*,ngx_msec_t)"
93533,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,ngx_int_t ngx_ssl_ocsp_validate(ngx_connection_t *c);,11,52,event\ngx_event_openssl.h,ngx_ssl_ocsp_validate,,false,193,193,ngx_ssl_ocsp_validate,,,23,ngx_int_t ngx_ssl_ocsp_validate (ngx_connection_t*)
93538,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_ocsp_get_status(ngx_connection_t *c, const char **s);",11,70,event\ngx_event_openssl.h,ngx_ssl_ocsp_get_status,,false,194,194,ngx_ssl_ocsp_get_status,,,24,"ngx_int_t ngx_ssl_ocsp_get_status (ngx_connection_t*,char**)"
93544,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,void ngx_ssl_ocsp_cleanup(ngx_connection_t *c);,6,46,event\ngx_event_openssl.h,ngx_ssl_ocsp_cleanup,,false,195,195,ngx_ssl_ocsp_cleanup,,,25,void ngx_ssl_ocsp_cleanup (ngx_connection_t*)
93549,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_ocsp_cache_init(ngx_shm_zone_t *shm_zone, void *data);",11,71,event\ngx_event_openssl.h,ngx_ssl_ocsp_cache_init,,false,196,196,ngx_ssl_ocsp_cache_init,,,26,"ngx_int_t ngx_ssl_ocsp_cache_init (ngx_shm_zone_t*,void*)"
93555,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"RSA *ngx_ssl_rsa512_key_callback(ngx_ssl_conn_t *ssl_conn, int is_export,
    int key_length);",5,33,event\ngx_event_openssl.h,ngx_ssl_rsa512_key_callback,,false,197,198,ngx_ssl_rsa512_key_callback,,,27,"RSA* ngx_ssl_rsa512_key_callback (SSL*,int,int)"
93562,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_array_t *ngx_ssl_read_password_file(ngx_conf_t *cf, ngx_str_t *file);",13,72,event\ngx_event_openssl.h,ngx_ssl_read_password_file,,false,199,199,ngx_ssl_read_password_file,,,28,"ngx_array_t* ngx_ssl_read_password_file (ngx_conf_t*,ngx_str_t*)"
93568,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_array_t *ngx_ssl_preserve_passwords(ngx_conf_t *cf,
    ngx_array_t *passwords);",13,27,event\ngx_event_openssl.h,ngx_ssl_preserve_passwords,,false,200,201,ngx_ssl_preserve_passwords,,,29,"ngx_array_t* ngx_ssl_preserve_passwords (ngx_conf_t*,ngx_array_t*)"
93574,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_dhparam(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *file);",11,74,event\ngx_event_openssl.h,ngx_ssl_dhparam,,false,202,202,ngx_ssl_dhparam,,,30,"ngx_int_t ngx_ssl_dhparam (ngx_conf_t*,ngx_ssl_t*,ngx_str_t*)"
93581,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_ecdh_curve(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *name);",11,77,event\ngx_event_openssl.h,ngx_ssl_ecdh_curve,,false,203,203,ngx_ssl_ecdh_curve,,,31,"ngx_int_t ngx_ssl_ecdh_curve (ngx_conf_t*,ngx_ssl_t*,ngx_str_t*)"
93588,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_early_data(ngx_conf_t *cf, ngx_ssl_t *ssl,
    ngx_uint_t enable);",11,22,event\ngx_event_openssl.h,ngx_ssl_early_data,,false,204,205,ngx_ssl_early_data,,,32,"ngx_int_t ngx_ssl_early_data (ngx_conf_t*,ngx_ssl_t*,ngx_uint_t)"
93595,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_client_session_cache(ngx_conf_t *cf, ngx_ssl_t *ssl,
    ngx_uint_t enable);",11,22,event\ngx_event_openssl.h,ngx_ssl_client_session_cache,,false,206,207,ngx_ssl_client_session_cache,,,33,"ngx_int_t ngx_ssl_client_session_cache (ngx_conf_t*,ngx_ssl_t*,ngx_uint_t)"
93602,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_session_cache(ngx_ssl_t *ssl, ngx_str_t *sess_ctx,
    ngx_array_t *certificates, ssize_t builtin_session_cache,
    ngx_shm_zone_t *shm_zone, time_t timeout);",11,45,event\ngx_event_openssl.h,ngx_ssl_session_cache,,false,208,210,ngx_ssl_session_cache,,,34,"ngx_int_t ngx_ssl_session_cache (ngx_ssl_t*,ngx_str_t*,ngx_array_t*,ssize_t,ngx_shm_zone_t*,time_t)"
93612,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_session_ticket_keys(ngx_conf_t *cf, ngx_ssl_t *ssl,
    ngx_array_t *paths);",11,23,event\ngx_event_openssl.h,ngx_ssl_session_ticket_keys,,false,211,212,ngx_ssl_session_ticket_keys,,,35,"ngx_int_t ngx_ssl_session_ticket_keys (ngx_conf_t*,ngx_ssl_t*,ngx_array_t*)"
93619,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_session_cache_init(ngx_shm_zone_t *shm_zone, void *data);",11,74,event\ngx_event_openssl.h,ngx_ssl_session_cache_init,,false,213,213,ngx_ssl_session_cache_init,,,36,"ngx_int_t ngx_ssl_session_cache_init (ngx_shm_zone_t*,void*)"
93625,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_create_connection(ngx_ssl_t *ssl, ngx_connection_t *c,
    ngx_uint_t flags);",11,21,event\ngx_event_openssl.h,ngx_ssl_create_connection,,false,214,215,ngx_ssl_create_connection,,,37,"ngx_int_t ngx_ssl_create_connection (ngx_ssl_t*,ngx_connection_t*,ngx_uint_t)"
93632,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"void ngx_ssl_remove_cached_session(SSL_CTX *ssl, ngx_ssl_session_t *sess);",6,49,event\ngx_event_openssl.h,ngx_ssl_remove_cached_session,,false,217,217,ngx_ssl_remove_cached_session,,,38,"void ngx_ssl_remove_cached_session (SSL_CTX*,SSL_SESSION*)"
93638,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_set_session(ngx_connection_t *c, ngx_ssl_session_t *session);",11,51,event\ngx_event_openssl.h,ngx_ssl_set_session,,false,218,218,ngx_ssl_set_session,,,39,"ngx_int_t ngx_ssl_set_session (ngx_connection_t*,SSL_SESSION*)"
93644,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,SSL_SESSION SSL_SESSION *(ngx_connection_t *);,19,59,event\ngx_event_openssl.h,ngx_ssl_get_session,,false,219,219,ngx_ssl_get_session,,,40,SSL_SESSION* ngx_ssl_get_session (ngx_connection_t*)
93649,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,SSL_SESSION SSL_SESSION *(ngx_connection_t *);,19,60,event\ngx_event_openssl.h,ngx_ssl_get0_session,,false,220,220,ngx_ssl_get0_session,,,41,SSL_SESSION* ngx_ssl_get0_session (ngx_connection_t*)
93654,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_check_host(ngx_connection_t *c, ngx_str_t *name);",11,66,event\ngx_event_openssl.h,ngx_ssl_check_host,,false,234,234,ngx_ssl_check_host,,,42,"ngx_int_t ngx_ssl_check_host (ngx_connection_t*,ngx_str_t*)"
93660,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_get_protocol(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);",11,17,event\ngx_event_openssl.h,ngx_ssl_get_protocol,,false,237,238,ngx_ssl_get_protocol,,,43,"ngx_int_t ngx_ssl_get_protocol (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
93667,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_get_cipher_name(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);",11,17,event\ngx_event_openssl.h,ngx_ssl_get_cipher_name,,false,239,240,ngx_ssl_get_cipher_name,,,44,"ngx_int_t ngx_ssl_get_cipher_name (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
93674,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_get_ciphers(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);",11,17,event\ngx_event_openssl.h,ngx_ssl_get_ciphers,,false,241,242,ngx_ssl_get_ciphers,,,45,"ngx_int_t ngx_ssl_get_ciphers (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
93681,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_get_curves(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);",11,17,event\ngx_event_openssl.h,ngx_ssl_get_curves,,false,243,244,ngx_ssl_get_curves,,,46,"ngx_int_t ngx_ssl_get_curves (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
93688,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_get_session_id(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);",11,17,event\ngx_event_openssl.h,ngx_ssl_get_session_id,,false,245,246,ngx_ssl_get_session_id,,,47,"ngx_int_t ngx_ssl_get_session_id (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
93695,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_get_session_reused(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);",11,17,event\ngx_event_openssl.h,ngx_ssl_get_session_reused,,false,247,248,ngx_ssl_get_session_reused,,,48,"ngx_int_t ngx_ssl_get_session_reused (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
93702,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_get_early_data(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);",11,17,event\ngx_event_openssl.h,ngx_ssl_get_early_data,,false,249,250,ngx_ssl_get_early_data,,,49,"ngx_int_t ngx_ssl_get_early_data (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
93709,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_get_server_name(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);",11,17,event\ngx_event_openssl.h,ngx_ssl_get_server_name,,false,251,252,ngx_ssl_get_server_name,,,50,"ngx_int_t ngx_ssl_get_server_name (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
93716,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_get_raw_certificate(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);",11,17,event\ngx_event_openssl.h,ngx_ssl_get_raw_certificate,,false,253,254,ngx_ssl_get_raw_certificate,,,51,"ngx_int_t ngx_ssl_get_raw_certificate (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
93723,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_get_certificate(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);",11,17,event\ngx_event_openssl.h,ngx_ssl_get_certificate,,false,255,256,ngx_ssl_get_certificate,,,52,"ngx_int_t ngx_ssl_get_certificate (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
93730,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_get_escaped_certificate(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);",11,17,event\ngx_event_openssl.h,ngx_ssl_get_escaped_certificate,,false,257,258,ngx_ssl_get_escaped_certificate,,,53,"ngx_int_t ngx_ssl_get_escaped_certificate (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
93737,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_get_subject_dn(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);",11,17,event\ngx_event_openssl.h,ngx_ssl_get_subject_dn,,false,259,260,ngx_ssl_get_subject_dn,,,54,"ngx_int_t ngx_ssl_get_subject_dn (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
93744,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_get_issuer_dn(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);",11,17,event\ngx_event_openssl.h,ngx_ssl_get_issuer_dn,,false,261,262,ngx_ssl_get_issuer_dn,,,55,"ngx_int_t ngx_ssl_get_issuer_dn (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
93751,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_get_subject_dn_legacy(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);",11,17,event\ngx_event_openssl.h,ngx_ssl_get_subject_dn_legacy,,false,263,264,ngx_ssl_get_subject_dn_legacy,,,56,"ngx_int_t ngx_ssl_get_subject_dn_legacy (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
93758,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_get_issuer_dn_legacy(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);",11,17,event\ngx_event_openssl.h,ngx_ssl_get_issuer_dn_legacy,,false,265,266,ngx_ssl_get_issuer_dn_legacy,,,57,"ngx_int_t ngx_ssl_get_issuer_dn_legacy (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
93765,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_get_serial_number(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);",11,17,event\ngx_event_openssl.h,ngx_ssl_get_serial_number,,false,267,268,ngx_ssl_get_serial_number,,,58,"ngx_int_t ngx_ssl_get_serial_number (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
93772,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_get_fingerprint(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);",11,17,event\ngx_event_openssl.h,ngx_ssl_get_fingerprint,,false,269,270,ngx_ssl_get_fingerprint,,,59,"ngx_int_t ngx_ssl_get_fingerprint (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
93779,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_get_client_verify(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);",11,17,event\ngx_event_openssl.h,ngx_ssl_get_client_verify,,false,271,272,ngx_ssl_get_client_verify,,,60,"ngx_int_t ngx_ssl_get_client_verify (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
93786,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_get_client_v_start(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);",11,17,event\ngx_event_openssl.h,ngx_ssl_get_client_v_start,,false,273,274,ngx_ssl_get_client_v_start,,,61,"ngx_int_t ngx_ssl_get_client_v_start (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
93793,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_get_client_v_end(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);",11,17,event\ngx_event_openssl.h,ngx_ssl_get_client_v_end,,false,275,276,ngx_ssl_get_client_v_end,,,62,"ngx_int_t ngx_ssl_get_client_v_end (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
93800,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_int_t ngx_ssl_get_client_v_remain(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);",11,17,event\ngx_event_openssl.h,ngx_ssl_get_client_v_remain,,false,277,278,ngx_ssl_get_client_v_remain,,,63,"ngx_int_t ngx_ssl_get_client_v_remain (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
93807,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,ngx_int_t ngx_ssl_handshake(ngx_connection_t *c);,11,48,event\ngx_event_openssl.h,ngx_ssl_handshake,,false,281,281,ngx_ssl_handshake,,,64,ngx_int_t ngx_ssl_handshake (ngx_connection_t*)
93812,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ssize_t ngx_ssl_recv(ngx_connection_t *c, u_char *buf, size_t size);",9,67,event\ngx_event_openssl.h,ngx_ssl_recv,,false,282,282,ngx_ssl_recv,,,65,"ssize_t ngx_ssl_recv (ngx_connection_t*,u_char*,size_t)"
93819,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ssize_t ngx_ssl_write(ngx_connection_t *c, u_char *data, size_t size);",9,69,event\ngx_event_openssl.h,ngx_ssl_write,,false,283,283,ngx_ssl_write,,,66,"ssize_t ngx_ssl_write (ngx_connection_t*,u_char*,size_t)"
93826,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ssize_t ngx_ssl_recv_chain(ngx_connection_t *c, ngx_chain_t *cl, off_t limit);",9,77,event\ngx_event_openssl.h,ngx_ssl_recv_chain,,false,284,284,ngx_ssl_recv_chain,,,67,"ssize_t ngx_ssl_recv_chain (ngx_connection_t*,ngx_chain_t*,off_t)"
93833,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,"ngx_chain_t *ngx_ssl_send_chain(ngx_connection_t *c, ngx_chain_t *in,
    off_t limit);",13,16,event\ngx_event_openssl.h,ngx_ssl_send_chain,,false,285,286,ngx_ssl_send_chain,,,68,"ngx_chain_t* ngx_ssl_send_chain (ngx_connection_t*,ngx_chain_t*,off_t)"
93840,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,void ngx_ssl_free_buffer(ngx_connection_t *c);,6,45,event\ngx_event_openssl.h,ngx_ssl_free_buffer,,false,287,287,ngx_ssl_free_buffer,,,69,void ngx_ssl_free_buffer (ngx_connection_t*)
93845,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,ngx_int_t ngx_ssl_shutdown(ngx_connection_t *c);,11,47,event\ngx_event_openssl.h,ngx_ssl_shutdown,,false,288,288,ngx_ssl_shutdown,,,70,ngx_int_t ngx_ssl_shutdown (ngx_connection_t*)
93851,METHOD,event\ngx_event_openssl.h:<global>,TYPE_DECL,void ngx_ssl_cleanup_ctx(void *data);,6,36,event\ngx_event_openssl.h,ngx_ssl_cleanup_ctx,,false,291,291,ngx_ssl_cleanup_ctx,,,72,void ngx_ssl_cleanup_ctx (void*)
93876,METHOD,event\ngx_event_openssl_stapling.c:<global>,TYPE_DECL,<global>,1,6,event\ngx_event_openssl_stapling.c,event\ngx_event_openssl_stapling.c:<global>,,false,1,2778,<global>,,,1,
93878,METHOD,event\ngx_event_openssl_stapling.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_stapling(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *file,
    ngx_str_t *responder, ngx_uint_t verify)
{
    ngx_log_error(NGX_LOG_WARN, ssl->log, 0,
                  ""\""ssl_stapling\"" ignored, not supported"");

    return NGX_OK;
}",1,1,event\ngx_event_openssl_stapling.c,ngx_ssl_stapling,,false,2713,2721,ngx_ssl_stapling,,,1,"ngx_int_t ngx_ssl_stapling (ngx_conf_t*,ngx_ssl_t*,ngx_str_t*,ngx_str_t*,ngx_uint_t)"
93896,METHOD,event\ngx_event_openssl_stapling.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_stapling_resolver(ngx_conf_t *cf, ngx_ssl_t *ssl,
    ngx_resolver_t *resolver, ngx_msec_t resolver_timeout)
{
    return NGX_OK;
}",1,1,event\ngx_event_openssl_stapling.c,ngx_ssl_stapling_resolver,,false,2724,2729,ngx_ssl_stapling_resolver,,,2,"ngx_int_t ngx_ssl_stapling_resolver (ngx_conf_t*,ngx_ssl_t*,ngx_resolver_t*,ngx_msec_t)"
93906,METHOD,event\ngx_event_openssl_stapling.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_ocsp(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *responder,
    ngx_uint_t depth, ngx_shm_zone_t *shm_zone)
{
    ngx_log_error(NGX_LOG_EMERG, ssl->log, 0,
                  ""\""ssl_ocsp\"" is not supported on this platform"");

    return NGX_ERROR;
}",1,1,event\ngx_event_openssl_stapling.c,ngx_ssl_ocsp,,false,2732,2740,ngx_ssl_ocsp,,,3,"ngx_int_t ngx_ssl_ocsp (ngx_conf_t*,ngx_ssl_t*,ngx_str_t*,ngx_uint_t,ngx_shm_zone_t*)"
93924,METHOD,event\ngx_event_openssl_stapling.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_ocsp_resolver(ngx_conf_t *cf, ngx_ssl_t *ssl,
    ngx_resolver_t *resolver, ngx_msec_t resolver_timeout)
{
    return NGX_OK;
}",1,1,event\ngx_event_openssl_stapling.c,ngx_ssl_ocsp_resolver,,false,2743,2748,ngx_ssl_ocsp_resolver,,,4,"ngx_int_t ngx_ssl_ocsp_resolver (ngx_conf_t*,ngx_ssl_t*,ngx_resolver_t*,ngx_msec_t)"
93934,METHOD,event\ngx_event_openssl_stapling.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_ocsp_validate(ngx_connection_t *c)
{
    return NGX_OK;
}",1,1,event\ngx_event_openssl_stapling.c,ngx_ssl_ocsp_validate,,false,2751,2755,ngx_ssl_ocsp_validate,,,5,ngx_int_t ngx_ssl_ocsp_validate (ngx_connection_t*)
93941,METHOD,event\ngx_event_openssl_stapling.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_ocsp_get_status(ngx_connection_t *c, const char **s)
{
    return NGX_OK;
}",1,1,event\ngx_event_openssl_stapling.c,ngx_ssl_ocsp_get_status,,false,2758,2762,ngx_ssl_ocsp_get_status,,,6,"ngx_int_t ngx_ssl_ocsp_get_status (ngx_connection_t*,char**)"
93949,METHOD,event\ngx_event_openssl_stapling.c:<global>,TYPE_DECL,"void
ngx_ssl_ocsp_cleanup(ngx_connection_t *c)
{
}",1,1,event\ngx_event_openssl_stapling.c,ngx_ssl_ocsp_cleanup,,false,2765,2768,ngx_ssl_ocsp_cleanup,,,7,void ngx_ssl_ocsp_cleanup (ngx_connection_t*)
93954,METHOD,event\ngx_event_openssl_stapling.c:<global>,TYPE_DECL,"ngx_int_t
ngx_ssl_ocsp_cache_init(ngx_shm_zone_t *shm_zone, void *data)
{
    return NGX_OK;
}",1,1,event\ngx_event_openssl_stapling.c,ngx_ssl_ocsp_cache_init,,false,2771,2775,ngx_ssl_ocsp_cache_init,,,8,"ngx_int_t ngx_ssl_ocsp_cache_init (ngx_shm_zone_t*,void*)"
93973,METHOD,event\ngx_event_pipe.c:<global>,TYPE_DECL,<global>,1,1,event\ngx_event_pipe.c,event\ngx_event_pipe.c:<global>,,false,1,1114,<global>,,,1,
93975,METHOD,event\ngx_event_pipe.c:<global>,TYPE_DECL,static ngx_int_t ngx_event_pipe_read_upstream(ngx_event_pipe_t *p);,18,66,event\ngx_event_pipe.c,ngx_event_pipe_read_upstream,,false,14,14,ngx_event_pipe_read_upstream,,,1,ngx_int_t ngx_event_pipe_read_upstream (ngx_event_pipe_t*)
93980,METHOD,event\ngx_event_pipe.c:<global>,TYPE_DECL,static ngx_int_t ngx_event_pipe_write_to_downstream(ngx_event_pipe_t *p);,18,72,event\ngx_event_pipe.c,ngx_event_pipe_write_to_downstream,,false,15,15,ngx_event_pipe_write_to_downstream,,,2,ngx_int_t ngx_event_pipe_write_to_downstream (ngx_event_pipe_t*)
93985,METHOD,event\ngx_event_pipe.c:<global>,TYPE_DECL,static ngx_int_t ngx_event_pipe_write_chain_to_temp_file(ngx_event_pipe_t *p);,18,77,event\ngx_event_pipe.c,ngx_event_pipe_write_chain_to_temp_file,,false,17,17,ngx_event_pipe_write_chain_to_temp_file,,,3,ngx_int_t ngx_event_pipe_write_chain_to_temp_file (ngx_event_pipe_t*)
93991,METHOD,event\ngx_event_pipe.c:<global>,TYPE_DECL,static ngx_int_t ngx_event_pipe_drain_chains(ngx_event_pipe_t *p);,18,65,event\ngx_event_pipe.c,ngx_event_pipe_drain_chains,,false,19,19,ngx_event_pipe_drain_chains,,,5,ngx_int_t ngx_event_pipe_drain_chains (ngx_event_pipe_t*)
93996,METHOD,event\ngx_event_pipe.c:<global>,TYPE_DECL,"ngx_int_t
ngx_event_pipe(ngx_event_pipe_t *p, ngx_int_t do_write)
{
    ngx_int_t     rc;
    ngx_uint_t    flags;
    ngx_event_t  *rev, *wev;

    for ( ;; ) {
        if (do_write) {
            p->log->action = ""sending to client"";

            rc = ngx_event_pipe_write_to_downstream(p);

            if (rc == NGX_ABORT) {
                return NGX_ABORT;
            }

            if (rc == NGX_BUSY) {
                return NGX_OK;
            }
        }

        p->read = 0;
        p->upstream_blocked = 0;

        p->log->action = ""reading upstream"";

        if (ngx_event_pipe_read_upstream(p) == NGX_ABORT) {
            return NGX_ABORT;
        }

        if (!p->read && !p->upstream_blocked) {
            break;
        }

        do_write = 1;
    }

    if (p->upstream->fd != (ngx_socket_t) -1) {
        rev = p->upstream->read;

        flags = (rev->eof || rev->error) ? NGX_CLOSE_EVENT : 0;

        if (ngx_handle_read_event(rev, flags) != NGX_OK) {
            re...",1,1,event\ngx_event_pipe.c,ngx_event_pipe,,false,22,98,ngx_event_pipe,,,6,"ngx_int_t ngx_event_pipe (ngx_event_pipe_t*,ngx_int_t)"
94217,METHOD,event\ngx_event_pipe.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_event_pipe_read_upstream(ngx_event_pipe_t *p)
{
    off_t         limit;
    ssize_t       n, size;
    ngx_int_t     rc;
    ngx_buf_t    *b;
    ngx_msec_t    delay;
    ngx_chain_t  *chain, *cl, *ln;

    if (p->upstream_eof || p->upstream_error || p->upstream_done) {
        return NGX_OK;
    }

#if (NGX_THREADS)

    if (p->aio) {
        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, p->log, 0,
                       ""pipe read upstream: aio"");
        return NGX_AGAIN;
    }

    if (p->writing) {
        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, p->log, 0,
                       ""pipe read upstream: writing"");

        rc = ngx_event_pipe_write_chain_to_temp_file(p);

        if (rc != NGX_OK) {
            return rc;
        }
    }

#endif

    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, p->log, 0,
                   ""pipe read upstream: %d"", p->upstream->read->ready);

    for ( ;; ) {

        if (p->upstream_eof || p->upstream_error || p->upstream_done) {
            break...",1,1,event\ngx_event_pipe.c,ngx_event_pipe_read_upstream,,false,101,498,ngx_event_pipe_read_upstream,,,7,ngx_int_t ngx_event_pipe_read_upstream (ngx_event_pipe_t*)
95100,METHOD,event\ngx_event_pipe.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_event_pipe_write_to_downstream(ngx_event_pipe_t *p)
{
    u_char            *prev;
    size_t             bsize;
    ngx_int_t          rc;
    ngx_uint_t         flush, flushed, prev_last_shadow;
    ngx_chain_t       *out, **ll, *cl;
    ngx_connection_t  *downstream;

    downstream = p->downstream;

    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, p->log, 0,
                   ""pipe write downstream: %d"", downstream->write->ready);

#if (NGX_THREADS)

    if (p->writing) {
        rc = ngx_event_pipe_write_chain_to_temp_file(p);

        if (rc == NGX_ABORT) {
            return NGX_ABORT;
        }
    }

#endif

    flushed = 0;

    for ( ;; ) {
        if (p->downstream_error) {
            return ngx_event_pipe_drain_chains(p);
        }

        if (p->upstream_eof || p->upstream_error || p->upstream_done) {

            /* pass the p->out and p->in chains to the output filter */

            for (cl = p->busy; cl; cl = cl->next) {
                cl->buf->recy...",1,1,event\ngx_event_pipe.c,ngx_event_pipe_write_to_downstream,,false,501,734,ngx_event_pipe_write_to_downstream,,,8,ngx_int_t ngx_event_pipe_write_to_downstream (ngx_event_pipe_t*)
95767,METHOD,event\ngx_event_pipe.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_event_pipe_write_chain_to_temp_file(ngx_event_pipe_t *p)
{
    ssize_t       size, bsize, n;
    ngx_buf_t    *b;
    ngx_uint_t    prev_last_shadow;
    ngx_chain_t  *cl, *tl, *next, *out, **ll, **last_out, **last_free;

#if (NGX_THREADS)

    if (p->writing) {

        if (p->aio) {
            return NGX_AGAIN;
        }

        out = p->writing;
        p->writing = NULL;

        n = ngx_write_chain_to_temp_file(p->temp_file, NULL);

        if (n == NGX_ERROR) {
            return NGX_ABORT;
        }

        goto done;
    }

#endif

    if (p->buf_to_file) {
        out = ngx_alloc_chain_link(p->pool);
        if (out == NULL) {
            return NGX_ABORT;
        }

        out->buf = p->buf_to_file;
        out->next = p->in;

    } else {
        out = p->in;
    }

    if (!p->cacheable) {

        size = 0;
        cl = out;
        ll = NULL;
        prev_last_shadow = 1;

        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, p->log, 0,
                 ...",1,1,event\ngx_event_pipe.c,ngx_event_pipe_write_chain_to_temp_file,,false,737,948,ngx_event_pipe_write_chain_to_temp_file,,,9,ngx_int_t ngx_event_pipe_write_chain_to_temp_file (ngx_event_pipe_t*)
96331,METHOD,event\ngx_event_pipe.c:<global>,TYPE_DECL,"ngx_int_t
ngx_event_pipe_copy_input_filter(ngx_event_pipe_t *p, ngx_buf_t *buf)
{
    ngx_buf_t    *b;
    ngx_chain_t  *cl;

    if (buf->pos == buf->last) {
        return NGX_OK;
    }

    cl = ngx_chain_get_free_buf(p->pool, &p->free);
    if (cl == NULL) {
        return NGX_ERROR;
    }

    b = cl->buf;

    ngx_memcpy(b, buf, sizeof(ngx_buf_t));
    b->shadow = buf;
    b->tag = p->tag;
    b->last_shadow = 1;
    b->recycled = 1;
    buf->shadow = b;

    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, p->log, 0, ""input buf #%d"", b->num);

    if (p->in) {
        *p->last_in = cl;
    } else {
        p->in = cl;
    }
    p->last_in = &cl->next;

    if (p->length == -1) {
        return NGX_OK;
    }

    p->length -= b->last - b->pos;

    return NGX_OK;
}",1,1,event\ngx_event_pipe.c,ngx_event_pipe_copy_input_filter,,false,953,993,ngx_event_pipe_copy_input_filter,,,10,"ngx_int_t ngx_event_pipe_copy_input_filter (ngx_event_pipe_t*,ngx_buf_t*)"
96464,METHOD,event\ngx_event_pipe.c:<global>,TYPE_DECL,"ngx_int_t
ngx_event_pipe_add_free_buf(ngx_event_pipe_t *p, ngx_buf_t *b)
{
    ngx_chain_t  *cl;

    cl = ngx_alloc_chain_link(p->pool);
    if (cl == NULL) {
        return NGX_ERROR;
    }

    if (p->buf_to_file && b->start == p->buf_to_file->start) {
        b->pos = p->buf_to_file->last;
        b->last = p->buf_to_file->last;

    } else {
        b->pos = b->start;
        b->last = b->start;
    }

    b->shadow = NULL;

    cl->buf = b;

    if (p->free_raw_bufs == NULL) {
        p->free_raw_bufs = cl;
        cl->next = NULL;

        return NGX_OK;
    }

    if (p->free_raw_bufs->buf->pos == p->free_raw_bufs->buf->last) {

        /* add the free buf to the list start */

        cl->next = p->free_raw_bufs;
        p->free_raw_bufs = cl;

        return NGX_OK;
    }

    /* the first free buf is partially filled, thus add the free buf after it */

    cl->next = p->free_raw_bufs->next;
    p->free_raw_bufs->next = cl;

    return NGX_OK;
}",1,1,event\ngx_event_pipe.c,ngx_event_pipe_add_free_buf,,false,1027,1073,ngx_event_pipe_add_free_buf,,,12,"ngx_int_t ngx_event_pipe_add_free_buf (ngx_event_pipe_t*,ngx_buf_t*)"
96611,METHOD,event\ngx_event_pipe.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_event_pipe_drain_chains(ngx_event_pipe_t *p)
{
    ngx_chain_t  *cl, *tl;

    for ( ;; ) {
        if (p->busy) {
            cl = p->busy;
            p->busy = NULL;

        } else if (p->out) {
            cl = p->out;
            p->out = NULL;

        } else if (p->in) {
            cl = p->in;
            p->in = NULL;

        } else {
            return NGX_OK;
        }

        while (cl) {
            if (cl->buf->last_shadow) {
                if (ngx_event_pipe_add_free_buf(p, cl->buf->shadow) != NGX_OK) {
                    return NGX_ABORT;
                }

                cl->buf->last_shadow = 0;
            }

            cl->buf->shadow = NULL;
            tl = cl->next;
            cl->next = p->free;
            p->free = cl;
            cl = tl;
        }
    }
}",1,1,event\ngx_event_pipe.c,ngx_event_pipe_drain_chains,,false,1076,1114,ngx_event_pipe_drain_chains,,,13,ngx_int_t ngx_event_pipe_drain_chains (ngx_event_pipe_t*)
96740,METHOD,event\ngx_event_pipe.h:<global>,TYPE_DECL,<global>,1,40,event\ngx_event_pipe.h,event\ngx_event_pipe.h:<global>,,false,1,107,<global>,,,1,
96744,METHOD,event\ngx_event_pipe.h:<global>,TYPE_DECL,"typedef ngx_int_t (*ngx_event_pipe_input_filter_pt)(ngx_event_pipe_t *p,
                                                    ngx_buf_t *buf);",19,67,event\ngx_event_pipe.h,ngx_event_pipe_input_filter_pt,,false,19,20,ngx_event_pipe_input_filter_pt,,,3,"ngx_int_t ngx_event_pipe_input_filter_pt (ngx_event_pipe_t*,ngx_buf_t*)"
96750,METHOD,event\ngx_event_pipe.h:<global>,TYPE_DECL,"typedef ngx_int_t (*ngx_event_pipe_output_filter_pt)(void *data,
                                                     ngx_chain_t *chain);",19,72,event\ngx_event_pipe.h,ngx_event_pipe_output_filter_pt,,false,21,22,ngx_event_pipe_output_filter_pt,,,4,"ngx_int_t ngx_event_pipe_output_filter_pt (void*,ngx_chain_t*)"
96770,METHOD,ngx_event_pipe_s,TYPE_DECL,"ngx_int_t                       (*thread_handler)(ngx_thread_task_t *task,
                                                      ngx_file_t *file);",37,71,event\ngx_event_pipe.h,ngx_event_pipe_s.thread_handler,,false,51,52,thread_handler,,,14,"ngx_int_t ngx_event_pipe_s.thread_handler (ngx_thread_task_t*,ngx_file_t*)"
96810,METHOD,event\ngx_event_pipe.h:<global>,TYPE_DECL,"ngx_int_t ngx_event_pipe(ngx_event_pipe_t *p, ngx_int_t do_write);",11,65,event\ngx_event_pipe.h,ngx_event_pipe,,false,102,102,ngx_event_pipe,,,6,"ngx_int_t ngx_event_pipe (ngx_event_pipe_t*,ngx_int_t)"
96816,METHOD,event\ngx_event_pipe.h:<global>,TYPE_DECL,"ngx_int_t ngx_event_pipe_copy_input_filter(ngx_event_pipe_t *p, ngx_buf_t *buf);",11,79,event\ngx_event_pipe.h,ngx_event_pipe_copy_input_filter,,false,103,103,ngx_event_pipe_copy_input_filter,,,7,"ngx_int_t ngx_event_pipe_copy_input_filter (ngx_event_pipe_t*,ngx_buf_t*)"
96822,METHOD,event\ngx_event_pipe.h:<global>,TYPE_DECL,"ngx_int_t ngx_event_pipe_add_free_buf(ngx_event_pipe_t *p, ngx_buf_t *b);",11,72,event\ngx_event_pipe.h,ngx_event_pipe_add_free_buf,,false,104,104,ngx_event_pipe_add_free_buf,,,8,"ngx_int_t ngx_event_pipe_add_free_buf (ngx_event_pipe_t*,ngx_buf_t*)"
96837,METHOD,event\ngx_event_posted.c:<global>,TYPE_DECL,<global>,1,1,event\ngx_event_posted.c,event\ngx_event_posted.c:<global>,,false,1,60,<global>,,,1,
96842,METHOD,event\ngx_event_posted.c:<global>,TYPE_DECL,"void
ngx_event_process_posted(ngx_cycle_t *cycle, ngx_queue_t *posted)
{
    ngx_queue_t  *q;
    ngx_event_t  *ev;

    while (!ngx_queue_empty(posted)) {

        q = ngx_queue_head(posted);
        ev = ngx_queue_data(q, ngx_event_t, queue);

        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
                      ""posted event %p"", ev);

        ngx_delete_posted_event(ev);

        ev->handler(ev);
    }
}",1,1,event\ngx_event_posted.c,ngx_event_process_posted,,false,18,36,ngx_event_process_posted,,,4,"void ngx_event_process_posted (ngx_cycle_t*,ngx_queue_t*)"
96880,METHOD,event\ngx_event_posted.c:<global>,TYPE_DECL,"void
ngx_event_move_posted_next(ngx_cycle_t *cycle)
{
    ngx_queue_t  *q;
    ngx_event_t  *ev;

    for (q = ngx_queue_head(&ngx_posted_next_events);
         q != ngx_queue_sentinel(&ngx_posted_next_events);
         q = ngx_queue_next(q))
    {
        ev = ngx_queue_data(q, ngx_event_t, queue);

        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
                      ""posted next event %p"", ev);

        ev->ready = 1;
        ev->available = -1;
    }

    ngx_queue_add(&ngx_posted_events, &ngx_posted_next_events);
    ngx_queue_init(&ngx_posted_next_events);
}",1,1,event\ngx_event_posted.c,ngx_event_move_posted_next,,false,39,60,ngx_event_move_posted_next,,,5,void ngx_event_move_posted_next (ngx_cycle_t*)
96946,METHOD,event\ngx_event_posted.h:<global>,TYPE_DECL,<global>,1,42,event\ngx_event_posted.h,event\ngx_event_posted.h:<global>,,false,1,50,<global>,,,1,
96948,METHOD,event\ngx_event_posted.h:<global>,TYPE_DECL,"void ngx_event_process_posted(ngx_cycle_t *cycle, ngx_queue_t *posted);",6,70,event\ngx_event_posted.h,ngx_event_process_posted,,false,41,41,ngx_event_process_posted,,,1,"void ngx_event_process_posted (ngx_cycle_t*,ngx_queue_t*)"
96954,METHOD,event\ngx_event_posted.h:<global>,TYPE_DECL,void ngx_event_move_posted_next(ngx_cycle_t *cycle);,6,51,event\ngx_event_posted.h,ngx_event_move_posted_next,,false,42,42,ngx_event_move_posted_next,,,2,void ngx_event_move_posted_next (ngx_cycle_t*)
96971,METHOD,event\ngx_event_timer.c:<global>,TYPE_DECL,<global>,1,1,event\ngx_event_timer.c,event\ngx_event_timer.c:<global>,,false,1,126,<global>,,,1,
96975,METHOD,event\ngx_event_timer.c:<global>,TYPE_DECL,"ngx_int_t
ngx_event_timer_init(ngx_log_t *log)
{
    ngx_rbtree_init(&ngx_event_timer_rbtree, &ngx_event_timer_sentinel,
                    ngx_rbtree_insert_timer_value);

    return NGX_OK;
}",1,1,event\ngx_event_timer.c,ngx_event_timer_init,,false,22,29,ngx_event_timer_init,,,3,ngx_int_t ngx_event_timer_init (ngx_log_t*)
96988,METHOD,event\ngx_event_timer.c:<global>,TYPE_DECL,"ngx_msec_t
ngx_event_find_timer(void)
{
    ngx_msec_int_t      timer;
    ngx_rbtree_node_t  *node, *root, *sentinel;

    if (ngx_event_timer_rbtree.root == &ngx_event_timer_sentinel) {
        return NGX_TIMER_INFINITE;
    }

    root = ngx_event_timer_rbtree.root;
    sentinel = ngx_event_timer_rbtree.sentinel;

    node = ngx_rbtree_min(root, sentinel);

    timer = (ngx_msec_int_t) (node->key - ngx_current_msec);

    return (ngx_msec_t) (timer > 0 ? timer : 0);
}",1,1,event\ngx_event_timer.c,ngx_event_find_timer,,false,32,50,ngx_event_find_timer,,,4,ngx_msec_t ngx_event_find_timer (void)
97038,METHOD,event\ngx_event_timer.c:<global>,TYPE_DECL,"void
ngx_event_expire_timers(void)
{
    ngx_event_t        *ev;
    ngx_rbtree_node_t  *node, *root, *sentinel;

    sentinel = ngx_event_timer_rbtree.sentinel;

    for ( ;; ) {
        root = ngx_event_timer_rbtree.root;

        if (root == sentinel) {
            return;
        }

        node = ngx_rbtree_min(root, sentinel);

        /* node->key > ngx_current_msec */

        if ((ngx_msec_int_t) (node->key - ngx_current_msec) > 0) {
            return;
        }

        ev = (ngx_event_t *) ((char *) node - offsetof(ngx_event_t, timer));

        ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ev->log, 0,
                       ""event timer del: %d: %M"",
                       ngx_event_ident(ev->data), ev->timer.key);

        ngx_rbtree_delete(&ngx_event_timer_rbtree, &ev->timer);

#if (NGX_DEBUG)
        ev->timer.left = NULL;
        ev->timer.right = NULL;
        ev->timer.parent = NULL;
#endif

        ev->timer_set = 0;

        ev->timedout = 1;

        ev->handler(ev);
   ...",1,1,event\ngx_event_timer.c,ngx_event_expire_timers,,false,53,96,ngx_event_expire_timers,,,5,void ngx_event_expire_timers (void)
97131,METHOD,event\ngx_event_timer.c:<global>,TYPE_DECL,"ngx_int_t
ngx_event_no_timers_left(void)
{
    ngx_event_t        *ev;
    ngx_rbtree_node_t  *node, *root, *sentinel;

    sentinel = ngx_event_timer_rbtree.sentinel;
    root = ngx_event_timer_rbtree.root;

    if (root == sentinel) {
        return NGX_OK;
    }

    for (node = ngx_rbtree_min(root, sentinel);
         node;
         node = ngx_rbtree_next(&ngx_event_timer_rbtree, node))
    {
        ev = (ngx_event_t *) ((char *) node - offsetof(ngx_event_t, timer));

        if (!ev->cancelable) {
            return NGX_AGAIN;
        }
    }

    /* only cancelable timers left */

    return NGX_OK;
}",1,1,event\ngx_event_timer.c,ngx_event_no_timers_left,,false,99,126,ngx_event_no_timers_left,,,6,ngx_int_t ngx_event_no_timers_left (void)
97202,METHOD,event\ngx_event_timer.h:<global>,TYPE_DECL,<global>,1,28,event\ngx_event_timer.h,event\ngx_event_timer.h:<global>,,false,1,90,<global>,,,1,
97204,METHOD,event\ngx_event_timer.h:<global>,TYPE_DECL,ngx_int_t ngx_event_timer_init(ngx_log_t *log);,11,46,event\ngx_event_timer.h,ngx_event_timer_init,,false,22,22,ngx_event_timer_init,,,1,ngx_int_t ngx_event_timer_init (ngx_log_t*)
97209,METHOD,event\ngx_event_timer.h:<global>,TYPE_DECL,ngx_msec_t ngx_event_find_timer(void);,12,37,event\ngx_event_timer.h,ngx_event_find_timer,,false,23,23,ngx_event_find_timer,,,2,ngx_msec_t ngx_event_find_timer (void)
97214,METHOD,event\ngx_event_timer.h:<global>,TYPE_DECL,void ngx_event_expire_timers(void);,6,34,event\ngx_event_timer.h,ngx_event_expire_timers,,false,24,24,ngx_event_expire_timers,,,3,void ngx_event_expire_timers (void)
97219,METHOD,event\ngx_event_timer.h:<global>,TYPE_DECL,ngx_int_t ngx_event_no_timers_left(void);,11,40,event\ngx_event_timer.h,ngx_event_no_timers_left,,false,25,25,ngx_event_no_timers_left,,,4,ngx_int_t ngx_event_no_timers_left (void)
97236,METHOD,event\ngx_event_udp.c:<global>,TYPE_DECL,<global>,1,6,event\ngx_event_udp.c,event\ngx_event_udp.c:<global>,,false,1,663,<global>,,,1,
97242,METHOD,event\ngx_event_udp.c:<global>,TYPE_DECL,static void ngx_close_accepted_udp_connection(ngx_connection_t *c);,13,66,event\ngx_event_udp.c,ngx_close_accepted_udp_connection,,false,22,22,ngx_close_accepted_udp_connection,,,2,void ngx_close_accepted_udp_connection (ngx_connection_t*)
97247,METHOD,event\ngx_event_udp.c:<global>,TYPE_DECL,"static ssize_t ngx_udp_shared_recv(ngx_connection_t *c, u_char *buf,
    size_t size);",16,16,event\ngx_event_udp.c,ngx_udp_shared_recv,,false,23,24,ngx_udp_shared_recv,,,3,"ssize_t ngx_udp_shared_recv (ngx_connection_t*,u_char*,size_t)"
97254,METHOD,event\ngx_event_udp.c:<global>,TYPE_DECL,static ngx_int_t ngx_insert_udp_connection(ngx_connection_t *c);,18,63,event\ngx_event_udp.c,ngx_insert_udp_connection,,false,25,25,ngx_insert_udp_connection,,,4,ngx_int_t ngx_insert_udp_connection (ngx_connection_t*)
97259,METHOD,event\ngx_event_udp.c:<global>,TYPE_DECL,"static ngx_connection_t *ngx_lookup_udp_connection(ngx_listening_t *ls,
    struct sockaddr *sockaddr, socklen_t socklen,
    struct sockaddr *local_sockaddr, socklen_t local_socklen);",25,61,event\ngx_event_udp.c,ngx_lookup_udp_connection,,false,26,28,ngx_lookup_udp_connection,,,5,"ngx_connection_t* ngx_lookup_udp_connection (ngx_listening_t*,sockaddr*,socklen_t,sockaddr*,socklen_t)"
97268,METHOD,event\ngx_event_udp.c:<global>,TYPE_DECL,"void
ngx_event_recvmsg(ngx_event_t *ev)
{
    ssize_t            n;
    ngx_buf_t          buf;
    ngx_log_t         *log;
    ngx_err_t          err;
    socklen_t          socklen, local_socklen;
    ngx_event_t       *rev, *wev;
    struct iovec       iov[1];
    struct msghdr      msg;
    ngx_sockaddr_t     sa, lsa;
    struct sockaddr   *sockaddr, *local_sockaddr;
    ngx_listening_t   *ls;
    ngx_event_conf_t  *ecf;
    ngx_connection_t  *c, *lc;
    static u_char      buffer[65535];

#if (NGX_HAVE_MSGHDR_MSG_CONTROL)

#if (NGX_HAVE_IP_RECVDSTADDR)
    u_char             msg_control[CMSG_SPACE(sizeof(struct in_addr))];
#elif (NGX_HAVE_IP_PKTINFO)
    u_char             msg_control[CMSG_SPACE(sizeof(struct in_pktinfo))];
#endif

#if (NGX_HAVE_INET6 && NGX_HAVE_IPV6_RECVPKTINFO)
    u_char             msg_control6[CMSG_SPACE(sizeof(struct in6_pktinfo))];
#endif

#endif

    if (ev->timedout) {
        if (ngx_enable_accept_events((ngx_cycle_t *) ngx_cycle) != NGX_OK) {
      ...",1,1,event\ngx_event_udp.c,ngx_event_recvmsg,,false,31,423,ngx_event_recvmsg,,,6,void ngx_event_recvmsg (ngx_event_t*)
97932,METHOD,event\ngx_event_udp.c:<global>,TYPE_DECL,"static void
ngx_close_accepted_udp_connection(ngx_connection_t *c)
{
    ngx_free_connection(c);

    c->fd = (ngx_socket_t) -1;

    if (c->pool) {
        ngx_destroy_pool(c->pool);
    }

#if (NGX_STAT_STUB)
    (void) ngx_atomic_fetch_add(ngx_stat_active, -1);
#endif
}",1,1,event\ngx_event_udp.c,ngx_close_accepted_udp_connection,,false,426,440,ngx_close_accepted_udp_connection,,,7,void ngx_close_accepted_udp_connection (ngx_connection_t*)
97955,METHOD,event\ngx_event_udp.c:<global>,TYPE_DECL,"static ssize_t
ngx_udp_shared_recv(ngx_connection_t *c, u_char *buf, size_t size)
{
    ssize_t     n;
    ngx_buf_t  *b;

    if (c->udp == NULL || c->udp->buffer == NULL) {
        return NGX_AGAIN;
    }

    b = c->udp->buffer;

    n = ngx_min(b->last - b->pos, (ssize_t) size);

    ngx_memcpy(buf, b->pos, n);

    c->udp->buffer = NULL;

    c->read->ready = 0;
    c->read->active = 1;

    return n;
}",1,1,event\ngx_event_udp.c,ngx_udp_shared_recv,,false,443,465,ngx_udp_shared_recv,,,8,"ssize_t ngx_udp_shared_recv (ngx_connection_t*,u_char*,size_t)"
98030,METHOD,event\ngx_event_udp.c:<global>,TYPE_DECL,"void
ngx_udp_rbtree_insert_value(ngx_rbtree_node_t *temp,
    ngx_rbtree_node_t *node, ngx_rbtree_node_t *sentinel)
{
    ngx_int_t               rc;
    ngx_connection_t       *c, *ct;
    ngx_rbtree_node_t     **p;
    ngx_udp_connection_t   *udp, *udpt;

    for ( ;; ) {

        if (node->key < temp->key) {

            p = &temp->left;

        } else if (node->key > temp->key) {

            p = &temp->right;

        } else { /* node->key == temp->key */

            udp = (ngx_udp_connection_t *) node;
            c = udp->connection;

            udpt = (ngx_udp_connection_t *) temp;
            ct = udpt->connection;

            rc = ngx_cmp_sockaddr(c->sockaddr, c->socklen,
                                  ct->sockaddr, ct->socklen, 1);

            if (rc == 0 && c->listening->wildcard) {
                rc = ngx_cmp_sockaddr(c->local_sockaddr, c->local_socklen,
                                      ct->local_sockaddr, ct->local_socklen, 1);
            }

            ...",1,1,event\ngx_event_udp.c,ngx_udp_rbtree_insert_value,,false,468,518,ngx_udp_rbtree_insert_value,,,9,"void ngx_udp_rbtree_insert_value (ngx_rbtree_node_t*,ngx_rbtree_node_t*,ngx_rbtree_node_t*)"
98189,METHOD,event\ngx_event_udp.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_insert_udp_connection(ngx_connection_t *c)
{
    uint32_t               hash;
    ngx_pool_cleanup_t    *cln;
    ngx_udp_connection_t  *udp;

    if (c->udp) {
        return NGX_OK;
    }

    udp = ngx_pcalloc(c->pool, sizeof(ngx_udp_connection_t));
    if (udp == NULL) {
        return NGX_ERROR;
    }

    udp->connection = c;

    ngx_crc32_init(hash);
    ngx_crc32_update(&hash, (u_char *) c->sockaddr, c->socklen);

    if (c->listening->wildcard) {
        ngx_crc32_update(&hash, (u_char *) c->local_sockaddr, c->local_socklen);
    }

    ngx_crc32_final(hash);

    udp->node.key = hash;

    cln = ngx_pool_cleanup_add(c->pool, 0);
    if (cln == NULL) {
        return NGX_ERROR;
    }

    cln->data = c;
    cln->handler = ngx_delete_udp_connection;

    ngx_rbtree_insert(&c->listening->rbtree, &udp->node);

    c->udp = udp;

    return NGX_OK;
}",1,1,event\ngx_event_udp.c,ngx_insert_udp_connection,,false,521,563,ngx_insert_udp_connection,,,10,ngx_int_t ngx_insert_udp_connection (ngx_connection_t*)
98306,METHOD,event\ngx_event_udp.c:<global>,TYPE_DECL,"void
ngx_delete_udp_connection(void *data)
{
    ngx_connection_t  *c = data;

    if (c->udp == NULL) {
        return;
    }

    ngx_rbtree_delete(&c->listening->rbtree, &c->udp->node);

    c->udp = NULL;
}",1,1,event\ngx_event_udp.c,ngx_delete_udp_connection,,false,566,578,ngx_delete_udp_connection,,,11,void ngx_delete_udp_connection (void*)
98341,METHOD,event\ngx_event_udp.c:<global>,TYPE_DECL,"static ngx_connection_t *
ngx_lookup_udp_connection(ngx_listening_t *ls, struct sockaddr *sockaddr,
    socklen_t socklen, struct sockaddr *local_sockaddr, socklen_t local_socklen)
{
    uint32_t               hash;
    ngx_int_t              rc;
    ngx_connection_t      *c;
    ngx_rbtree_node_t     *node, *sentinel;
    ngx_udp_connection_t  *udp;

#if (NGX_HAVE_UNIX_DOMAIN)

    if (sockaddr->sa_family == AF_UNIX) {
        struct sockaddr_un *saun = (struct sockaddr_un *) sockaddr;

        if (socklen <= (socklen_t) offsetof(struct sockaddr_un, sun_path)
            || saun->sun_path[0] == '\0')
        {
            ngx_log_debug0(NGX_LOG_DEBUG_EVENT, ngx_cycle->log, 0,
                           ""unbound unix socket"");
            return NULL;
        }
    }

#endif

    node = ls->rbtree.root;
    sentinel = ls->rbtree.sentinel;

    ngx_crc32_init(hash);
    ngx_crc32_update(&hash, (u_char *) sockaddr, socklen);

    if (ls->wildcard) {
        ngx_crc32_update(&hash, (u_...",1,1,event\ngx_event_udp.c,ngx_lookup_udp_connection,,false,581,653,ngx_lookup_udp_connection,,,12,"ngx_connection_t ngx_lookup_udp_connection (ngx_listening_t*,sockaddr*,socklen_t,sockaddr*,socklen_t)"
98497,METHOD,http\modules\ngx_http_access_module.c:<global>,TYPE_DECL,<global>,1,1,http\modules\ngx_http_access_module.c,http\modules\ngx_http_access_module.c:<global>,,false,1,463,<global>,,,1,
98509,METHOD,http\modules\ngx_http_access_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_access_handler(ngx_http_request_t *r);,18,63,http\modules\ngx_http_access_module.c,ngx_http_access_handler,,false,48,48,ngx_http_access_handler,,,5,ngx_int_t ngx_http_access_handler (ngx_http_request_t*)
98514,METHOD,http\modules\ngx_http_access_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_access_inet(ngx_http_request_t *r,
    ngx_http_access_loc_conf_t *alcf, in_addr_t addr);",18,53,http\modules\ngx_http_access_module.c,ngx_http_access_inet,,false,49,50,ngx_http_access_inet,,,6,"ngx_int_t ngx_http_access_inet (ngx_http_request_t*,ngx_http_access_loc_conf_t*,in_addr_t)"
98521,METHOD,http\modules\ngx_http_access_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_access_found(ngx_http_request_t *r, ngx_uint_t deny);",18,78,http\modules\ngx_http_access_module.c,ngx_http_access_found,,false,59,59,ngx_http_access_found,,,7,"ngx_int_t ngx_http_access_found (ngx_http_request_t*,ngx_uint_t)"
98527,METHOD,http\modules\ngx_http_access_module.c:<global>,TYPE_DECL,"static char *ngx_http_access_rule(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_access_module.c,ngx_http_access_rule,,false,60,61,ngx_http_access_rule,,,8,"char* ngx_http_access_rule (ngx_conf_t*,ngx_command_t*,void*)"
98534,METHOD,http\modules\ngx_http_access_module.c:<global>,TYPE_DECL,static void *ngx_http_access_create_loc_conf(ngx_conf_t *cf);,13,60,http\modules\ngx_http_access_module.c,ngx_http_access_create_loc_conf,,false,62,62,ngx_http_access_create_loc_conf,,,9,void* ngx_http_access_create_loc_conf (ngx_conf_t*)
98539,METHOD,http\modules\ngx_http_access_module.c:<global>,TYPE_DECL,"static char *ngx_http_access_merge_loc_conf(ngx_conf_t *cf,
    void *parent, void *child);",13,30,http\modules\ngx_http_access_module.c,ngx_http_access_merge_loc_conf,,false,63,64,ngx_http_access_merge_loc_conf,,,10,"char* ngx_http_access_merge_loc_conf (ngx_conf_t*,void*,void*)"
98546,METHOD,http\modules\ngx_http_access_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_access_init(ngx_conf_t *cf);,18,53,http\modules\ngx_http_access_module.c,ngx_http_access_init,,false,65,65,ngx_http_access_init,,,11,ngx_int_t ngx_http_access_init (ngx_conf_t*)
98617,METHOD,http\modules\ngx_http_access_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_access_handler(ngx_http_request_t *r)
{
    struct sockaddr_in          *sin;
    ngx_http_access_loc_conf_t  *alcf;
#if (NGX_HAVE_INET6)
    u_char                      *p;
    in_addr_t                    addr;
    struct sockaddr_in6         *sin6;
#endif

    alcf = ngx_http_get_module_loc_conf(r, ngx_http_access_module);

    switch (r->connection->sockaddr->sa_family) {

    case AF_INET:
        if (alcf->rules) {
            sin = (struct sockaddr_in *) r->connection->sockaddr;
            return ngx_http_access_inet(r, alcf, sin->sin_addr.s_addr);
        }
        break;

#if (NGX_HAVE_INET6)

    case AF_INET6:
        sin6 = (struct sockaddr_in6 *) r->connection->sockaddr;
        p = sin6->sin6_addr.s6_addr;

        if (alcf->rules && IN6_IS_ADDR_V4MAPPED(&sin6->sin6_addr)) {
            addr = p[12] << 24;
            addr += p[13] << 16;
            addr += p[14] << 8;
            addr += p[15];
            return ngx_http_access_inet(r, alc...",1,1,http\modules\ngx_http_access_module.c,ngx_http_access_handler,,false,122,179,ngx_http_access_handler,,,18,ngx_int_t ngx_http_access_handler (ngx_http_request_t*)
98666,METHOD,http\modules\ngx_http_access_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_access_inet(ngx_http_request_t *r, ngx_http_access_loc_conf_t *alcf,
    in_addr_t addr)
{
    ngx_uint_t               i;
    ngx_http_access_rule_t  *rule;

    rule = alcf->rules->elts;
    for (i = 0; i < alcf->rules->nelts; i++) {

        ngx_log_debug3(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                       ""access: %08XD %08XD %08XD"",
                       addr, rule[i].mask, rule[i].addr);

        if ((addr & rule[i].mask) == rule[i].addr) {
            return ngx_http_access_found(r, rule[i].deny);
        }
    }

    return NGX_DECLINED;
}",1,1,http\modules\ngx_http_access_module.c,ngx_http_access_inet,,false,182,202,ngx_http_access_inet,,,19,"ngx_int_t ngx_http_access_inet (ngx_http_request_t*,ngx_http_access_loc_conf_t*,in_addr_t)"
98742,METHOD,http\modules\ngx_http_access_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_access_found(ngx_http_request_t *r, ngx_uint_t deny)
{
    ngx_http_core_loc_conf_t  *clcf;

    if (deny) {
        clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

        if (clcf->satisfy == NGX_HTTP_SATISFY_ALL) {
            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                          ""access forbidden by rule"");
        }

        return NGX_HTTP_FORBIDDEN;
    }

    return NGX_OK;
}",1,1,http\modules\ngx_http_access_module.c,ngx_http_access_found,,false,275,292,ngx_http_access_found,,,20,"ngx_int_t ngx_http_access_found (ngx_http_request_t*,ngx_uint_t)"
98777,METHOD,http\modules\ngx_http_access_module.c:<global>,TYPE_DECL,"static char *
ngx_http_access_rule(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_access_loc_conf_t *alcf = conf;

    ngx_int_t                   rc;
    ngx_uint_t                  all;
    ngx_str_t                  *value;
    ngx_cidr_t                  cidr;
    ngx_http_access_rule_t     *rule;
#if (NGX_HAVE_INET6)
    ngx_http_access_rule6_t    *rule6;
#endif
#if (NGX_HAVE_UNIX_DOMAIN)
    ngx_http_access_rule_un_t  *rule_un;
#endif

    all = 0;
    ngx_memzero(&cidr, sizeof(ngx_cidr_t));

    value = cf->args->elts;

    if (value[1].len == 3 && ngx_strcmp(value[1].data, ""all"") == 0) {
        all = 1;

#if (NGX_HAVE_UNIX_DOMAIN)
    } else if (value[1].len == 5 && ngx_strcmp(value[1].data, ""unix:"") == 0) {
        cidr.family = AF_UNIX;
#endif

    } else {
        rc = ngx_ptocidr(&value[1], &cidr);

        if (rc == NGX_ERROR) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                         ""invalid parameter \""%V\"""", &value[1]);
        ...",1,1,http\modules\ngx_http_access_module.c,ngx_http_access_rule,,false,295,403,ngx_http_access_rule,,,21,"char* ngx_http_access_rule (ngx_conf_t*,ngx_command_t*,void*)"
98960,METHOD,http\modules\ngx_http_access_module.c:<global>,TYPE_DECL,"static void *
ngx_http_access_create_loc_conf(ngx_conf_t *cf)
{
    ngx_http_access_loc_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_access_loc_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    return conf;
}",1,1,http\modules\ngx_http_access_module.c,ngx_http_access_create_loc_conf,,false,406,417,ngx_http_access_create_loc_conf,,,22,void* ngx_http_access_create_loc_conf (ngx_conf_t*)
98983,METHOD,http\modules\ngx_http_access_module.c:<global>,TYPE_DECL,"static char *
ngx_http_access_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_access_loc_conf_t  *prev = parent;
    ngx_http_access_loc_conf_t  *conf = child;

    if (conf->rules == NULL
#if (NGX_HAVE_INET6)
        && conf->rules6 == NULL
#endif
#if (NGX_HAVE_UNIX_DOMAIN)
        && conf->rules_un == NULL
#endif
    ) {
        conf->rules = prev->rules;
#if (NGX_HAVE_INET6)
        conf->rules6 = prev->rules6;
#endif
#if (NGX_HAVE_UNIX_DOMAIN)
        conf->rules_un = prev->rules_un;
#endif
    }

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_access_module.c,ngx_http_access_merge_loc_conf,,false,420,444,ngx_http_access_merge_loc_conf,,,23,"char* ngx_http_access_merge_loc_conf (ngx_conf_t*,void*,void*)"
99014,METHOD,http\modules\ngx_http_access_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_access_init(ngx_conf_t *cf)
{
    ngx_http_handler_pt        *h;
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);

    h = ngx_array_push(&cmcf->phases[NGX_HTTP_ACCESS_PHASE].handlers);
    if (h == NULL) {
        return NGX_ERROR;
    }

    *h = ngx_http_access_handler;

    return NGX_OK;
}",1,1,http\modules\ngx_http_access_module.c,ngx_http_access_init,,false,447,463,ngx_http_access_init,,,24,ngx_int_t ngx_http_access_init (ngx_conf_t*)
99059,METHOD,http\modules\ngx_http_addition_filter_module.c:<global>,TYPE_DECL,<global>,1,1,http\modules\ngx_http_addition_filter_module.c,http\modules\ngx_http_addition_filter_module.c:<global>,,false,1,254,<global>,,,1,
99070,METHOD,http\modules\ngx_http_addition_filter_module.c:<global>,TYPE_DECL,static void *ngx_http_addition_create_conf(ngx_conf_t *cf);,13,58,http\modules\ngx_http_addition_filter_module.c,ngx_http_addition_create_conf,,false,27,27,ngx_http_addition_create_conf,,,5,void* ngx_http_addition_create_conf (ngx_conf_t*)
99075,METHOD,http\modules\ngx_http_addition_filter_module.c:<global>,TYPE_DECL,"static char *ngx_http_addition_merge_conf(ngx_conf_t *cf, void *parent,
    void *child);",13,16,http\modules\ngx_http_addition_filter_module.c,ngx_http_addition_merge_conf,,false,28,29,ngx_http_addition_merge_conf,,,6,"char* ngx_http_addition_merge_conf (ngx_conf_t*,void*,void*)"
99082,METHOD,http\modules\ngx_http_addition_filter_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_addition_filter_init(ngx_conf_t *cf);,18,62,http\modules\ngx_http_addition_filter_module.c,ngx_http_addition_filter_init,,false,30,30,ngx_http_addition_filter_init,,,7,ngx_int_t ngx_http_addition_filter_init (ngx_conf_t*)
99174,METHOD,http\modules\ngx_http_addition_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_addition_header_filter(ngx_http_request_t *r)
{
    ngx_http_addition_ctx_t   *ctx;
    ngx_http_addition_conf_t  *conf;

    if (r->headers_out.status != NGX_HTTP_OK || r != r->main) {
        return ngx_http_next_header_filter(r);
    }

    conf = ngx_http_get_module_loc_conf(r, ngx_http_addition_filter_module);

    if (conf->before_body.len == 0 && conf->after_body.len == 0) {
        return ngx_http_next_header_filter(r);
    }

    if (ngx_http_test_content_type(r, &conf->types) == NULL) {
        return ngx_http_next_header_filter(r);
    }

    ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_addition_ctx_t));
    if (ctx == NULL) {
        return NGX_ERROR;
    }

    ngx_http_set_ctx(r, ctx, ngx_http_addition_filter_module);

    ngx_http_clear_content_length(r);
    ngx_http_clear_accept_ranges(r);
    ngx_http_weak_etag(r);

    r->preserve_body = 1;

    return ngx_http_next_header_filter(r);
}",1,1,http\modules\ngx_http_addition_filter_module.c,ngx_http_addition_header_filter,,false,95,129,ngx_http_addition_header_filter,,,16,ngx_int_t ngx_http_addition_header_filter (ngx_http_request_t*)
99270,METHOD,http\modules\ngx_http_addition_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_addition_body_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    ngx_int_t                  rc;
    ngx_uint_t                 last;
    ngx_chain_t               *cl;
    ngx_http_request_t        *sr;
    ngx_http_addition_ctx_t   *ctx;
    ngx_http_addition_conf_t  *conf;

    if (in == NULL || r->header_only) {
        return ngx_http_next_body_filter(r, in);
    }

    ctx = ngx_http_get_module_ctx(r, ngx_http_addition_filter_module);

    if (ctx == NULL) {
        return ngx_http_next_body_filter(r, in);
    }

    conf = ngx_http_get_module_loc_conf(r, ngx_http_addition_filter_module);

    if (!ctx->before_body_sent) {
        ctx->before_body_sent = 1;

        if (conf->before_body.len) {
            if (ngx_http_subrequest(r, &conf->before_body, NULL, &sr, NULL, 0)
                != NGX_OK)
            {
                return NGX_ERROR;
            }
        }
    }

    if (conf->after_body.len == 0) {
        ngx_http_set_ctx(r, NULL, ngx_...",1,1,http\modules\ngx_http_addition_filter_module.c,ngx_http_addition_body_filter,,false,132,197,ngx_http_addition_body_filter,,,17,"ngx_int_t ngx_http_addition_body_filter (ngx_http_request_t*,ngx_chain_t*)"
99460,METHOD,http\modules\ngx_http_addition_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_addition_filter_init(ngx_conf_t *cf)
{
    ngx_http_next_header_filter = ngx_http_top_header_filter;
    ngx_http_top_header_filter = ngx_http_addition_header_filter;

    ngx_http_next_body_filter = ngx_http_top_body_filter;
    ngx_http_top_body_filter = ngx_http_addition_body_filter;

    return NGX_OK;
}",1,1,http\modules\ngx_http_addition_filter_module.c,ngx_http_addition_filter_init,,false,200,210,ngx_http_addition_filter_init,,,18,ngx_int_t ngx_http_addition_filter_init (ngx_conf_t*)
99479,METHOD,http\modules\ngx_http_addition_filter_module.c:<global>,TYPE_DECL,"static void *
ngx_http_addition_create_conf(ngx_conf_t *cf)
{
    ngx_http_addition_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_addition_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     conf->before_body = { 0, NULL };
     *     conf->after_body = { 0, NULL };
     *     conf->types = { NULL };
     *     conf->types_keys = NULL;
     */

    return conf;
}",1,1,http\modules\ngx_http_addition_filter_module.c,ngx_http_addition_create_conf,,false,213,233,ngx_http_addition_create_conf,,,19,void* ngx_http_addition_create_conf (ngx_conf_t*)
99502,METHOD,http\modules\ngx_http_addition_filter_module.c:<global>,TYPE_DECL,"static char *
ngx_http_addition_merge_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_addition_conf_t *prev = parent;
    ngx_http_addition_conf_t *conf = child;

    ngx_conf_merge_str_value(conf->before_body, prev->before_body, """");
    ngx_conf_merge_str_value(conf->after_body, prev->after_body, """");

    if (ngx_http_merge_types(cf, &conf->types_keys, &conf->types,
                             &prev->types_keys, &prev->types,
                             ngx_http_html_default_types)
        != NGX_OK)
    {
        return NGX_CONF_ERROR;
    }

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_addition_filter_module.c,ngx_http_addition_merge_conf,,false,236,254,ngx_http_addition_merge_conf,,,20,"char* ngx_http_addition_merge_conf (ngx_conf_t*,void*,void*)"
99571,METHOD,http\modules\ngx_http_auth_basic_module.c:<global>,TYPE_DECL,<global>,1,41,http\modules\ngx_http_auth_basic_module.c,http\modules\ngx_http_auth_basic_module.c:<global>,,false,1,428,<global>,,,1,
99577,METHOD,http\modules\ngx_http_auth_basic_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_auth_basic_handler(ngx_http_request_t *r);,18,67,http\modules\ngx_http_auth_basic_module.c,ngx_http_auth_basic_handler,,false,23,23,ngx_http_auth_basic_handler,,,3,ngx_int_t ngx_http_auth_basic_handler (ngx_http_request_t*)
99582,METHOD,http\modules\ngx_http_auth_basic_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_auth_basic_crypt_handler(ngx_http_request_t *r,
    ngx_str_t *passwd, ngx_str_t *realm);",18,40,http\modules\ngx_http_auth_basic_module.c,ngx_http_auth_basic_crypt_handler,,false,24,25,ngx_http_auth_basic_crypt_handler,,,4,"ngx_int_t ngx_http_auth_basic_crypt_handler (ngx_http_request_t*,ngx_str_t*,ngx_str_t*)"
99589,METHOD,http\modules\ngx_http_auth_basic_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_auth_basic_set_realm(ngx_http_request_t *r,
    ngx_str_t *realm);",18,21,http\modules\ngx_http_auth_basic_module.c,ngx_http_auth_basic_set_realm,,false,26,27,ngx_http_auth_basic_set_realm,,,5,"ngx_int_t ngx_http_auth_basic_set_realm (ngx_http_request_t*,ngx_str_t*)"
99595,METHOD,http\modules\ngx_http_auth_basic_module.c:<global>,TYPE_DECL,static void *ngx_http_auth_basic_create_loc_conf(ngx_conf_t *cf);,13,64,http\modules\ngx_http_auth_basic_module.c,ngx_http_auth_basic_create_loc_conf,,false,28,28,ngx_http_auth_basic_create_loc_conf,,,6,void* ngx_http_auth_basic_create_loc_conf (ngx_conf_t*)
99600,METHOD,http\modules\ngx_http_auth_basic_module.c:<global>,TYPE_DECL,"static char *ngx_http_auth_basic_merge_loc_conf(ngx_conf_t *cf,
    void *parent, void *child);",13,30,http\modules\ngx_http_auth_basic_module.c,ngx_http_auth_basic_merge_loc_conf,,false,29,30,ngx_http_auth_basic_merge_loc_conf,,,7,"char* ngx_http_auth_basic_merge_loc_conf (ngx_conf_t*,void*,void*)"
99607,METHOD,http\modules\ngx_http_auth_basic_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_auth_basic_init(ngx_conf_t *cf);,18,57,http\modules\ngx_http_auth_basic_module.c,ngx_http_auth_basic_init,,false,31,31,ngx_http_auth_basic_init,,,8,ngx_int_t ngx_http_auth_basic_init (ngx_conf_t*)
99612,METHOD,http\modules\ngx_http_auth_basic_module.c:<global>,TYPE_DECL,"static char *ngx_http_auth_basic_user_file(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_auth_basic_module.c,ngx_http_auth_basic_user_file,,false,32,33,ngx_http_auth_basic_user_file,,,9,"char* ngx_http_auth_basic_user_file (ngx_conf_t*,ngx_command_t*,void*)"
99689,METHOD,http\modules\ngx_http_auth_basic_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_auth_basic_handler(ngx_http_request_t *r)
{
    off_t                            offset;
    ssize_t                          n;
    ngx_fd_t                         fd;
    ngx_int_t                        rc;
    ngx_err_t                        err;
    ngx_str_t                        pwd, realm, user_file;
    ngx_uint_t                       i, level, login, left, passwd;
    ngx_file_t                       file;
    ngx_http_auth_basic_loc_conf_t  *alcf;
    u_char                           buf[NGX_HTTP_AUTH_BUF_SIZE];
    enum {
        sw_login,
        sw_passwd,
        sw_skip
    } state;

    alcf = ngx_http_get_module_loc_conf(r, ngx_http_auth_basic_module);

    if (alcf->realm == NULL || alcf->user_file.value.data == NULL) {
        return NGX_DECLINED;
    }

    if (ngx_http_complex_value(r, alcf->realm, &realm) != NGX_OK) {
        return NGX_ERROR;
    }

    if (realm.len == 3 && ngx_strncmp(realm.data, ""off"", 3) == 0) {
        retur...",1,41,http\modules\ngx_http_auth_basic_module.c,ngx_http_auth_basic_handler,,false,89,281,ngx_http_auth_basic_handler,,,16,ngx_int_t ngx_http_auth_basic_handler (ngx_http_request_t*)
100206,METHOD,http\modules\ngx_http_auth_basic_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_auth_basic_crypt_handler(ngx_http_request_t *r, ngx_str_t *passwd,
    ngx_str_t *realm)
{
    ngx_int_t   rc;
    u_char     *encrypted;

    rc = ngx_crypt(r->pool, r->headers_in.passwd.data, passwd->data,
                   &encrypted);

    ngx_log_debug3(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""rc: %i user: \""%V\"" salt: \""%s\"""",
                   rc, &r->headers_in.user, passwd->data);

    if (rc != NGX_OK) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    if (ngx_strcmp(encrypted, passwd->data) == 0) {
        return NGX_OK;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""encrypted: \""%s\"""", encrypted);

    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                  ""user \""%V\"": password mismatch"",
                  &r->headers_in.user);

    return ngx_http_auth_basic_set_realm(r, realm);
}",1,1,http\modules\ngx_http_auth_basic_module.c,ngx_http_auth_basic_crypt_handler,,false,284,314,ngx_http_auth_basic_crypt_handler,,,17,"ngx_int_t ngx_http_auth_basic_crypt_handler (ngx_http_request_t*,ngx_str_t*,ngx_str_t*)"
100299,METHOD,http\modules\ngx_http_auth_basic_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_auth_basic_set_realm(ngx_http_request_t *r, ngx_str_t *realm)
{
    size_t   len;
    u_char  *basic, *p;

    r->headers_out.www_authenticate = ngx_list_push(&r->headers_out.headers);
    if (r->headers_out.www_authenticate == NULL) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    len = sizeof(""Basic realm=\""\"""") - 1 + realm->len;

    basic = ngx_pnalloc(r->pool, len);
    if (basic == NULL) {
        r->headers_out.www_authenticate->hash = 0;
        r->headers_out.www_authenticate = NULL;
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    p = ngx_cpymem(basic, ""Basic realm=\"""", sizeof(""Basic realm=\"""") - 1);
    p = ngx_cpymem(p, realm->data, realm->len);
    *p = '""';

    r->headers_out.www_authenticate->hash = 1;
    ngx_str_set(&r->headers_out.www_authenticate->key, ""WWW-Authenticate"");
    r->headers_out.www_authenticate->value.data = basic;
    r->headers_out.www_authenticate->value.len = len;

    return NGX_HTTP_UNAUTHORIZED;
}",1,1,http\modules\ngx_http_auth_basic_module.c,ngx_http_auth_basic_set_realm,,false,317,347,ngx_http_auth_basic_set_realm,,,18,"ngx_int_t ngx_http_auth_basic_set_realm (ngx_http_request_t*,ngx_str_t*)"
100438,METHOD,http\modules\ngx_http_auth_basic_module.c:<global>,TYPE_DECL,"static void *
ngx_http_auth_basic_create_loc_conf(ngx_conf_t *cf)
{
    ngx_http_auth_basic_loc_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_auth_basic_loc_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    return conf;
}",1,1,http\modules\ngx_http_auth_basic_module.c,ngx_http_auth_basic_create_loc_conf,,false,350,361,ngx_http_auth_basic_create_loc_conf,,,19,void* ngx_http_auth_basic_create_loc_conf (ngx_conf_t*)
100461,METHOD,http\modules\ngx_http_auth_basic_module.c:<global>,TYPE_DECL,"static char *
ngx_http_auth_basic_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_auth_basic_loc_conf_t  *prev = parent;
    ngx_http_auth_basic_loc_conf_t  *conf = child;

    if (conf->realm == NULL) {
        conf->realm = prev->realm;
    }

    if (conf->user_file.value.data == NULL) {
        conf->user_file = prev->user_file;
    }

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_auth_basic_module.c,ngx_http_auth_basic_merge_loc_conf,,false,364,379,ngx_http_auth_basic_merge_loc_conf,,,20,"char* ngx_http_auth_basic_merge_loc_conf (ngx_conf_t*,void*,void*)"
100510,METHOD,http\modules\ngx_http_auth_basic_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_auth_basic_init(ngx_conf_t *cf)
{
    ngx_http_handler_pt        *h;
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);

    h = ngx_array_push(&cmcf->phases[NGX_HTTP_ACCESS_PHASE].handlers);
    if (h == NULL) {
        return NGX_ERROR;
    }

    *h = ngx_http_auth_basic_handler;

    return NGX_OK;
}",1,1,http\modules\ngx_http_auth_basic_module.c,ngx_http_auth_basic_init,,false,382,398,ngx_http_auth_basic_init,,,21,ngx_int_t ngx_http_auth_basic_init (ngx_conf_t*)
100546,METHOD,http\modules\ngx_http_auth_basic_module.c:<global>,TYPE_DECL,"static char *
ngx_http_auth_basic_user_file(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_auth_basic_loc_conf_t *alcf = conf;

    ngx_str_t                         *value;
    ngx_http_compile_complex_value_t   ccv;

    if (alcf->user_file.value.data) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    ngx_memzero(&ccv, sizeof(ngx_http_compile_complex_value_t));

    ccv.cf = cf;
    ccv.value = &value[1];
    ccv.complex_value = &alcf->user_file;
    ccv.zero = 1;
    ccv.conf_prefix = 1;

    if (ngx_http_compile_complex_value(&ccv) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_auth_basic_module.c,ngx_http_auth_basic_user_file,,false,401,428,ngx_http_auth_basic_user_file,,,22,"char* ngx_http_auth_basic_user_file (ngx_conf_t*,ngx_command_t*,void*)"
100633,METHOD,http\modules\ngx_http_auth_request_module.c:<global>,TYPE_DECL,<global>,1,1,http\modules\ngx_http_auth_request_module.c,http\modules\ngx_http_auth_request_module.c:<global>,,false,1,444,<global>,,,1,
100649,METHOD,http\modules\ngx_http_auth_request_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_auth_request_handler(ngx_http_request_t *r);,18,69,http\modules\ngx_http_auth_request_module.c,ngx_http_auth_request_handler,,false,33,33,ngx_http_auth_request_handler,,,7,ngx_int_t ngx_http_auth_request_handler (ngx_http_request_t*)
100654,METHOD,http\modules\ngx_http_auth_request_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_auth_request_done(ngx_http_request_t *r,
    void *data, ngx_int_t rc);",18,29,http\modules\ngx_http_auth_request_module.c,ngx_http_auth_request_done,,false,34,35,ngx_http_auth_request_done,,,8,"ngx_int_t ngx_http_auth_request_done (ngx_http_request_t*,void*,ngx_int_t)"
100661,METHOD,http\modules\ngx_http_auth_request_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_auth_request_set_variables(ngx_http_request_t *r,
    ngx_http_auth_request_conf_t *arcf, ngx_http_auth_request_ctx_t *ctx);",18,73,http\modules\ngx_http_auth_request_module.c,ngx_http_auth_request_set_variables,,false,36,37,ngx_http_auth_request_set_variables,,,9,"ngx_int_t ngx_http_auth_request_set_variables (ngx_http_request_t*,ngx_http_auth_request_conf_t*,ngx_http_auth_request_ctx_t*)"
100668,METHOD,http\modules\ngx_http_auth_request_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_auth_request_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\modules\ngx_http_auth_request_module.c,ngx_http_auth_request_variable,,false,38,39,ngx_http_auth_request_variable,,,10,"ngx_int_t ngx_http_auth_request_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
100675,METHOD,http\modules\ngx_http_auth_request_module.c:<global>,TYPE_DECL,static void *ngx_http_auth_request_create_conf(ngx_conf_t *cf);,13,62,http\modules\ngx_http_auth_request_module.c,ngx_http_auth_request_create_conf,,false,40,40,ngx_http_auth_request_create_conf,,,11,void* ngx_http_auth_request_create_conf (ngx_conf_t*)
100680,METHOD,http\modules\ngx_http_auth_request_module.c:<global>,TYPE_DECL,"static char *ngx_http_auth_request_merge_conf(ngx_conf_t *cf,
    void *parent, void *child);",13,30,http\modules\ngx_http_auth_request_module.c,ngx_http_auth_request_merge_conf,,false,41,42,ngx_http_auth_request_merge_conf,,,12,"char* ngx_http_auth_request_merge_conf (ngx_conf_t*,void*,void*)"
100687,METHOD,http\modules\ngx_http_auth_request_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_auth_request_init(ngx_conf_t *cf);,18,59,http\modules\ngx_http_auth_request_module.c,ngx_http_auth_request_init,,false,43,43,ngx_http_auth_request_init,,,13,ngx_int_t ngx_http_auth_request_init (ngx_conf_t*)
100692,METHOD,http\modules\ngx_http_auth_request_module.c:<global>,TYPE_DECL,"static char *ngx_http_auth_request(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_auth_request_module.c,ngx_http_auth_request,,false,44,45,ngx_http_auth_request,,,14,"char* ngx_http_auth_request (ngx_conf_t*,ngx_command_t*,void*)"
100699,METHOD,http\modules\ngx_http_auth_request_module.c:<global>,TYPE_DECL,"static char *ngx_http_auth_request_set(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_auth_request_module.c,ngx_http_auth_request_set,,false,46,47,ngx_http_auth_request_set,,,15,"char* ngx_http_auth_request_set (ngx_conf_t*,ngx_command_t*,void*)"
100768,METHOD,http\modules\ngx_http_auth_request_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_auth_request_handler(ngx_http_request_t *r)
{
    ngx_table_elt_t               *h, *ho;
    ngx_http_request_t            *sr;
    ngx_http_post_subrequest_t    *ps;
    ngx_http_auth_request_ctx_t   *ctx;
    ngx_http_auth_request_conf_t  *arcf;

    arcf = ngx_http_get_module_loc_conf(r, ngx_http_auth_request_module);

    if (arcf->uri.len == 0) {
        return NGX_DECLINED;
    }

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""auth request handler"");

    ctx = ngx_http_get_module_ctx(r, ngx_http_auth_request_module);

    if (ctx != NULL) {
        if (!ctx->done) {
            return NGX_AGAIN;
        }

        /*
         * as soon as we are done - explicitly set variables to make
         * sure they will be available after internal redirects
         */

        if (ngx_http_auth_request_set_variables(r, arcf, ctx) != NGX_OK) {
            return NGX_ERROR;
        }

        /* return appropriate status */

 ...",1,1,http\modules\ngx_http_auth_request_module.c,ngx_http_auth_request_handler,,false,101,213,ngx_http_auth_request_handler,,,22,ngx_int_t ngx_http_auth_request_handler (ngx_http_request_t*)
101035,METHOD,http\modules\ngx_http_auth_request_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_auth_request_done(ngx_http_request_t *r, void *data, ngx_int_t rc)
{
    ngx_http_auth_request_ctx_t   *ctx = data;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""auth request done s:%ui"", r->headers_out.status);

    ctx->done = 1;
    ctx->status = r->headers_out.status;

    return rc;
}",1,1,http\modules\ngx_http_auth_request_module.c,ngx_http_auth_request_done,,false,216,228,ngx_http_auth_request_done,,,23,"ngx_int_t ngx_http_auth_request_done (ngx_http_request_t*,void*,ngx_int_t)"
101076,METHOD,http\modules\ngx_http_auth_request_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_auth_request_set_variables(ngx_http_request_t *r,
    ngx_http_auth_request_conf_t *arcf, ngx_http_auth_request_ctx_t *ctx)
{
    ngx_str_t                          val;
    ngx_http_variable_t               *v;
    ngx_http_variable_value_t         *vv;
    ngx_http_auth_request_variable_t  *av, *last;
    ngx_http_core_main_conf_t         *cmcf;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""auth request set variables"");

    if (arcf->vars == NULL) {
        return NGX_OK;
    }

    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);
    v = cmcf->variables.elts;

    av = arcf->vars->elts;
    last = av + arcf->vars->nelts;

    while (av < last) {
        /*
         * explicitly set new value to make sure it will be available after
         * internal redirects
         */

        vv = &r->variables[av->index];

        if (ngx_http_complex_value(ctx->subrequest, &av->value, &val)
            != NGX_OK)...",1,1,http\modules\ngx_http_auth_request_module.c,ngx_http_auth_request_set_variables,,false,231,286,ngx_http_auth_request_set_variables,,,24,"ngx_int_t ngx_http_auth_request_set_variables (ngx_http_request_t*,ngx_http_auth_request_conf_t*,ngx_http_auth_request_ctx_t*)"
101212,METHOD,http\modules\ngx_http_auth_request_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_auth_request_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""auth request variable"");

    v->not_found = 1;

    return NGX_OK;
}",1,1,http\modules\ngx_http_auth_request_module.c,ngx_http_auth_request_variable,,false,289,299,ngx_http_auth_request_variable,,,25,"ngx_int_t ngx_http_auth_request_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
101235,METHOD,http\modules\ngx_http_auth_request_module.c:<global>,TYPE_DECL,"static void *
ngx_http_auth_request_create_conf(ngx_conf_t *cf)
{
    ngx_http_auth_request_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_auth_request_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     conf->uri = { 0, NULL };
     */

    conf->vars = NGX_CONF_UNSET_PTR;

    return conf;
}",1,1,http\modules\ngx_http_auth_request_module.c,ngx_http_auth_request_create_conf,,false,302,321,ngx_http_auth_request_create_conf,,,26,void* ngx_http_auth_request_create_conf (ngx_conf_t*)
101263,METHOD,http\modules\ngx_http_auth_request_module.c:<global>,TYPE_DECL,"static char *
ngx_http_auth_request_merge_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_auth_request_conf_t *prev = parent;
    ngx_http_auth_request_conf_t *conf = child;

    ngx_conf_merge_str_value(conf->uri, prev->uri, """");
    ngx_conf_merge_ptr_value(conf->vars, prev->vars, NULL);

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_auth_request_module.c,ngx_http_auth_request_merge_conf,,false,324,334,ngx_http_auth_request_merge_conf,,,27,"char* ngx_http_auth_request_merge_conf (ngx_conf_t*,void*,void*)"
101296,METHOD,http\modules\ngx_http_auth_request_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_auth_request_init(ngx_conf_t *cf)
{
    ngx_http_handler_pt        *h;
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);

    h = ngx_array_push(&cmcf->phases[NGX_HTTP_ACCESS_PHASE].handlers);
    if (h == NULL) {
        return NGX_ERROR;
    }

    *h = ngx_http_auth_request_handler;

    return NGX_OK;
}",1,1,http\modules\ngx_http_auth_request_module.c,ngx_http_auth_request_init,,false,337,353,ngx_http_auth_request_init,,,28,ngx_int_t ngx_http_auth_request_init (ngx_conf_t*)
101332,METHOD,http\modules\ngx_http_auth_request_module.c:<global>,TYPE_DECL,"static char *
ngx_http_auth_request(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_auth_request_conf_t *arcf = conf;

    ngx_str_t        *value;

    if (arcf->uri.data != NULL) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    if (ngx_strcmp(value[1].data, ""off"") == 0) {
        arcf->uri.len = 0;
        arcf->uri.data = (u_char *) """";

        return NGX_CONF_OK;
    }

    arcf->uri = value[1];

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_auth_request_module.c,ngx_http_auth_request,,false,356,379,ngx_http_auth_request,,,29,"char* ngx_http_auth_request (ngx_conf_t*,ngx_command_t*,void*)"
101400,METHOD,http\modules\ngx_http_auth_request_module.c:<global>,TYPE_DECL,"static char *
ngx_http_auth_request_set(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_auth_request_conf_t *arcf = conf;

    ngx_str_t                         *value;
    ngx_http_variable_t               *v;
    ngx_http_auth_request_variable_t  *av;
    ngx_http_compile_complex_value_t   ccv;

    value = cf->args->elts;

    if (value[1].data[0] != '$') {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""invalid variable name \""%V\"""", &value[1]);
        return NGX_CONF_ERROR;
    }

    value[1].len--;
    value[1].data++;

    if (arcf->vars == NGX_CONF_UNSET_PTR) {
        arcf->vars = ngx_array_create(cf->pool, 1,
                                      sizeof(ngx_http_auth_request_variable_t));
        if (arcf->vars == NULL) {
            return NGX_CONF_ERROR;
        }
    }

    av = ngx_array_push(arcf->vars);
    if (av == NULL) {
        return NGX_CONF_ERROR;
    }

    v = ngx_http_add_variable(cf, &value[1], NGX_HTTP_VAR_CH...",1,1,http\modules\ngx_http_auth_request_module.c,ngx_http_auth_request_set,,false,382,444,ngx_http_auth_request_set,,,30,"char* ngx_http_auth_request_set (ngx_conf_t*,ngx_command_t*,void*)"
101603,METHOD,http\modules\ngx_http_autoindex_module.c:<global>,TYPE_DECL,<global>,1,26,http\modules\ngx_http_autoindex_module.c,http\modules\ngx_http_autoindex_module.c:<global>,,false,1,1072,<global>,,,1,
101621,METHOD,http\modules\ngx_http_autoindex_module.c:<global>,TYPE_DECL,"static ngx_buf_t *ngx_http_autoindex_html(ngx_http_request_t *r,
    ngx_array_t *entries);",18,25,http\modules\ngx_http_autoindex_module.c,ngx_http_autoindex_html,,false,58,59,ngx_http_autoindex_html,,,5,"ngx_buf_t* ngx_http_autoindex_html (ngx_http_request_t*,ngx_array_t*)"
101627,METHOD,http\modules\ngx_http_autoindex_module.c:<global>,TYPE_DECL,"static ngx_buf_t *ngx_http_autoindex_json(ngx_http_request_t *r,
    ngx_array_t *entries, ngx_str_t *callback);",18,46,http\modules\ngx_http_autoindex_module.c,ngx_http_autoindex_json,,false,60,61,ngx_http_autoindex_json,,,6,"ngx_buf_t* ngx_http_autoindex_json (ngx_http_request_t*,ngx_array_t*,ngx_str_t*)"
101634,METHOD,http\modules\ngx_http_autoindex_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_autoindex_jsonp_callback(ngx_http_request_t *r,
    ngx_str_t *callback);",18,24,http\modules\ngx_http_autoindex_module.c,ngx_http_autoindex_jsonp_callback,,false,62,63,ngx_http_autoindex_jsonp_callback,,,7,"ngx_int_t ngx_http_autoindex_jsonp_callback (ngx_http_request_t*,ngx_str_t*)"
101640,METHOD,http\modules\ngx_http_autoindex_module.c:<global>,TYPE_DECL,"static ngx_buf_t *ngx_http_autoindex_xml(ngx_http_request_t *r,
    ngx_array_t *entries);",18,25,http\modules\ngx_http_autoindex_module.c,ngx_http_autoindex_xml,,false,64,65,ngx_http_autoindex_xml,,,8,"ngx_buf_t* ngx_http_autoindex_xml (ngx_http_request_t*,ngx_array_t*)"
101647,METHOD,http\modules\ngx_http_autoindex_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_autoindex_error(ngx_http_request_t *r,
    ngx_dir_t *dir, ngx_str_t *name);",18,36,http\modules\ngx_http_autoindex_module.c,ngx_http_autoindex_error,,false,69,70,ngx_http_autoindex_error,,,10,"ngx_int_t ngx_http_autoindex_error (ngx_http_request_t*,ngx_dir_t*,ngx_str_t*)"
101654,METHOD,http\modules\ngx_http_autoindex_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_autoindex_init(ngx_conf_t *cf);,18,56,http\modules\ngx_http_autoindex_module.c,ngx_http_autoindex_init,,false,72,72,ngx_http_autoindex_init,,,11,ngx_int_t ngx_http_autoindex_init (ngx_conf_t*)
101659,METHOD,http\modules\ngx_http_autoindex_module.c:<global>,TYPE_DECL,static void *ngx_http_autoindex_create_loc_conf(ngx_conf_t *cf);,13,63,http\modules\ngx_http_autoindex_module.c,ngx_http_autoindex_create_loc_conf,,false,73,73,ngx_http_autoindex_create_loc_conf,,,12,void* ngx_http_autoindex_create_loc_conf (ngx_conf_t*)
101664,METHOD,http\modules\ngx_http_autoindex_module.c:<global>,TYPE_DECL,"static char *ngx_http_autoindex_merge_loc_conf(ngx_conf_t *cf,
    void *parent, void *child);",13,30,http\modules\ngx_http_autoindex_module.c,ngx_http_autoindex_merge_loc_conf,,false,74,75,ngx_http_autoindex_merge_loc_conf,,,13,"char* ngx_http_autoindex_merge_loc_conf (ngx_conf_t*,void*,void*)"
101801,METHOD,http\modules\ngx_http_autoindex_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_autoindex_handler(ngx_http_request_t *r)
{
    u_char                         *last, *filename;
    size_t                          len, allocated, root;
    ngx_err_t                       err;
    ngx_buf_t                      *b;
    ngx_int_t                       rc;
    ngx_str_t                       path, callback;
    ngx_dir_t                       dir;
    ngx_uint_t                      level, format;
    ngx_pool_t                     *pool;
    ngx_chain_t                     out;
    ngx_array_t                     entries;
    ngx_http_autoindex_entry_t     *entry;
    ngx_http_autoindex_loc_conf_t  *alcf;

    if (r->uri.data[r->uri.len - 1] != '/') {
        return NGX_DECLINED;
    }

    if (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD))) {
        return NGX_DECLINED;
    }

    alcf = ngx_http_get_module_loc_conf(r, ngx_http_autoindex_module);

    if (!alcf->enable) {
        return NGX_DECLINED;
    }

    rc = ngx_http_discard_request...",1,36,http\modules\ngx_http_autoindex_module.c,ngx_http_autoindex_handler,,false,152,429,ngx_http_autoindex_handler,,,22,ngx_int_t ngx_http_autoindex_handler (ngx_http_request_t*)
102567,METHOD,http\modules\ngx_http_autoindex_module.c:<global>,TYPE_DECL,"static ngx_buf_t *
ngx_http_autoindex_html(ngx_http_request_t *r, ngx_array_t *entries)
{
    u_char                         *last, scale;
    off_t                           length;
    size_t                          len, entry_len, char_len, escape_html;
    ngx_tm_t                        tm;
    ngx_buf_t                      *b;
    ngx_int_t                       size;
    ngx_uint_t                      i, utf8;
    ngx_time_t                     *tp;
    ngx_http_autoindex_entry_t     *entry;
    ngx_http_autoindex_loc_conf_t  *alcf;

    static u_char  title[] =
        ""<html>"" CRLF
        ""<head><title>Index of ""
    ;

    static u_char  header[] =
        ""</title></head>"" CRLF
        ""<body>"" CRLF
        ""<h1>Index of ""
    ;

    static u_char  tail[] =
        ""</body>"" CRLF
        ""</html>"" CRLF
    ;

    static char  *months[] = { ""Jan"", ""Feb"", ""Mar"", ""Apr"", ""May"", ""Jun"",
                               ""Jul"", ""Aug"", ""Sep"", ""Oct"", ""Nov"", ""Dec"" };

    if (r->h...",1,20,http\modules\ngx_http_autoindex_module.c,ngx_http_autoindex_html,,false,432,699,ngx_http_autoindex_html,,,23,"ngx_buf_t ngx_http_autoindex_html (ngx_http_request_t*,ngx_array_t*)"
103728,METHOD,http\modules\ngx_http_autoindex_module.c:<global>,TYPE_DECL,"static ngx_buf_t *
ngx_http_autoindex_json(ngx_http_request_t *r, ngx_array_t *entries,
    ngx_str_t *callback)
{
    size_t                       len, entry_len;
    ngx_buf_t                   *b;
    ngx_uint_t                   i;
    ngx_http_autoindex_entry_t  *entry;

    len = sizeof(""["" CRLF CRLF ""]"") - 1;

    if (callback) {
        len += sizeof(""/* callback */"" CRLF ""();"") - 1 + callback->len;
    }

    entry = entries->elts;

    for (i = 0; i < entries->nelts; i++) {
        entry[i].escape = ngx_escape_json(NULL, entry[i].name.data,
                                          entry[i].name.len);

        entry_len = sizeof(""{  },"" CRLF) - 1
                  + sizeof(""\""name\"":\""\"""") - 1
                  + entry[i].name.len + entry[i].escape
                  + sizeof("", \""type\"":\""directory\"""") - 1
                  + sizeof("", \""mtime\"":\""Wed, 31 Dec 1986 10:00:00 GMT\"""") - 1;

        if (entry[i].file) {
            entry_len += sizeof("", \""size\"":"") - 1 + NGX_O...",1,1,http\modules\ngx_http_autoindex_module.c,ngx_http_autoindex_json,,false,702,809,ngx_http_autoindex_json,,,24,"ngx_buf_t ngx_http_autoindex_json (ngx_http_request_t*,ngx_array_t*,ngx_str_t*)"
104109,METHOD,http\modules\ngx_http_autoindex_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_autoindex_jsonp_callback(ngx_http_request_t *r, ngx_str_t *callback)
{
    u_char      *p, c, ch;
    ngx_uint_t   i;

    if (ngx_http_arg(r, (u_char *) ""callback"", 8, callback) != NGX_OK) {
        callback->len = 0;
        return NGX_OK;
    }

    if (callback->len > 128) {
        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
                      ""client sent too long callback name: \""%V\"""", callback);
        return NGX_DECLINED;
    }

    p = callback->data;

    for (i = 0; i < callback->len; i++) {
        ch = p[i];

        c = (u_char) (ch | 0x20);
        if (c >= 'a' && c <= 'z') {
            continue;
        }

        if ((ch >= '0' && ch <= '9') || ch == '_' || ch == '.') {
            continue;
        }

        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
                      ""client sent invalid callback name: \""%V\"""", callback);

        return NGX_DECLINED;
    }

    return NGX_OK;
}",1,1,http\modules\ngx_http_autoindex_module.c,ngx_http_autoindex_jsonp_callback,,false,812,850,ngx_http_autoindex_jsonp_callback,,,25,"ngx_int_t ngx_http_autoindex_jsonp_callback (ngx_http_request_t*,ngx_str_t*)"
104227,METHOD,http\modules\ngx_http_autoindex_module.c:<global>,TYPE_DECL,"static ngx_buf_t *
ngx_http_autoindex_xml(ngx_http_request_t *r, ngx_array_t *entries)
{
    size_t                          len, entry_len;
    ngx_tm_t                        tm;
    ngx_buf_t                      *b;
    ngx_str_t                       type;
    ngx_uint_t                      i;
    ngx_http_autoindex_entry_t     *entry;

    static u_char  head[] = ""<?xml version=\""1.0\""?>"" CRLF ""<list>"" CRLF;
    static u_char  tail[] = ""</list>"" CRLF;

    len = sizeof(head) - 1 + sizeof(tail) - 1;

    entry = entries->elts;

    for (i = 0; i < entries->nelts; i++) {
        entry[i].escape = ngx_escape_html(NULL, entry[i].name.data,
                                          entry[i].name.len);

        entry_len = sizeof(""<directory></directory>"" CRLF) - 1
                  + entry[i].name.len + entry[i].escape
                  + sizeof("" mtime=\""1986-12-31T10:00:00Z\"""") - 1;

        if (entry[i].file) {
            entry_len += sizeof("" size=\""\"""") - 1 + NGX_OFF_T_LEN;
...",1,1,http\modules\ngx_http_autoindex_module.c,ngx_http_autoindex_xml,,false,853,948,ngx_http_autoindex_xml,,,26,"ngx_buf_t ngx_http_autoindex_xml (ngx_http_request_t*,ngx_array_t*)"
104643,METHOD,http\modules\ngx_http_autoindex_module.c:<global>,TYPE_DECL,"ngx_http_autoindex_cmp_entries(const void *one, const void *two)
{
    ngx_http_autoindex_entry_t *first = (ngx_http_autoindex_entry_t *) one;
    ngx_http_autoindex_entry_t *second = (ngx_http_autoindex_entry_t *) two;

    if (first->dir && !second->dir) {
        /* move the directories to the start */
        return -1;
    }

    if (!first->dir && second->dir) {
        /* move the directories to the start */
        return 1;
    }

    return (int) ngx_strcmp(first->name.data, second->name.data);
}",1,1,http\modules\ngx_http_autoindex_module.c,ngx_http_autoindex_cmp_entries,,false,952,968,ngx_http_autoindex_cmp_entries,,,29,"ANY ngx_http_autoindex_cmp_entries (void*,void*)"
104700,METHOD,http\modules\ngx_http_autoindex_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_autoindex_error(ngx_http_request_t *r, ngx_dir_t *dir, ngx_str_t *name)
{
    if (ngx_close_dir(dir) == NGX_ERROR) {
        ngx_log_error(NGX_LOG_ALERT, r->connection->log, ngx_errno,
                      ngx_close_dir_n "" \""%V\"" failed"", name);
    }

    return r->header_sent ? NGX_ERROR : NGX_HTTP_INTERNAL_SERVER_ERROR;
}",1,1,http\modules\ngx_http_autoindex_module.c,ngx_http_autoindex_error,,false,1009,1018,ngx_http_autoindex_error,,,30,"ngx_int_t ngx_http_autoindex_error (ngx_http_request_t*,ngx_dir_t*,ngx_str_t*)"
104721,METHOD,http\modules\ngx_http_autoindex_module.c:<global>,TYPE_DECL,"static void *
ngx_http_autoindex_create_loc_conf(ngx_conf_t *cf)
{
    ngx_http_autoindex_loc_conf_t  *conf;

    conf = ngx_palloc(cf->pool, sizeof(ngx_http_autoindex_loc_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    conf->enable = NGX_CONF_UNSET;
    conf->format = NGX_CONF_UNSET_UINT;
    conf->localtime = NGX_CONF_UNSET;
    conf->exact_size = NGX_CONF_UNSET;

    return conf;
}",1,1,http\modules\ngx_http_autoindex_module.c,ngx_http_autoindex_create_loc_conf,,false,1021,1037,ngx_http_autoindex_create_loc_conf,,,31,void* ngx_http_autoindex_create_loc_conf (ngx_conf_t*)
104764,METHOD,http\modules\ngx_http_autoindex_module.c:<global>,TYPE_DECL,"static char *
ngx_http_autoindex_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_autoindex_loc_conf_t *prev = parent;
    ngx_http_autoindex_loc_conf_t *conf = child;

    ngx_conf_merge_value(conf->enable, prev->enable, 0);
    ngx_conf_merge_uint_value(conf->format, prev->format,
                              NGX_HTTP_AUTOINDEX_HTML);
    ngx_conf_merge_value(conf->localtime, prev->localtime, 0);
    ngx_conf_merge_value(conf->exact_size, prev->exact_size, 1);

    return NGX_CONF_OK;
}",1,30,http\modules\ngx_http_autoindex_module.c,ngx_http_autoindex_merge_loc_conf,,false,1040,1053,ngx_http_autoindex_merge_loc_conf,,,32,"char* ngx_http_autoindex_merge_loc_conf (ngx_conf_t*,void*,void*)"
104815,METHOD,http\modules\ngx_http_autoindex_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_autoindex_init(ngx_conf_t *cf)
{
    ngx_http_handler_pt        *h;
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);

    h = ngx_array_push(&cmcf->phases[NGX_HTTP_CONTENT_PHASE].handlers);
    if (h == NULL) {
        return NGX_ERROR;
    }

    *h = ngx_http_autoindex_handler;

    return NGX_OK;
}",1,1,http\modules\ngx_http_autoindex_module.c,ngx_http_autoindex_init,,false,1056,1072,ngx_http_autoindex_init,,,33,ngx_int_t ngx_http_autoindex_init (ngx_conf_t*)
104860,METHOD,http\modules\ngx_http_browser_module.c:<global>,TYPE_DECL,<global>,1,6,http\modules\ngx_http_browser_module.c,http\modules\ngx_http_browser_module.c:<global>,,false,1,712,<global>,,,1,
104867,METHOD,<empty>,<empty>,<empty>,1,,http\modules\ngx_http_browser_module.c,ngx_http_modern_browser_mask_t:<clinit>,,false,24,,<clinit>,,,5,
104881,METHOD,<empty>,<empty>,<empty>,1,,http\modules\ngx_http_browser_module.c,ngx_http_modern_browser_t:<clinit>,,false,32,,<clinit>,,,5,
104896,METHOD,http\modules\ngx_http_browser_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_msie_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\modules\ngx_http_browser_module.c,ngx_http_msie_variable,,false,51,52,ngx_http_msie_variable,,,7,"ngx_int_t ngx_http_msie_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
104903,METHOD,http\modules\ngx_http_browser_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_browser_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\modules\ngx_http_browser_module.c,ngx_http_browser_variable,,false,53,54,ngx_http_browser_variable,,,8,"ngx_int_t ngx_http_browser_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
104910,METHOD,http\modules\ngx_http_browser_module.c:<global>,TYPE_DECL,"static ngx_uint_t ngx_http_browser(ngx_http_request_t *r,
    ngx_http_browser_conf_t *cf);",19,32,http\modules\ngx_http_browser_module.c,ngx_http_browser,,false,56,57,ngx_http_browser,,,9,"ngx_uint_t ngx_http_browser (ngx_http_request_t*,ngx_http_browser_conf_t*)"
104916,METHOD,http\modules\ngx_http_browser_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_browser_add_variables(ngx_conf_t *cf);,18,63,http\modules\ngx_http_browser_module.c,ngx_http_browser_add_variables,,false,59,59,ngx_http_browser_add_variables,,,10,ngx_int_t ngx_http_browser_add_variables (ngx_conf_t*)
104921,METHOD,http\modules\ngx_http_browser_module.c:<global>,TYPE_DECL,static void *ngx_http_browser_create_conf(ngx_conf_t *cf);,13,57,http\modules\ngx_http_browser_module.c,ngx_http_browser_create_conf,,false,60,60,ngx_http_browser_create_conf,,,11,void* ngx_http_browser_create_conf (ngx_conf_t*)
104926,METHOD,http\modules\ngx_http_browser_module.c:<global>,TYPE_DECL,"static char *ngx_http_browser_merge_conf(ngx_conf_t *cf, void *parent,
    void *child);",13,16,http\modules\ngx_http_browser_module.c,ngx_http_browser_merge_conf,,false,61,62,ngx_http_browser_merge_conf,,,12,"char* ngx_http_browser_merge_conf (ngx_conf_t*,void*,void*)"
104934,METHOD,http\modules\ngx_http_browser_module.c:<global>,TYPE_DECL,"static char *ngx_http_modern_browser(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_browser_module.c,ngx_http_modern_browser,,false,65,66,ngx_http_modern_browser,,,14,"char* ngx_http_modern_browser (ngx_conf_t*,ngx_command_t*,void*)"
104941,METHOD,http\modules\ngx_http_browser_module.c:<global>,TYPE_DECL,"static char *ngx_http_ancient_browser(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_browser_module.c,ngx_http_ancient_browser,,false,67,68,ngx_http_ancient_browser,,,15,"char* ngx_http_ancient_browser (ngx_conf_t*,ngx_command_t*,void*)"
104948,METHOD,http\modules\ngx_http_browser_module.c:<global>,TYPE_DECL,"static char *ngx_http_modern_browser_value(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_browser_module.c,ngx_http_modern_browser_value,,false,69,70,ngx_http_modern_browser_value,,,16,"char* ngx_http_modern_browser_value (ngx_conf_t*,ngx_command_t*,void*)"
104955,METHOD,http\modules\ngx_http_browser_module.c:<global>,TYPE_DECL,"static char *ngx_http_ancient_browser_value(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_browser_module.c,ngx_http_ancient_browser_value,,false,71,72,ngx_http_ancient_browser_value,,,17,"char* ngx_http_ancient_browser_value (ngx_conf_t*,ngx_command_t*,void*)"
105146,METHOD,http\modules\ngx_http_browser_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_browser_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v,
    uintptr_t data)
{
    ngx_uint_t                rc;
    ngx_http_browser_conf_t  *cf;

    cf = ngx_http_get_module_loc_conf(r, ngx_http_browser_module);

    rc = ngx_http_browser(r, cf);

    if (data == NGX_HTTP_MODERN_BROWSER && rc == NGX_HTTP_MODERN_BROWSER) {
        *v = *cf->modern_browser_value;
        return NGX_OK;
    }

    if (data == NGX_HTTP_ANCIENT_BROWSER && rc == NGX_HTTP_ANCIENT_BROWSER) {
        *v = *cf->ancient_browser_value;
        return NGX_OK;
    }

    *v = ngx_http_variable_null_value;
    return NGX_OK;
}",1,16,http\modules\ngx_http_browser_module.c,ngx_http_browser_variable,,false,229,252,ngx_http_browser_variable,,,28,"ngx_int_t ngx_http_browser_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
105215,METHOD,http\modules\ngx_http_browser_module.c:<global>,TYPE_DECL,"static ngx_uint_t
ngx_http_browser(ngx_http_request_t *r, ngx_http_browser_conf_t *cf)
{
    size_t                      len;
    u_char                     *name, *ua, *last, c;
    ngx_str_t                  *ancient;
    ngx_uint_t                  i, version, ver, scale;
    ngx_http_modern_browser_t  *modern;

    if (r->headers_in.user_agent == NULL) {
        if (cf->modern_unlisted_browsers) {
            return NGX_HTTP_MODERN_BROWSER;
        }

        return NGX_HTTP_ANCIENT_BROWSER;
    }

    ua = r->headers_in.user_agent->value.data;
    len = r->headers_in.user_agent->value.len;
    last = ua + len;

    if (cf->modern_browsers) {
        modern = cf->modern_browsers->elts;

        for (i = 0; i < cf->modern_browsers->nelts; i++) {
            name = ua + modern[i].skip;

            if (name >= last) {
                continue;
            }

            name = (u_char *) ngx_strstr(name, modern[i].name);

            if (name == NULL) {
                continue;
 ...",1,19,http\modules\ngx_http_browser_module.c,ngx_http_browser,,false,255,380,ngx_http_browser,,,29,"ngx_uint_t ngx_http_browser (ngx_http_request_t*,ngx_http_browser_conf_t*)"
105611,METHOD,http\modules\ngx_http_browser_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_msie_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v,
    uintptr_t data)
{
    if (r->headers_in.msie) {
        *v = ngx_http_variable_true_value;
        return NGX_OK;
    }

    *v = ngx_http_variable_null_value;
    return NGX_OK;
}",1,1,http\modules\ngx_http_browser_module.c,ngx_http_msie_variable,,false,383,394,ngx_http_msie_variable,,,30,"ngx_int_t ngx_http_msie_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
105637,METHOD,http\modules\ngx_http_browser_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_browser_add_variables(ngx_conf_t *cf)
{
    ngx_http_variable_t  *var, *v;

    for (v = ngx_http_browser_vars; v->name.len; v++) {

        var = ngx_http_add_variable(cf, &v->name, v->flags);
        if (var == NULL) {
            return NGX_ERROR;
        }

        var->get_handler = v->get_handler;
        var->data = v->data;
    }

    return NGX_OK;
}",1,1,http\modules\ngx_http_browser_module.c,ngx_http_browser_add_variables,,false,397,414,ngx_http_browser_add_variables,,,31,ngx_int_t ngx_http_browser_add_variables (ngx_conf_t*)
105691,METHOD,http\modules\ngx_http_browser_module.c:<global>,TYPE_DECL,"static void *
ngx_http_browser_create_conf(ngx_conf_t *cf)
{
    ngx_http_browser_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_browser_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     conf->modern_browsers = NULL;
     *     conf->ancient_browsers = NULL;
     *     conf->modern_browser_value = NULL;
     *     conf->ancient_browser_value = NULL;
     *
     *     conf->modern_unlisted_browsers = 0;
     *     conf->netscape4 = 0;
     */

    return conf;
}",1,1,http\modules\ngx_http_browser_module.c,ngx_http_browser_create_conf,,false,417,440,ngx_http_browser_create_conf,,,32,void* ngx_http_browser_create_conf (ngx_conf_t*)
105714,METHOD,http\modules\ngx_http_browser_module.c:<global>,TYPE_DECL,"static char *
ngx_http_browser_merge_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_browser_conf_t *prev = parent;
    ngx_http_browser_conf_t *conf = child;

    ngx_uint_t                  i, n;
    ngx_http_modern_browser_t  *browsers, *opera;

    /*
     * At the merge the skip field is used to store the browser slot,
     * it will be used in sorting and then will overwritten
     * with a real skip value.  The zero value means Opera.
     */

    if (conf->modern_browsers == NULL && conf->modern_unlisted_browsers == 0) {
        conf->modern_browsers = prev->modern_browsers;
        conf->modern_unlisted_browsers = prev->modern_unlisted_browsers;

    } else if (conf->modern_browsers != NULL) {
        browsers = conf->modern_browsers->elts;

        for (i = 0; i < conf->modern_browsers->nelts; i++) {
            if (browsers[i].skip == 0) {
                goto found;
            }
        }

        /*
         * Opera may contain MSIE string, so if Opera w...",1,1,http\modules\ngx_http_browser_module.c,ngx_http_browser_merge_conf,,false,443,524,ngx_http_browser_merge_conf,,,33,"char* ngx_http_browser_merge_conf (ngx_conf_t*,void*,void*)"
105987,METHOD,http\modules\ngx_http_browser_module.c:<global>,TYPE_DECL,"ngx_http_modern_browser_sort(const void *one, const void *two)
{
    ngx_http_modern_browser_t *first = (ngx_http_modern_browser_t *) one;
    ngx_http_modern_browser_t *second = (ngx_http_modern_browser_t *) two;

    return (first->skip - second->skip);
}",1,1,http\modules\ngx_http_browser_module.c,ngx_http_modern_browser_sort,,false,528,534,ngx_http_modern_browser_sort,,,36,"ANY ngx_http_modern_browser_sort (void*,void*)"
106013,METHOD,http\modules\ngx_http_browser_module.c:<global>,TYPE_DECL,"static char *
ngx_http_modern_browser(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_browser_conf_t *bcf = conf;

    u_char                           c;
    ngx_str_t                       *value;
    ngx_uint_t                       i, n, version, ver, scale;
    ngx_http_modern_browser_t       *browser;
    ngx_http_modern_browser_mask_t  *mask;

    value = cf->args->elts;

    if (cf->args->nelts == 2) {
        if (ngx_strcmp(value[1].data, ""unlisted"") == 0) {
            bcf->modern_unlisted_browsers = 1;
            return NGX_CONF_OK;
        }

        return NGX_CONF_ERROR;
    }

    if (bcf->modern_browsers == NULL) {
        bcf->modern_browsers = ngx_array_create(cf->pool, 5,
                                            sizeof(ngx_http_modern_browser_t));
        if (bcf->modern_browsers == NULL) {
            return NGX_CONF_ERROR;
        }
    }

    browser = ngx_array_push(bcf->modern_browsers);
    if (browser == NULL) {
        return NGX_CONF_ER...",1,1,http\modules\ngx_http_browser_module.c,ngx_http_modern_browser,,false,537,626,ngx_http_modern_browser,,,37,"char* ngx_http_modern_browser (ngx_conf_t*,ngx_command_t*,void*)"
106254,METHOD,http\modules\ngx_http_browser_module.c:<global>,TYPE_DECL,"static char *
ngx_http_ancient_browser(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_browser_conf_t *bcf = conf;

    ngx_str_t   *value, *browser;
    ngx_uint_t   i;

    value = cf->args->elts;

    for (i = 1; i < cf->args->nelts; i++) {
        if (ngx_strcmp(value[i].data, ""netscape4"") == 0) {
            bcf->netscape4 = 1;
            continue;
        }

        if (bcf->ancient_browsers == NULL) {
            bcf->ancient_browsers = ngx_array_create(cf->pool, 4,
                                                     sizeof(ngx_str_t));
            if (bcf->ancient_browsers == NULL) {
                return NGX_CONF_ERROR;
            }
        }

        browser = ngx_array_push(bcf->ancient_browsers);
        if (browser == NULL) {
            return NGX_CONF_ERROR;
        }

        *browser = value[i];
    }

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_browser_module.c,ngx_http_ancient_browser,,false,629,662,ngx_http_ancient_browser,,,38,"char* ngx_http_ancient_browser (ngx_conf_t*,ngx_command_t*,void*)"
106355,METHOD,http\modules\ngx_http_browser_module.c:<global>,TYPE_DECL,"static char *
ngx_http_modern_browser_value(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_browser_conf_t *bcf = conf;

    ngx_str_t  *value;

    bcf->modern_browser_value = ngx_palloc(cf->pool,
                                           sizeof(ngx_http_variable_value_t));
    if (bcf->modern_browser_value == NULL) {
        return NGX_CONF_ERROR;
    }

    value = cf->args->elts;

    bcf->modern_browser_value->len = value[1].len;
    bcf->modern_browser_value->valid = 1;
    bcf->modern_browser_value->no_cacheable = 0;
    bcf->modern_browser_value->not_found = 0;
    bcf->modern_browser_value->data = value[1].data;

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_browser_module.c,ngx_http_modern_browser_value,,false,665,687,ngx_http_modern_browser_value,,,39,"char* ngx_http_modern_browser_value (ngx_conf_t*,ngx_command_t*,void*)"
106438,METHOD,http\modules\ngx_http_browser_module.c:<global>,TYPE_DECL,"static char *
ngx_http_ancient_browser_value(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_browser_conf_t *bcf = conf;

    ngx_str_t  *value;

    bcf->ancient_browser_value = ngx_palloc(cf->pool,
                                            sizeof(ngx_http_variable_value_t));
    if (bcf->ancient_browser_value == NULL) {
        return NGX_CONF_ERROR;
    }

    value = cf->args->elts;

    bcf->ancient_browser_value->len = value[1].len;
    bcf->ancient_browser_value->valid = 1;
    bcf->ancient_browser_value->no_cacheable = 0;
    bcf->ancient_browser_value->not_found = 0;
    bcf->ancient_browser_value->data = value[1].data;

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_browser_module.c,ngx_http_ancient_browser_value,,false,690,712,ngx_http_ancient_browser_value,,,40,"char* ngx_http_ancient_browser_value (ngx_conf_t*,ngx_command_t*,void*)"
106530,METHOD,http\modules\ngx_http_charset_filter_module.c:<global>,TYPE_DECL,<global>,1,38,http\modules\ngx_http_charset_filter_module.c,http\modules\ngx_http_charset_filter_module.c:<global>,,false,1,1685,<global>,,,1,
106572,METHOD,<empty>,<empty>,<empty>,1,,http\modules\ngx_http_charset_filter_module.c,ngx_http_charset_ctx_t:<clinit>,,false,63,,<clinit>,,,12,
106586,METHOD,http\modules\ngx_http_charset_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_destination_charset(ngx_http_request_t *r,
    ngx_str_t *name);",18,20,http\modules\ngx_http_charset_filter_module.c,ngx_http_destination_charset,,false,88,89,ngx_http_destination_charset,,,15,"ngx_int_t ngx_http_destination_charset (ngx_http_request_t*,ngx_str_t*)"
106592,METHOD,http\modules\ngx_http_charset_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_main_request_charset(ngx_http_request_t *r,
    ngx_str_t *name);",18,20,http\modules\ngx_http_charset_filter_module.c,ngx_http_main_request_charset,,false,90,91,ngx_http_main_request_charset,,,16,"ngx_int_t ngx_http_main_request_charset (ngx_http_request_t*,ngx_str_t*)"
106598,METHOD,http\modules\ngx_http_charset_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_source_charset(ngx_http_request_t *r,
    ngx_str_t *name);",18,20,http\modules\ngx_http_charset_filter_module.c,ngx_http_source_charset,,false,92,93,ngx_http_source_charset,,,17,"ngx_int_t ngx_http_source_charset (ngx_http_request_t*,ngx_str_t*)"
106604,METHOD,http\modules\ngx_http_charset_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_get_charset(ngx_http_request_t *r, ngx_str_t *name);",18,77,http\modules\ngx_http_charset_filter_module.c,ngx_http_get_charset,,false,94,94,ngx_http_get_charset,,,18,"ngx_int_t ngx_http_get_charset (ngx_http_request_t*,ngx_str_t*)"
106611,METHOD,http\modules\ngx_http_charset_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_charset_ctx(ngx_http_request_t *r,
    ngx_http_charset_t *charsets, ngx_int_t charset, ngx_int_t source_charset);",18,78,http\modules\ngx_http_charset_filter_module.c,ngx_http_charset_ctx,,false,97,98,ngx_http_charset_ctx,,,20,"ngx_int_t ngx_http_charset_ctx (ngx_http_request_t*,ngx_http_charset_t*,ngx_int_t,ngx_int_t)"
106619,METHOD,http\modules\ngx_http_charset_filter_module.c:<global>,TYPE_DECL,"static ngx_uint_t ngx_http_charset_recode(ngx_buf_t *b, u_char *table);",19,70,http\modules\ngx_http_charset_filter_module.c,ngx_http_charset_recode,,false,99,99,ngx_http_charset_recode,,,21,"ngx_uint_t ngx_http_charset_recode (ngx_buf_t*,u_char*)"
106625,METHOD,http\modules\ngx_http_charset_filter_module.c:<global>,TYPE_DECL,"static ngx_chain_t *ngx_http_charset_recode_from_utf8(ngx_pool_t *pool,
    ngx_buf_t *buf, ngx_http_charset_ctx_t *ctx);",20,48,http\modules\ngx_http_charset_filter_module.c,ngx_http_charset_recode_from_utf8,,false,100,101,ngx_http_charset_recode_from_utf8,,,22,"ngx_chain_t* ngx_http_charset_recode_from_utf8 (ngx_pool_t*,ngx_buf_t*,ngx_http_charset_ctx_t*)"
106632,METHOD,http\modules\ngx_http_charset_filter_module.c:<global>,TYPE_DECL,"static ngx_chain_t *ngx_http_charset_recode_to_utf8(ngx_pool_t *pool,
    ngx_buf_t *buf, ngx_http_charset_ctx_t *ctx);",20,48,http\modules\ngx_http_charset_filter_module.c,ngx_http_charset_recode_to_utf8,,false,102,103,ngx_http_charset_recode_to_utf8,,,23,"ngx_chain_t* ngx_http_charset_recode_to_utf8 (ngx_pool_t*,ngx_buf_t*,ngx_http_charset_ctx_t*)"
106639,METHOD,http\modules\ngx_http_charset_filter_module.c:<global>,TYPE_DECL,"static ngx_chain_t *ngx_http_charset_get_buf(ngx_pool_t *pool,
    ngx_http_charset_ctx_t *ctx);",20,32,http\modules\ngx_http_charset_filter_module.c,ngx_http_charset_get_buf,,false,105,106,ngx_http_charset_get_buf,,,24,"ngx_chain_t* ngx_http_charset_get_buf (ngx_pool_t*,ngx_http_charset_ctx_t*)"
106645,METHOD,http\modules\ngx_http_charset_filter_module.c:<global>,TYPE_DECL,"static ngx_chain_t *ngx_http_charset_get_buffer(ngx_pool_t *pool,
    ngx_http_charset_ctx_t *ctx, size_t size);",20,45,http\modules\ngx_http_charset_filter_module.c,ngx_http_charset_get_buffer,,false,107,108,ngx_http_charset_get_buffer,,,25,"ngx_chain_t* ngx_http_charset_get_buffer (ngx_pool_t*,ngx_http_charset_ctx_t*,size_t)"
106652,METHOD,http\modules\ngx_http_charset_filter_module.c:<global>,TYPE_DECL,"static char *ngx_http_charset_map_block(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_charset_filter_module.c,ngx_http_charset_map_block,,false,110,111,ngx_http_charset_map_block,,,26,"char* ngx_http_charset_map_block (ngx_conf_t*,ngx_command_t*,void*)"
106659,METHOD,http\modules\ngx_http_charset_filter_module.c:<global>,TYPE_DECL,"static char *ngx_http_charset_map(ngx_conf_t *cf, ngx_command_t *dummy,
    void *conf);",13,15,http\modules\ngx_http_charset_filter_module.c,ngx_http_charset_map,,false,112,113,ngx_http_charset_map,,,27,"char* ngx_http_charset_map (ngx_conf_t*,ngx_command_t*,void*)"
106666,METHOD,http\modules\ngx_http_charset_filter_module.c:<global>,TYPE_DECL,"static char *ngx_http_set_charset_slot(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_charset_filter_module.c,ngx_http_set_charset_slot,,false,115,116,ngx_http_set_charset_slot,,,28,"char* ngx_http_set_charset_slot (ngx_conf_t*,ngx_command_t*,void*)"
106673,METHOD,http\modules\ngx_http_charset_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_add_charset(ngx_array_t *charsets, ngx_str_t *name);",18,77,http\modules\ngx_http_charset_filter_module.c,ngx_http_add_charset,,false,117,117,ngx_http_add_charset,,,29,"ngx_int_t ngx_http_add_charset (ngx_array_t*,ngx_str_t*)"
106679,METHOD,http\modules\ngx_http_charset_filter_module.c:<global>,TYPE_DECL,static void *ngx_http_charset_create_main_conf(ngx_conf_t *cf);,13,62,http\modules\ngx_http_charset_filter_module.c,ngx_http_charset_create_main_conf,,false,119,119,ngx_http_charset_create_main_conf,,,30,void* ngx_http_charset_create_main_conf (ngx_conf_t*)
106684,METHOD,http\modules\ngx_http_charset_filter_module.c:<global>,TYPE_DECL,static void *ngx_http_charset_create_loc_conf(ngx_conf_t *cf);,13,61,http\modules\ngx_http_charset_filter_module.c,ngx_http_charset_create_loc_conf,,false,120,120,ngx_http_charset_create_loc_conf,,,31,void* ngx_http_charset_create_loc_conf (ngx_conf_t*)
106689,METHOD,http\modules\ngx_http_charset_filter_module.c:<global>,TYPE_DECL,"static char *ngx_http_charset_merge_loc_conf(ngx_conf_t *cf,
    void *parent, void *child);",13,30,http\modules\ngx_http_charset_filter_module.c,ngx_http_charset_merge_loc_conf,,false,121,122,ngx_http_charset_merge_loc_conf,,,32,"char* ngx_http_charset_merge_loc_conf (ngx_conf_t*,void*,void*)"
106696,METHOD,http\modules\ngx_http_charset_filter_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_charset_postconfiguration(ngx_conf_t *cf);,18,67,http\modules\ngx_http_charset_filter_module.c,ngx_http_charset_postconfiguration,,false,123,123,ngx_http_charset_postconfiguration,,,33,ngx_int_t ngx_http_charset_postconfiguration (ngx_conf_t*)
106839,METHOD,http\modules\ngx_http_charset_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_charset_header_filter(ngx_http_request_t *r)
{
    ngx_int_t                      charset, source_charset;
    ngx_str_t                      dst, src;
    ngx_http_charset_t            *charsets;
    ngx_http_charset_main_conf_t  *mcf;

    if (r == r->main) {
        charset = ngx_http_destination_charset(r, &dst);

    } else {
        charset = ngx_http_main_request_charset(r, &dst);
    }

    if (charset == NGX_ERROR) {
        return NGX_ERROR;
    }

    if (charset == NGX_DECLINED) {
        return ngx_http_next_header_filter(r);
    }

    /* charset: charset index or NGX_HTTP_NO_CHARSET */

    source_charset = ngx_http_source_charset(r, &src);

    if (source_charset == NGX_ERROR) {
        return NGX_ERROR;
    }

    /*
     * source_charset: charset index, NGX_HTTP_NO_CHARSET,
     *                 or NGX_HTTP_CHARSET_OFF
     */

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""charset: \""%V\"" > \""%V\"""", &sr...",1,26,http\modules\ngx_http_charset_filter_module.c,ngx_http_charset_header_filter,,false,216,313,ngx_http_charset_header_filter,,,44,ngx_int_t ngx_http_charset_header_filter (ngx_http_request_t*)
107085,METHOD,http\modules\ngx_http_charset_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_destination_charset(ngx_http_request_t *r, ngx_str_t *name)
{
    ngx_int_t                      charset;
    ngx_http_charset_t            *charsets;
    ngx_http_variable_value_t     *vv;
    ngx_http_charset_loc_conf_t   *mlcf;
    ngx_http_charset_main_conf_t  *mcf;

    if (r->headers_out.content_type.len == 0) {
        return NGX_DECLINED;
    }

    if (r->headers_out.override_charset
        && r->headers_out.override_charset->len)
    {
        *name = *r->headers_out.override_charset;

        charset = ngx_http_get_charset(r, name);

        if (charset != NGX_HTTP_NO_CHARSET) {
            return charset;
        }

        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                      ""unknown charset \""%V\"" to override"", name);

        return NGX_DECLINED;
    }

    mlcf = ngx_http_get_module_loc_conf(r, ngx_http_charset_filter_module);
    charset = mlcf->charset;

    if (charset == NGX_HTTP_CHARSET_OFF) {
        return NGX_DECL...",1,23,http\modules\ngx_http_charset_filter_module.c,ngx_http_destination_charset,,false,316,381,ngx_http_destination_charset,,,45,"ngx_int_t ngx_http_destination_charset (ngx_http_request_t*,ngx_str_t*)"
107279,METHOD,http\modules\ngx_http_charset_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_main_request_charset(ngx_http_request_t *r, ngx_str_t *src)
{
    ngx_int_t                charset;
    ngx_str_t               *main_charset;
    ngx_http_charset_ctx_t  *ctx;

    ctx = ngx_http_get_module_ctx(r->main, ngx_http_charset_filter_module);

    if (ctx) {
        *src = ctx->charset_name;
        return ctx->charset;
    }

    main_charset = &r->main->headers_out.charset;

    if (main_charset->len == 0) {
        return NGX_DECLINED;
    }

    ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_charset_ctx_t));
    if (ctx == NULL) {
        return NGX_ERROR;
    }

    ngx_http_set_ctx(r->main, ctx, ngx_http_charset_filter_module);

    charset = ngx_http_get_charset(r, main_charset);

    ctx->charset = charset;
    ctx->charset_name = *main_charset;
    *src = *main_charset;

    return charset;
}",1,1,http\modules\ngx_http_charset_filter_module.c,ngx_http_main_request_charset,,false,384,418,ngx_http_main_request_charset,,,46,"ngx_int_t ngx_http_main_request_charset (ngx_http_request_t*,ngx_str_t*)"
107371,METHOD,http\modules\ngx_http_charset_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_source_charset(ngx_http_request_t *r, ngx_str_t *name)
{
    ngx_int_t                      charset;
    ngx_http_charset_t            *charsets;
    ngx_http_variable_value_t     *vv;
    ngx_http_charset_loc_conf_t   *lcf;
    ngx_http_charset_main_conf_t  *mcf;

    if (r->headers_out.charset.len) {
        *name = r->headers_out.charset;
        return ngx_http_get_charset(r, name);
    }

    lcf = ngx_http_get_module_loc_conf(r, ngx_http_charset_filter_module);

    charset = lcf->source_charset;

    if (charset == NGX_HTTP_CHARSET_OFF) {
        name->len = 0;
        return charset;
    }

    if (charset < NGX_HTTP_CHARSET_VAR) {
        mcf = ngx_http_get_module_main_conf(r, ngx_http_charset_filter_module);
        charsets = mcf->charsets.elts;
        *name = charsets[charset].name;
        return charset;
    }

    vv = ngx_http_get_indexed_variable(r, charset - NGX_HTTP_CHARSET_VAR);

    if (vv == NULL || vv->not_found) {
        return NGX...",1,19,http\modules\ngx_http_charset_filter_module.c,ngx_http_source_charset,,false,421,461,ngx_http_source_charset,,,47,"ngx_int_t ngx_http_source_charset (ngx_http_request_t*,ngx_str_t*)"
107495,METHOD,http\modules\ngx_http_charset_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_get_charset(ngx_http_request_t *r, ngx_str_t *name)
{
    ngx_uint_t                     i, n;
    ngx_http_charset_t            *charset;
    ngx_http_charset_main_conf_t  *mcf;

    mcf = ngx_http_get_module_main_conf(r, ngx_http_charset_filter_module);

    charset = mcf->charsets.elts;
    n = mcf->charsets.nelts;

    for (i = 0; i < n; i++) {
        if (charset[i].name.len != name->len) {
            continue;
        }

        if (ngx_strncasecmp(charset[i].name.data, name->data, name->len) == 0) {
            return i;
        }
    }

    return NGX_HTTP_NO_CHARSET;
}",1,11,http\modules\ngx_http_charset_filter_module.c,ngx_http_get_charset,,false,464,487,ngx_http_get_charset,,,48,"ngx_int_t ngx_http_get_charset (ngx_http_request_t*,ngx_str_t*)"
107575,METHOD,http\modules\ngx_http_charset_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_charset_ctx(ngx_http_request_t *r, ngx_http_charset_t *charsets,
    ngx_int_t charset, ngx_int_t source_charset)
{
    ngx_http_charset_ctx_t  *ctx;

    ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_charset_ctx_t));
    if (ctx == NULL) {
        return NGX_ERROR;
    }

    ngx_http_set_ctx(r, ctx, ngx_http_charset_filter_module);

    ctx->table = charsets[source_charset].tables[charset];
    ctx->charset = charset;
    ctx->charset_name = charsets[charset].name;
    ctx->length = charsets[charset].length;
    ctx->from_utf8 = charsets[source_charset].utf8;
    ctx->to_utf8 = charsets[charset].utf8;

    r->filter_need_in_memory = 1;

    if ((ctx->to_utf8 || ctx->from_utf8) && r == r->main) {
        ngx_http_clear_content_length(r);

    } else {
        r->filter_need_temporary = 1;
    }

    return ngx_http_next_header_filter(r);
}",1,1,http\modules\ngx_http_charset_filter_module.c,ngx_http_charset_ctx,,false,513,543,ngx_http_charset_ctx,,,50,"ngx_int_t ngx_http_charset_ctx (ngx_http_request_t*,ngx_http_charset_t*,ngx_int_t,ngx_int_t)"
107687,METHOD,http\modules\ngx_http_charset_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_charset_body_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    ngx_int_t                rc;
    ngx_buf_t               *b;
    ngx_chain_t             *cl, *out, **ll;
    ngx_http_charset_ctx_t  *ctx;

    ctx = ngx_http_get_module_ctx(r, ngx_http_charset_filter_module);

    if (ctx == NULL || ctx->table == NULL) {
        return ngx_http_next_body_filter(r, in);
    }

    if ((ctx->to_utf8 || ctx->from_utf8) || ctx->busy) {

        out = NULL;
        ll = &out;

        for (cl = in; cl; cl = cl->next) {
            b = cl->buf;

            if (ngx_buf_size(b) == 0) {

                *ll = ngx_alloc_chain_link(r->pool);
                if (*ll == NULL) {
                    return NGX_ERROR;
                }

                (*ll)->buf = b;
                (*ll)->next = NULL;

                ll = &(*ll)->next;

                continue;
            }

            if (ctx->to_utf8) {
                *ll = ngx_http_charset_recode_to_utf8(r->pool...",1,1,http\modules\ngx_http_charset_filter_module.c,ngx_http_charset_body_filter,,false,546,648,ngx_http_charset_body_filter,,,51,"ngx_int_t ngx_http_charset_body_filter (ngx_http_request_t*,ngx_chain_t*)"
107996,METHOD,http\modules\ngx_http_charset_filter_module.c:<global>,TYPE_DECL,"static ngx_uint_t
ngx_http_charset_recode(ngx_buf_t *b, u_char *table)
{
    u_char  *p, *last;

    last = b->last;

    for (p = b->pos; p < last; p++) {

        if (*p != table[*p]) {
            goto recode;
        }
    }

    return 0;

recode:

    do {
        if (*p != table[*p]) {
            *p = table[*p];
        }

        p++;

    } while (p < last);

    b->in_file = 0;

    return 1;
}",1,1,http\modules\ngx_http_charset_filter_module.c,ngx_http_charset_recode,,false,651,681,ngx_http_charset_recode,,,52,"ngx_uint_t ngx_http_charset_recode (ngx_buf_t*,u_char*)"
108065,METHOD,http\modules\ngx_http_charset_filter_module.c:<global>,TYPE_DECL,"static ngx_chain_t *
ngx_http_charset_recode_from_utf8(ngx_pool_t *pool, ngx_buf_t *buf,
    ngx_http_charset_ctx_t *ctx)
{
    size_t        len, size;
    u_char        c, *p, *src, *dst, *saved, **table;
    uint32_t      n;
    ngx_buf_t    *b;
    ngx_uint_t    i;
    ngx_chain_t  *out, *cl, **ll;

    src = buf->pos;

    if (ctx->saved_len == 0) {

        for ( /* void */ ; src < buf->last; src++) {

            if (*src < 0x80) {
                continue;
            }

            len = src - buf->pos;

            if (len > 512) {
                out = ngx_http_charset_get_buf(pool, ctx);
                if (out == NULL) {
                    return NULL;
                }

                b = out->buf;

                b->temporary = buf->temporary;
                b->memory = buf->memory;
                b->mmap = buf->mmap;
                b->flush = buf->flush;

                b->pos = buf->pos;
                b->last = src;

                out->buf = b;
          ...",1,23,http\modules\ngx_http_charset_filter_module.c,ngx_http_charset_recode_from_utf8,,false,684,962,ngx_http_charset_recode_from_utf8,,,53,"ngx_chain_t ngx_http_charset_recode_from_utf8 (ngx_pool_t*,ngx_buf_t*,ngx_http_charset_ctx_t*)"
108868,METHOD,http\modules\ngx_http_charset_filter_module.c:<global>,TYPE_DECL,"static ngx_chain_t *
ngx_http_charset_recode_to_utf8(ngx_pool_t *pool, ngx_buf_t *buf,
    ngx_http_charset_ctx_t *ctx)
{
    size_t        len, size;
    u_char       *p, *src, *dst, *table;
    ngx_buf_t    *b;
    ngx_chain_t  *out, *cl, **ll;

    table = ctx->table;

    for (src = buf->pos; src < buf->last; src++) {
        if (table[*src * NGX_UTF_LEN] == '\1') {
            continue;
        }

        goto recode;
    }

    out = ngx_alloc_chain_link(pool);
    if (out == NULL) {
        return NULL;
    }

    out->buf = buf;
    out->next = NULL;

    return out;

recode:

    /*
     * we assume that there are about half of characters to be recoded,
     * so we preallocate ""size / 2 + size / 2 * ctx->length""
     */

    len = src - buf->pos;

    if (len > 512) {
        out = ngx_http_charset_get_buf(pool, ctx);
        if (out == NULL) {
            return NULL;
        }

        b = out->buf;

        b->temporary = buf->temporary;
        b->memory = buf->memory;...",1,25,http\modules\ngx_http_charset_filter_module.c,ngx_http_charset_recode_to_utf8,,false,965,1089,ngx_http_charset_recode_to_utf8,,,54,"ngx_chain_t ngx_http_charset_recode_to_utf8 (ngx_pool_t*,ngx_buf_t*,ngx_http_charset_ctx_t*)"
109255,METHOD,http\modules\ngx_http_charset_filter_module.c:<global>,TYPE_DECL,"static ngx_chain_t *
ngx_http_charset_get_buf(ngx_pool_t *pool, ngx_http_charset_ctx_t *ctx)
{
    ngx_chain_t  *cl;

    cl = ctx->free_bufs;

    if (cl) {
        ctx->free_bufs = cl->next;

        cl->buf->shadow = NULL;
        cl->next = NULL;

        return cl;
    }

    cl = ngx_alloc_chain_link(pool);
    if (cl == NULL) {
        return NULL;
    }

    cl->buf = ngx_calloc_buf(pool);
    if (cl->buf == NULL) {
        return NULL;
    }

    cl->next = NULL;

    cl->buf->tag = (ngx_buf_tag_t) &ngx_http_charset_filter_module;

    return cl;
}",1,1,http\modules\ngx_http_charset_filter_module.c,ngx_http_charset_get_buf,,false,1092,1123,ngx_http_charset_get_buf,,,55,"ngx_chain_t ngx_http_charset_get_buf (ngx_pool_t*,ngx_http_charset_ctx_t*)"
109333,METHOD,http\modules\ngx_http_charset_filter_module.c:<global>,TYPE_DECL,"static ngx_chain_t *
ngx_http_charset_get_buffer(ngx_pool_t *pool, ngx_http_charset_ctx_t *ctx,
    size_t size)
{
    ngx_buf_t    *b;
    ngx_chain_t  *cl, **ll;

    for (ll = &ctx->free_buffers, cl = ctx->free_buffers;
         cl;
         ll = &cl->next, cl = cl->next)
    {
        b = cl->buf;

        if ((size_t) (b->end - b->start) >= size) {
            *ll = cl->next;
            cl->next = NULL;

            b->pos = b->start;
            b->temporary = 1;
            b->shadow = NULL;

            return cl;
        }
    }

    cl = ngx_alloc_chain_link(pool);
    if (cl == NULL) {
        return NULL;
    }

    cl->buf = ngx_create_temp_buf(pool, size);
    if (cl->buf == NULL) {
        return NULL;
    }

    cl->next = NULL;

    cl->buf->temporary = 1;
    cl->buf->tag = (ngx_buf_tag_t) &ngx_http_charset_filter_module;

    return cl;
}",1,1,http\modules\ngx_http_charset_filter_module.c,ngx_http_charset_get_buffer,,false,1126,1167,ngx_http_charset_get_buffer,,,56,"ngx_chain_t ngx_http_charset_get_buffer (ngx_pool_t*,ngx_http_charset_ctx_t*,size_t)"
109468,METHOD,http\modules\ngx_http_charset_filter_module.c:<global>,TYPE_DECL,"static char *
ngx_http_charset_map_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_charset_main_conf_t  *mcf = conf;

    char                         *rv;
    u_char                       *p, *dst2src, **pp;
    ngx_int_t                     src, dst;
    ngx_uint_t                    i, n;
    ngx_str_t                    *value;
    ngx_conf_t                    pvcf;
    ngx_http_charset_t           *charset;
    ngx_http_charset_tables_t    *table;
    ngx_http_charset_conf_ctx_t   ctx;

    value = cf->args->elts;

    src = ngx_http_add_charset(&mcf->charsets, &value[1]);
    if (src == NGX_ERROR) {
        return NGX_CONF_ERROR;
    }

    dst = ngx_http_add_charset(&mcf->charsets, &value[2]);
    if (dst == NGX_ERROR) {
        return NGX_CONF_ERROR;
    }

    if (src == dst) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""\""charset_map\"" between the same charsets ""
                           ""\""%V\"" and \""%V\"""", &value[1...",1,53,http\modules\ngx_http_charset_filter_module.c,ngx_http_charset_map_block,,false,1170,1303,ngx_http_charset_map_block,,,57,"char* ngx_http_charset_map_block (ngx_conf_t*,ngx_command_t*,void*)"
109983,METHOD,http\modules\ngx_http_charset_filter_module.c:<global>,TYPE_DECL,"static char *
ngx_http_charset_map(ngx_conf_t *cf, ngx_command_t *dummy, void *conf)
{
    u_char                       *p, *dst2src, **pp;
    uint32_t                      n;
    ngx_int_t                     src, dst;
    ngx_str_t                    *value;
    ngx_uint_t                    i;
    ngx_http_charset_tables_t    *table;
    ngx_http_charset_conf_ctx_t  *ctx;

    if (cf->args->nelts != 2) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, ""invalid parameters number"");
        return NGX_CONF_ERROR;
    }

    value = cf->args->elts;

    src = ngx_hextoi(value[0].data, value[0].len);
    if (src == NGX_ERROR || src > 255) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""invalid value \""%V\"""", &value[0]);
        return NGX_CONF_ERROR;
    }

    ctx = cf->ctx;
    table = ctx->table;

    if (ctx->charset->utf8) {
        p = &table->src2dst[src * NGX_UTF_LEN];

        *p++ = (u_char) (value[1].len / 2);

        for (i = 0; i < value...",1,34,http\modules\ngx_http_charset_filter_module.c,ngx_http_charset_map,,false,1306,1393,ngx_http_charset_map,,,58,"char* ngx_http_charset_map (ngx_conf_t*,ngx_command_t*,void*)"
110309,METHOD,http\modules\ngx_http_charset_filter_module.c:<global>,TYPE_DECL,"static char *
ngx_http_set_charset_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char  *p = conf;

    ngx_int_t                     *cp;
    ngx_str_t                     *value, var;
    ngx_http_charset_main_conf_t  *mcf;

    cp = (ngx_int_t *) (p + cmd->offset);

    if (*cp != NGX_CONF_UNSET) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    if (cmd->offset == offsetof(ngx_http_charset_loc_conf_t, charset)
        && ngx_strcmp(value[1].data, ""off"") == 0)
    {
        *cp = NGX_HTTP_CHARSET_OFF;
        return NGX_CONF_OK;
    }


    if (value[1].data[0] == '$') {
        var.len = value[1].len - 1;
        var.data = value[1].data + 1;

        *cp = ngx_http_get_variable_index(cf, &var);

        if (*cp == NGX_ERROR) {
            return NGX_CONF_ERROR;
        }

        *cp += NGX_HTTP_CHARSET_VAR;

        return NGX_CONF_OK;
    }

    mcf = ngx_http_conf_get_module_main_conf(cf,
                                             ngx_http...",1,14,http\modules\ngx_http_charset_filter_module.c,ngx_http_set_charset_slot,,false,1396,1445,ngx_http_set_charset_slot,,,59,"char* ngx_http_set_charset_slot (ngx_conf_t*,ngx_command_t*,void*)"
110459,METHOD,http\modules\ngx_http_charset_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_add_charset(ngx_array_t *charsets, ngx_str_t *name)
{
    ngx_uint_t           i;
    ngx_http_charset_t  *c;

    c = charsets->elts;
    for (i = 0; i < charsets->nelts; i++) {
        if (name->len != c[i].name.len) {
            continue;
        }

        if (ngx_strcasecmp(name->data, c[i].name.data) == 0) {
            break;
        }
    }

    if (i < charsets->nelts) {
        return i;
    }

    c = ngx_array_push(charsets);
    if (c == NULL) {
        return NGX_ERROR;
    }

    c->tables = NULL;
    c->name = *name;
    c->length = 0;

    if (ngx_strcasecmp(name->data, (u_char *) ""utf-8"") == 0) {
        c->utf8 = 1;

    } else {
        c->utf8 = 0;
    }

    return i;
}",1,1,http\modules\ngx_http_charset_filter_module.c,ngx_http_add_charset,,false,1448,1486,ngx_http_add_charset,,,60,"ngx_int_t ngx_http_add_charset (ngx_array_t*,ngx_str_t*)"
110576,METHOD,http\modules\ngx_http_charset_filter_module.c:<global>,TYPE_DECL,"static void *
ngx_http_charset_create_main_conf(ngx_conf_t *cf)
{
    ngx_http_charset_main_conf_t  *mcf;

    mcf = ngx_pcalloc(cf->pool, sizeof(ngx_http_charset_main_conf_t));
    if (mcf == NULL) {
        return NULL;
    }

    if (ngx_array_init(&mcf->charsets, cf->pool, 2, sizeof(ngx_http_charset_t))
        != NGX_OK)
    {
        return NULL;
    }

    if (ngx_array_init(&mcf->tables, cf->pool, 1,
                       sizeof(ngx_http_charset_tables_t))
        != NGX_OK)
    {
        return NULL;
    }

    if (ngx_array_init(&mcf->recodes, cf->pool, 2,
                       sizeof(ngx_http_charset_recode_t))
        != NGX_OK)
    {
        return NULL;
    }

    return mcf;
}",1,1,http\modules\ngx_http_charset_filter_module.c,ngx_http_charset_create_main_conf,,false,1489,1520,ngx_http_charset_create_main_conf,,,61,void* ngx_http_charset_create_main_conf (ngx_conf_t*)
110650,METHOD,http\modules\ngx_http_charset_filter_module.c:<global>,TYPE_DECL,"static void *
ngx_http_charset_create_loc_conf(ngx_conf_t *cf)
{
    ngx_http_charset_loc_conf_t  *lcf;

    lcf = ngx_pcalloc(cf->pool, sizeof(ngx_http_charset_loc_conf_t));
    if (lcf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     lcf->types = { NULL };
     *     lcf->types_keys = NULL;
     */

    lcf->charset = NGX_CONF_UNSET;
    lcf->source_charset = NGX_CONF_UNSET;
    lcf->override_charset = NGX_CONF_UNSET;

    return lcf;
}",1,1,http\modules\ngx_http_charset_filter_module.c,ngx_http_charset_create_loc_conf,,false,1523,1545,ngx_http_charset_create_loc_conf,,,62,void* ngx_http_charset_create_loc_conf (ngx_conf_t*)
110688,METHOD,http\modules\ngx_http_charset_filter_module.c:<global>,TYPE_DECL,"static char *
ngx_http_charset_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_charset_loc_conf_t *prev = parent;
    ngx_http_charset_loc_conf_t *conf = child;

    ngx_uint_t                     i;
    ngx_http_charset_recode_t     *recode;
    ngx_http_charset_main_conf_t  *mcf;

    if (ngx_http_merge_types(cf, &conf->types_keys, &conf->types,
                             &prev->types_keys, &prev->types,
                             ngx_http_charset_default_types)
        != NGX_OK)
    {
        return NGX_CONF_ERROR;
    }

    ngx_conf_merge_value(conf->override_charset, prev->override_charset, 0);
    ngx_conf_merge_value(conf->charset, prev->charset, NGX_HTTP_CHARSET_OFF);
    ngx_conf_merge_value(conf->source_charset, prev->source_charset,
                         NGX_HTTP_CHARSET_OFF);

    if (conf->charset == NGX_HTTP_CHARSET_OFF
        || conf->source_charset == NGX_HTTP_CHARSET_OFF
        || conf->charset == conf->source_charset)
    {
     ...",1,55,http\modules\ngx_http_charset_filter_module.c,ngx_http_charset_merge_loc_conf,,false,1548,1604,ngx_http_charset_merge_loc_conf,,,63,"char* ngx_http_charset_merge_loc_conf (ngx_conf_t*,void*,void*)"
110889,METHOD,http\modules\ngx_http_charset_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_charset_postconfiguration(ngx_conf_t *cf)
{
    u_char                       **src, **dst;
    ngx_int_t                      c;
    ngx_uint_t                     i, t;
    ngx_http_charset_t            *charset;
    ngx_http_charset_recode_t     *recode;
    ngx_http_charset_tables_t     *tables;
    ngx_http_charset_main_conf_t  *mcf;

    mcf = ngx_http_conf_get_module_main_conf(cf,
                                             ngx_http_charset_filter_module);

    recode = mcf->recodes.elts;
    tables = mcf->tables.elts;
    charset = mcf->charsets.elts;

    for (i = 0; i < mcf->recodes.nelts; i++) {

        c = recode[i].src;

        for (t = 0; t < mcf->tables.nelts; t++) {

            if (c == tables[t].src && recode[i].dst == tables[t].dst) {
                goto next;
            }

            if (c == tables[t].dst && recode[i].dst == tables[t].src) {
                goto next;
            }
        }

        ngx_log_error(NGX_LOG_EMERG, cf...",1,1,http\modules\ngx_http_charset_filter_module.c,ngx_http_charset_postconfiguration,,false,1607,1685,ngx_http_charset_postconfiguration,,,64,ngx_int_t ngx_http_charset_postconfiguration (ngx_conf_t*)
111197,METHOD,http\modules\ngx_http_chunked_filter_module.c:<global>,TYPE_DECL,<global>,1,1,http\modules\ngx_http_chunked_filter_module.c,http\modules\ngx_http_chunked_filter_module.c:<global>,,false,1,341,<global>,,,1,
111203,METHOD,http\modules\ngx_http_chunked_filter_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_chunked_filter_init(ngx_conf_t *cf);,18,61,http\modules\ngx_http_chunked_filter_module.c,ngx_http_chunked_filter_init,,false,19,19,ngx_http_chunked_filter_init,,,3,ngx_int_t ngx_http_chunked_filter_init (ngx_conf_t*)
111208,METHOD,http\modules\ngx_http_chunked_filter_module.c:<global>,TYPE_DECL,"static ngx_chain_t *ngx_http_chunked_create_trailers(ngx_http_request_t *r,
    ngx_http_chunked_filter_ctx_t *ctx);",20,39,http\modules\ngx_http_chunked_filter_module.c,ngx_http_chunked_create_trailers,,false,20,21,ngx_http_chunked_create_trailers,,,4,"ngx_chain_t* ngx_http_chunked_create_trailers (ngx_http_request_t*,ngx_http_chunked_filter_ctx_t*)"
111245,METHOD,http\modules\ngx_http_chunked_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_chunked_header_filter(ngx_http_request_t *r)
{
    ngx_http_core_loc_conf_t       *clcf;
    ngx_http_chunked_filter_ctx_t  *ctx;

    if (r->headers_out.status == NGX_HTTP_NOT_MODIFIED
        || r->headers_out.status == NGX_HTTP_NO_CONTENT
        || r->headers_out.status < NGX_HTTP_OK
        || r != r->main
        || r->method == NGX_HTTP_HEAD)
    {
        return ngx_http_next_header_filter(r);
    }

    if (r->headers_out.content_length_n == -1
        || r->expect_trailers)
    {
        clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

        if (r->http_version >= NGX_HTTP_VERSION_11
            && clcf->chunked_transfer_encoding)
        {
            if (r->expect_trailers) {
                ngx_http_clear_content_length(r);
            }

            r->chunked = 1;

            ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_chunked_filter_ctx_t));
            if (ctx == NULL) {
                return NGX_ERROR;
            }

     ...",1,1,http\modules\ngx_http_chunked_filter_module.c,ngx_http_chunked_header_filter,,false,59,101,ngx_http_chunked_header_filter,,,11,ngx_int_t ngx_http_chunked_header_filter (ngx_http_request_t*)
111373,METHOD,http\modules\ngx_http_chunked_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_chunked_body_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    u_char                         *chunk;
    off_t                           size;
    ngx_int_t                       rc;
    ngx_buf_t                      *b;
    ngx_chain_t                    *out, *cl, *tl, **ll;
    ngx_http_chunked_filter_ctx_t  *ctx;

    if (in == NULL || !r->chunked || r->header_only) {
        return ngx_http_next_body_filter(r, in);
    }

    ctx = ngx_http_get_module_ctx(r, ngx_http_chunked_filter_module);

    out = NULL;
    ll = &out;

    size = 0;
    cl = in;

    for ( ;; ) {
        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                       ""http chunk: %O"", ngx_buf_size(cl->buf));

        size += ngx_buf_size(cl->buf);

        if (cl->buf->flush
            || cl->buf->sync
            || ngx_buf_in_memory(cl->buf)
            || cl->buf->in_file)
        {
            tl = ngx_alloc_chain_link(r->pool);
            if (tl == NULL...",1,1,http\modules\ngx_http_chunked_filter_module.c,ngx_http_chunked_body_filter,,false,104,225,ngx_http_chunked_body_filter,,,12,"ngx_int_t ngx_http_chunked_body_filter (ngx_http_request_t*,ngx_chain_t*)"
111731,METHOD,http\modules\ngx_http_chunked_filter_module.c:<global>,TYPE_DECL,"static ngx_chain_t *
ngx_http_chunked_create_trailers(ngx_http_request_t *r,
    ngx_http_chunked_filter_ctx_t *ctx)
{
    size_t            len;
    ngx_buf_t        *b;
    ngx_uint_t        i;
    ngx_chain_t      *cl;
    ngx_list_part_t  *part;
    ngx_table_elt_t  *header;

    len = 0;

    part = &r->headers_out.trailers.part;
    header = part->elts;

    for (i = 0; /* void */; i++) {

        if (i >= part->nelts) {
            if (part->next == NULL) {
                break;
            }

            part = part->next;
            header = part->elts;
            i = 0;
        }

        if (header[i].hash == 0) {
            continue;
        }

        len += header[i].key.len + sizeof("": "") - 1
               + header[i].value.len + sizeof(CRLF) - 1;
    }

    cl = ngx_chain_get_free_buf(r->pool, &ctx->free);
    if (cl == NULL) {
        return NULL;
    }

    b = cl->buf;

    b->tag = (ngx_buf_tag_t) &ngx_http_chunked_filter_module;
    b->temporary = 0;
    b-...",1,1,http\modules\ngx_http_chunked_filter_module.c,ngx_http_chunked_create_trailers,,false,228,328,ngx_http_chunked_create_trailers,,,13,"ngx_chain_t ngx_http_chunked_create_trailers (ngx_http_request_t*,ngx_http_chunked_filter_ctx_t*)"
112128,METHOD,http\modules\ngx_http_chunked_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_chunked_filter_init(ngx_conf_t *cf)
{
    ngx_http_next_header_filter = ngx_http_top_header_filter;
    ngx_http_top_header_filter = ngx_http_chunked_header_filter;

    ngx_http_next_body_filter = ngx_http_top_body_filter;
    ngx_http_top_body_filter = ngx_http_chunked_body_filter;

    return NGX_OK;
}",1,1,http\modules\ngx_http_chunked_filter_module.c,ngx_http_chunked_filter_init,,false,331,341,ngx_http_chunked_filter_init,,,14,ngx_int_t ngx_http_chunked_filter_init (ngx_conf_t*)
112156,METHOD,http\modules\ngx_http_dav_module.c:<global>,TYPE_DECL,<global>,1,25,http\modules\ngx_http_dav_module.c,http\modules\ngx_http_dav_module.c:<global>,,false,1,1149,<global>,,,1,
112168,METHOD,http\modules\ngx_http_dav_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_dav_handler(ngx_http_request_t *r);,18,60,http\modules\ngx_http_dav_module.c,ngx_http_dav_handler,,false,35,35,ngx_http_dav_handler,,,5,ngx_int_t ngx_http_dav_handler (ngx_http_request_t*)
112173,METHOD,http\modules\ngx_http_dav_module.c:<global>,TYPE_DECL,static void ngx_http_dav_put_handler(ngx_http_request_t *r);,13,59,http\modules\ngx_http_dav_module.c,ngx_http_dav_put_handler,,false,37,37,ngx_http_dav_put_handler,,,6,void ngx_http_dav_put_handler (ngx_http_request_t*)
112178,METHOD,http\modules\ngx_http_dav_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_dav_delete_handler(ngx_http_request_t *r);,18,67,http\modules\ngx_http_dav_module.c,ngx_http_dav_delete_handler,,false,39,39,ngx_http_dav_delete_handler,,,7,ngx_int_t ngx_http_dav_delete_handler (ngx_http_request_t*)
112183,METHOD,http\modules\ngx_http_dav_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_dav_delete_path(ngx_http_request_t *r,
    ngx_str_t *path, ngx_uint_t dir);",18,36,http\modules\ngx_http_dav_module.c,ngx_http_dav_delete_path,,false,40,41,ngx_http_dav_delete_path,,,8,"ngx_int_t ngx_http_dav_delete_path (ngx_http_request_t*,ngx_str_t*,ngx_uint_t)"
112190,METHOD,http\modules\ngx_http_dav_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_dav_delete_dir(ngx_tree_ctx_t *ctx, ngx_str_t *path);",18,78,http\modules\ngx_http_dav_module.c,ngx_http_dav_delete_dir,,false,42,42,ngx_http_dav_delete_dir,,,9,"ngx_int_t ngx_http_dav_delete_dir (ngx_tree_ctx_t*,ngx_str_t*)"
112196,METHOD,http\modules\ngx_http_dav_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_dav_delete_file(ngx_tree_ctx_t *ctx, ngx_str_t *path);",18,79,http\modules\ngx_http_dav_module.c,ngx_http_dav_delete_file,,false,43,43,ngx_http_dav_delete_file,,,10,"ngx_int_t ngx_http_dav_delete_file (ngx_tree_ctx_t*,ngx_str_t*)"
112202,METHOD,http\modules\ngx_http_dav_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_dav_noop(ngx_tree_ctx_t *ctx, ngx_str_t *path);",18,72,http\modules\ngx_http_dav_module.c,ngx_http_dav_noop,,false,44,44,ngx_http_dav_noop,,,11,"ngx_int_t ngx_http_dav_noop (ngx_tree_ctx_t*,ngx_str_t*)"
112208,METHOD,http\modules\ngx_http_dav_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_dav_mkcol_handler(ngx_http_request_t *r,
    ngx_http_dav_loc_conf_t *dlcf);",18,34,http\modules\ngx_http_dav_module.c,ngx_http_dav_mkcol_handler,,false,46,47,ngx_http_dav_mkcol_handler,,,12,"ngx_int_t ngx_http_dav_mkcol_handler (ngx_http_request_t*,ngx_http_dav_loc_conf_t*)"
112214,METHOD,http\modules\ngx_http_dav_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_dav_copy_move_handler(ngx_http_request_t *r);,18,70,http\modules\ngx_http_dav_module.c,ngx_http_dav_copy_move_handler,,false,49,49,ngx_http_dav_copy_move_handler,,,13,ngx_int_t ngx_http_dav_copy_move_handler (ngx_http_request_t*)
112219,METHOD,http\modules\ngx_http_dav_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_dav_copy_dir(ngx_tree_ctx_t *ctx, ngx_str_t *path);",18,76,http\modules\ngx_http_dav_module.c,ngx_http_dav_copy_dir,,false,50,50,ngx_http_dav_copy_dir,,,14,"ngx_int_t ngx_http_dav_copy_dir (ngx_tree_ctx_t*,ngx_str_t*)"
112225,METHOD,http\modules\ngx_http_dav_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_dav_copy_dir_time(ngx_tree_ctx_t *ctx,
    ngx_str_t *path);",18,20,http\modules\ngx_http_dav_module.c,ngx_http_dav_copy_dir_time,,false,51,52,ngx_http_dav_copy_dir_time,,,15,"ngx_int_t ngx_http_dav_copy_dir_time (ngx_tree_ctx_t*,ngx_str_t*)"
112231,METHOD,http\modules\ngx_http_dav_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_dav_copy_tree_file(ngx_tree_ctx_t *ctx,
    ngx_str_t *path);",18,20,http\modules\ngx_http_dav_module.c,ngx_http_dav_copy_tree_file,,false,53,54,ngx_http_dav_copy_tree_file,,,16,"ngx_int_t ngx_http_dav_copy_tree_file (ngx_tree_ctx_t*,ngx_str_t*)"
112237,METHOD,http\modules\ngx_http_dav_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_dav_depth(ngx_http_request_t *r, ngx_int_t dflt);",18,74,http\modules\ngx_http_dav_module.c,ngx_http_dav_depth,,false,56,56,ngx_http_dav_depth,,,17,"ngx_int_t ngx_http_dav_depth (ngx_http_request_t*,ngx_int_t)"
112243,METHOD,http\modules\ngx_http_dav_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_dav_error(ngx_log_t *log, ngx_err_t err,
    ngx_int_t not_found, char *failed, u_char *path);",18,52,http\modules\ngx_http_dav_module.c,ngx_http_dav_error,,false,57,58,ngx_http_dav_error,,,18,"ngx_int_t ngx_http_dav_error (ngx_log_t*,ngx_err_t,ngx_int_t,char*,u_char*)"
112252,METHOD,http\modules\ngx_http_dav_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_dav_location(ngx_http_request_t *r);,18,61,http\modules\ngx_http_dav_module.c,ngx_http_dav_location,,false,59,59,ngx_http_dav_location,,,19,ngx_int_t ngx_http_dav_location (ngx_http_request_t*)
112257,METHOD,http\modules\ngx_http_dav_module.c:<global>,TYPE_DECL,static void *ngx_http_dav_create_loc_conf(ngx_conf_t *cf);,13,57,http\modules\ngx_http_dav_module.c,ngx_http_dav_create_loc_conf,,false,60,60,ngx_http_dav_create_loc_conf,,,20,void* ngx_http_dav_create_loc_conf (ngx_conf_t*)
112262,METHOD,http\modules\ngx_http_dav_module.c:<global>,TYPE_DECL,"static char *ngx_http_dav_merge_loc_conf(ngx_conf_t *cf,
    void *parent, void *child);",13,30,http\modules\ngx_http_dav_module.c,ngx_http_dav_merge_loc_conf,,false,61,62,ngx_http_dav_merge_loc_conf,,,21,"char* ngx_http_dav_merge_loc_conf (ngx_conf_t*,void*,void*)"
112269,METHOD,http\modules\ngx_http_dav_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_dav_init(ngx_conf_t *cf);,18,50,http\modules\ngx_http_dav_module.c,ngx_http_dav_init,,false,63,63,ngx_http_dav_init,,,22,ngx_int_t ngx_http_dav_init (ngx_conf_t*)
112406,METHOD,http\modules\ngx_http_dav_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_dav_handler(ngx_http_request_t *r)
{
    ngx_int_t                 rc;
    ngx_http_dav_loc_conf_t  *dlcf;

    dlcf = ngx_http_get_module_loc_conf(r, ngx_http_dav_module);

    if (!(r->method & dlcf->methods)) {
        return NGX_DECLINED;
    }

    switch (r->method) {

    case NGX_HTTP_PUT:

        if (r->uri.data[r->uri.len - 1] == '/') {
            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                          ""cannot PUT to a collection"");
            return NGX_HTTP_CONFLICT;
        }

        if (r->headers_in.content_range) {
            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                          ""PUT with range is unsupported"");
            return NGX_HTTP_NOT_IMPLEMENTED;
        }

        r->request_body_in_file_only = 1;
        r->request_body_in_persistent_file = 1;
        r->request_body_in_clean_file = 1;
        r->request_body_file_group_access = 1;
        r->request_body_file_log_level = 0;

       ...",1,1,http\modules\ngx_http_dav_module.c,ngx_http_dav_handler,,false,142,202,ngx_http_dav_handler,,,31,ngx_int_t ngx_http_dav_handler (ngx_http_request_t*)
112545,METHOD,http\modules\ngx_http_dav_module.c:<global>,TYPE_DECL,"static void
ngx_http_dav_put_handler(ngx_http_request_t *r)
{
    size_t                    root;
    time_t                    date;
    ngx_str_t                *temp, path;
    ngx_uint_t                status;
    ngx_file_info_t           fi;
    ngx_ext_rename_file_t     ext;
    ngx_http_dav_loc_conf_t  *dlcf;

    if (r->request_body == NULL) {
        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                      ""PUT request body is unavailable"");
        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
        return;
    }

    if (r->request_body->temp_file == NULL) {
        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                      ""PUT request body must be in a file"");
        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
        return;
    }

    if (ngx_http_map_uri_to_path(r, &path, &root, 0) == NULL) {
        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
        return;
    }

    path.len--;

 ...",1,1,http\modules\ngx_http_dav_module.c,ngx_http_dav_put_handler,,false,205,301,ngx_http_dav_put_handler,,,32,void ngx_http_dav_put_handler (ngx_http_request_t*)
112841,METHOD,http\modules\ngx_http_dav_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_dav_delete_handler(ngx_http_request_t *r)
{
    size_t                    root;
    ngx_err_t                 err;
    ngx_int_t                 rc, depth;
    ngx_uint_t                i, d, dir;
    ngx_str_t                 path;
    ngx_file_info_t           fi;
    ngx_http_dav_loc_conf_t  *dlcf;

    if (r->headers_in.content_length_n > 0 || r->headers_in.chunked) {
        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                      ""DELETE with body is unsupported"");
        return NGX_HTTP_UNSUPPORTED_MEDIA_TYPE;
    }

    dlcf = ngx_http_get_module_loc_conf(r, ngx_http_dav_module);

    if (dlcf->min_delete_depth) {
        d = 0;

        for (i = 0; i < r->uri.len; /* void */) {
            if (r->uri.data[i++] == '/') {
                if (++d >= dlcf->min_delete_depth && i < r->uri.len) {
                    goto ok;
                }
            }
        }

        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
               ...",1,38,http\modules\ngx_http_dav_module.c,ngx_http_dav_delete_handler,,false,304,402,ngx_http_dav_delete_handler,,,33,ngx_int_t ngx_http_dav_delete_handler (ngx_http_request_t*)
113129,METHOD,http\modules\ngx_http_dav_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_dav_delete_path(ngx_http_request_t *r, ngx_str_t *path, ngx_uint_t dir)
{
    char            *failed;
    ngx_tree_ctx_t   tree;

    if (dir) {

        tree.init_handler = NULL;
        tree.file_handler = ngx_http_dav_delete_file;
        tree.pre_tree_handler = ngx_http_dav_noop;
        tree.post_tree_handler = ngx_http_dav_delete_dir;
        tree.spec_handler = ngx_http_dav_delete_file;
        tree.data = NULL;
        tree.alloc = 0;
        tree.log = r->connection->log;

        /* TODO: 207 */

        if (ngx_walk_tree(&tree, path) != NGX_OK) {
            return NGX_HTTP_INTERNAL_SERVER_ERROR;
        }

        if (ngx_delete_dir(path->data) != NGX_FILE_ERROR) {
            return NGX_OK;
        }

        failed = ngx_delete_dir_n;

    } else {

        if (ngx_delete_file(path->data) != NGX_FILE_ERROR) {
            return NGX_OK;
        }

        failed = ngx_delete_file_n;
    }

    return ngx_http_dav_error(r->connection->log, ngx_...",1,1,http\modules\ngx_http_dav_module.c,ngx_http_dav_delete_path,,false,405,445,ngx_http_dav_delete_path,,,34,"ngx_int_t ngx_http_dav_delete_path (ngx_http_request_t*,ngx_str_t*,ngx_uint_t)"
113236,METHOD,http\modules\ngx_http_dav_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_dav_delete_dir(ngx_tree_ctx_t *ctx, ngx_str_t *path)
{
    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx->log, 0,
                   ""http delete dir: \""%s\"""", path->data);

    if (ngx_delete_dir(path->data) == NGX_FILE_ERROR) {

        /* TODO: add to 207 */

        (void) ngx_http_dav_error(ctx->log, ngx_errno, 0, ngx_delete_dir_n,
                                  path->data);
    }

    return NGX_OK;
}",1,1,http\modules\ngx_http_dav_module.c,ngx_http_dav_delete_dir,,false,448,463,ngx_http_dav_delete_dir,,,35,"ngx_int_t ngx_http_dav_delete_dir (ngx_tree_ctx_t*,ngx_str_t*)"
113274,METHOD,http\modules\ngx_http_dav_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_dav_delete_file(ngx_tree_ctx_t *ctx, ngx_str_t *path)
{
    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx->log, 0,
                   ""http delete file: \""%s\"""", path->data);

    if (ngx_delete_file(path->data) == NGX_FILE_ERROR) {

        /* TODO: add to 207 */

        (void) ngx_http_dav_error(ctx->log, ngx_errno, 0, ngx_delete_file_n,
                                  path->data);
    }

    return NGX_OK;
}",1,1,http\modules\ngx_http_dav_module.c,ngx_http_dav_delete_file,,false,466,481,ngx_http_dav_delete_file,,,36,"ngx_int_t ngx_http_dav_delete_file (ngx_tree_ctx_t*,ngx_str_t*)"
113312,METHOD,http\modules\ngx_http_dav_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_dav_noop(ngx_tree_ctx_t *ctx, ngx_str_t *path)
{
    return NGX_OK;
}",1,1,http\modules\ngx_http_dav_module.c,ngx_http_dav_noop,,false,484,488,ngx_http_dav_noop,,,37,"ngx_int_t ngx_http_dav_noop (ngx_tree_ctx_t*,ngx_str_t*)"
113320,METHOD,http\modules\ngx_http_dav_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_dav_mkcol_handler(ngx_http_request_t *r, ngx_http_dav_loc_conf_t *dlcf)
{
    u_char    *p;
    size_t     root;
    ngx_str_t  path;

    if (r->headers_in.content_length_n > 0 || r->headers_in.chunked) {
        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                      ""MKCOL with body is unsupported"");
        return NGX_HTTP_UNSUPPORTED_MEDIA_TYPE;
    }

    if (r->uri.data[r->uri.len - 1] != '/') {
        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                      ""MKCOL can create a collection only"");
        return NGX_HTTP_CONFLICT;
    }

    p = ngx_http_map_uri_to_path(r, &path, &root, 0);
    if (p == NULL) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    *(p - 1) = '\0';

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http mkcol path: \""%s\"""", path.data);

    if (ngx_create_dir(path.data, ngx_dir_access(dlcf->access))
        != NGX_FILE_ERROR)
    {
        if (ngx_http...",1,1,http\modules\ngx_http_dav_module.c,ngx_http_dav_mkcol_handler,,false,491,532,ngx_http_dav_mkcol_handler,,,38,"ngx_int_t ngx_http_dav_mkcol_handler (ngx_http_request_t*,ngx_http_dav_loc_conf_t*)"
113452,METHOD,http\modules\ngx_http_dav_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_dav_copy_move_handler(ngx_http_request_t *r)
{
    u_char                   *p, *host, *last, ch;
    size_t                    len, root;
    ngx_err_t                 err;
    ngx_int_t                 rc, depth;
    ngx_uint_t                overwrite, slash, dir, flags;
    ngx_str_t                 path, uri, duri, args;
    ngx_tree_ctx_t            tree;
    ngx_copy_file_t           cf;
    ngx_file_info_t           fi;
    ngx_table_elt_t          *dest, *over;
    ngx_ext_rename_file_t     ext;
    ngx_http_dav_copy_ctx_t   copy;
    ngx_http_dav_loc_conf_t  *dlcf;

    if (r->headers_in.content_length_n > 0 || r->headers_in.chunked) {
        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                      ""COPY and MOVE with body are unsupported"");
        return NGX_HTTP_UNSUPPORTED_MEDIA_TYPE;
    }

    dest = r->headers_in.destination;

    if (dest == NULL) {
        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                 ...",1,34,http\modules\ngx_http_dav_module.c,ngx_http_dav_copy_move_handler,,false,535,857,ngx_http_dav_copy_move_handler,,,39,ngx_int_t ngx_http_dav_copy_move_handler (ngx_http_request_t*)
114484,METHOD,http\modules\ngx_http_dav_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_dav_copy_dir(ngx_tree_ctx_t *ctx, ngx_str_t *path)
{
    u_char                   *p, *dir;
    size_t                    len;
    ngx_http_dav_copy_ctx_t  *copy;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx->log, 0,
                   ""http copy dir: \""%s\"""", path->data);

    copy = ctx->data;

    len = copy->path.len + path->len;

    dir = ngx_alloc(len + 1, ctx->log);
    if (dir == NULL) {
        return NGX_ABORT;
    }

    p = ngx_cpymem(dir, copy->path.data, copy->path.len);
    (void) ngx_cpystrn(p, path->data + copy->len, path->len - copy->len + 1);

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx->log, 0,
                   ""http copy dir to: \""%s\"""", dir);

    if (ngx_create_dir(dir, ngx_dir_access(ctx->access)) == NGX_FILE_ERROR) {
        (void) ngx_http_dav_error(ctx->log, ngx_errno, 0, ngx_create_dir_n,
                                  dir);
    }

    ngx_free(dir);

    return NGX_OK;
}",1,1,http\modules\ngx_http_dav_module.c,ngx_http_dav_copy_dir,,false,860,893,ngx_http_dav_copy_dir,,,40,"ngx_int_t ngx_http_dav_copy_dir (ngx_tree_ctx_t*,ngx_str_t*)"
114602,METHOD,http\modules\ngx_http_dav_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_dav_copy_dir_time(ngx_tree_ctx_t *ctx, ngx_str_t *path)
{
    u_char                   *p, *dir;
    size_t                    len;
    ngx_http_dav_copy_ctx_t  *copy;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx->log, 0,
                   ""http copy dir time: \""%s\"""", path->data);

    copy = ctx->data;

    len = copy->path.len + path->len;

    dir = ngx_alloc(len + 1, ctx->log);
    if (dir == NULL) {
        return NGX_ABORT;
    }

    p = ngx_cpymem(dir, copy->path.data, copy->path.len);
    (void) ngx_cpystrn(p, path->data + copy->len, path->len - copy->len + 1);

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx->log, 0,
                   ""http copy dir time to: \""%s\"""", dir);

#if (NGX_WIN32)
    {
    ngx_fd_t  fd;

    fd = ngx_open_file(dir, NGX_FILE_RDWR, NGX_FILE_OPEN, 0);

    if (fd == NGX_INVALID_FILE) {
        (void) ngx_http_dav_error(ctx->log, ngx_errno, 0, ngx_open_file_n, dir);
        goto failed;
    }

    if (ngx_set_file_time(NULL, fd...",1,1,http\modules\ngx_http_dav_module.c,ngx_http_dav_copy_dir_time,,false,896,957,ngx_http_dav_copy_dir_time,,,41,"ngx_int_t ngx_http_dav_copy_dir_time (ngx_tree_ctx_t*,ngx_str_t*)"
114711,METHOD,http\modules\ngx_http_dav_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_dav_copy_tree_file(ngx_tree_ctx_t *ctx, ngx_str_t *path)
{
    u_char                   *p, *file;
    size_t                    len;
    ngx_copy_file_t           cf;
    ngx_http_dav_copy_ctx_t  *copy;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx->log, 0,
                   ""http copy file: \""%s\"""", path->data);

    copy = ctx->data;

    len = copy->path.len + path->len;

    file = ngx_alloc(len + 1, ctx->log);
    if (file == NULL) {
        return NGX_ABORT;
    }

    p = ngx_cpymem(file, copy->path.data, copy->path.len);
    (void) ngx_cpystrn(p, path->data + copy->len, path->len - copy->len + 1);

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx->log, 0,
                   ""http copy file to: \""%s\"""", file);

    cf.size = ctx->size;
    cf.buf_size = 0;
    cf.access = ctx->access;
    cf.time = ctx->mtime;
    cf.log = ctx->log;

    (void) ngx_copy_file(path->data, file, &cf);

    ngx_free(file);

    return NGX_OK;
}",1,1,http\modules\ngx_http_dav_module.c,ngx_http_dav_copy_tree_file,,false,960,997,ngx_http_dav_copy_tree_file,,,42,"ngx_int_t ngx_http_dav_copy_tree_file (ngx_tree_ctx_t*,ngx_str_t*)"
114852,METHOD,http\modules\ngx_http_dav_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_dav_depth(ngx_http_request_t *r, ngx_int_t dflt)
{
    ngx_table_elt_t  *depth;

    depth = r->headers_in.depth;

    if (depth == NULL) {
        return dflt;
    }

    if (depth->value.len == 1) {

        if (depth->value.data[0] == '0') {
            return 0;
        }

        if (depth->value.data[0] == '1') {
            return 1;
        }

    } else {

        if (depth->value.len == sizeof(""infinity"") - 1
            && ngx_strcmp(depth->value.data, ""infinity"") == 0)
        {
            return NGX_HTTP_DAV_INFINITY_DEPTH;
        }
    }

    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                  ""client sent invalid \""Depth\"" header: \""%V\"""",
                  &depth->value);

    return NGX_HTTP_DAV_INVALID_DEPTH;
}",1,19,http\modules\ngx_http_dav_module.c,ngx_http_dav_depth,,false,1000,1035,ngx_http_dav_depth,,,43,"ngx_int_t ngx_http_dav_depth (ngx_http_request_t*,ngx_int_t)"
114955,METHOD,http\modules\ngx_http_dav_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_dav_error(ngx_log_t *log, ngx_err_t err, ngx_int_t not_found,
    char *failed, u_char *path)
{
    ngx_int_t   rc;
    ngx_uint_t  level;

    if (err == NGX_ENOENT || err == NGX_ENOTDIR || err == NGX_ENAMETOOLONG) {
        level = NGX_LOG_ERR;
        rc = not_found;

    } else if (err == NGX_EACCES || err == NGX_EPERM) {
        level = NGX_LOG_ERR;
        rc = NGX_HTTP_FORBIDDEN;

    } else if (err == NGX_EEXIST) {
        level = NGX_LOG_ERR;
        rc = NGX_HTTP_NOT_ALLOWED;

    } else if (err == NGX_ENOSPC) {
        level = NGX_LOG_CRIT;
        rc = NGX_HTTP_INSUFFICIENT_STORAGE;

    } else {
        level = NGX_LOG_CRIT;
        rc = NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    ngx_log_error(level, log, err, ""%s \""%s\"" failed"", failed, path);

    return rc;
}",1,1,http\modules\ngx_http_dav_module.c,ngx_http_dav_error,,false,1038,1069,ngx_http_dav_error,,,44,"ngx_int_t ngx_http_dav_error (ngx_log_t*,ngx_err_t,ngx_int_t,char*,u_char*)"
115045,METHOD,http\modules\ngx_http_dav_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_dav_location(ngx_http_request_t *r)
{
    r->headers_out.location = ngx_list_push(&r->headers_out.headers);
    if (r->headers_out.location == NULL) {
        return NGX_ERROR;
    }

    r->headers_out.location->hash = 1;
    ngx_str_set(&r->headers_out.location->key, ""Location"");
    r->headers_out.location->value = r->uri;

    return NGX_OK;
}",1,1,http\modules\ngx_http_dav_module.c,ngx_http_dav_location,,false,1072,1085,ngx_http_dav_location,,,45,ngx_int_t ngx_http_dav_location (ngx_http_request_t*)
115106,METHOD,http\modules\ngx_http_dav_module.c:<global>,TYPE_DECL,"static void *
ngx_http_dav_create_loc_conf(ngx_conf_t *cf)
{
    ngx_http_dav_loc_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_dav_loc_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     conf->methods = 0;
     */

    conf->min_delete_depth = NGX_CONF_UNSET_UINT;
    conf->access = NGX_CONF_UNSET_UINT;
    conf->create_full_put_path = NGX_CONF_UNSET;

    return conf;
}",1,1,http\modules\ngx_http_dav_module.c,ngx_http_dav_create_loc_conf,,false,1088,1109,ngx_http_dav_create_loc_conf,,,46,void* ngx_http_dav_create_loc_conf (ngx_conf_t*)
115144,METHOD,http\modules\ngx_http_dav_module.c:<global>,TYPE_DECL,"static char *
ngx_http_dav_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_dav_loc_conf_t  *prev = parent;
    ngx_http_dav_loc_conf_t  *conf = child;

    ngx_conf_merge_bitmask_value(conf->methods, prev->methods,
                         (NGX_CONF_BITMASK_SET|NGX_HTTP_DAV_OFF));

    ngx_conf_merge_uint_value(conf->min_delete_depth,
                         prev->min_delete_depth, 0);

    ngx_conf_merge_uint_value(conf->access, prev->access, 0600);

    ngx_conf_merge_value(conf->create_full_put_path,
                         prev->create_full_put_path, 0);

    return NGX_CONF_OK;
}",1,47,http\modules\ngx_http_dav_module.c,ngx_http_dav_merge_loc_conf,,false,1112,1130,ngx_http_dav_merge_loc_conf,,,47,"char* ngx_http_dav_merge_loc_conf (ngx_conf_t*,void*,void*)"
115197,METHOD,http\modules\ngx_http_dav_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_dav_init(ngx_conf_t *cf)
{
    ngx_http_handler_pt        *h;
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);

    h = ngx_array_push(&cmcf->phases[NGX_HTTP_CONTENT_PHASE].handlers);
    if (h == NULL) {
        return NGX_ERROR;
    }

    *h = ngx_http_dav_handler;

    return NGX_OK;
}",1,1,http\modules\ngx_http_dav_module.c,ngx_http_dav_init,,false,1133,1149,ngx_http_dav_init,,,48,ngx_int_t ngx_http_dav_init (ngx_conf_t*)
115242,METHOD,http\modules\ngx_http_degradation_module.c:<global>,TYPE_DECL,<global>,1,1,http\modules\ngx_http_degradation_module.c,http\modules\ngx_http_degradation_module.c:<global>,,false,1,243,<global>,,,1,
115265,METHOD,http\modules\ngx_http_degradation_module.c:<global>,TYPE_DECL,static void *ngx_http_degradation_create_main_conf(ngx_conf_t *cf);,13,66,http\modules\ngx_http_degradation_module.c,ngx_http_degradation_create_main_conf,,false,30,30,ngx_http_degradation_create_main_conf,,,7,void* ngx_http_degradation_create_main_conf (ngx_conf_t*)
115270,METHOD,http\modules\ngx_http_degradation_module.c:<global>,TYPE_DECL,static void *ngx_http_degradation_create_loc_conf(ngx_conf_t *cf);,13,65,http\modules\ngx_http_degradation_module.c,ngx_http_degradation_create_loc_conf,,false,31,31,ngx_http_degradation_create_loc_conf,,,8,void* ngx_http_degradation_create_loc_conf (ngx_conf_t*)
115275,METHOD,http\modules\ngx_http_degradation_module.c:<global>,TYPE_DECL,"static char *ngx_http_degradation_merge_loc_conf(ngx_conf_t *cf, void *parent,
    void *child);",13,16,http\modules\ngx_http_degradation_module.c,ngx_http_degradation_merge_loc_conf,,false,32,33,ngx_http_degradation_merge_loc_conf,,,9,"char* ngx_http_degradation_merge_loc_conf (ngx_conf_t*,void*,void*)"
115282,METHOD,http\modules\ngx_http_degradation_module.c:<global>,TYPE_DECL,"static char *ngx_http_degradation(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_degradation_module.c,ngx_http_degradation,,false,34,35,ngx_http_degradation,,,10,"char* ngx_http_degradation (ngx_conf_t*,ngx_command_t*,void*)"
115289,METHOD,http\modules\ngx_http_degradation_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_degradation_init(ngx_conf_t *cf);,18,58,http\modules\ngx_http_degradation_module.c,ngx_http_degradation_init,,false,36,36,ngx_http_degradation_init,,,11,ngx_int_t ngx_http_degradation_init (ngx_conf_t*)
115355,METHOD,http\modules\ngx_http_degradation_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_degradation_handler(ngx_http_request_t *r)
{
    ngx_http_degradation_loc_conf_t  *dlcf;

    dlcf = ngx_http_get_module_loc_conf(r, ngx_http_degradation_module);

    if (dlcf->degrade && ngx_http_degraded(r)) {
        return dlcf->degrade;
    }

    return NGX_DECLINED;
}",1,1,http\modules\ngx_http_degradation_module.c,ngx_http_degradation_handler,,false,90,102,ngx_http_degradation_handler,,,18,ngx_int_t ngx_http_degradation_handler (ngx_http_request_t*)
115380,METHOD,http\modules\ngx_http_degradation_module.c:<global>,TYPE_DECL,"ngx_uint_t
ngx_http_degraded(ngx_http_request_t *r)
{
    time_t                             now;
    ngx_uint_t                         log;
    static size_t                      sbrk_size;
    static time_t                      sbrk_time;
    ngx_http_degradation_main_conf_t  *dmcf;

    dmcf = ngx_http_get_module_main_conf(r, ngx_http_degradation_module);

    if (dmcf->sbrk_size) {

        log = 0;
        now = ngx_time();

        /* lock mutex */

        if (now != sbrk_time) {

            /*
             * ELF/i386 is loaded at 0x08000000, 128M
             * ELF/amd64 is loaded at 0x00400000, 4M
             *
             * use a function address to subtract the loading address
             */

            sbrk_size = (size_t) sbrk(0) - ((uintptr_t) ngx_palloc & ~0x3FFFFF);
            sbrk_time = now;
            log = 1;
        }

        /* unlock mutex */

        if (sbrk_size >= dmcf->sbrk_size) {
            if (log) {
                ngx_log_error(NGX_LOG_NOTI...",1,1,http\modules\ngx_http_degradation_module.c,ngx_http_degraded,,false,105,151,ngx_http_degraded,,,19,ngx_uint_t ngx_http_degraded (ngx_http_request_t*)
115458,METHOD,http\modules\ngx_http_degradation_module.c:<global>,TYPE_DECL,"static void *
ngx_http_degradation_create_main_conf(ngx_conf_t *cf)
{
    ngx_http_degradation_main_conf_t  *dmcf;

    dmcf = ngx_pcalloc(cf->pool, sizeof(ngx_http_degradation_main_conf_t));
    if (dmcf == NULL) {
        return NULL;
    }

    return dmcf;
}",1,1,http\modules\ngx_http_degradation_module.c,ngx_http_degradation_create_main_conf,,false,154,165,ngx_http_degradation_create_main_conf,,,20,void* ngx_http_degradation_create_main_conf (ngx_conf_t*)
115481,METHOD,http\modules\ngx_http_degradation_module.c:<global>,TYPE_DECL,"static void *
ngx_http_degradation_create_loc_conf(ngx_conf_t *cf)
{
    ngx_http_degradation_loc_conf_t  *conf;

    conf = ngx_palloc(cf->pool, sizeof(ngx_http_degradation_loc_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    conf->degrade = NGX_CONF_UNSET_UINT;

    return conf;
}",1,1,http\modules\ngx_http_degradation_module.c,ngx_http_degradation_create_loc_conf,,false,168,181,ngx_http_degradation_create_loc_conf,,,21,void* ngx_http_degradation_create_loc_conf (ngx_conf_t*)
115509,METHOD,http\modules\ngx_http_degradation_module.c:<global>,TYPE_DECL,"static char *
ngx_http_degradation_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_degradation_loc_conf_t  *prev = parent;
    ngx_http_degradation_loc_conf_t  *conf = child;

    ngx_conf_merge_uint_value(conf->degrade, prev->degrade, 0);

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_degradation_module.c,ngx_http_degradation_merge_loc_conf,,false,184,193,ngx_http_degradation_merge_loc_conf,,,22,"char* ngx_http_degradation_merge_loc_conf (ngx_conf_t*,void*,void*)"
115534,METHOD,http\modules\ngx_http_degradation_module.c:<global>,TYPE_DECL,"static char *
ngx_http_degradation(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_degradation_main_conf_t  *dmcf = conf;

    ngx_str_t  *value, s;

    value = cf->args->elts;

    if (ngx_strncmp(value[1].data, ""sbrk="", 5) == 0) {

        s.len = value[1].len - 5;
        s.data = value[1].data + 5;

        dmcf->sbrk_size = ngx_parse_size(&s);
        if (dmcf->sbrk_size == (size_t) NGX_ERROR) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               ""invalid sbrk size \""%V\"""", &value[1]);
            return NGX_CONF_ERROR;
        }

        return NGX_CONF_OK;
    }

    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                       ""invalid parameter \""%V\"""", &value[1]);

    return NGX_CONF_ERROR;
}",1,1,http\modules\ngx_http_degradation_module.c,ngx_http_degradation,,false,196,224,ngx_http_degradation,,,23,"char* ngx_http_degradation (ngx_conf_t*,ngx_command_t*,void*)"
115628,METHOD,http\modules\ngx_http_degradation_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_degradation_init(ngx_conf_t *cf)
{
    ngx_http_handler_pt        *h;
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);

    h = ngx_array_push(&cmcf->phases[NGX_HTTP_PREACCESS_PHASE].handlers);
    if (h == NULL) {
        return NGX_ERROR;
    }

    *h = ngx_http_degradation_handler;

    return NGX_OK;
}",1,1,http\modules\ngx_http_degradation_module.c,ngx_http_degradation_init,,false,227,243,ngx_http_degradation_init,,,24,ngx_int_t ngx_http_degradation_init (ngx_conf_t*)
115673,METHOD,http\modules\ngx_http_empty_gif_module.c:<global>,TYPE_DECL,<global>,1,1,http\modules\ngx_http_empty_gif_module.c,http\modules\ngx_http_empty_gif_module.c:<global>,,false,1,140,<global>,,,1,
115675,METHOD,http\modules\ngx_http_empty_gif_module.c:<global>,TYPE_DECL,"static char *ngx_http_empty_gif(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_empty_gif_module.c,ngx_http_empty_gif,,false,12,13,ngx_http_empty_gif,,,1,"char* ngx_http_empty_gif (ngx_conf_t*,ngx_command_t*,void*)"
115778,METHOD,http\modules\ngx_http_empty_gif_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_empty_gif_handler(ngx_http_request_t *r)
{
    ngx_http_complex_value_t  cv;

    if (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD))) {
        return NGX_HTTP_NOT_ALLOWED;
    }

    ngx_memzero(&cv, sizeof(ngx_http_complex_value_t));

    cv.value.len = sizeof(ngx_empty_gif);
    cv.value.data = ngx_empty_gif;
    r->headers_out.last_modified_time = 23349600;

    return ngx_http_send_response(r, NGX_HTTP_OK, &ngx_http_gif_type, &cv);
}",1,1,http\modules\ngx_http_empty_gif_module.c,ngx_http_empty_gif_handler,,false,112,128,ngx_http_empty_gif_handler,,,12,ngx_int_t ngx_http_empty_gif_handler (ngx_http_request_t*)
115831,METHOD,http\modules\ngx_http_empty_gif_module.c:<global>,TYPE_DECL,"static char *
ngx_http_empty_gif(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_core_loc_conf_t  *clcf;

    clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);
    clcf->handler = ngx_http_empty_gif_handler;

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_empty_gif_module.c,ngx_http_empty_gif,,false,131,140,ngx_http_empty_gif,,,13,"char* ngx_http_empty_gif (ngx_conf_t*,ngx_command_t*,void*)"
115860,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,<global>,1,6,http\modules\ngx_http_fastcgi_module.c,http\modules\ngx_http_fastcgi_module.c:<global>,,false,1,3773,<global>,,,1,
115897,METHOD,<empty>,<empty>,<empty>,1,,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_state_e:<clinit>,,false,56,,<clinit>,,,11,
115940,METHOD,<empty>,<empty>,<empty>,1,,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_begin_request_t:<clinit>,,false,124,,<clinit>,,,5,
115958,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_fastcgi_eval(ngx_http_request_t *r,
    ngx_http_fastcgi_loc_conf_t *flcf);",18,38,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_eval,,false,147,148,ngx_http_fastcgi_eval,,,21,"ngx_int_t ngx_http_fastcgi_eval (ngx_http_request_t*,ngx_http_fastcgi_loc_conf_t*)"
115964,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_fastcgi_create_request(ngx_http_request_t *r);,18,71,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_create_request,,false,152,152,ngx_http_fastcgi_create_request,,,22,ngx_int_t ngx_http_fastcgi_create_request (ngx_http_request_t*)
115969,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_fastcgi_reinit_request(ngx_http_request_t *r);,18,71,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_reinit_request,,false,153,153,ngx_http_fastcgi_reinit_request,,,23,ngx_int_t ngx_http_fastcgi_reinit_request (ngx_http_request_t*)
115974,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_fastcgi_body_output_filter(void *data,
    ngx_chain_t *in);",18,20,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_body_output_filter,,false,154,155,ngx_http_fastcgi_body_output_filter,,,24,"ngx_int_t ngx_http_fastcgi_body_output_filter (void*,ngx_chain_t*)"
115980,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_fastcgi_process_header(ngx_http_request_t *r);,18,71,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_process_header,,false,156,156,ngx_http_fastcgi_process_header,,,25,ngx_int_t ngx_http_fastcgi_process_header (ngx_http_request_t*)
115985,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_fastcgi_input_filter_init(void *data);,18,63,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_input_filter_init,,false,157,157,ngx_http_fastcgi_input_filter_init,,,26,ngx_int_t ngx_http_fastcgi_input_filter_init (void*)
115990,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_fastcgi_input_filter(ngx_event_pipe_t *p,
    ngx_buf_t *buf);",18,19,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_input_filter,,false,158,159,ngx_http_fastcgi_input_filter,,,27,"ngx_int_t ngx_http_fastcgi_input_filter (ngx_event_pipe_t*,ngx_buf_t*)"
115996,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_fastcgi_non_buffered_filter(void *data,
    ssize_t bytes);",18,18,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_non_buffered_filter,,false,160,161,ngx_http_fastcgi_non_buffered_filter,,,28,"ngx_int_t ngx_http_fastcgi_non_buffered_filter (void*,ssize_t)"
116002,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_fastcgi_process_record(ngx_http_request_t *r,
    ngx_http_fastcgi_ctx_t *f);",18,30,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_process_record,,false,162,163,ngx_http_fastcgi_process_record,,,29,"ngx_int_t ngx_http_fastcgi_process_record (ngx_http_request_t*,ngx_http_fastcgi_ctx_t*)"
116008,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,static void ngx_http_fastcgi_abort_request(ngx_http_request_t *r);,13,65,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_abort_request,,false,164,164,ngx_http_fastcgi_abort_request,,,30,void ngx_http_fastcgi_abort_request (ngx_http_request_t*)
116013,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,"static void ngx_http_fastcgi_finalize_request(ngx_http_request_t *r,
    ngx_int_t rc);",13,17,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_finalize_request,,false,165,166,ngx_http_fastcgi_finalize_request,,,31,"void ngx_http_fastcgi_finalize_request (ngx_http_request_t*,ngx_int_t)"
116019,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_fastcgi_add_variables(ngx_conf_t *cf);,18,63,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_add_variables,,false,168,168,ngx_http_fastcgi_add_variables,,,32,ngx_int_t ngx_http_fastcgi_add_variables (ngx_conf_t*)
116024,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,static void *ngx_http_fastcgi_create_main_conf(ngx_conf_t *cf);,13,62,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_create_main_conf,,false,169,169,ngx_http_fastcgi_create_main_conf,,,33,void* ngx_http_fastcgi_create_main_conf (ngx_conf_t*)
116029,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,static void *ngx_http_fastcgi_create_loc_conf(ngx_conf_t *cf);,13,61,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_create_loc_conf,,false,170,170,ngx_http_fastcgi_create_loc_conf,,,34,void* ngx_http_fastcgi_create_loc_conf (ngx_conf_t*)
116034,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,"static char *ngx_http_fastcgi_merge_loc_conf(ngx_conf_t *cf,
    void *parent, void *child);",13,30,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_merge_loc_conf,,false,171,172,ngx_http_fastcgi_merge_loc_conf,,,35,"char* ngx_http_fastcgi_merge_loc_conf (ngx_conf_t*,void*,void*)"
116041,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_fastcgi_init_params(ngx_conf_t *cf,
    ngx_http_fastcgi_loc_conf_t *conf, ngx_http_fastcgi_params_t *params,
    ngx_keyval_t *default_params);",18,33,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_init_params,,false,173,175,ngx_http_fastcgi_init_params,,,36,"ngx_int_t ngx_http_fastcgi_init_params (ngx_conf_t*,ngx_http_fastcgi_loc_conf_t*,ngx_http_fastcgi_params_t*,ngx_keyval_t*)"
116049,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_fastcgi_script_name_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_script_name_variable,,false,177,178,ngx_http_fastcgi_script_name_variable,,,37,"ngx_int_t ngx_http_fastcgi_script_name_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
116056,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_fastcgi_path_info_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_path_info_variable,,false,179,180,ngx_http_fastcgi_path_info_variable,,,38,"ngx_int_t ngx_http_fastcgi_path_info_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
116063,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,"static ngx_http_fastcgi_ctx_t *ngx_http_fastcgi_split(ngx_http_request_t *r,
    ngx_http_fastcgi_loc_conf_t *flcf);",31,38,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_split,,false,181,182,ngx_http_fastcgi_split,,,39,"ngx_http_fastcgi_ctx_t* ngx_http_fastcgi_split (ngx_http_request_t*,ngx_http_fastcgi_loc_conf_t*)"
116069,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,"static char *ngx_http_fastcgi_pass(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_pass,,false,184,185,ngx_http_fastcgi_pass,,,40,"char* ngx_http_fastcgi_pass (ngx_conf_t*,ngx_command_t*,void*)"
116076,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,"static char *ngx_http_fastcgi_split_path_info(ngx_conf_t *cf,
    ngx_command_t *cmd, void *conf);",13,35,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_split_path_info,,false,186,187,ngx_http_fastcgi_split_path_info,,,41,"char* ngx_http_fastcgi_split_path_info (ngx_conf_t*,ngx_command_t*,void*)"
116083,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,"static char *ngx_http_fastcgi_store(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_store,,false,188,189,ngx_http_fastcgi_store,,,42,"char* ngx_http_fastcgi_store (ngx_conf_t*,ngx_command_t*,void*)"
116090,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,"static char *ngx_http_fastcgi_lowat_check(ngx_conf_t *cf, void *post,
    void *data);",13,15,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_lowat_check,,false,197,198,ngx_http_fastcgi_lowat_check,,,43,"char* ngx_http_fastcgi_lowat_check (ngx_conf_t*,void*,void*)"
116868,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_fastcgi_handler(ngx_http_request_t *r)
{
    ngx_int_t                      rc;
    ngx_http_upstream_t           *u;
    ngx_http_fastcgi_ctx_t        *f;
    ngx_http_fastcgi_loc_conf_t   *flcf;
#if (NGX_HTTP_CACHE)
    ngx_http_fastcgi_main_conf_t  *fmcf;
#endif

    if (ngx_http_upstream_create(r) != NGX_OK) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    f = ngx_pcalloc(r->pool, sizeof(ngx_http_fastcgi_ctx_t));
    if (f == NULL) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    ngx_http_set_ctx(r, f, ngx_http_fastcgi_module);

    flcf = ngx_http_get_module_loc_conf(r, ngx_http_fastcgi_module);

    if (flcf->fastcgi_lengths) {
        if (ngx_http_fastcgi_eval(r, flcf) != NGX_OK) {
            return NGX_HTTP_INTERNAL_SERVER_ERROR;
        }
    }

    u = r->upstream;

    ngx_str_set(&u->schema, ""fastcgi://"");
    u->output.tag = (ngx_buf_tag_t) &ngx_http_fastcgi_module;

    u->conf = &flcf->upstream;

#if (NGX_HTTP_CACHE)
  ...",1,1,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_handler,,false,677,755,ngx_http_fastcgi_handler,,,63,ngx_int_t ngx_http_fastcgi_handler (ngx_http_request_t*)
117071,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_fastcgi_eval(ngx_http_request_t *r, ngx_http_fastcgi_loc_conf_t *flcf)
{
    ngx_url_t             url;
    ngx_http_upstream_t  *u;

    ngx_memzero(&url, sizeof(ngx_url_t));

    if (ngx_http_script_run(r, &url.url, flcf->fastcgi_lengths->elts, 0,
                            flcf->fastcgi_values->elts)
        == NULL)
    {
        return NGX_ERROR;
    }

    url.no_resolve = 1;

    if (ngx_parse_url(r->pool, &url) != NGX_OK) {
        if (url.err) {
            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                          ""%s in upstream \""%V\"""", url.err, &url.url);
        }

        return NGX_ERROR;
    }

    u = r->upstream;

    u->resolved = ngx_pcalloc(r->pool, sizeof(ngx_http_upstream_resolved_t));
    if (u->resolved == NULL) {
        return NGX_ERROR;
    }

    if (url.addrs) {
        u->resolved->sockaddr = url.addrs[0].sockaddr;
        u->resolved->socklen = url.addrs[0].socklen;
        u->resolved->name = url.addrs[0]....",1,1,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_eval,,false,758,803,ngx_http_fastcgi_eval,,,64,"ngx_int_t ngx_http_fastcgi_eval (ngx_http_request_t*,ngx_http_fastcgi_loc_conf_t*)"
117249,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_fastcgi_create_request(ngx_http_request_t *r)
{
    off_t                         file_pos;
    u_char                        ch, *pos, *lowcase_key;
    size_t                        size, len, key_len, val_len, padding,
                                  allocated;
    ngx_uint_t                    i, n, next, hash, skip_empty, header_params;
    ngx_buf_t                    *b;
    ngx_chain_t                  *cl, *body;
    ngx_list_part_t              *part;
    ngx_table_elt_t              *header, **ignored;
    ngx_http_upstream_t          *u;
    ngx_http_script_code_pt       code;
    ngx_http_script_engine_t      e, le;
    ngx_http_fastcgi_header_t    *h;
    ngx_http_fastcgi_params_t    *params;
    ngx_http_fastcgi_loc_conf_t  *flcf;
    ngx_http_script_len_code_pt   lcode;

    len = 0;
    header_params = 0;
    ignored = NULL;

    u = r->upstream;

    flcf = ngx_http_get_module_loc_conf(r, ngx_http_fastcgi_module);

#if (NGX_HTTP_CACHE)
 ...",1,26,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_create_request,,false,831,1317,ngx_http_fastcgi_create_request,,,65,ngx_int_t ngx_http_fastcgi_create_request (ngx_http_request_t*)
119040,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_fastcgi_reinit_request(ngx_http_request_t *r)
{
    ngx_http_fastcgi_ctx_t  *f;

    f = ngx_http_get_module_ctx(r, ngx_http_fastcgi_module);

    if (f == NULL) {
        return NGX_OK;
    }

    f->state = ngx_http_fastcgi_st_version;
    f->fastcgi_stdout = 0;
    f->large_stderr = 0;

    if (f->split_parts) {
        f->split_parts->nelts = 0;
    }

    r->state = 0;

    return NGX_OK;
}",1,1,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_reinit_request,,false,1320,1342,ngx_http_fastcgi_reinit_request,,,66,ngx_int_t ngx_http_fastcgi_reinit_request (ngx_http_request_t*)
119092,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_fastcgi_body_output_filter(void *data, ngx_chain_t *in)
{
    ngx_http_request_t  *r = data;

    off_t                       file_pos;
    u_char                     *pos, *start;
    size_t                      len, padding;
    ngx_buf_t                  *b;
    ngx_int_t                   rc;
    ngx_uint_t                  next, last;
    ngx_chain_t                *cl, *tl, *out, **ll;
    ngx_http_fastcgi_ctx_t     *f;
    ngx_http_fastcgi_header_t  *h;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""fastcgi output filter"");

    f = ngx_http_get_module_ctx(r, ngx_http_fastcgi_module);

    if (in == NULL) {
        out = in;
        goto out;
    }

    out = NULL;
    ll = &out;

    if (!f->header_sent) {
        /* first buffer contains headers, pass it unmodified */

        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                       ""fastcgi output header"");

        f->header_sent = 1;

 ...",1,22,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_body_output_filter,,false,1345,1630,ngx_http_fastcgi_body_output_filter,,,67,"ngx_int_t ngx_http_fastcgi_body_output_filter (void*,ngx_chain_t*)"
119963,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_fastcgi_process_header(ngx_http_request_t *r)
{
    u_char                         *p, *msg, *start, *last,
                                   *part_start, *part_end;
    size_t                          size;
    ngx_str_t                      *status_line, *pattern;
    ngx_int_t                       rc, status;
    ngx_buf_t                       buf;
    ngx_uint_t                      i;
    ngx_table_elt_t                *h;
    ngx_http_upstream_t            *u;
    ngx_http_fastcgi_ctx_t         *f;
    ngx_http_upstream_header_t     *hh;
    ngx_http_fastcgi_loc_conf_t    *flcf;
    ngx_http_fastcgi_split_part_t  *part;
    ngx_http_upstream_main_conf_t  *umcf;

    f = ngx_http_get_module_ctx(r, ngx_http_fastcgi_module);

    umcf = ngx_http_get_module_main_conf(r, ngx_http_upstream_module);

    u = r->upstream;

    for ( ;; ) {

        if (f->state < ngx_http_fastcgi_st_data) {

            f->pos = u->buffer.pos;
            f->last = u->buff...",1,27,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_process_header,,false,1633,2072,ngx_http_fastcgi_process_header,,,68,ngx_int_t ngx_http_fastcgi_process_header (ngx_http_request_t*)
121403,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_fastcgi_input_filter_init(void *data)
{
    ngx_http_request_t           *r = data;
    ngx_http_fastcgi_loc_conf_t  *flcf;

    flcf = ngx_http_get_module_loc_conf(r, ngx_http_fastcgi_module);

    r->upstream->pipe->length = flcf->keep_conn ?
                                (off_t) sizeof(ngx_http_fastcgi_header_t) : -1;

    return NGX_OK;
}",1,1,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_input_filter_init,,false,2075,2087,ngx_http_fastcgi_input_filter_init,,,69,ngx_int_t ngx_http_fastcgi_input_filter_init (void*)
121438,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_fastcgi_input_filter(ngx_event_pipe_t *p, ngx_buf_t *buf)
{
    u_char                       *m, *msg;
    ngx_int_t                     rc;
    ngx_buf_t                    *b, **prev;
    ngx_chain_t                  *cl;
    ngx_http_request_t           *r;
    ngx_http_fastcgi_ctx_t       *f;
    ngx_http_fastcgi_loc_conf_t  *flcf;

    if (buf->pos == buf->last) {
        return NGX_OK;
    }

    r = p->input_ctx;
    f = ngx_http_get_module_ctx(r, ngx_http_fastcgi_module);
    flcf = ngx_http_get_module_loc_conf(r, ngx_http_fastcgi_module);

    b = NULL;
    prev = &buf->shadow;

    f->pos = buf->pos;
    f->last = buf->last;

    for ( ;; ) {
        if (f->state < ngx_http_fastcgi_st_data) {

            rc = ngx_http_fastcgi_process_record(r, f);

            if (rc == NGX_AGAIN) {
                break;
            }

            if (rc == NGX_ERROR) {
                return NGX_ERROR;
            }

            if (f->type == NGX_HTTP_FASTCGI_...",1,27,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_input_filter,,false,2090,2337,ngx_http_fastcgi_input_filter,,,70,"ngx_int_t ngx_http_fastcgi_input_filter (ngx_event_pipe_t*,ngx_buf_t*)"
122179,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_fastcgi_non_buffered_filter(void *data, ssize_t bytes)
{
    u_char                  *m, *msg;
    ngx_int_t                rc;
    ngx_buf_t               *b, *buf;
    ngx_chain_t             *cl, **ll;
    ngx_http_request_t      *r;
    ngx_http_upstream_t     *u;
    ngx_http_fastcgi_ctx_t  *f;

    r = data;
    f = ngx_http_get_module_ctx(r, ngx_http_fastcgi_module);

    u = r->upstream;
    buf = &u->buffer;

    buf->pos = buf->last;
    buf->last += bytes;

    for (cl = u->out_bufs, ll = &u->out_bufs; cl; cl = cl->next) {
        ll = &cl->next;
    }

    f->pos = buf->pos;
    f->last = buf->last;

    for ( ;; ) {
        if (f->state < ngx_http_fastcgi_st_data) {

            rc = ngx_http_fastcgi_process_record(r, f);

            if (rc == NGX_AGAIN) {
                break;
            }

            if (rc == NGX_ERROR) {
                return NGX_ERROR;
            }

            if (f->type == NGX_HTTP_FASTCGI_STDOUT && f->length == 0...",1,27,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_non_buffered_filter,,false,2340,2523,ngx_http_fastcgi_non_buffered_filter,,,71,"ngx_int_t ngx_http_fastcgi_non_buffered_filter (void*,ssize_t)"
122773,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_fastcgi_process_record(ngx_http_request_t *r,
    ngx_http_fastcgi_ctx_t *f)
{
    u_char                     ch, *p;
    ngx_http_fastcgi_state_e   state;

    state = f->state;

    for (p = f->pos; p < f->last; p++) {

        ch = *p;

        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                       ""http fastcgi record byte: %02Xd"", ch);

        switch (state) {

        case ngx_http_fastcgi_st_version:
            if (ch != 1) {
                ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                              ""upstream sent unsupported FastCGI ""
                              ""protocol version: %d"", ch);
                return NGX_ERROR;
            }
            state = ngx_http_fastcgi_st_type;
            break;

        case ngx_http_fastcgi_st_type:
            switch (ch) {
            case NGX_HTTP_FASTCGI_STDOUT:
            case NGX_HTTP_FASTCGI_STDERR:
            case NGX_HTTP_FASTCGI_END_REQUEST:
    ...",1,17,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_process_record,,false,2526,2630,ngx_http_fastcgi_process_record,,,72,"ngx_int_t ngx_http_fastcgi_process_record (ngx_http_request_t*,ngx_http_fastcgi_ctx_t*)"
123017,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,"static void
ngx_http_fastcgi_abort_request(ngx_http_request_t *r)
{
    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""abort http fastcgi request"");

    return;
}",1,1,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_abort_request,,false,2633,2640,ngx_http_fastcgi_abort_request,,,73,void ngx_http_fastcgi_abort_request (ngx_http_request_t*)
123032,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,"static void
ngx_http_fastcgi_finalize_request(ngx_http_request_t *r, ngx_int_t rc)
{
    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""finalize http fastcgi request"");

    return;
}",1,1,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_finalize_request,,false,2643,2650,ngx_http_fastcgi_finalize_request,,,74,"void ngx_http_fastcgi_finalize_request (ngx_http_request_t*,ngx_int_t)"
123048,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_fastcgi_add_variables(ngx_conf_t *cf)
{
    ngx_http_variable_t  *var, *v;

    for (v = ngx_http_fastcgi_vars; v->name.len; v++) {
        var = ngx_http_add_variable(cf, &v->name, v->flags);
        if (var == NULL) {
            return NGX_ERROR;
        }

        var->get_handler = v->get_handler;
        var->data = v->data;
    }

    return NGX_OK;
}",1,1,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_add_variables,,false,2653,2669,ngx_http_fastcgi_add_variables,,,75,ngx_int_t ngx_http_fastcgi_add_variables (ngx_conf_t*)
123102,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,"static void *
ngx_http_fastcgi_create_main_conf(ngx_conf_t *cf)
{
    ngx_http_fastcgi_main_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_fastcgi_main_conf_t));
    if (conf == NULL) {
        return NULL;
    }

#if (NGX_HTTP_CACHE)
    if (ngx_array_init(&conf->caches, cf->pool, 4,
                       sizeof(ngx_http_file_cache_t *))
        != NGX_OK)
    {
        return NULL;
    }
#endif

    return conf;
}",1,1,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_create_main_conf,,false,2672,2692,ngx_http_fastcgi_create_main_conf,,,76,void* ngx_http_fastcgi_create_main_conf (ngx_conf_t*)
123125,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,"static void *
ngx_http_fastcgi_create_loc_conf(ngx_conf_t *cf)
{
    ngx_http_fastcgi_loc_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_fastcgi_loc_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     conf->upstream.bufs.num = 0;
     *     conf->upstream.ignore_headers = 0;
     *     conf->upstream.next_upstream = 0;
     *     conf->upstream.cache_zone = NULL;
     *     conf->upstream.cache_use_stale = 0;
     *     conf->upstream.cache_methods = 0;
     *     conf->upstream.temp_path = NULL;
     *     conf->upstream.hide_headers_hash = { NULL, 0 };
     *     conf->upstream.store_lengths = NULL;
     *     conf->upstream.store_values = NULL;
     *
     *     conf->index.len = { 0, NULL };
     */

    conf->upstream.store = NGX_CONF_UNSET;
    conf->upstream.store_access = NGX_CONF_UNSET_UINT;
    conf->upstream.next_upstream_tries = NGX_CONF_UNSET_UINT;
    conf->upstream.buffering = NGX_CONF_U...",1,1,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_create_loc_conf,,false,2695,2780,ngx_http_fastcgi_create_loc_conf,,,77,void* ngx_http_fastcgi_create_loc_conf (ngx_conf_t*)
123348,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,"static char *
ngx_http_fastcgi_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_fastcgi_loc_conf_t *prev = parent;
    ngx_http_fastcgi_loc_conf_t *conf = child;

    size_t                        size;
    ngx_int_t                     rc;
    ngx_hash_init_t               hash;
    ngx_http_core_loc_conf_t     *clcf;

#if (NGX_HTTP_CACHE)

    if (conf->upstream.store > 0) {
        conf->upstream.cache = 0;
    }

    if (conf->upstream.cache > 0) {
        conf->upstream.store = 0;
    }

#endif

    if (conf->upstream.store == NGX_CONF_UNSET) {
        ngx_conf_merge_value(conf->upstream.store,
                              prev->upstream.store, 0);

        conf->upstream.store_lengths = prev->upstream.store_lengths;
        conf->upstream.store_values = prev->upstream.store_values;
    }

    ngx_conf_merge_uint_value(conf->upstream.store_access,
                              prev->upstream.store_access, 0600);

    ngx_conf_merge_uint_value(conf->upst...",1,1,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_merge_loc_conf,,false,2783,3150,ngx_http_fastcgi_merge_loc_conf,,,78,"char* ngx_http_fastcgi_merge_loc_conf (ngx_conf_t*,void*,void*)"
124173,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_fastcgi_init_params(ngx_conf_t *cf, ngx_http_fastcgi_loc_conf_t *conf,
    ngx_http_fastcgi_params_t *params, ngx_keyval_t *default_params)
{
    u_char                       *p;
    size_t                        size;
    uintptr_t                    *code;
    ngx_uint_t                    i, nsrc;
    ngx_array_t                   headers_names, params_merged;
    ngx_keyval_t                 *h;
    ngx_hash_key_t               *hk;
    ngx_hash_init_t               hash;
    ngx_http_upstream_param_t    *src, *s;
    ngx_http_script_compile_t     sc;
    ngx_http_script_copy_code_t  *copy;

    if (params->hash.buckets) {
        return NGX_OK;
    }

    if (conf->params_source == NULL && default_params == NULL) {
        params->hash.buckets = (void *) 1;
        return NGX_OK;
    }

    params->lengths = ngx_array_create(cf->pool, 64, 1);
    if (params->lengths == NULL) {
        return NGX_ERROR;
    }

    params->values = ngx_array_create(cf->p...",1,1,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_init_params,,false,3153,3355,ngx_http_fastcgi_init_params,,,79,"ngx_int_t ngx_http_fastcgi_init_params (ngx_conf_t*,ngx_http_fastcgi_loc_conf_t*,ngx_http_fastcgi_params_t*,ngx_keyval_t*)"
124881,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_fastcgi_script_name_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    u_char                       *p;
    ngx_http_fastcgi_ctx_t       *f;
    ngx_http_fastcgi_loc_conf_t  *flcf;

    flcf = ngx_http_get_module_loc_conf(r, ngx_http_fastcgi_module);

    f = ngx_http_fastcgi_split(r, flcf);

    if (f == NULL) {
        return NGX_ERROR;
    }

    if (f->script_name.len == 0
        || f->script_name.data[f->script_name.len - 1] != '/')
    {
        v->len = f->script_name.len;
        v->valid = 1;
        v->no_cacheable = 0;
        v->not_found = 0;
        v->data = f->script_name.data;

        return NGX_OK;
    }

    v->len = f->script_name.len + flcf->index.len;

    v->data = ngx_pnalloc(r->pool, v->len);
    if (v->data == NULL) {
        return NGX_ERROR;
    }

    p = ngx_copy(v->data, f->script_name.data, f->script_name.len);
    ngx_memcpy(p, flcf->index.data, flcf->index.len);

    return NGX_OK;
}",1,1,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_script_name_variable,,false,3358,3397,ngx_http_fastcgi_script_name_variable,,,80,"ngx_int_t ngx_http_fastcgi_script_name_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
125033,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_fastcgi_path_info_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    ngx_http_fastcgi_ctx_t       *f;
    ngx_http_fastcgi_loc_conf_t  *flcf;

    flcf = ngx_http_get_module_loc_conf(r, ngx_http_fastcgi_module);

    f = ngx_http_fastcgi_split(r, flcf);

    if (f == NULL) {
        return NGX_ERROR;
    }

    v->len = f->path_info.len;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = f->path_info.data;

    return NGX_OK;
}",1,1,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_path_info_variable,,false,3400,3422,ngx_http_fastcgi_path_info_variable,,,81,"ngx_int_t ngx_http_fastcgi_path_info_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
125094,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,"static ngx_http_fastcgi_ctx_t *
ngx_http_fastcgi_split(ngx_http_request_t *r, ngx_http_fastcgi_loc_conf_t *flcf)
{
    ngx_http_fastcgi_ctx_t       *f;
#if (NGX_PCRE)
    ngx_int_t                     n;
    int                           captures[(1 + 2) * 3];

    f = ngx_http_get_module_ctx(r, ngx_http_fastcgi_module);

    if (f == NULL) {
        f = ngx_pcalloc(r->pool, sizeof(ngx_http_fastcgi_ctx_t));
        if (f == NULL) {
            return NULL;
        }

        ngx_http_set_ctx(r, f, ngx_http_fastcgi_module);
    }

    if (f->script_name.len) {
        return f;
    }

    if (flcf->split_regex == NULL) {
        f->script_name = r->uri;
        return f;
    }

    n = ngx_regex_exec(flcf->split_regex, &r->uri, captures, (1 + 2) * 3);

    if (n >= 0) { /* match */
        f->script_name.len = captures[3] - captures[2];
        f->script_name.data = r->uri.data + captures[2];

        f->path_info.len = captures[5] - captures[4];
        f->path_info.data = r->uri.da...",1,1,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_split,,false,3425,3493,ngx_http_fastcgi_split,,,82,"ngx_http_fastcgi_ctx_t ngx_http_fastcgi_split (ngx_http_request_t*,ngx_http_fastcgi_loc_conf_t*)"
125139,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,"static char *
ngx_http_fastcgi_pass(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_fastcgi_loc_conf_t *flcf = conf;

    ngx_url_t                   u;
    ngx_str_t                  *value, *url;
    ngx_uint_t                  n;
    ngx_http_core_loc_conf_t   *clcf;
    ngx_http_script_compile_t   sc;

    if (flcf->upstream.upstream || flcf->fastcgi_lengths) {
        return ""is duplicate"";
    }

    clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);

    clcf->handler = ngx_http_fastcgi_handler;

    if (clcf->name.len && clcf->name.data[clcf->name.len - 1] == '/') {
        clcf->auto_redirect = 1;
    }

    value = cf->args->elts;

    url = &value[1];

    n = ngx_http_script_variables_count(url);

    if (n) {

        ngx_memzero(&sc, sizeof(ngx_http_script_compile_t));

        sc.cf = cf;
        sc.source = url;
        sc.lengths = &flcf->fastcgi_lengths;
        sc.values = &flcf->fastcgi_values;
        sc.variables = n;
        sc....",1,1,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_pass,,false,3496,3555,ngx_http_fastcgi_pass,,,83,"char* ngx_http_fastcgi_pass (ngx_conf_t*,ngx_command_t*,void*)"
125325,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,"static char *
ngx_http_fastcgi_split_path_info(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
#if (NGX_PCRE)
    ngx_http_fastcgi_loc_conf_t *flcf = conf;

    ngx_str_t            *value;
    ngx_regex_compile_t   rc;
    u_char                errstr[NGX_MAX_CONF_ERRSTR];

    value = cf->args->elts;

    flcf->split_name = value[1];

    ngx_memzero(&rc, sizeof(ngx_regex_compile_t));

    rc.pattern = value[1];
    rc.pool = cf->pool;
    rc.err.len = NGX_MAX_CONF_ERRSTR;
    rc.err.data = errstr;

    if (ngx_regex_compile(&rc) != NGX_OK) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, ""%V"", &rc.err);
        return NGX_CONF_ERROR;
    }

    if (rc.captures != 2) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""pattern \""%V\"" must have 2 captures"", &value[1]);
        return NGX_CONF_ERROR;
    }

    flcf->split_regex = rc.regex;

    return NGX_CONF_OK;

#else

    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                       ""\""%V\"" requi...",1,1,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_split_path_info,,false,3558,3601,ngx_http_fastcgi_split_path_info,,,84,"char* ngx_http_fastcgi_split_path_info (ngx_conf_t*,ngx_command_t*,void*)"
125343,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,"static char *
ngx_http_fastcgi_store(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_fastcgi_loc_conf_t *flcf = conf;

    ngx_str_t                  *value;
    ngx_http_script_compile_t   sc;

    if (flcf->upstream.store != NGX_CONF_UNSET) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    if (ngx_strcmp(value[1].data, ""off"") == 0) {
        flcf->upstream.store = 0;
        return NGX_CONF_OK;
    }

#if (NGX_HTTP_CACHE)
    if (flcf->upstream.cache > 0) {
        return ""is incompatible with \""fastcgi_cache\"""";
    }
#endif

    flcf->upstream.store = 1;

    if (ngx_strcmp(value[1].data, ""on"") == 0) {
        return NGX_CONF_OK;
    }

    /* include the terminating '\0' into script */
    value[1].len++;

    ngx_memzero(&sc, sizeof(ngx_http_script_compile_t));

    sc.cf = cf;
    sc.source = &value[1];
    sc.lengths = &flcf->upstream.store_lengths;
    sc.values = &flcf->upstream.store_values;
    sc.variables = ngx_http_script_variable...",1,1,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_store,,false,3604,3653,ngx_http_fastcgi_store,,,85,"char* ngx_http_fastcgi_store (ngx_conf_t*,ngx_command_t*,void*)"
125488,METHOD,http\modules\ngx_http_fastcgi_module.c:<global>,TYPE_DECL,"static char *
ngx_http_fastcgi_lowat_check(ngx_conf_t *cf, void *post, void *data)
{
#if (NGX_FREEBSD)
    ssize_t *np = data;

    if ((u_long) *np >= ngx_freebsd_net_inet_tcp_sendspace) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""\""fastcgi_send_lowat\"" must be less than %d ""
                           ""(sysctl net.inet.tcp.sendspace)"",
                           ngx_freebsd_net_inet_tcp_sendspace);

        return NGX_CONF_ERROR;
    }

#elif !(NGX_HAVE_SO_SNDLOWAT)
    ssize_t *np = data;

    ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
                       ""\""fastcgi_send_lowat\"" is not supported, ignored"");

    *np = 0;

#endif

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_fastcgi_module.c,ngx_http_fastcgi_lowat_check,,false,3747,3773,ngx_http_fastcgi_lowat_check,,,86,"char* ngx_http_fastcgi_lowat_check (ngx_conf_t*,void*,void*)"
125519,METHOD,http\modules\ngx_http_flv_module.c:<global>,TYPE_DECL,<global>,1,1,http\modules\ngx_http_flv_module.c,http\modules\ngx_http_flv_module.c:<global>,,false,1,266,<global>,,,1,
125521,METHOD,http\modules\ngx_http_flv_module.c:<global>,TYPE_DECL,"static char *ngx_http_flv(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",13,73,http\modules\ngx_http_flv_module.c,ngx_http_flv,,false,12,12,ngx_http_flv,,,1,"char* ngx_http_flv (ngx_conf_t*,ngx_command_t*,void*)"
125576,METHOD,http\modules\ngx_http_flv_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_flv_handler(ngx_http_request_t *r)
{
    u_char                    *last;
    off_t                      start, len;
    size_t                     root;
    ngx_int_t                  rc;
    ngx_uint_t                 level, i;
    ngx_str_t                  path, value;
    ngx_log_t                 *log;
    ngx_buf_t                 *b;
    ngx_chain_t                out[2];
    ngx_open_file_info_t       of;
    ngx_http_core_loc_conf_t  *clcf;

    if (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD))) {
        return NGX_HTTP_NOT_ALLOWED;
    }

    if (r->uri.data[r->uri.len - 1] == '/') {
        return NGX_DECLINED;
    }

    rc = ngx_http_discard_request_body(r);

    if (rc != NGX_OK) {
        return rc;
    }

    last = ngx_http_map_uri_to_path(r, &path, &root, 0);
    if (last == NULL) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    log = r->connection->log;

    path.len = last - path.data;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, l...",1,1,http\modules\ngx_http_flv_module.c,ngx_http_flv_handler,,false,61,254,ngx_http_flv_handler,,,10,ngx_int_t ngx_http_flv_handler (ngx_http_request_t*)
126158,METHOD,http\modules\ngx_http_flv_module.c:<global>,TYPE_DECL,"static char *
ngx_http_flv(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_core_loc_conf_t  *clcf;

    clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);
    clcf->handler = ngx_http_flv_handler;

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_flv_module.c,ngx_http_flv,,false,257,266,ngx_http_flv,,,11,"char* ngx_http_flv (ngx_conf_t*,ngx_command_t*,void*)"
126187,METHOD,http\modules\ngx_http_geo_module.c:<global>,TYPE_DECL,<global>,1,1,http\modules\ngx_http_geo_module.c,http\modules\ngx_http_geo_module.c:<global>,,false,1,1681,<global>,,,1,
126237,METHOD,http\modules\ngx_http_geo_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_geo_addr(ngx_http_request_t *r,
    ngx_http_geo_ctx_t *ctx, ngx_addr_t *addr);",18,46,http\modules\ngx_http_geo_module.c,ngx_http_geo_addr,,false,82,83,ngx_http_geo_addr,,,13,"ngx_int_t ngx_http_geo_addr (ngx_http_request_t*,ngx_http_geo_ctx_t*,ngx_addr_t*)"
126244,METHOD,http\modules\ngx_http_geo_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_geo_real_addr(ngx_http_request_t *r,
    ngx_http_geo_ctx_t *ctx, ngx_addr_t *addr);",18,46,http\modules\ngx_http_geo_module.c,ngx_http_geo_real_addr,,false,84,85,ngx_http_geo_real_addr,,,14,"ngx_int_t ngx_http_geo_real_addr (ngx_http_request_t*,ngx_http_geo_ctx_t*,ngx_addr_t*)"
126251,METHOD,http\modules\ngx_http_geo_module.c:<global>,TYPE_DECL,"static char *ngx_http_geo_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",13,79,http\modules\ngx_http_geo_module.c,ngx_http_geo_block,,false,86,86,ngx_http_geo_block,,,15,"char* ngx_http_geo_block (ngx_conf_t*,ngx_command_t*,void*)"
126258,METHOD,http\modules\ngx_http_geo_module.c:<global>,TYPE_DECL,"static char *ngx_http_geo(ngx_conf_t *cf, ngx_command_t *dummy, void *conf);",13,75,http\modules\ngx_http_geo_module.c,ngx_http_geo,,false,87,87,ngx_http_geo,,,16,"char* ngx_http_geo (ngx_conf_t*,ngx_command_t*,void*)"
126265,METHOD,http\modules\ngx_http_geo_module.c:<global>,TYPE_DECL,"static char *ngx_http_geo_range(ngx_conf_t *cf, ngx_http_geo_conf_ctx_t *ctx,
    ngx_str_t *value);",13,21,http\modules\ngx_http_geo_module.c,ngx_http_geo_range,,false,88,89,ngx_http_geo_range,,,17,"char* ngx_http_geo_range (ngx_conf_t*,ngx_http_geo_conf_ctx_t*,ngx_str_t*)"
126272,METHOD,http\modules\ngx_http_geo_module.c:<global>,TYPE_DECL,"static char *ngx_http_geo_add_range(ngx_conf_t *cf,
    ngx_http_geo_conf_ctx_t *ctx, in_addr_t start, in_addr_t end);",13,65,http\modules\ngx_http_geo_module.c,ngx_http_geo_add_range,,false,90,91,ngx_http_geo_add_range,,,18,"char* ngx_http_geo_add_range (ngx_conf_t*,ngx_http_geo_conf_ctx_t*,in_addr_t,in_addr_t)"
126280,METHOD,http\modules\ngx_http_geo_module.c:<global>,TYPE_DECL,"static ngx_uint_t ngx_http_geo_delete_range(ngx_conf_t *cf,
    ngx_http_geo_conf_ctx_t *ctx, in_addr_t start, in_addr_t end);",19,65,http\modules\ngx_http_geo_module.c,ngx_http_geo_delete_range,,false,92,93,ngx_http_geo_delete_range,,,19,"ngx_uint_t ngx_http_geo_delete_range (ngx_conf_t*,ngx_http_geo_conf_ctx_t*,in_addr_t,in_addr_t)"
126288,METHOD,http\modules\ngx_http_geo_module.c:<global>,TYPE_DECL,"static char *ngx_http_geo_cidr(ngx_conf_t *cf, ngx_http_geo_conf_ctx_t *ctx,
    ngx_str_t *value);",13,21,http\modules\ngx_http_geo_module.c,ngx_http_geo_cidr,,false,94,95,ngx_http_geo_cidr,,,20,"char* ngx_http_geo_cidr (ngx_conf_t*,ngx_http_geo_conf_ctx_t*,ngx_str_t*)"
126295,METHOD,http\modules\ngx_http_geo_module.c:<global>,TYPE_DECL,"static char *ngx_http_geo_cidr_add(ngx_conf_t *cf, ngx_http_geo_conf_ctx_t *ctx,
    ngx_cidr_t *cidr, ngx_str_t *value, ngx_str_t *net);",13,55,http\modules\ngx_http_geo_module.c,ngx_http_geo_cidr_add,,false,96,97,ngx_http_geo_cidr_add,,,21,"char* ngx_http_geo_cidr_add (ngx_conf_t*,ngx_http_geo_conf_ctx_t*,ngx_cidr_t*,ngx_str_t*,ngx_str_t*)"
126304,METHOD,http\modules\ngx_http_geo_module.c:<global>,TYPE_DECL,"static ngx_http_variable_value_t *ngx_http_geo_value(ngx_conf_t *cf,
    ngx_http_geo_conf_ctx_t *ctx, ngx_str_t *value);",34,51,http\modules\ngx_http_geo_module.c,ngx_http_geo_value,,false,98,99,ngx_http_geo_value,,,22,"ngx_http_variable_value_t* ngx_http_geo_value (ngx_conf_t*,ngx_http_geo_conf_ctx_t*,ngx_str_t*)"
126311,METHOD,http\modules\ngx_http_geo_module.c:<global>,TYPE_DECL,"static char *ngx_http_geo_add_proxy(ngx_conf_t *cf,
    ngx_http_geo_conf_ctx_t *ctx, ngx_cidr_t *cidr);",13,51,http\modules\ngx_http_geo_module.c,ngx_http_geo_add_proxy,,false,100,101,ngx_http_geo_add_proxy,,,23,"char* ngx_http_geo_add_proxy (ngx_conf_t*,ngx_http_geo_conf_ctx_t*,ngx_cidr_t*)"
126318,METHOD,http\modules\ngx_http_geo_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_geo_cidr_value(ngx_conf_t *cf, ngx_str_t *net,
    ngx_cidr_t *cidr);",18,21,http\modules\ngx_http_geo_module.c,ngx_http_geo_cidr_value,,false,102,103,ngx_http_geo_cidr_value,,,24,"ngx_int_t ngx_http_geo_cidr_value (ngx_conf_t*,ngx_str_t*,ngx_cidr_t*)"
126325,METHOD,http\modules\ngx_http_geo_module.c:<global>,TYPE_DECL,"static char *ngx_http_geo_include(ngx_conf_t *cf, ngx_http_geo_conf_ctx_t *ctx,
    ngx_str_t *name);",13,20,http\modules\ngx_http_geo_module.c,ngx_http_geo_include,,false,104,105,ngx_http_geo_include,,,25,"char* ngx_http_geo_include (ngx_conf_t*,ngx_http_geo_conf_ctx_t*,ngx_str_t*)"
126332,METHOD,http\modules\ngx_http_geo_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_geo_include_binary_base(ngx_conf_t *cf,
    ngx_http_geo_conf_ctx_t *ctx, ngx_str_t *name);",18,50,http\modules\ngx_http_geo_module.c,ngx_http_geo_include_binary_base,,false,106,107,ngx_http_geo_include_binary_base,,,26,"ngx_int_t ngx_http_geo_include_binary_base (ngx_conf_t*,ngx_http_geo_conf_ctx_t*,ngx_str_t*)"
126339,METHOD,http\modules\ngx_http_geo_module.c:<global>,TYPE_DECL,static void ngx_http_geo_create_binary_base(ngx_http_geo_conf_ctx_t *ctx);,13,73,http\modules\ngx_http_geo_module.c,ngx_http_geo_create_binary_base,,false,108,108,ngx_http_geo_create_binary_base,,,27,void ngx_http_geo_create_binary_base (ngx_http_geo_conf_ctx_t*)
126344,METHOD,http\modules\ngx_http_geo_module.c:<global>,TYPE_DECL,"static u_char *ngx_http_geo_copy_values(u_char *base, u_char *p,
    ngx_rbtree_node_t *node, ngx_rbtree_node_t *sentinel);",15,57,http\modules\ngx_http_geo_module.c,ngx_http_geo_copy_values,,false,109,110,ngx_http_geo_copy_values,,,28,"u_char* ngx_http_geo_copy_values (u_char*,u_char*,ngx_rbtree_node_t*,ngx_rbtree_node_t*)"
126404,METHOD,<empty>,<empty>,<empty>,1,,http\modules\ngx_http_geo_module.c,ngx_http_geo_header_t:<clinit>,,false,157,,<clinit>,,,6,
126427,METHOD,http\modules\ngx_http_geo_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_geo_cidr_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v,
    uintptr_t data)
{
    ngx_http_geo_ctx_t *ctx = (ngx_http_geo_ctx_t *) data;

    in_addr_t                   inaddr;
    ngx_addr_t                  addr;
    struct sockaddr_in         *sin;
    ngx_http_variable_value_t  *vv;
#if (NGX_HAVE_INET6)
    u_char                     *p;
    struct in6_addr            *inaddr6;
#endif

    if (ngx_http_geo_addr(r, ctx, &addr) != NGX_OK) {
        vv = (ngx_http_variable_value_t *)
                  ngx_radix32tree_find(ctx->u.trees.tree, INADDR_NONE);
        goto done;
    }

    switch (addr.sockaddr->sa_family) {

#if (NGX_HAVE_INET6)
    case AF_INET6:
        inaddr6 = &((struct sockaddr_in6 *) addr.sockaddr)->sin6_addr;
        p = inaddr6->s6_addr;

        if (IN6_IS_ADDR_V4MAPPED(inaddr6)) {
            inaddr = p[12] << 24;
            inaddr += p[13] << 16;
            inaddr += p[14] << 8;
            inaddr += p[15];

      ...",1,1,http\modules\ngx_http_geo_module.c,ngx_http_geo_cidr_variable,,false,173,243,ngx_http_geo_cidr_variable,,,39,"ngx_int_t ngx_http_geo_cidr_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
126522,METHOD,http\modules\ngx_http_geo_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_geo_range_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v,
    uintptr_t data)
{
    ngx_http_geo_ctx_t *ctx = (ngx_http_geo_ctx_t *) data;

    in_addr_t              inaddr;
    ngx_addr_t             addr;
    ngx_uint_t             n;
    struct sockaddr_in    *sin;
    ngx_http_geo_range_t  *range;
#if (NGX_HAVE_INET6)
    u_char                *p;
    struct in6_addr       *inaddr6;
#endif

    *v = *ctx->u.high.default_value;

    if (ngx_http_geo_addr(r, ctx, &addr) == NGX_OK) {

        switch (addr.sockaddr->sa_family) {

#if (NGX_HAVE_INET6)
        case AF_INET6:
            inaddr6 = &((struct sockaddr_in6 *) addr.sockaddr)->sin6_addr;

            if (IN6_IS_ADDR_V4MAPPED(inaddr6)) {
                p = inaddr6->s6_addr;

                inaddr = p[12] << 24;
                inaddr += p[13] << 16;
                inaddr += p[14] << 8;
                inaddr += p[15];

            } else {
                inaddr = INADDR_NONE;
    ...",1,1,http\modules\ngx_http_geo_module.c,ngx_http_geo_range_variable,,false,246,323,ngx_http_geo_range_variable,,,40,"ngx_int_t ngx_http_geo_range_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
126662,METHOD,http\modules\ngx_http_geo_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_geo_addr(ngx_http_request_t *r, ngx_http_geo_ctx_t *ctx,
    ngx_addr_t *addr)
{
    ngx_array_t  *xfwd;

    if (ngx_http_geo_real_addr(r, ctx, addr) != NGX_OK) {
        return NGX_ERROR;
    }

    xfwd = &r->headers_in.x_forwarded_for;

    if (xfwd->nelts > 0 && ctx->proxies != NULL) {
        (void) ngx_http_get_forwarded_addr(r, addr, xfwd, NULL,
                                           ctx->proxies, ctx->proxy_recursive);
    }

    return NGX_OK;
}",1,1,http\modules\ngx_http_geo_module.c,ngx_http_geo_addr,,false,326,344,ngx_http_geo_addr,,,41,"ngx_int_t ngx_http_geo_addr (ngx_http_request_t*,ngx_http_geo_ctx_t*,ngx_addr_t*)"
126716,METHOD,http\modules\ngx_http_geo_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_geo_real_addr(ngx_http_request_t *r, ngx_http_geo_ctx_t *ctx,
    ngx_addr_t *addr)
{
    ngx_http_variable_value_t  *v;

    if (ctx->index == -1) {
        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                       ""http geo started: %V"", &r->connection->addr_text);

        addr->sockaddr = r->connection->sockaddr;
        addr->socklen = r->connection->socklen;
        /* addr->name = r->connection->addr_text; */

        return NGX_OK;
    }

    v = ngx_http_get_flushed_variable(r, ctx->index);

    if (v == NULL || v->not_found) {
        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                       ""http geo not found"");

        return NGX_ERROR;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http geo started: %v"", v);

    if (ngx_parse_addr(r->pool, addr, v->data, v->len) == NGX_OK) {
        return NGX_OK;
    }

    return NGX_ERROR;
}",1,1,http\modules\ngx_http_geo_module.c,ngx_http_geo_real_addr,,false,347,381,ngx_http_geo_real_addr,,,42,"ngx_int_t ngx_http_geo_real_addr (ngx_http_request_t*,ngx_http_geo_ctx_t*,ngx_addr_t*)"
126823,METHOD,http\modules\ngx_http_geo_module.c:<global>,TYPE_DECL,"static char *
ngx_http_geo_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char                     *rv;
    size_t                    len;
    ngx_str_t                *value, name;
    ngx_uint_t                i;
    ngx_conf_t                save;
    ngx_pool_t               *pool;
    ngx_array_t              *a;
    ngx_http_variable_t      *var;
    ngx_http_geo_ctx_t       *geo;
    ngx_http_geo_conf_ctx_t   ctx;
#if (NGX_HAVE_INET6)
    static struct in6_addr    zero;
#endif

    value = cf->args->elts;

    geo = ngx_palloc(cf->pool, sizeof(ngx_http_geo_ctx_t));
    if (geo == NULL) {
        return NGX_CONF_ERROR;
    }

    name = value[1];

    if (name.data[0] != '$') {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""invalid variable name \""%V\"""", &name);
        return NGX_CONF_ERROR;
    }

    name.len--;
    name.data++;

    if (cf->args->nelts == 3) {

        geo->index = ngx_http_get_variable_index(cf, &name);
        i...",1,1,http\modules\ngx_http_geo_module.c,ngx_http_geo_block,,false,384,583,ngx_http_geo_block,,,43,"char* ngx_http_geo_block (ngx_conf_t*,ngx_command_t*,void*)"
127379,METHOD,http\modules\ngx_http_geo_module.c:<global>,TYPE_DECL,"static char *
ngx_http_geo(ngx_conf_t *cf, ngx_command_t *dummy, void *conf)
{
    char                     *rv;
    ngx_str_t                *value;
    ngx_cidr_t                cidr;
    ngx_http_geo_conf_ctx_t  *ctx;

    ctx = cf->ctx;

    value = cf->args->elts;

    if (cf->args->nelts == 1) {

        if (ngx_strcmp(value[0].data, ""ranges"") == 0) {

            if (ctx->tree
#if (NGX_HAVE_INET6)
                || ctx->tree6
#endif
               )
            {
                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                                   ""the \""ranges\"" directive must be ""
                                   ""the first directive inside \""geo\"" block"");
                goto failed;
            }

            ctx->ranges = 1;

            rv = NGX_CONF_OK;

            goto done;
        }

        else if (ngx_strcmp(value[0].data, ""proxy_recursive"") == 0) {
            ctx->proxy_recursive = 1;
            rv = NGX_CONF_OK;
            goto done;
        }
   ...",1,1,http\modules\ngx_http_geo_module.c,ngx_http_geo,,false,586,669,ngx_http_geo,,,44,"char* ngx_http_geo (ngx_conf_t*,ngx_command_t*,void*)"
127567,METHOD,http\modules\ngx_http_geo_module.c:<global>,TYPE_DECL,"static char *
ngx_http_geo_range(ngx_conf_t *cf, ngx_http_geo_conf_ctx_t *ctx,
    ngx_str_t *value)
{
    u_char      *p, *last;
    in_addr_t    start, end;
    ngx_str_t   *net;
    ngx_uint_t   del;

    if (ngx_strcmp(value[0].data, ""default"") == 0) {

        if (ctx->high.default_value) {
            ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
                ""duplicate default geo range value: \""%V\"", old value: \""%v\"""",
                &value[1], ctx->high.default_value);
        }

        ctx->high.default_value = ngx_http_geo_value(cf, ctx, &value[1]);
        if (ctx->high.default_value == NULL) {
            return NGX_CONF_ERROR;
        }

        return NGX_CONF_OK;
    }

    if (ctx->binary_include) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
            ""binary geo range base \""%s\"" cannot be mixed with usual entries"",
            ctx->include_name.data);
        return NGX_CONF_ERROR;
    }

    if (ctx->high.low == NULL) {
        ctx->high.low = ngx_pcalloc...",1,1,http\modules\ngx_http_geo_module.c,ngx_http_geo_range,,false,672,778,ngx_http_geo_range,,,45,"char* ngx_http_geo_range (ngx_conf_t*,ngx_http_geo_conf_ctx_t*,ngx_str_t*)"
127856,METHOD,http\modules\ngx_http_geo_module.c:<global>,TYPE_DECL,"static char *
ngx_http_geo_add_range(ngx_conf_t *cf, ngx_http_geo_conf_ctx_t *ctx,
    in_addr_t start, in_addr_t end)
{
    in_addr_t              n;
    ngx_uint_t             h, i, s, e;
    ngx_array_t           *a;
    ngx_http_geo_range_t  *range;

    for (n = start; n <= end; n = (n + 0x10000) & 0xffff0000) {

        h = n >> 16;

        if (n == start) {
            s = n & 0xffff;
        } else {
            s = 0;
        }

        if ((n | 0xffff) > end) {
            e = end & 0xffff;

        } else {
            e = 0xffff;
        }

        a = (ngx_array_t *) ctx->high.low[h];

        if (a == NULL) {
            a = ngx_array_create(ctx->temp_pool, 64,
                                 sizeof(ngx_http_geo_range_t));
            if (a == NULL) {
                return NGX_CONF_ERROR;
            }

            ctx->high.low[h] = (ngx_http_geo_range_t *) a;
        }

        i = a->nelts;
        range = a->elts;

        while (i) {

            i--;

        ...",1,1,http\modules\ngx_http_geo_module.c,ngx_http_geo_add_range,,false,783,982,ngx_http_geo_add_range,,,46,"char* ngx_http_geo_add_range (ngx_conf_t*,ngx_http_geo_conf_ctx_t*,in_addr_t,in_addr_t)"
128601,METHOD,http\modules\ngx_http_geo_module.c:<global>,TYPE_DECL,"static ngx_uint_t
ngx_http_geo_delete_range(ngx_conf_t *cf, ngx_http_geo_conf_ctx_t *ctx,
    in_addr_t start, in_addr_t end)
{
    in_addr_t              n;
    ngx_uint_t             h, i, s, e, warn;
    ngx_array_t           *a;
    ngx_http_geo_range_t  *range;

    warn = 0;

    for (n = start; n <= end; n = (n + 0x10000) & 0xffff0000) {

        h = n >> 16;

        if (n == start) {
            s = n & 0xffff;
        } else {
            s = 0;
        }

        if ((n | 0xffff) > end) {
            e = end & 0xffff;

        } else {
            e = 0xffff;
        }

        a = (ngx_array_t *) ctx->high.low[h];

        if (a == NULL || a->nelts == 0) {
            warn = 1;
            goto next;
        }

        range = a->elts;
        for (i = 0; i < a->nelts; i++) {

            if (s == (ngx_uint_t) range[i].start
                && e == (ngx_uint_t) range[i].end)
            {
                ngx_memmove(&range[i], &range[i + 1],
                            (...",1,1,http\modules\ngx_http_geo_module.c,ngx_http_geo_delete_range,,false,985,1047,ngx_http_geo_delete_range,,,47,"ngx_uint_t ngx_http_geo_delete_range (ngx_conf_t*,ngx_http_geo_conf_ctx_t*,in_addr_t,in_addr_t)"
128785,METHOD,http\modules\ngx_http_geo_module.c:<global>,TYPE_DECL,"static char *
ngx_http_geo_cidr(ngx_conf_t *cf, ngx_http_geo_conf_ctx_t *ctx,
    ngx_str_t *value)
{
    char        *rv;
    ngx_int_t    rc, del;
    ngx_str_t   *net;
    ngx_cidr_t   cidr;

    if (ctx->tree == NULL) {
        ctx->tree = ngx_radix_tree_create(ctx->pool, -1);
        if (ctx->tree == NULL) {
            return NGX_CONF_ERROR;
        }
    }

#if (NGX_HAVE_INET6)
    if (ctx->tree6 == NULL) {
        ctx->tree6 = ngx_radix_tree_create(ctx->pool, -1);
        if (ctx->tree6 == NULL) {
            return NGX_CONF_ERROR;
        }
    }
#endif

    if (ngx_strcmp(value[0].data, ""default"") == 0) {
        cidr.family = AF_INET;
        cidr.u.in.addr = 0;
        cidr.u.in.mask = 0;

        rv = ngx_http_geo_cidr_add(cf, ctx, &cidr, &value[1], &value[0]);

        if (rv != NGX_CONF_OK) {
            return rv;
        }

#if (NGX_HAVE_INET6)
        cidr.family = AF_INET6;
        ngx_memzero(&cidr.u.in6, sizeof(ngx_in6_cidr_t));

        rv = ngx_http_geo_cidr_a...",1,1,http\modules\ngx_http_geo_module.c,ngx_http_geo_cidr,,false,1050,1144,ngx_http_geo_cidr,,,48,"char* ngx_http_geo_cidr (ngx_conf_t*,ngx_http_geo_conf_ctx_t*,ngx_str_t*)"
129016,METHOD,http\modules\ngx_http_geo_module.c:<global>,TYPE_DECL,"static char *
ngx_http_geo_cidr_add(ngx_conf_t *cf, ngx_http_geo_conf_ctx_t *ctx,
    ngx_cidr_t *cidr, ngx_str_t *value, ngx_str_t *net)
{
    ngx_int_t                   rc;
    ngx_http_variable_value_t  *val, *old;

    val = ngx_http_geo_value(cf, ctx, value);

    if (val == NULL) {
        return NGX_CONF_ERROR;
    }

    switch (cidr->family) {

#if (NGX_HAVE_INET6)
    case AF_INET6:
        rc = ngx_radix128tree_insert(ctx->tree6, cidr->u.in6.addr.s6_addr,
                                     cidr->u.in6.mask.s6_addr,
                                     (uintptr_t) val);

        if (rc == NGX_OK) {
            return NGX_CONF_OK;
        }

        if (rc == NGX_ERROR) {
            return NGX_CONF_ERROR;
        }

        /* rc == NGX_BUSY */

        old = (ngx_http_variable_value_t *)
                   ngx_radix128tree_find(ctx->tree6,
                                         cidr->u.in6.addr.s6_addr);

        ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
              ...",1,1,http\modules\ngx_http_geo_module.c,ngx_http_geo_cidr_add,,false,1147,1242,ngx_http_geo_cidr_add,,,49,"char* ngx_http_geo_cidr_add (ngx_conf_t*,ngx_http_geo_conf_ctx_t*,ngx_cidr_t*,ngx_str_t*,ngx_str_t*)"
129172,METHOD,http\modules\ngx_http_geo_module.c:<global>,TYPE_DECL,"static ngx_http_variable_value_t *
ngx_http_geo_value(ngx_conf_t *cf, ngx_http_geo_conf_ctx_t *ctx,
    ngx_str_t *value)
{
    uint32_t                             hash;
    ngx_http_variable_value_t           *val;
    ngx_http_geo_variable_value_node_t  *gvvn;

    hash = ngx_crc32_long(value->data, value->len);

    gvvn = (ngx_http_geo_variable_value_node_t *)
               ngx_str_rbtree_lookup(&ctx->rbtree, value, hash);

    if (gvvn) {
        return gvvn->value;
    }

    val = ngx_palloc(ctx->pool, sizeof(ngx_http_variable_value_t));
    if (val == NULL) {
        return NULL;
    }

    val->len = value->len;
    val->data = ngx_pstrdup(ctx->pool, value);
    if (val->data == NULL) {
        return NULL;
    }

    val->valid = 1;
    val->no_cacheable = 0;
    val->not_found = 0;

    gvvn = ngx_palloc(ctx->temp_pool,
                      sizeof(ngx_http_geo_variable_value_node_t));
    if (gvvn == NULL) {
        return NULL;
    }

    gvvn->sn.node.key = hash;
   ...",1,1,http\modules\ngx_http_geo_module.c,ngx_http_geo_value,,false,1245,1295,ngx_http_geo_value,,,50,"ngx_http_variable_value_t ngx_http_geo_value (ngx_conf_t*,ngx_http_geo_conf_ctx_t*,ngx_str_t*)"
129346,METHOD,http\modules\ngx_http_geo_module.c:<global>,TYPE_DECL,"static char *
ngx_http_geo_add_proxy(ngx_conf_t *cf, ngx_http_geo_conf_ctx_t *ctx,
    ngx_cidr_t *cidr)
{
    ngx_cidr_t  *c;

    if (ctx->proxies == NULL) {
        ctx->proxies = ngx_array_create(ctx->pool, 4, sizeof(ngx_cidr_t));
        if (ctx->proxies == NULL) {
            return NGX_CONF_ERROR;
        }
    }

    c = ngx_array_push(ctx->proxies);
    if (c == NULL) {
        return NGX_CONF_ERROR;
    }

    *c = *cidr;

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_geo_module.c,ngx_http_geo_add_proxy,,false,1298,1319,ngx_http_geo_add_proxy,,,51,"char* ngx_http_geo_add_proxy (ngx_conf_t*,ngx_http_geo_conf_ctx_t*,ngx_cidr_t*)"
129401,METHOD,http\modules\ngx_http_geo_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_geo_cidr_value(ngx_conf_t *cf, ngx_str_t *net, ngx_cidr_t *cidr)
{
    ngx_int_t  rc;

    if (ngx_strcmp(net->data, ""255.255.255.255"") == 0) {
        cidr->family = AF_INET;
        cidr->u.in.addr = 0xffffffff;
        cidr->u.in.mask = 0xffffffff;

        return NGX_OK;
    }

    rc = ngx_ptocidr(net, cidr);

    if (rc == NGX_ERROR) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, ""invalid network \""%V\"""", net);
        return NGX_ERROR;
    }

    if (rc == NGX_DONE) {
        ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
                           ""low address bits of %V are meaningless"", net);
    }

    return NGX_OK;
}",1,1,http\modules\ngx_http_geo_module.c,ngx_http_geo_cidr_value,,false,1322,1348,ngx_http_geo_cidr_value,,,52,"ngx_int_t ngx_http_geo_cidr_value (ngx_conf_t*,ngx_str_t*,ngx_cidr_t*)"
129474,METHOD,http\modules\ngx_http_geo_module.c:<global>,TYPE_DECL,"static char *
ngx_http_geo_include(ngx_conf_t *cf, ngx_http_geo_conf_ctx_t *ctx,
    ngx_str_t *name)
{
    char       *rv;
    ngx_str_t   file;

    file.len = name->len + 4;
    file.data = ngx_pnalloc(ctx->temp_pool, name->len + 5);
    if (file.data == NULL) {
        return NGX_CONF_ERROR;
    }

    ngx_sprintf(file.data, ""%V.bin%Z"", name);

    if (ngx_conf_full_name(cf->cycle, &file, 1) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    if (ctx->ranges) {
        ngx_log_debug1(NGX_LOG_DEBUG_CORE, cf->log, 0, ""include %s"", file.data);

        switch (ngx_http_geo_include_binary_base(cf, ctx, &file)) {
        case NGX_OK:
            return NGX_CONF_OK;
        case NGX_ERROR:
            return NGX_CONF_ERROR;
        default:
            break;
        }
    }

    file.len -= 4;
    file.data[file.len] = '\0';

    ctx->include_name = file;

    if (ctx->outside_entries) {
        ctx->allow_binary_include = 0;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_CORE, cf->log, ...",1,1,http\modules\ngx_http_geo_module.c,ngx_http_geo_include,,false,1351,1400,ngx_http_geo_include,,,53,"char* ngx_http_geo_include (ngx_conf_t*,ngx_http_geo_conf_ctx_t*,ngx_str_t*)"
129621,METHOD,http\modules\ngx_http_geo_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_geo_include_binary_base(ngx_conf_t *cf, ngx_http_geo_conf_ctx_t *ctx,
    ngx_str_t *name)
{
    u_char                     *base, ch;
    time_t                      mtime;
    size_t                      size, len;
    ssize_t                     n;
    uint32_t                    crc32;
    ngx_err_t                   err;
    ngx_int_t                   rc;
    ngx_uint_t                  i;
    ngx_file_t                  file;
    ngx_file_info_t             fi;
    ngx_http_geo_range_t       *range, **ranges;
    ngx_http_geo_header_t      *header;
    ngx_http_variable_value_t  *vv;

    ngx_memzero(&file, sizeof(ngx_file_t));
    file.name = *name;
    file.log = cf->log;

    file.fd = ngx_open_file(name->data, NGX_FILE_RDONLY, NGX_FILE_OPEN, 0);

    if (file.fd == NGX_INVALID_FILE) {
        err = ngx_errno;
        if (err != NGX_ENOENT) {
            ngx_conf_log_error(NGX_LOG_CRIT, cf, err,
                               ngx_open_file_n "" \""%...",1,1,http\modules\ngx_http_geo_module.c,ngx_http_geo_include_binary_base,,false,1403,1574,ngx_http_geo_include_binary_base,,,54,"ngx_int_t ngx_http_geo_include_binary_base (ngx_conf_t*,ngx_http_geo_conf_ctx_t*,ngx_str_t*)"
130114,METHOD,http\modules\ngx_http_geo_module.c:<global>,TYPE_DECL,"static void
ngx_http_geo_create_binary_base(ngx_http_geo_conf_ctx_t *ctx)
{
    u_char                              *p;
    uint32_t                             hash;
    ngx_str_t                            s;
    ngx_uint_t                           i;
    ngx_file_mapping_t                   fm;
    ngx_http_geo_range_t                *r, *range, **ranges;
    ngx_http_geo_header_t               *header;
    ngx_http_geo_variable_value_node_t  *gvvn;

    fm.name = ngx_pnalloc(ctx->temp_pool, ctx->include_name.len + 5);
    if (fm.name == NULL) {
        return;
    }

    ngx_sprintf(fm.name, ""%V.bin%Z"", &ctx->include_name);

    fm.size = ctx->data_size;
    fm.log = ctx->pool->log;

    ngx_log_error(NGX_LOG_NOTICE, fm.log, 0,
                  ""creating binary geo range base \""%s\"""", fm.name);

    if (ngx_create_file_mapping(&fm) != NGX_OK) {
        return;
    }

    p = ngx_cpymem(fm.addr, &ngx_http_geo_header,
                   sizeof(ngx_http_geo_header_t));

    p = n...",1,1,http\modules\ngx_http_geo_module.c,ngx_http_geo_create_binary_base,,false,1577,1652,ngx_http_geo_create_binary_base,,,55,void ngx_http_geo_create_binary_base (ngx_http_geo_conf_ctx_t*)
130391,METHOD,http\modules\ngx_http_geo_module.c:<global>,TYPE_DECL,"static u_char *
ngx_http_geo_copy_values(u_char *base, u_char *p, ngx_rbtree_node_t *node,
    ngx_rbtree_node_t *sentinel)
{
    ngx_http_variable_value_t           *vv;
    ngx_http_geo_variable_value_node_t  *gvvn;

    if (node == sentinel) {
        return p;
    }

    gvvn = (ngx_http_geo_variable_value_node_t *) node;
    gvvn->offset = p - base;

    vv = (ngx_http_variable_value_t *) p;
    *vv = *gvvn->value;
    p += sizeof(ngx_http_variable_value_t);
    vv->data = (u_char *) (p - base);

    p = ngx_cpymem(p, gvvn->sn.str.data, gvvn->sn.str.len);

    p = ngx_align_ptr(p, sizeof(void *));

    p = ngx_http_geo_copy_values(base, p, node->left, sentinel);

    return ngx_http_geo_copy_values(base, p, node->right, sentinel);
}",1,1,http\modules\ngx_http_geo_module.c,ngx_http_geo_copy_values,,false,1655,1681,ngx_http_geo_copy_values,,,56,"u_char ngx_http_geo_copy_values (u_char*,u_char*,ngx_rbtree_node_t*,ngx_rbtree_node_t*)"
130499,METHOD,http\modules\ngx_http_geoip_module.c:<global>,TYPE_DECL,<global>,1,6,http\modules\ngx_http_geoip_module.c,http\modules\ngx_http_geoip_module.c:<global>,,false,1,925,<global>,,,1,
130515,METHOD,http\modules\ngx_http_geoip_module.c:<global>,TYPE_DECL,"typedef const char *(*ngx_http_geoip_variable_handler_pt)(GeoIP *,
    u_long addr);",20,16,http\modules\ngx_http_geoip_module.c,ngx_http_geoip_variable_handler_pt,,false,41,42,ngx_http_geoip_variable_handler_pt,,,5,"char* ngx_http_geoip_variable_handler_pt (GeoIP*,u_long)"
130528,METHOD,http\modules\ngx_http_geoip_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_geoip_country_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\modules\ngx_http_geoip_module.c,ngx_http_geoip_country_variable,,false,67,68,ngx_http_geoip_country_variable,,,8,"ngx_int_t ngx_http_geoip_country_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
130535,METHOD,http\modules\ngx_http_geoip_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_geoip_org_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\modules\ngx_http_geoip_module.c,ngx_http_geoip_org_variable,,false,69,70,ngx_http_geoip_org_variable,,,9,"ngx_int_t ngx_http_geoip_org_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
130542,METHOD,http\modules\ngx_http_geoip_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_geoip_city_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\modules\ngx_http_geoip_module.c,ngx_http_geoip_city_variable,,false,71,72,ngx_http_geoip_city_variable,,,10,"ngx_int_t ngx_http_geoip_city_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
130549,METHOD,http\modules\ngx_http_geoip_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_geoip_region_name_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\modules\ngx_http_geoip_module.c,ngx_http_geoip_region_name_variable,,false,73,74,ngx_http_geoip_region_name_variable,,,11,"ngx_int_t ngx_http_geoip_region_name_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
130556,METHOD,http\modules\ngx_http_geoip_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_geoip_city_float_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\modules\ngx_http_geoip_module.c,ngx_http_geoip_city_float_variable,,false,75,76,ngx_http_geoip_city_float_variable,,,12,"ngx_int_t ngx_http_geoip_city_float_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
130563,METHOD,http\modules\ngx_http_geoip_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_geoip_city_int_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\modules\ngx_http_geoip_module.c,ngx_http_geoip_city_int_variable,,false,77,78,ngx_http_geoip_city_int_variable,,,13,"ngx_int_t ngx_http_geoip_city_int_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
130570,METHOD,http\modules\ngx_http_geoip_module.c:<global>,TYPE_DECL,static GeoIPRecord *ngx_http_geoip_get_city_record(ngx_http_request_t *r);,20,73,http\modules\ngx_http_geoip_module.c,ngx_http_geoip_get_city_record,,false,79,79,ngx_http_geoip_get_city_record,,,14,GeoIPRecord* ngx_http_geoip_get_city_record (ngx_http_request_t*)
130575,METHOD,http\modules\ngx_http_geoip_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_geoip_add_variables(ngx_conf_t *cf);,18,61,http\modules\ngx_http_geoip_module.c,ngx_http_geoip_add_variables,,false,81,81,ngx_http_geoip_add_variables,,,15,ngx_int_t ngx_http_geoip_add_variables (ngx_conf_t*)
130580,METHOD,http\modules\ngx_http_geoip_module.c:<global>,TYPE_DECL,static void *ngx_http_geoip_create_conf(ngx_conf_t *cf);,13,55,http\modules\ngx_http_geoip_module.c,ngx_http_geoip_create_conf,,false,82,82,ngx_http_geoip_create_conf,,,16,void* ngx_http_geoip_create_conf (ngx_conf_t*)
130585,METHOD,http\modules\ngx_http_geoip_module.c:<global>,TYPE_DECL,"static char *ngx_http_geoip_init_conf(ngx_conf_t *cf, void *conf);",13,65,http\modules\ngx_http_geoip_module.c,ngx_http_geoip_init_conf,,false,83,83,ngx_http_geoip_init_conf,,,17,"char* ngx_http_geoip_init_conf (ngx_conf_t*,void*)"
130591,METHOD,http\modules\ngx_http_geoip_module.c:<global>,TYPE_DECL,"static char *ngx_http_geoip_country(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_geoip_module.c,ngx_http_geoip_country,,false,84,85,ngx_http_geoip_country,,,18,"char* ngx_http_geoip_country (ngx_conf_t*,ngx_command_t*,void*)"
130598,METHOD,http\modules\ngx_http_geoip_module.c:<global>,TYPE_DECL,"static char *ngx_http_geoip_org(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_geoip_module.c,ngx_http_geoip_org,,false,86,87,ngx_http_geoip_org,,,19,"char* ngx_http_geoip_org (ngx_conf_t*,ngx_command_t*,void*)"
130605,METHOD,http\modules\ngx_http_geoip_module.c:<global>,TYPE_DECL,"static char *ngx_http_geoip_city(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_geoip_module.c,ngx_http_geoip_city,,false,88,89,ngx_http_geoip_city,,,20,"char* ngx_http_geoip_city (ngx_conf_t*,ngx_command_t*,void*)"
130612,METHOD,http\modules\ngx_http_geoip_module.c:<global>,TYPE_DECL,"static char *ngx_http_geoip_proxy(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_geoip_module.c,ngx_http_geoip_proxy,,false,90,91,ngx_http_geoip_proxy,,,21,"char* ngx_http_geoip_proxy (ngx_conf_t*,ngx_command_t*,void*)"
130619,METHOD,http\modules\ngx_http_geoip_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_geoip_cidr_value(ngx_conf_t *cf, ngx_str_t *net,
    ngx_cidr_t *cidr);",18,21,http\modules\ngx_http_geoip_module.c,ngx_http_geoip_cidr_value,,false,92,93,ngx_http_geoip_cidr_value,,,22,"ngx_int_t ngx_http_geoip_cidr_value (ngx_conf_t*,ngx_str_t*,ngx_cidr_t*)"
130626,METHOD,http\modules\ngx_http_geoip_module.c:<global>,TYPE_DECL,static void ngx_http_geoip_cleanup(void *data);,13,46,http\modules\ngx_http_geoip_module.c,ngx_http_geoip_cleanup,,false,94,94,ngx_http_geoip_cleanup,,,23,void ngx_http_geoip_cleanup (void*)
130878,METHOD,http\modules\ngx_http_geoip_module.c:<global>,TYPE_DECL,"static u_long
ngx_http_geoip_addr(ngx_http_request_t *r, ngx_http_geoip_conf_t *gcf)
{
    ngx_addr_t           addr;
    ngx_array_t         *xfwd;
    struct sockaddr_in  *sin;

    addr.sockaddr = r->connection->sockaddr;
    addr.socklen = r->connection->socklen;
    /* addr.name = r->connection->addr_text; */

    xfwd = &r->headers_in.x_forwarded_for;

    if (xfwd->nelts > 0 && gcf->proxies != NULL) {
        (void) ngx_http_get_forwarded_addr(r, &addr, xfwd, NULL,
                                           gcf->proxies, gcf->proxy_recursive);
    }

#if (NGX_HAVE_INET6)

    if (addr.sockaddr->sa_family == AF_INET6) {
        u_char           *p;
        in_addr_t         inaddr;
        struct in6_addr  *inaddr6;

        inaddr6 = &((struct sockaddr_in6 *) addr.sockaddr)->sin6_addr;

        if (IN6_IS_ADDR_V4MAPPED(inaddr6)) {
            p = inaddr6->s6_addr;

            inaddr = p[12] << 24;
            inaddr += p[13] << 16;
            inaddr += p[14] << 8;
         ...",1,1,http\modules\ngx_http_geoip_module.c,ngx_http_geoip_addr,,false,239,286,ngx_http_geoip_addr,,,32,"u_long ngx_http_geoip_addr (ngx_http_request_t*,ngx_http_geoip_conf_t*)"
130965,METHOD,http\modules\ngx_http_geoip_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_geoip_country_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    ngx_http_geoip_variable_handler_pt     handler =
        ngx_http_geoip_country_functions[data];
#if (NGX_HAVE_GEOIP_V6)
    ngx_http_geoip_variable_handler_v6_pt  handler_v6 =
        ngx_http_geoip_country_v6_functions[data];
#endif

    const char             *val;
    ngx_http_geoip_conf_t  *gcf;

    gcf = ngx_http_get_module_main_conf(r, ngx_http_geoip_module);

    if (gcf->country == NULL) {
        goto not_found;
    }

#if (NGX_HAVE_GEOIP_V6)
    val = gcf->country_v6
              ? handler_v6(gcf->country, ngx_http_geoip_addr_v6(r, gcf))
              : handler(gcf->country, ngx_http_geoip_addr(r, gcf));
#else
    val = handler(gcf->country, ngx_http_geoip_addr(r, gcf));
#endif

    if (val == NULL) {
        goto not_found;
    }

    v->len = ngx_strlen(val);
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = (u_ch...",1,1,http\modules\ngx_http_geoip_module.c,ngx_http_geoip_country_variable,,false,340,385,ngx_http_geoip_country_variable,,,33,"ngx_int_t ngx_http_geoip_country_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
131046,METHOD,http\modules\ngx_http_geoip_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_geoip_org_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    size_t                  len;
    char                   *val;
    ngx_http_geoip_conf_t  *gcf;

    gcf = ngx_http_get_module_main_conf(r, ngx_http_geoip_module);

    if (gcf->org == NULL) {
        goto not_found;
    }

#if (NGX_HAVE_GEOIP_V6)
    val = gcf->org_v6
              ? GeoIP_name_by_ipnum_v6(gcf->org,
                                       ngx_http_geoip_addr_v6(r, gcf))
              : GeoIP_name_by_ipnum(gcf->org,
                                    ngx_http_geoip_addr(r, gcf));
#else
    val = GeoIP_name_by_ipnum(gcf->org, ngx_http_geoip_addr(r, gcf));
#endif

    if (val == NULL) {
        goto not_found;
    }

    len = ngx_strlen(val);
    v->data = ngx_pnalloc(r->pool, len);
    if (v->data == NULL) {
        ngx_free(val);
        return NGX_ERROR;
    }

    ngx_memcpy(v->data, val, len);

    v->len = len;
    v->valid = 1;
    v->no_c...",1,1,http\modules\ngx_http_geoip_module.c,ngx_http_geoip_org_variable,,false,388,439,ngx_http_geoip_org_variable,,,34,"ngx_int_t ngx_http_geoip_org_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
131146,METHOD,http\modules\ngx_http_geoip_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_geoip_city_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    char         *val;
    size_t        len;
    GeoIPRecord  *gr;

    gr = ngx_http_geoip_get_city_record(r);
    if (gr == NULL) {
        goto not_found;
    }

    val = *(char **) ((char *) gr + data);
    if (val == NULL) {
        goto no_value;
    }

    len = ngx_strlen(val);
    v->data = ngx_pnalloc(r->pool, len);
    if (v->data == NULL) {
        GeoIPRecord_delete(gr);
        return NGX_ERROR;
    }

    ngx_memcpy(v->data, val, len);

    v->len = len;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;

    GeoIPRecord_delete(gr);

    return NGX_OK;

no_value:

    GeoIPRecord_delete(gr);

not_found:

    v->not_found = 1;

    return NGX_OK;
}",1,1,http\modules\ngx_http_geoip_module.c,ngx_http_geoip_city_variable,,false,442,487,ngx_http_geoip_city_variable,,,35,"ngx_int_t ngx_http_geoip_city_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
131247,METHOD,http\modules\ngx_http_geoip_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_geoip_region_name_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    size_t        len;
    const char   *val;
    GeoIPRecord  *gr;

    gr = ngx_http_geoip_get_city_record(r);
    if (gr == NULL) {
        goto not_found;
    }

    val = GeoIP_region_name_by_code(gr->country_code, gr->region);

    GeoIPRecord_delete(gr);

    if (val == NULL) {
        goto not_found;
    }

    len = ngx_strlen(val);
    v->data = ngx_pnalloc(r->pool, len);
    if (v->data == NULL) {
        return NGX_ERROR;
    }

    ngx_memcpy(v->data, val, len);

    v->len = len;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;

    return NGX_OK;

not_found:

    v->not_found = 1;

    return NGX_OK;
}",1,1,http\modules\ngx_http_geoip_module.c,ngx_http_geoip_region_name_variable,,false,490,531,ngx_http_geoip_region_name_variable,,,36,"ngx_int_t ngx_http_geoip_region_name_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
131342,METHOD,http\modules\ngx_http_geoip_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_geoip_city_float_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    float         val;
    GeoIPRecord  *gr;

    gr = ngx_http_geoip_get_city_record(r);
    if (gr == NULL) {
        v->not_found = 1;
        return NGX_OK;
    }

    v->data = ngx_pnalloc(r->pool, NGX_INT64_LEN + 5);
    if (v->data == NULL) {
        GeoIPRecord_delete(gr);
        return NGX_ERROR;
    }

    val = *(float *) ((char *) gr + data);

    v->len = ngx_sprintf(v->data, ""%.4f"", val) - v->data;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;

    GeoIPRecord_delete(gr);

    return NGX_OK;
}",1,1,http\modules\ngx_http_geoip_module.c,ngx_http_geoip_city_float_variable,,false,534,563,ngx_http_geoip_city_float_variable,,,37,"ngx_int_t ngx_http_geoip_city_float_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
131432,METHOD,http\modules\ngx_http_geoip_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_geoip_city_int_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    int           val;
    GeoIPRecord  *gr;

    gr = ngx_http_geoip_get_city_record(r);
    if (gr == NULL) {
        v->not_found = 1;
        return NGX_OK;
    }

    v->data = ngx_pnalloc(r->pool, NGX_INT64_LEN);
    if (v->data == NULL) {
        GeoIPRecord_delete(gr);
        return NGX_ERROR;
    }

    val = *(int *) ((char *) gr + data);

    v->len = ngx_sprintf(v->data, ""%d"", val) - v->data;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;

    GeoIPRecord_delete(gr);

    return NGX_OK;
}",1,1,http\modules\ngx_http_geoip_module.c,ngx_http_geoip_city_int_variable,,false,566,595,ngx_http_geoip_city_int_variable,,,38,"ngx_int_t ngx_http_geoip_city_int_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
131520,METHOD,http\modules\ngx_http_geoip_module.c:<global>,TYPE_DECL,"static GeoIPRecord *
ngx_http_geoip_get_city_record(ngx_http_request_t *r)
{
    ngx_http_geoip_conf_t  *gcf;

    gcf = ngx_http_get_module_main_conf(r, ngx_http_geoip_module);

    if (gcf->city) {
#if (NGX_HAVE_GEOIP_V6)
        return gcf->city_v6
                   ? GeoIP_record_by_ipnum_v6(gcf->city,
                                              ngx_http_geoip_addr_v6(r, gcf))
                   : GeoIP_record_by_ipnum(gcf->city,
                                           ngx_http_geoip_addr(r, gcf));
#else
        return GeoIP_record_by_ipnum(gcf->city, ngx_http_geoip_addr(r, gcf));
#endif
    }

    return NULL;
}",1,1,http\modules\ngx_http_geoip_module.c,ngx_http_geoip_get_city_record,,false,598,618,ngx_http_geoip_get_city_record,,,39,GeoIPRecord ngx_http_geoip_get_city_record (ngx_http_request_t*)
131546,METHOD,http\modules\ngx_http_geoip_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_geoip_add_variables(ngx_conf_t *cf)
{
    ngx_http_variable_t  *var, *v;

    for (v = ngx_http_geoip_vars; v->name.len; v++) {
        var = ngx_http_add_variable(cf, &v->name, v->flags);
        if (var == NULL) {
            return NGX_ERROR;
        }

        var->get_handler = v->get_handler;
        var->data = v->data;
    }

    return NGX_OK;
}",1,1,http\modules\ngx_http_geoip_module.c,ngx_http_geoip_add_variables,,false,621,637,ngx_http_geoip_add_variables,,,40,ngx_int_t ngx_http_geoip_add_variables (ngx_conf_t*)
131600,METHOD,http\modules\ngx_http_geoip_module.c:<global>,TYPE_DECL,"static void *
ngx_http_geoip_create_conf(ngx_conf_t *cf)
{
    ngx_pool_cleanup_t     *cln;
    ngx_http_geoip_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_geoip_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    conf->proxy_recursive = NGX_CONF_UNSET;

    cln = ngx_pool_cleanup_add(cf->pool, 0);
    if (cln == NULL) {
        return NULL;
    }

    cln->handler = ngx_http_geoip_cleanup;
    cln->data = conf;

    return conf;
}",1,1,http\modules\ngx_http_geoip_module.c,ngx_http_geoip_create_conf,,false,640,662,ngx_http_geoip_create_conf,,,41,void* ngx_http_geoip_create_conf (ngx_conf_t*)
131653,METHOD,http\modules\ngx_http_geoip_module.c:<global>,TYPE_DECL,"static char *
ngx_http_geoip_init_conf(ngx_conf_t *cf, void *conf)
{
    ngx_http_geoip_conf_t  *gcf = conf;

    ngx_conf_init_value(gcf->proxy_recursive, 0);

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_geoip_module.c,ngx_http_geoip_init_conf,,false,665,673,ngx_http_geoip_init_conf,,,42,"char* ngx_http_geoip_init_conf (ngx_conf_t*,void*)"
131670,METHOD,http\modules\ngx_http_geoip_module.c:<global>,TYPE_DECL,"static char *
ngx_http_geoip_country(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_geoip_conf_t  *gcf = conf;

    ngx_str_t  *value;

    if (gcf->country) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    gcf->country = GeoIP_open((char *) value[1].data, GEOIP_MEMORY_CACHE);

    if (gcf->country == NULL) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""GeoIP_open(\""%V\"") failed"", &value[1]);

        return NGX_CONF_ERROR;
    }

    if (cf->args->nelts == 3) {
        if (ngx_strcmp(value[2].data, ""utf8"") == 0) {
            GeoIP_set_charset(gcf->country, GEOIP_CHARSET_UTF8);

        } else {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               ""invalid parameter \""%V\"""", &value[2]);
            return NGX_CONF_ERROR;
        }
    }

    switch (gcf->country->databaseType) {

    case GEOIP_COUNTRY_EDITION:

        return NGX_CONF_OK;

#if (NGX_HAVE_GEOIP_V6)
    case GEOIP_C...",1,1,http\modules\ngx_http_geoip_module.c,ngx_http_geoip_country,,false,676,728,ngx_http_geoip_country,,,43,"char* ngx_http_geoip_country (ngx_conf_t*,ngx_command_t*,void*)"
131793,METHOD,http\modules\ngx_http_geoip_module.c:<global>,TYPE_DECL,"static char *
ngx_http_geoip_org(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_geoip_conf_t  *gcf = conf;

    ngx_str_t  *value;

    if (gcf->org) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    gcf->org = GeoIP_open((char *) value[1].data, GEOIP_MEMORY_CACHE);

    if (gcf->org == NULL) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""GeoIP_open(\""%V\"") failed"", &value[1]);

        return NGX_CONF_ERROR;
    }

    if (cf->args->nelts == 3) {
        if (ngx_strcmp(value[2].data, ""utf8"") == 0) {
            GeoIP_set_charset(gcf->org, GEOIP_CHARSET_UTF8);

        } else {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               ""invalid parameter \""%V\"""", &value[2]);
            return NGX_CONF_ERROR;
        }
    }

    switch (gcf->org->databaseType) {

    case GEOIP_ISP_EDITION:
    case GEOIP_ORG_EDITION:
    case GEOIP_DOMAIN_EDITION:
    case GEOIP_ASNUM_EDITION:

        ...",1,1,http\modules\ngx_http_geoip_module.c,ngx_http_geoip_org,,false,731,789,ngx_http_geoip_org,,,44,"char* ngx_http_geoip_org (ngx_conf_t*,ngx_command_t*,void*)"
131922,METHOD,http\modules\ngx_http_geoip_module.c:<global>,TYPE_DECL,"static char *
ngx_http_geoip_city(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_geoip_conf_t  *gcf = conf;

    ngx_str_t  *value;

    if (gcf->city) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    gcf->city = GeoIP_open((char *) value[1].data, GEOIP_MEMORY_CACHE);

    if (gcf->city == NULL) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""GeoIP_open(\""%V\"") failed"", &value[1]);

        return NGX_CONF_ERROR;
    }

    if (cf->args->nelts == 3) {
        if (ngx_strcmp(value[2].data, ""utf8"") == 0) {
            GeoIP_set_charset(gcf->city, GEOIP_CHARSET_UTF8);

        } else {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               ""invalid parameter \""%V\"""", &value[2]);
            return NGX_CONF_ERROR;
        }
    }

    switch (gcf->city->databaseType) {

    case GEOIP_CITY_EDITION_REV0:
    case GEOIP_CITY_EDITION_REV1:

        return NGX_CONF_OK;

#if (NGX_HAVE_GEOIP_V6...",1,1,http\modules\ngx_http_geoip_module.c,ngx_http_geoip_city,,false,792,846,ngx_http_geoip_city,,,45,"char* ngx_http_geoip_city (ngx_conf_t*,ngx_command_t*,void*)"
132047,METHOD,http\modules\ngx_http_geoip_module.c:<global>,TYPE_DECL,"static char *
ngx_http_geoip_proxy(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_geoip_conf_t  *gcf = conf;

    ngx_str_t   *value;
    ngx_cidr_t  cidr, *c;

    value = cf->args->elts;

    if (ngx_http_geoip_cidr_value(cf, &value[1], &cidr) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    if (gcf->proxies == NULL) {
        gcf->proxies = ngx_array_create(cf->pool, 4, sizeof(ngx_cidr_t));
        if (gcf->proxies == NULL) {
            return NGX_CONF_ERROR;
        }
    }

    c = ngx_array_push(gcf->proxies);
    if (c == NULL) {
        return NGX_CONF_ERROR;
    }

    *c = cidr;

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_geoip_module.c,ngx_http_geoip_proxy,,false,849,878,ngx_http_geoip_proxy,,,46,"char* ngx_http_geoip_proxy (ngx_conf_t*,ngx_command_t*,void*)"
132128,METHOD,http\modules\ngx_http_geoip_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_geoip_cidr_value(ngx_conf_t *cf, ngx_str_t *net, ngx_cidr_t *cidr)
{
    ngx_int_t  rc;

    if (ngx_strcmp(net->data, ""255.255.255.255"") == 0) {
        cidr->family = AF_INET;
        cidr->u.in.addr = 0xffffffff;
        cidr->u.in.mask = 0xffffffff;

        return NGX_OK;
    }

    rc = ngx_ptocidr(net, cidr);

    if (rc == NGX_ERROR) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, ""invalid network \""%V\"""", net);
        return NGX_ERROR;
    }

    if (rc == NGX_DONE) {
        ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
                           ""low address bits of %V are meaningless"", net);
    }

    return NGX_OK;
}",1,1,http\modules\ngx_http_geoip_module.c,ngx_http_geoip_cidr_value,,false,880,906,ngx_http_geoip_cidr_value,,,47,"ngx_int_t ngx_http_geoip_cidr_value (ngx_conf_t*,ngx_str_t*,ngx_cidr_t*)"
132201,METHOD,http\modules\ngx_http_geoip_module.c:<global>,TYPE_DECL,"static void
ngx_http_geoip_cleanup(void *data)
{
    ngx_http_geoip_conf_t  *gcf = data;

    if (gcf->country) {
        GeoIP_delete(gcf->country);
    }

    if (gcf->org) {
        GeoIP_delete(gcf->org);
    }

    if (gcf->city) {
        GeoIP_delete(gcf->city);
    }
}",1,1,http\modules\ngx_http_geoip_module.c,ngx_http_geoip_cleanup,,false,909,925,ngx_http_geoip_cleanup,,,48,void ngx_http_geoip_cleanup (void*)
132246,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,<global>,1,6,http\modules\ngx_http_grpc_module.c,http\modules\ngx_http_grpc_module.c:<global>,,false,1,4893,<global>,,,1,
132284,METHOD,<empty>,<empty>,<empty>,1,,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_state_e:<clinit>,,false,47,,<clinit>,,,12,
132341,METHOD,<empty>,<empty>,<empty>,1,,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_ctx_t:<clinit>,,false,70,,<clinit>,,,43,
132359,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_grpc_eval(ngx_http_request_t *r,
    ngx_http_grpc_ctx_t *ctx, ngx_http_grpc_loc_conf_t *glcf);",18,61,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_eval,,false,144,145,ngx_http_grpc_eval,,,13,"ngx_int_t ngx_http_grpc_eval (ngx_http_request_t*,ngx_http_grpc_ctx_t*,ngx_http_grpc_loc_conf_t*)"
132366,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_grpc_create_request(ngx_http_request_t *r);,18,68,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_create_request,,false,146,146,ngx_http_grpc_create_request,,,14,ngx_int_t ngx_http_grpc_create_request (ngx_http_request_t*)
132371,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_grpc_reinit_request(ngx_http_request_t *r);,18,68,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_reinit_request,,false,147,147,ngx_http_grpc_reinit_request,,,15,ngx_int_t ngx_http_grpc_reinit_request (ngx_http_request_t*)
132376,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_grpc_body_output_filter(void *data, ngx_chain_t *in);",18,78,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_body_output_filter,,false,148,148,ngx_http_grpc_body_output_filter,,,16,"ngx_int_t ngx_http_grpc_body_output_filter (void*,ngx_chain_t*)"
132382,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_grpc_process_header(ngx_http_request_t *r);,18,68,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_process_header,,false,149,149,ngx_http_grpc_process_header,,,17,ngx_int_t ngx_http_grpc_process_header (ngx_http_request_t*)
132387,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_grpc_filter_init(void *data);,18,54,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_filter_init,,false,150,150,ngx_http_grpc_filter_init,,,18,ngx_int_t ngx_http_grpc_filter_init (void*)
132392,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_grpc_filter(void *data, ssize_t bytes);",18,64,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_filter,,false,151,151,ngx_http_grpc_filter,,,19,"ngx_int_t ngx_http_grpc_filter (void*,ssize_t)"
132398,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_grpc_parse_frame(ngx_http_request_t *r,
    ngx_http_grpc_ctx_t *ctx, ngx_buf_t *b);",18,43,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_parse_frame,,false,153,154,ngx_http_grpc_parse_frame,,,20,"ngx_int_t ngx_http_grpc_parse_frame (ngx_http_request_t*,ngx_http_grpc_ctx_t*,ngx_buf_t*)"
132405,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_grpc_parse_header(ngx_http_request_t *r,
    ngx_http_grpc_ctx_t *ctx, ngx_buf_t *b);",18,43,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_parse_header,,false,155,156,ngx_http_grpc_parse_header,,,21,"ngx_int_t ngx_http_grpc_parse_header (ngx_http_request_t*,ngx_http_grpc_ctx_t*,ngx_buf_t*)"
132412,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_grpc_parse_fragment(ngx_http_request_t *r,
    ngx_http_grpc_ctx_t *ctx, ngx_buf_t *b);",18,43,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_parse_fragment,,false,157,158,ngx_http_grpc_parse_fragment,,,22,"ngx_int_t ngx_http_grpc_parse_fragment (ngx_http_request_t*,ngx_http_grpc_ctx_t*,ngx_buf_t*)"
132419,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_grpc_validate_header_name(ngx_http_request_t *r,
    ngx_str_t *s);",18,17,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_validate_header_name,,false,159,160,ngx_http_grpc_validate_header_name,,,23,"ngx_int_t ngx_http_grpc_validate_header_name (ngx_http_request_t*,ngx_str_t*)"
132425,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_grpc_validate_header_value(ngx_http_request_t *r,
    ngx_str_t *s);",18,17,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_validate_header_value,,false,161,162,ngx_http_grpc_validate_header_value,,,24,"ngx_int_t ngx_http_grpc_validate_header_value (ngx_http_request_t*,ngx_str_t*)"
132431,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_grpc_parse_rst_stream(ngx_http_request_t *r,
    ngx_http_grpc_ctx_t *ctx, ngx_buf_t *b);",18,43,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_parse_rst_stream,,false,163,164,ngx_http_grpc_parse_rst_stream,,,25,"ngx_int_t ngx_http_grpc_parse_rst_stream (ngx_http_request_t*,ngx_http_grpc_ctx_t*,ngx_buf_t*)"
132438,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_grpc_parse_goaway(ngx_http_request_t *r,
    ngx_http_grpc_ctx_t *ctx, ngx_buf_t *b);",18,43,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_parse_goaway,,false,165,166,ngx_http_grpc_parse_goaway,,,26,"ngx_int_t ngx_http_grpc_parse_goaway (ngx_http_request_t*,ngx_http_grpc_ctx_t*,ngx_buf_t*)"
132445,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_grpc_parse_window_update(ngx_http_request_t *r,
    ngx_http_grpc_ctx_t *ctx, ngx_buf_t *b);",18,43,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_parse_window_update,,false,167,168,ngx_http_grpc_parse_window_update,,,27,"ngx_int_t ngx_http_grpc_parse_window_update (ngx_http_request_t*,ngx_http_grpc_ctx_t*,ngx_buf_t*)"
132452,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_grpc_parse_settings(ngx_http_request_t *r,
    ngx_http_grpc_ctx_t *ctx, ngx_buf_t *b);",18,43,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_parse_settings,,false,169,170,ngx_http_grpc_parse_settings,,,28,"ngx_int_t ngx_http_grpc_parse_settings (ngx_http_request_t*,ngx_http_grpc_ctx_t*,ngx_buf_t*)"
132459,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_grpc_parse_ping(ngx_http_request_t *r,
    ngx_http_grpc_ctx_t *ctx, ngx_buf_t *b);",18,43,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_parse_ping,,false,171,172,ngx_http_grpc_parse_ping,,,29,"ngx_int_t ngx_http_grpc_parse_ping (ngx_http_request_t*,ngx_http_grpc_ctx_t*,ngx_buf_t*)"
132466,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_grpc_send_settings_ack(ngx_http_request_t *r,
    ngx_http_grpc_ctx_t *ctx);",18,29,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_send_settings_ack,,false,174,175,ngx_http_grpc_send_settings_ack,,,30,"ngx_int_t ngx_http_grpc_send_settings_ack (ngx_http_request_t*,ngx_http_grpc_ctx_t*)"
132472,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_grpc_send_ping_ack(ngx_http_request_t *r,
    ngx_http_grpc_ctx_t *ctx);",18,29,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_send_ping_ack,,false,176,177,ngx_http_grpc_send_ping_ack,,,31,"ngx_int_t ngx_http_grpc_send_ping_ack (ngx_http_request_t*,ngx_http_grpc_ctx_t*)"
132478,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_grpc_send_window_update(ngx_http_request_t *r,
    ngx_http_grpc_ctx_t *ctx);",18,29,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_send_window_update,,false,178,179,ngx_http_grpc_send_window_update,,,32,"ngx_int_t ngx_http_grpc_send_window_update (ngx_http_request_t*,ngx_http_grpc_ctx_t*)"
132484,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_chain_t *ngx_http_grpc_get_buf(ngx_http_request_t *r,
    ngx_http_grpc_ctx_t *ctx);",20,29,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_get_buf,,false,181,182,ngx_http_grpc_get_buf,,,33,"ngx_chain_t* ngx_http_grpc_get_buf (ngx_http_request_t*,ngx_http_grpc_ctx_t*)"
132490,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,static ngx_http_grpc_ctx_t *ngx_http_grpc_get_ctx(ngx_http_request_t *r);,28,72,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_get_ctx,,false,183,183,ngx_http_grpc_get_ctx,,,34,ngx_http_grpc_ctx_t* ngx_http_grpc_get_ctx (ngx_http_request_t*)
132495,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_grpc_get_connection_data(ngx_http_request_t *r,
    ngx_http_grpc_ctx_t *ctx, ngx_peer_connection_t *pc);",18,56,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_get_connection_data,,false,184,185,ngx_http_grpc_get_connection_data,,,35,"ngx_int_t ngx_http_grpc_get_connection_data (ngx_http_request_t*,ngx_http_grpc_ctx_t*,ngx_peer_connection_t*)"
132502,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,static void ngx_http_grpc_cleanup(void *data);,13,45,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_cleanup,,false,186,186,ngx_http_grpc_cleanup,,,36,void ngx_http_grpc_cleanup (void*)
132507,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,static void ngx_http_grpc_abort_request(ngx_http_request_t *r);,13,62,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_abort_request,,false,188,188,ngx_http_grpc_abort_request,,,37,void ngx_http_grpc_abort_request (ngx_http_request_t*)
132512,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static void ngx_http_grpc_finalize_request(ngx_http_request_t *r,
    ngx_int_t rc);",13,17,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_finalize_request,,false,189,190,ngx_http_grpc_finalize_request,,,38,"void ngx_http_grpc_finalize_request (ngx_http_request_t*,ngx_int_t)"
132518,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_grpc_internal_trailers_variable(
    ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data);",18,72,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_internal_trailers_variable,,false,192,193,ngx_http_grpc_internal_trailers_variable,,,39,"ngx_int_t ngx_http_grpc_internal_trailers_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
132525,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_grpc_add_variables(ngx_conf_t *cf);,18,60,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_add_variables,,false,195,195,ngx_http_grpc_add_variables,,,40,ngx_int_t ngx_http_grpc_add_variables (ngx_conf_t*)
132530,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,static void *ngx_http_grpc_create_loc_conf(ngx_conf_t *cf);,13,58,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_create_loc_conf,,false,196,196,ngx_http_grpc_create_loc_conf,,,41,void* ngx_http_grpc_create_loc_conf (ngx_conf_t*)
132535,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static char *ngx_http_grpc_merge_loc_conf(ngx_conf_t *cf,
    void *parent, void *child);",13,30,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_merge_loc_conf,,false,197,198,ngx_http_grpc_merge_loc_conf,,,42,"char* ngx_http_grpc_merge_loc_conf (ngx_conf_t*,void*,void*)"
132542,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_grpc_init_headers(ngx_conf_t *cf,
    ngx_http_grpc_loc_conf_t *conf, ngx_http_grpc_headers_t *headers,
    ngx_keyval_t *default_headers);",18,34,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_init_headers,,false,199,201,ngx_http_grpc_init_headers,,,43,"ngx_int_t ngx_http_grpc_init_headers (ngx_conf_t*,ngx_http_grpc_loc_conf_t*,ngx_http_grpc_headers_t*,ngx_keyval_t*)"
132550,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static char *ngx_http_grpc_pass(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_pass,,false,203,204,ngx_http_grpc_pass,,,44,"char* ngx_http_grpc_pass (ngx_conf_t*,ngx_command_t*,void*)"
132995,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_grpc_handler(ngx_http_request_t *r)
{
    ngx_int_t                  rc;
    ngx_http_upstream_t       *u;
    ngx_http_grpc_ctx_t       *ctx;
    ngx_http_grpc_loc_conf_t  *glcf;

    if (ngx_http_upstream_create(r) != NGX_OK) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_grpc_ctx_t));
    if (ctx == NULL) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    ctx->request = r;

    ngx_http_set_ctx(r, ctx, ngx_http_grpc_module);

    glcf = ngx_http_get_module_loc_conf(r, ngx_http_grpc_module);

    u = r->upstream;

    if (glcf->grpc_lengths == NULL) {
        ctx->host = glcf->host;

#if (NGX_HTTP_SSL)
        u->ssl = (glcf->upstream.ssl != NULL);

        if (u->ssl) {
            ngx_str_set(&u->schema, ""grpcs://"");

        } else {
            ngx_str_set(&u->schema, ""grpc://"");
        }
#else
        ngx_str_set(&u->schema, ""grpc://"");
#endif

    } else {
        if (ngx_http_grpc_ev...",1,1,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_handler,,false,523,593,ngx_http_grpc_handler,,,61,ngx_int_t ngx_http_grpc_handler (ngx_http_request_t*)
133154,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_grpc_eval(ngx_http_request_t *r, ngx_http_grpc_ctx_t *ctx,
    ngx_http_grpc_loc_conf_t *glcf)
{
    size_t                add;
    ngx_url_t             url;
    ngx_http_upstream_t  *u;

    ngx_memzero(&url, sizeof(ngx_url_t));

    if (ngx_http_script_run(r, &url.url, glcf->grpc_lengths->elts, 0,
                            glcf->grpc_values->elts)
        == NULL)
    {
        return NGX_ERROR;
    }

    if (url.url.len > 7
        && ngx_strncasecmp(url.url.data, (u_char *) ""grpc://"", 7) == 0)
    {
        add = 7;

    } else if (url.url.len > 8
               && ngx_strncasecmp(url.url.data, (u_char *) ""grpcs://"", 8) == 0)
    {

#if (NGX_HTTP_SSL)
        add = 8;
        r->upstream->ssl = 1;
#else
        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                      ""grpcs protocol requires SSL support"");
        return NGX_ERROR;
#endif

    } else {
        add = 0;
    }

    u = r->upstream;

    if (add) {
        u->schema.len ...",1,1,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_eval,,false,596,690,ngx_http_grpc_eval,,,62,"ngx_int_t ngx_http_grpc_eval (ngx_http_request_t*,ngx_http_grpc_ctx_t*,ngx_http_grpc_loc_conf_t*)"
133501,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_grpc_create_request(ngx_http_request_t *r)
{
    u_char                       *p, *tmp, *key_tmp, *val_tmp, *headers_frame;
    size_t                        len, tmp_len, key_len, val_len, uri_len;
    uintptr_t                     escape;
    ngx_buf_t                    *b;
    ngx_uint_t                    i, next;
    ngx_chain_t                  *cl, *body;
    ngx_list_part_t              *part;
    ngx_table_elt_t              *header;
    ngx_http_grpc_ctx_t          *ctx;
    ngx_http_upstream_t          *u;
    ngx_http_grpc_frame_t        *f;
    ngx_http_script_code_pt       code;
    ngx_http_grpc_loc_conf_t     *glcf;
    ngx_http_script_engine_t      e, le;
    ngx_http_script_len_code_pt   lcode;

    u = r->upstream;

    glcf = ngx_http_get_module_loc_conf(r, ngx_http_grpc_module);

    ctx = ngx_http_get_module_ctx(r, ngx_http_grpc_module);

    len = sizeof(ngx_http_grpc_connection_start) - 1
          + sizeof(ngx_http_grpc_frame_t);  ...",1,1,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_create_request,,false,693,1187,ngx_http_grpc_create_request,,,63,ngx_int_t ngx_http_grpc_create_request (ngx_http_request_t*)
135148,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_grpc_reinit_request(ngx_http_request_t *r)
{
    ngx_http_grpc_ctx_t  *ctx;

    ctx = ngx_http_get_module_ctx(r, ngx_http_grpc_module);

    if (ctx == NULL) {
        return NGX_OK;
    }

    ctx->state = 0;
    ctx->header_sent = 0;
    ctx->output_closed = 0;
    ctx->output_blocked = 0;
    ctx->parsing_headers = 0;
    ctx->end_stream = 0;
    ctx->done = 0;
    ctx->status = 0;
    ctx->rst = 0;
    ctx->connection = NULL;

    return NGX_OK;
}",1,1,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_reinit_request,,false,1190,1213,ngx_http_grpc_reinit_request,,,64,ngx_int_t ngx_http_grpc_reinit_request (ngx_http_request_t*)
135218,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_grpc_body_output_filter(void *data, ngx_chain_t *in)
{
    ngx_http_request_t  *r = data;

    off_t                   file_pos;
    u_char                 *p, *pos, *start;
    size_t                  len, limit;
    ngx_buf_t              *b;
    ngx_int_t               rc;
    ngx_uint_t              next, last;
    ngx_chain_t            *cl, *out, **ll;
    ngx_http_upstream_t    *u;
    ngx_http_grpc_ctx_t    *ctx;
    ngx_http_grpc_frame_t  *f;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""grpc output filter"");

    ctx = ngx_http_grpc_get_ctx(r);

    if (ctx == NULL) {
        return NGX_ERROR;
    }

    if (in) {
        if (ngx_chain_add_copy(r->pool, &ctx->in, in) != NGX_OK) {
            return NGX_ERROR;
        }
    }

    out = NULL;
    ll = &out;

    if (!ctx->header_sent) {
        /* first buffer contains headers */

        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                ...",1,1,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_body_output_filter,,false,1216,1574,ngx_http_grpc_body_output_filter,,,65,"ngx_int_t ngx_http_grpc_body_output_filter (void*,ngx_chain_t*)"
136324,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_grpc_process_header(ngx_http_request_t *r)
{
    ngx_str_t                      *status_line;
    ngx_int_t                       rc, status;
    ngx_buf_t                      *b;
    ngx_table_elt_t                *h;
    ngx_http_upstream_t            *u;
    ngx_http_grpc_ctx_t            *ctx;
    ngx_http_upstream_header_t     *hh;
    ngx_http_upstream_main_conf_t  *umcf;

    u = r->upstream;
    b = &u->buffer;

#if (NGX_DEBUG)
    if (r->connection->log->log_level & NGX_LOG_DEBUG_HTTP) {
        u_char  buf[512];
        size_t  n, m;

        n = ngx_min(b->last - b->pos, 256);
        m = ngx_hex_dump(buf, b->pos, n) - buf;

        ngx_log_debug4(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                       ""grpc response: %*s%s, len: %uz"",
                       m, buf, b->last - b->pos > 256 ? ""..."" : """",
                       b->last - b->pos);
    }
#endif

    ctx = ngx_http_grpc_get_ctx(r);

    if (ctx == NULL) {
        return NGX_...",1,1,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_process_header,,false,1577,1942,ngx_http_grpc_process_header,,,66,ngx_int_t ngx_http_grpc_process_header (ngx_http_request_t*)
137196,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_grpc_filter_init(void *data)
{
    ngx_http_grpc_ctx_t  *ctx = data;

    ngx_http_request_t   *r;
    ngx_http_upstream_t  *u;

    r = ctx->request;
    u = r->upstream;

    u->length = 1;

    if (ctx->end_stream) {
        u->length = 0;
    }

    return NGX_OK;
}",1,1,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_filter_init,,false,1945,1963,ngx_http_grpc_filter_init,,,67,ngx_int_t ngx_http_grpc_filter_init (void*)
137234,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_grpc_filter(void *data, ssize_t bytes)
{
    ngx_http_grpc_ctx_t  *ctx = data;

    ngx_int_t             rc;
    ngx_buf_t            *b, *buf;
    ngx_chain_t          *cl, **ll;
    ngx_table_elt_t      *h;
    ngx_http_request_t   *r;
    ngx_http_upstream_t  *u;

    r = ctx->request;
    u = r->upstream;
    b = &u->buffer;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""grpc filter bytes:%z"", bytes);

    b->pos = b->last;
    b->last += bytes;

    for (cl = u->out_bufs, ll = &u->out_bufs; cl; cl = cl->next) {
        ll = &cl->next;
    }

    for ( ;; ) {

        if (ctx->state < ngx_http_grpc_st_payload) {

            rc = ngx_http_grpc_parse_frame(r, ctx, b);

            if (rc == NGX_AGAIN) {

                if (ctx->done) {

                    /*
                     * We have finished parsing the response and the
                     * remaining control frames.  If there are unsent
                     ...",1,1,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_filter,,false,1966,2442,ngx_http_grpc_filter,,,68,"ngx_int_t ngx_http_grpc_filter (void*,ssize_t)"
138530,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_grpc_parse_frame(ngx_http_request_t *r, ngx_http_grpc_ctx_t *ctx,
    ngx_buf_t *b)
{
    u_char                 ch, *p;
    ngx_http_grpc_state_e  state;

    state = ctx->state;

    for (p = b->pos; p < b->last; p++) {
        ch = *p;

#if 0
        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                       ""grpc frame byte: %02Xd, s:%d"", ch, state);
#endif

        switch (state) {

        case ngx_http_grpc_st_start:
            ctx->rest = ch << 16;
            state = ngx_http_grpc_st_length_2;
            break;

        case ngx_http_grpc_st_length_2:
            ctx->rest |= ch << 8;
            state = ngx_http_grpc_st_length_3;
            break;

        case ngx_http_grpc_st_length_3:
            ctx->rest |= ch;

            if (ctx->rest > NGX_HTTP_V2_DEFAULT_FRAME_SIZE) {
                ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                              ""upstream sent too large http2 frame: %uz"",
       ...",1,1,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_parse_frame,,false,2445,2537,ngx_http_grpc_parse_frame,,,69,"ngx_int_t ngx_http_grpc_parse_frame (ngx_http_request_t*,ngx_http_grpc_ctx_t*,ngx_buf_t*)"
138752,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_grpc_parse_header(ngx_http_request_t *r, ngx_http_grpc_ctx_t *ctx,
    ngx_buf_t *b)
{
    u_char     ch, *p, *last;
    size_t     min;
    ngx_int_t  rc;
    enum {
        sw_start = 0,
        sw_padding_length,
        sw_dependency,
        sw_dependency_2,
        sw_dependency_3,
        sw_dependency_4,
        sw_weight,
        sw_fragment,
        sw_padding
    } state;

    state = ctx->frame_state;

    if (state == sw_start) {

        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                       ""grpc parse header: start"");

        if (ctx->type == NGX_HTTP_V2_HEADERS_FRAME) {
            ctx->parsing_headers = 1;
            ctx->fragment_state = 0;

            min = (ctx->flags & NGX_HTTP_V2_PADDED_FLAG ? 1 : 0)
                  + (ctx->flags & NGX_HTTP_V2_PRIORITY_FLAG ? 5 : 0);

            if (ctx->rest < min) {
                ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                              ""upstre...",1,1,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_parse_header,,false,2540,2756,ngx_http_grpc_parse_header,,,70,"ngx_int_t ngx_http_grpc_parse_header (ngx_http_request_t*,ngx_http_grpc_ctx_t*,ngx_buf_t*)"
139214,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_grpc_parse_fragment(ngx_http_request_t *r, ngx_http_grpc_ctx_t *ctx,
    ngx_buf_t *b)
{
    u_char      ch, *p, *last;
    size_t      size;
    ngx_uint_t  index, size_update;
    enum {
        sw_start = 0,
        sw_index,
        sw_name_length,
        sw_name_length_2,
        sw_name_length_3,
        sw_name_length_4,
        sw_name,
        sw_name_bytes,
        sw_value_length,
        sw_value_length_2,
        sw_value_length_3,
        sw_value_length_4,
        sw_value,
        sw_value_bytes
    } state;

    /* header block fragment */

#if 0
    ngx_log_debug3(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""grpc header fragment %p:%p rest:%uz"",
                   b->pos, b->last, ctx->rest);
#endif

    if (b->last - b->pos < (ssize_t) ctx->rest - ctx->padding) {
        last = b->last;

    } else {
        last = b->pos + ctx->rest - ctx->padding;
    }

    state = ctx->fragment_state;

    for (p = b->pos; p < last;...",1,1,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_parse_fragment,,false,2759,3313,ngx_http_grpc_parse_fragment,,,71,"ngx_int_t ngx_http_grpc_parse_fragment (ngx_http_request_t*,ngx_http_grpc_ctx_t*,ngx_buf_t*)"
140547,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_grpc_validate_header_name(ngx_http_request_t *r, ngx_str_t *s)
{
    u_char      ch;
    ngx_uint_t  i;

    for (i = 0; i < s->len; i++) {
        ch = s->data[i];

        if (ch == ':' && i > 0) {
            return NGX_ERROR;
        }

        if (ch >= 'A' && ch <= 'Z') {
            return NGX_ERROR;
        }

        if (ch == '\0' || ch == CR || ch == LF) {
            return NGX_ERROR;
        }
    }

    return NGX_OK;
}",1,1,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_validate_header_name,,false,3316,3339,ngx_http_grpc_validate_header_name,,,72,"ngx_int_t ngx_http_grpc_validate_header_name (ngx_http_request_t*,ngx_str_t*)"
140614,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_grpc_validate_header_value(ngx_http_request_t *r, ngx_str_t *s)
{
    u_char      ch;
    ngx_uint_t  i;

    for (i = 0; i < s->len; i++) {
        ch = s->data[i];

        if (ch == '\0' || ch == CR || ch == LF) {
            return NGX_ERROR;
        }
    }

    return NGX_OK;
}",1,1,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_validate_header_value,,false,3342,3357,ngx_http_grpc_validate_header_value,,,73,"ngx_int_t ngx_http_grpc_validate_header_value (ngx_http_request_t*,ngx_str_t*)"
140659,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_grpc_parse_rst_stream(ngx_http_request_t *r, ngx_http_grpc_ctx_t *ctx,
    ngx_buf_t *b)
{
    u_char  ch, *p, *last;
    enum {
        sw_start = 0,
        sw_error_2,
        sw_error_3,
        sw_error_4
    } state;

    if (b->last - b->pos < (ssize_t) ctx->rest) {
        last = b->last;

    } else {
        last = b->pos + ctx->rest;
    }

    state = ctx->frame_state;

    if (state == sw_start) {
        if (ctx->rest != 4) {
            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                          ""upstream sent rst stream frame ""
                          ""with invalid length: %uz"",
                          ctx->rest);
            return NGX_ERROR;
        }
    }

    for (p = b->pos; p < last; p++) {
        ch = *p;

#if 0
        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                       ""grpc rst byte: %02Xd s:%d"", ch, state);
#endif

        switch (state) {

        case sw_start:
            ctx->...",1,1,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_parse_rst_stream,,false,3360,3436,ngx_http_grpc_parse_rst_stream,,,74,"ngx_int_t ngx_http_grpc_parse_rst_stream (ngx_http_request_t*,ngx_http_grpc_ctx_t*,ngx_buf_t*)"
140846,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_grpc_parse_goaway(ngx_http_request_t *r, ngx_http_grpc_ctx_t *ctx,
    ngx_buf_t *b)
{
    u_char  ch, *p, *last;
    enum {
        sw_start = 0,
        sw_last_stream_id_2,
        sw_last_stream_id_3,
        sw_last_stream_id_4,
        sw_error,
        sw_error_2,
        sw_error_3,
        sw_error_4,
        sw_debug
    } state;

    if (b->last - b->pos < (ssize_t) ctx->rest) {
        last = b->last;

    } else {
        last = b->pos + ctx->rest;
    }

    state = ctx->frame_state;

    if (state == sw_start) {

        if (ctx->stream_id) {
            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                          ""upstream sent goaway frame ""
                          ""with non-zero stream id: %ui"",
                          ctx->stream_id);
            return NGX_ERROR;
        }

        if (ctx->rest < 8) {
            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                          ""upstream sent goaway frame ""
...",1,1,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_parse_goaway,,false,3439,3554,ngx_http_grpc_parse_goaway,,,75,"ngx_int_t ngx_http_grpc_parse_goaway (ngx_http_request_t*,ngx_http_grpc_ctx_t*,ngx_buf_t*)"
141115,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_grpc_parse_window_update(ngx_http_request_t *r,
    ngx_http_grpc_ctx_t *ctx, ngx_buf_t *b)
{
    u_char  ch, *p, *last;
    enum {
        sw_start = 0,
        sw_size_2,
        sw_size_3,
        sw_size_4
    } state;

    if (b->last - b->pos < (ssize_t) ctx->rest) {
        last = b->last;

    } else {
        last = b->pos + ctx->rest;
    }

    state = ctx->frame_state;

    if (state == sw_start) {
        if (ctx->rest != 4) {
            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                          ""upstream sent window update frame ""
                          ""with invalid length: %uz"",
                          ctx->rest);
            return NGX_ERROR;
        }
    }

    for (p = b->pos; p < last; p++) {
        ch = *p;

#if 0
        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                       ""grpc window update byte: %02Xd s:%d"", ch, state);
#endif

        switch (state) {

        case sw_start:
    ...",1,1,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_parse_window_update,,false,3557,3659,ngx_http_grpc_parse_window_update,,,76,"ngx_int_t ngx_http_grpc_parse_window_update (ngx_http_request_t*,ngx_http_grpc_ctx_t*,ngx_buf_t*)"
141378,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_grpc_parse_settings(ngx_http_request_t *r, ngx_http_grpc_ctx_t *ctx,
    ngx_buf_t *b)
{
    u_char   ch, *p, *last;
    ssize_t  window_update;
    enum {
        sw_start = 0,
        sw_id,
        sw_id_2,
        sw_value,
        sw_value_2,
        sw_value_3,
        sw_value_4
    } state;

    if (b->last - b->pos < (ssize_t) ctx->rest) {
        last = b->last;

    } else {
        last = b->pos + ctx->rest;
    }

    state = ctx->frame_state;

    if (state == sw_start) {

        if (ctx->stream_id) {
            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                          ""upstream sent settings frame ""
                          ""with non-zero stream id: %ui"",
                          ctx->stream_id);
            return NGX_ERROR;
        }

        if (ctx->flags & NGX_HTTP_V2_ACK_FLAG) {
            ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                           ""grpc settings ack"");

            if (ct...",1,1,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_parse_settings,,false,3662,3828,ngx_http_grpc_parse_settings,,,77,"ngx_int_t ngx_http_grpc_parse_settings (ngx_http_request_t*,ngx_http_grpc_ctx_t*,ngx_buf_t*)"
141776,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_grpc_parse_ping(ngx_http_request_t *r,
    ngx_http_grpc_ctx_t *ctx, ngx_buf_t *b)
{
    u_char  ch, *p, *last;
    enum {
        sw_start = 0,
        sw_data_2,
        sw_data_3,
        sw_data_4,
        sw_data_5,
        sw_data_6,
        sw_data_7,
        sw_data_8
    } state;

    if (b->last - b->pos < (ssize_t) ctx->rest) {
        last = b->last;

    } else {
        last = b->pos + ctx->rest;
    }

    state = ctx->frame_state;

    if (state == sw_start) {

        if (ctx->stream_id) {
            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                          ""upstream sent ping frame ""
                          ""with non-zero stream id: %ui"",
                          ctx->stream_id);
            return NGX_ERROR;
        }

        if (ctx->rest != 8) {
            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                          ""upstream sent ping frame ""
                          ""with invalid length: %uz"",
 ...",1,1,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_parse_ping,,false,3831,3919,ngx_http_grpc_parse_ping,,,78,"ngx_int_t ngx_http_grpc_parse_ping (ngx_http_request_t*,ngx_http_grpc_ctx_t*,ngx_buf_t*)"
142000,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_grpc_send_settings_ack(ngx_http_request_t *r, ngx_http_grpc_ctx_t *ctx)
{
    ngx_chain_t            *cl, **ll;
    ngx_http_grpc_frame_t  *f;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""grpc send settings ack"");

    for (cl = ctx->out, ll = &ctx->out; cl; cl = cl->next) {
        ll = &cl->next;
    }

    cl = ngx_http_grpc_get_buf(r, ctx);
    if (cl == NULL) {
        return NGX_ERROR;
    }

    f = (ngx_http_grpc_frame_t *) cl->buf->last;
    cl->buf->last += sizeof(ngx_http_grpc_frame_t);

    f->length_0 = 0;
    f->length_1 = 0;
    f->length_2 = 0;
    f->type = NGX_HTTP_V2_SETTINGS_FRAME;
    f->flags = NGX_HTTP_V2_ACK_FLAG;
    f->stream_id_0 = 0;
    f->stream_id_1 = 0;
    f->stream_id_2 = 0;
    f->stream_id_3 = 0;

    *ll = cl;

    return NGX_OK;
}",1,1,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_send_settings_ack,,false,3922,3956,ngx_http_grpc_send_settings_ack,,,79,"ngx_int_t ngx_http_grpc_send_settings_ack (ngx_http_request_t*,ngx_http_grpc_ctx_t*)"
142125,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_grpc_send_ping_ack(ngx_http_request_t *r, ngx_http_grpc_ctx_t *ctx)
{
    ngx_chain_t            *cl, **ll;
    ngx_http_grpc_frame_t  *f;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""grpc send ping ack"");

    for (cl = ctx->out, ll = &ctx->out; cl; cl = cl->next) {
        ll = &cl->next;
    }

    cl = ngx_http_grpc_get_buf(r, ctx);
    if (cl == NULL) {
        return NGX_ERROR;
    }

    f = (ngx_http_grpc_frame_t *) cl->buf->last;
    cl->buf->last += sizeof(ngx_http_grpc_frame_t);

    f->length_0 = 0;
    f->length_1 = 0;
    f->length_2 = 8;
    f->type = NGX_HTTP_V2_PING_FRAME;
    f->flags = NGX_HTTP_V2_ACK_FLAG;
    f->stream_id_0 = 0;
    f->stream_id_1 = 0;
    f->stream_id_2 = 0;
    f->stream_id_3 = 0;

    cl->buf->last = ngx_copy(cl->buf->last, ctx->ping_data, 8);

    *ll = cl;

    return NGX_OK;
}",1,1,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_send_ping_ack,,false,3959,3995,ngx_http_grpc_send_ping_ack,,,80,"ngx_int_t ngx_http_grpc_send_ping_ack (ngx_http_request_t*,ngx_http_grpc_ctx_t*)"
142266,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_grpc_send_window_update(ngx_http_request_t *r,
    ngx_http_grpc_ctx_t *ctx)
{
    size_t                  n;
    ngx_chain_t            *cl, **ll;
    ngx_http_grpc_frame_t  *f;

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""grpc send window update: %uz %uz"",
                   ctx->connection->recv_window, ctx->recv_window);

    for (cl = ctx->out, ll = &ctx->out; cl; cl = cl->next) {
        ll = &cl->next;
    }

    cl = ngx_http_grpc_get_buf(r, ctx);
    if (cl == NULL) {
        return NGX_ERROR;
    }

    f = (ngx_http_grpc_frame_t *) cl->buf->last;
    cl->buf->last += sizeof(ngx_http_grpc_frame_t);

    f->length_0 = 0;
    f->length_1 = 0;
    f->length_2 = 4;
    f->type = NGX_HTTP_V2_WINDOW_UPDATE_FRAME;
    f->flags = 0;
    f->stream_id_0 = 0;
    f->stream_id_1 = 0;
    f->stream_id_2 = 0;
    f->stream_id_3 = 0;

    n = NGX_HTTP_V2_MAX_WINDOW - ctx->connection->recv_window;
    ctx->connection->recv_wi...",1,1,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_send_window_update,,false,3998,4064,ngx_http_grpc_send_window_update,,,81,"ngx_int_t ngx_http_grpc_send_window_update (ngx_http_request_t*,ngx_http_grpc_ctx_t*)"
142624,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_chain_t *
ngx_http_grpc_get_buf(ngx_http_request_t *r, ngx_http_grpc_ctx_t *ctx)
{
    u_char       *start;
    ngx_buf_t    *b;
    ngx_chain_t  *cl;

    cl = ngx_chain_get_free_buf(r->pool, &ctx->free);
    if (cl == NULL) {
        return NULL;
    }

    b = cl->buf;
    start = b->start;

    if (start == NULL) {

        /*
         * each buffer is large enough to hold two window update
         * frames in a row
         */

        start = ngx_palloc(r->pool, 2 * sizeof(ngx_http_grpc_frame_t) + 8);
        if (start == NULL) {
            return NULL;
        }

    }

    ngx_memzero(b, sizeof(ngx_buf_t));

    b->start = start;
    b->pos = start;
    b->last = start;
    b->end = start + 2 * sizeof(ngx_http_grpc_frame_t) + 8;

    b->tag = (ngx_buf_tag_t) &ngx_http_grpc_body_output_filter;
    b->temporary = 1;
    b->flush = 1;

    return cl;
}",1,1,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_get_buf,,false,4067,4108,ngx_http_grpc_get_buf,,,82,"ngx_chain_t ngx_http_grpc_get_buf (ngx_http_request_t*,ngx_http_grpc_ctx_t*)"
142734,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_http_grpc_ctx_t *
ngx_http_grpc_get_ctx(ngx_http_request_t *r)
{
    ngx_http_grpc_ctx_t  *ctx;
    ngx_http_upstream_t  *u;

    ctx = ngx_http_get_module_ctx(r, ngx_http_grpc_module);

    if (ctx->connection == NULL) {
        u = r->upstream;

        if (ngx_http_grpc_get_connection_data(r, ctx, &u->peer) != NGX_OK) {
            return NULL;
        }
    }

    return ctx;
}",1,1,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_get_ctx,,false,4111,4128,ngx_http_grpc_get_ctx,,,83,ngx_http_grpc_ctx_t ngx_http_grpc_get_ctx (ngx_http_request_t*)
142773,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_grpc_get_connection_data(ngx_http_request_t *r,
    ngx_http_grpc_ctx_t *ctx, ngx_peer_connection_t *pc)
{
    ngx_connection_t    *c;
    ngx_pool_cleanup_t  *cln;

    c = pc->connection;

    if (pc->cached) {

        /*
         * for cached connections, connection data can be found
         * in the cleanup handler
         */

        for (cln = c->pool->cleanup; cln; cln = cln->next) {
            if (cln->handler == ngx_http_grpc_cleanup) {
                ctx->connection = cln->data;
                break;
            }
        }

        if (ctx->connection == NULL) {
            ngx_log_error(NGX_LOG_ERR, c->log, 0,
                          ""no connection data found for ""
                          ""keepalive http2 connection"");
            return NGX_ERROR;
        }

        ctx->send_window = ctx->connection->init_window;
        ctx->recv_window = NGX_HTTP_V2_MAX_WINDOW;

        ctx->connection->last_stream_id += 2;
        ctx->id = ctx->c...",1,1,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_get_connection_data,,false,4131,4189,ngx_http_grpc_get_connection_data,,,84,"ngx_int_t ngx_http_grpc_get_connection_data (ngx_http_request_t*,ngx_http_grpc_ctx_t*,ngx_peer_connection_t*)"
142943,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static void
ngx_http_grpc_cleanup(void *data)
{
#if 0
    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,
                   ""grpc cleanup"");
#endif
    return;
}",1,1,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_cleanup,,false,4192,4200,ngx_http_grpc_cleanup,,,85,void ngx_http_grpc_cleanup (void*)
142949,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static void
ngx_http_grpc_abort_request(ngx_http_request_t *r)
{
    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""abort grpc request"");
    return;
}",1,1,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_abort_request,,false,4203,4209,ngx_http_grpc_abort_request,,,86,void ngx_http_grpc_abort_request (ngx_http_request_t*)
142964,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static void
ngx_http_grpc_finalize_request(ngx_http_request_t *r, ngx_int_t rc)
{
    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""finalize grpc request"");
    return;
}",1,1,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_finalize_request,,false,4212,4218,ngx_http_grpc_finalize_request,,,87,"void ngx_http_grpc_finalize_request (ngx_http_request_t*,ngx_int_t)"
142980,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_grpc_internal_trailers_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    ngx_table_elt_t  *te;

    te = r->headers_in.te;

    if (te == NULL) {
        v->not_found = 1;
        return NGX_OK;
    }

    if (ngx_strlcasestrn(te->value.data, te->value.data + te->value.len,
                         (u_char *) ""trailers"", 8 - 1)
        == NULL)
    {
        v->not_found = 1;
        return NGX_OK;
    }

    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;

    v->data = (u_char *) ""trailers"";
    v->len = sizeof(""trailers"") - 1;

    return NGX_OK;
}",1,1,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_internal_trailers_variable,,false,4221,4250,ngx_http_grpc_internal_trailers_variable,,,88,"ngx_int_t ngx_http_grpc_internal_trailers_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
143073,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_grpc_add_variables(ngx_conf_t *cf)
{
    ngx_http_variable_t  *var, *v;

    for (v = ngx_http_grpc_vars; v->name.len; v++) {
        var = ngx_http_add_variable(cf, &v->name, v->flags);
        if (var == NULL) {
            return NGX_ERROR;
        }

        var->get_handler = v->get_handler;
        var->data = v->data;
    }

    return NGX_OK;
}",1,1,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_add_variables,,false,4253,4269,ngx_http_grpc_add_variables,,,89,ngx_int_t ngx_http_grpc_add_variables (ngx_conf_t*)
143127,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static void *
ngx_http_grpc_create_loc_conf(ngx_conf_t *cf)
{
    ngx_http_grpc_loc_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_grpc_loc_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     conf->upstream.ignore_headers = 0;
     *     conf->upstream.next_upstream = 0;
     *     conf->upstream.hide_headers_hash = { NULL, 0 };
     *     conf->upstream.ssl_name = NULL;
     *
     *     conf->headers_source = NULL;
     *     conf->headers.lengths = NULL;
     *     conf->headers.values = NULL;
     *     conf->headers.hash = { NULL, 0 };
     *     conf->host = { 0, NULL };
     *     conf->host_set = 0;
     *     conf->ssl = 0;
     *     conf->ssl_protocols = 0;
     *     conf->ssl_ciphers = { 0, NULL };
     *     conf->ssl_trusted_certificate = { 0, NULL };
     *     conf->ssl_crl = { 0, NULL };
     *     conf->ssl_certificate = { 0, NULL };
     *     conf->ssl_certificate_key = { 0, NULL }...",1,1,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_create_loc_conf,,false,4272,4346,ngx_http_grpc_create_loc_conf,,,90,void* ngx_http_grpc_create_loc_conf (ngx_conf_t*)
143328,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static char *
ngx_http_grpc_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_grpc_loc_conf_t *prev = parent;
    ngx_http_grpc_loc_conf_t *conf = child;

    ngx_int_t                  rc;
    ngx_hash_init_t            hash;
    ngx_http_core_loc_conf_t  *clcf;

    ngx_conf_merge_ptr_value(conf->upstream.local,
                              prev->upstream.local, NULL);

    ngx_conf_merge_value(conf->upstream.socket_keepalive,
                              prev->upstream.socket_keepalive, 0);

    ngx_conf_merge_uint_value(conf->upstream.next_upstream_tries,
                              prev->upstream.next_upstream_tries, 0);

    ngx_conf_merge_msec_value(conf->upstream.connect_timeout,
                              prev->upstream.connect_timeout, 60000);

    ngx_conf_merge_msec_value(conf->upstream.send_timeout,
                              prev->upstream.send_timeout, 60000);

    ngx_conf_merge_msec_value(conf->upstream.read_timeout,
                ...",1,1,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_merge_loc_conf,,false,4349,4498,ngx_http_grpc_merge_loc_conf,,,91,"char* ngx_http_grpc_merge_loc_conf (ngx_conf_t*,void*,void*)"
143700,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_grpc_init_headers(ngx_conf_t *cf, ngx_http_grpc_loc_conf_t *conf,
    ngx_http_grpc_headers_t *headers, ngx_keyval_t *default_headers)
{
    u_char                       *p;
    size_t                        size;
    uintptr_t                    *code;
    ngx_uint_t                    i;
    ngx_array_t                   headers_names, headers_merged;
    ngx_keyval_t                 *src, *s, *h;
    ngx_hash_key_t               *hk;
    ngx_hash_init_t               hash;
    ngx_http_script_compile_t     sc;
    ngx_http_script_copy_code_t  *copy;

    if (headers->hash.buckets) {
        return NGX_OK;
    }

    if (ngx_array_init(&headers_names, cf->temp_pool, 4, sizeof(ngx_hash_key_t))
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    if (ngx_array_init(&headers_merged, cf->temp_pool, 4, sizeof(ngx_keyval_t))
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    headers->lengths = ngx_array_create(cf->pool, 64, 1);
    if (heade...",1,1,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_init_headers,,false,4501,4671,ngx_http_grpc_init_headers,,,92,"ngx_int_t ngx_http_grpc_init_headers (ngx_conf_t*,ngx_http_grpc_loc_conf_t*,ngx_http_grpc_headers_t*,ngx_keyval_t*)"
144295,METHOD,http\modules\ngx_http_grpc_module.c:<global>,TYPE_DECL,"static char *
ngx_http_grpc_pass(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_grpc_loc_conf_t *glcf = conf;

    size_t                      add;
    ngx_str_t                  *value, *url;
    ngx_url_t                   u;
    ngx_uint_t                  n;
    ngx_http_core_loc_conf_t   *clcf;
    ngx_http_script_compile_t   sc;

    if (glcf->upstream.upstream || glcf->grpc_lengths) {
        return ""is duplicate"";
    }

    clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);

    clcf->handler = ngx_http_grpc_handler;

    if (clcf->name.len && clcf->name.data[clcf->name.len - 1] == '/') {
        clcf->auto_redirect = 1;
    }

    value = cf->args->elts;

    url = &value[1];

    n = ngx_http_script_variables_count(url);

    if (n) {

        ngx_memzero(&sc, sizeof(ngx_http_script_compile_t));

        sc.cf = cf;
        sc.source = url;
        sc.lengths = &glcf->grpc_lengths;
        sc.values = &glcf->grpc_values;
        sc.variabl...",1,1,http\modules\ngx_http_grpc_module.c,ngx_http_grpc_pass,,false,4674,4772,ngx_http_grpc_pass,,,93,"char* ngx_http_grpc_pass (ngx_conf_t*,ngx_command_t*,void*)"
144608,METHOD,http\modules\ngx_http_gunzip_filter_module.c:<global>,TYPE_DECL,<global>,1,1,http\modules\ngx_http_gunzip_filter_module.c,http\modules\ngx_http_gunzip_filter_module.c:<global>,,false,1,687,<global>,,,1,
144631,METHOD,http\modules\ngx_http_gunzip_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_gunzip_filter_inflate_start(ngx_http_request_t *r,
    ngx_http_gunzip_ctx_t *ctx);",18,31,http\modules\ngx_http_gunzip_filter_module.c,ngx_http_gunzip_filter_inflate_start,,false,44,45,ngx_http_gunzip_filter_inflate_start,,,5,"ngx_int_t ngx_http_gunzip_filter_inflate_start (ngx_http_request_t*,ngx_http_gunzip_ctx_t*)"
144637,METHOD,http\modules\ngx_http_gunzip_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_gunzip_filter_add_data(ngx_http_request_t *r,
    ngx_http_gunzip_ctx_t *ctx);",18,31,http\modules\ngx_http_gunzip_filter_module.c,ngx_http_gunzip_filter_add_data,,false,46,47,ngx_http_gunzip_filter_add_data,,,6,"ngx_int_t ngx_http_gunzip_filter_add_data (ngx_http_request_t*,ngx_http_gunzip_ctx_t*)"
144643,METHOD,http\modules\ngx_http_gunzip_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_gunzip_filter_get_buf(ngx_http_request_t *r,
    ngx_http_gunzip_ctx_t *ctx);",18,31,http\modules\ngx_http_gunzip_filter_module.c,ngx_http_gunzip_filter_get_buf,,false,48,49,ngx_http_gunzip_filter_get_buf,,,7,"ngx_int_t ngx_http_gunzip_filter_get_buf (ngx_http_request_t*,ngx_http_gunzip_ctx_t*)"
144649,METHOD,http\modules\ngx_http_gunzip_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_gunzip_filter_inflate(ngx_http_request_t *r,
    ngx_http_gunzip_ctx_t *ctx);",18,31,http\modules\ngx_http_gunzip_filter_module.c,ngx_http_gunzip_filter_inflate,,false,50,51,ngx_http_gunzip_filter_inflate,,,8,"ngx_int_t ngx_http_gunzip_filter_inflate (ngx_http_request_t*,ngx_http_gunzip_ctx_t*)"
144655,METHOD,http\modules\ngx_http_gunzip_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_gunzip_filter_inflate_end(ngx_http_request_t *r,
    ngx_http_gunzip_ctx_t *ctx);",18,31,http\modules\ngx_http_gunzip_filter_module.c,ngx_http_gunzip_filter_inflate_end,,false,52,53,ngx_http_gunzip_filter_inflate_end,,,9,"ngx_int_t ngx_http_gunzip_filter_inflate_end (ngx_http_request_t*,ngx_http_gunzip_ctx_t*)"
144661,METHOD,http\modules\ngx_http_gunzip_filter_module.c:<global>,TYPE_DECL,"static void *ngx_http_gunzip_filter_alloc(void *opaque, u_int items,
    u_int size);",13,15,http\modules\ngx_http_gunzip_filter_module.c,ngx_http_gunzip_filter_alloc,,false,55,56,ngx_http_gunzip_filter_alloc,,,10,"void* ngx_http_gunzip_filter_alloc (void*,u_int,u_int)"
144668,METHOD,http\modules\ngx_http_gunzip_filter_module.c:<global>,TYPE_DECL,"static void ngx_http_gunzip_filter_free(void *opaque, void *address);",13,68,http\modules\ngx_http_gunzip_filter_module.c,ngx_http_gunzip_filter_free,,false,57,57,ngx_http_gunzip_filter_free,,,11,"void ngx_http_gunzip_filter_free (void*,void*)"
144674,METHOD,http\modules\ngx_http_gunzip_filter_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_gunzip_filter_init(ngx_conf_t *cf);,18,60,http\modules\ngx_http_gunzip_filter_module.c,ngx_http_gunzip_filter_init,,false,59,59,ngx_http_gunzip_filter_init,,,12,ngx_int_t ngx_http_gunzip_filter_init (ngx_conf_t*)
144679,METHOD,http\modules\ngx_http_gunzip_filter_module.c:<global>,TYPE_DECL,static void *ngx_http_gunzip_create_conf(ngx_conf_t *cf);,13,56,http\modules\ngx_http_gunzip_filter_module.c,ngx_http_gunzip_create_conf,,false,60,60,ngx_http_gunzip_create_conf,,,13,void* ngx_http_gunzip_create_conf (ngx_conf_t*)
144684,METHOD,http\modules\ngx_http_gunzip_filter_module.c:<global>,TYPE_DECL,"static char *ngx_http_gunzip_merge_conf(ngx_conf_t *cf,
    void *parent, void *child);",13,30,http\modules\ngx_http_gunzip_filter_module.c,ngx_http_gunzip_merge_conf,,false,61,62,ngx_http_gunzip_merge_conf,,,14,"char* ngx_http_gunzip_merge_conf (ngx_conf_t*,void*,void*)"
144759,METHOD,http\modules\ngx_http_gunzip_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_gunzip_header_filter(ngx_http_request_t *r)
{
    ngx_http_gunzip_ctx_t   *ctx;
    ngx_http_gunzip_conf_t  *conf;

    conf = ngx_http_get_module_loc_conf(r, ngx_http_gunzip_filter_module);

    /* TODO support multiple content-codings */
    /* TODO always gunzip - due to configuration or module request */
    /* TODO ignore content encoding? */

    if (!conf->enable
        || r->headers_out.content_encoding == NULL
        || r->headers_out.content_encoding->value.len != 4
        || ngx_strncasecmp(r->headers_out.content_encoding->value.data,
                           (u_char *) ""gzip"", 4) != 0)
    {
        return ngx_http_next_header_filter(r);
    }

    r->gzip_vary = 1;

    if (!r->gzip_tested) {
        if (ngx_http_gzip_ok(r) == NGX_OK) {
            return ngx_http_next_header_filter(r);
        }

    } else if (r->gzip_ok) {
        return ngx_http_next_header_filter(r);
    }

    ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_gunzip_ctx_t))...",1,1,http\modules\ngx_http_gunzip_filter_module.c,ngx_http_gunzip_header_filter,,false,120,171,ngx_http_gunzip_header_filter,,,23,ngx_int_t ngx_http_gunzip_header_filter (ngx_http_request_t*)
144901,METHOD,http\modules\ngx_http_gunzip_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_gunzip_body_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    int                     rc;
    ngx_uint_t              flush;
    ngx_chain_t            *cl;
    ngx_http_gunzip_ctx_t  *ctx;

    ctx = ngx_http_get_module_ctx(r, ngx_http_gunzip_filter_module);

    if (ctx == NULL || ctx->done) {
        return ngx_http_next_body_filter(r, in);
    }

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http gunzip filter"");

    if (!ctx->started) {
        if (ngx_http_gunzip_filter_inflate_start(r, ctx) != NGX_OK) {
            goto failed;
        }
    }

    if (in) {
        if (ngx_chain_add_copy(r->pool, &ctx->in, in) != NGX_OK) {
            goto failed;
        }
    }

    if (ctx->nomem) {

        /* flush busy buffers */

        if (ngx_http_next_body_filter(r, NULL) == NGX_ERROR) {
            goto failed;
        }

        cl = NULL;

        ngx_chain_update_chains(r->pool, &ctx->free, &ctx->busy, &cl,
    ...",1,1,http\modules\ngx_http_gunzip_filter_module.c,ngx_http_gunzip_body_filter,,false,174,298,ngx_http_gunzip_body_filter,,,24,"ngx_int_t ngx_http_gunzip_body_filter (ngx_http_request_t*,ngx_chain_t*)"
145169,METHOD,http\modules\ngx_http_gunzip_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_gunzip_filter_inflate_start(ngx_http_request_t *r,
    ngx_http_gunzip_ctx_t *ctx)
{
    int  rc;

    ctx->zstream.next_in = Z_NULL;
    ctx->zstream.avail_in = 0;

    ctx->zstream.zalloc = ngx_http_gunzip_filter_alloc;
    ctx->zstream.zfree = ngx_http_gunzip_filter_free;
    ctx->zstream.opaque = ctx;

    /* windowBits +16 to decode gzip, zlib 1.2.0.4+ */
    rc = inflateInit2(&ctx->zstream, MAX_WBITS + 16);

    if (rc != Z_OK) {
        ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,
                      ""inflateInit2() failed: %d"", rc);
        return NGX_ERROR;
    }

    ctx->started = 1;

    ctx->last_out = &ctx->out;
    ctx->flush = Z_NO_FLUSH;

    return NGX_OK;
}",1,1,http\modules\ngx_http_gunzip_filter_module.c,ngx_http_gunzip_filter_inflate_start,,false,301,329,ngx_http_gunzip_filter_inflate_start,,,25,"ngx_int_t ngx_http_gunzip_filter_inflate_start (ngx_http_request_t*,ngx_http_gunzip_ctx_t*)"
145258,METHOD,http\modules\ngx_http_gunzip_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_gunzip_filter_add_data(ngx_http_request_t *r,
    ngx_http_gunzip_ctx_t *ctx)
{
    if (ctx->zstream.avail_in || ctx->flush != Z_NO_FLUSH || ctx->redo) {
        return NGX_OK;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""gunzip in: %p"", ctx->in);

    if (ctx->in == NULL) {
        return NGX_DECLINED;
    }

    ctx->in_buf = ctx->in->buf;
    ctx->in = ctx->in->next;

    ctx->zstream.next_in = ctx->in_buf->pos;
    ctx->zstream.avail_in = ctx->in_buf->last - ctx->in_buf->pos;

    ngx_log_debug3(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""gunzip in_buf:%p ni:%p ai:%ud"",
                   ctx->in_buf,
                   ctx->zstream.next_in, ctx->zstream.avail_in);

    if (ctx->in_buf->last_buf || ctx->in_buf->last_in_chain) {
        ctx->flush = Z_FINISH;

    } else if (ctx->in_buf->flush) {
        ctx->flush = Z_SYNC_FLUSH;

    } else if (ctx->zstream.avail_in == 0) {
        /* ctx->...",1,1,http\modules\ngx_http_gunzip_filter_module.c,ngx_http_gunzip_filter_add_data,,false,332,370,ngx_http_gunzip_filter_add_data,,,26,"ngx_int_t ngx_http_gunzip_filter_add_data (ngx_http_request_t*,ngx_http_gunzip_ctx_t*)"
145419,METHOD,http\modules\ngx_http_gunzip_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_gunzip_filter_get_buf(ngx_http_request_t *r,
    ngx_http_gunzip_ctx_t *ctx)
{
    ngx_http_gunzip_conf_t  *conf;

    if (ctx->zstream.avail_out) {
        return NGX_OK;
    }

    conf = ngx_http_get_module_loc_conf(r, ngx_http_gunzip_filter_module);

    if (ctx->free) {
        ctx->out_buf = ctx->free->buf;
        ctx->free = ctx->free->next;

        ctx->out_buf->flush = 0;

    } else if (ctx->bufs < conf->bufs.num) {

        ctx->out_buf = ngx_create_temp_buf(r->pool, conf->bufs.size);
        if (ctx->out_buf == NULL) {
            return NGX_ERROR;
        }

        ctx->out_buf->tag = (ngx_buf_tag_t) &ngx_http_gunzip_filter_module;
        ctx->out_buf->recycled = 1;
        ctx->bufs++;

    } else {
        ctx->nomem = 1;
        return NGX_DECLINED;
    }

    ctx->zstream.next_out = ctx->out_buf->pos;
    ctx->zstream.avail_out = conf->bufs.size;

    return NGX_OK;
}",1,1,http\modules\ngx_http_gunzip_filter_module.c,ngx_http_gunzip_filter_get_buf,,false,373,411,ngx_http_gunzip_filter_get_buf,,,27,"ngx_int_t ngx_http_gunzip_filter_get_buf (ngx_http_request_t*,ngx_http_gunzip_ctx_t*)"
145558,METHOD,http\modules\ngx_http_gunzip_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_gunzip_filter_inflate(ngx_http_request_t *r,
    ngx_http_gunzip_ctx_t *ctx)
{
    int           rc;
    ngx_buf_t    *b;
    ngx_chain_t  *cl;

    ngx_log_debug6(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""inflate in: ni:%p no:%p ai:%ud ao:%ud fl:%d redo:%d"",
                   ctx->zstream.next_in, ctx->zstream.next_out,
                   ctx->zstream.avail_in, ctx->zstream.avail_out,
                   ctx->flush, ctx->redo);

    rc = inflate(&ctx->zstream, ctx->flush);

    if (rc != Z_OK && rc != Z_STREAM_END && rc != Z_BUF_ERROR) {
        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                      ""inflate() failed: %d, %d"", ctx->flush, rc);
        return NGX_ERROR;
    }

    ngx_log_debug5(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""inflate out: ni:%p no:%p ai:%ud ao:%ud rc:%d"",
                   ctx->zstream.next_in, ctx->zstream.next_out,
                   ctx->zstream.avail_in, ctx->zstream...",1,1,http\modules\ngx_http_gunzip_filter_module.c,ngx_http_gunzip_filter_inflate,,false,414,563,ngx_http_gunzip_filter_inflate,,,28,"ngx_int_t ngx_http_gunzip_filter_inflate (ngx_http_request_t*,ngx_http_gunzip_ctx_t*)"
146038,METHOD,http\modules\ngx_http_gunzip_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_gunzip_filter_inflate_end(ngx_http_request_t *r,
    ngx_http_gunzip_ctx_t *ctx)
{
    int           rc;
    ngx_buf_t    *b;
    ngx_chain_t  *cl;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""gunzip inflate end"");

    rc = inflateEnd(&ctx->zstream);

    if (rc != Z_OK) {
        ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,
                      ""inflateEnd() failed: %d"", rc);
        return NGX_ERROR;
    }

    b = ctx->out_buf;

    if (ngx_buf_size(b) == 0) {

        b = ngx_calloc_buf(ctx->request->pool);
        if (b == NULL) {
            return NGX_ERROR;
        }
    }

    cl = ngx_alloc_chain_link(r->pool);
    if (cl == NULL) {
        return NGX_ERROR;
    }

    cl->buf = b;
    cl->next = NULL;
    *ctx->last_out = cl;
    ctx->last_out = &cl->next;

    b->last_buf = (r == r->main) ? 1 : 0;
    b->last_in_chain = 1;
    b->sync = 1;

    ctx->done = 1;

    return NGX_OK;
}",1,1,http\modules\ngx_http_gunzip_filter_module.c,ngx_http_gunzip_filter_inflate_end,,false,566,612,ngx_http_gunzip_filter_inflate_end,,,29,"ngx_int_t ngx_http_gunzip_filter_inflate_end (ngx_http_request_t*,ngx_http_gunzip_ctx_t*)"
146172,METHOD,http\modules\ngx_http_gunzip_filter_module.c:<global>,TYPE_DECL,"static void *
ngx_http_gunzip_filter_alloc(void *opaque, u_int items, u_int size)
{
    ngx_http_gunzip_ctx_t *ctx = opaque;

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, ctx->request->connection->log, 0,
                   ""gunzip alloc: n:%ud s:%ud"",
                   items, size);

    return ngx_palloc(ctx->request->pool, items * size);
}",1,1,http\modules\ngx_http_gunzip_filter_module.c,ngx_http_gunzip_filter_alloc,,false,615,625,ngx_http_gunzip_filter_alloc,,,30,"void* ngx_http_gunzip_filter_alloc (void*,u_int,u_int)"
146206,METHOD,http\modules\ngx_http_gunzip_filter_module.c:<global>,TYPE_DECL,"static void
ngx_http_gunzip_filter_free(void *opaque, void *address)
{
#if 0
    ngx_http_gunzip_ctx_t *ctx = opaque;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx->request->connection->log, 0,
                   ""gunzip free: %p"", address);
#endif
}",1,1,http\modules\ngx_http_gunzip_filter_module.c,ngx_http_gunzip_filter_free,,false,628,637,ngx_http_gunzip_filter_free,,,31,"void ngx_http_gunzip_filter_free (void*,void*)"
146212,METHOD,http\modules\ngx_http_gunzip_filter_module.c:<global>,TYPE_DECL,"static void *
ngx_http_gunzip_create_conf(ngx_conf_t *cf)
{
    ngx_http_gunzip_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_gunzip_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     conf->bufs.num = 0;
     */

    conf->enable = NGX_CONF_UNSET;

    return conf;
}",1,1,http\modules\ngx_http_gunzip_filter_module.c,ngx_http_gunzip_create_conf,,false,640,659,ngx_http_gunzip_create_conf,,,32,void* ngx_http_gunzip_create_conf (ngx_conf_t*)
146240,METHOD,http\modules\ngx_http_gunzip_filter_module.c:<global>,TYPE_DECL,"static char *
ngx_http_gunzip_merge_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_gunzip_conf_t *prev = parent;
    ngx_http_gunzip_conf_t *conf = child;

    ngx_conf_merge_value(conf->enable, prev->enable, 0);

    ngx_conf_merge_bufs_value(conf->bufs, prev->bufs,
                              (128 * 1024) / ngx_pagesize, ngx_pagesize);

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_gunzip_filter_module.c,ngx_http_gunzip_merge_conf,,false,662,674,ngx_http_gunzip_merge_conf,,,33,"char* ngx_http_gunzip_merge_conf (ngx_conf_t*,void*,void*)"
146278,METHOD,http\modules\ngx_http_gunzip_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_gunzip_filter_init(ngx_conf_t *cf)
{
    ngx_http_next_header_filter = ngx_http_top_header_filter;
    ngx_http_top_header_filter = ngx_http_gunzip_header_filter;

    ngx_http_next_body_filter = ngx_http_top_body_filter;
    ngx_http_top_body_filter = ngx_http_gunzip_body_filter;

    return NGX_OK;
}",1,1,http\modules\ngx_http_gunzip_filter_module.c,ngx_http_gunzip_filter_init,,false,677,687,ngx_http_gunzip_filter_init,,,34,ngx_int_t ngx_http_gunzip_filter_init (ngx_conf_t*)
146308,METHOD,http\modules\ngx_http_gzip_filter_module.c:<global>,TYPE_DECL,<global>,1,1,http\modules\ngx_http_gzip_filter_module.c,http\modules\ngx_http_gzip_filter_module.c:<global>,,false,1,1170,<global>,,,1,
146349,METHOD,http\modules\ngx_http_gzip_filter_module.c:<global>,TYPE_DECL,"static void ngx_http_gzip_filter_memory(ngx_http_request_t *r,
    ngx_http_gzip_ctx_t *ctx);",13,29,http\modules\ngx_http_gzip_filter_module.c,ngx_http_gzip_filter_memory,,false,69,70,ngx_http_gzip_filter_memory,,,5,"void ngx_http_gzip_filter_memory (ngx_http_request_t*,ngx_http_gzip_ctx_t*)"
146355,METHOD,http\modules\ngx_http_gzip_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_gzip_filter_buffer(ngx_http_gzip_ctx_t *ctx,
    ngx_chain_t *in);",18,20,http\modules\ngx_http_gzip_filter_module.c,ngx_http_gzip_filter_buffer,,false,71,72,ngx_http_gzip_filter_buffer,,,6,"ngx_int_t ngx_http_gzip_filter_buffer (ngx_http_gzip_ctx_t*,ngx_chain_t*)"
146361,METHOD,http\modules\ngx_http_gzip_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_gzip_filter_deflate_start(ngx_http_request_t *r,
    ngx_http_gzip_ctx_t *ctx);",18,29,http\modules\ngx_http_gzip_filter_module.c,ngx_http_gzip_filter_deflate_start,,false,73,74,ngx_http_gzip_filter_deflate_start,,,7,"ngx_int_t ngx_http_gzip_filter_deflate_start (ngx_http_request_t*,ngx_http_gzip_ctx_t*)"
146367,METHOD,http\modules\ngx_http_gzip_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_gzip_filter_add_data(ngx_http_request_t *r,
    ngx_http_gzip_ctx_t *ctx);",18,29,http\modules\ngx_http_gzip_filter_module.c,ngx_http_gzip_filter_add_data,,false,75,76,ngx_http_gzip_filter_add_data,,,8,"ngx_int_t ngx_http_gzip_filter_add_data (ngx_http_request_t*,ngx_http_gzip_ctx_t*)"
146373,METHOD,http\modules\ngx_http_gzip_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_gzip_filter_get_buf(ngx_http_request_t *r,
    ngx_http_gzip_ctx_t *ctx);",18,29,http\modules\ngx_http_gzip_filter_module.c,ngx_http_gzip_filter_get_buf,,false,77,78,ngx_http_gzip_filter_get_buf,,,9,"ngx_int_t ngx_http_gzip_filter_get_buf (ngx_http_request_t*,ngx_http_gzip_ctx_t*)"
146379,METHOD,http\modules\ngx_http_gzip_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_gzip_filter_deflate(ngx_http_request_t *r,
    ngx_http_gzip_ctx_t *ctx);",18,29,http\modules\ngx_http_gzip_filter_module.c,ngx_http_gzip_filter_deflate,,false,79,80,ngx_http_gzip_filter_deflate,,,10,"ngx_int_t ngx_http_gzip_filter_deflate (ngx_http_request_t*,ngx_http_gzip_ctx_t*)"
146385,METHOD,http\modules\ngx_http_gzip_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_gzip_filter_deflate_end(ngx_http_request_t *r,
    ngx_http_gzip_ctx_t *ctx);",18,29,http\modules\ngx_http_gzip_filter_module.c,ngx_http_gzip_filter_deflate_end,,false,81,82,ngx_http_gzip_filter_deflate_end,,,11,"ngx_int_t ngx_http_gzip_filter_deflate_end (ngx_http_request_t*,ngx_http_gzip_ctx_t*)"
146391,METHOD,http\modules\ngx_http_gzip_filter_module.c:<global>,TYPE_DECL,"static void *ngx_http_gzip_filter_alloc(void *opaque, u_int items,
    u_int size);",13,15,http\modules\ngx_http_gzip_filter_module.c,ngx_http_gzip_filter_alloc,,false,84,85,ngx_http_gzip_filter_alloc,,,12,"void* ngx_http_gzip_filter_alloc (void*,u_int,u_int)"
146398,METHOD,http\modules\ngx_http_gzip_filter_module.c:<global>,TYPE_DECL,"static void ngx_http_gzip_filter_free(void *opaque, void *address);",13,66,http\modules\ngx_http_gzip_filter_module.c,ngx_http_gzip_filter_free,,false,86,86,ngx_http_gzip_filter_free,,,13,"void ngx_http_gzip_filter_free (void*,void*)"
146404,METHOD,http\modules\ngx_http_gzip_filter_module.c:<global>,TYPE_DECL,"static void ngx_http_gzip_filter_free_copy_buf(ngx_http_request_t *r,
    ngx_http_gzip_ctx_t *ctx);",13,29,http\modules\ngx_http_gzip_filter_module.c,ngx_http_gzip_filter_free_copy_buf,,false,87,88,ngx_http_gzip_filter_free_copy_buf,,,14,"void ngx_http_gzip_filter_free_copy_buf (ngx_http_request_t*,ngx_http_gzip_ctx_t*)"
146410,METHOD,http\modules\ngx_http_gzip_filter_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_gzip_add_variables(ngx_conf_t *cf);,18,60,http\modules\ngx_http_gzip_filter_module.c,ngx_http_gzip_add_variables,,false,90,90,ngx_http_gzip_add_variables,,,15,ngx_int_t ngx_http_gzip_add_variables (ngx_conf_t*)
146415,METHOD,http\modules\ngx_http_gzip_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_gzip_ratio_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\modules\ngx_http_gzip_filter_module.c,ngx_http_gzip_ratio_variable,,false,91,92,ngx_http_gzip_ratio_variable,,,16,"ngx_int_t ngx_http_gzip_ratio_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
146422,METHOD,http\modules\ngx_http_gzip_filter_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_gzip_filter_init(ngx_conf_t *cf);,18,58,http\modules\ngx_http_gzip_filter_module.c,ngx_http_gzip_filter_init,,false,94,94,ngx_http_gzip_filter_init,,,17,ngx_int_t ngx_http_gzip_filter_init (ngx_conf_t*)
146427,METHOD,http\modules\ngx_http_gzip_filter_module.c:<global>,TYPE_DECL,static void *ngx_http_gzip_create_conf(ngx_conf_t *cf);,13,54,http\modules\ngx_http_gzip_filter_module.c,ngx_http_gzip_create_conf,,false,95,95,ngx_http_gzip_create_conf,,,18,void* ngx_http_gzip_create_conf (ngx_conf_t*)
146432,METHOD,http\modules\ngx_http_gzip_filter_module.c:<global>,TYPE_DECL,"static char *ngx_http_gzip_merge_conf(ngx_conf_t *cf,
    void *parent, void *child);",13,30,http\modules\ngx_http_gzip_filter_module.c,ngx_http_gzip_merge_conf,,false,96,97,ngx_http_gzip_merge_conf,,,19,"char* ngx_http_gzip_merge_conf (ngx_conf_t*,void*,void*)"
146439,METHOD,http\modules\ngx_http_gzip_filter_module.c:<global>,TYPE_DECL,"static char *ngx_http_gzip_window(ngx_conf_t *cf, void *post, void *data);",13,73,http\modules\ngx_http_gzip_filter_module.c,ngx_http_gzip_window,,false,98,98,ngx_http_gzip_window,,,20,"char* ngx_http_gzip_window (ngx_conf_t*,void*,void*)"
146446,METHOD,http\modules\ngx_http_gzip_filter_module.c:<global>,TYPE_DECL,"static char *ngx_http_gzip_hash(ngx_conf_t *cf, void *post, void *data);",13,71,http\modules\ngx_http_gzip_filter_module.c,ngx_http_gzip_hash,,false,99,99,ngx_http_gzip_hash,,,21,"char* ngx_http_gzip_hash (ngx_conf_t*,void*,void*)"
146662,METHOD,http\modules\ngx_http_gzip_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_gzip_header_filter(ngx_http_request_t *r)
{
    ngx_table_elt_t       *h;
    ngx_http_gzip_ctx_t   *ctx;
    ngx_http_gzip_conf_t  *conf;

    conf = ngx_http_get_module_loc_conf(r, ngx_http_gzip_filter_module);

    if (!conf->enable
        || (r->headers_out.status != NGX_HTTP_OK
            && r->headers_out.status != NGX_HTTP_FORBIDDEN
            && r->headers_out.status != NGX_HTTP_NOT_FOUND)
        || (r->headers_out.content_encoding
            && r->headers_out.content_encoding->value.len)
        || (r->headers_out.content_length_n != -1
            && r->headers_out.content_length_n < conf->min_length)
        || ngx_http_test_content_type(r, &conf->types) == NULL
        || r->header_only)
    {
        return ngx_http_next_header_filter(r);
    }

    r->gzip_vary = 1;

#if (NGX_HTTP_DEGRADATION)
    {
    ngx_http_core_loc_conf_t  *clcf;

    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    if (clcf->gzip_disable_degradati...",1,1,http\modules\ngx_http_gzip_filter_module.c,ngx_http_gzip_header_filter,,false,219,294,ngx_http_gzip_header_filter,,,39,ngx_int_t ngx_http_gzip_header_filter (ngx_http_request_t*)
146877,METHOD,http\modules\ngx_http_gzip_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_gzip_body_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    int                   rc;
    ngx_uint_t            flush;
    ngx_chain_t          *cl;
    ngx_http_gzip_ctx_t  *ctx;

    ctx = ngx_http_get_module_ctx(r, ngx_http_gzip_filter_module);

    if (ctx == NULL || ctx->done || r->header_only) {
        return ngx_http_next_body_filter(r, in);
    }

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http gzip filter"");

    if (ctx->buffering) {

        /*
         * With default memory settings zlib starts to output gzipped data
         * only after it has got about 90K, so it makes sense to allocate
         * zlib memory (200-400K) only after we have enough data to compress.
         * Although we copy buffers, nevertheless for not big responses
         * this allows to allocate zlib memory, to compress and to output
         * the response in one step using hot CPU cache.
         */

        if (in) {
       ...",1,1,http\modules\ngx_http_gzip_filter_module.c,ngx_http_gzip_body_filter,,false,297,463,ngx_http_gzip_body_filter,,,40,"ngx_int_t ngx_http_gzip_body_filter (ngx_http_request_t*,ngx_chain_t*)"
147203,METHOD,http\modules\ngx_http_gzip_filter_module.c:<global>,TYPE_DECL,"static void
ngx_http_gzip_filter_memory(ngx_http_request_t *r, ngx_http_gzip_ctx_t *ctx)
{
    int                    wbits, memlevel;
    ngx_http_gzip_conf_t  *conf;

    conf = ngx_http_get_module_loc_conf(r, ngx_http_gzip_filter_module);

    wbits = conf->wbits;
    memlevel = conf->memlevel;

    if (r->headers_out.content_length_n > 0) {

        /* the actual zlib window size is smaller by 262 bytes */

        while (r->headers_out.content_length_n < ((1 << (wbits - 1)) - 262)) {
            wbits--;
            memlevel--;
        }

        if (memlevel < 1) {
            memlevel = 1;
        }
    }

    ctx->wbits = wbits;
    ctx->memlevel = memlevel;

    /*
     * We preallocate a memory for zlib in one buffer (200K-400K), this
     * decreases a number of malloc() and free() calls and also probably
     * decreases a number of syscalls (sbrk()/mmap() and so on).
     * Besides we free the memory as soon as a gzipping will complete
     * and do not wait while a who...",1,1,http\modules\ngx_http_gzip_filter_module.c,ngx_http_gzip_filter_memory,,false,466,527,ngx_http_gzip_filter_memory,,,41,"void ngx_http_gzip_filter_memory (ngx_http_request_t*,ngx_http_gzip_ctx_t*)"
147340,METHOD,http\modules\ngx_http_gzip_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_gzip_filter_buffer(ngx_http_gzip_ctx_t *ctx, ngx_chain_t *in)
{
    size_t                 size, buffered;
    ngx_buf_t             *b, *buf;
    ngx_chain_t           *cl, **ll;
    ngx_http_request_t    *r;
    ngx_http_gzip_conf_t  *conf;

    r = ctx->request;

    r->connection->buffered |= NGX_HTTP_GZIP_BUFFERED;

    buffered = 0;
    ll = &ctx->in;

    for (cl = ctx->in; cl; cl = cl->next) {
        buffered += cl->buf->last - cl->buf->pos;
        ll = &cl->next;
    }

    conf = ngx_http_get_module_loc_conf(r, ngx_http_gzip_filter_module);

    while (in) {
        cl = ngx_alloc_chain_link(r->pool);
        if (cl == NULL) {
            return NGX_ERROR;
        }

        b = in->buf;

        size = b->last - b->pos;
        buffered += size;

        if (b->flush || b->last_buf || buffered > conf->postpone_gzipping) {
            ctx->buffering = 0;
        }

        if (ctx->buffering && size) {

            buf = ngx_create_temp_buf(r->p...",1,1,http\modules\ngx_http_gzip_filter_module.c,ngx_http_gzip_filter_buffer,,false,530,595,ngx_http_gzip_filter_buffer,,,42,"ngx_int_t ngx_http_gzip_filter_buffer (ngx_http_gzip_ctx_t*,ngx_chain_t*)"
147558,METHOD,http\modules\ngx_http_gzip_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_gzip_filter_deflate_start(ngx_http_request_t *r,
    ngx_http_gzip_ctx_t *ctx)
{
    int                    rc;
    ngx_http_gzip_conf_t  *conf;

    conf = ngx_http_get_module_loc_conf(r, ngx_http_gzip_filter_module);

    ctx->preallocated = ngx_palloc(r->pool, ctx->allocated);
    if (ctx->preallocated == NULL) {
        return NGX_ERROR;
    }

    ctx->free_mem = ctx->preallocated;

    ctx->zstream.zalloc = ngx_http_gzip_filter_alloc;
    ctx->zstream.zfree = ngx_http_gzip_filter_free;
    ctx->zstream.opaque = ctx;

    rc = deflateInit2(&ctx->zstream, (int) conf->level, Z_DEFLATED,
                      ctx->wbits + 16, ctx->memlevel, Z_DEFAULT_STRATEGY);

    if (rc != Z_OK) {
        ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,
                      ""deflateInit2() failed: %d"", rc);
        return NGX_ERROR;
    }

    ctx->last_out = &ctx->out;
    ctx->flush = Z_NO_FLUSH;

    return NGX_OK;
}",1,1,http\modules\ngx_http_gzip_filter_module.c,ngx_http_gzip_filter_deflate_start,,false,598,631,ngx_http_gzip_filter_deflate_start,,,43,"ngx_int_t ngx_http_gzip_filter_deflate_start (ngx_http_request_t*,ngx_http_gzip_ctx_t*)"
147673,METHOD,http\modules\ngx_http_gzip_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_gzip_filter_add_data(ngx_http_request_t *r, ngx_http_gzip_ctx_t *ctx)
{
    ngx_chain_t  *cl;

    if (ctx->zstream.avail_in || ctx->flush != Z_NO_FLUSH || ctx->redo) {
        return NGX_OK;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""gzip in: %p"", ctx->in);

    if (ctx->in == NULL) {
        return NGX_DECLINED;
    }

    if (ctx->copy_buf) {

        /*
         * to avoid CPU cache trashing we do not free() just quit buf,
         * but postpone free()ing after zlib compressing and data output
         */

        ctx->copy_buf->next = ctx->copied;
        ctx->copied = ctx->copy_buf;
        ctx->copy_buf = NULL;
    }

    cl = ctx->in;
    ctx->in_buf = cl->buf;
    ctx->in = cl->next;

    if (ctx->in_buf->tag == (ngx_buf_tag_t) &ngx_http_gzip_filter_module) {
        ctx->copy_buf = cl;

    } else {
        ngx_free_chain(r->pool, cl);
    }

    ctx->zstream.next_in = ctx->in_buf->pos;
    ctx->zstre...",1,1,http\modules\ngx_http_gzip_filter_module.c,ngx_http_gzip_filter_add_data,,false,634,693,ngx_http_gzip_filter_add_data,,,44,"ngx_int_t ngx_http_gzip_filter_add_data (ngx_http_request_t*,ngx_http_gzip_ctx_t*)"
147879,METHOD,http\modules\ngx_http_gzip_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_gzip_filter_get_buf(ngx_http_request_t *r, ngx_http_gzip_ctx_t *ctx)
{
    ngx_chain_t           *cl;
    ngx_http_gzip_conf_t  *conf;

    if (ctx->zstream.avail_out) {
        return NGX_OK;
    }

    conf = ngx_http_get_module_loc_conf(r, ngx_http_gzip_filter_module);

    if (ctx->free) {

        cl = ctx->free;
        ctx->out_buf = cl->buf;
        ctx->free = cl->next;

        ngx_free_chain(r->pool, cl);

    } else if (ctx->bufs < conf->bufs.num) {

        ctx->out_buf = ngx_create_temp_buf(r->pool, conf->bufs.size);
        if (ctx->out_buf == NULL) {
            return NGX_ERROR;
        }

        ctx->out_buf->tag = (ngx_buf_tag_t) &ngx_http_gzip_filter_module;
        ctx->out_buf->recycled = 1;
        ctx->bufs++;

    } else {
        ctx->nomem = 1;
        return NGX_DECLINED;
    }

    ctx->zstream.next_out = ctx->out_buf->pos;
    ctx->zstream.avail_out = conf->bufs.size;

    return NGX_OK;
}",1,1,http\modules\ngx_http_gzip_filter_module.c,ngx_http_gzip_filter_get_buf,,false,696,736,ngx_http_gzip_filter_get_buf,,,45,"ngx_int_t ngx_http_gzip_filter_get_buf (ngx_http_request_t*,ngx_http_gzip_ctx_t*)"
148018,METHOD,http\modules\ngx_http_gzip_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_gzip_filter_deflate(ngx_http_request_t *r, ngx_http_gzip_ctx_t *ctx)
{
    int                    rc;
    ngx_buf_t             *b;
    ngx_chain_t           *cl;
    ngx_http_gzip_conf_t  *conf;

    ngx_log_debug6(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                 ""deflate in: ni:%p no:%p ai:%ud ao:%ud fl:%d redo:%d"",
                 ctx->zstream.next_in, ctx->zstream.next_out,
                 ctx->zstream.avail_in, ctx->zstream.avail_out,
                 ctx->flush, ctx->redo);

    rc = deflate(&ctx->zstream, ctx->flush);

    if (rc != Z_OK && rc != Z_STREAM_END && rc != Z_BUF_ERROR) {
        ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,
                      ""deflate() failed: %d, %d"", ctx->flush, rc);
        return NGX_ERROR;
    }

    ngx_log_debug5(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""deflate out: ni:%p no:%p ai:%ud ao:%ud rc:%d"",
                   ctx->zstream.next_in, ctx->zstream.next_out,
        ...",1,1,http\modules\ngx_http_gzip_filter_module.c,ngx_http_gzip_filter_deflate,,false,739,863,ngx_http_gzip_filter_deflate,,,46,"ngx_int_t ngx_http_gzip_filter_deflate (ngx_http_request_t*,ngx_http_gzip_ctx_t*)"
148431,METHOD,http\modules\ngx_http_gzip_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_gzip_filter_deflate_end(ngx_http_request_t *r,
    ngx_http_gzip_ctx_t *ctx)
{
    int           rc;
    ngx_buf_t    *b;
    ngx_chain_t  *cl;

    ctx->zin = ctx->zstream.total_in;
    ctx->zout = ctx->zstream.total_out;

    rc = deflateEnd(&ctx->zstream);

    if (rc != Z_OK) {
        ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,
                      ""deflateEnd() failed: %d"", rc);
        return NGX_ERROR;
    }

    ngx_pfree(r->pool, ctx->preallocated);

    cl = ngx_alloc_chain_link(r->pool);
    if (cl == NULL) {
        return NGX_ERROR;
    }

    b = ctx->out_buf;

    if (ngx_buf_size(b) == 0) {
        b->temporary = 0;
    }

    b->last_buf = 1;

    cl->buf = b;
    cl->next = NULL;
    *ctx->last_out = cl;
    ctx->last_out = &cl->next;

    ctx->zstream.avail_in = 0;
    ctx->zstream.avail_out = 0;

    ctx->done = 1;

    r->connection->buffered &= ~NGX_HTTP_GZIP_BUFFERED;

    return NGX_OK;
}",1,1,http\modules\ngx_http_gzip_filter_module.c,ngx_http_gzip_filter_deflate_end,,false,866,913,ngx_http_gzip_filter_deflate_end,,,47,"ngx_int_t ngx_http_gzip_filter_deflate_end (ngx_http_request_t*,ngx_http_gzip_ctx_t*)"
148576,METHOD,http\modules\ngx_http_gzip_filter_module.c:<global>,TYPE_DECL,"static void *
ngx_http_gzip_filter_alloc(void *opaque, u_int items, u_int size)
{
    ngx_http_gzip_ctx_t *ctx = opaque;

    void        *p;
    ngx_uint_t   alloc;

    alloc = items * size;

    if (items == 1 && alloc % 512 != 0 && alloc < 8192) {

        /*
         * The zlib deflate_state allocation, it takes about 6K,
         * we allocate 8K.  Other allocations are divisible by 512.
         */

        alloc = 8192;
    }

    if (alloc <= ctx->allocated) {
        p = ctx->free_mem;
        ctx->free_mem += alloc;
        ctx->allocated -= alloc;

        ngx_log_debug4(NGX_LOG_DEBUG_HTTP, ctx->request->connection->log, 0,
                       ""gzip alloc: n:%ud s:%ud a:%ui p:%p"",
                       items, size, alloc, p);

        return p;
    }

    if (ctx->intel) {
        ngx_log_error(NGX_LOG_ALERT, ctx->request->connection->log, 0,
                      ""gzip filter failed to use preallocated memory: ""
                      ""%ud of %ui"", items * size, ctx-...",1,1,http\modules\ngx_http_gzip_filter_module.c,ngx_http_gzip_filter_alloc,,false,916,960,ngx_http_gzip_filter_alloc,,,48,"void* ngx_http_gzip_filter_alloc (void*,u_int,u_int)"
148691,METHOD,http\modules\ngx_http_gzip_filter_module.c:<global>,TYPE_DECL,"static void
ngx_http_gzip_filter_free(void *opaque, void *address)
{
#if 0
    ngx_http_gzip_ctx_t *ctx = opaque;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx->request->connection->log, 0,
                   ""gzip free: %p"", address);
#endif
}",1,1,http\modules\ngx_http_gzip_filter_module.c,ngx_http_gzip_filter_free,,false,963,972,ngx_http_gzip_filter_free,,,49,"void ngx_http_gzip_filter_free (void*,void*)"
148697,METHOD,http\modules\ngx_http_gzip_filter_module.c:<global>,TYPE_DECL,"static void
ngx_http_gzip_filter_free_copy_buf(ngx_http_request_t *r,
    ngx_http_gzip_ctx_t *ctx)
{
    ngx_chain_t  *cl;

    for (cl = ctx->copied; cl; cl = cl->next) {
        ngx_pfree(r->pool, cl->buf->start);
    }

    ctx->copied = NULL;
}",1,1,http\modules\ngx_http_gzip_filter_module.c,ngx_http_gzip_filter_free_copy_buf,,false,975,986,ngx_http_gzip_filter_free_copy_buf,,,50,"void ngx_http_gzip_filter_free_copy_buf (ngx_http_request_t*,ngx_http_gzip_ctx_t*)"
148732,METHOD,http\modules\ngx_http_gzip_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_gzip_add_variables(ngx_conf_t *cf)
{
    ngx_http_variable_t  *var;

    var = ngx_http_add_variable(cf, &ngx_http_gzip_ratio, NGX_HTTP_VAR_NOHASH);
    if (var == NULL) {
        return NGX_ERROR;
    }

    var->get_handler = ngx_http_gzip_ratio_variable;

    return NGX_OK;
}",1,1,http\modules\ngx_http_gzip_filter_module.c,ngx_http_gzip_add_variables,,false,989,1002,ngx_http_gzip_add_variables,,,51,ngx_int_t ngx_http_gzip_add_variables (ngx_conf_t*)
148759,METHOD,http\modules\ngx_http_gzip_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_gzip_ratio_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    ngx_uint_t            zint, zfrac;
    ngx_http_gzip_ctx_t  *ctx;

    ctx = ngx_http_get_module_ctx(r, ngx_http_gzip_filter_module);

    if (ctx == NULL || ctx->zout == 0) {
        v->not_found = 1;
        return NGX_OK;
    }

    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;

    v->data = ngx_pnalloc(r->pool, NGX_INT32_LEN + 3);
    if (v->data == NULL) {
        return NGX_ERROR;
    }

    zint = (ngx_uint_t) (ctx->zin / ctx->zout);
    zfrac = (ngx_uint_t) ((ctx->zin * 100 / ctx->zout) % 100);

    if ((ctx->zin * 1000 / ctx->zout) % 10 > 4) {

        /* the rounding, e.g., 2.125 to 2.13 */

        zfrac++;

        if (zfrac > 99) {
            zint++;
            zfrac = 0;
        }
    }

    v->len = ngx_sprintf(v->data, ""%ui.%02ui"", zint, zfrac) - v->data;

    return NGX_OK;
}",1,1,http\modules\ngx_http_gzip_filter_module.c,ngx_http_gzip_ratio_variable,,false,1005,1046,ngx_http_gzip_ratio_variable,,,52,"ngx_int_t ngx_http_gzip_ratio_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
148895,METHOD,http\modules\ngx_http_gzip_filter_module.c:<global>,TYPE_DECL,"static void *
ngx_http_gzip_create_conf(ngx_conf_t *cf)
{
    ngx_http_gzip_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_gzip_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     conf->bufs.num = 0;
     *     conf->types = { NULL };
     *     conf->types_keys = NULL;
     */

    conf->enable = NGX_CONF_UNSET;
    conf->no_buffer = NGX_CONF_UNSET;

    conf->postpone_gzipping = NGX_CONF_UNSET_SIZE;
    conf->level = NGX_CONF_UNSET;
    conf->wbits = NGX_CONF_UNSET_SIZE;
    conf->memlevel = NGX_CONF_UNSET_SIZE;
    conf->min_length = NGX_CONF_UNSET;

    return conf;
}",1,1,http\modules\ngx_http_gzip_filter_module.c,ngx_http_gzip_create_conf,,false,1049,1077,ngx_http_gzip_create_conf,,,53,void* ngx_http_gzip_create_conf (ngx_conf_t*)
148953,METHOD,http\modules\ngx_http_gzip_filter_module.c:<global>,TYPE_DECL,"static char *
ngx_http_gzip_merge_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_gzip_conf_t *prev = parent;
    ngx_http_gzip_conf_t *conf = child;

    ngx_conf_merge_value(conf->enable, prev->enable, 0);
    ngx_conf_merge_value(conf->no_buffer, prev->no_buffer, 0);

    ngx_conf_merge_bufs_value(conf->bufs, prev->bufs,
                              (128 * 1024) / ngx_pagesize, ngx_pagesize);

    ngx_conf_merge_size_value(conf->postpone_gzipping, prev->postpone_gzipping,
                              0);
    ngx_conf_merge_value(conf->level, prev->level, 1);
    ngx_conf_merge_size_value(conf->wbits, prev->wbits, MAX_WBITS);
    ngx_conf_merge_size_value(conf->memlevel, prev->memlevel,
                              MAX_MEM_LEVEL - 1);
    ngx_conf_merge_value(conf->min_length, prev->min_length, 20);

    if (ngx_http_merge_types(cf, &conf->types_keys, &conf->types,
                             &prev->types_keys, &prev->types,
                             ngx_http...",1,1,http\modules\ngx_http_gzip_filter_module.c,ngx_http_gzip_merge_conf,,false,1080,1109,ngx_http_gzip_merge_conf,,,54,"char* ngx_http_gzip_merge_conf (ngx_conf_t*,void*,void*)"
149066,METHOD,http\modules\ngx_http_gzip_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_gzip_filter_init(ngx_conf_t *cf)
{
    ngx_http_next_header_filter = ngx_http_top_header_filter;
    ngx_http_top_header_filter = ngx_http_gzip_header_filter;

    ngx_http_next_body_filter = ngx_http_top_body_filter;
    ngx_http_top_body_filter = ngx_http_gzip_body_filter;

    return NGX_OK;
}",1,1,http\modules\ngx_http_gzip_filter_module.c,ngx_http_gzip_filter_init,,false,1112,1122,ngx_http_gzip_filter_init,,,55,ngx_int_t ngx_http_gzip_filter_init (ngx_conf_t*)
149085,METHOD,http\modules\ngx_http_gzip_filter_module.c:<global>,TYPE_DECL,"static char *
ngx_http_gzip_window(ngx_conf_t *cf, void *post, void *data)
{
    size_t *np = data;

    size_t  wbits, wsize;

    wbits = 15;

    for (wsize = 32 * 1024; wsize > 256; wsize >>= 1) {

        if (wsize == *np) {
            *np = wbits;

            return NGX_CONF_OK;
        }

        wbits--;
    }

    return ""must be 512, 1k, 2k, 4k, 8k, 16k, or 32k"";
}",1,1,http\modules\ngx_http_gzip_filter_module.c,ngx_http_gzip_window,,false,1125,1146,ngx_http_gzip_window,,,56,"char* ngx_http_gzip_window (ngx_conf_t*,void*,void*)"
149131,METHOD,http\modules\ngx_http_gzip_filter_module.c:<global>,TYPE_DECL,"static char *
ngx_http_gzip_hash(ngx_conf_t *cf, void *post, void *data)
{
    size_t *np = data;

    size_t  memlevel, hsize;

    memlevel = 9;

    for (hsize = 128 * 1024; hsize > 256; hsize >>= 1) {

        if (hsize == *np) {
            *np = memlevel;

            return NGX_CONF_OK;
        }

        memlevel--;
    }

    return ""must be 512, 1k, 2k, 4k, 8k, 16k, 32k, 64k, or 128k"";
}",1,1,http\modules\ngx_http_gzip_filter_module.c,ngx_http_gzip_hash,,false,1149,1170,ngx_http_gzip_hash,,,57,"char* ngx_http_gzip_hash (ngx_conf_t*,void*,void*)"
149186,METHOD,http\modules\ngx_http_gzip_static_module.c:<global>,TYPE_DECL,<global>,1,25,http\modules\ngx_http_gzip_static_module.c,http\modules\ngx_http_gzip_static_module.c:<global>,,false,1,331,<global>,,,1,
149191,METHOD,http\modules\ngx_http_gzip_static_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_gzip_static_handler(ngx_http_request_t *r);,18,68,http\modules\ngx_http_gzip_static_module.c,ngx_http_gzip_static_handler,,false,23,23,ngx_http_gzip_static_handler,,,3,ngx_int_t ngx_http_gzip_static_handler (ngx_http_request_t*)
149196,METHOD,http\modules\ngx_http_gzip_static_module.c:<global>,TYPE_DECL,static void *ngx_http_gzip_static_create_conf(ngx_conf_t *cf);,13,61,http\modules\ngx_http_gzip_static_module.c,ngx_http_gzip_static_create_conf,,false,24,24,ngx_http_gzip_static_create_conf,,,4,void* ngx_http_gzip_static_create_conf (ngx_conf_t*)
149201,METHOD,http\modules\ngx_http_gzip_static_module.c:<global>,TYPE_DECL,"static char *ngx_http_gzip_static_merge_conf(ngx_conf_t *cf, void *parent,
    void *child);",13,16,http\modules\ngx_http_gzip_static_module.c,ngx_http_gzip_static_merge_conf,,false,25,26,ngx_http_gzip_static_merge_conf,,,5,"char* ngx_http_gzip_static_merge_conf (ngx_conf_t*,void*,void*)"
149208,METHOD,http\modules\ngx_http_gzip_static_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_gzip_static_init(ngx_conf_t *cf);,18,58,http\modules\ngx_http_gzip_static_module.c,ngx_http_gzip_static_init,,false,27,27,ngx_http_gzip_static_init,,,6,ngx_int_t ngx_http_gzip_static_init (ngx_conf_t*)
149289,METHOD,http\modules\ngx_http_gzip_static_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_gzip_static_handler(ngx_http_request_t *r)
{
    u_char                       *p;
    size_t                        root;
    ngx_str_t                     path;
    ngx_int_t                     rc;
    ngx_uint_t                    level;
    ngx_log_t                    *log;
    ngx_buf_t                    *b;
    ngx_chain_t                   out;
    ngx_table_elt_t              *h;
    ngx_open_file_info_t          of;
    ngx_http_core_loc_conf_t     *clcf;
    ngx_http_gzip_static_conf_t  *gzcf;

    if (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD))) {
        return NGX_DECLINED;
    }

    if (r->uri.data[r->uri.len - 1] == '/') {
        return NGX_DECLINED;
    }

    gzcf = ngx_http_get_module_loc_conf(r, ngx_http_gzip_static_module);

    if (gzcf->enable == NGX_HTTP_GZIP_STATIC_OFF) {
        return NGX_DECLINED;
    }

    if (gzcf->enable == NGX_HTTP_GZIP_STATIC_ON) {
        rc = ngx_http_gzip_ok(r);

    } else {
        /* always */
    ...",1,24,http\modules\ngx_http_gzip_static_module.c,ngx_http_gzip_static_handler,,false,82,283,ngx_http_gzip_static_handler,,,15,ngx_int_t ngx_http_gzip_static_handler (ngx_http_request_t*)
149867,METHOD,http\modules\ngx_http_gzip_static_module.c:<global>,TYPE_DECL,"static void *
ngx_http_gzip_static_create_conf(ngx_conf_t *cf)
{
    ngx_http_gzip_static_conf_t  *conf;

    conf = ngx_palloc(cf->pool, sizeof(ngx_http_gzip_static_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    conf->enable = NGX_CONF_UNSET_UINT;

    return conf;
}",1,1,http\modules\ngx_http_gzip_static_module.c,ngx_http_gzip_static_create_conf,,false,286,299,ngx_http_gzip_static_create_conf,,,16,void* ngx_http_gzip_static_create_conf (ngx_conf_t*)
149895,METHOD,http\modules\ngx_http_gzip_static_module.c:<global>,TYPE_DECL,"static char *
ngx_http_gzip_static_merge_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_gzip_static_conf_t *prev = parent;
    ngx_http_gzip_static_conf_t *conf = child;

    ngx_conf_merge_uint_value(conf->enable, prev->enable,
                              NGX_HTTP_GZIP_STATIC_OFF);

    return NGX_CONF_OK;
}",1,30,http\modules\ngx_http_gzip_static_module.c,ngx_http_gzip_static_merge_conf,,false,302,312,ngx_http_gzip_static_merge_conf,,,17,"char* ngx_http_gzip_static_merge_conf (ngx_conf_t*,void*,void*)"
149922,METHOD,http\modules\ngx_http_gzip_static_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_gzip_static_init(ngx_conf_t *cf)
{
    ngx_http_handler_pt        *h;
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);

    h = ngx_array_push(&cmcf->phases[NGX_HTTP_CONTENT_PHASE].handlers);
    if (h == NULL) {
        return NGX_ERROR;
    }

    *h = ngx_http_gzip_static_handler;

    return NGX_OK;
}",1,1,http\modules\ngx_http_gzip_static_module.c,ngx_http_gzip_static_init,,false,315,331,ngx_http_gzip_static_init,,,18,ngx_int_t ngx_http_gzip_static_init (ngx_conf_t*)
149967,METHOD,http\modules\ngx_http_headers_filter_module.c:<global>,TYPE_DECL,<global>,1,1,http\modules\ngx_http_headers_filter_module.c,http\modules\ngx_http_headers_filter_module.c:<global>,,false,1,867,<global>,,,1,
149971,METHOD,http\modules\ngx_http_headers_filter_module.c:<global>,TYPE_DECL,"typedef ngx_int_t (*ngx_http_set_header_pt)(ngx_http_request_t *r,
    ngx_http_header_val_t *hv, ngx_str_t *value);",19,48,http\modules\ngx_http_headers_filter_module.c,ngx_http_set_header_pt,,false,15,16,ngx_http_set_header_pt,,,3,"ngx_int_t ngx_http_set_header_pt (ngx_http_request_t*,ngx_http_header_val_t*,ngx_str_t*)"
150005,METHOD,http\modules\ngx_http_headers_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_set_expires(ngx_http_request_t *r,
    ngx_http_headers_conf_t *conf);",18,34,http\modules\ngx_http_headers_filter_module.c,ngx_http_set_expires,,false,55,56,ngx_http_set_expires,,,11,"ngx_int_t ngx_http_set_expires (ngx_http_request_t*,ngx_http_headers_conf_t*)"
150011,METHOD,http\modules\ngx_http_headers_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_parse_expires(ngx_str_t *value,
    ngx_http_expires_t *expires, time_t *expires_time, char **err);",18,66,http\modules\ngx_http_headers_filter_module.c,ngx_http_parse_expires,,false,57,58,ngx_http_parse_expires,,,12,"ngx_int_t ngx_http_parse_expires (ngx_str_t*,ngx_http_expires_t*,time_t*,char**)"
150019,METHOD,http\modules\ngx_http_headers_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_add_multi_header_lines(ngx_http_request_t *r,
    ngx_http_header_val_t *hv, ngx_str_t *value);",18,48,http\modules\ngx_http_headers_filter_module.c,ngx_http_add_multi_header_lines,,false,59,60,ngx_http_add_multi_header_lines,,,13,"ngx_int_t ngx_http_add_multi_header_lines (ngx_http_request_t*,ngx_http_header_val_t*,ngx_str_t*)"
150026,METHOD,http\modules\ngx_http_headers_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_add_header(ngx_http_request_t *r,
    ngx_http_header_val_t *hv, ngx_str_t *value);",18,48,http\modules\ngx_http_headers_filter_module.c,ngx_http_add_header,,false,61,62,ngx_http_add_header,,,14,"ngx_int_t ngx_http_add_header (ngx_http_request_t*,ngx_http_header_val_t*,ngx_str_t*)"
150033,METHOD,http\modules\ngx_http_headers_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_set_last_modified(ngx_http_request_t *r,
    ngx_http_header_val_t *hv, ngx_str_t *value);",18,48,http\modules\ngx_http_headers_filter_module.c,ngx_http_set_last_modified,,false,63,64,ngx_http_set_last_modified,,,15,"ngx_int_t ngx_http_set_last_modified (ngx_http_request_t*,ngx_http_header_val_t*,ngx_str_t*)"
150040,METHOD,http\modules\ngx_http_headers_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_set_response_header(ngx_http_request_t *r,
    ngx_http_header_val_t *hv, ngx_str_t *value);",18,48,http\modules\ngx_http_headers_filter_module.c,ngx_http_set_response_header,,false,65,66,ngx_http_set_response_header,,,16,"ngx_int_t ngx_http_set_response_header (ngx_http_request_t*,ngx_http_header_val_t*,ngx_str_t*)"
150047,METHOD,http\modules\ngx_http_headers_filter_module.c:<global>,TYPE_DECL,static void *ngx_http_headers_create_conf(ngx_conf_t *cf);,13,57,http\modules\ngx_http_headers_filter_module.c,ngx_http_headers_create_conf,,false,68,68,ngx_http_headers_create_conf,,,17,void* ngx_http_headers_create_conf (ngx_conf_t*)
150052,METHOD,http\modules\ngx_http_headers_filter_module.c:<global>,TYPE_DECL,"static char *ngx_http_headers_merge_conf(ngx_conf_t *cf,
    void *parent, void *child);",13,30,http\modules\ngx_http_headers_filter_module.c,ngx_http_headers_merge_conf,,false,69,70,ngx_http_headers_merge_conf,,,18,"char* ngx_http_headers_merge_conf (ngx_conf_t*,void*,void*)"
150059,METHOD,http\modules\ngx_http_headers_filter_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_headers_filter_init(ngx_conf_t *cf);,18,61,http\modules\ngx_http_headers_filter_module.c,ngx_http_headers_filter_init,,false,71,71,ngx_http_headers_filter_init,,,19,ngx_int_t ngx_http_headers_filter_init (ngx_conf_t*)
150064,METHOD,http\modules\ngx_http_headers_filter_module.c:<global>,TYPE_DECL,"static char *ngx_http_headers_expires(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_headers_filter_module.c,ngx_http_headers_expires,,false,72,73,ngx_http_headers_expires,,,20,"char* ngx_http_headers_expires (ngx_conf_t*,ngx_command_t*,void*)"
150071,METHOD,http\modules\ngx_http_headers_filter_module.c:<global>,TYPE_DECL,"static char *ngx_http_headers_add(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_headers_filter_module.c,ngx_http_headers_add,,false,74,75,ngx_http_headers_add,,,21,"char* ngx_http_headers_add (ngx_conf_t*,ngx_command_t*,void*)"
150202,METHOD,http\modules\ngx_http_headers_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_headers_filter(ngx_http_request_t *r)
{
    ngx_str_t                 value;
    ngx_uint_t                i, safe_status;
    ngx_http_header_val_t    *h;
    ngx_http_headers_conf_t  *conf;

    if (r != r->main) {
        return ngx_http_next_header_filter(r);
    }

    conf = ngx_http_get_module_loc_conf(r, ngx_http_headers_filter_module);

    if (conf->expires == NGX_HTTP_EXPIRES_OFF
        && conf->headers == NULL
        && conf->trailers == NULL)
    {
        return ngx_http_next_header_filter(r);
    }

    switch (r->headers_out.status) {

    case NGX_HTTP_OK:
    case NGX_HTTP_CREATED:
    case NGX_HTTP_NO_CONTENT:
    case NGX_HTTP_PARTIAL_CONTENT:
    case NGX_HTTP_MOVED_PERMANENTLY:
    case NGX_HTTP_MOVED_TEMPORARILY:
    case NGX_HTTP_SEE_OTHER:
    case NGX_HTTP_NOT_MODIFIED:
    case NGX_HTTP_TEMPORARY_REDIRECT:
    case NGX_HTTP_PERMANENT_REDIRECT:
        safe_status = 1;
        break;

    default:
        safe_status = 0;
       ...",1,1,http\modules\ngx_http_headers_filter_module.c,ngx_http_headers_filter,,false,165,244,ngx_http_headers_filter,,,32,ngx_int_t ngx_http_headers_filter (ngx_http_request_t*)
150425,METHOD,http\modules\ngx_http_headers_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_trailers_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    ngx_str_t                 value;
    ngx_uint_t                i, safe_status;
    ngx_chain_t              *cl;
    ngx_table_elt_t          *t;
    ngx_http_header_val_t    *h;
    ngx_http_headers_conf_t  *conf;

    conf = ngx_http_get_module_loc_conf(r, ngx_http_headers_filter_module);

    if (in == NULL
        || conf->trailers == NULL
        || !r->expect_trailers
        || r->header_only)
    {
        return ngx_http_next_body_filter(r, in);
    }

    for (cl = in; cl; cl = cl->next) {
        if (cl->buf->last_buf) {
            break;
        }
    }

    if (cl == NULL) {
        return ngx_http_next_body_filter(r, in);
    }

    switch (r->headers_out.status) {

    case NGX_HTTP_OK:
    case NGX_HTTP_CREATED:
    case NGX_HTTP_NO_CONTENT:
    case NGX_HTTP_PARTIAL_CONTENT:
    case NGX_HTTP_MOVED_PERMANENTLY:
    case NGX_HTTP_MOVED_TEMPORARILY:
    case NGX_HTTP_SEE_OTHER:
  ...",1,1,http\modules\ngx_http_headers_filter_module.c,ngx_http_trailers_filter,,false,247,321,ngx_http_trailers_filter,,,33,"ngx_int_t ngx_http_trailers_filter (ngx_http_request_t*,ngx_chain_t*)"
150626,METHOD,http\modules\ngx_http_headers_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_set_expires(ngx_http_request_t *r, ngx_http_headers_conf_t *conf)
{
    char                *err;
    size_t               len;
    time_t               now, expires_time, max_age;
    ngx_str_t            value;
    ngx_int_t            rc;
    ngx_uint_t           i;
    ngx_table_elt_t     *e, *cc, **ccp;
    ngx_http_expires_t   expires;

    expires = conf->expires;
    expires_time = conf->expires_time;

    if (conf->expires_value != NULL) {

        if (ngx_http_complex_value(r, conf->expires_value, &value) != NGX_OK) {
            return NGX_ERROR;
        }

        rc = ngx_http_parse_expires(&value, &expires, &expires_time, &err);

        if (rc != NGX_OK) {
            return NGX_OK;
        }

        if (expires == NGX_HTTP_EXPIRES_OFF) {
            return NGX_OK;
        }
    }

    e = r->headers_out.expires;

    if (e == NULL) {

        e = ngx_list_push(&r->headers_out.headers);
        if (e == NULL) {
            return NGX_ERROR;
...",1,1,http\modules\ngx_http_headers_filter_module.c,ngx_http_set_expires,,false,324,467,ngx_http_set_expires,,,34,"ngx_int_t ngx_http_set_expires (ngx_http_request_t*,ngx_http_headers_conf_t*)"
151094,METHOD,http\modules\ngx_http_headers_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_parse_expires(ngx_str_t *value, ngx_http_expires_t *expires,
    time_t *expires_time, char **err)
{
    ngx_uint_t  minus;

    if (*expires != NGX_HTTP_EXPIRES_MODIFIED) {

        if (value->len == 5 && ngx_strncmp(value->data, ""epoch"", 5) == 0) {
            *expires = NGX_HTTP_EXPIRES_EPOCH;
            return NGX_OK;
        }

        if (value->len == 3 && ngx_strncmp(value->data, ""max"", 3) == 0) {
            *expires = NGX_HTTP_EXPIRES_MAX;
            return NGX_OK;
        }

        if (value->len == 3 && ngx_strncmp(value->data, ""off"", 3) == 0) {
            *expires = NGX_HTTP_EXPIRES_OFF;
            return NGX_OK;
        }
    }

    if (value->len && value->data[0] == '@') {
        value->data++;
        value->len--;
        minus = 0;

        if (*expires == NGX_HTTP_EXPIRES_MODIFIED) {
            *err = ""daily time cannot be used with \""modified\"" parameter"";
            return NGX_ERROR;
        }

        *expires = NGX_HTTP_EXPIR...",1,1,http\modules\ngx_http_headers_filter_module.c,ngx_http_parse_expires,,false,470,539,ngx_http_parse_expires,,,35,"ngx_int_t ngx_http_parse_expires (ngx_str_t*,ngx_http_expires_t*,time_t*,char**)"
151324,METHOD,http\modules\ngx_http_headers_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_add_header(ngx_http_request_t *r, ngx_http_header_val_t *hv,
    ngx_str_t *value)
{
    ngx_table_elt_t  *h;

    if (value->len) {
        h = ngx_list_push(&r->headers_out.headers);
        if (h == NULL) {
            return NGX_ERROR;
        }

        h->hash = 1;
        h->key = hv->key;
        h->value = *value;
    }

    return NGX_OK;
}",1,1,http\modules\ngx_http_headers_filter_module.c,ngx_http_add_header,,false,542,560,ngx_http_add_header,,,36,"ngx_int_t ngx_http_add_header (ngx_http_request_t*,ngx_http_header_val_t*,ngx_str_t*)"
151373,METHOD,http\modules\ngx_http_headers_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_add_multi_header_lines(ngx_http_request_t *r,
    ngx_http_header_val_t *hv, ngx_str_t *value)
{
    ngx_array_t      *pa;
    ngx_table_elt_t  *h, **ph;

    if (value->len == 0) {
        return NGX_OK;
    }

    pa = (ngx_array_t *) ((char *) &r->headers_out + hv->offset);

    if (pa->elts == NULL) {
        if (ngx_array_init(pa, r->pool, 1, sizeof(ngx_table_elt_t *)) != NGX_OK)
        {
            return NGX_ERROR;
        }
    }

    h = ngx_list_push(&r->headers_out.headers);
    if (h == NULL) {
        return NGX_ERROR;
    }

    h->hash = 1;
    h->key = hv->key;
    h->value = *value;

    ph = ngx_array_push(pa);
    if (ph == NULL) {
        return NGX_ERROR;
    }

    *ph = h;

    return NGX_OK;
}",1,1,http\modules\ngx_http_headers_filter_module.c,ngx_http_add_multi_header_lines,,false,563,600,ngx_http_add_multi_header_lines,,,37,"ngx_int_t ngx_http_add_multi_header_lines (ngx_http_request_t*,ngx_http_header_val_t*,ngx_str_t*)"
151478,METHOD,http\modules\ngx_http_headers_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_set_last_modified(ngx_http_request_t *r, ngx_http_header_val_t *hv,
    ngx_str_t *value)
{
    if (ngx_http_set_response_header(r, hv, value) != NGX_OK) {
        return NGX_ERROR;
    }

    r->headers_out.last_modified_time =
        (value->len) ? ngx_parse_http_time(value->data, value->len) : -1;

    return NGX_OK;
}",1,1,http\modules\ngx_http_headers_filter_module.c,ngx_http_set_last_modified,,false,603,615,ngx_http_set_last_modified,,,38,"ngx_int_t ngx_http_set_last_modified (ngx_http_request_t*,ngx_http_header_val_t*,ngx_str_t*)"
151516,METHOD,http\modules\ngx_http_headers_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_set_response_header(ngx_http_request_t *r, ngx_http_header_val_t *hv,
    ngx_str_t *value)
{
    ngx_table_elt_t  *h, **old;

    old = (ngx_table_elt_t **) ((char *) &r->headers_out + hv->offset);

    if (value->len == 0) {
        if (*old) {
            (*old)->hash = 0;
            *old = NULL;
        }

        return NGX_OK;
    }

    if (*old) {
        h = *old;

    } else {
        h = ngx_list_push(&r->headers_out.headers);
        if (h == NULL) {
            return NGX_ERROR;
        }

        *old = h;
    }

    h->hash = 1;
    h->key = hv->key;
    h->value = *value;

    return NGX_OK;
}",1,1,http\modules\ngx_http_headers_filter_module.c,ngx_http_set_response_header,,false,618,652,ngx_http_set_response_header,,,39,"ngx_int_t ngx_http_set_response_header (ngx_http_request_t*,ngx_http_header_val_t*,ngx_str_t*)"
151612,METHOD,http\modules\ngx_http_headers_filter_module.c:<global>,TYPE_DECL,"static void *
ngx_http_headers_create_conf(ngx_conf_t *cf)
{
    ngx_http_headers_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_headers_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     conf->headers = NULL;
     *     conf->trailers = NULL;
     *     conf->expires_time = 0;
     *     conf->expires_value = NULL;
     */

    conf->expires = NGX_HTTP_EXPIRES_UNSET;

    return conf;
}",1,1,http\modules\ngx_http_headers_filter_module.c,ngx_http_headers_create_conf,,false,655,677,ngx_http_headers_create_conf,,,40,void* ngx_http_headers_create_conf (ngx_conf_t*)
151640,METHOD,http\modules\ngx_http_headers_filter_module.c:<global>,TYPE_DECL,"static char *
ngx_http_headers_merge_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_headers_conf_t *prev = parent;
    ngx_http_headers_conf_t *conf = child;

    if (conf->expires == NGX_HTTP_EXPIRES_UNSET) {
        conf->expires = prev->expires;
        conf->expires_time = prev->expires_time;
        conf->expires_value = prev->expires_value;

        if (conf->expires == NGX_HTTP_EXPIRES_UNSET) {
            conf->expires = NGX_HTTP_EXPIRES_OFF;
        }
    }

    if (conf->headers == NULL) {
        conf->headers = prev->headers;
    }

    if (conf->trailers == NULL) {
        conf->trailers = prev->trailers;
    }

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_headers_filter_module.c,ngx_http_headers_merge_conf,,false,680,705,ngx_http_headers_merge_conf,,,41,"char* ngx_http_headers_merge_conf (ngx_conf_t*,void*,void*)"
151725,METHOD,http\modules\ngx_http_headers_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_headers_filter_init(ngx_conf_t *cf)
{
    ngx_http_next_header_filter = ngx_http_top_header_filter;
    ngx_http_top_header_filter = ngx_http_headers_filter;

    ngx_http_next_body_filter = ngx_http_top_body_filter;
    ngx_http_top_body_filter = ngx_http_trailers_filter;

    return NGX_OK;
}",1,1,http\modules\ngx_http_headers_filter_module.c,ngx_http_headers_filter_init,,false,708,718,ngx_http_headers_filter_init,,,42,ngx_int_t ngx_http_headers_filter_init (ngx_conf_t*)
151744,METHOD,http\modules\ngx_http_headers_filter_module.c:<global>,TYPE_DECL,"static char *
ngx_http_headers_expires(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_headers_conf_t *hcf = conf;

    char                              *err;
    ngx_str_t                         *value;
    ngx_int_t                          rc;
    ngx_uint_t                         n;
    ngx_http_complex_value_t           cv;
    ngx_http_compile_complex_value_t   ccv;

    if (hcf->expires != NGX_HTTP_EXPIRES_UNSET) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    if (cf->args->nelts == 2) {

        hcf->expires = NGX_HTTP_EXPIRES_ACCESS;

        n = 1;

    } else { /* cf->args->nelts == 3 */

        if (ngx_strcmp(value[1].data, ""modified"") != 0) {
            return ""invalid value"";
        }

        hcf->expires = NGX_HTTP_EXPIRES_MODIFIED;

        n = 2;
    }

    ngx_memzero(&ccv, sizeof(ngx_http_compile_complex_value_t));

    ccv.cf = cf;
    ccv.value = &value[n];
    ccv.complex_value = &cv;

    if (ngx_http_compile_comp...",1,1,http\modules\ngx_http_headers_filter_module.c,ngx_http_headers_expires,,false,721,786,ngx_http_headers_expires,,,43,"char* ngx_http_headers_expires (ngx_conf_t*,ngx_command_t*,void*)"
151910,METHOD,http\modules\ngx_http_headers_filter_module.c:<global>,TYPE_DECL,"static char *
ngx_http_headers_add(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_headers_conf_t *hcf = conf;

    ngx_str_t                          *value;
    ngx_uint_t                          i;
    ngx_array_t                       **headers;
    ngx_http_header_val_t              *hv;
    ngx_http_set_header_t              *set;
    ngx_http_compile_complex_value_t    ccv;

    value = cf->args->elts;

    headers = (ngx_array_t **) ((char *) hcf + cmd->offset);

    if (*headers == NULL) {
        *headers = ngx_array_create(cf->pool, 1,
                                    sizeof(ngx_http_header_val_t));
        if (*headers == NULL) {
            return NGX_CONF_ERROR;
        }
    }

    hv = ngx_array_push(*headers);
    if (hv == NULL) {
        return NGX_CONF_ERROR;
    }

    hv->key = value[1];
    hv->handler = NULL;
    hv->offset = 0;
    hv->always = 0;

    if (headers == &hcf->headers) {
        hv->handler = ngx_http_add_header;

        set ...",1,1,http\modules\ngx_http_headers_filter_module.c,ngx_http_headers_add,,false,789,867,ngx_http_headers_add,,,44,"char* ngx_http_headers_add (ngx_conf_t*,ngx_command_t*,void*)"
152175,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,<global>,1,24,http\modules\ngx_http_image_filter_module.c,http\modules\ngx_http_image_filter_module.c:<global>,,false,1,1675,<global>,,,1,
152208,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_image_send(ngx_http_request_t *r,
    ngx_http_image_filter_ctx_t *ctx, ngx_chain_t *in);",18,54,http\modules\ngx_http_image_filter_module.c,ngx_http_image_send,,false,81,82,ngx_http_image_send,,,5,"ngx_int_t ngx_http_image_send (ngx_http_request_t*,ngx_http_image_filter_ctx_t*,ngx_chain_t*)"
152215,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static ngx_uint_t ngx_http_image_test(ngx_http_request_t *r, ngx_chain_t *in);",19,77,http\modules\ngx_http_image_filter_module.c,ngx_http_image_test,,false,83,83,ngx_http_image_test,,,6,"ngx_uint_t ngx_http_image_test (ngx_http_request_t*,ngx_chain_t*)"
152221,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_image_read(ngx_http_request_t *r, ngx_chain_t *in);",18,76,http\modules\ngx_http_image_filter_module.c,ngx_http_image_read,,false,84,84,ngx_http_image_read,,,7,"ngx_int_t ngx_http_image_read (ngx_http_request_t*,ngx_chain_t*)"
152227,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,static ngx_buf_t *ngx_http_image_process(ngx_http_request_t *r);,18,63,http\modules\ngx_http_image_filter_module.c,ngx_http_image_process,,false,85,85,ngx_http_image_process,,,8,ngx_buf_t* ngx_http_image_process (ngx_http_request_t*)
152232,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static ngx_buf_t *ngx_http_image_json(ngx_http_request_t *r,
    ngx_http_image_filter_ctx_t *ctx);",18,37,http\modules\ngx_http_image_filter_module.c,ngx_http_image_json,,false,86,87,ngx_http_image_json,,,9,"ngx_buf_t* ngx_http_image_json (ngx_http_request_t*,ngx_http_image_filter_ctx_t*)"
152238,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static ngx_buf_t *ngx_http_image_asis(ngx_http_request_t *r,
    ngx_http_image_filter_ctx_t *ctx);",18,37,http\modules\ngx_http_image_filter_module.c,ngx_http_image_asis,,false,88,89,ngx_http_image_asis,,,10,"ngx_buf_t* ngx_http_image_asis (ngx_http_request_t*,ngx_http_image_filter_ctx_t*)"
152244,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static void ngx_http_image_length(ngx_http_request_t *r, ngx_buf_t *b);",13,70,http\modules\ngx_http_image_filter_module.c,ngx_http_image_length,,false,90,90,ngx_http_image_length,,,11,"void ngx_http_image_length (ngx_http_request_t*,ngx_buf_t*)"
152250,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_image_size(ngx_http_request_t *r,
    ngx_http_image_filter_ctx_t *ctx);",18,37,http\modules\ngx_http_image_filter_module.c,ngx_http_image_size,,false,91,92,ngx_http_image_size,,,12,"ngx_int_t ngx_http_image_size (ngx_http_request_t*,ngx_http_image_filter_ctx_t*)"
152256,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static ngx_buf_t *ngx_http_image_resize(ngx_http_request_t *r,
    ngx_http_image_filter_ctx_t *ctx);",18,37,http\modules\ngx_http_image_filter_module.c,ngx_http_image_resize,,false,94,95,ngx_http_image_resize,,,13,"ngx_buf_t* ngx_http_image_resize (ngx_http_request_t*,ngx_http_image_filter_ctx_t*)"
152262,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static gdImagePtr ngx_http_image_source(ngx_http_request_t *r,
    ngx_http_image_filter_ctx_t *ctx);",19,37,http\modules\ngx_http_image_filter_module.c,ngx_http_image_source,,false,96,97,ngx_http_image_source,,,14,"gdImagePtr ngx_http_image_source (ngx_http_request_t*,ngx_http_image_filter_ctx_t*)"
152268,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static gdImagePtr ngx_http_image_new(ngx_http_request_t *r, int w, int h,
    int colors);",19,15,http\modules\ngx_http_image_filter_module.c,ngx_http_image_new,,false,98,99,ngx_http_image_new,,,15,"gdImagePtr ngx_http_image_new (ngx_http_request_t*,int,int,int)"
152276,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static u_char *ngx_http_image_out(ngx_http_request_t *r, ngx_uint_t type,
    gdImagePtr img, int *size);",15,30,http\modules\ngx_http_image_filter_module.c,ngx_http_image_out,,false,100,101,ngx_http_image_out,,,16,"u_char* ngx_http_image_out (ngx_http_request_t*,ngx_uint_t,gdImagePtr,int*)"
152284,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,static void ngx_http_image_cleanup(void *data);,13,46,http\modules\ngx_http_image_filter_module.c,ngx_http_image_cleanup,,false,102,102,ngx_http_image_cleanup,,,17,void ngx_http_image_cleanup (void*)
152289,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static ngx_uint_t ngx_http_image_filter_get_value(ngx_http_request_t *r,
    ngx_http_complex_value_t *cv, ngx_uint_t v);",19,47,http\modules\ngx_http_image_filter_module.c,ngx_http_image_filter_get_value,,false,103,104,ngx_http_image_filter_get_value,,,18,"ngx_uint_t ngx_http_image_filter_get_value (ngx_http_request_t*,ngx_http_complex_value_t*,ngx_uint_t)"
152296,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,static ngx_uint_t ngx_http_image_filter_value(ngx_str_t *value);,19,63,http\modules\ngx_http_image_filter_module.c,ngx_http_image_filter_value,,false,105,105,ngx_http_image_filter_value,,,19,ngx_uint_t ngx_http_image_filter_value (ngx_str_t*)
152301,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,static void *ngx_http_image_filter_create_conf(ngx_conf_t *cf);,13,62,http\modules\ngx_http_image_filter_module.c,ngx_http_image_filter_create_conf,,false,108,108,ngx_http_image_filter_create_conf,,,20,void* ngx_http_image_filter_create_conf (ngx_conf_t*)
152306,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static char *ngx_http_image_filter_merge_conf(ngx_conf_t *cf, void *parent,
    void *child);",13,16,http\modules\ngx_http_image_filter_module.c,ngx_http_image_filter_merge_conf,,false,109,110,ngx_http_image_filter_merge_conf,,,21,"char* ngx_http_image_filter_merge_conf (ngx_conf_t*,void*,void*)"
152313,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static char *ngx_http_image_filter(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_image_filter_module.c,ngx_http_image_filter,,false,111,112,ngx_http_image_filter,,,22,"char* ngx_http_image_filter (ngx_conf_t*,ngx_command_t*,void*)"
152320,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static char *ngx_http_image_filter_jpeg_quality(ngx_conf_t *cf,
    ngx_command_t *cmd, void *conf);",13,35,http\modules\ngx_http_image_filter_module.c,ngx_http_image_filter_jpeg_quality,,false,113,114,ngx_http_image_filter_jpeg_quality,,,23,"char* ngx_http_image_filter_jpeg_quality (ngx_conf_t*,ngx_command_t*,void*)"
152327,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static char *ngx_http_image_filter_webp_quality(ngx_conf_t *cf,
    ngx_command_t *cmd, void *conf);",13,35,http\modules\ngx_http_image_filter_module.c,ngx_http_image_filter_webp_quality,,false,115,116,ngx_http_image_filter_webp_quality,,,24,"char* ngx_http_image_filter_webp_quality (ngx_conf_t*,ngx_command_t*,void*)"
152334,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static char *ngx_http_image_filter_sharpen(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_image_filter_module.c,ngx_http_image_filter_sharpen,,false,117,118,ngx_http_image_filter_sharpen,,,25,"char* ngx_http_image_filter_sharpen (ngx_conf_t*,ngx_command_t*,void*)"
152341,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_image_filter_init(ngx_conf_t *cf);,18,59,http\modules\ngx_http_image_filter_module.c,ngx_http_image_filter_init,,false,119,119,ngx_http_image_filter_init,,,26,ngx_int_t ngx_http_image_filter_init (ngx_conf_t*)
152494,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_image_header_filter(ngx_http_request_t *r)
{
    off_t                          len;
    ngx_http_image_filter_ctx_t   *ctx;
    ngx_http_image_filter_conf_t  *conf;

    if (r->headers_out.status == NGX_HTTP_NOT_MODIFIED) {
        return ngx_http_next_header_filter(r);
    }

    ctx = ngx_http_get_module_ctx(r, ngx_http_image_filter_module);

    if (ctx) {
        ngx_http_set_ctx(r, NULL, ngx_http_image_filter_module);
        return ngx_http_next_header_filter(r);
    }

    conf = ngx_http_get_module_loc_conf(r, ngx_http_image_filter_module);

    if (conf->filter == NGX_HTTP_IMAGE_OFF) {
        return ngx_http_next_header_filter(r);
    }

    if (r->headers_out.content_type.len
            >= sizeof(""multipart/x-mixed-replace"") - 1
        && ngx_strncasecmp(r->headers_out.content_type.data,
                           (u_char *) ""multipart/x-mixed-replace"",
                           sizeof(""multipart/x-mixed-replace"") - 1)
           == 0)
    {
...",1,24,http\modules\ngx_http_image_filter_module.c,ngx_http_image_header_filter,,false,220,288,ngx_http_image_header_filter,,,37,ngx_int_t ngx_http_image_header_filter (ngx_http_request_t*)
152691,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_image_body_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    ngx_int_t                      rc;
    ngx_str_t                     *ct;
    ngx_chain_t                    out;
    ngx_http_image_filter_ctx_t   *ctx;
    ngx_http_image_filter_conf_t  *conf;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, ""image filter"");

    if (in == NULL) {
        return ngx_http_next_body_filter(r, in);
    }

    ctx = ngx_http_get_module_ctx(r, ngx_http_image_filter_module);

    if (ctx == NULL) {
        return ngx_http_next_body_filter(r, in);
    }

    switch (ctx->phase) {

    case NGX_HTTP_IMAGE_START:

        ctx->type = ngx_http_image_test(r, in);

        conf = ngx_http_get_module_loc_conf(r, ngx_http_image_filter_module);

        if (ctx->type == NGX_HTTP_IMAGE_NONE) {

            if (conf->filter == NGX_HTTP_IMAGE_SIZE) {
                out.buf = ngx_http_image_json(r, NULL);

                if (out.buf) {
                    out.ne...",1,9,http\modules\ngx_http_image_filter_module.c,ngx_http_image_body_filter,,false,291,397,ngx_http_image_body_filter,,,38,"ngx_int_t ngx_http_image_body_filter (ngx_http_request_t*,ngx_chain_t*)"
152960,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_image_send(ngx_http_request_t *r, ngx_http_image_filter_ctx_t *ctx,
    ngx_chain_t *in)
{
    ngx_int_t  rc;

    rc = ngx_http_next_header_filter(r);

    if (rc == NGX_ERROR || rc > NGX_OK || r->header_only) {
        return NGX_ERROR;
    }

    rc = ngx_http_next_body_filter(r, in);

    if (ctx->phase == NGX_HTTP_IMAGE_DONE) {
        /* NGX_ERROR resets any pending data */
        return (rc == NGX_OK) ? NGX_ERROR : rc;
    }

    return rc;
}",1,22,http\modules\ngx_http_image_filter_module.c,ngx_http_image_send,,false,400,420,ngx_http_image_send,,,39,"ngx_int_t ngx_http_image_send (ngx_http_request_t*,ngx_http_image_filter_ctx_t*,ngx_chain_t*)"
153010,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static ngx_uint_t
ngx_http_image_test(ngx_http_request_t *r, ngx_chain_t *in)
{
    u_char  *p;

    p = in->buf->pos;

    if (in->buf->last - p < 16) {
        return NGX_HTTP_IMAGE_NONE;
    }

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""image filter: \""%c%c\"""", p[0], p[1]);

    if (p[0] == 0xff && p[1] == 0xd8) {

        /* JPEG */

        return NGX_HTTP_IMAGE_JPEG;

    } else if (p[0] == 'G' && p[1] == 'I' && p[2] == 'F' && p[3] == '8'
               && p[5] == 'a')
    {
        if (p[4] == '9' || p[4] == '7') {
            /* GIF */
            return NGX_HTTP_IMAGE_GIF;
        }

    } else if (p[0] == 0x89 && p[1] == 'P' && p[2] == 'N' && p[3] == 'G'
               && p[4] == 0x0d && p[5] == 0x0a && p[6] == 0x1a && p[7] == 0x0a)
    {
        /* PNG */

        return NGX_HTTP_IMAGE_PNG;

    } else if (p[0] == 'R' && p[1] == 'I' && p[2] == 'F' && p[3] == 'F'
               && p[8] == 'W' && p[9] == 'E' && p[10] == 'B' && p[11] ==...",1,15,http\modules\ngx_http_image_filter_module.c,ngx_http_image_test,,false,423,467,ngx_http_image_test,,,40,"ngx_uint_t ngx_http_image_test (ngx_http_request_t*,ngx_chain_t*)"
153235,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_image_read(ngx_http_request_t *r, ngx_chain_t *in)
{
    u_char                       *p;
    size_t                        size, rest;
    ngx_buf_t                    *b;
    ngx_chain_t                  *cl;
    ngx_http_image_filter_ctx_t  *ctx;

    ctx = ngx_http_get_module_ctx(r, ngx_http_image_filter_module);

    if (ctx->image == NULL) {
        ctx->image = ngx_palloc(r->pool, ctx->length);
        if (ctx->image == NULL) {
            return NGX_ERROR;
        }

        ctx->last = ctx->image;
    }

    p = ctx->last;

    for (cl = in; cl; cl = cl->next) {

        b = cl->buf;
        size = b->last - b->pos;

        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                       ""image buf: %uz"", size);

        rest = ctx->image + ctx->length - p;

        if (size > rest) {
            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                          ""image filter: too big response"");
            return NGX_ERR...",1,31,http\modules\ngx_http_image_filter_module.c,ngx_http_image_read,,false,470,521,ngx_http_image_read,,,41,"ngx_int_t ngx_http_image_read (ngx_http_request_t*,ngx_chain_t*)"
153395,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static ngx_buf_t *
ngx_http_image_process(ngx_http_request_t *r)
{
    ngx_int_t                      rc;
    ngx_http_image_filter_ctx_t   *ctx;
    ngx_http_image_filter_conf_t  *conf;

    r->connection->buffered &= ~NGX_HTTP_IMAGE_BUFFERED;

    ctx = ngx_http_get_module_ctx(r, ngx_http_image_filter_module);

    rc = ngx_http_image_size(r, ctx);

    conf = ngx_http_get_module_loc_conf(r, ngx_http_image_filter_module);

    if (conf->filter == NGX_HTTP_IMAGE_SIZE) {
        return ngx_http_image_json(r, rc == NGX_OK ? ctx : NULL);
    }

    ctx->angle = ngx_http_image_filter_get_value(r, conf->acv, conf->angle);

    if (conf->filter == NGX_HTTP_IMAGE_ROTATE) {

        if (ctx->angle != 90 && ctx->angle != 180 && ctx->angle != 270) {
            return NULL;
        }

        return ngx_http_image_resize(r, ctx);
    }

    ctx->max_width = ngx_http_image_filter_get_value(r, conf->wcv, conf->width);
    if (ctx->max_width == 0) {
        return NULL;
    }

    ctx->max_heig...",1,32,http\modules\ngx_http_image_filter_module.c,ngx_http_image_process,,false,524,575,ngx_http_image_process,,,42,ngx_buf_t ngx_http_image_process (ngx_http_request_t*)
153574,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static ngx_buf_t *
ngx_http_image_json(ngx_http_request_t *r, ngx_http_image_filter_ctx_t *ctx)
{
    size_t      len;
    ngx_buf_t  *b;

    b = ngx_calloc_buf(r->pool);
    if (b == NULL) {
        return NULL;
    }

    b->memory = 1;
    b->last_buf = 1;

    ngx_http_clean_header(r);

    r->headers_out.status = NGX_HTTP_OK;
    r->headers_out.content_type_len = sizeof(""application/json"") - 1;
    ngx_str_set(&r->headers_out.content_type, ""application/json"");
    r->headers_out.content_type_lowcase = NULL;

    if (ctx == NULL) {
        b->pos = (u_char *) ""{}"" CRLF;
        b->last = b->pos + sizeof(""{}"" CRLF) - 1;

        ngx_http_image_length(r, b);

        return b;
    }

    len = sizeof(""{ \""img\"" : ""
                 ""{ \""width\"": , \""height\"": , \""type\"": \""jpeg\"" } }"" CRLF) - 1
          + 2 * NGX_SIZE_T_LEN;

    b->pos = ngx_pnalloc(r->pool, len);
    if (b->pos == NULL) {
        return NULL;
    }

    b->last = ngx_sprintf(b->pos,
                          ""...",1,1,http\modules\ngx_http_image_filter_module.c,ngx_http_image_json,,false,578,628,ngx_http_image_json,,,43,"ngx_buf_t ngx_http_image_json (ngx_http_request_t*,ngx_http_image_filter_ctx_t*)"
153684,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static ngx_buf_t *
ngx_http_image_asis(ngx_http_request_t *r, ngx_http_image_filter_ctx_t *ctx)
{
    ngx_buf_t  *b;

    b = ngx_calloc_buf(r->pool);
    if (b == NULL) {
        return NULL;
    }

    b->pos = ctx->image;
    b->last = ctx->last;
    b->memory = 1;
    b->last_buf = 1;

    ngx_http_image_length(r, b);

    return b;
}",1,1,http\modules\ngx_http_image_filter_module.c,ngx_http_image_asis,,false,631,649,ngx_http_image_asis,,,44,"ngx_buf_t ngx_http_image_asis (ngx_http_request_t*,ngx_http_image_filter_ctx_t*)"
153733,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static void
ngx_http_image_length(ngx_http_request_t *r, ngx_buf_t *b)
{
    r->headers_out.content_length_n = b->last - b->pos;

    if (r->headers_out.content_length) {
        r->headers_out.content_length->hash = 0;
    }

    r->headers_out.content_length = NULL;
}",1,1,http\modules\ngx_http_image_filter_module.c,ngx_http_image_length,,false,652,662,ngx_http_image_length,,,45,"void ngx_http_image_length (ngx_http_request_t*,ngx_buf_t*)"
153775,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_image_size(ngx_http_request_t *r, ngx_http_image_filter_ctx_t *ctx)
{
    u_char      *p, *last;
    size_t       len, app;
    ngx_uint_t   width, height;

    p = ctx->image;

    switch (ctx->type) {

    case NGX_HTTP_IMAGE_JPEG:

        p += 2;
        last = ctx->image + ctx->length - 10;
        width = 0;
        height = 0;
        app = 0;

        while (p < last) {

            if (p[0] == 0xff && p[1] != 0xff) {

                ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                               ""JPEG: %02xd %02xd"", p[0], p[1]);

                p++;

                if ((*p == 0xc0 || *p == 0xc1 || *p == 0xc2 || *p == 0xc3
                     || *p == 0xc9 || *p == 0xca || *p == 0xcb)
                    && (width == 0 || height == 0))
                {
                    width = p[6] * 256 + p[7];
                    height = p[4] * 256 + p[5];
                }

                ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->co...",1,9,http\modules\ngx_http_image_filter_module.c,ngx_http_image_size,,false,665,816,ngx_http_image_size,,,46,"ngx_int_t ngx_http_image_size (ngx_http_request_t*,ngx_http_image_filter_ctx_t*)"
154302,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static ngx_buf_t *
ngx_http_image_resize(ngx_http_request_t *r, ngx_http_image_filter_ctx_t *ctx)
{
    int                            sx, sy, dx, dy, ox, oy, ax, ay, size,
                                   colors, palette, transparent, sharpen,
                                   red, green, blue, t;
    u_char                        *out;
    ngx_buf_t                     *b;
    ngx_uint_t                     resize;
    gdImagePtr                     src, dst;
    ngx_pool_cleanup_t            *cln;
    ngx_http_image_filter_conf_t  *conf;

    src = ngx_http_image_source(r, ctx);

    if (src == NULL) {
        return NULL;
    }

    sx = gdImageSX(src);
    sy = gdImageSY(src);

    conf = ngx_http_get_module_loc_conf(r, ngx_http_image_filter_module);

    if (!ctx->force
        && ctx->angle == 0
        && (ngx_uint_t) sx <= ctx->max_width
        && (ngx_uint_t) sy <= ctx->max_height)
    {
        gdImageDestroy(src);
        return ngx_http_image_asis(r, ctx);
    }

  ...",1,24,http\modules\ngx_http_image_filter_module.c,ngx_http_image_resize,,false,819,1088,ngx_http_image_resize,,,47,"ngx_buf_t ngx_http_image_resize (ngx_http_request_t*,ngx_http_image_filter_ctx_t*)"
155127,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static gdImagePtr
ngx_http_image_source(ngx_http_request_t *r, ngx_http_image_filter_ctx_t *ctx)
{
    char        *failed;
    gdImagePtr   img;

    img = NULL;

    switch (ctx->type) {

    case NGX_HTTP_IMAGE_JPEG:
        img = gdImageCreateFromJpegPtr(ctx->length, ctx->image);
        failed = ""gdImageCreateFromJpegPtr() failed"";
        break;

    case NGX_HTTP_IMAGE_GIF:
        img = gdImageCreateFromGifPtr(ctx->length, ctx->image);
        failed = ""gdImageCreateFromGifPtr() failed"";
        break;

    case NGX_HTTP_IMAGE_PNG:
        img = gdImageCreateFromPngPtr(ctx->length, ctx->image);
        failed = ""gdImageCreateFromPngPtr() failed"";
        break;

    case NGX_HTTP_IMAGE_WEBP:
#if (NGX_HAVE_GD_WEBP)
        img = gdImageCreateFromWebpPtr(ctx->length, ctx->image);
        failed = ""gdImageCreateFromWebpPtr() failed"";
#else
        failed = ""nginx was built without GD WebP support"";
#endif
        break;

    default:
        failed = ""unknown image type"";
     ...",1,9,http\modules\ngx_http_image_filter_module.c,ngx_http_image_source,,false,1091,1135,ngx_http_image_source,,,48,"gdImagePtr ngx_http_image_source (ngx_http_request_t*,ngx_http_image_filter_ctx_t*)"
155223,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static gdImagePtr
ngx_http_image_new(ngx_http_request_t *r, int w, int h, int colors)
{
    gdImagePtr  img;

    if (colors == 0) {
        img = gdImageCreateTrueColor(w, h);

        if (img == NULL) {
            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                          ""gdImageCreateTrueColor() failed"");
            return NULL;
        }

    } else {
        img = gdImageCreate(w, h);

        if (img == NULL) {
            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                          ""gdImageCreate() failed"");
            return NULL;
        }
    }

    return img;
}",1,1,http\modules\ngx_http_image_filter_module.c,ngx_http_image_new,,false,1138,1163,ngx_http_image_new,,,49,"gdImagePtr ngx_http_image_new (ngx_http_request_t*,int,int,int)"
155283,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static u_char *
ngx_http_image_out(ngx_http_request_t *r, ngx_uint_t type, gdImagePtr img,
    int *size)
{
    char                          *failed;
    u_char                        *out;
    ngx_int_t                      q;
    ngx_http_image_filter_conf_t  *conf;

    out = NULL;

    switch (type) {

    case NGX_HTTP_IMAGE_JPEG:
        conf = ngx_http_get_module_loc_conf(r, ngx_http_image_filter_module);

        q = ngx_http_image_filter_get_value(r, conf->jqcv, conf->jpeg_quality);
        if (q <= 0) {
            return NULL;
        }

        out = gdImageJpegPtr(img, size, q);
        failed = ""gdImageJpegPtr() failed"";
        break;

    case NGX_HTTP_IMAGE_GIF:
        out = gdImageGifPtr(img, size);
        failed = ""gdImageGifPtr() failed"";
        break;

    case NGX_HTTP_IMAGE_PNG:
        out = gdImagePngPtr(img, size);
        failed = ""gdImagePngPtr() failed"";
        break;

    case NGX_HTTP_IMAGE_WEBP:
#if (NGX_HAVE_GD_WEBP)
        conf = ngx_http_get_...",1,9,http\modules\ngx_http_image_filter_module.c,ngx_http_image_out,,false,1166,1227,ngx_http_image_out,,,50,"u_char ngx_http_image_out (ngx_http_request_t*,ngx_uint_t,gdImagePtr,int*)"
155392,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static void
ngx_http_image_cleanup(void *data)
{
    gdFree(data);
}",1,1,http\modules\ngx_http_image_filter_module.c,ngx_http_image_cleanup,,false,1230,1234,ngx_http_image_cleanup,,,51,void ngx_http_image_cleanup (void*)
155399,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static ngx_uint_t
ngx_http_image_filter_get_value(ngx_http_request_t *r,
    ngx_http_complex_value_t *cv, ngx_uint_t v)
{
    ngx_str_t  val;

    if (cv == NULL) {
        return v;
    }

    if (ngx_http_complex_value(r, cv, &val) != NGX_OK) {
        return 0;
    }

    return ngx_http_image_filter_value(&val);
}",1,1,http\modules\ngx_http_image_filter_module.c,ngx_http_image_filter_get_value,,false,1237,1252,ngx_http_image_filter_get_value,,,52,"ngx_uint_t ngx_http_image_filter_get_value (ngx_http_request_t*,ngx_http_complex_value_t*,ngx_uint_t)"
155429,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static ngx_uint_t
ngx_http_image_filter_value(ngx_str_t *value)
{
    ngx_int_t  n;

    if (value->len == 1 && value->data[0] == '-') {
        return (ngx_uint_t) -1;
    }

    n = ngx_atoi(value->data, value->len);

    if (n > 0) {
        return (ngx_uint_t) n;
    }

    return 0;
}",1,1,http\modules\ngx_http_image_filter_module.c,ngx_http_image_filter_value,,false,1255,1271,ngx_http_image_filter_value,,,53,ngx_uint_t ngx_http_image_filter_value (ngx_str_t*)
155474,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static void *
ngx_http_image_filter_create_conf(ngx_conf_t *cf)
{
    ngx_http_image_filter_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_image_filter_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     conf->width = 0;
     *     conf->height = 0;
     *     conf->angle = 0;
     *     conf->wcv = NULL;
     *     conf->hcv = NULL;
     *     conf->acv = NULL;
     *     conf->jqcv = NULL;
     *     conf->wqcv = NULL;
     *     conf->shcv = NULL;
     */

    conf->filter = NGX_CONF_UNSET_UINT;
    conf->jpeg_quality = NGX_CONF_UNSET_UINT;
    conf->webp_quality = NGX_CONF_UNSET_UINT;
    conf->sharpen = NGX_CONF_UNSET_UINT;
    conf->transparency = NGX_CONF_UNSET;
    conf->interlace = NGX_CONF_UNSET;
    conf->buffer_size = NGX_CONF_UNSET_SIZE;

    return conf;
}",1,1,http\modules\ngx_http_image_filter_module.c,ngx_http_image_filter_create_conf,,false,1274,1307,ngx_http_image_filter_create_conf,,,54,void* ngx_http_image_filter_create_conf (ngx_conf_t*)
155532,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static char *
ngx_http_image_filter_merge_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_image_filter_conf_t *prev = parent;
    ngx_http_image_filter_conf_t *conf = child;

    if (conf->filter == NGX_CONF_UNSET_UINT) {

        if (prev->filter == NGX_CONF_UNSET_UINT) {
            conf->filter = NGX_HTTP_IMAGE_OFF;

        } else {
            conf->filter = prev->filter;
            conf->width = prev->width;
            conf->height = prev->height;
            conf->angle = prev->angle;
            conf->wcv = prev->wcv;
            conf->hcv = prev->hcv;
            conf->acv = prev->acv;
        }
    }

    if (conf->jpeg_quality == NGX_CONF_UNSET_UINT) {

        /* 75 is libjpeg default quality */
        ngx_conf_merge_uint_value(conf->jpeg_quality, prev->jpeg_quality, 75);

        if (conf->jqcv == NULL) {
            conf->jqcv = prev->jqcv;
        }
    }

    if (conf->webp_quality == NGX_CONF_UNSET_UINT) {

        /* 80 is libwebp default quality ...",1,27,http\modules\ngx_http_image_filter_module.c,ngx_http_image_filter_merge_conf,,false,1310,1368,ngx_http_image_filter_merge_conf,,,55,"char* ngx_http_image_filter_merge_conf (ngx_conf_t*,void*,void*)"
155736,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static char *
ngx_http_image_filter(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_image_filter_conf_t *imcf = conf;

    ngx_str_t                         *value;
    ngx_int_t                          n;
    ngx_uint_t                         i;
    ngx_http_complex_value_t           cv;
    ngx_http_compile_complex_value_t   ccv;

    value = cf->args->elts;

    i = 1;

    if (cf->args->nelts == 2) {
        if (ngx_strcmp(value[i].data, ""off"") == 0) {
            imcf->filter = NGX_HTTP_IMAGE_OFF;

        } else if (ngx_strcmp(value[i].data, ""test"") == 0) {
            imcf->filter = NGX_HTTP_IMAGE_TEST;

        } else if (ngx_strcmp(value[i].data, ""size"") == 0) {
            imcf->filter = NGX_HTTP_IMAGE_SIZE;

        } else {
            goto failed;
        }

        return NGX_CONF_OK;

    } else if (cf->args->nelts == 3) {

        if (ngx_strcmp(value[i].data, ""rotate"") == 0) {
            if (imcf->filter != NGX_HTTP_IMAGE_RESIZE
                && ...",1,27,http\modules\ngx_http_image_filter_module.c,ngx_http_image_filter,,false,1371,1521,ngx_http_image_filter,,,56,"char* ngx_http_image_filter (ngx_conf_t*,ngx_command_t*,void*)"
156212,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static char *
ngx_http_image_filter_jpeg_quality(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf)
{
    ngx_http_image_filter_conf_t *imcf = conf;

    ngx_str_t                         *value;
    ngx_int_t                          n;
    ngx_http_complex_value_t           cv;
    ngx_http_compile_complex_value_t   ccv;

    value = cf->args->elts;

    ngx_memzero(&ccv, sizeof(ngx_http_compile_complex_value_t));

    ccv.cf = cf;
    ccv.value = &value[1];
    ccv.complex_value = &cv;

    if (ngx_http_compile_complex_value(&ccv) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    if (cv.lengths == NULL) {
        n = ngx_http_image_filter_value(&value[1]);

        if (n <= 0) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               ""invalid value \""%V\"""", &value[1]);
            return NGX_CONF_ERROR;
        }

        imcf->jpeg_quality = (ngx_uint_t) n;

    } else {
        imcf->jqcv = ngx_palloc(cf->pool, sizeof(ngx_http_complex_value_t))...",1,1,http\modules\ngx_http_image_filter_module.c,ngx_http_image_filter_jpeg_quality,,false,1524,1568,ngx_http_image_filter_jpeg_quality,,,57,"char* ngx_http_image_filter_jpeg_quality (ngx_conf_t*,ngx_command_t*,void*)"
156333,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static char *
ngx_http_image_filter_webp_quality(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf)
{
    ngx_http_image_filter_conf_t *imcf = conf;

    ngx_str_t                         *value;
    ngx_int_t                          n;
    ngx_http_complex_value_t           cv;
    ngx_http_compile_complex_value_t   ccv;

    value = cf->args->elts;

    ngx_memzero(&ccv, sizeof(ngx_http_compile_complex_value_t));

    ccv.cf = cf;
    ccv.value = &value[1];
    ccv.complex_value = &cv;

    if (ngx_http_compile_complex_value(&ccv) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    if (cv.lengths == NULL) {
        n = ngx_http_image_filter_value(&value[1]);

        if (n <= 0) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               ""invalid value \""%V\"""", &value[1]);
            return NGX_CONF_ERROR;
        }

        imcf->webp_quality = (ngx_uint_t) n;

    } else {
        imcf->wqcv = ngx_palloc(cf->pool, sizeof(ngx_http_complex_value_t))...",1,1,http\modules\ngx_http_image_filter_module.c,ngx_http_image_filter_webp_quality,,false,1571,1615,ngx_http_image_filter_webp_quality,,,58,"char* ngx_http_image_filter_webp_quality (ngx_conf_t*,ngx_command_t*,void*)"
156454,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static char *
ngx_http_image_filter_sharpen(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf)
{
    ngx_http_image_filter_conf_t *imcf = conf;

    ngx_str_t                         *value;
    ngx_int_t                          n;
    ngx_http_complex_value_t           cv;
    ngx_http_compile_complex_value_t   ccv;

    value = cf->args->elts;

    ngx_memzero(&ccv, sizeof(ngx_http_compile_complex_value_t));

    ccv.cf = cf;
    ccv.value = &value[1];
    ccv.complex_value = &cv;

    if (ngx_http_compile_complex_value(&ccv) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    if (cv.lengths == NULL) {
        n = ngx_http_image_filter_value(&value[1]);

        if (n < 0) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               ""invalid value \""%V\"""", &value[1]);
            return NGX_CONF_ERROR;
        }

        imcf->sharpen = (ngx_uint_t) n;

    } else {
        imcf->shcv = ngx_palloc(cf->pool, sizeof(ngx_http_complex_value_t));
        i...",1,1,http\modules\ngx_http_image_filter_module.c,ngx_http_image_filter_sharpen,,false,1618,1662,ngx_http_image_filter_sharpen,,,59,"char* ngx_http_image_filter_sharpen (ngx_conf_t*,ngx_command_t*,void*)"
156575,METHOD,http\modules\ngx_http_image_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_image_filter_init(ngx_conf_t *cf)
{
    ngx_http_next_header_filter = ngx_http_top_header_filter;
    ngx_http_top_header_filter = ngx_http_image_header_filter;

    ngx_http_next_body_filter = ngx_http_top_body_filter;
    ngx_http_top_body_filter = ngx_http_image_body_filter;

    return NGX_OK;
}",1,1,http\modules\ngx_http_image_filter_module.c,ngx_http_image_filter_init,,false,1665,1675,ngx_http_image_filter_init,,,60,ngx_int_t ngx_http_image_filter_init (ngx_conf_t*)
156603,METHOD,http\modules\ngx_http_index_module.c:<global>,TYPE_DECL,<global>,1,33,http\modules\ngx_http_index_module.c,http\modules\ngx_http_index_module.c:<global>,,false,1,540,<global>,,,1,
156614,METHOD,http\modules\ngx_http_index_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_index_test_dir(ngx_http_request_t *r,
    ngx_http_core_loc_conf_t *clcf, u_char *path, u_char *last);",18,63,http\modules\ngx_http_index_module.c,ngx_http_index_test_dir,,false,29,30,ngx_http_index_test_dir,,,5,"ngx_int_t ngx_http_index_test_dir (ngx_http_request_t*,ngx_http_core_loc_conf_t*,u_char*,u_char*)"
156622,METHOD,http\modules\ngx_http_index_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_index_error(ngx_http_request_t *r,
    ngx_http_core_loc_conf_t *clcf, u_char *file, ngx_err_t err);",18,64,http\modules\ngx_http_index_module.c,ngx_http_index_error,,false,31,32,ngx_http_index_error,,,6,"ngx_int_t ngx_http_index_error (ngx_http_request_t*,ngx_http_core_loc_conf_t*,u_char*,ngx_err_t)"
156630,METHOD,http\modules\ngx_http_index_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_index_init(ngx_conf_t *cf);,18,52,http\modules\ngx_http_index_module.c,ngx_http_index_init,,false,34,34,ngx_http_index_init,,,7,ngx_int_t ngx_http_index_init (ngx_conf_t*)
156635,METHOD,http\modules\ngx_http_index_module.c:<global>,TYPE_DECL,static void *ngx_http_index_create_loc_conf(ngx_conf_t *cf);,13,59,http\modules\ngx_http_index_module.c,ngx_http_index_create_loc_conf,,false,35,35,ngx_http_index_create_loc_conf,,,8,void* ngx_http_index_create_loc_conf (ngx_conf_t*)
156640,METHOD,http\modules\ngx_http_index_module.c:<global>,TYPE_DECL,"static char *ngx_http_index_merge_loc_conf(ngx_conf_t *cf,
    void *parent, void *child);",13,30,http\modules\ngx_http_index_module.c,ngx_http_index_merge_loc_conf,,false,36,37,ngx_http_index_merge_loc_conf,,,9,"char* ngx_http_index_merge_loc_conf (ngx_conf_t*,void*,void*)"
156647,METHOD,http\modules\ngx_http_index_module.c:<global>,TYPE_DECL,"static char *ngx_http_index_set_index(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_index_module.c,ngx_http_index_set_index,,false,38,39,ngx_http_index_set_index,,,10,"char* ngx_http_index_set_index (ngx_conf_t*,ngx_command_t*,void*)"
156702,METHOD,http\modules\ngx_http_index_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_index_handler(ngx_http_request_t *r)
{
    u_char                       *p, *name;
    size_t                        len, root, reserve, allocated;
    ngx_int_t                     rc;
    ngx_str_t                     path, uri;
    ngx_uint_t                    i, dir_tested;
    ngx_http_index_t             *index;
    ngx_open_file_info_t          of;
    ngx_http_script_code_pt       code;
    ngx_http_script_engine_t      e;
    ngx_http_core_loc_conf_t     *clcf;
    ngx_http_index_loc_conf_t    *ilcf;
    ngx_http_script_len_code_pt   lcode;

    if (r->uri.data[r->uri.len - 1] != '/') {
        return NGX_DECLINED;
    }

    if (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD|NGX_HTTP_POST))) {
        return NGX_DECLINED;
    }

    ilcf = ngx_http_get_module_loc_conf(r, ngx_http_index_module);
    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    allocated = 0;
    root = 0;
    dir_tested = 0;
    name = NULL;
    /* suppress MSVC w...",1,1,http\modules\ngx_http_index_module.c,ngx_http_index_handler,,false,96,281,ngx_http_index_handler,,,17,ngx_int_t ngx_http_index_handler (ngx_http_request_t*)
157353,METHOD,http\modules\ngx_http_index_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_index_test_dir(ngx_http_request_t *r, ngx_http_core_loc_conf_t *clcf,
    u_char *path, u_char *last)
{
    u_char                c;
    ngx_str_t             dir;
    ngx_open_file_info_t  of;

    c = *last;
    if (c != '/' || path == last) {
        /* ""alias"" without trailing slash */
        c = *(++last);
    }
    *last = '\0';

    dir.len = last - path;
    dir.data = path;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http index check dir: \""%V\"""", &dir);

    ngx_memzero(&of, sizeof(ngx_open_file_info_t));

    of.test_dir = 1;
    of.test_only = 1;
    of.valid = clcf->open_file_cache_valid;
    of.errors = clcf->open_file_cache_errors;

    if (ngx_http_set_disable_symlinks(r, clcf, &dir, &of) != NGX_OK) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    if (ngx_open_cached_file(clcf->open_file_cache, &dir, &of, r->pool)
        != NGX_OK)
    {
        if (of.err) {

#if (NGX_HAVE_OPENAT)
        ...",1,1,http\modules\ngx_http_index_module.c,ngx_http_index_test_dir,,false,284,364,ngx_http_index_test_dir,,,18,"ngx_int_t ngx_http_index_test_dir (ngx_http_request_t*,ngx_http_core_loc_conf_t*,u_char*,u_char*)"
157547,METHOD,http\modules\ngx_http_index_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_index_error(ngx_http_request_t *r, ngx_http_core_loc_conf_t  *clcf,
    u_char *file, ngx_err_t err)
{
    if (err == NGX_EACCES) {
        ngx_log_error(NGX_LOG_ERR, r->connection->log, err,
                      ""\""%s\"" is forbidden"", file);

        return NGX_HTTP_FORBIDDEN;
    }

    if (clcf->log_not_found) {
        ngx_log_error(NGX_LOG_ERR, r->connection->log, err,
                      ""\""%s\"" is not found"", file);
    }

    return NGX_HTTP_NOT_FOUND;
}",1,1,http\modules\ngx_http_index_module.c,ngx_http_index_error,,false,367,384,ngx_http_index_error,,,19,"ngx_int_t ngx_http_index_error (ngx_http_request_t*,ngx_http_core_loc_conf_t*,u_char*,ngx_err_t)"
157589,METHOD,http\modules\ngx_http_index_module.c:<global>,TYPE_DECL,"static void *
ngx_http_index_create_loc_conf(ngx_conf_t *cf)
{
    ngx_http_index_loc_conf_t  *conf;

    conf = ngx_palloc(cf->pool, sizeof(ngx_http_index_loc_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    conf->indices = NULL;
    conf->max_index_len = 0;

    return conf;
}",1,1,http\modules\ngx_http_index_module.c,ngx_http_index_create_loc_conf,,false,387,401,ngx_http_index_create_loc_conf,,,20,void* ngx_http_index_create_loc_conf (ngx_conf_t*)
157622,METHOD,http\modules\ngx_http_index_module.c:<global>,TYPE_DECL,"static char *
ngx_http_index_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_index_loc_conf_t  *prev = parent;
    ngx_http_index_loc_conf_t  *conf = child;

    ngx_http_index_t  *index;

    if (conf->indices == NULL) {
        conf->indices = prev->indices;
        conf->max_index_len = prev->max_index_len;
    }

    if (conf->indices == NULL) {
        conf->indices = ngx_array_create(cf->pool, 1, sizeof(ngx_http_index_t));
        if (conf->indices == NULL) {
            return NGX_CONF_ERROR;
        }

        index = ngx_array_push(conf->indices);
        if (index == NULL) {
            return NGX_CONF_ERROR;
        }

        index->name.len = sizeof(NGX_HTTP_DEFAULT_INDEX);
        index->name.data = (u_char *) NGX_HTTP_DEFAULT_INDEX;
        index->lengths = NULL;
        index->values = NULL;

        conf->max_index_len = sizeof(NGX_HTTP_DEFAULT_INDEX);

        return NGX_CONF_OK;
    }

    return NGX_CONF_OK;
}",1,33,http\modules\ngx_http_index_module.c,ngx_http_index_merge_loc_conf,,false,404,439,ngx_http_index_merge_loc_conf,,,21,"char* ngx_http_index_merge_loc_conf (ngx_conf_t*,void*,void*)"
157742,METHOD,http\modules\ngx_http_index_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_index_init(ngx_conf_t *cf)
{
    ngx_http_handler_pt        *h;
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);

    h = ngx_array_push(&cmcf->phases[NGX_HTTP_CONTENT_PHASE].handlers);
    if (h == NULL) {
        return NGX_ERROR;
    }

    *h = ngx_http_index_handler;

    return NGX_OK;
}",1,1,http\modules\ngx_http_index_module.c,ngx_http_index_init,,false,442,458,ngx_http_index_init,,,22,ngx_int_t ngx_http_index_init (ngx_conf_t*)
157778,METHOD,http\modules\ngx_http_index_module.c:<global>,TYPE_DECL,"static char *
ngx_http_index_set_index(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_index_loc_conf_t *ilcf = conf;

    ngx_str_t                  *value;
    ngx_uint_t                  i, n;
    ngx_http_index_t           *index;
    ngx_http_script_compile_t   sc;

    if (ilcf->indices == NULL) {
        ilcf->indices = ngx_array_create(cf->pool, 2, sizeof(ngx_http_index_t));
        if (ilcf->indices == NULL) {
            return NGX_CONF_ERROR;
        }
    }

    value = cf->args->elts;

    for (i = 1; i < cf->args->nelts; i++) {

        if (value[i].data[0] == '/' && i != cf->args->nelts - 1) {
            ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
                               ""only the last index in \""index\"" directive ""
                               ""should be absolute"");
        }

        if (value[i].len == 0) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               ""index \""%V\"" in \""index\"" directive is invalid"",
     ...",1,1,http\modules\ngx_http_index_module.c,ngx_http_index_set_index,,false,463,540,ngx_http_index_set_index,,,23,"char* ngx_http_index_set_index (ngx_conf_t*,ngx_command_t*,void*)"
158054,METHOD,http\modules\ngx_http_limit_conn_module.c:<global>,TYPE_DECL,<global>,1,37,http\modules\ngx_http_limit_conn_module.c,http\modules\ngx_http_limit_conn_module.c:<global>,,false,1,758,<global>,,,1,
158061,METHOD,<empty>,<empty>,<empty>,1,,http\modules\ngx_http_limit_conn_module.c,ngx_http_limit_conn_node_t:<clinit>,,false,18,,<clinit>,,,5,
158091,METHOD,http\modules\ngx_http_limit_conn_module.c:<global>,TYPE_DECL,"static ngx_rbtree_node_t *ngx_http_limit_conn_lookup(ngx_rbtree_t *rbtree,
    ngx_str_t *key, uint32_t hash);",26,34,http\modules\ngx_http_limit_conn_module.c,ngx_http_limit_conn_lookup,,false,59,60,ngx_http_limit_conn_lookup,,,13,"ngx_rbtree_node_t* ngx_http_limit_conn_lookup (ngx_rbtree_t*,ngx_str_t*,uint32_t)"
158098,METHOD,http\modules\ngx_http_limit_conn_module.c:<global>,TYPE_DECL,static void ngx_http_limit_conn_cleanup(void *data);,13,51,http\modules\ngx_http_limit_conn_module.c,ngx_http_limit_conn_cleanup,,false,61,61,ngx_http_limit_conn_cleanup,,,14,void ngx_http_limit_conn_cleanup (void*)
158104,METHOD,http\modules\ngx_http_limit_conn_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_limit_conn_status_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\modules\ngx_http_limit_conn_module.c,ngx_http_limit_conn_status_variable,,false,64,65,ngx_http_limit_conn_status_variable,,,16,"ngx_int_t ngx_http_limit_conn_status_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
158111,METHOD,http\modules\ngx_http_limit_conn_module.c:<global>,TYPE_DECL,static void *ngx_http_limit_conn_create_conf(ngx_conf_t *cf);,13,60,http\modules\ngx_http_limit_conn_module.c,ngx_http_limit_conn_create_conf,,false,66,66,ngx_http_limit_conn_create_conf,,,17,void* ngx_http_limit_conn_create_conf (ngx_conf_t*)
158116,METHOD,http\modules\ngx_http_limit_conn_module.c:<global>,TYPE_DECL,"static char *ngx_http_limit_conn_merge_conf(ngx_conf_t *cf, void *parent,
    void *child);",13,16,http\modules\ngx_http_limit_conn_module.c,ngx_http_limit_conn_merge_conf,,false,67,68,ngx_http_limit_conn_merge_conf,,,18,"char* ngx_http_limit_conn_merge_conf (ngx_conf_t*,void*,void*)"
158123,METHOD,http\modules\ngx_http_limit_conn_module.c:<global>,TYPE_DECL,"static char *ngx_http_limit_conn_zone(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_limit_conn_module.c,ngx_http_limit_conn_zone,,false,69,70,ngx_http_limit_conn_zone,,,19,"char* ngx_http_limit_conn_zone (ngx_conf_t*,ngx_command_t*,void*)"
158130,METHOD,http\modules\ngx_http_limit_conn_module.c:<global>,TYPE_DECL,"static char *ngx_http_limit_conn(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_limit_conn_module.c,ngx_http_limit_conn,,false,71,72,ngx_http_limit_conn,,,20,"char* ngx_http_limit_conn (ngx_conf_t*,ngx_command_t*,void*)"
158137,METHOD,http\modules\ngx_http_limit_conn_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_limit_conn_add_variables(ngx_conf_t *cf);,18,66,http\modules\ngx_http_limit_conn_module.c,ngx_http_limit_conn_add_variables,,false,73,73,ngx_http_limit_conn_add_variables,,,21,ngx_int_t ngx_http_limit_conn_add_variables (ngx_conf_t*)
158142,METHOD,http\modules\ngx_http_limit_conn_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_limit_conn_init(ngx_conf_t *cf);,18,57,http\modules\ngx_http_limit_conn_module.c,ngx_http_limit_conn_init,,false,74,74,ngx_http_limit_conn_init,,,22,ngx_int_t ngx_http_limit_conn_init (ngx_conf_t*)
158308,METHOD,http\modules\ngx_http_limit_conn_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_limit_conn_handler(ngx_http_request_t *r)
{
    size_t                          n;
    uint32_t                        hash;
    ngx_str_t                       key;
    ngx_uint_t                      i;
    ngx_rbtree_node_t              *node;
    ngx_pool_cleanup_t             *cln;
    ngx_http_limit_conn_ctx_t      *ctx;
    ngx_http_limit_conn_node_t     *lc;
    ngx_http_limit_conn_conf_t     *lccf;
    ngx_http_limit_conn_limit_t    *limits;
    ngx_http_limit_conn_cleanup_t  *lccln;

    if (r->main->limit_conn_status) {
        return NGX_DECLINED;
    }

    lccf = ngx_http_get_module_loc_conf(r, ngx_http_limit_conn_module);
    limits = lccf->limits.elts;

    for (i = 0; i < lccf->limits.nelts; i++) {
        ctx = limits[i].shm_zone->data;

        if (ngx_http_complex_value(r, &ctx->key, &key) != NGX_OK) {
            return NGX_HTTP_INTERNAL_SERVER_ERROR;
        }

        if (key.len == 0) {
            continue;
        }

        if (ke...",1,37,http\modules\ngx_http_limit_conn_module.c,ngx_http_limit_conn_handler,,false,179,308,ngx_http_limit_conn_handler,,,37,ngx_int_t ngx_http_limit_conn_handler (ngx_http_request_t*)
158725,METHOD,http\modules\ngx_http_limit_conn_module.c:<global>,TYPE_DECL,"static void
ngx_http_limit_conn_rbtree_insert_value(ngx_rbtree_node_t *temp,
    ngx_rbtree_node_t *node, ngx_rbtree_node_t *sentinel)
{
    ngx_rbtree_node_t           **p;
    ngx_http_limit_conn_node_t   *lcn, *lcnt;

    for ( ;; ) {

        if (node->key < temp->key) {

            p = &temp->left;

        } else if (node->key > temp->key) {

            p = &temp->right;

        } else { /* node->key == temp->key */

            lcn = (ngx_http_limit_conn_node_t *) &node->color;
            lcnt = (ngx_http_limit_conn_node_t *) &temp->color;

            p = (ngx_memn2cmp(lcn->data, lcnt->data, lcn->len, lcnt->len) < 0)
                ? &temp->left : &temp->right;
        }

        if (*p == sentinel) {
            break;
        }

        temp = *p;
    }

    *p = node;
    node->parent = temp;
    node->left = sentinel;
    node->right = sentinel;
    ngx_rbt_red(node);
}",1,1,http\modules\ngx_http_limit_conn_module.c,ngx_http_limit_conn_rbtree_insert_value,,false,311,349,ngx_http_limit_conn_rbtree_insert_value,,,38,"void ngx_http_limit_conn_rbtree_insert_value (ngx_rbtree_node_t*,ngx_rbtree_node_t*,ngx_rbtree_node_t*)"
158846,METHOD,http\modules\ngx_http_limit_conn_module.c:<global>,TYPE_DECL,"static ngx_rbtree_node_t *
ngx_http_limit_conn_lookup(ngx_rbtree_t *rbtree, ngx_str_t *key, uint32_t hash)
{
    ngx_int_t                    rc;
    ngx_rbtree_node_t           *node, *sentinel;
    ngx_http_limit_conn_node_t  *lcn;

    node = rbtree->root;
    sentinel = rbtree->sentinel;

    while (node != sentinel) {

        if (hash < node->key) {
            node = node->left;
            continue;
        }

        if (hash > node->key) {
            node = node->right;
            continue;
        }

        /* hash == node->key */

        lcn = (ngx_http_limit_conn_node_t *) &node->color;

        rc = ngx_memn2cmp(key->data, lcn->data, key->len, (size_t) lcn->len);

        if (rc == 0) {
            return node;
        }

        node = (rc < 0) ? node->left : node->right;
    }

    return NULL;
}",1,1,http\modules\ngx_http_limit_conn_module.c,ngx_http_limit_conn_lookup,,false,352,388,ngx_http_limit_conn_lookup,,,39,"ngx_rbtree_node_t ngx_http_limit_conn_lookup (ngx_rbtree_t*,ngx_str_t*,uint32_t)"
158944,METHOD,http\modules\ngx_http_limit_conn_module.c:<global>,TYPE_DECL,"static void
ngx_http_limit_conn_cleanup(void *data)
{
    ngx_http_limit_conn_cleanup_t  *lccln = data;

    ngx_rbtree_node_t           *node;
    ngx_http_limit_conn_ctx_t   *ctx;
    ngx_http_limit_conn_node_t  *lc;

    ctx = lccln->shm_zone->data;
    node = lccln->node;
    lc = (ngx_http_limit_conn_node_t *) &node->color;

    ngx_shmtx_lock(&ctx->shpool->mutex);

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, lccln->shm_zone->shm.log, 0,
                   ""limit conn cleanup: %08Xi %d"", node->key, lc->conn);

    lc->conn--;

    if (lc->conn == 0) {
        ngx_rbtree_delete(&ctx->sh->rbtree, node);
        ngx_slab_free_locked(ctx->shpool, node);
    }

    ngx_shmtx_unlock(&ctx->shpool->mutex);
}",1,1,http\modules\ngx_http_limit_conn_module.c,ngx_http_limit_conn_cleanup,,false,391,417,ngx_http_limit_conn_cleanup,,,40,void ngx_http_limit_conn_cleanup (void*)
159032,METHOD,http\modules\ngx_http_limit_conn_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_limit_conn_init_zone(ngx_shm_zone_t *shm_zone, void *data)
{
    ngx_http_limit_conn_ctx_t  *octx = data;

    size_t                      len;
    ngx_http_limit_conn_ctx_t  *ctx;

    ctx = shm_zone->data;

    if (octx) {
        if (ctx->key.value.len != octx->key.value.len
            || ngx_strncmp(ctx->key.value.data, octx->key.value.data,
                           ctx->key.value.len)
               != 0)
        {
            ngx_log_error(NGX_LOG_EMERG, shm_zone->shm.log, 0,
                          ""limit_conn_zone \""%V\"" uses the \""%V\"" key ""
                          ""while previously it used the \""%V\"" key"",
                          &shm_zone->shm.name, &ctx->key.value,
                          &octx->key.value);
            return NGX_ERROR;
        }

        ctx->sh = octx->sh;
        ctx->shpool = octx->shpool;

        return NGX_OK;
    }

    ctx->shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;

    if (shm_zone->shm.exists) {
    ...",1,1,http\modules\ngx_http_limit_conn_module.c,ngx_http_limit_conn_init_zone,,false,436,495,ngx_http_limit_conn_init_zone,,,42,"ngx_int_t ngx_http_limit_conn_init_zone (ngx_shm_zone_t*,void*)"
159259,METHOD,http\modules\ngx_http_limit_conn_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_limit_conn_status_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    if (r->main->limit_conn_status == 0) {
        v->not_found = 1;
        return NGX_OK;
    }

    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->len = ngx_http_limit_conn_status[r->main->limit_conn_status - 1].len;
    v->data = ngx_http_limit_conn_status[r->main->limit_conn_status - 1].data;

    return NGX_OK;
}",1,1,http\modules\ngx_http_limit_conn_module.c,ngx_http_limit_conn_status_variable,,false,498,514,ngx_http_limit_conn_status_variable,,,43,"ngx_int_t ngx_http_limit_conn_status_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
159329,METHOD,http\modules\ngx_http_limit_conn_module.c:<global>,TYPE_DECL,"static void *
ngx_http_limit_conn_create_conf(ngx_conf_t *cf)
{
    ngx_http_limit_conn_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_limit_conn_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     conf->limits.elts = NULL;
     */

    conf->log_level = NGX_CONF_UNSET_UINT;
    conf->status_code = NGX_CONF_UNSET_UINT;
    conf->dry_run = NGX_CONF_UNSET;

    return conf;
}",1,1,http\modules\ngx_http_limit_conn_module.c,ngx_http_limit_conn_create_conf,,false,517,538,ngx_http_limit_conn_create_conf,,,44,void* ngx_http_limit_conn_create_conf (ngx_conf_t*)
159367,METHOD,http\modules\ngx_http_limit_conn_module.c:<global>,TYPE_DECL,"static char *
ngx_http_limit_conn_merge_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_limit_conn_conf_t *prev = parent;
    ngx_http_limit_conn_conf_t *conf = child;

    if (conf->limits.elts == NULL) {
        conf->limits = prev->limits;
    }

    ngx_conf_merge_uint_value(conf->log_level, prev->log_level, NGX_LOG_ERR);
    ngx_conf_merge_uint_value(conf->status_code, prev->status_code,
                              NGX_HTTP_SERVICE_UNAVAILABLE);

    ngx_conf_merge_value(conf->dry_run, prev->dry_run, 0);

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_limit_conn_module.c,ngx_http_limit_conn_merge_conf,,false,541,558,ngx_http_limit_conn_merge_conf,,,45,"char* ngx_http_limit_conn_merge_conf (ngx_conf_t*,void*,void*)"
159424,METHOD,http\modules\ngx_http_limit_conn_module.c:<global>,TYPE_DECL,"static char *
ngx_http_limit_conn_zone(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    u_char                            *p;
    ssize_t                            size;
    ngx_str_t                         *value, name, s;
    ngx_uint_t                         i;
    ngx_shm_zone_t                    *shm_zone;
    ngx_http_limit_conn_ctx_t         *ctx;
    ngx_http_compile_complex_value_t   ccv;

    value = cf->args->elts;

    ctx = ngx_pcalloc(cf->pool, sizeof(ngx_http_limit_conn_ctx_t));
    if (ctx == NULL) {
        return NGX_CONF_ERROR;
    }

    ngx_memzero(&ccv, sizeof(ngx_http_compile_complex_value_t));

    ccv.cf = cf;
    ccv.value = &value[1];
    ccv.complex_value = &ctx->key;

    if (ngx_http_compile_complex_value(&ccv) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    size = 0;
    name.len = 0;

    for (i = 2; i < cf->args->nelts; i++) {

        if (ngx_strncmp(value[i].data, ""zone="", 5) == 0) {

            name.data = value[i].data + 5;

    ...",1,1,http\modules\ngx_http_limit_conn_module.c,ngx_http_limit_conn_zone,,false,561,659,ngx_http_limit_conn_zone,,,46,"char* ngx_http_limit_conn_zone (ngx_conf_t*,ngx_command_t*,void*)"
159730,METHOD,http\modules\ngx_http_limit_conn_module.c:<global>,TYPE_DECL,"static char *
ngx_http_limit_conn(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_shm_zone_t               *shm_zone;
    ngx_http_limit_conn_conf_t   *lccf = conf;
    ngx_http_limit_conn_limit_t  *limit, *limits;

    ngx_str_t  *value;
    ngx_int_t   n;
    ngx_uint_t  i;

    value = cf->args->elts;

    shm_zone = ngx_shared_memory_add(cf, &value[1], 0,
                                     &ngx_http_limit_conn_module);
    if (shm_zone == NULL) {
        return NGX_CONF_ERROR;
    }

    limits = lccf->limits.elts;

    if (limits == NULL) {
        if (ngx_array_init(&lccf->limits, cf->pool, 1,
                           sizeof(ngx_http_limit_conn_limit_t))
            != NGX_OK)
        {
            return NGX_CONF_ERROR;
        }
    }

    for (i = 0; i < lccf->limits.nelts; i++) {
        if (shm_zone == limits[i].shm_zone) {
            return ""is duplicate"";
        }
    }

    n = ngx_atoi(value[2].data, value[2].len);
    if (n <= 0) {
        ngx_conf_lo...",1,1,http\modules\ngx_http_limit_conn_module.c,ngx_http_limit_conn,,false,662,720,ngx_http_limit_conn,,,47,"char* ngx_http_limit_conn (ngx_conf_t*,ngx_command_t*,void*)"
159894,METHOD,http\modules\ngx_http_limit_conn_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_limit_conn_add_variables(ngx_conf_t *cf)
{
    ngx_http_variable_t  *var, *v;

    for (v = ngx_http_limit_conn_vars; v->name.len; v++) {
        var = ngx_http_add_variable(cf, &v->name, v->flags);
        if (var == NULL) {
            return NGX_ERROR;
        }

        var->get_handler = v->get_handler;
        var->data = v->data;
    }

    return NGX_OK;
}",1,1,http\modules\ngx_http_limit_conn_module.c,ngx_http_limit_conn_add_variables,,false,723,739,ngx_http_limit_conn_add_variables,,,48,ngx_int_t ngx_http_limit_conn_add_variables (ngx_conf_t*)
159948,METHOD,http\modules\ngx_http_limit_conn_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_limit_conn_init(ngx_conf_t *cf)
{
    ngx_http_handler_pt        *h;
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);

    h = ngx_array_push(&cmcf->phases[NGX_HTTP_PREACCESS_PHASE].handlers);
    if (h == NULL) {
        return NGX_ERROR;
    }

    *h = ngx_http_limit_conn_handler;

    return NGX_OK;
}",1,1,http\modules\ngx_http_limit_conn_module.c,ngx_http_limit_conn_init,,false,742,758,ngx_http_limit_conn_init,,,49,ngx_int_t ngx_http_limit_conn_init (ngx_conf_t*)
159993,METHOD,http\modules\ngx_http_limit_req_module.c:<global>,TYPE_DECL,<global>,1,40,http\modules\ngx_http_limit_req_module.c,http\modules\ngx_http_limit_req_module.c:<global>,,false,1,1085,<global>,,,1,
160004,METHOD,<empty>,<empty>,<empty>,1,,http\modules\ngx_http_limit_req_module.c,ngx_http_limit_req_node_t:<clinit>,,false,20,,<clinit>,,,9,
160035,METHOD,http\modules\ngx_http_limit_req_module.c:<global>,TYPE_DECL,static void ngx_http_limit_req_delay(ngx_http_request_t *r);,13,59,http\modules\ngx_http_limit_req_module.c,ngx_http_limit_req_delay,,false,67,67,ngx_http_limit_req_delay,,,11,void ngx_http_limit_req_delay (ngx_http_request_t*)
160040,METHOD,http\modules\ngx_http_limit_req_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_limit_req_lookup(ngx_http_limit_req_limit_t *limit,
    ngx_uint_t hash, ngx_str_t *key, ngx_uint_t *ep, ngx_uint_t account);",18,72,http\modules\ngx_http_limit_req_module.c,ngx_http_limit_req_lookup,,false,68,69,ngx_http_limit_req_lookup,,,12,"ngx_int_t ngx_http_limit_req_lookup (ngx_http_limit_req_limit_t*,ngx_uint_t,ngx_str_t*,ngx_uint_t*,ngx_uint_t)"
160049,METHOD,http\modules\ngx_http_limit_req_module.c:<global>,TYPE_DECL,"static ngx_msec_t ngx_http_limit_req_account(ngx_http_limit_req_limit_t *limits,
    ngx_uint_t n, ngx_uint_t *ep, ngx_http_limit_req_limit_t **limit);",19,69,http\modules\ngx_http_limit_req_module.c,ngx_http_limit_req_account,,false,70,71,ngx_http_limit_req_account,,,13,"ngx_msec_t ngx_http_limit_req_account (ngx_http_limit_req_limit_t*,ngx_uint_t,ngx_uint_t*,ngx_http_limit_req_limit_t**)"
160057,METHOD,http\modules\ngx_http_limit_req_module.c:<global>,TYPE_DECL,"static void ngx_http_limit_req_expire(ngx_http_limit_req_ctx_t *ctx,
    ngx_uint_t n);",13,17,http\modules\ngx_http_limit_req_module.c,ngx_http_limit_req_expire,,false,72,73,ngx_http_limit_req_expire,,,14,"void ngx_http_limit_req_expire (ngx_http_limit_req_ctx_t*,ngx_uint_t)"
160063,METHOD,http\modules\ngx_http_limit_req_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_limit_req_status_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\modules\ngx_http_limit_req_module.c,ngx_http_limit_req_status_variable,,false,75,76,ngx_http_limit_req_status_variable,,,15,"ngx_int_t ngx_http_limit_req_status_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
160070,METHOD,http\modules\ngx_http_limit_req_module.c:<global>,TYPE_DECL,static void *ngx_http_limit_req_create_conf(ngx_conf_t *cf);,13,59,http\modules\ngx_http_limit_req_module.c,ngx_http_limit_req_create_conf,,false,77,77,ngx_http_limit_req_create_conf,,,16,void* ngx_http_limit_req_create_conf (ngx_conf_t*)
160075,METHOD,http\modules\ngx_http_limit_req_module.c:<global>,TYPE_DECL,"static char *ngx_http_limit_req_merge_conf(ngx_conf_t *cf, void *parent,
    void *child);",13,16,http\modules\ngx_http_limit_req_module.c,ngx_http_limit_req_merge_conf,,false,78,79,ngx_http_limit_req_merge_conf,,,17,"char* ngx_http_limit_req_merge_conf (ngx_conf_t*,void*,void*)"
160082,METHOD,http\modules\ngx_http_limit_req_module.c:<global>,TYPE_DECL,"static char *ngx_http_limit_req_zone(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_limit_req_module.c,ngx_http_limit_req_zone,,false,80,81,ngx_http_limit_req_zone,,,18,"char* ngx_http_limit_req_zone (ngx_conf_t*,ngx_command_t*,void*)"
160089,METHOD,http\modules\ngx_http_limit_req_module.c:<global>,TYPE_DECL,"static char *ngx_http_limit_req(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_limit_req_module.c,ngx_http_limit_req,,false,82,83,ngx_http_limit_req,,,19,"char* ngx_http_limit_req (ngx_conf_t*,ngx_command_t*,void*)"
160096,METHOD,http\modules\ngx_http_limit_req_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_limit_req_add_variables(ngx_conf_t *cf);,18,65,http\modules\ngx_http_limit_req_module.c,ngx_http_limit_req_add_variables,,false,84,84,ngx_http_limit_req_add_variables,,,20,ngx_int_t ngx_http_limit_req_add_variables (ngx_conf_t*)
160101,METHOD,http\modules\ngx_http_limit_req_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_limit_req_init(ngx_conf_t *cf);,18,56,http\modules\ngx_http_limit_req_module.c,ngx_http_limit_req_init,,false,85,85,ngx_http_limit_req_init,,,21,ngx_int_t ngx_http_limit_req_init (ngx_conf_t*)
160271,METHOD,http\modules\ngx_http_limit_req_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_limit_req_handler(ngx_http_request_t *r)
{
    uint32_t                     hash;
    ngx_str_t                    key;
    ngx_int_t                    rc;
    ngx_uint_t                   n, excess;
    ngx_msec_t                   delay;
    ngx_http_limit_req_ctx_t    *ctx;
    ngx_http_limit_req_conf_t   *lrcf;
    ngx_http_limit_req_limit_t  *limit, *limits;

    if (r->main->limit_req_status) {
        return NGX_DECLINED;
    }

    lrcf = ngx_http_get_module_loc_conf(r, ngx_http_limit_req_module);
    limits = lrcf->limits.elts;

    excess = 0;

    rc = NGX_DECLINED;

#if (NGX_SUPPRESS_WARN)
    limit = NULL;
#endif

    for (n = 0; n < lrcf->limits.nelts; n++) {

        limit = &limits[n];

        ctx = limit->shm_zone->data;

        if (ngx_http_complex_value(r, &ctx->key, &key) != NGX_OK) {
            return NGX_HTTP_INTERNAL_SERVER_ERROR;
        }

        if (key.len == 0) {
            continue;
        }

        if (key.len > 65535) ...",1,40,http\modules\ngx_http_limit_req_module.c,ngx_http_limit_req_handler,,false,192,335,ngx_http_limit_req_handler,,,36,ngx_int_t ngx_http_limit_req_handler (ngx_http_request_t*)
160708,METHOD,http\modules\ngx_http_limit_req_module.c:<global>,TYPE_DECL,"static void
ngx_http_limit_req_delay(ngx_http_request_t *r)
{
    ngx_event_t  *wev;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""limit_req delay"");

    wev = r->connection->write;

    if (wev->delayed) {

        if (ngx_handle_write_event(wev, 0) != NGX_OK) {
            ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
        }

        return;
    }

    if (ngx_handle_read_event(r->connection->read, 0) != NGX_OK) {
        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
        return;
    }

    r->read_event_handler = ngx_http_block_reading;
    r->write_event_handler = ngx_http_core_run_phases;

    ngx_http_core_run_phases(r);
}",1,1,http\modules\ngx_http_limit_req_module.c,ngx_http_limit_req_delay,,false,338,366,ngx_http_limit_req_delay,,,37,void ngx_http_limit_req_delay (ngx_http_request_t*)
160773,METHOD,http\modules\ngx_http_limit_req_module.c:<global>,TYPE_DECL,"static void
ngx_http_limit_req_rbtree_insert_value(ngx_rbtree_node_t *temp,
    ngx_rbtree_node_t *node, ngx_rbtree_node_t *sentinel)
{
    ngx_rbtree_node_t          **p;
    ngx_http_limit_req_node_t   *lrn, *lrnt;

    for ( ;; ) {

        if (node->key < temp->key) {

            p = &temp->left;

        } else if (node->key > temp->key) {

            p = &temp->right;

        } else { /* node->key == temp->key */

            lrn = (ngx_http_limit_req_node_t *) &node->color;
            lrnt = (ngx_http_limit_req_node_t *) &temp->color;

            p = (ngx_memn2cmp(lrn->data, lrnt->data, lrn->len, lrnt->len) < 0)
                ? &temp->left : &temp->right;
        }

        if (*p == sentinel) {
            break;
        }

        temp = *p;
    }

    *p = node;
    node->parent = temp;
    node->left = sentinel;
    node->right = sentinel;
    ngx_rbt_red(node);
}",1,1,http\modules\ngx_http_limit_req_module.c,ngx_http_limit_req_rbtree_insert_value,,false,369,407,ngx_http_limit_req_rbtree_insert_value,,,38,"void ngx_http_limit_req_rbtree_insert_value (ngx_rbtree_node_t*,ngx_rbtree_node_t*,ngx_rbtree_node_t*)"
160894,METHOD,http\modules\ngx_http_limit_req_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_limit_req_lookup(ngx_http_limit_req_limit_t *limit, ngx_uint_t hash,
    ngx_str_t *key, ngx_uint_t *ep, ngx_uint_t account)
{
    size_t                      size;
    ngx_int_t                   rc, excess;
    ngx_msec_t                  now;
    ngx_msec_int_t              ms;
    ngx_rbtree_node_t          *node, *sentinel;
    ngx_http_limit_req_ctx_t   *ctx;
    ngx_http_limit_req_node_t  *lr;

    now = ngx_current_msec;

    ctx = limit->shm_zone->data;

    node = ctx->sh->rbtree.root;
    sentinel = ctx->sh->rbtree.sentinel;

    while (node != sentinel) {

        if (hash < node->key) {
            node = node->left;
            continue;
        }

        if (hash > node->key) {
            node = node->right;
            continue;
        }

        /* hash == node->key */

        lr = (ngx_http_limit_req_node_t *) &node->color;

        rc = ngx_memn2cmp(key->data, lr->data, key->len, (size_t) lr->len);

        if (rc == 0) {
            ...",1,1,http\modules\ngx_http_limit_req_module.c,ngx_http_limit_req_lookup,,false,410,538,ngx_http_limit_req_lookup,,,39,"ngx_int_t ngx_http_limit_req_lookup (ngx_http_limit_req_limit_t*,ngx_uint_t,ngx_str_t*,ngx_uint_t*,ngx_uint_t)"
161272,METHOD,http\modules\ngx_http_limit_req_module.c:<global>,TYPE_DECL,"static ngx_msec_t
ngx_http_limit_req_account(ngx_http_limit_req_limit_t *limits, ngx_uint_t n,
    ngx_uint_t *ep, ngx_http_limit_req_limit_t **limit)
{
    ngx_int_t                   excess;
    ngx_msec_t                  now, delay, max_delay;
    ngx_msec_int_t              ms;
    ngx_http_limit_req_ctx_t   *ctx;
    ngx_http_limit_req_node_t  *lr;

    excess = *ep;

    if ((ngx_uint_t) excess <= (*limit)->delay) {
        max_delay = 0;

    } else {
        ctx = (*limit)->shm_zone->data;
        max_delay = (excess - (*limit)->delay) * 1000 / ctx->rate;
    }

    while (n--) {
        ctx = limits[n].shm_zone->data;
        lr = ctx->node;

        if (lr == NULL) {
            continue;
        }

        ngx_shmtx_lock(&ctx->shpool->mutex);

        now = ngx_current_msec;
        ms = (ngx_msec_int_t) (now - lr->last);

        if (ms < -60000) {
            ms = 1;

        } else if (ms < 0) {
            ms = 0;
        }

        excess = lr->excess - ctx->rate * ...",1,1,http\modules\ngx_http_limit_req_module.c,ngx_http_limit_req_account,,false,541,612,ngx_http_limit_req_account,,,40,"ngx_msec_t ngx_http_limit_req_account (ngx_http_limit_req_limit_t*,ngx_uint_t,ngx_uint_t*,ngx_http_limit_req_limit_t**)"
161489,METHOD,http\modules\ngx_http_limit_req_module.c:<global>,TYPE_DECL,"static void
ngx_http_limit_req_expire(ngx_http_limit_req_ctx_t *ctx, ngx_uint_t n)
{
    ngx_int_t                   excess;
    ngx_msec_t                  now;
    ngx_queue_t                *q;
    ngx_msec_int_t              ms;
    ngx_rbtree_node_t          *node;
    ngx_http_limit_req_node_t  *lr;

    now = ngx_current_msec;

    /*
     * n == 1 deletes one or two zero rate entries
     * n == 0 deletes oldest entry by force
     *        and one or two zero rate entries
     */

    while (n < 3) {

        if (ngx_queue_empty(&ctx->sh->queue)) {
            return;
        }

        q = ngx_queue_last(&ctx->sh->queue);

        lr = ngx_queue_data(q, ngx_http_limit_req_node_t, queue);

        if (lr->count) {

            /*
             * There is not much sense in looking further,
             * because we bump nodes on the lookup stage.
             */

            return;
        }

        if (n++ != 0) {

            ms = (ngx_msec_int_t) (now - lr->last);
      ...",1,1,http\modules\ngx_http_limit_req_module.c,ngx_http_limit_req_expire,,false,615,678,ngx_http_limit_req_expire,,,41,"void ngx_http_limit_req_expire (ngx_http_limit_req_ctx_t*,ngx_uint_t)"
161609,METHOD,http\modules\ngx_http_limit_req_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_limit_req_init_zone(ngx_shm_zone_t *shm_zone, void *data)
{
    ngx_http_limit_req_ctx_t  *octx = data;

    size_t                     len;
    ngx_http_limit_req_ctx_t  *ctx;

    ctx = shm_zone->data;

    if (octx) {
        if (ctx->key.value.len != octx->key.value.len
            || ngx_strncmp(ctx->key.value.data, octx->key.value.data,
                           ctx->key.value.len)
               != 0)
        {
            ngx_log_error(NGX_LOG_EMERG, shm_zone->shm.log, 0,
                          ""limit_req \""%V\"" uses the \""%V\"" key ""
                          ""while previously it used the \""%V\"" key"",
                          &shm_zone->shm.name, &ctx->key.value,
                          &octx->key.value);
            return NGX_ERROR;
        }

        ctx->sh = octx->sh;
        ctx->shpool = octx->shpool;

        return NGX_OK;
    }

    ctx->shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;

    if (shm_zone->shm.exists) {
        ctx->s...",1,1,http\modules\ngx_http_limit_req_module.c,ngx_http_limit_req_init_zone,,false,681,744,ngx_http_limit_req_init_zone,,,42,"ngx_int_t ngx_http_limit_req_init_zone (ngx_shm_zone_t*,void*)"
161850,METHOD,http\modules\ngx_http_limit_req_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_limit_req_status_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    if (r->main->limit_req_status == 0) {
        v->not_found = 1;
        return NGX_OK;
    }

    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->len = ngx_http_limit_req_status[r->main->limit_req_status - 1].len;
    v->data = ngx_http_limit_req_status[r->main->limit_req_status - 1].data;

    return NGX_OK;
}",1,1,http\modules\ngx_http_limit_req_module.c,ngx_http_limit_req_status_variable,,false,747,763,ngx_http_limit_req_status_variable,,,43,"ngx_int_t ngx_http_limit_req_status_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
161920,METHOD,http\modules\ngx_http_limit_req_module.c:<global>,TYPE_DECL,"static void *
ngx_http_limit_req_create_conf(ngx_conf_t *cf)
{
    ngx_http_limit_req_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_limit_req_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     conf->limits.elts = NULL;
     */

    conf->limit_log_level = NGX_CONF_UNSET_UINT;
    conf->status_code = NGX_CONF_UNSET_UINT;
    conf->dry_run = NGX_CONF_UNSET;

    return conf;
}",1,1,http\modules\ngx_http_limit_req_module.c,ngx_http_limit_req_create_conf,,false,766,787,ngx_http_limit_req_create_conf,,,44,void* ngx_http_limit_req_create_conf (ngx_conf_t*)
161958,METHOD,http\modules\ngx_http_limit_req_module.c:<global>,TYPE_DECL,"static char *
ngx_http_limit_req_merge_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_limit_req_conf_t *prev = parent;
    ngx_http_limit_req_conf_t *conf = child;

    if (conf->limits.elts == NULL) {
        conf->limits = prev->limits;
    }

    ngx_conf_merge_uint_value(conf->limit_log_level, prev->limit_log_level,
                              NGX_LOG_ERR);

    conf->delay_log_level = (conf->limit_log_level == NGX_LOG_INFO) ?
                                NGX_LOG_INFO : conf->limit_log_level + 1;

    ngx_conf_merge_uint_value(conf->status_code, prev->status_code,
                              NGX_HTTP_SERVICE_UNAVAILABLE);

    ngx_conf_merge_value(conf->dry_run, prev->dry_run, 0);

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_limit_req_module.c,ngx_http_limit_req_merge_conf,,false,790,812,ngx_http_limit_req_merge_conf,,,45,"char* ngx_http_limit_req_merge_conf (ngx_conf_t*,void*,void*)"
162031,METHOD,http\modules\ngx_http_limit_req_module.c:<global>,TYPE_DECL,"static char *
ngx_http_limit_req_zone(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    u_char                            *p;
    size_t                             len;
    ssize_t                            size;
    ngx_str_t                         *value, name, s;
    ngx_int_t                          rate, scale;
    ngx_uint_t                         i;
    ngx_shm_zone_t                    *shm_zone;
    ngx_http_limit_req_ctx_t          *ctx;
    ngx_http_compile_complex_value_t   ccv;

    value = cf->args->elts;

    ctx = ngx_pcalloc(cf->pool, sizeof(ngx_http_limit_req_ctx_t));
    if (ctx == NULL) {
        return NGX_CONF_ERROR;
    }

    ngx_memzero(&ccv, sizeof(ngx_http_compile_complex_value_t));

    ccv.cf = cf;
    ccv.value = &value[1];
    ccv.complex_value = &ctx->key;

    if (ngx_http_compile_complex_value(&ccv) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    size = 0;
    rate = 1;
    scale = 1;
    name.len = 0;

    for (i = 2; i < cf->args->...",1,1,http\modules\ngx_http_limit_req_module.c,ngx_http_limit_req_zone,,false,815,943,ngx_http_limit_req_zone,,,46,"char* ngx_http_limit_req_zone (ngx_conf_t*,ngx_command_t*,void*)"
162445,METHOD,http\modules\ngx_http_limit_req_module.c:<global>,TYPE_DECL,"static char *
ngx_http_limit_req(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_limit_req_conf_t  *lrcf = conf;

    ngx_int_t                    burst, delay;
    ngx_str_t                   *value, s;
    ngx_uint_t                   i;
    ngx_shm_zone_t              *shm_zone;
    ngx_http_limit_req_limit_t  *limit, *limits;

    value = cf->args->elts;

    shm_zone = NULL;
    burst = 0;
    delay = 0;

    for (i = 1; i < cf->args->nelts; i++) {

        if (ngx_strncmp(value[i].data, ""zone="", 5) == 0) {

            s.len = value[i].len - 5;
            s.data = value[i].data + 5;

            shm_zone = ngx_shared_memory_add(cf, &s, 0,
                                             &ngx_http_limit_req_module);
            if (shm_zone == NULL) {
                return NGX_CONF_ERROR;
            }

            continue;
        }

        if (ngx_strncmp(value[i].data, ""burst="", 6) == 0) {

            burst = ngx_atoi(value[i].data + 6, value[i].len - 6);
   ...",1,1,http\modules\ngx_http_limit_req_module.c,ngx_http_limit_req,,false,946,1047,ngx_http_limit_req,,,47,"char* ngx_http_limit_req (ngx_conf_t*,ngx_command_t*,void*)"
162772,METHOD,http\modules\ngx_http_limit_req_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_limit_req_add_variables(ngx_conf_t *cf)
{
    ngx_http_variable_t  *var, *v;

    for (v = ngx_http_limit_req_vars; v->name.len; v++) {
        var = ngx_http_add_variable(cf, &v->name, v->flags);
        if (var == NULL) {
            return NGX_ERROR;
        }

        var->get_handler = v->get_handler;
        var->data = v->data;
    }

    return NGX_OK;
}",1,1,http\modules\ngx_http_limit_req_module.c,ngx_http_limit_req_add_variables,,false,1050,1066,ngx_http_limit_req_add_variables,,,48,ngx_int_t ngx_http_limit_req_add_variables (ngx_conf_t*)
162826,METHOD,http\modules\ngx_http_limit_req_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_limit_req_init(ngx_conf_t *cf)
{
    ngx_http_handler_pt        *h;
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);

    h = ngx_array_push(&cmcf->phases[NGX_HTTP_PREACCESS_PHASE].handlers);
    if (h == NULL) {
        return NGX_ERROR;
    }

    *h = ngx_http_limit_req_handler;

    return NGX_OK;
}",1,1,http\modules\ngx_http_limit_req_module.c,ngx_http_limit_req_init,,false,1069,1085,ngx_http_limit_req_init,,,49,ngx_int_t ngx_http_limit_req_init (ngx_conf_t*)
162873,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,<global>,1,9,http\modules\ngx_http_log_module.c,http\modules\ngx_http_log_module.c:<global>,,false,1,1909,<global>,,,1,
162877,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"typedef u_char *(*ngx_http_log_op_run_pt) (ngx_http_request_t *r, u_char *buf,
    ngx_http_log_op_t *op);",16,26,http\modules\ngx_http_log_module.c,ngx_http_log_op_run_pt,,false,19,20,ngx_http_log_op_run_pt,,,3,"u_char* ngx_http_log_op_run_pt (ngx_http_request_t*,u_char*,ngx_http_log_op_t*)"
162884,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"typedef size_t (*ngx_http_log_op_getlen_pt) (ngx_http_request_t *r,
    uintptr_t data);",16,19,http\modules\ngx_http_log_module.c,ngx_http_log_op_getlen_pt,,false,22,23,ngx_http_log_op_getlen_pt,,,4,"size_t ngx_http_log_op_getlen_pt (ngx_http_request_t*,uintptr_t)"
162937,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static void ngx_http_log_write(ngx_http_request_t *r, ngx_http_log_t *log,
    u_char *buf, size_t len);",13,28,http\modules\ngx_http_log_module.c,ngx_http_log_write,,false,98,99,ngx_http_log_write,,,20,"void ngx_http_log_write (ngx_http_request_t*,ngx_http_log_t*,u_char*,size_t)"
162945,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static ssize_t ngx_http_log_script_write(ngx_http_request_t *r,
    ngx_http_log_script_t *script, u_char **name, u_char *buf, size_t len);",16,74,http\modules\ngx_http_log_module.c,ngx_http_log_script_write,,false,100,101,ngx_http_log_script_write,,,21,"ssize_t ngx_http_log_script_write (ngx_http_request_t*,ngx_http_log_script_t*,u_char**,u_char*,size_t)"
162954,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static void ngx_http_log_flush(ngx_open_file_t *file, ngx_log_t *log);",13,69,http\modules\ngx_http_log_module.c,ngx_http_log_flush,,false,111,111,ngx_http_log_flush,,,22,"void ngx_http_log_flush (ngx_open_file_t*,ngx_log_t*)"
162960,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,static void ngx_http_log_flush_handler(ngx_event_t *ev);,13,55,http\modules\ngx_http_log_module.c,ngx_http_log_flush_handler,,false,112,112,ngx_http_log_flush_handler,,,23,void ngx_http_log_flush_handler (ngx_event_t*)
162965,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static u_char *ngx_http_log_pipe(ngx_http_request_t *r, u_char *buf,
    ngx_http_log_op_t *op);",15,26,http\modules\ngx_http_log_module.c,ngx_http_log_pipe,,false,114,115,ngx_http_log_pipe,,,24,"u_char* ngx_http_log_pipe (ngx_http_request_t*,u_char*,ngx_http_log_op_t*)"
162972,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static u_char *ngx_http_log_time(ngx_http_request_t *r, u_char *buf,
    ngx_http_log_op_t *op);",15,26,http\modules\ngx_http_log_module.c,ngx_http_log_time,,false,116,117,ngx_http_log_time,,,25,"u_char* ngx_http_log_time (ngx_http_request_t*,u_char*,ngx_http_log_op_t*)"
162979,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static u_char *ngx_http_log_iso8601(ngx_http_request_t *r, u_char *buf,
    ngx_http_log_op_t *op);",15,26,http\modules\ngx_http_log_module.c,ngx_http_log_iso8601,,false,118,119,ngx_http_log_iso8601,,,26,"u_char* ngx_http_log_iso8601 (ngx_http_request_t*,u_char*,ngx_http_log_op_t*)"
162986,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static u_char *ngx_http_log_msec(ngx_http_request_t *r, u_char *buf,
    ngx_http_log_op_t *op);",15,26,http\modules\ngx_http_log_module.c,ngx_http_log_msec,,false,120,121,ngx_http_log_msec,,,27,"u_char* ngx_http_log_msec (ngx_http_request_t*,u_char*,ngx_http_log_op_t*)"
162993,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static u_char *ngx_http_log_request_time(ngx_http_request_t *r, u_char *buf,
    ngx_http_log_op_t *op);",15,26,http\modules\ngx_http_log_module.c,ngx_http_log_request_time,,false,122,123,ngx_http_log_request_time,,,28,"u_char* ngx_http_log_request_time (ngx_http_request_t*,u_char*,ngx_http_log_op_t*)"
163000,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static u_char *ngx_http_log_status(ngx_http_request_t *r, u_char *buf,
    ngx_http_log_op_t *op);",15,26,http\modules\ngx_http_log_module.c,ngx_http_log_status,,false,124,125,ngx_http_log_status,,,29,"u_char* ngx_http_log_status (ngx_http_request_t*,u_char*,ngx_http_log_op_t*)"
163007,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static u_char *ngx_http_log_bytes_sent(ngx_http_request_t *r, u_char *buf,
    ngx_http_log_op_t *op);",15,26,http\modules\ngx_http_log_module.c,ngx_http_log_bytes_sent,,false,126,127,ngx_http_log_bytes_sent,,,30,"u_char* ngx_http_log_bytes_sent (ngx_http_request_t*,u_char*,ngx_http_log_op_t*)"
163014,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static u_char *ngx_http_log_body_bytes_sent(ngx_http_request_t *r,
    u_char *buf, ngx_http_log_op_t *op);",15,39,http\modules\ngx_http_log_module.c,ngx_http_log_body_bytes_sent,,false,128,129,ngx_http_log_body_bytes_sent,,,31,"u_char* ngx_http_log_body_bytes_sent (ngx_http_request_t*,u_char*,ngx_http_log_op_t*)"
163021,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static u_char *ngx_http_log_request_length(ngx_http_request_t *r, u_char *buf,
    ngx_http_log_op_t *op);",15,26,http\modules\ngx_http_log_module.c,ngx_http_log_request_length,,false,130,131,ngx_http_log_request_length,,,32,"u_char* ngx_http_log_request_length (ngx_http_request_t*,u_char*,ngx_http_log_op_t*)"
163028,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_log_variable_compile(ngx_conf_t *cf,
    ngx_http_log_op_t *op, ngx_str_t *value, ngx_uint_t escape);",18,63,http\modules\ngx_http_log_module.c,ngx_http_log_variable_compile,,false,133,134,ngx_http_log_variable_compile,,,33,"ngx_int_t ngx_http_log_variable_compile (ngx_conf_t*,ngx_http_log_op_t*,ngx_str_t*,ngx_uint_t)"
163036,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static size_t ngx_http_log_variable_getlen(ngx_http_request_t *r,
    uintptr_t data);",15,19,http\modules\ngx_http_log_module.c,ngx_http_log_variable_getlen,,false,135,136,ngx_http_log_variable_getlen,,,34,"size_t ngx_http_log_variable_getlen (ngx_http_request_t*,uintptr_t)"
163042,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static u_char *ngx_http_log_variable(ngx_http_request_t *r, u_char *buf,
    ngx_http_log_op_t *op);",15,26,http\modules\ngx_http_log_module.c,ngx_http_log_variable,,false,137,138,ngx_http_log_variable,,,35,"u_char* ngx_http_log_variable (ngx_http_request_t*,u_char*,ngx_http_log_op_t*)"
163049,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static uintptr_t ngx_http_log_escape(u_char *dst, u_char *src, size_t size);",18,75,http\modules\ngx_http_log_module.c,ngx_http_log_escape,,false,139,139,ngx_http_log_escape,,,36,"uintptr_t ngx_http_log_escape (u_char*,u_char*,size_t)"
163056,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static size_t ngx_http_log_json_variable_getlen(ngx_http_request_t *r,
    uintptr_t data);",15,19,http\modules\ngx_http_log_module.c,ngx_http_log_json_variable_getlen,,false,140,141,ngx_http_log_json_variable_getlen,,,37,"size_t ngx_http_log_json_variable_getlen (ngx_http_request_t*,uintptr_t)"
163062,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static u_char *ngx_http_log_json_variable(ngx_http_request_t *r, u_char *buf,
    ngx_http_log_op_t *op);",15,26,http\modules\ngx_http_log_module.c,ngx_http_log_json_variable,,false,142,143,ngx_http_log_json_variable,,,38,"u_char* ngx_http_log_json_variable (ngx_http_request_t*,u_char*,ngx_http_log_op_t*)"
163069,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static size_t ngx_http_log_unescaped_variable_getlen(ngx_http_request_t *r,
    uintptr_t data);",15,19,http\modules\ngx_http_log_module.c,ngx_http_log_unescaped_variable_getlen,,false,144,145,ngx_http_log_unescaped_variable_getlen,,,39,"size_t ngx_http_log_unescaped_variable_getlen (ngx_http_request_t*,uintptr_t)"
163075,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static u_char *ngx_http_log_unescaped_variable(ngx_http_request_t *r,
    u_char *buf, ngx_http_log_op_t *op);",15,39,http\modules\ngx_http_log_module.c,ngx_http_log_unescaped_variable,,false,146,147,ngx_http_log_unescaped_variable,,,40,"u_char* ngx_http_log_unescaped_variable (ngx_http_request_t*,u_char*,ngx_http_log_op_t*)"
163082,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,static void *ngx_http_log_create_main_conf(ngx_conf_t *cf);,13,58,http\modules\ngx_http_log_module.c,ngx_http_log_create_main_conf,,false,150,150,ngx_http_log_create_main_conf,,,41,void* ngx_http_log_create_main_conf (ngx_conf_t*)
163087,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,static void *ngx_http_log_create_loc_conf(ngx_conf_t *cf);,13,57,http\modules\ngx_http_log_module.c,ngx_http_log_create_loc_conf,,false,151,151,ngx_http_log_create_loc_conf,,,42,void* ngx_http_log_create_loc_conf (ngx_conf_t*)
163092,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static char *ngx_http_log_merge_loc_conf(ngx_conf_t *cf, void *parent,
    void *child);",13,16,http\modules\ngx_http_log_module.c,ngx_http_log_merge_loc_conf,,false,152,153,ngx_http_log_merge_loc_conf,,,43,"char* ngx_http_log_merge_loc_conf (ngx_conf_t*,void*,void*)"
163099,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static char *ngx_http_log_set_log(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_log_module.c,ngx_http_log_set_log,,false,154,155,ngx_http_log_set_log,,,44,"char* ngx_http_log_set_log (ngx_conf_t*,ngx_command_t*,void*)"
163106,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static char *ngx_http_log_set_format(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_log_module.c,ngx_http_log_set_format,,false,156,157,ngx_http_log_set_format,,,45,"char* ngx_http_log_set_format (ngx_conf_t*,ngx_command_t*,void*)"
163113,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static char *ngx_http_log_compile_format(ngx_conf_t *cf,
    ngx_array_t *flushes, ngx_array_t *ops, ngx_array_t *args, ngx_uint_t s);",13,76,http\modules\ngx_http_log_module.c,ngx_http_log_compile_format,,false,158,159,ngx_http_log_compile_format,,,46,"char* ngx_http_log_compile_format (ngx_conf_t*,ngx_array_t*,ngx_array_t*,ngx_array_t*,ngx_uint_t)"
163122,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static char *ngx_http_log_open_file_cache(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_log_module.c,ngx_http_log_open_file_cache,,false,160,161,ngx_http_log_open_file_cache,,,47,"char* ngx_http_log_open_file_cache (ngx_conf_t*,ngx_command_t*,void*)"
163129,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_log_init(ngx_conf_t *cf);,18,50,http\modules\ngx_http_log_module.c,ngx_http_log_init,,false,162,162,ngx_http_log_init,,,48,ngx_int_t ngx_http_log_init (ngx_conf_t*)
163283,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_log_handler(ngx_http_request_t *r)
{
    u_char                   *line, *p;
    size_t                    len, size;
    ssize_t                   n;
    ngx_str_t                 val;
    ngx_uint_t                i, l;
    ngx_http_log_t           *log;
    ngx_http_log_op_t        *op;
    ngx_http_log_buf_t       *buffer;
    ngx_http_log_loc_conf_t  *lcf;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http log handler"");

    lcf = ngx_http_get_module_loc_conf(r, ngx_http_log_module);

    if (lcf->off) {
        return NGX_OK;
    }

    log = lcf->logs->elts;
    for (l = 0; l < lcf->logs->nelts; l++) {

        if (log[l].filter) {
            if (ngx_http_complex_value(r, log[l].filter, &val) != NGX_OK) {
                return NGX_ERROR;
            }

            if (val.len == 0 || (val.len == 1 && val.data[0] == '0')) {
                continue;
            }
        }

        if (ngx_time() == log[l].disk_...",1,1,http\modules\ngx_http_log_module.c,ngx_http_log_handler,,false,253,402,ngx_http_log_handler,,,61,ngx_int_t ngx_http_log_handler (ngx_http_request_t*)
163791,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static void
ngx_http_log_write(ngx_http_request_t *r, ngx_http_log_t *log, u_char *buf,
    size_t len)
{
    u_char              *name;
    time_t               now;
    ssize_t              n;
    ngx_err_t            err;
#if (NGX_ZLIB)
    ngx_http_log_buf_t  *buffer;
#endif

    if (log->script == NULL) {
        name = log->file->name.data;

#if (NGX_ZLIB)
        buffer = log->file->data;

        if (buffer && buffer->gzip) {
            n = ngx_http_log_gzip(log->file->fd, buf, len, buffer->gzip,
                                  r->connection->log);
        } else {
            n = ngx_write_fd(log->file->fd, buf, len);
        }
#else
        n = ngx_write_fd(log->file->fd, buf, len);
#endif

    } else {
        name = NULL;
        n = ngx_http_log_script_write(r, log->script, &name, buf, len);
    }

    if (n == (ssize_t) len) {
        return;
    }

    now = ngx_time();

    if (n == -1) {
        err = ngx_errno;

        if (err == NGX_ENOSPC) {
            log->...",1,1,http\modules\ngx_http_log_module.c,ngx_http_log_write,,false,405,468,ngx_http_log_write,,,62,"void ngx_http_log_write (ngx_http_request_t*,ngx_http_log_t*,u_char*,size_t)"
163906,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static ssize_t
ngx_http_log_script_write(ngx_http_request_t *r, ngx_http_log_script_t *script,
    u_char **name, u_char *buf, size_t len)
{
    size_t                     root;
    ssize_t                    n;
    ngx_str_t                  log, path;
    ngx_open_file_info_t       of;
    ngx_http_log_loc_conf_t   *llcf;
    ngx_http_core_loc_conf_t  *clcf;

    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    if (!r->root_tested) {

        /* test root directory existence */

        if (ngx_http_map_uri_to_path(r, &path, &root, 0) == NULL) {
            /* simulate successful logging */
            return len;
        }

        path.data[root] = '\0';

        ngx_memzero(&of, sizeof(ngx_open_file_info_t));

        of.valid = clcf->open_file_cache_valid;
        of.min_uses = clcf->open_file_cache_min_uses;
        of.test_dir = 1;
        of.test_only = 1;
        of.errors = clcf->open_file_cache_errors;
        of.events = clcf->open_file_cache_events;

...",1,1,http\modules\ngx_http_log_module.c,ngx_http_log_script_write,,false,471,581,ngx_http_log_script_write,,,63,"ssize_t ngx_http_log_script_write (ngx_http_request_t*,ngx_http_log_script_t*,u_char**,u_char*,size_t)"
164229,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static void
ngx_http_log_flush(ngx_open_file_t *file, ngx_log_t *log)
{
    size_t               len;
    ssize_t              n;
    ngx_http_log_buf_t  *buffer;

    buffer = file->data;

    len = buffer->pos - buffer->start;

    if (len == 0) {
        return;
    }

#if (NGX_ZLIB)
    if (buffer->gzip) {
        n = ngx_http_log_gzip(file->fd, buffer->start, len, buffer->gzip, log);
    } else {
        n = ngx_write_fd(file->fd, buffer->start, len);
    }
#else
    n = ngx_write_fd(file->fd, buffer->start, len);
#endif

    if (n == -1) {
        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,
                      ngx_write_fd_n "" to \""%s\"" failed"",
                      file->name.data);

    } else if ((size_t) n != len) {
        ngx_log_error(NGX_LOG_ALERT, log, 0,
                      ngx_write_fd_n "" to \""%s\"" was incomplete: %z of %uz"",
                      file->name.data, n, len);
    }

    buffer->pos = buffer->start;

    if (buffer->event && buffer->event->timer_...",1,1,http\modules\ngx_http_log_module.c,ngx_http_log_flush,,false,718,759,ngx_http_log_flush,,,64,"void ngx_http_log_flush (ngx_open_file_t*,ngx_log_t*)"
164307,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static void
ngx_http_log_flush_handler(ngx_event_t *ev)
{
    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, ev->log, 0,
                   ""http log buffer flush handler"");

    ngx_http_log_flush(ev->data, ev->log);
}",1,1,http\modules\ngx_http_log_module.c,ngx_http_log_flush_handler,,false,762,769,ngx_http_log_flush_handler,,,65,void ngx_http_log_flush_handler (ngx_event_t*)
164326,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static u_char *
ngx_http_log_copy_short(ngx_http_request_t *r, u_char *buf,
    ngx_http_log_op_t *op)
{
    size_t     len;
    uintptr_t  data;

    len = op->len;
    data = op->data;

    while (len--) {
        *buf++ = (u_char) (data & 0xff);
        data >>= 8;
    }

    return buf;
}",1,1,http\modules\ngx_http_log_module.c,ngx_http_log_copy_short,,false,772,788,ngx_http_log_copy_short,,,66,"u_char ngx_http_log_copy_short (ngx_http_request_t*,u_char*,ngx_http_log_op_t*)"
164362,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static u_char *
ngx_http_log_copy_long(ngx_http_request_t *r, u_char *buf,
    ngx_http_log_op_t *op)
{
    return ngx_cpymem(buf, (u_char *) op->data, op->len);
}",1,1,http\modules\ngx_http_log_module.c,ngx_http_log_copy_long,,false,791,796,ngx_http_log_copy_long,,,67,"u_char ngx_http_log_copy_long (ngx_http_request_t*,u_char*,ngx_http_log_op_t*)"
164380,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static u_char *
ngx_http_log_pipe(ngx_http_request_t *r, u_char *buf, ngx_http_log_op_t *op)
{
    if (r->pipeline) {
        *buf = 'p';
    } else {
        *buf = '.';
    }

    return buf + 1;
}",1,1,http\modules\ngx_http_log_module.c,ngx_http_log_pipe,,false,799,809,ngx_http_log_pipe,,,68,"u_char ngx_http_log_pipe (ngx_http_request_t*,u_char*,ngx_http_log_op_t*)"
164406,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static u_char *
ngx_http_log_time(ngx_http_request_t *r, u_char *buf, ngx_http_log_op_t *op)
{
    return ngx_cpymem(buf, ngx_cached_http_log_time.data,
                      ngx_cached_http_log_time.len);
}",1,1,http\modules\ngx_http_log_module.c,ngx_http_log_time,,false,812,817,ngx_http_log_time,,,69,"u_char ngx_http_log_time (ngx_http_request_t*,u_char*,ngx_http_log_op_t*)"
164422,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static u_char *
ngx_http_log_iso8601(ngx_http_request_t *r, u_char *buf, ngx_http_log_op_t *op)
{
    return ngx_cpymem(buf, ngx_cached_http_log_iso8601.data,
                      ngx_cached_http_log_iso8601.len);
}",1,1,http\modules\ngx_http_log_module.c,ngx_http_log_iso8601,,false,819,824,ngx_http_log_iso8601,,,70,"u_char ngx_http_log_iso8601 (ngx_http_request_t*,u_char*,ngx_http_log_op_t*)"
164438,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static u_char *
ngx_http_log_msec(ngx_http_request_t *r, u_char *buf, ngx_http_log_op_t *op)
{
    ngx_time_t  *tp;

    tp = ngx_timeofday();

    return ngx_sprintf(buf, ""%T.%03M"", tp->sec, tp->msec);
}",1,1,http\modules\ngx_http_log_module.c,ngx_http_log_msec,,false,826,834,ngx_http_log_msec,,,71,"u_char ngx_http_log_msec (ngx_http_request_t*,u_char*,ngx_http_log_op_t*)"
164459,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static u_char *
ngx_http_log_request_time(ngx_http_request_t *r, u_char *buf,
    ngx_http_log_op_t *op)
{
    ngx_time_t      *tp;
    ngx_msec_int_t   ms;

    tp = ngx_timeofday();

    ms = (ngx_msec_int_t)
             ((tp->sec - r->start_sec) * 1000 + (tp->msec - r->start_msec));
    ms = ngx_max(ms, 0);

    return ngx_sprintf(buf, ""%T.%03M"", (time_t) ms / 1000, ms % 1000);
}",1,1,http\modules\ngx_http_log_module.c,ngx_http_log_request_time,,false,837,851,ngx_http_log_request_time,,,72,"u_char ngx_http_log_request_time (ngx_http_request_t*,u_char*,ngx_http_log_op_t*)"
164508,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static u_char *
ngx_http_log_status(ngx_http_request_t *r, u_char *buf, ngx_http_log_op_t *op)
{
    ngx_uint_t  status;

    if (r->err_status) {
        status = r->err_status;

    } else if (r->headers_out.status) {
        status = r->headers_out.status;

    } else if (r->http_version == NGX_HTTP_VERSION_9) {
        status = 9;

    } else {
        status = 0;
    }

    return ngx_sprintf(buf, ""%03ui"", status);
}",1,1,http\modules\ngx_http_log_module.c,ngx_http_log_status,,false,854,873,ngx_http_log_status,,,73,"u_char ngx_http_log_status (ngx_http_request_t*,u_char*,ngx_http_log_op_t*)"
164564,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static u_char *
ngx_http_log_bytes_sent(ngx_http_request_t *r, u_char *buf,
    ngx_http_log_op_t *op)
{
    return ngx_sprintf(buf, ""%O"", r->connection->sent);
}",1,1,http\modules\ngx_http_log_module.c,ngx_http_log_bytes_sent,,false,876,881,ngx_http_log_bytes_sent,,,74,"u_char ngx_http_log_bytes_sent (ngx_http_request_t*,u_char*,ngx_http_log_op_t*)"
164580,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static u_char *
ngx_http_log_body_bytes_sent(ngx_http_request_t *r, u_char *buf,
    ngx_http_log_op_t *op)
{
    off_t  length;

    length = r->connection->sent - r->header_size;

    if (length > 0) {
        return ngx_sprintf(buf, ""%O"", length);
    }

    *buf = '0';

    return buf + 1;
}",1,1,http\modules\ngx_http_log_module.c,ngx_http_log_body_bytes_sent,,false,889,904,ngx_http_log_body_bytes_sent,,,75,"u_char ngx_http_log_body_bytes_sent (ngx_http_request_t*,u_char*,ngx_http_log_op_t*)"
164617,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static u_char *
ngx_http_log_request_length(ngx_http_request_t *r, u_char *buf,
    ngx_http_log_op_t *op)
{
    return ngx_sprintf(buf, ""%O"", r->request_length);
}",1,1,http\modules\ngx_http_log_module.c,ngx_http_log_request_length,,false,907,912,ngx_http_log_request_length,,,76,"u_char ngx_http_log_request_length (ngx_http_request_t*,u_char*,ngx_http_log_op_t*)"
164631,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_log_variable_compile(ngx_conf_t *cf, ngx_http_log_op_t *op,
    ngx_str_t *value, ngx_uint_t escape)
{
    ngx_int_t  index;

    index = ngx_http_get_variable_index(cf, value);
    if (index == NGX_ERROR) {
        return NGX_ERROR;
    }

    op->len = 0;

    switch (escape) {
    case NGX_HTTP_LOG_ESCAPE_JSON:
        op->getlen = ngx_http_log_json_variable_getlen;
        op->run = ngx_http_log_json_variable;
        break;

    case NGX_HTTP_LOG_ESCAPE_NONE:
        op->getlen = ngx_http_log_unescaped_variable_getlen;
        op->run = ngx_http_log_unescaped_variable;
        break;

    default: /* NGX_HTTP_LOG_ESCAPE_DEFAULT */
        op->getlen = ngx_http_log_variable_getlen;
        op->run = ngx_http_log_variable;
    }

    op->data = index;

    return NGX_OK;
}",1,9,http\modules\ngx_http_log_module.c,ngx_http_log_variable_compile,,false,915,947,ngx_http_log_variable_compile,,,77,"ngx_int_t ngx_http_log_variable_compile (ngx_conf_t*,ngx_http_log_op_t*,ngx_str_t*,ngx_uint_t)"
164708,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static size_t
ngx_http_log_variable_getlen(ngx_http_request_t *r, uintptr_t data)
{
    uintptr_t                   len;
    ngx_http_variable_value_t  *value;

    value = ngx_http_get_indexed_variable(r, data);

    if (value == NULL || value->not_found) {
        return 1;
    }

    len = ngx_http_log_escape(NULL, value->data, value->len);

    value->escape = len ? 1 : 0;

    return value->len + len * 3;
}",1,1,http\modules\ngx_http_log_module.c,ngx_http_log_variable_getlen,,false,950,967,ngx_http_log_variable_getlen,,,78,"size_t ngx_http_log_variable_getlen (ngx_http_request_t*,uintptr_t)"
164758,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static u_char *
ngx_http_log_variable(ngx_http_request_t *r, u_char *buf, ngx_http_log_op_t *op)
{
    ngx_http_variable_value_t  *value;

    value = ngx_http_get_indexed_variable(r, op->data);

    if (value == NULL || value->not_found) {
        *buf = '-';
        return buf + 1;
    }

    if (value->escape == 0) {
        return ngx_cpymem(buf, value->data, value->len);

    } else {
        return (u_char *) ngx_http_log_escape(buf, value->data, value->len);
    }
}",1,1,http\modules\ngx_http_log_module.c,ngx_http_log_variable,,false,970,988,ngx_http_log_variable,,,79,"u_char ngx_http_log_variable (ngx_http_request_t*,u_char*,ngx_http_log_op_t*)"
164819,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static uintptr_t
ngx_http_log_escape(u_char *dst, u_char *src, size_t size)
{
    ngx_uint_t      n;
    static u_char   hex[] = ""0123456789ABCDEF"";

    static uint32_t   escape[] = {
        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */

                    /* ?>=< ;:98 7654 3210  /.-, +*)( '&%$ #""!  */
        0x00000004, /* 0000 0000 0000 0000  0000 0000 0000 0100 */

                    /* _^]\ [ZYX WVUT SRQP  ONML KJIH GFED CBA@ */
        0x10000000, /* 0001 0000 0000 0000  0000 0000 0000 0000 */

                    /*  ~}| {zyx wvut srqp  onml kjih gfed cba` */
        0x80000000, /* 1000 0000 0000 0000  0000 0000 0000 0000 */

        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */
        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */
        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */
        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */
    };


    if (dst == NULL) {

        /* find the number of the char...",1,1,http\modules\ngx_http_log_module.c,ngx_http_log_escape,,false,991,1048,ngx_http_log_escape,,,80,"uintptr_t ngx_http_log_escape (u_char*,u_char*,size_t)"
164944,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static size_t
ngx_http_log_json_variable_getlen(ngx_http_request_t *r, uintptr_t data)
{
    uintptr_t                   len;
    ngx_http_variable_value_t  *value;

    value = ngx_http_get_indexed_variable(r, data);

    if (value == NULL || value->not_found) {
        return 0;
    }

    len = ngx_escape_json(NULL, value->data, value->len);

    value->escape = len ? 1 : 0;

    return value->len + len;
}",1,1,http\modules\ngx_http_log_module.c,ngx_http_log_json_variable_getlen,,false,1051,1068,ngx_http_log_json_variable_getlen,,,81,"size_t ngx_http_log_json_variable_getlen (ngx_http_request_t*,uintptr_t)"
164992,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static u_char *
ngx_http_log_json_variable(ngx_http_request_t *r, u_char *buf,
    ngx_http_log_op_t *op)
{
    ngx_http_variable_value_t  *value;

    value = ngx_http_get_indexed_variable(r, op->data);

    if (value == NULL || value->not_found) {
        return buf;
    }

    if (value->escape == 0) {
        return ngx_cpymem(buf, value->data, value->len);

    } else {
        return (u_char *) ngx_escape_json(buf, value->data, value->len);
    }
}",1,1,http\modules\ngx_http_log_module.c,ngx_http_log_json_variable,,false,1071,1089,ngx_http_log_json_variable,,,82,"u_char ngx_http_log_json_variable (ngx_http_request_t*,u_char*,ngx_http_log_op_t*)"
165047,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static size_t
ngx_http_log_unescaped_variable_getlen(ngx_http_request_t *r, uintptr_t data)
{
    ngx_http_variable_value_t  *value;

    value = ngx_http_get_indexed_variable(r, data);

    if (value == NULL || value->not_found) {
        return 0;
    }

    value->escape = 0;

    return value->len;
}",1,1,http\modules\ngx_http_log_module.c,ngx_http_log_unescaped_variable_getlen,,false,1092,1106,ngx_http_log_unescaped_variable_getlen,,,83,"size_t ngx_http_log_unescaped_variable_getlen (ngx_http_request_t*,uintptr_t)"
165079,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static u_char *
ngx_http_log_unescaped_variable(ngx_http_request_t *r, u_char *buf,
    ngx_http_log_op_t *op)
{
    ngx_http_variable_value_t  *value;

    value = ngx_http_get_indexed_variable(r, op->data);

    if (value == NULL || value->not_found) {
        return buf;
    }

    return ngx_cpymem(buf, value->data, value->len);
}",1,1,http\modules\ngx_http_log_module.c,ngx_http_log_unescaped_variable,,false,1109,1122,ngx_http_log_unescaped_variable,,,84,"u_char ngx_http_log_unescaped_variable (ngx_http_request_t*,u_char*,ngx_http_log_op_t*)"
165114,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static void *
ngx_http_log_create_main_conf(ngx_conf_t *cf)
{
    ngx_http_log_main_conf_t  *conf;

    ngx_http_log_fmt_t  *fmt;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_log_main_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    if (ngx_array_init(&conf->formats, cf->pool, 4, sizeof(ngx_http_log_fmt_t))
        != NGX_OK)
    {
        return NULL;
    }

    fmt = ngx_array_push(&conf->formats);
    if (fmt == NULL) {
        return NULL;
    }

    ngx_str_set(&fmt->name, ""combined"");

    fmt->flushes = NULL;

    fmt->ops = ngx_array_create(cf->pool, 16, sizeof(ngx_http_log_op_t));
    if (fmt->ops == NULL) {
        return NULL;
    }

    return conf;
}",1,1,http\modules\ngx_http_log_module.c,ngx_http_log_create_main_conf,,false,1125,1158,ngx_http_log_create_main_conf,,,85,void* ngx_http_log_create_main_conf (ngx_conf_t*)
165200,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static void *
ngx_http_log_create_loc_conf(ngx_conf_t *cf)
{
    ngx_http_log_loc_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_log_loc_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    conf->open_file_cache = NGX_CONF_UNSET_PTR;

    return conf;
}",1,1,http\modules\ngx_http_log_module.c,ngx_http_log_create_loc_conf,,false,1161,1174,ngx_http_log_create_loc_conf,,,86,void* ngx_http_log_create_loc_conf (ngx_conf_t*)
165228,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static char *
ngx_http_log_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_log_loc_conf_t *prev = parent;
    ngx_http_log_loc_conf_t *conf = child;

    ngx_http_log_t            *log;
    ngx_http_log_fmt_t        *fmt;
    ngx_http_log_main_conf_t  *lmcf;

    if (conf->open_file_cache == NGX_CONF_UNSET_PTR) {

        conf->open_file_cache = prev->open_file_cache;
        conf->open_file_cache_valid = prev->open_file_cache_valid;
        conf->open_file_cache_min_uses = prev->open_file_cache_min_uses;

        if (conf->open_file_cache == NGX_CONF_UNSET_PTR) {
            conf->open_file_cache = NULL;
        }
    }

    if (conf->logs || conf->off) {
        return NGX_CONF_OK;
    }

    conf->logs = prev->logs;
    conf->off = prev->off;

    if (conf->logs || conf->off) {
        return NGX_CONF_OK;
    }

    conf->logs = ngx_array_create(cf->pool, 2, sizeof(ngx_http_log_t));
    if (conf->logs == NULL) {
        return NGX_CONF_ERROR;
    }

    l...",1,1,http\modules\ngx_http_log_module.c,ngx_http_log_merge_loc_conf,,false,1177,1234,ngx_http_log_merge_loc_conf,,,87,"char* ngx_http_log_merge_loc_conf (ngx_conf_t*,void*,void*)"
165405,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static char *
ngx_http_log_set_log(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_log_loc_conf_t *llcf = conf;

    ssize_t                            size;
    ngx_int_t                          gzip;
    ngx_uint_t                         i, n;
    ngx_msec_t                         flush;
    ngx_str_t                         *value, name, s;
    ngx_http_log_t                    *log;
    ngx_syslog_peer_t                 *peer;
    ngx_http_log_buf_t                *buffer;
    ngx_http_log_fmt_t                *fmt;
    ngx_http_log_main_conf_t          *lmcf;
    ngx_http_script_compile_t          sc;
    ngx_http_compile_complex_value_t   ccv;

    value = cf->args->elts;

    if (ngx_strcmp(value[1].data, ""off"") == 0) {
        llcf->off = 1;
        if (cf->args->nelts == 2) {
            return NGX_CONF_OK;
        }

        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""invalid parameter \""%V\"""", &value[2]);
        return NGX_CONF_...",1,1,http\modules\ngx_http_log_module.c,ngx_http_log_set_log,,false,1237,1533,ngx_http_log_set_log,,,88,"char* ngx_http_log_set_log (ngx_conf_t*,ngx_command_t*,void*)"
166316,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static char *
ngx_http_log_set_format(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_log_main_conf_t *lmcf = conf;

    ngx_str_t           *value;
    ngx_uint_t           i;
    ngx_http_log_fmt_t  *fmt;

    value = cf->args->elts;

    fmt = lmcf->formats.elts;
    for (i = 0; i < lmcf->formats.nelts; i++) {
        if (fmt[i].name.len == value[1].len
            && ngx_strcmp(fmt[i].name.data, value[1].data) == 0)
        {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               ""duplicate \""log_format\"" name \""%V\"""",
                               &value[1]);
            return NGX_CONF_ERROR;
        }
    }

    fmt = ngx_array_push(&lmcf->formats);
    if (fmt == NULL) {
        return NGX_CONF_ERROR;
    }

    fmt->name = value[1];

    fmt->flushes = ngx_array_create(cf->pool, 4, sizeof(ngx_int_t));
    if (fmt->flushes == NULL) {
        return NGX_CONF_ERROR;
    }

    fmt->ops = ngx_array_create(cf->pool, 16, sizeof(ngx_htt...",1,1,http\modules\ngx_http_log_module.c,ngx_http_log_set_format,,false,1536,1577,ngx_http_log_set_format,,,89,"char* ngx_http_log_set_format (ngx_conf_t*,ngx_command_t*,void*)"
166475,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static char *
ngx_http_log_compile_format(ngx_conf_t *cf, ngx_array_t *flushes,
    ngx_array_t *ops, ngx_array_t *args, ngx_uint_t s)
{
    u_char              *data, *p, ch;
    size_t               i, len;
    ngx_str_t           *value, var;
    ngx_int_t           *flush;
    ngx_uint_t           bracket, escape;
    ngx_http_log_op_t   *op;
    ngx_http_log_var_t  *v;

    escape = NGX_HTTP_LOG_ESCAPE_DEFAULT;
    value = args->elts;

    if (s < args->nelts && ngx_strncmp(value[s].data, ""escape="", 7) == 0) {
        data = value[s].data + 7;

        if (ngx_strcmp(data, ""json"") == 0) {
            escape = NGX_HTTP_LOG_ESCAPE_JSON;

        } else if (ngx_strcmp(data, ""none"") == 0) {
            escape = NGX_HTTP_LOG_ESCAPE_NONE;

        } else if (ngx_strcmp(data, ""default"") != 0) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               ""unknown log format escaping \""%s\"""", data);
            return NGX_CONF_ERROR;
        }

        s++;
    }...",1,13,http\modules\ngx_http_log_module.c,ngx_http_log_compile_format,,false,1580,1756,ngx_http_log_compile_format,,,90,"char* ngx_http_log_compile_format (ngx_conf_t*,ngx_array_t*,ngx_array_t*,ngx_array_t*,ngx_uint_t)"
167013,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static char *
ngx_http_log_open_file_cache(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_log_loc_conf_t *llcf = conf;

    time_t       inactive, valid;
    ngx_str_t   *value, s;
    ngx_int_t    max, min_uses;
    ngx_uint_t   i;

    if (llcf->open_file_cache != NGX_CONF_UNSET_PTR) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    max = 0;
    inactive = 10;
    valid = 60;
    min_uses = 1;

    for (i = 1; i < cf->args->nelts; i++) {

        if (ngx_strncmp(value[i].data, ""max="", 4) == 0) {

            max = ngx_atoi(value[i].data + 4, value[i].len - 4);
            if (max == NGX_ERROR) {
                goto failed;
            }

            continue;
        }

        if (ngx_strncmp(value[i].data, ""inactive="", 9) == 0) {

            s.len = value[i].len - 9;
            s.data = value[i].data + 9;

            inactive = ngx_parse_time(&s, 1);
            if (inactive == (time_t) NGX_ERROR) {
                goto failed;
        ...",1,1,http\modules\ngx_http_log_module.c,ngx_http_log_open_file_cache,,false,1759,1864,ngx_http_log_open_file_cache,,,91,"char* ngx_http_log_open_file_cache (ngx_conf_t*,ngx_command_t*,void*)"
167323,METHOD,http\modules\ngx_http_log_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_log_init(ngx_conf_t *cf)
{
    ngx_str_t                  *value;
    ngx_array_t                 a;
    ngx_http_handler_pt        *h;
    ngx_http_log_fmt_t         *fmt;
    ngx_http_log_main_conf_t   *lmcf;
    ngx_http_core_main_conf_t  *cmcf;

    lmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_log_module);

    if (lmcf->combined_used) {
        if (ngx_array_init(&a, cf->pool, 1, sizeof(ngx_str_t)) != NGX_OK) {
            return NGX_ERROR;
        }

        value = ngx_array_push(&a);
        if (value == NULL) {
            return NGX_ERROR;
        }

        *value = ngx_http_combined_fmt;
        fmt = lmcf->formats.elts;

        if (ngx_http_log_compile_format(cf, NULL, fmt->ops, &a, 0)
            != NGX_CONF_OK)
        {
            return NGX_ERROR;
        }
    }

    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);

    h = ngx_array_push(&cmcf->phases[NGX_HTTP_LOG_PHASE].handlers);
    if (h == NULL) {
    ...",1,1,http\modules\ngx_http_log_module.c,ngx_http_log_init,,false,1867,1909,ngx_http_log_init,,,92,ngx_int_t ngx_http_log_init (ngx_conf_t*)
167435,METHOD,http\modules\ngx_http_map_module.c:<global>,TYPE_DECL,<global>,1,1,http\modules\ngx_http_map_module.c,http\modules\ngx_http_map_module.c:<global>,,false,1,589,<global>,,,1,
167457,METHOD,http\modules\ngx_http_map_module.c:<global>,TYPE_DECL,static void *ngx_http_map_create_conf(ngx_conf_t *cf);,13,53,http\modules\ngx_http_map_module.c,ngx_http_map_create_conf,,false,44,44,ngx_http_map_create_conf,,,8,void* ngx_http_map_create_conf (ngx_conf_t*)
167462,METHOD,http\modules\ngx_http_map_module.c:<global>,TYPE_DECL,"static char *ngx_http_map_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",13,79,http\modules\ngx_http_map_module.c,ngx_http_map_block,,false,45,45,ngx_http_map_block,,,9,"char* ngx_http_map_block (ngx_conf_t*,ngx_command_t*,void*)"
167469,METHOD,http\modules\ngx_http_map_module.c:<global>,TYPE_DECL,"static char *ngx_http_map(ngx_conf_t *cf, ngx_command_t *dummy, void *conf);",13,75,http\modules\ngx_http_map_module.c,ngx_http_map,,false,46,46,ngx_http_map,,,10,"char* ngx_http_map (ngx_conf_t*,ngx_command_t*,void*)"
167546,METHOD,http\modules\ngx_http_map_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_map_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v,
    uintptr_t data)
{
    ngx_http_map_ctx_t  *map = (ngx_http_map_ctx_t *) data;

    ngx_str_t                   val, str;
    ngx_http_complex_value_t   *cv;
    ngx_http_variable_value_t  *value;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http map started"");

    if (ngx_http_complex_value(r, &map->value, &val) != NGX_OK) {
        return NGX_ERROR;
    }

    if (map->hostnames && val.len > 0 && val.data[val.len - 1] == '.') {
        val.len--;
    }

    value = ngx_http_map_find(r, &map->map, &val);

    if (value == NULL) {
        value = map->default_value;
    }

    if (!value->valid) {
        cv = (ngx_http_complex_value_t *) value->data;

        if (ngx_http_complex_value(r, cv, &str) != NGX_OK) {
            return NGX_ERROR;
        }

        v->valid = 1;
        v->no_cacheable = 0;
        v->not_found = 0;
        v->len = str.le...",1,1,http\modules\ngx_http_map_module.c,ngx_http_map_variable,,false,107,155,ngx_http_map_variable,,,17,"ngx_int_t ngx_http_map_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
167707,METHOD,http\modules\ngx_http_map_module.c:<global>,TYPE_DECL,"static void *
ngx_http_map_create_conf(ngx_conf_t *cf)
{
    ngx_http_map_conf_t  *mcf;

    mcf = ngx_palloc(cf->pool, sizeof(ngx_http_map_conf_t));
    if (mcf == NULL) {
        return NULL;
    }

    mcf->hash_max_size = NGX_CONF_UNSET_UINT;
    mcf->hash_bucket_size = NGX_CONF_UNSET_UINT;

    return mcf;
}",1,1,http\modules\ngx_http_map_module.c,ngx_http_map_create_conf,,false,158,172,ngx_http_map_create_conf,,,18,void* ngx_http_map_create_conf (ngx_conf_t*)
167740,METHOD,http\modules\ngx_http_map_module.c:<global>,TYPE_DECL,"static char *
ngx_http_map_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_map_conf_t  *mcf = conf;

    char                              *rv;
    ngx_str_t                         *value, name;
    ngx_conf_t                         save;
    ngx_pool_t                        *pool;
    ngx_hash_init_t                    hash;
    ngx_http_map_ctx_t                *map;
    ngx_http_variable_t               *var;
    ngx_http_map_conf_ctx_t            ctx;
    ngx_http_compile_complex_value_t   ccv;

    if (mcf->hash_max_size == NGX_CONF_UNSET_UINT) {
        mcf->hash_max_size = 2048;
    }

    if (mcf->hash_bucket_size == NGX_CONF_UNSET_UINT) {
        mcf->hash_bucket_size = ngx_cacheline_size;

    } else {
        mcf->hash_bucket_size = ngx_align(mcf->hash_bucket_size,
                                          ngx_cacheline_size);
    }

    map = ngx_pcalloc(cf->pool, sizeof(ngx_http_map_ctx_t));
    if (map == NULL) {
        return NGX_CONF_ERROR;
 ...",1,1,http\modules\ngx_http_map_module.c,ngx_http_map_block,,false,175,365,ngx_http_map_block,,,19,"char* ngx_http_map_block (ngx_conf_t*,ngx_command_t*,void*)"
168315,METHOD,http\modules\ngx_http_map_module.c:<global>,TYPE_DECL,"ngx_http_map_cmp_dns_wildcards(const void *one, const void *two)
{
    ngx_hash_key_t  *first, *second;

    first = (ngx_hash_key_t *) one;
    second = (ngx_hash_key_t *) two;

    return ngx_dns_strcmp(first->key.data, second->key.data);
}",1,1,http\modules\ngx_http_map_module.c,ngx_http_map_cmp_dns_wildcards,,false,369,377,ngx_http_map_cmp_dns_wildcards,,,22,"ANY ngx_http_map_cmp_dns_wildcards (void*,void*)"
168345,METHOD,http\modules\ngx_http_map_module.c:<global>,TYPE_DECL,"static char *
ngx_http_map(ngx_conf_t *cf, ngx_command_t *dummy, void *conf)
{
    u_char                            *data;
    size_t                             len;
    ngx_int_t                          rv;
    ngx_str_t                         *value, v;
    ngx_uint_t                         i, key;
    ngx_http_map_conf_ctx_t           *ctx;
    ngx_http_complex_value_t           cv, *cvp;
    ngx_http_variable_value_t         *var, **vp;
    ngx_http_compile_complex_value_t   ccv;

    ctx = cf->ctx;

    value = cf->args->elts;

    if (cf->args->nelts == 1
        && ngx_strcmp(value[0].data, ""hostnames"") == 0)
    {
        ctx->hostnames = 1;
        return NGX_CONF_OK;
    }

    if (cf->args->nelts == 1
        && ngx_strcmp(value[0].data, ""volatile"") == 0)
    {
        ctx->no_cacheable = 1;
        return NGX_CONF_OK;
    }

    if (cf->args->nelts != 2) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""invalid number of the map paramete...",1,1,http\modules\ngx_http_map_module.c,ngx_http_map,,false,380,589,ngx_http_map,,,23,"char* ngx_http_map (ngx_conf_t*,ngx_command_t*,void*)"
168923,METHOD,http\modules\ngx_http_memcached_module.c:<global>,TYPE_DECL,<global>,1,53,http\modules\ngx_http_memcached_module.c,http\modules\ngx_http_memcached_module.c:<global>,,false,1,732,<global>,,,1,
168935,METHOD,http\modules\ngx_http_memcached_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_memcached_create_request(ngx_http_request_t *r);,18,73,http\modules\ngx_http_memcached_module.c,ngx_http_memcached_create_request,,false,27,27,ngx_http_memcached_create_request,,,5,ngx_int_t ngx_http_memcached_create_request (ngx_http_request_t*)
168940,METHOD,http\modules\ngx_http_memcached_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_memcached_reinit_request(ngx_http_request_t *r);,18,73,http\modules\ngx_http_memcached_module.c,ngx_http_memcached_reinit_request,,false,28,28,ngx_http_memcached_reinit_request,,,6,ngx_int_t ngx_http_memcached_reinit_request (ngx_http_request_t*)
168945,METHOD,http\modules\ngx_http_memcached_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_memcached_process_header(ngx_http_request_t *r);,18,73,http\modules\ngx_http_memcached_module.c,ngx_http_memcached_process_header,,false,29,29,ngx_http_memcached_process_header,,,7,ngx_int_t ngx_http_memcached_process_header (ngx_http_request_t*)
168950,METHOD,http\modules\ngx_http_memcached_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_memcached_filter_init(void *data);,18,59,http\modules\ngx_http_memcached_module.c,ngx_http_memcached_filter_init,,false,30,30,ngx_http_memcached_filter_init,,,8,ngx_int_t ngx_http_memcached_filter_init (void*)
168955,METHOD,http\modules\ngx_http_memcached_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_memcached_filter(void *data, ssize_t bytes);",18,69,http\modules\ngx_http_memcached_module.c,ngx_http_memcached_filter,,false,31,31,ngx_http_memcached_filter,,,9,"ngx_int_t ngx_http_memcached_filter (void*,ssize_t)"
168961,METHOD,http\modules\ngx_http_memcached_module.c:<global>,TYPE_DECL,static void ngx_http_memcached_abort_request(ngx_http_request_t *r);,13,67,http\modules\ngx_http_memcached_module.c,ngx_http_memcached_abort_request,,false,32,32,ngx_http_memcached_abort_request,,,10,void ngx_http_memcached_abort_request (ngx_http_request_t*)
168966,METHOD,http\modules\ngx_http_memcached_module.c:<global>,TYPE_DECL,"static void ngx_http_memcached_finalize_request(ngx_http_request_t *r,
    ngx_int_t rc);",13,17,http\modules\ngx_http_memcached_module.c,ngx_http_memcached_finalize_request,,false,33,34,ngx_http_memcached_finalize_request,,,11,"void ngx_http_memcached_finalize_request (ngx_http_request_t*,ngx_int_t)"
168972,METHOD,http\modules\ngx_http_memcached_module.c:<global>,TYPE_DECL,static void *ngx_http_memcached_create_loc_conf(ngx_conf_t *cf);,13,63,http\modules\ngx_http_memcached_module.c,ngx_http_memcached_create_loc_conf,,false,36,36,ngx_http_memcached_create_loc_conf,,,12,void* ngx_http_memcached_create_loc_conf (ngx_conf_t*)
168977,METHOD,http\modules\ngx_http_memcached_module.c:<global>,TYPE_DECL,"static char *ngx_http_memcached_merge_loc_conf(ngx_conf_t *cf,
    void *parent, void *child);",13,30,http\modules\ngx_http_memcached_module.c,ngx_http_memcached_merge_loc_conf,,false,37,38,ngx_http_memcached_merge_loc_conf,,,13,"char* ngx_http_memcached_merge_loc_conf (ngx_conf_t*,void*,void*)"
168984,METHOD,http\modules\ngx_http_memcached_module.c:<global>,TYPE_DECL,"static char *ngx_http_memcached_pass(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_memcached_module.c,ngx_http_memcached_pass,,false,40,41,ngx_http_memcached_pass,,,14,"char* ngx_http_memcached_pass (ngx_conf_t*,ngx_command_t*,void*)"
169249,METHOD,http\modules\ngx_http_memcached_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_memcached_handler(ngx_http_request_t *r)
{
    ngx_int_t                       rc;
    ngx_http_upstream_t            *u;
    ngx_http_memcached_ctx_t       *ctx;
    ngx_http_memcached_loc_conf_t  *mlcf;

    if (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD))) {
        return NGX_HTTP_NOT_ALLOWED;
    }

    rc = ngx_http_discard_request_body(r);

    if (rc != NGX_OK) {
        return rc;
    }

    if (ngx_http_set_content_type(r) != NGX_OK) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    if (ngx_http_upstream_create(r) != NGX_OK) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    u = r->upstream;

    ngx_str_set(&u->schema, ""memcached://"");
    u->output.tag = (ngx_buf_tag_t) &ngx_http_memcached_module;

    mlcf = ngx_http_get_module_loc_conf(r, ngx_http_memcached_module);

    u->conf = &mlcf->upstream;

    u->create_request = ngx_http_memcached_create_request;
    u->reinit_request = ngx_http_memcached_reinit_request;
    u->proc...",1,1,http\modules\ngx_http_memcached_module.c,ngx_http_memcached_handler,,false,175,234,ngx_http_memcached_handler,,,26,ngx_int_t ngx_http_memcached_handler (ngx_http_request_t*)
169404,METHOD,http\modules\ngx_http_memcached_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_memcached_create_request(ngx_http_request_t *r)
{
    size_t                          len;
    uintptr_t                       escape;
    ngx_buf_t                      *b;
    ngx_chain_t                    *cl;
    ngx_http_memcached_ctx_t       *ctx;
    ngx_http_variable_value_t      *vv;
    ngx_http_memcached_loc_conf_t  *mlcf;

    mlcf = ngx_http_get_module_loc_conf(r, ngx_http_memcached_module);

    vv = ngx_http_get_indexed_variable(r, mlcf->index);

    if (vv == NULL || vv->not_found || vv->len == 0) {
        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                      ""the \""$memcached_key\"" variable is not set"");
        return NGX_ERROR;
    }

    escape = 2 * ngx_escape_uri(NULL, vv->data, vv->len, NGX_ESCAPE_MEMCACHED);

    len = sizeof(""get "") - 1 + vv->len + escape + sizeof(CRLF) - 1;

    b = ngx_create_temp_buf(r->pool, len);
    if (b == NULL) {
        return NGX_ERROR;
    }

    cl = ngx_alloc_chain_link(r->pool);
  ...",1,1,http\modules\ngx_http_memcached_module.c,ngx_http_memcached_create_request,,false,237,299,ngx_http_memcached_create_request,,,27,ngx_int_t ngx_http_memcached_create_request (ngx_http_request_t*)
169652,METHOD,http\modules\ngx_http_memcached_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_memcached_reinit_request(ngx_http_request_t *r)
{
    return NGX_OK;
}",1,1,http\modules\ngx_http_memcached_module.c,ngx_http_memcached_reinit_request,,false,302,306,ngx_http_memcached_reinit_request,,,28,ngx_int_t ngx_http_memcached_reinit_request (ngx_http_request_t*)
169659,METHOD,http\modules\ngx_http_memcached_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_memcached_process_header(ngx_http_request_t *r)
{
    u_char                         *p, *start;
    ngx_str_t                       line;
    ngx_uint_t                      flags;
    ngx_table_elt_t                *h;
    ngx_http_upstream_t            *u;
    ngx_http_memcached_ctx_t       *ctx;
    ngx_http_memcached_loc_conf_t  *mlcf;

    u = r->upstream;

    for (p = u->buffer.pos; p < u->buffer.last; p++) {
        if (*p == LF) {
            goto found;
        }
    }

    return NGX_AGAIN;

found:

    line.data = u->buffer.pos;
    line.len = p - u->buffer.pos;

    if (line.len == 0 || *(p - 1) != CR) {
        goto no_valid;
    }

    *p = '\0';
    line.len--;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""memcached: \""%V\"""", &line);

    p = u->buffer.pos;

    ctx = ngx_http_get_module_ctx(r, ngx_http_memcached_module);
    mlcf = ngx_http_get_module_loc_conf(r, ngx_http_memcached_module);

    if (ngx...",1,1,http\modules\ngx_http_memcached_module.c,ngx_http_memcached_process_header,,false,309,449,ngx_http_memcached_process_header,,,29,ngx_int_t ngx_http_memcached_process_header (ngx_http_request_t*)
170088,METHOD,http\modules\ngx_http_memcached_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_memcached_filter_init(void *data)
{
    ngx_http_memcached_ctx_t  *ctx = data;

    ngx_http_upstream_t  *u;

    u = ctx->request->upstream;

    if (u->headers_in.status_n != 404) {
        u->length = u->headers_in.content_length_n + NGX_HTTP_MEMCACHED_END;
        ctx->rest = NGX_HTTP_MEMCACHED_END;

    } else {
        u->length = 0;
    }

    return NGX_OK;
}",1,53,http\modules\ngx_http_memcached_module.c,ngx_http_memcached_filter_init,,false,452,470,ngx_http_memcached_filter_init,,,30,ngx_int_t ngx_http_memcached_filter_init (void*)
170149,METHOD,http\modules\ngx_http_memcached_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_memcached_filter(void *data, ssize_t bytes)
{
    ngx_http_memcached_ctx_t  *ctx = data;

    u_char               *last;
    ngx_buf_t            *b;
    ngx_chain_t          *cl, **ll;
    ngx_http_upstream_t  *u;

    u = ctx->request->upstream;
    b = &u->buffer;

    if (u->length == (ssize_t) ctx->rest) {

        if (ngx_strncmp(b->last,
                   ngx_http_memcached_end + NGX_HTTP_MEMCACHED_END - ctx->rest,
                   bytes)
            != 0)
        {
            ngx_log_error(NGX_LOG_ERR, ctx->request->connection->log, 0,
                          ""memcached sent invalid trailer"");

            u->length = 0;
            ctx->rest = 0;

            return NGX_OK;
        }

        u->length -= bytes;
        ctx->rest -= bytes;

        if (u->length == 0) {
            u->keepalive = 1;
        }

        return NGX_OK;
    }

    for (cl = u->out_bufs, ll = &u->out_bufs; cl; cl = cl->next) {
        ll = &cl->next;
    }

    c...",1,44,http\modules\ngx_http_memcached_module.c,ngx_http_memcached_filter,,false,473,565,ngx_http_memcached_filter,,,31,"ngx_int_t ngx_http_memcached_filter (void*,ssize_t)"
170506,METHOD,http\modules\ngx_http_memcached_module.c:<global>,TYPE_DECL,"static void
ngx_http_memcached_abort_request(ngx_http_request_t *r)
{
    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""abort http memcached request"");
    return;
}",1,1,http\modules\ngx_http_memcached_module.c,ngx_http_memcached_abort_request,,false,568,574,ngx_http_memcached_abort_request,,,32,void ngx_http_memcached_abort_request (ngx_http_request_t*)
170521,METHOD,http\modules\ngx_http_memcached_module.c:<global>,TYPE_DECL,"static void
ngx_http_memcached_finalize_request(ngx_http_request_t *r, ngx_int_t rc)
{
    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""finalize http memcached request"");
    return;
}",1,1,http\modules\ngx_http_memcached_module.c,ngx_http_memcached_finalize_request,,false,577,583,ngx_http_memcached_finalize_request,,,33,"void ngx_http_memcached_finalize_request (ngx_http_request_t*,ngx_int_t)"
170537,METHOD,http\modules\ngx_http_memcached_module.c:<global>,TYPE_DECL,"static void *
ngx_http_memcached_create_loc_conf(ngx_conf_t *cf)
{
    ngx_http_memcached_loc_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_memcached_loc_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     conf->upstream.bufs.num = 0;
     *     conf->upstream.next_upstream = 0;
     *     conf->upstream.temp_path = NULL;
     */

    conf->upstream.local = NGX_CONF_UNSET_PTR;
    conf->upstream.socket_keepalive = NGX_CONF_UNSET;
    conf->upstream.next_upstream_tries = NGX_CONF_UNSET_UINT;
    conf->upstream.connect_timeout = NGX_CONF_UNSET_MSEC;
    conf->upstream.send_timeout = NGX_CONF_UNSET_MSEC;
    conf->upstream.read_timeout = NGX_CONF_UNSET_MSEC;
    conf->upstream.next_upstream_timeout = NGX_CONF_UNSET_MSEC;

    conf->upstream.buffer_size = NGX_CONF_UNSET_SIZE;

    /* the hardcoded values */
    conf->upstream.cyclic_temp_file = 0;
    conf->upstream.buffering = 0;
    conf->upstream.ignor...",1,1,http\modules\ngx_http_memcached_module.c,ngx_http_memcached_create_loc_conf,,false,586,633,ngx_http_memcached_create_loc_conf,,,34,void* ngx_http_memcached_create_loc_conf (ngx_conf_t*)
170719,METHOD,http\modules\ngx_http_memcached_module.c:<global>,TYPE_DECL,"static char *
ngx_http_memcached_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_memcached_loc_conf_t *prev = parent;
    ngx_http_memcached_loc_conf_t *conf = child;

    ngx_conf_merge_ptr_value(conf->upstream.local,
                              prev->upstream.local, NULL);

    ngx_conf_merge_value(conf->upstream.socket_keepalive,
                              prev->upstream.socket_keepalive, 0);

    ngx_conf_merge_uint_value(conf->upstream.next_upstream_tries,
                              prev->upstream.next_upstream_tries, 0);

    ngx_conf_merge_msec_value(conf->upstream.connect_timeout,
                              prev->upstream.connect_timeout, 60000);

    ngx_conf_merge_msec_value(conf->upstream.send_timeout,
                              prev->upstream.send_timeout, 60000);

    ngx_conf_merge_msec_value(conf->upstream.read_timeout,
                              prev->upstream.read_timeout, 60000);

    ngx_conf_merge_msec_value(conf->upstrea...",1,1,http\modules\ngx_http_memcached_module.c,ngx_http_memcached_merge_loc_conf,,false,636,689,ngx_http_memcached_merge_loc_conf,,,35,"char* ngx_http_memcached_merge_loc_conf (ngx_conf_t*,void*,void*)"
170910,METHOD,http\modules\ngx_http_memcached_module.c:<global>,TYPE_DECL,"static char *
ngx_http_memcached_pass(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_memcached_loc_conf_t *mlcf = conf;

    ngx_str_t                 *value;
    ngx_url_t                  u;
    ngx_http_core_loc_conf_t  *clcf;

    if (mlcf->upstream.upstream) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    ngx_memzero(&u, sizeof(ngx_url_t));

    u.url = value[1];
    u.no_resolve = 1;

    mlcf->upstream.upstream = ngx_http_upstream_add(cf, &u, 0);
    if (mlcf->upstream.upstream == NULL) {
        return NGX_CONF_ERROR;
    }

    clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);

    clcf->handler = ngx_http_memcached_handler;

    if (clcf->name.len && clcf->name.data[clcf->name.len - 1] == '/') {
        clcf->auto_redirect = 1;
    }

    mlcf->index = ngx_http_get_variable_index(cf, &ngx_http_memcached_key);

    if (mlcf->index == NGX_ERROR) {
        return NGX_CONF_ERROR;
    }

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_memcached_module.c,ngx_http_memcached_pass,,false,692,732,ngx_http_memcached_pass,,,36,"char* ngx_http_memcached_pass (ngx_conf_t*,ngx_command_t*,void*)"
171045,METHOD,http\modules\ngx_http_mirror_module.c:<global>,TYPE_DECL,<global>,1,1,http\modules\ngx_http_mirror_module.c,http\modules\ngx_http_mirror_module.c:<global>,,false,1,264,<global>,,,1,
171054,METHOD,http\modules\ngx_http_mirror_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_mirror_handler(ngx_http_request_t *r);,18,63,http\modules\ngx_http_mirror_module.c,ngx_http_mirror_handler,,false,24,24,ngx_http_mirror_handler,,,5,ngx_int_t ngx_http_mirror_handler (ngx_http_request_t*)
171059,METHOD,http\modules\ngx_http_mirror_module.c:<global>,TYPE_DECL,static void ngx_http_mirror_body_handler(ngx_http_request_t *r);,13,63,http\modules\ngx_http_mirror_module.c,ngx_http_mirror_body_handler,,false,25,25,ngx_http_mirror_body_handler,,,6,void ngx_http_mirror_body_handler (ngx_http_request_t*)
171064,METHOD,http\modules\ngx_http_mirror_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_mirror_handler_internal(ngx_http_request_t *r);,18,72,http\modules\ngx_http_mirror_module.c,ngx_http_mirror_handler_internal,,false,26,26,ngx_http_mirror_handler_internal,,,7,ngx_int_t ngx_http_mirror_handler_internal (ngx_http_request_t*)
171069,METHOD,http\modules\ngx_http_mirror_module.c:<global>,TYPE_DECL,static void *ngx_http_mirror_create_loc_conf(ngx_conf_t *cf);,13,60,http\modules\ngx_http_mirror_module.c,ngx_http_mirror_create_loc_conf,,false,27,27,ngx_http_mirror_create_loc_conf,,,8,void* ngx_http_mirror_create_loc_conf (ngx_conf_t*)
171074,METHOD,http\modules\ngx_http_mirror_module.c:<global>,TYPE_DECL,"static char *ngx_http_mirror_merge_loc_conf(ngx_conf_t *cf, void *parent,
    void *child);",13,16,http\modules\ngx_http_mirror_module.c,ngx_http_mirror_merge_loc_conf,,false,28,29,ngx_http_mirror_merge_loc_conf,,,9,"char* ngx_http_mirror_merge_loc_conf (ngx_conf_t*,void*,void*)"
171081,METHOD,http\modules\ngx_http_mirror_module.c:<global>,TYPE_DECL,"static char *ngx_http_mirror(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",13,76,http\modules\ngx_http_mirror_module.c,ngx_http_mirror,,false,30,30,ngx_http_mirror,,,10,"char* ngx_http_mirror (ngx_conf_t*,ngx_command_t*,void*)"
171088,METHOD,http\modules\ngx_http_mirror_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_mirror_init(ngx_conf_t *cf);,18,53,http\modules\ngx_http_mirror_module.c,ngx_http_mirror_init,,false,31,31,ngx_http_mirror_init,,,11,ngx_int_t ngx_http_mirror_init (ngx_conf_t*)
171157,METHOD,http\modules\ngx_http_mirror_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_mirror_handler(ngx_http_request_t *r)
{
    ngx_int_t                    rc;
    ngx_http_mirror_ctx_t       *ctx;
    ngx_http_mirror_loc_conf_t  *mlcf;

    if (r != r->main) {
        return NGX_DECLINED;
    }

    mlcf = ngx_http_get_module_loc_conf(r, ngx_http_mirror_module);

    if (mlcf->mirror == NULL) {
        return NGX_DECLINED;
    }

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, ""mirror handler"");

    if (mlcf->request_body) {
        ctx = ngx_http_get_module_ctx(r, ngx_http_mirror_module);

        if (ctx) {
            return ctx->status;
        }

        ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_mirror_ctx_t));
        if (ctx == NULL) {
            return NGX_ERROR;
        }

        ctx->status = NGX_DONE;

        ngx_http_set_ctx(r, ctx, ngx_http_mirror_module);

        rc = ngx_http_read_client_request_body(r, ngx_http_mirror_body_handler);
        if (rc >= NGX_HTTP_SPECIAL_RESPONSE) {
            return rc;
...",1,1,http\modules\ngx_http_mirror_module.c,ngx_http_mirror_handler,,false,85,130,ngx_http_mirror_handler,,,18,ngx_int_t ngx_http_mirror_handler (ngx_http_request_t*)
171258,METHOD,http\modules\ngx_http_mirror_module.c:<global>,TYPE_DECL,"static void
ngx_http_mirror_body_handler(ngx_http_request_t *r)
{
    ngx_http_mirror_ctx_t  *ctx;

    ctx = ngx_http_get_module_ctx(r, ngx_http_mirror_module);

    ctx->status = ngx_http_mirror_handler_internal(r);

    r->preserve_body = 1;

    r->write_event_handler = ngx_http_core_run_phases;
    ngx_http_core_run_phases(r);
}",1,1,http\modules\ngx_http_mirror_module.c,ngx_http_mirror_body_handler,,false,133,146,ngx_http_mirror_body_handler,,,19,void ngx_http_mirror_body_handler (ngx_http_request_t*)
171287,METHOD,http\modules\ngx_http_mirror_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_mirror_handler_internal(ngx_http_request_t *r)
{
    ngx_str_t                   *name;
    ngx_uint_t                   i;
    ngx_http_request_t          *sr;
    ngx_http_mirror_loc_conf_t  *mlcf;

    mlcf = ngx_http_get_module_loc_conf(r, ngx_http_mirror_module);

    name = mlcf->mirror->elts;

    for (i = 0; i < mlcf->mirror->nelts; i++) {
        if (ngx_http_subrequest(r, &name[i], &r->args, &sr, NULL,
                                NGX_HTTP_SUBREQUEST_BACKGROUND)
            != NGX_OK)
        {
            return NGX_HTTP_INTERNAL_SERVER_ERROR;
        }

        sr->header_only = 1;
        sr->method = r->method;
        sr->method_name = r->method_name;
    }

    return NGX_DECLINED;
}",1,1,http\modules\ngx_http_mirror_module.c,ngx_http_mirror_handler_internal,,false,149,175,ngx_http_mirror_handler_internal,,,20,ngx_int_t ngx_http_mirror_handler_internal (ngx_http_request_t*)
171364,METHOD,http\modules\ngx_http_mirror_module.c:<global>,TYPE_DECL,"static void *
ngx_http_mirror_create_loc_conf(ngx_conf_t *cf)
{
    ngx_http_mirror_loc_conf_t  *mlcf;

    mlcf = ngx_pcalloc(cf->pool, sizeof(ngx_http_mirror_loc_conf_t));
    if (mlcf == NULL) {
        return NULL;
    }

    mlcf->mirror = NGX_CONF_UNSET_PTR;
    mlcf->request_body = NGX_CONF_UNSET;

    return mlcf;
}",1,1,http\modules\ngx_http_mirror_module.c,ngx_http_mirror_create_loc_conf,,false,178,192,ngx_http_mirror_create_loc_conf,,,21,void* ngx_http_mirror_create_loc_conf (ngx_conf_t*)
171397,METHOD,http\modules\ngx_http_mirror_module.c:<global>,TYPE_DECL,"static char *
ngx_http_mirror_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_mirror_loc_conf_t *prev = parent;
    ngx_http_mirror_loc_conf_t *conf = child;

    ngx_conf_merge_ptr_value(conf->mirror, prev->mirror, NULL);
    ngx_conf_merge_value(conf->request_body, prev->request_body, 1);

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_mirror_module.c,ngx_http_mirror_merge_loc_conf,,false,195,205,ngx_http_mirror_merge_loc_conf,,,22,"char* ngx_http_mirror_merge_loc_conf (ngx_conf_t*,void*,void*)"
171430,METHOD,http\modules\ngx_http_mirror_module.c:<global>,TYPE_DECL,"static char *
ngx_http_mirror(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_mirror_loc_conf_t *mlcf = conf;

    ngx_str_t  *value, *s;

    value = cf->args->elts;

    if (ngx_strcmp(value[1].data, ""off"") == 0) {
        if (mlcf->mirror != NGX_CONF_UNSET_PTR) {
            return ""is duplicate"";
        }

        mlcf->mirror = NULL;
        return NGX_CONF_OK;
    }

    if (mlcf->mirror == NULL) {
        return ""is duplicate"";
    }

    if (mlcf->mirror == NGX_CONF_UNSET_PTR) {
        mlcf->mirror = ngx_array_create(cf->pool, 4, sizeof(ngx_str_t));
        if (mlcf->mirror == NULL) {
            return NGX_CONF_ERROR;
        }
    }

    s = ngx_array_push(mlcf->mirror);
    if (s == NULL) {
        return NGX_CONF_ERROR;
    }

    *s = value[1];

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_mirror_module.c,ngx_http_mirror,,false,208,245,ngx_http_mirror,,,23,"char* ngx_http_mirror (ngx_conf_t*,ngx_command_t*,void*)"
171534,METHOD,http\modules\ngx_http_mirror_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_mirror_init(ngx_conf_t *cf)
{
    ngx_http_handler_pt        *h;
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);

    h = ngx_array_push(&cmcf->phases[NGX_HTTP_PRECONTENT_PHASE].handlers);
    if (h == NULL) {
        return NGX_ERROR;
    }

    *h = ngx_http_mirror_handler;

    return NGX_OK;
}",1,1,http\modules\ngx_http_mirror_module.c,ngx_http_mirror_init,,false,248,264,ngx_http_mirror_init,,,24,ngx_int_t ngx_http_mirror_init (ngx_conf_t*)
171579,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,<global>,1,30,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:<global>,,false,1,3615,<global>,,,1,
171589,METHOD,<empty>,<empty>,<empty>,1,,http\modules\ngx_http_mp4_module.c,ngx_mp4_stsc_entry_t:<clinit>,,false,49,,<clinit>,,,4,
171655,METHOD,<empty>,<empty>,<empty>,1,,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_trak_t:<clinit>,,false,56,,<clinit>,,,55,
171697,METHOD,<empty>,<empty>,<empty>,1,,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_file_t:<clinit>,,false,119,,<clinit>,,,31,
171710,METHOD,ngx_http_mp4_atom_handler_t,TYPE_DECL,"ngx_int_t           (*handler)(ngx_http_mp4_file_t *mp4,
                                   uint64_t atom_data_size);",25,59,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_atom_handler_t.handler,,false,161,162,handler,,,2,"ngx_int_t ngx_http_mp4_atom_handler_t.handler (ngx_http_mp4_file_t*,uint64_t)"
171717,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_mp4_handler(ngx_http_request_t *r);,18,60,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_handler,,false,225,225,ngx_http_mp4_handler,,,11,ngx_int_t ngx_http_mp4_handler (ngx_http_request_t*)
171722,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_mp4_atofp(u_char *line, size_t n, size_t point);",18,73,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_atofp,,false,226,226,ngx_http_mp4_atofp,,,12,"ngx_int_t ngx_http_mp4_atofp (u_char*,size_t,size_t)"
171729,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_mp4_process(ngx_http_mp4_file_t *mp4);,18,63,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_process,,false,228,228,ngx_http_mp4_process,,,13,ngx_int_t ngx_http_mp4_process (ngx_http_mp4_file_t*)
171734,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_mp4_read_atom(ngx_http_mp4_file_t *mp4,
    ngx_http_mp4_atom_handler_t *atom, uint64_t atom_data_size);",18,63,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_atom,,false,229,230,ngx_http_mp4_read_atom,,,14,"ngx_int_t ngx_http_mp4_read_atom (ngx_http_mp4_file_t*,ngx_http_mp4_atom_handler_t*,uint64_t)"
171741,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_mp4_read(ngx_http_mp4_file_t *mp4, size_t size);",18,73,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read,,false,231,231,ngx_http_mp4_read,,,15,"ngx_int_t ngx_http_mp4_read (ngx_http_mp4_file_t*,size_t)"
171747,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_mp4_read_ftyp_atom(ngx_http_mp4_file_t *mp4,
    uint64_t atom_data_size);",18,28,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_ftyp_atom,,false,232,233,ngx_http_mp4_read_ftyp_atom,,,16,"ngx_int_t ngx_http_mp4_read_ftyp_atom (ngx_http_mp4_file_t*,uint64_t)"
171753,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_mp4_read_moov_atom(ngx_http_mp4_file_t *mp4,
    uint64_t atom_data_size);",18,28,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_moov_atom,,false,234,235,ngx_http_mp4_read_moov_atom,,,17,"ngx_int_t ngx_http_mp4_read_moov_atom (ngx_http_mp4_file_t*,uint64_t)"
171759,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_mp4_read_mdat_atom(ngx_http_mp4_file_t *mp4,
    uint64_t atom_data_size);",18,28,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_mdat_atom,,false,236,237,ngx_http_mp4_read_mdat_atom,,,18,"ngx_int_t ngx_http_mp4_read_mdat_atom (ngx_http_mp4_file_t*,uint64_t)"
171765,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static size_t ngx_http_mp4_update_mdat_atom(ngx_http_mp4_file_t *mp4,
    off_t start_offset, off_t end_offset);",15,41,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_update_mdat_atom,,false,238,239,ngx_http_mp4_update_mdat_atom,,,19,"size_t ngx_http_mp4_update_mdat_atom (ngx_http_mp4_file_t*,off_t,off_t)"
171772,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_mp4_read_mvhd_atom(ngx_http_mp4_file_t *mp4,
    uint64_t atom_data_size);",18,28,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_mvhd_atom,,false,240,241,ngx_http_mp4_read_mvhd_atom,,,20,"ngx_int_t ngx_http_mp4_read_mvhd_atom (ngx_http_mp4_file_t*,uint64_t)"
171778,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_mp4_read_trak_atom(ngx_http_mp4_file_t *mp4,
    uint64_t atom_data_size);",18,28,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_trak_atom,,false,242,243,ngx_http_mp4_read_trak_atom,,,21,"ngx_int_t ngx_http_mp4_read_trak_atom (ngx_http_mp4_file_t*,uint64_t)"
171784,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static void ngx_http_mp4_update_trak_atom(ngx_http_mp4_file_t *mp4,
    ngx_http_mp4_trak_t *trak);",13,30,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_update_trak_atom,,false,244,245,ngx_http_mp4_update_trak_atom,,,22,"void ngx_http_mp4_update_trak_atom (ngx_http_mp4_file_t*,ngx_http_mp4_trak_t*)"
171790,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_mp4_read_cmov_atom(ngx_http_mp4_file_t *mp4,
    uint64_t atom_data_size);",18,28,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_cmov_atom,,false,246,247,ngx_http_mp4_read_cmov_atom,,,23,"ngx_int_t ngx_http_mp4_read_cmov_atom (ngx_http_mp4_file_t*,uint64_t)"
171796,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_mp4_read_tkhd_atom(ngx_http_mp4_file_t *mp4,
    uint64_t atom_data_size);",18,28,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_tkhd_atom,,false,248,249,ngx_http_mp4_read_tkhd_atom,,,24,"ngx_int_t ngx_http_mp4_read_tkhd_atom (ngx_http_mp4_file_t*,uint64_t)"
171802,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_mp4_read_mdia_atom(ngx_http_mp4_file_t *mp4,
    uint64_t atom_data_size);",18,28,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_mdia_atom,,false,250,251,ngx_http_mp4_read_mdia_atom,,,25,"ngx_int_t ngx_http_mp4_read_mdia_atom (ngx_http_mp4_file_t*,uint64_t)"
171808,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static void ngx_http_mp4_update_mdia_atom(ngx_http_mp4_file_t *mp4,
    ngx_http_mp4_trak_t *trak);",13,30,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_update_mdia_atom,,false,252,253,ngx_http_mp4_update_mdia_atom,,,26,"void ngx_http_mp4_update_mdia_atom (ngx_http_mp4_file_t*,ngx_http_mp4_trak_t*)"
171814,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_mp4_read_mdhd_atom(ngx_http_mp4_file_t *mp4,
    uint64_t atom_data_size);",18,28,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_mdhd_atom,,false,254,255,ngx_http_mp4_read_mdhd_atom,,,27,"ngx_int_t ngx_http_mp4_read_mdhd_atom (ngx_http_mp4_file_t*,uint64_t)"
171820,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_mp4_read_hdlr_atom(ngx_http_mp4_file_t *mp4,
    uint64_t atom_data_size);",18,28,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_hdlr_atom,,false,256,257,ngx_http_mp4_read_hdlr_atom,,,28,"ngx_int_t ngx_http_mp4_read_hdlr_atom (ngx_http_mp4_file_t*,uint64_t)"
171826,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_mp4_read_minf_atom(ngx_http_mp4_file_t *mp4,
    uint64_t atom_data_size);",18,28,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_minf_atom,,false,258,259,ngx_http_mp4_read_minf_atom,,,29,"ngx_int_t ngx_http_mp4_read_minf_atom (ngx_http_mp4_file_t*,uint64_t)"
171832,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static void ngx_http_mp4_update_minf_atom(ngx_http_mp4_file_t *mp4,
    ngx_http_mp4_trak_t *trak);",13,30,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_update_minf_atom,,false,260,261,ngx_http_mp4_update_minf_atom,,,30,"void ngx_http_mp4_update_minf_atom (ngx_http_mp4_file_t*,ngx_http_mp4_trak_t*)"
171838,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_mp4_read_dinf_atom(ngx_http_mp4_file_t *mp4,
    uint64_t atom_data_size);",18,28,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_dinf_atom,,false,262,263,ngx_http_mp4_read_dinf_atom,,,31,"ngx_int_t ngx_http_mp4_read_dinf_atom (ngx_http_mp4_file_t*,uint64_t)"
171844,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_mp4_read_vmhd_atom(ngx_http_mp4_file_t *mp4,
    uint64_t atom_data_size);",18,28,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_vmhd_atom,,false,264,265,ngx_http_mp4_read_vmhd_atom,,,32,"ngx_int_t ngx_http_mp4_read_vmhd_atom (ngx_http_mp4_file_t*,uint64_t)"
171850,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_mp4_read_smhd_atom(ngx_http_mp4_file_t *mp4,
    uint64_t atom_data_size);",18,28,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_smhd_atom,,false,266,267,ngx_http_mp4_read_smhd_atom,,,33,"ngx_int_t ngx_http_mp4_read_smhd_atom (ngx_http_mp4_file_t*,uint64_t)"
171856,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_mp4_read_stbl_atom(ngx_http_mp4_file_t *mp4,
    uint64_t atom_data_size);",18,28,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_stbl_atom,,false,268,269,ngx_http_mp4_read_stbl_atom,,,34,"ngx_int_t ngx_http_mp4_read_stbl_atom (ngx_http_mp4_file_t*,uint64_t)"
171862,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static void ngx_http_mp4_update_stbl_atom(ngx_http_mp4_file_t *mp4,
    ngx_http_mp4_trak_t *trak);",13,30,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_update_stbl_atom,,false,270,271,ngx_http_mp4_update_stbl_atom,,,35,"void ngx_http_mp4_update_stbl_atom (ngx_http_mp4_file_t*,ngx_http_mp4_trak_t*)"
171868,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_mp4_read_stsd_atom(ngx_http_mp4_file_t *mp4,
    uint64_t atom_data_size);",18,28,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_stsd_atom,,false,272,273,ngx_http_mp4_read_stsd_atom,,,36,"ngx_int_t ngx_http_mp4_read_stsd_atom (ngx_http_mp4_file_t*,uint64_t)"
171874,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_mp4_read_stts_atom(ngx_http_mp4_file_t *mp4,
    uint64_t atom_data_size);",18,28,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_stts_atom,,false,274,275,ngx_http_mp4_read_stts_atom,,,37,"ngx_int_t ngx_http_mp4_read_stts_atom (ngx_http_mp4_file_t*,uint64_t)"
171880,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_mp4_update_stts_atom(ngx_http_mp4_file_t *mp4,
    ngx_http_mp4_trak_t *trak);",18,30,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_update_stts_atom,,false,276,277,ngx_http_mp4_update_stts_atom,,,38,"ngx_int_t ngx_http_mp4_update_stts_atom (ngx_http_mp4_file_t*,ngx_http_mp4_trak_t*)"
171886,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_mp4_crop_stts_data(ngx_http_mp4_file_t *mp4,
    ngx_http_mp4_trak_t *trak, ngx_uint_t start);",18,48,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_crop_stts_data,,false,278,279,ngx_http_mp4_crop_stts_data,,,39,"ngx_int_t ngx_http_mp4_crop_stts_data (ngx_http_mp4_file_t*,ngx_http_mp4_trak_t*,ngx_uint_t)"
171893,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_mp4_read_stss_atom(ngx_http_mp4_file_t *mp4,
    uint64_t atom_data_size);",18,28,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_stss_atom,,false,280,281,ngx_http_mp4_read_stss_atom,,,40,"ngx_int_t ngx_http_mp4_read_stss_atom (ngx_http_mp4_file_t*,uint64_t)"
171899,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_mp4_update_stss_atom(ngx_http_mp4_file_t *mp4,
    ngx_http_mp4_trak_t *trak);",18,30,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_update_stss_atom,,false,282,283,ngx_http_mp4_update_stss_atom,,,41,"ngx_int_t ngx_http_mp4_update_stss_atom (ngx_http_mp4_file_t*,ngx_http_mp4_trak_t*)"
171905,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static void ngx_http_mp4_crop_stss_data(ngx_http_mp4_file_t *mp4,
    ngx_http_mp4_trak_t *trak, ngx_uint_t start);",13,48,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_crop_stss_data,,false,284,285,ngx_http_mp4_crop_stss_data,,,42,"void ngx_http_mp4_crop_stss_data (ngx_http_mp4_file_t*,ngx_http_mp4_trak_t*,ngx_uint_t)"
171912,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_mp4_read_ctts_atom(ngx_http_mp4_file_t *mp4,
    uint64_t atom_data_size);",18,28,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_ctts_atom,,false,286,287,ngx_http_mp4_read_ctts_atom,,,43,"ngx_int_t ngx_http_mp4_read_ctts_atom (ngx_http_mp4_file_t*,uint64_t)"
171918,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static void ngx_http_mp4_update_ctts_atom(ngx_http_mp4_file_t *mp4,
    ngx_http_mp4_trak_t *trak);",13,30,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_update_ctts_atom,,false,288,289,ngx_http_mp4_update_ctts_atom,,,44,"void ngx_http_mp4_update_ctts_atom (ngx_http_mp4_file_t*,ngx_http_mp4_trak_t*)"
171924,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static void ngx_http_mp4_crop_ctts_data(ngx_http_mp4_file_t *mp4,
    ngx_http_mp4_trak_t *trak, ngx_uint_t start);",13,48,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_crop_ctts_data,,false,290,291,ngx_http_mp4_crop_ctts_data,,,45,"void ngx_http_mp4_crop_ctts_data (ngx_http_mp4_file_t*,ngx_http_mp4_trak_t*,ngx_uint_t)"
171931,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_mp4_read_stsc_atom(ngx_http_mp4_file_t *mp4,
    uint64_t atom_data_size);",18,28,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_stsc_atom,,false,292,293,ngx_http_mp4_read_stsc_atom,,,46,"ngx_int_t ngx_http_mp4_read_stsc_atom (ngx_http_mp4_file_t*,uint64_t)"
171937,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_mp4_update_stsc_atom(ngx_http_mp4_file_t *mp4,
    ngx_http_mp4_trak_t *trak);",18,30,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_update_stsc_atom,,false,294,295,ngx_http_mp4_update_stsc_atom,,,47,"ngx_int_t ngx_http_mp4_update_stsc_atom (ngx_http_mp4_file_t*,ngx_http_mp4_trak_t*)"
171943,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_mp4_crop_stsc_data(ngx_http_mp4_file_t *mp4,
    ngx_http_mp4_trak_t *trak, ngx_uint_t start);",18,48,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_crop_stsc_data,,false,296,297,ngx_http_mp4_crop_stsc_data,,,48,"ngx_int_t ngx_http_mp4_crop_stsc_data (ngx_http_mp4_file_t*,ngx_http_mp4_trak_t*,ngx_uint_t)"
171950,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_mp4_read_stsz_atom(ngx_http_mp4_file_t *mp4,
    uint64_t atom_data_size);",18,28,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_stsz_atom,,false,298,299,ngx_http_mp4_read_stsz_atom,,,49,"ngx_int_t ngx_http_mp4_read_stsz_atom (ngx_http_mp4_file_t*,uint64_t)"
171956,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_mp4_update_stsz_atom(ngx_http_mp4_file_t *mp4,
    ngx_http_mp4_trak_t *trak);",18,30,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_update_stsz_atom,,false,300,301,ngx_http_mp4_update_stsz_atom,,,50,"ngx_int_t ngx_http_mp4_update_stsz_atom (ngx_http_mp4_file_t*,ngx_http_mp4_trak_t*)"
171962,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_mp4_read_stco_atom(ngx_http_mp4_file_t *mp4,
    uint64_t atom_data_size);",18,28,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_stco_atom,,false,302,303,ngx_http_mp4_read_stco_atom,,,51,"ngx_int_t ngx_http_mp4_read_stco_atom (ngx_http_mp4_file_t*,uint64_t)"
171968,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_mp4_update_stco_atom(ngx_http_mp4_file_t *mp4,
    ngx_http_mp4_trak_t *trak);",18,30,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_update_stco_atom,,false,304,305,ngx_http_mp4_update_stco_atom,,,52,"ngx_int_t ngx_http_mp4_update_stco_atom (ngx_http_mp4_file_t*,ngx_http_mp4_trak_t*)"
171974,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static void ngx_http_mp4_adjust_stco_atom(ngx_http_mp4_file_t *mp4,
    ngx_http_mp4_trak_t *trak, int32_t adjustment);",13,50,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_adjust_stco_atom,,false,306,307,ngx_http_mp4_adjust_stco_atom,,,53,"void ngx_http_mp4_adjust_stco_atom (ngx_http_mp4_file_t*,ngx_http_mp4_trak_t*,int32_t)"
171981,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_mp4_read_co64_atom(ngx_http_mp4_file_t *mp4,
    uint64_t atom_data_size);",18,28,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_co64_atom,,false,308,309,ngx_http_mp4_read_co64_atom,,,54,"ngx_int_t ngx_http_mp4_read_co64_atom (ngx_http_mp4_file_t*,uint64_t)"
171987,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_mp4_update_co64_atom(ngx_http_mp4_file_t *mp4,
    ngx_http_mp4_trak_t *trak);",18,30,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_update_co64_atom,,false,310,311,ngx_http_mp4_update_co64_atom,,,55,"ngx_int_t ngx_http_mp4_update_co64_atom (ngx_http_mp4_file_t*,ngx_http_mp4_trak_t*)"
171993,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static void ngx_http_mp4_adjust_co64_atom(ngx_http_mp4_file_t *mp4,
    ngx_http_mp4_trak_t *trak, off_t adjustment);",13,48,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_adjust_co64_atom,,false,312,313,ngx_http_mp4_adjust_co64_atom,,,56,"void ngx_http_mp4_adjust_co64_atom (ngx_http_mp4_file_t*,ngx_http_mp4_trak_t*,off_t)"
172000,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static char *ngx_http_mp4(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",13,73,http\modules\ngx_http_mp4_module.c,ngx_http_mp4,,false,315,315,ngx_http_mp4,,,57,"char* ngx_http_mp4 (ngx_conf_t*,ngx_command_t*,void*)"
172007,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,static void *ngx_http_mp4_create_conf(ngx_conf_t *cf);,13,53,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_create_conf,,false,316,316,ngx_http_mp4_create_conf,,,58,void* ngx_http_mp4_create_conf (ngx_conf_t*)
172012,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static char *ngx_http_mp4_merge_conf(ngx_conf_t *cf, void *parent, void *child);",13,79,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_merge_conf,,false,317,317,ngx_http_mp4_merge_conf,,,59,"char* ngx_http_mp4_merge_conf (ngx_conf_t*,void*,void*)"
172206,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_mp4_handler(ngx_http_request_t *r)
{
    u_char                    *last;
    size_t                     root;
    ngx_int_t                  rc, start, end;
    ngx_uint_t                 level, length;
    ngx_str_t                  path, value;
    ngx_log_t                 *log;
    ngx_buf_t                 *b;
    ngx_chain_t                out;
    ngx_http_mp4_file_t       *mp4;
    ngx_open_file_info_t       of;
    ngx_http_core_loc_conf_t  *clcf;

    if (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD))) {
        return NGX_HTTP_NOT_ALLOWED;
    }

    if (r->uri.data[r->uri.len - 1] == '/') {
        return NGX_DECLINED;
    }

    rc = ngx_http_discard_request_body(r);

    if (rc != NGX_OK) {
        return rc;
    }

    last = ngx_http_map_uri_to_path(r, &path, &root, 0);
    if (last == NULL) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    log = r->connection->log;

    path.len = last - path.data;

    ngx_log_debug1(NGX_LOG_DEBUG_...",1,1,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_handler,,false,426,683,ngx_http_mp4_handler,,,78,ngx_int_t ngx_http_mp4_handler (ngx_http_request_t*)
172930,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_mp4_atofp(u_char *line, size_t n, size_t point)
{
    ngx_int_t   value, cutoff, cutlim;
    ngx_uint_t  dot;

    /* same as ngx_atofp(), but allows additional digits */

    if (n == 0) {
        return NGX_ERROR;
    }

    cutoff = NGX_MAX_INT_T_VALUE / 10;
    cutlim = NGX_MAX_INT_T_VALUE % 10;

    dot = 0;

    for (value = 0; n--; line++) {

        if (*line == '.') {
            if (dot) {
                return NGX_ERROR;
            }

            dot = 1;
            continue;
        }

        if (*line < '0' || *line > '9') {
            return NGX_ERROR;
        }

        if (point == 0) {
            continue;
        }

        if (value >= cutoff && (value > cutoff || *line - '0' > cutlim)) {
            return NGX_ERROR;
        }

        value = value * 10 + (*line - '0');
        point -= dot;
    }

    while (point--) {
        if (value > cutoff) {
            return NGX_ERROR;
        }

        value = value * 10;
    }

    re...",1,1,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_atofp,,false,686,739,ngx_http_mp4_atofp,,,79,"ngx_int_t ngx_http_mp4_atofp (u_char*,size_t,size_t)"
173054,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_mp4_process(ngx_http_mp4_file_t *mp4)
{
    off_t                  start_offset, end_offset, adjustment;
    ngx_int_t              rc;
    ngx_uint_t             i, j;
    ngx_chain_t          **prev;
    ngx_http_mp4_trak_t   *trak;
    ngx_http_mp4_conf_t   *conf;

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,
                   ""mp4 start:%ui, length:%ui"", mp4->start, mp4->length);

    conf = ngx_http_get_module_loc_conf(mp4->request, ngx_http_mp4_module);

    mp4->buffer_size = conf->buffer_size;

    rc = ngx_http_mp4_read_atom(mp4, ngx_http_mp4_atoms, mp4->end);
    if (rc != NGX_OK) {
        return rc;
    }

    if (mp4->trak.nelts == 0) {
        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,
                      ""no mp4 trak atoms were found in \""%s\"""",
                      mp4->file.name.data);
        return NGX_ERROR;
    }

    if (mp4->mdat_atom.buf == NULL) {
        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,
               ...",1,24,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_process,,false,742,893,ngx_http_mp4_process,,,80,ngx_int_t ngx_http_mp4_process (ngx_http_mp4_file_t*)
173780,METHOD,<empty>,<empty>,<empty>,1,,http\modules\ngx_http_mp4_module.c,ngx_mp4_atom_header_t:<clinit>,,false,896,,<clinit>,,,3,
173793,METHOD,<empty>,<empty>,<empty>,1,,http\modules\ngx_http_mp4_module.c,ngx_mp4_atom_header64_t:<clinit>,,false,901,,<clinit>,,,4,
173804,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_mp4_read_atom(ngx_http_mp4_file_t *mp4,
    ngx_http_mp4_atom_handler_t *atom, uint64_t atom_data_size)
{
    off_t        end;
    size_t       atom_header_size;
    u_char      *atom_header, *atom_name;
    uint64_t     atom_size;
    ngx_int_t    rc;
    ngx_uint_t   n;

    end = mp4->offset + atom_data_size;

    while (mp4->offset < end) {

        if (ngx_http_mp4_read(mp4, sizeof(uint32_t)) != NGX_OK) {
            return NGX_ERROR;
        }

        atom_header = mp4->buffer_pos;
        atom_size = ngx_mp4_get_32value(atom_header);
        atom_header_size = sizeof(ngx_mp4_atom_header_t);

        if (atom_size == 0) {
            ngx_log_debug0(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,
                           ""mp4 atom end"");
            return NGX_OK;
        }

        if (atom_size < sizeof(ngx_mp4_atom_header_t)) {

            if (atom_size == 1) {

                if (ngx_http_mp4_read(mp4, sizeof(ngx_mp4_atom_header64_t))
                 ...",1,20,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_atom,,false,908,1009,ngx_http_mp4_read_atom,,,85,"ngx_int_t ngx_http_mp4_read_atom (ngx_http_mp4_file_t*,ngx_http_mp4_atom_handler_t*,uint64_t)"
174264,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_mp4_read(ngx_http_mp4_file_t *mp4, size_t size)
{
    ssize_t  n;

    if (mp4->buffer_pos + size <= mp4->buffer_end) {
        return NGX_OK;
    }

    if (mp4->offset + (off_t) mp4->buffer_size > mp4->end) {
        mp4->buffer_size = (size_t) (mp4->end - mp4->offset);
    }

    if (mp4->buffer_size < size) {
        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,
                      ""\""%s\"" mp4 file truncated"", mp4->file.name.data);
        return NGX_ERROR;
    }

    if (mp4->buffer == NULL) {
        mp4->buffer = ngx_palloc(mp4->request->pool, mp4->buffer_size);
        if (mp4->buffer == NULL) {
            return NGX_ERROR;
        }

        mp4->buffer_start = mp4->buffer;
    }

    n = ngx_read_file(&mp4->file, mp4->buffer_start, mp4->buffer_size,
                      mp4->offset);

    if (n == NGX_ERROR) {
        return NGX_ERROR;
    }

    if ((size_t) n != mp4->buffer_size) {
        ngx_log_error(NGX_LOG_CRIT, mp4->file.log, 0,
       ...",1,1,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read,,false,1012,1058,ngx_http_mp4_read,,,86,"ngx_int_t ngx_http_mp4_read (ngx_http_mp4_file_t*,size_t)"
174427,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_mp4_read_ftyp_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)
{
    u_char     *ftyp_atom;
    size_t      atom_size;
    ngx_buf_t  *atom;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0, ""mp4 ftyp atom"");

    if (atom_data_size > 1024
        || ngx_mp4_atom_data(mp4) + (size_t) atom_data_size > mp4->buffer_end)
    {
        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,
                      ""\""%s\"" mp4 ftyp atom is too large:%uL"",
                      mp4->file.name.data, atom_data_size);
        return NGX_ERROR;
    }

    atom_size = sizeof(ngx_mp4_atom_header_t) + (size_t) atom_data_size;

    ftyp_atom = ngx_palloc(mp4->request->pool, atom_size);
    if (ftyp_atom == NULL) {
        return NGX_ERROR;
    }

    ngx_mp4_set_32value(ftyp_atom, atom_size);
    ngx_mp4_set_atom_name(ftyp_atom, 'f', 't', 'y', 'p');

    /*
     * only moov atom content is guaranteed to be in mp4->buffer
     * during sending response, so ftyp atom cont...",1,11,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_ftyp_atom,,false,1061,1108,ngx_http_mp4_read_ftyp_atom,,,87,"ngx_int_t ngx_http_mp4_read_ftyp_atom (ngx_http_mp4_file_t*,uint64_t)"
174675,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_mp4_read_moov_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)
{
    ngx_int_t             rc;
    ngx_uint_t            no_mdat;
    ngx_buf_t            *atom;
    ngx_http_mp4_conf_t  *conf;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0, ""mp4 moov atom"");

    no_mdat = (mp4->mdat_atom.buf == NULL);

    if (no_mdat && mp4->start == 0 && mp4->length == 0) {
        /*
         * send original file if moov atom resides before
         * mdat atom and client requests integral file
         */
        return NGX_DECLINED;
    }

    conf = ngx_http_get_module_loc_conf(mp4->request, ngx_http_mp4_module);

    if (atom_data_size > mp4->buffer_size) {

        if (atom_data_size > conf->max_buffer_size) {
            ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,
                          ""\""%s\"" mp4 moov atom is too large:%uL, ""
                          ""you may want to increase mp4_max_buffer_size"",
                          mp4->file.name.d...",1,27,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_moov_atom,,false,1117,1194,ngx_http_mp4_read_moov_atom,,,88,"ngx_int_t ngx_http_mp4_read_moov_atom (ngx_http_mp4_file_t*,uint64_t)"
174956,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_mp4_read_mdat_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)
{
    ngx_buf_t  *data;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0, ""mp4 mdat atom"");

    data = &mp4->mdat_data_buf;
    data->file = &mp4->file;
    data->in_file = 1;
    data->last_buf = (mp4->request == mp4->request->main) ? 1 : 0;
    data->last_in_chain = 1;
    data->file_last = mp4->offset + atom_data_size;

    mp4->mdat_atom.buf = &mp4->mdat_atom_buf;
    mp4->mdat_atom.next = &mp4->mdat_data;
    mp4->mdat_data.buf = data;

    if (mp4->trak.nelts) {
        /* skip atoms after mdat atom */
        mp4->offset = mp4->end;

    } else {
        ngx_mp4_atom_next(mp4, atom_data_size);
    }

    return NGX_OK;
}",1,8,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_mdat_atom,,false,1197,1224,ngx_http_mp4_read_mdat_atom,,,89,"ngx_int_t ngx_http_mp4_read_mdat_atom (ngx_http_mp4_file_t*,uint64_t)"
175103,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static size_t
ngx_http_mp4_update_mdat_atom(ngx_http_mp4_file_t *mp4, off_t start_offset,
    off_t end_offset)
{
    off_t       atom_data_size;
    u_char     *atom_header;
    uint32_t    atom_header_size;
    uint64_t    atom_size;
    ngx_buf_t  *atom;

    atom_data_size = end_offset - start_offset;
    mp4->mdat_data.buf->file_pos = start_offset;
    mp4->mdat_data.buf->file_last = end_offset;

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,
                   ""mdat new offset @%O:%O"", start_offset, atom_data_size);

    atom_header = mp4->mdat_atom_header;

    if ((uint64_t) atom_data_size
        > (uint64_t) 0xffffffff - sizeof(ngx_mp4_atom_header_t))
    {
        atom_size = 1;
        atom_header_size = sizeof(ngx_mp4_atom_header64_t);
        ngx_mp4_set_64value(atom_header + sizeof(ngx_mp4_atom_header_t),
                            sizeof(ngx_mp4_atom_header64_t) + atom_data_size);
    } else {
        atom_size = sizeof(ngx_mp4_atom_header_t) + atom_data_s...",1,8,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_update_mdat_atom,,false,1227,1269,ngx_http_mp4_update_mdat_atom,,,90,"size_t ngx_http_mp4_update_mdat_atom (ngx_http_mp4_file_t*,off_t,off_t)"
175443,METHOD,<empty>,<empty>,<empty>,1,,http\modules\ngx_http_mp4_module.c,ngx_mp4_mvhd_atom_t:<clinit>,,false,1272,,<clinit>,,,20,
175506,METHOD,<empty>,<empty>,<empty>,1,,http\modules\ngx_http_mp4_module.c,ngx_mp4_mvhd64_atom_t:<clinit>,,false,1294,,<clinit>,,,20,
175549,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_mp4_read_mvhd_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)
{
    u_char                 *atom_header;
    size_t                  atom_size;
    uint32_t                timescale;
    uint64_t                duration, start_time, length_time;
    ngx_buf_t              *atom;
    ngx_mp4_mvhd_atom_t    *mvhd_atom;
    ngx_mp4_mvhd64_atom_t  *mvhd64_atom;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0, ""mp4 mvhd atom"");

    atom_header = ngx_mp4_atom_header(mp4);
    mvhd_atom = (ngx_mp4_mvhd_atom_t *) atom_header;
    mvhd64_atom = (ngx_mp4_mvhd64_atom_t *) atom_header;
    ngx_mp4_set_atom_name(atom_header, 'm', 'v', 'h', 'd');

    if (ngx_mp4_atom_data_size(ngx_mp4_mvhd_atom_t) > atom_data_size) {
        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,
                      ""\""%s\"" mp4 mvhd atom too small"", mp4->file.name.data);
        return NGX_ERROR;
    }

    if (mvhd_atom->version[0] == 0) {
        /* version 0: 32-bit duration...",1,18,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_mvhd_atom,,false,1317,1409,ngx_http_mp4_read_mvhd_atom,,,95,"ngx_int_t ngx_http_mp4_read_mvhd_atom (ngx_http_mp4_file_t*,uint64_t)"
176313,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_mp4_read_trak_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)
{
    u_char               *atom_header, *atom_end;
    off_t                 atom_file_end;
    ngx_int_t             rc;
    ngx_buf_t            *atom;
    ngx_http_mp4_trak_t  *trak;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0, ""mp4 trak atom"");

    trak = ngx_array_push(&mp4->trak);
    if (trak == NULL) {
        return NGX_ERROR;
    }

    ngx_memzero(trak, sizeof(ngx_http_mp4_trak_t));

    atom_header = ngx_mp4_atom_header(mp4);
    ngx_mp4_set_atom_name(atom_header, 't', 'r', 'a', 'k');

    atom = &trak->trak_atom_buf;
    atom->temporary = 1;
    atom->pos = atom_header;
    atom->last = atom_header + sizeof(ngx_mp4_atom_header_t);

    trak->out[NGX_HTTP_MP4_TRAK_ATOM].buf = atom;

    atom_end = mp4->buffer_pos + (size_t) atom_data_size;
    atom_file_end = mp4->offset + atom_data_size;

    rc = ngx_http_mp4_read_atom(mp4, ngx_http_mp4_trak_atoms, atom_data_s...",1,18,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_trak_atom,,false,1412,1458,ngx_http_mp4_read_trak_atom,,,96,"ngx_int_t ngx_http_mp4_read_trak_atom (ngx_http_mp4_file_t*,uint64_t)"
176490,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static void
ngx_http_mp4_update_trak_atom(ngx_http_mp4_file_t *mp4,
    ngx_http_mp4_trak_t *trak)
{
    ngx_buf_t  *atom;

    trak->size += sizeof(ngx_mp4_atom_header_t);
    atom = &trak->trak_atom_buf;
    ngx_mp4_set_32value(atom->pos, trak->size);
}",1,4,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_update_trak_atom,,false,1461,1470,ngx_http_mp4_update_trak_atom,,,97,"void ngx_http_mp4_update_trak_atom (ngx_http_mp4_file_t*,ngx_http_mp4_trak_t*)"
176571,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_mp4_read_cmov_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)
{
    ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,
                  ""\""%s\"" mp4 compressed moov atom (cmov) is not supported"",
                  mp4->file.name.data);

    return NGX_ERROR;
}",1,1,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_cmov_atom,,false,1473,1481,ngx_http_mp4_read_cmov_atom,,,98,"ngx_int_t ngx_http_mp4_read_cmov_atom (ngx_http_mp4_file_t*,uint64_t)"
176613,METHOD,<empty>,<empty>,<empty>,1,,http\modules\ngx_http_mp4_module.c,ngx_mp4_tkhd_atom_t:<clinit>,,false,1484,,<clinit>,,,18,
176670,METHOD,<empty>,<empty>,<empty>,1,,http\modules\ngx_http_mp4_module.c,ngx_mp4_tkhd64_atom_t:<clinit>,,false,1504,,<clinit>,,,18,
176709,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_mp4_read_tkhd_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)
{
    u_char                 *atom_header;
    size_t                  atom_size;
    uint64_t                duration, start_time, length_time;
    ngx_buf_t              *atom;
    ngx_http_mp4_trak_t    *trak;
    ngx_mp4_tkhd_atom_t    *tkhd_atom;
    ngx_mp4_tkhd64_atom_t  *tkhd64_atom;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0, ""mp4 tkhd atom"");

    atom_header = ngx_mp4_atom_header(mp4);
    tkhd_atom = (ngx_mp4_tkhd_atom_t *) atom_header;
    tkhd64_atom = (ngx_mp4_tkhd64_atom_t *) atom_header;
    ngx_mp4_set_atom_name(tkhd_atom, 't', 'k', 'h', 'd');

    if (ngx_mp4_atom_data_size(ngx_mp4_tkhd_atom_t) > atom_data_size) {
        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,
                      ""\""%s\"" mp4 tkhd atom too small"", mp4->file.name.data);
        return NGX_ERROR;
    }

    if (tkhd_atom->version[0] == 0) {
        /* version 0: 32-bit duration */
   ...",1,18,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_tkhd_atom,,false,1525,1616,ngx_http_mp4_read_tkhd_atom,,,103,"ngx_int_t ngx_http_mp4_read_tkhd_atom (ngx_http_mp4_file_t*,uint64_t)"
177408,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_mp4_read_mdia_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)
{
    u_char               *atom_header;
    ngx_buf_t            *atom;
    ngx_http_mp4_trak_t  *trak;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0, ""process mdia atom"");

    atom_header = ngx_mp4_atom_header(mp4);
    ngx_mp4_set_atom_name(atom_header, 'm', 'd', 'i', 'a');

    trak = ngx_mp4_last_trak(mp4);

    atom = &trak->mdia_atom_buf;
    atom->temporary = 1;
    atom->pos = atom_header;
    atom->last = atom_header + sizeof(ngx_mp4_atom_header_t);

    trak->out[NGX_HTTP_MP4_MDIA_ATOM].buf = atom;

    return ngx_http_mp4_read_atom(mp4, ngx_http_mp4_mdia_atoms, atom_data_size);
}",1,18,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_mdia_atom,,false,1619,1641,ngx_http_mp4_read_mdia_atom,,,104,"ngx_int_t ngx_http_mp4_read_mdia_atom (ngx_http_mp4_file_t*,uint64_t)"
177529,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static void
ngx_http_mp4_update_mdia_atom(ngx_http_mp4_file_t *mp4,
    ngx_http_mp4_trak_t *trak)
{
    ngx_buf_t  *atom;

    trak->size += sizeof(ngx_mp4_atom_header_t);
    atom = &trak->mdia_atom_buf;
    ngx_mp4_set_32value(atom->pos, trak->size);
}",1,4,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_update_mdia_atom,,false,1644,1653,ngx_http_mp4_update_mdia_atom,,,105,"void ngx_http_mp4_update_mdia_atom (ngx_http_mp4_file_t*,ngx_http_mp4_trak_t*)"
177621,METHOD,<empty>,<empty>,<empty>,1,,http\modules\ngx_http_mp4_module.c,ngx_mp4_mdhd_atom_t:<clinit>,,false,1656,,<clinit>,,,11,
177657,METHOD,<empty>,<empty>,<empty>,1,,http\modules\ngx_http_mp4_module.c,ngx_mp4_mdhd64_atom_t:<clinit>,,false,1669,,<clinit>,,,11,
177682,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_mp4_read_mdhd_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)
{
    u_char                 *atom_header;
    size_t                  atom_size;
    uint32_t                timescale;
    uint64_t                duration, start_time, length_time;
    ngx_buf_t              *atom;
    ngx_http_mp4_trak_t    *trak;
    ngx_mp4_mdhd_atom_t    *mdhd_atom;
    ngx_mp4_mdhd64_atom_t  *mdhd64_atom;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0, ""mp4 mdhd atom"");

    atom_header = ngx_mp4_atom_header(mp4);
    mdhd_atom = (ngx_mp4_mdhd_atom_t *) atom_header;
    mdhd64_atom = (ngx_mp4_mdhd64_atom_t *) atom_header;
    ngx_mp4_set_atom_name(mdhd_atom, 'm', 'd', 'h', 'd');

    if (ngx_mp4_atom_data_size(ngx_mp4_mdhd_atom_t) > atom_data_size) {
        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,
                      ""\""%s\"" mp4 mdhd atom too small"", mp4->file.name.data);
        return NGX_ERROR;
    }

    if (mdhd_atom->version[0] == 0) {
     ...",1,18,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_mdhd_atom,,false,1683,1778,ngx_http_mp4_read_mdhd_atom,,,110,"ngx_int_t ngx_http_mp4_read_mdhd_atom (ngx_http_mp4_file_t*,uint64_t)"
178470,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_mp4_read_hdlr_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)
{
    u_char              *atom_header;
    size_t               atom_size;
    ngx_buf_t            *atom;
    ngx_http_mp4_trak_t  *trak;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0, ""mp4 hdlr atom"");

    atom_header = ngx_mp4_atom_header(mp4);
    atom_size = sizeof(ngx_mp4_atom_header_t) + (size_t) atom_data_size;
    ngx_mp4_set_32value(atom_header, atom_size);
    ngx_mp4_set_atom_name(atom_header, 'h', 'd', 'l', 'r');

    trak = ngx_mp4_last_trak(mp4);

    atom = &trak->hdlr_atom_buf;
    atom->temporary = 1;
    atom->pos = atom_header;
    atom->last = atom_header + atom_size;

    trak->hdlr_size = atom_size;
    trak->out[NGX_HTTP_MP4_HDLR_ATOM].buf = atom;

    ngx_mp4_atom_next(mp4, atom_data_size);

    return NGX_OK;
}",1,18,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_hdlr_atom,,false,1781,1809,ngx_http_mp4_read_hdlr_atom,,,111,"ngx_int_t ngx_http_mp4_read_hdlr_atom (ngx_http_mp4_file_t*,uint64_t)"
178680,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_mp4_read_minf_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)
{
    u_char               *atom_header;
    ngx_buf_t            *atom;
    ngx_http_mp4_trak_t  *trak;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0, ""process minf atom"");

    atom_header = ngx_mp4_atom_header(mp4);
    ngx_mp4_set_atom_name(atom_header, 'm', 'i', 'n', 'f');

    trak = ngx_mp4_last_trak(mp4);

    atom = &trak->minf_atom_buf;
    atom->temporary = 1;
    atom->pos = atom_header;
    atom->last = atom_header + sizeof(ngx_mp4_atom_header_t);

    trak->out[NGX_HTTP_MP4_MINF_ATOM].buf = atom;

    return ngx_http_mp4_read_atom(mp4, ngx_http_mp4_minf_atoms, atom_data_size);
}",1,18,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_minf_atom,,false,1812,1834,ngx_http_mp4_read_minf_atom,,,112,"ngx_int_t ngx_http_mp4_read_minf_atom (ngx_http_mp4_file_t*,uint64_t)"
178801,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static void
ngx_http_mp4_update_minf_atom(ngx_http_mp4_file_t *mp4,
    ngx_http_mp4_trak_t *trak)
{
    ngx_buf_t  *atom;

    trak->size += sizeof(ngx_mp4_atom_header_t)
               + trak->vmhd_size
               + trak->smhd_size
               + trak->dinf_size;
    atom = &trak->minf_atom_buf;
    ngx_mp4_set_32value(atom->pos, trak->size);
}",1,4,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_update_minf_atom,,false,1837,1849,ngx_http_mp4_update_minf_atom,,,113,"void ngx_http_mp4_update_minf_atom (ngx_http_mp4_file_t*,ngx_http_mp4_trak_t*)"
178894,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_mp4_read_vmhd_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)
{
    u_char              *atom_header;
    size_t               atom_size;
    ngx_buf_t            *atom;
    ngx_http_mp4_trak_t  *trak;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0, ""mp4 vmhd atom"");

    atom_header = ngx_mp4_atom_header(mp4);
    atom_size = sizeof(ngx_mp4_atom_header_t) + (size_t) atom_data_size;
    ngx_mp4_set_32value(atom_header, atom_size);
    ngx_mp4_set_atom_name(atom_header, 'v', 'm', 'h', 'd');

    trak = ngx_mp4_last_trak(mp4);

    atom = &trak->vmhd_atom_buf;
    atom->temporary = 1;
    atom->pos = atom_header;
    atom->last = atom_header + atom_size;

    trak->vmhd_size += atom_size;
    trak->out[NGX_HTTP_MP4_VMHD_ATOM].buf = atom;

    ngx_mp4_atom_next(mp4, atom_data_size);

    return NGX_OK;
}",1,18,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_vmhd_atom,,false,1852,1880,ngx_http_mp4_read_vmhd_atom,,,114,"ngx_int_t ngx_http_mp4_read_vmhd_atom (ngx_http_mp4_file_t*,uint64_t)"
179104,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_mp4_read_smhd_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)
{
    u_char              *atom_header;
    size_t               atom_size;
    ngx_buf_t            *atom;
    ngx_http_mp4_trak_t  *trak;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0, ""mp4 smhd atom"");

    atom_header = ngx_mp4_atom_header(mp4);
    atom_size = sizeof(ngx_mp4_atom_header_t) + (size_t) atom_data_size;
    ngx_mp4_set_32value(atom_header, atom_size);
    ngx_mp4_set_atom_name(atom_header, 's', 'm', 'h', 'd');

    trak = ngx_mp4_last_trak(mp4);

    atom = &trak->smhd_atom_buf;
    atom->temporary = 1;
    atom->pos = atom_header;
    atom->last = atom_header + atom_size;

    trak->smhd_size += atom_size;
    trak->out[NGX_HTTP_MP4_SMHD_ATOM].buf = atom;

    ngx_mp4_atom_next(mp4, atom_data_size);

    return NGX_OK;
}",1,18,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_smhd_atom,,false,1883,1911,ngx_http_mp4_read_smhd_atom,,,115,"ngx_int_t ngx_http_mp4_read_smhd_atom (ngx_http_mp4_file_t*,uint64_t)"
179314,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_mp4_read_dinf_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)
{
    u_char              *atom_header;
    size_t               atom_size;
    ngx_buf_t            *atom;
    ngx_http_mp4_trak_t  *trak;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0, ""mp4 dinf atom"");

    atom_header = ngx_mp4_atom_header(mp4);
    atom_size = sizeof(ngx_mp4_atom_header_t) + (size_t) atom_data_size;
    ngx_mp4_set_32value(atom_header, atom_size);
    ngx_mp4_set_atom_name(atom_header, 'd', 'i', 'n', 'f');

    trak = ngx_mp4_last_trak(mp4);

    atom = &trak->dinf_atom_buf;
    atom->temporary = 1;
    atom->pos = atom_header;
    atom->last = atom_header + atom_size;

    trak->dinf_size += atom_size;
    trak->out[NGX_HTTP_MP4_DINF_ATOM].buf = atom;

    ngx_mp4_atom_next(mp4, atom_data_size);

    return NGX_OK;
}",1,18,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_dinf_atom,,false,1914,1942,ngx_http_mp4_read_dinf_atom,,,116,"ngx_int_t ngx_http_mp4_read_dinf_atom (ngx_http_mp4_file_t*,uint64_t)"
179524,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_mp4_read_stbl_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)
{
    u_char               *atom_header;
    ngx_buf_t            *atom;
    ngx_http_mp4_trak_t  *trak;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0, ""process stbl atom"");

    atom_header = ngx_mp4_atom_header(mp4);
    ngx_mp4_set_atom_name(atom_header, 's', 't', 'b', 'l');

    trak = ngx_mp4_last_trak(mp4);

    atom = &trak->stbl_atom_buf;
    atom->temporary = 1;
    atom->pos = atom_header;
    atom->last = atom_header + sizeof(ngx_mp4_atom_header_t);

    trak->out[NGX_HTTP_MP4_STBL_ATOM].buf = atom;

    return ngx_http_mp4_read_atom(mp4, ngx_http_mp4_stbl_atoms, atom_data_size);
}",1,18,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_stbl_atom,,false,1945,1967,ngx_http_mp4_read_stbl_atom,,,117,"ngx_int_t ngx_http_mp4_read_stbl_atom (ngx_http_mp4_file_t*,uint64_t)"
179645,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static void
ngx_http_mp4_update_stbl_atom(ngx_http_mp4_file_t *mp4,
    ngx_http_mp4_trak_t *trak)
{
    ngx_buf_t  *atom;

    trak->size += sizeof(ngx_mp4_atom_header_t);
    atom = &trak->stbl_atom_buf;
    ngx_mp4_set_32value(atom->pos, trak->size);
}",1,4,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_update_stbl_atom,,false,1970,1979,ngx_http_mp4_update_stbl_atom,,,118,"void ngx_http_mp4_update_stbl_atom (ngx_http_mp4_file_t*,ngx_http_mp4_trak_t*)"
179734,METHOD,<empty>,<empty>,<empty>,1,,http\modules\ngx_http_mp4_module.c,ngx_mp4_stsd_atom_t:<clinit>,,false,1982,,<clinit>,,,8,
179753,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_mp4_read_stsd_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)
{
    u_char               *atom_header, *atom_table;
    size_t                atom_size;
    ngx_buf_t            *atom;
    ngx_mp4_stsd_atom_t  *stsd_atom;
    ngx_http_mp4_trak_t  *trak;

    /* sample description atom */

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0, ""mp4 stsd atom"");

    atom_header = ngx_mp4_atom_header(mp4);
    stsd_atom = (ngx_mp4_stsd_atom_t *) atom_header;
    atom_size = sizeof(ngx_mp4_atom_header_t) + (size_t) atom_data_size;
    atom_table = atom_header + atom_size;
    ngx_mp4_set_32value(stsd_atom->size, atom_size);
    ngx_mp4_set_atom_name(stsd_atom, 's', 't', 's', 'd');

    if (ngx_mp4_atom_data_size(ngx_mp4_stsd_atom_t) > atom_data_size) {
        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,
                      ""\""%s\"" mp4 stsd atom too small"", mp4->file.name.data);
        return NGX_ERROR;
    }

    ngx_log_debug3(NGX_LOG_DEBUG_HTTP...",1,18,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_stsd_atom,,false,1994,2038,ngx_http_mp4_read_stsd_atom,,,121,"ngx_int_t ngx_http_mp4_read_stsd_atom (ngx_http_mp4_file_t*,uint64_t)"
180078,METHOD,<empty>,<empty>,<empty>,1,,http\modules\ngx_http_mp4_module.c,ngx_mp4_stts_atom_t:<clinit>,,false,2041,,<clinit>,,,6,
180096,METHOD,<empty>,<empty>,<empty>,1,,http\modules\ngx_http_mp4_module.c,ngx_mp4_stts_entry_t:<clinit>,,false,2049,,<clinit>,,,3,
180105,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_mp4_read_stts_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)
{
    u_char               *atom_header, *atom_table, *atom_end;
    uint32_t              entries;
    ngx_buf_t            *atom, *data;
    ngx_mp4_stts_atom_t  *stts_atom;
    ngx_http_mp4_trak_t  *trak;

    /* time-to-sample atom */

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0, ""mp4 stts atom"");

    atom_header = ngx_mp4_atom_header(mp4);
    stts_atom = (ngx_mp4_stts_atom_t *) atom_header;
    ngx_mp4_set_atom_name(stts_atom, 's', 't', 't', 's');

    if (ngx_mp4_atom_data_size(ngx_mp4_stts_atom_t) > atom_data_size) {
        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,
                      ""\""%s\"" mp4 stts atom too small"", mp4->file.name.data);
        return NGX_ERROR;
    }

    entries = ngx_mp4_get_32value(stts_atom->entries);

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,
                   ""mp4 time-to-sample entries:%uD"", entries);

    if (ngx_mp4_...",1,18,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_stts_atom,,false,2055,2113,ngx_http_mp4_read_stts_atom,,,126,"ngx_int_t ngx_http_mp4_read_stts_atom (ngx_http_mp4_file_t*,uint64_t)"
180439,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_mp4_update_stts_atom(ngx_http_mp4_file_t *mp4,
    ngx_http_mp4_trak_t *trak)
{
    size_t                atom_size;
    ngx_buf_t            *atom, *data;
    ngx_mp4_stts_atom_t  *stts_atom;

    /*
     * mdia.minf.stbl.stts updating requires trak->timescale
     * from mdia.mdhd atom which may reside after mdia.minf
     */

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,
                   ""mp4 stts atom update"");

    data = trak->out[NGX_HTTP_MP4_STTS_DATA].buf;

    if (data == NULL) {
        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,
                      ""no mp4 stts atoms were found in \""%s\"""",
                      mp4->file.name.data);
        return NGX_ERROR;
    }

    if (ngx_http_mp4_crop_stts_data(mp4, trak, 1) != NGX_OK) {
        return NGX_ERROR;
    }

    if (ngx_http_mp4_crop_stts_data(mp4, trak, 0) != NGX_OK) {
        return NGX_ERROR;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,
                   ""...",1,21,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_update_stts_atom,,false,2116,2161,ngx_http_mp4_update_stts_atom,,,127,"ngx_int_t ngx_http_mp4_update_stts_atom (ngx_http_mp4_file_t*,ngx_http_mp4_trak_t*)"
180675,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_mp4_crop_stts_data(ngx_http_mp4_file_t *mp4,
    ngx_http_mp4_trak_t *trak, ngx_uint_t start)
{
    uint32_t               count, duration, rest;
    uint64_t               start_time;
    ngx_buf_t             *data;
    ngx_uint_t             start_sample, entries, start_sec;
    ngx_mp4_stts_entry_t  *entry, *end;

    if (start) {
        start_sec = mp4->start;

        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,
                       ""mp4 stts crop start_time:%ui"", start_sec);

    } else if (mp4->length) {
        start_sec = mp4->length;

        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,
                       ""mp4 stts crop end_time:%ui"", start_sec);

    } else {
        return NGX_OK;
    }

    data = trak->out[NGX_HTTP_MP4_STTS_DATA].buf;

    start_time = (uint64_t) start_sec * trak->timescale / 1000;

    entries = trak->time_to_sample_entries;
    start_sample = 0;
    entry = (ngx_mp4_stts_entry_t *) data->pos;
    end ...",1,21,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_crop_stts_data,,false,2164,2259,ngx_http_mp4_crop_stts_data,,,128,"ngx_int_t ngx_http_mp4_crop_stts_data (ngx_http_mp4_file_t*,ngx_http_mp4_trak_t*,ngx_uint_t)"
181162,METHOD,<empty>,<empty>,<empty>,1,,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_stss_atom_t:<clinit>,,false,2262,,<clinit>,,,6,
181177,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_mp4_read_stss_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)
{
    u_char                    *atom_header, *atom_table, *atom_end;
    uint32_t                   entries;
    ngx_buf_t                 *atom, *data;
    ngx_http_mp4_trak_t       *trak;
    ngx_http_mp4_stss_atom_t  *stss_atom;

    /* sync samples atom */

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0, ""mp4 stss atom"");

    atom_header = ngx_mp4_atom_header(mp4);
    stss_atom = (ngx_http_mp4_stss_atom_t *) atom_header;
    ngx_mp4_set_atom_name(stss_atom, 's', 't', 's', 's');

    if (ngx_mp4_atom_data_size(ngx_http_mp4_stss_atom_t) > atom_data_size) {
        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,
                      ""\""%s\"" mp4 stss atom too small"", mp4->file.name.data);
        return NGX_ERROR;
    }

    entries = ngx_mp4_get_32value(stss_atom->entries);

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,
                   ""sync sample entries:%uD"", e...",1,18,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_stss_atom,,false,2271,2330,ngx_http_mp4_read_stss_atom,,,131,"ngx_int_t ngx_http_mp4_read_stss_atom (ngx_http_mp4_file_t*,uint64_t)"
181512,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_mp4_update_stss_atom(ngx_http_mp4_file_t *mp4,
    ngx_http_mp4_trak_t *trak)
{
    size_t                     atom_size;
    uint32_t                   sample, start_sample, *entry, *end;
    ngx_buf_t                 *atom, *data;
    ngx_http_mp4_stss_atom_t  *stss_atom;

    /*
     * mdia.minf.stbl.stss updating requires trak->start_sample
     * from mdia.minf.stbl.stts which depends on value from mdia.mdhd
     * atom which may reside after mdia.minf
     */

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,
                   ""mp4 stss atom update"");

    data = trak->out[NGX_HTTP_MP4_STSS_DATA].buf;

    if (data == NULL) {
        return NGX_OK;
    }

    ngx_http_mp4_crop_stss_data(mp4, trak, 1);
    ngx_http_mp4_crop_stss_data(mp4, trak, 0);

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,
                   ""sync sample entries:%uD"", trak->sync_samples_entries);

    if (trak->sync_samples_entries) {
        entry = (uint32_t *...",1,21,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_update_stss_atom,,false,2333,2390,ngx_http_mp4_update_stss_atom,,,132,"ngx_int_t ngx_http_mp4_update_stss_atom (ngx_http_mp4_file_t*,ngx_http_mp4_trak_t*)"
181848,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static void
ngx_http_mp4_crop_stss_data(ngx_http_mp4_file_t *mp4,
    ngx_http_mp4_trak_t *trak, ngx_uint_t start)
{
    uint32_t     sample, start_sample, *entry, *end;
    ngx_buf_t   *data;
    ngx_uint_t   entries;

    /* sync samples starts from 1 */

    if (start) {
        start_sample = trak->start_sample + 1;

        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,
                       ""mp4 stss crop start_sample:%uD"", start_sample);

    } else if (mp4->length) {
        start_sample = trak->end_sample + 1;

        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,
                       ""mp4 stss crop end_sample:%uD"", start_sample);

    } else {
        return;
    }

    data = trak->out[NGX_HTTP_MP4_STSS_DATA].buf;

    entries = trak->sync_samples_entries;
    entry = (uint32_t *) data->pos;
    end = (uint32_t *) data->last;

    while (entry < end) {
        sample = ngx_mp4_get_32value(entry);

        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0...",1,21,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_crop_stss_data,,false,2393,2452,ngx_http_mp4_crop_stss_data,,,133,"void ngx_http_mp4_crop_stss_data (ngx_http_mp4_file_t*,ngx_http_mp4_trak_t*,ngx_uint_t)"
182043,METHOD,<empty>,<empty>,<empty>,1,,http\modules\ngx_http_mp4_module.c,ngx_mp4_ctts_atom_t:<clinit>,,false,2455,,<clinit>,,,6,
182061,METHOD,<empty>,<empty>,<empty>,1,,http\modules\ngx_http_mp4_module.c,ngx_mp4_ctts_entry_t:<clinit>,,false,2463,,<clinit>,,,3,
182070,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_mp4_read_ctts_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)
{
    u_char               *atom_header, *atom_table, *atom_end;
    uint32_t              entries;
    ngx_buf_t            *atom, *data;
    ngx_mp4_ctts_atom_t  *ctts_atom;
    ngx_http_mp4_trak_t  *trak;

    /* composition offsets atom */

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0, ""mp4 ctts atom"");

    atom_header = ngx_mp4_atom_header(mp4);
    ctts_atom = (ngx_mp4_ctts_atom_t *) atom_header;
    ngx_mp4_set_atom_name(ctts_atom, 'c', 't', 't', 's');

    if (ngx_mp4_atom_data_size(ngx_mp4_ctts_atom_t) > atom_data_size) {
        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,
                      ""\""%s\"" mp4 ctts atom too small"", mp4->file.name.data);
        return NGX_ERROR;
    }

    entries = ngx_mp4_get_32value(ctts_atom->entries);

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,
                   ""composition offset entries:%uD"", entries);

    trak = ...",1,18,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_ctts_atom,,false,2469,2528,ngx_http_mp4_read_ctts_atom,,,138,"ngx_int_t ngx_http_mp4_read_ctts_atom (ngx_http_mp4_file_t*,uint64_t)"
182403,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static void
ngx_http_mp4_update_ctts_atom(ngx_http_mp4_file_t *mp4,
    ngx_http_mp4_trak_t *trak)
{
    size_t                atom_size;
    ngx_buf_t            *atom, *data;
    ngx_mp4_ctts_atom_t  *ctts_atom;

    /*
     * mdia.minf.stbl.ctts updating requires trak->start_sample
     * from mdia.minf.stbl.stts which depends on value from mdia.mdhd
     * atom which may reside after mdia.minf
     */

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,
                   ""mp4 ctts atom update"");

    data = trak->out[NGX_HTTP_MP4_CTTS_DATA].buf;

    if (data == NULL) {
        return;
    }

    ngx_http_mp4_crop_ctts_data(mp4, trak, 1);
    ngx_http_mp4_crop_ctts_data(mp4, trak, 0);

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,
                   ""composition offset entries:%uD"",
                   trak->composition_offset_entries);

    if (trak->composition_offset_entries == 0) {
        trak->out[NGX_HTTP_MP4_CTTS_ATOM].buf = NULL;
        trak->out[NGX_HT...",1,21,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_update_ctts_atom,,false,2531,2577,ngx_http_mp4_update_ctts_atom,,,139,"void ngx_http_mp4_update_ctts_atom (ngx_http_mp4_file_t*,ngx_http_mp4_trak_t*)"
182639,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static void
ngx_http_mp4_crop_ctts_data(ngx_http_mp4_file_t *mp4,
    ngx_http_mp4_trak_t *trak, ngx_uint_t start)
{
    uint32_t               count, start_sample, rest;
    ngx_buf_t             *data;
    ngx_uint_t             entries;
    ngx_mp4_ctts_entry_t  *entry, *end;

    /* sync samples starts from 1 */

    if (start) {
        start_sample = trak->start_sample + 1;

        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,
                       ""mp4 ctts crop start_sample:%uD"", start_sample);

    } else if (mp4->length) {
        start_sample = trak->end_sample - trak->start_sample + 1;

        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,
                       ""mp4 ctts crop end_sample:%uD"", start_sample);

    } else {
        return;
    }

    data = trak->out[NGX_HTTP_MP4_CTTS_DATA].buf;

    entries = trak->composition_offset_entries;
    entry = (ngx_mp4_ctts_entry_t *) data->pos;
    end = (ngx_mp4_ctts_entry_t *) data->last;

    while (entry < ...",1,21,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_crop_ctts_data,,false,2580,2649,ngx_http_mp4_crop_ctts_data,,,140,"void ngx_http_mp4_crop_ctts_data (ngx_http_mp4_file_t*,ngx_http_mp4_trak_t*,ngx_uint_t)"
183023,METHOD,<empty>,<empty>,<empty>,1,,http\modules\ngx_http_mp4_module.c,ngx_mp4_stsc_atom_t:<clinit>,,false,2652,,<clinit>,,,6,
183038,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_mp4_read_stsc_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)
{
    u_char               *atom_header, *atom_table, *atom_end;
    uint32_t              entries;
    ngx_buf_t            *atom, *data;
    ngx_mp4_stsc_atom_t  *stsc_atom;
    ngx_http_mp4_trak_t  *trak;

    /* sample-to-chunk atom */

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0, ""mp4 stsc atom"");

    atom_header = ngx_mp4_atom_header(mp4);
    stsc_atom = (ngx_mp4_stsc_atom_t *) atom_header;
    ngx_mp4_set_atom_name(stsc_atom, 's', 't', 's', 'c');

    if (ngx_mp4_atom_data_size(ngx_mp4_stsc_atom_t) > atom_data_size) {
        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,
                      ""\""%s\"" mp4 stsc atom too small"", mp4->file.name.data);
        return NGX_ERROR;
    }

    entries = ngx_mp4_get_32value(stsc_atom->entries);

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,
                   ""sample-to-chunk entries:%uD"", entries);

    if (ngx_mp4_at...",1,18,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_stsc_atom,,false,2661,2719,ngx_http_mp4_read_stsc_atom,,,143,"ngx_int_t ngx_http_mp4_read_stsc_atom (ngx_http_mp4_file_t*,uint64_t)"
183372,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_mp4_update_stsc_atom(ngx_http_mp4_file_t *mp4,
    ngx_http_mp4_trak_t *trak)
{
    size_t                 atom_size;
    uint32_t               chunk;
    ngx_buf_t             *atom, *data;
    ngx_mp4_stsc_atom_t   *stsc_atom;
    ngx_mp4_stsc_entry_t  *entry, *end;

    /*
     * mdia.minf.stbl.stsc updating requires trak->start_sample
     * from mdia.minf.stbl.stts which depends on value from mdia.mdhd
     * atom which may reside after mdia.minf
     */

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,
                   ""mp4 stsc atom update"");

    data = trak->out[NGX_HTTP_MP4_STSC_DATA].buf;

    if (data == NULL) {
        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,
                      ""no mp4 stsc atoms were found in \""%s\"""",
                      mp4->file.name.data);
        return NGX_ERROR;
    }

    if (trak->sample_to_chunk_entries == 0) {
        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,
                      ""zero number ...",1,21,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_update_stsc_atom,,false,2722,2791,ngx_http_mp4_update_stsc_atom,,,144,"ngx_int_t ngx_http_mp4_update_stsc_atom (ngx_http_mp4_file_t*,ngx_http_mp4_trak_t*)"
183758,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_mp4_crop_stsc_data(ngx_http_mp4_file_t *mp4,
    ngx_http_mp4_trak_t *trak, ngx_uint_t start)
{
    uint32_t               start_sample, chunk, samples, id, next_chunk, n,
                           prev_samples;
    ngx_buf_t             *data, *buf;
    ngx_uint_t             entries, target_chunk, chunk_samples;
    ngx_mp4_stsc_entry_t  *entry, *end, *first;

    entries = trak->sample_to_chunk_entries - 1;

    if (start) {
        start_sample = (uint32_t) trak->start_sample;

        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,
                       ""mp4 stsc crop start_sample:%uD"", start_sample);

    } else if (mp4->length) {
        start_sample = (uint32_t) (trak->end_sample - trak->start_sample);
        samples = 0;

        data = trak->out[NGX_HTTP_MP4_STSC_START].buf;

        if (data) {
            entry = (ngx_mp4_stsc_entry_t *) data->pos;
            samples = ngx_mp4_get_32value(entry->samples);
            entries--;

       ...",1,25,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_crop_stsc_data,,false,2794,2989,ngx_http_mp4_crop_stsc_data,,,145,"ngx_int_t ngx_http_mp4_crop_stsc_data (ngx_http_mp4_file_t*,ngx_http_mp4_trak_t*,ngx_uint_t)"
185201,METHOD,<empty>,<empty>,<empty>,1,,http\modules\ngx_http_mp4_module.c,ngx_mp4_stsz_atom_t:<clinit>,,false,2992,,<clinit>,,,7,
185218,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_mp4_read_stsz_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)
{
    u_char               *atom_header, *atom_table, *atom_end;
    size_t                atom_size;
    uint32_t              entries, size;
    ngx_buf_t            *atom, *data;
    ngx_mp4_stsz_atom_t  *stsz_atom;
    ngx_http_mp4_trak_t  *trak;

    /* sample sizes atom */

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0, ""mp4 stsz atom"");

    atom_header = ngx_mp4_atom_header(mp4);
    stsz_atom = (ngx_mp4_stsz_atom_t *) atom_header;
    ngx_mp4_set_atom_name(stsz_atom, 's', 't', 's', 'z');

    if (ngx_mp4_atom_data_size(ngx_mp4_stsz_atom_t) > atom_data_size) {
        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,
                      ""\""%s\"" mp4 stsz atom too small"", mp4->file.name.data);
        return NGX_ERROR;
    }

    size = ngx_mp4_get_32value(stsz_atom->uniform_size);
    entries = ngx_mp4_get_32value(stsz_atom->entries);

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, ...",1,18,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_stsz_atom,,false,3002,3074,ngx_http_mp4_read_stsz_atom,,,148,"ngx_int_t ngx_http_mp4_read_stsz_atom (ngx_http_mp4_file_t*,uint64_t)"
185662,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_mp4_update_stsz_atom(ngx_http_mp4_file_t *mp4,
    ngx_http_mp4_trak_t *trak)
{
    size_t                atom_size;
    uint32_t             *pos, *end, entries;
    ngx_buf_t            *atom, *data;
    ngx_mp4_stsz_atom_t  *stsz_atom;

    /*
     * mdia.minf.stbl.stsz updating requires trak->start_sample
     * from mdia.minf.stbl.stts which depends on value from mdia.mdhd
     * atom which may reside after mdia.minf
     */

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,
                   ""mp4 stsz atom update"");

    data = trak->out[NGX_HTTP_MP4_STSZ_DATA].buf;

    if (data) {
        entries = trak->sample_sizes_entries;

        if (trak->start_sample > entries) {
            ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,
                          ""start time is out mp4 stsz samples in \""%s\"""",
                          mp4->file.name.data);
            return NGX_ERROR;
        }

        entries -= trak->start_sample;
        data->pos...",1,21,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_update_stsz_atom,,false,3077,3165,ngx_http_mp4_update_stsz_atom,,,149,"ngx_int_t ngx_http_mp4_update_stsz_atom (ngx_http_mp4_file_t*,ngx_http_mp4_trak_t*)"
186145,METHOD,<empty>,<empty>,<empty>,1,,http\modules\ngx_http_mp4_module.c,ngx_mp4_stco_atom_t:<clinit>,,false,3168,,<clinit>,,,6,
186160,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_mp4_read_stco_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)
{
    u_char               *atom_header, *atom_table, *atom_end;
    uint32_t              entries;
    ngx_buf_t            *atom, *data;
    ngx_mp4_stco_atom_t  *stco_atom;
    ngx_http_mp4_trak_t  *trak;

    /* chunk offsets atom */

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0, ""mp4 stco atom"");

    atom_header = ngx_mp4_atom_header(mp4);
    stco_atom = (ngx_mp4_stco_atom_t *) atom_header;
    ngx_mp4_set_atom_name(stco_atom, 's', 't', 'c', 'o');

    if (ngx_mp4_atom_data_size(ngx_mp4_stco_atom_t) > atom_data_size) {
        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,
                      ""\""%s\"" mp4 stco atom too small"", mp4->file.name.data);
        return NGX_ERROR;
    }

    entries = ngx_mp4_get_32value(stco_atom->entries);

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0, ""chunks:%uD"", entries);

    if (ngx_mp4_atom_data_size(ngx_mp4_stco_atom_t)
    ...",1,18,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_stco_atom,,false,3177,3234,ngx_http_mp4_read_stco_atom,,,152,"ngx_int_t ngx_http_mp4_read_stco_atom (ngx_http_mp4_file_t*,uint64_t)"
186493,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_mp4_update_stco_atom(ngx_http_mp4_file_t *mp4,
    ngx_http_mp4_trak_t *trak)
{
    size_t                atom_size;
    uint32_t              entries;
    uint64_t              chunk_offset, samples_size;
    ngx_buf_t            *atom, *data;
    ngx_mp4_stco_atom_t  *stco_atom;

    /*
     * mdia.minf.stbl.stco updating requires trak->start_chunk
     * from mdia.minf.stbl.stsc which depends on value from mdia.mdhd
     * atom which may reside after mdia.minf
     */

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,
                   ""mp4 stco atom update"");

    data = trak->out[NGX_HTTP_MP4_STCO_DATA].buf;

    if (data == NULL) {
        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,
                      ""no mp4 stco atoms were found in \""%s\"""",
                      mp4->file.name.data);
        return NGX_ERROR;
    }

    if (trak->start_chunk > trak->chunks) {
        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,
                      ""sta...",1,21,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_update_stco_atom,,false,3237,3343,ngx_http_mp4_update_stco_atom,,,153,"ngx_int_t ngx_http_mp4_update_stco_atom (ngx_http_mp4_file_t*,ngx_http_mp4_trak_t*)"
187101,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static void
ngx_http_mp4_adjust_stco_atom(ngx_http_mp4_file_t *mp4,
    ngx_http_mp4_trak_t *trak, int32_t adjustment)
{
    uint32_t    offset, *entry, *end;
    ngx_buf_t  *data;

    /*
     * moov.trak.mdia.minf.stbl.stco adjustment requires
     * minimal start offset of all traks and new moov atom size
     */

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,
                   ""mp4 stco atom adjustment"");

    data = trak->out[NGX_HTTP_MP4_STCO_DATA].buf;
    entry = (uint32_t *) data->pos;
    end = (uint32_t *) data->last;

    while (entry < end) {
        offset = ngx_mp4_get_32value(entry);
        offset += adjustment;
        ngx_mp4_set_32value(entry, offset);
        entry++;
    }
}",1,21,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_adjust_stco_atom,,false,3346,3371,ngx_http_mp4_adjust_stco_atom,,,154,"void ngx_http_mp4_adjust_stco_atom (ngx_http_mp4_file_t*,ngx_http_mp4_trak_t*,int32_t)"
187239,METHOD,<empty>,<empty>,<empty>,1,,http\modules\ngx_http_mp4_module.c,ngx_mp4_co64_atom_t:<clinit>,,false,3374,,<clinit>,,,6,
187254,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_mp4_read_co64_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)
{
    u_char               *atom_header, *atom_table, *atom_end;
    uint32_t              entries;
    ngx_buf_t            *atom, *data;
    ngx_mp4_co64_atom_t  *co64_atom;
    ngx_http_mp4_trak_t  *trak;

    /* chunk offsets atom */

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0, ""mp4 co64 atom"");

    atom_header = ngx_mp4_atom_header(mp4);
    co64_atom = (ngx_mp4_co64_atom_t *) atom_header;
    ngx_mp4_set_atom_name(co64_atom, 'c', 'o', '6', '4');

    if (ngx_mp4_atom_data_size(ngx_mp4_co64_atom_t) > atom_data_size) {
        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,
                      ""\""%s\"" mp4 co64 atom too small"", mp4->file.name.data);
        return NGX_ERROR;
    }

    entries = ngx_mp4_get_32value(co64_atom->entries);

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0, ""chunks:%uD"", entries);

    if (ngx_mp4_atom_data_size(ngx_mp4_co64_atom_t)
    ...",1,18,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_read_co64_atom,,false,3383,3440,ngx_http_mp4_read_co64_atom,,,157,"ngx_int_t ngx_http_mp4_read_co64_atom (ngx_http_mp4_file_t*,uint64_t)"
187587,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_mp4_update_co64_atom(ngx_http_mp4_file_t *mp4,
    ngx_http_mp4_trak_t *trak)
{
    size_t                atom_size;
    uint64_t              entries, chunk_offset, samples_size;
    ngx_buf_t            *atom, *data;
    ngx_mp4_co64_atom_t  *co64_atom;

    /*
     * mdia.minf.stbl.co64 updating requires trak->start_chunk
     * from mdia.minf.stbl.stsc which depends on value from mdia.mdhd
     * atom which may reside after mdia.minf
     */

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,
                   ""mp4 co64 atom update"");

    data = trak->out[NGX_HTTP_MP4_CO64_DATA].buf;

    if (data == NULL) {
        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,
                      ""no mp4 co64 atoms were found in \""%s\"""",
                      mp4->file.name.data);
        return NGX_ERROR;
    }

    if (trak->start_chunk > trak->chunks) {
        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,
                      ""start time is out mp4 co64 ch...",1,21,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_update_co64_atom,,false,3443,3544,ngx_http_mp4_update_co64_atom,,,158,"ngx_int_t ngx_http_mp4_update_co64_atom (ngx_http_mp4_file_t*,ngx_http_mp4_trak_t*)"
188343,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static void
ngx_http_mp4_adjust_co64_atom(ngx_http_mp4_file_t *mp4,
    ngx_http_mp4_trak_t *trak, off_t adjustment)
{
    uint64_t    offset, *entry, *end;
    ngx_buf_t  *data;

    /*
     * moov.trak.mdia.minf.stbl.co64 adjustment requires
     * minimal start offset of all traks and new moov atom size
     */

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,
                   ""mp4 co64 atom adjustment"");

    data = trak->out[NGX_HTTP_MP4_CO64_DATA].buf;
    entry = (uint64_t *) data->pos;
    end = (uint64_t *) data->last;

    while (entry < end) {
        offset = ngx_mp4_get_64value(entry);
        offset += adjustment;
        ngx_mp4_set_64value(entry, offset);
        entry++;
    }
}",1,21,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_adjust_co64_atom,,false,3547,3572,ngx_http_mp4_adjust_co64_atom,,,159,"void ngx_http_mp4_adjust_co64_atom (ngx_http_mp4_file_t*,ngx_http_mp4_trak_t*,off_t)"
188555,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static char *
ngx_http_mp4(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_core_loc_conf_t  *clcf;

    clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);
    clcf->handler = ngx_http_mp4_handler;

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_mp4_module.c,ngx_http_mp4,,false,3575,3584,ngx_http_mp4,,,160,"char* ngx_http_mp4 (ngx_conf_t*,ngx_command_t*,void*)"
188575,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static void *
ngx_http_mp4_create_conf(ngx_conf_t *cf)
{
    ngx_http_mp4_conf_t  *conf;

    conf = ngx_palloc(cf->pool, sizeof(ngx_http_mp4_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    conf->buffer_size = NGX_CONF_UNSET_SIZE;
    conf->max_buffer_size = NGX_CONF_UNSET_SIZE;

    return conf;
}",1,1,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_create_conf,,false,3587,3601,ngx_http_mp4_create_conf,,,161,void* ngx_http_mp4_create_conf (ngx_conf_t*)
188608,METHOD,http\modules\ngx_http_mp4_module.c:<global>,TYPE_DECL,"static char *
ngx_http_mp4_merge_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_mp4_conf_t *prev = parent;
    ngx_http_mp4_conf_t *conf = child;

    ngx_conf_merge_size_value(conf->buffer_size, prev->buffer_size, 512 * 1024);
    ngx_conf_merge_size_value(conf->max_buffer_size, prev->max_buffer_size,
                              10 * 1024 * 1024);

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_mp4_module.c,ngx_http_mp4_merge_conf,,false,3604,3615,ngx_http_mp4_merge_conf,,,162,"char* ngx_http_mp4_merge_conf (ngx_conf_t*,void*,void*)"
188656,METHOD,http\modules\ngx_http_not_modified_filter_module.c:<global>,TYPE_DECL,<global>,1,1,http\modules\ngx_http_not_modified_filter_module.c,http\modules\ngx_http_not_modified_filter_module.c:<global>,,false,1,266,<global>,,,1,
188658,METHOD,http\modules\ngx_http_not_modified_filter_module.c:<global>,TYPE_DECL,static ngx_uint_t ngx_http_test_if_unmodified(ngx_http_request_t *r);,19,68,http\modules\ngx_http_not_modified_filter_module.c,ngx_http_test_if_unmodified,,false,13,13,ngx_http_test_if_unmodified,,,1,ngx_uint_t ngx_http_test_if_unmodified (ngx_http_request_t*)
188663,METHOD,http\modules\ngx_http_not_modified_filter_module.c:<global>,TYPE_DECL,static ngx_uint_t ngx_http_test_if_modified(ngx_http_request_t *r);,19,66,http\modules\ngx_http_not_modified_filter_module.c,ngx_http_test_if_modified,,false,14,14,ngx_http_test_if_modified,,,2,ngx_uint_t ngx_http_test_if_modified (ngx_http_request_t*)
188668,METHOD,http\modules\ngx_http_not_modified_filter_module.c:<global>,TYPE_DECL,"static ngx_uint_t ngx_http_test_if_match(ngx_http_request_t *r,
    ngx_table_elt_t *header, ngx_uint_t weak);",19,45,http\modules\ngx_http_not_modified_filter_module.c,ngx_http_test_if_match,,false,15,16,ngx_http_test_if_match,,,3,"ngx_uint_t ngx_http_test_if_match (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
188675,METHOD,http\modules\ngx_http_not_modified_filter_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_not_modified_filter_init(ngx_conf_t *cf);,18,66,http\modules\ngx_http_not_modified_filter_module.c,ngx_http_not_modified_filter_init,,false,17,17,ngx_http_not_modified_filter_init,,,4,ngx_int_t ngx_http_not_modified_filter_init (ngx_conf_t*)
188710,METHOD,http\modules\ngx_http_not_modified_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_not_modified_header_filter(ngx_http_request_t *r)
{
    if (r->headers_out.status != NGX_HTTP_OK
        || r != r->main
        || r->disable_not_modified)
    {
        return ngx_http_next_header_filter(r);
    }

    if (r->headers_in.if_unmodified_since
        && !ngx_http_test_if_unmodified(r))
    {
        return ngx_http_filter_finalize_request(r, NULL,
                                                NGX_HTTP_PRECONDITION_FAILED);
    }

    if (r->headers_in.if_match
        && !ngx_http_test_if_match(r, r->headers_in.if_match, 0))
    {
        return ngx_http_filter_finalize_request(r, NULL,
                                                NGX_HTTP_PRECONDITION_FAILED);
    }

    if (r->headers_in.if_modified_since || r->headers_in.if_none_match) {

        if (r->headers_in.if_modified_since
            && ngx_http_test_if_modified(r))
        {
            return ngx_http_next_header_filter(r);
        }

        if (r->headers_in.if_none_mat...",1,1,http\modules\ngx_http_not_modified_filter_module.c,ngx_http_not_modified_header_filter,,false,54,109,ngx_http_not_modified_header_filter,,,10,ngx_int_t ngx_http_not_modified_header_filter (ngx_http_request_t*)
188879,METHOD,http\modules\ngx_http_not_modified_filter_module.c:<global>,TYPE_DECL,"static ngx_uint_t
ngx_http_test_if_unmodified(ngx_http_request_t *r)
{
    time_t  iums;

    if (r->headers_out.last_modified_time == (time_t) -1) {
        return 0;
    }

    iums = ngx_parse_http_time(r->headers_in.if_unmodified_since->value.data,
                               r->headers_in.if_unmodified_since->value.len);

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                 ""http iums:%T lm:%T"", iums, r->headers_out.last_modified_time);

    if (iums >= r->headers_out.last_modified_time) {
        return 1;
    }

    return 0;
}",1,1,http\modules\ngx_http_not_modified_filter_module.c,ngx_http_test_if_unmodified,,false,112,132,ngx_http_test_if_unmodified,,,11,ngx_uint_t ngx_http_test_if_unmodified (ngx_http_request_t*)
188947,METHOD,http\modules\ngx_http_not_modified_filter_module.c:<global>,TYPE_DECL,"static ngx_uint_t
ngx_http_test_if_modified(ngx_http_request_t *r)
{
    time_t                     ims;
    ngx_http_core_loc_conf_t  *clcf;

    if (r->headers_out.last_modified_time == (time_t) -1) {
        return 1;
    }

    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    if (clcf->if_modified_since == NGX_HTTP_IMS_OFF) {
        return 1;
    }

    ims = ngx_parse_http_time(r->headers_in.if_modified_since->value.data,
                              r->headers_in.if_modified_since->value.len);

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http ims:%T lm:%T"", ims, r->headers_out.last_modified_time);

    if (ims == r->headers_out.last_modified_time) {
        return 0;
    }

    if (clcf->if_modified_since == NGX_HTTP_IMS_EXACT
        || ims < r->headers_out.last_modified_time)
    {
        return 1;
    }

    return 0;
}",1,1,http\modules\ngx_http_not_modified_filter_module.c,ngx_http_test_if_modified,,false,135,168,ngx_http_test_if_modified,,,12,ngx_uint_t ngx_http_test_if_modified (ngx_http_request_t*)
189047,METHOD,http\modules\ngx_http_not_modified_filter_module.c:<global>,TYPE_DECL,"static ngx_uint_t
ngx_http_test_if_match(ngx_http_request_t *r, ngx_table_elt_t *header,
    ngx_uint_t weak)
{
    u_char     *start, *end, ch;
    ngx_str_t   etag, *list;

    list = &header->value;

    if (list->len == 1 && list->data[0] == '*') {
        return 1;
    }

    if (r->headers_out.etag == NULL) {
        return 0;
    }

    etag = r->headers_out.etag->value;

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http im:\""%V\"" etag:%V"", list, &etag);

    if (weak
        && etag.len > 2
        && etag.data[0] == 'W'
        && etag.data[1] == '/')
    {
        etag.len -= 2;
        etag.data += 2;
    }

    start = list->data;
    end = list->data + list->len;

    while (start < end) {

        if (weak
            && end - start > 2
            && start[0] == 'W'
            && start[1] == '/')
        {
            start += 2;
        }

        if (etag.len > (size_t) (end - start)) {
            return 0;
        }

        i...",1,1,http\modules\ngx_http_not_modified_filter_module.c,ngx_http_test_if_match,,false,171,256,ngx_http_test_if_match,,,13,"ngx_uint_t ngx_http_test_if_match (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
189297,METHOD,http\modules\ngx_http_not_modified_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_not_modified_filter_init(ngx_conf_t *cf)
{
    ngx_http_next_header_filter = ngx_http_top_header_filter;
    ngx_http_top_header_filter = ngx_http_not_modified_header_filter;

    return NGX_OK;
}",1,1,http\modules\ngx_http_not_modified_filter_module.c,ngx_http_not_modified_filter_init,,false,259,266,ngx_http_not_modified_filter_init,,,14,ngx_int_t ngx_http_not_modified_filter_init (ngx_conf_t*)
189319,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,<global>,1,1,http\modules\ngx_http_proxy_module.c,http\modules\ngx_http_proxy_module.c:<global>,,false,1,4367,<global>,,,1,
189326,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"typedef ngx_int_t (*ngx_http_proxy_rewrite_pt)(ngx_http_request_t *r,
    ngx_table_elt_t *h, size_t prefix, size_t len,
    ngx_http_proxy_rewrite_t *pr);",19,33,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_rewrite_pt,,false,20,22,ngx_http_proxy_rewrite_pt,,,5,"ngx_int_t ngx_http_proxy_rewrite_pt (ngx_http_request_t*,ngx_table_elt_t*,size_t,size_t,ngx_http_proxy_rewrite_t*)"
189399,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_proxy_eval(ngx_http_request_t *r,
    ngx_http_proxy_ctx_t *ctx, ngx_http_proxy_loc_conf_t *plcf);",18,63,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_eval,,false,122,123,ngx_http_proxy_eval,,,15,"ngx_int_t ngx_http_proxy_eval (ngx_http_request_t*,ngx_http_proxy_ctx_t*,ngx_http_proxy_loc_conf_t*)"
189406,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_proxy_create_request(ngx_http_request_t *r);,18,69,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_create_request,,false,127,127,ngx_http_proxy_create_request,,,16,ngx_int_t ngx_http_proxy_create_request (ngx_http_request_t*)
189411,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_proxy_reinit_request(ngx_http_request_t *r);,18,69,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_reinit_request,,false,128,128,ngx_http_proxy_reinit_request,,,17,ngx_int_t ngx_http_proxy_reinit_request (ngx_http_request_t*)
189416,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_proxy_body_output_filter(void *data, ngx_chain_t *in);",18,79,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_body_output_filter,,false,129,129,ngx_http_proxy_body_output_filter,,,18,"ngx_int_t ngx_http_proxy_body_output_filter (void*,ngx_chain_t*)"
189422,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_proxy_process_status_line(ngx_http_request_t *r);,18,74,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_process_status_line,,false,130,130,ngx_http_proxy_process_status_line,,,19,ngx_int_t ngx_http_proxy_process_status_line (ngx_http_request_t*)
189427,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_proxy_process_header(ngx_http_request_t *r);,18,69,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_process_header,,false,131,131,ngx_http_proxy_process_header,,,20,ngx_int_t ngx_http_proxy_process_header (ngx_http_request_t*)
189432,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_proxy_input_filter_init(void *data);,18,61,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_input_filter_init,,false,132,132,ngx_http_proxy_input_filter_init,,,21,ngx_int_t ngx_http_proxy_input_filter_init (void*)
189437,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_proxy_copy_filter(ngx_event_pipe_t *p,
    ngx_buf_t *buf);",18,19,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_copy_filter,,false,133,134,ngx_http_proxy_copy_filter,,,22,"ngx_int_t ngx_http_proxy_copy_filter (ngx_event_pipe_t*,ngx_buf_t*)"
189443,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_proxy_chunked_filter(ngx_event_pipe_t *p,
    ngx_buf_t *buf);",18,19,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_chunked_filter,,false,135,136,ngx_http_proxy_chunked_filter,,,23,"ngx_int_t ngx_http_proxy_chunked_filter (ngx_event_pipe_t*,ngx_buf_t*)"
189449,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_proxy_non_buffered_copy_filter(void *data,
    ssize_t bytes);",18,18,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_non_buffered_copy_filter,,false,137,138,ngx_http_proxy_non_buffered_copy_filter,,,24,"ngx_int_t ngx_http_proxy_non_buffered_copy_filter (void*,ssize_t)"
189455,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_proxy_non_buffered_chunked_filter(void *data,
    ssize_t bytes);",18,18,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_non_buffered_chunked_filter,,false,139,140,ngx_http_proxy_non_buffered_chunked_filter,,,25,"ngx_int_t ngx_http_proxy_non_buffered_chunked_filter (void*,ssize_t)"
189461,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,static void ngx_http_proxy_abort_request(ngx_http_request_t *r);,13,63,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_abort_request,,false,141,141,ngx_http_proxy_abort_request,,,26,void ngx_http_proxy_abort_request (ngx_http_request_t*)
189466,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static void ngx_http_proxy_finalize_request(ngx_http_request_t *r,
    ngx_int_t rc);",13,17,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_finalize_request,,false,142,143,ngx_http_proxy_finalize_request,,,27,"void ngx_http_proxy_finalize_request (ngx_http_request_t*,ngx_int_t)"
189472,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_proxy_host_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_host_variable,,false,145,146,ngx_http_proxy_host_variable,,,28,"ngx_int_t ngx_http_proxy_host_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
189479,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_proxy_port_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_port_variable,,false,147,148,ngx_http_proxy_port_variable,,,29,"ngx_int_t ngx_http_proxy_port_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
189486,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t
    ngx_http_proxy_add_x_forwarded_for_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",5,49,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_add_x_forwarded_for_variable,,false,150,151,ngx_http_proxy_add_x_forwarded_for_variable,,,30,"ngx_int_t ngx_http_proxy_add_x_forwarded_for_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
189493,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t
    ngx_http_proxy_internal_body_length_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",5,49,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_internal_body_length_variable,,false,153,154,ngx_http_proxy_internal_body_length_variable,,,31,"ngx_int_t ngx_http_proxy_internal_body_length_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
189500,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_proxy_internal_chunked_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_internal_chunked_variable,,false,155,156,ngx_http_proxy_internal_chunked_variable,,,32,"ngx_int_t ngx_http_proxy_internal_chunked_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
189507,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_proxy_rewrite_redirect(ngx_http_request_t *r,
    ngx_table_elt_t *h, size_t prefix);",18,38,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_rewrite_redirect,,false,157,158,ngx_http_proxy_rewrite_redirect,,,33,"ngx_int_t ngx_http_proxy_rewrite_redirect (ngx_http_request_t*,ngx_table_elt_t*,size_t)"
189514,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_proxy_rewrite_cookie(ngx_http_request_t *r,
    ngx_table_elt_t *h);",18,23,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_rewrite_cookie,,false,159,160,ngx_http_proxy_rewrite_cookie,,,34,"ngx_int_t ngx_http_proxy_rewrite_cookie (ngx_http_request_t*,ngx_table_elt_t*)"
189520,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_proxy_rewrite_cookie_value(ngx_http_request_t *r,
    ngx_table_elt_t *h, u_char *value, ngx_array_t *rewrites);",18,61,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_rewrite_cookie_value,,false,161,162,ngx_http_proxy_rewrite_cookie_value,,,35,"ngx_int_t ngx_http_proxy_rewrite_cookie_value (ngx_http_request_t*,ngx_table_elt_t*,u_char*,ngx_array_t*)"
189528,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_proxy_rewrite(ngx_http_request_t *r,
    ngx_table_elt_t *h, size_t prefix, size_t len, ngx_str_t *replacement);",18,74,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_rewrite,,false,163,164,ngx_http_proxy_rewrite,,,36,"ngx_int_t ngx_http_proxy_rewrite (ngx_http_request_t*,ngx_table_elt_t*,size_t,size_t,ngx_str_t*)"
189537,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_proxy_add_variables(ngx_conf_t *cf);,18,61,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_add_variables,,false,166,166,ngx_http_proxy_add_variables,,,37,ngx_int_t ngx_http_proxy_add_variables (ngx_conf_t*)
189542,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,static void *ngx_http_proxy_create_main_conf(ngx_conf_t *cf);,13,60,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_create_main_conf,,false,167,167,ngx_http_proxy_create_main_conf,,,38,void* ngx_http_proxy_create_main_conf (ngx_conf_t*)
189547,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,static void *ngx_http_proxy_create_loc_conf(ngx_conf_t *cf);,13,59,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_create_loc_conf,,false,168,168,ngx_http_proxy_create_loc_conf,,,39,void* ngx_http_proxy_create_loc_conf (ngx_conf_t*)
189552,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static char *ngx_http_proxy_merge_loc_conf(ngx_conf_t *cf,
    void *parent, void *child);",13,30,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_merge_loc_conf,,false,169,170,ngx_http_proxy_merge_loc_conf,,,40,"char* ngx_http_proxy_merge_loc_conf (ngx_conf_t*,void*,void*)"
189559,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_proxy_init_headers(ngx_conf_t *cf,
    ngx_http_proxy_loc_conf_t *conf, ngx_http_proxy_headers_t *headers,
    ngx_keyval_t *default_headers);",18,34,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_init_headers,,false,171,173,ngx_http_proxy_init_headers,,,41,"ngx_int_t ngx_http_proxy_init_headers (ngx_conf_t*,ngx_http_proxy_loc_conf_t*,ngx_http_proxy_headers_t*,ngx_keyval_t*)"
189567,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static char *ngx_http_proxy_pass(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_pass,,false,175,176,ngx_http_proxy_pass,,,42,"char* ngx_http_proxy_pass (ngx_conf_t*,ngx_command_t*,void*)"
189574,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static char *ngx_http_proxy_redirect(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_redirect,,false,177,178,ngx_http_proxy_redirect,,,43,"char* ngx_http_proxy_redirect (ngx_conf_t*,ngx_command_t*,void*)"
189581,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static char *ngx_http_proxy_cookie_domain(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_cookie_domain,,false,179,180,ngx_http_proxy_cookie_domain,,,44,"char* ngx_http_proxy_cookie_domain (ngx_conf_t*,ngx_command_t*,void*)"
189588,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static char *ngx_http_proxy_cookie_path(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_cookie_path,,false,181,182,ngx_http_proxy_cookie_path,,,45,"char* ngx_http_proxy_cookie_path (ngx_conf_t*,ngx_command_t*,void*)"
189595,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static char *ngx_http_proxy_store(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_store,,false,183,184,ngx_http_proxy_store,,,46,"char* ngx_http_proxy_store (ngx_conf_t*,ngx_command_t*,void*)"
189602,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static char *ngx_http_proxy_lowat_check(ngx_conf_t *cf, void *post, void *data);",13,79,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_lowat_check,,false,196,196,ngx_http_proxy_lowat_check,,,47,"char* ngx_http_proxy_lowat_check (ngx_conf_t*,void*,void*)"
189609,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_proxy_rewrite_regex(ngx_conf_t *cf,
    ngx_http_proxy_rewrite_t *pr, ngx_str_t *regex, ngx_uint_t caseless);",18,72,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_rewrite_regex,,false,198,199,ngx_http_proxy_rewrite_regex,,,48,"ngx_int_t ngx_http_proxy_rewrite_regex (ngx_conf_t*,ngx_http_proxy_rewrite_t*,ngx_str_t*,ngx_uint_t)"
189617,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static void ngx_http_proxy_set_vars(ngx_url_t *u, ngx_http_proxy_vars_t *v);",13,75,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_set_vars,,false,205,205,ngx_http_proxy_set_vars,,,49,"void ngx_http_proxy_set_vars (ngx_url_t*,ngx_http_proxy_vars_t*)"
190530,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_proxy_handler(ngx_http_request_t *r)
{
    ngx_int_t                    rc;
    ngx_http_upstream_t         *u;
    ngx_http_proxy_ctx_t        *ctx;
    ngx_http_proxy_loc_conf_t   *plcf;
#if (NGX_HTTP_CACHE)
    ngx_http_proxy_main_conf_t  *pmcf;
#endif

    if (ngx_http_upstream_create(r) != NGX_OK) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_proxy_ctx_t));
    if (ctx == NULL) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    ngx_http_set_ctx(r, ctx, ngx_http_proxy_module);

    plcf = ngx_http_get_module_loc_conf(r, ngx_http_proxy_module);

    u = r->upstream;

    if (plcf->proxy_lengths == NULL) {
        ctx->vars = plcf->vars;
        u->schema = plcf->vars.schema;
#if (NGX_HTTP_SSL)
        u->ssl = (plcf->upstream.ssl != NULL);
#endif

    } else {
        if (ngx_http_proxy_eval(r, ctx, plcf) != NGX_OK) {
            return NGX_HTTP_INTERNAL_SERVER_ERROR;
        }
    }

    ...",1,1,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_handler,,false,848,944,ngx_http_proxy_handler,,,73,ngx_int_t ngx_http_proxy_handler (ngx_http_request_t*)
190796,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_proxy_eval(ngx_http_request_t *r, ngx_http_proxy_ctx_t *ctx,
    ngx_http_proxy_loc_conf_t *plcf)
{
    u_char               *p;
    size_t                add;
    u_short               port;
    ngx_str_t             proxy;
    ngx_url_t             url;
    ngx_http_upstream_t  *u;

    if (ngx_http_script_run(r, &proxy, plcf->proxy_lengths->elts, 0,
                            plcf->proxy_values->elts)
        == NULL)
    {
        return NGX_ERROR;
    }

    if (proxy.len > 7
        && ngx_strncasecmp(proxy.data, (u_char *) ""http://"", 7) == 0)
    {
        add = 7;
        port = 80;

#if (NGX_HTTP_SSL)

    } else if (proxy.len > 8
               && ngx_strncasecmp(proxy.data, (u_char *) ""https://"", 8) == 0)
    {
        add = 8;
        port = 443;
        r->upstream->ssl = 1;

#endif

    } else {
        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                      ""invalid URL prefix in \""%V\"""", &proxy);
        return NGX_ERROR;
  ...",1,1,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_eval,,false,947,1046,ngx_http_proxy_eval,,,74,"ngx_int_t ngx_http_proxy_eval (ngx_http_request_t*,ngx_http_proxy_ctx_t*,ngx_http_proxy_loc_conf_t*)"
191156,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_proxy_create_request(ngx_http_request_t *r)
{
    size_t                        len, uri_len, loc_len, body_len,
                                  key_len, val_len;
    uintptr_t                     escape;
    ngx_buf_t                    *b;
    ngx_str_t                     method;
    ngx_uint_t                    i, unparsed_uri;
    ngx_chain_t                  *cl, *body;
    ngx_list_part_t              *part;
    ngx_table_elt_t              *header;
    ngx_http_upstream_t          *u;
    ngx_http_proxy_ctx_t         *ctx;
    ngx_http_script_code_pt       code;
    ngx_http_proxy_headers_t     *headers;
    ngx_http_script_engine_t      e, le;
    ngx_http_proxy_loc_conf_t    *plcf;
    ngx_http_script_len_code_pt   lcode;

    u = r->upstream;

    plcf = ngx_http_get_module_loc_conf(r, ngx_http_proxy_module);

#if (NGX_HTTP_CACHE)
    headers = u->cacheable ? &plcf->headers_cache : &plcf->headers;
#else
    headers = &plcf->headers;
#endif

  ...",1,1,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_create_request,,false,1149,1519,ngx_http_proxy_create_request,,,75,ngx_int_t ngx_http_proxy_create_request (ngx_http_request_t*)
192649,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_proxy_reinit_request(ngx_http_request_t *r)
{
    ngx_http_proxy_ctx_t  *ctx;

    ctx = ngx_http_get_module_ctx(r, ngx_http_proxy_module);

    if (ctx == NULL) {
        return NGX_OK;
    }

    ctx->status.code = 0;
    ctx->status.count = 0;
    ctx->status.start = NULL;
    ctx->status.end = NULL;
    ctx->chunked.state = 0;

    r->upstream->process_header = ngx_http_proxy_process_status_line;
    r->upstream->pipe->input_filter = ngx_http_proxy_copy_filter;
    r->upstream->input_filter = ngx_http_proxy_non_buffered_copy_filter;
    r->state = 0;

    return NGX_OK;
}",1,1,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_reinit_request,,false,1522,1545,ngx_http_proxy_reinit_request,,,76,ngx_int_t ngx_http_proxy_reinit_request (ngx_http_request_t*)
192732,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_proxy_body_output_filter(void *data, ngx_chain_t *in)
{
    ngx_http_request_t  *r = data;

    off_t                  size;
    u_char                *chunk;
    ngx_int_t              rc;
    ngx_buf_t             *b;
    ngx_chain_t           *out, *cl, *tl, **ll, **fl;
    ngx_http_proxy_ctx_t  *ctx;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""proxy output filter"");

    ctx = ngx_http_get_module_ctx(r, ngx_http_proxy_module);

    if (in == NULL) {
        out = in;
        goto out;
    }

    out = NULL;
    ll = &out;

    if (!ctx->header_sent) {
        /* first buffer contains headers, pass it unmodified */

        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                       ""proxy output header"");

        ctx->header_sent = 1;

        tl = ngx_alloc_chain_link(r->pool);
        if (tl == NULL) {
            return NGX_ERROR;
        }

        tl->buf = in->buf;
        *ll = tl;
    ...",1,1,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_body_output_filter,,false,1548,1712,ngx_http_proxy_body_output_filter,,,77,"ngx_int_t ngx_http_proxy_body_output_filter (void*,ngx_chain_t*)"
193222,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_proxy_process_status_line(ngx_http_request_t *r)
{
    size_t                 len;
    ngx_int_t              rc;
    ngx_http_upstream_t   *u;
    ngx_http_proxy_ctx_t  *ctx;

    ctx = ngx_http_get_module_ctx(r, ngx_http_proxy_module);

    if (ctx == NULL) {
        return NGX_ERROR;
    }

    u = r->upstream;

    rc = ngx_http_parse_status_line(r, &u->buffer, &ctx->status);

    if (rc == NGX_AGAIN) {
        return rc;
    }

    if (rc == NGX_ERROR) {

#if (NGX_HTTP_CACHE)

        if (r->cache) {
            r->http_version = NGX_HTTP_VERSION_9;
            return NGX_OK;
        }

#endif

        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                      ""upstream sent no valid HTTP/1.0 header"");

#if 0
        if (u->accel) {
            return NGX_HTTP_UPSTREAM_INVALID_HEADER;
        }
#endif

        r->http_version = NGX_HTTP_VERSION_9;
        u->state->status = NGX_HTTP_OK;
        u->headers_in.connection_close = 1;

        ...",1,1,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_process_status_line,,false,1715,1791,ngx_http_proxy_process_status_line,,,78,ngx_int_t ngx_http_proxy_process_status_line (ngx_http_request_t*)
193443,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_proxy_process_header(ngx_http_request_t *r)
{
    ngx_int_t                       rc;
    ngx_table_elt_t                *h;
    ngx_http_upstream_t            *u;
    ngx_http_proxy_ctx_t           *ctx;
    ngx_http_upstream_header_t     *hh;
    ngx_http_upstream_main_conf_t  *umcf;

    umcf = ngx_http_get_module_main_conf(r, ngx_http_upstream_module);

    for ( ;; ) {

        rc = ngx_http_parse_header_line(r, &r->upstream->buffer, 1);

        if (rc == NGX_OK) {

            /* a header line has been parsed successfully */

            h = ngx_list_push(&r->upstream->headers_in.headers);
            if (h == NULL) {
                return NGX_ERROR;
            }

            h->hash = r->header_hash;

            h->key.len = r->header_name_end - r->header_name_start;
            h->value.len = r->header_end - r->header_start;

            h->key.data = ngx_pnalloc(r->pool,
                               h->key.len + 1 + h->value.len + 1 + h->key....",1,1,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_process_header,,false,1794,1945,ngx_http_proxy_process_header,,,79,ngx_int_t ngx_http_proxy_process_header (ngx_http_request_t*)
194017,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_proxy_input_filter_init(void *data)
{
    ngx_http_request_t    *r = data;
    ngx_http_upstream_t   *u;
    ngx_http_proxy_ctx_t  *ctx;

    u = r->upstream;
    ctx = ngx_http_get_module_ctx(r, ngx_http_proxy_module);

    if (ctx == NULL) {
        return NGX_ERROR;
    }

    ngx_log_debug4(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http proxy filter init s:%ui h:%d c:%d l:%O"",
                   u->headers_in.status_n, ctx->head, u->headers_in.chunked,
                   u->headers_in.content_length_n);

    /* as per RFC2616, 4.4 Message Length */

    if (u->headers_in.status_n == NGX_HTTP_NO_CONTENT
        || u->headers_in.status_n == NGX_HTTP_NOT_MODIFIED
        || ctx->head)
    {
        /* 1xx, 204, and 304 and replies to HEAD requests */
        /* no 1xx since we don't send Expect and Upgrade */

        u->pipe->length = 0;
        u->length = 0;
        u->keepalive = !u->headers_in.connection_close;

    } else if (u->...",1,1,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_input_filter_init,,false,1948,2004,ngx_http_proxy_input_filter_init,,,80,ngx_int_t ngx_http_proxy_input_filter_init (void*)
194205,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_proxy_copy_filter(ngx_event_pipe_t *p, ngx_buf_t *buf)
{
    ngx_buf_t           *b;
    ngx_chain_t         *cl;
    ngx_http_request_t  *r;

    if (buf->pos == buf->last) {
        return NGX_OK;
    }

    cl = ngx_chain_get_free_buf(p->pool, &p->free);
    if (cl == NULL) {
        return NGX_ERROR;
    }

    b = cl->buf;

    ngx_memcpy(b, buf, sizeof(ngx_buf_t));
    b->shadow = buf;
    b->tag = p->tag;
    b->last_shadow = 1;
    b->recycled = 1;
    buf->shadow = b;

    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, p->log, 0, ""input buf #%d"", b->num);

    if (p->in) {
        *p->last_in = cl;
    } else {
        p->in = cl;
    }
    p->last_in = &cl->next;

    if (p->length == -1) {
        return NGX_OK;
    }

    p->length -= b->last - b->pos;

    if (p->length == 0) {
        r = p->input_ctx;
        p->upstream_done = 1;
        r->upstream->keepalive = !r->upstream->headers_in.connection_close;

    } else if (p->length < 0) {
        r = p->...",1,1,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_copy_filter,,false,2007,2062,ngx_http_proxy_copy_filter,,,81,"ngx_int_t ngx_http_proxy_copy_filter (ngx_event_pipe_t*,ngx_buf_t*)"
194397,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_proxy_chunked_filter(ngx_event_pipe_t *p, ngx_buf_t *buf)
{
    ngx_int_t              rc;
    ngx_buf_t             *b, **prev;
    ngx_chain_t           *cl;
    ngx_http_request_t    *r;
    ngx_http_proxy_ctx_t  *ctx;

    if (buf->pos == buf->last) {
        return NGX_OK;
    }

    r = p->input_ctx;
    ctx = ngx_http_get_module_ctx(r, ngx_http_proxy_module);

    if (ctx == NULL) {
        return NGX_ERROR;
    }

    b = NULL;
    prev = &buf->shadow;

    for ( ;; ) {

        rc = ngx_http_parse_chunked(r, buf, &ctx->chunked);

        if (rc == NGX_OK) {

            /* a chunk has been parsed successfully */

            cl = ngx_chain_get_free_buf(p->pool, &p->free);
            if (cl == NULL) {
                return NGX_ERROR;
            }

            b = cl->buf;

            ngx_memzero(b, sizeof(ngx_buf_t));

            b->pos = buf->pos;
            b->start = buf->start;
            b->end = buf->end;
            b->tag = p->tag;
  ...",1,1,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_chunked_filter,,false,2065,2191,ngx_http_proxy_chunked_filter,,,82,"ngx_int_t ngx_http_proxy_chunked_filter (ngx_event_pipe_t*,ngx_buf_t*)"
194763,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_proxy_non_buffered_copy_filter(void *data, ssize_t bytes)
{
    ngx_http_request_t   *r = data;

    ngx_buf_t            *b;
    ngx_chain_t          *cl, **ll;
    ngx_http_upstream_t  *u;

    u = r->upstream;

    for (cl = u->out_bufs, ll = &u->out_bufs; cl; cl = cl->next) {
        ll = &cl->next;
    }

    cl = ngx_chain_get_free_buf(r->pool, &u->free_bufs);
    if (cl == NULL) {
        return NGX_ERROR;
    }

    *ll = cl;

    cl->buf->flush = 1;
    cl->buf->memory = 1;

    b = &u->buffer;

    cl->buf->pos = b->last;
    b->last += bytes;
    cl->buf->last = b->last;
    cl->buf->tag = u->output.tag;

    if (u->length == -1) {
        return NGX_OK;
    }

    u->length -= bytes;

    if (u->length == 0) {
        u->keepalive = !u->headers_in.connection_close;
    }

    return NGX_OK;
}",1,1,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_non_buffered_copy_filter,,false,2194,2237,ngx_http_proxy_non_buffered_copy_filter,,,83,"ngx_int_t ngx_http_proxy_non_buffered_copy_filter (void*,ssize_t)"
194918,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_proxy_non_buffered_chunked_filter(void *data, ssize_t bytes)
{
    ngx_http_request_t   *r = data;

    ngx_int_t              rc;
    ngx_buf_t             *b, *buf;
    ngx_chain_t           *cl, **ll;
    ngx_http_upstream_t   *u;
    ngx_http_proxy_ctx_t  *ctx;

    ctx = ngx_http_get_module_ctx(r, ngx_http_proxy_module);

    if (ctx == NULL) {
        return NGX_ERROR;
    }

    u = r->upstream;
    buf = &u->buffer;

    buf->pos = buf->last;
    buf->last += bytes;

    for (cl = u->out_bufs, ll = &u->out_bufs; cl; cl = cl->next) {
        ll = &cl->next;
    }

    for ( ;; ) {

        rc = ngx_http_parse_chunked(r, buf, &ctx->chunked);

        if (rc == NGX_OK) {

            /* a chunk has been parsed successfully */

            cl = ngx_chain_get_free_buf(r->pool, &u->free_bufs);
            if (cl == NULL) {
                return NGX_ERROR;
            }

            *ll = cl;
            ll = &cl->next;

            b = cl->buf;

        ...",1,1,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_non_buffered_chunked_filter,,false,2240,2332,ngx_http_proxy_non_buffered_chunked_filter,,,84,"ngx_int_t ngx_http_proxy_non_buffered_chunked_filter (void*,ssize_t)"
195201,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static void
ngx_http_proxy_abort_request(ngx_http_request_t *r)
{
    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""abort http proxy request"");

    return;
}",1,1,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_abort_request,,false,2335,2342,ngx_http_proxy_abort_request,,,85,void ngx_http_proxy_abort_request (ngx_http_request_t*)
195216,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static void
ngx_http_proxy_finalize_request(ngx_http_request_t *r, ngx_int_t rc)
{
    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""finalize http proxy request"");

    return;
}",1,1,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_finalize_request,,false,2345,2352,ngx_http_proxy_finalize_request,,,86,"void ngx_http_proxy_finalize_request (ngx_http_request_t*,ngx_int_t)"
195232,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_proxy_host_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    ngx_http_proxy_ctx_t  *ctx;

    ctx = ngx_http_get_module_ctx(r, ngx_http_proxy_module);

    if (ctx == NULL) {
        v->not_found = 1;
        return NGX_OK;
    }

    v->len = ctx->vars.host_header.len;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = ctx->vars.host_header.data;

    return NGX_OK;
}",1,1,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_host_variable,,false,2355,2375,ngx_http_proxy_host_variable,,,87,"ngx_int_t ngx_http_proxy_host_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
195296,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_proxy_port_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    ngx_http_proxy_ctx_t  *ctx;

    ctx = ngx_http_get_module_ctx(r, ngx_http_proxy_module);

    if (ctx == NULL) {
        v->not_found = 1;
        return NGX_OK;
    }

    v->len = ctx->vars.port.len;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = ctx->vars.port.data;

    return NGX_OK;
}",1,1,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_port_variable,,false,2378,2398,ngx_http_proxy_port_variable,,,88,"ngx_int_t ngx_http_proxy_port_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
195360,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_proxy_add_x_forwarded_for_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    size_t             len;
    u_char            *p;
    ngx_uint_t         i, n;
    ngx_table_elt_t  **h;

    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;

    n = r->headers_in.x_forwarded_for.nelts;
    h = r->headers_in.x_forwarded_for.elts;

    len = 0;

    for (i = 0; i < n; i++) {
        len += h[i]->value.len + sizeof("", "") - 1;
    }

    if (len == 0) {
        v->len = r->connection->addr_text.len;
        v->data = r->connection->addr_text.data;
        return NGX_OK;
    }

    len += r->connection->addr_text.len;

    p = ngx_pnalloc(r->pool, len);
    if (p == NULL) {
        return NGX_ERROR;
    }

    v->len = len;
    v->data = p;

    for (i = 0; i < n; i++) {
        p = ngx_copy(p, h[i]->value.data, h[i]->value.len);
        *p++ = ','; *p++ = ' ';
    }

    ngx_memcpy(p, r->connection->addr_text.data, r-...",1,1,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_add_x_forwarded_for_variable,,false,2401,2447,ngx_http_proxy_add_x_forwarded_for_variable,,,89,"ngx_int_t ngx_http_proxy_add_x_forwarded_for_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
195552,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_proxy_internal_body_length_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    ngx_http_proxy_ctx_t  *ctx;

    ctx = ngx_http_get_module_ctx(r, ngx_http_proxy_module);

    if (ctx == NULL || ctx->internal_body_length < 0) {
        v->not_found = 1;
        return NGX_OK;
    }

    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;

    v->data = ngx_pnalloc(r->pool, NGX_OFF_T_LEN);

    if (v->data == NULL) {
        return NGX_ERROR;
    }

    v->len = ngx_sprintf(v->data, ""%O"", ctx->internal_body_length) - v->data;

    return NGX_OK;
}",1,1,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_internal_body_length_variable,,false,2450,2476,ngx_http_proxy_internal_body_length_variable,,,90,"ngx_int_t ngx_http_proxy_internal_body_length_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
195634,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_proxy_internal_chunked_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    ngx_http_proxy_ctx_t  *ctx;

    ctx = ngx_http_get_module_ctx(r, ngx_http_proxy_module);

    if (ctx == NULL || !ctx->internal_chunked) {
        v->not_found = 1;
        return NGX_OK;
    }

    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;

    v->data = (u_char *) ""chunked"";
    v->len = sizeof(""chunked"") - 1;

    return NGX_OK;
}",1,1,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_internal_chunked_variable,,false,2479,2500,ngx_http_proxy_internal_chunked_variable,,,91,"ngx_int_t ngx_http_proxy_internal_chunked_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
195696,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_proxy_rewrite_redirect(ngx_http_request_t *r, ngx_table_elt_t *h,
    size_t prefix)
{
    size_t                      len;
    ngx_int_t                   rc;
    ngx_uint_t                  i;
    ngx_http_proxy_rewrite_t   *pr;
    ngx_http_proxy_loc_conf_t  *plcf;

    plcf = ngx_http_get_module_loc_conf(r, ngx_http_proxy_module);

    pr = plcf->redirects->elts;

    if (pr == NULL) {
        return NGX_DECLINED;
    }

    len = h->value.len - prefix;

    for (i = 0; i < plcf->redirects->nelts; i++) {
        rc = pr[i].handler(r, h, prefix, len, &pr[i]);

        if (rc != NGX_DECLINED) {
            return rc;
        }
    }

    return NGX_DECLINED;
}",1,1,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_rewrite_redirect,,false,2503,2532,ngx_http_proxy_rewrite_redirect,,,92,"ngx_int_t ngx_http_proxy_rewrite_redirect (ngx_http_request_t*,ngx_table_elt_t*,size_t)"
195776,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_proxy_rewrite_cookie(ngx_http_request_t *r, ngx_table_elt_t *h)
{
    size_t                      prefix;
    u_char                     *p;
    ngx_int_t                   rc, rv;
    ngx_http_proxy_loc_conf_t  *plcf;

    p = (u_char *) ngx_strchr(h->value.data, ';');
    if (p == NULL) {
        return NGX_DECLINED;
    }

    prefix = p + 1 - h->value.data;

    rv = NGX_DECLINED;

    plcf = ngx_http_get_module_loc_conf(r, ngx_http_proxy_module);

    if (plcf->cookie_domains) {
        p = ngx_strcasestrn(h->value.data + prefix, ""domain="", 7 - 1);

        if (p) {
            rc = ngx_http_proxy_rewrite_cookie_value(r, h, p + 7,
                                                     plcf->cookie_domains);
            if (rc == NGX_ERROR) {
                return NGX_ERROR;
            }

            if (rc != NGX_DECLINED) {
                rv = rc;
            }
        }
    }

    if (plcf->cookie_paths) {
        p = ngx_strcasestrn(h->value.data +...",1,1,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_rewrite_cookie,,false,2535,2587,ngx_http_proxy_rewrite_cookie,,,93,"ngx_int_t ngx_http_proxy_rewrite_cookie (ngx_http_request_t*,ngx_table_elt_t*)"
195922,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_proxy_rewrite_cookie_value(ngx_http_request_t *r, ngx_table_elt_t *h,
    u_char *value, ngx_array_t *rewrites)
{
    size_t                     len, prefix;
    u_char                    *p;
    ngx_int_t                  rc;
    ngx_uint_t                 i;
    ngx_http_proxy_rewrite_t  *pr;

    prefix = value - h->value.data;

    p = (u_char *) ngx_strchr(value, ';');

    len = p ? (size_t) (p - value) : (h->value.len - prefix);

    pr = rewrites->elts;

    for (i = 0; i < rewrites->nelts; i++) {
        rc = pr[i].handler(r, h, prefix, len, &pr[i]);

        if (rc != NGX_DECLINED) {
            return rc;
        }
    }

    return NGX_DECLINED;
}",1,1,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_rewrite_cookie_value,,false,2590,2617,ngx_http_proxy_rewrite_cookie_value,,,94,"ngx_int_t ngx_http_proxy_rewrite_cookie_value (ngx_http_request_t*,ngx_table_elt_t*,u_char*,ngx_array_t*)"
196010,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_proxy_rewrite_complex_handler(ngx_http_request_t *r,
    ngx_table_elt_t *h, size_t prefix, size_t len, ngx_http_proxy_rewrite_t *pr)
{
    ngx_str_t  pattern, replacement;

    if (ngx_http_complex_value(r, &pr->pattern.complex, &pattern) != NGX_OK) {
        return NGX_ERROR;
    }

    if (pattern.len > len
        || ngx_rstrncmp(h->value.data + prefix, pattern.data,
                        pattern.len) != 0)
    {
        return NGX_DECLINED;
    }

    if (ngx_http_complex_value(r, &pr->replacement, &replacement) != NGX_OK) {
        return NGX_ERROR;
    }

    return ngx_http_proxy_rewrite(r, h, prefix, pattern.len, &replacement);
}",1,1,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_rewrite_complex_handler,,false,2620,2642,ngx_http_proxy_rewrite_complex_handler,,,95,"ngx_int_t ngx_http_proxy_rewrite_complex_handler (ngx_http_request_t*,ngx_table_elt_t*,size_t,size_t,ngx_http_proxy_rewrite_t*)"
196087,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_proxy_rewrite_domain_handler(ngx_http_request_t *r,
    ngx_table_elt_t *h, size_t prefix, size_t len, ngx_http_proxy_rewrite_t *pr)
{
    u_char     *p;
    ngx_str_t   pattern, replacement;

    if (ngx_http_complex_value(r, &pr->pattern.complex, &pattern) != NGX_OK) {
        return NGX_ERROR;
    }

    p = h->value.data + prefix;

    if (p[0] == '.') {
        p++;
        prefix++;
        len--;
    }

    if (pattern.len != len || ngx_rstrncasecmp(pattern.data, p, len) != 0) {
        return NGX_DECLINED;
    }

    if (ngx_http_complex_value(r, &pr->replacement, &replacement) != NGX_OK) {
        return NGX_ERROR;
    }

    return ngx_http_proxy_rewrite(r, h, prefix, len, &replacement);
}",1,1,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_rewrite_domain_handler,,false,2675,2703,ngx_http_proxy_rewrite_domain_handler,,,96,"ngx_int_t ngx_http_proxy_rewrite_domain_handler (ngx_http_request_t*,ngx_table_elt_t*,size_t,size_t,ngx_http_proxy_rewrite_t*)"
196177,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_proxy_rewrite(ngx_http_request_t *r, ngx_table_elt_t *h, size_t prefix,
    size_t len, ngx_str_t *replacement)
{
    u_char  *p, *data;
    size_t   new_len;

    new_len = replacement->len + h->value.len - len;

    if (replacement->len > len) {

        data = ngx_pnalloc(r->pool, new_len + 1);
        if (data == NULL) {
            return NGX_ERROR;
        }

        p = ngx_copy(data, h->value.data, prefix);
        p = ngx_copy(p, replacement->data, replacement->len);

        ngx_memcpy(p, h->value.data + prefix + len,
                   h->value.len - len - prefix + 1);

        h->value.data = data;

    } else {
        p = ngx_copy(h->value.data + prefix, replacement->data,
                     replacement->len);

        ngx_memmove(p, h->value.data + prefix + len,
                    h->value.len - len - prefix + 1);
    }

    h->value.len = new_len;

    return NGX_OK;
}",1,1,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_rewrite,,false,2706,2741,ngx_http_proxy_rewrite,,,97,"ngx_int_t ngx_http_proxy_rewrite (ngx_http_request_t*,ngx_table_elt_t*,size_t,size_t,ngx_str_t*)"
196323,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_proxy_add_variables(ngx_conf_t *cf)
{
    ngx_http_variable_t  *var, *v;

    for (v = ngx_http_proxy_vars; v->name.len; v++) {
        var = ngx_http_add_variable(cf, &v->name, v->flags);
        if (var == NULL) {
            return NGX_ERROR;
        }

        var->get_handler = v->get_handler;
        var->data = v->data;
    }

    return NGX_OK;
}",1,1,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_add_variables,,false,2744,2760,ngx_http_proxy_add_variables,,,98,ngx_int_t ngx_http_proxy_add_variables (ngx_conf_t*)
196377,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static void *
ngx_http_proxy_create_main_conf(ngx_conf_t *cf)
{
    ngx_http_proxy_main_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_proxy_main_conf_t));
    if (conf == NULL) {
        return NULL;
    }

#if (NGX_HTTP_CACHE)
    if (ngx_array_init(&conf->caches, cf->pool, 4,
                       sizeof(ngx_http_file_cache_t *))
        != NGX_OK)
    {
        return NULL;
    }
#endif

    return conf;
}",1,1,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_create_main_conf,,false,2763,2783,ngx_http_proxy_create_main_conf,,,99,void* ngx_http_proxy_create_main_conf (ngx_conf_t*)
196400,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static void *
ngx_http_proxy_create_loc_conf(ngx_conf_t *cf)
{
    ngx_http_proxy_loc_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_proxy_loc_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     conf->upstream.bufs.num = 0;
     *     conf->upstream.ignore_headers = 0;
     *     conf->upstream.next_upstream = 0;
     *     conf->upstream.cache_zone = NULL;
     *     conf->upstream.cache_use_stale = 0;
     *     conf->upstream.cache_methods = 0;
     *     conf->upstream.temp_path = NULL;
     *     conf->upstream.hide_headers_hash = { NULL, 0 };
     *     conf->upstream.store_lengths = NULL;
     *     conf->upstream.store_values = NULL;
     *     conf->upstream.ssl_name = NULL;
     *
     *     conf->method = NULL;
     *     conf->location = NULL;
     *     conf->url = { 0, NULL };
     *     conf->headers_source = NULL;
     *     conf->headers.lengths = NULL;
     *     conf->headers.values ...",1,1,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_create_loc_conf,,false,2786,2906,ngx_http_proxy_create_loc_conf,,,100,void* ngx_http_proxy_create_loc_conf (ngx_conf_t*)
196643,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static char *
ngx_http_proxy_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_proxy_loc_conf_t *prev = parent;
    ngx_http_proxy_loc_conf_t *conf = child;

    u_char                     *p;
    size_t                      size;
    ngx_int_t                   rc;
    ngx_hash_init_t             hash;
    ngx_http_core_loc_conf_t   *clcf;
    ngx_http_proxy_rewrite_t   *pr;
    ngx_http_script_compile_t   sc;

#if (NGX_HTTP_CACHE)

    if (conf->upstream.store > 0) {
        conf->upstream.cache = 0;
    }

    if (conf->upstream.cache > 0) {
        conf->upstream.store = 0;
    }

#endif

    if (conf->upstream.store == NGX_CONF_UNSET) {
        ngx_conf_merge_value(conf->upstream.store,
                              prev->upstream.store, 0);

        conf->upstream.store_lengths = prev->upstream.store_lengths;
        conf->upstream.store_values = prev->upstream.store_values;
    }

    ngx_conf_merge_uint_value(conf->upstream.store_access,
              ...",1,1,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_merge_loc_conf,,false,2909,3403,ngx_http_proxy_merge_loc_conf,,,101,"char* ngx_http_proxy_merge_loc_conf (ngx_conf_t*,void*,void*)"
197841,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_proxy_init_headers(ngx_conf_t *cf, ngx_http_proxy_loc_conf_t *conf,
    ngx_http_proxy_headers_t *headers, ngx_keyval_t *default_headers)
{
    u_char                       *p;
    size_t                        size;
    uintptr_t                    *code;
    ngx_uint_t                    i;
    ngx_array_t                   headers_names, headers_merged;
    ngx_keyval_t                 *src, *s, *h;
    ngx_hash_key_t               *hk;
    ngx_hash_init_t               hash;
    ngx_http_script_compile_t     sc;
    ngx_http_script_copy_code_t  *copy;

    if (headers->hash.buckets) {
        return NGX_OK;
    }

    if (ngx_array_init(&headers_names, cf->temp_pool, 4, sizeof(ngx_hash_key_t))
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    if (ngx_array_init(&headers_merged, cf->temp_pool, 4, sizeof(ngx_keyval_t))
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    headers->lengths = ngx_array_create(cf->pool, 64, 1);
    if (he...",1,1,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_init_headers,,false,3406,3570,ngx_http_proxy_init_headers,,,102,"ngx_int_t ngx_http_proxy_init_headers (ngx_conf_t*,ngx_http_proxy_loc_conf_t*,ngx_http_proxy_headers_t*,ngx_keyval_t*)"
198409,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static char *
ngx_http_proxy_pass(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_proxy_loc_conf_t *plcf = conf;

    size_t                      add;
    u_short                     port;
    ngx_str_t                  *value, *url;
    ngx_url_t                   u;
    ngx_uint_t                  n;
    ngx_http_core_loc_conf_t   *clcf;
    ngx_http_script_compile_t   sc;

    if (plcf->upstream.upstream || plcf->proxy_lengths) {
        return ""is duplicate"";
    }

    clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);

    clcf->handler = ngx_http_proxy_handler;

    if (clcf->name.len && clcf->name.data[clcf->name.len - 1] == '/') {
        clcf->auto_redirect = 1;
    }

    value = cf->args->elts;

    url = &value[1];

    n = ngx_http_script_variables_count(url);

    if (n) {

        ngx_memzero(&sc, sizeof(ngx_http_script_compile_t));

        sc.cf = cf;
        sc.source = url;
        sc.lengths = &plcf->proxy_lengths;
        sc.valu...",1,1,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_pass,,false,3573,3692,ngx_http_proxy_pass,,,103,"char* ngx_http_proxy_pass (ngx_conf_t*,ngx_command_t*,void*)"
198753,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static char *
ngx_http_proxy_redirect(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_proxy_loc_conf_t *plcf = conf;

    u_char                            *p;
    ngx_str_t                         *value;
    ngx_http_proxy_rewrite_t          *pr;
    ngx_http_compile_complex_value_t   ccv;

    if (plcf->redirect == 0) {
        return NGX_CONF_OK;
    }

    plcf->redirect = 1;

    value = cf->args->elts;

    if (cf->args->nelts == 2) {
        if (ngx_strcmp(value[1].data, ""off"") == 0) {
            plcf->redirect = 0;
            plcf->redirects = NULL;
            return NGX_CONF_OK;
        }

        if (ngx_strcmp(value[1].data, ""false"") == 0) {
            ngx_conf_log_error(NGX_LOG_ERR, cf, 0,
                           ""invalid parameter \""false\"", use \""off\"" instead"");
            plcf->redirect = 0;
            plcf->redirects = NULL;
            return NGX_CONF_OK;
        }

        if (ngx_strcmp(value[1].data, ""default"") != 0) {
            ngx_co...",1,1,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_redirect,,false,3695,3838,ngx_http_proxy_redirect,,,104,"char* ngx_http_proxy_redirect (ngx_conf_t*,ngx_command_t*,void*)"
199240,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static char *
ngx_http_proxy_cookie_domain(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_proxy_loc_conf_t *plcf = conf;

    ngx_str_t                         *value;
    ngx_http_proxy_rewrite_t          *pr;
    ngx_http_compile_complex_value_t   ccv;

    if (plcf->cookie_domains == NULL) {
        return NGX_CONF_OK;
    }

    value = cf->args->elts;

    if (cf->args->nelts == 2) {

        if (ngx_strcmp(value[1].data, ""off"") == 0) {
            plcf->cookie_domains = NULL;
            return NGX_CONF_OK;
        }

        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""invalid parameter \""%V\"""", &value[1]);
        return NGX_CONF_ERROR;
    }

    if (plcf->cookie_domains == NGX_CONF_UNSET_PTR) {
        plcf->cookie_domains = ngx_array_create(cf->pool, 1,
                                     sizeof(ngx_http_proxy_rewrite_t));
        if (plcf->cookie_domains == NULL) {
            return NGX_CONF_ERROR;
        }
    }

    pr = ngx_a...",1,1,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_cookie_domain,,false,3841,3925,ngx_http_proxy_cookie_domain,,,105,"char* ngx_http_proxy_cookie_domain (ngx_conf_t*,ngx_command_t*,void*)"
199512,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static char *
ngx_http_proxy_cookie_path(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_proxy_loc_conf_t *plcf = conf;

    ngx_str_t                         *value;
    ngx_http_proxy_rewrite_t          *pr;
    ngx_http_compile_complex_value_t   ccv;

    if (plcf->cookie_paths == NULL) {
        return NGX_CONF_OK;
    }

    value = cf->args->elts;

    if (cf->args->nelts == 2) {

        if (ngx_strcmp(value[1].data, ""off"") == 0) {
            plcf->cookie_paths = NULL;
            return NGX_CONF_OK;
        }

        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""invalid parameter \""%V\"""", &value[1]);
        return NGX_CONF_ERROR;
    }

    if (plcf->cookie_paths == NGX_CONF_UNSET_PTR) {
        plcf->cookie_paths = ngx_array_create(cf->pool, 1,
                                     sizeof(ngx_http_proxy_rewrite_t));
        if (plcf->cookie_paths == NULL) {
            return NGX_CONF_ERROR;
        }
    }

    pr = ngx_array_push(pl...",1,1,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_cookie_path,,false,3928,4012,ngx_http_proxy_cookie_path,,,106,"char* ngx_http_proxy_cookie_path (ngx_conf_t*,ngx_command_t*,void*)"
199777,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_proxy_rewrite_regex(ngx_conf_t *cf, ngx_http_proxy_rewrite_t *pr,
    ngx_str_t *regex, ngx_uint_t caseless)
{
#if (NGX_PCRE)
    u_char               errstr[NGX_MAX_CONF_ERRSTR];
    ngx_regex_compile_t  rc;

    ngx_memzero(&rc, sizeof(ngx_regex_compile_t));

    rc.pattern = *regex;
    rc.err.len = NGX_MAX_CONF_ERRSTR;
    rc.err.data = errstr;

    if (caseless) {
        rc.options = NGX_REGEX_CASELESS;
    }

    pr->pattern.regex = ngx_http_regex_compile(cf, &rc);
    if (pr->pattern.regex == NULL) {
        return NGX_ERROR;
    }

    pr->handler = ngx_http_proxy_rewrite_regex_handler;

    return NGX_OK;

#else

    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                       ""using regex \""%V\"" requires PCRE library"", regex);
    return NGX_ERROR;

#endif
}",1,1,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_rewrite_regex,,false,4015,4049,ngx_http_proxy_rewrite_regex,,,107,"ngx_int_t ngx_http_proxy_rewrite_regex (ngx_conf_t*,ngx_http_proxy_rewrite_t*,ngx_str_t*,ngx_uint_t)"
199793,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static char *
ngx_http_proxy_store(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_proxy_loc_conf_t *plcf = conf;

    ngx_str_t                  *value;
    ngx_http_script_compile_t   sc;

    if (plcf->upstream.store != NGX_CONF_UNSET) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    if (ngx_strcmp(value[1].data, ""off"") == 0) {
        plcf->upstream.store = 0;
        return NGX_CONF_OK;
    }

#if (NGX_HTTP_CACHE)
    if (plcf->upstream.cache > 0) {
        return ""is incompatible with \""proxy_cache\"""";
    }
#endif

    plcf->upstream.store = 1;

    if (ngx_strcmp(value[1].data, ""on"") == 0) {
        return NGX_CONF_OK;
    }

    /* include the terminating '\0' into script */
    value[1].len++;

    ngx_memzero(&sc, sizeof(ngx_http_script_compile_t));

    sc.cf = cf;
    sc.source = &value[1];
    sc.lengths = &plcf->upstream.store_lengths;
    sc.values = &plcf->upstream.store_values;
    sc.variables = ngx_http_script_variables_coun...",1,1,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_store,,false,4052,4101,ngx_http_proxy_store,,,108,"char* ngx_http_proxy_store (ngx_conf_t*,ngx_command_t*,void*)"
199938,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static char *
ngx_http_proxy_lowat_check(ngx_conf_t *cf, void *post, void *data)
{
#if (NGX_FREEBSD)
    ssize_t *np = data;

    if ((u_long) *np >= ngx_freebsd_net_inet_tcp_sendspace) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""\""proxy_send_lowat\"" must be less than %d ""
                           ""(sysctl net.inet.tcp.sendspace)"",
                           ngx_freebsd_net_inet_tcp_sendspace);

        return NGX_CONF_ERROR;
    }

#elif !(NGX_HAVE_SO_SNDLOWAT)
    ssize_t *np = data;

    ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
                       ""\""proxy_send_lowat\"" is not supported, ignored"");

    *np = 0;

#endif

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_lowat_check,,false,4222,4248,ngx_http_proxy_lowat_check,,,109,"char* ngx_http_proxy_lowat_check (ngx_conf_t*,void*,void*)"
199960,METHOD,http\modules\ngx_http_proxy_module.c:<global>,TYPE_DECL,"static void
ngx_http_proxy_set_vars(ngx_url_t *u, ngx_http_proxy_vars_t *v)
{
    if (u->family != AF_UNIX) {

        if (u->no_port || u->port == u->default_port) {

            v->host_header = u->host;

            if (u->default_port == 80) {
                ngx_str_set(&v->port, ""80"");

            } else {
                ngx_str_set(&v->port, ""443"");
            }

        } else {
            v->host_header.len = u->host.len + 1 + u->port_text.len;
            v->host_header.data = u->host.data;
            v->port = u->port_text;
        }

        v->key_start.len += v->host_header.len;

    } else {
        ngx_str_set(&v->host_header, ""localhost"");
        ngx_str_null(&v->port);
        v->key_start.len += sizeof(""unix:"") - 1 + u->host.len + 1;
    }

    v->uri = u->uri;
}",1,1,http\modules\ngx_http_proxy_module.c,ngx_http_proxy_set_vars,,false,4336,4367,ngx_http_proxy_set_vars,,,110,"void ngx_http_proxy_set_vars (ngx_url_t*,ngx_http_proxy_vars_t*)"
200111,METHOD,http\modules\ngx_http_random_index_module.c:<global>,TYPE_DECL,<global>,1,10,http\modules\ngx_http_random_index_module.c,http\modules\ngx_http_random_index_module.c:<global>,,false,1,317,<global>,,,1,
200116,METHOD,http\modules\ngx_http_random_index_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_random_index_error(ngx_http_request_t *r,
    ngx_dir_t *dir, ngx_str_t *name);",18,36,http\modules\ngx_http_random_index_module.c,ngx_http_random_index_error,,false,21,22,ngx_http_random_index_error,,,3,"ngx_int_t ngx_http_random_index_error (ngx_http_request_t*,ngx_dir_t*,ngx_str_t*)"
200123,METHOD,http\modules\ngx_http_random_index_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_random_index_init(ngx_conf_t *cf);,18,59,http\modules\ngx_http_random_index_module.c,ngx_http_random_index_init,,false,23,23,ngx_http_random_index_init,,,4,ngx_int_t ngx_http_random_index_init (ngx_conf_t*)
200128,METHOD,http\modules\ngx_http_random_index_module.c:<global>,TYPE_DECL,static void *ngx_http_random_index_create_loc_conf(ngx_conf_t *cf);,13,66,http\modules\ngx_http_random_index_module.c,ngx_http_random_index_create_loc_conf,,false,24,24,ngx_http_random_index_create_loc_conf,,,5,void* ngx_http_random_index_create_loc_conf (ngx_conf_t*)
200133,METHOD,http\modules\ngx_http_random_index_module.c:<global>,TYPE_DECL,"static char *ngx_http_random_index_merge_loc_conf(ngx_conf_t *cf,
    void *parent, void *child);",13,30,http\modules\ngx_http_random_index_module.c,ngx_http_random_index_merge_loc_conf,,false,25,26,ngx_http_random_index_merge_loc_conf,,,6,"char* ngx_http_random_index_merge_loc_conf (ngx_conf_t*,void*,void*)"
200186,METHOD,http\modules\ngx_http_random_index_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_random_index_handler(ngx_http_request_t *r)
{
    u_char                            *last, *filename;
    size_t                             len, allocated, root;
    ngx_err_t                          err;
    ngx_int_t                          rc;
    ngx_str_t                          path, uri, *name;
    ngx_dir_t                          dir;
    ngx_uint_t                         n, level;
    ngx_array_t                        names;
    ngx_http_random_index_loc_conf_t  *rlcf;

    if (r->uri.data[r->uri.len - 1] != '/') {
        return NGX_DECLINED;
    }

    if (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD|NGX_HTTP_POST))) {
        return NGX_DECLINED;
    }

    rlcf = ngx_http_get_module_loc_conf(r, ngx_http_random_index_module);

    if (!rlcf->enable) {
        return NGX_DECLINED;
    }

#if (NGX_HAVE_D_TYPE)
    len = 0;
#else
    len = NGX_HTTP_RANDOM_INDEX_PREALLOCATE;
#endif

    last = ngx_http_map_uri_to_path(r, &path, &root, len);
   ...",1,10,http\modules\ngx_http_random_index_module.c,ngx_http_random_index_handler,,false,73,257,ngx_http_random_index_handler,,,13,ngx_int_t ngx_http_random_index_handler (ngx_http_request_t*)
200743,METHOD,http\modules\ngx_http_random_index_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_random_index_error(ngx_http_request_t *r, ngx_dir_t *dir,
    ngx_str_t *name)
{
    if (ngx_close_dir(dir) == NGX_ERROR) {
        ngx_log_error(NGX_LOG_ALERT, r->connection->log, ngx_errno,
                      ngx_close_dir_n "" \""%V\"" failed"", name);
    }

    return NGX_HTTP_INTERNAL_SERVER_ERROR;
}",1,1,http\modules\ngx_http_random_index_module.c,ngx_http_random_index_error,,false,260,270,ngx_http_random_index_error,,,14,"ngx_int_t ngx_http_random_index_error (ngx_http_request_t*,ngx_dir_t*,ngx_str_t*)"
200759,METHOD,http\modules\ngx_http_random_index_module.c:<global>,TYPE_DECL,"static void *
ngx_http_random_index_create_loc_conf(ngx_conf_t *cf)
{
    ngx_http_random_index_loc_conf_t  *conf;

    conf = ngx_palloc(cf->pool, sizeof(ngx_http_random_index_loc_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    conf->enable = NGX_CONF_UNSET;

    return conf;
}",1,1,http\modules\ngx_http_random_index_module.c,ngx_http_random_index_create_loc_conf,,false,273,286,ngx_http_random_index_create_loc_conf,,,15,void* ngx_http_random_index_create_loc_conf (ngx_conf_t*)
200787,METHOD,http\modules\ngx_http_random_index_module.c:<global>,TYPE_DECL,"static char *
ngx_http_random_index_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_random_index_loc_conf_t *prev = parent;
    ngx_http_random_index_loc_conf_t *conf = child;

    ngx_conf_merge_value(conf->enable, prev->enable, 0);

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_random_index_module.c,ngx_http_random_index_merge_loc_conf,,false,289,298,ngx_http_random_index_merge_loc_conf,,,16,"char* ngx_http_random_index_merge_loc_conf (ngx_conf_t*,void*,void*)"
200812,METHOD,http\modules\ngx_http_random_index_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_random_index_init(ngx_conf_t *cf)
{
    ngx_http_handler_pt        *h;
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);

    h = ngx_array_push(&cmcf->phases[NGX_HTTP_CONTENT_PHASE].handlers);
    if (h == NULL) {
        return NGX_ERROR;
    }

    *h = ngx_http_random_index_handler;

    return NGX_OK;
}",1,1,http\modules\ngx_http_random_index_module.c,ngx_http_random_index_init,,false,301,317,ngx_http_random_index_init,,,17,ngx_int_t ngx_http_random_index_init (ngx_conf_t*)
200857,METHOD,http\modules\ngx_http_range_filter_module.c:<global>,TYPE_DECL,<global>,1,1,http\modules\ngx_http_range_filter_module.c,http\modules\ngx_http_range_filter_module.c:<global>,,false,1,968,<global>,,,1,
200869,METHOD,http\modules\ngx_http_range_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_range_parse(ngx_http_request_t *r,
    ngx_http_range_filter_ctx_t *ctx, ngx_uint_t ranges);",18,56,http\modules\ngx_http_range_filter_module.c,ngx_http_range_parse,,false,62,63,ngx_http_range_parse,,,5,"ngx_int_t ngx_http_range_parse (ngx_http_request_t*,ngx_http_range_filter_ctx_t*,ngx_uint_t)"
200876,METHOD,http\modules\ngx_http_range_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_range_singlepart_header(ngx_http_request_t *r,
    ngx_http_range_filter_ctx_t *ctx);",18,37,http\modules\ngx_http_range_filter_module.c,ngx_http_range_singlepart_header,,false,64,65,ngx_http_range_singlepart_header,,,6,"ngx_int_t ngx_http_range_singlepart_header (ngx_http_request_t*,ngx_http_range_filter_ctx_t*)"
200882,METHOD,http\modules\ngx_http_range_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_range_multipart_header(ngx_http_request_t *r,
    ngx_http_range_filter_ctx_t *ctx);",18,37,http\modules\ngx_http_range_filter_module.c,ngx_http_range_multipart_header,,false,66,67,ngx_http_range_multipart_header,,,7,"ngx_int_t ngx_http_range_multipart_header (ngx_http_request_t*,ngx_http_range_filter_ctx_t*)"
200888,METHOD,http\modules\ngx_http_range_filter_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_range_not_satisfiable(ngx_http_request_t *r);,18,70,http\modules\ngx_http_range_filter_module.c,ngx_http_range_not_satisfiable,,false,68,68,ngx_http_range_not_satisfiable,,,8,ngx_int_t ngx_http_range_not_satisfiable (ngx_http_request_t*)
200893,METHOD,http\modules\ngx_http_range_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_range_test_overlapped(ngx_http_request_t *r,
    ngx_http_range_filter_ctx_t *ctx, ngx_chain_t *in);",18,54,http\modules\ngx_http_range_filter_module.c,ngx_http_range_test_overlapped,,false,69,70,ngx_http_range_test_overlapped,,,9,"ngx_int_t ngx_http_range_test_overlapped (ngx_http_request_t*,ngx_http_range_filter_ctx_t*,ngx_chain_t*)"
200900,METHOD,http\modules\ngx_http_range_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_range_singlepart_body(ngx_http_request_t *r,
    ngx_http_range_filter_ctx_t *ctx, ngx_chain_t *in);",18,54,http\modules\ngx_http_range_filter_module.c,ngx_http_range_singlepart_body,,false,71,72,ngx_http_range_singlepart_body,,,10,"ngx_int_t ngx_http_range_singlepart_body (ngx_http_request_t*,ngx_http_range_filter_ctx_t*,ngx_chain_t*)"
200907,METHOD,http\modules\ngx_http_range_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_range_multipart_body(ngx_http_request_t *r,
    ngx_http_range_filter_ctx_t *ctx, ngx_chain_t *in);",18,54,http\modules\ngx_http_range_filter_module.c,ngx_http_range_multipart_body,,false,73,74,ngx_http_range_multipart_body,,,11,"ngx_int_t ngx_http_range_multipart_body (ngx_http_request_t*,ngx_http_range_filter_ctx_t*,ngx_chain_t*)"
200914,METHOD,http\modules\ngx_http_range_filter_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_range_header_filter_init(ngx_conf_t *cf);,18,66,http\modules\ngx_http_range_filter_module.c,ngx_http_range_header_filter_init,,false,76,76,ngx_http_range_header_filter_init,,,12,ngx_int_t ngx_http_range_header_filter_init (ngx_conf_t*)
200919,METHOD,http\modules\ngx_http_range_filter_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_range_body_filter_init(ngx_conf_t *cf);,18,64,http\modules\ngx_http_range_filter_module.c,ngx_http_range_body_filter_init,,false,77,77,ngx_http_range_body_filter_init,,,13,ngx_int_t ngx_http_range_body_filter_init (ngx_conf_t*)
200984,METHOD,http\modules\ngx_http_range_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_range_header_filter(ngx_http_request_t *r)
{
    time_t                        if_range_time;
    ngx_str_t                    *if_range, *etag;
    ngx_uint_t                    ranges;
    ngx_http_core_loc_conf_t     *clcf;
    ngx_http_range_filter_ctx_t  *ctx;

    if (r->http_version < NGX_HTTP_VERSION_10
        || r->headers_out.status != NGX_HTTP_OK
        || (r != r->main && !r->subrequest_ranges)
        || r->headers_out.content_length_n == -1
        || !r->allow_ranges)
    {
        return ngx_http_next_header_filter(r);
    }

    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    if (clcf->max_ranges == 0) {
        return ngx_http_next_header_filter(r);
    }

    if (r->headers_in.range == NULL
        || r->headers_in.range->value.len < 7
        || ngx_strncasecmp(r->headers_in.range->value.data,
                           (u_char *) ""bytes="", 6)
           != 0)
    {
        goto next_filter;
    }

    if (r->headers...",1,1,http\modules\ngx_http_range_filter_module.c,ngx_http_range_header_filter,,false,146,265,ngx_http_range_header_filter,,,24,ngx_int_t ngx_http_range_header_filter (ngx_http_request_t*)
201377,METHOD,http\modules\ngx_http_range_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_range_parse(ngx_http_request_t *r, ngx_http_range_filter_ctx_t *ctx,
    ngx_uint_t ranges)
{
    u_char                       *p;
    off_t                         start, end, size, content_length, cutoff,
                                  cutlim;
    ngx_uint_t                    suffix;
    ngx_http_range_t             *range;
    ngx_http_range_filter_ctx_t  *mctx;

    if (r != r->main) {
        mctx = ngx_http_get_module_ctx(r->main,
                                       ngx_http_range_body_filter_module);
        if (mctx) {
            ctx->ranges = mctx->ranges;
            return NGX_OK;
        }
    }

    if (ngx_array_init(&ctx->ranges, r->pool, 1, sizeof(ngx_http_range_t))
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    p = r->headers_in.range->value.data + 6;
    size = 0;
    content_length = r->headers_out.content_length_n;

    cutoff = NGX_MAX_OFF_T_VALUE / 10;
    cutlim = NGX_MAX_OFF_T_VALUE % 10;

    for ( ;; ) {
    ...",1,1,http\modules\ngx_http_range_filter_module.c,ngx_http_range_parse,,false,268,408,ngx_http_range_parse,,,25,"ngx_int_t ngx_http_range_parse (ngx_http_request_t*,ngx_http_range_filter_ctx_t*,ngx_uint_t)"
201791,METHOD,http\modules\ngx_http_range_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_range_singlepart_header(ngx_http_request_t *r,
    ngx_http_range_filter_ctx_t *ctx)
{
    ngx_table_elt_t   *content_range;
    ngx_http_range_t  *range;

    if (r != r->main) {
        return ngx_http_next_header_filter(r);
    }

    content_range = ngx_list_push(&r->headers_out.headers);
    if (content_range == NULL) {
        return NGX_ERROR;
    }

    r->headers_out.content_range = content_range;

    content_range->hash = 1;
    ngx_str_set(&content_range->key, ""Content-Range"");

    content_range->value.data = ngx_pnalloc(r->pool,
                                    sizeof(""bytes -/"") - 1 + 3 * NGX_OFF_T_LEN);
    if (content_range->value.data == NULL) {
        content_range->hash = 0;
        r->headers_out.content_range = NULL;
        return NGX_ERROR;
    }

    /* ""Content-Range: bytes SSSS-EEEE/TTTT"" header */

    range = ctx->ranges.elts;

    content_range->value.len = ngx_sprintf(content_range->value.data,
                            ...",1,1,http\modules\ngx_http_range_filter_module.c,ngx_http_range_singlepart_header,,false,411,459,ngx_http_range_singlepart_header,,,26,"ngx_int_t ngx_http_range_singlepart_header (ngx_http_request_t*,ngx_http_range_filter_ctx_t*)"
201971,METHOD,http\modules\ngx_http_range_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_range_multipart_header(ngx_http_request_t *r,
    ngx_http_range_filter_ctx_t *ctx)
{
    off_t               len;
    size_t              size;
    ngx_uint_t          i;
    ngx_http_range_t   *range;
    ngx_atomic_uint_t   boundary;

    size = sizeof(CRLF ""--"") - 1 + NGX_ATOMIC_T_LEN
           + sizeof(CRLF ""Content-Type: "") - 1
           + r->headers_out.content_type.len
           + sizeof(CRLF ""Content-Range: bytes "") - 1;

    if (r->headers_out.content_type_len == r->headers_out.content_type.len
        && r->headers_out.charset.len)
    {
        size += sizeof(""; charset="") - 1 + r->headers_out.charset.len;
    }

    ctx->boundary_header.data = ngx_pnalloc(r->pool, size);
    if (ctx->boundary_header.data == NULL) {
        return NGX_ERROR;
    }

    boundary = ngx_next_temp_number(0);

    /*
     * The boundary header of the range:
     * CRLF
     * ""--0123456789"" CRLF
     * ""Content-Type: image/jpeg"" CRLF
     * ""Content-Range: bytes ""...",1,1,http\modules\ngx_http_range_filter_module.c,ngx_http_range_multipart_header,,false,462,584,ngx_http_range_multipart_header,,,27,"ngx_int_t ngx_http_range_multipart_header (ngx_http_request_t*,ngx_http_range_filter_ctx_t*)"
202287,METHOD,http\modules\ngx_http_range_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_range_not_satisfiable(ngx_http_request_t *r)
{
    ngx_table_elt_t  *content_range;

    r->headers_out.status = NGX_HTTP_RANGE_NOT_SATISFIABLE;

    content_range = ngx_list_push(&r->headers_out.headers);
    if (content_range == NULL) {
        return NGX_ERROR;
    }

    r->headers_out.content_range = content_range;

    content_range->hash = 1;
    ngx_str_set(&content_range->key, ""Content-Range"");

    content_range->value.data = ngx_pnalloc(r->pool,
                                       sizeof(""bytes */"") - 1 + NGX_OFF_T_LEN);
    if (content_range->value.data == NULL) {
        content_range->hash = 0;
        r->headers_out.content_range = NULL;
        return NGX_ERROR;
    }

    content_range->value.len = ngx_sprintf(content_range->value.data,
                                           ""bytes */%O"",
                                           r->headers_out.content_length_n)
                               - content_range->value.data;

    ngx_ht...",1,1,http\modules\ngx_http_range_filter_module.c,ngx_http_range_not_satisfiable,,false,587,620,ngx_http_range_not_satisfiable,,,28,ngx_int_t ngx_http_range_not_satisfiable (ngx_http_request_t*)
202401,METHOD,http\modules\ngx_http_range_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_range_body_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    ngx_http_range_filter_ctx_t  *ctx;

    if (in == NULL) {
        return ngx_http_next_body_filter(r, in);
    }

    ctx = ngx_http_get_module_ctx(r, ngx_http_range_body_filter_module);

    if (ctx == NULL) {
        return ngx_http_next_body_filter(r, in);
    }

    if (ctx->ranges.nelts == 1) {
        return ngx_http_range_singlepart_body(r, ctx, in);
    }

    /*
     * multipart ranges are supported only if whole body is in a single buffer
     */

    if (ngx_buf_special(in->buf)) {
        return ngx_http_next_body_filter(r, in);
    }

    if (ngx_http_range_test_overlapped(r, ctx, in) != NGX_OK) {
        return NGX_ERROR;
    }

    return ngx_http_range_multipart_body(r, ctx, in);
}",1,1,http\modules\ngx_http_range_filter_module.c,ngx_http_range_body_filter,,false,623,655,ngx_http_range_body_filter,,,29,"ngx_int_t ngx_http_range_body_filter (ngx_http_request_t*,ngx_chain_t*)"
202470,METHOD,http\modules\ngx_http_range_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_range_test_overlapped(ngx_http_request_t *r,
    ngx_http_range_filter_ctx_t *ctx, ngx_chain_t *in)
{
    off_t              start, last;
    ngx_buf_t         *buf;
    ngx_uint_t         i;
    ngx_http_range_t  *range;

    if (ctx->offset) {
        goto overlapped;
    }

    buf = in->buf;

    if (!buf->last_buf) {
        start = ctx->offset;
        last = ctx->offset + ngx_buf_size(buf);

        range = ctx->ranges.elts;
        for (i = 0; i < ctx->ranges.nelts; i++) {
            if (start > range[i].start || last < range[i].end) {
                goto overlapped;
            }
        }
    }

    ctx->offset = ngx_buf_size(buf);

    return NGX_OK;

overlapped:

    ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,
                  ""range in overlapped buffers"");

    return NGX_ERROR;
}",1,1,http\modules\ngx_http_range_filter_module.c,ngx_http_range_test_overlapped,,false,658,695,ngx_http_range_test_overlapped,,,30,"ngx_int_t ngx_http_range_test_overlapped (ngx_http_request_t*,ngx_http_range_filter_ctx_t*,ngx_chain_t*)"
202572,METHOD,http\modules\ngx_http_range_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_range_singlepart_body(ngx_http_request_t *r,
    ngx_http_range_filter_ctx_t *ctx, ngx_chain_t *in)
{
    off_t              start, last;
    ngx_int_t          rc;
    ngx_buf_t         *buf;
    ngx_chain_t       *out, *cl, *tl, **ll;
    ngx_http_range_t  *range;

    out = NULL;
    ll = &out;
    range = ctx->ranges.elts;

    for (cl = in; cl; cl = cl->next) {

        buf = cl->buf;

        start = ctx->offset;
        last = ctx->offset + ngx_buf_size(buf);

        ctx->offset = last;

        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                       ""http range body buf: %O-%O"", start, last);

        if (ngx_buf_special(buf)) {

            if (range->end <= start) {
                continue;
            }

            tl = ngx_alloc_chain_link(r->pool);
            if (tl == NULL) {
                return NGX_ERROR;
            }

            tl->buf = buf;
            tl->next = NULL;

            *ll = tl;
            l...",1,1,http\modules\ngx_http_range_filter_module.c,ngx_http_range_singlepart_body,,false,698,818,ngx_http_range_singlepart_body,,,31,"ngx_int_t ngx_http_range_singlepart_body (ngx_http_request_t*,ngx_http_range_filter_ctx_t*,ngx_chain_t*)"
202918,METHOD,http\modules\ngx_http_range_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_range_multipart_body(ngx_http_request_t *r,
    ngx_http_range_filter_ctx_t *ctx, ngx_chain_t *in)
{
    ngx_buf_t         *b, *buf;
    ngx_uint_t         i;
    ngx_chain_t       *out, *hcl, *rcl, *dcl, **ll;
    ngx_http_range_t  *range;

    ll = &out;
    buf = in->buf;
    range = ctx->ranges.elts;

    for (i = 0; i < ctx->ranges.nelts; i++) {

        /*
         * The boundary header of the range:
         * CRLF
         * ""--0123456789"" CRLF
         * ""Content-Type: image/jpeg"" CRLF
         * ""Content-Range: bytes ""
         */

        b = ngx_calloc_buf(r->pool);
        if (b == NULL) {
            return NGX_ERROR;
        }

        b->memory = 1;
        b->pos = ctx->boundary_header.data;
        b->last = ctx->boundary_header.data + ctx->boundary_header.len;

        hcl = ngx_alloc_chain_link(r->pool);
        if (hcl == NULL) {
            return NGX_ERROR;
        }

        hcl->buf = b;


        /* ""SSSS-EEEE/TTTT"" CRLF CRLF */

 ...",1,1,http\modules\ngx_http_range_filter_module.c,ngx_http_range_multipart_body,,false,821,948,ngx_http_range_multipart_body,,,32,"ngx_int_t ngx_http_range_multipart_body (ngx_http_request_t*,ngx_http_range_filter_ctx_t*,ngx_chain_t*)"
203335,METHOD,http\modules\ngx_http_range_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_range_header_filter_init(ngx_conf_t *cf)
{
    ngx_http_next_header_filter = ngx_http_top_header_filter;
    ngx_http_top_header_filter = ngx_http_range_header_filter;

    return NGX_OK;
}",1,1,http\modules\ngx_http_range_filter_module.c,ngx_http_range_header_filter_init,,false,951,958,ngx_http_range_header_filter_init,,,33,ngx_int_t ngx_http_range_header_filter_init (ngx_conf_t*)
203348,METHOD,http\modules\ngx_http_range_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_range_body_filter_init(ngx_conf_t *cf)
{
    ngx_http_next_body_filter = ngx_http_top_body_filter;
    ngx_http_top_body_filter = ngx_http_range_body_filter;

    return NGX_OK;
}",1,1,http\modules\ngx_http_range_filter_module.c,ngx_http_range_body_filter_init,,false,961,968,ngx_http_range_body_filter_init,,,34,ngx_int_t ngx_http_range_body_filter_init (ngx_conf_t*)
203370,METHOD,http\modules\ngx_http_realip_module.c:<global>,TYPE_DECL,<global>,1,9,http\modules\ngx_http_realip_module.c,http\modules\ngx_http_realip_module.c:<global>,,false,1,622,<global>,,,1,
203386,METHOD,http\modules\ngx_http_realip_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_realip_handler(ngx_http_request_t *r);,18,63,http\modules\ngx_http_realip_module.c,ngx_http_realip_handler,,false,36,36,ngx_http_realip_handler,,,5,ngx_int_t ngx_http_realip_handler (ngx_http_request_t*)
203391,METHOD,http\modules\ngx_http_realip_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_realip_set_addr(ngx_http_request_t *r,
    ngx_addr_t *addr);",18,21,http\modules\ngx_http_realip_module.c,ngx_http_realip_set_addr,,false,37,38,ngx_http_realip_set_addr,,,6,"ngx_int_t ngx_http_realip_set_addr (ngx_http_request_t*,ngx_addr_t*)"
203397,METHOD,http\modules\ngx_http_realip_module.c:<global>,TYPE_DECL,static void ngx_http_realip_cleanup(void *data);,13,47,http\modules\ngx_http_realip_module.c,ngx_http_realip_cleanup,,false,39,39,ngx_http_realip_cleanup,,,7,void ngx_http_realip_cleanup (void*)
203402,METHOD,http\modules\ngx_http_realip_module.c:<global>,TYPE_DECL,"static char *ngx_http_realip_from(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_realip_module.c,ngx_http_realip_from,,false,40,41,ngx_http_realip_from,,,8,"char* ngx_http_realip_from (ngx_conf_t*,ngx_command_t*,void*)"
203409,METHOD,http\modules\ngx_http_realip_module.c:<global>,TYPE_DECL,"static char *ngx_http_realip(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",13,76,http\modules\ngx_http_realip_module.c,ngx_http_realip,,false,42,42,ngx_http_realip,,,9,"char* ngx_http_realip (ngx_conf_t*,ngx_command_t*,void*)"
203416,METHOD,http\modules\ngx_http_realip_module.c:<global>,TYPE_DECL,static void *ngx_http_realip_create_loc_conf(ngx_conf_t *cf);,13,60,http\modules\ngx_http_realip_module.c,ngx_http_realip_create_loc_conf,,false,43,43,ngx_http_realip_create_loc_conf,,,10,void* ngx_http_realip_create_loc_conf (ngx_conf_t*)
203421,METHOD,http\modules\ngx_http_realip_module.c:<global>,TYPE_DECL,"static char *ngx_http_realip_merge_loc_conf(ngx_conf_t *cf,
    void *parent, void *child);",13,30,http\modules\ngx_http_realip_module.c,ngx_http_realip_merge_loc_conf,,false,44,45,ngx_http_realip_merge_loc_conf,,,11,"char* ngx_http_realip_merge_loc_conf (ngx_conf_t*,void*,void*)"
203428,METHOD,http\modules\ngx_http_realip_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_realip_add_variables(ngx_conf_t *cf);,18,62,http\modules\ngx_http_realip_module.c,ngx_http_realip_add_variables,,false,46,46,ngx_http_realip_add_variables,,,12,ngx_int_t ngx_http_realip_add_variables (ngx_conf_t*)
203433,METHOD,http\modules\ngx_http_realip_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_realip_init(ngx_conf_t *cf);,18,53,http\modules\ngx_http_realip_module.c,ngx_http_realip_init,,false,47,47,ngx_http_realip_init,,,13,ngx_int_t ngx_http_realip_init (ngx_conf_t*)
203438,METHOD,http\modules\ngx_http_realip_module.c:<global>,TYPE_DECL,"static ngx_http_realip_ctx_t *ngx_http_realip_get_module_ctx(
    ngx_http_request_t *r);",30,26,http\modules\ngx_http_realip_module.c,ngx_http_realip_get_module_ctx,,false,48,49,ngx_http_realip_get_module_ctx,,,14,ngx_http_realip_ctx_t* ngx_http_realip_get_module_ctx (ngx_http_request_t*)
203443,METHOD,http\modules\ngx_http_realip_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_realip_remote_addr_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\modules\ngx_http_realip_module.c,ngx_http_realip_remote_addr_variable,,false,52,53,ngx_http_realip_remote_addr_variable,,,15,"ngx_int_t ngx_http_realip_remote_addr_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
203450,METHOD,http\modules\ngx_http_realip_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_realip_remote_port_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\modules\ngx_http_realip_module.c,ngx_http_realip_remote_port_variable,,false,54,55,ngx_http_realip_remote_port_variable,,,16,"ngx_int_t ngx_http_realip_remote_port_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
203556,METHOD,http\modules\ngx_http_realip_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_realip_handler(ngx_http_request_t *r)
{
    u_char                      *p;
    size_t                       len;
    ngx_str_t                   *value;
    ngx_uint_t                   i, hash;
    ngx_addr_t                   addr;
    ngx_array_t                 *xfwd;
    ngx_list_part_t             *part;
    ngx_table_elt_t             *header;
    ngx_connection_t            *c;
    ngx_http_realip_ctx_t       *ctx;
    ngx_http_realip_loc_conf_t  *rlcf;

    rlcf = ngx_http_get_module_loc_conf(r, ngx_http_realip_module);

    if (rlcf->from == NULL) {
        return NGX_DECLINED;
    }

    ctx = ngx_http_realip_get_module_ctx(r);

    if (ctx) {
        return NGX_DECLINED;
    }

    switch (rlcf->type) {

    case NGX_HTTP_REALIP_XREALIP:

        if (r->headers_in.x_real_ip == NULL) {
            return NGX_DECLINED;
        }

        value = &r->headers_in.x_real_ip->value;
        xfwd = NULL;

        break;

    case NGX_HTTP_REALIP_XFWD:
...",1,9,http\modules\ngx_http_realip_module.c,ngx_http_realip_handler,,false,129,247,ngx_http_realip_handler,,,25,ngx_int_t ngx_http_realip_handler (ngx_http_request_t*)
203860,METHOD,http\modules\ngx_http_realip_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_realip_set_addr(ngx_http_request_t *r, ngx_addr_t *addr)
{
    size_t                  len;
    u_char                 *p;
    u_char                  text[NGX_SOCKADDR_STRLEN];
    ngx_connection_t       *c;
    ngx_pool_cleanup_t     *cln;
    ngx_http_realip_ctx_t  *ctx;

    cln = ngx_pool_cleanup_add(r->pool, sizeof(ngx_http_realip_ctx_t));
    if (cln == NULL) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    ctx = cln->data;

    c = r->connection;

    len = ngx_sock_ntop(addr->sockaddr, addr->socklen, text,
                        NGX_SOCKADDR_STRLEN, 0);
    if (len == 0) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    p = ngx_pnalloc(c->pool, len);
    if (p == NULL) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    ngx_memcpy(p, text, len);

    cln->handler = ngx_http_realip_cleanup;
    ngx_http_set_ctx(r, ctx, ngx_http_realip_module);

    ctx->connection = c;
    ctx->sockaddr = c->sockaddr;
    ctx->socklen =...",1,1,http\modules\ngx_http_realip_module.c,ngx_http_realip_set_addr,,false,250,296,ngx_http_realip_set_addr,,,26,"ngx_int_t ngx_http_realip_set_addr (ngx_http_request_t*,ngx_addr_t*)"
203999,METHOD,http\modules\ngx_http_realip_module.c:<global>,TYPE_DECL,"static void
ngx_http_realip_cleanup(void *data)
{
    ngx_http_realip_ctx_t *ctx = data;

    ngx_connection_t  *c;

    c = ctx->connection;

    c->sockaddr = ctx->sockaddr;
    c->socklen = ctx->socklen;
    c->addr_text = ctx->addr_text;
}",1,1,http\modules\ngx_http_realip_module.c,ngx_http_realip_cleanup,,false,299,311,ngx_http_realip_cleanup,,,27,void ngx_http_realip_cleanup (void*)
204035,METHOD,http\modules\ngx_http_realip_module.c:<global>,TYPE_DECL,"static char *
ngx_http_realip_from(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_realip_loc_conf_t *rlcf = conf;

    ngx_int_t             rc;
    ngx_str_t            *value;
    ngx_url_t             u;
    ngx_cidr_t            c, *cidr;
    ngx_uint_t            i;
    struct sockaddr_in   *sin;
#if (NGX_HAVE_INET6)
    struct sockaddr_in6  *sin6;
#endif

    value = cf->args->elts;

    if (rlcf->from == NULL) {
        rlcf->from = ngx_array_create(cf->pool, 2,
                                      sizeof(ngx_cidr_t));
        if (rlcf->from == NULL) {
            return NGX_CONF_ERROR;
        }
    }

#if (NGX_HAVE_UNIX_DOMAIN)

    if (ngx_strcmp(value[1].data, ""unix:"") == 0) {
        cidr = ngx_array_push(rlcf->from);
        if (cidr == NULL) {
            return NGX_CONF_ERROR;
        }

        cidr->family = AF_UNIX;
        return NGX_CONF_OK;
    }

#endif

    rc = ngx_ptocidr(&value[1], &c);

    if (rc != NGX_ERROR) {
        if (rc == NGX_DONE...",1,1,http\modules\ngx_http_realip_module.c,ngx_http_realip_from,,false,314,414,ngx_http_realip_from,,,28,"char* ngx_http_realip_from (ngx_conf_t*,ngx_command_t*,void*)"
204275,METHOD,http\modules\ngx_http_realip_module.c:<global>,TYPE_DECL,"static char *
ngx_http_realip(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_realip_loc_conf_t *rlcf = conf;

    ngx_str_t  *value;

    if (rlcf->type != NGX_CONF_UNSET_UINT) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    if (ngx_strcmp(value[1].data, ""X-Real-IP"") == 0) {
        rlcf->type = NGX_HTTP_REALIP_XREALIP;
        return NGX_CONF_OK;
    }

    if (ngx_strcmp(value[1].data, ""X-Forwarded-For"") == 0) {
        rlcf->type = NGX_HTTP_REALIP_XFWD;
        return NGX_CONF_OK;
    }

    if (ngx_strcmp(value[1].data, ""proxy_protocol"") == 0) {
        rlcf->type = NGX_HTTP_REALIP_PROXY;
        return NGX_CONF_OK;
    }

    rlcf->type = NGX_HTTP_REALIP_HEADER;
    rlcf->hash = ngx_hash_strlow(value[1].data, value[1].data, value[1].len);
    rlcf->header = value[1];

    return NGX_CONF_OK;
}",1,21,http\modules\ngx_http_realip_module.c,ngx_http_realip,,false,417,450,ngx_http_realip,,,29,"char* ngx_http_realip (ngx_conf_t*,ngx_command_t*,void*)"
204399,METHOD,http\modules\ngx_http_realip_module.c:<global>,TYPE_DECL,"static void *
ngx_http_realip_create_loc_conf(ngx_conf_t *cf)
{
    ngx_http_realip_loc_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_realip_loc_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     conf->from = NULL;
     *     conf->hash = 0;
     *     conf->header = { 0, NULL };
     */

    conf->type = NGX_CONF_UNSET_UINT;
    conf->recursive = NGX_CONF_UNSET;

    return conf;
}",1,1,http\modules\ngx_http_realip_module.c,ngx_http_realip_create_loc_conf,,false,453,475,ngx_http_realip_create_loc_conf,,,30,void* ngx_http_realip_create_loc_conf (ngx_conf_t*)
204432,METHOD,http\modules\ngx_http_realip_module.c:<global>,TYPE_DECL,"static char *
ngx_http_realip_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_realip_loc_conf_t  *prev = parent;
    ngx_http_realip_loc_conf_t  *conf = child;

    if (conf->from == NULL) {
        conf->from = prev->from;
    }

    ngx_conf_merge_uint_value(conf->type, prev->type, NGX_HTTP_REALIP_XREALIP);
    ngx_conf_merge_value(conf->recursive, prev->recursive, 0);

    if (conf->header.len == 0) {
        conf->hash = prev->hash;
        conf->header = prev->header;
    }

    return NGX_CONF_OK;
}",1,54,http\modules\ngx_http_realip_module.c,ngx_http_realip_merge_loc_conf,,false,478,497,ngx_http_realip_merge_loc_conf,,,31,"char* ngx_http_realip_merge_loc_conf (ngx_conf_t*,void*,void*)"
204504,METHOD,http\modules\ngx_http_realip_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_realip_add_variables(ngx_conf_t *cf)
{
    ngx_http_variable_t  *var, *v;

    for (v = ngx_http_realip_vars; v->name.len; v++) {
        var = ngx_http_add_variable(cf, &v->name, v->flags);
        if (var == NULL) {
            return NGX_ERROR;
        }

        var->get_handler = v->get_handler;
        var->data = v->data;
    }

    return NGX_OK;
}",1,1,http\modules\ngx_http_realip_module.c,ngx_http_realip_add_variables,,false,500,516,ngx_http_realip_add_variables,,,32,ngx_int_t ngx_http_realip_add_variables (ngx_conf_t*)
204558,METHOD,http\modules\ngx_http_realip_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_realip_init(ngx_conf_t *cf)
{
    ngx_http_handler_pt        *h;
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);

    h = ngx_array_push(&cmcf->phases[NGX_HTTP_POST_READ_PHASE].handlers);
    if (h == NULL) {
        return NGX_ERROR;
    }

    *h = ngx_http_realip_handler;

    h = ngx_array_push(&cmcf->phases[NGX_HTTP_PREACCESS_PHASE].handlers);
    if (h == NULL) {
        return NGX_ERROR;
    }

    *h = ngx_http_realip_handler;

    return NGX_OK;
}",1,1,http\modules\ngx_http_realip_module.c,ngx_http_realip_init,,false,519,542,ngx_http_realip_init,,,33,ngx_int_t ngx_http_realip_init (ngx_conf_t*)
204616,METHOD,http\modules\ngx_http_realip_module.c:<global>,TYPE_DECL,"static ngx_http_realip_ctx_t *
ngx_http_realip_get_module_ctx(ngx_http_request_t *r)
{
    ngx_pool_cleanup_t     *cln;
    ngx_http_realip_ctx_t  *ctx;

    ctx = ngx_http_get_module_ctx(r, ngx_http_realip_module);

    if (ctx == NULL && (r->internal || r->filter_finalize)) {

        /*
         * if module context was reset, the original address
         * can still be found in the cleanup handler
         */

        for (cln = r->pool->cleanup; cln; cln = cln->next) {
            if (cln->handler == ngx_http_realip_cleanup) {
                ctx = cln->data;
                break;
            }
        }
    }

    return ctx;
}",1,1,http\modules\ngx_http_realip_module.c,ngx_http_realip_get_module_ctx,,false,545,569,ngx_http_realip_get_module_ctx,,,34,ngx_http_realip_ctx_t ngx_http_realip_get_module_ctx (ngx_http_request_t*)
204672,METHOD,http\modules\ngx_http_realip_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_realip_remote_addr_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    ngx_str_t              *addr_text;
    ngx_http_realip_ctx_t  *ctx;

    ctx = ngx_http_realip_get_module_ctx(r);

    addr_text = ctx ? &ctx->addr_text : &r->connection->addr_text;

    v->len = addr_text->len;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = addr_text->data;

    return NGX_OK;
}",1,1,http\modules\ngx_http_realip_module.c,ngx_http_realip_remote_addr_variable,,false,572,590,ngx_http_realip_remote_addr_variable,,,35,"ngx_int_t ngx_http_realip_remote_addr_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
204730,METHOD,http\modules\ngx_http_realip_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_realip_remote_port_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    ngx_uint_t              port;
    struct sockaddr        *sa;
    ngx_http_realip_ctx_t  *ctx;

    ctx = ngx_http_realip_get_module_ctx(r);

    sa = ctx ? ctx->sockaddr : r->connection->sockaddr;

    v->len = 0;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;

    v->data = ngx_pnalloc(r->pool, sizeof(""65535"") - 1);
    if (v->data == NULL) {
        return NGX_ERROR;
    }

    port = ngx_inet_get_port(sa);

    if (port > 0 && port < 65536) {
        v->len = ngx_sprintf(v->data, ""%ui"", port) - v->data;
    }

    return NGX_OK;
}",1,1,http\modules\ngx_http_realip_module.c,ngx_http_realip_remote_port_variable,,false,593,622,ngx_http_realip_remote_port_variable,,,36,"ngx_int_t ngx_http_realip_remote_port_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
204835,METHOD,http\modules\ngx_http_referer_module.c:<global>,TYPE_DECL,<global>,1,15,http\modules\ngx_http_referer_module.c,http\modules\ngx_http_referer_module.c:<global>,,false,1,682,<global>,,,1,
204848,METHOD,http\modules\ngx_http_referer_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_referer_add_variables(ngx_conf_t *cf);,18,63,http\modules\ngx_http_referer_module.c,ngx_http_referer_add_variables,,false,35,35,ngx_http_referer_add_variables,,,3,ngx_int_t ngx_http_referer_add_variables (ngx_conf_t*)
204853,METHOD,http\modules\ngx_http_referer_module.c:<global>,TYPE_DECL,static void * ngx_http_referer_create_conf(ngx_conf_t *cf);,13,58,http\modules\ngx_http_referer_module.c,ngx_http_referer_create_conf,,false,36,36,ngx_http_referer_create_conf,,,4,void* ngx_http_referer_create_conf (ngx_conf_t*)
204858,METHOD,http\modules\ngx_http_referer_module.c:<global>,TYPE_DECL,"static char * ngx_http_referer_merge_conf(ngx_conf_t *cf, void *parent,
    void *child);",13,16,http\modules\ngx_http_referer_module.c,ngx_http_referer_merge_conf,,false,37,38,ngx_http_referer_merge_conf,,,5,"char* ngx_http_referer_merge_conf (ngx_conf_t*,void*,void*)"
204865,METHOD,http\modules\ngx_http_referer_module.c:<global>,TYPE_DECL,"static char *ngx_http_valid_referers(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_referer_module.c,ngx_http_valid_referers,,false,39,40,ngx_http_valid_referers,,,6,"char* ngx_http_valid_referers (ngx_conf_t*,ngx_command_t*,void*)"
204872,METHOD,http\modules\ngx_http_referer_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_add_referer(ngx_conf_t *cf,
    ngx_hash_keys_arrays_t *keys, ngx_str_t *value, ngx_str_t *uri);",18,67,http\modules\ngx_http_referer_module.c,ngx_http_add_referer,,false,41,42,ngx_http_add_referer,,,7,"ngx_int_t ngx_http_add_referer (ngx_conf_t*,ngx_hash_keys_arrays_t*,ngx_str_t*,ngx_str_t*)"
204880,METHOD,http\modules\ngx_http_referer_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_add_regex_referer(ngx_conf_t *cf,
    ngx_http_referer_conf_t *rlcf, ngx_str_t *name);",18,51,http\modules\ngx_http_referer_module.c,ngx_http_add_regex_referer,,false,43,44,ngx_http_add_regex_referer,,,8,"ngx_int_t ngx_http_add_regex_referer (ngx_conf_t*,ngx_http_referer_conf_t*,ngx_str_t*)"
204967,METHOD,http\modules\ngx_http_referer_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_referer_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v,
    uintptr_t data)
{
    u_char                    *p, *ref, *last;
    size_t                     len;
    ngx_str_t                 *uri;
    ngx_uint_t                 i, key;
    ngx_http_referer_conf_t   *rlcf;
    u_char                     buf[256];
#if (NGX_PCRE)
    ngx_int_t                  rc;
    ngx_str_t                  referer;
#endif

    rlcf = ngx_http_get_module_loc_conf(r, ngx_http_referer_module);

    if (rlcf->hash.hash.buckets == NULL
        && rlcf->hash.wc_head == NULL
        && rlcf->hash.wc_tail == NULL
#if (NGX_PCRE)
        && rlcf->regex == NULL
        && rlcf->server_name_regex == NULL
#endif
       )
    {
        goto valid;
    }

    if (r->headers_in.referer == NULL) {
        if (rlcf->no_referer) {
            goto valid;
        }

        goto invalid;
    }

    len = r->headers_in.referer->value.len;
    ref = r->headers_in.referer->value.d...",1,15,http\modules\ngx_http_referer_module.c,ngx_http_referer_variable,,false,114,267,ngx_http_referer_variable,,,18,"ngx_int_t ngx_http_referer_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
205241,METHOD,http\modules\ngx_http_referer_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_referer_add_variables(ngx_conf_t *cf)
{
    ngx_http_variable_t  *var;

    var = ngx_http_add_variable(cf, &ngx_http_invalid_referer_name,
                                NGX_HTTP_VAR_CHANGEABLE);
    if (var == NULL) {
        return NGX_ERROR;
    }

    var->get_handler = ngx_http_referer_variable;

    return NGX_OK;
}",1,1,http\modules\ngx_http_referer_module.c,ngx_http_referer_add_variables,,false,270,284,ngx_http_referer_add_variables,,,19,ngx_int_t ngx_http_referer_add_variables (ngx_conf_t*)
205268,METHOD,http\modules\ngx_http_referer_module.c:<global>,TYPE_DECL,"static void *
ngx_http_referer_create_conf(ngx_conf_t *cf)
{
    ngx_http_referer_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_referer_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     conf->hash = { NULL };
     *     conf->server_names = 0;
     *     conf->keys = NULL;
     */

#if (NGX_PCRE)
    conf->regex = NGX_CONF_UNSET_PTR;
    conf->server_name_regex = NGX_CONF_UNSET_PTR;
#endif

    conf->no_referer = NGX_CONF_UNSET;
    conf->blocked_referer = NGX_CONF_UNSET;
    conf->referer_hash_max_size = NGX_CONF_UNSET_UINT;
    conf->referer_hash_bucket_size = NGX_CONF_UNSET_UINT;

    return conf;
}",1,1,http\modules\ngx_http_referer_module.c,ngx_http_referer_create_conf,,false,287,316,ngx_http_referer_create_conf,,,20,void* ngx_http_referer_create_conf (ngx_conf_t*)
205311,METHOD,http\modules\ngx_http_referer_module.c:<global>,TYPE_DECL,"static char *
ngx_http_referer_merge_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_referer_conf_t *prev = parent;
    ngx_http_referer_conf_t *conf = child;

    ngx_uint_t                 n;
    ngx_hash_init_t            hash;
    ngx_http_server_name_t    *sn;
    ngx_http_core_srv_conf_t  *cscf;

    if (conf->keys == NULL) {
        conf->hash = prev->hash;

#if (NGX_PCRE)
        ngx_conf_merge_ptr_value(conf->regex, prev->regex, NULL);
        ngx_conf_merge_ptr_value(conf->server_name_regex,
                                 prev->server_name_regex, NULL);
#endif
        ngx_conf_merge_value(conf->no_referer, prev->no_referer, 0);
        ngx_conf_merge_value(conf->blocked_referer, prev->blocked_referer, 0);
        ngx_conf_merge_uint_value(conf->referer_hash_max_size,
                                  prev->referer_hash_max_size, 2048);
        ngx_conf_merge_uint_value(conf->referer_hash_bucket_size,
                                  prev->referer_hash_buc...",1,1,http\modules\ngx_http_referer_module.c,ngx_http_referer_merge_conf,,false,319,468,ngx_http_referer_merge_conf,,,21,"char* ngx_http_referer_merge_conf (ngx_conf_t*,void*,void*)"
205766,METHOD,http\modules\ngx_http_referer_module.c:<global>,TYPE_DECL,"static char *
ngx_http_valid_referers(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_referer_conf_t  *rlcf = conf;

    u_char      *p;
    ngx_str_t   *value, uri;
    ngx_uint_t   i;

    if (rlcf->keys == NULL) {
        rlcf->keys = ngx_pcalloc(cf->temp_pool, sizeof(ngx_hash_keys_arrays_t));
        if (rlcf->keys == NULL) {
            return NGX_CONF_ERROR;
        }

        rlcf->keys->pool = cf->pool;
        rlcf->keys->temp_pool = cf->pool;

        if (ngx_hash_keys_array_init(rlcf->keys, NGX_HASH_SMALL) != NGX_OK) {
            return NGX_CONF_ERROR;
        }
    }

    value = cf->args->elts;

    for (i = 1; i < cf->args->nelts; i++) {
        if (value[i].len == 0) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               ""invalid referer \""%V\"""", &value[i]);
            return NGX_CONF_ERROR;
        }

        if (ngx_strcmp(value[i].data, ""none"") == 0) {
            rlcf->no_referer = 1;
            continue;
        }
...",1,1,http\modules\ngx_http_referer_module.c,ngx_http_valid_referers,,false,471,542,ngx_http_valid_referers,,,22,"char* ngx_http_valid_referers (ngx_conf_t*,ngx_command_t*,void*)"
206025,METHOD,http\modules\ngx_http_referer_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_add_referer(ngx_conf_t *cf, ngx_hash_keys_arrays_t *keys,
    ngx_str_t *value, ngx_str_t *uri)
{
    ngx_int_t   rc;
    ngx_str_t  *u;

    if (uri == NULL || uri->len == 0) {
        u = NGX_HTTP_REFERER_NO_URI_PART;

    } else {
        u = ngx_palloc(cf->pool, sizeof(ngx_str_t));
        if (u == NULL) {
            return NGX_ERROR;
        }

        *u = *uri;
    }

    rc = ngx_hash_add_key(keys, value, u, NGX_HASH_WILDCARD_KEY);

    if (rc == NGX_OK) {
        return NGX_OK;
    }

    if (rc == NGX_DECLINED) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""invalid hostname or wildcard \""%V\"""", value);
    }

    if (rc == NGX_BUSY) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""conflicting parameter \""%V\"""", value);
    }

    return NGX_ERROR;
}",1,12,http\modules\ngx_http_referer_module.c,ngx_http_add_referer,,false,545,581,ngx_http_add_referer,,,23,"ngx_int_t ngx_http_add_referer (ngx_conf_t*,ngx_hash_keys_arrays_t*,ngx_str_t*,ngx_str_t*)"
206113,METHOD,http\modules\ngx_http_referer_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_add_regex_referer(ngx_conf_t *cf, ngx_http_referer_conf_t *rlcf,
    ngx_str_t *name)
{
#if (NGX_PCRE)
    ngx_regex_elt_t      *re;
    ngx_regex_compile_t   rc;
    u_char                errstr[NGX_MAX_CONF_ERRSTR];

    if (name->len == 1) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, ""empty regex in \""%V\"""", name);
        return NGX_ERROR;
    }

    if (rlcf->regex == NGX_CONF_UNSET_PTR) {
        rlcf->regex = ngx_array_create(cf->pool, 2, sizeof(ngx_regex_elt_t));
        if (rlcf->regex == NULL) {
            return NGX_ERROR;
        }
    }

    re = ngx_array_push(rlcf->regex);
    if (re == NULL) {
        return NGX_ERROR;
    }

    name->len--;
    name->data++;

    ngx_memzero(&rc, sizeof(ngx_regex_compile_t));

    rc.pattern = *name;
    rc.pool = cf->pool;
    rc.options = NGX_REGEX_CASELESS;
    rc.err.len = NGX_MAX_CONF_ERRSTR;
    rc.err.data = errstr;

    if (ngx_regex_compile(&rc) != NGX_OK) {
        ngx_conf_log_error(NGX_L...",1,1,http\modules\ngx_http_referer_module.c,ngx_http_add_regex_referer,,false,584,640,ngx_http_add_regex_referer,,,24,"ngx_int_t ngx_http_add_regex_referer (ngx_conf_t*,ngx_http_referer_conf_t*,ngx_str_t*)"
206130,METHOD,http\modules\ngx_http_referer_module.c:<global>,TYPE_DECL,"ngx_http_cmp_referer_wildcards(const void *one, const void *two)
{
    ngx_hash_key_t  *first, *second;

    first = (ngx_hash_key_t *) one;
    second = (ngx_hash_key_t *) two;

    return ngx_dns_strcmp(first->key.data, second->key.data);
}",1,1,http\modules\ngx_http_referer_module.c,ngx_http_cmp_referer_wildcards,,false,674,682,ngx_http_cmp_referer_wildcards,,,27,"ANY ngx_http_cmp_referer_wildcards (void*,void*)"
206169,METHOD,http\modules\ngx_http_rewrite_module.c:<global>,TYPE_DECL,<global>,1,1,http\modules\ngx_http_rewrite_module.c,http\modules\ngx_http_rewrite_module.c:<global>,,false,1,1019,<global>,,,1,
206177,METHOD,http\modules\ngx_http_rewrite_module.c:<global>,TYPE_DECL,static void *ngx_http_rewrite_create_loc_conf(ngx_conf_t *cf);,13,61,http\modules\ngx_http_rewrite_module.c,ngx_http_rewrite_create_loc_conf,,false,23,23,ngx_http_rewrite_create_loc_conf,,,3,void* ngx_http_rewrite_create_loc_conf (ngx_conf_t*)
206182,METHOD,http\modules\ngx_http_rewrite_module.c:<global>,TYPE_DECL,"static char *ngx_http_rewrite_merge_loc_conf(ngx_conf_t *cf,
    void *parent, void *child);",13,30,http\modules\ngx_http_rewrite_module.c,ngx_http_rewrite_merge_loc_conf,,false,24,25,ngx_http_rewrite_merge_loc_conf,,,4,"char* ngx_http_rewrite_merge_loc_conf (ngx_conf_t*,void*,void*)"
206189,METHOD,http\modules\ngx_http_rewrite_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_rewrite_init(ngx_conf_t *cf);,18,54,http\modules\ngx_http_rewrite_module.c,ngx_http_rewrite_init,,false,26,26,ngx_http_rewrite_init,,,5,ngx_int_t ngx_http_rewrite_init (ngx_conf_t*)
206194,METHOD,http\modules\ngx_http_rewrite_module.c:<global>,TYPE_DECL,"static char *ngx_http_rewrite(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",13,77,http\modules\ngx_http_rewrite_module.c,ngx_http_rewrite,,false,27,27,ngx_http_rewrite,,,6,"char* ngx_http_rewrite (ngx_conf_t*,ngx_command_t*,void*)"
206201,METHOD,http\modules\ngx_http_rewrite_module.c:<global>,TYPE_DECL,"static char *ngx_http_rewrite_return(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_rewrite_module.c,ngx_http_rewrite_return,,false,28,29,ngx_http_rewrite_return,,,7,"char* ngx_http_rewrite_return (ngx_conf_t*,ngx_command_t*,void*)"
206208,METHOD,http\modules\ngx_http_rewrite_module.c:<global>,TYPE_DECL,"static char *ngx_http_rewrite_break(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_rewrite_module.c,ngx_http_rewrite_break,,false,30,31,ngx_http_rewrite_break,,,8,"char* ngx_http_rewrite_break (ngx_conf_t*,ngx_command_t*,void*)"
206215,METHOD,http\modules\ngx_http_rewrite_module.c:<global>,TYPE_DECL,"static char *ngx_http_rewrite_if(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_rewrite_module.c,ngx_http_rewrite_if,,false,32,33,ngx_http_rewrite_if,,,9,"char* ngx_http_rewrite_if (ngx_conf_t*,ngx_command_t*,void*)"
206222,METHOD,http\modules\ngx_http_rewrite_module.c:<global>,TYPE_DECL,"static char * ngx_http_rewrite_if_condition(ngx_conf_t *cf,
    ngx_http_rewrite_loc_conf_t *lcf);",13,37,http\modules\ngx_http_rewrite_module.c,ngx_http_rewrite_if_condition,,false,34,35,ngx_http_rewrite_if_condition,,,10,"char* ngx_http_rewrite_if_condition (ngx_conf_t*,ngx_http_rewrite_loc_conf_t*)"
206228,METHOD,http\modules\ngx_http_rewrite_module.c:<global>,TYPE_DECL,"static char *ngx_http_rewrite_variable(ngx_conf_t *cf,
    ngx_http_rewrite_loc_conf_t *lcf, ngx_str_t *value);",13,55,http\modules\ngx_http_rewrite_module.c,ngx_http_rewrite_variable,,false,36,37,ngx_http_rewrite_variable,,,11,"char* ngx_http_rewrite_variable (ngx_conf_t*,ngx_http_rewrite_loc_conf_t*,ngx_str_t*)"
206235,METHOD,http\modules\ngx_http_rewrite_module.c:<global>,TYPE_DECL,"static char *ngx_http_rewrite_set(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_rewrite_module.c,ngx_http_rewrite_set,,false,38,39,ngx_http_rewrite_set,,,12,"char* ngx_http_rewrite_set (ngx_conf_t*,ngx_command_t*,void*)"
206242,METHOD,http\modules\ngx_http_rewrite_module.c:<global>,TYPE_DECL,"static char * ngx_http_rewrite_value(ngx_conf_t *cf,
    ngx_http_rewrite_loc_conf_t *lcf, ngx_str_t *value);",13,55,http\modules\ngx_http_rewrite_module.c,ngx_http_rewrite_value,,false,40,41,ngx_http_rewrite_value,,,13,"char* ngx_http_rewrite_value (ngx_conf_t*,ngx_http_rewrite_loc_conf_t*,ngx_str_t*)"
206401,METHOD,http\modules\ngx_http_rewrite_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_rewrite_handler(ngx_http_request_t *r)
{
    ngx_int_t                     index;
    ngx_http_script_code_pt       code;
    ngx_http_script_engine_t     *e;
    ngx_http_core_srv_conf_t     *cscf;
    ngx_http_core_main_conf_t    *cmcf;
    ngx_http_rewrite_loc_conf_t  *rlcf;

    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);
    cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);
    index = cmcf->phase_engine.location_rewrite_index;

    if (r->phase_handler == index && r->loc_conf == cscf->ctx->loc_conf) {
        /* skipping location rewrite phase for server null location */
        return NGX_DECLINED;
    }

    rlcf = ngx_http_get_module_loc_conf(r, ngx_http_rewrite_module);

    if (rlcf->codes == NULL) {
        return NGX_DECLINED;
    }

    e = ngx_pcalloc(r->pool, sizeof(ngx_http_script_engine_t));
    if (e == NULL) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    e->sp = ngx_pcalloc(r->pool,
           ...",1,1,http\modules\ngx_http_rewrite_module.c,ngx_http_rewrite_handler,,false,136,184,ngx_http_rewrite_handler,,,20,ngx_int_t ngx_http_rewrite_handler (ngx_http_request_t*)
206553,METHOD,http\modules\ngx_http_rewrite_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_rewrite_var(ngx_http_request_t *r, ngx_http_variable_value_t *v,
    uintptr_t data)
{
    ngx_http_variable_t          *var;
    ngx_http_core_main_conf_t    *cmcf;
    ngx_http_rewrite_loc_conf_t  *rlcf;

    rlcf = ngx_http_get_module_loc_conf(r, ngx_http_rewrite_module);

    if (rlcf->uninitialized_variable_warn == 0) {
        *v = ngx_http_variable_null_value;
        return NGX_OK;
    }

    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);

    var = cmcf->variables.elts;

    /*
     * the ngx_http_rewrite_module sets variables directly in r->variables,
     * and they should be handled by ngx_http_get_indexed_variable(),
     * so the handler is called only if the variable is not initialized
     */

    ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,
                  ""using uninitialized \""%V\"" variable"", &var[data].name);

    *v = ngx_http_variable_null_value;

    return NGX_OK;
}",1,1,http\modules\ngx_http_rewrite_module.c,ngx_http_rewrite_var,,false,187,218,ngx_http_rewrite_var,,,21,"ngx_int_t ngx_http_rewrite_var (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
206614,METHOD,http\modules\ngx_http_rewrite_module.c:<global>,TYPE_DECL,"static void *
ngx_http_rewrite_create_loc_conf(ngx_conf_t *cf)
{
    ngx_http_rewrite_loc_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_rewrite_loc_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    conf->stack_size = NGX_CONF_UNSET_UINT;
    conf->log = NGX_CONF_UNSET;
    conf->uninitialized_variable_warn = NGX_CONF_UNSET;

    return conf;
}",1,1,http\modules\ngx_http_rewrite_module.c,ngx_http_rewrite_create_loc_conf,,false,221,236,ngx_http_rewrite_create_loc_conf,,,22,void* ngx_http_rewrite_create_loc_conf (ngx_conf_t*)
206652,METHOD,http\modules\ngx_http_rewrite_module.c:<global>,TYPE_DECL,"static char *
ngx_http_rewrite_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_rewrite_loc_conf_t *prev = parent;
    ngx_http_rewrite_loc_conf_t *conf = child;

    uintptr_t  *code;

    ngx_conf_merge_value(conf->log, prev->log, 0);
    ngx_conf_merge_value(conf->uninitialized_variable_warn,
                         prev->uninitialized_variable_warn, 1);
    ngx_conf_merge_uint_value(conf->stack_size, prev->stack_size, 10);

    if (conf->codes == NULL) {
        return NGX_CONF_OK;
    }

    if (conf->codes == prev->codes) {
        return NGX_CONF_OK;
    }

    code = ngx_array_push_n(conf->codes, sizeof(uintptr_t));
    if (code == NULL) {
        return NGX_CONF_ERROR;
    }

    *code = (uintptr_t) NULL;

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_rewrite_module.c,ngx_http_rewrite_merge_loc_conf,,false,239,268,ngx_http_rewrite_merge_loc_conf,,,23,"char* ngx_http_rewrite_merge_loc_conf (ngx_conf_t*,void*,void*)"
206735,METHOD,http\modules\ngx_http_rewrite_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_rewrite_init(ngx_conf_t *cf)
{
    ngx_http_handler_pt        *h;
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);

    h = ngx_array_push(&cmcf->phases[NGX_HTTP_SERVER_REWRITE_PHASE].handlers);
    if (h == NULL) {
        return NGX_ERROR;
    }

    *h = ngx_http_rewrite_handler;

    h = ngx_array_push(&cmcf->phases[NGX_HTTP_REWRITE_PHASE].handlers);
    if (h == NULL) {
        return NGX_ERROR;
    }

    *h = ngx_http_rewrite_handler;

    return NGX_OK;
}",1,1,http\modules\ngx_http_rewrite_module.c,ngx_http_rewrite_init,,false,271,294,ngx_http_rewrite_init,,,24,ngx_int_t ngx_http_rewrite_init (ngx_conf_t*)
206793,METHOD,http\modules\ngx_http_rewrite_module.c:<global>,TYPE_DECL,"static char *
ngx_http_rewrite(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_rewrite_loc_conf_t  *lcf = conf;

    ngx_str_t                         *value;
    ngx_uint_t                         last;
    ngx_regex_compile_t                rc;
    ngx_http_script_code_pt           *code;
    ngx_http_script_compile_t          sc;
    ngx_http_script_regex_code_t      *regex;
    ngx_http_script_regex_end_code_t  *regex_end;
    u_char                             errstr[NGX_MAX_CONF_ERRSTR];

    regex = ngx_http_script_start_code(cf->pool, &lcf->codes,
                                       sizeof(ngx_http_script_regex_code_t));
    if (regex == NULL) {
        return NGX_CONF_ERROR;
    }

    ngx_memzero(regex, sizeof(ngx_http_script_regex_code_t));

    value = cf->args->elts;

    if (value[2].len == 0) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, ""empty replacement"");
        return NGX_CONF_ERROR;
    }

    ngx_memzero(&rc, sizeof(ngx_regex_compile_t))...",1,1,http\modules\ngx_http_rewrite_module.c,ngx_http_rewrite,,false,297,438,ngx_http_rewrite,,,25,"char* ngx_http_rewrite (ngx_conf_t*,ngx_command_t*,void*)"
207319,METHOD,http\modules\ngx_http_rewrite_module.c:<global>,TYPE_DECL,"static char *
ngx_http_rewrite_return(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_rewrite_loc_conf_t  *lcf = conf;

    u_char                            *p;
    ngx_str_t                         *value, *v;
    ngx_http_script_return_code_t     *ret;
    ngx_http_compile_complex_value_t   ccv;

    ret = ngx_http_script_start_code(cf->pool, &lcf->codes,
                                     sizeof(ngx_http_script_return_code_t));
    if (ret == NULL) {
        return NGX_CONF_ERROR;
    }

    value = cf->args->elts;

    ngx_memzero(ret, sizeof(ngx_http_script_return_code_t));

    ret->code = ngx_http_script_return_code;

    p = value[1].data;

    ret->status = ngx_atoi(p, value[1].len);

    if (ret->status == (uintptr_t) NGX_ERROR) {

        if (cf->args->nelts == 2
            && (ngx_strncmp(p, ""http://"", sizeof(""http://"") - 1) == 0
                || ngx_strncmp(p, ""https://"", sizeof(""https://"") - 1) == 0
                || ngx_strncmp(p, ""$scheme"", size...",1,1,http\modules\ngx_http_rewrite_module.c,ngx_http_rewrite_return,,false,441,509,ngx_http_rewrite_return,,,26,"char* ngx_http_rewrite_return (ngx_conf_t*,ngx_command_t*,void*)"
207531,METHOD,http\modules\ngx_http_rewrite_module.c:<global>,TYPE_DECL,"static char *
ngx_http_rewrite_break(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_rewrite_loc_conf_t *lcf = conf;

    ngx_http_script_code_pt  *code;

    code = ngx_http_script_start_code(cf->pool, &lcf->codes, sizeof(uintptr_t));
    if (code == NULL) {
        return NGX_CONF_ERROR;
    }

    *code = ngx_http_script_break_code;

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_rewrite_module.c,ngx_http_rewrite_break,,false,512,527,ngx_http_rewrite_break,,,27,"char* ngx_http_rewrite_break (ngx_conf_t*,ngx_command_t*,void*)"
207568,METHOD,http\modules\ngx_http_rewrite_module.c:<global>,TYPE_DECL,"static char *
ngx_http_rewrite_if(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_rewrite_loc_conf_t  *lcf = conf;

    void                         *mconf;
    char                         *rv;
    u_char                       *elts;
    ngx_uint_t                    i;
    ngx_conf_t                    save;
    ngx_http_module_t            *module;
    ngx_http_conf_ctx_t          *ctx, *pctx;
    ngx_http_core_loc_conf_t     *clcf, *pclcf;
    ngx_http_script_if_code_t    *if_code;
    ngx_http_rewrite_loc_conf_t  *nlcf;

    ctx = ngx_pcalloc(cf->pool, sizeof(ngx_http_conf_ctx_t));
    if (ctx == NULL) {
        return NGX_CONF_ERROR;
    }

    pctx = cf->ctx;
    ctx->main_conf = pctx->main_conf;
    ctx->srv_conf = pctx->srv_conf;

    ctx->loc_conf = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_http_max_module);
    if (ctx->loc_conf == NULL) {
        return NGX_CONF_ERROR;
    }

    for (i = 0; cf->cycle->modules[i]; i++) {
        if (cf->cycle->modules[i]-...",1,1,http\modules\ngx_http_rewrite_module.c,ngx_http_rewrite_if,,false,530,643,ngx_http_rewrite_if,,,28,"char* ngx_http_rewrite_if (ngx_conf_t*,ngx_command_t*,void*)"
207932,METHOD,http\modules\ngx_http_rewrite_module.c:<global>,TYPE_DECL,"static char *
ngx_http_rewrite_if_condition(ngx_conf_t *cf, ngx_http_rewrite_loc_conf_t *lcf)
{
    u_char                        *p;
    size_t                         len;
    ngx_str_t                     *value;
    ngx_uint_t                     cur, last;
    ngx_regex_compile_t            rc;
    ngx_http_script_code_pt       *code;
    ngx_http_script_file_code_t   *fop;
    ngx_http_script_regex_code_t  *regex;
    u_char                         errstr[NGX_MAX_CONF_ERRSTR];

    value = cf->args->elts;
    last = cf->args->nelts - 1;

    if (value[1].len < 1 || value[1].data[0] != '(') {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""invalid condition \""%V\"""", &value[1]);
        return NGX_CONF_ERROR;
    }

    if (value[1].len == 1) {
        cur = 2;

    } else {
        cur = 1;
        value[1].len--;
        value[1].data++;
    }

    if (value[last].len < 1 || value[last].data[value[last].len - 1] != ')') {
        ngx_conf_log_error...",1,1,http\modules\ngx_http_rewrite_module.c,ngx_http_rewrite_if_condition,,false,646,863,ngx_http_rewrite_if_condition,,,29,"char* ngx_http_rewrite_if_condition (ngx_conf_t*,ngx_http_rewrite_loc_conf_t*)"
208715,METHOD,http\modules\ngx_http_rewrite_module.c:<global>,TYPE_DECL,"static char *
ngx_http_rewrite_variable(ngx_conf_t *cf, ngx_http_rewrite_loc_conf_t *lcf,
    ngx_str_t *value)
{
    ngx_int_t                    index;
    ngx_http_script_var_code_t  *var_code;

    value->len--;
    value->data++;

    index = ngx_http_get_variable_index(cf, value);

    if (index == NGX_ERROR) {
        return NGX_CONF_ERROR;
    }

    var_code = ngx_http_script_start_code(cf->pool, &lcf->codes,
                                          sizeof(ngx_http_script_var_code_t));
    if (var_code == NULL) {
        return NGX_CONF_ERROR;
    }

    var_code->code = ngx_http_script_var_code;
    var_code->index = index;

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_rewrite_module.c,ngx_http_rewrite_variable,,false,866,892,ngx_http_rewrite_variable,,,30,"char* ngx_http_rewrite_variable (ngx_conf_t*,ngx_http_rewrite_loc_conf_t*,ngx_str_t*)"
208775,METHOD,http\modules\ngx_http_rewrite_module.c:<global>,TYPE_DECL,"static char *
ngx_http_rewrite_set(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_rewrite_loc_conf_t  *lcf = conf;

    ngx_int_t                            index;
    ngx_str_t                           *value;
    ngx_http_variable_t                 *v;
    ngx_http_script_var_code_t          *vcode;
    ngx_http_script_var_handler_code_t  *vhcode;

    value = cf->args->elts;

    if (value[1].data[0] != '$') {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""invalid variable name \""%V\"""", &value[1]);
        return NGX_CONF_ERROR;
    }

    value[1].len--;
    value[1].data++;

    v = ngx_http_add_variable(cf, &value[1],
                              NGX_HTTP_VAR_CHANGEABLE|NGX_HTTP_VAR_WEAK);
    if (v == NULL) {
        return NGX_CONF_ERROR;
    }

    index = ngx_http_get_variable_index(cf, &value[1]);
    if (index == NGX_ERROR) {
        return NGX_CONF_ERROR;
    }

    if (v->get_handler == NULL) {
        v->get_handler = ng...",1,1,http\modules\ngx_http_rewrite_module.c,ngx_http_rewrite_set,,false,895,961,ngx_http_rewrite_set,,,31,"char* ngx_http_rewrite_set (ngx_conf_t*,ngx_command_t*,void*)"
208973,METHOD,http\modules\ngx_http_rewrite_module.c:<global>,TYPE_DECL,"static char *
ngx_http_rewrite_value(ngx_conf_t *cf, ngx_http_rewrite_loc_conf_t *lcf,
    ngx_str_t *value)
{
    ngx_int_t                              n;
    ngx_http_script_compile_t              sc;
    ngx_http_script_value_code_t          *val;
    ngx_http_script_complex_value_code_t  *complex;

    n = ngx_http_script_variables_count(value);

    if (n == 0) {
        val = ngx_http_script_start_code(cf->pool, &lcf->codes,
                                         sizeof(ngx_http_script_value_code_t));
        if (val == NULL) {
            return NGX_CONF_ERROR;
        }

        n = ngx_atoi(value->data, value->len);

        if (n == NGX_ERROR) {
            n = 0;
        }

        val->code = ngx_http_script_value_code;
        val->value = (uintptr_t) n;
        val->text_len = (uintptr_t) value->len;
        val->text_data = (uintptr_t) value->data;

        return NGX_CONF_OK;
    }

    complex = ngx_http_script_start_code(cf->pool, &lcf->codes,
                  ...",1,1,http\modules\ngx_http_rewrite_module.c,ngx_http_rewrite_value,,false,964,1019,ngx_http_rewrite_value,,,32,"char* ngx_http_rewrite_value (ngx_conf_t*,ngx_http_rewrite_loc_conf_t*,ngx_str_t*)"
209151,METHOD,http\modules\ngx_http_scgi_module.c:<global>,TYPE_DECL,<global>,1,6,http\modules\ngx_http_scgi_module.c,http\modules\ngx_http_scgi_module.c:<global>,,false,1,2019,<global>,,,1,
209172,METHOD,http\modules\ngx_http_scgi_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_scgi_eval(ngx_http_request_t *r,
    ngx_http_scgi_loc_conf_t *scf);",18,34,http\modules\ngx_http_scgi_module.c,ngx_http_scgi_eval,,false,46,47,ngx_http_scgi_eval,,,7,"ngx_int_t ngx_http_scgi_eval (ngx_http_request_t*,ngx_http_scgi_loc_conf_t*)"
209178,METHOD,http\modules\ngx_http_scgi_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_scgi_create_request(ngx_http_request_t *r);,18,68,http\modules\ngx_http_scgi_module.c,ngx_http_scgi_create_request,,false,48,48,ngx_http_scgi_create_request,,,8,ngx_int_t ngx_http_scgi_create_request (ngx_http_request_t*)
209183,METHOD,http\modules\ngx_http_scgi_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_scgi_reinit_request(ngx_http_request_t *r);,18,68,http\modules\ngx_http_scgi_module.c,ngx_http_scgi_reinit_request,,false,49,49,ngx_http_scgi_reinit_request,,,9,ngx_int_t ngx_http_scgi_reinit_request (ngx_http_request_t*)
209188,METHOD,http\modules\ngx_http_scgi_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_scgi_process_status_line(ngx_http_request_t *r);,18,73,http\modules\ngx_http_scgi_module.c,ngx_http_scgi_process_status_line,,false,50,50,ngx_http_scgi_process_status_line,,,10,ngx_int_t ngx_http_scgi_process_status_line (ngx_http_request_t*)
209193,METHOD,http\modules\ngx_http_scgi_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_scgi_process_header(ngx_http_request_t *r);,18,68,http\modules\ngx_http_scgi_module.c,ngx_http_scgi_process_header,,false,51,51,ngx_http_scgi_process_header,,,11,ngx_int_t ngx_http_scgi_process_header (ngx_http_request_t*)
209198,METHOD,http\modules\ngx_http_scgi_module.c:<global>,TYPE_DECL,static void ngx_http_scgi_abort_request(ngx_http_request_t *r);,13,62,http\modules\ngx_http_scgi_module.c,ngx_http_scgi_abort_request,,false,52,52,ngx_http_scgi_abort_request,,,12,void ngx_http_scgi_abort_request (ngx_http_request_t*)
209203,METHOD,http\modules\ngx_http_scgi_module.c:<global>,TYPE_DECL,"static void ngx_http_scgi_finalize_request(ngx_http_request_t *r, ngx_int_t rc);",13,79,http\modules\ngx_http_scgi_module.c,ngx_http_scgi_finalize_request,,false,53,53,ngx_http_scgi_finalize_request,,,13,"void ngx_http_scgi_finalize_request (ngx_http_request_t*,ngx_int_t)"
209209,METHOD,http\modules\ngx_http_scgi_module.c:<global>,TYPE_DECL,static void *ngx_http_scgi_create_main_conf(ngx_conf_t *cf);,13,59,http\modules\ngx_http_scgi_module.c,ngx_http_scgi_create_main_conf,,false,55,55,ngx_http_scgi_create_main_conf,,,14,void* ngx_http_scgi_create_main_conf (ngx_conf_t*)
209214,METHOD,http\modules\ngx_http_scgi_module.c:<global>,TYPE_DECL,static void *ngx_http_scgi_create_loc_conf(ngx_conf_t *cf);,13,58,http\modules\ngx_http_scgi_module.c,ngx_http_scgi_create_loc_conf,,false,56,56,ngx_http_scgi_create_loc_conf,,,15,void* ngx_http_scgi_create_loc_conf (ngx_conf_t*)
209219,METHOD,http\modules\ngx_http_scgi_module.c:<global>,TYPE_DECL,"static char *ngx_http_scgi_merge_loc_conf(ngx_conf_t *cf, void *parent,
    void *child);",13,16,http\modules\ngx_http_scgi_module.c,ngx_http_scgi_merge_loc_conf,,false,57,58,ngx_http_scgi_merge_loc_conf,,,16,"char* ngx_http_scgi_merge_loc_conf (ngx_conf_t*,void*,void*)"
209226,METHOD,http\modules\ngx_http_scgi_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_scgi_init_params(ngx_conf_t *cf,
    ngx_http_scgi_loc_conf_t *conf, ngx_http_scgi_params_t *params,
    ngx_keyval_t *default_params);",18,33,http\modules\ngx_http_scgi_module.c,ngx_http_scgi_init_params,,false,59,61,ngx_http_scgi_init_params,,,17,"ngx_int_t ngx_http_scgi_init_params (ngx_conf_t*,ngx_http_scgi_loc_conf_t*,ngx_http_scgi_params_t*,ngx_keyval_t*)"
209234,METHOD,http\modules\ngx_http_scgi_module.c:<global>,TYPE_DECL,"static char *ngx_http_scgi_pass(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",13,79,http\modules\ngx_http_scgi_module.c,ngx_http_scgi_pass,,false,63,63,ngx_http_scgi_pass,,,18,"char* ngx_http_scgi_pass (ngx_conf_t*,ngx_command_t*,void*)"
209241,METHOD,http\modules\ngx_http_scgi_module.c:<global>,TYPE_DECL,"static char *ngx_http_scgi_store(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_scgi_module.c,ngx_http_scgi_store,,false,64,65,ngx_http_scgi_store,,,19,"char* ngx_http_scgi_store (ngx_conf_t*,ngx_command_t*,void*)"
209873,METHOD,http\modules\ngx_http_scgi_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_scgi_handler(ngx_http_request_t *r)
{
    ngx_int_t                   rc;
    ngx_http_status_t          *status;
    ngx_http_upstream_t        *u;
    ngx_http_scgi_loc_conf_t   *scf;
#if (NGX_HTTP_CACHE)
    ngx_http_scgi_main_conf_t  *smcf;
#endif

    if (ngx_http_upstream_create(r) != NGX_OK) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    status = ngx_pcalloc(r->pool, sizeof(ngx_http_status_t));
    if (status == NULL) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    ngx_http_set_ctx(r, status, ngx_http_scgi_module);

    scf = ngx_http_get_module_loc_conf(r, ngx_http_scgi_module);

    if (scf->scgi_lengths) {
        if (ngx_http_scgi_eval(r, scf) != NGX_OK) {
            return NGX_HTTP_INTERNAL_SERVER_ERROR;
        }
    }

    u = r->upstream;

    ngx_str_set(&u->schema, ""scgi://"");
    u->output.tag = (ngx_buf_tag_t) &ngx_http_scgi_module;

    u->conf = &scf->upstream;

#if (NGX_HTTP_CACHE)
    smcf = ngx_http_get_modu...",1,1,http\modules\ngx_http_scgi_module.c,ngx_http_scgi_handler,,false,476,551,ngx_http_scgi_handler,,,33,ngx_int_t ngx_http_scgi_handler (ngx_http_request_t*)
210068,METHOD,http\modules\ngx_http_scgi_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_scgi_eval(ngx_http_request_t *r, ngx_http_scgi_loc_conf_t * scf)
{
    ngx_url_t             url;
    ngx_http_upstream_t  *u;

    ngx_memzero(&url, sizeof(ngx_url_t));

    if (ngx_http_script_run(r, &url.url, scf->scgi_lengths->elts, 0,
                            scf->scgi_values->elts)
        == NULL)
    {
        return NGX_ERROR;
    }

    url.no_resolve = 1;

    if (ngx_parse_url(r->pool, &url) != NGX_OK) {
        if (url.err) {
            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                          ""%s in upstream \""%V\"""", url.err, &url.url);
        }

        return NGX_ERROR;
    }

    u = r->upstream;

    u->resolved = ngx_pcalloc(r->pool, sizeof(ngx_http_upstream_resolved_t));
    if (u->resolved == NULL) {
        return NGX_ERROR;
    }

    if (url.addrs) {
        u->resolved->sockaddr = url.addrs[0].sockaddr;
        u->resolved->socklen = url.addrs[0].socklen;
        u->resolved->name = url.addrs[0].name;
        ...",1,1,http\modules\ngx_http_scgi_module.c,ngx_http_scgi_eval,,false,554,599,ngx_http_scgi_eval,,,34,"ngx_int_t ngx_http_scgi_eval (ngx_http_request_t*,ngx_http_scgi_loc_conf_t*)"
210246,METHOD,http\modules\ngx_http_scgi_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_scgi_create_request(ngx_http_request_t *r)
{
    off_t                         content_length_n;
    u_char                        ch, *key, *val, *lowcase_key;
    size_t                        len, key_len, val_len, allocated;
    ngx_buf_t                    *b;
    ngx_str_t                     content_length;
    ngx_uint_t                    i, n, hash, skip_empty, header_params;
    ngx_chain_t                  *cl, *body;
    ngx_list_part_t              *part;
    ngx_table_elt_t              *header, **ignored;
    ngx_http_scgi_params_t       *params;
    ngx_http_script_code_pt       code;
    ngx_http_script_engine_t      e, le;
    ngx_http_scgi_loc_conf_t     *scf;
    ngx_http_script_len_code_pt   lcode;
    u_char                        buffer[NGX_OFF_T_LEN];

    content_length_n = 0;
    body = r->upstream->request_bufs;

    while (body) {
        content_length_n += ngx_buf_size(body->buf);
        body = body->next;
    }

    content_...",1,1,http\modules\ngx_http_scgi_module.c,ngx_http_scgi_create_request,,false,627,937,ngx_http_scgi_create_request,,,35,ngx_int_t ngx_http_scgi_create_request (ngx_http_request_t*)
211314,METHOD,http\modules\ngx_http_scgi_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_scgi_reinit_request(ngx_http_request_t *r)
{
    ngx_http_status_t  *status;

    status = ngx_http_get_module_ctx(r, ngx_http_scgi_module);

    if (status == NULL) {
        return NGX_OK;
    }

    status->code = 0;
    status->count = 0;
    status->start = NULL;
    status->end = NULL;

    r->upstream->process_header = ngx_http_scgi_process_status_line;
    r->state = 0;

    return NGX_OK;
}",1,1,http\modules\ngx_http_scgi_module.c,ngx_http_scgi_reinit_request,,false,940,960,ngx_http_scgi_reinit_request,,,36,ngx_int_t ngx_http_scgi_reinit_request (ngx_http_request_t*)
211366,METHOD,http\modules\ngx_http_scgi_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_scgi_process_status_line(ngx_http_request_t *r)
{
    size_t                len;
    ngx_int_t             rc;
    ngx_http_status_t    *status;
    ngx_http_upstream_t  *u;

    status = ngx_http_get_module_ctx(r, ngx_http_scgi_module);

    if (status == NULL) {
        return NGX_ERROR;
    }

    u = r->upstream;

    rc = ngx_http_parse_status_line(r, &u->buffer, status);

    if (rc == NGX_AGAIN) {
        return rc;
    }

    if (rc == NGX_ERROR) {
        u->process_header = ngx_http_scgi_process_header;
        return ngx_http_scgi_process_header(r);
    }

    if (u->state && u->state->status == 0) {
        u->state->status = status->code;
    }

    u->headers_in.status_n = status->code;

    len = status->end - status->start;
    u->headers_in.status_line.len = len;

    u->headers_in.status_line.data = ngx_pnalloc(r->pool, len);
    if (u->headers_in.status_line.data == NULL) {
        return NGX_ERROR;
    }

    ngx_memcpy(u->headers_in.sta...",1,1,http\modules\ngx_http_scgi_module.c,ngx_http_scgi_process_status_line,,false,963,1013,ngx_http_scgi_process_status_line,,,37,ngx_int_t ngx_http_scgi_process_status_line (ngx_http_request_t*)
211536,METHOD,http\modules\ngx_http_scgi_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_scgi_process_header(ngx_http_request_t *r)
{
    ngx_str_t                      *status_line;
    ngx_int_t                       rc, status;
    ngx_table_elt_t                *h;
    ngx_http_upstream_t            *u;
    ngx_http_upstream_header_t     *hh;
    ngx_http_upstream_main_conf_t  *umcf;

    umcf = ngx_http_get_module_main_conf(r, ngx_http_upstream_module);

    for ( ;; ) {

        rc = ngx_http_parse_header_line(r, &r->upstream->buffer, 1);

        if (rc == NGX_OK) {

            /* a header line has been parsed successfully */

            h = ngx_list_push(&r->upstream->headers_in.headers);
            if (h == NULL) {
                return NGX_ERROR;
            }

            h->hash = r->header_hash;

            h->key.len = r->header_name_end - r->header_name_start;
            h->value.len = r->header_end - r->header_start;

            h->key.data = ngx_pnalloc(r->pool,
                                      h->key.len + 1 + h->v...",1,1,http\modules\ngx_http_scgi_module.c,ngx_http_scgi_process_header,,false,1016,1145,ngx_http_scgi_process_header,,,38,ngx_int_t ngx_http_scgi_process_header (ngx_http_request_t*)
212049,METHOD,http\modules\ngx_http_scgi_module.c:<global>,TYPE_DECL,"static void
ngx_http_scgi_abort_request(ngx_http_request_t *r)
{
    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""abort http scgi request"");

    return;
}",1,1,http\modules\ngx_http_scgi_module.c,ngx_http_scgi_abort_request,,false,1148,1155,ngx_http_scgi_abort_request,,,39,void ngx_http_scgi_abort_request (ngx_http_request_t*)
212064,METHOD,http\modules\ngx_http_scgi_module.c:<global>,TYPE_DECL,"static void
ngx_http_scgi_finalize_request(ngx_http_request_t *r, ngx_int_t rc)
{
    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""finalize http scgi request"");

    return;
}",1,1,http\modules\ngx_http_scgi_module.c,ngx_http_scgi_finalize_request,,false,1158,1165,ngx_http_scgi_finalize_request,,,40,"void ngx_http_scgi_finalize_request (ngx_http_request_t*,ngx_int_t)"
212080,METHOD,http\modules\ngx_http_scgi_module.c:<global>,TYPE_DECL,"static void *
ngx_http_scgi_create_main_conf(ngx_conf_t *cf)
{
    ngx_http_scgi_main_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_scgi_main_conf_t));
    if (conf == NULL) {
        return NULL;
    }

#if (NGX_HTTP_CACHE)
    if (ngx_array_init(&conf->caches, cf->pool, 4,
                       sizeof(ngx_http_file_cache_t *))
        != NGX_OK)
    {
        return NULL;
    }
#endif

    return conf;
}",1,1,http\modules\ngx_http_scgi_module.c,ngx_http_scgi_create_main_conf,,false,1168,1188,ngx_http_scgi_create_main_conf,,,41,void* ngx_http_scgi_create_main_conf (ngx_conf_t*)
212103,METHOD,http\modules\ngx_http_scgi_module.c:<global>,TYPE_DECL,"static void *
ngx_http_scgi_create_loc_conf(ngx_conf_t *cf)
{
    ngx_http_scgi_loc_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_scgi_loc_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    conf->upstream.store = NGX_CONF_UNSET;
    conf->upstream.store_access = NGX_CONF_UNSET_UINT;
    conf->upstream.next_upstream_tries = NGX_CONF_UNSET_UINT;
    conf->upstream.buffering = NGX_CONF_UNSET;
    conf->upstream.request_buffering = NGX_CONF_UNSET;
    conf->upstream.ignore_client_abort = NGX_CONF_UNSET;
    conf->upstream.force_ranges = NGX_CONF_UNSET;

    conf->upstream.local = NGX_CONF_UNSET_PTR;
    conf->upstream.socket_keepalive = NGX_CONF_UNSET;

    conf->upstream.connect_timeout = NGX_CONF_UNSET_MSEC;
    conf->upstream.send_timeout = NGX_CONF_UNSET_MSEC;
    conf->upstream.read_timeout = NGX_CONF_UNSET_MSEC;
    conf->upstream.next_upstream_timeout = NGX_CONF_UNSET_MSEC;

    conf->upstream.send_lowat = NGX_CONF_UNSET_SIZE;
    conf->upstream....",1,1,http\modules\ngx_http_scgi_module.c,ngx_http_scgi_create_loc_conf,,false,1191,1255,ngx_http_scgi_create_loc_conf,,,42,void* ngx_http_scgi_create_loc_conf (ngx_conf_t*)
212316,METHOD,http\modules\ngx_http_scgi_module.c:<global>,TYPE_DECL,"static char *
ngx_http_scgi_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_scgi_loc_conf_t *prev = parent;
    ngx_http_scgi_loc_conf_t *conf = child;

    size_t                        size;
    ngx_int_t                     rc;
    ngx_hash_init_t               hash;
    ngx_http_core_loc_conf_t     *clcf;

#if (NGX_HTTP_CACHE)

    if (conf->upstream.store > 0) {
        conf->upstream.cache = 0;
    }

    if (conf->upstream.cache > 0) {
        conf->upstream.store = 0;
    }

#endif

    if (conf->upstream.store == NGX_CONF_UNSET) {
        ngx_conf_merge_value(conf->upstream.store, prev->upstream.store, 0);

        conf->upstream.store_lengths = prev->upstream.store_lengths;
        conf->upstream.store_values = prev->upstream.store_values;
    }

    ngx_conf_merge_uint_value(conf->upstream.store_access,
                              prev->upstream.store_access, 0600);

    ngx_conf_merge_uint_value(conf->upstream.next_upstream_tries,
             ...",1,1,http\modules\ngx_http_scgi_module.c,ngx_http_scgi_merge_loc_conf,,false,1258,1610,ngx_http_scgi_merge_loc_conf,,,43,"char* ngx_http_scgi_merge_loc_conf (ngx_conf_t*,void*,void*)"
213117,METHOD,http\modules\ngx_http_scgi_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_scgi_init_params(ngx_conf_t *cf, ngx_http_scgi_loc_conf_t *conf,
    ngx_http_scgi_params_t *params, ngx_keyval_t *default_params)
{
    u_char                       *p;
    size_t                        size;
    uintptr_t                    *code;
    ngx_uint_t                    i, nsrc;
    ngx_array_t                   headers_names, params_merged;
    ngx_keyval_t                 *h;
    ngx_hash_key_t               *hk;
    ngx_hash_init_t               hash;
    ngx_http_upstream_param_t    *src, *s;
    ngx_http_script_compile_t     sc;
    ngx_http_script_copy_code_t  *copy;

    if (params->hash.buckets) {
        return NGX_OK;
    }

    if (conf->params_source == NULL && default_params == NULL) {
        params->hash.buckets = (void *) 1;
        return NGX_OK;
    }

    params->lengths = ngx_array_create(cf->pool, 64, 1);
    if (params->lengths == NULL) {
        return NGX_ERROR;
    }

    params->values = ngx_array_create(cf->pool, 512,...",1,1,http\modules\ngx_http_scgi_module.c,ngx_http_scgi_init_params,,false,1613,1815,ngx_http_scgi_init_params,,,44,"ngx_int_t ngx_http_scgi_init_params (ngx_conf_t*,ngx_http_scgi_loc_conf_t*,ngx_http_scgi_params_t*,ngx_keyval_t*)"
213835,METHOD,http\modules\ngx_http_scgi_module.c:<global>,TYPE_DECL,"static char *
ngx_http_scgi_pass(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_scgi_loc_conf_t *scf = conf;

    ngx_url_t                   u;
    ngx_str_t                  *value, *url;
    ngx_uint_t                  n;
    ngx_http_core_loc_conf_t   *clcf;
    ngx_http_script_compile_t   sc;

    if (scf->upstream.upstream || scf->scgi_lengths) {
        return ""is duplicate"";
    }

    clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);
    clcf->handler = ngx_http_scgi_handler;

    value = cf->args->elts;

    url = &value[1];

    n = ngx_http_script_variables_count(url);

    if (n) {

        ngx_memzero(&sc, sizeof(ngx_http_script_compile_t));

        sc.cf = cf;
        sc.source = url;
        sc.lengths = &scf->scgi_lengths;
        sc.values = &scf->scgi_values;
        sc.variables = n;
        sc.complete_lengths = 1;
        sc.complete_values = 1;

        if (ngx_http_script_compile(&sc) != NGX_OK) {
            return NGX_CONF...",1,1,http\modules\ngx_http_scgi_module.c,ngx_http_scgi_pass,,false,1818,1876,ngx_http_scgi_pass,,,45,"char* ngx_http_scgi_pass (ngx_conf_t*,ngx_command_t*,void*)"
214021,METHOD,http\modules\ngx_http_scgi_module.c:<global>,TYPE_DECL,"static char *
ngx_http_scgi_store(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_scgi_loc_conf_t *scf = conf;

    ngx_str_t                  *value;
    ngx_http_script_compile_t   sc;

    if (scf->upstream.store != NGX_CONF_UNSET) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    if (ngx_strcmp(value[1].data, ""off"") == 0) {
        scf->upstream.store = 0;
        return NGX_CONF_OK;
    }

#if (NGX_HTTP_CACHE)
    if (scf->upstream.cache > 0) {
        return ""is incompatible with \""scgi_cache\"""";
    }
#endif

    scf->upstream.store = 1;

    if (ngx_strcmp(value[1].data, ""on"") == 0) {
        return NGX_CONF_OK;
    }

    /* include the terminating '\0' into script */
    value[1].len++;

    ngx_memzero(&sc, sizeof(ngx_http_script_compile_t));

    sc.cf = cf;
    sc.source = &value[1];
    sc.lengths = &scf->upstream.store_lengths;
    sc.values = &scf->upstream.store_values;
    sc.variables = ngx_http_script_variables_count(&value[1...",1,1,http\modules\ngx_http_scgi_module.c,ngx_http_scgi_store,,false,1879,1928,ngx_http_scgi_store,,,46,"char* ngx_http_scgi_store (ngx_conf_t*,ngx_command_t*,void*)"
214177,METHOD,http\modules\ngx_http_secure_link_module.c:<global>,TYPE_DECL,<global>,1,1,http\modules\ngx_http_secure_link_module.c,http\modules\ngx_http_secure_link_module.c:<global>,,false,1,367,<global>,,,1,
214187,METHOD,http\modules\ngx_http_secure_link_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_secure_link_old_variable(ngx_http_request_t *r,
    ngx_http_secure_link_conf_t *conf, ngx_http_variable_value_t *v,
    uintptr_t data);",18,19,http\modules\ngx_http_secure_link_module.c,ngx_http_secure_link_old_variable,,false,26,28,ngx_http_secure_link_old_variable,,,5,"ngx_int_t ngx_http_secure_link_old_variable (ngx_http_request_t*,ngx_http_secure_link_conf_t*,ngx_http_variable_value_t*,uintptr_t)"
214195,METHOD,http\modules\ngx_http_secure_link_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_secure_link_expires_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\modules\ngx_http_secure_link_module.c,ngx_http_secure_link_expires_variable,,false,29,30,ngx_http_secure_link_expires_variable,,,6,"ngx_int_t ngx_http_secure_link_expires_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
214202,METHOD,http\modules\ngx_http_secure_link_module.c:<global>,TYPE_DECL,static void *ngx_http_secure_link_create_conf(ngx_conf_t *cf);,13,61,http\modules\ngx_http_secure_link_module.c,ngx_http_secure_link_create_conf,,false,31,31,ngx_http_secure_link_create_conf,,,7,void* ngx_http_secure_link_create_conf (ngx_conf_t*)
214207,METHOD,http\modules\ngx_http_secure_link_module.c:<global>,TYPE_DECL,"static char *ngx_http_secure_link_merge_conf(ngx_conf_t *cf, void *parent,
    void *child);",13,16,http\modules\ngx_http_secure_link_module.c,ngx_http_secure_link_merge_conf,,false,32,33,ngx_http_secure_link_merge_conf,,,8,"char* ngx_http_secure_link_merge_conf (ngx_conf_t*,void*,void*)"
214214,METHOD,http\modules\ngx_http_secure_link_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_secure_link_add_variables(ngx_conf_t *cf);,18,67,http\modules\ngx_http_secure_link_module.c,ngx_http_secure_link_add_variables,,false,34,34,ngx_http_secure_link_add_variables,,,9,ngx_int_t ngx_http_secure_link_add_variables (ngx_conf_t*)
214311,METHOD,http\modules\ngx_http_secure_link_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_secure_link_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    u_char                       *p, *last;
    ngx_str_t                     val, hash;
    time_t                        expires;
    ngx_md5_t                     md5;
    ngx_http_secure_link_ctx_t   *ctx;
    ngx_http_secure_link_conf_t  *conf;
    u_char                        hash_buf[18], md5_buf[16];

    conf = ngx_http_get_module_loc_conf(r, ngx_http_secure_link_module);

    if (conf->secret.data) {
        return ngx_http_secure_link_old_variable(r, conf, v, data);
    }

    if (conf->variable == NULL || conf->md5 == NULL) {
        goto not_found;
    }

    if (ngx_http_complex_value(r, conf->variable, &val) != NGX_OK) {
        return NGX_ERROR;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""secure link: \""%V\"""", &val);

    last = val.data + val.len;

    p = ngx_strlchr(val.data, last, ',');
    expires...",1,1,http\modules\ngx_http_secure_link_module.c,ngx_http_secure_link_variable,,false,100,195,ngx_http_secure_link_variable,,,20,"ngx_int_t ngx_http_secure_link_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
214589,METHOD,http\modules\ngx_http_secure_link_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_secure_link_old_variable(ngx_http_request_t *r,
    ngx_http_secure_link_conf_t *conf, ngx_http_variable_value_t *v,
    uintptr_t data)
{
    u_char      *p, *start, *end, *last;
    size_t       len;
    ngx_int_t    n;
    ngx_uint_t   i;
    ngx_md5_t    md5;
    u_char       hash[16];

    p = &r->unparsed_uri.data[1];
    last = r->unparsed_uri.data + r->unparsed_uri.len;

    while (p < last) {
        if (*p++ == '/') {
            start = p;
            goto md5_start;
        }
    }

    goto not_found;

md5_start:

    while (p < last) {
        if (*p++ == '/') {
            end = p - 1;
            goto url_start;
        }
    }

    goto not_found;

url_start:

    len = last - p;

    if (end - start != 32 || len == 0) {
        goto not_found;
    }

    ngx_md5_init(&md5);
    ngx_md5_update(&md5, p, len);
    ngx_md5_update(&md5, conf->secret.data, conf->secret.len);
    ngx_md5_final(hash, &md5);

    for (i = 0; i < 16; i++) {
        ...",1,1,http\modules\ngx_http_secure_link_module.c,ngx_http_secure_link_old_variable,,false,198,266,ngx_http_secure_link_old_variable,,,21,"ngx_int_t ngx_http_secure_link_old_variable (ngx_http_request_t*,ngx_http_secure_link_conf_t*,ngx_http_variable_value_t*,uintptr_t)"
214777,METHOD,http\modules\ngx_http_secure_link_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_secure_link_expires_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    ngx_http_secure_link_ctx_t  *ctx;

    ctx = ngx_http_get_module_ctx(r, ngx_http_secure_link_module);

    if (ctx) {
        v->len = ctx->expires.len;
        v->valid = 1;
        v->no_cacheable = 0;
        v->not_found = 0;
        v->data = ctx->expires.data;

    } else {
        v->not_found = 1;
    }

    return NGX_OK;
}",1,1,http\modules\ngx_http_secure_link_module.c,ngx_http_secure_link_expires_variable,,false,269,289,ngx_http_secure_link_expires_variable,,,22,"ngx_int_t ngx_http_secure_link_expires_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
214835,METHOD,http\modules\ngx_http_secure_link_module.c:<global>,TYPE_DECL,"static void *
ngx_http_secure_link_create_conf(ngx_conf_t *cf)
{
    ngx_http_secure_link_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_secure_link_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     conf->variable = NULL;
     *     conf->md5 = NULL;
     *     conf->secret = { 0, NULL };
     */

    return conf;
}",1,1,http\modules\ngx_http_secure_link_module.c,ngx_http_secure_link_create_conf,,false,292,311,ngx_http_secure_link_create_conf,,,23,void* ngx_http_secure_link_create_conf (ngx_conf_t*)
214858,METHOD,http\modules\ngx_http_secure_link_module.c:<global>,TYPE_DECL,"static char *
ngx_http_secure_link_merge_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_secure_link_conf_t *prev = parent;
    ngx_http_secure_link_conf_t *conf = child;

    if (conf->secret.data) {
        if (conf->variable || conf->md5) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               ""\""secure_link_secret\"" cannot be mixed with ""
                               ""\""secure_link\"" and \""secure_link_md5\"""");
            return NGX_CONF_ERROR;
        }

        return NGX_CONF_OK;
    }

    if (conf->variable == NULL) {
        conf->variable = prev->variable;
    }

    if (conf->md5 == NULL) {
        conf->md5 = prev->md5;
    }

    if (conf->variable == NULL && conf->md5 == NULL) {
        conf->secret = prev->secret;
    }

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_secure_link_module.c,ngx_http_secure_link_merge_conf,,false,314,344,ngx_http_secure_link_merge_conf,,,24,"char* ngx_http_secure_link_merge_conf (ngx_conf_t*,void*,void*)"
214948,METHOD,http\modules\ngx_http_secure_link_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_secure_link_add_variables(ngx_conf_t *cf)
{
    ngx_http_variable_t  *var;

    var = ngx_http_add_variable(cf, &ngx_http_secure_link_name, 0);
    if (var == NULL) {
        return NGX_ERROR;
    }

    var->get_handler = ngx_http_secure_link_variable;

    var = ngx_http_add_variable(cf, &ngx_http_secure_link_expires_name, 0);
    if (var == NULL) {
        return NGX_ERROR;
    }

    var->get_handler = ngx_http_secure_link_expires_variable;

    return NGX_OK;
}",1,1,http\modules\ngx_http_secure_link_module.c,ngx_http_secure_link_add_variables,,false,347,367,ngx_http_secure_link_add_variables,,,25,ngx_int_t ngx_http_secure_link_add_variables (ngx_conf_t*)
215003,METHOD,http\modules\ngx_http_slice_filter_module.c:<global>,TYPE_DECL,<global>,1,1,http\modules\ngx_http_slice_filter_module.c,http\modules\ngx_http_slice_filter_module.c:<global>,,false,1,545,<global>,,,1,
215022,METHOD,http\modules\ngx_http_slice_filter_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_slice_header_filter(ngx_http_request_t *r);,18,68,http\modules\ngx_http_slice_filter_module.c,ngx_http_slice_header_filter,,false,36,36,ngx_http_slice_header_filter,,,7,ngx_int_t ngx_http_slice_header_filter (ngx_http_request_t*)
215027,METHOD,http\modules\ngx_http_slice_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_slice_body_filter(ngx_http_request_t *r,
    ngx_chain_t *in);",18,20,http\modules\ngx_http_slice_filter_module.c,ngx_http_slice_body_filter,,false,37,38,ngx_http_slice_body_filter,,,8,"ngx_int_t ngx_http_slice_body_filter (ngx_http_request_t*,ngx_chain_t*)"
215033,METHOD,http\modules\ngx_http_slice_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_slice_parse_content_range(ngx_http_request_t *r,
    ngx_http_slice_content_range_t *cr);",18,39,http\modules\ngx_http_slice_filter_module.c,ngx_http_slice_parse_content_range,,false,39,40,ngx_http_slice_parse_content_range,,,9,"ngx_int_t ngx_http_slice_parse_content_range (ngx_http_request_t*,ngx_http_slice_content_range_t*)"
215039,METHOD,http\modules\ngx_http_slice_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_slice_range_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\modules\ngx_http_slice_filter_module.c,ngx_http_slice_range_variable,,false,41,42,ngx_http_slice_range_variable,,,10,"ngx_int_t ngx_http_slice_range_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
215046,METHOD,http\modules\ngx_http_slice_filter_module.c:<global>,TYPE_DECL,static off_t ngx_http_slice_get_start(ngx_http_request_t *r);,14,60,http\modules\ngx_http_slice_filter_module.c,ngx_http_slice_get_start,,false,43,43,ngx_http_slice_get_start,,,11,off_t ngx_http_slice_get_start (ngx_http_request_t*)
215051,METHOD,http\modules\ngx_http_slice_filter_module.c:<global>,TYPE_DECL,static void *ngx_http_slice_create_loc_conf(ngx_conf_t *cf);,13,59,http\modules\ngx_http_slice_filter_module.c,ngx_http_slice_create_loc_conf,,false,44,44,ngx_http_slice_create_loc_conf,,,12,void* ngx_http_slice_create_loc_conf (ngx_conf_t*)
215056,METHOD,http\modules\ngx_http_slice_filter_module.c:<global>,TYPE_DECL,"static char *ngx_http_slice_merge_loc_conf(ngx_conf_t *cf, void *parent,
    void *child);",13,16,http\modules\ngx_http_slice_filter_module.c,ngx_http_slice_merge_loc_conf,,false,45,46,ngx_http_slice_merge_loc_conf,,,13,"char* ngx_http_slice_merge_loc_conf (ngx_conf_t*,void*,void*)"
215063,METHOD,http\modules\ngx_http_slice_filter_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_slice_add_variables(ngx_conf_t *cf);,18,61,http\modules\ngx_http_slice_filter_module.c,ngx_http_slice_add_variables,,false,47,47,ngx_http_slice_add_variables,,,14,ngx_int_t ngx_http_slice_add_variables (ngx_conf_t*)
215068,METHOD,http\modules\ngx_http_slice_filter_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_slice_init(ngx_conf_t *cf);,18,52,http\modules\ngx_http_slice_filter_module.c,ngx_http_slice_init,,false,48,48,ngx_http_slice_init,,,15,ngx_int_t ngx_http_slice_init (ngx_conf_t*)
215130,METHOD,http\modules\ngx_http_slice_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_slice_header_filter(ngx_http_request_t *r)
{
    off_t                            end;
    ngx_int_t                        rc;
    ngx_table_elt_t                 *h;
    ngx_http_slice_ctx_t            *ctx;
    ngx_http_slice_loc_conf_t       *slcf;
    ngx_http_slice_content_range_t   cr;

    ctx = ngx_http_get_module_ctx(r, ngx_http_slice_filter_module);
    if (ctx == NULL) {
        return ngx_http_next_header_filter(r);
    }

    if (r->headers_out.status != NGX_HTTP_PARTIAL_CONTENT) {
        if (r == r->main) {
            ngx_http_set_ctx(r, NULL, ngx_http_slice_filter_module);
            return ngx_http_next_header_filter(r);
        }

        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                      ""unexpected status code %ui in slice response"",
                      r->headers_out.status);
        return NGX_ERROR;
    }

    h = r->headers_out.etag;

    if (ctx->etag.len) {
        if (h == NULL
            || h->value.len...",1,1,http\modules\ngx_http_slice_filter_module.c,ngx_http_slice_header_filter,,false,101,209,ngx_http_slice_header_filter,,,26,ngx_int_t ngx_http_slice_header_filter (ngx_http_request_t*)
215534,METHOD,http\modules\ngx_http_slice_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_slice_body_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    ngx_int_t                   rc;
    ngx_chain_t                *cl;
    ngx_http_slice_ctx_t       *ctx;
    ngx_http_slice_loc_conf_t  *slcf;

    ctx = ngx_http_get_module_ctx(r, ngx_http_slice_filter_module);

    if (ctx == NULL || r != r->main) {
        return ngx_http_next_body_filter(r, in);
    }

    for (cl = in; cl; cl = cl->next) {
        if (cl->buf->last_buf) {
            cl->buf->last_buf = 0;
            cl->buf->last_in_chain = 1;
            cl->buf->sync = 1;
            ctx->last = 1;
        }
    }

    rc = ngx_http_next_body_filter(r, in);

    if (rc == NGX_ERROR || !ctx->last) {
        return rc;
    }

    if (ctx->sr && !ctx->sr->done) {
        return rc;
    }

    if (!ctx->active) {
        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                      ""missing slice response"");
        return NGX_ERROR;
    }

    if (ctx->start >= ctx->end) {
     ...",1,1,http\modules\ngx_http_slice_filter_module.c,ngx_http_slice_body_filter,,false,212,282,ngx_http_slice_body_filter,,,27,"ngx_int_t ngx_http_slice_body_filter (ngx_http_request_t*,ngx_chain_t*)"
215768,METHOD,http\modules\ngx_http_slice_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_slice_parse_content_range(ngx_http_request_t *r,
    ngx_http_slice_content_range_t *cr)
{
    off_t             start, end, complete_length, cutoff, cutlim;
    u_char           *p;
    ngx_table_elt_t  *h;

    h = r->headers_out.content_range;

    if (h == NULL
        || h->value.len < 7
        || ngx_strncmp(h->value.data, ""bytes "", 6) != 0)
    {
        return NGX_ERROR;
    }

    p = h->value.data + 6;

    cutoff = NGX_MAX_OFF_T_VALUE / 10;
    cutlim = NGX_MAX_OFF_T_VALUE % 10;

    start = 0;
    end = 0;
    complete_length = 0;

    while (*p == ' ') { p++; }

    if (*p < '0' || *p > '9') {
        return NGX_ERROR;
    }

    while (*p >= '0' && *p <= '9') {
        if (start >= cutoff && (start > cutoff || *p - '0' > cutlim)) {
            return NGX_ERROR;
        }

        start = start * 10 + (*p++ - '0');
    }

    while (*p == ' ') { p++; }

    if (*p++ != '-') {
        return NGX_ERROR;
    }

    while (*p == ' ') { p++; }

   ...",1,1,http\modules\ngx_http_slice_filter_module.c,ngx_http_slice_parse_content_range,,false,285,386,ngx_http_slice_parse_content_range,,,28,"ngx_int_t ngx_http_slice_parse_content_range (ngx_http_request_t*,ngx_http_slice_content_range_t*)"
216108,METHOD,http\modules\ngx_http_slice_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_slice_range_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    u_char                     *p;
    ngx_http_slice_ctx_t       *ctx;
    ngx_http_slice_loc_conf_t  *slcf;

    ctx = ngx_http_get_module_ctx(r, ngx_http_slice_filter_module);

    if (ctx == NULL) {
        if (r != r->main || r->headers_out.status) {
            v->not_found = 1;
            return NGX_OK;
        }

        slcf = ngx_http_get_module_loc_conf(r, ngx_http_slice_filter_module);

        if (slcf->size == 0) {
            v->not_found = 1;
            return NGX_OK;
        }

        ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_slice_ctx_t));
        if (ctx == NULL) {
            return NGX_ERROR;
        }

        ngx_http_set_ctx(r, ctx, ngx_http_slice_filter_module);

        p = ngx_pnalloc(r->pool, sizeof(""bytes=-"") - 1 + 2 * NGX_OFF_T_LEN);
        if (p == NULL) {
            return NGX_ERROR;
        }

        ctx->start = slcf->size...",1,1,http\modules\ngx_http_slice_filter_module.c,ngx_http_slice_range_variable,,false,389,439,ngx_http_slice_range_variable,,,29,"ngx_int_t ngx_http_slice_range_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
216288,METHOD,http\modules\ngx_http_slice_filter_module.c:<global>,TYPE_DECL,"static off_t
ngx_http_slice_get_start(ngx_http_request_t *r)
{
    off_t             start, cutoff, cutlim;
    u_char           *p;
    ngx_table_elt_t  *h;

    if (r->headers_in.if_range) {
        return 0;
    }

    h = r->headers_in.range;

    if (h == NULL
        || h->value.len < 7
        || ngx_strncasecmp(h->value.data, (u_char *) ""bytes="", 6) != 0)
    {
        return 0;
    }

    p = h->value.data + 6;

    if (ngx_strchr(p, ',')) {
        return 0;
    }

    while (*p == ' ') { p++; }

    if (*p == '-') {
        return 0;
    }

    cutoff = NGX_MAX_OFF_T_VALUE / 10;
    cutlim = NGX_MAX_OFF_T_VALUE % 10;

    start = 0;

    while (*p >= '0' && *p <= '9') {
        if (start >= cutoff && (start > cutoff || *p - '0' > cutlim)) {
            return 0;
        }

        start = start * 10 + (*p++ - '0');
    }

    return start;
}",1,1,http\modules\ngx_http_slice_filter_module.c,ngx_http_slice_get_start,,false,442,488,ngx_http_slice_get_start,,,30,off_t ngx_http_slice_get_start (ngx_http_request_t*)
216429,METHOD,http\modules\ngx_http_slice_filter_module.c:<global>,TYPE_DECL,"static void *
ngx_http_slice_create_loc_conf(ngx_conf_t *cf)
{
    ngx_http_slice_loc_conf_t  *slcf;

    slcf = ngx_palloc(cf->pool, sizeof(ngx_http_slice_loc_conf_t));
    if (slcf == NULL) {
        return NULL;
    }

    slcf->size = NGX_CONF_UNSET_SIZE;

    return slcf;
}",1,1,http\modules\ngx_http_slice_filter_module.c,ngx_http_slice_create_loc_conf,,false,491,504,ngx_http_slice_create_loc_conf,,,31,void* ngx_http_slice_create_loc_conf (ngx_conf_t*)
216457,METHOD,http\modules\ngx_http_slice_filter_module.c:<global>,TYPE_DECL,"static char *
ngx_http_slice_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_slice_loc_conf_t *prev = parent;
    ngx_http_slice_loc_conf_t *conf = child;

    ngx_conf_merge_size_value(conf->size, prev->size, 0);

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_slice_filter_module.c,ngx_http_slice_merge_loc_conf,,false,507,516,ngx_http_slice_merge_loc_conf,,,32,"char* ngx_http_slice_merge_loc_conf (ngx_conf_t*,void*,void*)"
216482,METHOD,http\modules\ngx_http_slice_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_slice_add_variables(ngx_conf_t *cf)
{
    ngx_http_variable_t  *var;

    var = ngx_http_add_variable(cf, &ngx_http_slice_range_name, 0);
    if (var == NULL) {
        return NGX_ERROR;
    }

    var->get_handler = ngx_http_slice_range_variable;

    return NGX_OK;
}",1,1,http\modules\ngx_http_slice_filter_module.c,ngx_http_slice_add_variables,,false,519,532,ngx_http_slice_add_variables,,,33,ngx_int_t ngx_http_slice_add_variables (ngx_conf_t*)
216509,METHOD,http\modules\ngx_http_slice_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_slice_init(ngx_conf_t *cf)
{
    ngx_http_next_header_filter = ngx_http_top_header_filter;
    ngx_http_top_header_filter = ngx_http_slice_header_filter;

    ngx_http_next_body_filter = ngx_http_top_body_filter;
    ngx_http_top_body_filter = ngx_http_slice_body_filter;

    return NGX_OK;
}",1,1,http\modules\ngx_http_slice_filter_module.c,ngx_http_slice_init,,false,535,545,ngx_http_slice_init,,,34,ngx_int_t ngx_http_slice_init (ngx_conf_t*)
216537,METHOD,http\modules\ngx_http_split_clients_module.c:<global>,TYPE_DECL,<global>,1,1,http\modules\ngx_http_split_clients_module.c,http\modules\ngx_http_split_clients_module.c:<global>,,false,1,246,<global>,,,1,
216547,METHOD,http\modules\ngx_http_split_clients_module.c:<global>,TYPE_DECL,"static char *ngx_conf_split_clients_block(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_split_clients_module.c,ngx_conf_split_clients_block,,false,25,26,ngx_conf_split_clients_block,,,5,"char* ngx_conf_split_clients_block (ngx_conf_t*,ngx_command_t*,void*)"
216554,METHOD,http\modules\ngx_http_split_clients_module.c:<global>,TYPE_DECL,"static char *ngx_http_split_clients(ngx_conf_t *cf, ngx_command_t *dummy,
    void *conf);",13,15,http\modules\ngx_http_split_clients_module.c,ngx_http_split_clients,,false,27,28,ngx_http_split_clients,,,6,"char* ngx_http_split_clients (ngx_conf_t*,ngx_command_t*,void*)"
216607,METHOD,http\modules\ngx_http_split_clients_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_split_clients_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    ngx_http_split_clients_ctx_t *ctx = (ngx_http_split_clients_ctx_t *) data;

    uint32_t                        hash;
    ngx_str_t                       val;
    ngx_uint_t                      i;
    ngx_http_split_clients_part_t  *part;

    *v = ngx_http_variable_null_value;

    if (ngx_http_complex_value(r, &ctx->value, &val) != NGX_OK) {
        return NGX_OK;
    }

    hash = ngx_murmur_hash2(val.data, val.len);

    part = ctx->parts.elts;

    for (i = 0; i < ctx->parts.nelts; i++) {

        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                       ""http split: %uD %uD"", hash, part[i].percent);

        if (hash < part[i].percent || part[i].percent == 0) {
            *v = part[i].value;
            return NGX_OK;
        }
    }

    return NGX_OK;
}",1,1,http\modules\ngx_http_split_clients_module.c,ngx_http_split_clients_variable,,false,74,107,ngx_http_split_clients_variable,,,13,"ngx_int_t ngx_http_split_clients_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
216717,METHOD,http\modules\ngx_http_split_clients_module.c:<global>,TYPE_DECL,"static char *
ngx_conf_split_clients_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char                                *rv;
    uint32_t                             sum, last;
    ngx_str_t                           *value, name;
    ngx_uint_t                           i;
    ngx_conf_t                           save;
    ngx_http_variable_t                 *var;
    ngx_http_split_clients_ctx_t        *ctx;
    ngx_http_split_clients_part_t       *part;
    ngx_http_compile_complex_value_t     ccv;

    ctx = ngx_pcalloc(cf->pool, sizeof(ngx_http_split_clients_ctx_t));
    if (ctx == NULL) {
        return NGX_CONF_ERROR;
    }

    value = cf->args->elts;

    ngx_memzero(&ccv, sizeof(ngx_http_compile_complex_value_t));

    ccv.cf = cf;
    ccv.value = &value[1];
    ccv.complex_value = &ctx->value;

    if (ngx_http_compile_complex_value(&ccv) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    name = value[2];

    if (name.data[0] != '$') {
        ngx_conf_l...",1,1,http\modules\ngx_http_split_clients_module.c,ngx_conf_split_clients_block,,false,110,198,ngx_conf_split_clients_block,,,14,"char* ngx_conf_split_clients_block (ngx_conf_t*,ngx_command_t*,void*)"
216986,METHOD,http\modules\ngx_http_split_clients_module.c:<global>,TYPE_DECL,"static char *
ngx_http_split_clients(ngx_conf_t *cf, ngx_command_t *dummy, void *conf)
{
    ngx_int_t                       n;
    ngx_str_t                      *value;
    ngx_http_split_clients_ctx_t   *ctx;
    ngx_http_split_clients_part_t  *part;

    ctx = cf->ctx;
    value = cf->args->elts;

    part = ngx_array_push(&ctx->parts);
    if (part == NULL) {
        return NGX_CONF_ERROR;
    }

    if (value[0].len == 1 && value[0].data[0] == '*') {
        part->percent = 0;

    } else {
        if (value[0].len == 0 || value[0].data[value[0].len - 1] != '%') {
            goto invalid;
        }

        n = ngx_atofp(value[0].data, value[0].len - 1, 2);
        if (n == NGX_ERROR || n == 0) {
            goto invalid;
        }

        part->percent = (uint32_t) n;
    }

    part->value.len = value[1].len;
    part->value.valid = 1;
    part->value.no_cacheable = 0;
    part->value.not_found = 0;
    part->value.data = value[1].data;

    return NGX_CONF_OK;

invalid:

...",1,1,http\modules\ngx_http_split_clients_module.c,ngx_http_split_clients,,false,201,246,ngx_http_split_clients,,,15,"char* ngx_http_split_clients (ngx_conf_t*,ngx_command_t*,void*)"
217174,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,<global>,1,29,http\modules\ngx_http_ssi_filter_module.c,http\modules\ngx_http_ssi_filter_module.c:<global>,,false,1,2933,<global>,,,1,
217217,METHOD,<empty>,<empty>,<empty>,1,,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_state_e:<clinit>,,false,49,,<clinit>,,,21,
217225,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_ssi_output(ngx_http_request_t *r,
    ngx_http_ssi_ctx_t *ctx);",18,28,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_output,,false,73,74,ngx_http_ssi_output,,,9,"ngx_int_t ngx_http_ssi_output (ngx_http_request_t*,ngx_http_ssi_ctx_t*)"
217231,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static void ngx_http_ssi_buffered(ngx_http_request_t *r,
    ngx_http_ssi_ctx_t *ctx);",13,28,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_buffered,,false,75,76,ngx_http_ssi_buffered,,,10,"void ngx_http_ssi_buffered (ngx_http_request_t*,ngx_http_ssi_ctx_t*)"
217237,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_ssi_parse(ngx_http_request_t *r,
    ngx_http_ssi_ctx_t *ctx);",18,28,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_parse,,false,77,78,ngx_http_ssi_parse,,,11,"ngx_int_t ngx_http_ssi_parse (ngx_http_request_t*,ngx_http_ssi_ctx_t*)"
217243,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static ngx_str_t *ngx_http_ssi_get_variable(ngx_http_request_t *r,
    ngx_str_t *name, ngx_uint_t key);",18,36,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_get_variable,,false,79,80,ngx_http_ssi_get_variable,,,12,"ngx_str_t* ngx_http_ssi_get_variable (ngx_http_request_t*,ngx_str_t*,ngx_uint_t)"
217250,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_ssi_evaluate_string(ngx_http_request_t *r,
    ngx_http_ssi_ctx_t *ctx, ngx_str_t *text, ngx_uint_t flags);",18,63,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_evaluate_string,,false,81,82,ngx_http_ssi_evaluate_string,,,13,"ngx_int_t ngx_http_ssi_evaluate_string (ngx_http_request_t*,ngx_http_ssi_ctx_t*,ngx_str_t*,ngx_uint_t)"
217258,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_ssi_regex_match(ngx_http_request_t *r,
    ngx_str_t *pattern, ngx_str_t *str);",18,39,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_regex_match,,false,83,84,ngx_http_ssi_regex_match,,,14,"ngx_int_t ngx_http_ssi_regex_match (ngx_http_request_t*,ngx_str_t*,ngx_str_t*)"
217265,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_ssi_include(ngx_http_request_t *r,
    ngx_http_ssi_ctx_t *ctx, ngx_str_t **params);",18,48,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_include,,false,86,87,ngx_http_ssi_include,,,15,"ngx_int_t ngx_http_ssi_include (ngx_http_request_t*,ngx_http_ssi_ctx_t*,ngx_str_t**)"
217272,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_ssi_stub_output(ngx_http_request_t *r, void *data,
    ngx_int_t rc);",18,17,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_stub_output,,false,88,89,ngx_http_ssi_stub_output,,,16,"ngx_int_t ngx_http_ssi_stub_output (ngx_http_request_t*,void*,ngx_int_t)"
217279,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_ssi_set_variable(ngx_http_request_t *r, void *data,
    ngx_int_t rc);",18,17,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_set_variable,,false,90,91,ngx_http_ssi_set_variable,,,17,"ngx_int_t ngx_http_ssi_set_variable (ngx_http_request_t*,void*,ngx_int_t)"
217286,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_ssi_echo(ngx_http_request_t *r,
    ngx_http_ssi_ctx_t *ctx, ngx_str_t **params);",18,48,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_echo,,false,92,93,ngx_http_ssi_echo,,,18,"ngx_int_t ngx_http_ssi_echo (ngx_http_request_t*,ngx_http_ssi_ctx_t*,ngx_str_t**)"
217293,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_ssi_config(ngx_http_request_t *r,
    ngx_http_ssi_ctx_t *ctx, ngx_str_t **params);",18,48,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_config,,false,94,95,ngx_http_ssi_config,,,19,"ngx_int_t ngx_http_ssi_config (ngx_http_request_t*,ngx_http_ssi_ctx_t*,ngx_str_t**)"
217300,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_ssi_set(ngx_http_request_t *r,
    ngx_http_ssi_ctx_t *ctx, ngx_str_t **params);",18,48,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_set,,false,96,97,ngx_http_ssi_set,,,20,"ngx_int_t ngx_http_ssi_set (ngx_http_request_t*,ngx_http_ssi_ctx_t*,ngx_str_t**)"
217307,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_ssi_if(ngx_http_request_t *r,
    ngx_http_ssi_ctx_t *ctx, ngx_str_t **params);",18,48,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_if,,false,98,99,ngx_http_ssi_if,,,21,"ngx_int_t ngx_http_ssi_if (ngx_http_request_t*,ngx_http_ssi_ctx_t*,ngx_str_t**)"
217314,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_ssi_else(ngx_http_request_t *r,
    ngx_http_ssi_ctx_t *ctx, ngx_str_t **params);",18,48,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_else,,false,100,101,ngx_http_ssi_else,,,22,"ngx_int_t ngx_http_ssi_else (ngx_http_request_t*,ngx_http_ssi_ctx_t*,ngx_str_t**)"
217321,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_ssi_endif(ngx_http_request_t *r,
    ngx_http_ssi_ctx_t *ctx, ngx_str_t **params);",18,48,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_endif,,false,102,103,ngx_http_ssi_endif,,,23,"ngx_int_t ngx_http_ssi_endif (ngx_http_request_t*,ngx_http_ssi_ctx_t*,ngx_str_t**)"
217328,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_ssi_block(ngx_http_request_t *r,
    ngx_http_ssi_ctx_t *ctx, ngx_str_t **params);",18,48,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_block,,false,104,105,ngx_http_ssi_block,,,24,"ngx_int_t ngx_http_ssi_block (ngx_http_request_t*,ngx_http_ssi_ctx_t*,ngx_str_t**)"
217335,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_ssi_endblock(ngx_http_request_t *r,
    ngx_http_ssi_ctx_t *ctx, ngx_str_t **params);",18,48,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_endblock,,false,106,107,ngx_http_ssi_endblock,,,25,"ngx_int_t ngx_http_ssi_endblock (ngx_http_request_t*,ngx_http_ssi_ctx_t*,ngx_str_t**)"
217342,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_ssi_date_gmt_local_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t gmt);",18,48,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_date_gmt_local_variable,,false,109,110,ngx_http_ssi_date_gmt_local_variable,,,26,"ngx_int_t ngx_http_ssi_date_gmt_local_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
217349,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_ssi_preconfiguration(ngx_conf_t *cf);,18,62,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_preconfiguration,,false,112,112,ngx_http_ssi_preconfiguration,,,27,ngx_int_t ngx_http_ssi_preconfiguration (ngx_conf_t*)
217354,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,static void *ngx_http_ssi_create_main_conf(ngx_conf_t *cf);,13,58,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_create_main_conf,,false,113,113,ngx_http_ssi_create_main_conf,,,28,void* ngx_http_ssi_create_main_conf (ngx_conf_t*)
217359,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static char *ngx_http_ssi_init_main_conf(ngx_conf_t *cf, void *conf);",13,68,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_init_main_conf,,false,114,114,ngx_http_ssi_init_main_conf,,,29,"char* ngx_http_ssi_init_main_conf (ngx_conf_t*,void*)"
217365,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,static void *ngx_http_ssi_create_loc_conf(ngx_conf_t *cf);,13,57,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_create_loc_conf,,false,115,115,ngx_http_ssi_create_loc_conf,,,30,void* ngx_http_ssi_create_loc_conf (ngx_conf_t*)
217370,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static char *ngx_http_ssi_merge_loc_conf(ngx_conf_t *cf,
    void *parent, void *child);",13,30,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_merge_loc_conf,,false,116,117,ngx_http_ssi_merge_loc_conf,,,31,"char* ngx_http_ssi_merge_loc_conf (ngx_conf_t*,void*,void*)"
217377,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_ssi_filter_init(ngx_conf_t *cf);,18,57,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_filter_init,,false,118,118,ngx_http_ssi_filter_init,,,32,ngx_int_t ngx_http_ssi_filter_init (ngx_conf_t*)
217840,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_ssi_header_filter(ngx_http_request_t *r)
{
    ngx_http_ssi_ctx_t       *ctx;
    ngx_http_ssi_loc_conf_t  *slcf;

    slcf = ngx_http_get_module_loc_conf(r, ngx_http_ssi_filter_module);

    if (!slcf->enable
        || r->headers_out.content_length_n == 0
        || ngx_http_test_content_type(r, &slcf->types) == NULL)
    {
        return ngx_http_next_header_filter(r);
    }

    ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_ssi_ctx_t));
    if (ctx == NULL) {
        return NGX_ERROR;
    }

    ngx_http_set_ctx(r, ctx, ngx_http_ssi_filter_module);


    ctx->value_len = slcf->value_len;
    ctx->last_out = &ctx->out;

    ctx->encoding = NGX_HTTP_SSI_ENTITY_ENCODING;
    ctx->output = 1;

    ctx->params.elts = ctx->params_array;
    ctx->params.size = sizeof(ngx_table_elt_t);
    ctx->params.nalloc = NGX_HTTP_SSI_PARAMS_N;
    ctx->params.pool = r->pool;

    ctx->timefmt = ngx_http_ssi_timefmt;
    ngx_str_set(&ctx->errmsg,
                ""[an error oc...",1,1,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_header_filter,,false,329,385,ngx_http_ssi_header_filter,,,67,ngx_int_t ngx_http_ssi_header_filter (ngx_http_request_t*)
218004,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_ssi_body_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    size_t                     len;
    ngx_int_t                  rc;
    ngx_buf_t                 *b;
    ngx_uint_t                 i, index;
    ngx_chain_t               *cl, **ll;
    ngx_table_elt_t           *param;
    ngx_http_ssi_ctx_t        *ctx, *mctx;
    ngx_http_ssi_block_t      *bl;
    ngx_http_ssi_param_t      *prm;
    ngx_http_ssi_command_t    *cmd;
    ngx_http_ssi_loc_conf_t   *slcf;
    ngx_http_ssi_main_conf_t  *smcf;
    ngx_str_t                 *params[NGX_HTTP_SSI_MAX_PARAMS + 1];

    ctx = ngx_http_get_module_ctx(r, ngx_http_ssi_filter_module);

    if (ctx == NULL
        || (in == NULL
            && ctx->buf == NULL
            && ctx->in == NULL
            && ctx->busy == NULL))
    {
        return ngx_http_next_body_filter(r, in);
    }

    /* add the incoming chain to the chain ctx->in */

    if (in) {
        if (ngx_chain_add_copy(r->pool, &ctx->in, in) !=...",1,1,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_body_filter,,false,388,911,ngx_http_ssi_body_filter,,,68,"ngx_int_t ngx_http_ssi_body_filter (ngx_http_request_t*,ngx_chain_t*)"
219829,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_ssi_output(ngx_http_request_t *r, ngx_http_ssi_ctx_t *ctx)
{
    ngx_int_t     rc;
    ngx_buf_t    *b;
    ngx_chain_t  *cl;

#if 1
    b = NULL;
    for (cl = ctx->out; cl; cl = cl->next) {
        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                       ""ssi out: %p %p"", cl->buf, cl->buf->pos);
        if (cl->buf == b) {
            ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,
                          ""the same buf was used in ssi"");
            ngx_debug_point();
            return NGX_ERROR;
        }
        b = cl->buf;
    }
#endif

    rc = ngx_http_next_body_filter(r, ctx->out);

    if (ctx->busy == NULL) {
        ctx->busy = ctx->out;

    } else {
        for (cl = ctx->busy; cl->next; cl = cl->next) { /* void */ }
        cl->next = ctx->out;
    }

    ctx->out = NULL;
    ctx->last_out = &ctx->out;

    while (ctx->busy) {

        cl = ctx->busy;
        b = cl->buf;

        if (ngx_buf_size(b) != 0) {
   ...",1,1,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_output,,false,914,975,ngx_http_ssi_output,,,69,"ngx_int_t ngx_http_ssi_output (ngx_http_request_t*,ngx_http_ssi_ctx_t*)"
220025,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static void
ngx_http_ssi_buffered(ngx_http_request_t *r, ngx_http_ssi_ctx_t *ctx)
{
    if (ctx->in || ctx->buf) {
        r->buffered |= NGX_HTTP_SSI_BUFFERED;

    } else {
        r->buffered &= ~NGX_HTTP_SSI_BUFFERED;
    }
}",1,1,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_buffered,,false,978,987,ngx_http_ssi_buffered,,,70,"void ngx_http_ssi_buffered (ngx_http_request_t*,ngx_http_ssi_ctx_t*)"
220053,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_ssi_parse(ngx_http_request_t *r, ngx_http_ssi_ctx_t *ctx)
{
    u_char                *p, *value, *last, *copy_end, ch;
    size_t                 looked;
    ngx_http_ssi_state_e   state;

    state = ctx->state;
    looked = ctx->looked;
    last = ctx->buf->last;
    copy_end = ctx->copy_end;

    for (p = ctx->pos; p < last; p++) {

        ch = *p;

        if (state == ssi_start_state) {

            /* the tight loop */

            for ( ;; ) {
                if (ch == '<') {
                    copy_end = p;
                    looked = 1;
                    state = ssi_tag_state;

                    goto tag_started;
                }

                if (++p == last) {
                    break;
                }

                ch = *p;
            }

            ctx->state = state;
            ctx->pos = p;
            ctx->looked = looked;
            ctx->copy_end = p;

            if (ctx->copy_start == NULL) {
                ctx->copy_...",1,23,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_parse,,false,990,1552,ngx_http_ssi_parse,,,71,"ngx_int_t ngx_http_ssi_parse (ngx_http_request_t*,ngx_http_ssi_ctx_t*)"
221478,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static ngx_str_t *
ngx_http_ssi_get_variable(ngx_http_request_t *r, ngx_str_t *name,
    ngx_uint_t key)
{
    ngx_uint_t           i;
    ngx_list_part_t     *part;
    ngx_http_ssi_var_t  *var;
    ngx_http_ssi_ctx_t  *ctx;

    ctx = ngx_http_get_module_ctx(r->main, ngx_http_ssi_filter_module);

#if (NGX_PCRE)
    {
    ngx_str_t  *value;

    if (key >= '0' && key <= '9') {
        i = key - '0';

        if (i < ctx->ncaptures) {
            value = ngx_palloc(r->pool, sizeof(ngx_str_t));
            if (value == NULL) {
                return NULL;
            }

            i *= 2;

            value->data = ctx->captures_data + ctx->captures[i];
            value->len = ctx->captures[i + 1] - ctx->captures[i];

            return value;
        }
    }
    }
#endif

    if (ctx->variables == NULL) {
        return NULL;
    }

    part = &ctx->variables->part;
    var = part->elts;

    for (i = 0; /* void */ ; i++) {

        if (i >= part->nelts) {
            if (part->ne...",1,1,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_get_variable,,false,1555,1623,ngx_http_ssi_get_variable,,,72,"ngx_str_t ngx_http_ssi_get_variable (ngx_http_request_t*,ngx_str_t*,ngx_uint_t)"
221605,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_ssi_evaluate_string(ngx_http_request_t *r, ngx_http_ssi_ctx_t *ctx,
    ngx_str_t *text, ngx_uint_t flags)
{
    u_char                      ch, *p, **value, *data, *part_data;
    size_t                     *size, len, prefix, part_len;
    ngx_str_t                   var, *val;
    ngx_uint_t                  i, n, bracket, quoted, key;
    ngx_array_t                 lengths, values;
    ngx_http_variable_value_t  *vv;

    n = ngx_http_script_variables_count(text);

    if (n == 0) {

        data = text->data;
        p = data;

        if ((flags & NGX_HTTP_SSI_ADD_PREFIX) && text->data[0] != '/') {

            for (prefix = r->uri.len; prefix; prefix--) {
                if (r->uri.data[prefix - 1] == '/') {
                    break;
                }
            }

            if (prefix) {
                len = prefix + text->len;

                data = ngx_pnalloc(r->pool, len);
                if (data == NULL) {
                    return NGX...",1,21,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_evaluate_string,,false,1626,1874,ngx_http_ssi_evaluate_string,,,73,"ngx_int_t ngx_http_ssi_evaluate_string (ngx_http_request_t*,ngx_http_ssi_ctx_t*,ngx_str_t*,ngx_uint_t)"
222363,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_ssi_regex_match(ngx_http_request_t *r, ngx_str_t *pattern,
    ngx_str_t *str)
{
#if (NGX_PCRE)
    int                   rc, *captures;
    u_char               *p, errstr[NGX_MAX_CONF_ERRSTR];
    size_t                size;
    ngx_str_t            *vv, name, value;
    ngx_uint_t            i, n, key;
    ngx_http_ssi_ctx_t   *ctx;
    ngx_http_ssi_var_t   *var;
    ngx_regex_compile_t   rgc;

    ngx_memzero(&rgc, sizeof(ngx_regex_compile_t));

    rgc.pattern = *pattern;
    rgc.pool = r->pool;
    rgc.err.len = NGX_MAX_CONF_ERRSTR;
    rgc.err.data = errstr;

    if (ngx_regex_compile(&rgc) != NGX_OK) {
        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0, ""%V"", &rgc.err);
        return NGX_HTTP_SSI_ERROR;
    }

    n = (rgc.captures + 1) * 3;

    captures = ngx_palloc(r->pool, n * sizeof(int));
    if (captures == NULL) {
        return NGX_ERROR;
    }

    rc = ngx_regex_exec(rgc.regex, str, captures, n);

    if (rc < NGX_REGEX_NO_MATCHED)...",1,11,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_regex_match,,false,1877,1982,ngx_http_ssi_regex_match,,,74,"ngx_int_t ngx_http_ssi_regex_match (ngx_http_request_t*,ngx_str_t*,ngx_str_t*)"
222384,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_ssi_include(ngx_http_request_t *r, ngx_http_ssi_ctx_t *ctx,
    ngx_str_t **params)
{
    ngx_int_t                    rc;
    ngx_str_t                   *uri, *file, *wait, *set, *stub, args;
    ngx_buf_t                   *b;
    ngx_uint_t                   flags, i, key;
    ngx_chain_t                 *cl, *tl, **ll, *out;
    ngx_http_request_t          *sr;
    ngx_http_ssi_var_t          *var;
    ngx_http_ssi_ctx_t          *mctx;
    ngx_http_ssi_block_t        *bl;
    ngx_http_post_subrequest_t  *psr;

    uri = params[NGX_HTTP_SSI_INCLUDE_VIRTUAL];
    file = params[NGX_HTTP_SSI_INCLUDE_FILE];
    wait = params[NGX_HTTP_SSI_INCLUDE_WAIT];
    set = params[NGX_HTTP_SSI_INCLUDE_SET];
    stub = params[NGX_HTTP_SSI_INCLUDE_STUB];

    if (uri && file) {
        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                      ""inclusion may be either virtual=\""%V\"" or file=\""%V\"""",
                      uri, file);
        return NGX_HTTP_...",1,17,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_include,,false,1985,2198,ngx_http_ssi_include,,,75,"ngx_int_t ngx_http_ssi_include (ngx_http_request_t*,ngx_http_ssi_ctx_t*,ngx_str_t**)"
223063,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_ssi_stub_output(ngx_http_request_t *r, void *data, ngx_int_t rc)
{
    ngx_chain_t  *out;

    if (rc == NGX_ERROR || r->connection->error || r->request_output) {
        return rc;
    }

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""ssi stub output: \""%V?%V\"""", &r->uri, &r->args);

    out = data;

    if (!r->header_sent) {
        r->headers_out.content_type_len =
                                      r->parent->headers_out.content_type_len;
        r->headers_out.content_type = r->parent->headers_out.content_type;

        if (ngx_http_send_header(r) == NGX_ERROR) {
            return NGX_ERROR;
        }
    }

    return ngx_http_output_filter(r, out);
}",1,1,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_stub_output,,false,2201,2226,ngx_http_ssi_stub_output,,,76,"ngx_int_t ngx_http_ssi_stub_output (ngx_http_request_t*,void*,ngx_int_t)"
223152,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_ssi_set_variable(ngx_http_request_t *r, void *data, ngx_int_t rc)
{
    ngx_str_t  *value = data;

    if (r->headers_out.status < NGX_HTTP_SPECIAL_RESPONSE
        && r->out && r->out->buf)
    {
        value->len = r->out->buf->last - r->out->buf->pos;
        value->data = r->out->buf->pos;
    }

    return rc;
}",1,1,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_set_variable,,false,2229,2242,ngx_http_ssi_set_variable,,,77,"ngx_int_t ngx_http_ssi_set_variable (ngx_http_request_t*,void*,ngx_int_t)"
223214,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_ssi_echo(ngx_http_request_t *r, ngx_http_ssi_ctx_t *ctx,
    ngx_str_t **params)
{
    u_char                     *p;
    uintptr_t                   len;
    ngx_buf_t                  *b;
    ngx_str_t                  *var, *value, *enc, text;
    ngx_uint_t                  key;
    ngx_chain_t                *cl;
    ngx_http_variable_value_t  *vv;

    var = params[NGX_HTTP_SSI_ECHO_VAR];

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""ssi echo \""%V\"""", var);

    key = ngx_hash_strlow(var->data, var->data, var->len);

    value = ngx_http_ssi_get_variable(r, var, key);

    if (value == NULL) {
        vv = ngx_http_get_variable(r, var, key);

        if (vv == NULL) {
            return NGX_HTTP_SSI_ERROR;
        }

        if (!vv->not_found) {
            text.data = vv->data;
            text.len = vv->len;
            value = &text;
        }
    }

    if (value == NULL) {
        value = params[NGX_HTTP_SSI_...",1,17,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_echo,,false,2245,2378,ngx_http_ssi_echo,,,78,"ngx_int_t ngx_http_ssi_echo (ngx_http_request_t*,ngx_http_ssi_ctx_t*,ngx_str_t**)"
223638,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_ssi_config(ngx_http_request_t *r, ngx_http_ssi_ctx_t *ctx,
    ngx_str_t **params)
{
    ngx_str_t  *value;

    value = params[NGX_HTTP_SSI_CONFIG_TIMEFMT];

    if (value) {
        ctx->timefmt.len = value->len;
        ctx->timefmt.data = ngx_pnalloc(r->pool, value->len + 1);
        if (ctx->timefmt.data == NULL) {
            return NGX_ERROR;
        }

        ngx_cpystrn(ctx->timefmt.data, value->data, value->len + 1);
    }

    value = params[NGX_HTTP_SSI_CONFIG_ERRMSG];

    if (value) {
        ctx->errmsg = *value;
    }

    return NGX_OK;
}",1,19,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_config,,false,2381,2406,ngx_http_ssi_config,,,79,"ngx_int_t ngx_http_ssi_config (ngx_http_request_t*,ngx_http_ssi_ctx_t*,ngx_str_t**)"
223723,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_ssi_set(ngx_http_request_t *r, ngx_http_ssi_ctx_t *ctx,
    ngx_str_t **params)
{
    ngx_int_t            rc;
    ngx_str_t           *name, *value, *vv;
    ngx_uint_t           key;
    ngx_http_ssi_var_t  *var;
    ngx_http_ssi_ctx_t  *mctx;

    mctx = ngx_http_get_module_ctx(r->main, ngx_http_ssi_filter_module);

    if (mctx->variables == NULL) {
        mctx->variables = ngx_list_create(r->pool, 4,
                                          sizeof(ngx_http_ssi_var_t));
        if (mctx->variables == NULL) {
            return NGX_ERROR;
        }
    }

    name = params[NGX_HTTP_SSI_SET_VAR];
    value = params[NGX_HTTP_SSI_SET_VALUE];

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""ssi set \""%V\"" \""%V\"""", name, value);

    rc = ngx_http_ssi_evaluate_string(r, ctx, value, 0);

    if (rc != NGX_OK) {
        return rc;
    }

    key = ngx_hash_strlow(name->data, name->data, name->len);

    vv = ngx_http_ssi_get_...",1,18,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_set,,false,2409,2463,ngx_http_ssi_set,,,80,"ngx_int_t ngx_http_ssi_set (ngx_http_request_t*,ngx_http_ssi_ctx_t*,ngx_str_t**)"
223881,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_ssi_if(ngx_http_request_t *r, ngx_http_ssi_ctx_t *ctx,
    ngx_str_t **params)
{
    u_char       *p, *last;
    ngx_str_t    *expr, left, right;
    ngx_int_t     rc;
    ngx_uint_t    negative, noregex, flags;

    if (ctx->command.len == 2) {
        if (ctx->conditional) {
            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                          ""the \""if\"" command inside the \""if\"" command"");
            return NGX_HTTP_SSI_ERROR;
        }
    }

    if (ctx->output_chosen) {
        ctx->output = 0;
        return NGX_OK;
    }

    expr = params[NGX_HTTP_SSI_IF_EXPR];

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""ssi if expr=\""%V\"""", expr);

    left.data = expr->data;
    last = expr->data + expr->len;

    for (p = left.data; p < last; p++) {
        if (*p >= 'A' && *p <= 'Z') {
            *p |= 0x20;
            continue;
        }

        if ((*p >= 'a' && *p <= 'z')
             || (*p >= '0...",1,19,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_if,,false,2466,2637,ngx_http_ssi_if,,,81,"ngx_int_t ngx_http_ssi_if (ngx_http_request_t*,ngx_http_ssi_ctx_t*,ngx_str_t**)"
224439,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_ssi_else(ngx_http_request_t *r, ngx_http_ssi_ctx_t *ctx,
    ngx_str_t **params)
{
    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""ssi else"");

    if (ctx->output_chosen) {
        ctx->output = 0;
    } else {
        ctx->output = 1;
    }

    ctx->conditional = NGX_HTTP_SSI_COND_ELSE;

    return NGX_OK;
}",1,1,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_else,,false,2640,2656,ngx_http_ssi_else,,,82,"ngx_int_t ngx_http_ssi_else (ngx_http_request_t*,ngx_http_ssi_ctx_t*,ngx_str_t**)"
224479,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_ssi_endif(ngx_http_request_t *r, ngx_http_ssi_ctx_t *ctx,
    ngx_str_t **params)
{
    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""ssi endif"");

    ctx->output = 1;
    ctx->output_chosen = 0;
    ctx->conditional = 0;

    return NGX_OK;
}",1,1,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_endif,,false,2659,2671,ngx_http_ssi_endif,,,83,"ngx_int_t ngx_http_ssi_endif (ngx_http_request_t*,ngx_http_ssi_ctx_t*,ngx_str_t**)"
224512,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_ssi_block(ngx_http_request_t *r, ngx_http_ssi_ctx_t *ctx,
    ngx_str_t **params)
{
    ngx_http_ssi_ctx_t    *mctx;
    ngx_http_ssi_block_t  *bl;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""ssi block"");

    mctx = ngx_http_get_module_ctx(r->main, ngx_http_ssi_filter_module);

    if (mctx->blocks == NULL) {
        mctx->blocks = ngx_array_create(r->pool, 4,
                                        sizeof(ngx_http_ssi_block_t));
        if (mctx->blocks == NULL) {
            return NGX_HTTP_SSI_ERROR;
        }
    }

    bl = ngx_array_push(mctx->blocks);
    if (bl == NULL) {
        return NGX_HTTP_SSI_ERROR;
    }

    bl->name = *params[NGX_HTTP_SSI_BLOCK_NAME];
    bl->bufs = NULL;
    bl->count = 0;

    ctx->output = 0;
    ctx->block = 1;

    return NGX_OK;
}",1,19,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_block,,false,2674,2707,ngx_http_ssi_block,,,84,"ngx_int_t ngx_http_ssi_block (ngx_http_request_t*,ngx_http_ssi_ctx_t*,ngx_str_t**)"
224613,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_ssi_endblock(ngx_http_request_t *r, ngx_http_ssi_ctx_t *ctx,
    ngx_str_t **params)
{
    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""ssi endblock"");

    ctx->output = 1;
    ctx->block = 0;

    return NGX_OK;
}",1,1,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_endblock,,false,2710,2721,ngx_http_ssi_endblock,,,85,"ngx_int_t ngx_http_ssi_endblock (ngx_http_request_t*,ngx_http_ssi_ctx_t*,ngx_str_t**)"
224641,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_ssi_date_gmt_local_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t gmt)
{
    time_t               now;
    ngx_http_ssi_ctx_t  *ctx;
    ngx_str_t           *timefmt;
    struct tm            tm;
    char                 buf[NGX_HTTP_SSI_DATE_LEN];

    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;

    now = ngx_time();

    ctx = ngx_http_get_module_ctx(r, ngx_http_ssi_filter_module);

    timefmt = ctx ? &ctx->timefmt : &ngx_http_ssi_timefmt;

    if (timefmt->len == sizeof(""%s"") - 1
        && timefmt->data[0] == '%' && timefmt->data[1] == 's')
    {
        v->data = ngx_pnalloc(r->pool, NGX_TIME_T_LEN);
        if (v->data == NULL) {
            return NGX_ERROR;
        }

        v->len = ngx_sprintf(v->data, ""%T"", now) - v->data;

        return NGX_OK;
    }

    if (gmt) {
        ngx_libc_gmtime(now, &tm);
    } else {
        ngx_libc_localtime(now, &tm);
    }

    v->len = strftime(buf, NGX_HTTP_SSI...",1,29,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_date_gmt_local_variable,,false,2724,2777,ngx_http_ssi_date_gmt_local_variable,,,86,"ngx_int_t ngx_http_ssi_date_gmt_local_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
224814,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_ssi_preconfiguration(ngx_conf_t *cf)
{
    ngx_int_t                  rc;
    ngx_http_variable_t       *var, *v;
    ngx_http_ssi_command_t    *cmd;
    ngx_http_ssi_main_conf_t  *smcf;

    for (v = ngx_http_ssi_vars; v->name.len; v++) {
        var = ngx_http_add_variable(cf, &v->name, v->flags);
        if (var == NULL) {
            return NGX_ERROR;
        }

        var->get_handler = v->get_handler;
        var->data = v->data;
    }

    smcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_ssi_filter_module);

    for (cmd = ngx_http_ssi_commands; cmd->name.len; cmd++) {
        rc = ngx_hash_add_key(&smcf->commands, &cmd->name, cmd,
                              NGX_HASH_READONLY_KEY);

        if (rc == NGX_OK) {
            continue;
        }

        if (rc == NGX_BUSY) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               ""conflicting SSI command \""%V\"""", &cmd->name);
        }

        return NGX_ERROR;
   ...",1,1,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_preconfiguration,,false,2780,2817,ngx_http_ssi_preconfiguration,,,87,ngx_int_t ngx_http_ssi_preconfiguration (ngx_conf_t*)
224924,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static void *
ngx_http_ssi_create_main_conf(ngx_conf_t *cf)
{
    ngx_http_ssi_main_conf_t  *smcf;

    smcf = ngx_pcalloc(cf->pool, sizeof(ngx_http_ssi_main_conf_t));
    if (smcf == NULL) {
        return NULL;
    }

    smcf->commands.pool = cf->pool;
    smcf->commands.temp_pool = cf->temp_pool;

    if (ngx_hash_keys_array_init(&smcf->commands, NGX_HASH_SMALL) != NGX_OK) {
        return NULL;
    }

    return smcf;
}",1,1,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_create_main_conf,,false,2820,2838,ngx_http_ssi_create_main_conf,,,88,void* ngx_http_ssi_create_main_conf (ngx_conf_t*)
224977,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static char *
ngx_http_ssi_init_main_conf(ngx_conf_t *cf, void *conf)
{
    ngx_http_ssi_main_conf_t *smcf = conf;

    ngx_hash_init_t  hash;

    hash.hash = &smcf->hash;
    hash.key = ngx_hash_key;
    hash.max_size = 1024;
    hash.bucket_size = ngx_cacheline_size;
    hash.name = ""ssi_command_hash"";
    hash.pool = cf->pool;
    hash.temp_pool = NULL;

    if (ngx_hash_init(&hash, smcf->commands.keys.elts,
                      smcf->commands.keys.nelts)
        != NGX_OK)
    {
        return NGX_CONF_ERROR;
    }

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_init_main_conf,,false,2841,2864,ngx_http_ssi_init_main_conf,,,89,"char* ngx_http_ssi_init_main_conf (ngx_conf_t*,void*)"
225053,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static void *
ngx_http_ssi_create_loc_conf(ngx_conf_t *cf)
{
    ngx_http_ssi_loc_conf_t  *slcf;

    slcf = ngx_pcalloc(cf->pool, sizeof(ngx_http_ssi_loc_conf_t));
    if (slcf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     conf->types = { NULL };
     *     conf->types_keys = NULL;
     */

    slcf->enable = NGX_CONF_UNSET;
    slcf->silent_errors = NGX_CONF_UNSET;
    slcf->ignore_recycled_buffers = NGX_CONF_UNSET;
    slcf->last_modified = NGX_CONF_UNSET;

    slcf->min_file_chunk = NGX_CONF_UNSET_SIZE;
    slcf->value_len = NGX_CONF_UNSET_SIZE;

    return slcf;
}",1,1,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_create_loc_conf,,false,2867,2893,ngx_http_ssi_create_loc_conf,,,90,void* ngx_http_ssi_create_loc_conf (ngx_conf_t*)
225106,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static char *
ngx_http_ssi_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_ssi_loc_conf_t *prev = parent;
    ngx_http_ssi_loc_conf_t *conf = child;

    ngx_conf_merge_value(conf->enable, prev->enable, 0);
    ngx_conf_merge_value(conf->silent_errors, prev->silent_errors, 0);
    ngx_conf_merge_value(conf->ignore_recycled_buffers,
                         prev->ignore_recycled_buffers, 0);
    ngx_conf_merge_value(conf->last_modified, prev->last_modified, 0);

    ngx_conf_merge_size_value(conf->min_file_chunk, prev->min_file_chunk, 1024);
    ngx_conf_merge_size_value(conf->value_len, prev->value_len, 255);

    if (ngx_http_merge_types(cf, &conf->types_keys, &conf->types,
                             &prev->types_keys, &prev->types,
                             ngx_http_html_default_types)
        != NGX_OK)
    {
        return NGX_CONF_ERROR;
    }

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_merge_loc_conf,,false,2896,2920,ngx_http_ssi_merge_loc_conf,,,91,"char* ngx_http_ssi_merge_loc_conf (ngx_conf_t*,void*,void*)"
225196,METHOD,http\modules\ngx_http_ssi_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_ssi_filter_init(ngx_conf_t *cf)
{
    ngx_http_next_header_filter = ngx_http_top_header_filter;
    ngx_http_top_header_filter = ngx_http_ssi_header_filter;

    ngx_http_next_body_filter = ngx_http_top_body_filter;
    ngx_http_top_body_filter = ngx_http_ssi_body_filter;

    return NGX_OK;
}",1,1,http\modules\ngx_http_ssi_filter_module.c,ngx_http_ssi_filter_init,,false,2923,2933,ngx_http_ssi_filter_init,,,92,ngx_int_t ngx_http_ssi_filter_init (ngx_conf_t*)
225224,METHOD,http\modules\ngx_http_ssi_filter_module.h:<global>,TYPE_DECL,<global>,1,43,http\modules\ngx_http_ssi_filter_module.h,http\modules\ngx_http_ssi_filter_module.h:<global>,,false,1,114,<global>,,,1,
225264,METHOD,<empty>,<empty>,<empty>,1,,http\modules\ngx_http_ssi_filter_module.h,ngx_http_ssi_ctx_t:<clinit>,,false,39,,<clinit>,,,34,
225273,METHOD,http\modules\ngx_http_ssi_filter_module.h:<global>,TYPE_DECL,"typedef ngx_int_t (*ngx_http_ssi_command_pt) (ngx_http_request_t *r,
    ngx_http_ssi_ctx_t *ctx, ngx_str_t **);",19,42,http\modules\ngx_http_ssi_filter_module.h,ngx_http_ssi_command_pt,,false,87,88,ngx_http_ssi_command_pt,,,5,"ngx_int_t ngx_http_ssi_command_pt (ngx_http_request_t*,ngx_http_ssi_ctx_t*,ngx_str_t**)"
225304,METHOD,http\modules\ngx_http_ssl_module.c:<global>,TYPE_DECL,<global>,1,56,http\modules\ngx_http_ssl_module.c,http\modules\ngx_http_ssl_module.c:<global>,,false,1,1309,<global>,,,1,
225306,METHOD,http\modules\ngx_http_ssl_module.c:<global>,TYPE_DECL,"typedef ngx_int_t (*ngx_ssl_variable_handler_pt)(ngx_connection_t *c,
    ngx_pool_t *pool, ngx_str_t *s);",19,35,http\modules\ngx_http_ssl_module.c,ngx_ssl_variable_handler_pt,,false,13,14,ngx_ssl_variable_handler_pt,,,1,"ngx_int_t ngx_ssl_variable_handler_pt (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
225313,METHOD,http\modules\ngx_http_ssl_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_ssl_static_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\modules\ngx_http_ssl_module.c,ngx_http_ssl_static_variable,,false,34,35,ngx_http_ssl_static_variable,,,2,"ngx_int_t ngx_http_ssl_static_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
225320,METHOD,http\modules\ngx_http_ssl_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_ssl_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\modules\ngx_http_ssl_module.c,ngx_http_ssl_variable,,false,36,37,ngx_http_ssl_variable,,,3,"ngx_int_t ngx_http_ssl_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
225327,METHOD,http\modules\ngx_http_ssl_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_ssl_add_variables(ngx_conf_t *cf);,18,59,http\modules\ngx_http_ssl_module.c,ngx_http_ssl_add_variables,,false,39,39,ngx_http_ssl_add_variables,,,4,ngx_int_t ngx_http_ssl_add_variables (ngx_conf_t*)
225332,METHOD,http\modules\ngx_http_ssl_module.c:<global>,TYPE_DECL,static void *ngx_http_ssl_create_srv_conf(ngx_conf_t *cf);,13,57,http\modules\ngx_http_ssl_module.c,ngx_http_ssl_create_srv_conf,,false,40,40,ngx_http_ssl_create_srv_conf,,,5,void* ngx_http_ssl_create_srv_conf (ngx_conf_t*)
225337,METHOD,http\modules\ngx_http_ssl_module.c:<global>,TYPE_DECL,"static char *ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf,
    void *parent, void *child);",13,30,http\modules\ngx_http_ssl_module.c,ngx_http_ssl_merge_srv_conf,,false,41,42,ngx_http_ssl_merge_srv_conf,,,6,"char* ngx_http_ssl_merge_srv_conf (ngx_conf_t*,void*,void*)"
225344,METHOD,http\modules\ngx_http_ssl_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_ssl_compile_certificates(ngx_conf_t *cf,
    ngx_http_ssl_srv_conf_t *conf);",18,34,http\modules\ngx_http_ssl_module.c,ngx_http_ssl_compile_certificates,,false,44,45,ngx_http_ssl_compile_certificates,,,7,"ngx_int_t ngx_http_ssl_compile_certificates (ngx_conf_t*,ngx_http_ssl_srv_conf_t*)"
225350,METHOD,http\modules\ngx_http_ssl_module.c:<global>,TYPE_DECL,"static char *ngx_http_ssl_enable(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_ssl_module.c,ngx_http_ssl_enable,,false,47,48,ngx_http_ssl_enable,,,8,"char* ngx_http_ssl_enable (ngx_conf_t*,ngx_command_t*,void*)"
225357,METHOD,http\modules\ngx_http_ssl_module.c:<global>,TYPE_DECL,"static char *ngx_http_ssl_password_file(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_ssl_module.c,ngx_http_ssl_password_file,,false,49,50,ngx_http_ssl_password_file,,,9,"char* ngx_http_ssl_password_file (ngx_conf_t*,ngx_command_t*,void*)"
225364,METHOD,http\modules\ngx_http_ssl_module.c:<global>,TYPE_DECL,"static char *ngx_http_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_ssl_module.c,ngx_http_ssl_session_cache,,false,51,52,ngx_http_ssl_session_cache,,,10,"char* ngx_http_ssl_session_cache (ngx_conf_t*,ngx_command_t*,void*)"
225371,METHOD,http\modules\ngx_http_ssl_module.c:<global>,TYPE_DECL,"static char *ngx_http_ssl_ocsp_cache(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_ssl_module.c,ngx_http_ssl_ocsp_cache,,false,53,54,ngx_http_ssl_ocsp_cache,,,11,"char* ngx_http_ssl_ocsp_cache (ngx_conf_t*,ngx_command_t*,void*)"
225378,METHOD,http\modules\ngx_http_ssl_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_ssl_init(ngx_conf_t *cf);,18,50,http\modules\ngx_http_ssl_module.c,ngx_http_ssl_init,,false,56,56,ngx_http_ssl_init,,,12,ngx_int_t ngx_http_ssl_init (ngx_conf_t*)
226095,METHOD,http\modules\ngx_http_ssl_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_ssl_static_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    ngx_ssl_variable_handler_pt  handler = (ngx_ssl_variable_handler_pt) data;

    size_t     len;
    ngx_str_t  s;

    if (r->connection->ssl) {

        (void) handler(r->connection, NULL, &s);

        v->data = s.data;

        for (len = 0; v->data[len]; len++) { /* void */ }

        v->len = len;
        v->valid = 1;
        v->no_cacheable = 0;
        v->not_found = 0;

        return NGX_OK;
    }

    v->not_found = 1;

    return NGX_OK;
}",1,1,http\modules\ngx_http_ssl_module.c,ngx_http_ssl_static_variable,,false,491,519,ngx_http_ssl_static_variable,,,31,"ngx_int_t ngx_http_ssl_static_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
226175,METHOD,http\modules\ngx_http_ssl_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_ssl_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v,
    uintptr_t data)
{
    ngx_ssl_variable_handler_pt  handler = (ngx_ssl_variable_handler_pt) data;

    ngx_str_t  s;

    if (r->connection->ssl) {

        if (handler(r->connection, r->pool, &s) != NGX_OK) {
            return NGX_ERROR;
        }

        v->len = s.len;
        v->data = s.data;

        if (v->len) {
            v->valid = 1;
            v->no_cacheable = 0;
            v->not_found = 0;

            return NGX_OK;
        }
    }

    v->not_found = 1;

    return NGX_OK;
}",1,1,http\modules\ngx_http_ssl_module.c,ngx_http_ssl_variable,,false,522,551,ngx_http_ssl_variable,,,32,"ngx_int_t ngx_http_ssl_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
226254,METHOD,http\modules\ngx_http_ssl_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_ssl_add_variables(ngx_conf_t *cf)
{
    ngx_http_variable_t  *var, *v;

    for (v = ngx_http_ssl_vars; v->name.len; v++) {
        var = ngx_http_add_variable(cf, &v->name, v->flags);
        if (var == NULL) {
            return NGX_ERROR;
        }

        var->get_handler = v->get_handler;
        var->data = v->data;
    }

    return NGX_OK;
}",1,1,http\modules\ngx_http_ssl_module.c,ngx_http_ssl_add_variables,,false,554,570,ngx_http_ssl_add_variables,,,33,ngx_int_t ngx_http_ssl_add_variables (ngx_conf_t*)
226308,METHOD,http\modules\ngx_http_ssl_module.c:<global>,TYPE_DECL,"static void *
ngx_http_ssl_create_srv_conf(ngx_conf_t *cf)
{
    ngx_http_ssl_srv_conf_t  *sscf;

    sscf = ngx_pcalloc(cf->pool, sizeof(ngx_http_ssl_srv_conf_t));
    if (sscf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     sscf->protocols = 0;
     *     sscf->certificate_values = NULL;
     *     sscf->dhparam = { 0, NULL };
     *     sscf->ecdh_curve = { 0, NULL };
     *     sscf->client_certificate = { 0, NULL };
     *     sscf->trusted_certificate = { 0, NULL };
     *     sscf->crl = { 0, NULL };
     *     sscf->ciphers = { 0, NULL };
     *     sscf->shm_zone = NULL;
     *     sscf->ocsp_responder = { 0, NULL };
     *     sscf->stapling_file = { 0, NULL };
     *     sscf->stapling_responder = { 0, NULL };
     */

    sscf->enable = NGX_CONF_UNSET;
    sscf->prefer_server_ciphers = NGX_CONF_UNSET;
    sscf->early_data = NGX_CONF_UNSET;
    sscf->buffer_size = NGX_CONF_UNSET_SIZE;
    sscf->verify = NGX_CONF_UNSET_UINT;
   ...",1,1,http\modules\ngx_http_ssl_module.c,ngx_http_ssl_create_srv_conf,,false,573,619,ngx_http_ssl_create_srv_conf,,,34,void* ngx_http_ssl_create_srv_conf (ngx_conf_t*)
226416,METHOD,http\modules\ngx_http_ssl_module.c:<global>,TYPE_DECL,"static char *
ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_ssl_srv_conf_t *prev = parent;
    ngx_http_ssl_srv_conf_t *conf = child;

    ngx_pool_cleanup_t  *cln;

    if (conf->enable == NGX_CONF_UNSET) {
        if (prev->enable == NGX_CONF_UNSET) {
            conf->enable = 0;

        } else {
            conf->enable = prev->enable;
            conf->file = prev->file;
            conf->line = prev->line;
        }
    }

    ngx_conf_merge_value(conf->session_timeout,
                         prev->session_timeout, 300);

    ngx_conf_merge_value(conf->prefer_server_ciphers,
                         prev->prefer_server_ciphers, 0);

    ngx_conf_merge_value(conf->early_data, prev->early_data, 0);

    ngx_conf_merge_bitmask_value(conf->protocols, prev->protocols,
                         (NGX_CONF_BITMASK_SET|NGX_SSL_TLSv1
                          |NGX_SSL_TLSv1_1|NGX_SSL_TLSv1_2));

    ngx_conf_merge_size_value(conf->buffer_size, p...",1,25,http\modules\ngx_http_ssl_module.c,ngx_http_ssl_merge_srv_conf,,false,622,917,ngx_http_ssl_merge_srv_conf,,,35,"char* ngx_http_ssl_merge_srv_conf (ngx_conf_t*,void*,void*)"
227225,METHOD,http\modules\ngx_http_ssl_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_ssl_compile_certificates(ngx_conf_t *cf,
    ngx_http_ssl_srv_conf_t *conf)
{
    ngx_str_t                         *cert, *key;
    ngx_uint_t                         i, nelts;
    ngx_http_complex_value_t          *cv;
    ngx_http_compile_complex_value_t   ccv;

    cert = conf->certificates->elts;
    key = conf->certificate_keys->elts;
    nelts = conf->certificates->nelts;

    for (i = 0; i < nelts; i++) {

        if (ngx_http_script_variables_count(&cert[i])) {
            goto found;
        }

        if (ngx_http_script_variables_count(&key[i])) {
            goto found;
        }
    }

    return NGX_OK;

found:

    conf->certificate_values = ngx_array_create(cf->pool, nelts,
                                             sizeof(ngx_http_complex_value_t));
    if (conf->certificate_values == NULL) {
        return NGX_ERROR;
    }

    conf->certificate_key_values = ngx_array_create(cf->pool, nelts,
                                             ...",1,1,http\modules\ngx_http_ssl_module.c,ngx_http_ssl_compile_certificates,,false,920,1001,ngx_http_ssl_compile_certificates,,,36,"ngx_int_t ngx_http_ssl_compile_certificates (ngx_conf_t*,ngx_http_ssl_srv_conf_t*)"
227459,METHOD,http\modules\ngx_http_ssl_module.c:<global>,TYPE_DECL,"static char *
ngx_http_ssl_enable(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_ssl_srv_conf_t *sscf = conf;

    char  *rv;

    rv = ngx_conf_set_flag_slot(cf, cmd, conf);

    if (rv != NGX_CONF_OK) {
        return rv;
    }

    sscf->file = cf->conf_file->file.name.data;
    sscf->line = cf->conf_file->line;

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_ssl_module.c,ngx_http_ssl_enable,,false,1004,1021,ngx_http_ssl_enable,,,37,"char* ngx_http_ssl_enable (ngx_conf_t*,ngx_command_t*,void*)"
227508,METHOD,http\modules\ngx_http_ssl_module.c:<global>,TYPE_DECL,"static char *
ngx_http_ssl_password_file(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_ssl_srv_conf_t *sscf = conf;

    ngx_str_t  *value;

    if (sscf->passwords != NGX_CONF_UNSET_PTR) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    sscf->passwords = ngx_ssl_read_password_file(cf, &value[1]);

    if (sscf->passwords == NULL) {
        return NGX_CONF_ERROR;
    }

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_ssl_module.c,ngx_http_ssl_password_file,,false,1024,1044,ngx_http_ssl_password_file,,,38,"char* ngx_http_ssl_password_file (ngx_conf_t*,ngx_command_t*,void*)"
227557,METHOD,http\modules\ngx_http_ssl_module.c:<global>,TYPE_DECL,"static char *
ngx_http_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_ssl_srv_conf_t *sscf = conf;

    size_t       len;
    ngx_str_t   *value, name, size;
    ngx_int_t    n;
    ngx_uint_t   i, j;

    value = cf->args->elts;

    for (i = 1; i < cf->args->nelts; i++) {

        if (ngx_strcmp(value[i].data, ""off"") == 0) {
            sscf->builtin_session_cache = NGX_SSL_NO_SCACHE;
            continue;
        }

        if (ngx_strcmp(value[i].data, ""none"") == 0) {
            sscf->builtin_session_cache = NGX_SSL_NONE_SCACHE;
            continue;
        }

        if (ngx_strcmp(value[i].data, ""builtin"") == 0) {
            sscf->builtin_session_cache = NGX_SSL_DFLT_BUILTIN_SCACHE;
            continue;
        }

        if (value[i].len > sizeof(""builtin:"") - 1
            && ngx_strncmp(value[i].data, ""builtin:"", sizeof(""builtin:"") - 1)
               == 0)
        {
            n = ngx_atoi(value[i].data + sizeof(""builtin:"") - 1,
     ...",1,1,http\modules\ngx_http_ssl_module.c,ngx_http_ssl_session_cache,,false,1047,1156,ngx_http_ssl_session_cache,,,39,"char* ngx_http_ssl_session_cache (ngx_conf_t*,ngx_command_t*,void*)"
227908,METHOD,http\modules\ngx_http_ssl_module.c:<global>,TYPE_DECL,"static char *
ngx_http_ssl_ocsp_cache(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_ssl_srv_conf_t *sscf = conf;

    size_t       len;
    ngx_int_t    n;
    ngx_str_t   *value, name, size;
    ngx_uint_t   j;

    if (sscf->ocsp_cache_zone != NGX_CONF_UNSET_PTR) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    if (ngx_strcmp(value[1].data, ""off"") == 0) {
        sscf->ocsp_cache_zone = NULL;
        return NGX_CONF_OK;
    }

    if (value[1].len <= sizeof(""shared:"") - 1
        || ngx_strncmp(value[1].data, ""shared:"", sizeof(""shared:"") - 1) != 0)
    {
        goto invalid;
    }

    len = 0;

    for (j = sizeof(""shared:"") - 1; j < value[1].len; j++) {
        if (value[1].data[j] == ':') {
            break;
        }

        len++;
    }

    if (len == 0) {
        goto invalid;
    }

    name.len = len;
    name.data = value[1].data + sizeof(""shared:"") - 1;

    size.len = value[1].len - j - 1;
    size.data = name.data + len + 1;...",1,1,http\modules\ngx_http_ssl_module.c,ngx_http_ssl_ocsp_cache,,false,1159,1235,ngx_http_ssl_ocsp_cache,,,40,"char* ngx_http_ssl_ocsp_cache (ngx_conf_t*,ngx_command_t*,void*)"
228141,METHOD,http\modules\ngx_http_ssl_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_ssl_init(ngx_conf_t *cf)
{
    ngx_uint_t                   a, p, s;
    ngx_http_conf_addr_t        *addr;
    ngx_http_conf_port_t        *port;
    ngx_http_ssl_srv_conf_t     *sscf;
    ngx_http_core_loc_conf_t    *clcf;
    ngx_http_core_srv_conf_t   **cscfp, *cscf;
    ngx_http_core_main_conf_t   *cmcf;

    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);
    cscfp = cmcf->servers.elts;

    for (s = 0; s < cmcf->servers.nelts; s++) {

        sscf = cscfp[s]->ctx->srv_conf[ngx_http_ssl_module.ctx_index];

        if (sscf->ssl.ctx == NULL) {
            continue;
        }

        clcf = cscfp[s]->ctx->loc_conf[ngx_http_core_module.ctx_index];

        if (sscf->stapling) {
            if (ngx_ssl_stapling_resolver(cf, &sscf->ssl, clcf->resolver,
                                          clcf->resolver_timeout)
                != NGX_OK)
            {
                return NGX_ERROR;
            }
        }

        if (sscf->o...",1,1,http\modules\ngx_http_ssl_module.c,ngx_http_ssl_init,,false,1238,1309,ngx_http_ssl_init,,,41,ngx_int_t ngx_http_ssl_init (ngx_conf_t*)
228384,METHOD,http\modules\ngx_http_ssl_module.h:<global>,TYPE_DECL,<global>,1,38,http\modules\ngx_http_ssl_module.h,http\modules\ngx_http_ssl_module.h:<global>,,false,1,74,<global>,,,1,
228431,METHOD,http\modules\ngx_http_static_module.c:<global>,TYPE_DECL,<global>,1,1,http\modules\ngx_http_static_module.c,http\modules\ngx_http_static_module.c:<global>,,false,1,288,<global>,,,1,
228433,METHOD,http\modules\ngx_http_static_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_static_handler(ngx_http_request_t *r);,18,63,http\modules\ngx_http_static_module.c,ngx_http_static_handler,,false,13,13,ngx_http_static_handler,,,1,ngx_int_t ngx_http_static_handler (ngx_http_request_t*)
228438,METHOD,http\modules\ngx_http_static_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_static_init(ngx_conf_t *cf);,18,53,http\modules\ngx_http_static_module.c,ngx_http_static_init,,false,14,14,ngx_http_static_init,,,2,ngx_int_t ngx_http_static_init (ngx_conf_t*)
228472,METHOD,http\modules\ngx_http_static_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_static_handler(ngx_http_request_t *r)
{
    u_char                    *last, *location;
    size_t                     root, len;
    ngx_str_t                  path;
    ngx_int_t                  rc;
    ngx_uint_t                 level;
    ngx_log_t                 *log;
    ngx_buf_t                 *b;
    ngx_chain_t                out;
    ngx_open_file_info_t       of;
    ngx_http_core_loc_conf_t  *clcf;

    if (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD|NGX_HTTP_POST))) {
        return NGX_HTTP_NOT_ALLOWED;
    }

    if (r->uri.data[r->uri.len - 1] == '/') {
        return NGX_DECLINED;
    }

    log = r->connection->log;

    /*
     * ngx_http_map_uri_to_path() allocates memory for terminating '\0'
     * so we do not need to reserve memory for '/' for possible redirect
     */

    last = ngx_http_map_uri_to_path(r, &path, &root, 0);
    if (last == NULL) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    path.len = last - path.dat...",1,1,http\modules\ngx_http_static_module.c,ngx_http_static_handler,,false,48,269,ngx_http_static_handler,,,7,ngx_int_t ngx_http_static_handler (ngx_http_request_t*)
229151,METHOD,http\modules\ngx_http_static_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_static_init(ngx_conf_t *cf)
{
    ngx_http_handler_pt        *h;
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);

    h = ngx_array_push(&cmcf->phases[NGX_HTTP_CONTENT_PHASE].handlers);
    if (h == NULL) {
        return NGX_ERROR;
    }

    *h = ngx_http_static_handler;

    return NGX_OK;
}",1,1,http\modules\ngx_http_static_module.c,ngx_http_static_init,,false,272,288,ngx_http_static_init,,,8,ngx_int_t ngx_http_static_init (ngx_conf_t*)
229196,METHOD,http\modules\ngx_http_stub_status_module.c:<global>,TYPE_DECL,<global>,1,1,http\modules\ngx_http_stub_status_module.c,http\modules\ngx_http_stub_status_module.c:<global>,,false,1,236,<global>,,,1,
229198,METHOD,http\modules\ngx_http_stub_status_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_stub_status_handler(ngx_http_request_t *r);,18,68,http\modules\ngx_http_stub_status_module.c,ngx_http_stub_status_handler,,false,13,13,ngx_http_stub_status_handler,,,1,ngx_int_t ngx_http_stub_status_handler (ngx_http_request_t*)
229203,METHOD,http\modules\ngx_http_stub_status_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_stub_status_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\modules\ngx_http_stub_status_module.c,ngx_http_stub_status_variable,,false,14,15,ngx_http_stub_status_variable,,,2,"ngx_int_t ngx_http_stub_status_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
229210,METHOD,http\modules\ngx_http_stub_status_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_stub_status_add_variables(ngx_conf_t *cf);,18,67,http\modules\ngx_http_stub_status_module.c,ngx_http_stub_status_add_variables,,false,16,16,ngx_http_stub_status_add_variables,,,3,ngx_int_t ngx_http_stub_status_add_variables (ngx_conf_t*)
229215,METHOD,http\modules\ngx_http_stub_status_module.c:<global>,TYPE_DECL,"static char *ngx_http_set_stub_status(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_stub_status_module.c,ngx_http_set_stub_status,,false,17,18,ngx_http_set_stub_status,,,4,"char* ngx_http_set_stub_status (ngx_conf_t*,ngx_command_t*,void*)"
229307,METHOD,http\modules\ngx_http_stub_status_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_stub_status_handler(ngx_http_request_t *r)
{
    size_t             size;
    ngx_int_t          rc;
    ngx_buf_t         *b;
    ngx_chain_t        out;
    ngx_atomic_int_t   ap, hn, ac, rq, rd, wr, wa;

    if (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD))) {
        return NGX_HTTP_NOT_ALLOWED;
    }

    rc = ngx_http_discard_request_body(r);

    if (rc != NGX_OK) {
        return rc;
    }

    r->headers_out.content_type_len = sizeof(""text/plain"") - 1;
    ngx_str_set(&r->headers_out.content_type, ""text/plain"");
    r->headers_out.content_type_lowcase = NULL;

    if (r->method == NGX_HTTP_HEAD) {
        r->headers_out.status = NGX_HTTP_OK;

        rc = ngx_http_send_header(r);

        if (rc == NGX_ERROR || rc > NGX_OK || r->header_only) {
            return rc;
        }
    }

    size = sizeof(""Active connections:  \n"") + NGX_ATOMIC_T_LEN
           + sizeof(""server accepts handled requests\n"") - 1
           + 6 + 3 * NGX_ATOMIC_T_LEN
       ...",1,1,http\modules\ngx_http_stub_status_module.c,ngx_http_stub_status_handler,,false,83,160,ngx_http_stub_status_handler,,,13,ngx_int_t ngx_http_stub_status_handler (ngx_http_request_t*)
229588,METHOD,http\modules\ngx_http_stub_status_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_stub_status_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    u_char            *p;
    ngx_atomic_int_t   value;

    p = ngx_pnalloc(r->pool, NGX_ATOMIC_T_LEN);
    if (p == NULL) {
        return NGX_ERROR;
    }

    switch (data) {
    case 0:
        value = *ngx_stat_active;
        break;

    case 1:
        value = *ngx_stat_reading;
        break;

    case 2:
        value = *ngx_stat_writing;
        break;

    case 3:
        value = *ngx_stat_waiting;
        break;

    /* suppress warning */
    default:
        value = 0;
        break;
    }

    v->len = ngx_sprintf(p, ""%uA"", value) - p;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = p;

    return NGX_OK;
}",1,1,http\modules\ngx_http_stub_status_module.c,ngx_http_stub_status_variable,,false,163,205,ngx_http_stub_status_variable,,,14,"ngx_int_t ngx_http_stub_status_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
229679,METHOD,http\modules\ngx_http_stub_status_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_stub_status_add_variables(ngx_conf_t *cf)
{
    ngx_http_variable_t  *var, *v;

    for (v = ngx_http_stub_status_vars; v->name.len; v++) {
        var = ngx_http_add_variable(cf, &v->name, v->flags);
        if (var == NULL) {
            return NGX_ERROR;
        }

        var->get_handler = v->get_handler;
        var->data = v->data;
    }

    return NGX_OK;
}",1,1,http\modules\ngx_http_stub_status_module.c,ngx_http_stub_status_add_variables,,false,208,224,ngx_http_stub_status_add_variables,,,15,ngx_int_t ngx_http_stub_status_add_variables (ngx_conf_t*)
229733,METHOD,http\modules\ngx_http_stub_status_module.c:<global>,TYPE_DECL,"static char *
ngx_http_set_stub_status(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_core_loc_conf_t  *clcf;

    clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);
    clcf->handler = ngx_http_stub_status_handler;

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_stub_status_module.c,ngx_http_set_stub_status,,false,227,236,ngx_http_set_stub_status,,,16,"char* ngx_http_set_stub_status (ngx_conf_t*,ngx_command_t*,void*)"
229762,METHOD,http\modules\ngx_http_sub_filter_module.c:<global>,TYPE_DECL,<global>,1,1,http\modules\ngx_http_sub_filter_module.c,http\modules\ngx_http_sub_filter_module.c:<global>,,false,1,1018,<global>,,,1,
229777,METHOD,<empty>,<empty>,<empty>,1,,http\modules\ngx_http_sub_filter_module.c,ngx_http_sub_tables_t:<clinit>,,false,25,,<clinit>,,,5,
229817,METHOD,http\modules\ngx_http_sub_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_sub_output(ngx_http_request_t *r,
    ngx_http_sub_ctx_t *ctx);",18,28,http\modules\ngx_http_sub_filter_module.c,ngx_http_sub_output,,false,83,84,ngx_http_sub_output,,,12,"ngx_int_t ngx_http_sub_output (ngx_http_request_t*,ngx_http_sub_ctx_t*)"
229823,METHOD,http\modules\ngx_http_sub_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_sub_parse(ngx_http_request_t *r,
    ngx_http_sub_ctx_t *ctx, ngx_uint_t flush);",18,46,http\modules\ngx_http_sub_filter_module.c,ngx_http_sub_parse,,false,85,86,ngx_http_sub_parse,,,13,"ngx_int_t ngx_http_sub_parse (ngx_http_request_t*,ngx_http_sub_ctx_t*,ngx_uint_t)"
229830,METHOD,http\modules\ngx_http_sub_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_sub_match(ngx_http_sub_ctx_t *ctx, ngx_int_t start,
    ngx_str_t *m);",18,17,http\modules\ngx_http_sub_filter_module.c,ngx_http_sub_match,,false,87,88,ngx_http_sub_match,,,14,"ngx_int_t ngx_http_sub_match (ngx_http_sub_ctx_t*,ngx_int_t,ngx_str_t*)"
229837,METHOD,http\modules\ngx_http_sub_filter_module.c:<global>,TYPE_DECL,"static char * ngx_http_sub_filter(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_sub_filter_module.c,ngx_http_sub_filter,,false,90,91,ngx_http_sub_filter,,,15,"char* ngx_http_sub_filter (ngx_conf_t*,ngx_command_t*,void*)"
229844,METHOD,http\modules\ngx_http_sub_filter_module.c:<global>,TYPE_DECL,static void *ngx_http_sub_create_conf(ngx_conf_t *cf);,13,53,http\modules\ngx_http_sub_filter_module.c,ngx_http_sub_create_conf,,false,92,92,ngx_http_sub_create_conf,,,16,void* ngx_http_sub_create_conf (ngx_conf_t*)
229849,METHOD,http\modules\ngx_http_sub_filter_module.c:<global>,TYPE_DECL,"static char *ngx_http_sub_merge_conf(ngx_conf_t *cf,
    void *parent, void *child);",13,30,http\modules\ngx_http_sub_filter_module.c,ngx_http_sub_merge_conf,,false,93,94,ngx_http_sub_merge_conf,,,17,"char* ngx_http_sub_merge_conf (ngx_conf_t*,void*,void*)"
229856,METHOD,http\modules\ngx_http_sub_filter_module.c:<global>,TYPE_DECL,"static void ngx_http_sub_init_tables(ngx_http_sub_tables_t *tables,
    ngx_http_sub_match_t *match, ngx_uint_t n);",13,46,http\modules\ngx_http_sub_filter_module.c,ngx_http_sub_init_tables,,false,95,96,ngx_http_sub_init_tables,,,18,"void ngx_http_sub_init_tables (ngx_http_sub_tables_t*,ngx_http_sub_match_t*,ngx_uint_t)"
229863,METHOD,http\modules\ngx_http_sub_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_sub_cmp_matches(const void *one, const void *two);",18,75,http\modules\ngx_http_sub_filter_module.c,ngx_http_sub_cmp_matches,,false,97,97,ngx_http_sub_cmp_matches,,,19,"ngx_int_t ngx_http_sub_cmp_matches (void*,void*)"
229869,METHOD,http\modules\ngx_http_sub_filter_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_sub_filter_init(ngx_conf_t *cf);,18,57,http\modules\ngx_http_sub_filter_module.c,ngx_http_sub_filter_init,,false,98,98,ngx_http_sub_filter_init,,,20,ngx_int_t ngx_http_sub_filter_init (ngx_conf_t*)
229975,METHOD,http\modules\ngx_http_sub_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_sub_header_filter(ngx_http_request_t *r)
{
    ngx_str_t                *m;
    ngx_uint_t                i, j, n;
    ngx_http_sub_ctx_t       *ctx;
    ngx_http_sub_pair_t      *pairs;
    ngx_http_sub_match_t     *matches;
    ngx_http_sub_loc_conf_t  *slcf;

    slcf = ngx_http_get_module_loc_conf(r, ngx_http_sub_filter_module);

    if (slcf->pairs == NULL
        || r->headers_out.content_length_n == 0
        || ngx_http_test_content_type(r, &slcf->types) == NULL)
    {
        return ngx_http_next_header_filter(r);
    }

    ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_sub_ctx_t));
    if (ctx == NULL) {
        return NGX_ERROR;
    }

    if (slcf->dynamic == 0) {
        ctx->tables = slcf->tables;
        ctx->matches = slcf->matches;

    } else {
        pairs = slcf->pairs->elts;
        n = slcf->pairs->nelts;

        matches = ngx_pcalloc(r->pool, sizeof(ngx_http_sub_match_t) * n);
        if (matches == NULL) {
            return NGX_ERROR...",1,1,http\modules\ngx_http_sub_filter_module.c,ngx_http_sub_header_filter,,false,170,281,ngx_http_sub_header_filter,,,29,ngx_int_t ngx_http_sub_header_filter (ngx_http_request_t*)
230369,METHOD,http\modules\ngx_http_sub_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_sub_body_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    ngx_int_t                  rc;
    ngx_buf_t                 *b;
    ngx_str_t                 *sub;
    ngx_uint_t                 flush, last;
    ngx_chain_t               *cl;
    ngx_http_sub_ctx_t        *ctx;
    ngx_http_sub_match_t      *match;
    ngx_http_sub_loc_conf_t   *slcf;

    ctx = ngx_http_get_module_ctx(r, ngx_http_sub_filter_module);

    if (ctx == NULL) {
        return ngx_http_next_body_filter(r, in);
    }

    if ((in == NULL
         && ctx->buf == NULL
         && ctx->in == NULL
         && ctx->busy == NULL))
    {
        return ngx_http_next_body_filter(r, in);
    }

    if (ctx->once && (ctx->buf == NULL || ctx->in == NULL)) {

        if (ctx->busy) {
            if (ngx_http_sub_output(r, ctx) == NGX_ERROR) {
                return NGX_ERROR;
            }
        }

        return ngx_http_next_body_filter(r, in);
    }

    /* add the incoming chain to the ...",1,1,http\modules\ngx_http_sub_filter_module.c,ngx_http_sub_body_filter,,false,284,534,ngx_http_sub_body_filter,,,30,"ngx_int_t ngx_http_sub_body_filter (ngx_http_request_t*,ngx_chain_t*)"
231271,METHOD,http\modules\ngx_http_sub_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_sub_output(ngx_http_request_t *r, ngx_http_sub_ctx_t *ctx)
{
    ngx_int_t     rc;
    ngx_buf_t    *b;
    ngx_chain_t  *cl;

#if 1
    b = NULL;
    for (cl = ctx->out; cl; cl = cl->next) {
        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                       ""sub out: %p %p"", cl->buf, cl->buf->pos);
        if (cl->buf == b) {
            ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,
                          ""the same buf was used in sub"");
            ngx_debug_point();
            return NGX_ERROR;
        }
        b = cl->buf;
    }
#endif

    rc = ngx_http_next_body_filter(r, ctx->out);

    if (ctx->busy == NULL) {
        ctx->busy = ctx->out;

    } else {
        for (cl = ctx->busy; cl->next; cl = cl->next) { /* void */ }
        cl->next = ctx->out;
    }

    ctx->out = NULL;
    ctx->last_out = &ctx->out;

    while (ctx->busy) {

        cl = ctx->busy;
        b = cl->buf;

        if (ngx_buf_size(b) != 0) {
   ...",1,1,http\modules\ngx_http_sub_filter_module.c,ngx_http_sub_output,,false,537,603,ngx_http_sub_output,,,31,"ngx_int_t ngx_http_sub_output (ngx_http_request_t*,ngx_http_sub_ctx_t*)"
231486,METHOD,http\modules\ngx_http_sub_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_sub_parse(ngx_http_request_t *r, ngx_http_sub_ctx_t *ctx,
    ngx_uint_t flush)
{
    u_char                   *p, c;
    ngx_str_t                *m;
    ngx_int_t                 offset, start, next, end, len, rc;
    ngx_uint_t                shift, i, j;
    ngx_http_sub_match_t     *match;
    ngx_http_sub_tables_t    *tables;
    ngx_http_sub_loc_conf_t  *slcf;

    slcf = ngx_http_get_module_loc_conf(r, ngx_http_sub_filter_module);
    tables = ctx->tables;
    match = ctx->matches->elts;

    offset = ctx->offset;
    end = ctx->buf->last - ctx->pos;

    if (ctx->once) {
        /* sets start and next to end */
        offset = end + (ngx_int_t) tables->min_match_len - 1;
        goto again;
    }

    while (offset < end) {

        c = offset < 0 ? ctx->looked.data[ctx->looked.len + offset]
                       : ctx->pos[offset];

        c = ngx_tolower(c);

        shift = tables->shift[c];
        if (shift > 0) {
            offset += shif...",1,1,http\modules\ngx_http_sub_filter_module.c,ngx_http_sub_parse,,false,606,740,ngx_http_sub_parse,,,32,"ngx_int_t ngx_http_sub_parse (ngx_http_request_t*,ngx_http_sub_ctx_t*,ngx_uint_t)"
231932,METHOD,http\modules\ngx_http_sub_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_sub_match(ngx_http_sub_ctx_t *ctx, ngx_int_t start, ngx_str_t *m)
{
    u_char  *p, *last, *pat, *pat_end;

    pat = m->data;
    pat_end = m->data + m->len;

    if (start >= 0) {
        p = ctx->pos + start;

    } else {
        last = ctx->looked.data + ctx->looked.len;
        p = last + start;

        while (p < last && pat < pat_end) {
            if (ngx_tolower(*p) != *pat) {
                return NGX_DECLINED;
            }

            p++;
            pat++;
        }

        p = ctx->pos;
    }

    while (p < ctx->buf->last && pat < pat_end) {
        if (ngx_tolower(*p) != *pat) {
            return NGX_DECLINED;
        }

        p++;
        pat++;
    }

    if (pat != pat_end) {
        /* partial match */
        return NGX_AGAIN;
    }

    return NGX_OK;
}",1,1,http\modules\ngx_http_sub_filter_module.c,ngx_http_sub_match,,false,743,785,ngx_http_sub_match,,,33,"ngx_int_t ngx_http_sub_match (ngx_http_sub_ctx_t*,ngx_int_t,ngx_str_t*)"
232053,METHOD,http\modules\ngx_http_sub_filter_module.c:<global>,TYPE_DECL,"static char *
ngx_http_sub_filter(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_sub_loc_conf_t *slcf = conf;

    ngx_str_t                         *value;
    ngx_http_sub_pair_t               *pair;
    ngx_http_compile_complex_value_t   ccv;

    value = cf->args->elts;

    if (value[1].len == 0) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, ""empty search pattern"");
        return NGX_CONF_ERROR;
    }

    if (slcf->pairs == NULL) {
        slcf->pairs = ngx_array_create(cf->pool, 1,
                                       sizeof(ngx_http_sub_pair_t));
        if (slcf->pairs == NULL) {
            return NGX_CONF_ERROR;
        }
    }

    if (slcf->pairs->nelts == 255) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""number of search patterns exceeds 255"");
        return NGX_CONF_ERROR;
    }

    ngx_strlow(value[1].data, value[1].data, value[1].len);

    pair = ngx_array_push(slcf->pairs);
    if (pair == NULL) {
       ...",1,1,http\modules\ngx_http_sub_filter_module.c,ngx_http_sub_filter,,false,788,854,ngx_http_sub_filter,,,34,"char* ngx_http_sub_filter (ngx_conf_t*,ngx_command_t*,void*)"
232272,METHOD,http\modules\ngx_http_sub_filter_module.c:<global>,TYPE_DECL,"static void *
ngx_http_sub_create_conf(ngx_conf_t *cf)
{
    ngx_http_sub_loc_conf_t  *slcf;

    slcf = ngx_pcalloc(cf->pool, sizeof(ngx_http_sub_loc_conf_t));
    if (slcf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     conf->dynamic = 0;
     *     conf->pairs = NULL;
     *     conf->tables = NULL;
     *     conf->types = { NULL };
     *     conf->types_keys = NULL;
     *     conf->matches = NULL;
     */

    slcf->once = NGX_CONF_UNSET;
    slcf->last_modified = NGX_CONF_UNSET;

    return slcf;
}",1,1,http\modules\ngx_http_sub_filter_module.c,ngx_http_sub_create_conf,,false,857,882,ngx_http_sub_create_conf,,,35,void* ngx_http_sub_create_conf (ngx_conf_t*)
232305,METHOD,http\modules\ngx_http_sub_filter_module.c:<global>,TYPE_DECL,"static char *
ngx_http_sub_merge_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_uint_t                i, n;
    ngx_http_sub_pair_t      *pairs;
    ngx_http_sub_match_t     *matches;
    ngx_http_sub_loc_conf_t  *prev = parent;
    ngx_http_sub_loc_conf_t  *conf = child;

    ngx_conf_merge_value(conf->once, prev->once, 1);
    ngx_conf_merge_value(conf->last_modified, prev->last_modified, 0);

    if (ngx_http_merge_types(cf, &conf->types_keys, &conf->types,
                             &prev->types_keys, &prev->types,
                             ngx_http_html_default_types)
        != NGX_OK)
    {
        return NGX_CONF_ERROR;
    }

    if (conf->pairs == NULL) {
        conf->dynamic = prev->dynamic;
        conf->pairs = prev->pairs;
        conf->matches = prev->matches;
        conf->tables = prev->tables;
    }

    if (conf->pairs && conf->dynamic == 0 && conf->tables == NULL) {
        pairs = conf->pairs->elts;
        n = conf->pairs->nelts;

        match...",1,1,http\modules\ngx_http_sub_filter_module.c,ngx_http_sub_merge_conf,,false,885,944,ngx_http_sub_merge_conf,,,36,"char* ngx_http_sub_merge_conf (ngx_conf_t*,void*,void*)"
232552,METHOD,http\modules\ngx_http_sub_filter_module.c:<global>,TYPE_DECL,"static void
ngx_http_sub_init_tables(ngx_http_sub_tables_t *tables,
    ngx_http_sub_match_t *match, ngx_uint_t n)
{
    u_char      c;
    ngx_uint_t  i, j, min, max, ch;

    min = match[0].match.len;
    max = match[0].match.len;

    for (i = 1; i < n; i++) {
        min = ngx_min(min, match[i].match.len);
        max = ngx_max(max, match[i].match.len);
    }

    tables->min_match_len = min;
    tables->max_match_len = max;

    ngx_http_sub_cmp_index = tables->min_match_len - 1;
    ngx_sort(match, n, sizeof(ngx_http_sub_match_t), ngx_http_sub_cmp_matches);

    min = ngx_min(min, 255);
    ngx_memset(tables->shift, min, 256);

    ch = 0;

    for (i = 0; i < n; i++) {

        for (j = 0; j < min; j++) {
            c = match[i].match.data[tables->min_match_len - 1 - j];
            tables->shift[c] = ngx_min(tables->shift[c], (u_char) j);
        }

        c = match[i].match.data[tables->min_match_len - 1];
        while (ch <= (ngx_uint_t) c) {
            tables->index[c...",1,1,http\modules\ngx_http_sub_filter_module.c,ngx_http_sub_init_tables,,false,947,989,ngx_http_sub_init_tables,,,37,"void ngx_http_sub_init_tables (ngx_http_sub_tables_t*,ngx_http_sub_match_t*,ngx_uint_t)"
232754,METHOD,http\modules\ngx_http_sub_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_sub_cmp_matches(const void *one, const void *two)
{
    ngx_int_t              c1, c2;
    ngx_http_sub_match_t  *first, *second;

    first = (ngx_http_sub_match_t *) one;
    second = (ngx_http_sub_match_t *) two;

    c1 = first->match.data[ngx_http_sub_cmp_index];
    c2 = second->match.data[ngx_http_sub_cmp_index];

    return c1 - c2;
}",1,1,http\modules\ngx_http_sub_filter_module.c,ngx_http_sub_cmp_matches,,false,992,1005,ngx_http_sub_cmp_matches,,,38,"ngx_int_t ngx_http_sub_cmp_matches (void*,void*)"
232796,METHOD,http\modules\ngx_http_sub_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_sub_filter_init(ngx_conf_t *cf)
{
    ngx_http_next_header_filter = ngx_http_top_header_filter;
    ngx_http_top_header_filter = ngx_http_sub_header_filter;

    ngx_http_next_body_filter = ngx_http_top_body_filter;
    ngx_http_top_body_filter = ngx_http_sub_body_filter;

    return NGX_OK;
}",1,1,http\modules\ngx_http_sub_filter_module.c,ngx_http_sub_filter_init,,false,1008,1018,ngx_http_sub_filter_init,,,39,ngx_int_t ngx_http_sub_filter_init (ngx_conf_t*)
232824,METHOD,http\modules\ngx_http_try_files_module.c:<global>,TYPE_DECL,<global>,1,1,http\modules\ngx_http_try_files_module.c,http\modules\ngx_http_try_files_module.c:<global>,,false,1,404,<global>,,,1,
232836,METHOD,http\modules\ngx_http_try_files_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_try_files_handler(ngx_http_request_t *r);,18,66,http\modules\ngx_http_try_files_module.c,ngx_http_try_files_handler,,false,28,28,ngx_http_try_files_handler,,,5,ngx_int_t ngx_http_try_files_handler (ngx_http_request_t*)
232841,METHOD,http\modules\ngx_http_try_files_module.c:<global>,TYPE_DECL,"static char *ngx_http_try_files(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",13,79,http\modules\ngx_http_try_files_module.c,ngx_http_try_files,,false,29,29,ngx_http_try_files,,,6,"char* ngx_http_try_files (ngx_conf_t*,ngx_command_t*,void*)"
232848,METHOD,http\modules\ngx_http_try_files_module.c:<global>,TYPE_DECL,static void *ngx_http_try_files_create_loc_conf(ngx_conf_t *cf);,13,63,http\modules\ngx_http_try_files_module.c,ngx_http_try_files_create_loc_conf,,false,30,30,ngx_http_try_files_create_loc_conf,,,7,void* ngx_http_try_files_create_loc_conf (ngx_conf_t*)
232853,METHOD,http\modules\ngx_http_try_files_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_try_files_init(ngx_conf_t *cf);,18,56,http\modules\ngx_http_try_files_module.c,ngx_http_try_files_init,,false,31,31,ngx_http_try_files_init,,,8,ngx_int_t ngx_http_try_files_init (ngx_conf_t*)
232904,METHOD,http\modules\ngx_http_try_files_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_try_files_handler(ngx_http_request_t *r)
{
    size_t                          len, root, alias, reserve, allocated;
    u_char                         *p, *name;
    ngx_str_t                       path, args;
    ngx_uint_t                      test_dir;
    ngx_http_try_file_t            *tf;
    ngx_open_file_info_t            of;
    ngx_http_script_code_pt         code;
    ngx_http_script_engine_t        e;
    ngx_http_core_loc_conf_t       *clcf;
    ngx_http_script_len_code_pt     lcode;
    ngx_http_try_files_loc_conf_t  *tlcf;

    tlcf = ngx_http_get_module_loc_conf(r, ngx_http_try_files_module);

    if (tlcf->try_files == NULL) {
        return NGX_DECLINED;
    }

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""try files handler"");

    allocated = 0;
    root = 0;
    name = NULL;
    /* suppress MSVC warning */
    path.data = NULL;

    tf = tlcf->try_files;

    clcf = ngx_http_get_module_loc_conf(r, ngx...",1,1,http\modules\ngx_http_try_files_module.c,ngx_http_try_files_handler,,false,78,287,ngx_http_try_files_handler,,,15,ngx_int_t ngx_http_try_files_handler (ngx_http_request_t*)
233609,METHOD,http\modules\ngx_http_try_files_module.c:<global>,TYPE_DECL,"static char *
ngx_http_try_files(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_try_files_loc_conf_t *tlcf = conf;

    ngx_str_t                  *value;
    ngx_int_t                   code;
    ngx_uint_t                  i, n;
    ngx_http_try_file_t        *tf;
    ngx_http_script_compile_t   sc;

    if (tlcf->try_files) {
        return ""is duplicate"";
    }

    tf = ngx_pcalloc(cf->pool, cf->args->nelts * sizeof(ngx_http_try_file_t));
    if (tf == NULL) {
        return NGX_CONF_ERROR;
    }

    tlcf->try_files = tf;

    value = cf->args->elts;

    for (i = 0; i < cf->args->nelts - 1; i++) {

        tf[i].name = value[i + 1];

        if (tf[i].name.len > 0
            && tf[i].name.data[tf[i].name.len - 1] == '/'
            && i + 2 < cf->args->nelts)
        {
            tf[i].test_dir = 1;
            tf[i].name.len--;
            tf[i].name.data[tf[i].name.len] = '\0';
        }

        n = ngx_http_script_variables_count(&tf[i].name);

        i...",1,1,http\modules\ngx_http_try_files_module.c,ngx_http_try_files,,false,290,365,ngx_http_try_files,,,16,"char* ngx_http_try_files (ngx_conf_t*,ngx_command_t*,void*)"
233938,METHOD,http\modules\ngx_http_try_files_module.c:<global>,TYPE_DECL,"static void *
ngx_http_try_files_create_loc_conf(ngx_conf_t *cf)
{
    ngx_http_try_files_loc_conf_t  *tlcf;

    tlcf = ngx_pcalloc(cf->pool, sizeof(ngx_http_try_files_loc_conf_t));
    if (tlcf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     tlcf->try_files = NULL;
     */

    return tlcf;
}",1,1,http\modules\ngx_http_try_files_module.c,ngx_http_try_files_create_loc_conf,,false,368,385,ngx_http_try_files_create_loc_conf,,,17,void* ngx_http_try_files_create_loc_conf (ngx_conf_t*)
233961,METHOD,http\modules\ngx_http_try_files_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_try_files_init(ngx_conf_t *cf)
{
    ngx_http_handler_pt        *h;
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);

    h = ngx_array_push(&cmcf->phases[NGX_HTTP_PRECONTENT_PHASE].handlers);
    if (h == NULL) {
        return NGX_ERROR;
    }

    *h = ngx_http_try_files_handler;

    return NGX_OK;
}",1,1,http\modules\ngx_http_try_files_module.c,ngx_http_try_files_init,,false,388,404,ngx_http_try_files_init,,,18,ngx_int_t ngx_http_try_files_init (ngx_conf_t*)
234006,METHOD,http\modules\ngx_http_upstream_hash_module.c:<global>,TYPE_DECL,<global>,1,1,http\modules\ngx_http_upstream_hash_module.c,http\modules\ngx_http_upstream_hash_module.c:<global>,,false,1,686,<global>,,,1,
234015,METHOD,<empty>,<empty>,<empty>,1,,http\modules\ngx_http_upstream_hash_module.c,ngx_http_upstream_chash_points_t:<clinit>,,false,19,,<clinit>,,,3,
234035,METHOD,http\modules\ngx_http_upstream_hash_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_init_hash(ngx_conf_t *cf,
    ngx_http_upstream_srv_conf_t *us);",18,37,http\modules\ngx_http_upstream_hash_module.c,ngx_http_upstream_init_hash,,false,43,44,ngx_http_upstream_init_hash,,,9,"ngx_int_t ngx_http_upstream_init_hash (ngx_conf_t*,ngx_http_upstream_srv_conf_t*)"
234041,METHOD,http\modules\ngx_http_upstream_hash_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_init_hash_peer(ngx_http_request_t *r,
    ngx_http_upstream_srv_conf_t *us);",18,37,http\modules\ngx_http_upstream_hash_module.c,ngx_http_upstream_init_hash_peer,,false,45,46,ngx_http_upstream_init_hash_peer,,,10,"ngx_int_t ngx_http_upstream_init_hash_peer (ngx_http_request_t*,ngx_http_upstream_srv_conf_t*)"
234047,METHOD,http\modules\ngx_http_upstream_hash_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_get_hash_peer(ngx_peer_connection_t *pc,
    void *data);",18,15,http\modules\ngx_http_upstream_hash_module.c,ngx_http_upstream_get_hash_peer,,false,47,48,ngx_http_upstream_get_hash_peer,,,11,"ngx_int_t ngx_http_upstream_get_hash_peer (ngx_peer_connection_t*,void*)"
234053,METHOD,http\modules\ngx_http_upstream_hash_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_init_chash(ngx_conf_t *cf,
    ngx_http_upstream_srv_conf_t *us);",18,37,http\modules\ngx_http_upstream_hash_module.c,ngx_http_upstream_init_chash,,false,50,51,ngx_http_upstream_init_chash,,,12,"ngx_int_t ngx_http_upstream_init_chash (ngx_conf_t*,ngx_http_upstream_srv_conf_t*)"
234061,METHOD,http\modules\ngx_http_upstream_hash_module.c:<global>,TYPE_DECL,"ngx_http_upstream_chash_cmp_points(const void *one, const void *two);",5,72,http\modules\ngx_http_upstream_hash_module.c,ngx_http_upstream_chash_cmp_points,,false,53,53,ngx_http_upstream_chash_cmp_points,,,15,"ANY ngx_http_upstream_chash_cmp_points (void*,void*)"
234067,METHOD,http\modules\ngx_http_upstream_hash_module.c:<global>,TYPE_DECL,"static ngx_uint_t ngx_http_upstream_find_chash_point(
    ngx_http_upstream_chash_points_t *points, uint32_t hash);",19,60,http\modules\ngx_http_upstream_hash_module.c,ngx_http_upstream_find_chash_point,,false,54,55,ngx_http_upstream_find_chash_point,,,16,"ngx_uint_t ngx_http_upstream_find_chash_point (ngx_http_upstream_chash_points_t*,uint32_t)"
234073,METHOD,http\modules\ngx_http_upstream_hash_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_init_chash_peer(ngx_http_request_t *r,
    ngx_http_upstream_srv_conf_t *us);",18,37,http\modules\ngx_http_upstream_hash_module.c,ngx_http_upstream_init_chash_peer,,false,56,57,ngx_http_upstream_init_chash_peer,,,17,"ngx_int_t ngx_http_upstream_init_chash_peer (ngx_http_request_t*,ngx_http_upstream_srv_conf_t*)"
234079,METHOD,http\modules\ngx_http_upstream_hash_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_get_chash_peer(ngx_peer_connection_t *pc,
    void *data);",18,15,http\modules\ngx_http_upstream_hash_module.c,ngx_http_upstream_get_chash_peer,,false,58,59,ngx_http_upstream_get_chash_peer,,,18,"ngx_int_t ngx_http_upstream_get_chash_peer (ngx_peer_connection_t*,void*)"
234085,METHOD,http\modules\ngx_http_upstream_hash_module.c:<global>,TYPE_DECL,static void *ngx_http_upstream_hash_create_conf(ngx_conf_t *cf);,13,63,http\modules\ngx_http_upstream_hash_module.c,ngx_http_upstream_hash_create_conf,,false,61,61,ngx_http_upstream_hash_create_conf,,,19,void* ngx_http_upstream_hash_create_conf (ngx_conf_t*)
234090,METHOD,http\modules\ngx_http_upstream_hash_module.c:<global>,TYPE_DECL,"static char *ngx_http_upstream_hash(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_upstream_hash_module.c,ngx_http_upstream_hash,,false,62,63,ngx_http_upstream_hash,,,20,"char* ngx_http_upstream_hash (ngx_conf_t*,ngx_command_t*,void*)"
234141,METHOD,http\modules\ngx_http_upstream_hash_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_init_hash(ngx_conf_t *cf, ngx_http_upstream_srv_conf_t *us)
{
    if (ngx_http_upstream_init_round_robin(cf, us) != NGX_OK) {
        return NGX_ERROR;
    }

    us->peer.init = ngx_http_upstream_init_hash_peer;

    return NGX_OK;
}",1,1,http\modules\ngx_http_upstream_hash_module.c,ngx_http_upstream_init_hash,,false,110,120,ngx_http_upstream_init_hash,,,27,"ngx_int_t ngx_http_upstream_init_hash (ngx_conf_t*,ngx_http_upstream_srv_conf_t*)"
234165,METHOD,http\modules\ngx_http_upstream_hash_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_init_hash_peer(ngx_http_request_t *r,
    ngx_http_upstream_srv_conf_t *us)
{
    ngx_http_upstream_hash_srv_conf_t   *hcf;
    ngx_http_upstream_hash_peer_data_t  *hp;

    hp = ngx_palloc(r->pool, sizeof(ngx_http_upstream_hash_peer_data_t));
    if (hp == NULL) {
        return NGX_ERROR;
    }

    r->upstream->peer.data = &hp->rrp;

    if (ngx_http_upstream_init_round_robin_peer(r, us) != NGX_OK) {
        return NGX_ERROR;
    }

    r->upstream->peer.get = ngx_http_upstream_get_hash_peer;

    hcf = ngx_http_conf_upstream_srv_conf(us, ngx_http_upstream_hash_module);

    if (ngx_http_complex_value(r, &hcf->key, &hp->key) != NGX_OK) {
        return NGX_ERROR;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""upstream hash key:\""%V\"""", &hp->key);

    hp->conf = hcf;
    hp->tries = 0;
    hp->rehash = 0;
    hp->hash = 0;
    hp->get_rr_peer = ngx_http_upstream_get_round_robin_peer;

    return NGX_OK;
}",1,1,http\modules\ngx_http_upstream_hash_module.c,ngx_http_upstream_init_hash_peer,,false,123,159,ngx_http_upstream_init_hash_peer,,,28,"ngx_int_t ngx_http_upstream_init_hash_peer (ngx_http_request_t*,ngx_http_upstream_srv_conf_t*)"
234279,METHOD,http\modules\ngx_http_upstream_hash_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_get_hash_peer(ngx_peer_connection_t *pc, void *data)
{
    ngx_http_upstream_hash_peer_data_t  *hp = data;

    time_t                        now;
    u_char                        buf[NGX_INT_T_LEN];
    size_t                        size;
    uint32_t                      hash;
    ngx_int_t                     w;
    uintptr_t                     m;
    ngx_uint_t                    n, p;
    ngx_http_upstream_rr_peer_t  *peer;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, pc->log, 0,
                   ""get hash peer, try: %ui"", pc->tries);

    ngx_http_upstream_rr_peers_rlock(hp->rrp.peers);

    if (hp->tries > 20 || hp->rrp.peers->single || hp->key.len == 0) {
        ngx_http_upstream_rr_peers_unlock(hp->rrp.peers);
        return hp->get_rr_peer(pc, &hp->rrp);
    }

    now = ngx_time();

    pc->cached = 0;
    pc->connection = NULL;

    for ( ;; ) {

        /*
         * Hash expression is compatible with Cache::Memcached:
         * ((crc...",1,1,http\modules\ngx_http_upstream_hash_module.c,ngx_http_upstream_get_hash_peer,,false,162,282,ngx_http_upstream_get_hash_peer,,,29,"ngx_int_t ngx_http_upstream_get_hash_peer (ngx_peer_connection_t*,void*)"
234682,METHOD,http\modules\ngx_http_upstream_hash_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_init_chash(ngx_conf_t *cf, ngx_http_upstream_srv_conf_t *us)
{
    u_char                             *host, *port, c;
    size_t                              host_len, port_len, size;
    uint32_t                            hash, base_hash;
    ngx_str_t                          *server;
    ngx_uint_t                          npoints, i, j;
    ngx_http_upstream_rr_peer_t        *peer;
    ngx_http_upstream_rr_peers_t       *peers;
    ngx_http_upstream_chash_points_t   *points;
    ngx_http_upstream_hash_srv_conf_t  *hcf;
    union {
        uint32_t                        value;
        u_char                          byte[4];
    } prev_hash;

    if (ngx_http_upstream_init_round_robin(cf, us) != NGX_OK) {
        return NGX_ERROR;
    }

    us->peer.init = ngx_http_upstream_init_chash_peer;

    peers = us->peer.data;
    npoints = peers->total_weight * 160;

    size = sizeof(ngx_http_upstream_chash_points_t)
           + sizeof(ngx_http_up...",1,1,http\modules\ngx_http_upstream_hash_module.c,ngx_http_upstream_init_chash,,false,285,408,ngx_http_upstream_init_chash,,,30,"ngx_int_t ngx_http_upstream_init_chash (ngx_conf_t*,ngx_http_upstream_srv_conf_t*)"
235114,METHOD,http\modules\ngx_http_upstream_hash_module.c:<global>,TYPE_DECL,"ngx_http_upstream_chash_cmp_points(const void *one, const void *two)
{
    ngx_http_upstream_chash_point_t *first =
                                       (ngx_http_upstream_chash_point_t *) one;
    ngx_http_upstream_chash_point_t *second =
                                       (ngx_http_upstream_chash_point_t *) two;

    if (first->hash < second->hash) {
        return -1;

    } else if (first->hash > second->hash) {
        return 1;

    } else {
        return 0;
    }
}",1,1,http\modules\ngx_http_upstream_hash_module.c,ngx_http_upstream_chash_cmp_points,,false,412,428,ngx_http_upstream_chash_cmp_points,,,33,"ANY ngx_http_upstream_chash_cmp_points (void*,void*)"
235161,METHOD,http\modules\ngx_http_upstream_hash_module.c:<global>,TYPE_DECL,"static ngx_uint_t
ngx_http_upstream_find_chash_point(ngx_http_upstream_chash_points_t *points,
    uint32_t hash)
{
    ngx_uint_t                        i, j, k;
    ngx_http_upstream_chash_point_t  *point;

    /* find first point >= hash */

    point = &points->point[0];

    i = 0;
    j = points->number;

    while (i < j) {
        k = (i + j) / 2;

        if (hash > point[k].hash) {
            i = k + 1;

        } else if (hash < point[k].hash) {
            j = k;

        } else {
            return k;
        }
    }

    return i;
}",1,1,http\modules\ngx_http_upstream_hash_module.c,ngx_http_upstream_find_chash_point,,false,431,460,ngx_http_upstream_find_chash_point,,,34,"ngx_uint_t ngx_http_upstream_find_chash_point (ngx_http_upstream_chash_points_t*,uint32_t)"
235233,METHOD,http\modules\ngx_http_upstream_hash_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_init_chash_peer(ngx_http_request_t *r,
    ngx_http_upstream_srv_conf_t *us)
{
    uint32_t                             hash;
    ngx_http_upstream_hash_srv_conf_t   *hcf;
    ngx_http_upstream_hash_peer_data_t  *hp;

    if (ngx_http_upstream_init_hash_peer(r, us) != NGX_OK) {
        return NGX_ERROR;
    }

    r->upstream->peer.get = ngx_http_upstream_get_chash_peer;

    hp = r->upstream->peer.data;
    hcf = ngx_http_conf_upstream_srv_conf(us, ngx_http_upstream_hash_module);

    hash = ngx_crc32_long(hp->key.data, hp->key.len);

    ngx_http_upstream_rr_peers_rlock(hp->rrp.peers);

    hp->hash = ngx_http_upstream_find_chash_point(hcf->points, hash);

    ngx_http_upstream_rr_peers_unlock(hp->rrp.peers);

    return NGX_OK;
}",1,1,http\modules\ngx_http_upstream_hash_module.c,ngx_http_upstream_init_chash_peer,,false,463,489,ngx_http_upstream_init_chash_peer,,,35,"ngx_int_t ngx_http_upstream_init_chash_peer (ngx_http_request_t*,ngx_http_upstream_srv_conf_t*)"
235310,METHOD,http\modules\ngx_http_upstream_hash_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_get_chash_peer(ngx_peer_connection_t *pc, void *data)
{
    ngx_http_upstream_hash_peer_data_t  *hp = data;

    time_t                              now;
    intptr_t                            m;
    ngx_str_t                          *server;
    ngx_int_t                           total;
    ngx_uint_t                          i, n, best_i;
    ngx_http_upstream_rr_peer_t        *peer, *best;
    ngx_http_upstream_chash_point_t    *point;
    ngx_http_upstream_chash_points_t   *points;
    ngx_http_upstream_hash_srv_conf_t  *hcf;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, pc->log, 0,
                   ""get consistent hash peer, try: %ui"", pc->tries);

    ngx_http_upstream_rr_peers_wlock(hp->rrp.peers);

    if (hp->tries > 20 || hp->rrp.peers->single || hp->key.len == 0) {
        ngx_http_upstream_rr_peers_unlock(hp->rrp.peers);
        return hp->get_rr_peer(pc, &hp->rrp);
    }

    pc->cached = 0;
    pc->connection = NULL;

    now = ngx_tim...",1,1,http\modules\ngx_http_upstream_hash_module.c,ngx_http_upstream_get_chash_peer,,false,492,619,ngx_http_upstream_get_chash_peer,,,36,"ngx_int_t ngx_http_upstream_get_chash_peer (ngx_peer_connection_t*,void*)"
235753,METHOD,http\modules\ngx_http_upstream_hash_module.c:<global>,TYPE_DECL,"static void *
ngx_http_upstream_hash_create_conf(ngx_conf_t *cf)
{
    ngx_http_upstream_hash_srv_conf_t  *conf;

    conf = ngx_palloc(cf->pool, sizeof(ngx_http_upstream_hash_srv_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    conf->points = NULL;

    return conf;
}",1,1,http\modules\ngx_http_upstream_hash_module.c,ngx_http_upstream_hash_create_conf,,false,622,635,ngx_http_upstream_hash_create_conf,,,37,void* ngx_http_upstream_hash_create_conf (ngx_conf_t*)
235781,METHOD,http\modules\ngx_http_upstream_hash_module.c:<global>,TYPE_DECL,"static char *
ngx_http_upstream_hash(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_upstream_hash_srv_conf_t  *hcf = conf;

    ngx_str_t                         *value;
    ngx_http_upstream_srv_conf_t      *uscf;
    ngx_http_compile_complex_value_t   ccv;

    value = cf->args->elts;

    ngx_memzero(&ccv, sizeof(ngx_http_compile_complex_value_t));

    ccv.cf = cf;
    ccv.value = &value[1];
    ccv.complex_value = &hcf->key;

    if (ngx_http_compile_complex_value(&ccv) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    uscf = ngx_http_conf_get_module_srv_conf(cf, ngx_http_upstream_module);

    if (uscf->peer.init_upstream) {
        ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
                           ""load balancing method redefined"");
    }

    uscf->flags = NGX_HTTP_UPSTREAM_CREATE
                  |NGX_HTTP_UPSTREAM_WEIGHT
                  |NGX_HTTP_UPSTREAM_MAX_CONNS
                  |NGX_HTTP_UPSTREAM_MAX_FAILS
                  |NGX_HTTP_UPSTREAM_F...",1,1,http\modules\ngx_http_upstream_hash_module.c,ngx_http_upstream_hash,,false,638,686,ngx_http_upstream_hash,,,38,"char* ngx_http_upstream_hash (ngx_conf_t*,ngx_command_t*,void*)"
235929,METHOD,http\modules\ngx_http_upstream_ip_hash_module.c:<global>,TYPE_DECL,<global>,1,1,http\modules\ngx_http_upstream_ip_hash_module.c,http\modules\ngx_http_upstream_ip_hash_module.c:<global>,,false,1,278,<global>,,,1,
235939,METHOD,http\modules\ngx_http_upstream_ip_hash_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_init_ip_hash_peer(ngx_http_request_t *r,
    ngx_http_upstream_srv_conf_t *us);",18,37,http\modules\ngx_http_upstream_ip_hash_module.c,ngx_http_upstream_init_ip_hash_peer,,false,28,29,ngx_http_upstream_init_ip_hash_peer,,,3,"ngx_int_t ngx_http_upstream_init_ip_hash_peer (ngx_http_request_t*,ngx_http_upstream_srv_conf_t*)"
235945,METHOD,http\modules\ngx_http_upstream_ip_hash_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_get_ip_hash_peer(ngx_peer_connection_t *pc,
    void *data);",18,15,http\modules\ngx_http_upstream_ip_hash_module.c,ngx_http_upstream_get_ip_hash_peer,,false,30,31,ngx_http_upstream_get_ip_hash_peer,,,4,"ngx_int_t ngx_http_upstream_get_ip_hash_peer (ngx_peer_connection_t*,void*)"
235951,METHOD,http\modules\ngx_http_upstream_ip_hash_module.c:<global>,TYPE_DECL,"static char *ngx_http_upstream_ip_hash(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_upstream_ip_hash_module.c,ngx_http_upstream_ip_hash,,false,32,33,ngx_http_upstream_ip_hash,,,5,"char* ngx_http_upstream_ip_hash (ngx_conf_t*,ngx_command_t*,void*)"
236005,METHOD,http\modules\ngx_http_upstream_ip_hash_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_init_ip_hash(ngx_conf_t *cf, ngx_http_upstream_srv_conf_t *us)
{
    if (ngx_http_upstream_init_round_robin(cf, us) != NGX_OK) {
        return NGX_ERROR;
    }

    us->peer.init = ngx_http_upstream_init_ip_hash_peer;

    return NGX_OK;
}",1,1,http\modules\ngx_http_upstream_ip_hash_module.c,ngx_http_upstream_init_ip_hash,,false,83,93,ngx_http_upstream_init_ip_hash,,,14,"ngx_int_t ngx_http_upstream_init_ip_hash (ngx_conf_t*,ngx_http_upstream_srv_conf_t*)"
236029,METHOD,http\modules\ngx_http_upstream_ip_hash_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_init_ip_hash_peer(ngx_http_request_t *r,
    ngx_http_upstream_srv_conf_t *us)
{
    struct sockaddr_in                     *sin;
#if (NGX_HAVE_INET6)
    struct sockaddr_in6                    *sin6;
#endif
    ngx_http_upstream_ip_hash_peer_data_t  *iphp;

    iphp = ngx_palloc(r->pool, sizeof(ngx_http_upstream_ip_hash_peer_data_t));
    if (iphp == NULL) {
        return NGX_ERROR;
    }

    r->upstream->peer.data = &iphp->rrp;

    if (ngx_http_upstream_init_round_robin_peer(r, us) != NGX_OK) {
        return NGX_ERROR;
    }

    r->upstream->peer.get = ngx_http_upstream_get_ip_hash_peer;

    switch (r->connection->sockaddr->sa_family) {

    case AF_INET:
        sin = (struct sockaddr_in *) r->connection->sockaddr;
        iphp->addr = (u_char *) &sin->sin_addr.s_addr;
        iphp->addrlen = 3;
        break;

#if (NGX_HAVE_INET6)
    case AF_INET6:
        sin6 = (struct sockaddr_in6 *) r->connection->sockaddr;
        iphp->addr = (u_ch...",1,1,http\modules\ngx_http_upstream_ip_hash_module.c,ngx_http_upstream_init_ip_hash_peer,,false,96,145,ngx_http_upstream_init_ip_hash_peer,,,15,"ngx_int_t ngx_http_upstream_init_ip_hash_peer (ngx_http_request_t*,ngx_http_upstream_srv_conf_t*)"
236148,METHOD,http\modules\ngx_http_upstream_ip_hash_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_get_ip_hash_peer(ngx_peer_connection_t *pc, void *data)
{
    ngx_http_upstream_ip_hash_peer_data_t  *iphp = data;

    time_t                        now;
    ngx_int_t                     w;
    uintptr_t                     m;
    ngx_uint_t                    i, n, p, hash;
    ngx_http_upstream_rr_peer_t  *peer;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, pc->log, 0,
                   ""get ip hash peer, try: %ui"", pc->tries);

    /* TODO: cached */

    ngx_http_upstream_rr_peers_rlock(iphp->rrp.peers);

    if (iphp->tries > 20 || iphp->rrp.peers->single) {
        ngx_http_upstream_rr_peers_unlock(iphp->rrp.peers);
        return iphp->get_rr_peer(pc, &iphp->rrp);
    }

    now = ngx_time();

    pc->cached = 0;
    pc->connection = NULL;

    hash = iphp->hash;

    for ( ;; ) {

        for (i = 0; i < (ngx_uint_t) iphp->addrlen; i++) {
            hash = (hash * 113 + iphp->addr[i]) % 6271;
        }

        w = hash % iphp->rrp.peers->tot...",1,1,http\modules\ngx_http_upstream_ip_hash_module.c,ngx_http_upstream_get_ip_hash_peer,,false,148,253,ngx_http_upstream_get_ip_hash_peer,,,16,"ngx_int_t ngx_http_upstream_get_ip_hash_peer (ngx_peer_connection_t*,void*)"
236523,METHOD,http\modules\ngx_http_upstream_ip_hash_module.c:<global>,TYPE_DECL,"static char *
ngx_http_upstream_ip_hash(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_upstream_srv_conf_t  *uscf;

    uscf = ngx_http_conf_get_module_srv_conf(cf, ngx_http_upstream_module);

    if (uscf->peer.init_upstream) {
        ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
                           ""load balancing method redefined"");
    }

    uscf->peer.init_upstream = ngx_http_upstream_init_ip_hash;

    uscf->flags = NGX_HTTP_UPSTREAM_CREATE
                  |NGX_HTTP_UPSTREAM_WEIGHT
                  |NGX_HTTP_UPSTREAM_MAX_CONNS
                  |NGX_HTTP_UPSTREAM_MAX_FAILS
                  |NGX_HTTP_UPSTREAM_FAIL_TIMEOUT
                  |NGX_HTTP_UPSTREAM_DOWN;

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_upstream_ip_hash_module.c,ngx_http_upstream_ip_hash,,false,256,278,ngx_http_upstream_ip_hash,,,17,"char* ngx_http_upstream_ip_hash (ngx_conf_t*,ngx_command_t*,void*)"
236581,METHOD,http\modules\ngx_http_upstream_keepalive_module.c:<global>,TYPE_DECL,<global>,1,1,http\modules\ngx_http_upstream_keepalive_module.c,http\modules\ngx_http_upstream_keepalive_module.c:<global>,,false,1,562,<global>,,,1,
236608,METHOD,http\modules\ngx_http_upstream_keepalive_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_init_keepalive_peer(ngx_http_request_t *r,
    ngx_http_upstream_srv_conf_t *us);",18,37,http\modules\ngx_http_upstream_keepalive_module.c,ngx_http_upstream_init_keepalive_peer,,false,57,58,ngx_http_upstream_init_keepalive_peer,,,7,"ngx_int_t ngx_http_upstream_init_keepalive_peer (ngx_http_request_t*,ngx_http_upstream_srv_conf_t*)"
236614,METHOD,http\modules\ngx_http_upstream_keepalive_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_get_keepalive_peer(ngx_peer_connection_t *pc,
    void *data);",18,15,http\modules\ngx_http_upstream_keepalive_module.c,ngx_http_upstream_get_keepalive_peer,,false,59,60,ngx_http_upstream_get_keepalive_peer,,,8,"ngx_int_t ngx_http_upstream_get_keepalive_peer (ngx_peer_connection_t*,void*)"
236620,METHOD,http\modules\ngx_http_upstream_keepalive_module.c:<global>,TYPE_DECL,"static void ngx_http_upstream_free_keepalive_peer(ngx_peer_connection_t *pc,
    void *data, ngx_uint_t state);",13,33,http\modules\ngx_http_upstream_keepalive_module.c,ngx_http_upstream_free_keepalive_peer,,false,61,62,ngx_http_upstream_free_keepalive_peer,,,9,"void ngx_http_upstream_free_keepalive_peer (ngx_peer_connection_t*,void*,ngx_uint_t)"
236627,METHOD,http\modules\ngx_http_upstream_keepalive_module.c:<global>,TYPE_DECL,static void ngx_http_upstream_keepalive_dummy_handler(ngx_event_t *ev);,13,70,http\modules\ngx_http_upstream_keepalive_module.c,ngx_http_upstream_keepalive_dummy_handler,,false,64,64,ngx_http_upstream_keepalive_dummy_handler,,,10,void ngx_http_upstream_keepalive_dummy_handler (ngx_event_t*)
236632,METHOD,http\modules\ngx_http_upstream_keepalive_module.c:<global>,TYPE_DECL,static void ngx_http_upstream_keepalive_close_handler(ngx_event_t *ev);,13,70,http\modules\ngx_http_upstream_keepalive_module.c,ngx_http_upstream_keepalive_close_handler,,false,65,65,ngx_http_upstream_keepalive_close_handler,,,11,void ngx_http_upstream_keepalive_close_handler (ngx_event_t*)
236637,METHOD,http\modules\ngx_http_upstream_keepalive_module.c:<global>,TYPE_DECL,static void ngx_http_upstream_keepalive_close(ngx_connection_t *c);,13,66,http\modules\ngx_http_upstream_keepalive_module.c,ngx_http_upstream_keepalive_close,,false,66,66,ngx_http_upstream_keepalive_close,,,12,void ngx_http_upstream_keepalive_close (ngx_connection_t*)
236642,METHOD,http\modules\ngx_http_upstream_keepalive_module.c:<global>,TYPE_DECL,static void *ngx_http_upstream_keepalive_create_conf(ngx_conf_t *cf);,13,68,http\modules\ngx_http_upstream_keepalive_module.c,ngx_http_upstream_keepalive_create_conf,,false,75,75,ngx_http_upstream_keepalive_create_conf,,,13,void* ngx_http_upstream_keepalive_create_conf (ngx_conf_t*)
236647,METHOD,http\modules\ngx_http_upstream_keepalive_module.c:<global>,TYPE_DECL,"static char *ngx_http_upstream_keepalive(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_upstream_keepalive_module.c,ngx_http_upstream_keepalive,,false,76,77,ngx_http_upstream_keepalive,,,14,"char* ngx_http_upstream_keepalive (ngx_conf_t*,ngx_command_t*,void*)"
236722,METHOD,http\modules\ngx_http_upstream_keepalive_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_init_keepalive(ngx_conf_t *cf,
    ngx_http_upstream_srv_conf_t *us)
{
    ngx_uint_t                               i;
    ngx_http_upstream_keepalive_srv_conf_t  *kcf;
    ngx_http_upstream_keepalive_cache_t     *cached;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, cf->log, 0,
                   ""init keepalive"");

    kcf = ngx_http_conf_upstream_srv_conf(us,
                                          ngx_http_upstream_keepalive_module);

    ngx_conf_init_msec_value(kcf->timeout, 60000);
    ngx_conf_init_uint_value(kcf->requests, 100);

    if (kcf->original_init_upstream(cf, us) != NGX_OK) {
        return NGX_ERROR;
    }

    kcf->original_init_peer = us->peer.init;

    us->peer.init = ngx_http_upstream_init_keepalive_peer;

    /* allocate cache items and add to free queue */

    cached = ngx_pcalloc(cf->pool,
                sizeof(ngx_http_upstream_keepalive_cache_t) * kcf->max_cached);
    if (cached == NULL) {
        return NGX_ERROR;
    ...",1,1,http\modules\ngx_http_upstream_keepalive_module.c,ngx_http_upstream_init_keepalive,,false,138,180,ngx_http_upstream_init_keepalive,,,21,"ngx_int_t ngx_http_upstream_init_keepalive (ngx_conf_t*,ngx_http_upstream_srv_conf_t*)"
236843,METHOD,http\modules\ngx_http_upstream_keepalive_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_init_keepalive_peer(ngx_http_request_t *r,
    ngx_http_upstream_srv_conf_t *us)
{
    ngx_http_upstream_keepalive_peer_data_t  *kp;
    ngx_http_upstream_keepalive_srv_conf_t   *kcf;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""init keepalive peer"");

    kcf = ngx_http_conf_upstream_srv_conf(us,
                                          ngx_http_upstream_keepalive_module);

    kp = ngx_palloc(r->pool, sizeof(ngx_http_upstream_keepalive_peer_data_t));
    if (kp == NULL) {
        return NGX_ERROR;
    }

    if (kcf->original_init_peer(r, us) != NGX_OK) {
        return NGX_ERROR;
    }

    kp->conf = kcf;
    kp->upstream = r->upstream;
    kp->data = r->upstream->peer.data;
    kp->original_get_peer = r->upstream->peer.get;
    kp->original_free_peer = r->upstream->peer.free;

    r->upstream->peer.data = kp;
    r->upstream->peer.get = ngx_http_upstream_get_keepalive_peer;
    r->upstream->peer.free = ng...",1,1,http\modules\ngx_http_upstream_keepalive_module.c,ngx_http_upstream_init_keepalive_peer,,false,183,223,ngx_http_upstream_init_keepalive_peer,,,22,"ngx_int_t ngx_http_upstream_init_keepalive_peer (ngx_http_request_t*,ngx_http_upstream_srv_conf_t*)"
236966,METHOD,http\modules\ngx_http_upstream_keepalive_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_get_keepalive_peer(ngx_peer_connection_t *pc, void *data)
{
    ngx_http_upstream_keepalive_peer_data_t  *kp = data;
    ngx_http_upstream_keepalive_cache_t      *item;

    ngx_int_t          rc;
    ngx_queue_t       *q, *cache;
    ngx_connection_t  *c;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, pc->log, 0,
                   ""get keepalive peer"");

    /* ask balancer */

    rc = kp->original_get_peer(pc, kp->data);

    if (rc != NGX_OK) {
        return rc;
    }

    /* search cache for suitable connection */

    cache = &kp->conf->cache;

    for (q = ngx_queue_head(cache);
         q != ngx_queue_sentinel(cache);
         q = ngx_queue_next(q))
    {
        item = ngx_queue_data(q, ngx_http_upstream_keepalive_cache_t, queue);
        c = item->connection;

        if (ngx_memn2cmp((u_char *) &item->sockaddr, (u_char *) pc->sockaddr,
                         item->socklen, pc->socklen)
            == 0)
        {
            ngx_queue_remov...",1,1,http\modules\ngx_http_upstream_keepalive_module.c,ngx_http_upstream_get_keepalive_peer,,false,226,292,ngx_http_upstream_get_keepalive_peer,,,23,"ngx_int_t ngx_http_upstream_get_keepalive_peer (ngx_peer_connection_t*,void*)"
237155,METHOD,http\modules\ngx_http_upstream_keepalive_module.c:<global>,TYPE_DECL,"static void
ngx_http_upstream_free_keepalive_peer(ngx_peer_connection_t *pc, void *data,
    ngx_uint_t state)
{
    ngx_http_upstream_keepalive_peer_data_t  *kp = data;
    ngx_http_upstream_keepalive_cache_t      *item;

    ngx_queue_t          *q;
    ngx_connection_t     *c;
    ngx_http_upstream_t  *u;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, pc->log, 0,
                   ""free keepalive peer"");

    /* cache valid connections */

    u = kp->upstream;
    c = pc->connection;

    if (state & NGX_PEER_FAILED
        || c == NULL
        || c->read->eof
        || c->read->error
        || c->read->timedout
        || c->write->error
        || c->write->timedout)
    {
        goto invalid;
    }

    if (c->requests >= kp->conf->requests) {
        goto invalid;
    }

    if (!u->keepalive) {
        goto invalid;
    }

    if (!u->request_body_sent) {
        goto invalid;
    }

    if (ngx_terminate || ngx_exiting) {
        goto invalid;
    }

    if (ngx_handle_read_e...",1,1,http\modules\ngx_http_upstream_keepalive_module.c,ngx_http_upstream_free_keepalive_peer,,false,295,397,ngx_http_upstream_free_keepalive_peer,,,24,"void ngx_http_upstream_free_keepalive_peer (ngx_peer_connection_t*,void*,ngx_uint_t)"
237468,METHOD,http\modules\ngx_http_upstream_keepalive_module.c:<global>,TYPE_DECL,"static void
ngx_http_upstream_keepalive_dummy_handler(ngx_event_t *ev)
{
    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, ev->log, 0,
                   ""keepalive dummy handler"");
}",1,1,http\modules\ngx_http_upstream_keepalive_module.c,ngx_http_upstream_keepalive_dummy_handler,,false,400,405,ngx_http_upstream_keepalive_dummy_handler,,,25,void ngx_http_upstream_keepalive_dummy_handler (ngx_event_t*)
237480,METHOD,http\modules\ngx_http_upstream_keepalive_module.c:<global>,TYPE_DECL,"static void
ngx_http_upstream_keepalive_close_handler(ngx_event_t *ev)
{
    ngx_http_upstream_keepalive_srv_conf_t  *conf;
    ngx_http_upstream_keepalive_cache_t     *item;

    int                n;
    char               buf[1];
    ngx_connection_t  *c;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, ev->log, 0,
                   ""keepalive close handler"");

    c = ev->data;

    if (c->close || c->read->timedout) {
        goto close;
    }

    n = recv(c->fd, buf, 1, MSG_PEEK);

    if (n == -1 && ngx_socket_errno == NGX_EAGAIN) {
        ev->ready = 0;

        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
            goto close;
        }

        return;
    }

close:

    item = c->data;
    conf = item->conf;

    ngx_http_upstream_keepalive_close(c);

    ngx_queue_remove(&item->queue);
    ngx_queue_insert_head(&conf->free, &item->queue);
}",1,1,http\modules\ngx_http_upstream_keepalive_module.c,ngx_http_upstream_keepalive_close_handler,,false,408,448,ngx_http_upstream_keepalive_close_handler,,,26,void ngx_http_upstream_keepalive_close_handler (ngx_event_t*)
237576,METHOD,http\modules\ngx_http_upstream_keepalive_module.c:<global>,TYPE_DECL,"static void
ngx_http_upstream_keepalive_close(ngx_connection_t *c)
{

#if (NGX_HTTP_SSL)

    if (c->ssl) {
        c->ssl->no_wait_shutdown = 1;
        c->ssl->no_send_shutdown = 1;

        if (ngx_ssl_shutdown(c) == NGX_AGAIN) {
            c->ssl->handler = ngx_http_upstream_keepalive_close;
            return;
        }
    }

#endif

    ngx_destroy_pool(c->pool);
    ngx_close_connection(c);
}",1,1,http\modules\ngx_http_upstream_keepalive_module.c,ngx_http_upstream_keepalive_close,,false,451,471,ngx_http_upstream_keepalive_close,,,27,void ngx_http_upstream_keepalive_close (ngx_connection_t*)
237587,METHOD,http\modules\ngx_http_upstream_keepalive_module.c:<global>,TYPE_DECL,"static void *
ngx_http_upstream_keepalive_create_conf(ngx_conf_t *cf)
{
    ngx_http_upstream_keepalive_srv_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool,
                       sizeof(ngx_http_upstream_keepalive_srv_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     conf->original_init_upstream = NULL;
     *     conf->original_init_peer = NULL;
     *     conf->max_cached = 0;
     */

    conf->timeout = NGX_CONF_UNSET_MSEC;
    conf->requests = NGX_CONF_UNSET_UINT;

    return conf;
}",1,1,http\modules\ngx_http_upstream_keepalive_module.c,ngx_http_upstream_keepalive_create_conf,,false,497,520,ngx_http_upstream_keepalive_create_conf,,,28,void* ngx_http_upstream_keepalive_create_conf (ngx_conf_t*)
237620,METHOD,http\modules\ngx_http_upstream_keepalive_module.c:<global>,TYPE_DECL,"static char *
ngx_http_upstream_keepalive(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_upstream_srv_conf_t            *uscf;
    ngx_http_upstream_keepalive_srv_conf_t  *kcf = conf;

    ngx_int_t    n;
    ngx_str_t   *value;

    if (kcf->max_cached) {
        return ""is duplicate"";
    }

    /* read options */

    value = cf->args->elts;

    n = ngx_atoi(value[1].data, value[1].len);

    if (n == NGX_ERROR || n == 0) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""invalid value \""%V\"" in \""%V\"" directive"",
                           &value[1], &cmd->name);
        return NGX_CONF_ERROR;
    }

    kcf->max_cached = n;

    /* init upstream handler */

    uscf = ngx_http_conf_get_module_srv_conf(cf, ngx_http_upstream_module);

    kcf->original_init_upstream = uscf->peer.init_upstream
                                  ? uscf->peer.init_upstream
                                  : ngx_http_upstream_init_round_robin;

    uscf->p...",1,1,http\modules\ngx_http_upstream_keepalive_module.c,ngx_http_upstream_keepalive,,false,523,562,ngx_http_upstream_keepalive,,,29,"char* ngx_http_upstream_keepalive (ngx_conf_t*,ngx_command_t*,void*)"
237729,METHOD,http\modules\ngx_http_upstream_least_conn_module.c:<global>,TYPE_DECL,<global>,1,1,http\modules\ngx_http_upstream_least_conn_module.c,http\modules\ngx_http_upstream_least_conn_module.c:<global>,,false,1,314,<global>,,,1,
237731,METHOD,http\modules\ngx_http_upstream_least_conn_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_init_least_conn_peer(ngx_http_request_t *r,
    ngx_http_upstream_srv_conf_t *us);",18,37,http\modules\ngx_http_upstream_least_conn_module.c,ngx_http_upstream_init_least_conn_peer,,false,13,14,ngx_http_upstream_init_least_conn_peer,,,1,"ngx_int_t ngx_http_upstream_init_least_conn_peer (ngx_http_request_t*,ngx_http_upstream_srv_conf_t*)"
237737,METHOD,http\modules\ngx_http_upstream_least_conn_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_get_least_conn_peer(
    ngx_peer_connection_t *pc, void *data);",18,42,http\modules\ngx_http_upstream_least_conn_module.c,ngx_http_upstream_get_least_conn_peer,,false,15,16,ngx_http_upstream_get_least_conn_peer,,,2,"ngx_int_t ngx_http_upstream_get_least_conn_peer (ngx_peer_connection_t*,void*)"
237743,METHOD,http\modules\ngx_http_upstream_least_conn_module.c:<global>,TYPE_DECL,"static char *ngx_http_upstream_least_conn(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_upstream_least_conn_module.c,ngx_http_upstream_least_conn,,false,17,18,ngx_http_upstream_least_conn,,,3,"char* ngx_http_upstream_least_conn (ngx_conf_t*,ngx_command_t*,void*)"
237794,METHOD,http\modules\ngx_http_upstream_least_conn_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_init_least_conn(ngx_conf_t *cf,
    ngx_http_upstream_srv_conf_t *us)
{
    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, cf->log, 0,
                   ""init least conn"");

    if (ngx_http_upstream_init_round_robin(cf, us) != NGX_OK) {
        return NGX_ERROR;
    }

    us->peer.init = ngx_http_upstream_init_least_conn_peer;

    return NGX_OK;
}",1,1,http\modules\ngx_http_upstream_least_conn_module.c,ngx_http_upstream_init_least_conn,,false,65,79,ngx_http_upstream_init_least_conn,,,10,"ngx_int_t ngx_http_upstream_init_least_conn (ngx_conf_t*,ngx_http_upstream_srv_conf_t*)"
237825,METHOD,http\modules\ngx_http_upstream_least_conn_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_init_least_conn_peer(ngx_http_request_t *r,
    ngx_http_upstream_srv_conf_t *us)
{
    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""init least conn peer"");

    if (ngx_http_upstream_init_round_robin_peer(r, us) != NGX_OK) {
        return NGX_ERROR;
    }

    r->upstream->peer.get = ngx_http_upstream_get_least_conn_peer;

    return NGX_OK;
}",1,1,http\modules\ngx_http_upstream_least_conn_module.c,ngx_http_upstream_init_least_conn_peer,,false,82,96,ngx_http_upstream_init_least_conn_peer,,,11,"ngx_int_t ngx_http_upstream_init_least_conn_peer (ngx_http_request_t*,ngx_http_upstream_srv_conf_t*)"
237860,METHOD,http\modules\ngx_http_upstream_least_conn_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_get_least_conn_peer(ngx_peer_connection_t *pc, void *data)
{
    ngx_http_upstream_rr_peer_data_t  *rrp = data;

    time_t                         now;
    uintptr_t                      m;
    ngx_int_t                      rc, total;
    ngx_uint_t                     i, n, p, many;
    ngx_http_upstream_rr_peer_t   *peer, *best;
    ngx_http_upstream_rr_peers_t  *peers;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, pc->log, 0,
                   ""get least conn peer, try: %ui"", pc->tries);

    if (rrp->peers->single) {
        return ngx_http_upstream_get_round_robin_peer(pc, rrp);
    }

    pc->cached = 0;
    pc->connection = NULL;

    now = ngx_time();

    peers = rrp->peers;

    ngx_http_upstream_rr_peers_wlock(peers);

    best = NULL;
    total = 0;

#if (NGX_SUPPRESS_WARN)
    many = 0;
    p = 0;
#endif

    for (peer = peers->peer, i = 0;
         peer;
         peer = peer->next, i++)
    {
        n = i / (8 * sizeof(uintptr_t));
    ...",1,1,http\modules\ngx_http_upstream_least_conn_module.c,ngx_http_upstream_get_least_conn_peer,,false,99,288,ngx_http_upstream_get_least_conn_peer,,,12,"ngx_int_t ngx_http_upstream_get_least_conn_peer (ngx_peer_connection_t*,void*)"
238416,METHOD,http\modules\ngx_http_upstream_least_conn_module.c:<global>,TYPE_DECL,"static char *
ngx_http_upstream_least_conn(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_upstream_srv_conf_t  *uscf;

    uscf = ngx_http_conf_get_module_srv_conf(cf, ngx_http_upstream_module);

    if (uscf->peer.init_upstream) {
        ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
                           ""load balancing method redefined"");
    }

    uscf->peer.init_upstream = ngx_http_upstream_init_least_conn;

    uscf->flags = NGX_HTTP_UPSTREAM_CREATE
                  |NGX_HTTP_UPSTREAM_WEIGHT
                  |NGX_HTTP_UPSTREAM_MAX_CONNS
                  |NGX_HTTP_UPSTREAM_MAX_FAILS
                  |NGX_HTTP_UPSTREAM_FAIL_TIMEOUT
                  |NGX_HTTP_UPSTREAM_DOWN
                  |NGX_HTTP_UPSTREAM_BACKUP;

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_upstream_least_conn_module.c,ngx_http_upstream_least_conn,,false,291,314,ngx_http_upstream_least_conn,,,13,"char* ngx_http_upstream_least_conn (ngx_conf_t*,ngx_command_t*,void*)"
238476,METHOD,http\modules\ngx_http_upstream_random_module.c:<global>,TYPE_DECL,<global>,1,1,http\modules\ngx_http_upstream_random_module.c,http\modules\ngx_http_upstream_random_module.c:<global>,,false,1,502,<global>,,,1,
238491,METHOD,http\modules\ngx_http_upstream_random_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_init_random(ngx_conf_t *cf,
    ngx_http_upstream_srv_conf_t *us);",18,37,http\modules\ngx_http_upstream_random_module.c,ngx_http_upstream_init_random,,false,33,34,ngx_http_upstream_init_random,,,7,"ngx_int_t ngx_http_upstream_init_random (ngx_conf_t*,ngx_http_upstream_srv_conf_t*)"
238497,METHOD,http\modules\ngx_http_upstream_random_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_update_random(ngx_pool_t *pool,
    ngx_http_upstream_srv_conf_t *us);",18,37,http\modules\ngx_http_upstream_random_module.c,ngx_http_upstream_update_random,,false,35,36,ngx_http_upstream_update_random,,,8,"ngx_int_t ngx_http_upstream_update_random (ngx_pool_t*,ngx_http_upstream_srv_conf_t*)"
238503,METHOD,http\modules\ngx_http_upstream_random_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_init_random_peer(ngx_http_request_t *r,
    ngx_http_upstream_srv_conf_t *us);",18,37,http\modules\ngx_http_upstream_random_module.c,ngx_http_upstream_init_random_peer,,false,38,39,ngx_http_upstream_init_random_peer,,,9,"ngx_int_t ngx_http_upstream_init_random_peer (ngx_http_request_t*,ngx_http_upstream_srv_conf_t*)"
238509,METHOD,http\modules\ngx_http_upstream_random_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_get_random_peer(ngx_peer_connection_t *pc,
    void *data);",18,15,http\modules\ngx_http_upstream_random_module.c,ngx_http_upstream_get_random_peer,,false,40,41,ngx_http_upstream_get_random_peer,,,10,"ngx_int_t ngx_http_upstream_get_random_peer (ngx_peer_connection_t*,void*)"
238515,METHOD,http\modules\ngx_http_upstream_random_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_get_random2_peer(ngx_peer_connection_t *pc,
    void *data);",18,15,http\modules\ngx_http_upstream_random_module.c,ngx_http_upstream_get_random2_peer,,false,42,43,ngx_http_upstream_get_random2_peer,,,11,"ngx_int_t ngx_http_upstream_get_random2_peer (ngx_peer_connection_t*,void*)"
238521,METHOD,http\modules\ngx_http_upstream_random_module.c:<global>,TYPE_DECL,"static ngx_uint_t ngx_http_upstream_peek_random_peer(
    ngx_http_upstream_rr_peers_t *peers,
    ngx_http_upstream_random_peer_data_t *rp);",19,45,http\modules\ngx_http_upstream_random_module.c,ngx_http_upstream_peek_random_peer,,false,44,46,ngx_http_upstream_peek_random_peer,,,12,"ngx_uint_t ngx_http_upstream_peek_random_peer (ngx_http_upstream_rr_peers_t*,ngx_http_upstream_random_peer_data_t*)"
238527,METHOD,http\modules\ngx_http_upstream_random_module.c:<global>,TYPE_DECL,static void *ngx_http_upstream_random_create_conf(ngx_conf_t *cf);,13,65,http\modules\ngx_http_upstream_random_module.c,ngx_http_upstream_random_create_conf,,false,47,47,ngx_http_upstream_random_create_conf,,,13,void* ngx_http_upstream_random_create_conf (ngx_conf_t*)
238532,METHOD,http\modules\ngx_http_upstream_random_module.c:<global>,TYPE_DECL,"static char *ngx_http_upstream_random(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_upstream_random_module.c,ngx_http_upstream_random,,false,48,49,ngx_http_upstream_random,,,14,"char* ngx_http_upstream_random (ngx_conf_t*,ngx_command_t*,void*)"
238585,METHOD,http\modules\ngx_http_upstream_random_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_init_random(ngx_conf_t *cf, ngx_http_upstream_srv_conf_t *us)
{
    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, cf->log, 0, ""init random"");

    if (ngx_http_upstream_init_round_robin(cf, us) != NGX_OK) {
        return NGX_ERROR;
    }

    us->peer.init = ngx_http_upstream_init_random_peer;

#if (NGX_HTTP_UPSTREAM_ZONE)
    if (us->shm_zone) {
        return NGX_OK;
    }
#endif

    return ngx_http_upstream_update_random(cf->pool, us);
}",1,1,http\modules\ngx_http_upstream_random_module.c,ngx_http_upstream_init_random,,false,96,114,ngx_http_upstream_init_random,,,21,"ngx_int_t ngx_http_upstream_init_random (ngx_conf_t*,ngx_http_upstream_srv_conf_t*)"
238620,METHOD,http\modules\ngx_http_upstream_random_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_update_random(ngx_pool_t *pool,
    ngx_http_upstream_srv_conf_t *us)
{
    size_t                                size;
    ngx_uint_t                            i, total_weight;
    ngx_http_upstream_rr_peer_t          *peer;
    ngx_http_upstream_rr_peers_t         *peers;
    ngx_http_upstream_random_range_t     *ranges;
    ngx_http_upstream_random_srv_conf_t  *rcf;

    rcf = ngx_http_conf_upstream_srv_conf(us, ngx_http_upstream_random_module);

    peers = us->peer.data;

    size = peers->number * sizeof(ngx_http_upstream_random_range_t);

    ranges = pool ? ngx_palloc(pool, size) : ngx_alloc(size, ngx_cycle->log);
    if (ranges == NULL) {
        return NGX_ERROR;
    }

    total_weight = 0;

    for (peer = peers->peer, i = 0; peer; peer = peer->next, i++) {
        ranges[i].peer = peer;
        ranges[i].range = total_weight;
        total_weight += peer->weight;
    }

    rcf->ranges = ranges;

    return NGX_OK;
}",1,1,http\modules\ngx_http_upstream_random_module.c,ngx_http_upstream_update_random,,false,117,150,ngx_http_upstream_update_random,,,22,"ngx_int_t ngx_http_upstream_update_random (ngx_pool_t*,ngx_http_upstream_srv_conf_t*)"
238722,METHOD,http\modules\ngx_http_upstream_random_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_init_random_peer(ngx_http_request_t *r,
    ngx_http_upstream_srv_conf_t *us)
{
    ngx_http_upstream_random_srv_conf_t   *rcf;
    ngx_http_upstream_random_peer_data_t  *rp;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""init random peer"");

    rcf = ngx_http_conf_upstream_srv_conf(us, ngx_http_upstream_random_module);

    rp = ngx_palloc(r->pool, sizeof(ngx_http_upstream_random_peer_data_t));
    if (rp == NULL) {
        return NGX_ERROR;
    }

    r->upstream->peer.data = &rp->rrp;

    if (ngx_http_upstream_init_round_robin_peer(r, us) != NGX_OK) {
        return NGX_ERROR;
    }

    if (rcf->two) {
        r->upstream->peer.get = ngx_http_upstream_get_random2_peer;

    } else {
        r->upstream->peer.get = ngx_http_upstream_get_random_peer;
    }

    rp->conf = rcf;
    rp->tries = 0;

    ngx_http_upstream_rr_peers_rlock(rp->rrp.peers);

#if (NGX_HTTP_UPSTREAM_ZONE)
    if (rp->rrp.peers->shpool &...",1,1,http\modules\ngx_http_upstream_random_module.c,ngx_http_upstream_init_random_peer,,false,153,200,ngx_http_upstream_init_random_peer,,,23,"ngx_int_t ngx_http_upstream_init_random_peer (ngx_http_request_t*,ngx_http_upstream_srv_conf_t*)"
238829,METHOD,http\modules\ngx_http_upstream_random_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_get_random_peer(ngx_peer_connection_t *pc, void *data)
{
    ngx_http_upstream_random_peer_data_t  *rp = data;

    time_t                             now;
    uintptr_t                          m;
    ngx_uint_t                         i, n;
    ngx_http_upstream_rr_peer_t       *peer;
    ngx_http_upstream_rr_peers_t      *peers;
    ngx_http_upstream_rr_peer_data_t  *rrp;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, pc->log, 0,
                   ""get random peer, try: %ui"", pc->tries);

    rrp = &rp->rrp;
    peers = rrp->peers;

    ngx_http_upstream_rr_peers_rlock(peers);

    if (rp->tries > 20 || peers->single) {
        ngx_http_upstream_rr_peers_unlock(peers);
        return ngx_http_upstream_get_round_robin_peer(pc, rrp);
    }

    pc->cached = 0;
    pc->connection = NULL;

    now = ngx_time();

    for ( ;; ) {

        i = ngx_http_upstream_peek_random_peer(peers, rp);

        peer = rp->conf->ranges[i].peer;

        n = i / (8 * size...",1,1,http\modules\ngx_http_upstream_random_module.c,ngx_http_upstream_get_random_peer,,false,203,294,ngx_http_upstream_get_random_peer,,,24,"ngx_int_t ngx_http_upstream_get_random_peer (ngx_peer_connection_t*,void*)"
239081,METHOD,http\modules\ngx_http_upstream_random_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_get_random2_peer(ngx_peer_connection_t *pc, void *data)
{
    ngx_http_upstream_random_peer_data_t  *rp = data;

    time_t                             now;
    uintptr_t                          m;
    ngx_uint_t                         i, n, p;
    ngx_http_upstream_rr_peer_t       *peer, *prev;
    ngx_http_upstream_rr_peers_t      *peers;
    ngx_http_upstream_rr_peer_data_t  *rrp;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, pc->log, 0,
                   ""get random2 peer, try: %ui"", pc->tries);

    rrp = &rp->rrp;
    peers = rrp->peers;

    ngx_http_upstream_rr_peers_wlock(peers);

    if (rp->tries > 20 || peers->single) {
        ngx_http_upstream_rr_peers_unlock(peers);
        return ngx_http_upstream_get_round_robin_peer(pc, rrp);
    }

    pc->cached = 0;
    pc->connection = NULL;

    now = ngx_time();

    prev = NULL;

#if (NGX_SUPPRESS_WARN)
    p = 0;
#endif

    for ( ;; ) {

        i = ngx_http_upstream_peek_random_peer(peers, ...",1,1,http\modules\ngx_http_upstream_random_module.c,ngx_http_upstream_get_random2_peer,,false,297,403,ngx_http_upstream_get_random2_peer,,,25,"ngx_int_t ngx_http_upstream_get_random2_peer (ngx_peer_connection_t*,void*)"
239378,METHOD,http\modules\ngx_http_upstream_random_module.c:<global>,TYPE_DECL,"static ngx_uint_t
ngx_http_upstream_peek_random_peer(ngx_http_upstream_rr_peers_t *peers,
    ngx_http_upstream_random_peer_data_t *rp)
{
    ngx_uint_t  i, j, k, x;

    x = ngx_random() % peers->total_weight;

    i = 0;
    j = peers->number;

    while (j - i > 1) {
        k = (i + j) / 2;

        if (x < rp->conf->ranges[k].range) {
            j = k;

        } else {
            i = k;
        }
    }

    return i;
}",1,1,http\modules\ngx_http_upstream_random_module.c,ngx_http_upstream_peek_random_peer,,false,406,429,ngx_http_upstream_peek_random_peer,,,26,"ngx_uint_t ngx_http_upstream_peek_random_peer (ngx_http_upstream_rr_peers_t*,ngx_http_upstream_random_peer_data_t*)"
239440,METHOD,http\modules\ngx_http_upstream_random_module.c:<global>,TYPE_DECL,"static void *
ngx_http_upstream_random_create_conf(ngx_conf_t *cf)
{
    ngx_http_upstream_random_srv_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_upstream_random_srv_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     conf->two = 0;
     */

    return conf;
}",1,1,http\modules\ngx_http_upstream_random_module.c,ngx_http_upstream_random_create_conf,,false,432,449,ngx_http_upstream_random_create_conf,,,27,void* ngx_http_upstream_random_create_conf (ngx_conf_t*)
239463,METHOD,http\modules\ngx_http_upstream_random_module.c:<global>,TYPE_DECL,"static char *
ngx_http_upstream_random(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_upstream_random_srv_conf_t  *rcf = conf;

    ngx_str_t                     *value;
    ngx_http_upstream_srv_conf_t  *uscf;

    uscf = ngx_http_conf_get_module_srv_conf(cf, ngx_http_upstream_module);

    if (uscf->peer.init_upstream) {
        ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
                           ""load balancing method redefined"");
    }

    uscf->peer.init_upstream = ngx_http_upstream_init_random;

    uscf->flags = NGX_HTTP_UPSTREAM_CREATE
                  |NGX_HTTP_UPSTREAM_WEIGHT
                  |NGX_HTTP_UPSTREAM_MAX_CONNS
                  |NGX_HTTP_UPSTREAM_MAX_FAILS
                  |NGX_HTTP_UPSTREAM_FAIL_TIMEOUT
                  |NGX_HTTP_UPSTREAM_DOWN;

    if (cf->args->nelts == 1) {
        return NGX_CONF_OK;
    }

    value = cf->args->elts;

    if (ngx_strcmp(value[1].data, ""two"") == 0) {
        rcf->two = 1;

    } else {
        ngx_conf_lo...",1,1,http\modules\ngx_http_upstream_random_module.c,ngx_http_upstream_random,,false,452,502,ngx_http_upstream_random,,,28,"char* ngx_http_upstream_random (ngx_conf_t*,ngx_command_t*,void*)"
239606,METHOD,http\modules\ngx_http_upstream_zone_module.c:<global>,TYPE_DECL,<global>,1,1,http\modules\ngx_http_upstream_zone_module.c,http\modules\ngx_http_upstream_zone_module.c:<global>,,false,1,325,<global>,,,1,
239608,METHOD,http\modules\ngx_http_upstream_zone_module.c:<global>,TYPE_DECL,"static char *ngx_http_upstream_zone(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_upstream_zone_module.c,ngx_http_upstream_zone,,false,13,14,ngx_http_upstream_zone,,,1,"char* ngx_http_upstream_zone (ngx_conf_t*,ngx_command_t*,void*)"
239615,METHOD,http\modules\ngx_http_upstream_zone_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_init_zone(ngx_shm_zone_t *shm_zone,
    void *data);",18,15,http\modules\ngx_http_upstream_zone_module.c,ngx_http_upstream_init_zone,,false,15,16,ngx_http_upstream_init_zone,,,2,"ngx_int_t ngx_http_upstream_init_zone (ngx_shm_zone_t*,void*)"
239621,METHOD,http\modules\ngx_http_upstream_zone_module.c:<global>,TYPE_DECL,"static ngx_http_upstream_rr_peers_t *ngx_http_upstream_zone_copy_peers(
    ngx_slab_pool_t *shpool, ngx_http_upstream_srv_conf_t *uscf);",37,64,http\modules\ngx_http_upstream_zone_module.c,ngx_http_upstream_zone_copy_peers,,false,17,18,ngx_http_upstream_zone_copy_peers,,,3,"ngx_http_upstream_rr_peers_t* ngx_http_upstream_zone_copy_peers (ngx_slab_pool_t*,ngx_http_upstream_srv_conf_t*)"
239627,METHOD,http\modules\ngx_http_upstream_zone_module.c:<global>,TYPE_DECL,"static ngx_http_upstream_rr_peer_t *ngx_http_upstream_zone_copy_peer(
    ngx_http_upstream_rr_peers_t *peers, ngx_http_upstream_rr_peer_t *src);",36,74,http\modules\ngx_http_upstream_zone_module.c,ngx_http_upstream_zone_copy_peer,,false,19,20,ngx_http_upstream_zone_copy_peer,,,4,"ngx_http_upstream_rr_peer_t* ngx_http_upstream_zone_copy_peer (ngx_http_upstream_rr_peers_t*,ngx_http_upstream_rr_peer_t*)"
239677,METHOD,http\modules\ngx_http_upstream_zone_module.c:<global>,TYPE_DECL,"static char *
ngx_http_upstream_zone(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ssize_t                         size;
    ngx_str_t                      *value;
    ngx_http_upstream_srv_conf_t   *uscf;
    ngx_http_upstream_main_conf_t  *umcf;

    uscf = ngx_http_conf_get_module_srv_conf(cf, ngx_http_upstream_module);
    umcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_upstream_module);

    value = cf->args->elts;

    if (!value[1].len) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""invalid zone name \""%V\"""", &value[1]);
        return NGX_CONF_ERROR;
    }

    if (cf->args->nelts == 3) {
        size = ngx_parse_size(&value[2]);

        if (size == NGX_ERROR) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               ""invalid zone size \""%V\"""", &value[2]);
            return NGX_CONF_ERROR;
        }

        if (size < (ssize_t) (8 * ngx_pagesize)) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf,...",1,1,http\modules\ngx_http_upstream_zone_module.c,ngx_http_upstream_zone,,false,67,117,ngx_http_upstream_zone,,,11,"char* ngx_http_upstream_zone (ngx_conf_t*,ngx_command_t*,void*)"
239825,METHOD,http\modules\ngx_http_upstream_zone_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_init_zone(ngx_shm_zone_t *shm_zone, void *data)
{
    size_t                          len;
    ngx_uint_t                      i;
    ngx_slab_pool_t                *shpool;
    ngx_http_upstream_rr_peers_t   *peers, **peersp;
    ngx_http_upstream_srv_conf_t   *uscf, **uscfp;
    ngx_http_upstream_main_conf_t  *umcf;

    shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;
    umcf = shm_zone->data;
    uscfp = umcf->upstreams.elts;

    if (shm_zone->shm.exists) {
        peers = shpool->data;

        for (i = 0; i < umcf->upstreams.nelts; i++) {
            uscf = uscfp[i];

            if (uscf->shm_zone != shm_zone) {
                continue;
            }

            uscf->peer.data = peers;
            peers = peers->zone_next;
        }

        return NGX_OK;
    }

    len = sizeof("" in upstream zone \""\"""") + shm_zone->shm.name.len;

    shpool->log_ctx = ngx_slab_alloc(shpool, len);
    if (shpool->log_ctx == NULL) {
        return NGX_E...",1,1,http\modules\ngx_http_upstream_zone_module.c,ngx_http_upstream_init_zone,,false,120,183,ngx_http_upstream_init_zone,,,12,"ngx_int_t ngx_http_upstream_init_zone (ngx_shm_zone_t*,void*)"
240015,METHOD,http\modules\ngx_http_upstream_zone_module.c:<global>,TYPE_DECL,"static ngx_http_upstream_rr_peers_t *
ngx_http_upstream_zone_copy_peers(ngx_slab_pool_t *shpool,
    ngx_http_upstream_srv_conf_t *uscf)
{
    ngx_str_t                     *name;
    ngx_http_upstream_rr_peer_t   *peer, **peerp;
    ngx_http_upstream_rr_peers_t  *peers, *backup;

    peers = ngx_slab_alloc(shpool, sizeof(ngx_http_upstream_rr_peers_t));
    if (peers == NULL) {
        return NULL;
    }

    ngx_memcpy(peers, uscf->peer.data, sizeof(ngx_http_upstream_rr_peers_t));

    name = ngx_slab_alloc(shpool, sizeof(ngx_str_t));
    if (name == NULL) {
        return NULL;
    }

    name->data = ngx_slab_alloc(shpool, peers->name->len);
    if (name->data == NULL) {
        return NULL;
    }

    ngx_memcpy(name->data, peers->name->data, peers->name->len);
    name->len = peers->name->len;

    peers->name = name;

    peers->shpool = shpool;

    for (peerp = &peers->peer; *peerp; peerp = &peer->next) {
        /* pool is unlocked */
        peer = ngx_http_upstream_zone_c...",1,1,http\modules\ngx_http_upstream_zone_module.c,ngx_http_upstream_zone_copy_peers,,false,186,260,ngx_http_upstream_zone_copy_peers,,,13,"ngx_http_upstream_rr_peers_t ngx_http_upstream_zone_copy_peers (ngx_slab_pool_t*,ngx_http_upstream_srv_conf_t*)"
240235,METHOD,http\modules\ngx_http_upstream_zone_module.c:<global>,TYPE_DECL,"static ngx_http_upstream_rr_peer_t *
ngx_http_upstream_zone_copy_peer(ngx_http_upstream_rr_peers_t *peers,
    ngx_http_upstream_rr_peer_t *src)
{
    ngx_slab_pool_t              *pool;
    ngx_http_upstream_rr_peer_t  *dst;

    pool = peers->shpool;

    dst = ngx_slab_calloc_locked(pool, sizeof(ngx_http_upstream_rr_peer_t));
    if (dst == NULL) {
        return NULL;
    }

    if (src) {
        ngx_memcpy(dst, src, sizeof(ngx_http_upstream_rr_peer_t));
        dst->sockaddr = NULL;
        dst->name.data = NULL;
        dst->server.data = NULL;
    }

    dst->sockaddr = ngx_slab_calloc_locked(pool, sizeof(ngx_sockaddr_t));
    if (dst->sockaddr == NULL) {
        goto failed;
    }

    dst->name.data = ngx_slab_calloc_locked(pool, NGX_SOCKADDR_STRLEN);
    if (dst->name.data == NULL) {
        goto failed;
    }

    if (src) {
        ngx_memcpy(dst->sockaddr, src->sockaddr, src->socklen);
        ngx_memcpy(dst->name.data, src->name.data, src->name.len);

        dst->ser...",1,1,http\modules\ngx_http_upstream_zone_module.c,ngx_http_upstream_zone_copy_peer,,false,263,325,ngx_http_upstream_zone_copy_peer,,,14,"ngx_http_upstream_rr_peer_t ngx_http_upstream_zone_copy_peer (ngx_http_upstream_rr_peers_t*,ngx_http_upstream_rr_peer_t*)"
240446,METHOD,http\modules\ngx_http_userid_filter_module.c:<global>,TYPE_DECL,<global>,1,25,http\modules\ngx_http_userid_filter_module.c,http\modules\ngx_http_userid_filter_module.c:<global>,,false,1,853,<global>,,,1,
240463,METHOD,<empty>,<empty>,<empty>,1,,http\modules\ngx_http_userid_filter_module.c,ngx_http_userid_ctx_t:<clinit>,,false,38,,<clinit>,,,5,
240472,METHOD,http\modules\ngx_http_userid_filter_module.c:<global>,TYPE_DECL,"static ngx_http_userid_ctx_t *ngx_http_userid_get_uid(ngx_http_request_t *r,
    ngx_http_userid_conf_t *conf);",30,33,http\modules\ngx_http_userid_filter_module.c,ngx_http_userid_get_uid,,false,46,47,ngx_http_userid_get_uid,,,5,"ngx_http_userid_ctx_t* ngx_http_userid_get_uid (ngx_http_request_t*,ngx_http_userid_conf_t*)"
240478,METHOD,http\modules\ngx_http_userid_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_userid_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, ngx_str_t *name, uint32_t *uid);",18,65,http\modules\ngx_http_userid_filter_module.c,ngx_http_userid_variable,,false,48,49,ngx_http_userid_variable,,,6,"ngx_int_t ngx_http_userid_variable (ngx_http_request_t*,ngx_http_variable_value_t*,ngx_str_t*,uint32_t*)"
240486,METHOD,http\modules\ngx_http_userid_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_userid_set_uid(ngx_http_request_t *r,
    ngx_http_userid_ctx_t *ctx, ngx_http_userid_conf_t *conf);",18,61,http\modules\ngx_http_userid_filter_module.c,ngx_http_userid_set_uid,,false,50,51,ngx_http_userid_set_uid,,,7,"ngx_int_t ngx_http_userid_set_uid (ngx_http_request_t*,ngx_http_userid_ctx_t*,ngx_http_userid_conf_t*)"
240493,METHOD,http\modules\ngx_http_userid_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_userid_create_uid(ngx_http_request_t *r,
    ngx_http_userid_ctx_t *ctx, ngx_http_userid_conf_t *conf);",18,61,http\modules\ngx_http_userid_filter_module.c,ngx_http_userid_create_uid,,false,52,53,ngx_http_userid_create_uid,,,8,"ngx_int_t ngx_http_userid_create_uid (ngx_http_request_t*,ngx_http_userid_ctx_t*,ngx_http_userid_conf_t*)"
240500,METHOD,http\modules\ngx_http_userid_filter_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_userid_add_variables(ngx_conf_t *cf);,18,62,http\modules\ngx_http_userid_filter_module.c,ngx_http_userid_add_variables,,false,55,55,ngx_http_userid_add_variables,,,9,ngx_int_t ngx_http_userid_add_variables (ngx_conf_t*)
240505,METHOD,http\modules\ngx_http_userid_filter_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_userid_init(ngx_conf_t *cf);,18,53,http\modules\ngx_http_userid_filter_module.c,ngx_http_userid_init,,false,56,56,ngx_http_userid_init,,,10,ngx_int_t ngx_http_userid_init (ngx_conf_t*)
240510,METHOD,http\modules\ngx_http_userid_filter_module.c:<global>,TYPE_DECL,static void *ngx_http_userid_create_conf(ngx_conf_t *cf);,13,56,http\modules\ngx_http_userid_filter_module.c,ngx_http_userid_create_conf,,false,57,57,ngx_http_userid_create_conf,,,11,void* ngx_http_userid_create_conf (ngx_conf_t*)
240515,METHOD,http\modules\ngx_http_userid_filter_module.c:<global>,TYPE_DECL,"static char *ngx_http_userid_merge_conf(ngx_conf_t *cf, void *parent,
    void *child);",13,16,http\modules\ngx_http_userid_filter_module.c,ngx_http_userid_merge_conf,,false,58,59,ngx_http_userid_merge_conf,,,12,"char* ngx_http_userid_merge_conf (ngx_conf_t*,void*,void*)"
240522,METHOD,http\modules\ngx_http_userid_filter_module.c:<global>,TYPE_DECL,"static char *ngx_http_userid_domain(ngx_conf_t *cf, void *post, void *data);",13,75,http\modules\ngx_http_userid_filter_module.c,ngx_http_userid_domain,,false,60,60,ngx_http_userid_domain,,,13,"char* ngx_http_userid_domain (ngx_conf_t*,void*,void*)"
240529,METHOD,http\modules\ngx_http_userid_filter_module.c:<global>,TYPE_DECL,"static char *ngx_http_userid_path(ngx_conf_t *cf, void *post, void *data);",13,73,http\modules\ngx_http_userid_filter_module.c,ngx_http_userid_path,,false,61,61,ngx_http_userid_path,,,14,"char* ngx_http_userid_path (ngx_conf_t*,void*,void*)"
240536,METHOD,http\modules\ngx_http_userid_filter_module.c:<global>,TYPE_DECL,"static char *ngx_http_userid_expires(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_userid_filter_module.c,ngx_http_userid_expires,,false,62,63,ngx_http_userid_expires,,,15,"char* ngx_http_userid_expires (ngx_conf_t*,ngx_command_t*,void*)"
240543,METHOD,http\modules\ngx_http_userid_filter_module.c:<global>,TYPE_DECL,"static char *ngx_http_userid_p3p(ngx_conf_t *cf, void *post, void *data);",13,72,http\modules\ngx_http_userid_filter_module.c,ngx_http_userid_p3p,,false,64,64,ngx_http_userid_p3p,,,16,"char* ngx_http_userid_p3p (ngx_conf_t*,void*,void*)"
240550,METHOD,http\modules\ngx_http_userid_filter_module.c:<global>,TYPE_DECL,"static char *ngx_http_userid_mark(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_userid_filter_module.c,ngx_http_userid_mark,,false,65,66,ngx_http_userid_mark,,,17,"char* ngx_http_userid_mark (ngx_conf_t*,ngx_command_t*,void*)"
240557,METHOD,http\modules\ngx_http_userid_filter_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_userid_init_worker(ngx_cycle_t *cycle);,18,64,http\modules\ngx_http_userid_filter_module.c,ngx_http_userid_init_worker,,false,67,67,ngx_http_userid_init_worker,,,18,ngx_int_t ngx_http_userid_init_worker (ngx_cycle_t*)
240796,METHOD,http\modules\ngx_http_userid_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_userid_filter(ngx_http_request_t *r)
{
    ngx_http_userid_ctx_t   *ctx;
    ngx_http_userid_conf_t  *conf;

    if (r != r->main) {
        return ngx_http_next_header_filter(r);
    }

    conf = ngx_http_get_module_loc_conf(r, ngx_http_userid_filter_module);

    if (conf->enable < NGX_HTTP_USERID_V1) {
        return ngx_http_next_header_filter(r);
    }

    ctx = ngx_http_userid_get_uid(r, conf);

    if (ctx == NULL) {
        return NGX_ERROR;
    }

    if (ngx_http_userid_set_uid(r, ctx, conf) == NGX_OK) {
        return ngx_http_next_header_filter(r);
    }

    return NGX_ERROR;
}",1,23,http\modules\ngx_http_userid_filter_module.c,ngx_http_userid_filter,,false,196,223,ngx_http_userid_filter,,,48,ngx_int_t ngx_http_userid_filter (ngx_http_request_t*)
240855,METHOD,http\modules\ngx_http_userid_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_userid_got_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    ngx_http_userid_ctx_t   *ctx;
    ngx_http_userid_conf_t  *conf;

    conf = ngx_http_get_module_loc_conf(r->main, ngx_http_userid_filter_module);

    if (conf->enable == NGX_HTTP_USERID_OFF) {
        v->not_found = 1;
        return NGX_OK;
    }

    ctx = ngx_http_userid_get_uid(r->main, conf);

    if (ctx == NULL) {
        return NGX_ERROR;
    }

    if (ctx->uid_got[3] != 0) {
        return ngx_http_userid_variable(r->main, v, &conf->name, ctx->uid_got);
    }

    v->not_found = 1;

    return NGX_OK;
}",1,24,http\modules\ngx_http_userid_filter_module.c,ngx_http_userid_got_variable,,false,226,253,ngx_http_userid_got_variable,,,49,"ngx_int_t ngx_http_userid_got_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
240930,METHOD,http\modules\ngx_http_userid_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_userid_set_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    ngx_http_userid_ctx_t   *ctx;
    ngx_http_userid_conf_t  *conf;

    conf = ngx_http_get_module_loc_conf(r->main, ngx_http_userid_filter_module);

    if (conf->enable < NGX_HTTP_USERID_V1) {
        v->not_found = 1;
        return NGX_OK;
    }

    ctx = ngx_http_userid_get_uid(r->main, conf);

    if (ctx == NULL) {
        return NGX_ERROR;
    }

    if (ngx_http_userid_create_uid(r->main, ctx, conf) != NGX_OK) {
        return NGX_ERROR;
    }

    if (ctx->uid_set[3] == 0) {
        v->not_found = 1;
        return NGX_OK;
    }

    return ngx_http_userid_variable(r->main, v, &conf->name, ctx->uid_set);
}",1,23,http\modules\ngx_http_userid_filter_module.c,ngx_http_userid_set_variable,,false,256,286,ngx_http_userid_set_variable,,,50,"ngx_int_t ngx_http_userid_set_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
241017,METHOD,http\modules\ngx_http_userid_filter_module.c:<global>,TYPE_DECL,"static ngx_http_userid_ctx_t *
ngx_http_userid_get_uid(ngx_http_request_t *r, ngx_http_userid_conf_t *conf)
{
    ngx_int_t                n;
    ngx_str_t                src, dst;
    ngx_table_elt_t        **cookies;
    ngx_http_userid_ctx_t   *ctx;

    ctx = ngx_http_get_module_ctx(r, ngx_http_userid_filter_module);

    if (ctx) {
        return ctx;
    }

    if (ctx == NULL) {
        ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_userid_ctx_t));
        if (ctx == NULL) {
            return NULL;
        }

        ngx_http_set_ctx(r, ctx, ngx_http_userid_filter_module);
    }

    n = ngx_http_parse_multi_header_lines(&r->headers_in.cookies, &conf->name,
                                          &ctx->cookie);
    if (n == NGX_DECLINED) {
        return ctx;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""uid cookie: \""%V\"""", &ctx->cookie);

    if (ctx->cookie.len < 22) {
        cookies = r->headers_in.cookies.elts;
        ngx_log_e...",1,1,http\modules\ngx_http_userid_filter_module.c,ngx_http_userid_get_uid,,false,289,356,ngx_http_userid_get_uid,,,51,"ngx_http_userid_ctx_t ngx_http_userid_get_uid (ngx_http_request_t*,ngx_http_userid_conf_t*)"
241219,METHOD,http\modules\ngx_http_userid_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_userid_set_uid(ngx_http_request_t *r, ngx_http_userid_ctx_t *ctx,
    ngx_http_userid_conf_t *conf)
{
    u_char           *cookie, *p;
    size_t            len;
    ngx_str_t         src, dst;
    ngx_table_elt_t  *set_cookie, *p3p;

    if (ngx_http_userid_create_uid(r, ctx, conf) != NGX_OK) {
        return NGX_ERROR;
    }

    if (ctx->uid_set[3] == 0) {
        return NGX_OK;
    }

    len = conf->name.len + 1 + ngx_base64_encoded_length(16) + conf->path.len;

    if (conf->expires) {
        len += sizeof(expires) - 1 + 2;
    }

    if (conf->domain.len) {
        len += conf->domain.len;
    }

    cookie = ngx_pnalloc(r->pool, len);
    if (cookie == NULL) {
        return NGX_ERROR;
    }

    p = ngx_copy(cookie, conf->name.data, conf->name.len);
    *p++ = '=';

    if (ctx->uid_got[3] == 0 || ctx->reset) {
        src.len = 16;
        src.data = (u_char *) ctx->uid_set;
        dst.data = p;

        ngx_encode_base64(&dst, &src);

        ...",1,25,http\modules\ngx_http_userid_filter_module.c,ngx_http_userid_set_uid,,false,359,452,ngx_http_userid_set_uid,,,52,"ngx_int_t ngx_http_userid_set_uid (ngx_http_request_t*,ngx_http_userid_ctx_t*,ngx_http_userid_conf_t*)"
241585,METHOD,http\modules\ngx_http_userid_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_userid_create_uid(ngx_http_request_t *r, ngx_http_userid_ctx_t *ctx,
    ngx_http_userid_conf_t *conf)
{
    ngx_connection_t           *c;
    struct sockaddr_in         *sin;
    ngx_http_variable_value_t  *vv;
#if (NGX_HAVE_INET6)
    u_char                     *p;
    struct sockaddr_in6        *sin6;
#endif

    if (ctx->uid_set[3] != 0) {
        return NGX_OK;
    }

    if (ctx->uid_got[3] != 0) {

        vv = ngx_http_get_indexed_variable(r, ngx_http_userid_reset_index);

        if (vv == NULL || vv->not_found) {
            return NGX_ERROR;
        }

        if (vv->len == 0 || (vv->len == 1 && vv->data[0] == '0')) {

            if (conf->mark == '\0'
                || (ctx->cookie.len > 23
                    && ctx->cookie.data[22] == conf->mark
                    && ctx->cookie.data[23] == '='))
            {
                return NGX_OK;
            }

            ctx->uid_set[0] = ctx->uid_got[0];
            ctx->uid_set[1] = ctx->ui...",1,24,http\modules\ngx_http_userid_filter_module.c,ngx_http_userid_create_uid,,false,455,575,ngx_http_userid_create_uid,,,53,"ngx_int_t ngx_http_userid_create_uid (ngx_http_request_t*,ngx_http_userid_ctx_t*,ngx_http_userid_conf_t*)"
241955,METHOD,http\modules\ngx_http_userid_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_userid_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v,
    ngx_str_t *name, uint32_t *uid)
{
    v->len = name->len + sizeof(""=00001111222233334444555566667777"") - 1;
    v->data = ngx_pnalloc(r->pool, v->len);
    if (v->data == NULL) {
        return NGX_ERROR;
    }

    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;

    ngx_sprintf(v->data, ""%V=%08XD%08XD%08XD%08XD"",
                name, uid[0], uid[1], uid[2], uid[3]);

    return NGX_OK;
}",1,1,http\modules\ngx_http_userid_filter_module.c,ngx_http_userid_variable,,false,578,596,ngx_http_userid_variable,,,54,"ngx_int_t ngx_http_userid_variable (ngx_http_request_t*,ngx_http_variable_value_t*,ngx_str_t*,uint32_t*)"
242030,METHOD,http\modules\ngx_http_userid_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_userid_reset_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    *v = ngx_http_variable_null_value;

    return NGX_OK;
}",1,1,http\modules\ngx_http_userid_filter_module.c,ngx_http_userid_reset_variable,,false,599,606,ngx_http_userid_reset_variable,,,55,"ngx_int_t ngx_http_userid_reset_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
242043,METHOD,http\modules\ngx_http_userid_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_userid_add_variables(ngx_conf_t *cf)
{
    ngx_int_t             n;
    ngx_http_variable_t  *var;

    var = ngx_http_add_variable(cf, &ngx_http_userid_got, 0);
    if (var == NULL) {
        return NGX_ERROR;
    }

    var->get_handler = ngx_http_userid_got_variable;

    var = ngx_http_add_variable(cf, &ngx_http_userid_set, 0);
    if (var == NULL) {
        return NGX_ERROR;
    }

    var->get_handler = ngx_http_userid_set_variable;

    var = ngx_http_add_variable(cf, &ngx_http_userid_reset,
                                NGX_HTTP_VAR_CHANGEABLE);
    if (var == NULL) {
        return NGX_ERROR;
    }

    var->get_handler = ngx_http_userid_reset_variable;

    n = ngx_http_get_variable_index(cf, &ngx_http_userid_reset);
    if (n == NGX_ERROR) {
        return NGX_ERROR;
    }

    ngx_http_userid_reset_index = n;

    return NGX_OK;
}",1,1,http\modules\ngx_http_userid_filter_module.c,ngx_http_userid_add_variables,,false,609,645,ngx_http_userid_add_variables,,,56,ngx_int_t ngx_http_userid_add_variables (ngx_conf_t*)
242125,METHOD,http\modules\ngx_http_userid_filter_module.c:<global>,TYPE_DECL,"static void *
ngx_http_userid_create_conf(ngx_conf_t *cf)
{
    ngx_http_userid_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_userid_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     conf->name = { 0, NULL };
     *     conf->domain = { 0, NULL };
     *     conf->path = { 0, NULL };
     *     conf->p3p = { 0, NULL };
     */

    conf->enable = NGX_CONF_UNSET_UINT;
    conf->service = NGX_CONF_UNSET;
    conf->expires = NGX_CONF_UNSET;
    conf->mark = (u_char) '\xFF';

    return conf;
}",1,1,http\modules\ngx_http_userid_filter_module.c,ngx_http_userid_create_conf,,false,648,673,ngx_http_userid_create_conf,,,57,void* ngx_http_userid_create_conf (ngx_conf_t*)
242170,METHOD,http\modules\ngx_http_userid_filter_module.c:<global>,TYPE_DECL,"static char *
ngx_http_userid_merge_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_userid_conf_t *prev = parent;
    ngx_http_userid_conf_t *conf = child;

    ngx_conf_merge_uint_value(conf->enable, prev->enable,
                              NGX_HTTP_USERID_OFF);

    ngx_conf_merge_str_value(conf->name, prev->name, ""uid"");
    ngx_conf_merge_str_value(conf->domain, prev->domain, """");
    ngx_conf_merge_str_value(conf->path, prev->path, ""; path=/"");
    ngx_conf_merge_str_value(conf->p3p, prev->p3p, """");

    ngx_conf_merge_value(conf->service, prev->service, NGX_CONF_UNSET);
    ngx_conf_merge_sec_value(conf->expires, prev->expires, 0);

    if (conf->mark == (u_char) '\xFF') {
        if (prev->mark == (u_char) '\xFF') {
            conf->mark = '\0';
        } else {
            conf->mark = prev->mark;
        }
    }

    return NGX_CONF_OK;
}",1,30,http\modules\ngx_http_userid_filter_module.c,ngx_http_userid_merge_conf,,false,676,702,ngx_http_userid_merge_conf,,,58,"char* ngx_http_userid_merge_conf (ngx_conf_t*,void*,void*)"
242277,METHOD,http\modules\ngx_http_userid_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_userid_init(ngx_conf_t *cf)
{
    ngx_http_next_header_filter = ngx_http_top_header_filter;
    ngx_http_top_header_filter = ngx_http_userid_filter;

    return NGX_OK;
}",1,1,http\modules\ngx_http_userid_filter_module.c,ngx_http_userid_init,,false,705,712,ngx_http_userid_init,,,59,ngx_int_t ngx_http_userid_init (ngx_conf_t*)
242290,METHOD,http\modules\ngx_http_userid_filter_module.c:<global>,TYPE_DECL,"static char *
ngx_http_userid_domain(ngx_conf_t *cf, void *post, void *data)
{
    ngx_str_t  *domain = data;

    u_char  *p, *new;

    if (ngx_strcmp(domain->data, ""none"") == 0) {
        ngx_str_set(domain, """");
        return NGX_CONF_OK;
    }

    new = ngx_pnalloc(cf->pool, sizeof(""; domain="") - 1 + domain->len);
    if (new == NULL) {
        return NGX_CONF_ERROR;
    }

    p = ngx_cpymem(new, ""; domain="", sizeof(""; domain="") - 1);
    ngx_memcpy(p, domain->data, domain->len);

    domain->len += sizeof(""; domain="") - 1;
    domain->data = new;

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_userid_filter_module.c,ngx_http_userid_domain,,false,715,739,ngx_http_userid_domain,,,60,"char* ngx_http_userid_domain (ngx_conf_t*,void*,void*)"
242370,METHOD,http\modules\ngx_http_userid_filter_module.c:<global>,TYPE_DECL,"static char *
ngx_http_userid_path(ngx_conf_t *cf, void *post, void *data)
{
    ngx_str_t  *path = data;

    u_char  *p, *new;

    new = ngx_pnalloc(cf->pool, sizeof(""; path="") - 1 + path->len);
    if (new == NULL) {
        return NGX_CONF_ERROR;
    }

    p = ngx_cpymem(new, ""; path="", sizeof(""; path="") - 1);
    ngx_memcpy(p, path->data, path->len);

    path->len += sizeof(""; path="") - 1;
    path->data = new;

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_userid_filter_module.c,ngx_http_userid_path,,false,742,761,ngx_http_userid_path,,,61,"char* ngx_http_userid_path (ngx_conf_t*,void*,void*)"
242436,METHOD,http\modules\ngx_http_userid_filter_module.c:<global>,TYPE_DECL,"static char *
ngx_http_userid_expires(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_userid_conf_t *ucf = conf;

    ngx_str_t  *value;

    if (ucf->expires != NGX_CONF_UNSET) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    if (ngx_strcmp(value[1].data, ""max"") == 0) {
        ucf->expires = NGX_HTTP_USERID_MAX_EXPIRES;
        return NGX_CONF_OK;
    }

    if (ngx_strcmp(value[1].data, ""off"") == 0) {
        ucf->expires = 0;
        return NGX_CONF_OK;
    }

    ucf->expires = ngx_parse_time(&value[1], 1);
    if (ucf->expires == (time_t) NGX_ERROR) {
        return ""invalid value"";
    }

    return NGX_CONF_OK;
}",1,23,http\modules\ngx_http_userid_filter_module.c,ngx_http_userid_expires,,false,764,793,ngx_http_userid_expires,,,62,"char* ngx_http_userid_expires (ngx_conf_t*,ngx_command_t*,void*)"
242525,METHOD,http\modules\ngx_http_userid_filter_module.c:<global>,TYPE_DECL,"static char *
ngx_http_userid_p3p(ngx_conf_t *cf, void *post, void *data)
{
    ngx_str_t  *p3p = data;

    if (ngx_strcmp(p3p->data, ""none"") == 0) {
        ngx_str_set(p3p, """");
    }

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_userid_filter_module.c,ngx_http_userid_p3p,,false,796,806,ngx_http_userid_p3p,,,63,"char* ngx_http_userid_p3p (ngx_conf_t*,void*,void*)"
242550,METHOD,http\modules\ngx_http_userid_filter_module.c:<global>,TYPE_DECL,"static char *
ngx_http_userid_mark(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_userid_conf_t *ucf = conf;

    ngx_str_t  *value;

    if (ucf->mark != (u_char) '\xFF') {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    if (ngx_strcmp(value[1].data, ""off"") == 0) {
        ucf->mark = '\0';
        return NGX_CONF_OK;
    }

    if (value[1].len != 1
        || !((value[1].data[0] >= '0' && value[1].data[0] <= '9')
              || (value[1].data[0] >= 'A' && value[1].data[0] <= 'Z')
              || (value[1].data[0] >= 'a' && value[1].data[0] <= 'z')
              || value[1].data[0] == '='))
    {
        return ""value must be \""off\"" or a single letter, digit or \""=\"""";
    }

    ucf->mark = value[1].data[0];

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_userid_filter_module.c,ngx_http_userid_mark,,false,809,839,ngx_http_userid_mark,,,64,"char* ngx_http_userid_mark (ngx_conf_t*,ngx_command_t*,void*)"
242693,METHOD,http\modules\ngx_http_userid_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_userid_init_worker(ngx_cycle_t *cycle)
{
    struct timeval  tp;

    ngx_gettimeofday(&tp);

    /* use the most significant usec part that fits to 16 bits */
    start_value = (((uint32_t) tp.tv_usec / 20) << 16) | ngx_pid;

    return NGX_OK;
}",1,1,http\modules\ngx_http_userid_filter_module.c,ngx_http_userid_init_worker,,false,842,853,ngx_http_userid_init_worker,,,65,ngx_int_t ngx_http_userid_init_worker (ngx_cycle_t*)
242726,METHOD,http\modules\ngx_http_uwsgi_module.c:<global>,TYPE_DECL,<global>,1,6,http\modules\ngx_http_uwsgi_module.c,http\modules\ngx_http_uwsgi_module.c:<global>,,false,1,2422,<global>,,,1,
242759,METHOD,http\modules\ngx_http_uwsgi_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_uwsgi_eval(ngx_http_request_t *r,
    ngx_http_uwsgi_loc_conf_t *uwcf);",18,36,http\modules\ngx_http_uwsgi_module.c,ngx_http_uwsgi_eval,,false,64,65,ngx_http_uwsgi_eval,,,7,"ngx_int_t ngx_http_uwsgi_eval (ngx_http_request_t*,ngx_http_uwsgi_loc_conf_t*)"
242765,METHOD,http\modules\ngx_http_uwsgi_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_uwsgi_create_request(ngx_http_request_t *r);,18,69,http\modules\ngx_http_uwsgi_module.c,ngx_http_uwsgi_create_request,,false,66,66,ngx_http_uwsgi_create_request,,,8,ngx_int_t ngx_http_uwsgi_create_request (ngx_http_request_t*)
242770,METHOD,http\modules\ngx_http_uwsgi_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_uwsgi_reinit_request(ngx_http_request_t *r);,18,69,http\modules\ngx_http_uwsgi_module.c,ngx_http_uwsgi_reinit_request,,false,67,67,ngx_http_uwsgi_reinit_request,,,9,ngx_int_t ngx_http_uwsgi_reinit_request (ngx_http_request_t*)
242775,METHOD,http\modules\ngx_http_uwsgi_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_uwsgi_process_status_line(ngx_http_request_t *r);,18,74,http\modules\ngx_http_uwsgi_module.c,ngx_http_uwsgi_process_status_line,,false,68,68,ngx_http_uwsgi_process_status_line,,,10,ngx_int_t ngx_http_uwsgi_process_status_line (ngx_http_request_t*)
242780,METHOD,http\modules\ngx_http_uwsgi_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_uwsgi_process_header(ngx_http_request_t *r);,18,69,http\modules\ngx_http_uwsgi_module.c,ngx_http_uwsgi_process_header,,false,69,69,ngx_http_uwsgi_process_header,,,11,ngx_int_t ngx_http_uwsgi_process_header (ngx_http_request_t*)
242785,METHOD,http\modules\ngx_http_uwsgi_module.c:<global>,TYPE_DECL,static void ngx_http_uwsgi_abort_request(ngx_http_request_t *r);,13,63,http\modules\ngx_http_uwsgi_module.c,ngx_http_uwsgi_abort_request,,false,70,70,ngx_http_uwsgi_abort_request,,,12,void ngx_http_uwsgi_abort_request (ngx_http_request_t*)
242790,METHOD,http\modules\ngx_http_uwsgi_module.c:<global>,TYPE_DECL,"static void ngx_http_uwsgi_finalize_request(ngx_http_request_t *r,
    ngx_int_t rc);",13,17,http\modules\ngx_http_uwsgi_module.c,ngx_http_uwsgi_finalize_request,,false,71,72,ngx_http_uwsgi_finalize_request,,,13,"void ngx_http_uwsgi_finalize_request (ngx_http_request_t*,ngx_int_t)"
242796,METHOD,http\modules\ngx_http_uwsgi_module.c:<global>,TYPE_DECL,static void *ngx_http_uwsgi_create_main_conf(ngx_conf_t *cf);,13,60,http\modules\ngx_http_uwsgi_module.c,ngx_http_uwsgi_create_main_conf,,false,74,74,ngx_http_uwsgi_create_main_conf,,,14,void* ngx_http_uwsgi_create_main_conf (ngx_conf_t*)
242801,METHOD,http\modules\ngx_http_uwsgi_module.c:<global>,TYPE_DECL,static void *ngx_http_uwsgi_create_loc_conf(ngx_conf_t *cf);,13,59,http\modules\ngx_http_uwsgi_module.c,ngx_http_uwsgi_create_loc_conf,,false,75,75,ngx_http_uwsgi_create_loc_conf,,,15,void* ngx_http_uwsgi_create_loc_conf (ngx_conf_t*)
242806,METHOD,http\modules\ngx_http_uwsgi_module.c:<global>,TYPE_DECL,"static char *ngx_http_uwsgi_merge_loc_conf(ngx_conf_t *cf, void *parent,
    void *child);",13,16,http\modules\ngx_http_uwsgi_module.c,ngx_http_uwsgi_merge_loc_conf,,false,76,77,ngx_http_uwsgi_merge_loc_conf,,,16,"char* ngx_http_uwsgi_merge_loc_conf (ngx_conf_t*,void*,void*)"
242813,METHOD,http\modules\ngx_http_uwsgi_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_uwsgi_init_params(ngx_conf_t *cf,
    ngx_http_uwsgi_loc_conf_t *conf, ngx_http_uwsgi_params_t *params,
    ngx_keyval_t *default_params);",18,33,http\modules\ngx_http_uwsgi_module.c,ngx_http_uwsgi_init_params,,false,78,80,ngx_http_uwsgi_init_params,,,17,"ngx_int_t ngx_http_uwsgi_init_params (ngx_conf_t*,ngx_http_uwsgi_loc_conf_t*,ngx_http_uwsgi_params_t*,ngx_keyval_t*)"
242821,METHOD,http\modules\ngx_http_uwsgi_module.c:<global>,TYPE_DECL,"static char *ngx_http_uwsgi_pass(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_uwsgi_module.c,ngx_http_uwsgi_pass,,false,82,83,ngx_http_uwsgi_pass,,,18,"char* ngx_http_uwsgi_pass (ngx_conf_t*,ngx_command_t*,void*)"
242828,METHOD,http\modules\ngx_http_uwsgi_module.c:<global>,TYPE_DECL,"static char *ngx_http_uwsgi_store(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_uwsgi_module.c,ngx_http_uwsgi_store,,false,84,85,ngx_http_uwsgi_store,,,19,"char* ngx_http_uwsgi_store (ngx_conf_t*,ngx_command_t*,void*)"
243515,METHOD,http\modules\ngx_http_uwsgi_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_uwsgi_handler(ngx_http_request_t *r)
{
    ngx_int_t                    rc;
    ngx_http_status_t           *status;
    ngx_http_upstream_t         *u;
    ngx_http_uwsgi_loc_conf_t   *uwcf;
#if (NGX_HTTP_CACHE)
    ngx_http_uwsgi_main_conf_t  *uwmcf;
#endif

    if (ngx_http_upstream_create(r) != NGX_OK) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    status = ngx_pcalloc(r->pool, sizeof(ngx_http_status_t));
    if (status == NULL) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    ngx_http_set_ctx(r, status, ngx_http_uwsgi_module);

    uwcf = ngx_http_get_module_loc_conf(r, ngx_http_uwsgi_module);

    u = r->upstream;

    if (uwcf->uwsgi_lengths == NULL) {

#if (NGX_HTTP_SSL)
        u->ssl = (uwcf->upstream.ssl != NULL);

        if (u->ssl) {
            ngx_str_set(&u->schema, ""suwsgi://"");

        } else {
            ngx_str_set(&u->schema, ""uwsgi://"");
        }
#else
        ngx_str_set(&u->schema, ""uwsgi://"");
#endif

   ...",1,1,http\modules\ngx_http_uwsgi_module.c,ngx_http_uwsgi_handler,,false,631,720,ngx_http_uwsgi_handler,,,35,ngx_int_t ngx_http_uwsgi_handler (ngx_http_request_t*)
243714,METHOD,http\modules\ngx_http_uwsgi_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_uwsgi_eval(ngx_http_request_t *r, ngx_http_uwsgi_loc_conf_t * uwcf)
{
    size_t                add;
    ngx_url_t             url;
    ngx_http_upstream_t  *u;

    ngx_memzero(&url, sizeof(ngx_url_t));

    if (ngx_http_script_run(r, &url.url, uwcf->uwsgi_lengths->elts, 0,
                            uwcf->uwsgi_values->elts)
        == NULL)
    {
        return NGX_ERROR;
    }

    if (url.url.len > 8
        && ngx_strncasecmp(url.url.data, (u_char *) ""uwsgi://"", 8) == 0)
    {
        add = 8;

    } else if (url.url.len > 9
               && ngx_strncasecmp(url.url.data, (u_char *) ""suwsgi://"", 9) == 0)
    {

#if (NGX_HTTP_SSL)
        add = 9;
        r->upstream->ssl = 1;
#else
        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                      ""suwsgi protocol requires SSL support"");
        return NGX_ERROR;
#endif

    } else {
        add = 0;
    }

    u = r->upstream;

    if (add) {
        u->schema.len = add;
        u->sche...",1,1,http\modules\ngx_http_uwsgi_module.c,ngx_http_uwsgi_eval,,false,723,802,ngx_http_uwsgi_eval,,,36,"ngx_int_t ngx_http_uwsgi_eval (ngx_http_request_t*,ngx_http_uwsgi_loc_conf_t*)"
244001,METHOD,http\modules\ngx_http_uwsgi_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_uwsgi_create_request(ngx_http_request_t *r)
{
    u_char                        ch, *lowcase_key;
    size_t                        key_len, val_len, len, allocated;
    ngx_uint_t                    i, n, hash, skip_empty, header_params;
    ngx_buf_t                    *b;
    ngx_chain_t                  *cl, *body;
    ngx_list_part_t              *part;
    ngx_table_elt_t              *header, **ignored;
    ngx_http_uwsgi_params_t      *params;
    ngx_http_script_code_pt       code;
    ngx_http_script_engine_t      e, le;
    ngx_http_uwsgi_loc_conf_t    *uwcf;
    ngx_http_script_len_code_pt   lcode;

    len = 0;
    header_params = 0;
    ignored = NULL;

    uwcf = ngx_http_get_module_loc_conf(r, ngx_http_uwsgi_module);

#if (NGX_HTTP_CACHE)
    params = r->upstream->cacheable ? &uwcf->params_cache : &uwcf->params;
#else
    params = &uwcf->params;
#endif

    if (params->lengths) {
        ngx_memzero(&le, sizeof(ngx_http_script_engine_t));

 ...",1,1,http\modules\ngx_http_uwsgi_module.c,ngx_http_uwsgi_create_request,,false,830,1147,ngx_http_uwsgi_create_request,,,37,ngx_int_t ngx_http_uwsgi_create_request (ngx_http_request_t*)
245187,METHOD,http\modules\ngx_http_uwsgi_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_uwsgi_reinit_request(ngx_http_request_t *r)
{
    ngx_http_status_t  *status;

    status = ngx_http_get_module_ctx(r, ngx_http_uwsgi_module);

    if (status == NULL) {
        return NGX_OK;
    }

    status->code = 0;
    status->count = 0;
    status->start = NULL;
    status->end = NULL;

    r->upstream->process_header = ngx_http_uwsgi_process_status_line;
    r->state = 0;

    return NGX_OK;
}",1,1,http\modules\ngx_http_uwsgi_module.c,ngx_http_uwsgi_reinit_request,,false,1150,1170,ngx_http_uwsgi_reinit_request,,,38,ngx_int_t ngx_http_uwsgi_reinit_request (ngx_http_request_t*)
245239,METHOD,http\modules\ngx_http_uwsgi_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_uwsgi_process_status_line(ngx_http_request_t *r)
{
    size_t                 len;
    ngx_int_t              rc;
    ngx_http_status_t     *status;
    ngx_http_upstream_t   *u;

    status = ngx_http_get_module_ctx(r, ngx_http_uwsgi_module);

    if (status == NULL) {
        return NGX_ERROR;
    }

    u = r->upstream;

    rc = ngx_http_parse_status_line(r, &u->buffer, status);

    if (rc == NGX_AGAIN) {
        return rc;
    }

    if (rc == NGX_ERROR) {
        u->process_header = ngx_http_uwsgi_process_header;
        return ngx_http_uwsgi_process_header(r);
    }

    if (u->state && u->state->status == 0) {
        u->state->status = status->code;
    }

    u->headers_in.status_n = status->code;

    len = status->end - status->start;
    u->headers_in.status_line.len = len;

    u->headers_in.status_line.data = ngx_pnalloc(r->pool, len);
    if (u->headers_in.status_line.data == NULL) {
        return NGX_ERROR;
    }

    ngx_memcpy(u->header...",1,1,http\modules\ngx_http_uwsgi_module.c,ngx_http_uwsgi_process_status_line,,false,1173,1223,ngx_http_uwsgi_process_status_line,,,39,ngx_int_t ngx_http_uwsgi_process_status_line (ngx_http_request_t*)
245409,METHOD,http\modules\ngx_http_uwsgi_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_uwsgi_process_header(ngx_http_request_t *r)
{
    ngx_str_t                      *status_line;
    ngx_int_t                       rc, status;
    ngx_table_elt_t                *h;
    ngx_http_upstream_t            *u;
    ngx_http_upstream_header_t     *hh;
    ngx_http_upstream_main_conf_t  *umcf;

    umcf = ngx_http_get_module_main_conf(r, ngx_http_upstream_module);

    for ( ;; ) {

        rc = ngx_http_parse_header_line(r, &r->upstream->buffer, 1);

        if (rc == NGX_OK) {

            /* a header line has been parsed successfully */

            h = ngx_list_push(&r->upstream->headers_in.headers);
            if (h == NULL) {
                return NGX_ERROR;
            }

            h->hash = r->header_hash;

            h->key.len = r->header_name_end - r->header_name_start;
            h->value.len = r->header_end - r->header_start;

            h->key.data = ngx_pnalloc(r->pool,
                                      h->key.len + 1 + h->...",1,1,http\modules\ngx_http_uwsgi_module.c,ngx_http_uwsgi_process_header,,false,1226,1355,ngx_http_uwsgi_process_header,,,40,ngx_int_t ngx_http_uwsgi_process_header (ngx_http_request_t*)
245922,METHOD,http\modules\ngx_http_uwsgi_module.c:<global>,TYPE_DECL,"static void
ngx_http_uwsgi_abort_request(ngx_http_request_t *r)
{
    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""abort http uwsgi request"");

    return;
}",1,1,http\modules\ngx_http_uwsgi_module.c,ngx_http_uwsgi_abort_request,,false,1358,1365,ngx_http_uwsgi_abort_request,,,41,void ngx_http_uwsgi_abort_request (ngx_http_request_t*)
245937,METHOD,http\modules\ngx_http_uwsgi_module.c:<global>,TYPE_DECL,"static void
ngx_http_uwsgi_finalize_request(ngx_http_request_t *r, ngx_int_t rc)
{
    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""finalize http uwsgi request"");

    return;
}",1,1,http\modules\ngx_http_uwsgi_module.c,ngx_http_uwsgi_finalize_request,,false,1368,1375,ngx_http_uwsgi_finalize_request,,,42,"void ngx_http_uwsgi_finalize_request (ngx_http_request_t*,ngx_int_t)"
245953,METHOD,http\modules\ngx_http_uwsgi_module.c:<global>,TYPE_DECL,"static void *
ngx_http_uwsgi_create_main_conf(ngx_conf_t *cf)
{
    ngx_http_uwsgi_main_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_uwsgi_main_conf_t));
    if (conf == NULL) {
        return NULL;
    }

#if (NGX_HTTP_CACHE)
    if (ngx_array_init(&conf->caches, cf->pool, 4,
                       sizeof(ngx_http_file_cache_t *))
        != NGX_OK)
    {
        return NULL;
    }
#endif

    return conf;
}",1,1,http\modules\ngx_http_uwsgi_module.c,ngx_http_uwsgi_create_main_conf,,false,1378,1398,ngx_http_uwsgi_create_main_conf,,,43,void* ngx_http_uwsgi_create_main_conf (ngx_conf_t*)
245976,METHOD,http\modules\ngx_http_uwsgi_module.c:<global>,TYPE_DECL,"static void *
ngx_http_uwsgi_create_loc_conf(ngx_conf_t *cf)
{
    ngx_http_uwsgi_loc_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_uwsgi_loc_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    conf->modifier1 = NGX_CONF_UNSET_UINT;
    conf->modifier2 = NGX_CONF_UNSET_UINT;

    conf->upstream.store = NGX_CONF_UNSET;
    conf->upstream.store_access = NGX_CONF_UNSET_UINT;
    conf->upstream.next_upstream_tries = NGX_CONF_UNSET_UINT;
    conf->upstream.buffering = NGX_CONF_UNSET;
    conf->upstream.request_buffering = NGX_CONF_UNSET;
    conf->upstream.ignore_client_abort = NGX_CONF_UNSET;
    conf->upstream.force_ranges = NGX_CONF_UNSET;

    conf->upstream.local = NGX_CONF_UNSET_PTR;
    conf->upstream.socket_keepalive = NGX_CONF_UNSET;

    conf->upstream.connect_timeout = NGX_CONF_UNSET_MSEC;
    conf->upstream.send_timeout = NGX_CONF_UNSET_MSEC;
    conf->upstream.read_timeout = NGX_CONF_UNSET_MSEC;
    conf->upstream.next_upstream_timeout = NGX_...",1,1,http\modules\ngx_http_uwsgi_module.c,ngx_http_uwsgi_create_loc_conf,,false,1401,1476,ngx_http_uwsgi_create_loc_conf,,,44,void* ngx_http_uwsgi_create_loc_conf (ngx_conf_t*)
246199,METHOD,http\modules\ngx_http_uwsgi_module.c:<global>,TYPE_DECL,"static char *
ngx_http_uwsgi_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_uwsgi_loc_conf_t *prev = parent;
    ngx_http_uwsgi_loc_conf_t *conf = child;

    size_t                        size;
    ngx_int_t                     rc;
    ngx_hash_init_t               hash;
    ngx_http_core_loc_conf_t     *clcf;

#if (NGX_HTTP_CACHE)

    if (conf->upstream.store > 0) {
        conf->upstream.cache = 0;
    }

    if (conf->upstream.cache > 0) {
        conf->upstream.store = 0;
    }

#endif

    if (conf->upstream.store == NGX_CONF_UNSET) {
        ngx_conf_merge_value(conf->upstream.store, prev->upstream.store, 0);

        conf->upstream.store_lengths = prev->upstream.store_lengths;
        conf->upstream.store_values = prev->upstream.store_values;
    }

    ngx_conf_merge_uint_value(conf->upstream.store_access,
                              prev->upstream.store_access, 0600);

    ngx_conf_merge_uint_value(conf->upstream.next_upstream_tries,
          ...",1,1,http\modules\ngx_http_uwsgi_module.c,ngx_http_uwsgi_merge_loc_conf,,false,1479,1879,ngx_http_uwsgi_merge_loc_conf,,,45,"char* ngx_http_uwsgi_merge_loc_conf (ngx_conf_t*,void*,void*)"
247024,METHOD,http\modules\ngx_http_uwsgi_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_uwsgi_init_params(ngx_conf_t *cf, ngx_http_uwsgi_loc_conf_t *conf,
    ngx_http_uwsgi_params_t *params, ngx_keyval_t *default_params)
{
    u_char                       *p;
    size_t                        size;
    uintptr_t                    *code;
    ngx_uint_t                    i, nsrc;
    ngx_array_t                   headers_names, params_merged;
    ngx_keyval_t                 *h;
    ngx_hash_key_t               *hk;
    ngx_hash_init_t               hash;
    ngx_http_upstream_param_t    *src, *s;
    ngx_http_script_compile_t     sc;
    ngx_http_script_copy_code_t  *copy;

    if (params->hash.buckets) {
        return NGX_OK;
    }

    if (conf->params_source == NULL && default_params == NULL) {
        params->hash.buckets = (void *) 1;
        return NGX_OK;
    }

    params->lengths = ngx_array_create(cf->pool, 64, 1);
    if (params->lengths == NULL) {
        return NGX_ERROR;
    }

    params->values = ngx_array_create(cf->pool, 5...",1,1,http\modules\ngx_http_uwsgi_module.c,ngx_http_uwsgi_init_params,,false,1882,2084,ngx_http_uwsgi_init_params,,,46,"ngx_int_t ngx_http_uwsgi_init_params (ngx_conf_t*,ngx_http_uwsgi_loc_conf_t*,ngx_http_uwsgi_params_t*,ngx_keyval_t*)"
247732,METHOD,http\modules\ngx_http_uwsgi_module.c:<global>,TYPE_DECL,"static char *
ngx_http_uwsgi_pass(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_uwsgi_loc_conf_t *uwcf = conf;

    size_t                      add;
    ngx_url_t                   u;
    ngx_str_t                  *value, *url;
    ngx_uint_t                  n;
    ngx_http_core_loc_conf_t   *clcf;
    ngx_http_script_compile_t   sc;

    if (uwcf->upstream.upstream || uwcf->uwsgi_lengths) {
        return ""is duplicate"";
    }

    clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);
    clcf->handler = ngx_http_uwsgi_handler;

    value = cf->args->elts;

    url = &value[1];

    n = ngx_http_script_variables_count(url);

    if (n) {

        ngx_memzero(&sc, sizeof(ngx_http_script_compile_t));

        sc.cf = cf;
        sc.source = url;
        sc.lengths = &uwcf->uwsgi_lengths;
        sc.values = &uwcf->uwsgi_values;
        sc.variables = n;
        sc.complete_lengths = 1;
        sc.complete_values = 1;

        if (ngx_http_script_compi...",1,1,http\modules\ngx_http_uwsgi_module.c,ngx_http_uwsgi_pass,,false,2087,2169,ngx_http_uwsgi_pass,,,47,"char* ngx_http_uwsgi_pass (ngx_conf_t*,ngx_command_t*,void*)"
247975,METHOD,http\modules\ngx_http_uwsgi_module.c:<global>,TYPE_DECL,"static char *
ngx_http_uwsgi_store(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_uwsgi_loc_conf_t *uwcf = conf;

    ngx_str_t                  *value;
    ngx_http_script_compile_t   sc;

    if (uwcf->upstream.store != NGX_CONF_UNSET) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    if (ngx_strcmp(value[1].data, ""off"") == 0) {
        uwcf->upstream.store = 0;
        return NGX_CONF_OK;
    }

#if (NGX_HTTP_CACHE)

    if (uwcf->upstream.cache > 0) {
        return ""is incompatible with \""uwsgi_cache\"""";
    }

#endif

    uwcf->upstream.store = 1;

    if (ngx_strcmp(value[1].data, ""on"") == 0) {
        return NGX_CONF_OK;
    }

    /* include the terminating '\0' into script */
    value[1].len++;

    ngx_memzero(&sc, sizeof(ngx_http_script_compile_t));

    sc.cf = cf;
    sc.source = &value[1];
    sc.lengths = &uwcf->upstream.store_lengths;
    sc.values = &uwcf->upstream.store_values;
    sc.variables = ngx_http_script_variables_co...",1,1,http\modules\ngx_http_uwsgi_module.c,ngx_http_uwsgi_store,,false,2172,2223,ngx_http_uwsgi_store,,,48,"char* ngx_http_uwsgi_store (ngx_conf_t*,ngx_command_t*,void*)"
248145,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,<global>,1,5,http\modules\ngx_http_xslt_filter_module.c,http\modules\ngx_http_xslt_filter_module.c:<global>,,false,1,1156,<global>,,,1,
248180,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_xslt_send(ngx_http_request_t *r,
    ngx_http_xslt_filter_ctx_t *ctx, ngx_buf_t *b);",18,50,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_send,,false,76,77,ngx_http_xslt_send,,,13,"ngx_int_t ngx_http_xslt_send (ngx_http_request_t*,ngx_http_xslt_filter_ctx_t*,ngx_buf_t*)"
248187,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_xslt_add_chunk(ngx_http_request_t *r,
    ngx_http_xslt_filter_ctx_t *ctx, ngx_buf_t *b);",18,50,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_add_chunk,,false,78,79,ngx_http_xslt_add_chunk,,,14,"ngx_int_t ngx_http_xslt_add_chunk (ngx_http_request_t*,ngx_http_xslt_filter_ctx_t*,ngx_buf_t*)"
248194,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,"static void ngx_http_xslt_sax_external_subset(void *data, const xmlChar *name,
    const xmlChar *externalId, const xmlChar *systemId);",13,55,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_sax_external_subset,,false,82,83,ngx_http_xslt_sax_external_subset,,,15,"void ngx_http_xslt_sax_external_subset (void*,xmlChar*,xmlChar*,xmlChar*)"
248203,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,"static ngx_buf_t *ngx_http_xslt_apply_stylesheet(ngx_http_request_t *r,
    ngx_http_xslt_filter_ctx_t *ctx);",18,36,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_apply_stylesheet,,false,87,88,ngx_http_xslt_apply_stylesheet,,,17,"ngx_buf_t* ngx_http_xslt_apply_stylesheet (ngx_http_request_t*,ngx_http_xslt_filter_ctx_t*)"
248209,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_xslt_params(ngx_http_request_t *r,
    ngx_http_xslt_filter_ctx_t *ctx, ngx_array_t *params, ngx_uint_t final);",18,75,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_params,,false,89,90,ngx_http_xslt_params,,,18,"ngx_int_t ngx_http_xslt_params (ngx_http_request_t*,ngx_http_xslt_filter_ctx_t*,ngx_array_t*,ngx_uint_t)"
248217,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,static u_char *ngx_http_xslt_content_type(xsltStylesheetPtr s);,15,62,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_content_type,,false,91,91,ngx_http_xslt_content_type,,,19,u_char* ngx_http_xslt_content_type (xsltStylesheetPtr)
248222,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,static u_char *ngx_http_xslt_encoding(xsltStylesheetPtr s);,15,58,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_encoding,,false,92,92,ngx_http_xslt_encoding,,,20,u_char* ngx_http_xslt_encoding (xsltStylesheetPtr)
248227,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,static void ngx_http_xslt_cleanup(void *data);,13,45,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_cleanup,,false,93,93,ngx_http_xslt_cleanup,,,21,void ngx_http_xslt_cleanup (void*)
248232,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,"static char *ngx_http_xslt_entities(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_entities,,false,95,96,ngx_http_xslt_entities,,,22,"char* ngx_http_xslt_entities (ngx_conf_t*,ngx_command_t*,void*)"
248239,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,"static char *ngx_http_xslt_stylesheet(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_stylesheet,,false,97,98,ngx_http_xslt_stylesheet,,,23,"char* ngx_http_xslt_stylesheet (ngx_conf_t*,ngx_command_t*,void*)"
248246,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,"static char *ngx_http_xslt_param(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_param,,false,99,100,ngx_http_xslt_param,,,24,"char* ngx_http_xslt_param (ngx_conf_t*,ngx_command_t*,void*)"
248253,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,static void ngx_http_xslt_cleanup_dtd(void *data);,13,49,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_cleanup_dtd,,false,101,101,ngx_http_xslt_cleanup_dtd,,,25,void ngx_http_xslt_cleanup_dtd (void*)
248258,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,static void ngx_http_xslt_cleanup_stylesheet(void *data);,13,56,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_cleanup_stylesheet,,false,102,102,ngx_http_xslt_cleanup_stylesheet,,,26,void ngx_http_xslt_cleanup_stylesheet (void*)
248263,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,static void *ngx_http_xslt_filter_create_main_conf(ngx_conf_t *cf);,13,66,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_filter_create_main_conf,,false,103,103,ngx_http_xslt_filter_create_main_conf,,,27,void* ngx_http_xslt_filter_create_main_conf (ngx_conf_t*)
248268,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,static void *ngx_http_xslt_filter_create_conf(ngx_conf_t *cf);,13,61,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_filter_create_conf,,false,104,104,ngx_http_xslt_filter_create_conf,,,28,void* ngx_http_xslt_filter_create_conf (ngx_conf_t*)
248273,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,"static char *ngx_http_xslt_filter_merge_conf(ngx_conf_t *cf, void *parent,
    void *child);",13,16,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_filter_merge_conf,,false,105,106,ngx_http_xslt_filter_merge_conf,,,29,"char* ngx_http_xslt_filter_merge_conf (ngx_conf_t*,void*,void*)"
248280,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_xslt_filter_preconfiguration(ngx_conf_t *cf);,18,70,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_filter_preconfiguration,,false,107,107,ngx_http_xslt_filter_preconfiguration,,,30,ngx_int_t ngx_http_xslt_filter_preconfiguration (ngx_conf_t*)
248285,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_xslt_filter_init(ngx_conf_t *cf);,18,58,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_filter_init,,false,108,108,ngx_http_xslt_filter_init,,,31,ngx_int_t ngx_http_xslt_filter_init (ngx_conf_t*)
248290,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,static void ngx_http_xslt_filter_exit(ngx_cycle_t *cycle);,13,57,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_filter_exit,,false,109,109,ngx_http_xslt_filter_exit,,,32,void ngx_http_xslt_filter_exit (ngx_cycle_t*)
248427,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_xslt_header_filter(ngx_http_request_t *r)
{
    ngx_http_xslt_filter_ctx_t       *ctx;
    ngx_http_xslt_filter_loc_conf_t  *conf;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""xslt filter header"");

    if (r->headers_out.status == NGX_HTTP_NOT_MODIFIED) {
        return ngx_http_next_header_filter(r);
    }

    conf = ngx_http_get_module_loc_conf(r, ngx_http_xslt_filter_module);

    if (conf->sheets.nelts == 0
        || ngx_http_test_content_type(r, &conf->types) == NULL)
    {
        return ngx_http_next_header_filter(r);
    }

    ctx = ngx_http_get_module_ctx(r, ngx_http_xslt_filter_module);

    if (ctx) {
        return ngx_http_next_header_filter(r);
    }

    ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_xslt_filter_ctx_t));
    if (ctx == NULL) {
        return NGX_ERROR;
    }

    ngx_http_set_ctx(r, ctx, ngx_http_xslt_filter_module);

    r->main_filter_need_in_memory = 1;

    return NGX_OK;
}",1,1,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_header_filter,,false,201,238,ngx_http_xslt_header_filter,,,43,ngx_int_t ngx_http_xslt_header_filter (ngx_http_request_t*)
248518,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_xslt_body_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    int                          wellFormed;
    ngx_chain_t                 *cl;
    ngx_http_xslt_filter_ctx_t  *ctx;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""xslt filter body"");

    if (in == NULL) {
        return ngx_http_next_body_filter(r, in);
    }

    ctx = ngx_http_get_module_ctx(r, ngx_http_xslt_filter_module);

    if (ctx == NULL || ctx->done) {
        return ngx_http_next_body_filter(r, in);
    }

    for (cl = in; cl; cl = cl->next) {

        if (ngx_http_xslt_add_chunk(r, ctx, cl->buf) != NGX_OK) {

            if (ctx->ctxt->myDoc) {

#if (NGX_HTTP_XSLT_REUSE_DTD)
                ctx->ctxt->myDoc->extSubset = NULL;
#endif
                xmlFreeDoc(ctx->ctxt->myDoc);
            }

            xmlFreeParserCtxt(ctx->ctxt);

            return ngx_http_xslt_send(r, ctx, NULL);
        }

        if (cl->buf->last_buf || cl->buf->last_in...",1,5,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_body_filter,,false,241,305,ngx_http_xslt_body_filter,,,44,"ngx_int_t ngx_http_xslt_body_filter (ngx_http_request_t*,ngx_chain_t*)"
248686,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_xslt_send(ngx_http_request_t *r, ngx_http_xslt_filter_ctx_t *ctx,
    ngx_buf_t *b)
{
    ngx_int_t                         rc;
    ngx_chain_t                       out;
    ngx_pool_cleanup_t               *cln;
    ngx_http_xslt_filter_loc_conf_t  *conf;

    ctx->done = 1;

    if (b == NULL) {
        return ngx_http_filter_finalize_request(r, &ngx_http_xslt_filter_module,
                                               NGX_HTTP_INTERNAL_SERVER_ERROR);
    }

    cln = ngx_pool_cleanup_add(r->pool, 0);

    if (cln == NULL) {
        ngx_free(b->pos);
        return ngx_http_filter_finalize_request(r, &ngx_http_xslt_filter_module,
                                               NGX_HTTP_INTERNAL_SERVER_ERROR);
    }

    if (r == r->main) {
        r->headers_out.content_length_n = b->last - b->pos;

        if (r->headers_out.content_length) {
            r->headers_out.content_length->hash = 0;
            r->headers_out.content_length = NULL;
        ...",1,1,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_send,,false,308,365,ngx_http_xslt_send,,,45,"ngx_int_t ngx_http_xslt_send (ngx_http_request_t*,ngx_http_xslt_filter_ctx_t*,ngx_buf_t*)"
248847,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_xslt_add_chunk(ngx_http_request_t *r, ngx_http_xslt_filter_ctx_t *ctx,
    ngx_buf_t *b)
{
    int               err;
    xmlParserCtxtPtr  ctxt;

    if (ctx->ctxt == NULL) {

        ctxt = xmlCreatePushParserCtxt(NULL, NULL, NULL, 0, NULL);
        if (ctxt == NULL) {
            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                          ""xmlCreatePushParserCtxt() failed"");
            return NGX_ERROR;
        }
        xmlCtxtUseOptions(ctxt, XML_PARSE_NOENT|XML_PARSE_DTDLOAD
                                               |XML_PARSE_NOWARNING);

        ctxt->sax->externalSubset = ngx_http_xslt_sax_external_subset;
        ctxt->sax->setDocumentLocator = NULL;
        ctxt->sax->error = ngx_http_xslt_sax_error;
        ctxt->sax->fatalError = ngx_http_xslt_sax_error;
        ctxt->sax->_private = ctx;

        ctx->ctxt = ctxt;
        ctx->request = r;
    }

    err = xmlParseChunk(ctx->ctxt, (char *) b->pos, (int) (b->last - b->pos)...",1,1,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_add_chunk,,false,368,408,ngx_http_xslt_add_chunk,,,46,"ngx_int_t ngx_http_xslt_add_chunk (ngx_http_request_t*,ngx_http_xslt_filter_ctx_t*,ngx_buf_t*)"
248992,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,"static void
ngx_http_xslt_sax_external_subset(void *data, const xmlChar *name,
    const xmlChar *externalId, const xmlChar *systemId)
{
    xmlParserCtxtPtr ctxt = data;

    xmlDocPtr                         doc;
    xmlDtdPtr                         dtd;
    ngx_http_request_t               *r;
    ngx_http_xslt_filter_ctx_t       *ctx;
    ngx_http_xslt_filter_loc_conf_t  *conf;

    ctx = ctxt->sax->_private;
    r = ctx->request;

    conf = ngx_http_get_module_loc_conf(r, ngx_http_xslt_filter_module);

    ngx_log_debug3(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""xslt filter extSubset: \""%s\"" \""%s\"" \""%s\"""",
                   name ? name : (xmlChar *) """",
                   externalId ? externalId : (xmlChar *) """",
                   systemId ? systemId : (xmlChar *) """");

    doc = ctxt->myDoc;

#if (NGX_HTTP_XSLT_REUSE_DTD)

    dtd = conf->dtd;

#else

    dtd = xmlCopyDtd(conf->dtd);
    if (dtd == NULL) {
        ngx_log_error(NGX_LOG_ERR, r->connect...",1,5,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_sax_external_subset,,false,411,459,ngx_http_xslt_sax_external_subset,,,47,"void ngx_http_xslt_sax_external_subset (void*,xmlChar*,xmlChar*,xmlChar*)"
249070,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,"ngx_http_xslt_sax_error(void *data, const char *msg, ...)
{
    xmlParserCtxtPtr ctxt = data;

    size_t                       n;
    va_list                      args;
    ngx_http_xslt_filter_ctx_t  *ctx;
    u_char                       buf[NGX_MAX_ERROR_STR];

    ctx = ctxt->sax->_private;

    buf[0] = '\0';

    va_start(args, msg);
    n = (size_t) vsnprintf((char *) buf, NGX_MAX_ERROR_STR, msg, args);
    va_end(args);

    while (--n && (buf[n] == CR || buf[n] == LF)) { /* void */ }

    ngx_log_error(NGX_LOG_ERR, ctx->request->connection->log, 0,
                  ""libxml2 error: \""%*s\"""", n + 1, buf);
}",1,1,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_sax_error,,false,463,484,ngx_http_xslt_sax_error,,,50,"ANY ngx_http_xslt_sax_error (void*,char*...)"
249143,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,"static ngx_buf_t *
ngx_http_xslt_apply_stylesheet(ngx_http_request_t *r,
    ngx_http_xslt_filter_ctx_t *ctx)
{
    int                               len, rc, doc_type;
    u_char                           *type, *encoding;
    ngx_buf_t                        *b;
    ngx_uint_t                        i;
    xmlChar                          *buf;
    xmlDocPtr                         doc, res;
    ngx_http_xslt_sheet_t            *sheet;
    ngx_http_xslt_filter_loc_conf_t  *conf;

    conf = ngx_http_get_module_loc_conf(r, ngx_http_xslt_filter_module);
    sheet = conf->sheets.elts;
    doc = ctx->doc;

    /* preallocate array for 4 params */

    if (ngx_array_init(&ctx->params, r->pool, 4 * 2 + 1, sizeof(char *))
        != NGX_OK)
    {
        xmlFreeDoc(doc);
        return NULL;
    }

    for (i = 0; i < conf->sheets.nelts; i++) {

        ctx->transform = xsltNewTransformContext(sheet[i].stylesheet, doc);
        if (ctx->transform == NULL) {
            xmlFreeDoc(doc);
 ...",1,1,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_apply_stylesheet,,false,487,624,ngx_http_xslt_apply_stylesheet,,,51,"ngx_buf_t ngx_http_xslt_apply_stylesheet (ngx_http_request_t*,ngx_http_xslt_filter_ctx_t*)"
249576,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_xslt_params(ngx_http_request_t *r, ngx_http_xslt_filter_ctx_t *ctx,
    ngx_array_t *params, ngx_uint_t final)
{
    u_char                 *p, *value, *dst, *src, **s;
    size_t                  len;
    ngx_uint_t              i;
    ngx_str_t               string;
    ngx_http_xslt_param_t  *param;

    param = params->elts;

    for (i = 0; i < params->nelts; i++) {

        if (ngx_http_complex_value(r, &param[i].value, &string) != NGX_OK) {
            return NGX_ERROR;
        }

        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                       ""xslt filter param: \""%s\"""", string.data);

        if (param[i].name) {

            ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                           ""xslt filter param name: \""%s\"""", param[i].name);

            if (param[i].quote) {
                if (xsltQuoteOneUserParam(ctx->transform, param[i].name,
                                          string.data)
     ...",1,1,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_params,,false,627,765,ngx_http_xslt_params,,,52,"ngx_int_t ngx_http_xslt_params (ngx_http_request_t*,ngx_http_xslt_filter_ctx_t*,ngx_array_t*,ngx_uint_t)"
249963,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,"static u_char *
ngx_http_xslt_content_type(xsltStylesheetPtr s)
{
    u_char  *type;

    if (s->mediaType) {
        return s->mediaType;
    }

    for (s = s->imports; s; s = s->next) {

        type = ngx_http_xslt_content_type(s);

        if (type) {
            return type;
        }
    }

    return NULL;
}",1,1,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_content_type,,false,768,787,ngx_http_xslt_content_type,,,53,u_char ngx_http_xslt_content_type (xsltStylesheetPtr)
250003,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,"static u_char *
ngx_http_xslt_encoding(xsltStylesheetPtr s)
{
    u_char  *encoding;

    if (s->encoding) {
        return s->encoding;
    }

    for (s = s->imports; s; s = s->next) {

        encoding = ngx_http_xslt_encoding(s);

        if (encoding) {
            return encoding;
        }
    }

    return NULL;
}",1,1,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_encoding,,false,790,809,ngx_http_xslt_encoding,,,54,u_char ngx_http_xslt_encoding (xsltStylesheetPtr)
250043,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,"static void
ngx_http_xslt_cleanup(void *data)
{
    ngx_free(data);
}",1,1,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_cleanup,,false,812,816,ngx_http_xslt_cleanup,,,55,void ngx_http_xslt_cleanup (void*)
250050,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,"static char *
ngx_http_xslt_entities(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_xslt_filter_loc_conf_t *xlcf = conf;

    ngx_str_t                         *value;
    ngx_uint_t                         i;
    ngx_pool_cleanup_t                *cln;
    ngx_http_xslt_file_t              *file;
    ngx_http_xslt_filter_main_conf_t  *xmcf;

    if (xlcf->dtd) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    xmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_xslt_filter_module);

    file = xmcf->dtd_files.elts;
    for (i = 0; i < xmcf->dtd_files.nelts; i++) {
        if (ngx_strcmp(file[i].name, value[1].data) == 0) {
            xlcf->dtd = file[i].data;
            return NGX_CONF_OK;
        }
    }

    cln = ngx_pool_cleanup_add(cf->pool, 0);
    if (cln == NULL) {
        return NGX_CONF_ERROR;
    }

    xlcf->dtd = xmlParseDTD(NULL, (xmlChar *) value[1].data);

    if (xlcf->dtd == NULL) {
        ngx_conf_log_error(NGX_LOG_ERR,...",1,1,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_entities,,false,819,870,ngx_http_xslt_entities,,,56,"char* ngx_http_xslt_entities (ngx_conf_t*,ngx_command_t*,void*)"
250218,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,"static char *
ngx_http_xslt_stylesheet(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_xslt_filter_loc_conf_t *xlcf = conf;

    ngx_str_t                         *value;
    ngx_uint_t                         i, n;
    ngx_pool_cleanup_t                *cln;
    ngx_http_xslt_file_t              *file;
    ngx_http_xslt_sheet_t             *sheet;
    ngx_http_xslt_param_t             *param;
    ngx_http_compile_complex_value_t   ccv;
    ngx_http_xslt_filter_main_conf_t  *xmcf;

    value = cf->args->elts;

    if (xlcf->sheets.elts == NULL) {
        if (ngx_array_init(&xlcf->sheets, cf->pool, 1,
                           sizeof(ngx_http_xslt_sheet_t))
            != NGX_OK)
        {
            return NGX_CONF_ERROR;
        }
    }

    sheet = ngx_array_push(&xlcf->sheets);
    if (sheet == NULL) {
        return NGX_CONF_ERROR;
    }

    ngx_memzero(sheet, sizeof(ngx_http_xslt_sheet_t));

    if (ngx_conf_full_name(cf->cycle, &value[1], 0) != NGX_OK) {
    ...",1,1,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_stylesheet,,false,874,980,ngx_http_xslt_stylesheet,,,57,"char* ngx_http_xslt_stylesheet (ngx_conf_t*,ngx_command_t*,void*)"
250546,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,"static char *
ngx_http_xslt_param(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_xslt_filter_loc_conf_t  *xlcf = conf;

    ngx_http_xslt_param_t            *param;
    ngx_http_compile_complex_value_t  ccv;
    ngx_str_t                        *value;

    value = cf->args->elts;

    if (xlcf->params == NULL) {
        xlcf->params = ngx_array_create(cf->pool, 2,
                                        sizeof(ngx_http_xslt_param_t));
        if (xlcf->params == NULL) {
            return NGX_CONF_ERROR;
        }
    }

    param = ngx_array_push(xlcf->params);
    if (param == NULL) {
        return NGX_CONF_ERROR;
    }

    param->name = value[1].data;
    param->quote = (cmd->post == NULL) ? 0 : 1;

    ngx_memzero(&ccv, sizeof(ngx_http_compile_complex_value_t));

    ccv.cf = cf;
    ccv.value = &value[2];
    ccv.complex_value = &param->value;
    ccv.zero = 1;

    if (ngx_http_compile_complex_value(&ccv) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

  ...",1,1,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_param,,false,983,1022,ngx_http_xslt_param,,,58,"char* ngx_http_xslt_param (ngx_conf_t*,ngx_command_t*,void*)"
250670,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,"static void
ngx_http_xslt_cleanup_dtd(void *data)
{
    xmlFreeDtd(data);
}",1,1,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_cleanup_dtd,,false,1025,1029,ngx_http_xslt_cleanup_dtd,,,59,void ngx_http_xslt_cleanup_dtd (void*)
250677,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,"static void
ngx_http_xslt_cleanup_stylesheet(void *data)
{
    xsltFreeStylesheet(data);
}",1,1,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_cleanup_stylesheet,,false,1032,1036,ngx_http_xslt_cleanup_stylesheet,,,60,void ngx_http_xslt_cleanup_stylesheet (void*)
250684,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,"static void *
ngx_http_xslt_filter_create_main_conf(ngx_conf_t *cf)
{
    ngx_http_xslt_filter_main_conf_t  *conf;

    conf = ngx_palloc(cf->pool, sizeof(ngx_http_xslt_filter_main_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    if (ngx_array_init(&conf->dtd_files, cf->pool, 1,
                       sizeof(ngx_http_xslt_file_t))
        != NGX_OK)
    {
        return NULL;
    }

    if (ngx_array_init(&conf->sheet_files, cf->pool, 1,
                       sizeof(ngx_http_xslt_file_t))
        != NGX_OK)
    {
        return NULL;
    }

    return conf;
}",1,1,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_filter_create_main_conf,,false,1039,1064,ngx_http_xslt_filter_create_main_conf,,,61,void* ngx_http_xslt_filter_create_main_conf (ngx_conf_t*)
250741,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,"static void *
ngx_http_xslt_filter_create_conf(ngx_conf_t *cf)
{
    ngx_http_xslt_filter_loc_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_xslt_filter_loc_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     conf->dtd = NULL;
     *     conf->sheets = { NULL };
     *     conf->types = { NULL };
     *     conf->types_keys = NULL;
     *     conf->params = NULL;
     */

    conf->last_modified = NGX_CONF_UNSET;

    return conf;
}",1,1,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_filter_create_conf,,false,1067,1090,ngx_http_xslt_filter_create_conf,,,62,void* ngx_http_xslt_filter_create_conf (ngx_conf_t*)
250769,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,"static char *
ngx_http_xslt_filter_merge_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_xslt_filter_loc_conf_t *prev = parent;
    ngx_http_xslt_filter_loc_conf_t *conf = child;

    if (conf->dtd == NULL) {
        conf->dtd = prev->dtd;
    }

    if (conf->sheets.nelts == 0) {
        conf->sheets = prev->sheets;
    }

    if (conf->params == NULL) {
        conf->params = prev->params;
    }

    if (ngx_http_merge_types(cf, &conf->types_keys, &conf->types,
                             &prev->types_keys, &prev->types,
                             ngx_http_xslt_default_types)
        != NGX_OK)
    {
        return NGX_CONF_ERROR;
    }

    ngx_conf_merge_value(conf->last_modified, prev->last_modified, 0);

    return NGX_CONF_OK;
}",1,1,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_filter_merge_conf,,false,1093,1122,ngx_http_xslt_filter_merge_conf,,,63,"char* ngx_http_xslt_filter_merge_conf (ngx_conf_t*,void*,void*)"
250863,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_xslt_filter_preconfiguration(ngx_conf_t *cf)
{
    xmlInitParser();

#if (NGX_HAVE_EXSLT)
    exsltRegisterAll();
#endif

    return NGX_OK;
}",1,1,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_filter_preconfiguration,,false,1125,1135,ngx_http_xslt_filter_preconfiguration,,,64,ngx_int_t ngx_http_xslt_filter_preconfiguration (ngx_conf_t*)
250871,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_xslt_filter_init(ngx_conf_t *cf)
{
    ngx_http_next_header_filter = ngx_http_top_header_filter;
    ngx_http_top_header_filter = ngx_http_xslt_header_filter;

    ngx_http_next_body_filter = ngx_http_top_body_filter;
    ngx_http_top_body_filter = ngx_http_xslt_body_filter;

    return NGX_OK;
}",1,1,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_filter_init,,false,1138,1148,ngx_http_xslt_filter_init,,,65,ngx_int_t ngx_http_xslt_filter_init (ngx_conf_t*)
250890,METHOD,http\modules\ngx_http_xslt_filter_module.c:<global>,TYPE_DECL,"static void
ngx_http_xslt_filter_exit(ngx_cycle_t *cycle)
{
    xsltCleanupGlobals();
    xmlCleanupParser();
}",1,1,http\modules\ngx_http_xslt_filter_module.c,ngx_http_xslt_filter_exit,,false,1151,1156,ngx_http_xslt_filter_exit,,,66,void ngx_http_xslt_filter_exit (ngx_cycle_t*)
250908,METHOD,http\modules\perl\ngx_http_perl_module.c:<global>,TYPE_DECL,<global>,1,58,http\modules\perl\ngx_http_perl_module.c,http\modules\perl\ngx_http_perl_module.c:<global>,,false,1,1135,<global>,,,1,
250924,METHOD,http\modules\perl\ngx_http_perl_module.c:<global>,TYPE_DECL,"static char *ngx_http_perl_init_interpreter(ngx_conf_t *cf,
    ngx_http_perl_main_conf_t *pmcf);",13,36,http\modules\perl\ngx_http_perl_module.c,ngx_http_perl_init_interpreter,,false,39,40,ngx_http_perl_init_interpreter,,,7,"char* ngx_http_perl_init_interpreter (ngx_conf_t*,ngx_http_perl_main_conf_t*)"
250930,METHOD,http\modules\perl\ngx_http_perl_module.c:<global>,TYPE_DECL,"static PerlInterpreter *ngx_http_perl_create_interpreter(ngx_conf_t *cf,
    ngx_http_perl_main_conf_t *pmcf);",24,36,http\modules\perl\ngx_http_perl_module.c,ngx_http_perl_create_interpreter,,false,41,42,ngx_http_perl_create_interpreter,,,8,"PerlInterpreter* ngx_http_perl_create_interpreter (ngx_conf_t*,ngx_http_perl_main_conf_t*)"
250939,METHOD,http\modules\perl\ngx_http_perl_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_perl_preconfiguration(ngx_conf_t *cf);,18,63,http\modules\perl\ngx_http_perl_module.c,ngx_http_perl_preconfiguration,,false,50,50,ngx_http_perl_preconfiguration,,,12,ngx_int_t ngx_http_perl_preconfiguration (ngx_conf_t*)
250944,METHOD,http\modules\perl\ngx_http_perl_module.c:<global>,TYPE_DECL,static void *ngx_http_perl_create_main_conf(ngx_conf_t *cf);,13,59,http\modules\perl\ngx_http_perl_module.c,ngx_http_perl_create_main_conf,,false,51,51,ngx_http_perl_create_main_conf,,,13,void* ngx_http_perl_create_main_conf (ngx_conf_t*)
250949,METHOD,http\modules\perl\ngx_http_perl_module.c:<global>,TYPE_DECL,"static char *ngx_http_perl_init_main_conf(ngx_conf_t *cf, void *conf);",13,69,http\modules\perl\ngx_http_perl_module.c,ngx_http_perl_init_main_conf,,false,52,52,ngx_http_perl_init_main_conf,,,14,"char* ngx_http_perl_init_main_conf (ngx_conf_t*,void*)"
250955,METHOD,http\modules\perl\ngx_http_perl_module.c:<global>,TYPE_DECL,static void *ngx_http_perl_create_loc_conf(ngx_conf_t *cf);,13,58,http\modules\perl\ngx_http_perl_module.c,ngx_http_perl_create_loc_conf,,false,53,53,ngx_http_perl_create_loc_conf,,,15,void* ngx_http_perl_create_loc_conf (ngx_conf_t*)
250960,METHOD,http\modules\perl\ngx_http_perl_module.c:<global>,TYPE_DECL,"static char *ngx_http_perl_merge_loc_conf(ngx_conf_t *cf, void *parent,
    void *child);",13,16,http\modules\perl\ngx_http_perl_module.c,ngx_http_perl_merge_loc_conf,,false,54,55,ngx_http_perl_merge_loc_conf,,,16,"char* ngx_http_perl_merge_loc_conf (ngx_conf_t*,void*,void*)"
250967,METHOD,http\modules\perl\ngx_http_perl_module.c:<global>,TYPE_DECL,"static char *ngx_http_perl(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",13,74,http\modules\perl\ngx_http_perl_module.c,ngx_http_perl,,false,56,56,ngx_http_perl,,,17,"char* ngx_http_perl (ngx_conf_t*,ngx_command_t*,void*)"
250974,METHOD,http\modules\perl\ngx_http_perl_module.c:<global>,TYPE_DECL,"static char *ngx_http_perl_set(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",13,78,http\modules\perl\ngx_http_perl_module.c,ngx_http_perl_set,,false,57,57,ngx_http_perl_set,,,18,"char* ngx_http_perl_set (ngx_conf_t*,ngx_command_t*,void*)"
250981,METHOD,http\modules\perl\ngx_http_perl_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_perl_init_worker(ngx_cycle_t *cycle);,18,62,http\modules\perl\ngx_http_perl_module.c,ngx_http_perl_init_worker,,false,63,63,ngx_http_perl_init_worker,,,19,ngx_int_t ngx_http_perl_init_worker (ngx_cycle_t*)
250986,METHOD,http\modules\perl\ngx_http_perl_module.c:<global>,TYPE_DECL,static void ngx_http_perl_exit(ngx_cycle_t *cycle);,13,50,http\modules\perl\ngx_http_perl_module.c,ngx_http_perl_exit,,false,64,64,ngx_http_perl_exit,,,20,void ngx_http_perl_exit (ngx_cycle_t*)
251077,METHOD,http\modules\perl\ngx_http_perl_module.c:<global>,TYPE_DECL,"static void
ngx_http_perl_xs_init(pTHX)
{
    newXS(""DynaLoader::boot_DynaLoader"", boot_DynaLoader, __FILE__);

    nginx_stash = gv_stashpv(""nginx"", TRUE);
}",1,58,http\modules\perl\ngx_http_perl_module.c,ngx_http_perl_xs_init,,false,161,167,ngx_http_perl_xs_init,,,31,void ngx_http_perl_xs_init (ANY)
251093,METHOD,http\modules\perl\ngx_http_perl_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_perl_handler(ngx_http_request_t *r)
{
    r->main->count++;

    ngx_http_perl_handle_request(r);

    return NGX_DONE;
}",1,1,http\modules\perl\ngx_http_perl_module.c,ngx_http_perl_handler,,false,170,178,ngx_http_perl_handler,,,32,ngx_int_t ngx_http_perl_handler (ngx_http_request_t*)
251108,METHOD,http\modules\perl\ngx_http_perl_module.c:<global>,TYPE_DECL,"void
ngx_http_perl_handle_request(ngx_http_request_t *r)
{
    SV                         *sub;
    ngx_int_t                   rc;
    ngx_str_t                   uri, args, *handler;
    ngx_uint_t                  flags;
    ngx_http_perl_ctx_t        *ctx;
    ngx_http_perl_loc_conf_t   *plcf;
    ngx_http_perl_main_conf_t  *pmcf;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, ""perl handler"");

    ctx = ngx_http_get_module_ctx(r, ngx_http_perl_module);

    if (ctx == NULL) {
        ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_perl_ctx_t));
        if (ctx == NULL) {
            ngx_http_finalize_request(r, NGX_ERROR);
            return;
        }

        ngx_http_set_ctx(r, ctx, ngx_http_perl_module);

        ctx->request = r;
    }

    pmcf = ngx_http_get_module_main_conf(r, ngx_http_perl_module);

    {

    dTHXa(pmcf->perl);
    PERL_SET_CONTEXT(pmcf->perl);
    PERL_SET_INTERP(pmcf->perl);

    if (ctx->next == NULL) {
        plcf = ngx_http_get_module...",1,1,http\modules\perl\ngx_http_perl_module.c,ngx_http_perl_handle_request,,false,181,285,ngx_http_perl_handle_request,,,33,void ngx_http_perl_handle_request (ngx_http_request_t*)
251370,METHOD,http\modules\perl\ngx_http_perl_module.c:<global>,TYPE_DECL,"void
ngx_http_perl_sleep_handler(ngx_http_request_t *r)
{
    ngx_event_t  *wev;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""perl sleep handler"");

    wev = r->connection->write;

    if (wev->delayed) {

        if (ngx_handle_write_event(wev, 0) != NGX_OK) {
            ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
        }

        return;
    }

    ngx_http_perl_handle_request(r);
}",1,1,http\modules\perl\ngx_http_perl_module.c,ngx_http_perl_sleep_handler,,false,288,308,ngx_http_perl_sleep_handler,,,34,void ngx_http_perl_sleep_handler (ngx_http_request_t*)
251410,METHOD,http\modules\perl\ngx_http_perl_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_perl_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v,
    uintptr_t data)
{
    ngx_http_perl_variable_t *pv = (ngx_http_perl_variable_t *) data;

    ngx_int_t                   rc;
    ngx_str_t                   value;
    ngx_uint_t                  saved;
    ngx_http_perl_ctx_t        *ctx;
    ngx_http_perl_main_conf_t  *pmcf;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""perl variable handler"");

    ctx = ngx_http_get_module_ctx(r, ngx_http_perl_module);

    if (ctx == NULL) {
        ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_perl_ctx_t));
        if (ctx == NULL) {
            return NGX_ERROR;
        }

        ngx_http_set_ctx(r, ctx, ngx_http_perl_module);

        ctx->request = r;
    }

    saved = ctx->variable;
    ctx->variable = 1;

    pmcf = ngx_http_get_module_main_conf(r, ngx_http_perl_module);

    value.data = NULL;

    {

    dTHXa(pmcf->perl);
    PERL_SET_CONTEXT(pmcf->perl);...",1,1,http\modules\perl\ngx_http_perl_module.c,ngx_http_perl_variable,,false,311,376,ngx_http_perl_variable,,,35,"ngx_int_t ngx_http_perl_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
251576,METHOD,http\modules\perl\ngx_http_perl_module.c:<global>,TYPE_DECL,"static char *
ngx_http_perl_init_interpreter(ngx_conf_t *cf, ngx_http_perl_main_conf_t *pmcf)
{
    ngx_str_t           *m;
    ngx_uint_t           i;
#if (NGX_HAVE_PERL_MULTIPLICITY)
    ngx_pool_cleanup_t  *cln;

    cln = ngx_pool_cleanup_add(cf->pool, 0);
    if (cln == NULL) {
        return NGX_CONF_ERROR;
    }

#endif

#ifdef NGX_PERL_MODULES
    if (pmcf->modules == NGX_CONF_UNSET_PTR) {

        pmcf->modules = ngx_array_create(cf->pool, 1, sizeof(ngx_str_t));
        if (pmcf->modules == NULL) {
            return NGX_CONF_ERROR;
        }

        m = ngx_array_push(pmcf->modules);
        if (m == NULL) {
            return NGX_CONF_ERROR;
        }

        ngx_str_set(m, NGX_PERL_MODULES);
    }
#endif

    if (pmcf->modules != NGX_CONF_UNSET_PTR) {
        m = pmcf->modules->elts;
        for (i = 0; i < pmcf->modules->nelts; i++) {
            if (ngx_conf_full_name(cf->cycle, &m[i], 0) != NGX_OK) {
                return NGX_CONF_ERROR;
            }
        }
   ...",1,1,http\modules\perl\ngx_http_perl_module.c,ngx_http_perl_init_interpreter,,false,484,571,ngx_http_perl_init_interpreter,,,36,"char* ngx_http_perl_init_interpreter (ngx_conf_t*,ngx_http_perl_main_conf_t*)"
251697,METHOD,http\modules\perl\ngx_http_perl_module.c:<global>,TYPE_DECL,"static PerlInterpreter *
ngx_http_perl_create_interpreter(ngx_conf_t *cf,
    ngx_http_perl_main_conf_t *pmcf)
{
    int                n;
    STRLEN             len;
    SV                *sv;
    char              *ver, **embedding;
    ngx_str_t         *m;
    ngx_uint_t         i;
    PerlInterpreter   *perl;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, cf->log, 0, ""create perl interpreter"");

    if (ngx_set_environment(cf->cycle, NULL) == NULL) {
        return NULL;
    }

    perl = perl_alloc();
    if (perl == NULL) {
        ngx_log_error(NGX_LOG_ALERT, cf->log, 0, ""perl_alloc() failed"");
        return NULL;
    }

    {

    dTHXa(perl);
    PERL_SET_CONTEXT(perl);
    PERL_SET_INTERP(perl);

    perl_construct(perl);

#ifdef PERL_EXIT_DESTRUCT_END
    PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
#endif

    n = (pmcf->modules != NGX_CONF_UNSET_PTR) ? pmcf->modules->nelts * 2 : 0;

    embedding = ngx_palloc(cf->pool, (5 + n) * sizeof(char *));
    if (embedding == NULL) {
    ...",1,1,http\modules\perl\ngx_http_perl_module.c,ngx_http_perl_create_interpreter,,false,574,664,ngx_http_perl_create_interpreter,,,37,"PerlInterpreter ngx_http_perl_create_interpreter (ngx_conf_t*,ngx_http_perl_main_conf_t*)"
251932,METHOD,http\modules\perl\ngx_http_perl_module.c:<global>,TYPE_DECL,"static void *
ngx_http_perl_create_main_conf(ngx_conf_t *cf)
{
    ngx_http_perl_main_conf_t  *pmcf;

    pmcf = ngx_pcalloc(cf->pool, sizeof(ngx_http_perl_main_conf_t));
    if (pmcf == NULL) {
        return NULL;
    }

    pmcf->modules = NGX_CONF_UNSET_PTR;
    pmcf->requires = NGX_CONF_UNSET_PTR;

    return pmcf;
}",1,1,http\modules\perl\ngx_http_perl_module.c,ngx_http_perl_create_main_conf,,false,845,859,ngx_http_perl_create_main_conf,,,45,void* ngx_http_perl_create_main_conf (ngx_conf_t*)
251965,METHOD,http\modules\perl\ngx_http_perl_module.c:<global>,TYPE_DECL,"static char *
ngx_http_perl_init_main_conf(ngx_conf_t *cf, void *conf)
{
    ngx_http_perl_main_conf_t *pmcf = conf;

    if (pmcf->perl == NULL) {
        if (ngx_http_perl_init_interpreter(cf, pmcf) != NGX_CONF_OK) {
            return NGX_CONF_ERROR;
        }
    }

    return NGX_CONF_OK;
}",1,1,http\modules\perl\ngx_http_perl_module.c,ngx_http_perl_init_main_conf,,false,862,874,ngx_http_perl_init_main_conf,,,46,"char* ngx_http_perl_init_main_conf (ngx_conf_t*,void*)"
251993,METHOD,http\modules\perl\ngx_http_perl_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_perl_preconfiguration(ngx_conf_t *cf)
{
#if (NGX_HTTP_SSI)
    ngx_int_t                  rc;
    ngx_http_ssi_main_conf_t  *smcf;

    smcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_ssi_filter_module);

    rc = ngx_hash_add_key(&smcf->commands, &ngx_http_perl_ssi_command.name,
                          &ngx_http_perl_ssi_command, NGX_HASH_READONLY_KEY);

    if (rc != NGX_OK) {
        if (rc == NGX_BUSY) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               ""conflicting SSI command \""%V\"""",
                               &ngx_http_perl_ssi_command.name);
        }

        return NGX_ERROR;
    }
#endif

    return NGX_OK;
}",1,1,http\modules\perl\ngx_http_perl_module.c,ngx_http_perl_preconfiguration,,false,901,925,ngx_http_perl_preconfiguration,,,47,ngx_int_t ngx_http_perl_preconfiguration (ngx_conf_t*)
252000,METHOD,http\modules\perl\ngx_http_perl_module.c:<global>,TYPE_DECL,"static void *
ngx_http_perl_create_loc_conf(ngx_conf_t *cf)
{
    ngx_http_perl_loc_conf_t *plcf;

    plcf = ngx_pcalloc(cf->pool, sizeof(ngx_http_perl_loc_conf_t));
    if (plcf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     plcf->handler = { 0, NULL };
     */

    return plcf;
}",1,1,http\modules\perl\ngx_http_perl_module.c,ngx_http_perl_create_loc_conf,,false,928,945,ngx_http_perl_create_loc_conf,,,48,void* ngx_http_perl_create_loc_conf (ngx_conf_t*)
252023,METHOD,http\modules\perl\ngx_http_perl_module.c:<global>,TYPE_DECL,"static char *
ngx_http_perl_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_perl_loc_conf_t *prev = parent;
    ngx_http_perl_loc_conf_t *conf = child;

    if (conf->sub == NULL) {
        conf->sub = prev->sub;
        conf->handler = prev->handler;
    }

    return NGX_CONF_OK;
}",1,1,http\modules\perl\ngx_http_perl_module.c,ngx_http_perl_merge_loc_conf,,false,948,960,ngx_http_perl_merge_loc_conf,,,49,"char* ngx_http_perl_merge_loc_conf (ngx_conf_t*,void*,void*)"
252061,METHOD,http\modules\perl\ngx_http_perl_module.c:<global>,TYPE_DECL,"static char *
ngx_http_perl(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_perl_loc_conf_t *plcf = conf;

    ngx_str_t                  *value;
    ngx_http_core_loc_conf_t   *clcf;
    ngx_http_perl_main_conf_t  *pmcf;

    value = cf->args->elts;

    if (plcf->handler.data) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""duplicate perl handler \""%V\"""", &value[1]);
        return NGX_CONF_ERROR;
    }

    pmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_perl_module);

    if (pmcf->perl == NULL) {
        if (ngx_http_perl_init_interpreter(cf, pmcf) != NGX_CONF_OK) {
            return NGX_CONF_ERROR;
        }
    }

    plcf->handler = value[1];

    {

    dTHXa(pmcf->perl);
    PERL_SET_CONTEXT(pmcf->perl);
    PERL_SET_INTERP(pmcf->perl);

    ngx_http_perl_eval_anon_sub(aTHX_ &value[1], &plcf->sub);

    if (plcf->sub == &PL_sv_undef) {
        ngx_conf_log_error(NGX_LOG_ERR, cf, 0,
                           ""eval_pv(\""...",1,1,http\modules\perl\ngx_http_perl_module.c,ngx_http_perl,,false,963,1014,ngx_http_perl,,,50,"char* ngx_http_perl (ngx_conf_t*,ngx_command_t*,void*)"
252206,METHOD,http\modules\perl\ngx_http_perl_module.c:<global>,TYPE_DECL,"static char *
ngx_http_perl_set(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_int_t                   index;
    ngx_str_t                  *value;
    ngx_http_variable_t        *v;
    ngx_http_perl_variable_t   *pv;
    ngx_http_perl_main_conf_t  *pmcf;

    value = cf->args->elts;

    if (value[1].data[0] != '$') {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""invalid variable name \""%V\"""", &value[1]);
        return NGX_CONF_ERROR;
    }

    value[1].len--;
    value[1].data++;

    v = ngx_http_add_variable(cf, &value[1], NGX_HTTP_VAR_CHANGEABLE);
    if (v == NULL) {
        return NGX_CONF_ERROR;
    }

    pv = ngx_palloc(cf->pool, sizeof(ngx_http_perl_variable_t));
    if (pv == NULL) {
        return NGX_CONF_ERROR;
    }

    index = ngx_http_get_variable_index(cf, &value[1]);
    if (index == NGX_ERROR) {
        return NGX_CONF_ERROR;
    }

    pmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_perl_module);

    if (pm...",1,1,http\modules\perl\ngx_http_perl_module.c,ngx_http_perl_set,,false,1017,1086,ngx_http_perl_set,,,51,"char* ngx_http_perl_set (ngx_conf_t*,ngx_command_t*,void*)"
252413,METHOD,http\modules\perl\ngx_http_perl_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_perl_init_worker(ngx_cycle_t *cycle)
{
    ngx_http_perl_main_conf_t  *pmcf;

    pmcf = ngx_http_cycle_get_module_main_conf(cycle, ngx_http_perl_module);

    if (pmcf) {
        dTHXa(pmcf->perl);
        PERL_SET_CONTEXT(pmcf->perl);
        PERL_SET_INTERP(pmcf->perl);

        /* set worker's $$ */

        sv_setiv(GvSV(gv_fetchpv(""$"", TRUE, SVt_PV)), (I32) ngx_pid);
    }

    return NGX_OK;
}",1,1,http\modules\perl\ngx_http_perl_module.c,ngx_http_perl_init_worker,,false,1089,1107,ngx_http_perl_init_worker,,,52,ngx_int_t ngx_http_perl_init_worker (ngx_cycle_t*)
252450,METHOD,http\modules\perl\ngx_http_perl_module.c:<global>,TYPE_DECL,"static void
ngx_http_perl_exit(ngx_cycle_t *cycle)
{
#if (NGX_HAVE_PERL_MULTIPLICITY)

    /*
     * the master exit hook is run before global pool cleanup,
     * therefore just set flag here
     */

    ngx_perl_term = 1;

#else

    if (nginx_stash) {
        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, cycle->log, 0, ""perl term"");

        (void) perl_destruct(perl);

        perl_free(perl);

        PERL_SYS_TERM();
    }

#endif
}",1,1,http\modules\perl\ngx_http_perl_module.c,ngx_http_perl_exit,,false,1110,1135,ngx_http_perl_exit,,,53,void ngx_http_perl_exit (ngx_cycle_t*)
252487,METHOD,http\modules\perl\ngx_http_perl_module.h:<global>,TYPE_DECL,<global>,1,46,http\modules\perl\ngx_http_perl_module.h,http\modules\perl\ngx_http_perl_module.h:<global>,,false,1,73,<global>,,,1,
252510,METHOD,http\modules\perl\ngx_http_perl_module.h:<global>,TYPE_DECL,void ngx_http_perl_handle_request(ngx_http_request_t *r);,6,56,http\modules\perl\ngx_http_perl_module.h,ngx_http_perl_handle_request,,false,69,69,ngx_http_perl_handle_request,,,8,void ngx_http_perl_handle_request (ngx_http_request_t*)
252515,METHOD,http\modules\perl\ngx_http_perl_module.h:<global>,TYPE_DECL,void ngx_http_perl_sleep_handler(ngx_http_request_t *r);,6,55,http\modules\perl\ngx_http_perl_module.h,ngx_http_perl_sleep_handler,,false,70,70,ngx_http_perl_sleep_handler,,,9,void ngx_http_perl_sleep_handler (ngx_http_request_t*)
252529,METHOD,http\ngx_http.c:<global>,TYPE_DECL,<global>,1,1,http\ngx_http.c,http\ngx_http.c:<global>,,false,1,2076,<global>,,,1,
252531,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static char *ngx_http_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",13,75,http\ngx_http.c,ngx_http_block,,false,13,13,ngx_http_block,,,1,"char* ngx_http_block (ngx_conf_t*,ngx_command_t*,void*)"
252538,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_init_phases(ngx_conf_t *cf,
    ngx_http_core_main_conf_t *cmcf);",18,36,http\ngx_http.c,ngx_http_init_phases,,false,14,15,ngx_http_init_phases,,,2,"ngx_int_t ngx_http_init_phases (ngx_conf_t*,ngx_http_core_main_conf_t*)"
252544,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_init_headers_in_hash(ngx_conf_t *cf,
    ngx_http_core_main_conf_t *cmcf);",18,36,http\ngx_http.c,ngx_http_init_headers_in_hash,,false,16,17,ngx_http_init_headers_in_hash,,,3,"ngx_int_t ngx_http_init_headers_in_hash (ngx_conf_t*,ngx_http_core_main_conf_t*)"
252550,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_init_phase_handlers(ngx_conf_t *cf,
    ngx_http_core_main_conf_t *cmcf);",18,36,http\ngx_http.c,ngx_http_init_phase_handlers,,false,18,19,ngx_http_init_phase_handlers,,,4,"ngx_int_t ngx_http_init_phase_handlers (ngx_conf_t*,ngx_http_core_main_conf_t*)"
252556,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_add_addresses(ngx_conf_t *cf,
    ngx_http_core_srv_conf_t *cscf, ngx_http_conf_port_t *port,
    ngx_http_listen_opt_t *lsopt);",18,33,http\ngx_http.c,ngx_http_add_addresses,,false,21,23,ngx_http_add_addresses,,,5,"ngx_int_t ngx_http_add_addresses (ngx_conf_t*,ngx_http_core_srv_conf_t*,ngx_http_conf_port_t*,ngx_http_listen_opt_t*)"
252564,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_add_address(ngx_conf_t *cf,
    ngx_http_core_srv_conf_t *cscf, ngx_http_conf_port_t *port,
    ngx_http_listen_opt_t *lsopt);",18,33,http\ngx_http.c,ngx_http_add_address,,false,24,26,ngx_http_add_address,,,6,"ngx_int_t ngx_http_add_address (ngx_conf_t*,ngx_http_core_srv_conf_t*,ngx_http_conf_port_t*,ngx_http_listen_opt_t*)"
252572,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_add_server(ngx_conf_t *cf,
    ngx_http_core_srv_conf_t *cscf, ngx_http_conf_addr_t *addr);",18,63,http\ngx_http.c,ngx_http_add_server,,false,27,28,ngx_http_add_server,,,7,"ngx_int_t ngx_http_add_server (ngx_conf_t*,ngx_http_core_srv_conf_t*,ngx_http_conf_addr_t*)"
252579,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static char *ngx_http_merge_servers(ngx_conf_t *cf,
    ngx_http_core_main_conf_t *cmcf, ngx_http_module_t *module,
    ngx_uint_t ctx_index);",13,25,http\ngx_http.c,ngx_http_merge_servers,,false,30,32,ngx_http_merge_servers,,,8,"char* ngx_http_merge_servers (ngx_conf_t*,ngx_http_core_main_conf_t*,ngx_http_module_t*,ngx_uint_t)"
252587,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static char *ngx_http_merge_locations(ngx_conf_t *cf,
    ngx_queue_t *locations, void **loc_conf, ngx_http_module_t *module,
    ngx_uint_t ctx_index);",13,25,http\ngx_http.c,ngx_http_merge_locations,,false,33,35,ngx_http_merge_locations,,,9,"char* ngx_http_merge_locations (ngx_conf_t*,ngx_queue_t*,void**,ngx_http_module_t*,ngx_uint_t)"
252596,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_init_locations(ngx_conf_t *cf,
    ngx_http_core_srv_conf_t *cscf, ngx_http_core_loc_conf_t *pclcf);",18,68,http\ngx_http.c,ngx_http_init_locations,,false,36,37,ngx_http_init_locations,,,10,"ngx_int_t ngx_http_init_locations (ngx_conf_t*,ngx_http_core_srv_conf_t*,ngx_http_core_loc_conf_t*)"
252603,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_init_static_location_trees(ngx_conf_t *cf,
    ngx_http_core_loc_conf_t *pclcf);",18,36,http\ngx_http.c,ngx_http_init_static_location_trees,,false,38,39,ngx_http_init_static_location_trees,,,11,"ngx_int_t ngx_http_init_static_location_trees (ngx_conf_t*,ngx_http_core_loc_conf_t*)"
252609,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_cmp_locations(const ngx_queue_t *one,
    const ngx_queue_t *two);",18,27,http\ngx_http.c,ngx_http_cmp_locations,,false,40,41,ngx_http_cmp_locations,,,12,"ngx_int_t ngx_http_cmp_locations (ngx_queue_t*,ngx_queue_t*)"
252615,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_join_exact_locations(ngx_conf_t *cf,
    ngx_queue_t *locations);",18,27,http\ngx_http.c,ngx_http_join_exact_locations,,false,42,43,ngx_http_join_exact_locations,,,13,"ngx_int_t ngx_http_join_exact_locations (ngx_conf_t*,ngx_queue_t*)"
252621,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static void ngx_http_create_locations_list(ngx_queue_t *locations,
    ngx_queue_t *q);",13,19,http\ngx_http.c,ngx_http_create_locations_list,,false,44,45,ngx_http_create_locations_list,,,14,"void ngx_http_create_locations_list (ngx_queue_t*,ngx_queue_t*)"
252627,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static ngx_http_location_tree_node_t *
    ngx_http_create_locations_tree(ngx_conf_t *cf, ngx_queue_t *locations,
    size_t prefix);",38,18,http\ngx_http.c,ngx_http_create_locations_tree,,false,46,48,ngx_http_create_locations_tree,,,15,"ngx_http_location_tree_node_t* ngx_http_create_locations_tree (ngx_conf_t*,ngx_queue_t*,size_t)"
252634,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_optimize_servers(ngx_conf_t *cf,
    ngx_http_core_main_conf_t *cmcf, ngx_array_t *ports);",18,56,http\ngx_http.c,ngx_http_optimize_servers,,false,50,51,ngx_http_optimize_servers,,,16,"ngx_int_t ngx_http_optimize_servers (ngx_conf_t*,ngx_http_core_main_conf_t*,ngx_array_t*)"
252641,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_server_names(ngx_conf_t *cf,
    ngx_http_core_main_conf_t *cmcf, ngx_http_conf_addr_t *addr);",18,64,http\ngx_http.c,ngx_http_server_names,,false,52,53,ngx_http_server_names,,,17,"ngx_int_t ngx_http_server_names (ngx_conf_t*,ngx_http_core_main_conf_t*,ngx_http_conf_addr_t*)"
252648,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_cmp_conf_addrs(const void *one, const void *two);",18,74,http\ngx_http.c,ngx_http_cmp_conf_addrs,,false,54,54,ngx_http_cmp_conf_addrs,,,18,"ngx_int_t ngx_http_cmp_conf_addrs (void*,void*)"
252655,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_init_listening(ngx_conf_t *cf,
    ngx_http_conf_port_t *port);",18,31,http\ngx_http.c,ngx_http_init_listening,,false,58,59,ngx_http_init_listening,,,20,"ngx_int_t ngx_http_init_listening (ngx_conf_t*,ngx_http_conf_port_t*)"
252661,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static ngx_listening_t *ngx_http_add_listening(ngx_conf_t *cf,
    ngx_http_conf_addr_t *addr);",24,31,http\ngx_http.c,ngx_http_add_listening,,false,60,61,ngx_http_add_listening,,,21,"ngx_listening_t* ngx_http_add_listening (ngx_conf_t*,ngx_http_conf_addr_t*)"
252667,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_add_addrs(ngx_conf_t *cf, ngx_http_port_t *hport,
    ngx_http_conf_addr_t *addr);",18,31,http\ngx_http.c,ngx_http_add_addrs,,false,62,63,ngx_http_add_addrs,,,22,"ngx_int_t ngx_http_add_addrs (ngx_conf_t*,ngx_http_port_t*,ngx_http_conf_addr_t*)"
252727,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static char *
ngx_http_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char                        *rv;
    ngx_uint_t                   mi, m, s;
    ngx_conf_t                   pcf;
    ngx_http_module_t           *module;
    ngx_http_conf_ctx_t         *ctx;
    ngx_http_core_loc_conf_t    *clcf;
    ngx_http_core_srv_conf_t   **cscfp;
    ngx_http_core_main_conf_t   *cmcf;

    if (*(ngx_http_conf_ctx_t **) conf) {
        return ""is duplicate"";
    }

    /* the main http context */

    ctx = ngx_pcalloc(cf->pool, sizeof(ngx_http_conf_ctx_t));
    if (ctx == NULL) {
        return NGX_CONF_ERROR;
    }

    *(ngx_http_conf_ctx_t **) conf = ctx;


    /* count the number of the http modules and set up their indices */

    ngx_http_max_module = ngx_count_modules(cf->cycle, NGX_HTTP_MODULE);


    /* the http main_conf context, it is the same in the all http contexts */

    ctx->main_conf = ngx_pcalloc(cf->pool,
                                 sizeof(void *) * ng...",1,1,http\ngx_http.c,ngx_http_block,,false,119,344,ngx_http_block,,,35,"char* ngx_http_block (ngx_conf_t*,ngx_command_t*,void*)"
253329,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_init_phases(ngx_conf_t *cf, ngx_http_core_main_conf_t *cmcf)
{
    if (ngx_array_init(&cmcf->phases[NGX_HTTP_POST_READ_PHASE].handlers,
                       cf->pool, 1, sizeof(ngx_http_handler_pt))
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    if (ngx_array_init(&cmcf->phases[NGX_HTTP_SERVER_REWRITE_PHASE].handlers,
                       cf->pool, 1, sizeof(ngx_http_handler_pt))
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    if (ngx_array_init(&cmcf->phases[NGX_HTTP_REWRITE_PHASE].handlers,
                       cf->pool, 1, sizeof(ngx_http_handler_pt))
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    if (ngx_array_init(&cmcf->phases[NGX_HTTP_PREACCESS_PHASE].handlers,
                       cf->pool, 1, sizeof(ngx_http_handler_pt))
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    if (ngx_array_init(&cmcf->phases[NGX_HTTP_ACCESS_PHASE].handlers,
                       cf->pool, 2, sizeof(ngx_http...",1,1,http\ngx_http.c,ngx_http_init_phases,,false,347,407,ngx_http_init_phases,,,36,"ngx_int_t ngx_http_init_phases (ngx_conf_t*,ngx_http_core_main_conf_t*)"
253505,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_init_headers_in_hash(ngx_conf_t *cf, ngx_http_core_main_conf_t *cmcf)
{
    ngx_array_t         headers_in;
    ngx_hash_key_t     *hk;
    ngx_hash_init_t     hash;
    ngx_http_header_t  *header;

    if (ngx_array_init(&headers_in, cf->temp_pool, 32, sizeof(ngx_hash_key_t))
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    for (header = ngx_http_headers_in; header->name.len; header++) {
        hk = ngx_array_push(&headers_in);
        if (hk == NULL) {
            return NGX_ERROR;
        }

        hk->key = header->name;
        hk->key_hash = ngx_hash_key_lc(header->name.data, header->name.len);
        hk->value = header;
    }

    hash.hash = &cmcf->headers_in_hash;
    hash.key = ngx_hash_key_lc;
    hash.max_size = 512;
    hash.bucket_size = ngx_align(64, ngx_cacheline_size);
    hash.name = ""headers_in_hash"";
    hash.pool = cf->pool;
    hash.temp_pool = NULL;

    if (ngx_hash_init(&hash, headers_in.elts, headers_in.nelts) != NG...",1,1,http\ngx_http.c,ngx_http_init_headers_in_hash,,false,410,448,ngx_http_init_headers_in_hash,,,37,"ngx_int_t ngx_http_init_headers_in_hash (ngx_conf_t*,ngx_http_core_main_conf_t*)"
253641,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_init_phase_handlers(ngx_conf_t *cf, ngx_http_core_main_conf_t *cmcf)
{
    ngx_int_t                   j;
    ngx_uint_t                  i, n;
    ngx_uint_t                  find_config_index, use_rewrite, use_access;
    ngx_http_handler_pt        *h;
    ngx_http_phase_handler_t   *ph;
    ngx_http_phase_handler_pt   checker;

    cmcf->phase_engine.server_rewrite_index = (ngx_uint_t) -1;
    cmcf->phase_engine.location_rewrite_index = (ngx_uint_t) -1;
    find_config_index = 0;
    use_rewrite = cmcf->phases[NGX_HTTP_REWRITE_PHASE].handlers.nelts ? 1 : 0;
    use_access = cmcf->phases[NGX_HTTP_ACCESS_PHASE].handlers.nelts ? 1 : 0;

    n = 1                  /* find config phase */
        + use_rewrite      /* post rewrite phase */
        + use_access;      /* post access phase */

    for (i = 0; i < NGX_HTTP_LOG_PHASE; i++) {
        n += cmcf->phases[i].handlers.nelts;
    }

    ph = ngx_pcalloc(cf->pool,
                     n * sizeof(ngx_http_...",1,1,http\ngx_http.c,ngx_http_init_phase_handlers,,false,451,557,ngx_http_init_phase_handlers,,,38,"ngx_int_t ngx_http_init_phase_handlers (ngx_conf_t*,ngx_http_core_main_conf_t*)"
253961,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static char *
ngx_http_merge_servers(ngx_conf_t *cf, ngx_http_core_main_conf_t *cmcf,
    ngx_http_module_t *module, ngx_uint_t ctx_index)
{
    char                        *rv;
    ngx_uint_t                   s;
    ngx_http_conf_ctx_t         *ctx, saved;
    ngx_http_core_loc_conf_t    *clcf;
    ngx_http_core_srv_conf_t   **cscfp;

    cscfp = cmcf->servers.elts;
    ctx = (ngx_http_conf_ctx_t *) cf->ctx;
    saved = *ctx;
    rv = NGX_CONF_OK;

    for (s = 0; s < cmcf->servers.nelts; s++) {

        /* merge the server{}s' srv_conf's */

        ctx->srv_conf = cscfp[s]->ctx->srv_conf;

        if (module->merge_srv_conf) {
            rv = module->merge_srv_conf(cf, saved.srv_conf[ctx_index],
                                        cscfp[s]->ctx->srv_conf[ctx_index]);
            if (rv != NGX_CONF_OK) {
                goto failed;
            }
        }

        if (module->merge_loc_conf) {

            /* merge the server{}'s loc_conf */

            ctx->loc_conf = csc...",1,1,http\ngx_http.c,ngx_http_merge_servers,,false,560,619,ngx_http_merge_servers,,,39,"char* ngx_http_merge_servers (ngx_conf_t*,ngx_http_core_main_conf_t*,ngx_http_module_t*,ngx_uint_t)"
254139,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static char *
ngx_http_merge_locations(ngx_conf_t *cf, ngx_queue_t *locations,
    void **loc_conf, ngx_http_module_t *module, ngx_uint_t ctx_index)
{
    char                       *rv;
    ngx_queue_t                *q;
    ngx_http_conf_ctx_t        *ctx, saved;
    ngx_http_core_loc_conf_t   *clcf;
    ngx_http_location_queue_t  *lq;

    if (locations == NULL) {
        return NGX_CONF_OK;
    }

    ctx = (ngx_http_conf_ctx_t *) cf->ctx;
    saved = *ctx;

    for (q = ngx_queue_head(locations);
         q != ngx_queue_sentinel(locations);
         q = ngx_queue_next(q))
    {
        lq = (ngx_http_location_queue_t *) q;

        clcf = lq->exact ? lq->exact : lq->inclusive;
        ctx->loc_conf = clcf->loc_conf;

        rv = module->merge_loc_conf(cf, loc_conf[ctx_index],
                                    clcf->loc_conf[ctx_index]);
        if (rv != NGX_CONF_OK) {
            return rv;
        }

        rv = ngx_http_merge_locations(cf, clcf->locations, clcf->loc_conf...",1,1,http\ngx_http.c,ngx_http_merge_locations,,false,622,664,ngx_http_merge_locations,,,40,"char* ngx_http_merge_locations (ngx_conf_t*,ngx_queue_t*,void**,ngx_http_module_t*,ngx_uint_t)"
254258,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_init_locations(ngx_conf_t *cf, ngx_http_core_srv_conf_t *cscf,
    ngx_http_core_loc_conf_t *pclcf)
{
    ngx_uint_t                   n;
    ngx_queue_t                 *q, *locations, *named, tail;
    ngx_http_core_loc_conf_t    *clcf;
    ngx_http_location_queue_t   *lq;
    ngx_http_core_loc_conf_t   **clcfp;
#if (NGX_PCRE)
    ngx_uint_t                   r;
    ngx_queue_t                 *regex;
#endif

    locations = pclcf->locations;

    if (locations == NULL) {
        return NGX_OK;
    }

    ngx_queue_sort(locations, ngx_http_cmp_locations);

    named = NULL;
    n = 0;
#if (NGX_PCRE)
    regex = NULL;
    r = 0;
#endif

    for (q = ngx_queue_head(locations);
         q != ngx_queue_sentinel(locations);
         q = ngx_queue_next(q))
    {
        lq = (ngx_http_location_queue_t *) q;

        clcf = lq->exact ? lq->exact : lq->inclusive;

        if (ngx_http_init_locations(cf, NULL, clcf) != NGX_OK) {
            return NGX_ERROR;
     ...",1,1,http\ngx_http.c,ngx_http_init_locations,,false,667,793,ngx_http_init_locations,,,41,"ngx_int_t ngx_http_init_locations (ngx_conf_t*,ngx_http_core_srv_conf_t*,ngx_http_core_loc_conf_t*)"
254433,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_init_static_location_trees(ngx_conf_t *cf,
    ngx_http_core_loc_conf_t *pclcf)
{
    ngx_queue_t                *q, *locations;
    ngx_http_core_loc_conf_t   *clcf;
    ngx_http_location_queue_t  *lq;

    locations = pclcf->locations;

    if (locations == NULL) {
        return NGX_OK;
    }

    if (ngx_queue_empty(locations)) {
        return NGX_OK;
    }

    for (q = ngx_queue_head(locations);
         q != ngx_queue_sentinel(locations);
         q = ngx_queue_next(q))
    {
        lq = (ngx_http_location_queue_t *) q;

        clcf = lq->exact ? lq->exact : lq->inclusive;

        if (ngx_http_init_static_location_trees(cf, clcf) != NGX_OK) {
            return NGX_ERROR;
        }
    }

    if (ngx_http_join_exact_locations(cf, locations) != NGX_OK) {
        return NGX_ERROR;
    }

    ngx_http_create_locations_list(locations, ngx_queue_head(locations));

    pclcf->static_locations = ngx_http_create_locations_tree(cf, locations, 0);
    if (...",1,1,http\ngx_http.c,ngx_http_init_static_location_trees,,false,796,839,ngx_http_init_static_location_trees,,,42,"ngx_int_t ngx_http_init_static_location_trees (ngx_conf_t*,ngx_http_core_loc_conf_t*)"
254534,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_add_location(ngx_conf_t *cf, ngx_queue_t **locations,
    ngx_http_core_loc_conf_t *clcf)
{
    ngx_http_location_queue_t  *lq;

    if (*locations == NULL) {
        *locations = ngx_palloc(cf->temp_pool,
                                sizeof(ngx_http_location_queue_t));
        if (*locations == NULL) {
            return NGX_ERROR;
        }

        ngx_queue_init(*locations);
    }

    lq = ngx_palloc(cf->temp_pool, sizeof(ngx_http_location_queue_t));
    if (lq == NULL) {
        return NGX_ERROR;
    }

    if (clcf->exact_match
#if (NGX_PCRE)
        || clcf->regex
#endif
        || clcf->named || clcf->noname)
    {
        lq->exact = clcf;
        lq->inclusive = NULL;

    } else {
        lq->exact = NULL;
        lq->inclusive = clcf;
    }

    lq->name = &clcf->name;
    lq->file_name = cf->conf_file->file.name.data;
    lq->line = cf->conf_file->line;

    ngx_queue_init(&lq->list);

    ngx_queue_insert_tail(*locations, &lq->queue);

    return...",1,1,http\ngx_http.c,ngx_http_add_location,,false,842,886,ngx_http_add_location,,,43,"ngx_int_t ngx_http_add_location (ngx_conf_t*,ngx_queue_t**,ngx_http_core_loc_conf_t*)"
254662,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_cmp_locations(const ngx_queue_t *one, const ngx_queue_t *two)
{
    ngx_int_t                   rc;
    ngx_http_core_loc_conf_t   *first, *second;
    ngx_http_location_queue_t  *lq1, *lq2;

    lq1 = (ngx_http_location_queue_t *) one;
    lq2 = (ngx_http_location_queue_t *) two;

    first = lq1->exact ? lq1->exact : lq1->inclusive;
    second = lq2->exact ? lq2->exact : lq2->inclusive;

    if (first->noname && !second->noname) {
        /* shift no named locations to the end */
        return 1;
    }

    if (!first->noname && second->noname) {
        /* shift no named locations to the end */
        return -1;
    }

    if (first->noname || second->noname) {
        /* do not sort no named locations */
        return 0;
    }

    if (first->named && !second->named) {
        /* shift named locations to the end */
        return 1;
    }

    if (!first->named && second->named) {
        /* shift named locations to the end */
        return -1;
    ...",1,1,http\ngx_http.c,ngx_http_cmp_locations,,false,889,959,ngx_http_cmp_locations,,,44,"ngx_int_t ngx_http_cmp_locations (ngx_queue_t*,ngx_queue_t*)"
254833,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_join_exact_locations(ngx_conf_t *cf, ngx_queue_t *locations)
{
    ngx_queue_t                *q, *x;
    ngx_http_location_queue_t  *lq, *lx;

    q = ngx_queue_head(locations);

    while (q != ngx_queue_last(locations)) {

        x = ngx_queue_next(q);

        lq = (ngx_http_location_queue_t *) q;
        lx = (ngx_http_location_queue_t *) x;

        if (lq->name->len == lx->name->len
            && ngx_filename_cmp(lq->name->data, lx->name->data, lx->name->len)
               == 0)
        {
            if ((lq->exact && lx->exact) || (lq->inclusive && lx->inclusive)) {
                ngx_log_error(NGX_LOG_EMERG, cf->log, 0,
                              ""duplicate location \""%V\"" in %s:%ui"",
                              lx->name, lx->file_name, lx->line);

                return NGX_ERROR;
            }

            lq->inclusive = lx->inclusive;

            ngx_queue_remove(x);

            continue;
        }

        q = ngx_queue_next(q);
   ...",1,1,http\ngx_http.c,ngx_http_join_exact_locations,,false,962,1000,ngx_http_join_exact_locations,,,45,"ngx_int_t ngx_http_join_exact_locations (ngx_conf_t*,ngx_queue_t*)"
254950,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static void
ngx_http_create_locations_list(ngx_queue_t *locations, ngx_queue_t *q)
{
    u_char                     *name;
    size_t                      len;
    ngx_queue_t                *x, tail;
    ngx_http_location_queue_t  *lq, *lx;

    if (q == ngx_queue_last(locations)) {
        return;
    }

    lq = (ngx_http_location_queue_t *) q;

    if (lq->inclusive == NULL) {
        ngx_http_create_locations_list(locations, ngx_queue_next(q));
        return;
    }

    len = lq->name->len;
    name = lq->name->data;

    for (x = ngx_queue_next(q);
         x != ngx_queue_sentinel(locations);
         x = ngx_queue_next(x))
    {
        lx = (ngx_http_location_queue_t *) x;

        if (len > lx->name->len
            || ngx_filename_cmp(name, lx->name->data, len) != 0)
        {
            break;
        }
    }

    q = ngx_queue_next(q);

    if (q == x) {
        ngx_http_create_locations_list(locations, x);
        return;
    }

    ngx_queue_split(locations, q, &tail...",1,1,http\ngx_http.c,ngx_http_create_locations_list,,false,1003,1059,ngx_http_create_locations_list,,,46,"void ngx_http_create_locations_list (ngx_queue_t*,ngx_queue_t*)"
255108,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static ngx_http_location_tree_node_t *
ngx_http_create_locations_tree(ngx_conf_t *cf, ngx_queue_t *locations,
    size_t prefix)
{
    size_t                          len;
    ngx_queue_t                    *q, tail;
    ngx_http_location_queue_t      *lq;
    ngx_http_location_tree_node_t  *node;

    q = ngx_queue_middle(locations);

    lq = (ngx_http_location_queue_t *) q;
    len = lq->name->len - prefix;

    node = ngx_palloc(cf->pool,
                      offsetof(ngx_http_location_tree_node_t, name) + len);
    if (node == NULL) {
        return NULL;
    }

    node->left = NULL;
    node->right = NULL;
    node->tree = NULL;
    node->exact = lq->exact;
    node->inclusive = lq->inclusive;

    node->auto_redirect = (u_char) ((lq->exact && lq->exact->auto_redirect)
                           || (lq->inclusive && lq->inclusive->auto_redirect));

    node->len = (u_char) len;
    ngx_memcpy(node->name, &lq->name->data[prefix], len);

    ngx_queue_split(locations, q, &tail...",1,1,http\ngx_http.c,ngx_http_create_locations_tree,,false,1067,1137,ngx_http_create_locations_tree,,,47,"ngx_http_location_tree_node_t ngx_http_create_locations_tree (ngx_conf_t*,ngx_queue_t*,size_t)"
255316,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_add_listen(ngx_conf_t *cf, ngx_http_core_srv_conf_t *cscf,
    ngx_http_listen_opt_t *lsopt)
{
    in_port_t                   p;
    ngx_uint_t                  i;
    struct sockaddr            *sa;
    ngx_http_conf_port_t       *port;
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);

    if (cmcf->ports == NULL) {
        cmcf->ports = ngx_array_create(cf->temp_pool, 2,
                                       sizeof(ngx_http_conf_port_t));
        if (cmcf->ports == NULL) {
            return NGX_ERROR;
        }
    }

    sa = lsopt->sockaddr;
    p = ngx_inet_get_port(sa);

    port = cmcf->ports->elts;
    for (i = 0; i < cmcf->ports->nelts; i++) {

        if (p != port[i].port || sa->sa_family != port[i].family) {
            continue;
        }

        /* a port is already in the port list */

        return ngx_http_add_addresses(cf, cscf, &port[i], lsopt);
    }

    /* add a port to the p...",1,1,http\ngx_http.c,ngx_http_add_listen,,false,1140,1187,ngx_http_add_listen,,,48,"ngx_int_t ngx_http_add_listen (ngx_conf_t*,ngx_http_core_srv_conf_t*,ngx_http_listen_opt_t*)"
255458,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_add_addresses(ngx_conf_t *cf, ngx_http_core_srv_conf_t *cscf,
    ngx_http_conf_port_t *port, ngx_http_listen_opt_t *lsopt)
{
    ngx_uint_t             i, default_server, proxy_protocol;
    ngx_http_conf_addr_t  *addr;
#if (NGX_HTTP_SSL)
    ngx_uint_t             ssl;
#endif
#if (NGX_HTTP_V2)
    ngx_uint_t             http2;
#endif

    /*
     * we cannot compare whole sockaddr struct's as kernel
     * may fill some fields in inherited sockaddr struct's
     */

    addr = port->addrs.elts;

    for (i = 0; i < port->addrs.nelts; i++) {

        if (ngx_cmp_sockaddr(lsopt->sockaddr, lsopt->socklen,
                             addr[i].opt.sockaddr,
                             addr[i].opt.socklen, 0)
            != NGX_OK)
        {
            continue;
        }

        /* the address is already in the address list */

        if (ngx_http_add_server(cf, cscf, &addr[i]) != NGX_OK) {
            return NGX_ERROR;
        }

        /* preserve defau...",1,1,http\ngx_http.c,ngx_http_add_addresses,,false,1190,1280,ngx_http_add_addresses,,,49,"ngx_int_t ngx_http_add_addresses (ngx_conf_t*,ngx_http_core_srv_conf_t*,ngx_http_conf_port_t*,ngx_http_listen_opt_t*)"
255650,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_add_address(ngx_conf_t *cf, ngx_http_core_srv_conf_t *cscf,
    ngx_http_conf_port_t *port, ngx_http_listen_opt_t *lsopt)
{
    ngx_http_conf_addr_t  *addr;

    if (port->addrs.elts == NULL) {
        if (ngx_array_init(&port->addrs, cf->temp_pool, 4,
                           sizeof(ngx_http_conf_addr_t))
            != NGX_OK)
        {
            return NGX_ERROR;
        }
    }

#if (NGX_HTTP_V2 && NGX_HTTP_SSL                                              \
     && !defined TLSEXT_TYPE_application_layer_protocol_negotiation           \
     && !defined TLSEXT_TYPE_next_proto_neg)

    if (lsopt->http2 && lsopt->ssl) {
        ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
                           ""nginx was built with OpenSSL that lacks ALPN ""
                           ""and NPN support, HTTP/2 is not enabled for %V"",
                           &lsopt->addr_text);
    }

#endif

    addr = ngx_array_push(&port->addrs);
    if (addr == NULL) {
        ret...",1,1,http\ngx_http.c,ngx_http_add_address,,false,1288,1334,ngx_http_add_address,,,50,"ngx_int_t ngx_http_add_address (ngx_conf_t*,ngx_http_core_srv_conf_t*,ngx_http_conf_port_t*,ngx_http_listen_opt_t*)"
255746,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_add_server(ngx_conf_t *cf, ngx_http_core_srv_conf_t *cscf,
    ngx_http_conf_addr_t *addr)
{
    ngx_uint_t                  i;
    ngx_http_core_srv_conf_t  **server;

    if (addr->servers.elts == NULL) {
        if (ngx_array_init(&addr->servers, cf->temp_pool, 4,
                           sizeof(ngx_http_core_srv_conf_t *))
            != NGX_OK)
        {
            return NGX_ERROR;
        }

    } else {
        server = addr->servers.elts;
        for (i = 0; i < addr->servers.nelts; i++) {
            if (server[i] == cscf) {
                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                                   ""a duplicate listen %V"",
                                   &addr->opt.addr_text);
                return NGX_ERROR;
            }
        }
    }

    server = ngx_array_push(&addr->servers);
    if (server == NULL) {
        return NGX_ERROR;
    }

    *server = cscf;

    return NGX_OK;
}",1,1,http\ngx_http.c,ngx_http_add_server,,false,1339,1374,ngx_http_add_server,,,51,"ngx_int_t ngx_http_add_server (ngx_conf_t*,ngx_http_core_srv_conf_t*,ngx_http_conf_addr_t*)"
255845,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_optimize_servers(ngx_conf_t *cf, ngx_http_core_main_conf_t *cmcf,
    ngx_array_t *ports)
{
    ngx_uint_t             p, a;
    ngx_http_conf_port_t  *port;
    ngx_http_conf_addr_t  *addr;

    if (ports == NULL) {
        return NGX_OK;
    }

    port = ports->elts;
    for (p = 0; p < ports->nelts; p++) {

        ngx_sort(port[p].addrs.elts, (size_t) port[p].addrs.nelts,
                 sizeof(ngx_http_conf_addr_t), ngx_http_cmp_conf_addrs);

        /*
         * check whether all name-based servers have the same
         * configuration as a default server for given address:port
         */

        addr = port[p].addrs.elts;
        for (a = 0; a < port[p].addrs.nelts; a++) {

            if (addr[a].servers.nelts > 1
#if (NGX_PCRE)
                || addr[a].default_server->captures
#endif
               )
            {
                if (ngx_http_server_names(cf, cmcf, &addr[a]) != NGX_OK) {
                    return NGX_ERROR;
               ...",1,1,http\ngx_http.c,ngx_http_optimize_servers,,false,1377,1421,ngx_http_optimize_servers,,,52,"ngx_int_t ngx_http_optimize_servers (ngx_conf_t*,ngx_http_core_main_conf_t*,ngx_array_t*)"
255965,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_server_names(ngx_conf_t *cf, ngx_http_core_main_conf_t *cmcf,
    ngx_http_conf_addr_t *addr)
{
    ngx_int_t                   rc;
    ngx_uint_t                  n, s;
    ngx_hash_init_t             hash;
    ngx_hash_keys_arrays_t      ha;
    ngx_http_server_name_t     *name;
    ngx_http_core_srv_conf_t  **cscfp;
#if (NGX_PCRE)
    ngx_uint_t                  regex, i;

    regex = 0;
#endif

    ngx_memzero(&ha, sizeof(ngx_hash_keys_arrays_t));

    ha.temp_pool = ngx_create_pool(NGX_DEFAULT_POOL_SIZE, cf->log);
    if (ha.temp_pool == NULL) {
        return NGX_ERROR;
    }

    ha.pool = cf->pool;

    if (ngx_hash_keys_array_init(&ha, NGX_HASH_LARGE) != NGX_OK) {
        goto failed;
    }

    cscfp = addr->servers.elts;

    for (s = 0; s < addr->servers.nelts; s++) {

        name = cscfp[s]->server_names.elts;

        for (n = 0; n < cscfp[s]->server_names.nelts; n++) {

#if (NGX_PCRE)
            if (name[n].regex) {
                regex++;...",1,1,http\ngx_http.c,ngx_http_server_names,,false,1424,1577,ngx_http_server_names,,,53,"ngx_int_t ngx_http_server_names (ngx_conf_t*,ngx_http_core_main_conf_t*,ngx_http_conf_addr_t*)"
256346,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_cmp_conf_addrs(const void *one, const void *two)
{
    ngx_http_conf_addr_t  *first, *second;

    first = (ngx_http_conf_addr_t *) one;
    second = (ngx_http_conf_addr_t *) two;

    if (first->opt.wildcard) {
        /* a wildcard address must be the last resort, shift it to the end */
        return 1;
    }

    if (second->opt.wildcard) {
        /* a wildcard address must be the last resort, shift it to the end */
        return -1;
    }

    if (first->opt.bind && !second->opt.bind) {
        /* shift explicit bind()ed addresses to the start */
        return -1;
    }

    if (!first->opt.bind && second->opt.bind) {
        /* shift explicit bind()ed addresses to the start */
        return 1;
    }

    /* do not sort by default */

    return 0;
}",1,1,http\ngx_http.c,ngx_http_cmp_conf_addrs,,false,1580,1611,ngx_http_cmp_conf_addrs,,,54,"ngx_int_t ngx_http_cmp_conf_addrs (void*,void*)"
256420,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"ngx_http_cmp_dns_wildcards(const void *one, const void *two)
{
    ngx_hash_key_t  *first, *second;

    first = (ngx_hash_key_t *) one;
    second = (ngx_hash_key_t *) two;

    return ngx_dns_strcmp(first->key.data, second->key.data);
}",1,1,http\ngx_http.c,ngx_http_cmp_dns_wildcards,,false,1615,1623,ngx_http_cmp_dns_wildcards,,,57,"ANY ngx_http_cmp_dns_wildcards (void*,void*)"
256450,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_init_listening(ngx_conf_t *cf, ngx_http_conf_port_t *port)
{
    ngx_uint_t                 i, last, bind_wildcard;
    ngx_listening_t           *ls;
    ngx_http_port_t           *hport;
    ngx_http_conf_addr_t      *addr;

    addr = port->addrs.elts;
    last = port->addrs.nelts;

    /*
     * If there is a binding to an ""*:port"" then we need to bind() to
     * the ""*:port"" only and ignore other implicit bindings.  The bindings
     * have been already sorted: explicit bindings are on the start, then
     * implicit bindings go, and wildcard binding is in the end.
     */

    if (addr[last - 1].opt.wildcard) {
        addr[last - 1].opt.bind = 1;
        bind_wildcard = 1;

    } else {
        bind_wildcard = 0;
    }

    i = 0;

    while (i < last) {

        if (bind_wildcard && !addr[i].opt.bind) {
            i++;
            continue;
        }

        ls = ngx_http_add_listening(cf, &addr[i]);
        if (ls == NULL) {
            return N...",1,1,http\ngx_http.c,ngx_http_init_listening,,false,1626,1696,ngx_http_init_listening,,,58,"ngx_int_t ngx_http_init_listening (ngx_conf_t*,ngx_http_conf_port_t*)"
256596,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static ngx_listening_t *
ngx_http_add_listening(ngx_conf_t *cf, ngx_http_conf_addr_t *addr)
{
    ngx_listening_t           *ls;
    ngx_http_core_loc_conf_t  *clcf;
    ngx_http_core_srv_conf_t  *cscf;

    ls = ngx_create_listening(cf, addr->opt.sockaddr, addr->opt.socklen);
    if (ls == NULL) {
        return NULL;
    }

    ls->addr_ntop = 1;

    ls->handler = ngx_http_init_connection;

    cscf = addr->default_server;
    ls->pool_size = cscf->connection_pool_size;
    ls->post_accept_timeout = cscf->client_header_timeout;

    clcf = cscf->ctx->loc_conf[ngx_http_core_module.ctx_index];

    ls->logp = clcf->error_log;
    ls->log.data = &ls->addr_text;
    ls->log.handler = ngx_accept_log_error;

#if (NGX_WIN32)
    {
    ngx_iocp_conf_t  *iocpcf = NULL;

    if (ngx_get_conf(cf->cycle->conf_ctx, ngx_events_module)) {
        iocpcf = ngx_event_get_conf(cf->cycle->conf_ctx, ngx_iocp_module);
    }
    if (iocpcf && iocpcf->acceptex_read) {
        ls->post_accept_buffer_siz...",1,1,http\ngx_http.c,ngx_http_add_listening,,false,1699,1774,ngx_http_add_listening,,,59,"ngx_listening_t ngx_http_add_listening (ngx_conf_t*,ngx_http_conf_addr_t*)"
256728,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_add_addrs(ngx_conf_t *cf, ngx_http_port_t *hport,
    ngx_http_conf_addr_t *addr)
{
    ngx_uint_t                 i;
    ngx_http_in_addr_t        *addrs;
    struct sockaddr_in        *sin;
    ngx_http_virtual_names_t  *vn;

    hport->addrs = ngx_pcalloc(cf->pool,
                               hport->naddrs * sizeof(ngx_http_in_addr_t));
    if (hport->addrs == NULL) {
        return NGX_ERROR;
    }

    addrs = hport->addrs;

    for (i = 0; i < hport->naddrs; i++) {

        sin = (struct sockaddr_in *) addr[i].opt.sockaddr;
        addrs[i].addr = sin->sin_addr.s_addr;
        addrs[i].conf.default_server = addr[i].default_server;
#if (NGX_HTTP_SSL)
        addrs[i].conf.ssl = addr[i].opt.ssl;
#endif
#if (NGX_HTTP_V2)
        addrs[i].conf.http2 = addr[i].opt.http2;
#endif
        addrs[i].conf.proxy_protocol = addr[i].opt.proxy_protocol;

        if (addr[i].hash.buckets == NULL
            && (addr[i].wc_head == NULL
                || addr[i].wc...",1,1,http\ngx_http.c,ngx_http_add_addrs,,false,1777,1837,ngx_http_add_addrs,,,60,"ngx_int_t ngx_http_add_addrs (ngx_conf_t*,ngx_http_port_t*,ngx_http_conf_addr_t*)"
256941,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"char *
ngx_http_types_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char  *p = conf;

    ngx_array_t     **types;
    ngx_str_t        *value, *default_type;
    ngx_uint_t        i, n, hash;
    ngx_hash_key_t   *type;

    types = (ngx_array_t **) (p + cmd->offset);

    if (*types == (void *) -1) {
        return NGX_CONF_OK;
    }

    default_type = cmd->post;

    if (*types == NULL) {
        *types = ngx_array_create(cf->temp_pool, 1, sizeof(ngx_hash_key_t));
        if (*types == NULL) {
            return NGX_CONF_ERROR;
        }

        if (default_type) {
            type = ngx_array_push(*types);
            if (type == NULL) {
                return NGX_CONF_ERROR;
            }

            type->key = *default_type;
            type->key_hash = ngx_hash_key(default_type->data,
                                          default_type->len);
            type->value = (void *) 4;
        }
    }

    value = cf->args->elts;

    for (i = 1; i < cf->args->n...",1,1,http\ngx_http.c,ngx_http_types_slot,,false,1907,1981,ngx_http_types_slot,,,61,"char* ngx_http_types_slot (ngx_conf_t*,ngx_command_t*,void*)"
257210,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"char *
ngx_http_merge_types(ngx_conf_t *cf, ngx_array_t **keys, ngx_hash_t *types_hash,
    ngx_array_t **prev_keys, ngx_hash_t *prev_types_hash,
    ngx_str_t *default_types)
{
    ngx_hash_init_t  hash;

    if (*keys) {

        if (*keys == (void *) -1) {
            return NGX_CONF_OK;
        }

        hash.hash = types_hash;
        hash.key = NULL;
        hash.max_size = 2048;
        hash.bucket_size = 64;
        hash.name = ""test_types_hash"";
        hash.pool = cf->pool;
        hash.temp_pool = NULL;

        if (ngx_hash_init(&hash, (*keys)->elts, (*keys)->nelts) != NGX_OK) {
            return NGX_CONF_ERROR;
        }

        return NGX_CONF_OK;
    }

    if (prev_types_hash->buckets == NULL) {

        if (*prev_keys == NULL) {

            if (ngx_http_set_default_types(cf, prev_keys, default_types)
                != NGX_OK)
            {
                return NGX_CONF_ERROR;
            }

        } else if (*prev_keys == (void *) -1) {
            *keys = *...",1,1,http\ngx_http.c,ngx_http_merge_types,,false,1984,2046,ngx_http_merge_types,,,62,"char* ngx_http_merge_types (ngx_conf_t*,ngx_array_t**,ngx_hash_t*,ngx_array_t**,ngx_hash_t*,ngx_str_t*)"
257394,METHOD,http\ngx_http.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_set_default_types(ngx_conf_t *cf, ngx_array_t **types,
    ngx_str_t *default_type)
{
    ngx_hash_key_t  *type;

    *types = ngx_array_create(cf->temp_pool, 1, sizeof(ngx_hash_key_t));
    if (*types == NULL) {
        return NGX_ERROR;
    }

    while (default_type->len) {

        type = ngx_array_push(*types);
        if (type == NULL) {
            return NGX_ERROR;
        }

        type->key = *default_type;
        type->key_hash = ngx_hash_key(default_type->data,
                                      default_type->len);
        type->value = (void *) 4;

        default_type++;
    }

    return NGX_OK;
}",1,1,http\ngx_http.c,ngx_http_set_default_types,,false,2049,2076,ngx_http_set_default_types,,,63,"ngx_int_t ngx_http_set_default_types (ngx_conf_t*,ngx_array_t**,ngx_str_t*)"
257494,METHOD,http\ngx_http.h:<global>,TYPE_DECL,<global>,1,34,http\ngx_http.h,http\ngx_http.h:<global>,,false,1,180,<global>,,,1,
257510,METHOD,http\ngx_http.h:<global>,TYPE_DECL,"typedef ngx_int_t (*ngx_http_header_handler_pt)(ngx_http_request_t *r,
    ngx_table_elt_t *h, ngx_uint_t offset);",19,42,http\ngx_http.h,ngx_http_header_handler_pt,,false,24,25,ngx_http_header_handler_pt,,,15,"ngx_int_t ngx_http_header_handler_pt (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
257517,METHOD,http\ngx_http.h:<global>,TYPE_DECL,"typedef u_char *(*ngx_http_log_handler_pt)(ngx_http_request_t *r,
    ngx_http_request_t *sr, u_char *buf, size_t len);",16,52,http\ngx_http.h,ngx_http_log_handler_pt,,false,26,27,ngx_http_log_handler_pt,,,16,"u_char* ngx_http_log_handler_pt (ngx_http_request_t*,ngx_http_request_t*,u_char*,size_t)"
257540,METHOD,http\ngx_http.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_add_location(ngx_conf_t *cf, ngx_queue_t **locations,
    ngx_http_core_loc_conf_t *clcf);",11,35,http\ngx_http.h,ngx_http_add_location,,false,79,80,ngx_http_add_location,,,21,"ngx_int_t ngx_http_add_location (ngx_conf_t*,ngx_queue_t**,ngx_http_core_loc_conf_t*)"
257547,METHOD,http\ngx_http.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_add_listen(ngx_conf_t *cf, ngx_http_core_srv_conf_t *cscf,
    ngx_http_listen_opt_t *lsopt);",11,33,http\ngx_http.h,ngx_http_add_listen,,false,81,82,ngx_http_add_listen,,,22,"ngx_int_t ngx_http_add_listen (ngx_conf_t*,ngx_http_core_srv_conf_t*,ngx_http_listen_opt_t*)"
257554,METHOD,http\ngx_http.h:<global>,TYPE_DECL,void ngx_http_init_connection(ngx_connection_t *c);,6,50,http\ngx_http.h,ngx_http_init_connection,,false,85,85,ngx_http_init_connection,,,23,void ngx_http_init_connection (ngx_connection_t*)
257559,METHOD,http\ngx_http.h:<global>,TYPE_DECL,void ngx_http_close_connection(ngx_connection_t *c);,6,51,http\ngx_http.h,ngx_http_close_connection,,false,86,86,ngx_http_close_connection,,,24,void ngx_http_close_connection (ngx_connection_t*)
257564,METHOD,http\ngx_http.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_parse_request_line(ngx_http_request_t *r, ngx_buf_t *b);",11,74,http\ngx_http.h,ngx_http_parse_request_line,,false,96,96,ngx_http_parse_request_line,,,25,"ngx_int_t ngx_http_parse_request_line (ngx_http_request_t*,ngx_buf_t*)"
257570,METHOD,http\ngx_http.h:<global>,TYPE_DECL,ngx_int_t ngx_http_parse_uri(ngx_http_request_t *r);,11,51,http\ngx_http.h,ngx_http_parse_uri,,false,97,97,ngx_http_parse_uri,,,26,ngx_int_t ngx_http_parse_uri (ngx_http_request_t*)
257575,METHOD,http\ngx_http.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_parse_complex_uri(ngx_http_request_t *r,
    ngx_uint_t merge_slashes);",11,29,http\ngx_http.h,ngx_http_parse_complex_uri,,false,98,99,ngx_http_parse_complex_uri,,,27,"ngx_int_t ngx_http_parse_complex_uri (ngx_http_request_t*,ngx_uint_t)"
257581,METHOD,http\ngx_http.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_parse_status_line(ngx_http_request_t *r, ngx_buf_t *b,
    ngx_http_status_t *status);",11,30,http\ngx_http.h,ngx_http_parse_status_line,,false,100,101,ngx_http_parse_status_line,,,28,"ngx_int_t ngx_http_parse_status_line (ngx_http_request_t*,ngx_buf_t*,ngx_http_status_t*)"
257588,METHOD,http\ngx_http.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_parse_unsafe_uri(ngx_http_request_t *r, ngx_str_t *uri,
    ngx_str_t *args, ngx_uint_t *flags);",11,39,http\ngx_http.h,ngx_http_parse_unsafe_uri,,false,102,103,ngx_http_parse_unsafe_uri,,,29,"ngx_int_t ngx_http_parse_unsafe_uri (ngx_http_request_t*,ngx_str_t*,ngx_str_t*,ngx_uint_t*)"
257596,METHOD,http\ngx_http.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_parse_header_line(ngx_http_request_t *r, ngx_buf_t *b,
    ngx_uint_t allow_underscores);",11,33,http\ngx_http.h,ngx_http_parse_header_line,,false,104,105,ngx_http_parse_header_line,,,30,"ngx_int_t ngx_http_parse_header_line (ngx_http_request_t*,ngx_buf_t*,ngx_uint_t)"
257603,METHOD,http\ngx_http.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_parse_multi_header_lines(ngx_array_t *headers,
    ngx_str_t *name, ngx_str_t *value);",11,38,http\ngx_http.h,ngx_http_parse_multi_header_lines,,false,106,107,ngx_http_parse_multi_header_lines,,,31,"ngx_int_t ngx_http_parse_multi_header_lines (ngx_array_t*,ngx_str_t*,ngx_str_t*)"
257610,METHOD,http\ngx_http.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_parse_set_cookie_lines(ngx_array_t *headers,
    ngx_str_t *name, ngx_str_t *value);",11,38,http\ngx_http.h,ngx_http_parse_set_cookie_lines,,false,108,109,ngx_http_parse_set_cookie_lines,,,32,"ngx_int_t ngx_http_parse_set_cookie_lines (ngx_array_t*,ngx_str_t*,ngx_str_t*)"
257617,METHOD,http\ngx_http.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_arg(ngx_http_request_t *r, u_char *name, size_t len,
    ngx_str_t *value);",11,21,http\ngx_http.h,ngx_http_arg,,false,110,111,ngx_http_arg,,,33,"ngx_int_t ngx_http_arg (ngx_http_request_t*,u_char*,size_t,ngx_str_t*)"
257625,METHOD,http\ngx_http.h:<global>,TYPE_DECL,"void ngx_http_split_args(ngx_http_request_t *r, ngx_str_t *uri,
    ngx_str_t *args);",6,20,http\ngx_http.h,ngx_http_split_args,,false,112,113,ngx_http_split_args,,,34,"void ngx_http_split_args (ngx_http_request_t*,ngx_str_t*,ngx_str_t*)"
257632,METHOD,http\ngx_http.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_parse_chunked(ngx_http_request_t *r, ngx_buf_t *b,
    ngx_http_chunked_t *ctx);",11,28,http\ngx_http.h,ngx_http_parse_chunked,,false,114,115,ngx_http_parse_chunked,,,35,"ngx_int_t ngx_http_parse_chunked (ngx_http_request_t*,ngx_buf_t*,ngx_http_chunked_t*)"
257639,METHOD,http\ngx_http.h:<global>,TYPE_DECL,ngx_http_request_t *ngx_http_create_request(ngx_connection_t *c);,20,64,http\ngx_http.h,ngx_http_create_request,,false,118,118,ngx_http_create_request,,,36,ngx_http_request_t* ngx_http_create_request (ngx_connection_t*)
257644,METHOD,http\ngx_http.h:<global>,TYPE_DECL,ngx_int_t ngx_http_process_request_uri(ngx_http_request_t *r);,11,61,http\ngx_http.h,ngx_http_process_request_uri,,false,119,119,ngx_http_process_request_uri,,,37,ngx_int_t ngx_http_process_request_uri (ngx_http_request_t*)
257649,METHOD,http\ngx_http.h:<global>,TYPE_DECL,ngx_int_t ngx_http_process_request_header(ngx_http_request_t *r);,11,64,http\ngx_http.h,ngx_http_process_request_header,,false,120,120,ngx_http_process_request_header,,,38,ngx_int_t ngx_http_process_request_header (ngx_http_request_t*)
257654,METHOD,http\ngx_http.h:<global>,TYPE_DECL,void ngx_http_process_request(ngx_http_request_t *r);,6,52,http\ngx_http.h,ngx_http_process_request,,false,121,121,ngx_http_process_request,,,39,void ngx_http_process_request (ngx_http_request_t*)
257659,METHOD,http\ngx_http.h:<global>,TYPE_DECL,void ngx_http_update_location_config(ngx_http_request_t *r);,6,59,http\ngx_http.h,ngx_http_update_location_config,,false,122,122,ngx_http_update_location_config,,,40,void ngx_http_update_location_config (ngx_http_request_t*)
257664,METHOD,http\ngx_http.h:<global>,TYPE_DECL,void ngx_http_handler(ngx_http_request_t *r);,6,44,http\ngx_http.h,ngx_http_handler,,false,123,123,ngx_http_handler,,,41,void ngx_http_handler (ngx_http_request_t*)
257669,METHOD,http\ngx_http.h:<global>,TYPE_DECL,void ngx_http_run_posted_requests(ngx_connection_t *c);,6,54,http\ngx_http.h,ngx_http_run_posted_requests,,false,124,124,ngx_http_run_posted_requests,,,42,void ngx_http_run_posted_requests (ngx_connection_t*)
257674,METHOD,http\ngx_http.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_post_request(ngx_http_request_t *r,
    ngx_http_posted_request_t *pr);",11,34,http\ngx_http.h,ngx_http_post_request,,false,125,126,ngx_http_post_request,,,43,"ngx_int_t ngx_http_post_request (ngx_http_request_t*,ngx_http_posted_request_t*)"
257680,METHOD,http\ngx_http.h:<global>,TYPE_DECL,"void ngx_http_finalize_request(ngx_http_request_t *r, ngx_int_t rc);",6,67,http\ngx_http.h,ngx_http_finalize_request,,false,127,127,ngx_http_finalize_request,,,44,"void ngx_http_finalize_request (ngx_http_request_t*,ngx_int_t)"
257686,METHOD,http\ngx_http.h:<global>,TYPE_DECL,"void ngx_http_free_request(ngx_http_request_t *r, ngx_int_t rc);",6,63,http\ngx_http.h,ngx_http_free_request,,false,128,128,ngx_http_free_request,,,45,"void ngx_http_free_request (ngx_http_request_t*,ngx_int_t)"
257692,METHOD,http\ngx_http.h:<global>,TYPE_DECL,void ngx_http_empty_handler(ngx_event_t *wev);,6,45,http\ngx_http.h,ngx_http_empty_handler,,false,130,130,ngx_http_empty_handler,,,46,void ngx_http_empty_handler (ngx_event_t*)
257697,METHOD,http\ngx_http.h:<global>,TYPE_DECL,void ngx_http_request_empty_handler(ngx_http_request_t *r);,6,58,http\ngx_http.h,ngx_http_request_empty_handler,,false,131,131,ngx_http_request_empty_handler,,,47,void ngx_http_request_empty_handler (ngx_http_request_t*)
257702,METHOD,http\ngx_http.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_send_special(ngx_http_request_t *r, ngx_uint_t flags);",11,72,http\ngx_http.h,ngx_http_send_special,,false,137,137,ngx_http_send_special,,,48,"ngx_int_t ngx_http_send_special (ngx_http_request_t*,ngx_uint_t)"
257708,METHOD,http\ngx_http.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_read_client_request_body(ngx_http_request_t *r,
    ngx_http_client_body_handler_pt post_handler);",11,49,http\ngx_http.h,ngx_http_read_client_request_body,,false,140,141,ngx_http_read_client_request_body,,,49,"ngx_int_t ngx_http_read_client_request_body (ngx_http_request_t*,ngx_http_client_body_handler_pt)"
257714,METHOD,http\ngx_http.h:<global>,TYPE_DECL,ngx_int_t ngx_http_read_unbuffered_request_body(ngx_http_request_t *r);,11,70,http\ngx_http.h,ngx_http_read_unbuffered_request_body,,false,142,142,ngx_http_read_unbuffered_request_body,,,50,ngx_int_t ngx_http_read_unbuffered_request_body (ngx_http_request_t*)
257719,METHOD,http\ngx_http.h:<global>,TYPE_DECL,ngx_int_t ngx_http_send_header(ngx_http_request_t *r);,11,53,http\ngx_http.h,ngx_http_send_header,,false,144,144,ngx_http_send_header,,,51,ngx_int_t ngx_http_send_header (ngx_http_request_t*)
257724,METHOD,http\ngx_http.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_special_response_handler(ngx_http_request_t *r,
    ngx_int_t error);",11,20,http\ngx_http.h,ngx_http_special_response_handler,,false,145,146,ngx_http_special_response_handler,,,52,"ngx_int_t ngx_http_special_response_handler (ngx_http_request_t*,ngx_int_t)"
257730,METHOD,http\ngx_http.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_filter_finalize_request(ngx_http_request_t *r,
    ngx_module_t *m, ngx_int_t error);",11,37,http\ngx_http.h,ngx_http_filter_finalize_request,,false,147,148,ngx_http_filter_finalize_request,,,53,"ngx_int_t ngx_http_filter_finalize_request (ngx_http_request_t*,ngx_module_t*,ngx_int_t)"
257737,METHOD,http\ngx_http.h:<global>,TYPE_DECL,void ngx_http_clean_header(ngx_http_request_t *r);,6,49,http\ngx_http.h,ngx_http_clean_header,,false,149,149,ngx_http_clean_header,,,54,void ngx_http_clean_header (ngx_http_request_t*)
257742,METHOD,http\ngx_http.h:<global>,TYPE_DECL,ngx_int_t ngx_http_discard_request_body(ngx_http_request_t *r);,11,62,http\ngx_http.h,ngx_http_discard_request_body,,false,152,152,ngx_http_discard_request_body,,,55,ngx_int_t ngx_http_discard_request_body (ngx_http_request_t*)
257747,METHOD,http\ngx_http.h:<global>,TYPE_DECL,void ngx_http_discarded_request_body_handler(ngx_http_request_t *r);,6,67,http\ngx_http.h,ngx_http_discarded_request_body_handler,,false,153,153,ngx_http_discarded_request_body_handler,,,56,void ngx_http_discarded_request_body_handler (ngx_http_request_t*)
257752,METHOD,http\ngx_http.h:<global>,TYPE_DECL,void ngx_http_block_reading(ngx_http_request_t *r);,6,50,http\ngx_http.h,ngx_http_block_reading,,false,154,154,ngx_http_block_reading,,,57,void ngx_http_block_reading (ngx_http_request_t*)
257757,METHOD,http\ngx_http.h:<global>,TYPE_DECL,void ngx_http_test_reading(ngx_http_request_t *r);,6,49,http\ngx_http.h,ngx_http_test_reading,,false,155,155,ngx_http_test_reading,,,58,void ngx_http_test_reading (ngx_http_request_t*)
257762,METHOD,http\ngx_http.h:<global>,TYPE_DECL,"char *ngx_http_types_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",6,73,http\ngx_http.h,ngx_http_types_slot,,false,158,158,ngx_http_types_slot,,,59,"char* ngx_http_types_slot (ngx_conf_t*,ngx_command_t*,void*)"
257769,METHOD,http\ngx_http.h:<global>,TYPE_DECL,"char *ngx_http_merge_types(ngx_conf_t *cf, ngx_array_t **keys,
    ngx_hash_t *types_hash, ngx_array_t **prev_keys,
    ngx_hash_t *prev_types_hash, ngx_str_t *default_types);",6,58,http\ngx_http.h,ngx_http_merge_types,,false,159,161,ngx_http_merge_types,,,60,"char* ngx_http_merge_types (ngx_conf_t*,ngx_array_t**,ngx_hash_t*,ngx_array_t**,ngx_hash_t*,ngx_str_t*)"
257779,METHOD,http\ngx_http.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_set_default_types(ngx_conf_t *cf, ngx_array_t **types,
    ngx_str_t *default_type);",11,28,http\ngx_http.h,ngx_http_set_default_types,,false,162,163,ngx_http_set_default_types,,,61,"ngx_int_t ngx_http_set_default_types (ngx_conf_t*,ngx_array_t**,ngx_str_t*)"
257801,METHOD,http\ngx_http_cache.h:<global>,TYPE_DECL,<global>,1,41,http\ngx_http_cache.h,http\ngx_http_cache.h:<global>,,false,1,207,<global>,,,1,
257825,METHOD,<empty>,<empty>,<empty>,1,,http\ngx_http_cache.h,ngx_http_file_cache_node_t:<clinit>,,false,39,,<clinit>,,,18,
257881,METHOD,<empty>,<empty>,<empty>,1,,http\ngx_http_cache.h,ngx_http_cache_s:<clinit>,,false,65,,<clinit>,,,44,
257913,METHOD,<empty>,<empty>,<empty>,1,,http\ngx_http_cache.h,ngx_http_file_cache_header_t:<clinit>,,false,126,,<clinit>,,,16,
257958,METHOD,http\ngx_http_cache.h:<global>,TYPE_DECL,ngx_int_t ngx_http_file_cache_new(ngx_http_request_t *r);,11,56,http\ngx_http_cache.h,ngx_http_file_cache_new,,false,187,187,ngx_http_file_cache_new,,,11,ngx_int_t ngx_http_file_cache_new (ngx_http_request_t*)
257963,METHOD,http\ngx_http_cache.h:<global>,TYPE_DECL,ngx_int_t ngx_http_file_cache_create(ngx_http_request_t *r);,11,59,http\ngx_http_cache.h,ngx_http_file_cache_create,,false,188,188,ngx_http_file_cache_create,,,12,ngx_int_t ngx_http_file_cache_create (ngx_http_request_t*)
257968,METHOD,http\ngx_http_cache.h:<global>,TYPE_DECL,void ngx_http_file_cache_create_key(ngx_http_request_t *r);,6,58,http\ngx_http_cache.h,ngx_http_file_cache_create_key,,false,189,189,ngx_http_file_cache_create_key,,,13,void ngx_http_file_cache_create_key (ngx_http_request_t*)
257973,METHOD,http\ngx_http_cache.h:<global>,TYPE_DECL,ngx_int_t ngx_http_file_cache_open(ngx_http_request_t *r);,11,57,http\ngx_http_cache.h,ngx_http_file_cache_open,,false,190,190,ngx_http_file_cache_open,,,14,ngx_int_t ngx_http_file_cache_open (ngx_http_request_t*)
257978,METHOD,http\ngx_http_cache.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_file_cache_set_header(ngx_http_request_t *r, u_char *buf);",11,76,http\ngx_http_cache.h,ngx_http_file_cache_set_header,,false,191,191,ngx_http_file_cache_set_header,,,15,"ngx_int_t ngx_http_file_cache_set_header (ngx_http_request_t*,u_char*)"
257984,METHOD,http\ngx_http_cache.h:<global>,TYPE_DECL,"void ngx_http_file_cache_update(ngx_http_request_t *r, ngx_temp_file_t *tf);",6,75,http\ngx_http_cache.h,ngx_http_file_cache_update,,false,192,192,ngx_http_file_cache_update,,,16,"void ngx_http_file_cache_update (ngx_http_request_t*,ngx_temp_file_t*)"
257990,METHOD,http\ngx_http_cache.h:<global>,TYPE_DECL,void ngx_http_file_cache_update_header(ngx_http_request_t *r);,6,61,http\ngx_http_cache.h,ngx_http_file_cache_update_header,,false,193,193,ngx_http_file_cache_update_header,,,17,void ngx_http_file_cache_update_header (ngx_http_request_t*)
257995,METHOD,http\ngx_http_cache.h:<global>,TYPE_DECL,ngx_int_t ngx_http_cache_send(ngx_http_request_t *);,11,51,http\ngx_http_cache.h,ngx_http_cache_send,,false,194,194,ngx_http_cache_send,,,18,ngx_int_t ngx_http_cache_send (ngx_http_request_t*)
258000,METHOD,http\ngx_http_cache.h:<global>,TYPE_DECL,"void ngx_http_file_cache_free(ngx_http_cache_t *c, ngx_temp_file_t *tf);",6,71,http\ngx_http_cache.h,ngx_http_file_cache_free,,false,195,195,ngx_http_file_cache_free,,,19,"void ngx_http_file_cache_free (ngx_http_cache_t*,ngx_temp_file_t*)"
258006,METHOD,http\ngx_http_cache.h:<global>,TYPE_DECL,"time_t ngx_http_file_cache_valid(ngx_array_t *cache_valid, ngx_uint_t status);",8,77,http\ngx_http_cache.h,ngx_http_file_cache_valid,,false,196,196,ngx_http_file_cache_valid,,,20,"time_t ngx_http_file_cache_valid (ngx_array_t*,ngx_uint_t)"
258012,METHOD,http\ngx_http_cache.h:<global>,TYPE_DECL,"char *ngx_http_file_cache_set_slot(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",6,15,http\ngx_http_cache.h,ngx_http_file_cache_set_slot,,false,198,199,ngx_http_file_cache_set_slot,,,21,"char* ngx_http_file_cache_set_slot (ngx_conf_t*,ngx_command_t*,void*)"
258019,METHOD,http\ngx_http_cache.h:<global>,TYPE_DECL,"char *ngx_http_file_cache_valid_set_slot(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",6,15,http\ngx_http_cache.h,ngx_http_file_cache_valid_set_slot,,false,200,201,ngx_http_file_cache_valid_set_slot,,,22,"char* ngx_http_file_cache_valid_set_slot (ngx_conf_t*,ngx_command_t*,void*)"
258037,METHOD,http\ngx_http_config.h:<global>,TYPE_DECL,<global>,1,41,http\ngx_http_config.h,http\ngx_http_config.h:<global>,,false,1,75,<global>,,,1,
258045,METHOD,ngx_http_module_t,TYPE_DECL,ngx_int_t   (*preconfiguration)(ngx_conf_t *cf);,17,51,http\ngx_http_config.h,ngx_http_module_t.preconfiguration,,false,25,25,preconfiguration,,,1,ngx_int_t ngx_http_module_t.preconfiguration (ngx_conf_t*)
258050,METHOD,ngx_http_module_t,TYPE_DECL,ngx_int_t   (*postconfiguration)(ngx_conf_t *cf);,17,52,http\ngx_http_config.h,ngx_http_module_t.postconfiguration,,false,26,26,postconfiguration,,,2,ngx_int_t ngx_http_module_t.postconfiguration (ngx_conf_t*)
258055,METHOD,ngx_http_module_t,TYPE_DECL,void       *(*create_main_conf)(ngx_conf_t *cf);,16,51,http\ngx_http_config.h,ngx_http_module_t.create_main_conf,,false,28,28,create_main_conf,,,3,void* ngx_http_module_t.create_main_conf (ngx_conf_t*)
258060,METHOD,ngx_http_module_t,TYPE_DECL,"char       *(*init_main_conf)(ngx_conf_t *cf, void *conf);",16,61,http\ngx_http_config.h,ngx_http_module_t.init_main_conf,,false,29,29,init_main_conf,,,4,"char* ngx_http_module_t.init_main_conf (ngx_conf_t*,void*)"
258066,METHOD,ngx_http_module_t,TYPE_DECL,void       *(*create_srv_conf)(ngx_conf_t *cf);,16,50,http\ngx_http_config.h,ngx_http_module_t.create_srv_conf,,false,31,31,create_srv_conf,,,5,void* ngx_http_module_t.create_srv_conf (ngx_conf_t*)
258071,METHOD,ngx_http_module_t,TYPE_DECL,"char       *(*merge_srv_conf)(ngx_conf_t *cf, void *prev, void *conf);",16,73,http\ngx_http_config.h,ngx_http_module_t.merge_srv_conf,,false,32,32,merge_srv_conf,,,6,"char* ngx_http_module_t.merge_srv_conf (ngx_conf_t*,void*,void*)"
258078,METHOD,ngx_http_module_t,TYPE_DECL,void       *(*create_loc_conf)(ngx_conf_t *cf);,16,50,http\ngx_http_config.h,ngx_http_module_t.create_loc_conf,,false,34,34,create_loc_conf,,,7,void* ngx_http_module_t.create_loc_conf (ngx_conf_t*)
258083,METHOD,ngx_http_module_t,TYPE_DECL,"char       *(*merge_loc_conf)(ngx_conf_t *cf, void *prev, void *conf);",16,73,http\ngx_http_config.h,ngx_http_module_t.merge_loc_conf,,false,35,35,merge_loc_conf,,,8,"char* ngx_http_module_t.merge_loc_conf (ngx_conf_t*,void*,void*)"
258100,METHOD,http\ngx_http_copy_filter_module.c:<global>,TYPE_DECL,<global>,1,2,http\ngx_http_copy_filter_module.c,http\ngx_http_copy_filter_module.c:<global>,,false,1,379,<global>,,,1,
258105,METHOD,http\ngx_http_copy_filter_module.c:<global>,TYPE_DECL,static void *ngx_http_copy_filter_create_conf(ngx_conf_t *cf);,13,61,http\ngx_http_copy_filter_module.c,ngx_http_copy_filter_create_conf,,false,33,33,ngx_http_copy_filter_create_conf,,,3,void* ngx_http_copy_filter_create_conf (ngx_conf_t*)
258110,METHOD,http\ngx_http_copy_filter_module.c:<global>,TYPE_DECL,"static char *ngx_http_copy_filter_merge_conf(ngx_conf_t *cf,
    void *parent, void *child);",13,30,http\ngx_http_copy_filter_module.c,ngx_http_copy_filter_merge_conf,,false,34,35,ngx_http_copy_filter_merge_conf,,,4,"char* ngx_http_copy_filter_merge_conf (ngx_conf_t*,void*,void*)"
258117,METHOD,http\ngx_http_copy_filter_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_copy_filter_init(ngx_conf_t *cf);,18,58,http\ngx_http_copy_filter_module.c,ngx_http_copy_filter_init,,false,36,36,ngx_http_copy_filter_init,,,5,ngx_int_t ngx_http_copy_filter_init (ngx_conf_t*)
258173,METHOD,http\ngx_http_copy_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_copy_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    ngx_int_t                     rc;
    ngx_connection_t             *c;
    ngx_output_chain_ctx_t       *ctx;
    ngx_http_core_loc_conf_t     *clcf;
    ngx_http_copy_filter_conf_t  *conf;

    c = r->connection;

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, c->log, 0,
                   ""http copy filter: \""%V?%V\"""", &r->uri, &r->args);

    ctx = ngx_http_get_module_ctx(r, ngx_http_copy_filter_module);

    if (ctx == NULL) {
        ctx = ngx_pcalloc(r->pool, sizeof(ngx_output_chain_ctx_t));
        if (ctx == NULL) {
            return NGX_ERROR;
        }

        ngx_http_set_ctx(r, ctx, ngx_http_copy_filter_module);

        conf = ngx_http_get_module_loc_conf(r, ngx_http_copy_filter_module);
        clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

        ctx->sendfile = c->sendfile;
        ctx->need_in_memory = r->main_filter_need_in_memory
                              || r->filte...",1,1,http\ngx_http_copy_filter_module.c,ngx_http_copy_filter,,false,86,165,ngx_http_copy_filter,,,13,"ngx_int_t ngx_http_copy_filter (ngx_http_request_t*,ngx_chain_t*)"
258368,METHOD,http\ngx_http_copy_filter_module.c:<global>,TYPE_DECL,"static void *
ngx_http_copy_filter_create_conf(ngx_conf_t *cf)
{
    ngx_http_copy_filter_conf_t *conf;

    conf = ngx_palloc(cf->pool, sizeof(ngx_http_copy_filter_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    conf->bufs.num = 0;

    return conf;
}",1,1,http\ngx_http_copy_filter_module.c,ngx_http_copy_filter_create_conf,,false,344,357,ngx_http_copy_filter_create_conf,,,14,void* ngx_http_copy_filter_create_conf (ngx_conf_t*)
258398,METHOD,http\ngx_http_copy_filter_module.c:<global>,TYPE_DECL,"static char *
ngx_http_copy_filter_merge_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_copy_filter_conf_t *prev = parent;
    ngx_http_copy_filter_conf_t *conf = child;

    ngx_conf_merge_bufs_value(conf->bufs, prev->bufs, 2, 32768);

    return NULL;
}",1,1,http\ngx_http_copy_filter_module.c,ngx_http_copy_filter_merge_conf,,false,360,369,ngx_http_copy_filter_merge_conf,,,15,"char* ngx_http_copy_filter_merge_conf (ngx_conf_t*,void*,void*)"
258424,METHOD,http\ngx_http_copy_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_copy_filter_init(ngx_conf_t *cf)
{
    ngx_http_next_body_filter = ngx_http_top_body_filter;
    ngx_http_top_body_filter = ngx_http_copy_filter;

    return NGX_OK;
}",1,1,http\ngx_http_copy_filter_module.c,ngx_http_copy_filter_init,,false,372,379,ngx_http_copy_filter_init,,,16,ngx_int_t ngx_http_copy_filter_init (ngx_conf_t*)
258446,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,<global>,1,25,http\ngx_http_core_module.c,http\ngx_http_core_module.c:<global>,,false,1,5185,<global>,,,1,
258452,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_core_auth_delay(ngx_http_request_t *r);,18,64,http\ngx_http_core_module.c,ngx_http_core_auth_delay,,false,24,24,ngx_http_core_auth_delay,,,3,ngx_int_t ngx_http_core_auth_delay (ngx_http_request_t*)
258457,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,static void ngx_http_core_auth_delay_handler(ngx_http_request_t *r);,13,67,http\ngx_http_core_module.c,ngx_http_core_auth_delay_handler,,false,25,25,ngx_http_core_auth_delay_handler,,,4,void ngx_http_core_auth_delay_handler (ngx_http_request_t*)
258462,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_core_find_location(ngx_http_request_t *r);,18,67,http\ngx_http_core_module.c,ngx_http_core_find_location,,false,27,27,ngx_http_core_find_location,,,5,ngx_int_t ngx_http_core_find_location (ngx_http_request_t*)
258467,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_core_find_static_location(ngx_http_request_t *r,
    ngx_http_location_tree_node_t *node);",18,40,http\ngx_http_core_module.c,ngx_http_core_find_static_location,,false,28,29,ngx_http_core_find_static_location,,,6,"ngx_int_t ngx_http_core_find_static_location (ngx_http_request_t*,ngx_http_location_tree_node_t*)"
258473,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_core_preconfiguration(ngx_conf_t *cf);,18,63,http\ngx_http_core_module.c,ngx_http_core_preconfiguration,,false,31,31,ngx_http_core_preconfiguration,,,7,ngx_int_t ngx_http_core_preconfiguration (ngx_conf_t*)
258478,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_core_postconfiguration(ngx_conf_t *cf);,18,64,http\ngx_http_core_module.c,ngx_http_core_postconfiguration,,false,32,32,ngx_http_core_postconfiguration,,,8,ngx_int_t ngx_http_core_postconfiguration (ngx_conf_t*)
258483,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,static void *ngx_http_core_create_main_conf(ngx_conf_t *cf);,13,59,http\ngx_http_core_module.c,ngx_http_core_create_main_conf,,false,33,33,ngx_http_core_create_main_conf,,,9,void* ngx_http_core_create_main_conf (ngx_conf_t*)
258488,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *ngx_http_core_init_main_conf(ngx_conf_t *cf, void *conf);",13,69,http\ngx_http_core_module.c,ngx_http_core_init_main_conf,,false,34,34,ngx_http_core_init_main_conf,,,10,"char* ngx_http_core_init_main_conf (ngx_conf_t*,void*)"
258494,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,static void *ngx_http_core_create_srv_conf(ngx_conf_t *cf);,13,58,http\ngx_http_core_module.c,ngx_http_core_create_srv_conf,,false,35,35,ngx_http_core_create_srv_conf,,,11,void* ngx_http_core_create_srv_conf (ngx_conf_t*)
258499,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *ngx_http_core_merge_srv_conf(ngx_conf_t *cf,
    void *parent, void *child);",13,30,http\ngx_http_core_module.c,ngx_http_core_merge_srv_conf,,false,36,37,ngx_http_core_merge_srv_conf,,,12,"char* ngx_http_core_merge_srv_conf (ngx_conf_t*,void*,void*)"
258506,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,static void *ngx_http_core_create_loc_conf(ngx_conf_t *cf);,13,58,http\ngx_http_core_module.c,ngx_http_core_create_loc_conf,,false,38,38,ngx_http_core_create_loc_conf,,,13,void* ngx_http_core_create_loc_conf (ngx_conf_t*)
258511,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *ngx_http_core_merge_loc_conf(ngx_conf_t *cf,
    void *parent, void *child);",13,30,http\ngx_http_core_module.c,ngx_http_core_merge_loc_conf,,false,39,40,ngx_http_core_merge_loc_conf,,,14,"char* ngx_http_core_merge_loc_conf (ngx_conf_t*,void*,void*)"
258518,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *ngx_http_core_server(ngx_conf_t *cf, ngx_command_t *cmd,
    void *dummy);",13,16,http\ngx_http_core_module.c,ngx_http_core_server,,false,42,43,ngx_http_core_server,,,15,"char* ngx_http_core_server (ngx_conf_t*,ngx_command_t*,void*)"
258525,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *ngx_http_core_location(ngx_conf_t *cf, ngx_command_t *cmd,
    void *dummy);",13,16,http\ngx_http_core_module.c,ngx_http_core_location,,false,44,45,ngx_http_core_location,,,16,"char* ngx_http_core_location (ngx_conf_t*,ngx_command_t*,void*)"
258532,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_core_regex_location(ngx_conf_t *cf,
    ngx_http_core_loc_conf_t *clcf, ngx_str_t *regex, ngx_uint_t caseless);",18,74,http\ngx_http_core_module.c,ngx_http_core_regex_location,,false,46,47,ngx_http_core_regex_location,,,17,"ngx_int_t ngx_http_core_regex_location (ngx_conf_t*,ngx_http_core_loc_conf_t*,ngx_str_t*,ngx_uint_t)"
258540,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *ngx_http_core_types(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\ngx_http_core_module.c,ngx_http_core_types,,false,49,50,ngx_http_core_types,,,18,"char* ngx_http_core_types (ngx_conf_t*,ngx_command_t*,void*)"
258547,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *ngx_http_core_type(ngx_conf_t *cf, ngx_command_t *dummy,
    void *conf);",13,15,http\ngx_http_core_module.c,ngx_http_core_type,,false,51,52,ngx_http_core_type,,,19,"char* ngx_http_core_type (ngx_conf_t*,ngx_command_t*,void*)"
258554,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *ngx_http_core_listen(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\ngx_http_core_module.c,ngx_http_core_listen,,false,54,55,ngx_http_core_listen,,,20,"char* ngx_http_core_listen (ngx_conf_t*,ngx_command_t*,void*)"
258561,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *ngx_http_core_server_name(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\ngx_http_core_module.c,ngx_http_core_server_name,,false,56,57,ngx_http_core_server_name,,,21,"char* ngx_http_core_server_name (ngx_conf_t*,ngx_command_t*,void*)"
258568,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *ngx_http_core_root(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",13,79,http\ngx_http_core_module.c,ngx_http_core_root,,false,58,58,ngx_http_core_root,,,22,"char* ngx_http_core_root (ngx_conf_t*,ngx_command_t*,void*)"
258575,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *ngx_http_core_limit_except(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\ngx_http_core_module.c,ngx_http_core_limit_except,,false,59,60,ngx_http_core_limit_except,,,23,"char* ngx_http_core_limit_except (ngx_conf_t*,ngx_command_t*,void*)"
258582,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *ngx_http_core_set_aio(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\ngx_http_core_module.c,ngx_http_core_set_aio,,false,61,62,ngx_http_core_set_aio,,,24,"char* ngx_http_core_set_aio (ngx_conf_t*,ngx_command_t*,void*)"
258589,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *ngx_http_core_directio(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\ngx_http_core_module.c,ngx_http_core_directio,,false,63,64,ngx_http_core_directio,,,25,"char* ngx_http_core_directio (ngx_conf_t*,ngx_command_t*,void*)"
258596,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *ngx_http_core_error_page(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\ngx_http_core_module.c,ngx_http_core_error_page,,false,65,66,ngx_http_core_error_page,,,26,"char* ngx_http_core_error_page (ngx_conf_t*,ngx_command_t*,void*)"
258603,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *ngx_http_core_open_file_cache(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\ngx_http_core_module.c,ngx_http_core_open_file_cache,,false,67,68,ngx_http_core_open_file_cache,,,27,"char* ngx_http_core_open_file_cache (ngx_conf_t*,ngx_command_t*,void*)"
258610,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *ngx_http_core_error_log(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\ngx_http_core_module.c,ngx_http_core_error_log,,false,69,70,ngx_http_core_error_log,,,28,"char* ngx_http_core_error_log (ngx_conf_t*,ngx_command_t*,void*)"
258617,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *ngx_http_core_keepalive(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\ngx_http_core_module.c,ngx_http_core_keepalive,,false,71,72,ngx_http_core_keepalive,,,29,"char* ngx_http_core_keepalive (ngx_conf_t*,ngx_command_t*,void*)"
258624,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *ngx_http_core_internal(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\ngx_http_core_module.c,ngx_http_core_internal,,false,73,74,ngx_http_core_internal,,,30,"char* ngx_http_core_internal (ngx_conf_t*,ngx_command_t*,void*)"
258631,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *ngx_http_core_resolver(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\ngx_http_core_module.c,ngx_http_core_resolver,,false,75,76,ngx_http_core_resolver,,,31,"char* ngx_http_core_resolver (ngx_conf_t*,ngx_command_t*,void*)"
258638,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_get_forwarded_addr_internal(ngx_http_request_t *r,
    ngx_addr_t *addr, u_char *xff, size_t xfflen, ngx_array_t *proxies,
    int recursive);",18,18,http\ngx_http_core_module.c,ngx_http_get_forwarded_addr_internal,,false,83,85,ngx_http_get_forwarded_addr_internal,,,32,"ngx_int_t ngx_http_get_forwarded_addr_internal (ngx_http_request_t*,ngx_addr_t*,u_char*,size_t,ngx_array_t*,int)"
258648,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *ngx_http_core_lowat_check(ngx_conf_t *cf, void *post, void *data);",13,78,http\ngx_http_core_module.c,ngx_http_core_lowat_check,,false,91,91,ngx_http_core_lowat_check,,,33,"char* ngx_http_core_lowat_check (ngx_conf_t*,void*,void*)"
258655,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *ngx_http_core_pool_size(ngx_conf_t *cf, void *post, void *data);",13,76,http\ngx_http_core_module.c,ngx_http_core_pool_size,,false,92,92,ngx_http_core_pool_size,,,34,"char* ngx_http_core_pool_size (ngx_conf_t*,void*,void*)"
260012,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"void
ngx_http_handler(ngx_http_request_t *r)
{
    ngx_http_core_main_conf_t  *cmcf;

    r->connection->log->action = NULL;

    if (!r->internal) {
        switch (r->headers_in.connection_type) {
        case 0:
            r->keepalive = (r->http_version > NGX_HTTP_VERSION_10);
            break;

        case NGX_HTTP_CONNECTION_CLOSE:
            r->keepalive = 0;
            break;

        case NGX_HTTP_CONNECTION_KEEP_ALIVE:
            r->keepalive = 1;
            break;
        }

        r->lingering_close = (r->headers_in.content_length_n > 0
                              || r->headers_in.chunked);
        r->phase_handler = 0;

    } else {
        cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);
        r->phase_handler = cmcf->phase_engine.server_rewrite_index;
    }

    r->valid_location = 1;
#if (NGX_HTTP_GZIP)
    r->gzip_tested = 0;
    r->gzip_ok = 0;
    r->gzip_vary = 0;
#endif

    r->write_event_handler = ngx_http_core_run_phases;
    ngx_htt...",1,1,http\ngx_http_core_module.c,ngx_http_handler,,false,812,852,ngx_http_handler,,,61,void ngx_http_handler (ngx_http_request_t*)
260118,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"void
ngx_http_core_run_phases(ngx_http_request_t *r)
{
    ngx_int_t                   rc;
    ngx_http_phase_handler_t   *ph;
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);

    ph = cmcf->phase_engine.handlers;

    while (ph[r->phase_handler].checker) {

        rc = ph[r->phase_handler].checker(r, &ph[r->phase_handler]);

        if (rc == NGX_OK) {
            return;
        }
    }
}",1,1,http\ngx_http_core_module.c,ngx_http_core_run_phases,,false,855,874,ngx_http_core_run_phases,,,62,void ngx_http_core_run_phases (ngx_http_request_t*)
260170,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_core_generic_phase(ngx_http_request_t *r, ngx_http_phase_handler_t *ph)
{
    ngx_int_t  rc;

    /*
     * generic phase checker,
     * used by the post read and pre-access phases
     */

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""generic phase: %ui"", r->phase_handler);

    rc = ph->handler(r);

    if (rc == NGX_OK) {
        r->phase_handler = ph->next;
        return NGX_AGAIN;
    }

    if (rc == NGX_DECLINED) {
        r->phase_handler++;
        return NGX_AGAIN;
    }

    if (rc == NGX_AGAIN || rc == NGX_DONE) {
        return NGX_OK;
    }

    /* rc == NGX_ERROR || rc == NGX_HTTP_...  */

    ngx_http_finalize_request(r, rc);

    return NGX_OK;
}",1,1,http\ngx_http_core_module.c,ngx_http_core_generic_phase,,false,877,911,ngx_http_core_generic_phase,,,63,"ngx_int_t ngx_http_core_generic_phase (ngx_http_request_t*,ngx_http_phase_handler_t*)"
260237,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_core_rewrite_phase(ngx_http_request_t *r, ngx_http_phase_handler_t *ph)
{
    ngx_int_t  rc;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""rewrite phase: %ui"", r->phase_handler);

    rc = ph->handler(r);

    if (rc == NGX_DECLINED) {
        r->phase_handler++;
        return NGX_AGAIN;
    }

    if (rc == NGX_DONE) {
        return NGX_OK;
    }

    /* NGX_OK, NGX_AGAIN, NGX_ERROR, NGX_HTTP_...  */

    ngx_http_finalize_request(r, rc);

    return NGX_OK;
}",1,1,http\ngx_http_core_module.c,ngx_http_core_rewrite_phase,,false,914,938,ngx_http_core_rewrite_phase,,,64,"ngx_int_t ngx_http_core_rewrite_phase (ngx_http_request_t*,ngx_http_phase_handler_t*)"
260286,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_core_find_config_phase(ngx_http_request_t *r,
    ngx_http_phase_handler_t *ph)
{
    u_char                    *p;
    size_t                     len;
    ngx_int_t                  rc;
    ngx_http_core_loc_conf_t  *clcf;

    r->content_handler = NULL;
    r->uri_changed = 0;

    rc = ngx_http_core_find_location(r);

    if (rc == NGX_ERROR) {
        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
        return NGX_OK;
    }

    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    if (!r->internal && clcf->internal) {
        ngx_http_finalize_request(r, NGX_HTTP_NOT_FOUND);
        return NGX_OK;
    }

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""using configuration \""%s%V\"""",
                   (clcf->noname ? ""*"" : (clcf->exact_match ? ""="" : """")),
                   &clcf->name);

    ngx_http_update_location_config(r);

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
       ...",1,1,http\ngx_http_core_module.c,ngx_http_core_find_config_phase,,false,941,1032,ngx_http_core_find_config_phase,,,65,"ngx_int_t ngx_http_core_find_config_phase (ngx_http_request_t*,ngx_http_phase_handler_t*)"
260613,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_core_post_rewrite_phase(ngx_http_request_t *r,
    ngx_http_phase_handler_t *ph)
{
    ngx_http_core_srv_conf_t  *cscf;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""post rewrite phase: %ui"", r->phase_handler);

    if (!r->uri_changed) {
        r->phase_handler++;
        return NGX_AGAIN;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""uri changes: %d"", r->uri_changes);

    /*
     * gcc before 3.3 compiles the broken code for
     *     if (r->uri_changes-- == 0)
     * if the r->uri_changes is defined as
     *     unsigned  uri_changes:4
     */

    r->uri_changes--;

    if (r->uri_changes == 0) {
        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                      ""rewrite or internal redirection cycle ""
                      ""while processing \""%V\"""", &r->uri);

        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
        return NGX_OK;
    }

    r...",1,1,http\ngx_http_core_module.c,ngx_http_core_post_rewrite_phase,,false,1035,1076,ngx_http_core_post_rewrite_phase,,,66,"ngx_int_t ngx_http_core_post_rewrite_phase (ngx_http_request_t*,ngx_http_phase_handler_t*)"
260708,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_core_access_phase(ngx_http_request_t *r, ngx_http_phase_handler_t *ph)
{
    ngx_int_t                  rc;
    ngx_http_core_loc_conf_t  *clcf;

    if (r != r->main) {
        r->phase_handler = ph->next;
        return NGX_AGAIN;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""access phase: %ui"", r->phase_handler);

    rc = ph->handler(r);

    if (rc == NGX_DECLINED) {
        r->phase_handler++;
        return NGX_AGAIN;
    }

    if (rc == NGX_AGAIN || rc == NGX_DONE) {
        return NGX_OK;
    }

    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    if (clcf->satisfy == NGX_HTTP_SATISFY_ALL) {

        if (rc == NGX_OK) {
            r->phase_handler++;
            return NGX_AGAIN;
        }

    } else {
        if (rc == NGX_OK) {
            r->access_code = 0;

            if (r->headers_out.www_authenticate) {
                r->headers_out.www_authenticate->hash = 0;
            }

       ...",1,1,http\ngx_http_core_module.c,ngx_http_core_access_phase,,false,1079,1143,ngx_http_core_access_phase,,,67,"ngx_int_t ngx_http_core_access_phase (ngx_http_request_t*,ngx_http_phase_handler_t*)"
260873,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_core_post_access_phase(ngx_http_request_t *r,
    ngx_http_phase_handler_t *ph)
{
    ngx_int_t  access_code;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""post access phase: %ui"", r->phase_handler);

    access_code = r->access_code;

    if (access_code) {
        r->access_code = 0;

        if (access_code == NGX_HTTP_FORBIDDEN) {
            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                          ""access forbidden by rule"");
        }

        if (access_code == NGX_HTTP_UNAUTHORIZED) {
            return ngx_http_core_auth_delay(r);
        }

        ngx_http_finalize_request(r, access_code);
        return NGX_OK;
    }

    r->phase_handler++;
    return NGX_AGAIN;
}",1,1,http\ngx_http_core_module.c,ngx_http_core_post_access_phase,,false,1146,1175,ngx_http_core_post_access_phase,,,68,"ngx_int_t ngx_http_core_post_access_phase (ngx_http_request_t*,ngx_http_phase_handler_t*)"
260938,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_core_auth_delay(ngx_http_request_t *r)
{
    ngx_http_core_loc_conf_t  *clcf;

    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    if (clcf->auth_delay == 0) {
        ngx_http_finalize_request(r, NGX_HTTP_UNAUTHORIZED);
        return NGX_OK;
    }

    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
                  ""delaying unauthorized request"");

    if (ngx_handle_read_event(r->connection->read, 0) != NGX_OK) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    r->read_event_handler = ngx_http_test_reading;
    r->write_event_handler = ngx_http_core_auth_delay_handler;

    r->connection->write->delayed = 1;
    ngx_add_timer(r->connection->write, clcf->auth_delay);

    /*
     * trigger an additional event loop iteration
     * to ensure constant-time processing
     */

    ngx_post_event(r->connection->write, &ngx_posted_next_events);

    return NGX_OK;
}",1,1,http\ngx_http_core_module.c,ngx_http_core_auth_delay,,false,1178,1211,ngx_http_core_auth_delay,,,69,ngx_int_t ngx_http_core_auth_delay (ngx_http_request_t*)
261021,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static void
ngx_http_core_auth_delay_handler(ngx_http_request_t *r)
{
    ngx_event_t  *wev;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""auth delay handler"");

    wev = r->connection->write;

    if (wev->delayed) {

        if (ngx_handle_write_event(wev, 0) != NGX_OK) {
            ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
        }

        return;
    }

    ngx_http_finalize_request(r, NGX_HTTP_UNAUTHORIZED);
}",1,1,http\ngx_http_core_module.c,ngx_http_core_auth_delay_handler,,false,1214,1234,ngx_http_core_auth_delay_handler,,,70,void ngx_http_core_auth_delay_handler (ngx_http_request_t*)
261062,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_core_content_phase(ngx_http_request_t *r,
    ngx_http_phase_handler_t *ph)
{
    size_t     root;
    ngx_int_t  rc;
    ngx_str_t  path;

    if (r->content_handler) {
        r->write_event_handler = ngx_http_request_empty_handler;
        ngx_http_finalize_request(r, r->content_handler(r));
        return NGX_OK;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""content phase: %ui"", r->phase_handler);

    rc = ph->handler(r);

    if (rc != NGX_DECLINED) {
        ngx_http_finalize_request(r, rc);
        return NGX_OK;
    }

    /* rc == NGX_DECLINED */

    ph++;

    if (ph->checker) {
        r->phase_handler++;
        return NGX_AGAIN;
    }

    /* no content handler was found */

    if (r->uri.data[r->uri.len - 1] == '/') {

        if (ngx_http_map_uri_to_path(r, &path, &root, 0) != NULL) {
            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                          ""directory index of \""%s\"" is for...",1,1,http\ngx_http_core_module.c,ngx_http_core_content_phase,,false,1237,1287,ngx_http_core_content_phase,,,71,"ngx_int_t ngx_http_core_content_phase (ngx_http_request_t*,ngx_http_phase_handler_t*)"
261191,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"void
ngx_http_update_location_config(ngx_http_request_t *r)
{
    ngx_http_core_loc_conf_t  *clcf;

    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    if (r->method & clcf->limit_except) {
        r->loc_conf = clcf->limit_except_loc_conf;
        clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);
    }

    if (r == r->main) {
        ngx_set_connection_log(r->connection, clcf->error_log);
    }

    if ((ngx_io.flags & NGX_IO_SENDFILE) && clcf->sendfile) {
        r->connection->sendfile = 1;

    } else {
        r->connection->sendfile = 0;
    }

    if (clcf->client_body_in_file_only) {
        r->request_body_in_file_only = 1;
        r->request_body_in_persistent_file = 1;
        r->request_body_in_clean_file =
            clcf->client_body_in_file_only == NGX_HTTP_REQUEST_BODY_FILE_CLEAN;
        r->request_body_file_log_level = NGX_LOG_NOTICE;

    } else {
        r->request_body_file_log_level = NGX_LOG_WARN;
    }

    r->request_body_in_...",1,46,http\ngx_http_core_module.c,ngx_http_update_location_config,,false,1290,1365,ngx_http_update_location_config,,,72,void ngx_http_update_location_config (ngx_http_request_t*)
261415,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_core_find_location(ngx_http_request_t *r)
{
    ngx_int_t                  rc;
    ngx_http_core_loc_conf_t  *pclcf;
#if (NGX_PCRE)
    ngx_int_t                  n;
    ngx_uint_t                 noregex;
    ngx_http_core_loc_conf_t  *clcf, **clcfp;

    noregex = 0;
#endif

    pclcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    rc = ngx_http_core_find_static_location(r, pclcf->static_locations);

    if (rc == NGX_AGAIN) {

#if (NGX_PCRE)
        clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

        noregex = clcf->noregex;
#endif

        /* look up nested locations */

        rc = ngx_http_core_find_location(r);
    }

    if (rc == NGX_OK || rc == NGX_DONE) {
        return rc;
    }

    /* rc == NGX_DECLINED or rc == NGX_AGAIN in nested location */

#if (NGX_PCRE)

    if (noregex == 0 && pclcf->regex_locations) {

        for (clcfp = pclcf->regex_locations; *clcfp; clcfp++) {

            ngx_log_debug1(NGX_LOG_D...",1,1,http\ngx_http_core_module.c,ngx_http_core_find_location,,false,1376,1443,ngx_http_core_find_location,,,73,ngx_int_t ngx_http_core_find_location (ngx_http_request_t*)
261456,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_core_find_static_location(ngx_http_request_t *r,
    ngx_http_location_tree_node_t *node)
{
    u_char     *uri;
    size_t      len, n;
    ngx_int_t   rc, rv;

    len = r->uri.len;
    uri = r->uri.data;

    rv = NGX_DECLINED;

    for ( ;; ) {

        if (node == NULL) {
            return rv;
        }

        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                       ""test location: \""%*s\"""",
                       (size_t) node->len, node->name);

        n = (len <= (size_t) node->len) ? len : node->len;

        rc = ngx_filename_cmp(uri, node->name, n);

        if (rc != 0) {
            node = (rc < 0) ? node->left : node->right;

            continue;
        }

        if (len > (size_t) node->len) {

            if (node->inclusive) {

                r->loc_conf = node->inclusive->loc_conf;
                rv = NGX_AGAIN;

                node = node->tree;
                uri += n;
                len -= n;

       ...",1,1,http\ngx_http_core_module.c,ngx_http_core_find_static_location,,false,1453,1530,ngx_http_core_find_static_location,,,74,"ngx_int_t ngx_http_core_find_static_location (ngx_http_request_t*,ngx_http_location_tree_node_t*)"
261674,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"void *
ngx_http_test_content_type(ngx_http_request_t *r, ngx_hash_t *types_hash)
{
    u_char      c, *lowcase;
    size_t      len;
    ngx_uint_t  i, hash;

    if (types_hash->size == 0) {
        return (void *) 4;
    }

    if (r->headers_out.content_type.len == 0) {
        return NULL;
    }

    len = r->headers_out.content_type_len;

    if (r->headers_out.content_type_lowcase == NULL) {

        lowcase = ngx_pnalloc(r->pool, len);
        if (lowcase == NULL) {
            return NULL;
        }

        r->headers_out.content_type_lowcase = lowcase;

        hash = 0;

        for (i = 0; i < len; i++) {
            c = ngx_tolower(r->headers_out.content_type.data[i]);
            hash = ngx_hash(hash, c);
            lowcase[i] = c;
        }

        r->headers_out.content_type_hash = hash;
    }

    return ngx_hash_find(types_hash, r->headers_out.content_type_hash,
                         r->headers_out.content_type_lowcase, len);
}",1,1,http\ngx_http_core_module.c,ngx_http_test_content_type,,false,1533,1572,ngx_http_test_content_type,,,75,"void* ngx_http_test_content_type (ngx_http_request_t*,ngx_hash_t*)"
261803,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_set_content_type(ngx_http_request_t *r)
{
    u_char                     c, *exten;
    ngx_str_t                 *type;
    ngx_uint_t                 i, hash;
    ngx_http_core_loc_conf_t  *clcf;

    if (r->headers_out.content_type.len) {
        return NGX_OK;
    }

    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    if (r->exten.len) {

        hash = 0;

        for (i = 0; i < r->exten.len; i++) {
            c = r->exten.data[i];

            if (c >= 'A' && c <= 'Z') {

                exten = ngx_pnalloc(r->pool, r->exten.len);
                if (exten == NULL) {
                    return NGX_ERROR;
                }

                hash = ngx_hash_strlow(exten, r->exten.data, r->exten.len);

                r->exten.data = exten;

                break;
            }

            hash = ngx_hash(hash, c);
        }

        type = ngx_hash_find(&clcf->types_hash, hash,
                             r->exten.data, r->exten.len);

  ...",1,1,http\ngx_http_core_module.c,ngx_http_set_content_type,,false,1575,1628,ngx_http_set_content_type,,,76,ngx_int_t ngx_http_set_content_type (ngx_http_request_t*)
261980,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"void
ngx_http_set_exten(ngx_http_request_t *r)
{
    ngx_int_t  i;

    ngx_str_null(&r->exten);

    for (i = r->uri.len - 1; i > 1; i--) {
        if (r->uri.data[i] == '.' && r->uri.data[i - 1] != '/') {

            r->exten.len = r->uri.len - i - 1;
            r->exten.data = &r->uri.data[i + 1];

            return;

        } else if (r->uri.data[i] == '/') {
            return;
        }
    }

    return;
}",1,1,http\ngx_http_core_module.c,ngx_http_set_exten,,false,1631,1652,ngx_http_set_exten,,,77,void ngx_http_set_exten (ngx_http_request_t*)
262078,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_set_etag(ngx_http_request_t *r)
{
    ngx_table_elt_t           *etag;
    ngx_http_core_loc_conf_t  *clcf;

    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    if (!clcf->etag) {
        return NGX_OK;
    }

    etag = ngx_list_push(&r->headers_out.headers);
    if (etag == NULL) {
        return NGX_ERROR;
    }

    etag->hash = 1;
    ngx_str_set(&etag->key, ""ETag"");

    etag->value.data = ngx_pnalloc(r->pool, NGX_OFF_T_LEN + NGX_TIME_T_LEN + 3);
    if (etag->value.data == NULL) {
        etag->hash = 0;
        return NGX_ERROR;
    }

    etag->value.len = ngx_sprintf(etag->value.data, ""\""%xT-%xO\"""",
                                  r->headers_out.last_modified_time,
                                  r->headers_out.content_length_n)
                      - etag->value.data;

    r->headers_out.etag = etag;

    return NGX_OK;
}",1,1,http\ngx_http_core_module.c,ngx_http_set_etag,,false,1655,1689,ngx_http_set_etag,,,78,ngx_int_t ngx_http_set_etag (ngx_http_request_t*)
262194,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"void
ngx_http_weak_etag(ngx_http_request_t *r)
{
    size_t            len;
    u_char           *p;
    ngx_table_elt_t  *etag;

    etag = r->headers_out.etag;

    if (etag == NULL) {
        return;
    }

    if (etag->value.len > 2
        && etag->value.data[0] == 'W'
        && etag->value.data[1] == '/')
    {
        return;
    }

    if (etag->value.len < 1 || etag->value.data[0] != '""') {
        r->headers_out.etag->hash = 0;
        r->headers_out.etag = NULL;
        return;
    }

    p = ngx_pnalloc(r->pool, etag->value.len + 2);
    if (p == NULL) {
        r->headers_out.etag->hash = 0;
        r->headers_out.etag = NULL;
        return;
    }

    len = ngx_sprintf(p, ""W/%V"", &etag->value) - p;

    etag->value.data = p;
    etag->value.len = len;
}",1,1,http\ngx_http_core_module.c,ngx_http_weak_etag,,false,1692,1729,ngx_http_weak_etag,,,79,void ngx_http_weak_etag (ngx_http_request_t*)
262341,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_send_response(ngx_http_request_t *r, ngx_uint_t status,
    ngx_str_t *ct, ngx_http_complex_value_t *cv)
{
    ngx_int_t     rc;
    ngx_str_t     val;
    ngx_buf_t    *b;
    ngx_chain_t   out;

    rc = ngx_http_discard_request_body(r);

    if (rc != NGX_OK) {
        return rc;
    }

    r->headers_out.status = status;

    if (ngx_http_complex_value(r, cv, &val) != NGX_OK) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    if (status == NGX_HTTP_MOVED_PERMANENTLY
        || status == NGX_HTTP_MOVED_TEMPORARILY
        || status == NGX_HTTP_SEE_OTHER
        || status == NGX_HTTP_TEMPORARY_REDIRECT
        || status == NGX_HTTP_PERMANENT_REDIRECT)
    {
        ngx_http_clear_location(r);

        r->headers_out.location = ngx_list_push(&r->headers_out.headers);
        if (r->headers_out.location == NULL) {
            return NGX_HTTP_INTERNAL_SERVER_ERROR;
        }

        r->headers_out.location->hash = 1;
        ngx_str_set(&r->headers_out.lo...",1,1,http\ngx_http_core_module.c,ngx_http_send_response,,false,1732,1810,ngx_http_send_response,,,80,"ngx_int_t ngx_http_send_response (ngx_http_request_t*,ngx_uint_t,ngx_str_t*,ngx_http_complex_value_t*)"
262612,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_send_header(ngx_http_request_t *r)
{
    if (r->post_action) {
        return NGX_OK;
    }

    if (r->header_sent) {
        ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,
                      ""header already sent"");
        return NGX_ERROR;
    }

    if (r->err_status) {
        r->headers_out.status = r->err_status;
        r->headers_out.status_line.len = 0;
    }

    return ngx_http_top_header_filter(r);
}",1,1,http\ngx_http_core_module.c,ngx_http_send_header,,false,1813,1832,ngx_http_send_header,,,81,ngx_int_t ngx_http_send_header (ngx_http_request_t*)
262666,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_output_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    ngx_int_t          rc;
    ngx_connection_t  *c;

    c = r->connection;

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, c->log, 0,
                   ""http output filter \""%V?%V\"""", &r->uri, &r->args);

    rc = ngx_http_top_body_filter(r, in);

    if (rc == NGX_ERROR) {
        /* NGX_ERROR may be returned by any filter */
        c->error = 1;
    }

    return rc;
}",1,1,http\ngx_http_core_module.c,ngx_http_output_filter,,false,1835,1854,ngx_http_output_filter,,,82,"ngx_int_t ngx_http_output_filter (ngx_http_request_t*,ngx_chain_t*)"
262711,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"u_char *
ngx_http_map_uri_to_path(ngx_http_request_t *r, ngx_str_t *path,
    size_t *root_length, size_t reserved)
{
    u_char                    *last;
    size_t                     alias;
    ngx_http_core_loc_conf_t  *clcf;

    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    alias = clcf->alias;

    if (alias && !r->valid_location) {
        ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,
                      ""\""alias\"" cannot be used in location \""%V\"" ""
                      ""where URI was rewritten"", &clcf->name);
        return NULL;
    }

    if (clcf->root_lengths == NULL) {

        *root_length = clcf->root.len;

        path->len = clcf->root.len + reserved + r->uri.len - alias + 1;

        path->data = ngx_pnalloc(r->pool, path->len);
        if (path->data == NULL) {
            return NULL;
        }

        last = ngx_copy(path->data, clcf->root.data, clcf->root.len);

    } else {

        if (alias == NGX_MAX_SIZE_T_VALUE) {
        ...",1,1,http\ngx_http_core_module.c,ngx_http_map_uri_to_path,,false,1857,1928,ngx_http_map_uri_to_path,,,83,"u_char ngx_http_map_uri_to_path (ngx_http_request_t*,ngx_str_t*,size_t*,size_t)"
262958,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_auth_basic_user(ngx_http_request_t *r)
{
    ngx_str_t   auth, encoded;
    ngx_uint_t  len;

    if (r->headers_in.user.len == 0 && r->headers_in.user.data != NULL) {
        return NGX_DECLINED;
    }

    if (r->headers_in.authorization == NULL) {
        r->headers_in.user.data = (u_char *) """";
        return NGX_DECLINED;
    }

    encoded = r->headers_in.authorization->value;

    if (encoded.len < sizeof(""Basic "") - 1
        || ngx_strncasecmp(encoded.data, (u_char *) ""Basic "",
                           sizeof(""Basic "") - 1)
           != 0)
    {
        r->headers_in.user.data = (u_char *) """";
        return NGX_DECLINED;
    }

    encoded.len -= sizeof(""Basic "") - 1;
    encoded.data += sizeof(""Basic "") - 1;

    while (encoded.len && encoded.data[0] == ' ') {
        encoded.len--;
        encoded.data++;
    }

    if (encoded.len == 0) {
        r->headers_in.user.data = (u_char *) """";
        return NGX_DECLINED;
    }

    auth.len = ngx_base64_...",1,1,http\ngx_http_core_module.c,ngx_http_auth_basic_user,,false,1931,2000,ngx_http_auth_basic_user,,,84,ngx_int_t ngx_http_auth_basic_user (ngx_http_request_t*)
263275,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_subrequest(ngx_http_request_t *r,
    ngx_str_t *uri, ngx_str_t *args, ngx_http_request_t **psr,
    ngx_http_post_subrequest_t *ps, ngx_uint_t flags)
{
    ngx_time_t                    *tp;
    ngx_connection_t              *c;
    ngx_http_request_t            *sr;
    ngx_http_core_srv_conf_t      *cscf;
    ngx_http_postponed_request_t  *pr, *p;

    if (r->subrequests == 0) {
        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                      ""subrequests cycle while processing \""%V\"""", uri);
        return NGX_ERROR;
    }

    /*
     * 1000 is reserved for other purposes.
     */
    if (r->main->count >= 65535 - 1000) {
        ngx_log_error(NGX_LOG_CRIT, r->connection->log, 0,
                      ""request reference counter overflow ""
                      ""while processing \""%V\"""", uri);
        return NGX_ERROR;
    }

    if (r->subrequest_in_memory) {
        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                      ""neste...",1,1,http\ngx_http_core_module.c,ngx_http_subrequest,,false,2297,2478,ngx_http_subrequest,,,85,"ngx_int_t ngx_http_subrequest (ngx_http_request_t*,ngx_str_t*,ngx_str_t*,ngx_http_request_t**,ngx_http_post_subrequest_t*,ngx_uint_t)"
263869,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_internal_redirect(ngx_http_request_t *r,
    ngx_str_t *uri, ngx_str_t *args)
{
    ngx_http_core_srv_conf_t  *cscf;

    r->uri_changes--;

    if (r->uri_changes == 0) {
        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                      ""rewrite or internal redirection cycle ""
                      ""while internally redirecting to \""%V\"""", uri);

        r->main->count++;
        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
        return NGX_DONE;
    }

    r->uri = *uri;

    if (args) {
        r->args = *args;

    } else {
        ngx_str_null(&r->args);
    }

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""internal redirect: \""%V?%V\"""", uri, &r->args);

    ngx_http_set_exten(r);

    /* clear the modules contexts */
    ngx_memzero(r->ctx, sizeof(void *) * ngx_http_max_module);

    cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);
    r->loc_conf = cscf->ctx->loc_conf;

    ngx...",1,1,http\ngx_http_core_module.c,ngx_http_internal_redirect,,false,2481,2533,ngx_http_internal_redirect,,,86,"ngx_int_t ngx_http_internal_redirect (ngx_http_request_t*,ngx_str_t*,ngx_str_t*)"
263996,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_named_location(ngx_http_request_t *r, ngx_str_t *name)
{
    ngx_http_core_srv_conf_t    *cscf;
    ngx_http_core_loc_conf_t   **clcfp;
    ngx_http_core_main_conf_t   *cmcf;

    r->main->count++;
    r->uri_changes--;

    if (r->uri_changes == 0) {
        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                      ""rewrite or internal redirection cycle ""
                      ""while redirect to named location \""%V\"""", name);

        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
        return NGX_DONE;
    }

    if (r->uri.len == 0) {
        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                      ""empty URI in redirect to named location \""%V\"""", name);

        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
        return NGX_DONE;
    }

    cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);

    if (cscf->named_locations) {

        for (clcfp = cscf->named_locations; *clcfp; clcfp++) {...",1,1,http\ngx_http_core_module.c,ngx_http_named_location,,false,2536,2609,ngx_http_named_location,,,87,"ngx_int_t ngx_http_named_location (ngx_http_request_t*,ngx_str_t*)"
264215,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"ngx_http_cleanup_t *
ngx_http_cleanup_add(ngx_http_request_t *r, size_t size)
{
    ngx_http_cleanup_t  *cln;

    r = r->main;

    cln = ngx_palloc(r->pool, sizeof(ngx_http_cleanup_t));
    if (cln == NULL) {
        return NULL;
    }

    if (size) {
        cln->data = ngx_palloc(r->pool, size);
        if (cln->data == NULL) {
            return NULL;
        }

    } else {
        cln->data = NULL;
    }

    cln->handler = NULL;
    cln->next = r->cleanup;

    r->cleanup = cln;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http cleanup add: %p"", cln);

    return cln;
}",1,1,http\ngx_http_core_module.c,ngx_http_cleanup_add,,false,2612,2643,ngx_http_cleanup_add,,,88,"ngx_http_cleanup_t ngx_http_cleanup_add (ngx_http_request_t*,size_t)"
264299,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_set_disable_symlinks(ngx_http_request_t *r,
    ngx_http_core_loc_conf_t *clcf, ngx_str_t *path, ngx_open_file_info_t *of)
{
#if (NGX_HAVE_OPENAT)
    u_char     *p;
    ngx_str_t   from;

    of->disable_symlinks = clcf->disable_symlinks;

    if (clcf->disable_symlinks_from == NULL) {
        return NGX_OK;
    }

    if (ngx_http_complex_value(r, clcf->disable_symlinks_from, &from)
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    if (from.len == 0
        || from.len > path->len
        || ngx_memcmp(path->data, from.data, from.len) != 0)
    {
        return NGX_OK;
    }

    if (from.len == path->len) {
        of->disable_symlinks = NGX_DISABLE_SYMLINKS_OFF;
        return NGX_OK;
    }

    p = path->data + from.len;

    if (*p == '/') {
        of->disable_symlinks_from = from.len;
        return NGX_OK;
    }

    p--;

    if (*p == '/') {
        of->disable_symlinks_from = from.len - 1;
    }
#endif

    return NGX_OK;
}",1,1,http\ngx_http_core_module.c,ngx_http_set_disable_symlinks,,false,2646,2693,ngx_http_set_disable_symlinks,,,89,"ngx_int_t ngx_http_set_disable_symlinks (ngx_http_request_t*,ngx_http_core_loc_conf_t*,ngx_str_t*,ngx_open_file_info_t*)"
264309,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_get_forwarded_addr(ngx_http_request_t *r, ngx_addr_t *addr,
    ngx_array_t *headers, ngx_str_t *value, ngx_array_t *proxies,
    int recursive)
{
    ngx_int_t          rc;
    ngx_uint_t         i, found;
    ngx_table_elt_t  **h;

    if (headers == NULL) {
        return ngx_http_get_forwarded_addr_internal(r, addr, value->data,
                                                    value->len, proxies,
                                                    recursive);
    }

    i = headers->nelts;
    h = headers->elts;

    rc = NGX_DECLINED;

    found = 0;

    while (i-- > 0) {
        rc = ngx_http_get_forwarded_addr_internal(r, addr, h[i]->value.data,
                                                  h[i]->value.len, proxies,
                                                  recursive);

        if (!recursive) {
            break;
        }

        if (rc == NGX_DECLINED && found) {
            rc = NGX_DONE;
            break;
        }

        if (rc !=...",1,1,http\ngx_http_core_module.c,ngx_http_get_forwarded_addr,,false,2696,2740,ngx_http_get_forwarded_addr,,,90,"ngx_int_t ngx_http_get_forwarded_addr (ngx_http_request_t*,ngx_addr_t*,ngx_array_t*,ngx_str_t*,ngx_array_t*,int)"
264410,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_get_forwarded_addr_internal(ngx_http_request_t *r, ngx_addr_t *addr,
    u_char *xff, size_t xfflen, ngx_array_t *proxies, int recursive)
{
    u_char      *p;
    ngx_addr_t   paddr;
    ngx_uint_t   found;

    found = 0;

    do {

        if (ngx_cidr_match(addr->sockaddr, proxies) != NGX_OK) {
            return found ? NGX_DONE : NGX_DECLINED;
        }

        for (p = xff + xfflen - 1; p > xff; p--, xfflen--) {
            if (*p != ' ' && *p != ',') {
                break;
            }
        }

        for ( /* void */ ; p > xff; p--) {
            if (*p == ' ' || *p == ',') {
                p++;
                break;
            }
        }

        if (ngx_parse_addr_port(r->pool, &paddr, p, xfflen - (p - xff))
            != NGX_OK)
        {
            return found ? NGX_DONE : NGX_DECLINED;
        }

        *addr = paddr;
        found = 1;
        xfflen = p - 1 - xff;

    } while (recursive && p > xff);

    return NGX_OK;
}",1,1,http\ngx_http_core_module.c,ngx_http_get_forwarded_addr_internal,,false,2743,2785,ngx_http_get_forwarded_addr_internal,,,91,"ngx_int_t ngx_http_get_forwarded_addr_internal (ngx_http_request_t*,ngx_addr_t*,u_char*,size_t,ngx_array_t*,int)"
264536,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *
ngx_http_core_server(ngx_conf_t *cf, ngx_command_t *cmd, void *dummy)
{
    char                        *rv;
    void                        *mconf;
    size_t                       len;
    u_char                      *p;
    ngx_uint_t                   i;
    ngx_conf_t                   pcf;
    ngx_http_module_t           *module;
    struct sockaddr_in          *sin;
    ngx_http_conf_ctx_t         *ctx, *http_ctx;
    ngx_http_listen_opt_t        lsopt;
    ngx_http_core_srv_conf_t    *cscf, **cscfp;
    ngx_http_core_main_conf_t   *cmcf;

    ctx = ngx_pcalloc(cf->pool, sizeof(ngx_http_conf_ctx_t));
    if (ctx == NULL) {
        return NGX_CONF_ERROR;
    }

    http_ctx = cf->ctx;
    ctx->main_conf = http_ctx->main_conf;

    /* the server{}'s srv_conf */

    ctx->srv_conf = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_http_max_module);
    if (ctx->srv_conf == NULL) {
        return NGX_CONF_ERROR;
    }

    /* the server{}'s loc_conf */

    ctx->loc_conf ...",1,1,http\ngx_http_core_module.c,ngx_http_core_server,,false,2788,2929,ngx_http_core_server,,,92,"char* ngx_http_core_server (ngx_conf_t*,ngx_command_t*,void*)"
264949,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *
ngx_http_core_location(ngx_conf_t *cf, ngx_command_t *cmd, void *dummy)
{
    char                      *rv;
    u_char                    *mod;
    size_t                     len;
    ngx_str_t                 *value, *name;
    ngx_uint_t                 i;
    ngx_conf_t                 save;
    ngx_http_module_t         *module;
    ngx_http_conf_ctx_t       *ctx, *pctx;
    ngx_http_core_loc_conf_t  *clcf, *pclcf;

    ctx = ngx_pcalloc(cf->pool, sizeof(ngx_http_conf_ctx_t));
    if (ctx == NULL) {
        return NGX_CONF_ERROR;
    }

    pctx = cf->ctx;
    ctx->main_conf = pctx->main_conf;
    ctx->srv_conf = pctx->srv_conf;

    ctx->loc_conf = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_http_max_module);
    if (ctx->loc_conf == NULL) {
        return NGX_CONF_ERROR;
    }

    for (i = 0; cf->cycle->modules[i]; i++) {
        if (cf->cycle->modules[i]->type != NGX_HTTP_MODULE) {
            continue;
        }

        module = cf->cycle->modules[i]->ctx;

 ...",1,1,http\ngx_http_core_module.c,ngx_http_core_location,,false,2932,3123,ngx_http_core_location,,,93,"char* ngx_http_core_location (ngx_conf_t*,ngx_command_t*,void*)"
265597,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_core_regex_location(ngx_conf_t *cf, ngx_http_core_loc_conf_t *clcf,
    ngx_str_t *regex, ngx_uint_t caseless)
{
#if (NGX_PCRE)
    ngx_regex_compile_t  rc;
    u_char               errstr[NGX_MAX_CONF_ERRSTR];

    ngx_memzero(&rc, sizeof(ngx_regex_compile_t));

    rc.pattern = *regex;
    rc.err.len = NGX_MAX_CONF_ERRSTR;
    rc.err.data = errstr;

#if (NGX_HAVE_CASELESS_FILESYSTEM)
    rc.options = NGX_REGEX_CASELESS;
#else
    rc.options = caseless ? NGX_REGEX_CASELESS : 0;
#endif

    clcf->regex = ngx_http_regex_compile(cf, &rc);
    if (clcf->regex == NULL) {
        return NGX_ERROR;
    }

    clcf->name = *regex;

    return NGX_OK;

#else

    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                       ""using regex \""%V\"" requires PCRE library"",
                       regex);
    return NGX_ERROR;

#endif
}",1,1,http\ngx_http_core_module.c,ngx_http_core_regex_location,,false,3126,3163,ngx_http_core_regex_location,,,94,"ngx_int_t ngx_http_core_regex_location (ngx_conf_t*,ngx_http_core_loc_conf_t*,ngx_str_t*,ngx_uint_t)"
265613,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *
ngx_http_core_types(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_core_loc_conf_t *clcf = conf;

    char        *rv;
    ngx_conf_t   save;

    if (clcf->types == NULL) {
        clcf->types = ngx_array_create(cf->pool, 64, sizeof(ngx_hash_key_t));
        if (clcf->types == NULL) {
            return NGX_CONF_ERROR;
        }
    }

    save = *cf;
    cf->handler = ngx_http_core_type;
    cf->handler_conf = conf;

    rv = ngx_conf_parse(cf, NULL);

    *cf = save;

    return rv;
}",1,1,http\ngx_http_core_module.c,ngx_http_core_types,,false,3166,3190,ngx_http_core_types,,,95,"char* ngx_http_core_types (ngx_conf_t*,ngx_command_t*,void*)"
265678,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *
ngx_http_core_type(ngx_conf_t *cf, ngx_command_t *dummy, void *conf)
{
    ngx_http_core_loc_conf_t *clcf = conf;

    ngx_str_t       *value, *content_type, *old;
    ngx_uint_t       i, n, hash;
    ngx_hash_key_t  *type;

    value = cf->args->elts;

    if (ngx_strcmp(value[0].data, ""include"") == 0) {
        if (cf->args->nelts != 2) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               ""invalid number of arguments""
                               "" in \""include\"" directive"");
            return NGX_CONF_ERROR;
        }

        return ngx_conf_include(cf, dummy, conf);
    }

    content_type = ngx_palloc(cf->pool, sizeof(ngx_str_t));
    if (content_type == NULL) {
        return NGX_CONF_ERROR;
    }

    *content_type = value[0];

    for (i = 1; i < cf->args->nelts; i++) {

        hash = ngx_hash_strlow(value[i].data, value[i].data, value[i].len);

        type = clcf->types->elts;
        for (n = 0; n < clcf->types->nelts; n...",1,1,http\ngx_http_core_module.c,ngx_http_core_type,,false,3193,3256,ngx_http_core_type,,,96,"char* ngx_http_core_type (ngx_conf_t*,ngx_command_t*,void*)"
265888,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_core_preconfiguration(ngx_conf_t *cf)
{
    return ngx_http_variables_add_core_vars(cf);
}",1,1,http\ngx_http_core_module.c,ngx_http_core_preconfiguration,,false,3259,3263,ngx_http_core_preconfiguration,,,97,ngx_int_t ngx_http_core_preconfiguration (ngx_conf_t*)
265896,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_core_postconfiguration(ngx_conf_t *cf)
{
    ngx_http_top_request_body_filter = ngx_http_request_body_save_filter;

    return NGX_OK;
}",1,1,http\ngx_http_core_module.c,ngx_http_core_postconfiguration,,false,3266,3272,ngx_http_core_postconfiguration,,,98,ngx_int_t ngx_http_core_postconfiguration (ngx_conf_t*)
265906,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static void *
ngx_http_core_create_main_conf(ngx_conf_t *cf)
{
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_pcalloc(cf->pool, sizeof(ngx_http_core_main_conf_t));
    if (cmcf == NULL) {
        return NULL;
    }

    if (ngx_array_init(&cmcf->servers, cf->pool, 4,
                       sizeof(ngx_http_core_srv_conf_t *))
        != NGX_OK)
    {
        return NULL;
    }

    cmcf->server_names_hash_max_size = NGX_CONF_UNSET_UINT;
    cmcf->server_names_hash_bucket_size = NGX_CONF_UNSET_UINT;

    cmcf->variables_hash_max_size = NGX_CONF_UNSET_UINT;
    cmcf->variables_hash_bucket_size = NGX_CONF_UNSET_UINT;

    return cmcf;
}",1,1,http\ngx_http_core_module.c,ngx_http_core_create_main_conf,,false,3275,3299,ngx_http_core_create_main_conf,,,99,void* ngx_http_core_create_main_conf (ngx_conf_t*)
265966,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *
ngx_http_core_init_main_conf(ngx_conf_t *cf, void *conf)
{
    ngx_http_core_main_conf_t *cmcf = conf;

    ngx_conf_init_uint_value(cmcf->server_names_hash_max_size, 512);
    ngx_conf_init_uint_value(cmcf->server_names_hash_bucket_size,
                             ngx_cacheline_size);

    cmcf->server_names_hash_bucket_size =
            ngx_align(cmcf->server_names_hash_bucket_size, ngx_cacheline_size);


    ngx_conf_init_uint_value(cmcf->variables_hash_max_size, 1024);
    ngx_conf_init_uint_value(cmcf->variables_hash_bucket_size, 64);

    cmcf->variables_hash_bucket_size =
               ngx_align(cmcf->variables_hash_bucket_size, ngx_cacheline_size);

    if (cmcf->ncaptures) {
        cmcf->ncaptures = (cmcf->ncaptures + 1) * 3;
    }

    return NGX_CONF_OK;
}",1,1,http\ngx_http_core_module.c,ngx_http_core_init_main_conf,,false,3302,3326,ngx_http_core_init_main_conf,,,100,"char* ngx_http_core_init_main_conf (ngx_conf_t*,void*)"
266032,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static void *
ngx_http_core_create_srv_conf(ngx_conf_t *cf)
{
    ngx_http_core_srv_conf_t  *cscf;

    cscf = ngx_pcalloc(cf->pool, sizeof(ngx_http_core_srv_conf_t));
    if (cscf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     conf->client_large_buffers.num = 0;
     */

    if (ngx_array_init(&cscf->server_names, cf->temp_pool, 4,
                       sizeof(ngx_http_server_name_t))
        != NGX_OK)
    {
        return NULL;
    }

    cscf->connection_pool_size = NGX_CONF_UNSET_SIZE;
    cscf->request_pool_size = NGX_CONF_UNSET_SIZE;
    cscf->client_header_timeout = NGX_CONF_UNSET_MSEC;
    cscf->client_header_buffer_size = NGX_CONF_UNSET_SIZE;
    cscf->ignore_invalid_headers = NGX_CONF_UNSET;
    cscf->merge_slashes = NGX_CONF_UNSET;
    cscf->underscores_in_headers = NGX_CONF_UNSET;

    cscf->file_name = cf->conf_file->file.name.data;
    cscf->line = cf->conf_file->line;

    return cscf;
}",1,1,http\ngx_http_core_module.c,ngx_http_core_create_srv_conf,,false,3329,3364,ngx_http_core_create_srv_conf,,,101,void* ngx_http_core_create_srv_conf (ngx_conf_t*)
266129,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *
ngx_http_core_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_core_srv_conf_t *prev = parent;
    ngx_http_core_srv_conf_t *conf = child;

    ngx_str_t                name;
    ngx_http_server_name_t  *sn;

    /* TODO: it does not merge, it inits only */

    ngx_conf_merge_size_value(conf->connection_pool_size,
                              prev->connection_pool_size, 64 * sizeof(void *));
    ngx_conf_merge_size_value(conf->request_pool_size,
                              prev->request_pool_size, 4096);
    ngx_conf_merge_msec_value(conf->client_header_timeout,
                              prev->client_header_timeout, 60000);
    ngx_conf_merge_size_value(conf->client_header_buffer_size,
                              prev->client_header_buffer_size, 1024);
    ngx_conf_merge_bufs_value(conf->large_client_header_buffers,
                              prev->large_client_header_buffers,
                              4, 8192);

    if (conf->l...",1,1,http\ngx_http_core_module.c,ngx_http_core_merge_srv_conf,,false,3367,3437,ngx_http_core_merge_srv_conf,,,102,"char* ngx_http_core_merge_srv_conf (ngx_conf_t*,void*,void*)"
266324,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static void *
ngx_http_core_create_loc_conf(ngx_conf_t *cf)
{
    ngx_http_core_loc_conf_t  *clcf;

    clcf = ngx_pcalloc(cf->pool, sizeof(ngx_http_core_loc_conf_t));
    if (clcf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     clcf->root = { 0, NULL };
     *     clcf->limit_except = 0;
     *     clcf->post_action = { 0, NULL };
     *     clcf->types = NULL;
     *     clcf->default_type = { 0, NULL };
     *     clcf->error_log = NULL;
     *     clcf->error_pages = NULL;
     *     clcf->client_body_path = NULL;
     *     clcf->regex = NULL;
     *     clcf->exact_match = 0;
     *     clcf->auto_redirect = 0;
     *     clcf->alias = 0;
     *     clcf->limit_rate = NULL;
     *     clcf->limit_rate_after = NULL;
     *     clcf->gzip_proxied = 0;
     *     clcf->keepalive_disable = 0;
     */

    clcf->client_max_body_size = NGX_CONF_UNSET;
    clcf->client_body_buffer_size = NGX_CONF_UNSET_SIZE;
    clcf->client_body_timeout =...",1,1,http\ngx_http_core_module.c,ngx_http_core_create_loc_conf,,false,3440,3544,ngx_http_core_create_loc_conf,,,103,void* ngx_http_core_create_loc_conf (ngx_conf_t*)
266633,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *
ngx_http_core_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_core_loc_conf_t *prev = parent;
    ngx_http_core_loc_conf_t *conf = child;

    ngx_uint_t        i;
    ngx_hash_key_t   *type;
    ngx_hash_init_t   types_hash;

    if (conf->root.data == NULL) {

        conf->alias = prev->alias;
        conf->root = prev->root;
        conf->root_lengths = prev->root_lengths;
        conf->root_values = prev->root_values;

        if (prev->root.data == NULL) {
            ngx_str_set(&conf->root, ""html"");

            if (ngx_conf_full_name(cf->cycle, &conf->root, 0) != NGX_OK) {
                return NGX_CONF_ERROR;
            }
        }
    }

    if (conf->post_action.data == NULL) {
        conf->post_action = prev->post_action;
    }

    ngx_conf_merge_uint_value(conf->types_hash_max_size,
                              prev->types_hash_max_size, 1024);

    ngx_conf_merge_uint_value(conf->types_hash_bucket_size,
                     ...",1,30,http\ngx_http_core_module.c,ngx_http_core_merge_loc_conf,,false,3559,3847,ngx_http_core_merge_loc_conf,,,112,"char* ngx_http_core_merge_loc_conf (ngx_conf_t*,void*,void*)"
267560,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *
ngx_http_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_core_srv_conf_t *cscf = conf;

    ngx_str_t              *value, size;
    ngx_url_t               u;
    ngx_uint_t              n;
    ngx_http_listen_opt_t   lsopt;

    cscf->listen = 1;

    value = cf->args->elts;

    ngx_memzero(&u, sizeof(ngx_url_t));

    u.url = value[1];
    u.listen = 1;
    u.default_port = 80;

    if (ngx_parse_url(cf->pool, &u) != NGX_OK) {
        if (u.err) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               ""%s in \""%V\"" of the \""listen\"" directive"",
                               u.err, &u.url);
        }

        return NGX_CONF_ERROR;
    }

    ngx_memzero(&lsopt, sizeof(ngx_http_listen_opt_t));

    lsopt.backlog = NGX_LISTEN_BACKLOG;
    lsopt.rcvbuf = -1;
    lsopt.sndbuf = -1;
#if (NGX_HAVE_SETFIB)
    lsopt.setfib = -1;
#endif
#if (NGX_HAVE_TCP_FASTOPEN)
    lsopt.fastopen = -1;
#endif
#if (NGX_HAVE_INET6)
...",1,1,http\ngx_http_core_module.c,ngx_http_core_listen,,false,3850,4202,ngx_http_core_listen,,,113,"char* ngx_http_core_listen (ngx_conf_t*,ngx_command_t*,void*)"
268226,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *
ngx_http_core_server_name(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_core_srv_conf_t *cscf = conf;

    u_char                   ch;
    ngx_str_t               *value;
    ngx_uint_t               i;
    ngx_http_server_name_t  *sn;

    value = cf->args->elts;

    for (i = 1; i < cf->args->nelts; i++) {

        ch = value[i].data[0];

        if ((ch == '*' && (value[i].len < 3 || value[i].data[1] != '.'))
            || (ch == '.' && value[i].len < 2))
        {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               ""server name \""%V\"" is invalid"", &value[i]);
            return NGX_CONF_ERROR;
        }

        if (ngx_strchr(value[i].data, '/')) {
            ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
                               ""server name \""%V\"" has suspicious symbols"",
                               &value[i]);
        }

        sn = ngx_array_push(&cscf->server_names);
        if (sn == NULL) {
            ...",1,1,http\ngx_http_core_module.c,ngx_http_core_server_name,,false,4205,4303,ngx_http_core_server_name,,,114,"char* ngx_http_core_server_name (ngx_conf_t*,ngx_command_t*,void*)"
268427,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *
ngx_http_core_root(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_core_loc_conf_t *clcf = conf;

    ngx_str_t                  *value;
    ngx_int_t                   alias;
    ngx_uint_t                  n;
    ngx_http_script_compile_t   sc;

    alias = (cmd->name.len == sizeof(""alias"") - 1) ? 1 : 0;

    if (clcf->root.data) {

        if ((clcf->alias != 0) == alias) {
            return ""is duplicate"";
        }

        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""\""%V\"" directive is duplicate, ""
                           ""\""%s\"" directive was specified earlier"",
                           &cmd->name, clcf->alias ? ""alias"" : ""root"");

        return NGX_CONF_ERROR;
    }

    if (clcf->named && alias) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""the \""alias\"" directive cannot be used ""
                           ""inside the named location"");

        return NGX_CONF_ERROR;
    }

    va...",1,1,http\ngx_http_core_module.c,ngx_http_core_root,,false,4306,4405,ngx_http_core_root,,,115,"char* ngx_http_core_root (ngx_conf_t*,ngx_command_t*,void*)"
268837,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *
ngx_http_core_limit_except(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_core_loc_conf_t *pclcf = conf;

    char                      *rv;
    void                      *mconf;
    ngx_str_t                 *value;
    ngx_uint_t                 i;
    ngx_conf_t                 save;
    ngx_http_module_t         *module;
    ngx_http_conf_ctx_t       *ctx, *pctx;
    ngx_http_method_name_t    *name;
    ngx_http_core_loc_conf_t  *clcf;

    if (pclcf->limit_except) {
        return ""is duplicate"";
    }

    pclcf->limit_except = 0xffffffff;

    value = cf->args->elts;

    for (i = 1; i < cf->args->nelts; i++) {
        for (name = ngx_methods_names; name->name; name++) {

            if (ngx_strcasecmp(value[i].data, name->name) == 0) {
                pclcf->limit_except &= name->method;
                goto next;
            }
        }

        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""invalid method \""%V\"""", &value[...",1,1,http\ngx_http_core_module.c,ngx_http_core_limit_except,,false,4427,4524,ngx_http_core_limit_except,,,118,"char* ngx_http_core_limit_except (ngx_conf_t*,ngx_command_t*,void*)"
269160,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *
ngx_http_core_set_aio(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_core_loc_conf_t *clcf = conf;

    ngx_str_t  *value;

    if (clcf->aio != NGX_CONF_UNSET) {
        return ""is duplicate"";
    }

#if (NGX_THREADS)
    clcf->thread_pool = NULL;
    clcf->thread_pool_value = NULL;
#endif

    value = cf->args->elts;

    if (ngx_strcmp(value[1].data, ""off"") == 0) {
        clcf->aio = NGX_HTTP_AIO_OFF;
        return NGX_CONF_OK;
    }

    if (ngx_strcmp(value[1].data, ""on"") == 0) {
#if (NGX_HAVE_FILE_AIO)
        clcf->aio = NGX_HTTP_AIO_ON;
        return NGX_CONF_OK;
#else
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""\""aio on\"" ""
                           ""is unsupported on this platform"");
        return NGX_CONF_ERROR;
#endif
    }

#if (NGX_HAVE_AIO_SENDFILE)

    if (ngx_strcmp(value[1].data, ""sendfile"") == 0) {
        clcf->aio = NGX_HTTP_AIO_ON;

        ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
             ...",1,1,http\ngx_http_core_module.c,ngx_http_core_set_aio,,false,4527,4634,ngx_http_core_set_aio,,,119,"char* ngx_http_core_set_aio (ngx_conf_t*,ngx_command_t*,void*)"
269263,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *
ngx_http_core_directio(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_core_loc_conf_t *clcf = conf;

    ngx_str_t  *value;

    if (clcf->directio != NGX_CONF_UNSET) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    if (ngx_strcmp(value[1].data, ""off"") == 0) {
        clcf->directio = NGX_OPEN_FILE_DIRECTIO_OFF;
        return NGX_CONF_OK;
    }

    clcf->directio = ngx_parse_offset(&value[1]);
    if (clcf->directio == (off_t) NGX_ERROR) {
        return ""invalid value"";
    }

    return NGX_CONF_OK;
}",1,1,http\ngx_http_core_module.c,ngx_http_core_directio,,false,4637,4661,ngx_http_core_directio,,,120,"char* ngx_http_core_directio (ngx_conf_t*,ngx_command_t*,void*)"
269331,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *
ngx_http_core_error_page(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_core_loc_conf_t *clcf = conf;

    u_char                            *p;
    ngx_int_t                          overwrite;
    ngx_str_t                         *value, uri, args;
    ngx_uint_t                         i, n;
    ngx_http_err_page_t               *err;
    ngx_http_complex_value_t           cv;
    ngx_http_compile_complex_value_t   ccv;

    if (clcf->error_pages == NULL) {
        clcf->error_pages = ngx_array_create(cf->pool, 4,
                                             sizeof(ngx_http_err_page_t));
        if (clcf->error_pages == NULL) {
            return NGX_CONF_ERROR;
        }
    }

    value = cf->args->elts;

    i = cf->args->nelts - 2;

    if (value[i].data[0] == '=') {
        if (i == 1) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               ""invalid value \""%V\"""", &value[i]);
            return NGX_CONF_ERROR;
    ...",1,1,http\ngx_http_core_module.c,ngx_http_core_error_page,,false,4664,4780,ngx_http_core_error_page,,,121,"char* ngx_http_core_error_page (ngx_conf_t*,ngx_command_t*,void*)"
269732,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *
ngx_http_core_open_file_cache(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_core_loc_conf_t *clcf = conf;

    time_t       inactive;
    ngx_str_t   *value, s;
    ngx_int_t    max;
    ngx_uint_t   i;

    if (clcf->open_file_cache != NGX_CONF_UNSET_PTR) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    max = 0;
    inactive = 60;

    for (i = 1; i < cf->args->nelts; i++) {

        if (ngx_strncmp(value[i].data, ""max="", 4) == 0) {

            max = ngx_atoi(value[i].data + 4, value[i].len - 4);
            if (max <= 0) {
                goto failed;
            }

            continue;
        }

        if (ngx_strncmp(value[i].data, ""inactive="", 9) == 0) {

            s.len = value[i].len - 9;
            s.data = value[i].data + 9;

            inactive = ngx_parse_time(&s, 1);
            if (inactive == (time_t) NGX_ERROR) {
                goto failed;
            }

            continue;
        }

        if (ngx_s...",1,1,http\ngx_http_core_module.c,ngx_http_core_open_file_cache,,false,4783,4858,ngx_http_core_open_file_cache,,,122,"char* ngx_http_core_open_file_cache (ngx_conf_t*,ngx_command_t*,void*)"
269939,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *
ngx_http_core_error_log(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_core_loc_conf_t *clcf = conf;

    return ngx_log_set_log(cf, &clcf->error_log);
}",1,1,http\ngx_http_core_module.c,ngx_http_core_error_log,,false,4861,4867,ngx_http_core_error_log,,,123,"char* ngx_http_core_error_log (ngx_conf_t*,ngx_command_t*,void*)"
269957,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *
ngx_http_core_keepalive(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_core_loc_conf_t *clcf = conf;

    ngx_str_t  *value;

    if (clcf->keepalive_timeout != NGX_CONF_UNSET_MSEC) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    clcf->keepalive_timeout = ngx_parse_time(&value[1], 0);

    if (clcf->keepalive_timeout == (ngx_msec_t) NGX_ERROR) {
        return ""invalid value"";
    }

    if (cf->args->nelts == 2) {
        return NGX_CONF_OK;
    }

    clcf->keepalive_header = ngx_parse_time(&value[2], 1);

    if (clcf->keepalive_header == (time_t) NGX_ERROR) {
        return ""invalid value"";
    }

    return NGX_CONF_OK;
}",1,1,http\ngx_http_core_module.c,ngx_http_core_keepalive,,false,4870,4900,ngx_http_core_keepalive,,,124,"char* ngx_http_core_keepalive (ngx_conf_t*,ngx_command_t*,void*)"
270040,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *
ngx_http_core_internal(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_core_loc_conf_t *clcf = conf;

    if (clcf->internal != NGX_CONF_UNSET) {
        return ""is duplicate"";
    }

    clcf->internal = 1;

    return NGX_CONF_OK;
}",1,1,http\ngx_http_core_module.c,ngx_http_core_internal,,false,4903,4915,ngx_http_core_internal,,,125,"char* ngx_http_core_internal (ngx_conf_t*,ngx_command_t*,void*)"
270067,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *
ngx_http_core_resolver(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_core_loc_conf_t  *clcf = conf;

    ngx_str_t  *value;

    if (clcf->resolver) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    clcf->resolver = ngx_resolver_create(cf, &value[1], cf->args->nelts - 1);
    if (clcf->resolver == NULL) {
        return NGX_CONF_ERROR;
    }

    return NGX_CONF_OK;
}",1,1,http\ngx_http_core_module.c,ngx_http_core_resolver,,false,4918,4937,ngx_http_core_resolver,,,126,"char* ngx_http_core_resolver (ngx_conf_t*,ngx_command_t*,void*)"
270121,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *
ngx_http_core_lowat_check(ngx_conf_t *cf, void *post, void *data)
{
#if (NGX_FREEBSD)
    ssize_t *np = data;

    if ((u_long) *np >= ngx_freebsd_net_inet_tcp_sendspace) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""\""send_lowat\"" must be less than %d ""
                           ""(sysctl net.inet.tcp.sendspace)"",
                           ngx_freebsd_net_inet_tcp_sendspace);

        return NGX_CONF_ERROR;
    }

#elif !(NGX_HAVE_SO_SNDLOWAT)
    ssize_t *np = data;

    ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
                       ""\""send_lowat\"" is not supported, ignored"");

    *np = 0;

#endif

    return NGX_CONF_OK;
}",1,1,http\ngx_http_core_module.c,ngx_http_core_lowat_check,,false,5136,5162,ngx_http_core_lowat_check,,,127,"char* ngx_http_core_lowat_check (ngx_conf_t*,void*,void*)"
270143,METHOD,http\ngx_http_core_module.c:<global>,TYPE_DECL,"static char *
ngx_http_core_pool_size(ngx_conf_t *cf, void *post, void *data)
{
    size_t *sp = data;

    if (*sp < NGX_MIN_POOL_SIZE) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""the pool size must be no less than %uz"",
                           NGX_MIN_POOL_SIZE);
        return NGX_CONF_ERROR;
    }

    if (*sp % NGX_POOL_ALIGNMENT) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""the pool size must be a multiple of %uz"",
                           NGX_POOL_ALIGNMENT);
        return NGX_CONF_ERROR;
    }

    return NGX_CONF_OK;
}",1,1,http\ngx_http_core_module.c,ngx_http_core_pool_size,,false,5165,5185,ngx_http_core_pool_size,,,128,"char* ngx_http_core_pool_size (ngx_conf_t*,void*,void*)"
270195,METHOD,http\ngx_http_core_module.h:<global>,TYPE_DECL,<global>,1,39,http\ngx_http_core_module.h,http\ngx_http_core_module.h:<global>,,false,1,580,<global>,,,1,
270239,METHOD,<empty>,<empty>,<empty>,1,,http\ngx_http_core_module.h,ngx_http_phases:<clinit>,,false,107,,<clinit>,,,12,
270249,METHOD,http\ngx_http_core_module.h:<global>,TYPE_DECL,"typedef ngx_int_t (*ngx_http_phase_handler_pt)(ngx_http_request_t *r,
    ngx_http_phase_handler_t *ph);",19,33,http\ngx_http_core_module.h,ngx_http_phase_handler_pt,,false,130,131,ngx_http_phase_handler_pt,,,11,"ngx_int_t ngx_http_phase_handler_pt (ngx_http_request_t*,ngx_http_phase_handler_t*)"
270282,METHOD,<empty>,<empty>,<empty>,1,,http\ngx_http_core_module.h,ngx_http_core_main_conf_t:<clinit>,,false,152,,<clinit>,,,15,
270463,METHOD,<empty>,<empty>,<empty>,1,,http\ngx_http_core_module.h,ngx_http_location_tree_node_s:<clinit>,,false,456,,<clinit>,,,9,
270469,METHOD,http\ngx_http_core_module.h:<global>,TYPE_DECL,void ngx_http_core_run_phases(ngx_http_request_t *r);,6,52,http\ngx_http_core_module.h,ngx_http_core_run_phases,,false,470,470,ngx_http_core_run_phases,,,40,void ngx_http_core_run_phases (ngx_http_request_t*)
270474,METHOD,http\ngx_http_core_module.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_core_generic_phase(ngx_http_request_t *r,
    ngx_http_phase_handler_t *ph);",11,33,http\ngx_http_core_module.h,ngx_http_core_generic_phase,,false,471,472,ngx_http_core_generic_phase,,,41,"ngx_int_t ngx_http_core_generic_phase (ngx_http_request_t*,ngx_http_phase_handler_t*)"
270480,METHOD,http\ngx_http_core_module.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_core_rewrite_phase(ngx_http_request_t *r,
    ngx_http_phase_handler_t *ph);",11,33,http\ngx_http_core_module.h,ngx_http_core_rewrite_phase,,false,473,474,ngx_http_core_rewrite_phase,,,42,"ngx_int_t ngx_http_core_rewrite_phase (ngx_http_request_t*,ngx_http_phase_handler_t*)"
270486,METHOD,http\ngx_http_core_module.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_core_find_config_phase(ngx_http_request_t *r,
    ngx_http_phase_handler_t *ph);",11,33,http\ngx_http_core_module.h,ngx_http_core_find_config_phase,,false,475,476,ngx_http_core_find_config_phase,,,43,"ngx_int_t ngx_http_core_find_config_phase (ngx_http_request_t*,ngx_http_phase_handler_t*)"
270492,METHOD,http\ngx_http_core_module.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_core_post_rewrite_phase(ngx_http_request_t *r,
    ngx_http_phase_handler_t *ph);",11,33,http\ngx_http_core_module.h,ngx_http_core_post_rewrite_phase,,false,477,478,ngx_http_core_post_rewrite_phase,,,44,"ngx_int_t ngx_http_core_post_rewrite_phase (ngx_http_request_t*,ngx_http_phase_handler_t*)"
270498,METHOD,http\ngx_http_core_module.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_core_access_phase(ngx_http_request_t *r,
    ngx_http_phase_handler_t *ph);",11,33,http\ngx_http_core_module.h,ngx_http_core_access_phase,,false,479,480,ngx_http_core_access_phase,,,45,"ngx_int_t ngx_http_core_access_phase (ngx_http_request_t*,ngx_http_phase_handler_t*)"
270504,METHOD,http\ngx_http_core_module.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_core_post_access_phase(ngx_http_request_t *r,
    ngx_http_phase_handler_t *ph);",11,33,http\ngx_http_core_module.h,ngx_http_core_post_access_phase,,false,481,482,ngx_http_core_post_access_phase,,,46,"ngx_int_t ngx_http_core_post_access_phase (ngx_http_request_t*,ngx_http_phase_handler_t*)"
270510,METHOD,http\ngx_http_core_module.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_core_content_phase(ngx_http_request_t *r,
    ngx_http_phase_handler_t *ph);",11,33,http\ngx_http_core_module.h,ngx_http_core_content_phase,,false,483,484,ngx_http_core_content_phase,,,47,"ngx_int_t ngx_http_core_content_phase (ngx_http_request_t*,ngx_http_phase_handler_t*)"
270516,METHOD,http\ngx_http_core_module.h:<global>,TYPE_DECL,"void *ngx_http_test_content_type(ngx_http_request_t *r, ngx_hash_t *types_hash);",6,79,http\ngx_http_core_module.h,ngx_http_test_content_type,,false,487,487,ngx_http_test_content_type,,,48,"void* ngx_http_test_content_type (ngx_http_request_t*,ngx_hash_t*)"
270522,METHOD,http\ngx_http_core_module.h:<global>,TYPE_DECL,ngx_int_t ngx_http_set_content_type(ngx_http_request_t *r);,11,58,http\ngx_http_core_module.h,ngx_http_set_content_type,,false,488,488,ngx_http_set_content_type,,,49,ngx_int_t ngx_http_set_content_type (ngx_http_request_t*)
270527,METHOD,http\ngx_http_core_module.h:<global>,TYPE_DECL,void ngx_http_set_exten(ngx_http_request_t *r);,6,46,http\ngx_http_core_module.h,ngx_http_set_exten,,false,489,489,ngx_http_set_exten,,,50,void ngx_http_set_exten (ngx_http_request_t*)
270532,METHOD,http\ngx_http_core_module.h:<global>,TYPE_DECL,ngx_int_t ngx_http_set_etag(ngx_http_request_t *r);,11,50,http\ngx_http_core_module.h,ngx_http_set_etag,,false,490,490,ngx_http_set_etag,,,51,ngx_int_t ngx_http_set_etag (ngx_http_request_t*)
270537,METHOD,http\ngx_http_core_module.h:<global>,TYPE_DECL,void ngx_http_weak_etag(ngx_http_request_t *r);,6,46,http\ngx_http_core_module.h,ngx_http_weak_etag,,false,491,491,ngx_http_weak_etag,,,52,void ngx_http_weak_etag (ngx_http_request_t*)
270542,METHOD,http\ngx_http_core_module.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_send_response(ngx_http_request_t *r, ngx_uint_t status,
    ngx_str_t *ct, ngx_http_complex_value_t *cv);",11,48,http\ngx_http_core_module.h,ngx_http_send_response,,false,492,493,ngx_http_send_response,,,53,"ngx_int_t ngx_http_send_response (ngx_http_request_t*,ngx_uint_t,ngx_str_t*,ngx_http_complex_value_t*)"
270550,METHOD,http\ngx_http_core_module.h:<global>,TYPE_DECL,"u_char *ngx_http_map_uri_to_path(ngx_http_request_t *r, ngx_str_t *name,
    size_t *root_length, size_t reserved);",8,41,http\ngx_http_core_module.h,ngx_http_map_uri_to_path,,false,494,495,ngx_http_map_uri_to_path,,,54,"u_char* ngx_http_map_uri_to_path (ngx_http_request_t*,ngx_str_t*,size_t*,size_t)"
270558,METHOD,http\ngx_http_core_module.h:<global>,TYPE_DECL,ngx_int_t ngx_http_auth_basic_user(ngx_http_request_t *r);,11,57,http\ngx_http_core_module.h,ngx_http_auth_basic_user,,false,496,496,ngx_http_auth_basic_user,,,55,ngx_int_t ngx_http_auth_basic_user (ngx_http_request_t*)
270563,METHOD,http\ngx_http_core_module.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_subrequest(ngx_http_request_t *r,
    ngx_str_t *uri, ngx_str_t *args, ngx_http_request_t **sr,
    ngx_http_post_subrequest_t *psr, ngx_uint_t flags);",11,54,http\ngx_http_core_module.h,ngx_http_subrequest,,false,502,504,ngx_http_subrequest,,,56,"ngx_int_t ngx_http_subrequest (ngx_http_request_t*,ngx_str_t*,ngx_str_t*,ngx_http_request_t**,ngx_http_post_subrequest_t*,ngx_uint_t)"
270573,METHOD,http\ngx_http_core_module.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_internal_redirect(ngx_http_request_t *r,
    ngx_str_t *uri, ngx_str_t *args);",11,36,http\ngx_http_core_module.h,ngx_http_internal_redirect,,false,505,506,ngx_http_internal_redirect,,,57,"ngx_int_t ngx_http_internal_redirect (ngx_http_request_t*,ngx_str_t*,ngx_str_t*)"
270580,METHOD,http\ngx_http_core_module.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_named_location(ngx_http_request_t *r, ngx_str_t *name);",11,73,http\ngx_http_core_module.h,ngx_http_named_location,,false,507,507,ngx_http_named_location,,,58,"ngx_int_t ngx_http_named_location (ngx_http_request_t*,ngx_str_t*)"
270586,METHOD,http\ngx_http_core_module.h:<global>,TYPE_DECL,"ngx_http_cleanup_t *ngx_http_cleanup_add(ngx_http_request_t *r, size_t size);",20,76,http\ngx_http_core_module.h,ngx_http_cleanup_add,,false,510,510,ngx_http_cleanup_add,,,59,"ngx_http_cleanup_t* ngx_http_cleanup_add (ngx_http_request_t*,size_t)"
270592,METHOD,http\ngx_http_core_module.h:<global>,TYPE_DECL,typedef ngx_int_t (*ngx_http_output_header_filter_pt)(ngx_http_request_t *r);,19,76,http\ngx_http_core_module.h,ngx_http_output_header_filter_pt,,false,513,513,ngx_http_output_header_filter_pt,,,60,ngx_int_t ngx_http_output_header_filter_pt (ngx_http_request_t*)
270597,METHOD,http\ngx_http_core_module.h:<global>,TYPE_DECL,"typedef ngx_int_t (*ngx_http_output_body_filter_pt)
    (ngx_http_request_t *r, ngx_chain_t *chain);",19,47,http\ngx_http_core_module.h,ngx_http_output_body_filter_pt,,false,514,515,ngx_http_output_body_filter_pt,,,61,"ngx_int_t ngx_http_output_body_filter_pt (ngx_http_request_t*,ngx_chain_t*)"
270603,METHOD,http\ngx_http_core_module.h:<global>,TYPE_DECL,"typedef ngx_int_t (*ngx_http_request_body_filter_pt)
    (ngx_http_request_t *r, ngx_chain_t *chain);",19,47,http\ngx_http_core_module.h,ngx_http_request_body_filter_pt,,false,516,517,ngx_http_request_body_filter_pt,,,62,"ngx_int_t ngx_http_request_body_filter_pt (ngx_http_request_t*,ngx_chain_t*)"
270609,METHOD,http\ngx_http_core_module.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_output_filter(ngx_http_request_t *r, ngx_chain_t *chain);",11,75,http\ngx_http_core_module.h,ngx_http_output_filter,,false,520,520,ngx_http_output_filter,,,63,"ngx_int_t ngx_http_output_filter (ngx_http_request_t*,ngx_chain_t*)"
270615,METHOD,http\ngx_http_core_module.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_write_filter(ngx_http_request_t *r, ngx_chain_t *chain);",11,74,http\ngx_http_core_module.h,ngx_http_write_filter,,false,521,521,ngx_http_write_filter,,,64,"ngx_int_t ngx_http_write_filter (ngx_http_request_t*,ngx_chain_t*)"
270621,METHOD,http\ngx_http_core_module.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_request_body_save_filter(ngx_http_request_t *r,
    ngx_chain_t *chain);",11,23,http\ngx_http_core_module.h,ngx_http_request_body_save_filter,,false,522,523,ngx_http_request_body_save_filter,,,65,"ngx_int_t ngx_http_request_body_save_filter (ngx_http_request_t*,ngx_chain_t*)"
270627,METHOD,http\ngx_http_core_module.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_set_disable_symlinks(ngx_http_request_t *r,
    ngx_http_core_loc_conf_t *clcf, ngx_str_t *path, ngx_open_file_info_t *of);",11,78,http\ngx_http_core_module.h,ngx_http_set_disable_symlinks,,false,526,527,ngx_http_set_disable_symlinks,,,66,"ngx_int_t ngx_http_set_disable_symlinks (ngx_http_request_t*,ngx_http_core_loc_conf_t*,ngx_str_t*,ngx_open_file_info_t*)"
270635,METHOD,http\ngx_http_core_module.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_get_forwarded_addr(ngx_http_request_t *r, ngx_addr_t *addr,
    ngx_array_t *headers, ngx_str_t *value, ngx_array_t *proxies,
    int recursive);",11,18,http\ngx_http_core_module.h,ngx_http_get_forwarded_addr,,false,529,531,ngx_http_get_forwarded_addr,,,67,"ngx_int_t ngx_http_get_forwarded_addr (ngx_http_request_t*,ngx_addr_t*,ngx_array_t*,ngx_str_t*,ngx_array_t*,int)"
270659,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,<global>,1,1,http\ngx_http_file_cache.c,http\ngx_http_file_cache.c:<global>,,false,1,2698,<global>,,,1,
270661,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_file_cache_lock(ngx_http_request_t *r,
    ngx_http_cache_t *c);",18,24,http\ngx_http_file_cache.c,ngx_http_file_cache_lock,,false,14,15,ngx_http_file_cache_lock,,,1,"ngx_int_t ngx_http_file_cache_lock (ngx_http_request_t*,ngx_http_cache_t*)"
270667,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,static void ngx_http_file_cache_lock_wait_handler(ngx_event_t *ev);,13,66,http\ngx_http_file_cache.c,ngx_http_file_cache_lock_wait_handler,,false,16,16,ngx_http_file_cache_lock_wait_handler,,,2,void ngx_http_file_cache_lock_wait_handler (ngx_event_t*)
270672,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static void ngx_http_file_cache_lock_wait(ngx_http_request_t *r,
    ngx_http_cache_t *c);",13,24,http\ngx_http_file_cache.c,ngx_http_file_cache_lock_wait,,false,17,18,ngx_http_file_cache_lock_wait,,,3,"void ngx_http_file_cache_lock_wait (ngx_http_request_t*,ngx_http_cache_t*)"
270678,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_file_cache_read(ngx_http_request_t *r,
    ngx_http_cache_t *c);",18,24,http\ngx_http_file_cache.c,ngx_http_file_cache_read,,false,19,20,ngx_http_file_cache_read,,,4,"ngx_int_t ngx_http_file_cache_read (ngx_http_request_t*,ngx_http_cache_t*)"
270684,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static ssize_t ngx_http_file_cache_aio_read(ngx_http_request_t *r,
    ngx_http_cache_t *c);",16,24,http\ngx_http_file_cache.c,ngx_http_file_cache_aio_read,,false,21,22,ngx_http_file_cache_aio_read,,,5,"ssize_t ngx_http_file_cache_aio_read (ngx_http_request_t*,ngx_http_cache_t*)"
270690,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_file_cache_exists(ngx_http_file_cache_t *cache,
    ngx_http_cache_t *c);",18,24,http\ngx_http_file_cache.c,ngx_http_file_cache_exists,,false,31,32,ngx_http_file_cache_exists,,,6,"ngx_int_t ngx_http_file_cache_exists (ngx_http_file_cache_t*,ngx_http_cache_t*)"
270696,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_file_cache_name(ngx_http_request_t *r,
    ngx_path_t *path);",18,21,http\ngx_http_file_cache.c,ngx_http_file_cache_name,,false,33,34,ngx_http_file_cache_name,,,7,"ngx_int_t ngx_http_file_cache_name (ngx_http_request_t*,ngx_path_t*)"
270702,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static ngx_http_file_cache_node_t *
    ngx_http_file_cache_lookup(ngx_http_file_cache_t *cache, u_char *key);",35,73,http\ngx_http_file_cache.c,ngx_http_file_cache_lookup,,false,35,36,ngx_http_file_cache_lookup,,,8,"ngx_http_file_cache_node_t* ngx_http_file_cache_lookup (ngx_http_file_cache_t*,u_char*)"
270708,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static void ngx_http_file_cache_rbtree_insert_value(ngx_rbtree_node_t *temp,
    ngx_rbtree_node_t *node, ngx_rbtree_node_t *sentinel);",13,57,http\ngx_http_file_cache.c,ngx_http_file_cache_rbtree_insert_value,,false,37,38,ngx_http_file_cache_rbtree_insert_value,,,9,"void ngx_http_file_cache_rbtree_insert_value (ngx_rbtree_node_t*,ngx_rbtree_node_t*,ngx_rbtree_node_t*)"
270715,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static void ngx_http_file_cache_vary(ngx_http_request_t *r, u_char *vary,
    size_t len, u_char *hash);",13,29,http\ngx_http_file_cache.c,ngx_http_file_cache_vary,,false,39,40,ngx_http_file_cache_vary,,,10,"void ngx_http_file_cache_vary (ngx_http_request_t*,u_char*,size_t,u_char*)"
270723,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static void ngx_http_file_cache_vary_header(ngx_http_request_t *r,
    ngx_md5_t *md5, ngx_str_t *name);",13,36,http\ngx_http_file_cache.c,ngx_http_file_cache_vary_header,,false,41,42,ngx_http_file_cache_vary_header,,,11,"void ngx_http_file_cache_vary_header (ngx_http_request_t*,ngx_md5_t*,ngx_str_t*)"
270730,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_file_cache_reopen(ngx_http_request_t *r,
    ngx_http_cache_t *c);",18,24,http\ngx_http_file_cache.c,ngx_http_file_cache_reopen,,false,43,44,ngx_http_file_cache_reopen,,,12,"ngx_int_t ngx_http_file_cache_reopen (ngx_http_request_t*,ngx_http_cache_t*)"
270736,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_file_cache_update_variant(ngx_http_request_t *r,
    ngx_http_cache_t *c);",18,24,http\ngx_http_file_cache.c,ngx_http_file_cache_update_variant,,false,45,46,ngx_http_file_cache_update_variant,,,13,"ngx_int_t ngx_http_file_cache_update_variant (ngx_http_request_t*,ngx_http_cache_t*)"
270742,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,static void ngx_http_file_cache_cleanup(void *data);,13,51,http\ngx_http_file_cache.c,ngx_http_file_cache_cleanup,,false,47,47,ngx_http_file_cache_cleanup,,,14,void ngx_http_file_cache_cleanup (void*)
270747,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,static time_t ngx_http_file_cache_forced_expire(ngx_http_file_cache_t *cache);,15,77,http\ngx_http_file_cache.c,ngx_http_file_cache_forced_expire,,false,48,48,ngx_http_file_cache_forced_expire,,,15,time_t ngx_http_file_cache_forced_expire (ngx_http_file_cache_t*)
270752,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,static time_t ngx_http_file_cache_expire(ngx_http_file_cache_t *cache);,15,70,http\ngx_http_file_cache.c,ngx_http_file_cache_expire,,false,49,49,ngx_http_file_cache_expire,,,16,time_t ngx_http_file_cache_expire (ngx_http_file_cache_t*)
270757,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static void ngx_http_file_cache_delete(ngx_http_file_cache_t *cache,
    ngx_queue_t *q, u_char *name);",13,33,http\ngx_http_file_cache.c,ngx_http_file_cache_delete,,false,50,51,ngx_http_file_cache_delete,,,17,"void ngx_http_file_cache_delete (ngx_http_file_cache_t*,ngx_queue_t*,u_char*)"
270764,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,static void ngx_http_file_cache_loader_sleep(ngx_http_file_cache_t *cache);,13,74,http\ngx_http_file_cache.c,ngx_http_file_cache_loader_sleep,,false,52,52,ngx_http_file_cache_loader_sleep,,,18,void ngx_http_file_cache_loader_sleep (ngx_http_file_cache_t*)
270769,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_file_cache_noop(ngx_tree_ctx_t *ctx,
    ngx_str_t *path);",18,20,http\ngx_http_file_cache.c,ngx_http_file_cache_noop,,false,53,54,ngx_http_file_cache_noop,,,19,"ngx_int_t ngx_http_file_cache_noop (ngx_tree_ctx_t*,ngx_str_t*)"
270775,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_file_cache_manage_file(ngx_tree_ctx_t *ctx,
    ngx_str_t *path);",18,20,http\ngx_http_file_cache.c,ngx_http_file_cache_manage_file,,false,55,56,ngx_http_file_cache_manage_file,,,20,"ngx_int_t ngx_http_file_cache_manage_file (ngx_tree_ctx_t*,ngx_str_t*)"
270781,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_file_cache_manage_directory(ngx_tree_ctx_t *ctx,
    ngx_str_t *path);",18,20,http\ngx_http_file_cache.c,ngx_http_file_cache_manage_directory,,false,57,58,ngx_http_file_cache_manage_directory,,,21,"ngx_int_t ngx_http_file_cache_manage_directory (ngx_tree_ctx_t*,ngx_str_t*)"
270787,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_file_cache_add_file(ngx_tree_ctx_t *ctx,
    ngx_str_t *path);",18,20,http\ngx_http_file_cache.c,ngx_http_file_cache_add_file,,false,59,60,ngx_http_file_cache_add_file,,,22,"ngx_int_t ngx_http_file_cache_add_file (ngx_tree_ctx_t*,ngx_str_t*)"
270793,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_file_cache_add(ngx_http_file_cache_t *cache,
    ngx_http_cache_t *c);",18,24,http\ngx_http_file_cache.c,ngx_http_file_cache_add,,false,61,62,ngx_http_file_cache_add,,,23,"ngx_int_t ngx_http_file_cache_add (ngx_http_file_cache_t*,ngx_http_cache_t*)"
270799,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_file_cache_delete_file(ngx_tree_ctx_t *ctx,
    ngx_str_t *path);",18,20,http\ngx_http_file_cache.c,ngx_http_file_cache_delete_file,,false,63,64,ngx_http_file_cache_delete_file,,,24,"ngx_int_t ngx_http_file_cache_delete_file (ngx_tree_ctx_t*,ngx_str_t*)"
270805,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,static void ngx_http_file_cache_set_watermark(ngx_http_file_cache_t *cache);,13,75,http\ngx_http_file_cache.c,ngx_http_file_cache_set_watermark,,false,65,65,ngx_http_file_cache_set_watermark,,,25,void ngx_http_file_cache_set_watermark (ngx_http_file_cache_t*)
270838,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_file_cache_init(ngx_shm_zone_t *shm_zone, void *data)
{
    ngx_http_file_cache_t  *ocache = data;

    size_t                  len;
    ngx_uint_t              n;
    ngx_http_file_cache_t  *cache;

    cache = shm_zone->data;

    if (ocache) {
        if (ngx_strcmp(cache->path->name.data, ocache->path->name.data) != 0) {
            ngx_log_error(NGX_LOG_EMERG, shm_zone->shm.log, 0,
                          ""cache \""%V\"" uses the \""%V\"" cache path ""
                          ""while previously it used the \""%V\"" cache path"",
                          &shm_zone->shm.name, &cache->path->name,
                          &ocache->path->name);

            return NGX_ERROR;
        }

        for (n = 0; n < NGX_MAX_PATH_LEVEL; n++) {
            if (cache->path->level[n] != ocache->path->level[n]) {
                ngx_log_error(NGX_LOG_EMERG, shm_zone->shm.log, 0,
                              ""cache \""%V\"" had previously different levels"",
                ...",1,1,http\ngx_http_file_cache.c,ngx_http_file_cache_init,,false,82,172,ngx_http_file_cache_init,,,30,"ngx_int_t ngx_http_file_cache_init (ngx_shm_zone_t*,void*)"
271212,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_file_cache_new(ngx_http_request_t *r)
{
    ngx_http_cache_t  *c;

    c = ngx_pcalloc(r->pool, sizeof(ngx_http_cache_t));
    if (c == NULL) {
        return NGX_ERROR;
    }

    if (ngx_array_init(&c->keys, r->pool, 4, sizeof(ngx_str_t)) != NGX_OK) {
        return NGX_ERROR;
    }

    r->cache = c;
    c->file.log = r->connection->log;
    c->file.fd = NGX_INVALID_FILE;

    return NGX_OK;
}",1,1,http\ngx_http_file_cache.c,ngx_http_file_cache_new,,false,175,194,ngx_http_file_cache_new,,,31,ngx_int_t ngx_http_file_cache_new (ngx_http_request_t*)
271275,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_file_cache_create(ngx_http_request_t *r)
{
    ngx_http_cache_t       *c;
    ngx_pool_cleanup_t     *cln;
    ngx_http_file_cache_t  *cache;

    c = r->cache;
    cache = c->file_cache;

    cln = ngx_pool_cleanup_add(r->pool, 0);
    if (cln == NULL) {
        return NGX_ERROR;
    }

    cln->handler = ngx_http_file_cache_cleanup;
    cln->data = c;

    if (ngx_http_file_cache_exists(cache, c) == NGX_ERROR) {
        return NGX_ERROR;
    }

    if (ngx_http_file_cache_name(r, cache->path) != NGX_OK) {
        return NGX_ERROR;
    }

    return NGX_OK;
}",1,1,http\ngx_http_file_cache.c,ngx_http_file_cache_create,,false,197,224,ngx_http_file_cache_create,,,32,ngx_int_t ngx_http_file_cache_create (ngx_http_request_t*)
271339,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"void
ngx_http_file_cache_create_key(ngx_http_request_t *r)
{
    size_t             len;
    ngx_str_t         *key;
    ngx_uint_t         i;
    ngx_md5_t          md5;
    ngx_http_cache_t  *c;

    c = r->cache;

    len = 0;

    ngx_crc32_init(c->crc32);
    ngx_md5_init(&md5);

    key = c->keys.elts;
    for (i = 0; i < c->keys.nelts; i++) {
        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                       ""http cache key: \""%V\"""", &key[i]);

        len += key[i].len;

        ngx_crc32_update(&c->crc32, key[i].data, key[i].len);
        ngx_md5_update(&md5, key[i].data, key[i].len);
    }

    c->header_start = sizeof(ngx_http_file_cache_header_t)
                      + sizeof(ngx_http_file_cache_key) + len + 1;

    ngx_crc32_final(c->crc32);
    ngx_md5_final(c->key, &md5);

    ngx_memcpy(c->main, c->key, NGX_HTTP_CACHE_KEY_LEN);
}",1,1,http\ngx_http_file_cache.c,ngx_http_file_cache_create_key,,false,227,261,ngx_http_file_cache_create_key,,,33,void ngx_http_file_cache_create_key (ngx_http_request_t*)
271465,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_file_cache_open(ngx_http_request_t *r)
{
    ngx_int_t                  rc, rv;
    ngx_uint_t                 test;
    ngx_http_cache_t          *c;
    ngx_pool_cleanup_t        *cln;
    ngx_open_file_info_t       of;
    ngx_http_file_cache_t     *cache;
    ngx_http_core_loc_conf_t  *clcf;

    c = r->cache;

    if (c->waiting) {
        return NGX_AGAIN;
    }

    if (c->reading) {
        return ngx_http_file_cache_read(r, c);
    }

    cache = c->file_cache;

    if (c->node == NULL) {
        cln = ngx_pool_cleanup_add(r->pool, 0);
        if (cln == NULL) {
            return NGX_ERROR;
        }

        cln->handler = ngx_http_file_cache_cleanup;
        cln->data = c;
    }

    rc = ngx_http_file_cache_exists(cache, c);

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http file cache exists: %i e:%d"", rc, c->exists);

    if (rc == NGX_ERROR) {
        return rc;
    }

    if (rc == NGX_AGAIN) {
        return N...",1,1,http\ngx_http_file_cache.c,ngx_http_file_cache_open,,false,264,399,ngx_http_file_cache_open,,,34,ngx_int_t ngx_http_file_cache_open (ngx_http_request_t*)
271837,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_file_cache_lock(ngx_http_request_t *r, ngx_http_cache_t *c)
{
    ngx_msec_t                 now, timer;
    ngx_http_file_cache_t     *cache;

    if (!c->lock) {
        return NGX_DECLINED;
    }

    now = ngx_current_msec;

    cache = c->file_cache;

    ngx_shmtx_lock(&cache->shpool->mutex);

    timer = c->node->lock_time - now;

    if (!c->node->updating || (ngx_msec_int_t) timer <= 0) {
        c->node->updating = 1;
        c->node->lock_time = now + c->lock_age;
        c->updating = 1;
        c->lock_time = c->node->lock_time;
    }

    ngx_shmtx_unlock(&cache->shpool->mutex);

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http file cache lock u:%d wt:%M"",
                   c->updating, c->wait_time);

    if (c->updating) {
        return NGX_DECLINED;
    }

    if (c->lock_timeout == 0) {
        return NGX_HTTP_CACHE_SCARCE;
    }

    c->waiting = 1;

    if (c->wait_time == 0) {
        c->wait_time...",1,1,http\ngx_http_file_cache.c,ngx_http_file_cache_lock,,false,402,458,ngx_http_file_cache_lock,,,35,"ngx_int_t ngx_http_file_cache_lock (ngx_http_request_t*,ngx_http_cache_t*)"
272034,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static void
ngx_http_file_cache_lock_wait_handler(ngx_event_t *ev)
{
    ngx_connection_t    *c;
    ngx_http_request_t  *r;

    r = ev->data;
    c = r->connection;

    ngx_http_set_log_request(c->log, r);

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, c->log, 0,
                   ""http file cache wait: \""%V?%V\"""", &r->uri, &r->args);

    ngx_http_file_cache_lock_wait(r, r->cache);

    ngx_http_run_posted_requests(c);
}",1,1,http\ngx_http_file_cache.c,ngx_http_file_cache_lock_wait_handler,,false,461,478,ngx_http_file_cache_lock_wait_handler,,,36,void ngx_http_file_cache_lock_wait_handler (ngx_event_t*)
272078,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static void
ngx_http_file_cache_lock_wait(ngx_http_request_t *r, ngx_http_cache_t *c)
{
    ngx_uint_t              wait;
    ngx_msec_t              now, timer;
    ngx_http_file_cache_t  *cache;

    now = ngx_current_msec;

    timer = c->wait_time - now;

    if ((ngx_msec_int_t) timer <= 0) {
        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
                      ""cache lock timeout"");
        c->lock_timeout = 0;
        goto wakeup;
    }

    cache = c->file_cache;
    wait = 0;

    ngx_shmtx_lock(&cache->shpool->mutex);

    timer = c->node->lock_time - now;

    if (c->node->updating && (ngx_msec_int_t) timer > 0) {
        wait = 1;
    }

    ngx_shmtx_unlock(&cache->shpool->mutex);

    if (wait) {
        ngx_add_timer(&c->wait_event, (timer > 500) ? 500 : timer);
        return;
    }

wakeup:

    c->waiting = 0;
    r->main->blocked--;
    r->write_event_handler(r);
}",1,1,http\ngx_http_file_cache.c,ngx_http_file_cache_lock_wait,,false,481,522,ngx_http_file_cache_lock_wait,,,37,"void ngx_http_file_cache_lock_wait (ngx_http_request_t*,ngx_http_cache_t*)"
272199,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_file_cache_read(ngx_http_request_t *r, ngx_http_cache_t *c)
{
    u_char                        *p;
    time_t                         now;
    ssize_t                        n;
    ngx_str_t                     *key;
    ngx_int_t                      rc;
    ngx_uint_t                     i;
    ngx_http_file_cache_t         *cache;
    ngx_http_file_cache_header_t  *h;

    n = ngx_http_file_cache_aio_read(r, c);

    if (n < 0) {
        return n;
    }

    if ((size_t) n < c->header_start) {
        ngx_log_error(NGX_LOG_CRIT, r->connection->log, 0,
                      ""cache file \""%s\"" is too small"", c->file.name.data);
        return NGX_DECLINED;
    }

    h = (ngx_http_file_cache_header_t *) c->buf->pos;

    if (h->version != NGX_HTTP_CACHE_VERSION) {
        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
                      ""cache file \""%s\"" version mismatch"", c->file.name.data);
        return NGX_DECLINED;
    }

    if (h->crc32 !=...",1,1,http\ngx_http_file_cache.c,ngx_http_file_cache_read,,false,525,663,ngx_http_file_cache_read,,,38,"ngx_int_t ngx_http_file_cache_read (ngx_http_request_t*,ngx_http_cache_t*)"
272761,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static ssize_t
ngx_http_file_cache_aio_read(ngx_http_request_t *r, ngx_http_cache_t *c)
{
#if (NGX_HAVE_FILE_AIO || NGX_THREADS)
    ssize_t                    n;
    ngx_http_core_loc_conf_t  *clcf;

    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);
#endif

#if (NGX_HAVE_FILE_AIO)

    if (clcf->aio == NGX_HTTP_AIO_ON && ngx_file_aio) {
        n = ngx_file_aio_read(&c->file, c->buf->pos, c->body_start, 0, r->pool);

        if (n != NGX_AGAIN) {
            c->reading = 0;
            return n;
        }

        c->reading = 1;

        c->file.aio->data = r;
        c->file.aio->handler = ngx_http_cache_aio_event_handler;

        r->main->blocked++;
        r->aio = 1;

        return NGX_AGAIN;
    }

#endif

#if (NGX_THREADS)

    if (clcf->aio == NGX_HTTP_AIO_THREADS) {
        c->file.thread_task = c->thread_task;
        c->file.thread_handler = ngx_http_cache_thread_handler;
        c->file.thread_ctx = r;

        n = ngx_thread_read(&c->file, c->buf->pos...",1,1,http\ngx_http_file_cache.c,ngx_http_file_cache_aio_read,,false,666,717,ngx_http_file_cache_aio_read,,,39,"ssize_t ngx_http_file_cache_aio_read (ngx_http_request_t*,ngx_http_cache_t*)"
272782,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_file_cache_exists(ngx_http_file_cache_t *cache, ngx_http_cache_t *c)
{
    ngx_int_t                    rc;
    ngx_http_file_cache_node_t  *fcn;

    ngx_shmtx_lock(&cache->shpool->mutex);

    fcn = c->node;

    if (fcn == NULL) {
        fcn = ngx_http_file_cache_lookup(cache, c->key);
    }

    if (fcn) {
        ngx_queue_remove(&fcn->queue);

        if (c->node == NULL) {
            fcn->uses++;
            fcn->count++;
        }

        if (fcn->error) {

            if (fcn->valid_sec < ngx_time()) {
                goto renew;
            }

            rc = NGX_OK;

            goto done;
        }

        if (fcn->exists || fcn->uses >= c->min_uses) {

            c->exists = fcn->exists;
            if (fcn->body_start) {
                c->body_start = fcn->body_start;
            }

            rc = NGX_OK;

            goto done;
        }

        rc = NGX_AGAIN;

        goto done;
    }

    fcn = ngx_slab_calloc_locked(cache->shpoo...",1,1,http\ngx_http_file_cache.c,ngx_http_file_cache_exists,,false,819,929,ngx_http_file_cache_exists,,,40,"ngx_int_t ngx_http_file_cache_exists (ngx_http_file_cache_t*,ngx_http_cache_t*)"
273101,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_file_cache_name(ngx_http_request_t *r, ngx_path_t *path)
{
    u_char            *p;
    ngx_http_cache_t  *c;

    c = r->cache;

    if (c->file.name.len) {
        return NGX_OK;
    }

    c->file.name.len = path->name.len + 1 + path->len
                       + 2 * NGX_HTTP_CACHE_KEY_LEN;

    c->file.name.data = ngx_pnalloc(r->pool, c->file.name.len + 1);
    if (c->file.name.data == NULL) {
        return NGX_ERROR;
    }

    ngx_memcpy(c->file.name.data, path->name.data, path->name.len);

    p = c->file.name.data + path->name.len + 1 + path->len;
    p = ngx_hex_dump(p, c->key, NGX_HTTP_CACHE_KEY_LEN);
    *p = '\0';

    ngx_create_hashed_filename(path, c->file.name.data, c->file.name.len);

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""cache file: \""%s\"""", c->file.name.data);

    return NGX_OK;
}",1,1,http\ngx_http_file_cache.c,ngx_http_file_cache_name,,false,932,964,ngx_http_file_cache_name,,,41,"ngx_int_t ngx_http_file_cache_name (ngx_http_request_t*,ngx_path_t*)"
273267,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static ngx_http_file_cache_node_t *
ngx_http_file_cache_lookup(ngx_http_file_cache_t *cache, u_char *key)
{
    ngx_int_t                    rc;
    ngx_rbtree_key_t             node_key;
    ngx_rbtree_node_t           *node, *sentinel;
    ngx_http_file_cache_node_t  *fcn;

    ngx_memcpy((u_char *) &node_key, key, sizeof(ngx_rbtree_key_t));

    node = cache->sh->rbtree.root;
    sentinel = cache->sh->rbtree.sentinel;

    while (node != sentinel) {

        if (node_key < node->key) {
            node = node->left;
            continue;
        }

        if (node_key > node->key) {
            node = node->right;
            continue;
        }

        /* node_key == node->key */

        fcn = (ngx_http_file_cache_node_t *) node;

        rc = ngx_memcmp(&key[sizeof(ngx_rbtree_key_t)], fcn->key,
                        NGX_HTTP_CACHE_KEY_LEN - sizeof(ngx_rbtree_key_t));

        if (rc == 0) {
            return fcn;
        }

        node = (rc < 0) ? node->left : node->rig...",1,1,http\ngx_http_file_cache.c,ngx_http_file_cache_lookup,,false,967,1009,ngx_http_file_cache_lookup,,,42,"ngx_http_file_cache_node_t ngx_http_file_cache_lookup (ngx_http_file_cache_t*,u_char*)"
273376,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static void
ngx_http_file_cache_rbtree_insert_value(ngx_rbtree_node_t *temp,
    ngx_rbtree_node_t *node, ngx_rbtree_node_t *sentinel)
{
    ngx_rbtree_node_t           **p;
    ngx_http_file_cache_node_t   *cn, *cnt;

    for ( ;; ) {

        if (node->key < temp->key) {

            p = &temp->left;

        } else if (node->key > temp->key) {

            p = &temp->right;

        } else { /* node->key == temp->key */

            cn = (ngx_http_file_cache_node_t *) node;
            cnt = (ngx_http_file_cache_node_t *) temp;

            p = (ngx_memcmp(cn->key, cnt->key,
                            NGX_HTTP_CACHE_KEY_LEN - sizeof(ngx_rbtree_key_t))
                 < 0)
                    ? &temp->left : &temp->right;
        }

        if (*p == sentinel) {
            break;
        }

        temp = *p;
    }

    *p = node;
    node->parent = temp;
    node->left = sentinel;
    node->right = sentinel;
    ngx_rbt_red(node);
}",1,1,http\ngx_http_file_cache.c,ngx_http_file_cache_rbtree_insert_value,,false,1012,1052,ngx_http_file_cache_rbtree_insert_value,,,43,"void ngx_http_file_cache_rbtree_insert_value (ngx_rbtree_node_t*,ngx_rbtree_node_t*,ngx_rbtree_node_t*)"
273489,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static void
ngx_http_file_cache_vary(ngx_http_request_t *r, u_char *vary, size_t len,
    u_char *hash)
{
    u_char     *p, *last;
    ngx_str_t   name;
    ngx_md5_t   md5;
    u_char      buf[NGX_HTTP_CACHE_VARY_LEN];

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http file cache vary: \""%*s\"""", len, vary);

    ngx_md5_init(&md5);
    ngx_md5_update(&md5, r->cache->main, NGX_HTTP_CACHE_KEY_LEN);

    ngx_strlow(buf, vary, len);

    p = buf;
    last = buf + len;

    while (p < last) {

        while (p < last && (*p == ' ' || *p == ',')) { p++; }

        name.data = p;

        while (p < last && *p != ',' && *p != ' ') { p++; }

        name.len = p - name.data;

        if (name.len == 0) {
            break;
        }

        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                       ""http file cache vary: %V"", &name);

        ngx_md5_update(&md5, name.data, name.len);
        ngx_md5_update(&md5, (u_char *) "":"", ...",1,1,http\ngx_http_file_cache.c,ngx_http_file_cache_vary,,false,1055,1101,ngx_http_file_cache_vary,,,44,"void ngx_http_file_cache_vary (ngx_http_request_t*,u_char*,size_t,u_char*)"
273648,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static void
ngx_http_file_cache_vary_header(ngx_http_request_t *r, ngx_md5_t *md5,
    ngx_str_t *name)
{
    size_t            len;
    u_char           *p, *start, *last;
    ngx_uint_t        i, multiple, normalize;
    ngx_list_part_t  *part;
    ngx_table_elt_t  *header;

    multiple = 0;
    normalize = 0;

    if (name->len == sizeof(""Accept-Charset"") - 1
        && ngx_strncasecmp(name->data, (u_char *) ""Accept-Charset"",
                           sizeof(""Accept-Charset"") - 1) == 0)
    {
        normalize = 1;

    } else if (name->len == sizeof(""Accept-Encoding"") - 1
        && ngx_strncasecmp(name->data, (u_char *) ""Accept-Encoding"",
                           sizeof(""Accept-Encoding"") - 1) == 0)
    {
        normalize = 1;

    } else if (name->len == sizeof(""Accept-Language"") - 1
        && ngx_strncasecmp(name->data, (u_char *) ""Accept-Language"",
                           sizeof(""Accept-Language"") - 1) == 0)
    {
        normalize = 1;
    }

    part = &r->headers...",1,1,http\ngx_http_file_cache.c,ngx_http_file_cache_vary_header,,false,1104,1204,ngx_http_file_cache_vary_header,,,45,"void ngx_http_file_cache_vary_header (ngx_http_request_t*,ngx_md5_t*,ngx_str_t*)"
273977,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_file_cache_reopen(ngx_http_request_t *r, ngx_http_cache_t *c)
{
    ngx_http_file_cache_t  *cache;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->file.log, 0,
                   ""http file cache reopen"");

    if (c->secondary) {
        ngx_log_error(NGX_LOG_CRIT, r->connection->log, 0,
                      ""cache file \""%s\"" has incorrect vary hash"",
                      c->file.name.data);
        return NGX_DECLINED;
    }

    cache = c->file_cache;

    ngx_shmtx_lock(&cache->shpool->mutex);

    c->node->count--;
    c->node = NULL;

    ngx_shmtx_unlock(&cache->shpool->mutex);

    c->secondary = 1;
    c->file.name.len = 0;
    c->body_start = c->buf->end - c->buf->start;

    ngx_memcpy(c->key, c->variant, NGX_HTTP_CACHE_KEY_LEN);

    return ngx_http_file_cache_open(r);
}",1,1,http\ngx_http_file_cache.c,ngx_http_file_cache_reopen,,false,1207,1238,ngx_http_file_cache_reopen,,,46,"ngx_int_t ngx_http_file_cache_reopen (ngx_http_request_t*,ngx_http_cache_t*)"
274086,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_file_cache_set_header(ngx_http_request_t *r, u_char *buf)
{
    ngx_http_file_cache_header_t  *h = (ngx_http_file_cache_header_t *) buf;

    u_char            *p;
    ngx_str_t         *key;
    ngx_uint_t         i;
    ngx_http_cache_t  *c;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http file cache set header"");

    c = r->cache;

    ngx_memzero(h, sizeof(ngx_http_file_cache_header_t));

    h->version = NGX_HTTP_CACHE_VERSION;
    h->valid_sec = c->valid_sec;
    h->updating_sec = c->updating_sec;
    h->error_sec = c->error_sec;
    h->last_modified = c->last_modified;
    h->date = c->date;
    h->crc32 = c->crc32;
    h->valid_msec = (u_short) c->valid_msec;
    h->header_start = (u_short) c->header_start;
    h->body_start = (u_short) c->body_start;

    if (c->etag.len <= NGX_HTTP_CACHE_ETAG_LEN) {
        h->etag_len = (u_char) c->etag.len;
        ngx_memcpy(h->etag, c->etag.data, c->etag.len);
    }

    if (c-...",1,1,http\ngx_http_file_cache.c,ngx_http_file_cache_set_header,,false,1241,1303,ngx_http_file_cache_set_header,,,47,"ngx_int_t ngx_http_file_cache_set_header (ngx_http_request_t*,u_char*)"
274363,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_file_cache_update_variant(ngx_http_request_t *r, ngx_http_cache_t *c)
{
    ngx_http_file_cache_t  *cache;

    if (!c->secondary) {
        return NGX_OK;
    }

    if (c->vary.len
        && ngx_memcmp(c->variant, c->key, NGX_HTTP_CACHE_KEY_LEN) == 0)
    {
        return NGX_OK;
    }

    /*
     * if the variant hash doesn't match one we used as a secondary
     * cache key, switch back to the original key
     */

    cache = c->file_cache;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http file cache main key"");

    ngx_shmtx_lock(&cache->shpool->mutex);

    c->node->count--;
    c->node->updating = 0;
    c->node = NULL;

    ngx_shmtx_unlock(&cache->shpool->mutex);

    c->file.name.len = 0;

    ngx_memcpy(c->key, c->main, NGX_HTTP_CACHE_KEY_LEN);

    if (ngx_http_file_cache_exists(cache, c) == NGX_ERROR) {
        return NGX_ERROR;
    }

    if (ngx_http_file_cache_name(r, cache->path) != NGX_OK) {
      ...",1,1,http\ngx_http_file_cache.c,ngx_http_file_cache_update_variant,,false,1306,1352,ngx_http_file_cache_update_variant,,,48,"ngx_int_t ngx_http_file_cache_update_variant (ngx_http_request_t*,ngx_http_cache_t*)"
274483,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"void
ngx_http_file_cache_update(ngx_http_request_t *r, ngx_temp_file_t *tf)
{
    off_t                   fs_size;
    ngx_int_t               rc;
    ngx_file_uniq_t         uniq;
    ngx_file_info_t         fi;
    ngx_http_cache_t        *c;
    ngx_ext_rename_file_t   ext;
    ngx_http_file_cache_t  *cache;

    c = r->cache;

    if (c->updated) {
        return;
    }

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http file cache update"");

    cache = c->file_cache;

    c->updated = 1;
    c->updating = 0;

    uniq = 0;
    fs_size = 0;

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http file cache rename: \""%s\"" to \""%s\"""",
                   tf->file.name.data, c->file.name.data);

    ext.access = NGX_FILE_OWNER_ACCESS;
    ext.path_access = NGX_FILE_OWNER_ACCESS;
    ext.time = -1;
    ext.create_path = 1;
    ext.delete_file = 1;
    ext.log = r->connection->log;

    rc = ngx_ext_rename_file(&tf->...",1,1,http\ngx_http_file_cache.c,ngx_http_file_cache_update,,false,1355,1427,ngx_http_file_cache_update,,,49,"void ngx_http_file_cache_update (ngx_http_request_t*,ngx_temp_file_t*)"
274737,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"void
ngx_http_file_cache_update_header(ngx_http_request_t *r)
{
    ssize_t                        n;
    ngx_err_t                      err;
    ngx_file_t                     file;
    ngx_file_info_t                fi;
    ngx_http_cache_t              *c;
    ngx_http_file_cache_header_t   h;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http file cache update header"");

    c = r->cache;

    ngx_memzero(&file, sizeof(ngx_file_t));

    file.name = c->file.name;
    file.log = r->connection->log;
    file.fd = ngx_open_file(file.name.data, NGX_FILE_RDWR, NGX_FILE_OPEN, 0);

    if (file.fd == NGX_INVALID_FILE) {
        err = ngx_errno;

        /* cache file may have been deleted */

        if (err == NGX_ENOENT) {
            ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                           ""http file cache \""%s\"" not found"",
                           file.name.data);
            return;
        }

        ngx_log_erro...",1,1,http\ngx_http_file_cache.c,ngx_http_file_cache_update_header,,false,1430,1559,ngx_http_file_cache_update_header,,,50,void ngx_http_file_cache_update_header (ngx_http_request_t*)
275166,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_cache_send(ngx_http_request_t *r)
{
    ngx_int_t          rc;
    ngx_buf_t         *b;
    ngx_chain_t        out;
    ngx_http_cache_t  *c;

    c = r->cache;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http file cache send: %s"", c->file.name.data);

    if (r != r->main && c->length - c->body_start == 0) {
        return ngx_http_send_header(r);
    }

    /* we need to allocate all before the header would be sent */

    b = ngx_calloc_buf(r->pool);
    if (b == NULL) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    b->file = ngx_pcalloc(r->pool, sizeof(ngx_file_t));
    if (b->file == NULL) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    rc = ngx_http_send_header(r);

    if (rc == NGX_ERROR || rc > NGX_OK || r->header_only) {
        return rc;
    }

    b->file_pos = c->body_start;
    b->file_last = c->length;

    b->in_file = (c->length - c->body_start) ? 1: 0;
    b->last_buf = (r == r->mai...",1,1,http\ngx_http_file_cache.c,ngx_http_cache_send,,false,1562,1612,ngx_http_cache_send,,,51,ngx_int_t ngx_http_cache_send (ngx_http_request_t*)
275360,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"void
ngx_http_file_cache_free(ngx_http_cache_t *c, ngx_temp_file_t *tf)
{
    ngx_http_file_cache_t       *cache;
    ngx_http_file_cache_node_t  *fcn;

    if (c->updated || c->node == NULL) {
        return;
    }

    cache = c->file_cache;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->file.log, 0,
                   ""http file cache free, fd: %d"", c->file.fd);

    ngx_shmtx_lock(&cache->shpool->mutex);

    fcn = c->node;
    fcn->count--;

    if (c->updating && fcn->lock_time == c->lock_time) {
        fcn->updating = 0;
    }

    if (c->error) {
        fcn->error = c->error;

        if (c->valid_sec) {
            fcn->valid_sec = c->valid_sec;
            fcn->valid_msec = c->valid_msec;
        }

    } else if (!fcn->exists && fcn->count == 0 && c->min_uses == 1) {
        ngx_queue_remove(&fcn->queue);
        ngx_rbtree_delete(&cache->sh->rbtree, &fcn->node);
        ngx_slab_free_locked(cache->shpool, fcn);
        cache->sh->count--;
        c->node = NULL;
    }

   ...",1,1,http\ngx_http_file_cache.c,ngx_http_file_cache_free,,false,1615,1677,ngx_http_file_cache_free,,,52,"void ngx_http_file_cache_free (ngx_http_cache_t*,ngx_temp_file_t*)"
275590,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static void
ngx_http_file_cache_cleanup(void *data)
{
    ngx_http_cache_t  *c = data;

    if (c->updated) {
        return;
    }

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->file.log, 0,
                   ""http file cache cleanup"");

    if (c->updating && !c->background) {
        ngx_log_error(NGX_LOG_ALERT, c->file.log, 0,
                      ""stalled cache updating, error:%ui"", c->error);
    }

    ngx_http_file_cache_free(c, NULL);
}",1,1,http\ngx_http_file_cache.c,ngx_http_file_cache_cleanup,,false,1680,1698,ngx_http_file_cache_cleanup,,,53,void ngx_http_file_cache_cleanup (void*)
275639,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static time_t
ngx_http_file_cache_forced_expire(ngx_http_file_cache_t *cache)
{
    u_char                      *name, *p;
    size_t                       len;
    time_t                       wait;
    ngx_uint_t                   tries;
    ngx_path_t                  *path;
    ngx_queue_t                 *q, *sentinel;
    ngx_http_file_cache_node_t  *fcn;
    u_char                       key[2 * NGX_HTTP_CACHE_KEY_LEN];

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, ngx_cycle->log, 0,
                   ""http file cache forced expire"");

    path = cache->path;
    len = path->name.len + 1 + path->len + 2 * NGX_HTTP_CACHE_KEY_LEN;

    name = ngx_alloc(len + 1, ngx_cycle->log);
    if (name == NULL) {
        return 10;
    }

    ngx_memcpy(name, path->name.data, path->name.len);

    wait = 10;
    tries = 20;
    sentinel = NULL;

    ngx_shmtx_lock(&cache->shpool->mutex);

    for ( ;; ) {
        if (ngx_queue_empty(&cache->sh->queue)) {
            break;
        }

        q =...",1,1,http\ngx_http_file_cache.c,ngx_http_file_cache_forced_expire,,false,1701,1792,ngx_http_file_cache_forced_expire,,,54,time_t ngx_http_file_cache_forced_expire (ngx_http_file_cache_t*)
275903,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static time_t
ngx_http_file_cache_expire(ngx_http_file_cache_t *cache)
{
    u_char                      *name, *p;
    size_t                       len;
    time_t                       now, wait;
    ngx_path_t                  *path;
    ngx_msec_t                   elapsed;
    ngx_queue_t                 *q;
    ngx_http_file_cache_node_t  *fcn;
    u_char                       key[2 * NGX_HTTP_CACHE_KEY_LEN];

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, ngx_cycle->log, 0,
                   ""http file cache expire"");

    path = cache->path;
    len = path->name.len + 1 + path->len + 2 * NGX_HTTP_CACHE_KEY_LEN;

    name = ngx_alloc(len + 1, ngx_cycle->log);
    if (name == NULL) {
        return 10;
    }

    ngx_memcpy(name, path->name.data, path->name.len);

    now = ngx_time();

    ngx_shmtx_lock(&cache->shpool->mutex);

    for ( ;; ) {

        if (ngx_quit || ngx_terminate) {
            wait = 1;
            break;
        }

        if (ngx_queue_empty(&cache->sh->queue...",1,1,http\ngx_http_file_cache.c,ngx_http_file_cache_expire,,false,1795,1903,ngx_http_file_cache_expire,,,55,time_t ngx_http_file_cache_expire (ngx_http_file_cache_t*)
276213,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static void
ngx_http_file_cache_delete(ngx_http_file_cache_t *cache, ngx_queue_t *q,
    u_char *name)
{
    u_char                      *p;
    size_t                       len;
    ngx_path_t                  *path;
    ngx_http_file_cache_node_t  *fcn;

    fcn = ngx_queue_data(q, ngx_http_file_cache_node_t, queue);

    if (fcn->exists) {
        cache->sh->size -= fcn->fs_size;

        path = cache->path;
        p = name + path->name.len + 1 + path->len;
        p = ngx_hex_dump(p, (u_char *) &fcn->node.key,
                         sizeof(ngx_rbtree_key_t));
        len = NGX_HTTP_CACHE_KEY_LEN - sizeof(ngx_rbtree_key_t);
        p = ngx_hex_dump(p, fcn->key, len);
        *p = '\0';

        fcn->count++;
        fcn->deleting = 1;
        ngx_shmtx_unlock(&cache->shpool->mutex);

        len = path->name.len + 1 + path->len + 2 * NGX_HTTP_CACHE_KEY_LEN;
        ngx_create_hashed_filename(path, name, len);

        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, ngx_cycle->log, 0,
     ...",1,1,http\ngx_http_file_cache.c,ngx_http_file_cache_delete,,false,1906,1954,ngx_http_file_cache_delete,,,56,"void ngx_http_file_cache_delete (ngx_http_file_cache_t*,ngx_queue_t*,u_char*)"
276395,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static ngx_msec_t
ngx_http_file_cache_manager(void *data)
{
    ngx_http_file_cache_t  *cache = data;

    off_t       size;
    time_t      wait;
    ngx_msec_t  elapsed, next;
    ngx_uint_t  count, watermark;

    cache->last = ngx_current_msec;
    cache->files = 0;

    next = (ngx_msec_t) ngx_http_file_cache_expire(cache) * 1000;

    if (next == 0) {
        next = cache->manager_sleep;
        goto done;
    }

    for ( ;; ) {
        ngx_shmtx_lock(&cache->shpool->mutex);

        size = cache->sh->size;
        count = cache->sh->count;
        watermark = cache->sh->watermark;

        ngx_shmtx_unlock(&cache->shpool->mutex);

        ngx_log_debug3(NGX_LOG_DEBUG_HTTP, ngx_cycle->log, 0,
                       ""http file cache size: %O c:%ui w:%i"",
                       size, count, (ngx_int_t) watermark);

        if (size < cache->max_size && count < watermark) {
            break;
        }

        wait = ngx_http_file_cache_forced_expire(cache);

        if (wait >...",1,1,http\ngx_http_file_cache.c,ngx_http_file_cache_manager,,false,1957,2029,ngx_http_file_cache_manager,,,57,ngx_msec_t ngx_http_file_cache_manager (void*)
276587,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static void
ngx_http_file_cache_loader(void *data)
{
    ngx_http_file_cache_t  *cache = data;

    ngx_tree_ctx_t  tree;

    if (!cache->sh->cold || cache->sh->loading) {
        return;
    }

    if (!ngx_atomic_cmp_set(&cache->sh->loading, 0, ngx_pid)) {
        return;
    }

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, ngx_cycle->log, 0,
                   ""http file cache loader"");

    tree.init_handler = NULL;
    tree.file_handler = ngx_http_file_cache_manage_file;
    tree.pre_tree_handler = ngx_http_file_cache_manage_directory;
    tree.post_tree_handler = ngx_http_file_cache_noop;
    tree.spec_handler = ngx_http_file_cache_delete_file;
    tree.data = cache;
    tree.alloc = 0;
    tree.log = ngx_cycle->log;

    cache->last = ngx_current_msec;
    cache->files = 0;

    if (ngx_walk_tree(&tree, &cache->path->name) == NGX_ABORT) {
        cache->sh->loading = 0;
        return;
    }

    cache->sh->cold = 0;
    cache->sh->loading = 0;

    ngx_log_error(NGX_LOG_NOTICE, ng...",1,1,http\ngx_http_file_cache.c,ngx_http_file_cache_loader,,false,2032,2075,ngx_http_file_cache_loader,,,58,void ngx_http_file_cache_loader (void*)
276750,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_file_cache_noop(ngx_tree_ctx_t *ctx, ngx_str_t *path)
{
    return NGX_OK;
}",1,1,http\ngx_http_file_cache.c,ngx_http_file_cache_noop,,false,2078,2082,ngx_http_file_cache_noop,,,59,"ngx_int_t ngx_http_file_cache_noop (ngx_tree_ctx_t*,ngx_str_t*)"
276758,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_file_cache_manage_file(ngx_tree_ctx_t *ctx, ngx_str_t *path)
{
    ngx_msec_t              elapsed;
    ngx_http_file_cache_t  *cache;

    cache = ctx->data;

    if (ngx_http_file_cache_add_file(ctx, path) != NGX_OK) {
        (void) ngx_http_file_cache_delete_file(ctx, path);
    }

    if (++cache->files >= cache->loader_files) {
        ngx_http_file_cache_loader_sleep(cache);

    } else {
        ngx_time_update();

        elapsed = ngx_abs((ngx_msec_int_t) (ngx_current_msec - cache->last));

        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, ngx_cycle->log, 0,
                       ""http file cache loader time elapsed: %M"", elapsed);

        if (elapsed >= cache->loader_threshold) {
            ngx_http_file_cache_loader_sleep(cache);
        }
    }

    return (ngx_quit || ngx_terminate) ? NGX_ABORT : NGX_OK;
}",1,1,http\ngx_http_file_cache.c,ngx_http_file_cache_manage_file,,false,2085,2114,ngx_http_file_cache_manage_file,,,60,"ngx_int_t ngx_http_file_cache_manage_file (ngx_tree_ctx_t*,ngx_str_t*)"
276831,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_file_cache_manage_directory(ngx_tree_ctx_t *ctx, ngx_str_t *path)
{
    if (path->len >= 5
        && ngx_strncmp(path->data + path->len - 5, ""/temp"", 5) == 0)
    {
        return NGX_DECLINED;
    }

    return NGX_OK;
}",1,1,http\ngx_http_file_cache.c,ngx_http_file_cache_manage_directory,,false,2117,2127,ngx_http_file_cache_manage_directory,,,61,"ngx_int_t ngx_http_file_cache_manage_directory (ngx_tree_ctx_t*,ngx_str_t*)"
276863,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static void
ngx_http_file_cache_loader_sleep(ngx_http_file_cache_t *cache)
{
    ngx_msleep(cache->loader_sleep);

    ngx_time_update();

    cache->last = ngx_current_msec;
    cache->files = 0;
}",1,1,http\ngx_http_file_cache.c,ngx_http_file_cache_loader_sleep,,false,2130,2139,ngx_http_file_cache_loader_sleep,,,62,void ngx_http_file_cache_loader_sleep (ngx_http_file_cache_t*)
276883,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_file_cache_add_file(ngx_tree_ctx_t *ctx, ngx_str_t *name)
{
    u_char                 *p;
    ngx_int_t               n;
    ngx_uint_t              i;
    ngx_http_cache_t        c;
    ngx_http_file_cache_t  *cache;

    if (name->len < 2 * NGX_HTTP_CACHE_KEY_LEN) {
        return NGX_ERROR;
    }

    /*
     * Temporary files in cache have a suffix consisting of a dot
     * followed by 10 digits.
     */

    if (name->len >= 2 * NGX_HTTP_CACHE_KEY_LEN + 1 + 10
        && name->data[name->len - 10 - 1] == '.')
    {
        return NGX_OK;
    }

    if (ctx->size < (off_t) sizeof(ngx_http_file_cache_header_t)) {
        ngx_log_error(NGX_LOG_CRIT, ctx->log, 0,
                      ""cache file \""%s\"" is too small"", name->data);
        return NGX_ERROR;
    }

    ngx_memzero(&c, sizeof(ngx_http_cache_t));
    cache = ctx->data;

    c.length = ctx->size;
    c.fs_size = (ctx->fs_size + cache->bsize - 1) / cache->bsize;

    p = &name->data[name->len ...",1,1,http\ngx_http_file_cache.c,ngx_http_file_cache_add_file,,false,2142,2193,ngx_http_file_cache_add_file,,,63,"ngx_int_t ngx_http_file_cache_add_file (ngx_tree_ctx_t*,ngx_str_t*)"
277044,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_file_cache_add(ngx_http_file_cache_t *cache, ngx_http_cache_t *c)
{
    ngx_http_file_cache_node_t  *fcn;

    ngx_shmtx_lock(&cache->shpool->mutex);

    fcn = ngx_http_file_cache_lookup(cache, c->key);

    if (fcn == NULL) {

        fcn = ngx_slab_calloc_locked(cache->shpool,
                                     sizeof(ngx_http_file_cache_node_t));
        if (fcn == NULL) {
            ngx_http_file_cache_set_watermark(cache);

            if (cache->fail_time != ngx_time()) {
                cache->fail_time = ngx_time();
                ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, 0,
                           ""could not allocate node%s"", cache->shpool->log_ctx);
            }

            ngx_shmtx_unlock(&cache->shpool->mutex);
            return NGX_ERROR;
        }

        cache->sh->count++;

        ngx_memcpy((u_char *) &fcn->node.key, c->key, sizeof(ngx_rbtree_key_t));

        ngx_memcpy(fcn->key, &c->key[sizeof(ngx_rbtree_key_t)],
        ...",1,1,http\ngx_http_file_cache.c,ngx_http_file_cache_add,,false,2196,2248,ngx_http_file_cache_add,,,64,"ngx_int_t ngx_http_file_cache_add (ngx_http_file_cache_t*,ngx_http_cache_t*)"
277226,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_file_cache_delete_file(ngx_tree_ctx_t *ctx, ngx_str_t *path)
{
    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx->log, 0,
                   ""http file cache delete: \""%s\"""", path->data);

    if (ngx_delete_file(path->data) == NGX_FILE_ERROR) {
        ngx_log_error(NGX_LOG_CRIT, ctx->log, ngx_errno,
                      ngx_delete_file_n "" \""%s\"" failed"", path->data);
    }

    return NGX_OK;
}",1,1,http\ngx_http_file_cache.c,ngx_http_file_cache_delete_file,,false,2251,2263,ngx_http_file_cache_delete_file,,,65,"ngx_int_t ngx_http_file_cache_delete_file (ngx_tree_ctx_t*,ngx_str_t*)"
277253,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"static void
ngx_http_file_cache_set_watermark(ngx_http_file_cache_t *cache)
{
    cache->sh->watermark = cache->sh->count - cache->sh->count / 8;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, ngx_cycle->log, 0,
                   ""http file cache watermark: %ui"", cache->sh->watermark);
}",1,1,http\ngx_http_file_cache.c,ngx_http_file_cache_set_watermark,,false,2266,2273,ngx_http_file_cache_set_watermark,,,66,void ngx_http_file_cache_set_watermark (ngx_http_file_cache_t*)
277289,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"time_t
ngx_http_file_cache_valid(ngx_array_t *cache_valid, ngx_uint_t status)
{
    ngx_uint_t               i;
    ngx_http_cache_valid_t  *valid;

    if (cache_valid == NULL) {
        return 0;
    }

    valid = cache_valid->elts;
    for (i = 0; i < cache_valid->nelts; i++) {

        if (valid[i].status == 0) {
            return valid[i].valid;
        }

        if (valid[i].status == status) {
            return valid[i].valid;
        }
    }

    return 0;
}",1,1,http\ngx_http_file_cache.c,ngx_http_file_cache_valid,,false,2276,2299,ngx_http_file_cache_valid,,,67,"time_t ngx_http_file_cache_valid (ngx_array_t*,ngx_uint_t)"
277354,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"char *
ngx_http_file_cache_set_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char  *confp = conf;

    off_t                   max_size;
    u_char                 *last, *p;
    time_t                  inactive;
    ssize_t                 size;
    ngx_str_t               s, name, *value;
    ngx_int_t               loader_files, manager_files;
    ngx_msec_t              loader_sleep, manager_sleep, loader_threshold,
                            manager_threshold;
    ngx_uint_t              i, n, use_temp_path;
    ngx_array_t            *caches;
    ngx_http_file_cache_t  *cache, **ce;

    cache = ngx_pcalloc(cf->pool, sizeof(ngx_http_file_cache_t));
    if (cache == NULL) {
        return NGX_CONF_ERROR;
    }

    cache->path = ngx_pcalloc(cf->pool, sizeof(ngx_path_t));
    if (cache->path == NULL) {
        return NGX_CONF_ERROR;
    }

    use_temp_path = 1;

    inactive = 600;

    loader_files = 100;
    loader_sleep = 50;
    loader_threshold = 200;

    ma...",1,1,http\ngx_http_file_cache.c,ngx_http_file_cache_set_slot,,false,2302,2621,ngx_http_file_cache_set_slot,,,68,"char* ngx_http_file_cache_set_slot (ngx_conf_t*,ngx_command_t*,void*)"
278512,METHOD,http\ngx_http_file_cache.c:<global>,TYPE_DECL,"char *
ngx_http_file_cache_valid_set_slot(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf)
{
    char  *p = conf;

    time_t                    valid;
    ngx_str_t                *value;
    ngx_int_t                 status;
    ngx_uint_t                i, n;
    ngx_array_t             **a;
    ngx_http_cache_valid_t   *v;
    static ngx_uint_t         statuses[] = { 200, 301, 302 };

    a = (ngx_array_t **) (p + cmd->offset);

    if (*a == NGX_CONF_UNSET_PTR) {
        *a = ngx_array_create(cf->pool, 1, sizeof(ngx_http_cache_valid_t));
        if (*a == NULL) {
            return NGX_CONF_ERROR;
        }
    }

    value = cf->args->elts;
    n = cf->args->nelts - 1;

    valid = ngx_parse_time(&value[n], 1);
    if (valid == (time_t) NGX_ERROR) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""invalid time value \""%V\"""", &value[n]);
        return NGX_CONF_ERROR;
    }

    if (n == 1) {

        for (i = 0; i < 3; i++) {
            v = ngx_...",1,1,http\ngx_http_file_cache.c,ngx_http_file_cache_valid_set_slot,,false,2624,2698,ngx_http_file_cache_valid_set_slot,,,69,"char* ngx_http_file_cache_valid_set_slot (ngx_conf_t*,ngx_command_t*,void*)"
278749,METHOD,http\ngx_http_header_filter_module.c:<global>,TYPE_DECL,<global>,1,24,http\ngx_http_header_filter_module.c,http\ngx_http_header_filter_module.c:<global>,,false,1,630,<global>,,,1,
278751,METHOD,http\ngx_http_header_filter_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_header_filter_init(ngx_conf_t *cf);,18,60,http\ngx_http_header_filter_module.c,ngx_http_header_filter_init,,false,14,14,ngx_http_header_filter_init,,,1,ngx_int_t ngx_http_header_filter_init (ngx_conf_t*)
278756,METHOD,http\ngx_http_header_filter_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_header_filter(ngx_http_request_t *r);,18,62,http\ngx_http_header_filter_module.c,ngx_http_header_filter,,false,15,15,ngx_http_header_filter,,,2,ngx_int_t ngx_http_header_filter (ngx_http_request_t*)
278953,METHOD,http\ngx_http_header_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_header_filter(ngx_http_request_t *r)
{
    u_char                    *p;
    size_t                     len;
    ngx_str_t                  host, *status_line;
    ngx_buf_t                 *b;
    ngx_uint_t                 status, i, port;
    ngx_chain_t                out;
    ngx_list_part_t           *part;
    ngx_table_elt_t           *header;
    ngx_connection_t          *c;
    ngx_http_core_loc_conf_t  *clcf;
    ngx_http_core_srv_conf_t  *cscf;
    u_char                     addr[NGX_SOCKADDR_STRLEN];

    if (r->header_sent) {
        return NGX_OK;
    }

    r->header_sent = 1;

    if (r != r->main) {
        return NGX_OK;
    }

    if (r->http_version < NGX_HTTP_VERSION_10) {
        return NGX_OK;
    }

    if (r->method == NGX_HTTP_HEAD) {
        r->header_only = 1;
    }

    if (r->headers_out.last_modified_time != -1) {
        if (r->headers_out.status != NGX_HTTP_OK
            && r->headers_out.status != NGX_HTTP_PARTIAL_CONTEN...",1,24,http\ngx_http_header_filter_module.c,ngx_http_header_filter,,false,156,621,ngx_http_header_filter,,,14,ngx_int_t ngx_http_header_filter (ngx_http_request_t*)
280612,METHOD,http\ngx_http_header_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_header_filter_init(ngx_conf_t *cf)
{
    ngx_http_top_header_filter = ngx_http_header_filter;

    return NGX_OK;
}",1,1,http\ngx_http_header_filter_module.c,ngx_http_header_filter_init,,false,624,630,ngx_http_header_filter_init,,,15,ngx_int_t ngx_http_header_filter_init (ngx_conf_t*)
280631,METHOD,http\ngx_http_parse.c:<global>,TYPE_DECL,<global>,1,24,http\ngx_http_parse.c,http\ngx_http_parse.c:<global>,,false,1,2430,<global>,,,1,
280645,METHOD,http\ngx_http_parse.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_parse_request_line(ngx_http_request_t *r, ngx_buf_t *b)
{
    u_char  c, ch, *p, *m;
    enum {
        sw_start = 0,
        sw_method,
        sw_spaces_before_uri,
        sw_schema,
        sw_schema_slash,
        sw_schema_slash_slash,
        sw_host_start,
        sw_host,
        sw_host_end,
        sw_host_ip_literal,
        sw_port,
        sw_host_http_09,
        sw_after_slash_in_uri,
        sw_check_uri,
        sw_check_uri_http_09,
        sw_uri,
        sw_http_09,
        sw_http_H,
        sw_http_HT,
        sw_http_HTT,
        sw_http_HTTP,
        sw_first_major_digit,
        sw_major_digit,
        sw_first_minor_digit,
        sw_minor_digit,
        sw_spaces_after_digit,
        sw_almost_done
    } state;

    state = r->state;

    for (p = b->pos; p < b->last; p++) {
        ch = *p;

        switch (state) {

        /* HTTP methods: GET, HEAD, POST */
        case sw_start:
            r->request_start = p;

            if (ch...",1,24,http\ngx_http_parse.c,ngx_http_parse_request_line,,false,103,842,ngx_http_parse_request_line,,,3,"ngx_int_t ngx_http_parse_request_line (ngx_http_request_t*,ngx_buf_t*)"
282662,METHOD,http\ngx_http_parse.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_parse_header_line(ngx_http_request_t *r, ngx_buf_t *b,
    ngx_uint_t allow_underscores)
{
    u_char      c, ch, *p;
    ngx_uint_t  hash, i;
    enum {
        sw_start = 0,
        sw_name,
        sw_space_before_value,
        sw_value,
        sw_space_after_value,
        sw_ignore_line,
        sw_almost_done,
        sw_header_almost_done
    } state;

    /* the last '\0' is not needed because string is zero terminated */

    static u_char  lowcase[] =
        ""\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0""
        ""\0\0\0\0\0\0\0\0\0\0\0\0\0-\0\0"" ""0123456789\0\0\0\0\0\0""
        ""\0abcdefghijklmnopqrstuvwxyz\0\0\0\0\0""
        ""\0abcdefghijklmnopqrstuvwxyz\0\0\0\0\0""
        ""\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0""
        ""\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0""
        ""\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0""
        ""\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0...",1,1,http\ngx_http_parse.c,ngx_http_parse_header_line,,false,845,1115,ngx_http_parse_header_line,,,4,"ngx_int_t ngx_http_parse_header_line (ngx_http_request_t*,ngx_buf_t*,ngx_uint_t)"
283221,METHOD,http\ngx_http_parse.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_parse_uri(ngx_http_request_t *r)
{
    u_char  *p, ch;
    enum {
        sw_start = 0,
        sw_after_slash_in_uri,
        sw_check_uri,
        sw_uri
    } state;

    state = sw_start;

    for (p = r->uri_start; p != r->uri_end; p++) {

        ch = *p;

        switch (state) {

        case sw_start:

            if (ch != '/') {
                return NGX_ERROR;
            }

            state = sw_after_slash_in_uri;
            break;

        /* check ""/."", ""//"", ""%"", and ""\"" (Win32) in URI */
        case sw_after_slash_in_uri:

            if (usual[ch >> 5] & (1U << (ch & 0x1f))) {
                state = sw_check_uri;
                break;
            }

            switch (ch) {
            case ' ':
                r->space_in_uri = 1;
                state = sw_check_uri;
                break;
            case '.':
                r->complex_uri = 1;
                state = sw_uri;
                break;
            case '%':
              ...",1,1,http\ngx_http_parse.c,ngx_http_parse_uri,,false,1118,1263,ngx_http_parse_uri,,,5,ngx_int_t ngx_http_parse_uri (ngx_http_request_t*)
283501,METHOD,http\ngx_http_parse.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_parse_complex_uri(ngx_http_request_t *r, ngx_uint_t merge_slashes)
{
    u_char  c, ch, decoded, *p, *u;
    enum {
        sw_usual = 0,
        sw_slash,
        sw_dot,
        sw_dot_dot,
        sw_quoted,
        sw_quoted_second
    } state, quoted_state;

#if (NGX_SUPPRESS_WARN)
    decoded = '\0';
    quoted_state = sw_usual;
#endif

    state = sw_usual;
    p = r->uri_start;
    u = r->uri.data;
    r->uri_ext = NULL;
    r->args_start = NULL;

    ch = *p++;

    while (p <= r->uri_end) {

        /*
         * we use ""ch = *p++"" inside the cycle, but this operation is safe,
         * because after the URI there is always at least one character:
         * the line feed
         */

        ngx_log_debug3(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                       ""s:%d in:'%Xd:%c'"", state, ch, ch);

        switch (state) {

        case sw_usual:

            if (usual[ch >> 5] & (1U << (ch & 0x1f))) {
                *u++ = ch;
              ...",1,1,http\ngx_http_parse.c,ngx_http_parse_complex_uri,,false,1266,1635,ngx_http_parse_complex_uri,,,6,"ngx_int_t ngx_http_parse_complex_uri (ngx_http_request_t*,ngx_uint_t)"
284355,METHOD,http\ngx_http_parse.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_parse_status_line(ngx_http_request_t *r, ngx_buf_t *b,
    ngx_http_status_t *status)
{
    u_char   ch;
    u_char  *p;
    enum {
        sw_start = 0,
        sw_H,
        sw_HT,
        sw_HTT,
        sw_HTTP,
        sw_first_major_digit,
        sw_major_digit,
        sw_first_minor_digit,
        sw_minor_digit,
        sw_status,
        sw_space_after_status,
        sw_status_text,
        sw_almost_done
    } state;

    state = r->state;

    for (p = b->pos; p < b->last; p++) {
        ch = *p;

        switch (state) {

        /* ""HTTP/"" */
        case sw_start:
            switch (ch) {
            case 'H':
                state = sw_H;
                break;
            default:
                return NGX_ERROR;
            }
            break;

        case sw_H:
            switch (ch) {
            case 'T':
                state = sw_HT;
                break;
            default:
                return NGX_ERROR;
            }
          ...",1,1,http\ngx_http_parse.c,ngx_http_parse_status_line,,false,1638,1853,ngx_http_parse_status_line,,,7,"ngx_int_t ngx_http_parse_status_line (ngx_http_request_t*,ngx_buf_t*,ngx_http_status_t*)"
284771,METHOD,http\ngx_http_parse.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_parse_unsafe_uri(ngx_http_request_t *r, ngx_str_t *uri,
    ngx_str_t *args, ngx_uint_t *flags)
{
    u_char      ch, *p, *src, *dst;
    size_t      len;
    ngx_uint_t  quoted;

    len = uri->len;
    p = uri->data;
    quoted = 0;

    if (len == 0 || p[0] == '?') {
        goto unsafe;
    }

    if (p[0] == '.' && len > 1 && p[1] == '.'
        && (len == 2 || ngx_path_separator(p[2])))
    {
        goto unsafe;
    }

    for ( /* void */ ; len; len--) {

        ch = *p++;

        if (ch == '%') {
            quoted = 1;
            continue;
        }

        if (usual[ch >> 5] & (1U << (ch & 0x1f))) {
            continue;
        }

        if (ch == '?') {
            args->len = len - 1;
            args->data = p;
            uri->len -= len;

            break;
        }

        if (ch == '\0') {
            goto unsafe;
        }

        if (ngx_path_separator(ch) && len > 2) {

            /* detect ""/../"" and ""/.."" */

            if (p[0] =...",1,1,http\ngx_http_parse.c,ngx_http_parse_unsafe_uri,,false,1856,1975,ngx_http_parse_unsafe_uri,,,8,"ngx_int_t ngx_http_parse_unsafe_uri (ngx_http_request_t*,ngx_str_t*,ngx_str_t*,ngx_uint_t*)"
285104,METHOD,http\ngx_http_parse.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_parse_multi_header_lines(ngx_array_t *headers, ngx_str_t *name,
    ngx_str_t *value)
{
    ngx_uint_t         i;
    u_char            *start, *last, *end, ch;
    ngx_table_elt_t  **h;

    h = headers->elts;

    for (i = 0; i < headers->nelts; i++) {

        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, headers->pool->log, 0,
                       ""parse header: \""%V: %V\"""", &h[i]->key, &h[i]->value);

        if (name->len > h[i]->value.len) {
            continue;
        }

        start = h[i]->value.data;
        end = h[i]->value.data + h[i]->value.len;

        while (start < end) {

            if (ngx_strncasecmp(start, name->data, name->len) != 0) {
                goto skip;
            }

            for (start += name->len; start < end && *start == ' '; start++) {
                /* void */
            }

            if (value == NULL) {
                if (start == end || *start == ',') {
                    return i;
                }

                go...",1,1,http\ngx_http_parse.c,ngx_http_parse_multi_header_lines,,false,1978,2048,ngx_http_parse_multi_header_lines,,,9,"ngx_int_t ngx_http_parse_multi_header_lines (ngx_array_t*,ngx_str_t*,ngx_str_t*)"
285339,METHOD,http\ngx_http_parse.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_parse_set_cookie_lines(ngx_array_t *headers, ngx_str_t *name,
    ngx_str_t *value)
{
    ngx_uint_t         i;
    u_char            *start, *last, *end;
    ngx_table_elt_t  **h;

    h = headers->elts;

    for (i = 0; i < headers->nelts; i++) {

        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, headers->pool->log, 0,
                       ""parse header: \""%V: %V\"""", &h[i]->key, &h[i]->value);

        if (name->len >= h[i]->value.len) {
            continue;
        }

        start = h[i]->value.data;
        end = h[i]->value.data + h[i]->value.len;

        if (ngx_strncasecmp(start, name->data, name->len) != 0) {
            continue;
        }

        for (start += name->len; start < end && *start == ' '; start++) {
            /* void */
        }

        if (start == end || *start++ != '=') {
            /* the invalid header value */
            continue;
        }

        while (start < end && *start == ' ') { start++; }

        for (last = start; last ...",1,1,http\ngx_http_parse.c,ngx_http_parse_set_cookie_lines,,false,2051,2099,ngx_http_parse_set_cookie_lines,,,10,"ngx_int_t ngx_http_parse_set_cookie_lines (ngx_array_t*,ngx_str_t*,ngx_str_t*)"
285517,METHOD,http\ngx_http_parse.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_arg(ngx_http_request_t *r, u_char *name, size_t len, ngx_str_t *value)
{
    u_char  *p, *last;

    if (r->args.len == 0) {
        return NGX_DECLINED;
    }

    p = r->args.data;
    last = p + r->args.len;

    for ( /* void */ ; p < last; p++) {

        /* we need '=' after name, so drop one char from last */

        p = ngx_strlcasestrn(p, last - 1, name, len - 1);

        if (p == NULL) {
            return NGX_DECLINED;
        }

        if ((p == r->args.data || *(p - 1) == '&') && *(p + len) == '=') {

            value->data = p + len + 1;

            p = ngx_strlchr(p, last, '&');

            if (p == NULL) {
                p = r->args.data + r->args.len;
            }

            value->len = p - value->data;

            return NGX_OK;
        }
    }

    return NGX_DECLINED;
}",1,1,http\ngx_http_parse.c,ngx_http_arg,,false,2102,2141,ngx_http_arg,,,11,"ngx_int_t ngx_http_arg (ngx_http_request_t*,u_char*,size_t,ngx_str_t*)"
285649,METHOD,http\ngx_http_parse.c:<global>,TYPE_DECL,"void
ngx_http_split_args(ngx_http_request_t *r, ngx_str_t *uri, ngx_str_t *args)
{
    u_char  *p, *last;

    last = uri->data + uri->len;

    p = ngx_strlchr(uri->data, last, '?');

    if (p) {
        uri->len = p - uri->data;
        p++;
        args->len = last - p;
        args->data = p;

    } else {
        args->len = 0;
    }
}",1,1,http\ngx_http_parse.c,ngx_http_split_args,,false,2144,2162,ngx_http_split_args,,,12,"void ngx_http_split_args (ngx_http_request_t*,ngx_str_t*,ngx_str_t*)"
285708,METHOD,http\ngx_http_parse.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_parse_chunked(ngx_http_request_t *r, ngx_buf_t *b,
    ngx_http_chunked_t *ctx)
{
    u_char     *pos, ch, c;
    ngx_int_t   rc;
    enum {
        sw_chunk_start = 0,
        sw_chunk_size,
        sw_chunk_extension,
        sw_chunk_extension_almost_done,
        sw_chunk_data,
        sw_after_data,
        sw_after_data_almost_done,
        sw_last_chunk_extension,
        sw_last_chunk_extension_almost_done,
        sw_trailer,
        sw_trailer_almost_done,
        sw_trailer_header,
        sw_trailer_header_almost_done
    } state;

    state = ctx->state;

    if (state == sw_chunk_data && ctx->size == 0) {
        state = sw_after_data;
    }

    rc = NGX_AGAIN;

    for (pos = b->pos; pos < b->last; pos++) {

        ch = *pos;

        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                       ""http chunked byte: %02Xd s:%d"", ch, state);

        switch (state) {

        case sw_chunk_start:
            if (ch >= '0' && ch <=...",1,1,http\ngx_http_parse.c,ngx_http_parse_chunked,,false,2165,2430,ngx_http_parse_chunked,,,13,"ngx_int_t ngx_http_parse_chunked (ngx_http_request_t*,ngx_buf_t*,ngx_http_chunked_t*)"
286256,METHOD,http\ngx_http_postpone_filter_module.c:<global>,TYPE_DECL,<global>,1,1,http\ngx_http_postpone_filter_module.c,http\ngx_http_postpone_filter_module.c:<global>,,false,1,259,<global>,,,1,
286258,METHOD,http\ngx_http_postpone_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_postpone_filter_add(ngx_http_request_t *r,
    ngx_chain_t *in);",18,20,http\ngx_http_postpone_filter_module.c,ngx_http_postpone_filter_add,,false,13,14,ngx_http_postpone_filter_add,,,1,"ngx_int_t ngx_http_postpone_filter_add (ngx_http_request_t*,ngx_chain_t*)"
286264,METHOD,http\ngx_http_postpone_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_postpone_filter_in_memory(ngx_http_request_t *r,
    ngx_chain_t *in);",18,20,http\ngx_http_postpone_filter_module.c,ngx_http_postpone_filter_in_memory,,false,15,16,ngx_http_postpone_filter_in_memory,,,2,"ngx_int_t ngx_http_postpone_filter_in_memory (ngx_http_request_t*,ngx_chain_t*)"
286270,METHOD,http\ngx_http_postpone_filter_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_postpone_filter_init(ngx_conf_t *cf);,18,62,http\ngx_http_postpone_filter_module.c,ngx_http_postpone_filter_init,,false,17,17,ngx_http_postpone_filter_init,,,3,ngx_int_t ngx_http_postpone_filter_init (ngx_conf_t*)
286305,METHOD,http\ngx_http_postpone_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_postpone_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    ngx_connection_t              *c;
    ngx_http_postponed_request_t  *pr;

    c = r->connection;

    ngx_log_debug3(NGX_LOG_DEBUG_HTTP, c->log, 0,
                   ""http postpone filter \""%V?%V\"" %p"", &r->uri, &r->args, in);

    if (r->subrequest_in_memory) {
        return ngx_http_postpone_filter_in_memory(r, in);
    }

    if (r != c->data) {

        if (in) {
            if (ngx_http_postpone_filter_add(r, in) != NGX_OK) {
                return NGX_ERROR;
            }

            return NGX_OK;
        }

#if 0
        /* TODO: SSI may pass NULL */
        ngx_log_error(NGX_LOG_ALERT, c->log, 0,
                      ""http postpone filter NULL inactive request"");
#endif

        return NGX_OK;
    }

    if (r->postponed == NULL) {

        if (in || c->buffered) {
            return ngx_http_next_body_filter(r->main, in);
        }

        return NGX_OK;
    }

    if (in) {
      ...",1,1,http\ngx_http_postpone_filter_module.c,ngx_http_postpone_filter,,false,54,138,ngx_http_postpone_filter,,,9,"ngx_int_t ngx_http_postpone_filter (ngx_http_request_t*,ngx_chain_t*)"
286507,METHOD,http\ngx_http_postpone_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_postpone_filter_add(ngx_http_request_t *r, ngx_chain_t *in)
{
    ngx_http_postponed_request_t  *pr, **ppr;

    if (r->postponed) {
        for (pr = r->postponed; pr->next; pr = pr->next) { /* void */ }

        if (pr->request == NULL) {
            goto found;
        }

        ppr = &pr->next;

    } else {
        ppr = &r->postponed;
    }

    pr = ngx_palloc(r->pool, sizeof(ngx_http_postponed_request_t));
    if (pr == NULL) {
        return NGX_ERROR;
    }

    *ppr = pr;

    pr->request = NULL;
    pr->out = NULL;
    pr->next = NULL;

found:

    if (ngx_chain_add_copy(r->pool, &pr->out, in) == NGX_OK) {
        return NGX_OK;
    }

    return NGX_ERROR;
}",1,1,http\ngx_http_postpone_filter_module.c,ngx_http_postpone_filter_add,,false,141,177,ngx_http_postpone_filter_add,,,10,"ngx_int_t ngx_http_postpone_filter_add (ngx_http_request_t*,ngx_chain_t*)"
286610,METHOD,http\ngx_http_postpone_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_postpone_filter_in_memory(ngx_http_request_t *r, ngx_chain_t *in)
{
    size_t                     len;
    ngx_buf_t                 *b;
    ngx_connection_t          *c;
    ngx_http_core_loc_conf_t  *clcf;

    c = r->connection;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,
                   ""http postpone filter in memory"");

    if (r->out == NULL) {
        clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

        if (r->headers_out.content_length_n != -1) {
            len = r->headers_out.content_length_n;

            if (len > clcf->subrequest_output_buffer_size) {
                ngx_log_error(NGX_LOG_ERR, c->log, 0,
                              ""too big subrequest response: %uz"", len);
                return NGX_ERROR;
            }

        } else {
            len = clcf->subrequest_output_buffer_size;
        }

        b = ngx_create_temp_buf(r->pool, len);
        if (b == NULL) {
            return NGX_ERROR;
        }...",1,1,http\ngx_http_postpone_filter_module.c,ngx_http_postpone_filter_in_memory,,false,180,249,ngx_http_postpone_filter_in_memory,,,11,"ngx_int_t ngx_http_postpone_filter_in_memory (ngx_http_request_t*,ngx_chain_t*)"
286827,METHOD,http\ngx_http_postpone_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_postpone_filter_init(ngx_conf_t *cf)
{
    ngx_http_next_body_filter = ngx_http_top_body_filter;
    ngx_http_top_body_filter = ngx_http_postpone_filter;

    return NGX_OK;
}",1,1,http\ngx_http_postpone_filter_module.c,ngx_http_postpone_filter_init,,false,252,259,ngx_http_postpone_filter_init,,,12,ngx_int_t ngx_http_postpone_filter_init (ngx_conf_t*)
286849,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,<global>,1,1,http\ngx_http_request.c,http\ngx_http_request.c:<global>,,false,1,3820,<global>,,,1,
286851,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,static void ngx_http_wait_request_handler(ngx_event_t *ev);,13,58,http\ngx_http_request.c,ngx_http_wait_request_handler,,false,13,13,ngx_http_wait_request_handler,,,1,void ngx_http_wait_request_handler (ngx_event_t*)
286856,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,static ngx_http_request_t *ngx_http_alloc_request(ngx_connection_t *c);,27,70,http\ngx_http_request.c,ngx_http_alloc_request,,false,14,14,ngx_http_alloc_request,,,2,ngx_http_request_t* ngx_http_alloc_request (ngx_connection_t*)
286861,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,static void ngx_http_process_request_line(ngx_event_t *rev);,13,59,http\ngx_http_request.c,ngx_http_process_request_line,,false,15,15,ngx_http_process_request_line,,,3,void ngx_http_process_request_line (ngx_event_t*)
286866,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,static void ngx_http_process_request_headers(ngx_event_t *rev);,13,62,http\ngx_http_request.c,ngx_http_process_request_headers,,false,16,16,ngx_http_process_request_headers,,,4,void ngx_http_process_request_headers (ngx_event_t*)
286871,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,static ssize_t ngx_http_read_request_header(ngx_http_request_t *r);,16,66,http\ngx_http_request.c,ngx_http_read_request_header,,false,17,17,ngx_http_read_request_header,,,5,ssize_t ngx_http_read_request_header (ngx_http_request_t*)
286876,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_alloc_large_header_buffer(ngx_http_request_t *r,
    ngx_uint_t request_line);",18,28,http\ngx_http_request.c,ngx_http_alloc_large_header_buffer,,false,18,19,ngx_http_alloc_large_header_buffer,,,6,"ngx_int_t ngx_http_alloc_large_header_buffer (ngx_http_request_t*,ngx_uint_t)"
286882,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_process_header_line(ngx_http_request_t *r,
    ngx_table_elt_t *h, ngx_uint_t offset);",18,42,http\ngx_http_request.c,ngx_http_process_header_line,,false,21,22,ngx_http_process_header_line,,,7,"ngx_int_t ngx_http_process_header_line (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
286889,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_process_unique_header_line(ngx_http_request_t *r,
    ngx_table_elt_t *h, ngx_uint_t offset);",18,42,http\ngx_http_request.c,ngx_http_process_unique_header_line,,false,23,24,ngx_http_process_unique_header_line,,,8,"ngx_int_t ngx_http_process_unique_header_line (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
286896,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_process_multi_header_lines(ngx_http_request_t *r,
    ngx_table_elt_t *h, ngx_uint_t offset);",18,42,http\ngx_http_request.c,ngx_http_process_multi_header_lines,,false,25,26,ngx_http_process_multi_header_lines,,,9,"ngx_int_t ngx_http_process_multi_header_lines (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
286903,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_process_host(ngx_http_request_t *r,
    ngx_table_elt_t *h, ngx_uint_t offset);",18,42,http\ngx_http_request.c,ngx_http_process_host,,false,27,28,ngx_http_process_host,,,10,"ngx_int_t ngx_http_process_host (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
286910,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_process_connection(ngx_http_request_t *r,
    ngx_table_elt_t *h, ngx_uint_t offset);",18,42,http\ngx_http_request.c,ngx_http_process_connection,,false,29,30,ngx_http_process_connection,,,11,"ngx_int_t ngx_http_process_connection (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
286917,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_process_user_agent(ngx_http_request_t *r,
    ngx_table_elt_t *h, ngx_uint_t offset);",18,42,http\ngx_http_request.c,ngx_http_process_user_agent,,false,31,32,ngx_http_process_user_agent,,,12,"ngx_int_t ngx_http_process_user_agent (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
286924,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_validate_host(ngx_str_t *host, ngx_pool_t *pool,
    ngx_uint_t alloc);",18,21,http\ngx_http_request.c,ngx_http_validate_host,,false,34,35,ngx_http_validate_host,,,13,"ngx_int_t ngx_http_validate_host (ngx_str_t*,ngx_pool_t*,ngx_uint_t)"
286931,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_set_virtual_server(ngx_http_request_t *r,
    ngx_str_t *host);",18,20,http\ngx_http_request.c,ngx_http_set_virtual_server,,false,36,37,ngx_http_set_virtual_server,,,14,"ngx_int_t ngx_http_set_virtual_server (ngx_http_request_t*,ngx_str_t*)"
286937,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_find_virtual_server(ngx_connection_t *c,
    ngx_http_virtual_names_t *virtual_names, ngx_str_t *host,
    ngx_http_request_t *r, ngx_http_core_srv_conf_t **cscfp);",18,60,http\ngx_http_request.c,ngx_http_find_virtual_server,,false,38,40,ngx_http_find_virtual_server,,,15,"ngx_int_t ngx_http_find_virtual_server (ngx_connection_t*,ngx_http_virtual_names_t*,ngx_str_t*,ngx_http_request_t*,ngx_http_core_srv_conf_t**)"
286946,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,static void ngx_http_request_handler(ngx_event_t *ev);,13,53,http\ngx_http_request.c,ngx_http_request_handler,,false,42,42,ngx_http_request_handler,,,16,void ngx_http_request_handler (ngx_event_t*)
286951,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static void ngx_http_terminate_request(ngx_http_request_t *r, ngx_int_t rc);",13,75,http\ngx_http_request.c,ngx_http_terminate_request,,false,43,43,ngx_http_terminate_request,,,17,"void ngx_http_terminate_request (ngx_http_request_t*,ngx_int_t)"
286957,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,static void ngx_http_terminate_handler(ngx_http_request_t *r);,13,61,http\ngx_http_request.c,ngx_http_terminate_handler,,false,44,44,ngx_http_terminate_handler,,,18,void ngx_http_terminate_handler (ngx_http_request_t*)
286962,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,static void ngx_http_finalize_connection(ngx_http_request_t *r);,13,63,http\ngx_http_request.c,ngx_http_finalize_connection,,false,45,45,ngx_http_finalize_connection,,,19,void ngx_http_finalize_connection (ngx_http_request_t*)
286967,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_set_write_handler(ngx_http_request_t *r);,18,66,http\ngx_http_request.c,ngx_http_set_write_handler,,false,46,46,ngx_http_set_write_handler,,,20,ngx_int_t ngx_http_set_write_handler (ngx_http_request_t*)
286972,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,static void ngx_http_writer(ngx_http_request_t *r);,13,50,http\ngx_http_request.c,ngx_http_writer,,false,47,47,ngx_http_writer,,,21,void ngx_http_writer (ngx_http_request_t*)
286977,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,static void ngx_http_request_finalizer(ngx_http_request_t *r);,13,61,http\ngx_http_request.c,ngx_http_request_finalizer,,false,48,48,ngx_http_request_finalizer,,,22,void ngx_http_request_finalizer (ngx_http_request_t*)
286982,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,static void ngx_http_set_keepalive(ngx_http_request_t *r);,13,57,http\ngx_http_request.c,ngx_http_set_keepalive,,false,50,50,ngx_http_set_keepalive,,,23,void ngx_http_set_keepalive (ngx_http_request_t*)
286987,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,static void ngx_http_keepalive_handler(ngx_event_t *ev);,13,55,http\ngx_http_request.c,ngx_http_keepalive_handler,,false,51,51,ngx_http_keepalive_handler,,,24,void ngx_http_keepalive_handler (ngx_event_t*)
286992,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,static void ngx_http_set_lingering_close(ngx_http_request_t *r);,13,63,http\ngx_http_request.c,ngx_http_set_lingering_close,,false,52,52,ngx_http_set_lingering_close,,,25,void ngx_http_set_lingering_close (ngx_http_request_t*)
286997,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,static void ngx_http_lingering_close_handler(ngx_event_t *ev);,13,61,http\ngx_http_request.c,ngx_http_lingering_close_handler,,false,53,53,ngx_http_lingering_close_handler,,,26,void ngx_http_lingering_close_handler (ngx_event_t*)
287002,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_post_action(ngx_http_request_t *r);,18,60,http\ngx_http_request.c,ngx_http_post_action,,false,54,54,ngx_http_post_action,,,27,ngx_int_t ngx_http_post_action (ngx_http_request_t*)
287007,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static void ngx_http_close_request(ngx_http_request_t *r, ngx_int_t error);",13,74,http\ngx_http_request.c,ngx_http_close_request,,false,55,55,ngx_http_close_request,,,28,"void ngx_http_close_request (ngx_http_request_t*,ngx_int_t)"
287013,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,static void ngx_http_log_request(ngx_http_request_t *r);,13,55,http\ngx_http_request.c,ngx_http_log_request,,false,56,56,ngx_http_log_request,,,29,void ngx_http_log_request (ngx_http_request_t*)
287018,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static u_char *ngx_http_log_error(ngx_log_t *log, u_char *buf, size_t len);",15,74,http\ngx_http_request.c,ngx_http_log_error,,false,58,58,ngx_http_log_error,,,30,"u_char* ngx_http_log_error (ngx_log_t*,u_char*,size_t)"
287025,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static u_char *ngx_http_log_error_handler(ngx_http_request_t *r,
    ngx_http_request_t *sr, u_char *buf, size_t len);",15,52,http\ngx_http_request.c,ngx_http_log_error_handler,,false,59,60,ngx_http_log_error_handler,,,31,"u_char* ngx_http_log_error_handler (ngx_http_request_t*,ngx_http_request_t*,u_char*,size_t)"
287189,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"void
ngx_http_init_connection(ngx_connection_t *c)
{
    ngx_uint_t              i;
    ngx_event_t            *rev;
    struct sockaddr_in     *sin;
    ngx_http_port_t        *port;
    ngx_http_in_addr_t     *addr;
    ngx_http_log_ctx_t     *ctx;
    ngx_http_connection_t  *hc;
#if (NGX_HAVE_INET6)
    struct sockaddr_in6    *sin6;
    ngx_http_in6_addr_t    *addr6;
#endif

    hc = ngx_pcalloc(c->pool, sizeof(ngx_http_connection_t));
    if (hc == NULL) {
        ngx_http_close_connection(c);
        return;
    }

    c->data = hc;

    /* find the server configuration for the address:port */

    port = c->listening->servers;

    if (port->naddrs > 1) {

        /*
         * there are several addresses on this port and one of them
         * is an ""*:port"" wildcard so getsockname() in ngx_http_server_addr()
         * is required to determine a server address
         */

        if (ngx_connection_local_sockaddr(c, NULL, 0) != NGX_OK) {
            ngx_http_close_connectio...",1,1,http\ngx_http_request.c,ngx_http_init_connection,,false,206,371,ngx_http_init_connection,,,36,void ngx_http_init_connection (ngx_connection_t*)
287485,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static void
ngx_http_wait_request_handler(ngx_event_t *rev)
{
    u_char                    *p;
    size_t                     size;
    ssize_t                    n;
    ngx_buf_t                 *b;
    ngx_connection_t          *c;
    ngx_http_connection_t     *hc;
    ngx_http_core_srv_conf_t  *cscf;

    c = rev->data;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0, ""http wait request handler"");

    if (rev->timedout) {
        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, ""client timed out"");
        ngx_http_close_connection(c);
        return;
    }

    if (c->close) {
        ngx_http_close_connection(c);
        return;
    }

    hc = c->data;
    cscf = ngx_http_get_module_srv_conf(hc->conf_ctx, ngx_http_core_module);

    size = cscf->client_header_buffer_size;

    b = c->buffer;

    if (b == NULL) {
        b = ngx_create_temp_buf(c->pool, size);
        if (b == NULL) {
            ngx_http_close_connection(c);
            return;
        }

        c->bu...",1,1,http\ngx_http_request.c,ngx_http_wait_request_handler,,false,374,501,ngx_http_wait_request_handler,,,37,void ngx_http_wait_request_handler (ngx_event_t*)
287818,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"ngx_http_request_t *
ngx_http_create_request(ngx_connection_t *c)
{
    ngx_http_request_t        *r;
    ngx_http_log_ctx_t        *ctx;
    ngx_http_core_loc_conf_t  *clcf;

    r = ngx_http_alloc_request(c);
    if (r == NULL) {
        return NULL;
    }

    c->requests++;

    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    ngx_set_connection_log(c, clcf->error_log);

    ctx = c->log->data;
    ctx->request = r;
    ctx->current_request = r;

#if (NGX_STAT_STUB)
    (void) ngx_atomic_fetch_add(ngx_stat_reading, 1);
    r->stat_reading = 1;
    (void) ngx_atomic_fetch_add(ngx_stat_requests, 1);
#endif

    return r;
}",1,1,http\ngx_http_request.c,ngx_http_create_request,,false,504,533,ngx_http_create_request,,,38,ngx_http_request_t ngx_http_create_request (ngx_connection_t*)
287870,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static ngx_http_request_t *
ngx_http_alloc_request(ngx_connection_t *c)
{
    ngx_pool_t                 *pool;
    ngx_time_t                 *tp;
    ngx_http_request_t         *r;
    ngx_http_connection_t      *hc;
    ngx_http_core_srv_conf_t   *cscf;
    ngx_http_core_main_conf_t  *cmcf;

    hc = c->data;

    cscf = ngx_http_get_module_srv_conf(hc->conf_ctx, ngx_http_core_module);

    pool = ngx_create_pool(cscf->request_pool_size, c->log);
    if (pool == NULL) {
        return NULL;
    }

    r = ngx_pcalloc(pool, sizeof(ngx_http_request_t));
    if (r == NULL) {
        ngx_destroy_pool(pool);
        return NULL;
    }

    r->pool = pool;

    r->http_connection = hc;
    r->signature = NGX_HTTP_MODULE;
    r->connection = c;

    r->main_conf = hc->conf_ctx->main_conf;
    r->srv_conf = hc->conf_ctx->srv_conf;
    r->loc_conf = hc->conf_ctx->loc_conf;

    r->read_event_handler = ngx_http_block_reading;

    r->header_in = hc->busy ? hc->busy->buf : c->buffer;

    i...",1,1,http\ngx_http_request.c,ngx_http_alloc_request,,false,536,635,ngx_http_alloc_request,,,39,ngx_http_request_t ngx_http_alloc_request (ngx_connection_t*)
288192,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static void
ngx_http_process_request_line(ngx_event_t *rev)
{
    ssize_t              n;
    ngx_int_t            rc, rv;
    ngx_str_t            host;
    ngx_connection_t    *c;
    ngx_http_request_t  *r;

    c = rev->data;
    r = c->data;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, rev->log, 0,
                   ""http process request line"");

    if (rev->timedout) {
        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, ""client timed out"");
        c->timedout = 1;
        ngx_http_close_request(r, NGX_HTTP_REQUEST_TIME_OUT);
        return;
    }

    rc = NGX_AGAIN;

    for ( ;; ) {

        if (rc == NGX_AGAIN) {
            n = ngx_http_read_request_header(r);

            if (n == NGX_AGAIN || n == NGX_ERROR) {
                break;
            }
        }

        rc = ngx_http_parse_request_line(r, r->header_in);

        if (rc == NGX_OK) {

            /* the request line has been parsed successfully */

            r->request_line.len = r->request_end - r->requ...",1,1,http\ngx_http_request.c,ngx_http_process_request_line,,false,1037,1197,ngx_http_process_request_line,,,40,void ngx_http_process_request_line (ngx_event_t*)
288647,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_process_request_uri(ngx_http_request_t *r)
{
    ngx_http_core_srv_conf_t  *cscf;

    if (r->args_start) {
        r->uri.len = r->args_start - 1 - r->uri_start;
    } else {
        r->uri.len = r->uri_end - r->uri_start;
    }

    if (r->complex_uri || r->quoted_uri) {

        r->uri.data = ngx_pnalloc(r->pool, r->uri.len + 1);
        if (r->uri.data == NULL) {
            ngx_http_close_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
            return NGX_ERROR;
        }

        cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);

        if (ngx_http_parse_complex_uri(r, cscf->merge_slashes) != NGX_OK) {
            r->uri.len = 0;

            ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
                          ""client sent invalid request"");
            ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);
            return NGX_ERROR;
        }

    } else {
        r->uri.data = r->uri_start;
    }

    r->unparsed_uri.len = r->uri_end -...",1,1,http\ngx_http_request.c,ngx_http_process_request_uri,,false,1200,1314,ngx_http_process_request_uri,,,41,ngx_int_t ngx_http_process_request_uri (ngx_http_request_t*)
288931,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static void
ngx_http_process_request_headers(ngx_event_t *rev)
{
    u_char                     *p;
    size_t                      len;
    ssize_t                     n;
    ngx_int_t                   rc, rv;
    ngx_table_elt_t            *h;
    ngx_connection_t           *c;
    ngx_http_header_t          *hh;
    ngx_http_request_t         *r;
    ngx_http_core_srv_conf_t   *cscf;
    ngx_http_core_main_conf_t  *cmcf;

    c = rev->data;
    r = c->data;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, rev->log, 0,
                   ""http process request header line"");

    if (rev->timedout) {
        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, ""client timed out"");
        c->timedout = 1;
        ngx_http_close_request(r, NGX_HTTP_REQUEST_TIME_OUT);
        return;
    }

    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);

    rc = NGX_AGAIN;

    for ( ;; ) {

        if (rc == NGX_AGAIN) {

            if (r->header_in->pos == r->header_in->end) {

        ...",1,1,http\ngx_http_request.c,ngx_http_process_request_headers,,false,1317,1502,ngx_http_process_request_headers,,,42,void ngx_http_process_request_headers (ngx_event_t*)
289443,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static ssize_t
ngx_http_read_request_header(ngx_http_request_t *r)
{
    ssize_t                    n;
    ngx_event_t               *rev;
    ngx_connection_t          *c;
    ngx_http_core_srv_conf_t  *cscf;

    c = r->connection;
    rev = c->read;

    n = r->header_in->last - r->header_in->pos;

    if (n > 0) {
        return n;
    }

    if (rev->ready) {
        n = c->recv(c, r->header_in->last,
                    r->header_in->end - r->header_in->last);
    } else {
        n = NGX_AGAIN;
    }

    if (n == NGX_AGAIN) {
        if (!rev->timer_set) {
            cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);
            ngx_add_timer(rev, cscf->client_header_timeout);
        }

        if (ngx_handle_read_event(rev, 0) != NGX_OK) {
            ngx_http_close_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
            return NGX_ERROR;
        }

        return NGX_AGAIN;
    }

    if (n == 0) {
        ngx_log_error(NGX_LOG_INFO, c->log, 0,
               ...",1,1,http\ngx_http_request.c,ngx_http_read_request_header,,false,1505,1559,ngx_http_read_request_header,,,43,ssize_t ngx_http_read_request_header (ngx_http_request_t*)
289597,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_alloc_large_header_buffer(ngx_http_request_t *r,
    ngx_uint_t request_line)
{
    u_char                    *old, *new;
    ngx_buf_t                 *b;
    ngx_chain_t               *cl;
    ngx_http_connection_t     *hc;
    ngx_http_core_srv_conf_t  *cscf;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http alloc large header buffer"");

    if (request_line && r->state == 0) {

        /* the client fills up the buffer with ""\r\n"" */

        r->header_in->pos = r->header_in->start;
        r->header_in->last = r->header_in->start;

        return NGX_OK;
    }

    old = request_line ? r->request_start : r->header_name_start;

    cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);

    if (r->state != 0
        && (size_t) (r->header_in->pos - old)
                                     >= cscf->large_client_header_buffers.size)
    {
        return NGX_DECLINED;
    }

    hc = r->http_connection;

    if...",1,1,http\ngx_http_request.c,ngx_http_alloc_large_header_buffer,,false,1562,1708,ngx_http_alloc_large_header_buffer,,,44,"ngx_int_t ngx_http_alloc_large_header_buffer (ngx_http_request_t*,ngx_uint_t)"
290143,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_process_header_line(ngx_http_request_t *r, ngx_table_elt_t *h,
    ngx_uint_t offset)
{
    ngx_table_elt_t  **ph;

    ph = (ngx_table_elt_t **) ((char *) &r->headers_in + offset);

    if (*ph == NULL) {
        *ph = h;
    }

    return NGX_OK;
}",1,1,http\ngx_http_request.c,ngx_http_process_header_line,,false,1711,1724,ngx_http_process_header_line,,,45,"ngx_int_t ngx_http_process_header_line (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
290175,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_process_unique_header_line(ngx_http_request_t *r, ngx_table_elt_t *h,
    ngx_uint_t offset)
{
    ngx_table_elt_t  **ph;

    ph = (ngx_table_elt_t **) ((char *) &r->headers_in + offset);

    if (*ph == NULL) {
        *ph = h;
        return NGX_OK;
    }

    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
                  ""client sent duplicate header line: \""%V: %V\"", ""
                  ""previous value: \""%V: %V\"""",
                  &h->key, &h->value, &(*ph)->key, &(*ph)->value);

    ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);

    return NGX_ERROR;
}",1,1,http\ngx_http_request.c,ngx_http_process_unique_header_line,,false,1727,1748,ngx_http_process_unique_header_line,,,46,"ngx_int_t ngx_http_process_unique_header_line (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
290239,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_process_host(ngx_http_request_t *r, ngx_table_elt_t *h,
    ngx_uint_t offset)
{
    ngx_int_t  rc;
    ngx_str_t  host;

    if (r->headers_in.host) {
        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
                      ""client sent duplicate host header: \""%V: %V\"", ""
                      ""previous value: \""%V: %V\"""",
                      &h->key, &h->value, &r->headers_in.host->key,
                      &r->headers_in.host->value);
        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);
        return NGX_ERROR;
    }

    r->headers_in.host = h;

    host = h->value;

    rc = ngx_http_validate_host(&host, r->pool, 0);

    if (rc == NGX_DECLINED) {
        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
                      ""client sent invalid host header"");
        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);
        return NGX_ERROR;
    }

    if (rc == NGX_ERROR) {
        ngx_http_close_request(r, NGX_HTTP_INTERNAL_S...",1,1,http\ngx_http_request.c,ngx_http_process_host,,false,1751,1797,ngx_http_process_host,,,47,"ngx_int_t ngx_http_process_host (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
290373,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_process_connection(ngx_http_request_t *r, ngx_table_elt_t *h,
    ngx_uint_t offset)
{
    if (ngx_strcasestrn(h->value.data, ""close"", 5 - 1)) {
        r->headers_in.connection_type = NGX_HTTP_CONNECTION_CLOSE;

    } else if (ngx_strcasestrn(h->value.data, ""keep-alive"", 10 - 1)) {
        r->headers_in.connection_type = NGX_HTTP_CONNECTION_KEEP_ALIVE;
    }

    return NGX_OK;
}",1,1,http\ngx_http_request.c,ngx_http_process_connection,,false,1800,1812,ngx_http_process_connection,,,48,"ngx_int_t ngx_http_process_connection (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
290422,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_process_user_agent(ngx_http_request_t *r, ngx_table_elt_t *h,
    ngx_uint_t offset)
{
    u_char  *user_agent, *msie;

    if (r->headers_in.user_agent) {
        return NGX_OK;
    }

    r->headers_in.user_agent = h;

    /* check some widespread browsers while the header is in CPU cache */

    user_agent = h->value.data;

    msie = ngx_strstrn(user_agent, ""MSIE "", 5 - 1);

    if (msie && msie + 7 < user_agent + h->value.len) {

        r->headers_in.msie = 1;

        if (msie[6] == '.') {

            switch (msie[5]) {
            case '4':
            case '5':
                r->headers_in.msie6 = 1;
                break;
            case '6':
                if (ngx_strstrn(msie + 8, ""SV1"", 3 - 1) == NULL) {
                    r->headers_in.msie6 = 1;
                }
                break;
            }
        }

#if 0
        /* MSIE ignores the SSL ""close notify"" alert */
        if (c->ssl) {
            c->ssl->no_send_shutdown = 1;
   ...",1,1,http\ngx_http_request.c,ngx_http_process_user_agent,,false,1815,1885,ngx_http_process_user_agent,,,49,"ngx_int_t ngx_http_process_user_agent (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
290649,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_process_multi_header_lines(ngx_http_request_t *r, ngx_table_elt_t *h,
    ngx_uint_t offset)
{
    ngx_array_t       *headers;
    ngx_table_elt_t  **ph;

    headers = (ngx_array_t *) ((char *) &r->headers_in + offset);

    if (headers->elts == NULL) {
        if (ngx_array_init(headers, r->pool, 1, sizeof(ngx_table_elt_t *))
            != NGX_OK)
        {
            ngx_http_close_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
            return NGX_ERROR;
        }
    }

    ph = ngx_array_push(headers);
    if (ph == NULL) {
        ngx_http_close_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
        return NGX_ERROR;
    }

    *ph = h;
    return NGX_OK;
}",1,1,http\ngx_http_request.c,ngx_http_process_multi_header_lines,,false,1888,1914,ngx_http_process_multi_header_lines,,,50,"ngx_int_t ngx_http_process_multi_header_lines (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
290714,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_process_request_header(ngx_http_request_t *r)
{
    if (r->headers_in.server.len == 0
        && ngx_http_set_virtual_server(r, &r->headers_in.server)
           == NGX_ERROR)
    {
        return NGX_ERROR;
    }

    if (r->headers_in.host == NULL && r->http_version > NGX_HTTP_VERSION_10) {
        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
                   ""client sent HTTP/1.1 request without \""Host\"" header"");
        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);
        return NGX_ERROR;
    }

    if (r->headers_in.content_length) {
        r->headers_in.content_length_n =
                            ngx_atoof(r->headers_in.content_length->value.data,
                                      r->headers_in.content_length->value.len);

        if (r->headers_in.content_length_n == NGX_ERROR) {
            ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
                          ""client sent invalid \""Content-Length\"" header"");
            ngx_...",1,1,http\ngx_http_request.c,ngx_http_process_request_header,,false,1917,1981,ngx_http_process_request_header,,,51,ngx_int_t ngx_http_process_request_header (ngx_http_request_t*)
290974,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"void
ngx_http_process_request(ngx_http_request_t *r)
{
    ngx_connection_t  *c;

    c = r->connection;

#if (NGX_HTTP_SSL)

    if (r->http_connection->ssl) {
        long                      rc;
        X509                     *cert;
        const char               *s;
        ngx_http_ssl_srv_conf_t  *sscf;

        if (c->ssl == NULL) {
            ngx_log_error(NGX_LOG_INFO, c->log, 0,
                          ""client sent plain HTTP request to HTTPS port"");
            ngx_http_finalize_request(r, NGX_HTTP_TO_HTTPS);
            return;
        }

        sscf = ngx_http_get_module_srv_conf(r, ngx_http_ssl_module);

        if (sscf->verify) {
            rc = SSL_get_verify_result(c->ssl->connection);

            if (rc != X509_V_OK
                && (sscf->verify != 3 || !ngx_ssl_verify_error_optional(rc)))
            {
                ngx_log_error(NGX_LOG_INFO, c->log, 0,
                              ""client SSL certificate verify error: (%l:%s)"",
                ...",1,1,http\ngx_http_request.c,ngx_http_process_request,,false,1984,2073,ngx_http_process_request,,,52,void ngx_http_process_request (ngx_http_request_t*)
291017,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_validate_host(ngx_str_t *host, ngx_pool_t *pool, ngx_uint_t alloc)
{
    u_char  *h, ch;
    size_t   i, dot_pos, host_len;

    enum {
        sw_usual = 0,
        sw_literal,
        sw_rest
    } state;

    dot_pos = host->len;
    host_len = host->len;

    h = host->data;

    state = sw_usual;

    for (i = 0; i < host->len; i++) {
        ch = h[i];

        switch (ch) {

        case '.':
            if (dot_pos == i - 1) {
                return NGX_DECLINED;
            }
            dot_pos = i;
            break;

        case ':':
            if (state == sw_usual) {
                host_len = i;
                state = sw_rest;
            }
            break;

        case '[':
            if (i == 0) {
                state = sw_literal;
            }
            break;

        case ']':
            if (state == sw_literal) {
                host_len = i + 1;
                state = sw_rest;
            }
            break;

        case...",1,1,http\ngx_http_request.c,ngx_http_validate_host,,false,2076,2164,ngx_http_validate_host,,,53,"ngx_int_t ngx_http_validate_host (ngx_str_t*,ngx_pool_t*,ngx_uint_t)"
291197,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_set_virtual_server(ngx_http_request_t *r, ngx_str_t *host)
{
    ngx_int_t                  rc;
    ngx_http_connection_t     *hc;
    ngx_http_core_loc_conf_t  *clcf;
    ngx_http_core_srv_conf_t  *cscf;

#if (NGX_SUPPRESS_WARN)
    cscf = NULL;
#endif

    hc = r->http_connection;

#if (NGX_HTTP_SSL && defined SSL_CTRL_SET_TLSEXT_HOSTNAME)

    if (hc->ssl_servername) {
        if (hc->ssl_servername->len == host->len
            && ngx_strncmp(hc->ssl_servername->data,
                           host->data, host->len) == 0)
        {
#if (NGX_PCRE)
            if (hc->ssl_servername_regex
                && ngx_http_regex_exec(r, hc->ssl_servername_regex,
                                          hc->ssl_servername) != NGX_OK)
            {
                ngx_http_close_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
                return NGX_ERROR;
            }
#endif
            return NGX_OK;
        }
    }

#endif

    rc = ngx_http_find_virtual_serv...",1,1,http\ngx_http_request.c,ngx_http_set_virtual_server,,false,2167,2247,ngx_http_set_virtual_server,,,54,"ngx_int_t ngx_http_set_virtual_server (ngx_http_request_t*,ngx_str_t*)"
291276,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_find_virtual_server(ngx_connection_t *c,
    ngx_http_virtual_names_t *virtual_names, ngx_str_t *host,
    ngx_http_request_t *r, ngx_http_core_srv_conf_t **cscfp)
{
    ngx_http_core_srv_conf_t  *cscf;

    if (virtual_names == NULL) {
        return NGX_DECLINED;
    }

    cscf = ngx_hash_find_combined(&virtual_names->names,
                                  ngx_hash_key(host->data, host->len),
                                  host->data, host->len);

    if (cscf) {
        *cscfp = cscf;
        return NGX_OK;
    }

#if (NGX_PCRE)

    if (host->len && virtual_names->nregex) {
        ngx_int_t                n;
        ngx_uint_t               i;
        ngx_http_server_name_t  *sn;

        sn = virtual_names->regex;

#if (NGX_HTTP_SSL && defined SSL_CTRL_SET_TLSEXT_HOSTNAME)

        if (r == NULL) {
            ngx_http_connection_t  *hc;

            for (i = 0; i < virtual_names->nregex; i++) {

                n = ngx_regex_exec(sn[i].regex->r...",1,1,http\ngx_http_request.c,ngx_http_find_virtual_server,,false,2250,2333,ngx_http_find_virtual_server,,,55,"ngx_int_t ngx_http_find_virtual_server (ngx_connection_t*,ngx_http_virtual_names_t*,ngx_str_t*,ngx_http_request_t*,ngx_http_core_srv_conf_t**)"
291324,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static void
ngx_http_request_handler(ngx_event_t *ev)
{
    ngx_connection_t    *c;
    ngx_http_request_t  *r;

    c = ev->data;
    r = c->data;

    ngx_http_set_log_request(c->log, r);

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, c->log, 0,
                   ""http run request: \""%V?%V\"""", &r->uri, &r->args);

    if (c->close) {
        r->main->count++;
        ngx_http_terminate_request(r, 0);
        ngx_http_run_posted_requests(c);
        return;
    }

    if (ev->delayed && ev->timedout) {
        ev->delayed = 0;
        ev->timedout = 0;
    }

    if (ev->write) {
        r->write_event_handler(r);

    } else {
        r->read_event_handler(r);
    }

    ngx_http_run_posted_requests(c);
}",1,1,http\ngx_http_request.c,ngx_http_request_handler,,false,2336,2370,ngx_http_request_handler,,,56,void ngx_http_request_handler (ngx_event_t*)
291416,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"void
ngx_http_run_posted_requests(ngx_connection_t *c)
{
    ngx_http_request_t         *r;
    ngx_http_posted_request_t  *pr;

    for ( ;; ) {

        if (c->destroyed) {
            return;
        }

        r = c->data;
        pr = r->main->posted_requests;

        if (pr == NULL) {
            return;
        }

        r->main->posted_requests = pr->next;

        r = pr->request;

        ngx_http_set_log_request(c->log, r);

        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, c->log, 0,
                       ""http posted request: \""%V?%V\"""", &r->uri, &r->args);

        r->write_event_handler(r);
    }
}",1,1,http\ngx_http_request.c,ngx_http_run_posted_requests,,false,2373,2403,ngx_http_run_posted_requests,,,57,void ngx_http_run_posted_requests (ngx_connection_t*)
291489,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_post_request(ngx_http_request_t *r, ngx_http_posted_request_t *pr)
{
    ngx_http_posted_request_t  **p;

    if (pr == NULL) {
        pr = ngx_palloc(r->pool, sizeof(ngx_http_posted_request_t));
        if (pr == NULL) {
            return NGX_ERROR;
        }
    }

    pr->request = r;
    pr->next = NULL;

    for (p = &r->main->posted_requests; *p; p = &(*p)->next) { /* void */ }

    *p = pr;

    return NGX_OK;
}",1,1,http\ngx_http_request.c,ngx_http_post_request,,false,2406,2426,ngx_http_post_request,,,58,"ngx_int_t ngx_http_post_request (ngx_http_request_t*,ngx_http_posted_request_t*)"
291552,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"void
ngx_http_finalize_request(ngx_http_request_t *r, ngx_int_t rc)
{
    ngx_connection_t          *c;
    ngx_http_request_t        *pr;
    ngx_http_core_loc_conf_t  *clcf;

    c = r->connection;

    ngx_log_debug5(NGX_LOG_DEBUG_HTTP, c->log, 0,
                   ""http finalize request: %i, \""%V?%V\"" a:%d, c:%d"",
                   rc, &r->uri, &r->args, r == c->data, r->main->count);

    if (rc == NGX_DONE) {
        ngx_http_finalize_connection(r);
        return;
    }

    if (rc == NGX_OK && r->filter_finalize) {
        c->error = 1;
    }

    if (rc == NGX_DECLINED) {
        r->content_handler = NULL;
        r->write_event_handler = ngx_http_core_run_phases;
        ngx_http_core_run_phases(r);
        return;
    }

    if (r != r->main && r->post_subrequest) {
        rc = r->post_subrequest->handler(r, r->post_subrequest->data, rc);
    }

    if (rc == NGX_ERROR
        || rc == NGX_HTTP_REQUEST_TIME_OUT
        || rc == NGX_HTTP_CLIENT_CLOSED_REQUEST
        ||...",1,1,http\ngx_http_request.c,ngx_http_finalize_request,,false,2429,2618,ngx_http_finalize_request,,,59,"void ngx_http_finalize_request (ngx_http_request_t*,ngx_int_t)"
292076,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static void
ngx_http_terminate_request(ngx_http_request_t *r, ngx_int_t rc)
{
    ngx_http_cleanup_t    *cln;
    ngx_http_request_t    *mr;
    ngx_http_ephemeral_t  *e;

    mr = r->main;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http terminate request count:%d"", mr->count);

    if (rc > 0 && (mr->headers_out.status == 0 || mr->connection->sent == 0)) {
        mr->headers_out.status = rc;
    }

    cln = mr->cleanup;
    mr->cleanup = NULL;

    while (cln) {
        if (cln->handler) {
            cln->handler(cln->data);
        }

        cln = cln->next;
    }

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http terminate cleanup count:%d blk:%d"",
                   mr->count, mr->blocked);

    if (mr->write_event_handler) {

        if (mr->blocked) {
            r->connection->error = 1;
            r->write_event_handler = ngx_http_request_finalizer;
            return;
        }

        e = ng...",1,1,http\ngx_http_request.c,ngx_http_terminate_request,,false,2621,2668,ngx_http_terminate_request,,,60,"void ngx_http_terminate_request (ngx_http_request_t*,ngx_int_t)"
292224,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static void
ngx_http_terminate_handler(ngx_http_request_t *r)
{
    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http terminate handler count:%d"", r->count);

    r->count = 1;

    ngx_http_close_request(r, 0);
}",1,1,http\ngx_http_request.c,ngx_http_terminate_handler,,false,2671,2680,ngx_http_terminate_handler,,,61,void ngx_http_terminate_handler (ngx_http_request_t*)
292249,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static void
ngx_http_finalize_connection(ngx_http_request_t *r)
{
    ngx_http_core_loc_conf_t  *clcf;

#if (NGX_HTTP_V2)
    if (r->stream) {
        ngx_http_close_request(r, 0);
        return;
    }
#endif

    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    if (r->main->count != 1) {

        if (r->discard_body) {
            r->read_event_handler = ngx_http_discarded_request_body_handler;
            ngx_add_timer(r->connection->read, clcf->lingering_timeout);

            if (r->lingering_time == 0) {
                r->lingering_time = ngx_time()
                                      + (time_t) (clcf->lingering_time / 1000);
            }
        }

        ngx_http_close_request(r, 0);
        return;
    }

    r = r->main;

    if (r->reading_body) {
        r->keepalive = 0;
        r->lingering_close = 1;
    }

    if (!ngx_terminate
         && !ngx_exiting
         && r->keepalive
         && clcf->keepalive_timeout > 0)
    {
        ngx_http_set...",1,1,http\ngx_http_request.c,ngx_http_finalize_connection,,false,2683,2740,ngx_http_finalize_connection,,,62,void ngx_http_finalize_connection (ngx_http_request_t*)
292394,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_set_write_handler(ngx_http_request_t *r)
{
    ngx_event_t               *wev;
    ngx_http_core_loc_conf_t  *clcf;

    r->http_state = NGX_HTTP_WRITING_REQUEST_STATE;

    r->read_event_handler = r->discard_body ?
                                ngx_http_discarded_request_body_handler:
                                ngx_http_test_reading;
    r->write_event_handler = ngx_http_writer;

    wev = r->connection->write;

    if (wev->ready && wev->delayed) {
        return NGX_OK;
    }

    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);
    if (!wev->delayed) {
        ngx_add_timer(wev, clcf->send_timeout);
    }

    if (ngx_handle_write_event(wev, clcf->send_lowat) != NGX_OK) {
        ngx_http_close_request(r, 0);
        return NGX_ERROR;
    }

    return NGX_OK;
}",1,1,http\ngx_http_request.c,ngx_http_set_write_handler,,false,2743,2773,ngx_http_set_write_handler,,,63,ngx_int_t ngx_http_set_write_handler (ngx_http_request_t*)
292471,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static void
ngx_http_writer(ngx_http_request_t *r)
{
    ngx_int_t                  rc;
    ngx_event_t               *wev;
    ngx_connection_t          *c;
    ngx_http_core_loc_conf_t  *clcf;

    c = r->connection;
    wev = c->write;

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, wev->log, 0,
                   ""http writer handler: \""%V?%V\"""", &r->uri, &r->args);

    clcf = ngx_http_get_module_loc_conf(r->main, ngx_http_core_module);

    if (wev->timedout) {
        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT,
                      ""client timed out"");
        c->timedout = 1;

        ngx_http_finalize_request(r, NGX_HTTP_REQUEST_TIME_OUT);
        return;
    }

    if (wev->delayed || r->aio) {
        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, wev->log, 0,
                       ""http writer delayed"");

        if (!wev->delayed) {
            ngx_add_timer(wev, clcf->send_timeout);
        }

        if (ngx_handle_write_event(wev, clcf->send_lowat) != NGX_OK) {
            ngx_...",1,1,http\ngx_http_request.c,ngx_http_writer,,false,2776,2846,ngx_http_writer,,,64,void ngx_http_writer (ngx_http_request_t*)
292669,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static void
ngx_http_request_finalizer(ngx_http_request_t *r)
{
    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http finalizer done: \""%V?%V\"""", &r->uri, &r->args);

    ngx_http_finalize_request(r, 0);
}",1,1,http\ngx_http_request.c,ngx_http_request_finalizer,,false,2849,2856,ngx_http_request_finalizer,,,65,void ngx_http_request_finalizer (ngx_http_request_t*)
292694,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"void
ngx_http_block_reading(ngx_http_request_t *r)
{
    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http reading blocked"");

    /* aio does not call this handler */

    if ((ngx_event_flags & NGX_USE_LEVEL_EVENT)
        && r->connection->read->active)
    {
        if (ngx_del_event(r->connection->read, NGX_READ_EVENT, 0) != NGX_OK) {
            ngx_http_close_request(r, 0);
        }
    }
}",1,1,http\ngx_http_request.c,ngx_http_block_reading,,false,2859,2874,ngx_http_block_reading,,,66,void ngx_http_block_reading (ngx_http_request_t*)
292736,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"void
ngx_http_test_reading(ngx_http_request_t *r)
{
    int                n;
    char               buf[1];
    ngx_err_t          err;
    ngx_event_t       *rev;
    ngx_connection_t  *c;

    c = r->connection;
    rev = c->read;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0, ""http test reading"");

#if (NGX_HTTP_V2)

    if (r->stream) {
        if (c->error) {
            err = 0;
            goto closed;
        }

        return;
    }

#endif

#if (NGX_HAVE_KQUEUE)

    if (ngx_event_flags & NGX_USE_KQUEUE_EVENT) {

        if (!rev->pending_eof) {
            return;
        }

        rev->eof = 1;
        c->error = 1;
        err = rev->kq_errno;

        goto closed;
    }

#endif

#if (NGX_HAVE_EPOLLRDHUP)

    if ((ngx_event_flags & NGX_USE_EPOLL_EVENT) && ngx_use_epoll_rdhup) {
        socklen_t  len;

        if (!rev->pending_eof) {
            return;
        }

        rev->eof = 1;
        c->error = 1;

        err = 0;
        len = sizeof(ngx_err_t);

   ...",1,1,http\ngx_http_request.c,ngx_http_test_reading,,false,2877,2993,ngx_http_test_reading,,,67,void ngx_http_test_reading (ngx_http_request_t*)
292858,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static void
ngx_http_set_keepalive(ngx_http_request_t *r)
{
    int                        tcp_nodelay;
    ngx_buf_t                 *b, *f;
    ngx_chain_t               *cl, *ln;
    ngx_event_t               *rev, *wev;
    ngx_connection_t          *c;
    ngx_http_connection_t     *hc;
    ngx_http_core_loc_conf_t  *clcf;

    c = r->connection;
    rev = c->read;

    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0, ""set http keepalive handler"");

    if (r->discard_body) {
        r->write_event_handler = ngx_http_request_empty_handler;
        r->lingering_time = ngx_time() + (time_t) (clcf->lingering_time / 1000);
        ngx_add_timer(rev, clcf->lingering_timeout);
        return;
    }

    c->log->action = ""closing request"";

    hc = r->http_connection;
    b = r->header_in;

    if (b->pos < b->last) {

        /* the pipelined request */

        if (b != c->buffer) {

            /*
             * If th...",1,1,http\ngx_http_request.c,ngx_http_set_keepalive,,false,2996,3215,ngx_http_set_keepalive,,,68,void ngx_http_set_keepalive (ngx_http_request_t*)
293409,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static void
ngx_http_keepalive_handler(ngx_event_t *rev)
{
    size_t             size;
    ssize_t            n;
    ngx_buf_t         *b;
    ngx_connection_t  *c;

    c = rev->data;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0, ""http keepalive handler"");

    if (rev->timedout || c->close) {
        ngx_http_close_connection(c);
        return;
    }

#if (NGX_HAVE_KQUEUE)

    if (ngx_event_flags & NGX_USE_KQUEUE_EVENT) {
        if (rev->pending_eof) {
            c->log->handler = NULL;
            ngx_log_error(NGX_LOG_INFO, c->log, rev->kq_errno,
                          ""kevent() reported that client %V closed ""
                          ""keepalive connection"", &c->addr_text);
#if (NGX_HTTP_SSL)
            if (c->ssl) {
                c->ssl->no_send_shutdown = 1;
            }
#endif
            ngx_http_close_connection(c);
            return;
        }
    }

#endif

    b = c->buffer;
    size = b->end - b->start;

    if (b->pos == NULL) {

        /*
        ...",1,1,http\ngx_http_request.c,ngx_http_keepalive_handler,,false,3218,3346,ngx_http_keepalive_handler,,,69,void ngx_http_keepalive_handler (ngx_event_t*)
293656,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static void
ngx_http_set_lingering_close(ngx_http_request_t *r)
{
    ngx_event_t               *rev, *wev;
    ngx_connection_t          *c;
    ngx_http_core_loc_conf_t  *clcf;

    c = r->connection;

    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    rev = c->read;
    rev->handler = ngx_http_lingering_close_handler;

    r->lingering_time = ngx_time() + (time_t) (clcf->lingering_time / 1000);
    ngx_add_timer(rev, clcf->lingering_timeout);

    if (ngx_handle_read_event(rev, 0) != NGX_OK) {
        ngx_http_close_request(r, 0);
        return;
    }

    wev = c->write;
    wev->handler = ngx_http_empty_handler;

    if (wev->active && (ngx_event_flags & NGX_USE_LEVEL_EVENT)) {
        if (ngx_del_event(wev, NGX_WRITE_EVENT, 0) != NGX_OK) {
            ngx_http_close_request(r, 0);
            return;
        }
    }

    if (ngx_shutdown_socket(c->fd, NGX_WRITE_SHUTDOWN) == -1) {
        ngx_connection_error(c, ngx_socket_errno,
                           ...",1,1,http\ngx_http_request.c,ngx_http_set_lingering_close,,false,3349,3391,ngx_http_set_lingering_close,,,70,void ngx_http_set_lingering_close (ngx_http_request_t*)
293766,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static void
ngx_http_lingering_close_handler(ngx_event_t *rev)
{
    ssize_t                    n;
    ngx_msec_t                 timer;
    ngx_connection_t          *c;
    ngx_http_request_t        *r;
    ngx_http_core_loc_conf_t  *clcf;
    u_char                     buffer[NGX_HTTP_LINGERING_BUFFER_SIZE];

    c = rev->data;
    r = c->data;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,
                   ""http lingering close handler"");

    if (rev->timedout) {
        ngx_http_close_request(r, 0);
        return;
    }

    timer = (ngx_msec_t) r->lingering_time - (ngx_msec_t) ngx_time();
    if ((ngx_msec_int_t) timer <= 0) {
        ngx_http_close_request(r, 0);
        return;
    }

    do {
        n = c->recv(c, buffer, NGX_HTTP_LINGERING_BUFFER_SIZE);

        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0, ""lingering read: %z"", n);

        if (n == NGX_AGAIN) {
            break;
        }

        if (n == NGX_ERROR || n == 0) {
            ngx_http_close_reque...",1,1,http\ngx_http_request.c,ngx_http_lingering_close_handler,,false,3394,3451,ngx_http_lingering_close_handler,,,71,void ngx_http_lingering_close_handler (ngx_event_t*)
293900,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"void
ngx_http_empty_handler(ngx_event_t *wev)
{
    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, wev->log, 0, ""http empty handler"");

    return;
}",1,1,http\ngx_http_request.c,ngx_http_empty_handler,,false,3454,3460,ngx_http_empty_handler,,,72,void ngx_http_empty_handler (ngx_event_t*)
293913,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"void
ngx_http_request_empty_handler(ngx_http_request_t *r)
{
    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http request empty handler"");

    return;
}",1,1,http\ngx_http_request.c,ngx_http_request_empty_handler,,false,3463,3470,ngx_http_request_empty_handler,,,73,void ngx_http_request_empty_handler (ngx_http_request_t*)
293928,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_send_special(ngx_http_request_t *r, ngx_uint_t flags)
{
    ngx_buf_t    *b;
    ngx_chain_t   out;

    b = ngx_calloc_buf(r->pool);
    if (b == NULL) {
        return NGX_ERROR;
    }

    if (flags & NGX_HTTP_LAST) {

        if (r == r->main && !r->post_action) {
            b->last_buf = 1;

        } else {
            b->sync = 1;
            b->last_in_chain = 1;
        }
    }

    if (flags & NGX_HTTP_FLUSH) {
        b->flush = 1;
    }

    out.buf = b;
    out.next = NULL;

    return ngx_http_output_filter(r, &out);
}",1,1,http\ngx_http_request.c,ngx_http_send_special,,false,3473,3503,ngx_http_send_special,,,74,"ngx_int_t ngx_http_send_special (ngx_http_request_t*,ngx_uint_t)"
294008,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_post_action(ngx_http_request_t *r)
{
    ngx_http_core_loc_conf_t  *clcf;

    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    if (clcf->post_action.data == NULL) {
        return NGX_DECLINED;
    }

    if (r->post_action && r->uri_changes == 0) {
        return NGX_DECLINED;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""post action: \""%V\"""", &clcf->post_action);

    r->main->count--;

    r->http_version = NGX_HTTP_VERSION_9;
    r->header_only = 1;
    r->post_action = 1;

    r->read_event_handler = ngx_http_block_reading;

    if (clcf->post_action.data[0] == '/') {
        ngx_http_internal_redirect(r, &clcf->post_action, NULL);

    } else {
        ngx_http_named_location(r, &clcf->post_action);
    }

    return NGX_OK;
}",1,1,http\ngx_http_request.c,ngx_http_post_action,,false,3506,3540,ngx_http_post_action,,,75,ngx_int_t ngx_http_post_action (ngx_http_request_t*)
294110,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static void
ngx_http_close_request(ngx_http_request_t *r, ngx_int_t rc)
{
    ngx_connection_t  *c;

    r = r->main;
    c = r->connection;

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, c->log, 0,
                   ""http request count:%d blk:%d"", r->count, r->blocked);

    if (r->count == 0) {
        ngx_log_error(NGX_LOG_ALERT, c->log, 0, ""http request count is zero"");
    }

    r->count--;

    if (r->count || r->blocked) {
        return;
    }

#if (NGX_HTTP_V2)
    if (r->stream) {
        ngx_http_v2_close_stream(r->stream, rc);
        return;
    }
#endif

    ngx_http_free_request(r, rc);
    ngx_http_close_connection(c);
}",1,1,http\ngx_http_request.c,ngx_http_close_request,,false,3543,3573,ngx_http_close_request,,,76,"void ngx_http_close_request (ngx_http_request_t*,ngx_int_t)"
294173,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"void
ngx_http_free_request(ngx_http_request_t *r, ngx_int_t rc)
{
    ngx_log_t                 *log;
    ngx_pool_t                *pool;
    struct linger              linger;
    ngx_http_cleanup_t        *cln;
    ngx_http_log_ctx_t        *ctx;
    ngx_http_core_loc_conf_t  *clcf;

    log = r->connection->log;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, log, 0, ""http close request"");

    if (r->pool == NULL) {
        ngx_log_error(NGX_LOG_ALERT, log, 0, ""http request already closed"");
        return;
    }

    cln = r->cleanup;
    r->cleanup = NULL;

    while (cln) {
        if (cln->handler) {
            cln->handler(cln->data);
        }

        cln = cln->next;
    }

#if (NGX_STAT_STUB)

    if (r->stat_reading) {
        (void) ngx_atomic_fetch_add(ngx_stat_reading, -1);
    }

    if (r->stat_writing) {
        (void) ngx_atomic_fetch_add(ngx_stat_writing, -1);
    }

#endif

    if (rc > 0 && (r->headers_out.status == 0 || r->connection->sent == 0)) {
        r->head...",1,1,http\ngx_http_request.c,ngx_http_free_request,,false,3576,3663,ngx_http_free_request,,,77,"void ngx_http_free_request (ngx_http_request_t*,ngx_int_t)"
294373,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static void
ngx_http_log_request(ngx_http_request_t *r)
{
    ngx_uint_t                  i, n;
    ngx_http_handler_pt        *log_handler;
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);

    log_handler = cmcf->phases[NGX_HTTP_LOG_PHASE].handlers.elts;
    n = cmcf->phases[NGX_HTTP_LOG_PHASE].handlers.nelts;

    for (i = 0; i < n; i++) {
        log_handler[i](r);
    }
}",1,1,http\ngx_http_request.c,ngx_http_log_request,,false,3666,3681,ngx_http_log_request,,,78,void ngx_http_log_request (ngx_http_request_t*)
294425,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"void
ngx_http_close_connection(ngx_connection_t *c)
{
    ngx_pool_t  *pool;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0,
                   ""close http connection: %d"", c->fd);

#if (NGX_HTTP_SSL)

    if (c->ssl) {
        if (ngx_ssl_shutdown(c) == NGX_AGAIN) {
            c->ssl->handler = ngx_http_close_connection;
            return;
        }
    }

#endif

#if (NGX_STAT_STUB)
    (void) ngx_atomic_fetch_add(ngx_stat_active, -1);
#endif

    c->destroyed = 1;

    pool = c->pool;

    ngx_close_connection(c);

    ngx_destroy_pool(pool);
}",1,1,http\ngx_http_request.c,ngx_http_close_connection,,false,3684,3714,ngx_http_close_connection,,,79,void ngx_http_close_connection (ngx_connection_t*)
294455,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static u_char *
ngx_http_log_error(ngx_log_t *log, u_char *buf, size_t len)
{
    u_char              *p;
    ngx_http_request_t  *r;
    ngx_http_log_ctx_t  *ctx;

    if (log->action) {
        p = ngx_snprintf(buf, len, "" while %s"", log->action);
        len -= p - buf;
        buf = p;
    }

    ctx = log->data;

    p = ngx_snprintf(buf, len, "", client: %V"", &ctx->connection->addr_text);
    len -= p - buf;

    r = ctx->request;

    if (r) {
        return r->log_handler(r, ctx->current_request, p, len);

    } else {
        p = ngx_snprintf(p, len, "", server: %V"",
                         &ctx->connection->listening->addr_text);
    }

    return p;
}",1,1,http\ngx_http_request.c,ngx_http_log_error,,false,3717,3746,ngx_http_log_error,,,80,"u_char ngx_http_log_error (ngx_log_t*,u_char*,size_t)"
294546,METHOD,http\ngx_http_request.c:<global>,TYPE_DECL,"static u_char *
ngx_http_log_error_handler(ngx_http_request_t *r, ngx_http_request_t *sr,
    u_char *buf, size_t len)
{
    char                      *uri_separator;
    u_char                    *p;
    ngx_http_upstream_t       *u;
    ngx_http_core_srv_conf_t  *cscf;

    cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);

    p = ngx_snprintf(buf, len, "", server: %V"", &cscf->server_name);
    len -= p - buf;
    buf = p;

    if (r->request_line.data == NULL && r->request_start) {
        for (p = r->request_start; p < r->header_in->last; p++) {
            if (*p == CR || *p == LF) {
                break;
            }
        }

        r->request_line.len = p - r->request_start;
        r->request_line.data = r->request_start;
    }

    if (r->request_line.len) {
        p = ngx_snprintf(buf, len, "", request: \""%V\"""", &r->request_line);
        len -= p - buf;
        buf = p;
    }

    if (r != sr) {
        p = ngx_snprintf(buf, len, "", subrequest: \""%V\"""", &...",1,1,http\ngx_http_request.c,ngx_http_log_error_handler,,false,3749,3820,ngx_http_log_error_handler,,,81,"u_char ngx_http_log_error_handler (ngx_http_request_t*,ngx_http_request_t*,u_char*,size_t)"
294794,METHOD,http\ngx_http_request.h:<global>,TYPE_DECL,<global>,1,53,http\ngx_http_request.h,http\ngx_http_request.h:<global>,,false,1,615,<global>,,,1,
294806,METHOD,<empty>,<empty>,<empty>,1,,http\ngx_http_request.h,ngx_http_state_e:<clinit>,,false,153,,<clinit>,,,10,
294900,METHOD,http\ngx_http_request.h:<global>,TYPE_DECL,typedef void (*ngx_http_client_body_handler_pt)(ngx_http_request_t *r);,14,70,http\ngx_http_request.h,ngx_http_client_body_handler_pt,,false,292,292,ngx_http_client_body_handler_pt,,,11,void ngx_http_client_body_handler_pt (ngx_http_request_t*)
294929,METHOD,http\ngx_http_request.h:<global>,TYPE_DECL,typedef void (*ngx_http_cleanup_pt)(void *data);,14,47,http\ngx_http_request.h,ngx_http_cleanup_pt,,false,330,330,ngx_http_cleanup_pt,,,18,void ngx_http_cleanup_pt (void*)
294940,METHOD,http\ngx_http_request.h:<global>,TYPE_DECL,"typedef ngx_int_t (*ngx_http_post_subrequest_pt)(ngx_http_request_t *r,
    void *data, ngx_int_t rc);",19,29,http\ngx_http_request.h,ngx_http_post_subrequest_pt,,false,341,342,ngx_http_post_subrequest_pt,,,22,"ngx_int_t ngx_http_post_subrequest_pt (ngx_http_request_t*,void*,ngx_int_t)"
294962,METHOD,http\ngx_http_request.h:<global>,TYPE_DECL,typedef ngx_int_t (*ngx_http_handler_pt)(ngx_http_request_t *r);,19,63,http\ngx_http_request.h,ngx_http_handler_pt,,false,367,367,ngx_http_handler_pt,,,31,ngx_int_t ngx_http_handler_pt (ngx_http_request_t*)
294967,METHOD,http\ngx_http_request.h:<global>,TYPE_DECL,typedef void (*ngx_http_event_handler_pt)(ngx_http_request_t *r);,14,64,http\ngx_http_request.h,ngx_http_event_handler_pt,,false,368,368,ngx_http_event_handler_pt,,,32,void ngx_http_event_handler_pt (ngx_http_request_t*)
295117,METHOD,<empty>,<empty>,<empty>,1,,http\ngx_http_request.h,ngx_http_request_s:<clinit>,,false,371,,<clinit>,,,145,
295141,METHOD,http\ngx_http_request_body.c:<global>,TYPE_DECL,<global>,1,1,http\ngx_http_request_body.c,http\ngx_http_request_body.c:<global>,,false,1,1169,<global>,,,1,
295143,METHOD,http\ngx_http_request_body.c:<global>,TYPE_DECL,static void ngx_http_read_client_request_body_handler(ngx_http_request_t *r);,13,76,http\ngx_http_request_body.c,ngx_http_read_client_request_body_handler,,false,13,13,ngx_http_read_client_request_body_handler,,,1,void ngx_http_read_client_request_body_handler (ngx_http_request_t*)
295148,METHOD,http\ngx_http_request_body.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_do_read_client_request_body(ngx_http_request_t *r);,18,76,http\ngx_http_request_body.c,ngx_http_do_read_client_request_body,,false,14,14,ngx_http_do_read_client_request_body,,,2,ngx_int_t ngx_http_do_read_client_request_body (ngx_http_request_t*)
295153,METHOD,http\ngx_http_request_body.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_write_request_body(ngx_http_request_t *r);,18,67,http\ngx_http_request_body.c,ngx_http_write_request_body,,false,15,15,ngx_http_write_request_body,,,3,ngx_int_t ngx_http_write_request_body (ngx_http_request_t*)
295158,METHOD,http\ngx_http_request_body.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_read_discarded_request_body(ngx_http_request_t *r);,18,76,http\ngx_http_request_body.c,ngx_http_read_discarded_request_body,,false,16,16,ngx_http_read_discarded_request_body,,,4,ngx_int_t ngx_http_read_discarded_request_body (ngx_http_request_t*)
295163,METHOD,http\ngx_http_request_body.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_discard_request_body_filter(ngx_http_request_t *r,
    ngx_buf_t *b);",18,17,http\ngx_http_request_body.c,ngx_http_discard_request_body_filter,,false,17,18,ngx_http_discard_request_body_filter,,,5,"ngx_int_t ngx_http_discard_request_body_filter (ngx_http_request_t*,ngx_buf_t*)"
295169,METHOD,http\ngx_http_request_body.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_test_expect(ngx_http_request_t *r);,18,60,http\ngx_http_request_body.c,ngx_http_test_expect,,false,19,19,ngx_http_test_expect,,,6,ngx_int_t ngx_http_test_expect (ngx_http_request_t*)
295174,METHOD,http\ngx_http_request_body.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_request_body_filter(ngx_http_request_t *r,
    ngx_chain_t *in);",18,20,http\ngx_http_request_body.c,ngx_http_request_body_filter,,false,21,22,ngx_http_request_body_filter,,,7,"ngx_int_t ngx_http_request_body_filter (ngx_http_request_t*,ngx_chain_t*)"
295180,METHOD,http\ngx_http_request_body.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_request_body_length_filter(ngx_http_request_t *r,
    ngx_chain_t *in);",18,20,http\ngx_http_request_body.c,ngx_http_request_body_length_filter,,false,23,24,ngx_http_request_body_length_filter,,,8,"ngx_int_t ngx_http_request_body_length_filter (ngx_http_request_t*,ngx_chain_t*)"
295186,METHOD,http\ngx_http_request_body.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_request_body_chunked_filter(ngx_http_request_t *r,
    ngx_chain_t *in);",18,20,http\ngx_http_request_body.c,ngx_http_request_body_chunked_filter,,false,25,26,ngx_http_request_body_chunked_filter,,,9,"ngx_int_t ngx_http_request_body_chunked_filter (ngx_http_request_t*,ngx_chain_t*)"
295192,METHOD,http\ngx_http_request_body.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_read_client_request_body(ngx_http_request_t *r,
    ngx_http_client_body_handler_pt post_handler)
{
    size_t                     preread;
    ssize_t                    size;
    ngx_int_t                  rc;
    ngx_buf_t                 *b;
    ngx_chain_t                out;
    ngx_http_request_body_t   *rb;
    ngx_http_core_loc_conf_t  *clcf;

    r->main->count++;

    if (r != r->main || r->request_body || r->discard_body) {
        r->request_body_no_buffering = 0;
        post_handler(r);
        return NGX_OK;
    }

    if (ngx_http_test_expect(r) != NGX_OK) {
        rc = NGX_HTTP_INTERNAL_SERVER_ERROR;
        goto done;
    }

    rb = ngx_pcalloc(r->pool, sizeof(ngx_http_request_body_t));
    if (rb == NULL) {
        rc = NGX_HTTP_INTERNAL_SERVER_ERROR;
        goto done;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     rb->bufs = NULL;
     *     rb->buf = NULL;
     *     rb->free = NULL;
     *     rb->busy = NULL;
     *     rb-...",1,1,http\ngx_http_request_body.c,ngx_http_read_client_request_body,,false,29,209,ngx_http_read_client_request_body,,,10,"ngx_int_t ngx_http_read_client_request_body (ngx_http_request_t*,ngx_http_client_body_handler_pt)"
295662,METHOD,http\ngx_http_request_body.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_read_unbuffered_request_body(ngx_http_request_t *r)
{
    ngx_int_t  rc;

#if (NGX_HTTP_V2)
    if (r->stream) {
        rc = ngx_http_v2_read_unbuffered_request_body(r);

        if (rc == NGX_OK) {
            r->reading_body = 0;
        }

        return rc;
    }
#endif

    if (r->connection->read->timedout) {
        r->connection->timedout = 1;
        return NGX_HTTP_REQUEST_TIME_OUT;
    }

    rc = ngx_http_do_read_client_request_body(r);

    if (rc == NGX_OK) {
        r->reading_body = 0;
    }

    return rc;
}",1,1,http\ngx_http_request_body.c,ngx_http_read_unbuffered_request_body,,false,212,241,ngx_http_read_unbuffered_request_body,,,11,ngx_int_t ngx_http_read_unbuffered_request_body (ngx_http_request_t*)
295702,METHOD,http\ngx_http_request_body.c:<global>,TYPE_DECL,"static void
ngx_http_read_client_request_body_handler(ngx_http_request_t *r)
{
    ngx_int_t  rc;

    if (r->connection->read->timedout) {
        r->connection->timedout = 1;
        ngx_http_finalize_request(r, NGX_HTTP_REQUEST_TIME_OUT);
        return;
    }

    rc = ngx_http_do_read_client_request_body(r);

    if (rc >= NGX_HTTP_SPECIAL_RESPONSE) {
        ngx_http_finalize_request(r, rc);
    }
}",1,1,http\ngx_http_request_body.c,ngx_http_read_client_request_body_handler,,false,244,260,ngx_http_read_client_request_body_handler,,,12,void ngx_http_read_client_request_body_handler (ngx_http_request_t*)
295740,METHOD,http\ngx_http_request_body.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_do_read_client_request_body(ngx_http_request_t *r)
{
    off_t                      rest;
    size_t                     size;
    ssize_t                    n;
    ngx_int_t                  rc;
    ngx_chain_t                out;
    ngx_connection_t          *c;
    ngx_http_request_body_t   *rb;
    ngx_http_core_loc_conf_t  *clcf;

    c = r->connection;
    rb = r->request_body;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,
                   ""http read client request body"");

    for ( ;; ) {
        for ( ;; ) {
            if (rb->buf->last == rb->buf->end) {

                if (rb->buf->pos != rb->buf->last) {

                    /* pass buffer to request body filter chain */

                    out.buf = rb->buf;
                    out.next = NULL;

                    rc = ngx_http_request_body_filter(r, &out);

                    if (rc != NGX_OK) {
                        return rc;
                    }

                } else {

  ...",1,1,http\ngx_http_request_body.c,ngx_http_do_read_client_request_body,,false,263,425,ngx_http_do_read_client_request_body,,,13,ngx_int_t ngx_http_do_read_client_request_body (ngx_http_request_t*)
296184,METHOD,http\ngx_http_request_body.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_write_request_body(ngx_http_request_t *r)
{
    ssize_t                    n;
    ngx_chain_t               *cl, *ln;
    ngx_temp_file_t           *tf;
    ngx_http_request_body_t   *rb;
    ngx_http_core_loc_conf_t  *clcf;

    rb = r->request_body;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http write client request body, bufs %p"", rb->bufs);

    if (rb->temp_file == NULL) {
        tf = ngx_pcalloc(r->pool, sizeof(ngx_temp_file_t));
        if (tf == NULL) {
            return NGX_ERROR;
        }

        clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

        tf->file.fd = NGX_INVALID_FILE;
        tf->file.log = r->connection->log;
        tf->path = clcf->client_body_temp_path;
        tf->pool = r->pool;
        tf->warn = ""a client request body is buffered to a temporary file"";
        tf->log_level = r->request_body_file_log_level;
        tf->persistent = r->request_body_in_persistent_file;...",1,1,http\ngx_http_request_body.c,ngx_http_write_request_body,,false,428,507,ngx_http_write_request_body,,,14,ngx_int_t ngx_http_write_request_body (ngx_http_request_t*)
296419,METHOD,http\ngx_http_request_body.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_discard_request_body(ngx_http_request_t *r)
{
    ssize_t       size;
    ngx_int_t     rc;
    ngx_event_t  *rev;

    if (r != r->main || r->discard_body || r->request_body) {
        return NGX_OK;
    }

#if (NGX_HTTP_V2)
    if (r->stream) {
        r->stream->skip_data = 1;
        return NGX_OK;
    }
#endif

    if (ngx_http_test_expect(r) != NGX_OK) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    rev = r->connection->read;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, rev->log, 0, ""http set discard body"");

    if (rev->timer_set) {
        ngx_del_timer(rev);
    }

    if (r->headers_in.content_length_n <= 0 && !r->headers_in.chunked) {
        return NGX_OK;
    }

    size = r->header_in->last - r->header_in->pos;

    if (size || r->headers_in.chunked) {
        rc = ngx_http_discard_request_body_filter(r, r->header_in);

        if (rc != NGX_OK) {
            return rc;
        }

        if (r->headers_in.content_length_n == 0) {
           ...",1,1,http\ngx_http_request_body.c,ngx_http_discard_request_body,,false,510,581,ngx_http_discard_request_body,,,15,ngx_int_t ngx_http_discard_request_body (ngx_http_request_t*)
296586,METHOD,http\ngx_http_request_body.c:<global>,TYPE_DECL,"void
ngx_http_discarded_request_body_handler(ngx_http_request_t *r)
{
    ngx_int_t                  rc;
    ngx_msec_t                 timer;
    ngx_event_t               *rev;
    ngx_connection_t          *c;
    ngx_http_core_loc_conf_t  *clcf;

    c = r->connection;
    rev = c->read;

    if (rev->timedout) {
        c->timedout = 1;
        c->error = 1;
        ngx_http_finalize_request(r, NGX_ERROR);
        return;
    }

    if (r->lingering_time) {
        timer = (ngx_msec_t) r->lingering_time - (ngx_msec_t) ngx_time();

        if ((ngx_msec_int_t) timer <= 0) {
            r->discard_body = 0;
            r->lingering_close = 0;
            ngx_http_finalize_request(r, NGX_ERROR);
            return;
        }

    } else {
        timer = 0;
    }

    rc = ngx_http_read_discarded_request_body(r);

    if (rc == NGX_OK) {
        r->discard_body = 0;
        r->lingering_close = 0;
        ngx_http_finalize_request(r, NGX_DONE);
        return;
    }

    if (rc >=...",1,1,http\ngx_http_request_body.c,ngx_http_discarded_request_body_handler,,false,584,652,ngx_http_discarded_request_body_handler,,,16,void ngx_http_discarded_request_body_handler (ngx_http_request_t*)
296746,METHOD,http\ngx_http_request_body.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_read_discarded_request_body(ngx_http_request_t *r)
{
    size_t     size;
    ssize_t    n;
    ngx_int_t  rc;
    ngx_buf_t  b;
    u_char     buffer[NGX_HTTP_DISCARD_BUFFER_SIZE];

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http read discarded body"");

    ngx_memzero(&b, sizeof(ngx_buf_t));

    b.temporary = 1;

    for ( ;; ) {
        if (r->headers_in.content_length_n == 0) {
            r->read_event_handler = ngx_http_block_reading;
            return NGX_OK;
        }

        if (!r->connection->read->ready) {
            return NGX_AGAIN;
        }

        size = (size_t) ngx_min(r->headers_in.content_length_n,
                                NGX_HTTP_DISCARD_BUFFER_SIZE);

        n = r->connection->recv(r->connection, buffer, size);

        if (n == NGX_ERROR) {
            r->connection->error = 1;
            return NGX_OK;
        }

        if (n == NGX_AGAIN) {
            return NGX_AGAIN;
       ...",1,1,http\ngx_http_request_body.c,ngx_http_read_discarded_request_body,,false,655,708,ngx_http_read_discarded_request_body,,,17,ngx_int_t ngx_http_read_discarded_request_body (ngx_http_request_t*)
296883,METHOD,http\ngx_http_request_body.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_discard_request_body_filter(ngx_http_request_t *r, ngx_buf_t *b)
{
    size_t                    size;
    ngx_int_t                 rc;
    ngx_http_request_body_t  *rb;

    if (r->headers_in.chunked) {

        rb = r->request_body;

        if (rb == NULL) {

            rb = ngx_pcalloc(r->pool, sizeof(ngx_http_request_body_t));
            if (rb == NULL) {
                return NGX_HTTP_INTERNAL_SERVER_ERROR;
            }

            rb->chunked = ngx_pcalloc(r->pool, sizeof(ngx_http_chunked_t));
            if (rb->chunked == NULL) {
                return NGX_HTTP_INTERNAL_SERVER_ERROR;
            }

            r->request_body = rb;
        }

        for ( ;; ) {

            rc = ngx_http_parse_chunked(r, b, rb->chunked);

            if (rc == NGX_OK) {

                /* a chunk has been parsed successfully */

                size = b->last - b->pos;

                if ((off_t) size > rb->chunked->size) {
                    b->pos += (...",1,1,http\ngx_http_request_body.c,ngx_http_discard_request_body_filter,,false,711,797,ngx_http_discard_request_body_filter,,,18,"ngx_int_t ngx_http_discard_request_body_filter (ngx_http_request_t*,ngx_buf_t*)"
297118,METHOD,http\ngx_http_request_body.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_test_expect(ngx_http_request_t *r)
{
    ngx_int_t   n;
    ngx_str_t  *expect;

    if (r->expect_tested
        || r->headers_in.expect == NULL
        || r->http_version < NGX_HTTP_VERSION_11
#if (NGX_HTTP_V2)
        || r->stream != NULL
#endif
       )
    {
        return NGX_OK;
    }

    r->expect_tested = 1;

    expect = &r->headers_in.expect->value;

    if (expect->len != sizeof(""100-continue"") - 1
        || ngx_strncasecmp(expect->data, (u_char *) ""100-continue"",
                           sizeof(""100-continue"") - 1)
           != 0)
    {
        return NGX_OK;
    }

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""send 100 Continue"");

    n = r->connection->send(r->connection,
                            (u_char *) ""HTTP/1.1 100 Continue"" CRLF CRLF,
                            sizeof(""HTTP/1.1 100 Continue"" CRLF CRLF) - 1);

    if (n == sizeof(""HTTP/1.1 100 Continue"" CRLF CRLF) - 1) {
        return NGX_O...",1,1,http\ngx_http_request_body.c,ngx_http_test_expect,,false,800,845,ngx_http_test_expect,,,19,ngx_int_t ngx_http_test_expect (ngx_http_request_t*)
297211,METHOD,http\ngx_http_request_body.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_request_body_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    if (r->headers_in.chunked) {
        return ngx_http_request_body_chunked_filter(r, in);

    } else {
        return ngx_http_request_body_length_filter(r, in);
    }
}",1,1,http\ngx_http_request_body.c,ngx_http_request_body_filter,,false,848,857,ngx_http_request_body_filter,,,20,"ngx_int_t ngx_http_request_body_filter (ngx_http_request_t*,ngx_chain_t*)"
297234,METHOD,http\ngx_http_request_body.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_request_body_length_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    size_t                     size;
    ngx_int_t                  rc;
    ngx_buf_t                 *b;
    ngx_chain_t               *cl, *tl, *out, **ll;
    ngx_http_request_body_t   *rb;

    rb = r->request_body;

    if (rb->rest == -1) {
        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                       ""http request body content length filter"");

        rb->rest = r->headers_in.content_length_n;
    }

    out = NULL;
    ll = &out;

    for (cl = in; cl; cl = cl->next) {

        if (rb->rest == 0) {
            break;
        }

        tl = ngx_chain_get_free_buf(r->pool, &rb->free);
        if (tl == NULL) {
            return NGX_HTTP_INTERNAL_SERVER_ERROR;
        }

        b = tl->buf;

        ngx_memzero(b, sizeof(ngx_buf_t));

        b->temporary = 1;
        b->tag = (ngx_buf_tag_t) &ngx_http_read_client_request_body;
        b->start = cl->buf...",1,1,http\ngx_http_request_body.c,ngx_http_request_body_length_filter,,false,860,927,ngx_http_request_body_length_filter,,,21,"ngx_int_t ngx_http_request_body_length_filter (ngx_http_request_t*,ngx_chain_t*)"
297491,METHOD,http\ngx_http_request_body.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_request_body_chunked_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    size_t                     size;
    ngx_int_t                  rc;
    ngx_buf_t                 *b;
    ngx_chain_t               *cl, *out, *tl, **ll;
    ngx_http_request_body_t   *rb;
    ngx_http_core_loc_conf_t  *clcf;

    rb = r->request_body;

    if (rb->rest == -1) {

        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                       ""http request body chunked filter"");

        rb->chunked = ngx_pcalloc(r->pool, sizeof(ngx_http_chunked_t));
        if (rb->chunked == NULL) {
            return NGX_HTTP_INTERNAL_SERVER_ERROR;
        }

        r->headers_in.content_length_n = 0;
        rb->rest = 3;
    }

    out = NULL;
    ll = &out;

    for (cl = in; cl; cl = cl->next) {

        for ( ;; ) {

            ngx_log_debug7(NGX_LOG_DEBUG_EVENT, r->connection->log, 0,
                           ""http body chunked buf ""
                           ""t:...",1,1,http\ngx_http_request_body.c,ngx_http_request_body_chunked_filter,,false,930,1080,ngx_http_request_body_chunked_filter,,,22,"ngx_int_t ngx_http_request_body_chunked_filter (ngx_http_request_t*,ngx_chain_t*)"
297989,METHOD,http\ngx_http_request_body.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_request_body_save_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    ngx_buf_t                 *b;
    ngx_chain_t               *cl;
    ngx_http_request_body_t   *rb;

    rb = r->request_body;

#if (NGX_DEBUG)

#if 0
    for (cl = rb->bufs; cl; cl = cl->next) {
        ngx_log_debug7(NGX_LOG_DEBUG_EVENT, r->connection->log, 0,
                       ""http body old buf t:%d f:%d %p, pos %p, size: %z ""
                       ""file: %O, size: %O"",
                       cl->buf->temporary, cl->buf->in_file,
                       cl->buf->start, cl->buf->pos,
                       cl->buf->last - cl->buf->pos,
                       cl->buf->file_pos,
                       cl->buf->file_last - cl->buf->file_pos);
    }
#endif

    for (cl = in; cl; cl = cl->next) {
        ngx_log_debug7(NGX_LOG_DEBUG_EVENT, r->connection->log, 0,
                       ""http body new buf t:%d f:%d %p, pos %p, size: %z ""
                       ""file: %O, size: %O"",
           ...",1,1,http\ngx_http_request_body.c,ngx_http_request_body_save_filter,,false,1083,1169,ngx_http_request_body_save_filter,,,23,"ngx_int_t ngx_http_request_body_save_filter (ngx_http_request_t*,ngx_chain_t*)"
298154,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,<global>,1,16,http\ngx_http_script.c,http\ngx_http_script.c:<global>,,false,1,1861,<global>,,,1,
298156,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_script_init_arrays(ngx_http_script_compile_t *sc);,18,75,http\ngx_http_script.c,ngx_http_script_init_arrays,,false,13,13,ngx_http_script_init_arrays,,,1,ngx_int_t ngx_http_script_init_arrays (ngx_http_script_compile_t*)
298161,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_script_done(ngx_http_script_compile_t *sc);,18,68,http\ngx_http_script.c,ngx_http_script_done,,false,14,14,ngx_http_script_done,,,2,ngx_int_t ngx_http_script_done (ngx_http_script_compile_t*)
298166,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_script_add_copy_code(ngx_http_script_compile_t *sc,
    ngx_str_t *value, ngx_uint_t last);",18,38,http\ngx_http_script.c,ngx_http_script_add_copy_code,,false,15,16,ngx_http_script_add_copy_code,,,3,"ngx_int_t ngx_http_script_add_copy_code (ngx_http_script_compile_t*,ngx_str_t*,ngx_uint_t)"
298173,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_script_add_var_code(ngx_http_script_compile_t *sc,
    ngx_str_t *name);",18,20,http\ngx_http_script.c,ngx_http_script_add_var_code,,false,17,18,ngx_http_script_add_var_code,,,4,"ngx_int_t ngx_http_script_add_var_code (ngx_http_script_compile_t*,ngx_str_t*)"
298179,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_script_add_args_code(ngx_http_script_compile_t *sc);,18,77,http\ngx_http_script.c,ngx_http_script_add_args_code,,false,19,19,ngx_http_script_add_args_code,,,5,ngx_int_t ngx_http_script_add_args_code (ngx_http_script_compile_t*)
298184,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"static ngx_int_t
    ngx_http_script_add_full_name_code(ngx_http_script_compile_t *sc);",5,69,http\ngx_http_script.c,ngx_http_script_add_full_name_code,,false,25,25,ngx_http_script_add_full_name_code,,,6,ngx_int_t ngx_http_script_add_full_name_code (ngx_http_script_compile_t*)
298189,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,static size_t ngx_http_script_full_name_len_code(ngx_http_script_engine_t *e);,15,77,http\ngx_http_script.c,ngx_http_script_full_name_len_code,,false,26,26,ngx_http_script_full_name_len_code,,,7,size_t ngx_http_script_full_name_len_code (ngx_http_script_engine_t*)
298194,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,static void ngx_http_script_full_name_code(ngx_http_script_engine_t *e);,13,71,http\ngx_http_script.c,ngx_http_script_full_name_code,,false,27,27,ngx_http_script_full_name_code,,,8,void ngx_http_script_full_name_code (ngx_http_script_engine_t*)
298205,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"void
ngx_http_script_flush_complex_value(ngx_http_request_t *r,
    ngx_http_complex_value_t *val)
{
    ngx_uint_t *index;

    index = val->flushes;

    if (index) {
        while (*index != (ngx_uint_t) -1) {

            if (r->variables[*index].no_cacheable) {
                r->variables[*index].valid = 0;
                r->variables[*index].not_found = 0;
            }

            index++;
        }
    }
}",1,1,http\ngx_http_script.c,ngx_http_script_flush_complex_value,,false,35,54,ngx_http_script_flush_complex_value,,,11,"void ngx_http_script_flush_complex_value (ngx_http_request_t*,ngx_http_complex_value_t*)"
298260,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_complex_value(ngx_http_request_t *r, ngx_http_complex_value_t *val,
    ngx_str_t *value)
{
    size_t                        len;
    ngx_http_script_code_pt       code;
    ngx_http_script_len_code_pt   lcode;
    ngx_http_script_engine_t      e;

    if (val->lengths == NULL) {
        *value = val->value;
        return NGX_OK;
    }

    ngx_http_script_flush_complex_value(r, val);

    ngx_memzero(&e, sizeof(ngx_http_script_engine_t));

    e.ip = val->lengths;
    e.request = r;
    e.flushed = 1;

    len = 0;

    while (*(uintptr_t *) e.ip) {
        lcode = *(ngx_http_script_len_code_pt *) e.ip;
        len += lcode(&e);
    }

    value->len = len;
    value->data = ngx_pnalloc(r->pool, len);
    if (value->data == NULL) {
        return NGX_ERROR;
    }

    e.ip = val->values;
    e.pos = value->data;
    e.buf = *value;

    while (*(uintptr_t *) e.ip) {
        code = *(ngx_http_script_code_pt *) e.ip;
        code((ngx_http_script_engine_t *) &e);...",1,1,http\ngx_http_script.c,ngx_http_complex_value,,false,57,104,ngx_http_complex_value,,,12,"ngx_int_t ngx_http_complex_value (ngx_http_request_t*,ngx_http_complex_value_t*,ngx_str_t*)"
298407,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"size_t
ngx_http_complex_value_size(ngx_http_request_t *r,
    ngx_http_complex_value_t *val, size_t default_value)
{
    size_t     size;
    ngx_str_t  value;

    if (val == NULL) {
        return default_value;
    }

    if (val->lengths == NULL) {
        return val->u.size;
    }

    if (ngx_http_complex_value(r, val, &value) != NGX_OK) {
        return default_value;
    }

    size = ngx_parse_size(&value);

    if (size == (size_t) NGX_ERROR) {
        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                      ""invalid size \""%V\"""", &value);
        return default_value;
    }

    return size;
}",1,1,http\ngx_http_script.c,ngx_http_complex_value_size,,false,107,135,ngx_http_complex_value_size,,,13,"size_t ngx_http_complex_value_size (ngx_http_request_t*,ngx_http_complex_value_t*,size_t)"
298474,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_compile_complex_value(ngx_http_compile_complex_value_t *ccv)
{
    ngx_str_t                  *v;
    ngx_uint_t                  i, n, nv, nc;
    ngx_array_t                 flushes, lengths, values, *pf, *pl, *pv;
    ngx_http_script_compile_t   sc;

    v = ccv->value;

    nv = 0;
    nc = 0;

    for (i = 0; i < v->len; i++) {
        if (v->data[i] == '$') {
            if (v->data[i + 1] >= '1' && v->data[i + 1] <= '9') {
                nc++;

            } else {
                nv++;
            }
        }
    }

    if ((v->len == 0 || v->data[0] != '$')
        && (ccv->conf_prefix || ccv->root_prefix))
    {
        if (ngx_conf_full_name(ccv->cf->cycle, v, ccv->conf_prefix) != NGX_OK) {
            return NGX_ERROR;
        }

        ccv->conf_prefix = 0;
        ccv->root_prefix = 0;
    }

    ccv->complex_value->value = *v;
    ccv->complex_value->flushes = NULL;
    ccv->complex_value->lengths = NULL;
    ccv->complex_value->values = NULL;

  ...",1,1,http\ngx_http_script.c,ngx_http_compile_complex_value,,false,138,239,ngx_http_compile_complex_value,,,14,ngx_int_t ngx_http_compile_complex_value (ngx_http_compile_complex_value_t*)
298871,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"char *
ngx_http_set_complex_value_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char  *p = conf;

    ngx_str_t                          *value;
    ngx_http_complex_value_t          **cv;
    ngx_http_compile_complex_value_t    ccv;

    cv = (ngx_http_complex_value_t **) (p + cmd->offset);

    if (*cv != NULL) {
        return ""is duplicate"";
    }

    *cv = ngx_palloc(cf->pool, sizeof(ngx_http_complex_value_t));
    if (*cv == NULL) {
        return NGX_CONF_ERROR;
    }

    value = cf->args->elts;

    ngx_memzero(&ccv, sizeof(ngx_http_compile_complex_value_t));

    ccv.cf = cf;
    ccv.value = &value[1];
    ccv.complex_value = *cv;

    if (ngx_http_compile_complex_value(&ccv) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    return NGX_CONF_OK;
}",1,1,http\ngx_http_script.c,ngx_http_set_complex_value_slot,,false,242,275,ngx_http_set_complex_value_slot,,,15,"char* ngx_http_set_complex_value_slot (ngx_conf_t*,ngx_command_t*,void*)"
298961,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"char *
ngx_http_set_complex_value_size_slot(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf)
{
    char  *p = conf;

    char                      *rv;
    ngx_http_complex_value_t  *cv;

    rv = ngx_http_set_complex_value_slot(cf, cmd, conf);

    if (rv != NGX_CONF_OK) {
        return rv;
    }

    cv = *(ngx_http_complex_value_t **) (p + cmd->offset);

    if (cv->lengths) {
        return NGX_CONF_OK;
    }

    cv->u.size = ngx_parse_size(&cv->value);
    if (cv->u.size == (size_t) NGX_ERROR) {
        return ""invalid value"";
    }

    return NGX_CONF_OK;
}",1,1,http\ngx_http_script.c,ngx_http_set_complex_value_size_slot,,false,278,305,ngx_http_set_complex_value_size_slot,,,16,"char* ngx_http_set_complex_value_size_slot (ngx_conf_t*,ngx_command_t*,void*)"
299030,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_test_predicates(ngx_http_request_t *r, ngx_array_t *predicates)
{
    ngx_str_t                  val;
    ngx_uint_t                 i;
    ngx_http_complex_value_t  *cv;

    if (predicates == NULL) {
        return NGX_OK;
    }

    cv = predicates->elts;

    for (i = 0; i < predicates->nelts; i++) {
        if (ngx_http_complex_value(r, &cv[i], &val) != NGX_OK) {
            return NGX_ERROR;
        }

        if (val.len && (val.len != 1 || val.data[0] != '0')) {
            return NGX_DECLINED;
        }
    }

    return NGX_OK;
}",1,1,http\ngx_http_script.c,ngx_http_test_predicates,,false,308,332,ngx_http_test_predicates,,,17,"ngx_int_t ngx_http_test_predicates (ngx_http_request_t*,ngx_array_t*)"
299101,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_test_required_predicates(ngx_http_request_t *r,
    ngx_array_t *predicates)
{
    ngx_str_t                  val;
    ngx_uint_t                 i;
    ngx_http_complex_value_t  *cv;

    if (predicates == NULL) {
        return NGX_OK;
    }

    cv = predicates->elts;

    for (i = 0; i < predicates->nelts; i++) {
        if (ngx_http_complex_value(r, &cv[i], &val) != NGX_OK) {
            return NGX_ERROR;
        }

        if (val.len == 0 || (val.len == 1 && val.data[0] == '0')) {
            return NGX_DECLINED;
        }
    }

    return NGX_OK;
}",1,1,http\ngx_http_script.c,ngx_http_test_required_predicates,,false,335,360,ngx_http_test_required_predicates,,,18,"ngx_int_t ngx_http_test_required_predicates (ngx_http_request_t*,ngx_array_t*)"
299174,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"char *
ngx_http_set_predicate_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char  *p = conf;

    ngx_str_t                          *value;
    ngx_uint_t                          i;
    ngx_array_t                       **a;
    ngx_http_complex_value_t           *cv;
    ngx_http_compile_complex_value_t    ccv;

    a = (ngx_array_t **) (p + cmd->offset);

    if (*a == NGX_CONF_UNSET_PTR) {
        *a = ngx_array_create(cf->pool, 1, sizeof(ngx_http_complex_value_t));
        if (*a == NULL) {
            return NGX_CONF_ERROR;
        }
    }

    value = cf->args->elts;

    for (i = 1; i < cf->args->nelts; i++) {
        cv = ngx_array_push(*a);
        if (cv == NULL) {
            return NGX_CONF_ERROR;
        }

        ngx_memzero(&ccv, sizeof(ngx_http_compile_complex_value_t));

        ccv.cf = cf;
        ccv.value = &value[i];
        ccv.complex_value = cv;

        if (ngx_http_compile_complex_value(&ccv) != NGX_OK) {
            return NGX_CONF_ERROR;
...",1,1,http\ngx_http_script.c,ngx_http_set_predicate_slot,,false,363,403,ngx_http_set_predicate_slot,,,19,"char* ngx_http_set_predicate_slot (ngx_conf_t*,ngx_command_t*,void*)"
299291,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"ngx_uint_t
ngx_http_script_variables_count(ngx_str_t *value)
{
    ngx_uint_t  i, n;

    for (n = 0, i = 0; i < value->len; i++) {
        if (value->data[i] == '$') {
            n++;
        }
    }

    return n;
}",1,1,http\ngx_http_script.c,ngx_http_script_variables_count,,false,406,418,ngx_http_script_variables_count,,,20,ngx_uint_t ngx_http_script_variables_count (ngx_str_t*)
299328,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_script_compile(ngx_http_script_compile_t *sc)
{
    u_char       ch;
    ngx_str_t    name;
    ngx_uint_t   i, bracket;

    if (ngx_http_script_init_arrays(sc) != NGX_OK) {
        return NGX_ERROR;
    }

    for (i = 0; i < sc->source->len; /* void */ ) {

        name.len = 0;

        if (sc->source->data[i] == '$') {

            if (++i == sc->source->len) {
                goto invalid_variable;
            }

            if (sc->source->data[i] >= '1' && sc->source->data[i] <= '9') {
#if (NGX_PCRE)
                ngx_uint_t  n;

                n = sc->source->data[i] - '0';

                if (sc->captures_mask & ((ngx_uint_t) 1 << n)) {
                    sc->dup_capture = 1;
                }

                sc->captures_mask |= (ngx_uint_t) 1 << n;

                if (ngx_http_script_add_capture_code(sc, n) != NGX_OK) {
                    return NGX_ERROR;
                }

                i++;

                continue;
#else
                ...",1,1,http\ngx_http_script.c,ngx_http_script_compile,,false,421,573,ngx_http_script_compile,,,21,ngx_int_t ngx_http_script_compile (ngx_http_script_compile_t*)
299717,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"u_char *
ngx_http_script_run(ngx_http_request_t *r, ngx_str_t *value,
    void *code_lengths, size_t len, void *code_values)
{
    ngx_uint_t                    i;
    ngx_http_script_code_pt       code;
    ngx_http_script_len_code_pt   lcode;
    ngx_http_script_engine_t      e;
    ngx_http_core_main_conf_t    *cmcf;

    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);

    for (i = 0; i < cmcf->variables.nelts; i++) {
        if (r->variables[i].no_cacheable) {
            r->variables[i].valid = 0;
            r->variables[i].not_found = 0;
        }
    }

    ngx_memzero(&e, sizeof(ngx_http_script_engine_t));

    e.ip = code_lengths;
    e.request = r;
    e.flushed = 1;

    while (*(uintptr_t *) e.ip) {
        lcode = *(ngx_http_script_len_code_pt *) e.ip;
        len += lcode(&e);
    }


    value->len = len;
    value->data = ngx_pnalloc(r->pool, len);
    if (value->data == NULL) {
        return NULL;
    }

    e.ip = code_values;
    e.pos = value->d...",1,1,http\ngx_http_script.c,ngx_http_script_run,,false,576,622,ngx_http_script_run,,,22,"u_char ngx_http_script_run (ngx_http_request_t*,ngx_str_t*,void*,size_t,void*)"
299879,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"void
ngx_http_script_flush_no_cacheable_variables(ngx_http_request_t *r,
    ngx_array_t *indices)
{
    ngx_uint_t  n, *index;

    if (indices) {
        index = indices->elts;
        for (n = 0; n < indices->nelts; n++) {
            if (r->variables[index[n]].no_cacheable) {
                r->variables[index[n]].valid = 0;
                r->variables[index[n]].not_found = 0;
            }
        }
    }
}",1,1,http\ngx_http_script.c,ngx_http_script_flush_no_cacheable_variables,,false,625,640,ngx_http_script_flush_no_cacheable_variables,,,23,"void ngx_http_script_flush_no_cacheable_variables (ngx_http_request_t*,ngx_array_t*)"
299941,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_script_init_arrays(ngx_http_script_compile_t *sc)
{
    ngx_uint_t   n;

    if (sc->flushes && *sc->flushes == NULL) {
        n = sc->variables ? sc->variables : 1;
        *sc->flushes = ngx_array_create(sc->cf->pool, n, sizeof(ngx_uint_t));
        if (*sc->flushes == NULL) {
            return NGX_ERROR;
        }
    }

    if (*sc->lengths == NULL) {
        n = sc->variables * (2 * sizeof(ngx_http_script_copy_code_t)
                             + sizeof(ngx_http_script_var_code_t))
            + sizeof(uintptr_t);

        *sc->lengths = ngx_array_create(sc->cf->pool, n, 1);
        if (*sc->lengths == NULL) {
            return NGX_ERROR;
        }
    }

    if (*sc->values == NULL) {
        n = (sc->variables * (2 * sizeof(ngx_http_script_copy_code_t)
                              + sizeof(ngx_http_script_var_code_t))
                + sizeof(uintptr_t)
                + sc->source->len
                + sizeof(uintptr_t) - 1)
            & ~(s...",1,1,http\ngx_http_script.c,ngx_http_script_init_arrays,,false,643,684,ngx_http_script_init_arrays,,,24,ngx_int_t ngx_http_script_init_arrays (ngx_http_script_compile_t*)
300111,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_script_done(ngx_http_script_compile_t *sc)
{
    ngx_str_t    zero;
    uintptr_t   *code;

    if (sc->zero) {

        zero.len = 1;
        zero.data = (u_char *) ""\0"";

        if (ngx_http_script_add_copy_code(sc, &zero, 0) != NGX_OK) {
            return NGX_ERROR;
        }
    }

    if (sc->conf_prefix || sc->root_prefix) {
        if (ngx_http_script_add_full_name_code(sc) != NGX_OK) {
            return NGX_ERROR;
        }
    }

    if (sc->complete_lengths) {
        code = ngx_http_script_add_code(*sc->lengths, sizeof(uintptr_t), NULL);
        if (code == NULL) {
            return NGX_ERROR;
        }

        *code = (uintptr_t) NULL;
    }

    if (sc->complete_values) {
        code = ngx_http_script_add_code(*sc->values, sizeof(uintptr_t),
                                        &sc->main);
        if (code == NULL) {
            return NGX_ERROR;
        }

        *code = (uintptr_t) NULL;
    }

    return NGX_OK;
}",1,1,http\ngx_http_script.c,ngx_http_script_done,,false,687,729,ngx_http_script_done,,,25,ngx_int_t ngx_http_script_done (ngx_http_script_compile_t*)
300224,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"void *
ngx_http_script_start_code(ngx_pool_t *pool, ngx_array_t **codes, size_t size)
{
    if (*codes == NULL) {
        *codes = ngx_array_create(pool, 256, 1);
        if (*codes == NULL) {
            return NULL;
        }
    }

    return ngx_array_push_n(*codes, size);
}",1,1,http\ngx_http_script.c,ngx_http_script_start_code,,false,732,743,ngx_http_script_start_code,,,26,"void* ngx_http_script_start_code (ngx_pool_t*,ngx_array_t**,size_t)"
300257,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"void *
ngx_http_script_add_code(ngx_array_t *codes, size_t size, void *code)
{
    u_char  *elts, **p;
    void    *new;

    elts = codes->elts;

    new = ngx_array_push_n(codes, size);
    if (new == NULL) {
        return NULL;
    }

    if (code) {
        if (elts != codes->elts) {
            p = code;
            *p += (u_char *) codes->elts - elts;
        }
    }

    return new;
}",1,1,http\ngx_http_script.c,ngx_http_script_add_code,,false,746,767,ngx_http_script_add_code,,,27,"void* ngx_http_script_add_code (ngx_array_t*,size_t,void*)"
300309,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_script_add_copy_code(ngx_http_script_compile_t *sc, ngx_str_t *value,
    ngx_uint_t last)
{
    u_char                       *p;
    size_t                        size, len, zero;
    ngx_http_script_copy_code_t  *code;

    zero = (sc->zero && last);
    len = value->len + zero;

    code = ngx_http_script_add_code(*sc->lengths,
                                    sizeof(ngx_http_script_copy_code_t), NULL);
    if (code == NULL) {
        return NGX_ERROR;
    }

    code->code = (ngx_http_script_code_pt) (void *)
                                                 ngx_http_script_copy_len_code;
    code->len = len;

    size = (sizeof(ngx_http_script_copy_code_t) + len + sizeof(uintptr_t) - 1)
            & ~(sizeof(uintptr_t) - 1);

    code = ngx_http_script_add_code(*sc->values, size, &sc->main);
    if (code == NULL) {
        return NGX_ERROR;
    }

    code->code = ngx_http_script_copy_code;
    code->len = len;

    p = ngx_cpymem((u_char *) code + ...",1,1,http\ngx_http_script.c,ngx_http_script_add_copy_code,,false,770,811,ngx_http_script_add_copy_code,,,28,"ngx_int_t ngx_http_script_add_copy_code (ngx_http_script_compile_t*,ngx_str_t*,ngx_uint_t)"
300441,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"size_t
ngx_http_script_copy_len_code(ngx_http_script_engine_t *e)
{
    ngx_http_script_copy_code_t  *code;

    code = (ngx_http_script_copy_code_t *) e->ip;

    e->ip += sizeof(ngx_http_script_copy_code_t);

    return code->len;
}",1,1,http\ngx_http_script.c,ngx_http_script_copy_len_code,,false,814,824,ngx_http_script_copy_len_code,,,29,size_t ngx_http_script_copy_len_code (ngx_http_script_engine_t*)
300464,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"void
ngx_http_script_copy_code(ngx_http_script_engine_t *e)
{
    u_char                       *p;
    ngx_http_script_copy_code_t  *code;

    code = (ngx_http_script_copy_code_t *) e->ip;

    p = e->pos;

    if (!e->skip) {
        e->pos = ngx_copy(p, e->ip + sizeof(ngx_http_script_copy_code_t),
                          code->len);
    }

    e->ip += sizeof(ngx_http_script_copy_code_t)
          + ((code->len + sizeof(uintptr_t) - 1) & ~(sizeof(uintptr_t) - 1));

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
                   ""http script copy: \""%*s\"""", e->pos - p, p);
}",1,1,http\ngx_http_script.c,ngx_http_script_copy_code,,false,827,847,ngx_http_script_copy_code,,,30,void ngx_http_script_copy_code (ngx_http_script_engine_t*)
300542,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_script_add_var_code(ngx_http_script_compile_t *sc, ngx_str_t *name)
{
    ngx_int_t                    index, *p;
    ngx_http_script_var_code_t  *code;

    index = ngx_http_get_variable_index(sc->cf, name);

    if (index == NGX_ERROR) {
        return NGX_ERROR;
    }

    if (sc->flushes) {
        p = ngx_array_push(*sc->flushes);
        if (p == NULL) {
            return NGX_ERROR;
        }

        *p = index;
    }

    code = ngx_http_script_add_code(*sc->lengths,
                                    sizeof(ngx_http_script_var_code_t), NULL);
    if (code == NULL) {
        return NGX_ERROR;
    }

    code->code = (ngx_http_script_code_pt) (void *)
                                             ngx_http_script_copy_var_len_code;
    code->index = (uintptr_t) index;

    code = ngx_http_script_add_code(*sc->values,
                                    sizeof(ngx_http_script_var_code_t),
                                    &sc->main);
    if (code ==...",1,1,http\ngx_http_script.c,ngx_http_script_add_var_code,,false,850,892,ngx_http_script_add_var_code,,,31,"ngx_int_t ngx_http_script_add_var_code (ngx_http_script_compile_t*,ngx_str_t*)"
300655,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"size_t
ngx_http_script_copy_var_len_code(ngx_http_script_engine_t *e)
{
    ngx_http_variable_value_t   *value;
    ngx_http_script_var_code_t  *code;

    code = (ngx_http_script_var_code_t *) e->ip;

    e->ip += sizeof(ngx_http_script_var_code_t);

    if (e->flushed) {
        value = ngx_http_get_indexed_variable(e->request, code->index);

    } else {
        value = ngx_http_get_flushed_variable(e->request, code->index);
    }

    if (value && !value->not_found) {
        return value->len;
    }

    return 0;
}",1,1,http\ngx_http_script.c,ngx_http_script_copy_var_len_code,,false,895,917,ngx_http_script_copy_var_len_code,,,32,size_t ngx_http_script_copy_var_len_code (ngx_http_script_engine_t*)
300714,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"void
ngx_http_script_copy_var_code(ngx_http_script_engine_t *e)
{
    u_char                      *p;
    ngx_http_variable_value_t   *value;
    ngx_http_script_var_code_t  *code;

    code = (ngx_http_script_var_code_t *) e->ip;

    e->ip += sizeof(ngx_http_script_var_code_t);

    if (!e->skip) {

        if (e->flushed) {
            value = ngx_http_get_indexed_variable(e->request, code->index);

        } else {
            value = ngx_http_get_flushed_variable(e->request, code->index);
        }

        if (value && !value->not_found) {
            p = e->pos;
            e->pos = ngx_copy(p, value->data, value->len);

            ngx_log_debug2(NGX_LOG_DEBUG_HTTP,
                           e->request->connection->log, 0,
                           ""http script var: \""%*s\"""", e->pos - p, p);
        }
    }
}",1,1,http\ngx_http_script.c,ngx_http_script_copy_var_code,,false,920,949,ngx_http_script_copy_var_code,,,33,void ngx_http_script_copy_var_code (ngx_http_script_engine_t*)
300808,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_script_add_args_code(ngx_http_script_compile_t *sc)
{
    uintptr_t   *code;

    code = ngx_http_script_add_code(*sc->lengths, sizeof(uintptr_t), NULL);
    if (code == NULL) {
        return NGX_ERROR;
    }

    *code = (uintptr_t) ngx_http_script_mark_args_code;

    code = ngx_http_script_add_code(*sc->values, sizeof(uintptr_t), &sc->main);
    if (code == NULL) {
        return NGX_ERROR;
    }

    *code = (uintptr_t) ngx_http_script_start_args_code;

    return NGX_OK;
}",1,1,http\ngx_http_script.c,ngx_http_script_add_args_code,,false,952,972,ngx_http_script_add_args_code,,,34,ngx_int_t ngx_http_script_add_args_code (ngx_http_script_compile_t*)
300865,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"size_t
ngx_http_script_mark_args_code(ngx_http_script_engine_t *e)
{
    e->is_args = 1;
    e->ip += sizeof(uintptr_t);

    return 1;
}",1,1,http\ngx_http_script.c,ngx_http_script_mark_args_code,,false,975,982,ngx_http_script_mark_args_code,,,35,size_t ngx_http_script_mark_args_code (ngx_http_script_engine_t*)
300883,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"void
ngx_http_script_start_args_code(ngx_http_script_engine_t *e)
{
    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
                   ""http script args"");

    e->is_args = 1;
    e->args = e->pos;
    e->ip += sizeof(uintptr_t);
}",1,1,http\ngx_http_script.c,ngx_http_script_start_args_code,,false,985,994,ngx_http_script_start_args_code,,,36,void ngx_http_script_start_args_code (ngx_http_script_engine_t*)
300917,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_script_add_full_name_code(ngx_http_script_compile_t *sc)
{
    ngx_http_script_full_name_code_t  *code;

    code = ngx_http_script_add_code(*sc->lengths,
                                    sizeof(ngx_http_script_full_name_code_t),
                                    NULL);
    if (code == NULL) {
        return NGX_ERROR;
    }

    code->code = (ngx_http_script_code_pt) (void *)
                                            ngx_http_script_full_name_len_code;
    code->conf_prefix = sc->conf_prefix;

    code = ngx_http_script_add_code(*sc->values,
                                    sizeof(ngx_http_script_full_name_code_t),
                                    &sc->main);
    if (code == NULL) {
        return NGX_ERROR;
    }

    code->code = ngx_http_script_full_name_code;
    code->conf_prefix = sc->conf_prefix;

    return NGX_OK;
}",1,1,http\ngx_http_script.c,ngx_http_script_add_full_name_code,,false,1375,1402,ngx_http_script_add_full_name_code,,,37,ngx_int_t ngx_http_script_add_full_name_code (ngx_http_script_compile_t*)
300990,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"static size_t
ngx_http_script_full_name_len_code(ngx_http_script_engine_t *e)
{
    ngx_http_script_full_name_code_t  *code;

    code = (ngx_http_script_full_name_code_t *) e->ip;

    e->ip += sizeof(ngx_http_script_full_name_code_t);

    return code->conf_prefix ? ngx_cycle->conf_prefix.len:
                               ngx_cycle->prefix.len;
}",1,1,http\ngx_http_script.c,ngx_http_script_full_name_len_code,,false,1405,1416,ngx_http_script_full_name_len_code,,,38,size_t ngx_http_script_full_name_len_code (ngx_http_script_engine_t*)
301024,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"static void
ngx_http_script_full_name_code(ngx_http_script_engine_t *e)
{
    ngx_http_script_full_name_code_t  *code;

    ngx_str_t  value, *prefix;

    code = (ngx_http_script_full_name_code_t *) e->ip;

    value.data = e->buf.data;
    value.len = e->pos - e->buf.data;

    prefix = code->conf_prefix ? (ngx_str_t *) &ngx_cycle->conf_prefix:
                                 (ngx_str_t *) &ngx_cycle->prefix;

    if (ngx_get_full_name(e->request->pool, prefix, &value) != NGX_OK) {
        e->ip = ngx_http_script_exit;
        e->status = NGX_HTTP_INTERNAL_SERVER_ERROR;
        return;
    }

    e->buf = value;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
                   ""http script fullname: \""%V\"""", &value);

    e->ip += sizeof(ngx_http_script_full_name_code_t);
}",1,16,http\ngx_http_script.c,ngx_http_script_full_name_code,,false,1419,1446,ngx_http_script_full_name_code,,,39,void ngx_http_script_full_name_code (ngx_http_script_engine_t*)
301132,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"void
ngx_http_script_return_code(ngx_http_script_engine_t *e)
{
    ngx_http_script_return_code_t  *code;

    code = (ngx_http_script_return_code_t *) e->ip;

    if (code->status < NGX_HTTP_BAD_REQUEST
        || code->text.value.len
        || code->text.lengths)
    {
        e->status = ngx_http_send_response(e->request, code->status, NULL,
                                           &code->text);
    } else {
        e->status = code->status;
    }

    e->ip = ngx_http_script_exit;
}",1,12,http\ngx_http_script.c,ngx_http_script_return_code,,false,1449,1467,ngx_http_script_return_code,,,40,void ngx_http_script_return_code (ngx_http_script_engine_t*)
301201,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"void
ngx_http_script_break_code(ngx_http_script_engine_t *e)
{
    ngx_http_request_t  *r;

    r = e->request;

    if (r->uri_changed) {
        r->valid_location = 0;
        r->uri_changed = 0;
    }

    e->ip = ngx_http_script_exit;
}",1,12,http\ngx_http_script.c,ngx_http_script_break_code,,false,1470,1483,ngx_http_script_break_code,,,41,void ngx_http_script_break_code (ngx_http_script_engine_t*)
301237,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"void
ngx_http_script_if_code(ngx_http_script_engine_t *e)
{
    ngx_http_script_if_code_t  *code;

    code = (ngx_http_script_if_code_t *) e->ip;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
                   ""http script if"");

    e->sp--;

    if (e->sp->len && (e->sp->len != 1 || e->sp->data[0] != '0')) {
        if (code->loc_conf) {
            e->request->loc_conf = code->loc_conf;
            ngx_http_update_location_config(e->request);
        }

        e->ip += sizeof(ngx_http_script_if_code_t);
        return;
    }

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
                   ""http script if: false"");

    e->ip += code->next;
}",1,1,http\ngx_http_script.c,ngx_http_script_if_code,,false,1486,1512,ngx_http_script_if_code,,,42,void ngx_http_script_if_code (ngx_http_script_engine_t*)
301333,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"void
ngx_http_script_equal_code(ngx_http_script_engine_t *e)
{
    ngx_http_variable_value_t  *val, *res;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
                   ""http script equal"");

    e->sp--;
    val = e->sp;
    res = e->sp - 1;

    e->ip += sizeof(uintptr_t);

    if (val->len == res->len
        && ngx_strncmp(val->data, res->data, res->len) == 0)
    {
        *res = ngx_http_variable_true_value;
        return;
    }

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
                   ""http script equal: no"");

    *res = ngx_http_variable_null_value;
}",1,1,http\ngx_http_script.c,ngx_http_script_equal_code,,false,1515,1540,ngx_http_script_equal_code,,,43,void ngx_http_script_equal_code (ngx_http_script_engine_t*)
301415,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"void
ngx_http_script_not_equal_code(ngx_http_script_engine_t *e)
{
    ngx_http_variable_value_t  *val, *res;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
                   ""http script not equal"");

    e->sp--;
    val = e->sp;
    res = e->sp - 1;

    e->ip += sizeof(uintptr_t);

    if (val->len == res->len
        && ngx_strncmp(val->data, res->data, res->len) == 0)
    {
        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
                       ""http script not equal: no"");

        *res = ngx_http_variable_null_value;
        return;
    }

    *res = ngx_http_variable_true_value;
}",1,1,http\ngx_http_script.c,ngx_http_script_not_equal_code,,false,1543,1568,ngx_http_script_not_equal_code,,,44,void ngx_http_script_not_equal_code (ngx_http_script_engine_t*)
301497,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"void
ngx_http_script_file_code(ngx_http_script_engine_t *e)
{
    ngx_str_t                     path;
    ngx_http_request_t           *r;
    ngx_open_file_info_t          of;
    ngx_http_core_loc_conf_t     *clcf;
    ngx_http_variable_value_t    *value;
    ngx_http_script_file_code_t  *code;

    value = e->sp - 1;

    code = (ngx_http_script_file_code_t *) e->ip;
    e->ip += sizeof(ngx_http_script_file_code_t);

    path.len = value->len - 1;
    path.data = value->data;

    r = e->request;

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http script file op %p \""%V\"""", (void *) code->op, &path);

    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    ngx_memzero(&of, sizeof(ngx_open_file_info_t));

    of.read_ahead = clcf->read_ahead;
    of.directio = clcf->directio;
    of.valid = clcf->open_file_cache_valid;
    of.min_uses = clcf->open_file_cache_min_uses;
    of.test_only = 1;
    of.errors = clcf->open_file_cache_err...",1,16,http\ngx_http_script.c,ngx_http_script_file_code,,false,1571,1709,ngx_http_script_file_code,,,45,void ngx_http_script_file_code (ngx_http_script_engine_t*)
301861,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"void
ngx_http_script_complex_value_code(ngx_http_script_engine_t *e)
{
    size_t                                 len;
    ngx_http_script_engine_t               le;
    ngx_http_script_len_code_pt            lcode;
    ngx_http_script_complex_value_code_t  *code;

    code = (ngx_http_script_complex_value_code_t *) e->ip;

    e->ip += sizeof(ngx_http_script_complex_value_code_t);

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
                   ""http script complex value"");

    ngx_memzero(&le, sizeof(ngx_http_script_engine_t));

    le.ip = code->lengths->elts;
    le.line = e->line;
    le.request = e->request;
    le.quote = e->quote;

    for (len = 0; *(uintptr_t *) le.ip; len += lcode(&le)) {
        lcode = *(ngx_http_script_len_code_pt *) le.ip;
    }

    e->buf.len = len;
    e->buf.data = ngx_pnalloc(e->request->pool, len);
    if (e->buf.data == NULL) {
        e->ip = ngx_http_script_exit;
        e->status = NGX_HTTP_INTERNAL_SERVER_ERROR;
 ...",1,16,http\ngx_http_script.c,ngx_http_script_complex_value_code,,false,1712,1751,ngx_http_script_complex_value_code,,,46,void ngx_http_script_complex_value_code (ngx_http_script_engine_t*)
302034,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"void
ngx_http_script_value_code(ngx_http_script_engine_t *e)
{
    ngx_http_script_value_code_t  *code;

    code = (ngx_http_script_value_code_t *) e->ip;

    e->ip += sizeof(ngx_http_script_value_code_t);

    e->sp->len = code->text_len;
    e->sp->data = (u_char *) code->text_data;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
                   ""http script value: \""%v\"""", e->sp);

    e->sp++;
}",1,1,http\ngx_http_script.c,ngx_http_script_value_code,,false,1754,1770,ngx_http_script_value_code,,,47,void ngx_http_script_value_code (ngx_http_script_engine_t*)
302091,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"void
ngx_http_script_set_var_code(ngx_http_script_engine_t *e)
{
    ngx_http_request_t          *r;
    ngx_http_script_var_code_t  *code;

    code = (ngx_http_script_var_code_t *) e->ip;

    e->ip += sizeof(ngx_http_script_var_code_t);

    r = e->request;

    e->sp--;

    r->variables[code->index].len = e->sp->len;
    r->variables[code->index].valid = 1;
    r->variables[code->index].no_cacheable = 0;
    r->variables[code->index].not_found = 0;
    r->variables[code->index].data = e->sp->data;

#if (NGX_DEBUG)
    {
    ngx_http_variable_t        *v;
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);

    v = cmcf->variables.elts;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
                   ""http script set $%V"", &v[code->index].name);
    }
#endif
}",1,1,http\ngx_http_script.c,ngx_http_script_set_var_code,,false,1773,1806,ngx_http_script_set_var_code,,,48,void ngx_http_script_set_var_code (ngx_http_script_engine_t*)
302183,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"void
ngx_http_script_var_set_handler_code(ngx_http_script_engine_t *e)
{
    ngx_http_script_var_handler_code_t  *code;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
                   ""http script set var handler"");

    code = (ngx_http_script_var_handler_code_t *) e->ip;

    e->ip += sizeof(ngx_http_script_var_handler_code_t);

    e->sp--;

    code->handler(e->request, e->sp, code->data);
}",1,1,http\ngx_http_script.c,ngx_http_script_var_set_handler_code,,false,1809,1824,ngx_http_script_var_set_handler_code,,,49,void ngx_http_script_var_set_handler_code (ngx_http_script_engine_t*)
302230,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"void
ngx_http_script_var_code(ngx_http_script_engine_t *e)
{
    ngx_http_variable_value_t   *value;
    ngx_http_script_var_code_t  *code;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
                   ""http script var"");

    code = (ngx_http_script_var_code_t *) e->ip;

    e->ip += sizeof(ngx_http_script_var_code_t);

    value = ngx_http_get_flushed_variable(e->request, code->index);

    if (value && !value->not_found) {
        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
                       ""http script var: \""%v\"""", value);

        *e->sp = *value;
        e->sp++;

        return;
    }

    *e->sp = ngx_http_variable_null_value;
    e->sp++;
}",1,1,http\ngx_http_script.c,ngx_http_script_var_code,,false,1827,1854,ngx_http_script_var_code,,,50,void ngx_http_script_var_code (ngx_http_script_engine_t*)
302312,METHOD,http\ngx_http_script.c:<global>,TYPE_DECL,"void
ngx_http_script_nop_code(ngx_http_script_engine_t *e)
{
    e->ip += sizeof(uintptr_t);
}",1,1,http\ngx_http_script.c,ngx_http_script_nop_code,,false,1857,1861,ngx_http_script_nop_code,,,51,void ngx_http_script_nop_code (ngx_http_script_engine_t*)
302332,METHOD,http\ngx_http_script.h:<global>,TYPE_DECL,<global>,1,41,http\ngx_http_script.h,http\ngx_http_script.h:<global>,,false,1,267,<global>,,,1,
302386,METHOD,http\ngx_http_script.h:<global>,TYPE_DECL,typedef void (*ngx_http_script_code_pt) (ngx_http_script_engine_t *e);,14,69,http\ngx_http_script.h,ngx_http_script_code_pt,,false,89,89,ngx_http_script_code_pt,,,9,void ngx_http_script_code_pt (ngx_http_script_engine_t*)
302391,METHOD,http\ngx_http_script.h:<global>,TYPE_DECL,typedef size_t (*ngx_http_script_len_code_pt) (ngx_http_script_engine_t *e);,16,75,http\ngx_http_script.h,ngx_http_script_len_code_pt,,false,90,90,ngx_http_script_len_code_pt,,,10,size_t ngx_http_script_len_code_pt (ngx_http_script_engine_t*)
302431,METHOD,<empty>,<empty>,<empty>,1,,http\ngx_http_script.h,ngx_http_script_file_op_e:<clinit>,,false,171,,<clinit>,,,9,
302458,METHOD,http\ngx_http_script.h:<global>,TYPE_DECL,"void ngx_http_script_flush_complex_value(ngx_http_request_t *r,
    ngx_http_complex_value_t *val);",6,34,http\ngx_http_script.h,ngx_http_script_flush_complex_value,,false,210,211,ngx_http_script_flush_complex_value,,,33,"void ngx_http_script_flush_complex_value (ngx_http_request_t*,ngx_http_complex_value_t*)"
302464,METHOD,http\ngx_http_script.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_complex_value(ngx_http_request_t *r,
    ngx_http_complex_value_t *val, ngx_str_t *value);",11,52,http\ngx_http_script.h,ngx_http_complex_value,,false,212,213,ngx_http_complex_value,,,34,"ngx_int_t ngx_http_complex_value (ngx_http_request_t*,ngx_http_complex_value_t*,ngx_str_t*)"
302471,METHOD,http\ngx_http_script.h:<global>,TYPE_DECL,"size_t ngx_http_complex_value_size(ngx_http_request_t *r,
    ngx_http_complex_value_t *val, size_t default_value);",8,56,http\ngx_http_script.h,ngx_http_complex_value_size,,false,214,215,ngx_http_complex_value_size,,,35,"size_t ngx_http_complex_value_size (ngx_http_request_t*,ngx_http_complex_value_t*,size_t)"
302478,METHOD,http\ngx_http_script.h:<global>,TYPE_DECL,ngx_int_t ngx_http_compile_complex_value(ngx_http_compile_complex_value_t *ccv);,11,79,http\ngx_http_script.h,ngx_http_compile_complex_value,,false,216,216,ngx_http_compile_complex_value,,,36,ngx_int_t ngx_http_compile_complex_value (ngx_http_compile_complex_value_t*)
302483,METHOD,http\ngx_http_script.h:<global>,TYPE_DECL,"char *ngx_http_set_complex_value_slot(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",6,15,http\ngx_http_script.h,ngx_http_set_complex_value_slot,,false,217,218,ngx_http_set_complex_value_slot,,,37,"char* ngx_http_set_complex_value_slot (ngx_conf_t*,ngx_command_t*,void*)"
302490,METHOD,http\ngx_http_script.h:<global>,TYPE_DECL,"char *ngx_http_set_complex_value_size_slot(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",6,15,http\ngx_http_script.h,ngx_http_set_complex_value_size_slot,,false,219,220,ngx_http_set_complex_value_size_slot,,,38,"char* ngx_http_set_complex_value_size_slot (ngx_conf_t*,ngx_command_t*,void*)"
302497,METHOD,http\ngx_http_script.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_test_predicates(ngx_http_request_t *r,
    ngx_array_t *predicates);",11,28,http\ngx_http_script.h,ngx_http_test_predicates,,false,223,224,ngx_http_test_predicates,,,39,"ngx_int_t ngx_http_test_predicates (ngx_http_request_t*,ngx_array_t*)"
302503,METHOD,http\ngx_http_script.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_test_required_predicates(ngx_http_request_t *r,
    ngx_array_t *predicates);",11,28,http\ngx_http_script.h,ngx_http_test_required_predicates,,false,225,226,ngx_http_test_required_predicates,,,40,"ngx_int_t ngx_http_test_required_predicates (ngx_http_request_t*,ngx_array_t*)"
302509,METHOD,http\ngx_http_script.h:<global>,TYPE_DECL,"char *ngx_http_set_predicate_slot(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",6,15,http\ngx_http_script.h,ngx_http_set_predicate_slot,,false,227,228,ngx_http_set_predicate_slot,,,41,"char* ngx_http_set_predicate_slot (ngx_conf_t*,ngx_command_t*,void*)"
302516,METHOD,http\ngx_http_script.h:<global>,TYPE_DECL,ngx_uint_t ngx_http_script_variables_count(ngx_str_t *value);,12,60,http\ngx_http_script.h,ngx_http_script_variables_count,,false,230,230,ngx_http_script_variables_count,,,42,ngx_uint_t ngx_http_script_variables_count (ngx_str_t*)
302521,METHOD,http\ngx_http_script.h:<global>,TYPE_DECL,ngx_int_t ngx_http_script_compile(ngx_http_script_compile_t *sc);,11,64,http\ngx_http_script.h,ngx_http_script_compile,,false,231,231,ngx_http_script_compile,,,43,ngx_int_t ngx_http_script_compile (ngx_http_script_compile_t*)
302526,METHOD,http\ngx_http_script.h:<global>,TYPE_DECL,"u_char *ngx_http_script_run(ngx_http_request_t *r, ngx_str_t *value,
    void *code_lengths, size_t reserved, void *code_values);",8,59,http\ngx_http_script.h,ngx_http_script_run,,false,232,233,ngx_http_script_run,,,44,"u_char* ngx_http_script_run (ngx_http_request_t*,ngx_str_t*,void*,size_t,void*)"
302535,METHOD,http\ngx_http_script.h:<global>,TYPE_DECL,"void ngx_http_script_flush_no_cacheable_variables(ngx_http_request_t *r,
    ngx_array_t *indices);",6,25,http\ngx_http_script.h,ngx_http_script_flush_no_cacheable_variables,,false,234,235,ngx_http_script_flush_no_cacheable_variables,,,45,"void ngx_http_script_flush_no_cacheable_variables (ngx_http_request_t*,ngx_array_t*)"
302541,METHOD,http\ngx_http_script.h:<global>,TYPE_DECL,"void *ngx_http_script_start_code(ngx_pool_t *pool, ngx_array_t **codes,
    size_t size);",6,16,http\ngx_http_script.h,ngx_http_script_start_code,,false,237,238,ngx_http_script_start_code,,,46,"void* ngx_http_script_start_code (ngx_pool_t*,ngx_array_t**,size_t)"
302548,METHOD,http\ngx_http_script.h:<global>,TYPE_DECL,"void *ngx_http_script_add_code(ngx_array_t *codes, size_t size, void *code);",6,75,http\ngx_http_script.h,ngx_http_script_add_code,,false,239,239,ngx_http_script_add_code,,,47,"void* ngx_http_script_add_code (ngx_array_t*,size_t,void*)"
302555,METHOD,http\ngx_http_script.h:<global>,TYPE_DECL,size_t ngx_http_script_copy_len_code(ngx_http_script_engine_t *e);,8,65,http\ngx_http_script.h,ngx_http_script_copy_len_code,,false,241,241,ngx_http_script_copy_len_code,,,48,size_t ngx_http_script_copy_len_code (ngx_http_script_engine_t*)
302560,METHOD,http\ngx_http_script.h:<global>,TYPE_DECL,void ngx_http_script_copy_code(ngx_http_script_engine_t *e);,6,59,http\ngx_http_script.h,ngx_http_script_copy_code,,false,242,242,ngx_http_script_copy_code,,,49,void ngx_http_script_copy_code (ngx_http_script_engine_t*)
302565,METHOD,http\ngx_http_script.h:<global>,TYPE_DECL,size_t ngx_http_script_copy_var_len_code(ngx_http_script_engine_t *e);,8,69,http\ngx_http_script.h,ngx_http_script_copy_var_len_code,,false,243,243,ngx_http_script_copy_var_len_code,,,50,size_t ngx_http_script_copy_var_len_code (ngx_http_script_engine_t*)
302570,METHOD,http\ngx_http_script.h:<global>,TYPE_DECL,void ngx_http_script_copy_var_code(ngx_http_script_engine_t *e);,6,63,http\ngx_http_script.h,ngx_http_script_copy_var_code,,false,244,244,ngx_http_script_copy_var_code,,,51,void ngx_http_script_copy_var_code (ngx_http_script_engine_t*)
302575,METHOD,http\ngx_http_script.h:<global>,TYPE_DECL,size_t ngx_http_script_copy_capture_len_code(ngx_http_script_engine_t *e);,8,73,http\ngx_http_script.h,ngx_http_script_copy_capture_len_code,,false,245,245,ngx_http_script_copy_capture_len_code,,,52,size_t ngx_http_script_copy_capture_len_code (ngx_http_script_engine_t*)
302580,METHOD,http\ngx_http_script.h:<global>,TYPE_DECL,void ngx_http_script_copy_capture_code(ngx_http_script_engine_t *e);,6,67,http\ngx_http_script.h,ngx_http_script_copy_capture_code,,false,246,246,ngx_http_script_copy_capture_code,,,53,void ngx_http_script_copy_capture_code (ngx_http_script_engine_t*)
302585,METHOD,http\ngx_http_script.h:<global>,TYPE_DECL,size_t ngx_http_script_mark_args_code(ngx_http_script_engine_t *e);,8,66,http\ngx_http_script.h,ngx_http_script_mark_args_code,,false,247,247,ngx_http_script_mark_args_code,,,54,size_t ngx_http_script_mark_args_code (ngx_http_script_engine_t*)
302590,METHOD,http\ngx_http_script.h:<global>,TYPE_DECL,void ngx_http_script_start_args_code(ngx_http_script_engine_t *e);,6,65,http\ngx_http_script.h,ngx_http_script_start_args_code,,false,248,248,ngx_http_script_start_args_code,,,55,void ngx_http_script_start_args_code (ngx_http_script_engine_t*)
302595,METHOD,http\ngx_http_script.h:<global>,TYPE_DECL,void ngx_http_script_return_code(ngx_http_script_engine_t *e);,6,61,http\ngx_http_script.h,ngx_http_script_return_code,,false,253,253,ngx_http_script_return_code,,,56,void ngx_http_script_return_code (ngx_http_script_engine_t*)
302600,METHOD,http\ngx_http_script.h:<global>,TYPE_DECL,void ngx_http_script_break_code(ngx_http_script_engine_t *e);,6,60,http\ngx_http_script.h,ngx_http_script_break_code,,false,254,254,ngx_http_script_break_code,,,57,void ngx_http_script_break_code (ngx_http_script_engine_t*)
302605,METHOD,http\ngx_http_script.h:<global>,TYPE_DECL,void ngx_http_script_if_code(ngx_http_script_engine_t *e);,6,57,http\ngx_http_script.h,ngx_http_script_if_code,,false,255,255,ngx_http_script_if_code,,,58,void ngx_http_script_if_code (ngx_http_script_engine_t*)
302610,METHOD,http\ngx_http_script.h:<global>,TYPE_DECL,void ngx_http_script_equal_code(ngx_http_script_engine_t *e);,6,60,http\ngx_http_script.h,ngx_http_script_equal_code,,false,256,256,ngx_http_script_equal_code,,,59,void ngx_http_script_equal_code (ngx_http_script_engine_t*)
302615,METHOD,http\ngx_http_script.h:<global>,TYPE_DECL,void ngx_http_script_not_equal_code(ngx_http_script_engine_t *e);,6,64,http\ngx_http_script.h,ngx_http_script_not_equal_code,,false,257,257,ngx_http_script_not_equal_code,,,60,void ngx_http_script_not_equal_code (ngx_http_script_engine_t*)
302620,METHOD,http\ngx_http_script.h:<global>,TYPE_DECL,void ngx_http_script_file_code(ngx_http_script_engine_t *e);,6,59,http\ngx_http_script.h,ngx_http_script_file_code,,false,258,258,ngx_http_script_file_code,,,61,void ngx_http_script_file_code (ngx_http_script_engine_t*)
302625,METHOD,http\ngx_http_script.h:<global>,TYPE_DECL,void ngx_http_script_complex_value_code(ngx_http_script_engine_t *e);,6,68,http\ngx_http_script.h,ngx_http_script_complex_value_code,,false,259,259,ngx_http_script_complex_value_code,,,62,void ngx_http_script_complex_value_code (ngx_http_script_engine_t*)
302630,METHOD,http\ngx_http_script.h:<global>,TYPE_DECL,void ngx_http_script_value_code(ngx_http_script_engine_t *e);,6,60,http\ngx_http_script.h,ngx_http_script_value_code,,false,260,260,ngx_http_script_value_code,,,63,void ngx_http_script_value_code (ngx_http_script_engine_t*)
302635,METHOD,http\ngx_http_script.h:<global>,TYPE_DECL,void ngx_http_script_set_var_code(ngx_http_script_engine_t *e);,6,62,http\ngx_http_script.h,ngx_http_script_set_var_code,,false,261,261,ngx_http_script_set_var_code,,,64,void ngx_http_script_set_var_code (ngx_http_script_engine_t*)
302640,METHOD,http\ngx_http_script.h:<global>,TYPE_DECL,void ngx_http_script_var_set_handler_code(ngx_http_script_engine_t *e);,6,70,http\ngx_http_script.h,ngx_http_script_var_set_handler_code,,false,262,262,ngx_http_script_var_set_handler_code,,,65,void ngx_http_script_var_set_handler_code (ngx_http_script_engine_t*)
302645,METHOD,http\ngx_http_script.h:<global>,TYPE_DECL,void ngx_http_script_var_code(ngx_http_script_engine_t *e);,6,58,http\ngx_http_script.h,ngx_http_script_var_code,,false,263,263,ngx_http_script_var_code,,,66,void ngx_http_script_var_code (ngx_http_script_engine_t*)
302650,METHOD,http\ngx_http_script.h:<global>,TYPE_DECL,void ngx_http_script_nop_code(ngx_http_script_engine_t *e);,6,58,http\ngx_http_script.h,ngx_http_script_nop_code,,false,264,264,ngx_http_script_nop_code,,,67,void ngx_http_script_nop_code (ngx_http_script_engine_t*)
302666,METHOD,http\ngx_http_special_response.c:<global>,TYPE_DECL,<global>,1,26,http\ngx_http_special_response.c,http\ngx_http_special_response.c:<global>,,false,1,852,<global>,,,1,
302668,METHOD,http\ngx_http_special_response.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_send_error_page(ngx_http_request_t *r,
    ngx_http_err_page_t *err_page);",18,34,http\ngx_http_special_response.c,ngx_http_send_error_page,,false,14,15,ngx_http_send_error_page,,,1,"ngx_int_t ngx_http_send_error_page (ngx_http_request_t*,ngx_http_err_page_t*)"
302674,METHOD,http\ngx_http_special_response.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_send_special_response(ngx_http_request_t *r,
    ngx_http_core_loc_conf_t *clcf, ngx_uint_t err);",18,51,http\ngx_http_special_response.c,ngx_http_send_special_response,,false,16,17,ngx_http_send_special_response,,,2,"ngx_int_t ngx_http_send_special_response (ngx_http_request_t*,ngx_http_core_loc_conf_t*,ngx_uint_t)"
302681,METHOD,http\ngx_http_special_response.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_send_refresh(ngx_http_request_t *r);,18,61,http\ngx_http_special_response.c,ngx_http_send_refresh,,false,18,18,ngx_http_send_refresh,,,3,ngx_int_t ngx_http_send_refresh (ngx_http_request_t*)
302821,METHOD,http\ngx_http_special_response.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_special_response_handler(ngx_http_request_t *r, ngx_int_t error)
{
    ngx_uint_t                 i, err;
    ngx_http_err_page_t       *err_page;
    ngx_http_core_loc_conf_t  *clcf;

    ngx_log_debug3(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http special response: %i, \""%V?%V\"""",
                   error, &r->uri, &r->args);

    r->err_status = error;

    if (r->keepalive) {
        switch (error) {
            case NGX_HTTP_BAD_REQUEST:
            case NGX_HTTP_REQUEST_ENTITY_TOO_LARGE:
            case NGX_HTTP_REQUEST_URI_TOO_LARGE:
            case NGX_HTTP_TO_HTTPS:
            case NGX_HTTPS_CERT_ERROR:
            case NGX_HTTPS_NO_CERT:
            case NGX_HTTP_INTERNAL_SERVER_ERROR:
            case NGX_HTTP_NOT_IMPLEMENTED:
                r->keepalive = 0;
        }
    }

    if (r->lingering_close) {
        switch (error) {
            case NGX_HTTP_BAD_REQUEST:
            case NGX_HTTP_TO_HTTPS:
            case NGX_HTT...",1,26,http\ngx_http_special_response.c,ngx_http_special_response_handler,,false,415,524,ngx_http_special_response_handler,,,47,"ngx_int_t ngx_http_special_response_handler (ngx_http_request_t*,ngx_int_t)"
303150,METHOD,http\ngx_http_special_response.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_filter_finalize_request(ngx_http_request_t *r, ngx_module_t *m,
    ngx_int_t error)
{
    void       *ctx;
    ngx_int_t   rc;

    ngx_http_clean_header(r);

    ctx = NULL;

    if (m) {
        ctx = r->ctx[m->ctx_index];
    }

    /* clear the modules contexts */
    ngx_memzero(r->ctx, sizeof(void *) * ngx_http_max_module);

    if (m) {
        r->ctx[m->ctx_index] = ctx;
    }

    r->filter_finalize = 1;

    rc = ngx_http_special_response_handler(r, error);

    /* NGX_ERROR resets any pending data */

    switch (rc) {

    case NGX_OK:
    case NGX_DONE:
        return NGX_ERROR;

    default:
        return rc;
    }
}",1,1,http\ngx_http_special_response.c,ngx_http_filter_finalize_request,,false,527,564,ngx_http_filter_finalize_request,,,48,"ngx_int_t ngx_http_filter_finalize_request (ngx_http_request_t*,ngx_module_t*,ngx_int_t)"
303218,METHOD,http\ngx_http_special_response.c:<global>,TYPE_DECL,"void
ngx_http_clean_header(ngx_http_request_t *r)
{
    ngx_memzero(&r->headers_out.status,
                sizeof(ngx_http_headers_out_t)
                    - offsetof(ngx_http_headers_out_t, status));

    r->headers_out.headers.part.nelts = 0;
    r->headers_out.headers.part.next = NULL;
    r->headers_out.headers.last = &r->headers_out.headers.part;

    r->headers_out.content_length_n = -1;
    r->headers_out.last_modified_time = -1;
}",1,1,http\ngx_http_special_response.c,ngx_http_clean_header,,false,567,580,ngx_http_clean_header,,,49,void ngx_http_clean_header (ngx_http_request_t*)
303290,METHOD,http\ngx_http_special_response.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_send_error_page(ngx_http_request_t *r, ngx_http_err_page_t *err_page)
{
    ngx_int_t                  overwrite;
    ngx_str_t                  uri, args;
    ngx_table_elt_t           *location;
    ngx_http_core_loc_conf_t  *clcf;

    overwrite = err_page->overwrite;

    if (overwrite && overwrite != NGX_HTTP_OK) {
        r->expect_tested = 1;
    }

    if (overwrite >= 0) {
        r->err_status = overwrite;
    }

    if (ngx_http_complex_value(r, &err_page->value, &uri) != NGX_OK) {
        return NGX_ERROR;
    }

    if (uri.len && uri.data[0] == '/') {

        if (err_page->value.lengths) {
            ngx_http_split_args(r, &uri, &args);

        } else {
            args = err_page->args;
        }

        if (r->method != NGX_HTTP_HEAD) {
            r->method = NGX_HTTP_GET;
            r->method_name = ngx_http_core_get_method;
        }

        return ngx_http_internal_redirect(r, &uri, &args);
    }

    if (uri.len && uri.data[0] == ...",1,53,http\ngx_http_special_response.c,ngx_http_send_error_page,,false,583,664,ngx_http_send_error_page,,,50,"ngx_int_t ngx_http_send_error_page (ngx_http_request_t*,ngx_http_err_page_t*)"
303534,METHOD,http\ngx_http_special_response.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_send_special_response(ngx_http_request_t *r,
    ngx_http_core_loc_conf_t *clcf, ngx_uint_t err)
{
    u_char       *tail;
    size_t        len;
    ngx_int_t     rc;
    ngx_buf_t    *b;
    ngx_uint_t    msie_padding;
    ngx_chain_t   out[3];

    if (clcf->server_tokens == NGX_HTTP_SERVER_TOKENS_ON) {
        len = sizeof(ngx_http_error_full_tail) - 1;
        tail = ngx_http_error_full_tail;

    } else if (clcf->server_tokens == NGX_HTTP_SERVER_TOKENS_BUILD) {
        len = sizeof(ngx_http_error_build_tail) - 1;
        tail = ngx_http_error_build_tail;

    } else {
        len = sizeof(ngx_http_error_tail) - 1;
        tail = ngx_http_error_tail;
    }

    msie_padding = 0;

    if (ngx_http_error_pages[err].len) {
        r->headers_out.content_length_n = ngx_http_error_pages[err].len + len;
        if (clcf->msie_padding
            && (r->headers_in.msie || r->headers_in.chrome)
            && r->http_version >= NGX_HTTP_VERSION_10
            ...",1,22,http\ngx_http_special_response.c,ngx_http_send_special_response,,false,667,779,ngx_http_send_special_response,,,51,"ngx_int_t ngx_http_send_special_response (ngx_http_request_t*,ngx_http_core_loc_conf_t*,ngx_uint_t)"
303941,METHOD,http\ngx_http_special_response.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_send_refresh(ngx_http_request_t *r)
{
    u_char       *p, *location;
    size_t        len, size;
    uintptr_t     escape;
    ngx_int_t     rc;
    ngx_buf_t    *b;
    ngx_chain_t   out;

    len = r->headers_out.location->value.len;
    location = r->headers_out.location->value.data;

    escape = 2 * ngx_escape_uri(NULL, location, len, NGX_ESCAPE_REFRESH);

    size = sizeof(ngx_http_msie_refresh_head) - 1
           + escape + len
           + sizeof(ngx_http_msie_refresh_tail) - 1;

    r->err_status = NGX_HTTP_OK;

    r->headers_out.content_type_len = sizeof(""text/html"") - 1;
    ngx_str_set(&r->headers_out.content_type, ""text/html"");
    r->headers_out.content_type_lowcase = NULL;

    r->headers_out.location->hash = 0;
    r->headers_out.location = NULL;

    r->headers_out.content_length_n = size;

    if (r->headers_out.content_length) {
        r->headers_out.content_length->hash = 0;
        r->headers_out.content_length = NULL;
    }

    n...",1,1,http\ngx_http_special_response.c,ngx_http_send_refresh,,false,782,852,ngx_http_send_refresh,,,52,ngx_int_t ngx_http_send_refresh (ngx_http_request_t*)
304196,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,<global>,1,1,http\ngx_http_upstream.c,http\ngx_http_upstream.c:<global>,,false,1,6502,<global>,,,1,
304198,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,static void ngx_http_upstream_init_request(ngx_http_request_t *r);,13,65,http\ngx_http_upstream.c,ngx_http_upstream_init_request,,false,32,32,ngx_http_upstream_init_request,,,1,void ngx_http_upstream_init_request (ngx_http_request_t*)
304203,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,static void ngx_http_upstream_resolve_handler(ngx_resolver_ctx_t *ctx);,13,70,http\ngx_http_upstream.c,ngx_http_upstream_resolve_handler,,false,33,33,ngx_http_upstream_resolve_handler,,,2,void ngx_http_upstream_resolve_handler (ngx_resolver_ctx_t*)
304208,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,static void ngx_http_upstream_rd_check_broken_connection(ngx_http_request_t *r);,13,79,http\ngx_http_upstream.c,ngx_http_upstream_rd_check_broken_connection,,false,34,34,ngx_http_upstream_rd_check_broken_connection,,,3,void ngx_http_upstream_rd_check_broken_connection (ngx_http_request_t*)
304213,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,static void ngx_http_upstream_wr_check_broken_connection(ngx_http_request_t *r);,13,79,http\ngx_http_upstream.c,ngx_http_upstream_wr_check_broken_connection,,false,35,35,ngx_http_upstream_wr_check_broken_connection,,,4,void ngx_http_upstream_wr_check_broken_connection (ngx_http_request_t*)
304218,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void ngx_http_upstream_check_broken_connection(ngx_http_request_t *r,
    ngx_event_t *ev);",13,20,http\ngx_http_upstream.c,ngx_http_upstream_check_broken_connection,,false,36,37,ngx_http_upstream_check_broken_connection,,,5,"void ngx_http_upstream_check_broken_connection (ngx_http_request_t*,ngx_event_t*)"
304224,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void ngx_http_upstream_connect(ngx_http_request_t *r,
    ngx_http_upstream_t *u);",13,27,http\ngx_http_upstream.c,ngx_http_upstream_connect,,false,38,39,ngx_http_upstream_connect,,,6,"void ngx_http_upstream_connect (ngx_http_request_t*,ngx_http_upstream_t*)"
304230,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_reinit(ngx_http_request_t *r,
    ngx_http_upstream_t *u);",18,27,http\ngx_http_upstream.c,ngx_http_upstream_reinit,,false,40,41,ngx_http_upstream_reinit,,,7,"ngx_int_t ngx_http_upstream_reinit (ngx_http_request_t*,ngx_http_upstream_t*)"
304236,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void ngx_http_upstream_send_request(ngx_http_request_t *r,
    ngx_http_upstream_t *u, ngx_uint_t do_write);",13,48,http\ngx_http_upstream.c,ngx_http_upstream_send_request,,false,42,43,ngx_http_upstream_send_request,,,8,"void ngx_http_upstream_send_request (ngx_http_request_t*,ngx_http_upstream_t*,ngx_uint_t)"
304243,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_send_request_body(ngx_http_request_t *r,
    ngx_http_upstream_t *u, ngx_uint_t do_write);",18,48,http\ngx_http_upstream.c,ngx_http_upstream_send_request_body,,false,44,45,ngx_http_upstream_send_request_body,,,9,"ngx_int_t ngx_http_upstream_send_request_body (ngx_http_request_t*,ngx_http_upstream_t*,ngx_uint_t)"
304250,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void ngx_http_upstream_send_request_handler(ngx_http_request_t *r,
    ngx_http_upstream_t *u);",13,27,http\ngx_http_upstream.c,ngx_http_upstream_send_request_handler,,false,46,47,ngx_http_upstream_send_request_handler,,,10,"void ngx_http_upstream_send_request_handler (ngx_http_request_t*,ngx_http_upstream_t*)"
304256,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,static void ngx_http_upstream_read_request_handler(ngx_http_request_t *r);,13,73,http\ngx_http_upstream.c,ngx_http_upstream_read_request_handler,,false,48,48,ngx_http_upstream_read_request_handler,,,11,void ngx_http_upstream_read_request_handler (ngx_http_request_t*)
304261,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void ngx_http_upstream_process_header(ngx_http_request_t *r,
    ngx_http_upstream_t *u);",13,27,http\ngx_http_upstream.c,ngx_http_upstream_process_header,,false,49,50,ngx_http_upstream_process_header,,,12,"void ngx_http_upstream_process_header (ngx_http_request_t*,ngx_http_upstream_t*)"
304267,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_test_next(ngx_http_request_t *r,
    ngx_http_upstream_t *u);",18,27,http\ngx_http_upstream.c,ngx_http_upstream_test_next,,false,51,52,ngx_http_upstream_test_next,,,13,"ngx_int_t ngx_http_upstream_test_next (ngx_http_request_t*,ngx_http_upstream_t*)"
304273,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_intercept_errors(ngx_http_request_t *r,
    ngx_http_upstream_t *u);",18,27,http\ngx_http_upstream.c,ngx_http_upstream_intercept_errors,,false,53,54,ngx_http_upstream_intercept_errors,,,14,"ngx_int_t ngx_http_upstream_intercept_errors (ngx_http_request_t*,ngx_http_upstream_t*)"
304279,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_upstream_test_connect(ngx_connection_t *c);,18,68,http\ngx_http_upstream.c,ngx_http_upstream_test_connect,,false,55,55,ngx_http_upstream_test_connect,,,15,ngx_int_t ngx_http_upstream_test_connect (ngx_connection_t*)
304284,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_process_headers(ngx_http_request_t *r,
    ngx_http_upstream_t *u);",18,27,http\ngx_http_upstream.c,ngx_http_upstream_process_headers,,false,56,57,ngx_http_upstream_process_headers,,,16,"ngx_int_t ngx_http_upstream_process_headers (ngx_http_request_t*,ngx_http_upstream_t*)"
304290,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_process_trailers(ngx_http_request_t *r,
    ngx_http_upstream_t *u);",18,27,http\ngx_http_upstream.c,ngx_http_upstream_process_trailers,,false,58,59,ngx_http_upstream_process_trailers,,,17,"ngx_int_t ngx_http_upstream_process_trailers (ngx_http_request_t*,ngx_http_upstream_t*)"
304296,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void ngx_http_upstream_send_response(ngx_http_request_t *r,
    ngx_http_upstream_t *u);",13,27,http\ngx_http_upstream.c,ngx_http_upstream_send_response,,false,60,61,ngx_http_upstream_send_response,,,18,"void ngx_http_upstream_send_response (ngx_http_request_t*,ngx_http_upstream_t*)"
304302,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void ngx_http_upstream_upgrade(ngx_http_request_t *r,
    ngx_http_upstream_t *u);",13,27,http\ngx_http_upstream.c,ngx_http_upstream_upgrade,,false,62,63,ngx_http_upstream_upgrade,,,19,"void ngx_http_upstream_upgrade (ngx_http_request_t*,ngx_http_upstream_t*)"
304308,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,static void ngx_http_upstream_upgraded_read_downstream(ngx_http_request_t *r);,13,77,http\ngx_http_upstream.c,ngx_http_upstream_upgraded_read_downstream,,false,64,64,ngx_http_upstream_upgraded_read_downstream,,,20,void ngx_http_upstream_upgraded_read_downstream (ngx_http_request_t*)
304313,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,static void ngx_http_upstream_upgraded_write_downstream(ngx_http_request_t *r);,13,78,http\ngx_http_upstream.c,ngx_http_upstream_upgraded_write_downstream,,false,65,65,ngx_http_upstream_upgraded_write_downstream,,,21,void ngx_http_upstream_upgraded_write_downstream (ngx_http_request_t*)
304318,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void ngx_http_upstream_upgraded_read_upstream(ngx_http_request_t *r,
    ngx_http_upstream_t *u);",13,27,http\ngx_http_upstream.c,ngx_http_upstream_upgraded_read_upstream,,false,66,67,ngx_http_upstream_upgraded_read_upstream,,,22,"void ngx_http_upstream_upgraded_read_upstream (ngx_http_request_t*,ngx_http_upstream_t*)"
304324,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void ngx_http_upstream_upgraded_write_upstream(ngx_http_request_t *r,
    ngx_http_upstream_t *u);",13,27,http\ngx_http_upstream.c,ngx_http_upstream_upgraded_write_upstream,,false,68,69,ngx_http_upstream_upgraded_write_upstream,,,23,"void ngx_http_upstream_upgraded_write_upstream (ngx_http_request_t*,ngx_http_upstream_t*)"
304330,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void ngx_http_upstream_process_upgraded(ngx_http_request_t *r,
    ngx_uint_t from_upstream, ngx_uint_t do_write);",13,50,http\ngx_http_upstream.c,ngx_http_upstream_process_upgraded,,false,70,71,ngx_http_upstream_process_upgraded,,,24,"void ngx_http_upstream_process_upgraded (ngx_http_request_t*,ngx_uint_t,ngx_uint_t)"
304337,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void
    ngx_http_upstream_process_non_buffered_downstream(ngx_http_request_t *r);",5,76,http\ngx_http_upstream.c,ngx_http_upstream_process_non_buffered_downstream,,false,73,73,ngx_http_upstream_process_non_buffered_downstream,,,25,void ngx_http_upstream_process_non_buffered_downstream (ngx_http_request_t*)
304342,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void
    ngx_http_upstream_process_non_buffered_upstream(ngx_http_request_t *r,
    ngx_http_upstream_t *u);",5,27,http\ngx_http_upstream.c,ngx_http_upstream_process_non_buffered_upstream,,false,75,76,ngx_http_upstream_process_non_buffered_upstream,,,26,"void ngx_http_upstream_process_non_buffered_upstream (ngx_http_request_t*,ngx_http_upstream_t*)"
304348,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void
    ngx_http_upstream_process_non_buffered_request(ngx_http_request_t *r,
    ngx_uint_t do_write);",5,24,http\ngx_http_upstream.c,ngx_http_upstream_process_non_buffered_request,,false,78,79,ngx_http_upstream_process_non_buffered_request,,,27,"void ngx_http_upstream_process_non_buffered_request (ngx_http_request_t*,ngx_uint_t)"
304354,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_upstream_non_buffered_filter_init(void *data);,18,71,http\ngx_http_upstream.c,ngx_http_upstream_non_buffered_filter_init,,false,80,80,ngx_http_upstream_non_buffered_filter_init,,,28,ngx_int_t ngx_http_upstream_non_buffered_filter_init (void*)
304359,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_non_buffered_filter(void *data,
    ssize_t bytes);",18,18,http\ngx_http_upstream.c,ngx_http_upstream_non_buffered_filter,,false,81,82,ngx_http_upstream_non_buffered_filter,,,29,"ngx_int_t ngx_http_upstream_non_buffered_filter (void*,ssize_t)"
304365,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_output_filter(void *data,
    ngx_chain_t *chain);",18,23,http\ngx_http_upstream.c,ngx_http_upstream_output_filter,,false,88,89,ngx_http_upstream_output_filter,,,30,"ngx_int_t ngx_http_upstream_output_filter (void*,ngx_chain_t*)"
304371,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,static void ngx_http_upstream_process_downstream(ngx_http_request_t *r);,13,71,http\ngx_http_upstream.c,ngx_http_upstream_process_downstream,,false,90,90,ngx_http_upstream_process_downstream,,,31,void ngx_http_upstream_process_downstream (ngx_http_request_t*)
304376,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void ngx_http_upstream_process_upstream(ngx_http_request_t *r,
    ngx_http_upstream_t *u);",13,27,http\ngx_http_upstream.c,ngx_http_upstream_process_upstream,,false,91,92,ngx_http_upstream_process_upstream,,,32,"void ngx_http_upstream_process_upstream (ngx_http_request_t*,ngx_http_upstream_t*)"
304382,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void ngx_http_upstream_process_request(ngx_http_request_t *r,
    ngx_http_upstream_t *u);",13,27,http\ngx_http_upstream.c,ngx_http_upstream_process_request,,false,93,94,ngx_http_upstream_process_request,,,33,"void ngx_http_upstream_process_request (ngx_http_request_t*,ngx_http_upstream_t*)"
304388,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void ngx_http_upstream_store(ngx_http_request_t *r,
    ngx_http_upstream_t *u);",13,27,http\ngx_http_upstream.c,ngx_http_upstream_store,,false,95,96,ngx_http_upstream_store,,,34,"void ngx_http_upstream_store (ngx_http_request_t*,ngx_http_upstream_t*)"
304394,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void ngx_http_upstream_dummy_handler(ngx_http_request_t *r,
    ngx_http_upstream_t *u);",13,27,http\ngx_http_upstream.c,ngx_http_upstream_dummy_handler,,false,97,98,ngx_http_upstream_dummy_handler,,,35,"void ngx_http_upstream_dummy_handler (ngx_http_request_t*,ngx_http_upstream_t*)"
304400,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void ngx_http_upstream_next(ngx_http_request_t *r,
    ngx_http_upstream_t *u, ngx_uint_t ft_type);",13,47,http\ngx_http_upstream.c,ngx_http_upstream_next,,false,99,100,ngx_http_upstream_next,,,36,"void ngx_http_upstream_next (ngx_http_request_t*,ngx_http_upstream_t*,ngx_uint_t)"
304407,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,static void ngx_http_upstream_cleanup(void *data);,13,49,http\ngx_http_upstream.c,ngx_http_upstream_cleanup,,false,101,101,ngx_http_upstream_cleanup,,,37,void ngx_http_upstream_cleanup (void*)
304412,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void ngx_http_upstream_finalize_request(ngx_http_request_t *r,
    ngx_http_upstream_t *u, ngx_int_t rc);",13,41,http\ngx_http_upstream.c,ngx_http_upstream_finalize_request,,false,102,103,ngx_http_upstream_finalize_request,,,38,"void ngx_http_upstream_finalize_request (ngx_http_request_t*,ngx_http_upstream_t*,ngx_int_t)"
304419,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_process_header_line(ngx_http_request_t *r,
    ngx_table_elt_t *h, ngx_uint_t offset);",18,42,http\ngx_http_upstream.c,ngx_http_upstream_process_header_line,,false,105,106,ngx_http_upstream_process_header_line,,,39,"ngx_int_t ngx_http_upstream_process_header_line (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
304426,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_process_content_length(ngx_http_request_t *r,
    ngx_table_elt_t *h, ngx_uint_t offset);",18,42,http\ngx_http_upstream.c,ngx_http_upstream_process_content_length,,false,107,108,ngx_http_upstream_process_content_length,,,40,"ngx_int_t ngx_http_upstream_process_content_length (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
304433,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_process_last_modified(ngx_http_request_t *r,
    ngx_table_elt_t *h, ngx_uint_t offset);",18,42,http\ngx_http_upstream.c,ngx_http_upstream_process_last_modified,,false,109,110,ngx_http_upstream_process_last_modified,,,41,"ngx_int_t ngx_http_upstream_process_last_modified (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
304440,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_process_set_cookie(ngx_http_request_t *r,
    ngx_table_elt_t *h, ngx_uint_t offset);",18,42,http\ngx_http_upstream.c,ngx_http_upstream_process_set_cookie,,false,111,112,ngx_http_upstream_process_set_cookie,,,42,"ngx_int_t ngx_http_upstream_process_set_cookie (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
304447,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
    ngx_http_upstream_process_cache_control(ngx_http_request_t *r,
    ngx_table_elt_t *h, ngx_uint_t offset);",5,42,http\ngx_http_upstream.c,ngx_http_upstream_process_cache_control,,false,114,115,ngx_http_upstream_process_cache_control,,,43,"ngx_int_t ngx_http_upstream_process_cache_control (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
304454,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_ignore_header_line(ngx_http_request_t *r,
    ngx_table_elt_t *h, ngx_uint_t offset);",18,42,http\ngx_http_upstream.c,ngx_http_upstream_ignore_header_line,,false,116,117,ngx_http_upstream_ignore_header_line,,,44,"ngx_int_t ngx_http_upstream_ignore_header_line (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
304461,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_process_expires(ngx_http_request_t *r,
    ngx_table_elt_t *h, ngx_uint_t offset);",18,42,http\ngx_http_upstream.c,ngx_http_upstream_process_expires,,false,118,119,ngx_http_upstream_process_expires,,,45,"ngx_int_t ngx_http_upstream_process_expires (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
304468,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_process_accel_expires(ngx_http_request_t *r,
    ngx_table_elt_t *h, ngx_uint_t offset);",18,42,http\ngx_http_upstream.c,ngx_http_upstream_process_accel_expires,,false,120,121,ngx_http_upstream_process_accel_expires,,,46,"ngx_int_t ngx_http_upstream_process_accel_expires (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
304475,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_process_limit_rate(ngx_http_request_t *r,
    ngx_table_elt_t *h, ngx_uint_t offset);",18,42,http\ngx_http_upstream.c,ngx_http_upstream_process_limit_rate,,false,122,123,ngx_http_upstream_process_limit_rate,,,47,"ngx_int_t ngx_http_upstream_process_limit_rate (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
304482,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_process_buffering(ngx_http_request_t *r,
    ngx_table_elt_t *h, ngx_uint_t offset);",18,42,http\ngx_http_upstream.c,ngx_http_upstream_process_buffering,,false,124,125,ngx_http_upstream_process_buffering,,,48,"ngx_int_t ngx_http_upstream_process_buffering (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
304489,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_process_charset(ngx_http_request_t *r,
    ngx_table_elt_t *h, ngx_uint_t offset);",18,42,http\ngx_http_upstream.c,ngx_http_upstream_process_charset,,false,126,127,ngx_http_upstream_process_charset,,,49,"ngx_int_t ngx_http_upstream_process_charset (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
304496,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_process_connection(ngx_http_request_t *r,
    ngx_table_elt_t *h, ngx_uint_t offset);",18,42,http\ngx_http_upstream.c,ngx_http_upstream_process_connection,,false,128,129,ngx_http_upstream_process_connection,,,50,"ngx_int_t ngx_http_upstream_process_connection (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
304503,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
    ngx_http_upstream_process_transfer_encoding(ngx_http_request_t *r,
    ngx_table_elt_t *h, ngx_uint_t offset);",5,42,http\ngx_http_upstream.c,ngx_http_upstream_process_transfer_encoding,,false,131,132,ngx_http_upstream_process_transfer_encoding,,,51,"ngx_int_t ngx_http_upstream_process_transfer_encoding (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
304510,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_process_vary(ngx_http_request_t *r,
    ngx_table_elt_t *h, ngx_uint_t offset);",18,42,http\ngx_http_upstream.c,ngx_http_upstream_process_vary,,false,133,134,ngx_http_upstream_process_vary,,,52,"ngx_int_t ngx_http_upstream_process_vary (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
304517,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_copy_header_line(ngx_http_request_t *r,
    ngx_table_elt_t *h, ngx_uint_t offset);",18,42,http\ngx_http_upstream.c,ngx_http_upstream_copy_header_line,,false,135,136,ngx_http_upstream_copy_header_line,,,53,"ngx_int_t ngx_http_upstream_copy_header_line (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
304524,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
    ngx_http_upstream_copy_multi_header_lines(ngx_http_request_t *r,
    ngx_table_elt_t *h, ngx_uint_t offset);",5,42,http\ngx_http_upstream.c,ngx_http_upstream_copy_multi_header_lines,,false,138,139,ngx_http_upstream_copy_multi_header_lines,,,54,"ngx_int_t ngx_http_upstream_copy_multi_header_lines (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
304531,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_copy_content_type(ngx_http_request_t *r,
    ngx_table_elt_t *h, ngx_uint_t offset);",18,42,http\ngx_http_upstream.c,ngx_http_upstream_copy_content_type,,false,140,141,ngx_http_upstream_copy_content_type,,,55,"ngx_int_t ngx_http_upstream_copy_content_type (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
304538,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_copy_last_modified(ngx_http_request_t *r,
    ngx_table_elt_t *h, ngx_uint_t offset);",18,42,http\ngx_http_upstream.c,ngx_http_upstream_copy_last_modified,,false,142,143,ngx_http_upstream_copy_last_modified,,,56,"ngx_int_t ngx_http_upstream_copy_last_modified (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
304545,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_rewrite_location(ngx_http_request_t *r,
    ngx_table_elt_t *h, ngx_uint_t offset);",18,42,http\ngx_http_upstream.c,ngx_http_upstream_rewrite_location,,false,144,145,ngx_http_upstream_rewrite_location,,,57,"ngx_int_t ngx_http_upstream_rewrite_location (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
304552,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_rewrite_refresh(ngx_http_request_t *r,
    ngx_table_elt_t *h, ngx_uint_t offset);",18,42,http\ngx_http_upstream.c,ngx_http_upstream_rewrite_refresh,,false,146,147,ngx_http_upstream_rewrite_refresh,,,58,"ngx_int_t ngx_http_upstream_rewrite_refresh (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
304559,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_rewrite_set_cookie(ngx_http_request_t *r,
    ngx_table_elt_t *h, ngx_uint_t offset);",18,42,http\ngx_http_upstream.c,ngx_http_upstream_rewrite_set_cookie,,false,148,149,ngx_http_upstream_rewrite_set_cookie,,,59,"ngx_int_t ngx_http_upstream_rewrite_set_cookie (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
304566,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_copy_allow_ranges(ngx_http_request_t *r,
    ngx_table_elt_t *h, ngx_uint_t offset);",18,42,http\ngx_http_upstream.c,ngx_http_upstream_copy_allow_ranges,,false,150,151,ngx_http_upstream_copy_allow_ranges,,,60,"ngx_int_t ngx_http_upstream_copy_allow_ranges (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
304573,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_upstream_add_variables(ngx_conf_t *cf);,18,64,http\ngx_http_upstream.c,ngx_http_upstream_add_variables,,false,158,158,ngx_http_upstream_add_variables,,,61,ngx_int_t ngx_http_upstream_add_variables (ngx_conf_t*)
304578,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_addr_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_upstream.c,ngx_http_upstream_addr_variable,,false,159,160,ngx_http_upstream_addr_variable,,,62,"ngx_int_t ngx_http_upstream_addr_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
304585,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_status_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_upstream.c,ngx_http_upstream_status_variable,,false,161,162,ngx_http_upstream_status_variable,,,63,"ngx_int_t ngx_http_upstream_status_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
304592,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_response_time_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_upstream.c,ngx_http_upstream_response_time_variable,,false,163,164,ngx_http_upstream_response_time_variable,,,64,"ngx_int_t ngx_http_upstream_response_time_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
304599,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_response_length_variable(
    ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data);",18,72,http\ngx_http_upstream.c,ngx_http_upstream_response_length_variable,,false,165,166,ngx_http_upstream_response_length_variable,,,65,"ngx_int_t ngx_http_upstream_response_length_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
304606,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_header_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_upstream.c,ngx_http_upstream_header_variable,,false,167,168,ngx_http_upstream_header_variable,,,66,"ngx_int_t ngx_http_upstream_header_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
304613,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_trailer_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_upstream.c,ngx_http_upstream_trailer_variable,,false,169,170,ngx_http_upstream_trailer_variable,,,67,"ngx_int_t ngx_http_upstream_trailer_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
304620,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_cookie_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_upstream.c,ngx_http_upstream_cookie_variable,,false,171,172,ngx_http_upstream_cookie_variable,,,68,"ngx_int_t ngx_http_upstream_cookie_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
304627,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static char *ngx_http_upstream(ngx_conf_t *cf, ngx_command_t *cmd, void *dummy);",13,79,http\ngx_http_upstream.c,ngx_http_upstream,,false,174,174,ngx_http_upstream,,,69,"char* ngx_http_upstream (ngx_conf_t*,ngx_command_t*,void*)"
304634,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static char *ngx_http_upstream_server(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\ngx_http_upstream.c,ngx_http_upstream_server,,false,175,176,ngx_http_upstream_server,,,70,"char* ngx_http_upstream_server (ngx_conf_t*,ngx_command_t*,void*)"
304641,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_upstream_set_local(ngx_http_request_t *r,
  ngx_http_upstream_t *u, ngx_http_upstream_local_t *local);",18,59,http\ngx_http_upstream.c,ngx_http_upstream_set_local,,false,178,179,ngx_http_upstream_set_local,,,71,"ngx_int_t ngx_http_upstream_set_local (ngx_http_request_t*,ngx_http_upstream_t*,ngx_http_upstream_local_t*)"
304648,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,static void *ngx_http_upstream_create_main_conf(ngx_conf_t *cf);,13,63,http\ngx_http_upstream.c,ngx_http_upstream_create_main_conf,,false,181,181,ngx_http_upstream_create_main_conf,,,72,void* ngx_http_upstream_create_main_conf (ngx_conf_t*)
304653,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static char *ngx_http_upstream_init_main_conf(ngx_conf_t *cf, void *conf);",13,73,http\ngx_http_upstream.c,ngx_http_upstream_init_main_conf,,false,182,182,ngx_http_upstream_init_main_conf,,,73,"char* ngx_http_upstream_init_main_conf (ngx_conf_t*,void*)"
305159,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_upstream_create(ngx_http_request_t *r)
{
    ngx_http_upstream_t  *u;

    u = r->upstream;

    if (u && u->cleanup) {
        r->main->count++;
        ngx_http_upstream_cleanup(r);
    }

    u = ngx_pcalloc(r->pool, sizeof(ngx_http_upstream_t));
    if (u == NULL) {
        return NGX_ERROR;
    }

    r->upstream = u;

    u->peer.log = r->connection->log;
    u->peer.log_error = NGX_ERROR_ERR;

#if (NGX_HTTP_CACHE)
    r->cache = NULL;
#endif

    u->headers_in.content_length_n = -1;
    u->headers_in.last_modified_time = -1;

    return NGX_OK;
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_create,,false,479,509,ngx_http_upstream_create,,,90,ngx_int_t ngx_http_upstream_create (ngx_http_request_t*)
305241,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"void
ngx_http_upstream_init(ngx_http_request_t *r)
{
    ngx_connection_t     *c;

    c = r->connection;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0,
                   ""http init upstream, client timer: %d"", c->read->timer_set);

#if (NGX_HTTP_V2)
    if (r->stream) {
        ngx_http_upstream_init_request(r);
        return;
    }
#endif

    if (c->read->timer_set) {
        ngx_del_timer(c->read);
    }

    if (ngx_event_flags & NGX_USE_CLEAR_EVENT) {

        if (!c->write->active) {
            if (ngx_add_event(c->write, NGX_WRITE_EVENT, NGX_CLEAR_EVENT)
                == NGX_ERROR)
            {
                ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
                return;
            }
        }
    }

    ngx_http_upstream_init_request(r);
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_init,,false,512,546,ngx_http_upstream_init,,,91,void ngx_http_upstream_init (ngx_http_request_t*)
305304,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void
ngx_http_upstream_init_request(ngx_http_request_t *r)
{
    ngx_str_t                      *host;
    ngx_uint_t                      i;
    ngx_resolver_ctx_t             *ctx, temp;
    ngx_http_cleanup_t             *cln;
    ngx_http_upstream_t            *u;
    ngx_http_core_loc_conf_t       *clcf;
    ngx_http_upstream_srv_conf_t   *uscf, **uscfp;
    ngx_http_upstream_main_conf_t  *umcf;

    if (r->aio) {
        return;
    }

    u = r->upstream;

#if (NGX_HTTP_CACHE)

    if (u->conf->cache) {
        ngx_int_t  rc;

        rc = ngx_http_upstream_cache(r, u);

        if (rc == NGX_BUSY) {
            r->write_event_handler = ngx_http_upstream_init_request;
            return;
        }

        r->write_event_handler = ngx_http_request_empty_handler;

        if (rc == NGX_ERROR) {
            ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
            return;
        }

        if (rc == NGX_OK) {
            rc = ngx_http_upstream_cache_send...",1,1,http\ngx_http_upstream.c,ngx_http_upstream_init_request,,false,549,807,ngx_http_upstream_init_request,,,92,void ngx_http_upstream_init_request (ngx_http_request_t*)
305954,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void
ngx_http_upstream_resolve_handler(ngx_resolver_ctx_t *ctx)
{
    ngx_uint_t                     run_posted;
    ngx_connection_t              *c;
    ngx_http_request_t            *r;
    ngx_http_upstream_t           *u;
    ngx_http_upstream_resolved_t  *ur;

    run_posted = ctx->async;

    r = ctx->data;
    c = r->connection;

    u = r->upstream;
    ur = u->resolved;

    ngx_http_set_log_request(c->log, r);

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, c->log, 0,
                   ""http upstream resolve: \""%V?%V\"""", &r->uri, &r->args);

    if (ctx->state) {
        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                      ""%V could not be resolved (%i: %s)"",
                      &ctx->name, ctx->state,
                      ngx_resolver_strerror(ctx->state));

        ngx_http_upstream_finalize_request(r, u, NGX_HTTP_BAD_GATEWAY);
        goto failed;
    }

    ur->naddrs = ctx->naddrs;
    ur->addrs = ctx->addrs;

#if (NGX_DEBUG)
    {
    u_char   ...",1,1,http\ngx_http_upstream.c,ngx_http_upstream_resolve_handler,,false,1179,1256,ngx_http_upstream_resolve_handler,,,93,void ngx_http_upstream_resolve_handler (ngx_resolver_ctx_t*)
306118,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void
ngx_http_upstream_handler(ngx_event_t *ev)
{
    ngx_connection_t     *c;
    ngx_http_request_t   *r;
    ngx_http_upstream_t  *u;

    c = ev->data;
    r = c->data;

    u = r->upstream;
    c = r->connection;

    ngx_http_set_log_request(c->log, r);

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, c->log, 0,
                   ""http upstream request: \""%V?%V\"""", &r->uri, &r->args);

    if (ev->delayed && ev->timedout) {
        ev->delayed = 0;
        ev->timedout = 0;
    }

    if (ev->write) {
        u->write_event_handler(r, u);

    } else {
        u->read_event_handler(r, u);
    }

    ngx_http_run_posted_requests(c);
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_handler,,false,1259,1290,ngx_http_upstream_handler,,,94,void ngx_http_upstream_handler (ngx_event_t*)
306206,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void
ngx_http_upstream_rd_check_broken_connection(ngx_http_request_t *r)
{
    ngx_http_upstream_check_broken_connection(r, r->connection->read);
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_rd_check_broken_connection,,false,1293,1297,ngx_http_upstream_rd_check_broken_connection,,,95,void ngx_http_upstream_rd_check_broken_connection (ngx_http_request_t*)
306218,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void
ngx_http_upstream_wr_check_broken_connection(ngx_http_request_t *r)
{
    ngx_http_upstream_check_broken_connection(r, r->connection->write);
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_wr_check_broken_connection,,false,1300,1304,ngx_http_upstream_wr_check_broken_connection,,,96,void ngx_http_upstream_wr_check_broken_connection (ngx_http_request_t*)
306230,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void
ngx_http_upstream_check_broken_connection(ngx_http_request_t *r,
    ngx_event_t *ev)
{
    int                  n;
    char                 buf[1];
    ngx_err_t            err;
    ngx_int_t            event;
    ngx_connection_t     *c;
    ngx_http_upstream_t  *u;

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, ev->log, 0,
                   ""http upstream check client, write event:%d, \""%V\"""",
                   ev->write, &r->uri);

    c = r->connection;
    u = r->upstream;

    if (c->error) {
        if ((ngx_event_flags & NGX_USE_LEVEL_EVENT) && ev->active) {

            event = ev->write ? NGX_WRITE_EVENT : NGX_READ_EVENT;

            if (ngx_del_event(ev, event, 0) != NGX_OK) {
                ngx_http_upstream_finalize_request(r, u,
                                               NGX_HTTP_INTERNAL_SERVER_ERROR);
                return;
            }
        }

        if (!u->cacheable) {
            ngx_http_upstream_finalize_request(r, u,
                       ...",1,1,http\ngx_http_upstream.c,ngx_http_upstream_check_broken_connection,,false,1307,1498,ngx_http_upstream_check_broken_connection,,,97,"void ngx_http_upstream_check_broken_connection (ngx_http_request_t*,ngx_event_t*)"
306458,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void
ngx_http_upstream_connect(ngx_http_request_t *r, ngx_http_upstream_t *u)
{
    ngx_int_t          rc;
    ngx_connection_t  *c;

    r->connection->log->action = ""connecting to upstream"";

    if (u->state && u->state->response_time == (ngx_msec_t) -1) {
        u->state->response_time = ngx_current_msec - u->start_time;
    }

    u->state = ngx_array_push(r->upstream_states);
    if (u->state == NULL) {
        ngx_http_upstream_finalize_request(r, u,
                                           NGX_HTTP_INTERNAL_SERVER_ERROR);
        return;
    }

    ngx_memzero(u->state, sizeof(ngx_http_upstream_state_t));

    u->start_time = ngx_current_msec;

    u->state->response_time = (ngx_msec_t) -1;
    u->state->connect_time = (ngx_msec_t) -1;
    u->state->header_time = (ngx_msec_t) -1;

    rc = ngx_event_connect_peer(&u->peer);

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http upstream connect: %i"", rc);

    if (rc == NGX_ERROR) {
...",1,1,http\ngx_http_upstream.c,ngx_http_upstream_connect,,false,1501,1650,ngx_http_upstream_connect,,,98,"void ngx_http_upstream_connect (ngx_http_request_t*,ngx_http_upstream_t*)"
306967,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_reinit(ngx_http_request_t *r, ngx_http_upstream_t *u)
{
    off_t         file_pos;
    ngx_chain_t  *cl;

    if (u->reinit_request(r) != NGX_OK) {
        return NGX_ERROR;
    }

    u->keepalive = 0;
    u->upgrade = 0;

    ngx_memzero(&u->headers_in, sizeof(ngx_http_upstream_headers_in_t));
    u->headers_in.content_length_n = -1;
    u->headers_in.last_modified_time = -1;

    if (ngx_list_init(&u->headers_in.headers, r->pool, 8,
                      sizeof(ngx_table_elt_t))
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    if (ngx_list_init(&u->headers_in.trailers, r->pool, 2,
                      sizeof(ngx_table_elt_t))
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    /* reinit the request chain */

    file_pos = 0;

    for (cl = u->request_bufs; cl; cl = cl->next) {
        cl->buf->pos = cl->buf->start;

        /* there is at most one file */

        if (cl->buf->in_file) {
            cl->buf->file_pos = ...",1,1,http\ngx_http_upstream.c,ngx_http_upstream_reinit,,false,1910,1992,ngx_http_upstream_reinit,,,99,"ngx_int_t ngx_http_upstream_reinit (ngx_http_request_t*,ngx_http_upstream_t*)"
307247,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void
ngx_http_upstream_send_request(ngx_http_request_t *r, ngx_http_upstream_t *u,
    ngx_uint_t do_write)
{
    ngx_int_t          rc;
    ngx_connection_t  *c;

    c = u->peer.connection;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,
                   ""http upstream send request"");

    if (u->state->connect_time == (ngx_msec_t) -1) {
        u->state->connect_time = ngx_current_msec - u->start_time;
    }

    if (!u->request_sent && ngx_http_upstream_test_connect(c) != NGX_OK) {
        ngx_http_upstream_next(r, u, NGX_HTTP_UPSTREAM_FT_ERROR);
        return;
    }

    c->log->action = ""sending request to upstream"";

    rc = ngx_http_upstream_send_request_body(r, u, do_write);

    if (rc == NGX_ERROR) {
        ngx_http_upstream_next(r, u, NGX_HTTP_UPSTREAM_FT_ERROR);
        return;
    }

    if (rc >= NGX_HTTP_SPECIAL_RESPONSE) {
        ngx_http_upstream_finalize_request(r, u, rc);
        return;
    }

    if (rc == NGX_AGAIN) {
        if (!c->write->rea...",1,1,http\ngx_http_upstream.c,ngx_http_upstream_send_request,,false,1995,2101,ngx_http_upstream_send_request,,,100,"void ngx_http_upstream_send_request (ngx_http_request_t*,ngx_http_upstream_t*,ngx_uint_t)"
307534,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_send_request_body(ngx_http_request_t *r,
    ngx_http_upstream_t *u, ngx_uint_t do_write)
{
    ngx_int_t                  rc;
    ngx_chain_t               *out, *cl, *ln;
    ngx_connection_t          *c;
    ngx_http_core_loc_conf_t  *clcf;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http upstream send request body"");

    if (!r->request_body_no_buffering) {

        /* buffered request body */

        if (!u->request_sent) {
            u->request_sent = 1;
            out = u->request_bufs;

        } else {
            out = NULL;
        }

        rc = ngx_output_chain(&u->output, out);

        if (rc == NGX_AGAIN) {
            u->request_body_blocked = 1;

        } else {
            u->request_body_blocked = 0;
        }

        return rc;
    }

    if (!u->request_sent) {
        u->request_sent = 1;
        out = u->request_bufs;

        if (r->request_body->bufs) {
            for (cl = ou...",1,1,http\ngx_http_upstream.c,ngx_http_upstream_send_request_body,,false,2104,2221,ngx_http_upstream_send_request_body,,,101,"ngx_int_t ngx_http_upstream_send_request_body (ngx_http_request_t*,ngx_http_upstream_t*,ngx_uint_t)"
307835,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void
ngx_http_upstream_send_request_handler(ngx_http_request_t *r,
    ngx_http_upstream_t *u)
{
    ngx_connection_t  *c;

    c = u->peer.connection;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http upstream send request handler"");

    if (c->write->timedout) {
        ngx_http_upstream_next(r, u, NGX_HTTP_UPSTREAM_FT_TIMEOUT);
        return;
    }

#if (NGX_HTTP_SSL)

    if (u->ssl && c->ssl == NULL) {
        ngx_http_upstream_ssl_init_connection(r, u, c);
        return;
    }

#endif

    if (u->header_sent && !u->conf->preserve_output) {
        u->write_event_handler = ngx_http_upstream_dummy_handler;

        (void) ngx_handle_write_event(c->write, 0);

        return;
    }

    ngx_http_upstream_send_request(r, u, 1);
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_send_request_handler,,false,2224,2258,ngx_http_upstream_send_request_handler,,,102,"void ngx_http_upstream_send_request_handler (ngx_http_request_t*,ngx_http_upstream_t*)"
307899,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void
ngx_http_upstream_read_request_handler(ngx_http_request_t *r)
{
    ngx_connection_t     *c;
    ngx_http_upstream_t  *u;

    c = r->connection;
    u = r->upstream;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http upstream read request handler"");

    if (c->read->timedout) {
        c->timedout = 1;
        ngx_http_upstream_finalize_request(r, u, NGX_HTTP_REQUEST_TIME_OUT);
        return;
    }

    ngx_http_upstream_send_request(r, u, 0);
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_read_request_handler,,false,2261,2280,ngx_http_upstream_read_request_handler,,,103,void ngx_http_upstream_read_request_handler (ngx_http_request_t*)
307946,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void
ngx_http_upstream_process_header(ngx_http_request_t *r, ngx_http_upstream_t *u)
{
    ssize_t            n;
    ngx_int_t          rc;
    ngx_connection_t  *c;

    c = u->peer.connection;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,
                   ""http upstream process header"");

    c->log->action = ""reading response header from upstream"";

    if (c->read->timedout) {
        ngx_http_upstream_next(r, u, NGX_HTTP_UPSTREAM_FT_TIMEOUT);
        return;
    }

    if (!u->request_sent && ngx_http_upstream_test_connect(c) != NGX_OK) {
        ngx_http_upstream_next(r, u, NGX_HTTP_UPSTREAM_FT_ERROR);
        return;
    }

    if (u->buffer.start == NULL) {
        u->buffer.start = ngx_palloc(r->pool, u->conf->buffer_size);
        if (u->buffer.start == NULL) {
            ngx_http_upstream_finalize_request(r, u,
                                               NGX_HTTP_INTERNAL_SERVER_ERROR);
            return;
        }

        u->buffer.pos = u->buffer.sta...",1,1,http\ngx_http_upstream.c,ngx_http_upstream_process_header,,false,2283,2437,ngx_http_upstream_process_header,,,104,"void ngx_http_upstream_process_header (ngx_http_request_t*,ngx_http_upstream_t*)"
308335,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_test_next(ngx_http_request_t *r, ngx_http_upstream_t *u)
{
    ngx_msec_t                 timeout;
    ngx_uint_t                 status, mask;
    ngx_http_upstream_next_t  *un;

    status = u->headers_in.status_n;

    for (un = ngx_http_upstream_next_errors; un->status; un++) {

        if (status != un->status) {
            continue;
        }

        timeout = u->conf->next_upstream_timeout;

        if (u->request_sent
            && (r->method & (NGX_HTTP_POST|NGX_HTTP_LOCK|NGX_HTTP_PATCH)))
        {
            mask = un->mask | NGX_HTTP_UPSTREAM_FT_NON_IDEMPOTENT;

        } else {
            mask = un->mask;
        }

        if (u->peer.tries > 1
            && ((u->conf->next_upstream & mask) == mask)
            && !(u->request_sent && r->request_body_no_buffering)
            && !(timeout && ngx_current_msec - u->peer.start_time >= timeout))
        {
            ngx_http_upstream_next(r, u, un->mask);
            return NGX_OK;...",1,1,http\ngx_http_upstream.c,ngx_http_upstream_test_next,,false,2440,2576,ngx_http_upstream_test_next,,,105,"ngx_int_t ngx_http_upstream_test_next (ngx_http_request_t*,ngx_http_upstream_t*)"
308459,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_intercept_errors(ngx_http_request_t *r,
    ngx_http_upstream_t *u)
{
    ngx_int_t                  status;
    ngx_uint_t                 i;
    ngx_table_elt_t           *h;
    ngx_http_err_page_t       *err_page;
    ngx_http_core_loc_conf_t  *clcf;

    status = u->headers_in.status_n;

    if (status == NGX_HTTP_NOT_FOUND && u->conf->intercept_404) {
        ngx_http_upstream_finalize_request(r, u, NGX_HTTP_NOT_FOUND);
        return NGX_OK;
    }

    if (!u->conf->intercept_errors) {
        return NGX_DECLINED;
    }

    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    if (clcf->error_pages == NULL) {
        return NGX_DECLINED;
    }

    err_page = clcf->error_pages->elts;
    for (i = 0; i < clcf->error_pages->nelts; i++) {

        if (err_page[i].status == status) {

            if (status == NGX_HTTP_UNAUTHORIZED
                && u->headers_in.www_authenticate)
            {
                h = ngx_list_push(&r...",1,1,http\ngx_http_upstream.c,ngx_http_upstream_intercept_errors,,false,2579,2659,ngx_http_upstream_intercept_errors,,,106,"ngx_int_t ngx_http_upstream_intercept_errors (ngx_http_request_t*,ngx_http_upstream_t*)"
308604,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_test_connect(ngx_connection_t *c)
{
    int        err;
    socklen_t  len;

#if (NGX_HAVE_KQUEUE)

    if (ngx_event_flags & NGX_USE_KQUEUE_EVENT)  {
        if (c->write->pending_eof || c->read->pending_eof) {
            if (c->write->pending_eof) {
                err = c->write->kq_errno;

            } else {
                err = c->read->kq_errno;
            }

            c->log->action = ""connecting to upstream"";
            (void) ngx_connection_error(c, err,
                                    ""kevent() reported that connect() failed"");
            return NGX_ERROR;
        }

    } else
#endif
    {
        err = 0;
        len = sizeof(int);

        /*
         * BSDs and Linux return 0 and set a pending error in err
         * Solaris returns -1 and sets errno
         */

        if (getsockopt(c->fd, SOL_SOCKET, SO_ERROR, (void *) &err, &len)
            == -1)
        {
            err = ngx_socket_errno;
        }

        if (...",1,1,http\ngx_http_upstream.c,ngx_http_upstream_test_connect,,false,2662,2710,ngx_http_upstream_test_connect,,,107,ngx_int_t ngx_http_upstream_test_connect (ngx_connection_t*)
308659,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_process_headers(ngx_http_request_t *r, ngx_http_upstream_t *u)
{
    ngx_str_t                       uri, args;
    ngx_uint_t                      i, flags;
    ngx_list_part_t                *part;
    ngx_table_elt_t                *h;
    ngx_http_upstream_header_t     *hh;
    ngx_http_upstream_main_conf_t  *umcf;

    umcf = ngx_http_get_module_main_conf(r, ngx_http_upstream_module);

    if (u->headers_in.x_accel_redirect
        && !(u->conf->ignore_headers & NGX_HTTP_UPSTREAM_IGN_XA_REDIRECT))
    {
        ngx_http_upstream_finalize_request(r, u, NGX_DECLINED);

        part = &u->headers_in.headers.part;
        h = part->elts;

        for (i = 0; /* void */; i++) {

            if (i >= part->nelts) {
                if (part->next == NULL) {
                    break;
                }

                part = part->next;
                h = part->elts;
                i = 0;
            }

            hh = ngx_hash_find(&umcf->headers...",1,1,http\ngx_http_upstream.c,ngx_http_upstream_process_headers,,false,2713,2853,ngx_http_upstream_process_headers,,,108,"ngx_int_t ngx_http_upstream_process_headers (ngx_http_request_t*,ngx_http_upstream_t*)"
309143,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_process_trailers(ngx_http_request_t *r,
    ngx_http_upstream_t *u)
{
    ngx_uint_t        i;
    ngx_list_part_t  *part;
    ngx_table_elt_t  *h, *ho;

    if (!u->conf->pass_trailers) {
        return NGX_OK;
    }

    part = &u->headers_in.trailers.part;
    h = part->elts;

    for (i = 0; /* void */; i++) {

        if (i >= part->nelts) {
            if (part->next == NULL) {
                break;
            }

            part = part->next;
            h = part->elts;
            i = 0;
        }

        if (ngx_hash_find(&u->conf->hide_headers_hash, h[i].hash,
                          h[i].lowcase_key, h[i].key.len))
        {
            continue;
        }

        ho = ngx_list_push(&r->headers_out.trailers);
        if (ho == NULL) {
            return NGX_ERROR;
        }

        *ho = h[i];
    }

    return NGX_OK;
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_process_trailers,,false,2856,2898,ngx_http_upstream_process_trailers,,,109,"ngx_int_t ngx_http_upstream_process_trailers (ngx_http_request_t*,ngx_http_upstream_t*)"
309265,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void
ngx_http_upstream_send_response(ngx_http_request_t *r, ngx_http_upstream_t *u)
{
    ssize_t                    n;
    ngx_int_t                  rc;
    ngx_event_pipe_t          *p;
    ngx_connection_t          *c;
    ngx_http_core_loc_conf_t  *clcf;

    rc = ngx_http_send_header(r);

    if (rc == NGX_ERROR || rc > NGX_OK || r->post_action) {
        ngx_http_upstream_finalize_request(r, u, rc);
        return;
    }

    u->header_sent = 1;

    if (u->upgrade) {

#if (NGX_HTTP_CACHE)

        if (r->cache) {
            ngx_http_file_cache_free(r->cache, u->pipe->temp_file);
        }

#endif

        ngx_http_upstream_upgrade(r, u);
        return;
    }

    c = r->connection;

    if (r->header_only) {

        if (!u->buffering) {
            ngx_http_upstream_finalize_request(r, u, rc);
            return;
        }

        if (!u->cacheable && !u->store) {
            ngx_http_upstream_finalize_request(r, u, rc);
            return;
        }

        u->p...",1,1,http\ngx_http_upstream.c,ngx_http_upstream_send_response,,false,2901,3243,ngx_http_upstream_send_response,,,110,"void ngx_http_upstream_send_response (ngx_http_request_t*,ngx_http_upstream_t*)"
310042,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void
ngx_http_upstream_upgrade(ngx_http_request_t *r, ngx_http_upstream_t *u)
{
    ngx_connection_t          *c;
    ngx_http_core_loc_conf_t  *clcf;

    c = r->connection;
    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    /* TODO: prevent upgrade if not requested or not possible */

    if (r != r->main) {
        ngx_log_error(NGX_LOG_ERR, c->log, 0,
                      ""connection upgrade in subrequest"");
        ngx_http_upstream_finalize_request(r, u, NGX_ERROR);
        return;
    }

    r->keepalive = 0;
    c->log->action = ""proxying upgraded connection"";

    u->read_event_handler = ngx_http_upstream_upgraded_read_upstream;
    u->write_event_handler = ngx_http_upstream_upgraded_write_upstream;
    r->read_event_handler = ngx_http_upstream_upgraded_read_downstream;
    r->write_event_handler = ngx_http_upstream_upgraded_write_downstream;

    if (clcf->tcp_nodelay) {

        if (ngx_tcp_nodelay(c) != NGX_OK) {
            ngx_http_upstream_...",1,1,http\ngx_http_upstream.c,ngx_http_upstream_upgrade,,false,3246,3299,ngx_http_upstream_upgrade,,,111,"void ngx_http_upstream_upgrade (ngx_http_request_t*,ngx_http_upstream_t*)"
310192,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void
ngx_http_upstream_upgraded_read_downstream(ngx_http_request_t *r)
{
    ngx_http_upstream_process_upgraded(r, 0, 0);
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_upgraded_read_downstream,,false,3302,3306,ngx_http_upstream_upgraded_read_downstream,,,112,void ngx_http_upstream_upgraded_read_downstream (ngx_http_request_t*)
310201,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void
ngx_http_upstream_upgraded_write_downstream(ngx_http_request_t *r)
{
    ngx_http_upstream_process_upgraded(r, 1, 1);
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_upgraded_write_downstream,,false,3309,3313,ngx_http_upstream_upgraded_write_downstream,,,113,void ngx_http_upstream_upgraded_write_downstream (ngx_http_request_t*)
310210,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void
ngx_http_upstream_upgraded_read_upstream(ngx_http_request_t *r,
    ngx_http_upstream_t *u)
{
    ngx_http_upstream_process_upgraded(r, 1, 0);
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_upgraded_read_upstream,,false,3316,3321,ngx_http_upstream_upgraded_read_upstream,,,114,"void ngx_http_upstream_upgraded_read_upstream (ngx_http_request_t*,ngx_http_upstream_t*)"
310220,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void
ngx_http_upstream_upgraded_write_upstream(ngx_http_request_t *r,
    ngx_http_upstream_t *u)
{
    ngx_http_upstream_process_upgraded(r, 0, 1);
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_upgraded_write_upstream,,false,3324,3329,ngx_http_upstream_upgraded_write_upstream,,,115,"void ngx_http_upstream_upgraded_write_upstream (ngx_http_request_t*,ngx_http_upstream_t*)"
310230,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void
ngx_http_upstream_process_upgraded(ngx_http_request_t *r,
    ngx_uint_t from_upstream, ngx_uint_t do_write)
{
    size_t                     size;
    ssize_t                    n;
    ngx_buf_t                 *b;
    ngx_uint_t                 flags;
    ngx_connection_t          *c, *downstream, *upstream, *dst, *src;
    ngx_http_upstream_t       *u;
    ngx_http_core_loc_conf_t  *clcf;

    c = r->connection;
    u = r->upstream;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0,
                   ""http upstream process upgraded, fu:%ui"", from_upstream);

    downstream = c;
    upstream = u->peer.connection;

    if (downstream->write->timedout) {
        c->timedout = 1;
        ngx_connection_error(c, NGX_ETIMEDOUT, ""client timed out"");
        ngx_http_upstream_finalize_request(r, u, NGX_HTTP_REQUEST_TIME_OUT);
        return;
    }

    if (upstream->read->timedout || upstream->write->timedout) {
        ngx_connection_error(c, NGX_ETIMEDOUT, ""upstream timed ...",1,1,http\ngx_http_upstream.c,ngx_http_upstream_process_upgraded,,false,3332,3522,ngx_http_upstream_process_upgraded,,,116,"void ngx_http_upstream_process_upgraded (ngx_http_request_t*,ngx_uint_t,ngx_uint_t)"
310879,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void
ngx_http_upstream_process_non_buffered_downstream(ngx_http_request_t *r)
{
    ngx_event_t          *wev;
    ngx_connection_t     *c;
    ngx_http_upstream_t  *u;

    c = r->connection;
    u = r->upstream;
    wev = c->write;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,
                   ""http upstream process non buffered downstream"");

    c->log->action = ""sending to client"";

    if (wev->timedout) {
        c->timedout = 1;
        ngx_connection_error(c, NGX_ETIMEDOUT, ""client timed out"");
        ngx_http_upstream_finalize_request(r, u, NGX_HTTP_REQUEST_TIME_OUT);
        return;
    }

    ngx_http_upstream_process_non_buffered_request(r, 1);
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_process_non_buffered_downstream,,false,3525,3549,ngx_http_upstream_process_non_buffered_downstream,,,117,void ngx_http_upstream_process_non_buffered_downstream (ngx_http_request_t*)
310938,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void
ngx_http_upstream_process_non_buffered_upstream(ngx_http_request_t *r,
    ngx_http_upstream_t *u)
{
    ngx_connection_t  *c;

    c = u->peer.connection;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,
                   ""http upstream process non buffered upstream"");

    c->log->action = ""reading upstream"";

    if (c->read->timedout) {
        ngx_connection_error(c, NGX_ETIMEDOUT, ""upstream timed out"");
        ngx_http_upstream_finalize_request(r, u, NGX_HTTP_GATEWAY_TIME_OUT);
        return;
    }

    ngx_http_upstream_process_non_buffered_request(r, 0);
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_process_non_buffered_upstream,,false,3552,3572,ngx_http_upstream_process_non_buffered_upstream,,,118,"void ngx_http_upstream_process_non_buffered_upstream (ngx_http_request_t*,ngx_http_upstream_t*)"
310985,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void
ngx_http_upstream_process_non_buffered_request(ngx_http_request_t *r,
    ngx_uint_t do_write)
{
    size_t                     size;
    ssize_t                    n;
    ngx_buf_t                 *b;
    ngx_int_t                  rc;
    ngx_uint_t                 flags;
    ngx_connection_t          *downstream, *upstream;
    ngx_http_upstream_t       *u;
    ngx_http_core_loc_conf_t  *clcf;

    u = r->upstream;
    downstream = r->connection;
    upstream = u->peer.connection;

    b = &u->buffer;

    do_write = do_write || u->length == 0;

    for ( ;; ) {

        if (do_write) {

            if (u->out_bufs || u->busy_bufs || downstream->buffered) {
                rc = ngx_http_output_filter(r, u->out_bufs);

                if (rc == NGX_ERROR) {
                    ngx_http_upstream_finalize_request(r, u, NGX_ERROR);
                    return;
                }

                ngx_chain_update_chains(r->pool, &u->free_bufs, &u->busy_bufs,
                ...",1,1,http\ngx_http_upstream.c,ngx_http_upstream_process_non_buffered_request,,false,3575,3705,ngx_http_upstream_process_non_buffered_request,,,119,"void ngx_http_upstream_process_non_buffered_request (ngx_http_request_t*,ngx_uint_t)"
311375,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_non_buffered_filter_init(void *data)
{
    return NGX_OK;
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_non_buffered_filter_init,,false,3708,3712,ngx_http_upstream_non_buffered_filter_init,,,120,ngx_int_t ngx_http_upstream_non_buffered_filter_init (void*)
311382,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_non_buffered_filter(void *data, ssize_t bytes)
{
    ngx_http_request_t  *r = data;

    ngx_buf_t            *b;
    ngx_chain_t          *cl, **ll;
    ngx_http_upstream_t  *u;

    u = r->upstream;

    for (cl = u->out_bufs, ll = &u->out_bufs; cl; cl = cl->next) {
        ll = &cl->next;
    }

    cl = ngx_chain_get_free_buf(r->pool, &u->free_bufs);
    if (cl == NULL) {
        return NGX_ERROR;
    }

    *ll = cl;

    cl->buf->flush = 1;
    cl->buf->memory = 1;

    b = &u->buffer;

    cl->buf->pos = b->last;
    b->last += bytes;
    cl->buf->last = b->last;
    cl->buf->tag = u->output.tag;

    if (u->length == -1) {
        return NGX_OK;
    }

    u->length -= bytes;

    return NGX_OK;
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_non_buffered_filter,,false,3715,3754,ngx_http_upstream_non_buffered_filter,,,121,"ngx_int_t ngx_http_upstream_non_buffered_filter (void*,ssize_t)"
311520,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_output_filter(void *data, ngx_chain_t *chain)
{
    ngx_int_t            rc;
    ngx_event_pipe_t    *p;
    ngx_http_request_t  *r;

    r = data;
    p = r->upstream->pipe;

    rc = ngx_http_output_filter(r, chain);

    p->aio = r->aio;

    return rc;
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_output_filter,,false,3840,3855,ngx_http_upstream_output_filter,,,122,"ngx_int_t ngx_http_upstream_output_filter (void*,ngx_chain_t*)"
311553,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void
ngx_http_upstream_process_downstream(ngx_http_request_t *r)
{
    ngx_event_t          *wev;
    ngx_connection_t     *c;
    ngx_event_pipe_t     *p;
    ngx_http_upstream_t  *u;

    c = r->connection;
    u = r->upstream;
    p = u->pipe;
    wev = c->write;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,
                   ""http upstream process downstream"");

    c->log->action = ""sending to client"";

#if (NGX_THREADS)
    p->aio = r->aio;
#endif

    if (wev->timedout) {

        p->downstream_error = 1;
        c->timedout = 1;
        ngx_connection_error(c, NGX_ETIMEDOUT, ""client timed out"");

    } else {

        if (wev->delayed) {

            ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,
                           ""http downstream delayed"");

            if (ngx_handle_write_event(wev, p->send_lowat) != NGX_OK) {
                ngx_http_upstream_finalize_request(r, u, NGX_ERROR);
            }

            return;
        }

        if (ngx_event_pipe(p...",1,1,http\ngx_http_upstream.c,ngx_http_upstream_process_downstream,,false,3858,3907,ngx_http_upstream_process_downstream,,,123,void ngx_http_upstream_process_downstream (ngx_http_request_t*)
311658,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void
ngx_http_upstream_process_upstream(ngx_http_request_t *r,
    ngx_http_upstream_t *u)
{
    ngx_event_t       *rev;
    ngx_event_pipe_t  *p;
    ngx_connection_t  *c;

    c = u->peer.connection;
    p = u->pipe;
    rev = c->read;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,
                   ""http upstream process upstream"");

    c->log->action = ""reading upstream"";

    if (rev->timedout) {

        p->upstream_error = 1;
        ngx_connection_error(c, NGX_ETIMEDOUT, ""upstream timed out"");

    } else {

        if (rev->delayed) {

            ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,
                           ""http upstream delayed"");

            if (ngx_handle_read_event(rev, 0) != NGX_OK) {
                ngx_http_upstream_finalize_request(r, u, NGX_ERROR);
            }

            return;
        }

        if (ngx_event_pipe(p, 0) == NGX_ABORT) {
            ngx_http_upstream_finalize_request(r, u, NGX_ERROR);
            return;
        }
   ...",1,1,http\ngx_http_upstream.c,ngx_http_upstream_process_upstream,,false,3910,3953,ngx_http_upstream_process_upstream,,,124,"void ngx_http_upstream_process_upstream (ngx_http_request_t*,ngx_http_upstream_t*)"
311753,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void
ngx_http_upstream_process_request(ngx_http_request_t *r,
    ngx_http_upstream_t *u)
{
    ngx_temp_file_t   *tf;
    ngx_event_pipe_t  *p;

    p = u->pipe;

#if (NGX_THREADS)

    if (p->writing && !p->aio) {

        /*
         * make sure to call ngx_event_pipe()
         * if there is an incomplete aio write
         */

        if (ngx_event_pipe(p, 1) == NGX_ABORT) {
            ngx_http_upstream_finalize_request(r, u, NGX_ERROR);
            return;
        }
    }

    if (p->writing) {
        return;
    }

#endif

    if (u->peer.connection) {

        if (u->store) {

            if (p->upstream_eof || p->upstream_done) {

                tf = p->temp_file;

                if (u->headers_in.status_n == NGX_HTTP_OK
                    && (p->upstream_done || p->length == -1)
                    && (u->headers_in.content_length_n == -1
                        || u->headers_in.content_length_n == tf->offset))
                {
                    ngx_http_ups...",1,1,http\ngx_http_upstream.c,ngx_http_upstream_process_request,,false,3956,4062,ngx_http_upstream_process_request,,,125,"void ngx_http_upstream_process_request (ngx_http_request_t*,ngx_http_upstream_t*)"
311934,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void
ngx_http_upstream_store(ngx_http_request_t *r, ngx_http_upstream_t *u)
{
    size_t                  root;
    time_t                  lm;
    ngx_str_t               path;
    ngx_temp_file_t        *tf;
    ngx_ext_rename_file_t   ext;

    tf = u->pipe->temp_file;

    if (tf->file.fd == NGX_INVALID_FILE) {

        /* create file for empty 200 response */

        tf = ngx_pcalloc(r->pool, sizeof(ngx_temp_file_t));
        if (tf == NULL) {
            return;
        }

        tf->file.fd = NGX_INVALID_FILE;
        tf->file.log = r->connection->log;
        tf->path = u->conf->temp_path;
        tf->pool = r->pool;
        tf->persistent = 1;

        if (ngx_create_temp_file(&tf->file, tf->path, tf->pool,
                                 tf->persistent, tf->clean, tf->access)
            != NGX_OK)
        {
            return;
        }

        u->pipe->temp_file = tf;
    }

    ext.access = u->conf->store_access;
    ext.path_access = u->conf->store_access;
 ...",1,1,http\ngx_http_upstream.c,ngx_http_upstream_store,,false,4065,4143,ngx_http_upstream_store,,,126,"void ngx_http_upstream_store (ngx_http_request_t*,ngx_http_upstream_t*)"
312224,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void
ngx_http_upstream_dummy_handler(ngx_http_request_t *r, ngx_http_upstream_t *u)
{
    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http upstream dummy handler"");
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_dummy_handler,,false,4146,4151,ngx_http_upstream_dummy_handler,,,127,"void ngx_http_upstream_dummy_handler (ngx_http_request_t*,ngx_http_upstream_t*)"
312239,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void
ngx_http_upstream_next(ngx_http_request_t *r, ngx_http_upstream_t *u,
    ngx_uint_t ft_type)
{
    ngx_msec_t  timeout;
    ngx_uint_t  status, state;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http next upstream, %xi"", ft_type);

    if (u->peer.sockaddr) {

        if (u->peer.connection) {
            u->state->bytes_sent = u->peer.connection->sent;
        }

        if (ft_type == NGX_HTTP_UPSTREAM_FT_HTTP_403
            || ft_type == NGX_HTTP_UPSTREAM_FT_HTTP_404)
        {
            state = NGX_PEER_NEXT;

        } else {
            state = NGX_PEER_FAILED;
        }

        u->peer.free(&u->peer, u->peer.data, state);
        u->peer.sockaddr = NULL;
    }

    if (ft_type == NGX_HTTP_UPSTREAM_FT_TIMEOUT) {
        ngx_log_error(NGX_LOG_ERR, r->connection->log, NGX_ETIMEDOUT,
                      ""upstream timed out"");
    }

    if (u->peer.cached && ft_type == NGX_HTTP_UPSTREAM_FT_ERROR) {
        /* TODO: inform ...",1,1,http\ngx_http_upstream.c,ngx_http_upstream_next,,false,4154,4307,ngx_http_upstream_next,,,128,"void ngx_http_upstream_next (ngx_http_request_t*,ngx_http_upstream_t*,ngx_uint_t)"
312546,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void
ngx_http_upstream_cleanup(void *data)
{
    ngx_http_request_t *r = data;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""cleanup http upstream request: \""%V\"""", &r->uri);

    ngx_http_upstream_finalize_request(r, r->upstream, NGX_DONE);
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_cleanup,,false,4310,4319,ngx_http_upstream_cleanup,,,129,void ngx_http_upstream_cleanup (void*)
312574,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void
ngx_http_upstream_finalize_request(ngx_http_request_t *r,
    ngx_http_upstream_t *u, ngx_int_t rc)
{
    ngx_uint_t  flush;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""finalize http upstream request: %i"", rc);

    if (u->cleanup == NULL) {
        /* the request was already finalized */
        ngx_http_finalize_request(r, NGX_DONE);
        return;
    }

    *u->cleanup = NULL;
    u->cleanup = NULL;

    if (u->resolved && u->resolved->ctx) {
        ngx_resolve_name_done(u->resolved->ctx);
        u->resolved->ctx = NULL;
    }

    if (u->state && u->state->response_time == (ngx_msec_t) -1) {
        u->state->response_time = ngx_current_msec - u->start_time;

        if (u->pipe && u->pipe->read_length) {
            u->state->bytes_received += u->pipe->read_length
                                        - u->pipe->preread_size;
            u->state->response_length = u->pipe->read_length;
        }

        if (u->peer.conn...",1,1,http\ngx_http_upstream.c,ngx_http_upstream_finalize_request,,false,4322,4485,ngx_http_upstream_finalize_request,,,130,"void ngx_http_upstream_finalize_request (ngx_http_request_t*,ngx_http_upstream_t*,ngx_int_t)"
313001,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_process_header_line(ngx_http_request_t *r, ngx_table_elt_t *h,
    ngx_uint_t offset)
{
    ngx_table_elt_t  **ph;

    ph = (ngx_table_elt_t **) ((char *) &r->upstream->headers_in + offset);

    if (*ph == NULL) {
        *ph = h;
    }

    return NGX_OK;
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_process_header_line,,false,4488,4501,ngx_http_upstream_process_header_line,,,131,"ngx_int_t ngx_http_upstream_process_header_line (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
313035,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_ignore_header_line(ngx_http_request_t *r, ngx_table_elt_t *h,
    ngx_uint_t offset)
{
    return NGX_OK;
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_ignore_header_line,,false,4504,4509,ngx_http_upstream_ignore_header_line,,,132,"ngx_int_t ngx_http_upstream_ignore_header_line (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
313044,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_process_content_length(ngx_http_request_t *r,
    ngx_table_elt_t *h, ngx_uint_t offset)
{
    ngx_http_upstream_t  *u;

    u = r->upstream;

    u->headers_in.content_length = h;
    u->headers_in.content_length_n = ngx_atoof(h->value.data, h->value.len);

    return NGX_OK;
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_process_content_length,,false,4512,4524,ngx_http_upstream_process_content_length,,,133,"ngx_int_t ngx_http_upstream_process_content_length (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
313083,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_process_last_modified(ngx_http_request_t *r,
    ngx_table_elt_t *h, ngx_uint_t offset)
{
    ngx_http_upstream_t  *u;

    u = r->upstream;

    u->headers_in.last_modified = h;
    u->headers_in.last_modified_time = ngx_parse_http_time(h->value.data,
                                                           h->value.len);

    return NGX_OK;
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_process_last_modified,,false,4527,4540,ngx_http_upstream_process_last_modified,,,134,"ngx_int_t ngx_http_upstream_process_last_modified (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
313122,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_process_set_cookie(ngx_http_request_t *r, ngx_table_elt_t *h,
    ngx_uint_t offset)
{
    ngx_array_t           *pa;
    ngx_table_elt_t      **ph;
    ngx_http_upstream_t   *u;

    u = r->upstream;
    pa = &u->headers_in.cookies;

    if (pa->elts == NULL) {
        if (ngx_array_init(pa, r->pool, 1, sizeof(ngx_table_elt_t *)) != NGX_OK)
        {
            return NGX_ERROR;
        }
    }

    ph = ngx_array_push(pa);
    if (ph == NULL) {
        return NGX_ERROR;
    }

    *ph = h;

#if (NGX_HTTP_CACHE)
    if (!(u->conf->ignore_headers & NGX_HTTP_UPSTREAM_IGN_SET_COOKIE)) {
        u->cacheable = 0;
    }
#endif

    return NGX_OK;
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_process_set_cookie,,false,4543,4575,ngx_http_upstream_process_set_cookie,,,135,"ngx_int_t ngx_http_upstream_process_set_cookie (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
313183,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_process_cache_control(ngx_http_request_t *r,
    ngx_table_elt_t *h, ngx_uint_t offset)
{
    ngx_array_t          *pa;
    ngx_table_elt_t     **ph;
    ngx_http_upstream_t  *u;

    u = r->upstream;
    pa = &u->headers_in.cache_control;

    if (pa->elts == NULL) {
        if (ngx_array_init(pa, r->pool, 2, sizeof(ngx_table_elt_t *)) != NGX_OK)
        {
            return NGX_ERROR;
        }
    }

    ph = ngx_array_push(pa);
    if (ph == NULL) {
        return NGX_ERROR;
    }

    *ph = h;

#if (NGX_HTTP_CACHE)
    {
    u_char     *p, *start, *last;
    ngx_int_t   n;

    if (u->conf->ignore_headers & NGX_HTTP_UPSTREAM_IGN_CACHE_CONTROL) {
        return NGX_OK;
    }

    if (r->cache == NULL) {
        return NGX_OK;
    }

    if (r->cache->valid_sec != 0 && u->headers_in.x_accel_expires != NULL) {
        return NGX_OK;
    }

    start = h->value.data;
    last = start + h->value.len;

    if (ngx_strlcasestrn(start, last, (u_char *...",1,1,http\ngx_http_upstream.c,ngx_http_upstream_process_cache_control,,false,4578,4713,ngx_http_upstream_process_cache_control,,,136,"ngx_int_t ngx_http_upstream_process_cache_control (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
313244,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_process_expires(ngx_http_request_t *r, ngx_table_elt_t *h,
    ngx_uint_t offset)
{
    ngx_http_upstream_t  *u;

    u = r->upstream;
    u->headers_in.expires = h;

#if (NGX_HTTP_CACHE)
    {
    time_t  expires;

    if (u->conf->ignore_headers & NGX_HTTP_UPSTREAM_IGN_EXPIRES) {
        return NGX_OK;
    }

    if (r->cache == NULL) {
        return NGX_OK;
    }

    if (r->cache->valid_sec != 0) {
        return NGX_OK;
    }

    expires = ngx_parse_http_time(h->value.data, h->value.len);

    if (expires == NGX_ERROR || expires < ngx_time()) {
        u->cacheable = 0;
        return NGX_OK;
    }

    r->cache->valid_sec = expires;
    }
#endif

    return NGX_OK;
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_process_expires,,false,4716,4753,ngx_http_upstream_process_expires,,,137,"ngx_int_t ngx_http_upstream_process_expires (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
313266,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_process_accel_expires(ngx_http_request_t *r,
    ngx_table_elt_t *h, ngx_uint_t offset)
{
    ngx_http_upstream_t  *u;

    u = r->upstream;
    u->headers_in.x_accel_expires = h;

#if (NGX_HTTP_CACHE)
    {
    u_char     *p;
    size_t      len;
    ngx_int_t   n;

    if (u->conf->ignore_headers & NGX_HTTP_UPSTREAM_IGN_XA_EXPIRES) {
        return NGX_OK;
    }

    if (r->cache == NULL) {
        return NGX_OK;
    }

    len = h->value.len;
    p = h->value.data;

    if (p[0] != '@') {
        n = ngx_atoi(p, len);

        switch (n) {
        case 0:
            u->cacheable = 0;
            /* fall through */

        case NGX_ERROR:
            return NGX_OK;

        default:
            r->cache->valid_sec = ngx_time() + n;
            return NGX_OK;
        }
    }

    p++;
    len--;

    n = ngx_atoi(p, len);

    if (n != NGX_ERROR) {
        r->cache->valid_sec = n;
    }
    }
#endif

    return NGX_OK;
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_process_accel_expires,,false,4756,4811,ngx_http_upstream_process_accel_expires,,,138,"ngx_int_t ngx_http_upstream_process_accel_expires (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
313288,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_process_limit_rate(ngx_http_request_t *r, ngx_table_elt_t *h,
    ngx_uint_t offset)
{
    ngx_int_t             n;
    ngx_http_upstream_t  *u;

    u = r->upstream;
    u->headers_in.x_accel_limit_rate = h;

    if (u->conf->ignore_headers & NGX_HTTP_UPSTREAM_IGN_XA_LIMIT_RATE) {
        return NGX_OK;
    }

    n = ngx_atoi(h->value.data, h->value.len);

    if (n != NGX_ERROR) {
        r->limit_rate = (size_t) n;
        r->limit_rate_set = 1;
    }

    return NGX_OK;
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_process_limit_rate,,false,4814,4836,ngx_http_upstream_process_limit_rate,,,139,"ngx_int_t ngx_http_upstream_process_limit_rate (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
313352,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_process_buffering(ngx_http_request_t *r, ngx_table_elt_t *h,
    ngx_uint_t offset)
{
    u_char                c0, c1, c2;
    ngx_http_upstream_t  *u;

    u = r->upstream;

    if (u->conf->ignore_headers & NGX_HTTP_UPSTREAM_IGN_XA_BUFFERING) {
        return NGX_OK;
    }

    if (u->conf->change_buffering) {

        if (h->value.len == 2) {
            c0 = ngx_tolower(h->value.data[0]);
            c1 = ngx_tolower(h->value.data[1]);

            if (c0 == 'n' && c1 == 'o') {
                u->buffering = 0;
            }

        } else if (h->value.len == 3) {
            c0 = ngx_tolower(h->value.data[0]);
            c1 = ngx_tolower(h->value.data[1]);
            c2 = ngx_tolower(h->value.data[2]);

            if (c0 == 'y' && c1 == 'e' && c2 == 's') {
                u->buffering = 1;
            }
        }
    }

    return NGX_OK;
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_process_buffering,,false,4839,4874,ngx_http_upstream_process_buffering,,,140,"ngx_int_t ngx_http_upstream_process_buffering (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
313490,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_process_charset(ngx_http_request_t *r, ngx_table_elt_t *h,
    ngx_uint_t offset)
{
    if (r->upstream->conf->ignore_headers & NGX_HTTP_UPSTREAM_IGN_XA_CHARSET) {
        return NGX_OK;
    }

    r->headers_out.override_charset = &h->value;

    return NGX_OK;
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_process_charset,,false,4877,4888,ngx_http_upstream_process_charset,,,141,"ngx_int_t ngx_http_upstream_process_charset (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
313522,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_process_connection(ngx_http_request_t *r, ngx_table_elt_t *h,
    ngx_uint_t offset)
{
    r->upstream->headers_in.connection = h;

    if (ngx_strlcasestrn(h->value.data, h->value.data + h->value.len,
                         (u_char *) ""close"", 5 - 1)
        != NULL)
    {
        r->upstream->headers_in.connection_close = 1;
    }

    return NGX_OK;
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_process_connection,,false,4891,4905,ngx_http_upstream_process_connection,,,142,"ngx_int_t ngx_http_upstream_process_connection (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
313576,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_process_transfer_encoding(ngx_http_request_t *r,
    ngx_table_elt_t *h, ngx_uint_t offset)
{
    r->upstream->headers_in.transfer_encoding = h;

    if (ngx_strlcasestrn(h->value.data, h->value.data + h->value.len,
                         (u_char *) ""chunked"", 7 - 1)
        != NULL)
    {
        r->upstream->headers_in.chunked = 1;
    }

    return NGX_OK;
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_process_transfer_encoding,,false,4908,4922,ngx_http_upstream_process_transfer_encoding,,,143,"ngx_int_t ngx_http_upstream_process_transfer_encoding (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
313630,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_process_vary(ngx_http_request_t *r,
    ngx_table_elt_t *h, ngx_uint_t offset)
{
    ngx_http_upstream_t  *u;

    u = r->upstream;
    u->headers_in.vary = h;

#if (NGX_HTTP_CACHE)

    if (u->conf->ignore_headers & NGX_HTTP_UPSTREAM_IGN_VARY) {
        return NGX_OK;
    }

    if (r->cache == NULL) {
        return NGX_OK;
    }

    if (h->value.len > NGX_HTTP_CACHE_VARY_LEN
        || (h->value.len == 1 && h->value.data[0] == '*'))
    {
        u->cacheable = 0;
    }

    r->cache->vary = h->value;

#endif

    return NGX_OK;
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_process_vary,,false,4925,4955,ngx_http_upstream_process_vary,,,144,"ngx_int_t ngx_http_upstream_process_vary (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
313652,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_copy_header_line(ngx_http_request_t *r, ngx_table_elt_t *h,
    ngx_uint_t offset)
{
    ngx_table_elt_t  *ho, **ph;

    ho = ngx_list_push(&r->headers_out.headers);
    if (ho == NULL) {
        return NGX_ERROR;
    }

    *ho = *h;

    if (offset) {
        ph = (ngx_table_elt_t **) ((char *) &r->headers_out + offset);
        *ph = ho;
    }

    return NGX_OK;
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_copy_header_line,,false,4958,4977,ngx_http_upstream_copy_header_line,,,145,"ngx_int_t ngx_http_upstream_copy_header_line (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
313703,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_copy_multi_header_lines(ngx_http_request_t *r,
    ngx_table_elt_t *h, ngx_uint_t offset)
{
    ngx_array_t      *pa;
    ngx_table_elt_t  *ho, **ph;

    pa = (ngx_array_t *) ((char *) &r->headers_out + offset);

    if (pa->elts == NULL) {
        if (ngx_array_init(pa, r->pool, 2, sizeof(ngx_table_elt_t *)) != NGX_OK)
        {
            return NGX_ERROR;
        }
    }

    ho = ngx_list_push(&r->headers_out.headers);
    if (ho == NULL) {
        return NGX_ERROR;
    }

    *ho = *h;

    ph = ngx_array_push(pa);
    if (ph == NULL) {
        return NGX_ERROR;
    }

    *ph = ho;

    return NGX_OK;
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_copy_multi_header_lines,,false,4980,5011,ngx_http_upstream_copy_multi_header_lines,,,146,"ngx_int_t ngx_http_upstream_copy_multi_header_lines (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
313784,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_copy_content_type(ngx_http_request_t *r, ngx_table_elt_t *h,
    ngx_uint_t offset)
{
    u_char  *p, *last;

    r->headers_out.content_type_len = h->value.len;
    r->headers_out.content_type = h->value;
    r->headers_out.content_type_lowcase = NULL;

    for (p = h->value.data; *p; p++) {

        if (*p != ';') {
            continue;
        }

        last = p;

        while (*++p == ' ') { /* void */ }

        if (*p == '\0') {
            return NGX_OK;
        }

        if (ngx_strncasecmp(p, (u_char *) ""charset="", 8) != 0) {
            continue;
        }

        p += 8;

        r->headers_out.content_type_len = last - h->value.data;

        if (*p == '""') {
            p++;
        }

        last = h->value.data + h->value.len;

        if (*(last - 1) == '""') {
            last--;
        }

        r->headers_out.charset.len = last - p;
        r->headers_out.charset.data = p;

        return NGX_OK;
    }

    return NGX_OK;
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_copy_content_type,,false,5014,5063,ngx_http_upstream_copy_content_type,,,147,"ngx_int_t ngx_http_upstream_copy_content_type (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
313941,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_copy_last_modified(ngx_http_request_t *r, ngx_table_elt_t *h,
    ngx_uint_t offset)
{
    ngx_table_elt_t  *ho;

    ho = ngx_list_push(&r->headers_out.headers);
    if (ho == NULL) {
        return NGX_ERROR;
    }

    *ho = *h;

    r->headers_out.last_modified = ho;
    r->headers_out.last_modified_time =
                                    r->upstream->headers_in.last_modified_time;

    return NGX_OK;
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_copy_last_modified,,false,5066,5084,ngx_http_upstream_copy_last_modified,,,148,"ngx_int_t ngx_http_upstream_copy_last_modified (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
313992,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_rewrite_location(ngx_http_request_t *r, ngx_table_elt_t *h,
    ngx_uint_t offset)
{
    ngx_int_t         rc;
    ngx_table_elt_t  *ho;

    ho = ngx_list_push(&r->headers_out.headers);
    if (ho == NULL) {
        return NGX_ERROR;
    }

    *ho = *h;

    if (r->upstream->rewrite_redirect) {
        rc = r->upstream->rewrite_redirect(r, ho, 0);

        if (rc == NGX_DECLINED) {
            return NGX_OK;
        }

        if (rc == NGX_OK) {
            r->headers_out.location = ho;

            ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                           ""rewritten location: \""%V\"""", &ho->value);
        }

        return rc;
    }

    if (ho->value.data[0] != '/') {
        r->headers_out.location = ho;
    }

    /*
     * we do not set r->headers_out.location here to avoid handling
     * relative redirects in ngx_http_header_filter()
     */

    return NGX_OK;
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_rewrite_location,,false,5087,5128,ngx_http_upstream_rewrite_location,,,149,"ngx_int_t ngx_http_upstream_rewrite_location (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
314094,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_rewrite_refresh(ngx_http_request_t *r, ngx_table_elt_t *h,
    ngx_uint_t offset)
{
    u_char           *p;
    ngx_int_t         rc;
    ngx_table_elt_t  *ho;

    ho = ngx_list_push(&r->headers_out.headers);
    if (ho == NULL) {
        return NGX_ERROR;
    }

    *ho = *h;

    if (r->upstream->rewrite_redirect) {

        p = ngx_strcasestrn(ho->value.data, ""url="", 4 - 1);

        if (p) {
            rc = r->upstream->rewrite_redirect(r, ho, p + 4 - ho->value.data);

        } else {
            return NGX_OK;
        }

        if (rc == NGX_DECLINED) {
            return NGX_OK;
        }

        if (rc == NGX_OK) {
            r->headers_out.refresh = ho;

            ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                           ""rewritten refresh: \""%V\"""", &ho->value);
        }

        return rc;
    }

    r->headers_out.refresh = ho;

    return NGX_OK;
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_rewrite_refresh,,false,5131,5174,ngx_http_upstream_rewrite_refresh,,,150,"ngx_int_t ngx_http_upstream_rewrite_refresh (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
314213,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_rewrite_set_cookie(ngx_http_request_t *r, ngx_table_elt_t *h,
    ngx_uint_t offset)
{
    ngx_int_t         rc;
    ngx_table_elt_t  *ho;

    ho = ngx_list_push(&r->headers_out.headers);
    if (ho == NULL) {
        return NGX_ERROR;
    }

    *ho = *h;

    if (r->upstream->rewrite_cookie) {
        rc = r->upstream->rewrite_cookie(r, ho);

        if (rc == NGX_DECLINED) {
            return NGX_OK;
        }

#if (NGX_DEBUG)
        if (rc == NGX_OK) {
            ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                           ""rewritten cookie: \""%V\"""", &ho->value);
        }
#endif

        return rc;
    }

    return NGX_OK;
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_rewrite_set_cookie,,false,5177,5209,ngx_http_upstream_rewrite_set_cookie,,,151,"ngx_int_t ngx_http_upstream_rewrite_set_cookie (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
314271,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_copy_allow_ranges(ngx_http_request_t *r,
    ngx_table_elt_t *h, ngx_uint_t offset)
{
    ngx_table_elt_t  *ho;

    if (r->upstream->conf->force_ranges) {
        return NGX_OK;
    }

#if (NGX_HTTP_CACHE)

    if (r->cached) {
        r->allow_ranges = 1;
        return NGX_OK;
    }

    if (r->upstream->cacheable) {
        r->allow_ranges = 1;
        r->single_range = 1;
        return NGX_OK;
    }

#endif

    ho = ngx_list_push(&r->headers_out.headers);
    if (ho == NULL) {
        return NGX_ERROR;
    }

    *ho = *h;

    r->headers_out.accept_ranges = ho;

    return NGX_OK;
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_copy_allow_ranges,,false,5212,5247,ngx_http_upstream_copy_allow_ranges,,,152,"ngx_int_t ngx_http_upstream_copy_allow_ranges (ngx_http_request_t*,ngx_table_elt_t*,ngx_uint_t)"
314320,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_add_variables(ngx_conf_t *cf)
{
    ngx_http_variable_t  *var, *v;

    for (v = ngx_http_upstream_vars; v->name.len; v++) {
        var = ngx_http_add_variable(cf, &v->name, v->flags);
        if (var == NULL) {
            return NGX_ERROR;
        }

        var->get_handler = v->get_handler;
        var->data = v->data;
    }

    return NGX_OK;
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_add_variables,,false,5273,5289,ngx_http_upstream_add_variables,,,153,ngx_int_t ngx_http_upstream_add_variables (ngx_conf_t*)
314374,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_addr_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    u_char                     *p;
    size_t                      len;
    ngx_uint_t                  i;
    ngx_http_upstream_state_t  *state;

    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;

    if (r->upstream_states == NULL || r->upstream_states->nelts == 0) {
        v->not_found = 1;
        return NGX_OK;
    }

    len = 0;
    state = r->upstream_states->elts;

    for (i = 0; i < r->upstream_states->nelts; i++) {
        if (state[i].peer) {
            len += state[i].peer->len + 2;

        } else {
            len += 3;
        }
    }

    p = ngx_pnalloc(r->pool, len);
    if (p == NULL) {
        return NGX_ERROR;
    }

    v->data = p;

    i = 0;

    for ( ;; ) {
        if (state[i].peer) {
            p = ngx_cpymem(p, state[i].peer->data, state[i].peer->len);
        }

        if (++i == r->upstream_states->nelts) {
 ...",1,1,http\ngx_http_upstream.c,ngx_http_upstream_addr_variable,,false,5292,5360,ngx_http_upstream_addr_variable,,,154,"ngx_int_t ngx_http_upstream_addr_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
314588,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_status_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    u_char                     *p;
    size_t                      len;
    ngx_uint_t                  i;
    ngx_http_upstream_state_t  *state;

    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;

    if (r->upstream_states == NULL || r->upstream_states->nelts == 0) {
        v->not_found = 1;
        return NGX_OK;
    }

    len = r->upstream_states->nelts * (3 + 2);

    p = ngx_pnalloc(r->pool, len);
    if (p == NULL) {
        return NGX_ERROR;
    }

    v->data = p;

    i = 0;
    state = r->upstream_states->elts;

    for ( ;; ) {
        if (state[i].status) {
            p = ngx_sprintf(p, ""%ui"", state[i].status);

        } else {
            *p++ = '-';
        }

        if (++i == r->upstream_states->nelts) {
            break;
        }

        if (state[i].peer) {
            *p++ = ',';
            *p++ = ' ';

        } el...",1,1,http\ngx_http_upstream.c,ngx_http_upstream_status_variable,,false,5363,5425,ngx_http_upstream_status_variable,,,155,"ngx_int_t ngx_http_upstream_status_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
314771,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_response_time_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    u_char                     *p;
    size_t                      len;
    ngx_uint_t                  i;
    ngx_msec_int_t              ms;
    ngx_http_upstream_state_t  *state;

    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;

    if (r->upstream_states == NULL || r->upstream_states->nelts == 0) {
        v->not_found = 1;
        return NGX_OK;
    }

    len = r->upstream_states->nelts * (NGX_TIME_T_LEN + 4 + 2);

    p = ngx_pnalloc(r->pool, len);
    if (p == NULL) {
        return NGX_ERROR;
    }

    v->data = p;

    i = 0;
    state = r->upstream_states->elts;

    for ( ;; ) {

        if (data == 1) {
            ms = state[i].header_time;

        } else if (data == 2) {
            ms = state[i].connect_time;

        } else {
            ms = state[i].response_time;
        }

        if (ms != -1) {
            ms =...",1,1,http\ngx_http_upstream.c,ngx_http_upstream_response_time_variable,,false,5428,5503,ngx_http_upstream_response_time_variable,,,156,"ngx_int_t ngx_http_upstream_response_time_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
314999,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_response_length_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    u_char                     *p;
    size_t                      len;
    ngx_uint_t                  i;
    ngx_http_upstream_state_t  *state;

    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;

    if (r->upstream_states == NULL || r->upstream_states->nelts == 0) {
        v->not_found = 1;
        return NGX_OK;
    }

    len = r->upstream_states->nelts * (NGX_OFF_T_LEN + 2);

    p = ngx_pnalloc(r->pool, len);
    if (p == NULL) {
        return NGX_ERROR;
    }

    v->data = p;

    i = 0;
    state = r->upstream_states->elts;

    for ( ;; ) {

        if (data == 1) {
            p = ngx_sprintf(p, ""%O"", state[i].bytes_received);

        } else if (data == 2) {
            p = ngx_sprintf(p, ""%O"", state[i].bytes_sent);

        } else {
            p = ngx_sprintf(p, ""%O"", state[i].response_length);
        }

        if (+...",1,1,http\ngx_http_upstream.c,ngx_http_upstream_response_length_variable,,false,5506,5572,ngx_http_upstream_response_length_variable,,,157,"ngx_int_t ngx_http_upstream_response_length_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
315202,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_header_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    if (r->upstream == NULL) {
        v->not_found = 1;
        return NGX_OK;
    }

    return ngx_http_variable_unknown_header(v, (ngx_str_t *) data,
                                         &r->upstream->headers_in.headers.part,
                                         sizeof(""upstream_http_"") - 1);
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_header_variable,,false,5575,5587,ngx_http_upstream_header_variable,,,158,"ngx_int_t ngx_http_upstream_header_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
315243,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_trailer_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    if (r->upstream == NULL) {
        v->not_found = 1;
        return NGX_OK;
    }

    return ngx_http_variable_unknown_header(v, (ngx_str_t *) data,
                                        &r->upstream->headers_in.trailers.part,
                                        sizeof(""upstream_trailer_"") - 1);
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_trailer_variable,,false,5590,5602,ngx_http_upstream_trailer_variable,,,159,"ngx_int_t ngx_http_upstream_trailer_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
315284,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_cookie_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    ngx_str_t  *name = (ngx_str_t *) data;

    ngx_str_t   cookie, s;

    if (r->upstream == NULL) {
        v->not_found = 1;
        return NGX_OK;
    }

    s.len = name->len - (sizeof(""upstream_cookie_"") - 1);
    s.data = name->data + sizeof(""upstream_cookie_"") - 1;

    if (ngx_http_parse_set_cookie_lines(&r->upstream->headers_in.cookies,
                                        &s, &cookie)
        == NGX_DECLINED)
    {
        v->not_found = 1;
        return NGX_OK;
    }

    v->len = cookie.len;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = cookie.data;

    return NGX_OK;
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_cookie_variable,,false,5605,5636,ngx_http_upstream_cookie_variable,,,160,"ngx_int_t ngx_http_upstream_cookie_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
315392,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static char *
ngx_http_upstream(ngx_conf_t *cf, ngx_command_t *cmd, void *dummy)
{
    char                          *rv;
    void                          *mconf;
    ngx_str_t                     *value;
    ngx_url_t                      u;
    ngx_uint_t                     m;
    ngx_conf_t                     pcf;
    ngx_http_module_t             *module;
    ngx_http_conf_ctx_t           *ctx, *http_ctx;
    ngx_http_upstream_srv_conf_t  *uscf;

    ngx_memzero(&u, sizeof(ngx_url_t));

    value = cf->args->elts;
    u.host = value[1];
    u.no_resolve = 1;
    u.no_port = 1;

    uscf = ngx_http_upstream_add(cf, &u, NGX_HTTP_UPSTREAM_CREATE
                                         |NGX_HTTP_UPSTREAM_WEIGHT
                                         |NGX_HTTP_UPSTREAM_MAX_CONNS
                                         |NGX_HTTP_UPSTREAM_MAX_FAILS
                                         |NGX_HTTP_UPSTREAM_FAIL_TIMEOUT
                                         |NGX_HTTP_UPSTREAM...",1,1,http\ngx_http_upstream.c,ngx_http_upstream,,false,5719,5832,ngx_http_upstream,,,161,"char* ngx_http_upstream (ngx_conf_t*,ngx_command_t*,void*)"
315725,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static char *
ngx_http_upstream_server(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_upstream_srv_conf_t  *uscf = conf;

    time_t                       fail_timeout;
    ngx_str_t                   *value, s;
    ngx_url_t                    u;
    ngx_int_t                    weight, max_conns, max_fails;
    ngx_uint_t                   i;
    ngx_http_upstream_server_t  *us;

    us = ngx_array_push(uscf->servers);
    if (us == NULL) {
        return NGX_CONF_ERROR;
    }

    ngx_memzero(us, sizeof(ngx_http_upstream_server_t));

    value = cf->args->elts;

    weight = 1;
    max_conns = 0;
    max_fails = 1;
    fail_timeout = 10;

    for (i = 2; i < cf->args->nelts; i++) {

        if (ngx_strncmp(value[i].data, ""weight="", 7) == 0) {

            if (!(uscf->flags & NGX_HTTP_UPSTREAM_WEIGHT)) {
                goto not_supported;
            }

            weight = ngx_atoi(&value[i].data[7], value[i].len - 7);

            if (weight == NGX_ERROR || weig...",1,1,http\ngx_http_upstream.c,ngx_http_upstream_server,,false,5835,5989,ngx_http_upstream_server,,,162,"char* ngx_http_upstream_server (ngx_conf_t*,ngx_command_t*,void*)"
316163,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"ngx_http_upstream_srv_conf_t *
ngx_http_upstream_add(ngx_conf_t *cf, ngx_url_t *u, ngx_uint_t flags)
{
    ngx_uint_t                      i;
    ngx_http_upstream_server_t     *us;
    ngx_http_upstream_srv_conf_t   *uscf, **uscfp;
    ngx_http_upstream_main_conf_t  *umcf;

    if (!(flags & NGX_HTTP_UPSTREAM_CREATE)) {

        if (ngx_parse_url(cf->pool, u) != NGX_OK) {
            if (u->err) {
                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                                   ""%s in upstream \""%V\"""", u->err, &u->url);
            }

            return NULL;
        }
    }

    umcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_upstream_module);

    uscfp = umcf->upstreams.elts;

    for (i = 0; i < umcf->upstreams.nelts; i++) {

        if (uscfp[i]->host.len != u->host.len
            || ngx_strncasecmp(uscfp[i]->host.data, u->host.data, u->host.len)
               != 0)
        {
            continue;
        }

        if ((flags & NGX_HTTP_UPSTREAM_CREATE)
   ...",1,1,http\ngx_http_upstream.c,ngx_http_upstream_add,,false,5992,6100,ngx_http_upstream_add,,,163,"ngx_http_upstream_srv_conf_t ngx_http_upstream_add (ngx_conf_t*,ngx_url_t*,ngx_uint_t)"
316559,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"char *
ngx_http_upstream_bind_set_slot(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf)
{
    char  *p = conf;

    ngx_int_t                           rc;
    ngx_str_t                          *value;
    ngx_http_complex_value_t            cv;
    ngx_http_upstream_local_t         **plocal, *local;
    ngx_http_compile_complex_value_t    ccv;

    plocal = (ngx_http_upstream_local_t **) (p + cmd->offset);

    if (*plocal != NGX_CONF_UNSET_PTR) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    if (cf->args->nelts == 2 && ngx_strcmp(value[1].data, ""off"") == 0) {
        *plocal = NULL;
        return NGX_CONF_OK;
    }

    ngx_memzero(&ccv, sizeof(ngx_http_compile_complex_value_t));

    ccv.cf = cf;
    ccv.value = &value[1];
    ccv.complex_value = &cv;

    if (ngx_http_compile_complex_value(&ccv) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    local = ngx_pcalloc(cf->pool, sizeof(ngx_http_upstream_local_t));
    if (local == NULL) {
        re...",1,1,http\ngx_http_upstream.c,ngx_http_upstream_bind_set_slot,,false,6103,6200,ngx_http_upstream_bind_set_slot,,,164,"char* ngx_http_upstream_bind_set_slot (ngx_conf_t*,ngx_command_t*,void*)"
316816,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_upstream_set_local(ngx_http_request_t *r, ngx_http_upstream_t *u,
    ngx_http_upstream_local_t *local)
{
    ngx_int_t    rc;
    ngx_str_t    val;
    ngx_addr_t  *addr;

    if (local == NULL) {
        u->peer.local = NULL;
        return NGX_OK;
    }

#if (NGX_HAVE_TRANSPARENT_PROXY)
    u->peer.transparent = local->transparent;
#endif

    if (local->value == NULL) {
        u->peer.local = local->addr;
        return NGX_OK;
    }

    if (ngx_http_complex_value(r, local->value, &val) != NGX_OK) {
        return NGX_ERROR;
    }

    if (val.len == 0) {
        return NGX_OK;
    }

    addr = ngx_palloc(r->pool, sizeof(ngx_addr_t));
    if (addr == NULL) {
        return NGX_ERROR;
    }

    rc = ngx_parse_addr_port(r->pool, addr, val.data, val.len);
    if (rc == NGX_ERROR) {
        return NGX_ERROR;
    }

    if (rc != NGX_OK) {
        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                      ""invalid local address \""%V\"""", &val...",1,1,http\ngx_http_upstream.c,ngx_http_upstream_set_local,,false,6203,6253,ngx_http_upstream_set_local,,,165,"ngx_int_t ngx_http_upstream_set_local (ngx_http_request_t*,ngx_http_upstream_t*,ngx_http_upstream_local_t*)"
316947,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"char *
ngx_http_upstream_param_set_slot(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf)
{
    char  *p = conf;

    ngx_str_t                   *value;
    ngx_array_t                **a;
    ngx_http_upstream_param_t   *param;

    a = (ngx_array_t **) (p + cmd->offset);

    if (*a == NULL) {
        *a = ngx_array_create(cf->pool, 4, sizeof(ngx_http_upstream_param_t));
        if (*a == NULL) {
            return NGX_CONF_ERROR;
        }
    }

    param = ngx_array_push(*a);
    if (param == NULL) {
        return NGX_CONF_ERROR;
    }

    value = cf->args->elts;

    param->key = value[1];
    param->value = value[2];
    param->skip_empty = 0;

    if (cf->args->nelts == 4) {
        if (ngx_strcmp(value[3].data, ""if_not_empty"") != 0) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               ""invalid parameter \""%V\"""", &value[3]);
            return NGX_CONF_ERROR;
        }

        param->skip_empty = 1;
    }

    return NGX_CONF_OK;
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_param_set_slot,,false,6256,6297,ngx_http_upstream_param_set_slot,,,166,"char* ngx_http_upstream_param_set_slot (ngx_conf_t*,ngx_command_t*,void*)"
317070,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_upstream_hide_headers_hash(ngx_conf_t *cf,
    ngx_http_upstream_conf_t *conf, ngx_http_upstream_conf_t *prev,
    ngx_str_t *default_hide_headers, ngx_hash_init_t *hash)
{
    ngx_str_t       *h;
    ngx_uint_t       i, j;
    ngx_array_t      hide_headers;
    ngx_hash_key_t  *hk;

    if (conf->hide_headers == NGX_CONF_UNSET_PTR
        && conf->pass_headers == NGX_CONF_UNSET_PTR)
    {
        conf->hide_headers = prev->hide_headers;
        conf->pass_headers = prev->pass_headers;

        conf->hide_headers_hash = prev->hide_headers_hash;

        if (conf->hide_headers_hash.buckets) {
            return NGX_OK;
        }

    } else {
        if (conf->hide_headers == NGX_CONF_UNSET_PTR) {
            conf->hide_headers = prev->hide_headers;
        }

        if (conf->pass_headers == NGX_CONF_UNSET_PTR) {
            conf->pass_headers = prev->pass_headers;
        }
    }

    if (ngx_array_init(&hide_headers, cf->temp_pool, 4, sizeof(ngx_hash_key_t))
  ...",1,1,http\ngx_http_upstream.c,ngx_http_upstream_hide_headers_hash,,false,6300,6420,ngx_http_upstream_hide_headers_hash,,,167,"ngx_int_t ngx_http_upstream_hide_headers_hash (ngx_conf_t*,ngx_http_upstream_conf_t*,ngx_http_upstream_conf_t*,ngx_str_t*,ngx_hash_init_t*)"
317486,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static void *
ngx_http_upstream_create_main_conf(ngx_conf_t *cf)
{
    ngx_http_upstream_main_conf_t  *umcf;

    umcf = ngx_pcalloc(cf->pool, sizeof(ngx_http_upstream_main_conf_t));
    if (umcf == NULL) {
        return NULL;
    }

    if (ngx_array_init(&umcf->upstreams, cf->pool, 4,
                       sizeof(ngx_http_upstream_srv_conf_t *))
        != NGX_OK)
    {
        return NULL;
    }

    return umcf;
}",1,1,http\ngx_http_upstream.c,ngx_http_upstream_create_main_conf,,false,6423,6441,ngx_http_upstream_create_main_conf,,,168,void* ngx_http_upstream_create_main_conf (ngx_conf_t*)
317526,METHOD,http\ngx_http_upstream.c:<global>,TYPE_DECL,"static char *
ngx_http_upstream_init_main_conf(ngx_conf_t *cf, void *conf)
{
    ngx_http_upstream_main_conf_t  *umcf = conf;

    ngx_uint_t                      i;
    ngx_array_t                     headers_in;
    ngx_hash_key_t                 *hk;
    ngx_hash_init_t                 hash;
    ngx_http_upstream_init_pt       init;
    ngx_http_upstream_header_t     *header;
    ngx_http_upstream_srv_conf_t  **uscfp;

    uscfp = umcf->upstreams.elts;

    for (i = 0; i < umcf->upstreams.nelts; i++) {

        init = uscfp[i]->peer.init_upstream ? uscfp[i]->peer.init_upstream:
                                            ngx_http_upstream_init_round_robin;

        if (init(cf, uscfp[i]) != NGX_OK) {
            return NGX_CONF_ERROR;
        }
    }


    /* upstream_headers_in_hash */

    if (ngx_array_init(&headers_in, cf->temp_pool, 32, sizeof(ngx_hash_key_t))
        != NGX_OK)
    {
        return NGX_CONF_ERROR;
    }

    for (header = ngx_http_upstream_headers_in; heade...",1,1,http\ngx_http_upstream.c,ngx_http_upstream_init_main_conf,,false,6444,6502,ngx_http_upstream_init_main_conf,,,169,"char* ngx_http_upstream_init_main_conf (ngx_conf_t*,void*)"
317735,METHOD,http\ngx_http_upstream.h:<global>,TYPE_DECL,<global>,1,43,http\ngx_http_upstream.h,http\ngx_http_upstream.h:<global>,,false,1,437,<global>,,,1,
317754,METHOD,http\ngx_http_upstream.h:<global>,TYPE_DECL,"typedef ngx_int_t (*ngx_http_upstream_init_pt)(ngx_conf_t *cf,
    ngx_http_upstream_srv_conf_t *us);",19,37,http\ngx_http_upstream.h,ngx_http_upstream_init_pt,,false,81,82,ngx_http_upstream_init_pt,,,7,"ngx_int_t ngx_http_upstream_init_pt (ngx_conf_t*,ngx_http_upstream_srv_conf_t*)"
317760,METHOD,http\ngx_http_upstream.h:<global>,TYPE_DECL,"typedef ngx_int_t (*ngx_http_upstream_init_peer_pt)(ngx_http_request_t *r,
    ngx_http_upstream_srv_conf_t *us);",19,37,http\ngx_http_upstream.h,ngx_http_upstream_init_peer_pt,,false,83,84,ngx_http_upstream_init_peer_pt,,,8,"ngx_int_t ngx_http_upstream_init_peer_pt (ngx_http_request_t*,ngx_http_upstream_srv_conf_t*)"
317916,METHOD,http\ngx_http_upstream.h:<global>,TYPE_DECL,"typedef void (*ngx_http_upstream_handler_pt)(ngx_http_request_t *r,
    ngx_http_upstream_t *u);",14,27,http\ngx_http_upstream.h,ngx_http_upstream_handler_pt,,false,315,316,ngx_http_upstream_handler_pt,,,24,"void ngx_http_upstream_handler_pt (ngx_http_request_t*,ngx_http_upstream_t*)"
317941,METHOD,ngx_http_upstream_s,TYPE_DECL,ngx_int_t                      (*input_filter_init)(void *data);,36,67,http\ngx_http_upstream.h,ngx_http_upstream_s.input_filter_init,,false,351,351,input_filter_init,,,19,ngx_int_t ngx_http_upstream_s.input_filter_init (void*)
317946,METHOD,ngx_http_upstream_s,TYPE_DECL,"ngx_int_t                      (*input_filter)(void *data, ssize_t bytes);",36,77,http\ngx_http_upstream.h,ngx_http_upstream_s.input_filter,,false,352,352,input_filter,,,20,"ngx_int_t ngx_http_upstream_s.input_filter (void*,ssize_t)"
317953,METHOD,ngx_http_upstream_s,TYPE_DECL,ngx_int_t                      (*create_key)(ngx_http_request_t *r);,36,71,http\ngx_http_upstream.h,ngx_http_upstream_s.create_key,,false,356,356,create_key,,,22,ngx_int_t ngx_http_upstream_s.create_key (ngx_http_request_t*)
317958,METHOD,ngx_http_upstream_s,TYPE_DECL,ngx_int_t                      (*create_request)(ngx_http_request_t *r);,36,75,http\ngx_http_upstream.h,ngx_http_upstream_s.create_request,,false,358,358,create_request,,,23,ngx_int_t ngx_http_upstream_s.create_request (ngx_http_request_t*)
317963,METHOD,ngx_http_upstream_s,TYPE_DECL,ngx_int_t                      (*reinit_request)(ngx_http_request_t *r);,36,75,http\ngx_http_upstream.h,ngx_http_upstream_s.reinit_request,,false,359,359,reinit_request,,,24,ngx_int_t ngx_http_upstream_s.reinit_request (ngx_http_request_t*)
317968,METHOD,ngx_http_upstream_s,TYPE_DECL,ngx_int_t                      (*process_header)(ngx_http_request_t *r);,36,75,http\ngx_http_upstream.h,ngx_http_upstream_s.process_header,,false,360,360,process_header,,,25,ngx_int_t ngx_http_upstream_s.process_header (ngx_http_request_t*)
317973,METHOD,ngx_http_upstream_s,TYPE_DECL,void                           (*abort_request)(ngx_http_request_t *r);,36,74,http\ngx_http_upstream.h,ngx_http_upstream_s.abort_request,,false,361,361,abort_request,,,26,void ngx_http_upstream_s.abort_request (ngx_http_request_t*)
317978,METHOD,ngx_http_upstream_s,TYPE_DECL,"void                           (*finalize_request)(ngx_http_request_t *r,
                                         ngx_int_t rc);",36,54,http\ngx_http_upstream.h,ngx_http_upstream_s.finalize_request,,false,362,363,finalize_request,,,27,"void ngx_http_upstream_s.finalize_request (ngx_http_request_t*,ngx_int_t)"
317984,METHOD,ngx_http_upstream_s,TYPE_DECL,"ngx_int_t                      (*rewrite_redirect)(ngx_http_request_t *r,
                                         ngx_table_elt_t *h, size_t prefix);",36,75,http\ngx_http_upstream.h,ngx_http_upstream_s.rewrite_redirect,,false,364,365,rewrite_redirect,,,28,"ngx_int_t ngx_http_upstream_s.rewrite_redirect (ngx_http_request_t*,ngx_table_elt_t*,size_t)"
317991,METHOD,ngx_http_upstream_s,TYPE_DECL,"ngx_int_t                      (*rewrite_cookie)(ngx_http_request_t *r,
                                         ngx_table_elt_t *h);",36,60,http\ngx_http_upstream.h,ngx_http_upstream_s.rewrite_cookie,,false,366,367,rewrite_cookie,,,29,"ngx_int_t ngx_http_upstream_s.rewrite_cookie (ngx_http_request_t*,ngx_table_elt_t*)"
318025,METHOD,http\ngx_http_upstream.h:<global>,TYPE_DECL,ngx_int_t ngx_http_upstream_create(ngx_http_request_t *r);,11,57,http\ngx_http_upstream.h,ngx_http_upstream_create,,false,415,415,ngx_http_upstream_create,,,30,ngx_int_t ngx_http_upstream_create (ngx_http_request_t*)
318030,METHOD,http\ngx_http_upstream.h:<global>,TYPE_DECL,void ngx_http_upstream_init(ngx_http_request_t *r);,6,50,http\ngx_http_upstream.h,ngx_http_upstream_init,,false,416,416,ngx_http_upstream_init,,,31,void ngx_http_upstream_init (ngx_http_request_t*)
318035,METHOD,http\ngx_http_upstream.h:<global>,TYPE_DECL,"ngx_http_upstream_srv_conf_t *ngx_http_upstream_add(ngx_conf_t *cf,
    ngx_url_t *u, ngx_uint_t flags);",30,35,http\ngx_http_upstream.h,ngx_http_upstream_add,,false,417,418,ngx_http_upstream_add,,,32,"ngx_http_upstream_srv_conf_t* ngx_http_upstream_add (ngx_conf_t*,ngx_url_t*,ngx_uint_t)"
318042,METHOD,http\ngx_http_upstream.h:<global>,TYPE_DECL,"char *ngx_http_upstream_bind_set_slot(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",6,15,http\ngx_http_upstream.h,ngx_http_upstream_bind_set_slot,,false,419,420,ngx_http_upstream_bind_set_slot,,,33,"char* ngx_http_upstream_bind_set_slot (ngx_conf_t*,ngx_command_t*,void*)"
318049,METHOD,http\ngx_http_upstream.h:<global>,TYPE_DECL,"char *ngx_http_upstream_param_set_slot(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",6,15,http\ngx_http_upstream.h,ngx_http_upstream_param_set_slot,,false,421,422,ngx_http_upstream_param_set_slot,,,34,"char* ngx_http_upstream_param_set_slot (ngx_conf_t*,ngx_command_t*,void*)"
318056,METHOD,http\ngx_http_upstream.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_upstream_hide_headers_hash(ngx_conf_t *cf,
    ngx_http_upstream_conf_t *conf, ngx_http_upstream_conf_t *prev,
    ngx_str_t *default_hide_headers, ngx_hash_init_t *hash);",11,59,http\ngx_http_upstream.h,ngx_http_upstream_hide_headers_hash,,false,423,425,ngx_http_upstream_hide_headers_hash,,,35,"ngx_int_t ngx_http_upstream_hide_headers_hash (ngx_conf_t*,ngx_http_upstream_conf_t*,ngx_http_upstream_conf_t*,ngx_str_t*,ngx_hash_init_t*)"
318079,METHOD,http\ngx_http_upstream_round_robin.c:<global>,TYPE_DECL,<global>,1,30,http\ngx_http_upstream_round_robin.c,http\ngx_http_upstream_round_robin.c:<global>,,false,1,839,<global>,,,1,
318081,METHOD,http\ngx_http_upstream_round_robin.c:<global>,TYPE_DECL,"static ngx_http_upstream_rr_peer_t *ngx_http_upstream_get_peer(
    ngx_http_upstream_rr_peer_data_t *rrp);",36,42,http\ngx_http_upstream_round_robin.c,ngx_http_upstream_get_peer,,false,17,18,ngx_http_upstream_get_peer,,,1,ngx_http_upstream_rr_peer_t* ngx_http_upstream_get_peer (ngx_http_upstream_rr_peer_data_t*)
318086,METHOD,http\ngx_http_upstream_round_robin.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_upstream_init_round_robin(ngx_conf_t *cf,
    ngx_http_upstream_srv_conf_t *us)
{
    ngx_url_t                      u;
    ngx_uint_t                     i, j, n, w;
    ngx_http_upstream_server_t    *server;
    ngx_http_upstream_rr_peer_t   *peer, **peerp;
    ngx_http_upstream_rr_peers_t  *peers, *backup;

    us->peer.init = ngx_http_upstream_init_round_robin_peer;

    if (us->servers) {
        server = us->servers->elts;

        n = 0;
        w = 0;

        for (i = 0; i < us->servers->nelts; i++) {
            if (server[i].backup) {
                continue;
            }

            n += server[i].naddrs;
            w += server[i].naddrs * server[i].weight;
        }

        if (n == 0) {
            ngx_log_error(NGX_LOG_EMERG, cf->log, 0,
                          ""no servers in upstream \""%V\"" in %s:%ui"",
                          &us->host, us->file_name, us->line);
            return NGX_ERROR;
        }

        peers = ngx_pcalloc(cf->pool,...",1,1,http\ngx_http_upstream_round_robin.c,ngx_http_upstream_init_round_robin,,false,30,240,ngx_http_upstream_init_round_robin,,,2,"ngx_int_t ngx_http_upstream_init_round_robin (ngx_conf_t*,ngx_http_upstream_srv_conf_t*)"
319056,METHOD,http\ngx_http_upstream_round_robin.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_upstream_init_round_robin_peer(ngx_http_request_t *r,
    ngx_http_upstream_srv_conf_t *us)
{
    ngx_uint_t                         n;
    ngx_http_upstream_rr_peer_data_t  *rrp;

    rrp = r->upstream->peer.data;

    if (rrp == NULL) {
        rrp = ngx_palloc(r->pool, sizeof(ngx_http_upstream_rr_peer_data_t));
        if (rrp == NULL) {
            return NGX_ERROR;
        }

        r->upstream->peer.data = rrp;
    }

    rrp->peers = us->peer.data;
    rrp->current = NULL;
    rrp->config = 0;

    n = rrp->peers->number;

    if (rrp->peers->next && rrp->peers->next->number > n) {
        n = rrp->peers->next->number;
    }

    if (n <= 8 * sizeof(uintptr_t)) {
        rrp->tried = &rrp->data;
        rrp->data = 0;

    } else {
        n = (n + (8 * sizeof(uintptr_t) - 1)) / (8 * sizeof(uintptr_t));

        rrp->tried = ngx_pcalloc(r->pool, n * sizeof(uintptr_t));
        if (rrp->tried == NULL) {
            return NGX_ERROR;
        }
    }

    r->...",1,30,http\ngx_http_upstream_round_robin.c,ngx_http_upstream_init_round_robin_peer,,false,243,295,ngx_http_upstream_init_round_robin_peer,,,3,"ngx_int_t ngx_http_upstream_init_round_robin_peer (ngx_http_request_t*,ngx_http_upstream_srv_conf_t*)"
319266,METHOD,http\ngx_http_upstream_round_robin.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_upstream_create_round_robin_peer(ngx_http_request_t *r,
    ngx_http_upstream_resolved_t *ur)
{
    u_char                            *p;
    size_t                             len;
    socklen_t                          socklen;
    ngx_uint_t                         i, n;
    struct sockaddr                   *sockaddr;
    ngx_http_upstream_rr_peer_t       *peer, **peerp;
    ngx_http_upstream_rr_peers_t      *peers;
    ngx_http_upstream_rr_peer_data_t  *rrp;

    rrp = r->upstream->peer.data;

    if (rrp == NULL) {
        rrp = ngx_palloc(r->pool, sizeof(ngx_http_upstream_rr_peer_data_t));
        if (rrp == NULL) {
            return NGX_ERROR;
        }

        r->upstream->peer.data = rrp;
    }

    peers = ngx_pcalloc(r->pool, sizeof(ngx_http_upstream_rr_peers_t));
    if (peers == NULL) {
        return NGX_ERROR;
    }

    peer = ngx_pcalloc(r->pool, sizeof(ngx_http_upstream_rr_peer_t)
                                * ur->naddrs);
    if (peer == ...",1,30,http\ngx_http_upstream_round_robin.c,ngx_http_upstream_create_round_robin_peer,,false,298,413,ngx_http_upstream_create_round_robin_peer,,,4,"ngx_int_t ngx_http_upstream_create_round_robin_peer (ngx_http_request_t*,ngx_http_upstream_resolved_t*)"
319771,METHOD,http\ngx_http_upstream_round_robin.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_upstream_get_round_robin_peer(ngx_peer_connection_t *pc, void *data)
{
    ngx_http_upstream_rr_peer_data_t  *rrp = data;

    ngx_int_t                      rc;
    ngx_uint_t                     i, n;
    ngx_http_upstream_rr_peer_t   *peer;
    ngx_http_upstream_rr_peers_t  *peers;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, pc->log, 0,
                   ""get rr peer, try: %ui"", pc->tries);

    pc->cached = 0;
    pc->connection = NULL;

    peers = rrp->peers;
    ngx_http_upstream_rr_peers_wlock(peers);

    if (peers->single) {
        peer = peers->peer;

        if (peer->down) {
            goto failed;
        }

        if (peer->max_conns && peer->conns >= peer->max_conns) {
            goto failed;
        }

        rrp->current = peer;

    } else {

        /* there are several peers */

        peer = ngx_http_upstream_get_peer(rrp);

        if (peer == NULL) {
            goto failed;
        }

        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, pc->log, ...",1,1,http\ngx_http_upstream_round_robin.c,ngx_http_upstream_get_round_robin_peer,,false,416,504,ngx_http_upstream_get_round_robin_peer,,,5,"ngx_int_t ngx_http_upstream_get_round_robin_peer (ngx_peer_connection_t*,void*)"
319985,METHOD,http\ngx_http_upstream_round_robin.c:<global>,TYPE_DECL,"static ngx_http_upstream_rr_peer_t *
ngx_http_upstream_get_peer(ngx_http_upstream_rr_peer_data_t *rrp)
{
    time_t                        now;
    uintptr_t                     m;
    ngx_int_t                     total;
    ngx_uint_t                    i, n, p;
    ngx_http_upstream_rr_peer_t  *peer, *best;

    now = ngx_time();

    best = NULL;
    total = 0;

#if (NGX_SUPPRESS_WARN)
    p = 0;
#endif

    for (peer = rrp->peers->peer, i = 0;
         peer;
         peer = peer->next, i++)
    {
        n = i / (8 * sizeof(uintptr_t));
        m = (uintptr_t) 1 << i % (8 * sizeof(uintptr_t));

        if (rrp->tried[n] & m) {
            continue;
        }

        if (peer->down) {
            continue;
        }

        if (peer->max_fails
            && peer->fails >= peer->max_fails
            && now - peer->checked <= peer->fail_timeout)
        {
            continue;
        }

        if (peer->max_conns && peer->conns >= peer->max_conns) {
            continue;
   ...",1,1,http\ngx_http_upstream_round_robin.c,ngx_http_upstream_get_peer,,false,507,582,ngx_http_upstream_get_peer,,,6,ngx_http_upstream_rr_peer_t ngx_http_upstream_get_peer (ngx_http_upstream_rr_peer_data_t*)
320210,METHOD,http\ngx_http_upstream_round_robin.c:<global>,TYPE_DECL,"void
ngx_http_upstream_free_round_robin_peer(ngx_peer_connection_t *pc, void *data,
    ngx_uint_t state)
{
    ngx_http_upstream_rr_peer_data_t  *rrp = data;

    time_t                       now;
    ngx_http_upstream_rr_peer_t  *peer;

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, pc->log, 0,
                   ""free rr peer %ui %ui"", pc->tries, state);

    /* TODO: NGX_PEER_KEEPALIVE */

    peer = rrp->current;

    ngx_http_upstream_rr_peers_rlock(rrp->peers);
    ngx_http_upstream_rr_peer_lock(rrp->peers, peer);

    if (rrp->peers->single) {

        peer->conns--;

        ngx_http_upstream_rr_peer_unlock(rrp->peers, peer);
        ngx_http_upstream_rr_peers_unlock(rrp->peers);

        pc->tries = 0;
        return;
    }

    if (state & NGX_PEER_FAILED) {
        now = ngx_time();

        peer->fails++;
        peer->accessed = now;
        peer->checked = now;

        if (peer->max_fails) {
            peer->effective_weight -= peer->weight / peer->max_fails;

            i...",1,1,http\ngx_http_upstream_round_robin.c,ngx_http_upstream_free_round_robin_peer,,false,585,656,ngx_http_upstream_free_round_robin_peer,,,7,"void ngx_http_upstream_free_round_robin_peer (ngx_peer_connection_t*,void*,ngx_uint_t)"
320398,METHOD,http\ngx_http_upstream_round_robin.h:<global>,TYPE_DECL,<global>,1,55,http\ngx_http_upstream_round_robin.h,http\ngx_http_upstream_round_robin.h:<global>,,false,1,156,<global>,,,1,
320446,METHOD,http\ngx_http_upstream_round_robin.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_upstream_init_round_robin(ngx_conf_t *cf,
    ngx_http_upstream_srv_conf_t *us);",11,37,http\ngx_http_upstream_round_robin.h,ngx_http_upstream_init_round_robin,,false,136,137,ngx_http_upstream_init_round_robin,,,9,"ngx_int_t ngx_http_upstream_init_round_robin (ngx_conf_t*,ngx_http_upstream_srv_conf_t*)"
320452,METHOD,http\ngx_http_upstream_round_robin.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_upstream_init_round_robin_peer(ngx_http_request_t *r,
    ngx_http_upstream_srv_conf_t *us);",11,37,http\ngx_http_upstream_round_robin.h,ngx_http_upstream_init_round_robin_peer,,false,138,139,ngx_http_upstream_init_round_robin_peer,,,10,"ngx_int_t ngx_http_upstream_init_round_robin_peer (ngx_http_request_t*,ngx_http_upstream_srv_conf_t*)"
320458,METHOD,http\ngx_http_upstream_round_robin.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_upstream_create_round_robin_peer(ngx_http_request_t *r,
    ngx_http_upstream_resolved_t *ur);",11,37,http\ngx_http_upstream_round_robin.h,ngx_http_upstream_create_round_robin_peer,,false,140,141,ngx_http_upstream_create_round_robin_peer,,,11,"ngx_int_t ngx_http_upstream_create_round_robin_peer (ngx_http_request_t*,ngx_http_upstream_resolved_t*)"
320464,METHOD,http\ngx_http_upstream_round_robin.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_upstream_get_round_robin_peer(ngx_peer_connection_t *pc,
    void *data);",11,15,http\ngx_http_upstream_round_robin.h,ngx_http_upstream_get_round_robin_peer,,false,142,143,ngx_http_upstream_get_round_robin_peer,,,12,"ngx_int_t ngx_http_upstream_get_round_robin_peer (ngx_peer_connection_t*,void*)"
320470,METHOD,http\ngx_http_upstream_round_robin.h:<global>,TYPE_DECL,"void ngx_http_upstream_free_round_robin_peer(ngx_peer_connection_t *pc,
    void *data, ngx_uint_t state);",6,33,http\ngx_http_upstream_round_robin.h,ngx_http_upstream_free_round_robin_peer,,false,144,145,ngx_http_upstream_free_round_robin_peer,,,13,"void ngx_http_upstream_free_round_robin_peer (ngx_peer_connection_t*,void*,ngx_uint_t)"
320488,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,<global>,1,1,http\ngx_http_variables.c,http\ngx_http_variables.c:<global>,,false,1,2740,<global>,,,1,
320490,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_http_variable_t *ngx_http_add_prefix_variable(ngx_conf_t *cf,
    ngx_str_t *name, ngx_uint_t flags);",28,38,http\ngx_http_variables.c,ngx_http_add_prefix_variable,,false,14,15,ngx_http_add_prefix_variable,,,1,"ngx_http_variable_t* ngx_http_add_prefix_variable (ngx_conf_t*,ngx_str_t*,ngx_uint_t)"
320497,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_request(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_request,,false,17,18,ngx_http_variable_request,,,2,"ngx_int_t ngx_http_variable_request (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320504,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_request_get_size(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_request_get_size,,false,23,24,ngx_http_variable_request_get_size,,,3,"ngx_int_t ngx_http_variable_request_get_size (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320511,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_header(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_header,,false,25,26,ngx_http_variable_header,,,4,"ngx_int_t ngx_http_variable_header (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320518,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_cookies(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_cookies,,false,28,29,ngx_http_variable_cookies,,,5,"ngx_int_t ngx_http_variable_cookies (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320525,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_headers(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_headers,,false,30,31,ngx_http_variable_headers,,,6,"ngx_int_t ngx_http_variable_headers (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320532,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_headers_internal(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data, u_char sep);",18,61,http\ngx_http_variables.c,ngx_http_variable_headers_internal,,false,32,33,ngx_http_variable_headers_internal,,,7,"ngx_int_t ngx_http_variable_headers_internal (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t,u_char)"
320540,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_unknown_header_in(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_unknown_header_in,,false,35,36,ngx_http_variable_unknown_header_in,,,8,"ngx_int_t ngx_http_variable_unknown_header_in (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320547,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_unknown_header_out(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_unknown_header_out,,false,37,38,ngx_http_variable_unknown_header_out,,,9,"ngx_int_t ngx_http_variable_unknown_header_out (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320554,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_unknown_trailer_out(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_unknown_trailer_out,,false,39,40,ngx_http_variable_unknown_trailer_out,,,10,"ngx_int_t ngx_http_variable_unknown_trailer_out (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320561,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_request_line(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_request_line,,false,41,42,ngx_http_variable_request_line,,,11,"ngx_int_t ngx_http_variable_request_line (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320568,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_cookie(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_cookie,,false,43,44,ngx_http_variable_cookie,,,12,"ngx_int_t ngx_http_variable_cookie (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320575,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_argument(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_argument,,false,45,46,ngx_http_variable_argument,,,13,"ngx_int_t ngx_http_variable_argument (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320582,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_content_length(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_content_length,,false,52,53,ngx_http_variable_content_length,,,14,"ngx_int_t ngx_http_variable_content_length (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320589,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_host(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_host,,false,54,55,ngx_http_variable_host,,,15,"ngx_int_t ngx_http_variable_host (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320596,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_binary_remote_addr(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_binary_remote_addr,,false,56,57,ngx_http_variable_binary_remote_addr,,,16,"ngx_int_t ngx_http_variable_binary_remote_addr (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320603,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_remote_addr(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_remote_addr,,false,58,59,ngx_http_variable_remote_addr,,,17,"ngx_int_t ngx_http_variable_remote_addr (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320610,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_remote_port(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_remote_port,,false,60,61,ngx_http_variable_remote_port,,,18,"ngx_int_t ngx_http_variable_remote_port (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320617,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_proxy_protocol_addr(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_proxy_protocol_addr,,false,62,63,ngx_http_variable_proxy_protocol_addr,,,19,"ngx_int_t ngx_http_variable_proxy_protocol_addr (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320624,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_proxy_protocol_port(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_proxy_protocol_port,,false,64,65,ngx_http_variable_proxy_protocol_port,,,20,"ngx_int_t ngx_http_variable_proxy_protocol_port (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320631,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_server_addr(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_server_addr,,false,66,67,ngx_http_variable_server_addr,,,21,"ngx_int_t ngx_http_variable_server_addr (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320638,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_server_port(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_server_port,,false,68,69,ngx_http_variable_server_port,,,22,"ngx_int_t ngx_http_variable_server_port (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320645,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_scheme(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_scheme,,false,70,71,ngx_http_variable_scheme,,,23,"ngx_int_t ngx_http_variable_scheme (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320652,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_https(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_https,,false,72,73,ngx_http_variable_https,,,24,"ngx_int_t ngx_http_variable_https (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320659,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static void ngx_http_variable_set_args(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",13,49,http\ngx_http_variables.c,ngx_http_variable_set_args,,false,74,75,ngx_http_variable_set_args,,,25,"void ngx_http_variable_set_args (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320666,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_is_args(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_is_args,,false,76,77,ngx_http_variable_is_args,,,26,"ngx_int_t ngx_http_variable_is_args (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320673,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_document_root(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_document_root,,false,78,79,ngx_http_variable_document_root,,,27,"ngx_int_t ngx_http_variable_document_root (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320680,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_realpath_root(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_realpath_root,,false,80,81,ngx_http_variable_realpath_root,,,28,"ngx_int_t ngx_http_variable_realpath_root (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320687,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_request_filename(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_request_filename,,false,82,83,ngx_http_variable_request_filename,,,29,"ngx_int_t ngx_http_variable_request_filename (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320694,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_server_name(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_server_name,,false,84,85,ngx_http_variable_server_name,,,30,"ngx_int_t ngx_http_variable_server_name (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320701,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_request_method(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_request_method,,false,86,87,ngx_http_variable_request_method,,,31,"ngx_int_t ngx_http_variable_request_method (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320708,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_remote_user(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_remote_user,,false,88,89,ngx_http_variable_remote_user,,,32,"ngx_int_t ngx_http_variable_remote_user (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320715,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_bytes_sent(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_bytes_sent,,false,90,91,ngx_http_variable_bytes_sent,,,33,"ngx_int_t ngx_http_variable_bytes_sent (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320722,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_body_bytes_sent(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_body_bytes_sent,,false,92,93,ngx_http_variable_body_bytes_sent,,,34,"ngx_int_t ngx_http_variable_body_bytes_sent (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320729,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_pipe(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_pipe,,false,94,95,ngx_http_variable_pipe,,,35,"ngx_int_t ngx_http_variable_pipe (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320736,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_request_completion(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_request_completion,,false,96,97,ngx_http_variable_request_completion,,,36,"ngx_int_t ngx_http_variable_request_completion (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320743,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_request_body(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_request_body,,false,98,99,ngx_http_variable_request_body,,,37,"ngx_int_t ngx_http_variable_request_body (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320750,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_request_body_file(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_request_body_file,,false,100,101,ngx_http_variable_request_body_file,,,38,"ngx_int_t ngx_http_variable_request_body_file (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320757,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_request_length(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_request_length,,false,102,103,ngx_http_variable_request_length,,,39,"ngx_int_t ngx_http_variable_request_length (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320764,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_request_time(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_request_time,,false,104,105,ngx_http_variable_request_time,,,40,"ngx_int_t ngx_http_variable_request_time (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320771,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_request_id(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_request_id,,false,106,107,ngx_http_variable_request_id,,,41,"ngx_int_t ngx_http_variable_request_id (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320778,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_status(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_status,,false,108,109,ngx_http_variable_status,,,42,"ngx_int_t ngx_http_variable_status (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320785,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_sent_content_type(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_sent_content_type,,false,111,112,ngx_http_variable_sent_content_type,,,43,"ngx_int_t ngx_http_variable_sent_content_type (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320792,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_sent_content_length(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_sent_content_length,,false,113,114,ngx_http_variable_sent_content_length,,,44,"ngx_int_t ngx_http_variable_sent_content_length (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320799,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_sent_location(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_sent_location,,false,115,116,ngx_http_variable_sent_location,,,45,"ngx_int_t ngx_http_variable_sent_location (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320806,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_sent_last_modified(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_sent_last_modified,,false,117,118,ngx_http_variable_sent_last_modified,,,46,"ngx_int_t ngx_http_variable_sent_last_modified (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320813,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_sent_connection(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_sent_connection,,false,119,120,ngx_http_variable_sent_connection,,,47,"ngx_int_t ngx_http_variable_sent_connection (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320820,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_sent_keep_alive(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_sent_keep_alive,,false,121,122,ngx_http_variable_sent_keep_alive,,,48,"ngx_int_t ngx_http_variable_sent_keep_alive (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320827,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_sent_transfer_encoding(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_sent_transfer_encoding,,false,123,124,ngx_http_variable_sent_transfer_encoding,,,49,"ngx_int_t ngx_http_variable_sent_transfer_encoding (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320834,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static void ngx_http_variable_set_limit_rate(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",13,49,http\ngx_http_variables.c,ngx_http_variable_set_limit_rate,,false,125,126,ngx_http_variable_set_limit_rate,,,50,"void ngx_http_variable_set_limit_rate (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320841,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_connection(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_connection,,false,128,129,ngx_http_variable_connection,,,51,"ngx_int_t ngx_http_variable_connection (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320848,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_connection_requests(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_connection_requests,,false,130,131,ngx_http_variable_connection_requests,,,52,"ngx_int_t ngx_http_variable_connection_requests (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320855,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_nginx_version(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_nginx_version,,false,133,134,ngx_http_variable_nginx_version,,,53,"ngx_int_t ngx_http_variable_nginx_version (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320862,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_hostname(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_hostname,,false,135,136,ngx_http_variable_hostname,,,54,"ngx_int_t ngx_http_variable_hostname (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320869,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_pid(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_pid,,false,137,138,ngx_http_variable_pid,,,55,"ngx_int_t ngx_http_variable_pid (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320876,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_msec(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_msec,,false,139,140,ngx_http_variable_msec,,,56,"ngx_int_t ngx_http_variable_msec (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320883,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_time_iso8601(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_time_iso8601,,false,141,142,ngx_http_variable_time_iso8601,,,57,"ngx_int_t ngx_http_variable_time_iso8601 (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
320890,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_variable_time_local(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\ngx_http_variables.c,ngx_http_variable_time_local,,false,143,144,ngx_http_variable_time_local,,,58,"ngx_int_t ngx_http_variable_time_local (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
321492,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"ngx_http_variable_t *
ngx_http_add_variable(ngx_conf_t *cf, ngx_str_t *name, ngx_uint_t flags)
{
    ngx_int_t                   rc;
    ngx_uint_t                  i;
    ngx_hash_key_t             *key;
    ngx_http_variable_t        *v;
    ngx_http_core_main_conf_t  *cmcf;

    if (name->len == 0) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""invalid variable name \""$\"""");
        return NULL;
    }

    if (flags & NGX_HTTP_VAR_PREFIX) {
        return ngx_http_add_prefix_variable(cf, name, flags);
    }

    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);

    key = cmcf->variables_keys->keys.elts;
    for (i = 0; i < cmcf->variables_keys->keys.nelts; i++) {
        if (name->len != key[i].key.len
            || ngx_strncasecmp(name->data, key[i].key.data, name->len) != 0)
        {
            continue;
        }

        v = key[i].value;

        if (!(v->flags & NGX_HTTP_VAR_CHANGEABLE)) {
            ngx_conf_log_error...",1,1,http\ngx_http_variables.c,ngx_http_add_variable,,false,405,481,ngx_http_add_variable,,,67,"ngx_http_variable_t ngx_http_add_variable (ngx_conf_t*,ngx_str_t*,ngx_uint_t)"
321746,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_http_variable_t *
ngx_http_add_prefix_variable(ngx_conf_t *cf, ngx_str_t *name, ngx_uint_t flags)
{
    ngx_uint_t                  i;
    ngx_http_variable_t        *v;
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);

    v = cmcf->prefix_variables.elts;
    for (i = 0; i < cmcf->prefix_variables.nelts; i++) {
        if (name->len != v[i].name.len
            || ngx_strncasecmp(name->data, v[i].name.data, name->len) != 0)
        {
            continue;
        }

        v = &v[i];

        if (!(v->flags & NGX_HTTP_VAR_CHANGEABLE)) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               ""the duplicate \""%V\"" variable"", name);
            return NULL;
        }

        if (!(flags & NGX_HTTP_VAR_WEAK)) {
            v->flags &= ~NGX_HTTP_VAR_WEAK;
        }

        return v;
    }

    v = ngx_array_push(&cmcf->prefix_variables);
    if (v == NULL) {
        return NULL;
   ...",1,1,http\ngx_http_variables.c,ngx_http_add_prefix_variable,,false,484,536,ngx_http_add_prefix_variable,,,68,"ngx_http_variable_t ngx_http_add_prefix_variable (ngx_conf_t*,ngx_str_t*,ngx_uint_t)"
321936,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_get_variable_index(ngx_conf_t *cf, ngx_str_t *name)
{
    ngx_uint_t                  i;
    ngx_http_variable_t        *v;
    ngx_http_core_main_conf_t  *cmcf;

    if (name->len == 0) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""invalid variable name \""$\"""");
        return NGX_ERROR;
    }

    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);

    v = cmcf->variables.elts;

    if (v == NULL) {
        if (ngx_array_init(&cmcf->variables, cf->pool, 4,
                           sizeof(ngx_http_variable_t))
            != NGX_OK)
        {
            return NGX_ERROR;
        }

    } else {
        for (i = 0; i < cmcf->variables.nelts; i++) {
            if (name->len != v[i].name.len
                || ngx_strncasecmp(name->data, v[i].name.data, name->len) != 0)
            {
                continue;
            }

            return i;
        }
    }

    v = ngx_array_push(&cmcf->variables);
    if (...",1,1,http\ngx_http_variables.c,ngx_http_get_variable_index,,false,539,596,ngx_http_get_variable_index,,,69,"ngx_int_t ngx_http_get_variable_index (ngx_conf_t*,ngx_str_t*)"
322137,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"ngx_http_variable_value_t *
ngx_http_get_indexed_variable(ngx_http_request_t *r, ngx_uint_t index)
{
    ngx_http_variable_t        *v;
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);

    if (cmcf->variables.nelts <= index) {
        ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,
                      ""unknown variable index: %ui"", index);
        return NULL;
    }

    if (r->variables[index].not_found || r->variables[index].valid) {
        return &r->variables[index];
    }

    v = cmcf->variables.elts;

    if (ngx_http_variable_depth == 0) {
        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                      ""cycle while evaluating variable \""%V\"""",
                      &v[index].name);
        return NULL;
    }

    ngx_http_variable_depth--;

    if (v[index].get_handler(r, &r->variables[index], v[index].data)
        == NGX_OK)
    {
        ngx_http_variable_depth++;

        if (v[index].flags ...",1,1,http\ngx_http_variables.c,ngx_http_get_indexed_variable,,false,599,646,ngx_http_get_indexed_variable,,,70,"ngx_http_variable_value_t ngx_http_get_indexed_variable (ngx_http_request_t*,ngx_uint_t)"
322297,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"ngx_http_variable_value_t *
ngx_http_get_flushed_variable(ngx_http_request_t *r, ngx_uint_t index)
{
    ngx_http_variable_value_t  *v;

    v = &r->variables[index];

    if (v->valid || v->not_found) {
        if (!v->no_cacheable) {
            return v;
        }

        v->valid = 0;
        v->not_found = 0;
    }

    return ngx_http_get_indexed_variable(r, index);
}",1,1,http\ngx_http_variables.c,ngx_http_get_flushed_variable,,false,649,666,ngx_http_get_flushed_variable,,,71,"ngx_http_variable_value_t ngx_http_get_flushed_variable (ngx_http_request_t*,ngx_uint_t)"
322343,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"ngx_http_variable_value_t *
ngx_http_get_variable(ngx_http_request_t *r, ngx_str_t *name, ngx_uint_t key)
{
    size_t                      len;
    ngx_uint_t                  i, n;
    ngx_http_variable_t        *v;
    ngx_http_variable_value_t  *vv;
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);

    v = ngx_hash_find(&cmcf->variables_hash, key, name->data, name->len);

    if (v) {
        if (v->flags & NGX_HTTP_VAR_INDEXED) {
            return ngx_http_get_flushed_variable(r, v->index);
        }

        if (ngx_http_variable_depth == 0) {
            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                          ""cycle while evaluating variable \""%V\"""", name);
            return NULL;
        }

        ngx_http_variable_depth--;

        vv = ngx_palloc(r->pool, sizeof(ngx_http_variable_value_t));

        if (vv && v->get_handler(r, vv, v->data) == NGX_OK) {
            ngx_http_variable_depth++;
   ...",1,1,http\ngx_http_variables.c,ngx_http_get_variable,,false,669,736,ngx_http_get_variable,,,72,"ngx_http_variable_value_t ngx_http_get_variable (ngx_http_request_t*,ngx_str_t*,ngx_uint_t)"
322575,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_request(ngx_http_request_t *r, ngx_http_variable_value_t *v,
    uintptr_t data)
{
    ngx_str_t  *s;

    s = (ngx_str_t *) ((char *) r + data);

    if (s->data) {
        v->len = s->len;
        v->valid = 1;
        v->no_cacheable = 0;
        v->not_found = 0;
        v->data = s->data;

    } else {
        v->not_found = 1;
    }

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_request,,false,739,759,ngx_http_variable_request,,,73,"ngx_int_t ngx_http_variable_request (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
322635,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_request_get_size(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    size_t  *sp;

    sp = (size_t *) ((char *) r + data);

    v->data = ngx_pnalloc(r->pool, NGX_SIZE_T_LEN);
    if (v->data == NULL) {
        return NGX_ERROR;
    }

    v->len = ngx_sprintf(v->data, ""%uz"", *sp) - v->data;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_request_get_size,,false,779,798,ngx_http_variable_request_get_size,,,74,"ngx_int_t ngx_http_variable_request_get_size (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
322702,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_header(ngx_http_request_t *r, ngx_http_variable_value_t *v,
    uintptr_t data)
{
    ngx_table_elt_t  *h;

    h = *(ngx_table_elt_t **) ((char *) r + data);

    if (h) {
        v->len = h->value.len;
        v->valid = 1;
        v->no_cacheable = 0;
        v->not_found = 0;
        v->data = h->value.data;

    } else {
        v->not_found = 1;
    }

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_header,,false,801,821,ngx_http_variable_header,,,75,"ngx_int_t ngx_http_variable_header (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
322765,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_cookies(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    return ngx_http_variable_headers_internal(r, v, data, ';');
}",1,1,http\ngx_http_variables.c,ngx_http_variable_cookies,,false,824,829,ngx_http_variable_cookies,,,76,"ngx_int_t ngx_http_variable_cookies (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
322778,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_headers(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    return ngx_http_variable_headers_internal(r, v, data, ',');
}",1,1,http\ngx_http_variables.c,ngx_http_variable_headers,,false,832,837,ngx_http_variable_headers,,,77,"ngx_int_t ngx_http_variable_headers (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
322791,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_headers_internal(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data, u_char sep)
{
    size_t             len;
    u_char            *p, *end;
    ngx_uint_t         i, n;
    ngx_array_t       *a;
    ngx_table_elt_t  **h;

    a = (ngx_array_t *) ((char *) r + data);

    n = a->nelts;
    h = a->elts;

    len = 0;

    for (i = 0; i < n; i++) {

        if (h[i]->hash == 0) {
            continue;
        }

        len += h[i]->value.len + 2;
    }

    if (len == 0) {
        v->not_found = 1;
        return NGX_OK;
    }

    len -= 2;

    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;

    if (n == 1) {
        v->len = (*h)->value.len;
        v->data = (*h)->value.data;

        return NGX_OK;
    }

    p = ngx_pnalloc(r->pool, len);
    if (p == NULL) {
        return NGX_ERROR;
    }

    v->len = len;
    v->data = p;

    end = p + len;

    for (i = 0; /* void */ ; i++) {

        if (h[i]->hash =...",1,1,http\ngx_http_variables.c,ngx_http_variable_headers_internal,,false,840,910,ngx_http_variable_headers_internal,,,78,"ngx_int_t ngx_http_variable_headers_internal (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t,u_char)"
323000,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_unknown_header_in(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    return ngx_http_variable_unknown_header(v, (ngx_str_t *) data,
                                            &r->headers_in.headers.part,
                                            sizeof(""http_"") - 1);
}",1,1,http\ngx_http_variables.c,ngx_http_variable_unknown_header_in,,false,913,920,ngx_http_variable_unknown_header_in,,,79,"ngx_int_t ngx_http_variable_unknown_header_in (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
323025,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_unknown_header_out(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    return ngx_http_variable_unknown_header(v, (ngx_str_t *) data,
                                            &r->headers_out.headers.part,
                                            sizeof(""sent_http_"") - 1);
}",1,1,http\ngx_http_variables.c,ngx_http_variable_unknown_header_out,,false,923,930,ngx_http_variable_unknown_header_out,,,80,"ngx_int_t ngx_http_variable_unknown_header_out (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
323050,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_unknown_trailer_out(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    return ngx_http_variable_unknown_header(v, (ngx_str_t *) data,
                                            &r->headers_out.trailers.part,
                                            sizeof(""sent_trailer_"") - 1);
}",1,1,http\ngx_http_variables.c,ngx_http_variable_unknown_trailer_out,,false,933,940,ngx_http_variable_unknown_trailer_out,,,81,"ngx_int_t ngx_http_variable_unknown_trailer_out (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
323075,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_variable_unknown_header(ngx_http_variable_value_t *v, ngx_str_t *var,
    ngx_list_part_t *part, size_t prefix)
{
    u_char            ch;
    ngx_uint_t        i, n;
    ngx_table_elt_t  *header;

    header = part->elts;

    for (i = 0; /* void */ ; i++) {

        if (i >= part->nelts) {
            if (part->next == NULL) {
                break;
            }

            part = part->next;
            header = part->elts;
            i = 0;
        }

        if (header[i].hash == 0) {
            continue;
        }

        for (n = 0; n + prefix < var->len && n < header[i].key.len; n++) {
            ch = header[i].key.data[n];

            if (ch >= 'A' && ch <= 'Z') {
                ch |= 0x20;

            } else if (ch == '-') {
                ch = '_';
            }

            if (var->data[n + prefix] != ch) {
                break;
            }
        }

        if (n + prefix == var->len && n == header[i].key.len) {
            v->len = he...",1,1,http\ngx_http_variables.c,ngx_http_variable_unknown_header,,false,943,998,ngx_http_variable_unknown_header,,,82,"ngx_int_t ngx_http_variable_unknown_header (ngx_http_variable_value_t*,ngx_str_t*,ngx_list_part_t*,size_t)"
323273,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_request_line(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    u_char  *p, *s;

    s = r->request_line.data;

    if (s == NULL) {
        s = r->request_start;

        if (s == NULL) {
            v->not_found = 1;
            return NGX_OK;
        }

        for (p = s; p < r->header_in->last; p++) {
            if (*p == CR || *p == LF) {
                break;
            }
        }

        r->request_line.len = p - s;
        r->request_line.data = s;
    }

    v->len = r->request_line.len;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = s;

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_request_line,,false,1001,1034,ngx_http_variable_request_line,,,83,"ngx_int_t ngx_http_variable_request_line (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
323385,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_cookie(ngx_http_request_t *r, ngx_http_variable_value_t *v,
    uintptr_t data)
{
    ngx_str_t *name = (ngx_str_t *) data;

    ngx_str_t  cookie, s;

    s.len = name->len - (sizeof(""cookie_"") - 1);
    s.data = name->data + sizeof(""cookie_"") - 1;

    if (ngx_http_parse_multi_header_lines(&r->headers_in.cookies, &s, &cookie)
        == NGX_DECLINED)
    {
        v->not_found = 1;
        return NGX_OK;
    }

    v->len = cookie.len;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = cookie.data;

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_cookie,,false,1037,1062,ngx_http_variable_cookie,,,84,"ngx_int_t ngx_http_variable_cookie (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
323477,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_argument(ngx_http_request_t *r, ngx_http_variable_value_t *v,
    uintptr_t data)
{
    ngx_str_t *name = (ngx_str_t *) data;

    u_char     *arg;
    size_t      len;
    ngx_str_t   value;

    len = name->len - (sizeof(""arg_"") - 1);
    arg = name->data + sizeof(""arg_"") - 1;

    if (len == 0 || ngx_http_arg(r, arg, len, &value) != NGX_OK) {
        v->not_found = 1;
        return NGX_OK;
    }

    v->data = value.data;
    v->len = value.len;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_argument,,false,1065,1090,ngx_http_variable_argument,,,85,"ngx_int_t ngx_http_variable_argument (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
323565,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_content_length(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    u_char  *p;

    if (r->headers_in.content_length) {
        v->len = r->headers_in.content_length->value.len;
        v->data = r->headers_in.content_length->value.data;
        v->valid = 1;
        v->no_cacheable = 0;
        v->not_found = 0;

    } else if (r->reading_body) {
        v->not_found = 1;
        v->no_cacheable = 1;

    } else if (r->headers_in.content_length_n >= 0) {
        p = ngx_pnalloc(r->pool, NGX_OFF_T_LEN);
        if (p == NULL) {
            return NGX_ERROR;
        }

        v->len = ngx_sprintf(p, ""%O"", r->headers_in.content_length_n) - p;
        v->data = p;
        v->valid = 1;
        v->no_cacheable = 0;
        v->not_found = 0;

    } else {
        v->not_found = 1;
    }

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_content_length,,false,1148,1182,ngx_http_variable_content_length,,,86,"ngx_int_t ngx_http_variable_content_length (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
323706,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_host(ngx_http_request_t *r, ngx_http_variable_value_t *v,
    uintptr_t data)
{
    ngx_http_core_srv_conf_t  *cscf;

    if (r->headers_in.server.len) {
        v->len = r->headers_in.server.len;
        v->data = r->headers_in.server.data;

    } else {
        cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);

        v->len = cscf->server_name.len;
        v->data = cscf->server_name.data;
    }

    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_host,,false,1185,1207,ngx_http_variable_host,,,87,"ngx_int_t ngx_http_variable_host (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
323787,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_binary_remote_addr(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    struct sockaddr_in   *sin;
#if (NGX_HAVE_INET6)
    struct sockaddr_in6  *sin6;
#endif

    switch (r->connection->sockaddr->sa_family) {

#if (NGX_HAVE_INET6)
    case AF_INET6:
        sin6 = (struct sockaddr_in6 *) r->connection->sockaddr;

        v->len = sizeof(struct in6_addr);
        v->valid = 1;
        v->no_cacheable = 0;
        v->not_found = 0;
        v->data = sin6->sin6_addr.s6_addr;

        break;
#endif

#if (NGX_HAVE_UNIX_DOMAIN)
    case AF_UNIX:

        v->len = r->connection->addr_text.len;
        v->valid = 1;
        v->no_cacheable = 0;
        v->not_found = 0;
        v->data = r->connection->addr_text.data;

        break;
#endif

    default: /* AF_INET */
        sin = (struct sockaddr_in *) r->connection->sockaddr;

        v->len = sizeof(in_addr_t);
        v->valid = 1;
        v->no_cacheable = 0;
        v->not...",1,1,http\ngx_http_variables.c,ngx_http_variable_binary_remote_addr,,false,1210,1259,ngx_http_variable_binary_remote_addr,,,88,"ngx_int_t ngx_http_variable_binary_remote_addr (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
323848,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_remote_addr(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    v->len = r->connection->addr_text.len;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = r->connection->addr_text.data;

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_remote_addr,,false,1262,1273,ngx_http_variable_remote_addr,,,89,"ngx_int_t ngx_http_variable_remote_addr (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
323894,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_remote_port(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    ngx_uint_t  port;

    v->len = 0;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;

    v->data = ngx_pnalloc(r->pool, sizeof(""65535"") - 1);
    if (v->data == NULL) {
        return NGX_ERROR;
    }

    port = ngx_inet_get_port(r->connection->sockaddr);

    if (port > 0 && port < 65536) {
        v->len = ngx_sprintf(v->data, ""%ui"", port) - v->data;
    }

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_remote_port,,false,1276,1299,ngx_http_variable_remote_port,,,90,"ngx_int_t ngx_http_variable_remote_port (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
323976,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_proxy_protocol_addr(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    ngx_str_t             *addr;
    ngx_proxy_protocol_t  *pp;

    pp = r->connection->proxy_protocol;
    if (pp == NULL) {
        v->not_found = 1;
        return NGX_OK;
    }

    addr = (ngx_str_t *) ((char *) pp + data);

    v->len = addr->len;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = addr->data;

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_proxy_protocol_addr,,false,1302,1324,ngx_http_variable_proxy_protocol_addr,,,91,"ngx_int_t ngx_http_variable_proxy_protocol_addr (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
324044,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_proxy_protocol_port(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    ngx_uint_t             port;
    ngx_proxy_protocol_t  *pp;

    pp = r->connection->proxy_protocol;
    if (pp == NULL) {
        v->not_found = 1;
        return NGX_OK;
    }

    v->len = 0;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;

    v->data = ngx_pnalloc(r->pool, sizeof(""65535"") - 1);
    if (v->data == NULL) {
        return NGX_ERROR;
    }

    port = *(in_port_t *) ((char *) pp + data);

    if (port > 0 && port < 65536) {
        v->len = ngx_sprintf(v->data, ""%ui"", port) - v->data;
    }

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_proxy_protocol_port,,false,1327,1357,ngx_http_variable_proxy_protocol_port,,,92,"ngx_int_t ngx_http_variable_proxy_protocol_port (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
324148,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_server_addr(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    ngx_str_t  s;
    u_char     addr[NGX_SOCKADDR_STRLEN];

    s.len = NGX_SOCKADDR_STRLEN;
    s.data = addr;

    if (ngx_connection_local_sockaddr(r->connection, &s, 0) != NGX_OK) {
        return NGX_ERROR;
    }

    s.data = ngx_pnalloc(r->pool, s.len);
    if (s.data == NULL) {
        return NGX_ERROR;
    }

    ngx_memcpy(s.data, addr, s.len);

    v->len = s.len;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = s.data;

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_server_addr,,false,1360,1388,ngx_http_variable_server_addr,,,93,"ngx_int_t ngx_http_variable_server_addr (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
324239,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_server_port(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    ngx_uint_t  port;

    v->len = 0;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;

    if (ngx_connection_local_sockaddr(r->connection, NULL, 0) != NGX_OK) {
        return NGX_ERROR;
    }

    v->data = ngx_pnalloc(r->pool, sizeof(""65535"") - 1);
    if (v->data == NULL) {
        return NGX_ERROR;
    }

    port = ngx_inet_get_port(r->connection->local_sockaddr);

    if (port > 0 && port < 65536) {
        v->len = ngx_sprintf(v->data, ""%ui"", port) - v->data;
    }

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_server_port,,false,1391,1418,ngx_http_variable_server_port,,,94,"ngx_int_t ngx_http_variable_server_port (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
324333,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_scheme(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
#if (NGX_HTTP_SSL)

    if (r->connection->ssl) {
        v->len = sizeof(""https"") - 1;
        v->valid = 1;
        v->no_cacheable = 0;
        v->not_found = 0;
        v->data = (u_char *) ""https"";

        return NGX_OK;
    }

#endif

    v->len = sizeof(""http"") - 1;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = (u_char *) ""http"";

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_scheme,,false,1421,1446,ngx_http_variable_scheme,,,95,"ngx_int_t ngx_http_variable_scheme (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
324372,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_https(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
#if (NGX_HTTP_SSL)

    if (r->connection->ssl) {
        v->len = sizeof(""on"") - 1;
        v->valid = 1;
        v->no_cacheable = 0;
        v->not_found = 0;
        v->data = (u_char *) ""on"";

        return NGX_OK;
    }

#endif

    *v = ngx_http_variable_null_value;

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_https,,false,1449,1470,ngx_http_variable_https,,,96,"ngx_int_t ngx_http_variable_https (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
324385,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static void
ngx_http_variable_set_args(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    r->args.len = v->len;
    r->args.data = v->data;
    r->valid_unparsed_uri = 0;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_set_args,,false,1473,1480,ngx_http_variable_set_args,,,97,"void ngx_http_variable_set_args (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
324415,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_is_args(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    if (r->args.len == 0) {
        *v = ngx_http_variable_null_value;
        return NGX_OK;
    }

    v->len = 1;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = (u_char *) ""?"";

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_is_args,,false,1483,1499,ngx_http_variable_is_args,,,98,"ngx_int_t ngx_http_variable_is_args (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
324466,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_document_root(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    ngx_str_t                  path;
    ngx_http_core_loc_conf_t  *clcf;

    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    if (clcf->root_lengths == NULL) {
        v->len = clcf->root.len;
        v->valid = 1;
        v->no_cacheable = 0;
        v->not_found = 0;
        v->data = clcf->root.data;

    } else {
        if (ngx_http_script_run(r, &path, clcf->root_lengths->elts, 0,
                                clcf->root_values->elts)
            == NULL)
        {
            return NGX_ERROR;
        }

        if (ngx_get_full_name(r->pool, (ngx_str_t *) &ngx_cycle->prefix, &path)
            != NGX_OK)
        {
            return NGX_ERROR;
        }

        v->len = path.len;
        v->valid = 1;
        v->no_cacheable = 0;
        v->not_found = 0;
        v->data = path.data;
    }

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_document_root,,false,1502,1540,ngx_http_variable_document_root,,,99,"ngx_int_t ngx_http_variable_document_root (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
324592,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_realpath_root(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    u_char                    *real;
    size_t                     len;
    ngx_str_t                  path;
    ngx_http_core_loc_conf_t  *clcf;
#if (NGX_HAVE_MAX_PATH)
    u_char                     buffer[NGX_MAX_PATH];
#endif

    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    if (clcf->root_lengths == NULL) {
        path = clcf->root;

    } else {
        if (ngx_http_script_run(r, &path, clcf->root_lengths->elts, 1,
                                clcf->root_values->elts)
            == NULL)
        {
            return NGX_ERROR;
        }

        path.data[path.len - 1] = '\0';

        if (ngx_get_full_name(r->pool, (ngx_str_t *) &ngx_cycle->prefix, &path)
            != NGX_OK)
        {
            return NGX_ERROR;
        }
    }

#if (NGX_HAVE_MAX_PATH)
    real = buffer;
#else
    real = NULL;
#endif

    real = ngx_realp...",1,1,http\ngx_http_variables.c,ngx_http_variable_realpath_root,,false,1543,1613,ngx_http_variable_realpath_root,,,100,"ngx_int_t ngx_http_variable_realpath_root (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
324744,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_request_filename(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    size_t     root;
    ngx_str_t  path;

    if (ngx_http_map_uri_to_path(r, &path, &root, 0) == NULL) {
        return NGX_ERROR;
    }

    /* ngx_http_map_uri_to_path() allocates memory for terminating '\0' */

    v->len = path.len - 1;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = path.data;

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_request_filename,,false,1616,1636,ngx_http_variable_request_filename,,,101,"ngx_int_t ngx_http_variable_request_filename (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
324799,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_server_name(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    ngx_http_core_srv_conf_t  *cscf;

    cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);

    v->len = cscf->server_name.len;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = cscf->server_name.data;

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_server_name,,false,1639,1654,ngx_http_variable_server_name,,,102,"ngx_int_t ngx_http_variable_server_name (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
324847,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_request_method(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    if (r->main->method_name.data) {
        v->len = r->main->method_name.len;
        v->valid = 1;
        v->no_cacheable = 0;
        v->not_found = 0;
        v->data = r->main->method_name.data;

    } else {
        v->not_found = 1;
    }

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_request_method,,false,1657,1673,ngx_http_variable_request_method,,,103,"ngx_int_t ngx_http_variable_request_method (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
324909,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_remote_user(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    ngx_int_t  rc;

    rc = ngx_http_auth_basic_user(r);

    if (rc == NGX_DECLINED) {
        v->not_found = 1;
        return NGX_OK;
    }

    if (rc == NGX_ERROR) {
        return NGX_ERROR;
    }

    v->len = r->headers_in.user.len;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = r->headers_in.user.data;

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_remote_user,,false,1676,1700,ngx_http_variable_remote_user,,,104,"ngx_int_t ngx_http_variable_remote_user (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
324979,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_bytes_sent(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    u_char  *p;

    p = ngx_pnalloc(r->pool, NGX_OFF_T_LEN);
    if (p == NULL) {
        return NGX_ERROR;
    }

    v->len = ngx_sprintf(p, ""%O"", r->connection->sent) - p;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = p;

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_bytes_sent,,false,1703,1721,ngx_http_variable_bytes_sent,,,105,"ngx_int_t ngx_http_variable_bytes_sent (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
325037,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_body_bytes_sent(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    off_t    sent;
    u_char  *p;

    sent = r->connection->sent - r->header_size;

    if (sent < 0) {
        sent = 0;
    }

    p = ngx_pnalloc(r->pool, NGX_OFF_T_LEN);
    if (p == NULL) {
        return NGX_ERROR;
    }

    v->len = ngx_sprintf(p, ""%O"", sent) - p;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = p;

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_body_bytes_sent,,false,1724,1749,ngx_http_variable_body_bytes_sent,,,106,"ngx_int_t ngx_http_variable_body_bytes_sent (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
325111,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_pipe(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    v->data = (u_char *) (r->pipeline ? ""p"" : ""."");
    v->len = 1;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_pipe,,false,1752,1763,ngx_http_variable_pipe,,,107,"ngx_int_t ngx_http_variable_pipe (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
325152,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_status(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    ngx_uint_t  status;

    v->data = ngx_pnalloc(r->pool, NGX_INT_T_LEN);
    if (v->data == NULL) {
        return NGX_ERROR;
    }

    if (r->err_status) {
        status = r->err_status;

    } else if (r->headers_out.status) {
        status = r->headers_out.status;

    } else if (r->http_version == NGX_HTTP_VERSION_9) {
        status = 9;

    } else {
        status = 0;
    }

    v->len = ngx_sprintf(v->data, ""%03ui"", status) - v->data;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_status,,false,1766,1796,ngx_http_variable_status,,,108,"ngx_int_t ngx_http_variable_status (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
325252,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_sent_content_type(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    if (r->headers_out.content_type.len) {
        v->len = r->headers_out.content_type.len;
        v->valid = 1;
        v->no_cacheable = 0;
        v->not_found = 0;
        v->data = r->headers_out.content_type.data;

    } else {
        v->not_found = 1;
    }

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_sent_content_type,,false,1799,1815,ngx_http_variable_sent_content_type,,,109,"ngx_int_t ngx_http_variable_sent_content_type (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
325314,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_sent_content_length(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    u_char  *p;

    if (r->headers_out.content_length) {
        v->len = r->headers_out.content_length->value.len;
        v->valid = 1;
        v->no_cacheable = 0;
        v->not_found = 0;
        v->data = r->headers_out.content_length->value.data;

        return NGX_OK;
    }

    if (r->headers_out.content_length_n >= 0) {
        p = ngx_pnalloc(r->pool, NGX_OFF_T_LEN);
        if (p == NULL) {
            return NGX_ERROR;
        }

        v->len = ngx_sprintf(p, ""%O"", r->headers_out.content_length_n) - p;
        v->valid = 1;
        v->no_cacheable = 0;
        v->not_found = 0;
        v->data = p;

        return NGX_OK;
    }

    v->not_found = 1;

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_sent_content_length,,false,1818,1852,ngx_http_variable_sent_content_length,,,110,"ngx_int_t ngx_http_variable_sent_content_length (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
325438,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_sent_location(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    ngx_str_t  name;

    if (r->headers_out.location) {
        v->len = r->headers_out.location->value.len;
        v->valid = 1;
        v->no_cacheable = 0;
        v->not_found = 0;
        v->data = r->headers_out.location->value.data;

        return NGX_OK;
    }

    ngx_str_set(&name, ""sent_http_location"");

    return ngx_http_variable_unknown_header(v, &name,
                                            &r->headers_out.headers.part,
                                            sizeof(""sent_http_"") - 1);
}",1,1,http\ngx_http_variables.c,ngx_http_variable_sent_location,,false,1855,1876,ngx_http_variable_sent_location,,,111,"ngx_int_t ngx_http_variable_sent_location (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
325517,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_sent_last_modified(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    u_char  *p;

    if (r->headers_out.last_modified) {
        v->len = r->headers_out.last_modified->value.len;
        v->valid = 1;
        v->no_cacheable = 0;
        v->not_found = 0;
        v->data = r->headers_out.last_modified->value.data;

        return NGX_OK;
    }

    if (r->headers_out.last_modified_time >= 0) {
        p = ngx_pnalloc(r->pool, sizeof(""Mon, 28 Sep 1970 06:00:00 GMT"") - 1);
        if (p == NULL) {
            return NGX_ERROR;
        }

        v->len = ngx_http_time(p, r->headers_out.last_modified_time) - p;
        v->valid = 1;
        v->no_cacheable = 0;
        v->not_found = 0;
        v->data = p;

        return NGX_OK;
    }

    v->not_found = 1;

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_sent_last_modified,,false,1879,1913,ngx_http_variable_sent_last_modified,,,112,"ngx_int_t ngx_http_variable_sent_last_modified (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
325643,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_sent_connection(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    size_t   len;
    char    *p;

    if (r->headers_out.status == NGX_HTTP_SWITCHING_PROTOCOLS) {
        len = sizeof(""upgrade"") - 1;
        p = ""upgrade"";

    } else if (r->keepalive) {
        len = sizeof(""keep-alive"") - 1;
        p = ""keep-alive"";

    } else {
        len = sizeof(""close"") - 1;
        p = ""close"";
    }

    v->len = len;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = (u_char *) p;

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_sent_connection,,false,1916,1943,ngx_http_variable_sent_connection,,,113,"ngx_int_t ngx_http_variable_sent_connection (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
325726,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_sent_keep_alive(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    u_char                    *p;
    ngx_http_core_loc_conf_t  *clcf;

    if (r->keepalive) {
        clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

        if (clcf->keepalive_header) {

            p = ngx_pnalloc(r->pool, sizeof(""timeout="") - 1 + NGX_TIME_T_LEN);
            if (p == NULL) {
                return NGX_ERROR;
            }

            v->len = ngx_sprintf(p, ""timeout=%T"", clcf->keepalive_header) - p;
            v->valid = 1;
            v->no_cacheable = 0;
            v->not_found = 0;
            v->data = p;

            return NGX_OK;
        }
    }

    v->not_found = 1;

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_sent_keep_alive,,false,1946,1976,ngx_http_variable_sent_keep_alive,,,114,"ngx_int_t ngx_http_variable_sent_keep_alive (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
325810,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_sent_transfer_encoding(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    if (r->chunked) {
        v->len = sizeof(""chunked"") - 1;
        v->valid = 1;
        v->no_cacheable = 0;
        v->not_found = 0;
        v->data = (u_char *) ""chunked"";

    } else {
        v->not_found = 1;
    }

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_sent_transfer_encoding,,false,1979,1995,ngx_http_variable_sent_transfer_encoding,,,115,"ngx_int_t ngx_http_variable_sent_transfer_encoding (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
325861,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static void
ngx_http_variable_set_limit_rate(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    ssize_t    s;
    ngx_str_t  val;

    val.len = v->len;
    val.data = v->data;

    s = ngx_parse_size(&val);

    if (s == NGX_ERROR) {
        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                      ""invalid $limit_rate \""%V\"""", &val);
        return;
    }

    r->limit_rate = s;
    r->limit_rate_set = 1;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_set_limit_rate,,false,1998,2018,ngx_http_variable_set_limit_rate,,,116,"void ngx_http_variable_set_limit_rate (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
325916,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_request_completion(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    if (r->request_complete) {
        v->len = 2;
        v->valid = 1;
        v->no_cacheable = 0;
        v->not_found = 0;
        v->data = (u_char *) ""OK"";

        return NGX_OK;
    }

    *v = ngx_http_variable_null_value;

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_request_completion,,false,2021,2038,ngx_http_variable_request_completion,,,117,"ngx_int_t ngx_http_variable_request_completion (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
325963,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_request_body(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    u_char       *p;
    size_t        len;
    ngx_buf_t    *buf;
    ngx_chain_t  *cl;

    if (r->request_body == NULL
        || r->request_body->bufs == NULL
        || r->request_body->temp_file)
    {
        v->not_found = 1;

        return NGX_OK;
    }

    cl = r->request_body->bufs;
    buf = cl->buf;

    if (cl->next == NULL) {
        v->len = buf->last - buf->pos;
        v->valid = 1;
        v->no_cacheable = 0;
        v->not_found = 0;
        v->data = buf->pos;

        return NGX_OK;
    }

    len = buf->last - buf->pos;
    cl = cl->next;

    for ( /* void */ ; cl; cl = cl->next) {
        buf = cl->buf;
        len += buf->last - buf->pos;
    }

    p = ngx_pnalloc(r->pool, len);
    if (p == NULL) {
        return NGX_ERROR;
    }

    v->data = p;
    cl = r->request_body->bufs;

    for ( /* void */ ; cl; cl = cl->next) {
        ...",1,1,http\ngx_http_variables.c,ngx_http_variable_request_body,,false,2041,2099,ngx_http_variable_request_body,,,118,"ngx_int_t ngx_http_variable_request_body (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
326169,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_request_body_file(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    if (r->request_body == NULL || r->request_body->temp_file == NULL) {
        v->not_found = 1;

        return NGX_OK;
    }

    v->len = r->request_body->temp_file->file.name.len;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = r->request_body->temp_file->file.name.data;

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_request_body_file,,false,2102,2119,ngx_http_variable_request_body_file,,,119,"ngx_int_t ngx_http_variable_request_body_file (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
326245,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_request_length(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    u_char  *p;

    p = ngx_pnalloc(r->pool, NGX_OFF_T_LEN);
    if (p == NULL) {
        return NGX_ERROR;
    }

    v->len = ngx_sprintf(p, ""%O"", r->request_length) - p;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = p;

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_request_length,,false,2122,2140,ngx_http_variable_request_length,,,120,"ngx_int_t ngx_http_variable_request_length (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
326301,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_request_time(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    u_char          *p;
    ngx_time_t      *tp;
    ngx_msec_int_t   ms;

    p = ngx_pnalloc(r->pool, NGX_TIME_T_LEN + 4);
    if (p == NULL) {
        return NGX_ERROR;
    }

    tp = ngx_timeofday();

    ms = (ngx_msec_int_t)
             ((tp->sec - r->start_sec) * 1000 + (tp->msec - r->start_msec));
    ms = ngx_max(ms, 0);

    v->len = ngx_sprintf(p, ""%T.%03M"", (time_t) ms / 1000, ms % 1000) - p;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = p;

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_request_time,,false,2143,2169,ngx_http_variable_request_time,,,121,"ngx_int_t ngx_http_variable_request_time (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
326394,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_request_id(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    u_char  *id;

#if (NGX_OPENSSL)
    u_char   random_bytes[16];
#endif

    id = ngx_pnalloc(r->pool, 32);
    if (id == NULL) {
        return NGX_ERROR;
    }

    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;

    v->len = 32;
    v->data = id;

#if (NGX_OPENSSL)

    if (RAND_bytes(random_bytes, 16) == 1) {
        ngx_hex_dump(id, random_bytes, 16);
        return NGX_OK;
    }

    ngx_ssl_error(NGX_LOG_ERR, r->connection->log, 0, ""RAND_bytes() failed"");

#endif

    ngx_sprintf(id, ""%08xD%08xD%08xD%08xD"",
                (uint32_t) ngx_random(), (uint32_t) ngx_random(),
                (uint32_t) ngx_random(), (uint32_t) ngx_random());

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_request_id,,false,2172,2210,ngx_http_variable_request_id,,,122,"ngx_int_t ngx_http_variable_request_id (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
326458,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_connection(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    u_char  *p;

    p = ngx_pnalloc(r->pool, NGX_ATOMIC_T_LEN);
    if (p == NULL) {
        return NGX_ERROR;
    }

    v->len = ngx_sprintf(p, ""%uA"", r->connection->number) - p;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = p;

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_connection,,false,2213,2231,ngx_http_variable_connection,,,123,"ngx_int_t ngx_http_variable_connection (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
326516,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_connection_requests(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    u_char  *p;

    p = ngx_pnalloc(r->pool, NGX_INT_T_LEN);
    if (p == NULL) {
        return NGX_ERROR;
    }

    v->len = ngx_sprintf(p, ""%ui"", r->connection->requests) - p;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = p;

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_connection_requests,,false,2234,2252,ngx_http_variable_connection_requests,,,124,"ngx_int_t ngx_http_variable_connection_requests (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
326574,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_nginx_version(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    v->len = sizeof(NGINX_VERSION) - 1;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = (u_char *) NGINX_VERSION;

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_nginx_version,,false,2255,2266,ngx_http_variable_nginx_version,,,125,"ngx_int_t ngx_http_variable_nginx_version (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
326613,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_hostname(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    v->len = ngx_cycle->hostname.len;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = ngx_cycle->hostname.data;

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_hostname,,false,2269,2280,ngx_http_variable_hostname,,,126,"ngx_int_t ngx_http_variable_hostname (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
326655,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_pid(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    u_char  *p;

    p = ngx_pnalloc(r->pool, NGX_INT64_LEN);
    if (p == NULL) {
        return NGX_ERROR;
    }

    v->len = ngx_sprintf(p, ""%P"", ngx_pid) - p;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = p;

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_pid,,false,2283,2301,ngx_http_variable_pid,,,127,"ngx_int_t ngx_http_variable_pid (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
326709,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_msec(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    u_char      *p;
    ngx_time_t  *tp;

    p = ngx_pnalloc(r->pool, NGX_TIME_T_LEN + 4);
    if (p == NULL) {
        return NGX_ERROR;
    }

    tp = ngx_timeofday();

    v->len = ngx_sprintf(p, ""%T.%03M"", tp->sec, tp->msec) - p;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = p;

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_msec,,false,2304,2325,ngx_http_variable_msec,,,128,"ngx_int_t ngx_http_variable_msec (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
326774,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_time_iso8601(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    u_char  *p;

    p = ngx_pnalloc(r->pool, ngx_cached_http_log_iso8601.len);
    if (p == NULL) {
        return NGX_ERROR;
    }

    ngx_memcpy(p, ngx_cached_http_log_iso8601.data,
               ngx_cached_http_log_iso8601.len);

    v->len = ngx_cached_http_log_iso8601.len;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = p;

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_time_iso8601,,false,2328,2349,ngx_http_variable_time_iso8601,,,129,"ngx_int_t ngx_http_variable_time_iso8601 (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
326835,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_variable_time_local(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    u_char  *p;

    p = ngx_pnalloc(r->pool, ngx_cached_http_log_time.len);
    if (p == NULL) {
        return NGX_ERROR;
    }

    ngx_memcpy(p, ngx_cached_http_log_time.data, ngx_cached_http_log_time.len);

    v->len = ngx_cached_http_log_time.len;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = p;

    return NGX_OK;
}",1,1,http\ngx_http_variables.c,ngx_http_variable_time_local,,false,2352,2372,ngx_http_variable_time_local,,,130,"ngx_int_t ngx_http_variable_time_local (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
326896,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"void *
ngx_http_map_find(ngx_http_request_t *r, ngx_http_map_t *map, ngx_str_t *match)
{
    void        *value;
    u_char      *low;
    size_t       len;
    ngx_uint_t   key;

    len = match->len;

    if (len) {
        low = ngx_pnalloc(r->pool, len);
        if (low == NULL) {
            return NULL;
        }

    } else {
        low = NULL;
    }

    key = ngx_hash_strlow(low, match->data, len);

    value = ngx_hash_find_combined(&map->hash, key, low, len);
    if (value) {
        return value;
    }

#if (NGX_PCRE)

    if (len && map->nregex) {
        ngx_int_t              n;
        ngx_uint_t             i;
        ngx_http_map_regex_t  *reg;

        reg = map->regex;

        for (i = 0; i < map->nregex; i++) {

            n = ngx_http_regex_exec(r, reg[i].regex, match);

            if (n == NGX_OK) {
                return reg[i].value;
            }

            if (n == NGX_DECLINED) {
                continue;
            }

            /* NGX_ERROR */

...",1,1,http\ngx_http_variables.c,ngx_http_map_find,,false,2375,2432,ngx_http_map_find,,,131,"void* ngx_http_map_find (ngx_http_request_t*,ngx_http_map_t*,ngx_str_t*)"
326959,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_variables_add_core_vars(ngx_conf_t *cf)
{
    ngx_http_variable_t        *cv, *v;
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);

    cmcf->variables_keys = ngx_pcalloc(cf->temp_pool,
                                       sizeof(ngx_hash_keys_arrays_t));
    if (cmcf->variables_keys == NULL) {
        return NGX_ERROR;
    }

    cmcf->variables_keys->pool = cf->pool;
    cmcf->variables_keys->temp_pool = cf->pool;

    if (ngx_hash_keys_array_init(cmcf->variables_keys, NGX_HASH_SMALL)
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    if (ngx_array_init(&cmcf->prefix_variables, cf->pool, 8,
                       sizeof(ngx_http_variable_t))
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    for (cv = ngx_http_core_variables; cv->name.len; cv++) {
        v = ngx_http_add_variable(cf, &cv->name, cv->flags);
        if (v == NULL) {
            return NGX_ERROR;
        }

    ...",1,1,http\ngx_http_variables.c,ngx_http_variables_add_core_vars,,false,2591,2631,ngx_http_variables_add_core_vars,,,132,ngx_int_t ngx_http_variables_add_core_vars (ngx_conf_t*)
327075,METHOD,http\ngx_http_variables.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_variables_init_vars(ngx_conf_t *cf)
{
    size_t                      len;
    ngx_uint_t                  i, n;
    ngx_hash_key_t             *key;
    ngx_hash_init_t             hash;
    ngx_http_variable_t        *v, *av, *pv;
    ngx_http_core_main_conf_t  *cmcf;

    /* set the handlers for the indexed http variables */

    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);

    v = cmcf->variables.elts;
    pv = cmcf->prefix_variables.elts;
    key = cmcf->variables_keys->keys.elts;

    for (i = 0; i < cmcf->variables.nelts; i++) {

        for (n = 0; n < cmcf->variables_keys->keys.nelts; n++) {

            av = key[n].value;

            if (v[i].name.len == key[n].key.len
                && ngx_strncmp(v[i].name.data, key[n].key.data, v[i].name.len)
                   == 0)
            {
                v[i].get_handler = av->get_handler;
                v[i].data = av->data;

                av->flags |= NGX_HTTP_VAR_INDEXED;
    ...",1,1,http\ngx_http_variables.c,ngx_http_variables_init_vars,,false,2634,2740,ngx_http_variables_init_vars,,,133,ngx_int_t ngx_http_variables_init_vars (ngx_conf_t*)
327522,METHOD,http\ngx_http_variables.h:<global>,TYPE_DECL,<global>,1,44,http\ngx_http_variables.h,http\ngx_http_variables.h:<global>,,false,1,116,<global>,,,1,
327527,METHOD,http\ngx_http_variables.h:<global>,TYPE_DECL,"typedef void (*ngx_http_set_variable_pt) (ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",14,49,http\ngx_http_variables.h,ngx_http_set_variable_pt,,false,23,24,ngx_http_set_variable_pt,,,4,"void ngx_http_set_variable_pt (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
327534,METHOD,http\ngx_http_variables.h:<global>,TYPE_DECL,"typedef ngx_int_t (*ngx_http_get_variable_pt) (ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",19,49,http\ngx_http_variables.h,ngx_http_get_variable_pt,,false,25,26,ngx_http_get_variable_pt,,,5,"ngx_int_t ngx_http_get_variable_pt (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
327548,METHOD,http\ngx_http_variables.h:<global>,TYPE_DECL,"ngx_http_variable_t *ngx_http_add_variable(ngx_conf_t *cf, ngx_str_t *name,
    ngx_uint_t flags);",21,21,http\ngx_http_variables.h,ngx_http_add_variable,,false,49,50,ngx_http_add_variable,,,7,"ngx_http_variable_t* ngx_http_add_variable (ngx_conf_t*,ngx_str_t*,ngx_uint_t)"
327555,METHOD,http\ngx_http_variables.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_get_variable_index(ngx_conf_t *cf, ngx_str_t *name);",11,70,http\ngx_http_variables.h,ngx_http_get_variable_index,,false,51,51,ngx_http_get_variable_index,,,8,"ngx_int_t ngx_http_get_variable_index (ngx_conf_t*,ngx_str_t*)"
327561,METHOD,http\ngx_http_variables.h:<global>,TYPE_DECL,"ngx_http_variable_value_t *ngx_http_get_indexed_variable(ngx_http_request_t *r,
    ngx_uint_t index);",27,21,http\ngx_http_variables.h,ngx_http_get_indexed_variable,,false,52,53,ngx_http_get_indexed_variable,,,9,"ngx_http_variable_value_t* ngx_http_get_indexed_variable (ngx_http_request_t*,ngx_uint_t)"
327567,METHOD,http\ngx_http_variables.h:<global>,TYPE_DECL,"ngx_http_variable_value_t *ngx_http_get_flushed_variable(ngx_http_request_t *r,
    ngx_uint_t index);",27,21,http\ngx_http_variables.h,ngx_http_get_flushed_variable,,false,54,55,ngx_http_get_flushed_variable,,,10,"ngx_http_variable_value_t* ngx_http_get_flushed_variable (ngx_http_request_t*,ngx_uint_t)"
327573,METHOD,http\ngx_http_variables.h:<global>,TYPE_DECL,"ngx_http_variable_value_t *ngx_http_get_variable(ngx_http_request_t *r,
    ngx_str_t *name, ngx_uint_t key);",27,36,http\ngx_http_variables.h,ngx_http_get_variable,,false,57,58,ngx_http_get_variable,,,11,"ngx_http_variable_value_t* ngx_http_get_variable (ngx_http_request_t*,ngx_str_t*,ngx_uint_t)"
327580,METHOD,http\ngx_http_variables.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_variable_unknown_header(ngx_http_variable_value_t *v,
    ngx_str_t *var, ngx_list_part_t *part, size_t prefix);",11,57,http\ngx_http_variables.h,ngx_http_variable_unknown_header,,false,60,61,ngx_http_variable_unknown_header,,,12,"ngx_int_t ngx_http_variable_unknown_header (ngx_http_variable_value_t*,ngx_str_t*,ngx_list_part_t*,size_t)"
327593,METHOD,http\ngx_http_variables.h:<global>,TYPE_DECL,"void *ngx_http_map_find(ngx_http_request_t *r, ngx_http_map_t *map,
    ngx_str_t *match);",6,21,http\ngx_http_variables.h,ngx_http_map_find,,false,104,105,ngx_http_map_find,,,15,"void* ngx_http_map_find (ngx_http_request_t*,ngx_http_map_t*,ngx_str_t*)"
327600,METHOD,http\ngx_http_variables.h:<global>,TYPE_DECL,ngx_int_t ngx_http_variables_add_core_vars(ngx_conf_t *cf);,11,58,http\ngx_http_variables.h,ngx_http_variables_add_core_vars,,false,108,108,ngx_http_variables_add_core_vars,,,16,ngx_int_t ngx_http_variables_add_core_vars (ngx_conf_t*)
327605,METHOD,http\ngx_http_variables.h:<global>,TYPE_DECL,ngx_int_t ngx_http_variables_init_vars(ngx_conf_t *cf);,11,54,http\ngx_http_variables.h,ngx_http_variables_init_vars,,false,109,109,ngx_http_variables_init_vars,,,17,ngx_int_t ngx_http_variables_init_vars (ngx_conf_t*)
327621,METHOD,http\ngx_http_write_filter_module.c:<global>,TYPE_DECL,<global>,1,1,http\ngx_http_write_filter_module.c,http\ngx_http_write_filter_module.c:<global>,,false,1,367,<global>,,,1,
327623,METHOD,http\ngx_http_write_filter_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_write_filter_init(ngx_conf_t *cf);,18,59,http\ngx_http_write_filter_module.c,ngx_http_write_filter_init,,false,13,13,ngx_http_write_filter_init,,,1,ngx_int_t ngx_http_write_filter_init (ngx_conf_t*)
327657,METHOD,http\ngx_http_write_filter_module.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_write_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    off_t                      size, sent, nsent, limit;
    ngx_uint_t                 last, flush, sync;
    ngx_msec_t                 delay;
    ngx_chain_t               *cl, *ln, **ll, *chain;
    ngx_connection_t          *c;
    ngx_http_core_loc_conf_t  *clcf;

    c = r->connection;

    if (c->error) {
        return NGX_ERROR;
    }

    size = 0;
    flush = 0;
    sync = 0;
    last = 0;
    ll = &r->out;

    /* find the size, the flush point and the last link of the saved chain */

    for (cl = r->out; cl; cl = cl->next) {
        ll = &cl->next;

        ngx_log_debug7(NGX_LOG_DEBUG_EVENT, c->log, 0,
                       ""write old buf t:%d f:%d %p, pos %p, size: %z ""
                       ""file: %O, size: %O"",
                       cl->buf->temporary, cl->buf->in_file,
                       cl->buf->start, cl->buf->pos,
                       cl->buf->last - cl->buf->pos,
              ...",1,1,http\ngx_http_write_filter_module.c,ngx_http_write_filter,,false,47,358,ngx_http_write_filter,,,6,"ngx_int_t ngx_http_write_filter (ngx_http_request_t*,ngx_chain_t*)"
328695,METHOD,http\ngx_http_write_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_write_filter_init(ngx_conf_t *cf)
{
    ngx_http_top_body_filter = ngx_http_write_filter;

    return NGX_OK;
}",1,1,http\ngx_http_write_filter_module.c,ngx_http_write_filter_init,,false,361,367,ngx_http_write_filter_init,,,7,ngx_int_t ngx_http_write_filter_init (ngx_conf_t*)
328716,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,<global>,1,46,http\v2\ngx_http_v2.c,http\v2\ngx_http_v2.c:<global>,,false,1,4793,<global>,,,1,
328724,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,static void ngx_http_v2_read_handler(ngx_event_t *rev);,13,54,http\v2\ngx_http_v2.c,ngx_http_v2_read_handler,,false,60,60,ngx_http_v2_read_handler,,,3,void ngx_http_v2_read_handler (ngx_event_t*)
328729,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,static void ngx_http_v2_write_handler(ngx_event_t *wev);,13,55,http\v2\ngx_http_v2.c,ngx_http_v2_write_handler,,false,61,61,ngx_http_v2_write_handler,,,4,void ngx_http_v2_write_handler (ngx_event_t*)
328734,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,static void ngx_http_v2_handle_connection(ngx_http_v2_connection_t *h2c);,13,72,http\v2\ngx_http_v2.c,ngx_http_v2_handle_connection,,false,62,62,ngx_http_v2_handle_connection,,,5,void ngx_http_v2_handle_connection (ngx_http_v2_connection_t*)
328739,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *ngx_http_v2_state_proxy_protocol(ngx_http_v2_connection_t *h2c,
    u_char *pos, u_char *end);",15,29,http\v2\ngx_http_v2.c,ngx_http_v2_state_proxy_protocol,,false,64,65,ngx_http_v2_state_proxy_protocol,,,6,"u_char* ngx_http_v2_state_proxy_protocol (ngx_http_v2_connection_t*,u_char*,u_char*)"
328746,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *ngx_http_v2_state_preface(ngx_http_v2_connection_t *h2c,
    u_char *pos, u_char *end);",15,29,http\v2\ngx_http_v2.c,ngx_http_v2_state_preface,,false,66,67,ngx_http_v2_state_preface,,,7,"u_char* ngx_http_v2_state_preface (ngx_http_v2_connection_t*,u_char*,u_char*)"
328753,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *ngx_http_v2_state_preface_end(ngx_http_v2_connection_t *h2c,
    u_char *pos, u_char *end);",15,29,http\v2\ngx_http_v2.c,ngx_http_v2_state_preface_end,,false,68,69,ngx_http_v2_state_preface_end,,,8,"u_char* ngx_http_v2_state_preface_end (ngx_http_v2_connection_t*,u_char*,u_char*)"
328760,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *ngx_http_v2_state_head(ngx_http_v2_connection_t *h2c,
    u_char *pos, u_char *end);",15,29,http\v2\ngx_http_v2.c,ngx_http_v2_state_head,,false,70,71,ngx_http_v2_state_head,,,9,"u_char* ngx_http_v2_state_head (ngx_http_v2_connection_t*,u_char*,u_char*)"
328767,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *ngx_http_v2_state_data(ngx_http_v2_connection_t *h2c,
    u_char *pos, u_char *end);",15,29,http\v2\ngx_http_v2.c,ngx_http_v2_state_data,,false,72,73,ngx_http_v2_state_data,,,10,"u_char* ngx_http_v2_state_data (ngx_http_v2_connection_t*,u_char*,u_char*)"
328774,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *ngx_http_v2_state_read_data(ngx_http_v2_connection_t *h2c,
    u_char *pos, u_char *end);",15,29,http\v2\ngx_http_v2.c,ngx_http_v2_state_read_data,,false,74,75,ngx_http_v2_state_read_data,,,11,"u_char* ngx_http_v2_state_read_data (ngx_http_v2_connection_t*,u_char*,u_char*)"
328781,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *ngx_http_v2_state_headers(ngx_http_v2_connection_t *h2c,
    u_char *pos, u_char *end);",15,29,http\v2\ngx_http_v2.c,ngx_http_v2_state_headers,,false,76,77,ngx_http_v2_state_headers,,,12,"u_char* ngx_http_v2_state_headers (ngx_http_v2_connection_t*,u_char*,u_char*)"
328788,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *ngx_http_v2_state_header_block(ngx_http_v2_connection_t *h2c,
    u_char *pos, u_char *end);",15,29,http\v2\ngx_http_v2.c,ngx_http_v2_state_header_block,,false,78,79,ngx_http_v2_state_header_block,,,13,"u_char* ngx_http_v2_state_header_block (ngx_http_v2_connection_t*,u_char*,u_char*)"
328795,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *ngx_http_v2_state_field_len(ngx_http_v2_connection_t *h2c,
    u_char *pos, u_char *end);",15,29,http\v2\ngx_http_v2.c,ngx_http_v2_state_field_len,,false,80,81,ngx_http_v2_state_field_len,,,14,"u_char* ngx_http_v2_state_field_len (ngx_http_v2_connection_t*,u_char*,u_char*)"
328802,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *ngx_http_v2_state_field_huff(ngx_http_v2_connection_t *h2c,
    u_char *pos, u_char *end);",15,29,http\v2\ngx_http_v2.c,ngx_http_v2_state_field_huff,,false,82,83,ngx_http_v2_state_field_huff,,,15,"u_char* ngx_http_v2_state_field_huff (ngx_http_v2_connection_t*,u_char*,u_char*)"
328809,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *ngx_http_v2_state_field_raw(ngx_http_v2_connection_t *h2c,
    u_char *pos, u_char *end);",15,29,http\v2\ngx_http_v2.c,ngx_http_v2_state_field_raw,,false,84,85,ngx_http_v2_state_field_raw,,,16,"u_char* ngx_http_v2_state_field_raw (ngx_http_v2_connection_t*,u_char*,u_char*)"
328816,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *ngx_http_v2_state_field_skip(ngx_http_v2_connection_t *h2c,
    u_char *pos, u_char *end);",15,29,http\v2\ngx_http_v2.c,ngx_http_v2_state_field_skip,,false,86,87,ngx_http_v2_state_field_skip,,,17,"u_char* ngx_http_v2_state_field_skip (ngx_http_v2_connection_t*,u_char*,u_char*)"
328823,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *ngx_http_v2_state_process_header(ngx_http_v2_connection_t *h2c,
    u_char *pos, u_char *end);",15,29,http\v2\ngx_http_v2.c,ngx_http_v2_state_process_header,,false,88,89,ngx_http_v2_state_process_header,,,18,"u_char* ngx_http_v2_state_process_header (ngx_http_v2_connection_t*,u_char*,u_char*)"
328830,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *ngx_http_v2_state_header_complete(ngx_http_v2_connection_t *h2c,
    u_char *pos, u_char *end);",15,29,http\v2\ngx_http_v2.c,ngx_http_v2_state_header_complete,,false,90,91,ngx_http_v2_state_header_complete,,,19,"u_char* ngx_http_v2_state_header_complete (ngx_http_v2_connection_t*,u_char*,u_char*)"
328837,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *ngx_http_v2_handle_continuation(ngx_http_v2_connection_t *h2c,
    u_char *pos, u_char *end, ngx_http_v2_handler_pt handler);",15,61,http\v2\ngx_http_v2.c,ngx_http_v2_handle_continuation,,false,92,93,ngx_http_v2_handle_continuation,,,20,"u_char* ngx_http_v2_handle_continuation (ngx_http_v2_connection_t*,u_char*,u_char*,ngx_http_v2_handler_pt)"
328845,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *ngx_http_v2_state_priority(ngx_http_v2_connection_t *h2c,
    u_char *pos, u_char *end);",15,29,http\v2\ngx_http_v2.c,ngx_http_v2_state_priority,,false,94,95,ngx_http_v2_state_priority,,,21,"u_char* ngx_http_v2_state_priority (ngx_http_v2_connection_t*,u_char*,u_char*)"
328852,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *ngx_http_v2_state_rst_stream(ngx_http_v2_connection_t *h2c,
    u_char *pos, u_char *end);",15,29,http\v2\ngx_http_v2.c,ngx_http_v2_state_rst_stream,,false,96,97,ngx_http_v2_state_rst_stream,,,22,"u_char* ngx_http_v2_state_rst_stream (ngx_http_v2_connection_t*,u_char*,u_char*)"
328859,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *ngx_http_v2_state_settings(ngx_http_v2_connection_t *h2c,
    u_char *pos, u_char *end);",15,29,http\v2\ngx_http_v2.c,ngx_http_v2_state_settings,,false,98,99,ngx_http_v2_state_settings,,,23,"u_char* ngx_http_v2_state_settings (ngx_http_v2_connection_t*,u_char*,u_char*)"
328866,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *ngx_http_v2_state_settings_params(ngx_http_v2_connection_t *h2c,
    u_char *pos, u_char *end);",15,29,http\v2\ngx_http_v2.c,ngx_http_v2_state_settings_params,,false,100,101,ngx_http_v2_state_settings_params,,,24,"u_char* ngx_http_v2_state_settings_params (ngx_http_v2_connection_t*,u_char*,u_char*)"
328873,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *ngx_http_v2_state_push_promise(ngx_http_v2_connection_t *h2c,
    u_char *pos, u_char *end);",15,29,http\v2\ngx_http_v2.c,ngx_http_v2_state_push_promise,,false,102,103,ngx_http_v2_state_push_promise,,,25,"u_char* ngx_http_v2_state_push_promise (ngx_http_v2_connection_t*,u_char*,u_char*)"
328880,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *ngx_http_v2_state_ping(ngx_http_v2_connection_t *h2c,
    u_char *pos, u_char *end);",15,29,http\v2\ngx_http_v2.c,ngx_http_v2_state_ping,,false,104,105,ngx_http_v2_state_ping,,,26,"u_char* ngx_http_v2_state_ping (ngx_http_v2_connection_t*,u_char*,u_char*)"
328887,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *ngx_http_v2_state_goaway(ngx_http_v2_connection_t *h2c,
    u_char *pos, u_char *end);",15,29,http\v2\ngx_http_v2.c,ngx_http_v2_state_goaway,,false,106,107,ngx_http_v2_state_goaway,,,27,"u_char* ngx_http_v2_state_goaway (ngx_http_v2_connection_t*,u_char*,u_char*)"
328894,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *ngx_http_v2_state_window_update(ngx_http_v2_connection_t *h2c,
    u_char *pos, u_char *end);",15,29,http\v2\ngx_http_v2.c,ngx_http_v2_state_window_update,,false,108,109,ngx_http_v2_state_window_update,,,28,"u_char* ngx_http_v2_state_window_update (ngx_http_v2_connection_t*,u_char*,u_char*)"
328901,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *ngx_http_v2_state_continuation(ngx_http_v2_connection_t *h2c,
    u_char *pos, u_char *end);",15,29,http\v2\ngx_http_v2.c,ngx_http_v2_state_continuation,,false,110,111,ngx_http_v2_state_continuation,,,29,"u_char* ngx_http_v2_state_continuation (ngx_http_v2_connection_t*,u_char*,u_char*)"
328908,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *ngx_http_v2_state_complete(ngx_http_v2_connection_t *h2c,
    u_char *pos, u_char *end);",15,29,http\v2\ngx_http_v2.c,ngx_http_v2_state_complete,,false,112,113,ngx_http_v2_state_complete,,,30,"u_char* ngx_http_v2_state_complete (ngx_http_v2_connection_t*,u_char*,u_char*)"
328915,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *ngx_http_v2_state_skip_padded(ngx_http_v2_connection_t *h2c,
    u_char *pos, u_char *end);",15,29,http\v2\ngx_http_v2.c,ngx_http_v2_state_skip_padded,,false,114,115,ngx_http_v2_state_skip_padded,,,31,"u_char* ngx_http_v2_state_skip_padded (ngx_http_v2_connection_t*,u_char*,u_char*)"
328922,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *ngx_http_v2_state_skip(ngx_http_v2_connection_t *h2c,
    u_char *pos, u_char *end);",15,29,http\v2\ngx_http_v2.c,ngx_http_v2_state_skip,,false,116,117,ngx_http_v2_state_skip,,,32,"u_char* ngx_http_v2_state_skip (ngx_http_v2_connection_t*,u_char*,u_char*)"
328929,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *ngx_http_v2_state_save(ngx_http_v2_connection_t *h2c,
    u_char *pos, u_char *end, ngx_http_v2_handler_pt handler);",15,61,http\v2\ngx_http_v2.c,ngx_http_v2_state_save,,false,118,119,ngx_http_v2_state_save,,,33,"u_char* ngx_http_v2_state_save (ngx_http_v2_connection_t*,u_char*,u_char*,ngx_http_v2_handler_pt)"
328937,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *ngx_http_v2_state_headers_save(ngx_http_v2_connection_t *h2c,
    u_char *pos, u_char *end, ngx_http_v2_handler_pt handler);",15,61,http\v2\ngx_http_v2.c,ngx_http_v2_state_headers_save,,false,120,121,ngx_http_v2_state_headers_save,,,34,"u_char* ngx_http_v2_state_headers_save (ngx_http_v2_connection_t*,u_char*,u_char*,ngx_http_v2_handler_pt)"
328945,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *ngx_http_v2_connection_error(ngx_http_v2_connection_t *h2c,
    ngx_uint_t err);",15,19,http\v2\ngx_http_v2.c,ngx_http_v2_connection_error,,false,122,123,ngx_http_v2_connection_error,,,35,"u_char* ngx_http_v2_connection_error (ngx_http_v2_connection_t*,ngx_uint_t)"
328951,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_v2_parse_int(ngx_http_v2_connection_t *h2c,
    u_char **pos, u_char *end, ngx_uint_t prefix);",18,49,http\v2\ngx_http_v2.c,ngx_http_v2_parse_int,,false,125,126,ngx_http_v2_parse_int,,,36,"ngx_int_t ngx_http_v2_parse_int (ngx_http_v2_connection_t*,u_char**,u_char*,ngx_uint_t)"
328959,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_http_v2_stream_t *ngx_http_v2_create_stream(
    ngx_http_v2_connection_t *h2c, ngx_uint_t push);",29,51,http\v2\ngx_http_v2.c,ngx_http_v2_create_stream,,false,128,129,ngx_http_v2_create_stream,,,37,"ngx_http_v2_stream_t* ngx_http_v2_create_stream (ngx_http_v2_connection_t*,ngx_uint_t)"
328965,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_http_v2_node_t *ngx_http_v2_get_node_by_id(
    ngx_http_v2_connection_t *h2c, ngx_uint_t sid, ngx_uint_t alloc);",27,68,http\v2\ngx_http_v2.c,ngx_http_v2_get_node_by_id,,false,130,131,ngx_http_v2_get_node_by_id,,,38,"ngx_http_v2_node_t* ngx_http_v2_get_node_by_id (ngx_http_v2_connection_t*,ngx_uint_t,ngx_uint_t)"
328972,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_http_v2_node_t *ngx_http_v2_get_closed_node(
    ngx_http_v2_connection_t *h2c);",27,34,http\v2\ngx_http_v2.c,ngx_http_v2_get_closed_node,,false,132,133,ngx_http_v2_get_closed_node,,,39,ngx_http_v2_node_t* ngx_http_v2_get_closed_node (ngx_http_v2_connection_t*)
328977,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_v2_send_settings(ngx_http_v2_connection_t *h2c);,18,73,http\v2\ngx_http_v2.c,ngx_http_v2_send_settings,,false,137,137,ngx_http_v2_send_settings,,,40,ngx_int_t ngx_http_v2_send_settings (ngx_http_v2_connection_t*)
328982,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_v2_settings_frame_handler(
    ngx_http_v2_connection_t *h2c, ngx_http_v2_out_frame_t *frame);",18,66,http\v2\ngx_http_v2.c,ngx_http_v2_settings_frame_handler,,false,138,139,ngx_http_v2_settings_frame_handler,,,41,"ngx_int_t ngx_http_v2_settings_frame_handler (ngx_http_v2_connection_t*,ngx_http_v2_out_frame_t*)"
328988,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_v2_send_window_update(ngx_http_v2_connection_t *h2c,
    ngx_uint_t sid, size_t window);",18,34,http\v2\ngx_http_v2.c,ngx_http_v2_send_window_update,,false,140,141,ngx_http_v2_send_window_update,,,42,"ngx_int_t ngx_http_v2_send_window_update (ngx_http_v2_connection_t*,ngx_uint_t,size_t)"
328995,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_v2_send_rst_stream(ngx_http_v2_connection_t *h2c,
    ngx_uint_t sid, ngx_uint_t status);",18,38,http\v2\ngx_http_v2.c,ngx_http_v2_send_rst_stream,,false,142,143,ngx_http_v2_send_rst_stream,,,43,"ngx_int_t ngx_http_v2_send_rst_stream (ngx_http_v2_connection_t*,ngx_uint_t,ngx_uint_t)"
329002,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_v2_send_goaway(ngx_http_v2_connection_t *h2c,
    ngx_uint_t status);",18,22,http\v2\ngx_http_v2.c,ngx_http_v2_send_goaway,,false,144,145,ngx_http_v2_send_goaway,,,44,"ngx_int_t ngx_http_v2_send_goaway (ngx_http_v2_connection_t*,ngx_uint_t)"
329008,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_http_v2_out_frame_t *ngx_http_v2_get_frame(
    ngx_http_v2_connection_t *h2c, size_t length, ngx_uint_t type,
    u_char flags, ngx_uint_t sid);",32,33,http\v2\ngx_http_v2.c,ngx_http_v2_get_frame,,false,147,149,ngx_http_v2_get_frame,,,45,"ngx_http_v2_out_frame_t* ngx_http_v2_get_frame (ngx_http_v2_connection_t*,size_t,ngx_uint_t,u_char,ngx_uint_t)"
329017,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_v2_frame_handler(ngx_http_v2_connection_t *h2c,
    ngx_http_v2_out_frame_t *frame);",18,35,http\v2\ngx_http_v2.c,ngx_http_v2_frame_handler,,false,150,151,ngx_http_v2_frame_handler,,,46,"ngx_int_t ngx_http_v2_frame_handler (ngx_http_v2_connection_t*,ngx_http_v2_out_frame_t*)"
329023,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_v2_validate_header(ngx_http_request_t *r,
    ngx_http_v2_header_t *header);",18,33,http\v2\ngx_http_v2.c,ngx_http_v2_validate_header,,false,153,154,ngx_http_v2_validate_header,,,47,"ngx_int_t ngx_http_v2_validate_header (ngx_http_request_t*,ngx_http_v2_header_t*)"
329029,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_v2_pseudo_header(ngx_http_request_t *r,
    ngx_http_v2_header_t *header);",18,33,http\v2\ngx_http_v2.c,ngx_http_v2_pseudo_header,,false,155,156,ngx_http_v2_pseudo_header,,,48,"ngx_int_t ngx_http_v2_pseudo_header (ngx_http_request_t*,ngx_http_v2_header_t*)"
329035,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_v2_parse_path(ngx_http_request_t *r,
    ngx_str_t *value);",18,21,http\v2\ngx_http_v2.c,ngx_http_v2_parse_path,,false,157,158,ngx_http_v2_parse_path,,,49,"ngx_int_t ngx_http_v2_parse_path (ngx_http_request_t*,ngx_str_t*)"
329041,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_v2_parse_method(ngx_http_request_t *r,
    ngx_str_t *value);",18,21,http\v2\ngx_http_v2.c,ngx_http_v2_parse_method,,false,159,160,ngx_http_v2_parse_method,,,50,"ngx_int_t ngx_http_v2_parse_method (ngx_http_request_t*,ngx_str_t*)"
329047,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_v2_parse_scheme(ngx_http_request_t *r,
    ngx_str_t *value);",18,21,http\v2\ngx_http_v2.c,ngx_http_v2_parse_scheme,,false,161,162,ngx_http_v2_parse_scheme,,,51,"ngx_int_t ngx_http_v2_parse_scheme (ngx_http_request_t*,ngx_str_t*)"
329053,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_v2_parse_authority(ngx_http_request_t *r,
    ngx_str_t *value);",18,21,http\v2\ngx_http_v2.c,ngx_http_v2_parse_authority,,false,163,164,ngx_http_v2_parse_authority,,,52,"ngx_int_t ngx_http_v2_parse_authority (ngx_http_request_t*,ngx_str_t*)"
329059,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_v2_parse_header(ngx_http_request_t *r,
    ngx_http_v2_parse_header_t *header, ngx_str_t *value);",18,57,http\v2\ngx_http_v2.c,ngx_http_v2_parse_header,,false,165,166,ngx_http_v2_parse_header,,,53,"ngx_int_t ngx_http_v2_parse_header (ngx_http_request_t*,ngx_http_v2_parse_header_t*,ngx_str_t*)"
329066,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_v2_construct_request_line(ngx_http_request_t *r);,18,74,http\v2\ngx_http_v2.c,ngx_http_v2_construct_request_line,,false,167,167,ngx_http_v2_construct_request_line,,,54,ngx_int_t ngx_http_v2_construct_request_line (ngx_http_request_t*)
329071,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_v2_cookie(ngx_http_request_t *r,
    ngx_http_v2_header_t *header);",18,33,http\v2\ngx_http_v2.c,ngx_http_v2_cookie,,false,168,169,ngx_http_v2_cookie,,,55,"ngx_int_t ngx_http_v2_cookie (ngx_http_request_t*,ngx_http_v2_header_t*)"
329077,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_v2_construct_cookie_header(ngx_http_request_t *r);,18,75,http\v2\ngx_http_v2.c,ngx_http_v2_construct_cookie_header,,false,170,170,ngx_http_v2_construct_cookie_header,,,56,ngx_int_t ngx_http_v2_construct_cookie_header (ngx_http_request_t*)
329082,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,static void ngx_http_v2_run_request(ngx_http_request_t *r);,13,58,http\v2\ngx_http_v2.c,ngx_http_v2_run_request,,false,171,171,ngx_http_v2_run_request,,,57,void ngx_http_v2_run_request (ngx_http_request_t*)
329087,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,static void ngx_http_v2_run_request_handler(ngx_event_t *ev);,13,60,http\v2\ngx_http_v2.c,ngx_http_v2_run_request_handler,,false,172,172,ngx_http_v2_run_request_handler,,,58,void ngx_http_v2_run_request_handler (ngx_event_t*)
329092,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_v2_process_request_body(ngx_http_request_t *r,
    u_char *pos, size_t size, ngx_uint_t last);",18,46,http\v2\ngx_http_v2.c,ngx_http_v2_process_request_body,,false,173,174,ngx_http_v2_process_request_body,,,59,"ngx_int_t ngx_http_v2_process_request_body (ngx_http_request_t*,u_char*,size_t,ngx_uint_t)"
329100,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_v2_filter_request_body(ngx_http_request_t *r);,18,71,http\v2\ngx_http_v2.c,ngx_http_v2_filter_request_body,,false,175,175,ngx_http_v2_filter_request_body,,,60,ngx_int_t ngx_http_v2_filter_request_body (ngx_http_request_t*)
329105,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,static void ngx_http_v2_read_client_request_body_handler(ngx_http_request_t *r);,13,79,http\v2\ngx_http_v2.c,ngx_http_v2_read_client_request_body_handler,,false,176,176,ngx_http_v2_read_client_request_body_handler,,,61,void ngx_http_v2_read_client_request_body_handler (ngx_http_request_t*)
329110,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_v2_terminate_stream(ngx_http_v2_connection_t *h2c,
    ngx_http_v2_stream_t *stream, ngx_uint_t status);",18,52,http\v2\ngx_http_v2.c,ngx_http_v2_terminate_stream,,false,178,179,ngx_http_v2_terminate_stream,,,62,"ngx_int_t ngx_http_v2_terminate_stream (ngx_http_v2_connection_t*,ngx_http_v2_stream_t*,ngx_uint_t)"
329117,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,static void ngx_http_v2_close_stream_handler(ngx_event_t *ev);,13,61,http\v2\ngx_http_v2.c,ngx_http_v2_close_stream_handler,,false,180,180,ngx_http_v2_close_stream_handler,,,63,void ngx_http_v2_close_stream_handler (ngx_event_t*)
329122,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,static void ngx_http_v2_retry_close_stream_handler(ngx_event_t *ev);,13,67,http\v2\ngx_http_v2.c,ngx_http_v2_retry_close_stream_handler,,false,181,181,ngx_http_v2_retry_close_stream_handler,,,64,void ngx_http_v2_retry_close_stream_handler (ngx_event_t*)
329127,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,static void ngx_http_v2_handle_connection_handler(ngx_event_t *rev);,13,67,http\v2\ngx_http_v2.c,ngx_http_v2_handle_connection_handler,,false,182,182,ngx_http_v2_handle_connection_handler,,,65,void ngx_http_v2_handle_connection_handler (ngx_event_t*)
329132,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,static void ngx_http_v2_idle_handler(ngx_event_t *rev);,13,54,http\v2\ngx_http_v2.c,ngx_http_v2_idle_handler,,false,183,183,ngx_http_v2_idle_handler,,,66,void ngx_http_v2_idle_handler (ngx_event_t*)
329137,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static void ngx_http_v2_finalize_connection(ngx_http_v2_connection_t *h2c,
    ngx_uint_t status);",13,22,http\v2\ngx_http_v2.c,ngx_http_v2_finalize_connection,,false,184,185,ngx_http_v2_finalize_connection,,,67,"void ngx_http_v2_finalize_connection (ngx_http_v2_connection_t*,ngx_uint_t)"
329143,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_v2_adjust_windows(ngx_http_v2_connection_t *h2c,
    ssize_t delta);",18,18,http\v2\ngx_http_v2.c,ngx_http_v2_adjust_windows,,false,187,188,ngx_http_v2_adjust_windows,,,68,"ngx_int_t ngx_http_v2_adjust_windows (ngx_http_v2_connection_t*,ssize_t)"
329149,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static void ngx_http_v2_set_dependency(ngx_http_v2_connection_t *h2c,
    ngx_http_v2_node_t *node, ngx_uint_t depend, ngx_uint_t exclusive);",13,70,http\v2\ngx_http_v2.c,ngx_http_v2_set_dependency,,false,189,190,ngx_http_v2_set_dependency,,,69,"void ngx_http_v2_set_dependency (ngx_http_v2_connection_t*,ngx_http_v2_node_t*,ngx_uint_t,ngx_uint_t)"
329157,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,static void ngx_http_v2_node_children_update(ngx_http_v2_node_t *node);,13,70,http\v2\ngx_http_v2.c,ngx_http_v2_node_children_update,,false,191,191,ngx_http_v2_node_children_update,,,70,void ngx_http_v2_node_children_update (ngx_http_v2_node_t*)
329162,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,static void ngx_http_v2_pool_cleanup(void *data);,13,48,http\v2\ngx_http_v2.c,ngx_http_v2_pool_cleanup,,false,193,193,ngx_http_v2_pool_cleanup,,,71,void ngx_http_v2_pool_cleanup (void*)
329222,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"void
ngx_http_v2_init(ngx_event_t *rev)
{
    ngx_connection_t          *c;
    ngx_pool_cleanup_t        *cln;
    ngx_http_connection_t     *hc;
    ngx_http_v2_srv_conf_t    *h2scf;
    ngx_http_v2_main_conf_t   *h2mcf;
    ngx_http_v2_connection_t  *h2c;

    c = rev->data;
    hc = c->data;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0, ""init http2 connection"");

    c->log->action = ""processing HTTP/2 connection"";

    h2mcf = ngx_http_get_module_main_conf(hc->conf_ctx, ngx_http_v2_module);

    if (h2mcf->recv_buffer == NULL) {
        h2mcf->recv_buffer = ngx_palloc(ngx_cycle->pool,
                                        h2mcf->recv_buffer_size);
        if (h2mcf->recv_buffer == NULL) {
            ngx_http_close_connection(c);
            return;
        }
    }

    h2c = ngx_pcalloc(c->pool, sizeof(ngx_http_v2_connection_t));
    if (h2c == NULL) {
        ngx_http_close_connection(c);
        return;
    }

    h2c->connection = c;
    h2c->http_connection = hc;

 ...",1,46,http\v2\ngx_http_v2.c,ngx_http_v2_init,,false,230,329,ngx_http_v2_init,,,76,void ngx_http_v2_init (ngx_event_t*)
329509,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static void
ngx_http_v2_read_handler(ngx_event_t *rev)
{
    u_char                    *p, *end;
    size_t                     available;
    ssize_t                    n;
    ngx_connection_t          *c;
    ngx_http_v2_main_conf_t   *h2mcf;
    ngx_http_v2_connection_t  *h2c;

    c = rev->data;
    h2c = c->data;

    if (rev->timedout) {
        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, ""client timed out"");
        ngx_http_v2_finalize_connection(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);
        return;
    }

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0, ""http2 read handler"");

    h2c->blocked = 1;

    if (c->close) {
        c->close = 0;

        if (c->error) {
            ngx_http_v2_finalize_connection(h2c, 0);
            return;
        }

        if (!h2c->goaway) {
            h2c->goaway = 1;

            if (ngx_http_v2_send_goaway(h2c, NGX_HTTP_V2_NO_ERROR)
                == NGX_ERROR)
            {
                ngx_http_v2_finalize_connection(h2c, 0);
...",1,45,http\v2\ngx_http_v2.c,ngx_http_v2_read_handler,,false,332,459,ngx_http_v2_read_handler,,,77,void ngx_http_v2_read_handler (ngx_event_t*)
329845,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static void
ngx_http_v2_write_handler(ngx_event_t *wev)
{
    ngx_int_t                  rc;
    ngx_connection_t          *c;
    ngx_http_v2_connection_t  *h2c;

    c = wev->data;
    h2c = c->data;

    if (wev->timedout) {
        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,
                       ""http2 write event timed out"");
        c->error = 1;
        ngx_http_v2_finalize_connection(h2c, 0);
        return;
    }

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0, ""http2 write handler"");

    if (h2c->last_out == NULL && !c->buffered) {

        if (wev->timer_set) {
            ngx_del_timer(wev);
        }

        ngx_http_v2_handle_connection(h2c);
        return;
    }

    h2c->blocked = 1;

    rc = ngx_http_v2_send_output_queue(h2c);

    if (rc == NGX_ERROR) {
        ngx_http_v2_finalize_connection(h2c, 0);
        return;
    }

    h2c->blocked = 0;

    if (rc == NGX_AGAIN) {
        return;
    }

    ngx_http_v2_handle_connection(h2c);
}",1,1,http\v2\ngx_http_v2.c,ngx_http_v2_write_handler,,false,462,508,ngx_http_v2_write_handler,,,78,void ngx_http_v2_write_handler (ngx_event_t*)
329944,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_v2_send_output_queue(ngx_http_v2_connection_t *h2c)
{
    int                        tcp_nodelay;
    ngx_chain_t               *cl;
    ngx_event_t               *wev;
    ngx_connection_t          *c;
    ngx_http_v2_out_frame_t   *out, *frame, *fn;
    ngx_http_core_loc_conf_t  *clcf;

    c = h2c->connection;
    wev = c->write;

    if (c->error) {
        goto error;
    }

    if (!wev->ready) {
        return NGX_AGAIN;
    }

    cl = NULL;
    out = NULL;

    for (frame = h2c->last_out; frame; frame = fn) {
        frame->last->next = cl;
        cl = frame->first;

        fn = frame->next;
        frame->next = out;
        out = frame;

        ngx_log_debug4(NGX_LOG_DEBUG_HTTP, c->log, 0,
                       ""http2 frame out: %p sid:%ui bl:%d len:%uz"",
                       out, out->stream ? out->stream->node->id : 0,
                       out->blocked, out->length);
    }

    cl = c->send_chain(c, cl, 0);

    if (cl == NGX_CHAIN_ERROR) {
  ...",1,1,http\v2\ngx_http_v2.c,ngx_http_v2_send_output_queue,,false,511,623,ngx_http_v2_send_output_queue,,,79,ngx_int_t ngx_http_v2_send_output_queue (ngx_http_v2_connection_t*)
330253,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static void
ngx_http_v2_handle_connection(ngx_http_v2_connection_t *h2c)
{
    ngx_int_t                rc;
    ngx_connection_t        *c;
    ngx_http_v2_srv_conf_t  *h2scf;

    if (h2c->last_out || h2c->processing || h2c->pushing) {
        return;
    }

    c = h2c->connection;

    if (c->error) {
        ngx_http_close_connection(c);
        return;
    }

    if (c->buffered) {
        h2c->blocked = 1;

        rc = ngx_http_v2_send_output_queue(h2c);

        h2c->blocked = 0;

        if (rc == NGX_ERROR) {
            ngx_http_close_connection(c);
            return;
        }

        if (rc == NGX_AGAIN) {
            return;
        }

        /* rc == NGX_OK */
    }

    if (h2c->goaway) {
        ngx_http_close_connection(c);
        return;
    }

    h2scf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,
                                         ngx_http_v2_module);
    if (h2c->state.incomplete) {
        ngx_add_timer(c->read, h2scf->recv_timeout)...",1,1,http\v2\ngx_http_v2.c,ngx_http_v2_handle_connection,,false,626,699,ngx_http_v2_handle_connection,,,80,void ngx_http_v2_handle_connection (ngx_http_v2_connection_t*)
330417,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *
ngx_http_v2_state_proxy_protocol(ngx_http_v2_connection_t *h2c, u_char *pos,
    u_char *end)
{
    ngx_log_t  *log;

    log = h2c->connection->log;
    log->action = ""reading PROXY protocol"";

    pos = ngx_proxy_protocol_read(h2c->connection, pos, end);

    log->action = ""processing HTTP/2 connection"";

    if (pos == NULL) {
        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);
    }

    return ngx_http_v2_state_preface(h2c, pos, end);
}",1,49,http\v2\ngx_http_v2.c,ngx_http_v2_state_proxy_protocol,,false,702,720,ngx_http_v2_state_proxy_protocol,,,81,"u_char ngx_http_v2_state_proxy_protocol (ngx_http_v2_connection_t*,u_char*,u_char*)"
330466,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *
ngx_http_v2_state_preface(ngx_http_v2_connection_t *h2c, u_char *pos,
    u_char *end)
{
    static const u_char preface[] = ""PRI * HTTP/2.0\r\n"";

    if ((size_t) (end - pos) < sizeof(preface) - 1) {
        return ngx_http_v2_state_save(h2c, pos, end, ngx_http_v2_state_preface);
    }

    if (ngx_memcmp(pos, preface, sizeof(preface) - 1) != 0) {
        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
                      ""invalid connection preface"");

        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);
    }

    return ngx_http_v2_state_preface_end(h2c, pos + sizeof(preface) - 1, end);
}",1,49,http\v2\ngx_http_v2.c,ngx_http_v2_state_preface,,false,723,741,ngx_http_v2_state_preface,,,82,"u_char ngx_http_v2_state_preface (ngx_http_v2_connection_t*,u_char*,u_char*)"
330530,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *
ngx_http_v2_state_preface_end(ngx_http_v2_connection_t *h2c, u_char *pos,
    u_char *end)
{
    static const u_char preface[] = ""\r\nSM\r\n\r\n"";

    if ((size_t) (end - pos) < sizeof(preface) - 1) {
        return ngx_http_v2_state_save(h2c, pos, end,
                                      ngx_http_v2_state_preface_end);
    }

    if (ngx_memcmp(pos, preface, sizeof(preface) - 1) != 0) {
        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
                      ""invalid connection preface"");

        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);
    }

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
                   ""http2 preface verified"");

    return ngx_http_v2_state_head(h2c, pos + sizeof(preface) - 1, end);
}",1,49,http\v2\ngx_http_v2.c,ngx_http_v2_state_preface_end,,false,744,766,ngx_http_v2_state_preface_end,,,83,"u_char ngx_http_v2_state_preface_end (ngx_http_v2_connection_t*,u_char*,u_char*)"
330603,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *
ngx_http_v2_state_head(ngx_http_v2_connection_t *h2c, u_char *pos, u_char *end)
{
    uint32_t    head;
    ngx_uint_t  type;

    if (end - pos < NGX_HTTP_V2_FRAME_HEADER_SIZE) {
        return ngx_http_v2_state_save(h2c, pos, end, ngx_http_v2_state_head);
    }

    head = ngx_http_v2_parse_uint32(pos);

    h2c->state.length = ngx_http_v2_parse_length(head);
    h2c->state.flags = pos[4];

    h2c->state.sid = ngx_http_v2_parse_sid(&pos[5]);

    pos += NGX_HTTP_V2_FRAME_HEADER_SIZE;

    type = ngx_http_v2_parse_type(head);

    ngx_log_debug4(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
                   ""http2 frame type:%ui f:%Xd l:%uz sid:%ui"",
                   type, h2c->state.flags, h2c->state.length, h2c->state.sid);

    if (type >= NGX_HTTP_V2_FRAME_STATES) {
        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
                      ""client sent frame with unknown type %ui"", type);
        return ngx_http_v2_state_skip(h2c, pos, end);
    }

 ...",1,16,http\v2\ngx_http_v2.c,ngx_http_v2_state_head,,false,769,801,ngx_http_v2_state_head,,,84,"u_char ngx_http_v2_state_head (ngx_http_v2_connection_t*,u_char*,u_char*)"
330723,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *
ngx_http_v2_state_data(ngx_http_v2_connection_t *h2c, u_char *pos, u_char *end)
{
    size_t                 size;
    ngx_http_v2_node_t    *node;
    ngx_http_v2_stream_t  *stream;

    size = h2c->state.length;

    if (h2c->state.flags & NGX_HTTP_V2_PADDED_FLAG) {

        if (h2c->state.length == 0) {
            ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
                          ""client sent padded DATA frame ""
                          ""with incorrect length: 0"");

            return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);
        }

        if (end - pos == 0) {
            return ngx_http_v2_state_save(h2c, pos, end,
                                          ngx_http_v2_state_data);
        }

        h2c->state.padding = *pos++;

        if (h2c->state.padding >= size) {
            ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
                          ""client sent padded DATA frame ""
                          ""with inc...",1,53,http\v2\ngx_http_v2.c,ngx_http_v2_state_data,,false,804,934,ngx_http_v2_state_data,,,85,"u_char ngx_http_v2_state_data (ngx_http_v2_connection_t*,u_char*,u_char*)"
331087,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *
ngx_http_v2_state_read_data(ngx_http_v2_connection_t *h2c, u_char *pos,
    u_char *end)
{
    size_t                   size;
    ngx_buf_t               *buf;
    ngx_int_t                rc;
    ngx_http_request_t      *r;
    ngx_http_v2_stream_t    *stream;
    ngx_http_v2_srv_conf_t  *h2scf;

    stream = h2c->state.stream;

    if (stream == NULL) {
        return ngx_http_v2_state_skip_padded(h2c, pos, end);
    }

    if (stream->skip_data) {
        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
                       ""skipping http2 DATA frame"");

        return ngx_http_v2_state_skip_padded(h2c, pos, end);
    }

    r = stream->request;

    if (r->reading_body && !r->request_body_no_buffering) {
        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
                       ""skipping http2 DATA frame"");

        return ngx_http_v2_state_skip_padded(h2c, pos, end);
    }

    size = end - pos;

    if (size >= h2c->state.length) {
...",1,52,http\v2\ngx_http_v2.c,ngx_http_v2_state_read_data,,false,937,1025,ngx_http_v2_state_read_data,,,86,"u_char ngx_http_v2_state_read_data (ngx_http_v2_connection_t*,u_char*,u_char*)"
331351,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *
ngx_http_v2_state_headers(ngx_http_v2_connection_t *h2c, u_char *pos,
    u_char *end)
{
    size_t                   size;
    ngx_uint_t               padded, priority, depend, dependency, excl, weight;
    ngx_uint_t               status;
    ngx_http_v2_node_t      *node;
    ngx_http_v2_stream_t    *stream;
    ngx_http_v2_srv_conf_t  *h2scf;

    padded = h2c->state.flags & NGX_HTTP_V2_PADDED_FLAG;
    priority = h2c->state.flags & NGX_HTTP_V2_PRIORITY_FLAG;

    size = 0;

    if (padded) {
        size++;
    }

    if (priority) {
        size += sizeof(uint32_t) + 1;
    }

    if (h2c->state.length < size) {
        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
                      ""client sent HEADERS frame with incorrect length %uz"",
                      h2c->state.length);

        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);
    }

    if (h2c->state.length == size) {
        ngx_log_error(NGX_LOG_INFO, h2c->connection->lo...",1,49,http\v2\ngx_http_v2.c,ngx_http_v2_state_headers,,false,1028,1214,ngx_http_v2_state_headers,,,87,"u_char ngx_http_v2_state_headers (ngx_http_v2_connection_t*,u_char*,u_char*)"
331990,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *
ngx_http_v2_state_header_block(ngx_http_v2_connection_t *h2c, u_char *pos,
    u_char *end)
{
    u_char      ch;
    ngx_int_t   value;
    ngx_uint_t  indexed, size_update, prefix;

    if (end - pos < 1) {
        return ngx_http_v2_state_headers_save(h2c, pos, end,
                                              ngx_http_v2_state_header_block);
    }

    if (!(h2c->state.flags & NGX_HTTP_V2_END_HEADERS_FLAG)
        && h2c->state.length < NGX_HTTP_V2_INT_OCTETS)
    {
        return ngx_http_v2_handle_continuation(h2c, pos, end,
                                               ngx_http_v2_state_header_block);
    }

    size_update = 0;
    indexed = 0;

    ch = *pos;

    if (ch >= (1 << 7)) {
        /* indexed header field */
        indexed = 1;
        prefix = ngx_http_v2_prefix(7);

    } else if (ch >= (1 << 6)) {
        /* literal header field with incremental indexing */
        h2c->state.index = 1;
        prefix = ngx_http_v2_prefix(6);

    } else if...",1,53,http\v2\ngx_http_v2.c,ngx_http_v2_state_header_block,,false,1217,1314,ngx_http_v2_state_header_block,,,88,"u_char ngx_http_v2_state_header_block (ngx_http_v2_connection_t*,u_char*,u_char*)"
332264,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *
ngx_http_v2_state_field_len(ngx_http_v2_connection_t *h2c, u_char *pos,
    u_char *end)
{
    size_t                   alloc;
    ngx_int_t                len;
    ngx_uint_t               huff;
    ngx_http_v2_srv_conf_t  *h2scf;

    if (!(h2c->state.flags & NGX_HTTP_V2_END_HEADERS_FLAG)
        && h2c->state.length < NGX_HTTP_V2_INT_OCTETS)
    {
        return ngx_http_v2_handle_continuation(h2c, pos, end,
                                               ngx_http_v2_state_field_len);
    }

    if (h2c->state.length < 1) {
        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
                      ""client sent header block with incorrect length"");

        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);
    }

    if (end - pos < 1) {
        return ngx_http_v2_state_headers_save(h2c, pos, end,
                                              ngx_http_v2_state_field_len);
    }

    huff = *pos >> 7;
    len = ngx_http_v2_parse_int(h2c, &pos,...",1,49,http\v2\ngx_http_v2.c,ngx_http_v2_state_field_len,,false,1317,1401,ngx_http_v2_state_field_len,,,89,"u_char ngx_http_v2_state_field_len (ngx_http_v2_connection_t*,u_char*,u_char*)"
332541,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *
ngx_http_v2_state_field_huff(ngx_http_v2_connection_t *h2c, u_char *pos,
    u_char *end)
{
    size_t  size;

    size = end - pos;

    if (size > h2c->state.field_rest) {
        size = h2c->state.field_rest;
    }

    if (size > h2c->state.length) {
        size = h2c->state.length;
    }

    h2c->state.length -= size;
    h2c->state.field_rest -= size;

    if (ngx_http_v2_huff_decode(&h2c->state.field_state, pos, size,
                                &h2c->state.field_end,
                                h2c->state.field_rest == 0,
                                h2c->connection->log)
        != NGX_OK)
    {
        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
                      ""client sent invalid encoded header field"");

        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_COMP_ERROR);
    }

    pos += size;

    if (h2c->state.field_rest == 0) {
        *h2c->state.field_end = '\0';
        return ngx_http_v2_state_process_header(h2c,...",1,49,http\v2\ngx_http_v2.c,ngx_http_v2_state_field_huff,,false,1404,1456,ngx_http_v2_state_field_huff,,,90,"u_char ngx_http_v2_state_field_huff (ngx_http_v2_connection_t*,u_char*,u_char*)"
332714,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *
ngx_http_v2_state_field_raw(ngx_http_v2_connection_t *h2c, u_char *pos,
    u_char *end)
{
    size_t  size;

    size = end - pos;

    if (size > h2c->state.field_rest) {
        size = h2c->state.field_rest;
    }

    if (size > h2c->state.length) {
        size = h2c->state.length;
    }

    h2c->state.length -= size;
    h2c->state.field_rest -= size;

    h2c->state.field_end = ngx_cpymem(h2c->state.field_end, pos, size);

    pos += size;

    if (h2c->state.field_rest == 0) {
        *h2c->state.field_end = '\0';
        return ngx_http_v2_state_process_header(h2c, pos, end);
    }

    if (h2c->state.length) {
        return ngx_http_v2_state_headers_save(h2c, pos, end,
                                              ngx_http_v2_state_field_raw);
    }

    if (h2c->state.flags & NGX_HTTP_V2_END_HEADERS_FLAG) {
        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
                      ""client sent header field with incorrect length"");

        return...",1,49,http\v2\ngx_http_v2.c,ngx_http_v2_state_field_raw,,false,1459,1501,ngx_http_v2_state_field_raw,,,91,"u_char ngx_http_v2_state_field_raw (ngx_http_v2_connection_t*,u_char*,u_char*)"
332855,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *
ngx_http_v2_state_field_skip(ngx_http_v2_connection_t *h2c, u_char *pos,
    u_char *end)
{
    size_t  size;

    size = end - pos;

    if (size > h2c->state.field_rest) {
        size = h2c->state.field_rest;
    }

    if (size > h2c->state.length) {
        size = h2c->state.length;
    }

    h2c->state.length -= size;
    h2c->state.field_rest -= size;

    pos += size;

    if (h2c->state.field_rest == 0) {
        return ngx_http_v2_state_process_header(h2c, pos, end);
    }

    if (h2c->state.length) {
        return ngx_http_v2_state_save(h2c, pos, end,
                                      ngx_http_v2_state_field_skip);
    }

    if (h2c->state.flags & NGX_HTTP_V2_END_HEADERS_FLAG) {
        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
                      ""client sent header field with incorrect length"");

        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);
    }

    return ngx_http_v2_handle_continuation(h2c, pos, end,
...",1,49,http\v2\ngx_http_v2.c,ngx_http_v2_state_field_skip,,false,1504,1543,ngx_http_v2_state_field_skip,,,92,"u_char ngx_http_v2_state_field_skip (ngx_http_v2_connection_t*,u_char*,u_char*)"
332974,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *
ngx_http_v2_state_process_header(ngx_http_v2_connection_t *h2c, u_char *pos,
    u_char *end)
{
    size_t                      len;
    ngx_int_t                   rc;
    ngx_table_elt_t            *h;
    ngx_http_header_t          *hh;
    ngx_http_request_t         *r;
    ngx_http_v2_header_t       *header;
    ngx_http_core_srv_conf_t   *cscf;
    ngx_http_core_main_conf_t  *cmcf;

    static ngx_str_t cookie = ngx_string(""cookie"");

    header = &h2c->state.header;

    if (h2c->state.parse_name) {
        h2c->state.parse_name = 0;

        header->name.len = h2c->state.field_end - h2c->state.field_start;
        header->name.data = h2c->state.field_start;

        if (header->name.len == 0) {
            ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
                          ""client sent zero header name length"");

            return ngx_http_v2_connection_error(h2c,
                                                NGX_HTTP_V2_PROTOCOL_ERROR);
       ...",1,48,http\v2\ngx_http_v2.c,ngx_http_v2_state_process_header,,false,1546,1710,ngx_http_v2_state_process_header,,,93,"u_char ngx_http_v2_state_process_header (ngx_http_v2_connection_t*,u_char*,u_char*)"
333537,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *
ngx_http_v2_state_header_complete(ngx_http_v2_connection_t *h2c, u_char *pos,
    u_char *end)
{
    ngx_http_v2_stream_t  *stream;

    if (h2c->state.length) {
        if (end - pos > 0) {
            h2c->state.handler = ngx_http_v2_state_header_block;
            return pos;
        }

        return ngx_http_v2_state_headers_save(h2c, pos, end,
                                              ngx_http_v2_state_header_block);
    }

    if (!(h2c->state.flags & NGX_HTTP_V2_END_HEADERS_FLAG)) {
        return ngx_http_v2_handle_continuation(h2c, pos, end,
                                             ngx_http_v2_state_header_complete);
    }

    stream = h2c->state.stream;

    if (stream) {
        ngx_http_v2_run_request(stream->request);
    }

    if (!h2c->state.keep_pool) {
        ngx_destroy_pool(h2c->state.pool);
    }

    h2c->state.pool = NULL;
    h2c->state.keep_pool = 0;

    if (h2c->state.padding) {
        return ngx_http_v2_state_skip_padded(h2c, p...",1,1,http\v2\ngx_http_v2.c,ngx_http_v2_state_header_complete,,false,1713,1752,ngx_http_v2_state_header_complete,,,94,"u_char ngx_http_v2_state_header_complete (ngx_http_v2_connection_t*,u_char*,u_char*)"
333649,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *
ngx_http_v2_handle_continuation(ngx_http_v2_connection_t *h2c, u_char *pos,
    u_char *end, ngx_http_v2_handler_pt handler)
{
    u_char    *p;
    size_t     len, skip;
    uint32_t   head;

    len = h2c->state.length;

    if (h2c->state.padding && (size_t) (end - pos) > len) {
        skip = ngx_min(h2c->state.padding, (end - pos) - len);

        h2c->state.padding -= skip;

        p = pos;
        pos += skip;
        ngx_memmove(pos, p, len);
    }

    if ((size_t) (end - pos) < len + NGX_HTTP_V2_FRAME_HEADER_SIZE) {
        return ngx_http_v2_state_headers_save(h2c, pos, end, handler);
    }

    p = pos + len;

    head = ngx_http_v2_parse_uint32(p);

    if (ngx_http_v2_parse_type(head) != NGX_HTTP_V2_CONTINUATION_FRAME) {
        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
             ""client sent inappropriate frame while CONTINUATION was expected"");

        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);
    }

    h2c...",1,49,http\v2\ngx_http_v2.c,ngx_http_v2_handle_continuation,,false,1755,1814,ngx_http_v2_handle_continuation,,,95,"u_char ngx_http_v2_handle_continuation (ngx_http_v2_connection_t*,u_char*,u_char*,ngx_http_v2_handler_pt)"
333843,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *
ngx_http_v2_state_priority(ngx_http_v2_connection_t *h2c, u_char *pos,
    u_char *end)
{
    ngx_uint_t           depend, dependency, excl, weight;
    ngx_http_v2_node_t  *node;

    if (h2c->state.length != NGX_HTTP_V2_PRIORITY_SIZE) {
        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
                      ""client sent PRIORITY frame with incorrect length %uz"",
                      h2c->state.length);

        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);
    }

    if (--h2c->priority_limit == 0) {
        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
                      ""client sent too many PRIORITY frames"");

        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_ENHANCE_YOUR_CALM);
    }

    if (end - pos < NGX_HTTP_V2_PRIORITY_SIZE) {
        return ngx_http_v2_state_save(h2c, pos, end,
                                      ngx_http_v2_state_priority);
    }

    dependency = ngx_http_v2_parse_uint32(pos);

   ...",1,29,http\v2\ngx_http_v2.c,ngx_http_v2_state_priority,,false,1817,1894,ngx_http_v2_state_priority,,,96,"u_char ngx_http_v2_state_priority (ngx_http_v2_connection_t*,u_char*,u_char*)"
334090,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *
ngx_http_v2_state_rst_stream(ngx_http_v2_connection_t *h2c, u_char *pos,
    u_char *end)
{
    ngx_uint_t             status;
    ngx_event_t           *ev;
    ngx_connection_t      *fc;
    ngx_http_v2_node_t    *node;
    ngx_http_v2_stream_t  *stream;

    if (h2c->state.length != NGX_HTTP_V2_RST_STREAM_SIZE) {
        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
                      ""client sent RST_STREAM frame with incorrect length %uz"",
                      h2c->state.length);

        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);
    }

    if (end - pos < NGX_HTTP_V2_RST_STREAM_SIZE) {
        return ngx_http_v2_state_save(h2c, pos, end,
                                      ngx_http_v2_state_rst_stream);
    }

    status = ngx_http_v2_parse_uint32(pos);

    pos += NGX_HTTP_V2_RST_STREAM_SIZE;

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
                   ""http2 RST_STREAM frame, sid:%ui status:%ui"",
   ...",1,29,http\v2\ngx_http_v2.c,ngx_http_v2_state_rst_stream,,false,1897,1981,ngx_http_v2_state_rst_stream,,,97,"u_char ngx_http_v2_state_rst_stream (ngx_http_v2_connection_t*,u_char*,u_char*)"
334342,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *
ngx_http_v2_state_settings(ngx_http_v2_connection_t *h2c, u_char *pos,
    u_char *end)
{
    if (h2c->state.flags == NGX_HTTP_V2_ACK_FLAG) {

        if (h2c->state.length != 0) {
            ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
                          ""client sent SETTINGS frame with the ACK flag ""
                          ""and nonzero length"");

            return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);
        }

        h2c->settings_ack = 1;

        return ngx_http_v2_state_complete(h2c, pos, end);
    }

    if (h2c->state.length % NGX_HTTP_V2_SETTINGS_PARAM_SIZE) {
        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
                      ""client sent SETTINGS frame with incorrect length %uz"",
                      h2c->state.length);

        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);
    }

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
                   ""http2 SETTINGS ...",1,53,http\v2\ngx_http_v2.c,ngx_http_v2_state_settings,,false,1984,2015,ngx_http_v2_state_settings,,,98,"u_char ngx_http_v2_state_settings (ngx_http_v2_connection_t*,u_char*,u_char*)"
334437,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *
ngx_http_v2_state_settings_params(ngx_http_v2_connection_t *h2c, u_char *pos,
    u_char *end)
{
    ssize_t                   window_delta;
    ngx_uint_t                id, value;
    ngx_http_v2_srv_conf_t   *h2scf;
    ngx_http_v2_out_frame_t  *frame;

    window_delta = 0;

    while (h2c->state.length) {
        if (end - pos < NGX_HTTP_V2_SETTINGS_PARAM_SIZE) {
            return ngx_http_v2_state_save(h2c, pos, end,
                                          ngx_http_v2_state_settings_params);
        }

        h2c->state.length -= NGX_HTTP_V2_SETTINGS_PARAM_SIZE;

        id = ngx_http_v2_parse_uint16(pos);
        value = ngx_http_v2_parse_uint32(&pos[2]);

        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
                       ""http2 setting %ui:%ui"", id, value);

        switch (id) {

        case NGX_HTTP_V2_INIT_WINDOW_SIZE_SETTING:

            if (value > NGX_HTTP_V2_MAX_WINDOW) {
                ngx_log_error(NGX_LOG_INFO, h2c->co...",1,24,http\v2\ngx_http_v2.c,ngx_http_v2_state_settings_params,,false,2018,2127,ngx_http_v2_state_settings_params,,,99,"u_char ngx_http_v2_state_settings_params (ngx_http_v2_connection_t*,u_char*,u_char*)"
334698,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *
ngx_http_v2_state_push_promise(ngx_http_v2_connection_t *h2c, u_char *pos,
    u_char *end)
{
    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
                  ""client sent PUSH_PROMISE frame"");

    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);
}",1,45,http\v2\ngx_http_v2.c,ngx_http_v2_state_push_promise,,false,2130,2138,ngx_http_v2_state_push_promise,,,100,"u_char ngx_http_v2_state_push_promise (ngx_http_v2_connection_t*,u_char*,u_char*)"
334720,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *
ngx_http_v2_state_ping(ngx_http_v2_connection_t *h2c, u_char *pos, u_char *end)
{
    ngx_buf_t                *buf;
    ngx_http_v2_out_frame_t  *frame;

    if (h2c->state.length != NGX_HTTP_V2_PING_SIZE) {
        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
                      ""client sent PING frame with incorrect length %uz"",
                      h2c->state.length);

        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);
    }

    if (end - pos < NGX_HTTP_V2_PING_SIZE) {
        return ngx_http_v2_state_save(h2c, pos, end, ngx_http_v2_state_ping);
    }

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
                   ""http2 PING frame"");

    if (h2c->state.flags & NGX_HTTP_V2_ACK_FLAG) {
        return ngx_http_v2_state_skip(h2c, pos, end);
    }

    frame = ngx_http_v2_get_frame(h2c, NGX_HTTP_V2_PING_SIZE,
                                  NGX_HTTP_V2_PING_FRAME,
                                  NGX_HTTP_V2_...",1,29,http\v2\ngx_http_v2.c,ngx_http_v2_state_ping,,false,2141,2180,ngx_http_v2_state_ping,,,101,"u_char ngx_http_v2_state_ping (ngx_http_v2_connection_t*,u_char*,u_char*)"
334850,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *
ngx_http_v2_state_goaway(ngx_http_v2_connection_t *h2c, u_char *pos,
    u_char *end)
{
#if (NGX_DEBUG)
    ngx_uint_t  last_sid, error;
#endif

    if (h2c->state.length < NGX_HTTP_V2_GOAWAY_SIZE) {
        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
                      ""client sent GOAWAY frame ""
                      ""with incorrect length %uz"", h2c->state.length);

        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);
    }

    if (end - pos < NGX_HTTP_V2_GOAWAY_SIZE) {
        return ngx_http_v2_state_save(h2c, pos, end, ngx_http_v2_state_goaway);
    }

#if (NGX_DEBUG)
    h2c->state.length -= NGX_HTTP_V2_GOAWAY_SIZE;

    last_sid = ngx_http_v2_parse_sid(pos);
    error = ngx_http_v2_parse_uint32(&pos[4]);

    pos += NGX_HTTP_V2_GOAWAY_SIZE;

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
                   ""http2 GOAWAY frame: last sid %ui, error %ui"",
                   last_sid, error);
#endif

    return ng...",1,28,http\v2\ngx_http_v2.c,ngx_http_v2_state_goaway,,false,2183,2217,ngx_http_v2_state_goaway,,,102,"u_char ngx_http_v2_state_goaway (ngx_http_v2_connection_t*,u_char*,u_char*)"
334908,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *
ngx_http_v2_state_window_update(ngx_http_v2_connection_t *h2c, u_char *pos,
    u_char *end)
{
    size_t                 window;
    ngx_event_t           *wev;
    ngx_queue_t           *q;
    ngx_http_v2_node_t    *node;
    ngx_http_v2_stream_t  *stream;

    if (h2c->state.length != NGX_HTTP_V2_WINDOW_UPDATE_SIZE) {
        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
                      ""client sent WINDOW_UPDATE frame ""
                      ""with incorrect length %uz"", h2c->state.length);

        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);
    }

    if (end - pos < NGX_HTTP_V2_WINDOW_UPDATE_SIZE) {
        return ngx_http_v2_state_save(h2c, pos, end,
                                      ngx_http_v2_state_window_update);
    }

    window = ngx_http_v2_parse_window(pos);

    pos += NGX_HTTP_V2_WINDOW_UPDATE_SIZE;

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
                   ""http2 WINDOW_UPDATE frame s...",1,29,http\v2\ngx_http_v2.c,ngx_http_v2_state_window_update,,false,2220,2346,ngx_http_v2_state_window_update,,,103,"u_char ngx_http_v2_state_window_update (ngx_http_v2_connection_t*,u_char*,u_char*)"
335260,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *
ngx_http_v2_state_continuation(ngx_http_v2_connection_t *h2c, u_char *pos,
    u_char *end)
{
    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
                  ""client sent unexpected CONTINUATION frame"");

    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);
}",1,45,http\v2\ngx_http_v2.c,ngx_http_v2_state_continuation,,false,2349,2357,ngx_http_v2_state_continuation,,,104,"u_char ngx_http_v2_state_continuation (ngx_http_v2_connection_t*,u_char*,u_char*)"
335282,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *
ngx_http_v2_state_complete(ngx_http_v2_connection_t *h2c, u_char *pos,
    u_char *end)
{
    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
                   ""http2 frame complete pos:%p end:%p"", pos, end);

    if (pos > end) {
        ngx_log_error(NGX_LOG_ALERT, h2c->connection->log, 0,
                      ""receive buffer overrun"");

        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_INTERNAL_ERROR);
    }

    h2c->state.stream = NULL;
    h2c->state.handler = ngx_http_v2_state_head;

    return pos;
}",1,49,http\v2\ngx_http_v2.c,ngx_http_v2_state_complete,,false,2360,2378,ngx_http_v2_state_complete,,,105,"u_char ngx_http_v2_state_complete (ngx_http_v2_connection_t*,u_char*,u_char*)"
335336,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *
ngx_http_v2_state_skip_padded(ngx_http_v2_connection_t *h2c, u_char *pos,
    u_char *end)
{
    h2c->state.length += h2c->state.padding;
    h2c->state.padding = 0;

    return ngx_http_v2_state_skip(h2c, pos, end);
}",1,1,http\v2\ngx_http_v2.c,ngx_http_v2_state_skip_padded,,false,2381,2389,ngx_http_v2_state_skip_padded,,,106,"u_char ngx_http_v2_state_skip_padded (ngx_http_v2_connection_t*,u_char*,u_char*)"
335366,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *
ngx_http_v2_state_skip(ngx_http_v2_connection_t *h2c, u_char *pos, u_char *end)
{
    size_t  size;

    size = end - pos;

    if (size < h2c->state.length) {
        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
                       ""http2 frame skip %uz of %uz"", size, h2c->state.length);

        h2c->state.length -= size;
        return ngx_http_v2_state_save(h2c, end, end, ngx_http_v2_state_skip);
    }

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
                   ""http2 frame skip %uz"", h2c->state.length);

    return ngx_http_v2_state_complete(h2c, pos + h2c->state.length, end);
}",1,1,http\v2\ngx_http_v2.c,ngx_http_v2_state_skip,,false,2392,2411,ngx_http_v2_state_skip,,,107,"u_char ngx_http_v2_state_skip (ngx_http_v2_connection_t*,u_char*,u_char*)"
335441,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *
ngx_http_v2_state_save(ngx_http_v2_connection_t *h2c, u_char *pos, u_char *end,
    ngx_http_v2_handler_pt handler)
{
    size_t  size;

    ngx_log_debug3(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
                   ""http2 frame state save pos:%p end:%p handler:%p"",
                   pos, end, handler);

    size = end - pos;

    if (size > NGX_HTTP_V2_STATE_BUFFER_SIZE) {
        ngx_log_error(NGX_LOG_ALERT, h2c->connection->log, 0,
                      ""state buffer overflow: %uz bytes required"", size);

        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_INTERNAL_ERROR);
    }

    ngx_memcpy(h2c->state.buffer, pos, NGX_HTTP_V2_STATE_BUFFER_SIZE);

    h2c->state.buffer_used = size;
    h2c->state.handler = handler;
    h2c->state.incomplete = 1;

    return end;
}",1,49,http\v2\ngx_http_v2.c,ngx_http_v2_state_save,,false,2414,2440,ngx_http_v2_state_save,,,108,"u_char ngx_http_v2_state_save (ngx_http_v2_connection_t*,u_char*,u_char*,ngx_http_v2_handler_pt)"
335519,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *
ngx_http_v2_state_headers_save(ngx_http_v2_connection_t *h2c, u_char *pos,
    u_char *end, ngx_http_v2_handler_pt handler)
{
    ngx_event_t               *rev;
    ngx_http_request_t        *r;
    ngx_http_core_srv_conf_t  *cscf;

    if (h2c->state.stream) {
        r = h2c->state.stream->request;
        rev = r->connection->read;

        if (!rev->timer_set) {
            cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);
            ngx_add_timer(rev, cscf->client_header_timeout);
        }
    }

    return ngx_http_v2_state_save(h2c, pos, end, handler);
}",1,1,http\v2\ngx_http_v2.c,ngx_http_v2_state_headers_save,,false,2443,2462,ngx_http_v2_state_headers_save,,,109,"u_char ngx_http_v2_state_headers_save (ngx_http_v2_connection_t*,u_char*,u_char*,ngx_http_v2_handler_pt)"
335575,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static u_char *
ngx_http_v2_connection_error(ngx_http_v2_connection_t *h2c,
    ngx_uint_t err)
{
    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
                   ""http2 state connection error"");

    ngx_http_v2_finalize_connection(h2c, err);

    return NULL;
}",1,1,http\v2\ngx_http_v2.c,ngx_http_v2_connection_error,,false,2465,2475,ngx_http_v2_connection_error,,,110,"u_char ngx_http_v2_connection_error (ngx_http_v2_connection_t*,ngx_uint_t)"
335595,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_v2_parse_int(ngx_http_v2_connection_t *h2c, u_char **pos, u_char *end,
    ngx_uint_t prefix)
{
    u_char      *start, *p;
    ngx_uint_t   value, octet, shift;

    start = *pos;
    p = start;

    value = *p++ & prefix;

    if (value != prefix) {
        if (h2c->state.length == 0) {
            return NGX_ERROR;
        }

        h2c->state.length--;

        *pos = p;
        return value;
    }

    if (end - start > NGX_HTTP_V2_INT_OCTETS) {
        end = start + NGX_HTTP_V2_INT_OCTETS;
    }

    for (shift = 0; p != end; shift += 7) {
        octet = *p++;

        value += (octet & 0x7f) << shift;

        if (octet < 128) {
            if ((size_t) (p - start) > h2c->state.length) {
                return NGX_ERROR;
            }

            h2c->state.length -= p - start;

            *pos = p;
            return value;
        }
    }

    if ((size_t) (end - start) >= h2c->state.length) {
        return NGX_ERROR;
    }

    if (end == sta...",1,1,http\v2\ngx_http_v2.c,ngx_http_v2_parse_int,,false,2478,2531,ngx_http_v2_parse_int,,,111,"ngx_int_t ngx_http_v2_parse_int (ngx_http_v2_connection_t*,u_char**,u_char*,ngx_uint_t)"
335745,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"ngx_http_v2_stream_t *
ngx_http_v2_push_stream(ngx_http_v2_stream_t *parent, ngx_str_t *path)
{
    ngx_int_t                     rc;
    ngx_str_t                     value;
    ngx_pool_t                   *pool;
    ngx_uint_t                    index;
    ngx_table_elt_t             **h;
    ngx_connection_t             *fc;
    ngx_http_request_t           *r;
    ngx_http_v2_node_t           *node;
    ngx_http_v2_stream_t         *stream;
    ngx_http_v2_srv_conf_t       *h2scf;
    ngx_http_v2_connection_t     *h2c;
    ngx_http_v2_parse_header_t   *header;

    h2c = parent->connection;

    pool = ngx_create_pool(1024, h2c->connection->log);
    if (pool == NULL) {
        goto rst_stream;
    }

    node = ngx_http_v2_get_node_by_id(h2c, h2c->last_push, 1);

    if (node == NULL) {
        ngx_destroy_pool(pool);
        goto rst_stream;
    }

    stream = ngx_http_v2_create_stream(h2c, 1);
    if (stream == NULL) {

        if (node->parent == NULL) {
            h2scf ...",1,20,http\v2\ngx_http_v2.c,ngx_http_v2_push_stream,,false,2534,2688,ngx_http_v2_push_stream,,,112,"ngx_http_v2_stream_t ngx_http_v2_push_stream (ngx_http_v2_stream_t*,ngx_str_t*)"
336186,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_v2_send_settings(ngx_http_v2_connection_t *h2c)
{
    size_t                    len;
    ngx_buf_t                *buf;
    ngx_chain_t              *cl;
    ngx_http_v2_srv_conf_t   *h2scf;
    ngx_http_v2_out_frame_t  *frame;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
                   ""http2 send SETTINGS frame"");

    frame = ngx_palloc(h2c->pool, sizeof(ngx_http_v2_out_frame_t));
    if (frame == NULL) {
        return NGX_ERROR;
    }

    cl = ngx_alloc_chain_link(h2c->pool);
    if (cl == NULL) {
        return NGX_ERROR;
    }

    len = NGX_HTTP_V2_SETTINGS_PARAM_SIZE * 3;

    buf = ngx_create_temp_buf(h2c->pool, NGX_HTTP_V2_FRAME_HEADER_SIZE + len);
    if (buf == NULL) {
        return NGX_ERROR;
    }

    buf->last_buf = 1;

    cl->buf = buf;
    cl->next = NULL;

    frame->first = cl;
    frame->last = cl;
    frame->handler = ngx_http_v2_settings_frame_handler;
    frame->stream = NULL;
#if (NGX_DEBUG)
    frame->le...",1,10,http\v2\ngx_http_v2.c,ngx_http_v2_send_settings,,false,2691,2761,ngx_http_v2_send_settings,,,113,ngx_int_t ngx_http_v2_send_settings (ngx_http_v2_connection_t*)
336400,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_v2_settings_frame_handler(ngx_http_v2_connection_t *h2c,
    ngx_http_v2_out_frame_t *frame)
{
    ngx_buf_t  *buf;

    buf = frame->first->buf;

    if (buf->pos != buf->last) {
        return NGX_AGAIN;
    }

    ngx_free_chain(h2c->pool, frame->first);

    return NGX_OK;
}",1,1,http\v2\ngx_http_v2.c,ngx_http_v2_settings_frame_handler,,false,2764,2779,ngx_http_v2_settings_frame_handler,,,114,"ngx_int_t ngx_http_v2_settings_frame_handler (ngx_http_v2_connection_t*,ngx_http_v2_out_frame_t*)"
336434,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_v2_send_window_update(ngx_http_v2_connection_t *h2c, ngx_uint_t sid,
    size_t window)
{
    ngx_buf_t                *buf;
    ngx_http_v2_out_frame_t  *frame;

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
                   ""http2 send WINDOW_UPDATE frame sid:%ui, window:%uz"",
                   sid, window);

    frame = ngx_http_v2_get_frame(h2c, NGX_HTTP_V2_WINDOW_UPDATE_SIZE,
                                  NGX_HTTP_V2_WINDOW_UPDATE_FRAME,
                                  NGX_HTTP_V2_NO_FLAG, sid);
    if (frame == NULL) {
        return NGX_ERROR;
    }

    buf = frame->first->buf;

    buf->last = ngx_http_v2_write_uint32(buf->last, window);

    ngx_http_v2_queue_blocked_frame(h2c, frame);

    return NGX_OK;
}",1,39,http\v2\ngx_http_v2.c,ngx_http_v2_send_window_update,,false,2782,2807,ngx_http_v2_send_window_update,,,115,"ngx_int_t ngx_http_v2_send_window_update (ngx_http_v2_connection_t*,ngx_uint_t,size_t)"
336492,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_v2_send_rst_stream(ngx_http_v2_connection_t *h2c, ngx_uint_t sid,
    ngx_uint_t status)
{
    ngx_buf_t                *buf;
    ngx_http_v2_out_frame_t  *frame;

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
                   ""http2 send RST_STREAM frame sid:%ui, status:%ui"",
                   sid, status);

    frame = ngx_http_v2_get_frame(h2c, NGX_HTTP_V2_RST_STREAM_SIZE,
                                  NGX_HTTP_V2_RST_STREAM_FRAME,
                                  NGX_HTTP_V2_NO_FLAG, sid);
    if (frame == NULL) {
        return NGX_ERROR;
    }

    buf = frame->first->buf;

    buf->last = ngx_http_v2_write_uint32(buf->last, status);

    ngx_http_v2_queue_blocked_frame(h2c, frame);

    return NGX_OK;
}",1,39,http\v2\ngx_http_v2.c,ngx_http_v2_send_rst_stream,,false,2810,2835,ngx_http_v2_send_rst_stream,,,116,"ngx_int_t ngx_http_v2_send_rst_stream (ngx_http_v2_connection_t*,ngx_uint_t,ngx_uint_t)"
336550,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_v2_send_goaway(ngx_http_v2_connection_t *h2c, ngx_uint_t status)
{
    ngx_buf_t                *buf;
    ngx_http_v2_out_frame_t  *frame;

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
                   ""http2 send GOAWAY frame: last sid %ui, error %ui"",
                   h2c->last_sid, status);

    frame = ngx_http_v2_get_frame(h2c, NGX_HTTP_V2_GOAWAY_SIZE,
                                  NGX_HTTP_V2_GOAWAY_FRAME,
                                  NGX_HTTP_V2_NO_FLAG, 0);
    if (frame == NULL) {
        return NGX_ERROR;
    }

    buf = frame->first->buf;

    buf->last = ngx_http_v2_write_sid(buf->last, h2c->last_sid);
    buf->last = ngx_http_v2_write_uint32(buf->last, status);

    ngx_http_v2_queue_blocked_frame(h2c, frame);

    return NGX_OK;
}",1,39,http\v2\ngx_http_v2.c,ngx_http_v2_send_goaway,,false,2838,2863,ngx_http_v2_send_goaway,,,117,"ngx_int_t ngx_http_v2_send_goaway (ngx_http_v2_connection_t*,ngx_uint_t)"
336620,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_http_v2_out_frame_t *
ngx_http_v2_get_frame(ngx_http_v2_connection_t *h2c, size_t length,
    ngx_uint_t type, u_char flags, ngx_uint_t sid)
{
    ngx_buf_t                *buf;
    ngx_pool_t               *pool;
    ngx_http_v2_out_frame_t  *frame;

    frame = h2c->free_frames;

    if (frame) {
        h2c->free_frames = frame->next;

        buf = frame->first->buf;
        buf->pos = buf->start;

        frame->blocked = 0;

    } else if (h2c->frames < 10000) {
        pool = h2c->pool ? h2c->pool : h2c->connection->pool;

        frame = ngx_pcalloc(pool, sizeof(ngx_http_v2_out_frame_t));
        if (frame == NULL) {
            return NULL;
        }

        frame->first = ngx_alloc_chain_link(pool);
        if (frame->first == NULL) {
            return NULL;
        }

        buf = ngx_create_temp_buf(pool, NGX_HTTP_V2_FRAME_BUFFER_SIZE);
        if (buf == NULL) {
            return NULL;
        }

        buf->last_buf = 1;

        frame->first->buf = buf...",1,40,http\v2\ngx_http_v2.c,ngx_http_v2_get_frame,,false,2866,2937,ngx_http_v2_get_frame,,,118,"ngx_http_v2_out_frame_t ngx_http_v2_get_frame (ngx_http_v2_connection_t*,size_t,ngx_uint_t,u_char,ngx_uint_t)"
336812,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_v2_frame_handler(ngx_http_v2_connection_t *h2c,
    ngx_http_v2_out_frame_t *frame)
{
    ngx_buf_t  *buf;

    buf = frame->first->buf;

    if (buf->pos != buf->last) {
        return NGX_AGAIN;
    }

    frame->next = h2c->free_frames;
    h2c->free_frames = frame;

    h2c->total_bytes += NGX_HTTP_V2_FRAME_HEADER_SIZE + frame->length;

    return NGX_OK;
}",1,1,http\v2\ngx_http_v2.c,ngx_http_v2_frame_handler,,false,2940,2958,ngx_http_v2_frame_handler,,,119,"ngx_int_t ngx_http_v2_frame_handler (ngx_http_v2_connection_t*,ngx_http_v2_out_frame_t*)"
336860,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_http_v2_stream_t *
ngx_http_v2_create_stream(ngx_http_v2_connection_t *h2c, ngx_uint_t push)
{
    ngx_log_t                 *log;
    ngx_event_t               *rev, *wev;
    ngx_connection_t          *fc;
    ngx_http_log_ctx_t        *ctx;
    ngx_http_request_t        *r;
    ngx_http_v2_stream_t      *stream;
    ngx_http_v2_srv_conf_t    *h2scf;
    ngx_http_core_srv_conf_t  *cscf;

    fc = h2c->free_fake_connections;

    if (fc) {
        h2c->free_fake_connections = fc->data;

        rev = fc->read;
        wev = fc->write;
        log = fc->log;
        ctx = log->data;

    } else {
        fc = ngx_palloc(h2c->pool, sizeof(ngx_connection_t));
        if (fc == NULL) {
            return NULL;
        }

        rev = ngx_palloc(h2c->pool, sizeof(ngx_event_t));
        if (rev == NULL) {
            return NULL;
        }

        wev = ngx_palloc(h2c->pool, sizeof(ngx_event_t));
        if (wev == NULL) {
            return NULL;
        }

        log = ng...",1,1,http\v2\ngx_http_v2.c,ngx_http_v2_create_stream,,false,2961,3105,ngx_http_v2_create_stream,,,120,"ngx_http_v2_stream_t ngx_http_v2_create_stream (ngx_http_v2_connection_t*,ngx_uint_t)"
337283,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_http_v2_node_t *
ngx_http_v2_get_node_by_id(ngx_http_v2_connection_t *h2c, ngx_uint_t sid,
    ngx_uint_t alloc)
{
    ngx_uint_t               index;
    ngx_http_v2_node_t      *node;
    ngx_http_v2_srv_conf_t  *h2scf;

    h2scf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,
                                         ngx_http_v2_module);

    index = ngx_http_v2_index(h2scf, sid);

    for (node = h2c->streams_index[index]; node; node = node->index) {

        if (node->id == sid) {
            return node;
        }
    }

    if (!alloc) {
        return NULL;
    }

    if (h2c->closed_nodes < 32) {
        node = ngx_pcalloc(h2c->connection->pool, sizeof(ngx_http_v2_node_t));
        if (node == NULL) {
            return NULL;
        }

    } else {
        node = ngx_http_v2_get_closed_node(h2c);
    }

    node->id = sid;

    ngx_queue_init(&node->children);

    node->index = h2c->streams_index[index];
    h2c->streams_index[index] = node;

   ...",1,12,http\v2\ngx_http_v2.c,ngx_http_v2_get_node_by_id,,false,3108,3150,ngx_http_v2_get_node_by_id,,,121,"ngx_http_v2_node_t ngx_http_v2_get_node_by_id (ngx_http_v2_connection_t*,ngx_uint_t,ngx_uint_t)"
337404,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_http_v2_node_t *
ngx_http_v2_get_closed_node(ngx_http_v2_connection_t *h2c)
{
    ngx_uint_t               weight;
    ngx_queue_t             *q, *children;
    ngx_http_v2_node_t      *node, **next, *n, *parent, *child;
    ngx_http_v2_srv_conf_t  *h2scf;

    h2scf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,
                                         ngx_http_v2_module);

    h2c->closed_nodes--;

    q = ngx_queue_head(&h2c->closed);

    ngx_queue_remove(q);

    node = ngx_queue_data(q, ngx_http_v2_node_t, reuse);

    next = &h2c->streams_index[ngx_http_v2_index(h2scf, node->id)];

    for ( ;; ) {
        n = *next;

        if (n == node) {
            *next = n->index;
            break;
        }

        next = &n->index;
    }

    ngx_queue_remove(&node->queue);

    weight = 0;

    for (q = ngx_queue_head(&node->children);
         q != ngx_queue_sentinel(&node->children);
         q = ngx_queue_next(q))
    {
        child = ngx_queue_dat...",1,31,http\v2\ngx_http_v2.c,ngx_http_v2_get_closed_node,,false,3153,3231,ngx_http_v2_get_closed_node,,,122,ngx_http_v2_node_t ngx_http_v2_get_closed_node (ngx_http_v2_connection_t*)
337657,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_v2_validate_header(ngx_http_request_t *r, ngx_http_v2_header_t *header)
{
    u_char                     ch;
    ngx_uint_t                 i;
    ngx_http_core_srv_conf_t  *cscf;

    r->invalid_header = 0;

    cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);

    for (i = (header->name.data[0] == ':'); i != header->name.len; i++) {
        ch = header->name.data[i];

        if ((ch >= 'a' && ch <= 'z')
            || (ch == '-')
            || (ch >= '0' && ch <= '9')
            || (ch == '_' && cscf->underscores_in_headers))
        {
            continue;
        }

        if (ch == '\0' || ch == LF || ch == CR || ch == ':'
            || (ch >= 'A' && ch <= 'Z'))
        {
            ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
                          ""client sent invalid header name: \""%V\"""",
                          &header->name);

            return NGX_ERROR;
        }

        r->invalid_header = 1;
    }

    for (i = ...",1,1,http\v2\ngx_http_v2.c,ngx_http_v2_validate_header,,false,3234,3283,ngx_http_v2_validate_header,,,123,"ngx_int_t ngx_http_v2_validate_header (ngx_http_request_t*,ngx_http_v2_header_t*)"
337841,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_v2_pseudo_header(ngx_http_request_t *r, ngx_http_v2_header_t *header)
{
    header->name.len--;
    header->name.data++;

    switch (header->name.len) {
    case 4:
        if (ngx_memcmp(header->name.data, ""path"", sizeof(""path"") - 1)
            == 0)
        {
            return ngx_http_v2_parse_path(r, &header->value);
        }

        break;

    case 6:
        if (ngx_memcmp(header->name.data, ""method"", sizeof(""method"") - 1)
            == 0)
        {
            return ngx_http_v2_parse_method(r, &header->value);
        }

        if (ngx_memcmp(header->name.data, ""scheme"", sizeof(""scheme"") - 1)
            == 0)
        {
            return ngx_http_v2_parse_scheme(r, &header->value);
        }

        break;

    case 9:
        if (ngx_memcmp(header->name.data, ""authority"", sizeof(""authority"") - 1)
            == 0)
        {
            return ngx_http_v2_parse_authority(r, &header->value);
        }

        break;
    }

    ngx_log_erro...",1,1,http\v2\ngx_http_v2.c,ngx_http_v2_pseudo_header,,false,3286,3332,ngx_http_v2_pseudo_header,,,124,"ngx_int_t ngx_http_v2_pseudo_header (ngx_http_request_t*,ngx_http_v2_header_t*)"
337978,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_v2_parse_path(ngx_http_request_t *r, ngx_str_t *value)
{
    if (r->unparsed_uri.len) {
        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
                      ""client sent duplicate :path header"");

        return NGX_DECLINED;
    }

    if (value->len == 0) {
        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
                      ""client sent empty :path header"");

        return NGX_DECLINED;
    }

    r->uri_start = value->data;
    r->uri_end = value->data + value->len;

    if (ngx_http_parse_uri(r) != NGX_OK) {
        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
                      ""client sent invalid :path header: \""%V\"""", value);

        return NGX_DECLINED;
    }

    if (ngx_http_process_request_uri(r) != NGX_OK) {
        /*
         * request has been finalized already
         * in ngx_http_process_request_uri()
         */
        return NGX_ABORT;
    }

    return NGX_OK;
}",1,1,http\v2\ngx_http_v2.c,ngx_http_v2_parse_path,,false,3335,3371,ngx_http_v2_parse_path,,,125,"ngx_int_t ngx_http_v2_parse_path (ngx_http_request_t*,ngx_str_t*)"
338066,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_v2_parse_method(ngx_http_request_t *r, ngx_str_t *value)
{
    size_t         k, len;
    ngx_uint_t     n;
    const u_char  *p, *m;

    /*
     * This array takes less than 256 sequential bytes,
     * and if typical CPU cache line size is 64 bytes,
     * it is prefetched for 4 load operations.
     */
    static const struct {
        u_char            len;
        const u_char      method[11];
        uint32_t          value;
    } tests[] = {
        { 3, ""GET"",       NGX_HTTP_GET },
        { 4, ""POST"",      NGX_HTTP_POST },
        { 4, ""HEAD"",      NGX_HTTP_HEAD },
        { 7, ""OPTIONS"",   NGX_HTTP_OPTIONS },
        { 8, ""PROPFIND"",  NGX_HTTP_PROPFIND },
        { 3, ""PUT"",       NGX_HTTP_PUT },
        { 5, ""MKCOL"",     NGX_HTTP_MKCOL },
        { 6, ""DELETE"",    NGX_HTTP_DELETE },
        { 4, ""COPY"",      NGX_HTTP_COPY },
        { 4, ""MOVE"",      NGX_HTTP_MOVE },
        { 9, ""PROPPATCH"", NGX_HTTP_PROPPATCH },
        { 4, ""LOCK"",      NGX_H...",1,1,http\v2\ngx_http_v2.c,ngx_http_v2_parse_method,,false,3374,3466,ngx_http_v2_parse_method,,,126,"ngx_int_t ngx_http_v2_parse_method (ngx_http_request_t*,ngx_str_t*)"
338318,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_v2_parse_scheme(ngx_http_request_t *r, ngx_str_t *value)
{
    u_char      c, ch;
    ngx_uint_t  i;

    if (r->schema.len) {
        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
                      ""client sent duplicate :scheme header"");

        return NGX_DECLINED;
    }

    if (value->len == 0) {
        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
                      ""client sent empty :scheme header"");

        return NGX_DECLINED;
    }

    for (i = 0; i < value->len; i++) {
        ch = value->data[i];

        c = (u_char) (ch | 0x20);
        if (c >= 'a' && c <= 'z') {
            continue;
        }

        if (((ch >= '0' && ch <= '9') || ch == '+' || ch == '-' || ch == '.')
            && i > 0)
        {
            continue;
        }

        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
                      ""client sent invalid :scheme header: \""%V\"""", value);

        return NGX_DECLINED;
    }

    r->schema = ...",1,1,http\v2\ngx_http_v2.c,ngx_http_v2_parse_scheme,,false,3469,3512,ngx_http_v2_parse_scheme,,,127,"ngx_int_t ngx_http_v2_parse_scheme (ngx_http_request_t*,ngx_str_t*)"
338445,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_v2_parse_authority(ngx_http_request_t *r, ngx_str_t *value)
{
    return ngx_http_v2_parse_header(r, &ngx_http_v2_parse_headers[0], value);
}",1,1,http\v2\ngx_http_v2.c,ngx_http_v2_parse_authority,,false,3515,3519,ngx_http_v2_parse_authority,,,128,"ngx_int_t ngx_http_v2_parse_authority (ngx_http_request_t*,ngx_str_t*)"
338459,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_v2_parse_header(ngx_http_request_t *r,
    ngx_http_v2_parse_header_t *header, ngx_str_t *value)
{
    ngx_table_elt_t            *h;
    ngx_http_core_main_conf_t  *cmcf;

    h = ngx_list_push(&r->headers_in.headers);
    if (h == NULL) {
        return NGX_ERROR;
    }

    h->key.len = header->name.len;
    h->key.data = header->name.data;
    h->lowcase_key = header->name.data;

    if (header->hh == NULL) {
        header->hash = ngx_hash_key(header->name.data, header->name.len);

        cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);

        header->hh = ngx_hash_find(&cmcf->headers_in_hash, header->hash,
                                   h->lowcase_key, h->key.len);
        if (header->hh == NULL) {
            return NGX_ERROR;
        }
    }

    h->hash = header->hash;

    h->value.len = value->len;
    h->value.data = value->data;

    if (header->hh->handler(r, h, header->hh->offset) != NGX_OK) {
        /* header handler ha...",1,1,http\v2\ngx_http_v2.c,ngx_http_v2_parse_header,,false,3522,3561,ngx_http_v2_parse_header,,,129,"ngx_int_t ngx_http_v2_parse_header (ngx_http_request_t*,ngx_http_v2_parse_header_t*,ngx_str_t*)"
338617,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_v2_construct_request_line(ngx_http_request_t *r)
{
    u_char  *p;

    static const u_char ending[] = "" HTTP/2.0"";

    if (r->method_name.len == 0
        || r->schema.len == 0
        || r->unparsed_uri.len == 0)
    {
        if (r->method_name.len == 0) {
            ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
                          ""client sent no :method header"");

        } else if (r->schema.len == 0) {
            ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
                          ""client sent no :scheme header"");

        } else {
            ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
                          ""client sent no :path header"");
        }

        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);
        return NGX_ERROR;
    }

    r->request_line.len = r->method_name.len + 1
                          + r->unparsed_uri.len
                          + sizeof(ending) - 1;

    p = ngx_pnalloc(r->pool, r->r...",1,1,http\v2\ngx_http_v2.c,ngx_http_v2_construct_request_line,,false,3564,3616,ngx_http_v2_construct_request_line,,,130,ngx_int_t ngx_http_v2_construct_request_line (ngx_http_request_t*)
338815,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_v2_cookie(ngx_http_request_t *r, ngx_http_v2_header_t *header)
{
    ngx_str_t    *val;
    ngx_array_t  *cookies;

    cookies = r->stream->cookies;

    if (cookies == NULL) {
        cookies = ngx_array_create(r->pool, 2, sizeof(ngx_str_t));
        if (cookies == NULL) {
            return NGX_ERROR;
        }

        r->stream->cookies = cookies;
    }

    val = ngx_array_push(cookies);
    if (val == NULL) {
        return NGX_ERROR;
    }

    val->len = header->value.len;
    val->data = header->value.data;

    return NGX_OK;
}",1,1,http\v2\ngx_http_v2.c,ngx_http_v2_cookie,,false,3619,3645,ngx_http_v2_cookie,,,131,"ngx_int_t ngx_http_v2_cookie (ngx_http_request_t*,ngx_http_v2_header_t*)"
338889,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_v2_construct_cookie_header(ngx_http_request_t *r)
{
    u_char                     *buf, *p, *end;
    size_t                      len;
    ngx_str_t                  *vals;
    ngx_uint_t                  i;
    ngx_array_t                *cookies;
    ngx_table_elt_t            *h;
    ngx_http_header_t          *hh;
    ngx_http_core_main_conf_t  *cmcf;

    static ngx_str_t cookie = ngx_string(""cookie"");

    cookies = r->stream->cookies;

    if (cookies == NULL) {
        return NGX_OK;
    }

    vals = cookies->elts;

    i = 0;
    len = 0;

    do {
        len += vals[i].len + 2;
    } while (++i != cookies->nelts);

    len -= 2;

    buf = ngx_pnalloc(r->pool, len + 1);
    if (buf == NULL) {
        ngx_http_v2_close_stream(r->stream, NGX_HTTP_INTERNAL_SERVER_ERROR);
        return NGX_ERROR;
    }

    p = buf;
    end = buf + len;

    for (i = 0; /* void */ ; i++) {

        p = ngx_cpymem(p, vals[i].data, vals[i].len);

        if (p == en...",1,1,http\v2\ngx_http_v2.c,ngx_http_v2_construct_cookie_header,,false,3648,3736,ngx_http_v2_construct_cookie_header,,,132,ngx_int_t ngx_http_v2_construct_cookie_header (ngx_http_request_t*)
339152,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static void
ngx_http_v2_run_request(ngx_http_request_t *r)
{
    ngx_connection_t          *fc;
    ngx_http_v2_connection_t  *h2c;

    fc = r->connection;

    if (ngx_http_v2_construct_request_line(r) != NGX_OK) {
        goto failed;
    }

    if (ngx_http_v2_construct_cookie_header(r) != NGX_OK) {
        goto failed;
    }

    r->http_state = NGX_HTTP_PROCESS_REQUEST_STATE;

    if (ngx_http_process_request_header(r) != NGX_OK) {
        goto failed;
    }

    if (r->headers_in.content_length_n > 0 && r->stream->in_closed) {
        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
                      ""client prematurely closed stream"");

        r->stream->skip_data = 1;

        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);
        goto failed;
    }

    if (r->headers_in.content_length_n == -1 && !r->stream->in_closed) {
        r->headers_in.chunked = 1;
    }

    h2c = r->stream->connection;

    h2c->payload_bytes += r->request_length;

    ngx_http_process...",1,1,http\v2\ngx_http_v2.c,ngx_http_v2_run_request,,false,3739,3784,ngx_http_v2_run_request,,,133,void ngx_http_v2_run_request (ngx_http_request_t*)
339268,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static void
ngx_http_v2_run_request_handler(ngx_event_t *ev)
{
    ngx_connection_t    *fc;
    ngx_http_request_t  *r;

    fc = ev->data;
    r = fc->data;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, fc->log, 0,
                   ""http2 run request handler"");

    ngx_http_v2_run_request(r);
}",1,1,http\v2\ngx_http_v2.c,ngx_http_v2_run_request_handler,,false,3787,3800,ngx_http_v2_run_request_handler,,,134,void ngx_http_v2_run_request_handler (ngx_event_t*)
339294,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_v2_read_request_body(ngx_http_request_t *r)
{
    off_t                      len;
    size_t                     size;
    ngx_buf_t                 *buf;
    ngx_int_t                  rc;
    ngx_http_v2_stream_t      *stream;
    ngx_http_v2_srv_conf_t    *h2scf;
    ngx_http_request_body_t   *rb;
    ngx_http_core_loc_conf_t  *clcf;
    ngx_http_v2_connection_t  *h2c;

    stream = r->stream;
    rb = r->request_body;

    if (stream->skip_data) {
        r->request_body_no_buffering = 0;
        rb->post_handler(r);
        return NGX_OK;
    }

    h2scf = ngx_http_get_module_srv_conf(r, ngx_http_v2_module);
    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    len = r->headers_in.content_length_n;

    if (r->request_body_no_buffering && !stream->in_closed) {

        if (len < 0 || len > (off_t) clcf->client_body_buffer_size) {
            len = clcf->client_body_buffer_size;
        }

        /*
         * We need a room to store data up...",1,1,http\v2\ngx_http_v2.c,ngx_http_v2_read_request_body,,false,3803,3935,ngx_http_v2_read_request_body,,,135,ngx_int_t ngx_http_v2_read_request_body (ngx_http_request_t*)
339678,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_v2_process_request_body(ngx_http_request_t *r, u_char *pos,
    size_t size, ngx_uint_t last)
{
    ngx_buf_t                 *buf;
    ngx_int_t                  rc;
    ngx_connection_t          *fc;
    ngx_http_request_body_t   *rb;
    ngx_http_core_loc_conf_t  *clcf;

    fc = r->connection;
    rb = r->request_body;
    buf = rb->buf;

    if (size) {
        if (buf->sync) {
            buf->pos = buf->start = pos;
            buf->last = buf->end = pos + size;

            r->request_body_in_file_only = 1;

        } else {
            if (size > (size_t) (buf->end - buf->last)) {
                ngx_log_error(NGX_LOG_INFO, fc->log, 0,
                              ""client intended to send body data ""
                              ""larger than declared"");

                return NGX_HTTP_BAD_REQUEST;
            }

            buf->last = ngx_cpymem(buf->last, pos, size);
        }
    }

    if (last) {
        rb->rest = 0;

        if (fc->read-...",1,1,http\v2\ngx_http_v2.c,ngx_http_v2_process_request_body,,false,3938,4022,ngx_http_v2_process_request_body,,,136,"ngx_int_t ngx_http_v2_process_request_body (ngx_http_request_t*,u_char*,size_t,ngx_uint_t)"
339895,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_v2_filter_request_body(ngx_http_request_t *r)
{
    ngx_buf_t                 *b, *buf;
    ngx_int_t                  rc;
    ngx_chain_t               *cl;
    ngx_http_request_body_t   *rb;
    ngx_http_core_loc_conf_t  *clcf;

    rb = r->request_body;
    buf = rb->buf;

    if (buf->pos == buf->last && rb->rest) {
        cl = NULL;
        goto update;
    }

    cl = ngx_chain_get_free_buf(r->pool, &rb->free);
    if (cl == NULL) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    b = cl->buf;

    ngx_memzero(b, sizeof(ngx_buf_t));

    if (buf->pos != buf->last) {
        r->request_length += buf->last - buf->pos;
        rb->received += buf->last - buf->pos;

        if (r->headers_in.content_length_n != -1) {
            if (rb->received > r->headers_in.content_length_n) {
                ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
                              ""client intended to send body data ""
                              ""la...",1,1,http\v2\ngx_http_v2.c,ngx_http_v2_filter_request_body,,false,4025,4113,ngx_http_v2_filter_request_body,,,137,ngx_int_t ngx_http_v2_filter_request_body (ngx_http_request_t*)
340185,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static void
ngx_http_v2_read_client_request_body_handler(ngx_http_request_t *r)
{
    ngx_connection_t  *fc;

    fc = r->connection;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, fc->log, 0,
                   ""http2 read client request body handler"");

    if (fc->read->timedout) {
        ngx_log_error(NGX_LOG_INFO, fc->log, NGX_ETIMEDOUT, ""client timed out"");

        fc->timedout = 1;
        r->stream->skip_data = 1;

        ngx_http_finalize_request(r, NGX_HTTP_REQUEST_TIME_OUT);
        return;
    }

    if (fc->error) {
        ngx_log_error(NGX_LOG_INFO, fc->log, 0,
                      ""client prematurely closed stream"");

        r->stream->skip_data = 1;

        ngx_http_finalize_request(r, NGX_HTTP_CLIENT_CLOSED_REQUEST);
        return;
    }
}",1,1,http\v2\ngx_http_v2.c,ngx_http_v2_read_client_request_body_handler,,false,4116,4145,ngx_http_v2_read_client_request_body_handler,,,138,void ngx_http_v2_read_client_request_body_handler (ngx_http_request_t*)
340256,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_v2_read_unbuffered_request_body(ngx_http_request_t *r)
{
    size_t                     window;
    ngx_buf_t                 *buf;
    ngx_int_t                  rc;
    ngx_connection_t          *fc;
    ngx_http_v2_stream_t      *stream;
    ngx_http_v2_connection_t  *h2c;
    ngx_http_core_loc_conf_t  *clcf;

    stream = r->stream;
    fc = r->connection;

    if (fc->read->timedout) {
        if (stream->recv_window) {
            stream->skip_data = 1;
            fc->timedout = 1;

            return NGX_HTTP_REQUEST_TIME_OUT;
        }

        fc->read->timedout = 0;
    }

    if (fc->error) {
        stream->skip_data = 1;
        return NGX_HTTP_BAD_REQUEST;
    }

    rc = ngx_http_v2_filter_request_body(r);

    if (rc != NGX_OK) {
        stream->skip_data = 1;
        return rc;
    }

    if (!r->request_body->rest) {
        return NGX_OK;
    }

    if (r->request_body->busy != NULL) {
        return NGX_AGAIN;
    }

    buf = r->request_body-...",1,1,http\v2\ngx_http_v2.c,ngx_http_v2_read_unbuffered_request_body,,false,4148,4237,ngx_http_v2_read_unbuffered_request_body,,,139,ngx_int_t ngx_http_v2_read_unbuffered_request_body (ngx_http_request_t*)
340503,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_v2_terminate_stream(ngx_http_v2_connection_t *h2c,
    ngx_http_v2_stream_t *stream, ngx_uint_t status)
{
    ngx_event_t       *rev;
    ngx_connection_t  *fc;

    if (stream->rst_sent) {
        return NGX_OK;
    }

    if (ngx_http_v2_send_rst_stream(h2c, stream->node->id, status)
        == NGX_ERROR)
    {
        return NGX_ERROR;
    }

    stream->rst_sent = 1;
    stream->skip_data = 1;

    fc = stream->request->connection;
    fc->error = 1;

    rev = fc->read;
    rev->handler(rev);

    return NGX_OK;
}",1,1,http\v2\ngx_http_v2.c,ngx_http_v2_terminate_stream,,false,4240,4267,ngx_http_v2_terminate_stream,,,140,"ngx_int_t ngx_http_v2_terminate_stream (ngx_http_v2_connection_t*,ngx_http_v2_stream_t*,ngx_uint_t)"
340567,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"void
ngx_http_v2_close_stream(ngx_http_v2_stream_t *stream, ngx_int_t rc)
{
    ngx_pool_t                *pool;
    ngx_uint_t                 push;
    ngx_event_t               *ev;
    ngx_connection_t          *fc;
    ngx_http_v2_node_t        *node;
    ngx_http_v2_connection_t  *h2c;

    h2c = stream->connection;
    node = stream->node;

    ngx_log_debug4(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
                   ""http2 close stream %ui, queued %ui, ""
                   ""processing %ui, pushing %ui"",
                   node->id, stream->queued, h2c->processing, h2c->pushing);

    fc = stream->request->connection;

    if (stream->queued) {
        fc->error = 1;
        fc->write->handler = ngx_http_v2_retry_close_stream_handler;
        fc->read->handler = ngx_http_v2_retry_close_stream_handler;
        return;
    }

    if (!stream->rst_sent && !h2c->connection->error) {

        if (!stream->out_closed) {
            if (ngx_http_v2_send_rst_stream(h2c, node->id...",1,53,http\v2\ngx_http_v2.c,ngx_http_v2_close_stream,,false,4270,4387,ngx_http_v2_close_stream,,,141,"void ngx_http_v2_close_stream (ngx_http_v2_stream_t*,ngx_int_t)"
340889,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static void
ngx_http_v2_close_stream_handler(ngx_event_t *ev)
{
    ngx_connection_t    *fc;
    ngx_http_request_t  *r;

    fc = ev->data;
    r = fc->data;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, fc->log, 0,
                   ""http2 close stream handler"");

    if (ev->timedout) {
        ngx_log_error(NGX_LOG_INFO, fc->log, NGX_ETIMEDOUT, ""client timed out"");

        fc->timedout = 1;

        ngx_http_v2_close_stream(r->stream, NGX_HTTP_REQUEST_TIME_OUT);
        return;
    }

    ngx_http_v2_close_stream(r->stream, 0);
}",1,1,http\v2\ngx_http_v2.c,ngx_http_v2_close_stream_handler,,false,4390,4412,ngx_http_v2_close_stream_handler,,,142,void ngx_http_v2_close_stream_handler (ngx_event_t*)
340941,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static void
ngx_http_v2_retry_close_stream_handler(ngx_event_t *ev)
{
    ngx_connection_t    *fc;
    ngx_http_request_t  *r;

    fc = ev->data;
    r = fc->data;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, fc->log, 0,
                   ""http2 retry close stream handler"");

    ngx_http_v2_close_stream(r->stream, 0);
}",1,1,http\v2\ngx_http_v2.c,ngx_http_v2_retry_close_stream_handler,,false,4415,4428,ngx_http_v2_retry_close_stream_handler,,,143,void ngx_http_v2_retry_close_stream_handler (ngx_event_t*)
340970,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static void
ngx_http_v2_handle_connection_handler(ngx_event_t *rev)
{
    ngx_connection_t          *c;
    ngx_http_v2_connection_t  *h2c;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, rev->log, 0,
                   ""http2 handle connection handler"");

    c = rev->data;
    h2c = c->data;

    if (c->error) {
        ngx_http_v2_finalize_connection(h2c, 0);
        return;
    }

    rev->handler = ngx_http_v2_read_handler;

    if (rev->ready) {
        ngx_http_v2_read_handler(rev);
        return;
    }

    if (h2c->last_out && ngx_http_v2_send_output_queue(h2c) == NGX_ERROR) {
        ngx_http_v2_finalize_connection(h2c, 0);
        return;
    }

    ngx_http_v2_handle_connection(c->data);
}",1,1,http\v2\ngx_http_v2.c,ngx_http_v2_handle_connection_handler,,false,4431,4461,ngx_http_v2_handle_connection_handler,,,144,void ngx_http_v2_handle_connection_handler (ngx_event_t*)
341034,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static void
ngx_http_v2_idle_handler(ngx_event_t *rev)
{
    ngx_connection_t          *c;
    ngx_http_v2_srv_conf_t    *h2scf;
    ngx_http_v2_connection_t  *h2c;

    c = rev->data;
    h2c = c->data;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0, ""http2 idle handler"");

    if (rev->timedout || c->close) {
        ngx_http_v2_finalize_connection(h2c, NGX_HTTP_V2_NO_ERROR);
        return;
    }

#if (NGX_HAVE_KQUEUE)

    if (ngx_event_flags & NGX_USE_KQUEUE_EVENT) {
        if (rev->pending_eof) {
            c->log->handler = NULL;
            ngx_log_error(NGX_LOG_INFO, c->log, rev->kq_errno,
                          ""kevent() reported that client %V closed ""
                          ""idle connection"", &c->addr_text);
#if (NGX_HTTP_SSL)
            if (c->ssl) {
                c->ssl->no_send_shutdown = 1;
            }
#endif
            ngx_http_close_connection(c);
            return;
        }
    }

#endif

    h2scf = ngx_http_get_module_srv_conf(h2c->http_connec...",1,45,http\v2\ngx_http_v2.c,ngx_http_v2_idle_handler,,false,4464,4524,ngx_http_v2_idle_handler,,,145,void ngx_http_v2_idle_handler (ngx_event_t*)
341158,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static void
ngx_http_v2_finalize_connection(ngx_http_v2_connection_t *h2c,
    ngx_uint_t status)
{
    ngx_uint_t               i, size;
    ngx_event_t             *ev;
    ngx_connection_t        *c, *fc;
    ngx_http_request_t      *r;
    ngx_http_v2_node_t      *node;
    ngx_http_v2_stream_t    *stream;
    ngx_http_v2_srv_conf_t  *h2scf;

    c = h2c->connection;

    h2c->blocked = 1;

    if (!c->error && !h2c->goaway) {
        if (ngx_http_v2_send_goaway(h2c, status) != NGX_ERROR) {
            (void) ngx_http_v2_send_output_queue(h2c);
        }
    }

    c->error = 1;

    if (!h2c->processing && !h2c->pushing) {
        ngx_http_close_connection(c);
        return;
    }

    c->read->handler = ngx_http_empty_handler;
    c->write->handler = ngx_http_empty_handler;

    h2c->last_out = NULL;

    h2scf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,
                                         ngx_http_v2_module);

    size = ngx_http_v2_index_size(h2scf);...",1,11,http\v2\ngx_http_v2.c,ngx_http_v2_finalize_connection,,false,4527,4605,ngx_http_v2_finalize_connection,,,146,"void ngx_http_v2_finalize_connection (ngx_http_v2_connection_t*,ngx_uint_t)"
341379,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_v2_adjust_windows(ngx_http_v2_connection_t *h2c, ssize_t delta)
{
    ngx_uint_t               i, size;
    ngx_event_t             *wev;
    ngx_http_v2_node_t      *node;
    ngx_http_v2_stream_t    *stream;
    ngx_http_v2_srv_conf_t  *h2scf;

    h2scf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,
                                         ngx_http_v2_module);

    size = ngx_http_v2_index_size(h2scf);

    for (i = 0; i < size; i++) {

        for (node = h2c->streams_index[i]; node; node = node->index) {
            stream = node->stream;

            if (stream == NULL) {
                continue;
            }

            if (delta > 0
                && stream->send_window
                      > (ssize_t) (NGX_HTTP_V2_MAX_WINDOW - delta))
            {
                if (ngx_http_v2_terminate_stream(h2c, stream,
                                                 NGX_HTTP_V2_FLOW_CTRL_ERROR)
                    == NGX_ERROR)
        ...",1,11,http\v2\ngx_http_v2.c,ngx_http_v2_adjust_windows,,false,4608,4667,ngx_http_v2_adjust_windows,,,147,"ngx_int_t ngx_http_v2_adjust_windows (ngx_http_v2_connection_t*,ssize_t)"
341543,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static void
ngx_http_v2_set_dependency(ngx_http_v2_connection_t *h2c,
    ngx_http_v2_node_t *node, ngx_uint_t depend, ngx_uint_t exclusive)
{
    ngx_queue_t         *children, *q;
    ngx_http_v2_node_t  *parent, *child, *next;

    parent = depend ? ngx_http_v2_get_node_by_id(h2c, depend, 0) : NULL;

    if (parent == NULL) {
        parent = NGX_HTTP_V2_ROOT;

        if (depend != 0) {
            exclusive = 0;
        }

        node->rank = 1;
        node->rel_weight = (1.0 / 256) * node->weight;

        children = &h2c->dependencies;

    } else {
        if (node->parent != NULL) {

            for (next = parent->parent;
                 next != NGX_HTTP_V2_ROOT && next->rank >= node->rank;
                 next = next->parent)
            {
                if (next != node) {
                    continue;
                }

                ngx_queue_remove(&parent->queue);
                ngx_queue_insert_after(&node->queue, &parent->queue);

                parent->pa...",1,17,http\v2\ngx_http_v2.c,ngx_http_v2_set_dependency,,false,4670,4758,ngx_http_v2_set_dependency,,,148,"void ngx_http_v2_set_dependency (ngx_http_v2_connection_t*,ngx_http_v2_node_t*,ngx_uint_t,ngx_uint_t)"
341847,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static void
ngx_http_v2_node_children_update(ngx_http_v2_node_t *node)
{
    ngx_queue_t         *q;
    ngx_http_v2_node_t  *child;

    for (q = ngx_queue_head(&node->children);
         q != ngx_queue_sentinel(&node->children);
         q = ngx_queue_next(q))
    {
        child = ngx_queue_data(q, ngx_http_v2_node_t, queue);

        child->rank = node->rank + 1;
        child->rel_weight = (node->rel_weight / 256) * child->weight;

        ngx_http_v2_node_children_update(child);
    }
}",1,1,http\v2\ngx_http_v2.c,ngx_http_v2_node_children_update,,false,4761,4778,ngx_http_v2_node_children_update,,,149,void ngx_http_v2_node_children_update (ngx_http_v2_node_t*)
341905,METHOD,http\v2\ngx_http_v2.c:<global>,TYPE_DECL,"static void
ngx_http_v2_pool_cleanup(void *data)
{
    ngx_http_v2_connection_t  *h2c = data;

    if (h2c->state.pool) {
        ngx_destroy_pool(h2c->state.pool);
    }

    if (h2c->pool) {
        ngx_destroy_pool(h2c->pool);
    }
}",1,1,http\v2\ngx_http_v2.c,ngx_http_v2_pool_cleanup,,false,4781,4793,ngx_http_v2_pool_cleanup,,,150,void ngx_http_v2_pool_cleanup (void*)
341945,METHOD,http\v2\ngx_http_v2.h:<global>,TYPE_DECL,<global>,1,44,http\v2\ngx_http_v2.h,http\v2\ngx_http_v2.h:<global>,,false,1,421,<global>,,,1,
341953,METHOD,http\v2\ngx_http_v2.h:<global>,TYPE_DECL,"typedef u_char *(*ngx_http_v2_handler_pt) (ngx_http_v2_connection_t *h2c,
    u_char *pos, u_char *end);",16,29,http\v2\ngx_http_v2.h,ngx_http_v2_handler_pt,,false,63,64,ngx_http_v2_handler_pt,,,7,"u_char* ngx_http_v2_handler_pt (ngx_http_v2_connection_t*,u_char*,u_char*)"
341985,METHOD,<empty>,<empty>,<empty>,1,,http\v2\ngx_http_v2.h,ngx_http_v2_state_t:<clinit>,,false,73,,<clinit>,,,21,
342076,METHOD,ngx_http_v2_out_frame_s,TYPE_DECL,"ngx_int_t                      (*handler)(ngx_http_v2_connection_t *h2c,
                                        ngx_http_v2_out_frame_t *frame);",36,71,http\v2\ngx_http_v2.h,ngx_http_v2_out_frame_s.handler,,false,226,227,handler,,,4,"ngx_int_t ngx_http_v2_out_frame_s.handler (ngx_http_v2_connection_t*,ngx_http_v2_out_frame_t*)"
342089,METHOD,http\v2\ngx_http_v2.h:<global>,TYPE_DECL,void ngx_http_v2_init(ngx_event_t *rev);,6,39,http\v2\ngx_http_v2.h,ngx_http_v2_init,,false,290,290,ngx_http_v2_init,,,21,void ngx_http_v2_init (ngx_event_t*)
342094,METHOD,http\v2\ngx_http_v2.h:<global>,TYPE_DECL,ngx_int_t ngx_http_v2_read_request_body(ngx_http_request_t *r);,11,62,http\v2\ngx_http_v2.h,ngx_http_v2_read_request_body,,false,292,292,ngx_http_v2_read_request_body,,,22,ngx_int_t ngx_http_v2_read_request_body (ngx_http_request_t*)
342099,METHOD,http\v2\ngx_http_v2.h:<global>,TYPE_DECL,ngx_int_t ngx_http_v2_read_unbuffered_request_body(ngx_http_request_t *r);,11,73,http\v2\ngx_http_v2.h,ngx_http_v2_read_unbuffered_request_body,,false,293,293,ngx_http_v2_read_unbuffered_request_body,,,23,ngx_int_t ngx_http_v2_read_unbuffered_request_body (ngx_http_request_t*)
342104,METHOD,http\v2\ngx_http_v2.h:<global>,TYPE_DECL,"ngx_http_v2_stream_t *ngx_http_v2_push_stream(ngx_http_v2_stream_t *parent,
    ngx_str_t *path);",22,20,http\v2\ngx_http_v2.h,ngx_http_v2_push_stream,,false,295,296,ngx_http_v2_push_stream,,,24,"ngx_http_v2_stream_t* ngx_http_v2_push_stream (ngx_http_v2_stream_t*,ngx_str_t*)"
342110,METHOD,http\v2\ngx_http_v2.h:<global>,TYPE_DECL,"void ngx_http_v2_close_stream(ngx_http_v2_stream_t *stream, ngx_int_t rc);",6,73,http\v2\ngx_http_v2.h,ngx_http_v2_close_stream,,false,298,298,ngx_http_v2_close_stream,,,25,"void ngx_http_v2_close_stream (ngx_http_v2_stream_t*,ngx_int_t)"
342116,METHOD,http\v2\ngx_http_v2.h:<global>,TYPE_DECL,ngx_int_t ngx_http_v2_send_output_queue(ngx_http_v2_connection_t *h2c);,11,70,http\v2\ngx_http_v2.h,ngx_http_v2_send_output_queue,,false,300,300,ngx_http_v2_send_output_queue,,,26,ngx_int_t ngx_http_v2_send_output_queue (ngx_http_v2_connection_t*)
342121,METHOD,http\v2\ngx_http_v2.h:<global>,TYPE_DECL,ngx_str_t *ngx_http_v2_get_static_name(ngx_uint_t index);,11,56,http\v2\ngx_http_v2.h,ngx_http_v2_get_static_name,,false,303,303,ngx_http_v2_get_static_name,,,27,ngx_str_t* ngx_http_v2_get_static_name (ngx_uint_t)
342126,METHOD,http\v2\ngx_http_v2.h:<global>,TYPE_DECL,ngx_str_t *ngx_http_v2_get_static_value(ngx_uint_t index);,11,57,http\v2\ngx_http_v2.h,ngx_http_v2_get_static_value,,false,304,304,ngx_http_v2_get_static_value,,,28,ngx_str_t* ngx_http_v2_get_static_value (ngx_uint_t)
342131,METHOD,http\v2\ngx_http_v2.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_v2_get_indexed_header(ngx_http_v2_connection_t *h2c,
    ngx_uint_t index, ngx_uint_t name_only);",11,43,http\v2\ngx_http_v2.h,ngx_http_v2_get_indexed_header,,false,306,307,ngx_http_v2_get_indexed_header,,,29,"ngx_int_t ngx_http_v2_get_indexed_header (ngx_http_v2_connection_t*,ngx_uint_t,ngx_uint_t)"
342138,METHOD,http\v2\ngx_http_v2.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_v2_add_header(ngx_http_v2_connection_t *h2c,
    ngx_http_v2_header_t *header);",11,33,http\v2\ngx_http_v2.h,ngx_http_v2_add_header,,false,308,309,ngx_http_v2_add_header,,,30,"ngx_int_t ngx_http_v2_add_header (ngx_http_v2_connection_t*,ngx_http_v2_header_t*)"
342144,METHOD,http\v2\ngx_http_v2.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_v2_table_size(ngx_http_v2_connection_t *h2c, size_t size);",11,76,http\v2\ngx_http_v2.h,ngx_http_v2_table_size,,false,310,310,ngx_http_v2_table_size,,,31,"ngx_int_t ngx_http_v2_table_size (ngx_http_v2_connection_t*,size_t)"
342150,METHOD,http\v2\ngx_http_v2.h:<global>,TYPE_DECL,"ngx_int_t ngx_http_v2_huff_decode(u_char *state, u_char *src, size_t len,
    u_char **dst, ngx_uint_t last, ngx_log_t *log);",11,50,http\v2\ngx_http_v2.h,ngx_http_v2_huff_decode,,false,313,314,ngx_http_v2_huff_decode,,,32,"ngx_int_t ngx_http_v2_huff_decode (u_char*,u_char*,size_t,u_char**,ngx_uint_t,ngx_log_t*)"
342160,METHOD,http\v2\ngx_http_v2.h:<global>,TYPE_DECL,"size_t ngx_http_v2_huff_encode(u_char *src, size_t len, u_char *dst,
    ngx_uint_t lower);",8,21,http\v2\ngx_http_v2.h,ngx_http_v2_huff_encode,,false,315,316,ngx_http_v2_huff_encode,,,33,"size_t ngx_http_v2_huff_encode (u_char*,size_t,u_char*,ngx_uint_t)"
342168,METHOD,http\v2\ngx_http_v2.h:<global>,TYPE_DECL,"u_char *ngx_http_v2_string_encode(u_char *dst, u_char *src, size_t len,
    u_char *tmp, ngx_uint_t lower);",8,34,http\v2\ngx_http_v2.h,ngx_http_v2_string_encode,,false,417,418,ngx_http_v2_string_encode,,,34,"u_char* ngx_http_v2_string_encode (u_char*,u_char*,size_t,u_char*,ngx_uint_t)"
342186,METHOD,http\v2\ngx_http_v2_encode.c:<global>,TYPE_DECL,<global>,1,1,http\v2\ngx_http_v2_encode.c,http\v2\ngx_http_v2_encode.c:<global>,,false,1,62,<global>,,,1,
342188,METHOD,http\v2\ngx_http_v2_encode.c:<global>,TYPE_DECL,"static u_char *ngx_http_v2_write_int(u_char *pos, ngx_uint_t prefix,
    ngx_uint_t value);",15,21,http\v2\ngx_http_v2_encode.c,ngx_http_v2_write_int,,false,13,14,ngx_http_v2_write_int,,,1,"u_char* ngx_http_v2_write_int (u_char*,ngx_uint_t,ngx_uint_t)"
342195,METHOD,http\v2\ngx_http_v2_encode.c:<global>,TYPE_DECL,"u_char *
ngx_http_v2_string_encode(u_char *dst, u_char *src, size_t len, u_char *tmp,
    ngx_uint_t lower)
{
    size_t  hlen;

    hlen = ngx_http_v2_huff_encode(src, len, tmp, lower);

    if (hlen > 0) {
        *dst = NGX_HTTP_V2_ENCODE_HUFF;
        dst = ngx_http_v2_write_int(dst, ngx_http_v2_prefix(7), hlen);
        return ngx_cpymem(dst, tmp, hlen);
    }

    *dst = NGX_HTTP_V2_ENCODE_RAW;
    dst = ngx_http_v2_write_int(dst, ngx_http_v2_prefix(7), len);

    if (lower) {
        ngx_strlow(dst, src, len);
        return dst + len;
    }

    return ngx_cpymem(dst, src, len);
}",1,1,http\v2\ngx_http_v2_encode.c,ngx_http_v2_string_encode,,false,17,40,ngx_http_v2_string_encode,,,2,"u_char ngx_http_v2_string_encode (u_char*,u_char*,size_t,u_char*,ngx_uint_t)"
342260,METHOD,http\v2\ngx_http_v2_encode.c:<global>,TYPE_DECL,"static u_char *
ngx_http_v2_write_int(u_char *pos, ngx_uint_t prefix, ngx_uint_t value)
{
    if (value < prefix) {
        *pos++ |= value;
        return pos;
    }

    *pos++ |= prefix;
    value -= prefix;

    while (value >= 128) {
        *pos++ = value % 128 + 128;
        value /= 128;
    }

    *pos++ = (u_char) value;

    return pos;
}",1,1,http\v2\ngx_http_v2_encode.c,ngx_http_v2_write_int,,false,43,62,ngx_http_v2_write_int,,,3,"u_char ngx_http_v2_write_int (u_char*,ngx_uint_t,ngx_uint_t)"
342326,METHOD,http\v2\ngx_http_v2_filter_module.c:<global>,TYPE_DECL,<global>,1,34,http\v2\ngx_http_v2_filter_module.c,http\v2\ngx_http_v2_filter_module.c:<global>,,false,1,2176,<global>,,,1,
342365,METHOD,http\v2\ngx_http_v2_filter_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_v2_push_resources(ngx_http_request_t *r);,18,66,http\v2\ngx_http_v2_filter_module.c,ngx_http_v2_push_resources,,false,55,55,ngx_http_v2_push_resources,,,5,ngx_int_t ngx_http_v2_push_resources (ngx_http_request_t*)
342370,METHOD,http\v2\ngx_http_v2_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_v2_push_resource(ngx_http_request_t *r,
    ngx_str_t *path, ngx_str_t *binary);",18,39,http\v2\ngx_http_v2_filter_module.c,ngx_http_v2_push_resource,,false,56,57,ngx_http_v2_push_resource,,,6,"ngx_int_t ngx_http_v2_push_resource (ngx_http_request_t*,ngx_str_t*,ngx_str_t*)"
342377,METHOD,http\v2\ngx_http_v2_filter_module.c:<global>,TYPE_DECL,"static ngx_http_v2_out_frame_t *ngx_http_v2_create_headers_frame(
    ngx_http_request_t *r, u_char *pos, u_char *end, ngx_uint_t fin);",32,68,http\v2\ngx_http_v2_filter_module.c,ngx_http_v2_create_headers_frame,,false,59,60,ngx_http_v2_create_headers_frame,,,7,"ngx_http_v2_out_frame_t* ngx_http_v2_create_headers_frame (ngx_http_request_t*,u_char*,u_char*,ngx_uint_t)"
342385,METHOD,http\v2\ngx_http_v2_filter_module.c:<global>,TYPE_DECL,"static ngx_http_v2_out_frame_t *ngx_http_v2_create_push_frame(
    ngx_http_request_t *r, u_char *pos, u_char *end);",32,52,http\v2\ngx_http_v2_filter_module.c,ngx_http_v2_create_push_frame,,false,61,62,ngx_http_v2_create_push_frame,,,8,"ngx_http_v2_out_frame_t* ngx_http_v2_create_push_frame (ngx_http_request_t*,u_char*,u_char*)"
342392,METHOD,http\v2\ngx_http_v2_filter_module.c:<global>,TYPE_DECL,"static ngx_http_v2_out_frame_t *ngx_http_v2_create_trailers_frame(
    ngx_http_request_t *r);",32,26,http\v2\ngx_http_v2_filter_module.c,ngx_http_v2_create_trailers_frame,,false,63,64,ngx_http_v2_create_trailers_frame,,,9,ngx_http_v2_out_frame_t* ngx_http_v2_create_trailers_frame (ngx_http_request_t*)
342397,METHOD,http\v2\ngx_http_v2_filter_module.c:<global>,TYPE_DECL,"static ngx_chain_t *ngx_http_v2_send_chain(ngx_connection_t *fc,
    ngx_chain_t *in, off_t limit);",20,33,http\v2\ngx_http_v2_filter_module.c,ngx_http_v2_send_chain,,false,66,67,ngx_http_v2_send_chain,,,10,"ngx_chain_t* ngx_http_v2_send_chain (ngx_connection_t*,ngx_chain_t*,off_t)"
342404,METHOD,http\v2\ngx_http_v2_filter_module.c:<global>,TYPE_DECL,"static ngx_chain_t *ngx_http_v2_filter_get_shadow(
    ngx_http_v2_stream_t *stream, ngx_buf_t *buf, off_t offset, off_t size);",20,75,http\v2\ngx_http_v2_filter_module.c,ngx_http_v2_filter_get_shadow,,false,69,70,ngx_http_v2_filter_get_shadow,,,11,"ngx_chain_t* ngx_http_v2_filter_get_shadow (ngx_http_v2_stream_t*,ngx_buf_t*,off_t,off_t)"
342412,METHOD,http\v2\ngx_http_v2_filter_module.c:<global>,TYPE_DECL,"static ngx_http_v2_out_frame_t *ngx_http_v2_filter_get_data_frame(
    ngx_http_v2_stream_t *stream, size_t len, ngx_chain_t *first,
    ngx_chain_t *last);",32,22,http\v2\ngx_http_v2_filter_module.c,ngx_http_v2_filter_get_data_frame,,false,71,73,ngx_http_v2_filter_get_data_frame,,,12,"ngx_http_v2_out_frame_t* ngx_http_v2_filter_get_data_frame (ngx_http_v2_stream_t*,size_t,ngx_chain_t*,ngx_chain_t*)"
342421,METHOD,http\v2\ngx_http_v2_filter_module.c:<global>,TYPE_DECL,"static void ngx_http_v2_waiting_queue(ngx_http_v2_connection_t *h2c,
    ngx_http_v2_stream_t *stream);",13,33,http\v2\ngx_http_v2_filter_module.c,ngx_http_v2_waiting_queue,,false,77,78,ngx_http_v2_waiting_queue,,,14,"void ngx_http_v2_waiting_queue (ngx_http_v2_connection_t*,ngx_http_v2_stream_t*)"
342428,METHOD,http\v2\ngx_http_v2_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_v2_headers_frame_handler(
    ngx_http_v2_connection_t *h2c, ngx_http_v2_out_frame_t *frame);",18,66,http\v2\ngx_http_v2_filter_module.c,ngx_http_v2_headers_frame_handler,,false,83,84,ngx_http_v2_headers_frame_handler,,,16,"ngx_int_t ngx_http_v2_headers_frame_handler (ngx_http_v2_connection_t*,ngx_http_v2_out_frame_t*)"
342434,METHOD,http\v2\ngx_http_v2_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_v2_push_frame_handler(
    ngx_http_v2_connection_t *h2c, ngx_http_v2_out_frame_t *frame);",18,66,http\v2\ngx_http_v2_filter_module.c,ngx_http_v2_push_frame_handler,,false,85,86,ngx_http_v2_push_frame_handler,,,17,"ngx_int_t ngx_http_v2_push_frame_handler (ngx_http_v2_connection_t*,ngx_http_v2_out_frame_t*)"
342440,METHOD,http\v2\ngx_http_v2_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_v2_data_frame_handler(
    ngx_http_v2_connection_t *h2c, ngx_http_v2_out_frame_t *frame);",18,66,http\v2\ngx_http_v2_filter_module.c,ngx_http_v2_data_frame_handler,,false,87,88,ngx_http_v2_data_frame_handler,,,18,"ngx_int_t ngx_http_v2_data_frame_handler (ngx_http_v2_connection_t*,ngx_http_v2_out_frame_t*)"
342448,METHOD,http\v2\ngx_http_v2_filter_module.c:<global>,TYPE_DECL,static void ngx_http_v2_filter_cleanup(void *data);,13,50,http\v2\ngx_http_v2_filter_module.c,ngx_http_v2_filter_cleanup,,false,94,94,ngx_http_v2_filter_cleanup,,,21,void ngx_http_v2_filter_cleanup (void*)
342453,METHOD,http\v2\ngx_http_v2_filter_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_v2_filter_init(ngx_conf_t *cf);,18,56,http\v2\ngx_http_v2_filter_module.c,ngx_http_v2_filter_init,,false,96,96,ngx_http_v2_filter_init,,,22,ngx_int_t ngx_http_v2_filter_init (ngx_conf_t*)
342488,METHOD,http\v2\ngx_http_v2_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_v2_header_filter(ngx_http_request_t *r)
{
    u_char                     status, *pos, *start, *p, *tmp;
    size_t                     len, tmp_len;
    ngx_str_t                  host, location;
    ngx_uint_t                 i, port, fin;
    ngx_list_part_t           *part;
    ngx_table_elt_t           *header;
    ngx_connection_t          *fc;
    ngx_http_cleanup_t        *cln;
    ngx_http_v2_stream_t      *stream;
    ngx_http_v2_out_frame_t   *frame;
    ngx_http_v2_connection_t  *h2c;
    ngx_http_core_loc_conf_t  *clcf;
    ngx_http_core_srv_conf_t  *cscf;
    u_char                     addr[NGX_SOCKADDR_STRLEN];

    static const u_char nginx[5] = ""\x84\xaa\x63\x55\xe7"";
#if (NGX_HTTP_GZIP)
    static const u_char accept_encoding[12] =
        ""\x8b\x84\x84\x2d\x69\x5b\x05\x44\x3c\x86\xaa\x6f"";
#endif

    static size_t nginx_ver_len = ngx_http_v2_literal_size(NGINX_VER);
    static u_char nginx_ver[ngx_http_v2_literal_size(NGINX_VER)];

    s...",1,34,http\v2\ngx_http_v2_filter_module.c,ngx_http_v2_header_filter,,false,133,670,ngx_http_v2_header_filter,,,28,ngx_int_t ngx_http_v2_header_filter (ngx_http_request_t*)
344312,METHOD,http\v2\ngx_http_v2_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_v2_push_resources(ngx_http_request_t *r)
{
    u_char                     *start, *end, *last;
    ngx_int_t                   rc;
    ngx_str_t                   path;
    ngx_uint_t                  i, push;
    ngx_table_elt_t           **h;
    ngx_http_v2_loc_conf_t     *h2lcf;
    ngx_http_complex_value_t   *pushes;
    ngx_str_t                   binary[NGX_HTTP_V2_PUSH_HEADERS];

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   ""http2 push resources"");

    ngx_memzero(binary, NGX_HTTP_V2_PUSH_HEADERS * sizeof(ngx_str_t));

    h2lcf = ngx_http_get_module_loc_conf(r, ngx_http_v2_module);

    if (h2lcf->pushes) {
        pushes = h2lcf->pushes->elts;

        for (i = 0; i < h2lcf->pushes->nelts; i++) {

            if (ngx_http_complex_value(r, &pushes[i], &path) != NGX_OK) {
                return NGX_ERROR;
            }

            if (path.len == 0) {
                continue;
            }

            if (path...",1,39,http\v2\ngx_http_v2_filter_module.c,ngx_http_v2_push_resources,,false,673,894,ngx_http_v2_push_resources,,,29,ngx_int_t ngx_http_v2_push_resources (ngx_http_request_t*)
344971,METHOD,http\v2\ngx_http_v2_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_v2_push_resource(ngx_http_request_t *r, ngx_str_t *path,
    ngx_str_t *binary)
{
    u_char                      *start, *pos, *tmp;
    size_t                       len;
    ngx_str_t                   *value;
    ngx_uint_t                   i;
    ngx_table_elt_t            **h;
    ngx_connection_t            *fc;
    ngx_http_v2_stream_t        *stream;
    ngx_http_v2_out_frame_t     *frame;
    ngx_http_v2_connection_t    *h2c;
    ngx_http_v2_push_header_t   *ph;

    fc = r->connection;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, fc->log, 0, ""http2 push resource"");

    stream = r->stream;
    h2c = stream->connection;

    if (!ngx_path_separator(path->data[0])) {
        ngx_log_error(NGX_LOG_WARN, fc->log, 0,
                      ""non-absolute path \""%V\"" not pushed"", path);
        return NGX_DECLINED;
    }

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
                   ""http2 pushing:%ui limit:%ui"",
                   h2c->p...",1,24,http\v2\ngx_http_v2_filter_module.c,ngx_http_v2_push_resource,,false,897,1075,ngx_http_v2_push_resource,,,30,"ngx_int_t ngx_http_v2_push_resource (ngx_http_request_t*,ngx_str_t*,ngx_str_t*)"
345629,METHOD,http\v2\ngx_http_v2_filter_module.c:<global>,TYPE_DECL,"static ngx_http_v2_out_frame_t *
ngx_http_v2_create_headers_frame(ngx_http_request_t *r, u_char *pos,
    u_char *end, ngx_uint_t fin)
{
    u_char                    type, flags;
    size_t                    rest, frame_size;
    ngx_buf_t                *b;
    ngx_chain_t              *cl, **ll;
    ngx_http_v2_stream_t     *stream;
    ngx_http_v2_out_frame_t  *frame;

    stream = r->stream;
    rest = end - pos;

    frame = ngx_palloc(r->pool, sizeof(ngx_http_v2_out_frame_t));
    if (frame == NULL) {
        return NULL;
    }

    frame->handler = ngx_http_v2_headers_frame_handler;
    frame->stream = stream;
    frame->length = rest;
    frame->blocked = 1;
    frame->fin = fin;

    ll = &frame->first;

    type = NGX_HTTP_V2_HEADERS_FRAME;
    flags = fin ? NGX_HTTP_V2_END_STREAM_FLAG : NGX_HTTP_V2_NO_FLAG;
    frame_size = stream->connection->frame_size;

    for ( ;; ) {
        if (rest <= frame_size) {
            frame_size = rest;
            flags |= NGX_HTTP_V2_...",1,1,http\v2\ngx_http_v2_filter_module.c,ngx_http_v2_create_headers_frame,,false,1078,1180,ngx_http_v2_create_headers_frame,,,31,"ngx_http_v2_out_frame_t ngx_http_v2_create_headers_frame (ngx_http_request_t*,u_char*,u_char*,ngx_uint_t)"
345938,METHOD,http\v2\ngx_http_v2_filter_module.c:<global>,TYPE_DECL,"static ngx_http_v2_out_frame_t *
ngx_http_v2_create_push_frame(ngx_http_request_t *r, u_char *pos, u_char *end)
{
    u_char                     type, flags;
    size_t                     rest, frame_size, len;
    ngx_buf_t                 *b;
    ngx_chain_t               *cl, **ll;
    ngx_http_v2_stream_t      *stream;
    ngx_http_v2_out_frame_t   *frame;
    ngx_http_v2_connection_t  *h2c;

    stream = r->stream;
    h2c = stream->connection;
    rest = NGX_HTTP_V2_STREAM_ID_SIZE + (end - pos);

    frame = ngx_palloc(r->pool, sizeof(ngx_http_v2_out_frame_t));
    if (frame == NULL) {
        return NULL;
    }

    frame->handler = ngx_http_v2_push_frame_handler;
    frame->stream = stream;
    frame->length = rest;
    frame->blocked = 1;
    frame->fin = 0;

    ll = &frame->first;

    type = NGX_HTTP_V2_PUSH_PROMISE_FRAME;
    flags = NGX_HTTP_V2_NO_FLAG;
    frame_size = h2c->frame_size;

    for ( ;; ) {
        if (rest <= frame_size) {
            frame_size = rest;...",1,1,http\v2\ngx_http_v2_filter_module.c,ngx_http_v2_create_push_frame,,false,1183,1299,ngx_http_v2_create_push_frame,,,32,"ngx_http_v2_out_frame_t ngx_http_v2_create_push_frame (ngx_http_request_t*,u_char*,u_char*)"
346282,METHOD,http\v2\ngx_http_v2_filter_module.c:<global>,TYPE_DECL,"static ngx_http_v2_out_frame_t *
ngx_http_v2_create_trailers_frame(ngx_http_request_t *r)
{
    u_char            *pos, *start, *tmp;
    size_t             len, tmp_len;
    ngx_uint_t         i;
    ngx_list_part_t   *part;
    ngx_table_elt_t   *header;
    ngx_connection_t  *fc;

    fc = r->connection;
    len = 0;
    tmp_len = 0;

    part = &r->headers_out.trailers.part;
    header = part->elts;

    for (i = 0; /* void */; i++) {

        if (i >= part->nelts) {
            if (part->next == NULL) {
                break;
            }

            part = part->next;
            header = part->elts;
            i = 0;
        }

        if (header[i].hash == 0) {
            continue;
        }

        if (header[i].key.len > NGX_HTTP_V2_MAX_FIELD) {
            ngx_log_error(NGX_LOG_CRIT, fc->log, 0,
                          ""too long response trailer name: \""%V\"""",
                          &header[i].key);
            return NULL;
        }

        if (header[i].value...",1,15,http\v2\ngx_http_v2_filter_module.c,ngx_http_v2_create_trailers_frame,,false,1302,1413,ngx_http_v2_create_trailers_frame,,,33,ngx_http_v2_out_frame_t ngx_http_v2_create_trailers_frame (ngx_http_request_t*)
346639,METHOD,http\v2\ngx_http_v2_filter_module.c:<global>,TYPE_DECL,"static ngx_chain_t *
ngx_http_v2_send_chain(ngx_connection_t *fc, ngx_chain_t *in, off_t limit)
{
    off_t                      size, offset;
    size_t                     rest, frame_size;
    ngx_chain_t               *cl, *out, **ln;
    ngx_http_request_t        *r;
    ngx_http_v2_stream_t      *stream;
    ngx_http_v2_loc_conf_t    *h2lcf;
    ngx_http_v2_out_frame_t   *frame, *trailers;
    ngx_http_v2_connection_t  *h2c;

    r = fc->data;
    stream = r->stream;

#if (NGX_SUPPRESS_WARN)
    size = 0;
#endif

    while (in) {
        size = ngx_buf_size(in->buf);

        if (size || in->buf->last_buf) {
            break;
        }

        in = in->next;
    }

    if (in == NULL || stream->out_closed) {

        if (size) {
            ngx_log_error(NGX_LOG_ERR, fc->log, 0,
                          ""output on closed stream"");
            return NGX_CHAIN_ERROR;
        }

        if (stream->queued) {
            fc->write->active = 1;
            fc->write->ready = 0;...",1,15,http\v2\ngx_http_v2_filter_module.c,ngx_http_v2_send_chain,,false,1416,1632,ngx_http_v2_send_chain,,,34,"ngx_chain_t ngx_http_v2_send_chain (ngx_connection_t*,ngx_chain_t*,off_t)"
347251,METHOD,http\v2\ngx_http_v2_filter_module.c:<global>,TYPE_DECL,"static ngx_chain_t *
ngx_http_v2_filter_get_shadow(ngx_http_v2_stream_t *stream, ngx_buf_t *buf,
    off_t offset, off_t size)
{
    ngx_buf_t    *chunk;
    ngx_chain_t  *cl;

    cl = ngx_chain_get_free_buf(stream->request->pool, &stream->free_bufs);
    if (cl == NULL) {
        return NULL;
    }

    chunk = cl->buf;

    ngx_memcpy(chunk, buf, sizeof(ngx_buf_t));

    chunk->tag = (ngx_buf_tag_t) &ngx_http_v2_filter_get_shadow;
    chunk->shadow = buf;

    if (ngx_buf_in_memory(chunk)) {
        chunk->pos += offset;
        chunk->last = chunk->pos + size;
    }

    if (chunk->in_file) {
        chunk->file_pos += offset;
        chunk->file_last = chunk->file_pos + size;
    }

    return cl;
}",1,1,http\v2\ngx_http_v2_filter_module.c,ngx_http_v2_filter_get_shadow,,false,1635,1665,ngx_http_v2_filter_get_shadow,,,35,"ngx_chain_t ngx_http_v2_filter_get_shadow (ngx_http_v2_stream_t*,ngx_buf_t*,off_t,off_t)"
347341,METHOD,http\v2\ngx_http_v2_filter_module.c:<global>,TYPE_DECL,"static ngx_http_v2_out_frame_t *
ngx_http_v2_filter_get_data_frame(ngx_http_v2_stream_t *stream,
    size_t len, ngx_chain_t *first, ngx_chain_t *last)
{
    u_char                     flags;
    ngx_buf_t                 *buf;
    ngx_chain_t               *cl;
    ngx_http_v2_out_frame_t   *frame;
    ngx_http_v2_connection_t  *h2c;

    frame = stream->free_frames;
    h2c = stream->connection;

    if (frame) {
        stream->free_frames = frame->next;

    } else if (h2c->frames < 10000) {
        frame = ngx_palloc(stream->request->pool,
                           sizeof(ngx_http_v2_out_frame_t));
        if (frame == NULL) {
            return NULL;
        }

        stream->frames++;
        h2c->frames++;

    } else {
        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
                      ""http2 flood detected"");

        h2c->connection->error = 1;
        return NULL;
    }

    flags = last->buf->last_buf ? NGX_HTTP_V2_END_STREAM_FLAG : 0;

    ngx_log_debu...",1,1,http\v2\ngx_http_v2_filter_module.c,ngx_http_v2_filter_get_data_frame,,false,1668,1753,ngx_http_v2_filter_get_data_frame,,,36,"ngx_http_v2_out_frame_t ngx_http_v2_filter_get_data_frame (ngx_http_v2_stream_t*,size_t,ngx_chain_t*,ngx_chain_t*)"
347640,METHOD,http\v2\ngx_http_v2_filter_module.c:<global>,TYPE_DECL,"ngx_http_v2_flow_control(ngx_http_v2_connection_t *h2c,
    ngx_http_v2_stream_t *stream)
{
    ngx_log_debug3(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
                   ""http2:%ui windows: conn:%uz stream:%z"",
                   stream->node->id, h2c->send_window, stream->send_window);

    if (stream->send_window <= 0) {
        stream->exhausted = 1;
        return NGX_DECLINED;
    }

    if (h2c->send_window == 0) {
        ngx_http_v2_waiting_queue(h2c, stream);
        return NGX_DECLINED;
    }

    return NGX_OK;
}",1,1,http\v2\ngx_http_v2_filter_module.c,ngx_http_v2_flow_control,,false,1757,1775,ngx_http_v2_flow_control,,,39,"ANY ngx_http_v2_flow_control (ngx_http_v2_connection_t*,ngx_http_v2_stream_t*)"
347694,METHOD,http\v2\ngx_http_v2_filter_module.c:<global>,TYPE_DECL,"static void
ngx_http_v2_waiting_queue(ngx_http_v2_connection_t *h2c,
    ngx_http_v2_stream_t *stream)
{
    ngx_queue_t           *q;
    ngx_http_v2_stream_t  *s;

    if (stream->waiting) {
        return;
    }

    stream->waiting = 1;

    for (q = ngx_queue_last(&h2c->waiting);
         q != ngx_queue_sentinel(&h2c->waiting);
         q = ngx_queue_prev(q))
    {
        s = ngx_queue_data(q, ngx_http_v2_stream_t, queue);

        if (s->node->rank < stream->node->rank
            || (s->node->rank == stream->node->rank
                && s->node->rel_weight >= stream->node->rel_weight))
        {
            break;
        }
    }

    ngx_queue_insert_after(q, &stream->queue);
}",1,1,http\v2\ngx_http_v2_filter_module.c,ngx_http_v2_waiting_queue,,false,1778,1806,ngx_http_v2_waiting_queue,,,40,"void ngx_http_v2_waiting_queue (ngx_http_v2_connection_t*,ngx_http_v2_stream_t*)"
347786,METHOD,http\v2\ngx_http_v2_filter_module.c:<global>,TYPE_DECL,"ngx_http_v2_filter_send(ngx_connection_t *fc, ngx_http_v2_stream_t *stream)
{
    stream->blocked = 1;

    if (ngx_http_v2_send_output_queue(stream->connection) == NGX_ERROR) {
        fc->error = 1;
        return NGX_ERROR;
    }

    stream->blocked = 0;

    if (stream->queued) {
        fc->buffered |= NGX_HTTP_V2_BUFFERED;
        fc->write->active = 1;
        fc->write->ready = 0;
        return NGX_AGAIN;
    }

    fc->buffered &= ~NGX_HTTP_V2_BUFFERED;

    return NGX_OK;
}",1,1,http\v2\ngx_http_v2_filter_module.c,ngx_http_v2_filter_send,,false,1810,1831,ngx_http_v2_filter_send,,,43,"ANY ngx_http_v2_filter_send (ngx_connection_t*,ngx_http_v2_stream_t*)"
347851,METHOD,http\v2\ngx_http_v2_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_v2_headers_frame_handler(ngx_http_v2_connection_t *h2c,
    ngx_http_v2_out_frame_t *frame)
{
    ngx_chain_t           *cl, *ln;
    ngx_http_v2_stream_t  *stream;

    stream = frame->stream;
    cl = frame->first;

    for ( ;; ) {
        if (cl->buf->pos != cl->buf->last) {
            frame->first = cl;

            ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
                           ""http2:%ui HEADERS frame %p was sent partially"",
                           stream->node->id, frame);

            return NGX_AGAIN;
        }

        ln = cl->next;

        if (cl->buf->tag == (ngx_buf_tag_t) &ngx_http_v2_module) {
            cl->next = stream->free_frame_headers;
            stream->free_frame_headers = cl;

        } else {
            cl->next = stream->free_bufs;
            stream->free_bufs = cl;
        }

        if (cl == frame->last) {
            break;
        }

        cl = ln;
    }

    ngx_log_debug2(NGX_LOG_DEBUG_HT...",1,1,http\v2\ngx_http_v2_filter_module.c,ngx_http_v2_headers_frame_handler,,false,1834,1887,ngx_http_v2_headers_frame_handler,,,44,"ngx_int_t ngx_http_v2_headers_frame_handler (ngx_http_v2_connection_t*,ngx_http_v2_out_frame_t*)"
348002,METHOD,http\v2\ngx_http_v2_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_v2_push_frame_handler(ngx_http_v2_connection_t *h2c,
    ngx_http_v2_out_frame_t *frame)
{
    ngx_chain_t           *cl, *ln;
    ngx_http_v2_stream_t  *stream;

    stream = frame->stream;
    cl = frame->first;

    for ( ;; ) {
        if (cl->buf->pos != cl->buf->last) {
            frame->first = cl;

            ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
                           ""http2:%ui PUSH_PROMISE frame %p was sent partially"",
                           stream->node->id, frame);

            return NGX_AGAIN;
        }

        ln = cl->next;

        if (cl->buf->tag == (ngx_buf_tag_t) &ngx_http_v2_module) {
            cl->next = stream->free_frame_headers;
            stream->free_frame_headers = cl;

        } else {
            cl->next = stream->free_bufs;
            stream->free_bufs = cl;
        }

        if (cl == frame->last) {
            break;
        }

        cl = ln;
    }

    ngx_log_debug2(NGX_LOG_DEBUG_...",1,1,http\v2\ngx_http_v2_filter_module.c,ngx_http_v2_push_frame_handler,,false,1890,1943,ngx_http_v2_push_frame_handler,,,45,"ngx_int_t ngx_http_v2_push_frame_handler (ngx_http_v2_connection_t*,ngx_http_v2_out_frame_t*)"
348153,METHOD,http\v2\ngx_http_v2_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_v2_data_frame_handler(ngx_http_v2_connection_t *h2c,
    ngx_http_v2_out_frame_t *frame)
{
    ngx_buf_t             *buf;
    ngx_chain_t           *cl, *ln;
    ngx_http_v2_stream_t  *stream;

    stream = frame->stream;
    cl = frame->first;

    if (cl->buf->tag == (ngx_buf_tag_t) &ngx_http_v2_module) {

        if (cl->buf->pos != cl->buf->last) {
            ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
                           ""http2:%ui DATA frame %p was sent partially"",
                           stream->node->id, frame);

            return NGX_AGAIN;
        }

        ln = cl->next;

        cl->next = stream->free_frame_headers;
        stream->free_frame_headers = cl;

        if (cl == frame->last) {
            goto done;
        }

        cl = ln;
    }

    for ( ;; ) {
        if (cl->buf->tag == (ngx_buf_tag_t) &ngx_http_v2_filter_get_shadow) {
            buf = cl->buf->shadow;

            if (ngx_buf_in_memory(buf)) ...",1,1,http\v2\ngx_http_v2_filter_module.c,ngx_http_v2_data_frame_handler,,false,1946,2038,ngx_http_v2_data_frame_handler,,,46,"ngx_int_t ngx_http_v2_data_frame_handler (ngx_http_v2_connection_t*,ngx_http_v2_out_frame_t*)"
348418,METHOD,http\v2\ngx_http_v2_filter_module.c:<global>,TYPE_DECL,"static void
ngx_http_v2_filter_cleanup(void *data)
{
    ngx_http_v2_stream_t *stream = data;

    size_t                     window;
    ngx_event_t               *wev;
    ngx_queue_t               *q;
    ngx_http_v2_out_frame_t   *frame, **fn;
    ngx_http_v2_connection_t  *h2c;

    if (stream->waiting) {
        stream->waiting = 0;
        ngx_queue_remove(&stream->queue);
    }

    if (stream->queued == 0) {
        return;
    }

    window = 0;
    h2c = stream->connection;
    fn = &h2c->last_out;

    for ( ;; ) {
        frame = *fn;

        if (frame == NULL) {
            break;
        }

        if (frame->stream == stream && !frame->blocked) {
            *fn = frame->next;

            window += frame->length;

            if (--stream->queued == 0) {
                break;
            }

            continue;
        }

        fn = &frame->next;
    }

    if (h2c->send_window == 0 && window) {

        while (!ngx_queue_empty(&h2c->waiting)) {
            q =...",1,1,http\v2\ngx_http_v2_filter_module.c,ngx_http_v2_filter_cleanup,,false,2097,2166,ngx_http_v2_filter_cleanup,,,49,void ngx_http_v2_filter_cleanup (void*)
348593,METHOD,http\v2\ngx_http_v2_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_v2_filter_init(ngx_conf_t *cf)
{
    ngx_http_next_header_filter = ngx_http_top_header_filter;
    ngx_http_top_header_filter = ngx_http_v2_header_filter;

    return NGX_OK;
}",1,1,http\v2\ngx_http_v2_filter_module.c,ngx_http_v2_filter_init,,false,2169,2176,ngx_http_v2_filter_init,,,50,ngx_int_t ngx_http_v2_filter_init (ngx_conf_t*)
348615,METHOD,http\v2\ngx_http_v2_huff_decode.c:<global>,TYPE_DECL,<global>,1,1,http\v2\ngx_http_v2_huff_decode.c,http\v2\ngx_http_v2_huff_decode.c:<global>,,false,1,2714,<global>,,,1,
369364,METHOD,http\v2\ngx_http_v2_huff_decode.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_v2_huff_decode(u_char *state, u_char *src, size_t len, u_char **dst,
    ngx_uint_t last, ngx_log_t *log)
{
    u_char  *end, ch, ending;

    ch = 0;
    ending = 1;

    end = src + len;

    while (src != end) {
        ch = *src++;

        if (ngx_http_v2_huff_decode_bits(state, &ending, ch >> 4, dst)
            != NGX_OK)
        {
            ngx_log_debug2(NGX_LOG_DEBUG_HTTP, log, 0,
                           ""http2 huffman decoding error at state %d: ""
                           ""bad code 0x%Xd"", *state, ch >> 4);

            return NGX_ERROR;
        }

        if (ngx_http_v2_huff_decode_bits(state, &ending, ch & 0xf, dst)
            != NGX_OK)
        {
            ngx_log_debug2(NGX_LOG_DEBUG_HTTP, log, 0,
                           ""http2 huffman decoding error at state %d: ""
                           ""bad code 0x%Xd"", *state, ch & 0xf);

            return NGX_ERROR;
        }
    }

    if (last) {
        if (!ending) {
            ngx_log_de...",1,1,http\v2\ngx_http_v2_huff_decode.c,ngx_http_v2_huff_decode,,false,2642,2690,ngx_http_v2_huff_decode,,,6,"ngx_int_t ngx_http_v2_huff_decode (u_char*,u_char*,size_t,u_char**,ngx_uint_t,ngx_log_t*)"
369469,METHOD,http\v2\ngx_http_v2_huff_decode.c:<global>,TYPE_DECL,"ngx_http_v2_huff_decode_bits(u_char *state, u_char *ending, ngx_uint_t bits,
    u_char **dst)
{
    ngx_http_v2_huff_decode_code_t  code;

    code = ngx_http_v2_huff_decode_codes[*state][bits];

    if (code.next == *state) {
        return NGX_ERROR;
    }

    if (code.emit) {
        *(*dst)++ = code.sym;
    }

    *ending = code.ending;
    *state = code.next;

    return NGX_OK;
}",1,1,http\v2\ngx_http_v2_huff_decode.c,ngx_http_v2_huff_decode_bits,,false,2695,2714,ngx_http_v2_huff_decode_bits,,,9,"ANY ngx_http_v2_huff_decode_bits (u_char*,u_char*,ngx_uint_t,u_char**)"
369532,METHOD,http\v2\ngx_http_v2_huff_encode.c:<global>,TYPE_DECL,<global>,1,8,http\v2\ngx_http_v2_huff_encode.c,http\v2\ngx_http_v2_huff_encode.c:<global>,,false,1,254,<global>,,,1,
371082,METHOD,http\v2\ngx_http_v2_huff_encode.c:<global>,TYPE_DECL,"size_t
ngx_http_v2_huff_encode(u_char *src, size_t len, u_char *dst, ngx_uint_t lower)
{
    u_char                          *end;
    size_t                           hlen;
    ngx_uint_t                       buf, pending, code;
    ngx_http_v2_huff_encode_code_t  *table, *next;

    table = lower ? ngx_http_v2_huff_encode_table_lc
                  : ngx_http_v2_huff_encode_table;
    hlen = 0;
    buf = 0;
    pending = 0;

    end = src + len;

    while (src != end) {
        next = &table[*src++];

        code = next->code;
        pending += next->len;

        /* accumulate bits */
        if (pending < sizeof(buf) * 8) {
            buf |= code << (sizeof(buf) * 8 - pending);
            continue;
        }

        if (hlen + sizeof(buf) >= len) {
            return 0;
        }

        pending -= sizeof(buf) * 8;

        buf |= code >> pending;

        ngx_http_v2_huff_encode_buf(&dst[hlen], buf);

        hlen += sizeof(buf);

        buf = pending ? code << (sizeof...",1,8,http\v2\ngx_http_v2_huff_encode.c,ngx_http_v2_huff_encode,,false,191,254,ngx_http_v2_huff_encode,,,7,"size_t ngx_http_v2_huff_encode (u_char*,size_t,u_char*,ngx_uint_t)"
371280,METHOD,http\v2\ngx_http_v2_module.c:<global>,TYPE_DECL,<global>,1,1,http\v2\ngx_http_v2_module.c,http\v2\ngx_http_v2_module.c:<global>,,false,1,610,<global>,,,1,
371282,METHOD,http\v2\ngx_http_v2_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_v2_add_variables(ngx_conf_t *cf);,18,58,http\v2\ngx_http_v2_module.c,ngx_http_v2_add_variables,,false,14,14,ngx_http_v2_add_variables,,,1,ngx_int_t ngx_http_v2_add_variables (ngx_conf_t*)
371287,METHOD,http\v2\ngx_http_v2_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_v2_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);",18,49,http\v2\ngx_http_v2_module.c,ngx_http_v2_variable,,false,16,17,ngx_http_v2_variable,,,2,"ngx_int_t ngx_http_v2_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
371294,METHOD,http\v2\ngx_http_v2_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_http_v2_module_init(ngx_cycle_t *cycle);,18,60,http\v2\ngx_http_v2_module.c,ngx_http_v2_module_init,,false,19,19,ngx_http_v2_module_init,,,3,ngx_int_t ngx_http_v2_module_init (ngx_cycle_t*)
371299,METHOD,http\v2\ngx_http_v2_module.c:<global>,TYPE_DECL,static void *ngx_http_v2_create_main_conf(ngx_conf_t *cf);,13,57,http\v2\ngx_http_v2_module.c,ngx_http_v2_create_main_conf,,false,21,21,ngx_http_v2_create_main_conf,,,4,void* ngx_http_v2_create_main_conf (ngx_conf_t*)
371304,METHOD,http\v2\ngx_http_v2_module.c:<global>,TYPE_DECL,"static char *ngx_http_v2_init_main_conf(ngx_conf_t *cf, void *conf);",13,67,http\v2\ngx_http_v2_module.c,ngx_http_v2_init_main_conf,,false,22,22,ngx_http_v2_init_main_conf,,,5,"char* ngx_http_v2_init_main_conf (ngx_conf_t*,void*)"
371310,METHOD,http\v2\ngx_http_v2_module.c:<global>,TYPE_DECL,static void *ngx_http_v2_create_srv_conf(ngx_conf_t *cf);,13,56,http\v2\ngx_http_v2_module.c,ngx_http_v2_create_srv_conf,,false,23,23,ngx_http_v2_create_srv_conf,,,6,void* ngx_http_v2_create_srv_conf (ngx_conf_t*)
371315,METHOD,http\v2\ngx_http_v2_module.c:<global>,TYPE_DECL,"static char *ngx_http_v2_merge_srv_conf(ngx_conf_t *cf, void *parent,
    void *child);",13,16,http\v2\ngx_http_v2_module.c,ngx_http_v2_merge_srv_conf,,false,24,25,ngx_http_v2_merge_srv_conf,,,7,"char* ngx_http_v2_merge_srv_conf (ngx_conf_t*,void*,void*)"
371322,METHOD,http\v2\ngx_http_v2_module.c:<global>,TYPE_DECL,static void *ngx_http_v2_create_loc_conf(ngx_conf_t *cf);,13,56,http\v2\ngx_http_v2_module.c,ngx_http_v2_create_loc_conf,,false,26,26,ngx_http_v2_create_loc_conf,,,8,void* ngx_http_v2_create_loc_conf (ngx_conf_t*)
371327,METHOD,http\v2\ngx_http_v2_module.c:<global>,TYPE_DECL,"static char *ngx_http_v2_merge_loc_conf(ngx_conf_t *cf, void *parent,
    void *child);",13,16,http\v2\ngx_http_v2_module.c,ngx_http_v2_merge_loc_conf,,false,27,28,ngx_http_v2_merge_loc_conf,,,9,"char* ngx_http_v2_merge_loc_conf (ngx_conf_t*,void*,void*)"
371334,METHOD,http\v2\ngx_http_v2_module.c:<global>,TYPE_DECL,"static char *ngx_http_v2_push(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",13,77,http\v2\ngx_http_v2_module.c,ngx_http_v2_push,,false,30,30,ngx_http_v2_push,,,10,"char* ngx_http_v2_push (ngx_conf_t*,ngx_command_t*,void*)"
371341,METHOD,http\v2\ngx_http_v2_module.c:<global>,TYPE_DECL,"static char *ngx_http_v2_recv_buffer_size(ngx_conf_t *cf, void *post,
    void *data);",13,15,http\v2\ngx_http_v2_module.c,ngx_http_v2_recv_buffer_size,,false,32,33,ngx_http_v2_recv_buffer_size,,,11,"char* ngx_http_v2_recv_buffer_size (ngx_conf_t*,void*,void*)"
371348,METHOD,http\v2\ngx_http_v2_module.c:<global>,TYPE_DECL,"static char *ngx_http_v2_pool_size(ngx_conf_t *cf, void *post, void *data);",13,74,http\v2\ngx_http_v2_module.c,ngx_http_v2_pool_size,,false,34,34,ngx_http_v2_pool_size,,,12,"char* ngx_http_v2_pool_size (ngx_conf_t*,void*,void*)"
371355,METHOD,http\v2\ngx_http_v2_module.c:<global>,TYPE_DECL,"static char *ngx_http_v2_preread_size(ngx_conf_t *cf, void *post, void *data);",13,77,http\v2\ngx_http_v2_module.c,ngx_http_v2_preread_size,,false,35,35,ngx_http_v2_preread_size,,,13,"char* ngx_http_v2_preread_size (ngx_conf_t*,void*,void*)"
371362,METHOD,http\v2\ngx_http_v2_module.c:<global>,TYPE_DECL,"static char *ngx_http_v2_streams_index_mask(ngx_conf_t *cf, void *post,
    void *data);",13,15,http\v2\ngx_http_v2_module.c,ngx_http_v2_streams_index_mask,,false,36,37,ngx_http_v2_streams_index_mask,,,14,"char* ngx_http_v2_streams_index_mask (ngx_conf_t*,void*,void*)"
371369,METHOD,http\v2\ngx_http_v2_module.c:<global>,TYPE_DECL,"static char *ngx_http_v2_chunk_size(ngx_conf_t *cf, void *post, void *data);",13,75,http\v2\ngx_http_v2_module.c,ngx_http_v2_chunk_size,,false,38,38,ngx_http_v2_chunk_size,,,15,"char* ngx_http_v2_chunk_size (ngx_conf_t*,void*,void*)"
371376,METHOD,http\v2\ngx_http_v2_module.c:<global>,TYPE_DECL,"static char *ngx_http_v2_spdy_deprecated(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,http\v2\ngx_http_v2_module.c,ngx_http_v2_spdy_deprecated,,false,39,40,ngx_http_v2_spdy_deprecated,,,16,"char* ngx_http_v2_spdy_deprecated (ngx_conf_t*,ngx_command_t*,void*)"
371754,METHOD,http\v2\ngx_http_v2_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_v2_add_variables(ngx_conf_t *cf)
{
    ngx_http_variable_t  *var, *v;

    for (v = ngx_http_v2_vars; v->name.len; v++) {
        var = ngx_http_add_variable(cf, &v->name, v->flags);
        if (var == NULL) {
            return NGX_ERROR;
        }

        var->get_handler = v->get_handler;
        var->data = v->data;
    }

    return NGX_OK;
}",1,1,http\v2\ngx_http_v2_module.c,ngx_http_v2_add_variables,,false,255,271,ngx_http_v2_add_variables,,,35,ngx_int_t ngx_http_v2_add_variables (ngx_conf_t*)
371808,METHOD,http\v2\ngx_http_v2_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_v2_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{

    if (r->stream) {
#if (NGX_HTTP_SSL)

        if (r->connection->ssl) {
            v->len = sizeof(""h2"") - 1;
            v->valid = 1;
            v->no_cacheable = 0;
            v->not_found = 0;
            v->data = (u_char *) ""h2"";

            return NGX_OK;
        }

#endif
        v->len = sizeof(""h2c"") - 1;
        v->valid = 1;
        v->no_cacheable = 0;
        v->not_found = 0;
        v->data = (u_char *) ""h2c"";

        return NGX_OK;
    }

    *v = ngx_http_variable_null_value;

    return NGX_OK;
}",1,1,http\v2\ngx_http_v2_module.c,ngx_http_v2_variable,,false,274,305,ngx_http_v2_variable,,,36,"ngx_int_t ngx_http_v2_variable (ngx_http_request_t*,ngx_http_variable_value_t*,uintptr_t)"
371858,METHOD,http\v2\ngx_http_v2_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_v2_module_init(ngx_cycle_t *cycle)
{
    return NGX_OK;
}",1,1,http\v2\ngx_http_v2_module.c,ngx_http_v2_module_init,,false,308,312,ngx_http_v2_module_init,,,37,ngx_int_t ngx_http_v2_module_init (ngx_cycle_t*)
371865,METHOD,http\v2\ngx_http_v2_module.c:<global>,TYPE_DECL,"static void *
ngx_http_v2_create_main_conf(ngx_conf_t *cf)
{
    ngx_http_v2_main_conf_t  *h2mcf;

    h2mcf = ngx_pcalloc(cf->pool, sizeof(ngx_http_v2_main_conf_t));
    if (h2mcf == NULL) {
        return NULL;
    }

    h2mcf->recv_buffer_size = NGX_CONF_UNSET_SIZE;

    return h2mcf;
}",1,1,http\v2\ngx_http_v2_module.c,ngx_http_v2_create_main_conf,,false,315,328,ngx_http_v2_create_main_conf,,,38,void* ngx_http_v2_create_main_conf (ngx_conf_t*)
371893,METHOD,http\v2\ngx_http_v2_module.c:<global>,TYPE_DECL,"static char *
ngx_http_v2_init_main_conf(ngx_conf_t *cf, void *conf)
{
    ngx_http_v2_main_conf_t *h2mcf = conf;

    ngx_conf_init_size_value(h2mcf->recv_buffer_size, 256 * 1024);

    return NGX_CONF_OK;
}",1,1,http\v2\ngx_http_v2_module.c,ngx_http_v2_init_main_conf,,false,331,339,ngx_http_v2_init_main_conf,,,39,"char* ngx_http_v2_init_main_conf (ngx_conf_t*,void*)"
371912,METHOD,http\v2\ngx_http_v2_module.c:<global>,TYPE_DECL,"static void *
ngx_http_v2_create_srv_conf(ngx_conf_t *cf)
{
    ngx_http_v2_srv_conf_t  *h2scf;

    h2scf = ngx_pcalloc(cf->pool, sizeof(ngx_http_v2_srv_conf_t));
    if (h2scf == NULL) {
        return NULL;
    }

    h2scf->pool_size = NGX_CONF_UNSET_SIZE;

    h2scf->concurrent_streams = NGX_CONF_UNSET_UINT;
    h2scf->concurrent_pushes = NGX_CONF_UNSET_UINT;
    h2scf->max_requests = NGX_CONF_UNSET_UINT;

    h2scf->max_field_size = NGX_CONF_UNSET_SIZE;
    h2scf->max_header_size = NGX_CONF_UNSET_SIZE;

    h2scf->preread_size = NGX_CONF_UNSET_SIZE;

    h2scf->streams_index_mask = NGX_CONF_UNSET_UINT;

    h2scf->recv_timeout = NGX_CONF_UNSET_MSEC;
    h2scf->idle_timeout = NGX_CONF_UNSET_MSEC;

    return h2scf;
}",1,1,http\v2\ngx_http_v2_module.c,ngx_http_v2_create_srv_conf,,false,342,369,ngx_http_v2_create_srv_conf,,,40,void* ngx_http_v2_create_srv_conf (ngx_conf_t*)
371985,METHOD,http\v2\ngx_http_v2_module.c:<global>,TYPE_DECL,"static char *
ngx_http_v2_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_v2_srv_conf_t *prev = parent;
    ngx_http_v2_srv_conf_t *conf = child;

    ngx_conf_merge_size_value(conf->pool_size, prev->pool_size, 4096);

    ngx_conf_merge_uint_value(conf->concurrent_streams,
                              prev->concurrent_streams, 128);
    ngx_conf_merge_uint_value(conf->concurrent_pushes,
                              prev->concurrent_pushes, 10);
    ngx_conf_merge_uint_value(conf->max_requests, prev->max_requests, 1000);

    ngx_conf_merge_size_value(conf->max_field_size, prev->max_field_size,
                              4096);
    ngx_conf_merge_size_value(conf->max_header_size, prev->max_header_size,
                              16384);

    ngx_conf_merge_size_value(conf->preread_size, prev->preread_size, 65536);

    ngx_conf_merge_uint_value(conf->streams_index_mask,
                              prev->streams_index_mask, 32 - 1);

    ngx_conf_me...",1,1,http\v2\ngx_http_v2_module.c,ngx_http_v2_merge_srv_conf,,false,372,402,ngx_http_v2_merge_srv_conf,,,41,"char* ngx_http_v2_merge_srv_conf (ngx_conf_t*,void*,void*)"
372084,METHOD,http\v2\ngx_http_v2_module.c:<global>,TYPE_DECL,"static void *
ngx_http_v2_create_loc_conf(ngx_conf_t *cf)
{
    ngx_http_v2_loc_conf_t  *h2lcf;

    h2lcf = ngx_pcalloc(cf->pool, sizeof(ngx_http_v2_loc_conf_t));
    if (h2lcf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     h2lcf->pushes = NULL;
     */

    h2lcf->chunk_size = NGX_CONF_UNSET_SIZE;

    h2lcf->push_preload = NGX_CONF_UNSET;
    h2lcf->push = NGX_CONF_UNSET;

    return h2lcf;
}",1,1,http\v2\ngx_http_v2_module.c,ngx_http_v2_create_loc_conf,,false,405,427,ngx_http_v2_create_loc_conf,,,42,void* ngx_http_v2_create_loc_conf (ngx_conf_t*)
372122,METHOD,http\v2\ngx_http_v2_module.c:<global>,TYPE_DECL,"static char *
ngx_http_v2_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_v2_loc_conf_t *prev = parent;
    ngx_http_v2_loc_conf_t *conf = child;

    ngx_conf_merge_size_value(conf->chunk_size, prev->chunk_size, 8 * 1024);

    ngx_conf_merge_value(conf->push, prev->push, 1);

    if (conf->push && conf->pushes == NULL) {
        conf->pushes = prev->pushes;
    }

    ngx_conf_merge_value(conf->push_preload, prev->push_preload, 0);

    return NGX_CONF_OK;
}",1,1,http\v2\ngx_http_v2_module.c,ngx_http_v2_merge_loc_conf,,false,430,447,ngx_http_v2_merge_loc_conf,,,43,"char* ngx_http_v2_merge_loc_conf (ngx_conf_t*,void*,void*)"
372183,METHOD,http\v2\ngx_http_v2_module.c:<global>,TYPE_DECL,"static char *
ngx_http_v2_push(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_v2_loc_conf_t *h2lcf = conf;

    ngx_str_t                         *value;
    ngx_http_complex_value_t          *cv;
    ngx_http_compile_complex_value_t   ccv;

    value = cf->args->elts;

    if (ngx_strcmp(value[1].data, ""off"") == 0) {

        if (h2lcf->pushes) {
            return ""\""off\"" parameter cannot be used with URI"";
        }

        if (h2lcf->push == 0) {
            return ""is duplicate"";
        }

        h2lcf->push = 0;
        return NGX_CONF_OK;
    }

    if (h2lcf->push == 0) {
        return ""URI cannot be used with \""off\"" parameter"";
    }

    h2lcf->push = 1;

    if (h2lcf->pushes == NULL) {
        h2lcf->pushes = ngx_array_create(cf->pool, 1,
                                         sizeof(ngx_http_complex_value_t));
        if (h2lcf->pushes == NULL) {
            return NGX_CONF_ERROR;
        }
    }

    cv = ngx_array_push(h2lcf->pushes);
    if (c...",1,1,http\v2\ngx_http_v2_module.c,ngx_http_v2_push,,false,450,505,ngx_http_v2_push,,,44,"char* ngx_http_v2_push (ngx_conf_t*,ngx_command_t*,void*)"
372326,METHOD,http\v2\ngx_http_v2_module.c:<global>,TYPE_DECL,"static char *
ngx_http_v2_recv_buffer_size(ngx_conf_t *cf, void *post, void *data)
{
    size_t *sp = data;

    if (*sp <= 2 * NGX_HTTP_V2_STATE_BUFFER_SIZE) {
        return ""value is too small"";
    }

    return NGX_CONF_OK;
}",1,1,http\v2\ngx_http_v2_module.c,ngx_http_v2_recv_buffer_size,,false,508,518,ngx_http_v2_recv_buffer_size,,,45,"char* ngx_http_v2_recv_buffer_size (ngx_conf_t*,void*,void*)"
372349,METHOD,http\v2\ngx_http_v2_module.c:<global>,TYPE_DECL,"static char *
ngx_http_v2_pool_size(ngx_conf_t *cf, void *post, void *data)
{
    size_t *sp = data;

    if (*sp < NGX_MIN_POOL_SIZE) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""the pool size must be no less than %uz"",
                           NGX_MIN_POOL_SIZE);

        return NGX_CONF_ERROR;
    }

    if (*sp % NGX_POOL_ALIGNMENT) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""the pool size must be a multiple of %uz"",
                           NGX_POOL_ALIGNMENT);

        return NGX_CONF_ERROR;
    }

    return NGX_CONF_OK;
}",1,1,http\v2\ngx_http_v2_module.c,ngx_http_v2_pool_size,,false,521,543,ngx_http_v2_pool_size,,,46,"char* ngx_http_v2_pool_size (ngx_conf_t*,void*,void*)"
372390,METHOD,http\v2\ngx_http_v2_module.c:<global>,TYPE_DECL,"static char *
ngx_http_v2_preread_size(ngx_conf_t *cf, void *post, void *data)
{
    size_t *sp = data;

    if (*sp > NGX_HTTP_V2_MAX_WINDOW) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""the maximum body preread buffer size is %uz"",
                           NGX_HTTP_V2_MAX_WINDOW);

        return NGX_CONF_ERROR;
    }

    return NGX_CONF_OK;
}",1,1,http\v2\ngx_http_v2_module.c,ngx_http_v2_preread_size,,false,546,560,ngx_http_v2_preread_size,,,47,"char* ngx_http_v2_preread_size (ngx_conf_t*,void*,void*)"
372417,METHOD,http\v2\ngx_http_v2_module.c:<global>,TYPE_DECL,"static char *
ngx_http_v2_streams_index_mask(ngx_conf_t *cf, void *post, void *data)
{
    ngx_uint_t *np = data;

    ngx_uint_t  mask;

    mask = *np - 1;

    if (*np == 0 || (*np & mask)) {
        return ""must be a power of two"";
    }

    *np = mask;

    return NGX_CONF_OK;
}",1,1,http\v2\ngx_http_v2_module.c,ngx_http_v2_streams_index_mask,,false,563,579,ngx_http_v2_streams_index_mask,,,48,"char* ngx_http_v2_streams_index_mask (ngx_conf_t*,void*,void*)"
372454,METHOD,http\v2\ngx_http_v2_module.c:<global>,TYPE_DECL,"static char *
ngx_http_v2_chunk_size(ngx_conf_t *cf, void *post, void *data)
{
    size_t *sp = data;

    if (*sp == 0) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""the http2 chunk size cannot be zero"");

        return NGX_CONF_ERROR;
    }

    if (*sp > NGX_HTTP_V2_MAX_FRAME_SIZE) {
        *sp = NGX_HTTP_V2_MAX_FRAME_SIZE;
    }

    return NGX_CONF_OK;
}",1,1,http\v2\ngx_http_v2_module.c,ngx_http_v2_chunk_size,,false,582,599,ngx_http_v2_chunk_size,,,49,"char* ngx_http_v2_chunk_size (ngx_conf_t*,void*,void*)"
372490,METHOD,http\v2\ngx_http_v2_module.c:<global>,TYPE_DECL,"static char *
ngx_http_v2_spdy_deprecated(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
                       ""invalid directive \""%V\"": ngx_http_spdy_module ""
                       ""was superseded by ngx_http_v2_module"", &cmd->name);

    return NGX_CONF_OK;
}",1,1,http\v2\ngx_http_v2_module.c,ngx_http_v2_spdy_deprecated,,false,602,610,ngx_http_v2_spdy_deprecated,,,50,"char* ngx_http_v2_spdy_deprecated (ngx_conf_t*,ngx_command_t*,void*)"
372517,METHOD,http\v2\ngx_http_v2_module.h:<global>,TYPE_DECL,<global>,1,44,http\v2\ngx_http_v2_module.h,http\v2\ngx_http_v2_module.h:<global>,,false,1,50,<global>,,,1,
372551,METHOD,http\v2\ngx_http_v2_table.c:<global>,TYPE_DECL,<global>,1,16,http\v2\ngx_http_v2_table.c,http\v2\ngx_http_v2_table.c:<global>,,false,1,363,<global>,,,1,
372553,METHOD,http\v2\ngx_http_v2_table.c:<global>,TYPE_DECL,"static ngx_int_t ngx_http_v2_table_account(ngx_http_v2_connection_t *h2c,
    size_t size);",18,16,http\v2\ngx_http_v2_table.c,ngx_http_v2_table_account,,false,16,17,ngx_http_v2_table_account,,,1,"ngx_int_t ngx_http_v2_table_account (ngx_http_v2_connection_t*,size_t)"
372868,METHOD,http\v2\ngx_http_v2_table.c:<global>,TYPE_DECL,"ngx_str_t *
ngx_http_v2_get_static_name(ngx_uint_t index)
{
    return &ngx_http_v2_static_table[index - 1].name;
}",1,1,http\v2\ngx_http_v2_table.c,ngx_http_v2_get_static_name,,false,89,93,ngx_http_v2_get_static_name,,,4,ngx_str_t ngx_http_v2_get_static_name (ngx_uint_t)
372882,METHOD,http\v2\ngx_http_v2_table.c:<global>,TYPE_DECL,"ngx_str_t *
ngx_http_v2_get_static_value(ngx_uint_t index)
{
    return &ngx_http_v2_static_table[index - 1].value;
}",1,1,http\v2\ngx_http_v2_table.c,ngx_http_v2_get_static_value,,false,96,100,ngx_http_v2_get_static_value,,,5,ngx_str_t ngx_http_v2_get_static_value (ngx_uint_t)
372896,METHOD,http\v2\ngx_http_v2_table.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_v2_get_indexed_header(ngx_http_v2_connection_t *h2c, ngx_uint_t index,
    ngx_uint_t name_only)
{
    u_char                *p;
    size_t                 rest;
    ngx_http_v2_header_t  *entry;

    if (index == 0) {
        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
                      ""client sent invalid hpack table index 0"");
        return NGX_ERROR;
    }

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
                   ""http2 get indexed %s: %ui"",
                   name_only ? ""name"" : ""header"", index);

    index--;

    if (index < NGX_HTTP_V2_STATIC_TABLE_ENTRIES) {
        h2c->state.header = ngx_http_v2_static_table[index];
        return NGX_OK;
    }

    index -= NGX_HTTP_V2_STATIC_TABLE_ENTRIES;

    if (index < h2c->hpack.added - h2c->hpack.deleted) {
        index = (h2c->hpack.added - index - 1) % h2c->hpack.allocated;
        entry = h2c->hpack.entries[index];

        p = ngx_pnalloc(h2c->state.pool, entry->nam...",1,16,http\v2\ngx_http_v2_table.c,ngx_http_v2_get_indexed_header,,false,103,185,ngx_http_v2_get_indexed_header,,,6,"ngx_int_t ngx_http_v2_get_indexed_header (ngx_http_v2_connection_t*,ngx_uint_t,ngx_uint_t)"
373269,METHOD,http\v2\ngx_http_v2_table.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_v2_add_header(ngx_http_v2_connection_t *h2c,
    ngx_http_v2_header_t *header)
{
    size_t                 avail;
    ngx_uint_t             index;
    ngx_http_v2_header_t  *entry, **entries;

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
                   ""http2 table add: \""%V: %V\"""",
                   &header->name, &header->value);

    if (h2c->hpack.entries == NULL) {
        h2c->hpack.allocated = 64;
        h2c->hpack.size = NGX_HTTP_V2_TABLE_SIZE;
        h2c->hpack.free = NGX_HTTP_V2_TABLE_SIZE;

        h2c->hpack.entries = ngx_palloc(h2c->connection->pool,
                                        sizeof(ngx_http_v2_header_t *)
                                        * h2c->hpack.allocated);
        if (h2c->hpack.entries == NULL) {
            return NGX_ERROR;
        }

        h2c->hpack.storage = ngx_palloc(h2c->connection->pool,
                                        h2c->hpack.free);
        if (h2c->hpack.storage == NULL) ...",1,26,http\v2\ngx_http_v2_table.c,ngx_http_v2_add_header,,false,188,299,ngx_http_v2_add_header,,,7,"ngx_int_t ngx_http_v2_add_header (ngx_http_v2_connection_t*,ngx_http_v2_header_t*)"
373857,METHOD,http\v2\ngx_http_v2_table.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_http_v2_table_account(ngx_http_v2_connection_t *h2c, size_t size)
{
    ngx_http_v2_header_t  *entry;

    size += 32;

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
                   ""http2 table account: %uz free:%uz"",
                   size, h2c->hpack.free);

    if (size <= h2c->hpack.free) {
        h2c->hpack.free -= size;
        return NGX_OK;
    }

    if (size > h2c->hpack.size) {
        h2c->hpack.deleted = h2c->hpack.added;
        h2c->hpack.free = h2c->hpack.size;
        return NGX_DECLINED;
    }

    do {
        entry = h2c->hpack.entries[h2c->hpack.deleted++ % h2c->hpack.allocated];
        h2c->hpack.free += 32 + entry->name.len + entry->value.len;
    } while (size > h2c->hpack.free);

    h2c->hpack.free -= size;

    return NGX_OK;
}",1,1,http\v2\ngx_http_v2_table.c,ngx_http_v2_table_account,,false,302,332,ngx_http_v2_table_account,,,8,"ngx_int_t ngx_http_v2_table_account (ngx_http_v2_connection_t*,size_t)"
373990,METHOD,http\v2\ngx_http_v2_table.c:<global>,TYPE_DECL,"ngx_int_t
ngx_http_v2_table_size(ngx_http_v2_connection_t *h2c, size_t size)
{
    ssize_t                needed;
    ngx_http_v2_header_t  *entry;

    if (size > NGX_HTTP_V2_TABLE_SIZE) {
        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
                      ""client sent invalid table size update: %uz"", size);

        return NGX_ERROR;
    }

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
                   ""http2 new hpack table size: %uz was:%uz"",
                   size, h2c->hpack.size);

    needed = h2c->hpack.size - size;

    while (needed > (ssize_t) h2c->hpack.free) {
        entry = h2c->hpack.entries[h2c->hpack.deleted++ % h2c->hpack.allocated];
        h2c->hpack.free += 32 + entry->name.len + entry->value.len;
    }

    h2c->hpack.size = size;
    h2c->hpack.free -= needed;

    return NGX_OK;
}",1,15,http\v2\ngx_http_v2_table.c,ngx_http_v2_table_size,,false,335,363,ngx_http_v2_table_size,,,9,"ngx_int_t ngx_http_v2_table_size (ngx_http_v2_connection_t*,size_t)"
374118,METHOD,mail\ngx_mail.c:<global>,TYPE_DECL,<global>,1,1,mail\ngx_mail.c,mail\ngx_mail.c:<global>,,false,1,482,<global>,,,1,
374120,METHOD,mail\ngx_mail.c:<global>,TYPE_DECL,"static char *ngx_mail_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",13,75,mail\ngx_mail.c,ngx_mail_block,,false,14,14,ngx_mail_block,,,1,"char* ngx_mail_block (ngx_conf_t*,ngx_command_t*,void*)"
374127,METHOD,mail\ngx_mail.c:<global>,TYPE_DECL,"static ngx_int_t ngx_mail_add_ports(ngx_conf_t *cf, ngx_array_t *ports,
    ngx_mail_listen_t *listen);",18,30,mail\ngx_mail.c,ngx_mail_add_ports,,false,15,16,ngx_mail_add_ports,,,2,"ngx_int_t ngx_mail_add_ports (ngx_conf_t*,ngx_array_t*,ngx_mail_listen_t*)"
374134,METHOD,mail\ngx_mail.c:<global>,TYPE_DECL,"static char *ngx_mail_optimize_servers(ngx_conf_t *cf, ngx_array_t *ports);",13,74,mail\ngx_mail.c,ngx_mail_optimize_servers,,false,17,17,ngx_mail_optimize_servers,,,3,"char* ngx_mail_optimize_servers (ngx_conf_t*,ngx_array_t*)"
374140,METHOD,mail\ngx_mail.c:<global>,TYPE_DECL,"static ngx_int_t ngx_mail_add_addrs(ngx_conf_t *cf, ngx_mail_port_t *mport,
    ngx_mail_conf_addr_t *addr);",18,31,mail\ngx_mail.c,ngx_mail_add_addrs,,false,18,19,ngx_mail_add_addrs,,,4,"ngx_int_t ngx_mail_add_addrs (ngx_conf_t*,ngx_mail_port_t*,ngx_mail_conf_addr_t*)"
374147,METHOD,mail\ngx_mail.c:<global>,TYPE_DECL,"static ngx_int_t ngx_mail_cmp_conf_addrs(const void *one, const void *two);",18,74,mail\ngx_mail.c,ngx_mail_cmp_conf_addrs,,false,24,24,ngx_mail_cmp_conf_addrs,,,5,"ngx_int_t ngx_mail_cmp_conf_addrs (void*,void*)"
374196,METHOD,mail\ngx_mail.c:<global>,TYPE_DECL,"static char *
ngx_mail_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char                        *rv;
    ngx_uint_t                   i, m, mi, s;
    ngx_conf_t                   pcf;
    ngx_array_t                  ports;
    ngx_mail_listen_t           *listen;
    ngx_mail_module_t           *module;
    ngx_mail_conf_ctx_t         *ctx;
    ngx_mail_core_srv_conf_t   **cscfp;
    ngx_mail_core_main_conf_t   *cmcf;

    if (*(ngx_mail_conf_ctx_t **) conf) {
        return ""is duplicate"";
    }

    /* the main mail context */

    ctx = ngx_pcalloc(cf->pool, sizeof(ngx_mail_conf_ctx_t));
    if (ctx == NULL) {
        return NGX_CONF_ERROR;
    }

    *(ngx_mail_conf_ctx_t **) conf = ctx;

    /* count the number of the mail modules and set up their indices */

    ngx_mail_max_module = ngx_count_modules(cf->cycle, NGX_MAIL_MODULE);


    /* the mail main_conf context, it is the same in the all mail contexts */

    ctx->main_conf = ngx_pcalloc(cf->pool,
        ...",1,1,mail\ngx_mail.c,ngx_mail_block,,false,66,221,ngx_mail_block,,,13,"char* ngx_mail_block (ngx_conf_t*,ngx_command_t*,void*)"
374654,METHOD,mail\ngx_mail.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_mail_add_ports(ngx_conf_t *cf, ngx_array_t *ports,
    ngx_mail_listen_t *listen)
{
    in_port_t              p;
    ngx_uint_t             i;
    struct sockaddr       *sa;
    ngx_mail_conf_port_t  *port;
    ngx_mail_conf_addr_t  *addr;

    sa = listen->sockaddr;
    p = ngx_inet_get_port(sa);

    port = ports->elts;
    for (i = 0; i < ports->nelts; i++) {
        if (p == port[i].port && sa->sa_family == port[i].family) {

            /* a port is already in the port list */

            port = &port[i];
            goto found;
        }
    }

    /* add a port to the port list */

    port = ngx_array_push(ports);
    if (port == NULL) {
        return NGX_ERROR;
    }

    port->family = sa->sa_family;
    port->port = p;

    if (ngx_array_init(&port->addrs, cf->temp_pool, 2,
                       sizeof(ngx_mail_conf_addr_t))
        != NGX_OK)
    {
        return NGX_ERROR;
    }

found:

    addr = ngx_array_push(&port->addrs);
    if (addr == N...",1,1,mail\ngx_mail.c,ngx_mail_add_ports,,false,224,275,ngx_mail_add_ports,,,14,"ngx_int_t ngx_mail_add_ports (ngx_conf_t*,ngx_array_t*,ngx_mail_listen_t*)"
374782,METHOD,mail\ngx_mail.c:<global>,TYPE_DECL,"static char *
ngx_mail_optimize_servers(ngx_conf_t *cf, ngx_array_t *ports)
{
    ngx_uint_t                 i, p, last, bind_wildcard;
    ngx_listening_t           *ls;
    ngx_mail_port_t           *mport;
    ngx_mail_conf_port_t      *port;
    ngx_mail_conf_addr_t      *addr;
    ngx_mail_core_srv_conf_t  *cscf;

    port = ports->elts;
    for (p = 0; p < ports->nelts; p++) {

        ngx_sort(port[p].addrs.elts, (size_t) port[p].addrs.nelts,
                 sizeof(ngx_mail_conf_addr_t), ngx_mail_cmp_conf_addrs);

        addr = port[p].addrs.elts;
        last = port[p].addrs.nelts;

        /*
         * if there is the binding to the ""*:port"" then we need to bind()
         * to the ""*:port"" only and ignore the other bindings
         */

        if (addr[last - 1].opt.wildcard) {
            addr[last - 1].opt.bind = 1;
            bind_wildcard = 1;

        } else {
            bind_wildcard = 0;
        }

        i = 0;

        while (i < last) {

            if (bi...",1,1,mail\ngx_mail.c,ngx_mail_optimize_servers,,false,278,380,ngx_mail_optimize_servers,,,15,"char* ngx_mail_optimize_servers (ngx_conf_t*,ngx_array_t*)"
375079,METHOD,mail\ngx_mail.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_mail_add_addrs(ngx_conf_t *cf, ngx_mail_port_t *mport,
    ngx_mail_conf_addr_t *addr)
{
    ngx_uint_t           i;
    ngx_mail_in_addr_t  *addrs;
    struct sockaddr_in  *sin;

    mport->addrs = ngx_pcalloc(cf->pool,
                               mport->naddrs * sizeof(ngx_mail_in_addr_t));
    if (mport->addrs == NULL) {
        return NGX_ERROR;
    }

    addrs = mport->addrs;

    for (i = 0; i < mport->naddrs; i++) {

        sin = (struct sockaddr_in *) addr[i].opt.sockaddr;
        addrs[i].addr = sin->sin_addr.s_addr;

        addrs[i].conf.ctx = addr[i].opt.ctx;
#if (NGX_MAIL_SSL)
        addrs[i].conf.ssl = addr[i].opt.ssl;
#endif
        addrs[i].conf.addr_text = addr[i].opt.addr_text;
    }

    return NGX_OK;
}",1,1,mail\ngx_mail.c,ngx_mail_add_addrs,,false,383,412,ngx_mail_add_addrs,,,16,"ngx_int_t ngx_mail_add_addrs (ngx_conf_t*,ngx_mail_port_t*,ngx_mail_conf_addr_t*)"
375184,METHOD,mail\ngx_mail.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_mail_cmp_conf_addrs(const void *one, const void *two)
{
    ngx_mail_conf_addr_t  *first, *second;

    first = (ngx_mail_conf_addr_t *) one;
    second = (ngx_mail_conf_addr_t *) two;

    if (first->opt.wildcard) {
        /* a wildcard must be the last resort, shift it to the end */
        return 1;
    }

    if (second->opt.wildcard) {
        /* a wildcard must be the last resort, shift it to the end */
        return -1;
    }

    if (first->opt.bind && !second->opt.bind) {
        /* shift explicit bind()ed addresses to the start */
        return -1;
    }

    if (!first->opt.bind && second->opt.bind) {
        /* shift explicit bind()ed addresses to the start */
        return 1;
    }

    /* do not sort by default */

    return 0;
}",1,1,mail\ngx_mail.c,ngx_mail_cmp_conf_addrs,,false,451,482,ngx_mail_cmp_conf_addrs,,,17,"ngx_int_t ngx_mail_cmp_conf_addrs (void*,void*)"
375269,METHOD,mail\ngx_mail.h:<global>,TYPE_DECL,<global>,1,34,mail\ngx_mail.h,mail\ngx_mail.h:<global>,,false,1,413,<global>,,,1,
375341,METHOD,<empty>,<empty>,<empty>,1,,mail\ngx_mail.h,ngx_pop3_state_e:<clinit>,,false,131,,<clinit>,,,9,
375359,METHOD,<empty>,<empty>,<empty>,1,,mail\ngx_mail.h,ngx_imap_state_e:<clinit>,,false,143,,<clinit>,,,10,
375382,METHOD,<empty>,<empty>,<empty>,1,,mail\ngx_mail.h,ngx_smtp_state_e:<clinit>,,false,156,,<clinit>,,,15,
375440,METHOD,mail\ngx_mail.h:<global>,TYPE_DECL,"typedef void (*ngx_mail_init_session_pt)(ngx_mail_session_t *s,
    ngx_connection_t *c);",14,24,mail\ngx_mail.h,ngx_mail_init_session_pt,,false,309,310,ngx_mail_init_session_pt,,,33,"void ngx_mail_init_session_pt (ngx_mail_session_t*,ngx_connection_t*)"
375446,METHOD,mail\ngx_mail.h:<global>,TYPE_DECL,typedef void (*ngx_mail_init_protocol_pt)(ngx_event_t *rev);,14,59,mail\ngx_mail.h,ngx_mail_init_protocol_pt,,false,311,311,ngx_mail_init_protocol_pt,,,34,void ngx_mail_init_protocol_pt (ngx_event_t*)
375451,METHOD,mail\ngx_mail.h:<global>,TYPE_DECL,typedef void (*ngx_mail_auth_state_pt)(ngx_event_t *rev);,14,56,mail\ngx_mail.h,ngx_mail_auth_state_pt,,false,312,312,ngx_mail_auth_state_pt,,,35,void ngx_mail_auth_state_pt (ngx_event_t*)
375456,METHOD,mail\ngx_mail.h:<global>,TYPE_DECL,typedef ngx_int_t (*ngx_mail_parse_command_pt)(ngx_mail_session_t *s);,19,69,mail\ngx_mail.h,ngx_mail_parse_command_pt,,false,313,313,ngx_mail_parse_command_pt,,,36,ngx_int_t ngx_mail_parse_command_pt (ngx_mail_session_t*)
375472,METHOD,<empty>,<empty>,<empty>,1,,mail\ngx_mail.h,ngx_mail_protocol_s:<clinit>,,false,316,,<clinit>,,,11,
375480,METHOD,ngx_mail_module_t,TYPE_DECL,void                       *(*create_main_conf)(ngx_conf_t *cf);,32,67,mail\ngx_mail.h,ngx_mail_module_t.create_main_conf,,false,335,335,create_main_conf,,,2,void* ngx_mail_module_t.create_main_conf (ngx_conf_t*)
375485,METHOD,ngx_mail_module_t,TYPE_DECL,"char                       *(*init_main_conf)(ngx_conf_t *cf, void *conf);",32,77,mail\ngx_mail.h,ngx_mail_module_t.init_main_conf,,false,336,336,init_main_conf,,,3,"char* ngx_mail_module_t.init_main_conf (ngx_conf_t*,void*)"
375491,METHOD,ngx_mail_module_t,TYPE_DECL,void                       *(*create_srv_conf)(ngx_conf_t *cf);,32,66,mail\ngx_mail.h,ngx_mail_module_t.create_srv_conf,,false,338,338,create_srv_conf,,,4,void* ngx_mail_module_t.create_srv_conf (ngx_conf_t*)
375496,METHOD,ngx_mail_module_t,TYPE_DECL,"char                       *(*merge_srv_conf)(ngx_conf_t *cf, void *prev,
                                                  void *conf);",32,61,mail\ngx_mail.h,ngx_mail_module_t.merge_srv_conf,,false,339,340,merge_srv_conf,,,5,"char* ngx_mail_module_t.merge_srv_conf (ngx_conf_t*,void*,void*)"
375504,METHOD,mail\ngx_mail.h:<global>,TYPE_DECL,void ngx_mail_init_connection(ngx_connection_t *c);,6,50,mail\ngx_mail.h,ngx_mail_init_connection,,false,375,375,ngx_mail_init_connection,,,40,void ngx_mail_init_connection (ngx_connection_t*)
375509,METHOD,mail\ngx_mail.h:<global>,TYPE_DECL,"ngx_int_t ngx_mail_salt(ngx_mail_session_t *s, ngx_connection_t *c,
    ngx_mail_core_srv_conf_t *cscf);",11,35,mail\ngx_mail.h,ngx_mail_salt,,false,377,378,ngx_mail_salt,,,41,"ngx_int_t ngx_mail_salt (ngx_mail_session_t*,ngx_connection_t*,ngx_mail_core_srv_conf_t*)"
375516,METHOD,mail\ngx_mail.h:<global>,TYPE_DECL,"ngx_int_t ngx_mail_auth_plain(ngx_mail_session_t *s, ngx_connection_t *c,
    ngx_uint_t n);",11,17,mail\ngx_mail.h,ngx_mail_auth_plain,,false,379,380,ngx_mail_auth_plain,,,42,"ngx_int_t ngx_mail_auth_plain (ngx_mail_session_t*,ngx_connection_t*,ngx_uint_t)"
375523,METHOD,mail\ngx_mail.h:<global>,TYPE_DECL,"ngx_int_t ngx_mail_auth_login_username(ngx_mail_session_t *s,
    ngx_connection_t *c, ngx_uint_t n);",11,38,mail\ngx_mail.h,ngx_mail_auth_login_username,,false,381,382,ngx_mail_auth_login_username,,,43,"ngx_int_t ngx_mail_auth_login_username (ngx_mail_session_t*,ngx_connection_t*,ngx_uint_t)"
375530,METHOD,mail\ngx_mail.h:<global>,TYPE_DECL,"ngx_int_t ngx_mail_auth_login_password(ngx_mail_session_t *s,
    ngx_connection_t *c);",11,24,mail\ngx_mail.h,ngx_mail_auth_login_password,,false,383,384,ngx_mail_auth_login_password,,,44,"ngx_int_t ngx_mail_auth_login_password (ngx_mail_session_t*,ngx_connection_t*)"
375536,METHOD,mail\ngx_mail.h:<global>,TYPE_DECL,"ngx_int_t ngx_mail_auth_cram_md5_salt(ngx_mail_session_t *s,
    ngx_connection_t *c, char *prefix, size_t len);",11,50,mail\ngx_mail.h,ngx_mail_auth_cram_md5_salt,,false,385,386,ngx_mail_auth_cram_md5_salt,,,45,"ngx_int_t ngx_mail_auth_cram_md5_salt (ngx_mail_session_t*,ngx_connection_t*,char*,size_t)"
375544,METHOD,mail\ngx_mail.h:<global>,TYPE_DECL,"ngx_int_t ngx_mail_auth_cram_md5(ngx_mail_session_t *s, ngx_connection_t *c);",11,76,mail\ngx_mail.h,ngx_mail_auth_cram_md5,,false,387,387,ngx_mail_auth_cram_md5,,,46,"ngx_int_t ngx_mail_auth_cram_md5 (ngx_mail_session_t*,ngx_connection_t*)"
375550,METHOD,mail\ngx_mail.h:<global>,TYPE_DECL,"ngx_int_t ngx_mail_auth_external(ngx_mail_session_t *s, ngx_connection_t *c,
    ngx_uint_t n);",11,17,mail\ngx_mail.h,ngx_mail_auth_external,,false,388,389,ngx_mail_auth_external,,,47,"ngx_int_t ngx_mail_auth_external (ngx_mail_session_t*,ngx_connection_t*,ngx_uint_t)"
375557,METHOD,mail\ngx_mail.h:<global>,TYPE_DECL,"ngx_int_t ngx_mail_auth_parse(ngx_mail_session_t *s, ngx_connection_t *c);",11,73,mail\ngx_mail.h,ngx_mail_auth_parse,,false,390,390,ngx_mail_auth_parse,,,48,"ngx_int_t ngx_mail_auth_parse (ngx_mail_session_t*,ngx_connection_t*)"
375563,METHOD,mail\ngx_mail.h:<global>,TYPE_DECL,void ngx_mail_send(ngx_event_t *wev);,6,36,mail\ngx_mail.h,ngx_mail_send,,false,392,392,ngx_mail_send,,,49,void ngx_mail_send (ngx_event_t*)
375568,METHOD,mail\ngx_mail.h:<global>,TYPE_DECL,"ngx_int_t ngx_mail_read_command(ngx_mail_session_t *s, ngx_connection_t *c);",11,75,mail\ngx_mail.h,ngx_mail_read_command,,false,393,393,ngx_mail_read_command,,,50,"ngx_int_t ngx_mail_read_command (ngx_mail_session_t*,ngx_connection_t*)"
375574,METHOD,mail\ngx_mail.h:<global>,TYPE_DECL,"void ngx_mail_auth(ngx_mail_session_t *s, ngx_connection_t *c);",6,62,mail\ngx_mail.h,ngx_mail_auth,,false,394,394,ngx_mail_auth,,,51,"void ngx_mail_auth (ngx_mail_session_t*,ngx_connection_t*)"
375580,METHOD,mail\ngx_mail.h:<global>,TYPE_DECL,void ngx_mail_close_connection(ngx_connection_t *c);,6,51,mail\ngx_mail.h,ngx_mail_close_connection,,false,395,395,ngx_mail_close_connection,,,52,void ngx_mail_close_connection (ngx_connection_t*)
375585,METHOD,mail\ngx_mail.h:<global>,TYPE_DECL,void ngx_mail_session_internal_server_error(ngx_mail_session_t *s);,6,66,mail\ngx_mail.h,ngx_mail_session_internal_server_error,,false,396,396,ngx_mail_session_internal_server_error,,,53,void ngx_mail_session_internal_server_error (ngx_mail_session_t*)
375590,METHOD,mail\ngx_mail.h:<global>,TYPE_DECL,"u_char *ngx_mail_log_error(ngx_log_t *log, u_char *buf, size_t len);",8,67,mail\ngx_mail.h,ngx_mail_log_error,,false,397,397,ngx_mail_log_error,,,54,"u_char* ngx_mail_log_error (ngx_log_t*,u_char*,size_t)"
375597,METHOD,mail\ngx_mail.h:<global>,TYPE_DECL,"char *ngx_mail_capabilities(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",6,75,mail\ngx_mail.h,ngx_mail_capabilities,,false,400,400,ngx_mail_capabilities,,,55,"char* ngx_mail_capabilities (ngx_conf_t*,ngx_command_t*,void*)"
375604,METHOD,mail\ngx_mail.h:<global>,TYPE_DECL,"void ngx_mail_proxy_init(ngx_mail_session_t *s, ngx_addr_t *peer);",6,65,mail\ngx_mail.h,ngx_mail_proxy_init,,false,404,404,ngx_mail_proxy_init,,,56,"void ngx_mail_proxy_init (ngx_mail_session_t*,ngx_addr_t*)"
375610,METHOD,mail\ngx_mail.h:<global>,TYPE_DECL,void ngx_mail_auth_http_init(ngx_mail_session_t *s);,6,51,mail\ngx_mail.h,ngx_mail_auth_http_init,,false,405,405,ngx_mail_auth_http_init,,,57,void ngx_mail_auth_http_init (ngx_mail_session_t*)
375630,METHOD,mail\ngx_mail_auth_http_module.c:<global>,TYPE_DECL,<global>,1,1,mail\ngx_mail_auth_http_module.c,mail\ngx_mail_auth_http_module.c:<global>,,false,1,1574,<global>,,,1,
375645,METHOD,mail\ngx_mail_auth_http_module.c:<global>,TYPE_DECL,"typedef void (*ngx_mail_auth_http_handler_pt)(ngx_mail_session_t *s,
    ngx_mail_auth_http_ctx_t *ctx);",14,34,mail\ngx_mail_auth_http_module.c,ngx_mail_auth_http_handler_pt,,false,34,35,ngx_mail_auth_http_handler_pt,,,5,"void ngx_mail_auth_http_handler_pt (ngx_mail_session_t*,ngx_mail_auth_http_ctx_t*)"
375668,METHOD,mail\ngx_mail_auth_http_module.c:<global>,TYPE_DECL,static void ngx_mail_auth_http_write_handler(ngx_event_t *wev);,13,62,mail\ngx_mail_auth_http_module.c,ngx_mail_auth_http_write_handler,,false,63,63,ngx_mail_auth_http_write_handler,,,7,void ngx_mail_auth_http_write_handler (ngx_event_t*)
375673,METHOD,mail\ngx_mail_auth_http_module.c:<global>,TYPE_DECL,static void ngx_mail_auth_http_read_handler(ngx_event_t *rev);,13,61,mail\ngx_mail_auth_http_module.c,ngx_mail_auth_http_read_handler,,false,64,64,ngx_mail_auth_http_read_handler,,,8,void ngx_mail_auth_http_read_handler (ngx_event_t*)
375678,METHOD,mail\ngx_mail_auth_http_module.c:<global>,TYPE_DECL,"static void ngx_mail_auth_http_ignore_status_line(ngx_mail_session_t *s,
    ngx_mail_auth_http_ctx_t *ctx);",13,34,mail\ngx_mail_auth_http_module.c,ngx_mail_auth_http_ignore_status_line,,false,65,66,ngx_mail_auth_http_ignore_status_line,,,9,"void ngx_mail_auth_http_ignore_status_line (ngx_mail_session_t*,ngx_mail_auth_http_ctx_t*)"
375684,METHOD,mail\ngx_mail_auth_http_module.c:<global>,TYPE_DECL,"static void ngx_mail_auth_http_process_headers(ngx_mail_session_t *s,
    ngx_mail_auth_http_ctx_t *ctx);",13,34,mail\ngx_mail_auth_http_module.c,ngx_mail_auth_http_process_headers,,false,67,68,ngx_mail_auth_http_process_headers,,,10,"void ngx_mail_auth_http_process_headers (ngx_mail_session_t*,ngx_mail_auth_http_ctx_t*)"
375690,METHOD,mail\ngx_mail_auth_http_module.c:<global>,TYPE_DECL,static void ngx_mail_auth_sleep_handler(ngx_event_t *rev);,13,57,mail\ngx_mail_auth_http_module.c,ngx_mail_auth_sleep_handler,,false,69,69,ngx_mail_auth_sleep_handler,,,11,void ngx_mail_auth_sleep_handler (ngx_event_t*)
375695,METHOD,mail\ngx_mail_auth_http_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_mail_auth_http_parse_header_line(ngx_mail_session_t *s,
    ngx_mail_auth_http_ctx_t *ctx);",18,34,mail\ngx_mail_auth_http_module.c,ngx_mail_auth_http_parse_header_line,,false,70,71,ngx_mail_auth_http_parse_header_line,,,12,"ngx_int_t ngx_mail_auth_http_parse_header_line (ngx_mail_session_t*,ngx_mail_auth_http_ctx_t*)"
375701,METHOD,mail\ngx_mail_auth_http_module.c:<global>,TYPE_DECL,static void ngx_mail_auth_http_block_read(ngx_event_t *rev);,13,59,mail\ngx_mail_auth_http_module.c,ngx_mail_auth_http_block_read,,false,72,72,ngx_mail_auth_http_block_read,,,13,void ngx_mail_auth_http_block_read (ngx_event_t*)
375706,METHOD,mail\ngx_mail_auth_http_module.c:<global>,TYPE_DECL,static void ngx_mail_auth_http_dummy_handler(ngx_event_t *ev);,13,61,mail\ngx_mail_auth_http_module.c,ngx_mail_auth_http_dummy_handler,,false,73,73,ngx_mail_auth_http_dummy_handler,,,14,void ngx_mail_auth_http_dummy_handler (ngx_event_t*)
375711,METHOD,mail\ngx_mail_auth_http_module.c:<global>,TYPE_DECL,"static ngx_buf_t *ngx_mail_auth_http_create_request(ngx_mail_session_t *s,
    ngx_pool_t *pool, ngx_mail_auth_http_conf_t *ahcf);",18,54,mail\ngx_mail_auth_http_module.c,ngx_mail_auth_http_create_request,,false,74,75,ngx_mail_auth_http_create_request,,,15,"ngx_buf_t* ngx_mail_auth_http_create_request (ngx_mail_session_t*,ngx_pool_t*,ngx_mail_auth_http_conf_t*)"
375718,METHOD,mail\ngx_mail_auth_http_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_mail_auth_http_escape(ngx_pool_t *pool, ngx_str_t *text,
    ngx_str_t *escaped);",18,23,mail\ngx_mail_auth_http_module.c,ngx_mail_auth_http_escape,,false,76,77,ngx_mail_auth_http_escape,,,16,"ngx_int_t ngx_mail_auth_http_escape (ngx_pool_t*,ngx_str_t*,ngx_str_t*)"
375725,METHOD,mail\ngx_mail_auth_http_module.c:<global>,TYPE_DECL,static void *ngx_mail_auth_http_create_conf(ngx_conf_t *cf);,13,59,mail\ngx_mail_auth_http_module.c,ngx_mail_auth_http_create_conf,,false,79,79,ngx_mail_auth_http_create_conf,,,17,void* ngx_mail_auth_http_create_conf (ngx_conf_t*)
375730,METHOD,mail\ngx_mail_auth_http_module.c:<global>,TYPE_DECL,"static char *ngx_mail_auth_http_merge_conf(ngx_conf_t *cf, void *parent,
    void *child);",13,16,mail\ngx_mail_auth_http_module.c,ngx_mail_auth_http_merge_conf,,false,80,81,ngx_mail_auth_http_merge_conf,,,18,"char* ngx_mail_auth_http_merge_conf (ngx_conf_t*,void*,void*)"
375737,METHOD,mail\ngx_mail_auth_http_module.c:<global>,TYPE_DECL,"static char *ngx_mail_auth_http(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",13,79,mail\ngx_mail_auth_http_module.c,ngx_mail_auth_http,,false,82,82,ngx_mail_auth_http,,,19,"char* ngx_mail_auth_http (ngx_conf_t*,ngx_command_t*,void*)"
375744,METHOD,mail\ngx_mail_auth_http_module.c:<global>,TYPE_DECL,"static char *ngx_mail_auth_http_header(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,mail\ngx_mail_auth_http_module.c,ngx_mail_auth_http_header,,false,83,84,ngx_mail_auth_http_header,,,20,"char* ngx_mail_auth_http_header (ngx_conf_t*,ngx_command_t*,void*)"
375857,METHOD,mail\ngx_mail_auth_http_module.c:<global>,TYPE_DECL,"void
ngx_mail_auth_http_init(ngx_mail_session_t *s)
{
    ngx_int_t                   rc;
    ngx_pool_t                 *pool;
    ngx_mail_auth_http_ctx_t   *ctx;
    ngx_mail_auth_http_conf_t  *ahcf;

    s->connection->log->action = ""in http auth state"";

    pool = ngx_create_pool(2048, s->connection->log);
    if (pool == NULL) {
        ngx_mail_session_internal_server_error(s);
        return;
    }

    ctx = ngx_pcalloc(pool, sizeof(ngx_mail_auth_http_ctx_t));
    if (ctx == NULL) {
        ngx_destroy_pool(pool);
        ngx_mail_session_internal_server_error(s);
        return;
    }

    ctx->pool = pool;

    ahcf = ngx_mail_get_module_srv_conf(s, ngx_mail_auth_http_module);

    ctx->request = ngx_mail_auth_http_create_request(s, pool, ahcf);
    if (ctx->request == NULL) {
        ngx_destroy_pool(ctx->pool);
        ngx_mail_session_internal_server_error(s);
        return;
    }

    ngx_mail_set_ctx(s, ctx, ngx_mail_auth_http_module);

    ctx->peer.sockaddr = ahc...",1,1,mail\ngx_mail_auth_http_module.c,ngx_mail_auth_http_init,,false,161,232,ngx_mail_auth_http_init,,,31,void ngx_mail_auth_http_init (ngx_mail_session_t*)
376137,METHOD,mail\ngx_mail_auth_http_module.c:<global>,TYPE_DECL,"static void
ngx_mail_auth_http_write_handler(ngx_event_t *wev)
{
    ssize_t                     n, size;
    ngx_connection_t           *c;
    ngx_mail_session_t         *s;
    ngx_mail_auth_http_ctx_t   *ctx;
    ngx_mail_auth_http_conf_t  *ahcf;

    c = wev->data;
    s = c->data;

    ctx = ngx_mail_get_module_ctx(s, ngx_mail_auth_http_module);

    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, wev->log, 0,
                   ""mail auth http write handler"");

    if (wev->timedout) {
        ngx_log_error(NGX_LOG_ERR, wev->log, NGX_ETIMEDOUT,
                      ""auth http server %V timed out"", ctx->peer.name);
        ngx_close_connection(c);
        ngx_destroy_pool(ctx->pool);
        ngx_mail_session_internal_server_error(s);
        return;
    }

    size = ctx->request->last - ctx->request->pos;

    n = ngx_send(c, ctx->request->pos, size);

    if (n == NGX_ERROR) {
        ngx_close_connection(c);
        ngx_destroy_pool(ctx->pool);
        ngx_mail_session_internal_server_...",1,1,mail\ngx_mail_auth_http_module.c,ngx_mail_auth_http_write_handler,,false,235,296,ngx_mail_auth_http_write_handler,,,32,void ngx_mail_auth_http_write_handler (ngx_event_t*)
376294,METHOD,mail\ngx_mail_auth_http_module.c:<global>,TYPE_DECL,"static void
ngx_mail_auth_http_read_handler(ngx_event_t *rev)
{
    ssize_t                     n, size;
    ngx_connection_t          *c;
    ngx_mail_session_t        *s;
    ngx_mail_auth_http_ctx_t  *ctx;

    c = rev->data;
    s = c->data;

    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,
                   ""mail auth http read handler"");

    ctx = ngx_mail_get_module_ctx(s, ngx_mail_auth_http_module);

    if (rev->timedout) {
        ngx_log_error(NGX_LOG_ERR, rev->log, NGX_ETIMEDOUT,
                      ""auth http server %V timed out"", ctx->peer.name);
        ngx_close_connection(c);
        ngx_destroy_pool(ctx->pool);
        ngx_mail_session_internal_server_error(s);
        return;
    }

    if (ctx->response == NULL) {
        ctx->response = ngx_create_temp_buf(ctx->pool, 1024);
        if (ctx->response == NULL) {
            ngx_close_connection(c);
            ngx_destroy_pool(ctx->pool);
            ngx_mail_session_internal_server_error(s);
            re...",1,1,mail\ngx_mail_auth_http_module.c,ngx_mail_auth_http_read_handler,,false,299,352,ngx_mail_auth_http_read_handler,,,33,void ngx_mail_auth_http_read_handler (ngx_event_t*)
376440,METHOD,mail\ngx_mail_auth_http_module.c:<global>,TYPE_DECL,"static void
ngx_mail_auth_http_ignore_status_line(ngx_mail_session_t *s,
    ngx_mail_auth_http_ctx_t *ctx)
{
    u_char  *p, ch;
    enum  {
        sw_start = 0,
        sw_H,
        sw_HT,
        sw_HTT,
        sw_HTTP,
        sw_skip,
        sw_almost_done
    } state;

    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
                   ""mail auth http process status line"");

    state = ctx->state;

    for (p = ctx->response->pos; p < ctx->response->last; p++) {
        ch = *p;

        switch (state) {

        /* ""HTTP/"" */
        case sw_start:
            if (ch == 'H') {
                state = sw_H;
                break;
            }
            goto next;

        case sw_H:
            if (ch == 'T') {
                state = sw_HT;
                break;
            }
            goto next;

        case sw_HT:
            if (ch == 'T') {
                state = sw_HTT;
                break;
            }
            goto next;

        case sw...",1,1,mail\ngx_mail_auth_http_module.c,ngx_mail_auth_http_ignore_status_line,,false,355,459,ngx_mail_auth_http_ignore_status_line,,,34,"void ngx_mail_auth_http_ignore_status_line (ngx_mail_session_t*,ngx_mail_auth_http_ctx_t*)"
376648,METHOD,mail\ngx_mail_auth_http_module.c:<global>,TYPE_DECL,"static void
ngx_mail_auth_http_process_headers(ngx_mail_session_t *s,
    ngx_mail_auth_http_ctx_t *ctx)
{
    u_char      *p;
    time_t       timer;
    size_t       len, size;
    ngx_int_t    rc, port, n;
    ngx_addr_t  *peer;

    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
                   ""mail auth http process headers"");

    for ( ;; ) {
        rc = ngx_mail_auth_http_parse_header_line(s, ctx);

        if (rc == NGX_OK) {

#if (NGX_DEBUG)
            {
            ngx_str_t  key, value;

            key.len = ctx->header_name_end - ctx->header_name_start;
            key.data = ctx->header_name_start;
            value.len = ctx->header_end - ctx->header_start;
            value.data = ctx->header_start;

            ngx_log_debug2(NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
                           ""mail auth http header: \""%V: %V\"""",
                           &key, &value);
            }
#endif

            len = ctx->header_name_end - ctx->header_na...",1,1,mail\ngx_mail_auth_http_module.c,ngx_mail_auth_http_process_headers,,false,462,855,ngx_mail_auth_http_process_headers,,,35,"void ngx_mail_auth_http_process_headers (ngx_mail_session_t*,ngx_mail_auth_http_ctx_t*)"
377971,METHOD,mail\ngx_mail_auth_http_module.c:<global>,TYPE_DECL,"static void
ngx_mail_auth_sleep_handler(ngx_event_t *rev)
{
    ngx_connection_t          *c;
    ngx_mail_session_t        *s;
    ngx_mail_core_srv_conf_t  *cscf;

    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0, ""mail auth sleep handler"");

    c = rev->data;
    s = c->data;

    if (rev->timedout) {

        rev->timedout = 0;

        if (s->auth_wait) {
            s->auth_wait = 0;
            ngx_mail_auth_http_init(s);
            return;
        }

        cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);

        rev->handler = cscf->protocol->auth_state;

        s->mail_state = 0;
        s->auth_method = NGX_MAIL_AUTH_PLAIN;

        c->log->action = ""in auth state"";

        ngx_mail_send(c->write);

        if (c->destroyed) {
            return;
        }

        ngx_add_timer(rev, cscf->timeout);

        if (rev->ready) {
            rev->handler(rev);
            return;
        }

        if (ngx_handle_read_event(rev, 0) != NGX_OK) {
          ...",1,1,mail\ngx_mail_auth_http_module.c,ngx_mail_auth_sleep_handler,,false,858,914,ngx_mail_auth_sleep_handler,,,36,void ngx_mail_auth_sleep_handler (ngx_event_t*)
378100,METHOD,mail\ngx_mail_auth_http_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_mail_auth_http_parse_header_line(ngx_mail_session_t *s,
    ngx_mail_auth_http_ctx_t *ctx)
{
    u_char      c, ch, *p;
    enum {
        sw_start = 0,
        sw_name,
        sw_space_before_value,
        sw_value,
        sw_space_after_value,
        sw_almost_done,
        sw_header_almost_done
    } state;

    state = ctx->state;

    for (p = ctx->response->pos; p < ctx->response->last; p++) {
        ch = *p;

        switch (state) {

        /* first char */
        case sw_start:

            switch (ch) {
            case CR:
                ctx->header_end = p;
                state = sw_header_almost_done;
                break;
            case LF:
                ctx->header_end = p;
                goto header_done;
            default:
                state = sw_name;
                ctx->header_name_start = p;

                c = (u_char) (ch | 0x20);
                if (c >= 'a' && c <= 'z') {
                    break;
                }
...",1,1,mail\ngx_mail_auth_http_module.c,ngx_mail_auth_http_parse_header_line,,false,917,1097,ngx_mail_auth_http_parse_header_line,,,37,"ngx_int_t ngx_mail_auth_http_parse_header_line (ngx_mail_session_t*,ngx_mail_auth_http_ctx_t*)"
378475,METHOD,mail\ngx_mail_auth_http_module.c:<global>,TYPE_DECL,"static void
ngx_mail_auth_http_block_read(ngx_event_t *rev)
{
    ngx_connection_t          *c;
    ngx_mail_session_t        *s;
    ngx_mail_auth_http_ctx_t  *ctx;

    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,
                   ""mail auth http block read"");

    if (ngx_handle_read_event(rev, 0) != NGX_OK) {
        c = rev->data;
        s = c->data;

        ctx = ngx_mail_get_module_ctx(s, ngx_mail_auth_http_module);

        ngx_close_connection(ctx->peer.connection);
        ngx_destroy_pool(ctx->pool);
        ngx_mail_session_internal_server_error(s);
    }
}",1,1,mail\ngx_mail_auth_http_module.c,ngx_mail_auth_http_block_read,,false,1100,1120,ngx_mail_auth_http_block_read,,,38,void ngx_mail_auth_http_block_read (ngx_event_t*)
378524,METHOD,mail\ngx_mail_auth_http_module.c:<global>,TYPE_DECL,"static void
ngx_mail_auth_http_dummy_handler(ngx_event_t *ev)
{
    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, ev->log, 0,
                   ""mail auth http dummy handler"");
}",1,1,mail\ngx_mail_auth_http_module.c,ngx_mail_auth_http_dummy_handler,,false,1123,1128,ngx_mail_auth_http_dummy_handler,,,39,void ngx_mail_auth_http_dummy_handler (ngx_event_t*)
378536,METHOD,mail\ngx_mail_auth_http_module.c:<global>,TYPE_DECL,"static ngx_buf_t *
ngx_mail_auth_http_create_request(ngx_mail_session_t *s, ngx_pool_t *pool,
    ngx_mail_auth_http_conf_t *ahcf)
{
    size_t                     len;
    ngx_buf_t                 *b;
    ngx_str_t                  login, passwd;
#if (NGX_MAIL_SSL)
    ngx_str_t                  verify, subject, issuer, serial, fingerprint,
                               raw_cert, cert;
    ngx_connection_t          *c;
    ngx_mail_ssl_conf_t       *sslcf;
#endif
    ngx_mail_core_srv_conf_t  *cscf;

    if (ngx_mail_auth_http_escape(pool, &s->login, &login) != NGX_OK) {
        return NULL;
    }

    if (ngx_mail_auth_http_escape(pool, &s->passwd, &passwd) != NGX_OK) {
        return NULL;
    }

#if (NGX_MAIL_SSL)

    c = s->connection;
    sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);

    if (c->ssl && sslcf->verify) {

        /* certificate details */

        if (ngx_ssl_get_client_verify(c, pool, &verify) != NGX_OK) {
            return NULL;
        }

...",1,1,mail\ngx_mail_auth_http_module.c,ngx_mail_auth_http_create_request,,false,1131,1387,ngx_mail_auth_http_create_request,,,40,"ngx_buf_t ngx_mail_auth_http_create_request (ngx_mail_session_t*,ngx_pool_t*,ngx_mail_auth_http_conf_t*)"
379187,METHOD,mail\ngx_mail_auth_http_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_mail_auth_http_escape(ngx_pool_t *pool, ngx_str_t *text, ngx_str_t *escaped)
{
    u_char     *p;
    uintptr_t   n;

    n = ngx_escape_uri(NULL, text->data, text->len, NGX_ESCAPE_MAIL_AUTH);

    if (n == 0) {
        *escaped = *text;
        return NGX_OK;
    }

    escaped->len = text->len + n * 2;

    p = ngx_pnalloc(pool, escaped->len);
    if (p == NULL) {
        return NGX_ERROR;
    }

    (void) ngx_escape_uri(p, text->data, text->len, NGX_ESCAPE_MAIL_AUTH);

    escaped->data = p;

    return NGX_OK;
}",1,1,mail\ngx_mail_auth_http_module.c,ngx_mail_auth_http_escape,,false,1390,1415,ngx_mail_auth_http_escape,,,41,"ngx_int_t ngx_mail_auth_http_escape (ngx_pool_t*,ngx_str_t*,ngx_str_t*)"
379262,METHOD,mail\ngx_mail_auth_http_module.c:<global>,TYPE_DECL,"static void *
ngx_mail_auth_http_create_conf(ngx_conf_t *cf)
{
    ngx_mail_auth_http_conf_t  *ahcf;

    ahcf = ngx_pcalloc(cf->pool, sizeof(ngx_mail_auth_http_conf_t));
    if (ahcf == NULL) {
        return NULL;
    }

    ahcf->timeout = NGX_CONF_UNSET_MSEC;
    ahcf->pass_client_cert = NGX_CONF_UNSET;

    ahcf->file = cf->conf_file->file.name.data;
    ahcf->line = cf->conf_file->line;

    return ahcf;
}",1,1,mail\ngx_mail_auth_http_module.c,ngx_mail_auth_http_create_conf,,false,1418,1435,ngx_mail_auth_http_create_conf,,,42,void* ngx_mail_auth_http_create_conf (ngx_conf_t*)
379317,METHOD,mail\ngx_mail_auth_http_module.c:<global>,TYPE_DECL,"static char *
ngx_mail_auth_http_merge_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_mail_auth_http_conf_t *prev = parent;
    ngx_mail_auth_http_conf_t *conf = child;

    u_char           *p;
    size_t            len;
    ngx_uint_t        i;
    ngx_table_elt_t  *header;

    if (conf->peer == NULL) {
        conf->peer = prev->peer;
        conf->host_header = prev->host_header;
        conf->uri = prev->uri;

        if (conf->peer == NULL) {
            ngx_log_error(NGX_LOG_EMERG, cf->log, 0,
                          ""no \""auth_http\"" is defined for server in %s:%ui"",
                          conf->file, conf->line);

            return NGX_CONF_ERROR;
        }
    }

    ngx_conf_merge_msec_value(conf->timeout, prev->timeout, 60000);

    ngx_conf_merge_value(conf->pass_client_cert, prev->pass_client_cert, 0);

    if (conf->headers == NULL) {
        conf->headers = prev->headers;
        conf->header = prev->header;
    }

    if (conf->headers && conf->hea...",1,1,mail\ngx_mail_auth_http_module.c,ngx_mail_auth_http_merge_conf,,false,1438,1496,ngx_mail_auth_http_merge_conf,,,43,"char* ngx_mail_auth_http_merge_conf (ngx_conf_t*,void*,void*)"
379583,METHOD,mail\ngx_mail_auth_http_module.c:<global>,TYPE_DECL,"static char *
ngx_mail_auth_http(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_mail_auth_http_conf_t *ahcf = conf;

    ngx_str_t  *value;
    ngx_url_t   u;

    value = cf->args->elts;

    ngx_memzero(&u, sizeof(ngx_url_t));

    u.url = value[1];
    u.default_port = 80;
    u.uri_part = 1;

    if (ngx_strncmp(u.url.data, ""http://"", 7) == 0) {
        u.url.len -= 7;
        u.url.data += 7;
    }

    if (ngx_parse_url(cf->pool, &u) != NGX_OK) {
        if (u.err) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               ""%s in auth_http \""%V\"""", u.err, &u.url);
        }

        return NGX_CONF_ERROR;
    }

    ahcf->peer = u.addrs;

    if (u.family != AF_UNIX) {
        ahcf->host_header = u.host;

    } else {
        ngx_str_set(&ahcf->host_header, ""localhost"");
    }

    ahcf->uri = u.uri;

    if (ahcf->uri.len == 0) {
        ngx_str_set(&ahcf->uri, ""/"");
    }

    return NGX_CONF_OK;
}",1,1,mail\ngx_mail_auth_http_module.c,ngx_mail_auth_http,,false,1499,1545,ngx_mail_auth_http,,,44,"char* ngx_mail_auth_http (ngx_conf_t*,ngx_command_t*,void*)"
379733,METHOD,mail\ngx_mail_auth_http_module.c:<global>,TYPE_DECL,"static char *
ngx_mail_auth_http_header(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_mail_auth_http_conf_t *ahcf = conf;

    ngx_str_t        *value;
    ngx_table_elt_t  *header;

    if (ahcf->headers == NULL) {
        ahcf->headers = ngx_array_create(cf->pool, 1, sizeof(ngx_table_elt_t));
        if (ahcf->headers == NULL) {
            return NGX_CONF_ERROR;
        }
    }

    header = ngx_array_push(ahcf->headers);
    if (header == NULL) {
        return NGX_CONF_ERROR;
    }

    value = cf->args->elts;

    header->key = value[1];
    header->value = value[2];

    return NGX_CONF_OK;
}",1,1,mail\ngx_mail_auth_http_module.c,ngx_mail_auth_http_header,,false,1548,1574,ngx_mail_auth_http_header,,,45,"char* ngx_mail_auth_http_header (ngx_conf_t*,ngx_command_t*,void*)"
379820,METHOD,mail\ngx_mail_core_module.c:<global>,TYPE_DECL,<global>,1,1,mail\ngx_mail_core_module.c,mail\ngx_mail_core_module.c:<global>,,false,1,678,<global>,,,1,
379822,METHOD,mail\ngx_mail_core_module.c:<global>,TYPE_DECL,static void *ngx_mail_core_create_main_conf(ngx_conf_t *cf);,13,59,mail\ngx_mail_core_module.c,ngx_mail_core_create_main_conf,,false,14,14,ngx_mail_core_create_main_conf,,,1,void* ngx_mail_core_create_main_conf (ngx_conf_t*)
379827,METHOD,mail\ngx_mail_core_module.c:<global>,TYPE_DECL,static void *ngx_mail_core_create_srv_conf(ngx_conf_t *cf);,13,58,mail\ngx_mail_core_module.c,ngx_mail_core_create_srv_conf,,false,15,15,ngx_mail_core_create_srv_conf,,,2,void* ngx_mail_core_create_srv_conf (ngx_conf_t*)
379832,METHOD,mail\ngx_mail_core_module.c:<global>,TYPE_DECL,"static char *ngx_mail_core_merge_srv_conf(ngx_conf_t *cf, void *parent,
    void *child);",13,16,mail\ngx_mail_core_module.c,ngx_mail_core_merge_srv_conf,,false,16,17,ngx_mail_core_merge_srv_conf,,,3,"char* ngx_mail_core_merge_srv_conf (ngx_conf_t*,void*,void*)"
379839,METHOD,mail\ngx_mail_core_module.c:<global>,TYPE_DECL,"static char *ngx_mail_core_server(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,mail\ngx_mail_core_module.c,ngx_mail_core_server,,false,18,19,ngx_mail_core_server,,,4,"char* ngx_mail_core_server (ngx_conf_t*,ngx_command_t*,void*)"
379846,METHOD,mail\ngx_mail_core_module.c:<global>,TYPE_DECL,"static char *ngx_mail_core_listen(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,mail\ngx_mail_core_module.c,ngx_mail_core_listen,,false,20,21,ngx_mail_core_listen,,,5,"char* ngx_mail_core_listen (ngx_conf_t*,ngx_command_t*,void*)"
379853,METHOD,mail\ngx_mail_core_module.c:<global>,TYPE_DECL,"static char *ngx_mail_core_protocol(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,mail\ngx_mail_core_module.c,ngx_mail_core_protocol,,false,22,23,ngx_mail_core_protocol,,,6,"char* ngx_mail_core_protocol (ngx_conf_t*,ngx_command_t*,void*)"
379860,METHOD,mail\ngx_mail_core_module.c:<global>,TYPE_DECL,"static char *ngx_mail_core_error_log(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,mail\ngx_mail_core_module.c,ngx_mail_core_error_log,,false,24,25,ngx_mail_core_error_log,,,7,"char* ngx_mail_core_error_log (ngx_conf_t*,ngx_command_t*,void*)"
379867,METHOD,mail\ngx_mail_core_module.c:<global>,TYPE_DECL,"static char *ngx_mail_core_resolver(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,mail\ngx_mail_core_module.c,ngx_mail_core_resolver,,false,26,27,ngx_mail_core_resolver,,,8,"char* ngx_mail_core_resolver (ngx_conf_t*,ngx_command_t*,void*)"
380003,METHOD,mail\ngx_mail_core_module.c:<global>,TYPE_DECL,"static void *
ngx_mail_core_create_main_conf(ngx_conf_t *cf)
{
    ngx_mail_core_main_conf_t  *cmcf;

    cmcf = ngx_pcalloc(cf->pool, sizeof(ngx_mail_core_main_conf_t));
    if (cmcf == NULL) {
        return NULL;
    }

    if (ngx_array_init(&cmcf->servers, cf->pool, 4,
                       sizeof(ngx_mail_core_srv_conf_t *))
        != NGX_OK)
    {
        return NULL;
    }

    if (ngx_array_init(&cmcf->listen, cf->pool, 4, sizeof(ngx_mail_listen_t))
        != NGX_OK)
    {
        return NULL;
    }

    return cmcf;
}",1,1,mail\ngx_mail_core_module.c,ngx_mail_core_create_main_conf,,false,119,143,ngx_mail_core_create_main_conf,,,15,void* ngx_mail_core_create_main_conf (ngx_conf_t*)
380060,METHOD,mail\ngx_mail_core_module.c:<global>,TYPE_DECL,"static void *
ngx_mail_core_create_srv_conf(ngx_conf_t *cf)
{
    ngx_mail_core_srv_conf_t  *cscf;

    cscf = ngx_pcalloc(cf->pool, sizeof(ngx_mail_core_srv_conf_t));
    if (cscf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     cscf->protocol = NULL;
     *     cscf->error_log = NULL;
     */

    cscf->timeout = NGX_CONF_UNSET_MSEC;
    cscf->resolver_timeout = NGX_CONF_UNSET_MSEC;

    cscf->resolver = NGX_CONF_UNSET_PTR;

    cscf->file_name = cf->conf_file->file.name.data;
    cscf->line = cf->conf_file->line;

    return cscf;
}",1,1,mail\ngx_mail_core_module.c,ngx_mail_core_create_srv_conf,,false,146,172,ngx_mail_core_create_srv_conf,,,16,void* ngx_mail_core_create_srv_conf (ngx_conf_t*)
380120,METHOD,mail\ngx_mail_core_module.c:<global>,TYPE_DECL,"static char *
ngx_mail_core_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_mail_core_srv_conf_t *prev = parent;
    ngx_mail_core_srv_conf_t *conf = child;

    ngx_conf_merge_msec_value(conf->timeout, prev->timeout, 60000);
    ngx_conf_merge_msec_value(conf->resolver_timeout, prev->resolver_timeout,
                              30000);


    ngx_conf_merge_str_value(conf->server_name, prev->server_name, """");

    if (conf->server_name.len == 0) {
        conf->server_name = cf->cycle->hostname;
    }

    if (conf->protocol == NULL) {
        ngx_log_error(NGX_LOG_EMERG, cf->log, 0,
                      ""unknown mail protocol for server in %s:%ui"",
                      conf->file_name, conf->line);
        return NGX_CONF_ERROR;
    }

    if (conf->error_log == NULL) {
        if (prev->error_log) {
            conf->error_log = prev->error_log;
        } else {
            conf->error_log = &cf->cycle->new_log;
        }
    }

    ngx_conf_merge_ptr_valu...",1,1,mail\ngx_mail_core_module.c,ngx_mail_core_merge_srv_conf,,false,175,210,ngx_mail_core_merge_srv_conf,,,17,"char* ngx_mail_core_merge_srv_conf (ngx_conf_t*,void*,void*)"
380240,METHOD,mail\ngx_mail_core_module.c:<global>,TYPE_DECL,"static char *
ngx_mail_core_server(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char                       *rv;
    void                       *mconf;
    ngx_uint_t                  m;
    ngx_conf_t                  pcf;
    ngx_mail_module_t          *module;
    ngx_mail_conf_ctx_t        *ctx, *mail_ctx;
    ngx_mail_core_srv_conf_t   *cscf, **cscfp;
    ngx_mail_core_main_conf_t  *cmcf;

    ctx = ngx_pcalloc(cf->pool, sizeof(ngx_mail_conf_ctx_t));
    if (ctx == NULL) {
        return NGX_CONF_ERROR;
    }

    mail_ctx = cf->ctx;
    ctx->main_conf = mail_ctx->main_conf;

    /* the server{}'s srv_conf */

    ctx->srv_conf = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_mail_max_module);
    if (ctx->srv_conf == NULL) {
        return NGX_CONF_ERROR;
    }

    for (m = 0; cf->cycle->modules[m]; m++) {
        if (cf->cycle->modules[m]->type != NGX_MAIL_MODULE) {
            continue;
        }

        module = cf->cycle->modules[m]->ctx;

        if (module->create_...",1,1,mail\ngx_mail_core_module.c,ngx_mail_core_server,,false,213,290,ngx_mail_core_server,,,18,"char* ngx_mail_core_server (ngx_conf_t*,ngx_command_t*,void*)"
380470,METHOD,mail\ngx_mail_core_module.c:<global>,TYPE_DECL,"static char *
ngx_mail_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_mail_core_srv_conf_t  *cscf = conf;

    ngx_str_t                  *value, size;
    ngx_url_t                   u;
    ngx_uint_t                  i, n, m;
    ngx_mail_listen_t          *ls, *als;
    ngx_mail_module_t          *module;
    ngx_mail_core_main_conf_t  *cmcf;

    cscf->listen = 1;

    value = cf->args->elts;

    ngx_memzero(&u, sizeof(ngx_url_t));

    u.url = value[1];
    u.listen = 1;

    if (ngx_parse_url(cf->pool, &u) != NGX_OK) {
        if (u.err) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               ""%s in \""%V\"" of the \""listen\"" directive"",
                               u.err, &u.url);
        }

        return NGX_CONF_ERROR;
    }

    cmcf = ngx_mail_conf_get_module_main_conf(cf, ngx_mail_core_module);

    ls = ngx_array_push_n(&cmcf->listen, u.naddrs);
    if (ls == NULL) {
        return NGX_CONF_ERROR;
    }

    ngx_mem...",1,1,mail\ngx_mail_core_module.c,ngx_mail_core_listen,,false,293,583,ngx_mail_core_listen,,,19,"char* ngx_mail_core_listen (ngx_conf_t*,ngx_command_t*,void*)"
381169,METHOD,mail\ngx_mail_core_module.c:<global>,TYPE_DECL,"static char *
ngx_mail_core_protocol(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_mail_core_srv_conf_t  *cscf = conf;

    ngx_str_t          *value;
    ngx_uint_t          m;
    ngx_mail_module_t  *module;

    value = cf->args->elts;

    for (m = 0; cf->cycle->modules[m]; m++) {
        if (cf->cycle->modules[m]->type != NGX_MAIL_MODULE) {
            continue;
        }

        module = cf->cycle->modules[m]->ctx;

        if (module->protocol
            && ngx_strcmp(module->protocol->name.data, value[1].data) == 0)
        {
            cscf->protocol = module->protocol;

            return NGX_CONF_OK;
        }
    }

    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                       ""unknown protocol \""%V\"""", &value[1]);
    return NGX_CONF_ERROR;
}",1,1,mail\ngx_mail_core_module.c,ngx_mail_core_protocol,,false,586,616,ngx_mail_core_protocol,,,20,"char* ngx_mail_core_protocol (ngx_conf_t*,ngx_command_t*,void*)"
381271,METHOD,mail\ngx_mail_core_module.c:<global>,TYPE_DECL,"static char *
ngx_mail_core_error_log(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_mail_core_srv_conf_t  *cscf = conf;

    return ngx_log_set_log(cf, &cscf->error_log);
}",1,1,mail\ngx_mail_core_module.c,ngx_mail_core_error_log,,false,619,625,ngx_mail_core_error_log,,,21,"char* ngx_mail_core_error_log (ngx_conf_t*,ngx_command_t*,void*)"
381289,METHOD,mail\ngx_mail_core_module.c:<global>,TYPE_DECL,"static char *
ngx_mail_core_resolver(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_mail_core_srv_conf_t  *cscf = conf;

    ngx_str_t  *value;

    value = cf->args->elts;

    if (cscf->resolver != NGX_CONF_UNSET_PTR) {
        return ""is duplicate"";
    }

    if (ngx_strcmp(value[1].data, ""off"") == 0) {
        cscf->resolver = NULL;
        return NGX_CONF_OK;
    }

    cscf->resolver = ngx_resolver_create(cf, &value[1], cf->args->nelts - 1);
    if (cscf->resolver == NULL) {
        return NGX_CONF_ERROR;
    }

    return NGX_CONF_OK;
}",1,1,mail\ngx_mail_core_module.c,ngx_mail_core_resolver,,false,628,652,ngx_mail_core_resolver,,,22,"char* ngx_mail_core_resolver (ngx_conf_t*,ngx_command_t*,void*)"
381363,METHOD,mail\ngx_mail_core_module.c:<global>,TYPE_DECL,"char *
ngx_mail_capabilities(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char  *p = conf;

    ngx_str_t    *c, *value;
    ngx_uint_t    i;
    ngx_array_t  *a;

    a = (ngx_array_t *) (p + cmd->offset);

    value = cf->args->elts;

    for (i = 1; i < cf->args->nelts; i++) {
        c = ngx_array_push(a);
        if (c == NULL) {
            return NGX_CONF_ERROR;
        }

        *c = value[i];
    }

    return NGX_CONF_OK;
}",1,1,mail\ngx_mail_core_module.c,ngx_mail_capabilities,,false,655,678,ngx_mail_capabilities,,,23,"char* ngx_mail_capabilities (ngx_conf_t*,ngx_command_t*,void*)"
381439,METHOD,mail\ngx_mail_handler.c:<global>,TYPE_DECL,<global>,1,1,mail\ngx_mail_handler.c,mail\ngx_mail_handler.c:<global>,,false,1,884,<global>,,,1,
381441,METHOD,mail\ngx_mail_handler.c:<global>,TYPE_DECL,static void ngx_mail_init_session(ngx_connection_t *c);,13,54,mail\ngx_mail_handler.c,ngx_mail_init_session,,false,14,14,ngx_mail_init_session,,,1,void ngx_mail_init_session (ngx_connection_t*)
381446,METHOD,mail\ngx_mail_handler.c:<global>,TYPE_DECL,"void
ngx_mail_init_connection(ngx_connection_t *c)
{
    size_t                     len;
    ngx_uint_t                 i;
    ngx_mail_port_t           *port;
    struct sockaddr           *sa;
    struct sockaddr_in        *sin;
    ngx_mail_log_ctx_t        *ctx;
    ngx_mail_in_addr_t        *addr;
    ngx_mail_session_t        *s;
    ngx_mail_addr_conf_t      *addr_conf;
    ngx_mail_core_srv_conf_t  *cscf;
    u_char                     text[NGX_SOCKADDR_STRLEN];
#if (NGX_HAVE_INET6)
    struct sockaddr_in6       *sin6;
    ngx_mail_in6_addr_t       *addr6;
#endif


    /* find the server configuration for the address:port */

    port = c->listening->servers;

    if (port->naddrs > 1) {

        /*
         * There are several addresses on this port and one of them
         * is the ""*:port"" wildcard so getsockname() is needed to determine
         * the server address.
         *
         * AcceptEx() already gave this address.
         */

        if (ngx_connection_local...",1,1,mail\ngx_mail_handler.c,ngx_mail_init_connection,,false,24,179,ngx_mail_init_connection,,,2,void ngx_mail_init_connection (ngx_connection_t*)
381730,METHOD,mail\ngx_mail_handler.c:<global>,TYPE_DECL,"static void
ngx_mail_init_session(ngx_connection_t *c)
{
    ngx_mail_session_t        *s;
    ngx_mail_core_srv_conf_t  *cscf;

    s = c->data;

    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);

    s->protocol = cscf->protocol->type;

    s->ctx = ngx_pcalloc(c->pool, sizeof(void *) * ngx_mail_max_module);
    if (s->ctx == NULL) {
        ngx_mail_session_internal_server_error(s);
        return;
    }

    c->write->handler = ngx_mail_send;

    cscf->protocol->init_session(s, c);
}",1,1,mail\ngx_mail_handler.c,ngx_mail_init_session,,false,333,354,ngx_mail_init_session,,,3,void ngx_mail_init_session (ngx_connection_t*)
381793,METHOD,mail\ngx_mail_handler.c:<global>,TYPE_DECL,"ngx_int_t
ngx_mail_salt(ngx_mail_session_t *s, ngx_connection_t *c,
    ngx_mail_core_srv_conf_t *cscf)
{
    s->salt.data = ngx_pnalloc(c->pool,
                               sizeof("" <18446744073709551616.@>"" CRLF) - 1
                               + NGX_TIME_T_LEN
                               + cscf->server_name.len);
    if (s->salt.data == NULL) {
        return NGX_ERROR;
    }

    s->salt.len = ngx_sprintf(s->salt.data, ""<%ul.%T@%V>"" CRLF,
                              ngx_random(), ngx_time(), &cscf->server_name)
                  - s->salt.data;

    return NGX_OK;
}",1,1,mail\ngx_mail_handler.c,ngx_mail_salt,,false,357,374,ngx_mail_salt,,,4,"ngx_int_t ngx_mail_salt (ngx_mail_session_t*,ngx_connection_t*,ngx_mail_core_srv_conf_t*)"
381815,METHOD,mail\ngx_mail_handler.c:<global>,TYPE_DECL,"ngx_int_t
ngx_mail_auth_plain(ngx_mail_session_t *s, ngx_connection_t *c, ngx_uint_t n)
{
    u_char     *p, *last;
    ngx_str_t  *arg, plain;

    arg = s->args.elts;

#if (NGX_DEBUG_MAIL_PASSWD)
    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
                   ""mail auth plain: \""%V\"""", &arg[n]);
#endif

    plain.data = ngx_pnalloc(c->pool, ngx_base64_decoded_length(arg[n].len));
    if (plain.data == NULL) {
        return NGX_ERROR;
    }

    if (ngx_decode_base64(&plain, &arg[n]) != NGX_OK) {
        ngx_log_error(NGX_LOG_INFO, c->log, 0,
            ""client sent invalid base64 encoding in AUTH PLAIN command"");
        return NGX_MAIL_PARSE_INVALID_COMMAND;
    }

    p = plain.data;
    last = p + plain.len;

    while (p < last && *p++) { /* void */ }

    if (p == last) {
        ngx_log_error(NGX_LOG_INFO, c->log, 0,
                      ""client sent invalid login in AUTH PLAIN command"");
        return NGX_MAIL_PARSE_INVALID_COMMAND;
    }

    s->login.data = p;

 ...",1,1,mail\ngx_mail_handler.c,ngx_mail_auth_plain,,false,400,456,ngx_mail_auth_plain,,,5,"ngx_int_t ngx_mail_auth_plain (ngx_mail_session_t*,ngx_connection_t*,ngx_uint_t)"
381974,METHOD,mail\ngx_mail_handler.c:<global>,TYPE_DECL,"ngx_int_t
ngx_mail_auth_login_username(ngx_mail_session_t *s, ngx_connection_t *c,
    ngx_uint_t n)
{
    ngx_str_t  *arg;

    arg = s->args.elts;

    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
                   ""mail auth login username: \""%V\"""", &arg[n]);

    s->login.data = ngx_pnalloc(c->pool, ngx_base64_decoded_length(arg[n].len));
    if (s->login.data == NULL) {
        return NGX_ERROR;
    }

    if (ngx_decode_base64(&s->login, &arg[n]) != NGX_OK) {
        ngx_log_error(NGX_LOG_INFO, c->log, 0,
            ""client sent invalid base64 encoding in AUTH LOGIN command"");
        return NGX_MAIL_PARSE_INVALID_COMMAND;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
                   ""mail auth login username: \""%V\"""", &s->login);

    return NGX_OK;
}",1,1,mail\ngx_mail_handler.c,ngx_mail_auth_login_username,,false,459,485,ngx_mail_auth_login_username,,,6,"ngx_int_t ngx_mail_auth_login_username (ngx_mail_session_t*,ngx_connection_t*,ngx_uint_t)"
382062,METHOD,mail\ngx_mail_handler.c:<global>,TYPE_DECL,"ngx_int_t
ngx_mail_auth_login_password(ngx_mail_session_t *s, ngx_connection_t *c)
{
    ngx_str_t  *arg;

    arg = s->args.elts;

#if (NGX_DEBUG_MAIL_PASSWD)
    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
                   ""mail auth login password: \""%V\"""", &arg[0]);
#endif

    s->passwd.data = ngx_pnalloc(c->pool,
                                 ngx_base64_decoded_length(arg[0].len));
    if (s->passwd.data == NULL) {
        return NGX_ERROR;
    }

    if (ngx_decode_base64(&s->passwd, &arg[0]) != NGX_OK) {
        ngx_log_error(NGX_LOG_INFO, c->log, 0,
            ""client sent invalid base64 encoding in AUTH LOGIN command"");
        return NGX_MAIL_PARSE_INVALID_COMMAND;
    }

#if (NGX_DEBUG_MAIL_PASSWD)
    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
                   ""mail auth login password: \""%V\"""", &s->passwd);
#endif

    return NGX_DONE;
}",1,1,mail\ngx_mail_handler.c,ngx_mail_auth_login_password,,false,488,518,ngx_mail_auth_login_password,,,7,"ngx_int_t ngx_mail_auth_login_password (ngx_mail_session_t*,ngx_connection_t*)"
382127,METHOD,mail\ngx_mail_handler.c:<global>,TYPE_DECL,"ngx_int_t
ngx_mail_auth_cram_md5_salt(ngx_mail_session_t *s, ngx_connection_t *c,
    char *prefix, size_t len)
{
    u_char      *p;
    ngx_str_t    salt;
    ngx_uint_t   n;

    p = ngx_pnalloc(c->pool, len + ngx_base64_encoded_length(s->salt.len) + 2);
    if (p == NULL) {
        return NGX_ERROR;
    }

    salt.data = ngx_cpymem(p, prefix, len);
    s->salt.len -= 2;

    ngx_encode_base64(&salt, &s->salt);

    s->salt.len += 2;
    n = len + salt.len;
    p[n++] = CR; p[n++] = LF;

    s->out.len = n;
    s->out.data = p;

    return NGX_OK;
}",1,1,mail\ngx_mail_handler.c,ngx_mail_auth_cram_md5_salt,,false,521,547,ngx_mail_auth_cram_md5_salt,,,8,"ngx_int_t ngx_mail_auth_cram_md5_salt (ngx_mail_session_t*,ngx_connection_t*,char*,size_t)"
382225,METHOD,mail\ngx_mail_handler.c:<global>,TYPE_DECL,"ngx_int_t
ngx_mail_auth_cram_md5(ngx_mail_session_t *s, ngx_connection_t *c)
{
    u_char     *p, *last;
    ngx_str_t  *arg;

    arg = s->args.elts;

    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
                   ""mail auth cram-md5: \""%V\"""", &arg[0]);

    s->login.data = ngx_pnalloc(c->pool, ngx_base64_decoded_length(arg[0].len));
    if (s->login.data == NULL) {
        return NGX_ERROR;
    }

    if (ngx_decode_base64(&s->login, &arg[0]) != NGX_OK) {
        ngx_log_error(NGX_LOG_INFO, c->log, 0,
            ""client sent invalid base64 encoding in AUTH CRAM-MD5 command"");
        return NGX_MAIL_PARSE_INVALID_COMMAND;
    }

    p = s->login.data;
    last = p + s->login.len;

    while (p < last) {
        if (*p++ == ' ') {
            s->login.len = p - s->login.data - 1;
            s->passwd.len = last - p;
            s->passwd.data = p;
            break;
        }
    }

    if (s->passwd.len != 32) {
        ngx_log_error(NGX_LOG_INFO, c->log, 0,
            ""c...",1,1,mail\ngx_mail_handler.c,ngx_mail_auth_cram_md5,,false,550,596,ngx_mail_auth_cram_md5,,,9,"ngx_int_t ngx_mail_auth_cram_md5 (ngx_mail_session_t*,ngx_connection_t*)"
382401,METHOD,mail\ngx_mail_handler.c:<global>,TYPE_DECL,"ngx_int_t
ngx_mail_auth_external(ngx_mail_session_t *s, ngx_connection_t *c,
    ngx_uint_t n)
{
    ngx_str_t  *arg, external;

    arg = s->args.elts;

    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
                   ""mail auth external: \""%V\"""", &arg[n]);

    external.data = ngx_pnalloc(c->pool, ngx_base64_decoded_length(arg[n].len));
    if (external.data == NULL) {
        return NGX_ERROR;
    }

    if (ngx_decode_base64(&external, &arg[n]) != NGX_OK) {
        ngx_log_error(NGX_LOG_INFO, c->log, 0,
            ""client sent invalid base64 encoding in AUTH EXTERNAL command"");
        return NGX_MAIL_PARSE_INVALID_COMMAND;
    }

    s->login.len = external.len;
    s->login.data = external.data;

    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
                   ""mail auth external: \""%V\"""", &s->login);

    s->auth_method = NGX_MAIL_AUTH_EXTERNAL;

    return NGX_DONE;
}",1,1,mail\ngx_mail_handler.c,ngx_mail_auth_external,,false,599,630,ngx_mail_auth_external,,,10,"ngx_int_t ngx_mail_auth_external (ngx_mail_session_t*,ngx_connection_t*,ngx_uint_t)"
382507,METHOD,mail\ngx_mail_handler.c:<global>,TYPE_DECL,"void
ngx_mail_send(ngx_event_t *wev)
{
    ngx_int_t                  n;
    ngx_connection_t          *c;
    ngx_mail_session_t        *s;
    ngx_mail_core_srv_conf_t  *cscf;

    c = wev->data;
    s = c->data;

    if (wev->timedout) {
        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, ""client timed out"");
        c->timedout = 1;
        ngx_mail_close_connection(c);
        return;
    }

    if (s->out.len == 0) {
        if (ngx_handle_write_event(c->write, 0) != NGX_OK) {
            ngx_mail_close_connection(c);
        }

        return;
    }

    n = c->send(c, s->out.data, s->out.len);

    if (n > 0) {
        s->out.data += n;
        s->out.len -= n;

        if (s->out.len != 0) {
            goto again;
        }

        if (wev->timer_set) {
            ngx_del_timer(wev);
        }

        if (s->quit) {
            ngx_mail_close_connection(c);
            return;
        }

        if (s->blocked) {
            c->read->handler(c->read);
        }

...",1,1,mail\ngx_mail_handler.c,ngx_mail_send,,false,633,702,ngx_mail_send,,,11,void ngx_mail_send (ngx_event_t*)
382676,METHOD,mail\ngx_mail_handler.c:<global>,TYPE_DECL,"ngx_int_t
ngx_mail_read_command(ngx_mail_session_t *s, ngx_connection_t *c)
{
    ssize_t                    n;
    ngx_int_t                  rc;
    ngx_str_t                  l;
    ngx_mail_core_srv_conf_t  *cscf;

    n = c->recv(c, s->buffer->last, s->buffer->end - s->buffer->last);

    if (n == NGX_ERROR || n == 0) {
        ngx_mail_close_connection(c);
        return NGX_ERROR;
    }

    if (n > 0) {
        s->buffer->last += n;
    }

    if (n == NGX_AGAIN) {
        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
            ngx_mail_session_internal_server_error(s);
            return NGX_ERROR;
        }

        if (s->buffer->pos == s->buffer->last) {
            return NGX_AGAIN;
        }
    }

    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);

    rc = cscf->protocol->parse_command(s);

    if (rc == NGX_AGAIN) {

        if (s->buffer->last < s->buffer->end) {
            return rc;
        }

        l.len = s->buffer->last - s->buffer->st...",1,1,mail\ngx_mail_handler.c,ngx_mail_read_command,,false,705,766,ngx_mail_read_command,,,12,"ngx_int_t ngx_mail_read_command (ngx_mail_session_t*,ngx_connection_t*)"
382863,METHOD,mail\ngx_mail_handler.c:<global>,TYPE_DECL,"void
ngx_mail_auth(ngx_mail_session_t *s, ngx_connection_t *c)
{
    s->args.nelts = 0;

    if (s->buffer->pos == s->buffer->last) {
        s->buffer->pos = s->buffer->start;
        s->buffer->last = s->buffer->start;
    }

    s->state = 0;

    if (c->read->timer_set) {
        ngx_del_timer(c->read);
    }

    s->login_attempt++;

    ngx_mail_auth_http_init(s);
}",1,1,mail\ngx_mail_handler.c,ngx_mail_auth,,false,769,788,ngx_mail_auth,,,13,"void ngx_mail_auth (ngx_mail_session_t*,ngx_connection_t*)"
382933,METHOD,mail\ngx_mail_handler.c:<global>,TYPE_DECL,"void
ngx_mail_session_internal_server_error(ngx_mail_session_t *s)
{
    ngx_mail_core_srv_conf_t  *cscf;

    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);

    s->out = cscf->protocol->internal_server_error;
    s->quit = 1;

    ngx_mail_send(s->connection->write);
}",1,1,mail\ngx_mail_handler.c,ngx_mail_session_internal_server_error,,false,791,802,ngx_mail_session_internal_server_error,,,14,void ngx_mail_session_internal_server_error (ngx_mail_session_t*)
382964,METHOD,mail\ngx_mail_handler.c:<global>,TYPE_DECL,"void
ngx_mail_close_connection(ngx_connection_t *c)
{
    ngx_pool_t  *pool;

    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
                   ""close mail connection: %d"", c->fd);

#if (NGX_MAIL_SSL)

    if (c->ssl) {
        if (ngx_ssl_shutdown(c) == NGX_AGAIN) {
            c->ssl->handler = ngx_mail_close_connection;
            return;
        }
    }

#endif

#if (NGX_STAT_STUB)
    (void) ngx_atomic_fetch_add(ngx_stat_active, -1);
#endif

    c->destroyed = 1;

    pool = c->pool;

    ngx_close_connection(c);

    ngx_destroy_pool(pool);
}",1,1,mail\ngx_mail_handler.c,ngx_mail_close_connection,,false,805,835,ngx_mail_close_connection,,,15,void ngx_mail_close_connection (ngx_connection_t*)
382994,METHOD,mail\ngx_mail_handler.c:<global>,TYPE_DECL,"u_char *
ngx_mail_log_error(ngx_log_t *log, u_char *buf, size_t len)
{
    u_char              *p;
    ngx_mail_session_t  *s;
    ngx_mail_log_ctx_t  *ctx;

    if (log->action) {
        p = ngx_snprintf(buf, len, "" while %s"", log->action);
        len -= p - buf;
        buf = p;
    }

    ctx = log->data;

    p = ngx_snprintf(buf, len, "", client: %V"", ctx->client);
    len -= p - buf;
    buf = p;

    s = ctx->session;

    if (s == NULL) {
        return p;
    }

    p = ngx_snprintf(buf, len, ""%s, server: %V"",
                     s->starttls ? "" using starttls"" : """",
                     s->addr_text);
    len -= p - buf;
    buf = p;

    if (s->login.len == 0) {
        return p;
    }

    p = ngx_snprintf(buf, len, "", login: \""%V\"""", &s->login);
    len -= p - buf;
    buf = p;

    if (s->proxy == NULL) {
        return p;
    }

    p = ngx_snprintf(buf, len, "", upstream: %V"", s->proxy->upstream.name);

    return p;
}",1,1,mail\ngx_mail_handler.c,ngx_mail_log_error,,false,838,884,ngx_mail_log_error,,,16,"u_char ngx_mail_log_error (ngx_log_t*,u_char*,size_t)"
383149,METHOD,mail\ngx_mail_imap_handler.c:<global>,TYPE_DECL,<global>,1,1,mail\ngx_mail_imap_handler.c,mail\ngx_mail_imap_handler.c:<global>,,false,1,472,<global>,,,1,
383151,METHOD,mail\ngx_mail_imap_handler.c:<global>,TYPE_DECL,"static ngx_int_t ngx_mail_imap_login(ngx_mail_session_t *s,
    ngx_connection_t *c);",18,24,mail\ngx_mail_imap_handler.c,ngx_mail_imap_login,,false,15,16,ngx_mail_imap_login,,,1,"ngx_int_t ngx_mail_imap_login (ngx_mail_session_t*,ngx_connection_t*)"
383157,METHOD,mail\ngx_mail_imap_handler.c:<global>,TYPE_DECL,"static ngx_int_t ngx_mail_imap_authenticate(ngx_mail_session_t *s,
    ngx_connection_t *c);",18,24,mail\ngx_mail_imap_handler.c,ngx_mail_imap_authenticate,,false,17,18,ngx_mail_imap_authenticate,,,2,"ngx_int_t ngx_mail_imap_authenticate (ngx_mail_session_t*,ngx_connection_t*)"
383163,METHOD,mail\ngx_mail_imap_handler.c:<global>,TYPE_DECL,"static ngx_int_t ngx_mail_imap_capability(ngx_mail_session_t *s,
    ngx_connection_t *c);",18,24,mail\ngx_mail_imap_handler.c,ngx_mail_imap_capability,,false,19,20,ngx_mail_imap_capability,,,3,"ngx_int_t ngx_mail_imap_capability (ngx_mail_session_t*,ngx_connection_t*)"
383169,METHOD,mail\ngx_mail_imap_handler.c:<global>,TYPE_DECL,"static ngx_int_t ngx_mail_imap_starttls(ngx_mail_session_t *s,
    ngx_connection_t *c);",18,24,mail\ngx_mail_imap_handler.c,ngx_mail_imap_starttls,,false,21,22,ngx_mail_imap_starttls,,,4,"ngx_int_t ngx_mail_imap_starttls (ngx_mail_session_t*,ngx_connection_t*)"
383187,METHOD,mail\ngx_mail_imap_handler.c:<global>,TYPE_DECL,"void
ngx_mail_imap_init_session(ngx_mail_session_t *s, ngx_connection_t *c)
{
    ngx_mail_core_srv_conf_t  *cscf;

    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);

    ngx_str_set(&s->out, imap_greeting);

    c->read->handler = ngx_mail_imap_init_protocol;

    ngx_add_timer(c->read, cscf->timeout);

    if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
        ngx_mail_close_connection(c);
    }

    ngx_mail_send(c->write);
}",1,1,mail\ngx_mail_imap_handler.c,ngx_mail_imap_init_session,,false,36,54,ngx_mail_imap_init_session,,,15,"void ngx_mail_imap_init_session (ngx_mail_session_t*,ngx_connection_t*)"
383234,METHOD,mail\ngx_mail_imap_handler.c:<global>,TYPE_DECL,"void
ngx_mail_imap_init_protocol(ngx_event_t *rev)
{
    ngx_connection_t          *c;
    ngx_mail_session_t        *s;
    ngx_mail_imap_srv_conf_t  *iscf;

    c = rev->data;

    c->log->action = ""in auth state"";

    if (rev->timedout) {
        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, ""client timed out"");
        c->timedout = 1;
        ngx_mail_close_connection(c);
        return;
    }

    s = c->data;

    if (s->buffer == NULL) {
        if (ngx_array_init(&s->args, c->pool, 2, sizeof(ngx_str_t))
            == NGX_ERROR)
        {
            ngx_mail_session_internal_server_error(s);
            return;
        }

        iscf = ngx_mail_get_module_srv_conf(s, ngx_mail_imap_module);

        s->buffer = ngx_create_temp_buf(c->pool, iscf->client_buffer_size);
        if (s->buffer == NULL) {
            ngx_mail_session_internal_server_error(s);
            return;
        }
    }

    s->mail_state = ngx_imap_start;
    c->read->handler = ngx_mail_imap_auth_s...",1,1,mail\ngx_mail_imap_handler.c,ngx_mail_imap_init_protocol,,false,57,98,ngx_mail_imap_init_protocol,,,16,void ngx_mail_imap_init_protocol (ngx_event_t*)
383344,METHOD,mail\ngx_mail_imap_handler.c:<global>,TYPE_DECL,"void
ngx_mail_imap_auth_state(ngx_event_t *rev)
{
    u_char              *p, *dst, *src, *end;
    ngx_str_t           *arg;
    ngx_int_t            rc;
    ngx_uint_t           tag, i;
    ngx_connection_t    *c;
    ngx_mail_session_t  *s;

    c = rev->data;
    s = c->data;

    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0, ""imap auth state"");

    if (rev->timedout) {
        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, ""client timed out"");
        c->timedout = 1;
        ngx_mail_close_connection(c);
        return;
    }

    if (s->out.len) {
        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0, ""imap send handler busy"");
        s->blocked = 1;
        return;
    }

    s->blocked = 0;

    rc = ngx_mail_read_command(s, c);

    if (rc == NGX_AGAIN || rc == NGX_ERROR) {
        return;
    }

    tag = 1;
    s->text.len = 0;
    ngx_str_set(&s->out, imap_ok);

    if (rc == NGX_OK) {

        ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0, ""imap auth command: %i"",
...",1,1,mail\ngx_mail_imap_handler.c,ngx_mail_imap_auth_state,,false,101,297,ngx_mail_imap_auth_state,,,17,void ngx_mail_imap_auth_state (ngx_event_t*)
384001,METHOD,mail\ngx_mail_imap_handler.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_mail_imap_login(ngx_mail_session_t *s, ngx_connection_t *c)
{
    ngx_str_t  *arg;

#if (NGX_MAIL_SSL)
    if (ngx_mail_starttls_only(s, c)) {
        return NGX_MAIL_PARSE_INVALID_COMMAND;
    }
#endif

    arg = s->args.elts;

    if (s->args.nelts != 2 || arg[0].len == 0) {
        return NGX_MAIL_PARSE_INVALID_COMMAND;
    }

    s->login.len = arg[0].len;
    s->login.data = ngx_pnalloc(c->pool, s->login.len);
    if (s->login.data == NULL) {
        return NGX_ERROR;
    }

    ngx_memcpy(s->login.data, arg[0].data, s->login.len);

    s->passwd.len = arg[1].len;
    s->passwd.data = ngx_pnalloc(c->pool, s->passwd.len);
    if (s->passwd.data == NULL) {
        return NGX_ERROR;
    }

    ngx_memcpy(s->passwd.data, arg[1].data, s->passwd.len);

#if (NGX_DEBUG_MAIL_PASSWD)
    ngx_log_debug2(NGX_LOG_DEBUG_MAIL, c->log, 0,
                   ""imap login:\""%V\"" passwd:\""%V\"""",
                   &s->login, &s->passwd);
#else
    ngx_log_debug1(NGX_LOG_DEBUG_...",1,1,mail\ngx_mail_imap_handler.c,ngx_mail_imap_login,,false,300,343,ngx_mail_imap_login,,,18,"ngx_int_t ngx_mail_imap_login (ngx_mail_session_t*,ngx_connection_t*)"
384153,METHOD,mail\ngx_mail_imap_handler.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_mail_imap_authenticate(ngx_mail_session_t *s, ngx_connection_t *c)
{
    ngx_int_t                  rc;
    ngx_mail_core_srv_conf_t  *cscf;
    ngx_mail_imap_srv_conf_t  *iscf;

#if (NGX_MAIL_SSL)
    if (ngx_mail_starttls_only(s, c)) {
        return NGX_MAIL_PARSE_INVALID_COMMAND;
    }
#endif

    iscf = ngx_mail_get_module_srv_conf(s, ngx_mail_imap_module);

    rc = ngx_mail_auth_parse(s, c);

    switch (rc) {

    case NGX_MAIL_AUTH_LOGIN:

        ngx_str_set(&s->out, imap_username);
        s->mail_state = ngx_imap_auth_login_username;

        return NGX_OK;

    case NGX_MAIL_AUTH_LOGIN_USERNAME:

        ngx_str_set(&s->out, imap_password);
        s->mail_state = ngx_imap_auth_login_password;

        return ngx_mail_auth_login_username(s, c, 1);

    case NGX_MAIL_AUTH_PLAIN:

        ngx_str_set(&s->out, imap_plain_next);
        s->mail_state = ngx_imap_auth_plain;

        return NGX_OK;

    case NGX_MAIL_AUTH_CRAM_MD5:

        if (!(iscf->au...",1,1,mail\ngx_mail_imap_handler.c,ngx_mail_imap_authenticate,,false,346,420,ngx_mail_imap_authenticate,,,19,"ngx_int_t ngx_mail_imap_authenticate (ngx_mail_session_t*,ngx_connection_t*)"
384304,METHOD,mail\ngx_mail_imap_handler.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_mail_imap_capability(ngx_mail_session_t *s, ngx_connection_t *c)
{
    ngx_mail_imap_srv_conf_t  *iscf;

    iscf = ngx_mail_get_module_srv_conf(s, ngx_mail_imap_module);

#if (NGX_MAIL_SSL)

    if (c->ssl == NULL) {
        ngx_mail_ssl_conf_t  *sslcf;

        sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);

        if (sslcf->starttls == NGX_MAIL_STARTTLS_ON) {
            s->text = iscf->starttls_capability;
            return NGX_OK;
        }

        if (sslcf->starttls == NGX_MAIL_STARTTLS_ONLY) {
            s->text = iscf->starttls_only_capability;
            return NGX_OK;
        }
    }
#endif

    s->text = iscf->capability;

    return NGX_OK;
}",1,1,mail\ngx_mail_imap_handler.c,ngx_mail_imap_capability,,false,423,452,ngx_mail_imap_capability,,,20,"ngx_int_t ngx_mail_imap_capability (ngx_mail_session_t*,ngx_connection_t*)"
384325,METHOD,mail\ngx_mail_imap_handler.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_mail_imap_starttls(ngx_mail_session_t *s, ngx_connection_t *c)
{
#if (NGX_MAIL_SSL)
    ngx_mail_ssl_conf_t  *sslcf;

    if (c->ssl == NULL) {
        sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);
        if (sslcf->starttls) {
            c->read->handler = ngx_mail_starttls_handler;
            return NGX_OK;
        }
    }

#endif

    return NGX_MAIL_PARSE_INVALID_COMMAND;
}",1,1,mail\ngx_mail_imap_handler.c,ngx_mail_imap_starttls,,false,455,472,ngx_mail_imap_starttls,,,21,"ngx_int_t ngx_mail_imap_starttls (ngx_mail_session_t*,ngx_connection_t*)"
384346,METHOD,mail\ngx_mail_imap_module.c:<global>,TYPE_DECL,<global>,1,1,mail\ngx_mail_imap_module.c,mail\ngx_mail_imap_module.c:<global>,,false,1,257,<global>,,,1,
384348,METHOD,mail\ngx_mail_imap_module.c:<global>,TYPE_DECL,static void *ngx_mail_imap_create_srv_conf(ngx_conf_t *cf);,13,58,mail\ngx_mail_imap_module.c,ngx_mail_imap_create_srv_conf,,false,15,15,ngx_mail_imap_create_srv_conf,,,1,void* ngx_mail_imap_create_srv_conf (ngx_conf_t*)
384353,METHOD,mail\ngx_mail_imap_module.c:<global>,TYPE_DECL,"static char *ngx_mail_imap_merge_srv_conf(ngx_conf_t *cf, void *parent,
    void *child);",13,16,mail\ngx_mail_imap_module.c,ngx_mail_imap_merge_srv_conf,,false,16,17,ngx_mail_imap_merge_srv_conf,,,2,"char* ngx_mail_imap_merge_srv_conf (ngx_conf_t*,void*,void*)"
384485,METHOD,mail\ngx_mail_imap_module.c:<global>,TYPE_DECL,"static void *
ngx_mail_imap_create_srv_conf(ngx_conf_t *cf)
{
    ngx_mail_imap_srv_conf_t  *iscf;

    iscf = ngx_pcalloc(cf->pool, sizeof(ngx_mail_imap_srv_conf_t));
    if (iscf == NULL) {
        return NULL;
    }

    iscf->client_buffer_size = NGX_CONF_UNSET_SIZE;

    if (ngx_array_init(&iscf->capabilities, cf->pool, 4, sizeof(ngx_str_t))
        != NGX_OK)
    {
        return NULL;
    }

    return iscf;
}",1,1,mail\ngx_mail_imap_module.c,ngx_mail_imap_create_srv_conf,,false,117,136,ngx_mail_imap_create_srv_conf,,,17,void* ngx_mail_imap_create_srv_conf (ngx_conf_t*)
384530,METHOD,mail\ngx_mail_imap_module.c:<global>,TYPE_DECL,"static char *
ngx_mail_imap_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_mail_imap_srv_conf_t *prev = parent;
    ngx_mail_imap_srv_conf_t *conf = child;

    u_char      *p, *auth;
    size_t       size;
    ngx_str_t   *c, *d;
    ngx_uint_t   i, m;

    ngx_conf_merge_size_value(conf->client_buffer_size,
                              prev->client_buffer_size,
                              (size_t) ngx_pagesize);

    ngx_conf_merge_bitmask_value(conf->auth_methods,
                              prev->auth_methods,
                              (NGX_CONF_BITMASK_SET
                               |NGX_MAIL_AUTH_PLAIN_ENABLED));


    if (conf->capabilities.nelts == 0) {
        conf->capabilities = prev->capabilities;
    }

    if (conf->capabilities.nelts == 0) {

        for (d = ngx_mail_imap_default_capabilities; d->len; d++) {
            c = ngx_array_push(&conf->capabilities);
            if (c == NULL) {
                return NGX_CONF_ERROR;
      ...",1,1,mail\ngx_mail_imap_module.c,ngx_mail_imap_merge_srv_conf,,false,139,257,ngx_mail_imap_merge_srv_conf,,,18,"char* ngx_mail_imap_merge_srv_conf (ngx_conf_t*,void*,void*)"
384985,METHOD,mail\ngx_mail_imap_module.h:<global>,TYPE_DECL,<global>,1,46,mail\ngx_mail_imap_module.h,mail\ngx_mail_imap_module.h:<global>,,false,1,39,<global>,,,1,
384995,METHOD,mail\ngx_mail_imap_module.h:<global>,TYPE_DECL,"void ngx_mail_imap_init_session(ngx_mail_session_t *s, ngx_connection_t *c);",6,75,mail\ngx_mail_imap_module.h,ngx_mail_imap_init_session,,false,30,30,ngx_mail_imap_init_session,,,3,"void ngx_mail_imap_init_session (ngx_mail_session_t*,ngx_connection_t*)"
385001,METHOD,mail\ngx_mail_imap_module.h:<global>,TYPE_DECL,void ngx_mail_imap_init_protocol(ngx_event_t *rev);,6,50,mail\ngx_mail_imap_module.h,ngx_mail_imap_init_protocol,,false,31,31,ngx_mail_imap_init_protocol,,,4,void ngx_mail_imap_init_protocol (ngx_event_t*)
385006,METHOD,mail\ngx_mail_imap_module.h:<global>,TYPE_DECL,void ngx_mail_imap_auth_state(ngx_event_t *rev);,6,47,mail\ngx_mail_imap_module.h,ngx_mail_imap_auth_state,,false,32,32,ngx_mail_imap_auth_state,,,5,void ngx_mail_imap_auth_state (ngx_event_t*)
385011,METHOD,mail\ngx_mail_imap_module.h:<global>,TYPE_DECL,ngx_int_t ngx_mail_imap_parse_command(ngx_mail_session_t *s);,11,60,mail\ngx_mail_imap_module.h,ngx_mail_imap_parse_command,,false,33,33,ngx_mail_imap_parse_command,,,6,ngx_int_t ngx_mail_imap_parse_command (ngx_mail_session_t*)
385034,METHOD,mail\ngx_mail_parse.c:<global>,TYPE_DECL,<global>,1,1,mail\ngx_mail_parse.c,mail\ngx_mail_parse.c:<global>,,false,1,932,<global>,,,1,
385036,METHOD,mail\ngx_mail_parse.c:<global>,TYPE_DECL,"ngx_int_t
ngx_mail_pop3_parse_command(ngx_mail_session_t *s)
{
    u_char      ch, *p, *c, c0, c1, c2, c3;
    ngx_str_t  *arg;
    enum {
        sw_start = 0,
        sw_spaces_before_argument,
        sw_argument,
        sw_almost_done
    } state;

    state = s->state;

    for (p = s->buffer->pos; p < s->buffer->last; p++) {
        ch = *p;

        switch (state) {

        /* POP3 command */
        case sw_start:
            if (ch == ' ' || ch == CR || ch == LF) {
                c = s->buffer->start;

                if (p - c == 4) {

                    c0 = ngx_toupper(c[0]);
                    c1 = ngx_toupper(c[1]);
                    c2 = ngx_toupper(c[2]);
                    c3 = ngx_toupper(c[3]);

                    if (c0 == 'U' && c1 == 'S' && c2 == 'E' && c3 == 'R')
                    {
                        s->command = NGX_POP3_USER;

                    } else if (c0 == 'P' && c1 == 'A' && c2 == 'S' && c3 == 'S')
                    {
             ...",1,1,mail\ngx_mail_parse.c,ngx_mail_pop3_parse_command,,false,17,212,ngx_mail_pop3_parse_command,,,1,ngx_int_t ngx_mail_pop3_parse_command (ngx_mail_session_t*)
385577,METHOD,mail\ngx_mail_parse.c:<global>,TYPE_DECL,"ngx_int_t
ngx_mail_imap_parse_command(ngx_mail_session_t *s)
{
    u_char      ch, *p, *c;
    ngx_str_t  *arg;
    enum {
        sw_start = 0,
        sw_spaces_before_command,
        sw_command,
        sw_spaces_before_argument,
        sw_argument,
        sw_backslash,
        sw_literal,
        sw_no_sync_literal_argument,
        sw_start_literal_argument,
        sw_literal_argument,
        sw_end_literal_argument,
        sw_almost_done
    } state;

    state = s->state;

    for (p = s->buffer->pos; p < s->buffer->last; p++) {
        ch = *p;

        switch (state) {

        /* IMAP tag */
        case sw_start:
            switch (ch) {
            case ' ':
                s->tag.len = p - s->buffer->start + 1;
                s->tag.data = s->buffer->start;
                state = sw_spaces_before_command;
                break;
            case CR:
                s->state = sw_start;
                return NGX_MAIL_PARSE_INVALID_COMMAND;
            case LF:
 ...",1,1,mail\ngx_mail_parse.c,ngx_mail_imap_parse_command,,false,215,619,ngx_mail_imap_parse_command,,,2,ngx_int_t ngx_mail_imap_parse_command (ngx_mail_session_t*)
386831,METHOD,mail\ngx_mail_parse.c:<global>,TYPE_DECL,"ngx_int_t
ngx_mail_smtp_parse_command(ngx_mail_session_t *s)
{
    u_char      ch, *p, *c, c0, c1, c2, c3;
    ngx_str_t  *arg;
    enum {
        sw_start = 0,
        sw_command,
        sw_invalid,
        sw_spaces_before_argument,
        sw_argument,
        sw_almost_done
    } state;

    state = s->state;

    for (p = s->buffer->pos; p < s->buffer->last; p++) {
        ch = *p;

        switch (state) {

        /* SMTP command */
        case sw_start:
            s->cmd_start = p;
            state = sw_command;

            /* fall through */

        case sw_command:
            if (ch == ' ' || ch == CR || ch == LF) {
                c = s->cmd_start;

                if (p - c == 4) {

                    c0 = ngx_toupper(c[0]);
                    c1 = ngx_toupper(c[1]);
                    c2 = ngx_toupper(c[2]);
                    c3 = ngx_toupper(c[3]);

                    if (c0 == 'H' && c1 == 'E' && c2 == 'L' && c3 == 'O')
                    {
             ...",1,1,mail\ngx_mail_parse.c,ngx_mail_smtp_parse_command,,false,622,857,ngx_mail_smtp_parse_command,,,3,ngx_int_t ngx_mail_smtp_parse_command (ngx_mail_session_t*)
387525,METHOD,mail\ngx_mail_parse.c:<global>,TYPE_DECL,"ngx_int_t
ngx_mail_auth_parse(ngx_mail_session_t *s, ngx_connection_t *c)
{
    ngx_str_t                 *arg;

#if (NGX_MAIL_SSL)
    if (ngx_mail_starttls_only(s, c)) {
        return NGX_MAIL_PARSE_INVALID_COMMAND;
    }
#endif

    if (s->args.nelts == 0) {
        return NGX_MAIL_PARSE_INVALID_COMMAND;
    }

    arg = s->args.elts;

    if (arg[0].len == 5) {

        if (ngx_strncasecmp(arg[0].data, (u_char *) ""LOGIN"", 5) == 0) {

            if (s->args.nelts == 1) {
                return NGX_MAIL_AUTH_LOGIN;
            }

            if (s->args.nelts == 2) {
                return NGX_MAIL_AUTH_LOGIN_USERNAME;
            }

            return NGX_MAIL_PARSE_INVALID_COMMAND;
        }

        if (ngx_strncasecmp(arg[0].data, (u_char *) ""PLAIN"", 5) == 0) {

            if (s->args.nelts == 1) {
                return NGX_MAIL_AUTH_PLAIN;
            }

            if (s->args.nelts == 2) {
                return ngx_mail_auth_plain(s, c, 1);
            }
        }

   ...",1,1,mail\ngx_mail_parse.c,ngx_mail_auth_parse,,false,860,932,ngx_mail_auth_parse,,,4,"ngx_int_t ngx_mail_auth_parse (ngx_mail_session_t*,ngx_connection_t*)"
387730,METHOD,mail\ngx_mail_pop3_handler.c:<global>,TYPE_DECL,<global>,1,1,mail\ngx_mail_pop3_handler.c,mail\ngx_mail_pop3_handler.c:<global>,,false,1,515,<global>,,,1,
387732,METHOD,mail\ngx_mail_pop3_handler.c:<global>,TYPE_DECL,"static ngx_int_t ngx_mail_pop3_user(ngx_mail_session_t *s, ngx_connection_t *c);",18,79,mail\ngx_mail_pop3_handler.c,ngx_mail_pop3_user,,false,15,15,ngx_mail_pop3_user,,,1,"ngx_int_t ngx_mail_pop3_user (ngx_mail_session_t*,ngx_connection_t*)"
387738,METHOD,mail\ngx_mail_pop3_handler.c:<global>,TYPE_DECL,"static ngx_int_t ngx_mail_pop3_pass(ngx_mail_session_t *s, ngx_connection_t *c);",18,79,mail\ngx_mail_pop3_handler.c,ngx_mail_pop3_pass,,false,16,16,ngx_mail_pop3_pass,,,2,"ngx_int_t ngx_mail_pop3_pass (ngx_mail_session_t*,ngx_connection_t*)"
387744,METHOD,mail\ngx_mail_pop3_handler.c:<global>,TYPE_DECL,"static ngx_int_t ngx_mail_pop3_capa(ngx_mail_session_t *s, ngx_connection_t *c,
    ngx_int_t stls);",18,19,mail\ngx_mail_pop3_handler.c,ngx_mail_pop3_capa,,false,17,18,ngx_mail_pop3_capa,,,3,"ngx_int_t ngx_mail_pop3_capa (ngx_mail_session_t*,ngx_connection_t*,ngx_int_t)"
387751,METHOD,mail\ngx_mail_pop3_handler.c:<global>,TYPE_DECL,"static ngx_int_t ngx_mail_pop3_stls(ngx_mail_session_t *s, ngx_connection_t *c);",18,79,mail\ngx_mail_pop3_handler.c,ngx_mail_pop3_stls,,false,19,19,ngx_mail_pop3_stls,,,4,"ngx_int_t ngx_mail_pop3_stls (ngx_mail_session_t*,ngx_connection_t*)"
387757,METHOD,mail\ngx_mail_pop3_handler.c:<global>,TYPE_DECL,"static ngx_int_t ngx_mail_pop3_apop(ngx_mail_session_t *s, ngx_connection_t *c);",18,79,mail\ngx_mail_pop3_handler.c,ngx_mail_pop3_apop,,false,20,20,ngx_mail_pop3_apop,,,5,"ngx_int_t ngx_mail_pop3_apop (ngx_mail_session_t*,ngx_connection_t*)"
387763,METHOD,mail\ngx_mail_pop3_handler.c:<global>,TYPE_DECL,"static ngx_int_t ngx_mail_pop3_auth(ngx_mail_session_t *s, ngx_connection_t *c);",18,79,mail\ngx_mail_pop3_handler.c,ngx_mail_pop3_auth,,false,21,21,ngx_mail_pop3_auth,,,6,"ngx_int_t ngx_mail_pop3_auth (ngx_mail_session_t*,ngx_connection_t*)"
387775,METHOD,mail\ngx_mail_pop3_handler.c:<global>,TYPE_DECL,"void
ngx_mail_pop3_init_session(ngx_mail_session_t *s, ngx_connection_t *c)
{
    u_char                    *p;
    ngx_mail_core_srv_conf_t  *cscf;
    ngx_mail_pop3_srv_conf_t  *pscf;

    pscf = ngx_mail_get_module_srv_conf(s, ngx_mail_pop3_module);
    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);

    if (pscf->auth_methods
        & (NGX_MAIL_AUTH_APOP_ENABLED|NGX_MAIL_AUTH_CRAM_MD5_ENABLED))
    {
        if (ngx_mail_salt(s, c, cscf) != NGX_OK) {
            ngx_mail_session_internal_server_error(s);
            return;
        }

        s->out.data = ngx_pnalloc(c->pool, sizeof(pop3_greeting) + s->salt.len);
        if (s->out.data == NULL) {
            ngx_mail_session_internal_server_error(s);
            return;
        }

        p = ngx_cpymem(s->out.data, pop3_greeting, sizeof(pop3_greeting) - 3);
        *p++ = ' ';
        p = ngx_cpymem(p, s->salt.data, s->salt.len);

        s->out.len = p - s->out.data;

    } else {
        ngx_str_set(&s->out,...",1,1,mail\ngx_mail_pop3_handler.c,ngx_mail_pop3_init_session,,false,32,75,ngx_mail_pop3_init_session,,,13,"void ngx_mail_pop3_init_session (ngx_mail_session_t*,ngx_connection_t*)"
387926,METHOD,mail\ngx_mail_pop3_handler.c:<global>,TYPE_DECL,"void
ngx_mail_pop3_init_protocol(ngx_event_t *rev)
{
    ngx_connection_t    *c;
    ngx_mail_session_t  *s;

    c = rev->data;

    c->log->action = ""in auth state"";

    if (rev->timedout) {
        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, ""client timed out"");
        c->timedout = 1;
        ngx_mail_close_connection(c);
        return;
    }

    s = c->data;

    if (s->buffer == NULL) {
        if (ngx_array_init(&s->args, c->pool, 2, sizeof(ngx_str_t))
            == NGX_ERROR)
        {
            ngx_mail_session_internal_server_error(s);
            return;
        }

        s->buffer = ngx_create_temp_buf(c->pool, 128);
        if (s->buffer == NULL) {
            ngx_mail_session_internal_server_error(s);
            return;
        }
    }

    s->mail_state = ngx_pop3_start;
    c->read->handler = ngx_mail_pop3_auth_state;

    ngx_mail_pop3_auth_state(rev);
}",1,1,mail\ngx_mail_pop3_handler.c,ngx_mail_pop3_init_protocol,,false,78,116,ngx_mail_pop3_init_protocol,,,14,void ngx_mail_pop3_init_protocol (ngx_event_t*)
388028,METHOD,mail\ngx_mail_pop3_handler.c:<global>,TYPE_DECL,"void
ngx_mail_pop3_auth_state(ngx_event_t *rev)
{
    ngx_int_t            rc;
    ngx_connection_t    *c;
    ngx_mail_session_t  *s;

    c = rev->data;
    s = c->data;

    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0, ""pop3 auth state"");

    if (rev->timedout) {
        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, ""client timed out"");
        c->timedout = 1;
        ngx_mail_close_connection(c);
        return;
    }

    if (s->out.len) {
        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0, ""pop3 send handler busy"");
        s->blocked = 1;
        return;
    }

    s->blocked = 0;

    rc = ngx_mail_read_command(s, c);

    if (rc == NGX_AGAIN || rc == NGX_ERROR) {
        return;
    }

    ngx_str_set(&s->out, pop3_ok);

    if (rc == NGX_OK) {
        switch (s->mail_state) {

        case ngx_pop3_start:

            switch (s->command) {

            case NGX_POP3_USER:
                rc = ngx_mail_pop3_user(s, c);
                break;

            case NGX_...",1,1,mail\ngx_mail_pop3_handler.c,ngx_mail_pop3_auth_state,,false,119,280,ngx_mail_pop3_auth_state,,,15,void ngx_mail_pop3_auth_state (ngx_event_t*)
388373,METHOD,mail\ngx_mail_pop3_handler.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_mail_pop3_user(ngx_mail_session_t *s, ngx_connection_t *c)
{
    ngx_str_t  *arg;

#if (NGX_MAIL_SSL)
    if (ngx_mail_starttls_only(s, c)) {
        return NGX_MAIL_PARSE_INVALID_COMMAND;
    }
#endif

    if (s->args.nelts != 1) {
        return NGX_MAIL_PARSE_INVALID_COMMAND;
    }

    arg = s->args.elts;
    s->login.len = arg[0].len;
    s->login.data = ngx_pnalloc(c->pool, s->login.len);
    if (s->login.data == NULL) {
        return NGX_ERROR;
    }

    ngx_memcpy(s->login.data, arg[0].data, s->login.len);

    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
                   ""pop3 login: \""%V\"""", &s->login);

    s->mail_state = ngx_pop3_user;

    return NGX_OK;
}",1,1,mail\ngx_mail_pop3_handler.c,ngx_mail_pop3_user,,false,282,312,ngx_mail_pop3_user,,,16,"ngx_int_t ngx_mail_pop3_user (ngx_mail_session_t*,ngx_connection_t*)"
388469,METHOD,mail\ngx_mail_pop3_handler.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_mail_pop3_pass(ngx_mail_session_t *s, ngx_connection_t *c)
{
    ngx_str_t  *arg;

    if (s->args.nelts != 1) {
        return NGX_MAIL_PARSE_INVALID_COMMAND;
    }

    arg = s->args.elts;
    s->passwd.len = arg[0].len;
    s->passwd.data = ngx_pnalloc(c->pool, s->passwd.len);
    if (s->passwd.data == NULL) {
        return NGX_ERROR;
    }

    ngx_memcpy(s->passwd.data, arg[0].data, s->passwd.len);

#if (NGX_DEBUG_MAIL_PASSWD)
    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
                   ""pop3 passwd: \""%V\"""", &s->passwd);
#endif

    return NGX_DONE;
}",1,1,mail\ngx_mail_pop3_handler.c,ngx_mail_pop3_pass,,false,315,339,ngx_mail_pop3_pass,,,17,"ngx_int_t ngx_mail_pop3_pass (ngx_mail_session_t*,ngx_connection_t*)"
388549,METHOD,mail\ngx_mail_pop3_handler.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_mail_pop3_capa(ngx_mail_session_t *s, ngx_connection_t *c, ngx_int_t stls)
{
    ngx_mail_pop3_srv_conf_t  *pscf;

    pscf = ngx_mail_get_module_srv_conf(s, ngx_mail_pop3_module);

#if (NGX_MAIL_SSL)

    if (stls && c->ssl == NULL) {
        ngx_mail_ssl_conf_t  *sslcf;

        sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);

        if (sslcf->starttls == NGX_MAIL_STARTTLS_ON) {
            s->out = pscf->starttls_capability;
            return NGX_OK;
        }

        if (sslcf->starttls == NGX_MAIL_STARTTLS_ONLY) {
            s->out = pscf->starttls_only_capability;
            return NGX_OK;
        }
    }

#endif

    s->out = pscf->capability;
    return NGX_OK;
}",1,1,mail\ngx_mail_pop3_handler.c,ngx_mail_pop3_capa,,false,342,371,ngx_mail_pop3_capa,,,18,"ngx_int_t ngx_mail_pop3_capa (ngx_mail_session_t*,ngx_connection_t*,ngx_int_t)"
388571,METHOD,mail\ngx_mail_pop3_handler.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_mail_pop3_stls(ngx_mail_session_t *s, ngx_connection_t *c)
{
#if (NGX_MAIL_SSL)
    ngx_mail_ssl_conf_t  *sslcf;

    if (c->ssl == NULL) {
        sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);
        if (sslcf->starttls) {
            c->read->handler = ngx_mail_starttls_handler;
            return NGX_OK;
        }
    }

#endif

    return NGX_MAIL_PARSE_INVALID_COMMAND;
}",1,1,mail\ngx_mail_pop3_handler.c,ngx_mail_pop3_stls,,false,374,391,ngx_mail_pop3_stls,,,19,"ngx_int_t ngx_mail_pop3_stls (ngx_mail_session_t*,ngx_connection_t*)"
388579,METHOD,mail\ngx_mail_pop3_handler.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_mail_pop3_apop(ngx_mail_session_t *s, ngx_connection_t *c)
{
    ngx_str_t                 *arg;
    ngx_mail_pop3_srv_conf_t  *pscf;

#if (NGX_MAIL_SSL)
    if (ngx_mail_starttls_only(s, c)) {
        return NGX_MAIL_PARSE_INVALID_COMMAND;
    }
#endif

    if (s->args.nelts != 2) {
        return NGX_MAIL_PARSE_INVALID_COMMAND;
    }

    pscf = ngx_mail_get_module_srv_conf(s, ngx_mail_pop3_module);

    if (!(pscf->auth_methods & NGX_MAIL_AUTH_APOP_ENABLED)) {
        return NGX_MAIL_PARSE_INVALID_COMMAND;
    }

    arg = s->args.elts;

    s->login.len = arg[0].len;
    s->login.data = ngx_pnalloc(c->pool, s->login.len);
    if (s->login.data == NULL) {
        return NGX_ERROR;
    }

    ngx_memcpy(s->login.data, arg[0].data, s->login.len);

    s->passwd.len = arg[1].len;
    s->passwd.data = ngx_pnalloc(c->pool, s->passwd.len);
    if (s->passwd.data == NULL) {
        return NGX_ERROR;
    }

    ngx_memcpy(s->passwd.data, arg[1].data, s->passwd.len);
...",1,1,mail\ngx_mail_pop3_handler.c,ngx_mail_pop3_apop,,false,394,440,ngx_mail_pop3_apop,,,20,"ngx_int_t ngx_mail_pop3_apop (ngx_mail_session_t*,ngx_connection_t*)"
388748,METHOD,mail\ngx_mail_pop3_handler.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_mail_pop3_auth(ngx_mail_session_t *s, ngx_connection_t *c)
{
    ngx_int_t                  rc;
    ngx_mail_pop3_srv_conf_t  *pscf;

#if (NGX_MAIL_SSL)
    if (ngx_mail_starttls_only(s, c)) {
        return NGX_MAIL_PARSE_INVALID_COMMAND;
    }
#endif

    pscf = ngx_mail_get_module_srv_conf(s, ngx_mail_pop3_module);

    if (s->args.nelts == 0) {
        s->out = pscf->auth_capability;
        s->state = 0;

        return NGX_OK;
    }

    rc = ngx_mail_auth_parse(s, c);

    switch (rc) {

    case NGX_MAIL_AUTH_LOGIN:

        ngx_str_set(&s->out, pop3_username);
        s->mail_state = ngx_pop3_auth_login_username;

        return NGX_OK;

    case NGX_MAIL_AUTH_LOGIN_USERNAME:

        ngx_str_set(&s->out, pop3_password);
        s->mail_state = ngx_pop3_auth_login_password;

        return ngx_mail_auth_login_username(s, c, 1);

    case NGX_MAIL_AUTH_PLAIN:

        ngx_str_set(&s->out, pop3_next);
        s->mail_state = ngx_pop3_auth_plain;

        ...",1,1,mail\ngx_mail_pop3_handler.c,ngx_mail_pop3_auth,,false,443,515,ngx_mail_pop3_auth,,,21,"ngx_int_t ngx_mail_pop3_auth (ngx_mail_session_t*,ngx_connection_t*)"
388910,METHOD,mail\ngx_mail_pop3_module.c:<global>,TYPE_DECL,<global>,1,1,mail\ngx_mail_pop3_module.c,mail\ngx_mail_pop3_module.c:<global>,,false,1,322,<global>,,,1,
388912,METHOD,mail\ngx_mail_pop3_module.c:<global>,TYPE_DECL,static void *ngx_mail_pop3_create_srv_conf(ngx_conf_t *cf);,13,58,mail\ngx_mail_pop3_module.c,ngx_mail_pop3_create_srv_conf,,false,15,15,ngx_mail_pop3_create_srv_conf,,,1,void* ngx_mail_pop3_create_srv_conf (ngx_conf_t*)
388917,METHOD,mail\ngx_mail_pop3_module.c:<global>,TYPE_DECL,"static char *ngx_mail_pop3_merge_srv_conf(ngx_conf_t *cf, void *parent,
    void *child);",13,16,mail\ngx_mail_pop3_module.c,ngx_mail_pop3_merge_srv_conf,,false,16,17,ngx_mail_pop3_merge_srv_conf,,,2,"char* ngx_mail_pop3_merge_srv_conf (ngx_conf_t*,void*,void*)"
389035,METHOD,mail\ngx_mail_pop3_module.c:<global>,TYPE_DECL,"static void *
ngx_mail_pop3_create_srv_conf(ngx_conf_t *cf)
{
    ngx_mail_pop3_srv_conf_t  *pscf;

    pscf = ngx_pcalloc(cf->pool, sizeof(ngx_mail_pop3_srv_conf_t));
    if (pscf == NULL) {
        return NULL;
    }

    if (ngx_array_init(&pscf->capabilities, cf->pool, 4, sizeof(ngx_str_t))
        != NGX_OK)
    {
        return NULL;
    }

    return pscf;
}",1,1,mail\ngx_mail_pop3_module.c,ngx_mail_pop3_create_srv_conf,,false,110,127,ngx_mail_pop3_create_srv_conf,,,17,void* ngx_mail_pop3_create_srv_conf (ngx_conf_t*)
389075,METHOD,mail\ngx_mail_pop3_module.c:<global>,TYPE_DECL,"static char *
ngx_mail_pop3_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_mail_pop3_srv_conf_t *prev = parent;
    ngx_mail_pop3_srv_conf_t *conf = child;

    u_char      *p;
    size_t       size, stls_only_size;
    ngx_str_t   *c, *d;
    ngx_uint_t   i, m;

    ngx_conf_merge_bitmask_value(conf->auth_methods,
                                 prev->auth_methods,
                                 (NGX_CONF_BITMASK_SET
                                  |NGX_MAIL_AUTH_PLAIN_ENABLED));

    if (conf->auth_methods & NGX_MAIL_AUTH_PLAIN_ENABLED) {
        conf->auth_methods |= NGX_MAIL_AUTH_LOGIN_ENABLED;
    }

    if (conf->capabilities.nelts == 0) {
        conf->capabilities = prev->capabilities;
    }

    if (conf->capabilities.nelts == 0) {

        for (d = ngx_mail_pop3_default_capabilities; d->len; d++) {
            c = ngx_array_push(&conf->capabilities);
            if (c == NULL) {
                return NGX_CONF_ERROR;
            }

            *c ...",1,1,mail\ngx_mail_pop3_module.c,ngx_mail_pop3_merge_srv_conf,,false,130,322,ngx_mail_pop3_merge_srv_conf,,,18,"char* ngx_mail_pop3_merge_srv_conf (ngx_conf_t*,void*,void*)"
389753,METHOD,mail\ngx_mail_pop3_module.h:<global>,TYPE_DECL,<global>,1,46,mail\ngx_mail_pop3_module.h,mail\ngx_mail_pop3_module.h:<global>,,false,1,38,<global>,,,1,
389763,METHOD,mail\ngx_mail_pop3_module.h:<global>,TYPE_DECL,"void ngx_mail_pop3_init_session(ngx_mail_session_t *s, ngx_connection_t *c);",6,75,mail\ngx_mail_pop3_module.h,ngx_mail_pop3_init_session,,false,29,29,ngx_mail_pop3_init_session,,,3,"void ngx_mail_pop3_init_session (ngx_mail_session_t*,ngx_connection_t*)"
389769,METHOD,mail\ngx_mail_pop3_module.h:<global>,TYPE_DECL,void ngx_mail_pop3_init_protocol(ngx_event_t *rev);,6,50,mail\ngx_mail_pop3_module.h,ngx_mail_pop3_init_protocol,,false,30,30,ngx_mail_pop3_init_protocol,,,4,void ngx_mail_pop3_init_protocol (ngx_event_t*)
389774,METHOD,mail\ngx_mail_pop3_module.h:<global>,TYPE_DECL,void ngx_mail_pop3_auth_state(ngx_event_t *rev);,6,47,mail\ngx_mail_pop3_module.h,ngx_mail_pop3_auth_state,,false,31,31,ngx_mail_pop3_auth_state,,,5,void ngx_mail_pop3_auth_state (ngx_event_t*)
389779,METHOD,mail\ngx_mail_pop3_module.h:<global>,TYPE_DECL,ngx_int_t ngx_mail_pop3_parse_command(ngx_mail_session_t *s);,11,60,mail\ngx_mail_pop3_module.h,ngx_mail_pop3_parse_command,,false,32,32,ngx_mail_pop3_parse_command,,,6,ngx_int_t ngx_mail_pop3_parse_command (ngx_mail_session_t*)
389798,METHOD,mail\ngx_mail_proxy_module.c:<global>,TYPE_DECL,<global>,1,1,mail\ngx_mail_proxy_module.c,mail\ngx_mail_proxy_module.c:<global>,,false,1,1126,<global>,,,1,
389807,METHOD,mail\ngx_mail_proxy_module.c:<global>,TYPE_DECL,static void ngx_mail_proxy_block_read(ngx_event_t *rev);,13,55,mail\ngx_mail_proxy_module.c,ngx_mail_proxy_block_read,,false,24,24,ngx_mail_proxy_block_read,,,3,void ngx_mail_proxy_block_read (ngx_event_t*)
389812,METHOD,mail\ngx_mail_proxy_module.c:<global>,TYPE_DECL,static void ngx_mail_proxy_pop3_handler(ngx_event_t *rev);,13,57,mail\ngx_mail_proxy_module.c,ngx_mail_proxy_pop3_handler,,false,25,25,ngx_mail_proxy_pop3_handler,,,4,void ngx_mail_proxy_pop3_handler (ngx_event_t*)
389817,METHOD,mail\ngx_mail_proxy_module.c:<global>,TYPE_DECL,static void ngx_mail_proxy_imap_handler(ngx_event_t *rev);,13,57,mail\ngx_mail_proxy_module.c,ngx_mail_proxy_imap_handler,,false,26,26,ngx_mail_proxy_imap_handler,,,5,void ngx_mail_proxy_imap_handler (ngx_event_t*)
389822,METHOD,mail\ngx_mail_proxy_module.c:<global>,TYPE_DECL,static void ngx_mail_proxy_smtp_handler(ngx_event_t *rev);,13,57,mail\ngx_mail_proxy_module.c,ngx_mail_proxy_smtp_handler,,false,27,27,ngx_mail_proxy_smtp_handler,,,6,void ngx_mail_proxy_smtp_handler (ngx_event_t*)
389827,METHOD,mail\ngx_mail_proxy_module.c:<global>,TYPE_DECL,static void ngx_mail_proxy_dummy_handler(ngx_event_t *ev);,13,57,mail\ngx_mail_proxy_module.c,ngx_mail_proxy_dummy_handler,,false,28,28,ngx_mail_proxy_dummy_handler,,,7,void ngx_mail_proxy_dummy_handler (ngx_event_t*)
389832,METHOD,mail\ngx_mail_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_mail_proxy_read_response(ngx_mail_session_t *s,
    ngx_uint_t state);",18,21,mail\ngx_mail_proxy_module.c,ngx_mail_proxy_read_response,,false,29,30,ngx_mail_proxy_read_response,,,8,"ngx_int_t ngx_mail_proxy_read_response (ngx_mail_session_t*,ngx_uint_t)"
389838,METHOD,mail\ngx_mail_proxy_module.c:<global>,TYPE_DECL,static void ngx_mail_proxy_handler(ngx_event_t *ev);,13,51,mail\ngx_mail_proxy_module.c,ngx_mail_proxy_handler,,false,31,31,ngx_mail_proxy_handler,,,9,void ngx_mail_proxy_handler (ngx_event_t*)
389843,METHOD,mail\ngx_mail_proxy_module.c:<global>,TYPE_DECL,static void ngx_mail_proxy_upstream_error(ngx_mail_session_t *s);,13,64,mail\ngx_mail_proxy_module.c,ngx_mail_proxy_upstream_error,,false,32,32,ngx_mail_proxy_upstream_error,,,10,void ngx_mail_proxy_upstream_error (ngx_mail_session_t*)
389848,METHOD,mail\ngx_mail_proxy_module.c:<global>,TYPE_DECL,static void ngx_mail_proxy_internal_server_error(ngx_mail_session_t *s);,13,71,mail\ngx_mail_proxy_module.c,ngx_mail_proxy_internal_server_error,,false,33,33,ngx_mail_proxy_internal_server_error,,,11,void ngx_mail_proxy_internal_server_error (ngx_mail_session_t*)
389853,METHOD,mail\ngx_mail_proxy_module.c:<global>,TYPE_DECL,static void ngx_mail_proxy_close_session(ngx_mail_session_t *s);,13,63,mail\ngx_mail_proxy_module.c,ngx_mail_proxy_close_session,,false,34,34,ngx_mail_proxy_close_session,,,12,void ngx_mail_proxy_close_session (ngx_mail_session_t*)
389858,METHOD,mail\ngx_mail_proxy_module.c:<global>,TYPE_DECL,static void *ngx_mail_proxy_create_conf(ngx_conf_t *cf);,13,55,mail\ngx_mail_proxy_module.c,ngx_mail_proxy_create_conf,,false,35,35,ngx_mail_proxy_create_conf,,,13,void* ngx_mail_proxy_create_conf (ngx_conf_t*)
389863,METHOD,mail\ngx_mail_proxy_module.c:<global>,TYPE_DECL,"static char *ngx_mail_proxy_merge_conf(ngx_conf_t *cf, void *parent,
    void *child);",13,16,mail\ngx_mail_proxy_module.c,ngx_mail_proxy_merge_conf,,false,36,37,ngx_mail_proxy_merge_conf,,,14,"char* ngx_mail_proxy_merge_conf (ngx_conf_t*,void*,void*)"
389972,METHOD,mail\ngx_mail_proxy_module.c:<global>,TYPE_DECL,"void
ngx_mail_proxy_init(ngx_mail_session_t *s, ngx_addr_t *peer)
{
    ngx_int_t                  rc;
    ngx_mail_proxy_ctx_t      *p;
    ngx_mail_proxy_conf_t     *pcf;
    ngx_mail_core_srv_conf_t  *cscf;

    s->connection->log->action = ""connecting to upstream"";

    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);

    p = ngx_pcalloc(s->connection->pool, sizeof(ngx_mail_proxy_ctx_t));
    if (p == NULL) {
        ngx_mail_session_internal_server_error(s);
        return;
    }

    s->proxy = p;

    p->upstream.sockaddr = peer->sockaddr;
    p->upstream.socklen = peer->socklen;
    p->upstream.name = &peer->name;
    p->upstream.get = ngx_event_get_peer;
    p->upstream.log = s->connection->log;
    p->upstream.log_error = NGX_ERROR_ERR;

    rc = ngx_event_connect_peer(&p->upstream);

    if (rc == NGX_ERROR || rc == NGX_BUSY || rc == NGX_DECLINED) {
        ngx_mail_proxy_internal_server_error(s);
        return;
    }

    ngx_add_timer(p->upstream.connecti...",1,1,mail\ngx_mail_proxy_module.c,ngx_mail_proxy_init,,false,111,181,ngx_mail_proxy_init,,,22,"void ngx_mail_proxy_init (ngx_mail_session_t*,ngx_addr_t*)"
390248,METHOD,mail\ngx_mail_proxy_module.c:<global>,TYPE_DECL,"static void
ngx_mail_proxy_block_read(ngx_event_t *rev)
{
    ngx_connection_t    *c;
    ngx_mail_session_t  *s;

    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0, ""mail proxy block read"");

    if (ngx_handle_read_event(rev, 0) != NGX_OK) {
        c = rev->data;
        s = c->data;

        ngx_mail_proxy_close_session(s);
    }
}",1,1,mail\ngx_mail_proxy_module.c,ngx_mail_proxy_block_read,,false,184,198,ngx_mail_proxy_block_read,,,23,void ngx_mail_proxy_block_read (ngx_event_t*)
390281,METHOD,mail\ngx_mail_proxy_module.c:<global>,TYPE_DECL,"static void
ngx_mail_proxy_pop3_handler(ngx_event_t *rev)
{
    u_char                 *p;
    ngx_int_t               rc;
    ngx_str_t               line;
    ngx_connection_t       *c;
    ngx_mail_session_t     *s;
    ngx_mail_proxy_conf_t  *pcf;

    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,
                   ""mail proxy pop3 auth handler"");

    c = rev->data;
    s = c->data;

    if (rev->timedout) {
        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT,
                      ""upstream timed out"");
        c->timedout = 1;
        ngx_mail_proxy_internal_server_error(s);
        return;
    }

    rc = ngx_mail_proxy_read_response(s, 0);

    if (rc == NGX_AGAIN) {
        return;
    }

    if (rc == NGX_ERROR) {
        ngx_mail_proxy_upstream_error(s);
        return;
    }

    switch (s->mail_state) {

    case ngx_pop3_start:
        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0, ""mail proxy send user"");

        s->connection->log->action = ""sending user ...",1,1,mail\ngx_mail_proxy_module.c,ngx_mail_proxy_pop3_handler,,false,201,311,ngx_mail_proxy_pop3_handler,,,24,void ngx_mail_proxy_pop3_handler (ngx_event_t*)
390668,METHOD,mail\ngx_mail_proxy_module.c:<global>,TYPE_DECL,"static void
ngx_mail_proxy_imap_handler(ngx_event_t *rev)
{
    u_char                 *p;
    ngx_int_t               rc;
    ngx_str_t               line;
    ngx_connection_t       *c;
    ngx_mail_session_t     *s;
    ngx_mail_proxy_conf_t  *pcf;

    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,
                   ""mail proxy imap auth handler"");

    c = rev->data;
    s = c->data;

    if (rev->timedout) {
        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT,
                      ""upstream timed out"");
        c->timedout = 1;
        ngx_mail_proxy_internal_server_error(s);
        return;
    }

    rc = ngx_mail_proxy_read_response(s, s->mail_state);

    if (rc == NGX_AGAIN) {
        return;
    }

    if (rc == NGX_ERROR) {
        ngx_mail_proxy_upstream_error(s);
        return;
    }

    switch (s->mail_state) {

    case ngx_imap_start:
        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,
                       ""mail proxy send login"");

        s->conn...",1,1,mail\ngx_mail_proxy_module.c,ngx_mail_proxy_imap_handler,,false,314,445,ngx_mail_proxy_imap_handler,,,25,void ngx_mail_proxy_imap_handler (ngx_event_t*)
391081,METHOD,mail\ngx_mail_proxy_module.c:<global>,TYPE_DECL,"static void
ngx_mail_proxy_smtp_handler(ngx_event_t *rev)
{
    u_char                    *p;
    ngx_int_t                  rc;
    ngx_str_t                  line;
    ngx_buf_t                 *b;
    ngx_connection_t          *c;
    ngx_mail_session_t        *s;
    ngx_mail_proxy_conf_t     *pcf;
    ngx_mail_core_srv_conf_t  *cscf;

    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,
                   ""mail proxy smtp auth handler"");

    c = rev->data;
    s = c->data;

    if (rev->timedout) {
        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT,
                      ""upstream timed out"");
        c->timedout = 1;
        ngx_mail_proxy_internal_server_error(s);
        return;
    }

    rc = ngx_mail_proxy_read_response(s, s->mail_state);

    if (rc == NGX_AGAIN) {
        return;
    }

    if (rc == NGX_ERROR) {
        ngx_mail_proxy_upstream_error(s);
        return;
    }

    switch (s->mail_state) {

    case ngx_smtp_start:
        ngx_log_debug0(NGX_LOG_D...",1,1,mail\ngx_mail_proxy_module.c,ngx_mail_proxy_smtp_handler,,false,448,697,ngx_mail_proxy_smtp_handler,,,26,void ngx_mail_proxy_smtp_handler (ngx_event_t*)
391888,METHOD,mail\ngx_mail_proxy_module.c:<global>,TYPE_DECL,"static void
ngx_mail_proxy_dummy_handler(ngx_event_t *wev)
{
    ngx_connection_t    *c;
    ngx_mail_session_t  *s;

    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, wev->log, 0, ""mail proxy dummy handler"");

    if (ngx_handle_write_event(wev, 0) != NGX_OK) {
        c = wev->data;
        s = c->data;

        ngx_mail_proxy_close_session(s);
    }
}",1,1,mail\ngx_mail_proxy_module.c,ngx_mail_proxy_dummy_handler,,false,700,714,ngx_mail_proxy_dummy_handler,,,27,void ngx_mail_proxy_dummy_handler (ngx_event_t*)
391921,METHOD,mail\ngx_mail_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_mail_proxy_read_response(ngx_mail_session_t *s, ngx_uint_t state)
{
    u_char                 *p, *m;
    ssize_t                 n;
    ngx_buf_t              *b;
    ngx_mail_proxy_conf_t  *pcf;

    s->connection->log->action = ""reading response from upstream"";

    b = s->proxy->buffer;

    n = s->proxy->upstream.connection->recv(s->proxy->upstream.connection,
                                            b->last, b->end - b->last);

    if (n == NGX_ERROR || n == 0) {
        return NGX_ERROR;
    }

    if (n == NGX_AGAIN) {
        return NGX_AGAIN;
    }

    b->last += n;

    if (b->last - b->pos < 4) {
        return NGX_AGAIN;
    }

    if (*(b->last - 2) != CR || *(b->last - 1) != LF) {
        if (b->last == b->end) {
            *(b->last - 1) = '\0';
            ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,
                          ""upstream sent too long response line: \""%s\"""",
                          b->pos);
            return NGX_ERRO...",1,1,mail\ngx_mail_proxy_module.c,ngx_mail_proxy_read_response,,false,717,867,ngx_mail_proxy_read_response,,,28,"ngx_int_t ngx_mail_proxy_read_response (ngx_mail_session_t*,ngx_uint_t)"
392418,METHOD,mail\ngx_mail_proxy_module.c:<global>,TYPE_DECL,"static void
ngx_mail_proxy_handler(ngx_event_t *ev)
{
    char                   *action, *recv_action, *send_action;
    size_t                  size;
    ssize_t                 n;
    ngx_buf_t              *b;
    ngx_uint_t              do_write;
    ngx_connection_t       *c, *src, *dst;
    ngx_mail_session_t     *s;
    ngx_mail_proxy_conf_t  *pcf;

    c = ev->data;
    s = c->data;

    if (ev->timedout || c->close) {
        c->log->action = ""proxying"";

        if (c->close) {
            ngx_log_error(NGX_LOG_INFO, c->log, 0, ""shutdown timeout"");

        } else if (c == s->connection) {
            ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT,
                          ""client timed out"");
            c->timedout = 1;

        } else {
            ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT,
                          ""upstream timed out"");
        }

        ngx_mail_proxy_close_session(s);
        return;
    }

    if (c == s->connection) {
        if (ev-...",1,1,mail\ngx_mail_proxy_module.c,ngx_mail_proxy_handler,,false,870,1038,ngx_mail_proxy_handler,,,29,void ngx_mail_proxy_handler (ngx_event_t*)
392969,METHOD,mail\ngx_mail_proxy_module.c:<global>,TYPE_DECL,"static void
ngx_mail_proxy_upstream_error(ngx_mail_session_t *s)
{
    if (s->proxy->upstream.connection) {
        ngx_log_debug1(NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
                       ""close mail proxy connection: %d"",
                       s->proxy->upstream.connection->fd);

        ngx_close_connection(s->proxy->upstream.connection);
    }

    if (s->out.len == 0) {
        ngx_mail_session_internal_server_error(s);
        return;
    }

    s->quit = 1;
    ngx_mail_send(s->connection->write);
}",1,1,mail\ngx_mail_proxy_module.c,ngx_mail_proxy_upstream_error,,false,1041,1059,ngx_mail_proxy_upstream_error,,,30,void ngx_mail_proxy_upstream_error (ngx_mail_session_t*)
393032,METHOD,mail\ngx_mail_proxy_module.c:<global>,TYPE_DECL,"static void
ngx_mail_proxy_internal_server_error(ngx_mail_session_t *s)
{
    if (s->proxy->upstream.connection) {
        ngx_log_debug1(NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
                       ""close mail proxy connection: %d"",
                       s->proxy->upstream.connection->fd);

        ngx_close_connection(s->proxy->upstream.connection);
    }

    ngx_mail_session_internal_server_error(s);
}",1,1,mail\ngx_mail_proxy_module.c,ngx_mail_proxy_internal_server_error,,false,1062,1074,ngx_mail_proxy_internal_server_error,,,31,void ngx_mail_proxy_internal_server_error (ngx_mail_session_t*)
393074,METHOD,mail\ngx_mail_proxy_module.c:<global>,TYPE_DECL,"static void
ngx_mail_proxy_close_session(ngx_mail_session_t *s)
{
    if (s->proxy->upstream.connection) {
        ngx_log_debug1(NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
                       ""close mail proxy connection: %d"",
                       s->proxy->upstream.connection->fd);

        ngx_close_connection(s->proxy->upstream.connection);
    }

    ngx_mail_close_connection(s->connection);
}",1,1,mail\ngx_mail_proxy_module.c,ngx_mail_proxy_close_session,,false,1077,1089,ngx_mail_proxy_close_session,,,32,void ngx_mail_proxy_close_session (ngx_mail_session_t*)
393118,METHOD,mail\ngx_mail_proxy_module.c:<global>,TYPE_DECL,"static void *
ngx_mail_proxy_create_conf(ngx_conf_t *cf)
{
    ngx_mail_proxy_conf_t  *pcf;

    pcf = ngx_pcalloc(cf->pool, sizeof(ngx_mail_proxy_conf_t));
    if (pcf == NULL) {
        return NULL;
    }

    pcf->enable = NGX_CONF_UNSET;
    pcf->pass_error_message = NGX_CONF_UNSET;
    pcf->xclient = NGX_CONF_UNSET;
    pcf->buffer_size = NGX_CONF_UNSET_SIZE;
    pcf->timeout = NGX_CONF_UNSET_MSEC;

    return pcf;
}",1,1,mail\ngx_mail_proxy_module.c,ngx_mail_proxy_create_conf,,false,1092,1109,ngx_mail_proxy_create_conf,,,33,void* ngx_mail_proxy_create_conf (ngx_conf_t*)
393166,METHOD,mail\ngx_mail_proxy_module.c:<global>,TYPE_DECL,"static char *
ngx_mail_proxy_merge_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_mail_proxy_conf_t *prev = parent;
    ngx_mail_proxy_conf_t *conf = child;

    ngx_conf_merge_value(conf->enable, prev->enable, 0);
    ngx_conf_merge_value(conf->pass_error_message, prev->pass_error_message, 0);
    ngx_conf_merge_value(conf->xclient, prev->xclient, 1);
    ngx_conf_merge_size_value(conf->buffer_size, prev->buffer_size,
                              (size_t) ngx_pagesize);
    ngx_conf_merge_msec_value(conf->timeout, prev->timeout, 24 * 60 * 60000);

    return NGX_CONF_OK;
}",1,1,mail\ngx_mail_proxy_module.c,ngx_mail_proxy_merge_conf,,false,1112,1126,ngx_mail_proxy_merge_conf,,,34,"char* ngx_mail_proxy_merge_conf (ngx_conf_t*,void*,void*)"
393242,METHOD,mail\ngx_mail_smtp_handler.c:<global>,TYPE_DECL,<global>,1,1,mail\ngx_mail_smtp_handler.c,mail\ngx_mail_smtp_handler.c:<global>,,false,1,915,<global>,,,1,
393244,METHOD,mail\ngx_mail_smtp_handler.c:<global>,TYPE_DECL,static void ngx_mail_smtp_resolve_addr_handler(ngx_resolver_ctx_t *ctx);,13,71,mail\ngx_mail_smtp_handler.c,ngx_mail_smtp_resolve_addr_handler,,false,15,15,ngx_mail_smtp_resolve_addr_handler,,,1,void ngx_mail_smtp_resolve_addr_handler (ngx_resolver_ctx_t*)
393249,METHOD,mail\ngx_mail_smtp_handler.c:<global>,TYPE_DECL,static void ngx_mail_smtp_resolve_name(ngx_event_t *rev);,13,56,mail\ngx_mail_smtp_handler.c,ngx_mail_smtp_resolve_name,,false,16,16,ngx_mail_smtp_resolve_name,,,2,void ngx_mail_smtp_resolve_name (ngx_event_t*)
393254,METHOD,mail\ngx_mail_smtp_handler.c:<global>,TYPE_DECL,static void ngx_mail_smtp_resolve_name_handler(ngx_resolver_ctx_t *ctx);,13,71,mail\ngx_mail_smtp_handler.c,ngx_mail_smtp_resolve_name_handler,,false,17,17,ngx_mail_smtp_resolve_name_handler,,,3,void ngx_mail_smtp_resolve_name_handler (ngx_resolver_ctx_t*)
393259,METHOD,mail\ngx_mail_smtp_handler.c:<global>,TYPE_DECL,static void ngx_mail_smtp_block_reading(ngx_event_t *rev);,13,57,mail\ngx_mail_smtp_handler.c,ngx_mail_smtp_block_reading,,false,18,18,ngx_mail_smtp_block_reading,,,4,void ngx_mail_smtp_block_reading (ngx_event_t*)
393264,METHOD,mail\ngx_mail_smtp_handler.c:<global>,TYPE_DECL,"static void ngx_mail_smtp_greeting(ngx_mail_session_t *s, ngx_connection_t *c);",13,78,mail\ngx_mail_smtp_handler.c,ngx_mail_smtp_greeting,,false,19,19,ngx_mail_smtp_greeting,,,5,"void ngx_mail_smtp_greeting (ngx_mail_session_t*,ngx_connection_t*)"
393270,METHOD,mail\ngx_mail_smtp_handler.c:<global>,TYPE_DECL,static void ngx_mail_smtp_invalid_pipelining(ngx_event_t *rev);,13,62,mail\ngx_mail_smtp_handler.c,ngx_mail_smtp_invalid_pipelining,,false,20,20,ngx_mail_smtp_invalid_pipelining,,,6,void ngx_mail_smtp_invalid_pipelining (ngx_event_t*)
393275,METHOD,mail\ngx_mail_smtp_handler.c:<global>,TYPE_DECL,"static ngx_int_t ngx_mail_smtp_create_buffer(ngx_mail_session_t *s,
    ngx_connection_t *c);",18,24,mail\ngx_mail_smtp_handler.c,ngx_mail_smtp_create_buffer,,false,21,22,ngx_mail_smtp_create_buffer,,,7,"ngx_int_t ngx_mail_smtp_create_buffer (ngx_mail_session_t*,ngx_connection_t*)"
393281,METHOD,mail\ngx_mail_smtp_handler.c:<global>,TYPE_DECL,"static ngx_int_t ngx_mail_smtp_helo(ngx_mail_session_t *s, ngx_connection_t *c);",18,79,mail\ngx_mail_smtp_handler.c,ngx_mail_smtp_helo,,false,24,24,ngx_mail_smtp_helo,,,8,"ngx_int_t ngx_mail_smtp_helo (ngx_mail_session_t*,ngx_connection_t*)"
393287,METHOD,mail\ngx_mail_smtp_handler.c:<global>,TYPE_DECL,"static ngx_int_t ngx_mail_smtp_auth(ngx_mail_session_t *s, ngx_connection_t *c);",18,79,mail\ngx_mail_smtp_handler.c,ngx_mail_smtp_auth,,false,25,25,ngx_mail_smtp_auth,,,9,"ngx_int_t ngx_mail_smtp_auth (ngx_mail_session_t*,ngx_connection_t*)"
393293,METHOD,mail\ngx_mail_smtp_handler.c:<global>,TYPE_DECL,"static ngx_int_t ngx_mail_smtp_mail(ngx_mail_session_t *s, ngx_connection_t *c);",18,79,mail\ngx_mail_smtp_handler.c,ngx_mail_smtp_mail,,false,26,26,ngx_mail_smtp_mail,,,10,"ngx_int_t ngx_mail_smtp_mail (ngx_mail_session_t*,ngx_connection_t*)"
393299,METHOD,mail\ngx_mail_smtp_handler.c:<global>,TYPE_DECL,"static ngx_int_t ngx_mail_smtp_starttls(ngx_mail_session_t *s,
    ngx_connection_t *c);",18,24,mail\ngx_mail_smtp_handler.c,ngx_mail_smtp_starttls,,false,27,28,ngx_mail_smtp_starttls,,,11,"ngx_int_t ngx_mail_smtp_starttls (ngx_mail_session_t*,ngx_connection_t*)"
393305,METHOD,mail\ngx_mail_smtp_handler.c:<global>,TYPE_DECL,"static ngx_int_t ngx_mail_smtp_rset(ngx_mail_session_t *s, ngx_connection_t *c);",18,79,mail\ngx_mail_smtp_handler.c,ngx_mail_smtp_rset,,false,29,29,ngx_mail_smtp_rset,,,12,"ngx_int_t ngx_mail_smtp_rset (ngx_mail_session_t*,ngx_connection_t*)"
393311,METHOD,mail\ngx_mail_smtp_handler.c:<global>,TYPE_DECL,"static ngx_int_t ngx_mail_smtp_rcpt(ngx_mail_session_t *s, ngx_connection_t *c);",18,79,mail\ngx_mail_smtp_handler.c,ngx_mail_smtp_rcpt,,false,30,30,ngx_mail_smtp_rcpt,,,13,"ngx_int_t ngx_mail_smtp_rcpt (ngx_mail_session_t*,ngx_connection_t*)"
393317,METHOD,mail\ngx_mail_smtp_handler.c:<global>,TYPE_DECL,"static ngx_int_t ngx_mail_smtp_discard_command(ngx_mail_session_t *s,
    ngx_connection_t *c, char *err);",18,35,mail\ngx_mail_smtp_handler.c,ngx_mail_smtp_discard_command,,false,32,33,ngx_mail_smtp_discard_command,,,14,"ngx_int_t ngx_mail_smtp_discard_command (ngx_mail_session_t*,ngx_connection_t*,char*)"
393324,METHOD,mail\ngx_mail_smtp_handler.c:<global>,TYPE_DECL,"static void ngx_mail_smtp_log_rejected_command(ngx_mail_session_t *s,
    ngx_connection_t *c, char *err);",13,35,mail\ngx_mail_smtp_handler.c,ngx_mail_smtp_log_rejected_command,,false,34,35,ngx_mail_smtp_log_rejected_command,,,15,"void ngx_mail_smtp_log_rejected_command (ngx_mail_session_t*,ngx_connection_t*,char*)"
393352,METHOD,mail\ngx_mail_smtp_handler.c:<global>,TYPE_DECL,"void
ngx_mail_smtp_init_session(ngx_mail_session_t *s, ngx_connection_t *c)
{
    ngx_resolver_ctx_t        *ctx;
    ngx_mail_core_srv_conf_t  *cscf;

    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);

    if (cscf->resolver == NULL) {
        s->host = smtp_unavailable;
        ngx_mail_smtp_greeting(s, c);
        return;
    }

#if (NGX_HAVE_UNIX_DOMAIN)
    if (c->sockaddr->sa_family == AF_UNIX) {
        s->host = smtp_tempunavail;
        ngx_mail_smtp_greeting(s, c);
        return;
    }
#endif

    c->log->action = ""in resolving client address"";

    ctx = ngx_resolve_start(cscf->resolver, NULL);
    if (ctx == NULL) {
        ngx_mail_close_connection(c);
        return;
    }

    ctx->addr.sockaddr = c->sockaddr;
    ctx->addr.socklen = c->socklen;
    ctx->handler = ngx_mail_smtp_resolve_addr_handler;
    ctx->data = s;
    ctx->timeout = cscf->resolver_timeout;

    s->resolver_ctx = ctx;
    c->read->handler = ngx_mail_smtp_block_reading;

    if (ngx...",1,1,mail\ngx_mail_smtp_handler.c,ngx_mail_smtp_init_session,,false,56,98,ngx_mail_smtp_init_session,,,31,"void ngx_mail_smtp_init_session (ngx_mail_session_t*,ngx_connection_t*)"
393458,METHOD,mail\ngx_mail_smtp_handler.c:<global>,TYPE_DECL,"static void
ngx_mail_smtp_resolve_addr_handler(ngx_resolver_ctx_t *ctx)
{
    ngx_connection_t    *c;
    ngx_mail_session_t  *s;

    s = ctx->data;
    c = s->connection;

    if (ctx->state) {
        ngx_log_error(NGX_LOG_ERR, c->log, 0,
                      ""%V could not be resolved (%i: %s)"",
                      &c->addr_text, ctx->state,
                      ngx_resolver_strerror(ctx->state));

        if (ctx->state == NGX_RESOLVE_NXDOMAIN) {
            s->host = smtp_unavailable;

        } else {
            s->host = smtp_tempunavail;
        }

        ngx_resolve_addr_done(ctx);

        ngx_mail_smtp_greeting(s, s->connection);

        return;
    }

    c->log->action = ""in resolving client hostname"";

    s->host.data = ngx_pstrdup(c->pool, &ctx->name);
    if (s->host.data == NULL) {
        ngx_resolve_addr_done(ctx);
        ngx_mail_close_connection(c);
        return;
    }

    s->host.len = ctx->name.len;

    ngx_resolve_addr_done(ctx);

    ngx_log_deb...",1,1,mail\ngx_mail_smtp_handler.c,ngx_mail_smtp_resolve_addr_handler,,false,101,149,ngx_mail_smtp_resolve_addr_handler,,,32,void ngx_mail_smtp_resolve_addr_handler (ngx_resolver_ctx_t*)
393597,METHOD,mail\ngx_mail_smtp_handler.c:<global>,TYPE_DECL,"static void
ngx_mail_smtp_resolve_name(ngx_event_t *rev)
{
    ngx_connection_t          *c;
    ngx_mail_session_t        *s;
    ngx_resolver_ctx_t        *ctx;
    ngx_mail_core_srv_conf_t  *cscf;

    c = rev->data;
    s = c->data;

    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);

    ctx = ngx_resolve_start(cscf->resolver, NULL);
    if (ctx == NULL) {
        ngx_mail_close_connection(c);
        return;
    }

    ctx->name = s->host;
    ctx->handler = ngx_mail_smtp_resolve_name_handler;
    ctx->data = s;
    ctx->timeout = cscf->resolver_timeout;

    s->resolver_ctx = ctx;
    c->read->handler = ngx_mail_smtp_block_reading;

    if (ngx_resolve_name(ctx) != NGX_OK) {
        ngx_mail_close_connection(c);
    }
}",1,1,mail\ngx_mail_smtp_handler.c,ngx_mail_smtp_resolve_name,,false,152,182,ngx_mail_smtp_resolve_name,,,33,void ngx_mail_smtp_resolve_name (ngx_event_t*)
393680,METHOD,mail\ngx_mail_smtp_handler.c:<global>,TYPE_DECL,"static void
ngx_mail_smtp_resolve_name_handler(ngx_resolver_ctx_t *ctx)
{
    ngx_uint_t           i;
    ngx_connection_t    *c;
    ngx_mail_session_t  *s;

    s = ctx->data;
    c = s->connection;

    if (ctx->state) {
        ngx_log_error(NGX_LOG_ERR, c->log, 0,
                      ""\""%V\"" could not be resolved (%i: %s)"",
                      &ctx->name, ctx->state,
                      ngx_resolver_strerror(ctx->state));

        if (ctx->state == NGX_RESOLVE_NXDOMAIN) {
            s->host = smtp_unavailable;

        } else {
            s->host = smtp_tempunavail;
        }

    } else {

#if (NGX_DEBUG)
        {
        u_char     text[NGX_SOCKADDR_STRLEN];
        ngx_str_t  addr;

        addr.data = text;

        for (i = 0; i < ctx->naddrs; i++) {
            addr.len = ngx_sock_ntop(ctx->addrs[i].sockaddr,
                                     ctx->addrs[i].socklen,
                                     text, NGX_SOCKADDR_STRLEN, 0);

            ngx_log_debug1(...",1,1,mail\ngx_mail_smtp_handler.c,ngx_mail_smtp_resolve_name_handler,,false,185,245,ngx_mail_smtp_resolve_name_handler,,,34,void ngx_mail_smtp_resolve_name_handler (ngx_resolver_ctx_t*)
393793,METHOD,mail\ngx_mail_smtp_handler.c:<global>,TYPE_DECL,"static void
ngx_mail_smtp_block_reading(ngx_event_t *rev)
{
    ngx_connection_t    *c;
    ngx_mail_session_t  *s;
    ngx_resolver_ctx_t  *ctx;

    c = rev->data;
    s = c->data;

    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0, ""smtp reading blocked"");

    if (ngx_handle_read_event(rev, 0) != NGX_OK) {

        if (s->resolver_ctx) {
            ctx = s->resolver_ctx;

            if (ctx->handler == ngx_mail_smtp_resolve_addr_handler) {
                ngx_resolve_addr_done(ctx);

            } else if (ctx->handler == ngx_mail_smtp_resolve_name_handler) {
                ngx_resolve_name_done(ctx);
            }

            s->resolver_ctx = NULL;
        }

        ngx_mail_close_connection(c);
    }
}",1,1,mail\ngx_mail_smtp_handler.c,ngx_mail_smtp_block_reading,,false,248,277,ngx_mail_smtp_block_reading,,,35,void ngx_mail_smtp_block_reading (ngx_event_t*)
393862,METHOD,mail\ngx_mail_smtp_handler.c:<global>,TYPE_DECL,"static void
ngx_mail_smtp_greeting(ngx_mail_session_t *s, ngx_connection_t *c)
{
    ngx_msec_t                 timeout;
    ngx_mail_core_srv_conf_t  *cscf;
    ngx_mail_smtp_srv_conf_t  *sscf;

    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
                   ""smtp greeting for \""%V\"""", &s->host);

    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);
    sscf = ngx_mail_get_module_srv_conf(s, ngx_mail_smtp_module);

    timeout = sscf->greeting_delay ? sscf->greeting_delay : cscf->timeout;
    ngx_add_timer(c->read, timeout);

    if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
        ngx_mail_close_connection(c);
    }

    if (c->read->ready) {
        ngx_post_event(c->read, &ngx_posted_events);
    }

    if (sscf->greeting_delay) {
         c->read->handler = ngx_mail_smtp_invalid_pipelining;
         return;
    }

    c->read->handler = ngx_mail_smtp_init_protocol;

    s->out = sscf->greeting;

    ngx_mail_send(c->write);
}",1,1,mail\ngx_mail_smtp_handler.c,ngx_mail_smtp_greeting,,false,280,314,ngx_mail_smtp_greeting,,,36,"void ngx_mail_smtp_greeting (ngx_mail_session_t*,ngx_connection_t*)"
393964,METHOD,mail\ngx_mail_smtp_handler.c:<global>,TYPE_DECL,"static void
ngx_mail_smtp_invalid_pipelining(ngx_event_t *rev)
{
    ngx_connection_t          *c;
    ngx_mail_session_t        *s;
    ngx_mail_core_srv_conf_t  *cscf;
    ngx_mail_smtp_srv_conf_t  *sscf;

    c = rev->data;
    s = c->data;

    c->log->action = ""in delay pipelining state"";

    if (rev->timedout) {

        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0, ""delay greeting"");

        rev->timedout = 0;

        cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);

        c->read->handler = ngx_mail_smtp_init_protocol;

        ngx_add_timer(c->read, cscf->timeout);

        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
            ngx_mail_close_connection(c);
            return;
        }

        sscf = ngx_mail_get_module_srv_conf(s, ngx_mail_smtp_module);

        s->out = sscf->greeting;

    } else {

        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0, ""invalid pipelining"");

        if (s->buffer == NULL) {
            if (ngx_mail_smtp_creat...",1,1,mail\ngx_mail_smtp_handler.c,ngx_mail_smtp_invalid_pipelining,,false,317,373,ngx_mail_smtp_invalid_pipelining,,,37,void ngx_mail_smtp_invalid_pipelining (ngx_event_t*)
394098,METHOD,mail\ngx_mail_smtp_handler.c:<global>,TYPE_DECL,"void
ngx_mail_smtp_init_protocol(ngx_event_t *rev)
{
    ngx_connection_t    *c;
    ngx_mail_session_t  *s;

    c = rev->data;

    c->log->action = ""in auth state"";

    if (rev->timedout) {
        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, ""client timed out"");
        c->timedout = 1;
        ngx_mail_close_connection(c);
        return;
    }

    s = c->data;

    if (s->buffer == NULL) {
        if (ngx_mail_smtp_create_buffer(s, c) != NGX_OK) {
            return;
        }
    }

    s->mail_state = ngx_smtp_start;
    c->read->handler = ngx_mail_smtp_auth_state;

    ngx_mail_smtp_auth_state(rev);
}",1,1,mail\ngx_mail_smtp_handler.c,ngx_mail_smtp_init_protocol,,false,376,405,ngx_mail_smtp_init_protocol,,,38,void ngx_mail_smtp_init_protocol (ngx_event_t*)
394171,METHOD,mail\ngx_mail_smtp_handler.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_mail_smtp_create_buffer(ngx_mail_session_t *s, ngx_connection_t *c)
{
    ngx_mail_smtp_srv_conf_t  *sscf;

    if (ngx_array_init(&s->args, c->pool, 2, sizeof(ngx_str_t)) == NGX_ERROR) {
        ngx_mail_session_internal_server_error(s);
        return NGX_ERROR;
    }

    sscf = ngx_mail_get_module_srv_conf(s, ngx_mail_smtp_module);

    s->buffer = ngx_create_temp_buf(c->pool, sscf->client_buffer_size);
    if (s->buffer == NULL) {
        ngx_mail_session_internal_server_error(s);
        return NGX_ERROR;
    }

    return NGX_OK;
}",1,1,mail\ngx_mail_smtp_handler.c,ngx_mail_smtp_create_buffer,,false,408,427,ngx_mail_smtp_create_buffer,,,39,"ngx_int_t ngx_mail_smtp_create_buffer (ngx_mail_session_t*,ngx_connection_t*)"
394226,METHOD,mail\ngx_mail_smtp_handler.c:<global>,TYPE_DECL,"void
ngx_mail_smtp_auth_state(ngx_event_t *rev)
{
    ngx_int_t            rc;
    ngx_connection_t    *c;
    ngx_mail_session_t  *s;

    c = rev->data;
    s = c->data;

    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0, ""smtp auth state"");

    if (rev->timedout) {
        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, ""client timed out"");
        c->timedout = 1;
        ngx_mail_close_connection(c);
        return;
    }

    if (s->out.len) {
        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0, ""smtp send handler busy"");
        s->blocked = 1;
        return;
    }

    s->blocked = 0;

    rc = ngx_mail_read_command(s, c);

    if (rc == NGX_AGAIN || rc == NGX_ERROR) {
        return;
    }

    ngx_str_set(&s->out, smtp_ok);

    if (rc == NGX_OK) {
        switch (s->mail_state) {

        case ngx_smtp_start:

            switch (s->command) {

            case NGX_SMTP_HELO:
            case NGX_SMTP_EHLO:
                rc = ngx_mail_smtp_helo(s, c);
             ...",1,1,mail\ngx_mail_smtp_handler.c,ngx_mail_smtp_auth_state,,false,430,573,ngx_mail_smtp_auth_state,,,40,void ngx_mail_smtp_auth_state (ngx_event_t*)
394579,METHOD,mail\ngx_mail_smtp_handler.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_mail_smtp_helo(ngx_mail_session_t *s, ngx_connection_t *c)
{
    ngx_str_t                 *arg;
    ngx_mail_smtp_srv_conf_t  *sscf;

    if (s->args.nelts != 1) {
        ngx_str_set(&s->out, smtp_invalid_argument);
        s->state = 0;
        return NGX_OK;
    }

    arg = s->args.elts;

    s->smtp_helo.len = arg[0].len;

    s->smtp_helo.data = ngx_pnalloc(c->pool, arg[0].len);
    if (s->smtp_helo.data == NULL) {
        return NGX_ERROR;
    }

    ngx_memcpy(s->smtp_helo.data, arg[0].data, arg[0].len);

    ngx_str_null(&s->smtp_from);
    ngx_str_null(&s->smtp_to);

    sscf = ngx_mail_get_module_srv_conf(s, ngx_mail_smtp_module);

    if (s->command == NGX_SMTP_HELO) {
        s->out = sscf->server_name;

    } else {
        s->esmtp = 1;

#if (NGX_MAIL_SSL)

        if (c->ssl == NULL) {
            ngx_mail_ssl_conf_t  *sslcf;

            sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);

            if (sslcf->starttls == NGX_MAIL_S...",1,1,mail\ngx_mail_smtp_handler.c,ngx_mail_smtp_helo,,false,576,633,ngx_mail_smtp_helo,,,41,"ngx_int_t ngx_mail_smtp_helo (ngx_mail_session_t*,ngx_connection_t*)"
394714,METHOD,mail\ngx_mail_smtp_handler.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_mail_smtp_auth(ngx_mail_session_t *s, ngx_connection_t *c)
{
    ngx_int_t                  rc;
    ngx_mail_core_srv_conf_t  *cscf;
    ngx_mail_smtp_srv_conf_t  *sscf;

#if (NGX_MAIL_SSL)
    if (ngx_mail_starttls_only(s, c)) {
        return NGX_MAIL_PARSE_INVALID_COMMAND;
    }
#endif

    if (s->args.nelts == 0) {
        ngx_str_set(&s->out, smtp_invalid_argument);
        s->state = 0;
        return NGX_OK;
    }

    sscf = ngx_mail_get_module_srv_conf(s, ngx_mail_smtp_module);

    rc = ngx_mail_auth_parse(s, c);

    switch (rc) {

    case NGX_MAIL_AUTH_LOGIN:

        ngx_str_set(&s->out, smtp_username);
        s->mail_state = ngx_smtp_auth_login_username;

        return NGX_OK;

    case NGX_MAIL_AUTH_LOGIN_USERNAME:

        ngx_str_set(&s->out, smtp_password);
        s->mail_state = ngx_smtp_auth_login_password;

        return ngx_mail_auth_login_username(s, c, 1);

    case NGX_MAIL_AUTH_PLAIN:

        ngx_str_set(&s->out, smtp_next);
     ...",1,1,mail\ngx_mail_smtp_handler.c,ngx_mail_smtp_auth,,false,636,716,ngx_mail_smtp_auth,,,42,"ngx_int_t ngx_mail_smtp_auth (ngx_mail_session_t*,ngx_connection_t*)"
394887,METHOD,mail\ngx_mail_smtp_handler.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_mail_smtp_mail(ngx_mail_session_t *s, ngx_connection_t *c)
{
    ngx_str_t                 *arg, cmd;
    ngx_mail_smtp_srv_conf_t  *sscf;

    sscf = ngx_mail_get_module_srv_conf(s, ngx_mail_smtp_module);

    if (!(sscf->auth_methods & NGX_MAIL_AUTH_NONE_ENABLED)) {
        ngx_mail_smtp_log_rejected_command(s, c, ""client was rejected: \""%V\"""");
        ngx_str_set(&s->out, smtp_auth_required);
        return NGX_OK;
    }

    /* auth none */

    if (s->smtp_from.len) {
        ngx_str_set(&s->out, smtp_bad_sequence);
        return NGX_OK;
    }

    if (s->args.nelts == 0) {
        ngx_str_set(&s->out, smtp_invalid_argument);
        return NGX_OK;
    }

    arg = s->args.elts;
    arg += s->args.nelts - 1;

    cmd.len = arg->data + arg->len - s->cmd.data;
    cmd.data = s->cmd.data;

    s->smtp_from.len = cmd.len;

    s->smtp_from.data = ngx_pnalloc(c->pool, cmd.len);
    if (s->smtp_from.data == NULL) {
        return NGX_ERROR;
    }

    ngx_memcp...",1,1,mail\ngx_mail_smtp_handler.c,ngx_mail_smtp_mail,,false,719,766,ngx_mail_smtp_mail,,,43,"ngx_int_t ngx_mail_smtp_mail (ngx_mail_session_t*,ngx_connection_t*)"
395059,METHOD,mail\ngx_mail_smtp_handler.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_mail_smtp_rcpt(ngx_mail_session_t *s, ngx_connection_t *c)
{
    ngx_str_t  *arg, cmd;

    if (s->smtp_from.len == 0) {
        ngx_str_set(&s->out, smtp_bad_sequence);
        return NGX_OK;
    }

    if (s->args.nelts == 0) {
        ngx_str_set(&s->out, smtp_invalid_argument);
        return NGX_OK;
    }

    arg = s->args.elts;
    arg += s->args.nelts - 1;

    cmd.len = arg->data + arg->len - s->cmd.data;
    cmd.data = s->cmd.data;

    s->smtp_to.len = cmd.len;

    s->smtp_to.data = ngx_pnalloc(c->pool, cmd.len);
    if (s->smtp_to.data == NULL) {
        return NGX_ERROR;
    }

    ngx_memcpy(s->smtp_to.data, cmd.data, cmd.len);

    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
                   ""smtp rcpt to:\""%V\"""", &s->smtp_to);

    s->auth_method = NGX_MAIL_AUTH_NONE;

    return NGX_DONE;
}",1,1,mail\ngx_mail_smtp_handler.c,ngx_mail_smtp_rcpt,,false,769,805,ngx_mail_smtp_rcpt,,,44,"ngx_int_t ngx_mail_smtp_rcpt (ngx_mail_session_t*,ngx_connection_t*)"
395206,METHOD,mail\ngx_mail_smtp_handler.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_mail_smtp_rset(ngx_mail_session_t *s, ngx_connection_t *c)
{
    ngx_str_null(&s->smtp_from);
    ngx_str_null(&s->smtp_to);
    ngx_str_set(&s->out, smtp_ok);

    return NGX_OK;
}",1,1,mail\ngx_mail_smtp_handler.c,ngx_mail_smtp_rset,,false,808,816,ngx_mail_smtp_rset,,,45,"ngx_int_t ngx_mail_smtp_rset (ngx_mail_session_t*,ngx_connection_t*)"
395230,METHOD,mail\ngx_mail_smtp_handler.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_mail_smtp_starttls(ngx_mail_session_t *s, ngx_connection_t *c)
{
#if (NGX_MAIL_SSL)
    ngx_mail_ssl_conf_t  *sslcf;

    if (c->ssl == NULL) {
        sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);
        if (sslcf->starttls) {

            /*
             * RFC3207 requires us to discard any knowledge
             * obtained from client before STARTTLS.
             */

            ngx_str_null(&s->smtp_helo);
            ngx_str_null(&s->smtp_from);
            ngx_str_null(&s->smtp_to);

            s->buffer->pos = s->buffer->start;
            s->buffer->last = s->buffer->start;

            c->read->handler = ngx_mail_starttls_handler;
            return NGX_OK;
        }
    }

#endif

    return NGX_MAIL_PARSE_INVALID_COMMAND;
}",1,1,mail\ngx_mail_smtp_handler.c,ngx_mail_smtp_starttls,,false,819,849,ngx_mail_smtp_starttls,,,46,"ngx_int_t ngx_mail_smtp_starttls (ngx_mail_session_t*,ngx_connection_t*)"
395238,METHOD,mail\ngx_mail_smtp_handler.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_mail_smtp_discard_command(ngx_mail_session_t *s, ngx_connection_t *c,
    char *err)
{
    ssize_t    n;

    n = c->recv(c, s->buffer->last, s->buffer->end - s->buffer->last);

    if (n == NGX_ERROR || n == 0) {
        ngx_mail_close_connection(c);
        return NGX_ERROR;
    }

    if (n > 0) {
        s->buffer->last += n;
    }

    if (n == NGX_AGAIN) {
        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
            ngx_mail_session_internal_server_error(s);
            return NGX_ERROR;
        }

        return NGX_AGAIN;
    }

    ngx_mail_smtp_log_rejected_command(s, c, err);

    s->buffer->pos = s->buffer->start;
    s->buffer->last = s->buffer->start;

    return NGX_OK;
}",1,1,mail\ngx_mail_smtp_handler.c,ngx_mail_smtp_discard_command,,false,852,884,ngx_mail_smtp_discard_command,,,47,"ngx_int_t ngx_mail_smtp_discard_command (ngx_mail_session_t*,ngx_connection_t*,char*)"
395342,METHOD,mail\ngx_mail_smtp_handler.c:<global>,TYPE_DECL,"static void
ngx_mail_smtp_log_rejected_command(ngx_mail_session_t *s, ngx_connection_t *c,
    char *err)
{
    u_char      ch;
    ngx_str_t   cmd;
    ngx_uint_t  i;

    if (c->log->log_level < NGX_LOG_INFO) {
        return;
    }

    cmd.len = s->buffer->last - s->buffer->start;
    cmd.data = s->buffer->start;

    for (i = 0; i < cmd.len; i++) {
        ch = cmd.data[i];

        if (ch != CR && ch != LF) {
            continue;
        }

        cmd.data[i] = '_';
    }

    cmd.len = i;

    ngx_log_error(NGX_LOG_INFO, c->log, 0, err, &cmd);
}",1,1,mail\ngx_mail_smtp_handler.c,ngx_mail_smtp_log_rejected_command,,false,887,915,ngx_mail_smtp_log_rejected_command,,,48,"void ngx_mail_smtp_log_rejected_command (ngx_mail_session_t*,ngx_connection_t*,char*)"
395450,METHOD,mail\ngx_mail_smtp_module.c:<global>,TYPE_DECL,<global>,1,1,mail\ngx_mail_smtp_module.c,mail\ngx_mail_smtp_module.c:<global>,,false,1,311,<global>,,,1,
395452,METHOD,mail\ngx_mail_smtp_module.c:<global>,TYPE_DECL,static void *ngx_mail_smtp_create_srv_conf(ngx_conf_t *cf);,13,58,mail\ngx_mail_smtp_module.c,ngx_mail_smtp_create_srv_conf,,false,15,15,ngx_mail_smtp_create_srv_conf,,,1,void* ngx_mail_smtp_create_srv_conf (ngx_conf_t*)
395457,METHOD,mail\ngx_mail_smtp_module.c:<global>,TYPE_DECL,"static char *ngx_mail_smtp_merge_srv_conf(ngx_conf_t *cf, void *parent,
    void *child);",13,16,mail\ngx_mail_smtp_module.c,ngx_mail_smtp_merge_srv_conf,,false,16,17,ngx_mail_smtp_merge_srv_conf,,,2,"char* ngx_mail_smtp_merge_srv_conf (ngx_conf_t*,void*,void*)"
395596,METHOD,mail\ngx_mail_smtp_module.c:<global>,TYPE_DECL,"static void *
ngx_mail_smtp_create_srv_conf(ngx_conf_t *cf)
{
    ngx_mail_smtp_srv_conf_t  *sscf;

    sscf = ngx_pcalloc(cf->pool, sizeof(ngx_mail_smtp_srv_conf_t));
    if (sscf == NULL) {
        return NULL;
    }

    sscf->client_buffer_size = NGX_CONF_UNSET_SIZE;
    sscf->greeting_delay = NGX_CONF_UNSET_MSEC;

    if (ngx_array_init(&sscf->capabilities, cf->pool, 4, sizeof(ngx_str_t))
        != NGX_OK)
    {
        return NULL;
    }

    return sscf;
}",1,1,mail\ngx_mail_smtp_module.c,ngx_mail_smtp_create_srv_conf,,false,117,137,ngx_mail_smtp_create_srv_conf,,,15,void* ngx_mail_smtp_create_srv_conf (ngx_conf_t*)
395646,METHOD,mail\ngx_mail_smtp_module.c:<global>,TYPE_DECL,"static char *
ngx_mail_smtp_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_mail_smtp_srv_conf_t *prev = parent;
    ngx_mail_smtp_srv_conf_t *conf = child;

    u_char                    *p, *auth, *last;
    size_t                     size;
    ngx_str_t                 *c;
    ngx_uint_t                 i, m, auth_enabled;
    ngx_mail_core_srv_conf_t  *cscf;

    ngx_conf_merge_size_value(conf->client_buffer_size,
                              prev->client_buffer_size,
                              (size_t) ngx_pagesize);

    ngx_conf_merge_msec_value(conf->greeting_delay,
                              prev->greeting_delay, 0);

    ngx_conf_merge_bitmask_value(conf->auth_methods,
                              prev->auth_methods,
                              (NGX_CONF_BITMASK_SET
                               |NGX_MAIL_AUTH_PLAIN_ENABLED
                               |NGX_MAIL_AUTH_LOGIN_ENABLED));


    cscf = ngx_mail_conf_get_module_srv_conf(cf, ngx_ma...",1,1,mail\ngx_mail_smtp_module.c,ngx_mail_smtp_merge_srv_conf,,false,140,311,ngx_mail_smtp_merge_srv_conf,,,16,"char* ngx_mail_smtp_merge_srv_conf (ngx_conf_t*,void*,void*)"
396365,METHOD,mail\ngx_mail_smtp_module.h:<global>,TYPE_DECL,<global>,1,46,mail\ngx_mail_smtp_module.h,mail\ngx_mail_smtp_module.h:<global>,,false,1,45,<global>,,,1,
396378,METHOD,mail\ngx_mail_smtp_module.h:<global>,TYPE_DECL,"void ngx_mail_smtp_init_session(ngx_mail_session_t *s, ngx_connection_t *c);",6,75,mail\ngx_mail_smtp_module.h,ngx_mail_smtp_init_session,,false,36,36,ngx_mail_smtp_init_session,,,3,"void ngx_mail_smtp_init_session (ngx_mail_session_t*,ngx_connection_t*)"
396384,METHOD,mail\ngx_mail_smtp_module.h:<global>,TYPE_DECL,void ngx_mail_smtp_init_protocol(ngx_event_t *rev);,6,50,mail\ngx_mail_smtp_module.h,ngx_mail_smtp_init_protocol,,false,37,37,ngx_mail_smtp_init_protocol,,,4,void ngx_mail_smtp_init_protocol (ngx_event_t*)
396389,METHOD,mail\ngx_mail_smtp_module.h:<global>,TYPE_DECL,void ngx_mail_smtp_auth_state(ngx_event_t *rev);,6,47,mail\ngx_mail_smtp_module.h,ngx_mail_smtp_auth_state,,false,38,38,ngx_mail_smtp_auth_state,,,5,void ngx_mail_smtp_auth_state (ngx_event_t*)
396394,METHOD,mail\ngx_mail_smtp_module.h:<global>,TYPE_DECL,ngx_int_t ngx_mail_smtp_parse_command(ngx_mail_session_t *s);,11,60,mail\ngx_mail_smtp_module.h,ngx_mail_smtp_parse_command,,false,39,39,ngx_mail_smtp_parse_command,,,6,ngx_int_t ngx_mail_smtp_parse_command (ngx_mail_session_t*)
396409,METHOD,mail\ngx_mail_ssl_module.c:<global>,TYPE_DECL,<global>,1,25,mail\ngx_mail_ssl_module.c,mail\ngx_mail_ssl_module.c:<global>,,false,1,656,<global>,,,1,
396411,METHOD,mail\ngx_mail_ssl_module.c:<global>,TYPE_DECL,static void *ngx_mail_ssl_create_conf(ngx_conf_t *cf);,13,53,mail\ngx_mail_ssl_module.c,ngx_mail_ssl_create_conf,,false,17,17,ngx_mail_ssl_create_conf,,,1,void* ngx_mail_ssl_create_conf (ngx_conf_t*)
396416,METHOD,mail\ngx_mail_ssl_module.c:<global>,TYPE_DECL,"static char *ngx_mail_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child);",13,79,mail\ngx_mail_ssl_module.c,ngx_mail_ssl_merge_conf,,false,18,18,ngx_mail_ssl_merge_conf,,,2,"char* ngx_mail_ssl_merge_conf (ngx_conf_t*,void*,void*)"
396423,METHOD,mail\ngx_mail_ssl_module.c:<global>,TYPE_DECL,"static char *ngx_mail_ssl_enable(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,mail\ngx_mail_ssl_module.c,ngx_mail_ssl_enable,,false,20,21,ngx_mail_ssl_enable,,,3,"char* ngx_mail_ssl_enable (ngx_conf_t*,ngx_command_t*,void*)"
396430,METHOD,mail\ngx_mail_ssl_module.c:<global>,TYPE_DECL,"static char *ngx_mail_ssl_starttls(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,mail\ngx_mail_ssl_module.c,ngx_mail_ssl_starttls,,false,22,23,ngx_mail_ssl_starttls,,,4,"char* ngx_mail_ssl_starttls (ngx_conf_t*,ngx_command_t*,void*)"
396437,METHOD,mail\ngx_mail_ssl_module.c:<global>,TYPE_DECL,"static char *ngx_mail_ssl_password_file(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,mail\ngx_mail_ssl_module.c,ngx_mail_ssl_password_file,,false,24,25,ngx_mail_ssl_password_file,,,5,"char* ngx_mail_ssl_password_file (ngx_conf_t*,ngx_command_t*,void*)"
396444,METHOD,mail\ngx_mail_ssl_module.c:<global>,TYPE_DECL,"static char *ngx_mail_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,mail\ngx_mail_ssl_module.c,ngx_mail_ssl_session_cache,,false,26,27,ngx_mail_ssl_session_cache,,,6,"char* ngx_mail_ssl_session_cache (ngx_conf_t*,ngx_command_t*,void*)"
396832,METHOD,mail\ngx_mail_ssl_module.c:<global>,TYPE_DECL,"static void *
ngx_mail_ssl_create_conf(ngx_conf_t *cf)
{
    ngx_mail_ssl_conf_t  *scf;

    scf = ngx_pcalloc(cf->pool, sizeof(ngx_mail_ssl_conf_t));
    if (scf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     scf->listen = 0;
     *     scf->protocols = 0;
     *     scf->dhparam = { 0, NULL };
     *     scf->ecdh_curve = { 0, NULL };
     *     scf->client_certificate = { 0, NULL };
     *     scf->trusted_certificate = { 0, NULL };
     *     scf->crl = { 0, NULL };
     *     scf->ciphers = { 0, NULL };
     *     scf->shm_zone = NULL;
     */

    scf->enable = NGX_CONF_UNSET;
    scf->starttls = NGX_CONF_UNSET_UINT;
    scf->certificates = NGX_CONF_UNSET_PTR;
    scf->certificate_keys = NGX_CONF_UNSET_PTR;
    scf->passwords = NGX_CONF_UNSET_PTR;
    scf->prefer_server_ciphers = NGX_CONF_UNSET;
    scf->verify = NGX_CONF_UNSET_UINT;
    scf->verify_depth = NGX_CONF_UNSET_UINT;
    scf->builtin_session_cache = NGX_CONF_UNSET;
    s...",1,1,mail\ngx_mail_ssl_module.c,ngx_mail_ssl_create_conf,,false,233,271,ngx_mail_ssl_create_conf,,,23,void* ngx_mail_ssl_create_conf (ngx_conf_t*)
396915,METHOD,mail\ngx_mail_ssl_module.c:<global>,TYPE_DECL,"static char *
ngx_mail_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_mail_ssl_conf_t *prev = parent;
    ngx_mail_ssl_conf_t *conf = child;

    char                *mode;
    ngx_pool_cleanup_t  *cln;

    ngx_conf_merge_value(conf->enable, prev->enable, 0);
    ngx_conf_merge_uint_value(conf->starttls, prev->starttls,
                         NGX_MAIL_STARTTLS_OFF);

    ngx_conf_merge_value(conf->session_timeout,
                         prev->session_timeout, 300);

    ngx_conf_merge_value(conf->prefer_server_ciphers,
                         prev->prefer_server_ciphers, 0);

    ngx_conf_merge_bitmask_value(conf->protocols, prev->protocols,
                         (NGX_CONF_BITMASK_SET|NGX_SSL_TLSv1
                          |NGX_SSL_TLSv1_1|NGX_SSL_TLSv1_2));

    ngx_conf_merge_uint_value(conf->verify, prev->verify, 0);
    ngx_conf_merge_uint_value(conf->verify_depth, prev->verify_depth, 1);

    ngx_conf_merge_ptr_value(conf->certificates, prev->cert...",1,25,mail\ngx_mail_ssl_module.c,ngx_mail_ssl_merge_conf,,false,274,465,ngx_mail_ssl_merge_conf,,,24,"char* ngx_mail_ssl_merge_conf (ngx_conf_t*,void*,void*)"
397506,METHOD,mail\ngx_mail_ssl_module.c:<global>,TYPE_DECL,"static char *
ngx_mail_ssl_enable(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_mail_ssl_conf_t  *scf = conf;

    char  *rv;

    rv = ngx_conf_set_flag_slot(cf, cmd, conf);

    if (rv != NGX_CONF_OK) {
        return rv;
    }

    if (scf->enable && (ngx_int_t) scf->starttls > NGX_MAIL_STARTTLS_OFF) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""\""starttls\"" directive conflicts with \""ssl on\"""");
        return NGX_CONF_ERROR;
    }

    if (!scf->listen) {
        scf->file = cf->conf_file->file.name.data;
        scf->line = cf->conf_file->line;
    }

    return NGX_CONF_OK;
}",1,1,mail\ngx_mail_ssl_module.c,ngx_mail_ssl_enable,,false,468,493,ngx_mail_ssl_enable,,,25,"char* ngx_mail_ssl_enable (ngx_conf_t*,ngx_command_t*,void*)"
397581,METHOD,mail\ngx_mail_ssl_module.c:<global>,TYPE_DECL,"static char *
ngx_mail_ssl_starttls(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_mail_ssl_conf_t  *scf = conf;

    char  *rv;

    rv = ngx_conf_set_enum_slot(cf, cmd, conf);

    if (rv != NGX_CONF_OK) {
        return rv;
    }

    if (scf->enable == 1 && (ngx_int_t) scf->starttls > NGX_MAIL_STARTTLS_OFF) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""\""ssl\"" directive conflicts with \""starttls\"""");
        return NGX_CONF_ERROR;
    }

    if (!scf->listen) {
        scf->file = cf->conf_file->file.name.data;
        scf->line = cf->conf_file->line;
    }

    return NGX_CONF_OK;
}",1,1,mail\ngx_mail_ssl_module.c,ngx_mail_ssl_starttls,,false,496,521,ngx_mail_ssl_starttls,,,26,"char* ngx_mail_ssl_starttls (ngx_conf_t*,ngx_command_t*,void*)"
397658,METHOD,mail\ngx_mail_ssl_module.c:<global>,TYPE_DECL,"static char *
ngx_mail_ssl_password_file(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_mail_ssl_conf_t  *scf = conf;

    ngx_str_t  *value;

    if (scf->passwords != NGX_CONF_UNSET_PTR) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    scf->passwords = ngx_ssl_read_password_file(cf, &value[1]);

    if (scf->passwords == NULL) {
        return NGX_CONF_ERROR;
    }

    return NGX_CONF_OK;
}",1,1,mail\ngx_mail_ssl_module.c,ngx_mail_ssl_password_file,,false,524,544,ngx_mail_ssl_password_file,,,27,"char* ngx_mail_ssl_password_file (ngx_conf_t*,ngx_command_t*,void*)"
397707,METHOD,mail\ngx_mail_ssl_module.c:<global>,TYPE_DECL,"static char *
ngx_mail_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_mail_ssl_conf_t  *scf = conf;

    size_t       len;
    ngx_str_t   *value, name, size;
    ngx_int_t    n;
    ngx_uint_t   i, j;

    value = cf->args->elts;

    for (i = 1; i < cf->args->nelts; i++) {

        if (ngx_strcmp(value[i].data, ""off"") == 0) {
            scf->builtin_session_cache = NGX_SSL_NO_SCACHE;
            continue;
        }

        if (ngx_strcmp(value[i].data, ""none"") == 0) {
            scf->builtin_session_cache = NGX_SSL_NONE_SCACHE;
            continue;
        }

        if (ngx_strcmp(value[i].data, ""builtin"") == 0) {
            scf->builtin_session_cache = NGX_SSL_DFLT_BUILTIN_SCACHE;
            continue;
        }

        if (value[i].len > sizeof(""builtin:"") - 1
            && ngx_strncmp(value[i].data, ""builtin:"", sizeof(""builtin:"") - 1)
               == 0)
        {
            n = ngx_atoi(value[i].data + sizeof(""builtin:"") - 1,
            ...",1,1,mail\ngx_mail_ssl_module.c,ngx_mail_ssl_session_cache,,false,547,656,ngx_mail_ssl_session_cache,,,28,"char* ngx_mail_ssl_session_cache (ngx_conf_t*,ngx_command_t*,void*)"
398067,METHOD,mail\ngx_mail_ssl_module.h:<global>,TYPE_DECL,<global>,1,38,mail\ngx_mail_ssl_module.h,mail\ngx_mail_ssl_module.h:<global>,,false,1,65,<global>,,,1,
398119,METHOD,misc\ngx_cpp_test_module.cpp:<global>,TYPE_DECL,<global>,1,1,misc\ngx_cpp_test_module.cpp,misc\ngx_cpp_test_module.cpp:<global>,,false,1,29,<global>,,,1,
398121,METHOD,misc\ngx_cpp_test_module.cpp:<global>,TYPE_DECL,void ngx_cpp_test_handler(void *data);,6,37,misc\ngx_cpp_test_module.cpp,ngx_cpp_test_handler,,false,23,23,ngx_cpp_test_handler,,,1,void ngx_cpp_test_handler (void*)
398126,METHOD,misc\ngx_cpp_test_module.cpp:<global>,TYPE_DECL,"void
ngx_cpp_test_handler(void *data)
{
    return;
}",1,1,misc\ngx_cpp_test_module.cpp,ngx_cpp_test_handler,,false,25,29,ngx_cpp_test_handler,,,2,void ngx_cpp_test_handler (void*)
398139,METHOD,misc\ngx_google_perftools_module.c:<global>,TYPE_DECL,<global>,1,54,misc\ngx_google_perftools_module.c,misc\ngx_google_perftools_module.c:<global>,,false,1,126,<global>,,,1,
398141,METHOD,misc\ngx_google_perftools_module.c:<global>,TYPE_DECL,int ProfilerStart(u_char* fname);,5,32,misc\ngx_google_perftools_module.c,ProfilerStart,,false,16,16,ProfilerStart,,,1,int ProfilerStart (u_char*)
398146,METHOD,misc\ngx_google_perftools_module.c:<global>,TYPE_DECL,void ProfilerStop(void);,6,23,misc\ngx_google_perftools_module.c,ProfilerStop,,false,17,17,ProfilerStop,,,2,void ProfilerStop (void)
398151,METHOD,misc\ngx_google_perftools_module.c:<global>,TYPE_DECL,void ProfilerRegisterThread(void);,6,33,misc\ngx_google_perftools_module.c,ProfilerRegisterThread,,false,18,18,ProfilerRegisterThread,,,3,void ProfilerRegisterThread (void)
398156,METHOD,misc\ngx_google_perftools_module.c:<global>,TYPE_DECL,static void *ngx_google_perftools_create_conf(ngx_cycle_t *cycle);,13,65,misc\ngx_google_perftools_module.c,ngx_google_perftools_create_conf,,false,21,21,ngx_google_perftools_create_conf,,,4,void* ngx_google_perftools_create_conf (ngx_cycle_t*)
398161,METHOD,misc\ngx_google_perftools_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_google_perftools_worker(ngx_cycle_t *cycle);,18,64,misc\ngx_google_perftools_module.c,ngx_google_perftools_worker,,false,22,22,ngx_google_perftools_worker,,,5,ngx_int_t ngx_google_perftools_worker (ngx_cycle_t*)
398213,METHOD,misc\ngx_google_perftools_module.c:<global>,TYPE_DECL,"static void *
ngx_google_perftools_create_conf(ngx_cycle_t *cycle)
{
    ngx_google_perftools_conf_t  *gptcf;

    gptcf = ngx_pcalloc(cycle->pool, sizeof(ngx_google_perftools_conf_t));
    if (gptcf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc()
     *
     *     gptcf->profiles = { 0, NULL };
     */

    return gptcf;
}",1,1,misc\ngx_google_perftools_module.c,ngx_google_perftools_create_conf,,false,66,83,ngx_google_perftools_create_conf,,,14,void* ngx_google_perftools_create_conf (ngx_cycle_t*)
398236,METHOD,misc\ngx_google_perftools_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_google_perftools_worker(ngx_cycle_t *cycle)
{
    u_char                       *profile;
    ngx_google_perftools_conf_t  *gptcf;

    gptcf = (ngx_google_perftools_conf_t *)
                ngx_get_conf(cycle->conf_ctx, ngx_google_perftools_module);

    if (gptcf->profiles.len == 0) {
        return NGX_OK;
    }

    profile = ngx_alloc(gptcf->profiles.len + NGX_INT_T_LEN + 2, cycle->log);
    if (profile == NULL) {
        return NGX_OK;
    }

    if (getenv(""CPUPROFILE"")) {
        /* disable inherited Profiler enabled in master process */
        ProfilerStop();
    }

    ngx_sprintf(profile, ""%V.%d%Z"", &gptcf->profiles, ngx_pid);

    if (ProfilerStart(profile)) {
        /* start ITIMER_PROF timer */
        ProfilerRegisterThread();

    } else {
        ngx_log_error(NGX_LOG_CRIT, cycle->log, ngx_errno,
                      ""ProfilerStart(%s) failed"", profile);
    }

    ngx_free(profile);

    return NGX_OK;
}",1,1,misc\ngx_google_perftools_module.c,ngx_google_perftools_worker,,false,86,123,ngx_google_perftools_worker,,,15,ngx_int_t ngx_google_perftools_worker (ngx_cycle_t*)
398324,METHOD,os\unix\ngx_alloc.c:<global>,TYPE_DECL,<global>,1,6,os\unix\ngx_alloc.c,os\unix\ngx_alloc.c:<global>,,false,1,90,<global>,,,1,
398329,METHOD,os\unix\ngx_alloc.c:<global>,TYPE_DECL,"void *
ngx_alloc(size_t size, ngx_log_t *log)
{
    void  *p;

    p = malloc(size);
    if (p == NULL) {
        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,
                      ""malloc(%uz) failed"", size);
    }

    ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, log, 0, ""malloc: %p:%uz"", p, size);

    return p;
}",1,1,os\unix\ngx_alloc.c,ngx_alloc,,false,17,31,ngx_alloc,,,4,"void* ngx_alloc (size_t,ngx_log_t*)"
398360,METHOD,os\unix\ngx_alloc.c:<global>,TYPE_DECL,"void *
ngx_calloc(size_t size, ngx_log_t *log)
{
    void  *p;

    p = ngx_alloc(size, log);

    if (p) {
        ngx_memzero(p, size);
    }

    return p;
}",1,1,os\unix\ngx_alloc.c,ngx_calloc,,false,34,46,ngx_calloc,,,5,"void* ngx_calloc (size_t,ngx_log_t*)"
398387,METHOD,os\unix\ngx_alloc.h:<global>,TYPE_DECL,<global>,1,35,os\unix\ngx_alloc.h,os\unix\ngx_alloc.h:<global>,,false,1,45,<global>,,,1,
398389,METHOD,os\unix\ngx_alloc.h:<global>,TYPE_DECL,"void *ngx_alloc(size_t size, ngx_log_t *log);",6,44,os\unix\ngx_alloc.h,ngx_alloc,,false,16,16,ngx_alloc,,,1,"void* ngx_alloc (size_t,ngx_log_t*)"
398395,METHOD,os\unix\ngx_alloc.h:<global>,TYPE_DECL,"void *ngx_calloc(size_t size, ngx_log_t *log);",6,45,os\unix\ngx_alloc.h,ngx_calloc,,false,17,17,ngx_calloc,,,2,"void* ngx_calloc (size_t,ngx_log_t*)"
398425,METHOD,os\unix\ngx_atomic.h:<global>,TYPE_DECL,<global>,1,36,os\unix\ngx_atomic.h,os\unix\ngx_atomic.h:<global>,,false,1,313,<global>,,,1,
398432,METHOD,os\unix\ngx_atomic.h:<global>,TYPE_DECL,"ngx_atomic_cmp_set(ngx_atomic_t *lock, ngx_atomic_uint_t old,
    ngx_atomic_uint_t set)
{
    if (*lock == old) {
        *lock = set;
        return 1;
    }

    return 0;
}",1,1,os\unix\ngx_atomic.h,ngx_atomic_cmp_set,,false,278,287,ngx_atomic_cmp_set,,,6,"ANY ngx_atomic_cmp_set (ngx_atomic_t*,ngx_atomic_uint_t,ngx_atomic_uint_t)"
398455,METHOD,os\unix\ngx_atomic.h:<global>,TYPE_DECL,"ngx_atomic_fetch_add(ngx_atomic_t *value, ngx_atomic_int_t add)
{
    ngx_atomic_int_t  old;

    old = *value;
    *value += add;

    return old;
}",1,1,os\unix\ngx_atomic.h,ngx_atomic_fetch_add,,false,291,299,ngx_atomic_fetch_add,,,9,"ANY ngx_atomic_fetch_add (ngx_atomic_t*,ngx_atomic_int_t)"
398472,METHOD,os\unix\ngx_atomic.h:<global>,TYPE_DECL,"void ngx_spinlock(ngx_atomic_t *lock, ngx_atomic_int_t value, ngx_uint_t spin);",6,78,os\unix\ngx_atomic.h,ngx_spinlock,,false,307,307,ngx_spinlock,,,10,"void ngx_spinlock (ngx_atomic_t*,ngx_atomic_int_t,ngx_uint_t)"
398488,METHOD,os\unix\ngx_channel.c:<global>,TYPE_DECL,<global>,1,1,os\unix\ngx_channel.c,os\unix\ngx_channel.c:<global>,,false,1,253,<global>,,,1,
398490,METHOD,os\unix\ngx_channel.c:<global>,TYPE_DECL,"ngx_int_t
ngx_write_channel(ngx_socket_t s, ngx_channel_t *ch, size_t size,
    ngx_log_t *log)
{
    ssize_t             n;
    ngx_err_t           err;
    struct iovec        iov[1];
    struct msghdr       msg;

#if (NGX_HAVE_MSGHDR_MSG_CONTROL)

    union {
        struct cmsghdr  cm;
        char            space[CMSG_SPACE(sizeof(int))];
    } cmsg;

    if (ch->fd == -1) {
        msg.msg_control = NULL;
        msg.msg_controllen = 0;

    } else {
        msg.msg_control = (caddr_t) &cmsg;
        msg.msg_controllen = sizeof(cmsg);

        ngx_memzero(&cmsg, sizeof(cmsg));

        cmsg.cm.cmsg_len = CMSG_LEN(sizeof(int));
        cmsg.cm.cmsg_level = SOL_SOCKET;
        cmsg.cm.cmsg_type = SCM_RIGHTS;

        /*
         * We have to use ngx_memcpy() instead of simple
         *   *(int *) CMSG_DATA(&cmsg.cm) = ch->fd;
         * because some gcc 4.4 with -O2/3/s optimization issues the warning:
         *   dereferencing type-punned pointer will break strict-aliasing r...",1,1,os\unix\ngx_channel.c,ngx_write_channel,,false,13,92,ngx_write_channel,,,1,"ngx_int_t ngx_write_channel (ngx_socket_t,ngx_channel_t*,size_t,ngx_log_t*)"
398605,METHOD,os\unix\ngx_channel.c:<global>,TYPE_DECL,"ngx_int_t
ngx_read_channel(ngx_socket_t s, ngx_channel_t *ch, size_t size, ngx_log_t *log)
{
    ssize_t             n;
    ngx_err_t           err;
    struct iovec        iov[1];
    struct msghdr       msg;

#if (NGX_HAVE_MSGHDR_MSG_CONTROL)
    union {
        struct cmsghdr  cm;
        char            space[CMSG_SPACE(sizeof(int))];
    } cmsg;
#else
    int                 fd;
#endif

    iov[0].iov_base = (char *) ch;
    iov[0].iov_len = size;

    msg.msg_name = NULL;
    msg.msg_namelen = 0;
    msg.msg_iov = iov;
    msg.msg_iovlen = 1;

#if (NGX_HAVE_MSGHDR_MSG_CONTROL)
    msg.msg_control = (caddr_t) &cmsg;
    msg.msg_controllen = sizeof(cmsg);
#else
    msg.msg_accrights = (caddr_t) &fd;
    msg.msg_accrightslen = sizeof(int);
#endif

    n = recvmsg(s, &msg, 0);

    if (n == -1) {
        err = ngx_errno;
        if (err == NGX_EAGAIN) {
            return NGX_AGAIN;
        }

        ngx_log_error(NGX_LOG_ALERT, log, err, ""recvmsg() failed"");
        return NGX_E...",1,1,os\unix\ngx_channel.c,ngx_read_channel,,false,95,195,ngx_read_channel,,,2,"ngx_int_t ngx_read_channel (ngx_socket_t,ngx_channel_t*,size_t,ngx_log_t*)"
398754,METHOD,os\unix\ngx_channel.c:<global>,TYPE_DECL,"ngx_int_t
ngx_add_channel_event(ngx_cycle_t *cycle, ngx_fd_t fd, ngx_int_t event,
    ngx_event_handler_pt handler)
{
    ngx_event_t       *ev, *rev, *wev;
    ngx_connection_t  *c;

    c = ngx_get_connection(fd, cycle->log);

    if (c == NULL) {
        return NGX_ERROR;
    }

    c->pool = cycle->pool;

    rev = c->read;
    wev = c->write;

    rev->log = cycle->log;
    wev->log = cycle->log;

    rev->channel = 1;
    wev->channel = 1;

    ev = (event == NGX_READ_EVENT) ? rev : wev;

    ev->handler = handler;

    if (ngx_add_conn && (ngx_event_flags & NGX_USE_EPOLL_EVENT) == 0) {
        if (ngx_add_conn(c) == NGX_ERROR) {
            ngx_free_connection(c);
            return NGX_ERROR;
        }

    } else {
        if (ngx_add_event(ev, event, 0) == NGX_ERROR) {
            ngx_free_connection(c);
            return NGX_ERROR;
        }
    }

    return NGX_OK;
}",1,1,os\unix\ngx_channel.c,ngx_add_channel_event,,false,198,240,ngx_add_channel_event,,,3,"ngx_int_t ngx_add_channel_event (ngx_cycle_t*,ngx_fd_t,ngx_int_t,ngx_event_handler_pt)"
398869,METHOD,os\unix\ngx_channel.c:<global>,TYPE_DECL,"void
ngx_close_channel(ngx_fd_t *fd, ngx_log_t *log)
{
    if (close(fd[0]) == -1) {
        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno, ""close() channel failed"");
    }

    if (close(fd[1]) == -1) {
        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno, ""close() channel failed"");
    }
}",1,1,os\unix\ngx_channel.c,ngx_close_channel,,false,243,253,ngx_close_channel,,,4,"void ngx_close_channel (ngx_fd_t*,ngx_log_t*)"
398912,METHOD,os\unix\ngx_channel.h:<global>,TYPE_DECL,<global>,1,37,os\unix\ngx_channel.h,os\unix\ngx_channel.h:<global>,,false,1,34,<global>,,,1,
398920,METHOD,os\unix\ngx_channel.h:<global>,TYPE_DECL,"ngx_int_t ngx_write_channel(ngx_socket_t s, ngx_channel_t *ch, size_t size,
    ngx_log_t *log);",11,19,os\unix\ngx_channel.h,ngx_write_channel,,false,25,26,ngx_write_channel,,,3,"ngx_int_t ngx_write_channel (ngx_socket_t,ngx_channel_t*,size_t,ngx_log_t*)"
398928,METHOD,os\unix\ngx_channel.h:<global>,TYPE_DECL,"ngx_int_t ngx_read_channel(ngx_socket_t s, ngx_channel_t *ch, size_t size,
    ngx_log_t *log);",11,19,os\unix\ngx_channel.h,ngx_read_channel,,false,27,28,ngx_read_channel,,,4,"ngx_int_t ngx_read_channel (ngx_socket_t,ngx_channel_t*,size_t,ngx_log_t*)"
398936,METHOD,os\unix\ngx_channel.h:<global>,TYPE_DECL,"ngx_int_t ngx_add_channel_event(ngx_cycle_t *cycle, ngx_fd_t fd,
    ngx_int_t event, ngx_event_handler_pt handler);",11,50,os\unix\ngx_channel.h,ngx_add_channel_event,,false,29,30,ngx_add_channel_event,,,5,"ngx_int_t ngx_add_channel_event (ngx_cycle_t*,ngx_fd_t,ngx_int_t,ngx_event_handler_pt)"
398944,METHOD,os\unix\ngx_channel.h:<global>,TYPE_DECL,"void ngx_close_channel(ngx_fd_t *fd, ngx_log_t *log);",6,52,os\unix\ngx_channel.h,ngx_close_channel,,false,31,31,ngx_close_channel,,,6,"void ngx_close_channel (ngx_fd_t*,ngx_log_t*)"
398957,METHOD,os\unix\ngx_daemon.c:<global>,TYPE_DECL,<global>,1,1,os\unix\ngx_daemon.c,os\unix\ngx_daemon.c:<global>,,false,1,71,<global>,,,1,
398959,METHOD,os\unix\ngx_daemon.c:<global>,TYPE_DECL,"ngx_int_t
ngx_daemon(ngx_log_t *log)
{
    int  fd;

    switch (fork()) {
    case -1:
        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno, ""fork() failed"");
        return NGX_ERROR;

    case 0:
        break;

    default:
        exit(0);
    }

    ngx_parent = ngx_pid;
    ngx_pid = ngx_getpid();

    if (setsid() == -1) {
        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno, ""setsid() failed"");
        return NGX_ERROR;
    }

    umask(0);

    fd = open(""/dev/null"", O_RDWR);
    if (fd == -1) {
        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,
                      ""open(\""/dev/null\"") failed"");
        return NGX_ERROR;
    }

    if (dup2(fd, STDIN_FILENO) == -1) {
        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno, ""dup2(STDIN) failed"");
        return NGX_ERROR;
    }

    if (dup2(fd, STDOUT_FILENO) == -1) {
        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno, ""dup2(STDOUT) failed"");
        return NGX_ERROR;
    }

#if 0
    if (dup2(fd, STDERR_FILENO) == -1) {
  ...",1,1,os\unix\ngx_daemon.c,ngx_daemon,,false,12,71,ngx_daemon,,,1,ngx_int_t ngx_daemon (ngx_log_t*)
399077,METHOD,os\unix\ngx_darwin.h:<global>,TYPE_DECL,<global>,1,36,os\unix\ngx_darwin.h,os\unix\ngx_darwin.h:<global>,,false,1,23,<global>,,,1,
399079,METHOD,os\unix\ngx_darwin.h:<global>,TYPE_DECL,void ngx_debug_init(void);,6,25,os\unix\ngx_darwin.h,ngx_debug_init,,false,12,12,ngx_debug_init,,,1,void ngx_debug_init (void)
399084,METHOD,os\unix\ngx_darwin.h:<global>,TYPE_DECL,"ngx_chain_t *ngx_darwin_sendfile_chain(ngx_connection_t *c, ngx_chain_t *in,
    off_t limit);",13,16,os\unix\ngx_darwin.h,ngx_darwin_sendfile_chain,,false,13,14,ngx_darwin_sendfile_chain,,,2,"ngx_chain_t* ngx_darwin_sendfile_chain (ngx_connection_t*,ngx_chain_t*,off_t)"
399176,METHOD,os\unix\ngx_darwin_config.h:<global>,TYPE_DECL,<global>,1,43,os\unix\ngx_darwin_config.h,os\unix\ngx_darwin_config.h:<global>,,false,1,100,<global>,,,1,
399186,METHOD,os\unix\ngx_darwin_init.c:<global>,TYPE_DECL,<global>,1,1,os\unix\ngx_darwin_init.c,os\unix\ngx_darwin_init.c:<global>,,false,1,198,<global>,,,1,
399246,METHOD,os\unix\ngx_darwin_init.c:<global>,TYPE_DECL,"void
ngx_debug_init(void)
{
#if (NGX_DEBUG_MALLOC)

    /*
     * MacOSX 10.6, 10.7:  MallocScribble fills freed memory with 0x55
     *                     and fills allocated memory with 0xAA.
     * MacOSX 10.4, 10.5:  MallocScribble fills freed memory with 0x55,
     *                     MallocPreScribble fills allocated memory with 0xAA.
     * MacOSX 10.3:        MallocScribble fills freed memory with 0x55,
     *                     and no way to fill allocated memory.
     */

    setenv(""MallocScribble"", ""1"", 0);

    ngx_debug_malloc = 1;

#else

    if (getenv(""MallocScribble"")) {
        ngx_debug_malloc = 1;
    }

#endif
}",1,1,os\unix\ngx_darwin_init.c,ngx_debug_init,,false,63,88,ngx_debug_init,,,15,void ngx_debug_init (void)
399258,METHOD,os\unix\ngx_darwin_init.c:<global>,TYPE_DECL,"ngx_int_t
ngx_os_specific_init(ngx_log_t *log)
{
    size_t      size;
    ngx_err_t   err;
    ngx_uint_t  i;

    size = sizeof(ngx_darwin_kern_ostype);
    if (sysctlbyname(""kern.ostype"", ngx_darwin_kern_ostype, &size, NULL, 0)
        == -1)
    {
        err = ngx_errno;

        if (err != NGX_ENOENT) {

            ngx_log_error(NGX_LOG_ALERT, log, err,
                          ""sysctlbyname(kern.ostype) failed"");

            if (err != NGX_ENOMEM) {
                return NGX_ERROR;
            }

            ngx_darwin_kern_ostype[size - 1] = '\0';
        }
    }

    size = sizeof(ngx_darwin_kern_osrelease);
    if (sysctlbyname(""kern.osrelease"", ngx_darwin_kern_osrelease, &size,
                     NULL, 0)
        == -1)
    {
        err = ngx_errno;

        if (err != NGX_ENOENT) {

            ngx_log_error(NGX_LOG_ALERT, log, err,
                          ""sysctlbyname(kern.osrelease) failed"");

            if (err != NGX_ENOMEM) {
                return NGX_ER...",1,1,os\unix\ngx_darwin_init.c,ngx_os_specific_init,,false,91,171,ngx_os_specific_init,,,16,ngx_int_t ngx_os_specific_init (ngx_log_t*)
399443,METHOD,os\unix\ngx_darwin_init.c:<global>,TYPE_DECL,"void
ngx_os_specific_status(ngx_log_t *log)
{
    u_long      value;
    ngx_uint_t  i;

    if (ngx_darwin_kern_ostype[0]) {
        ngx_log_error(NGX_LOG_NOTICE, log, 0, ""OS: %s %s"",
                      ngx_darwin_kern_ostype, ngx_darwin_kern_osrelease);
    }

    for (i = 0; sysctls[i].name; i++) {
        if (sysctls[i].exists) {
            if (sysctls[i].size == sizeof(long)) {
                value = *(long *) sysctls[i].value;

            } else {
                value = *(int *) sysctls[i].value;
            }

            ngx_log_error(NGX_LOG_NOTICE, log, 0, ""%s: %l"",
                          sysctls[i].name, value);
        }
    }
}",1,1,os\unix\ngx_darwin_init.c,ngx_os_specific_status,,false,174,198,ngx_os_specific_status,,,17,void ngx_os_specific_status (ngx_log_t*)
399534,METHOD,os\unix\ngx_darwin_sendfile_chain.c:<global>,TYPE_DECL,<global>,1,1,os\unix\ngx_darwin_sendfile_chain.c,os\unix\ngx_darwin_sendfile_chain.c:<global>,,false,1,206,<global>,,,1,
399536,METHOD,os\unix\ngx_darwin_sendfile_chain.c:<global>,TYPE_DECL,"ngx_chain_t *
ngx_darwin_sendfile_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)
{
    int              rc;
    off_t            send, prev_send, sent;
    off_t            file_size;
    ssize_t          n;
    ngx_uint_t       eintr;
    ngx_err_t        err;
    ngx_buf_t       *file;
    ngx_event_t     *wev;
    ngx_chain_t     *cl;
    ngx_iovec_t      header, trailer;
    struct sf_hdtr   hdtr;
    struct iovec     headers[NGX_IOVS_PREALLOCATE];
    struct iovec     trailers[NGX_IOVS_PREALLOCATE];

    wev = c->write;

    if (!wev->ready) {
        return in;
    }

#if (NGX_HAVE_KQUEUE)

    if ((ngx_event_flags & NGX_USE_KQUEUE_EVENT) && wev->pending_eof) {
        (void) ngx_connection_error(c, wev->kq_errno,
                               ""kevent() reported about an closed connection"");
        wev->error = 1;
        return NGX_CHAIN_ERROR;
    }

#endif

    /* the maximum limit size is the maximum size_t value - the page size */

    if (limit == 0 || limit ...",1,1,os\unix\ngx_darwin_sendfile_chain.c,ngx_darwin_sendfile_chain,,false,30,206,ngx_darwin_sendfile_chain,,,1,"ngx_chain_t ngx_darwin_sendfile_chain (ngx_connection_t*,ngx_chain_t*,off_t)"
399953,METHOD,os\unix\ngx_dlopen.c:<global>,TYPE_DECL,<global>,1,6,os\unix\ngx_dlopen.c,os\unix\ngx_dlopen.c:<global>,,false,1,28,<global>,,,1,
399962,METHOD,os\unix\ngx_dlopen.h:<global>,TYPE_DECL,<global>,1,36,os\unix\ngx_dlopen.h,os\unix\ngx_dlopen.h:<global>,,false,1,31,<global>,,,1,
399971,METHOD,os\unix\ngx_errno.c:<global>,TYPE_DECL,<global>,1,1,os\unix\ngx_errno.c,os\unix\ngx_errno.c:<global>,,false,1,87,<global>,,,1,
399979,METHOD,os\unix\ngx_errno.c:<global>,TYPE_DECL,"u_char *
ngx_strerror(ngx_err_t err, u_char *errstr, size_t size)
{
    ngx_str_t  *msg;

    msg = ((ngx_uint_t) err < NGX_SYS_NERR) ? &ngx_sys_errlist[err]:
                                              &ngx_unknown_error;
    size = ngx_min(size, msg->len);

    return ngx_cpymem(errstr, msg->data, size);
}",1,1,os\unix\ngx_errno.c,ngx_strerror,,false,32,42,ngx_strerror,,,4,"u_char ngx_strerror (ngx_err_t,u_char*,size_t)"
400015,METHOD,os\unix\ngx_errno.c:<global>,TYPE_DECL,"ngx_int_t
ngx_strerror_init(void)
{
    char       *msg;
    u_char     *p;
    size_t      len;
    ngx_err_t   err;

    /*
     * ngx_strerror() is not ready to work at this stage, therefore,
     * malloc() is used and possible errors are logged using strerror().
     */

    len = NGX_SYS_NERR * sizeof(ngx_str_t);

    ngx_sys_errlist = malloc(len);
    if (ngx_sys_errlist == NULL) {
        goto failed;
    }

    for (err = 0; err < NGX_SYS_NERR; err++) {
        msg = strerror(err);
        len = ngx_strlen(msg);

        p = malloc(len);
        if (p == NULL) {
            goto failed;
        }

        ngx_memcpy(p, msg, len);
        ngx_sys_errlist[err].len = len;
        ngx_sys_errlist[err].data = p;
    }

    return NGX_OK;

failed:

    err = errno;
    ngx_log_stderr(0, ""malloc(%uz) failed (%d: %s)"", len, err, strerror(err));

    return NGX_ERROR;
}",1,1,os\unix\ngx_errno.c,ngx_strerror_init,,false,45,87,ngx_strerror_init,,,5,ngx_int_t ngx_strerror_init (void)
400109,METHOD,os\unix\ngx_errno.h:<global>,TYPE_DECL,<global>,1,35,os\unix\ngx_errno.h,os\unix\ngx_errno.h:<global>,,false,1,79,<global>,,,1,
400112,METHOD,os\unix\ngx_errno.h:<global>,TYPE_DECL,"u_char *ngx_strerror(ngx_err_t err, u_char *errstr, size_t size);",8,64,os\unix\ngx_errno.h,ngx_strerror,,false,75,75,ngx_strerror,,,2,"u_char* ngx_strerror (ngx_err_t,u_char*,size_t)"
400119,METHOD,os\unix\ngx_errno.h:<global>,TYPE_DECL,ngx_int_t ngx_strerror_init(void);,11,33,os\unix\ngx_errno.h,ngx_strerror_init,,false,76,76,ngx_strerror_init,,,3,ngx_int_t ngx_strerror_init (void)
400133,METHOD,os\unix\ngx_file_aio_read.c:<global>,TYPE_DECL,<global>,1,1,os\unix\ngx_file_aio_read.c,os\unix\ngx_file_aio_read.c:<global>,,false,1,216,<global>,,,1,
400136,METHOD,os\unix\ngx_file_aio_read.c:<global>,TYPE_DECL,"static ssize_t ngx_file_aio_result(ngx_file_t *file, ngx_event_aio_t *aio,
    ngx_event_t *ev);",16,20,os\unix\ngx_file_aio_read.c,ngx_file_aio_result,,false,34,35,ngx_file_aio_result,,,2,"ssize_t ngx_file_aio_result (ngx_file_t*,ngx_event_aio_t*,ngx_event_t*)"
400143,METHOD,os\unix\ngx_file_aio_read.c:<global>,TYPE_DECL,static void ngx_file_aio_event_handler(ngx_event_t *ev);,13,55,os\unix\ngx_file_aio_read.c,ngx_file_aio_event_handler,,false,36,36,ngx_file_aio_event_handler,,,3,void ngx_file_aio_event_handler (ngx_event_t*)
400148,METHOD,os\unix\ngx_file_aio_read.c:<global>,TYPE_DECL,"ngx_int_t
ngx_file_aio_init(ngx_file_t *file, ngx_pool_t *pool)
{
    ngx_event_aio_t  *aio;

    aio = ngx_pcalloc(pool, sizeof(ngx_event_aio_t));
    if (aio == NULL) {
        return NGX_ERROR;
    }

    aio->file = file;
    aio->fd = file->fd;
    aio->event.data = aio;
    aio->event.ready = 1;
    aio->event.log = file->log;

    file->aio = aio;

    return NGX_OK;
}",1,1,os\unix\ngx_file_aio_read.c,ngx_file_aio_init,,false,39,58,ngx_file_aio_init,,,4,"ngx_int_t ngx_file_aio_init (ngx_file_t*,ngx_pool_t*)"
400210,METHOD,os\unix\ngx_file_aio_read.c:<global>,TYPE_DECL,"ssize_t
ngx_file_aio_read(ngx_file_t *file, u_char *buf, size_t size, off_t offset,
    ngx_pool_t *pool)
{
    int               n;
    ngx_event_t      *ev;
    ngx_event_aio_t  *aio;

    if (!ngx_file_aio) {
        return ngx_read_file(file, buf, size, offset);
    }

    if (file->aio == NULL && ngx_file_aio_init(file, pool) != NGX_OK) {
        return NGX_ERROR;
    }

    aio = file->aio;
    ev = &aio->event;

    if (!ev->ready) {
        ngx_log_error(NGX_LOG_ALERT, file->log, 0,
                      ""second aio post for \""%V\"""", &file->name);
        return NGX_AGAIN;
    }

    ngx_log_debug4(NGX_LOG_DEBUG_CORE, file->log, 0,
                   ""aio complete:%d @%O:%uz %V"",
                   ev->complete, offset, size, &file->name);

    if (ev->complete) {
        ev->complete = 0;
        ngx_set_errno(aio->err);

        if (aio->err == 0) {
            return aio->nbytes;
        }

        ngx_log_error(NGX_LOG_CRIT, file->log, ngx_errno,
                      ""a...",1,1,os\unix\ngx_file_aio_read.c,ngx_file_aio_read,,false,61,145,ngx_file_aio_read,,,5,"ssize_t ngx_file_aio_read (ngx_file_t*,u_char*,size_t,off_t,ngx_pool_t*)"
400461,METHOD,os\unix\ngx_file_aio_read.c:<global>,TYPE_DECL,"static ssize_t
ngx_file_aio_result(ngx_file_t *file, ngx_event_aio_t *aio, ngx_event_t *ev)
{
    int        n;
    ngx_err_t  err;

    n = aio_error(&aio->aiocb);

    ngx_log_debug2(NGX_LOG_DEBUG_CORE, file->log, 0,
                   ""aio_error: fd:%d %d"", file->fd, n);

    if (n == -1) {
        err = ngx_errno;
        aio->err = err;

        ngx_log_error(NGX_LOG_ALERT, file->log, err,
                      ""aio_error(\""%V\"") failed"", &file->name);
        return NGX_ERROR;
    }

    if (n == NGX_EINPROGRESS) {
        if (ev->ready) {
            ev->ready = 0;
            ngx_log_error(NGX_LOG_ALERT, file->log, n,
                          ""aio_read(\""%V\"") still in progress"",
                          &file->name);
        }

        return NGX_AGAIN;
    }

    n = aio_return(&aio->aiocb);

    if (n == -1) {
        err = ngx_errno;
        aio->err = err;
        ev->ready = 1;

        ngx_log_error(NGX_LOG_CRIT, file->log, err,
                      ""aio_return(\""%...",1,1,os\unix\ngx_file_aio_read.c,ngx_file_aio_result,,false,148,200,ngx_file_aio_result,,,6,"ssize_t ngx_file_aio_result (ngx_file_t*,ngx_event_aio_t*,ngx_event_t*)"
400615,METHOD,os\unix\ngx_file_aio_read.c:<global>,TYPE_DECL,"static void
ngx_file_aio_event_handler(ngx_event_t *ev)
{
    ngx_event_aio_t  *aio;

    aio = ev->data;

    ngx_log_debug2(NGX_LOG_DEBUG_CORE, ev->log, 0,
                   ""aio event handler fd:%d %V"", aio->fd, &aio->file->name);

    if (ngx_file_aio_result(aio->file, aio, ev) != NGX_AGAIN) {
        aio->handler(ev);
    }
}",1,1,os\unix\ngx_file_aio_read.c,ngx_file_aio_event_handler,,false,203,216,ngx_file_aio_event_handler,,,7,void ngx_file_aio_event_handler (ngx_event_t*)
400666,METHOD,os\unix\ngx_files.c:<global>,TYPE_DECL,<global>,1,6,os\unix\ngx_files.c,os\unix\ngx_files.c:<global>,,false,1,907,<global>,,,1,
400668,METHOD,os\unix\ngx_files.c:<global>,TYPE_DECL,"static ngx_chain_t *ngx_chain_to_iovec(ngx_iovec_t *vec, ngx_chain_t *cl);",20,73,os\unix\ngx_files.c,ngx_chain_to_iovec,,false,18,18,ngx_chain_to_iovec,,,1,"ngx_chain_t* ngx_chain_to_iovec (ngx_iovec_t*,ngx_chain_t*)"
400674,METHOD,os\unix\ngx_files.c:<global>,TYPE_DECL,"static ssize_t ngx_writev_file(ngx_file_t *file, ngx_iovec_t *vec,
    off_t offset);",16,17,os\unix\ngx_files.c,ngx_writev_file,,false,19,20,ngx_writev_file,,,2,"ssize_t ngx_writev_file (ngx_file_t*,ngx_iovec_t*,off_t)"
400681,METHOD,os\unix\ngx_files.c:<global>,TYPE_DECL,"ssize_t
ngx_read_file(ngx_file_t *file, u_char *buf, size_t size, off_t offset)
{
    ssize_t  n;

    ngx_log_debug4(NGX_LOG_DEBUG_CORE, file->log, 0,
                   ""read: %d, %p, %uz, %O"", file->fd, buf, size, offset);

#if (NGX_HAVE_PREAD)

    n = pread(file->fd, buf, size, offset);

    if (n == -1) {
        ngx_log_error(NGX_LOG_CRIT, file->log, ngx_errno,
                      ""pread() \""%s\"" failed"", file->name.data);
        return NGX_ERROR;
    }

#else

    if (file->sys_offset != offset) {
        if (lseek(file->fd, offset, SEEK_SET) == -1) {
            ngx_log_error(NGX_LOG_CRIT, file->log, ngx_errno,
                          ""lseek() \""%s\"" failed"", file->name.data);
            return NGX_ERROR;
        }

        file->sys_offset = offset;
    }

    n = read(file->fd, buf, size);

    if (n == -1) {
        ngx_log_error(NGX_LOG_CRIT, file->log, ngx_errno,
                      ""read() \""%s\"" failed"", file->name.data);
        return NGX_ERROR;
    }

    ...",1,1,os\unix\ngx_files.c,ngx_read_file,,false,30,75,ngx_read_file,,,3,"ssize_t ngx_read_file (ngx_file_t*,u_char*,size_t,off_t)"
400780,METHOD,os\unix\ngx_files.c:<global>,TYPE_DECL,"ssize_t
ngx_write_file(ngx_file_t *file, u_char *buf, size_t size, off_t offset)
{
    ssize_t    n, written;
    ngx_err_t  err;

    ngx_log_debug4(NGX_LOG_DEBUG_CORE, file->log, 0,
                   ""write: %d, %p, %uz, %O"", file->fd, buf, size, offset);

    written = 0;

#if (NGX_HAVE_PWRITE)

    for ( ;; ) {
        n = pwrite(file->fd, buf + written, size, offset);

        if (n == -1) {
            err = ngx_errno;

            if (err == NGX_EINTR) {
                ngx_log_debug0(NGX_LOG_DEBUG_CORE, file->log, err,
                               ""pwrite() was interrupted"");
                continue;
            }

            ngx_log_error(NGX_LOG_CRIT, file->log, err,
                          ""pwrite() \""%s\"" failed"", file->name.data);
            return NGX_ERROR;
        }

        file->offset += n;
        written += n;

        if ((size_t) n == size) {
            return written;
        }

        offset += n;
        size -= n;
    }

#else

    if (file->sys_...",1,1,os\unix\ngx_files.c,ngx_write_file,,false,192,273,ngx_write_file,,,4,"ssize_t ngx_write_file (ngx_file_t*,u_char*,size_t,off_t)"
400918,METHOD,os\unix\ngx_files.c:<global>,TYPE_DECL,"ngx_fd_t
ngx_open_tempfile(u_char *name, ngx_uint_t persistent, ngx_uint_t access)
{
    ngx_fd_t  fd;

    fd = open((const char *) name, O_CREAT|O_EXCL|O_RDWR,
              access ? access : 0600);

    if (fd != -1 && !persistent) {
        (void) unlink((const char *) name);
    }

    return fd;
}",1,1,os\unix\ngx_files.c,ngx_open_tempfile,,false,276,289,ngx_open_tempfile,,,5,"ngx_fd_t ngx_open_tempfile (u_char*,ngx_uint_t,ngx_uint_t)"
400958,METHOD,os\unix\ngx_files.c:<global>,TYPE_DECL,"ssize_t
ngx_write_chain_to_file(ngx_file_t *file, ngx_chain_t *cl, off_t offset,
    ngx_pool_t *pool)
{
    ssize_t        total, n;
    ngx_iovec_t    vec;
    struct iovec   iovs[NGX_IOVS_PREALLOCATE];

    /* use pwrite() if there is the only buf in a chain */

    if (cl->next == NULL) {
        return ngx_write_file(file, cl->buf->pos,
                              (size_t) (cl->buf->last - cl->buf->pos),
                              offset);
    }

    total = 0;

    vec.iovs = iovs;
    vec.nalloc = NGX_IOVS_PREALLOCATE;

    do {
        /* create the iovec and coalesce the neighbouring bufs */
        cl = ngx_chain_to_iovec(&vec, cl);

        /* use pwrite() if there is the only iovec buffer */

        if (vec.count == 1) {
            n = ngx_write_file(file, (u_char *) iovs[0].iov_base,
                               iovs[0].iov_len, offset);

            if (n == NGX_ERROR) {
                return n;
            }

            return total + n;
        }

        ...",1,1,os\unix\ngx_files.c,ngx_write_chain_to_file,,false,292,342,ngx_write_chain_to_file,,,6,"ssize_t ngx_write_chain_to_file (ngx_file_t*,ngx_chain_t*,off_t,ngx_pool_t*)"
401077,METHOD,os\unix\ngx_files.c:<global>,TYPE_DECL,"static ngx_chain_t *
ngx_chain_to_iovec(ngx_iovec_t *vec, ngx_chain_t *cl)
{
    size_t         total, size;
    u_char        *prev;
    ngx_uint_t     n;
    struct iovec  *iov;

    iov = NULL;
    prev = NULL;
    total = 0;
    n = 0;

    for ( /* void */ ; cl; cl = cl->next) {

        if (ngx_buf_special(cl->buf)) {
            continue;
        }

        size = cl->buf->last - cl->buf->pos;

        if (prev == cl->buf->pos) {
            iov->iov_len += size;

        } else {
            if (n == vec->nalloc) {
                break;
            }

            iov = &vec->iovs[n++];

            iov->iov_base = (void *) cl->buf->pos;
            iov->iov_len = size;
        }

        prev = cl->buf->pos + size;
        total += size;
    }

    vec->count = n;
    vec->size = total;

    return cl;
}",1,1,os\unix\ngx_files.c,ngx_chain_to_iovec,,false,345,388,ngx_chain_to_iovec,,,7,"ngx_chain_t ngx_chain_to_iovec (ngx_iovec_t*,ngx_chain_t*)"
401202,METHOD,os\unix\ngx_files.c:<global>,TYPE_DECL,"static ssize_t
ngx_writev_file(ngx_file_t *file, ngx_iovec_t *vec, off_t offset)
{
    ssize_t    n;
    ngx_err_t  err;

    ngx_log_debug3(NGX_LOG_DEBUG_CORE, file->log, 0,
                   ""writev: %d, %uz, %O"", file->fd, vec->size, offset);

#if (NGX_HAVE_PWRITEV)

eintr:

    n = pwritev(file->fd, vec->iovs, vec->count, offset);

    if (n == -1) {
        err = ngx_errno;

        if (err == NGX_EINTR) {
            ngx_log_debug0(NGX_LOG_DEBUG_CORE, file->log, err,
                           ""pwritev() was interrupted"");
            goto eintr;
        }

        ngx_log_error(NGX_LOG_CRIT, file->log, err,
                      ""pwritev() \""%s\"" failed"", file->name.data);
        return NGX_ERROR;
    }

    if ((size_t) n != vec->size) {
        ngx_log_error(NGX_LOG_CRIT, file->log, 0,
                      ""pwritev() \""%s\"" has written only %z of %uz"",
                      file->name.data, n, vec->size);
        return NGX_ERROR;
    }

#else

    if (file->sys_offset !...",1,1,os\unix\ngx_files.c,ngx_writev_file,,false,391,471,ngx_writev_file,,,8,"ssize_t ngx_writev_file (ngx_file_t*,ngx_iovec_t*,off_t)"
401350,METHOD,os\unix\ngx_files.c:<global>,TYPE_DECL,"ngx_int_t
ngx_set_file_time(u_char *name, ngx_fd_t fd, time_t s)
{
    struct timeval  tv[2];

    tv[0].tv_sec = ngx_time();
    tv[0].tv_usec = 0;
    tv[1].tv_sec = s;
    tv[1].tv_usec = 0;

    if (utimes((char *) name, tv) != -1) {
        return NGX_OK;
    }

    return NGX_ERROR;
}",1,1,os\unix\ngx_files.c,ngx_set_file_time,,false,600,615,ngx_set_file_time,,,9,"ngx_int_t ngx_set_file_time (u_char*,ngx_fd_t,time_t)"
401400,METHOD,os\unix\ngx_files.c:<global>,TYPE_DECL,"ngx_int_t
ngx_create_file_mapping(ngx_file_mapping_t *fm)
{
    fm->fd = ngx_open_file(fm->name, NGX_FILE_RDWR, NGX_FILE_TRUNCATE,
                           NGX_FILE_DEFAULT_ACCESS);

    if (fm->fd == NGX_INVALID_FILE) {
        ngx_log_error(NGX_LOG_CRIT, fm->log, ngx_errno,
                      ngx_open_file_n "" \""%s\"" failed"", fm->name);
        return NGX_ERROR;
    }

    if (ftruncate(fm->fd, fm->size) == -1) {
        ngx_log_error(NGX_LOG_CRIT, fm->log, ngx_errno,
                      ""ftruncate() \""%s\"" failed"", fm->name);
        goto failed;
    }

    fm->addr = mmap(NULL, fm->size, PROT_READ|PROT_WRITE, MAP_SHARED,
                    fm->fd, 0);
    if (fm->addr != MAP_FAILED) {
        return NGX_OK;
    }

    ngx_log_error(NGX_LOG_CRIT, fm->log, ngx_errno,
                  ""mmap(%uz) \""%s\"" failed"", fm->size, fm->name);

failed:

    if (ngx_close_file(fm->fd) == NGX_FILE_ERROR) {
        ngx_log_error(NGX_LOG_ALERT, fm->log, ngx_errno,
                      ng...",1,1,os\unix\ngx_files.c,ngx_create_file_mapping,,false,618,653,ngx_create_file_mapping,,,10,ngx_int_t ngx_create_file_mapping (ngx_file_mapping_t*)
401500,METHOD,os\unix\ngx_files.c:<global>,TYPE_DECL,"void
ngx_close_file_mapping(ngx_file_mapping_t *fm)
{
    if (munmap(fm->addr, fm->size) == -1) {
        ngx_log_error(NGX_LOG_CRIT, fm->log, ngx_errno,
                      ""munmap(%uz) \""%s\"" failed"", fm->size, fm->name);
    }

    if (ngx_close_file(fm->fd) == NGX_FILE_ERROR) {
        ngx_log_error(NGX_LOG_ALERT, fm->log, ngx_errno,
                      ngx_close_file_n "" \""%s\"" failed"", fm->name);
    }
}",1,1,os\unix\ngx_files.c,ngx_close_file_mapping,,false,656,668,ngx_close_file_mapping,,,11,void ngx_close_file_mapping (ngx_file_mapping_t*)
401539,METHOD,os\unix\ngx_files.c:<global>,TYPE_DECL,"ngx_int_t
ngx_open_dir(ngx_str_t *name, ngx_dir_t *dir)
{
    dir->dir = opendir((const char *) name->data);

    if (dir->dir == NULL) {
        return NGX_ERROR;
    }

    dir->valid_info = 0;

    return NGX_OK;
}",1,1,os\unix\ngx_files.c,ngx_open_dir,,false,671,683,ngx_open_dir,,,12,"ngx_int_t ngx_open_dir (ngx_str_t*,ngx_dir_t*)"
401571,METHOD,os\unix\ngx_files.c:<global>,TYPE_DECL,"ngx_int_t
ngx_read_dir(ngx_dir_t *dir)
{
    dir->de = readdir(dir->dir);

    if (dir->de) {
#if (NGX_HAVE_D_TYPE)
        dir->type = dir->de->d_type;
#else
        dir->type = 0;
#endif
        return NGX_OK;
    }

    return NGX_ERROR;
}",1,1,os\unix\ngx_files.c,ngx_read_dir,,false,686,701,ngx_read_dir,,,13,ngx_int_t ngx_read_dir (ngx_dir_t*)
401598,METHOD,os\unix\ngx_files.c:<global>,TYPE_DECL,"ngx_int_t
ngx_open_glob(ngx_glob_t *gl)
{
    int  n;

    n = glob((char *) gl->pattern, 0, NULL, &gl->pglob);

    if (n == 0) {
        return NGX_OK;
    }

#ifdef GLOB_NOMATCH

    if (n == GLOB_NOMATCH && gl->test) {
        return NGX_OK;
    }

#endif

    return NGX_ERROR;
}",1,1,os\unix\ngx_files.c,ngx_open_glob,,false,704,724,ngx_open_glob,,,14,ngx_int_t ngx_open_glob (ngx_glob_t*)
401627,METHOD,os\unix\ngx_files.c:<global>,TYPE_DECL,"ngx_int_t
ngx_read_glob(ngx_glob_t *gl, ngx_str_t *name)
{
    size_t  count;

#ifdef GLOB_NOMATCH
    count = (size_t) gl->pglob.gl_pathc;
#else
    count = (size_t) gl->pglob.gl_matchc;
#endif

    if (gl->n < count) {

        name->len = (size_t) ngx_strlen(gl->pglob.gl_pathv[gl->n]);
        name->data = (u_char *) gl->pglob.gl_pathv[gl->n];
        gl->n++;

        return NGX_OK;
    }

    return NGX_DONE;
}",1,1,os\unix\ngx_files.c,ngx_read_glob,,false,727,748,ngx_read_glob,,,15,"ngx_int_t ngx_read_glob (ngx_glob_t*,ngx_str_t*)"
401689,METHOD,os\unix\ngx_files.c:<global>,TYPE_DECL,"void
ngx_close_glob(ngx_glob_t *gl)
{
    globfree(&gl->pglob);
}",1,1,os\unix\ngx_files.c,ngx_close_glob,,false,751,755,ngx_close_glob,,,16,void ngx_close_glob (ngx_glob_t*)
401699,METHOD,os\unix\ngx_files.c:<global>,TYPE_DECL,"ngx_err_t
ngx_trylock_fd(ngx_fd_t fd)
{
    struct flock  fl;

    ngx_memzero(&fl, sizeof(struct flock));
    fl.l_type = F_WRLCK;
    fl.l_whence = SEEK_SET;

    if (fcntl(fd, F_SETLK, &fl) == -1) {
        return ngx_errno;
    }

    return 0;
}",1,1,os\unix\ngx_files.c,ngx_trylock_fd,,false,758,772,ngx_trylock_fd,,,17,ngx_err_t ngx_trylock_fd (ngx_fd_t)
401734,METHOD,os\unix\ngx_files.c:<global>,TYPE_DECL,"ngx_err_t
ngx_lock_fd(ngx_fd_t fd)
{
    struct flock  fl;

    ngx_memzero(&fl, sizeof(struct flock));
    fl.l_type = F_WRLCK;
    fl.l_whence = SEEK_SET;

    if (fcntl(fd, F_SETLKW, &fl) == -1) {
        return ngx_errno;
    }

    return 0;
}",1,1,os\unix\ngx_files.c,ngx_lock_fd,,false,775,789,ngx_lock_fd,,,18,ngx_err_t ngx_lock_fd (ngx_fd_t)
401769,METHOD,os\unix\ngx_files.c:<global>,TYPE_DECL,"ngx_err_t
ngx_unlock_fd(ngx_fd_t fd)
{
    struct flock  fl;

    ngx_memzero(&fl, sizeof(struct flock));
    fl.l_type = F_UNLCK;
    fl.l_whence = SEEK_SET;

    if (fcntl(fd, F_SETLK, &fl) == -1) {
        return  ngx_errno;
    }

    return 0;
}",1,1,os\unix\ngx_files.c,ngx_unlock_fd,,false,792,806,ngx_unlock_fd,,,19,ngx_err_t ngx_unlock_fd (ngx_fd_t)
401804,METHOD,os\unix\ngx_files.c:<global>,TYPE_DECL,"size_t
ngx_fs_bsize(u_char *name)
{
    return 512;
}",1,1,os\unix\ngx_files.c,ngx_fs_bsize,,false,901,905,ngx_fs_bsize,,,20,size_t ngx_fs_bsize (u_char*)
401818,METHOD,os\unix\ngx_files.h:<global>,TYPE_DECL,<global>,1,35,os\unix\ngx_files.h,os\unix\ngx_files.h:<global>,,false,1,392,<global>,,,1,
401847,METHOD,os\unix\ngx_files.h:<global>,TYPE_DECL,"ngx_fd_t ngx_open_tempfile(u_char *name, ngx_uint_t persistent,
    ngx_uint_t access);",10,22,os\unix\ngx_files.h,ngx_open_tempfile,,false,117,118,ngx_open_tempfile,,,11,"ngx_fd_t ngx_open_tempfile (u_char*,ngx_uint_t,ngx_uint_t)"
401854,METHOD,os\unix\ngx_files.h:<global>,TYPE_DECL,"ssize_t ngx_read_file(ngx_file_t *file, u_char *buf, size_t size, off_t offset);",9,79,os\unix\ngx_files.h,ngx_read_file,,false,122,122,ngx_read_file,,,12,"ssize_t ngx_read_file (ngx_file_t*,u_char*,size_t,off_t)"
401862,METHOD,os\unix\ngx_files.h:<global>,TYPE_DECL,"ssize_t ngx_write_file(ngx_file_t *file, u_char *buf, size_t size,
    off_t offset);",9,17,os\unix\ngx_files.h,ngx_write_file,,false,129,130,ngx_write_file,,,13,"ssize_t ngx_write_file (ngx_file_t*,u_char*,size_t,off_t)"
401870,METHOD,os\unix\ngx_files.h:<global>,TYPE_DECL,"ssize_t ngx_write_chain_to_file(ngx_file_t *file, ngx_chain_t *ce,
    off_t offset, ngx_pool_t *pool);",9,35,os\unix\ngx_files.h,ngx_write_chain_to_file,,false,132,133,ngx_write_chain_to_file,,,14,"ssize_t ngx_write_chain_to_file (ngx_file_t*,ngx_chain_t*,off_t,ngx_pool_t*)"
401880,METHOD,os\unix\ngx_files.h:<global>,TYPE_DECL,"ngx_write_fd(ngx_fd_t fd, void *buf, size_t n)
{
    return write(fd, buf, n);
}",1,1,os\unix\ngx_files.h,ngx_write_fd,,false,145,148,ngx_write_fd,,,17,"ANY ngx_write_fd (ngx_fd_t,void*,size_t)"
401892,METHOD,os\unix\ngx_files.h:<global>,TYPE_DECL,"ngx_int_t ngx_set_file_time(u_char *name, ngx_fd_t fd, time_t s);",11,64,os\unix\ngx_files.h,ngx_set_file_time,,false,169,169,ngx_set_file_time,,,18,"ngx_int_t ngx_set_file_time (u_char*,ngx_fd_t,time_t)"
401899,METHOD,os\unix\ngx_files.h:<global>,TYPE_DECL,ngx_int_t ngx_create_file_mapping(ngx_file_mapping_t *fm);,11,57,os\unix\ngx_files.h,ngx_create_file_mapping,,false,193,193,ngx_create_file_mapping,,,19,ngx_int_t ngx_create_file_mapping (ngx_file_mapping_t*)
401904,METHOD,os\unix\ngx_files.h:<global>,TYPE_DECL,void ngx_close_file_mapping(ngx_file_mapping_t *fm);,6,51,os\unix\ngx_files.h,ngx_close_file_mapping,,false,194,194,ngx_close_file_mapping,,,20,void ngx_close_file_mapping (ngx_file_mapping_t*)
401909,METHOD,os\unix\ngx_files.h:<global>,TYPE_DECL,"ngx_int_t ngx_open_dir(ngx_str_t *name, ngx_dir_t *dir);",11,55,os\unix\ngx_files.h,ngx_open_dir,,false,216,216,ngx_open_dir,,,21,"ngx_int_t ngx_open_dir (ngx_str_t*,ngx_dir_t*)"
401915,METHOD,os\unix\ngx_files.h:<global>,TYPE_DECL,ngx_int_t ngx_read_dir(ngx_dir_t *dir);,11,38,os\unix\ngx_files.h,ngx_read_dir,,false,224,224,ngx_read_dir,,,22,ngx_int_t ngx_read_dir (ngx_dir_t*)
401922,METHOD,os\unix\ngx_files.h:<global>,TYPE_DECL,"ngx_de_info(u_char *name, ngx_dir_t *dir)
{
    dir->type = 0;
    return stat((const char *) name, &dir->info);
}",1,1,os\unix\ngx_files.h,ngx_de_info,,false,247,251,ngx_de_info,,,25,"ANY ngx_de_info (u_char*,ngx_dir_t*)"
401942,METHOD,os\unix\ngx_files.h:<global>,TYPE_DECL,ngx_int_t ngx_open_glob(ngx_glob_t *gl);,11,39,os\unix\ngx_files.h,ngx_open_glob,,false,286,286,ngx_open_glob,,,26,ngx_int_t ngx_open_glob (ngx_glob_t*)
401947,METHOD,os\unix\ngx_files.h:<global>,TYPE_DECL,"ngx_int_t ngx_read_glob(ngx_glob_t *gl, ngx_str_t *name);",11,56,os\unix\ngx_files.h,ngx_read_glob,,false,288,288,ngx_read_glob,,,27,"ngx_int_t ngx_read_glob (ngx_glob_t*,ngx_str_t*)"
401953,METHOD,os\unix\ngx_files.h:<global>,TYPE_DECL,void ngx_close_glob(ngx_glob_t *gl);,6,35,os\unix\ngx_files.h,ngx_close_glob,,false,289,289,ngx_close_glob,,,28,void ngx_close_glob (ngx_glob_t*)
401958,METHOD,os\unix\ngx_files.h:<global>,TYPE_DECL,ngx_err_t ngx_trylock_fd(ngx_fd_t fd);,11,37,os\unix\ngx_files.h,ngx_trylock_fd,,false,292,292,ngx_trylock_fd,,,29,ngx_err_t ngx_trylock_fd (ngx_fd_t)
401963,METHOD,os\unix\ngx_files.h:<global>,TYPE_DECL,ngx_err_t ngx_lock_fd(ngx_fd_t fd);,11,34,os\unix\ngx_files.h,ngx_lock_fd,,false,293,293,ngx_lock_fd,,,30,ngx_err_t ngx_lock_fd (ngx_fd_t)
401968,METHOD,os\unix\ngx_files.h:<global>,TYPE_DECL,ngx_err_t ngx_unlock_fd(ngx_fd_t fd);,11,36,os\unix\ngx_files.h,ngx_unlock_fd,,false,294,294,ngx_unlock_fd,,,31,ngx_err_t ngx_unlock_fd (ngx_fd_t)
401973,METHOD,os\unix\ngx_files.h:<global>,TYPE_DECL,size_t ngx_fs_bsize(u_char *name);,8,33,os\unix\ngx_files.h,ngx_fs_bsize,,false,348,348,ngx_fs_bsize,,,32,size_t ngx_fs_bsize (u_char*)
401981,METHOD,os\unix\ngx_freebsd.h:<global>,TYPE_DECL,<global>,1,37,os\unix\ngx_freebsd.h,os\unix\ngx_freebsd.h:<global>,,false,1,25,<global>,,,1,
401983,METHOD,os\unix\ngx_freebsd.h:<global>,TYPE_DECL,void ngx_debug_init(void);,6,25,os\unix\ngx_freebsd.h,ngx_debug_init,,false,12,12,ngx_debug_init,,,1,void ngx_debug_init (void)
401988,METHOD,os\unix\ngx_freebsd.h:<global>,TYPE_DECL,"ngx_chain_t *ngx_freebsd_sendfile_chain(ngx_connection_t *c, ngx_chain_t *in,
    off_t limit);",13,16,os\unix\ngx_freebsd.h,ngx_freebsd_sendfile_chain,,false,13,14,ngx_freebsd_sendfile_chain,,,2,"ngx_chain_t* ngx_freebsd_sendfile_chain (ngx_connection_t*,ngx_chain_t*,off_t)"
402086,METHOD,os\unix\ngx_freebsd_config.h:<global>,TYPE_DECL,<global>,1,44,os\unix\ngx_freebsd_config.h,os\unix\ngx_freebsd_config.h:<global>,,false,1,129,<global>,,,1,
402097,METHOD,os\unix\ngx_freebsd_init.c:<global>,TYPE_DECL,<global>,1,1,os\unix\ngx_freebsd_init.c,os\unix\ngx_freebsd_init.c:<global>,,false,1,262,<global>,,,1,
402168,METHOD,os\unix\ngx_freebsd_init.c:<global>,TYPE_DECL,"void
ngx_debug_init(void)
{
#if (NGX_DEBUG_MALLOC)

#if __FreeBSD_version >= 500014 && __FreeBSD_version < 1000011
    _malloc_options = ""J"";
#elif __FreeBSD_version < 500014
    malloc_options = ""J"";
#endif

    ngx_debug_malloc = 1;

#else
    char  *mo;

    mo = getenv(""MALLOC_OPTIONS"");

    if (mo && ngx_strchr(mo, 'J')) {
        ngx_debug_malloc = 1;
    }
#endif
}",1,1,os\unix\ngx_freebsd_init.c,ngx_debug_init,,false,76,98,ngx_debug_init,,,19,void ngx_debug_init (void)
402188,METHOD,os\unix\ngx_freebsd_init.c:<global>,TYPE_DECL,"ngx_int_t
ngx_os_specific_init(ngx_log_t *log)
{
    int         version;
    size_t      size;
    ngx_err_t   err;
    ngx_uint_t  i;

    size = sizeof(ngx_freebsd_kern_ostype);
    if (sysctlbyname(""kern.ostype"",
                     ngx_freebsd_kern_ostype, &size, NULL, 0) == -1) {
        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,
                      ""sysctlbyname(kern.ostype) failed"");

        if (ngx_errno != NGX_ENOMEM) {
            return NGX_ERROR;
        }

        ngx_freebsd_kern_ostype[size - 1] = '\0';
    }

    size = sizeof(ngx_freebsd_kern_osrelease);
    if (sysctlbyname(""kern.osrelease"",
                     ngx_freebsd_kern_osrelease, &size, NULL, 0) == -1) {
        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,
                      ""sysctlbyname(kern.osrelease) failed"");

        if (ngx_errno != NGX_ENOMEM) {
            return NGX_ERROR;
        }

        ngx_freebsd_kern_osrelease[size - 1] = '\0';
    }


    size = sizeof(int);
    if (sysctlbyna...",1,1,os\unix\ngx_freebsd_init.c,ngx_os_specific_init,,false,101,227,ngx_os_specific_init,,,20,ngx_int_t ngx_os_specific_init (ngx_log_t*)
402415,METHOD,os\unix\ngx_freebsd_init.c:<global>,TYPE_DECL,"void
ngx_os_specific_status(ngx_log_t *log)
{
    u_long      value;
    ngx_uint_t  i;

    ngx_log_error(NGX_LOG_NOTICE, log, 0, ""OS: %s %s"",
                  ngx_freebsd_kern_ostype, ngx_freebsd_kern_osrelease);

#ifdef __DragonFly_version
    ngx_log_error(NGX_LOG_NOTICE, log, 0,
                  ""kern.osreldate: %d, built on %d"",
                  ngx_freebsd_kern_osreldate, __DragonFly_version);
#else
    ngx_log_error(NGX_LOG_NOTICE, log, 0,
                  ""kern.osreldate: %d, built on %d"",
                  ngx_freebsd_kern_osreldate, __FreeBSD_version);
#endif

    for (i = 0; sysctls[i].name; i++) {
        if (sysctls[i].exists) {
            if (sysctls[i].size == sizeof(long)) {
                value = *(long *) sysctls[i].value;

            } else {
                value = *(int *) sysctls[i].value;
            }

            ngx_log_error(NGX_LOG_NOTICE, log, 0, ""%s: %l"",
                          sysctls[i].name, value);
        }
    }
}",1,1,os\unix\ngx_freebsd_init.c,ngx_os_specific_status,,false,230,262,ngx_os_specific_status,,,21,void ngx_os_specific_status (ngx_log_t*)
402508,METHOD,os\unix\ngx_freebsd_sendfile_chain.c:<global>,TYPE_DECL,<global>,1,1,os\unix\ngx_freebsd_sendfile_chain.c,os\unix\ngx_freebsd_sendfile_chain.c:<global>,,false,1,333,<global>,,,1,
402510,METHOD,os\unix\ngx_freebsd_sendfile_chain.c:<global>,TYPE_DECL,"ngx_chain_t *
ngx_freebsd_sendfile_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)
{
    int               rc, flags;
    off_t             send, prev_send, sent;
    size_t            file_size;
    ssize_t           n;
    ngx_uint_t        eintr, eagain;
    ngx_err_t         err;
    ngx_buf_t        *file;
    ngx_event_t      *wev;
    ngx_chain_t      *cl;
    ngx_iovec_t       header, trailer;
    struct sf_hdtr    hdtr;
    struct iovec      headers[NGX_IOVS_PREALLOCATE];
    struct iovec      trailers[NGX_IOVS_PREALLOCATE];
#if (NGX_HAVE_AIO_SENDFILE)
    ngx_uint_t        ebusy;
    ngx_event_aio_t  *aio;
#endif

    wev = c->write;

    if (!wev->ready) {
        return in;
    }

#if (NGX_HAVE_KQUEUE)

    if ((ngx_event_flags & NGX_USE_KQUEUE_EVENT) && wev->pending_eof) {
        (void) ngx_connection_error(c, wev->kq_errno,
                               ""kevent() reported about an closed connection"");
        wev->error = 1;
        return NGX_CHAIN_ERROR;
 ...",1,1,os\unix\ngx_freebsd_sendfile_chain.c,ngx_freebsd_sendfile_chain,,false,32,333,ngx_freebsd_sendfile_chain,,,1,"ngx_chain_t ngx_freebsd_sendfile_chain (ngx_connection_t*,ngx_chain_t*,off_t)"
402989,METHOD,os\unix\ngx_gcc_atomic_amd64.h:<global>,TYPE_DECL,<global>,1,9,os\unix\ngx_gcc_atomic_amd64.h,os\unix\ngx_gcc_atomic_amd64.h:<global>,,false,1,82,<global>,,,1,
402993,METHOD,os\unix\ngx_gcc_atomic_amd64.h:<global>,TYPE_DECL,"ngx_atomic_cmp_set(ngx_atomic_t *lock, ngx_atomic_uint_t old,
    ngx_atomic_uint_t set)
{
    u_char  res;

    __asm__ volatile (

         NGX_SMP_LOCK
    ""    cmpxchgq  %3, %1;   ""
    ""    sete      %0;       ""

    : ""=a"" (res) : ""m"" (*lock), ""a"" (old), ""r"" (set) : ""cc"", ""memory"");

    return res;
}",1,9,os\unix\ngx_gcc_atomic_amd64.h,ngx_atomic_cmp_set,,false,37,51,ngx_atomic_cmp_set,,,3,"ANY ngx_atomic_cmp_set (ngx_atomic_t*,ngx_atomic_uint_t,ngx_atomic_uint_t)"
403006,METHOD,os\unix\ngx_gcc_atomic_amd64.h:<global>,TYPE_DECL,"ngx_atomic_fetch_add(ngx_atomic_t *value, ngx_atomic_int_t add)
{
    __asm__ volatile (

         NGX_SMP_LOCK
    ""    xaddq  %0, %1;   ""

    : ""+r"" (add) : ""m"" (*value) : ""cc"", ""memory"");

    return add;
}",1,9,os\unix\ngx_gcc_atomic_amd64.h,ngx_atomic_fetch_add,,false,67,77,ngx_atomic_fetch_add,,,6,"ANY ngx_atomic_fetch_add (ngx_atomic_t*,ngx_atomic_int_t)"
403018,METHOD,os\unix\ngx_gcc_atomic_ppc.h:<global>,TYPE_DECL,<global>,1,23,os\unix\ngx_gcc_atomic_ppc.h,os\unix\ngx_gcc_atomic_ppc.h:<global>,,false,1,155,<global>,,,1,
403022,METHOD,os\unix\ngx_gcc_atomic_ppc.h:<global>,TYPE_DECL,"ngx_atomic_cmp_set(ngx_atomic_t *lock, ngx_atomic_uint_t old,
    ngx_atomic_uint_t set)
{
    ngx_atomic_uint_t  res, temp;

    __asm__ volatile (

    ""    li      %0, 0       \n"" /* preset ""0"" to ""res""                      */
    ""    eieio               \n"" /* write barrier                            */
    ""1:                      \n""
    ""    lwarx   %1, 0, %2   \n"" /* load from [lock] into ""temp""             */
                                 /*   and store reservation                  */
    ""    cmpw    %1, %3      \n"" /* compare ""temp"" and ""old""                 */
    ""    bne-    2f          \n"" /* not equal                                */
    ""    stwcx.  %4, 0, %2   \n"" /* store ""set"" into [lock] if reservation   */
                                 /*   is not cleared                         */
    ""    bne-    1b          \n"" /* the reservation was cleared              */
    ""    isync               \n"" /* read barrier                             */
    ""    li   ...",1,1,os\unix\ngx_gcc_atomic_ppc.h,ngx_atomic_cmp_set,,false,92,118,ngx_atomic_cmp_set,,,3,"ANY ngx_atomic_cmp_set (ngx_atomic_t*,ngx_atomic_uint_t,ngx_atomic_uint_t)"
403036,METHOD,os\unix\ngx_gcc_atomic_ppc.h:<global>,TYPE_DECL,"ngx_atomic_fetch_add(ngx_atomic_t *value, ngx_atomic_int_t add)
{
    ngx_atomic_uint_t  res, temp;

    __asm__ volatile (

    ""    eieio               \n"" /* write barrier                            */
    ""1:  lwarx   %0, 0, %2   \n"" /* load from [value] into ""res""             */
                                 /*   and store reservation                  */
    ""    add     %1, %0, %3  \n"" /* ""res"" + ""add"" store in ""temp""            */
    ""    stwcx.  %1, 0, %2   \n"" /* store ""temp"" into [value] if reservation */
                                 /*   is not cleared                         */
    ""    bne-    1b          \n"" /* try again if reservation was cleared     */
    ""    isync               \n"" /* read barrier                             */

    : ""=&b"" (res), ""=&b"" (temp)
    : ""b"" (value), ""b"" (add)
    : ""cc"", ""memory"");

    return res;
}",1,1,os\unix\ngx_gcc_atomic_ppc.h,ngx_atomic_fetch_add,,false,122,142,ngx_atomic_fetch_add,,,6,"ANY ngx_atomic_fetch_add (ngx_atomic_t*,ngx_atomic_int_t)"
403050,METHOD,os\unix\ngx_gcc_atomic_sparc64.h:<global>,TYPE_DECL,<global>,1,4,os\unix\ngx_gcc_atomic_sparc64.h,os\unix\ngx_gcc_atomic_sparc64.h:<global>,,false,1,82,<global>,,,1,
403054,METHOD,os\unix\ngx_gcc_atomic_sparc64.h:<global>,TYPE_DECL,"ngx_atomic_cmp_set(ngx_atomic_t *lock, ngx_atomic_uint_t old,
    ngx_atomic_uint_t set)
{
    __asm__ volatile (

    NGX_CASA "" [%1] 0x80, %2, %0""

    : ""+r"" (set) : ""r"" (lock), ""r"" (old) : ""memory"");

    return (set == old);
}",1,4,os\unix\ngx_gcc_atomic_sparc64.h,ngx_atomic_cmp_set,,false,34,44,ngx_atomic_cmp_set,,,3,"ANY ngx_atomic_cmp_set (ngx_atomic_t*,ngx_atomic_uint_t,ngx_atomic_uint_t)"
403068,METHOD,os\unix\ngx_gcc_atomic_sparc64.h:<global>,TYPE_DECL,"ngx_atomic_fetch_add(ngx_atomic_t *value, ngx_atomic_int_t add)
{
    ngx_atomic_uint_t  old, res;

    old = *value;

    for ( ;; ) {

        res = old + add;

        __asm__ volatile (

        NGX_CASA "" [%1] 0x80, %2, %0""

        : ""+r"" (res) : ""r"" (value), ""r"" (old) : ""memory"");

        if (res == old) {
            return res;
        }

        old = res;
    }
}",1,8,os\unix\ngx_gcc_atomic_sparc64.h,ngx_atomic_fetch_add,,false,48,70,ngx_atomic_fetch_add,,,6,"ANY ngx_atomic_fetch_add (ngx_atomic_t*,ngx_atomic_int_t)"
403102,METHOD,os\unix\ngx_gcc_atomic_x86.h:<global>,TYPE_DECL,<global>,1,9,os\unix\ngx_gcc_atomic_x86.h,os\unix\ngx_gcc_atomic_x86.h:<global>,,false,1,127,<global>,,,1,
403106,METHOD,os\unix\ngx_gcc_atomic_x86.h:<global>,TYPE_DECL,"ngx_atomic_cmp_set(ngx_atomic_t *lock, ngx_atomic_uint_t old,
    ngx_atomic_uint_t set)
{
    u_char  res;

    __asm__ volatile (

         NGX_SMP_LOCK
    ""    cmpxchgl  %3, %1;   ""
    ""    sete      %0;       ""

    : ""=a"" (res) : ""m"" (*lock), ""a"" (old), ""r"" (set) : ""cc"", ""memory"");

    return res;
}",1,9,os\unix\ngx_gcc_atomic_x86.h,ngx_atomic_cmp_set,,false,38,52,ngx_atomic_cmp_set,,,3,"ANY ngx_atomic_cmp_set (ngx_atomic_t*,ngx_atomic_uint_t,ngx_atomic_uint_t)"
403119,METHOD,os\unix\ngx_gcc_atomic_x86.h:<global>,TYPE_DECL,"ngx_atomic_fetch_add(ngx_atomic_t *value, ngx_atomic_int_t add)
{
    __asm__ volatile (

         NGX_SMP_LOCK
    ""    xaddl  %0, %1;   ""

    : ""+r"" (add) : ""m"" (*value) : ""cc"", ""memory"");

    return add;
}",1,9,os\unix\ngx_gcc_atomic_x86.h,ngx_atomic_fetch_add,,false,80,90,ngx_atomic_fetch_add,,,6,"ANY ngx_atomic_fetch_add (ngx_atomic_t*,ngx_atomic_int_t)"
403131,METHOD,os\unix\ngx_linux.h:<global>,TYPE_DECL,<global>,1,35,os\unix\ngx_linux.h,os\unix\ngx_linux.h:<global>,,false,1,16,<global>,,,1,
403133,METHOD,os\unix\ngx_linux.h:<global>,TYPE_DECL,"ngx_chain_t *ngx_linux_sendfile_chain(ngx_connection_t *c, ngx_chain_t *in,
    off_t limit);",13,16,os\unix\ngx_linux.h,ngx_linux_sendfile_chain,,false,12,13,ngx_linux_sendfile_chain,,,1,"ngx_chain_t* ngx_linux_sendfile_chain (ngx_connection_t*,ngx_chain_t*,off_t)"
403149,METHOD,os\unix\ngx_linux_aio_read.c:<global>,TYPE_DECL,<global>,1,1,os\unix\ngx_linux_aio_read.c,os\unix\ngx_linux_aio_read.c:<global>,,false,1,148,<global>,,,1,
403153,METHOD,os\unix\ngx_linux_aio_read.c:<global>,TYPE_DECL,static void ngx_file_aio_event_handler(ngx_event_t *ev);,13,55,os\unix\ngx_linux_aio_read.c,ngx_file_aio_event_handler,,false,17,17,ngx_file_aio_event_handler,,,3,void ngx_file_aio_event_handler (ngx_event_t*)
403158,METHOD,os\unix\ngx_linux_aio_read.c:<global>,TYPE_DECL,"static int
io_submit(aio_context_t ctx, long n, struct iocb **paiocb)
{
    return syscall(SYS_io_submit, ctx, n, paiocb);
}",1,1,os\unix\ngx_linux_aio_read.c,io_submit,,false,20,24,io_submit,,,4,"int io_submit (aio_context_t,long,iocb**)"
403171,METHOD,os\unix\ngx_linux_aio_read.c:<global>,TYPE_DECL,"ngx_int_t
ngx_file_aio_init(ngx_file_t *file, ngx_pool_t *pool)
{
    ngx_event_aio_t  *aio;

    aio = ngx_pcalloc(pool, sizeof(ngx_event_aio_t));
    if (aio == NULL) {
        return NGX_ERROR;
    }

    aio->file = file;
    aio->fd = file->fd;
    aio->event.data = aio;
    aio->event.ready = 1;
    aio->event.log = file->log;

    file->aio = aio;

    return NGX_OK;
}",1,1,os\unix\ngx_linux_aio_read.c,ngx_file_aio_init,,false,27,46,ngx_file_aio_init,,,5,"ngx_int_t ngx_file_aio_init (ngx_file_t*,ngx_pool_t*)"
403233,METHOD,os\unix\ngx_linux_aio_read.c:<global>,TYPE_DECL,"ssize_t
ngx_file_aio_read(ngx_file_t *file, u_char *buf, size_t size, off_t offset,
    ngx_pool_t *pool)
{
    ngx_err_t         err;
    struct iocb      *piocb[1];
    ngx_event_t      *ev;
    ngx_event_aio_t  *aio;

    if (!ngx_file_aio) {
        return ngx_read_file(file, buf, size, offset);
    }

    if (file->aio == NULL && ngx_file_aio_init(file, pool) != NGX_OK) {
        return NGX_ERROR;
    }

    aio = file->aio;
    ev = &aio->event;

    if (!ev->ready) {
        ngx_log_error(NGX_LOG_ALERT, file->log, 0,
                      ""second aio post for \""%V\"""", &file->name);
        return NGX_AGAIN;
    }

    ngx_log_debug4(NGX_LOG_DEBUG_CORE, file->log, 0,
                   ""aio complete:%d @%O:%uz %V"",
                   ev->complete, offset, size, &file->name);

    if (ev->complete) {
        ev->active = 0;
        ev->complete = 0;

        if (aio->res >= 0) {
            ngx_set_errno(0);
            return aio->res;
        }

        ngx_set_errno(-aio->re...",1,1,os\unix\ngx_linux_aio_read.c,ngx_file_aio_read,,false,49,134,ngx_file_aio_read,,,6,"ssize_t ngx_file_aio_read (ngx_file_t*,u_char*,size_t,off_t,ngx_pool_t*)"
403516,METHOD,os\unix\ngx_linux_aio_read.c:<global>,TYPE_DECL,"static void
ngx_file_aio_event_handler(ngx_event_t *ev)
{
    ngx_event_aio_t  *aio;

    aio = ev->data;

    ngx_log_debug2(NGX_LOG_DEBUG_CORE, ev->log, 0,
                   ""aio event handler fd:%d %V"", aio->fd, &aio->file->name);

    aio->handler(ev);
}",1,1,os\unix\ngx_linux_aio_read.c,ngx_file_aio_event_handler,,false,137,148,ngx_file_aio_event_handler,,,7,void ngx_file_aio_event_handler (ngx_event_t*)
403643,METHOD,os\unix\ngx_linux_config.h:<global>,TYPE_DECL,<global>,1,42,os\unix\ngx_linux_config.h,os\unix\ngx_linux_config.h:<global>,,false,1,128,<global>,,,1,
403645,METHOD,os\unix\ngx_linux_config.h:<global>,TYPE_DECL,"extern ssize_t sendfile(int s, int fd, int32_t *offset, size_t size);",16,68,os\unix\ngx_linux_config.h,sendfile,,false,77,77,sendfile,,,1,"ssize_t sendfile (int,int,int32_t*,size_t)"
403661,METHOD,os\unix\ngx_linux_init.c:<global>,TYPE_DECL,<global>,1,1,os\unix\ngx_linux_init.c,os\unix\ngx_linux_init.c:<global>,,false,1,60,<global>,,,1,
403681,METHOD,os\unix\ngx_linux_init.c:<global>,TYPE_DECL,"ngx_int_t
ngx_os_specific_init(ngx_log_t *log)
{
    struct utsname  u;

    if (uname(&u) == -1) {
        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno, ""uname() failed"");
        return NGX_ERROR;
    }

    (void) ngx_cpystrn(ngx_linux_kern_ostype, (u_char *) u.sysname,
                       sizeof(ngx_linux_kern_ostype));

    (void) ngx_cpystrn(ngx_linux_kern_osrelease, (u_char *) u.release,
                       sizeof(ngx_linux_kern_osrelease));

    ngx_os_io = ngx_linux_io;

    return NGX_OK;
}",1,1,os\unix\ngx_linux_init.c,ngx_os_specific_init,,false,33,52,ngx_os_specific_init,,,7,ngx_int_t ngx_os_specific_init (ngx_log_t*)
403729,METHOD,os\unix\ngx_linux_init.c:<global>,TYPE_DECL,"void
ngx_os_specific_status(ngx_log_t *log)
{
    ngx_log_error(NGX_LOG_NOTICE, log, 0, ""OS: %s %s"",
                  ngx_linux_kern_ostype, ngx_linux_kern_osrelease);
}",1,1,os\unix\ngx_linux_init.c,ngx_os_specific_status,,false,55,60,ngx_os_specific_status,,,8,void ngx_os_specific_status (ngx_log_t*)
403752,METHOD,os\unix\ngx_linux_sendfile_chain.c:<global>,TYPE_DECL,<global>,1,39,os\unix\ngx_linux_sendfile_chain.c,os\unix\ngx_linux_sendfile_chain.c:<global>,,false,1,442,<global>,,,1,
403754,METHOD,os\unix\ngx_linux_sendfile_chain.c:<global>,TYPE_DECL,"static ssize_t ngx_linux_sendfile(ngx_connection_t *c, ngx_buf_t *file,
    size_t size);",16,16,os\unix\ngx_linux_sendfile_chain.c,ngx_linux_sendfile,,false,13,14,ngx_linux_sendfile,,,1,"ssize_t ngx_linux_sendfile (ngx_connection_t*,ngx_buf_t*,size_t)"
403761,METHOD,os\unix\ngx_linux_sendfile_chain.c:<global>,TYPE_DECL,"ngx_chain_t *
ngx_linux_sendfile_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)
{
    int            tcp_nodelay;
    off_t          send, prev_send;
    size_t         file_size, sent;
    ssize_t        n;
    ngx_err_t      err;
    ngx_buf_t     *file;
    ngx_event_t   *wev;
    ngx_chain_t   *cl;
    ngx_iovec_t    header;
    struct iovec   headers[NGX_IOVS_PREALLOCATE];

    wev = c->write;

    if (!wev->ready) {
        return in;
    }


    /* the maximum limit size is 2G-1 - the page size */

    if (limit == 0 || limit > (off_t) (NGX_SENDFILE_MAXSIZE - ngx_pagesize)) {
        limit = NGX_SENDFILE_MAXSIZE - ngx_pagesize;
    }


    send = 0;

    header.iovs = headers;
    header.nalloc = NGX_IOVS_PREALLOCATE;

    for ( ;; ) {
        prev_send = send;

        /* create the iovec and coalesce the neighbouring bufs */

        cl = ngx_output_chain_to_iovec(&header, in, limit - send, c->log);

        if (cl == NGX_CHAIN_ERROR) {
            return NGX_CHAI...",1,39,os\unix\ngx_linux_sendfile_chain.c,ngx_linux_sendfile_chain,,false,46,226,ngx_linux_sendfile_chain,,,2,"ngx_chain_t ngx_linux_sendfile_chain (ngx_connection_t*,ngx_chain_t*,off_t)"
404127,METHOD,os\unix\ngx_linux_sendfile_chain.c:<global>,TYPE_DECL,"static ssize_t
ngx_linux_sendfile(ngx_connection_t *c, ngx_buf_t *file, size_t size)
{
#if (NGX_HAVE_SENDFILE64)
    off_t      offset;
#else
    int32_t    offset;
#endif
    ssize_t    n;
    ngx_err_t  err;

#if (NGX_THREADS)

    if (file->file->thread_handler) {
        return ngx_linux_sendfile_thread(c, file, size);
    }

#endif

#if (NGX_HAVE_SENDFILE64)
    offset = file->file_pos;
#else
    offset = (int32_t) file->file_pos;
#endif

eintr:

    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,
                   ""sendfile: @%O %uz"", file->file_pos, size);

    n = sendfile(c->fd, file->file->fd, &offset, size);

    if (n == -1) {
        err = ngx_errno;

        switch (err) {
        case NGX_EAGAIN:
            ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, err,
                           ""sendfile() is not ready"");
            return NGX_AGAIN;

        case NGX_EINTR:
            ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, err,
                           ""sendfile() was i...",1,1,os\unix\ngx_linux_sendfile_chain.c,ngx_linux_sendfile,,false,229,299,ngx_linux_sendfile,,,3,"ssize_t ngx_linux_sendfile (ngx_connection_t*,ngx_buf_t*,size_t)"
404270,METHOD,os\unix\ngx_os.h:<global>,TYPE_DECL,<global>,1,32,os\unix\ngx_os.h,os\unix\ngx_os.h:<global>,,false,1,102,<global>,,,1,
404272,METHOD,os\unix\ngx_os.h:<global>,TYPE_DECL,"typedef ssize_t (*ngx_recv_pt)(ngx_connection_t *c, u_char *buf, size_t size);",17,77,os\unix\ngx_os.h,ngx_recv_pt,,false,19,19,ngx_recv_pt,,,1,"ssize_t ngx_recv_pt (ngx_connection_t*,u_char*,size_t)"
404279,METHOD,os\unix\ngx_os.h:<global>,TYPE_DECL,"typedef ssize_t (*ngx_recv_chain_pt)(ngx_connection_t *c, ngx_chain_t *in,
    off_t limit);",17,16,os\unix\ngx_os.h,ngx_recv_chain_pt,,false,20,21,ngx_recv_chain_pt,,,2,"ssize_t ngx_recv_chain_pt (ngx_connection_t*,ngx_chain_t*,off_t)"
404286,METHOD,os\unix\ngx_os.h:<global>,TYPE_DECL,"typedef ssize_t (*ngx_send_pt)(ngx_connection_t *c, u_char *buf, size_t size);",17,77,os\unix\ngx_os.h,ngx_send_pt,,false,22,22,ngx_send_pt,,,3,"ssize_t ngx_send_pt (ngx_connection_t*,u_char*,size_t)"
404293,METHOD,os\unix\ngx_os.h:<global>,TYPE_DECL,"typedef ngx_chain_t *(*ngx_send_chain_pt)(ngx_connection_t *c, ngx_chain_t *in,
    off_t limit);",21,16,os\unix\ngx_os.h,ngx_send_chain_pt,,false,23,24,ngx_send_chain_pt,,,4,"ngx_chain_t* ngx_send_chain_pt (ngx_connection_t*,ngx_chain_t*,off_t)"
404310,METHOD,os\unix\ngx_os.h:<global>,TYPE_DECL,ngx_int_t ngx_os_init(ngx_log_t *log);,11,37,os\unix\ngx_os.h,ngx_os_init,,false,38,38,ngx_os_init,,,7,ngx_int_t ngx_os_init (ngx_log_t*)
404315,METHOD,os\unix\ngx_os.h:<global>,TYPE_DECL,void ngx_os_status(ngx_log_t *log);,6,34,os\unix\ngx_os.h,ngx_os_status,,false,39,39,ngx_os_status,,,8,void ngx_os_status (ngx_log_t*)
404320,METHOD,os\unix\ngx_os.h:<global>,TYPE_DECL,ngx_int_t ngx_os_specific_init(ngx_log_t *log);,11,46,os\unix\ngx_os.h,ngx_os_specific_init,,false,40,40,ngx_os_specific_init,,,9,ngx_int_t ngx_os_specific_init (ngx_log_t*)
404325,METHOD,os\unix\ngx_os.h:<global>,TYPE_DECL,void ngx_os_specific_status(ngx_log_t *log);,6,43,os\unix\ngx_os.h,ngx_os_specific_status,,false,41,41,ngx_os_specific_status,,,10,void ngx_os_specific_status (ngx_log_t*)
404330,METHOD,os\unix\ngx_os.h:<global>,TYPE_DECL,ngx_int_t ngx_daemon(ngx_log_t *log);,11,36,os\unix\ngx_os.h,ngx_daemon,,false,42,42,ngx_daemon,,,11,ngx_int_t ngx_daemon (ngx_log_t*)
404335,METHOD,os\unix\ngx_os.h:<global>,TYPE_DECL,"ngx_int_t ngx_os_signal_process(ngx_cycle_t *cycle, char *sig, ngx_pid_t pid);",11,77,os\unix\ngx_os.h,ngx_os_signal_process,,false,43,43,ngx_os_signal_process,,,12,"ngx_int_t ngx_os_signal_process (ngx_cycle_t*,char*,ngx_pid_t)"
404342,METHOD,os\unix\ngx_os.h:<global>,TYPE_DECL,"ssize_t ngx_unix_recv(ngx_connection_t *c, u_char *buf, size_t size);",9,68,os\unix\ngx_os.h,ngx_unix_recv,,false,46,46,ngx_unix_recv,,,13,"ssize_t ngx_unix_recv (ngx_connection_t*,u_char*,size_t)"
404349,METHOD,os\unix\ngx_os.h:<global>,TYPE_DECL,"ssize_t ngx_readv_chain(ngx_connection_t *c, ngx_chain_t *entry, off_t limit);",9,77,os\unix\ngx_os.h,ngx_readv_chain,,false,47,47,ngx_readv_chain,,,14,"ssize_t ngx_readv_chain (ngx_connection_t*,ngx_chain_t*,off_t)"
404356,METHOD,os\unix\ngx_os.h:<global>,TYPE_DECL,"ssize_t ngx_udp_unix_recv(ngx_connection_t *c, u_char *buf, size_t size);",9,72,os\unix\ngx_os.h,ngx_udp_unix_recv,,false,48,48,ngx_udp_unix_recv,,,15,"ssize_t ngx_udp_unix_recv (ngx_connection_t*,u_char*,size_t)"
404363,METHOD,os\unix\ngx_os.h:<global>,TYPE_DECL,"ssize_t ngx_unix_send(ngx_connection_t *c, u_char *buf, size_t size);",9,68,os\unix\ngx_os.h,ngx_unix_send,,false,49,49,ngx_unix_send,,,16,"ssize_t ngx_unix_send (ngx_connection_t*,u_char*,size_t)"
404370,METHOD,os\unix\ngx_os.h:<global>,TYPE_DECL,"ngx_chain_t *ngx_writev_chain(ngx_connection_t *c, ngx_chain_t *in,
    off_t limit);",13,16,os\unix\ngx_os.h,ngx_writev_chain,,false,50,51,ngx_writev_chain,,,17,"ngx_chain_t* ngx_writev_chain (ngx_connection_t*,ngx_chain_t*,off_t)"
404377,METHOD,os\unix\ngx_os.h:<global>,TYPE_DECL,"ssize_t ngx_udp_unix_send(ngx_connection_t *c, u_char *buf, size_t size);",9,72,os\unix\ngx_os.h,ngx_udp_unix_send,,false,52,52,ngx_udp_unix_send,,,18,"ssize_t ngx_udp_unix_send (ngx_connection_t*,u_char*,size_t)"
404384,METHOD,os\unix\ngx_os.h:<global>,TYPE_DECL,"ngx_chain_t *ngx_udp_unix_sendmsg_chain(ngx_connection_t *c, ngx_chain_t *in,
    off_t limit);",13,16,os\unix\ngx_os.h,ngx_udp_unix_sendmsg_chain,,false,53,54,ngx_udp_unix_sendmsg_chain,,,19,"ngx_chain_t* ngx_udp_unix_sendmsg_chain (ngx_connection_t*,ngx_chain_t*,off_t)"
404398,METHOD,os\unix\ngx_os.h:<global>,TYPE_DECL,"ngx_chain_t *ngx_output_chain_to_iovec(ngx_iovec_t *vec, ngx_chain_t *in,
    size_t limit, ngx_log_t *log);",13,33,os\unix\ngx_os.h,ngx_output_chain_to_iovec,,false,71,72,ngx_output_chain_to_iovec,,,22,"ngx_chain_t* ngx_output_chain_to_iovec (ngx_iovec_t*,ngx_chain_t*,size_t,ngx_log_t*)"
404406,METHOD,os\unix\ngx_os.h:<global>,TYPE_DECL,"ssize_t ngx_writev(ngx_connection_t *c, ngx_iovec_t *vec);",9,57,os\unix\ngx_os.h,ngx_writev,,false,75,75,ngx_writev,,,23,"ssize_t ngx_writev (ngx_connection_t*,ngx_iovec_t*)"
404512,METHOD,os\unix\ngx_posix_config.h:<global>,TYPE_DECL,<global>,1,42,os\unix\ngx_posix_config.h,os\unix\ngx_posix_config.h:<global>,,false,1,151,<global>,,,1,
404524,METHOD,os\unix\ngx_posix_init.c:<global>,TYPE_DECL,<global>,1,6,os\unix\ngx_posix_init.c,os\unix\ngx_posix_init.c:<global>,,false,1,144,<global>,,,1,
404544,METHOD,os\unix\ngx_posix_init.c:<global>,TYPE_DECL,"ngx_int_t
ngx_os_init(ngx_log_t *log)
{
    ngx_time_t  *tp;
    ngx_uint_t   n;
#if (NGX_HAVE_LEVEL1_DCACHE_LINESIZE)
    long         size;
#endif

#if (NGX_HAVE_OS_SPECIFIC_INIT)
    if (ngx_os_specific_init(log) != NGX_OK) {
        return NGX_ERROR;
    }
#endif

    if (ngx_init_setproctitle(log) != NGX_OK) {
        return NGX_ERROR;
    }

    ngx_pagesize = getpagesize();
    ngx_cacheline_size = NGX_CPU_CACHE_LINE;

    for (n = ngx_pagesize; n >>= 1; ngx_pagesize_shift++) { /* void */ }

#if (NGX_HAVE_SC_NPROCESSORS_ONLN)
    if (ngx_ncpu == 0) {
        ngx_ncpu = sysconf(_SC_NPROCESSORS_ONLN);
    }
#endif

    if (ngx_ncpu < 1) {
        ngx_ncpu = 1;
    }

#if (NGX_HAVE_LEVEL1_DCACHE_LINESIZE)
    size = sysconf(_SC_LEVEL1_DCACHE_LINESIZE);
    if (size > 0) {
        ngx_cacheline_size = size;
    }
#endif

    ngx_cpuinfo();

    if (getrlimit(RLIMIT_NOFILE, &rlmt) == -1) {
        ngx_log_error(NGX_LOG_ALERT, log, errno,
                      ""getrlimit(RLIMIT_NOF...",1,1,os\unix\ngx_posix_init.c,ngx_os_init,,false,34,95,ngx_os_init,,,9,ngx_int_t ngx_os_init (ngx_log_t*)
404630,METHOD,os\unix\ngx_posix_init.c:<global>,TYPE_DECL,"void
ngx_os_status(ngx_log_t *log)
{
    ngx_log_error(NGX_LOG_NOTICE, log, 0, NGINX_VER_BUILD);

#ifdef NGX_COMPILER
    ngx_log_error(NGX_LOG_NOTICE, log, 0, ""built by "" NGX_COMPILER);
#endif

#if (NGX_HAVE_OS_SPECIFIC_INIT)
    ngx_os_specific_status(log);
#endif

    ngx_log_error(NGX_LOG_NOTICE, log, 0,
                  ""getrlimit(RLIMIT_NOFILE): %r:%r"",
                  rlmt.rlim_cur, rlmt.rlim_max);
}",1,1,os\unix\ngx_posix_init.c,ngx_os_status,,false,98,114,ngx_os_status,,,10,void ngx_os_status (ngx_log_t*)
404662,METHOD,os\unix\ngx_process.c:<global>,TYPE_DECL,<global>,1,1,os\unix\ngx_process.c,os\unix\ngx_process.c:<global>,,false,1,648,<global>,,,1,
404668,METHOD,ngx_signal_t,TYPE_DECL,"void  (*handler)(int signo, siginfo_t *siginfo, void *ucontext);",11,67,os\unix\ngx_process.c,ngx_signal_t.handler,,false,18,18,handler,,,4,"void ngx_signal_t.handler (int,siginfo_t*,void*)"
404676,METHOD,os\unix\ngx_process.c:<global>,TYPE_DECL,"static void ngx_execute_proc(ngx_cycle_t *cycle, void *data);",13,60,os\unix\ngx_process.c,ngx_execute_proc,,false,23,23,ngx_execute_proc,,,3,"void ngx_execute_proc (ngx_cycle_t*,void*)"
404682,METHOD,os\unix\ngx_process.c:<global>,TYPE_DECL,"static void ngx_signal_handler(int signo, siginfo_t *siginfo, void *ucontext);",13,77,os\unix\ngx_process.c,ngx_signal_handler,,false,24,24,ngx_signal_handler,,,4,"void ngx_signal_handler (int,siginfo_t*,void*)"
404689,METHOD,os\unix\ngx_process.c:<global>,TYPE_DECL,static void ngx_process_get_status(void);,13,40,os\unix\ngx_process.c,ngx_process_get_status,,false,25,25,ngx_process_get_status,,,5,void ngx_process_get_status (void)
404694,METHOD,os\unix\ngx_process.c:<global>,TYPE_DECL,static void ngx_unlock_mutexes(ngx_pid_t pid);,13,45,os\unix\ngx_process.c,ngx_unlock_mutexes,,false,26,26,ngx_unlock_mutexes,,,6,void ngx_unlock_mutexes (ngx_pid_t)
404723,METHOD,os\unix\ngx_process.c:<global>,TYPE_DECL,"ngx_pid_t
ngx_spawn_process(ngx_cycle_t *cycle, ngx_spawn_proc_pt proc, void *data,
    char *name, ngx_int_t respawn)
{
    u_long     on;
    ngx_pid_t  pid;
    ngx_int_t  s;

    if (respawn >= 0) {
        s = respawn;

    } else {
        for (s = 0; s < ngx_last_process; s++) {
            if (ngx_processes[s].pid == -1) {
                break;
            }
        }

        if (s == NGX_MAX_PROCESSES) {
            ngx_log_error(NGX_LOG_ALERT, cycle->log, 0,
                          ""no more than %d processes can be spawned"",
                          NGX_MAX_PROCESSES);
            return NGX_INVALID_PID;
        }
    }


    if (respawn != NGX_PROCESS_DETACHED) {

        /* Solaris 9 still has no AF_LOCAL */

        if (socketpair(AF_UNIX, SOCK_STREAM, 0, ngx_processes[s].channel) == -1)
        {
            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                          ""socketpair() failed while spawning \""%s\"""", name);
            return NGX_INVAL...",1,1,os\unix\ngx_process.c,ngx_spawn_process,,false,86,258,ngx_spawn_process,,,30,"ngx_pid_t ngx_spawn_process (ngx_cycle_t*,ngx_spawn_proc_pt,void*,char*,ngx_int_t)"
405288,METHOD,os\unix\ngx_process.c:<global>,TYPE_DECL,"ngx_pid_t
ngx_execute(ngx_cycle_t *cycle, ngx_exec_ctx_t *ctx)
{
    return ngx_spawn_process(cycle, ngx_execute_proc, ctx, ctx->name,
                             NGX_PROCESS_DETACHED);
}",1,1,os\unix\ngx_process.c,ngx_execute,,false,261,266,ngx_execute,,,31,"ngx_pid_t ngx_execute (ngx_cycle_t*,ngx_exec_ctx_t*)"
405303,METHOD,os\unix\ngx_process.c:<global>,TYPE_DECL,"static void
ngx_execute_proc(ngx_cycle_t *cycle, void *data)
{
    ngx_exec_ctx_t  *ctx = data;

    if (execve(ctx->path, ctx->argv, ctx->envp) == -1) {
        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                      ""execve() failed while executing %s \""%s\"""",
                      ctx->name, ctx->path);
    }

    exit(1);
}",1,1,os\unix\ngx_process.c,ngx_execute_proc,,false,269,281,ngx_execute_proc,,,32,"void ngx_execute_proc (ngx_cycle_t*,void*)"
405343,METHOD,os\unix\ngx_process.c:<global>,TYPE_DECL,"ngx_int_t
ngx_init_signals(ngx_log_t *log)
{
    ngx_signal_t      *sig;
    struct sigaction   sa;

    for (sig = signals; sig->signo != 0; sig++) {
        ngx_memzero(&sa, sizeof(struct sigaction));

        if (sig->handler) {
            sa.sa_sigaction = sig->handler;
            sa.sa_flags = SA_SIGINFO;

        } else {
            sa.sa_handler = SIG_IGN;
        }

        sigemptyset(&sa.sa_mask);
        if (sigaction(sig->signo, &sa, NULL) == -1) {
#if (NGX_VALGRIND)
            ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,
                          ""sigaction(%s) failed, ignored"", sig->signame);
#else
            ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,
                          ""sigaction(%s) failed"", sig->signame);
            return NGX_ERROR;
#endif
        }
    }

    return NGX_OK;
}",1,1,os\unix\ngx_process.c,ngx_init_signals,,false,284,315,ngx_init_signals,,,33,ngx_int_t ngx_init_signals (ngx_log_t*)
405421,METHOD,os\unix\ngx_process.c:<global>,TYPE_DECL,"static void
ngx_signal_handler(int signo, siginfo_t *siginfo, void *ucontext)
{
    char            *action;
    ngx_int_t        ignore;
    ngx_err_t        err;
    ngx_signal_t    *sig;

    ignore = 0;

    err = ngx_errno;

    for (sig = signals; sig->signo != 0; sig++) {
        if (sig->signo == signo) {
            break;
        }
    }

    ngx_time_sigsafe_update();

    action = """";

    switch (ngx_process) {

    case NGX_PROCESS_MASTER:
    case NGX_PROCESS_SINGLE:
        switch (signo) {

        case ngx_signal_value(NGX_SHUTDOWN_SIGNAL):
            ngx_quit = 1;
            action = "", shutting down"";
            break;

        case ngx_signal_value(NGX_TERMINATE_SIGNAL):
        case SIGINT:
            ngx_terminate = 1;
            action = "", exiting"";
            break;

        case ngx_signal_value(NGX_NOACCEPT_SIGNAL):
            if (ngx_daemonized) {
                ngx_noaccept = 1;
                action = "", stop accepting connections"";
          ...",1,1,os\unix\ngx_process.c,ngx_signal_handler,,false,318,467,ngx_signal_handler,,,34,"void ngx_signal_handler (int,siginfo_t*,void*)"
405690,METHOD,os\unix\ngx_process.c:<global>,TYPE_DECL,"static void
ngx_process_get_status(void)
{
    int              status;
    char            *process;
    ngx_pid_t        pid;
    ngx_err_t        err;
    ngx_int_t        i;
    ngx_uint_t       one;

    one = 0;

    for ( ;; ) {
        pid = waitpid(-1, &status, WNOHANG);

        if (pid == 0) {
            return;
        }

        if (pid == -1) {
            err = ngx_errno;

            if (err == NGX_EINTR) {
                continue;
            }

            if (err == NGX_ECHILD && one) {
                return;
            }

            /*
             * Solaris always calls the signal handler for each exited process
             * despite waitpid() may be already called for this process.
             *
             * When several processes exit at the same time FreeBSD may
             * erroneously call the signal handler for exited process
             * despite waitpid() may be already called for this process.
             */

            if (err == NGX_ECHI...",1,1,os\unix\ngx_process.c,ngx_process_get_status,,false,470,561,ngx_process_get_status,,,35,void ngx_process_get_status (void)
405873,METHOD,os\unix\ngx_process.c:<global>,TYPE_DECL,"static void
ngx_unlock_mutexes(ngx_pid_t pid)
{
    ngx_uint_t        i;
    ngx_shm_zone_t   *shm_zone;
    ngx_list_part_t  *part;
    ngx_slab_pool_t  *sp;

    /*
     * unlock the accept mutex if the abnormally exited process
     * held it
     */

    if (ngx_accept_mutex_ptr) {
        (void) ngx_shmtx_force_unlock(&ngx_accept_mutex, pid);
    }

    /*
     * unlock shared memory mutexes if held by the abnormally exited
     * process
     */

    part = (ngx_list_part_t *) &ngx_cycle->shared_memory.part;
    shm_zone = part->elts;

    for (i = 0; /* void */ ; i++) {

        if (i >= part->nelts) {
            if (part->next == NULL) {
                break;
            }
            part = part->next;
            shm_zone = part->elts;
            i = 0;
        }

        sp = (ngx_slab_pool_t *) shm_zone[i].shm.addr;

        if (ngx_shmtx_force_unlock(&sp->mutex, pid)) {
            ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, 0,
                          ""shared memo...",1,1,os\unix\ngx_process.c,ngx_unlock_mutexes,,false,564,608,ngx_unlock_mutexes,,,36,void ngx_unlock_mutexes (ngx_pid_t)
405977,METHOD,os\unix\ngx_process.c:<global>,TYPE_DECL,"void
ngx_debug_point(void)
{
    ngx_core_conf_t  *ccf;

    ccf = (ngx_core_conf_t *) ngx_get_conf(ngx_cycle->conf_ctx,
                                           ngx_core_module);

    switch (ccf->debug_points) {

    case NGX_DEBUG_POINTS_STOP:
        raise(SIGSTOP);
        break;

    case NGX_DEBUG_POINTS_ABORT:
        ngx_abort();
    }
}",1,1,os\unix\ngx_process.c,ngx_debug_point,,false,611,628,ngx_debug_point,,,37,void ngx_debug_point (void)
406005,METHOD,os\unix\ngx_process.c:<global>,TYPE_DECL,"ngx_int_t
ngx_os_signal_process(ngx_cycle_t *cycle, char *name, ngx_pid_t pid)
{
    ngx_signal_t  *sig;

    for (sig = signals; sig->signo != 0; sig++) {
        if (ngx_strcmp(name, sig->name) == 0) {
            if (kill(pid, sig->signo) != -1) {
                return 0;
            }

            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                          ""kill(%P, %d) failed"", pid, sig->signo);
        }
    }

    return 1;
}",1,1,os\unix\ngx_process.c,ngx_os_signal_process,,false,631,648,ngx_os_signal_process,,,38,"ngx_int_t ngx_os_signal_process (ngx_cycle_t*,char*,ngx_pid_t)"
406067,METHOD,os\unix\ngx_process.h:<global>,TYPE_DECL,<global>,1,36,os\unix\ngx_process.h,os\unix\ngx_process.h:<global>,,false,1,90,<global>,,,1,
406070,METHOD,os\unix\ngx_process.h:<global>,TYPE_DECL,"typedef void (*ngx_spawn_proc_pt) (ngx_cycle_t *cycle, void *data);",14,66,os\unix\ngx_process.h,ngx_spawn_proc_pt,,false,20,20,ngx_spawn_proc_pt,,,2,"void ngx_spawn_proc_pt (ngx_cycle_t*,void*)"
406088,METHOD,<empty>,<empty>,<empty>,1,,os\unix\ngx_process.h,ngx_process_t:<clinit>,,false,22,,<clinit>,,,12,
406101,METHOD,os\unix\ngx_process.h:<global>,TYPE_DECL,"ngx_pid_t ngx_spawn_process(ngx_cycle_t *cycle,
    ngx_spawn_proc_pt proc, void *data, char *name, ngx_int_t respawn);",11,70,os\unix\ngx_process.h,ngx_spawn_process,,false,64,65,ngx_spawn_process,,,7,"ngx_pid_t ngx_spawn_process (ngx_cycle_t*,ngx_spawn_proc_pt,void*,char*,ngx_int_t)"
406110,METHOD,os\unix\ngx_process.h:<global>,TYPE_DECL,"ngx_pid_t ngx_execute(ngx_cycle_t *cycle, ngx_exec_ctx_t *ctx);",11,62,os\unix\ngx_process.h,ngx_execute,,false,66,66,ngx_execute,,,8,"ngx_pid_t ngx_execute (ngx_cycle_t*,ngx_exec_ctx_t*)"
406116,METHOD,os\unix\ngx_process.h:<global>,TYPE_DECL,ngx_int_t ngx_init_signals(ngx_log_t *log);,11,42,os\unix\ngx_process.h,ngx_init_signals,,false,67,67,ngx_init_signals,,,9,ngx_int_t ngx_init_signals (ngx_log_t*)
406121,METHOD,os\unix\ngx_process.h:<global>,TYPE_DECL,void ngx_debug_point(void);,6,26,os\unix\ngx_process.h,ngx_debug_point,,false,68,68,ngx_debug_point,,,10,void ngx_debug_point (void)
406150,METHOD,os\unix\ngx_process_cycle.c:<global>,TYPE_DECL,<global>,1,1,os\unix\ngx_process_cycle.c,os\unix\ngx_process_cycle.c:<global>,,false,1,1229,<global>,,,1,
406152,METHOD,os\unix\ngx_process_cycle.c:<global>,TYPE_DECL,"static void ngx_start_worker_processes(ngx_cycle_t *cycle, ngx_int_t n,
    ngx_int_t type);",13,19,os\unix\ngx_process_cycle.c,ngx_start_worker_processes,,false,14,15,ngx_start_worker_processes,,,1,"void ngx_start_worker_processes (ngx_cycle_t*,ngx_int_t,ngx_int_t)"
406159,METHOD,os\unix\ngx_process_cycle.c:<global>,TYPE_DECL,"static void ngx_start_cache_manager_processes(ngx_cycle_t *cycle,
    ngx_uint_t respawn);",13,23,os\unix\ngx_process_cycle.c,ngx_start_cache_manager_processes,,false,16,17,ngx_start_cache_manager_processes,,,2,"void ngx_start_cache_manager_processes (ngx_cycle_t*,ngx_uint_t)"
406165,METHOD,os\unix\ngx_process_cycle.c:<global>,TYPE_DECL,"static void ngx_pass_open_channel(ngx_cycle_t *cycle, ngx_channel_t *ch);",13,72,os\unix\ngx_process_cycle.c,ngx_pass_open_channel,,false,18,18,ngx_pass_open_channel,,,3,"void ngx_pass_open_channel (ngx_cycle_t*,ngx_channel_t*)"
406171,METHOD,os\unix\ngx_process_cycle.c:<global>,TYPE_DECL,"static void ngx_signal_worker_processes(ngx_cycle_t *cycle, int signo);",13,70,os\unix\ngx_process_cycle.c,ngx_signal_worker_processes,,false,19,19,ngx_signal_worker_processes,,,4,"void ngx_signal_worker_processes (ngx_cycle_t*,int)"
406177,METHOD,os\unix\ngx_process_cycle.c:<global>,TYPE_DECL,static ngx_uint_t ngx_reap_children(ngx_cycle_t *cycle);,19,55,os\unix\ngx_process_cycle.c,ngx_reap_children,,false,20,20,ngx_reap_children,,,5,ngx_uint_t ngx_reap_children (ngx_cycle_t*)
406182,METHOD,os\unix\ngx_process_cycle.c:<global>,TYPE_DECL,static void ngx_master_process_exit(ngx_cycle_t *cycle);,13,55,os\unix\ngx_process_cycle.c,ngx_master_process_exit,,false,21,21,ngx_master_process_exit,,,6,void ngx_master_process_exit (ngx_cycle_t*)
406187,METHOD,os\unix\ngx_process_cycle.c:<global>,TYPE_DECL,"static void ngx_worker_process_cycle(ngx_cycle_t *cycle, void *data);",13,68,os\unix\ngx_process_cycle.c,ngx_worker_process_cycle,,false,22,22,ngx_worker_process_cycle,,,7,"void ngx_worker_process_cycle (ngx_cycle_t*,void*)"
406193,METHOD,os\unix\ngx_process_cycle.c:<global>,TYPE_DECL,"static void ngx_worker_process_init(ngx_cycle_t *cycle, ngx_int_t worker);",13,73,os\unix\ngx_process_cycle.c,ngx_worker_process_init,,false,23,23,ngx_worker_process_init,,,8,"void ngx_worker_process_init (ngx_cycle_t*,ngx_int_t)"
406199,METHOD,os\unix\ngx_process_cycle.c:<global>,TYPE_DECL,static void ngx_worker_process_exit(ngx_cycle_t *cycle);,13,55,os\unix\ngx_process_cycle.c,ngx_worker_process_exit,,false,24,24,ngx_worker_process_exit,,,9,void ngx_worker_process_exit (ngx_cycle_t*)
406204,METHOD,os\unix\ngx_process_cycle.c:<global>,TYPE_DECL,static void ngx_channel_handler(ngx_event_t *ev);,13,48,os\unix\ngx_process_cycle.c,ngx_channel_handler,,false,25,25,ngx_channel_handler,,,10,void ngx_channel_handler (ngx_event_t*)
406209,METHOD,os\unix\ngx_process_cycle.c:<global>,TYPE_DECL,"static void ngx_cache_manager_process_cycle(ngx_cycle_t *cycle, void *data);",13,75,os\unix\ngx_process_cycle.c,ngx_cache_manager_process_cycle,,false,26,26,ngx_cache_manager_process_cycle,,,11,"void ngx_cache_manager_process_cycle (ngx_cycle_t*,void*)"
406215,METHOD,os\unix\ngx_process_cycle.c:<global>,TYPE_DECL,static void ngx_cache_manager_process_handler(ngx_event_t *ev);,13,62,os\unix\ngx_process_cycle.c,ngx_cache_manager_process_handler,,false,27,27,ngx_cache_manager_process_handler,,,12,void ngx_cache_manager_process_handler (ngx_event_t*)
406220,METHOD,os\unix\ngx_process_cycle.c:<global>,TYPE_DECL,static void ngx_cache_loader_process_handler(ngx_event_t *ev);,13,61,os\unix\ngx_process_cycle.c,ngx_cache_loader_process_handler,,false,28,28,ngx_cache_loader_process_handler,,,13,void ngx_cache_loader_process_handler (ngx_event_t*)
406266,METHOD,os\unix\ngx_process_cycle.c:<global>,TYPE_DECL,"void
ngx_master_process_cycle(ngx_cycle_t *cycle)
{
    char              *title;
    u_char            *p;
    size_t             size;
    ngx_int_t          i;
    ngx_uint_t         n, sigio;
    sigset_t           set;
    struct itimerval   itv;
    ngx_uint_t         live;
    ngx_msec_t         delay;
    ngx_listening_t   *ls;
    ngx_core_conf_t   *ccf;

    sigemptyset(&set);
    sigaddset(&set, SIGCHLD);
    sigaddset(&set, SIGALRM);
    sigaddset(&set, SIGIO);
    sigaddset(&set, SIGINT);
    sigaddset(&set, ngx_signal_value(NGX_RECONFIGURE_SIGNAL));
    sigaddset(&set, ngx_signal_value(NGX_REOPEN_SIGNAL));
    sigaddset(&set, ngx_signal_value(NGX_NOACCEPT_SIGNAL));
    sigaddset(&set, ngx_signal_value(NGX_TERMINATE_SIGNAL));
    sigaddset(&set, ngx_signal_value(NGX_SHUTDOWN_SIGNAL));
    sigaddset(&set, ngx_signal_value(NGX_CHANGEBIN_SIGNAL));

    if (sigprocmask(SIG_BLOCK, &set, NULL) == -1) {
        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
              ...",1,1,os\unix\ngx_process_cycle.c,ngx_master_process_cycle,,false,73,285,ngx_master_process_cycle,,,43,void ngx_master_process_cycle (ngx_cycle_t*)
406812,METHOD,os\unix\ngx_process_cycle.c:<global>,TYPE_DECL,"void
ngx_single_process_cycle(ngx_cycle_t *cycle)
{
    ngx_uint_t  i;

    if (ngx_set_environment(cycle, NULL) == NULL) {
        /* fatal */
        exit(2);
    }

    for (i = 0; cycle->modules[i]; i++) {
        if (cycle->modules[i]->init_process) {
            if (cycle->modules[i]->init_process(cycle) == NGX_ERROR) {
                /* fatal */
                exit(2);
            }
        }
    }

    for ( ;; ) {
        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, cycle->log, 0, ""worker cycle"");

        ngx_process_events_and_timers(cycle);

        if (ngx_terminate || ngx_quit) {

            for (i = 0; cycle->modules[i]; i++) {
                if (cycle->modules[i]->exit_process) {
                    cycle->modules[i]->exit_process(cycle);
                }
            }

            ngx_master_process_exit(cycle);
        }

        if (ngx_reconfigure) {
            ngx_reconfigure = 0;
            ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, ""reconfiguring"");

         ...",1,1,os\unix\ngx_process_cycle.c,ngx_single_process_cycle,,false,288,342,ngx_single_process_cycle,,,44,void ngx_single_process_cycle (ngx_cycle_t*)
406963,METHOD,os\unix\ngx_process_cycle.c:<global>,TYPE_DECL,"static void
ngx_start_worker_processes(ngx_cycle_t *cycle, ngx_int_t n, ngx_int_t type)
{
    ngx_int_t      i;
    ngx_channel_t  ch;

    ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, ""start worker processes"");

    ngx_memzero(&ch, sizeof(ngx_channel_t));

    ch.command = NGX_CMD_OPEN_CHANNEL;

    for (i = 0; i < n; i++) {

        ngx_spawn_process(cycle, ngx_worker_process_cycle,
                          (void *) (intptr_t) i, ""worker process"", type);

        ch.pid = ngx_processes[ngx_process_slot].pid;
        ch.slot = ngx_process_slot;
        ch.fd = ngx_processes[ngx_process_slot].channel[0];

        ngx_pass_open_channel(cycle, &ch);
    }
}",1,1,os\unix\ngx_process_cycle.c,ngx_start_worker_processes,,false,345,368,ngx_start_worker_processes,,,45,"void ngx_start_worker_processes (ngx_cycle_t*,ngx_int_t,ngx_int_t)"
407039,METHOD,os\unix\ngx_process_cycle.c:<global>,TYPE_DECL,"static void
ngx_start_cache_manager_processes(ngx_cycle_t *cycle, ngx_uint_t respawn)
{
    ngx_uint_t       i, manager, loader;
    ngx_path_t     **path;
    ngx_channel_t    ch;

    manager = 0;
    loader = 0;

    path = ngx_cycle->paths.elts;
    for (i = 0; i < ngx_cycle->paths.nelts; i++) {

        if (path[i]->manager) {
            manager = 1;
        }

        if (path[i]->loader) {
            loader = 1;
        }
    }

    if (manager == 0) {
        return;
    }

    ngx_spawn_process(cycle, ngx_cache_manager_process_cycle,
                      &ngx_cache_manager_ctx, ""cache manager process"",
                      respawn ? NGX_PROCESS_JUST_RESPAWN : NGX_PROCESS_RESPAWN);

    ngx_memzero(&ch, sizeof(ngx_channel_t));

    ch.command = NGX_CMD_OPEN_CHANNEL;
    ch.pid = ngx_processes[ngx_process_slot].pid;
    ch.slot = ngx_process_slot;
    ch.fd = ngx_processes[ngx_process_slot].channel[0];

    ngx_pass_open_channel(cycle, &ch);

    if (loader == 0) {
      ...",1,1,os\unix\ngx_process_cycle.c,ngx_start_cache_manager_processes,,false,371,424,ngx_start_cache_manager_processes,,,46,"void ngx_start_cache_manager_processes (ngx_cycle_t*,ngx_uint_t)"
407203,METHOD,os\unix\ngx_process_cycle.c:<global>,TYPE_DECL,"static void
ngx_pass_open_channel(ngx_cycle_t *cycle, ngx_channel_t *ch)
{
    ngx_int_t  i;

    for (i = 0; i < ngx_last_process; i++) {

        if (i == ngx_process_slot
            || ngx_processes[i].pid == -1
            || ngx_processes[i].channel[0] == -1)
        {
            continue;
        }

        ngx_log_debug6(NGX_LOG_DEBUG_CORE, cycle->log, 0,
                      ""pass channel s:%i pid:%P fd:%d to s:%i pid:%P fd:%d"",
                      ch->slot, ch->pid, ch->fd,
                      i, ngx_processes[i].pid,
                      ngx_processes[i].channel[0]);

        /* TODO: NGX_AGAIN */

        ngx_write_channel(ngx_processes[i].channel[0],
                          ch, sizeof(ngx_channel_t), cycle->log);
    }
}",1,1,os\unix\ngx_process_cycle.c,ngx_pass_open_channel,,false,427,452,ngx_pass_open_channel,,,47,"void ngx_pass_open_channel (ngx_cycle_t*,ngx_channel_t*)"
407290,METHOD,os\unix\ngx_process_cycle.c:<global>,TYPE_DECL,"static void
ngx_signal_worker_processes(ngx_cycle_t *cycle, int signo)
{
    ngx_int_t      i;
    ngx_err_t      err;
    ngx_channel_t  ch;

    ngx_memzero(&ch, sizeof(ngx_channel_t));

#if (NGX_BROKEN_SCM_RIGHTS)

    ch.command = 0;

#else

    switch (signo) {

    case ngx_signal_value(NGX_SHUTDOWN_SIGNAL):
        ch.command = NGX_CMD_QUIT;
        break;

    case ngx_signal_value(NGX_TERMINATE_SIGNAL):
        ch.command = NGX_CMD_TERMINATE;
        break;

    case ngx_signal_value(NGX_REOPEN_SIGNAL):
        ch.command = NGX_CMD_REOPEN;
        break;

    default:
        ch.command = 0;
    }

#endif

    ch.fd = -1;


    for (i = 0; i < ngx_last_process; i++) {

        ngx_log_debug7(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
                       ""child: %i %P e:%d t:%d d:%d r:%d j:%d"",
                       i,
                       ngx_processes[i].pid,
                       ngx_processes[i].exiting,
                       ngx_processes[i].exited,
                   ...",1,1,os\unix\ngx_process_cycle.c,ngx_signal_worker_processes,,false,455,554,ngx_signal_worker_processes,,,48,"void ngx_signal_worker_processes (ngx_cycle_t*,int)"
407555,METHOD,os\unix\ngx_process_cycle.c:<global>,TYPE_DECL,"static ngx_uint_t
ngx_reap_children(ngx_cycle_t *cycle)
{
    ngx_int_t         i, n;
    ngx_uint_t        live;
    ngx_channel_t     ch;
    ngx_core_conf_t  *ccf;

    ngx_memzero(&ch, sizeof(ngx_channel_t));

    ch.command = NGX_CMD_CLOSE_CHANNEL;
    ch.fd = -1;

    live = 0;
    for (i = 0; i < ngx_last_process; i++) {

        ngx_log_debug7(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
                       ""child: %i %P e:%d t:%d d:%d r:%d j:%d"",
                       i,
                       ngx_processes[i].pid,
                       ngx_processes[i].exiting,
                       ngx_processes[i].exited,
                       ngx_processes[i].detached,
                       ngx_processes[i].respawn,
                       ngx_processes[i].just_spawn);

        if (ngx_processes[i].pid == -1) {
            continue;
        }

        if (ngx_processes[i].exited) {

            if (!ngx_processes[i].detached) {
                ngx_close_channel(ngx_processes[i].channel, c...",1,1,os\unix\ngx_process_cycle.c,ngx_reap_children,,false,557,681,ngx_reap_children,,,49,ngx_uint_t ngx_reap_children (ngx_cycle_t*)
407957,METHOD,os\unix\ngx_process_cycle.c:<global>,TYPE_DECL,"static void
ngx_master_process_exit(ngx_cycle_t *cycle)
{
    ngx_uint_t  i;

    ngx_delete_pidfile(cycle);

    ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, ""exit"");

    for (i = 0; cycle->modules[i]; i++) {
        if (cycle->modules[i]->exit_master) {
            cycle->modules[i]->exit_master(cycle);
        }
    }

    ngx_close_listening_sockets(cycle);

    /*
     * Copy ngx_cycle->log related data to the special static exit cycle,
     * log, and log file structures enough to allow a signal handler to log.
     * The handler may be called when standard ngx_cycle->log allocated from
     * ngx_cycle->pool is already destroyed.
     */


    ngx_exit_log = *ngx_log_get_file_log(ngx_cycle->log);

    ngx_exit_log_file.fd = ngx_exit_log.file->fd;
    ngx_exit_log.file = &ngx_exit_log_file;
    ngx_exit_log.next = NULL;
    ngx_exit_log.writer = NULL;

    ngx_exit_cycle.log = &ngx_exit_log;
    ngx_exit_cycle.files = ngx_cycle->files;
    ngx_exit_cycle.files_n = ngx_cycle->...",1,1,os\unix\ngx_process_cycle.c,ngx_master_process_exit,,false,684,724,ngx_master_process_exit,,,50,void ngx_master_process_exit (ngx_cycle_t*)
408067,METHOD,os\unix\ngx_process_cycle.c:<global>,TYPE_DECL,"static void
ngx_worker_process_cycle(ngx_cycle_t *cycle, void *data)
{
    ngx_int_t worker = (intptr_t) data;

    ngx_process = NGX_PROCESS_WORKER;
    ngx_worker = worker;

    ngx_worker_process_init(cycle, worker);

    ngx_setproctitle(""worker process"");

    for ( ;; ) {

        if (ngx_exiting) {
            if (ngx_event_no_timers_left() == NGX_OK) {
                ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, ""exiting"");
                ngx_worker_process_exit(cycle);
            }
        }

        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, cycle->log, 0, ""worker cycle"");

        ngx_process_events_and_timers(cycle);

        if (ngx_terminate) {
            ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, ""exiting"");
            ngx_worker_process_exit(cycle);
        }

        if (ngx_quit) {
            ngx_quit = 0;
            ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0,
                          ""gracefully shutting down"");
            ngx_setproctitle(""worker process is s...",1,1,os\unix\ngx_process_cycle.c,ngx_worker_process_cycle,,false,727,777,ngx_worker_process_cycle,,,51,"void ngx_worker_process_cycle (ngx_cycle_t*,void*)"
408176,METHOD,os\unix\ngx_process_cycle.c:<global>,TYPE_DECL,"static void
ngx_worker_process_init(ngx_cycle_t *cycle, ngx_int_t worker)
{
    sigset_t          set;
    ngx_int_t         n;
    ngx_time_t       *tp;
    ngx_uint_t        i;
    ngx_cpuset_t     *cpu_affinity;
    struct rlimit     rlmt;
    ngx_core_conf_t  *ccf;
    ngx_listening_t  *ls;

    if (ngx_set_environment(cycle, NULL) == NULL) {
        /* fatal */
        exit(2);
    }

    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);

    if (worker >= 0 && ccf->priority != 0) {
        if (setpriority(PRIO_PROCESS, 0, ccf->priority) == -1) {
            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                          ""setpriority(%d) failed"", ccf->priority);
        }
    }

    if (ccf->rlimit_nofile != NGX_CONF_UNSET) {
        rlmt.rlim_cur = (rlim_t) ccf->rlimit_nofile;
        rlmt.rlim_max = (rlim_t) ccf->rlimit_nofile;

        if (setrlimit(RLIMIT_NOFILE, &rlmt) == -1) {
            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_e...",1,1,os\unix\ngx_process_cycle.c,ngx_worker_process_init,,false,780,974,ngx_worker_process_init,,,52,"void ngx_worker_process_init (ngx_cycle_t*,ngx_int_t)"
408646,METHOD,os\unix\ngx_process_cycle.c:<global>,TYPE_DECL,"static void
ngx_worker_process_exit(ngx_cycle_t *cycle)
{
    ngx_uint_t         i;
    ngx_connection_t  *c;

    for (i = 0; cycle->modules[i]; i++) {
        if (cycle->modules[i]->exit_process) {
            cycle->modules[i]->exit_process(cycle);
        }
    }

    if (ngx_exiting) {
        c = cycle->connections;
        for (i = 0; i < cycle->connection_n; i++) {
            if (c[i].fd != -1
                && c[i].read
                && !c[i].read->accept
                && !c[i].read->channel
                && !c[i].read->resolver)
            {
                ngx_log_error(NGX_LOG_ALERT, cycle->log, 0,
                              ""*%uA open socket #%d left in connection %ui"",
                              c[i].number, c[i].fd, i);
                ngx_debug_quit = 1;
            }
        }

        if (ngx_debug_quit) {
            ngx_log_error(NGX_LOG_ALERT, cycle->log, 0, ""aborting"");
            ngx_debug_point();
        }
    }

    /*
     * Copy ngx_cycle-...",1,1,os\unix\ngx_process_cycle.c,ngx_worker_process_exit,,false,977,1035,ngx_worker_process_exit,,,53,void ngx_worker_process_exit (ngx_cycle_t*)
408849,METHOD,os\unix\ngx_process_cycle.c:<global>,TYPE_DECL,"static void
ngx_channel_handler(ngx_event_t *ev)
{
    ngx_int_t          n;
    ngx_channel_t      ch;
    ngx_connection_t  *c;

    if (ev->timedout) {
        ev->timedout = 0;
        return;
    }

    c = ev->data;

    ngx_log_debug0(NGX_LOG_DEBUG_CORE, ev->log, 0, ""channel handler"");

    for ( ;; ) {

        n = ngx_read_channel(c->fd, &ch, sizeof(ngx_channel_t), ev->log);

        ngx_log_debug1(NGX_LOG_DEBUG_CORE, ev->log, 0, ""channel: %i"", n);

        if (n == NGX_ERROR) {

            if (ngx_event_flags & NGX_USE_EPOLL_EVENT) {
                ngx_del_conn(c, 0);
            }

            ngx_close_connection(c);
            return;
        }

        if (ngx_event_flags & NGX_USE_EVENTPORT_EVENT) {
            if (ngx_add_event(ev, NGX_READ_EVENT, 0) == NGX_ERROR) {
                return;
            }
        }

        if (n == NGX_AGAIN) {
            return;
        }

        ngx_log_debug1(NGX_LOG_DEBUG_CORE, ev->log, 0,
                       ""channel comm...",1,1,os\unix\ngx_process_cycle.c,ngx_channel_handler,,false,1038,1123,ngx_channel_handler,,,54,void ngx_channel_handler (ngx_event_t*)
409082,METHOD,os\unix\ngx_process_cycle.c:<global>,TYPE_DECL,"static void
ngx_cache_manager_process_cycle(ngx_cycle_t *cycle, void *data)
{
    ngx_cache_manager_ctx_t *ctx = data;

    void         *ident[4];
    ngx_event_t   ev;

    /*
     * Set correct process type since closing listening Unix domain socket
     * in a master process also removes the Unix domain socket file.
     */
    ngx_process = NGX_PROCESS_HELPER;

    ngx_close_listening_sockets(cycle);

    /* Set a moderate number of connections for a helper process. */
    cycle->connection_n = 512;

    ngx_worker_process_init(cycle, -1);

    ngx_memzero(&ev, sizeof(ngx_event_t));
    ev.handler = ctx->handler;
    ev.data = ident;
    ev.log = cycle->log;
    ident[3] = (void *) -1;

    ngx_use_accept_mutex = 0;

    ngx_setproctitle(ctx->name);

    ngx_add_timer(&ev, ctx->delay);

    for ( ;; ) {

        if (ngx_terminate || ngx_quit) {
            ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, ""exiting"");
            exit(0);
        }

        if (ngx_reopen) {
        ...",1,1,os\unix\ngx_process_cycle.c,ngx_cache_manager_process_cycle,,false,1126,1174,ngx_cache_manager_process_cycle,,,55,"void ngx_cache_manager_process_cycle (ngx_cycle_t*,void*)"
409189,METHOD,os\unix\ngx_process_cycle.c:<global>,TYPE_DECL,"static void
ngx_cache_manager_process_handler(ngx_event_t *ev)
{
    ngx_uint_t    i;
    ngx_msec_t    next, n;
    ngx_path_t  **path;

    next = 60 * 60 * 1000;

    path = ngx_cycle->paths.elts;
    for (i = 0; i < ngx_cycle->paths.nelts; i++) {

        if (path[i]->manager) {
            n = path[i]->manager(path[i]->data);

            next = (n <= next) ? n : next;

            ngx_time_update();
        }
    }

    if (next == 0) {
        next = 1;
    }

    ngx_add_timer(ev, next);
}",1,1,os\unix\ngx_process_cycle.c,ngx_cache_manager_process_handler,,false,1177,1203,ngx_cache_manager_process_handler,,,56,void ngx_cache_manager_process_handler (ngx_event_t*)
409267,METHOD,os\unix\ngx_process_cycle.c:<global>,TYPE_DECL,"static void
ngx_cache_loader_process_handler(ngx_event_t *ev)
{
    ngx_uint_t     i;
    ngx_path_t   **path;
    ngx_cycle_t   *cycle;

    cycle = (ngx_cycle_t *) ngx_cycle;

    path = cycle->paths.elts;
    for (i = 0; i < cycle->paths.nelts; i++) {

        if (ngx_terminate || ngx_quit) {
            break;
        }

        if (path[i]->loader) {
            path[i]->loader(path[i]->data);
            ngx_time_update();
        }
    }

    exit(0);
}",1,1,os\unix\ngx_process_cycle.c,ngx_cache_loader_process_handler,,false,1206,1229,ngx_cache_loader_process_handler,,,57,void ngx_cache_loader_process_handler (ngx_event_t*)
409336,METHOD,os\unix\ngx_process_cycle.h:<global>,TYPE_DECL,<global>,1,43,os\unix\ngx_process_cycle.h,os\unix\ngx_process_cycle.h:<global>,,false,1,61,<global>,,,1,
409343,METHOD,os\unix\ngx_process_cycle.h:<global>,TYPE_DECL,void ngx_master_process_cycle(ngx_cycle_t *cycle);,6,49,os\unix\ngx_process_cycle.h,ngx_master_process_cycle,,false,37,37,ngx_master_process_cycle,,,3,void ngx_master_process_cycle (ngx_cycle_t*)
409348,METHOD,os\unix\ngx_process_cycle.h:<global>,TYPE_DECL,void ngx_single_process_cycle(ngx_cycle_t *cycle);,6,49,os\unix\ngx_process_cycle.h,ngx_single_process_cycle,,false,38,38,ngx_single_process_cycle,,,4,void ngx_single_process_cycle (ngx_cycle_t*)
409379,METHOD,os\unix\ngx_readv_chain.c:<global>,TYPE_DECL,<global>,1,1,os\unix\ngx_readv_chain.c,os\unix\ngx_readv_chain.c:<global>,,false,1,248,<global>,,,1,
409381,METHOD,os\unix\ngx_readv_chain.c:<global>,TYPE_DECL,"ssize_t
ngx_readv_chain(ngx_connection_t *c, ngx_chain_t *chain, off_t limit)
{
    u_char        *prev;
    ssize_t        n, size;
    ngx_err_t      err;
    ngx_array_t    vec;
    ngx_event_t   *rev;
    struct iovec  *iov, iovs[NGX_IOVS_PREALLOCATE];

    rev = c->read;

#if (NGX_HAVE_KQUEUE)

    if (ngx_event_flags & NGX_USE_KQUEUE_EVENT) {
        ngx_log_debug3(NGX_LOG_DEBUG_EVENT, c->log, 0,
                       ""readv: eof:%d, avail:%d, err:%d"",
                       rev->pending_eof, rev->available, rev->kq_errno);

        if (rev->available == 0) {
            if (rev->pending_eof) {
                rev->ready = 0;
                rev->eof = 1;

                ngx_log_error(NGX_LOG_INFO, c->log, rev->kq_errno,
                              ""kevent() reported about an closed connection"");

                if (rev->kq_errno) {
                    rev->error = 1;
                    ngx_set_socket_errno(rev->kq_errno);
                    return NGX_ERROR;
          ...",1,1,os\unix\ngx_readv_chain.c,ngx_readv_chain,,false,13,248,ngx_readv_chain,,,1,"ssize_t ngx_readv_chain (ngx_connection_t*,ngx_chain_t*,off_t)"
409673,METHOD,os\unix\ngx_recv.c:<global>,TYPE_DECL,<global>,1,1,os\unix\ngx_recv.c,os\unix\ngx_recv.c:<global>,,false,1,201,<global>,,,1,
409675,METHOD,os\unix\ngx_recv.c:<global>,TYPE_DECL,"ssize_t
ngx_unix_recv(ngx_connection_t *c, u_char *buf, size_t size)
{
    ssize_t       n;
    ngx_err_t     err;
    ngx_event_t  *rev;

    rev = c->read;

#if (NGX_HAVE_KQUEUE)

    if (ngx_event_flags & NGX_USE_KQUEUE_EVENT) {
        ngx_log_debug3(NGX_LOG_DEBUG_EVENT, c->log, 0,
                       ""recv: eof:%d, avail:%d, err:%d"",
                       rev->pending_eof, rev->available, rev->kq_errno);

        if (rev->available == 0) {
            if (rev->pending_eof) {
                rev->ready = 0;
                rev->eof = 1;

                if (rev->kq_errno) {
                    rev->error = 1;
                    ngx_set_socket_errno(rev->kq_errno);

                    return ngx_connection_error(c, rev->kq_errno,
                               ""kevent() reported about an closed connection"");
                }

                return 0;

            } else {
                rev->ready = 0;
                return NGX_AGAIN;
            }
        }
    }

#end...",1,1,os\unix\ngx_recv.c,ngx_unix_recv,,false,13,201,ngx_unix_recv,,,1,"ssize_t ngx_unix_recv (ngx_connection_t*,u_char*,size_t)"
409814,METHOD,os\unix\ngx_send.c:<global>,TYPE_DECL,<global>,1,1,os\unix\ngx_send.c,os\unix\ngx_send.c:<global>,,false,1,73,<global>,,,1,
409816,METHOD,os\unix\ngx_send.c:<global>,TYPE_DECL,"ssize_t
ngx_unix_send(ngx_connection_t *c, u_char *buf, size_t size)
{
    ssize_t       n;
    ngx_err_t     err;
    ngx_event_t  *wev;

    wev = c->write;

#if (NGX_HAVE_KQUEUE)

    if ((ngx_event_flags & NGX_USE_KQUEUE_EVENT) && wev->pending_eof) {
        (void) ngx_connection_error(c, wev->kq_errno,
                               ""kevent() reported about an closed connection"");
        wev->error = 1;
        return NGX_ERROR;
    }

#endif

    for ( ;; ) {
        n = send(c->fd, buf, size, 0);

        ngx_log_debug3(NGX_LOG_DEBUG_EVENT, c->log, 0,
                       ""send: fd:%d %z of %uz"", c->fd, n, size);

        if (n > 0) {
            if (n < (ssize_t) size) {
                wev->ready = 0;
            }

            c->sent += n;

            return n;
        }

        err = ngx_socket_errno;

        if (n == 0) {
            ngx_log_error(NGX_LOG_ALERT, c->log, err, ""send() returned zero"");
            wev->ready = 0;
            return n;
        }

    ...",1,1,os\unix\ngx_send.c,ngx_unix_send,,false,13,73,ngx_unix_send,,,1,"ssize_t ngx_unix_send (ngx_connection_t*,u_char*,size_t)"
409951,METHOD,os\unix\ngx_setaffinity.c:<global>,TYPE_DECL,<global>,1,6,os\unix\ngx_setaffinity.c,os\unix\ngx_setaffinity.c:<global>,,false,1,53,<global>,,,1,
409958,METHOD,os\unix\ngx_setaffinity.h:<global>,TYPE_DECL,<global>,1,41,os\unix\ngx_setaffinity.h,os\unix\ngx_setaffinity.h:<global>,,false,1,37,<global>,,,1,
409968,METHOD,os\unix\ngx_setproctitle.c:<global>,TYPE_DECL,<global>,1,38,os\unix\ngx_setproctitle.c,os\unix\ngx_setproctitle.c:<global>,,false,1,135,<global>,,,1,
409973,METHOD,os\unix\ngx_setproctitle.h:<global>,TYPE_DECL,<global>,1,42,os\unix\ngx_setproctitle.h,os\unix\ngx_setproctitle.h:<global>,,false,1,52,<global>,,,1,
409986,METHOD,os\unix\ngx_shmem.c:<global>,TYPE_DECL,<global>,1,6,os\unix\ngx_shmem.c,os\unix\ngx_shmem.c:<global>,,false,1,126,<global>,,,1,
409995,METHOD,os\unix\ngx_shmem.h:<global>,TYPE_DECL,<global>,1,35,os\unix\ngx_shmem.h,os\unix\ngx_shmem.h:<global>,,false,1,29,<global>,,,1,
410004,METHOD,os\unix\ngx_shmem.h:<global>,TYPE_DECL,ngx_int_t ngx_shm_alloc(ngx_shm_t *shm);,11,39,os\unix\ngx_shmem.h,ngx_shm_alloc,,false,25,25,ngx_shm_alloc,,,3,ngx_int_t ngx_shm_alloc (ngx_shm_t*)
410009,METHOD,os\unix\ngx_shmem.h:<global>,TYPE_DECL,void ngx_shm_free(ngx_shm_t *shm);,6,33,os\unix\ngx_shmem.h,ngx_shm_free,,false,26,26,ngx_shm_free,,,4,void ngx_shm_free (ngx_shm_t*)
410021,METHOD,os\unix\ngx_socket.c:<global>,TYPE_DECL,<global>,1,6,os\unix\ngx_socket.c,os\unix\ngx_socket.c:<global>,,false,1,116,<global>,,,1,
410023,METHOD,os\unix\ngx_socket.c:<global>,TYPE_DECL,"int
ngx_tcp_nopush(ngx_socket_t s)
{
    return 0;
}",1,1,os\unix\ngx_socket.c,ngx_tcp_nopush,,false,103,107,ngx_tcp_nopush,,,1,int ngx_tcp_nopush (ngx_socket_t)
410030,METHOD,os\unix\ngx_socket.c:<global>,TYPE_DECL,"int
ngx_tcp_push(ngx_socket_t s)
{
    return 0;
}",1,1,os\unix\ngx_socket.c,ngx_tcp_push,,false,110,114,ngx_tcp_push,,,2,int ngx_tcp_push (ngx_socket_t)
410042,METHOD,os\unix\ngx_socket.h:<global>,TYPE_DECL,<global>,1,36,os\unix\ngx_socket.h,os\unix\ngx_socket.h:<global>,,false,1,71,<global>,,,1,
410045,METHOD,os\unix\ngx_socket.h:<global>,TYPE_DECL,int ngx_tcp_nopush(ngx_socket_t s);,5,34,os\unix\ngx_socket.h,ngx_tcp_nopush,,false,48,48,ngx_tcp_nopush,,,2,int ngx_tcp_nopush (ngx_socket_t)
410050,METHOD,os\unix\ngx_socket.h:<global>,TYPE_DECL,int ngx_tcp_push(ngx_socket_t s);,5,32,os\unix\ngx_socket.h,ngx_tcp_push,,false,49,49,ngx_tcp_push,,,3,int ngx_tcp_push (ngx_socket_t)
410058,METHOD,os\unix\ngx_solaris.h:<global>,TYPE_DECL,<global>,1,37,os\unix\ngx_solaris.h,os\unix\ngx_solaris.h:<global>,,false,1,16,<global>,,,1,
410060,METHOD,os\unix\ngx_solaris.h:<global>,TYPE_DECL,"ngx_chain_t *ngx_solaris_sendfilev_chain(ngx_connection_t *c, ngx_chain_t *in,
    off_t limit);",13,16,os\unix\ngx_solaris.h,ngx_solaris_sendfilev_chain,,false,12,13,ngx_solaris_sendfilev_chain,,,1,"ngx_chain_t* ngx_solaris_sendfilev_chain (ngx_connection_t*,ngx_chain_t*,off_t)"
410156,METHOD,os\unix\ngx_solaris_config.h:<global>,TYPE_DECL,<global>,1,44,os\unix\ngx_solaris_config.h,os\unix\ngx_solaris_config.h:<global>,,false,1,112,<global>,,,1,
410166,METHOD,os\unix\ngx_solaris_init.c:<global>,TYPE_DECL,<global>,1,1,os\unix\ngx_solaris_init.c,os\unix\ngx_solaris_init.c:<global>,,false,1,77,<global>,,,1,
410189,METHOD,os\unix\ngx_solaris_init.c:<global>,TYPE_DECL,"ngx_int_t
ngx_os_specific_init(ngx_log_t *log)
{
    if (sysinfo(SI_SYSNAME, ngx_solaris_sysname, sizeof(ngx_solaris_sysname))
        == -1)
    {
        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,
                      ""sysinfo(SI_SYSNAME) failed"");
        return NGX_ERROR;
    }

    if (sysinfo(SI_RELEASE, ngx_solaris_release, sizeof(ngx_solaris_release))
        == -1)
    {
        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,
                      ""sysinfo(SI_RELEASE) failed"");
        return NGX_ERROR;
    }

    if (sysinfo(SI_VERSION, ngx_solaris_version, sizeof(ngx_solaris_version))
        == -1)
    {
        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,
                      ""sysinfo(SI_SYSNAME) failed"");
        return NGX_ERROR;
    }


    ngx_os_io = ngx_solaris_io;

    return NGX_OK;
}",1,1,os\unix\ngx_solaris_init.c,ngx_os_specific_init,,false,34,65,ngx_os_specific_init,,,9,ngx_int_t ngx_os_specific_init (ngx_log_t*)
410250,METHOD,os\unix\ngx_solaris_init.c:<global>,TYPE_DECL,"void
ngx_os_specific_status(ngx_log_t *log)
{

    ngx_log_error(NGX_LOG_NOTICE, log, 0, ""OS: %s %s"",
                  ngx_solaris_sysname, ngx_solaris_release);

    ngx_log_error(NGX_LOG_NOTICE, log, 0, ""version: %s"",
                  ngx_solaris_version);
}",1,1,os\unix\ngx_solaris_init.c,ngx_os_specific_status,,false,68,77,ngx_os_specific_status,,,10,void ngx_os_specific_status (ngx_log_t*)
410277,METHOD,os\unix\ngx_solaris_sendfilev_chain.c:<global>,TYPE_DECL,<global>,1,30,os\unix\ngx_solaris_sendfilev_chain.c,os\unix\ngx_solaris_sendfilev_chain.c:<global>,,false,1,228,<global>,,,1,
410279,METHOD,os\unix\ngx_solaris_sendfilev_chain.c:<global>,TYPE_DECL,"ngx_chain_t *
ngx_solaris_sendfilev_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)
{
    int             fd;
    u_char         *prev;
    off_t           size, send, prev_send, aligned, fprev;
    size_t          sent;
    ssize_t         n;
    ngx_int_t       eintr;
    ngx_err_t       err;
    ngx_buf_t      *file;
    ngx_uint_t      nsfv;
    sendfilevec_t  *sfv, sfvs[NGX_SENDFILEVECS];
    ngx_event_t    *wev;
    ngx_chain_t    *cl;

    wev = c->write;

    if (!wev->ready) {
        return in;
    }

    if (!c->sendfile) {
        return ngx_writev_chain(c, in, limit);
    }


    /* the maximum limit size is the maximum size_t value - the page size */

    if (limit == 0 || limit > (off_t) (NGX_MAX_SIZE_T_VALUE - ngx_pagesize)) {
        limit = NGX_MAX_SIZE_T_VALUE - ngx_pagesize;
    }


    send = 0;

    for ( ;; ) {
        fd = SFV_FD_SELF;
        prev = NULL;
        fprev = 0;
        file = NULL;
        sfv = NULL;
        eintr = 0;
        sent = 0...",1,30,os\unix\ngx_solaris_sendfilev_chain.c,ngx_solaris_sendfilev_chain,,false,41,228,ngx_solaris_sendfilev_chain,,,1,"ngx_chain_t ngx_solaris_sendfilev_chain (ngx_connection_t*,ngx_chain_t*,off_t)"
410825,METHOD,os\unix\ngx_sunpro_atomic_sparc64.h:<global>,TYPE_DECL,<global>,1,10,os\unix\ngx_sunpro_atomic_sparc64.h,os\unix\ngx_sunpro_atomic_sparc64.h:<global>,,false,1,61,<global>,,,1,
410827,METHOD,os\unix\ngx_sunpro_atomic_sparc64.h:<global>,TYPE_DECL,"ngx_atomic_uint_t
ngx_casa(ngx_atomic_uint_t set, ngx_atomic_uint_t old, ngx_atomic_t *lock);",1,74,os\unix\ngx_sunpro_atomic_sparc64.h,ngx_casa,,false,16,16,ngx_casa,,,1,"ngx_atomic_uint_t ngx_casa (ngx_atomic_uint_t,ngx_atomic_uint_t,ngx_atomic_t*)"
410834,METHOD,os\unix\ngx_sunpro_atomic_sparc64.h:<global>,TYPE_DECL,"ngx_atomic_uint_t
ngx_casxa(ngx_atomic_uint_t set, ngx_atomic_uint_t old, ngx_atomic_t *lock);",1,75,os\unix\ngx_sunpro_atomic_sparc64.h,ngx_casxa,,false,19,19,ngx_casxa,,,2,"ngx_atomic_uint_t ngx_casxa (ngx_atomic_uint_t,ngx_atomic_uint_t,ngx_atomic_t*)"
410843,METHOD,os\unix\ngx_sunpro_atomic_sparc64.h:<global>,TYPE_DECL,"ngx_atomic_cmp_set(ngx_atomic_t *lock, ngx_atomic_uint_t old,
    ngx_atomic_uint_t set)
{
    set = NGX_CASA(set, old, lock);

    return (set == old);
}",1,10,os\unix\ngx_sunpro_atomic_sparc64.h,ngx_atomic_cmp_set,,false,25,31,ngx_atomic_cmp_set,,,5,"ANY ngx_atomic_cmp_set (ngx_atomic_t*,ngx_atomic_uint_t,ngx_atomic_uint_t)"
410864,METHOD,os\unix\ngx_sunpro_atomic_sparc64.h:<global>,TYPE_DECL,"ngx_atomic_fetch_add(ngx_atomic_t *value, ngx_atomic_int_t add)
{
    ngx_atomic_uint_t  old, res;

    old = *value;

    for ( ;; ) {

        res = old + add;

        res = NGX_CASA(res, old, value);

        if (res == old) {
            return res;
        }

        old = res;
    }
}",1,14,os\unix\ngx_sunpro_atomic_sparc64.h,ngx_atomic_fetch_add,,false,35,53,ngx_atomic_fetch_add,,,8,"ANY ngx_atomic_fetch_add (ngx_atomic_t*,ngx_atomic_int_t)"
410911,METHOD,os\unix\ngx_thread.h:<global>,TYPE_DECL,<global>,1,36,os\unix\ngx_thread.h,os\unix\ngx_thread.h:<global>,,false,1,71,<global>,,,1,
410920,METHOD,os\unix\ngx_thread_cond.c:<global>,TYPE_DECL,<global>,1,1,os\unix\ngx_thread_cond.c,os\unix\ngx_thread_cond.c:<global>,,false,1,76,<global>,,,1,
410922,METHOD,os\unix\ngx_thread_cond.c:<global>,TYPE_DECL,"ngx_int_t
ngx_thread_cond_create(ngx_thread_cond_t *cond, ngx_log_t *log)
{
    ngx_err_t  err;

    err = pthread_cond_init(cond, NULL);
    if (err == 0) {
        return NGX_OK;
    }

    ngx_log_error(NGX_LOG_EMERG, log, err, ""pthread_cond_init() failed"");
    return NGX_ERROR;
}",1,1,os\unix\ngx_thread_cond.c,ngx_thread_cond_create,,false,12,24,ngx_thread_cond_create,,,1,"ngx_int_t ngx_thread_cond_create (ngx_thread_cond_t*,ngx_log_t*)"
410948,METHOD,os\unix\ngx_thread_cond.c:<global>,TYPE_DECL,"ngx_int_t
ngx_thread_cond_destroy(ngx_thread_cond_t *cond, ngx_log_t *log)
{
    ngx_err_t  err;

    err = pthread_cond_destroy(cond);
    if (err == 0) {
        return NGX_OK;
    }

    ngx_log_error(NGX_LOG_EMERG, log, err, ""pthread_cond_destroy() failed"");
    return NGX_ERROR;
}",1,1,os\unix\ngx_thread_cond.c,ngx_thread_cond_destroy,,false,27,39,ngx_thread_cond_destroy,,,2,"ngx_int_t ngx_thread_cond_destroy (ngx_thread_cond_t*,ngx_log_t*)"
410973,METHOD,os\unix\ngx_thread_cond.c:<global>,TYPE_DECL,"ngx_int_t
ngx_thread_cond_signal(ngx_thread_cond_t *cond, ngx_log_t *log)
{
    ngx_err_t  err;

    err = pthread_cond_signal(cond);
    if (err == 0) {
        return NGX_OK;
    }

    ngx_log_error(NGX_LOG_EMERG, log, err, ""pthread_cond_signal() failed"");
    return NGX_ERROR;
}",1,1,os\unix\ngx_thread_cond.c,ngx_thread_cond_signal,,false,42,54,ngx_thread_cond_signal,,,3,"ngx_int_t ngx_thread_cond_signal (ngx_thread_cond_t*,ngx_log_t*)"
410998,METHOD,os\unix\ngx_thread_cond.c:<global>,TYPE_DECL,"ngx_int_t
ngx_thread_cond_wait(ngx_thread_cond_t *cond, ngx_thread_mutex_t *mtx,
    ngx_log_t *log)
{
    ngx_err_t  err;

    err = pthread_cond_wait(cond, mtx);

#if 0
    ngx_time_update();
#endif

    if (err == 0) {
        return NGX_OK;
    }

    ngx_log_error(NGX_LOG_ALERT, log, err, ""pthread_cond_wait() failed"");

    return NGX_ERROR;
}",1,1,os\unix\ngx_thread_cond.c,ngx_thread_cond_wait,,false,57,76,ngx_thread_cond_wait,,,4,"ngx_int_t ngx_thread_cond_wait (ngx_thread_cond_t*,ngx_thread_mutex_t*,ngx_log_t*)"
411036,METHOD,os\unix\ngx_thread_id.c:<global>,TYPE_DECL,<global>,1,6,os\unix\ngx_thread_id.c,os\unix\ngx_thread_id.c:<global>,,false,1,70,<global>,,,1,
411038,METHOD,os\unix\ngx_thread_id.c:<global>,TYPE_DECL,"ngx_tid_t
ngx_thread_tid(void)
{
    return (uint64_t) (uintptr_t) pthread_self();
}",1,1,os\unix\ngx_thread_id.c,ngx_thread_tid,,false,64,68,ngx_thread_tid,,,1,ngx_tid_t ngx_thread_tid (void)
411056,METHOD,os\unix\ngx_thread_mutex.c:<global>,TYPE_DECL,<global>,1,1,os\unix\ngx_thread_mutex.c,os\unix\ngx_thread_mutex.c:<global>,,false,1,165,<global>,,,1,
411058,METHOD,os\unix\ngx_thread_mutex.c:<global>,TYPE_DECL,"ngx_int_t
ngx_thread_mutex_create(ngx_thread_mutex_t *mtx, ngx_log_t *log)
{
    ngx_err_t            err;
    pthread_mutexattr_t  attr;

    err = pthread_mutexattr_init(&attr);
    if (err != 0) {
        ngx_log_error(NGX_LOG_EMERG, log, err,
                      ""pthread_mutexattr_init() failed"");
        return NGX_ERROR;
    }

    err = pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ERRORCHECK);
    if (err != 0) {
        ngx_log_error(NGX_LOG_EMERG, log, err,
                      ""pthread_mutexattr_settype""
                      ""(PTHREAD_MUTEX_ERRORCHECK) failed"");
        return NGX_ERROR;
    }

    err = pthread_mutex_init(mtx, &attr);
    if (err != 0) {
        ngx_log_error(NGX_LOG_EMERG, log, err,
                      ""pthread_mutex_init() failed"");
        return NGX_ERROR;
    }

    err = pthread_mutexattr_destroy(&attr);
    if (err != 0) {
        ngx_log_error(NGX_LOG_ALERT, log, err,
                      ""pthread_mutexattr_destroy() failed"");
    }

    ...",1,1,os\unix\ngx_thread_mutex.c,ngx_thread_mutex_create,,false,77,112,ngx_thread_mutex_create,,,1,"ngx_int_t ngx_thread_mutex_create (ngx_thread_mutex_t*,ngx_log_t*)"
411136,METHOD,os\unix\ngx_thread_mutex.c:<global>,TYPE_DECL,"ngx_int_t
ngx_thread_mutex_destroy(ngx_thread_mutex_t *mtx, ngx_log_t *log)
{
    ngx_err_t  err;

    err = pthread_mutex_destroy(mtx);
    if (err != 0) {
        ngx_log_error(NGX_LOG_ALERT, log, err,
                      ""pthread_mutex_destroy() failed"");
        return NGX_ERROR;
    }

    return NGX_OK;
}",1,1,os\unix\ngx_thread_mutex.c,ngx_thread_mutex_destroy,,false,115,128,ngx_thread_mutex_destroy,,,2,"ngx_int_t ngx_thread_mutex_destroy (ngx_thread_mutex_t*,ngx_log_t*)"
411161,METHOD,os\unix\ngx_thread_mutex.c:<global>,TYPE_DECL,"ngx_int_t
ngx_thread_mutex_lock(ngx_thread_mutex_t *mtx, ngx_log_t *log)
{
    ngx_err_t  err;

    err = pthread_mutex_lock(mtx);
    if (err == 0) {
        return NGX_OK;
    }

    ngx_log_error(NGX_LOG_ALERT, log, err, ""pthread_mutex_lock() failed"");

    return NGX_ERROR;
}",1,1,os\unix\ngx_thread_mutex.c,ngx_thread_mutex_lock,,false,131,144,ngx_thread_mutex_lock,,,3,"ngx_int_t ngx_thread_mutex_lock (ngx_thread_mutex_t*,ngx_log_t*)"
411186,METHOD,os\unix\ngx_thread_mutex.c:<global>,TYPE_DECL,"ngx_int_t
ngx_thread_mutex_unlock(ngx_thread_mutex_t *mtx, ngx_log_t *log)
{
    ngx_err_t  err;

    err = pthread_mutex_unlock(mtx);

#if 0
    ngx_time_update();
#endif

    if (err == 0) {
        return NGX_OK;
    }

    ngx_log_error(NGX_LOG_ALERT, log, err, ""pthread_mutex_unlock() failed"");

    return NGX_ERROR;
}",1,1,os\unix\ngx_thread_mutex.c,ngx_thread_mutex_unlock,,false,147,165,ngx_thread_mutex_unlock,,,4,"ngx_int_t ngx_thread_mutex_unlock (ngx_thread_mutex_t*,ngx_log_t*)"
411218,METHOD,os\unix\ngx_time.c:<global>,TYPE_DECL,<global>,1,1,os\unix\ngx_time.c,os\unix\ngx_time.c:<global>,,false,1,104,<global>,,,1,
411220,METHOD,os\unix\ngx_time.c:<global>,TYPE_DECL,"void
ngx_timezone_update(void)
{
#if (NGX_FREEBSD)

    if (getenv(""TZ"")) {
        return;
    }

    putenv(""TZ=UTC"");

    tzset();

    unsetenv(""TZ"");

    tzset();

#elif (NGX_LINUX)
    time_t      s;
    struct tm  *t;
    char        buf[4];

    s = time(0);

    t = localtime(&s);

    strftime(buf, 4, ""%H"", t);

#endif
}",1,1,os\unix\ngx_time.c,ngx_timezone_update,,false,24,53,ngx_timezone_update,,,1,void ngx_timezone_update (void)
411225,METHOD,os\unix\ngx_time.c:<global>,TYPE_DECL,"void
ngx_localtime(time_t s, ngx_tm_t *tm)
{
#if (NGX_HAVE_LOCALTIME_R)
    (void) localtime_r(&s, tm);

#else
    ngx_tm_t  *t;

    t = localtime(&s);
    *tm = *t;

#endif

    tm->ngx_tm_mon++;
    tm->ngx_tm_year += 1900;
}",1,1,os\unix\ngx_time.c,ngx_localtime,,false,56,72,ngx_localtime,,,2,"void ngx_localtime (time_t,ngx_tm_t*)"
411251,METHOD,os\unix\ngx_time.c:<global>,TYPE_DECL,"void
ngx_libc_localtime(time_t s, struct tm *tm)
{
#if (NGX_HAVE_LOCALTIME_R)
    (void) localtime_r(&s, tm);

#else
    struct tm  *t;

    t = localtime(&s);
    *tm = *t;

#endif
}",1,1,os\unix\ngx_time.c,ngx_libc_localtime,,false,75,88,ngx_libc_localtime,,,3,"void ngx_libc_localtime (time_t,tm*)"
411268,METHOD,os\unix\ngx_time.c:<global>,TYPE_DECL,"void
ngx_libc_gmtime(time_t s, struct tm *tm)
{
#if (NGX_HAVE_LOCALTIME_R)
    (void) gmtime_r(&s, tm);

#else
    struct tm  *t;

    t = gmtime(&s);
    *tm = *t;

#endif
}",1,1,os\unix\ngx_time.c,ngx_libc_gmtime,,false,91,104,ngx_libc_gmtime,,,4,"void ngx_libc_gmtime (time_t,tm*)"
411292,METHOD,os\unix\ngx_time.h:<global>,TYPE_DECL,<global>,1,34,os\unix\ngx_time.h,os\unix\ngx_time.h:<global>,,false,1,66,<global>,,,1,
411298,METHOD,os\unix\ngx_time.h:<global>,TYPE_DECL,void ngx_timezone_update(void);,6,30,os\unix\ngx_time.h,ngx_timezone_update,,false,56,56,ngx_timezone_update,,,5,void ngx_timezone_update (void)
411303,METHOD,os\unix\ngx_time.h:<global>,TYPE_DECL,"void ngx_localtime(time_t s, ngx_tm_t *tm);",6,42,os\unix\ngx_time.h,ngx_localtime,,false,57,57,ngx_localtime,,,6,"void ngx_localtime (time_t,ngx_tm_t*)"
411309,METHOD,os\unix\ngx_time.h:<global>,TYPE_DECL,"void ngx_libc_localtime(time_t s, struct tm *tm);",6,48,os\unix\ngx_time.h,ngx_libc_localtime,,false,58,58,ngx_libc_localtime,,,7,"void ngx_libc_localtime (time_t,tm*)"
411315,METHOD,os\unix\ngx_time.h:<global>,TYPE_DECL,"void ngx_libc_gmtime(time_t s, struct tm *tm);",6,45,os\unix\ngx_time.h,ngx_libc_gmtime,,false,59,59,ngx_libc_gmtime,,,8,"void ngx_libc_gmtime (time_t,tm*)"
411330,METHOD,os\unix\ngx_udp_recv.c:<global>,TYPE_DECL,<global>,1,1,os\unix\ngx_udp_recv.c,os\unix\ngx_udp_recv.c:<global>,,false,1,72,<global>,,,1,
411332,METHOD,os\unix\ngx_udp_recv.c:<global>,TYPE_DECL,"ssize_t
ngx_udp_unix_recv(ngx_connection_t *c, u_char *buf, size_t size)
{
    ssize_t       n;
    ngx_err_t     err;
    ngx_event_t  *rev;

    rev = c->read;

    do {
        n = recv(c->fd, buf, size, 0);

        ngx_log_debug3(NGX_LOG_DEBUG_EVENT, c->log, 0,
                       ""recv: fd:%d %z of %uz"", c->fd, n, size);

        if (n >= 0) {

#if (NGX_HAVE_KQUEUE)

            if (ngx_event_flags & NGX_USE_KQUEUE_EVENT) {
                rev->available -= n;

                /*
                 * rev->available may be negative here because some additional
                 * bytes may be received between kevent() and recv()
                 */

                if (rev->available <= 0) {
                    rev->ready = 0;
                    rev->available = 0;
                }
            }

#endif

            return n;
        }

        err = ngx_socket_errno;

        if (err == NGX_EAGAIN || err == NGX_EINTR) {
            ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log,...",1,1,os\unix\ngx_udp_recv.c,ngx_udp_unix_recv,,false,13,72,ngx_udp_unix_recv,,,1,"ssize_t ngx_udp_unix_recv (ngx_connection_t*,u_char*,size_t)"
411437,METHOD,os\unix\ngx_udp_send.c:<global>,TYPE_DECL,<global>,1,1,os\unix\ngx_udp_send.c,os\unix\ngx_udp_send.c:<global>,,false,1,56,<global>,,,1,
411439,METHOD,os\unix\ngx_udp_send.c:<global>,TYPE_DECL,"ssize_t
ngx_udp_unix_send(ngx_connection_t *c, u_char *buf, size_t size)
{
    ssize_t       n;
    ngx_err_t     err;
    ngx_event_t  *wev;

    wev = c->write;

    for ( ;; ) {
        n = sendto(c->fd, buf, size, 0, c->sockaddr, c->socklen);

        ngx_log_debug4(NGX_LOG_DEBUG_EVENT, c->log, 0,
                       ""sendto: fd:%d %z of %uz to \""%V\"""",
                       c->fd, n, size, &c->addr_text);

        if (n >= 0) {
            if ((size_t) n != size) {
                wev->error = 1;
                (void) ngx_connection_error(c, 0, ""sendto() incomplete"");
                return NGX_ERROR;
            }

            c->sent += n;

            return n;
        }

        err = ngx_socket_errno;

        if (err == NGX_EAGAIN) {
            wev->ready = 0;
            ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, NGX_EAGAIN,
                           ""sendto() not ready"");
            return NGX_AGAIN;
        }

        if (err != NGX_EINTR) {
            wev->e...",1,1,os\unix\ngx_udp_send.c,ngx_udp_unix_send,,false,13,56,ngx_udp_unix_send,,,1,"ssize_t ngx_udp_unix_send (ngx_connection_t*,u_char*,size_t)"
411569,METHOD,os\unix\ngx_udp_sendmsg_chain.c:<global>,TYPE_DECL,<global>,1,1,os\unix\ngx_udp_sendmsg_chain.c,os\unix\ngx_udp_sendmsg_chain.c:<global>,,false,1,335,<global>,,,1,
411571,METHOD,os\unix\ngx_udp_sendmsg_chain.c:<global>,TYPE_DECL,"static ngx_chain_t *ngx_udp_output_chain_to_iovec(ngx_iovec_t *vec,
    ngx_chain_t *in, ngx_log_t *log);",20,36,os\unix\ngx_udp_sendmsg_chain.c,ngx_udp_output_chain_to_iovec,,false,13,14,ngx_udp_output_chain_to_iovec,,,1,"ngx_chain_t* ngx_udp_output_chain_to_iovec (ngx_iovec_t*,ngx_chain_t*,ngx_log_t*)"
411578,METHOD,os\unix\ngx_udp_sendmsg_chain.c:<global>,TYPE_DECL,"static ssize_t ngx_sendmsg(ngx_connection_t *c, ngx_iovec_t *vec);",16,65,os\unix\ngx_udp_sendmsg_chain.c,ngx_sendmsg,,false,15,15,ngx_sendmsg,,,2,"ssize_t ngx_sendmsg (ngx_connection_t*,ngx_iovec_t*)"
411584,METHOD,os\unix\ngx_udp_sendmsg_chain.c:<global>,TYPE_DECL,"ngx_chain_t *
ngx_udp_unix_sendmsg_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)
{
    ssize_t        n;
    off_t          send;
    ngx_chain_t   *cl;
    ngx_event_t   *wev;
    ngx_iovec_t    vec;
    struct iovec   iovs[NGX_IOVS_PREALLOCATE];

    wev = c->write;

    if (!wev->ready) {
        return in;
    }

#if (NGX_HAVE_KQUEUE)

    if ((ngx_event_flags & NGX_USE_KQUEUE_EVENT) && wev->pending_eof) {
        (void) ngx_connection_error(c, wev->kq_errno,
                               ""kevent() reported about an closed connection"");
        wev->error = 1;
        return NGX_CHAIN_ERROR;
    }

#endif

    /* the maximum limit size is the maximum size_t value - the page size */

    if (limit == 0 || limit > (off_t) (NGX_MAX_SIZE_T_VALUE - ngx_pagesize)) {
        limit = NGX_MAX_SIZE_T_VALUE - ngx_pagesize;
    }

    send = 0;

    vec.iovs = iovs;
    vec.nalloc = NGX_IOVS_PREALLOCATE;

    for ( ;; ) {

        /* create the iovec and coalesce the neighbourin...",1,1,os\unix\ngx_udp_sendmsg_chain.c,ngx_udp_unix_sendmsg_chain,,false,18,110,ngx_udp_unix_sendmsg_chain,,,3,"ngx_chain_t ngx_udp_unix_sendmsg_chain (ngx_connection_t*,ngx_chain_t*,off_t)"
411781,METHOD,os\unix\ngx_udp_sendmsg_chain.c:<global>,TYPE_DECL,"static ngx_chain_t *
ngx_udp_output_chain_to_iovec(ngx_iovec_t *vec, ngx_chain_t *in, ngx_log_t *log)
{
    size_t         total, size;
    u_char        *prev;
    ngx_uint_t     n, flush;
    ngx_chain_t   *cl;
    struct iovec  *iov;

    cl = in;
    iov = NULL;
    prev = NULL;
    total = 0;
    n = 0;
    flush = 0;

    for ( /* void */ ; in && !flush; in = in->next) {

        if (in->buf->flush || in->buf->last_buf) {
            flush = 1;
        }

        if (ngx_buf_special(in->buf)) {
            continue;
        }

        if (in->buf->in_file) {
            break;
        }

        if (!ngx_buf_in_memory(in->buf)) {
            ngx_log_error(NGX_LOG_ALERT, log, 0,
                          ""bad buf in output chain ""
                          ""t:%d r:%d f:%d %p %p-%p %p %O-%O"",
                          in->buf->temporary,
                          in->buf->recycled,
                          in->buf->in_file,
                          in->buf->start,
            ...",1,1,os\unix\ngx_udp_sendmsg_chain.c,ngx_udp_output_chain_to_iovec,,false,113,196,ngx_udp_output_chain_to_iovec,,,4,"ngx_chain_t ngx_udp_output_chain_to_iovec (ngx_iovec_t*,ngx_chain_t*,ngx_log_t*)"
412014,METHOD,os\unix\ngx_udp_sendmsg_chain.c:<global>,TYPE_DECL,"static ssize_t
ngx_sendmsg(ngx_connection_t *c, ngx_iovec_t *vec)
{
    ssize_t        n;
    ngx_err_t      err;
    struct msghdr  msg;

#if (NGX_HAVE_MSGHDR_MSG_CONTROL)

#if (NGX_HAVE_IP_SENDSRCADDR)
    u_char         msg_control[CMSG_SPACE(sizeof(struct in_addr))];
#elif (NGX_HAVE_IP_PKTINFO)
    u_char         msg_control[CMSG_SPACE(sizeof(struct in_pktinfo))];
#endif

#if (NGX_HAVE_INET6 && NGX_HAVE_IPV6_RECVPKTINFO)
    u_char         msg_control6[CMSG_SPACE(sizeof(struct in6_pktinfo))];
#endif

#endif

    ngx_memzero(&msg, sizeof(struct msghdr));

    if (c->socklen) {
        msg.msg_name = c->sockaddr;
        msg.msg_namelen = c->socklen;
    }

    msg.msg_iov = vec->iovs;
    msg.msg_iovlen = vec->count;

#if (NGX_HAVE_MSGHDR_MSG_CONTROL)

    if (c->listening && c->listening->wildcard && c->local_sockaddr) {

#if (NGX_HAVE_IP_SENDSRCADDR)

        if (c->local_sockaddr->sa_family == AF_INET) {
            struct cmsghdr      *cmsg;
            struct in_addr      *a...",1,1,os\unix\ngx_udp_sendmsg_chain.c,ngx_sendmsg,,false,199,335,ngx_sendmsg,,,5,"ssize_t ngx_sendmsg (ngx_connection_t*,ngx_iovec_t*)"
412138,METHOD,os\unix\ngx_user.c:<global>,TYPE_DECL,<global>,1,22,os\unix\ngx_user.c,os\unix\ngx_user.c:<global>,,false,1,76,<global>,,,1,
412147,METHOD,os\unix\ngx_user.h:<global>,TYPE_DECL,<global>,1,34,os\unix\ngx_user.h,os\unix\ngx_user.h:<global>,,false,1,24,<global>,,,1,
412151,METHOD,os\unix\ngx_user.h:<global>,TYPE_DECL,"ngx_int_t ngx_libc_crypt(ngx_pool_t *pool, u_char *key, u_char *salt,
    u_char **encrypted);",11,23,os\unix\ngx_user.h,ngx_libc_crypt,,false,20,21,ngx_libc_crypt,,,3,"ngx_int_t ngx_libc_crypt (ngx_pool_t*,u_char*,u_char*,u_char**)"
412168,METHOD,os\unix\ngx_writev_chain.c:<global>,TYPE_DECL,<global>,1,1,os\unix\ngx_writev_chain.c,os\unix\ngx_writev_chain.c:<global>,,false,1,216,<global>,,,1,
412170,METHOD,os\unix\ngx_writev_chain.c:<global>,TYPE_DECL,"ngx_chain_t *
ngx_writev_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)
{
    ssize_t        n, sent;
    off_t          send, prev_send;
    ngx_chain_t   *cl;
    ngx_event_t   *wev;
    ngx_iovec_t    vec;
    struct iovec   iovs[NGX_IOVS_PREALLOCATE];

    wev = c->write;

    if (!wev->ready) {
        return in;
    }

#if (NGX_HAVE_KQUEUE)

    if ((ngx_event_flags & NGX_USE_KQUEUE_EVENT) && wev->pending_eof) {
        (void) ngx_connection_error(c, wev->kq_errno,
                               ""kevent() reported about an closed connection"");
        wev->error = 1;
        return NGX_CHAIN_ERROR;
    }

#endif

    /* the maximum limit size is the maximum size_t value - the page size */

    if (limit == 0 || limit > (off_t) (NGX_MAX_SIZE_T_VALUE - ngx_pagesize)) {
        limit = NGX_MAX_SIZE_T_VALUE - ngx_pagesize;
    }

    send = 0;

    vec.iovs = iovs;
    vec.nalloc = NGX_IOVS_PREALLOCATE;

    for ( ;; ) {
        prev_send = send;

        /* create the i...",1,1,os\unix\ngx_writev_chain.c,ngx_writev_chain,,false,13,104,ngx_writev_chain,,,1,"ngx_chain_t ngx_writev_chain (ngx_connection_t*,ngx_chain_t*,off_t)"
412378,METHOD,os\unix\ngx_writev_chain.c:<global>,TYPE_DECL,"ngx_chain_t *
ngx_output_chain_to_iovec(ngx_iovec_t *vec, ngx_chain_t *in, size_t limit,
    ngx_log_t *log)
{
    size_t         total, size;
    u_char        *prev;
    ngx_uint_t     n;
    struct iovec  *iov;

    iov = NULL;
    prev = NULL;
    total = 0;
    n = 0;

    for ( /* void */ ; in && total < limit; in = in->next) {

        if (ngx_buf_special(in->buf)) {
            continue;
        }

        if (in->buf->in_file) {
            break;
        }

        if (!ngx_buf_in_memory(in->buf)) {
            ngx_log_error(NGX_LOG_ALERT, log, 0,
                          ""bad buf in output chain ""
                          ""t:%d r:%d f:%d %p %p-%p %p %O-%O"",
                          in->buf->temporary,
                          in->buf->recycled,
                          in->buf->in_file,
                          in->buf->start,
                          in->buf->pos,
                          in->buf->last,
                          in->buf->file,
                   ...",1,1,os\unix\ngx_writev_chain.c,ngx_output_chain_to_iovec,,false,107,178,ngx_output_chain_to_iovec,,,2,"ngx_chain_t ngx_output_chain_to_iovec (ngx_iovec_t*,ngx_chain_t*,size_t,ngx_log_t*)"
412589,METHOD,os\unix\ngx_writev_chain.c:<global>,TYPE_DECL,"ssize_t
ngx_writev(ngx_connection_t *c, ngx_iovec_t *vec)
{
    ssize_t    n;
    ngx_err_t  err;

eintr:

    n = writev(c->fd, vec->iovs, vec->count);

    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,
                   ""writev: %z of %uz"", n, vec->size);

    if (n == -1) {
        err = ngx_errno;

        switch (err) {
        case NGX_EAGAIN:
            ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, err,
                           ""writev() not ready"");
            return NGX_AGAIN;

        case NGX_EINTR:
            ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, err,
                           ""writev() was interrupted"");
            goto eintr;

        default:
            c->write->error = 1;
            ngx_connection_error(c, err, ""writev() failed"");
            return NGX_ERROR;
        }
    }

    return n;
}",1,1,os\unix\ngx_writev_chain.c,ngx_writev,,false,181,216,ngx_writev,,,3,"ssize_t ngx_writev (ngx_connection_t*,ngx_iovec_t*)"
412677,METHOD,os\win32\ngx_alloc.c:<global>,TYPE_DECL,<global>,1,1,os\win32\ngx_alloc.c,os\win32\ngx_alloc.c:<global>,,false,1,44,<global>,,,1,
412682,METHOD,os\win32\ngx_alloc.c:<global>,TYPE_DECL,"void *ngx_alloc(size_t size, ngx_log_t *log)
{
    void  *p;

    p = malloc(size);
    if (p == NULL) {
        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,
                      ""malloc(%uz) failed"", size);
    }

    ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, log, 0, ""malloc: %p:%uz"", p, size);

    return p;
}",1,1,os\win32\ngx_alloc.c,ngx_alloc,,false,17,30,ngx_alloc,,,4,"void* ngx_alloc (size_t,ngx_log_t*)"
412713,METHOD,os\win32\ngx_alloc.c:<global>,TYPE_DECL,"void *ngx_calloc(size_t size, ngx_log_t *log)
{
    void  *p;

    p = ngx_alloc(size, log);

    if (p) {
        ngx_memzero(p, size);
    }

    return p;
}",1,1,os\win32\ngx_alloc.c,ngx_calloc,,false,33,44,ngx_calloc,,,5,"void* ngx_calloc (size_t,ngx_log_t*)"
412740,METHOD,os\win32\ngx_alloc.h:<global>,TYPE_DECL,<global>,1,35,os\win32\ngx_alloc.h,os\win32\ngx_alloc.h:<global>,,false,1,27,<global>,,,1,
412742,METHOD,os\win32\ngx_alloc.h:<global>,TYPE_DECL,"void *ngx_alloc(size_t size, ngx_log_t *log);",6,44,os\win32\ngx_alloc.h,ngx_alloc,,false,16,16,ngx_alloc,,,1,"void* ngx_alloc (size_t,ngx_log_t*)"
412748,METHOD,os\win32\ngx_alloc.h:<global>,TYPE_DECL,"void *ngx_calloc(size_t size, ngx_log_t *log);",6,45,os\win32\ngx_alloc.h,ngx_calloc,,false,17,17,ngx_calloc,,,2,"void* ngx_calloc (size_t,ngx_log_t*)"
412764,METHOD,os\win32\ngx_atomic.h:<global>,TYPE_DECL,<global>,1,36,os\win32\ngx_atomic.h,os\win32\ngx_atomic.h:<global>,,false,1,69,<global>,,,1,
412769,METHOD,os\win32\ngx_atomic.h:<global>,TYPE_DECL,"void ngx_spinlock(ngx_atomic_t *lock, ngx_atomic_int_t value, ngx_uint_t spin);",6,78,os\win32\ngx_atomic.h,ngx_spinlock,,false,63,63,ngx_spinlock,,,4,"void ngx_spinlock (ngx_atomic_t*,ngx_atomic_int_t,ngx_uint_t)"
412783,METHOD,os\win32\ngx_dlopen.c:<global>,TYPE_DECL,<global>,1,1,os\win32\ngx_dlopen.c,os\win32\ngx_dlopen.c:<global>,,false,1,22,<global>,,,1,
412785,METHOD,os\win32\ngx_dlopen.c:<global>,TYPE_DECL,"char *
ngx_dlerror(void)
{
    u_char         *p;
    static u_char   errstr[NGX_MAX_ERROR_STR];

    p = ngx_strerror(ngx_errno, errstr, NGX_MAX_ERROR_STR);
    *p = '\0';

    return (char *) errstr;
}",1,1,os\win32\ngx_dlopen.c,ngx_dlerror,,false,12,22,ngx_dlerror,,,1,char* ngx_dlerror (void)
412813,METHOD,os\win32\ngx_dlopen.h:<global>,TYPE_DECL,<global>,1,36,os\win32\ngx_dlopen.h,os\win32\ngx_dlopen.h:<global>,,false,1,32,<global>,,,1,
412815,METHOD,os\win32\ngx_dlopen.h:<global>,TYPE_DECL,char *ngx_dlerror(void);,6,23,os\win32\ngx_dlopen.h,ngx_dlerror,,false,29,29,ngx_dlerror,,,1,char* ngx_dlerror (void)
412827,METHOD,os\win32\ngx_errno.c:<global>,TYPE_DECL,<global>,1,1,os\win32\ngx_errno.c,os\win32\ngx_errno.c:<global>,,false,1,60,<global>,,,1,
412829,METHOD,os\win32\ngx_errno.c:<global>,TYPE_DECL,"u_char *
ngx_strerror(ngx_err_t err, u_char *errstr, size_t size)
{
    u_int          len;
    static u_long  lang = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);

    if (size == 0) {
        return errstr;
    }

    len = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                        NULL, err, lang, (char *) errstr, size, NULL);

    if (len == 0 && lang) {

        /*
         * Try to use English messages first and fallback to a language,
         * based on locale: non-English Windows have no English messages
         * at all.  This way allows to use English messages at least on
         * Windows with MUI.
         */

        lang = 0;

        len = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                            NULL, err, lang, (char *) errstr, size, NULL);
    }

    if (len == 0) {
        return ngx_snprintf(errstr, size,
                            ""FormatMessage() error:(%d)"", GetLastError());
    }

    /* remove "".\r\n\0"" */
    while (errstr[len] == '\0...",1,1,os\win32\ngx_errno.c,ngx_strerror,,false,12,53,ngx_strerror,,,1,"u_char ngx_strerror (ngx_err_t,u_char*,size_t)"
412928,METHOD,os\win32\ngx_errno.c:<global>,TYPE_DECL,"ngx_int_t
ngx_strerror_init(void)
{
    return NGX_OK;
}",1,1,os\win32\ngx_errno.c,ngx_strerror_init,,false,56,60,ngx_strerror_init,,,2,ngx_int_t ngx_strerror_init (void)
412942,METHOD,os\win32\ngx_errno.h:<global>,TYPE_DECL,<global>,1,35,os\win32\ngx_errno.h,os\win32\ngx_errno.h:<global>,,false,1,71,<global>,,,1,
412945,METHOD,os\win32\ngx_errno.h:<global>,TYPE_DECL,"u_char *ngx_strerror(ngx_err_t err, u_char *errstr, size_t size);",8,64,os\win32\ngx_errno.h,ngx_strerror,,false,67,67,ngx_strerror,,,2,"u_char* ngx_strerror (ngx_err_t,u_char*,size_t)"
412952,METHOD,os\win32\ngx_errno.h:<global>,TYPE_DECL,ngx_int_t ngx_strerror_init(void);,11,33,os\win32\ngx_errno.h,ngx_strerror_init,,false,68,68,ngx_strerror_init,,,3,ngx_int_t ngx_strerror_init (void)
412964,METHOD,os\win32\ngx_event_log.c:<global>,TYPE_DECL,<global>,1,25,os\win32\ngx_event_log.c,os\win32\ngx_event_log.c:<global>,,false,1,99,<global>,,,1,
412968,METHOD,os\win32\ngx_event_log.c:<global>,TYPE_DECL,"ngx_event_log(ngx_err_t err, const char *fmt, ...)
{
    u_char         *p, *last;
    long            types;
    HKEY            key;
    HANDLE          ev;
    va_list         args;
    u_char          text[NGX_MAX_ERROR_STR];
    const char     *msgarg[9];
    static u_char   netmsg[] = ""%SystemRoot%\\System32\\netmsg.dll"";

    last = text + NGX_MAX_ERROR_STR;
    p = text + GetModuleFileName(NULL, (char *) text, NGX_MAX_ERROR_STR - 50);

    *p++ = ':';
    ngx_linefeed(p);

    va_start(args, fmt);
    p = ngx_vslprintf(p, last, fmt, args);
    va_end(args);

    if (err) {
        p = ngx_log_errno(p, last, err);
    }

    if (p > last - NGX_LINEFEED_SIZE - 1) {
        p = last - NGX_LINEFEED_SIZE - 1;
    }

    ngx_linefeed(p);

    *p = '\0';

    /*
     * we do not log errors here since we use
     * Event Log only to log our own logs open errors
     */

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
           ""SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\...",1,25,os\win32\ngx_event_log.c,ngx_event_log,,false,15,99,ngx_event_log,,,3,"ANY ngx_event_log (ngx_err_t,char*...)"
413180,METHOD,os\win32\ngx_files.c:<global>,TYPE_DECL,<global>,1,22,os\win32\ngx_files.c,os\win32\ngx_files.c:<global>,,false,1,899,<global>,,,1,
413182,METHOD,os\win32\ngx_files.c:<global>,TYPE_DECL,"static ngx_int_t ngx_win32_check_filename(u_char *name, u_short *u,
    size_t len);",18,15,os\win32\ngx_files.c,ngx_win32_check_filename,,false,14,15,ngx_win32_check_filename,,,1,"ngx_int_t ngx_win32_check_filename (u_char*,u_short*,size_t)"
413189,METHOD,os\win32\ngx_files.c:<global>,TYPE_DECL,"static u_short *ngx_utf8_to_utf16(u_short *utf16, u_char *utf8, size_t *len);",16,76,os\win32\ngx_files.c,ngx_utf8_to_utf16,,false,16,16,ngx_utf8_to_utf16,,,2,"u_short* ngx_utf8_to_utf16 (u_short*,u_char*,size_t*)"
413196,METHOD,os\win32\ngx_files.c:<global>,TYPE_DECL,"ngx_fd_t
ngx_open_file(u_char *name, u_long mode, u_long create, u_long access)
{
    size_t      len;
    u_short    *u;
    ngx_fd_t    fd;
    ngx_err_t   err;
    u_short     utf16[NGX_UTF16_BUFLEN];

    len = NGX_UTF16_BUFLEN;
    u = ngx_utf8_to_utf16(utf16, name, &len);

    if (u == NULL) {
        return INVALID_HANDLE_VALUE;
    }

    fd = INVALID_HANDLE_VALUE;

    if (create == NGX_FILE_OPEN
        && ngx_win32_check_filename(name, u, len) != NGX_OK)
    {
        goto failed;
    }

    fd = CreateFileW(u, mode,
                     FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                     NULL, create, FILE_FLAG_BACKUP_SEMANTICS, NULL);

failed:

    if (u != utf16) {
        err = ngx_errno;
        ngx_free(u);
        ngx_set_errno(err);
    }

    return fd;
}",1,22,os\win32\ngx_files.c,ngx_open_file,,false,21,58,ngx_open_file,,,3,"ngx_fd_t ngx_open_file (u_char*,u_long,u_long,u_long)"
413273,METHOD,os\win32\ngx_files.c:<global>,TYPE_DECL,"ssize_t
ngx_read_file(ngx_file_t *file, u_char *buf, size_t size, off_t offset)
{
    u_long      n;
    ngx_err_t   err;
    OVERLAPPED  ovlp, *povlp;

    ovlp.Internal = 0;
    ovlp.InternalHigh = 0;
    ovlp.Offset = (u_long) offset;
    ovlp.OffsetHigh = (u_long) (offset >> 32);
    ovlp.hEvent = NULL;

    povlp = &ovlp;

    if (ReadFile(file->fd, buf, size, &n, povlp) == 0) {
        err = ngx_errno;

        if (err == ERROR_HANDLE_EOF) {
            return 0;
        }

        ngx_log_error(NGX_LOG_ERR, file->log, err,
                      ""ReadFile() \""%s\"" failed"", file->name.data);
        return NGX_ERROR;
    }

    file->offset += n;

    return n;
}",1,1,os\win32\ngx_files.c,ngx_read_file,,false,61,91,ngx_read_file,,,4,"ssize_t ngx_read_file (ngx_file_t*,u_char*,size_t,off_t)"
413363,METHOD,os\win32\ngx_files.c:<global>,TYPE_DECL,"ssize_t
ngx_write_file(ngx_file_t *file, u_char *buf, size_t size, off_t offset)
{
    u_long      n;
    OVERLAPPED  ovlp, *povlp;

    ovlp.Internal = 0;
    ovlp.InternalHigh = 0;
    ovlp.Offset = (u_long) offset;
    ovlp.OffsetHigh = (u_long) (offset >> 32);
    ovlp.hEvent = NULL;

    povlp = &ovlp;

    if (WriteFile(file->fd, buf, size, &n, povlp) == 0) {
        ngx_log_error(NGX_LOG_ERR, file->log, ngx_errno,
                      ""WriteFile() \""%s\"" failed"", file->name.data);
        return NGX_ERROR;
    }

    if (n != size) {
        ngx_log_error(NGX_LOG_CRIT, file->log, 0,
                      ""WriteFile() \""%s\"" has written only %ul of %uz"",
                      file->name.data, n, size);
        return NGX_ERROR;
    }

    file->offset += n;

    return n;
}",1,1,os\win32\ngx_files.c,ngx_write_file,,false,94,124,ngx_write_file,,,5,"ssize_t ngx_write_file (ngx_file_t*,u_char*,size_t,off_t)"
413463,METHOD,os\win32\ngx_files.c:<global>,TYPE_DECL,"ssize_t
ngx_write_chain_to_file(ngx_file_t *file, ngx_chain_t *cl, off_t offset,
    ngx_pool_t *pool)
{
    u_char   *buf, *prev;
    size_t    size;
    ssize_t   total, n;

    total = 0;

    while (cl) {
        buf = cl->buf->pos;
        prev = buf;
        size = 0;

        /* coalesce the neighbouring bufs */

        while (cl && prev == cl->buf->pos) {
            size += cl->buf->last - cl->buf->pos;
            prev = cl->buf->last;
            cl = cl->next;
        }

        n = ngx_write_file(file, buf, size, offset);

        if (n == NGX_ERROR) {
            return NGX_ERROR;
        }

        total += n;
        offset += n;
    }

    return total;
}",1,1,os\win32\ngx_files.c,ngx_write_chain_to_file,,false,127,161,ngx_write_chain_to_file,,,6,"ssize_t ngx_write_chain_to_file (ngx_file_t*,ngx_chain_t*,off_t,ngx_pool_t*)"
413553,METHOD,os\win32\ngx_files.c:<global>,TYPE_DECL,"ssize_t
ngx_read_fd(ngx_fd_t fd, void *buf, size_t size)
{
    u_long  n;

    if (ReadFile(fd, buf, size, &n, NULL) != 0) {
        return (size_t) n;
    }

    return -1;
}",1,1,os\win32\ngx_files.c,ngx_read_fd,,false,164,174,ngx_read_fd,,,7,"ssize_t ngx_read_fd (ngx_fd_t,void*,size_t)"
413579,METHOD,os\win32\ngx_files.c:<global>,TYPE_DECL,"ssize_t
ngx_write_fd(ngx_fd_t fd, void *buf, size_t size)
{
    u_long  n;

    if (WriteFile(fd, buf, size, &n, NULL) != 0) {
        return (size_t) n;
    }

    return -1;
}",1,1,os\win32\ngx_files.c,ngx_write_fd,,false,177,187,ngx_write_fd,,,8,"ssize_t ngx_write_fd (ngx_fd_t,void*,size_t)"
413605,METHOD,os\win32\ngx_files.c:<global>,TYPE_DECL,"ssize_t
ngx_write_console(ngx_fd_t fd, void *buf, size_t size)
{
    u_long  n;

    (void) CharToOemBuff(buf, buf, size);

    if (WriteFile(fd, buf, size, &n, NULL) != 0) {
        return (size_t) n;
    }

    return -1;
}",1,1,os\win32\ngx_files.c,ngx_write_console,,false,190,202,ngx_write_console,,,9,"ssize_t ngx_write_console (ngx_fd_t,void*,size_t)"
413637,METHOD,os\win32\ngx_files.c:<global>,TYPE_DECL,"ngx_err_t
ngx_win32_rename_file(ngx_str_t *from, ngx_str_t *to, ngx_log_t *log)
{
    u_char             *name;
    ngx_err_t           err;
    ngx_uint_t          collision;
    ngx_atomic_uint_t   num;

    name = ngx_alloc(to->len + 1 + NGX_ATOMIC_T_LEN + 1 + sizeof(""DELETE""),
                     log);
    if (name == NULL) {
        return NGX_ENOMEM;
    }

    ngx_memcpy(name, to->data, to->len);

    collision = 0;

    /* mutex_lock() (per cache or single ?) */

    for ( ;; ) {
        num = ngx_next_temp_number(collision);

        ngx_sprintf(name + to->len, "".%0muA.DELETE%Z"", num);

        if (MoveFile((const char *) to->data, (const char *) name) != 0) {
            break;
        }

        collision = 1;

        ngx_log_error(NGX_LOG_CRIT, log, ngx_errno,
                      ""MoveFile() \""%s\"" to \""%s\"" failed"", to->data, name);
    }

    if (MoveFile((const char *) from->data, (const char *) to->data) == 0) {
        err = ngx_errno;

    } else {
        err ...",1,1,os\win32\ngx_files.c,ngx_win32_rename_file,,false,205,257,ngx_win32_rename_file,,,10,"ngx_err_t ngx_win32_rename_file (ngx_str_t*,ngx_str_t*,ngx_log_t*)"
413764,METHOD,os\win32\ngx_files.c:<global>,TYPE_DECL,"ngx_int_t
ngx_file_info(u_char *file, ngx_file_info_t *sb)
{
    size_t                      len;
    long                        rc;
    u_short                    *u;
    ngx_err_t                   err;
    WIN32_FILE_ATTRIBUTE_DATA   fa;
    u_short                     utf16[NGX_UTF16_BUFLEN];

    len = NGX_UTF16_BUFLEN;

    u = ngx_utf8_to_utf16(utf16, file, &len);

    if (u == NULL) {
        return NGX_FILE_ERROR;
    }

    rc = NGX_FILE_ERROR;

    if (ngx_win32_check_filename(file, u, len) != NGX_OK) {
        goto failed;
    }

    rc = GetFileAttributesExW(u, GetFileExInfoStandard, &fa);

    sb->dwFileAttributes = fa.dwFileAttributes;
    sb->ftCreationTime = fa.ftCreationTime;
    sb->ftLastAccessTime = fa.ftLastAccessTime;
    sb->ftLastWriteTime = fa.ftLastWriteTime;
    sb->nFileSizeHigh = fa.nFileSizeHigh;
    sb->nFileSizeLow = fa.nFileSizeLow;

failed:

    if (u != utf16) {
        err = ngx_errno;
        ngx_free(u);
        ngx_set_errno(err);
    }

    ...",1,38,os\win32\ngx_files.c,ngx_file_info,,false,260,302,ngx_file_info,,,11,"ngx_int_t ngx_file_info (u_char*,ngx_file_info_t*)"
413871,METHOD,os\win32\ngx_files.c:<global>,TYPE_DECL,"ngx_int_t
ngx_set_file_time(u_char *name, ngx_fd_t fd, time_t s)
{
    uint64_t  intervals;
    FILETIME  ft;

    /* 116444736000000000 is commented in src/os/win32/ngx_time.c */

    intervals = s * 10000000 + 116444736000000000;

    ft.dwLowDateTime = (DWORD) intervals;
    ft.dwHighDateTime = (DWORD) (intervals >> 32);

    if (SetFileTime(fd, NULL, NULL, &ft) != 0) {
        return NGX_OK;
    }

    return NGX_ERROR;
}",1,1,os\win32\ngx_files.c,ngx_set_file_time,,false,305,323,ngx_set_file_time,,,12,"ngx_int_t ngx_set_file_time (u_char*,ngx_fd_t,time_t)"
413916,METHOD,os\win32\ngx_files.c:<global>,TYPE_DECL,"ngx_int_t
ngx_create_file_mapping(ngx_file_mapping_t *fm)
{
    LARGE_INTEGER  size;

    fm->fd = ngx_open_file(fm->name, NGX_FILE_RDWR, NGX_FILE_TRUNCATE,
                           NGX_FILE_DEFAULT_ACCESS);

    if (fm->fd == NGX_INVALID_FILE) {
        ngx_log_error(NGX_LOG_CRIT, fm->log, ngx_errno,
                      ngx_open_file_n "" \""%s\"" failed"", fm->name);
        return NGX_ERROR;
    }

    fm->handle = NULL;

    size.QuadPart = fm->size;

    if (SetFilePointerEx(fm->fd, size, NULL, FILE_BEGIN) == 0) {
        ngx_log_error(NGX_LOG_CRIT, fm->log, ngx_errno,
                      ""SetFilePointerEx(\""%s\"", %uz) failed"",
                      fm->name, fm->size);
        goto failed;
    }

    if (SetEndOfFile(fm->fd) == 0) {
        ngx_log_error(NGX_LOG_CRIT, fm->log, ngx_errno,
                      ""SetEndOfFile() \""%s\"" failed"", fm->name);
        goto failed;
    }

    fm->handle = CreateFileMapping(fm->fd, NULL, PAGE_READWRITE,
                                ...",1,1,os\win32\ngx_files.c,ngx_create_file_mapping,,false,326,394,ngx_create_file_mapping,,,13,ngx_int_t ngx_create_file_mapping (ngx_file_mapping_t*)
414116,METHOD,os\win32\ngx_files.c:<global>,TYPE_DECL,"void
ngx_close_file_mapping(ngx_file_mapping_t *fm)
{
    if (UnmapViewOfFile(fm->addr) == 0) {
        ngx_log_error(NGX_LOG_ALERT, fm->log, ngx_errno,
                      ""UnmapViewOfFile(%p) of file mapping \""%s\"" failed"",
                      fm->addr, &fm->name);
    }

    if (CloseHandle(fm->handle) == 0) {
        ngx_log_error(NGX_LOG_ALERT, fm->log, ngx_errno,
                      ""CloseHandle() of file mapping \""%s\"" failed"",
                      &fm->name);
    }

    if (ngx_close_file(fm->fd) == NGX_FILE_ERROR) {
        ngx_log_error(NGX_LOG_ALERT, fm->log, ngx_errno,
                      ngx_close_file_n "" \""%s\"" failed"", fm->name);
    }
}",1,1,os\win32\ngx_files.c,ngx_close_file_mapping,,false,397,416,ngx_close_file_mapping,,,14,void ngx_close_file_mapping (ngx_file_mapping_t*)
414171,METHOD,os\win32\ngx_files.c:<global>,TYPE_DECL,"u_char *
ngx_realpath(u_char *path, u_char *resolved)
{
    /* STUB */
    return path;
}",1,1,os\win32\ngx_files.c,ngx_realpath,,false,419,424,ngx_realpath,,,15,"u_char ngx_realpath (u_char*,u_char*)"
414179,METHOD,os\win32\ngx_files.c:<global>,TYPE_DECL,"ngx_int_t
ngx_open_dir(ngx_str_t *name, ngx_dir_t *dir)
{
    u_char     *pattern, *p;
    ngx_err_t   err;

    pattern = malloc(name->len + 3);
    if (pattern == NULL) {
        return NGX_ERROR;
    }

    p = ngx_cpymem(pattern, name->data, name->len);

    *p++ = '/';
    *p++ = '*';
    *p = '\0';

    dir->dir = FindFirstFile((const char *) pattern, &dir->finddata);

    if (dir->dir == INVALID_HANDLE_VALUE) {
        err = ngx_errno;
        ngx_free(pattern);
        ngx_set_errno(err);
        return NGX_ERROR;
    }

    ngx_free(pattern);

    dir->valid_info = 1;
    dir->ready = 1;

    return NGX_OK;
}",1,1,os\win32\ngx_files.c,ngx_open_dir,,false,427,459,ngx_open_dir,,,16,"ngx_int_t ngx_open_dir (ngx_str_t*,ngx_dir_t*)"
414269,METHOD,os\win32\ngx_files.c:<global>,TYPE_DECL,"ngx_int_t
ngx_read_dir(ngx_dir_t *dir)
{
    if (dir->ready) {
        dir->ready = 0;
        return NGX_OK;
    }

    if (FindNextFile(dir->dir, &dir->finddata) != 0) {
        dir->type = 1;
        return NGX_OK;
    }

    return NGX_ERROR;
}",1,1,os\win32\ngx_files.c,ngx_read_dir,,false,462,476,ngx_read_dir,,,17,ngx_int_t ngx_read_dir (ngx_dir_t*)
414307,METHOD,os\win32\ngx_files.c:<global>,TYPE_DECL,"ngx_int_t
ngx_close_dir(ngx_dir_t *dir)
{
    if (FindClose(dir->dir) == 0) {
        return NGX_ERROR;
    }

    return NGX_OK;
}",1,1,os\win32\ngx_files.c,ngx_close_dir,,false,479,487,ngx_close_dir,,,18,ngx_int_t ngx_close_dir (ngx_dir_t*)
414324,METHOD,os\win32\ngx_files.c:<global>,TYPE_DECL,"ngx_int_t
ngx_open_glob(ngx_glob_t *gl)
{
    u_char     *p;
    size_t      len;
    ngx_err_t   err;

    gl->dir = FindFirstFile((const char *) gl->pattern, &gl->finddata);

    if (gl->dir == INVALID_HANDLE_VALUE) {

        err = ngx_errno;

        if ((err == ERROR_FILE_NOT_FOUND || err == ERROR_PATH_NOT_FOUND)
             && gl->test)
        {
            gl->no_match = 1;
            return NGX_OK;
        }

        return NGX_ERROR;
    }

    for (p = gl->pattern; *p; p++) {
        if (*p == '/') {
            gl->last = p + 1 - gl->pattern;
        }
    }

    len = ngx_strlen(gl->finddata.cFileName);
    gl->name.len = gl->last + len;

    gl->name.data = ngx_alloc(gl->name.len + 1, gl->log);
    if (gl->name.data == NULL) {
        return NGX_ERROR;
    }

    ngx_memcpy(gl->name.data, gl->pattern, gl->last);
    ngx_cpystrn(gl->name.data + gl->last, (u_char *) gl->finddata.cFileName,
                len + 1);

    gl->ready = 1;

    return NGX_OK;
}",1,1,os\win32\ngx_files.c,ngx_open_glob,,false,490,534,ngx_open_glob,,,19,ngx_int_t ngx_open_glob (ngx_glob_t*)
414493,METHOD,os\win32\ngx_files.c:<global>,TYPE_DECL,"ngx_int_t
ngx_read_glob(ngx_glob_t *gl, ngx_str_t *name)
{
    size_t     len;
    ngx_err_t  err;

    if (gl->no_match) {
        return NGX_DONE;
    }

    if (gl->ready) {
        *name = gl->name;

        gl->ready = 0;
        return NGX_OK;
    }

    ngx_free(gl->name.data);
    gl->name.data = NULL;

    if (FindNextFile(gl->dir, &gl->finddata) != 0) {

        len = ngx_strlen(gl->finddata.cFileName);
        gl->name.len = gl->last + len;

        gl->name.data = ngx_alloc(gl->name.len + 1, gl->log);
        if (gl->name.data == NULL) {
            return NGX_ERROR;
        }

        ngx_memcpy(gl->name.data, gl->pattern, gl->last);
        ngx_cpystrn(gl->name.data + gl->last, (u_char *) gl->finddata.cFileName,
                    len + 1);

        *name = gl->name;

        return NGX_OK;
    }

    err = ngx_errno;

    if (err == NGX_ENOMOREFILES) {
        return NGX_DONE;
    }

    ngx_log_error(NGX_LOG_ALERT, gl->log, err,
                  ""FindNextFile(%s) f...",1,1,os\win32\ngx_files.c,ngx_read_glob,,false,537,586,ngx_read_glob,,,20,"ngx_int_t ngx_read_glob (ngx_glob_t*,ngx_str_t*)"
414660,METHOD,os\win32\ngx_files.c:<global>,TYPE_DECL,"void
ngx_close_glob(ngx_glob_t *gl)
{
    if (gl->name.data) {
        ngx_free(gl->name.data);
    }

    if (gl->dir == INVALID_HANDLE_VALUE) {
        return;
    }

    if (FindClose(gl->dir) == 0) {
        ngx_log_error(NGX_LOG_ALERT, gl->log, ngx_errno,
                      ""FindClose(%s) failed"", gl->pattern);
    }
}",1,1,os\win32\ngx_files.c,ngx_close_glob,,false,589,604,ngx_close_glob,,,21,void ngx_close_glob (ngx_glob_t*)
414704,METHOD,os\win32\ngx_files.c:<global>,TYPE_DECL,"ngx_int_t
ngx_de_info(u_char *name, ngx_dir_t *dir)
{
    return NGX_OK;
}",1,1,os\win32\ngx_files.c,ngx_de_info,,false,607,611,ngx_de_info,,,22,"ngx_int_t ngx_de_info (u_char*,ngx_dir_t*)"
414712,METHOD,os\win32\ngx_files.c:<global>,TYPE_DECL,"ngx_int_t
ngx_de_link_info(u_char *name, ngx_dir_t *dir)
{
    return NGX_OK;
}",1,1,os\win32\ngx_files.c,ngx_de_link_info,,false,614,618,ngx_de_link_info,,,23,"ngx_int_t ngx_de_link_info (u_char*,ngx_dir_t*)"
414720,METHOD,os\win32\ngx_files.c:<global>,TYPE_DECL,"ngx_int_t
ngx_read_ahead(ngx_fd_t fd, size_t n)
{
    return ~NGX_FILE_ERROR;
}",1,1,os\win32\ngx_files.c,ngx_read_ahead,,false,621,625,ngx_read_ahead,,,24,"ngx_int_t ngx_read_ahead (ngx_fd_t,size_t)"
414729,METHOD,os\win32\ngx_files.c:<global>,TYPE_DECL,"ngx_int_t
ngx_directio_on(ngx_fd_t fd)
{
    return ~NGX_FILE_ERROR;
}",1,1,os\win32\ngx_files.c,ngx_directio_on,,false,628,632,ngx_directio_on,,,25,ngx_int_t ngx_directio_on (ngx_fd_t)
414737,METHOD,os\win32\ngx_files.c:<global>,TYPE_DECL,"ngx_int_t
ngx_directio_off(ngx_fd_t fd)
{
    return ~NGX_FILE_ERROR;
}",1,1,os\win32\ngx_files.c,ngx_directio_off,,false,635,639,ngx_directio_off,,,26,ngx_int_t ngx_directio_off (ngx_fd_t)
414745,METHOD,os\win32\ngx_files.c:<global>,TYPE_DECL,"size_t
ngx_fs_bsize(u_char *name)
{
    u_char  root[4];
    u_long  sc, bs, nfree, ncl;

    if (name[2] == ':') {
        ngx_cpystrn(root, name, 4);
        name = root;
    }

    if (GetDiskFreeSpace((const char *) name, &sc, &bs, &nfree, &ncl) == 0) {
        return 512;
    }

    return sc * bs;
}",1,1,os\win32\ngx_files.c,ngx_fs_bsize,,false,642,658,ngx_fs_bsize,,,27,size_t ngx_fs_bsize (u_char*)
414791,METHOD,os\win32\ngx_files.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_win32_check_filename(u_char *name, u_short *u, size_t len)
{
    u_char     *p, ch;
    u_long      n;
    u_short    *lu;
    ngx_err_t   err;
    enum {
        sw_start = 0,
        sw_normal,
        sw_after_slash,
        sw_after_colon,
        sw_after_dot
    } state;

    /* check for NTFS streams ("":""), trailing dots and spaces */

    lu = NULL;
    state = sw_start;

    for (p = name; *p; p++) {
        ch = *p;

        switch (state) {

        case sw_start:

            /*
             * skip till first ""/"" to allow paths starting with drive and
             * relative path, like ""c:html/""
             */

            if (ch == '/' || ch == '\\') {
                state = sw_after_slash;
            }

            break;

        case sw_normal:

            if (ch == ':') {
                state = sw_after_colon;
                break;
            }

            if (ch == '.' || ch == ' ') {
                state = sw_after_dot;
              ...",1,1,os\win32\ngx_files.c,ngx_win32_check_filename,,false,661,802,ngx_win32_check_filename,,,28,"ngx_int_t ngx_win32_check_filename (u_char*,u_short*,size_t)"
415024,METHOD,os\win32\ngx_files.c:<global>,TYPE_DECL,"static u_short *
ngx_utf8_to_utf16(u_short *utf16, u_char *utf8, size_t *len)
{
    u_char    *p;
    u_short   *u, *last;
    uint32_t   n;

    p = utf8;
    u = utf16;
    last = utf16 + *len;

    while (u < last) {

        if (*p < 0x80) {
            *u++ = (u_short) *p;

            if (*p == 0) {
                *len = u - utf16;
                return utf16;
            }

            p++;

            continue;
        }

        if (u + 1 == last) {
            *len = u - utf16;
            break;
        }

        n = ngx_utf8_decode(&p, 4);

        if (n > 0x10ffff) {
            ngx_set_errno(NGX_EILSEQ);
            return NULL;
        }

        if (n > 0xffff) {
            n -= 0x10000;
            *u++ = (u_short) (0xd800 + (n >> 10));
            *u++ = (u_short) (0xdc00 + (n & 0x03ff));
            continue;
        }

        *u++ = (u_short) n;
    }

    /* the given buffer is not enough, allocate a new one */

    u = malloc(((p - utf8) + ngx_strlen(p) +...",1,1,os\win32\ngx_files.c,ngx_utf8_to_utf16,,false,805,899,ngx_utf8_to_utf16,,,29,"u_short ngx_utf8_to_utf16 (u_short*,u_char*,size_t*)"
415275,METHOD,os\win32\ngx_files.h:<global>,TYPE_DECL,<global>,1,35,os\win32\ngx_files.h,os\win32\ngx_files.h:<global>,,false,1,270,<global>,,,1,
415306,METHOD,os\win32\ngx_files.h:<global>,TYPE_DECL,"ngx_fd_t ngx_open_file(u_char *name, u_long mode, u_long create, u_long access);",10,79,os\win32\ngx_files.h,ngx_open_file,,false,72,72,ngx_open_file,,,10,"ngx_fd_t ngx_open_file (u_char*,u_long,u_long,u_long)"
415314,METHOD,os\win32\ngx_files.h:<global>,TYPE_DECL,"ssize_t ngx_read_fd(ngx_fd_t fd, void *buf, size_t size);",9,56,os\win32\ngx_files.h,ngx_read_fd,,false,106,106,ngx_read_fd,,,11,"ssize_t ngx_read_fd (ngx_fd_t,void*,size_t)"
415321,METHOD,os\win32\ngx_files.h:<global>,TYPE_DECL,"ssize_t ngx_write_fd(ngx_fd_t fd, void *buf, size_t size);",9,57,os\win32\ngx_files.h,ngx_write_fd,,false,110,110,ngx_write_fd,,,12,"ssize_t ngx_write_fd (ngx_fd_t,void*,size_t)"
415328,METHOD,os\win32\ngx_files.h:<global>,TYPE_DECL,"ssize_t ngx_write_console(ngx_fd_t fd, void *buf, size_t size);",9,62,os\win32\ngx_files.h,ngx_write_console,,false,114,114,ngx_write_console,,,13,"ssize_t ngx_write_console (ngx_fd_t,void*,size_t)"
415335,METHOD,os\win32\ngx_files.h:<global>,TYPE_DECL,"ngx_err_t ngx_win32_rename_file(ngx_str_t *from, ngx_str_t *to, ngx_log_t *log);",11,79,os\win32\ngx_files.h,ngx_win32_rename_file,,false,128,128,ngx_win32_rename_file,,,14,"ngx_err_t ngx_win32_rename_file (ngx_str_t*,ngx_str_t*,ngx_log_t*)"
415342,METHOD,os\win32\ngx_files.h:<global>,TYPE_DECL,"ngx_int_t ngx_set_file_time(u_char *name, ngx_fd_t fd, time_t s);",11,64,os\win32\ngx_files.h,ngx_set_file_time,,false,132,132,ngx_set_file_time,,,15,"ngx_int_t ngx_set_file_time (u_char*,ngx_fd_t,time_t)"
415349,METHOD,os\win32\ngx_files.h:<global>,TYPE_DECL,"ngx_int_t ngx_file_info(u_char *filename, ngx_file_info_t *fi);",11,62,os\win32\ngx_files.h,ngx_file_info,,false,136,136,ngx_file_info,,,16,"ngx_int_t ngx_file_info (u_char*,ngx_file_info_t*)"
415355,METHOD,os\win32\ngx_files.h:<global>,TYPE_DECL,ngx_int_t ngx_create_file_mapping(ngx_file_mapping_t *fm);,11,57,os\win32\ngx_files.h,ngx_create_file_mapping,,false,171,171,ngx_create_file_mapping,,,17,ngx_int_t ngx_create_file_mapping (ngx_file_mapping_t*)
415360,METHOD,os\win32\ngx_files.h:<global>,TYPE_DECL,void ngx_close_file_mapping(ngx_file_mapping_t *fm);,6,51,os\win32\ngx_files.h,ngx_close_file_mapping,,false,172,172,ngx_close_file_mapping,,,18,void ngx_close_file_mapping (ngx_file_mapping_t*)
415365,METHOD,os\win32\ngx_files.h:<global>,TYPE_DECL,"u_char *ngx_realpath(u_char *path, u_char *resolved);",8,52,os\win32\ngx_files.h,ngx_realpath,,false,175,175,ngx_realpath,,,19,"u_char* ngx_realpath (u_char*,u_char*)"
415371,METHOD,os\win32\ngx_files.h:<global>,TYPE_DECL,"ngx_int_t ngx_open_dir(ngx_str_t *name, ngx_dir_t *dir);",11,55,os\win32\ngx_files.h,ngx_open_dir,,false,185,185,ngx_open_dir,,,20,"ngx_int_t ngx_open_dir (ngx_str_t*,ngx_dir_t*)"
415377,METHOD,os\win32\ngx_files.h:<global>,TYPE_DECL,ngx_int_t ngx_read_dir(ngx_dir_t *dir);,11,38,os\win32\ngx_files.h,ngx_read_dir,,false,189,189,ngx_read_dir,,,21,ngx_int_t ngx_read_dir (ngx_dir_t*)
415382,METHOD,os\win32\ngx_files.h:<global>,TYPE_DECL,ngx_int_t ngx_close_dir(ngx_dir_t *dir);,11,39,os\win32\ngx_files.h,ngx_close_dir,,false,193,193,ngx_close_dir,,,22,ngx_int_t ngx_close_dir (ngx_dir_t*)
415387,METHOD,os\win32\ngx_files.h:<global>,TYPE_DECL,"ngx_int_t ngx_de_info(u_char *name, ngx_dir_t *dir);",11,51,os\win32\ngx_files.h,ngx_de_info,,false,211,211,ngx_de_info,,,23,"ngx_int_t ngx_de_info (u_char*,ngx_dir_t*)"
415393,METHOD,os\win32\ngx_files.h:<global>,TYPE_DECL,"ngx_int_t ngx_de_link_info(u_char *name, ngx_dir_t *dir);",11,56,os\win32\ngx_files.h,ngx_de_link_info,,false,214,214,ngx_de_link_info,,,24,"ngx_int_t ngx_de_link_info (u_char*,ngx_dir_t*)"
415399,METHOD,os\win32\ngx_files.h:<global>,TYPE_DECL,ngx_int_t ngx_open_glob(ngx_glob_t *gl);,11,39,os\win32\ngx_files.h,ngx_open_glob,,false,236,236,ngx_open_glob,,,25,ngx_int_t ngx_open_glob (ngx_glob_t*)
415404,METHOD,os\win32\ngx_files.h:<global>,TYPE_DECL,"ngx_int_t ngx_read_glob(ngx_glob_t *gl, ngx_str_t *name);",11,56,os\win32\ngx_files.h,ngx_read_glob,,false,239,239,ngx_read_glob,,,26,"ngx_int_t ngx_read_glob (ngx_glob_t*,ngx_str_t*)"
415410,METHOD,os\win32\ngx_files.h:<global>,TYPE_DECL,void ngx_close_glob(ngx_glob_t *gl);,6,35,os\win32\ngx_files.h,ngx_close_glob,,false,240,240,ngx_close_glob,,,27,void ngx_close_glob (ngx_glob_t*)
415415,METHOD,os\win32\ngx_files.h:<global>,TYPE_DECL,"ssize_t ngx_read_file(ngx_file_t *file, u_char *buf, size_t size, off_t offset);",9,79,os\win32\ngx_files.h,ngx_read_file,,false,243,243,ngx_read_file,,,28,"ssize_t ngx_read_file (ngx_file_t*,u_char*,size_t,off_t)"
415423,METHOD,os\win32\ngx_files.h:<global>,TYPE_DECL,"ssize_t ngx_write_file(ngx_file_t *file, u_char *buf, size_t size,
    off_t offset);",9,17,os\win32\ngx_files.h,ngx_write_file,,false,246,247,ngx_write_file,,,29,"ssize_t ngx_write_file (ngx_file_t*,u_char*,size_t,off_t)"
415431,METHOD,os\win32\ngx_files.h:<global>,TYPE_DECL,"ssize_t ngx_write_chain_to_file(ngx_file_t *file, ngx_chain_t *ce,
    off_t offset, ngx_pool_t *pool);",9,35,os\win32\ngx_files.h,ngx_write_chain_to_file,,false,249,250,ngx_write_chain_to_file,,,30,"ssize_t ngx_write_chain_to_file (ngx_file_t*,ngx_chain_t*,off_t,ngx_pool_t*)"
415439,METHOD,os\win32\ngx_files.h:<global>,TYPE_DECL,"ngx_int_t ngx_read_ahead(ngx_fd_t fd, size_t n);",11,47,os\win32\ngx_files.h,ngx_read_ahead,,false,252,252,ngx_read_ahead,,,31,"ngx_int_t ngx_read_ahead (ngx_fd_t,size_t)"
415445,METHOD,os\win32\ngx_files.h:<global>,TYPE_DECL,ngx_int_t ngx_directio_on(ngx_fd_t fd);,11,38,os\win32\ngx_files.h,ngx_directio_on,,false,255,255,ngx_directio_on,,,32,ngx_int_t ngx_directio_on (ngx_fd_t)
415450,METHOD,os\win32\ngx_files.h:<global>,TYPE_DECL,ngx_int_t ngx_directio_off(ngx_fd_t fd);,11,39,os\win32\ngx_files.h,ngx_directio_off,,false,258,258,ngx_directio_off,,,33,ngx_int_t ngx_directio_off (ngx_fd_t)
415455,METHOD,os\win32\ngx_files.h:<global>,TYPE_DECL,size_t ngx_fs_bsize(u_char *name);,8,33,os\win32\ngx_files.h,ngx_fs_bsize,,false,261,261,ngx_fs_bsize,,,34,size_t ngx_fs_bsize (u_char*)
415467,METHOD,os\win32\ngx_os.h:<global>,TYPE_DECL,<global>,1,32,os\win32\ngx_os.h,os\win32\ngx_os.h:<global>,,false,1,68,<global>,,,1,
415469,METHOD,os\win32\ngx_os.h:<global>,TYPE_DECL,"typedef ssize_t (*ngx_recv_pt)(ngx_connection_t *c, u_char *buf, size_t size);",17,77,os\win32\ngx_os.h,ngx_recv_pt,,false,19,19,ngx_recv_pt,,,1,"ssize_t ngx_recv_pt (ngx_connection_t*,u_char*,size_t)"
415476,METHOD,os\win32\ngx_os.h:<global>,TYPE_DECL,"typedef ssize_t (*ngx_recv_chain_pt)(ngx_connection_t *c, ngx_chain_t *in,
    off_t limit);",17,16,os\win32\ngx_os.h,ngx_recv_chain_pt,,false,20,21,ngx_recv_chain_pt,,,2,"ssize_t ngx_recv_chain_pt (ngx_connection_t*,ngx_chain_t*,off_t)"
415483,METHOD,os\win32\ngx_os.h:<global>,TYPE_DECL,"typedef ssize_t (*ngx_send_pt)(ngx_connection_t *c, u_char *buf, size_t size);",17,77,os\win32\ngx_os.h,ngx_send_pt,,false,22,22,ngx_send_pt,,,3,"ssize_t ngx_send_pt (ngx_connection_t*,u_char*,size_t)"
415490,METHOD,os\win32\ngx_os.h:<global>,TYPE_DECL,"typedef ngx_chain_t *(*ngx_send_chain_pt)(ngx_connection_t *c, ngx_chain_t *in,
    off_t limit);",21,16,os\win32\ngx_os.h,ngx_send_chain_pt,,false,23,24,ngx_send_chain_pt,,,4,"ngx_chain_t* ngx_send_chain_pt (ngx_connection_t*,ngx_chain_t*,off_t)"
415507,METHOD,os\win32\ngx_os.h:<global>,TYPE_DECL,ngx_int_t ngx_os_init(ngx_log_t *log);,11,37,os\win32\ngx_os.h,ngx_os_init,,false,38,38,ngx_os_init,,,7,ngx_int_t ngx_os_init (ngx_log_t*)
415512,METHOD,os\win32\ngx_os.h:<global>,TYPE_DECL,void ngx_os_status(ngx_log_t *log);,6,34,os\win32\ngx_os.h,ngx_os_status,,false,39,39,ngx_os_status,,,8,void ngx_os_status (ngx_log_t*)
415517,METHOD,os\win32\ngx_os.h:<global>,TYPE_DECL,"ngx_int_t ngx_os_signal_process(ngx_cycle_t *cycle, char *sig, ngx_pid_t pid);",11,77,os\win32\ngx_os.h,ngx_os_signal_process,,false,40,40,ngx_os_signal_process,,,9,"ngx_int_t ngx_os_signal_process (ngx_cycle_t*,char*,ngx_pid_t)"
415524,METHOD,os\win32\ngx_os.h:<global>,TYPE_DECL,"ssize_t ngx_wsarecv(ngx_connection_t *c, u_char *buf, size_t size);",9,66,os\win32\ngx_os.h,ngx_wsarecv,,false,42,42,ngx_wsarecv,,,10,"ssize_t ngx_wsarecv (ngx_connection_t*,u_char*,size_t)"
415531,METHOD,os\win32\ngx_os.h:<global>,TYPE_DECL,"ssize_t ngx_overlapped_wsarecv(ngx_connection_t *c, u_char *buf, size_t size);",9,77,os\win32\ngx_os.h,ngx_overlapped_wsarecv,,false,43,43,ngx_overlapped_wsarecv,,,11,"ssize_t ngx_overlapped_wsarecv (ngx_connection_t*,u_char*,size_t)"
415538,METHOD,os\win32\ngx_os.h:<global>,TYPE_DECL,"ssize_t ngx_udp_wsarecv(ngx_connection_t *c, u_char *buf, size_t size);",9,70,os\win32\ngx_os.h,ngx_udp_wsarecv,,false,44,44,ngx_udp_wsarecv,,,12,"ssize_t ngx_udp_wsarecv (ngx_connection_t*,u_char*,size_t)"
415545,METHOD,os\win32\ngx_os.h:<global>,TYPE_DECL,"ssize_t ngx_udp_overlapped_wsarecv(ngx_connection_t *c, u_char *buf,
    size_t size);",9,16,os\win32\ngx_os.h,ngx_udp_overlapped_wsarecv,,false,45,46,ngx_udp_overlapped_wsarecv,,,13,"ssize_t ngx_udp_overlapped_wsarecv (ngx_connection_t*,u_char*,size_t)"
415552,METHOD,os\win32\ngx_os.h:<global>,TYPE_DECL,"ssize_t ngx_wsarecv_chain(ngx_connection_t *c, ngx_chain_t *chain, off_t limit);",9,79,os\win32\ngx_os.h,ngx_wsarecv_chain,,false,47,47,ngx_wsarecv_chain,,,14,"ssize_t ngx_wsarecv_chain (ngx_connection_t*,ngx_chain_t*,off_t)"
415559,METHOD,os\win32\ngx_os.h:<global>,TYPE_DECL,"ssize_t ngx_wsasend(ngx_connection_t *c, u_char *buf, size_t size);",9,66,os\win32\ngx_os.h,ngx_wsasend,,false,48,48,ngx_wsasend,,,15,"ssize_t ngx_wsasend (ngx_connection_t*,u_char*,size_t)"
415566,METHOD,os\win32\ngx_os.h:<global>,TYPE_DECL,"ssize_t ngx_overlapped_wsasend(ngx_connection_t *c, u_char *buf, size_t size);",9,77,os\win32\ngx_os.h,ngx_overlapped_wsasend,,false,49,49,ngx_overlapped_wsasend,,,16,"ssize_t ngx_overlapped_wsasend (ngx_connection_t*,u_char*,size_t)"
415573,METHOD,os\win32\ngx_os.h:<global>,TYPE_DECL,"ngx_chain_t *ngx_wsasend_chain(ngx_connection_t *c, ngx_chain_t *in,
    off_t limit);",13,16,os\win32\ngx_os.h,ngx_wsasend_chain,,false,50,51,ngx_wsasend_chain,,,17,"ngx_chain_t* ngx_wsasend_chain (ngx_connection_t*,ngx_chain_t*,off_t)"
415580,METHOD,os\win32\ngx_os.h:<global>,TYPE_DECL,"ngx_chain_t *ngx_overlapped_wsasend_chain(ngx_connection_t *c, ngx_chain_t *in,
    off_t limit);",13,16,os\win32\ngx_os.h,ngx_overlapped_wsasend_chain,,false,52,53,ngx_overlapped_wsasend_chain,,,18,"ngx_chain_t* ngx_overlapped_wsasend_chain (ngx_connection_t*,ngx_chain_t*,off_t)"
415604,METHOD,os\win32\ngx_process.c:<global>,TYPE_DECL,<global>,1,1,os\win32\ngx_process.c,os\win32\ngx_process.c:<global>,,false,1,238,<global>,,,1,
415613,METHOD,os\win32\ngx_process.c:<global>,TYPE_DECL,"ngx_pid_t
ngx_spawn_process(ngx_cycle_t *cycle, char *name, ngx_int_t respawn)
{
    u_long          rc, n, code;
    ngx_int_t       s;
    ngx_pid_t       pid;
    ngx_exec_ctx_t  ctx;
    HANDLE          events[2];
    char            file[MAX_PATH + 1];

    if (respawn >= 0) {
        s = respawn;

    } else {
        for (s = 0; s < ngx_last_process; s++) {
            if (ngx_processes[s].handle == NULL) {
                break;
            }
        }

        if (s == NGX_MAX_PROCESSES) {
            ngx_log_error(NGX_LOG_ALERT, cycle->log, 0,
                          ""no more than %d processes can be spawned"",
                          NGX_MAX_PROCESSES);
            return NGX_INVALID_PID;
        }
    }

    n = GetModuleFileName(NULL, file, MAX_PATH);

    if (n == 0) {
        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                      ""GetModuleFileName() failed"");
        return NGX_INVALID_PID;
    }

    file[n] = '\0';

    ngx_log_debug1(NGX_LOG_...",1,1,os\win32\ngx_process.c,ngx_spawn_process,,false,20,203,ngx_spawn_process,,,7,"ngx_pid_t ngx_spawn_process (ngx_cycle_t*,char*,ngx_int_t)"
416128,METHOD,os\win32\ngx_process.c:<global>,TYPE_DECL,"ngx_pid_t
ngx_execute(ngx_cycle_t *cycle, ngx_exec_ctx_t *ctx)
{
    STARTUPINFO          si;
    PROCESS_INFORMATION  pi;

    ngx_memzero(&si, sizeof(STARTUPINFO));
    si.cb = sizeof(STARTUPINFO);

    ngx_memzero(&pi, sizeof(PROCESS_INFORMATION));

    if (CreateProcess(ctx->path, ctx->args,
                      NULL, NULL, 0, CREATE_NO_WINDOW, NULL, NULL, &si, &pi)
        == 0)
    {
        ngx_log_error(NGX_LOG_CRIT, cycle->log, ngx_errno,
                      ""CreateProcess(\""%s\"") failed"", ngx_argv[0]);

        return 0;
    }

    ctx->child = pi.hProcess;

    if (CloseHandle(pi.hThread) == 0) {
        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                      ""CloseHandle(pi.hThread) failed"");
    }

    ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0,
                  ""start %s process %P"", ctx->name, pi.dwProcessId);

    return pi.dwProcessId;
}",1,1,os\win32\ngx_process.c,ngx_execute,,false,206,238,ngx_execute,,,8,"ngx_pid_t ngx_execute (ngx_cycle_t*,ngx_exec_ctx_t*)"
416227,METHOD,os\win32\ngx_process.h:<global>,TYPE_DECL,<global>,1,39,os\win32\ngx_process.h,os\win32\ngx_process.h:<global>,,false,1,80,<global>,,,1,
416243,METHOD,<empty>,<empty>,<empty>,1,,os\win32\ngx_process.h,ngx_process_t:<clinit>,,false,28,,<clinit>,,,12,
416277,METHOD,os\win32\ngx_process.h:<global>,TYPE_DECL,"ngx_pid_t ngx_spawn_process(ngx_cycle_t *cycle, char *name, ngx_int_t respawn);",11,78,os\win32\ngx_process.h,ngx_spawn_process,,false,56,56,ngx_spawn_process,,,7,"ngx_pid_t ngx_spawn_process (ngx_cycle_t*,char*,ngx_int_t)"
416284,METHOD,os\win32\ngx_process.h:<global>,TYPE_DECL,"ngx_pid_t ngx_execute(ngx_cycle_t *cycle, ngx_exec_ctx_t *ctx);",11,62,os\win32\ngx_process.h,ngx_execute,,false,57,57,ngx_execute,,,8,"ngx_pid_t ngx_execute (ngx_cycle_t*,ngx_exec_ctx_t*)"
416314,METHOD,os\win32\ngx_process_cycle.c:<global>,TYPE_DECL,<global>,1,11,os\win32\ngx_process_cycle.c,os\win32\ngx_process_cycle.c:<global>,,false,1,1043,<global>,,,1,
416316,METHOD,os\win32\ngx_process_cycle.c:<global>,TYPE_DECL,static void ngx_console_init(ngx_cycle_t *cycle);,13,48,os\win32\ngx_process_cycle.c,ngx_console_init,,false,14,14,ngx_console_init,,,1,void ngx_console_init (ngx_cycle_t*)
416321,METHOD,os\win32\ngx_process_cycle.c:<global>,TYPE_DECL,static int __stdcall ngx_console_handler(u_long type);,22,53,os\win32\ngx_process_cycle.c,ngx_console_handler,,false,15,15,ngx_console_handler,,,2,int ngx_console_handler (u_long)
416326,METHOD,os\win32\ngx_process_cycle.c:<global>,TYPE_DECL,static ngx_int_t ngx_create_signal_events(ngx_cycle_t *cycle);,18,61,os\win32\ngx_process_cycle.c,ngx_create_signal_events,,false,16,16,ngx_create_signal_events,,,3,ngx_int_t ngx_create_signal_events (ngx_cycle_t*)
416331,METHOD,os\win32\ngx_process_cycle.c:<global>,TYPE_DECL,"static ngx_int_t ngx_start_worker_processes(ngx_cycle_t *cycle, ngx_int_t type);",18,79,os\win32\ngx_process_cycle.c,ngx_start_worker_processes,,false,17,17,ngx_start_worker_processes,,,4,"ngx_int_t ngx_start_worker_processes (ngx_cycle_t*,ngx_int_t)"
416337,METHOD,os\win32\ngx_process_cycle.c:<global>,TYPE_DECL,static void ngx_reopen_worker_processes(ngx_cycle_t *cycle);,13,59,os\win32\ngx_process_cycle.c,ngx_reopen_worker_processes,,false,18,18,ngx_reopen_worker_processes,,,5,void ngx_reopen_worker_processes (ngx_cycle_t*)
416342,METHOD,os\win32\ngx_process_cycle.c:<global>,TYPE_DECL,"static void ngx_quit_worker_processes(ngx_cycle_t *cycle, ngx_uint_t old);",13,73,os\win32\ngx_process_cycle.c,ngx_quit_worker_processes,,false,19,19,ngx_quit_worker_processes,,,6,"void ngx_quit_worker_processes (ngx_cycle_t*,ngx_uint_t)"
416348,METHOD,os\win32\ngx_process_cycle.c:<global>,TYPE_DECL,static void ngx_terminate_worker_processes(ngx_cycle_t *cycle);,13,62,os\win32\ngx_process_cycle.c,ngx_terminate_worker_processes,,false,20,20,ngx_terminate_worker_processes,,,7,void ngx_terminate_worker_processes (ngx_cycle_t*)
416353,METHOD,os\win32\ngx_process_cycle.c:<global>,TYPE_DECL,"static ngx_uint_t ngx_reap_worker(ngx_cycle_t *cycle, HANDLE h);",19,63,os\win32\ngx_process_cycle.c,ngx_reap_worker,,false,21,21,ngx_reap_worker,,,8,"ngx_uint_t ngx_reap_worker (ngx_cycle_t*,HANDLE)"
416359,METHOD,os\win32\ngx_process_cycle.c:<global>,TYPE_DECL,static void ngx_master_process_exit(ngx_cycle_t *cycle);,13,55,os\win32\ngx_process_cycle.c,ngx_master_process_exit,,false,22,22,ngx_master_process_exit,,,9,void ngx_master_process_exit (ngx_cycle_t*)
416364,METHOD,os\win32\ngx_process_cycle.c:<global>,TYPE_DECL,"static void ngx_worker_process_cycle(ngx_cycle_t *cycle, char *mevn);",13,68,os\win32\ngx_process_cycle.c,ngx_worker_process_cycle,,false,23,23,ngx_worker_process_cycle,,,10,"void ngx_worker_process_cycle (ngx_cycle_t*,char*)"
416370,METHOD,os\win32\ngx_process_cycle.c:<global>,TYPE_DECL,static void ngx_worker_process_exit(ngx_cycle_t *cycle);,13,55,os\win32\ngx_process_cycle.c,ngx_worker_process_exit,,false,24,24,ngx_worker_process_exit,,,11,void ngx_worker_process_exit (ngx_cycle_t*)
416375,METHOD,os\win32\ngx_process_cycle.c:<global>,TYPE_DECL,static ngx_thread_value_t __stdcall ngx_worker_thread(void *data);,37,65,os\win32\ngx_process_cycle.c,ngx_worker_thread,,false,25,25,ngx_worker_thread,,,12,ngx_thread_value_t ngx_worker_thread (void*)
416380,METHOD,os\win32\ngx_process_cycle.c:<global>,TYPE_DECL,static ngx_thread_value_t __stdcall ngx_cache_manager_thread(void *data);,37,72,os\win32\ngx_process_cycle.c,ngx_cache_manager_thread,,false,26,26,ngx_cache_manager_thread,,,13,ngx_thread_value_t ngx_cache_manager_thread (void*)
416385,METHOD,os\win32\ngx_process_cycle.c:<global>,TYPE_DECL,static void ngx_cache_manager_process_handler(void);,13,51,os\win32\ngx_process_cycle.c,ngx_cache_manager_process_handler,,false,27,27,ngx_cache_manager_process_handler,,,14,void ngx_cache_manager_process_handler (void)
416390,METHOD,os\win32\ngx_process_cycle.c:<global>,TYPE_DECL,static ngx_thread_value_t __stdcall ngx_cache_loader_thread(void *data);,37,71,os\win32\ngx_process_cycle.c,ngx_cache_loader_thread,,false,28,28,ngx_cache_loader_thread,,,15,ngx_thread_value_t ngx_cache_loader_thread (void*)
416431,METHOD,os\win32\ngx_process_cycle.c:<global>,TYPE_DECL,"void
ngx_master_process_cycle(ngx_cycle_t *cycle)
{
    u_long      nev, ev, timeout;
    ngx_err_t   err;
    ngx_int_t   n;
    ngx_msec_t  timer;
    ngx_uint_t  live;
    HANDLE      events[MAXIMUM_WAIT_OBJECTS];

    ngx_sprintf((u_char *) ngx_master_process_event_name,
                ""ngx_master_%s%Z"", ngx_unique);

    if (ngx_process == NGX_PROCESS_WORKER) {
        ngx_worker_process_cycle(cycle, ngx_master_process_event_name);
        return;
    }

    ngx_log_debug0(NGX_LOG_DEBUG_CORE, cycle->log, 0, ""master started"");

    ngx_console_init(cycle);

    SetEnvironmentVariable(""ngx_unique"", ngx_unique);

    ngx_master_process_event = CreateEvent(NULL, 1, 0,
                                           ngx_master_process_event_name);
    if (ngx_master_process_event == NULL) {
        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                      ""CreateEvent(\""%s\"") failed"",
                      ngx_master_process_event_name);
        exit(2);
    }

    if (n...",1,1,os\win32\ngx_process_cycle.c,ngx_master_process_cycle,,false,63,249,ngx_master_process_cycle,,,46,void ngx_master_process_cycle (ngx_cycle_t*)
416869,METHOD,os\win32\ngx_process_cycle.c:<global>,TYPE_DECL,"static void
ngx_console_init(ngx_cycle_t *cycle)
{
    ngx_core_conf_t  *ccf;

    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);

    if (ccf->daemon) {
        if (FreeConsole() == 0) {
            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                          ""FreeConsole() failed"");
        }

        return;
    }

    if (SetConsoleCtrlHandler(ngx_console_handler, 1) == 0) {
        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                      ""SetConsoleCtrlHandler() failed"");
    }
}",1,1,os\win32\ngx_process_cycle.c,ngx_console_init,,false,252,272,ngx_console_init,,,47,void ngx_console_init (ngx_cycle_t*)
416916,METHOD,os\win32\ngx_process_cycle.c:<global>,TYPE_DECL,"static int __stdcall
ngx_console_handler(u_long type)
{
    char  *msg;

    switch (type) {

    case CTRL_C_EVENT:
        msg = ""Ctrl-C pressed, exiting"";
        break;

    case CTRL_BREAK_EVENT:
        msg = ""Ctrl-Break pressed, exiting"";
        break;

    case CTRL_CLOSE_EVENT:
        msg = ""console closing, exiting"";
        break;

    case CTRL_LOGOFF_EVENT:
        msg = ""user logs off, exiting"";
        break;

    default:
        return 0;
    }

    ngx_log_error(NGX_LOG_NOTICE, ngx_cycle->log, 0, msg);

    if (ngx_stop_event == NULL) {
        return 1;
    }

    if (SetEvent(ngx_stop_event) == 0) {
        ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, 0,
                      ""SetEvent(\""%s\"") failed"", ngx_stop_event_name);
    }

    return 1;
}",1,11,os\win32\ngx_process_cycle.c,ngx_console_handler,,false,275,314,ngx_console_handler,,,48,int ngx_console_handler (u_long)
416982,METHOD,os\win32\ngx_process_cycle.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_create_signal_events(ngx_cycle_t *cycle)
{
    ngx_sprintf((u_char *) ngx_stop_event_name,
                ""Global\\ngx_stop_%s%Z"", ngx_unique);

    ngx_stop_event = CreateEvent(NULL, 1, 0, ngx_stop_event_name);
    if (ngx_stop_event == NULL) {
        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                      ""CreateEvent(\""%s\"") failed"", ngx_stop_event_name);
        return NGX_ERROR;
    }


    ngx_sprintf((u_char *) ngx_quit_event_name,
                ""Global\\ngx_quit_%s%Z"", ngx_unique);

    ngx_quit_event = CreateEvent(NULL, 1, 0, ngx_quit_event_name);
    if (ngx_quit_event == NULL) {
        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                      ""CreateEvent(\""%s\"") failed"", ngx_quit_event_name);
        return NGX_ERROR;
    }


    ngx_sprintf((u_char *) ngx_reopen_event_name,
                ""Global\\ngx_reopen_%s%Z"", ngx_unique);

    ngx_reopen_event = CreateEvent(NULL, 1, 0, ngx_reopen_event_name);
    if (ngx...",1,1,os\win32\ngx_process_cycle.c,ngx_create_signal_events,,false,317,364,ngx_create_signal_events,,,49,ngx_int_t ngx_create_signal_events (ngx_cycle_t*)
417101,METHOD,os\win32\ngx_process_cycle.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_start_worker_processes(ngx_cycle_t *cycle, ngx_int_t type)
{
    ngx_int_t         n;
    ngx_core_conf_t  *ccf;

    ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, ""start worker processes"");

    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);

    for (n = 0; n < ccf->worker_processes; n++) {
        if (ngx_spawn_process(cycle, ""worker"", type) == NGX_INVALID_PID) {
            break;
        }
    }

    return n;
}",1,1,os\win32\ngx_process_cycle.c,ngx_start_worker_processes,,false,367,384,ngx_start_worker_processes,,,50,"ngx_int_t ngx_start_worker_processes (ngx_cycle_t*,ngx_int_t)"
417149,METHOD,os\win32\ngx_process_cycle.c:<global>,TYPE_DECL,"static void
ngx_reopen_worker_processes(ngx_cycle_t *cycle)
{
    ngx_int_t  n;

    for (n = 0; n < ngx_last_process; n++) {

        if (ngx_processes[n].handle == NULL) {
            continue;
        }

        if (SetEvent(ngx_processes[n].reopen) == 0) {
            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                          ""SetEvent(\""%s\"") failed"",
                          ngx_processes[n].reopen_event);
        }
    }
}",1,1,os\win32\ngx_process_cycle.c,ngx_reopen_worker_processes,,false,387,404,ngx_reopen_worker_processes,,,51,void ngx_reopen_worker_processes (ngx_cycle_t*)
417198,METHOD,os\win32\ngx_process_cycle.c:<global>,TYPE_DECL,"static void
ngx_quit_worker_processes(ngx_cycle_t *cycle, ngx_uint_t old)
{
    ngx_int_t  n;

    for (n = 0; n < ngx_last_process; n++) {

        ngx_log_debug5(NGX_LOG_DEBUG_CORE, cycle->log, 0,
                       ""process: %d %P %p e:%d j:%d"",
                       n,
                       ngx_processes[n].pid,
                       ngx_processes[n].handle,
                       ngx_processes[n].exiting,
                       ngx_processes[n].just_spawn);

        if (old && ngx_processes[n].just_spawn) {
            ngx_processes[n].just_spawn = 0;
            continue;
        }

        if (ngx_processes[n].handle == NULL) {
            continue;
        }

        if (SetEvent(ngx_processes[n].quit) == 0) {
            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                          ""SetEvent(\""%s\"") failed"",
                          ngx_processes[n].quit_event);
        }

        ngx_processes[n].exiting = 1;
    }
}",1,1,os\win32\ngx_process_cycle.c,ngx_quit_worker_processes,,false,407,439,ngx_quit_worker_processes,,,52,"void ngx_quit_worker_processes (ngx_cycle_t*,ngx_uint_t)"
417300,METHOD,os\win32\ngx_process_cycle.c:<global>,TYPE_DECL,"static void
ngx_terminate_worker_processes(ngx_cycle_t *cycle)
{
    ngx_int_t  n;

    for (n = 0; n < ngx_last_process; n++) {

        if (ngx_processes[n].handle == NULL) {
            continue;
        }

        if (TerminateProcess(ngx_processes[n].handle, 0) == 0) {
            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                          ""TerminateProcess(\""%p\"") failed"",
                          ngx_processes[n].handle);
        }

        ngx_processes[n].exiting = 1;

        ngx_close_handle(ngx_processes[n].reopen);
        ngx_close_handle(ngx_processes[n].quit);
        ngx_close_handle(ngx_processes[n].term);
        ngx_close_handle(ngx_processes[n].handle);
    }
}",1,1,os\win32\ngx_process_cycle.c,ngx_terminate_worker_processes,,false,442,466,ngx_terminate_worker_processes,,,53,void ngx_terminate_worker_processes (ngx_cycle_t*)
417381,METHOD,os\win32\ngx_process_cycle.c:<global>,TYPE_DECL,"static ngx_uint_t
ngx_reap_worker(ngx_cycle_t *cycle, HANDLE h)
{
    u_long     code;
    ngx_int_t  n;

    for (n = 0; n < ngx_last_process; n++) {

        if (ngx_processes[n].handle != h) {
            continue;
        }

        if (GetExitCodeProcess(h, &code) == 0) {
            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                          ""GetExitCodeProcess(%P) failed"",
                          ngx_processes[n].pid);
        }

        ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0,
                      ""%s process %P exited with code %Xl"",
                      ngx_processes[n].name, ngx_processes[n].pid, code);

        ngx_close_handle(ngx_processes[n].reopen);
        ngx_close_handle(ngx_processes[n].quit);
        ngx_close_handle(ngx_processes[n].term);
        ngx_close_handle(h);

        ngx_processes[n].handle = NULL;
        ngx_processes[n].term = NULL;
        ngx_processes[n].quit = NULL;
        ngx_processes[n].reopen = NULL;

        if (...",1,1,os\win32\ngx_process_cycle.c,ngx_reap_worker,,false,469,538,ngx_reap_worker,,,54,"ngx_uint_t ngx_reap_worker (ngx_cycle_t*,HANDLE)"
417603,METHOD,os\win32\ngx_process_cycle.c:<global>,TYPE_DECL,"static void
ngx_master_process_exit(ngx_cycle_t *cycle)
{
    ngx_uint_t  i;

    ngx_delete_pidfile(cycle);

    ngx_close_handle(ngx_cache_manager_mutex);
    ngx_close_handle(ngx_stop_event);
    ngx_close_handle(ngx_quit_event);
    ngx_close_handle(ngx_reopen_event);
    ngx_close_handle(ngx_reload_event);
    ngx_close_handle(ngx_master_process_event);

    ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, ""exit"");

    for (i = 0; cycle->modules[i]; i++) {
        if (cycle->modules[i]->exit_master) {
            cycle->modules[i]->exit_master(cycle);
        }
    }

    ngx_destroy_pool(cycle->pool);

    exit(0);
}",1,1,os\win32\ngx_process_cycle.c,ngx_master_process_exit,,false,541,566,ngx_master_process_exit,,,55,void ngx_master_process_exit (ngx_cycle_t*)
417667,METHOD,os\win32\ngx_process_cycle.c:<global>,TYPE_DECL,"static void
ngx_worker_process_cycle(ngx_cycle_t *cycle, char *mevn)
{
    char        wtevn[NGX_PROCESS_SYNC_NAME];
    char        wqevn[NGX_PROCESS_SYNC_NAME];
    char        wroevn[NGX_PROCESS_SYNC_NAME];
    HANDLE      mev, events[3];
    u_long      nev, ev;
    ngx_err_t   err;
    ngx_tid_t   wtid, cmtid, cltid;
    ngx_log_t  *log;

    log = cycle->log;

    ngx_log_debug0(NGX_LOG_DEBUG_CORE, log, 0, ""worker started"");

    ngx_sprintf((u_char *) wtevn, ""ngx_worker_term_%P%Z"", ngx_pid);
    events[0] = CreateEvent(NULL, 1, 0, wtevn);
    if (events[0] == NULL) {
        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,
                      ""CreateEvent(\""%s\"") failed"", wtevn);
        goto failed;
    }

    ngx_sprintf((u_char *) wqevn, ""ngx_worker_quit_%P%Z"", ngx_pid);
    events[1] = CreateEvent(NULL, 1, 0, wqevn);
    if (events[1] == NULL) {
        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,
                      ""CreateEvent(\""%s\"") failed"", wqevn);
        goto fail...",1,1,os\win32\ngx_process_cycle.c,ngx_worker_process_cycle,,false,569,759,ngx_worker_process_cycle,,,56,"void ngx_worker_process_cycle (ngx_cycle_t*,char*)"
418112,METHOD,os\win32\ngx_process_cycle.c:<global>,TYPE_DECL,"static ngx_thread_value_t __stdcall
ngx_worker_thread(void *data)
{
    ngx_int_t     n;
    ngx_time_t   *tp;
    ngx_cycle_t  *cycle;

    tp = ngx_timeofday();
    srand((ngx_pid << 16) ^ (unsigned) tp->sec ^ tp->msec);

    cycle = (ngx_cycle_t *) ngx_cycle;

    for (n = 0; cycle->modules[n]; n++) {
        if (cycle->modules[n]->init_process) {
            if (cycle->modules[n]->init_process(cycle) == NGX_ERROR) {
                /* fatal */
                exit(2);
            }
        }
    }

    while (!ngx_quit) {

        if (ngx_exiting) {
            if (ngx_event_no_timers_left() == NGX_OK) {
                break;
            }
        }

        ngx_log_debug0(NGX_LOG_DEBUG_CORE, cycle->log, 0, ""worker cycle"");

        ngx_process_events_and_timers(cycle);

        if (ngx_terminate) {
            return 0;
        }

        if (ngx_quit) {
            ngx_quit = 0;

            if (!ngx_exiting) {
                ngx_exiting = 1;
                ngx_set_shutdown...",1,26,os\win32\ngx_process_cycle.c,ngx_worker_thread,,false,762,819,ngx_worker_thread,,,57,ngx_thread_value_t ngx_worker_thread (void*)
418244,METHOD,os\win32\ngx_process_cycle.c:<global>,TYPE_DECL,"static void
ngx_worker_process_exit(ngx_cycle_t *cycle)
{
    ngx_uint_t         i;
    ngx_connection_t  *c;

    ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, ""exit"");

    for (i = 0; cycle->modules[i]; i++) {
        if (cycle->modules[i]->exit_process) {
            cycle->modules[i]->exit_process(cycle);
        }
    }

    if (ngx_exiting) {
        c = cycle->connections;
        for (i = 0; i < cycle->connection_n; i++) {
            if (c[i].fd != (ngx_socket_t) -1
                && c[i].read
                && !c[i].read->accept
                && !c[i].read->channel
                && !c[i].read->resolver)
            {
                ngx_log_error(NGX_LOG_ALERT, cycle->log, 0,
                              ""*%uA open socket #%d left in connection %ui"",
                              c[i].number, c[i].fd, i);
            }
        }
    }

    ngx_destroy_pool(cycle->pool);

    exit(0);
}",1,1,os\win32\ngx_process_cycle.c,ngx_worker_process_exit,,false,822,855,ngx_worker_process_exit,,,58,void ngx_worker_process_exit (ngx_cycle_t*)
418378,METHOD,os\win32\ngx_process_cycle.c:<global>,TYPE_DECL,"static ngx_thread_value_t __stdcall
ngx_cache_manager_thread(void *data)
{
    u_long        ev;
    HANDLE        events[2];
    ngx_err_t     err;
    ngx_cycle_t  *cycle;

    cycle = (ngx_cycle_t *) ngx_cycle;

    events[0] = ngx_cache_manager_event;
    events[1] = ngx_cache_manager_mutex;

    for ( ;; ) {
        ev = WaitForMultipleObjects(2, events, 0, INFINITE);

        err = ngx_errno;
        ngx_time_update();

        ngx_log_debug1(NGX_LOG_DEBUG_CORE, cycle->log, 0,
                       ""cache manager WaitForMultipleObjects: %ul"", ev);

        if (ev == WAIT_FAILED) {
            ngx_log_error(NGX_LOG_ALERT, cycle->log, err,
                          ""WaitForMultipleObjects() failed"");
        }

        /*
         * ev == WAIT_OBJECT_0
         * ev == WAIT_OBJECT_0 + 1
         * ev == WAIT_ABANDONED_0 + 1
         */

        if (ngx_terminate || ngx_quit || ngx_exiting) {
            ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, ""exiting"");
            return...",1,26,os\win32\ngx_process_cycle.c,ngx_cache_manager_thread,,false,858,915,ngx_cache_manager_thread,,,59,ngx_thread_value_t ngx_cache_manager_thread (void*)
418487,METHOD,os\win32\ngx_process_cycle.c:<global>,TYPE_DECL,"static void
ngx_cache_manager_process_handler(void)
{
    u_long        ev;
    ngx_uint_t    i;
    ngx_msec_t    next, n;
    ngx_path_t  **path;

    next = 60 * 60 * 1000;

    path = ngx_cycle->paths.elts;
    for (i = 0; i < ngx_cycle->paths.nelts; i++) {

        if (path[i]->manager) {
            n = path[i]->manager(path[i]->data);

            next = (n <= next) ? n : next;

            ngx_time_update();
        }
    }

    if (next == 0) {
        next = 1;
    }

    ev = WaitForSingleObject(ngx_cache_manager_event, (u_long) next);

    if (ev != WAIT_TIMEOUT) {

        ngx_time_update();

        ngx_log_debug1(NGX_LOG_DEBUG_CORE, ngx_cycle->log, 0,
                       ""cache manager WaitForSingleObject: %ul"", ev);
    }
}",1,1,os\win32\ngx_process_cycle.c,ngx_cache_manager_process_handler,,false,918,953,ngx_cache_manager_process_handler,,,60,void ngx_cache_manager_process_handler (void)
418584,METHOD,os\win32\ngx_process_cycle.c:<global>,TYPE_DECL,"static ngx_thread_value_t __stdcall
ngx_cache_loader_thread(void *data)
{
    ngx_uint_t     i;
    ngx_path_t   **path;
    ngx_cycle_t   *cycle;

    ngx_msleep(60000);

    cycle = (ngx_cycle_t *) ngx_cycle;

    path = cycle->paths.elts;
    for (i = 0; i < cycle->paths.nelts; i++) {

        if (ngx_terminate || ngx_quit || ngx_exiting) {
            break;
        }

        if (path[i]->loader) {
            path[i]->loader(path[i]->data);
            ngx_time_update();
        }
    }

    return 0;
}",1,26,os\win32\ngx_process_cycle.c,ngx_cache_loader_thread,,false,956,981,ngx_cache_loader_thread,,,61,ngx_thread_value_t ngx_cache_loader_thread (void*)
418650,METHOD,os\win32\ngx_process_cycle.c:<global>,TYPE_DECL,"void
ngx_single_process_cycle(ngx_cycle_t *cycle)
{
    ngx_tid_t  tid;

    ngx_console_init(cycle);

    if (ngx_create_signal_events(cycle) != NGX_OK) {
        exit(2);
    }

    if (ngx_create_thread(&tid, ngx_worker_thread, NULL, cycle->log) != 0) {
        /* fatal */
        exit(2);
    }

    /* STUB */
    WaitForSingleObject(ngx_stop_event, INFINITE);
}",1,1,os\win32\ngx_process_cycle.c,ngx_single_process_cycle,,false,984,1002,ngx_single_process_cycle,,,62,void ngx_single_process_cycle (ngx_cycle_t*)
418683,METHOD,os\win32\ngx_process_cycle.c:<global>,TYPE_DECL,"ngx_int_t
ngx_os_signal_process(ngx_cycle_t *cycle, char *sig, ngx_pid_t pid)
{
    HANDLE     ev;
    ngx_int_t  rc;
    char       evn[NGX_PROCESS_SYNC_NAME];

    ngx_sprintf((u_char *) evn, ""Global\\ngx_%s_%P%Z"", sig, pid);

    ev = OpenEvent(EVENT_MODIFY_STATE, 0, evn);
    if (ev == NULL) {
        ngx_log_error(NGX_LOG_ERR, cycle->log, ngx_errno,
                      ""OpenEvent(\""%s\"") failed"", evn);
        return 1;
    }

    if (SetEvent(ev) == 0) {
        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                      ""SetEvent(\""%s\"") failed"", evn);
        rc = 1;

    } else {
        rc = 0;
    }

    ngx_close_handle(ev);

    return rc;
}",1,1,os\win32\ngx_process_cycle.c,ngx_os_signal_process,,false,1005,1033,ngx_os_signal_process,,,63,"ngx_int_t ngx_os_signal_process (ngx_cycle_t*,char*,ngx_pid_t)"
418747,METHOD,os\win32\ngx_process_cycle.c:<global>,TYPE_DECL,"void
ngx_close_handle(HANDLE h)
{
    if (CloseHandle(h) == 0) {
        ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, ngx_errno,
                      ""CloseHandle(%p) failed"", h);
    }
}",1,1,os\win32\ngx_process_cycle.c,ngx_close_handle,,false,1036,1043,ngx_close_handle,,,64,void ngx_close_handle (HANDLE)
418773,METHOD,os\win32\ngx_process_cycle.h:<global>,TYPE_DECL,<global>,1,43,os\win32\ngx_process_cycle.h,os\win32\ngx_process_cycle.h:<global>,,false,1,44,<global>,,,1,
418775,METHOD,os\win32\ngx_process_cycle.h:<global>,TYPE_DECL,void ngx_master_process_cycle(ngx_cycle_t *cycle);,6,49,os\win32\ngx_process_cycle.h,ngx_master_process_cycle,,false,22,22,ngx_master_process_cycle,,,1,void ngx_master_process_cycle (ngx_cycle_t*)
418780,METHOD,os\win32\ngx_process_cycle.h:<global>,TYPE_DECL,void ngx_single_process_cycle(ngx_cycle_t *cycle);,6,49,os\win32\ngx_process_cycle.h,ngx_single_process_cycle,,false,23,23,ngx_single_process_cycle,,,2,void ngx_single_process_cycle (ngx_cycle_t*)
418785,METHOD,os\win32\ngx_process_cycle.h:<global>,TYPE_DECL,void ngx_close_handle(HANDLE h);,6,31,os\win32\ngx_process_cycle.h,ngx_close_handle,,false,24,24,ngx_close_handle,,,3,void ngx_close_handle (HANDLE)
418805,METHOD,os\win32\ngx_service.c:<global>,TYPE_DECL,<global>,1,9,os\win32\ngx_service.c,os\win32\ngx_service.c:<global>,,false,1,134,<global>,,,1,
418817,METHOD,os\win32\ngx_service.c:<global>,TYPE_DECL,"ngx_int_t
ngx_service(ngx_log_t *log)
{
    /* primary thread */

    /* StartServiceCtrlDispatcher() should be called within 30 seconds */

    if (StartServiceCtrlDispatcher(st) == 0) {
        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,
                      ""StartServiceCtrlDispatcher() failed"");
        return NGX_ERROR;
    }

    return NGX_OK;
}",1,1,os\win32\ngx_service.c,ngx_service,,false,19,33,ngx_service,,,3,ngx_int_t ngx_service (ngx_log_t*)
418837,METHOD,os\win32\ngx_service.c:<global>,TYPE_DECL,"void
service_main(u_int argc, char **argv)
{
    SERVICE_STATUS         status;
    SERVICE_STATUS_HANDLE  service;

    /* thread spawned by SCM */

    service = RegisterServiceCtrlHandlerEx(""nginx"", service_handler, ctx);
    if (service == INVALID_HANDLE_VALUE) {
        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,
                      ""RegisterServiceCtrlHandlerEx() failed"");
        return;
    }

    status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    status.dwCurrentState = SERVICE_START_PENDING;
    status.dwControlsAccepted = SERVICE_ACCEPT_STOP
                                |SERVICE_ACCEPT_PARAMCHANGE;
    status.dwWin32ExitCode = NO_ERROR;
    status.dwServiceSpecificExitCode = 0;
    status.dwCheckPoint = 1;
    status.dwWaitHint = 2000;

    /* SetServiceStatus() should be called within 80 seconds */

    if (SetServiceStatus(service, &status) == 0) {
        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,
                      ""SetServiceStatus() failed"");
        r...",1,1,os\win32\ngx_service.c,service_main,,false,36,87,service_main,,,4,"void service_main (u_int,char**)"
418942,METHOD,os\win32\ngx_service.c:<global>,TYPE_DECL,"u_int
service_handler(u_int control, u_int type, void *data, void *ctx)
{
    /* primary thread */

    switch (control) {

    case SERVICE_CONTROL_INTERROGATE:
        status = NGX_IOCP_INTERROGATE;
        break;

    case SERVICE_CONTROL_STOP:
        status = NGX_IOCP_STOP;
        break;

    case SERVICE_CONTROL_PARAMCHANGE:
        status = NGX_IOCP_RECONFIGURE;
        break;

    case NGX_SERVICE_CONTROL_SHUTDOWN:
        status = NGX_IOCP_REOPEN;
        break;

    case NGX_SERVICE_CONTROL_REOPEN:
        status = NGX_IOCP_REOPEN;
        break;

    default:
        return ERROR_CALL_NOT_IMPLEMENTED;
    }

    if (ngx_single) {
        if (PostQueuedCompletionStatus(iocp, ... status, ...) == 0) {
            err = ngx_errno;
            ngx_log_error(NGX_LOG_ALERT, log, err,
                          ""PostQueuedCompletionStatus() failed"");
            return err;
        }

    } else {
        Event
    }

    return NO_ERROR;
}",1,9,os\win32\ngx_service.c,service_handler,,false,90,134,service_handler,,,5,"u_int service_handler (u_int,u_int,void*,void*)"
419019,METHOD,os\win32\ngx_shmem.c:<global>,TYPE_DECL,<global>,1,38,os\win32\ngx_shmem.c,os\win32\ngx_shmem.c:<global>,,false,1,161,<global>,,,1,
419022,METHOD,os\win32\ngx_shmem.c:<global>,TYPE_DECL,"ngx_int_t
ngx_shm_alloc(ngx_shm_t *shm)
{
    u_char         *name;
    uint64_t        size;
    static u_char  *base = (u_char *) NGX_SHMEM_BASE;

    name = ngx_alloc(shm->name.len + 2 + NGX_INT32_LEN, shm->log);
    if (name == NULL) {
        return NGX_ERROR;
    }

    (void) ngx_sprintf(name, ""%V_%s%Z"", &shm->name, ngx_unique);

    ngx_set_errno(0);

    size = shm->size;

    shm->handle = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE,
                                    (u_long) (size >> 32),
                                    (u_long) (size & 0xffffffff),
                                    (char *) name);

    if (shm->handle == NULL) {
        ngx_log_error(NGX_LOG_ALERT, shm->log, ngx_errno,
                      ""CreateFileMapping(%uz, %s) failed"",
                      shm->size, name);
        ngx_free(name);

        return NGX_ERROR;
    }

    ngx_free(name);

    if (ngx_errno == ERROR_ALREADY_EXISTS) {
        shm->exists = 1;
    }

    shm->a...",1,38,os\win32\ngx_shmem.c,ngx_shm_alloc,,false,44,120,ngx_shm_alloc,,,2,ngx_int_t ngx_shm_alloc (ngx_shm_t*)
419227,METHOD,os\win32\ngx_shmem.c:<global>,TYPE_DECL,"ngx_int_t
ngx_shm_remap(ngx_shm_t *shm, u_char *addr)
{
    if (UnmapViewOfFile(shm->addr) == 0) {
        ngx_log_error(NGX_LOG_ALERT, shm->log, ngx_errno,
                      ""UnmapViewOfFile(%p) of file mapping \""%V\"" failed"",
                      shm->addr, &shm->name);
        return NGX_ERROR;
    }

    shm->addr = MapViewOfFileEx(shm->handle, FILE_MAP_WRITE, 0, 0, 0, addr);

    if (shm->addr != NULL) {
        return NGX_OK;
    }

    ngx_log_error(NGX_LOG_ALERT, shm->log, ngx_errno,
                  ""MapViewOfFileEx(%uz, %p) of file mapping \""%V\"" failed"",
                  shm->size, addr, &shm->name);

    return NGX_ERROR;
}",1,1,os\win32\ngx_shmem.c,ngx_shm_remap,,false,123,144,ngx_shm_remap,,,3,"ngx_int_t ngx_shm_remap (ngx_shm_t*,u_char*)"
419296,METHOD,os\win32\ngx_shmem.c:<global>,TYPE_DECL,"void
ngx_shm_free(ngx_shm_t *shm)
{
    if (UnmapViewOfFile(shm->addr) == 0) {
        ngx_log_error(NGX_LOG_ALERT, shm->log, ngx_errno,
                      ""UnmapViewOfFile(%p) of file mapping \""%V\"" failed"",
                      shm->addr, &shm->name);
    }

    if (CloseHandle(shm->handle) == 0) {
        ngx_log_error(NGX_LOG_ALERT, shm->log, ngx_errno,
                      ""CloseHandle() of file mapping \""%V\"" failed"",
                      &shm->name);
    }
}",1,1,os\win32\ngx_shmem.c,ngx_shm_free,,false,147,161,ngx_shm_free,,,4,void ngx_shm_free (ngx_shm_t*)
419349,METHOD,os\win32\ngx_shmem.h:<global>,TYPE_DECL,<global>,1,35,os\win32\ngx_shmem.h,os\win32\ngx_shmem.h:<global>,,false,1,33,<global>,,,1,
419359,METHOD,os\win32\ngx_shmem.h:<global>,TYPE_DECL,ngx_int_t ngx_shm_alloc(ngx_shm_t *shm);,11,39,os\win32\ngx_shmem.h,ngx_shm_alloc,,false,26,26,ngx_shm_alloc,,,3,ngx_int_t ngx_shm_alloc (ngx_shm_t*)
419364,METHOD,os\win32\ngx_shmem.h:<global>,TYPE_DECL,"ngx_int_t ngx_shm_remap(ngx_shm_t *shm, u_char *addr);",11,53,os\win32\ngx_shmem.h,ngx_shm_remap,,false,27,27,ngx_shm_remap,,,4,"ngx_int_t ngx_shm_remap (ngx_shm_t*,u_char*)"
419370,METHOD,os\win32\ngx_shmem.h:<global>,TYPE_DECL,void ngx_shm_free(ngx_shm_t *shm);,6,33,os\win32\ngx_shmem.h,ngx_shm_free,,false,28,28,ngx_shm_free,,,5,void ngx_shm_free (ngx_shm_t*)
419383,METHOD,os\win32\ngx_socket.c:<global>,TYPE_DECL,<global>,1,1,os\win32\ngx_socket.c,os\win32\ngx_socket.c:<global>,,false,1,49,<global>,,,1,
419385,METHOD,os\win32\ngx_socket.c:<global>,TYPE_DECL,"int
ngx_nonblocking(ngx_socket_t s)
{
    unsigned long  nb = 1;

    return ioctlsocket(s, FIONBIO, &nb);
}",1,1,os\win32\ngx_socket.c,ngx_nonblocking,,false,12,18,ngx_nonblocking,,,1,int ngx_nonblocking (ngx_socket_t)
419400,METHOD,os\win32\ngx_socket.c:<global>,TYPE_DECL,"int
ngx_blocking(ngx_socket_t s)
{
    unsigned long  nb = 0;

    return ioctlsocket(s, FIONBIO, &nb);
}",1,1,os\win32\ngx_socket.c,ngx_blocking,,false,21,27,ngx_blocking,,,2,int ngx_blocking (ngx_socket_t)
419415,METHOD,os\win32\ngx_socket.c:<global>,TYPE_DECL,"int
ngx_socket_nread(ngx_socket_t s, int *n)
{
    unsigned long  nread;

    if (ioctlsocket(s, FIONREAD, &nread) == -1) {
        return -1;
    }

    *n = nread;

    return 0;
}",1,1,os\win32\ngx_socket.c,ngx_socket_nread,,false,30,42,ngx_socket_nread,,,3,"int ngx_socket_nread (ngx_socket_t,int*)"
419441,METHOD,os\win32\ngx_socket.c:<global>,TYPE_DECL,"int
ngx_tcp_push(ngx_socket_t s)
{
    return 0;
}",1,1,os\win32\ngx_socket.c,ngx_tcp_push,,false,45,49,ngx_tcp_push,,,4,int ngx_tcp_push (ngx_socket_t)
419455,METHOD,os\win32\ngx_socket.h:<global>,TYPE_DECL,<global>,1,36,os\win32\ngx_socket.h,os\win32\ngx_socket.h:<global>,,false,1,253,<global>,,,1,
419459,METHOD,os\win32\ngx_socket.h:<global>,TYPE_DECL,int ngx_nonblocking(ngx_socket_t s);,5,35,os\win32\ngx_socket.h,ngx_nonblocking,,false,28,28,ngx_nonblocking,,,3,int ngx_nonblocking (ngx_socket_t)
419464,METHOD,os\win32\ngx_socket.h:<global>,TYPE_DECL,int ngx_blocking(ngx_socket_t s);,5,32,os\win32\ngx_socket.h,ngx_blocking,,false,29,29,ngx_blocking,,,4,int ngx_blocking (ngx_socket_t)
419469,METHOD,os\win32\ngx_socket.h:<global>,TYPE_DECL,"int ngx_socket_nread(ngx_socket_t s, int *n);",5,44,os\win32\ngx_socket.h,ngx_socket_nread,,false,34,34,ngx_socket_nread,,,5,"int ngx_socket_nread (ngx_socket_t,int*)"
419489,METHOD,os\win32\ngx_socket.h:<global>,TYPE_DECL,int ngx_tcp_push(ngx_socket_t s);,5,32,os\win32\ngx_socket.h,ngx_tcp_push,,false,249,249,ngx_tcp_push,,,20,int ngx_tcp_push (ngx_socket_t)
419501,METHOD,os\win32\ngx_stat.c:<global>,TYPE_DECL,<global>,1,2,os\win32\ngx_stat.c,os\win32\ngx_stat.c:<global>,,false,1,34,<global>,,,1,
419503,METHOD,os\win32\ngx_stat.c:<global>,TYPE_DECL,"int ngx_file_type(char *file, ngx_file_info_t *sb)
{
    sb->dwFileAttributes = GetFileAttributes(file);

    if (sb->dwFileAttributes == INVALID_FILE_ATTRIBUTES) {
        return -1;
    }

    return 0;
}",1,1,os\win32\ngx_stat.c,ngx_file_type,,false,12,21,ngx_file_type,,,1,"int ngx_file_type (char*,ngx_file_info_t*)"
419534,METHOD,os\win32\ngx_thread.c:<global>,TYPE_DECL,<global>,1,24,os\win32\ngx_thread.c,os\win32\ngx_thread.c:<global>,,false,1,30,<global>,,,1,
419536,METHOD,os\win32\ngx_thread.c:<global>,TYPE_DECL,"ngx_err_t
ngx_create_thread(ngx_tid_t *tid,
    ngx_thread_value_t (__stdcall *func)(void *arg), void *arg, ngx_log_t *log)
{
    u_long     id;
    ngx_err_t  err;

    *tid = CreateThread(NULL, 0, func, arg, 0, &id);

    if (*tid != NULL) {
        ngx_log_error(NGX_LOG_NOTICE, log, 0,
                      ""create thread "" NGX_TID_T_FMT, id);
        return 0;
    }

    err = ngx_errno;
    ngx_log_error(NGX_LOG_ALERT, log, err, ""CreateThread() failed"");
    return err;
}",1,24,os\win32\ngx_thread.c,ngx_create_thread,,false,12,30,ngx_create_thread,,,1,"ngx_err_t ngx_create_thread (ngx_tid_t*,ngx_thread_value_t,void*,ngx_log_t*)"
419583,METHOD,os\win32\ngx_thread.h:<global>,TYPE_DECL,<global>,1,24,os\win32\ngx_thread.h,os\win32\ngx_thread.h:<global>,,false,1,27,<global>,,,1,
419587,METHOD,os\win32\ngx_thread.h:<global>,TYPE_DECL,"ngx_err_t ngx_create_thread(ngx_tid_t *tid,
    ngx_thread_value_t (__stdcall *func)(void *arg), void *arg, ngx_log_t *log);",11,24,os\win32\ngx_thread.h,ngx_create_thread,,false,20,21,ngx_create_thread,,,3,"ngx_err_t ngx_create_thread (ngx_tid_t*,ngx_thread_value_t,void*,ngx_log_t*)"
419602,METHOD,os\win32\ngx_time.c:<global>,TYPE_DECL,<global>,1,1,os\win32\ngx_time.c,os\win32\ngx_time.c:<global>,,false,1,83,<global>,,,1,
419604,METHOD,os\win32\ngx_time.c:<global>,TYPE_DECL,"void
ngx_gettimeofday(struct timeval *tp)
{
    uint64_t  intervals;
    FILETIME  ft;

    GetSystemTimeAsFileTime(&ft);

    /*
     * A file time is a 64-bit value that represents the number
     * of 100-nanosecond intervals that have elapsed since
     * January 1, 1601 12:00 A.M. UTC.
     *
     * Between January 1, 1970 (Epoch) and January 1, 1601 there were
     * 134774 days,
     * 11644473600 seconds or
     * 11644473600,000,000,0 100-nanosecond intervals.
     *
     * See also MSKB Q167296.
     */

    intervals = ((uint64_t) ft.dwHighDateTime << 32) | ft.dwLowDateTime;
    intervals -= 116444736000000000;

    tp->tv_sec = (long) (intervals / 10000000);
    tp->tv_usec = (long) ((intervals % 10000000) / 10);
}",1,1,os\win32\ngx_time.c,ngx_gettimeofday,,false,12,38,ngx_gettimeofday,,,1,void ngx_gettimeofday (timeval*)
419650,METHOD,os\win32\ngx_time.c:<global>,TYPE_DECL,"void
ngx_libc_localtime(time_t s, struct tm *tm)
{
    struct tm  *t;

    t = localtime(&s);
    *tm = *t;
}",1,1,os\win32\ngx_time.c,ngx_libc_localtime,,false,41,48,ngx_libc_localtime,,,2,"void ngx_libc_localtime (time_t,tm*)"
419667,METHOD,os\win32\ngx_time.c:<global>,TYPE_DECL,"void
ngx_libc_gmtime(time_t s, struct tm *tm)
{
    struct tm  *t;

    t = gmtime(&s);
    *tm = *t;
}",1,1,os\win32\ngx_time.c,ngx_libc_gmtime,,false,51,58,ngx_libc_gmtime,,,3,"void ngx_libc_gmtime (time_t,tm*)"
419684,METHOD,os\win32\ngx_time.c:<global>,TYPE_DECL,"ngx_int_t
ngx_gettimezone(void)
{
    u_long                 n;
    TIME_ZONE_INFORMATION  tz;

    n = GetTimeZoneInformation(&tz);

    switch (n) {

    case TIME_ZONE_ID_UNKNOWN:
        return -tz.Bias;

    case TIME_ZONE_ID_STANDARD:
        return -(tz.Bias + tz.StandardBias);

    case TIME_ZONE_ID_DAYLIGHT:
        return -(tz.Bias + tz.DaylightBias);

    default: /* TIME_ZONE_ID_INVALID */
        return 0;
    }
}",1,1,os\win32\ngx_time.c,ngx_gettimezone,,false,61,83,ngx_gettimezone,,,4,ngx_int_t ngx_gettimezone (void)
419738,METHOD,os\win32\ngx_time.h:<global>,TYPE_DECL,<global>,1,34,os\win32\ngx_time.h,os\win32\ngx_time.h:<global>,,false,1,51,<global>,,,1,
419744,METHOD,os\win32\ngx_time.h:<global>,TYPE_DECL,ngx_int_t ngx_gettimezone(void);,11,31,os\win32\ngx_time.h,ngx_gettimezone,,false,45,45,ngx_gettimezone,,,5,ngx_int_t ngx_gettimezone (void)
419749,METHOD,os\win32\ngx_time.h:<global>,TYPE_DECL,"void ngx_libc_localtime(time_t s, struct tm *tm);",6,48,os\win32\ngx_time.h,ngx_libc_localtime,,false,46,46,ngx_libc_localtime,,,6,"void ngx_libc_localtime (time_t,tm*)"
419755,METHOD,os\win32\ngx_time.h:<global>,TYPE_DECL,"void ngx_libc_gmtime(time_t s, struct tm *tm);",6,45,os\win32\ngx_time.h,ngx_libc_gmtime,,false,47,47,ngx_libc_gmtime,,,7,"void ngx_libc_gmtime (time_t,tm*)"
419761,METHOD,os\win32\ngx_time.h:<global>,TYPE_DECL,void ngx_gettimeofday(struct timeval *tp);,6,41,os\win32\ngx_time.h,ngx_gettimeofday,,false,48,48,ngx_gettimeofday,,,8,void ngx_gettimeofday (timeval*)
419775,METHOD,os\win32\ngx_udp_wsarecv.c:<global>,TYPE_DECL,<global>,1,1,os\win32\ngx_udp_wsarecv.c,os\win32\ngx_udp_wsarecv.c:<global>,,false,1,149,<global>,,,1,
419777,METHOD,os\win32\ngx_udp_wsarecv.c:<global>,TYPE_DECL,"ssize_t
ngx_udp_wsarecv(ngx_connection_t *c, u_char *buf, size_t size)
{
    int           rc;
    u_long        bytes, flags;
    WSABUF        wsabuf[1];
    ngx_err_t     err;
    ngx_event_t  *rev;

    wsabuf[0].buf = (char *) buf;
    wsabuf[0].len = size;
    flags = 0;
    bytes = 0;

    rc = WSARecv(c->fd, wsabuf, 1, &bytes, &flags, NULL, NULL);

    ngx_log_debug4(NGX_LOG_DEBUG_EVENT, c->log, 0,
                   ""WSARecv: fd:%d rc:%d %ul of %z"", c->fd, rc, bytes, size);

    rev = c->read;

    if (rc == -1) {
        rev->ready = 0;
        err = ngx_socket_errno;

        if (err == WSAEWOULDBLOCK) {
            ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, err,
                           ""WSARecv() not ready"");
            return NGX_AGAIN;
        }

        rev->error = 1;
        ngx_connection_error(c, err, ""WSARecv() failed"");

        return NGX_ERROR;
    }

    return bytes;
}",1,1,os\win32\ngx_udp_wsarecv.c,ngx_udp_wsarecv,,false,13,51,ngx_udp_wsarecv,,,1,"ssize_t ngx_udp_wsarecv (ngx_connection_t*,u_char*,size_t)"
419885,METHOD,os\win32\ngx_udp_wsarecv.c:<global>,TYPE_DECL,"ssize_t
ngx_udp_overlapped_wsarecv(ngx_connection_t *c, u_char *buf, size_t size)
{
    int               rc;
    u_long            bytes, flags;
    WSABUF            wsabuf[1];
    ngx_err_t         err;
    ngx_event_t      *rev;
    LPWSAOVERLAPPED   ovlp;

    rev = c->read;

    if (!rev->ready) {
        ngx_log_error(NGX_LOG_ALERT, c->log, 0, ""second wsa post"");
        return NGX_AGAIN;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,
                   ""rev->complete: %d"", rev->complete);

    if (rev->complete) {
        rev->complete = 0;

        if (ngx_event_flags & NGX_USE_IOCP_EVENT) {
            if (rev->ovlp.error) {
                ngx_connection_error(c, rev->ovlp.error, ""WSARecv() failed"");
                return NGX_ERROR;
            }

            ngx_log_debug3(NGX_LOG_DEBUG_EVENT, c->log, 0,
                           ""WSARecv ovlp: fd:%d %ul of %z"",
                           c->fd, rev->available, size);

            return rev->available;
    ...",1,1,os\win32\ngx_udp_wsarecv.c,ngx_udp_overlapped_wsarecv,,false,54,149,ngx_udp_overlapped_wsarecv,,,2,"ssize_t ngx_udp_overlapped_wsarecv (ngx_connection_t*,u_char*,size_t)"
420146,METHOD,os\win32\ngx_user.c:<global>,TYPE_DECL,<global>,1,22,os\win32\ngx_user.c,os\win32\ngx_user.c:<global>,,false,1,23,<global>,,,1,
420155,METHOD,os\win32\ngx_user.h:<global>,TYPE_DECL,<global>,1,34,os\win32\ngx_user.h,os\win32\ngx_user.h:<global>,,false,1,25,<global>,,,1,
420157,METHOD,os\win32\ngx_user.h:<global>,TYPE_DECL,"ngx_int_t ngx_libc_crypt(ngx_pool_t *pool, u_char *key, u_char *salt,
    u_char **encrypted);",11,23,os\win32\ngx_user.h,ngx_libc_crypt,,false,21,22,ngx_libc_crypt,,,1,"ngx_int_t ngx_libc_crypt (ngx_pool_t*,u_char*,u_char*,u_char**)"
420196,METHOD,os\win32\ngx_win32_config.h:<global>,TYPE_DECL,<global>,1,5,os\win32\ngx_win32_config.h,os\win32\ngx_win32_config.h:<global>,,false,1,286,<global>,,,1,
420217,METHOD,os\win32\ngx_win32_init.c:<global>,TYPE_DECL,<global>,1,1,os\win32\ngx_win32_init.c,os\win32\ngx_win32_init.c:<global>,,false,1,329,<global>,,,1,
420282,METHOD,os\win32\ngx_win32_init.c:<global>,TYPE_DECL,"ngx_int_t
ngx_os_init(ngx_log_t *log)
{
    DWORD         bytes;
    SOCKET        s;
    WSADATA       wsd;
    ngx_err_t     err;
    ngx_time_t   *tp;
    ngx_uint_t    n;
    SYSTEM_INFO   si;

    /* get Windows version */

    ngx_memzero(&osvi, sizeof(OSVERSIONINFOEX));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

#ifdef _MSC_VER
#pragma warning(disable:4996)
#endif

    osviex = GetVersionEx((OSVERSIONINFO *) &osvi);

    if (osviex == 0) {
        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        if (GetVersionEx((OSVERSIONINFO *) &osvi) == 0) {
            ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,
                          ""GetVersionEx() failed"");
            return NGX_ERROR;
        }
    }

#ifdef _MSC_VER
#pragma warning(default:4996)
#endif

    /*
     *  Windows 3.1 Win32s   0xxxxx
     *
     *  Windows 95           140000
     *  Windows 98           141000
     *  Windows ME           149000
     *  Windows NT 3.51      235100
     *  Wi...",1,1,os\win32\ngx_win32_init.c,ngx_os_init,,false,67,279,ngx_os_init,,,34,ngx_int_t ngx_os_init (ngx_log_t*)
420668,METHOD,os\win32\ngx_win32_init.c:<global>,TYPE_DECL,"void
ngx_os_status(ngx_log_t *log)
{
    ngx_osviex_stub_t  *osviex_stub;

    ngx_log_error(NGX_LOG_NOTICE, log, 0, NGINX_VER_BUILD);

    if (osviex) {

        /*
         * the MSVC 6.0 SP2 defines wSuiteMask and wProductType
         * as WORD wReserved[2]
         */
        osviex_stub = (ngx_osviex_stub_t *) &osvi.wServicePackMinor;

        ngx_log_error(NGX_LOG_INFO, log, 0,
                      ""OS: %ud build:%ud, \""%s\"", suite:%Xd, type:%ud"",
                      ngx_win32_version, osvi.dwBuildNumber, osvi.szCSDVersion,
                      osviex_stub->wSuiteMask, osviex_stub->wProductType);

    } else {
        if (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) {

            /* Win9x build */

            ngx_log_error(NGX_LOG_INFO, log, 0,
                          ""OS: %u build:%ud.%ud.%ud, \""%s\"""",
                          ngx_win32_version,
                          osvi.dwBuildNumber >> 24,
                          (osvi.dwBuildNumber >> 16) & 0xff,
     ...",1,1,os\win32\ngx_win32_init.c,ngx_os_status,,false,282,329,ngx_os_status,,,35,void ngx_os_status (ngx_log_t*)
420766,METHOD,os\win32\ngx_wsarecv.c:<global>,TYPE_DECL,<global>,1,1,os\win32\ngx_wsarecv.c,os\win32\ngx_wsarecv.c:<global>,,false,1,213,<global>,,,1,
420768,METHOD,os\win32\ngx_wsarecv.c:<global>,TYPE_DECL,"ssize_t
ngx_wsarecv(ngx_connection_t *c, u_char *buf, size_t size)
{
    int           rc;
    u_long        bytes, flags;
    WSABUF        wsabuf[1];
    ngx_err_t     err;
    ngx_int_t     n;
    ngx_event_t  *rev;

    wsabuf[0].buf = (char *) buf;
    wsabuf[0].len = size;
    flags = 0;
    bytes = 0;

    rc = WSARecv(c->fd, wsabuf, 1, &bytes, &flags, NULL, NULL);

    ngx_log_debug4(NGX_LOG_DEBUG_EVENT, c->log, 0,
                   ""WSARecv: fd:%d rc:%d %ul of %z"", c->fd, rc, bytes, size);

    rev = c->read;

    if (rc == -1) {
        rev->ready = 0;
        err = ngx_socket_errno;

        if (err == WSAEWOULDBLOCK) {
            ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, err,
                           ""WSARecv() not ready"");
            return NGX_AGAIN;
        }

        n = ngx_connection_error(c, err, ""WSARecv() failed"");

        if (n == NGX_ERROR) {
            rev->error = 1;
        }

        return n;
    }

#if (NGX_HAVE_FIONREAD)

    if (rev->available...",1,1,os\win32\ngx_wsarecv.c,ngx_wsarecv,,false,13,102,ngx_wsarecv,,,1,"ssize_t ngx_wsarecv (ngx_connection_t*,u_char*,size_t)"
420904,METHOD,os\win32\ngx_wsarecv.c:<global>,TYPE_DECL,"ssize_t
ngx_overlapped_wsarecv(ngx_connection_t *c, u_char *buf, size_t size)
{
    int               rc;
    u_long            bytes, flags;
    WSABUF            wsabuf[1];
    ngx_err_t         err;
    ngx_int_t         n;
    ngx_event_t      *rev;
    LPWSAOVERLAPPED   ovlp;

    rev = c->read;

    if (!rev->ready) {
        ngx_log_error(NGX_LOG_ALERT, c->log, 0, ""second wsa post"");
        return NGX_AGAIN;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,
                   ""rev->complete: %d"", rev->complete);

    if (rev->complete) {
        rev->complete = 0;

        if (ngx_event_flags & NGX_USE_IOCP_EVENT) {
            if (rev->ovlp.error) {
                ngx_connection_error(c, rev->ovlp.error, ""WSARecv() failed"");
                return NGX_ERROR;
            }

            ngx_log_debug3(NGX_LOG_DEBUG_EVENT, c->log, 0,
                           ""WSARecv ovlp: fd:%d %ul of %z"",
                           c->fd, rev->available, size);

            return...",1,1,os\win32\ngx_wsarecv.c,ngx_overlapped_wsarecv,,false,105,213,ngx_overlapped_wsarecv,,,2,"ssize_t ngx_overlapped_wsarecv (ngx_connection_t*,u_char*,size_t)"
421197,METHOD,os\win32\ngx_wsarecv_chain.c:<global>,TYPE_DECL,<global>,1,26,os\win32\ngx_wsarecv_chain.c,os\win32\ngx_wsarecv_chain.c:<global>,,false,1,141,<global>,,,1,
421199,METHOD,os\win32\ngx_wsarecv_chain.c:<global>,TYPE_DECL,"ssize_t
ngx_wsarecv_chain(ngx_connection_t *c, ngx_chain_t *chain, off_t limit)
{
    int           rc;
    u_char       *prev;
    u_long        bytes, flags;
    size_t        n, size;
    ngx_err_t     err;
    ngx_array_t   vec;
    ngx_event_t  *rev;
    LPWSABUF      wsabuf;
    WSABUF        wsabufs[NGX_WSABUFS];

    prev = NULL;
    wsabuf = NULL;
    flags = 0;
    size = 0;
    bytes = 0;

    vec.elts = wsabufs;
    vec.nelts = 0;
    vec.size = sizeof(WSABUF);
    vec.nalloc = NGX_WSABUFS;
    vec.pool = c->pool;

    /* coalesce the neighbouring bufs */

    while (chain) {
        n = chain->buf->end - chain->buf->last;

        if (limit) {
            if (size >= (size_t) limit) {
                break;
            }

            if (size + n > (size_t) limit) {
                n = (size_t) limit - size;
            }
        }

        if (prev == chain->buf->last) {
            wsabuf->len += n;

        } else {
            wsabuf = ngx_array_push(&vec);
        ...",1,26,os\win32\ngx_wsarecv_chain.c,ngx_wsarecv_chain,,false,16,141,ngx_wsarecv_chain,,,1,"ssize_t ngx_wsarecv_chain (ngx_connection_t*,ngx_chain_t*,off_t)"
421470,METHOD,os\win32\ngx_wsasend.c:<global>,TYPE_DECL,<global>,1,1,os\win32\ngx_wsasend.c,os\win32\ngx_wsasend.c:<global>,,false,1,185,<global>,,,1,
421472,METHOD,os\win32\ngx_wsasend.c:<global>,TYPE_DECL,"ssize_t
ngx_wsasend(ngx_connection_t *c, u_char *buf, size_t size)
{
    int           n;
    u_long        sent;
    ngx_err_t     err;
    ngx_event_t  *wev;
    WSABUF        wsabuf;

    wev = c->write;

    if (!wev->ready) {
        return NGX_AGAIN;
    }

    /*
     * WSABUF must be 4-byte aligned otherwise
     * WSASend() will return undocumented WSAEINVAL error.
     */

    wsabuf.buf = (char *) buf;
    wsabuf.len = size;

    sent = 0;

    n = WSASend(c->fd, &wsabuf, 1, &sent, 0, NULL, NULL);

    ngx_log_debug4(NGX_LOG_DEBUG_EVENT, c->log, 0,
                   ""WSASend: fd:%d, %d, %ul of %uz"", c->fd, n, sent, size);

    if (n == 0) {
        if (sent < size) {
            wev->ready = 0;
        }

        c->sent += sent;

        return sent;
    }

    err = ngx_socket_errno;

    if (err == WSAEWOULDBLOCK) {
        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, err, ""WSASend() not ready"");
        wev->ready = 0;
        return NGX_AGAIN;
    }

    wev->error =...",1,1,os\win32\ngx_wsasend.c,ngx_wsasend,,false,13,65,ngx_wsasend,,,1,"ssize_t ngx_wsasend (ngx_connection_t*,u_char*,size_t)"
421594,METHOD,os\win32\ngx_wsasend.c:<global>,TYPE_DECL,"ssize_t
ngx_overlapped_wsasend(ngx_connection_t *c, u_char *buf, size_t size)
{
    int               n;
    u_long            sent;
    ngx_err_t         err;
    ngx_event_t      *wev;
    LPWSAOVERLAPPED   ovlp;
    WSABUF            wsabuf;

    wev = c->write;

    if (!wev->ready) {
        return NGX_AGAIN;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,
                   ""wev->complete: %d"", wev->complete);

    if (!wev->complete) {

        /* post the overlapped WSASend() */

        /*
         * WSABUFs must be 4-byte aligned otherwise
         * WSASend() will return undocumented WSAEINVAL error.
         */

        wsabuf.buf = (char *) buf;
        wsabuf.len = size;

        sent = 0;

        ovlp = (LPWSAOVERLAPPED) &c->write->ovlp;
        ngx_memzero(ovlp, sizeof(WSAOVERLAPPED));

        n = WSASend(c->fd, &wsabuf, 1, &sent, 0, ovlp, NULL);

        ngx_log_debug4(NGX_LOG_DEBUG_EVENT, c->log, 0,
                       ""WSASend: fd:%d, %d, %ul of %uz...",1,1,os\win32\ngx_wsasend.c,ngx_overlapped_wsasend,,false,68,185,ngx_overlapped_wsasend,,,2,"ssize_t ngx_overlapped_wsasend (ngx_connection_t*,u_char*,size_t)"
421863,METHOD,os\win32\ngx_wsasend_chain.c:<global>,TYPE_DECL,<global>,1,26,os\win32\ngx_wsasend_chain.c,os\win32\ngx_wsasend_chain.c:<global>,,false,1,292,<global>,,,1,
421865,METHOD,os\win32\ngx_wsasend_chain.c:<global>,TYPE_DECL,"ngx_chain_t *
ngx_wsasend_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)
{
    int           rc;
    u_char       *prev;
    u_long        size, sent, send, prev_send;
    ngx_err_t     err;
    ngx_event_t  *wev;
    ngx_array_t   vec;
    ngx_chain_t  *cl;
    LPWSABUF      wsabuf;
    WSABUF        wsabufs[NGX_WSABUFS];

    wev = c->write;

    if (!wev->ready) {
        return in;
    }

    /* the maximum limit size is the maximum u_long value - the page size */

    if (limit == 0 || limit > (off_t) (NGX_MAX_UINT32_VALUE - ngx_pagesize)) {
        limit = NGX_MAX_UINT32_VALUE - ngx_pagesize;
    }

    send = 0;

    /*
     * WSABUFs must be 4-byte aligned otherwise
     * WSASend() will return undocumented WSAEINVAL error.
     */

    vec.elts = wsabufs;
    vec.size = sizeof(WSABUF);
    vec.nalloc = NGX_WSABUFS;
    vec.pool = c->pool;

    for ( ;; ) {
        prev = NULL;
        wsabuf = NULL;
        prev_send = send;

        vec.nelts = 0;

        /* cre...",1,26,os\win32\ngx_wsasend_chain.c,ngx_wsasend_chain,,false,16,127,ngx_wsasend_chain,,,1,"ngx_chain_t ngx_wsasend_chain (ngx_connection_t*,ngx_chain_t*,off_t)"
422188,METHOD,os\win32\ngx_wsasend_chain.c:<global>,TYPE_DECL,"ngx_chain_t *
ngx_overlapped_wsasend_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)
{
    int               rc;
    u_char           *prev;
    u_long            size, send, sent;
    ngx_err_t         err;
    ngx_event_t      *wev;
    ngx_array_t       vec;
    ngx_chain_t      *cl;
    LPWSAOVERLAPPED   ovlp;
    LPWSABUF          wsabuf;
    WSABUF            wsabufs[NGX_WSABUFS];

    wev = c->write;

    if (!wev->ready) {
        return in;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,
                   ""wev->complete: %d"", wev->complete);

    if (!wev->complete) {

        /* post the overlapped WSASend() */

        /* the maximum limit size is the maximum u_long value - the page size */

        if (limit == 0 || limit > (off_t) (NGX_MAX_UINT32_VALUE - ngx_pagesize))
        {
            limit = NGX_MAX_UINT32_VALUE - ngx_pagesize;
        }

        /*
         * WSABUFs must be 4-byte aligned otherwise
         * WSASend() will return undocument...",1,30,os\win32\ngx_wsasend_chain.c,ngx_overlapped_wsasend_chain,,false,130,292,ngx_overlapped_wsasend_chain,,,2,"ngx_chain_t ngx_overlapped_wsasend_chain (ngx_connection_t*,ngx_chain_t*,off_t)"
422635,METHOD,stream\ngx_stream.c:<global>,TYPE_DECL,<global>,1,1,stream\ngx_stream.c,stream\ngx_stream.c:<global>,,false,1,651,<global>,,,1,
422637,METHOD,stream\ngx_stream.c:<global>,TYPE_DECL,"static char *ngx_stream_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",13,77,stream\ngx_stream.c,ngx_stream_block,,false,14,14,ngx_stream_block,,,1,"char* ngx_stream_block (ngx_conf_t*,ngx_command_t*,void*)"
422644,METHOD,stream\ngx_stream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_init_phases(ngx_conf_t *cf,
    ngx_stream_core_main_conf_t *cmcf);",18,38,stream\ngx_stream.c,ngx_stream_init_phases,,false,15,16,ngx_stream_init_phases,,,2,"ngx_int_t ngx_stream_init_phases (ngx_conf_t*,ngx_stream_core_main_conf_t*)"
422650,METHOD,stream\ngx_stream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_init_phase_handlers(ngx_conf_t *cf,
    ngx_stream_core_main_conf_t *cmcf);",18,38,stream\ngx_stream.c,ngx_stream_init_phase_handlers,,false,17,18,ngx_stream_init_phase_handlers,,,3,"ngx_int_t ngx_stream_init_phase_handlers (ngx_conf_t*,ngx_stream_core_main_conf_t*)"
422656,METHOD,stream\ngx_stream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_add_ports(ngx_conf_t *cf, ngx_array_t *ports,
    ngx_stream_listen_t *listen);",18,32,stream\ngx_stream.c,ngx_stream_add_ports,,false,19,20,ngx_stream_add_ports,,,4,"ngx_int_t ngx_stream_add_ports (ngx_conf_t*,ngx_array_t*,ngx_stream_listen_t*)"
422663,METHOD,stream\ngx_stream.c:<global>,TYPE_DECL,"static char *ngx_stream_optimize_servers(ngx_conf_t *cf, ngx_array_t *ports);",13,76,stream\ngx_stream.c,ngx_stream_optimize_servers,,false,21,21,ngx_stream_optimize_servers,,,5,"char* ngx_stream_optimize_servers (ngx_conf_t*,ngx_array_t*)"
422669,METHOD,stream\ngx_stream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_add_addrs(ngx_conf_t *cf, ngx_stream_port_t *stport,
    ngx_stream_conf_addr_t *addr);",18,33,stream\ngx_stream.c,ngx_stream_add_addrs,,false,22,23,ngx_stream_add_addrs,,,6,"ngx_int_t ngx_stream_add_addrs (ngx_conf_t*,ngx_stream_port_t*,ngx_stream_conf_addr_t*)"
422676,METHOD,stream\ngx_stream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_cmp_conf_addrs(const void *one, const void *two);",18,76,stream\ngx_stream.c,ngx_stream_cmp_conf_addrs,,false,28,28,ngx_stream_cmp_conf_addrs,,,7,"ngx_int_t ngx_stream_cmp_conf_addrs (void*,void*)"
422726,METHOD,stream\ngx_stream.c:<global>,TYPE_DECL,"static char *
ngx_stream_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char                          *rv;
    ngx_uint_t                     i, m, mi, s;
    ngx_conf_t                     pcf;
    ngx_array_t                    ports;
    ngx_stream_listen_t           *listen;
    ngx_stream_module_t           *module;
    ngx_stream_conf_ctx_t         *ctx;
    ngx_stream_core_srv_conf_t   **cscfp;
    ngx_stream_core_main_conf_t   *cmcf;

    if (*(ngx_stream_conf_ctx_t **) conf) {
        return ""is duplicate"";
    }

    /* the main stream context */

    ctx = ngx_pcalloc(cf->pool, sizeof(ngx_stream_conf_ctx_t));
    if (ctx == NULL) {
        return NGX_CONF_ERROR;
    }

    *(ngx_stream_conf_ctx_t **) conf = ctx;

    /* count the number of the stream modules and set up their indices */

    ngx_stream_max_module = ngx_count_modules(cf->cycle, NGX_STREAM_MODULE);


    /* the stream main_conf context, it's the same in the all stream contexts */

    ctx->main_...",1,1,stream\ngx_stream.c,ngx_stream_block,,false,73,269,ngx_stream_block,,,16,"char* ngx_stream_block (ngx_conf_t*,ngx_command_t*,void*)"
423322,METHOD,stream\ngx_stream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_init_phases(ngx_conf_t *cf, ngx_stream_core_main_conf_t *cmcf)
{
    if (ngx_array_init(&cmcf->phases[NGX_STREAM_POST_ACCEPT_PHASE].handlers,
                       cf->pool, 1, sizeof(ngx_stream_handler_pt))
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    if (ngx_array_init(&cmcf->phases[NGX_STREAM_PREACCESS_PHASE].handlers,
                       cf->pool, 1, sizeof(ngx_stream_handler_pt))
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    if (ngx_array_init(&cmcf->phases[NGX_STREAM_ACCESS_PHASE].handlers,
                       cf->pool, 1, sizeof(ngx_stream_handler_pt))
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    if (ngx_array_init(&cmcf->phases[NGX_STREAM_SSL_PHASE].handlers,
                       cf->pool, 1, sizeof(ngx_stream_handler_pt))
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    if (ngx_array_init(&cmcf->phases[NGX_STREAM_PREREAD_PHASE].handlers,
                       cf->pool, 1, si...",1,1,stream\ngx_stream.c,ngx_stream_init_phases,,false,272,318,ngx_stream_init_phases,,,17,"ngx_int_t ngx_stream_init_phases (ngx_conf_t*,ngx_stream_core_main_conf_t*)"
423456,METHOD,stream\ngx_stream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_init_phase_handlers(ngx_conf_t *cf,
    ngx_stream_core_main_conf_t *cmcf)
{
    ngx_int_t                     j;
    ngx_uint_t                    i, n;
    ngx_stream_handler_pt        *h;
    ngx_stream_phase_handler_t   *ph;
    ngx_stream_phase_handler_pt   checker;

    n = 1 /* content phase */;

    for (i = 0; i < NGX_STREAM_LOG_PHASE; i++) {
        n += cmcf->phases[i].handlers.nelts;
    }

    ph = ngx_pcalloc(cf->pool,
                     n * sizeof(ngx_stream_phase_handler_t) + sizeof(void *));
    if (ph == NULL) {
        return NGX_ERROR;
    }

    cmcf->phase_engine.handlers = ph;
    n = 0;

    for (i = 0; i < NGX_STREAM_LOG_PHASE; i++) {
        h = cmcf->phases[i].handlers.elts;

        switch (i) {

        case NGX_STREAM_PREREAD_PHASE:
            checker = ngx_stream_core_preread_phase;
            break;

        case NGX_STREAM_CONTENT_PHASE:
            ph->checker = ngx_stream_core_content_phase;
            n++;
        ...",1,1,stream\ngx_stream.c,ngx_stream_init_phase_handlers,,false,321,377,ngx_stream_init_phase_handlers,,,18,"ngx_int_t ngx_stream_init_phase_handlers (ngx_conf_t*,ngx_stream_core_main_conf_t*)"
423623,METHOD,stream\ngx_stream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_add_ports(ngx_conf_t *cf, ngx_array_t *ports,
    ngx_stream_listen_t *listen)
{
    in_port_t                p;
    ngx_uint_t               i;
    struct sockaddr         *sa;
    ngx_stream_conf_port_t  *port;
    ngx_stream_conf_addr_t  *addr;

    sa = listen->sockaddr;
    p = ngx_inet_get_port(sa);

    port = ports->elts;
    for (i = 0; i < ports->nelts; i++) {

        if (p == port[i].port
            && listen->type == port[i].type
            && sa->sa_family == port[i].family)
        {
            /* a port is already in the port list */

            port = &port[i];
            goto found;
        }
    }

    /* add a port to the port list */

    port = ngx_array_push(ports);
    if (port == NULL) {
        return NGX_ERROR;
    }

    port->family = sa->sa_family;
    port->type = listen->type;
    port->port = p;

    if (ngx_array_init(&port->addrs, cf->temp_pool, 2,
                       sizeof(ngx_stream_conf_addr_t))
        != NG...",1,1,stream\ngx_stream.c,ngx_stream_add_ports,,false,380,435,ngx_stream_add_ports,,,19,"ngx_int_t ngx_stream_add_ports (ngx_conf_t*,ngx_array_t*,ngx_stream_listen_t*)"
423768,METHOD,stream\ngx_stream.c:<global>,TYPE_DECL,"static char *
ngx_stream_optimize_servers(ngx_conf_t *cf, ngx_array_t *ports)
{
    ngx_uint_t                   i, p, last, bind_wildcard;
    ngx_listening_t             *ls;
    ngx_stream_port_t           *stport;
    ngx_stream_conf_port_t      *port;
    ngx_stream_conf_addr_t      *addr;
    ngx_stream_core_srv_conf_t  *cscf;

    port = ports->elts;
    for (p = 0; p < ports->nelts; p++) {

        ngx_sort(port[p].addrs.elts, (size_t) port[p].addrs.nelts,
                 sizeof(ngx_stream_conf_addr_t), ngx_stream_cmp_conf_addrs);

        addr = port[p].addrs.elts;
        last = port[p].addrs.nelts;

        /*
         * if there is the binding to the ""*:port"" then we need to bind()
         * to the ""*:port"" only and ignore the other bindings
         */

        if (addr[last - 1].opt.wildcard) {
            addr[last - 1].opt.bind = 1;
            bind_wildcard = 1;

        } else {
            bind_wildcard = 0;
        }

        i = 0;

        while (i < last) {
...",1,1,stream\ngx_stream.c,ngx_stream_optimize_servers,,false,438,547,ngx_stream_optimize_servers,,,20,"char* ngx_stream_optimize_servers (ngx_conf_t*,ngx_array_t*)"
424087,METHOD,stream\ngx_stream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_add_addrs(ngx_conf_t *cf, ngx_stream_port_t *stport,
    ngx_stream_conf_addr_t *addr)
{
    ngx_uint_t             i;
    struct sockaddr_in    *sin;
    ngx_stream_in_addr_t  *addrs;

    stport->addrs = ngx_pcalloc(cf->pool,
                                stport->naddrs * sizeof(ngx_stream_in_addr_t));
    if (stport->addrs == NULL) {
        return NGX_ERROR;
    }

    addrs = stport->addrs;

    for (i = 0; i < stport->naddrs; i++) {

        sin = (struct sockaddr_in *) addr[i].opt.sockaddr;
        addrs[i].addr = sin->sin_addr.s_addr;

        addrs[i].conf.ctx = addr[i].opt.ctx;
#if (NGX_STREAM_SSL)
        addrs[i].conf.ssl = addr[i].opt.ssl;
#endif
        addrs[i].conf.proxy_protocol = addr[i].opt.proxy_protocol;
        addrs[i].conf.addr_text = addr[i].opt.addr_text;
    }

    return NGX_OK;
}",1,1,stream\ngx_stream.c,ngx_stream_add_addrs,,false,550,580,ngx_stream_add_addrs,,,21,"ngx_int_t ngx_stream_add_addrs (ngx_conf_t*,ngx_stream_port_t*,ngx_stream_conf_addr_t*)"
424207,METHOD,stream\ngx_stream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_cmp_conf_addrs(const void *one, const void *two)
{
    ngx_stream_conf_addr_t  *first, *second;

    first = (ngx_stream_conf_addr_t *) one;
    second = (ngx_stream_conf_addr_t *) two;

    if (first->opt.wildcard) {
        /* a wildcard must be the last resort, shift it to the end */
        return 1;
    }

    if (second->opt.wildcard) {
        /* a wildcard must be the last resort, shift it to the end */
        return -1;
    }

    if (first->opt.bind && !second->opt.bind) {
        /* shift explicit bind()ed addresses to the start */
        return -1;
    }

    if (!first->opt.bind && second->opt.bind) {
        /* shift explicit bind()ed addresses to the start */
        return 1;
    }

    /* do not sort by default */

    return 0;
}",1,1,stream\ngx_stream.c,ngx_stream_cmp_conf_addrs,,false,620,651,ngx_stream_cmp_conf_addrs,,,22,"ngx_int_t ngx_stream_cmp_conf_addrs (void*,void*)"
424296,METHOD,stream\ngx_stream.h:<global>,TYPE_DECL,<global>,1,36,stream\ngx_stream.h,stream\ngx_stream.h:<global>,,false,1,309,<global>,,,1,
424356,METHOD,<empty>,<empty>,<empty>,1,,stream\ngx_stream.h,ngx_stream_phases:<clinit>,,false,115,,<clinit>,,,8,
424366,METHOD,stream\ngx_stream.h:<global>,TYPE_DECL,"typedef ngx_int_t (*ngx_stream_phase_handler_pt)(ngx_stream_session_t *s,
    ngx_stream_phase_handler_t *ph);",19,35,stream\ngx_stream.h,ngx_stream_phase_handler_pt,,false,128,129,ngx_stream_phase_handler_pt,,,21,"ngx_int_t ngx_stream_phase_handler_pt (ngx_stream_session_t*,ngx_stream_phase_handler_t*)"
424372,METHOD,stream\ngx_stream.h:<global>,TYPE_DECL,typedef ngx_int_t (*ngx_stream_handler_pt)(ngx_stream_session_t *s);,19,67,stream\ngx_stream.h,ngx_stream_handler_pt,,false,130,130,ngx_stream_handler_pt,,,22,ngx_int_t ngx_stream_handler_pt (ngx_stream_session_t*)
424377,METHOD,stream\ngx_stream.h:<global>,TYPE_DECL,typedef void (*ngx_stream_content_handler_pt)(ngx_stream_session_t *s);,14,70,stream\ngx_stream.h,ngx_stream_content_handler_pt,,false,131,131,ngx_stream_content_handler_pt,,,23,void ngx_stream_content_handler_pt (ngx_stream_session_t*)
424404,METHOD,<empty>,<empty>,<empty>,1,,stream\ngx_stream.h,ngx_stream_core_main_conf_t:<clinit>,,false,151,,<clinit>,,,12,
424450,METHOD,ngx_stream_module_t,TYPE_DECL,ngx_int_t                    (*preconfiguration)(ngx_conf_t *cf);,34,68,stream\ngx_stream.h,ngx_stream_module_t.preconfiguration,,false,235,235,preconfiguration,,,1,ngx_int_t ngx_stream_module_t.preconfiguration (ngx_conf_t*)
424455,METHOD,ngx_stream_module_t,TYPE_DECL,ngx_int_t                    (*postconfiguration)(ngx_conf_t *cf);,34,69,stream\ngx_stream.h,ngx_stream_module_t.postconfiguration,,false,236,236,postconfiguration,,,2,ngx_int_t ngx_stream_module_t.postconfiguration (ngx_conf_t*)
424460,METHOD,ngx_stream_module_t,TYPE_DECL,void                        *(*create_main_conf)(ngx_conf_t *cf);,33,68,stream\ngx_stream.h,ngx_stream_module_t.create_main_conf,,false,238,238,create_main_conf,,,3,void* ngx_stream_module_t.create_main_conf (ngx_conf_t*)
424465,METHOD,ngx_stream_module_t,TYPE_DECL,"char                        *(*init_main_conf)(ngx_conf_t *cf, void *conf);",33,78,stream\ngx_stream.h,ngx_stream_module_t.init_main_conf,,false,239,239,init_main_conf,,,4,"char* ngx_stream_module_t.init_main_conf (ngx_conf_t*,void*)"
424471,METHOD,ngx_stream_module_t,TYPE_DECL,void                        *(*create_srv_conf)(ngx_conf_t *cf);,33,67,stream\ngx_stream.h,ngx_stream_module_t.create_srv_conf,,false,241,241,create_srv_conf,,,5,void* ngx_stream_module_t.create_srv_conf (ngx_conf_t*)
424476,METHOD,ngx_stream_module_t,TYPE_DECL,"char                        *(*merge_srv_conf)(ngx_conf_t *cf, void *prev,
                                                   void *conf);",33,62,stream\ngx_stream.h,ngx_stream_module_t.merge_srv_conf,,false,242,243,merge_srv_conf,,,6,"char* ngx_stream_module_t.merge_srv_conf (ngx_conf_t*,void*,void*)"
424484,METHOD,stream\ngx_stream.h:<global>,TYPE_DECL,void ngx_stream_core_run_phases(ngx_stream_session_t *s);,6,56,stream\ngx_stream.h,ngx_stream_core_run_phases,,false,283,283,ngx_stream_core_run_phases,,,36,void ngx_stream_core_run_phases (ngx_stream_session_t*)
424489,METHOD,stream\ngx_stream.h:<global>,TYPE_DECL,"ngx_int_t ngx_stream_core_generic_phase(ngx_stream_session_t *s,
    ngx_stream_phase_handler_t *ph);",11,35,stream\ngx_stream.h,ngx_stream_core_generic_phase,,false,284,285,ngx_stream_core_generic_phase,,,37,"ngx_int_t ngx_stream_core_generic_phase (ngx_stream_session_t*,ngx_stream_phase_handler_t*)"
424495,METHOD,stream\ngx_stream.h:<global>,TYPE_DECL,"ngx_int_t ngx_stream_core_preread_phase(ngx_stream_session_t *s,
    ngx_stream_phase_handler_t *ph);",11,35,stream\ngx_stream.h,ngx_stream_core_preread_phase,,false,286,287,ngx_stream_core_preread_phase,,,38,"ngx_int_t ngx_stream_core_preread_phase (ngx_stream_session_t*,ngx_stream_phase_handler_t*)"
424501,METHOD,stream\ngx_stream.h:<global>,TYPE_DECL,"ngx_int_t ngx_stream_core_content_phase(ngx_stream_session_t *s,
    ngx_stream_phase_handler_t *ph);",11,35,stream\ngx_stream.h,ngx_stream_core_content_phase,,false,288,289,ngx_stream_core_content_phase,,,39,"ngx_int_t ngx_stream_core_content_phase (ngx_stream_session_t*,ngx_stream_phase_handler_t*)"
424507,METHOD,stream\ngx_stream.h:<global>,TYPE_DECL,void ngx_stream_init_connection(ngx_connection_t *c);,6,52,stream\ngx_stream.h,ngx_stream_init_connection,,false,292,292,ngx_stream_init_connection,,,40,void ngx_stream_init_connection (ngx_connection_t*)
424512,METHOD,stream\ngx_stream.h:<global>,TYPE_DECL,void ngx_stream_session_handler(ngx_event_t *rev);,6,49,stream\ngx_stream.h,ngx_stream_session_handler,,false,293,293,ngx_stream_session_handler,,,41,void ngx_stream_session_handler (ngx_event_t*)
424517,METHOD,stream\ngx_stream.h:<global>,TYPE_DECL,"void ngx_stream_finalize_session(ngx_stream_session_t *s, ngx_uint_t rc);",6,72,stream\ngx_stream.h,ngx_stream_finalize_session,,false,294,294,ngx_stream_finalize_session,,,42,"void ngx_stream_finalize_session (ngx_stream_session_t*,ngx_uint_t)"
424526,METHOD,stream\ngx_stream.h:<global>,TYPE_DECL,"typedef ngx_int_t (*ngx_stream_filter_pt)(ngx_stream_session_t *s,
    ngx_chain_t *chain, ngx_uint_t from_upstream);",19,49,stream\ngx_stream.h,ngx_stream_filter_pt,,false,302,303,ngx_stream_filter_pt,,,46,"ngx_int_t ngx_stream_filter_pt (ngx_stream_session_t*,ngx_chain_t*,ngx_uint_t)"
424543,METHOD,stream\ngx_stream_access_module.c:<global>,TYPE_DECL,<global>,1,1,stream\ngx_stream_access_module.c,stream\ngx_stream_access_module.c:<global>,,false,1,453,<global>,,,1,
424555,METHOD,stream\ngx_stream_access_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_stream_access_handler(ngx_stream_session_t *s);,18,67,stream\ngx_stream_access_module.c,ngx_stream_access_handler,,false,48,48,ngx_stream_access_handler,,,5,ngx_int_t ngx_stream_access_handler (ngx_stream_session_t*)
424560,METHOD,stream\ngx_stream_access_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_access_inet(ngx_stream_session_t *s,
    ngx_stream_access_srv_conf_t *ascf, in_addr_t addr);",18,55,stream\ngx_stream_access_module.c,ngx_stream_access_inet,,false,49,50,ngx_stream_access_inet,,,6,"ngx_int_t ngx_stream_access_inet (ngx_stream_session_t*,ngx_stream_access_srv_conf_t*,in_addr_t)"
424567,METHOD,stream\ngx_stream_access_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_access_found(ngx_stream_session_t *s,
    ngx_uint_t deny);",18,20,stream\ngx_stream_access_module.c,ngx_stream_access_found,,false,59,60,ngx_stream_access_found,,,7,"ngx_int_t ngx_stream_access_found (ngx_stream_session_t*,ngx_uint_t)"
424573,METHOD,stream\ngx_stream_access_module.c:<global>,TYPE_DECL,"static char *ngx_stream_access_rule(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,stream\ngx_stream_access_module.c,ngx_stream_access_rule,,false,61,62,ngx_stream_access_rule,,,8,"char* ngx_stream_access_rule (ngx_conf_t*,ngx_command_t*,void*)"
424580,METHOD,stream\ngx_stream_access_module.c:<global>,TYPE_DECL,static void *ngx_stream_access_create_srv_conf(ngx_conf_t *cf);,13,62,stream\ngx_stream_access_module.c,ngx_stream_access_create_srv_conf,,false,63,63,ngx_stream_access_create_srv_conf,,,9,void* ngx_stream_access_create_srv_conf (ngx_conf_t*)
424585,METHOD,stream\ngx_stream_access_module.c:<global>,TYPE_DECL,"static char *ngx_stream_access_merge_srv_conf(ngx_conf_t *cf,
    void *parent, void *child);",13,30,stream\ngx_stream_access_module.c,ngx_stream_access_merge_srv_conf,,false,64,65,ngx_stream_access_merge_srv_conf,,,10,"char* ngx_stream_access_merge_srv_conf (ngx_conf_t*,void*,void*)"
424592,METHOD,stream\ngx_stream_access_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_stream_access_init(ngx_conf_t *cf);,18,55,stream\ngx_stream_access_module.c,ngx_stream_access_init,,false,66,66,ngx_stream_access_init,,,11,ngx_int_t ngx_stream_access_init (ngx_conf_t*)
424653,METHOD,stream\ngx_stream_access_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_access_handler(ngx_stream_session_t *s)
{
    struct sockaddr_in            *sin;
    ngx_stream_access_srv_conf_t  *ascf;
#if (NGX_HAVE_INET6)
    u_char                        *p;
    in_addr_t                      addr;
    struct sockaddr_in6           *sin6;
#endif

    ascf = ngx_stream_get_module_srv_conf(s, ngx_stream_access_module);

    switch (s->connection->sockaddr->sa_family) {

    case AF_INET:
        if (ascf->rules) {
            sin = (struct sockaddr_in *) s->connection->sockaddr;
            return ngx_stream_access_inet(s, ascf, sin->sin_addr.s_addr);
        }
        break;

#if (NGX_HAVE_INET6)

    case AF_INET6:
        sin6 = (struct sockaddr_in6 *) s->connection->sockaddr;
        p = sin6->sin6_addr.s6_addr;

        if (ascf->rules && IN6_IS_ADDR_V4MAPPED(&sin6->sin6_addr)) {
            addr = p[12] << 24;
            addr += p[13] << 16;
            addr += p[14] << 8;
            addr += p[15];
            return ngx_str...",1,1,stream\ngx_stream_access_module.c,ngx_stream_access_handler,,false,118,175,ngx_stream_access_handler,,,18,ngx_int_t ngx_stream_access_handler (ngx_stream_session_t*)
424702,METHOD,stream\ngx_stream_access_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_access_inet(ngx_stream_session_t *s,
    ngx_stream_access_srv_conf_t *ascf, in_addr_t addr)
{
    ngx_uint_t                 i;
    ngx_stream_access_rule_t  *rule;

    rule = ascf->rules->elts;
    for (i = 0; i < ascf->rules->nelts; i++) {

        ngx_log_debug3(NGX_LOG_DEBUG_STREAM, s->connection->log, 0,
                       ""access: %08XD %08XD %08XD"",
                       addr, rule[i].mask, rule[i].addr);

        if ((addr & rule[i].mask) == rule[i].addr) {
            return ngx_stream_access_found(s, rule[i].deny);
        }
    }

    return NGX_DECLINED;
}",1,1,stream\ngx_stream_access_module.c,ngx_stream_access_inet,,false,178,198,ngx_stream_access_inet,,,19,"ngx_int_t ngx_stream_access_inet (ngx_stream_session_t*,ngx_stream_access_srv_conf_t*,in_addr_t)"
424778,METHOD,stream\ngx_stream_access_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_access_found(ngx_stream_session_t *s, ngx_uint_t deny)
{
    if (deny) {
        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,
                      ""access forbidden by rule"");
        return NGX_STREAM_FORBIDDEN;
    }

    return NGX_OK;
}",1,1,stream\ngx_stream_access_module.c,ngx_stream_access_found,,false,272,282,ngx_stream_access_found,,,20,"ngx_int_t ngx_stream_access_found (ngx_stream_session_t*,ngx_uint_t)"
424800,METHOD,stream\ngx_stream_access_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_access_rule(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_stream_access_srv_conf_t *ascf = conf;

    ngx_int_t                     rc;
    ngx_uint_t                    all;
    ngx_str_t                    *value;
    ngx_cidr_t                    cidr;
    ngx_stream_access_rule_t     *rule;
#if (NGX_HAVE_INET6)
    ngx_stream_access_rule6_t    *rule6;
#endif
#if (NGX_HAVE_UNIX_DOMAIN)
    ngx_stream_access_rule_un_t  *rule_un;
#endif

    all = 0;
    ngx_memzero(&cidr, sizeof(ngx_cidr_t));

    value = cf->args->elts;

    if (value[1].len == 3 && ngx_strcmp(value[1].data, ""all"") == 0) {
        all = 1;

#if (NGX_HAVE_UNIX_DOMAIN)
    } else if (value[1].len == 5 && ngx_strcmp(value[1].data, ""unix:"") == 0) {
        cidr.family = AF_UNIX;
#endif

    } else {
        rc = ngx_ptocidr(&value[1], &cidr);

        if (rc == NGX_ERROR) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                         ""invalid parameter \""%V\"""", &v...",1,1,stream\ngx_stream_access_module.c,ngx_stream_access_rule,,false,285,393,ngx_stream_access_rule,,,21,"char* ngx_stream_access_rule (ngx_conf_t*,ngx_command_t*,void*)"
424983,METHOD,stream\ngx_stream_access_module.c:<global>,TYPE_DECL,"static void *
ngx_stream_access_create_srv_conf(ngx_conf_t *cf)
{
    ngx_stream_access_srv_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_stream_access_srv_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    return conf;
}",1,1,stream\ngx_stream_access_module.c,ngx_stream_access_create_srv_conf,,false,396,407,ngx_stream_access_create_srv_conf,,,22,void* ngx_stream_access_create_srv_conf (ngx_conf_t*)
425006,METHOD,stream\ngx_stream_access_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_access_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_stream_access_srv_conf_t  *prev = parent;
    ngx_stream_access_srv_conf_t  *conf = child;

    if (conf->rules == NULL
#if (NGX_HAVE_INET6)
        && conf->rules6 == NULL
#endif
#if (NGX_HAVE_UNIX_DOMAIN)
        && conf->rules_un == NULL
#endif
    ) {
        conf->rules = prev->rules;
#if (NGX_HAVE_INET6)
        conf->rules6 = prev->rules6;
#endif
#if (NGX_HAVE_UNIX_DOMAIN)
        conf->rules_un = prev->rules_un;
#endif
    }

    return NGX_CONF_OK;
}",1,1,stream\ngx_stream_access_module.c,ngx_stream_access_merge_srv_conf,,false,410,434,ngx_stream_access_merge_srv_conf,,,23,"char* ngx_stream_access_merge_srv_conf (ngx_conf_t*,void*,void*)"
425037,METHOD,stream\ngx_stream_access_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_access_init(ngx_conf_t *cf)
{
    ngx_stream_handler_pt        *h;
    ngx_stream_core_main_conf_t  *cmcf;

    cmcf = ngx_stream_conf_get_module_main_conf(cf, ngx_stream_core_module);

    h = ngx_array_push(&cmcf->phases[NGX_STREAM_ACCESS_PHASE].handlers);
    if (h == NULL) {
        return NGX_ERROR;
    }

    *h = ngx_stream_access_handler;

    return NGX_OK;
}",1,1,stream\ngx_stream_access_module.c,ngx_stream_access_init,,false,437,453,ngx_stream_access_init,,,24,ngx_int_t ngx_stream_access_init (ngx_conf_t*)
425082,METHOD,stream\ngx_stream_core_module.c:<global>,TYPE_DECL,<global>,1,1,stream\ngx_stream_core_module.c,stream\ngx_stream_core_module.c:<global>,,false,1,916,<global>,,,1,
425084,METHOD,stream\ngx_stream_core_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_stream_core_preconfiguration(ngx_conf_t *cf);,18,65,stream\ngx_stream_core_module.c,ngx_stream_core_preconfiguration,,false,13,13,ngx_stream_core_preconfiguration,,,1,ngx_int_t ngx_stream_core_preconfiguration (ngx_conf_t*)
425089,METHOD,stream\ngx_stream_core_module.c:<global>,TYPE_DECL,static void *ngx_stream_core_create_main_conf(ngx_conf_t *cf);,13,61,stream\ngx_stream_core_module.c,ngx_stream_core_create_main_conf,,false,14,14,ngx_stream_core_create_main_conf,,,2,void* ngx_stream_core_create_main_conf (ngx_conf_t*)
425094,METHOD,stream\ngx_stream_core_module.c:<global>,TYPE_DECL,"static char *ngx_stream_core_init_main_conf(ngx_conf_t *cf, void *conf);",13,71,stream\ngx_stream_core_module.c,ngx_stream_core_init_main_conf,,false,15,15,ngx_stream_core_init_main_conf,,,3,"char* ngx_stream_core_init_main_conf (ngx_conf_t*,void*)"
425100,METHOD,stream\ngx_stream_core_module.c:<global>,TYPE_DECL,static void *ngx_stream_core_create_srv_conf(ngx_conf_t *cf);,13,60,stream\ngx_stream_core_module.c,ngx_stream_core_create_srv_conf,,false,16,16,ngx_stream_core_create_srv_conf,,,4,void* ngx_stream_core_create_srv_conf (ngx_conf_t*)
425105,METHOD,stream\ngx_stream_core_module.c:<global>,TYPE_DECL,"static char *ngx_stream_core_merge_srv_conf(ngx_conf_t *cf, void *parent,
    void *child);",13,16,stream\ngx_stream_core_module.c,ngx_stream_core_merge_srv_conf,,false,17,18,ngx_stream_core_merge_srv_conf,,,5,"char* ngx_stream_core_merge_srv_conf (ngx_conf_t*,void*,void*)"
425112,METHOD,stream\ngx_stream_core_module.c:<global>,TYPE_DECL,"static char *ngx_stream_core_error_log(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,stream\ngx_stream_core_module.c,ngx_stream_core_error_log,,false,19,20,ngx_stream_core_error_log,,,6,"char* ngx_stream_core_error_log (ngx_conf_t*,ngx_command_t*,void*)"
425119,METHOD,stream\ngx_stream_core_module.c:<global>,TYPE_DECL,"static char *ngx_stream_core_server(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,stream\ngx_stream_core_module.c,ngx_stream_core_server,,false,21,22,ngx_stream_core_server,,,7,"char* ngx_stream_core_server (ngx_conf_t*,ngx_command_t*,void*)"
425126,METHOD,stream\ngx_stream_core_module.c:<global>,TYPE_DECL,"static char *ngx_stream_core_listen(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,stream\ngx_stream_core_module.c,ngx_stream_core_listen,,false,23,24,ngx_stream_core_listen,,,8,"char* ngx_stream_core_listen (ngx_conf_t*,ngx_command_t*,void*)"
425133,METHOD,stream\ngx_stream_core_module.c:<global>,TYPE_DECL,"static char *ngx_stream_core_resolver(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,stream\ngx_stream_core_module.c,ngx_stream_core_resolver,,false,25,26,ngx_stream_core_resolver,,,9,"char* ngx_stream_core_resolver (ngx_conf_t*,ngx_command_t*,void*)"
425312,METHOD,stream\ngx_stream_core_module.c:<global>,TYPE_DECL,"void
ngx_stream_core_run_phases(ngx_stream_session_t *s)
{
    ngx_int_t                     rc;
    ngx_stream_phase_handler_t   *ph;
    ngx_stream_core_main_conf_t  *cmcf;

    cmcf = ngx_stream_get_module_main_conf(s, ngx_stream_core_module);

    ph = cmcf->phase_engine.handlers;

    while (ph[s->phase_handler].checker) {

        rc = ph[s->phase_handler].checker(s, &ph[s->phase_handler]);

        if (rc == NGX_OK) {
            return;
        }
    }
}",1,1,stream\ngx_stream_core_module.c,ngx_stream_core_run_phases,,false,140,159,ngx_stream_core_run_phases,,,16,void ngx_stream_core_run_phases (ngx_stream_session_t*)
425364,METHOD,stream\ngx_stream_core_module.c:<global>,TYPE_DECL,"ngx_int_t
ngx_stream_core_generic_phase(ngx_stream_session_t *s,
    ngx_stream_phase_handler_t *ph)
{
    ngx_int_t  rc;

    /*
     * generic phase checker,
     * used by all phases, except for preread and content
     */

    ngx_log_debug1(NGX_LOG_DEBUG_STREAM, s->connection->log, 0,
                   ""generic phase: %ui"", s->phase_handler);

    rc = ph->handler(s);

    if (rc == NGX_OK) {
        s->phase_handler = ph->next;
        return NGX_AGAIN;
    }

    if (rc == NGX_DECLINED) {
        s->phase_handler++;
        return NGX_AGAIN;
    }

    if (rc == NGX_AGAIN || rc == NGX_DONE) {
        return NGX_OK;
    }

    if (rc == NGX_ERROR) {
        rc = NGX_STREAM_INTERNAL_SERVER_ERROR;
    }

    ngx_stream_finalize_session(s, rc);

    return NGX_OK;
}",1,1,stream\ngx_stream_core_module.c,ngx_stream_core_generic_phase,,false,162,199,ngx_stream_core_generic_phase,,,17,"ngx_int_t ngx_stream_core_generic_phase (ngx_stream_session_t*,ngx_stream_phase_handler_t*)"
425439,METHOD,stream\ngx_stream_core_module.c:<global>,TYPE_DECL,"ngx_int_t
ngx_stream_core_preread_phase(ngx_stream_session_t *s,
    ngx_stream_phase_handler_t *ph)
{
    size_t                       size;
    ssize_t                      n;
    ngx_int_t                    rc;
    ngx_connection_t            *c;
    ngx_stream_core_srv_conf_t  *cscf;

    c = s->connection;

    c->log->action = ""prereading client data"";

    cscf = ngx_stream_get_module_srv_conf(s, ngx_stream_core_module);

    if (c->read->timedout) {
        rc = NGX_STREAM_OK;

    } else if (c->read->timer_set) {
        rc = NGX_AGAIN;

    } else {
        rc = ph->handler(s);
    }

    while (rc == NGX_AGAIN) {

        if (c->buffer == NULL) {
            c->buffer = ngx_create_temp_buf(c->pool, cscf->preread_buffer_size);
            if (c->buffer == NULL) {
                rc = NGX_ERROR;
                break;
            }
        }

        size = c->buffer->end - c->buffer->last;

        if (size == 0) {
            ngx_log_error(NGX_LOG_ERR, c->log, 0, ""prerea...",1,1,stream\ngx_stream_core_module.c,ngx_stream_core_preread_phase,,false,202,311,ngx_stream_core_preread_phase,,,18,"ngx_int_t ngx_stream_core_preread_phase (ngx_stream_session_t*,ngx_stream_phase_handler_t*)"
425726,METHOD,stream\ngx_stream_core_module.c:<global>,TYPE_DECL,"ngx_int_t
ngx_stream_core_content_phase(ngx_stream_session_t *s,
    ngx_stream_phase_handler_t *ph)
{
    ngx_connection_t            *c;
    ngx_stream_core_srv_conf_t  *cscf;

    c = s->connection;

    c->log->action = NULL;

    cscf = ngx_stream_get_module_srv_conf(s, ngx_stream_core_module);

    if (c->type == SOCK_STREAM
        && cscf->tcp_nodelay
        && ngx_tcp_nodelay(c) != NGX_OK)
    {
        ngx_stream_finalize_session(s, NGX_STREAM_INTERNAL_SERVER_ERROR);
        return NGX_OK;
    }

    cscf->handler(s);

    return NGX_OK;
}",1,1,stream\ngx_stream_core_module.c,ngx_stream_core_content_phase,,false,314,338,ngx_stream_core_content_phase,,,19,"ngx_int_t ngx_stream_core_content_phase (ngx_stream_session_t*,ngx_stream_phase_handler_t*)"
425779,METHOD,stream\ngx_stream_core_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_core_preconfiguration(ngx_conf_t *cf)
{
    return ngx_stream_variables_add_core_vars(cf);
}",1,1,stream\ngx_stream_core_module.c,ngx_stream_core_preconfiguration,,false,341,345,ngx_stream_core_preconfiguration,,,20,ngx_int_t ngx_stream_core_preconfiguration (ngx_conf_t*)
425787,METHOD,stream\ngx_stream_core_module.c:<global>,TYPE_DECL,"static void *
ngx_stream_core_create_main_conf(ngx_conf_t *cf)
{
    ngx_stream_core_main_conf_t  *cmcf;

    cmcf = ngx_pcalloc(cf->pool, sizeof(ngx_stream_core_main_conf_t));
    if (cmcf == NULL) {
        return NULL;
    }

    if (ngx_array_init(&cmcf->servers, cf->pool, 4,
                       sizeof(ngx_stream_core_srv_conf_t *))
        != NGX_OK)
    {
        return NULL;
    }

    if (ngx_array_init(&cmcf->listen, cf->pool, 4, sizeof(ngx_stream_listen_t))
        != NGX_OK)
    {
        return NULL;
    }

    cmcf->variables_hash_max_size = NGX_CONF_UNSET_UINT;
    cmcf->variables_hash_bucket_size = NGX_CONF_UNSET_UINT;

    return cmcf;
}",1,1,stream\ngx_stream_core_module.c,ngx_stream_core_create_main_conf,,false,348,375,ngx_stream_core_create_main_conf,,,21,void* ngx_stream_core_create_main_conf (ngx_conf_t*)
425854,METHOD,stream\ngx_stream_core_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_core_init_main_conf(ngx_conf_t *cf, void *conf)
{
    ngx_stream_core_main_conf_t *cmcf = conf;

    ngx_conf_init_uint_value(cmcf->variables_hash_max_size, 1024);
    ngx_conf_init_uint_value(cmcf->variables_hash_bucket_size, 64);

    cmcf->variables_hash_bucket_size =
               ngx_align(cmcf->variables_hash_bucket_size, ngx_cacheline_size);

    if (cmcf->ncaptures) {
        cmcf->ncaptures = (cmcf->ncaptures + 1) * 3;
    }

    return NGX_CONF_OK;
}",1,1,stream\ngx_stream_core_module.c,ngx_stream_core_init_main_conf,,false,378,394,ngx_stream_core_init_main_conf,,,22,"char* ngx_stream_core_init_main_conf (ngx_conf_t*,void*)"
425901,METHOD,stream\ngx_stream_core_module.c:<global>,TYPE_DECL,"static void *
ngx_stream_core_create_srv_conf(ngx_conf_t *cf)
{
    ngx_stream_core_srv_conf_t  *cscf;

    cscf = ngx_pcalloc(cf->pool, sizeof(ngx_stream_core_srv_conf_t));
    if (cscf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     cscf->handler = NULL;
     *     cscf->error_log = NULL;
     */

    cscf->file_name = cf->conf_file->file.name.data;
    cscf->line = cf->conf_file->line;
    cscf->resolver_timeout = NGX_CONF_UNSET_MSEC;
    cscf->proxy_protocol_timeout = NGX_CONF_UNSET_MSEC;
    cscf->tcp_nodelay = NGX_CONF_UNSET;
    cscf->preread_buffer_size = NGX_CONF_UNSET_SIZE;
    cscf->preread_timeout = NGX_CONF_UNSET_MSEC;

    return cscf;
}",1,1,stream\ngx_stream_core_module.c,ngx_stream_core_create_srv_conf,,false,397,423,ngx_stream_core_create_srv_conf,,,23,void* ngx_stream_core_create_srv_conf (ngx_conf_t*)
425971,METHOD,stream\ngx_stream_core_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_core_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_stream_core_srv_conf_t *prev = parent;
    ngx_stream_core_srv_conf_t *conf = child;

    ngx_conf_merge_msec_value(conf->resolver_timeout,
                              prev->resolver_timeout, 30000);

    if (conf->resolver == NULL) {

        if (prev->resolver == NULL) {

            /*
             * create dummy resolver in stream {} context
             * to inherit it in all servers
             */

            prev->resolver = ngx_resolver_create(cf, NULL, 0);
            if (prev->resolver == NULL) {
                return NGX_CONF_ERROR;
            }
        }

        conf->resolver = prev->resolver;
    }

    if (conf->handler == NULL) {
        ngx_log_error(NGX_LOG_EMERG, cf->log, 0,
                      ""no handler for server in %s:%ui"",
                      conf->file_name, conf->line);
        return NGX_CONF_ERROR;
    }

    if (conf->error_log == NULL) {
       ...",1,1,stream\ngx_stream_core_module.c,ngx_stream_core_merge_srv_conf,,false,426,480,ngx_stream_core_merge_srv_conf,,,24,"char* ngx_stream_core_merge_srv_conf (ngx_conf_t*,void*,void*)"
426119,METHOD,stream\ngx_stream_core_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_core_error_log(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_stream_core_srv_conf_t  *cscf = conf;

    return ngx_log_set_log(cf, &cscf->error_log);
}",1,1,stream\ngx_stream_core_module.c,ngx_stream_core_error_log,,false,483,489,ngx_stream_core_error_log,,,25,"char* ngx_stream_core_error_log (ngx_conf_t*,ngx_command_t*,void*)"
426137,METHOD,stream\ngx_stream_core_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_core_server(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char                         *rv;
    void                         *mconf;
    ngx_uint_t                    m;
    ngx_conf_t                    pcf;
    ngx_stream_module_t          *module;
    ngx_stream_conf_ctx_t        *ctx, *stream_ctx;
    ngx_stream_core_srv_conf_t   *cscf, **cscfp;
    ngx_stream_core_main_conf_t  *cmcf;

    ctx = ngx_pcalloc(cf->pool, sizeof(ngx_stream_conf_ctx_t));
    if (ctx == NULL) {
        return NGX_CONF_ERROR;
    }

    stream_ctx = cf->ctx;
    ctx->main_conf = stream_ctx->main_conf;

    /* the server{}'s srv_conf */

    ctx->srv_conf = ngx_pcalloc(cf->pool,
                                sizeof(void *) * ngx_stream_max_module);
    if (ctx->srv_conf == NULL) {
        return NGX_CONF_ERROR;
    }

    for (m = 0; cf->cycle->modules[m]; m++) {
        if (cf->cycle->modules[m]->type != NGX_STREAM_MODULE) {
            continue;
        }

        mod...",1,1,stream\ngx_stream_core_module.c,ngx_stream_core_server,,false,492,570,ngx_stream_core_server,,,26,"char* ngx_stream_core_server (ngx_conf_t*,ngx_command_t*,void*)"
426367,METHOD,stream\ngx_stream_core_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_stream_core_srv_conf_t  *cscf = conf;

    ngx_str_t                    *value, size;
    ngx_url_t                     u;
    ngx_uint_t                    i, n, backlog;
    ngx_stream_listen_t          *ls, *als;
    ngx_stream_core_main_conf_t  *cmcf;

    cscf->listen = 1;

    value = cf->args->elts;

    ngx_memzero(&u, sizeof(ngx_url_t));

    u.url = value[1];
    u.listen = 1;

    if (ngx_parse_url(cf->pool, &u) != NGX_OK) {
        if (u.err) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               ""%s in \""%V\"" of the \""listen\"" directive"",
                               u.err, &u.url);
        }

        return NGX_CONF_ERROR;
    }

    cmcf = ngx_stream_conf_get_module_main_conf(cf, ngx_stream_core_module);

    ls = ngx_array_push_n(&cmcf->listen, u.naddrs);
    if (ls == NULL) {
        return NGX_CONF_ERROR;
    }

    ngx_memzero(ls, sizeof(...",1,1,stream\ngx_stream_core_module.c,ngx_stream_core_listen,,false,573,894,ngx_stream_core_listen,,,27,"char* ngx_stream_core_listen (ngx_conf_t*,ngx_command_t*,void*)"
427076,METHOD,stream\ngx_stream_core_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_core_resolver(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_stream_core_srv_conf_t  *cscf = conf;

    ngx_str_t  *value;

    if (cscf->resolver) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    cscf->resolver = ngx_resolver_create(cf, &value[1], cf->args->nelts - 1);
    if (cscf->resolver == NULL) {
        return NGX_CONF_ERROR;
    }

    return NGX_CONF_OK;
}",1,1,stream\ngx_stream_core_module.c,ngx_stream_core_resolver,,false,897,916,ngx_stream_core_resolver,,,28,"char* ngx_stream_core_resolver (ngx_conf_t*,ngx_command_t*,void*)"
427139,METHOD,stream\ngx_stream_geo_module.c:<global>,TYPE_DECL,<global>,1,1,stream\ngx_stream_geo_module.c,stream\ngx_stream_geo_module.c:<global>,,false,1,1609,<global>,,,1,
427185,METHOD,stream\ngx_stream_geo_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_geo_addr(ngx_stream_session_t *s,
    ngx_stream_geo_ctx_t *ctx, ngx_addr_t *addr);",18,48,stream\ngx_stream_geo_module.c,ngx_stream_geo_addr,,false,77,78,ngx_stream_geo_addr,,,13,"ngx_int_t ngx_stream_geo_addr (ngx_stream_session_t*,ngx_stream_geo_ctx_t*,ngx_addr_t*)"
427192,METHOD,stream\ngx_stream_geo_module.c:<global>,TYPE_DECL,"static char *ngx_stream_geo_block(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,stream\ngx_stream_geo_module.c,ngx_stream_geo_block,,false,80,81,ngx_stream_geo_block,,,14,"char* ngx_stream_geo_block (ngx_conf_t*,ngx_command_t*,void*)"
427199,METHOD,stream\ngx_stream_geo_module.c:<global>,TYPE_DECL,"static char *ngx_stream_geo(ngx_conf_t *cf, ngx_command_t *dummy, void *conf);",13,77,stream\ngx_stream_geo_module.c,ngx_stream_geo,,false,82,82,ngx_stream_geo,,,15,"char* ngx_stream_geo (ngx_conf_t*,ngx_command_t*,void*)"
427206,METHOD,stream\ngx_stream_geo_module.c:<global>,TYPE_DECL,"static char *ngx_stream_geo_range(ngx_conf_t *cf,
    ngx_stream_geo_conf_ctx_t *ctx, ngx_str_t *value);",13,53,stream\ngx_stream_geo_module.c,ngx_stream_geo_range,,false,83,84,ngx_stream_geo_range,,,16,"char* ngx_stream_geo_range (ngx_conf_t*,ngx_stream_geo_conf_ctx_t*,ngx_str_t*)"
427213,METHOD,stream\ngx_stream_geo_module.c:<global>,TYPE_DECL,"static char *ngx_stream_geo_add_range(ngx_conf_t *cf,
    ngx_stream_geo_conf_ctx_t *ctx, in_addr_t start, in_addr_t end);",13,67,stream\ngx_stream_geo_module.c,ngx_stream_geo_add_range,,false,85,86,ngx_stream_geo_add_range,,,17,"char* ngx_stream_geo_add_range (ngx_conf_t*,ngx_stream_geo_conf_ctx_t*,in_addr_t,in_addr_t)"
427221,METHOD,stream\ngx_stream_geo_module.c:<global>,TYPE_DECL,"static ngx_uint_t ngx_stream_geo_delete_range(ngx_conf_t *cf,
    ngx_stream_geo_conf_ctx_t *ctx, in_addr_t start, in_addr_t end);",19,67,stream\ngx_stream_geo_module.c,ngx_stream_geo_delete_range,,false,87,88,ngx_stream_geo_delete_range,,,18,"ngx_uint_t ngx_stream_geo_delete_range (ngx_conf_t*,ngx_stream_geo_conf_ctx_t*,in_addr_t,in_addr_t)"
427229,METHOD,stream\ngx_stream_geo_module.c:<global>,TYPE_DECL,"static char *ngx_stream_geo_cidr(ngx_conf_t *cf,
    ngx_stream_geo_conf_ctx_t *ctx, ngx_str_t *value);",13,53,stream\ngx_stream_geo_module.c,ngx_stream_geo_cidr,,false,89,90,ngx_stream_geo_cidr,,,19,"char* ngx_stream_geo_cidr (ngx_conf_t*,ngx_stream_geo_conf_ctx_t*,ngx_str_t*)"
427236,METHOD,stream\ngx_stream_geo_module.c:<global>,TYPE_DECL,"static char *ngx_stream_geo_cidr_add(ngx_conf_t *cf,
    ngx_stream_geo_conf_ctx_t *ctx, ngx_cidr_t *cidr, ngx_str_t *value,
    ngx_str_t *net);",13,19,stream\ngx_stream_geo_module.c,ngx_stream_geo_cidr_add,,false,91,93,ngx_stream_geo_cidr_add,,,20,"char* ngx_stream_geo_cidr_add (ngx_conf_t*,ngx_stream_geo_conf_ctx_t*,ngx_cidr_t*,ngx_str_t*,ngx_str_t*)"
427245,METHOD,stream\ngx_stream_geo_module.c:<global>,TYPE_DECL,"static ngx_stream_variable_value_t *ngx_stream_geo_value(ngx_conf_t *cf,
    ngx_stream_geo_conf_ctx_t *ctx, ngx_str_t *value);",36,53,stream\ngx_stream_geo_module.c,ngx_stream_geo_value,,false,94,95,ngx_stream_geo_value,,,21,"ngx_stream_variable_value_t* ngx_stream_geo_value (ngx_conf_t*,ngx_stream_geo_conf_ctx_t*,ngx_str_t*)"
427252,METHOD,stream\ngx_stream_geo_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_geo_cidr_value(ngx_conf_t *cf, ngx_str_t *net,
    ngx_cidr_t *cidr);",18,21,stream\ngx_stream_geo_module.c,ngx_stream_geo_cidr_value,,false,96,97,ngx_stream_geo_cidr_value,,,22,"ngx_int_t ngx_stream_geo_cidr_value (ngx_conf_t*,ngx_str_t*,ngx_cidr_t*)"
427259,METHOD,stream\ngx_stream_geo_module.c:<global>,TYPE_DECL,"static char *ngx_stream_geo_include(ngx_conf_t *cf,
    ngx_stream_geo_conf_ctx_t *ctx, ngx_str_t *name);",13,52,stream\ngx_stream_geo_module.c,ngx_stream_geo_include,,false,98,99,ngx_stream_geo_include,,,23,"char* ngx_stream_geo_include (ngx_conf_t*,ngx_stream_geo_conf_ctx_t*,ngx_str_t*)"
427266,METHOD,stream\ngx_stream_geo_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_geo_include_binary_base(ngx_conf_t *cf,
    ngx_stream_geo_conf_ctx_t *ctx, ngx_str_t *name);",18,52,stream\ngx_stream_geo_module.c,ngx_stream_geo_include_binary_base,,false,100,101,ngx_stream_geo_include_binary_base,,,24,"ngx_int_t ngx_stream_geo_include_binary_base (ngx_conf_t*,ngx_stream_geo_conf_ctx_t*,ngx_str_t*)"
427273,METHOD,stream\ngx_stream_geo_module.c:<global>,TYPE_DECL,static void ngx_stream_geo_create_binary_base(ngx_stream_geo_conf_ctx_t *ctx);,13,77,stream\ngx_stream_geo_module.c,ngx_stream_geo_create_binary_base,,false,102,102,ngx_stream_geo_create_binary_base,,,25,void ngx_stream_geo_create_binary_base (ngx_stream_geo_conf_ctx_t*)
427278,METHOD,stream\ngx_stream_geo_module.c:<global>,TYPE_DECL,"static u_char *ngx_stream_geo_copy_values(u_char *base, u_char *p,
    ngx_rbtree_node_t *node, ngx_rbtree_node_t *sentinel);",15,57,stream\ngx_stream_geo_module.c,ngx_stream_geo_copy_values,,false,103,104,ngx_stream_geo_copy_values,,,26,"u_char* ngx_stream_geo_copy_values (u_char*,u_char*,ngx_rbtree_node_t*,ngx_rbtree_node_t*)"
427336,METHOD,<empty>,<empty>,<empty>,1,,stream\ngx_stream_geo_module.c,ngx_stream_geo_header_t:<clinit>,,false,148,,<clinit>,,,6,
427359,METHOD,stream\ngx_stream_geo_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_geo_cidr_variable(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data)
{
    ngx_stream_geo_ctx_t *ctx = (ngx_stream_geo_ctx_t *) data;

    in_addr_t                     inaddr;
    ngx_addr_t                    addr;
    struct sockaddr_in           *sin;
    ngx_stream_variable_value_t  *vv;
#if (NGX_HAVE_INET6)
    u_char                       *p;
    struct in6_addr              *inaddr6;
#endif

    if (ngx_stream_geo_addr(s, ctx, &addr) != NGX_OK) {
        vv = (ngx_stream_variable_value_t *)
                  ngx_radix32tree_find(ctx->u.trees.tree, INADDR_NONE);
        goto done;
    }

    switch (addr.sockaddr->sa_family) {

#if (NGX_HAVE_INET6)
    case AF_INET6:
        inaddr6 = &((struct sockaddr_in6 *) addr.sockaddr)->sin6_addr;
        p = inaddr6->s6_addr;

        if (IN6_IS_ADDR_V4MAPPED(inaddr6)) {
            inaddr = p[12] << 24;
            inaddr += p[13] << 16;
            inaddr += p[14] << 8;
          ...",1,1,stream\ngx_stream_geo_module.c,ngx_stream_geo_cidr_variable,,false,164,234,ngx_stream_geo_cidr_variable,,,37,"ngx_int_t ngx_stream_geo_cidr_variable (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
427454,METHOD,stream\ngx_stream_geo_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_geo_range_variable(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data)
{
    ngx_stream_geo_ctx_t *ctx = (ngx_stream_geo_ctx_t *) data;

    in_addr_t                inaddr;
    ngx_addr_t               addr;
    ngx_uint_t               n;
    struct sockaddr_in      *sin;
    ngx_stream_geo_range_t  *range;
#if (NGX_HAVE_INET6)
    u_char                  *p;
    struct in6_addr         *inaddr6;
#endif

    *v = *ctx->u.high.default_value;

    if (ngx_stream_geo_addr(s, ctx, &addr) == NGX_OK) {

        switch (addr.sockaddr->sa_family) {

#if (NGX_HAVE_INET6)
        case AF_INET6:
            inaddr6 = &((struct sockaddr_in6 *) addr.sockaddr)->sin6_addr;

            if (IN6_IS_ADDR_V4MAPPED(inaddr6)) {
                p = inaddr6->s6_addr;

                inaddr = p[12] << 24;
                inaddr += p[13] << 16;
                inaddr += p[14] << 8;
                inaddr += p[15];

            } else {
                ...",1,1,stream\ngx_stream_geo_module.c,ngx_stream_geo_range_variable,,false,237,314,ngx_stream_geo_range_variable,,,38,"ngx_int_t ngx_stream_geo_range_variable (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
427594,METHOD,stream\ngx_stream_geo_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_geo_addr(ngx_stream_session_t *s, ngx_stream_geo_ctx_t *ctx,
    ngx_addr_t *addr)
{
    ngx_stream_variable_value_t  *v;

    if (ctx->index == -1) {
        ngx_log_debug1(NGX_LOG_DEBUG_STREAM, s->connection->log, 0,
                       ""stream geo started: %V"", &s->connection->addr_text);

        addr->sockaddr = s->connection->sockaddr;
        addr->socklen = s->connection->socklen;
        /* addr->name = s->connection->addr_text; */

        return NGX_OK;
    }

    v = ngx_stream_get_flushed_variable(s, ctx->index);

    if (v == NULL || v->not_found) {
        ngx_log_debug0(NGX_LOG_DEBUG_STREAM, s->connection->log, 0,
                       ""stream geo not found"");

        return NGX_ERROR;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_STREAM, s->connection->log, 0,
                   ""stream geo started: %v"", v);

    if (ngx_parse_addr(s->connection->pool, addr, v->data, v->len) == NGX_OK) {
        return NGX_OK;
    }

    return NGX_ERROR;
}",1,1,stream\ngx_stream_geo_module.c,ngx_stream_geo_addr,,false,317,351,ngx_stream_geo_addr,,,39,"ngx_int_t ngx_stream_geo_addr (ngx_stream_session_t*,ngx_stream_geo_ctx_t*,ngx_addr_t*)"
427703,METHOD,stream\ngx_stream_geo_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_geo_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char                       *rv;
    size_t                      len;
    ngx_str_t                  *value, name;
    ngx_uint_t                  i;
    ngx_conf_t                  save;
    ngx_pool_t                 *pool;
    ngx_array_t                *a;
    ngx_stream_variable_t      *var;
    ngx_stream_geo_ctx_t       *geo;
    ngx_stream_geo_conf_ctx_t   ctx;
#if (NGX_HAVE_INET6)
    static struct in6_addr      zero;
#endif

    value = cf->args->elts;

    geo = ngx_palloc(cf->pool, sizeof(ngx_stream_geo_ctx_t));
    if (geo == NULL) {
        return NGX_CONF_ERROR;
    }

    name = value[1];

    if (name.data[0] != '$') {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""invalid variable name \""%V\"""", &name);
        return NGX_CONF_ERROR;
    }

    name.len--;
    name.data++;

    if (cf->args->nelts == 3) {

        geo->index = ngx_stream_get_variable...",1,1,stream\ngx_stream_geo_module.c,ngx_stream_geo_block,,false,354,550,ngx_stream_geo_block,,,40,"char* ngx_stream_geo_block (ngx_conf_t*,ngx_command_t*,void*)"
428245,METHOD,stream\ngx_stream_geo_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_geo(ngx_conf_t *cf, ngx_command_t *dummy, void *conf)
{
    char                       *rv;
    ngx_str_t                  *value;
    ngx_stream_geo_conf_ctx_t  *ctx;

    ctx = cf->ctx;

    value = cf->args->elts;

    if (cf->args->nelts == 1) {

        if (ngx_strcmp(value[0].data, ""ranges"") == 0) {

            if (ctx->tree
#if (NGX_HAVE_INET6)
                || ctx->tree6
#endif
               )
            {
                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                                   ""the \""ranges\"" directive must be ""
                                   ""the first directive inside \""geo\"" block"");
                goto failed;
            }

            ctx->ranges = 1;

            rv = NGX_CONF_OK;

            goto done;
        }
    }

    if (cf->args->nelts != 2) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""invalid number of the geo parameters"");
        goto failed;
    }

    if (ngx_strcmp(...",1,1,stream\ngx_stream_geo_module.c,ngx_stream_geo,,false,553,619,ngx_stream_geo,,,41,"char* ngx_stream_geo (ngx_conf_t*,ngx_command_t*,void*)"
428376,METHOD,stream\ngx_stream_geo_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_geo_range(ngx_conf_t *cf, ngx_stream_geo_conf_ctx_t *ctx,
    ngx_str_t *value)
{
    u_char      *p, *last;
    in_addr_t    start, end;
    ngx_str_t   *net;
    ngx_uint_t   del;

    if (ngx_strcmp(value[0].data, ""default"") == 0) {

        if (ctx->high.default_value) {
            ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
                ""duplicate default geo range value: \""%V\"", old value: \""%v\"""",
                &value[1], ctx->high.default_value);
        }

        ctx->high.default_value = ngx_stream_geo_value(cf, ctx, &value[1]);
        if (ctx->high.default_value == NULL) {
            return NGX_CONF_ERROR;
        }

        return NGX_CONF_OK;
    }

    if (ctx->binary_include) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
            ""binary geo range base \""%s\"" cannot be mixed with usual entries"",
            ctx->include_name.data);
        return NGX_CONF_ERROR;
    }

    if (ctx->high.low == NULL) {
        ctx->high.low = ngx_p...",1,1,stream\ngx_stream_geo_module.c,ngx_stream_geo_range,,false,622,728,ngx_stream_geo_range,,,42,"char* ngx_stream_geo_range (ngx_conf_t*,ngx_stream_geo_conf_ctx_t*,ngx_str_t*)"
428665,METHOD,stream\ngx_stream_geo_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_geo_add_range(ngx_conf_t *cf, ngx_stream_geo_conf_ctx_t *ctx,
    in_addr_t start, in_addr_t end)
{
    in_addr_t                n;
    ngx_uint_t               h, i, s, e;
    ngx_array_t             *a;
    ngx_stream_geo_range_t  *range;

    for (n = start; n <= end; n = (n + 0x10000) & 0xffff0000) {

        h = n >> 16;

        if (n == start) {
            s = n & 0xffff;
        } else {
            s = 0;
        }

        if ((n | 0xffff) > end) {
            e = end & 0xffff;

        } else {
            e = 0xffff;
        }

        a = (ngx_array_t *) ctx->high.low[h];

        if (a == NULL) {
            a = ngx_array_create(ctx->temp_pool, 64,
                                 sizeof(ngx_stream_geo_range_t));
            if (a == NULL) {
                return NGX_CONF_ERROR;
            }

            ctx->high.low[h] = (ngx_stream_geo_range_t *) a;
        }

        i = a->nelts;
        range = a->elts;

        while (i) {

          ...",1,1,stream\ngx_stream_geo_module.c,ngx_stream_geo_add_range,,false,733,932,ngx_stream_geo_add_range,,,43,"char* ngx_stream_geo_add_range (ngx_conf_t*,ngx_stream_geo_conf_ctx_t*,in_addr_t,in_addr_t)"
429410,METHOD,stream\ngx_stream_geo_module.c:<global>,TYPE_DECL,"static ngx_uint_t
ngx_stream_geo_delete_range(ngx_conf_t *cf, ngx_stream_geo_conf_ctx_t *ctx,
    in_addr_t start, in_addr_t end)
{
    in_addr_t                n;
    ngx_uint_t               h, i, s, e, warn;
    ngx_array_t             *a;
    ngx_stream_geo_range_t  *range;

    warn = 0;

    for (n = start; n <= end; n = (n + 0x10000) & 0xffff0000) {

        h = n >> 16;

        if (n == start) {
            s = n & 0xffff;
        } else {
            s = 0;
        }

        if ((n | 0xffff) > end) {
            e = end & 0xffff;

        } else {
            e = 0xffff;
        }

        a = (ngx_array_t *) ctx->high.low[h];

        if (a == NULL || a->nelts == 0) {
            warn = 1;
            goto next;
        }

        range = a->elts;
        for (i = 0; i < a->nelts; i++) {

            if (s == (ngx_uint_t) range[i].start
                && e == (ngx_uint_t) range[i].end)
            {
                ngx_memmove(&range[i], &range[i + 1],
                 ...",1,1,stream\ngx_stream_geo_module.c,ngx_stream_geo_delete_range,,false,935,997,ngx_stream_geo_delete_range,,,44,"ngx_uint_t ngx_stream_geo_delete_range (ngx_conf_t*,ngx_stream_geo_conf_ctx_t*,in_addr_t,in_addr_t)"
429594,METHOD,stream\ngx_stream_geo_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_geo_cidr(ngx_conf_t *cf, ngx_stream_geo_conf_ctx_t *ctx,
    ngx_str_t *value)
{
    char        *rv;
    ngx_int_t    rc, del;
    ngx_str_t   *net;
    ngx_cidr_t   cidr;

    if (ctx->tree == NULL) {
        ctx->tree = ngx_radix_tree_create(ctx->pool, -1);
        if (ctx->tree == NULL) {
            return NGX_CONF_ERROR;
        }
    }

#if (NGX_HAVE_INET6)
    if (ctx->tree6 == NULL) {
        ctx->tree6 = ngx_radix_tree_create(ctx->pool, -1);
        if (ctx->tree6 == NULL) {
            return NGX_CONF_ERROR;
        }
    }
#endif

    if (ngx_strcmp(value[0].data, ""default"") == 0) {
        cidr.family = AF_INET;
        cidr.u.in.addr = 0;
        cidr.u.in.mask = 0;

        rv = ngx_stream_geo_cidr_add(cf, ctx, &cidr, &value[1], &value[0]);

        if (rv != NGX_CONF_OK) {
            return rv;
        }

#if (NGX_HAVE_INET6)
        cidr.family = AF_INET6;
        ngx_memzero(&cidr.u.in6, sizeof(ngx_in6_cidr_t));

        rv = ngx_stream_ge...",1,1,stream\ngx_stream_geo_module.c,ngx_stream_geo_cidr,,false,1000,1094,ngx_stream_geo_cidr,,,45,"char* ngx_stream_geo_cidr (ngx_conf_t*,ngx_stream_geo_conf_ctx_t*,ngx_str_t*)"
429825,METHOD,stream\ngx_stream_geo_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_geo_cidr_add(ngx_conf_t *cf, ngx_stream_geo_conf_ctx_t *ctx,
    ngx_cidr_t *cidr, ngx_str_t *value, ngx_str_t *net)
{
    ngx_int_t                     rc;
    ngx_stream_variable_value_t  *val, *old;

    val = ngx_stream_geo_value(cf, ctx, value);

    if (val == NULL) {
        return NGX_CONF_ERROR;
    }

    switch (cidr->family) {

#if (NGX_HAVE_INET6)
    case AF_INET6:
        rc = ngx_radix128tree_insert(ctx->tree6, cidr->u.in6.addr.s6_addr,
                                     cidr->u.in6.mask.s6_addr,
                                     (uintptr_t) val);

        if (rc == NGX_OK) {
            return NGX_CONF_OK;
        }

        if (rc == NGX_ERROR) {
            return NGX_CONF_ERROR;
        }

        /* rc == NGX_BUSY */

        old = (ngx_stream_variable_value_t *)
                   ngx_radix128tree_find(ctx->tree6,
                                         cidr->u.in6.addr.s6_addr);

        ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
  ...",1,1,stream\ngx_stream_geo_module.c,ngx_stream_geo_cidr_add,,false,1097,1192,ngx_stream_geo_cidr_add,,,46,"char* ngx_stream_geo_cidr_add (ngx_conf_t*,ngx_stream_geo_conf_ctx_t*,ngx_cidr_t*,ngx_str_t*,ngx_str_t*)"
429981,METHOD,stream\ngx_stream_geo_module.c:<global>,TYPE_DECL,"static ngx_stream_variable_value_t *
ngx_stream_geo_value(ngx_conf_t *cf, ngx_stream_geo_conf_ctx_t *ctx,
    ngx_str_t *value)
{
    uint32_t                               hash;
    ngx_stream_variable_value_t           *val;
    ngx_stream_geo_variable_value_node_t  *gvvn;

    hash = ngx_crc32_long(value->data, value->len);

    gvvn = (ngx_stream_geo_variable_value_node_t *)
               ngx_str_rbtree_lookup(&ctx->rbtree, value, hash);

    if (gvvn) {
        return gvvn->value;
    }

    val = ngx_palloc(ctx->pool, sizeof(ngx_stream_variable_value_t));
    if (val == NULL) {
        return NULL;
    }

    val->len = value->len;
    val->data = ngx_pstrdup(ctx->pool, value);
    if (val->data == NULL) {
        return NULL;
    }

    val->valid = 1;
    val->no_cacheable = 0;
    val->not_found = 0;

    gvvn = ngx_palloc(ctx->temp_pool,
                      sizeof(ngx_stream_geo_variable_value_node_t));
    if (gvvn == NULL) {
        return NULL;
    }

    gvvn->sn.no...",1,1,stream\ngx_stream_geo_module.c,ngx_stream_geo_value,,false,1195,1245,ngx_stream_geo_value,,,47,"ngx_stream_variable_value_t ngx_stream_geo_value (ngx_conf_t*,ngx_stream_geo_conf_ctx_t*,ngx_str_t*)"
430155,METHOD,stream\ngx_stream_geo_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_geo_cidr_value(ngx_conf_t *cf, ngx_str_t *net, ngx_cidr_t *cidr)
{
    ngx_int_t  rc;

    if (ngx_strcmp(net->data, ""255.255.255.255"") == 0) {
        cidr->family = AF_INET;
        cidr->u.in.addr = 0xffffffff;
        cidr->u.in.mask = 0xffffffff;

        return NGX_OK;
    }

    rc = ngx_ptocidr(net, cidr);

    if (rc == NGX_ERROR) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, ""invalid network \""%V\"""", net);
        return NGX_ERROR;
    }

    if (rc == NGX_DONE) {
        ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
                           ""low address bits of %V are meaningless"", net);
    }

    return NGX_OK;
}",1,1,stream\ngx_stream_geo_module.c,ngx_stream_geo_cidr_value,,false,1248,1274,ngx_stream_geo_cidr_value,,,48,"ngx_int_t ngx_stream_geo_cidr_value (ngx_conf_t*,ngx_str_t*,ngx_cidr_t*)"
430228,METHOD,stream\ngx_stream_geo_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_geo_include(ngx_conf_t *cf, ngx_stream_geo_conf_ctx_t *ctx,
    ngx_str_t *name)
{
    char       *rv;
    ngx_str_t   file;

    file.len = name->len + 4;
    file.data = ngx_pnalloc(ctx->temp_pool, name->len + 5);
    if (file.data == NULL) {
        return NGX_CONF_ERROR;
    }

    ngx_sprintf(file.data, ""%V.bin%Z"", name);

    if (ngx_conf_full_name(cf->cycle, &file, 1) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    if (ctx->ranges) {
        ngx_log_debug1(NGX_LOG_DEBUG_CORE, cf->log, 0, ""include %s"", file.data);

        switch (ngx_stream_geo_include_binary_base(cf, ctx, &file)) {
        case NGX_OK:
            return NGX_CONF_OK;
        case NGX_ERROR:
            return NGX_CONF_ERROR;
        default:
            break;
        }
    }

    file.len -= 4;
    file.data[file.len] = '\0';

    ctx->include_name = file;

    if (ctx->outside_entries) {
        ctx->allow_binary_include = 0;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_CORE, cf-...",1,1,stream\ngx_stream_geo_module.c,ngx_stream_geo_include,,false,1277,1326,ngx_stream_geo_include,,,49,"char* ngx_stream_geo_include (ngx_conf_t*,ngx_stream_geo_conf_ctx_t*,ngx_str_t*)"
430375,METHOD,stream\ngx_stream_geo_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_geo_include_binary_base(ngx_conf_t *cf,
    ngx_stream_geo_conf_ctx_t *ctx, ngx_str_t *name)
{
    u_char                       *base, ch;
    time_t                        mtime;
    size_t                        size, len;
    ssize_t                       n;
    uint32_t                      crc32;
    ngx_err_t                     err;
    ngx_int_t                     rc;
    ngx_uint_t                    i;
    ngx_file_t                    file;
    ngx_file_info_t               fi;
    ngx_stream_geo_range_t       *range, **ranges;
    ngx_stream_geo_header_t      *header;
    ngx_stream_variable_value_t  *vv;

    ngx_memzero(&file, sizeof(ngx_file_t));
    file.name = *name;
    file.log = cf->log;

    file.fd = ngx_open_file(name->data, NGX_FILE_RDONLY, NGX_FILE_OPEN, 0);

    if (file.fd == NGX_INVALID_FILE) {
        err = ngx_errno;
        if (err != NGX_ENOENT) {
            ngx_conf_log_error(NGX_LOG_CRIT, cf, err,
                      ...",1,1,stream\ngx_stream_geo_module.c,ngx_stream_geo_include_binary_base,,false,1329,1502,ngx_stream_geo_include_binary_base,,,50,"ngx_int_t ngx_stream_geo_include_binary_base (ngx_conf_t*,ngx_stream_geo_conf_ctx_t*,ngx_str_t*)"
430868,METHOD,stream\ngx_stream_geo_module.c:<global>,TYPE_DECL,"static void
ngx_stream_geo_create_binary_base(ngx_stream_geo_conf_ctx_t *ctx)
{
    u_char                                *p;
    uint32_t                               hash;
    ngx_str_t                              s;
    ngx_uint_t                             i;
    ngx_file_mapping_t                     fm;
    ngx_stream_geo_range_t                *r, *range, **ranges;
    ngx_stream_geo_header_t               *header;
    ngx_stream_geo_variable_value_node_t  *gvvn;

    fm.name = ngx_pnalloc(ctx->temp_pool, ctx->include_name.len + 5);
    if (fm.name == NULL) {
        return;
    }

    ngx_sprintf(fm.name, ""%V.bin%Z"", &ctx->include_name);

    fm.size = ctx->data_size;
    fm.log = ctx->pool->log;

    ngx_log_error(NGX_LOG_NOTICE, fm.log, 0,
                  ""creating binary geo range base \""%s\"""", fm.name);

    if (ngx_create_file_mapping(&fm) != NGX_OK) {
        return;
    }

    p = ngx_cpymem(fm.addr, &ngx_stream_geo_header,
                   sizeof(ngx_stream_ge...",1,1,stream\ngx_stream_geo_module.c,ngx_stream_geo_create_binary_base,,false,1505,1580,ngx_stream_geo_create_binary_base,,,51,void ngx_stream_geo_create_binary_base (ngx_stream_geo_conf_ctx_t*)
431145,METHOD,stream\ngx_stream_geo_module.c:<global>,TYPE_DECL,"static u_char *
ngx_stream_geo_copy_values(u_char *base, u_char *p, ngx_rbtree_node_t *node,
    ngx_rbtree_node_t *sentinel)
{
    ngx_stream_variable_value_t           *vv;
    ngx_stream_geo_variable_value_node_t  *gvvn;

    if (node == sentinel) {
        return p;
    }

    gvvn = (ngx_stream_geo_variable_value_node_t *) node;
    gvvn->offset = p - base;

    vv = (ngx_stream_variable_value_t *) p;
    *vv = *gvvn->value;
    p += sizeof(ngx_stream_variable_value_t);
    vv->data = (u_char *) (p - base);

    p = ngx_cpymem(p, gvvn->sn.str.data, gvvn->sn.str.len);

    p = ngx_align_ptr(p, sizeof(void *));

    p = ngx_stream_geo_copy_values(base, p, node->left, sentinel);

    return ngx_stream_geo_copy_values(base, p, node->right, sentinel);
}",1,1,stream\ngx_stream_geo_module.c,ngx_stream_geo_copy_values,,false,1583,1609,ngx_stream_geo_copy_values,,,52,"u_char ngx_stream_geo_copy_values (u_char*,u_char*,ngx_rbtree_node_t*,ngx_rbtree_node_t*)"
431253,METHOD,stream\ngx_stream_geoip_module.c:<global>,TYPE_DECL,<global>,1,6,stream\ngx_stream_geoip_module.c,stream\ngx_stream_geoip_module.c:<global>,,false,1,814,<global>,,,1,
431267,METHOD,stream\ngx_stream_geoip_module.c:<global>,TYPE_DECL,"typedef const char *(*ngx_stream_geoip_variable_handler_pt)(GeoIP *,
    u_long addr);",20,16,stream\ngx_stream_geoip_module.c,ngx_stream_geoip_variable_handler_pt,,false,39,40,ngx_stream_geoip_variable_handler_pt,,,5,"char* ngx_stream_geoip_variable_handler_pt (GeoIP*,u_long)"
431280,METHOD,stream\ngx_stream_geoip_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_geoip_country_variable(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data);",18,51,stream\ngx_stream_geoip_module.c,ngx_stream_geoip_country_variable,,false,67,68,ngx_stream_geoip_country_variable,,,8,"ngx_int_t ngx_stream_geoip_country_variable (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
431287,METHOD,stream\ngx_stream_geoip_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_geoip_org_variable(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data);",18,51,stream\ngx_stream_geoip_module.c,ngx_stream_geoip_org_variable,,false,69,70,ngx_stream_geoip_org_variable,,,9,"ngx_int_t ngx_stream_geoip_org_variable (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
431294,METHOD,stream\ngx_stream_geoip_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_geoip_city_variable(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data);",18,51,stream\ngx_stream_geoip_module.c,ngx_stream_geoip_city_variable,,false,71,72,ngx_stream_geoip_city_variable,,,10,"ngx_int_t ngx_stream_geoip_city_variable (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
431301,METHOD,stream\ngx_stream_geoip_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_geoip_region_name_variable(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data);",18,51,stream\ngx_stream_geoip_module.c,ngx_stream_geoip_region_name_variable,,false,73,74,ngx_stream_geoip_region_name_variable,,,11,"ngx_int_t ngx_stream_geoip_region_name_variable (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
431308,METHOD,stream\ngx_stream_geoip_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_geoip_city_float_variable(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data);",18,51,stream\ngx_stream_geoip_module.c,ngx_stream_geoip_city_float_variable,,false,75,76,ngx_stream_geoip_city_float_variable,,,12,"ngx_int_t ngx_stream_geoip_city_float_variable (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
431315,METHOD,stream\ngx_stream_geoip_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_geoip_city_int_variable(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data);",18,51,stream\ngx_stream_geoip_module.c,ngx_stream_geoip_city_int_variable,,false,77,78,ngx_stream_geoip_city_int_variable,,,13,"ngx_int_t ngx_stream_geoip_city_int_variable (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
431322,METHOD,stream\ngx_stream_geoip_module.c:<global>,TYPE_DECL,static GeoIPRecord *ngx_stream_geoip_get_city_record(ngx_stream_session_t *s);,20,77,stream\ngx_stream_geoip_module.c,ngx_stream_geoip_get_city_record,,false,79,79,ngx_stream_geoip_get_city_record,,,14,GeoIPRecord* ngx_stream_geoip_get_city_record (ngx_stream_session_t*)
431327,METHOD,stream\ngx_stream_geoip_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_stream_geoip_add_variables(ngx_conf_t *cf);,18,63,stream\ngx_stream_geoip_module.c,ngx_stream_geoip_add_variables,,false,81,81,ngx_stream_geoip_add_variables,,,15,ngx_int_t ngx_stream_geoip_add_variables (ngx_conf_t*)
431332,METHOD,stream\ngx_stream_geoip_module.c:<global>,TYPE_DECL,static void *ngx_stream_geoip_create_conf(ngx_conf_t *cf);,13,57,stream\ngx_stream_geoip_module.c,ngx_stream_geoip_create_conf,,false,82,82,ngx_stream_geoip_create_conf,,,16,void* ngx_stream_geoip_create_conf (ngx_conf_t*)
431337,METHOD,stream\ngx_stream_geoip_module.c:<global>,TYPE_DECL,"static char *ngx_stream_geoip_country(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,stream\ngx_stream_geoip_module.c,ngx_stream_geoip_country,,false,83,84,ngx_stream_geoip_country,,,17,"char* ngx_stream_geoip_country (ngx_conf_t*,ngx_command_t*,void*)"
431344,METHOD,stream\ngx_stream_geoip_module.c:<global>,TYPE_DECL,"static char *ngx_stream_geoip_org(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,stream\ngx_stream_geoip_module.c,ngx_stream_geoip_org,,false,85,86,ngx_stream_geoip_org,,,18,"char* ngx_stream_geoip_org (ngx_conf_t*,ngx_command_t*,void*)"
431351,METHOD,stream\ngx_stream_geoip_module.c:<global>,TYPE_DECL,"static char *ngx_stream_geoip_city(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,stream\ngx_stream_geoip_module.c,ngx_stream_geoip_city,,false,87,88,ngx_stream_geoip_city,,,19,"char* ngx_stream_geoip_city (ngx_conf_t*,ngx_command_t*,void*)"
431358,METHOD,stream\ngx_stream_geoip_module.c:<global>,TYPE_DECL,static void ngx_stream_geoip_cleanup(void *data);,13,48,stream\ngx_stream_geoip_module.c,ngx_stream_geoip_cleanup,,false,89,89,ngx_stream_geoip_cleanup,,,20,void ngx_stream_geoip_cleanup (void*)
431586,METHOD,stream\ngx_stream_geoip_module.c:<global>,TYPE_DECL,"static u_long
ngx_stream_geoip_addr(ngx_stream_session_t *s, ngx_stream_geoip_conf_t *gcf)
{
    ngx_addr_t           addr;
    struct sockaddr_in  *sin;

    addr.sockaddr = s->connection->sockaddr;
    addr.socklen = s->connection->socklen;
    /* addr.name = s->connection->addr_text; */

#if (NGX_HAVE_INET6)

    if (addr.sockaddr->sa_family == AF_INET6) {
        u_char           *p;
        in_addr_t         inaddr;
        struct in6_addr  *inaddr6;

        inaddr6 = &((struct sockaddr_in6 *) addr.sockaddr)->sin6_addr;

        if (IN6_IS_ADDR_V4MAPPED(inaddr6)) {
            p = inaddr6->s6_addr;

            inaddr = p[12] << 24;
            inaddr += p[13] << 16;
            inaddr += p[14] << 8;
            inaddr += p[15];

            return inaddr;
        }
    }

#endif

    if (addr.sockaddr->sa_family != AF_INET) {
        return INADDR_NONE;
    }

    sin = (struct sockaddr_in *) addr.sockaddr;
    return ntohl(sin->sin_addr.s_addr);
}",1,1,stream\ngx_stream_geoip_module.c,ngx_stream_geoip_addr,,false,217,256,ngx_stream_geoip_addr,,,29,"u_long ngx_stream_geoip_addr (ngx_stream_session_t*,ngx_stream_geoip_conf_t*)"
431637,METHOD,stream\ngx_stream_geoip_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_geoip_country_variable(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data)
{
    ngx_stream_geoip_variable_handler_pt     handler =
        ngx_stream_geoip_country_functions[data];
#if (NGX_HAVE_GEOIP_V6)
    ngx_stream_geoip_variable_handler_v6_pt  handler_v6 =
        ngx_stream_geoip_country_v6_functions[data];
#endif

    const char               *val;
    ngx_stream_geoip_conf_t  *gcf;

    gcf = ngx_stream_get_module_main_conf(s, ngx_stream_geoip_module);

    if (gcf->country == NULL) {
        goto not_found;
    }

#if (NGX_HAVE_GEOIP_V6)
    val = gcf->country_v6
              ? handler_v6(gcf->country, ngx_stream_geoip_addr_v6(s, gcf))
              : handler(gcf->country, ngx_stream_geoip_addr(s, gcf));
#else
    val = handler(gcf->country, ngx_stream_geoip_addr(s, gcf));
#endif

    if (val == NULL) {
        goto not_found;
    }

    v->len = ngx_strlen(val);
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_fo...",1,1,stream\ngx_stream_geoip_module.c,ngx_stream_geoip_country_variable,,false,302,347,ngx_stream_geoip_country_variable,,,30,"ngx_int_t ngx_stream_geoip_country_variable (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
431718,METHOD,stream\ngx_stream_geoip_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_geoip_org_variable(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data)
{
    size_t                    len;
    char                     *val;
    ngx_stream_geoip_conf_t  *gcf;

    gcf = ngx_stream_get_module_main_conf(s, ngx_stream_geoip_module);

    if (gcf->org == NULL) {
        goto not_found;
    }

#if (NGX_HAVE_GEOIP_V6)
    val = gcf->org_v6
              ? GeoIP_name_by_ipnum_v6(gcf->org,
                                       ngx_stream_geoip_addr_v6(s, gcf))
              : GeoIP_name_by_ipnum(gcf->org,
                                    ngx_stream_geoip_addr(s, gcf));
#else
    val = GeoIP_name_by_ipnum(gcf->org, ngx_stream_geoip_addr(s, gcf));
#endif

    if (val == NULL) {
        goto not_found;
    }

    len = ngx_strlen(val);
    v->data = ngx_pnalloc(s->connection->pool, len);
    if (v->data == NULL) {
        ngx_free(val);
        return NGX_ERROR;
    }

    ngx_memcpy(v->data, val, len);

    v->len = ...",1,1,stream\ngx_stream_geoip_module.c,ngx_stream_geoip_org_variable,,false,350,401,ngx_stream_geoip_org_variable,,,31,"ngx_int_t ngx_stream_geoip_org_variable (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
431820,METHOD,stream\ngx_stream_geoip_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_geoip_city_variable(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data)
{
    char         *val;
    size_t        len;
    GeoIPRecord  *gr;

    gr = ngx_stream_geoip_get_city_record(s);
    if (gr == NULL) {
        goto not_found;
    }

    val = *(char **) ((char *) gr + data);
    if (val == NULL) {
        goto no_value;
    }

    len = ngx_strlen(val);
    v->data = ngx_pnalloc(s->connection->pool, len);
    if (v->data == NULL) {
        GeoIPRecord_delete(gr);
        return NGX_ERROR;
    }

    ngx_memcpy(v->data, val, len);

    v->len = len;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;

    GeoIPRecord_delete(gr);

    return NGX_OK;

no_value:

    GeoIPRecord_delete(gr);

not_found:

    v->not_found = 1;

    return NGX_OK;
}",1,1,stream\ngx_stream_geoip_module.c,ngx_stream_geoip_city_variable,,false,404,449,ngx_stream_geoip_city_variable,,,32,"ngx_int_t ngx_stream_geoip_city_variable (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
431923,METHOD,stream\ngx_stream_geoip_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_geoip_region_name_variable(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data)
{
    size_t        len;
    const char   *val;
    GeoIPRecord  *gr;

    gr = ngx_stream_geoip_get_city_record(s);
    if (gr == NULL) {
        goto not_found;
    }

    val = GeoIP_region_name_by_code(gr->country_code, gr->region);

    GeoIPRecord_delete(gr);

    if (val == NULL) {
        goto not_found;
    }

    len = ngx_strlen(val);
    v->data = ngx_pnalloc(s->connection->pool, len);
    if (v->data == NULL) {
        return NGX_ERROR;
    }

    ngx_memcpy(v->data, val, len);

    v->len = len;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;

    return NGX_OK;

not_found:

    v->not_found = 1;

    return NGX_OK;
}",1,1,stream\ngx_stream_geoip_module.c,ngx_stream_geoip_region_name_variable,,false,452,493,ngx_stream_geoip_region_name_variable,,,33,"ngx_int_t ngx_stream_geoip_region_name_variable (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
432020,METHOD,stream\ngx_stream_geoip_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_geoip_city_float_variable(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data)
{
    float         val;
    GeoIPRecord  *gr;

    gr = ngx_stream_geoip_get_city_record(s);
    if (gr == NULL) {
        v->not_found = 1;
        return NGX_OK;
    }

    v->data = ngx_pnalloc(s->connection->pool, NGX_INT64_LEN + 5);
    if (v->data == NULL) {
        GeoIPRecord_delete(gr);
        return NGX_ERROR;
    }

    val = *(float *) ((char *) gr + data);

    v->len = ngx_sprintf(v->data, ""%.4f"", val) - v->data;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;

    GeoIPRecord_delete(gr);

    return NGX_OK;
}",1,1,stream\ngx_stream_geoip_module.c,ngx_stream_geoip_city_float_variable,,false,496,525,ngx_stream_geoip_city_float_variable,,,34,"ngx_int_t ngx_stream_geoip_city_float_variable (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
432112,METHOD,stream\ngx_stream_geoip_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_geoip_city_int_variable(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data)
{
    int           val;
    GeoIPRecord  *gr;

    gr = ngx_stream_geoip_get_city_record(s);
    if (gr == NULL) {
        v->not_found = 1;
        return NGX_OK;
    }

    v->data = ngx_pnalloc(s->connection->pool, NGX_INT64_LEN);
    if (v->data == NULL) {
        GeoIPRecord_delete(gr);
        return NGX_ERROR;
    }

    val = *(int *) ((char *) gr + data);

    v->len = ngx_sprintf(v->data, ""%d"", val) - v->data;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;

    GeoIPRecord_delete(gr);

    return NGX_OK;
}",1,1,stream\ngx_stream_geoip_module.c,ngx_stream_geoip_city_int_variable,,false,528,557,ngx_stream_geoip_city_int_variable,,,35,"ngx_int_t ngx_stream_geoip_city_int_variable (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
432202,METHOD,stream\ngx_stream_geoip_module.c:<global>,TYPE_DECL,"static GeoIPRecord *
ngx_stream_geoip_get_city_record(ngx_stream_session_t *s)
{
    ngx_stream_geoip_conf_t  *gcf;

    gcf = ngx_stream_get_module_main_conf(s, ngx_stream_geoip_module);

    if (gcf->city) {
#if (NGX_HAVE_GEOIP_V6)
        return gcf->city_v6
                   ? GeoIP_record_by_ipnum_v6(gcf->city,
                                              ngx_stream_geoip_addr_v6(s, gcf))
                   : GeoIP_record_by_ipnum(gcf->city,
                                           ngx_stream_geoip_addr(s, gcf));
#else
        return GeoIP_record_by_ipnum(gcf->city, ngx_stream_geoip_addr(s, gcf));
#endif
    }

    return NULL;
}",1,1,stream\ngx_stream_geoip_module.c,ngx_stream_geoip_get_city_record,,false,560,580,ngx_stream_geoip_get_city_record,,,36,GeoIPRecord ngx_stream_geoip_get_city_record (ngx_stream_session_t*)
432228,METHOD,stream\ngx_stream_geoip_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_geoip_add_variables(ngx_conf_t *cf)
{
    ngx_stream_variable_t  *var, *v;

    for (v = ngx_stream_geoip_vars; v->name.len; v++) {
        var = ngx_stream_add_variable(cf, &v->name, v->flags);
        if (var == NULL) {
            return NGX_ERROR;
        }

        var->get_handler = v->get_handler;
        var->data = v->data;
    }

    return NGX_OK;
}",1,1,stream\ngx_stream_geoip_module.c,ngx_stream_geoip_add_variables,,false,583,599,ngx_stream_geoip_add_variables,,,37,ngx_int_t ngx_stream_geoip_add_variables (ngx_conf_t*)
432282,METHOD,stream\ngx_stream_geoip_module.c:<global>,TYPE_DECL,"static void *
ngx_stream_geoip_create_conf(ngx_conf_t *cf)
{
    ngx_pool_cleanup_t       *cln;
    ngx_stream_geoip_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_stream_geoip_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    cln = ngx_pool_cleanup_add(cf->pool, 0);
    if (cln == NULL) {
        return NULL;
    }

    cln->handler = ngx_stream_geoip_cleanup;
    cln->data = conf;

    return conf;
}",1,1,stream\ngx_stream_geoip_module.c,ngx_stream_geoip_create_conf,,false,602,622,ngx_stream_geoip_create_conf,,,38,void* ngx_stream_geoip_create_conf (ngx_conf_t*)
432330,METHOD,stream\ngx_stream_geoip_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_geoip_country(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_stream_geoip_conf_t  *gcf = conf;

    ngx_str_t  *value;

    if (gcf->country) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    gcf->country = GeoIP_open((char *) value[1].data, GEOIP_MEMORY_CACHE);

    if (gcf->country == NULL) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""GeoIP_open(\""%V\"") failed"", &value[1]);

        return NGX_CONF_ERROR;
    }

    if (cf->args->nelts == 3) {
        if (ngx_strcmp(value[2].data, ""utf8"") == 0) {
            GeoIP_set_charset(gcf->country, GEOIP_CHARSET_UTF8);

        } else {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               ""invalid parameter \""%V\"""", &value[2]);
            return NGX_CONF_ERROR;
        }
    }

    switch (gcf->country->databaseType) {

    case GEOIP_COUNTRY_EDITION:

        return NGX_CONF_OK;

#if (NGX_HAVE_GEOIP_V6)
    case GEO...",1,1,stream\ngx_stream_geoip_module.c,ngx_stream_geoip_country,,false,625,677,ngx_stream_geoip_country,,,39,"char* ngx_stream_geoip_country (ngx_conf_t*,ngx_command_t*,void*)"
432453,METHOD,stream\ngx_stream_geoip_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_geoip_org(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_stream_geoip_conf_t  *gcf = conf;

    ngx_str_t  *value;

    if (gcf->org) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    gcf->org = GeoIP_open((char *) value[1].data, GEOIP_MEMORY_CACHE);

    if (gcf->org == NULL) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""GeoIP_open(\""%V\"") failed"", &value[1]);

        return NGX_CONF_ERROR;
    }

    if (cf->args->nelts == 3) {
        if (ngx_strcmp(value[2].data, ""utf8"") == 0) {
            GeoIP_set_charset(gcf->org, GEOIP_CHARSET_UTF8);

        } else {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               ""invalid parameter \""%V\"""", &value[2]);
            return NGX_CONF_ERROR;
        }
    }

    switch (gcf->org->databaseType) {

    case GEOIP_ISP_EDITION:
    case GEOIP_ORG_EDITION:
    case GEOIP_DOMAIN_EDITION:
    case GEOIP_ASNUM_EDITION:

    ...",1,1,stream\ngx_stream_geoip_module.c,ngx_stream_geoip_org,,false,680,738,ngx_stream_geoip_org,,,40,"char* ngx_stream_geoip_org (ngx_conf_t*,ngx_command_t*,void*)"
432582,METHOD,stream\ngx_stream_geoip_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_geoip_city(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_stream_geoip_conf_t  *gcf = conf;

    ngx_str_t  *value;

    if (gcf->city) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    gcf->city = GeoIP_open((char *) value[1].data, GEOIP_MEMORY_CACHE);

    if (gcf->city == NULL) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""GeoIP_open(\""%V\"") failed"", &value[1]);

        return NGX_CONF_ERROR;
    }

    if (cf->args->nelts == 3) {
        if (ngx_strcmp(value[2].data, ""utf8"") == 0) {
            GeoIP_set_charset(gcf->city, GEOIP_CHARSET_UTF8);

        } else {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               ""invalid parameter \""%V\"""", &value[2]);
            return NGX_CONF_ERROR;
        }
    }

    switch (gcf->city->databaseType) {

    case GEOIP_CITY_EDITION_REV0:
    case GEOIP_CITY_EDITION_REV1:

        return NGX_CONF_OK;

#if (NGX_HAVE_GEOI...",1,1,stream\ngx_stream_geoip_module.c,ngx_stream_geoip_city,,false,741,795,ngx_stream_geoip_city,,,41,"char* ngx_stream_geoip_city (ngx_conf_t*,ngx_command_t*,void*)"
432707,METHOD,stream\ngx_stream_geoip_module.c:<global>,TYPE_DECL,"static void
ngx_stream_geoip_cleanup(void *data)
{
    ngx_stream_geoip_conf_t  *gcf = data;

    if (gcf->country) {
        GeoIP_delete(gcf->country);
    }

    if (gcf->org) {
        GeoIP_delete(gcf->org);
    }

    if (gcf->city) {
        GeoIP_delete(gcf->city);
    }
}",1,1,stream\ngx_stream_geoip_module.c,ngx_stream_geoip_cleanup,,false,798,814,ngx_stream_geoip_cleanup,,,42,void ngx_stream_geoip_cleanup (void*)
432754,METHOD,stream\ngx_stream_handler.c:<global>,TYPE_DECL,<global>,1,1,stream\ngx_stream_handler.c,stream\ngx_stream_handler.c:<global>,,false,1,385,<global>,,,1,
432756,METHOD,stream\ngx_stream_handler.c:<global>,TYPE_DECL,static void ngx_stream_log_session(ngx_stream_session_t *s);,13,59,stream\ngx_stream_handler.c,ngx_stream_log_session,,false,14,14,ngx_stream_log_session,,,1,void ngx_stream_log_session (ngx_stream_session_t*)
432761,METHOD,stream\ngx_stream_handler.c:<global>,TYPE_DECL,static void ngx_stream_close_connection(ngx_connection_t *c);,13,60,stream\ngx_stream_handler.c,ngx_stream_close_connection,,false,15,15,ngx_stream_close_connection,,,2,void ngx_stream_close_connection (ngx_connection_t*)
432766,METHOD,stream\ngx_stream_handler.c:<global>,TYPE_DECL,"static u_char *ngx_stream_log_error(ngx_log_t *log, u_char *buf, size_t len);",15,76,stream\ngx_stream_handler.c,ngx_stream_log_error,,false,16,16,ngx_stream_log_error,,,3,"u_char* ngx_stream_log_error (ngx_log_t*,u_char*,size_t)"
432773,METHOD,stream\ngx_stream_handler.c:<global>,TYPE_DECL,static void ngx_stream_proxy_protocol_handler(ngx_event_t *rev);,13,63,stream\ngx_stream_handler.c,ngx_stream_proxy_protocol_handler,,false,17,17,ngx_stream_proxy_protocol_handler,,,4,void ngx_stream_proxy_protocol_handler (ngx_event_t*)
432778,METHOD,stream\ngx_stream_handler.c:<global>,TYPE_DECL,"void
ngx_stream_init_connection(ngx_connection_t *c)
{
    u_char                        text[NGX_SOCKADDR_STRLEN];
    size_t                        len;
    ngx_uint_t                    i;
    ngx_time_t                   *tp;
    ngx_event_t                  *rev;
    struct sockaddr              *sa;
    ngx_stream_port_t            *port;
    struct sockaddr_in           *sin;
    ngx_stream_in_addr_t         *addr;
    ngx_stream_session_t         *s;
    ngx_stream_addr_conf_t       *addr_conf;
#if (NGX_HAVE_INET6)
    struct sockaddr_in6          *sin6;
    ngx_stream_in6_addr_t        *addr6;
#endif
    ngx_stream_core_srv_conf_t   *cscf;
    ngx_stream_core_main_conf_t  *cmcf;

    /* find the server configuration for the address:port */

    port = c->listening->servers;

    if (port->naddrs > 1) {

        /*
         * There are several addresses on this port and one of them
         * is the ""*:port"" wildcard so getsockname() is needed to determine
         * the ser...",1,1,stream\ngx_stream_handler.c,ngx_stream_init_connection,,false,20,202,ngx_stream_init_connection,,,5,void ngx_stream_init_connection (ngx_connection_t*)
433188,METHOD,stream\ngx_stream_handler.c:<global>,TYPE_DECL,"static void
ngx_stream_proxy_protocol_handler(ngx_event_t *rev)
{
    u_char                      *p, buf[NGX_PROXY_PROTOCOL_MAX_HEADER];
    size_t                       size;
    ssize_t                      n;
    ngx_err_t                    err;
    ngx_connection_t            *c;
    ngx_stream_session_t        *s;
    ngx_stream_core_srv_conf_t  *cscf;

    c = rev->data;
    s = c->data;

    ngx_log_debug0(NGX_LOG_DEBUG_STREAM, c->log, 0,
                   ""stream PROXY protocol handler"");

    if (rev->timedout) {
        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, ""client timed out"");
        ngx_stream_finalize_session(s, NGX_STREAM_OK);
        return;
    }

    n = recv(c->fd, (char *) buf, sizeof(buf), MSG_PEEK);

    err = ngx_socket_errno;

    ngx_log_debug1(NGX_LOG_DEBUG_STREAM, c->log, 0, ""recv(): %z"", n);

    if (n == -1) {
        if (err == NGX_EAGAIN) {
            rev->ready = 0;

            if (!rev->timer_set) {
                cscf = ngx_stream...",1,1,stream\ngx_stream_handler.c,ngx_stream_proxy_protocol_handler,,false,205,280,ngx_stream_proxy_protocol_handler,,,6,void ngx_stream_proxy_protocol_handler (ngx_event_t*)
433363,METHOD,stream\ngx_stream_handler.c:<global>,TYPE_DECL,"void
ngx_stream_session_handler(ngx_event_t *rev)
{
    ngx_connection_t      *c;
    ngx_stream_session_t  *s;

    c = rev->data;
    s = c->data;

    ngx_stream_core_run_phases(s);
}",1,1,stream\ngx_stream_handler.c,ngx_stream_session_handler,,false,283,293,ngx_stream_session_handler,,,7,void ngx_stream_session_handler (ngx_event_t*)
433382,METHOD,stream\ngx_stream_handler.c:<global>,TYPE_DECL,"void
ngx_stream_finalize_session(ngx_stream_session_t *s, ngx_uint_t rc)
{
    ngx_log_debug1(NGX_LOG_DEBUG_STREAM, s->connection->log, 0,
                   ""finalize stream session: %i"", rc);

    s->status = rc;

    ngx_stream_log_session(s);

    ngx_stream_close_connection(s->connection);
}",1,1,stream\ngx_stream_handler.c,ngx_stream_finalize_session,,false,296,307,ngx_stream_finalize_session,,,8,"void ngx_stream_finalize_session (ngx_stream_session_t*,ngx_uint_t)"
433409,METHOD,stream\ngx_stream_handler.c:<global>,TYPE_DECL,"static void
ngx_stream_log_session(ngx_stream_session_t *s)
{
    ngx_uint_t                    i, n;
    ngx_stream_handler_pt        *log_handler;
    ngx_stream_core_main_conf_t  *cmcf;

    cmcf = ngx_stream_get_module_main_conf(s, ngx_stream_core_module);

    log_handler = cmcf->phases[NGX_STREAM_LOG_PHASE].handlers.elts;
    n = cmcf->phases[NGX_STREAM_LOG_PHASE].handlers.nelts;

    for (i = 0; i < n; i++) {
        log_handler[i](s);
    }
}",1,1,stream\ngx_stream_handler.c,ngx_stream_log_session,,false,310,325,ngx_stream_log_session,,,9,void ngx_stream_log_session (ngx_stream_session_t*)
433461,METHOD,stream\ngx_stream_handler.c:<global>,TYPE_DECL,"static void
ngx_stream_close_connection(ngx_connection_t *c)
{
    ngx_pool_t  *pool;

    ngx_log_debug1(NGX_LOG_DEBUG_STREAM, c->log, 0,
                   ""close stream connection: %d"", c->fd);

#if (NGX_STREAM_SSL)

    if (c->ssl) {
        if (ngx_ssl_shutdown(c) == NGX_AGAIN) {
            c->ssl->handler = ngx_stream_close_connection;
            return;
        }
    }

#endif

#if (NGX_STAT_STUB)
    (void) ngx_atomic_fetch_add(ngx_stat_active, -1);
#endif

    pool = c->pool;

    ngx_close_connection(c);

    ngx_destroy_pool(pool);
}",1,1,stream\ngx_stream_handler.c,ngx_stream_close_connection,,false,328,356,ngx_stream_close_connection,,,10,void ngx_stream_close_connection (ngx_connection_t*)
433486,METHOD,stream\ngx_stream_handler.c:<global>,TYPE_DECL,"static u_char *
ngx_stream_log_error(ngx_log_t *log, u_char *buf, size_t len)
{
    u_char                *p;
    ngx_stream_session_t  *s;

    if (log->action) {
        p = ngx_snprintf(buf, len, "" while %s"", log->action);
        len -= p - buf;
        buf = p;
    }

    s = log->data;

    p = ngx_snprintf(buf, len, "", %sclient: %V, server: %V"",
                     s->connection->type == SOCK_DGRAM ? ""udp "" : """",
                     &s->connection->addr_text,
                     &s->connection->listening->addr_text);
    len -= p - buf;
    buf = p;

    if (s->log_handler) {
        p = s->log_handler(log, buf, len);
    }

    return p;
}",1,1,stream\ngx_stream_handler.c,ngx_stream_log_error,,false,359,385,ngx_stream_log_error,,,11,"u_char ngx_stream_log_error (ngx_log_t*,u_char*,size_t)"
433585,METHOD,stream\ngx_stream_limit_conn_module.c:<global>,TYPE_DECL,<global>,1,31,stream\ngx_stream_limit_conn_module.c,stream\ngx_stream_limit_conn_module.c:<global>,,false,1,737,<global>,,,1,
433592,METHOD,<empty>,<empty>,<empty>,1,,stream\ngx_stream_limit_conn_module.c,ngx_stream_limit_conn_node_t:<clinit>,,false,18,,<clinit>,,,5,
433621,METHOD,stream\ngx_stream_limit_conn_module.c:<global>,TYPE_DECL,"static ngx_rbtree_node_t *ngx_stream_limit_conn_lookup(ngx_rbtree_t *rbtree,
    ngx_str_t *key, uint32_t hash);",26,34,stream\ngx_stream_limit_conn_module.c,ngx_stream_limit_conn_lookup,,false,58,59,ngx_stream_limit_conn_lookup,,,13,"ngx_rbtree_node_t* ngx_stream_limit_conn_lookup (ngx_rbtree_t*,ngx_str_t*,uint32_t)"
433628,METHOD,stream\ngx_stream_limit_conn_module.c:<global>,TYPE_DECL,static void ngx_stream_limit_conn_cleanup(void *data);,13,53,stream\ngx_stream_limit_conn_module.c,ngx_stream_limit_conn_cleanup,,false,60,60,ngx_stream_limit_conn_cleanup,,,14,void ngx_stream_limit_conn_cleanup (void*)
433634,METHOD,stream\ngx_stream_limit_conn_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_limit_conn_status_variable(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data);",18,51,stream\ngx_stream_limit_conn_module.c,ngx_stream_limit_conn_status_variable,,false,63,64,ngx_stream_limit_conn_status_variable,,,16,"ngx_int_t ngx_stream_limit_conn_status_variable (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
433641,METHOD,stream\ngx_stream_limit_conn_module.c:<global>,TYPE_DECL,static void *ngx_stream_limit_conn_create_conf(ngx_conf_t *cf);,13,62,stream\ngx_stream_limit_conn_module.c,ngx_stream_limit_conn_create_conf,,false,65,65,ngx_stream_limit_conn_create_conf,,,17,void* ngx_stream_limit_conn_create_conf (ngx_conf_t*)
433646,METHOD,stream\ngx_stream_limit_conn_module.c:<global>,TYPE_DECL,"static char *ngx_stream_limit_conn_merge_conf(ngx_conf_t *cf, void *parent,
    void *child);",13,16,stream\ngx_stream_limit_conn_module.c,ngx_stream_limit_conn_merge_conf,,false,66,67,ngx_stream_limit_conn_merge_conf,,,18,"char* ngx_stream_limit_conn_merge_conf (ngx_conf_t*,void*,void*)"
433653,METHOD,stream\ngx_stream_limit_conn_module.c:<global>,TYPE_DECL,"static char *ngx_stream_limit_conn_zone(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,stream\ngx_stream_limit_conn_module.c,ngx_stream_limit_conn_zone,,false,68,69,ngx_stream_limit_conn_zone,,,19,"char* ngx_stream_limit_conn_zone (ngx_conf_t*,ngx_command_t*,void*)"
433660,METHOD,stream\ngx_stream_limit_conn_module.c:<global>,TYPE_DECL,"static char *ngx_stream_limit_conn(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,stream\ngx_stream_limit_conn_module.c,ngx_stream_limit_conn,,false,70,71,ngx_stream_limit_conn,,,20,"char* ngx_stream_limit_conn (ngx_conf_t*,ngx_command_t*,void*)"
433667,METHOD,stream\ngx_stream_limit_conn_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_stream_limit_conn_add_variables(ngx_conf_t *cf);,18,68,stream\ngx_stream_limit_conn_module.c,ngx_stream_limit_conn_add_variables,,false,72,72,ngx_stream_limit_conn_add_variables,,,21,ngx_int_t ngx_stream_limit_conn_add_variables (ngx_conf_t*)
433672,METHOD,stream\ngx_stream_limit_conn_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_stream_limit_conn_init(ngx_conf_t *cf);,18,59,stream\ngx_stream_limit_conn_module.c,ngx_stream_limit_conn_init,,false,73,73,ngx_stream_limit_conn_init,,,22,ngx_int_t ngx_stream_limit_conn_init (ngx_conf_t*)
433806,METHOD,stream\ngx_stream_limit_conn_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_limit_conn_handler(ngx_stream_session_t *s)
{
    size_t                            n;
    uint32_t                          hash;
    ngx_str_t                         key;
    ngx_uint_t                        i;
    ngx_rbtree_node_t                *node;
    ngx_pool_cleanup_t               *cln;
    ngx_stream_limit_conn_ctx_t      *ctx;
    ngx_stream_limit_conn_node_t     *lc;
    ngx_stream_limit_conn_conf_t     *lccf;
    ngx_stream_limit_conn_limit_t    *limits;
    ngx_stream_limit_conn_cleanup_t  *lccln;

    lccf = ngx_stream_get_module_srv_conf(s, ngx_stream_limit_conn_module);
    limits = lccf->limits.elts;

    for (i = 0; i < lccf->limits.nelts; i++) {
        ctx = limits[i].shm_zone->data;

        if (ngx_stream_complex_value(s, &ctx->key, &key) != NGX_OK) {
            return NGX_ERROR;
        }

        if (key.len == 0) {
            continue;
        }

        if (key.len > 255) {
            ngx_log_error(NGX_LOG_ERR, s->connec...",1,31,stream\ngx_stream_limit_conn_module.c,ngx_stream_limit_conn_handler,,false,163,288,ngx_stream_limit_conn_handler,,,35,ngx_int_t ngx_stream_limit_conn_handler (ngx_stream_session_t*)
434206,METHOD,stream\ngx_stream_limit_conn_module.c:<global>,TYPE_DECL,"static void
ngx_stream_limit_conn_rbtree_insert_value(ngx_rbtree_node_t *temp,
    ngx_rbtree_node_t *node, ngx_rbtree_node_t *sentinel)
{
    ngx_rbtree_node_t             **p;
    ngx_stream_limit_conn_node_t   *lcn, *lcnt;

    for ( ;; ) {

        if (node->key < temp->key) {

            p = &temp->left;

        } else if (node->key > temp->key) {

            p = &temp->right;

        } else { /* node->key == temp->key */

            lcn = (ngx_stream_limit_conn_node_t *) &node->color;
            lcnt = (ngx_stream_limit_conn_node_t *) &temp->color;

            p = (ngx_memn2cmp(lcn->data, lcnt->data, lcn->len, lcnt->len) < 0)
                ? &temp->left : &temp->right;
        }

        if (*p == sentinel) {
            break;
        }

        temp = *p;
    }

    *p = node;
    node->parent = temp;
    node->left = sentinel;
    node->right = sentinel;
    ngx_rbt_red(node);
}",1,1,stream\ngx_stream_limit_conn_module.c,ngx_stream_limit_conn_rbtree_insert_value,,false,291,329,ngx_stream_limit_conn_rbtree_insert_value,,,36,"void ngx_stream_limit_conn_rbtree_insert_value (ngx_rbtree_node_t*,ngx_rbtree_node_t*,ngx_rbtree_node_t*)"
434327,METHOD,stream\ngx_stream_limit_conn_module.c:<global>,TYPE_DECL,"static ngx_rbtree_node_t *
ngx_stream_limit_conn_lookup(ngx_rbtree_t *rbtree, ngx_str_t *key,
    uint32_t hash)
{
    ngx_int_t                      rc;
    ngx_rbtree_node_t             *node, *sentinel;
    ngx_stream_limit_conn_node_t  *lcn;

    node = rbtree->root;
    sentinel = rbtree->sentinel;

    while (node != sentinel) {

        if (hash < node->key) {
            node = node->left;
            continue;
        }

        if (hash > node->key) {
            node = node->right;
            continue;
        }

        /* hash == node->key */

        lcn = (ngx_stream_limit_conn_node_t *) &node->color;

        rc = ngx_memn2cmp(key->data, lcn->data, key->len, (size_t) lcn->len);

        if (rc == 0) {
            return node;
        }

        node = (rc < 0) ? node->left : node->right;
    }

    return NULL;
}",1,1,stream\ngx_stream_limit_conn_module.c,ngx_stream_limit_conn_lookup,,false,332,369,ngx_stream_limit_conn_lookup,,,37,"ngx_rbtree_node_t ngx_stream_limit_conn_lookup (ngx_rbtree_t*,ngx_str_t*,uint32_t)"
434425,METHOD,stream\ngx_stream_limit_conn_module.c:<global>,TYPE_DECL,"static void
ngx_stream_limit_conn_cleanup(void *data)
{
    ngx_stream_limit_conn_cleanup_t  *lccln = data;

    ngx_rbtree_node_t             *node;
    ngx_stream_limit_conn_ctx_t   *ctx;
    ngx_stream_limit_conn_node_t  *lc;

    ctx = lccln->shm_zone->data;
    node = lccln->node;
    lc = (ngx_stream_limit_conn_node_t *) &node->color;

    ngx_shmtx_lock(&ctx->shpool->mutex);

    ngx_log_debug2(NGX_LOG_DEBUG_STREAM, lccln->shm_zone->shm.log, 0,
                   ""limit conn cleanup: %08Xi %d"", node->key, lc->conn);

    lc->conn--;

    if (lc->conn == 0) {
        ngx_rbtree_delete(&ctx->sh->rbtree, node);
        ngx_slab_free_locked(ctx->shpool, node);
    }

    ngx_shmtx_unlock(&ctx->shpool->mutex);
}",1,1,stream\ngx_stream_limit_conn_module.c,ngx_stream_limit_conn_cleanup,,false,372,398,ngx_stream_limit_conn_cleanup,,,38,void ngx_stream_limit_conn_cleanup (void*)
434513,METHOD,stream\ngx_stream_limit_conn_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_limit_conn_init_zone(ngx_shm_zone_t *shm_zone, void *data)
{
    ngx_stream_limit_conn_ctx_t  *octx = data;

    size_t                        len;
    ngx_stream_limit_conn_ctx_t  *ctx;

    ctx = shm_zone->data;

    if (octx) {
        if (ctx->key.value.len != octx->key.value.len
            || ngx_strncmp(ctx->key.value.data, octx->key.value.data,
                           ctx->key.value.len)
               != 0)
        {
            ngx_log_error(NGX_LOG_EMERG, shm_zone->shm.log, 0,
                          ""limit_conn_zone \""%V\"" uses the \""%V\"" key ""
                          ""while previously it used the \""%V\"" key"",
                          &shm_zone->shm.name, &ctx->key.value,
                          &octx->key.value);
            return NGX_ERROR;
        }

        ctx->sh = octx->sh;
        ctx->shpool = octx->shpool;

        return NGX_OK;
    }

    ctx->shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;

    if (shm_zone->shm.exists...",1,1,stream\ngx_stream_limit_conn_module.c,ngx_stream_limit_conn_init_zone,,false,417,477,ngx_stream_limit_conn_init_zone,,,40,"ngx_int_t ngx_stream_limit_conn_init_zone (ngx_shm_zone_t*,void*)"
434740,METHOD,stream\ngx_stream_limit_conn_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_limit_conn_status_variable(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data)
{
    if (s->limit_conn_status == 0) {
        v->not_found = 1;
        return NGX_OK;
    }

    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->len = ngx_stream_limit_conn_status[s->limit_conn_status - 1].len;
    v->data = ngx_stream_limit_conn_status[s->limit_conn_status - 1].data;

    return NGX_OK;
}",1,1,stream\ngx_stream_limit_conn_module.c,ngx_stream_limit_conn_status_variable,,false,480,496,ngx_stream_limit_conn_status_variable,,,41,"ngx_int_t ngx_stream_limit_conn_status_variable (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
434804,METHOD,stream\ngx_stream_limit_conn_module.c:<global>,TYPE_DECL,"static void *
ngx_stream_limit_conn_create_conf(ngx_conf_t *cf)
{
    ngx_stream_limit_conn_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_stream_limit_conn_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     conf->limits.elts = NULL;
     */

    conf->log_level = NGX_CONF_UNSET_UINT;
    conf->dry_run = NGX_CONF_UNSET;

    return conf;
}",1,1,stream\ngx_stream_limit_conn_module.c,ngx_stream_limit_conn_create_conf,,false,499,519,ngx_stream_limit_conn_create_conf,,,42,void* ngx_stream_limit_conn_create_conf (ngx_conf_t*)
434837,METHOD,stream\ngx_stream_limit_conn_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_limit_conn_merge_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_stream_limit_conn_conf_t *prev = parent;
    ngx_stream_limit_conn_conf_t *conf = child;

    if (conf->limits.elts == NULL) {
        conf->limits = prev->limits;
    }

    ngx_conf_merge_uint_value(conf->log_level, prev->log_level, NGX_LOG_ERR);

    ngx_conf_merge_value(conf->dry_run, prev->dry_run, 0);

    return NGX_CONF_OK;
}",1,1,stream\ngx_stream_limit_conn_module.c,ngx_stream_limit_conn_merge_conf,,false,522,537,ngx_stream_limit_conn_merge_conf,,,43,"char* ngx_stream_limit_conn_merge_conf (ngx_conf_t*,void*,void*)"
434886,METHOD,stream\ngx_stream_limit_conn_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_limit_conn_zone(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    u_char                              *p;
    ssize_t                              size;
    ngx_str_t                           *value, name, s;
    ngx_uint_t                           i;
    ngx_shm_zone_t                      *shm_zone;
    ngx_stream_limit_conn_ctx_t         *ctx;
    ngx_stream_compile_complex_value_t   ccv;

    value = cf->args->elts;

    ctx = ngx_pcalloc(cf->pool, sizeof(ngx_stream_limit_conn_ctx_t));
    if (ctx == NULL) {
        return NGX_CONF_ERROR;
    }

    ngx_memzero(&ccv, sizeof(ngx_stream_compile_complex_value_t));

    ccv.cf = cf;
    ccv.value = &value[1];
    ccv.complex_value = &ctx->key;

    if (ngx_stream_compile_complex_value(&ccv) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    size = 0;
    name.len = 0;

    for (i = 2; i < cf->args->nelts; i++) {

        if (ngx_strncmp(value[i].data, ""zone="", 5) == 0) {

            name.data = va...",1,1,stream\ngx_stream_limit_conn_module.c,ngx_stream_limit_conn_zone,,false,540,638,ngx_stream_limit_conn_zone,,,44,"char* ngx_stream_limit_conn_zone (ngx_conf_t*,ngx_command_t*,void*)"
435192,METHOD,stream\ngx_stream_limit_conn_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_limit_conn(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_shm_zone_t                 *shm_zone;
    ngx_stream_limit_conn_conf_t   *lccf = conf;
    ngx_stream_limit_conn_limit_t  *limit, *limits;

    ngx_str_t   *value;
    ngx_int_t    n;
    ngx_uint_t   i;

    value = cf->args->elts;

    shm_zone = ngx_shared_memory_add(cf, &value[1], 0,
                                     &ngx_stream_limit_conn_module);
    if (shm_zone == NULL) {
        return NGX_CONF_ERROR;
    }

    limits = lccf->limits.elts;

    if (limits == NULL) {
        if (ngx_array_init(&lccf->limits, cf->pool, 1,
                           sizeof(ngx_stream_limit_conn_limit_t))
            != NGX_OK)
        {
            return NGX_CONF_ERROR;
        }
    }

    for (i = 0; i < lccf->limits.nelts; i++) {
        if (shm_zone == limits[i].shm_zone) {
            return ""is duplicate"";
        }
    }

    n = ngx_atoi(value[2].data, value[2].len);
    if (n <= 0) {
    ...",1,1,stream\ngx_stream_limit_conn_module.c,ngx_stream_limit_conn,,false,641,699,ngx_stream_limit_conn,,,45,"char* ngx_stream_limit_conn (ngx_conf_t*,ngx_command_t*,void*)"
435356,METHOD,stream\ngx_stream_limit_conn_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_limit_conn_add_variables(ngx_conf_t *cf)
{
    ngx_stream_variable_t  *var, *v;

    for (v = ngx_stream_limit_conn_vars; v->name.len; v++) {
        var = ngx_stream_add_variable(cf, &v->name, v->flags);
        if (var == NULL) {
            return NGX_ERROR;
        }

        var->get_handler = v->get_handler;
        var->data = v->data;
    }

    return NGX_OK;
}",1,1,stream\ngx_stream_limit_conn_module.c,ngx_stream_limit_conn_add_variables,,false,702,718,ngx_stream_limit_conn_add_variables,,,46,ngx_int_t ngx_stream_limit_conn_add_variables (ngx_conf_t*)
435410,METHOD,stream\ngx_stream_limit_conn_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_limit_conn_init(ngx_conf_t *cf)
{
    ngx_stream_handler_pt        *h;
    ngx_stream_core_main_conf_t  *cmcf;

    cmcf = ngx_stream_conf_get_module_main_conf(cf, ngx_stream_core_module);

    h = ngx_array_push(&cmcf->phases[NGX_STREAM_PREACCESS_PHASE].handlers);
    if (h == NULL) {
        return NGX_ERROR;
    }

    *h = ngx_stream_limit_conn_handler;

    return NGX_OK;
}",1,1,stream\ngx_stream_limit_conn_module.c,ngx_stream_limit_conn_init,,false,721,737,ngx_stream_limit_conn_init,,,47,ngx_int_t ngx_stream_limit_conn_init (ngx_conf_t*)
435457,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,<global>,1,9,stream\ngx_stream_log_module.c,stream\ngx_stream_log_module.c:<global>,,false,1,1596,<global>,,,1,
435461,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"typedef u_char *(*ngx_stream_log_op_run_pt) (ngx_stream_session_t *s,
    u_char *buf, ngx_stream_log_op_t *op);",16,41,stream\ngx_stream_log_module.c,ngx_stream_log_op_run_pt,,false,19,20,ngx_stream_log_op_run_pt,,,3,"u_char* ngx_stream_log_op_run_pt (ngx_stream_session_t*,u_char*,ngx_stream_log_op_t*)"
435468,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"typedef size_t (*ngx_stream_log_op_getlen_pt) (ngx_stream_session_t *s,
    uintptr_t data);",16,19,stream\ngx_stream_log_module.c,ngx_stream_log_op_getlen_pt,,false,22,23,ngx_stream_log_op_getlen_pt,,,4,"size_t ngx_stream_log_op_getlen_pt (ngx_stream_session_t*,uintptr_t)"
435520,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"static void ngx_stream_log_write(ngx_stream_session_t *s, ngx_stream_log_t *log,
    u_char *buf, size_t len);",13,28,stream\ngx_stream_log_module.c,ngx_stream_log_write,,false,97,98,ngx_stream_log_write,,,20,"void ngx_stream_log_write (ngx_stream_session_t*,ngx_stream_log_t*,u_char*,size_t)"
435528,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"static ssize_t ngx_stream_log_script_write(ngx_stream_session_t *s,
    ngx_stream_log_script_t *script, u_char **name, u_char *buf, size_t len);",16,76,stream\ngx_stream_log_module.c,ngx_stream_log_script_write,,false,99,100,ngx_stream_log_script_write,,,21,"ssize_t ngx_stream_log_script_write (ngx_stream_session_t*,ngx_stream_log_script_t*,u_char**,u_char*,size_t)"
435537,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"static void ngx_stream_log_flush(ngx_open_file_t *file, ngx_log_t *log);",13,71,stream\ngx_stream_log_module.c,ngx_stream_log_flush,,false,110,110,ngx_stream_log_flush,,,22,"void ngx_stream_log_flush (ngx_open_file_t*,ngx_log_t*)"
435543,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,static void ngx_stream_log_flush_handler(ngx_event_t *ev);,13,57,stream\ngx_stream_log_module.c,ngx_stream_log_flush_handler,,false,111,111,ngx_stream_log_flush_handler,,,23,void ngx_stream_log_flush_handler (ngx_event_t*)
435548,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_log_variable_compile(ngx_conf_t *cf,
    ngx_stream_log_op_t *op, ngx_str_t *value, ngx_uint_t escape);",18,65,stream\ngx_stream_log_module.c,ngx_stream_log_variable_compile,,false,113,114,ngx_stream_log_variable_compile,,,24,"ngx_int_t ngx_stream_log_variable_compile (ngx_conf_t*,ngx_stream_log_op_t*,ngx_str_t*,ngx_uint_t)"
435556,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"static size_t ngx_stream_log_variable_getlen(ngx_stream_session_t *s,
    uintptr_t data);",15,19,stream\ngx_stream_log_module.c,ngx_stream_log_variable_getlen,,false,115,116,ngx_stream_log_variable_getlen,,,25,"size_t ngx_stream_log_variable_getlen (ngx_stream_session_t*,uintptr_t)"
435562,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"static u_char *ngx_stream_log_variable(ngx_stream_session_t *s, u_char *buf,
    ngx_stream_log_op_t *op);",15,28,stream\ngx_stream_log_module.c,ngx_stream_log_variable,,false,117,118,ngx_stream_log_variable,,,26,"u_char* ngx_stream_log_variable (ngx_stream_session_t*,u_char*,ngx_stream_log_op_t*)"
435569,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"static uintptr_t ngx_stream_log_escape(u_char *dst, u_char *src, size_t size);",18,77,stream\ngx_stream_log_module.c,ngx_stream_log_escape,,false,119,119,ngx_stream_log_escape,,,27,"uintptr_t ngx_stream_log_escape (u_char*,u_char*,size_t)"
435576,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"static size_t ngx_stream_log_json_variable_getlen(ngx_stream_session_t *s,
    uintptr_t data);",15,19,stream\ngx_stream_log_module.c,ngx_stream_log_json_variable_getlen,,false,120,121,ngx_stream_log_json_variable_getlen,,,28,"size_t ngx_stream_log_json_variable_getlen (ngx_stream_session_t*,uintptr_t)"
435582,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"static u_char *ngx_stream_log_json_variable(ngx_stream_session_t *s,
    u_char *buf, ngx_stream_log_op_t *op);",15,41,stream\ngx_stream_log_module.c,ngx_stream_log_json_variable,,false,122,123,ngx_stream_log_json_variable,,,29,"u_char* ngx_stream_log_json_variable (ngx_stream_session_t*,u_char*,ngx_stream_log_op_t*)"
435589,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"static size_t ngx_stream_log_unescaped_variable_getlen(ngx_stream_session_t *s,
    uintptr_t data);",15,19,stream\ngx_stream_log_module.c,ngx_stream_log_unescaped_variable_getlen,,false,124,125,ngx_stream_log_unescaped_variable_getlen,,,30,"size_t ngx_stream_log_unescaped_variable_getlen (ngx_stream_session_t*,uintptr_t)"
435595,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"static u_char *ngx_stream_log_unescaped_variable(ngx_stream_session_t *s,
    u_char *buf, ngx_stream_log_op_t *op);",15,41,stream\ngx_stream_log_module.c,ngx_stream_log_unescaped_variable,,false,126,127,ngx_stream_log_unescaped_variable,,,31,"u_char* ngx_stream_log_unescaped_variable (ngx_stream_session_t*,u_char*,ngx_stream_log_op_t*)"
435602,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,static void *ngx_stream_log_create_main_conf(ngx_conf_t *cf);,13,60,stream\ngx_stream_log_module.c,ngx_stream_log_create_main_conf,,false,130,130,ngx_stream_log_create_main_conf,,,32,void* ngx_stream_log_create_main_conf (ngx_conf_t*)
435607,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,static void *ngx_stream_log_create_srv_conf(ngx_conf_t *cf);,13,59,stream\ngx_stream_log_module.c,ngx_stream_log_create_srv_conf,,false,131,131,ngx_stream_log_create_srv_conf,,,33,void* ngx_stream_log_create_srv_conf (ngx_conf_t*)
435612,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"static char *ngx_stream_log_merge_srv_conf(ngx_conf_t *cf, void *parent,
    void *child);",13,16,stream\ngx_stream_log_module.c,ngx_stream_log_merge_srv_conf,,false,132,133,ngx_stream_log_merge_srv_conf,,,34,"char* ngx_stream_log_merge_srv_conf (ngx_conf_t*,void*,void*)"
435619,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"static char *ngx_stream_log_set_log(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,stream\ngx_stream_log_module.c,ngx_stream_log_set_log,,false,134,135,ngx_stream_log_set_log,,,35,"char* ngx_stream_log_set_log (ngx_conf_t*,ngx_command_t*,void*)"
435626,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"static char *ngx_stream_log_set_format(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,stream\ngx_stream_log_module.c,ngx_stream_log_set_format,,false,136,137,ngx_stream_log_set_format,,,36,"char* ngx_stream_log_set_format (ngx_conf_t*,ngx_command_t*,void*)"
435633,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"static char *ngx_stream_log_compile_format(ngx_conf_t *cf,
    ngx_array_t *flushes, ngx_array_t *ops, ngx_array_t *args, ngx_uint_t s);",13,76,stream\ngx_stream_log_module.c,ngx_stream_log_compile_format,,false,138,139,ngx_stream_log_compile_format,,,37,"char* ngx_stream_log_compile_format (ngx_conf_t*,ngx_array_t*,ngx_array_t*,ngx_array_t*,ngx_uint_t)"
435642,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"static char *ngx_stream_log_open_file_cache(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,stream\ngx_stream_log_module.c,ngx_stream_log_open_file_cache,,false,140,141,ngx_stream_log_open_file_cache,,,38,"char* ngx_stream_log_open_file_cache (ngx_conf_t*,ngx_command_t*,void*)"
435649,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_stream_log_init(ngx_conf_t *cf);,18,52,stream\ngx_stream_log_module.c,ngx_stream_log_init,,false,142,142,ngx_stream_log_init,,,39,ngx_int_t ngx_stream_log_init (ngx_conf_t*)
435720,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_log_handler(ngx_stream_session_t *s)
{
    u_char                     *line, *p;
    size_t                      len, size;
    ssize_t                     n;
    ngx_str_t                   val;
    ngx_uint_t                  i, l;
    ngx_stream_log_t           *log;
    ngx_stream_log_op_t        *op;
    ngx_stream_log_buf_t       *buffer;
    ngx_stream_log_srv_conf_t  *lscf;

    ngx_log_debug0(NGX_LOG_DEBUG_STREAM, s->connection->log, 0,
                   ""stream log handler"");

    lscf = ngx_stream_get_module_srv_conf(s, ngx_stream_log_module);

    if (lscf->off || lscf->logs == NULL) {
        return NGX_OK;
    }

    log = lscf->logs->elts;
    for (l = 0; l < lscf->logs->nelts; l++) {

        if (log[l].filter) {
            if (ngx_stream_complex_value(s, log[l].filter, &val) != NGX_OK) {
                return NGX_ERROR;
            }

            if (val.len == 0 || (val.len == 1 && val.data[0] == '0')) {
                continue;
    ...",1,1,stream\ngx_stream_log_module.c,ngx_stream_log_handler,,false,200,350,ngx_stream_log_handler,,,46,ngx_int_t ngx_stream_log_handler (ngx_stream_session_t*)
436236,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"static void
ngx_stream_log_write(ngx_stream_session_t *s, ngx_stream_log_t *log,
    u_char *buf, size_t len)
{
    u_char                *name;
    time_t                 now;
    ssize_t                n;
    ngx_err_t              err;
#if (NGX_ZLIB)
    ngx_stream_log_buf_t  *buffer;
#endif

    if (log->script == NULL) {
        name = log->file->name.data;

#if (NGX_ZLIB)
        buffer = log->file->data;

        if (buffer && buffer->gzip) {
            n = ngx_stream_log_gzip(log->file->fd, buf, len, buffer->gzip,
                                    s->connection->log);
        } else {
            n = ngx_write_fd(log->file->fd, buf, len);
        }
#else
        n = ngx_write_fd(log->file->fd, buf, len);
#endif

    } else {
        name = NULL;
        n = ngx_stream_log_script_write(s, log->script, &name, buf, len);
    }

    if (n == (ssize_t) len) {
        return;
    }

    now = ngx_time();

    if (n == -1) {
        err = ngx_errno;

        if (err == NGX_ENOSP...",1,1,stream\ngx_stream_log_module.c,ngx_stream_log_write,,false,353,416,ngx_stream_log_write,,,47,"void ngx_stream_log_write (ngx_stream_session_t*,ngx_stream_log_t*,u_char*,size_t)"
436351,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"static ssize_t
ngx_stream_log_script_write(ngx_stream_session_t *s,
    ngx_stream_log_script_t *script, u_char **name, u_char *buf, size_t len)
{
    ssize_t                     n;
    ngx_str_t                   log;
    ngx_open_file_info_t        of;
    ngx_stream_log_srv_conf_t  *lscf;

    if (ngx_stream_script_run(s, &log, script->lengths->elts, 1,
                              script->values->elts)
        == NULL)
    {
        /* simulate successful logging */
        return len;
    }

    log.data[log.len - 1] = '\0';
    *name = log.data;

    ngx_log_debug1(NGX_LOG_DEBUG_STREAM, s->connection->log, 0,
                   ""stream log \""%s\"""", log.data);

    lscf = ngx_stream_get_module_srv_conf(s, ngx_stream_log_module);

    ngx_memzero(&of, sizeof(ngx_open_file_info_t));

    of.log = 1;
    of.valid = lscf->open_file_cache_valid;
    of.min_uses = lscf->open_file_cache_min_uses;
    of.directio = NGX_OPEN_FILE_DIRECTIO_OFF;

    if (ngx_open_cached_file(lscf->open_f...",1,1,stream\ngx_stream_log_module.c,ngx_stream_log_script_write,,false,419,472,ngx_stream_log_script_write,,,48,"ssize_t ngx_stream_log_script_write (ngx_stream_session_t*,ngx_stream_log_script_t*,u_char**,u_char*,size_t)"
436513,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"static void
ngx_stream_log_flush(ngx_open_file_t *file, ngx_log_t *log)
{
    size_t                 len;
    ssize_t                n;
    ngx_stream_log_buf_t  *buffer;

    buffer = file->data;

    len = buffer->pos - buffer->start;

    if (len == 0) {
        return;
    }

#if (NGX_ZLIB)
    if (buffer->gzip) {
        n = ngx_stream_log_gzip(file->fd, buffer->start, len, buffer->gzip,
                                log);
    } else {
        n = ngx_write_fd(file->fd, buffer->start, len);
    }
#else
    n = ngx_write_fd(file->fd, buffer->start, len);
#endif

    if (n == -1) {
        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,
                      ngx_write_fd_n "" to \""%s\"" failed"",
                      file->name.data);

    } else if ((size_t) n != len) {
        ngx_log_error(NGX_LOG_ALERT, log, 0,
                      ngx_write_fd_n "" to \""%s\"" was incomplete: %z of %uz"",
                      file->name.data, n, len);
    }

    buffer->pos = buffer->start;

    ...",1,1,stream\ngx_stream_log_module.c,ngx_stream_log_flush,,false,610,652,ngx_stream_log_flush,,,49,"void ngx_stream_log_flush (ngx_open_file_t*,ngx_log_t*)"
436591,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"static void
ngx_stream_log_flush_handler(ngx_event_t *ev)
{
    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, ev->log, 0,
                   ""stream log buffer flush handler"");

    ngx_stream_log_flush(ev->data, ev->log);
}",1,1,stream\ngx_stream_log_module.c,ngx_stream_log_flush_handler,,false,655,662,ngx_stream_log_flush_handler,,,50,void ngx_stream_log_flush_handler (ngx_event_t*)
436610,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"static u_char *
ngx_stream_log_copy_short(ngx_stream_session_t *s, u_char *buf,
    ngx_stream_log_op_t *op)
{
    size_t     len;
    uintptr_t  data;

    len = op->len;
    data = op->data;

    while (len--) {
        *buf++ = (u_char) (data & 0xff);
        data >>= 8;
    }

    return buf;
}",1,1,stream\ngx_stream_log_module.c,ngx_stream_log_copy_short,,false,665,681,ngx_stream_log_copy_short,,,51,"u_char ngx_stream_log_copy_short (ngx_stream_session_t*,u_char*,ngx_stream_log_op_t*)"
436646,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"static u_char *
ngx_stream_log_copy_long(ngx_stream_session_t *s, u_char *buf,
    ngx_stream_log_op_t *op)
{
    return ngx_cpymem(buf, (u_char *) op->data, op->len);
}",1,1,stream\ngx_stream_log_module.c,ngx_stream_log_copy_long,,false,684,689,ngx_stream_log_copy_long,,,52,"u_char ngx_stream_log_copy_long (ngx_stream_session_t*,u_char*,ngx_stream_log_op_t*)"
436664,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_log_variable_compile(ngx_conf_t *cf, ngx_stream_log_op_t *op,
    ngx_str_t *value, ngx_uint_t escape)
{
    ngx_int_t  index;

    index = ngx_stream_get_variable_index(cf, value);
    if (index == NGX_ERROR) {
        return NGX_ERROR;
    }

    op->len = 0;

    switch (escape) {
    case NGX_STREAM_LOG_ESCAPE_JSON:
        op->getlen = ngx_stream_log_json_variable_getlen;
        op->run = ngx_stream_log_json_variable;
        break;

    case NGX_STREAM_LOG_ESCAPE_NONE:
        op->getlen = ngx_stream_log_unescaped_variable_getlen;
        op->run = ngx_stream_log_unescaped_variable;
        break;

    default: /* NGX_STREAM_LOG_ESCAPE_DEFAULT */
        op->getlen = ngx_stream_log_variable_getlen;
        op->run = ngx_stream_log_variable;
    }

    op->data = index;

    return NGX_OK;
}",1,9,stream\ngx_stream_log_module.c,ngx_stream_log_variable_compile,,false,692,724,ngx_stream_log_variable_compile,,,53,"ngx_int_t ngx_stream_log_variable_compile (ngx_conf_t*,ngx_stream_log_op_t*,ngx_str_t*,ngx_uint_t)"
436741,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"static size_t
ngx_stream_log_variable_getlen(ngx_stream_session_t *s, uintptr_t data)
{
    uintptr_t                     len;
    ngx_stream_variable_value_t  *value;

    value = ngx_stream_get_indexed_variable(s, data);

    if (value == NULL || value->not_found) {
        return 1;
    }

    len = ngx_stream_log_escape(NULL, value->data, value->len);

    value->escape = len ? 1 : 0;

    return value->len + len * 3;
}",1,1,stream\ngx_stream_log_module.c,ngx_stream_log_variable_getlen,,false,727,744,ngx_stream_log_variable_getlen,,,54,"size_t ngx_stream_log_variable_getlen (ngx_stream_session_t*,uintptr_t)"
436791,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"static u_char *
ngx_stream_log_variable(ngx_stream_session_t *s, u_char *buf,
    ngx_stream_log_op_t *op)
{
    ngx_stream_variable_value_t  *value;

    value = ngx_stream_get_indexed_variable(s, op->data);

    if (value == NULL || value->not_found) {
        *buf = '-';
        return buf + 1;
    }

    if (value->escape == 0) {
        return ngx_cpymem(buf, value->data, value->len);

    } else {
        return (u_char *) ngx_stream_log_escape(buf, value->data, value->len);
    }
}",1,1,stream\ngx_stream_log_module.c,ngx_stream_log_variable,,false,747,766,ngx_stream_log_variable,,,55,"u_char ngx_stream_log_variable (ngx_stream_session_t*,u_char*,ngx_stream_log_op_t*)"
436852,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"static uintptr_t
ngx_stream_log_escape(u_char *dst, u_char *src, size_t size)
{
    ngx_uint_t      n;
    static u_char   hex[] = ""0123456789ABCDEF"";

    static uint32_t   escape[] = {
        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */

                    /* ?>=< ;:98 7654 3210  /.-, +*)( '&%$ #""!  */
        0x00000004, /* 0000 0000 0000 0000  0000 0000 0000 0100 */

                    /* _^]\ [ZYX WVUT SRQP  ONML KJIH GFED CBA@ */
        0x10000000, /* 0001 0000 0000 0000  0000 0000 0000 0000 */

                    /*  ~}| {zyx wvut srqp  onml kjih gfed cba` */
        0x80000000, /* 1000 0000 0000 0000  0000 0000 0000 0000 */

        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */
        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */
        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */
        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */
    };


    if (dst == NULL) {

        /* find the number of the ch...",1,1,stream\ngx_stream_log_module.c,ngx_stream_log_escape,,false,769,826,ngx_stream_log_escape,,,56,"uintptr_t ngx_stream_log_escape (u_char*,u_char*,size_t)"
436977,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"static size_t
ngx_stream_log_json_variable_getlen(ngx_stream_session_t *s, uintptr_t data)
{
    uintptr_t                     len;
    ngx_stream_variable_value_t  *value;

    value = ngx_stream_get_indexed_variable(s, data);

    if (value == NULL || value->not_found) {
        return 0;
    }

    len = ngx_escape_json(NULL, value->data, value->len);

    value->escape = len ? 1 : 0;

    return value->len + len;
}",1,1,stream\ngx_stream_log_module.c,ngx_stream_log_json_variable_getlen,,false,829,846,ngx_stream_log_json_variable_getlen,,,57,"size_t ngx_stream_log_json_variable_getlen (ngx_stream_session_t*,uintptr_t)"
437025,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"static u_char *
ngx_stream_log_json_variable(ngx_stream_session_t *s, u_char *buf,
    ngx_stream_log_op_t *op)
{
    ngx_stream_variable_value_t  *value;

    value = ngx_stream_get_indexed_variable(s, op->data);

    if (value == NULL || value->not_found) {
        return buf;
    }

    if (value->escape == 0) {
        return ngx_cpymem(buf, value->data, value->len);

    } else {
        return (u_char *) ngx_escape_json(buf, value->data, value->len);
    }
}",1,1,stream\ngx_stream_log_module.c,ngx_stream_log_json_variable,,false,849,867,ngx_stream_log_json_variable,,,58,"u_char ngx_stream_log_json_variable (ngx_stream_session_t*,u_char*,ngx_stream_log_op_t*)"
437080,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"static size_t
ngx_stream_log_unescaped_variable_getlen(ngx_stream_session_t *s,
    uintptr_t data)
{
    ngx_stream_variable_value_t  *value;

    value = ngx_stream_get_indexed_variable(s, data);

    if (value == NULL || value->not_found) {
        return 0;
    }

    value->escape = 0;

    return value->len;
}",1,1,stream\ngx_stream_log_module.c,ngx_stream_log_unescaped_variable_getlen,,false,870,885,ngx_stream_log_unescaped_variable_getlen,,,59,"size_t ngx_stream_log_unescaped_variable_getlen (ngx_stream_session_t*,uintptr_t)"
437112,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"static u_char *
ngx_stream_log_unescaped_variable(ngx_stream_session_t *s, u_char *buf,
                                  ngx_stream_log_op_t *op)
{
    ngx_stream_variable_value_t  *value;

    value = ngx_stream_get_indexed_variable(s, op->data);

    if (value == NULL || value->not_found) {
        return buf;
    }

    return ngx_cpymem(buf, value->data, value->len);
}",1,1,stream\ngx_stream_log_module.c,ngx_stream_log_unescaped_variable,,false,888,901,ngx_stream_log_unescaped_variable,,,60,"u_char ngx_stream_log_unescaped_variable (ngx_stream_session_t*,u_char*,ngx_stream_log_op_t*)"
437147,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"static void *
ngx_stream_log_create_main_conf(ngx_conf_t *cf)
{
    ngx_stream_log_main_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_stream_log_main_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    if (ngx_array_init(&conf->formats, cf->pool, 4,
                       sizeof(ngx_stream_log_fmt_t))
        != NGX_OK)
    {
        return NULL;
    }

    return conf;
}",1,1,stream\ngx_stream_log_module.c,ngx_stream_log_create_main_conf,,false,904,922,ngx_stream_log_create_main_conf,,,61,void* ngx_stream_log_create_main_conf (ngx_conf_t*)
437187,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"static void *
ngx_stream_log_create_srv_conf(ngx_conf_t *cf)
{
    ngx_stream_log_srv_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_stream_log_srv_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    conf->open_file_cache = NGX_CONF_UNSET_PTR;

    return conf;
}",1,1,stream\ngx_stream_log_module.c,ngx_stream_log_create_srv_conf,,false,925,938,ngx_stream_log_create_srv_conf,,,62,void* ngx_stream_log_create_srv_conf (ngx_conf_t*)
437215,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_log_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_stream_log_srv_conf_t *prev = parent;
    ngx_stream_log_srv_conf_t *conf = child;

    if (conf->open_file_cache == NGX_CONF_UNSET_PTR) {

        conf->open_file_cache = prev->open_file_cache;
        conf->open_file_cache_valid = prev->open_file_cache_valid;
        conf->open_file_cache_min_uses = prev->open_file_cache_min_uses;

        if (conf->open_file_cache == NGX_CONF_UNSET_PTR) {
            conf->open_file_cache = NULL;
        }
    }

    if (conf->logs || conf->off) {
        return NGX_CONF_OK;
    }

    conf->logs = prev->logs;
    conf->off = prev->off;

    return NGX_CONF_OK;
}",1,1,stream\ngx_stream_log_module.c,ngx_stream_log_merge_srv_conf,,false,941,966,ngx_stream_log_merge_srv_conf,,,63,"char* ngx_stream_log_merge_srv_conf (ngx_conf_t*,void*,void*)"
437297,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_log_set_log(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_stream_log_srv_conf_t *lscf = conf;

    ssize_t                              size;
    ngx_int_t                            gzip;
    ngx_uint_t                           i, n;
    ngx_msec_t                           flush;
    ngx_str_t                           *value, name, s;
    ngx_stream_log_t                    *log;
    ngx_syslog_peer_t                   *peer;
    ngx_stream_log_buf_t                *buffer;
    ngx_stream_log_fmt_t                *fmt;
    ngx_stream_script_compile_t          sc;
    ngx_stream_log_main_conf_t          *lmcf;
    ngx_stream_compile_complex_value_t   ccv;

    value = cf->args->elts;

    if (ngx_strcmp(value[1].data, ""off"") == 0) {
        lscf->off = 1;
        if (cf->args->nelts == 2) {
            return NGX_CONF_OK;
        }

        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""invalid parameter \""%V\"""", &value[2...",1,1,stream\ngx_stream_log_module.c,ngx_stream_log_set_log,,false,969,1262,ngx_stream_log_set_log,,,64,"char* ngx_stream_log_set_log (ngx_conf_t*,ngx_command_t*,void*)"
438192,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_log_set_format(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_stream_log_main_conf_t *lmcf = conf;

    ngx_str_t             *value;
    ngx_uint_t             i;
    ngx_stream_log_fmt_t  *fmt;

    value = cf->args->elts;

    fmt = lmcf->formats.elts;
    for (i = 0; i < lmcf->formats.nelts; i++) {
        if (fmt[i].name.len == value[1].len
            && ngx_strcmp(fmt[i].name.data, value[1].data) == 0)
        {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               ""duplicate \""log_format\"" name \""%V\"""",
                               &value[1]);
            return NGX_CONF_ERROR;
        }
    }

    fmt = ngx_array_push(&lmcf->formats);
    if (fmt == NULL) {
        return NGX_CONF_ERROR;
    }

    fmt->name = value[1];

    fmt->flushes = ngx_array_create(cf->pool, 4, sizeof(ngx_int_t));
    if (fmt->flushes == NULL) {
        return NGX_CONF_ERROR;
    }

    fmt->ops = ngx_array_create(cf->pool, 16, size...",1,1,stream\ngx_stream_log_module.c,ngx_stream_log_set_format,,false,1265,1307,ngx_stream_log_set_format,,,65,"char* ngx_stream_log_set_format (ngx_conf_t*,ngx_command_t*,void*)"
438351,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_log_compile_format(ngx_conf_t *cf, ngx_array_t *flushes,
    ngx_array_t *ops, ngx_array_t *args, ngx_uint_t s)
{
    u_char                *data, *p, ch;
    size_t                 i, len;
    ngx_str_t             *value, var;
    ngx_int_t             *flush;
    ngx_uint_t             bracket, escape;
    ngx_stream_log_op_t   *op;

    escape = NGX_STREAM_LOG_ESCAPE_DEFAULT;
    value = args->elts;

    if (s < args->nelts && ngx_strncmp(value[s].data, ""escape="", 7) == 0) {
        data = value[s].data + 7;

        if (ngx_strcmp(data, ""json"") == 0) {
            escape = NGX_STREAM_LOG_ESCAPE_JSON;

        } else if (ngx_strcmp(data, ""none"") == 0) {
            escape = NGX_STREAM_LOG_ESCAPE_NONE;

        } else if (ngx_strcmp(data, ""default"") != 0) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               ""unknown log format escaping \""%s\"""", data);
            return NGX_CONF_ERROR;
        }

        s++;
    }

    fo...",1,13,stream\ngx_stream_log_module.c,ngx_stream_log_compile_format,,false,1310,1469,ngx_stream_log_compile_format,,,66,"char* ngx_stream_log_compile_format (ngx_conf_t*,ngx_array_t*,ngx_array_t*,ngx_array_t*,ngx_uint_t)"
438823,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_log_open_file_cache(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_stream_log_srv_conf_t *lscf = conf;

    time_t       inactive, valid;
    ngx_str_t   *value, s;
    ngx_int_t    max, min_uses;
    ngx_uint_t   i;

    if (lscf->open_file_cache != NGX_CONF_UNSET_PTR) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    max = 0;
    inactive = 10;
    valid = 60;
    min_uses = 1;

    for (i = 1; i < cf->args->nelts; i++) {

        if (ngx_strncmp(value[i].data, ""max="", 4) == 0) {

            max = ngx_atoi(value[i].data + 4, value[i].len - 4);
            if (max == NGX_ERROR) {
                goto failed;
            }

            continue;
        }

        if (ngx_strncmp(value[i].data, ""inactive="", 9) == 0) {

            s.len = value[i].len - 9;
            s.data = value[i].data + 9;

            inactive = ngx_parse_time(&s, 1);
            if (inactive == (time_t) NGX_ERROR) {
                goto failed;
    ...",1,1,stream\ngx_stream_log_module.c,ngx_stream_log_open_file_cache,,false,1472,1577,ngx_stream_log_open_file_cache,,,67,"char* ngx_stream_log_open_file_cache (ngx_conf_t*,ngx_command_t*,void*)"
439133,METHOD,stream\ngx_stream_log_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_log_init(ngx_conf_t *cf)
{
    ngx_stream_handler_pt        *h;
    ngx_stream_core_main_conf_t  *cmcf;

    cmcf = ngx_stream_conf_get_module_main_conf(cf, ngx_stream_core_module);

    h = ngx_array_push(&cmcf->phases[NGX_STREAM_LOG_PHASE].handlers);
    if (h == NULL) {
        return NGX_ERROR;
    }

    *h = ngx_stream_log_handler;

    return NGX_OK;
}",1,1,stream\ngx_stream_log_module.c,ngx_stream_log_init,,false,1580,1596,ngx_stream_log_init,,,68,ngx_int_t ngx_stream_log_init (ngx_conf_t*)
439178,METHOD,stream\ngx_stream_map_module.c:<global>,TYPE_DECL,<global>,1,1,stream\ngx_stream_map_module.c,stream\ngx_stream_map_module.c:<global>,,false,1,588,<global>,,,1,
439200,METHOD,stream\ngx_stream_map_module.c:<global>,TYPE_DECL,static void *ngx_stream_map_create_conf(ngx_conf_t *cf);,13,55,stream\ngx_stream_map_module.c,ngx_stream_map_create_conf,,false,44,44,ngx_stream_map_create_conf,,,8,void* ngx_stream_map_create_conf (ngx_conf_t*)
439205,METHOD,stream\ngx_stream_map_module.c:<global>,TYPE_DECL,"static char *ngx_stream_map_block(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,stream\ngx_stream_map_module.c,ngx_stream_map_block,,false,45,46,ngx_stream_map_block,,,9,"char* ngx_stream_map_block (ngx_conf_t*,ngx_command_t*,void*)"
439212,METHOD,stream\ngx_stream_map_module.c:<global>,TYPE_DECL,"static char *ngx_stream_map(ngx_conf_t *cf, ngx_command_t *dummy, void *conf);",13,77,stream\ngx_stream_map_module.c,ngx_stream_map,,false,47,47,ngx_stream_map,,,10,"char* ngx_stream_map (ngx_conf_t*,ngx_command_t*,void*)"
439287,METHOD,stream\ngx_stream_map_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_map_variable(ngx_stream_session_t *s, ngx_stream_variable_value_t *v,
    uintptr_t data)
{
    ngx_stream_map_ctx_t  *map = (ngx_stream_map_ctx_t *) data;

    ngx_str_t                     val, str;
    ngx_stream_complex_value_t   *cv;
    ngx_stream_variable_value_t  *value;

    ngx_log_debug0(NGX_LOG_DEBUG_STREAM, s->connection->log, 0,
                   ""stream map started"");

    if (ngx_stream_complex_value(s, &map->value, &val) != NGX_OK) {
        return NGX_ERROR;
    }

    if (map->hostnames && val.len > 0 && val.data[val.len - 1] == '.') {
        val.len--;
    }

    value = ngx_stream_map_find(s, &map->map, &val);

    if (value == NULL) {
        value = map->default_value;
    }

    if (!value->valid) {
        cv = (ngx_stream_complex_value_t *) value->data;

        if (ngx_stream_complex_value(s, cv, &str) != NGX_OK) {
            return NGX_ERROR;
        }

        v->valid = 1;
        v->no_cacheable = 0;
        v->not_found ...",1,1,stream\ngx_stream_map_module.c,ngx_stream_map_variable,,false,105,153,ngx_stream_map_variable,,,17,"ngx_int_t ngx_stream_map_variable (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
439448,METHOD,stream\ngx_stream_map_module.c:<global>,TYPE_DECL,"static void *
ngx_stream_map_create_conf(ngx_conf_t *cf)
{
    ngx_stream_map_conf_t  *mcf;

    mcf = ngx_palloc(cf->pool, sizeof(ngx_stream_map_conf_t));
    if (mcf == NULL) {
        return NULL;
    }

    mcf->hash_max_size = NGX_CONF_UNSET_UINT;
    mcf->hash_bucket_size = NGX_CONF_UNSET_UINT;

    return mcf;
}",1,1,stream\ngx_stream_map_module.c,ngx_stream_map_create_conf,,false,156,170,ngx_stream_map_create_conf,,,18,void* ngx_stream_map_create_conf (ngx_conf_t*)
439481,METHOD,stream\ngx_stream_map_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_map_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_stream_map_conf_t  *mcf = conf;

    char                                *rv;
    ngx_str_t                           *value, name;
    ngx_conf_t                           save;
    ngx_pool_t                          *pool;
    ngx_hash_init_t                      hash;
    ngx_stream_map_ctx_t                *map;
    ngx_stream_variable_t               *var;
    ngx_stream_map_conf_ctx_t            ctx;
    ngx_stream_compile_complex_value_t   ccv;

    if (mcf->hash_max_size == NGX_CONF_UNSET_UINT) {
        mcf->hash_max_size = 2048;
    }

    if (mcf->hash_bucket_size == NGX_CONF_UNSET_UINT) {
        mcf->hash_bucket_size = ngx_cacheline_size;

    } else {
        mcf->hash_bucket_size = ngx_align(mcf->hash_bucket_size,
                                          ngx_cacheline_size);
    }

    map = ngx_pcalloc(cf->pool, sizeof(ngx_stream_map_ctx_t));
    if (map == NULL) {
        ...",1,1,stream\ngx_stream_map_module.c,ngx_stream_map_block,,false,173,364,ngx_stream_map_block,,,19,"char* ngx_stream_map_block (ngx_conf_t*,ngx_command_t*,void*)"
440056,METHOD,stream\ngx_stream_map_module.c:<global>,TYPE_DECL,"ngx_stream_map_cmp_dns_wildcards(const void *one, const void *two)
{
    ngx_hash_key_t  *first, *second;

    first = (ngx_hash_key_t *) one;
    second = (ngx_hash_key_t *) two;

    return ngx_dns_strcmp(first->key.data, second->key.data);
}",1,1,stream\ngx_stream_map_module.c,ngx_stream_map_cmp_dns_wildcards,,false,368,376,ngx_stream_map_cmp_dns_wildcards,,,22,"ANY ngx_stream_map_cmp_dns_wildcards (void*,void*)"
440086,METHOD,stream\ngx_stream_map_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_map(ngx_conf_t *cf, ngx_command_t *dummy, void *conf)
{
    u_char                              *data;
    size_t                               len;
    ngx_int_t                            rv;
    ngx_str_t                           *value, v;
    ngx_uint_t                           i, key;
    ngx_stream_map_conf_ctx_t           *ctx;
    ngx_stream_complex_value_t           cv, *cvp;
    ngx_stream_variable_value_t         *var, **vp;
    ngx_stream_compile_complex_value_t   ccv;

    ctx = cf->ctx;

    value = cf->args->elts;

    if (cf->args->nelts == 1
        && ngx_strcmp(value[0].data, ""hostnames"") == 0)
    {
        ctx->hostnames = 1;
        return NGX_CONF_OK;
    }

    if (cf->args->nelts == 1
        && ngx_strcmp(value[0].data, ""volatile"") == 0)
    {
        ctx->no_cacheable = 1;
        return NGX_CONF_OK;
    }

    if (cf->args->nelts != 2) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""invalid number...",1,1,stream\ngx_stream_map_module.c,ngx_stream_map,,false,379,588,ngx_stream_map,,,23,"char* ngx_stream_map (ngx_conf_t*,ngx_command_t*,void*)"
440664,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,<global>,1,1,stream\ngx_stream_proxy_module.c,stream\ngx_stream_proxy_module.c:<global>,,false,1,2317,<global>,,,1,
440702,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,static void ngx_stream_proxy_handler(ngx_stream_session_t *s);,13,61,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_handler,,false,61,61,ngx_stream_proxy_handler,,,5,void ngx_stream_proxy_handler (ngx_stream_session_t*)
440707,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_proxy_eval(ngx_stream_session_t *s,
    ngx_stream_proxy_srv_conf_t *pscf);",18,38,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_eval,,false,62,63,ngx_stream_proxy_eval,,,6,"ngx_int_t ngx_stream_proxy_eval (ngx_stream_session_t*,ngx_stream_proxy_srv_conf_t*)"
440713,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_proxy_set_local(ngx_stream_session_t *s,
    ngx_stream_upstream_t *u, ngx_stream_upstream_local_t *local);",18,65,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_set_local,,false,64,65,ngx_stream_proxy_set_local,,,7,"ngx_int_t ngx_stream_proxy_set_local (ngx_stream_session_t*,ngx_stream_upstream_t*,ngx_stream_upstream_local_t*)"
440720,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,static void ngx_stream_proxy_connect(ngx_stream_session_t *s);,13,61,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_connect,,false,66,66,ngx_stream_proxy_connect,,,8,void ngx_stream_proxy_connect (ngx_stream_session_t*)
440725,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,static void ngx_stream_proxy_init_upstream(ngx_stream_session_t *s);,13,67,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_init_upstream,,false,67,67,ngx_stream_proxy_init_upstream,,,9,void ngx_stream_proxy_init_upstream (ngx_stream_session_t*)
440730,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,static void ngx_stream_proxy_resolve_handler(ngx_resolver_ctx_t *ctx);,13,69,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_resolve_handler,,false,68,68,ngx_stream_proxy_resolve_handler,,,10,void ngx_stream_proxy_resolve_handler (ngx_resolver_ctx_t*)
440735,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,static void ngx_stream_proxy_upstream_handler(ngx_event_t *ev);,13,62,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_upstream_handler,,false,69,69,ngx_stream_proxy_upstream_handler,,,11,void ngx_stream_proxy_upstream_handler (ngx_event_t*)
440740,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,static void ngx_stream_proxy_downstream_handler(ngx_event_t *ev);,13,64,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_downstream_handler,,false,70,70,ngx_stream_proxy_downstream_handler,,,12,void ngx_stream_proxy_downstream_handler (ngx_event_t*)
440745,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,"static void ngx_stream_proxy_process_connection(ngx_event_t *ev,
    ngx_uint_t from_upstream);",13,29,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_process_connection,,false,71,72,ngx_stream_proxy_process_connection,,,13,"void ngx_stream_proxy_process_connection (ngx_event_t*,ngx_uint_t)"
440751,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,static void ngx_stream_proxy_connect_handler(ngx_event_t *ev);,13,61,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_connect_handler,,false,73,73,ngx_stream_proxy_connect_handler,,,14,void ngx_stream_proxy_connect_handler (ngx_event_t*)
440756,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_stream_proxy_test_connect(ngx_connection_t *c);,18,67,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_test_connect,,false,74,74,ngx_stream_proxy_test_connect,,,15,ngx_int_t ngx_stream_proxy_test_connect (ngx_connection_t*)
440761,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,"static void ngx_stream_proxy_process(ngx_stream_session_t *s,
    ngx_uint_t from_upstream, ngx_uint_t do_write);",13,50,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_process,,false,75,76,ngx_stream_proxy_process,,,16,"void ngx_stream_proxy_process (ngx_stream_session_t*,ngx_uint_t,ngx_uint_t)"
440768,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_proxy_test_finalize(ngx_stream_session_t *s,
    ngx_uint_t from_upstream);",18,29,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_test_finalize,,false,77,78,ngx_stream_proxy_test_finalize,,,17,"ngx_int_t ngx_stream_proxy_test_finalize (ngx_stream_session_t*,ngx_uint_t)"
440774,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,static void ngx_stream_proxy_next_upstream(ngx_stream_session_t *s);,13,67,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_next_upstream,,false,79,79,ngx_stream_proxy_next_upstream,,,18,void ngx_stream_proxy_next_upstream (ngx_stream_session_t*)
440779,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,"static void ngx_stream_proxy_finalize(ngx_stream_session_t *s, ngx_uint_t rc);",13,77,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_finalize,,false,80,80,ngx_stream_proxy_finalize,,,19,"void ngx_stream_proxy_finalize (ngx_stream_session_t*,ngx_uint_t)"
440785,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,"static u_char *ngx_stream_proxy_log_error(ngx_log_t *log, u_char *buf,
    size_t len);",15,15,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_log_error,,false,81,82,ngx_stream_proxy_log_error,,,20,"u_char* ngx_stream_proxy_log_error (ngx_log_t*,u_char*,size_t)"
440792,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,static void *ngx_stream_proxy_create_srv_conf(ngx_conf_t *cf);,13,61,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_create_srv_conf,,false,84,84,ngx_stream_proxy_create_srv_conf,,,21,void* ngx_stream_proxy_create_srv_conf (ngx_conf_t*)
440797,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,"static char *ngx_stream_proxy_merge_srv_conf(ngx_conf_t *cf, void *parent,
    void *child);",13,16,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_merge_srv_conf,,false,85,86,ngx_stream_proxy_merge_srv_conf,,,22,"char* ngx_stream_proxy_merge_srv_conf (ngx_conf_t*,void*,void*)"
440804,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,"static char *ngx_stream_proxy_pass(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_pass,,false,87,88,ngx_stream_proxy_pass,,,23,"char* ngx_stream_proxy_pass (ngx_conf_t*,ngx_command_t*,void*)"
440811,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,"static char *ngx_stream_proxy_bind(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_bind,,false,89,90,ngx_stream_proxy_bind,,,24,"char* ngx_stream_proxy_bind (ngx_conf_t*,ngx_command_t*,void*)"
441084,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,"static void
ngx_stream_proxy_handler(ngx_stream_session_t *s)
{
    u_char                           *p;
    ngx_str_t                        *host;
    ngx_uint_t                        i;
    ngx_connection_t                 *c;
    ngx_resolver_ctx_t               *ctx, temp;
    ngx_stream_upstream_t            *u;
    ngx_stream_core_srv_conf_t       *cscf;
    ngx_stream_proxy_srv_conf_t      *pscf;
    ngx_stream_upstream_srv_conf_t   *uscf, **uscfp;
    ngx_stream_upstream_main_conf_t  *umcf;

    c = s->connection;

    pscf = ngx_stream_get_module_srv_conf(s, ngx_stream_proxy_module);

    ngx_log_debug0(NGX_LOG_DEBUG_STREAM, c->log, 0,
                   ""proxy connection handler"");

    u = ngx_pcalloc(c->pool, sizeof(ngx_stream_upstream_t));
    if (u == NULL) {
        ngx_stream_proxy_finalize(s, NGX_STREAM_INTERNAL_SERVER_ERROR);
        return;
    }

    s->upstream = u;

    s->log_handler = ngx_stream_proxy_log_error;

    u->requests = 1;

    u->peer.log = c->l...",1,1,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_handler,,false,368,568,ngx_stream_proxy_handler,,,35,void ngx_stream_proxy_handler (ngx_stream_session_t*)
441663,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_proxy_eval(ngx_stream_session_t *s,
    ngx_stream_proxy_srv_conf_t *pscf)
{
    ngx_str_t               host;
    ngx_url_t               url;
    ngx_stream_upstream_t  *u;

    if (ngx_stream_complex_value(s, pscf->upstream_value, &host) != NGX_OK) {
        return NGX_ERROR;
    }

    ngx_memzero(&url, sizeof(ngx_url_t));

    url.url = host;
    url.no_resolve = 1;

    if (ngx_parse_url(s->connection->pool, &url) != NGX_OK) {
        if (url.err) {
            ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,
                          ""%s in upstream \""%V\"""", url.err, &url.url);
        }

        return NGX_ERROR;
    }

    u = s->upstream;

    u->resolved = ngx_pcalloc(s->connection->pool,
                              sizeof(ngx_stream_upstream_resolved_t));
    if (u->resolved == NULL) {
        return NGX_ERROR;
    }

    if (url.addrs) {
        u->resolved->sockaddr = url.addrs[0].sockaddr;
        u->resolved->socklen = url.addrs[0].sock...",1,1,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_eval,,false,571,617,ngx_stream_proxy_eval,,,36,"ngx_int_t ngx_stream_proxy_eval (ngx_stream_session_t*,ngx_stream_proxy_srv_conf_t*)"
441841,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_proxy_set_local(ngx_stream_session_t *s, ngx_stream_upstream_t *u,
    ngx_stream_upstream_local_t *local)
{
    ngx_int_t    rc;
    ngx_str_t    val;
    ngx_addr_t  *addr;

    if (local == NULL) {
        u->peer.local = NULL;
        return NGX_OK;
    }

#if (NGX_HAVE_TRANSPARENT_PROXY)
    u->peer.transparent = local->transparent;
#endif

    if (local->value == NULL) {
        u->peer.local = local->addr;
        return NGX_OK;
    }

    if (ngx_stream_complex_value(s, local->value, &val) != NGX_OK) {
        return NGX_ERROR;
    }

    if (val.len == 0) {
        return NGX_OK;
    }

    addr = ngx_palloc(s->connection->pool, sizeof(ngx_addr_t));
    if (addr == NULL) {
        return NGX_ERROR;
    }

    rc = ngx_parse_addr_port(s->connection->pool, addr, val.data, val.len);
    if (rc == NGX_ERROR) {
        return NGX_ERROR;
    }

    if (rc != NGX_OK) {
        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,
                      ""inva...",1,1,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_set_local,,false,620,670,ngx_stream_proxy_set_local,,,37,"ngx_int_t ngx_stream_proxy_set_local (ngx_stream_session_t*,ngx_stream_upstream_t*,ngx_stream_upstream_local_t*)"
441976,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,"static void
ngx_stream_proxy_connect(ngx_stream_session_t *s)
{
    ngx_int_t                     rc;
    ngx_connection_t             *c, *pc;
    ngx_stream_upstream_t        *u;
    ngx_stream_proxy_srv_conf_t  *pscf;

    c = s->connection;

    c->log->action = ""connecting to upstream"";

    pscf = ngx_stream_get_module_srv_conf(s, ngx_stream_proxy_module);

    u = s->upstream;

    u->connected = 0;
    u->proxy_protocol = pscf->proxy_protocol;

    if (u->state) {
        u->state->response_time = ngx_current_msec - u->start_time;
    }

    u->state = ngx_array_push(s->upstream_states);
    if (u->state == NULL) {
        ngx_stream_proxy_finalize(s, NGX_STREAM_INTERNAL_SERVER_ERROR);
        return;
    }

    ngx_memzero(u->state, sizeof(ngx_stream_upstream_state_t));

    u->start_time = ngx_current_msec;

    u->state->connect_time = (ngx_msec_t) -1;
    u->state->first_byte_time = (ngx_msec_t) -1;
    u->state->response_time = (ngx_msec_t) -1;

    rc = ngx_event_conne...",1,1,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_connect,,false,673,751,ngx_stream_proxy_connect,,,38,void ngx_stream_proxy_connect (ngx_stream_session_t*)
442225,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,"static void
ngx_stream_proxy_init_upstream(ngx_stream_session_t *s)
{
    u_char                       *p;
    ngx_chain_t                  *cl;
    ngx_connection_t             *c, *pc;
    ngx_log_handler_pt            handler;
    ngx_stream_upstream_t        *u;
    ngx_stream_core_srv_conf_t   *cscf;
    ngx_stream_proxy_srv_conf_t  *pscf;

    u = s->upstream;
    pc = u->peer.connection;

    cscf = ngx_stream_get_module_srv_conf(s, ngx_stream_core_module);

    if (pc->type == SOCK_STREAM
        && cscf->tcp_nodelay
        && ngx_tcp_nodelay(pc) != NGX_OK)
    {
        ngx_stream_proxy_next_upstream(s);
        return;
    }

    pscf = ngx_stream_get_module_srv_conf(s, ngx_stream_proxy_module);

#if (NGX_STREAM_SSL)

    if (pc->type == SOCK_STREAM && pscf->ssl) {

        if (u->proxy_protocol) {
            if (ngx_stream_proxy_send_proxy_protocol(s) != NGX_OK) {
                return;
            }

            u->proxy_protocol = 0;
        }

        if (pc->ssl ==...",1,1,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_init_upstream,,false,754,911,ngx_stream_proxy_init_upstream,,,39,void ngx_stream_proxy_init_upstream (ngx_stream_session_t*)
442722,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,"static void
ngx_stream_proxy_downstream_handler(ngx_event_t *ev)
{
    ngx_stream_proxy_process_connection(ev, ev->write);
}",1,1,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_downstream_handler,,false,1228,1232,ngx_stream_proxy_downstream_handler,,,40,void ngx_stream_proxy_downstream_handler (ngx_event_t*)
442732,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,"static void
ngx_stream_proxy_resolve_handler(ngx_resolver_ctx_t *ctx)
{
    ngx_stream_session_t            *s;
    ngx_stream_upstream_t           *u;
    ngx_stream_proxy_srv_conf_t     *pscf;
    ngx_stream_upstream_resolved_t  *ur;

    s = ctx->data;

    u = s->upstream;
    ur = u->resolved;

    ngx_log_debug0(NGX_LOG_DEBUG_STREAM, s->connection->log, 0,
                   ""stream upstream resolve"");

    if (ctx->state) {
        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,
                      ""%V could not be resolved (%i: %s)"",
                      &ctx->name, ctx->state,
                      ngx_resolver_strerror(ctx->state));

        ngx_stream_proxy_finalize(s, NGX_STREAM_INTERNAL_SERVER_ERROR);
        return;
    }

    ur->naddrs = ctx->naddrs;
    ur->addrs = ctx->addrs;

#if (NGX_DEBUG)
    {
    u_char      text[NGX_SOCKADDR_STRLEN];
    ngx_str_t   addr;
    ngx_uint_t  i;

    addr.data = text;

    for (i = 0; i < ctx->naddrs; i++) {
        addr.len...",1,1,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_resolve_handler,,false,1235,1301,ngx_stream_proxy_resolve_handler,,,41,void ngx_stream_proxy_resolve_handler (ngx_resolver_ctx_t*)
442864,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,"static void
ngx_stream_proxy_upstream_handler(ngx_event_t *ev)
{
    ngx_stream_proxy_process_connection(ev, !ev->write);
}",1,1,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_upstream_handler,,false,1304,1308,ngx_stream_proxy_upstream_handler,,,42,void ngx_stream_proxy_upstream_handler (ngx_event_t*)
442875,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,"static void
ngx_stream_proxy_process_connection(ngx_event_t *ev, ngx_uint_t from_upstream)
{
    ngx_connection_t             *c, *pc;
    ngx_log_handler_pt            handler;
    ngx_stream_session_t         *s;
    ngx_stream_upstream_t        *u;
    ngx_stream_proxy_srv_conf_t  *pscf;

    c = ev->data;
    s = c->data;
    u = s->upstream;

    if (c->close) {
        ngx_log_error(NGX_LOG_INFO, c->log, 0, ""shutdown timeout"");
        ngx_stream_proxy_finalize(s, NGX_STREAM_OK);
        return;
    }

    c = s->connection;
    pc = u->peer.connection;

    pscf = ngx_stream_get_module_srv_conf(s, ngx_stream_proxy_module);

    if (ev->timedout) {
        ev->timedout = 0;

        if (ev->delayed) {
            ev->delayed = 0;

            if (!ev->ready) {
                if (ngx_handle_read_event(ev, 0) != NGX_OK) {
                    ngx_stream_proxy_finalize(s,
                                              NGX_STREAM_INTERNAL_SERVER_ERROR);
                    return;
...",1,1,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_process_connection,,false,1311,1418,ngx_stream_proxy_process_connection,,,43,"void ngx_stream_proxy_process_connection (ngx_event_t*,ngx_uint_t)"
443145,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,"static void
ngx_stream_proxy_connect_handler(ngx_event_t *ev)
{
    ngx_connection_t      *c;
    ngx_stream_session_t  *s;

    c = ev->data;
    s = c->data;

    if (ev->timedout) {
        ngx_log_error(NGX_LOG_ERR, c->log, NGX_ETIMEDOUT, ""upstream timed out"");
        ngx_stream_proxy_next_upstream(s);
        return;
    }

    ngx_del_timer(c->write);

    ngx_log_debug0(NGX_LOG_DEBUG_STREAM, c->log, 0,
                   ""stream proxy connect upstream"");

    if (ngx_stream_proxy_test_connect(c) != NGX_OK) {
        ngx_stream_proxy_next_upstream(s);
        return;
    }

    ngx_stream_proxy_init_upstream(s);
}",1,1,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_connect_handler,,false,1421,1447,ngx_stream_proxy_connect_handler,,,44,void ngx_stream_proxy_connect_handler (ngx_event_t*)
443199,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_proxy_test_connect(ngx_connection_t *c)
{
    int        err;
    socklen_t  len;

#if (NGX_HAVE_KQUEUE)

    if (ngx_event_flags & NGX_USE_KQUEUE_EVENT)  {
        err = c->write->kq_errno ? c->write->kq_errno : c->read->kq_errno;

        if (err) {
            (void) ngx_connection_error(c, err,
                                    ""kevent() reported that connect() failed"");
            return NGX_ERROR;
        }

    } else
#endif
    {
        err = 0;
        len = sizeof(int);

        /*
         * BSDs and Linux return 0 and set a pending error in err
         * Solaris returns -1 and sets errno
         */

        if (getsockopt(c->fd, SOL_SOCKET, SO_ERROR, (void *) &err, &len)
            == -1)
        {
            err = ngx_socket_errno;
        }

        if (err) {
            (void) ngx_connection_error(c, err, ""connect() failed"");
            return NGX_ERROR;
        }
    }

    return NGX_OK;
}",1,1,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_test_connect,,false,1450,1491,ngx_stream_proxy_test_connect,,,45,ngx_int_t ngx_stream_proxy_test_connect (ngx_connection_t*)
443247,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,"static void
ngx_stream_proxy_process(ngx_stream_session_t *s, ngx_uint_t from_upstream,
    ngx_uint_t do_write)
{
    char                         *recv_action, *send_action;
    off_t                        *received, limit;
    size_t                        size, limit_rate;
    ssize_t                       n;
    ngx_buf_t                    *b;
    ngx_int_t                     rc;
    ngx_uint_t                    flags, *packets;
    ngx_msec_t                    delay;
    ngx_chain_t                  *cl, **ll, **out, **busy;
    ngx_connection_t             *c, *pc, *src, *dst;
    ngx_log_handler_pt            handler;
    ngx_stream_upstream_t        *u;
    ngx_stream_proxy_srv_conf_t  *pscf;

    u = s->upstream;

    c = s->connection;
    pc = u->connected ? u->peer.connection : NULL;

    if (c->type == SOCK_DGRAM && (ngx_terminate || ngx_exiting)) {

        /* socket is already closed on worker shutdown */

        handler = c->log->handler;
        c->log->handl...",1,1,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_process,,false,1494,1691,ngx_stream_proxy_process,,,46,"void ngx_stream_proxy_process (ngx_stream_session_t*,ngx_uint_t,ngx_uint_t)"
443917,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_proxy_test_finalize(ngx_stream_session_t *s,
    ngx_uint_t from_upstream)
{
    ngx_connection_t             *c, *pc;
    ngx_log_handler_pt            handler;
    ngx_stream_upstream_t        *u;
    ngx_stream_proxy_srv_conf_t  *pscf;

    pscf = ngx_stream_get_module_srv_conf(s, ngx_stream_proxy_module);

    c = s->connection;
    u = s->upstream;
    pc = u->connected ? u->peer.connection : NULL;

    if (c->type == SOCK_DGRAM) {

        if (pscf->requests && u->requests < pscf->requests) {
            return NGX_DECLINED;
        }

        if (pscf->requests) {
            ngx_delete_udp_connection(c);
        }

        if (pscf->responses == NGX_MAX_INT32_VALUE
            || u->responses < pscf->responses * u->requests)
        {
            return NGX_DECLINED;
        }

        if (pc == NULL || c->buffered || pc->buffered) {
            return NGX_DECLINED;
        }

        handler = c->log->handler;
        c->log->handler = NULL;

   ...",1,1,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_test_finalize,,false,1694,1772,ngx_stream_proxy_test_finalize,,,47,"ngx_int_t ngx_stream_proxy_test_finalize (ngx_stream_session_t*,ngx_uint_t)"
444169,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,"static void
ngx_stream_proxy_next_upstream(ngx_stream_session_t *s)
{
    ngx_msec_t                    timeout;
    ngx_connection_t             *pc;
    ngx_stream_upstream_t        *u;
    ngx_stream_proxy_srv_conf_t  *pscf;

    ngx_log_debug0(NGX_LOG_DEBUG_STREAM, s->connection->log, 0,
                   ""stream proxy next upstream"");

    u = s->upstream;
    pc = u->peer.connection;

    if (pc && pc->buffered) {
        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,
                      ""buffered data on next upstream"");
        ngx_stream_proxy_finalize(s, NGX_STREAM_INTERNAL_SERVER_ERROR);
        return;
    }

    if (s->connection->type == SOCK_DGRAM) {
        u->upstream_out = NULL;
    }

    if (u->peer.sockaddr) {
        u->peer.free(&u->peer, u->peer.data, NGX_PEER_FAILED);
        u->peer.sockaddr = NULL;
    }

    pscf = ngx_stream_get_module_srv_conf(s, ngx_stream_proxy_module);

    timeout = pscf->next_upstream_timeout;

    if (u->peer.tries == 0
    ...",1,1,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_next_upstream,,false,1775,1838,ngx_stream_proxy_next_upstream,,,48,void ngx_stream_proxy_next_upstream (ngx_stream_session_t*)
444347,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,"static void
ngx_stream_proxy_finalize(ngx_stream_session_t *s, ngx_uint_t rc)
{
    ngx_uint_t              state;
    ngx_connection_t       *pc;
    ngx_stream_upstream_t  *u;

    ngx_log_debug1(NGX_LOG_DEBUG_STREAM, s->connection->log, 0,
                   ""finalize stream proxy: %i"", rc);

    u = s->upstream;

    if (u == NULL) {
        goto noupstream;
    }

    if (u->resolved && u->resolved->ctx) {
        ngx_resolve_name_done(u->resolved->ctx);
        u->resolved->ctx = NULL;
    }

    pc = u->peer.connection;

    if (u->state) {
        if (u->state->response_time == (ngx_msec_t) -1) {
            u->state->response_time = ngx_current_msec - u->start_time;
        }

        if (pc) {
            u->state->bytes_received = u->received;
            u->state->bytes_sent = pc->sent;
        }
    }

    if (u->peer.free && u->peer.sockaddr) {
        state = 0;

        if (pc && pc->type == SOCK_DGRAM
            && (pc->read->error || pc->write->error))
        {
 ...",1,1,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_finalize,,false,1841,1906,ngx_stream_proxy_finalize,,,49,"void ngx_stream_proxy_finalize (ngx_stream_session_t*,ngx_uint_t)"
444547,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,"static u_char *
ngx_stream_proxy_log_error(ngx_log_t *log, u_char *buf, size_t len)
{
    u_char                 *p;
    ngx_connection_t       *pc;
    ngx_stream_session_t   *s;
    ngx_stream_upstream_t  *u;

    s = log->data;

    u = s->upstream;

    p = buf;

    if (u->peer.name) {
        p = ngx_snprintf(p, len, "", upstream: \""%V\"""", u->peer.name);
        len -= p - buf;
    }

    pc = u->peer.connection;

    p = ngx_snprintf(p, len,
                     "", bytes from/to client:%O/%O""
                     "", bytes from/to upstream:%O/%O"",
                     s->received, s->connection->sent,
                     u->received, pc ? pc->sent : 0);

    return p;
}",1,1,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_log_error,,false,1909,1937,ngx_stream_proxy_log_error,,,50,"u_char ngx_stream_proxy_log_error (ngx_log_t*,u_char*,size_t)"
444626,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,"static void *
ngx_stream_proxy_create_srv_conf(ngx_conf_t *cf)
{
    ngx_stream_proxy_srv_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_stream_proxy_srv_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     conf->ssl_protocols = 0;
     *     conf->ssl_ciphers = { 0, NULL };
     *     conf->ssl_name = NULL;
     *     conf->ssl_trusted_certificate = { 0, NULL };
     *     conf->ssl_crl = { 0, NULL };
     *     conf->ssl_certificate = { 0, NULL };
     *     conf->ssl_certificate_key = { 0, NULL };
     *
     *     conf->upload_rate = NULL;
     *     conf->download_rate = NULL;
     *     conf->ssl = NULL;
     *     conf->upstream = NULL;
     *     conf->upstream_value = NULL;
     */

    conf->connect_timeout = NGX_CONF_UNSET_MSEC;
    conf->timeout = NGX_CONF_UNSET_MSEC;
    conf->next_upstream_timeout = NGX_CONF_UNSET_MSEC;
    conf->buffer_size = NGX_CONF_UNSET_SIZE;
    conf->requests = NGX_CONF_...",1,1,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_create_srv_conf,,false,1940,1990,ngx_stream_proxy_create_srv_conf,,,51,void* ngx_stream_proxy_create_srv_conf (ngx_conf_t*)
444704,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_proxy_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_stream_proxy_srv_conf_t *prev = parent;
    ngx_stream_proxy_srv_conf_t *conf = child;

    ngx_conf_merge_msec_value(conf->connect_timeout,
                              prev->connect_timeout, 60000);

    ngx_conf_merge_msec_value(conf->timeout,
                              prev->timeout, 10 * 60000);

    ngx_conf_merge_msec_value(conf->next_upstream_timeout,
                              prev->next_upstream_timeout, 0);

    ngx_conf_merge_size_value(conf->buffer_size,
                              prev->buffer_size, 16384);

    if (conf->upload_rate == NULL) {
        conf->upload_rate = prev->upload_rate;
    }

    if (conf->download_rate == NULL) {
        conf->download_rate = prev->download_rate;
    }

    ngx_conf_merge_uint_value(conf->requests,
                              prev->requests, 0);

    ngx_conf_merge_uint_value(conf->responses,
                             ...",1,1,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_merge_srv_conf,,false,1993,2081,ngx_stream_proxy_merge_srv_conf,,,52,"char* ngx_stream_proxy_merge_srv_conf (ngx_conf_t*,void*,void*)"
444839,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_proxy_pass(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_stream_proxy_srv_conf_t *pscf = conf;

    ngx_url_t                            u;
    ngx_str_t                           *value, *url;
    ngx_stream_complex_value_t           cv;
    ngx_stream_core_srv_conf_t          *cscf;
    ngx_stream_compile_complex_value_t   ccv;

    if (pscf->upstream || pscf->upstream_value) {
        return ""is duplicate"";
    }

    cscf = ngx_stream_conf_get_module_srv_conf(cf, ngx_stream_core_module);

    cscf->handler = ngx_stream_proxy_handler;

    value = cf->args->elts;

    url = &value[1];

    ngx_memzero(&ccv, sizeof(ngx_stream_compile_complex_value_t));

    ccv.cf = cf;
    ccv.value = url;
    ccv.complex_value = &cv;

    if (ngx_stream_compile_complex_value(&ccv) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    if (cv.lengths) {
        pscf->upstream_value = ngx_palloc(cf->pool,
                                          sizeof(ngx_str...",1,1,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_pass,,false,2164,2220,ngx_stream_proxy_pass,,,53,"char* ngx_stream_proxy_pass (ngx_conf_t*,ngx_command_t*,void*)"
444988,METHOD,stream\ngx_stream_proxy_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_proxy_bind(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_stream_proxy_srv_conf_t *pscf = conf;

    ngx_int_t                            rc;
    ngx_str_t                           *value;
    ngx_stream_complex_value_t           cv;
    ngx_stream_upstream_local_t         *local;
    ngx_stream_compile_complex_value_t   ccv;

    if (pscf->local != NGX_CONF_UNSET_PTR) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    if (cf->args->nelts == 2 && ngx_strcmp(value[1].data, ""off"") == 0) {
        pscf->local = NULL;
        return NGX_CONF_OK;
    }

    ngx_memzero(&ccv, sizeof(ngx_stream_compile_complex_value_t));

    ccv.cf = cf;
    ccv.value = &value[1];
    ccv.complex_value = &cv;

    if (ngx_stream_compile_complex_value(&ccv) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    local = ngx_pcalloc(cf->pool, sizeof(ngx_stream_upstream_local_t));
    if (local == NULL) {
        return NGX_CONF_ERROR;
    }

    pscf...",1,1,stream\ngx_stream_proxy_module.c,ngx_stream_proxy_bind,,false,2223,2317,ngx_stream_proxy_bind,,,54,"char* ngx_stream_proxy_bind (ngx_conf_t*,ngx_command_t*,void*)"
445247,METHOD,stream\ngx_stream_realip_module.c:<global>,TYPE_DECL,<global>,1,1,stream\ngx_stream_realip_module.c,stream\ngx_stream_realip_module.c:<global>,,false,1,401,<global>,,,1,
445258,METHOD,stream\ngx_stream_realip_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_stream_realip_handler(ngx_stream_session_t *s);,18,67,stream\ngx_stream_realip_module.c,ngx_stream_realip_handler,,false,25,25,ngx_stream_realip_handler,,,5,ngx_int_t ngx_stream_realip_handler (ngx_stream_session_t*)
445263,METHOD,stream\ngx_stream_realip_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_realip_set_addr(ngx_stream_session_t *s,
    ngx_addr_t *addr);",18,21,stream\ngx_stream_realip_module.c,ngx_stream_realip_set_addr,,false,26,27,ngx_stream_realip_set_addr,,,6,"ngx_int_t ngx_stream_realip_set_addr (ngx_stream_session_t*,ngx_addr_t*)"
445269,METHOD,stream\ngx_stream_realip_module.c:<global>,TYPE_DECL,"static char *ngx_stream_realip_from(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,stream\ngx_stream_realip_module.c,ngx_stream_realip_from,,false,28,29,ngx_stream_realip_from,,,7,"char* ngx_stream_realip_from (ngx_conf_t*,ngx_command_t*,void*)"
445276,METHOD,stream\ngx_stream_realip_module.c:<global>,TYPE_DECL,static void *ngx_stream_realip_create_srv_conf(ngx_conf_t *cf);,13,62,stream\ngx_stream_realip_module.c,ngx_stream_realip_create_srv_conf,,false,30,30,ngx_stream_realip_create_srv_conf,,,8,void* ngx_stream_realip_create_srv_conf (ngx_conf_t*)
445281,METHOD,stream\ngx_stream_realip_module.c:<global>,TYPE_DECL,"static char *ngx_stream_realip_merge_srv_conf(ngx_conf_t *cf, void *parent,
    void *child);",13,16,stream\ngx_stream_realip_module.c,ngx_stream_realip_merge_srv_conf,,false,31,32,ngx_stream_realip_merge_srv_conf,,,9,"char* ngx_stream_realip_merge_srv_conf (ngx_conf_t*,void*,void*)"
445288,METHOD,stream\ngx_stream_realip_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_stream_realip_add_variables(ngx_conf_t *cf);,18,64,stream\ngx_stream_realip_module.c,ngx_stream_realip_add_variables,,false,33,33,ngx_stream_realip_add_variables,,,10,ngx_int_t ngx_stream_realip_add_variables (ngx_conf_t*)
445293,METHOD,stream\ngx_stream_realip_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_stream_realip_init(ngx_conf_t *cf);,18,55,stream\ngx_stream_realip_module.c,ngx_stream_realip_init,,false,34,34,ngx_stream_realip_init,,,11,ngx_int_t ngx_stream_realip_init (ngx_conf_t*)
445298,METHOD,stream\ngx_stream_realip_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_realip_remote_addr_variable(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data);",18,51,stream\ngx_stream_realip_module.c,ngx_stream_realip_remote_addr_variable,,false,37,38,ngx_stream_realip_remote_addr_variable,,,12,"ngx_int_t ngx_stream_realip_remote_addr_variable (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
445305,METHOD,stream\ngx_stream_realip_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_realip_remote_port_variable(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data);",18,51,stream\ngx_stream_realip_module.c,ngx_stream_realip_remote_port_variable,,false,39,40,ngx_stream_realip_remote_port_variable,,,13,"ngx_int_t ngx_stream_realip_remote_port_variable (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
445377,METHOD,stream\ngx_stream_realip_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_realip_handler(ngx_stream_session_t *s)
{
    ngx_addr_t                     addr;
    ngx_connection_t              *c;
    ngx_stream_realip_srv_conf_t  *rscf;

    rscf = ngx_stream_get_module_srv_conf(s, ngx_stream_realip_module);

    if (rscf->from == NULL) {
        return NGX_DECLINED;
    }

    c = s->connection;

    if (c->proxy_protocol == NULL) {
        return NGX_DECLINED;
    }

    if (ngx_cidr_match(c->sockaddr, rscf->from) != NGX_OK) {
        return NGX_DECLINED;
    }

    if (ngx_parse_addr(c->pool, &addr, c->proxy_protocol->src_addr.data,
                       c->proxy_protocol->src_addr.len)
        != NGX_OK)
    {
        return NGX_DECLINED;
    }

    ngx_inet_set_port(addr.sockaddr, c->proxy_protocol->src_port);

    return ngx_stream_realip_set_addr(s, &addr);
}",1,1,stream\ngx_stream_realip_module.c,ngx_stream_realip_handler,,false,96,129,ngx_stream_realip_handler,,,22,ngx_int_t ngx_stream_realip_handler (ngx_stream_session_t*)
445466,METHOD,stream\ngx_stream_realip_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_realip_set_addr(ngx_stream_session_t *s, ngx_addr_t *addr)
{
    size_t                    len;
    u_char                   *p;
    u_char                    text[NGX_SOCKADDR_STRLEN];
    ngx_connection_t         *c;
    ngx_stream_realip_ctx_t  *ctx;

    c = s->connection;

    ctx = ngx_palloc(c->pool, sizeof(ngx_stream_realip_ctx_t));
    if (ctx == NULL) {
        return NGX_ERROR;
    }

    len = ngx_sock_ntop(addr->sockaddr, addr->socklen, text,
                        NGX_SOCKADDR_STRLEN, 0);
    if (len == 0) {
        return NGX_ERROR;
    }

    p = ngx_pnalloc(c->pool, len);
    if (p == NULL) {
        return NGX_ERROR;
    }

    ngx_memcpy(p, text, len);

    ngx_stream_set_ctx(s, ctx, ngx_stream_realip_module);

    ctx->sockaddr = c->sockaddr;
    ctx->socklen = c->socklen;
    ctx->addr_text = c->addr_text;

    c->sockaddr = addr->sockaddr;
    c->socklen = addr->socklen;
    c->addr_text.len = len;
    c->addr_text.data = p;

    re...",1,1,stream\ngx_stream_realip_module.c,ngx_stream_realip_set_addr,,false,132,173,ngx_stream_realip_set_addr,,,23,"ngx_int_t ngx_stream_realip_set_addr (ngx_stream_session_t*,ngx_addr_t*)"
445589,METHOD,stream\ngx_stream_realip_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_realip_from(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_stream_realip_srv_conf_t *rscf = conf;

    ngx_int_t             rc;
    ngx_str_t            *value;
    ngx_url_t             u;
    ngx_cidr_t            c, *cidr;
    ngx_uint_t            i;
    struct sockaddr_in   *sin;
#if (NGX_HAVE_INET6)
    struct sockaddr_in6  *sin6;
#endif

    value = cf->args->elts;

    if (rscf->from == NULL) {
        rscf->from = ngx_array_create(cf->pool, 2,
                                      sizeof(ngx_cidr_t));
        if (rscf->from == NULL) {
            return NGX_CONF_ERROR;
        }
    }

#if (NGX_HAVE_UNIX_DOMAIN)

    if (ngx_strcmp(value[1].data, ""unix:"") == 0) {
        cidr = ngx_array_push(rscf->from);
        if (cidr == NULL) {
            return NGX_CONF_ERROR;
        }

        cidr->family = AF_UNIX;
        return NGX_CONF_OK;
    }

#endif

    rc = ngx_ptocidr(&value[1], &c);

    if (rc != NGX_ERROR) {
        if (rc == NGX_...",1,1,stream\ngx_stream_realip_module.c,ngx_stream_realip_from,,false,176,276,ngx_stream_realip_from,,,24,"char* ngx_stream_realip_from (ngx_conf_t*,ngx_command_t*,void*)"
445829,METHOD,stream\ngx_stream_realip_module.c:<global>,TYPE_DECL,"static void *
ngx_stream_realip_create_srv_conf(ngx_conf_t *cf)
{
    ngx_stream_realip_srv_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_stream_realip_srv_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     conf->from = NULL;
     */

    return conf;
}",1,1,stream\ngx_stream_realip_module.c,ngx_stream_realip_create_srv_conf,,false,279,296,ngx_stream_realip_create_srv_conf,,,25,void* ngx_stream_realip_create_srv_conf (ngx_conf_t*)
445852,METHOD,stream\ngx_stream_realip_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_realip_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_stream_realip_srv_conf_t *prev = parent;
    ngx_stream_realip_srv_conf_t *conf = child;

    if (conf->from == NULL) {
        conf->from = prev->from;
    }

    return NGX_CONF_OK;
}",1,1,stream\ngx_stream_realip_module.c,ngx_stream_realip_merge_srv_conf,,false,299,310,ngx_stream_realip_merge_srv_conf,,,26,"char* ngx_stream_realip_merge_srv_conf (ngx_conf_t*,void*,void*)"
445883,METHOD,stream\ngx_stream_realip_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_realip_add_variables(ngx_conf_t *cf)
{
    ngx_stream_variable_t  *var, *v;

    for (v = ngx_stream_realip_vars; v->name.len; v++) {
        var = ngx_stream_add_variable(cf, &v->name, v->flags);
        if (var == NULL) {
            return NGX_ERROR;
        }

        var->get_handler = v->get_handler;
        var->data = v->data;
    }

    return NGX_OK;
}",1,1,stream\ngx_stream_realip_module.c,ngx_stream_realip_add_variables,,false,313,329,ngx_stream_realip_add_variables,,,27,ngx_int_t ngx_stream_realip_add_variables (ngx_conf_t*)
445937,METHOD,stream\ngx_stream_realip_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_realip_init(ngx_conf_t *cf)
{
    ngx_stream_handler_pt        *h;
    ngx_stream_core_main_conf_t  *cmcf;

    cmcf = ngx_stream_conf_get_module_main_conf(cf, ngx_stream_core_module);

    h = ngx_array_push(&cmcf->phases[NGX_STREAM_POST_ACCEPT_PHASE].handlers);
    if (h == NULL) {
        return NGX_ERROR;
    }

    *h = ngx_stream_realip_handler;

    return NGX_OK;
}",1,1,stream\ngx_stream_realip_module.c,ngx_stream_realip_init,,false,332,348,ngx_stream_realip_init,,,28,ngx_int_t ngx_stream_realip_init (ngx_conf_t*)
445973,METHOD,stream\ngx_stream_realip_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_realip_remote_addr_variable(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data)
{
    ngx_str_t                *addr_text;
    ngx_stream_realip_ctx_t  *ctx;

    ctx = ngx_stream_get_module_ctx(s, ngx_stream_realip_module);

    addr_text = ctx ? &ctx->addr_text : &s->connection->addr_text;

    v->len = addr_text->len;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = addr_text->data;

    return NGX_OK;
}",1,1,stream\ngx_stream_realip_module.c,ngx_stream_realip_remote_addr_variable,,false,351,369,ngx_stream_realip_remote_addr_variable,,,29,"ngx_int_t ngx_stream_realip_remote_addr_variable (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
446032,METHOD,stream\ngx_stream_realip_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_realip_remote_port_variable(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data)
{
    ngx_uint_t                port;
    struct sockaddr          *sa;
    ngx_stream_realip_ctx_t  *ctx;

    ctx = ngx_stream_get_module_ctx(s, ngx_stream_realip_module);

    sa = ctx ? ctx->sockaddr : s->connection->sockaddr;

    v->len = 0;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;

    v->data = ngx_pnalloc(s->connection->pool, sizeof(""65535"") - 1);
    if (v->data == NULL) {
        return NGX_ERROR;
    }

    port = ngx_inet_get_port(sa);

    if (port > 0 && port < 65536) {
        v->len = ngx_sprintf(v->data, ""%ui"", port) - v->data;
    }

    return NGX_OK;
}",1,1,stream\ngx_stream_realip_module.c,ngx_stream_realip_remote_port_variable,,false,372,401,ngx_stream_realip_remote_port_variable,,,30,"ngx_int_t ngx_stream_realip_remote_port_variable (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
446140,METHOD,stream\ngx_stream_return_module.c:<global>,TYPE_DECL,<global>,1,1,stream\ngx_stream_return_module.c,stream\ngx_stream_return_module.c:<global>,,false,1,218,<global>,,,1,
446148,METHOD,stream\ngx_stream_return_module.c:<global>,TYPE_DECL,static void ngx_stream_return_handler(ngx_stream_session_t *s);,13,62,stream\ngx_stream_return_module.c,ngx_stream_return_handler,,false,23,23,ngx_stream_return_handler,,,5,void ngx_stream_return_handler (ngx_stream_session_t*)
446153,METHOD,stream\ngx_stream_return_module.c:<global>,TYPE_DECL,static void ngx_stream_return_write_handler(ngx_event_t *ev);,13,60,stream\ngx_stream_return_module.c,ngx_stream_return_write_handler,,false,24,24,ngx_stream_return_write_handler,,,6,void ngx_stream_return_write_handler (ngx_event_t*)
446158,METHOD,stream\ngx_stream_return_module.c:<global>,TYPE_DECL,static void *ngx_stream_return_create_srv_conf(ngx_conf_t *cf);,13,62,stream\ngx_stream_return_module.c,ngx_stream_return_create_srv_conf,,false,26,26,ngx_stream_return_create_srv_conf,,,7,void* ngx_stream_return_create_srv_conf (ngx_conf_t*)
446163,METHOD,stream\ngx_stream_return_module.c:<global>,TYPE_DECL,"static char *ngx_stream_return(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);",13,78,stream\ngx_stream_return_module.c,ngx_stream_return,,false,27,27,ngx_stream_return,,,8,"char* ngx_stream_return (ngx_conf_t*,ngx_command_t*,void*)"
446212,METHOD,stream\ngx_stream_return_module.c:<global>,TYPE_DECL,"static void
ngx_stream_return_handler(ngx_stream_session_t *s)
{
    ngx_str_t                      text;
    ngx_buf_t                     *b;
    ngx_connection_t              *c;
    ngx_stream_return_ctx_t       *ctx;
    ngx_stream_return_srv_conf_t  *rscf;

    c = s->connection;

    c->log->action = ""returning text"";

    rscf = ngx_stream_get_module_srv_conf(s, ngx_stream_return_module);

    if (ngx_stream_complex_value(s, &rscf->text, &text) != NGX_OK) {
        ngx_stream_finalize_session(s, NGX_STREAM_INTERNAL_SERVER_ERROR);
        return;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_STREAM, c->log, 0,
                   ""stream return text: \""%V\"""", &text);

    if (text.len == 0) {
        ngx_stream_finalize_session(s, NGX_STREAM_OK);
        return;
    }

    ctx = ngx_pcalloc(c->pool, sizeof(ngx_stream_return_ctx_t));
    if (ctx == NULL) {
        ngx_stream_finalize_session(s, NGX_STREAM_INTERNAL_SERVER_ERROR);
        return;
    }

    ngx_stream_set_ctx(s, ctx, n...",1,1,stream\ngx_stream_return_module.c,ngx_stream_return_handler,,false,71,130,ngx_stream_return_handler,,,15,void ngx_stream_return_handler (ngx_stream_session_t*)
446383,METHOD,stream\ngx_stream_return_module.c:<global>,TYPE_DECL,"static void
ngx_stream_return_write_handler(ngx_event_t *ev)
{
    ngx_connection_t         *c;
    ngx_stream_session_t     *s;
    ngx_stream_return_ctx_t  *ctx;

    c = ev->data;
    s = c->data;

    if (ev->timedout) {
        ngx_connection_error(c, NGX_ETIMEDOUT, ""connection timed out"");
        ngx_stream_finalize_session(s, NGX_STREAM_OK);
        return;
    }

    ctx = ngx_stream_get_module_ctx(s, ngx_stream_return_module);

    if (ngx_stream_top_filter(s, ctx->out, 1) == NGX_ERROR) {
        ngx_stream_finalize_session(s, NGX_STREAM_INTERNAL_SERVER_ERROR);
        return;
    }

    ctx->out = NULL;

    if (!c->buffered) {
        ngx_log_debug0(NGX_LOG_DEBUG_STREAM, c->log, 0,
                       ""stream return done sending"");
        ngx_stream_finalize_session(s, NGX_STREAM_OK);
        return;
    }

    if (ngx_handle_write_event(ev, 0) != NGX_OK) {
        ngx_stream_finalize_session(s, NGX_STREAM_INTERNAL_SERVER_ERROR);
        return;
    }

    ngx_add_ti...",1,1,stream\ngx_stream_return_module.c,ngx_stream_return_write_handler,,false,133,171,ngx_stream_return_write_handler,,,16,void ngx_stream_return_write_handler (ngx_event_t*)
446469,METHOD,stream\ngx_stream_return_module.c:<global>,TYPE_DECL,"static void *
ngx_stream_return_create_srv_conf(ngx_conf_t *cf)
{
    ngx_stream_return_srv_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_stream_return_srv_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    return conf;
}",1,1,stream\ngx_stream_return_module.c,ngx_stream_return_create_srv_conf,,false,174,185,ngx_stream_return_create_srv_conf,,,17,void* ngx_stream_return_create_srv_conf (ngx_conf_t*)
446492,METHOD,stream\ngx_stream_return_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_return(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_stream_return_srv_conf_t *rscf = conf;

    ngx_str_t                           *value;
    ngx_stream_core_srv_conf_t          *cscf;
    ngx_stream_compile_complex_value_t   ccv;

    if (rscf->text.value.data) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    ngx_memzero(&ccv, sizeof(ngx_stream_compile_complex_value_t));

    ccv.cf = cf;
    ccv.value = &value[1];
    ccv.complex_value = &rscf->text;

    if (ngx_stream_compile_complex_value(&ccv) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    cscf = ngx_stream_conf_get_module_srv_conf(cf, ngx_stream_core_module);

    cscf->handler = ngx_stream_return_handler;

    return NGX_CONF_OK;
}",1,1,stream\ngx_stream_return_module.c,ngx_stream_return,,false,188,218,ngx_stream_return,,,18,"char* ngx_stream_return (ngx_conf_t*,ngx_command_t*,void*)"
446580,METHOD,stream\ngx_stream_script.c:<global>,TYPE_DECL,<global>,1,16,stream\ngx_stream_script.c,stream\ngx_stream_script.c:<global>,,false,1,983,<global>,,,1,
446582,METHOD,stream\ngx_stream_script.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_script_init_arrays(
    ngx_stream_script_compile_t *sc);",18,36,stream\ngx_stream_script.c,ngx_stream_script_init_arrays,,false,13,14,ngx_stream_script_init_arrays,,,1,ngx_int_t ngx_stream_script_init_arrays (ngx_stream_script_compile_t*)
446587,METHOD,stream\ngx_stream_script.c:<global>,TYPE_DECL,static ngx_int_t ngx_stream_script_done(ngx_stream_script_compile_t *sc);,18,72,stream\ngx_stream_script.c,ngx_stream_script_done,,false,15,15,ngx_stream_script_done,,,2,ngx_int_t ngx_stream_script_done (ngx_stream_script_compile_t*)
446592,METHOD,stream\ngx_stream_script.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_script_add_copy_code(
    ngx_stream_script_compile_t *sc, ngx_str_t *value, ngx_uint_t last);",18,71,stream\ngx_stream_script.c,ngx_stream_script_add_copy_code,,false,16,17,ngx_stream_script_add_copy_code,,,3,"ngx_int_t ngx_stream_script_add_copy_code (ngx_stream_script_compile_t*,ngx_str_t*,ngx_uint_t)"
446599,METHOD,stream\ngx_stream_script.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_script_add_var_code(
    ngx_stream_script_compile_t *sc, ngx_str_t *name);",18,53,stream\ngx_stream_script.c,ngx_stream_script_add_var_code,,false,18,19,ngx_stream_script_add_var_code,,,4,"ngx_int_t ngx_stream_script_add_var_code (ngx_stream_script_compile_t*,ngx_str_t*)"
446605,METHOD,stream\ngx_stream_script.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_script_add_full_name_code(
    ngx_stream_script_compile_t *sc);",18,36,stream\ngx_stream_script.c,ngx_stream_script_add_full_name_code,,false,24,25,ngx_stream_script_add_full_name_code,,,5,ngx_int_t ngx_stream_script_add_full_name_code (ngx_stream_script_compile_t*)
446610,METHOD,stream\ngx_stream_script.c:<global>,TYPE_DECL,"static size_t ngx_stream_script_full_name_len_code(
    ngx_stream_script_engine_t *e);",15,34,stream\ngx_stream_script.c,ngx_stream_script_full_name_len_code,,false,26,27,ngx_stream_script_full_name_len_code,,,6,size_t ngx_stream_script_full_name_len_code (ngx_stream_script_engine_t*)
446615,METHOD,stream\ngx_stream_script.c:<global>,TYPE_DECL,static void ngx_stream_script_full_name_code(ngx_stream_script_engine_t *e);,13,75,stream\ngx_stream_script.c,ngx_stream_script_full_name_code,,false,28,28,ngx_stream_script_full_name_code,,,7,void ngx_stream_script_full_name_code (ngx_stream_script_engine_t*)
446626,METHOD,stream\ngx_stream_script.c:<global>,TYPE_DECL,"void
ngx_stream_script_flush_complex_value(ngx_stream_session_t *s,
    ngx_stream_complex_value_t *val)
{
    ngx_uint_t *index;

    index = val->flushes;

    if (index) {
        while (*index != (ngx_uint_t) -1) {

            if (s->variables[*index].no_cacheable) {
                s->variables[*index].valid = 0;
                s->variables[*index].not_found = 0;
            }

            index++;
        }
    }
}",1,1,stream\ngx_stream_script.c,ngx_stream_script_flush_complex_value,,false,36,55,ngx_stream_script_flush_complex_value,,,10,"void ngx_stream_script_flush_complex_value (ngx_stream_session_t*,ngx_stream_complex_value_t*)"
446681,METHOD,stream\ngx_stream_script.c:<global>,TYPE_DECL,"ngx_int_t
ngx_stream_complex_value(ngx_stream_session_t *s,
    ngx_stream_complex_value_t *val, ngx_str_t *value)
{
    size_t                         len;
    ngx_stream_script_code_pt      code;
    ngx_stream_script_engine_t     e;
    ngx_stream_script_len_code_pt  lcode;

    if (val->lengths == NULL) {
        *value = val->value;
        return NGX_OK;
    }

    ngx_stream_script_flush_complex_value(s, val);

    ngx_memzero(&e, sizeof(ngx_stream_script_engine_t));

    e.ip = val->lengths;
    e.session = s;
    e.flushed = 1;

    len = 0;

    while (*(uintptr_t *) e.ip) {
        lcode = *(ngx_stream_script_len_code_pt *) e.ip;
        len += lcode(&e);
    }

    value->len = len;
    value->data = ngx_pnalloc(s->connection->pool, len);
    if (value->data == NULL) {
        return NGX_ERROR;
    }

    e.ip = val->values;
    e.pos = value->data;
    e.buf = *value;

    while (*(uintptr_t *) e.ip) {
        code = *(ngx_stream_script_code_pt *) e.ip;
        code((ng...",1,1,stream\ngx_stream_script.c,ngx_stream_complex_value,,false,58,105,ngx_stream_complex_value,,,11,"ngx_int_t ngx_stream_complex_value (ngx_stream_session_t*,ngx_stream_complex_value_t*,ngx_str_t*)"
446830,METHOD,stream\ngx_stream_script.c:<global>,TYPE_DECL,"size_t
ngx_stream_complex_value_size(ngx_stream_session_t *s,
    ngx_stream_complex_value_t *val, size_t default_value)
{
    size_t     size;
    ngx_str_t  value;

    if (val == NULL) {
        return default_value;
    }

    if (val->lengths == NULL) {
        return val->u.size;
    }

    if (ngx_stream_complex_value(s, val, &value) != NGX_OK) {
        return default_value;
    }

    size = ngx_parse_size(&value);

    if (size == (size_t) NGX_ERROR) {
        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,
                      ""invalid size \""%V\"""", &value);
        return default_value;
    }

    return size;
}",1,1,stream\ngx_stream_script.c,ngx_stream_complex_value_size,,false,108,136,ngx_stream_complex_value_size,,,12,"size_t ngx_stream_complex_value_size (ngx_stream_session_t*,ngx_stream_complex_value_t*,size_t)"
446897,METHOD,stream\ngx_stream_script.c:<global>,TYPE_DECL,"ngx_int_t
ngx_stream_compile_complex_value(ngx_stream_compile_complex_value_t *ccv)
{
    ngx_str_t                    *v;
    ngx_uint_t                    i, n, nv, nc;
    ngx_array_t                   flushes, lengths, values, *pf, *pl, *pv;
    ngx_stream_script_compile_t   sc;

    v = ccv->value;

    nv = 0;
    nc = 0;

    for (i = 0; i < v->len; i++) {
        if (v->data[i] == '$') {
            if (v->data[i + 1] >= '1' && v->data[i + 1] <= '9') {
                nc++;

            } else {
                nv++;
            }
        }
    }

    if ((v->len == 0 || v->data[0] != '$')
        && (ccv->conf_prefix || ccv->root_prefix))
    {
        if (ngx_conf_full_name(ccv->cf->cycle, v, ccv->conf_prefix) != NGX_OK) {
            return NGX_ERROR;
        }

        ccv->conf_prefix = 0;
        ccv->root_prefix = 0;
    }

    ccv->complex_value->value = *v;
    ccv->complex_value->flushes = NULL;
    ccv->complex_value->lengths = NULL;
    ccv->complex_value->values...",1,1,stream\ngx_stream_script.c,ngx_stream_compile_complex_value,,false,139,240,ngx_stream_compile_complex_value,,,13,ngx_int_t ngx_stream_compile_complex_value (ngx_stream_compile_complex_value_t*)
447294,METHOD,stream\ngx_stream_script.c:<global>,TYPE_DECL,"char *
ngx_stream_set_complex_value_slot(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf)
{
    char  *p = conf;

    ngx_str_t                            *value;
    ngx_stream_complex_value_t          **cv;
    ngx_stream_compile_complex_value_t    ccv;

    cv = (ngx_stream_complex_value_t **) (p + cmd->offset);

    if (*cv != NULL) {
        return ""is duplicate"";
    }

    *cv = ngx_palloc(cf->pool, sizeof(ngx_stream_complex_value_t));
    if (*cv == NULL) {
        return NGX_CONF_ERROR;
    }

    value = cf->args->elts;

    ngx_memzero(&ccv, sizeof(ngx_stream_compile_complex_value_t));

    ccv.cf = cf;
    ccv.value = &value[1];
    ccv.complex_value = *cv;

    if (ngx_stream_compile_complex_value(&ccv) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    return NGX_CONF_OK;
}",1,1,stream\ngx_stream_script.c,ngx_stream_set_complex_value_slot,,false,243,277,ngx_stream_set_complex_value_slot,,,14,"char* ngx_stream_set_complex_value_slot (ngx_conf_t*,ngx_command_t*,void*)"
447384,METHOD,stream\ngx_stream_script.c:<global>,TYPE_DECL,"char *
ngx_stream_set_complex_value_size_slot(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf)
{
    char  *p = conf;

    char                        *rv;
    ngx_stream_complex_value_t  *cv;

    rv = ngx_stream_set_complex_value_slot(cf, cmd, conf);

    if (rv != NGX_CONF_OK) {
        return rv;
    }

    cv = *(ngx_stream_complex_value_t **) (p + cmd->offset);

    if (cv->lengths) {
        return NGX_CONF_OK;
    }

    cv->u.size = ngx_parse_size(&cv->value);
    if (cv->u.size == (size_t) NGX_ERROR) {
        return ""invalid value"";
    }

    return NGX_CONF_OK;
}",1,1,stream\ngx_stream_script.c,ngx_stream_set_complex_value_size_slot,,false,280,307,ngx_stream_set_complex_value_size_slot,,,15,"char* ngx_stream_set_complex_value_size_slot (ngx_conf_t*,ngx_command_t*,void*)"
447453,METHOD,stream\ngx_stream_script.c:<global>,TYPE_DECL,"ngx_uint_t
ngx_stream_script_variables_count(ngx_str_t *value)
{
    ngx_uint_t  i, n;

    for (n = 0, i = 0; i < value->len; i++) {
        if (value->data[i] == '$') {
            n++;
        }
    }

    return n;
}",1,1,stream\ngx_stream_script.c,ngx_stream_script_variables_count,,false,310,322,ngx_stream_script_variables_count,,,16,ngx_uint_t ngx_stream_script_variables_count (ngx_str_t*)
447490,METHOD,stream\ngx_stream_script.c:<global>,TYPE_DECL,"ngx_int_t
ngx_stream_script_compile(ngx_stream_script_compile_t *sc)
{
    u_char       ch;
    ngx_str_t    name;
    ngx_uint_t   i, bracket;

    if (ngx_stream_script_init_arrays(sc) != NGX_OK) {
        return NGX_ERROR;
    }

    for (i = 0; i < sc->source->len; /* void */ ) {

        name.len = 0;

        if (sc->source->data[i] == '$') {

            if (++i == sc->source->len) {
                goto invalid_variable;
            }

            if (sc->source->data[i] >= '1' && sc->source->data[i] <= '9') {
#if (NGX_PCRE)
                ngx_uint_t  n;

                n = sc->source->data[i] - '0';

                if (ngx_stream_script_add_capture_code(sc, n) != NGX_OK) {
                    return NGX_ERROR;
                }

                i++;

                continue;
#else
                ngx_conf_log_error(NGX_LOG_EMERG, sc->cf, 0,
                                   ""using variable \""$%c\"" requires ""
                                   ""PCRE library"", sc->source...",1,1,stream\ngx_stream_script.c,ngx_stream_script_compile,,false,325,449,ngx_stream_script_compile,,,17,ngx_int_t ngx_stream_script_compile (ngx_stream_script_compile_t*)
447821,METHOD,stream\ngx_stream_script.c:<global>,TYPE_DECL,"u_char *
ngx_stream_script_run(ngx_stream_session_t *s, ngx_str_t *value,
    void *code_lengths, size_t len, void *code_values)
{
    ngx_uint_t                      i;
    ngx_stream_script_code_pt       code;
    ngx_stream_script_engine_t      e;
    ngx_stream_core_main_conf_t    *cmcf;
    ngx_stream_script_len_code_pt   lcode;

    cmcf = ngx_stream_get_module_main_conf(s, ngx_stream_core_module);

    for (i = 0; i < cmcf->variables.nelts; i++) {
        if (s->variables[i].no_cacheable) {
            s->variables[i].valid = 0;
            s->variables[i].not_found = 0;
        }
    }

    ngx_memzero(&e, sizeof(ngx_stream_script_engine_t));

    e.ip = code_lengths;
    e.session = s;
    e.flushed = 1;

    while (*(uintptr_t *) e.ip) {
        lcode = *(ngx_stream_script_len_code_pt *) e.ip;
        len += lcode(&e);
    }


    value->len = len;
    value->data = ngx_pnalloc(s->connection->pool, len);
    if (value->data == NULL) {
        return NULL;
    }

    e.ip =...",1,1,stream\ngx_stream_script.c,ngx_stream_script_run,,false,452,498,ngx_stream_script_run,,,18,"u_char ngx_stream_script_run (ngx_stream_session_t*,ngx_str_t*,void*,size_t,void*)"
447985,METHOD,stream\ngx_stream_script.c:<global>,TYPE_DECL,"void
ngx_stream_script_flush_no_cacheable_variables(ngx_stream_session_t *s,
    ngx_array_t *indices)
{
    ngx_uint_t  n, *index;

    if (indices) {
        index = indices->elts;
        for (n = 0; n < indices->nelts; n++) {
            if (s->variables[index[n]].no_cacheable) {
                s->variables[index[n]].valid = 0;
                s->variables[index[n]].not_found = 0;
            }
        }
    }
}",1,1,stream\ngx_stream_script.c,ngx_stream_script_flush_no_cacheable_variables,,false,501,516,ngx_stream_script_flush_no_cacheable_variables,,,19,"void ngx_stream_script_flush_no_cacheable_variables (ngx_stream_session_t*,ngx_array_t*)"
448047,METHOD,stream\ngx_stream_script.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_script_init_arrays(ngx_stream_script_compile_t *sc)
{
    ngx_uint_t   n;

    if (sc->flushes && *sc->flushes == NULL) {
        n = sc->variables ? sc->variables : 1;
        *sc->flushes = ngx_array_create(sc->cf->pool, n, sizeof(ngx_uint_t));
        if (*sc->flushes == NULL) {
            return NGX_ERROR;
        }
    }

    if (*sc->lengths == NULL) {
        n = sc->variables * (2 * sizeof(ngx_stream_script_copy_code_t)
                             + sizeof(ngx_stream_script_var_code_t))
            + sizeof(uintptr_t);

        *sc->lengths = ngx_array_create(sc->cf->pool, n, 1);
        if (*sc->lengths == NULL) {
            return NGX_ERROR;
        }
    }

    if (*sc->values == NULL) {
        n = (sc->variables * (2 * sizeof(ngx_stream_script_copy_code_t)
                              + sizeof(ngx_stream_script_var_code_t))
                + sizeof(uintptr_t)
                + sc->source->len
                + sizeof(uintptr_t) - 1)
     ...",1,1,stream\ngx_stream_script.c,ngx_stream_script_init_arrays,,false,519,560,ngx_stream_script_init_arrays,,,20,ngx_int_t ngx_stream_script_init_arrays (ngx_stream_script_compile_t*)
448217,METHOD,stream\ngx_stream_script.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_script_done(ngx_stream_script_compile_t *sc)
{
    ngx_str_t    zero;
    uintptr_t   *code;

    if (sc->zero) {

        zero.len = 1;
        zero.data = (u_char *) ""\0"";

        if (ngx_stream_script_add_copy_code(sc, &zero, 0) != NGX_OK) {
            return NGX_ERROR;
        }
    }

    if (sc->conf_prefix || sc->root_prefix) {
        if (ngx_stream_script_add_full_name_code(sc) != NGX_OK) {
            return NGX_ERROR;
        }
    }

    if (sc->complete_lengths) {
        code = ngx_stream_script_add_code(*sc->lengths, sizeof(uintptr_t),
                                          NULL);
        if (code == NULL) {
            return NGX_ERROR;
        }

        *code = (uintptr_t) NULL;
    }

    if (sc->complete_values) {
        code = ngx_stream_script_add_code(*sc->values, sizeof(uintptr_t),
                                          &sc->main);
        if (code == NULL) {
            return NGX_ERROR;
        }

        *code = (uintpt...",1,1,stream\ngx_stream_script.c,ngx_stream_script_done,,false,563,606,ngx_stream_script_done,,,21,ngx_int_t ngx_stream_script_done (ngx_stream_script_compile_t*)
448330,METHOD,stream\ngx_stream_script.c:<global>,TYPE_DECL,"void *
ngx_stream_script_add_code(ngx_array_t *codes, size_t size, void *code)
{
    u_char  *elts, **p;
    void    *new;

    elts = codes->elts;

    new = ngx_array_push_n(codes, size);
    if (new == NULL) {
        return NULL;
    }

    if (code) {
        if (elts != codes->elts) {
            p = code;
            *p += (u_char *) codes->elts - elts;
        }
    }

    return new;
}",1,1,stream\ngx_stream_script.c,ngx_stream_script_add_code,,false,609,630,ngx_stream_script_add_code,,,22,"void* ngx_stream_script_add_code (ngx_array_t*,size_t,void*)"
448382,METHOD,stream\ngx_stream_script.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_script_add_copy_code(ngx_stream_script_compile_t *sc,
    ngx_str_t *value, ngx_uint_t last)
{
    u_char                         *p;
    size_t                          size, len, zero;
    ngx_stream_script_copy_code_t  *code;

    zero = (sc->zero && last);
    len = value->len + zero;

    code = ngx_stream_script_add_code(*sc->lengths,
                                      sizeof(ngx_stream_script_copy_code_t),
                                      NULL);
    if (code == NULL) {
        return NGX_ERROR;
    }

    code->code = (ngx_stream_script_code_pt) (void *)
                                               ngx_stream_script_copy_len_code;
    code->len = len;

    size = (sizeof(ngx_stream_script_copy_code_t) + len + sizeof(uintptr_t) - 1)
            & ~(sizeof(uintptr_t) - 1);

    code = ngx_stream_script_add_code(*sc->values, size, &sc->main);
    if (code == NULL) {
        return NGX_ERROR;
    }

    code->code = ngx_stream_script_copy_cod...",1,1,stream\ngx_stream_script.c,ngx_stream_script_add_copy_code,,false,633,675,ngx_stream_script_add_copy_code,,,23,"ngx_int_t ngx_stream_script_add_copy_code (ngx_stream_script_compile_t*,ngx_str_t*,ngx_uint_t)"
448514,METHOD,stream\ngx_stream_script.c:<global>,TYPE_DECL,"size_t
ngx_stream_script_copy_len_code(ngx_stream_script_engine_t *e)
{
    ngx_stream_script_copy_code_t  *code;

    code = (ngx_stream_script_copy_code_t *) e->ip;

    e->ip += sizeof(ngx_stream_script_copy_code_t);

    return code->len;
}",1,1,stream\ngx_stream_script.c,ngx_stream_script_copy_len_code,,false,678,688,ngx_stream_script_copy_len_code,,,24,size_t ngx_stream_script_copy_len_code (ngx_stream_script_engine_t*)
448537,METHOD,stream\ngx_stream_script.c:<global>,TYPE_DECL,"void
ngx_stream_script_copy_code(ngx_stream_script_engine_t *e)
{
    u_char                         *p;
    ngx_stream_script_copy_code_t  *code;

    code = (ngx_stream_script_copy_code_t *) e->ip;

    p = e->pos;

    if (!e->skip) {
        e->pos = ngx_copy(p, e->ip + sizeof(ngx_stream_script_copy_code_t),
                          code->len);
    }

    e->ip += sizeof(ngx_stream_script_copy_code_t)
          + ((code->len + sizeof(uintptr_t) - 1) & ~(sizeof(uintptr_t) - 1));

    ngx_log_debug2(NGX_LOG_DEBUG_STREAM, e->session->connection->log, 0,
                   ""stream script copy: \""%*s\"""", e->pos - p, p);
}",1,1,stream\ngx_stream_script.c,ngx_stream_script_copy_code,,false,691,711,ngx_stream_script_copy_code,,,25,void ngx_stream_script_copy_code (ngx_stream_script_engine_t*)
448615,METHOD,stream\ngx_stream_script.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_script_add_var_code(ngx_stream_script_compile_t *sc, ngx_str_t *name)
{
    ngx_int_t                      index, *p;
    ngx_stream_script_var_code_t  *code;

    index = ngx_stream_get_variable_index(sc->cf, name);

    if (index == NGX_ERROR) {
        return NGX_ERROR;
    }

    if (sc->flushes) {
        p = ngx_array_push(*sc->flushes);
        if (p == NULL) {
            return NGX_ERROR;
        }

        *p = index;
    }

    code = ngx_stream_script_add_code(*sc->lengths,
                                      sizeof(ngx_stream_script_var_code_t),
                                      NULL);
    if (code == NULL) {
        return NGX_ERROR;
    }

    code->code = (ngx_stream_script_code_pt) (void *)
                                           ngx_stream_script_copy_var_len_code;
    code->index = (uintptr_t) index;

    code = ngx_stream_script_add_code(*sc->values,
                                      sizeof(ngx_stream_script_var_code_t),
 ...",1,1,stream\ngx_stream_script.c,ngx_stream_script_add_var_code,,false,714,757,ngx_stream_script_add_var_code,,,26,"ngx_int_t ngx_stream_script_add_var_code (ngx_stream_script_compile_t*,ngx_str_t*)"
448728,METHOD,stream\ngx_stream_script.c:<global>,TYPE_DECL,"size_t
ngx_stream_script_copy_var_len_code(ngx_stream_script_engine_t *e)
{
    ngx_stream_variable_value_t   *value;
    ngx_stream_script_var_code_t  *code;

    code = (ngx_stream_script_var_code_t *) e->ip;

    e->ip += sizeof(ngx_stream_script_var_code_t);

    if (e->flushed) {
        value = ngx_stream_get_indexed_variable(e->session, code->index);

    } else {
        value = ngx_stream_get_flushed_variable(e->session, code->index);
    }

    if (value && !value->not_found) {
        return value->len;
    }

    return 0;
}",1,1,stream\ngx_stream_script.c,ngx_stream_script_copy_var_len_code,,false,760,782,ngx_stream_script_copy_var_len_code,,,27,size_t ngx_stream_script_copy_var_len_code (ngx_stream_script_engine_t*)
448787,METHOD,stream\ngx_stream_script.c:<global>,TYPE_DECL,"void
ngx_stream_script_copy_var_code(ngx_stream_script_engine_t *e)
{
    u_char                        *p;
    ngx_stream_variable_value_t   *value;
    ngx_stream_script_var_code_t  *code;

    code = (ngx_stream_script_var_code_t *) e->ip;

    e->ip += sizeof(ngx_stream_script_var_code_t);

    if (!e->skip) {

        if (e->flushed) {
            value = ngx_stream_get_indexed_variable(e->session, code->index);

        } else {
            value = ngx_stream_get_flushed_variable(e->session, code->index);
        }

        if (value && !value->not_found) {
            p = e->pos;
            e->pos = ngx_copy(p, value->data, value->len);

            ngx_log_debug2(NGX_LOG_DEBUG_STREAM,
                           e->session->connection->log, 0,
                           ""stream script var: \""%*s\"""", e->pos - p, p);
        }
    }
}",1,1,stream\ngx_stream_script.c,ngx_stream_script_copy_var_code,,false,785,814,ngx_stream_script_copy_var_code,,,28,void ngx_stream_script_copy_var_code (ngx_stream_script_engine_t*)
448881,METHOD,stream\ngx_stream_script.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_script_add_full_name_code(ngx_stream_script_compile_t *sc)
{
    ngx_stream_script_full_name_code_t  *code;

    code = ngx_stream_script_add_code(*sc->lengths,
                                    sizeof(ngx_stream_script_full_name_code_t),
                                    NULL);
    if (code == NULL) {
        return NGX_ERROR;
    }

    code->code = (ngx_stream_script_code_pt) (void *)
                                          ngx_stream_script_full_name_len_code;
    code->conf_prefix = sc->conf_prefix;

    code = ngx_stream_script_add_code(*sc->values,
                        sizeof(ngx_stream_script_full_name_code_t), &sc->main);
    if (code == NULL) {
        return NGX_ERROR;
    }

    code->code = ngx_stream_script_full_name_code;
    code->conf_prefix = sc->conf_prefix;

    return NGX_OK;
}",1,1,stream\ngx_stream_script.c,ngx_stream_script_add_full_name_code,,false,912,938,ngx_stream_script_add_full_name_code,,,29,ngx_int_t ngx_stream_script_add_full_name_code (ngx_stream_script_compile_t*)
448954,METHOD,stream\ngx_stream_script.c:<global>,TYPE_DECL,"static size_t
ngx_stream_script_full_name_len_code(ngx_stream_script_engine_t *e)
{
    ngx_stream_script_full_name_code_t  *code;

    code = (ngx_stream_script_full_name_code_t *) e->ip;

    e->ip += sizeof(ngx_stream_script_full_name_code_t);

    return code->conf_prefix ? ngx_cycle->conf_prefix.len:
                               ngx_cycle->prefix.len;
}",1,1,stream\ngx_stream_script.c,ngx_stream_script_full_name_len_code,,false,941,952,ngx_stream_script_full_name_len_code,,,30,size_t ngx_stream_script_full_name_len_code (ngx_stream_script_engine_t*)
448988,METHOD,stream\ngx_stream_script.c:<global>,TYPE_DECL,"static void
ngx_stream_script_full_name_code(ngx_stream_script_engine_t *e)
{
    ngx_stream_script_full_name_code_t  *code;

    ngx_str_t  value, *prefix;

    code = (ngx_stream_script_full_name_code_t *) e->ip;

    value.data = e->buf.data;
    value.len = e->pos - e->buf.data;

    prefix = code->conf_prefix ? (ngx_str_t *) &ngx_cycle->conf_prefix:
                                 (ngx_str_t *) &ngx_cycle->prefix;

    if (ngx_get_full_name(e->session->connection->pool, prefix, &value)
        != NGX_OK)
    {
        e->ip = ngx_stream_script_exit;
        return;
    }

    e->buf = value;

    ngx_log_debug1(NGX_LOG_DEBUG_STREAM, e->session->connection->log, 0,
                   ""stream script fullname: \""%V\"""", &value);

    e->ip += sizeof(ngx_stream_script_full_name_code_t);
}",1,16,stream\ngx_stream_script.c,ngx_stream_script_full_name_code,,false,955,983,ngx_stream_script_full_name_code,,,31,void ngx_stream_script_full_name_code (ngx_stream_script_engine_t*)
449102,METHOD,stream\ngx_stream_script.h:<global>,TYPE_DECL,<global>,1,43,stream\ngx_stream_script.h,stream\ngx_stream_script.h:<global>,,false,1,135,<global>,,,1,
449147,METHOD,stream\ngx_stream_script.h:<global>,TYPE_DECL,typedef void (*ngx_stream_script_code_pt) (ngx_stream_script_engine_t *e);,14,73,stream\ngx_stream_script.h,ngx_stream_script_code_pt,,false,77,77,ngx_stream_script_code_pt,,,9,void ngx_stream_script_code_pt (ngx_stream_script_engine_t*)
449152,METHOD,stream\ngx_stream_script.h:<global>,TYPE_DECL,typedef size_t (*ngx_stream_script_len_code_pt) (ngx_stream_script_engine_t *e);,16,79,stream\ngx_stream_script.h,ngx_stream_script_len_code_pt,,false,78,78,ngx_stream_script_len_code_pt,,,10,size_t ngx_stream_script_len_code_pt (ngx_stream_script_engine_t*)
449173,METHOD,stream\ngx_stream_script.h:<global>,TYPE_DECL,"void ngx_stream_script_flush_complex_value(ngx_stream_session_t *s,
    ngx_stream_complex_value_t *val);",6,36,stream\ngx_stream_script.h,ngx_stream_script_flush_complex_value,,false,105,106,ngx_stream_script_flush_complex_value,,,19,"void ngx_stream_script_flush_complex_value (ngx_stream_session_t*,ngx_stream_complex_value_t*)"
449179,METHOD,stream\ngx_stream_script.h:<global>,TYPE_DECL,"ngx_int_t ngx_stream_complex_value(ngx_stream_session_t *s,
    ngx_stream_complex_value_t *val, ngx_str_t *value);",11,54,stream\ngx_stream_script.h,ngx_stream_complex_value,,false,107,108,ngx_stream_complex_value,,,20,"ngx_int_t ngx_stream_complex_value (ngx_stream_session_t*,ngx_stream_complex_value_t*,ngx_str_t*)"
449186,METHOD,stream\ngx_stream_script.h:<global>,TYPE_DECL,"size_t ngx_stream_complex_value_size(ngx_stream_session_t *s,
    ngx_stream_complex_value_t *val, size_t default_value);",8,58,stream\ngx_stream_script.h,ngx_stream_complex_value_size,,false,109,110,ngx_stream_complex_value_size,,,21,"size_t ngx_stream_complex_value_size (ngx_stream_session_t*,ngx_stream_complex_value_t*,size_t)"
449193,METHOD,stream\ngx_stream_script.h:<global>,TYPE_DECL,"ngx_int_t ngx_stream_compile_complex_value(
    ngx_stream_compile_complex_value_t *ccv);",11,44,stream\ngx_stream_script.h,ngx_stream_compile_complex_value,,false,111,112,ngx_stream_compile_complex_value,,,22,ngx_int_t ngx_stream_compile_complex_value (ngx_stream_compile_complex_value_t*)
449198,METHOD,stream\ngx_stream_script.h:<global>,TYPE_DECL,"char *ngx_stream_set_complex_value_slot(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",6,15,stream\ngx_stream_script.h,ngx_stream_set_complex_value_slot,,false,113,114,ngx_stream_set_complex_value_slot,,,23,"char* ngx_stream_set_complex_value_slot (ngx_conf_t*,ngx_command_t*,void*)"
449205,METHOD,stream\ngx_stream_script.h:<global>,TYPE_DECL,"char *ngx_stream_set_complex_value_size_slot(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",6,15,stream\ngx_stream_script.h,ngx_stream_set_complex_value_size_slot,,false,115,116,ngx_stream_set_complex_value_size_slot,,,24,"char* ngx_stream_set_complex_value_size_slot (ngx_conf_t*,ngx_command_t*,void*)"
449212,METHOD,stream\ngx_stream_script.h:<global>,TYPE_DECL,ngx_uint_t ngx_stream_script_variables_count(ngx_str_t *value);,12,62,stream\ngx_stream_script.h,ngx_stream_script_variables_count,,false,119,119,ngx_stream_script_variables_count,,,25,ngx_uint_t ngx_stream_script_variables_count (ngx_str_t*)
449217,METHOD,stream\ngx_stream_script.h:<global>,TYPE_DECL,ngx_int_t ngx_stream_script_compile(ngx_stream_script_compile_t *sc);,11,68,stream\ngx_stream_script.h,ngx_stream_script_compile,,false,120,120,ngx_stream_script_compile,,,26,ngx_int_t ngx_stream_script_compile (ngx_stream_script_compile_t*)
449222,METHOD,stream\ngx_stream_script.h:<global>,TYPE_DECL,"u_char *ngx_stream_script_run(ngx_stream_session_t *s, ngx_str_t *value,
    void *code_lengths, size_t reserved, void *code_values);",8,59,stream\ngx_stream_script.h,ngx_stream_script_run,,false,121,122,ngx_stream_script_run,,,27,"u_char* ngx_stream_script_run (ngx_stream_session_t*,ngx_str_t*,void*,size_t,void*)"
449231,METHOD,stream\ngx_stream_script.h:<global>,TYPE_DECL,"void ngx_stream_script_flush_no_cacheable_variables(ngx_stream_session_t *s,
    ngx_array_t *indices);",6,25,stream\ngx_stream_script.h,ngx_stream_script_flush_no_cacheable_variables,,false,123,124,ngx_stream_script_flush_no_cacheable_variables,,,28,"void ngx_stream_script_flush_no_cacheable_variables (ngx_stream_session_t*,ngx_array_t*)"
449237,METHOD,stream\ngx_stream_script.h:<global>,TYPE_DECL,"void *ngx_stream_script_add_code(ngx_array_t *codes, size_t size, void *code);",6,77,stream\ngx_stream_script.h,ngx_stream_script_add_code,,false,126,126,ngx_stream_script_add_code,,,29,"void* ngx_stream_script_add_code (ngx_array_t*,size_t,void*)"
449244,METHOD,stream\ngx_stream_script.h:<global>,TYPE_DECL,size_t ngx_stream_script_copy_len_code(ngx_stream_script_engine_t *e);,8,69,stream\ngx_stream_script.h,ngx_stream_script_copy_len_code,,false,128,128,ngx_stream_script_copy_len_code,,,30,size_t ngx_stream_script_copy_len_code (ngx_stream_script_engine_t*)
449249,METHOD,stream\ngx_stream_script.h:<global>,TYPE_DECL,void ngx_stream_script_copy_code(ngx_stream_script_engine_t *e);,6,63,stream\ngx_stream_script.h,ngx_stream_script_copy_code,,false,129,129,ngx_stream_script_copy_code,,,31,void ngx_stream_script_copy_code (ngx_stream_script_engine_t*)
449254,METHOD,stream\ngx_stream_script.h:<global>,TYPE_DECL,size_t ngx_stream_script_copy_var_len_code(ngx_stream_script_engine_t *e);,8,73,stream\ngx_stream_script.h,ngx_stream_script_copy_var_len_code,,false,130,130,ngx_stream_script_copy_var_len_code,,,32,size_t ngx_stream_script_copy_var_len_code (ngx_stream_script_engine_t*)
449259,METHOD,stream\ngx_stream_script.h:<global>,TYPE_DECL,void ngx_stream_script_copy_var_code(ngx_stream_script_engine_t *e);,6,67,stream\ngx_stream_script.h,ngx_stream_script_copy_var_code,,false,131,131,ngx_stream_script_copy_var_code,,,33,void ngx_stream_script_copy_var_code (ngx_stream_script_engine_t*)
449264,METHOD,stream\ngx_stream_script.h:<global>,TYPE_DECL,size_t ngx_stream_script_copy_capture_len_code(ngx_stream_script_engine_t *e);,8,77,stream\ngx_stream_script.h,ngx_stream_script_copy_capture_len_code,,false,132,132,ngx_stream_script_copy_capture_len_code,,,34,size_t ngx_stream_script_copy_capture_len_code (ngx_stream_script_engine_t*)
449269,METHOD,stream\ngx_stream_script.h:<global>,TYPE_DECL,void ngx_stream_script_copy_capture_code(ngx_stream_script_engine_t *e);,6,71,stream\ngx_stream_script.h,ngx_stream_script_copy_capture_code,,false,133,133,ngx_stream_script_copy_capture_code,,,35,void ngx_stream_script_copy_capture_code (ngx_stream_script_engine_t*)
449283,METHOD,stream\ngx_stream_split_clients_module.c:<global>,TYPE_DECL,<global>,1,1,stream\ngx_stream_split_clients_module.c,stream\ngx_stream_split_clients_module.c:<global>,,false,1,244,<global>,,,1,
449293,METHOD,stream\ngx_stream_split_clients_module.c:<global>,TYPE_DECL,"static char *ngx_conf_split_clients_block(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,stream\ngx_stream_split_clients_module.c,ngx_conf_split_clients_block,,false,25,26,ngx_conf_split_clients_block,,,5,"char* ngx_conf_split_clients_block (ngx_conf_t*,ngx_command_t*,void*)"
449300,METHOD,stream\ngx_stream_split_clients_module.c:<global>,TYPE_DECL,"static char *ngx_stream_split_clients(ngx_conf_t *cf, ngx_command_t *dummy,
    void *conf);",13,15,stream\ngx_stream_split_clients_module.c,ngx_stream_split_clients,,false,27,28,ngx_stream_split_clients,,,6,"char* ngx_stream_split_clients (ngx_conf_t*,ngx_command_t*,void*)"
449351,METHOD,stream\ngx_stream_split_clients_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_split_clients_variable(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data)
{
    ngx_stream_split_clients_ctx_t *ctx =
                                       (ngx_stream_split_clients_ctx_t *) data;

    uint32_t                          hash;
    ngx_str_t                         val;
    ngx_uint_t                        i;
    ngx_stream_split_clients_part_t  *part;

    *v = ngx_stream_variable_null_value;

    if (ngx_stream_complex_value(s, &ctx->value, &val) != NGX_OK) {
        return NGX_OK;
    }

    hash = ngx_murmur_hash2(val.data, val.len);

    part = ctx->parts.elts;

    for (i = 0; i < ctx->parts.nelts; i++) {

        ngx_log_debug2(NGX_LOG_DEBUG_STREAM, s->connection->log, 0,
                       ""stream split: %uD %uD"", hash, part[i].percent);

        if (hash < part[i].percent || part[i].percent == 0) {
            *v = part[i].value;
            return NGX_OK;
        }
    }

    return NGX_OK;
}",1,1,stream\ngx_stream_split_clients_module.c,ngx_stream_split_clients_variable,,false,71,105,ngx_stream_split_clients_variable,,,13,"ngx_int_t ngx_stream_split_clients_variable (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
449461,METHOD,stream\ngx_stream_split_clients_module.c:<global>,TYPE_DECL,"static char *
ngx_conf_split_clients_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char                                *rv;
    uint32_t                             sum, last;
    ngx_str_t                           *value, name;
    ngx_uint_t                           i;
    ngx_conf_t                           save;
    ngx_stream_variable_t               *var;
    ngx_stream_split_clients_ctx_t      *ctx;
    ngx_stream_split_clients_part_t     *part;
    ngx_stream_compile_complex_value_t   ccv;

    ctx = ngx_pcalloc(cf->pool, sizeof(ngx_stream_split_clients_ctx_t));
    if (ctx == NULL) {
        return NGX_CONF_ERROR;
    }

    value = cf->args->elts;

    ngx_memzero(&ccv, sizeof(ngx_stream_compile_complex_value_t));

    ccv.cf = cf;
    ccv.value = &value[1];
    ccv.complex_value = &ctx->value;

    if (ngx_stream_compile_complex_value(&ccv) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    name = value[2];

    if (name.data[0] != '$') {
        ngx_...",1,1,stream\ngx_stream_split_clients_module.c,ngx_conf_split_clients_block,,false,108,196,ngx_conf_split_clients_block,,,14,"char* ngx_conf_split_clients_block (ngx_conf_t*,ngx_command_t*,void*)"
449730,METHOD,stream\ngx_stream_split_clients_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_split_clients(ngx_conf_t *cf, ngx_command_t *dummy, void *conf)
{
    ngx_int_t                         n;
    ngx_str_t                        *value;
    ngx_stream_split_clients_ctx_t   *ctx;
    ngx_stream_split_clients_part_t  *part;

    ctx = cf->ctx;
    value = cf->args->elts;

    part = ngx_array_push(&ctx->parts);
    if (part == NULL) {
        return NGX_CONF_ERROR;
    }

    if (value[0].len == 1 && value[0].data[0] == '*') {
        part->percent = 0;

    } else {
        if (value[0].len == 0 || value[0].data[value[0].len - 1] != '%') {
            goto invalid;
        }

        n = ngx_atofp(value[0].data, value[0].len - 1, 2);
        if (n == NGX_ERROR || n == 0) {
            goto invalid;
        }

        part->percent = (uint32_t) n;
    }

    part->value.len = value[1].len;
    part->value.valid = 1;
    part->value.no_cacheable = 0;
    part->value.not_found = 0;
    part->value.data = value[1].data;

    return NGX_CONF_OK;

...",1,1,stream\ngx_stream_split_clients_module.c,ngx_stream_split_clients,,false,199,244,ngx_stream_split_clients,,,15,"char* ngx_stream_split_clients (ngx_conf_t*,ngx_command_t*,void*)"
449918,METHOD,stream\ngx_stream_ssl_module.c:<global>,TYPE_DECL,<global>,1,25,stream\ngx_stream_ssl_module.c,stream\ngx_stream_ssl_module.c:<global>,,false,1,1053,<global>,,,1,
449920,METHOD,stream\ngx_stream_ssl_module.c:<global>,TYPE_DECL,"typedef ngx_int_t (*ngx_ssl_variable_handler_pt)(ngx_connection_t *c,
    ngx_pool_t *pool, ngx_str_t *s);",19,35,stream\ngx_stream_ssl_module.c,ngx_ssl_variable_handler_pt,,false,13,14,ngx_ssl_variable_handler_pt,,,1,"ngx_int_t ngx_ssl_variable_handler_pt (ngx_connection_t*,ngx_pool_t*,ngx_str_t*)"
449927,METHOD,stream\ngx_stream_ssl_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_stream_ssl_handler(ngx_stream_session_t *s);,18,64,stream\ngx_stream_ssl_module.c,ngx_stream_ssl_handler,,false,21,21,ngx_stream_ssl_handler,,,2,ngx_int_t ngx_stream_ssl_handler (ngx_stream_session_t*)
449932,METHOD,stream\ngx_stream_ssl_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_ssl_init_connection(ngx_ssl_t *ssl,
    ngx_connection_t *c);",18,24,stream\ngx_stream_ssl_module.c,ngx_stream_ssl_init_connection,,false,22,23,ngx_stream_ssl_init_connection,,,3,"ngx_int_t ngx_stream_ssl_init_connection (ngx_ssl_t*,ngx_connection_t*)"
449938,METHOD,stream\ngx_stream_ssl_module.c:<global>,TYPE_DECL,static void ngx_stream_ssl_handshake_handler(ngx_connection_t *c);,13,65,stream\ngx_stream_ssl_module.c,ngx_stream_ssl_handshake_handler,,false,24,24,ngx_stream_ssl_handshake_handler,,,4,void ngx_stream_ssl_handshake_handler (ngx_connection_t*)
449943,METHOD,stream\ngx_stream_ssl_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_ssl_static_variable(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data);",18,51,stream\ngx_stream_ssl_module.c,ngx_stream_ssl_static_variable,,false,31,32,ngx_stream_ssl_static_variable,,,5,"ngx_int_t ngx_stream_ssl_static_variable (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
449950,METHOD,stream\ngx_stream_ssl_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_ssl_variable(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data);",18,51,stream\ngx_stream_ssl_module.c,ngx_stream_ssl_variable,,false,33,34,ngx_stream_ssl_variable,,,6,"ngx_int_t ngx_stream_ssl_variable (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
449957,METHOD,stream\ngx_stream_ssl_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_stream_ssl_add_variables(ngx_conf_t *cf);,18,61,stream\ngx_stream_ssl_module.c,ngx_stream_ssl_add_variables,,false,36,36,ngx_stream_ssl_add_variables,,,7,ngx_int_t ngx_stream_ssl_add_variables (ngx_conf_t*)
449962,METHOD,stream\ngx_stream_ssl_module.c:<global>,TYPE_DECL,static void *ngx_stream_ssl_create_conf(ngx_conf_t *cf);,13,55,stream\ngx_stream_ssl_module.c,ngx_stream_ssl_create_conf,,false,37,37,ngx_stream_ssl_create_conf,,,8,void* ngx_stream_ssl_create_conf (ngx_conf_t*)
449967,METHOD,stream\ngx_stream_ssl_module.c:<global>,TYPE_DECL,"static char *ngx_stream_ssl_merge_conf(ngx_conf_t *cf, void *parent,
    void *child);",13,16,stream\ngx_stream_ssl_module.c,ngx_stream_ssl_merge_conf,,false,38,39,ngx_stream_ssl_merge_conf,,,9,"char* ngx_stream_ssl_merge_conf (ngx_conf_t*,void*,void*)"
449974,METHOD,stream\ngx_stream_ssl_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_ssl_compile_certificates(ngx_conf_t *cf,
    ngx_stream_ssl_conf_t *conf);",18,32,stream\ngx_stream_ssl_module.c,ngx_stream_ssl_compile_certificates,,false,41,42,ngx_stream_ssl_compile_certificates,,,10,"ngx_int_t ngx_stream_ssl_compile_certificates (ngx_conf_t*,ngx_stream_ssl_conf_t*)"
449980,METHOD,stream\ngx_stream_ssl_module.c:<global>,TYPE_DECL,"static char *ngx_stream_ssl_password_file(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,stream\ngx_stream_ssl_module.c,ngx_stream_ssl_password_file,,false,44,45,ngx_stream_ssl_password_file,,,11,"char* ngx_stream_ssl_password_file (ngx_conf_t*,ngx_command_t*,void*)"
449987,METHOD,stream\ngx_stream_ssl_module.c:<global>,TYPE_DECL,"static char *ngx_stream_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,stream\ngx_stream_ssl_module.c,ngx_stream_ssl_session_cache,,false,46,47,ngx_stream_ssl_session_cache,,,12,"char* ngx_stream_ssl_session_cache (ngx_conf_t*,ngx_command_t*,void*)"
449994,METHOD,stream\ngx_stream_ssl_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_stream_ssl_init(ngx_conf_t *cf);,18,52,stream\ngx_stream_ssl_module.c,ngx_stream_ssl_init,,false,48,48,ngx_stream_ssl_init,,,13,ngx_int_t ngx_stream_ssl_init (ngx_conf_t*)
450525,METHOD,stream\ngx_stream_ssl_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_ssl_handler(ngx_stream_session_t *s)
{
    long                    rc;
    X509                   *cert;
    ngx_int_t               rv;
    ngx_connection_t       *c;
    ngx_stream_ssl_conf_t  *sslcf;

    if (!s->ssl) {
        return NGX_OK;
    }

    c = s->connection;

    sslcf = ngx_stream_get_module_srv_conf(s, ngx_stream_ssl_module);

    if (c->ssl == NULL) {
        c->log->action = ""SSL handshaking"";

        rv = ngx_stream_ssl_init_connection(&sslcf->ssl, c);

        if (rv != NGX_OK) {
            return rv;
        }
    }

    if (sslcf->verify) {
        rc = SSL_get_verify_result(c->ssl->connection);

        if (rc != X509_V_OK
            && (sslcf->verify != 3 || !ngx_ssl_verify_error_optional(rc)))
        {
            ngx_log_error(NGX_LOG_INFO, c->log, 0,
                          ""client SSL certificate verify error: (%l:%s)"",
                          rc, X509_verify_cert_error_string(rc));

            ngx_ssl_remove_cached...",1,1,stream\ngx_stream_ssl_module.c,ngx_stream_ssl_handler,,false,296,355,ngx_stream_ssl_handler,,,28,ngx_int_t ngx_stream_ssl_handler (ngx_stream_session_t*)
450679,METHOD,stream\ngx_stream_ssl_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_ssl_init_connection(ngx_ssl_t *ssl, ngx_connection_t *c)
{
    ngx_int_t                    rc;
    ngx_stream_session_t        *s;
    ngx_stream_ssl_conf_t       *sslcf;
    ngx_stream_core_srv_conf_t  *cscf;

    s = c->data;

    cscf = ngx_stream_get_module_srv_conf(s, ngx_stream_core_module);

    if (cscf->tcp_nodelay && ngx_tcp_nodelay(c) != NGX_OK) {
        return NGX_ERROR;
    }

    if (ngx_ssl_create_connection(ssl, c, 0) != NGX_OK) {
        return NGX_ERROR;
    }

    rc = ngx_ssl_handshake(c);

    if (rc == NGX_ERROR) {
        return NGX_ERROR;
    }

    if (rc == NGX_AGAIN) {
        sslcf = ngx_stream_get_module_srv_conf(s, ngx_stream_ssl_module);

        ngx_add_timer(c->read, sslcf->handshake_timeout);

        c->ssl->handler = ngx_stream_ssl_handshake_handler;

        return NGX_AGAIN;
    }

    /* rc == NGX_OK */

    return NGX_OK;
}",1,1,stream\ngx_stream_ssl_module.c,ngx_stream_ssl_init_connection,,false,358,397,ngx_stream_ssl_init_connection,,,29,"ngx_int_t ngx_stream_ssl_init_connection (ngx_ssl_t*,ngx_connection_t*)"
450760,METHOD,stream\ngx_stream_ssl_module.c:<global>,TYPE_DECL,"static void
ngx_stream_ssl_handshake_handler(ngx_connection_t *c)
{
    ngx_stream_session_t  *s;

    s = c->data;

    if (!c->ssl->handshaked) {
        ngx_stream_finalize_session(s, NGX_STREAM_INTERNAL_SERVER_ERROR);
        return;
    }

    if (c->read->timer_set) {
        ngx_del_timer(c->read);
    }

    ngx_stream_core_run_phases(s);
}",1,1,stream\ngx_stream_ssl_module.c,ngx_stream_ssl_handshake_handler,,false,400,417,ngx_stream_ssl_handshake_handler,,,30,void ngx_stream_ssl_handshake_handler (ngx_connection_t*)
450796,METHOD,stream\ngx_stream_ssl_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_ssl_static_variable(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data)
{
    ngx_ssl_variable_handler_pt  handler = (ngx_ssl_variable_handler_pt) data;

    size_t     len;
    ngx_str_t  str;

    if (s->connection->ssl) {

        (void) handler(s->connection, NULL, &str);

        v->data = str.data;

        for (len = 0; v->data[len]; len++) { /* void */ }

        v->len = len;
        v->valid = 1;
        v->no_cacheable = 0;
        v->not_found = 0;

        return NGX_OK;
    }

    v->not_found = 1;

    return NGX_OK;
}",1,1,stream\ngx_stream_ssl_module.c,ngx_stream_ssl_static_variable,,false,487,515,ngx_stream_ssl_static_variable,,,31,"ngx_int_t ngx_stream_ssl_static_variable (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
450876,METHOD,stream\ngx_stream_ssl_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_ssl_variable(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data)
{
    ngx_ssl_variable_handler_pt  handler = (ngx_ssl_variable_handler_pt) data;

    ngx_str_t  str;

    if (s->connection->ssl) {

        if (handler(s->connection, s->connection->pool, &str) != NGX_OK) {
            return NGX_ERROR;
        }

        v->len = str.len;
        v->data = str.data;

        if (v->len) {
            v->valid = 1;
            v->no_cacheable = 0;
            v->not_found = 0;

            return NGX_OK;
        }
    }

    v->not_found = 1;

    return NGX_OK;
}",1,1,stream\ngx_stream_ssl_module.c,ngx_stream_ssl_variable,,false,518,547,ngx_stream_ssl_variable,,,32,"ngx_int_t ngx_stream_ssl_variable (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
450957,METHOD,stream\ngx_stream_ssl_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_ssl_add_variables(ngx_conf_t *cf)
{
    ngx_stream_variable_t  *var, *v;

    for (v = ngx_stream_ssl_vars; v->name.len; v++) {
        var = ngx_stream_add_variable(cf, &v->name, v->flags);
        if (var == NULL) {
            return NGX_ERROR;
        }

        var->get_handler = v->get_handler;
        var->data = v->data;
    }

    return NGX_OK;
}",1,1,stream\ngx_stream_ssl_module.c,ngx_stream_ssl_add_variables,,false,550,566,ngx_stream_ssl_add_variables,,,33,ngx_int_t ngx_stream_ssl_add_variables (ngx_conf_t*)
451011,METHOD,stream\ngx_stream_ssl_module.c:<global>,TYPE_DECL,"static void *
ngx_stream_ssl_create_conf(ngx_conf_t *cf)
{
    ngx_stream_ssl_conf_t  *scf;

    scf = ngx_pcalloc(cf->pool, sizeof(ngx_stream_ssl_conf_t));
    if (scf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     scf->listen = 0;
     *     scf->protocols = 0;
     *     scf->certificate_values = NULL;
     *     scf->dhparam = { 0, NULL };
     *     scf->ecdh_curve = { 0, NULL };
     *     scf->client_certificate = { 0, NULL };
     *     scf->trusted_certificate = { 0, NULL };
     *     scf->crl = { 0, NULL };
     *     scf->ciphers = { 0, NULL };
     *     scf->shm_zone = NULL;
     */

    scf->handshake_timeout = NGX_CONF_UNSET_MSEC;
    scf->certificates = NGX_CONF_UNSET_PTR;
    scf->certificate_keys = NGX_CONF_UNSET_PTR;
    scf->passwords = NGX_CONF_UNSET_PTR;
    scf->prefer_server_ciphers = NGX_CONF_UNSET;
    scf->verify = NGX_CONF_UNSET_UINT;
    scf->verify_depth = NGX_CONF_UNSET_UINT;
    scf->builtin_session_cache...",1,1,stream\ngx_stream_ssl_module.c,ngx_stream_ssl_create_conf,,false,569,607,ngx_stream_ssl_create_conf,,,34,void* ngx_stream_ssl_create_conf (ngx_conf_t*)
451089,METHOD,stream\ngx_stream_ssl_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_stream_ssl_conf_t *prev = parent;
    ngx_stream_ssl_conf_t *conf = child;

    ngx_pool_cleanup_t  *cln;

    ngx_conf_merge_msec_value(conf->handshake_timeout,
                         prev->handshake_timeout, 60000);

    ngx_conf_merge_value(conf->session_timeout,
                         prev->session_timeout, 300);

    ngx_conf_merge_value(conf->prefer_server_ciphers,
                         prev->prefer_server_ciphers, 0);

    ngx_conf_merge_bitmask_value(conf->protocols, prev->protocols,
                         (NGX_CONF_BITMASK_SET|NGX_SSL_TLSv1
                          |NGX_SSL_TLSv1_1|NGX_SSL_TLSv1_2));

    ngx_conf_merge_uint_value(conf->verify, prev->verify, 0);
    ngx_conf_merge_uint_value(conf->verify_depth, prev->verify_depth, 1);

    ngx_conf_merge_ptr_value(conf->certificates, prev->certificates, NULL);
    ngx_conf_merge_ptr_value(conf->certificate_keys, prev->cert...",1,25,stream\ngx_stream_ssl_module.c,ngx_stream_ssl_merge_conf,,false,610,815,ngx_stream_ssl_merge_conf,,,35,"char* ngx_stream_ssl_merge_conf (ngx_conf_t*,void*,void*)"
451646,METHOD,stream\ngx_stream_ssl_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_ssl_compile_certificates(ngx_conf_t *cf,
    ngx_stream_ssl_conf_t *conf)
{
    ngx_str_t                           *cert, *key;
    ngx_uint_t                           i, nelts;
    ngx_stream_complex_value_t          *cv;
    ngx_stream_compile_complex_value_t   ccv;

    cert = conf->certificates->elts;
    key = conf->certificate_keys->elts;
    nelts = conf->certificates->nelts;

    for (i = 0; i < nelts; i++) {

        if (ngx_stream_script_variables_count(&cert[i])) {
            goto found;
        }

        if (ngx_stream_script_variables_count(&key[i])) {
            goto found;
        }
    }

    return NGX_OK;

found:

    conf->certificate_values = ngx_array_create(cf->pool, nelts,
                                           sizeof(ngx_stream_complex_value_t));
    if (conf->certificate_values == NULL) {
        return NGX_ERROR;
    }

    conf->certificate_key_values = ngx_array_create(cf->pool, nelts,
                                 ...",1,1,stream\ngx_stream_ssl_module.c,ngx_stream_ssl_compile_certificates,,false,818,899,ngx_stream_ssl_compile_certificates,,,36,"ngx_int_t ngx_stream_ssl_compile_certificates (ngx_conf_t*,ngx_stream_ssl_conf_t*)"
451880,METHOD,stream\ngx_stream_ssl_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_ssl_password_file(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_stream_ssl_conf_t  *scf = conf;

    ngx_str_t  *value;

    if (scf->passwords != NGX_CONF_UNSET_PTR) {
        return ""is duplicate"";
    }

    value = cf->args->elts;

    scf->passwords = ngx_ssl_read_password_file(cf, &value[1]);

    if (scf->passwords == NULL) {
        return NGX_CONF_ERROR;
    }

    return NGX_CONF_OK;
}",1,1,stream\ngx_stream_ssl_module.c,ngx_stream_ssl_password_file,,false,902,922,ngx_stream_ssl_password_file,,,37,"char* ngx_stream_ssl_password_file (ngx_conf_t*,ngx_command_t*,void*)"
451929,METHOD,stream\ngx_stream_ssl_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_stream_ssl_conf_t  *scf = conf;

    size_t       len;
    ngx_str_t   *value, name, size;
    ngx_int_t    n;
    ngx_uint_t   i, j;

    value = cf->args->elts;

    for (i = 1; i < cf->args->nelts; i++) {

        if (ngx_strcmp(value[i].data, ""off"") == 0) {
            scf->builtin_session_cache = NGX_SSL_NO_SCACHE;
            continue;
        }

        if (ngx_strcmp(value[i].data, ""none"") == 0) {
            scf->builtin_session_cache = NGX_SSL_NONE_SCACHE;
            continue;
        }

        if (ngx_strcmp(value[i].data, ""builtin"") == 0) {
            scf->builtin_session_cache = NGX_SSL_DFLT_BUILTIN_SCACHE;
            continue;
        }

        if (value[i].len > sizeof(""builtin:"") - 1
            && ngx_strncmp(value[i].data, ""builtin:"", sizeof(""builtin:"") - 1)
               == 0)
        {
            n = ngx_atoi(value[i].data + sizeof(""builtin:"") - 1,
        ...",1,1,stream\ngx_stream_ssl_module.c,ngx_stream_ssl_session_cache,,false,925,1034,ngx_stream_ssl_session_cache,,,38,"char* ngx_stream_ssl_session_cache (ngx_conf_t*,ngx_command_t*,void*)"
452280,METHOD,stream\ngx_stream_ssl_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_ssl_init(ngx_conf_t *cf)
{
    ngx_stream_handler_pt        *h;
    ngx_stream_core_main_conf_t  *cmcf;

    cmcf = ngx_stream_conf_get_module_main_conf(cf, ngx_stream_core_module);

    h = ngx_array_push(&cmcf->phases[NGX_STREAM_SSL_PHASE].handlers);
    if (h == NULL) {
        return NGX_ERROR;
    }

    *h = ngx_stream_ssl_handler;

    return NGX_OK;
}",1,1,stream\ngx_stream_ssl_module.c,ngx_stream_ssl_init,,false,1037,1053,ngx_stream_ssl_init,,,39,ngx_int_t ngx_stream_ssl_init (ngx_conf_t*)
452325,METHOD,stream\ngx_stream_ssl_module.h:<global>,TYPE_DECL,<global>,1,40,stream\ngx_stream_ssl_module.h,stream\ngx_stream_ssl_module.h:<global>,,false,1,63,<global>,,,1,
452364,METHOD,stream\ngx_stream_ssl_preread_module.c:<global>,TYPE_DECL,<global>,1,1,stream\ngx_stream_ssl_preread_module.c,stream\ngx_stream_ssl_preread_module.c:<global>,,false,1,664,<global>,,,1,
452382,METHOD,<empty>,<empty>,<empty>,1,,stream\ngx_stream_ssl_preread_module.c,ngx_stream_ssl_preread_ctx_t:<clinit>,,false,17,,<clinit>,,,13,
452391,METHOD,stream\ngx_stream_ssl_preread_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_stream_ssl_preread_handler(ngx_stream_session_t *s);,18,72,stream\ngx_stream_ssl_preread_module.c,ngx_stream_ssl_preread_handler,,false,33,33,ngx_stream_ssl_preread_handler,,,5,ngx_int_t ngx_stream_ssl_preread_handler (ngx_stream_session_t*)
452396,METHOD,stream\ngx_stream_ssl_preread_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_ssl_preread_parse_record(
    ngx_stream_ssl_preread_ctx_t *ctx, u_char *pos, u_char *last);",18,65,stream\ngx_stream_ssl_preread_module.c,ngx_stream_ssl_preread_parse_record,,false,34,35,ngx_stream_ssl_preread_parse_record,,,6,"ngx_int_t ngx_stream_ssl_preread_parse_record (ngx_stream_ssl_preread_ctx_t*,u_char*,u_char*)"
452403,METHOD,stream\ngx_stream_ssl_preread_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_ssl_preread_protocol_variable(
    ngx_stream_session_t *s, ngx_stream_variable_value_t *v, uintptr_t data);",18,76,stream\ngx_stream_ssl_preread_module.c,ngx_stream_ssl_preread_protocol_variable,,false,36,37,ngx_stream_ssl_preread_protocol_variable,,,7,"ngx_int_t ngx_stream_ssl_preread_protocol_variable (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
452410,METHOD,stream\ngx_stream_ssl_preread_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_ssl_preread_server_name_variable(
    ngx_stream_session_t *s, ngx_stream_variable_value_t *v, uintptr_t data);",18,76,stream\ngx_stream_ssl_preread_module.c,ngx_stream_ssl_preread_server_name_variable,,false,38,39,ngx_stream_ssl_preread_server_name_variable,,,8,"ngx_int_t ngx_stream_ssl_preread_server_name_variable (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
452417,METHOD,stream\ngx_stream_ssl_preread_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_ssl_preread_alpn_protocols_variable(
    ngx_stream_session_t *s, ngx_stream_variable_value_t *v, uintptr_t data);",18,76,stream\ngx_stream_ssl_preread_module.c,ngx_stream_ssl_preread_alpn_protocols_variable,,false,40,41,ngx_stream_ssl_preread_alpn_protocols_variable,,,9,"ngx_int_t ngx_stream_ssl_preread_alpn_protocols_variable (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
452424,METHOD,stream\ngx_stream_ssl_preread_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_stream_ssl_preread_add_variables(ngx_conf_t *cf);,18,69,stream\ngx_stream_ssl_preread_module.c,ngx_stream_ssl_preread_add_variables,,false,42,42,ngx_stream_ssl_preread_add_variables,,,10,ngx_int_t ngx_stream_ssl_preread_add_variables (ngx_conf_t*)
452429,METHOD,stream\ngx_stream_ssl_preread_module.c:<global>,TYPE_DECL,static void *ngx_stream_ssl_preread_create_srv_conf(ngx_conf_t *cf);,13,67,stream\ngx_stream_ssl_preread_module.c,ngx_stream_ssl_preread_create_srv_conf,,false,43,43,ngx_stream_ssl_preread_create_srv_conf,,,11,void* ngx_stream_ssl_preread_create_srv_conf (ngx_conf_t*)
452434,METHOD,stream\ngx_stream_ssl_preread_module.c:<global>,TYPE_DECL,"static char *ngx_stream_ssl_preread_merge_srv_conf(ngx_conf_t *cf, void *parent,
    void *child);",13,16,stream\ngx_stream_ssl_preread_module.c,ngx_stream_ssl_preread_merge_srv_conf,,false,44,45,ngx_stream_ssl_preread_merge_srv_conf,,,12,"char* ngx_stream_ssl_preread_merge_srv_conf (ngx_conf_t*,void*,void*)"
452441,METHOD,stream\ngx_stream_ssl_preread_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_stream_ssl_preread_init(ngx_conf_t *cf);,18,60,stream\ngx_stream_ssl_preread_module.c,ngx_stream_ssl_preread_init,,false,46,46,ngx_stream_ssl_preread_init,,,13,ngx_int_t ngx_stream_ssl_preread_init (ngx_conf_t*)
452521,METHOD,stream\ngx_stream_ssl_preread_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_ssl_preread_handler(ngx_stream_session_t *s)
{
    u_char                             *last, *p;
    size_t                              len;
    ngx_int_t                           rc;
    ngx_connection_t                   *c;
    ngx_stream_ssl_preread_ctx_t       *ctx;
    ngx_stream_ssl_preread_srv_conf_t  *sscf;

    c = s->connection;

    ngx_log_debug0(NGX_LOG_DEBUG_STREAM, c->log, 0, ""ssl preread handler"");

    sscf = ngx_stream_get_module_srv_conf(s, ngx_stream_ssl_preread_module);

    if (!sscf->enabled) {
        return NGX_DECLINED;
    }

    if (c->type != SOCK_STREAM) {
        return NGX_DECLINED;
    }

    if (c->buffer == NULL) {
        return NGX_AGAIN;
    }

    ctx = ngx_stream_get_module_ctx(s, ngx_stream_ssl_preread_module);
    if (ctx == NULL) {
        ctx = ngx_pcalloc(c->pool, sizeof(ngx_stream_ssl_preread_ctx_t));
        if (ctx == NULL) {
            return NGX_ERROR;
        }

        ngx_stream_set_ctx(s, ctx, ngx_...",1,1,stream\ngx_stream_ssl_preread_module.c,ngx_stream_ssl_preread_handler,,false,105,200,ngx_stream_ssl_preread_handler,,,22,ngx_int_t ngx_stream_ssl_preread_handler (ngx_stream_session_t*)
452800,METHOD,stream\ngx_stream_ssl_preread_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_ssl_preread_parse_record(ngx_stream_ssl_preread_ctx_t *ctx,
    u_char *pos, u_char *last)
{
    size_t   left, n, size, ext;
    u_char  *dst, *p;

    enum {
        sw_start = 0,
        sw_header,          /* handshake msg_type, length */
        sw_version,         /* client_version */
        sw_random,          /* random */
        sw_sid_len,         /* session_id length */
        sw_sid,             /* session_id */
        sw_cs_len,          /* cipher_suites length */
        sw_cs,              /* cipher_suites */
        sw_cm_len,          /* compression_methods length */
        sw_cm,              /* compression_methods */
        sw_ext,             /* extension */
        sw_ext_header,      /* extension_type, extension_data length */
        sw_sni_len,         /* SNI length */
        sw_sni_host_head,   /* SNI name_type, host_name length */
        sw_sni_host,        /* SNI host_name */
        sw_alpn_len,        /* ALPN length */
...",1,1,stream\ngx_stream_ssl_preread_module.c,ngx_stream_ssl_preread_parse_record,,false,203,496,ngx_stream_ssl_preread_parse_record,,,23,"ngx_int_t ngx_stream_ssl_preread_parse_record (ngx_stream_ssl_preread_ctx_t*,u_char*,u_char*)"
453579,METHOD,stream\ngx_stream_ssl_preread_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_ssl_preread_protocol_variable(ngx_stream_session_t *s,
    ngx_variable_value_t *v, uintptr_t data)
{
    ngx_str_t                      version;
    ngx_stream_ssl_preread_ctx_t  *ctx;

    ctx = ngx_stream_get_module_ctx(s, ngx_stream_ssl_preread_module);

    if (ctx == NULL) {
        v->not_found = 1;
        return NGX_OK;
    }

    /* SSL_get_version() format */

    ngx_str_null(&version);

    switch (ctx->version[0]) {
    case 0:
        switch (ctx->version[1]) {
        case 2:
            ngx_str_set(&version, ""SSLv2"");
            break;
        }
        break;
    case 3:
        switch (ctx->version[1]) {
        case 0:
            ngx_str_set(&version, ""SSLv3"");
            break;
        case 1:
            ngx_str_set(&version, ""TLSv1"");
            break;
        case 2:
            ngx_str_set(&version, ""TLSv1.1"");
            break;
        case 3:
            ngx_str_set(&version, ""TLSv1.2"");
            break;
        case 4:
 ...",1,1,stream\ngx_stream_ssl_preread_module.c,ngx_stream_ssl_preread_protocol_variable,,false,499,552,ngx_stream_ssl_preread_protocol_variable,,,24,"ngx_int_t ngx_stream_ssl_preread_protocol_variable (ngx_stream_session_t*,ngx_variable_value_t*,uintptr_t)"
453707,METHOD,stream\ngx_stream_ssl_preread_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_ssl_preread_server_name_variable(ngx_stream_session_t *s,
    ngx_variable_value_t *v, uintptr_t data)
{
    ngx_stream_ssl_preread_ctx_t  *ctx;

    ctx = ngx_stream_get_module_ctx(s, ngx_stream_ssl_preread_module);

    if (ctx == NULL) {
        v->not_found = 1;
        return NGX_OK;
    }

    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->len = ctx->host.len;
    v->data = ctx->host.data;

    return NGX_OK;
}",1,1,stream\ngx_stream_ssl_preread_module.c,ngx_stream_ssl_preread_server_name_variable,,false,555,575,ngx_stream_ssl_preread_server_name_variable,,,25,"ngx_int_t ngx_stream_ssl_preread_server_name_variable (ngx_stream_session_t*,ngx_variable_value_t*,uintptr_t)"
453767,METHOD,stream\ngx_stream_ssl_preread_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_ssl_preread_alpn_protocols_variable(ngx_stream_session_t *s,
    ngx_variable_value_t *v, uintptr_t data)
{
    ngx_stream_ssl_preread_ctx_t  *ctx;

    ctx = ngx_stream_get_module_ctx(s, ngx_stream_ssl_preread_module);

    if (ctx == NULL) {
        v->not_found = 1;
        return NGX_OK;
    }

    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->len = ctx->alpn.len;
    v->data = ctx->alpn.data;

    return NGX_OK;
}",1,1,stream\ngx_stream_ssl_preread_module.c,ngx_stream_ssl_preread_alpn_protocols_variable,,false,578,598,ngx_stream_ssl_preread_alpn_protocols_variable,,,26,"ngx_int_t ngx_stream_ssl_preread_alpn_protocols_variable (ngx_stream_session_t*,ngx_variable_value_t*,uintptr_t)"
453827,METHOD,stream\ngx_stream_ssl_preread_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_ssl_preread_add_variables(ngx_conf_t *cf)
{
    ngx_stream_variable_t  *var, *v;

    for (v = ngx_stream_ssl_preread_vars; v->name.len; v++) {
        var = ngx_stream_add_variable(cf, &v->name, v->flags);
        if (var == NULL) {
            return NGX_ERROR;
        }

        var->get_handler = v->get_handler;
        var->data = v->data;
    }

    return NGX_OK;
}",1,1,stream\ngx_stream_ssl_preread_module.c,ngx_stream_ssl_preread_add_variables,,false,601,617,ngx_stream_ssl_preread_add_variables,,,27,ngx_int_t ngx_stream_ssl_preread_add_variables (ngx_conf_t*)
453881,METHOD,stream\ngx_stream_ssl_preread_module.c:<global>,TYPE_DECL,"static void *
ngx_stream_ssl_preread_create_srv_conf(ngx_conf_t *cf)
{
    ngx_stream_ssl_preread_srv_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_stream_ssl_preread_srv_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    conf->enabled = NGX_CONF_UNSET;

    return conf;
}",1,1,stream\ngx_stream_ssl_preread_module.c,ngx_stream_ssl_preread_create_srv_conf,,false,620,633,ngx_stream_ssl_preread_create_srv_conf,,,28,void* ngx_stream_ssl_preread_create_srv_conf (ngx_conf_t*)
453909,METHOD,stream\ngx_stream_ssl_preread_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_ssl_preread_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_stream_ssl_preread_srv_conf_t *prev = parent;
    ngx_stream_ssl_preread_srv_conf_t *conf = child;

    ngx_conf_merge_value(conf->enabled, prev->enabled, 0);

    return NGX_CONF_OK;
}",1,1,stream\ngx_stream_ssl_preread_module.c,ngx_stream_ssl_preread_merge_srv_conf,,false,636,645,ngx_stream_ssl_preread_merge_srv_conf,,,29,"char* ngx_stream_ssl_preread_merge_srv_conf (ngx_conf_t*,void*,void*)"
453934,METHOD,stream\ngx_stream_ssl_preread_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_ssl_preread_init(ngx_conf_t *cf)
{
    ngx_stream_handler_pt        *h;
    ngx_stream_core_main_conf_t  *cmcf;

    cmcf = ngx_stream_conf_get_module_main_conf(cf, ngx_stream_core_module);

    h = ngx_array_push(&cmcf->phases[NGX_STREAM_PREREAD_PHASE].handlers);
    if (h == NULL) {
        return NGX_ERROR;
    }

    *h = ngx_stream_ssl_preread_handler;

    return NGX_OK;
}",1,1,stream\ngx_stream_ssl_preread_module.c,ngx_stream_ssl_preread_init,,false,648,664,ngx_stream_ssl_preread_init,,,30,ngx_int_t ngx_stream_ssl_preread_init (ngx_conf_t*)
453979,METHOD,stream\ngx_stream_upstream.c:<global>,TYPE_DECL,<global>,1,1,stream\ngx_stream_upstream.c,stream\ngx_stream_upstream.c:<global>,,false,1,715,<global>,,,1,
453981,METHOD,stream\ngx_stream_upstream.c:<global>,TYPE_DECL,static ngx_int_t ngx_stream_upstream_add_variables(ngx_conf_t *cf);,18,66,stream\ngx_stream_upstream.c,ngx_stream_upstream_add_variables,,false,13,13,ngx_stream_upstream_add_variables,,,1,ngx_int_t ngx_stream_upstream_add_variables (ngx_conf_t*)
453986,METHOD,stream\ngx_stream_upstream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_upstream_addr_variable(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data);",18,51,stream\ngx_stream_upstream.c,ngx_stream_upstream_addr_variable,,false,14,15,ngx_stream_upstream_addr_variable,,,2,"ngx_int_t ngx_stream_upstream_addr_variable (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
453993,METHOD,stream\ngx_stream_upstream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_upstream_response_time_variable(
    ngx_stream_session_t *s, ngx_stream_variable_value_t *v, uintptr_t data);",18,76,stream\ngx_stream_upstream.c,ngx_stream_upstream_response_time_variable,,false,16,17,ngx_stream_upstream_response_time_variable,,,3,"ngx_int_t ngx_stream_upstream_response_time_variable (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
454000,METHOD,stream\ngx_stream_upstream.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_upstream_bytes_variable(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data);",18,51,stream\ngx_stream_upstream.c,ngx_stream_upstream_bytes_variable,,false,18,19,ngx_stream_upstream_bytes_variable,,,4,"ngx_int_t ngx_stream_upstream_bytes_variable (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
454007,METHOD,stream\ngx_stream_upstream.c:<global>,TYPE_DECL,"static char *ngx_stream_upstream(ngx_conf_t *cf, ngx_command_t *cmd,
    void *dummy);",13,16,stream\ngx_stream_upstream.c,ngx_stream_upstream,,false,21,22,ngx_stream_upstream,,,5,"char* ngx_stream_upstream (ngx_conf_t*,ngx_command_t*,void*)"
454014,METHOD,stream\ngx_stream_upstream.c:<global>,TYPE_DECL,"static char *ngx_stream_upstream_server(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,stream\ngx_stream_upstream.c,ngx_stream_upstream_server,,false,23,24,ngx_stream_upstream_server,,,6,"char* ngx_stream_upstream_server (ngx_conf_t*,ngx_command_t*,void*)"
454021,METHOD,stream\ngx_stream_upstream.c:<global>,TYPE_DECL,static void *ngx_stream_upstream_create_main_conf(ngx_conf_t *cf);,13,65,stream\ngx_stream_upstream.c,ngx_stream_upstream_create_main_conf,,false,25,25,ngx_stream_upstream_create_main_conf,,,7,void* ngx_stream_upstream_create_main_conf (ngx_conf_t*)
454026,METHOD,stream\ngx_stream_upstream.c:<global>,TYPE_DECL,"static char *ngx_stream_upstream_init_main_conf(ngx_conf_t *cf, void *conf);",13,75,stream\ngx_stream_upstream.c,ngx_stream_upstream_init_main_conf,,false,26,26,ngx_stream_upstream_init_main_conf,,,8,"char* ngx_stream_upstream_init_main_conf (ngx_conf_t*,void*)"
454139,METHOD,stream\ngx_stream_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_upstream_add_variables(ngx_conf_t *cf)
{
    ngx_stream_variable_t  *var, *v;

    for (v = ngx_stream_upstream_vars; v->name.len; v++) {
        var = ngx_stream_add_variable(cf, &v->name, v->flags);
        if (var == NULL) {
            return NGX_ERROR;
        }

        var->get_handler = v->get_handler;
        var->data = v->data;
    }

    return NGX_OK;
}",1,1,stream\ngx_stream_upstream.c,ngx_stream_upstream_add_variables,,false,107,123,ngx_stream_upstream_add_variables,,,17,ngx_int_t ngx_stream_upstream_add_variables (ngx_conf_t*)
454193,METHOD,stream\ngx_stream_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_upstream_addr_variable(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data)
{
    u_char                       *p;
    size_t                        len;
    ngx_uint_t                    i;
    ngx_stream_upstream_state_t  *state;

    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;

    if (s->upstream_states == NULL || s->upstream_states->nelts == 0) {
        v->not_found = 1;
        return NGX_OK;
    }

    len = 0;
    state = s->upstream_states->elts;

    for (i = 0; i < s->upstream_states->nelts; i++) {
        if (state[i].peer) {
            len += state[i].peer->len;
        }

        len += 2;
    }

    p = ngx_pnalloc(s->connection->pool, len);
    if (p == NULL) {
        return NGX_ERROR;
    }

    v->data = p;

    i = 0;

    for ( ;; ) {
        if (state[i].peer) {
            p = ngx_cpymem(p, state[i].peer->data, state[i].peer->len);
        }

        if (++i == s->upstream_states->nelts) {
...",1,1,stream\ngx_stream_upstream.c,ngx_stream_upstream_addr_variable,,false,126,180,ngx_stream_upstream_addr_variable,,,18,"ngx_int_t ngx_stream_upstream_addr_variable (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
454369,METHOD,stream\ngx_stream_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_upstream_bytes_variable(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data)
{
    u_char                       *p;
    size_t                        len;
    ngx_uint_t                    i;
    ngx_stream_upstream_state_t  *state;

    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;

    if (s->upstream_states == NULL || s->upstream_states->nelts == 0) {
        v->not_found = 1;
        return NGX_OK;
    }

    len = s->upstream_states->nelts * (NGX_OFF_T_LEN + 2);

    p = ngx_pnalloc(s->connection->pool, len);
    if (p == NULL) {
        return NGX_ERROR;
    }

    v->data = p;

    i = 0;
    state = s->upstream_states->elts;

    for ( ;; ) {

        if (data == 1) {
            p = ngx_sprintf(p, ""%O"", state[i].bytes_received);

        } else {
            p = ngx_sprintf(p, ""%O"", state[i].bytes_sent);
        }

        if (++i == s->upstream_states->nelts) {
            break;
        }

        *p++ = '...",1,1,stream\ngx_stream_upstream.c,ngx_stream_upstream_bytes_variable,,false,183,233,ngx_stream_upstream_bytes_variable,,,19,"ngx_int_t ngx_stream_upstream_bytes_variable (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
454521,METHOD,stream\ngx_stream_upstream.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_upstream_response_time_variable(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data)
{
    u_char                       *p;
    size_t                        len;
    ngx_uint_t                    i;
    ngx_msec_int_t                ms;
    ngx_stream_upstream_state_t  *state;

    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;

    if (s->upstream_states == NULL || s->upstream_states->nelts == 0) {
        v->not_found = 1;
        return NGX_OK;
    }

    len = s->upstream_states->nelts * (NGX_TIME_T_LEN + 4 + 2);

    p = ngx_pnalloc(s->connection->pool, len);
    if (p == NULL) {
        return NGX_ERROR;
    }

    v->data = p;

    i = 0;
    state = s->upstream_states->elts;

    for ( ;; ) {

        if (data == 1) {
            ms = state[i].first_byte_time;

        } else if (data == 2) {
            ms = state[i].connect_time;

        } else {
            ms = state[i].response_time;
        }

        ...",1,1,stream\ngx_stream_upstream.c,ngx_stream_upstream_response_time_variable,,false,236,298,ngx_stream_upstream_response_time_variable,,,20,"ngx_int_t ngx_stream_upstream_response_time_variable (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
454715,METHOD,stream\ngx_stream_upstream.c:<global>,TYPE_DECL,"static char *
ngx_stream_upstream(ngx_conf_t *cf, ngx_command_t *cmd, void *dummy)
{
    char                            *rv;
    void                            *mconf;
    ngx_str_t                       *value;
    ngx_url_t                        u;
    ngx_uint_t                       m;
    ngx_conf_t                       pcf;
    ngx_stream_module_t             *module;
    ngx_stream_conf_ctx_t           *ctx, *stream_ctx;
    ngx_stream_upstream_srv_conf_t  *uscf;

    ngx_memzero(&u, sizeof(ngx_url_t));

    value = cf->args->elts;
    u.host = value[1];
    u.no_resolve = 1;
    u.no_port = 1;

    uscf = ngx_stream_upstream_add(cf, &u, NGX_STREAM_UPSTREAM_CREATE
                                           |NGX_STREAM_UPSTREAM_WEIGHT
                                           |NGX_STREAM_UPSTREAM_MAX_CONNS
                                           |NGX_STREAM_UPSTREAM_MAX_FAILS
                                           |NGX_STREAM_UPSTREAM_FAIL_TIMEOUT
                 ...",1,1,stream\ngx_stream_upstream.c,ngx_stream_upstream,,false,301,398,ngx_stream_upstream,,,21,"char* ngx_stream_upstream (ngx_conf_t*,ngx_command_t*,void*)"
454993,METHOD,stream\ngx_stream_upstream.c:<global>,TYPE_DECL,"static char *
ngx_stream_upstream_server(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_stream_upstream_srv_conf_t  *uscf = conf;

    time_t                         fail_timeout;
    ngx_str_t                     *value, s;
    ngx_url_t                      u;
    ngx_int_t                      weight, max_conns, max_fails;
    ngx_uint_t                     i;
    ngx_stream_upstream_server_t  *us;

    us = ngx_array_push(uscf->servers);
    if (us == NULL) {
        return NGX_CONF_ERROR;
    }

    ngx_memzero(us, sizeof(ngx_stream_upstream_server_t));

    value = cf->args->elts;

    weight = 1;
    max_conns = 0;
    max_fails = 1;
    fail_timeout = 10;

    for (i = 2; i < cf->args->nelts; i++) {

        if (ngx_strncmp(value[i].data, ""weight="", 7) == 0) {

            if (!(uscf->flags & NGX_STREAM_UPSTREAM_WEIGHT)) {
                goto not_supported;
            }

            weight = ngx_atoi(&value[i].data[7], value[i].len - 7);

            if (weight ...",1,1,stream\ngx_stream_upstream.c,ngx_stream_upstream_server,,false,401,560,ngx_stream_upstream_server,,,22,"char* ngx_stream_upstream_server (ngx_conf_t*,ngx_command_t*,void*)"
455442,METHOD,stream\ngx_stream_upstream.c:<global>,TYPE_DECL,"ngx_stream_upstream_srv_conf_t *
ngx_stream_upstream_add(ngx_conf_t *cf, ngx_url_t *u, ngx_uint_t flags)
{
    ngx_uint_t                        i;
    ngx_stream_upstream_server_t     *us;
    ngx_stream_upstream_srv_conf_t   *uscf, **uscfp;
    ngx_stream_upstream_main_conf_t  *umcf;

    if (!(flags & NGX_STREAM_UPSTREAM_CREATE)) {

        if (ngx_parse_url(cf->pool, u) != NGX_OK) {
            if (u->err) {
                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                                   ""%s in upstream \""%V\"""", u->err, &u->url);
            }

            return NULL;
        }
    }

    umcf = ngx_stream_conf_get_module_main_conf(cf, ngx_stream_upstream_module);

    uscfp = umcf->upstreams.elts;

    for (i = 0; i < umcf->upstreams.nelts; i++) {

        if (uscfp[i]->host.len != u->host.len
            || ngx_strncasecmp(uscfp[i]->host.data, u->host.data, u->host.len)
               != 0)
        {
            continue;
        }

        if ((flags & NGX_STREAM_...",1,1,stream\ngx_stream_upstream.c,ngx_stream_upstream_add,,false,563,668,ngx_stream_upstream_add,,,23,"ngx_stream_upstream_srv_conf_t ngx_stream_upstream_add (ngx_conf_t*,ngx_url_t*,ngx_uint_t)"
455821,METHOD,stream\ngx_stream_upstream.c:<global>,TYPE_DECL,"static void *
ngx_stream_upstream_create_main_conf(ngx_conf_t *cf)
{
    ngx_stream_upstream_main_conf_t  *umcf;

    umcf = ngx_pcalloc(cf->pool, sizeof(ngx_stream_upstream_main_conf_t));
    if (umcf == NULL) {
        return NULL;
    }

    if (ngx_array_init(&umcf->upstreams, cf->pool, 4,
                       sizeof(ngx_stream_upstream_srv_conf_t *))
        != NGX_OK)
    {
        return NULL;
    }

    return umcf;
}",1,1,stream\ngx_stream_upstream.c,ngx_stream_upstream_create_main_conf,,false,671,689,ngx_stream_upstream_create_main_conf,,,24,void* ngx_stream_upstream_create_main_conf (ngx_conf_t*)
455861,METHOD,stream\ngx_stream_upstream.c:<global>,TYPE_DECL,"static char *
ngx_stream_upstream_init_main_conf(ngx_conf_t *cf, void *conf)
{
    ngx_stream_upstream_main_conf_t *umcf = conf;

    ngx_uint_t                        i;
    ngx_stream_upstream_init_pt       init;
    ngx_stream_upstream_srv_conf_t  **uscfp;

    uscfp = umcf->upstreams.elts;

    for (i = 0; i < umcf->upstreams.nelts; i++) {

        init = uscfp[i]->peer.init_upstream
                                         ? uscfp[i]->peer.init_upstream
                                         : ngx_stream_upstream_init_round_robin;

        if (init(cf, uscfp[i]) != NGX_OK) {
            return NGX_CONF_ERROR;
        }
    }

    return NGX_CONF_OK;
}",1,1,stream\ngx_stream_upstream.c,ngx_stream_upstream_init_main_conf,,false,692,715,ngx_stream_upstream_init_main_conf,,,25,"char* ngx_stream_upstream_init_main_conf (ngx_conf_t*,void*)"
455938,METHOD,stream\ngx_stream_upstream.h:<global>,TYPE_DECL,<global>,1,45,stream\ngx_stream_upstream.h,stream\ngx_stream_upstream.h:<global>,,false,1,159,<global>,,,1,
455945,METHOD,stream\ngx_stream_upstream.h:<global>,TYPE_DECL,"typedef ngx_int_t (*ngx_stream_upstream_init_pt)(ngx_conf_t *cf,
    ngx_stream_upstream_srv_conf_t *us);",19,39,stream\ngx_stream_upstream.h,ngx_stream_upstream_init_pt,,false,39,40,ngx_stream_upstream_init_pt,,,5,"ngx_int_t ngx_stream_upstream_init_pt (ngx_conf_t*,ngx_stream_upstream_srv_conf_t*)"
455951,METHOD,stream\ngx_stream_upstream.h:<global>,TYPE_DECL,"typedef ngx_int_t (*ngx_stream_upstream_init_peer_pt)(ngx_stream_session_t *s,
    ngx_stream_upstream_srv_conf_t *us);",19,39,stream\ngx_stream_upstream.h,ngx_stream_upstream_init_peer_pt,,false,41,42,ngx_stream_upstream_init_peer_pt,,,6,"ngx_int_t ngx_stream_upstream_init_peer_pt (ngx_stream_session_t*,ngx_stream_upstream_srv_conf_t*)"
456029,METHOD,stream\ngx_stream_upstream.h:<global>,TYPE_DECL,"ngx_stream_upstream_srv_conf_t *ngx_stream_upstream_add(ngx_conf_t *cf,
    ngx_url_t *u, ngx_uint_t flags);",32,35,stream\ngx_stream_upstream.h,ngx_stream_upstream_add,,false,148,149,ngx_stream_upstream_add,,,18,"ngx_stream_upstream_srv_conf_t* ngx_stream_upstream_add (ngx_conf_t*,ngx_url_t*,ngx_uint_t)"
456046,METHOD,stream\ngx_stream_upstream_hash_module.c:<global>,TYPE_DECL,<global>,1,1,stream\ngx_stream_upstream_hash_module.c,stream\ngx_stream_upstream_hash_module.c:<global>,,false,1,685,<global>,,,1,
456055,METHOD,<empty>,<empty>,<empty>,1,,stream\ngx_stream_upstream_hash_module.c,ngx_stream_upstream_chash_points_t:<clinit>,,false,19,,<clinit>,,,3,
456075,METHOD,stream\ngx_stream_upstream_hash_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_upstream_init_hash(ngx_conf_t *cf,
    ngx_stream_upstream_srv_conf_t *us);",18,39,stream\ngx_stream_upstream_hash_module.c,ngx_stream_upstream_init_hash,,false,43,44,ngx_stream_upstream_init_hash,,,9,"ngx_int_t ngx_stream_upstream_init_hash (ngx_conf_t*,ngx_stream_upstream_srv_conf_t*)"
456081,METHOD,stream\ngx_stream_upstream_hash_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_upstream_init_hash_peer(ngx_stream_session_t *s,
    ngx_stream_upstream_srv_conf_t *us);",18,39,stream\ngx_stream_upstream_hash_module.c,ngx_stream_upstream_init_hash_peer,,false,45,46,ngx_stream_upstream_init_hash_peer,,,10,"ngx_int_t ngx_stream_upstream_init_hash_peer (ngx_stream_session_t*,ngx_stream_upstream_srv_conf_t*)"
456087,METHOD,stream\ngx_stream_upstream_hash_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_upstream_get_hash_peer(ngx_peer_connection_t *pc,
    void *data);",18,15,stream\ngx_stream_upstream_hash_module.c,ngx_stream_upstream_get_hash_peer,,false,47,48,ngx_stream_upstream_get_hash_peer,,,11,"ngx_int_t ngx_stream_upstream_get_hash_peer (ngx_peer_connection_t*,void*)"
456093,METHOD,stream\ngx_stream_upstream_hash_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_upstream_init_chash(ngx_conf_t *cf,
    ngx_stream_upstream_srv_conf_t *us);",18,39,stream\ngx_stream_upstream_hash_module.c,ngx_stream_upstream_init_chash,,false,50,51,ngx_stream_upstream_init_chash,,,12,"ngx_int_t ngx_stream_upstream_init_chash (ngx_conf_t*,ngx_stream_upstream_srv_conf_t*)"
456101,METHOD,stream\ngx_stream_upstream_hash_module.c:<global>,TYPE_DECL,"ngx_stream_upstream_chash_cmp_points(const void *one, const void *two);",5,74,stream\ngx_stream_upstream_hash_module.c,ngx_stream_upstream_chash_cmp_points,,false,53,53,ngx_stream_upstream_chash_cmp_points,,,15,"ANY ngx_stream_upstream_chash_cmp_points (void*,void*)"
456107,METHOD,stream\ngx_stream_upstream_hash_module.c:<global>,TYPE_DECL,"static ngx_uint_t ngx_stream_upstream_find_chash_point(
    ngx_stream_upstream_chash_points_t *points, uint32_t hash);",19,62,stream\ngx_stream_upstream_hash_module.c,ngx_stream_upstream_find_chash_point,,false,54,55,ngx_stream_upstream_find_chash_point,,,16,"ngx_uint_t ngx_stream_upstream_find_chash_point (ngx_stream_upstream_chash_points_t*,uint32_t)"
456113,METHOD,stream\ngx_stream_upstream_hash_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_upstream_init_chash_peer(ngx_stream_session_t *s,
    ngx_stream_upstream_srv_conf_t *us);",18,39,stream\ngx_stream_upstream_hash_module.c,ngx_stream_upstream_init_chash_peer,,false,56,57,ngx_stream_upstream_init_chash_peer,,,17,"ngx_int_t ngx_stream_upstream_init_chash_peer (ngx_stream_session_t*,ngx_stream_upstream_srv_conf_t*)"
456119,METHOD,stream\ngx_stream_upstream_hash_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_upstream_get_chash_peer(ngx_peer_connection_t *pc,
    void *data);",18,15,stream\ngx_stream_upstream_hash_module.c,ngx_stream_upstream_get_chash_peer,,false,58,59,ngx_stream_upstream_get_chash_peer,,,18,"ngx_int_t ngx_stream_upstream_get_chash_peer (ngx_peer_connection_t*,void*)"
456125,METHOD,stream\ngx_stream_upstream_hash_module.c:<global>,TYPE_DECL,static void *ngx_stream_upstream_hash_create_conf(ngx_conf_t *cf);,13,65,stream\ngx_stream_upstream_hash_module.c,ngx_stream_upstream_hash_create_conf,,false,61,61,ngx_stream_upstream_hash_create_conf,,,19,void* ngx_stream_upstream_hash_create_conf (ngx_conf_t*)
456130,METHOD,stream\ngx_stream_upstream_hash_module.c:<global>,TYPE_DECL,"static char *ngx_stream_upstream_hash(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,stream\ngx_stream_upstream_hash_module.c,ngx_stream_upstream_hash,,false,62,63,ngx_stream_upstream_hash,,,20,"char* ngx_stream_upstream_hash (ngx_conf_t*,ngx_command_t*,void*)"
456179,METHOD,stream\ngx_stream_upstream_hash_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_upstream_init_hash(ngx_conf_t *cf,
    ngx_stream_upstream_srv_conf_t *us)
{
    if (ngx_stream_upstream_init_round_robin(cf, us) != NGX_OK) {
        return NGX_ERROR;
    }

    us->peer.init = ngx_stream_upstream_init_hash_peer;

    return NGX_OK;
}",1,1,stream\ngx_stream_upstream_hash_module.c,ngx_stream_upstream_init_hash,,false,107,118,ngx_stream_upstream_init_hash,,,27,"ngx_int_t ngx_stream_upstream_init_hash (ngx_conf_t*,ngx_stream_upstream_srv_conf_t*)"
456203,METHOD,stream\ngx_stream_upstream_hash_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_upstream_init_hash_peer(ngx_stream_session_t *s,
    ngx_stream_upstream_srv_conf_t *us)
{
    ngx_stream_upstream_hash_srv_conf_t   *hcf;
    ngx_stream_upstream_hash_peer_data_t  *hp;

    hp = ngx_palloc(s->connection->pool,
                    sizeof(ngx_stream_upstream_hash_peer_data_t));
    if (hp == NULL) {
        return NGX_ERROR;
    }

    s->upstream->peer.data = &hp->rrp;

    if (ngx_stream_upstream_init_round_robin_peer(s, us) != NGX_OK) {
        return NGX_ERROR;
    }

    s->upstream->peer.get = ngx_stream_upstream_get_hash_peer;

    hcf = ngx_stream_conf_upstream_srv_conf(us,
                                            ngx_stream_upstream_hash_module);

    if (ngx_stream_complex_value(s, &hcf->key, &hp->key) != NGX_OK) {
        return NGX_ERROR;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_STREAM, s->connection->log, 0,
                   ""upstream hash key:\""%V\"""", &hp->key);

    hp->conf = hcf;
    hp->tries = 0;
    hp->rehash = 0;
...",1,1,stream\ngx_stream_upstream_hash_module.c,ngx_stream_upstream_init_hash_peer,,false,121,159,ngx_stream_upstream_init_hash_peer,,,28,"ngx_int_t ngx_stream_upstream_init_hash_peer (ngx_stream_session_t*,ngx_stream_upstream_srv_conf_t*)"
456319,METHOD,stream\ngx_stream_upstream_hash_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_upstream_get_hash_peer(ngx_peer_connection_t *pc, void *data)
{
    ngx_stream_upstream_hash_peer_data_t *hp = data;

    time_t                          now;
    u_char                          buf[NGX_INT_T_LEN];
    size_t                          size;
    uint32_t                        hash;
    ngx_int_t                       w;
    uintptr_t                       m;
    ngx_uint_t                      n, p;
    ngx_stream_upstream_rr_peer_t  *peer;

    ngx_log_debug1(NGX_LOG_DEBUG_STREAM, pc->log, 0,
                   ""get hash peer, try: %ui"", pc->tries);

    ngx_stream_upstream_rr_peers_rlock(hp->rrp.peers);

    if (hp->tries > 20 || hp->rrp.peers->single || hp->key.len == 0) {
        ngx_stream_upstream_rr_peers_unlock(hp->rrp.peers);
        return hp->get_rr_peer(pc, &hp->rrp);
    }

    now = ngx_time();

    pc->connection = NULL;

    for ( ;; ) {

        /*
         * Hash expression is compatible with Cache::Memcached:
         * ...",1,1,stream\ngx_stream_upstream_hash_module.c,ngx_stream_upstream_get_hash_peer,,false,162,281,ngx_stream_upstream_get_hash_peer,,,29,"ngx_int_t ngx_stream_upstream_get_hash_peer (ngx_peer_connection_t*,void*)"
456717,METHOD,stream\ngx_stream_upstream_hash_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_upstream_init_chash(ngx_conf_t *cf,
    ngx_stream_upstream_srv_conf_t *us)
{
    u_char                               *host, *port, c;
    size_t                                host_len, port_len, size;
    uint32_t                              hash, base_hash;
    ngx_str_t                            *server;
    ngx_uint_t                            npoints, i, j;
    ngx_stream_upstream_rr_peer_t        *peer;
    ngx_stream_upstream_rr_peers_t       *peers;
    ngx_stream_upstream_chash_points_t   *points;
    ngx_stream_upstream_hash_srv_conf_t  *hcf;
    union {
        uint32_t                          value;
        u_char                            byte[4];
    } prev_hash;

    if (ngx_stream_upstream_init_round_robin(cf, us) != NGX_OK) {
        return NGX_ERROR;
    }

    us->peer.init = ngx_stream_upstream_init_chash_peer;

    peers = us->peer.data;
    npoints = peers->total_weight * 160;

    size = sizeof(ngx_stream_upstream_chash_point...",1,1,stream\ngx_stream_upstream_hash_module.c,ngx_stream_upstream_init_chash,,false,284,409,ngx_stream_upstream_init_chash,,,30,"ngx_int_t ngx_stream_upstream_init_chash (ngx_conf_t*,ngx_stream_upstream_srv_conf_t*)"
457149,METHOD,stream\ngx_stream_upstream_hash_module.c:<global>,TYPE_DECL,"ngx_stream_upstream_chash_cmp_points(const void *one, const void *two)
{
    ngx_stream_upstream_chash_point_t *first =
                                     (ngx_stream_upstream_chash_point_t *) one;
    ngx_stream_upstream_chash_point_t *second =
                                     (ngx_stream_upstream_chash_point_t *) two;

    if (first->hash < second->hash) {
        return -1;

    } else if (first->hash > second->hash) {
        return 1;

    } else {
        return 0;
    }
}",1,1,stream\ngx_stream_upstream_hash_module.c,ngx_stream_upstream_chash_cmp_points,,false,413,429,ngx_stream_upstream_chash_cmp_points,,,33,"ANY ngx_stream_upstream_chash_cmp_points (void*,void*)"
457196,METHOD,stream\ngx_stream_upstream_hash_module.c:<global>,TYPE_DECL,"static ngx_uint_t
ngx_stream_upstream_find_chash_point(ngx_stream_upstream_chash_points_t *points,
    uint32_t hash)
{
    ngx_uint_t                          i, j, k;
    ngx_stream_upstream_chash_point_t  *point;

    /* find first point >= hash */

    point = &points->point[0];

    i = 0;
    j = points->number;

    while (i < j) {
        k = (i + j) / 2;

        if (hash > point[k].hash) {
            i = k + 1;

        } else if (hash < point[k].hash) {
            j = k;

        } else {
            return k;
        }
    }

    return i;
}",1,1,stream\ngx_stream_upstream_hash_module.c,ngx_stream_upstream_find_chash_point,,false,432,461,ngx_stream_upstream_find_chash_point,,,34,"ngx_uint_t ngx_stream_upstream_find_chash_point (ngx_stream_upstream_chash_points_t*,uint32_t)"
457268,METHOD,stream\ngx_stream_upstream_hash_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_upstream_init_chash_peer(ngx_stream_session_t *s,
    ngx_stream_upstream_srv_conf_t *us)
{
    uint32_t                               hash;
    ngx_stream_upstream_hash_srv_conf_t   *hcf;
    ngx_stream_upstream_hash_peer_data_t  *hp;

    if (ngx_stream_upstream_init_hash_peer(s, us) != NGX_OK) {
        return NGX_ERROR;
    }

    s->upstream->peer.get = ngx_stream_upstream_get_chash_peer;

    hp = s->upstream->peer.data;
    hcf = ngx_stream_conf_upstream_srv_conf(us,
                                            ngx_stream_upstream_hash_module);

    hash = ngx_crc32_long(hp->key.data, hp->key.len);

    ngx_stream_upstream_rr_peers_rlock(hp->rrp.peers);

    hp->hash = ngx_stream_upstream_find_chash_point(hcf->points, hash);

    ngx_stream_upstream_rr_peers_unlock(hp->rrp.peers);

    return NGX_OK;
}",1,1,stream\ngx_stream_upstream_hash_module.c,ngx_stream_upstream_init_chash_peer,,false,464,491,ngx_stream_upstream_init_chash_peer,,,35,"ngx_int_t ngx_stream_upstream_init_chash_peer (ngx_stream_session_t*,ngx_stream_upstream_srv_conf_t*)"
457345,METHOD,stream\ngx_stream_upstream_hash_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_upstream_get_chash_peer(ngx_peer_connection_t *pc, void *data)
{
    ngx_stream_upstream_hash_peer_data_t *hp = data;

    time_t                                now;
    intptr_t                              m;
    ngx_str_t                            *server;
    ngx_int_t                             total;
    ngx_uint_t                            i, n, best_i;
    ngx_stream_upstream_rr_peer_t        *peer, *best;
    ngx_stream_upstream_chash_point_t    *point;
    ngx_stream_upstream_chash_points_t   *points;
    ngx_stream_upstream_hash_srv_conf_t  *hcf;

    ngx_log_debug1(NGX_LOG_DEBUG_STREAM, pc->log, 0,
                   ""get consistent hash peer, try: %ui"", pc->tries);

    ngx_stream_upstream_rr_peers_wlock(hp->rrp.peers);

    if (hp->tries > 20 || hp->rrp.peers->single || hp->key.len == 0) {
        ngx_stream_upstream_rr_peers_unlock(hp->rrp.peers);
        return hp->get_rr_peer(pc, &hp->rrp);
    }

    pc->connection = NULL;

    now = ...",1,1,stream\ngx_stream_upstream_hash_module.c,ngx_stream_upstream_get_chash_peer,,false,494,618,ngx_stream_upstream_get_chash_peer,,,36,"ngx_int_t ngx_stream_upstream_get_chash_peer (ngx_peer_connection_t*,void*)"
457782,METHOD,stream\ngx_stream_upstream_hash_module.c:<global>,TYPE_DECL,"static void *
ngx_stream_upstream_hash_create_conf(ngx_conf_t *cf)
{
    ngx_stream_upstream_hash_srv_conf_t  *conf;

    conf = ngx_palloc(cf->pool, sizeof(ngx_stream_upstream_hash_srv_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    conf->points = NULL;

    return conf;
}",1,1,stream\ngx_stream_upstream_hash_module.c,ngx_stream_upstream_hash_create_conf,,false,621,634,ngx_stream_upstream_hash_create_conf,,,37,void* ngx_stream_upstream_hash_create_conf (ngx_conf_t*)
457810,METHOD,stream\ngx_stream_upstream_hash_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_upstream_hash(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_stream_upstream_hash_srv_conf_t  *hcf = conf;

    ngx_str_t                           *value;
    ngx_stream_upstream_srv_conf_t      *uscf;
    ngx_stream_compile_complex_value_t   ccv;

    value = cf->args->elts;

    ngx_memzero(&ccv, sizeof(ngx_stream_compile_complex_value_t));

    ccv.cf = cf;
    ccv.value = &value[1];
    ccv.complex_value = &hcf->key;

    if (ngx_stream_compile_complex_value(&ccv) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    uscf = ngx_stream_conf_get_module_srv_conf(cf, ngx_stream_upstream_module);

    if (uscf->peer.init_upstream) {
        ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
                           ""load balancing method redefined"");
    }

    uscf->flags = NGX_STREAM_UPSTREAM_CREATE
                  |NGX_STREAM_UPSTREAM_WEIGHT
                  |NGX_STREAM_UPSTREAM_MAX_CONNS
                  |NGX_STREAM_UPSTREAM_MAX_FAILS
            ...",1,1,stream\ngx_stream_upstream_hash_module.c,ngx_stream_upstream_hash,,false,637,685,ngx_stream_upstream_hash,,,38,"char* ngx_stream_upstream_hash (ngx_conf_t*,ngx_command_t*,void*)"
457958,METHOD,stream\ngx_stream_upstream_least_conn_module.c:<global>,TYPE_DECL,<global>,1,1,stream\ngx_stream_upstream_least_conn_module.c,stream\ngx_stream_upstream_least_conn_module.c:<global>,,false,1,310,<global>,,,1,
457960,METHOD,stream\ngx_stream_upstream_least_conn_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_upstream_init_least_conn_peer(
    ngx_stream_session_t *s, ngx_stream_upstream_srv_conf_t *us);",18,64,stream\ngx_stream_upstream_least_conn_module.c,ngx_stream_upstream_init_least_conn_peer,,false,13,14,ngx_stream_upstream_init_least_conn_peer,,,1,"ngx_int_t ngx_stream_upstream_init_least_conn_peer (ngx_stream_session_t*,ngx_stream_upstream_srv_conf_t*)"
457966,METHOD,stream\ngx_stream_upstream_least_conn_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_upstream_get_least_conn_peer(
    ngx_peer_connection_t *pc, void *data);",18,42,stream\ngx_stream_upstream_least_conn_module.c,ngx_stream_upstream_get_least_conn_peer,,false,15,16,ngx_stream_upstream_get_least_conn_peer,,,2,"ngx_int_t ngx_stream_upstream_get_least_conn_peer (ngx_peer_connection_t*,void*)"
457972,METHOD,stream\ngx_stream_upstream_least_conn_module.c:<global>,TYPE_DECL,"static char *ngx_stream_upstream_least_conn(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,stream\ngx_stream_upstream_least_conn_module.c,ngx_stream_upstream_least_conn,,false,17,18,ngx_stream_upstream_least_conn,,,3,"char* ngx_stream_upstream_least_conn (ngx_conf_t*,ngx_command_t*,void*)"
458021,METHOD,stream\ngx_stream_upstream_least_conn_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_upstream_init_least_conn(ngx_conf_t *cf,
    ngx_stream_upstream_srv_conf_t *us)
{
    ngx_log_debug0(NGX_LOG_DEBUG_STREAM, cf->log, 0,
                   ""init least conn"");

    if (ngx_stream_upstream_init_round_robin(cf, us) != NGX_OK) {
        return NGX_ERROR;
    }

    us->peer.init = ngx_stream_upstream_init_least_conn_peer;

    return NGX_OK;
}",1,1,stream\ngx_stream_upstream_least_conn_module.c,ngx_stream_upstream_init_least_conn,,false,62,76,ngx_stream_upstream_init_least_conn,,,10,"ngx_int_t ngx_stream_upstream_init_least_conn (ngx_conf_t*,ngx_stream_upstream_srv_conf_t*)"
458052,METHOD,stream\ngx_stream_upstream_least_conn_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_upstream_init_least_conn_peer(ngx_stream_session_t *s,
    ngx_stream_upstream_srv_conf_t *us)
{
    ngx_log_debug0(NGX_LOG_DEBUG_STREAM, s->connection->log, 0,
                   ""init least conn peer"");

    if (ngx_stream_upstream_init_round_robin_peer(s, us) != NGX_OK) {
        return NGX_ERROR;
    }

    s->upstream->peer.get = ngx_stream_upstream_get_least_conn_peer;

    return NGX_OK;
}",1,1,stream\ngx_stream_upstream_least_conn_module.c,ngx_stream_upstream_init_least_conn_peer,,false,79,93,ngx_stream_upstream_init_least_conn_peer,,,11,"ngx_int_t ngx_stream_upstream_init_least_conn_peer (ngx_stream_session_t*,ngx_stream_upstream_srv_conf_t*)"
458087,METHOD,stream\ngx_stream_upstream_least_conn_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_upstream_get_least_conn_peer(ngx_peer_connection_t *pc, void *data)
{
    ngx_stream_upstream_rr_peer_data_t *rrp = data;

    time_t                           now;
    uintptr_t                        m;
    ngx_int_t                        rc, total;
    ngx_uint_t                       i, n, p, many;
    ngx_stream_upstream_rr_peer_t   *peer, *best;
    ngx_stream_upstream_rr_peers_t  *peers;

    ngx_log_debug1(NGX_LOG_DEBUG_STREAM, pc->log, 0,
                   ""get least conn peer, try: %ui"", pc->tries);

    if (rrp->peers->single) {
        return ngx_stream_upstream_get_round_robin_peer(pc, rrp);
    }

    pc->connection = NULL;

    now = ngx_time();

    peers = rrp->peers;

    ngx_stream_upstream_rr_peers_wlock(peers);

    best = NULL;
    total = 0;

#if (NGX_SUPPRESS_WARN)
    many = 0;
    p = 0;
#endif

    for (peer = peers->peer, i = 0;
         peer;
         peer = peer->next, i++)
    {
        n = i / (8 * sizeof(uintptr_t));
   ...",1,1,stream\ngx_stream_upstream_least_conn_module.c,ngx_stream_upstream_get_least_conn_peer,,false,96,284,ngx_stream_upstream_get_least_conn_peer,,,12,"ngx_int_t ngx_stream_upstream_get_least_conn_peer (ngx_peer_connection_t*,void*)"
458638,METHOD,stream\ngx_stream_upstream_least_conn_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_upstream_least_conn(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_stream_upstream_srv_conf_t  *uscf;

    uscf = ngx_stream_conf_get_module_srv_conf(cf, ngx_stream_upstream_module);

    if (uscf->peer.init_upstream) {
        ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
                           ""load balancing method redefined"");
    }

    uscf->peer.init_upstream = ngx_stream_upstream_init_least_conn;

    uscf->flags = NGX_STREAM_UPSTREAM_CREATE
                  |NGX_STREAM_UPSTREAM_WEIGHT
                  |NGX_STREAM_UPSTREAM_MAX_CONNS
                  |NGX_STREAM_UPSTREAM_MAX_FAILS
                  |NGX_STREAM_UPSTREAM_FAIL_TIMEOUT
                  |NGX_STREAM_UPSTREAM_DOWN
                  |NGX_STREAM_UPSTREAM_BACKUP;

    return NGX_CONF_OK;
}",1,1,stream\ngx_stream_upstream_least_conn_module.c,ngx_stream_upstream_least_conn,,false,287,310,ngx_stream_upstream_least_conn,,,13,"char* ngx_stream_upstream_least_conn (ngx_conf_t*,ngx_command_t*,void*)"
458698,METHOD,stream\ngx_stream_upstream_random_module.c:<global>,TYPE_DECL,<global>,1,1,stream\ngx_stream_upstream_random_module.c,stream\ngx_stream_upstream_random_module.c:<global>,,false,1,502,<global>,,,1,
458713,METHOD,stream\ngx_stream_upstream_random_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_upstream_init_random(ngx_conf_t *cf,
    ngx_stream_upstream_srv_conf_t *us);",18,39,stream\ngx_stream_upstream_random_module.c,ngx_stream_upstream_init_random,,false,33,34,ngx_stream_upstream_init_random,,,7,"ngx_int_t ngx_stream_upstream_init_random (ngx_conf_t*,ngx_stream_upstream_srv_conf_t*)"
458719,METHOD,stream\ngx_stream_upstream_random_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_upstream_update_random(ngx_pool_t *pool,
    ngx_stream_upstream_srv_conf_t *us);",18,39,stream\ngx_stream_upstream_random_module.c,ngx_stream_upstream_update_random,,false,35,36,ngx_stream_upstream_update_random,,,8,"ngx_int_t ngx_stream_upstream_update_random (ngx_pool_t*,ngx_stream_upstream_srv_conf_t*)"
458725,METHOD,stream\ngx_stream_upstream_random_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_upstream_init_random_peer(ngx_stream_session_t *s,
    ngx_stream_upstream_srv_conf_t *us);",18,39,stream\ngx_stream_upstream_random_module.c,ngx_stream_upstream_init_random_peer,,false,38,39,ngx_stream_upstream_init_random_peer,,,9,"ngx_int_t ngx_stream_upstream_init_random_peer (ngx_stream_session_t*,ngx_stream_upstream_srv_conf_t*)"
458731,METHOD,stream\ngx_stream_upstream_random_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_upstream_get_random_peer(ngx_peer_connection_t *pc,
    void *data);",18,15,stream\ngx_stream_upstream_random_module.c,ngx_stream_upstream_get_random_peer,,false,40,41,ngx_stream_upstream_get_random_peer,,,10,"ngx_int_t ngx_stream_upstream_get_random_peer (ngx_peer_connection_t*,void*)"
458737,METHOD,stream\ngx_stream_upstream_random_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_upstream_get_random2_peer(ngx_peer_connection_t *pc,
    void *data);",18,15,stream\ngx_stream_upstream_random_module.c,ngx_stream_upstream_get_random2_peer,,false,42,43,ngx_stream_upstream_get_random2_peer,,,11,"ngx_int_t ngx_stream_upstream_get_random2_peer (ngx_peer_connection_t*,void*)"
458743,METHOD,stream\ngx_stream_upstream_random_module.c:<global>,TYPE_DECL,"static ngx_uint_t ngx_stream_upstream_peek_random_peer(
    ngx_stream_upstream_rr_peers_t *peers,
    ngx_stream_upstream_random_peer_data_t *rp);",19,47,stream\ngx_stream_upstream_random_module.c,ngx_stream_upstream_peek_random_peer,,false,44,46,ngx_stream_upstream_peek_random_peer,,,12,"ngx_uint_t ngx_stream_upstream_peek_random_peer (ngx_stream_upstream_rr_peers_t*,ngx_stream_upstream_random_peer_data_t*)"
458749,METHOD,stream\ngx_stream_upstream_random_module.c:<global>,TYPE_DECL,static void *ngx_stream_upstream_random_create_conf(ngx_conf_t *cf);,13,67,stream\ngx_stream_upstream_random_module.c,ngx_stream_upstream_random_create_conf,,false,47,47,ngx_stream_upstream_random_create_conf,,,13,void* ngx_stream_upstream_random_create_conf (ngx_conf_t*)
458754,METHOD,stream\ngx_stream_upstream_random_module.c:<global>,TYPE_DECL,"static char *ngx_stream_upstream_random(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,stream\ngx_stream_upstream_random_module.c,ngx_stream_upstream_random,,false,48,49,ngx_stream_upstream_random,,,14,"char* ngx_stream_upstream_random (ngx_conf_t*,ngx_command_t*,void*)"
458805,METHOD,stream\ngx_stream_upstream_random_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_upstream_init_random(ngx_conf_t *cf,
    ngx_stream_upstream_srv_conf_t *us)
{
    ngx_log_debug0(NGX_LOG_DEBUG_STREAM, cf->log, 0, ""init random"");

    if (ngx_stream_upstream_init_round_robin(cf, us) != NGX_OK) {
        return NGX_ERROR;
    }

    us->peer.init = ngx_stream_upstream_init_random_peer;

#if (NGX_STREAM_UPSTREAM_ZONE)
    if (us->shm_zone) {
        return NGX_OK;
    }
#endif

    return ngx_stream_upstream_update_random(cf->pool, us);
}",1,1,stream\ngx_stream_upstream_random_module.c,ngx_stream_upstream_init_random,,false,93,112,ngx_stream_upstream_init_random,,,21,"ngx_int_t ngx_stream_upstream_init_random (ngx_conf_t*,ngx_stream_upstream_srv_conf_t*)"
458840,METHOD,stream\ngx_stream_upstream_random_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_upstream_update_random(ngx_pool_t *pool,
    ngx_stream_upstream_srv_conf_t *us)
{
    size_t                                  size;
    ngx_uint_t                              i, total_weight;
    ngx_stream_upstream_rr_peer_t          *peer;
    ngx_stream_upstream_rr_peers_t         *peers;
    ngx_stream_upstream_random_range_t     *ranges;
    ngx_stream_upstream_random_srv_conf_t  *rcf;

    rcf = ngx_stream_conf_upstream_srv_conf(us,
                                            ngx_stream_upstream_random_module);
    peers = us->peer.data;

    size = peers->number * sizeof(ngx_stream_upstream_random_range_t);

    ranges = pool ? ngx_palloc(pool, size) : ngx_alloc(size, ngx_cycle->log);
    if (ranges == NULL) {
        return NGX_ERROR;
    }

    total_weight = 0;

    for (peer = peers->peer, i = 0; peer; peer = peer->next, i++) {
        ranges[i].peer = peer;
        ranges[i].range = total_weight;
        total_weight += peer->weight;
    }

...",1,1,stream\ngx_stream_upstream_random_module.c,ngx_stream_upstream_update_random,,false,115,148,ngx_stream_upstream_update_random,,,22,"ngx_int_t ngx_stream_upstream_update_random (ngx_pool_t*,ngx_stream_upstream_srv_conf_t*)"
458942,METHOD,stream\ngx_stream_upstream_random_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_upstream_init_random_peer(ngx_stream_session_t *s,
    ngx_stream_upstream_srv_conf_t *us)
{
    ngx_stream_upstream_random_srv_conf_t   *rcf;
    ngx_stream_upstream_random_peer_data_t  *rp;

    ngx_log_debug0(NGX_LOG_DEBUG_STREAM, s->connection->log, 0,
                   ""init random peer"");

    rcf = ngx_stream_conf_upstream_srv_conf(us,
                                            ngx_stream_upstream_random_module);

    rp = ngx_palloc(s->connection->pool,
                    sizeof(ngx_stream_upstream_random_peer_data_t));
    if (rp == NULL) {
        return NGX_ERROR;
    }

    s->upstream->peer.data = &rp->rrp;

    if (ngx_stream_upstream_init_round_robin_peer(s, us) != NGX_OK) {
        return NGX_ERROR;
    }

    if (rcf->two) {
        s->upstream->peer.get = ngx_stream_upstream_get_random2_peer;

    } else {
        s->upstream->peer.get = ngx_stream_upstream_get_random_peer;
    }

    rp->conf = rcf;
    rp->tries = 0;

    ngx_stream...",1,1,stream\ngx_stream_upstream_random_module.c,ngx_stream_upstream_init_random_peer,,false,151,200,ngx_stream_upstream_init_random_peer,,,23,"ngx_int_t ngx_stream_upstream_init_random_peer (ngx_stream_session_t*,ngx_stream_upstream_srv_conf_t*)"
459051,METHOD,stream\ngx_stream_upstream_random_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_upstream_get_random_peer(ngx_peer_connection_t *pc, void *data)
{
    ngx_stream_upstream_random_peer_data_t  *rp = data;

    time_t                               now;
    uintptr_t                            m;
    ngx_uint_t                           i, n;
    ngx_stream_upstream_rr_peer_t       *peer;
    ngx_stream_upstream_rr_peers_t      *peers;
    ngx_stream_upstream_rr_peer_data_t  *rrp;

    ngx_log_debug1(NGX_LOG_DEBUG_STREAM, pc->log, 0,
                   ""get random peer, try: %ui"", pc->tries);

    rrp = &rp->rrp;
    peers = rrp->peers;

    ngx_stream_upstream_rr_peers_rlock(peers);

    if (rp->tries > 20 || peers->single) {
        ngx_stream_upstream_rr_peers_unlock(peers);
        return ngx_stream_upstream_get_round_robin_peer(pc, rrp);
    }

    pc->cached = 0;
    pc->connection = NULL;

    now = ngx_time();

    for ( ;; ) {

        i = ngx_stream_upstream_peek_random_peer(peers, rp);

        peer = rp->conf->ranges[i].peer;
...",1,1,stream\ngx_stream_upstream_random_module.c,ngx_stream_upstream_get_random_peer,,false,203,294,ngx_stream_upstream_get_random_peer,,,24,"ngx_int_t ngx_stream_upstream_get_random_peer (ngx_peer_connection_t*,void*)"
459303,METHOD,stream\ngx_stream_upstream_random_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_upstream_get_random2_peer(ngx_peer_connection_t *pc, void *data)
{
    ngx_stream_upstream_random_peer_data_t  *rp = data;

    time_t                               now;
    uintptr_t                            m;
    ngx_uint_t                           i, n, p;
    ngx_stream_upstream_rr_peer_t       *peer, *prev;
    ngx_stream_upstream_rr_peers_t      *peers;
    ngx_stream_upstream_rr_peer_data_t  *rrp;

    ngx_log_debug1(NGX_LOG_DEBUG_STREAM, pc->log, 0,
                   ""get random2 peer, try: %ui"", pc->tries);

    rrp = &rp->rrp;
    peers = rrp->peers;

    ngx_stream_upstream_rr_peers_wlock(peers);

    if (rp->tries > 20 || peers->single) {
        ngx_stream_upstream_rr_peers_unlock(peers);
        return ngx_stream_upstream_get_round_robin_peer(pc, rrp);
    }

    pc->cached = 0;
    pc->connection = NULL;

    now = ngx_time();

    prev = NULL;

#if (NGX_SUPPRESS_WARN)
    p = 0;
#endif

    for ( ;; ) {

        i = ngx_stream_upstrea...",1,1,stream\ngx_stream_upstream_random_module.c,ngx_stream_upstream_get_random2_peer,,false,297,403,ngx_stream_upstream_get_random2_peer,,,25,"ngx_int_t ngx_stream_upstream_get_random2_peer (ngx_peer_connection_t*,void*)"
459600,METHOD,stream\ngx_stream_upstream_random_module.c:<global>,TYPE_DECL,"static ngx_uint_t
ngx_stream_upstream_peek_random_peer(ngx_stream_upstream_rr_peers_t *peers,
    ngx_stream_upstream_random_peer_data_t *rp)
{
    ngx_uint_t  i, j, k, x;

    x = ngx_random() % peers->total_weight;

    i = 0;
    j = peers->number;

    while (j - i > 1) {
        k = (i + j) / 2;

        if (x < rp->conf->ranges[k].range) {
            j = k;

        } else {
            i = k;
        }
    }

    return i;
}",1,1,stream\ngx_stream_upstream_random_module.c,ngx_stream_upstream_peek_random_peer,,false,406,429,ngx_stream_upstream_peek_random_peer,,,26,"ngx_uint_t ngx_stream_upstream_peek_random_peer (ngx_stream_upstream_rr_peers_t*,ngx_stream_upstream_random_peer_data_t*)"
459662,METHOD,stream\ngx_stream_upstream_random_module.c:<global>,TYPE_DECL,"static void *
ngx_stream_upstream_random_create_conf(ngx_conf_t *cf)
{
    ngx_stream_upstream_random_srv_conf_t  *conf;

    conf = ngx_pcalloc(cf->pool, sizeof(ngx_stream_upstream_random_srv_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     conf->two = 0;
     */

    return conf;
}",1,1,stream\ngx_stream_upstream_random_module.c,ngx_stream_upstream_random_create_conf,,false,432,449,ngx_stream_upstream_random_create_conf,,,27,void* ngx_stream_upstream_random_create_conf (ngx_conf_t*)
459685,METHOD,stream\ngx_stream_upstream_random_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_upstream_random(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_stream_upstream_random_srv_conf_t  *rcf = conf;

    ngx_str_t                       *value;
    ngx_stream_upstream_srv_conf_t  *uscf;

    uscf = ngx_stream_conf_get_module_srv_conf(cf, ngx_stream_upstream_module);

    if (uscf->peer.init_upstream) {
        ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
                           ""load balancing method redefined"");
    }

    uscf->peer.init_upstream = ngx_stream_upstream_init_random;

    uscf->flags = NGX_STREAM_UPSTREAM_CREATE
                  |NGX_STREAM_UPSTREAM_WEIGHT
                  |NGX_STREAM_UPSTREAM_MAX_CONNS
                  |NGX_STREAM_UPSTREAM_MAX_FAILS
                  |NGX_STREAM_UPSTREAM_FAIL_TIMEOUT
                  |NGX_STREAM_UPSTREAM_DOWN;

    if (cf->args->nelts == 1) {
        return NGX_CONF_OK;
    }

    value = cf->args->elts;

    if (ngx_strcmp(value[1].data, ""two"") == 0) {
        rcf->two = 1;

    } ...",1,1,stream\ngx_stream_upstream_random_module.c,ngx_stream_upstream_random,,false,452,502,ngx_stream_upstream_random,,,28,"char* ngx_stream_upstream_random (ngx_conf_t*,ngx_command_t*,void*)"
459828,METHOD,stream\ngx_stream_upstream_round_robin.c:<global>,TYPE_DECL,<global>,1,30,stream\ngx_stream_upstream_round_robin.c,stream\ngx_stream_upstream_round_robin.c:<global>,,false,1,871,<global>,,,1,
459830,METHOD,stream\ngx_stream_upstream_round_robin.c:<global>,TYPE_DECL,"static ngx_stream_upstream_rr_peer_t *ngx_stream_upstream_get_peer(
    ngx_stream_upstream_rr_peer_data_t *rrp);",38,44,stream\ngx_stream_upstream_round_robin.c,ngx_stream_upstream_get_peer,,false,17,18,ngx_stream_upstream_get_peer,,,1,ngx_stream_upstream_rr_peer_t* ngx_stream_upstream_get_peer (ngx_stream_upstream_rr_peer_data_t*)
459835,METHOD,stream\ngx_stream_upstream_round_robin.c:<global>,TYPE_DECL,"static void ngx_stream_upstream_notify_round_robin_peer(
    ngx_peer_connection_t *pc, void *data, ngx_uint_t state);",13,60,stream\ngx_stream_upstream_round_robin.c,ngx_stream_upstream_notify_round_robin_peer,,false,19,20,ngx_stream_upstream_notify_round_robin_peer,,,2,"void ngx_stream_upstream_notify_round_robin_peer (ngx_peer_connection_t*,void*,ngx_uint_t)"
459842,METHOD,stream\ngx_stream_upstream_round_robin.c:<global>,TYPE_DECL,"ngx_int_t
ngx_stream_upstream_init_round_robin(ngx_conf_t *cf,
    ngx_stream_upstream_srv_conf_t *us)
{
    ngx_url_t                        u;
    ngx_uint_t                       i, j, n, w;
    ngx_stream_upstream_server_t    *server;
    ngx_stream_upstream_rr_peer_t   *peer, **peerp;
    ngx_stream_upstream_rr_peers_t  *peers, *backup;

    us->peer.init = ngx_stream_upstream_init_round_robin_peer;

    if (us->servers) {
        server = us->servers->elts;

        n = 0;
        w = 0;

        for (i = 0; i < us->servers->nelts; i++) {
            if (server[i].backup) {
                continue;
            }

            n += server[i].naddrs;
            w += server[i].naddrs * server[i].weight;
        }

        if (n == 0) {
            ngx_log_error(NGX_LOG_EMERG, cf->log, 0,
                          ""no servers in upstream \""%V\"" in %s:%ui"",
                          &us->host, us->file_name, us->line);
            return NGX_ERROR;
        }

        peers = ngx_p...",1,1,stream\ngx_stream_upstream_round_robin.c,ngx_stream_upstream_init_round_robin,,false,36,246,ngx_stream_upstream_init_round_robin,,,3,"ngx_int_t ngx_stream_upstream_init_round_robin (ngx_conf_t*,ngx_stream_upstream_srv_conf_t*)"
460812,METHOD,stream\ngx_stream_upstream_round_robin.c:<global>,TYPE_DECL,"ngx_int_t
ngx_stream_upstream_init_round_robin_peer(ngx_stream_session_t *s,
    ngx_stream_upstream_srv_conf_t *us)
{
    ngx_uint_t                           n;
    ngx_stream_upstream_rr_peer_data_t  *rrp;

    rrp = s->upstream->peer.data;

    if (rrp == NULL) {
        rrp = ngx_palloc(s->connection->pool,
                         sizeof(ngx_stream_upstream_rr_peer_data_t));
        if (rrp == NULL) {
            return NGX_ERROR;
        }

        s->upstream->peer.data = rrp;
    }

    rrp->peers = us->peer.data;
    rrp->current = NULL;
    rrp->config = 0;

    n = rrp->peers->number;

    if (rrp->peers->next && rrp->peers->next->number > n) {
        n = rrp->peers->next->number;
    }

    if (n <= 8 * sizeof(uintptr_t)) {
        rrp->tried = &rrp->data;
        rrp->data = 0;

    } else {
        n = (n + (8 * sizeof(uintptr_t) - 1)) / (8 * sizeof(uintptr_t));

        rrp->tried = ngx_pcalloc(s->connection->pool, n * sizeof(uintptr_t));
        if (rrp->tried == N...",1,30,stream\ngx_stream_upstream_round_robin.c,ngx_stream_upstream_init_round_robin_peer,,false,249,303,ngx_stream_upstream_init_round_robin_peer,,,4,"ngx_int_t ngx_stream_upstream_init_round_robin_peer (ngx_stream_session_t*,ngx_stream_upstream_srv_conf_t*)"
461035,METHOD,stream\ngx_stream_upstream_round_robin.c:<global>,TYPE_DECL,"ngx_int_t
ngx_stream_upstream_create_round_robin_peer(ngx_stream_session_t *s,
    ngx_stream_upstream_resolved_t *ur)
{
    u_char                              *p;
    size_t                               len;
    socklen_t                            socklen;
    ngx_uint_t                           i, n;
    struct sockaddr                     *sockaddr;
    ngx_stream_upstream_rr_peer_t       *peer, **peerp;
    ngx_stream_upstream_rr_peers_t      *peers;
    ngx_stream_upstream_rr_peer_data_t  *rrp;

    rrp = s->upstream->peer.data;

    if (rrp == NULL) {
        rrp = ngx_palloc(s->connection->pool,
                         sizeof(ngx_stream_upstream_rr_peer_data_t));
        if (rrp == NULL) {
            return NGX_ERROR;
        }

        s->upstream->peer.data = rrp;
    }

    peers = ngx_pcalloc(s->connection->pool,
                        sizeof(ngx_stream_upstream_rr_peers_t));
    if (peers == NULL) {
        return NGX_ERROR;
    }

    peer = ngx_pcalloc(s->connec...",1,30,stream\ngx_stream_upstream_round_robin.c,ngx_stream_upstream_create_round_robin_peer,,false,306,423,ngx_stream_upstream_create_round_robin_peer,,,5,"ngx_int_t ngx_stream_upstream_create_round_robin_peer (ngx_stream_session_t*,ngx_stream_upstream_resolved_t*)"
461543,METHOD,stream\ngx_stream_upstream_round_robin.c:<global>,TYPE_DECL,"ngx_int_t
ngx_stream_upstream_get_round_robin_peer(ngx_peer_connection_t *pc, void *data)
{
    ngx_stream_upstream_rr_peer_data_t *rrp = data;

    ngx_int_t                        rc;
    ngx_uint_t                       i, n;
    ngx_stream_upstream_rr_peer_t   *peer;
    ngx_stream_upstream_rr_peers_t  *peers;

    ngx_log_debug1(NGX_LOG_DEBUG_STREAM, pc->log, 0,
                   ""get rr peer, try: %ui"", pc->tries);

    pc->connection = NULL;

    peers = rrp->peers;
    ngx_stream_upstream_rr_peers_wlock(peers);

    if (peers->single) {
        peer = peers->peer;

        if (peer->down) {
            goto failed;
        }

        if (peer->max_conns && peer->conns >= peer->max_conns) {
            goto failed;
        }

        rrp->current = peer;

    } else {

        /* there are several peers */

        peer = ngx_stream_upstream_get_peer(rrp);

        if (peer == NULL) {
            goto failed;
        }

        ngx_log_debug2(NGX_LOG_DEBUG_STREAM, pc->log, 0...",1,1,stream\ngx_stream_upstream_round_robin.c,ngx_stream_upstream_get_round_robin_peer,,false,426,513,ngx_stream_upstream_get_round_robin_peer,,,6,"ngx_int_t ngx_stream_upstream_get_round_robin_peer (ngx_peer_connection_t*,void*)"
461752,METHOD,stream\ngx_stream_upstream_round_robin.c:<global>,TYPE_DECL,"static ngx_stream_upstream_rr_peer_t *
ngx_stream_upstream_get_peer(ngx_stream_upstream_rr_peer_data_t *rrp)
{
    time_t                          now;
    uintptr_t                       m;
    ngx_int_t                       total;
    ngx_uint_t                      i, n, p;
    ngx_stream_upstream_rr_peer_t  *peer, *best;

    now = ngx_time();

    best = NULL;
    total = 0;

#if (NGX_SUPPRESS_WARN)
    p = 0;
#endif

    for (peer = rrp->peers->peer, i = 0;
         peer;
         peer = peer->next, i++)
    {
        n = i / (8 * sizeof(uintptr_t));
        m = (uintptr_t) 1 << i % (8 * sizeof(uintptr_t));

        if (rrp->tried[n] & m) {
            continue;
        }

        if (peer->down) {
            continue;
        }

        if (peer->max_fails
            && peer->fails >= peer->max_fails
            && now - peer->checked <= peer->fail_timeout)
        {
            continue;
        }

        if (peer->max_conns && peer->conns >= peer->max_conns) {
         ...",1,1,stream\ngx_stream_upstream_round_robin.c,ngx_stream_upstream_get_peer,,false,516,591,ngx_stream_upstream_get_peer,,,7,ngx_stream_upstream_rr_peer_t ngx_stream_upstream_get_peer (ngx_stream_upstream_rr_peer_data_t*)
461977,METHOD,stream\ngx_stream_upstream_round_robin.c:<global>,TYPE_DECL,"void
ngx_stream_upstream_free_round_robin_peer(ngx_peer_connection_t *pc, void *data,
    ngx_uint_t state)
{
    ngx_stream_upstream_rr_peer_data_t  *rrp = data;

    time_t                          now;
    ngx_stream_upstream_rr_peer_t  *peer;

    ngx_log_debug2(NGX_LOG_DEBUG_STREAM, pc->log, 0,
                   ""free rr peer %ui %ui"", pc->tries, state);

    peer = rrp->current;

    ngx_stream_upstream_rr_peers_rlock(rrp->peers);
    ngx_stream_upstream_rr_peer_lock(rrp->peers, peer);

    if (rrp->peers->single) {
        peer->conns--;

        ngx_stream_upstream_rr_peer_unlock(rrp->peers, peer);
        ngx_stream_upstream_rr_peers_unlock(rrp->peers);

        pc->tries = 0;
        return;
    }

    if (state & NGX_PEER_FAILED) {
        now = ngx_time();

        peer->fails++;
        peer->accessed = now;
        peer->checked = now;

        if (peer->max_fails) {
            peer->effective_weight -= peer->weight / peer->max_fails;

            if (peer->fails >= ...",1,1,stream\ngx_stream_upstream_round_robin.c,ngx_stream_upstream_free_round_robin_peer,,false,594,662,ngx_stream_upstream_free_round_robin_peer,,,8,"void ngx_stream_upstream_free_round_robin_peer (ngx_peer_connection_t*,void*,ngx_uint_t)"
462156,METHOD,stream\ngx_stream_upstream_round_robin.c:<global>,TYPE_DECL,"static void
ngx_stream_upstream_notify_round_robin_peer(ngx_peer_connection_t *pc,
    void *data, ngx_uint_t type)
{
    ngx_stream_upstream_rr_peer_data_t  *rrp = data;

    ngx_stream_upstream_rr_peer_t  *peer;

    peer = rrp->current;

    if (type == NGX_STREAM_UPSTREAM_NOTIFY_CONNECT
        && pc->connection->type == SOCK_STREAM)
    {
        ngx_stream_upstream_rr_peers_rlock(rrp->peers);
        ngx_stream_upstream_rr_peer_lock(rrp->peers, peer);

        if (peer->accessed < peer->checked) {
            peer->fails = 0;
        }

        ngx_stream_upstream_rr_peer_unlock(rrp->peers, peer);
        ngx_stream_upstream_rr_peers_unlock(rrp->peers);
    }
}",1,1,stream\ngx_stream_upstream_round_robin.c,ngx_stream_upstream_notify_round_robin_peer,,false,665,688,ngx_stream_upstream_notify_round_robin_peer,,,9,"void ngx_stream_upstream_notify_round_robin_peer (ngx_peer_connection_t*,void*,ngx_uint_t)"
462227,METHOD,stream\ngx_stream_upstream_round_robin.h:<global>,TYPE_DECL,<global>,1,57,stream\ngx_stream_upstream_round_robin.h,stream\ngx_stream_upstream_round_robin.h:<global>,,false,1,146,<global>,,,1,
462275,METHOD,stream\ngx_stream_upstream_round_robin.h:<global>,TYPE_DECL,"ngx_int_t ngx_stream_upstream_init_round_robin(ngx_conf_t *cf,
    ngx_stream_upstream_srv_conf_t *us);",11,39,stream\ngx_stream_upstream_round_robin.h,ngx_stream_upstream_init_round_robin,,false,134,135,ngx_stream_upstream_init_round_robin,,,9,"ngx_int_t ngx_stream_upstream_init_round_robin (ngx_conf_t*,ngx_stream_upstream_srv_conf_t*)"
462281,METHOD,stream\ngx_stream_upstream_round_robin.h:<global>,TYPE_DECL,"ngx_int_t ngx_stream_upstream_init_round_robin_peer(ngx_stream_session_t *s,
    ngx_stream_upstream_srv_conf_t *us);",11,39,stream\ngx_stream_upstream_round_robin.h,ngx_stream_upstream_init_round_robin_peer,,false,136,137,ngx_stream_upstream_init_round_robin_peer,,,10,"ngx_int_t ngx_stream_upstream_init_round_robin_peer (ngx_stream_session_t*,ngx_stream_upstream_srv_conf_t*)"
462287,METHOD,stream\ngx_stream_upstream_round_robin.h:<global>,TYPE_DECL,"ngx_int_t ngx_stream_upstream_create_round_robin_peer(ngx_stream_session_t *s,
    ngx_stream_upstream_resolved_t *ur);",11,39,stream\ngx_stream_upstream_round_robin.h,ngx_stream_upstream_create_round_robin_peer,,false,138,139,ngx_stream_upstream_create_round_robin_peer,,,11,"ngx_int_t ngx_stream_upstream_create_round_robin_peer (ngx_stream_session_t*,ngx_stream_upstream_resolved_t*)"
462293,METHOD,stream\ngx_stream_upstream_round_robin.h:<global>,TYPE_DECL,"ngx_int_t ngx_stream_upstream_get_round_robin_peer(ngx_peer_connection_t *pc,
    void *data);",11,15,stream\ngx_stream_upstream_round_robin.h,ngx_stream_upstream_get_round_robin_peer,,false,140,141,ngx_stream_upstream_get_round_robin_peer,,,12,"ngx_int_t ngx_stream_upstream_get_round_robin_peer (ngx_peer_connection_t*,void*)"
462299,METHOD,stream\ngx_stream_upstream_round_robin.h:<global>,TYPE_DECL,"void ngx_stream_upstream_free_round_robin_peer(ngx_peer_connection_t *pc,
    void *data, ngx_uint_t state);",6,33,stream\ngx_stream_upstream_round_robin.h,ngx_stream_upstream_free_round_robin_peer,,false,142,143,ngx_stream_upstream_free_round_robin_peer,,,13,"void ngx_stream_upstream_free_round_robin_peer (ngx_peer_connection_t*,void*,ngx_uint_t)"
462315,METHOD,stream\ngx_stream_upstream_zone_module.c:<global>,TYPE_DECL,<global>,1,1,stream\ngx_stream_upstream_zone_module.c,stream\ngx_stream_upstream_zone_module.c:<global>,,false,1,322,<global>,,,1,
462317,METHOD,stream\ngx_stream_upstream_zone_module.c:<global>,TYPE_DECL,"static char *ngx_stream_upstream_zone(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);",13,15,stream\ngx_stream_upstream_zone_module.c,ngx_stream_upstream_zone,,false,13,14,ngx_stream_upstream_zone,,,1,"char* ngx_stream_upstream_zone (ngx_conf_t*,ngx_command_t*,void*)"
462324,METHOD,stream\ngx_stream_upstream_zone_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_upstream_init_zone(ngx_shm_zone_t *shm_zone,
    void *data);",18,15,stream\ngx_stream_upstream_zone_module.c,ngx_stream_upstream_init_zone,,false,15,16,ngx_stream_upstream_init_zone,,,2,"ngx_int_t ngx_stream_upstream_init_zone (ngx_shm_zone_t*,void*)"
462330,METHOD,stream\ngx_stream_upstream_zone_module.c:<global>,TYPE_DECL,"static ngx_stream_upstream_rr_peers_t *ngx_stream_upstream_zone_copy_peers(
    ngx_slab_pool_t *shpool, ngx_stream_upstream_srv_conf_t *uscf);",39,66,stream\ngx_stream_upstream_zone_module.c,ngx_stream_upstream_zone_copy_peers,,false,17,18,ngx_stream_upstream_zone_copy_peers,,,3,"ngx_stream_upstream_rr_peers_t* ngx_stream_upstream_zone_copy_peers (ngx_slab_pool_t*,ngx_stream_upstream_srv_conf_t*)"
462336,METHOD,stream\ngx_stream_upstream_zone_module.c:<global>,TYPE_DECL,"static ngx_stream_upstream_rr_peer_t *ngx_stream_upstream_zone_copy_peer(
    ngx_stream_upstream_rr_peers_t *peers, ngx_stream_upstream_rr_peer_t *src);",38,78,stream\ngx_stream_upstream_zone_module.c,ngx_stream_upstream_zone_copy_peer,,false,19,20,ngx_stream_upstream_zone_copy_peer,,,4,"ngx_stream_upstream_rr_peer_t* ngx_stream_upstream_zone_copy_peer (ngx_stream_upstream_rr_peers_t*,ngx_stream_upstream_rr_peer_t*)"
462384,METHOD,stream\ngx_stream_upstream_zone_module.c:<global>,TYPE_DECL,"static char *
ngx_stream_upstream_zone(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ssize_t                           size;
    ngx_str_t                        *value;
    ngx_stream_upstream_srv_conf_t   *uscf;
    ngx_stream_upstream_main_conf_t  *umcf;

    uscf = ngx_stream_conf_get_module_srv_conf(cf, ngx_stream_upstream_module);
    umcf = ngx_stream_conf_get_module_main_conf(cf, ngx_stream_upstream_module);

    value = cf->args->elts;

    if (!value[1].len) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""invalid zone name \""%V\"""", &value[1]);
        return NGX_CONF_ERROR;
    }

    if (cf->args->nelts == 3) {
        size = ngx_parse_size(&value[2]);

        if (size == NGX_ERROR) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               ""invalid zone size \""%V\"""", &value[2]);
            return NGX_CONF_ERROR;
        }

        if (size < (ssize_t) (8 * ngx_pagesize)) {
            ngx_conf_log_error(...",1,1,stream\ngx_stream_upstream_zone_module.c,ngx_stream_upstream_zone,,false,64,114,ngx_stream_upstream_zone,,,11,"char* ngx_stream_upstream_zone (ngx_conf_t*,ngx_command_t*,void*)"
462532,METHOD,stream\ngx_stream_upstream_zone_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_upstream_init_zone(ngx_shm_zone_t *shm_zone, void *data)
{
    size_t                            len;
    ngx_uint_t                        i;
    ngx_slab_pool_t                  *shpool;
    ngx_stream_upstream_rr_peers_t   *peers, **peersp;
    ngx_stream_upstream_srv_conf_t   *uscf, **uscfp;
    ngx_stream_upstream_main_conf_t  *umcf;

    shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;
    umcf = shm_zone->data;
    uscfp = umcf->upstreams.elts;

    if (shm_zone->shm.exists) {
        peers = shpool->data;

        for (i = 0; i < umcf->upstreams.nelts; i++) {
            uscf = uscfp[i];

            if (uscf->shm_zone != shm_zone) {
                continue;
            }

            uscf->peer.data = peers;
            peers = peers->zone_next;
        }

        return NGX_OK;
    }

    len = sizeof("" in upstream zone \""\"""") + shm_zone->shm.name.len;

    shpool->log_ctx = ngx_slab_alloc(shpool, len);
    if (shpool->log_ctx == NULL) {
      ...",1,1,stream\ngx_stream_upstream_zone_module.c,ngx_stream_upstream_init_zone,,false,117,180,ngx_stream_upstream_init_zone,,,12,"ngx_int_t ngx_stream_upstream_init_zone (ngx_shm_zone_t*,void*)"
462722,METHOD,stream\ngx_stream_upstream_zone_module.c:<global>,TYPE_DECL,"static ngx_stream_upstream_rr_peers_t *
ngx_stream_upstream_zone_copy_peers(ngx_slab_pool_t *shpool,
    ngx_stream_upstream_srv_conf_t *uscf)
{
    ngx_str_t                       *name;
    ngx_stream_upstream_rr_peer_t   *peer, **peerp;
    ngx_stream_upstream_rr_peers_t  *peers, *backup;

    peers = ngx_slab_alloc(shpool, sizeof(ngx_stream_upstream_rr_peers_t));
    if (peers == NULL) {
        return NULL;
    }

    ngx_memcpy(peers, uscf->peer.data, sizeof(ngx_stream_upstream_rr_peers_t));

    name = ngx_slab_alloc(shpool, sizeof(ngx_str_t));
    if (name == NULL) {
        return NULL;
    }

    name->data = ngx_slab_alloc(shpool, peers->name->len);
    if (name->data == NULL) {
        return NULL;
    }

    ngx_memcpy(name->data, peers->name->data, peers->name->len);
    name->len = peers->name->len;

    peers->name = name;

    peers->shpool = shpool;

    for (peerp = &peers->peer; *peerp; peerp = &peer->next) {
        /* pool is unlocked */
        peer = ngx_stre...",1,1,stream\ngx_stream_upstream_zone_module.c,ngx_stream_upstream_zone_copy_peers,,false,183,257,ngx_stream_upstream_zone_copy_peers,,,13,"ngx_stream_upstream_rr_peers_t ngx_stream_upstream_zone_copy_peers (ngx_slab_pool_t*,ngx_stream_upstream_srv_conf_t*)"
462942,METHOD,stream\ngx_stream_upstream_zone_module.c:<global>,TYPE_DECL,"static ngx_stream_upstream_rr_peer_t *
ngx_stream_upstream_zone_copy_peer(ngx_stream_upstream_rr_peers_t *peers,
    ngx_stream_upstream_rr_peer_t *src)
{
    ngx_slab_pool_t                *pool;
    ngx_stream_upstream_rr_peer_t  *dst;

    pool = peers->shpool;

    dst = ngx_slab_calloc_locked(pool, sizeof(ngx_stream_upstream_rr_peer_t));
    if (dst == NULL) {
        return NULL;
    }

    if (src) {
        ngx_memcpy(dst, src, sizeof(ngx_stream_upstream_rr_peer_t));
        dst->sockaddr = NULL;
        dst->name.data = NULL;
        dst->server.data = NULL;
    }

    dst->sockaddr = ngx_slab_calloc_locked(pool, sizeof(ngx_sockaddr_t));
    if (dst->sockaddr == NULL) {
        goto failed;
    }

    dst->name.data = ngx_slab_calloc_locked(pool, NGX_SOCKADDR_STRLEN);
    if (dst->name.data == NULL) {
        goto failed;
    }

    if (src) {
        ngx_memcpy(dst->sockaddr, src->sockaddr, src->socklen);
        ngx_memcpy(dst->name.data, src->name.data, src->name.len);

...",1,1,stream\ngx_stream_upstream_zone_module.c,ngx_stream_upstream_zone_copy_peer,,false,260,322,ngx_stream_upstream_zone_copy_peer,,,14,"ngx_stream_upstream_rr_peer_t ngx_stream_upstream_zone_copy_peer (ngx_stream_upstream_rr_peers_t*,ngx_stream_upstream_rr_peer_t*)"
463155,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,<global>,1,1,stream\ngx_stream_variables.c,stream\ngx_stream_variables.c:<global>,,false,1,1278,<global>,,,1,
463157,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"static ngx_stream_variable_t *ngx_stream_add_prefix_variable(ngx_conf_t *cf,
    ngx_str_t *name, ngx_uint_t flags);",30,38,stream\ngx_stream_variables.c,ngx_stream_add_prefix_variable,,false,13,14,ngx_stream_add_prefix_variable,,,1,"ngx_stream_variable_t* ngx_stream_add_prefix_variable (ngx_conf_t*,ngx_str_t*,ngx_uint_t)"
463164,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_variable_binary_remote_addr(
    ngx_stream_session_t *s, ngx_stream_variable_value_t *v, uintptr_t data);",18,76,stream\ngx_stream_variables.c,ngx_stream_variable_binary_remote_addr,,false,16,17,ngx_stream_variable_binary_remote_addr,,,2,"ngx_int_t ngx_stream_variable_binary_remote_addr (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
463171,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_variable_remote_addr(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data);",18,51,stream\ngx_stream_variables.c,ngx_stream_variable_remote_addr,,false,18,19,ngx_stream_variable_remote_addr,,,3,"ngx_int_t ngx_stream_variable_remote_addr (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
463178,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_variable_remote_port(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data);",18,51,stream\ngx_stream_variables.c,ngx_stream_variable_remote_port,,false,20,21,ngx_stream_variable_remote_port,,,4,"ngx_int_t ngx_stream_variable_remote_port (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
463185,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_variable_proxy_protocol_addr(
    ngx_stream_session_t *s, ngx_stream_variable_value_t *v, uintptr_t data);",18,76,stream\ngx_stream_variables.c,ngx_stream_variable_proxy_protocol_addr,,false,22,23,ngx_stream_variable_proxy_protocol_addr,,,5,"ngx_int_t ngx_stream_variable_proxy_protocol_addr (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
463192,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_variable_proxy_protocol_port(
    ngx_stream_session_t *s, ngx_stream_variable_value_t *v, uintptr_t data);",18,76,stream\ngx_stream_variables.c,ngx_stream_variable_proxy_protocol_port,,false,24,25,ngx_stream_variable_proxy_protocol_port,,,6,"ngx_int_t ngx_stream_variable_proxy_protocol_port (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
463199,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_variable_server_addr(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data);",18,51,stream\ngx_stream_variables.c,ngx_stream_variable_server_addr,,false,26,27,ngx_stream_variable_server_addr,,,7,"ngx_int_t ngx_stream_variable_server_addr (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
463206,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_variable_server_port(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data);",18,51,stream\ngx_stream_variables.c,ngx_stream_variable_server_port,,false,28,29,ngx_stream_variable_server_port,,,8,"ngx_int_t ngx_stream_variable_server_port (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
463213,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_variable_bytes(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data);",18,51,stream\ngx_stream_variables.c,ngx_stream_variable_bytes,,false,30,31,ngx_stream_variable_bytes,,,9,"ngx_int_t ngx_stream_variable_bytes (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
463220,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_variable_session_time(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data);",18,51,stream\ngx_stream_variables.c,ngx_stream_variable_session_time,,false,32,33,ngx_stream_variable_session_time,,,10,"ngx_int_t ngx_stream_variable_session_time (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
463227,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_variable_status(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data);",18,51,stream\ngx_stream_variables.c,ngx_stream_variable_status,,false,34,35,ngx_stream_variable_status,,,11,"ngx_int_t ngx_stream_variable_status (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
463234,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_variable_connection(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data);",18,51,stream\ngx_stream_variables.c,ngx_stream_variable_connection,,false,36,37,ngx_stream_variable_connection,,,12,"ngx_int_t ngx_stream_variable_connection (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
463241,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_variable_nginx_version(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data);",18,51,stream\ngx_stream_variables.c,ngx_stream_variable_nginx_version,,false,39,40,ngx_stream_variable_nginx_version,,,13,"ngx_int_t ngx_stream_variable_nginx_version (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
463248,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_variable_hostname(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data);",18,51,stream\ngx_stream_variables.c,ngx_stream_variable_hostname,,false,41,42,ngx_stream_variable_hostname,,,14,"ngx_int_t ngx_stream_variable_hostname (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
463255,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_variable_pid(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data);",18,51,stream\ngx_stream_variables.c,ngx_stream_variable_pid,,false,43,44,ngx_stream_variable_pid,,,15,"ngx_int_t ngx_stream_variable_pid (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
463262,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_variable_msec(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data);",18,51,stream\ngx_stream_variables.c,ngx_stream_variable_msec,,false,45,46,ngx_stream_variable_msec,,,16,"ngx_int_t ngx_stream_variable_msec (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
463269,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_variable_time_iso8601(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data);",18,51,stream\ngx_stream_variables.c,ngx_stream_variable_time_iso8601,,false,47,48,ngx_stream_variable_time_iso8601,,,17,"ngx_int_t ngx_stream_variable_time_iso8601 (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
463276,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_variable_time_local(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data);",18,51,stream\ngx_stream_variables.c,ngx_stream_variable_time_local,,false,49,50,ngx_stream_variable_time_local,,,18,"ngx_int_t ngx_stream_variable_time_local (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
463283,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_variable_protocol(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data);",18,51,stream\ngx_stream_variables.c,ngx_stream_variable_protocol,,false,51,52,ngx_stream_variable_protocol,,,19,"ngx_int_t ngx_stream_variable_protocol (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
463485,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"ngx_stream_variable_t *
ngx_stream_add_variable(ngx_conf_t *cf, ngx_str_t *name, ngx_uint_t flags)
{
    ngx_int_t                     rc;
    ngx_uint_t                    i;
    ngx_hash_key_t               *key;
    ngx_stream_variable_t        *v;
    ngx_stream_core_main_conf_t  *cmcf;

    if (name->len == 0) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""invalid variable name \""$\"""");
        return NULL;
    }

    if (flags & NGX_STREAM_VAR_PREFIX) {
        return ngx_stream_add_prefix_variable(cf, name, flags);
    }

    cmcf = ngx_stream_conf_get_module_main_conf(cf, ngx_stream_core_module);

    key = cmcf->variables_keys->keys.elts;
    for (i = 0; i < cmcf->variables_keys->keys.nelts; i++) {
        if (name->len != key[i].key.len
            || ngx_strncasecmp(name->data, key[i].key.data, name->len) != 0)
        {
            continue;
        }

        v = key[i].value;

        if (!(v->flags & NGX_STREAM_VAR_CHANGEABLE)) {
      ...",1,1,stream\ngx_stream_variables.c,ngx_stream_add_variable,,false,137,213,ngx_stream_add_variable,,,28,"ngx_stream_variable_t ngx_stream_add_variable (ngx_conf_t*,ngx_str_t*,ngx_uint_t)"
463739,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"static ngx_stream_variable_t *
ngx_stream_add_prefix_variable(ngx_conf_t *cf, ngx_str_t *name,
    ngx_uint_t flags)
{
    ngx_uint_t                    i;
    ngx_stream_variable_t        *v;
    ngx_stream_core_main_conf_t  *cmcf;

    cmcf = ngx_stream_conf_get_module_main_conf(cf, ngx_stream_core_module);

    v = cmcf->prefix_variables.elts;
    for (i = 0; i < cmcf->prefix_variables.nelts; i++) {
        if (name->len != v[i].name.len
            || ngx_strncasecmp(name->data, v[i].name.data, name->len) != 0)
        {
            continue;
        }

        v = &v[i];

        if (!(v->flags & NGX_STREAM_VAR_CHANGEABLE)) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               ""the duplicate \""%V\"" variable"", name);
            return NULL;
        }

        if (!(flags & NGX_STREAM_VAR_WEAK)) {
            v->flags &= ~NGX_STREAM_VAR_WEAK;
        }

        return v;
    }

    v = ngx_array_push(&cmcf->prefix_variables);
    if (v == NULL) {
...",1,1,stream\ngx_stream_variables.c,ngx_stream_add_prefix_variable,,false,216,269,ngx_stream_add_prefix_variable,,,29,"ngx_stream_variable_t ngx_stream_add_prefix_variable (ngx_conf_t*,ngx_str_t*,ngx_uint_t)"
463929,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"ngx_int_t
ngx_stream_get_variable_index(ngx_conf_t *cf, ngx_str_t *name)
{
    ngx_uint_t                    i;
    ngx_stream_variable_t        *v;
    ngx_stream_core_main_conf_t  *cmcf;

    if (name->len == 0) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                           ""invalid variable name \""$\"""");
        return NGX_ERROR;
    }

    cmcf = ngx_stream_conf_get_module_main_conf(cf, ngx_stream_core_module);

    v = cmcf->variables.elts;

    if (v == NULL) {
        if (ngx_array_init(&cmcf->variables, cf->pool, 4,
                           sizeof(ngx_stream_variable_t))
            != NGX_OK)
        {
            return NGX_ERROR;
        }

    } else {
        for (i = 0; i < cmcf->variables.nelts; i++) {
            if (name->len != v[i].name.len
                || ngx_strncasecmp(name->data, v[i].name.data, name->len) != 0)
            {
                continue;
            }

            return i;
        }
    }

    v = ngx_array_push(&cmcf->variab...",1,1,stream\ngx_stream_variables.c,ngx_stream_get_variable_index,,false,272,329,ngx_stream_get_variable_index,,,30,"ngx_int_t ngx_stream_get_variable_index (ngx_conf_t*,ngx_str_t*)"
464130,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"ngx_stream_variable_value_t *
ngx_stream_get_indexed_variable(ngx_stream_session_t *s, ngx_uint_t index)
{
    ngx_stream_variable_t        *v;
    ngx_stream_core_main_conf_t  *cmcf;

    cmcf = ngx_stream_get_module_main_conf(s, ngx_stream_core_module);

    if (cmcf->variables.nelts <= index) {
        ngx_log_error(NGX_LOG_ALERT, s->connection->log, 0,
                      ""unknown variable index: %ui"", index);
        return NULL;
    }

    if (s->variables[index].not_found || s->variables[index].valid) {
        return &s->variables[index];
    }

    v = cmcf->variables.elts;

    if (ngx_stream_variable_depth == 0) {
        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,
                      ""cycle while evaluating variable \""%V\"""",
                      &v[index].name);
        return NULL;
    }

    ngx_stream_variable_depth--;

    if (v[index].get_handler(s, &s->variables[index], v[index].data)
        == NGX_OK)
    {
        ngx_stream_variable_depth++;

       ...",1,1,stream\ngx_stream_variables.c,ngx_stream_get_indexed_variable,,false,332,379,ngx_stream_get_indexed_variable,,,31,"ngx_stream_variable_value_t ngx_stream_get_indexed_variable (ngx_stream_session_t*,ngx_uint_t)"
464290,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"ngx_stream_variable_value_t *
ngx_stream_get_flushed_variable(ngx_stream_session_t *s, ngx_uint_t index)
{
    ngx_stream_variable_value_t  *v;

    v = &s->variables[index];

    if (v->valid || v->not_found) {
        if (!v->no_cacheable) {
            return v;
        }

        v->valid = 0;
        v->not_found = 0;
    }

    return ngx_stream_get_indexed_variable(s, index);
}",1,1,stream\ngx_stream_variables.c,ngx_stream_get_flushed_variable,,false,382,399,ngx_stream_get_flushed_variable,,,32,"ngx_stream_variable_value_t ngx_stream_get_flushed_variable (ngx_stream_session_t*,ngx_uint_t)"
464336,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"ngx_stream_variable_value_t *
ngx_stream_get_variable(ngx_stream_session_t *s, ngx_str_t *name,
    ngx_uint_t key)
{
    size_t                        len;
    ngx_uint_t                    i, n;
    ngx_stream_variable_t        *v;
    ngx_stream_variable_value_t  *vv;
    ngx_stream_core_main_conf_t  *cmcf;

    cmcf = ngx_stream_get_module_main_conf(s, ngx_stream_core_module);

    v = ngx_hash_find(&cmcf->variables_hash, key, name->data, name->len);

    if (v) {
        if (v->flags & NGX_STREAM_VAR_INDEXED) {
            return ngx_stream_get_flushed_variable(s, v->index);
        }

        if (ngx_stream_variable_depth == 0) {
            ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,
                          ""cycle while evaluating variable \""%V\"""", name);
            return NULL;
        }

        ngx_stream_variable_depth--;

        vv = ngx_palloc(s->connection->pool,
                        sizeof(ngx_stream_variable_value_t));

        if (vv && v->get_handler(s...",1,1,stream\ngx_stream_variables.c,ngx_stream_get_variable,,false,402,471,ngx_stream_get_variable,,,33,"ngx_stream_variable_value_t ngx_stream_get_variable (ngx_stream_session_t*,ngx_str_t*,ngx_uint_t)"
464572,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_variable_binary_remote_addr(ngx_stream_session_t *s,
     ngx_stream_variable_value_t *v, uintptr_t data)
{
    struct sockaddr_in   *sin;
#if (NGX_HAVE_INET6)
    struct sockaddr_in6  *sin6;
#endif

    switch (s->connection->sockaddr->sa_family) {

#if (NGX_HAVE_INET6)
    case AF_INET6:
        sin6 = (struct sockaddr_in6 *) s->connection->sockaddr;

        v->len = sizeof(struct in6_addr);
        v->valid = 1;
        v->no_cacheable = 0;
        v->not_found = 0;
        v->data = sin6->sin6_addr.s6_addr;

        break;
#endif

#if (NGX_HAVE_UNIX_DOMAIN)
    case AF_UNIX:

        v->len = s->connection->addr_text.len;
        v->valid = 1;
        v->no_cacheable = 0;
        v->not_found = 0;
        v->data = s->connection->addr_text.data;

        break;
#endif

    default: /* AF_INET */
        sin = (struct sockaddr_in *) s->connection->sockaddr;

        v->len = sizeof(in_addr_t);
        v->valid = 1;
        v->no_cacheable = 0;
       ...",1,1,stream\ngx_stream_variables.c,ngx_stream_variable_binary_remote_addr,,false,474,523,ngx_stream_variable_binary_remote_addr,,,34,"ngx_int_t ngx_stream_variable_binary_remote_addr (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
464633,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_variable_remote_addr(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data)
{
    v->len = s->connection->addr_text.len;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = s->connection->addr_text.data;

    return NGX_OK;
}",1,1,stream\ngx_stream_variables.c,ngx_stream_variable_remote_addr,,false,526,537,ngx_stream_variable_remote_addr,,,35,"ngx_int_t ngx_stream_variable_remote_addr (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
464679,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_variable_remote_port(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data)
{
    ngx_uint_t  port;

    v->len = 0;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;

    v->data = ngx_pnalloc(s->connection->pool, sizeof(""65535"") - 1);
    if (v->data == NULL) {
        return NGX_ERROR;
    }

    port = ngx_inet_get_port(s->connection->sockaddr);

    if (port > 0 && port < 65536) {
        v->len = ngx_sprintf(v->data, ""%ui"", port) - v->data;
    }

    return NGX_OK;
}",1,1,stream\ngx_stream_variables.c,ngx_stream_variable_remote_port,,false,540,563,ngx_stream_variable_remote_port,,,36,"ngx_int_t ngx_stream_variable_remote_port (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
464763,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_variable_proxy_protocol_addr(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data)
{
    ngx_str_t             *addr;
    ngx_proxy_protocol_t  *pp;

    pp = s->connection->proxy_protocol;
    if (pp == NULL) {
        v->not_found = 1;
        return NGX_OK;
    }

    addr = (ngx_str_t *) ((char *) pp + data);

    v->len = addr->len;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = addr->data;

    return NGX_OK;
}",1,1,stream\ngx_stream_variables.c,ngx_stream_variable_proxy_protocol_addr,,false,566,588,ngx_stream_variable_proxy_protocol_addr,,,37,"ngx_int_t ngx_stream_variable_proxy_protocol_addr (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
464831,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_variable_proxy_protocol_port(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data)
{
    ngx_uint_t             port;
    ngx_proxy_protocol_t  *pp;

    pp = s->connection->proxy_protocol;
    if (pp == NULL) {
        v->not_found = 1;
        return NGX_OK;
    }

    v->len = 0;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;

    v->data = ngx_pnalloc(s->connection->pool, sizeof(""65535"") - 1);
    if (v->data == NULL) {
        return NGX_ERROR;
    }

    port = *(in_port_t *) ((char *) pp + data);

    if (port > 0 && port < 65536) {
        v->len = ngx_sprintf(v->data, ""%ui"", port) - v->data;
    }

    return NGX_OK;
}",1,1,stream\ngx_stream_variables.c,ngx_stream_variable_proxy_protocol_port,,false,591,621,ngx_stream_variable_proxy_protocol_port,,,38,"ngx_int_t ngx_stream_variable_proxy_protocol_port (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
464937,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_variable_server_addr(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data)
{
    ngx_str_t  str;
    u_char     addr[NGX_SOCKADDR_STRLEN];

    str.len = NGX_SOCKADDR_STRLEN;
    str.data = addr;

    if (ngx_connection_local_sockaddr(s->connection, &str, 0) != NGX_OK) {
        return NGX_ERROR;
    }

    str.data = ngx_pnalloc(s->connection->pool, str.len);
    if (str.data == NULL) {
        return NGX_ERROR;
    }

    ngx_memcpy(str.data, addr, str.len);

    v->len = str.len;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = str.data;

    return NGX_OK;
}",1,1,stream\ngx_stream_variables.c,ngx_stream_variable_server_addr,,false,624,652,ngx_stream_variable_server_addr,,,39,"ngx_int_t ngx_stream_variable_server_addr (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
465030,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_variable_server_port(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data)
{
    ngx_uint_t  port;

    v->len = 0;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;

    if (ngx_connection_local_sockaddr(s->connection, NULL, 0) != NGX_OK) {
        return NGX_ERROR;
    }

    v->data = ngx_pnalloc(s->connection->pool, sizeof(""65535"") - 1);
    if (v->data == NULL) {
        return NGX_ERROR;
    }

    port = ngx_inet_get_port(s->connection->local_sockaddr);

    if (port > 0 && port < 65536) {
        v->len = ngx_sprintf(v->data, ""%ui"", port) - v->data;
    }

    return NGX_OK;
}",1,1,stream\ngx_stream_variables.c,ngx_stream_variable_server_port,,false,655,682,ngx_stream_variable_server_port,,,40,"ngx_int_t ngx_stream_variable_server_port (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
465126,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_variable_bytes(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data)
{
    u_char  *p;

    p = ngx_pnalloc(s->connection->pool, NGX_OFF_T_LEN);
    if (p == NULL) {
        return NGX_ERROR;
    }

    if (data == 1) {
        v->len = ngx_sprintf(p, ""%O"", s->received) - p;

    } else {
        v->len = ngx_sprintf(p, ""%O"", s->connection->sent) - p;
    }

    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = p;

    return NGX_OK;
}",1,1,stream\ngx_stream_variables.c,ngx_stream_variable_bytes,,false,685,709,ngx_stream_variable_bytes,,,41,"ngx_int_t ngx_stream_variable_bytes (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
465205,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_variable_session_time(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data)
{
    u_char          *p;
    ngx_time_t      *tp;
    ngx_msec_int_t   ms;

    p = ngx_pnalloc(s->connection->pool, NGX_TIME_T_LEN + 4);
    if (p == NULL) {
        return NGX_ERROR;
    }

    tp = ngx_timeofday();

    ms = (ngx_msec_int_t)
             ((tp->sec - s->start_sec) * 1000 + (tp->msec - s->start_msec));
    ms = ngx_max(ms, 0);

    v->len = ngx_sprintf(p, ""%T.%03M"", (time_t) ms / 1000, ms % 1000) - p;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = p;

    return NGX_OK;
}",1,1,stream\ngx_stream_variables.c,ngx_stream_variable_session_time,,false,712,738,ngx_stream_variable_session_time,,,42,"ngx_int_t ngx_stream_variable_session_time (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
465300,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_variable_status(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data)
{
    v->data = ngx_pnalloc(s->connection->pool, NGX_INT_T_LEN);
    if (v->data == NULL) {
        return NGX_ERROR;
    }

    v->len = ngx_sprintf(v->data, ""%03ui"", s->status) - v->data;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;

    return NGX_OK;
}",1,1,stream\ngx_stream_variables.c,ngx_stream_variable_status,,false,741,756,ngx_stream_variable_status,,,43,"ngx_int_t ngx_stream_variable_status (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
465360,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_variable_connection(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data)
{
    u_char  *p;

    p = ngx_pnalloc(s->connection->pool, NGX_ATOMIC_T_LEN);
    if (p == NULL) {
        return NGX_ERROR;
    }

    v->len = ngx_sprintf(p, ""%uA"", s->connection->number) - p;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = p;

    return NGX_OK;
}",1,1,stream\ngx_stream_variables.c,ngx_stream_variable_connection,,false,759,777,ngx_stream_variable_connection,,,44,"ngx_int_t ngx_stream_variable_connection (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
465420,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_variable_nginx_version(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data)
{
    v->len = sizeof(NGINX_VERSION) - 1;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = (u_char *) NGINX_VERSION;

    return NGX_OK;
}",1,1,stream\ngx_stream_variables.c,ngx_stream_variable_nginx_version,,false,780,791,ngx_stream_variable_nginx_version,,,45,"ngx_int_t ngx_stream_variable_nginx_version (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
465459,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_variable_hostname(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data)
{
    v->len = ngx_cycle->hostname.len;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = ngx_cycle->hostname.data;

    return NGX_OK;
}",1,1,stream\ngx_stream_variables.c,ngx_stream_variable_hostname,,false,794,805,ngx_stream_variable_hostname,,,46,"ngx_int_t ngx_stream_variable_hostname (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
465501,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_variable_pid(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data)
{
    u_char  *p;

    p = ngx_pnalloc(s->connection->pool, NGX_INT64_LEN);
    if (p == NULL) {
        return NGX_ERROR;
    }

    v->len = ngx_sprintf(p, ""%P"", ngx_pid) - p;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = p;

    return NGX_OK;
}",1,1,stream\ngx_stream_variables.c,ngx_stream_variable_pid,,false,808,826,ngx_stream_variable_pid,,,47,"ngx_int_t ngx_stream_variable_pid (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
465557,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_variable_msec(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data)
{
    u_char      *p;
    ngx_time_t  *tp;

    p = ngx_pnalloc(s->connection->pool, NGX_TIME_T_LEN + 4);
    if (p == NULL) {
        return NGX_ERROR;
    }

    tp = ngx_timeofday();

    v->len = ngx_sprintf(p, ""%T.%03M"", tp->sec, tp->msec) - p;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = p;

    return NGX_OK;
}",1,1,stream\ngx_stream_variables.c,ngx_stream_variable_msec,,false,829,850,ngx_stream_variable_msec,,,48,"ngx_int_t ngx_stream_variable_msec (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
465624,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_variable_time_iso8601(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data)
{
    u_char  *p;

    p = ngx_pnalloc(s->connection->pool, ngx_cached_http_log_iso8601.len);
    if (p == NULL) {
        return NGX_ERROR;
    }

    ngx_memcpy(p, ngx_cached_http_log_iso8601.data,
               ngx_cached_http_log_iso8601.len);

    v->len = ngx_cached_http_log_iso8601.len;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = p;

    return NGX_OK;
}",1,1,stream\ngx_stream_variables.c,ngx_stream_variable_time_iso8601,,false,853,874,ngx_stream_variable_time_iso8601,,,49,"ngx_int_t ngx_stream_variable_time_iso8601 (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
465687,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_variable_time_local(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data)
{
    u_char  *p;

    p = ngx_pnalloc(s->connection->pool, ngx_cached_http_log_time.len);
    if (p == NULL) {
        return NGX_ERROR;
    }

    ngx_memcpy(p, ngx_cached_http_log_time.data, ngx_cached_http_log_time.len);

    v->len = ngx_cached_http_log_time.len;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = p;

    return NGX_OK;
}",1,1,stream\ngx_stream_variables.c,ngx_stream_variable_time_local,,false,877,897,ngx_stream_variable_time_local,,,50,"ngx_int_t ngx_stream_variable_time_local (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
465750,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_variable_protocol(ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data)
{
    v->len = 3;
    v->valid = 1;
    v->no_cacheable = 0;
    v->not_found = 0;
    v->data = (u_char *) (s->connection->type == SOCK_DGRAM ? ""UDP"" : ""TCP"");

    return NGX_OK;
}",1,1,stream\ngx_stream_variables.c,ngx_stream_variable_protocol,,false,900,911,ngx_stream_variable_protocol,,,51,"ngx_int_t ngx_stream_variable_protocol (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
465795,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"void *
ngx_stream_map_find(ngx_stream_session_t *s, ngx_stream_map_t *map,
    ngx_str_t *match)
{
    void        *value;
    u_char      *low;
    size_t       len;
    ngx_uint_t   key;

    len = match->len;

    if (len) {
        low = ngx_pnalloc(s->connection->pool, len);
        if (low == NULL) {
            return NULL;
        }

    } else {
        low = NULL;
    }

    key = ngx_hash_strlow(low, match->data, len);

    value = ngx_hash_find_combined(&map->hash, key, low, len);
    if (value) {
        return value;
    }

#if (NGX_PCRE)

    if (len && map->nregex) {
        ngx_int_t                n;
        ngx_uint_t               i;
        ngx_stream_map_regex_t  *reg;

        reg = map->regex;

        for (i = 0; i < map->nregex; i++) {

            n = ngx_stream_regex_exec(s, reg[i].regex, match);

            if (n == NGX_OK) {
                return reg[i].value;
            }

            if (n == NGX_DECLINED) {
                continue;
            }
...",1,1,stream\ngx_stream_variables.c,ngx_stream_map_find,,false,914,972,ngx_stream_map_find,,,52,"void* ngx_stream_map_find (ngx_stream_session_t*,ngx_stream_map_t*,ngx_str_t*)"
465860,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"ngx_int_t
ngx_stream_variables_add_core_vars(ngx_conf_t *cf)
{
    ngx_stream_variable_t        *cv, *v;
    ngx_stream_core_main_conf_t  *cmcf;

    cmcf = ngx_stream_conf_get_module_main_conf(cf, ngx_stream_core_module);

    cmcf->variables_keys = ngx_pcalloc(cf->temp_pool,
                                       sizeof(ngx_hash_keys_arrays_t));
    if (cmcf->variables_keys == NULL) {
        return NGX_ERROR;
    }

    cmcf->variables_keys->pool = cf->pool;
    cmcf->variables_keys->temp_pool = cf->pool;

    if (ngx_hash_keys_array_init(cmcf->variables_keys, NGX_HASH_SMALL)
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    if (ngx_array_init(&cmcf->prefix_variables, cf->pool, 8,
                       sizeof(ngx_stream_variable_t))
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    for (cv = ngx_stream_core_variables; cv->name.len; cv++) {
        v = ngx_stream_add_variable(cf, &cv->name, cv->flags);
        if (v == NULL) {
            return NGX_ERROR;...",1,1,stream\ngx_stream_variables.c,ngx_stream_variables_add_core_vars,,false,1130,1170,ngx_stream_variables_add_core_vars,,,53,ngx_int_t ngx_stream_variables_add_core_vars (ngx_conf_t*)
465976,METHOD,stream\ngx_stream_variables.c:<global>,TYPE_DECL,"ngx_int_t
ngx_stream_variables_init_vars(ngx_conf_t *cf)
{
    size_t                        len;
    ngx_uint_t                    i, n;
    ngx_hash_key_t               *key;
    ngx_hash_init_t               hash;
    ngx_stream_variable_t        *v, *av, *pv;
    ngx_stream_core_main_conf_t  *cmcf;

    /* set the handlers for the indexed stream variables */

    cmcf = ngx_stream_conf_get_module_main_conf(cf, ngx_stream_core_module);

    v = cmcf->variables.elts;
    pv = cmcf->prefix_variables.elts;
    key = cmcf->variables_keys->keys.elts;

    for (i = 0; i < cmcf->variables.nelts; i++) {

        for (n = 0; n < cmcf->variables_keys->keys.nelts; n++) {

            av = key[n].value;

            if (v[i].name.len == key[n].key.len
                && ngx_strncmp(v[i].name.data, key[n].key.data, v[i].name.len)
                   == 0)
            {
                v[i].get_handler = av->get_handler;
                v[i].data = av->data;

                av->flags |= NGX_ST...",1,1,stream\ngx_stream_variables.c,ngx_stream_variables_init_vars,,false,1173,1278,ngx_stream_variables_init_vars,,,54,ngx_int_t ngx_stream_variables_init_vars (ngx_conf_t*)
466423,METHOD,stream\ngx_stream_variables.h:<global>,TYPE_DECL,<global>,1,46,stream\ngx_stream_variables.h,stream\ngx_stream_variables.h:<global>,,false,1,113,<global>,,,1,
466428,METHOD,stream\ngx_stream_variables.h:<global>,TYPE_DECL,"typedef void (*ngx_stream_set_variable_pt) (ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data);",14,51,stream\ngx_stream_variables.h,ngx_stream_set_variable_pt,,false,23,24,ngx_stream_set_variable_pt,,,4,"void ngx_stream_set_variable_pt (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
466435,METHOD,stream\ngx_stream_variables.h:<global>,TYPE_DECL,"typedef ngx_int_t (*ngx_stream_get_variable_pt) (ngx_stream_session_t *s,
    ngx_stream_variable_value_t *v, uintptr_t data);",19,51,stream\ngx_stream_variables.h,ngx_stream_get_variable_pt,,false,25,26,ngx_stream_get_variable_pt,,,5,"ngx_int_t ngx_stream_get_variable_pt (ngx_stream_session_t*,ngx_stream_variable_value_t*,uintptr_t)"
466449,METHOD,stream\ngx_stream_variables.h:<global>,TYPE_DECL,"ngx_stream_variable_t *ngx_stream_add_variable(ngx_conf_t *cf, ngx_str_t *name,
    ngx_uint_t flags);",23,21,stream\ngx_stream_variables.h,ngx_stream_add_variable,,false,49,50,ngx_stream_add_variable,,,7,"ngx_stream_variable_t* ngx_stream_add_variable (ngx_conf_t*,ngx_str_t*,ngx_uint_t)"
466456,METHOD,stream\ngx_stream_variables.h:<global>,TYPE_DECL,"ngx_int_t ngx_stream_get_variable_index(ngx_conf_t *cf, ngx_str_t *name);",11,72,stream\ngx_stream_variables.h,ngx_stream_get_variable_index,,false,51,51,ngx_stream_get_variable_index,,,8,"ngx_int_t ngx_stream_get_variable_index (ngx_conf_t*,ngx_str_t*)"
466462,METHOD,stream\ngx_stream_variables.h:<global>,TYPE_DECL,"ngx_stream_variable_value_t *ngx_stream_get_indexed_variable(
    ngx_stream_session_t *s, ngx_uint_t index);",29,46,stream\ngx_stream_variables.h,ngx_stream_get_indexed_variable,,false,52,53,ngx_stream_get_indexed_variable,,,9,"ngx_stream_variable_value_t* ngx_stream_get_indexed_variable (ngx_stream_session_t*,ngx_uint_t)"
466468,METHOD,stream\ngx_stream_variables.h:<global>,TYPE_DECL,"ngx_stream_variable_value_t *ngx_stream_get_flushed_variable(
    ngx_stream_session_t *s, ngx_uint_t index);",29,46,stream\ngx_stream_variables.h,ngx_stream_get_flushed_variable,,false,54,55,ngx_stream_get_flushed_variable,,,10,"ngx_stream_variable_value_t* ngx_stream_get_flushed_variable (ngx_stream_session_t*,ngx_uint_t)"
466474,METHOD,stream\ngx_stream_variables.h:<global>,TYPE_DECL,"ngx_stream_variable_value_t *ngx_stream_get_variable(ngx_stream_session_t *s,
    ngx_str_t *name, ngx_uint_t key);",29,36,stream\ngx_stream_variables.h,ngx_stream_get_variable,,false,57,58,ngx_stream_get_variable,,,11,"ngx_stream_variable_value_t* ngx_stream_get_variable (ngx_stream_session_t*,ngx_str_t*,ngx_uint_t)"
466486,METHOD,stream\ngx_stream_variables.h:<global>,TYPE_DECL,"void *ngx_stream_map_find(ngx_stream_session_t *s, ngx_stream_map_t *map,
    ngx_str_t *match);",6,21,stream\ngx_stream_variables.h,ngx_stream_map_find,,false,101,102,ngx_stream_map_find,,,14,"void* ngx_stream_map_find (ngx_stream_session_t*,ngx_stream_map_t*,ngx_str_t*)"
466493,METHOD,stream\ngx_stream_variables.h:<global>,TYPE_DECL,ngx_int_t ngx_stream_variables_add_core_vars(ngx_conf_t *cf);,11,60,stream\ngx_stream_variables.h,ngx_stream_variables_add_core_vars,,false,105,105,ngx_stream_variables_add_core_vars,,,15,ngx_int_t ngx_stream_variables_add_core_vars (ngx_conf_t*)
466498,METHOD,stream\ngx_stream_variables.h:<global>,TYPE_DECL,ngx_int_t ngx_stream_variables_init_vars(ngx_conf_t *cf);,11,56,stream\ngx_stream_variables.h,ngx_stream_variables_init_vars,,false,106,106,ngx_stream_variables_init_vars,,,16,ngx_int_t ngx_stream_variables_init_vars (ngx_conf_t*)
466514,METHOD,stream\ngx_stream_write_filter_module.c:<global>,TYPE_DECL,<global>,1,1,stream\ngx_stream_write_filter_module.c,stream\ngx_stream_write_filter_module.c:<global>,,false,1,305,<global>,,,1,
466520,METHOD,stream\ngx_stream_write_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t ngx_stream_write_filter(ngx_stream_session_t *s,
    ngx_chain_t *in, ngx_uint_t from_upstream);",18,46,stream\ngx_stream_write_filter_module.c,ngx_stream_write_filter,,false,19,20,ngx_stream_write_filter,,,3,"ngx_int_t ngx_stream_write_filter (ngx_stream_session_t*,ngx_chain_t*,ngx_uint_t)"
466527,METHOD,stream\ngx_stream_write_filter_module.c:<global>,TYPE_DECL,static ngx_int_t ngx_stream_write_filter_init(ngx_conf_t *cf);,18,61,stream\ngx_stream_write_filter_module.c,ngx_stream_write_filter_init,,false,21,21,ngx_stream_write_filter_init,,,4,ngx_int_t ngx_stream_write_filter_init (ngx_conf_t*)
466559,METHOD,stream\ngx_stream_write_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_write_filter(ngx_stream_session_t *s, ngx_chain_t *in,
    ngx_uint_t from_upstream)
{
    off_t                           size;
    ngx_uint_t                      last, flush, sync;
    ngx_chain_t                    *cl, *ln, **ll, **out, *chain;
    ngx_connection_t               *c;
    ngx_stream_write_filter_ctx_t  *ctx;

    ctx = ngx_stream_get_module_ctx(s, ngx_stream_write_filter_module);

    if (ctx == NULL) {
        ctx = ngx_pcalloc(s->connection->pool,
                          sizeof(ngx_stream_write_filter_ctx_t));
        if (ctx == NULL) {
            return NGX_ERROR;
        }

        ngx_stream_set_ctx(s, ctx, ngx_stream_write_filter_module);
    }

    if (from_upstream) {
        c = s->connection;
        out = &ctx->from_upstream;

    } else {
        c = s->upstream->peer.connection;
        out = &ctx->from_downstream;
    }

    if (c->error) {
        return NGX_ERROR;
    }

    size = 0;
    flush = 0;
    sync = 0;
   ...",1,1,stream\ngx_stream_write_filter_module.c,ngx_stream_write_filter,,false,52,296,ngx_stream_write_filter,,,9,"ngx_int_t ngx_stream_write_filter (ngx_stream_session_t*,ngx_chain_t*,ngx_uint_t)"
467361,METHOD,stream\ngx_stream_write_filter_module.c:<global>,TYPE_DECL,"static ngx_int_t
ngx_stream_write_filter_init(ngx_conf_t *cf)
{
    ngx_stream_top_filter = ngx_stream_write_filter;

    return NGX_OK;
}",1,1,stream\ngx_stream_write_filter_module.c,ngx_stream_write_filter_init,,false,299,305,ngx_stream_write_filter_init,,,10,ngx_int_t ngx_stream_write_filter_init (ngx_conf_t*)
469930,METHOD,<includes>:<global>,NAMESPACE_BLOCK,<global>,,,<includes>,<includes>:<global>,,false,1,,<global>,,,1,
470278,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.assignment,,true,,,<operator>.assignment,,,0,
470283,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.arrayInitializer,,true,,,<operator>.arrayInitializer,,,0,
470298,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_string,,true,,,ngx_string,,,0,
470302,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.or,,true,,,<operator>.or,,,0,
470307,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,offsetof,,true,,,offsetof,,,0,
470312,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.addressOf,,true,,,<operator>.addressOf,,,0,
470316,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.notEquals,,true,,,<operator>.notEquals,,,0,
470321,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.logicalNot,,true,,,<operator>.logicalNot,,,0,
470325,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.minus,,true,,,<operator>.minus,,,0,
470329,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_getpid,,true,,,ngx_getpid,,,0,
470332,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_getppid,,true,,,ngx_getppid,,,0,
470335,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.equals,,true,,,<operator>.equals,,,0,
470340,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_memzero,,true,,,ngx_memzero,,,0,
470345,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.sizeOf,,true,,,<operator>.sizeOf,,,0,
470349,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.fieldAccess,,true,,,<operator>.fieldAccess,,,0,
470354,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.indirectFieldAccess,,true,,,<operator>.indirectFieldAccess,,,0,
470359,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.lessThan,,true,,,<operator>.lessThan,,,0,
470364,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.postIncrement,,true,,,<operator>.postIncrement,,,0,
470368,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_write_stdout,,true,,,ngx_write_stdout,,,0,
470372,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.cast,,true,,,<operator>.cast,,,0,
470377,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.indirectIndexAccess,,true,,,<operator>.indirectIndexAccess,,,0,
470382,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.subtraction,,true,,,<operator>.subtraction,,,0,
470387,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_get_conf,,true,,,ngx_get_conf,,,0,
470392,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.logicalAnd,,true,,,<operator>.logicalAnd,,,0,
470397,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_close_file,,true,,,ngx_close_file,,,0,
470401,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getenv,,true,,,getenv,,,0,
470405,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.expressionList,,true,,,<operator>.expressionList,,,0,
470410,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.indirection,,true,,,<operator>.indirection,,,0,
470414,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.logicalOr,,true,,,<operator>.logicalOr,,,0,
470419,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.addition,,true,,,<operator>.addition,,,0,
470424,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_strcmp,,true,,,ngx_strcmp,,,0,
470429,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_strncmp,,true,,,ngx_strncmp,,,0,
470435,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.multiplication,,true,,,<operator>.multiplication,,,0,
470440,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_free,,true,,,ngx_free,,,0,
470444,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_rename_file,,true,,,ngx_rename_file,,,0,
470449,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.preIncrement,,true,,,<operator>.preIncrement,,,0,
470453,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_strlen,,true,,,ngx_strlen,,,0,
470457,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_path_separator,,true,,,ngx_path_separator,,,0,
470461,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_memcpy,,true,,,ngx_memcpy,,,0,
470467,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_getcwd,,true,,,ngx_getcwd,,,0,
470472,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_str_set,,true,,,ngx_str_set,,,0,
470477,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.greaterThan,,true,,,<operator>.greaterThan,,,0,
470482,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.postDecrement,,true,,,<operator>.postDecrement,,,0,
470486,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_conf_init_value,,true,,,ngx_conf_init_value,,,0,
470491,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_conf_init_msec_value,,true,,,ngx_conf_init_msec_value,,,0,
470496,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_cpymem,,true,,,ngx_cpymem,,,0,
470502,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,geteuid,,true,,,geteuid,,,0,
470505,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_set_errno,,true,,,ngx_set_errno,,,0,
470509,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getpwnam,,true,,,getpwnam,,,0,
470513,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getgrnam,,true,,,getgrnam,,,0,
470517,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.assignmentPlus,,true,,,<operator>.assignmentPlus,,,0,
470522,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.conditional,,true,,,<operator>.conditional,,,0,
470528,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.assignmentMinus,,true,,,<operator>.assignmentMinus,,,0,
470533,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.lessEqualsThan,,true,,,<operator>.lessEqualsThan,,,0,
470538,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.assignmentMultiplication,,true,,,<operator>.assignmentMultiplication,,,0,
470543,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.greaterEqualsThan,,true,,,<operator>.greaterEqualsThan,,,0,
470548,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_calloc_buf,,true,,,ngx_calloc_buf,,,0,
470552,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_buf_size,,true,,,ngx_buf_size,,,0,
470556,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_free_chain,,true,,,ngx_free_chain,,,0,
470561,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.and,,true,,,<operator>.and,,,0,
470566,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.not,,true,,,<operator>.not,,,0,
470570,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_buf_special,,true,,,ngx_buf_special,,,0,
470574,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_buf_in_memory,,true,,,ngx_buf_in_memory,,,0,
470578,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_file_size,,true,,,ngx_file_size,,,0,
470582,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_fd_info,,true,,,ngx_fd_info,,,0,
470587,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,core\ngx_conf_file.c,core\ngx_conf_file.c:11:11:NGX_CONF_BUFFER:0,,true,11,11,NGX_CONF_BUFFER,,,0,
470590,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,*cf->handler,,true,,,*cf->handler,,,0,
470597,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set,,true,,,set,,,0,
470604,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_memmove,,true,,,ngx_memmove,,,0,
470610,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ssize_t,,true,,,ssize_t,,,0,
470614,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_log_debug1,,true,,,ngx_log_debug1,,,0,
470622,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strpbrk,,true,,,strpbrk,,,0,
470627,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_log_debug0,,true,,,ngx_log_debug0,,,0,
470634,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,flush,,true,,,flush,,,0,
470640,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,va_start,,true,,,va_start,,,0,
470645,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,va_end,,true,,,va_end,,,0,
470649,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,post_handler,,true,,,post_handler,,,0,
470654,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operators>.assignmentOr,,true,,,<operators>.assignmentOr,,,0,
470659,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_rbtree_init,,true,,,ngx_rbtree_init,,,0,
470665,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getsockname,,true,,,getsockname,,,0,
470671,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getsockopt,,true,,,getsockopt,,,0,
470679,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_socket,,true,,,ngx_socket,,,0,
470685,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,setsockopt,,true,,,setsockopt,,,0,
470693,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_close_socket,,true,,,ngx_close_socket,,,0,
470697,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_log_debug2,,true,,,ngx_log_debug2,,,0,
470706,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,bind,,true,,,bind,,,0,
470712,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,listen,,true,,,listen,,,0,
470717,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_msleep,,true,,,ngx_msleep,,,0,
470721,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_del_event,,true,,,ngx_del_event,,,0,
470727,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_del_timer,,true,,,ngx_del_timer,,,0,
470731,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_del_conn,,true,,,ngx_del_conn,,,0,
470736,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_delete_posted_event,,true,,,ngx_delete_posted_event,,,0,
470740,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_queue_remove,,true,,,ngx_queue_remove,,,0,
470744,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_queue_insert_head,,true,,,ngx_queue_insert_head,,,0,
470749,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_max,,true,,,ngx_max,,,0,
470754,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_min,,true,,,ngx_min,,,0,
470759,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.division,,true,,,<operator>.division,,,0,
470764,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_queue_empty,,true,,,ngx_queue_empty,,,0,
470768,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_queue_last,,true,,,ngx_queue_last,,,0,
470772,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_queue_data,,true,,,ngx_queue_data,,,0,
470778,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,handler,,true,,,handler,,,0,
470784,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.arithmeticShiftRight,,true,,,<operator>.arithmeticShiftRight,,,0,
470789,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.shiftLeft,,true,,,<operator>.shiftLeft,,,0,
470794,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_align_ptr,,true,,,ngx_align_ptr,,,0,
470799,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.xor,,true,,,<operator>.xor,,,0,
470804,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_timeofday,,true,,,ngx_timeofday,,,0,
470807,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_queue_init,,true,,,ngx_queue_init,,,0,
470811,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gethostname,,true,,,gethostname,,,0,
470816,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,create_conf,,true,,,create_conf,,,0,
470821,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,init_conf,,true,,,init_conf,,,0,
470827,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_is_init_cycle,,true,,,ngx_is_init_cycle,,,0,
470831,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_log_debug3,,true,,,ngx_log_debug3,,,0,
470841,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fcntl,,true,,,fcntl,,,0,
470847,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,init,,true,,,init,,,0,
470852,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,exit,,true,,,exit,,,0,
470856,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_add_timer,,true,,,ngx_add_timer,,,0,
470861,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_delete_file,,true,,,ngx_delete_file,,,0,
470865,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,chown,,true,,,chown,,,0,
470871,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,chmod,,true,,,chmod,,,0,
470876,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_create_dir,,true,,,ngx_create_dir,,,0,
470881,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_change_file_access,,true,,,ngx_change_file_access,,,0,
470886,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_dir_access,,true,,,ngx_dir_access,,,0,
470890,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_file_access,,true,,,ngx_file_access,,,0,
470894,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_file_mtime,,true,,,ngx_file_mtime,,,0,
470898,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_str_null,,true,,,ngx_str_null,,,0,
470902,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,init_handler,,true,,,init_handler,,,0,
470908,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_de_namelen,,true,,,ngx_de_namelen,,,0,
470912,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_de_name,,true,,,ngx_de_name,,,0,
470916,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_de_is_file,,true,,,ngx_de_is_file,,,0,
470920,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_de_size,,true,,,ngx_de_size,,,0,
470924,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_de_fs_size,,true,,,ngx_de_fs_size,,,0,
470928,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_de_access,,true,,,ngx_de_access,,,0,
470932,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_de_mtime,,true,,,ngx_de_mtime,,,0,
470936,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,file_handler,,true,,,file_handler,,,0,
470942,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_de_is_dir,,true,,,ngx_de_is_dir,,,0,
470946,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pre_tree_handler,,true,,,pre_tree_handler,,,0,
470952,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,post_tree_handler,,true,,,post_tree_handler,,,0,
470958,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,spec_handler,,true,,,spec_handler,,,0,
470964,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,core\ngx_file.h,core\ngx_file.h:42:42:NGX_MAX_PATH_LEVEL:0,,true,42,42,NGX_MAX_PATH_LEVEL,,,0,
470967,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.modulo,,true,,,<operator>.modulo,,,0,
470972,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_hash,,true,,,ngx_hash,,,0,
470977,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,core\ngx_hash.c,core\ngx_hash.c:248:249:NGX_HASH_ELT_SIZE:1,,true,248,249,NGX_HASH_ELT_SIZE,,,0,
470981,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_align,,true,,,ngx_align,,,0,
470986,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,u_short,,true,,,u_short,,,0,
470990,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,key,,true,,,key,,,0,
470996,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_tolower,,true,,,ngx_tolower,,,0,
471000,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operators>.assignmentModulo,,true,,,<operators>.assignmentModulo,,,0,
471005,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,htonl,,true,,,htonl,,,0,
471009,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ntohs,,true,,,ntohs,,,0,
471013,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_strlchr,,true,,,ngx_strlchr,,,0,
471019,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uint32_t,,true,,,uint32_t,,,0,
471023,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operators>.assignmentAnd,,true,,,<operators>.assignmentAnd,,,0,
471028,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,htons,,true,,,htons,,,0,
471032,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gethostbyname,,true,,,gethostbyname,,,0,
471036,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_linefeed,,true,,,ngx_linefeed,,,0,
471040,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,writer,,true,,,writer,,,0,
471048,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_time,,true,,,ngx_time,,,0,
471051,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_vsnprintf,,true,,,ngx_vsnprintf,,,0,
471058,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,malloc,,true,,,malloc,,,0,
471062,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_set_stderr,,true,,,ngx_set_stderr,,,0,
471066,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operators>.assignmentShiftLeft,,true,,,<operators>.assignmentShiftLeft,,,0,
471071,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,size_t,,true,,,size_t,,,0,
471075,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,u_char,,true,,,u_char,,,0,
471079,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,core\ngx_md5.c,core\ngx_md5.c:131:134:STEP:8,,true,131,134,STEP,,,0,
471087,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,core\ngx_module.c,core\ngx_module.c:13:13:NGX_MAX_DYNAMIC_MODULES:0,,true,13,13,NGX_MAX_DYNAMIC_MODULES,,,0,
471090,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,init_module,,true,,,init_module,,,0,
471095,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operators>.assignmentXor,,true,,,<operators>.assignmentXor,,,0,
471100,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_file_uniq,,true,,,ngx_file_uniq,,,0,
471104,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_file_fs_size,,true,,,ngx_file_fs_size,,,0,
471108,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_is_dir,,true,,,ngx_is_dir,,,0,
471112,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_is_file,,true,,,ngx_is_file,,,0,
471116,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_is_link,,true,,,ngx_is_link,,,0,
471120,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_is_exec,,true,,,ngx_is_exec,,,0,
471124,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_log_debug4,,true,,,ngx_log_debug4,,,0,
471135,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_log_debug5,,true,,,ngx_log_debug5,,,0,
471147,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,core\ngx_open_file_cache.c,core\ngx_open_file_cache.c:21:21:NGX_MIN_READ_AHEAD:0,,true,21,21,NGX_MIN_READ_AHEAD,,,0,
471150,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_add_event,,true,,,ngx_add_event,,,0,
471156,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_rbt_red,,true,,,ngx_rbt_red,,,0,
471160,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,output_filter,,true,,,output_filter,,,0,
471166,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,core\ngx_output_chain.c,core\ngx_output_chain.c:27:27:NGX_NONE:0,,true,27,27,NGX_NONE,,,0,
471169,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,off_t,,true,,,off_t,,,0,
471173,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,send_chain,,true,,,send_chain,,,0,
471180,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_memalign,,true,,,ngx_memalign,,,0,
471186,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_palloc_small,,true,,,ngx_palloc_small,,,0,
471192,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.assignmentDivision,,true,,,<operator>.assignmentDivision,,,0,
471197,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.preDecrement,,true,,,<operator>.preDecrement,,,0,
471201,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uint64_t,,true,,,uint64_t,,,0,
471205,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,memcmp,,true,,,memcmp,,,0,
471211,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,core\ngx_proxy_protocol.c,core\ngx_proxy_protocol.c:16:16:ngx_proxy_protocol_parse_uint16:1,,true,16,16,ngx_proxy_protocol_parse_uint16,,,0,
471215,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,core\ngx_proxy_protocol.c,core\ngx_proxy_protocol.c:12:12:NGX_PROXY_PROTOCOL_AF_INET:0,,true,12,12,NGX_PROXY_PROTOCOL_AF_INET,,,0,
471218,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,memcpy,,true,,,memcpy,,,0,
471224,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_queue_head,,true,,,ngx_queue_head,,,0,
471228,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_queue_next,,true,,,ngx_queue_next,,,0,
471232,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_queue_sentinel,,true,,,ngx_queue_sentinel,,,0,
471236,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_queue_prev,,true,,,ngx_queue_prev,,,0,
471240,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,cmp,,true,,,cmp,,,0,
471245,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_queue_insert_after,,true,,,ngx_queue_insert_after,,,0,
471250,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operators>.assignmentArithmeticShiftRight,,true,,,<operators>.assignmentArithmeticShiftRight,,,0,
471255,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_rbt_black,,true,,,ngx_rbt_black,,,0,
471259,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,insert,,true,,,insert,,,0,
471266,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_rbt_is_red,,true,,,ngx_rbt_is_red,,,0,
471270,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_rbtree_left_rotate,,true,,,ngx_rbtree_left_rotate,,,0,
471276,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_rbtree_right_rotate,,true,,,ngx_rbtree_right_rotate,,,0,
471282,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_rbtree_key_int_t,,true,,,ngx_rbtree_key_int_t,,,0,
471286,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_rbtree_min,,true,,,ngx_rbtree_min,,,0,
471291,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_rbt_copy_color,,true,,,ngx_rbt_copy_color,,,0,
471296,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_rbt_is_black,,true,,,ngx_rbt_is_black,,,0,
471300,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_regex_malloc_init,,true,,,ngx_regex_malloc_init,,,0,
471304,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pcre_compile,,true,,,pcre_compile,,,0,
471312,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_regex_malloc_done,,true,,,ngx_regex_malloc_done,,,0,
471315,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pcre_fullinfo,,true,,,pcre_fullinfo,,,0,
471322,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_regex_exec,,true,,,ngx_regex_exec,,,0,
471329,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pcre_study,,true,,,pcre_study,,,0,
471335,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,core\ngx_resolver.c,core\ngx_resolver.c:54:56:ngx_resolver_node:1,,true,54,56,ngx_resolver_node,,,0,
471339,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_msec_t,,true,,,ngx_msec_t,,,0,
471343,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ntohl,,true,,,ntohl,,,0,
471347,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_send,,true,,,ngx_send,,,0,
471353,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,core\ngx_resolver.c,core\ngx_resolver.c:15:15:NGX_RESOLVER_TCP_RSIZE:0,,true,15,15,NGX_RESOLVER_TCP_RSIZE,,,0,
471356,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,core\ngx_resolver.c,core\ngx_resolver.c:16:16:NGX_RESOLVER_TCP_WSIZE:0,,true,16,16,NGX_RESOLVER_TCP_WSIZE,,,0,
471359,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_udp_recv,,true,,,ngx_udp_recv,,,0,
471365,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,core\ngx_resolver.c,core\ngx_resolver.c:13:13:NGX_RESOLVER_UDP_SIZE:0,,true,13,13,NGX_RESOLVER_UDP_SIZE,,,0,
471368,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_movemem,,true,,,ngx_movemem,,,0,
471374,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_recv,,true,,,ngx_recv,,,0,
471380,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_log_debug6,,true,,,ngx_log_debug6,,,0,
471393,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_random,,true,,,ngx_random,,,0,
471396,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,connect,,true,,,connect,,,0,
471402,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_add_conn,,true,,,ngx_add_conn,,,0,
471406,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,core\ngx_sha1.c,core\ngx_sha1.c:144:148:GET:1,,true,144,148,GET,,,0,
471410,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,core\ngx_sha1.c,core\ngx_sha1.c:124:124:ROTATE:2,,true,124,124,ROTATE,,,0,
471414,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,core\ngx_sha1.c,core\ngx_sha1.c:130:136:STEP:8,,true,130,136,STEP,,,0,
471424,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,core\ngx_slab.c,core\ngx_slab.c:44:45:ngx_slab_slots:1,,true,44,45,ngx_slab_slots,,,0,
471428,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_uint_t,,true,,,ngx_uint_t,,,0,
471432,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,core\ngx_slab.c,core\ngx_slab.c:52:54:ngx_slab_page_addr:2,,true,52,54,ngx_slab_page_addr,,,0,
471437,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uintptr_t,,true,,,uintptr_t,,,0,
471441,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,core\ngx_slab.c,core\ngx_slab.c:39:39:NGX_SLAB_BUSY:0,,true,39,39,NGX_SLAB_BUSY,,,0,
471444,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,core\ngx_slab.c,core\ngx_slab.c:49:50:ngx_slab_page_prev:1,,true,49,50,ngx_slab_page_prev,,,0,
471448,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,core\ngx_slab.c,core\ngx_slab.c:15:15:NGX_SLAB_SMALL:0,,true,15,15,NGX_SLAB_SMALL,,,0,
471451,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,core\ngx_slab.c,core\ngx_slab.c:14:14:NGX_SLAB_EXACT:0,,true,14,14,NGX_SLAB_EXACT,,,0,
471454,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,core\ngx_slab.c,core\ngx_slab.c:37:37:NGX_SLAB_MAP_SHIFT:0,,true,37,37,NGX_SLAB_MAP_SHIFT,,,0,
471457,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,core\ngx_slab.c,core\ngx_slab.c:36:36:NGX_SLAB_MAP_MASK:0,,true,36,36,NGX_SLAB_MAP_MASK,,,0,
471460,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,core\ngx_slab.c,core\ngx_slab.c:13:13:NGX_SLAB_BIG:0,,true,13,13,NGX_SLAB_BIG,,,0,
471463,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,core\ngx_slab.c,core\ngx_slab.c:47:47:ngx_slab_page_type:1,,true,47,47,ngx_slab_page_type,,,0,
471467,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,core\ngx_slab.c,core\ngx_slab.c:35:35:NGX_SLAB_SHIFT_MASK:0,,true,35,35,NGX_SLAB_SHIFT_MASK,,,0,
471470,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,core\ngx_slab.c,core\ngx_slab.c:12:12:NGX_SLAB_PAGE:0,,true,12,12,NGX_SLAB_PAGE,,,0,
471473,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,core\ngx_slab.c,core\ngx_slab.c:33:33:NGX_SLAB_PAGE_START:0,,true,33,33,NGX_SLAB_PAGE_START,,,0,
471476,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,core\ngx_slab.c,core\ngx_slab.c:32:32:NGX_SLAB_PAGE_BUSY:0,,true,32,32,NGX_SLAB_PAGE_BUSY,,,0,
471479,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,core\ngx_slab.c,core\ngx_slab.c:31:31:NGX_SLAB_PAGE_FREE:0,,true,31,31,NGX_SLAB_PAGE_FREE,,,0,
471482,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,va_arg,,true,,,va_arg,,,0,
471487,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_memcmp,,true,,,ngx_memcmp,,,0,
471493,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_memory_barrier,,true,,,ngx_memory_barrier,,,0,
471496,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_strchr,,true,,,ngx_strchr,,,0,
471501,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,core\ngx_syslog.c,core\ngx_syslog.c:12:15:NGX_SYSLOG_MAX_STR:0,,true,12,15,NGX_SYSLOG_MAX_STR,,,0,
471504,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,send,,true,,,send,,,0,
471511,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,core\ngx_thread_pool.c,core\ngx_thread_pool.c:24:26:ngx_thread_pool_queue_init:1,,true,24,26,ngx_thread_pool_queue_init,,,0,
471515,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_attr_init,,true,,,pthread_attr_init,,,0,
471519,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_attr_setdetachstate,,true,,,pthread_attr_setdetachstate,,,0,
471524,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_create,,true,,,pthread_create,,,0,
471531,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_attr_destroy,,true,,,pthread_attr_destroy,,,0,
471535,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_sched_yield,,true,,,ngx_sched_yield,,,0,
471538,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_exit,,true,,,pthread_exit,,,0,
471542,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sigfillset,,true,,,sigfillset,,,0,
471546,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sigdelset,,true,,,sigdelset,,,0,
471551,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_sigmask,,true,,,pthread_sigmask,,,0,
471557,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_unlock,,true,,,ngx_unlock,,,0,
471561,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_notify,,true,,,ngx_notify,,,0,
471565,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,core\ngx_times.c,core\ngx_times.c:24:24:NGX_TIME_SLOTS:0,,true,24,24,NGX_TIME_SLOTS,,,0,
471568,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_trylock,,true,,,ngx_trylock,,,0,
471572,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_timezone,,true,,,ngx_timezone,,,0,
471576,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_abs,,true,,,ngx_abs,,,0,
471580,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,mktime,,true,,,mktime,,,0,
471584,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_event_get_conf,,true,,,ngx_event_get_conf,,,0,
471589,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,open,,true,,,open,,,0,
471595,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,write,,true,,,write,,,0,
471601,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,close,,true,,,close,,,0,
471605,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ioctl,,true,,,ioctl,,,0,
471611,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_post_event,,true,,,ngx_post_event,,,0,
471616,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_conf_init_uint_value,,true,,,ngx_conf_init_uint_value,,,0,
471621,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,epoll_create,,true,,,epoll_create,,,0,
471625,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,epoll_ctl,,true,,,epoll_ctl,,,0,
471632,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,epoll_wait,,true,,,epoll_wait,,,0,
471639,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,port_create,,true,,,port_create,,,0,
471642,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,timer_create,,true,,,timer_create,,,0,
471648,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,timer_settime,,true,,,timer_settime,,,0,
471655,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,timer_delete,,true,,,timer_delete,,,0,
471659,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,port_associate,,true,,,port_associate,,,0,
471667,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,port_dissociate,,true,,,port_dissociate,,,0,
471673,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,port_send,,true,,,port_send,,,0,
471679,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,port_getn,,true,,,port_getn,,,0,
471687,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CreateIoCompletionPort,,true,,,CreateIoCompletionPort,,,0,
471694,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Sleep,,true,,,Sleep,,,0,
471698,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CloseHandle,,true,,,CloseHandle,,,0,
471702,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetQueuedCompletionStatus,,true,,,GetQueuedCompletionStatus,,,0,
471710,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,kqueue,,true,,,kqueue,,,0,
471713,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,kevent,,true,,,kevent,,,0,
471722,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_event_ident,,true,,,ngx_event_ident,,,0,
471726,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NGX_KQUEUE_UDATA_T,,true,,,NGX_KQUEUE_UDATA_T,,,0,
471730,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_kqueue_dump_event,,true,,,ngx_kqueue_dump_event,,,0,
471735,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,poll,,true,,,poll,,,0,
471741,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FD_ZERO,,true,,,FD_ZERO,,,0,
471745,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FD_SET,,true,,,FD_SET,,,0,
471750,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FD_CLR,,true,,,FD_CLR,,,0,
471755,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,select,,true,,,select,,,0,
471763,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FD_ISSET,,true,,,FD_ISSET,,,0,
471768,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WSAPoll,,true,,,WSAPoll,,,0,
471774,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_process_events,,true,,,ngx_process_events,,,0,
471780,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getrlimit,,true,,,getrlimit,,,0,
471785,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sigemptyset,,true,,,sigemptyset,,,0,
471789,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sigaction,,true,,,sigaction,,,0,
471795,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,setitimer,,true,,,setitimer,,,0,
471801,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,event\ngx_event.c,event\ngx_event.c:13:13:DEFAULT_CONNECTIONS:0,,true,13,13,DEFAULT_CONNECTIONS,,,0,
471804,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_conf_init_ptr_value,,true,,,ngx_conf_init_ptr_value,,,0,
471809,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,accept,,true,,,accept,,,0,
471815,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_getacceptexsockaddrs,,true,,,ngx_getacceptexsockaddrs,,,0,
471826,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_acceptex,,true,,,ngx_acceptex,,,0,
471837,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,get,,true,,,get,,,0,
471843,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,event\ngx_event_connectex.c,event\ngx_event_connectex.c:13:13:NGX_MAX_PENDING_CONN:0,,true,13,13,NGX_MAX_PENDING_CONN,,,0,
471846,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EnterCriticalSection,,true,,,EnterCriticalSection,,,0,
471850,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LeaveCriticalSection,,true,,,LeaveCriticalSection,,,0,
471854,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetEvent,,true,,,SetEvent,,,0,
471858,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,msleep,,true,,,msleep,,,0,
471862,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_iocp_new_thread,,true,,,ngx_iocp_new_thread,,,0,
471866,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CreateEvent,,true,,,CreateEvent,,,0,
471873,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CreateThread,,true,,,CreateThread,,,0,
471882,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WSACreateEvent,,true,,,WSACreateEvent,,,0,
471885,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WSAEventSelect,,true,,,WSAEventSelect,,,0,
471891,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WSAWaitForMultipleEvents,,true,,,WSAWaitForMultipleEvents,,,0,
471899,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ExitThread,,true,,,ExitThread,,,0,
471903,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_iocp_new_connect,,true,,,ngx_iocp_new_connect,,,0,
471906,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WSAEnumNetworkEvents,,true,,,WSAEnumNetworkEvents,,,0,
471912,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PostQueuedCompletionStatus,,true,,,PostQueuedCompletionStatus,,,0,
471919,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OPENSSL_config,,true,,,OPENSSL_config,,,0,
471923,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_library_init,,true,,,SSL_library_init,,,0,
471926,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_load_error_strings,,true,,,SSL_load_error_strings,,,0,
471929,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OpenSSL_add_all_algorithms,,true,,,OpenSSL_add_all_algorithms,,,0,
471932,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,STACK_OF,,true,,,STACK_OF,,,0,
471936,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_COMP_get_compression_methods,,true,,,SSL_COMP_get_compression_methods,,,0,
471939,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sk_SSL_COMP_num,,true,,,sk_SSL_COMP_num,,,0,
471943,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sk_SSL_COMP_pop,,true,,,sk_SSL_COMP_pop,,,0,
471947,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_get_ex_new_index,,true,,,SSL_get_ex_new_index,,,0,
471955,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_get_ex_new_index,,true,,,SSL_CTX_get_ex_new_index,,,0,
471963,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_get_ex_new_index,,true,,,X509_get_ex_new_index,,,0,
471971,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_new,,true,,,SSL_CTX_new,,,0,
471975,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSLv23_method,,true,,,SSLv23_method,,,0,
471978,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_set_ex_data,,true,,,SSL_CTX_set_ex_data,,,0,
471984,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_set_options,,true,,,SSL_CTX_set_options,,,0,
471989,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_set_read_ahead,,true,,,SSL_CTX_set_read_ahead,,,0,
471994,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_set_info_callback,,true,,,SSL_CTX_set_info_callback,,,0,
471999,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_ssl_load_certificate,,true,,,ngx_ssl_load_certificate,,,0,
472006,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_use_certificate,,true,,,SSL_CTX_use_certificate,,,0,
472011,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_free,,true,,,X509_free,,,0,
472015,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sk_X509_pop_free,,true,,,sk_X509_pop_free,,,0,
472020,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_set_ex_data,,true,,,X509_set_ex_data,,,0,
472026,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_get_ex_data,,true,,,SSL_CTX_get_ex_data,,,0,
472031,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sk_X509_num,,true,,,sk_X509_num,,,0,
472035,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sk_X509_shift,,true,,,sk_X509_shift,,,0,
472039,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_add_extra_chain_cert,,true,,,SSL_CTX_add_extra_chain_cert,,,0,
472044,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sk_X509_free,,true,,,sk_X509_free,,,0,
472048,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_use_PrivateKey,,true,,,SSL_CTX_use_PrivateKey,,,0,
472053,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_PKEY_free,,true,,,EVP_PKEY_free,,,0,
472057,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_use_certificate,,true,,,SSL_use_certificate,,,0,
472062,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_use_PrivateKey,,true,,,SSL_use_PrivateKey,,,0,
472067,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ENGINE_by_id,,true,,,ENGINE_by_id,,,0,
472071,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ENGINE_load_private_key,,true,,,ENGINE_load_private_key,,,0,
472078,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ENGINE_free,,true,,,ENGINE_free,,,0,
472082,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIO_new_mem_buf,,true,,,BIO_new_mem_buf,,,0,
472087,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIO_new_file,,true,,,BIO_new_file,,,0,
472092,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PEM_read_bio_PrivateKey,,true,,,PEM_read_bio_PrivateKey,,,0,
472099,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ERR_clear_error,,true,,,ERR_clear_error,,,0,
472102,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIO_reset,,true,,,BIO_reset,,,0,
472106,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIO_free,,true,,,BIO_free,,,0,
472110,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_set_cipher_list,,true,,,SSL_CTX_set_cipher_list,,,0,
472115,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_set_tmp_rsa_callback,,true,,,SSL_CTX_set_tmp_rsa_callback,,,0,
472120,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_set_verify,,true,,,SSL_CTX_set_verify,,,0,
472126,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_set_verify_depth,,true,,,SSL_CTX_set_verify_depth,,,0,
472131,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_load_verify_locations,,true,,,SSL_CTX_load_verify_locations,,,0,
472137,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_load_client_CA_file,,true,,,SSL_load_client_CA_file,,,0,
472141,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_set_client_CA_list,,true,,,SSL_CTX_set_client_CA_list,,,0,
472146,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_get_cert_store,,true,,,SSL_CTX_get_cert_store,,,0,
472150,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_STORE_add_lookup,,true,,,X509_STORE_add_lookup,,,0,
472155,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_LOOKUP_file,,true,,,X509_LOOKUP_file,,,0,
472158,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_LOOKUP_load_file,,true,,,X509_LOOKUP_load_file,,,0,
472164,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_STORE_set_flags,,true,,,X509_STORE_set_flags,,,0,
472169,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_is_server,,true,,,SSL_is_server,,,0,
472173,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_ssl_get_connection,,true,,,ngx_ssl_get_connection,,,0,
472177,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_get_rbio,,true,,,SSL_get_rbio,,,0,
472181,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_get_wbio,,true,,,SSL_get_wbio,,,0,
472185,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIO_set_write_buffer_size,,true,,,BIO_set_write_buffer_size,,,0,
472190,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RSA_generate_key,,true,,,RSA_generate_key,,,0,
472197,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,event\ngx_event_openssl.c,event\ngx_event_openssl.c:13:13:NGX_SSL_PASSWORD_BUFFER_SIZE:0,,true,13,13,NGX_SSL_PASSWORD_BUFFER_SIZE,,,0,
472200,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PEM_read_bio_DHparams,,true,,,PEM_read_bio_DHparams,,,0,
472207,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_set_tmp_dh,,true,,,SSL_CTX_set_tmp_dh,,,0,
472212,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DH_free,,true,,,DH_free,,,0,
472216,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OBJ_sn2nid,,true,,,OBJ_sn2nid,,,0,
472220,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EC_KEY_new_by_curve_name,,true,,,EC_KEY_new_by_curve_name,,,0,
472224,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_set_tmp_ecdh,,true,,,SSL_CTX_set_tmp_ecdh,,,0,
472229,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EC_KEY_free,,true,,,EC_KEY_free,,,0,
472233,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_set_session_cache_mode,,true,,,SSL_CTX_set_session_cache_mode,,,0,
472238,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_sess_set_new_cb,,true,,,SSL_CTX_sess_set_new_cb,,,0,
472243,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,save_session,,true,,,save_session,,,0,
472248,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_new,,true,,,SSL_new,,,0,
472252,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_set_fd,,true,,,SSL_set_fd,,,0,
472257,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_set_connect_state,,true,,,SSL_set_connect_state,,,0,
472261,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_set_accept_state,,true,,,SSL_set_accept_state,,,0,
472265,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_set_ex_data,,true,,,SSL_set_ex_data,,,0,
472271,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_get1_session,,true,,,SSL_get1_session,,,0,
472275,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_get0_session,,true,,,SSL_get0_session,,,0,
472279,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_set_session,,true,,,SSL_set_session,,,0,
472284,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_do_handshake,,true,,,SSL_do_handshake,,,0,
472288,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_get_error,,true,,,SSL_get_error,,,0,
472293,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ERR_peek_error,,true,,,ERR_peek_error,,,0,
472296,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_read,,true,,,SSL_read,,,0,
472302,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_write,,true,,,SSL_write,,,0,
472308,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_in_init,,true,,,SSL_in_init,,,0,
472312,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_free,,true,,,SSL_free,,,0,
472316,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_set_quiet_shutdown,,true,,,SSL_set_quiet_shutdown,,,0,
472321,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_get_shutdown,,true,,,SSL_get_shutdown,,,0,
472325,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_set_shutdown,,true,,,SSL_set_shutdown,,,0,
472330,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_shutdown,,true,,,SSL_shutdown,,,0,
472334,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ERR_GET_REASON,,true,,,ERR_GET_REASON,,,0,
472338,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ERR_peek_error_line_data,,true,,,ERR_peek_error_line_data,,,0,
472345,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ERR_error_string_n,,true,,,ERR_error_string_n,,,0,
472351,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ERR_get_error,,true,,,ERR_get_error,,,0,
472354,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_set_timeout,,true,,,SSL_CTX_set_timeout,,,0,
472359,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_sess_set_cache_size,,true,,,SSL_CTX_sess_set_cache_size,,,0,
472364,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_sess_set_get_cb,,true,,,SSL_CTX_sess_set_get_cb,,,0,
472369,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_sess_set_remove_cb,,true,,,SSL_CTX_sess_set_remove_cb,,,0,
472374,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_MD_CTX_create,,true,,,EVP_MD_CTX_create,,,0,
472377,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_DigestInit_ex,,true,,,EVP_DigestInit_ex,,,0,
472383,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_sha1,,true,,,EVP_sha1,,,0,
472386,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_DigestUpdate,,true,,,EVP_DigestUpdate,,,0,
472392,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_get_ex_data,,true,,,X509_get_ex_data,,,0,
472397,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_digest,,true,,,X509_digest,,,0,
472404,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_get_client_CA_list,,true,,,SSL_CTX_get_client_CA_list,,,0,
472408,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sk_X509_NAME_num,,true,,,sk_X509_NAME_num,,,0,
472412,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sk_X509_NAME_value,,true,,,sk_X509_NAME_value,,,0,
472417,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_NAME_digest,,true,,,X509_NAME_digest,,,0,
472424,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_DigestFinal_ex,,true,,,EVP_DigestFinal_ex,,,0,
472430,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_MD_CTX_destroy,,true,,,EVP_MD_CTX_destroy,,,0,
472434,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_set_session_id_context,,true,,,SSL_CTX_set_session_id_context,,,0,
472440,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,i2d_SSL_SESSION,,true,,,i2d_SSL_SESSION,,,0,
472445,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_SESSION_get_id,,true,,,SSL_SESSION_get_id,,,0,
472450,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_get_timeout,,true,,,SSL_CTX_get_timeout,,,0,
472454,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,d2i_SSL_SESSION,,true,,,d2i_SSL_SESSION,,,0,
472460,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_remove_session,,true,,,SSL_CTX_remove_session,,,0,
472465,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_CTX_free,,true,,,SSL_CTX_free,,,0,
472469,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_get_peer_certificate,,true,,,SSL_get_peer_certificate,,,0,
472473,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_get_ext_d2i,,true,,,X509_get_ext_d2i,,,0,
472480,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sk_GENERAL_NAME_num,,true,,,sk_GENERAL_NAME_num,,,0,
472484,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sk_GENERAL_NAME_value,,true,,,sk_GENERAL_NAME_value,,,0,
472489,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASN1_STRING_length,,true,,,ASN1_STRING_length,,,0,
472493,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASN1_STRING_data,,true,,,ASN1_STRING_data,,,0,
472497,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GENERAL_NAMES_free,,true,,,GENERAL_NAMES_free,,,0,
472501,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_get_subject_name,,true,,,X509_get_subject_name,,,0,
472505,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_NAME_get_index_by_NID,,true,,,X509_NAME_get_index_by_NID,,,0,
472511,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_NAME_get_entry,,true,,,X509_NAME_get_entry,,,0,
472516,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_NAME_ENTRY_get_data,,true,,,X509_NAME_ENTRY_get_data,,,0,
472520,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_get_version,,true,,,SSL_get_version,,,0,
472524,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_get_cipher_name,,true,,,SSL_get_cipher_name,,,0,
472528,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_get_shared_ciphers,,true,,,SSL_get_shared_ciphers,,,0,
472534,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_session_reused,,true,,,SSL_session_reused,,,0,
472538,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIO_new,,true,,,BIO_new,,,0,
472542,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIO_s_mem,,true,,,BIO_s_mem,,,0,
472545,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PEM_write_bio_X509,,true,,,PEM_write_bio_X509,,,0,
472550,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIO_pending,,true,,,BIO_pending,,,0,
472554,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIO_read,,true,,,BIO_read,,,0,
472560,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_NAME_print_ex,,true,,,X509_NAME_print_ex,,,0,
472567,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_get_issuer_name,,true,,,X509_get_issuer_name,,,0,
472571,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_NAME_oneline,,true,,,X509_NAME_oneline,,,0,
472577,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OPENSSL_free,,true,,,OPENSSL_free,,,0,
472581,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,i2a_ASN1_INTEGER,,true,,,i2a_ASN1_INTEGER,,,0,
472586,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_get_serialNumber,,true,,,X509_get_serialNumber,,,0,
472590,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSL_get_verify_result,,true,,,SSL_get_verify_result,,,0,
472594,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_verify_cert_error_string,,true,,,X509_verify_cert_error_string,,,0,
472598,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASN1_TIME_print,,true,,,ASN1_TIME_print,,,0,
472603,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_get_notBefore,,true,,,X509_get_notBefore,,,0,
472607,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,X509_get_notAfter,,true,,,X509_get_notAfter,,,0,
472611,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIO_write,,true,,,BIO_write,,,0,
472617,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BIO_get_mem_data,,true,,,BIO_get_mem_data,,,0,
472622,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ENGINE_set_default,,true,,,ENGINE_set_default,,,0,
472627,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EVP_cleanup,,true,,,EVP_cleanup,,,0,
472630,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ENGINE_cleanup,,true,,,ENGINE_cleanup,,,0,
472633,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,recv_chain,,true,,,recv_chain,,,0,
472640,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_event_pipe_remove_shadow_links,,true,,,ngx_event_pipe_remove_shadow_links,,,0,
472644,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,input_filter,,true,,,input_filter,,,0,
472650,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_queue_add,,true,,,ngx_queue_add,,,0,
472655,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_msec_int_t,,true,,,ngx_msec_int_t,,,0,
472659,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,recvmsg,,true,,,recvmsg,,,0,
472665,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_crc32_init,,true,,,ngx_crc32_init,,,0,
472669,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_crc32_update,,true,,,ngx_crc32_update,,,0,
472675,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_crc32_final,,true,,,ngx_crc32_final,,,0,
472679,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_get_module_loc_conf,,true,,,ngx_http_get_module_loc_conf,,,0,
472684,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_conf_get_module_main_conf,,true,,,ngx_http_conf_get_module_main_conf,,,0,
472689,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_next_header_filter,,true,,,ngx_http_next_header_filter,,,0,
472693,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_set_ctx,,true,,,ngx_http_set_ctx,,,0,
472699,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_clear_content_length,,true,,,ngx_http_clear_content_length,,,0,
472703,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_clear_accept_ranges,,true,,,ngx_http_clear_accept_ranges,,,0,
472707,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_next_body_filter,,true,,,ngx_http_next_body_filter,,,0,
472712,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_get_module_ctx,,true,,,ngx_http_get_module_ctx,,,0,
472717,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_conf_merge_str_value,,true,,,ngx_conf_merge_str_value,,,0,
472723,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_auth_basic_module.c,http\modules\ngx_http_auth_basic_module.c:14:14:NGX_HTTP_AUTH_BUF_SIZE:0,,true,14,14,NGX_HTTP_AUTH_BUF_SIZE,,,0,
472726,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_get_module_main_conf,,true,,,ngx_http_get_module_main_conf,,,0,
472731,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,anonymous_type_0.set_handler,,true,,,set_handler,,,0,
472738,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_conf_merge_ptr_value,,true,,,ngx_conf_merge_ptr_value,,,0,
472744,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_autoindex_module.c,http\modules\ngx_http_autoindex_module.c:48:48:NGX_HTTP_AUTOINDEX_HTML:0,,true,48,48,NGX_HTTP_AUTOINDEX_HTML,,,0,
472747,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_autoindex_module.c,http\modules\ngx_http_autoindex_module.c:49:49:NGX_HTTP_AUTOINDEX_JSON:0,,true,49,49,NGX_HTTP_AUTOINDEX_JSON,,,0,
472750,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_autoindex_module.c,http\modules\ngx_http_autoindex_module.c:50:50:NGX_HTTP_AUTOINDEX_JSONP:0,,true,50,50,NGX_HTTP_AUTOINDEX_JSONP,,,0,
472753,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_autoindex_module.c,http\modules\ngx_http_autoindex_module.c:51:51:NGX_HTTP_AUTOINDEX_XML:0,,true,51,51,NGX_HTTP_AUTOINDEX_XML,,,0,
472756,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_autoindex_module.c,http\modules\ngx_http_autoindex_module.c:53:53:NGX_HTTP_AUTOINDEX_PREALLOCATE:0,,true,53,53,NGX_HTTP_AUTOINDEX_PREALLOCATE,,,0,
472759,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_qsort,,true,,,ngx_qsort,,,0,
472766,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_autoindex_module.c,http\modules\ngx_http_autoindex_module.c:55:55:NGX_HTTP_AUTOINDEX_NAME_LEN:0,,true,55,55,NGX_HTTP_AUTOINDEX_NAME_LEN,,,0,
472769,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_memset,,true,,,ngx_memset,,,0,
472775,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_int_t,,true,,,ngx_int_t,,,0,
472779,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_conf_merge_value,,true,,,ngx_conf_merge_value,,,0,
472785,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_conf_merge_uint_value,,true,,,ngx_conf_merge_uint_value,,,0,
472791,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_browser_module.c,http\modules\ngx_http_browser_module.c:20:20:NGX_HTTP_MODERN_BROWSER:0,,true,20,20,NGX_HTTP_MODERN_BROWSER,,,0,
472794,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_browser_module.c,http\modules\ngx_http_browser_module.c:21:21:NGX_HTTP_ANCIENT_BROWSER:0,,true,21,21,NGX_HTTP_ANCIENT_BROWSER,,,0,
472797,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_strstr,,true,,,ngx_strstr,,,0,
472802,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_charset_filter_module.c,http\modules\ngx_http_charset_filter_module.c:18:18:NGX_UTF_LEN:0,,true,18,18,NGX_UTF_LEN,,,0,
472805,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_charset_filter_module.c,http\modules\ngx_http_charset_filter_module.c:13:13:NGX_HTTP_CHARSET_OFF:0,,true,13,13,NGX_HTTP_CHARSET_OFF,,,0,
472808,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_set_charset,,true,,,ngx_http_set_charset,,,0,
472813,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_charset_filter_module.c,http\modules\ngx_http_charset_filter_module.c:14:14:NGX_HTTP_NO_CHARSET:0,,true,14,14,NGX_HTTP_NO_CHARSET,,,0,
472816,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_charset_filter_module.c,http\modules\ngx_http_charset_filter_module.c:15:15:NGX_HTTP_CHARSET_VAR:0,,true,15,15,NGX_HTTP_CHARSET_VAR,,,0,
472819,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_charset_filter_module.c,http\modules\ngx_http_charset_filter_module.c:20:20:NGX_HTML_ENTITY_LEN:0,,true,20,20,NGX_HTML_ENTITY_LEN,,,0,
472822,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_copy,,true,,,ngx_copy,,,0,
472828,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_dav_module.c,http\modules\ngx_http_dav_module.c:13:13:NGX_HTTP_DAV_OFF:0,,true,13,13,NGX_HTTP_DAV_OFF,,,0,
472831,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_link_info,,true,,,ngx_link_info,,,0,
472836,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_dav_module.c,http\modules\ngx_http_dav_module.c:18:18:NGX_HTTP_DAV_INFINITY_DEPTH:0,,true,18,18,NGX_HTTP_DAV_INFINITY_DEPTH,,,0,
472839,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_delete_dir,,true,,,ngx_delete_dir,,,0,
472843,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_dav_module.c,http\modules\ngx_http_dav_module.c:17:17:NGX_HTTP_DAV_INVALID_DEPTH:0,,true,17,17,NGX_HTTP_DAV_INVALID_DEPTH,,,0,
472846,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_conf_merge_bitmask_value,,true,,,ngx_conf_merge_bitmask_value,,,0,
472852,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sbrk,,true,,,sbrk,,,0,
472856,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_conf_get_module_loc_conf,,true,,,ngx_http_conf_get_module_loc_conf,,,0,
472861,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_fastcgi_module.c,http\modules\ngx_http_fastcgi_module.c:102:102:NGX_HTTP_FASTCGI_BEGIN_REQUEST:0,,true,102,102,NGX_HTTP_FASTCGI_BEGIN_REQUEST,,,0,
472864,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_fastcgi_module.c,http\modules\ngx_http_fastcgi_module.c:98:98:NGX_HTTP_FASTCGI_RESPONDER:0,,true,98,98,NGX_HTTP_FASTCGI_RESPONDER,,,0,
472867,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_fastcgi_module.c,http\modules\ngx_http_fastcgi_module.c:105:105:NGX_HTTP_FASTCGI_PARAMS:0,,true,105,105,NGX_HTTP_FASTCGI_PARAMS,,,0,
472870,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lcode,,true,,,lcode,,,0,
472874,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_fastcgi_module.c,http\modules\ngx_http_fastcgi_module.c:100:100:NGX_HTTP_FASTCGI_KEEP_CONN:0,,true,100,100,NGX_HTTP_FASTCGI_KEEP_CONN,,,0,
472877,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,code,,true,,,code,,,0,
472881,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_alloc_buf,,true,,,ngx_alloc_buf,,,0,
472885,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_fastcgi_module.c,http\modules\ngx_http_fastcgi_module.c:106:106:NGX_HTTP_FASTCGI_STDIN:0,,true,106,106,NGX_HTTP_FASTCGI_STDIN,,,0,
472888,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_log_debug7,,true,,,ngx_log_debug7,,,0,
472902,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_fastcgi_module.c,http\modules\ngx_http_fastcgi_module.c:107:107:NGX_HTTP_FASTCGI_STDOUT:0,,true,107,107,NGX_HTTP_FASTCGI_STDOUT,,,0,
472905,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_fastcgi_module.c,http\modules\ngx_http_fastcgi_module.c:108:108:NGX_HTTP_FASTCGI_STDERR:0,,true,108,108,NGX_HTTP_FASTCGI_STDERR,,,0,
472908,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_fastcgi_module.c,http\modules\ngx_http_fastcgi_module.c:104:104:NGX_HTTP_FASTCGI_END_REQUEST:0,,true,104,104,NGX_HTTP_FASTCGI_END_REQUEST,,,0,
472911,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_conf_merge_msec_value,,true,,,ngx_conf_merge_msec_value,,,0,
472917,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_conf_merge_size_value,,true,,,ngx_conf_merge_size_value,,,0,
472923,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_conf_merge_bufs_value,,true,,,ngx_conf_merge_bufs_value,,,0,
472930,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_geoip_module.c,http\modules\ngx_http_geoip_module.c:16:16:NGX_GEOIP_COUNTRY_CODE:0,,true,16,16,NGX_GEOIP_COUNTRY_CODE,,,0,
472933,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_geoip_module.c,http\modules\ngx_http_geoip_module.c:17:17:NGX_GEOIP_COUNTRY_CODE3:0,,true,17,17,NGX_GEOIP_COUNTRY_CODE3,,,0,
472936,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_geoip_module.c,http\modules\ngx_http_geoip_module.c:18:18:NGX_GEOIP_COUNTRY_NAME:0,,true,18,18,NGX_GEOIP_COUNTRY_NAME,,,0,
472939,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GeoIP_name_by_ipnum,,true,,,GeoIP_name_by_ipnum,,,0,
472944,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GeoIPRecord_delete,,true,,,GeoIPRecord_delete,,,0,
472948,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GeoIP_region_name_by_code,,true,,,GeoIP_region_name_by_code,,,0,
472953,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GeoIP_record_by_ipnum,,true,,,GeoIP_record_by_ipnum,,,0,
472958,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GeoIP_open,,true,,,GeoIP_open,,,0,
472963,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GeoIP_set_charset,,true,,,GeoIP_set_charset,,,0,
472968,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GeoIP_delete,,true,,,GeoIP_delete,,,0,
472972,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_v2_indexed,,true,,,ngx_http_v2_indexed,,,0,
472976,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_v2_inc_indexed,,true,,,ngx_http_v2_inc_indexed,,,0,
472980,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_v2_write_value,,true,,,ngx_http_v2_write_value,,,0,
472987,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_v2_write_name,,true,,,ngx_http_v2_write_name,,,0,
472994,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_gzip_ok,,true,,,ngx_http_gzip_ok,,,0,
472998,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,inflateInit2,,true,,,inflateInit2,,,0,
473003,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,inflate,,true,,,inflate,,,0,
473008,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,inflateReset,,true,,,inflateReset,,,0,
473012,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,inflateEnd,,true,,,inflateEnd,,,0,
473016,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,deflateEnd,,true,,,deflateEnd,,,0,
473020,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,deflateInit2,,true,,,deflateInit2,,,0,
473029,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,deflate,,true,,,deflate,,,0,
473034,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_gzip_static_module.c,http\modules\ngx_http_gzip_static_module.c:13:13:NGX_HTTP_GZIP_STATIC_OFF:0,,true,13,13,NGX_HTTP_GZIP_STATIC_OFF,,,0,
473037,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_gzip_static_module.c,http\modules\ngx_http_gzip_static_module.c:14:14:NGX_HTTP_GZIP_STATIC_ON:0,,true,14,14,NGX_HTTP_GZIP_STATIC_ON,,,0,
473040,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_gzip_static_module.c,http\modules\ngx_http_gzip_static_module.c:15:15:NGX_HTTP_GZIP_STATIC_ALWAYS:0,,true,15,15,NGX_HTTP_GZIP_STATIC_ALWAYS,,,0,
473043,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_header_val_s.handler,,true,,,handler,,,0,
473050,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_image_filter_module.c,http\modules\ngx_http_image_filter_module.c:15:15:NGX_HTTP_IMAGE_OFF:0,,true,15,15,NGX_HTTP_IMAGE_OFF,,,0,
473053,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_image_filter_module.c,http\modules\ngx_http_image_filter_module.c:23:23:NGX_HTTP_IMAGE_START:0,,true,23,23,NGX_HTTP_IMAGE_START,,,0,
473056,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_image_filter_module.c,http\modules\ngx_http_image_filter_module.c:30:30:NGX_HTTP_IMAGE_NONE:0,,true,30,30,NGX_HTTP_IMAGE_NONE,,,0,
473059,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_image_filter_module.c,http\modules\ngx_http_image_filter_module.c:17:17:NGX_HTTP_IMAGE_SIZE:0,,true,17,17,NGX_HTTP_IMAGE_SIZE,,,0,
473062,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_image_filter_module.c,http\modules\ngx_http_image_filter_module.c:27:27:NGX_HTTP_IMAGE_DONE:0,,true,27,27,NGX_HTTP_IMAGE_DONE,,,0,
473065,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_image_filter_module.c,http\modules\ngx_http_image_filter_module.c:16:16:NGX_HTTP_IMAGE_TEST:0,,true,16,16,NGX_HTTP_IMAGE_TEST,,,0,
473068,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_image_filter_module.c,http\modules\ngx_http_image_filter_module.c:26:26:NGX_HTTP_IMAGE_PASS:0,,true,26,26,NGX_HTTP_IMAGE_PASS,,,0,
473071,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_image_filter_module.c,http\modules\ngx_http_image_filter_module.c:24:24:NGX_HTTP_IMAGE_READ:0,,true,24,24,NGX_HTTP_IMAGE_READ,,,0,
473074,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_image_filter_module.c,http\modules\ngx_http_image_filter_module.c:25:25:NGX_HTTP_IMAGE_PROCESS:0,,true,25,25,NGX_HTTP_IMAGE_PROCESS,,,0,
473077,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_image_filter_module.c,http\modules\ngx_http_image_filter_module.c:31:31:NGX_HTTP_IMAGE_JPEG:0,,true,31,31,NGX_HTTP_IMAGE_JPEG,,,0,
473080,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_image_filter_module.c,http\modules\ngx_http_image_filter_module.c:32:32:NGX_HTTP_IMAGE_GIF:0,,true,32,32,NGX_HTTP_IMAGE_GIF,,,0,
473083,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_image_filter_module.c,http\modules\ngx_http_image_filter_module.c:33:33:NGX_HTTP_IMAGE_PNG:0,,true,33,33,NGX_HTTP_IMAGE_PNG,,,0,
473086,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_image_filter_module.c,http\modules\ngx_http_image_filter_module.c:34:34:NGX_HTTP_IMAGE_WEBP:0,,true,34,34,NGX_HTTP_IMAGE_WEBP,,,0,
473089,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_image_filter_module.c,http\modules\ngx_http_image_filter_module.c:37:37:NGX_HTTP_IMAGE_BUFFERED:0,,true,37,37,NGX_HTTP_IMAGE_BUFFERED,,,0,
473092,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_image_filter_module.c,http\modules\ngx_http_image_filter_module.c:20:20:NGX_HTTP_IMAGE_ROTATE:0,,true,20,20,NGX_HTTP_IMAGE_ROTATE,,,0,
473095,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gdImageSX,,true,,,gdImageSX,,,0,
473099,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gdImageSY,,true,,,gdImageSY,,,0,
473103,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gdImageDestroy,,true,,,gdImageDestroy,,,0,
473107,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gdImageColorsTotal,,true,,,gdImageColorsTotal,,,0,
473111,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gdImageGetTransparent,,true,,,gdImageGetTransparent,,,0,
473115,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gdImageRed,,true,,,gdImageRed,,,0,
473120,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gdImageGreen,,true,,,gdImageGreen,,,0,
473125,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gdImageBlue,,true,,,gdImageBlue,,,0,
473130,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gdImageColorTransparent,,true,,,gdImageColorTransparent,,,0,
473135,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_image_filter_module.c,http\modules\ngx_http_image_filter_module.c:18:18:NGX_HTTP_IMAGE_RESIZE:0,,true,18,18,NGX_HTTP_IMAGE_RESIZE,,,0,
473138,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gdImageSaveAlpha,,true,,,gdImageSaveAlpha,,,0,
473143,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gdImageAlphaBlending,,true,,,gdImageAlphaBlending,,,0,
473148,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gdImageCopyResampled,,true,,,gdImageCopyResampled,,,0,
473161,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gdImageTrueColorToPalette,,true,,,gdImageTrueColorToPalette,,,0,
473167,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gdImageCopyRotated,,true,,,gdImageCopyRotated,,,0,
473179,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_image_filter_module.c,http\modules\ngx_http_image_filter_module.c:19:19:NGX_HTTP_IMAGE_CROP:0,,true,19,19,NGX_HTTP_IMAGE_CROP,,,0,
473182,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gdImageCopy,,true,,,gdImageCopy,,,0,
473193,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gdImageColorExact,,true,,,gdImageColorExact,,,0,
473200,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gdImageSharpen,,true,,,gdImageSharpen,,,0,
473205,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gdImageInterlace,,true,,,gdImageInterlace,,,0,
473210,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gdFree,,true,,,gdFree,,,0,
473214,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gdImageCreateFromJpegPtr,,true,,,gdImageCreateFromJpegPtr,,,0,
473219,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gdImageCreateFromGifPtr,,true,,,gdImageCreateFromGifPtr,,,0,
473224,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gdImageCreateFromPngPtr,,true,,,gdImageCreateFromPngPtr,,,0,
473229,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gdImageCreateTrueColor,,true,,,gdImageCreateTrueColor,,,0,
473234,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gdImageCreate,,true,,,gdImageCreate,,,0,
473239,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gdImageJpegPtr,,true,,,gdImageJpegPtr,,,0,
473245,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gdImageGifPtr,,true,,,gdImageGifPtr,,,0,
473250,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gdImagePngPtr,,true,,,gdImagePngPtr,,,0,
473255,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_index_module.c,http\modules\ngx_http_index_module.c:26:26:NGX_HTTP_DEFAULT_INDEX:0,,true,26,26,NGX_HTTP_DEFAULT_INDEX,,,0,
473258,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_limit_conn_module.c,http\modules\ngx_http_limit_conn_module.c:13:13:NGX_HTTP_LIMIT_CONN_PASSED:0,,true,13,13,NGX_HTTP_LIMIT_CONN_PASSED,,,0,
473261,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_limit_conn_cleanup_all,,true,,,ngx_http_limit_conn_cleanup_all,,,0,
473265,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_limit_conn_module.c,http\modules\ngx_http_limit_conn_module.c:15:15:NGX_HTTP_LIMIT_CONN_REJECTED_DRY_RUN:0,,true,15,15,NGX_HTTP_LIMIT_CONN_REJECTED_DRY_RUN,,,0,
473268,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_limit_conn_module.c,http\modules\ngx_http_limit_conn_module.c:14:14:NGX_HTTP_LIMIT_CONN_REJECTED:0,,true,14,14,NGX_HTTP_LIMIT_CONN_REJECTED,,,0,
473271,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_limit_req_module.c,http\modules\ngx_http_limit_req_module.c:17:17:NGX_HTTP_LIMIT_REQ_REJECTED_DRY_RUN:0,,true,17,17,NGX_HTTP_LIMIT_REQ_REJECTED_DRY_RUN,,,0,
473274,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_limit_req_module.c,http\modules\ngx_http_limit_req_module.c:15:15:NGX_HTTP_LIMIT_REQ_REJECTED:0,,true,15,15,NGX_HTTP_LIMIT_REQ_REJECTED,,,0,
473277,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_limit_req_module.c,http\modules\ngx_http_limit_req_module.c:13:13:NGX_HTTP_LIMIT_REQ_PASSED:0,,true,13,13,NGX_HTTP_LIMIT_REQ_PASSED,,,0,
473280,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_limit_req_module.c,http\modules\ngx_http_limit_req_module.c:16:16:NGX_HTTP_LIMIT_REQ_DELAYED_DRY_RUN:0,,true,16,16,NGX_HTTP_LIMIT_REQ_DELAYED_DRY_RUN,,,0,
473283,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_limit_req_module.c,http\modules\ngx_http_limit_req_module.c:14:14:NGX_HTTP_LIMIT_REQ_DELAYED:0,,true,14,14,NGX_HTTP_LIMIT_REQ_DELAYED,,,0,
473286,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_log_op_s.getlen,,true,,,getlen,,,0,
473292,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_log_op_s.run,,true,,,run,,,0,
473299,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_log_module.c,http\modules\ngx_http_log_module.c:94:94:NGX_HTTP_LOG_ESCAPE_JSON:0,,true,94,94,NGX_HTTP_LOG_ESCAPE_JSON,,,0,
473302,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_log_module.c,http\modules\ngx_http_log_module.c:95:95:NGX_HTTP_LOG_ESCAPE_NONE:0,,true,95,95,NGX_HTTP_LOG_ESCAPE_NONE,,,0,
473305,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_log_module.c,http\modules\ngx_http_log_module.c:93:93:NGX_HTTP_LOG_ESCAPE_DEFAULT:0,,true,93,93,NGX_HTTP_LOG_ESCAPE_DEFAULT,,,0,
473308,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_memcached_module.c,http\modules\ngx_http_memcached_module.c:171:171:NGX_HTTP_MEMCACHED_END:0,,true,171,171,NGX_HTTP_MEMCACHED_END,,,0,
473311,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:40:40:NGX_HTTP_MP4_LAST_ATOM:0,,true,40,40,NGX_HTTP_MP4_LAST_ATOM,,,0,
473314,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:38:38:NGX_HTTP_MP4_CO64_DATA:0,,true,38,38,NGX_HTTP_MP4_CO64_DATA,,,0,
473317,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:12:12:NGX_HTTP_MP4_TRAK_ATOM:0,,true,12,12,NGX_HTTP_MP4_TRAK_ATOM,,,0,
473320,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:195:199:ngx_mp4_set_32value:2,,true,195,199,ngx_mp4_set_32value,,,0,
473325,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:183:187:ngx_mp4_set_atom_name:5,,true,183,187,ngx_mp4_set_atom_name,,,0,
473330,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:189:193:ngx_mp4_get_32value:1,,true,189,193,ngx_mp4_get_32value,,,0,
473334,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:201:209:ngx_mp4_get_64value:1,,true,201,209,ngx_mp4_get_64value,,,0,
473338,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:171:180:ngx_mp4_atom_next:2,,true,171,180,ngx_mp4_atom_next,,,0,
473343,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,anonymous_type_0.handler,,true,,,handler,,,0,
473349,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:167:167:ngx_mp4_atom_data:1,,true,167,167,ngx_mp4_atom_data,,,0,
473353,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:1115:1115:NGX_HTTP_MP4_MOOV_BUFFER_EXCESS:0,,true,1115,1115,NGX_HTTP_MP4_MOOV_BUFFER_EXCESS,,,0,
473356,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:211:219:ngx_mp4_set_64value:2,,true,211,219,ngx_mp4_set_64value,,,0,
473361,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:166:166:ngx_mp4_atom_header:1,,true,166,166,ngx_mp4_atom_header,,,0,
473365,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:168:168:ngx_mp4_atom_data_size:1,,true,168,168,ngx_mp4_atom_data_size,,,0,
473369,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:221:222:ngx_mp4_last_trak:1,,true,221,222,ngx_mp4_last_trak,,,0,
473373,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:13:13:NGX_HTTP_MP4_TKHD_ATOM:0,,true,13,13,NGX_HTTP_MP4_TKHD_ATOM,,,0,
473376,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:14:14:NGX_HTTP_MP4_MDIA_ATOM:0,,true,14,14,NGX_HTTP_MP4_MDIA_ATOM,,,0,
473379,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:15:15:NGX_HTTP_MP4_MDHD_ATOM:0,,true,15,15,NGX_HTTP_MP4_MDHD_ATOM,,,0,
473382,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:16:16:NGX_HTTP_MP4_HDLR_ATOM:0,,true,16,16,NGX_HTTP_MP4_HDLR_ATOM,,,0,
473385,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:17:17:NGX_HTTP_MP4_MINF_ATOM:0,,true,17,17,NGX_HTTP_MP4_MINF_ATOM,,,0,
473388,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:18:18:NGX_HTTP_MP4_VMHD_ATOM:0,,true,18,18,NGX_HTTP_MP4_VMHD_ATOM,,,0,
473391,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:19:19:NGX_HTTP_MP4_SMHD_ATOM:0,,true,19,19,NGX_HTTP_MP4_SMHD_ATOM,,,0,
473394,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:20:20:NGX_HTTP_MP4_DINF_ATOM:0,,true,20,20,NGX_HTTP_MP4_DINF_ATOM,,,0,
473397,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:21:21:NGX_HTTP_MP4_STBL_ATOM:0,,true,21,21,NGX_HTTP_MP4_STBL_ATOM,,,0,
473400,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:22:22:NGX_HTTP_MP4_STSD_ATOM:0,,true,22,22,NGX_HTTP_MP4_STSD_ATOM,,,0,
473403,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:23:23:NGX_HTTP_MP4_STTS_ATOM:0,,true,23,23,NGX_HTTP_MP4_STTS_ATOM,,,0,
473406,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:24:24:NGX_HTTP_MP4_STTS_DATA:0,,true,24,24,NGX_HTTP_MP4_STTS_DATA,,,0,
473409,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:25:25:NGX_HTTP_MP4_STSS_ATOM:0,,true,25,25,NGX_HTTP_MP4_STSS_ATOM,,,0,
473412,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:26:26:NGX_HTTP_MP4_STSS_DATA:0,,true,26,26,NGX_HTTP_MP4_STSS_DATA,,,0,
473415,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:27:27:NGX_HTTP_MP4_CTTS_ATOM:0,,true,27,27,NGX_HTTP_MP4_CTTS_ATOM,,,0,
473418,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:28:28:NGX_HTTP_MP4_CTTS_DATA:0,,true,28,28,NGX_HTTP_MP4_CTTS_DATA,,,0,
473421,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:29:29:NGX_HTTP_MP4_STSC_ATOM:0,,true,29,29,NGX_HTTP_MP4_STSC_ATOM,,,0,
473424,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:31:31:NGX_HTTP_MP4_STSC_DATA:0,,true,31,31,NGX_HTTP_MP4_STSC_DATA,,,0,
473427,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:30:30:NGX_HTTP_MP4_STSC_START:0,,true,30,30,NGX_HTTP_MP4_STSC_START,,,0,
473430,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:32:32:NGX_HTTP_MP4_STSC_END:0,,true,32,32,NGX_HTTP_MP4_STSC_END,,,0,
473433,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:33:33:NGX_HTTP_MP4_STSZ_ATOM:0,,true,33,33,NGX_HTTP_MP4_STSZ_ATOM,,,0,
473436,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:34:34:NGX_HTTP_MP4_STSZ_DATA:0,,true,34,34,NGX_HTTP_MP4_STSZ_DATA,,,0,
473439,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:35:35:NGX_HTTP_MP4_STCO_ATOM:0,,true,35,35,NGX_HTTP_MP4_STCO_ATOM,,,0,
473442,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:36:36:NGX_HTTP_MP4_STCO_DATA:0,,true,36,36,NGX_HTTP_MP4_STCO_DATA,,,0,
473445,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_mp4_module.c,http\modules\ngx_http_mp4_module.c:37:37:NGX_HTTP_MP4_CO64_ATOM:0,,true,37,37,NGX_HTTP_MP4_CO64_ATOM,,,0,
473448,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,in_port_t,,true,,,in_port_t,,,0,
473452,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_proxy_rewrite_s.handler,,true,,,handler,,,0,
473461,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_random_index_module.c,http\modules\ngx_http_random_index_module.c:18:18:NGX_HTTP_RANDOM_INDEX_PREALLOCATE:0,,true,18,18,NGX_HTTP_RANDOM_INDEX_PREALLOCATE,,,0,
473464,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_de_is_link,,true,,,ngx_de_is_link,,,0,
473468,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_realip_module.c,http\modules\ngx_http_realip_module.c:13:13:NGX_HTTP_REALIP_XREALIP:0,,true,13,13,NGX_HTTP_REALIP_XREALIP,,,0,
473471,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_realip_module.c,http\modules\ngx_http_realip_module.c:14:14:NGX_HTTP_REALIP_XFWD:0,,true,14,14,NGX_HTTP_REALIP_XFWD,,,0,
473474,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_realip_module.c,http\modules\ngx_http_realip_module.c:16:16:NGX_HTTP_REALIP_PROXY:0,,true,16,16,NGX_HTTP_REALIP_PROXY,,,0,
473477,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_realip_module.c,http\modules\ngx_http_realip_module.c:15:15:NGX_HTTP_REALIP_HEADER:0,,true,15,15,NGX_HTTP_REALIP_HEADER,,,0,
473480,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_referer_module.c,http\modules\ngx_http_referer_module.c:13:13:NGX_HTTP_REFERER_NO_URI_PART:0,,true,13,13,NGX_HTTP_REFERER_NO_URI_PART,,,0,
473483,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_conf_get_module_srv_conf,,true,,,ngx_http_conf_get_module_srv_conf,,,0,
473488,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_get_module_srv_conf,,true,,,ngx_http_get_module_srv_conf,,,0,
473493,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_regex_compile,,true,,,ngx_http_regex_compile,,,0,
473498,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,create_loc_conf,,true,,,create_loc_conf,,,0,
473503,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_ssi_filter_module.c,http\modules\ngx_http_ssi_filter_module.c:220:220:NGX_HTTP_SSI_INCLUDE_VIRTUAL:0,,true,220,220,NGX_HTTP_SSI_INCLUDE_VIRTUAL,,,0,
473506,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_ssi_filter_module.c,http\modules\ngx_http_ssi_filter_module.c:221:221:NGX_HTTP_SSI_INCLUDE_FILE:0,,true,221,221,NGX_HTTP_SSI_INCLUDE_FILE,,,0,
473509,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_ssi_filter_module.c,http\modules\ngx_http_ssi_filter_module.c:222:222:NGX_HTTP_SSI_INCLUDE_WAIT:0,,true,222,222,NGX_HTTP_SSI_INCLUDE_WAIT,,,0,
473512,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_ssi_filter_module.c,http\modules\ngx_http_ssi_filter_module.c:223:223:NGX_HTTP_SSI_INCLUDE_SET:0,,true,223,223,NGX_HTTP_SSI_INCLUDE_SET,,,0,
473515,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_ssi_filter_module.c,http\modules\ngx_http_ssi_filter_module.c:224:224:NGX_HTTP_SSI_INCLUDE_STUB:0,,true,224,224,NGX_HTTP_SSI_INCLUDE_STUB,,,0,
473518,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_ssi_filter_module.c,http\modules\ngx_http_ssi_filter_module.c:226:226:NGX_HTTP_SSI_ECHO_VAR:0,,true,226,226,NGX_HTTP_SSI_ECHO_VAR,,,0,
473521,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_ssi_filter_module.c,http\modules\ngx_http_ssi_filter_module.c:227:227:NGX_HTTP_SSI_ECHO_DEFAULT:0,,true,227,227,NGX_HTTP_SSI_ECHO_DEFAULT,,,0,
473524,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_ssi_filter_module.c,http\modules\ngx_http_ssi_filter_module.c:228:228:NGX_HTTP_SSI_ECHO_ENCODING:0,,true,228,228,NGX_HTTP_SSI_ECHO_ENCODING,,,0,
473527,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_ssi_filter_module.c,http\modules\ngx_http_ssi_filter_module.c:230:230:NGX_HTTP_SSI_CONFIG_ERRMSG:0,,true,230,230,NGX_HTTP_SSI_CONFIG_ERRMSG,,,0,
473530,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_ssi_filter_module.c,http\modules\ngx_http_ssi_filter_module.c:231:231:NGX_HTTP_SSI_CONFIG_TIMEFMT:0,,true,231,231,NGX_HTTP_SSI_CONFIG_TIMEFMT,,,0,
473533,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_ssi_filter_module.c,http\modules\ngx_http_ssi_filter_module.c:233:233:NGX_HTTP_SSI_SET_VAR:0,,true,233,233,NGX_HTTP_SSI_SET_VAR,,,0,
473536,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_ssi_filter_module.c,http\modules\ngx_http_ssi_filter_module.c:234:234:NGX_HTTP_SSI_SET_VALUE:0,,true,234,234,NGX_HTTP_SSI_SET_VALUE,,,0,
473539,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_ssi_filter_module.c,http\modules\ngx_http_ssi_filter_module.c:236:236:NGX_HTTP_SSI_IF_EXPR:0,,true,236,236,NGX_HTTP_SSI_IF_EXPR,,,0,
473542,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_ssi_filter_module.c,http\modules\ngx_http_ssi_filter_module.c:238:238:NGX_HTTP_SSI_BLOCK_NAME:0,,true,238,238,NGX_HTTP_SSI_BLOCK_NAME,,,0,
473545,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_clear_last_modified,,true,,,ngx_http_clear_last_modified,,,0,
473549,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_clear_etag,,true,,,ngx_http_clear_etag,,,0,
473553,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_ssi_filter_module.c,http\modules\ngx_http_ssi_filter_module.c:12:12:NGX_HTTP_SSI_ERROR:0,,true,12,12,NGX_HTTP_SSI_ERROR,,,0,
473556,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_ssi_filter_module.c,http\modules\ngx_http_ssi_filter_module.c:16:16:NGX_HTTP_SSI_ADD_PREFIX:0,,true,16,16,NGX_HTTP_SSI_ADD_PREFIX,,,0,
473559,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_ssi_filter_module.c,http\modules\ngx_http_ssi_filter_module.c:17:17:NGX_HTTP_SSI_ADD_ZERO:0,,true,17,17,NGX_HTTP_SSI_ADD_ZERO,,,0,
473562,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strftime,,true,,,strftime,,,0,
473569,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_ssi_filter_module.c,http\modules\ngx_http_ssi_filter_module.c:14:14:NGX_HTTP_SSI_DATE_LEN:0,,true,14,14,NGX_HTTP_SSI_DATE_LEN,,,0,
473572,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_ssi_filter_module.h,http\modules\ngx_http_ssi_filter_module.h:21:21:NGX_HTTP_SSI_PARAMS_N:0,,true,21,21,NGX_HTTP_SSI_PARAMS_N,,,0,
473575,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_ssl_module.c,http\modules\ngx_http_ssl_module.c:18:18:NGX_DEFAULT_ECDH_CURVE:0,,true,18,18,NGX_DEFAULT_ECDH_CURVE,,,0,
473578,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_ssl_module.c,http\modules\ngx_http_ssl_module.c:17:17:NGX_DEFAULT_CIPHERS:0,,true,17,17,NGX_DEFAULT_CIPHERS,,,0,
473581,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_clear_location,,true,,,ngx_http_clear_location,,,0,
473585,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_conf_upstream_srv_conf,,true,,,ngx_http_conf_upstream_srv_conf,,,0,
473590,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_upstream_rr_peers_rlock,,true,,,ngx_http_upstream_rr_peers_rlock,,,0,
473594,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_upstream_rr_peers_unlock,,true,,,ngx_http_upstream_rr_peers_unlock,,,0,
473598,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,anonymous_type_0.get_rr_peer,,true,,,get_rr_peer,,,0,
473604,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_upstream_rr_peer_lock,,true,,,ngx_http_upstream_rr_peer_lock,,,0,
473609,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_upstream_rr_peer_unlock,,true,,,ngx_http_upstream_rr_peer_unlock,,,0,
473614,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,anonymous_type_1.get_rr_peer,,true,,,get_rr_peer,,,0,
473620,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_upstream_rr_peers_wlock,,true,,,ngx_http_upstream_rr_peers_wlock,,,0,
473624,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,anonymous_type_2.get_rr_peer,,true,,,get_rr_peer,,,0,
473630,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,anonymous_type_3.get_rr_peer,,true,,,get_rr_peer,,,0,
473636,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,anonymous_type_0.original_init_upstream,,true,,,original_init_upstream,,,0,
473642,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,anonymous_type_1.original_init_peer,,true,,,original_init_peer,,,0,
473648,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,anonymous_type_2.original_get_peer,,true,,,original_get_peer,,,0,
473654,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,anonymous_type_3.original_free_peer,,true,,,original_free_peer,,,0,
473661,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,recv,,true,,,recv,,,0,
473668,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_userid_filter_module.c,http\modules\ngx_http_userid_filter_module.c:13:13:NGX_HTTP_USERID_OFF:0,,true,13,13,NGX_HTTP_USERID_OFF,,,0,
473671,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_userid_filter_module.c,http\modules\ngx_http_userid_filter_module.c:14:14:NGX_HTTP_USERID_LOG:0,,true,14,14,NGX_HTTP_USERID_LOG,,,0,
473674,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_userid_filter_module.c,http\modules\ngx_http_userid_filter_module.c:15:15:NGX_HTTP_USERID_V1:0,,true,15,15,NGX_HTTP_USERID_V1,,,0,
473677,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_userid_filter_module.c,http\modules\ngx_http_userid_filter_module.c:16:16:NGX_HTTP_USERID_ON:0,,true,16,16,NGX_HTTP_USERID_ON,,,0,
473680,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_base64_encoded_length,,true,,,ngx_base64_encoded_length,,,0,
473684,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\ngx_http_userid_filter_module.c,http\modules\ngx_http_userid_filter_module.c:19:19:NGX_HTTP_USERID_MAX_EXPIRES:0,,true,19,19,NGX_HTTP_USERID_MAX_EXPIRES,,,0,
473687,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_conf_merge_sec_value,,true,,,ngx_conf_merge_sec_value,,,0,
473693,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,xmlFreeDoc,,true,,,xmlFreeDoc,,,0,
473697,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,xmlFreeParserCtxt,,true,,,xmlFreeParserCtxt,,,0,
473701,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,xmlCreatePushParserCtxt,,true,,,xmlCreatePushParserCtxt,,,0,
473709,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,xmlCtxtUseOptions,,true,,,xmlCtxtUseOptions,,,0,
473714,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,xmlParseChunk,,true,,,xmlParseChunk,,,0,
473721,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vsnprintf,,true,,,vsnprintf,,,0,
473728,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,xsltNewTransformContext,,true,,,xsltNewTransformContext,,,0,
473733,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,xsltFreeTransformContext,,true,,,xsltFreeTransformContext,,,0,
473737,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,xsltApplyStylesheetUser,,true,,,xsltApplyStylesheetUser,,,0,
473746,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,xsltSaveResultToString,,true,,,xsltSaveResultToString,,,0,
473753,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,xsltQuoteOneUserParam,,true,,,xsltQuoteOneUserParam,,,0,
473759,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,xmlParseDTD,,true,,,xmlParseDTD,,,0,
473764,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,xsltParseStylesheetFile,,true,,,xsltParseStylesheetFile,,,0,
473768,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,xmlFreeDtd,,true,,,xmlFreeDtd,,,0,
473772,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,xsltFreeStylesheet,,true,,,xsltFreeStylesheet,,,0,
473776,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,xmlInitParser,,true,,,xmlInitParser,,,0,
473779,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,xsltCleanupGlobals,,true,,,xsltCleanupGlobals,,,0,
473782,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,xmlCleanupParser,,true,,,xmlCleanupParser,,,0,
473785,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,newXS,,true,,,newXS,,,0,
473791,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\modules\perl\ngx_http_perl_module.c,http\modules\perl\ngx_http_perl_module.c:-1:-1:__FILE__:0,,true,-1,-1,__FILE__,,,0,
473794,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gv_stashpv,,true,,,gv_stashpv,,,0,
473799,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dTHXa,,true,,,dTHXa,,,0,
473803,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PERL_SET_CONTEXT,,true,,,PERL_SET_CONTEXT,,,0,
473807,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PERL_SET_INTERP,,true,,,PERL_SET_INTERP,,,0,
473811,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PERL_SYS_INIT,,true,,,PERL_SYS_INIT,,,0,
473816,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,perl_alloc,,true,,,perl_alloc,,,0,
473819,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,perl_construct,,true,,,perl_construct,,,0,
473823,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,perl_parse,,true,,,perl_parse,,,0,
473831,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,get_sv,,true,,,get_sv,,,0,
473836,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SvPV,,true,,,SvPV,,,0,
473841,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,perl_destruct,,true,,,perl_destruct,,,0,
473845,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,perl_free,,true,,,perl_free,,,0,
473849,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_perl_eval_anon_sub,,true,,,ngx_http_perl_eval_anon_sub,,,0,
473854,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,newSVpvn,,true,,,newSVpvn,,,0,
473859,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_cycle_get_module_main_conf,,true,,,ngx_http_cycle_get_module_main_conf,,,0,
473864,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sv_setiv,,true,,,sv_setiv,,,0,
473869,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GvSV,,true,,,GvSV,,,0,
473873,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gv_fetchpv,,true,,,gv_fetchpv,,,0,
473879,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PERL_SYS_TERM,,true,,,PERL_SYS_TERM,,,0,
473882,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,create_main_conf,,true,,,create_main_conf,,,0,
473887,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,create_srv_conf,,true,,,create_srv_conf,,,0,
473892,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,preconfiguration,,true,,,preconfiguration,,,0,
473897,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,init_main_conf,,true,,,init_main_conf,,,0,
473903,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,postconfiguration,,true,,,postconfiguration,,,0,
473908,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,merge_srv_conf,,true,,,merge_srv_conf,,,0,
473915,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,merge_loc_conf,,true,,,merge_loc_conf,,,0,
473922,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_queue_split,,true,,,ngx_queue_split,,,0,
473928,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_queue_insert_tail,,true,,,ngx_queue_insert_tail,,,0,
473933,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\ngx_http_cache.h,http\ngx_http_cache.h:26:26:NGX_HTTP_CACHE_KEY_LEN:0,,true,26,26,NGX_HTTP_CACHE_KEY_LEN,,,0,
473936,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\ngx_http_cache.h,http\ngx_http_cache.h:27:27:NGX_HTTP_CACHE_ETAG_LEN:0,,true,27,27,NGX_HTTP_CACHE_ETAG_LEN,,,0,
473939,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\ngx_http_cache.h,http\ngx_http_cache.h:28:28:NGX_HTTP_CACHE_VARY_LEN:0,,true,28,28,NGX_HTTP_CACHE_VARY_LEN,,,0,
473942,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\ngx_http_core_module.c,http\ngx_http_core_module.c:19:19:NGX_HTTP_REQUEST_BODY_FILE_OFF:0,,true,19,19,NGX_HTTP_REQUEST_BODY_FILE_OFF,,,0,
473945,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\ngx_http_core_module.c,http\ngx_http_core_module.c:20:20:NGX_HTTP_REQUEST_BODY_FILE_ON:0,,true,20,20,NGX_HTTP_REQUEST_BODY_FILE_ON,,,0,
473948,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\ngx_http_core_module.c,http\ngx_http_core_module.c:21:21:NGX_HTTP_REQUEST_BODY_FILE_CLEAN:0,,true,21,21,NGX_HTTP_REQUEST_BODY_FILE_CLEAN,,,0,
473951,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,checker,,true,,,checker,,,0,
473957,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,content_handler,,true,,,content_handler,,,0,
473962,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_set_connection_log,,true,,,ngx_set_connection_log,,,0,
473967,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_top_header_filter,,true,,,ngx_http_top_header_filter,,,0,
473971,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_top_body_filter,,true,,,ngx_http_top_body_filter,,,0,
473976,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_base64_decoded_length,,true,,,ngx_base64_decoded_length,,,0,
473980,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getuid,,true,,,getuid,,,0,
473983,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_conf_merge_off_value,,true,,,ngx_conf_merge_off_value,,,0,
473989,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_set_log_request,,true,,,ngx_http_set_log_request,,,0,
473994,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,write_event_handler,,true,,,write_event_handler,,,0,
474000,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\ngx_http_header_filter_module.c,http\ngx_http_header_filter_module.c:66:66:NGX_HTTP_LAST_2XX:0,,true,66,66,NGX_HTTP_LAST_2XX,,,0,
474003,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\ngx_http_header_filter_module.c,http\ngx_http_header_filter_module.c:80:80:NGX_HTTP_LAST_3XX:0,,true,80,80,NGX_HTTP_LAST_3XX,,,0,
474006,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\ngx_http_header_filter_module.c,http\ngx_http_header_filter_module.c:67:67:NGX_HTTP_OFF_3XX:0,,true,67,67,NGX_HTTP_OFF_3XX,,,0,
474009,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\ngx_http_header_filter_module.c,http\ngx_http_header_filter_module.c:114:114:NGX_HTTP_LAST_4XX:0,,true,114,114,NGX_HTTP_LAST_4XX,,,0,
474012,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\ngx_http_header_filter_module.c,http\ngx_http_header_filter_module.c:81:81:NGX_HTTP_OFF_4XX:0,,true,81,81,NGX_HTTP_OFF_4XX,,,0,
474015,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\ngx_http_header_filter_module.c,http\ngx_http_header_filter_module.c:130:130:NGX_HTTP_LAST_5XX:0,,true,130,130,NGX_HTTP_LAST_5XX,,,0,
474018,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\ngx_http_header_filter_module.c,http\ngx_http_header_filter_module.c:115:115:NGX_HTTP_OFF_5XX:0,,true,115,115,NGX_HTTP_OFF_5XX,,,0,
474021,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\ngx_http_parse.c,http\ngx_http_parse.c:70:71:ngx_str3_cmp:5,,true,70,71,ngx_str3_cmp,,,0,
474028,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\ngx_http_parse.c,http\ngx_http_parse.c:73:74:ngx_str3Ocmp:5,,true,73,74,ngx_str3Ocmp,,,0,
474035,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\ngx_http_parse.c,http\ngx_http_parse.c:76:77:ngx_str4cmp:5,,true,76,77,ngx_str4cmp,,,0,
474043,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\ngx_http_parse.c,http\ngx_http_parse.c:79:80:ngx_str5cmp:6,,true,79,80,ngx_str5cmp,,,0,
474052,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\ngx_http_parse.c,http\ngx_http_parse.c:82:84:ngx_str6cmp:7,,true,82,84,ngx_str6cmp,,,0,
474062,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\ngx_http_parse.c,http\ngx_http_parse.c:86:88:ngx_str7_cmp:9,,true,86,88,ngx_str7_cmp,,,0,
474073,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\ngx_http_parse.c,http\ngx_http_parse.c:90:92:ngx_str8cmp:9,,true,90,92,ngx_str8cmp,,,0,
474085,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\ngx_http_parse.c,http\ngx_http_parse.c:94:96:ngx_str9cmp:10,,true,94,96,ngx_str9cmp,,,0,
474098,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,read_event_handler,,true,,,read_event_handler,,,0,
474104,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_ephemeral,,true,,,ngx_http_ephemeral,,,0,
474108,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,time_t,,true,,,time_t,,,0,
474112,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_set_socket_errno,,true,,,ngx_set_socket_errno,,,0,
474116,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_shutdown_socket,,true,,,ngx_shutdown_socket,,,0,
474121,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,log_handler[i],,true,,,log_handler[i],,,0,
474126,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,log_handler,,true,,,log_handler,,,0,
474133,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\ngx_http_request.h,http\ngx_http_request.h:16:16:NGX_HTTP_LC_HEADER_LEN:0,,true,16,16,NGX_HTTP_LC_HEADER_LEN,,,0,
474136,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_top_request_body_filter,,true,,,ngx_http_top_request_body_filter,,,0,
474141,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\ngx_http_script.c,http\ngx_http_script.c:30:30:ngx_http_script_exit:0,,true,30,30,ngx_http_script_exit,,,0,
474144,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\ngx_http_special_response.c,http\ngx_http_special_response.c:357:357:NGX_HTTP_LAST_3XX:0,,true,357,357,NGX_HTTP_LAST_3XX,,,0,
474147,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\ngx_http_special_response.c,http\ngx_http_special_response.c:345:345:NGX_HTTP_OFF_3XX:0,,true,345,345,NGX_HTTP_OFF_3XX,,,0,
474150,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\ngx_http_special_response.c,http\ngx_http_special_response.c:391:391:NGX_HTTP_LAST_4XX:0,,true,391,391,NGX_HTTP_LAST_4XX,,,0,
474153,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\ngx_http_special_response.c,http\ngx_http_special_response.c:358:358:NGX_HTTP_OFF_4XX:0,,true,358,358,NGX_HTTP_OFF_4XX,,,0,
474156,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\ngx_http_special_response.c,http\ngx_http_special_response.c:410:410:NGX_HTTP_LAST_5XX:0,,true,410,410,NGX_HTTP_LAST_5XX,,,0,
474159,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\ngx_http_special_response.c,http\ngx_http_special_response.c:392:392:NGX_HTTP_OFF_5XX:0,,true,392,392,NGX_HTTP_OFF_5XX,,,0,
474162,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,create_request,,true,,,create_request,,,0,
474167,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,reinit_request,,true,,,reinit_request,,,0,
474172,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,process_header,,true,,,process_header,,,0,
474177,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,copy_handler,,true,,,copy_handler,,,0,
474184,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,input_filter_init,,true,,,input_filter_init,,,0,
474189,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,free,,true,,,free,,,0,
474196,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,finalize_request,,true,,,finalize_request,,,0,
474202,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,rewrite_redirect,,true,,,rewrite_redirect,,,0,
474209,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,rewrite_cookie,,true,,,rewrite_cookie,,,0,
474215,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\ngx_http_upstream_round_robin.c,http\ngx_http_upstream_round_robin.c:13:14:ngx_http_upstream_tries:1,,true,13,14,ngx_http_upstream_tries,,,0,
474219,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_variable,,true,,,ngx_http_variable,,,0,
474223,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,get_handler,,true,,,get_handler,,,0,
474230,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\v2\ngx_http_v2.c,http\v2\ngx_http_v2.c:134:134:ngx_http_v2_index_size:1,,true,134,134,ngx_http_v2_index_size,,,0,
474234,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\v2\ngx_http_v2.c,http\v2\ngx_http_v2.c:24:24:NGX_HTTP_V2_PROTOCOL_ERROR:0,,true,24,24,NGX_HTTP_V2_PROTOCOL_ERROR,,,0,
474237,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\v2\ngx_http_v2.c,http\v2\ngx_http_v2.c:23:23:NGX_HTTP_V2_NO_ERROR:0,,true,23,23,NGX_HTTP_V2_NO_ERROR,,,0,
474240,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\v2\ngx_http_v2.c,http\v2\ngx_http_v2.c:25:25:NGX_HTTP_V2_INTERNAL_ERROR:0,,true,25,25,NGX_HTTP_V2_INTERNAL_ERROR,,,0,
474243,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_v2_parse_uint32,,true,,,ngx_http_v2_parse_uint32,,,0,
474247,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_v2_parse_length,,true,,,ngx_http_v2_parse_length,,,0,
474251,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_v2_parse_sid,,true,,,ngx_http_v2_parse_sid,,,0,
474255,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_v2_parse_type,,true,,,ngx_http_v2_parse_type,,,0,
474259,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\v2\ngx_http_v2.c,http\v2\ngx_http_v2.c:209:210:NGX_HTTP_V2_FRAME_STATES:0,,true,209,210,NGX_HTTP_V2_FRAME_STATES,,,0,
474262,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_v2_frame_states[type],,true,,,ngx_http_v2_frame_states[type],,,0,
474269,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\v2\ngx_http_v2.c,http\v2\ngx_http_v2.c:29:29:NGX_HTTP_V2_SIZE_ERROR:0,,true,29,29,NGX_HTTP_V2_SIZE_ERROR,,,0,
474272,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\v2\ngx_http_v2.c,http\v2\ngx_http_v2.c:26:26:NGX_HTTP_V2_FLOW_CTRL_ERROR:0,,true,26,26,NGX_HTTP_V2_FLOW_CTRL_ERROR,,,0,
474275,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\v2\ngx_http_v2.c,http\v2\ngx_http_v2.c:28:28:NGX_HTTP_V2_STREAM_CLOSED:0,,true,28,28,NGX_HTTP_V2_STREAM_CLOSED,,,0,
474278,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\v2\ngx_http_v2.c,http\v2\ngx_http_v2.c:30:30:NGX_HTTP_V2_REFUSED_STREAM:0,,true,30,30,NGX_HTTP_V2_REFUSED_STREAM,,,0,
474281,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_v2_prefix,,true,,,ngx_http_v2_prefix,,,0,
474285,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\v2\ngx_http_v2.c,http\v2\ngx_http_v2.c:32:32:NGX_HTTP_V2_COMP_ERROR:0,,true,32,32,NGX_HTTP_V2_COMP_ERROR,,,0,
474288,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\v2\ngx_http_v2.c,http\v2\ngx_http_v2.c:34:34:NGX_HTTP_V2_ENHANCE_YOUR_CALM:0,,true,34,34,NGX_HTTP_V2_ENHANCE_YOUR_CALM,,,0,
474291,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\v2\ngx_http_v2.c,http\v2\ngx_http_v2.c:41:41:NGX_HTTP_V2_PRIORITY_SIZE:0,,true,41,41,NGX_HTTP_V2_PRIORITY_SIZE,,,0,
474294,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\v2\ngx_http_v2.c,http\v2\ngx_http_v2.c:40:40:NGX_HTTP_V2_RST_STREAM_SIZE:0,,true,40,40,NGX_HTTP_V2_RST_STREAM_SIZE,,,0,
474297,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\v2\ngx_http_v2.c,http\v2\ngx_http_v2.c:31:31:NGX_HTTP_V2_CANCEL:0,,true,31,31,NGX_HTTP_V2_CANCEL,,,0,
474300,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\v2\ngx_http_v2.c,http\v2\ngx_http_v2.c:46:46:NGX_HTTP_V2_SETTINGS_PARAM_SIZE:0,,true,46,46,NGX_HTTP_V2_SETTINGS_PARAM_SIZE,,,0,
474303,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_v2_parse_uint16,,true,,,ngx_http_v2_parse_uint16,,,0,
474307,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\v2\ngx_http_v2.c,http\v2\ngx_http_v2.c:52:52:NGX_HTTP_V2_INIT_WINDOW_SIZE_SETTING:0,,true,52,52,NGX_HTTP_V2_INIT_WINDOW_SIZE_SETTING,,,0,
474310,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\v2\ngx_http_v2.c,http\v2\ngx_http_v2.c:53:53:NGX_HTTP_V2_MAX_FRAME_SIZE_SETTING:0,,true,53,53,NGX_HTTP_V2_MAX_FRAME_SIZE_SETTING,,,0,
474313,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\v2\ngx_http_v2.c,http\v2\ngx_http_v2.c:50:50:NGX_HTTP_V2_ENABLE_PUSH_SETTING:0,,true,50,50,NGX_HTTP_V2_ENABLE_PUSH_SETTING,,,0,
474316,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\v2\ngx_http_v2.c,http\v2\ngx_http_v2.c:51:51:NGX_HTTP_V2_MAX_STREAMS_SETTING:0,,true,51,51,NGX_HTTP_V2_MAX_STREAMS_SETTING,,,0,
474319,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\v2\ngx_http_v2.c,http\v2\ngx_http_v2.c:49:49:NGX_HTTP_V2_HEADER_TABLE_SIZE_SETTING:0,,true,49,49,NGX_HTTP_V2_HEADER_TABLE_SIZE_SETTING,,,0,
474322,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\v2\ngx_http_v2.c,http\v2\ngx_http_v2.c:39:39:NGX_HTTP_V2_SETTINGS_ACK_SIZE:0,,true,39,39,NGX_HTTP_V2_SETTINGS_ACK_SIZE,,,0,
474325,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_v2_queue_ordered_frame,,true,,,ngx_http_v2_queue_ordered_frame,,,0,
474330,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\v2\ngx_http_v2.c,http\v2\ngx_http_v2.c:42:42:NGX_HTTP_V2_PING_SIZE:0,,true,42,42,NGX_HTTP_V2_PING_SIZE,,,0,
474333,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_v2_queue_blocked_frame,,true,,,ngx_http_v2_queue_blocked_frame,,,0,
474338,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\v2\ngx_http_v2.c,http\v2\ngx_http_v2.c:43:43:NGX_HTTP_V2_GOAWAY_SIZE:0,,true,43,43,NGX_HTTP_V2_GOAWAY_SIZE,,,0,
474341,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\v2\ngx_http_v2.c,http\v2\ngx_http_v2.c:44:44:NGX_HTTP_V2_WINDOW_UPDATE_SIZE:0,,true,44,44,NGX_HTTP_V2_WINDOW_UPDATE_SIZE,,,0,
474344,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_v2_parse_window,,true,,,ngx_http_v2_parse_window,,,0,
474348,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\v2\ngx_http_v2.c,http\v2\ngx_http_v2.c:135:135:ngx_http_v2_index:2,,true,135,135,ngx_http_v2_index,,,0,
474353,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_v2_write_len_and_type,,true,,,ngx_http_v2_write_len_and_type,,,0,
474359,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_v2_write_sid,,true,,,ngx_http_v2_write_sid,,,0,
474364,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_v2_write_uint16,,true,,,ngx_http_v2_write_uint16,,,0,
474369,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_v2_write_uint32,,true,,,ngx_http_v2_write_uint32,,,0,
474374,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\v2\ngx_http_v2.c,http\v2\ngx_http_v2.c:55:55:NGX_HTTP_V2_FRAME_BUFFER_SIZE:0,,true,55,55,NGX_HTTP_V2_FRAME_BUFFER_SIZE,,,0,
474377,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\v2\ngx_http_v2.c,http\v2\ngx_http_v2.c:57:57:NGX_HTTP_V2_ROOT:0,,true,57,57,NGX_HTTP_V2_ROOT,,,0,
474380,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\v2\ngx_http_v2.h,http\v2\ngx_http_v2.h:19:19:NGX_HTTP_V2_STATE_BUFFER_SIZE:0,,true,19,19,NGX_HTTP_V2_STATE_BUFFER_SIZE,,,0,
474383,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\v2\ngx_http_v2_filter_module.c,http\v2\ngx_http_v2_filter_module.c:23:24:ngx_http_v2_literal_size:1,,true,23,24,ngx_http_v2_literal_size,,,0,
474386,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\v2\ngx_http_v2_filter_module.c,http\v2\ngx_http_v2_filter_module.c:21:21:ngx_http_v2_integer_octets:1,,true,21,21,ngx_http_v2_integer_octets,,,0,
474390,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\v2\ngx_http_v2_filter_module.c,http\v2\ngx_http_v2_filter_module.c:51:52:NGX_HTTP_V2_PUSH_HEADERS:0,,true,51,52,NGX_HTTP_V2_PUSH_HEADERS,,,0,
474393,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\v2\ngx_http_v2_filter_module.c,http\v2\ngx_http_v2_filter_module.c:27:27:NGX_HTTP_V2_NO_TRAILERS:0,,true,27,27,NGX_HTTP_V2_NO_TRAILERS,,,0,
474396,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_v2_queue_frame,,true,,,ngx_http_v2_queue_frame,,,0,
474401,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_v2_handle_frame,,true,,,ngx_http_v2_handle_frame,,,0,
474406,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_http_v2_handle_stream,,true,,,ngx_http_v2_handle_stream,,,0,
474411,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\v2\ngx_http_v2_huff_encode.c,http\v2\ngx_http_v2_huff_encode.c:185:186:ngx_http_v2_huff_encode_buf:2,,true,185,186,ngx_http_v2_huff_encode_buf,,,0,
474416,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_conf_init_size_value,,true,,,ngx_conf_init_size_value,,,0,
474421,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\v2\ngx_http_v2_table.c,http\v2\ngx_http_v2_table.c:84:86:NGX_HTTP_V2_STATIC_TABLE_ENTRIES:0,,true,84,86,NGX_HTTP_V2_STATIC_TABLE_ENTRIES,,,0,
474424,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,http\v2\ngx_http_v2_table.c,http\v2\ngx_http_v2_table.c:13:13:NGX_HTTP_V2_TABLE_SIZE:0,,true,13,13,NGX_HTTP_V2_TABLE_SIZE,,,0,
474427,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_mail_get_module_srv_conf,,true,,,ngx_mail_get_module_srv_conf,,,0,
474432,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_mail_set_ctx,,true,,,ngx_mail_set_ctx,,,0,
474438,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_mail_get_module_ctx,,true,,,ngx_mail_get_module_ctx,,,0,
474443,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_mail_auth_http_ctx_s.handler,,true,,,handler,,,0,
474449,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_mail_conf_get_module_main_conf,,true,,,ngx_mail_conf_get_module_main_conf,,,0,
474454,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,init_session,,true,,,init_session,,,0,
474460,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,parse_command,,true,,,parse_command,,,0,
474465,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_toupper,,true,,,ngx_toupper,,,0,
474469,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_mail_conf_get_module_srv_conf,,true,,,ngx_mail_conf_get_module_srv_conf,,,0,
474474,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,mail\ngx_mail_ssl_module.c,mail\ngx_mail_ssl_module.c:14:14:NGX_DEFAULT_ECDH_CURVE:0,,true,14,14,NGX_DEFAULT_ECDH_CURVE,,,0,
474477,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,mail\ngx_mail_ssl_module.c,mail\ngx_mail_ssl_module.c:13:13:NGX_DEFAULT_CIPHERS:0,,true,13,13,NGX_DEFAULT_CIPHERS,,,0,
474480,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sendmsg,,true,,,sendmsg,,,0,
474486,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fork,,true,,,fork,,,0,
474489,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,setsid,,true,,,setsid,,,0,
474492,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,umask,,true,,,umask,,,0,
474496,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dup2,,true,,,dup2,,,0,
474501,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sysctlbyname,,true,,,sysctlbyname,,,0,
474509,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strerror,,true,,,strerror,,,0,
474513,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,aio_read,,true,,,aio_read,,,0,
474517,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,aio_error,,true,,,aio_error,,,0,
474521,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,aio_return,,true,,,aio_return,,,0,
474525,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lseek,,true,,,lseek,,,0,
474531,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,read,,true,,,read,,,0,
474537,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,unlink,,true,,,unlink,,,0,
474541,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,writev,,true,,,writev,,,0,
474547,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,utimes,,true,,,utimes,,,0,
474552,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ftruncate,,true,,,ftruncate,,,0,
474557,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,mmap,,true,,,mmap,,,0,
474566,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,munmap,,true,,,munmap,,,0,
474571,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,opendir,,true,,,opendir,,,0,
474575,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,readdir,,true,,,readdir,,,0,
474579,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,glob,,true,,,glob,,,0,
474586,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,globfree,,true,,,globfree,,,0,
474590,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,stat,,true,,,stat,,,0,
474595,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,syscall,,true,,,syscall,,,0,
474602,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uname,,true,,,uname,,,0,
474606,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,os\unix\ngx_linux_sendfile_chain.c,os\unix\ngx_linux_sendfile_chain.c:43:43:NGX_SENDFILE_MAXSIZE:0,,true,43,43,NGX_SENDFILE_MAXSIZE,,,0,
474609,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_init_setproctitle,,true,,,ngx_init_setproctitle,,,0,
474613,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getpagesize,,true,,,getpagesize,,,0,
474616,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,srandom,,true,,,srandom,,,0,
474620,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,socketpair,,true,,,socketpair,,,0,
474627,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,proc,,true,,,proc,,,0,
474632,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,execve,,true,,,execve,,,0,
474638,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_signal_value,,true,,,ngx_signal_value,,,0,
474642,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,waitpid,,true,,,waitpid,,,0,
474648,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WTERMSIG,,true,,,WTERMSIG,,,0,
474652,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WEXITSTATUS,,true,,,WEXITSTATUS,,,0,
474656,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,raise,,true,,,raise,,,0,
474660,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_abort,,true,,,ngx_abort,,,0,
474663,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,kill,,true,,,kill,,,0,
474668,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,os\unix\ngx_process.h,os\unix\ngx_process.h:47:47:NGX_MAX_PROCESSES:0,,true,47,47,NGX_MAX_PROCESSES,,,0,
474671,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sigaddset,,true,,,sigaddset,,,0,
474676,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sigprocmask,,true,,,sigprocmask,,,0,
474682,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_setproctitle,,true,,,ngx_setproctitle,,,0,
474686,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sigsuspend,,true,,,sigsuspend,,,0,
474690,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,init_process,,true,,,init_process,,,0,
474695,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,exit_process,,true,,,exit_process,,,0,
474700,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,exit_master,,true,,,exit_master,,,0,
474705,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,setpriority,,true,,,setpriority,,,0,
474711,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,setrlimit,,true,,,setrlimit,,,0,
474716,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,setgid,,true,,,setgid,,,0,
474720,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,initgroups,,true,,,initgroups,,,0,
474725,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,setuid,,true,,,setuid,,,0,
474729,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_setaffinity,,true,,,ngx_setaffinity,,,0,
474734,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,chdir,,true,,,chdir,,,0,
474738,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,manager,,true,,,manager,,,0,
474743,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,loader,,true,,,loader,,,0,
474748,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,readv,,true,,,readv,,,0,
474754,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sysinfo,,true,,,sysinfo,,,0,
474760,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_buf_in_memory_only,,true,,,ngx_buf_in_memory_only,,,0,
474764,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,os\unix\ngx_solaris_sendfilev_chain.c,os\unix\ngx_solaris_sendfilev_chain.c:38:38:NGX_SENDFILEVECS:0,,true,38,38,NGX_SENDFILEVECS,,,0,
474767,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sendfilev,,true,,,sendfilev,,,0,
474774,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,os\unix\ngx_sunpro_atomic_sparc64.h,os\unix\ngx_sunpro_atomic_sparc64.h:11:11:NGX_CASA:0,,true,11,11,NGX_CASA,,,0,
474777,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_cond_init,,true,,,pthread_cond_init,,,0,
474782,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_cond_destroy,,true,,,pthread_cond_destroy,,,0,
474786,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_cond_signal,,true,,,pthread_cond_signal,,,0,
474790,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_cond_wait,,true,,,pthread_cond_wait,,,0,
474795,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_self,,true,,,pthread_self,,,0,
474798,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_mutexattr_init,,true,,,pthread_mutexattr_init,,,0,
474802,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_mutexattr_settype,,true,,,pthread_mutexattr_settype,,,0,
474807,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_mutex_init,,true,,,pthread_mutex_init,,,0,
474812,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_mutexattr_destroy,,true,,,pthread_mutexattr_destroy,,,0,
474816,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_mutex_destroy,,true,,,pthread_mutex_destroy,,,0,
474820,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_mutex_lock,,true,,,pthread_mutex_lock,,,0,
474824,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_mutex_unlock,,true,,,pthread_mutex_unlock,,,0,
474828,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,localtime,,true,,,localtime,,,0,
474832,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gmtime,,true,,,gmtime,,,0,
474836,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sendto,,true,,,sendto,,,0,
474845,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MAKELANGID,,true,,,MAKELANGID,,,0,
474850,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FormatMessage,,true,,,FormatMessage,,,0,
474860,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetLastError,,true,,,GetLastError,,,0,
474863,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,os\win32\ngx_event_log.c,os\win32\ngx_event_log.c:11:11:NGX_MAX_ERROR_STR:0,,true,11,11,NGX_MAX_ERROR_STR,,,0,
474866,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetModuleFileName,,true,,,GetModuleFileName,,,0,
474872,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RegCreateKeyEx,,true,,,RegCreateKeyEx,,,0,
474884,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RegSetValueEx,,true,,,RegSetValueEx,,,0,
474893,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RegCloseKey,,true,,,RegCloseKey,,,0,
474897,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RegisterEventSource,,true,,,RegisterEventSource,,,0,
474902,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReportEvent,,true,,,ReportEvent,,,0,
474914,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DeregisterEventSource,,true,,,DeregisterEventSource,,,0,
474918,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,os\win32\ngx_files.c,os\win32\ngx_files.c:12:12:NGX_UTF16_BUFLEN:0,,true,12,12,NGX_UTF16_BUFLEN,,,0,
474921,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CreateFileW,,true,,,CreateFileW,,,0,
474931,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,u_long,,true,,,u_long,,,0,
474935,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReadFile,,true,,,ReadFile,,,0,
474943,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteFile,,true,,,WriteFile,,,0,
474951,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CharToOemBuff,,true,,,CharToOemBuff,,,0,
474957,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MoveFile,,true,,,MoveFile,,,0,
474962,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DeleteFile,,true,,,DeleteFile,,,0,
474966,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetFileAttributesExW,,true,,,GetFileAttributesExW,,,0,
474972,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DWORD,,true,,,DWORD,,,0,
474976,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetFileTime,,true,,,SetFileTime,,,0,
474983,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetFilePointerEx,,true,,,SetFilePointerEx,,,0,
474990,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetEndOfFile,,true,,,SetEndOfFile,,,0,
474994,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CreateFileMapping,,true,,,CreateFileMapping,,,0,
475003,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MapViewOfFile,,true,,,MapViewOfFile,,,0,
475011,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,UnmapViewOfFile,,true,,,UnmapViewOfFile,,,0,
475015,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FindFirstFile,,true,,,FindFirstFile,,,0,
475020,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FindNextFile,,true,,,FindNextFile,,,0,
475025,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FindClose,,true,,,FindClose,,,0,
475029,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetDiskFreeSpace,,true,,,GetDiskFreeSpace,,,0,
475037,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetLongPathNameW,,true,,,GetLongPathNameW,,,0,
475043,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_wcsicmp,,true,,,_wcsicmp,,,0,
475048,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetCommandLine,,true,,,GetCommandLine,,,0,
475051,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WaitForMultipleObjects,,true,,,WaitForMultipleObjects,,,0,
475058,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OpenEvent,,true,,,OpenEvent,,,0,
475064,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ResetEvent,,true,,,ResetEvent,,,0,
475068,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetExitCodeProcess,,true,,,GetExitCodeProcess,,,0,
475073,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TerminateProcess,,true,,,TerminateProcess,,,0,
475078,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CreateProcess,,true,,,CreateProcess,,,0,
475091,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,os\win32\ngx_process.h,os\win32\ngx_process.h:21:22:NGX_PROCESS_SYNC_NAME:0,,true,21,22,NGX_PROCESS_SYNC_NAME,,,0,
475094,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,os\win32\ngx_process.h,os\win32\ngx_process.h:63:63:NGX_MAX_PROCESSES:0,,true,63,63,NGX_MAX_PROCESSES,,,0,
475097,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetEnvironmentVariable,,true,,,SetEnvironmentVariable,,,0,
475102,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CreateMutex,,true,,,CreateMutex,,,0,
475108,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FreeConsole,,true,,,FreeConsole,,,0,
475111,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetConsoleCtrlHandler,,true,,,SetConsoleCtrlHandler,,,0,
475116,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OpenMutex,,true,,,OpenMutex,,,0,
475122,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,srand,,true,,,srand,,,0,
475126,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReleaseMutex,,true,,,ReleaseMutex,,,0,
475130,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WaitForSingleObject,,true,,,WaitForSingleObject,,,0,
475135,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StartServiceCtrlDispatcher,,true,,,StartServiceCtrlDispatcher,,,0,
475139,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RegisterServiceCtrlHandlerEx,,true,,,RegisterServiceCtrlHandlerEx,,,0,
475145,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetServiceStatus,,true,,,SetServiceStatus,,,0,
475150,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,os\win32\ngx_service.c,os\win32\ngx_service.c:9:9:NGX_SERVICE_CONTROL_SHUTDOWN:0,,true,9,9,NGX_SERVICE_CONTROL_SHUTDOWN,,,0,
475153,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,os\win32\ngx_service.c,os\win32\ngx_service.c:10:10:NGX_SERVICE_CONTROL_REOPEN:0,,true,10,10,NGX_SERVICE_CONTROL_REOPEN,,,0,
475156,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,os\win32\ngx_shmem.c,os\win32\ngx_shmem.c:37:37:NGX_SHMEM_BASE:0,,true,37,37,NGX_SHMEM_BASE,,,0,
475159,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MapViewOfFileEx,,true,,,MapViewOfFileEx,,,0,
475168,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ioctlsocket,,true,,,ioctlsocket,,,0,
475174,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetFileAttributes,,true,,,GetFileAttributes,,,0,
475178,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetSystemTimeAsFileTime,,true,,,GetSystemTimeAsFileTime,,,0,
475182,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetTimeZoneInformation,,true,,,GetTimeZoneInformation,,,0,
475186,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WSARecv,,true,,,WSARecv,,,0,
475196,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WSAGetOverlappedResult,,true,,,WSAGetOverlappedResult,,,0,
475204,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetVersionEx,,true,,,GetVersionEx,,,0,
475208,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetSystemInfo,,true,,,GetSystemInfo,,,0,
475212,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,setlocale,,true,,,setlocale,,,0,
475217,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WSAStartup,,true,,,WSAStartup,,,0,
475222,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MAKEWORD,,true,,,MAKEWORD,,,0,
475227,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WSAIoctl,,true,,,WSAIoctl,,,0,
475239,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetEnvironmentVariable,,true,,,GetEnvironmentVariable,,,0,
475245,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,os\win32\ngx_wsarecv_chain.c,os\win32\ngx_wsarecv_chain.c:13:13:NGX_WSABUFS:0,,true,13,13,NGX_WSABUFS,,,0,
475248,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WSASend,,true,,,WSASend,,,0,
475258,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,os\win32\ngx_wsasend_chain.c,os\win32\ngx_wsasend_chain.c:13:13:NGX_WSABUFS:0,,true,13,13,NGX_WSABUFS,,,0,
475261,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_stream_get_module_srv_conf,,true,,,ngx_stream_get_module_srv_conf,,,0,
475266,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_stream_conf_get_module_main_conf,,true,,,ngx_stream_conf_get_module_main_conf,,,0,
475271,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_stream_get_module_main_conf,,true,,,ngx_stream_get_module_main_conf,,,0,
475276,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,stream\ngx_stream_geoip_module.c,stream\ngx_stream_geoip_module.c:16:16:NGX_GEOIP_COUNTRY_CODE:0,,true,16,16,NGX_GEOIP_COUNTRY_CODE,,,0,
475279,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,stream\ngx_stream_geoip_module.c,stream\ngx_stream_geoip_module.c:17:17:NGX_GEOIP_COUNTRY_CODE3:0,,true,17,17,NGX_GEOIP_COUNTRY_CODE3,,,0,
475282,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,stream\ngx_stream_geoip_module.c,stream\ngx_stream_geoip_module.c:18:18:NGX_GEOIP_COUNTRY_NAME:0,,true,18,18,NGX_GEOIP_COUNTRY_NAME,,,0,
475285,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,stream\ngx_stream_limit_conn_module.c,stream\ngx_stream_limit_conn_module.c:13:13:NGX_STREAM_LIMIT_CONN_PASSED:0,,true,13,13,NGX_STREAM_LIMIT_CONN_PASSED,,,0,
475288,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_stream_limit_conn_cleanup_all,,true,,,ngx_stream_limit_conn_cleanup_all,,,0,
475292,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,stream\ngx_stream_limit_conn_module.c,stream\ngx_stream_limit_conn_module.c:15:15:NGX_STREAM_LIMIT_CONN_REJECTED_DRY_RUN:0,,true,15,15,NGX_STREAM_LIMIT_CONN_REJECTED_DRY_RUN,,,0,
475295,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,stream\ngx_stream_limit_conn_module.c,stream\ngx_stream_limit_conn_module.c:14:14:NGX_STREAM_LIMIT_CONN_REJECTED:0,,true,14,14,NGX_STREAM_LIMIT_CONN_REJECTED,,,0,
475298,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_stream_log_op_s.getlen,,true,,,getlen,,,0,
475304,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_stream_log_op_s.run,,true,,,run,,,0,
475311,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,stream\ngx_stream_log_module.c,stream\ngx_stream_log_module.c:93:93:NGX_STREAM_LOG_ESCAPE_JSON:0,,true,93,93,NGX_STREAM_LOG_ESCAPE_JSON,,,0,
475314,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,stream\ngx_stream_log_module.c,stream\ngx_stream_log_module.c:94:94:NGX_STREAM_LOG_ESCAPE_NONE:0,,true,94,94,NGX_STREAM_LOG_ESCAPE_NONE,,,0,
475317,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,stream\ngx_stream_log_module.c,stream\ngx_stream_log_module.c:92:92:NGX_STREAM_LOG_ESCAPE_DEFAULT:0,,true,92,92,NGX_STREAM_LOG_ESCAPE_DEFAULT,,,0,
475320,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,notify,,true,,,notify,,,0,
475327,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_stream_top_filter,,true,,,ngx_stream_top_filter,,,0,
475333,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_stream_conf_get_module_srv_conf,,true,,,ngx_stream_conf_get_module_srv_conf,,,0,
475338,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_stream_set_ctx,,true,,,ngx_stream_set_ctx,,,0,
475344,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_stream_get_module_ctx,,true,,,ngx_stream_get_module_ctx,,,0,
475349,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,stream\ngx_stream_script.c,stream\ngx_stream_script.c:31:31:ngx_stream_script_exit:0,,true,31,31,ngx_stream_script_exit,,,0,
475352,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_ssl_verify_error_optional,,true,,,ngx_ssl_verify_error_optional,,,0,
475356,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,stream\ngx_stream_ssl_module.c,stream\ngx_stream_ssl_module.c:18:18:NGX_DEFAULT_ECDH_CURVE:0,,true,18,18,NGX_DEFAULT_ECDH_CURVE,,,0,
475359,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,stream\ngx_stream_ssl_module.c,stream\ngx_stream_ssl_module.c:17:17:NGX_DEFAULT_CIPHERS:0,,true,17,17,NGX_DEFAULT_CIPHERS,,,0,
475362,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_stream_conf_upstream_srv_conf,,true,,,ngx_stream_conf_upstream_srv_conf,,,0,
475367,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_stream_upstream_rr_peers_rlock,,true,,,ngx_stream_upstream_rr_peers_rlock,,,0,
475371,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_stream_upstream_rr_peers_unlock,,true,,,ngx_stream_upstream_rr_peers_unlock,,,0,
475375,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_stream_upstream_rr_peer_lock,,true,,,ngx_stream_upstream_rr_peer_lock,,,0,
475380,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_stream_upstream_rr_peer_unlock,,true,,,ngx_stream_upstream_rr_peer_unlock,,,0,
475385,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_stream_upstream_rr_peers_wlock,,true,,,ngx_stream_upstream_rr_peers_wlock,,,0,
475389,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,stream\ngx_stream_upstream_round_robin.c,stream\ngx_stream_upstream_round_robin.c:13:14:ngx_stream_upstream_tries:1,,true,13,14,ngx_stream_upstream_tries,,,0,
475393,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ngx_stream_variable,,true,,,ngx_stream_variable,,,0,
